Project Path: arc_gmh5225_KDemu__x0ojye1

Source Tree:

```txt
arc_gmh5225_KDemu__x0ojye1
├── CppProperties.json
├── KDemu
│   ├── Emulate.cpp
│   ├── Emulate.hpp
│   ├── Global.cpp
│   ├── Global.h
│   ├── KDemu.cpp
│   ├── KDemu.vcxproj
│   ├── KDemu.vcxproj.filters
│   ├── KDemu.vcxproj.user
│   ├── LoadPE.cpp
│   ├── LoadPE.hpp
│   ├── NtType.hpp
│   ├── UnicornEmu.hpp
│   ├── ci.dll
│   ├── cng.sys
│   ├── cpu.h
│   ├── fltMgr.sys
│   ├── hal.dll
│   ├── include
│   │   ├── LIEF
│   │   │   └── LIEF
│   │   │       ├── ART
│   │   │       │   ├── EnumToString.hpp
│   │   │       │   ├── File.hpp
│   │   │       │   ├── Header.hpp
│   │   │       │   ├── Parser.hpp
│   │   │       │   ├── enums.hpp
│   │   │       │   ├── hash.hpp
│   │   │       │   ├── java_structures.hpp
│   │   │       │   ├── json.hpp
│   │   │       │   ├── types.hpp
│   │   │       │   └── utils.hpp
│   │   │       ├── ART.hpp
│   │   │       ├── Abstract
│   │   │       │   ├── Binary.hpp
│   │   │       │   ├── DebugInfo.hpp
│   │   │       │   ├── EnumToString.hpp
│   │   │       │   ├── Function.hpp
│   │   │       │   ├── Header.hpp
│   │   │       │   ├── Parser.hpp
│   │   │       │   ├── Relocation.hpp
│   │   │       │   ├── Section.hpp
│   │   │       │   ├── Symbol.hpp
│   │   │       │   ├── enums.hpp
│   │   │       │   ├── hash.hpp
│   │   │       │   └── json.hpp
│   │   │       ├── Abstract.hpp
│   │   │       ├── BinaryStream
│   │   │       │   ├── ASN1Reader.hpp
│   │   │       │   ├── BinaryStream.hpp
│   │   │       │   ├── Convert.hpp
│   │   │       │   ├── FileStream.hpp
│   │   │       │   ├── MemoryStream.hpp
│   │   │       │   ├── SpanStream.hpp
│   │   │       │   └── VectorStream.hpp
│   │   │       ├── DEX
│   │   │       │   ├── Class.hpp
│   │   │       │   ├── CodeInfo.hpp
│   │   │       │   ├── EnumToString.hpp
│   │   │       │   ├── Field.hpp
│   │   │       │   ├── File.hpp
│   │   │       │   ├── Header.hpp
│   │   │       │   ├── MapItem.hpp
│   │   │       │   ├── MapList.hpp
│   │   │       │   ├── Method.hpp
│   │   │       │   ├── Parser.hpp
│   │   │       │   ├── Prototype.hpp
│   │   │       │   ├── Type.hpp
│   │   │       │   ├── deopt.hpp
│   │   │       │   ├── enums.hpp
│   │   │       │   ├── hash.hpp
│   │   │       │   ├── instructions.hpp
│   │   │       │   ├── json.hpp
│   │   │       │   ├── types.hpp
│   │   │       │   └── utils.hpp
│   │   │       ├── DEX.hpp
│   │   │       ├── DWARF
│   │   │       │   ├── CompilationUnit.hpp
│   │   │       │   ├── DebugInfo.hpp
│   │   │       │   ├── Function.hpp
│   │   │       │   ├── Scope.hpp
│   │   │       │   ├── Type.hpp
│   │   │       │   ├── Variable.hpp
│   │   │       │   ├── enums.hpp
│   │   │       │   ├── types
│   │   │       │   │   ├── Array.hpp
│   │   │       │   │   ├── Base.hpp
│   │   │       │   │   ├── ClassLike.hpp
│   │   │       │   │   ├── Const.hpp
│   │   │       │   │   └── Pointer.hpp
│   │   │       │   └── types.hpp
│   │   │       ├── DWARF.hpp
│   │   │       ├── ELF
│   │   │       │   ├── Binary.h
│   │   │       │   ├── Binary.hpp
│   │   │       │   ├── Builder.hpp
│   │   │       │   ├── DynamicEntry.h
│   │   │       │   ├── DynamicEntry.hpp
│   │   │       │   ├── DynamicEntryArray.hpp
│   │   │       │   ├── DynamicEntryFlags.hpp
│   │   │       │   ├── DynamicEntryLibrary.hpp
│   │   │       │   ├── DynamicEntryRpath.hpp
│   │   │       │   ├── DynamicEntryRunPath.hpp
│   │   │       │   ├── DynamicSharedObject.hpp
│   │   │       │   ├── EnumToString.hpp
│   │   │       │   ├── GnuHash.hpp
│   │   │       │   ├── Header.h
│   │   │       │   ├── Header.hpp
│   │   │       │   ├── Note.hpp
│   │   │       │   ├── NoteDetails
│   │   │       │   │   ├── AndroidIdent.hpp
│   │   │       │   │   ├── Core.hpp
│   │   │       │   │   ├── NoteAbi.hpp
│   │   │       │   │   ├── NoteGnuProperty.hpp
│   │   │       │   │   ├── Properties.hpp
│   │   │       │   │   ├── QNXStack.hpp
│   │   │       │   │   ├── core
│   │   │       │   │   │   ├── CoreAuxv.hpp
│   │   │       │   │   │   ├── CoreFile.hpp
│   │   │       │   │   │   ├── CorePrPsInfo.hpp
│   │   │       │   │   │   ├── CorePrStatus.hpp
│   │   │       │   │   │   └── CoreSigInfo.hpp
│   │   │       │   │   └── properties
│   │   │       │   │       ├── AArch64Feature.hpp
│   │   │       │   │       ├── Generic.hpp
│   │   │       │   │       ├── Needed.hpp
│   │   │       │   │       ├── NoteNoCopyOnProtected.hpp
│   │   │       │   │       ├── StackSize.hpp
│   │   │       │   │       ├── X86Feature.hpp
│   │   │       │   │       └── X86ISA.hpp
│   │   │       │   ├── NoteDetails.hpp
│   │   │       │   ├── Parser.hpp
│   │   │       │   ├── ParserConfig.hpp
│   │   │       │   ├── ProcessorFlags.hpp
│   │   │       │   ├── Relocation.hpp
│   │   │       │   ├── Relocations
│   │   │       │   │   ├── AArch64.def
│   │   │       │   │   ├── ARM.def
│   │   │       │   │   ├── Hexagon.def
│   │   │       │   │   ├── LoongArch.def
│   │   │       │   │   ├── Mips.def
│   │   │       │   │   ├── PowerPC.def
│   │   │       │   │   ├── PowerPC64.def
│   │   │       │   │   ├── Sparc.def
│   │   │       │   │   ├── SystemZ.def
│   │   │       │   │   ├── i386.def
│   │   │       │   │   └── x86_64.def
│   │   │       │   ├── Section.h
│   │   │       │   ├── Section.hpp
│   │   │       │   ├── Segment.h
│   │   │       │   ├── Segment.hpp
│   │   │       │   ├── Symbol.h
│   │   │       │   ├── Symbol.hpp
│   │   │       │   ├── SymbolVersion.hpp
│   │   │       │   ├── SymbolVersionAux.hpp
│   │   │       │   ├── SymbolVersionAuxRequirement.hpp
│   │   │       │   ├── SymbolVersionDefinition.hpp
│   │   │       │   ├── SymbolVersionRequirement.hpp
│   │   │       │   ├── SysvHash.hpp
│   │   │       │   ├── enums.h
│   │   │       │   ├── enums.hpp
│   │   │       │   ├── enums.inc
│   │   │       │   ├── hash.hpp
│   │   │       │   ├── json.hpp
│   │   │       │   ├── undef.h
│   │   │       │   ├── utils.h
│   │   │       │   └── utils.hpp
│   │   │       ├── ELF.h
│   │   │       ├── ELF.hpp
│   │   │       ├── LIEF.h
│   │   │       ├── LIEF.hpp
│   │   │       ├── MachO
│   │   │       │   ├── Binary.h
│   │   │       │   ├── Binary.hpp
│   │   │       │   ├── BinaryParser.hpp
│   │   │       │   ├── BindingInfo.hpp
│   │   │       │   ├── BuildToolVersion.hpp
│   │   │       │   ├── BuildVersion.hpp
│   │   │       │   ├── Builder.hpp
│   │   │       │   ├── ChainedBindingInfo.hpp
│   │   │       │   ├── CodeSignature.hpp
│   │   │       │   ├── CodeSignatureDir.hpp
│   │   │       │   ├── DataCodeEntry.hpp
│   │   │       │   ├── DataInCode.hpp
│   │   │       │   ├── DyldBindingInfo.hpp
│   │   │       │   ├── DyldChainedFixups.hpp
│   │   │       │   ├── DyldChainedFormat.hpp
│   │   │       │   ├── DyldEnvironment.hpp
│   │   │       │   ├── DyldExportsTrie.hpp
│   │   │       │   ├── DyldInfo.hpp
│   │   │       │   ├── DylibCommand.hpp
│   │   │       │   ├── DylinkerCommand.hpp
│   │   │       │   ├── DynamicSymbolCommand.hpp
│   │   │       │   ├── EncryptionInfo.hpp
│   │   │       │   ├── EnumToString.hpp
│   │   │       │   ├── ExportInfo.hpp
│   │   │       │   ├── FatBinary.hpp
│   │   │       │   ├── FilesetCommand.hpp
│   │   │       │   ├── FunctionStarts.hpp
│   │   │       │   ├── Header.h
│   │   │       │   ├── Header.hpp
│   │   │       │   ├── LinkEdit.hpp
│   │   │       │   ├── LinkerOptHint.hpp
│   │   │       │   ├── LoadCommand.h
│   │   │       │   ├── LoadCommand.hpp
│   │   │       │   ├── MainCommand.hpp
│   │   │       │   ├── Parser.hpp
│   │   │       │   ├── ParserConfig.hpp
│   │   │       │   ├── RPathCommand.hpp
│   │   │       │   ├── Relocation.hpp
│   │   │       │   ├── RelocationDyld.hpp
│   │   │       │   ├── RelocationFixup.hpp
│   │   │       │   ├── RelocationObject.hpp
│   │   │       │   ├── Section.h
│   │   │       │   ├── Section.hpp
│   │   │       │   ├── Segment.h
│   │   │       │   ├── SegmentCommand.hpp
│   │   │       │   ├── SegmentSplitInfo.hpp
│   │   │       │   ├── SourceVersion.hpp
│   │   │       │   ├── SubFramework.hpp
│   │   │       │   ├── Symbol.h
│   │   │       │   ├── Symbol.hpp
│   │   │       │   ├── SymbolCommand.hpp
│   │   │       │   ├── ThreadCommand.hpp
│   │   │       │   ├── TwoLevelHints.hpp
│   │   │       │   ├── UUIDCommand.hpp
│   │   │       │   ├── UnknownCommand.hpp
│   │   │       │   ├── VersionMin.hpp
│   │   │       │   ├── enums.h
│   │   │       │   ├── enums.hpp
│   │   │       │   ├── enums.inc
│   │   │       │   ├── hash.hpp
│   │   │       │   ├── json.hpp
│   │   │       │   ├── type_traits.hpp
│   │   │       │   ├── undef.h
│   │   │       │   └── utils.hpp
│   │   │       ├── MachO.h
│   │   │       ├── MachO.hpp
│   │   │       ├── OAT
│   │   │       │   ├── Binary.hpp
│   │   │       │   ├── Class.hpp
│   │   │       │   ├── DexFile.hpp
│   │   │       │   ├── EnumToString.hpp
│   │   │       │   ├── Header.hpp
│   │   │       │   ├── Method.hpp
│   │   │       │   ├── Parser.hpp
│   │   │       │   ├── enums.hpp
│   │   │       │   ├── hash.hpp
│   │   │       │   ├── json.hpp
│   │   │       │   ├── type_traits.hpp
│   │   │       │   └── utils.hpp
│   │   │       ├── OAT.hpp
│   │   │       ├── ObjC
│   │   │       │   ├── Class.hpp
│   │   │       │   ├── IVar.hpp
│   │   │       │   ├── Metadata.hpp
│   │   │       │   ├── Method.hpp
│   │   │       │   ├── Property.hpp
│   │   │       │   └── Protocol.hpp
│   │   │       ├── ObjC.hpp
│   │   │       ├── Object.hpp
│   │   │       ├── PDB
│   │   │       │   ├── CompilationUnit.hpp
│   │   │       │   ├── DebugInfo.hpp
│   │   │       │   ├── Function.hpp
│   │   │       │   ├── PublicSymbol.hpp
│   │   │       │   ├── Type.hpp
│   │   │       │   ├── types
│   │   │       │   │   ├── Array.hpp
│   │   │       │   │   ├── Attribute.hpp
│   │   │       │   │   ├── BitField.hpp
│   │   │       │   │   ├── ClassLike.hpp
│   │   │       │   │   ├── Enum.hpp
│   │   │       │   │   ├── Function.hpp
│   │   │       │   │   ├── Method.hpp
│   │   │       │   │   ├── Modifier.hpp
│   │   │       │   │   ├── Pointer.hpp
│   │   │       │   │   ├── Simple.hpp
│   │   │       │   │   └── Union.hpp
│   │   │       │   └── types.hpp
│   │   │       ├── PDB.hpp
│   │   │       ├── PE
│   │   │       │   ├── AuxiliarySymbol.hpp
│   │   │       │   ├── Binary.h
│   │   │       │   ├── Binary.hpp
│   │   │       │   ├── Builder.hpp
│   │   │       │   ├── CodeIntegrity.hpp
│   │   │       │   ├── DataDirectory.h
│   │   │       │   ├── DataDirectory.hpp
│   │   │       │   ├── Debug.hpp
│   │   │       │   ├── DelayImport.hpp
│   │   │       │   ├── DelayImportEntry.hpp
│   │   │       │   ├── DosHeader.h
│   │   │       │   ├── DosHeader.hpp
│   │   │       │   ├── EnumToString.h
│   │   │       │   ├── EnumToString.hpp
│   │   │       │   ├── Export.hpp
│   │   │       │   ├── ExportEntry.hpp
│   │   │       │   ├── Header.h
│   │   │       │   ├── Header.hpp
│   │   │       │   ├── Import.h
│   │   │       │   ├── Import.hpp
│   │   │       │   ├── ImportEntry.h
│   │   │       │   ├── ImportEntry.hpp
│   │   │       │   ├── LoadConfigurations
│   │   │       │   │   ├── LoadConfiguration.hpp
│   │   │       │   │   ├── LoadConfigurationV0.hpp
│   │   │       │   │   ├── LoadConfigurationV1.hpp
│   │   │       │   │   ├── LoadConfigurationV10.hpp
│   │   │       │   │   ├── LoadConfigurationV11.hpp
│   │   │       │   │   ├── LoadConfigurationV2.hpp
│   │   │       │   │   ├── LoadConfigurationV3.hpp
│   │   │       │   │   ├── LoadConfigurationV4.hpp
│   │   │       │   │   ├── LoadConfigurationV5.hpp
│   │   │       │   │   ├── LoadConfigurationV6.hpp
│   │   │       │   │   ├── LoadConfigurationV7.hpp
│   │   │       │   │   ├── LoadConfigurationV8.hpp
│   │   │       │   │   └── LoadConfigurationV9.hpp
│   │   │       │   ├── LoadConfigurations.hpp
│   │   │       │   ├── OptionalHeader.h
│   │   │       │   ├── OptionalHeader.hpp
│   │   │       │   ├── Parser.hpp
│   │   │       │   ├── ParserConfig.hpp
│   │   │       │   ├── Relocation.hpp
│   │   │       │   ├── RelocationEntry.hpp
│   │   │       │   ├── ResourceData.hpp
│   │   │       │   ├── ResourceDirectory.hpp
│   │   │       │   ├── ResourceNode.hpp
│   │   │       │   ├── ResourcesManager.hpp
│   │   │       │   ├── RichEntry.hpp
│   │   │       │   ├── RichHeader.hpp
│   │   │       │   ├── Section.h
│   │   │       │   ├── Section.hpp
│   │   │       │   ├── Symbol.hpp
│   │   │       │   ├── TLS.hpp
│   │   │       │   ├── debug
│   │   │       │   │   ├── CodeView.hpp
│   │   │       │   │   ├── CodeViewPDB.hpp
│   │   │       │   │   ├── Debug.hpp
│   │   │       │   │   ├── Pogo.hpp
│   │   │       │   │   ├── PogoEntry.hpp
│   │   │       │   │   └── Repro.hpp
│   │   │       │   ├── enums.h
│   │   │       │   ├── enums.hpp
│   │   │       │   ├── enums.inc
│   │   │       │   ├── hash.hpp
│   │   │       │   ├── json.hpp
│   │   │       │   ├── resources
│   │   │       │   │   ├── LangCodeItem.hpp
│   │   │       │   │   ├── ResourceAccelerator.hpp
│   │   │       │   │   ├── ResourceDialog.hpp
│   │   │       │   │   ├── ResourceDialogItem.hpp
│   │   │       │   │   ├── ResourceFixedFileInfo.hpp
│   │   │       │   │   ├── ResourceIcon.hpp
│   │   │       │   │   ├── ResourceStringFileInfo.hpp
│   │   │       │   │   ├── ResourceStringTable.hpp
│   │   │       │   │   ├── ResourceVarFileInfo.hpp
│   │   │       │   │   ├── ResourceVersion.hpp
│   │   │       │   │   └── langs.hpp
│   │   │       │   ├── signature
│   │   │       │   │   ├── Attribute.hpp
│   │   │       │   │   ├── ContentInfo.hpp
│   │   │       │   │   ├── GenericContent.hpp
│   │   │       │   │   ├── OIDToString.hpp
│   │   │       │   │   ├── PKCS9TSTInfo.hpp
│   │   │       │   │   ├── RsaInfo.hpp
│   │   │       │   │   ├── Signature.hpp
│   │   │       │   │   ├── SignatureParser.hpp
│   │   │       │   │   ├── SignerInfo.hpp
│   │   │       │   │   ├── SpcIndirectData.hpp
│   │   │       │   │   ├── attributes
│   │   │       │   │   │   ├── ContentType.hpp
│   │   │       │   │   │   ├── GenericType.hpp
│   │   │       │   │   │   ├── MsCounterSign.hpp
│   │   │       │   │   │   ├── MsManifestBinaryID.hpp
│   │   │       │   │   │   ├── MsSpcNestedSignature.hpp
│   │   │       │   │   │   ├── MsSpcStatementType.hpp
│   │   │       │   │   │   ├── PKCS9AtSequenceNumber.hpp
│   │   │       │   │   │   ├── PKCS9CounterSignature.hpp
│   │   │       │   │   │   ├── PKCS9MessageDigest.hpp
│   │   │       │   │   │   ├── PKCS9SigningTime.hpp
│   │   │       │   │   │   ├── SigningCertificateV2.hpp
│   │   │       │   │   │   ├── SpcRelaxedPeMarkerCheck.hpp
│   │   │       │   │   │   └── SpcSpOpusInfo.hpp
│   │   │       │   │   ├── attributes.hpp
│   │   │       │   │   ├── types.hpp
│   │   │       │   │   └── x509.hpp
│   │   │       │   ├── undef.h
│   │   │       │   └── utils.hpp
│   │   │       ├── PE.h
│   │   │       ├── PE.hpp
│   │   │       ├── VDEX
│   │   │       │   ├── File.hpp
│   │   │       │   ├── Header.hpp
│   │   │       │   ├── Parser.hpp
│   │   │       │   ├── hash.hpp
│   │   │       │   ├── json.hpp
│   │   │       │   ├── type_traits.hpp
│   │   │       │   └── utils.hpp
│   │   │       ├── VDEX.hpp
│   │   │       ├── Visitor.hpp
│   │   │       ├── canbe_unique.hpp
│   │   │       ├── compiler_attributes.hpp
│   │   │       ├── config.h
│   │   │       ├── debug_loc.hpp
│   │   │       ├── enums.hpp
│   │   │       ├── errors.hpp
│   │   │       ├── hash.hpp
│   │   │       ├── iostream.hpp
│   │   │       ├── iterators.hpp
│   │   │       ├── json.hpp
│   │   │       ├── logging.h
│   │   │       ├── logging.hpp
│   │   │       ├── platforms
│   │   │       │   ├── android
│   │   │       │   │   └── version.hpp
│   │   │       │   └── android.hpp
│   │   │       ├── platforms.hpp
│   │   │       ├── range.hpp
│   │   │       ├── span.hpp
│   │   │       ├── third-party
│   │   │       │   ├── expected.hpp
│   │   │       │   ├── internal
│   │   │       │   │   ├── expected.hpp
│   │   │       │   │   └── span.hpp
│   │   │       │   └── span.hpp
│   │   │       ├── to_json.hpp
│   │   │       ├── types.h
│   │   │       ├── types.hpp
│   │   │       ├── utils.hpp
│   │   │       ├── version.h
│   │   │       ├── visibility.h
│   │   │       └── visitor_macros.hpp
│   │   ├── capstone
│   │   │   └── capstone
│   │   │       ├── arm.h
│   │   │       ├── arm64.h
│   │   │       ├── capstone.h
│   │   │       ├── evm.h
│   │   │       ├── m680x.h
│   │   │       ├── m68k.h
│   │   │       ├── mips.h
│   │   │       ├── platform.h
│   │   │       ├── ppc.h
│   │   │       ├── sparc.h
│   │   │       ├── systemz.h
│   │   │       ├── tms320c64x.h
│   │   │       ├── x86.h
│   │   │       └── xcore.h
│   │   ├── kdmp-parser
│   │   │   ├── filemap.h
│   │   │   ├── kdmp-parser-structs.h
│   │   │   ├── kdmp-parser-version.h.in
│   │   │   ├── kdmp-parser.h
│   │   │   └── platform.h
│   │   └── unicorn
│   │       ├── list.h
│   │       ├── qemu.h
│   │       ├── uc_priv.h
│   │       └── unicorn
│   │           ├── arm.h
│   │           ├── arm64.h
│   │           ├── m68k.h
│   │           ├── mips.h
│   │           ├── platform.h
│   │           ├── ppc.h
│   │           ├── riscv.h
│   │           ├── s390x.h
│   │           ├── sparc.h
│   │           ├── tricore.h
│   │           ├── unicorn.h
│   │           └── x86.h
│   ├── kdmp-parser
│   │   ├── filemap.h
│   │   ├── kdmp-parser-structs.h
│   │   ├── kdmp-parser-version.h.in
│   │   ├── kdmp-parser.h
│   │   └── platform.h
│   ├── lib
│   │   ├── LIEF.lib
│   │   ├── capstone.lib
│   │   └── unicorn-import.lib
│   ├── multithread.sys
│   ├── ntdll.dll
│   ├── ucrtbase.dll
│   ├── udbserver.dll
│   ├── unicorn
│   │   └── unicorn
│   │       ├── arm.h
│   │       ├── arm64.h
│   │       ├── m68k.h
│   │       ├── mips.h
│   │       ├── platform.h
│   │       ├── ppc.h
│   │       ├── riscv.h
│   │       ├── s390x.h
│   │       ├── sparc.h
│   │       ├── tricore.h
│   │       ├── unicorn.h
│   │       └── x86.h
│   ├── unicorn.cpp
│   └── vgk_new.sys
├── KDemu.sln
├── README.md
├── vcpkg-configuration.json
└── vcpkg.json

```

`CppProperties.json`:

```json
{
  "configurations": [
    {
      "inheritEnvironments": [
        "msvc_x64"
      ],
      "name": "x64-Debug",
      "includePath": [
        "${env.INCLUDE}",
        "${workspaceRoot}\\**"
      ],
      "defines": [
        "WIN32",
        "_DEBUG",
        "UNICODE",
        "_UNICODE"
      ],
      "intelliSenseMode": "windows-msvc-x64"
    }
  ]
}
```

`KDemu.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.8.34408.163
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "KDemu", "KDemu\KDemu.vcxproj", "{B065BF6A-4C86-420D-9B4D-8D2C6CFC0A6A}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{B065BF6A-4C86-420D-9B4D-8D2C6CFC0A6A}.Debug|x64.ActiveCfg = Debug|x64
		{B065BF6A-4C86-420D-9B4D-8D2C6CFC0A6A}.Debug|x64.Build.0 = Debug|x64
		{B065BF6A-4C86-420D-9B4D-8D2C6CFC0A6A}.Debug|x86.ActiveCfg = Debug|Win32
		{B065BF6A-4C86-420D-9B4D-8D2C6CFC0A6A}.Debug|x86.Build.0 = Debug|Win32
		{B065BF6A-4C86-420D-9B4D-8D2C6CFC0A6A}.Release|x64.ActiveCfg = Release|x64
		{B065BF6A-4C86-420D-9B4D-8D2C6CFC0A6A}.Release|x64.Build.0 = Release|x64
		{B065BF6A-4C86-420D-9B4D-8D2C6CFC0A6A}.Release|x86.ActiveCfg = Release|Win32
		{B065BF6A-4C86-420D-9B4D-8D2C6CFC0A6A}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {E0C7673E-EAEC-4F8B-B5A1-05EAD93CADF1}
	EndGlobalSection
EndGlobal

```

`KDemu/Emulate.cpp`:

```cpp
#include "Emulate.hpp"
#include "UnicornEmu.hpp"
#include "NtType.hpp"
#include <bcrypt.h>
#include <windows.h>

#include <fstream>
#include <conio.h>
#include <iostream>
#include <algorithm>
#include <cstdlib>
#include <cwchar>
#include <emmintrin.h>
#include <xmmintrin.h>
#include <cstring>
#include <unordered_set>
#include <thread>
#include <tlhelp32.h>
#include <mutex>
#pragma comment(lib, "bcrypt.lib")
int checknumh = 0;

PEloader* Emulate::loader = &PEloader::GetInstance();


uint64_t ramAddr;


Emulate::Emulate(uc_engine* uc)
{
	struct RamRange {
		uint64_t base;
		uint64_t size;
	};

	RamRange myRam[9] = { { 0x1000, 0x57000 }, { 0x59000, 0x46000 }, { 0x100000, 0xb81b9000 }, { 0xb82f1000, 0x3b0000 }, { 0xb86a3000, 0xcc58000 },
		{ 0xc6b99000, 0xfd000 }, { 0xc7ba2000, 0x5e000 }, { 0x100000000, 0x337000000 }, { 0, 0 } };
	ramAddr = HeapAlloc(uc, sizeof(myRam));
}

ULONG64 Emulate::StackAlloc(ULONG AllocBytes)
{
	return UnicornEmu::StackAlloc(AllocBytes);
}

VOID Emulate::StackFree(ULONG AllocBytes)
{
	UnicornEmu::StackFree(AllocBytes);
}
uint64_t Emulate::Alloc(uc_engine* uc, uint64_t size, uint64_t myaddr) {
	return Emu(uc)->alloc(size, myaddr);
}
uint64_t Emulate::Alloc(uc_engine* uc, uint64_t size, uint64_t myaddr, bool show) {
	return Emu(uc)->alloc(size, myaddr, show);
}
uint64_t Emulate::Alloc(uc_engine* uc, uint64_t size, uint64_t myaddr, my_uc_prot m) {
	return Emu(uc)->alloc(size, myaddr, m);
}

uint64_t Emulate::AllocVirtPhysPage(uint64_t virtAddr) {
	return Emu(loader->uc)->AllocVirtPhysPage(virtAddr);
}

uint64_t Emulate::HeapAlloc(uc_engine* uc, uint64_t size) {
	return Emu(uc)->HeapAlloc(size);
}
uint64_t Emulate::HeapAlloc(uc_engine* uc, uint64_t size, bool show) {

	auto emuc = Emu(uc);
	return emuc->HeapAlloc(size, show);
}
void Emulate::HeapFree(uint64_t addr) {
	Emu(loader->uc)->HeapFree(addr);
}

void Emulate::RtlInitUnicodeString(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "RtlInitUnicodeString \n");
	auto emu = Emu(uc);
	uint64_t rcx = emu->rcx();
	uint64_t rdx = emu->rdx();
	std::wstring wstr;
	read_null_unicode_string(uc, rdx, wstr);
	std::string str;
	UnicodeToANSI(wstr, str);
	UNICODE_STRING ustr;
	ustr.Buffer = (PWCH)rdx;
	ustr.Length = (USHORT)wstr.length() * sizeof(WCHAR);
	ustr.MaximumLength = (USHORT)(wstr.length() + 1) * sizeof(WCHAR);
	emu->write(rcx, &ustr, sizeof(ustr));
	Logger::Log(true, ConsoleColor::RED, "DestString 0x%llx SourceString: %s\n", rcx, str.c_str());
	RetHook(uc);
}

void Emulate::RtlAnsiStringToUnicodeString(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "RtlAnsiStringToUnicodeString\n");
	auto emu = Emu(uc);
	uint64_t unicode_str_ptr = emu->rcx();
	uint64_t ansi_str_ptr = emu->rdx();
	uint64_t should_alloc = emu->r8();
	std::string ansi_str = read_ansi_string(uc, ansi_str_ptr);
	Logger::Log(true, ConsoleColor::RED, "ANSI String:: %s\n", ansi_str.c_str());
	std::wstring wstr;
	ANSIToUnicode(ansi_str, wstr);
	UNICODE_STRING ustr;

	ustr.Length = (USHORT)wstr.length() * sizeof(WCHAR);
	ustr.MaximumLength = (USHORT)(wstr.length() + 1) * sizeof(WCHAR);
	uint64_t buffer_addr = Emulate::HeapAlloc(uc, 0x1000);
	if (buffer_addr)
		emu->write(buffer_addr, wstr.data(), ustr.Length);

	emu->write(unicode_str_ptr, &ustr, sizeof(ustr));
	uint64_t status = 0;
    emu->rax(status);
	RetHook(uc);
}

void Emulate::RtlInitString(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "RtlInitString\n");
	auto emu = Emu(uc);
	uint64_t ansi_string_ptr = emu->rcx();
    uint64_t source_ptr = emu->rdx();
	std::string str;
	char ch;
	int offset = 0;
	do {
		ch = emu->read<char>(source_ptr + offset);
		if (ch != '\0') str += ch;
		offset++;
	} while (ch != '\0');

	uint16_t length = static_cast<uint16_t>(str.size());
	uint16_t maxLength = length + 1;

	struct {
		uint16_t Length;
		uint16_t MaximumLength;
		uint64_t Buffer;
	} ansi;

	ansi.Length = length;
	ansi.MaximumLength = maxLength;
	ansi.Buffer = source_ptr;

	emu->write(ansi_string_ptr, &ansi, sizeof(ansi));
	Logger::Log(true, ConsoleColor::RED, "RtlInitString : %s Length : %llx MaxLength : %llx at 0x%llx\n", str.c_str(), length, maxLength, ansi_string_ptr);
	RetHook(uc);
}

void Emulate::ExSystemTimeToLocalTime(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "ExSystemTimeToLocalTime\n");
	auto emu = Emu(uc);
	uint64_t lpSystemTime = emu->rcx();
	uint64_t lpLocalTime = emu->rdx();
	emu->write(lpLocalTime, &lpSystemTime, sizeof(LARGE_INTEGER));

	RetHook(uc);
}

void Emulate::RtlTimeFieldsToTime(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "RtlTimeFieldsToTime\n");
	auto emu = Emu(uc);
	uint64_t tf_ptr = emu->rcx();
    uint64_t time_ptr = emu->rdx();
	TIME_FIELDS tf = emu->read<TIME_FIELDS>(tf_ptr);

	SYSTEMTIME st = {
		(WORD)tf.Year,
		(WORD)tf.Month,
		(WORD)(tf.Weekday + 1),
		(WORD)tf.Day,
		(WORD)tf.Hour,
		(WORD)tf.Minute,
		(WORD)tf.Second,
		(WORD)tf.Milliseconds
	};

	FILETIME ft = { 0 };
	LARGE_INTEGER result = { 0 };
	BOOLEAN success = FALSE;

	if (::SystemTimeToFileTime(&st, &ft)) {
		result.LowPart = ft.dwLowDateTime;
		result.HighPart = ft.dwHighDateTime;
		success = TRUE;

		emu->write(time_ptr, &result, sizeof(result));
	}

	Logger::Log(true, ConsoleColor::RED, "via SystemTimeToFileTime : %s, Result = 0x%llx",
		(success ? "✓ OK" : "✗ Failed")
		, result.QuadPart);

	emu->rax(success);
    RetHook(uc);
}


void Emulate::RtlTimeToTimeFields(uc_engine* uc, uint64_t address, uint32_t size, void* user_data)
{
	Logger::Log(true, ConsoleColor::RED, "RtlTimeToTimeFields\n");

	auto emu = Emu(uc);
	uint64_t time_ptr = emu->rcx();
    uint64_t timefields_ptr = emu->rdx();
	LARGE_INTEGER time = emu->read<LARGE_INTEGER>(time_ptr);

	FILETIME ft;
	ft.dwLowDateTime = time.LowPart;
	ft.dwHighDateTime = time.HighPart;

	SYSTEMTIME st;
	FileTimeToSystemTime(&ft, &st);
	TIME_FIELDS tf;
	tf.Year = st.wYear;
	tf.Month = st.wMonth;
	tf.Day = st.wDay;
	tf.Hour = st.wHour;
	tf.Minute = st.wMinute;
	tf.Second = st.wSecond;
	tf.Milliseconds = st.wMilliseconds;
	tf.Weekday = st.wDayOfWeek;

	emu->write(timefields_ptr, &tf, sizeof(TIME_FIELDS));
	RetHook(uc);
}

void Emulate::RtlDuplicateUnicodeString(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "RtlDuplicateUnicodeString\n");
	auto emu = Emu(uc);
	uint64_t flags = emu->rcx();
    uint64_t string_ptr = emu->rdx();
    uint64_t dest_ptr = emu->r8();
	UNICODE_STRING string = emu->read<UNICODE_STRING>(string_ptr);
	if (string.Buffer != NULL && string.Length > 0) {
		std::wstring unicode_str = read_unicode_string(uc, string_ptr);

		std::string utf8_str;
		for (wchar_t wc : unicode_str) {
			if (wc < 128) {
				utf8_str += static_cast<char>(wc);
			}
			else {
				utf8_str += '?';
    		}
		}
		Logger::Log(true, ConsoleColor::RED, "Unicode String: %s\n", utf8_str.c_str());
	}
	else {
		Logger::Log(true, ConsoleColor::RED, "Unicode String is empty or null.\n");
	}

	UNICODE_STRING dest_string;
	dest_string.Length = string.Length;
	dest_string.MaximumLength = string.MaximumLength;
	dest_string.Buffer = string.Buffer;
    emu->write(dest_ptr, &dest_string, sizeof(UNICODE_STRING));

	uint64_t status = 0;
    emu->rax(status);
	RetHook(uc);
}

void Emulate::RtlCompareMemory(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "RtlCompareMemory\n");
	auto emu = Emu(uc);
	uint64_t source1 = emu->rcx();
    uint64_t source2 = emu->rdx();
    uint64_t length = emu->r8();
	std::vector<uint8_t> buf1 = emu->read(source1, static_cast<size_t>(length));
	std::vector<uint8_t> buf2 = emu->read(source2, static_cast<size_t>(length));

	size_t match_len = 0;
	for (size_t i = 0; i < length; ++i) {
		if (buf1[i] != buf2[i])
			break;
		++match_len;
	}

	Logger::Log(true, ConsoleColor::RED, " %d/%d bytes match\n", match_len, length);
	emu->rax(match_len);
	RetHook(uc);
}
void Emulate::IsDigit(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "IsDigit\n");
	auto emu = Emu(uc);
	uint64_t ch = emu->rcx();
	int result = (ch >= '0' && ch <= '9') ? 1 : 0;

	Logger::Log(true, ConsoleColor::RED, "(%c) => %c", (char)ch, result);
	emu->rax(result);
	RetHook(uc);
}
void Emulate::atol(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "atol\n");
	auto emu = Emu(uc);
	uint64_t str_ptr = emu->rcx();
	char raw_str[64] = { 0 };
	auto data = emu->read(str_ptr, sizeof(raw_str) - 1);
	size_t copy_len = min(data.size(), sizeof(raw_str) - 1);
	std::memcpy(raw_str, data.data(), copy_len);
	raw_str[copy_len] = '\0';

	int result = std::atoi(raw_str);

	Logger::Log(true, ConsoleColor::RED, "( %s ) = %d\n", raw_str, result);
	emu->rax(result);
	RetHook(uc);
}
void Emulate::ExAllocatePoolWithTag(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {


	auto emu = Emu(uc);
	uint64_t rcx_value = emu->rcx();
	int a1 = static_cast<int>(rcx_value & 0xFFFFFFFF);
    uint64_t a2 = emu->rdx();
    uint64_t a3 = emu->r8();
    uint64_t allocated_address;
	Logger::Log(true, ConsoleColor::RED, "ExAllocatePoolWithTag : called with PoolType: %d , NumberOfBytes: %lld,  Tag: %llx\n", a1, a2, a3);
	allocated_address = HeapAlloc(uc, a2, false);
	emu->rax(allocated_address);
	RetHook(uc);
}
void Emulate::ExFreePoolWithTag(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "ExFreePoolWithTag\n");
	auto emu = Emu(uc);
	uint64_t free_address = emu->rcx();
    uint64_t tag = emu->rdx();
	Logger::Log(true, ConsoleColor::DARK_GREEN, "called for address: 0x%llx , Tag : 0x%llx \n", free_address, tag);










	emu->rax(0);
	uint64_t rsp = emu->rsp();
	dump_stack(uc, rsp - 8, 10);
	RetHook(uc);
}
void Emulate::ExFreeHeapPool(uc_engine* uc, uint64_t address, uint32_t size, void* user_data)
{
	Logger::Log(true, ConsoleColor::RED, "ExFreeHeapPool \n");
	RetHook(uc);

}
void Emulate::ExFreePool(uc_engine* uc, uint64_t address, uint32_t size, void* user_data)
{
	DWORD tid = GetCurrentThreadId();

	for (auto& ti : loader->Threads) {
		ResetEvent(ti->Event);
		if (ti->threadId == tid) {
			if (loader->errorevent != nullptr && loader->errorevent != ti->Event)
			{
				WaitForSingleObject(loader->errorevent, INFINITE);
				Sleep(10);
			}
			loader->errorevent = ti->Event;
			Sleep(10);
		}
	}
	auto emu = Emu(uc);
	uint64_t allocated_address = emu->rcx();
    Logger::Log(true, ConsoleColor::RED, "ExFreePool : allocated_address = %llx \n", allocated_address);

	auto it = loader->real_mem_map.find(allocated_address);
	if (it == loader->real_mem_map.end()) {
		Logger::Log(true, ConsoleColor::RED, "Error: Attempted to free unallocated or invalid address: 0x%llx \n", allocated_address);
		return;
	}
	emu->rax(0);
	uint64_t rsp = emu->rsp();
	if (loader->sysinfo_addr == allocated_address)
		loader->sysinfo_addr = 0;
	RetHook(uc);
	for (auto& ti : loader->Threads) {
		SetEvent(ti->Event);
		loader->errorevent = nullptr;
	}
}
void Emulate::IoCreateDevice(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "IoCreateDevice\n");
	DRIVER_OBJECT driverObj;
	uint64_t rax, rcx, rdx, r8, r9, r10, r11, rsp;
	auto emu = Emu(uc);
	rax = emu->rax();
    rcx = emu->rcx();
    rdx = emu->rdx();
    r8 = emu->r8();
    r9 = emu->r9();

	rsp = emu->rsp();
	std::wstring var_name = read_unicode_string(uc, r8);
    rsp = rsp + 8;
	r10 = emu->read<uint64_t>(rsp + 0x20);
    r11 = emu->read<uint64_t>(rsp + 0x28);
    uint64_t deviceObjPtr = emu->read<uint64_t>(rsp + 0x30);
    driverObj = emu->read<DRIVER_OBJECT>(rcx);

	std::string Device_name;
	std::wstring device_name = read_unicode_string(uc, r8);
    UnicodeToANSI(device_name, Device_name);

	uint64_t device_obj_addr = Emulate::HeapAlloc(uc, sizeof(_DEVICE_OBJECT));

	_DEVICE_OBJECT dev = {};
	dev.DriverObject = (DRIVER_OBJECT*)rcx;
	dev.DeviceType = static_cast<DEVICE_TYPE>(r9);
	dev.Type = 3;
	dev.Size = sizeof(_DEVICE_OBJECT);
	dev.ReferenceCount = 1;
	dev.NextDevice = 0;

	if (rdx > 0) {
		uint64_t extAddr = Emulate::HeapAlloc(uc, rdx);
		dev.DeviceExtension = (PVOID)extAddr;
	}
	driverObj.DeviceObject = (_DEVICE_OBJECT*)device_obj_addr;
	emu->write(rcx, &driverObj, sizeof(DRIVER_OBJECT));
	emu->write(device_obj_addr, &dev, sizeof(dev));
	emu->write(deviceObjPtr, &device_obj_addr, sizeof(device_obj_addr));
	uint64_t t;
	emu->rax(STATUS_SUCCESS);
	Logger::Log(true, 12, "IoCreateDevice: %s\n", Device_name.c_str());
	RetHook(uc);
}

void Emulate::IoRegisterShutdownNotification(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "IoRegisterShutdownNotification\n");
	auto emu = Emu(uc);
	uint64_t device_object_addr = emu->rcx();

	Logger::Log(true, ConsoleColor::RED, "Called : DEVICE_OBJECT @ 0x%llx\n", device_object_addr);


	RetHook(uc);
}

void Emulate::IoCreateSymbolicLink(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "IoCreateSymbolicLink\n");
	auto emu = Emu(uc);
	uint64_t symbolic_link_str_ptr = emu->rcx();
    uint64_t device_name_str_ptr = emu->rdx();
	std::wstring symbolic_link = read_unicode_string(uc, symbolic_link_str_ptr);
	std::string ssymbolic_link;
	UnicodeToANSI(symbolic_link, ssymbolic_link);
	uint64_t rsp = emu->rsp();
    std::wstring device_name = read_unicode_string(uc, device_name_str_ptr);
	std::string sdevice_name;
	UnicodeToANSI(device_name, sdevice_name);
	Logger::Log(true, ConsoleColor::RED, "  called  SymbolicLink: %s DeviceName: %s \n", ssymbolic_link, sdevice_name.c_str());

	uint64_t t;
	emu->rax(0);
    RetHook(uc);
}

void Emulate::ZwFlushKey(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "ZwFlushKey \n");
	auto emu = Emu(uc);
	uint64_t keyHandle = emu->rcx();
    Logger::Log(true, ConsoleColor::DARK_GREEN, "Flushing key : 0x%llx \n", keyHandle);

	emu->rax(0);
    RetHook(uc);
}
std::map<uint64_t, HANDLE> r3SectionMap;uint64_t nextFakeHandle = 0x10000;
void Emulate::ZwCreateSection(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	auto emu = Emu(uc);
	uint64_t SectionHandlePtr = emu->rcx();
    uint64_t DesiredAccess = emu->rdx();
	uint64_t ObjectAttributes = emu->r8();
	uint64_t MaximumSizePtr = emu->r9();

	uint64_t rsp = emu->rsp();
	uint64_t Protection = emu->read<uint64_t>(rsp + 0x28);
    uint64_t AllocationAttributes = emu->read<uint64_t>(rsp + 0x30);
    uint64_t FileHandle = emu->read<uint64_t>(rsp + 0x38);
	uint64_t maxSize = 0x1000;
	if (MaximumSizePtr)
		maxSize = emu->read<uint64_t>(MaximumSizePtr);

	DWORD protect = PAGE_READWRITE;
	if (Protection == PAGE_EXECUTE_READWRITE) protect = PAGE_EXECUTE_READWRITE;

	DWORD secAttrib = (AllocationAttributes & 0x1000000) ? SEC_COMMIT : SEC_RESERVE;



	HANDLE hSection = CreateFileMappingW(
		(HANDLE)FileHandle, nullptr,
		protect | secAttrib,
		(DWORD)(maxSize >> 32),
		(DWORD)(maxSize & 0xFFFFFFFF),
		nullptr
	);

	if (!hSection) {
		emu->rax(0xC0000001);
		RetHook(uc);
		return;
	}
	emu->write(SectionHandlePtr, &FileHandle, sizeof(FileHandle));

	std::cout << "[+] ZwCreateSection simulation completed, FakeHandle = 0x" << std::hex << FileHandle
		<< ", Size = 0x" << maxSize << "\n";

	emu->rax(0);
	RetHook(uc);
}

void Emulate::ZwClose(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {


	Logger::Log(true, ConsoleColor::RED, "ZwClose\n");
	auto emu = Emu(uc);
	uint64_t handle = emu->rcx();

	Logger::Log(true, ConsoleColor::DARK_GREEN, "Closed handle 0x%llx \n", handle);
	if (handle > 0xcafebabe)
		return;
	if (handle != 0xcafebabe)
		try
	{
		CloseHandle((HANDLE)handle);
	}
	catch (const std::exception&)
	{

	}

	emu->rax(0);
    RetHook(uc);
}
void Emulate::PsGetCurrentProcess(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "PsGetCurrentProcess\n");

	auto emu = Emu(uc);
	uint64_t gsBase = emu->gs_base();

	uint64_t kthreadPtr = emu->read<uint64_t>(gsBase + 0x188);

	uint64_t eprocess_ptr, t;
	eprocess_ptr = emu->read<uint64_t>(kthreadPtr + 0x220);
	Logger::Log(true, ConsoleColor::DARK_GREEN, "EPROCESS = 0x%llx\n", eprocess_ptr);
	emu->rax(eprocess_ptr);

	PEloader* loader = &PEloader::GetInstance();

	RetHook(uc);}
void Emulate::KeStackAttachProcess(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "KeStackAttachProcess\n");
	auto emu = Emu(uc);
	uint64_t eprocess = emu->rcx();
    uint64_t apc_state_ptr = emu->rdx();
    uint64_t gsBase = emu->gs_base();
	uint64_t kthread = emu->read<uint64_t>(gsBase + 0x188);

	uint64_t apcStateOffset = 0x98;
    uint64_t currentApcState = emu->read<uint64_t>(kthread + apcStateOffset);
	uint64_t old_process = emu->read<uint64_t>(currentApcState);

	if (eprocess != 0)
	{

		emu->write(apc_state_ptr, &old_process, sizeof(old_process));

		emu->write(currentApcState, &eprocess, sizeof(eprocess));
	}
	else {
		uint64_t PsInitialSystemProcess;
		PEloader* loader = &PEloader::GetInstance();
		PsInitialSystemProcess = emu->read<uint64_t>(loader->peFiles[1]->Base + loader->peFiles[1]->FuncAddr["PsInitialSystemProcess"]);
		eprocess = PsInitialSystemProcess;
		emu->write(apc_state_ptr, &old_process, sizeof(old_process));

		emu->write(currentApcState, &eprocess, sizeof(eprocess));

	}
	Logger::Log(true, ConsoleColor::DARK_GREEN, "Attached to EPROCESS = 0x%llx\n", eprocess);
	emu->rax(0);
    RetHook(uc);
}

void Emulate::KeUnstackDetachProcess(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "KeUnstackDetachProcess\n");
	uint64_t t;

	RetHook(uc);
}

void Emulate::ExGetFirmwareEnvironmentVariable(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "ExGetFirmwareEnvironmentVariable\n");
	auto emu = Emu(uc);
	uint64_t var_name_ptr = emu->rcx();
	uint64_t guid_ptr = emu->rdx();
	uint64_t value_ptr = emu->r8();
	uint64_t value_len = emu->r9();

	uint64_t rsp = emu->rsp();
	uint64_t return_len_ptr = emu->read<uint64_t>(rsp + 0x20);

	uint32_t value_len_temp = emu->read<uint32_t>(value_len);



	std::wstring var_name = read_unicode_string(uc, var_name_ptr);
    int var_name_len = WideCharToMultiByte(CP_UTF8, 0, var_name.c_str(), -1, nullptr, 0, nullptr, nullptr);
	char* var_name_mb = new char[var_name_len];
	WideCharToMultiByte(CP_UTF8, 0, var_name.c_str(), -1, var_name_mb, var_name_len, nullptr, nullptr);
	Logger::Log(true, ConsoleColor::DARK_GREEN, "var_name: %s\n", var_name_mb);
	delete[] var_name_mb;

	GUID guid = emu->read<GUID>(guid_ptr);
	wchar_t guid_str[64];
	StringFromGUID2(guid, guid_str, 64);
	int guid_len = WideCharToMultiByte(CP_UTF8, 0, guid_str, -1, nullptr, 0, nullptr, nullptr);
	char* guid_mb = new char[guid_len];
	WideCharToMultiByte(CP_UTF8, 0, guid_str, -1, guid_mb, guid_len, nullptr, nullptr);
	Logger::Log(true, ConsoleColor::DARK_GREEN, "guid_str: %s\n", guid_mb);
	delete[] guid_mb;

	auto status = STATUS_SUCCESS;
	RetHook(uc);}



void Emulate::MmGetPhysicalMemoryRanges(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "MmGetPhysicalMemoryRanges\n");
}

void Emulate::ObfDereferenceObject(uc_engine* uc, uint64_t address, uint32_t size, void* user_data)
{
	Logger::Log(true, ConsoleColor::RED, "ObfDereferenceObject\n");
	return;
}

void Emulate::MmBuildMdlForNonPagedPool(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "MmBuildMdlForNonPagedPool\n");
	auto emu = Emu(uc);
	uint64_t mdl_addr = emu->rcx();
	uint16_t MdlFlags = emu->read<uint16_t>(mdl_addr + offsetof(FAKE_MDL, MdlFlags));

	MdlFlags |= 0x0002;
    emu->write(mdl_addr + offsetof(FAKE_MDL, MdlFlags), &MdlFlags, sizeof(MdlFlags));

	Logger::Log(true, ConsoleColor::DARK_GREEN, "Setting MDL @ 0x%llx MdlFlags = 0x%llx\n", mdl_addr, MdlFlags);

	RetHook(uc);
}

void Emulate::IoAllocateMdl(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "IoAllocateMdl\n");
	auto emu = Emu(uc);
	uint64_t VirtualAddress = emu->rcx();
	uint64_t Length = emu->rdx();
	uint64_t SecondaryBuffer = emu->r8();
	uint64_t ChargeQuota = emu->r9();

	uint64_t rsp = emu->rsp();
	uint64_t Irp = emu->read<uint64_t>(rsp + 0x28);
	uint64_t mdl_addr = Emulate::HeapAlloc(uc, sizeof(FAKE_MDL));
	FAKE_MDL mdl = {};
	mdl.Size = sizeof(FAKE_MDL);
	mdl.StartVa = VirtualAddress;
	mdl.ByteCount = Length;
	mdl.MappedSystemVa = VirtualAddress;
    emu->write(mdl_addr, &mdl, sizeof(mdl));

	Logger::Log(true, ConsoleColor::DARK_GREEN, "Alloc MDL  0x%llx VA: 0x%llx, Len= %lld\n", mdl_addr, VirtualAddress, Length);

	emu->rax(mdl_addr);
	RetHook(uc);
}

void Emulate::MmAllocateContiguousMemorySpecifyCache(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "MmAllocateContiguousMemorySpecifyCache\n");
	auto emu = Emu(uc);
	SIZE_T NumberOfBytes = static_cast<SIZE_T>(emu->rcx());
    uint64_t LowestAcceptableAddress = emu->rdx();
    uint64_t HighestAcceptableAddress = emu->r8();
    uint64_t BoundaryAddressMultiple = emu->r9();
    uint64_t rsp = emu->rsp();
	Logger::Log(true, ConsoleColor::DARK_GREEN, "\tLowest : %llx - Highest : %llx - Boundary : %llx - Size : %08x\n", LowestAcceptableAddress, HighestAcceptableAddress, BoundaryAddressMultiple, NumberOfBytes);
	loader->AllocatedContiguous = (uint64_t)HeapAlloc(uc, NumberOfBytes);
	emu->rax(loader->AllocatedContiguous);
	RetHook(uc);
}

void Emulate::PsRemoveLoadImageNotifyRoutine(uc_engine* uc, uint64_t address, uint32_t size, void* user_data)
{
	Logger::Log(true, ConsoleColor::RED, "PsRemoveLoadImageNotifyRoutine\n");

}

void Emulate::PsSetCreateProcessNotifyRoutineEx(uc_engine* uc, uint64_t address, uint32_t size, void* user_data)
{
	Logger::Log(true, ConsoleColor::RED, "PsSetCreateProcessNotifyRoutineEx\n");
	auto emu = Emu(uc);
	uint64_t NotifyRoutine = emu->rcx();
	uint64_t Remove = emu->rdx();

	uint64_t ret;
	if (Remove) {
		ret = STATUS_INVALID_PARAMETER;
	}
	else {
		ret = STATUS_SUCCESS;
	}
}

void Emulate::ObRegisterCallbacks(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "ObRegisterCallback\n");
	auto emu = Emu(uc);
	uint64_t registration_addr = emu->rcx();
	uint64_t handle_ptr = emu->rdx();

	uint16_t count;
	uint64_t op_array;
	uint64_t context;

	count = emu->read<uint16_t>(registration_addr + 4);
    context = emu->read<uint64_t>(registration_addr + 0x10);
    op_array = emu->read<uint64_t>(registration_addr + 0x18);
	uint64_t fake_handle = 0xDEADBEEF00000001;
	emu->write(handle_ptr, &fake_handle, sizeof(fake_handle));

	uint64_t status = 0;
    emu->rax(status);
	Logger::Log(true, ConsoleColor::DARK_GREEN, " %llx\n", count);
	RetHook(uc);
}
uint64_t g_CmCookieSeed = 0xCB00000000000000;
void Emulate::CmRegisterCallbackEx(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "CmRegisterCallbackEx\n");
	auto emu = Emu(uc);
	uint64_t fn = emu->rcx();
	uint64_t ctx = emu->rdx();
	uint64_t alt_str_ptr = emu->r8();
	uint64_t driver = emu->r9();

	uint64_t rsp = emu->rsp();
	uint64_t cookie_ptr = emu->read<uint64_t>(rsp + 0x20);

	std::wstring altitude;
	if (alt_str_ptr != 0) {
		altitude = read_unicode_string(uc, alt_str_ptr);
	}
	g_CmCookieSeed++;
	emu->write(cookie_ptr, &g_CmCookieSeed, sizeof(g_CmCookieSeed));

	Logger::Log(true, ConsoleColor::DARK_GREEN, " Registered Callback: 0x%llx , Altitude: %s\n", fn, altitude.c_str());

	uint64_t status = 0;
    emu->rax(status);
	RetHook(uc);
}
void Emulate::ObUnRegisterCallbacks(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "ObUnRegisterCallbacks\n");
	auto emu = Emu(uc);
	uint64_t regHandle = emu->rcx();

	Logger::Log(true, ConsoleColor::DARK_GREEN, "Removed \n");

	NTSTATUS status = 0;



	emu->rax(status);
	RetHook(uc);
}
void Emulate::ZwWaitForSingleObject(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "ZwWaitForSingleObject\n");
	auto emu = Emu(uc);
	uint64_t status = 0;
    emu->rax(status);
	RetHook(uc);
}
void Emulate::InitializeSListHead(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "InitializeSListHead\n");
	auto emu = Emu(uc);
	uint64_t listHeadAddr = emu->rcx();
	uint8_t zero[16] = {};

	Logger::Log(true, ConsoleColor::DARK_GREEN, " Clear SLIST_HEADER  0x%llx\n", listHeadAddr);

}
void Emulate::KeInitializeSpinLock(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "KeInitializeSpinLock \n");
	auto emu = Emu(uc);
	uint64_t spinlock_addr = emu->rcx();

	Logger::Log(true, ConsoleColor::DARK_GREEN, "SpinLock @ 0x%llx Set to Zero\n", spinlock_addr);

}

void Emulate::KeAcquireSpinLockRaiseToDpc(uc_engine* uc, uint64_t address, uint32_t size, void* user_data)
{
	Logger::Log(true, ConsoleColor::RED, "KeAcquireSpinLockRaiseToDpc\n");

	auto emu = Emu(uc);
	uint64_t ret = 0;
	emu->rax(ret);
	RetHook(uc);
}

void Emulate::KeReleaseSpinLock(uc_engine* uc, uint64_t address, uint32_t size, void* user_data)
{
	Logger::Log(true, ConsoleColor::RED, "KeReleaseSpinLock\n");
	RetHook(uc);
}

void Emulate::ExpInterlockedPopEntrySList(uc_engine* uc, uint64_t address, uint32_t size, void* user_data)
{
	Logger::Log(true, ConsoleColor::RED, "ExpInterlockedPopEntrySList\n");
	auto emu = Emu(uc);
	uint64_t ret = 0;
	emu->rax(ret);
	RetHook(uc);
}

void Emulate::ExWaitForRundownProtectionRelease(uc_engine* uc, uint64_t address, uint32_t size, void* user_data)
{
	Logger::Log(true, ConsoleColor::RED, "ExWaitForRundownProtectionRelease\n");
	RetHook(uc);
}

void Emulate::KeCancelTimer(uc_engine* uc, uint64_t address, uint32_t size, void* user_data)
{
	Logger::Log(true, ConsoleColor::RED, "KeCancelTimer\n");

	auto emu = Emu(uc);
	uint64_t ret = 1;
	emu->rax(ret);
	RetHook(uc);
}


void Emulate::RtlFreeUnicodeString(uc_engine* uc, uint64_t address, uint32_t size, void* user_data)
{
	Logger::Log(true, ConsoleColor::RED, "RtlFreeUnicodeString\n");
	RetHook(uc);
}

void Emulate::PsSetCreateThreadNotifyRoutine(uc_engine* uc, uint64_t address, uint32_t size, void* user_data)
{
	Logger::Log(true, ConsoleColor::RED, "PsSetCreateThreadNotifyRoutine\n");
	auto emu = Emu(uc);
	emu->rax(STATUS_SUCCESS);
	RetHook(uc);
}

void Emulate::PsSetLoadImageNotifyRoutine(uc_engine* uc, uint64_t address, uint32_t size, void* user_data)
{
	Logger::Log(true, ConsoleColor::RED, "PsSetLoadImageNotifyRoutine\n");
	auto emu = Emu(uc);
	emu->rax(STATUS_SUCCESS);
	RetHook(uc);
}

void Emulate::ExRegisterCallback(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "ExRegisterCallback\n");
	auto emu = Emu(uc);
	uint64_t callback_object = emu->rcx();
	uint64_t callback_fn = emu->rdx();
	uint64_t callback_ctx = emu->r8();

	Logger::Log(true, ConsoleColor::DARK_GREEN, "object = 0x%llx, fn=0x%llx, ctx=0x%llx\n", callback_object, callback_fn, callback_ctx);

	uint64_t reg_handle = callback_fn;
    emu->rax(reg_handle);
	RetHook(uc);
}
void Emulate::ExUnregisterCallback(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "ExUnregisterCallback\n");
	auto emu = Emu(uc);
	uint64_t handle = emu->rcx();
	Logger::Log(true, ConsoleColor::DARK_GREEN, " Remove Callback handle: %llx\n", handle);

	RetHook(uc);
}


void Emulate::_CiCheckSignedFile(uc_engine* uc, uint64_t address, uint32_t size, void* user_data)
{
	Logger::Log(true, ConsoleColor::RED, "CiCheckSignedFile\n");
	auto emu = Emu(uc);
	uint64_t digestBuffer = emu->rcx();
	uint64_t digestSize = emu->rdx();
	uint64_t digestIdentifier = emu->r8();
	uint64_t winCert = emu->r9();

	uint64_t rsp = emu->rsp();
	rsp = rsp + 8;
	int sizeOfSecurityDirectory;
	uint64_t policyInfoForSigner;
	uint64_t signingTime;
	uint64_t policyInfoForTimestampingAuthority;
	sizeOfSecurityDirectory = emu->read<int>(rsp + 0x20);
	policyInfoForSigner = emu->qword(rsp + 0x28);
	signingTime = emu->qword(rsp + 0x30);
	policyInfoForTimestampingAuthority = emu->qword(rsp + 0x38);
	std::vector<uint8_t> copiedDigestBufferData;
	if (digestSize != 0) {
		copiedDigestBufferData = emu->read(digestBuffer, static_cast<size_t>(digestSize));
	}
	const uint64_t WIN_CERTIFICATE_SIZE = 8;
    std::vector<uint8_t> copiedWinCertData;
	if (winCert != 0) {
		copiedWinCertData = emu->read(winCert, static_cast<size_t>(WIN_CERTIFICATE_SIZE));
	}
	auto ret = 0;


	emu->rax(ret);
	RetHook(uc);
}

void Emulate::CiFreePolicyInfo(uc_engine* uc, uint64_t address, uint32_t size, void* user_data)
{

	Logger::Log(true, ConsoleColor::RED, "CiFreePolicyInfo\n");
	auto emu = Emu(uc);
	uint64_t ptr = emu->rcx();

	Logger::Log(true, ConsoleColor::RED, "CiFreePolicyInfo: Free PolicyInfo @ 0x%llx\n", ptr);



	RetHook(uc);
}

void Emulate::KeWaitForMultipleObjects(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	auto emu = Emu(uc);
	uint64_t Count = emu->rcx();
	uint64_t ObjectArrayAddr = emu->rdx();
	uint64_t WaitType = emu->r8();
	uint64_t WaitReason = emu->r9();

	uint64_t rsp = emu->rsp();
	uint64_t WaitMode = emu->read<uint64_t>(rsp + 0x28);
	uint64_t Alertable = emu->read<uint64_t>(rsp + 0x30);
	uint64_t TimeoutAddr = emu->read<uint64_t>(rsp + 0x38);



	DWORD timeout_ms = INFINITE;
	if (TimeoutAddr != 0) {
		LARGE_INTEGER timeoutVal;
		timeoutVal = emu->read<LARGE_INTEGER>(TimeoutAddr);
		timeout_ms = (DWORD)(-timeoutVal.QuadPart / 10000);
	}

	DWORD result = 0;
	WaitForMultipleObjects(
		static_cast<DWORD>(loader->waitHandles.size()),
		loader->waitHandles.data(),
		WaitType,
		timeout_ms
	);

	uint64_t status = 0;
	switch (result) {
	case WAIT_OBJECT_0:
		std::cout << "Both events are signaled!\n";
		break;
	case WAIT_TIMEOUT:
		std::cout << "Timeout waiting for events.\n";
		break;
	case WAIT_FAILED:
		std::cout << "Wait failed: " << GetLastError() << "\n";
		break;
	default:
		std::cout << "Unknown result: " << result << "\n";
		break;
	}

	std::cout << "[+] KeWaitForMultipleObjects completed, return status: 0x" << std::hex << status << std::endl;
	emu->rax(status);
	RetHook(uc);
}


void Emulate::HalAcpiGetTableEx(uc_engine* uc, uint64_t address, uint32_t size, void* user_data)
{
	Logger::Log(true, ConsoleColor::RED, "HalAcpiGetTableEx\n");
	auto emu = Emu(uc);
	uint64_t rcx = emu->rcx();
	uint64_t rdx = emu->rdx();
	uint64_t r8 = emu->r8();
	std::wstring wstr;
	read_null_unicode_string(uc, rcx, wstr);

	RetHook(uc);
}

void Emulate::IoQueryFileInformation(uc_engine* uc, uint64_t address, uint32_t size, void* user_data)
{
	ZwQueryInformationFile(uc, address, size, user_data);
}

void Emulate::DbgPrint(uc_engine* uc, uint64_t address, uint32_t size, void* user_data)
{
	Logger::Log(true, ConsoleColor::RED, "DbgPrint\n");

	auto emu = Emu(uc);
	uint64_t format_ptr = emu->rcx();
	uint64_t arg1 = emu->rdx();
	uint64_t arg2 = emu->r8();
	uint64_t arg3 = emu->r9();

	std::vector<char> format;
	char ch;
	do {
		ch = static_cast<char>(emu->read<uint8_t>(format_ptr++));
		format.push_back(ch);
	} while (ch != '\0');
	std::string fmt(format.begin(), format.end());

	char str_arg1[256] = {};
	if (arg1 != 0) {
		auto arg1Data = emu->read(arg1, sizeof(str_arg1) - 1);
		memcpy(str_arg1, arg1Data.data(), arg1Data.size());
	}

	char buffer[512];
	snprintf(buffer, sizeof(buffer), fmt.c_str(), arg1, (unsigned int)arg2, (unsigned int)arg3);

	Logger::Log(true, ConsoleColor::GREEN, "%s", buffer);

	RetHook(uc);
}

void Emulate::RtlVirtualUnwind(uc_engine* uc, uint64_t address, uint32_t size, void* user_data)
{
	Logger::Log(true, ConsoleColor::RED, "RtlVirtualUnwind \n");
	uint64_t rsp;
}

void Emulate::SeSinglePrivilegeCheck(uc_engine* uc, uint64_t address, uint32_t size, void* user_data)
{
	auto emu = Emu(uc);
	emu->rax(STATUS_SUCCESS);
	RetHook(uc);
}

void Emulate::ExAcquireResourceExclusiveLite(uc_engine* uc, uint64_t address, uint32_t size, void* user_data)
{
	auto emu = Emu(uc);
	emu->rax(STATUS_SUCCESS);
	RetHook(uc);
}
int test = 0;

void Emulate::RtlRaiseStatus(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::DARK_GREEN, "RtlRaiseStatus\n");
}
void Emulate::PsGetCurrentServerSilo(uc_engine* uc, uint64_t address, uint32_t size, void* user_data)
{
	Logger::Log(true, ConsoleColor::RED, "PsGetCurrentServerSilo\n");
	auto emu = Emu(uc);
	uint64_t PsIdleProcess = emu->qword(0xfffff80508b134d0);

	emu->rax(0);
	RetHook(uc);


}
void Emulate::RtlLookupFunctionEntry(uc_engine* uc, uint64_t address, uint32_t size, void* user_data)
{
	Logger::Log(true, ConsoleColor::RED, "RtlLookupFunctionEntry\n");
	/*auto emu = Emu(uc);
	uint64_t rcx = emu->rcx();
	uint64_t rdx = emu->rdx();
	uint64_t r8 = emu->r8();
	uint64_t rcxtemp, rdxtemp;
	UNWIND_HISTORY_TABLE historyTable = {};
	rcxtemp = emu->qword(rcx);
	rdxtemp = emu->qword(rdx);
	historyTable = emu->read<UNWIND_HISTORY_TABLE>(r8);
	uint64_t rsp;*/


}

void Emulate::MmGetPhysicalAddress(uc_engine* uc, uint64_t address, uint32_t size, void* user_data)
{
	Logger::Log(true, ConsoleColor::RED, "MmGetPhysicalAddress\n");
	auto emu = Emu(uc);
	uint64_t baseAddress = emu->rcx();
	uint64_t ret = baseAddress >> 12;

	if (baseAddress == loader->AllocatedContiguous) {
		Logger::Log(true, DARK_GREEN, "\tGetting physical for last Contiguous Allocated Memory.\n");
	}
	if (baseAddress == 0xf0f87c3e1000) {
		ret = 0x1ad000;
	}
	else if (baseAddress == 0xfb7dbedf6000) {
		ret = 0x200000;
	}
	else if (baseAddress == 0xfbfdfeff7000) {
		ret = 0x200000;
	}
	else if (baseAddress == 0xfc7e3f1f8000) {
		ret = 0x200000;
	}
	else if (baseAddress == 0xfcfe7f3f9000) {
		ret = 0x200000;
	}
	Logger::Log(true, DARK_GREEN, "%llx Return: %llx\n", baseAddress, ret);
	emu->rax(ret);
	RetHook(uc);

	return;
}

void Emulate::ZwOpenSection(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "ZwOpenSection \n");
	auto emu = Emu(uc);
	uint64_t sectionHandlePtr = emu->rcx();
    uint64_t desiredAccess = emu->rdx();
	uint64_t objectAttrAddr = emu->r8();

	OBJECT_ATTRIBUTES ObjectAttributes = {};
	ObjectAttributes = emu->read<OBJECT_ATTRIBUTES>(objectAttrAddr);

	std::wstring sectionName = read_unicode_string(uc, ObjectAttributes.ObjectName);
	UNICODE_STRING KeyPath;
	ConvertToUnicodeString(KeyPath, sectionName);
	OBJECT_ATTRIBUTES objAttr;
	std::string unstring;
	UnicodeToANSI(sectionName, unstring);
	InitializeObjectAttributes(&objAttr, (uint64_t)&KeyPath, OBJ_CASE_INSENSITIVE, NULL, NULL);
	Logger::Log(true, DARK_GREEN, "Attempting to open Section: %s\n", unstring.c_str());

	uint64_t fakeHandle = 0xBAD00001;
	auto ret = __NtRoutine("NtOpenSection", &sectionHandlePtr, desiredAccess, &objAttr);

	uint64_t status = 0;
    emu->rax(ret);

	RetHook(uc);
}

static std::vector<uint8_t> get_system_module_information() {
	ULONG size = 0;
	HINSTANCE hNtDLL = LoadLibraryA("ntdll.dll");
	if (!hNtDLL) {
		std::cerr << "Failed to load ntdll.dll" << std::endl;
		return {};
	}

	_NtQuerySystemInformation NtQuerySystemInformation = _NtQuerySystemInformation(GetProcAddress(hNtDLL, "NtQuerySystemInformation"));
	if (!NtQuerySystemInformation) {
		std::cerr << "Failed to find NtQuerySystemInformation" << std::endl;
		FreeLibrary(hNtDLL);
		return {};
	}
	NTSTATUS status = NtQuerySystemInformation(11, nullptr, 0, &size);

	std::vector<uint8_t> buffer(size);
	status = NtQuerySystemInformation(11, buffer.data(), size, &size);
	PSYSTEM_MODULE_INFORMATION moduleInfo = (PSYSTEM_MODULE_INFORMATION)buffer.data();
	printf("Module count: %lu\n", moduleInfo->ModuleCount);
	return buffer;
}


void Emulate::ZwQuerySystemInformation(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {

	Logger::Log(true, ConsoleColor::RED, "ZwQuerySystemInformation\n");
	auto emu = Emu(uc);
	uint64_t SystemInformationClass = emu->rcx();
    uint64_t SystemInformation = emu->rdx();
    uint64_t SystemInformationLength = emu->r8();
    uint64_t ReturnLength = emu->r9();
    uint64_t rsp;

	Logger::Log(true, ConsoleColor::YELLOW, "SystemInformationClass : 0x%llx SystemInformation: 0x%llx \n", SystemInformationClass, SystemInformation);

	if (SystemInformationClass == 0x67) {

		SYSTEM_CODEINTEGRITY_INFORMATION Integrity = { sizeof(Integrity),0 };
		uint32_t retLen;
		uint32_t status = __NtRoutine("NtQuerySystemInformation", SystemInformationClass, &Integrity,
			sizeof(Integrity), &retLen);
		Logger::Log(true, ConsoleColor::RED, "returned : 0x%llx Integrity: %x\n", status, Integrity.CodeIntegrityOptions);
		Integrity.CodeIntegrityOptions = 0x2001;
		emu->write(SystemInformation, Integrity);
		if (ReturnLength != 0) {
			emu->write(ReturnLength, retLen);
			RetHook(uc);
			return;
		}
		emu->rax(status);
		RetHook(uc);
		return;
	}

	if (SystemInformationClass == 0x4d)
	{
		loader->sysinfo_addr = SystemInformation;
	}
}

void Emulate::_vswprintf_s(uc_engine* uc, uint64_t address, uint32_t size, void* user_data)
{
	DWORD tid = GetCurrentThreadId();
	for (auto& ti : loader->Threads) {
		if (ti->threadId != tid) {
			ResetEvent(ti->Event);
		}
		else if (ti->threadId == tid) {
			loader->errorevent = ti->Event;
		}
	}

	auto restore_threads = [&]() {
		for (auto& ti : loader->Threads) {
			SetEvent(ti->Event);
		}
		loader->errorevent = nullptr;
		};

	Logger::Log(true, ConsoleColor::RED, L"_vswprintf_s\n");

	auto emu = Emu(uc);
	uint64_t buffer_ptr = emu->rcx();
	uint64_t sizeInWords = emu->rdx();
	uint64_t format_ptr = emu->r8();
	uint64_t va_args_ptr = emu->r9();

	if (sizeInWords == 0 || sizeInWords > 0x100000) {
		wchar_t zero = L'\0';
		emu->write(buffer_ptr, &zero, sizeof(wchar_t));
		emu->rax(static_cast<uint64_t>(-1));
		RetHook(uc);
		restore_threads();
		return;
	}

	std::wstring format;
	for (uint64_t addr = format_ptr;; addr += sizeof(wchar_t)) {
		wchar_t ch = 0;
		if (!emu->try_read(addr, &ch, sizeof(ch))) {
			break;
		}
		format.push_back(ch);
		if (ch == L'\0') {
			break;
		}
	}
	if (format.empty() || format.back() != L'\0') {
		format.push_back(L'\0');
	}

	std::vector<uint64_t> guest_args;
	guest_args.reserve(32);
	for (int i = 0; i < 64; ++i) {
		uint64_t offset = va_args_ptr + static_cast<uint64_t>(i) * sizeof(uint64_t);
		if (auto value = emu->try_read<uint64_t>(offset)) {
			guest_args.push_back(*value);
		}
		else {
			break;
		}
	}

	std::wstringstream ws;
	size_t arg_idx = 0;

	for (size_t i = 0; i < format.size(); ++i) {
		if (format[i] == L'%' && i + 1 < format.size()) {
			size_t j = i + 1;
			int zero_pad = 0;

			if (j < format.size() && format[j] == L'0' && j + 1 < format.size() && iswdigit(format[j + 1])) {
				j++;
				while (j < format.size() && iswdigit(format[j])) {
					zero_pad = zero_pad * 10 + (format[j] - L'0');
					j++;
				}
			}

			if (j + 1 < format.size() && format[j] == L'h' && format[j + 1] == L'u') {
				if (arg_idx < guest_args.size()) {
					uint16_t val = static_cast<uint16_t>(guest_args[arg_idx++]);
					ws << std::setfill(L'0') << std::setw(zero_pad) << val;
				}
				i = j + 1;
			}
			else if (format[j] == L'u' && arg_idx < guest_args.size()) {
				uint32_t val = static_cast<uint32_t>(guest_args[arg_idx++]);
				ws << std::setfill(L'0') << std::setw(zero_pad) << val;
				i = j;
			}
			else if (format[j] == L'X' && arg_idx < guest_args.size()) {
				uint32_t val = static_cast<uint32_t>(guest_args[arg_idx++]);
				ws << std::uppercase << std::hex << std::setfill(L'0') << std::setw(zero_pad) << val << std::dec;
				i = j;
			}
			else if (format[j] == L'S' && arg_idx < guest_args.size()) {
				char tmp[512] = {};
				if (emu->try_read(guest_args[arg_idx++], tmp, sizeof(tmp))) {
					std::string ansi_tmp(tmp);
					std::wstring wide_tmp;
					ANSIToUnicode(ansi_tmp, wide_tmp);
					ws << wide_tmp.c_str();
				}
				i = j;
			}
			else if (format[j] == L's' && arg_idx < guest_args.size()) {
				wchar_t tmp[512] = {};
				if (emu->try_read(guest_args[arg_idx++], tmp, sizeof(tmp))) {
					ws << tmp;
				}
				i = j;
			}
			else if ((format[j] == L'd' || format[j] == L'i') && arg_idx < guest_args.size()) {
				int64_t val = static_cast<int64_t>(guest_args[arg_idx++]);
				ws << std::setfill(L'0') << std::setw(zero_pad) << val;
				i = j;
			}
			else if (format[j] == L'x' && arg_idx < guest_args.size()) {
				int64_t val = static_cast<int64_t>(guest_args[arg_idx++]);
				ws << std::hex << std::setfill(L'0') << std::setw(zero_pad) << val << std::dec;
				i = j;
			}
			else {
				ws << format[i];
			}
		}
		else {
			ws << format[i];
		}
	}

	std::wstring result = ws.str();
	size_t required = result.size() + 1;
	if (required > sizeInWords) {
		wchar_t zero = L'\0';
		emu->write(buffer_ptr, &zero, sizeof(wchar_t));
		emu->rax(static_cast<uint64_t>(-1));
		RetHook(uc);
		restore_threads();
		return;
	}

	Logger::Log(true, ConsoleColor::RED, L"%ls\n", result.c_str());
	emu->write(buffer_ptr, result.c_str(), required * sizeof(wchar_t));
	emu->rax(static_cast<uint64_t>(result.size()));
	RetHook(uc);
	restore_threads();
}

void Emulate::_swprintf_s(uc_engine* uc, uint64_t address, uint32_t size, void* user_data)
{
	DWORD tid = GetCurrentThreadId();
	for (auto& ti : loader->Threads) {
		if (ti->threadId != tid) {
			ResetEvent(ti->Event);
		}
		else {
			loader->errorevent = ti->Event;
		}
	}

	auto restore_threads = [&]() {
		for (auto& ti : loader->Threads) {
			SetEvent(ti->Event);
		}
		loader->errorevent = nullptr;
		};

	Logger::Log(true, ConsoleColor::RED, L"_swprintf_s\n");

	auto emu_sw = Emu(uc);
	uint64_t buffer_ptr = emu_sw->rcx();
	uint64_t sizeInWords = emu_sw->rdx();
	uint64_t format_ptr = emu_sw->r8();

	if (sizeInWords == 0 || sizeInWords > 0x100000) {
		wchar_t zero = L'\0';
		emu_sw->write(buffer_ptr, &zero, sizeof(wchar_t));
		emu_sw->rax(static_cast<uint64_t>(-1));
		RetHook(uc);
		restore_threads();
		return;
	}

	std::wstring format;
	for (uint64_t addr = format_ptr;; addr += sizeof(wchar_t)) {
		wchar_t ch = 0;
		if (!emu_sw->try_read(addr, &ch, sizeof(ch))) {
			break;
		}
		format.push_back(ch);
		if (ch == L'\0') {
			break;
		}
	}
	if (format.empty() || format.back() != L'\0') {
		format.push_back(L'\0');
	}

	std::vector<uint64_t> guest_args;
	guest_args.reserve(16);
	guest_args.push_back(emu_sw->r9());

	uint64_t rsp = emu_sw->rsp();
	for (int i = 0; i < 32; ++i) {
		uint64_t val = 0;
		if (!emu_sw->try_read(rsp + 0x28 + static_cast<uint64_t>(i) * 8, &val, sizeof(val))) {
			break;
		}
		guest_args.push_back(val);
	}

	size_t arg_idx = 0;
	auto next_arg = [&]() -> uint64_t {
		if (arg_idx < guest_args.size()) {
			return guest_args[arg_idx++];
		}
		return 0;
		};

	auto read_guest_cstring = [&](uint64_t addr) {
		std::string str;
		if (addr == 0) {
			return str;
		}
		for (size_t offset = 0; offset < 0x2000; ++offset) {
			char c = 0;
			if (!emu_sw->try_read(addr + offset, &c, sizeof(c))) {
				break;
			}
			if (c == '\0') {
				break;
			}
			str.push_back(c);
		}
		return str;
		};

	std::wstring result;
	result.reserve(format.size());

	size_t i = 0;
	while (i < format.size()) {
		wchar_t ch = format[i];
		if (ch == L'\0') {
			break;
		}
		if (ch != L'%') {
			result.push_back(ch);
			++i;
			continue;
		}
		if (i + 1 < format.size() && format[i + 1] == L'%') {
			result.push_back(L'%');
			i += 2;
			continue;
		}

		size_t j = i + 1;
		while (j < format.size()) {
			wchar_t flagChar = format[j];
			if (flagChar == L'-' || flagChar == L'+' || flagChar == L' ' || flagChar == L'#' || flagChar == L'0') {
				++j;
			}
			else {
				break;
			}
		}

		while (j < format.size() && iswdigit(format[j])) {
			++j;
		}

		if (j < format.size() && format[j] == L'.') {
			++j;
			while (j < format.size() && iswdigit(format[j])) {
				++j;
			}
		}

		size_t length_start = j;
		if (j < format.size()) {
			switch (format[j]) {
			case L'h':
				++j;
				if (j < format.size() && format[j] == L'h') {
					++j;
				}
				break;
			case L'l':
				++j;
				if (j < format.size() && format[j] == L'l') {
					++j;
				}
				break;
			case L'L':
			case L'w':
			case L'j':
			case L'z':
			case L't':
				++j;
				break;
			case L'I':
				++j;
				if (j + 1 < format.size() && format[j] == L'6' && format[j + 1] == L'4') {
					j += 2;
				}
				else if (j + 1 < format.size() && format[j] == L'3' && format[j + 1] == L'2') {
					j += 2;
				}
				break;
			default:
				break;
			}
		}

		if (j >= format.size()) {
			break;
		}

		wchar_t spec = format[j];
		size_t spec_pos = j;
		++j;
		std::wstring token = format.substr(i, j - i);
		std::wstring length_mod = format.substr(length_start, spec_pos - length_start);

		auto append_with_token = [&](auto value) -> bool {
			int needed = _scwprintf(token.c_str(), value);
			if (needed < 0) {
				return false;
			}
			std::vector<wchar_t> temp(static_cast<size_t>(needed) + 1, L'\0');
			if (_snwprintf_s(temp.data(), temp.size(), _TRUNCATE, token.c_str(), value) < 0) {
				return false;
			}
			result.append(temp.data());
			return true;
			};

		auto length_equals = [&](const wchar_t* mod) -> bool {
			return length_mod == mod;
			};

		bool handled = true;
		switch (spec) {
		case L'd':
		case L'i': {
			int64_t raw = static_cast<int64_t>(next_arg());
			if (length_equals(L"ll") || length_equals(L"I64")) {
				handled = append_with_token(static_cast<long long>(raw));
			}
			else if (length_equals(L"l")) {
				handled = append_with_token(static_cast<long>(raw));
			}
			else if (length_equals(L"hh")) {
				handled = append_with_token(static_cast<signed char>(raw));
			}
			else if (length_equals(L"h")) {
				handled = append_with_token(static_cast<short>(raw));
			}
			else {
				handled = append_with_token(static_cast<int>(raw));
			}
			break;
		}
		case L'u':
		case L'o':
		case L'x':
		case L'X': {
			uint64_t raw = next_arg();
			if (length_equals(L"ll") || length_equals(L"I64")) {
				handled = append_with_token(static_cast<unsigned long long>(raw));
			}
			else if (length_equals(L"l")) {
				handled = append_with_token(static_cast<unsigned long>(raw));
			}
			else if (length_equals(L"hh")) {
				handled = append_with_token(static_cast<unsigned char>(raw));
			}
			else if (length_equals(L"h")) {
				handled = append_with_token(static_cast<unsigned short>(raw));
			}
			else {
				handled = append_with_token(static_cast<unsigned int>(raw));
			}
			break;
		}
		case L'p': {
			uint64_t raw = next_arg();
			void* ptr_value = reinterpret_cast<void*>(raw);
			handled = append_with_token(ptr_value);
			break;
		}
		case L's': {
			uint64_t ptr = next_arg();
			const wchar_t* str_ptr = L"(null)";
			std::wstring tmp;
			if (ptr != 0) {
				std::wstring guest;
				read_null_unicode_string(uc, ptr, guest);
				tmp = std::move(guest);
				str_ptr = tmp.c_str();
			}
			handled = append_with_token(str_ptr);
			break;
		}
		case L'S': {
			uint64_t ptr = next_arg();
			const char* str_ptr = "(null)";
			std::string tmp;
			if (ptr != 0) {
				tmp = read_guest_cstring(ptr);
				str_ptr = tmp.c_str();
			}
			handled = append_with_token(str_ptr);
			break;
		}
		case L'c': {
			uint64_t raw = next_arg();
			wint_t ch_value = static_cast<wint_t>(raw);
			handled = append_with_token(ch_value);
			break;
		}
		case L'C': {
			uint64_t raw = next_arg();
			int ch_value = static_cast<int>(static_cast<unsigned char>(raw));
			handled = append_with_token(ch_value);
			break;
		}
		case L'f':
		case L'F':
		case L'e':
		case L'E':
		case L'g':
		case L'G':
		case L'a':
		case L'A': {
			uint64_t raw = next_arg();
			double value = 0.0;
			std::memcpy(&value, &raw, sizeof(value));
			handled = append_with_token(value);
			break;
		}
		case L'n': {
			uint64_t dest = next_arg();
			if (dest != 0) {
				int64_t count = static_cast<int64_t>(result.size());
				if (length_equals(L"ll") || length_equals(L"I64")) {
					long long value = static_cast<long long>(count);
					emu_sw->write(dest, &value, sizeof(value));
				}
				else if (length_equals(L"l")) {
					long value = static_cast<long>(count);
					emu_sw->write(dest, &value, sizeof(value));
				}
				else if (length_equals(L"hh")) {
					signed char value = static_cast<signed char>(count);
					emu_sw->write(dest, &value, sizeof(value));
				}
				else if (length_equals(L"h")) {
					short value = static_cast<short>(count);
					emu_sw->write(dest, &value, sizeof(value));
				}
				else {
					int value = static_cast<int>(count);
					emu_sw->write(dest, &value, sizeof(value));
				}
			}
			handled = true;
			break;
		}
		default:
			handled = false;
			break;
		}

		if (!handled) {
			result.append(token);
		}

		i = j;
	}

	size_t required = result.size() + 1;
	if (required > sizeInWords) {
		wchar_t zero = L'\0';
		emu_sw->write(buffer_ptr, &zero, sizeof(wchar_t));
		emu_sw->rax(static_cast<uint64_t>(-1));
		RetHook(uc);
		restore_threads();
		return;
	}

	emu_sw->write(buffer_ptr, result.c_str(), required * sizeof(wchar_t));
	Logger::Log(true, ConsoleColor::RED, L"%ls\n", result.c_str());
	emu_sw->rax(static_cast<uint64_t>(result.size()));
	RetHook(uc);
	restore_threads();
}


void Emulate::KeInsertQueueApc(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "KeInsertQueueApc\n");
	auto emu = Emu(uc);
	uint64_t status = 0;
	emu->rax(status);
	RetHook(uc);
}
void Emulate::KeInitializeApc(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "KeInitializeApc\n");
	auto emu = Emu(uc);
	uint64_t apc = emu->rcx();
	uint64_t inserted = 0;
	emu->try_write(apc + 0x52, &inserted, sizeof(inserted));

	RetHook(uc);
}


void Emulate::_vsnwprintf(uc_engine* uc, uint64_t address, uint32_t size, void* user_data)
{
	DWORD tid = GetCurrentThreadId();
	for (auto& ti : loader->Threads) {
		if (ti->threadId != tid) {
			ResetEvent(ti->Event);
		}
		else if (ti->threadId == tid) {
			loader->errorevent = ti->Event;
		}
	}
	auto emu_vsnw = Emu(uc);
	uint64_t buffer_ptr = emu_vsnw->rcx();
	uint64_t sizeInWords = emu_vsnw->rdx();
	uint64_t format_ptr = emu_vsnw->r8();
	uint64_t va_args_ptr = emu_vsnw->r9();

	std::vector<uint64_t> guest_args;
	for (int i = 0; i < 8; ++i) {
		uint64_t val = 0;
		val = emu_vsnw->read<uint64_t>(va_args_ptr + i * 8);
		guest_args.push_back(val);
	}

	std::wstring format;
	for (uint64_t addr = format_ptr;; addr += sizeof(wchar_t)) {
		wchar_t ch;
		ch = emu_vsnw->read<wchar_t>(addr);
		format.push_back(ch);
		if (ch == L'\0') break;
	}

	std::wstringstream ws;
	size_t arg_idx = 0;

	for (size_t i = 0; i < format.size(); ++i) {
		if (format[i] == L'%' && i + 1 < format.size()) {
			size_t j = i + 1;
			int zero_pad = 0;

			if (format[j] == L'0' && iswdigit(format[j + 1])) {
				j++;
				while (j < format.size() && iswdigit(format[j])) {
					zero_pad = zero_pad * 10 + (format[j] - L'0');
					j++;
				}
			}

			if (j + 1 < format.size() && format[j] == L'h' && format[j + 1] == L'u') {
				if (arg_idx < guest_args.size()) {
					uint16_t val = static_cast<uint16_t>(guest_args[arg_idx++]);
					ws << std::setfill(L'0') << std::setw(zero_pad) << val;
				}
				i = j + 1;
			}
			else if (format[j] == L'u' && arg_idx < guest_args.size()) {
				uint32_t val = static_cast<uint32_t>(guest_args[arg_idx++]);
				ws << std::setfill(L'0') << std::setw(zero_pad) << val;
				i = j;
			}
			else if (format[j] == L'X' && arg_idx < guest_args.size()) {
				uint32_t val = static_cast<uint32_t>(guest_args[arg_idx++]);
				ws << std::uppercase << std::hex << std::setfill(L'0') << std::setw(zero_pad) << val << std::dec;
				i = j;
			}
			else if (format[j] == L'S' && arg_idx < guest_args.size()) {
				char tmp[512] = {};
				auto tmpData = emu_vsnw->read(guest_args[arg_idx++], sizeof(tmp));
				memcpy(tmp, tmpData.data(), tmpData.size());
				ws << tmp;
				i = j;
			}
			else if (format[j] == L's' && arg_idx < guest_args.size()) {
				wchar_t tmp[512] = {};
				auto tmpData = emu_vsnw->read(guest_args[arg_idx++], sizeof(tmp));
				memcpy(tmp, tmpData.data(), tmpData.size());
				ws << tmp;
				i = j;
			}
			else if ((format[j] == L'd' || format[j] == L'i') && arg_idx < guest_args.size()) {
				int64_t val = static_cast<int64_t>(guest_args[arg_idx++]);
				ws << std::setfill(L'0') << std::setw(zero_pad) << val;
				i = j;
			}
			else if (format[j] == L'x' && arg_idx < guest_args.size()) {
				int64_t val = static_cast<int64_t>(guest_args[arg_idx++]);
				ws << std::hex << std::setfill(L'0') << std::setw(zero_pad) << val << std::dec;
				i = j;
			}
			else {
				ws << format[i];
			}
		}
		else {
			ws << format[i];
		}
	}
	std::wstring result = ws.str();
	std::string results;
	UnicodeToANSI(result, results);
	if (strcmp(results.c_str(), "\n") != 0) {
		std::string s = results + " \n";
		Logger::Log(true, ConsoleColor::RED, "_vsnwprintf\n");
		Logger::Log(true, ConsoleColor::RED, s.c_str());
	}

	size_t write_len = sizeInWords;
	emu_vsnw->write(buffer_ptr, result.c_str(), result.size());

	int ret = ws.str().size();
	emu_vsnw->rax(static_cast<uint64_t>(ret));


	RetHook(uc);
	for (auto& ti : loader->Threads) {
		SetEvent(ti->Event);
		loader->errorevent = nullptr;
	}
}
void Emulate::KeInitializeTimer(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "KeInitializeTimer\n");

	auto emu = Emu(uc);
	uint64_t timer_ptr = emu->rcx();
	Logger::Log(true, ConsoleColor::RED, "called with timer ptr : 0x%llx\n", timer_ptr);

	struct FAKE_KTIMER {
		uint8_t Header[0x18];
    	uint64_t DueTime;
    	uint64_t TimerListEntry[2];
    	void* Dpc;
    	uint32_t Period;
    };

	FAKE_KTIMER fake_timer = {};
	fake_timer.Header[0] = 0x08;
	emu->write(timer_ptr, &fake_timer, sizeof(fake_timer));

	Logger::Log(true, ConsoleColor::RED, "KTIMER initialized(fake)\n");

	uint64_t status = 0;
    emu->rax(status);
	RetHook(uc);
}
void Emulate::KeSetTimer(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "KeSetTimer\n");

	auto emu = Emu(uc);
	uint64_t timer_ptr = emu->rcx();
    uint64_t due_time_ptr = emu->rdx();
    uint64_t dpc_ptr = emu->r8();
	Logger::Log(true, ConsoleColor::DARK_GREEN, "called\n    Timer Ptr:     0x%llx\n    DueTime Ptr:   0x%llx\n    DPC Ptr:       0x%llx", timer_ptr, due_time_ptr, dpc_ptr);


	const size_t offset_DueTime = 0x18;
    const size_t offset_Dpc = 0x28;
	int64_t due_time_value = emu->read<int64_t>(due_time_ptr);
	Logger::Log(true, ConsoleColor::DARK_GREEN, "DueTime value: %d (100ns units)\n", due_time_value);

	emu->write(timer_ptr + offset_DueTime, due_time_value);
	emu->write(timer_ptr + offset_Dpc, dpc_ptr);
	uint32_t signal = 1;
	emu->write(timer_ptr + 0x0C, signal);
	uint64_t result = 0;
	emu->rax(result);

	Logger::Log(true, ConsoleColor::DARK_GREEN, "KTIMER Set\n");
	RetHook(uc);
}

void Emulate::KeReadStateTimer(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "KeReadStateTimer\n");
	return;
	auto emu = Emu(uc);
	uint64_t Timer = emu->rcx();
    int32_t SignalState = 0;
	emu->try_read(Timer + 0x4, &SignalState, sizeof(SignalState));

	Logger::Log(true, ConsoleColor::DARK_GREEN,
		"KeReadStateTimer\n"
		"  Timer: 0x%llx\n"
		"  SignalState: %d\n",
		Timer, SignalState);
	emu->rax(SignalState);

	RetHook(uc);
}
void Emulate::ExCreateCallback(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "ExCreateCallback\n");
	auto emu = Emu(uc);
	uint64_t callbackObjectPtr = emu->rcx();
    uint64_t ObjectAttributesAddr = emu->rdx();
    uint64_t create = emu->r8();
    uint64_t allowMultiple = emu->r9();
	OBJECT_ATTRIBUTES ObjectAttributes;
	ObjectAttributes = emu->read<OBJECT_ATTRIBUTES>(ObjectAttributesAddr);
	std::wstring file_name_str = read_unicode_string(uc, (uint64_t)ObjectAttributes.ObjectName);
	std::string str;
	UnicodeToANSI(file_name_str, str);
	Logger::Log(true, 8, "%s \n", str.c_str());

	uint64_t fake_callback_object = Emulate::HeapAlloc(uc, 0x1000);
	emu->write(callbackObjectPtr, fake_callback_object);

	uint64_t status = 0;
	emu->rax(status);

	Logger::Log(true, ConsoleColor::RED, "CallbackObject 0x%llx\n", fake_callback_object);
	RetHook(uc);
}
void Emulate::DebugPrompt(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "DebugPrompt\n");
	RetHook(uc);
}
void Emulate::DbgPrompt(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "DbgPrompt\n");
	auto emu = Emu(uc);
	uint64_t promptPtr = emu->rcx();
    uint64_t responsePtr = emu->rdx();
    uint64_t maxLen = emu->r8();
	std::vector<uint8_t> promptBuf = emu->read(promptPtr, 255);
	promptBuf.push_back(0);
	std::string prompt(reinterpret_cast<char*>(promptBuf.data()));
	uint64_t rsp = emu->rsp();
	auto lastExceptData = emu->read(rsp, sizeof(loader->lastExcept));
	memcpy(&loader->lastExcept, lastExceptData.data(), lastExceptData.size());
	Logger::Log(true, 12, "%s\n", prompt.c_str());
	Unicorn::seh_Handle(uc);

}


void Emulate::ExAcquireRundownProtection(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "ExAcquireRundownProtection\n");
	auto emu = Emu(uc);
	uint64_t rundownRefPtr = emu->rcx();

	uint64_t count = emu->qword(rundownRefPtr);

	Logger::Log(true, ConsoleColor::RED, "called, Count = %d\n", count);

	bool success = false;

	if (count != 0 && count < 0xFFFFFFF0) {
		count++;
    	emu->write(rundownRefPtr, count);
		success = true;
	}

	uint64_t result = 1;
	emu->rax(result);

	Logger::Log(true, ConsoleColor::RED, "Result = %s\n", (success ? "TRUE" : "FALSE"));
	RetHook(uc);
}



void Emulate::_wcscpy_s(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "_wcscpy_s\n");
	auto emu = Emu(uc);
	uint64_t dest_addr = emu->rcx();

	rsize_t destsz = static_cast<rsize_t>(emu->rdx());

	uint64_t src_addr = emu->r8();
	std::wstring src_str;
	read_null_unicode_string(uc, src_addr, src_str);
	uint64_t rbp = emu->rbp();
	uint64_t rbpValue;

	rbpValue = emu->read<uint64_t>(rbp - 0x49);
	size_t total_length = src_str.length() + 1;

	if (total_length * sizeof(wchar_t) > destsz) {
		Logger::Log(true, ConsoleColor::RED, "wcscpy_s: Buffer too small need %zu bytes; Got %zu bytes\n", total_length * sizeof(wchar_t), destsz);


		uint64_t error_code = 22;
    	emu->rax(error_code);
		RetHook(uc);
		return;
	}

	emu->write(dest_addr, src_str.c_str(), total_length * sizeof(wchar_t));

	Logger::Log(true, ConsoleColor::RED, "wcscpy_s: Copied string = %s\n", std::string(src_str.begin(), src_str.end()));

	uint64_t success_code = 0;
	emu->rax(success_code);

	RetHook(uc);
}
void Emulate::KeIpiGenericCall(uc_engine* uc, uint64_t address, uint32_t size, void* user_data)
{
	Logger::Log(true, ConsoleColor::RED, "KeIpiGenericCall\n");
	auto emu = Emu(uc);
	uint64_t routine = emu->rcx();
    uint64_t context = emu->rdx();
	emu->rip(routine);
	Logger::Log(true, 12, " jmp to %llx\n", routine);


}
void Emulate::KdChangeOption(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "KdChangeOption\n");
	auto emu = Emu(uc);
	emu->rax(0xC0000354);
    RetHook(uc);
}

void Emulate::MmIsAddressValid(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "MmIsAddressValid\n");
	auto emu = Emu(uc);
	uint64_t virtAddr = emu->rcx();

	bool isValid = false;
	uint64_t tmp = 0;
	if (emu->try_read(virtAddr, &tmp, sizeof(tmp))) {
		isValid = true;
	}
	emu->rax(isValid);
	Logger::Log(true, 12, "Address 0x%llx is %s\n", virtAddr, isValid ? "valid" : "invalid");

	RetHook(uc);
}
void Emulate::RtlInitializeBitMap(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "RtlInitializeBitMap\n");
	auto emu = Emu(uc);
	uint64_t bitmap_struct_addr = emu->rcx();
	uint64_t bitmap_buffer_addr = emu->rdx();
	uint64_t bit_size = emu->r8();

	struct {
		uint32_t SizeOfBitMap;
		uint64_t Buffer;
	} RTL_BITMAP_STRUCT;

	RTL_BITMAP_STRUCT.SizeOfBitMap = (uint32_t)bit_size;
	RTL_BITMAP_STRUCT.Buffer = bitmap_buffer_addr;

	emu->write(bitmap_struct_addr, &RTL_BITMAP_STRUCT, sizeof(RTL_BITMAP_STRUCT));
	Logger::Log(true, ConsoleColor::RED, "Bitmap initialized at 0x%llx Buffer address %llx\n", bitmap_struct_addr, bitmap_buffer_addr);

	RetHook(uc);}

void Emulate::RtlSetBits(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "RtlSetBits\n");
	auto emu = Emu(uc);
	uint64_t bitmap_addr = emu->rcx();
    uint64_t start_index = emu->rdx();
    uint64_t bit_count = emu->r8();
	if (bitmap_addr == 0 || bit_count == 0) {
		std::cerr << "[-] RtlSetBits: Invalid parameters (null or zero count)" << std::endl;
		RetHook(uc);
		return;
	}

	struct {
		ULONG  SizeOfBitMap;
		uint64_t Buffer;
	} bitmap;

	bitmap = emu->read<decltype(bitmap)>(bitmap_addr);


	if (bitmap.Buffer == 0 || bitmap.SizeOfBitMap == 0 || start_index + bit_count > bitmap.SizeOfBitMap) {
		std::cerr << "[-] RtlSetBits: Invalid bitmap range or buffer" << std::endl;
		RetHook(uc);
		return;
	}
	Logger::Log(true, ConsoleColor::RED, "RtlSetBits: Set %d bits at pos 0x%llx (Total bits: 0x%llx) Buffer=0x%llx\n", bit_count, start_index, bitmap.SizeOfBitMap, bitmap.Buffer);

	/*for (uint32_t i = 0; i < bit_count; ++i) {
		uint32_t bit_index = (uint32_t)(start_index + i);
		uint64_t byte_offset = bit_index / 8;
		uint8_t  bit_mask = 1 << (bit_index % 8);

		uint8_t byte_value = 0;
		uc_mem_read(uc, bitmap_addr + byte_offset, &byte_value, 1);
		byte_value |= bit_mask;
		uc_mem_write(uc, bitmap_addr + byte_offset, &byte_value, 1);
	}*/



	Logger::Log(true, 12, "RtlSetBits: Set %llx bits at pos %llx (Total bits : %llx ) Address: %llx\n", bit_count, start_index, bitmap.SizeOfBitMap, bitmap_addr);

	PEloader* loader = &PEloader::GetInstance();
	uint64_t t;

}

bool EnableDebugPrivilege() {
	HANDLE hToken;
	TOKEN_PRIVILEGES tp;
	LUID luid;

	if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
		return false;

	if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &luid)) {
		CloseHandle(hToken);
		return false;
	}

	tp.PrivilegeCount = 1;
	tp.Privileges[0].Luid = luid;
	tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

	BOOL result = AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(tp), NULL, NULL);
	CloseHandle(hToken);

	return result && GetLastError() == ERROR_SUCCESS;
}
void Emulate::PsLookupProcessByProcessId(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "PsLookupProcessByProcessId\n");
	auto emu = Emu(uc);
	uint64_t pid = emu->rcx();
	uint64_t outEprocessPtr = emu->rdx();
	Logger::Log(true, ConsoleColor::RED, "PsLookupProcessByProcessId Search PID: %llx\n", pid);
	if (pid == 4) {
		uint64_t base = 0;
		emu->rdx(base);
		Logger::Log(true, 12, "PsLookupProcessByProcessId System 4\n");
		uint64_t status = STATUS_SUCCESS;
    	emu->rax(status);
		RetHook(uc);
		return;
	}
	uint64_t status = 0xC000000D;
    emu->rax(status);
	RetHook(uc);
}

void Emulate::PsGetProcessImageFileName(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "PsGetProcessImageFileName\n");
	return;
	auto emu = Emu(uc);
	uint64_t eprocess = emu->rcx();
	if (eprocess == 0) {
		Logger::Log(true, ConsoleColor::DARK_GREEN, "PsGetProcessImageFileName: Invalid EPROCESS pointer \n ");
		uint64_t null = 0;
		emu->rax(null);
		RetHook(uc);
		return;
	}

	uint64_t image_name_addr = emu->read<uint64_t>(eprocess + 0x5a8);
    char image_name[16] = { 0 };
    emu->try_read(image_name_addr, image_name, sizeof(image_name));
    emu->rax(image_name_addr);

	Logger::Log(true, ConsoleColor::DARK_GREEN, "ImageFileName: %s\n", image_name);

	RetHook(uc);
}

void Emulate::PsGetProcessSectionBaseAddress(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "PsGetProcessSectionBaseAddress\n");
	auto emu = Emu(uc);
	uint64_t eprocess = emu->rcx();

	if (eprocess == 0) {
		Logger::Log(true, ConsoleColor::GREEN, "PsGetProcessSectionBaseAddress: Invalid EPROCESS\n");
		Logger::Log(true, ConsoleColor::DARK_GREEN, "PsGetProcessSectionBaseAddress: Invalid EPROCESS pointer \n");
		uint64_t null = 0;
		emu->rax(null);
		RetHook(uc);
		return;
	}

	uint64_t image_base = emu->read<uint64_t>(eprocess + 0x520);
	Logger::Log(true, ConsoleColor::DARK_GREEN, "PsGetProcessSectionBaseAddress: ImageBase = 0x%llx\n", image_base);

	emu->rax(image_base);
	RetHook(uc);
}

void Emulate::PsGetSessionId(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "PsGetSessionId\n");
	auto emu = Emu(uc);
	uint64_t eprocess = emu->rcx();

	if (eprocess == 0) {
		Logger::Log(true, ConsoleColor::DARK_GREEN, "PsGetSessionId: Invalid EPROCESS pointer \n");
		uint64_t zero = 0;
		emu->rax(zero);
		RetHook(uc);
		return;
	}

	uint32_t sessionId = emu->read<uint32_t>(eprocess + 0x448);
	Logger::Log(true, ConsoleColor::DARK_GREEN, "PsGetSessionId : Session ID = %d\n", sessionId);

	emu->rax(static_cast<uint64_t>(sessionId));
	RetHook(uc);
}

typedef enum _FILE_INFORMATION_CLASS {
	FileDirectoryInformation = 1,
	FileFullDirectoryInformation,
	FileBothDirectoryInformation,
	FileBasicInformation = 4,
	FileStandardInformation = 5,
} FILE_INFORMATION_CLASS;

void Emulate::IoCreateFileEx(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "IoCreateFileEx\n");
	auto emu = Emu(uc);
	uint64_t FileHandle, DesiredAccess, ObjectAttributesAddr, IoStatusBlock, AllocationSize, DriverContext, InternalParameters;
	uint32_t FileAttributes, ShareAccess, Disposition, CreateOptions, CreateFileType, EaBuffer, EaLength;
	FileHandle = emu->rcx();

	DesiredAccess = emu->rdx();
	uint32_t DesiredAccess32 = static_cast<uint32_t>(DesiredAccess);
    ObjectAttributesAddr = emu->r8();
	OBJECT_ATTRIBUTES ObjectAttributes;
	emu->try_read(ObjectAttributesAddr, &ObjectAttributes, sizeof(ObjectAttributes));
	std::wstring file_name_str = read_unicode_string(uc, (uint64_t)ObjectAttributes.ObjectName);
	std::string str;
	UnicodeToANSI(file_name_str, str);
	Logger::Log(true, 12, "IoCreateFileEx Path: %s\n", str.c_str());
	IoStatusBlock = emu->r9();

	uint64_t rsp = emu->rsp();
	rsp = rsp + 8;
	emu->try_read(rsp + 0x20, &AllocationSize, sizeof(AllocationSize));
	emu->try_read(rsp + 0x28, &FileAttributes, sizeof(FileAttributes));
	emu->try_read(rsp + 0x30, &ShareAccess, sizeof(ShareAccess));
	emu->try_read(rsp + 0x38, &Disposition, sizeof(Disposition));
	emu->try_read(rsp + 0x40, &CreateOptions, sizeof(CreateOptions));
	emu->try_read(rsp + 0x48, &EaBuffer, sizeof(EaBuffer));
	emu->try_read(rsp + 0x50, &EaLength, sizeof(EaLength));
	emu->try_read(rsp + 0x58, &CreateFileType, sizeof(CreateFileType));
	emu->try_read(rsp + 0x70, &DriverContext, sizeof(DriverContext));
	emu->try_read(rsp + 0x80, &InternalParameters, sizeof(InternalParameters));
	UNICODE_STRING KeyPath;
	ConvertToUnicodeString(KeyPath, file_name_str);
	OBJECT_ATTRIBUTES objAttr = { 0 };
	InitializeObjectAttributes(&objAttr, (uint64_t)&KeyPath, OBJ_CASE_INSENSITIVE, NULL, NULL);
	IO_STATUS_BLOCK io_status = { 0 };
	LARGE_INTEGER allocationSize;
	allocationSize.QuadPart = 0;
    HANDLE real_file_handle = nullptr;

	std::wstring prefix = L"\\??\\";
	std::wstring system32prefix = L"system32";
	std::wstring System32prefix = L"System32";
	std::wstring vgkbootstatusprefix = L"vgkbootstatus";
#define FILE_OPEN                       0x00000001
	if (file_name_str.find(system32prefix, 0) != std::wstring::npos ||
		file_name_str.find(System32prefix, 0) != std::wstring::npos ||
		file_name_str.find(vgkbootstatusprefix, 0) != std::wstring::npos)
	{
		auto ret = __NtRoutine("NtCreateFile", &real_file_handle,
			DesiredAccess,
			&objAttr,
			&io_status,
			nullptr,
			FileAttributes,
			ShareAccess,
			Disposition,
			CreateOptions,
			nullptr,
			0
		);
		emu->write(IoStatusBlock, &io_status, sizeof(io_status));

		Logger::Log(true, 10, "NtCreateFile Handle %llx    status : %lx \n", real_file_handle, ret);

		emu->write(FileHandle, &real_file_handle, sizeof(real_file_handle));
		emu->rax(ret);
		RetHook(uc);
		return;
	}
	else
	{
		if (file_name_str.rfind(prefix, 0) == 0) {
			file_name_str = file_name_str.substr(prefix.length());
    	}
		real_file_handle = CreateFile(
			file_name_str.c_str(),			FILE_APPEND_DATA,			FILE_SHARE_READ | FILE_SHARE_WRITE,			NULL,			OPEN_ALWAYS,			FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,			NULL		);

		if (real_file_handle == INVALID_HANDLE_VALUE) {
			DWORD errorCode = GetLastError();
			std::cerr << "CreateFile failed, error code: " << errorCode << std::endl;
			auto ret = 0xC000000D;
			emu->rax(ret);
			RetHook(uc);
			return;
		}
		else
		{
			auto ret = 0;
			Logger::Log(true, 10, "CreateFile Handle %llx    status : %lx \n", real_file_handle, ret);
			emu->write(FileHandle, &real_file_handle, sizeof(real_file_handle));
			emu->rax(ret);
			RetHook(uc);
			return;
		}

	}
}

void Emulate::wcscat_s(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "wcscat_s\n");
	auto emu = Emu(uc);
	uint64_t dest_addr = emu->rcx();

	rsize_t destsz = static_cast<rsize_t>(emu->rdx());

	uint64_t src_addr = emu->r8();

	std::wstring dest_str;
	read_null_unicode_string(uc, dest_addr, dest_str);
	std::wstring src_str;
	read_null_unicode_string(uc, src_addr, src_str);
	size_t total_length = dest_str.length() + src_str.length() + 1;

	if (total_length * sizeof(wchar_t) > destsz) {
		Logger::Log(true, ConsoleColor::DARK_GREEN, " wcscat_s: Target buffer too small! Need %d bytes, but only %d \n", total_length * sizeof(wchar_t), destsz);
		uint64_t error_code = 22;
    	emu->rax(error_code);
		return;
	}

	dest_str += src_str;

	emu->write(dest_addr, dest_str.c_str(), total_length * sizeof(wchar_t));

	Logger::Log(true, ConsoleColor::RED, "wcscat_s: Concat = %s\n", std::string(dest_str.begin(), dest_str.end()).c_str());
	uint64_t success_code = 0;
	emu->rax(success_code);

	RetHook(uc);
}

void Emulate::RtlMultiByteToUnicodeN(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "RtlMultiByteToUnicodeN\n");
	auto emu = Emu(uc);
	uint64_t unicode_str_ptr = emu->rcx();
    uint64_t unicode_size = emu->rdx();
    uint64_t result_size_ptr = emu->r8();
    uint64_t multi_byte_str_ptr = emu->r9();
    uint64_t rsp_value = emu->rsp();
	uint64_t multi_byte_size_addr = rsp_value + 0x28;
	uint32_t multi_byte_size = 0;
	emu->try_read(multi_byte_size_addr, &multi_byte_size, sizeof(multi_byte_size));


	std::vector<char> multi_byte_str(multi_byte_size + 1, 0);
	emu->try_read(multi_byte_str_ptr, multi_byte_str.data(), multi_byte_size);

	int wide_char_size = MultiByteToWideChar(CP_ACP, 0, multi_byte_str.data(), -1, NULL, 0);
	std::vector<wchar_t> unicode_str(wide_char_size, 0);
	MultiByteToWideChar(CP_ACP, 0, multi_byte_str.data(), -1, unicode_str.data(), wide_char_size);

	uint64_t unicode_length = unicode_str.size() + 1 * sizeof(wchar_t);

	uint64_t status = 0;
    if (unicode_length > unicode_size) {
		unicode_length = unicode_size;
		status = 0xC0000023;
    }

	Logger::Log(true, ConsoleColor::DARK_GREEN, "Before conversion (MultiByte): %s After conversion (Unicode): %s \n", multi_byte_str.data(), unicode_str.data());

	emu->write(unicode_str_ptr, unicode_str.data(), unicode_size);

	if (result_size_ptr) {
		emu->write(result_size_ptr, &unicode_size, sizeof(uint32_t));
	}

	emu->rax(status);
	RetHook(uc);
}


std::map<std::string, std::map<std::string, std::vector<uint8_t>>> Emulate::registry;
void Emulate::RtlWriteRegistryValue(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "RtlWriteRegistryValue\n");
	auto emu = Emu(uc);
	uint64_t relativeTo = emu->rcx();
    uint64_t pathAddr = emu->rdx();
    uint64_t valueNameAddr = emu->r8();
    uint64_t valueType = emu->r9();
	uint64_t stackPointer = emu->rsp();

	uint64_t valueDataAddr = 0;
	emu->try_read(stackPointer + 0x28, &valueDataAddr, sizeof(valueDataAddr));
    uint64_t valueLength = 0;
	emu->try_read(stackPointer + 0x30, &valueLength, sizeof(valueLength));
	std::wstring wstr = read_unicode_string(uc, pathAddr);
	std::string str;
	UnicodeToANSI(wstr, str);

	std::wstring wstr_valueNameAddr = read_unicode_string(uc, valueNameAddr);
	std::string str_valueNameAddr;
	UnicodeToANSI(wstr_valueNameAddr, str_valueNameAddr);

	std::vector<uint8_t> valueData(static_cast<size_t>(valueLength));
	emu->try_read(valueDataAddr, valueData.data(), static_cast<size_t>(valueLength));

	std::string pathStr(str);
	std::string valueNameStr(str_valueNameAddr);
	registry[pathStr][valueNameStr] = valueData;

	Logger::Log(true, ConsoleColor::DARK_GREEN, " Path: %s ValueName : %s ValueType : %d ValueLength: %d \n", pathStr, valueNameStr, valueType, valueLength);

	uint64_t status = 0;
    emu->rax(status);
    RetHook(uc);
}

void Emulate::RtlDeleteRegistryValue(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "RtlDeleteRegistryValue\n");
	auto emu = Emu(uc);
	uint64_t relativeTo = emu->rcx();
    uint64_t pathAddr = emu->rdx();
    uint64_t valueNameAddr = emu->r8();
	std::wstring wstr = read_unicode_string(uc, pathAddr);
	std::string str;
	UnicodeToANSI(wstr, str);


	std::wstring wstr_valueNameAddr = read_unicode_string(uc, valueNameAddr);
	std::string str_valueNameAddr;
	UnicodeToANSI(wstr_valueNameAddr, str_valueNameAddr);



	Logger::Log(true, ConsoleColor::DARK_GREEN, " Value :%llx not found in path \n ", str_valueNameAddr);
	uint64_t status = 0xC0000034;
    emu->rax(status);
	RetHook(uc);
}

void Emulate::ZwOpenKey(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "ZwOpenKey\n");
	auto emu = Emu(uc);
	uint64_t keyHandleAddr = emu->rcx();
    uint64_t desiredAccess = emu->rdx();
    uint64_t objectAttributesAddr = emu->r8();
    uint64_t rsp = emu->rsp();

	OBJECT_ATTRIBUTES ObjectAttributes;
	emu->try_read(objectAttributesAddr, &ObjectAttributes, sizeof(ObjectAttributes));
    std::wstring file_name_str = read_unicode_string(uc, ObjectAttributes.ObjectName);
	std::string str;
	UnicodeToANSI(file_name_str, str);

	HANDLE realHandle = nullptr;
	UNICODE_STRING KeyPath;
	ConvertToUnicodeString(KeyPath, file_name_str);
	OBJECT_ATTRIBUTES objAttr = { 0 };
	InitializeObjectAttributes(&objAttr, (uint64_t)&KeyPath, objAttr.Attributes, nullptr, nullptr);

	NTSTATUS ret = __NtRoutine("NtOpenKey", &realHandle, (ACCESS_MASK)desiredAccess, &objAttr);
	Logger::Log(true, 12, "Directory name: %s status : %lx\n", str.c_str(), ret);
	if (ret == 0) {
		uint64_t t;
		emu->write(keyHandleAddr, &realHandle, sizeof(realHandle));
	}

	emu->rax(ret);
	RetHook(uc);
}
void Emulate::ZwQueryValueKey(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "ZwQueryValueKey\n");
	auto emu = Emu(uc);
	uint64_t rcx = emu->rcx();
    uint64_t rdx = emu->rdx();
    uint64_t r8 = emu->r8();
    uint64_t outBufPtr = emu->r9();
    uint32_t bufLen = 0;
	uint64_t rsp = emu->rsp();
    emu->try_read(rsp + 0x28, &bufLen, sizeof(bufLen));
	uint64_t resultLenPtr = 0;
	emu->try_read(rsp + 0x30, &resultLenPtr, sizeof(resultLenPtr));
	if (rcx == 0 || resultLenPtr == 0) {
		Logger::Log(true, 12, "ZwQueryValueKey: Invalid KeyHandle \n");
		uint64_t status = STATUS_INVALID_HANDLE;
		emu->rax(status);
		RetHook(uc);
		return;
	}

	std::wstring valueNameW = read_unicode_string(uc, rdx);
	std::string svalueNameW;
	UnicodeToANSI(valueNameW, svalueNameW);
	UNICODE_STRING valueName;
	ConvertToUnicodeString(valueName, valueNameW);
	std::vector<uint8_t> buffer(bufLen);
	ULONG resultLength = 0;
	NTSTATUS status = __NtRoutine("NtQueryValueKey",
		reinterpret_cast<HANDLE>(rcx),
		&valueName,
		r8,
		buffer.data(),
		(ULONG)bufLen,
		&resultLength);

	buffer.resize(resultLength);

	status = __NtRoutine("NtQueryValueKey",
		reinterpret_cast<HANDLE>(rcx),
		&valueName,
		r8,
		buffer.data(),
		(ULONG)resultLength,
		&resultLength);
	Logger::Log(true, 12, "ZwQueryValueKey KeyHandle: %llx  Value=:%s \n", rcx, svalueNameW.c_str());

	if (status == 0) {

		uint64_t buffer_temp = Emulate::HeapAlloc(uc, 0x1000);
		emu->write(buffer_temp, buffer.data(), buffer.size());
		emu->r9(buffer_temp);
    	emu->write(resultLenPtr, &resultLength, sizeof(ULONG));
	}

	emu->rax(status);
	RetHook(uc);
}
void Emulate::ZwCreateKey(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "ZwCreateKey\n");
	auto emu = Emu(uc);
	uint64_t rcx = emu->rcx();
    uint64_t rdx = emu->rdx();
    uint64_t r8 = emu->r8();
    uint64_t r9 = emu->r9();
    uint64_t r10 = emu->r10();
    uint64_t r11 = emu->r11();
	if (r8 == 0) {
		Logger::Log(true, ConsoleColor::DARK_GREEN, "Invalid ObjectAttributes \n");
		NTSTATUS status = STATUS_INVALID_PARAMETER;
		emu->rax(status);
		RetHook(uc);
		return;
	}

	OBJECT_ATTRIBUTES ObjectAttributes;
	emu->try_read(r8, &ObjectAttributes, sizeof(ObjectAttributes));
    std::wstring file_name_str = read_unicode_string(uc, (uint64_t)ObjectAttributes.ObjectName);

	std::string str;
	UnicodeToANSI(file_name_str, str);
	Logger::Log(true, ConsoleColor::DARK_GREEN, "Path: %s\n", str.c_str());
	static std::unordered_set<std::wstring> fake_registry_keys;
	uint64_t disposition = REG_CREATED_NEW_KEY;
	NTSTATUS status = STATUS_SUCCESS;

	if (fake_registry_keys.count(file_name_str)) {
		Logger::Log(true, ConsoleColor::DARK_GREEN, "Key Exist\n");
		disposition = REG_OPENED_EXISTING_KEY;
	}
	else {
		Logger::Log(true, ConsoleColor::GREEN, "Key does not exist, create new key\n");
		fake_registry_keys.insert(file_name_str);
	}

	uint64_t fake_handle = 0xaa;
	emu->write(rcx, &fake_handle, sizeof(fake_handle));

	emu->write(r11, &disposition, sizeof(disposition));

	emu->rax(status);
	RetHook(uc);
}


void Emulate::ZwSetValueKey(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "ZwSetValueKey\n");
	auto emu = Emu(uc);
	uint64_t hKey = emu->rcx();
	uint64_t valueNameAddr = emu->rdx();
	uint64_t titleIndex = emu->r8();
	uint64_t type = emu->r9();

	uint64_t rsp = emu->rsp();
	uint64_t dataAddr = 0;
	emu->try_read(rsp + 0x28, &dataAddr, sizeof(uint64_t));
	uint32_t dataSize = 0;
	emu->try_read(rsp + 0x30, &dataSize, sizeof(uint32_t));
	std::wstring file_name_str = read_unicode_string(uc, valueNameAddr);

	UNICODE_STRING realStr;
	ConvertToUnicodeString(realStr, file_name_str);
	std::string st;
	UnicodeToANSI(file_name_str, st);
	std::vector<uint8_t> buffer(dataSize);
	emu->try_read(dataAddr, buffer.data(), buffer.size());
	Logger::Log(true, DARK_GREEN, "KeyHandle: %llx  Value=:%s \n", hKey, st);
	auto ret = __NtRoutine("NtSetValueKey",
		reinterpret_cast<HANDLE>(hKey),
		&realStr,
		static_cast<ULONG>(titleIndex),
		static_cast<ULONG>(type),
		buffer.data(),
		static_cast<ULONG>(dataSize)
	);
	uint64_t status = ret;
    emu->rax(status);
	RetHook(uc);
}
void Emulate::ZwDeleteValueKey(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "ZwDeleteValueKey\n");
	auto emu = Emu(uc);
	uint64_t KeyHandle = emu->rcx();
    uint64_t ValueNamePtr = emu->rdx();
	std::wstring value_name = read_unicode_string(uc, ValueNamePtr);


	std::string found_key;

	for (const auto& entry : registryHandles) {
		if (entry.second == KeyHandle) {
			found_key = entry.first;
			break;
    	}
	}
	std::wstring key_name;
	ANSIToUnicode(found_key, key_name);
	std::wstring key_path = key_name;



	RetHook(uc);
}

void Emulate::RtlRandomEx(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	auto emu = Emu(uc);
	uint64_t seed_ptr;
    uint64_t rip;
    uint32_t seed_value;
    uint32_t random_value;
	seed_ptr = emu->rcx();
    rip = emu->rip();
    emu->try_read(seed_ptr, &seed_value, sizeof(seed_value));

	seed_value = seed_value * 214013 + 2531011;
	random_value = (seed_value >> 16) & 0x7FFFFFFF;

	emu->write(seed_ptr, &seed_value, sizeof(seed_value));

	emu->rax(random_value);
	RetHook(uc);
}

void Emulate::KeAreAllApcsDisabled(uc_engine* uc, uint64_t address, uint32_t size, void* user_data)
{
	Logger::Log(true, ConsoleColor::RED, "KeAreAllApcsDisabled\n");
	return;
	uint64_t status = 0;
    auto emu = Emu(uc);
	emu->rax(status);
	RetHook(uc);
}
void Emulate::KeInitializeGuardedMutex(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "KeInitializeGuardedMutex\n");
	auto emu = Emu(uc);
	uint64_t mutexPtr = emu->rcx();
	Logger::Log(true, ConsoleColor::RED, "Initialize @ 0x%llx\n", mutexPtr);

	RetHook(uc);

}

void Emulate::ZwDeviceIoControlFile(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	auto emu = Emu(uc);
	uint64_t fileHandle = emu->rcx();
	uint64_t event = emu->rdx();
	uint64_t ioStatusBlock = emu->r8();
	uint64_t apcRoutine = emu->r9();
	uint64_t apcContext = 0;
	uint64_t ioControlCode = 0;
	uint64_t inputBuffer = 0;
	uint32_t inputBufferLength = 0;
	uint64_t outputBuffer = 0;
	uint32_t outputBufferLength = 0;

	uint64_t rsp = emu->rsp();
	emu->try_read(rsp + 0x8, &ioStatusBlock, sizeof(uint64_t));
	emu->try_read(rsp + 0x28, &apcContext, sizeof(uint64_t));
	emu->try_read(rsp + 0x30, &ioControlCode, sizeof(uint64_t));
	emu->try_read(rsp + 0x38, &inputBuffer, sizeof(inputBuffer));
	emu->try_read(rsp + 0x40, &inputBufferLength, sizeof(inputBufferLength));
	emu->try_read(rsp + 0x48, &outputBuffer, sizeof(outputBuffer));
	emu->try_read(rsp + 0x50, &outputBufferLength, sizeof(outputBufferLength));
	Logger::Log(true, ConsoleColor::RED, "ZwDeviceIoControlFile\n");
	Logger::Log(true, ConsoleColor::RED, "IOCTL = 0x%llx \n", ioControlCode);
	std::vector<uint8_t> input(inputBufferLength);
	emu->try_read(inputBuffer, input.data(), inputBufferLength);

	std::vector<uint8_t> output(outputBufferLength, 0);
	DWORD bytesReturned = 0;


	BOOL result = ::DeviceIoControl(
		(HANDLE)fileHandle,
		static_cast<DWORD>(ioControlCode),
		input.data(), static_cast<DWORD>(input.size()),
		output.data(), static_cast<DWORD>(output.size()),
		&bytesReturned,
		nullptr
	);

	NTSTATUS status = result ? 0 : HRESULT_FROM_WIN32(GetLastError());

	if (result) {
		emu->write(outputBuffer, output.data(), bytesReturned);
	}

	struct IO_STATUS_BLOCK {
		NTSTATUS Status;
		ULONG_PTR Information;
	} iosb = { status, bytesReturned };

	emu->write(ioStatusBlock, &iosb, sizeof(iosb));
	emu->rax(status);
	RetHook(uc);
}


void Emulate::ZwCreateFile(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "ZwCreateFile\n");
	auto emu = Emu(uc);
	uint64_t FileHandle, DesiredAccess, ObjectAttributesAddr, IoStatusBlock, AllocationSize, DriverContext, InternalParameters;
	uint32_t FileAttributes, ShareAccess, Disposition, CreateOptions, CreateFileType, EaBuffer, EaLength;
	FileHandle = emu->rcx();

	DesiredAccess = emu->rdx();
	uint32_t DesiredAccess32 = static_cast<uint32_t>(DesiredAccess);
    ObjectAttributesAddr = emu->r8();
	OBJECT_ATTRIBUTES ObjectAttributes;
	emu->try_read(ObjectAttributesAddr, &ObjectAttributes, sizeof(ObjectAttributes));
	std::wstring file_name_str = read_unicode_string(uc, (uint64_t)ObjectAttributes.ObjectName);
	std::string str;
	UnicodeToANSI(file_name_str, str);
	Logger::Log(true, ConsoleColor::RED, "Path: %s\n", str.c_str());
	IoStatusBlock = emu->r9();

	uint64_t rsp = emu->rsp();
	rsp = rsp + 8;
	emu->try_read(rsp + 0x20, &AllocationSize, sizeof(AllocationSize));
	emu->try_read(rsp + 0x28, &FileAttributes, sizeof(FileAttributes));
	emu->try_read(rsp + 0x30, &ShareAccess, sizeof(ShareAccess));
	emu->try_read(rsp + 0x38, &Disposition, sizeof(Disposition));
	emu->try_read(rsp + 0x40, &CreateOptions, sizeof(CreateOptions));
	emu->try_read(rsp + 0x48, &EaBuffer, sizeof(EaBuffer));
	emu->try_read(rsp + 0x50, &EaLength, sizeof(EaLength));
	emu->try_read(rsp + 0x58, &CreateFileType, sizeof(CreateFileType));
	emu->try_read(rsp + 0x70, &DriverContext, sizeof(DriverContext));
	emu->try_read(rsp + 0x80, &InternalParameters, sizeof(InternalParameters));
	UNICODE_STRING KeyPath;
	ConvertToUnicodeString(KeyPath, file_name_str);
	OBJECT_ATTRIBUTES objAttr = { 0 };
	InitializeObjectAttributes(&objAttr, (uint64_t)&KeyPath, OBJ_CASE_INSENSITIVE, NULL, NULL);
	IO_STATUS_BLOCK io_status = { 0 };
	LARGE_INTEGER allocationSize;
	allocationSize.QuadPart = 0;
    uint32_t ret = 0;
	HANDLE real_file_handle = nullptr;


#define FILE_OPEN                       0x00000001

	ret = __NtRoutine("NtCreateFile", &real_file_handle,
		DesiredAccess,
		&objAttr,
		&io_status,
		nullptr,
		FileAttributes,
		ShareAccess,
		Disposition,
		CreateOptions,
		nullptr,
		0
	);
	emu->write(IoStatusBlock, &io_status, sizeof(io_status));

	Logger::Log(true, 10, "NtCreateFile Handle %llx    status : %llx \n", real_file_handle, ret);

	emu->write(FileHandle, &real_file_handle, sizeof(real_file_handle));
	emu->rax(ret);
	RetHook(uc);
	return;


}
void Emulate::ZwWriteFile(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "ZwWriteFile\n");
	auto emu = Emu(uc);
	uint64_t file_handle = emu->rcx();
	uint64_t event = emu->rdx();
	uint64_t apc_routine = emu->r8();
	uint64_t apc_context = emu->r9();
	uint64_t io_status_block = 0;
	uint64_t buffer_addr = 0;
	uint64_t byte_offset = 0;
	uint32_t key = 0;
	uint32_t length = 0;
	uint64_t rsp = emu->rsp();
	emu->try_read(rsp + 0x28, &io_status_block, sizeof(uint64_t));
	emu->try_read(rsp + 0x30, &buffer_addr, sizeof(uint64_t));
	emu->try_read(rsp + 0x38, &length, sizeof(uint32_t));
	emu->try_read(rsp + 0x40, &byte_offset, sizeof(uint64_t));
	emu->try_read(rsp + 0x48, &key, sizeof(uint32_t));

	if (file_handle == 0) {
		Logger::Log(true, ConsoleColor::DARK_GREEN, "Invalid file handle\n");
		uint64_t status_invalid = 0xC0000008;
    	emu->rax(status_invalid);
		RetHook(uc);
		return;
	}

	if (length == 0) {
		Logger::Log(true, ConsoleColor::DARK_GREEN, "Write length is 0, no operation\n");
		uint64_t status_success = 0x0;
    	emu->rax(status_success);
		RetHook(uc);
		return;
	}

	std::vector<uint8_t> buffer(length);
	if (!emu->try_read(buffer_addr, buffer.data(), length)) {
		Logger::Log(true, ConsoleColor::DARK_GREEN, "Unable to read buffer\n");
		uint64_t status_access_violation = 0xC0000005;
    	emu->rax(status_access_violation);
		RetHook(uc);
		return;
	}


	DWORD bytesWritten;
	uint64_t status = 0;
	BOOL writeSuccess = WriteFile(
		(HANDLE)file_handle,
		buffer.data(),
		buffer.size(),
		&bytesWritten,
		NULL	);

	if (!writeSuccess) {
		std::cerr << "WriteFile failed, error code: " << GetLastError() << std::endl;
		status = GetLastError();
	}
	else {
		Logger::Log(true, ConsoleColor::DARK_GREEN, "Write successful, bytes written: %d \n", bytesWritten);
	}


	Logger::Log(true, 10, "NtWriteFile Handle: %llx\nLength: %d\nContent: ", file_handle, length);
	for (size_t i = 0; i < length; i++) {
		Logger::Log(false, ConsoleColor::DARK_GREEN, "%llx", (int)buffer[i]);
	}
	Logger::Log(false, ConsoleColor::DARK_GREEN, "\n");




	emu->rax(status);
	RetHook(uc);
}
void Emulate::ZwFlushBuffersFile(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {

	DWORD tid = GetCurrentThreadId();

	for (auto& ti : loader->Threads) {
		ResetEvent(ti->Event);
		if (ti->threadId == tid) {
			if (loader->errorevent != nullptr && loader->errorevent != ti->Event)
			{
				WaitForSingleObject(loader->errorevent, INFINITE);
				Sleep(10);
			}
			loader->errorevent = ti->Event;
			Sleep(10);
		}
	}
	Logger::Log(true, ConsoleColor::RED, "ZwFlushBuffersFile\n");
	auto emu = Emu(uc);
	uint64_t status = 0;
	uint64_t file_handle_raw = emu->rcx();
	uint64_t io_status_block_raw = emu->rdx();
	HANDLE file_handle = reinterpret_cast<HANDLE>(file_handle_raw);
	PIO_STATUS_BLOCK io_status_block = reinterpret_cast<PIO_STATUS_BLOCK>(io_status_block_raw);

	Logger::Log(true, ConsoleColor::DARK_GREEN, "Flush file buffers, file handle: %llx\n", file_handle);
	if (!FlushFileBuffers(file_handle)) {

		status = GetLastError();
		std::cerr << "FlushFileBuffers failed, error code: " << status << std::endl;
	}
	else {
		Logger::Log(true, ConsoleColor::DARK_GREEN, "Data successfully written to disk!\n");
	}
	emu->write(io_status_block_raw, &io_status_block, sizeof(IO_STATUS_BLOCK));

	emu->rax(status);
	RetHook(uc);
	for (auto& ti : loader->Threads) {
		SetEvent(ti->Event);
		loader->errorevent = nullptr;
	}
}
void Emulate::KeGetCurrentIrql(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "KeGetCurrentIrql\n");
	auto emu = Emu(uc);
	uint64_t irql = emu->cr8();


	emu->rax(irql);
	RetHook(uc);
}
void Emulate::ZwQueryInformationFile(uc_engine* uc) {
	Logger::Log(true, ConsoleColor::RED, "ZwQueryInformationFile\n");
	auto emu = Emu(uc);
	uint64_t FileHandle = emu->rcx();
	uint64_t IoStatusBlock = emu->rdx();
	uint64_t FileInformation = emu->r8();
	uint64_t Length = emu->r9();

	uint64_t rsp = emu->rsp();
	uint64_t FileInformationClass = 0;
	emu->try_read(rsp + 0x20, &FileInformationClass, sizeof(uint64_t));
	IO_STATUS_BLOCK _IoStatusBlock = { 0 };

	Logger::Log(true, ConsoleColor::RED, " Handle: %llx, InfoClass: %d\n", FileHandle, FileInformationClass);
	uint32_t status = 0xc0000003;
	PEloader* loader = &PEloader::GetInstance();
	auto it = loader->handle_table.find(FileHandle);

	if (FileInformationClass == 5) {		FILE_STANDARD_INFORMATION _FileInformation = { sizeof(FILE_STANDARD_INFORMATION),0 };
		auto ret = __NtRoutine("NtQueryInformationFile", FileHandle, &_IoStatusBlock, &_FileInformation, sizeof(_FileInformation), FileInformationClass);
		if (Length >= sizeof(FILE_STANDARD_INFORMATION)) {
			emu->write(FileInformation, &_FileInformation, sizeof(_FileInformation));
		}
		status = ret;
	}
	else if (FileInformationClass == 0) {
		FILE_DIRECTORY_INFORMATION _FILE_DIRECTORY_INFORMATION = { sizeof(FILE_DIRECTORY_INFORMATION),0 };
		auto ret = __NtRoutine("NtQueryInformationFile", FileHandle, &_IoStatusBlock, &_FILE_DIRECTORY_INFORMATION, sizeof(_FILE_DIRECTORY_INFORMATION), FileInformationClass);
		if (Length >= sizeof(FILE_DIRECTORY_INFORMATION)) {
			emu->write(FileInformation, &_FILE_DIRECTORY_INFORMATION, sizeof(FILE_DIRECTORY_INFORMATION));
		}
		status = ret;
	}
	status = 0;
	emu->rax(status);
}

void Emulate::ZwQueryInformationFile(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "ZwQueryInformationFile\n");
	auto emu = Emu(uc);
	uint64_t FileHandle = emu->rcx();
	uint64_t IoStatusBlock = emu->rdx();
	uint64_t FileInformation = emu->r8();
	uint64_t Length = emu->r9();

	uint64_t rsp = emu->rsp();
	uint64_t FileInformationClass = 0;
	emu->try_read(rsp + 0x28, &FileInformationClass, sizeof(uint64_t));
	uint64_t _FileInformationClass = 0;
	emu->try_read(FileInformationClass, &_FileInformationClass, sizeof(_FileInformationClass));
	IO_STATUS_BLOCK _IoStatusBlock = { 0 };
	FILE_STANDARD_INFORMATION _FileInformation = { sizeof(FILE_STANDARD_INFORMATION),0 };
	auto ret = __NtRoutine("NtQueryInformationFile", FileHandle, &_IoStatusBlock, &_FileInformation, sizeof(_FileInformation), FileInformationClass);

	Logger::Log(true, ConsoleColor::RED, " Handle: %llx, InfoClass: %d\n", FileHandle, FileInformationClass);
	uint32_t status = ret;
	PEloader* loader = &PEloader::GetInstance();
	auto it = loader->handle_table.find(FileHandle);

	if (FileInformationClass == 5) {		/*FILE_STANDARD_INFORMATION info{};
		info.AllocationSize = file.size;
		info.EndOfFile = file.size;
		info.NumberOfLinks = 1;
		info.DeletePending = 0;
		info.Directory = 0;*/

		if (Length >= sizeof(FILE_STANDARD_INFORMATION)) {
			emu->write(FileInformation, &_FileInformation, sizeof(_FileInformation));
		}
	}


	emu->rax(status);
	RetHook(uc);
}

void Emulate::ZwReadFile(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	Logger::Log(true, ConsoleColor::RED, "ZwReadFile\n");
	auto emu = Emu(uc);
	HANDLE FileHandle = reinterpret_cast<HANDLE>(emu->rcx());
	uint64_t Event = emu->rdx();
	uint64_t ApcRoutine = emu->r8();
	uint64_t ApcContext = emu->r9();
	uint64_t r15 = emu->r15();

	uint64_t rsp = emu->rsp();

	rsp = rsp + 8;
	uint64_t IoStatusBlock = 0;
	uint64_t BufferAddr = 0;
	uint32_t Length = 0;
	uint64_t ByteOffsetAddr = 0;
	uint64_t Key = 0;
	emu->try_read(rsp + 0x20, &IoStatusBlock, sizeof(uint64_t));
	emu->try_read(rsp + 0x28, &BufferAddr, sizeof(uint64_t));
	emu->try_read(rsp + 0x30, &Length, sizeof(uint32_t));
	emu->try_read(rsp + 0x38, &ByteOffsetAddr, sizeof(uint64_t));
	emu->try_read(rsp + 0x40, &Key, sizeof(uint64_t));
    LARGE_INTEGER ByteOffset = {};
	emu->try_read(ByteOffsetAddr, &ByteOffset, sizeof(LARGE_INTEGER));
	if (Length < 1)
		Length = static_cast<uint32_t>(emu->r13());


	LARGE_INTEGER liBytes = { 0 };
	std::vector<uint8_t> readBuffer(Length);
	IO_STATUS_BLOCK iosb = { 0 };
	ULONG fileSize = GetFileSize((HANDLE)FileHandle, NULL);
	IO_STATUS_BLOCK ioStatus = { 0 };
	LARGE_INTEGER offset = {};
	char buffer[1024] = {};
	auto status = __NtRoutine("NtReadFile",
		FileHandle,
		nullptr,
		nullptr,
		nullptr,
		&iosb,
		readBuffer.data(),
		readBuffer.size(),
		&offset,
		nullptr
	);
	if (status < 0xc0000000) {
		emu->write(BufferAddr, readBuffer.data(), readBuffer.size());
		status = 0;
	}

	emu->write(IoStatusBlock, &iosb, sizeof(ioStatus));

	emu->rax(status);
	Logger::Log(true, 10, "ZwReadFile simulation completed, Status: %d    Handle  0x%llx\n", status, reinterpret_cast<uint64_t>(FileHandle));
	RetHook(uc);
}

void Emulate::NtQuerySystemInformation(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	auto emu = Emu(uc);
	uint64_t SystemInformationClass = emu->rcx();
	uint64_t SystemInformation = emu->rdx();
	uint64_t SystemInformationLength = emu->r8();
	uint64_t ReturnLength = emu->r9();
	Logger::Log(true, ConsoleColor::RED, "NtQuerySystemInformation\n");

	Logger::Log(true, ConsoleColor::YELLOW, "SystemInformationClass: %llx Output Buffer Addr: 0x%llx\n", SystemInformationClass, SystemInformation);












}

void Emulate::IoWMIOpenBlock(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	auto emu = Emu(uc);
	uint64_t rcx = emu->rcx();
    uint64_t rdx = emu->rdx();
    uint64_t r8 = emu->r8();
    (void)rdx;

	uint8_t read_guid[16] = {};
	emu->try_read(rcx, read_guid, sizeof(read_guid));
	uint8_t TARGET_GUID[16] = { 0x50, 0x08, 0x68, 0x8f, 0x84, 0xa5, 0xd1, 0x11,
						   0xbf, 0x38, 0x00, 0xa0, 0xc9, 0x06, 0x29, 0x10 };
	uint64_t status = STATUS_WMI_GUID_NOT_FOUND;
	if (memcmp(read_guid, TARGET_GUID, 16) == 0) {
		Logger::Log(true, ConsoleColor::RED, "IoWMIOpenBlock Success\n");
		status = STATUS_SUCCESS;

		uint32_t fake_wmi_obj = 0xDEADBEEF;
    	emu->write(r8, &fake_wmi_obj, sizeof(fake_wmi_obj));
	}
	else {
		Logger::Log(true, ConsoleColor::GREEN, "IoWMIOpenBlock Failed\n");
	}

	emu->rax(status);
	RetHook(uc);
}
void Emulate::IoWMIQueryAllData(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	auto emu = Emu(uc);
	uint64_t rcx = emu->rcx();
    uint64_t rdx = emu->rdx();
    uint64_t r8 = emu->r8();
    (void)rdx;

	uint32_t handle_value = 0;
	emu->try_read(rcx, &handle_value, sizeof(handle_value));

	Logger::Log(true, ConsoleColor::RED, "IoWMIQueryAllData, Handle: 0x%llx\n", handle_value);
	uint64_t status = STATUS_INVALID_HANDLE;
	if (rcx == 0xDEADBEEF) {
		Logger::Log(true, ConsoleColor::DARK_GREEN, "Valid WMI Handle, Return Fake WMI Data\n");

		uint8_t fake_wmi_data[0x100] = { 0 };
		*(uint32_t*)&fake_wmi_data[0] = 0x100;
    	*(uint32_t*)&fake_wmi_data[4] = 0xDEADBEEF;
		emu->write(r8, fake_wmi_data, sizeof(fake_wmi_data));

		status = STATUS_SUCCESS;
	}
	else {
		Logger::Log(true, ConsoleColor::DARK_GREEN, "Invalid WMI Handle, return STATUS_INVALID_HANDLE");
	}

	emu->rax(status);
	RetHook(uc);
}
void Emulate::PsDereferenceSiloContext(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	uint64_t status = STATUS_SUCCESS;
	Logger::Log(true, ConsoleColor::RED, "PsDereferenceSiloContext\n");
	auto emu = Emu(uc);
	emu->rax(status);
	RetHook(uc);
}
void Emulate::__C_specific_handler(uc_engine* uc, uint64_t address, uint32_t size, void* user_data)
{
	Logger::Log(true, ConsoleColor::RED, "C_specific_handler\n");
	auto emu = Emu(uc);
	uint64_t ExceptionRecord = emu->rcx();
	uint64_t EstablisherFrame = emu->rdx();
	uint64_t ContextRecord = emu->r8();
	uint64_t DispatcherContext = emu->r9();

	Logger::Log(true, ConsoleColor::DARK_GREEN, "  ExceptionRecord:    0x%llx \n", ExceptionRecord);
	Logger::Log(true, ConsoleColor::DARK_GREEN, "  EstablisherFrame:   0x%llx\n", EstablisherFrame);
	CONTEXT mContextRecord;
	DISPATCHER_CONTEXT mDispatcherContext;
	emu->try_read(ContextRecord, &mContextRecord, sizeof(mContextRecord));
	emu->try_read(DispatcherContext, &mDispatcherContext, sizeof(mDispatcherContext));
	uint32_t exceptionCode = 0;
	emu->try_read(ExceptionRecord, &exceptionCode, sizeof(exceptionCode));







	Logger::Log(true, ConsoleColor::DARK_GREEN, "  ExceptionCode:    0x%llx \n", exceptionCode);




	loader->ExecuteExceptionHandler = 1;
	loader->LastException = exceptionCode;
}
void Emulate::KeInitializeEvent(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	auto emu = Emu(uc);
	uint64_t event_ptr = emu->rcx();
	uint64_t type = emu->rdx();
	uint64_t state = emu->r8();
	Logger::Log(true, ConsoleColor::RED, "KeInitializeEvent\n");
	Logger::Log(true, 8, "Event Address: 0x%llx\n", event_ptr);
	Logger::Log(true, 8, "Type: %s\n", (type == 0 ? "NotificationEvent" : "SynchronizationEvent"));
	Logger::Log(true, 8, "Initial State: %s\n", (state ? "Signaled" : "Non-Signaled"));
	HANDLE event = CreateEvent(NULL, type == 0, state != 0, NULL);


	if (event_ptr == 0) return;

	struct {
		uint8_t Type;
		uint8_t Absolute;
		uint8_t Size;
		uint8_t Inserted;
		int32_t SignalState;
	} header = { 0 };

	header.Type = (uint8_t)type;
    header.Absolute = 0;
	header.Size = sizeof(header) / sizeof(ULONG_PTR);
	header.Inserted = 0;
	header.SignalState = (state ? 1 : 0);
	uint64_t ptr = HeapAlloc(uc, 0x1000);
	emu->write(event_ptr, &event, sizeof(event));

	RetHook(uc);
}
int iws = 0;
void Emulate::TrampolineThread(ThreadInfo_t* ti) {
	ti->threadId = GetCurrentThreadId();
	for (auto& tii : loader->Threads) {
		if (tii->threadId != ti->threadId) {
			ResetEvent(tii->Event);
		}
		else if (tii->threadId == ti->threadId) {
			loader->errorevent = tii->Event;
		}

	}
	uc_engine* uc = loader->uc;
	
	uc_open(UC_ARCH_X86, UC_MODE_64, &ti->tuc);
	uc_mem_region* regions;
	uint32_t count;
	uc_ctl_set_cpu_model(ti->tuc, UC_CPU_X86_QEMU64);
	uc_ctl(ti->tuc, UC_CTL_UC_PAGE_SIZE, 0x100000000);
	uc_ctl_tlb_mode(ti->tuc, UC_TLB_VIRTUAL);
	auto emu = Emu(uc);
	auto threadEmu = Emu(ti->tuc);
	uc_hook trace, traces, trace_mem, trace_nt, t;
	bool KdDebuggerNotPresent = 1;
	bool KdDebuggerEnabled = 0;
	for (auto& peFile : loader->peFiles)
	{

		if (peFile->FileName == "ntoskrnl.exe")
		{
			uint64_t size = loader->real_mem_map[peFile->Base].second;
			uc_err err = uc_mem_map_ptr(ti->tuc, peFile->Base, peFile->End - peFile->Base, UC_PROT_ALL, loader->real_mem_map[peFile->Base].first);
			uint64_t KdDebuggerNotPresentaddress = peFile->Base + peFile->FuncAddr["KdDebuggerNotPresent"];
			uint64_t KdDebuggerEnabledaddress = peFile->Base + peFile->FuncAddr["KdDebuggerEnabled"];
			loader->RtlRaiseStatusBase = peFile->Base + peFile->FuncAddr["RtlRaiseStatus"];
			threadEmu->write(KdDebuggerNotPresentaddress, &KdDebuggerNotPresent, sizeof(KdDebuggerNotPresent));
			threadEmu->write(KdDebuggerEnabledaddress, &KdDebuggerEnabled, sizeof(KdDebuggerEnabled));
		}

	}


	uc_err errU = uc_hook_add(ti->tuc, &trace_mem, UC_HOOK_MEM_INVALID, (void*)Unicorn::hook_mem_invalid, NULL, 1, 0);
	errU = uc_hook_add(ti->tuc, &trace_mem, UC_HOOK_INSN_INVALID, (void*)Unicorn::hook_mem_invalid, NULL, 1, 0);
	errU = uc_hook_add(ti->tuc, &intr_hook, UC_HOOK_INTR, (void*)Unicorn::catch_error, nullptr, 1, 0);
	Unicorn _uc{};
	for (const auto& pair : _uc.NtfuncMap) {
		_uc.hook_File_func(ti->tuc, "t", pair.first, pair.second);
	}
	for (const auto& pair : _uc.CngFuncMap) {
		_uc.hook_File_func(ti->tuc, "t", pair.first, pair.second);
	}
	for (const auto& pair : _uc.CiFuncMap) {
		_uc.hook_File_func(ti->tuc, "t", pair.first, pair.second);
	}
	for (auto object : loader->objectList) {
		uc_hook_add(ti->tuc, &t, UC_HOOK_MEM_READ | UC_HOOK_MEM_WRITE, (void*)Unicorn::hook_access_object, (void*)object, object->address, object->address + object->size);
	}

	uc_hook_add(ti->tuc, &t, UC_HOOK_CODE, Unicorn::register_hook, NULL, 1, 0);


	uc_context_restore(ti->tuc, ti->uc_ctx);

	threadEmu->rip(ti->routineStart);
	threadEmu->rcx(ti->routineContext);

	uint64_t rsp_MapBase = 0xffff890a9a3c1000;
	uint64_t rsp = 0xffff890a9a3c72b8;
	std::vector<uint8_t> buffer(0x7000);
	uc_mem_map(ti->tuc, rsp_MapBase, 0x7000, UC_PROT_ALL);
	emu->try_read(rsp_MapBase, buffer.data(), buffer.size());
	threadEmu->write(rsp_MapBase, buffer.data(), buffer.size());
	threadEmu->rsp(rsp);


	Logger::Log(true, ConsoleColor::RED, "TI routineStart: %llx\n", ti->routineStart);
	for (auto& ti : loader->Threads) {
		SetEvent(ti->Event);
		loader->errorevent = nullptr;
	}
	uc_err uc_check = uc_emu_start(ti->tuc, ti->routineStart, loader->peFiles[0]->End, 0, 0);
	if (uc_check != UC_ERR_OK)
	{
		ShowRegister(ti->tuc);
		Logger::Log(true, ConsoleColor::RED, "uc_emu_start error: %d\n", uc_check);
	}
	DWORD tid = GetCurrentThreadId();


	Logger::Log(true, ConsoleColor::YELLOW, "Thread is about to terminate \n");
	for (auto& ti : loader->Threads) {
		SetEvent(ti->Event);
	}
	uc_engine* uc_t = ti->tuc;
	/*loader->Threads.erase(std::remove_if(loader->Threads.begin(), loader->Threads.end(), [uc_t](ThreadInfo_t* ti) {
		return ti->tuc == ti->tuc;
		}), loader->Threads.end());*/
	uc_close(ti->tuc);
	ti->tuc = nullptr;


	return;
}



void Emulate::PsCreateSystemThread(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	auto emu = Emu(uc);
	uint64_t threadHandlePtr = emu->rcx();
	uint64_t desiredAccess = emu->rdx();
	uint64_t objectAttr = emu->r8();
	uint64_t processHandle = emu->r9();
	UNREFERENCED_PARAMETER(desiredAccess);
	UNREFERENCED_PARAMETER(objectAttr);
	UNREFERENCED_PARAMETER(processHandle);

	uint64_t rsp = emu->rsp();
	uint64_t clientId = 0;
	uint64_t startRoutine = 0;
	uint64_t startContext =0;
	emu->try_read(rsp + 0x28, &clientId, sizeof(clientId));
	emu->try_read(rsp + 0x30, &startRoutine, sizeof(startRoutine));
	emu->try_read(rsp + 0x38, &startContext, sizeof(startContext));
	uint64_t checkstartContext = 0;
	emu->try_read(startContext, &checkstartContext, sizeof(checkstartContext));

	Logger::Log(true, ConsoleColor::RED, "PsCreateSystemThread: threadHandlePtr: 0x%llx StartContext: 0x%llx startRoutine : 0x%llx\n", threadHandlePtr, startContext, startRoutine);

	ThreadInfo_t* ti = (ThreadInfo_t*)malloc(sizeof(ThreadInfo_t));
	ti->routineContext = startContext;
	ti->routineStart = startRoutine;
	ti->uc_ctx = nullptr;


	ti->Event = CreateEventW(nullptr, TRUE, FALSE, nullptr);
	ti->id = loader->Threads.size();

	uc_context_alloc(uc, &ti->uc_ctx);
	uc_context_save(uc, ti->uc_ctx);

	HANDLE thread = CreateThread(nullptr, 8192, (LPTHREAD_START_ROUTINE)TrampolineThread, ti, 0, nullptr);
	
	ti->handle = thread;

	loader->Threads.push_back(ti);
	loader->waitHandles.push_back(ti->Event);



	WaitForSingleObject(ti->Event, INFINITE);
	uint64_t status = 0;
	emu->rax(status);
	RetHook(uc);

}

void Emulate::KeSetEvent(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	auto emu = Emu(uc);
	uint64_t rcx = emu->rcx();
    uint64_t rdx = emu->rdx();
    uint64_t r8 = emu->r8();
    UNREFERENCED_PARAMETER(rdx);
	UNREFERENCED_PARAMETER(r8);
	Logger::Log(true, ConsoleColor::RED, "KeSetEvent\n");
	HANDLE handle = nullptr;
	emu->try_read(rcx, &handle, sizeof(handle));
	SetEvent(handle);

	RetHook(uc);
}
void Emulate::KeResetEvent(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	auto emu = Emu(uc);
	uint64_t rcx = emu->rcx();
	int32_t previous_state = 0;
	Logger::Log(true, ConsoleColor::RED, "KeResetEvent\n");
	emu->try_read(rcx + 0x08, &previous_state, sizeof(int32_t));
	Logger::Log(true, ConsoleColor::RED, "KeResetEvent: Original SignalState = %d \n", previous_state);

	int32_t new_state = 0;
	emu->write(rcx + 0x08, &new_state, sizeof(int32_t));
	Logger::Log(true, ConsoleColor::BLUE, "KeResetEvent: Set SignalState = 0\n");

	uint64_t result = static_cast<uint64_t>(previous_state);
	emu->rax(result);

	RetHook(uc);}

void Emulate::KeCapturePersistentThreadState(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	auto emu = Emu(uc);
	uint64_t context_ptr = emu->rcx();
	uint64_t kthread_ptr = emu->rdx();
	uint64_t kprocess_ptr = emu->r8();
	Logger::Log(true, ConsoleColor::RED, "KeCapturePersistentThreadState\n");
	return;
}
void Emulate::ZwOpenDirectoryObject(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	auto emu = Emu(uc);
	uint64_t rcx = emu->rcx();
    uint64_t rdx = emu->rdx();
    uint64_t r8 = emu->r8();
    
	Logger::Log(true, ConsoleColor::RED, "ZwOpenDirectoryObject\n");

	Logger::Log(true, ConsoleColor::RED, "DirectoryHandle: 0x%llx\n    DirectoryHandle address: %llx\n    DesiredAccess: %d    ObjectAttributes pointer: %llx\n", rcx, rdx, r8);
	OBJECT_ATTRIBUTES ObjectAttributes;
	emu->try_read(r8, &ObjectAttributes, sizeof(ObjectAttributes));
    
	std::wstring file_name_str = read_unicode_string(uc, ObjectAttributes.ObjectName);
	std::wcout << "Directory name: " << file_name_str << std::endl;

	uint64_t status = STATUS_OBJECT_NAME_NOT_FOUND;
	uint32_t fake_handle = 0xBADF00D;
    
	if (file_name_str == L"\\" || file_name_str == L"\\Device" || file_name_str == L"\\KnownDlls") {
		status = STATUS_SUCCESS;
		emu->write(rcx, &fake_handle, sizeof(fake_handle));
    	Logger::Log(true, ConsoleColor::RED, "Exist, Return Fake Handle: 0xBADF00D\n");
	}
	else {
		Logger::Log(true, ConsoleColor::DARK_GREEN, "Path does not exist, return STATUS_OBJECT_NAME_NOT_FOUND");
	}

	emu->rax(status);

	RetHook(uc);
}
void Emulate::ObReferenceObjectByHandle(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	auto emu = Emu(uc);
	uint64_t rcx = emu->rcx();
    uint64_t rdx = emu->rdx();
    uint64_t r8 = emu->r8();
    UNREFERENCED_PARAMETER(rdx);
	UNREFERENCED_PARAMETER(r8);
	Logger::Log(true, ConsoleColor::RED, "ObReferenceObjectByHandle\n");

	uint64_t status = STATUS_INVALID_HANDLE;

	Logger::Log(true, ConsoleColor::DARK_GREEN, "Not Vaild Handle: 0x%llx \n ", rcx);

	status = 0;
	emu->rax(status);
    RetHook(uc);
}
void Emulate::NtClose(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	auto emu = Emu(uc);
	uint64_t rcx = emu->rcx();
	Logger::Log(true, ConsoleColor::RED, "NtClose\n");
	uint64_t status = STATUS_SUCCESS;
	emu->rax(status);
	RetHook(uc);
}

void Emulate::ExAcquireFastMutex(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	auto emu = Emu(uc);
	uint64_t rcx = emu->rcx(); 
	Logger::Log(true, ConsoleColor::RED, "ExAcquireFastMutex\n");
	if (rcx == 0) {
		Logger::Log(true, ConsoleColor::DARK_GREEN, "NULL\n");
		RetHook(uc);
		return;
	}

	uint32_t count = 0;
	emu->try_read(rcx, &count, sizeof(count));

	if (count == 1) {
		count = 0;
		uint64_t ownerThread = 0xDEADBEEF;
		emu->write(rcx, &count, sizeof(count));
		emu->write(rcx + 8, &ownerThread, sizeof(ownerThread));
		Logger::Log(true, ConsoleColor::DARK_GREEN, "FastMutex\n");
	}
	else {
		Logger::Log(true, ConsoleColor::DARK_GREEN, " FastMutex Lock, waiting...\n");
	}
	RetHook(uc);
}


void Emulate::KeReleaseGuardedMutex(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	auto emu = Emu(uc);
	uint64_t rcx = emu->rcx();
	Logger::Log(true, ConsoleColor::RED, "KeReleaseGuardedMutex\n");
	if (rcx == 0) {
		std::cerr << "[-] KeReleaseGuardedMutex: GuardedMutex is NULL" << std::endl;
		RetHook(uc);
		return;
	}

	uint64_t ownerThread = 0;
	uint32_t count = 0;
	emu->try_read(rcx, &count, sizeof(count));
	emu->try_read(rcx + 8, &ownerThread, sizeof(ownerThread));
	uint64_t currentThread = 0xDEADBEEF;
    if (ownerThread != currentThread) {
		std::cerr << "[-] KeReleaseGuardedMutex: Attempting to release GuardedMutex of non-current thread, may cause BSOD!" << std::endl;
		RetHook(uc);
		return;
	}

	count = 1;
	ownerThread = 0;
	emu->write(rcx, &count, sizeof(count));
	emu->write(rcx + 8, &ownerThread, sizeof(ownerThread));
	Logger::Log(true, ConsoleColor::RED, "KeReleaseGuardedMutex: GuardedMutex Release\n");
	RetHook(uc);
}
void Emulate::KeWaitForSingleObject(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	auto emu = Emu(uc);
	uint64_t rcx = emu->rcx();
	uint64_t rdx = emu->rdx();
	uint64_t r8 = emu->r8();
	uint64_t r9 = emu->r9();
	Logger::Log(true, ConsoleColor::RED, "KeWaitForSingleObject\n");
	if (rcx == 0) {
		Logger::Log(true, ConsoleColor::DARK_GREEN, "Object is null\n");
		uint64_t status = STATUS_INVALID_PARAMETER;
		emu->rax(status);
		RetHook(uc);
		return;
	}

	int32_t signalState = 0;
	emu->try_read(rcx + 4, &signalState, sizeof(signalState));
	if (signalState == 1) {
		Logger::Log(true, ConsoleColor::DARK_GREEN, "Return Success\n");
		uint64_t status = STATUS_SUCCESS;
		emu->rax(status);
		RetHook(uc);
		return;
	}

	uint64_t rsp = emu->rsp();
	uint64_t timeout = 0;
	emu->try_read(rsp + 0x28, &timeout, sizeof(timeout));
	
	HANDLE handle = nullptr;
	emu->try_read(rcx, &handle, sizeof(handle));
	WaitForSingleObject((HANDLE)handle, INFINITE);

	uint64_t status = STATUS_SUCCESS;
	emu->rax(status);
	RetHook(uc);
}
void Emulate::KeQueryTimeIncrement(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	uint32_t time_increment = 156250;
	Logger::Log(true, ConsoleColor::RED, "KeQueryTimeIncrement\n");
	Logger::Log(true, ConsoleColor::RED, " Return: %d\n", time_increment);

	auto emu = Emu(uc);
	emu->rax(time_increment);
	RetHook(uc);
}

void Emulate::PsIsSystemThread(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	auto emu = Emu(uc);
	uint64_t rcx = emu->rcx();
	Logger::Log(true, ConsoleColor::RED, "PsIsSystemThread\n");

	uint8_t system_thread_flag = 0;
	emu->try_read(rcx + 0x74, &system_thread_flag, sizeof(system_thread_flag));

	Logger::Log(true, ConsoleColor::RED, "Read ETHEAD %llx SystemThread Flag: %d\n", rcx, system_thread_flag);
	uint64_t result = (system_thread_flag == 1) ? TRUE : FALSE;
	emu->rax(result);
	RetHook(uc);
}

void Emulate::PsTerminateSystemThread(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	auto emu = Emu(uc);
	uint64_t exit_status = emu->rcx();

	Logger::Log(true, ConsoleColor::RED, "PsTerminateSystemThread: ExitStatus: 0x%llx\n", exit_status);
	Sleep(2000);
	uc_emu_stop(uc);
	return;
	ThreadInfo_t* ti = loader->Threads.front();

	loader->Threads.erase(
		std::remove_if(loader->Threads.begin(), loader->Threads.end(),
			[](ThreadInfo_t* ti) {
				return ti->threadId == GetCurrentThreadId();
			}),
		loader->Threads.end());

	ExitThread(1);
}


void Emulate::RtlGetVersion(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	auto emu = Emu(uc);
	uint64_t rcx = emu->rcx();
	Logger::Log(true, ConsoleColor::RED, "RtlGetVersion\n");
	RTL_OSVERSIONINFOW version_info = { 0 };
	version_info.dwOSVersionInfoSize = sizeof(RTL_OSVERSIONINFOW);
	version_info.dwMajorVersion = 10;
	version_info.dwMinorVersion = 0;
	version_info.dwBuildNumber = 19041;
	version_info.dwPlatformId = 2;
	wcscpy_s(version_info.szCSDVersion, L"Service Pack 1");
	emu->write(rcx, &version_info, sizeof(version_info));
	uint64_t status = STATUS_SUCCESS;
	emu->rax(status); 

	Logger::Log(true, ConsoleColor::DARK_GREEN, "RtlGetVersion\n");
	RetHook(uc);
}
void Emulate::KeDelayExecutionThread(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	auto emu = Emu(uc);
	uint64_t rcx = emu->rcx();
	uint64_t rdx = emu->rdx();
	uint64_t r8 = emu->r8();
	UNREFERENCED_PARAMETER(rcx);
	UNREFERENCED_PARAMETER(rdx);
	int64_t interval = 0;
	emu->try_read(r8, &interval, sizeof(interval));

	int64_t delay_ms = -(interval / 10000);
	if (delay_ms < 0) delay_ms = 0;
    int thread = loader->Threads.size();

	Sleep(delay_ms);

	uint64_t status = STATUS_SUCCESS;
	emu->rax(status);
	RetHook(uc);
}

void Emulate::ZwQueryFullAttributesFile(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	auto emu = Emu(uc);
	uint64_t rcx = emu->rcx();
	uint64_t rdx = emu->rdx();
	Logger::Log(true, ConsoleColor::RED, "ZwQueryFullAttributesFile\n");

	OBJECT_ATTRIBUTES ObjectAttributes;
	emu->try_read(rcx, &ObjectAttributes, sizeof(ObjectAttributes));
	std::wstring file_name_str = read_unicode_string(uc, (uint64_t)ObjectAttributes.ObjectName);



	std::wcout << "[+] Search File: " << file_name_str << std::endl;

	NTSTATUS status = STATUS_OBJECT_NAME_NOT_FOUND;

	std::wstring target_filename = L"\\??\\C:\\fakefile.txt";

	if (file_name_str.compare(target_filename) == 0) {
		FILE_NETWORK_OPEN_INFORMATION file_info = { 0 };
		file_info.EndOfFile.QuadPart = 1024;
		file_info.CreationTime.QuadPart = 132456789000000000;
		file_info.LastAccessTime.QuadPart = 132456789000000000;
		file_info.LastWriteTime.QuadPart = 132456789000000000;
		file_info.ChangeTime.QuadPart = 132456789000000000;
		file_info.FileAttributes = FILE_ATTRIBUTE_NORMAL;

		emu->write(rdx, &file_info, sizeof(file_info));
		status = STATUS_SUCCESS;

		std::wcout << L"[+] FileSize: " << file_info.EndOfFile.QuadPart << " bytes" << std::endl;
	}

	emu->rax(status);
	RetHook(uc);
}

void Emulate::KeEnterCriticalRegion(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {

}
void Emulate::ExReleaseResourceLite(uc_engine* uc, uint64_t address, uint32_t size, void* user_data)
{
	auto emu = Emu(uc);
	emu->rax(0);
	RetHook(uc);
}
void Emulate::KeLeaveCriticalRegion(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
}
void Emulate::ExAcquireFastMutexUnsafe(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	auto emu = Emu(uc);
	uint64_t rcx = emu->rcx();
	Logger::Log(true, ConsoleColor::RED, "ExAcquireFastMutexUnsafe\n");
	Logger::Log(true, ConsoleColor::RED, "FAST_MUTEX addr: %llx\n", rcx);

	RetHook(uc);
}
void Emulate::ExReleaseFastMutexUnsafe(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	auto emu = Emu(uc);
	uint64_t rcx = emu->rcx();
	Logger::Log(true, ConsoleColor::RED, "ExReleaseFastMutexUnsafe\n");
	Logger::Log(true, ConsoleColor::RED, "FAST_MUTEX addr: %llx\n", rcx);
	RetHook(uc);
}

void Emulate::RtlUnicodeStringToAnsiString(uc_engine* uc, uint64_t address, uint32_t size, void* user_data)
{
}
void Emulate::IoDeleteSymbolicLink(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	auto emu = Emu(uc);
	uint64_t rcx = emu->rcx();
	Logger::Log(true, ConsoleColor::RED, "IoDeleteSymbolicLink\n");
	if (rcx == 0) {
		Logger::Log(true, ConsoleColor::DARK_GREEN, "Invalid UNICODE_STRING pointer\n");
		uint64_t status = STATUS_INVALID_PARAMETER;
		emu->rax(status);
		RetHook(uc);
		return;
	}

	UNICODE_STRING us;
	emu->try_read(rcx, &us, sizeof(UNICODE_STRING));

	if (us.Length == 0 || us.Buffer == 0) {
		Logger::Log(true, ConsoleColor::DARK_GREEN, "Invalid SymbolicLinkName\n");
		uint64_t status = STATUS_OBJECT_NAME_NOT_FOUND;
		emu->rax(status);
		RetHook(uc);
		return;
	}

	std::vector<wchar_t> buffer(us.Length / sizeof(wchar_t) + 1);
	emu->try_read(reinterpret_cast<uint64_t>(us.Buffer), buffer.data(), us.Length);
	buffer[us.Length / sizeof(wchar_t)] = L'\0';

	std::wstring symbolic_link_name(buffer.begin(), buffer.end());

	Logger::Log(true, ConsoleColor::DARK_GREEN, "Delete Symbolic link -> %s\n", symbolic_link_name.c_str());

	static std::unordered_set<std::wstring> symbolic_links = {
		L"\\DosDevices\\ExampleLink"
	};

	uint64_t status = STATUS_OBJECT_NAME_NOT_FOUND;
	if (symbolic_links.count(symbolic_link_name)) {
		symbolic_links.erase(symbolic_link_name);
		std::wcout << L"[+] Symbolic link " << symbolic_link_name << L" deleted" << std::endl;
		status = STATUS_SUCCESS;
	}
	else {
		Logger::Log(true, ConsoleColor::DARK_GREEN, "Symbolic link %s does not exist\n", symbolic_link_name.c_str());
	}

	emu->rax(status);
	RetHook(uc);
}

std::map<uint64_t, BCRYPT_HASH_HANDLE> g_HashHandleMap;

uint64_t g_HashHandleSeed = 0xBC0000000000;

void Emulate::BCryptOpenAlgorithmProvider(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	auto emu = Emu(uc);
	uint64_t phAlgorithm_ptr = emu->rcx();
	uint64_t pszAlgId_ptr = emu->rdx();
	uint64_t pszImpl_ptr = emu->r8();
	uint64_t dwFlags = emu->r9();
	Logger::Log(true, ConsoleColor::RED, "BCryptOpenAlgorithmProvider\n");
	std::wstring wstr;
	read_null_unicode_string(uc, pszAlgId_ptr, wstr);
	BCRYPT_ALG_HANDLE hAlg = nullptr;
	NTSTATUS status = ::BCryptOpenAlgorithmProvider(
		&hAlg,
		wstr.c_str(),
		nullptr,
		static_cast<ULONG>(dwFlags)
	);

	if (status == 0) {
		emu->write(phAlgorithm_ptr, &hAlg, sizeof(hAlg));
	}
	else {
		std::wcerr << "Fail, NTSTATUS = 0x" << std::hex << status << std::endl;
	}

	emu->rax(status);
	RetHook(uc);
}


void Emulate::BCryptCloseAlgorithmProvider(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	auto emu = Emu(uc);
	uint64_t hFakeAlg = emu->rcx();
	uint64_t dwFlags = emu->rdx();
	Logger::Log(true, ConsoleColor::RED, "BCryptCloseAlgorithmProvider\n");
	auto it = g_HashHandleMap.find(hFakeAlg);


	BCRYPT_ALG_HANDLE realAlg = (BCRYPT_ALG_HANDLE)hFakeAlg;

	NTSTATUS status = ::BCryptCloseAlgorithmProvider(realAlg, static_cast<ULONG>(dwFlags));
	if (status == 0) {
		Logger::Log(true, ConsoleColor::RED, "Close, FakeHandle = 0x%llx\n", hFakeAlg);
	}
	else {
		Logger::Log(true, ConsoleColor::GREEN, "Failed, NTSTATUS = 0x%llx\n", status);
	}

	emu->rax(status);
	RetHook(uc);
}


void Emulate::BCryptCreateHash(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	auto emu = Emu(uc);
	uint64_t hAlg = emu->rcx();
	uint64_t phHash = emu->rdx();
	uint64_t pbHashObject = emu->r8();
	uint64_t cbHashObject = emu->r9();
	UNREFERENCED_PARAMETER(pbHashObject);
	UNREFERENCED_PARAMETER(cbHashObject);
	uint64_t pbSecret = 0;
	uint64_t cbSecret = 0;
	uint64_t dwFlags = 0;
	Logger::Log(true, ConsoleColor::RED, "BCryptCreateHash\n");
	uint64_t rsp = emu->rsp();
	rsp = rsp + 8;
	emu->try_read(rsp + 0x20, &pbSecret, sizeof(uint64_t));
	emu->try_read(rsp + 0x28, &cbSecret, sizeof(uint64_t));
	emu->try_read(rsp + 0x30, &dwFlags, sizeof(uint64_t));

	BCRYPT_ALG_HANDLE realAlgHandle = reinterpret_cast<BCRYPT_ALG_HANDLE>(hAlg);

	BCRYPT_HASH_HANDLE realHashHandle = nullptr;
	NTSTATUS status = ::BCryptCreateHash(
		realAlgHandle,
		&realHashHandle,
		nullptr, 0,
		(PUCHAR)pbSecret,
		static_cast<ULONG>(cbSecret),
		0
	);

	if (status == 0) {
		uint64_t fakeHashHandle = g_HashHandleSeed++;
		g_HashHandleMap[(uint64_t)realHashHandle] = realHashHandle;

		emu->write(phHash, &realHashHandle, sizeof(realHashHandle));
		Logger::Log(true, ConsoleColor::RED, "fakeHashHandle = 0x%llx\n", realHashHandle);
	}
	else {
		std::cerr << "[-] Fail, NTSTATUS = 0x" << std::hex << status << std::endl;
	}

	emu->rax(status);
	RetHook(uc);
}

void Emulate::BCryptHashData(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	auto emu = Emu(uc);
	uint64_t hFakeHash = emu->rcx();
	uint64_t pbInput = emu->rdx();
	uint64_t cbInput = emu->r8();
	uint64_t dwFlags = emu->r9();
	Logger::Log(true, ConsoleColor::RED, "BCryptHashData\n");
	auto it = g_HashHandleMap.find(hFakeHash);
	if (it == g_HashHandleMap.end()) {
		std::cerr << "[-] non hash handle: 0x" << std::hex << hFakeHash << std::endl;
		uint64_t status = 0xC0000008;
		emu->rax(status);
		RetHook(uc);
		return;
	}

	BCRYPT_HASH_HANDLE realHash = it->second;

	std::vector<uint8_t> buffer(cbInput);
	emu->try_read(pbInput, buffer.data(), cbInput);

	NTSTATUS status = ::BCryptHashData(
		realHash,
		buffer.data(),
		static_cast<ULONG>(cbInput),
		static_cast<ULONG>(dwFlags)
	);

	if (status == 0) {
		Logger::Log(true, ConsoleColor::RED, "Write %d bytes\n", cbInput);
	}
	else {
		std::cerr << "[-] Failed, NTSTATUS = 0x" << std::hex << status << std::endl;
	}

	emu->rax(status);
	RetHook(uc);
}
void Emulate::BCryptGetProperty(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	auto emu = Emu(uc);
	uint64_t hAlgo = emu->rcx();
	uint64_t pszProp = emu->rdx();
	uint64_t pbOutput = emu->r8();
	uint64_t cbOutput = emu->r9();
	uint64_t pcbResult = 0;
	uint64_t dwFlags = 0;
	Logger::Log(true, ConsoleColor::RED, "BCryptGetProperty\n");
	uint64_t rsp = emu->rsp();
	rsp = rsp + 8;
	emu->try_read(rsp + 0x20, &pcbResult, sizeof(uint64_t));
    emu->try_read(rsp + 0x28, &dwFlags, sizeof(uint64_t));

	std::wstring suckmyname = read_unicode_string(uc, pszProp);
	std::wstring propName;
	read_null_unicode_string(uc, pszProp, propName);
	DWORD resultLength = 0;
	BYTE outputBuffer[64] = { 0 };

	NTSTATUS status = ::BCryptGetProperty(
		(BCRYPT_HASH_HANDLE)hAlgo,
		propName.c_str(),
		outputBuffer,
		static_cast<ULONG>(cbOutput),
		&resultLength,
		0
	);

	if (status == 0) {
		emu->write(pbOutput, outputBuffer, resultLength);
		emu->write(pcbResult, &resultLength, sizeof(DWORD));
		std::wcout << L"[+] (\"" << propName << L"\") = " << resultLength << L" bytes\n";
	}
	else {
		std::wcerr << L"[-]  Failed. Status: 0x" << std::hex << status << std::endl;
	}

	emu->rax(status);
	RetHook(uc);
}

void Emulate::BCryptFinishHash(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	auto emu = Emu(uc);
	uint64_t hFakeHash = emu->rcx();
    uint64_t pbOutput = emu->rdx();
    uint64_t cbOutput = emu->r8();
    uint64_t dwFlags = emu->r9();
    Logger::Log(true, ConsoleColor::RED, "BCryptFinishHash\n");
	auto it = g_HashHandleMap.find(hFakeHash);
	if (it == g_HashHandleMap.end()) {
		std::cerr << "[-] Unknown Hash Handle: 0x" << std::hex << hFakeHash << std::endl;
		uint64_t status = 0xC0000008;
		emu->rax(status);
		RetHook(uc);
		return;
	}

	BCRYPT_HASH_HANDLE realHash = it->second;
	std::vector<BYTE> output(cbOutput);

	NTSTATUS status = ::BCryptFinishHash(
		realHash,
		output.data(),
		static_cast<ULONG>(cbOutput),
		static_cast<ULONG>(dwFlags)
	);

	if (status == 0) {
		emu->write(pbOutput, output.data(), cbOutput);
		Logger::Log(true, ConsoleColor::RED, "Write 0x%llx (%d bytes)\n", pbOutput, cbOutput);
	}
	else {
		Logger::Log(true, ConsoleColor::GREEN, "Failed, NTSTATUS = 0x%llx\n", status);
	}

	emu->rax(status);
	RetHook(uc);
}
void Emulate::BCryptDestroyHash(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
	auto emu = Emu(uc);
	uint64_t hashHandle = emu->rcx();
	Logger::Log(true, ConsoleColor::RED, "BCryptDestroyHash\n");
	Logger::Log(true, ConsoleColor::DARK_GREEN, " Destroy Hash Handle = 0x%llx\n", hashHandle);
	uint8_t zero[0x100] = {};
    g_HashHandleMap.erase(hashHandle);

	uint64_t status = 0;
	emu->rax(status);

	RetHook(uc);
}
```

`KDemu/Emulate.hpp`:

```hpp
#ifndef EMULATE_UNICORN_HPP
#define EMULATE_UNICORN_HPP
#include "Global.h"
#include "LoadPE.hpp"
#include <string>
static std::map<std::string, uint64_t> registryHandles = {
	{"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat", 0x2a},
	{"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\CI",0x1a},
	{"\\Registry\\Machine\\System\\CurrentControlSet\\Control",0x0a}
};
#define WSTRING_TO_VECTOR(str) std::vector<uint8_t>(reinterpret_cast<const uint8_t*>(str), \
                                                   reinterpret_cast<const uint8_t*>(str) + (wcslen(str) + 1) * sizeof(wchar_t))

class Emulate {
private:
	static PEloader* loader;
public:
	struct Pool {
		uint64_t addr;
		uint64_t size;
		bool free;
	};
	Emulate(uc_engine* uc);
	static uint64_t this_NtBase;
	static std::map<std::string, std::map<std::string, std::vector<uint8_t>>> registry;
	static void HeapFree(uint64_t addr);

	static uint64_t HeapAlloc(uc_engine* uc, uint64_t size);
	static uint64_t HeapAlloc(uc_engine* uc, uint64_t size, bool show);
	static uint64_t Alloc(uc_engine* uc, uint64_t size, uint64_t myaddr, bool show);
	static uint64_t Alloc(uc_engine* uc, uint64_t size, uint64_t myaddr, my_uc_prot m);
	static uint64_t Alloc(uc_engine* uc, uint64_t size, uint64_t myaddr);
	static uint64_t StackAlloc(ULONG AllocBytes);
	static uint64_t AllocVirtPhysPage(uint64_t virtAddr);

	static void StackFree(ULONG AllocBytes);
	static void RtlInitUnicodeString(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void RtlAnsiStringToUnicodeString(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void RtlInitString(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void RtlCompareMemory(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void IsDigit(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void atol(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void ExAllocatePoolWithTag(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void ExFreePoolWithTag(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void ExFreeHeapPool(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void IoCreateDevice(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void IoRegisterShutdownNotification(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void IoCreateSymbolicLink(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void ZwFlushKey(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void ZwCreateSection(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void RtlMultiByteToUnicodeN(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void RtlWriteRegistryValue(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void RtlDeleteRegistryValue(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void ZwOpenKey(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void ZwQueryValueKey(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void ZwCreateKey(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void ZwSetValueKey(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void ZwDeleteValueKey(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void RtlRandomEx(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void KeAreAllApcsDisabled(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void KeInitializeGuardedMutex(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void ZwDeviceIoControlFile(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void ZwCreateFile(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void ZwQueryInformationFile(uc_engine* uc);
	static void ZwQueryInformationFile(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void ZwReadFile(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void NtQuerySystemInformation(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void IoWMIOpenBlock(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void IoWMIQueryAllData(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void PsDereferenceSiloContext(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void __C_specific_handler(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void KeInitializeEvent(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void KeResetEvent(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void PsCreateSystemThread(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void KeCapturePersistentThreadState(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void ZwOpenDirectoryObject(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void ObReferenceObjectByHandle(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void NtClose(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void ExAcquireFastMutex(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void KeReleaseGuardedMutex(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void KeWaitForSingleObject(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void KeQueryTimeIncrement(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void KeSetEvent(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void PsIsSystemThread(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void PsTerminateSystemThread(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void RtlGetVersion(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void KeDelayExecutionThread(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void ZwQueryFullAttributesFile(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void KeEnterCriticalRegion(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void KeLeaveCriticalRegion(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void ExAcquireFastMutexUnsafe(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void ExReleaseFastMutexUnsafe(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void ExReleaseResourceLite(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void RtlUnicodeStringToAnsiString(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void IoDeleteSymbolicLink(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void BCryptOpenAlgorithmProvider(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void BCryptCloseAlgorithmProvider(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void BCryptCreateHash(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void BCryptHashData(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void BCryptGetProperty(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void BCryptFinishHash(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void BCryptDestroyHash(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void ZwClose(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void PsGetCurrentProcess(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void ZwOpenSection(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void ZwQuerySystemInformation(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void KiSystemCall64(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void ExSystemTimeToLocalTime(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void RtlTimeFieldsToTime(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void RtlTimeToTimeFields(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void CcInitializeCacheMap(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void RtlDuplicateUnicodeString(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void _vswprintf_s(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void _swprintf_s(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void KeInsertQueueApc(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void KeInitializeApc(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void KeInitializeTimer(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void KeSetTimer(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void KeReadStateTimer(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void ExCreateCallback(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void DebugPrompt(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void DbgPrompt(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void RtlRaiseStatus(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void PsGetCurrentServerSilo(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void ExAcquireRundownProtection(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void _vsnwprintf(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void IoCreateFileEx(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void ZwWriteFile(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void ZwFlushBuffersFile(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void KeGetCurrentIrql(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void wcscat_s(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void _wcscpy_s(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void KeIpiGenericCall(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void KdChangeOption(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void MmIsAddressValid(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void RtlInitializeBitMap(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void RtlSetBits(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void PsLookupProcessByProcessId(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void PsGetProcessImageFileName(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void PsGetProcessSectionBaseAddress(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void PsGetSessionId(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void KeStackAttachProcess(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void KeUnstackDetachProcess(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void ExGetFirmwareEnvironmentVariable(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void MmGetPhysicalAddress(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void MmGetPhysicalMemoryRanges(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void ObfDereferenceObject(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void MmBuildMdlForNonPagedPool(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void IoAllocateMdl(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void MmAllocateContiguousMemorySpecifyCache(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void PsRemoveLoadImageNotifyRoutine(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void PsSetCreateProcessNotifyRoutineEx(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void ObRegisterCallbacks(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void CmRegisterCallbackEx(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void ObUnRegisterCallbacks(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void ZwWaitForSingleObject(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void InitializeSListHead(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void KeInitializeSpinLock(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void KeAcquireSpinLockRaiseToDpc(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void KeReleaseSpinLock(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void ExpInterlockedPopEntrySList(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void ExWaitForRundownProtectionRelease(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void KeCancelTimer(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void ExFreePool(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void RtlFreeUnicodeString(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void PsSetCreateThreadNotifyRoutine(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void PsSetLoadImageNotifyRoutine(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void ExRegisterCallback(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void ExUnregisterCallback(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void _CiCheckSignedFile(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void CiFreePolicyInfo(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void KeWaitForMultipleObjects(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void HalAcpiGetTableEx(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void IoQueryFileInformation(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void DbgPrint(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void RtlVirtualUnwind(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void SeSinglePrivilegeCheck(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void ExAcquireResourceExclusiveLite(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	static void TrampolineThread(ThreadInfo* info);
	static void RtlLookupFunctionEntry(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
};

static uc_hook intr_hook;
class Unicorn {
private:
	static PEloader* loader;
public:
	std::map<std::string, void(*)(uc_engine*, uint64_t, uint32_t, void*)> NtfuncMap = {
		{"PsGetCurrentServerSilo", Emulate::PsGetCurrentServerSilo },
		{"RtlLookupFunctionEntry", Emulate::RtlLookupFunctionEntry},
		{"ZwCreateSection",Emulate::ZwCreateSection},
		{"KeResetEvent",Emulate::KeResetEvent},
		{"atoi",Emulate::atol},
		{"isdigit",Emulate::IsDigit},
		{"IoCreateDevice", Emulate::IoCreateDevice},
		{"ExAllocatePoolWithTag", Emulate::ExAllocatePoolWithTag},
		{"KeInsertQueueApc",Emulate::KeInsertQueueApc},
		{"RtlInitUnicodeString", Emulate::RtlInitUnicodeString},
		{"KeInitializeGuardedMutex",Emulate::KeInitializeGuardedMutex },
		{"KeInitializeMutex", Emulate::KeInitializeGuardedMutex},
		{"RtlCompareMemory",Emulate::RtlCompareMemory},
		{"RtlWriteRegistryValue",Emulate::RtlWriteRegistryValue},
		{"RtlDeleteRegistryValue",Emulate::RtlDeleteRegistryValue},
		{"ZwOpenKey",Emulate::ZwOpenKey},
		{"ZwQueryValueKey",Emulate::ZwQueryValueKey},
		{"ZwCreateKey",Emulate::ZwCreateKey},
		{"ZwSetValueKey",Emulate::ZwSetValueKey},
		{"ZwDeleteValueKey",Emulate::ZwDeleteValueKey},
		{"RtlAnsiStringToUnicodeString",Emulate::RtlAnsiStringToUnicodeString},
		{"ZwFlushKey",Emulate::ZwFlushKey},
		{"ZwClose",Emulate::ZwClose},
		{"RtlRandomEx",Emulate::RtlRandomEx},
		{"ZwQuerySystemInformation",Emulate::ZwQuerySystemInformation},
		{"__C_specific_handler", Emulate::__C_specific_handler },
		{"KeAreAllApcsDisabled",Emulate::KeAreAllApcsDisabled },
		{"RtlMultiByteToUnicodeN",Emulate::RtlMultiByteToUnicodeN },
		{"ZwCreateFile",Emulate::ZwCreateFile},
		{"ZwQueryInformationFile",Emulate::ZwQueryInformationFile},
		{"ZwReadFile",Emulate::ZwReadFile},
		{"ExReleaseResourceLite", Emulate::ExReleaseResourceLite},
		{"RtlUnicodeStringToAnsiString", Emulate::RtlUnicodeStringToAnsiString},
		{"PsDereferenceSiloContext",Emulate::PsDereferenceSiloContext},
		{"KeInitializeEvent",Emulate::KeInitializeEvent},
		{"PsCreateSystemThread",Emulate::PsCreateSystemThread},
		{"KeCapturePersistentThreadState",Emulate::KeCapturePersistentThreadState},
		{"ZwOpenDirectoryObject",Emulate::ZwOpenDirectoryObject},
		{"ObReferenceObjectByHandle",Emulate::ObReferenceObjectByHandle},
		{"NtClose",Emulate::NtClose},
		{"ExAcquireFastMutex",Emulate::ExAcquireFastMutex},
		{"KeReleaseGuardedMutex",Emulate::KeReleaseGuardedMutex},
		{"KeWaitForSingleObject",Emulate::KeWaitForSingleObject},
		{"KeQueryTimeIncrement",Emulate::KeQueryTimeIncrement},
		{"KeSetEvent",Emulate::KeSetEvent},
		{"PsIsSystemThread",Emulate::PsIsSystemThread},
		{"RtlGetVersion",Emulate::RtlGetVersion},
		{"KeDelayExecutionThread",Emulate::KeDelayExecutionThread},
		{"ZwQueryFullAttributesFile",Emulate::ZwQueryFullAttributesFile},
		{"KeEnterCriticalRegion",Emulate::KeEnterCriticalRegion},
		{"KeLeaveCriticalRegion",Emulate::KeLeaveCriticalRegion},
		{"ExAcquireFastMutexUnsafe",Emulate::ExAcquireFastMutexUnsafe},
		{"ExReleaseFastMutexUnsafe",Emulate::ExReleaseFastMutexUnsafe},
		{"IoDeleteSymbolicLink",Emulate::IoDeleteSymbolicLink},
		{"RtlDuplicateUnicodeString", Emulate::RtlDuplicateUnicodeString},
		{"ExSystemTimeToLocalTime", Emulate::ExSystemTimeToLocalTime },
		{"RtlTimeFieldsToTime",Emulate::RtlTimeFieldsToTime},
		{"RtlTimeToTimeFields", Emulate::RtlTimeToTimeFields },
		{"vswprintf_s", Emulate::_vswprintf_s},
		{"swprintf_s", Emulate::_swprintf_s},
		{"IoCreateFileEx", Emulate::IoCreateFileEx},
		{"_vsnwprintf", Emulate::_vsnwprintf},
		{"wcscpy_s", Emulate::_wcscpy_s},
		{"wcscat_s", Emulate::wcscat_s},
		{"ZwWriteFile",Emulate::ZwWriteFile},
		{"ZwFlushBuffersFile",Emulate::ZwFlushBuffersFile},
		{"KeGetCurrentIrql",Emulate::KeGetCurrentIrql},
		{"KeIpiGenericCall", Emulate::KeIpiGenericCall },
		{"KeInitializeTimer",Emulate::KeInitializeTimer},
		{"KeSetTimer",Emulate::KeSetTimer},
		{"ExCreateCallback",Emulate::ExCreateCallback},
		{"DbgPrompt",Emulate::DbgPrompt},
		{"RtlRaiseStatus",Emulate::RtlRaiseStatus},
		{"RtlVirtualUnwind", Emulate::RtlVirtualUnwind },
		{"DebugPrompt",Emulate::DebugPrompt},
		{"KdChangeOption", Emulate::KdChangeOption },
		{"PsGetCurrentProcess", Emulate::PsGetCurrentProcess},
		{"ZwOpenSection", Emulate::ZwOpenSection},
		{"MmIsAddressValid", Emulate::MmIsAddressValid },
		{"RtlSetBits", Emulate::RtlSetBits },
		{"KeStackAttachProcess", Emulate::KeStackAttachProcess},
		{"KeUnstackDetachProcess", Emulate::KeUnstackDetachProcess},
		{"MmGetPhysicalAddress", Emulate::MmGetPhysicalAddress },
		{"ObfDereferenceObject", Emulate::ObfDereferenceObject },
		{"MmGetPhysicalMemoryRanges",Emulate::MmGetPhysicalMemoryRanges},
		{"MmAllocateContiguousMemorySpecifyCache", Emulate::MmAllocateContiguousMemorySpecifyCache},
		{"PsRemoveLoadImageNotifyRoutine", Emulate::PsRemoveLoadImageNotifyRoutine},
		{"PsRemoveCreateThreadNotifyRoutine", Emulate::PsRemoveLoadImageNotifyRoutine},
		{"PsSetCreateProcessNotifyRoutineEx", Emulate::PsSetCreateProcessNotifyRoutineEx},
		{"PsSetCreateProcessNotifyRoutine", Emulate::PsSetCreateProcessNotifyRoutineEx},
		{"InitializeSListHead",Emulate::InitializeSListHead},
		{"KeInitializeSpinLock",Emulate::KeInitializeSpinLock},
		{"KeAcquireSpinLockRaiseToDpc", Emulate::KeAcquireSpinLockRaiseToDpc},
		{"KeReleaseSpinLock", Emulate::KeReleaseSpinLock},
		{"ExpInterlockedPopEntrySList", Emulate::ExpInterlockedPopEntrySList},
		{"ExWaitForRundownProtectionRelease", Emulate::ExWaitForRundownProtectionRelease},
		{"KeCancelTimer", Emulate::KeCancelTimer},
		{"ExFreeHeapPool",Emulate::ExFreeHeapPool },
		{"ExFreePool", Emulate::ExFreePool},
		{"RtlFreeUnicodeString", Emulate::RtlFreeUnicodeString},
		{"IoAllocateMdl",Emulate::IoAllocateMdl},
		{"MmBuildMdlForNonPagedPool",Emulate::MmBuildMdlForNonPagedPool},
		{"PsSetCreateThreadNotifyRoutine", Emulate::PsSetCreateThreadNotifyRoutine},
		{"PsSetLoadImageNotifyRoutine", Emulate::PsSetLoadImageNotifyRoutine },
		{"ObRegisterCallbacks",Emulate::ObRegisterCallbacks},
		{"CmRegisterCallbackEx",Emulate::CmRegisterCallbackEx},
		{"ExRegisterCallback", Emulate::ExRegisterCallback},
		{"ExUnregisterCallback",Emulate::ExUnregisterCallback},
		{"RtlInitString",Emulate::RtlInitString},
		{"ObUnRegisterCallbacks",Emulate::ObUnRegisterCallbacks},
		{"ZwWaitForSingleObject",Emulate::ZwWaitForSingleObject },
		{"PsLookupProcessByProcessId",Emulate::PsLookupProcessByProcessId },
		{"ExGetFirmwareEnvironmentVariable",Emulate::ExGetFirmwareEnvironmentVariable },
		{"PsGetProcessImageFileName", Emulate::PsGetProcessImageFileName },
		{"PsGetProcessSectionBaseAddress",Emulate::PsGetProcessSectionBaseAddress },
		{"PsGetSessionId",Emulate::PsGetSessionId },
		{"PsGetProcessSessionId",Emulate::PsGetSessionId },
		{"KeWaitForMultipleObjects", Emulate::KeWaitForMultipleObjects },
		{"PsTerminateSystemThread",Emulate::PsTerminateSystemThread },
		{"IoRegisterShutdownNotification",Emulate::IoRegisterShutdownNotification },
		{"IoCreateSymbolicLink",Emulate::IoCreateSymbolicLink },
		{"ZwDeviceIoControlFile",Emulate::ZwDeviceIoControlFile },
		{"IoQueryFileInformation", Emulate::IoQueryFileInformation },
		{"DbgPrint", Emulate::DbgPrint },
		{"SeSinglePrivilegeCheck", Emulate::SeSinglePrivilegeCheck },
		{"ExAcquireResourceExclusiveLite", Emulate::ExAcquireResourceExclusiveLite },
		{"KeInitializeApc",Emulate::KeInitializeApc },
		{"KeReadStateTimer",Emulate::KeReadStateTimer }
	};

	std::map<std::string, void(*)(uc_engine*, uint64_t, uint32_t, void*)> CngFuncMap = {
		{"BCryptOpenAlgorithmProvider",Emulate::BCryptOpenAlgorithmProvider},
		{"BCryptCreateHash",Emulate::BCryptCreateHash},
		{"BCryptHashData",Emulate::BCryptHashData},
		{"BCryptGetProperty",Emulate::BCryptGetProperty },
		{"BCryptFinishHash",Emulate::BCryptFinishHash },
		{"BCryptCloseAlgorithmProvider",Emulate::BCryptCloseAlgorithmProvider},
		{"BCryptDestroyHash",Emulate::BCryptDestroyHash}
	};

	std::map<std::string, void(*)(uc_engine*, uint64_t, uint32_t, void*)> CiFuncMap = {
		{"CiCheckSignedFile", Emulate::_CiCheckSignedFile},
		{"CiFreePolicyInfo",Emulate::CiFreePolicyInfo}
	};

	std::map<std::string, uint64_t> ntFuncAddr;
	std::map<std::string, uint64_t> cngFuncAddr;
	std::map<std::string, uint64_t> fltMgrFuncAddr;


	Unicorn();
	static void seh_Handle(uc_engine* uc);
	static void catch_error(uc_engine* uc, int exception, void* user_data);
	static void register_hook(uc_engine* uc, uint64_t address, const byte size, void* user_data);
	static void hook_mem_access(uc_engine* uc, uc_mem_type type, uint64_t address, int size, int64_t value, void* user_data);
	static void hook_mem_write(uc_engine* uc, uc_mem_type type, uint64_t address, int size, int64_t value, void* user_data);
	static bool hook_mem_invalid(uc_engine* uc, uc_mem_type type, uint64_t address, int size, int64_t value, void* user_data);
	static void hook_access_object(uc_engine* uc, uc_mem_type type, uint64_t address, int size, int64_t value, void* user_data);
	static void hook_File_func(uc_engine* uc, std::string fileName, std::string funcName, void(*func)(uc_engine*, uint64_t, uint32_t, void*));


	static bool check_is_ntFunc(uint64_t _register);
	static bool check_is_ntFunc_noNext(uint64_t _register);

};


class crt_buffer_t
{
public:
	crt_buffer_t();
	crt_buffer_t(size_t size);
	~crt_buffer_t();
	void* GetSpace(size_t needSize);
	size_t GetLength() { return m_cbSize; }
	void* GetBuffer() { return m_pBuffer; }

	void* m_pBuffer;
	size_t m_cbSize;
};

class Except {
private:
	static PEloader* loader;
public:
	Except();
	static VOID RtlpGetStackLimits(_Inout_ uc_engine* uc, OUT PULONG64 LowLimit, OUT PULONG64 HighLimit);
	static VOID RtlpCaptureContext(_Inout_ uc_engine* uc, IN PCONTEXT ContextRecord);
	static VOID RtlpRestoreContext(_Inout_ uc_engine* uc, IN PCONTEXT ContextRecord, IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL);
	static BOOLEAN RtlpDispatchException(_Inout_ uc_engine* uc, IN PEXCEPTION_RECORD ExceptionRecord, IN PCONTEXT ContextRecord);
	static VOID RtlRaiseStatus(_Inout_ uc_engine* uc, IN NTSTATUS Status);
	static NTSTATUS RaiseException(_Inout_ uc_engine* uc, IN PEXCEPTION_RECORD ExceptionRecord, IN PCONTEXT ContextRecord, IN BOOLEAN FirstChance);

	static EXCEPTION_DISPOSITION RtlpExecuteHandlerForException(
		_Inout_ uc_engine* uc,
		_Inout_ struct _EXCEPTION_RECORD* ExceptionRecord,
		_In_ PVOID EstablisherFrame,
		_Inout_ struct _CONTEXT* ContextRecord,
		_In_ PDISPATCHER_CONTEXT DispatcherContext
	);
	static PRUNTIME_FUNCTION RtlpLookupFunctionTable(
		_Inout_ uc_engine* uc,
		IN PVOID ControlPc,
		OUT PVOID* ImageBase,
		OUT PULONG SizeOfTable
	);
	static PRUNTIME_FUNCTION RtlpLookupFunctionEntry(
		_Inout_ uc_engine* uc,
		IN ULONG64 ControlPc,
		OUT PULONG64 ImageBase,
		IN OUT PUNWIND_HISTORY_TABLE HistoryTable OPTIONAL
	);
	static PRUNTIME_FUNCTION RtlpConvertFunctionEntry(
		_Inout_ uc_engine* uc,
		IN PRUNTIME_FUNCTION FunctionEntry,
		IN ULONG64 ImageBase
	);
	static PEXCEPTION_ROUTINE RtlpVirtualUnwind(
		_Inout_ uc_engine* uc,
		IN ULONG HandlerType,
		IN ULONG64 ImageBase,
		IN ULONG64 ControlPc,
		IN PRUNTIME_FUNCTION FunctionEntry,
		IN OUT PCONTEXT ContextRecord,
		OUT PVOID* HandlerData,
		OUT PULONG64 EstablisherFrame,
		IN OUT PKNONVOLATILE_CONTEXT_POINTERS ContextPointers OPTIONAL
	);
	static PRUNTIME_FUNCTION RtlpSameFunction(
		_Inout_ uc_engine* uc,
		IN PRUNTIME_FUNCTION FunctionEntry,
		IN ULONG64 ImageBase,
		IN ULONG64 ControlPc
	);



	static PRUNTIME_FUNCTION RtlpUnwindPrologue(
		_Inout_ uc_engine* uc,
		IN ULONG64 ImageBase,
		IN ULONG64 ControlPc,
		IN ULONG64 FrameBase,
		IN PRUNTIME_FUNCTION FunctionEntry,
		IN OUT PCONTEXT ContextRecord,
		IN OUT PKNONVOLATILE_CONTEXT_POINTERS ContextPointers OPTIONAL
	);

	static VOID RtlpCopyContext(_Inout_ uc_engine* uc, OUT PCONTEXT Destination, IN PCONTEXT Source);
	static EXCEPTION_DISPOSITION C_specific_handler(_Inout_ uc_engine* uc);
	static VOID RtlpUnwindEx(
		_Inout_ uc_engine* uc,
		IN PVOID TargetFrame OPTIONAL,
		IN PVOID TargetIp OPTIONAL,
		IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
		IN PVOID ReturnValue,
		IN PCONTEXT OriginalContext,
		IN PUNWIND_HISTORY_TABLE HistoryTable OPTIONAL
	);
	static BOOLEAN RtlpIsFrameInBounds(
		_Inout_ uc_engine* uc,
		IN OUT PULONG64 LowLimit,
		IN ULONG64 StackFrame,
		IN OUT PULONG64 HighLimit
	);

	static PRUNTIME_FUNCTION RtlpSearchInvertedFunctionTable(
		_Inout_ uc_engine* uc,
		PINVERTED_FUNCTION_TABLE InvertedTable,
		PVOID ControlPc,
		OUT PVOID* ImageBase,
		OUT PULONG SizeOfTable
	);
	static bool KeQueryCurrentStackInformation(_Inout_ uc_engine* uc, OUT PULONG64 LowLimit, OUT PULONG64 HighLimit);
	static VOID KiExceptionDispatch(
		_Inout_ uc_engine* uc,
		uint32_t ExceptionCode,
		uint32_t NumberParameters,
		uintptr_t ExceptionAddress,
		uintptr_t* ExceptionInformation,
		uintptr_t TrapFrame
	);
	static VOID RtlInsertInvertedFunctionTable(
		_Inout_ uc_engine* uc,
		PINVERTED_FUNCTION_TABLE InvertedTable,
		ULONG64 MappedBase,
		PVOID ImageBase,
		ULONG SizeOfImage
	);
};



class Snapshot {
private:
	std::vector<uint8_t> raw_data;
	void save_register(uc_engine* uc) {
		int registers[] = {
			UC_X86_REG_RAX, UC_X86_REG_RBX, UC_X86_REG_RCX, UC_X86_REG_RDX,
			UC_X86_REG_RSI, UC_X86_REG_RDI, UC_X86_REG_RBP, UC_X86_REG_RSP,
			UC_X86_REG_RIP, UC_X86_REG_R8, UC_X86_REG_R9, UC_X86_REG_R10,
			UC_X86_REG_R11, UC_X86_REG_R12, UC_X86_REG_R13, UC_X86_REG_R14,
			UC_X86_REG_R15, UC_X86_REG_EFLAGS
		};
		for (int reg : registers) {
			uint64_t value;
			if (uc_reg_read(uc, reg, &value) == UC_ERR_OK) {
				raw_data.insert(raw_data.end(), reinterpret_cast<uint8_t*>(&value), reinterpret_cast<uint8_t*>(&value) + sizeof(value));
				Logger::Log(true, ConsoleColor::DARK_GREEN, "Register %d: %llx\n", reg, value);
			}
		}
		int sse_registers[] = {
			UC_X86_REG_XMM0, UC_X86_REG_XMM1, UC_X86_REG_XMM2, UC_X86_REG_XMM3,
			UC_X86_REG_XMM4, UC_X86_REG_XMM5, UC_X86_REG_XMM6, UC_X86_REG_XMM7,
			UC_X86_REG_XMM8, UC_X86_REG_XMM9, UC_X86_REG_XMM10, UC_X86_REG_XMM11,
			UC_X86_REG_XMM12, UC_X86_REG_XMM13, UC_X86_REG_XMM14, UC_X86_REG_XMM15
		};
		for (int reg : sse_registers) {
			uint8_t value[16];
			uc_reg_read(uc, reg, &value);
			raw_data.insert(raw_data.end(), reinterpret_cast<uint8_t*>(&value), reinterpret_cast<uint8_t*>(&value) + sizeof(value));
		}
	}
	size_t load_register(uc_engine* uc) {
		int registers[] = {
			UC_X86_REG_RAX, UC_X86_REG_RBX, UC_X86_REG_RCX, UC_X86_REG_RDX,
			UC_X86_REG_RSI, UC_X86_REG_RDI, UC_X86_REG_RBP, UC_X86_REG_RSP,
			UC_X86_REG_RIP, UC_X86_REG_R8, UC_X86_REG_R9, UC_X86_REG_R10,
			UC_X86_REG_R11, UC_X86_REG_R12, UC_X86_REG_R13, UC_X86_REG_R14,
			UC_X86_REG_R15, UC_X86_REG_EFLAGS
		};
		const size_t num_registers = sizeof(registers) / sizeof(registers[0]);
		const size_t bytes_per_register = sizeof(uint64_t);

		for (size_t i = 0; i < num_registers; ++i) {
			uint64_t value;
			std::memcpy(&value, &raw_data[i * bytes_per_register], bytes_per_register);
			uc_reg_write(uc, registers[i], &value);
			Logger::Log(true, ConsoleColor::DARK_GREEN, "Register %d: %llx\n", registers[i], value);
		}
		auto from = num_registers * bytes_per_register;
		int sse_registers[] = {
			UC_X86_REG_XMM0, UC_X86_REG_XMM1, UC_X86_REG_XMM2, UC_X86_REG_XMM3,
			UC_X86_REG_XMM4, UC_X86_REG_XMM5, UC_X86_REG_XMM6, UC_X86_REG_XMM7,
			UC_X86_REG_XMM8, UC_X86_REG_XMM9, UC_X86_REG_XMM10, UC_X86_REG_XMM11,
			UC_X86_REG_XMM12, UC_X86_REG_XMM13, UC_X86_REG_XMM14, UC_X86_REG_XMM15
		};
		const size_t num_sse_registers = sizeof(sse_registers) / sizeof(sse_registers[0]);
		uint8_t value[16];
		const size_t bytes_per_sse_register = sizeof(value);

		for (size_t i = 0; i < num_sse_registers; ++i) {

			std::memcpy(&value, &raw_data[from + i * bytes_per_sse_register], bytes_per_sse_register);
			uc_reg_write(uc, sse_registers[i], &value);
		}
		return from + num_sse_registers * bytes_per_sse_register;
	}
	size_t load_memory(uc_engine* uc, size_t from) {
		uint32_t count;
		std::memcpy(&count, &raw_data[from], sizeof(count));
		from += sizeof(count);
		for (int i = 0; i < count; i++) {
			uint64_t start, size;
			std::memcpy(&start, &raw_data[from], sizeof(start));
			from += sizeof(start);
			std::memcpy(&size, &raw_data[from], sizeof(size));
			Logger::Log(true, ConsoleColor::DARK_GREEN, "Load Memory: %llx %llx\n", start, size);
			from += sizeof(size);
			Emulate::Alloc(uc, size, start);
			uc_mem_write(uc, start, &raw_data[from], size);
			from += size;
		}
		return from;
	}
	void save_memory(uc_engine* uc) {
		uc_mem_region* regions;
		uint32_t count;
		if (uc_mem_regions(uc, &regions, &count) != UC_ERR_OK) {
			std::cerr << "Failed to get memory regions" << std::endl;
			return;
		}
		raw_data.insert(raw_data.end(), reinterpret_cast<uint8_t*>(&count), reinterpret_cast<uint8_t*>(&count) + sizeof(count));
		for (uint32_t i = 0; i < count; i++) {
			uint64_t start = regions[i].begin;
			uint64_t size = regions[i].end - regions[i].begin + 1;
			raw_data.insert(raw_data.end(), reinterpret_cast<uint8_t*>(&start), reinterpret_cast<uint8_t*>(&start) + sizeof(start));
			raw_data.insert(raw_data.end(), reinterpret_cast<uint8_t*>(&size), reinterpret_cast<uint8_t*>(&size) + sizeof(size));
			auto original_size = raw_data.size();
			raw_data.resize(original_size + size);
			uc_mem_read(uc, start, raw_data.data() + original_size, size);
		}
		uc_free(regions);
	}
public:
	uint64_t load_snapshot(uc_engine* uc, std::string filename) {
		FILE* file = nullptr;
		fopen_s(&file, filename.c_str(), "rb");
		fseek(file, 0, SEEK_END);
		auto file_size = ftell(file);
		fseek(file, 0, SEEK_SET);
		if (file_size < 0) {
			std::cout << "Empty File\n";
			fclose(file);
			return 0;
		}
		raw_data.resize(file_size);
		fread(raw_data.data(), sizeof(uint8_t), raw_data.size(), file);
		fclose(file);

		auto from = load_register(uc);
		from = load_memory(uc, from);
		uint64_t allocSize;
		std::memcpy(&allocSize, &raw_data[from], sizeof(allocSize));
		return allocSize;
	}
	void save_snapshot(uc_engine* uc, std::string filename, uint64_t allocSize) {
		save_register(uc);
		save_memory(uc);
		raw_data.insert(raw_data.end(), reinterpret_cast<uint8_t*>(&allocSize), reinterpret_cast<uint8_t*>(&allocSize) + sizeof(allocSize));
		FILE* file = nullptr;
		fopen_s(&file, filename.c_str(), "wb");
		fwrite(raw_data.data(), sizeof(uint8_t), raw_data.size(), file);
		fclose(file);
	}
};



#endif

```

`KDemu/KDemu.cpp`:

```cpp
#include "LoadPE.hpp"
#include "NtType.hpp"
#include "Emulate.hpp"
#include <iostream>
#include <fstream>
#include <vector>
#include <map>
#include <cstdint>
#include <windows.h>
#include <mutex>
#include "UnicornEmu.hpp"
void gdbServer(uc_engine* uc, uint64_t entry) {
	HMODULE hDll = LoadLibrary(TEXT("udbserver.dll"));
	if (!hDll) {
		std::cerr << "Failed to load DLL!" << std::endl;
		return;
	}
	udbserver Udbserver = (udbserver)GetProcAddress(hDll, "udbserver");
	if (!Udbserver) {
		std::cerr << "Failed to get function address!" << std::endl;
		FreeLibrary(hDll);
		return;
	}
	Udbserver(uc, 10098, entry);
}

void mainThread() {
	printf("Unicorn version: %x\n", uc_version(NULL, NULL));
	PEloader& peLoader = PEloader::GetInstance();
	UnicornEmu::open(&peLoader.uc);

	uc_engine* uc = peLoader.uc;
	Emu(uc)->set_cpu_model(UC_CPU_X86_QEMU64);
	Emu(uc)->set_tlb_mode(UC_TLB_VIRTUAL);
	Emu(uc)->ctl(UC_CTL_UC_PAGE_SIZE, 0x100000000);
	char buffer[MAX_PATH];
	uint64_t status_register = 0x400024;

	ThreadInfo_t* ti = reinterpret_cast<ThreadInfo_t*>(malloc(sizeof(ThreadInfo_t)));
	ti->routineContext = 0;
	ti->routineStart = peLoader.ExecuteFromRip;
	ti->uc_ctx = nullptr;
	ti->Event = nullptr;
	ti->handle = GetCurrentThread();
	ti->threadId = GetCurrentThreadId();
	ti->tuc = uc;
	uc_context_alloc(uc, &ti->uc_ctx);

	ti->Event = CreateEventW(nullptr, TRUE, FALSE, nullptr);
	peLoader.waitHandles.push_back(ti->Event);
	ti->id = peLoader.Threads.size();
	peLoader.Threads.push_back(ti);

	DWORD length = GetCurrentDirectoryA(MAX_PATH, buffer);
	std::string ntoskrnl2(buffer);
	std::string cng(buffer);
	std::string fltMgr(buffer);
	std::string vgk(buffer);
	std::string ntdll(buffer);
	std::string halDll(buffer);
	std::string cidll(buffer);

	if (length > 0 && length < MAX_PATH)
	{
		vgk += "\\vgk_new.sys";
		Logger::Log(true, ConsoleColor::DARK_GREEN, "Full path: %s \n", ntoskrnl2);
	}
	else {
		std::cerr << "Error getting current directory" << std::endl;
	}

	peLoader.FILE_handle = 0x1000;
	
	peLoader.GetAllDriverBaseAddresses();
	
	Emu(uc)->alloc(0x1000, 0xffffffff00000000);
	Emu(uc)->alloc(0x1000, 0x10000000, MUC_PROT_ALL);
	uc_context_alloc(uc, &peLoader.ucContext);


	Unicorn _uc{};
	bool check = peLoader.LoadPE(vgk);
	if (check == false)
	{
		return;
	}

	peLoader.Init();
	peLoader.InitProcessor();
	peLoader.map_kuser_shared_data();
	peLoader.MapAllDriversFromKdmp();








	uc_hook trace, traces, trace_mem, trace_nt, t;
	Emu(uc)->hook_add(&trace_mem, UC_HOOK_MEM_INVALID, (void*)Unicorn::hook_mem_invalid, NULL, 1, 0);
	Emu(uc)->hook_add(&trace_mem, UC_HOOK_INSN_INVALID, (void*)Unicorn::hook_mem_invalid, NULL, 1, 0);
	Emu(uc)->hook_add(&intr_hook, UC_HOOK_INTR, (void*)Unicorn::catch_error, nullptr, 1, 0);
	for (const auto& pair : _uc.NtfuncMap) {
		_uc.hook_File_func(uc, "t", pair.first, pair.second);
	}
	for (const auto& pair : _uc.CngFuncMap) {
		_uc.hook_File_func(uc, "t", pair.first, pair.second);
	}
	for (const auto& pair : _uc.CiFuncMap) {
		_uc.hook_File_func(uc, "t", pair.first, pair.second);
	}

	for (auto object : peLoader.objectList) {
		Emu(uc)->hook_add(&t, UC_HOOK_MEM_READ | UC_HOOK_MEM_WRITE, (void*)Unicorn::hook_access_object, (void*)object, object->address, object->address + object->size);
	}
	Emu(uc)->hook_add(&t, UC_HOOK_CODE, Unicorn::register_hook, NULL, 1, 0);
	bool KdDebuggerNotPresent = 1;
	bool KdDebuggerEnabled = 0;
	for (auto& peFile : peLoader.peFiles)
	{
		if (peFile->FileName == "ntoskrnl.exe")
		{
			uint64_t KdDebuggerNotPresentaddress = peFile->Base + peFile->FuncAddr["KdDebuggerNotPresent"];
			uint64_t KdDebuggerEnabledaddress = peFile->Base + peFile->FuncAddr["KdDebuggerEnabled"];
			peLoader.RtlRaiseStatusBase = peFile->Base + peFile->FuncAddr["RtlRaiseStatus"];
			Emu(uc)->write(KdDebuggerNotPresentaddress, &KdDebuggerNotPresent, sizeof(KdDebuggerNotPresent));
			Emu(uc)->write(KdDebuggerEnabledaddress, &KdDebuggerEnabled, sizeof(KdDebuggerEnabled));
		}

	}

	peLoader.ExecuteFromRip = peLoader.peFiles[0]->Entry;


	uc_err err;

	Logger::Log(true, ConsoleColor::DARK_GREEN, "entry: 0x%llx  0%llx \n", peLoader.peFiles[0]->Entry, peLoader.ExecuteFromRip);

	while (true) {
		Emu(uc)->start(peLoader.ExecuteFromRip, peLoader.peFiles[0]->End, 0, 0);
		uint64_t rip = Emu(uc)->rip();
		if (peLoader.peFiles[0]->Base > rip || peLoader.peFiles[0]->End < rip) {
			break;
		}
		if (peLoader.LastException != STATUS_SUCCESS) {

			auto except = peLoader.LastException;
			break;
			Unicorn::seh_Handle(uc);
		}
		else {
			break;
		}
		printf("ExecuteFromRip %llx\n", peLoader.ExecuteFromRip);
	}
	Logger::Log(true, ConsoleColor::DARK_GREEN, "Main thread exited\n");
	DWORD exitCode = 0;
	while (true) {
		for (auto i : peLoader.Threads) {
			if (i->tuc != nullptr && i->id != 0)
			{
				if (GetExitCodeThread(i->handle, &exitCode)) {
					if (exitCode == STILL_ACTIVE) {
					}
					else {
						std::cout << "Thread ended, exit code: " << exitCode << std::endl;
						break;
					}
				}
				else {
					break;
				}
			}
		}

		Sleep(1000);	}


}

int main(int argc, char** argv, char** envp) {
	PEloader& peLoader = PEloader::GetInstance();
	peLoader.LoadDmp();
	InitializeCriticalSection(&peLoader.cs);
	DWORD s = GetCurrentThreadId();
	HANDLE thread = CreateThread(nullptr, 8192, (LPTHREAD_START_ROUTINE)mainThread, 0, 0, nullptr);

	WaitForSingleObject(thread, INFINITE);

	DeleteCriticalSection(&peLoader.cs);
	return 0;
}
```

`KDemu/KDemu.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Emulate.cpp" />
    <ClCompile Include="Global.cpp" />
    <ClCompile Include="KDemu.cpp" />
    <ClCompile Include="LoadPE.cpp" />
    <ClCompile Include="unicorn.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="cpu.h" />
    <ClInclude Include="Emulate.hpp" />
    <ClInclude Include="Global.h" />
    <ClInclude Include="LoadPE.hpp" />
    <ClInclude Include="NtType.hpp" />
    <ClInclude Include="UnicornEmu.hpp" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{b065bf6a-4c86-420d-9b4d-8d2c6cfc0a6a}</ProjectGuid>
    <RootNamespace>KDemu</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>false</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <IncludePath>$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <IncludePath>$(IncludePath)</IncludePath>
    <LibraryPath>$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg">
    <VcpkgEnableManifest>true</VcpkgEnableManifest>
    <VcpkgApplocalDeps>true</VcpkgApplocalDeps>
    <VcpkgXUseBuiltInApplocalDeps>true</VcpkgXUseBuiltInApplocalDeps>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
    <VcpkgConfiguration>Debug</VcpkgConfiguration>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(ProjectDir)\include\LIEF;</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <LanguageStandard_C>Default</LanguageStandard_C>
      <ExceptionHandling>false</ExceptionHandling>
      <Optimization>Disabled</Optimization>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>$(ProjectDir)\lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>$(CoreLibraryDependencies);LIEF.lib</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <FunctionLevelLinking>
      </FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(ProjectDir)\include\LIEF;</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <Optimization>Disabled</Optimization>
      <FavorSizeOrSpeed>Neither</FavorSizeOrSpeed>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <WholeProgramOptimization>false</WholeProgramOptimization>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <ExceptionHandling>false</ExceptionHandling>
      <SupportJustMyCode>true</SupportJustMyCode>
      <DebugInformationFormat>None</DebugInformationFormat>
      <MultiProcessorCompilation>
      </MultiProcessorCompilation>
      <SuppressStartupBanner>false</SuppressStartupBanner>
      <ErrorReporting>None</ErrorReporting>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalDependencies>LIEF.lib;capstone.lib;unicorn-import.lib;$(CoreLibraryDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(ProjectDir)\lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`KDemu/KDemu.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="來源檔案">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="標頭檔">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="資源檔">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="LoadPE.cpp" />
    <ClCompile Include="Emulate.cpp" />
    <ClCompile Include="KDemu.cpp" />
    <ClCompile Include="Global.cpp" />
    <ClCompile Include="unicorn.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="NtType.hpp" />
    <ClInclude Include="Emulate.hpp" />
    <ClInclude Include="Global.h" />
    <ClInclude Include="LoadPE.hpp" />
    <ClInclude Include="cpu.h">
      <Filter>標頭檔</Filter>
    </ClInclude>
    <ClInclude Include="UnicornEmu.hpp">
      <Filter>標頭檔</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`KDemu/KDemu.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LocalDebuggerAmpDefaultAccelerator>{ADEFF70D-84BF-47A1-91C3-FF6B0FC71218}</LocalDebuggerAmpDefaultAccelerator>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
    <LocalDebuggerMergeEnvironment>false</LocalDebuggerMergeEnvironment>
  </PropertyGroup>
</Project>
```

`KDemu/LoadPE.cpp`:

```cpp
#include "LoadPE.hpp"
#include "NtType.hpp"
#include "Emulate.hpp"
#include "UnicornEmu.hpp"
#include <fstream>
#include <psapi.h>
#include "cpu.h"

#pragma comment(lib,"ntdll.lib")

#pragma warning(disable : 4996)
extern "C"
{
	NTSYSAPI
		PVOID
		NTAPI
		RtlImageDirectoryEntryToData(
			PVOID BaseAddress,
			BOOLEAN MappedAsImage,
			USHORT Directory,
			PULONG Size
		);
}

void PEloader::GetAllDriverBaseAddresses() {
	DWORD cbNeeded = 0;
	if (!EnumDeviceDrivers(NULL, 0, &cbNeeded)) {
		std::cerr << "EnumDeviceDrivers failed to get size: " << GetLastError() << std::endl;
		return;
	}

	std::vector<void*> driverAddresses(cbNeeded / sizeof(void*));
	if (!EnumDeviceDrivers(driverAddresses.data(), cbNeeded, &cbNeeded)) {
		std::cerr << "EnumDeviceDrivers failed: " << GetLastError() << std::endl;
		return;
	}
	for (void* baseAddr : driverAddresses) {
		if (baseAddr == nullptr) break;

		wchar_t driverName[MAX_PATH] = { 0 };
		if (GetDeviceDriverBaseName(baseAddr, driverName, MAX_PATH)) {
			int len = WideCharToMultiByte(CP_UTF8, 0, driverName, -1, nullptr, 0, nullptr, nullptr);
			if (len > 0) {
				std::string strName(len - 1, 0);
				int result = WideCharToMultiByte(CP_UTF8, 0, driverName, -1, &strName[0], len, nullptr, nullptr);
				if (result > 0) {
					this->AllDriverBaseAddr[strName] = (uint64_t)baseAddr;
					if (strName == "ntoskrnl.exe" || strName == "CI.dll" || strName == "cng.sys")
						LoadModule(strName, 0);
				}
				else {
					std::cerr << "WideCharToMultiByte failed: " << GetLastError() << std::endl;
				}
			}
		}
	}
}

void PEloader::MapAllDriversFromKdmp() {
    auto emu = Emu(uc);

    auto to_lower = [](std::string s) {
        for (auto &c : s) c = static_cast<char>(::tolower(static_cast<unsigned char>(c)));
        return s;
    };
    auto basename_no_ext = [&](const std::string &path) {
        size_t pos = path.find_last_of("/\\");
        std::string fname = (pos == std::string::npos) ? path : path.substr(pos + 1);
        size_t dot = fname.find_last_of('.');
        if (dot != std::string::npos) fname = fname.substr(0, dot);
        return to_lower(fname);
    };
    std::vector<std::string> processed_names;
    processed_names.reserve(peFiles.size());
    for (auto *pf : peFiles) {
        if (!pf) continue;
        processed_names.emplace_back(basename_no_ext(pf->FileName));
    }

    int ntIndex = -1;
    for (size_t i = 0; i < peFiles.size(); ++i) {
        if (peFiles[i] && peFiles[i]->FileName == "ntoskrnl.exe") {
            ntIndex = static_cast<int>(i);
            break;
        }
    }
    if (ntIndex < 0) {
		Logger::Log(true, ConsoleColor::RED, "[KDMP] Failed to find ntoskrnl.exe PE metadata; unable to locate PsLoadedModuleList.\n");
        return;
    }

    uint64_t psListRva = 0;
    {
        auto it = peFiles[ntIndex]->FuncAddr.find("PsLoadedModuleList");
        if (it != peFiles[ntIndex]->FuncAddr.end())
            psListRva = it->second;
    }
	if (psListRva == 0) {
		Logger::Log(true, ConsoleColor::RED, "[KDMP] PsLoadedModuleList symbol not found (RVA=0).\n");
        return;
    }

    uint64_t ntCandidates[3] = { 0, 0, 0 };
    int candCount = 0;
    if (peFiles[ntIndex]->Base) ntCandidates[candCount++] = peFiles[ntIndex]->Base;
    if (NtoskrnlBase) ntCandidates[candCount++] = NtoskrnlBase;
    auto itLive = AllDriverBaseAddr.find("ntoskrnl.exe");
    if (itLive != AllDriverBaseAddr.end()) ntCandidates[candCount++] = itLive->second;

    auto read_kdmp = [this](uint64_t addr, void* out, size_t sz) -> bool {
        uint8_t* dst = reinterpret_cast<uint8_t*>(out);
        size_t rem = sz;
        while (rem > 0) {
            uint64_t page_base = addr & ~0xfffull;
            const uint8_t* page = kdmp.GetVirtualPage(page_base);
            if (!page) return false;
            size_t off = static_cast<size_t>(addr & 0xfff);
            size_t avail = 0x1000ull - off;
            size_t n = (rem < avail) ? rem : avail;
            const uint8_t* src = page + off;
            for (size_t i = 0; i < n; ++i) dst[i] = src[i];
            dst += n;
            addr += n;
            rem -= n;
        }
        return true;
    };

    LIST_ENTRY listHead{};
    uint64_t psListHeadAddr = 0;
    bool headOk = false;
    for (int i = 0; i < candCount; ++i) {
        uint64_t base = ntCandidates[i];
        if (!base) continue;
        uint64_t addr = base + psListRva;
        if (read_kdmp(addr, &listHead, sizeof(listHead))) {
            psListHeadAddr = addr;
            headOk = true;
			Logger::Log(true, ConsoleColor::DARK_GREEN, "[KDMP] PsLoadedModuleList OK, nt base=0x%llx -> head=0x%llx.\n", base, addr);
            break;
        } else {
			Logger::Log(true, ConsoleColor::YELLOW, "[KDMP] Attempt with nt base=0x%llx failed (addr=0x%llx).\n", base, addr);
        }
    }
    if (!headOk) {
		Logger::Log(true, ConsoleColor::RED, "[KDMP] Reading PsLoadedModuleList failed; all candidate bases were invalid.\n");
        return;
    }

    uint64_t current = reinterpret_cast<uint64_t>(listHead.Flink);
    const uint64_t listHeadVA = psListHeadAddr;
    const int kMaxModules = 4096;
    int mod_count = 0;

    while (current && current != listHeadVA && mod_count < kMaxModules) {
        _LDR_DATA_TABLE_ENTRY ldr{};
        if (!read_kdmp(current, &ldr, sizeof(ldr))) {
			Logger::Log(true, ConsoleColor::YELLOW, "[KDMP] Failed to read LDR_DATA_TABLE_ENTRY (addr=0x%llx).\n", current);
            break;
        }

        const uint64_t imageBase = reinterpret_cast<uint64_t>(ldr.DllBase);
        const uint64_t imageSize = static_cast<uint64_t>(ldr.SizeOfImage);

        std::wstring wname;
        if (ldr.BaseDllName.Length && ldr.BaseDllName.Buffer) {
            uint16_t len = ldr.BaseDllName.Length;
            std::vector<wchar_t> buf((len / sizeof(wchar_t)) + 1, L'\0');
            read_kdmp(reinterpret_cast<uint64_t>(ldr.BaseDllName.Buffer), buf.data(), len);
            wname.assign(buf.data(), buf.data() + (len / sizeof(wchar_t)));
        } else {
            wname = L"(unknown)";
        }
        std::string name;
        UnicodeToANSI(wname, name);

        if (imageBase && imageSize) {
            const uint64_t alignedStart = imageBase & ~0xfffull;
            const uint64_t alignedEnd   = (imageBase + imageSize + 0xfff) & ~0xfffull;
            const uint64_t alignedSize  = alignedEnd - alignedStart;
            std::string baseNameNoExt = basename_no_ext(name);
            bool skip_by_name = false;
            for (const auto &pn : processed_names) {
                if (pn == baseNameNoExt || pn.find(baseNameNoExt) != std::string::npos || baseNameNoExt.find(pn) != std::string::npos) {
                    skip_by_name = true;
                    break;
                }
            }

            bool skip_by_range = false;
            uint64_t imgStart = imageBase;
            uint64_t imgEnd = imageBase + imageSize - 1;
            for (auto *pf : peFiles) {
                if (!pf) continue;
                uint64_t peStart = pf->Base;
                uint64_t peEnd = pf->End;
				if (imgStart <= peEnd && imgEnd >= peStart) {
                    skip_by_range = true;
                    break;
                }
            }

            if (skip_by_name || skip_by_range) {
                Logger::Log(true, ConsoleColor::YELLOW,
					"[KDMP] Skip previously processed module: %s Base=0x%llx Size=0x%llx (by %s)\n",
                    name.c_str(), imageBase, imageSize,
                    skip_by_name ? "name" : "range");
                current = reinterpret_cast<uint64_t>(ldr.InLoadOrderLinks.Flink);
                continue;
            }

            void* host_buf = _aligned_malloc(static_cast<size_t>(alignedSize), 0x1000);
            if (!host_buf) {
				Logger::Log(true, ConsoleColor::RED, "[KDMP] Buffer allocation failed: %s Base=0x%llx Size=0x%llx\n", name.c_str(), imageBase, imageSize);
            } else {
                uint8_t* p = reinterpret_cast<uint8_t*>(host_buf);
                for (uint64_t i = 0; i < alignedSize; ++i) p[i] = 0;

                uint64_t filled = 0;
                for (uint64_t addr = alignedStart; addr < alignedEnd; addr += 0x1000) {
                    const uint8_t* page = kdmp.GetVirtualPage(addr);
                    if (!page) continue;
                    uint64_t off = addr - alignedStart;
                    for (size_t i = 0; i < 0x1000; ++i) p[off + i] = page[i];
                    filled += 0x1000;
                }

                bool already_mapped = false;
                uint8_t probe = 0;
                if (emu->try_read(alignedStart, &probe, sizeof(probe))) {
                    already_mapped = true;
                }

                if (!already_mapped) {
                    uc_err err = emu->mem_map_ptr(alignedStart, static_cast<size_t>(alignedSize), UC_PROT_ALL, host_buf);
                    if (err != UC_ERR_OK) {
						Logger::Log(true, ConsoleColor::RED, "[KDMP] uc_mem_map_ptr failed: %s err=%d Base=0x%llx Size=0x%llx\n",
                            name.c_str(), err, alignedStart, alignedSize);
                        _aligned_free(host_buf);
                    } else {
                        real_mem_map[alignedStart] = { host_buf, alignedSize };
                        real_mem_map_type_all[alignedStart] = { host_buf, MUC_PROT_ALL };

                        Logger::Log(true, ConsoleColor::DARK_GREEN,
							"[KDMP] Mapped driver: %s Base=0x%llx Size=0x%llx (filled: %llu KB, buffered mapping)\n",
							name.c_str(), imageBase, imageSize, filled / 1024);
                        ++mod_count;
                    }
                } else {
                    _aligned_free(host_buf);
                    Logger::Log(true, ConsoleColor::YELLOW,
						"[KDMP] Skip already mapped module: %s Base=0x%llx Size=0x%llx (no overwrite)\n",
                        name.c_str(), imageBase, imageSize);
                }
            }
        }

        current = reinterpret_cast<uint64_t>(ldr.InLoadOrderLinks.Flink);
    }

    if (mod_count >= kMaxModules) {
		Logger::Log(true, ConsoleColor::YELLOW, "[KDMP] Module count reached limit %d; stopping early.\n", kMaxModules);
    }
	Logger::Log(true, ConsoleColor::GREEN, "[KDMP] Completed driver mapping (buffered batch), total %d.\n", mod_count);
}

void PEloader::map_kuser_shared_data() {
	Emu(uc)->alloc(KUSER_SHARED_DATA_SIZE, KUSER_SHARED_DATA_ADDRESS);
	Emu(uc)->write(KUSER_SHARED_DATA_ADDRESS, (VOID*)kdmp.GetVirtualPage(KUSER_SHARED_DATA_ADDRESS), KUSER_SHARED_DATA_SIZE);
	bool data = 0;
	Emu(uc)->write(KUSER_SHARED_DATA_ADDRESS + 0x2d4, &data, sizeof(data));
	Logger::Log(true, ConsoleColor::DARK_GREEN, "KUSER_SHARED_DATA mapped and initialized at 0x%llx \n", KUSER_SHARED_DATA_ADDRESS);
}
void PEloader::InitProcessor() {
	auto emu = Emu(uc);
	SegmentSelector cs = { 0 };
	cs.fields.index = 1;
	emu->cs(cs.all);

	SegmentSelector ds = { 0 };
	ds.fields.index = 2;
	emu->ds(ds.all);

	SegmentSelector ss = { 0 };
	ss.fields.index = 2;
	emu->ss(ss.all);

	SegmentSelector es = { 0 };
	es.fields.index = 2;
	emu->es(es.all);
	uint64_t idtr = 0xfffff8050af9b000;
	Object* idtrObj = new Object("idtr", idtr, 0x1000);
	this->objectList.emplace_back(idtrObj);
	emu->idtr(idtr, 0x0FFF);
	emu->alloc(0x1000, idtr);
	emu->write(idtr, kdmp.GetVirtualPage(idtr), 0x1000);
	/* Init GS Segment */
	uint64_t gsBase = GsBase;
	gsBase = emu->alloc(0x1000, gsBase);
	emu->gs_base(gsBase);
	uint64_t CsBase = 0xfffff80508227900;

	emu->cs(CsBase);
	Object* gsObj = new Object("GS Segment", gsBase, 0x1000);
	emu->write(gsBase, kdmp.GetVirtualPage(gsBase), 0x1000);

	uint64_t kpcrBase;
	uint64_t KPCRCBBase;
	uint64_t kThreadBase;

	kpcrBase = emu->read<uint64_t>(gsBase + 0x18);
	kThreadBase = emu->read<uint64_t>(gsBase + 0x188);
	emu->alloc(0x1000, kThreadBase & ~0xfff, MUC_PROT_ALL);
	emu->write(kThreadBase & ~0xfff, kdmp.GetVirtualPage(kThreadBase & ~0xfff), 0x1000);



	Object* kThreadObj = new Object("KThread", kThreadBase, 0x1000);
	uint64_t currentApcState;
	currentApcState = emu->read<uint64_t>(kThreadBase + 0x98);


	uint64_t KPCRCB;

	FlagRegister eflags = { 0 };
	eflags.fields.id = 1;
	eflags.fields.intf = 1;
	eflags.fields.reserved1 = 1;

	emu->eflags(eflags.all);



	uint64_t cr0 = 0x80050033;
	uint64_t cr2 = 0x29c81264717;
	uint64_t cr3 = 0x1ad000;
	uint64_t cr4 = 0x3506f8;
	uint64_t cr8 = 0xf;



	emu->cr0(cr0);
	emu->cr2(cr2);
	emu->cr3(cr3);
	emu->alloc(0x10000, cr3);
	Object* cr3Obj = new Object("CR3", cr3, 0x1000);
	this->objectList.emplace_back(cr3Obj);
	emu->cr4(cr4);
	emu->cr8(cr8);
	emu->alloc(0x1ad000, 0xfffff0f87c3e0000);
	uint64_t tr = 0x40;
	emu->tr(tr);

	MSRList[0x1D9] = { 0, "DBGCTL_MSR" };
	MSRList[0x122] = { 0, "IA32_TSX_CTRL MSR" };
	MSRList[0x1DB] = { 0, "MSRLASTBRANCH-_FROM_IP_MSR" };
	MSRList[0x680] = { 0, "LastBranchFromIP_MSR" };
	MSRList[0x1c9] = { 0, "MSR_LASTBRANCH_TOS" };
	MSRList[0] = { 0xFFF, "MSR_0_P5_IP_ADDR" };
	MSRList[0xc0000082] = { 0x10000, "MSR_LSTAR" };
	MSRList[0x1B] = { 0xfee00800, "IA32_APIC_BASE" };
}
void PEloader::InsertTailList(
	IN ULONG64 ListHeadAddress,
	IN ULONG64 EntryAddress
)
{
	auto emu = Emu(uc);
	PLIST_ENTRY Blink;

	Blink = emu->read<PLIST_ENTRY>(ListHeadAddress + offsetof(LIST_ENTRY, Blink));


	emu->write(EntryAddress + offsetof(LIST_ENTRY, Flink), &ListHeadAddress, sizeof(ListHeadAddress));


	emu->write(EntryAddress + offsetof(LIST_ENTRY, Blink), &Blink, sizeof(Blink));


	emu->write((uint64_t)Blink + offsetof(LIST_ENTRY, Flink), &EntryAddress, sizeof(EntryAddress));


	emu->write(ListHeadAddress + offsetof(LIST_ENTRY, Blink), &EntryAddress, sizeof(EntryAddress));
}

void PEloader::Init() {
	/* Init Stack */
	uint64_t rsp_MapBase = 0xffff890a9a3c1000;
	auto emu = Emu(uc);
	emu->alloc(0x20000, rsp_MapBase);
	uint64_t Rsp = 0xffff890a9a3c72b8;

	auto driverEnd = peFiles[0]->End;
	auto driverEntry = peFiles[0]->Entry;

	emu->write(Rsp, &driverEnd, sizeof(Rsp));

	/* Init Register */
	printf("RSP: %llx\n", Rsp);
	emu->rsp(Rsp);
	uint64_t Rcx = 0xffff8f8b8b05f000;
	emu->alloc(0x1000, Rcx);
	uint64_t Rdx = 0xffff8f8b89e67000;
	emu->alloc(0x1000, Rdx);
	emu->write(Rdx, kdmp.GetVirtualPage(Rdx), 0x1000);
	const wchar_t* driverName = L"\\Driver\\vgk";



	auto drvObj = std::make_unique<_DRIVER_OBJECT>();
	drvObj->Type = 0x00000004;

	drvObj->Size = 0x150;
	drvObj->Flags = 2;
	drvObj->DriverStart = (void*)peFiles[0]->Entry;
	drvObj->DriverSize = peFiles[0]->Binary->virtual_size();

	drvObj->DriverName.Buffer = (WCHAR*)driverName;
	drvObj->DriverName.Length = lstrlenW(driverName) * sizeof(WCHAR);
	drvObj->DriverName.MaximumLength = 16;

	drvObj->DriverSection = (PVOID)peFiles[0]->LdrEntry;

	uint64_t majorFunctionTable[IRP_MJ_MAXIMUM_FUNCTION + 1] = { 0 };
	majorFunctionTable[IRP_MJ_CREATE] = driverEntry + 1;
	majorFunctionTable[IRP_MJ_READ] = driverEntry + 2;
	majorFunctionTable[IRP_MJ_WRITE] = driverEntry + 3;
	majorFunctionTable[IRP_MJ_DEVICE_CONTROL] = driverEntry + 4;
	majorFunctionTable[IRP_MJ_PNP] = driverEntry + 5;
	majorFunctionTable[IRP_MJ_INTERNAL_DEVICE_CONTROL] = driverEntry + 6;


	uint64_t majorFunctionAddr = Emu(uc)->HeapAlloc(sizeof(majorFunctionTable));
	Emu(uc)->write(majorFunctionAddr, &majorFunctionTable, sizeof(majorFunctionTable));

	drvObj->MajorFunction = (PVOID)majorFunctionAddr;

	const wchar_t* registry = L"\\Registry\\Machine\\SYSTEM\\ControlSet001\\Services\\vgk";
	uint64_t _registry = Emu(uc)->HeapAlloc(lstrlenW(registry) * sizeof(WCHAR));
	Emu(uc)->write(_registry, registry, lstrlenW(registry) * sizeof(WCHAR));

	const wchar_t* HardwareDatabase = L"\\REGISTRY\\MACHINE\\HARDWARE\\DESCRIPTION\\SYSTEM";
	_PRIMITIVE_UNICODE_STRING hwDatabase;
	hwDatabase.Buffer = (WCHAR*)HardwareDatabase;
	hwDatabase.Length = lstrlenW(HardwareDatabase) * sizeof(WCHAR);
	hwDatabase.MaximumLength = 0x5C;

	drvObj->HardwareDatabase = &hwDatabase;

	uint64_t drvObjAddr = 0xffff8f8b8b05fe30;

	emu->write(drvObjAddr, drvObj.get(), sizeof(_DRIVER_OBJECT));
	uint64_t regPathAddr = Rdx;
	USHORT registrySize = lstrlenW(registry) * sizeof(WCHAR);;
	emu->write(regPathAddr + offsetof(UNICODE_STRING, Length), &registrySize, sizeof(registrySize));
	emu->write(regPathAddr + offsetof(UNICODE_STRING, MaximumLength), &registrySize + 10, sizeof(registrySize));
	emu->write(regPathAddr + offsetof(UNICODE_STRING, Buffer), &_registry, sizeof(_registry));

	Logger::Log(true, ConsoleColor::DARK_GREEN, "DriverObject written to Unicorn memory at 0x%llx \n", drvObjAddr);
	emu->rcx(drvObjAddr);
	emu->rdx(regPathAddr);
}

void PEloader::LoadDmp()
{
	std::string path = "mem.dmp";
	kdmp.Parse(path.data());
}

void PEloader::FixImport(uint64_t baseAddr, LIEF::PE::Binary::it_imports imports) {
	int type = 1;
	for (auto & import : imports) {
		std::string dllName = import.name();
		std::transform(dllName.begin(), dllName.end(), dllName.begin(),
			[](unsigned char c) { return std::tolower(c); });

		bool check = false;
		for (int i = 0; i < peFiles.size(); i++)
		{
			if (peFiles[i]->FileName.find(dllName, 0) != std::string::npos)
			{
				type = i;
				check = true;
				break;
			}
		}
		if (check == false)
		{
			type = peFiles.size();
			LoadModule(dllName, type);
		}

		printf("Import DLL: %s\n", dllName.c_str());
		for (auto & entry : import.entries()) {
			std::string funcName = entry.name();
			uint64_t iatAddr = baseAddr + entry.iat_address();
			printf("Import function: %s\n", funcName.c_str());
			try {
				uint64_t funcRva = peFiles[type]->FuncAddr[funcName];
				uint64_t funcAddr = peFiles[type]->Base + peFiles[type]->FuncAddr[funcName];
				printf("Writing function address 0x%llx for %s at IAT 0x%llx\n", funcAddr, funcName.c_str(), iatAddr);
				Emu(uc)->write(iatAddr, &funcAddr, sizeof(funcAddr));
			}
			catch (...)
			{
			}

		}

	}
}

bool PEloader::LoadPE(const std::string path) {
	auto peBinary = LIEF::PE::Parser::parse(path);
	if (!peBinary) {
		std::cerr << "Failed to parse PE binary." << std::endl;
		return false;
	}
	PEfile* pe = new PEfile_t();
	uint64_t peBase = peBinary->imagebase();
	pe->Base = Emu_file_Base;
	pe->Entry = pe->Base + peBinary->optional_header().addressof_entrypoint();
	pe->End = pe->Base + peBinary->virtual_size() - 1;
	pe->memMap = malloc(peBinary->virtual_size());
	peFiles.insert(peFiles.begin(), pe);
	/* Security Cookie */
	LIEF::PE::LoadConfiguration* loadConfig = peBinary->load_configuration();
	uint64_t securityCookie = loadConfig->security_cookie();
	peBinary->patch_address(securityCookie, 0x2);

	auto peSections = peBinary->sections();;

	uint64_t peHeaderSize = peBinary->optional_header().sizeof_headers();
	std::ifstream file(path, std::ios::binary);

	uint64_t image_size = peBinary->virtual_size();

	if (!file.is_open()) {
		std::cerr << "Failed to open file: " << path << std::endl;
		return false;
	}
	file.read(reinterpret_cast<char*>(pe->memMap), peBinary->virtual_size());
	file.close();
	peFiles[0]->Binary = std::move(peBinary);
	peFiles[0]->FileName = path;
	auto imports = peFiles[0]->Binary->imports();
	int page = PAGE_ALIGN(peHeaderSize);
	Emu(uc)->alloc(image_size, pe->Base);
	Emu(uc)->write(pe->Base, pe->memMap, peHeaderSize);
	for (const auto& section : peSections) {
		uint64_t sectionAddress = pe->Base + section.virtual_address();
		uint64_t sectionSize = PAGE_ALIGN(section.virtual_size());
		auto sectionContent = section.content();
		Emu(uc)->write(sectionAddress, sectionContent.data(), sectionContent.size());
	}

	auto ExceptionTable = RtlImageDirectoryEntryToData((PVOID)peFiles[0]->memMap,
		TRUE,
		IMAGE_DIRECTORY_ENTRY_EXCEPTION,
		&peFiles[0]->ExceptionTableSize);
	peFiles[0]->ExceptionTable = peFiles[0]->Base + ((PUCHAR)ExceptionTable - (PUCHAR)peFiles[0]->memMap);

	uint64_t RtlpInvertedFunctionTableList = 0xfffff80508c18088;
	uint64_t imagebase = 0xfffff80508c18090;
	uint64_t imagesizebase = 0xfffff80508c18098;
	uint64_t ExceptionTableSizebase = 0xfffff80508c1809C;
	Emu(uc)->try_write(RtlpInvertedFunctionTableList, &peFiles[0]->ExceptionTable, sizeof(peFiles[0]->ExceptionTable));
	Emu(uc)->try_write(imagebase, &Emu_file_Base, sizeof(Emu_file_Base));
	Emu(uc)->try_write(imagesizebase, &image_size, sizeof(uint32_t));
	Emu(uc)->try_write(ExceptionTableSizebase, &peFiles[0]->ExceptionTableSize, sizeof(uint32_t));
	FixImport(pe->Base, imports);
	return true;
}

void PEloader::LoadModule(const std::string path, int type) {
	auto peBinary = LIEF::PE::Parser::parse(path);
	if (path == "ntoskrnl.exe") {
		int i = 0;
	}
	if (!peBinary) {
		char mpath[MAX_PATH];
		ExpandEnvironmentStringsA("%windir%\\System32\\", mpath, MAX_PATH);

		std::string system32Path(mpath);
		system32Path = system32Path + path;
		if (path == "ntoskrnl.exe") {
			system32Path = "E:\\KDemulator - Copy\\KDemu\\" + path;
		}
		peBinary = LIEF::PE::Parser::parse(system32Path);
		if (!peBinary)
		{

			std::cerr << "Failed to parse PE binary." << std::endl;
			return;
		}
	}

	auto peSections = peBinary->sections();;
	PEfile* pe = new PEfile_t();


	uint64_t peHeaderSize = peBinary->optional_header().sizeof_headers();

	std::ifstream file(path, std::ios::binary);

	if (!file.is_open()) {
		std::cerr << "Failed to open file: " << path << std::endl;
		return;
	}
	pe->memMap = malloc(peBinary->virtual_size());
	file.read(reinterpret_cast<char*>(pe->memMap), peBinary->virtual_size());
	file.close();
	int page = PAGE_ALIGN(peHeaderSize);
	
	for (auto i : peBinary->exported_functions()) {
		pe->FuncRVA[i.address()] = i.name();
		pe->FuncAddr[i.name()] = i.address();
	}
	if (path == "ntoskrnl.exe")
	{
		peBinary->optional_header().imagebase(0xfffff80507e17000);
		pe->Base = peBinary->imagebase();
	}

	if (path == "CI.dll")
	{
		peBinary->optional_header().imagebase(0xfffff80509550000);
		pe->Base = peBinary->imagebase();
	}

	if (path == "cng.sys")
	{
		peBinary->optional_header().imagebase(0xfffff80509640000);
		pe->Base = peBinary->imagebase();
	}

	if (path == "ntoskrnl.exe" || path == "CI.dll" || path == "cng.sys") {

		Emu(uc)->alloc(peBinary->virtual_size(), pe->Base);
		Emu(uc)->write(pe->Base, pe->memMap, peHeaderSize);
		pe->Entry = pe->Base + peBinary->optional_header().addressof_entrypoint();
		pe->End = pe->Base + peBinary->virtual_size();
		peFiles.push_back(pe);
		uint64_t vsize = peBinary->virtual_size();
		
		for (const auto& section : peSections) {
			uint64_t sectionAddress = pe->Base + section.virtual_address();
			uint64_t sectionSize = PAGE_ALIGN(section.virtual_size());
			auto sectionContent = section.content();
			Emu(uc)->write(sectionAddress, sectionContent.data(), sectionContent.size());
		}
		if (path == "ntoskrnl.exe") {
			this->PsLoadedModuleListBase = pe->Base + pe->FuncAddr["PsLoadedModuleList"];
			uint64_t PsLoadedModuleList = this->PsLoadedModuleListBase;
			Emu(uc)->write(this->PsLoadedModuleListBase, &PsLoadedModuleList, sizeof(PsLoadedModuleList));
		}
		int k = (pe->End - pe->Base) / 0x1000;
		for (int i = 0; i < k; i++) {
			auto page = kdmp.GetVirtualPage(pe->Base + i * 0x1000);
			if (page != NULL) {
				Emu(uc)->write(pe->Base + i * 0x1000, kdmp.GetVirtualPage(pe->Base + i * 0x1000), 0x1000);
			}
			else
				Logger::Log(true, ConsoleColor::RED, "Page error : %llx\n", pe->Base + i * 0x1000);
		}
	}
	else {
		return;
		if (pe->Base == 0)
			pe->Base = AllDriverBaseAddr[path];
		if (pe->Base != 0)
			Emu(uc)->alloc(page, pe->Base);
		else
			pe->Base = Emu(uc)->HeapAlloc(page);

		pe->Entry = pe->Base + peBinary->optional_header().addressof_entrypoint();
		pe->End = pe->Entry + peBinary->virtual_size();
		peFiles.push_back(pe);

		Emu(uc)->write(pe->Base, pe->memMap, peHeaderSize);

		for (const auto& section : peSections) {
			uint64_t sectionAddress = pe->Base + section.virtual_address();
			uint64_t sectionSize = PAGE_ALIGN(section.virtual_size());
			auto sectionContent = section.content();

			Emu(uc)->alloc(sectionSize, sectionAddress);

			Emu(uc)->write(sectionAddress, sectionContent.data(), sectionContent.size());
		}
	}
	std::wstring temp;
	ANSIToUnicode(path, temp);

	peFiles[peFiles.size() - 1]->Binary = std::move(peBinary);
	peFiles[peFiles.size() - 1]->FileName = path;
	file.close();
	return;
}
```

`KDemu/LoadPE.hpp`:

```hpp
#ifndef PELOADER_HPP
#define PELOADER_HPP
#include "Global.h"
#include "kdmp-parser/kdmp-parser.h"

typedef struct ThreadInfo {
	int id;
	uc_context* uc_ctx;
	uint64_t routineStart;
	uint64_t routineContext;
	uc_engine* tuc;
	HANDLE Event;
	HANDLE handle;
	DWORD threadId;
	uint64_t paddress;
} ThreadInfo_t;

typedef struct _INVERTED_FUNCTION_TABLE_ENTRY {
	PRUNTIME_FUNCTION FunctionTable;
	PVOID ImageBase;
	ULONG SizeOfImage;
	ULONG SizeOfTable;
} INVERTED_FUNCTION_TABLE_ENTRY, * PINVERTED_FUNCTION_TABLE_ENTRY;

typedef struct _INVERTED_FUNCTION_TABLE {
	ULONG CurrentSize;
	ULONG MaximumSize;
	BOOLEAN Overflow;
	INVERTED_FUNCTION_TABLE_ENTRY TableEntry[160];
} INVERTED_FUNCTION_TABLE, * PINVERTED_FUNCTION_TABLE;

typedef enum my_uc_prot {
	MUC_PROT_NONE = 0,
	MUC_PROT_READ = 1,
	MUC_PROT_WRITE = 2,
	MUC_PORT_READ_WRITE = 3,
	MUC_PROT_EXEC = 4,
	MUC_PROT_ALL = 7,
} my_uc_prot;


class PEloader {
private:
public:
	PEloader() = default;

	static PEloader& GetInstance() {
		static PEloader instance;
		return instance;
	}
	PEloader(const PEloader&) = delete;
	PEloader& operator=(const PEloader&) = delete;

	uint64_t sysinfo_addr = 0;
	uint32_t SystemInformationClass = 0;
	kdmpparser::KernelDumpParser kdmp;
	uc_engine* uc;
	uint64_t PsLoadedModuleListBase;
	uint64_t RtlRaiseStatusBase;
	INVERTED_FUNCTION_TABLE PsInvertedFunctionTable;
	std::map<std::string, uint64_t> AllDriverBaseAddr;
	void GetAllDriverBaseAddresses();
	void MapAllDriversFromKdmp();
	std::unordered_map<uint32_t, std::pair<uint64_t, std::string>> MSRList;

	std::vector<Object*> objectList;

	static const uint64_t Emu_file_Base = 0xfffff805dc9a0000;

	uint64_t NtoskrnlBase = 0xfffff8052e400000;

	uint64_t StackBase = 0xffff890a9a3c7000;

	uint64_t cibase = 0xfffff80532e00000;

	uint64_t halbase = 0xfffff8052d520000;

	uint64_t cngbase = 0xfffff80532ef0000;
	const uint64_t GsBase = 0xfffff80506d51000;
	static const uint64_t scratch = 0xffffffff00000000;

	const uint64_t StackSize = 0x1000;

	static const uint64_t AllocBase = 0xffffff000000000;

	uint64_t AllocatedContiguous = 0;
	uint64_t rsdtc_r8 = 0;
	uint64_t rsdtc_r9 = 0;
	bool go_addr = false;
	std::map<uint64_t, std::string> hook_addr_fn;

	std::vector<ThreadInfo_t*> Threads;

	std::vector<HANDLE> waitHandles;

	uint64_t lastExcept;

	uint64_t lastAlloc;
	volatile LONG g_flag = 0;
	volatile LONG g_running = 1;
	CRITICAL_SECTION cs;

	HANDLE errorevent;

	uc_context* ucContext = nullptr;

	std::map<uint64_t, std::pair<void*, uint64_t>>  real_mem_map;
	std::map<uint64_t, std::pair<void*, my_uc_prot>>  real_mem_map_type_read;
	std::map<uint64_t, std::pair<void*, my_uc_prot>>  real_mem_map_type_read_write;
	std::map<uint64_t, std::pair<void*, my_uc_prot>>  real_mem_map_type_all;



	std::map<uint64_t, uint64_t> hook;
	uint64_t ExecuteFromRip;
	int ExecuteExceptionHandler = 0;
	int LastException;


	struct VirtualFile {
		uint64_t handle;
		uint64_t size;
		uint64_t FileBase;
	};

	std::map<std::wstring, VirtualFile> virtual_files;

	std::map<uint64_t, std::wstring> handle_table;

	uint64_t FILE_handle;


	typedef struct PEfile {
		std::unique_ptr<LIEF::PE::Binary> Binary;
		void* memMap;
		uint64_t Base;
		uint64_t End;
		uint64_t Entry;
		ULONG64 ExceptionTable;
		ULONG ExceptionTableSize;
		uint64_t LdrEntry;
		std::map<uint64_t, std::string> FuncRVA;
		std::map<std::string, uint64_t> FuncAddr;
		std::string FileName;
	} PEfile_t;



	std::vector<PEfile_t*> peFiles;
	std::map<uint64_t, std::string> ntoskrnlRVA;

	struct _stack {
		uint64_t address;
		PVOID buffer;
		size_t size;
	} stack;
	void InsertTailList(
		IN ULONG64 ListHeadAddress,
		IN ULONG64 EntryAddress
	);


	void InitProcessor();

	void Init();

	void LoadDmp();

	void map_kuser_shared_data();

	void InitPsLoadedModule(uint64_t imageBase, uint64_t imageEntry, uint64_t imageSize, std::wstring dllName, int type);

	void Relocation(uint64_t newBase, int type);

	void FixImport(uint64_t baseAddr, LIEF::PE::Binary::it_imports imports);

	bool LoadPE(const std::string path);


	void LoadModule(std::string path, int type);
};

#endif

```

`KDemu/NtType.hpp`:

```hpp


#define OBJ_CASE_INSENSITIVE 0x00000040
#ifndef InitializeObjectAttributes
#define InitializeObjectAttributes(p, n, a, r, s) { \
    (p)->Length = sizeof(OBJECT_ATTRIBUTES);        \
    (p)->RootDirectory = r;                         \
    (p)->Attributes = a;                            \
    (p)->ObjectName = n;                            \
    (p)->SecurityDescriptor = s;                    \
    (p)->SecurityQualityOfService = NULL;           \
}
#endif
typedef struct _SYSTEM_FIRMWARE_TABLE_INFORMATION {
    ULONG ProviderSignature;
    ULONG Action;
    ULONG TableID;
    ULONG Reserved;
    UCHAR Data[ANYSIZE_ARRAY];
} SYSTEM_FIRMWARE_TABLE_INFORMATION, * PSYSTEM_FIRMWARE_TABLE_INFORMATION;
typedef struct _OBJECT_ATTRIBUTES {
    ULONG Length;
    HANDLE RootDirectory;
    uint64_t ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;
    PVOID SecurityQualityOfService;
} OBJECT_ATTRIBUTES;
typedef OBJECT_ATTRIBUTES* POBJECT_ATTRIBUTES;

struct FAKE_MDL {
    uint64_t Next;
    uint16_t Size;
    uint16_t MdlFlags;
    uint64_t Process;
    uint64_t MappedSystemVa;
    uint64_t StartVa;
    uint32_t ByteCount;
    uint32_t ByteOffset;
};
enum OB_OPERATION {
    OB_OPERATION_HANDLE_CREATE = 0x1,
    OB_OPERATION_HANDLE_DUPLICATE = 0x2
};
using POB_PRE_OPERATION_CALLBACK = uint64_t;
using POB_POST_OPERATION_CALLBACK = uint64_t;

struct _OBJECT_TYPE {
    UNICODE_STRING Name;
    uint32_t ObjectTypeFlags;
};
typedef struct _OBJECT_TYPE* POBJECT_TYPE;

typedef struct _OB_OPERATION_REGISTRATION {
    POBJECT_TYPE ObjectType;
    OB_OPERATION Operations;
    POB_PRE_OPERATION_CALLBACK PreOperation;
    POB_POST_OPERATION_CALLBACK PostOperation;
} OB_OPERATION_REGISTRATION, * POB_OPERATION_REGISTRATION;



typedef struct _OB_CALLBACK_REGISTRATION {
    USHORT Version;
    USHORT OperationRegistrationCount;
    UNICODE_STRING Altitude;
    PVOID RegistrationContext;
    OB_OPERATION_REGISTRATION* OperationRegistration;
} OB_CALLBACK_REGISTRATION, * POB_CALLBACK_REGISTRATION;


struct ObCallbackEntry {
    uint64_t RegistrationContext;
    uint64_t ObjectType;
    uint32_t Operations;
    uint64_t PreOperation;
    uint64_t PostOperation;
};

typedef struct _WIN_CERTIFICATE
{
    DWORD dwLength;
    WORD  wRevision;
    WORD  wCertificateType;
    BYTE  bCertificate[ANYSIZE_ARRAY];
} WIN_CERTIFICATE, * LPWIN_CERTIFICATE;


typedef enum _KERNEL_STACK_LIMITS {
    BugcheckStackLimits,
    DPCStackLimits,
    ExpandedStackLimits,
    NormalStackLimits,
    Win32kStackLimits,
    MaximumStackLimits
} KERNEL_STACK_LIMITS, * PKERNEL_STACK_LIMITS;
typedef struct _KERNEL_STACK_SEGMENT
{
    ULONG StackBase;
    ULONG StackLimit;
    ULONG KernelStack;
    ULONG InitialStack;
    ULONG ActualLimit;
} KERNEL_STACK_SEGMENT, * PKERNEL_STACK_SEGMENT;



typedef struct _KTRAP_FRAME
{
    ULONG DbgEbp;
    ULONG DbgEip;
    ULONG DbgArgMark;
    ULONG DbgArgPointer;
    WORD TempSegCs;
    UCHAR Logging;
    UCHAR Reserved;
    ULONG TempEsp;
    ULONG Dr0;
    ULONG Dr1;
    ULONG Dr2;
    ULONG Dr3;
    ULONG Dr6;
    ULONG Dr7;
    ULONG SegGs;
    ULONG SegEs;
    ULONG SegDs;
    ULONG Edx;
    ULONG Ecx;
    ULONG Eax;
    ULONG PreviousPreviousMode;
    PEXCEPTION_REGISTRATION_RECORD ExceptionList;
    ULONG SegFs;
    ULONG Edi;
    ULONG Esi;
    ULONG Ebx;
    ULONG Ebp;
    ULONG ErrCode;
    ULONG Eip;
    ULONG SegCs;
    ULONG EFlags;
    ULONG HardwareEsp;
    ULONG HardwareSegSs;
    ULONG V86Es;
    ULONG V86Ds;
    ULONG V86Fs;
    ULONG V86Gs;
} KTRAP_FRAME, * PKTRAP_FRAME;
typedef struct _KERNEL_STACK_CONTROL
{
    union
    {
        PKTRAP_FRAME PreviousTrapFrame;
        PVOID PreviousExceptionList;
    };
    ULONG StackControlFlags;
    ULONG PreviousLargeStack : 1;
    ULONG PreviousSegmentsPresent : 1;
    ULONG ExpandCalloutStack : 1;
    KERNEL_STACK_SEGMENT Previous;
} KERNEL_STACK_CONTROL, * PKERNEL_STACK_CONTROL;


union SegmentDescriptor {
    ULONG64 all;
    struct {
        ULONG64 limit_low : 16;
        ULONG64 base_low : 16;
        ULONG64 base_mid : 8;
        ULONG64 type : 4;
        ULONG64 system : 1;
        ULONG64 dpl : 2;
        ULONG64 present : 1;
        ULONG64 limit_high : 4;
        ULONG64 avl : 1;
        ULONG64 l : 1;
        ULONG64 db : 1;
        ULONG64 gran : 1;
        ULONG64 base_high : 8;
    } fields;
};

struct SegmentDesctiptorX64 {
    SegmentDescriptor descriptor;
    ULONG32 base_upper32;
    ULONG32 reserved;
};

union SegmentSelector {
    unsigned short all;
    struct {
        unsigned short rpl : 2;
        unsigned short ti : 1;
        unsigned short index : 13;
    } fields;
};

enum class Msr : unsigned int {
    kIa32ApicBase = 0x01B,

    kIa32FeatureControl = 0x03A,

    kIa32SysenterCs = 0x174,
    kIa32SysenterEsp = 0x175,
    kIa32SysenterEip = 0x176,

    kIa32Debugctl = 0x1D9,

    kIa32MtrrCap = 0xFE,
    kIa32MtrrDefType = 0x2FF,
    kIa32MtrrPhysBaseN = 0x200,
    kIa32MtrrPhysMaskN = 0x201,
    kIa32MtrrFix64k00000 = 0x250,
    kIa32MtrrFix16k80000 = 0x258,
    kIa32MtrrFix16kA0000 = 0x259,
    kIa32MtrrFix4kC0000 = 0x268,
    kIa32MtrrFix4kC8000 = 0x269,
    kIa32MtrrFix4kD0000 = 0x26A,
    kIa32MtrrFix4kD8000 = 0x26B,
    kIa32MtrrFix4kE0000 = 0x26C,
    kIa32MtrrFix4kE8000 = 0x26D,
    kIa32MtrrFix4kF0000 = 0x26E,
    kIa32MtrrFix4kF8000 = 0x26F,

    kIa32VmxBasic = 0x480,
    kIa32VmxPinbasedCtls = 0x481,
    kIa32VmxProcBasedCtls = 0x482,
    kIa32VmxExitCtls = 0x483,
    kIa32VmxEntryCtls = 0x484,
    kIa32VmxMisc = 0x485,
    kIa32VmxCr0Fixed0 = 0x486,
    kIa32VmxCr0Fixed1 = 0x487,
    kIa32VmxCr4Fixed0 = 0x488,
    kIa32VmxCr4Fixed1 = 0x489,
    kIa32VmxVmcsEnum = 0x48A,
    kIa32VmxProcBasedCtls2 = 0x48B,
    kIa32VmxEptVpidCap = 0x48C,
    kIa32VmxTruePinbasedCtls = 0x48D,
    kIa32VmxTrueProcBasedCtls = 0x48E,
    kIa32VmxTrueExitCtls = 0x48F,
    kIa32VmxTrueEntryCtls = 0x490,
    kIa32VmxVmfunc = 0x491,

    kIa32Efer = 0xC0000080,
    kIa32Star = 0xC0000081,
    kIa32Lstar = 0xC0000082,

    kIa32Fmask = 0xC0000084,

    kIa32FsBase = 0xC0000100,
    kIa32GsBase = 0xC0000101,
    kIa32KernelGsBase = 0xC0000102,
    kIa32TscAux = 0xC0000103,
};

typedef struct _KPCR
{
    SegmentDesctiptorX64 gdt[8];
}KPCR;

union FlagRegister {
    ULONG_PTR all;
    struct {
        ULONG_PTR cf : 1;
        ULONG_PTR reserved1 : 1;
        ULONG_PTR pf : 1;
        ULONG_PTR reserved2 : 1;
        ULONG_PTR af : 1;
        ULONG_PTR reserved3 : 1;
        ULONG_PTR zf : 1;
        ULONG_PTR sf : 1;
        ULONG_PTR tf : 1;
        ULONG_PTR intf : 1;
        ULONG_PTR df : 1;
        ULONG_PTR of : 1;
        ULONG_PTR iopl : 2;
        ULONG_PTR nt : 1;
        ULONG_PTR reserved4 : 1;
        ULONG_PTR rf : 1;
        ULONG_PTR vm : 1;
        ULONG_PTR ac : 1;
        ULONG_PTR vif : 1;
        ULONG_PTR vip : 1;
        ULONG_PTR id : 1;
        ULONG_PTR reserved5 : 10;
    } fields;
};



/*
    x64的teb_64 32位的没做
*/
struct _ACTIVATION_CONTEXT_STACK
{
    struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME* ActiveFrame;
    struct _LIST_ENTRY FrameListCache;
    ULONG Flags;
    ULONG NextCookieSequenceNumber;
    ULONG StackId;
};
struct _GDI_TEB_BATCH
{
    ULONG Offset : 31;
    ULONG HasRenderingCommand : 1;
    ULONGLONG HDC;
    ULONG Buffer[310];
};
struct _CLIENT_ID
{
    DWORD64 UniqueProcess;
    DWORD64 UniqueThread;
};
static_assert(sizeof(_CLIENT_ID) == 0x10, "_CLIENT_ID Size check");

static_assert(sizeof(_NT_TIB) == 0x38, "_NT_TIB Size check");
typedef struct X64TEB {
    struct _NT_TIB NtTib;
    VOID* EnvironmentPointer;
    struct _CLIENT_ID ClientId;
    VOID* ActiveRpcHandle;
    VOID* ThreadLocalStoragePointer;
    struct _PEB* ProcessEnvironmentBlock;
    ULONG LastErrorValue;
    ULONG CountOfOwnedCriticalSections;
    VOID* CsrClientThread;
    VOID* Win32ThreadInfo;
    ULONG User32Reserved[26];
    ULONG UserReserved[5];
    VOID* WOW32Reserved;
    ULONG CurrentLocale;
    ULONG FpSoftwareStatusRegister;
    VOID* ReservedForDebuggerInstrumentation[16];
    VOID* SystemReserved1[30];
    CHAR PlaceholderCompatibilityMode;
    UCHAR PlaceholderHydrationAlwaysExplicit;
    CHAR PlaceholderReserved[10];
    ULONG ProxiedProcessId;
    struct _ACTIVATION_CONTEXT_STACK _ActivationStack;
    UCHAR WorkingOnBehalfTicket[8];
    LONG ExceptionCode;
    UCHAR Padding0[4];
    struct _ACTIVATION_CONTEXT_STACK* ActivationContextStackPointer;
    ULONGLONG InstrumentationCallbackSp;
    ULONGLONG InstrumentationCallbackPreviousPc;
    ULONGLONG InstrumentationCallbackPreviousSp;
    ULONG TxFsContext;
    UCHAR InstrumentationCallbackDisabled;
    UCHAR UnalignedLoadStoreExceptions;
    UCHAR Padding1[2];
    struct _GDI_TEB_BATCH GdiTebBatch;
    struct _CLIENT_ID RealClientId;
    VOID* GdiCachedProcessHandle;
    ULONG GdiClientPID;
    ULONG GdiClientTID;
    VOID* GdiThreadLocalInfo;
    ULONGLONG Win32ClientInfo[62];
    VOID* glDispatchTable[233];
    ULONGLONG glReserved1[29];
    VOID* glReserved2;
    VOID* glSectionInfo;
    VOID* glSection;
    VOID* glTable;
    VOID* glCurrentRC;
    VOID* glContext;
    ULONG LastStatusValue;
    UCHAR Padding2[4];
    struct _UNICODE_STRING StaticUnicodeString;
    WCHAR StaticUnicodeBuffer[261];
    UCHAR Padding3[6];
    VOID* DeallocationStack;
    VOID* TlsSlots[64];
    struct _LIST_ENTRY TlsLinks;
    VOID* Vdm;
    VOID* ReservedForNtRpc;
    VOID* DbgSsReserved[2];
    ULONG HardErrorMode;
    UCHAR Padding4[4];
    VOID* Instrumentation[11];
    struct _GUID ActivityId;
    VOID* SubProcessTag;
    VOID* PerflibData;
    VOID* EtwTraceData;
    VOID* WinSockData;
    ULONG GdiBatchCount;
    union
    {
        struct _PROCESSOR_NUMBER CurrentIdealProcessor;
        ULONG IdealProcessorValue;
        struct
        {
            UCHAR ReservedPad0;
            UCHAR ReservedPad1;
            UCHAR ReservedPad2;
            UCHAR IdealProcessor;
        };
    };
    ULONG GuaranteedStackBytes;
    UCHAR Padding5[4];
    VOID* ReservedForPerf;
    VOID* ReservedForOle;
    ULONG WaitingOnLoaderLock;
    UCHAR Padding6[4];
    VOID* SavedPriorityState;
    ULONGLONG ReservedForCodeCoverage;
    VOID* ThreadPoolData;
    VOID** TlsExpansionSlots;
    VOID* DeallocationBStore;
    VOID* BStoreLimit;
    ULONG MuiGeneration;
    ULONG IsImpersonating;
    VOID* NlsCache;
    VOID* pShimData;
    ULONG HeapData;
    UCHAR Padding7[4];
    VOID* CurrentTransactionHandle;
    struct _TEB_ACTIVE_FRAME* ActiveFrame;
    VOID* FlsData;
    VOID* PreferredLanguages;
    VOID* UserPrefLanguages;
    VOID* MergedPrefLanguages;
    ULONG MuiImpersonation;
    union
    {
        volatile USHORT CrossTebFlags;
        USHORT SpareCrossTebBits : 16;
    };
    union
    {
        USHORT SameTebFlags;
        struct
        {
            USHORT SafeThunkCall : 1;
            USHORT InDebugPrint : 1;
            USHORT HasFiberData : 1;
            USHORT SkipThreadAttach : 1;
            USHORT WerInShipAssertCode : 1;
            USHORT RanProcessInit : 1;
            USHORT ClonedThread : 1;
            USHORT SuppressDebugMsg : 1;
            USHORT DisableUserStackWalk : 1;
            USHORT RtlExceptionAttached : 1;
            USHORT InitialThread : 1;
            USHORT SessionAware : 1;
            USHORT LoadOwner : 1;
            USHORT LoaderWorker : 1;
            USHORT SkipLoaderInit : 1;
            USHORT SpareSameTebBits : 1;
        };
    };
    VOID* TxnScopeEnterCallback;
    VOID* TxnScopeExitCallback;
    VOID* TxnScopeContext;
    ULONG LockCount;
    LONG WowTebOffset;
    VOID* ResourceRetValue;
    VOID* ReservedForWdf;
    ULONGLONG ReservedForCrt;
    struct _GUID EffectiveContainerId;
};
static_assert(sizeof(X64TEB) == 0x1838, "TEB Size check");

#define IRP_MJ_CREATE                   0x00
#define IRP_MJ_CREATE_NAMED_PIPE        0x01
#define IRP_MJ_CLOSE                    0x02
#define IRP_MJ_READ                     0x03
#define IRP_MJ_WRITE                    0x04
#define IRP_MJ_QUERY_INFORMATION        0x05
#define IRP_MJ_SET_INFORMATION          0x06
#define IRP_MJ_QUERY_EA                 0x07
#define IRP_MJ_SET_EA                   0x08
#define IRP_MJ_FLUSH_BUFFERS            0x09
#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a
#define IRP_MJ_SET_VOLUME_INFORMATION   0x0b
#define IRP_MJ_DIRECTORY_CONTROL        0x0c
#define IRP_MJ_FILE_SYSTEM_CONTROL      0x0d
#define IRP_MJ_DEVICE_CONTROL           0x0e
#define IRP_MJ_INTERNAL_DEVICE_CONTROL  0x0f
#define IRP_MJ_SHUTDOWN                 0x10
#define IRP_MJ_LOCK_CONTROL             0x11
#define IRP_MJ_CLEANUP                  0x12
#define IRP_MJ_CREATE_MAILSLOT          0x13
#define IRP_MJ_QUERY_SECURITY           0x14
#define IRP_MJ_SET_SECURITY             0x15
#define IRP_MJ_POWER                    0x16
#define IRP_MJ_SYSTEM_CONTROL           0x17
#define IRP_MJ_DEVICE_CHANGE            0x18
#define IRP_MJ_QUERY_QUOTA              0x19
#define IRP_MJ_SET_QUOTA                0x1a
#define IRP_MJ_PNP                      0x1b
#define IRP_MJ_PNP_POWER                IRP_MJ_PNP
#define IRP_MJ_MAXIMUM_FUNCTION         0x1b



typedef struct _USER_DRIVER_OBJECT {
    SHORT Type;
    SHORT Size;
    PVOID DeviceObject;
    ULONG Flags;
    PVOID DriverStart;
    ULONG DriverSize;
    PVOID DriverSection;
    PVOID DriverExtension;
    UNICODE_STRING DriverName;
    PVOID HardwareDatabase;
    PVOID FastIoDispatch;
    PVOID DriverInit;
    PVOID DriverStartIo;
    PVOID DriverUnload;
    PVOID MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + 1];
} USER_DRIVER_OBJECT, * PUSER_DRIVER_OBJECT;


typedef struct _KLDR_DATA_TABLE_ENTRY {
    LIST_ENTRY InLoadOrderLinks;
    PVOID ExceptionTable;
    ULONG ExceptionTableSize;
    PVOID GpValue;
    PVOID NonPagedDebugInfo;
    PVOID DllBase;
    PVOID EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    ULONG Flags;
    USHORT LoadCount;
    USHORT __Unused5;
    PVOID SectionPointer;
    ULONG CheckSum;
    PVOID LoadedImports;
    PVOID PatchInformation;
} KLDR_DATA_TABLE_ENTRY, * PKLDR_DATA_TABLE_ENTRY;

struct _RTL_BALANCED_NODE
{
    union
    {
        struct _RTL_BALANCED_NODE* Children[2];
        struct
        {
            struct _RTL_BALANCED_NODE* Left;
            struct _RTL_BALANCED_NODE* Right;
        };
    };
    union
    {
        struct
        {
            UCHAR Red : 1;
            UCHAR Balance : 2;
        };
        ULONGLONG ParentValue;
    };
};

struct _LDR_DATA_TABLE_ENTRY
{
    struct _LIST_ENTRY InLoadOrderLinks;
    struct _LIST_ENTRY InMemoryOrderLinks;
    struct _LIST_ENTRY InInitializationOrderLinks;
    VOID* DllBase;
    VOID* EntryPoint;
    ULONG SizeOfImage;
    struct _UNICODE_STRING FullDllName;
    struct _UNICODE_STRING BaseDllName;
    union
    {
        UCHAR FlagGroup[4];
        ULONG Flags;
        struct
        {
            ULONG PackagedBinary : 1;
            ULONG MarkedForRemoval : 1;
            ULONG ImageDll : 1;
            ULONG LoadNotificationsSent : 1;
            ULONG TelemetryEntryProcessed : 1;
            ULONG ProcessStaticImport : 1;
            ULONG InLegacyLists : 1;
            ULONG InIndexes : 1;
            ULONG ShimDll : 1;
            ULONG InExceptionTable : 1;
            ULONG ReservedFlags1 : 2;
            ULONG LoadInProgress : 1;
            ULONG LoadConfigProcessed : 1;
            ULONG EntryProcessed : 1;
            ULONG ProtectDelayLoad : 1;
            ULONG ReservedFlags3 : 2;
            ULONG DontCallForThreads : 1;
            ULONG ProcessAttachCalled : 1;
            ULONG ProcessAttachFailed : 1;
            ULONG CorDeferredValidate : 1;
            ULONG CorImage : 1;
            ULONG DontRelocate : 1;
            ULONG CorILOnly : 1;
            ULONG ChpeImage : 1;
            ULONG ChpeEmulatorImage : 1;
            ULONG ReservedFlags5 : 1;
            ULONG Redirected : 1;
            ULONG ReservedFlags6 : 2;
            ULONG CompatDatabaseProcessed : 1;
        };
    };
    USHORT ObsoleteLoadCount;
    USHORT TlsIndex;
    struct _LIST_ENTRY HashLinks;
    ULONG TimeDateStamp;
    struct _ACTIVATION_CONTEXT* EntryPointActivationContext;
    VOID* Lock;
    struct _LDR_DDAG_NODE* DdagNode;
    struct _LIST_ENTRY NodeModuleLink;
    struct _LDRP_LOAD_CONTEXT* LoadContext;
    VOID* ParentDllBase;
    VOID* SwitchBackContext;
    struct _RTL_BALANCED_NODE BaseAddressIndexNode;
    struct _RTL_BALANCED_NODE MappingInfoIndexNode;
    ULONGLONG OriginalBase;
    union _LARGE_INTEGER LoadTime;
    ULONG BaseNameHashValue;
    enum _LDR_DLL_LOAD_REASON LoadReason;
    ULONG ImplicitPathOptions;
    ULONG ReferenceCount;
    ULONG DependentLoadFlags;
    UCHAR SigningLevel;
    ULONG CheckSum;
    VOID* ActivePatchImageBase;
    enum _LDR_HOT_PATCH_STATE HotPatchState;
};

struct _PRIMITIVE_UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    WCHAR* Buffer;
};

typedef struct _DRIVER_OBJECT {
    SHORT Type;
    SHORT Size;
    struct _DEVICE_OBJECT* DeviceObject;
    ULONG Flags;
    VOID* DriverStart;
    ULONG DriverSize;
    VOID* DriverSection;
    struct _DRIVER_EXTENSION* DriverExtension;
    struct _PRIMITIVE_UNICODE_STRING DriverName;
    struct _PRIMITIVE_UNICODE_STRING* HardwareDatabase;
    struct _FAST_IO_DISPATCH* FastIoDispatch;
    LONG(*DriverInit)(struct _DRIVER_OBJECT* arg1, struct _UNICODE_STRING* arg2);
    VOID(*DriverStartIo)(struct _DEVICE_OBJECT* arg1, struct _IRP* arg2);
    VOID(*DriverUnload)(struct _DRIVER_OBJECT* arg1);
    PVOID MajorFunction;
}DRIVER_OBJECT, * PDRIVER_OBJECT;
struct _KDEVICE_QUEUE {
    SHORT Type;
    SHORT Size;
    struct _LIST_ENTRY DeviceListHead;
    ULONGLONG Lock;
    union {
        UCHAR Busy;
        struct {
            LONGLONG Reserved : 8;
            LONGLONG Hint : 56;
        };
    };
};
struct _KDPC {
    union {
        ULONG TargetInfoAsUlong;
        struct {
            UCHAR Type;
            UCHAR Importance;
            volatile USHORT Number;
        };
    };
    struct _SINGLE_LIST_ENTRY DpcListEntry;
    ULONGLONG ProcessorHistory;
    VOID(*DeferredRoutine)(struct _KDPC* arg1, VOID* arg2, VOID* arg3, VOID* arg4);
    VOID* DeferredContext;
    VOID* SystemArgument1;
    VOID* SystemArgument2;
    VOID* DpcData;
};
struct _KDEVICE_QUEUE_ENTRY {
    struct _LIST_ENTRY DeviceListEntry;
    ULONG SortKey;
    UCHAR Inserted;
};
struct _WAIT_CONTEXT_BLOCK {
    union {
        struct _KDEVICE_QUEUE_ENTRY WaitQueueEntry;
        struct {
            struct _LIST_ENTRY DmaWaitEntry;
            ULONG NumberOfChannels;
            ULONG SyncCallback : 1;
            ULONG DmaContext : 1;
            ULONG ZeroMapRegisters : 1;
            ULONG Reserved : 9;
            ULONG NumberOfRemapPages : 20;
        };
    };
    enum _IO_ALLOCATION_ACTION(*DeviceRoutine)(struct _DEVICE_OBJECT* arg1, struct _IRP* arg2, VOID* arg3, VOID* arg4);
    VOID* DeviceContext;
    ULONG NumberOfMapRegisters;
    VOID* DeviceObject;
    VOID* CurrentIrp;
    struct _KDPC* BufferChainingDpc;
};
struct _DISPATCHER_HEADER {
    union {
        volatile LONG Lock;
        LONG LockNV;
        struct {
            UCHAR Type;
            UCHAR Signalling;
            UCHAR Size;
            UCHAR Reserved1;
        };
        struct {
            UCHAR TimerType;
            union {
                UCHAR TimerControlFlags;
                struct {
                    UCHAR Absolute : 1;
                    UCHAR Wake : 1;
                    UCHAR EncodedTolerableDelay : 6;
                };
            };
            UCHAR Hand;
            union {
                UCHAR TimerMiscFlags;
                struct {
                    UCHAR Index : 6;
                    UCHAR Inserted : 1;
                    volatile UCHAR Expired : 1;
                };
            };
        };
        struct {
            UCHAR Timer2Type;
            union {
                UCHAR Timer2Flags;
                struct {
                    UCHAR Timer2Inserted : 1;
                    UCHAR Timer2Expiring : 1;
                    UCHAR Timer2CancelPending : 1;
                    UCHAR Timer2SetPending : 1;
                    UCHAR Timer2Running : 1;
                    UCHAR Timer2Disabled : 1;
                    UCHAR Timer2ReservedFlags : 2;
                };
            };
            UCHAR Timer2ComponentId;
            UCHAR Timer2RelativeId;
        };
        struct {
            UCHAR QueueType;
            union {
                UCHAR QueueControlFlags;
                struct {
                    UCHAR Abandoned : 1;
                    UCHAR DisableIncrement : 1;
                    UCHAR QueueReservedControlFlags : 6;
                };
            };
            UCHAR QueueSize;
            UCHAR QueueReserved;
        };
        struct {
            UCHAR ThreadType;
            UCHAR ThreadReserved;
            union {
                UCHAR ThreadControlFlags;
                struct {
                    UCHAR CycleProfiling : 1;
                    UCHAR CounterProfiling : 1;
                    UCHAR GroupScheduling : 1;
                    UCHAR AffinitySet : 1;
                    UCHAR Tagged : 1;
                    UCHAR EnergyProfiling : 1;
                    UCHAR SchedulerAssist : 1;
                    UCHAR ThreadReservedControlFlags : 1;
                };
            };
            union {
                UCHAR DebugActive;
                struct {
                    UCHAR ActiveDR7 : 1;
                    UCHAR Instrumented : 1;
                    UCHAR Minimal : 1;
                    UCHAR Reserved4 : 2;
                    UCHAR AltSyscall : 1;
                    UCHAR UmsScheduled : 1;
                    UCHAR UmsPrimary : 1;
                };
            };
        };
        struct {
            UCHAR MutantType;
            UCHAR MutantSize;
            UCHAR DpcActive;
            UCHAR MutantReserved;
        };
    };
    LONG SignalState;
    struct _LIST_ENTRY WaitListHead;
};

struct _KEVENT {
    struct _DISPATCHER_HEADER Header;
};

struct _DEVICE_OBJECT {
    SHORT Type;
    USHORT Size;
    LONG ReferenceCount;
    struct _DRIVER_OBJECT* DriverObject;
    struct _DEVICE_OBJECT* NextDevice;
    struct _DEVICE_OBJECT* AttachedDevice;
    struct _IRP* CurrentIrp;
    struct _IO_TIMER* Timer;
    ULONG Flags;
    ULONG Characteristics;
    struct _VPB* Vpb;
    VOID* DeviceExtension;
    ULONG DeviceType;
    CHAR StackSize;
    union {
        struct _LIST_ENTRY ListEntry;
        struct _WAIT_CONTEXT_BLOCK Wcb;
    } Queue;
    ULONG AlignmentRequirement;
    struct _KDEVICE_QUEUE DeviceQueue;
    struct _KDPC Dpc;
    ULONG ActiveThreadCount;
    VOID* SecurityDescriptor;
    struct _KEVENT DeviceLock;
    USHORT SectorSize;
    USHORT Spare1;
    struct _DEVOBJ_EXTENSION* DeviceObjectExtension;
    VOID* Reserved;
};


typedef union _UNWIND_CODE {
    struct {
        UCHAR CodeOffset;
        UCHAR UnwindOp : 4;
        UCHAR OpInfo : 4;
    };

    USHORT FrameOffset;
} UNWIND_CODE, * PUNWIND_CODE;

typedef struct _UNWIND_INFO {
    UCHAR Version : 3;
    UCHAR Flags : 5;
    UCHAR SizeOfProlog;
    UCHAR CountOfCodes;
    UCHAR FrameRegister : 4;
    UCHAR FrameOffset : 4;
    UNWIND_CODE UnwindCode[1];


} UNWIND_INFO, * PUNWIND_INFO;
typedef enum _UNWIND_OP_CODES {
    UWOP_PUSH_NONVOL = 0,
    UWOP_ALLOC_LARGE,
    UWOP_ALLOC_SMALL,
    UWOP_SET_FPREG,
    UWOP_SAVE_NONVOL,
    UWOP_SAVE_NONVOL_FAR,
    UWOP_SPARE_CODE1,
    UWOP_SPARE_CODE2,
    UWOP_SAVE_XMM128,
    UWOP_SAVE_XMM128_FAR,
    UWOP_PUSH_MACHFRAME
} UNWIND_OP_CODES, * PUNWIND_OP_CODES;

typedef struct _TIME_FIELDS {
    SHORT Year;
    SHORT Month;
    SHORT Day;
    SHORT Hour;
    SHORT Minute;
    SHORT Second;
    SHORT Milliseconds;
    SHORT Weekday;
} TIME_FIELDS, * PTIME_FIELDS;

struct FILE_STANDARD_INFORMATION {
    uint64_t AllocationSize;
    uint64_t EndOfFile;
    uint32_t NumberOfLinks;
    uint8_t  DeletePending;
    uint8_t  Directory;
};
typedef struct _FILE_DIRECTORY_INFORMATION {
    ULONG         NextEntryOffset;
    ULONG         FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG         FileAttributes;
    ULONG         FileNameLength;
    WCHAR         FileName[1];
} FILE_DIRECTORY_INFORMATION;
typedef struct _SYSTEM_CODEINTEGRITY_INFORMATION {
    ULONG Length;
    ULONG CodeIntegrityOptions;
} SYSTEM_CODEINTEGRITY_INFORMATION, * PSYSTEM_CODEINTEGRITY_INFORMATION;
typedef LONG KPRIORITY;
typedef struct _SYSTEM_PROCESS_INFORMATION {
    ULONG NextEntryOffset;
    ULONG NumberOfThreads;
    LARGE_INTEGER WorkingSetPrivateSize;
    ULONG HardFaultCount;
    ULONG NumberOfThreadsHighWatermark;
    ULONGLONG CycleTime;
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER KernelTime;
    UNICODE_STRING ImageName;
    KPRIORITY BasePriority;
    HANDLE UniqueProcessId;
    HANDLE InheritedFromUniqueProcessId;
    ULONG HandleCount;
    ULONG SessionId;
    ULONG_PTR UniqueProcessKey;
    SIZE_T PeakVirtualSize;
    SIZE_T VirtualSize;
    ULONG PageFaultCount;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
    SIZE_T PrivatePageCount;
    LARGE_INTEGER ReadOperationCount;
    LARGE_INTEGER WriteOperationCount;
    LARGE_INTEGER OtherOperationCount;
    LARGE_INTEGER ReadTransferCount;
    LARGE_INTEGER WriteTransferCount;
    LARGE_INTEGER OtherTransferCount;
} SYSTEM_PROCESS_INFORMATION, * PSYSTEM_PROCESS_INFORMATION;

typedef struct _SYSTEM_CODEINTEGRITY_CERTIFICATE_INFORMATION {
    ULONG  CodeIntegrityOptions;
    ULONG  CodeIntegrityPolicy;
    ULONG  Reserved;
} SYSTEM_CODEINTEGRITY_CERTIFICATE_INFORMATION, * PSYSTEM_CODEINTEGRITY_CERTIFICATE_INFORMATION;
typedef struct _FILE_NETWORK_OPEN_INFORMATION
{
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    ULONG FileAttributes;
} FILE_NETWORK_OPEN_INFORMATION, * PFILE_NETWORK_OPEN_INFORMATION;

typedef struct _IO_STATUS_BLOCK {
#pragma warning(push)
#pragma warning(disable: 4201)
    union {
        NTSTATUS Status;
        PVOID Pointer;
    } DUMMYUNIONNAME;
#pragma warning(pop)

    ULONG_PTR Information;
} IO_STATUS_BLOCK, * PIO_STATUS_BLOCK;
typedef
VOID
(NTAPI* PIO_APC_ROUTINE) (
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    );

#define FILE_DIRECTORY_FILE                     0x00000001
#define FILE_WRITE_THROUGH                      0x00000002
#define FILE_SEQUENTIAL_ONLY                    0x00000004
#define FILE_NO_INTERMEDIATE_BUFFERING          0x00000008

#define FILE_SYNCHRONOUS_IO_ALERT               0x00000010
#define FILE_SYNCHRONOUS_IO_NONALERT            0x00000020
#define FILE_NON_DIRECTORY_FILE                 0x00000040
#define FILE_CREATE_TREE_CONNECTION             0x00000080

#define FILE_COMPLETE_IF_OPLOCKED               0x00000100
#define FILE_NO_EA_KNOWLEDGE                    0x00000200
#define FILE_OPEN_REMOTE_INSTANCE               0x00000400
#define FILE_RANDOM_ACCESS                      0x00000800

#define FILE_DELETE_ON_CLOSE                    0x00001000
#define FILE_OPEN_BY_FILE_ID                    0x00002000
#define FILE_OPEN_FOR_BACKUP_INTENT             0x00004000
#define FILE_NO_COMPRESSION                     0x00008000

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN7)
#define FILE_OPEN_REQUIRING_OPLOCK              0x00010000
#endif

#define FILE_RESERVE_OPFILTER                   0x00100000
#define FILE_OPEN_REPARSE_POINT                 0x00200000
#define FILE_OPEN_NO_RECALL                     0x00400000
#define FILE_OPEN_FOR_FREE_SPACE_QUERY          0x00800000

#define FILE_VALID_OPTION_FLAGS                 0x00ffffff
#define FILE_VALID_PIPE_OPTION_FLAGS            0x00000032
#define FILE_VALID_MAILSLOT_OPTION_FLAGS        0x00000032
#define FILE_VALID_SET_FLAGS                    0x00000036
struct RTL_BITMAP {
    uint32_t SizeOfBitMap;
    uint32_t* Buffer;
};

struct KPROCESS
{
    uint8_t Header[0x18];
    struct _LIST_ENTRY ProfileListHead;
    ULONGLONG DirectoryTableBase;
    struct _LIST_ENTRY ThreadListHead;
    ULONG ProcessLock;
    ULONG ProcessTimerDelay;
    ULONGLONG DeepFreezeStartTime;
    uint8_t Affinity[0x108];
    struct _LIST_ENTRY ReadyListHead;
    struct _SINGLE_LIST_ENTRY SwapListEntry;
    uint8_t ActiveProcessors[0x278 - 0x170];
    union
    {
        struct
        {
            ULONG AutoAlignment : 1;
            ULONG DisableBoost : 1;
            ULONG DisableQuantum : 1;
            ULONG DeepFreeze : 1;
            ULONG TimerVirtualization : 1;
            ULONG CheckStackExtents : 1;
            ULONG CacheIsolationEnabled : 1;
            ULONG PpmPolicy : 4;
            ULONG VaSpaceDeleted : 1;
            ULONG MultiGroup : 1;
            ULONG ReservedFlags : 19;
        };
        volatile LONG ProcessFlags;
    };
    ULONG ActiveGroupsMask;
    CHAR BasePriority;
    CHAR QuantumReset;
    CHAR Visited;
    uint8_t Flags;
    USHORT ThreadSeed[32];
    USHORT IdealProcessor[32];
    USHORT IdealNode[32];
    USHORT IdealGlobalNode;
    USHORT Spare1;
    USHORT StackCount;
    struct _LIST_ENTRY ProcessListEntry;
    ULONGLONG CycleTime;
    ULONGLONG ContextSwitches;
    struct _KSCHEDULING_GROUP* SchedulingGroup;
    ULONG FreezeCount;
    ULONG KernelTime;
    ULONG UserTime;
    ULONG ReadyTime;
    ULONGLONG UserDirectoryTableBase;
    UCHAR AddressPolicy;
    UCHAR Spare2[71];
    VOID* InstrumentationCallback;
    union
    {
        ULONGLONG SecureHandle;
        struct
        {
            ULONGLONG SecureProcess : 1;
            ULONGLONG Unused : 1;
        } Flags;
    } SecureState;
    ULONGLONG KernelWaitTime;
    ULONGLONG UserWaitTime;
    ULONGLONG LastRebalanceQpc;
    VOID* PerProcessorCycleTimes;
    ULONGLONG ExtendedFeatureDisableMask;
    USHORT PrimaryGroup;
    USHORT Spare3[3];
    VOID* UserCetLogging;
    ULONGLONG EndPadding[3];
};

typedef struct _KAPC_STATE {
    LIST_ENTRY ApcListHead[2];
    struct KPROCESS* Process;
    BOOLEAN KernelApcInProgress;
    BOOLEAN KernelApcPending;
    BOOLEAN UserApcPending;
} KAPC_STATE, * PKAPC_STATE, * PRKAPC_STATE;

typedef struct _RTL_PROCESS_MODULE_INFORMATION {
    HANDLE Section;
    PVOID MappedBase;
    PVOID ImageBase;
    ULONG ImageSize;
    ULONG Flags;
    USHORT LoadOrderIndex;
    USHORT InitOrderIndex;
    USHORT LoadCount;
    USHORT OffsetToFileName;
    UCHAR  FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULE_INFORMATION_EX {
    USHORT NextOffset;
    RTL_PROCESS_MODULE_INFORMATION BaseInfo;
    ULONG  ImageChecksum;
    ULONG  TimeDateStamp;
    PVOID  DefaultBase;
} RTL_PROCESS_MODULE_INFORMATION_EX, * PRTL_PROCESS_MODULE_INFORMATION_EX;

typedef struct _RTL_PROCESS_MODULES_EX {
    ULONG NumberOfModules;
    RTL_PROCESS_MODULE_INFORMATION_EX Modules[1];
} RTL_PROCESS_MODULES_EX, * PRTL_PROCESS_MODULES_EX;


typedef struct _RTL_PROCESS_MODULES {
    ULONG NumberOfModules;
    RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;

struct SYSTEM_MODULE_INFORMATION_ENTRY {
    void* Section;
    void* MappedBase;
    void* ImageBase;
    uint32_t ImageSize;
    uint32_t Flags;
    uint16_t LoadOrderIndex;
    uint16_t InitOrderIndex;
    uint16_t LoadCount;
    uint16_t OffsetToFileName;
    char FullPathName[256];
};

typedef struct _PROCESS_BASIC_INFORMATION {
    PVOID Reserved1;
    PVOID PebBaseAddress;
    PVOID Reserved2[2];
    ULONG_PTR UniqueProcessId;
    PVOID Reserved3;
} PROCESS_BASIC_INFORMATION;

typedef struct _SYSTEM_MODULE_INFORMATION {
    ULONG ModuleCount;
    SYSTEM_MODULE_INFORMATION_ENTRY Modules[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;
typedef struct _Asn1BlobPtr
{
    int size;
    PVOID ptrToData;
} Asn1BlobPtr, * pAsn1BlobPtr;

typedef struct _CertificatePartyName
{
    PVOID pointerToName;
    short nameLen;
    short unknown;
} CertificatePartyName, * pCertificatePartyName;

typedef struct _CertChainMember
{
    int digestIdetifier;
    int digestSize;
    BYTE digestBuffer[64];
    CertificatePartyName subjectName;
    CertificatePartyName issuerName;
    Asn1BlobPtr certificate;
} CertChainMember, * pCertChainMember;

typedef struct _CertChainInfoHeader
{
    int bufferSize;
    pAsn1BlobPtr ptrToPublicKeys;
    int numberOfPublicKeys;
    pAsn1BlobPtr ptrToEkus;
    int numberOfEkus;
    pCertChainMember ptrToCertChainMembers;
    int numberOfCertChainMembers;
    int unknown;
    Asn1BlobPtr variousAuthenticodeAttributes;
} CertChainInfoHeader, * pCertChainInfoHeader;

typedef struct _PolicyInfo
{
    int structSize;
    NTSTATUS verificationStatus;
    int flags;
    pCertChainInfoHeader certChainInfo;
    FILETIME revocationTime;
    FILETIME notBeforeTime;
    FILETIME notAfterTime;
} PolicyInfo, * pPolicyInfo;
```

`KDemu/UnicornEmu.hpp`:

```hpp
#pragma once
#include <unicorn/unicorn.h>
#include <unicorn/x86.h>
#include <cstdint>
#include <vector>
#include <memory>
#include <cstdarg>
#include <malloc.h>
#include <optional>
#include "LoadPE.hpp"

class UnicornEmu {
private:
    uc_engine* uc_;

public:
    explicit UnicornEmu(uc_engine* uc) : uc_(uc) {}

    UnicornEmu& rip(uint64_t value) {
        uc_reg_write(uc_, UC_X86_REG_RIP, &value);
        return *this;
    }
    
    uint64_t rip() const {
        uint64_t value;
        uc_reg_read(uc_, UC_X86_REG_RIP, &value);
        return value;
    }

    UnicornEmu& rax(uint64_t value) {
        uc_reg_write(uc_, UC_X86_REG_RAX, &value);
        return *this;
    }
    
    uint64_t rax() const {
        uint64_t value;
        uc_reg_read(uc_, UC_X86_REG_RAX, &value);
        return value;
    }

    UnicornEmu& rbx(uint64_t value) {
        uc_reg_write(uc_, UC_X86_REG_RBX, &value);
        return *this;
    }
    
    uint64_t rbx() const {
        uint64_t value;
        uc_reg_read(uc_, UC_X86_REG_RBX, &value);
        return value;
    }

    UnicornEmu& rcx(uint64_t value) {
        uc_reg_write(uc_, UC_X86_REG_RCX, &value);
        return *this;
    }
    
    uint64_t rcx() const {
        uint64_t value;
        uc_reg_read(uc_, UC_X86_REG_RCX, &value);
        return value;
    }

    UnicornEmu& rdx(uint64_t value) {
        uc_reg_write(uc_, UC_X86_REG_RDX, &value);
        return *this;
    }
    
    uint64_t rdx() const {
        uint64_t value;
        uc_reg_read(uc_, UC_X86_REG_RDX, &value);
        return value;
    }

    UnicornEmu& rsi(uint64_t value) {
        uc_reg_write(uc_, UC_X86_REG_RSI, &value);
        return *this;
    }
    
    uint64_t rsi() const {
        uint64_t value;
        uc_reg_read(uc_, UC_X86_REG_RSI, &value);
        return value;
    }

    UnicornEmu& rdi(uint64_t value) {
        uc_reg_write(uc_, UC_X86_REG_RDI, &value);
        return *this;
    }
    
    uint64_t rdi() const {
        uint64_t value;
        uc_reg_read(uc_, UC_X86_REG_RDI, &value);
        return value;
    }

    UnicornEmu& rsp(uint64_t value) {
        uc_reg_write(uc_, UC_X86_REG_RSP, &value);
        return *this;
    }
    
    uint64_t rsp() const {
        uint64_t value;
        uc_reg_read(uc_, UC_X86_REG_RSP, &value);
        return value;
    }

    UnicornEmu& rbp(uint64_t value) {
        uc_reg_write(uc_, UC_X86_REG_RBP, &value);
        return *this;
    }
    
    uint64_t rbp() const {
        uint64_t value;
        uc_reg_read(uc_, UC_X86_REG_RBP, &value);
        return value;
    }

    UnicornEmu& r8(uint64_t value) {
        uc_reg_write(uc_, UC_X86_REG_R8, &value);
        return *this;
    }
    
    uint64_t r8() const {
        uint64_t value;
        uc_reg_read(uc_, UC_X86_REG_R8, &value);
        return value;
    }

    UnicornEmu& r9(uint64_t value) {
        uc_reg_write(uc_, UC_X86_REG_R9, &value);
        return *this;
    }
    
    uint64_t r9() const {
        uint64_t value;
        uc_reg_read(uc_, UC_X86_REG_R9, &value);
        return value;
    }

    UnicornEmu& r10(uint64_t value) {
        uc_reg_write(uc_, UC_X86_REG_R10, &value);
        return *this;
    }
    
    uint64_t r10() const {
        uint64_t value;
        uc_reg_read(uc_, UC_X86_REG_R10, &value);
        return value;
    }

    UnicornEmu& r11(uint64_t value) {
        uc_reg_write(uc_, UC_X86_REG_R11, &value);
        return *this;
    }
    
    uint64_t r11() const {
        uint64_t value;
        uc_reg_read(uc_, UC_X86_REG_R11, &value);
        return value;
    }

    UnicornEmu& r12(uint64_t value) {
        uc_reg_write(uc_, UC_X86_REG_R12, &value);
        return *this;
    }
    
    uint64_t r12() const {
        uint64_t value;
        uc_reg_read(uc_, UC_X86_REG_R12, &value);
        return value;
    }

    UnicornEmu& r13(uint64_t value) {
        uc_reg_write(uc_, UC_X86_REG_R13, &value);
        return *this;
    }
    
    uint64_t r13() const {
        uint64_t value;
        uc_reg_read(uc_, UC_X86_REG_R13, &value);
        return value;
    }

    UnicornEmu& r14(uint64_t value) {
        uc_reg_write(uc_, UC_X86_REG_R14, &value);
        return *this;
    }
    
    uint64_t r14() const {
        uint64_t value;
        uc_reg_read(uc_, UC_X86_REG_R14, &value);
        return value;
    }

    UnicornEmu& r15(uint64_t value) {
        uc_reg_write(uc_, UC_X86_REG_R15, &value);
        return *this;
    }
    
    uint64_t r15() const {
        uint64_t value;
        uc_reg_read(uc_, UC_X86_REG_R15, &value);
        return value;
    }

    UnicornEmu& cr0(uint64_t value) {
        uc_reg_write(uc_, UC_X86_REG_CR0, &value);
        return *this;
    }
    
    uint64_t cr0() const {
        uint64_t value;
        uc_reg_read(uc_, UC_X86_REG_CR0, &value);
        return value;
    }

    UnicornEmu& cr2(uint64_t value) {
        uc_reg_write(uc_, UC_X86_REG_CR2, &value);
        return *this;
    }
    
    uint64_t cr2() const {
        uint64_t value;
        uc_reg_read(uc_, UC_X86_REG_CR2, &value);
        return value;
    }

    UnicornEmu& cr3(uint64_t value) {
        uc_reg_write(uc_, UC_X86_REG_CR3, &value);
        return *this;
    }
    
    uint64_t cr3() const {
        uint64_t value;
        uc_reg_read(uc_, UC_X86_REG_CR3, &value);
        return value;
    }

    UnicornEmu& cr4(uint64_t value) {
        uc_reg_write(uc_, UC_X86_REG_CR4, &value);
        return *this;
    }
    
    uint64_t cr4() const {
        uint64_t value;
        uc_reg_read(uc_, UC_X86_REG_CR4, &value);
        return value;
    }

    UnicornEmu& cr8(uint64_t value) {
        uc_reg_write(uc_, UC_X86_REG_CR8, &value);
        return *this;
    }
    
    uint64_t cr8() const {
        uint64_t value;
        uc_reg_read(uc_, UC_X86_REG_CR8, &value);
        return value;
    }

    UnicornEmu& cs(uint64_t value) {
        uc_reg_write(uc_, UC_X86_REG_CS, &value);
        return *this;
    }
    
    uint64_t cs() const {
        uint64_t value;
        uc_reg_read(uc_, UC_X86_REG_CS, &value);
        return value;
    }

    UnicornEmu& ds(uint64_t value) {
        uc_reg_write(uc_, UC_X86_REG_DS, &value);
        return *this;
    }
    
    uint64_t ds() const {
        uint64_t value;
        uc_reg_read(uc_, UC_X86_REG_DS, &value);
        return value;
    }

    UnicornEmu& es(uint64_t value) {
        uc_reg_write(uc_, UC_X86_REG_ES, &value);
        return *this;
    }
    
    uint64_t es() const {
        uint64_t value;
        uc_reg_read(uc_, UC_X86_REG_ES, &value);
        return value;
    }

    UnicornEmu& fs(uint64_t value) {
        uc_reg_write(uc_, UC_X86_REG_FS, &value);
        return *this;
    }
    
    uint64_t fs() const {
        uint64_t value;
        uc_reg_read(uc_, UC_X86_REG_FS, &value);
        return value;
    }

    UnicornEmu& gs(uint64_t value) {
        uc_reg_write(uc_, UC_X86_REG_GS, &value);
        return *this;
    }
    
    uint64_t gs() const {
        uint64_t value;
        uc_reg_read(uc_, UC_X86_REG_GS, &value);
        return value;
    }

    UnicornEmu& ss(uint64_t value) {
        uc_reg_write(uc_, UC_X86_REG_SS, &value);
        return *this;
    }
    
    uint64_t ss() const {
        uint64_t value;
        uc_reg_read(uc_, UC_X86_REG_SS, &value);
        return value;
    }

    UnicornEmu& gs_base(uint64_t value) {
        uc_reg_write(uc_, UC_X86_REG_GS_BASE, &value);
        return *this;
    }
    
    uint64_t gs_base() const {
        uint64_t value;
        uc_reg_read(uc_, UC_X86_REG_GS_BASE, &value);
        return value;
    }

    UnicornEmu& eflags(uint64_t value) {
        uc_reg_write(uc_, UC_X86_REG_EFLAGS, &value);
        return *this;
    }
    
    uint64_t eflags() const {
        uint64_t value;
        uc_reg_read(uc_, UC_X86_REG_EFLAGS, &value);
        return value;
    }

    template<typename T>
    T read(uint64_t addr) const {
        T value;
        uc_mem_read(uc_, addr, &value, sizeof(T));
        return value;
    }

    std::vector<uint8_t> read(uint64_t addr, size_t size) const {
        std::vector<uint8_t> data(size);
        uc_mem_read(uc_, addr, data.data(), size);
        return data;
    }

    bool try_read(uint64_t addr, void* buffer, size_t size) const {
        return uc_mem_read(uc_, addr, buffer, size) == UC_ERR_OK;
    }

    template<typename T>
    std::optional<T> try_read(uint64_t addr) const {
        T value;
        if (try_read(addr, &value, sizeof(T))) {
            return value;
        }
        return std::nullopt;
    }

    template<typename T>
    UnicornEmu& write(uint64_t addr, const T& value) {
        uc_mem_write(uc_, addr, &value, sizeof(T));
        return *this;
    }

    UnicornEmu& write(uint64_t addr, const void* data, size_t size) {
        uc_err err = uc_mem_write(uc_, addr, data, size);
        return *this;
    }

    bool try_write(uint64_t addr, const void* data, size_t size) const {
        return uc_mem_write(uc_, addr, data, size) == UC_ERR_OK;
    }

    UnicornEmu& write_page(uint64_t addr, const void* data) {
        write(addr, data, 0x1000);
        return *this;
    }

    uint64_t qword(uint64_t addr) const {
        return read<uint64_t>(addr);
    }

    uint32_t dword(uint64_t addr) const {
        return read<uint32_t>(addr);
    }

    uint16_t word(uint64_t addr) const {
        return read<uint16_t>(addr);
    }

    uint8_t byte(uint64_t addr) const {
        return read<uint8_t>(addr);
    }

    UnicornEmu& qword(uint64_t addr, uint64_t value) {
        return write(addr, value);
    }

    UnicornEmu& dword(uint64_t addr, uint32_t value) {
        return write(addr, value);
    }

    UnicornEmu& word(uint64_t addr, uint16_t value) {
        return write(addr, value);
    }

    UnicornEmu& byte(uint64_t addr, uint8_t value) {
        return write(addr, value);
    }

    uint64_t alloc(size_t size, uint64_t address = 0) {
        return alloc_impl(size, address, MUC_PROT_ALL, true);
    }

    uint64_t alloc(size_t size, uint64_t address, bool show) {
        return alloc_impl(size, address, MUC_PROT_ALL, show);
    }

    uint64_t alloc(size_t size, uint64_t address, my_uc_prot prot) {
        return alloc_impl(size, address, prot, true);
    }

    uint64_t alloc(size_t size, uint64_t address, my_uc_prot prot, bool show) {
        return alloc_impl(size, address, prot, show);
    }

    uint64_t alloc_impl(size_t size, uint64_t address, my_uc_prot prot, bool show) {
        PEloader* loader = &PEloader::GetInstance();
        EnterCriticalSection(&loader->cs);

        if (show) {
            Logger::Log(true, ConsoleColor::RED, "Alloc\n");
        }

        size_t allocSize = static_cast<size_t>(PAGE_ALIGN(size));
        if (allocSize == 0) {
            LeaveCriticalSection(&loader->cs);
            return 0;
        }

        if (address == 0) {
            if (loader->lastAlloc == 0) {
                loader->lastAlloc = PEloader::AllocBase;
            }
            address = loader->lastAlloc;
            loader->lastAlloc += allocSize;
        }

        void* real_addr = _aligned_malloc(allocSize, 0x1000);
        if (!real_addr) {
            Logger::Log(true, ConsoleColor::RED, "Alloc error: _aligned_malloc failed size: %llx\n", static_cast<uint64_t>(allocSize));
            LeaveCriticalSection(&loader->cs);
            return 0;
        }

        loader->real_mem_map[address] = { real_addr, static_cast<uint64_t>(allocSize) };

        switch (prot) {
        case MUC_PROT_ALL:
            loader->real_mem_map_type_all[address] = { real_addr, prot };
            break;
        case MUC_PROT_READ:
            loader->real_mem_map_type_read[address] = { real_addr, prot };
            break;
        case MUC_PORT_READ_WRITE:
            loader->real_mem_map_type_read_write[address] = { real_addr, prot };
            break;
        default:
            break;
        }

        uc_err err = uc_mem_map_ptr(uc_, address, allocSize, prot, real_addr);
        if (err != UC_ERR_OK) {
            Logger::Log(true, ConsoleColor::RED, "Alloc error: %d\n", err);
            loader->real_mem_map.erase(address);
            loader->real_mem_map_type_all.erase(address);
            loader->real_mem_map_type_read.erase(address);
            loader->real_mem_map_type_read_write.erase(address);
            _aligned_free(real_addr);
            LeaveCriticalSection(&loader->cs);
            return 0;
        }

        if (show) {
            Logger::Log(true, ConsoleColor::DARK_YELLOW, "Memory address: %llx size: %llx\n", address, static_cast<uint64_t>(allocSize));
        }

        LeaveCriticalSection(&loader->cs);
        return address;
    }

    uint64_t HeapAlloc(uint64_t size) {
        return HeapAlloc(size, true);
    }

    uint64_t HeapAlloc(uint64_t size, bool show) {
        PEloader* loader = &PEloader::GetInstance();
        while (loader->g_running) {
            if (InterlockedCompareExchange(&loader->g_flag, 1, 0) == 0) {

                DWORD tid = GetCurrentThreadId();
                for (auto& ti : loader->Threads) {
                    if (ti->threadId != tid) {
                        ResetEvent(ti->Event);
                    }
                    else if (ti->threadId == tid) {
                        loader->errorevent = ti->Event;
                        Sleep(100);
                    }
                }

                if (show) {
                    Logger::Log(true, ConsoleColor::RED, "HeapAlloc\n");
                }
                if (loader->lastAlloc == 0) {
                    loader->lastAlloc = PEloader::AllocBase;
                }

                size_t allocSize = static_cast<size_t>(PAGE_ALIGN(size));
                uc_engine* engine = uc_;
                uc_mem_region* region = nullptr;
                uint32_t count = 0;
                uc_mem_regions(engine, &region, &count);
                bool found_gap = false;
                uint64_t alloc_addr = 0;
                if (count > 1) {
                    int start = 0;
                    for (uint32_t i = 0; i < count; i++) {
                        if (region[i].begin == PEloader::AllocBase) {
                            start = static_cast<int>(i);
                            break;
                        }
                    }
                    for (int i = start; i < static_cast<int>(count) - 1; i++) {
                        if (region[i + 1].begin - region[i].end >= allocSize) {
                            alloc_addr = PAGE_ALIGN(region[i].end);
                            found_gap = true;
                            break;
                        }
                    }
                }

                if (!found_gap) {
                    alloc_addr = loader->lastAlloc;
                }

                if (allocSize == 0) {
                    for (auto& ti : loader->Threads) {
                        SetEvent(ti->Event);
                        loader->errorevent = nullptr;
                    }
                    InterlockedExchange(&loader->g_flag, 0);
                    if (region) {
                        uc_free(region);
                    }
                    return 0;
                }

                Logger::Log(true, ConsoleColor::DARK_YELLOW, "Memory address: %llx size: %llx\n", alloc_addr, static_cast<uint64_t>(allocSize));
                bool success = false;
                void* real_addr = _aligned_malloc(allocSize, 0x1000);
                if (!real_addr) {
                    Logger::Log(true, ConsoleColor::RED, "HeapAlloc error: _aligned_malloc failed size: %llx\n", static_cast<uint64_t>(allocSize));
                }
                else {
                    loader->real_mem_map[alloc_addr] = { real_addr, static_cast<uint64_t>(allocSize) };
                    loader->real_mem_map_type_read[alloc_addr] = { real_addr, MUC_PROT_READ };
                    uc_err err = uc_mem_map_ptr(engine, alloc_addr, allocSize, UC_PROT_READ, real_addr);
                    if (err != UC_ERR_OK) {
                        Logger::Log(true, ConsoleColor::RED, "uc_mem_map_ptr failed: %d\n", err);
                        uc_mem_unmap(engine, alloc_addr, allocSize);
                        loader->real_mem_map.erase(alloc_addr);
                        loader->real_mem_map_type_read.erase(alloc_addr);
                        _aligned_free(real_addr);
                        uc_emu_stop(engine);
                    }
                    else {
                        success = true;
                    }
                }

                if (success && !found_gap) {
                    loader->lastAlloc += allocSize;
                }

                for (auto& ti : loader->Threads) {
                    SetEvent(ti->Event);
                    loader->errorevent = nullptr;
                }
                InterlockedExchange(&loader->g_flag, 0);

                if (region) {
                    uc_free(region);
                }
                return success ? alloc_addr : 0;
            }
            Sleep(100);
        }
        return 0;
    }

    void HeapFree(uint64_t addr) {
        PEloader* loader = &PEloader::GetInstance();
        uc_engine* engine = uc_;
        Logger::Log(true, ConsoleColor::RED, "HeapFree: %llx\n", addr);

        auto it = loader->real_mem_map.find(addr);
        if (it != loader->real_mem_map.end()) {
            uc_mem_unmap(engine, it->first, it->second.second);
            _aligned_free(it->second.first);
            loader->real_mem_map.erase(it);
            loader->real_mem_map_type_all.erase(addr);
            loader->real_mem_map_type_read.erase(addr);
            loader->real_mem_map_type_read_write.erase(addr);
        }
    }

    uint64_t AllocVirtPhysPage(uint64_t virtAddr) {
        PEloader* loader = &PEloader::GetInstance();
        EnterCriticalSection(&loader->cs);
        size_t pageSize = 0x1000;
        void* real_addr = _aligned_malloc(pageSize, 0x1000);
        if (!real_addr) {
            LeaveCriticalSection(&loader->cs);
            return 0;
        }

        auto physOpt = loader->kdmp.VirtTranslate(virtAddr);
        if (!physOpt.has_value()) {
            _aligned_free(real_addr);
            LeaveCriticalSection(&loader->cs);
            return 0;
        }
        uint64_t physAddr = physOpt.value();

        loader->real_mem_map[virtAddr] = { real_addr, pageSize };
        loader->real_mem_map[physAddr] = { real_addr, pageSize };

        uc_mem_map_ptr(uc_, virtAddr, pageSize, UC_PROT_ALL, real_addr);
        uc_mem_map_ptr(uc_, physAddr, pageSize, UC_PROT_ALL, real_addr);

        uc_mem_write(uc_, virtAddr, loader->kdmp.GetVirtualPage(virtAddr), pageSize);
        Logger::Log(true, ConsoleColor::DARK_YELLOW, "VirtAddr: %llx PhysAddr: %llx\n", virtAddr, physAddr);

        LeaveCriticalSection(&loader->cs);
        return virtAddr;
    }

    static uint64_t StackAlloc(ULONG AllocBytes) {
        PEloader* loader = &PEloader::GetInstance();
        uint64_t rsp = 0;
        uc_reg_read(loader->uc, UC_X86_REG_RSP, &rsp);
        rsp -= AllocBytes;
        uc_reg_write(loader->uc, UC_X86_REG_RSP, &rsp);
        return rsp;
    }

    static void StackFree(ULONG AllocBytes) {
        PEloader* loader = &PEloader::GetInstance();
        uint64_t rsp = 0;
        uc_reg_read(loader->uc, UC_X86_REG_RSP, &rsp);
        rsp += AllocBytes;
        uc_reg_write(loader->uc, UC_X86_REG_RSP, &rsp);
    }

    uc_err map(uint64_t address, size_t size, int prot = 7) {
        return uc_mem_map(uc_, address, size, prot);
    }

    uc_err unmap(uint64_t address, size_t size) {
        return uc_mem_unmap(uc_, address, size);
    }

    uc_err protect(uint64_t address, size_t size, int prot) {
        return uc_mem_protect(uc_, address, size, prot);
    }

    uc_engine* engine() const {
        return uc_;
    }



    uc_err start(uint64_t begin, uint64_t until, uint64_t timeout = 0, size_t count = 0) {
        return uc_emu_start(uc_, begin, until, timeout, count);
    }

    uc_err stop() {
        return uc_emu_stop(uc_);
    }

    uc_err hook_code(uc_hook* hh, void* callback, void* user_data = nullptr, 
                     uint64_t begin = 1, uint64_t end = 0) {
        return uc_hook_add(uc_, hh, UC_HOOK_CODE, callback, user_data, begin, end);
    }

    uc_err hook_block(uc_hook* hh, void* callback, void* user_data = nullptr, 
                      uint64_t begin = 1, uint64_t end = 0) {
        return uc_hook_add(uc_, hh, UC_HOOK_BLOCK, callback, user_data, begin, end);
    }

    uc_err hook_intr(uc_hook* hh, void* callback, void* user_data = nullptr) {
        return uc_hook_add(uc_, hh, UC_HOOK_INTR, callback, user_data, 1, 0);
    }

    uc_err hook_mem_read(uc_hook* hh, void* callback, void* user_data = nullptr, 
                         uint64_t begin = 1, uint64_t end = 0) {
        return uc_hook_add(uc_, hh, UC_HOOK_MEM_READ, callback, user_data, begin, end);
    }

    uc_err hook_mem_write(uc_hook* hh, void* callback, void* user_data = nullptr, 
                          uint64_t begin = 1, uint64_t end = 0) {
        return uc_hook_add(uc_, hh, UC_HOOK_MEM_WRITE, callback, user_data, begin, end);
    }

    uc_err hook_mem_access(uc_hook* hh, void* callback, void* user_data = nullptr, 
                           uint64_t begin = 1, uint64_t end = 0) {
        return uc_hook_add(uc_, hh, UC_HOOK_MEM_READ | UC_HOOK_MEM_WRITE, callback, user_data, begin, end);
    }

    uc_err hook_mem_fetch(uc_hook* hh, void* callback, void* user_data = nullptr, 
                          uint64_t begin = 1, uint64_t end = 0) {
        return uc_hook_add(uc_, hh, UC_HOOK_MEM_FETCH, callback, user_data, begin, end);
    }

    uc_err hook_mem_invalid(uc_hook* hh, void* callback, void* user_data = nullptr) {
        return uc_hook_add(uc_, hh, UC_HOOK_MEM_UNMAPPED, callback, user_data, 1, 0);
    }

    uc_err hook_mem_read_unmapped(uc_hook* hh, void* callback, void* user_data = nullptr) {
        return uc_hook_add(uc_, hh, UC_HOOK_MEM_READ_UNMAPPED, callback, user_data, 1, 0);
    }

    uc_err hook_mem_write_unmapped(uc_hook* hh, void* callback, void* user_data = nullptr) {
        return uc_hook_add(uc_, hh, UC_HOOK_MEM_WRITE_UNMAPPED, callback, user_data, 1, 0);
    }

    uc_err hook_mem_fetch_unmapped(uc_hook* hh, void* callback, void* user_data = nullptr) {
        return uc_hook_add(uc_, hh, UC_HOOK_MEM_FETCH_UNMAPPED, callback, user_data, 1, 0);
    }

    uc_err hook_mem_prot(uc_hook* hh, void* callback, void* user_data = nullptr) {
        return uc_hook_add(uc_, hh, UC_HOOK_MEM_PROT, callback, user_data, 1, 0);
    }

    uc_err hook_mem_read_prot(uc_hook* hh, void* callback, void* user_data = nullptr) {
        return uc_hook_add(uc_, hh, UC_HOOK_MEM_READ_PROT, callback, user_data, 1, 0);
    }

    uc_err hook_mem_write_prot(uc_hook* hh, void* callback, void* user_data = nullptr) {
        return uc_hook_add(uc_, hh, UC_HOOK_MEM_WRITE_PROT, callback, user_data, 1, 0);
    }

    uc_err hook_mem_fetch_prot(uc_hook* hh, void* callback, void* user_data = nullptr) {
        return uc_hook_add(uc_, hh, UC_HOOK_MEM_FETCH_PROT, callback, user_data, 1, 0);
    }

    uc_err hook_insn_invalid(uc_hook* hh, void* callback, void* user_data = nullptr) {
        return uc_hook_add(uc_, hh, UC_HOOK_INSN_INVALID, callback, user_data, 1, 0);
    }

    uc_err hook_edge_generated(uc_hook* hh, void* callback, void* user_data = nullptr) {
        return uc_hook_add(uc_, hh, UC_HOOK_EDGE_GENERATED, callback, user_data, 1, 0);
    }

    uc_err hook_tcg_opcode(uc_hook* hh, void* callback, void* user_data = nullptr, int opcode = 0) {
        return uc_hook_add(uc_, hh, UC_HOOK_TCG_OPCODE, callback, user_data, 1, 0, opcode);
    }

    uc_err hook_add(uc_hook* hh, int type, void* callback, void* user_data = nullptr, 
                    uint64_t begin = 1, uint64_t end = 0) {
        return uc_hook_add(uc_, hh, type, callback, user_data, begin, end);
    }

    uc_err hook_del(uc_hook hh) {
        return uc_hook_del(uc_, hh);
    }

    uc_err context_alloc(uc_context** context) {
        return uc_context_alloc(uc_, context);
    }

    uc_err context_save(uc_context* context) {
        return uc_context_save(uc_, context);
    }

    uc_err context_restore(uc_context* context) {
        return uc_context_restore(uc_, context);
    }

    uc_err context_free(uc_context* context) {
        return uc_context_free(context);
    }

    uc_err ctl(uc_control_type control, ...) {
        va_list args;
        va_start(args, control);
        uc_err result = uc_ctl(uc_, control, args);
        va_end(args);
        return result;
    }

    uc_err tlb_flush() {
        return uc_ctl(uc_, UC_CTL_TLB_FLUSH, NULL);
    }

    uc_err set_cpu_model(int model) {
        return uc_ctl_set_cpu_model(uc_, model);
    }

    uc_err set_tlb_mode(int mode) {
        return uc_ctl_tlb_mode(uc_, mode);
    }

    uc_err set_page_size(uint32_t page_size) {
        return uc_ctl(uc_, UC_CTL_UC_PAGE_SIZE, page_size);
    }

    uc_err mem_regions(uc_mem_region** regions, uint32_t* count) {
        return uc_mem_regions(uc_, regions, count);
    }

    static uint32_t version(uint32_t* major = nullptr, uint32_t* minor = nullptr) {
        return uc_version(major, minor);
    }

    static bool arch_supported(uc_arch arch) {
        return uc_arch_supported(arch);
    }

    static const char* strerror(uc_err code) {
        return uc_strerror(code);
    }

    uc_err errno_func() {
        return uc_errno(uc_);
    }

    UnicornEmu& msr_write(uint32_t msr_id, uint64_t value) {
        uc_x86_msr msr = { msr_id, value };
        uc_reg_write(uc_, UC_X86_REG_MSR, &msr);
        return *this;
    }

    uint64_t msr_read(uint32_t msr_id) {
        uc_x86_msr msr = { msr_id, 0 };
        uc_reg_read(uc_, UC_X86_REG_MSR, &msr);
        return msr.value;
    }

    uc_err reg_write_batch(int* regs, void** vals, int count) {
        return uc_reg_write_batch(uc_, regs, vals, count);
    }

    uc_err reg_read_batch(int* regs, void** vals, int count) {
        return uc_reg_read_batch(uc_, regs, vals, count);
    }

    uc_err mem_map_ptr(uint64_t address, size_t size, int prot, void* ptr) {
        return uc_mem_map_ptr(uc_, address, size, prot, ptr);
    }

    uc_err free(void* mem) {
        return uc_free(mem);
    }

    UnicornEmu& eax(uint32_t value) {
        uc_reg_write(uc_, UC_X86_REG_EAX, &value);
        return *this;
    }
    
    uint32_t eax() const {
        uint32_t value;
        uc_reg_read(uc_, UC_X86_REG_EAX, &value);
        return value;
    }

    UnicornEmu& ebx(uint32_t value) {
        uc_reg_write(uc_, UC_X86_REG_EBX, &value);
        return *this;
    }
    
    uint32_t ebx() const {
        uint32_t value;
        uc_reg_read(uc_, UC_X86_REG_EBX, &value);
        return value;
    }

    UnicornEmu& ecx(uint32_t value) {
        uc_reg_write(uc_, UC_X86_REG_ECX, &value);
        return *this;
    }
    
    uint32_t ecx() const {
        uint32_t value;
        uc_reg_read(uc_, UC_X86_REG_ECX, &value);
        return value;
    }

    UnicornEmu& edx(uint32_t value) {
        uc_reg_write(uc_, UC_X86_REG_EDX, &value);
        return *this;
    }
    
    uint32_t edx() const {
        uint32_t value;
        uc_reg_read(uc_, UC_X86_REG_EDX, &value);
        return value;
    }

    UnicornEmu& esp(uint32_t value) {
        uc_reg_write(uc_, UC_X86_REG_ESP, &value);
        return *this;
    }
    
    uint32_t esp() const {
        uint32_t value;
        uc_reg_read(uc_, UC_X86_REG_ESP, &value);
        return value;
    }

    UnicornEmu& ebp(uint32_t value) {
        uc_reg_write(uc_, UC_X86_REG_EBP, &value);
        return *this;
    }
    
    uint32_t ebp() const {
        uint32_t value;
        uc_reg_read(uc_, UC_X86_REG_EBP, &value);
        return value;
    }

    UnicornEmu& esi(uint32_t value) {
        uc_reg_write(uc_, UC_X86_REG_ESI, &value);
        return *this;
    }
    
    uint32_t esi() const {
        uint32_t value;
        uc_reg_read(uc_, UC_X86_REG_ESI, &value);
        return value;
    }

    UnicornEmu& edi(uint32_t value) {
        uc_reg_write(uc_, UC_X86_REG_EDI, &value);
        return *this;
    }
    
    uint32_t edi() const {
        uint32_t value;
        uc_reg_read(uc_, UC_X86_REG_EDI, &value);
        return value;
    }

    UnicornEmu& xmm(int reg_num, const uint8_t value[16]) {
        int reg_id = UC_X86_REG_XMM0 + reg_num;
        uc_reg_write(uc_, reg_id, value);
        return *this;
    }

    void xmm(int reg_num, uint8_t value[16]) const {
        int reg_id = UC_X86_REG_XMM0 + reg_num;
        uc_reg_read(uc_, reg_id, value);
    }

    UnicornEmu& dr(int reg_num, uint64_t value) {
        int reg_id = UC_X86_REG_DR0 + reg_num;
        uc_reg_write(uc_, reg_id, &value);
        return *this;
    }

    uint64_t dr(int reg_num) const {
        uint64_t value;
        int reg_id = UC_X86_REG_DR0 + reg_num;
        uc_reg_read(uc_, reg_id, &value);
        return value;
    }

    UnicornEmu& gdtr(uint64_t base, uint32_t limit) {
        uc_x86_mmr mmr = { base, limit, 0, 0 };
        uc_reg_write(uc_, UC_X86_REG_GDTR, &mmr);
        return *this;
    }

    void gdtr(uint64_t* base, uint32_t* limit) const {
        uc_x86_mmr mmr;
        uc_reg_read(uc_, UC_X86_REG_GDTR, &mmr);
        if (base) *base = mmr.base;
        if (limit) *limit = mmr.limit;
    }

    UnicornEmu& idtr(uint64_t base, uint32_t limit) {
        uc_x86_mmr mmr = { base, limit, 0, 0 };
        uc_reg_write(uc_, UC_X86_REG_IDTR, &mmr);
        return *this;
    }

    void idtr(uint64_t* base, uint32_t* limit) const {
        uc_x86_mmr mmr;
        uc_reg_read(uc_, UC_X86_REG_IDTR, &mmr);
        if (base) *base = mmr.base;
        if (limit) *limit = mmr.limit;
    }

    UnicornEmu& tr(uint64_t value) {
        uc_reg_write(uc_, UC_X86_REG_TR, &value);
        return *this;
    }
    
    uint64_t tr() const {
        uint64_t value;
        uc_reg_read(uc_, UC_X86_REG_TR, &value);
        return value;
    }

    UnicornEmu& ldtr(uint64_t value) {
        uc_reg_write(uc_, UC_X86_REG_LDTR, &value);
        return *this;
    }
    
    uint64_t ldtr() const {
        uint64_t value;
        uc_reg_read(uc_, UC_X86_REG_LDTR, &value);
        return value;
    }

    static uc_err open(uc_engine** uc) {
        return uc_open(UC_ARCH_X86, UC_MODE_64, uc);
    }

    static uc_err close(uc_engine* uc) {
        return uc_close(uc);
    }
};

class EmuWrapper {
private:
    UnicornEmu emu;

public:
    explicit EmuWrapper(uc_engine* uc) : emu(uc) {}
    
    UnicornEmu* operator->() {
        return &emu;
    }
    
    const UnicornEmu* operator->() const {
        return &emu;
    }
};

inline EmuWrapper Emu(uc_engine* uc) {
    return EmuWrapper(uc);
}
```

`KDemu/cpu.h`:

```h
#pragma once

/* segment descriptor fields */
#define DESC_G_SHIFT    23
#define DESC_G_MASK     (1 << DESC_G_SHIFT)
#define DESC_B_SHIFT    22
#define DESC_B_MASK     (1 << DESC_B_SHIFT)
#define DESC_L_SHIFT    21 /* x86_64 only : 64 bit code segment */
#define DESC_L_MASK     (1 << DESC_L_SHIFT)
#define DESC_AVL_SHIFT  20
#define DESC_AVL_MASK   (1 << DESC_AVL_SHIFT)
#define DESC_P_SHIFT    15
#define DESC_P_MASK     (1 << DESC_P_SHIFT)
#define DESC_DPL_SHIFT  13
#define DESC_DPL_MASK   (3 << DESC_DPL_SHIFT)
#define DESC_S_SHIFT    12
#define DESC_S_MASK     (1 << DESC_S_SHIFT)
#define DESC_TYPE_SHIFT 8
#define DESC_TYPE_MASK  (15 << DESC_TYPE_SHIFT)
#define DESC_A_MASK     (1 << 8)

#define DESC_CS_MASK    (1 << 11) /* 1=code segment 0=data segment */
#define DESC_C_MASK     (1 << 10) /* code: conforming */
#define DESC_R_MASK     (1 << 9)  /* code: readable */

#define DESC_E_MASK     (1 << 10) /* data: expansion direction */
#define DESC_W_MASK     (1 << 9)  /* data: writable */

#define DESC_TSS_BUSY_MASK (1 << 9)

/* eflags masks */
#define CC_C    0x0001
#define CC_P    0x0004
#define CC_A    0x0010
#define CC_Z    0x0040
#define CC_S    0x0080
#define CC_O    0x0800

#define TF_SHIFT   8
#define IOPL_SHIFT 12
#define VM_SHIFT   17

#define TF_MASK                 0x00000100
#define IF_MASK                 0x00000200
#define DF_MASK                 0x00000400
#define IOPL_MASK               0x00003000
#define NT_MASK                 0x00004000
#define RF_MASK                 0x00010000
#define VM_MASK                 0x00020000
#define AC_MASK                 0x00040000
#define VIF_MASK                0x00080000
#define VIP_MASK                0x00100000
#define ID_MASK                 0x00200000

/* hidden flags - used internally by qemu to represent additional cpu
   states. Only the INHIBIT_IRQ, SMM and SVMI are not redundant. We
   avoid using the IOPL_MASK, TF_MASK, VM_MASK and AC_MASK bit
   positions to ease oring with eflags. */
   /* current cpl */
#define HF_CPL_SHIFT         0
/* true if hardware interrupts must be disabled for next instruction */
#define HF_INHIBIT_IRQ_SHIFT 3
/* 16 or 32 segments */
#define HF_CS32_SHIFT        4
#define HF_SS32_SHIFT        5
/* zero base for DS, ES and SS : can be '0' only in 32 bit CS segment */
#define HF_ADDSEG_SHIFT      6
/* copy of CR0.PE (protected mode) */
#define HF_PE_SHIFT          7
#define HF_TF_SHIFT          8 /* must be same as eflags */
#define HF_MP_SHIFT          9 /* the order must be MP, EM, TS */
#define HF_EM_SHIFT         10
#define HF_TS_SHIFT         11
#define HF_IOPL_SHIFT       12 /* must be same as eflags */
#define HF_LMA_SHIFT        14 /* only used on x86_64: long mode active */
#define HF_CS64_SHIFT       15 /* only used on x86_64: 64 bit code segment  */
#define HF_RF_SHIFT         16 /* must be same as eflags */
#define HF_VM_SHIFT         17 /* must be same as eflags */
#define HF_AC_SHIFT         18 /* must be same as eflags */
#define HF_SMM_SHIFT        19 /* CPU in SMM mode */
#define HF_SVME_SHIFT       20 /* SVME enabled (copy of EFER.SVME) */
#define HF_GUEST_SHIFT      21 /* SVM intercepts are active */
#define HF_OSFXSR_SHIFT     22 /* CR4.OSFXSR */
#define HF_SMAP_SHIFT       23 /* CR4.SMAP */
#define HF_IOBPT_SHIFT      24 /* an io breakpoint enabled */
#define HF_MPX_EN_SHIFT     25 /* MPX Enabled (CR4+XCR0+BNDCFGx) */
#define HF_MPX_IU_SHIFT     26 /* BND registers in-use */

#define HF_CPL_MASK          (3 << HF_CPL_SHIFT)
#define HF_INHIBIT_IRQ_MASK  (1 << HF_INHIBIT_IRQ_SHIFT)
#define HF_CS32_MASK         (1 << HF_CS32_SHIFT)
#define HF_SS32_MASK         (1 << HF_SS32_SHIFT)
#define HF_ADDSEG_MASK       (1 << HF_ADDSEG_SHIFT)
#define HF_PE_MASK           (1 << HF_PE_SHIFT)
#define HF_TF_MASK           (1 << HF_TF_SHIFT)
#define HF_MP_MASK           (1 << HF_MP_SHIFT)
#define HF_EM_MASK           (1 << HF_EM_SHIFT)
#define HF_TS_MASK           (1 << HF_TS_SHIFT)
#define HF_IOPL_MASK         (3 << HF_IOPL_SHIFT)
#define HF_LMA_MASK          (1 << HF_LMA_SHIFT)
#define HF_CS64_MASK         (1 << HF_CS64_SHIFT)
#define HF_RF_MASK           (1 << HF_RF_SHIFT)
#define HF_VM_MASK           (1 << HF_VM_SHIFT)
#define HF_AC_MASK           (1 << HF_AC_SHIFT)
#define HF_SMM_MASK          (1 << HF_SMM_SHIFT)
#define HF_SVME_MASK         (1 << HF_SVME_SHIFT)
#define HF_GUEST_MASK        (1 << HF_GUEST_SHIFT)
#define HF_OSFXSR_MASK       (1 << HF_OSFXSR_SHIFT)
#define HF_SMAP_MASK         (1 << HF_SMAP_SHIFT)
#define HF_IOBPT_MASK        (1 << HF_IOBPT_SHIFT)
#define HF_MPX_EN_MASK       (1 << HF_MPX_EN_SHIFT)
#define HF_MPX_IU_MASK       (1 << HF_MPX_IU_SHIFT)

/* hflags2 */

#define HF2_GIF_SHIFT            0 /* if set CPU takes interrupts */
#define HF2_HIF_SHIFT            1 /* value of IF_MASK when entering SVM */
#define HF2_NMI_SHIFT            2 /* CPU serving NMI */
#define HF2_VINTR_SHIFT          3 /* value of V_INTR_MASKING bit */
#define HF2_SMM_INSIDE_NMI_SHIFT 4 /* CPU serving SMI nested inside NMI */
#define HF2_MPX_PR_SHIFT         5 /* BNDCFGx.BNDPRESERVE */
#define HF2_NPT_SHIFT            6 /* Nested Paging enabled */
#define HF2_IGNNE_SHIFT          7 /* Ignore CR0.NE=0 */

#define HF2_GIF_MASK            (1 << HF2_GIF_SHIFT)
#define HF2_HIF_MASK            (1 << HF2_HIF_SHIFT)
#define HF2_NMI_MASK            (1 << HF2_NMI_SHIFT)
#define HF2_VINTR_MASK          (1 << HF2_VINTR_SHIFT)
#define HF2_SMM_INSIDE_NMI_MASK (1 << HF2_SMM_INSIDE_NMI_SHIFT)
#define HF2_MPX_PR_MASK         (1 << HF2_MPX_PR_SHIFT)
#define HF2_NPT_MASK            (1 << HF2_NPT_SHIFT)
#define HF2_IGNNE_MASK          (1 << HF2_IGNNE_SHIFT)

#define CR0_PE_SHIFT 0
#define CR0_MP_SHIFT 1

#define CR0_PE_MASK  (1U << 0)
#define CR0_MP_MASK  (1U << 1)
#define CR0_EM_MASK  (1U << 2)
#define CR0_TS_MASK  (1U << 3)
#define CR0_ET_MASK  (1U << 4)
#define CR0_NE_MASK  (1U << 5)
#define CR0_WP_MASK  (1U << 16)
#define CR0_AM_MASK  (1U << 18)
#define CR0_PG_MASK  (1U << 31)

#define CR4_VME_MASK  (1U << 0)
#define CR4_PVI_MASK  (1U << 1)
#define CR4_TSD_MASK  (1U << 2)
#define CR4_DE_MASK   (1U << 3)
#define CR4_PSE_MASK  (1U << 4)
#define CR4_PAE_MASK  (1U << 5)
#define CR4_MCE_MASK  (1U << 6)
#define CR4_PGE_MASK  (1U << 7)
#define CR4_PCE_MASK  (1U << 8)
#define CR4_OSFXSR_SHIFT 9
#define CR4_OSFXSR_MASK (1U << CR4_OSFXSR_SHIFT)
#define CR4_OSXMMEXCPT_MASK  (1U << 10)
#define CR4_LA57_MASK   (1U << 12)
#define CR4_VMXE_MASK   (1U << 13)
#define CR4_SMXE_MASK   (1U << 14)
#define CR4_FSGSBASE_MASK (1U << 16)
#define CR4_PCIDE_MASK  (1U << 17)
#define CR4_OSXSAVE_MASK (1U << 18)
#define CR4_SMEP_MASK   (1U << 20)
#define CR4_SMAP_MASK   (1U << 21)
#define CR4_PKE_MASK   (1U << 22)

#define DR6_BD          (1 << 13)
#define DR6_BS          (1 << 14)
#define DR6_BT          (1 << 15)
#define DR6_FIXED_1     0xffff0ff0

#define DR7_GD          (1 << 13)
#define DR7_TYPE_SHIFT  16
#define DR7_LEN_SHIFT   18
#define DR7_FIXED_1     0x00000400
#define DR7_GLOBAL_BP_MASK   0xaa
#define DR7_LOCAL_BP_MASK    0x55
#define DR7_MAX_BP           4
#define DR7_TYPE_BP_INST     0x0
#define DR7_TYPE_DATA_WR     0x1
#define DR7_TYPE_IO_RW       0x2
#define DR7_TYPE_DATA_RW     0x3

#define PG_PRESENT_BIT  0
#define PG_RW_BIT       1
#define PG_USER_BIT     2
#define PG_PWT_BIT      3
#define PG_PCD_BIT      4
#define PG_ACCESSED_BIT 5
#define PG_DIRTY_BIT    6
#define PG_PSE_BIT      7
#define PG_GLOBAL_BIT   8
#define PG_PSE_PAT_BIT  12
#define PG_PKRU_BIT     59
#define PG_NX_BIT       63

#define PG_PRESENT_MASK  (1 << PG_PRESENT_BIT)
#define PG_RW_MASK       (1 << PG_RW_BIT)
#define PG_USER_MASK     (1 << PG_USER_BIT)
#define PG_PWT_MASK      (1 << PG_PWT_BIT)
#define PG_PCD_MASK      (1 << PG_PCD_BIT)
#define PG_ACCESSED_MASK (1 << PG_ACCESSED_BIT)
#define PG_DIRTY_MASK    (1 << PG_DIRTY_BIT)
#define PG_PSE_MASK      (1 << PG_PSE_BIT)
#define PG_GLOBAL_MASK   (1 << PG_GLOBAL_BIT)
#define PG_PSE_PAT_MASK  (1 << PG_PSE_PAT_BIT)
#define PG_ADDRESS_MASK  0x000ffffffffff000LL
#define PG_HI_RSVD_MASK  (PG_ADDRESS_MASK & ~PHYS_ADDR_MASK)
#define PG_HI_USER_MASK  0x7ff0000000000000LL
#define PG_PKRU_MASK     (15ULL << PG_PKRU_BIT)
#define PG_NX_MASK       (1ULL << PG_NX_BIT)

#define PG_ERROR_W_BIT     1

#define PG_ERROR_P_MASK    0x01
#define PG_ERROR_W_MASK    (1 << PG_ERROR_W_BIT)
#define PG_ERROR_U_MASK    0x04
#define PG_ERROR_RSVD_MASK 0x08
#define PG_ERROR_I_D_MASK  0x10
#define PG_ERROR_PK_MASK   0x20

#define MCG_CTL_P       (1ULL<<8)   /* MCG_CAP register available */
#define MCG_SER_P       (1ULL<<24) /* MCA recovery/new status bits */
#define MCG_LMCE_P      (1ULL<<27) /* Local Machine Check Supported */

#define MCE_CAP_DEF     (MCG_CTL_P|MCG_SER_P)
#define MCE_BANKS_DEF   10

#define MCG_CAP_BANKS_MASK 0xff

#define MCG_STATUS_RIPV (1ULL<<0)   /* restart ip valid */
#define MCG_STATUS_EIPV (1ULL<<1)   /* ip points to correct instruction */
#define MCG_STATUS_MCIP (1ULL<<2)   /* machine check in progress */
#define MCG_STATUS_LMCE (1ULL<<3)   /* Local MCE signaled */

#define MCG_EXT_CTL_LMCE_EN (1ULL<<0) /* Local MCE enabled */

#define MCI_STATUS_VAL   (1ULL<<63)  /* valid error */
#define MCI_STATUS_OVER  (1ULL<<62)  /* previous errors lost */
#define MCI_STATUS_UC    (1ULL<<61)  /* uncorrected error */
#define MCI_STATUS_EN    (1ULL<<60)  /* error enabled */
#define MCI_STATUS_MISCV (1ULL<<59)  /* misc error reg. valid */
#define MCI_STATUS_ADDRV (1ULL<<58)  /* addr reg. valid */
#define MCI_STATUS_PCC   (1ULL<<57)  /* processor context corrupt */
#define MCI_STATUS_S     (1ULL<<56)  /* Signaled machine check */
#define MCI_STATUS_AR    (1ULL<<55)  /* Action required */

/* MISC register defines */
#define MCM_ADDR_SEGOFF  0      /* segment offset */
#define MCM_ADDR_LINEAR  1      /* linear address */
#define MCM_ADDR_PHYS    2      /* physical address */
#define MCM_ADDR_MEM     3      /* memory address */
#define MCM_ADDR_GENERIC 7      /* generic */

#define MSR_IA32_TSC                    0x10
#define MSR_IA32_APICBASE               0x1b
#define MSR_IA32_APICBASE_BSP           (1<<8)
#define MSR_IA32_APICBASE_ENABLE        (1<<11)
#define MSR_IA32_APICBASE_EXTD          (1 << 10)
#define MSR_IA32_APICBASE_BASE          (0xfffffU<<12)
#define MSR_IA32_FEATURE_CONTROL        0x0000003a
#define MSR_TSC_ADJUST                  0x0000003b
#define MSR_IA32_SPEC_CTRL              0x48
#define MSR_VIRT_SSBD                   0xc001011f
#define MSR_IA32_PRED_CMD               0x49
#define MSR_IA32_UCODE_REV              0x8b
#define MSR_IA32_CORE_CAPABILITY        0xcf

#define MSR_IA32_ARCH_CAPABILITIES      0x10a
#define ARCH_CAP_TSX_CTRL_MSR		(1<<7)

#define MSR_IA32_TSX_CTRL		0x122
#define MSR_IA32_TSCDEADLINE            0x6e0

#define FEATURE_CONTROL_LOCKED                    (1<<0)
#define FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX (1<<2)
#define FEATURE_CONTROL_LMCE                      (1<<20)

#define MSR_P6_PERFCTR0                 0xc1

#define MSR_IA32_SMBASE                 0x9e
#define MSR_SMI_COUNT                   0x34
#define MSR_MTRRcap                     0xfe
#define MSR_MTRRcap_VCNT                8
#define MSR_MTRRcap_FIXRANGE_SUPPORT    (1 << 8)
#define MSR_MTRRcap_WC_SUPPORTED        (1 << 10)

#define MSR_IA32_SYSENTER_CS            0x174
#define MSR_IA32_SYSENTER_ESP           0x175
#define MSR_IA32_SYSENTER_EIP           0x176

#define MSR_MCG_CAP                     0x179
#define MSR_MCG_STATUS                  0x17a
#define MSR_MCG_CTL                     0x17b
#define MSR_MCG_EXT_CTL                 0x4d0

#define MSR_P6_EVNTSEL0                 0x186

#define MSR_IA32_PERF_STATUS            0x198

#define MSR_IA32_MISC_ENABLE            0x1a0
/* Indicates good rep/movs microcode on some processors: */
#define MSR_IA32_MISC_ENABLE_DEFAULT    1
#define MSR_IA32_MISC_ENABLE_MWAIT      (1ULL << 18)

#define MSR_MTRRphysBase(reg)           (0x200 + 2 * (reg))
#define MSR_MTRRphysMask(reg)           (0x200 + 2 * (reg) + 1)

#define MSR_MTRRphysIndex(addr)         ((((addr) & ~1u) - 0x200) / 2)

#define MSR_MTRRfix64K_00000            0x250
#define MSR_MTRRfix16K_80000            0x258
#define MSR_MTRRfix16K_A0000            0x259
#define MSR_MTRRfix4K_C0000             0x268
#define MSR_MTRRfix4K_C8000             0x269
#define MSR_MTRRfix4K_D0000             0x26a
#define MSR_MTRRfix4K_D8000             0x26b
#define MSR_MTRRfix4K_E0000             0x26c
#define MSR_MTRRfix4K_E8000             0x26d
#define MSR_MTRRfix4K_F0000             0x26e
#define MSR_MTRRfix4K_F8000             0x26f

#define MSR_PAT                         0x277

#define MSR_MTRRdefType                 0x2ff

#define MSR_CORE_PERF_FIXED_CTR0        0x309
#define MSR_CORE_PERF_FIXED_CTR1        0x30a
#define MSR_CORE_PERF_FIXED_CTR2        0x30b
#define MSR_CORE_PERF_FIXED_CTR_CTRL    0x38d
#define MSR_CORE_PERF_GLOBAL_STATUS     0x38e
#define MSR_CORE_PERF_GLOBAL_CTRL       0x38f
#define MSR_CORE_PERF_GLOBAL_OVF_CTRL   0x390

#define MSR_MC0_CTL                     0x400
#define MSR_MC0_STATUS                  0x401
#define MSR_MC0_ADDR                    0x402
#define MSR_MC0_MISC                    0x403

#define MSR_IA32_RTIT_OUTPUT_BASE       0x560
#define MSR_IA32_RTIT_OUTPUT_MASK       0x561
#define MSR_IA32_RTIT_CTL               0x570
#define MSR_IA32_RTIT_STATUS            0x571
#define MSR_IA32_RTIT_CR3_MATCH         0x572
#define MSR_IA32_RTIT_ADDR0_A           0x580
#define MSR_IA32_RTIT_ADDR0_B           0x581
#define MSR_IA32_RTIT_ADDR1_A           0x582
#define MSR_IA32_RTIT_ADDR1_B           0x583
#define MSR_IA32_RTIT_ADDR2_A           0x584
#define MSR_IA32_RTIT_ADDR2_B           0x585
#define MSR_IA32_RTIT_ADDR3_A           0x586
#define MSR_IA32_RTIT_ADDR3_B           0x587
#define MAX_RTIT_ADDRS                  8

#define MSR_EFER                        0xc0000080

#define MSR_EFER_SCE   (1 << 0)
#define MSR_EFER_LME   (1 << 8)
#define MSR_EFER_LMA   (1 << 10)
#define MSR_EFER_NXE   (1 << 11)
#define MSR_EFER_SVME  (1 << 12)
#define MSR_EFER_FFXSR (1 << 14)

#define MSR_STAR                        0xc0000081
#define MSR_LSTAR                       0xc0000082
#define MSR_CSTAR                       0xc0000083
#define MSR_FMASK                       0xc0000084
#define MSR_FSBASE                      0xc0000100
#define MSR_GSBASE                      0xc0000101
#define MSR_KERNELGSBASE                0xc0000102
#define MSR_TSC_AUX                     0xc0000103

#define MSR_VM_HSAVE_PA                 0xc0010117

#define MSR_IA32_BNDCFGS                0x00000d90
#define MSR_IA32_XSS                    0x00000da0
#define MSR_IA32_UMWAIT_CONTROL         0xe1

#define MSR_IA32_VMX_BASIC              0x00000480
#define MSR_IA32_VMX_PINBASED_CTLS      0x00000481
#define MSR_IA32_VMX_PROCBASED_CTLS     0x00000482
#define MSR_IA32_VMX_EXIT_CTLS          0x00000483
#define MSR_IA32_VMX_ENTRY_CTLS         0x00000484
#define MSR_IA32_VMX_MISC               0x00000485
#define MSR_IA32_VMX_CR0_FIXED0         0x00000486
#define MSR_IA32_VMX_CR0_FIXED1         0x00000487
#define MSR_IA32_VMX_CR4_FIXED0         0x00000488
#define MSR_IA32_VMX_CR4_FIXED1         0x00000489
#define MSR_IA32_VMX_VMCS_ENUM          0x0000048a
#define MSR_IA32_VMX_PROCBASED_CTLS2    0x0000048b
#define MSR_IA32_VMX_EPT_VPID_CAP       0x0000048c
#define MSR_IA32_VMX_TRUE_PINBASED_CTLS  0x0000048d
#define MSR_IA32_VMX_TRUE_PROCBASED_CTLS 0x0000048e
#define MSR_IA32_VMX_TRUE_EXIT_CTLS      0x0000048f
#define MSR_IA32_VMX_TRUE_ENTRY_CTLS     0x00000490
#define MSR_IA32_VMX_VMFUNC             0x00000491

#define XSTATE_FP_BIT                   0
#define XSTATE_SSE_BIT                  1
#define XSTATE_YMM_BIT                  2
#define XSTATE_BNDREGS_BIT              3
#define XSTATE_BNDCSR_BIT               4
#define XSTATE_OPMASK_BIT               5
#define XSTATE_ZMM_Hi256_BIT            6
#define XSTATE_Hi16_ZMM_BIT             7
#define XSTATE_PKRU_BIT                 9

#define XSTATE_FP_MASK                  (1ULL << XSTATE_FP_BIT)
#define XSTATE_SSE_MASK                 (1ULL << XSTATE_SSE_BIT)
#define XSTATE_YMM_MASK                 (1ULL << XSTATE_YMM_BIT)
#define XSTATE_BNDREGS_MASK             (1ULL << XSTATE_BNDREGS_BIT)
#define XSTATE_BNDCSR_MASK              (1ULL << XSTATE_BNDCSR_BIT)
#define XSTATE_OPMASK_MASK              (1ULL << XSTATE_OPMASK_BIT)
#define XSTATE_ZMM_Hi256_MASK           (1ULL << XSTATE_ZMM_Hi256_BIT)
#define XSTATE_Hi16_ZMM_MASK            (1ULL << XSTATE_Hi16_ZMM_BIT)
#define XSTATE_PKRU_MASK                (1ULL << XSTATE_PKRU_BIT)
```

`KDemu/include/LIEF/LIEF/ART.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ART_H
#define LIEF_ART_H

#include "LIEF/config.h"

#if defined(LIEF_ART_SUPPORT)
#include "LIEF/ART/Parser.hpp"
#include "LIEF/ART/utils.hpp"
#include "LIEF/ART/File.hpp"
#include "LIEF/ART/EnumToString.hpp"
#endif

#endif

```

`KDemu/include/LIEF/LIEF/ART/EnumToString.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ART_ENUM_TO_STRING_H
#define LIEF_ART_ENUM_TO_STRING_H
#include "LIEF/visibility.h"
#include "LIEF/ART/enums.hpp"

namespace LIEF {
namespace ART {

LIEF_API const char* to_string(STORAGE_MODES e);

LIEF_API const char* to_string(ART_17::IMAGE_SECTIONS e);
LIEF_API const char* to_string(ART_29::IMAGE_SECTIONS e);
LIEF_API const char* to_string(ART_30::IMAGE_SECTIONS e);

LIEF_API const char* to_string(ART_17::IMAGE_METHODS e);
LIEF_API const char* to_string(ART_44::IMAGE_METHODS e);

LIEF_API const char* to_string(ART_17::IMAGE_ROOTS e);
LIEF_API const char* to_string(ART_44::IMAGE_ROOTS e);

} // namespace ART
} // namespace LIEF

#endif


```

`KDemu/include/LIEF/LIEF/ART/File.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ART_FILE_H
#define LIEF_ART_FILE_H
#include <ostream>

#include "LIEF/ART/Header.hpp"

#include "LIEF/visibility.h"
#include "LIEF/Object.hpp"

namespace LIEF {
namespace ART {
class Parser;

class LIEF_API File : public Object {
  friend class Parser;

  public:
  File& operator=(const File& copy) = delete;
  File(const File& copy)            = delete;

  const Header& header() const;
  Header& header();

  void accept(Visitor& visitor) const override;


  ~File() override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const File& art_file);

  private:
  File();

  Header header_;
};

}
}

#endif

```

`KDemu/include/LIEF/LIEF/ART/Header.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ART_HEADER_H
#define LIEF_ART_HEADER_H

#include <array>
#include <cstdint>

#include "LIEF/ART/types.hpp"
#include "LIEF/ART/enums.hpp"

#include "LIEF/visibility.h"
#include "LIEF/Object.hpp"

namespace LIEF {
namespace ART {
class Parser;

class LIEF_API Header : public Object {
  friend class Parser;

  public:
  using magic_t = std::array<uint8_t, 4>;

  Header();

  template<class T>
  LIEF_LOCAL Header(const T* header);

  Header(const Header&);
  Header& operator=(const Header&);

  magic_t magic() const;
  art_version_t version() const;

  uint32_t image_begin() const;
  uint32_t image_size() const;

  uint32_t oat_checksum() const;

  uint32_t oat_file_begin() const;
  uint32_t oat_file_end() const;

  uint32_t oat_data_begin() const;
  uint32_t oat_data_end() const;

  int32_t patch_delta() const;

  uint32_t image_roots() const;

  uint32_t pointer_size() const;
  bool compile_pic() const;

  uint32_t nb_sections() const;
  uint32_t nb_methods() const;

  uint32_t boot_image_begin() const;
  uint32_t boot_image_size() const;

  uint32_t boot_oat_begin() const;
  uint32_t boot_oat_size() const;

  STORAGE_MODES storage_mode() const;

  uint32_t data_size() const;

  void accept(Visitor& visitor) const override;


  LIEF_API friend std::ostream& operator<<(std::ostream& os, const Header& hdr);

  ~Header() override;

  private:
  magic_t       magic_;
  art_version_t version_;

  uint32_t image_begin_;
  uint32_t image_size_;

  uint32_t oat_checksum_;

  uint32_t oat_file_begin_;
  uint32_t oat_file_end_;

  uint32_t oat_data_begin_;
  uint32_t oat_data_end_;

  int32_t patch_delta_;
  uint32_t image_roots_;

  uint32_t pointer_size_;

  bool compile_pic_;

  uint32_t nb_sections_;
  uint32_t nb_methods_;

  bool is_pic_;

  // From ART 29
  // ===========
  uint32_t boot_image_begin_;
  uint32_t boot_image_size_;

  uint32_t boot_oat_begin_;
  uint32_t boot_oat_size_;

  STORAGE_MODES storage_mode_;

  uint32_t data_size_;
};

} // Namespace ART
} // Namespace LIEF

#endif

```

`KDemu/include/LIEF/LIEF/ART/Parser.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ART_PARSER_H
#define LIEF_ART_PARSER_H
#include <memory>
#include <vector>

#include "LIEF/ART/types.hpp"
#include "LIEF/visibility.h"

namespace LIEF {
class BinaryStream;
namespace ART {
class File;


//! @brief Class which parses an ART file and transform into a ART::File object
class LIEF_API Parser {
  public:
  static std::unique_ptr<File> parse(const std::string& file);
  static std::unique_ptr<File> parse(std::vector<uint8_t> data, const std::string& name = "");

  Parser& operator=(const Parser& copy) = delete;
  Parser(const Parser& copy)            = delete;

  private:
  Parser();
  Parser(const std::string& file);
  Parser(std::vector<uint8_t> data);
  virtual ~Parser();

  void init(const std::string& name, art_version_t version);

  template<typename ART_T>
  void parse_file();

  template<typename ART_T>
  size_t parse_header();

  template<typename ART_T, typename PTR_T>
  void parse_sections();

  template<typename ART_T, typename PTR_T>
  void parse_roots();

  template<typename ART_T, typename PTR_T>
  void parse_methods();

  // Section parsing
  template<typename ART_T, typename PTR_T>
  void parse_objects(size_t offset, size_t size);

  template<typename ART_T, typename PTR_T>
  void parse_art_fields(size_t offset, size_t size);

  template<typename ART_T, typename PTR_T>
  void parse_art_methods(size_t offset, size_t size);

  template<typename ART_T, typename PTR_T>
  void parse_interned_strings(size_t offset, size_t size);

  // Parse an **Array** of java.lang.DexCache objects
  template<typename ART_T, typename PTR_T>
  void parse_dex_caches(size_t offset, size_t size);

  // Parse a **Single** java.lang.DexCache object
  template<typename ART_T, typename PTR_T>
  void parse_dex_cache(size_t object_offset);

  // Parse an **Array** of java.lang.Class objects
  template<typename ART_T, typename PTR_T>
  void parse_class_roots(size_t offset, size_t size);

  // Parse java.lang.Class objects
  template<typename ART_T, typename PTR_T>
  void parse_class(size_t offset);

  // Parse java.lang.String objects
  template<typename ART_T, typename PTR_T>
  void parse_jstring(size_t offset);


  //// Parse a **Single** java.lang.DexCache object
  //template<typename ART_T, typename PTR_T>
  //void parse_class_roots(size_t object_offset);

  std::unique_ptr<File> file_;
  std::unique_ptr<BinaryStream> stream_;
  uint32_t imagebase_ = 0;
};
} // namespace ART
} // namespace LIEF
#endif

```

`KDemu/include/LIEF/LIEF/ART/enums.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ART_ENUMS_H
#define LIEF_ART_ENUMS_H

namespace LIEF {
namespace ART {

enum STORAGE_MODES {
  STORAGE_UNCOMPRESSED = 0,
  STORAGE_LZ4          = 1,
  STORAGE_LZ4HC        = 2,
};

namespace ART_17 {

enum IMAGE_METHODS {
  RESOLUTION_METHOD         = 0,
  IMT_CONFLICT_METHOD       = 1,
  IMT_UNIMPLEMENTED_METHOD  = 2,
  CALLEE_SAVE_METHOD        = 3,
  REFS_ONLY_SAVE_METHOD     = 4,
  REFS_AND_ARGS_SAVE_METHOD = 5,
};

enum IMAGE_SECTIONS {
  SECTION_OBJECTS           = 0,
  SECTION_ART_FIELDS        = 1,
  SECTION_ART_METHODS       = 2,
  SECTION_INTERNED_STRINGS  = 3,
  SECTION_IMAGE_BITMAP      = 4,
};

enum IMAGE_ROOTS {
  DEX_CACHES   = 0,
  CLASS_ROOTS  = 1,
};


} // Namespace ART_17


namespace ART_29 {

using ART_17::IMAGE_METHODS;
using ART_17::IMAGE_ROOTS;

enum IMAGE_SECTIONS {
  SECTION_OBJECTS              = 0,
  SECTION_ART_FIELDS           = 1,
  SECTION_ART_METHODS          = 2,
  SECTION_RUNTIME_METHODS      = 3, // New in ART 29
  SECTION_IMT_CONFLICT_TABLES  = 4, // New in ART 29
  SECTION_DEX_CACHE_ARRAYS     = 5, // New in ART 29
  SECTION_INTERNED_STRINGS     = 6,
  SECTION_CLASS_TABLE          = 7, // New in ART 29
  SECTION_IMAGE_BITMAP         = 8,
};



} // Namespace ART_29


namespace ART_30 {

using ART_29::IMAGE_METHODS;
using ART_29::IMAGE_ROOTS;

enum IMAGE_SECTIONS {
  SECTION_OBJECTS              = 0,
  SECTION_ART_FIELDS           = 1,
  SECTION_ART_METHODS          = 2,
  SECTION_RUNTIME_METHODS      = 3,
  SECTION_IM_TABLES            = 4, // New in ART 30
  SECTION_IMT_CONFLICT_TABLES  = 5,
  SECTION_DEX_CACHE_ARRAYS     = 6,
  SECTION_INTERNED_STRINGS     = 7,
  SECTION_CLASS_TABLE          = 8,
  SECTION_IMAGE_BITMAP         = 9,
};

} // Namespace ART_30

namespace ART_44 {

using ART_30::IMAGE_SECTIONS;

enum IMAGE_METHODS {
  RESOLUTION_METHOD            = 0,
  IMT_CONFLICT_METHOD          = 1,
  IMT_UNIMPLEMENTED_METHOD     = 2,
  SAVE_ALL_CALLEE_SAVES_METHOD = 3, // New in ART 44
  SAVE_REFS_ONLY_METHOD        = 4, // New in ART 44
  SAVE_REFS_AND_ARGS_METHOD    = 5, // New in ART 44
  SAVE_EVERYTHING_METHOD       = 6, // New in ART 44
};


enum IMAGE_ROOTS {
  DEX_CACHES   = 0,
  CLASS_ROOTS  = 1,
  CLASS_LOADER = 2, // New in ART 44
};

} // Namespace ART_44


namespace ART_46 {

using ART_30::IMAGE_SECTIONS;
using ART_30::IMAGE_METHODS;
using ART_30::IMAGE_ROOTS;


} // Namespace ART_46

}
}
#endif

```

`KDemu/include/LIEF/LIEF/ART/hash.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ART_HASH_H
#define LIEF_ART_HASH_H

#include "LIEF/visibility.h"
#include "LIEF/hash.hpp"

namespace LIEF {
class Object;

namespace ART {
class File;
class Header;

class LIEF_API Hash : public LIEF::Hash {
  public:
  static LIEF::Hash::value_type hash(const Object& obj);

  public:
  using LIEF::Hash::Hash;
  using LIEF::Hash::visit;

  public:
  void visit(const File& file)      override;
  void visit(const Header& header)  override;

  ~Hash() override;
};

}
}

#endif

```

`KDemu/include/LIEF/LIEF/ART/java_structures.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ART_JAVA_STRUCTURES_H
#define LIEF_ART_JAVA_STRUCTURES_H

#include <cstring>
#include <tuple>

#include "LIEF/types.hpp"
#include "LIEF/ART/enums.hpp"
#include "LIEF/ART/types.hpp"

namespace LIEF {
//! @brief Namespace related to the LIEF's ART module
namespace ART {

namespace details {

struct no_brooks_read_barrier_t {};

// ======================
// Android 6.0.1 - ART 17
// ======================
namespace ART_17 {

//! @brief Namespace related to the Java part of ART 17
namespace Java {

using heap_reference_t = uint32_t;

struct brooks_read_barrier_t {
  uint32_t x_rb_ptr;
  uint32_t x_xpadding;
};

template<class T>
struct jobject_t {
  heap_reference_t klass;
  uint32_t         monitor;
  T                brooks_read_barrier;
};

template<>
struct jobject_t<no_brooks_read_barrier_t> {
  heap_reference_t klass;
  uint32_t         monitor;
};
template<class T = no_brooks_read_barrier_t>
struct ALIGNED_(4) jarray_t {
  jobject_t<T> object;
  int32_t   length;
  uint32_t* elements;
};

template<class T = no_brooks_read_barrier_t>
struct ALIGNED_(4) jclass_t {
  jobject_t<T>     object;

  heap_reference_t class_loader;
  heap_reference_t component_type;
  heap_reference_t dex_cache;
  heap_reference_t dex_cache_strings;
  heap_reference_t iftable;
  heap_reference_t name;
  heap_reference_t super_class;
  heap_reference_t verify_error_class;
  heap_reference_t vtable;

  uint32_t access_flags;
  uint64_t direct_methods;
  uint64_t ifields;
  uint64_t sfields;
  uint64_t virtual_methods;
  uint32_t class_size;
  uint32_t clinit_thread_id;
  int32_t  dex_class_def_idx;
  int32_t  dex_type_idx;
  uint32_t num_direct_methods;
  uint32_t num_instance_fields;
  uint32_t num_reference_instance_fields;
  uint32_t num_reference_static_fields;
  uint32_t num_static_fields;
  uint32_t num_virtual_methods;
  uint32_t object_size;
  uint32_t primitive_type;
  uint32_t reference_instance_offsets;
  int32_t  status;
};

template<class T = no_brooks_read_barrier_t>
struct ALIGNED_(4) jstring_t {
  jobject_t<T> object;
  int32_t      count;
  uint32_t     hash_code;
  uint16_t*    value;
};

template<class T = no_brooks_read_barrier_t>
struct ALIGNED_(4) jdex_cache_t {
  jobject_t<T> object;

  heap_reference_t dex;
  heap_reference_t location;
  heap_reference_t resolved_fields;
  heap_reference_t resolved_methods;
  heap_reference_t resolved_types;
  heap_reference_t strings;
  uint64_t         dex_file;
};


} // Namespace Java
} // Namespace ART_17

// ======================
// Android 7.0.0 - ART 29
// ======================
namespace ART_29 {

//! @brief Namespace related to the Java part of ART 29
namespace Java {
using heap_reference_t      = ART_17::Java::heap_reference_t;
using brooks_read_barrier_t = ART_17::Java::brooks_read_barrier_t;

template<class T = no_brooks_read_barrier_t>
using jobject_t = ART_17::Java::jobject_t<T>;

template<class T = no_brooks_read_barrier_t>
using jarray_t = ART_17::Java::jarray_t<T>;

template<class T = no_brooks_read_barrier_t>
struct ALIGNED_(4) jclass_t {
  jobject_t<T>     object;

  heap_reference_t annotation_type;           // ADDED in ART 29
  heap_reference_t class_loader;
  heap_reference_t component_type;
  heap_reference_t dex_cache;
  // heap_reference_t dex_cache_strings;      // REMOVED in ART 29
  heap_reference_t iftable;
  heap_reference_t name;
  heap_reference_t super_class;
  heap_reference_t verify_error;              // Type CHANGED from Class to Object
  heap_reference_t vtable;

  uint32_t access_flags;
  uint64_t dex_cache_strings;                 // direct_methods REPLACED with dex_cache_string
  uint64_t ifields;
  uint64_t methods;                           // ADDED in ART 29
  uint64_t sfields;
  uint32_t class_flags;                       // virtual_methods REPLACED with class_flags
  uint32_t class_size;
  uint32_t clinit_thread_id;
  int32_t  dex_class_def_idx;
  int32_t  dex_type_idx;
  // uint32_t num_direct_methods;             // REMOVED in ART 29
  // uint32_t num_instance_fields;            // REMOVED in ART 29
  uint32_t num_reference_instance_fields;
  uint32_t num_reference_static_fields;
  // uint32_t num_static_fields;              // REMOVED in ART 29
  // uint32_t num_virtual_methods;            // REMOVED in ART 29
  uint32_t object_size;
  uint32_t primitive_type;
  uint32_t reference_instance_offsets;
  int32_t  status;

  uint16_t copied_methods_offset;              // ADDED in ART 29
  uint16_t virtual_methods_offset;             // ADDED in ART 29
};


// No changes in jstring structure
template<class T = no_brooks_read_barrier_t>
using jstring_t = ART_17::Java::jstring_t<T>;

template<class T = no_brooks_read_barrier_t>
struct ALIGNED_(4) jdex_cache_t {
  jobject_t<T> object;

  heap_reference_t dex;
  heap_reference_t location;
  uint64_t         dex_file;               // LOCATION CHANGED
  uint64_t         resolved_fields;        // TYPE CHANGED from heap_reference_t to uint64_t
  uint64_t         resolved_methods;       // TYPE CHANGED from heap_reference_t to uint64_t
  uint64_t         resolved_types;         // TYPE CHANGED from heap_reference_t to uint64_t
  uint64_t         strings;                // TYPE CHANGED from heap_reference_t to uint64_t
  uint32_t         num_resolved_fields;    // ADDED in ART 29
  uint32_t         num_resolved_methods;   // ADDED in ART 29
  uint32_t         num_resolved_types;     // ADDED in ART 29
  uint32_t         num_strings;            // ADDED in ART 29
};




} // Namespace Java
} // Namespace ART_29


// ======================
// Android 7.1.X - ART 30
// ======================
namespace ART_30 {

//! @brief Namespace related to the Java part of ART 30
namespace Java {

using heap_reference_t      = ART_29::Java::heap_reference_t;
using brooks_read_barrier_t = ART_29::Java::brooks_read_barrier_t;

template<class T = no_brooks_read_barrier_t>
using jobject_t = ART_29::Java::jobject_t<T>;

template<class T = no_brooks_read_barrier_t>
using jarray_t = ART_29::Java::jarray_t<T>;

template<class T = no_brooks_read_barrier_t>
using jclass_t = ART_29::Java::jclass_t<T>;

// No changes in jstring structure
template<class T = no_brooks_read_barrier_t>
using jstring_t = ART_29::Java::jstring_t<T>;

// No changes in jdex_cache structure
template<class T = no_brooks_read_barrier_t>
using jdex_cache_t = ART_29::Java::jdex_cache_t<T>;

} // Namespace Java
} // Namespace ART_30

// ======================
// Android 8.0.0 - ART 44
// ======================
namespace ART_44 {

//! @brief Namespace related to the Java part of ART 44
namespace Java {


using heap_reference_t      = ART_30::Java::heap_reference_t;
using brooks_read_barrier_t = ART_30::Java::brooks_read_barrier_t;

template<class T = no_brooks_read_barrier_t>
using jobject_t = ART_30::Java::jobject_t<T>;

template<class T = no_brooks_read_barrier_t>
using jarray_t = ART_30::Java::jarray_t<T>;

template<class T = no_brooks_read_barrier_t>
struct ALIGNED_(4) jclass_t {
  jobject_t<T>     object;

  // heap_reference_t annotation_type;        // REMOVED in ART 44
  heap_reference_t class_loader;
  heap_reference_t component_type;
  heap_reference_t dex_cache;
  heap_reference_t ext_data;                  // ADDED in ART 44
  heap_reference_t iftable;
  heap_reference_t name;
  heap_reference_t super_class;
  // heap_reference_t verify_error;           // REMOVED in ART 44
  heap_reference_t vtable;

  // uint32_t access_flags;                   // REMOVED in ART 44
  // uint64_t dex_cache_strings;              // REMOVED in ART 44
  uint64_t ifields;
  uint64_t methods;
  uint64_t sfields;
  uint32_t access_flags;                      // ADDED in ART 44
  uint32_t class_flags;
  uint32_t class_size;
  uint32_t clinit_thread_id;
  int32_t  dex_class_def_idx;
  int32_t  dex_type_idx;
  uint32_t num_reference_instance_fields;
  uint32_t num_reference_static_fields;
  uint32_t object_size;
  uint32_t object_size_alloc_fast_path;       // ADDED in ART 44
  uint32_t primitive_type;
  uint32_t reference_instance_offsets;
  int32_t  status;
  uint16_t copied_methods_offset;
  uint16_t virtual_methods_offset;
};


// No changes in jstring structure but string can be
// encoded as as char16_t or char (compressed)
// count[0] (LSB) == 1 ----> compressed
// count[0] (LSB) == 0 ----> chat16_t
template<class T = no_brooks_read_barrier_t>
using jstring_t = ART_30::Java::jstring_t<T>;

template<class T = no_brooks_read_barrier_t>
struct ALIGNED_(4) jdex_cache_t {
  jobject_t<T> object;

  // heap_reference_t dex;                     // REMOVED in ART 44
  heap_reference_t location;
  uint32_t         num_resolved_call_sites;    // ADDED in ART 44 (related to DEX38 format)
  uint64_t         dex_file;
  uint64_t         resolved_call_sites;        // ADDED in ART 44 (related to DEX38 format)
  uint64_t         resolved_fields;
  uint64_t         resolved_method_types;      // ADDED in ART 44
  uint64_t         resolved_methods;
  uint64_t         resolved_types;
  uint64_t         strings;
  uint32_t         num_resolved_fields;
  uint32_t         num_resolved_methods_types; // ADDED in ART 44
  uint32_t         num_resolved_methods;
  uint32_t         num_resolved_types;
  uint32_t         num_strings;
};


} // Namespace Java
} // Namespace ART_44


// ======================
// Android 8.1.X - ART 46
// ======================
namespace ART_46 {

//! @brief Namespace related to the Java part of ART 46
namespace Java {

using heap_reference_t      = ART_44::Java::heap_reference_t;
using brooks_read_barrier_t = ART_44::Java::brooks_read_barrier_t;

template<class T = no_brooks_read_barrier_t>
using jobject_t = ART_44::Java::jobject_t<T>;

template<class T = no_brooks_read_barrier_t>
using jarray_t = ART_44::Java::jarray_t<T>;

template<class T = no_brooks_read_barrier_t>
using jclass_t = ART_44::Java::jclass_t<T>;

template<class T = no_brooks_read_barrier_t>
using jstring_t = ART_44::Java::jstring_t<T>;

template<class T = no_brooks_read_barrier_t>
using jdex_cache_t = ART_44::Java::jdex_cache_t<T>;

} // Namespace Java
} // Namespace ART_46

// ======================
// Android 9.0.0 - ART 66
// ======================
namespace ART_56 {

//! @brief Namespace related to the Java part of ART 46
namespace Java {

using heap_reference_t      = ART_46::Java::heap_reference_t;
using brooks_read_barrier_t = ART_46::Java::brooks_read_barrier_t;

template<class T = no_brooks_read_barrier_t>
using jobject_t = ART_46::Java::jobject_t<T>;

template<class T = no_brooks_read_barrier_t>
using jarray_t = ART_46::Java::jarray_t<T>;

template<class T = no_brooks_read_barrier_t>
using jclass_t = ART_46::Java::jclass_t<T>;

template<class T = no_brooks_read_barrier_t>
using jstring_t = ART_46::Java::jstring_t<T>;

template<class T = no_brooks_read_barrier_t>
using jdex_cache_t = ART_46::Java::jdex_cache_t<T>;

} // Namespace Java
} // Namespace ART_56

} // namespace details
} // Namespace ART
} // Namespace LIEF



#endif

```

`KDemu/include/LIEF/LIEF/ART/json.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ART_PUBLIC_JSON_H
#define LIEF_ART_PUBLIC_JSON_H

#include "LIEF/visibility.h"
#include <string>

namespace LIEF {
class Object;
namespace ART {

LIEF_API std::string to_json(const Object& v);

}
}

#endif

```

`KDemu/include/LIEF/LIEF/ART/types.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ART_TYPE_TRAITS_H
#define LIEF_ART_TYPE_TRAITS_H

#include <cstdint>
#include <vector>
#include "LIEF/iterators.hpp"

namespace LIEF {
namespace ART {

using art_version_t = uint32_t;

} // Namesapce ART
} // Namespace LIEF

#endif

```

`KDemu/include/LIEF/LIEF/ART/utils.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ART_UTILS_H
#define LIEF_ART_UTILS_H

#include <string>
#include <vector>

#include "LIEF/ART/types.hpp"

#include "LIEF/platforms/android.hpp"

#include "LIEF/types.hpp"
#include "LIEF/visibility.h"

namespace LIEF {
namespace ART {

//! @brief Check if the given file is an ART one.
LIEF_API bool is_art(const std::string& file);

//! @brief Check if the given raw data is an ART one.
LIEF_API bool is_art(const std::vector<uint8_t>& raw);

//! @brief Return the ART version of the given file
LIEF_API art_version_t version(const std::string& file);

//! @brief Return the ART version of the raw data
LIEF_API art_version_t version(const std::vector<uint8_t>& raw);

//! @brief Return the ANDROID_VERSIONS associated with the given ART version
LIEF_API LIEF::Android::ANDROID_VERSIONS android_version(art_version_t version);

}
}


#endif

```

`KDemu/include/LIEF/LIEF/Abstract.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ABSTRACT_H
#define LIEF_ABSTRACT_H

#include <LIEF/Abstract/Binary.hpp>
#include <LIEF/Abstract/enums.hpp>
#include <LIEF/Abstract/EnumToString.hpp>
#include <LIEF/Abstract/Parser.hpp>
#include <LIEF/Abstract/Relocation.hpp>
#include <LIEF/Abstract/Function.hpp>
#include <LIEF/Abstract/Symbol.hpp>
#include <LIEF/Abstract/Section.hpp>

#endif

```

`KDemu/include/LIEF/LIEF/Abstract/Binary.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ABSTRACT_BINARY_H
#define LIEF_ABSTRACT_BINARY_H

#include <vector>
#include <memory>

#include "LIEF/visibility.h"
#include "LIEF/Object.hpp"
#include "LIEF/iterators.hpp"
#include "LIEF/errors.hpp"
#include "LIEF/span.hpp"

#include "LIEF/Abstract/Header.hpp"
#include "LIEF/Abstract/Function.hpp"

//! LIEF namespace
namespace LIEF {
class Section;
class Relocation;
class Symbol;

class DebugInfo;

//! Abstract binary that exposes an uniform API for the
//! different executable file formats
class LIEF_API Binary : public Object {
  public:

  //! Type of a virtual address
  enum class VA_TYPES {
    AUTO = 0, ///< Try to guess if it's relative or not
    RVA  = 1, ///< Relative
    VA   = 2, ///< Absolute
  };

  enum FORMATS {
    UNKNOWN = 0,
    ELF,
    PE,
    MACHO,
    OAT,
  };

  using functions_t = std::vector<Function>;

  //! Internal container
  using sections_t = std::vector<Section*>;

  //! Iterator that outputs LIEF::Section&
  using it_sections = ref_iterator<sections_t>;

  //! Iterator that outputs const LIEF::Section&
  using it_const_sections = const_ref_iterator<sections_t>;

  //! Internal container
  using symbols_t = std::vector<Symbol*>;

  //! Iterator that outputs LIEF::Symbol&
  using it_symbols = ref_iterator<symbols_t>;

  //! Iterator that outputs const LIEF::Symbol&
  using it_const_symbols = const_ref_iterator<symbols_t>;

  //! Internal container
  using relocations_t = std::vector<Relocation*>;

  //! Iterator that outputs LIEF::Relocation&
  using it_relocations = ref_iterator<relocations_t>;

  //! Iterator that outputs const LIEF::Relocation&
  using it_const_relocations = const_ref_iterator<relocations_t>;

  public:
  Binary();
  Binary(FORMATS fmt);

  ~Binary() override;

  Binary& operator=(const Binary&) = delete;
  Binary(const Binary&) = delete;

  //! Executable format (ELF, PE, Mach-O) of the underlying binary
  FORMATS format() const {
    return format_;
  }

  //! Return the abstract header of the binary
  Header header() const;

  //! Return an iterator over the abstracted symbols in which the elements **can** be modified
  it_symbols symbols();

  //! Return an iterator over the abstracted symbols in which the elements **can't** be modified
  it_const_symbols  symbols() const;

  //! Check if a Symbol with the given name exists
  bool has_symbol(const std::string& name) const;

  //! Return the Symbol with the given name
  //! If the symbol does not exist, return a nullptr
  const Symbol* get_symbol(const std::string& name) const;

  Symbol* get_symbol(const std::string& name);

  //! Return an iterator over the binary's sections (LIEF::Section)
  it_sections sections();
  it_const_sections sections() const;

  //! Remove **all** the sections in the underlying binary
  virtual void remove_section(const std::string& name, bool clear = false) = 0;

  //! Return an iterator over the binary relocation (LIEF::Relocation)
  it_relocations       relocations();
  it_const_relocations relocations() const;

  //! Binary's entrypoint (if any)
  virtual uint64_t entrypoint() const = 0;

  //! Binary's original size
  uint64_t original_size() const {
    return original_size_;
  }

  //! Return the functions exported by the binary
  functions_t exported_functions() const;

  //! Return libraries which are imported by the binary
  std::vector<std::string> imported_libraries() const;

  //! Return functions imported by the binary
  functions_t imported_functions() const;

  //! Return the address of the given function name
  virtual result<uint64_t> get_function_address(const std::string& func_name) const;

  //! Method so that a ``visitor`` can visit us
  void accept(Visitor& visitor) const override;

  std::vector<uint64_t> xref(uint64_t address) const;

  //! Patch the content at virtual address @p address with @p patch_value
  //!
  //! @param[in] address        Address to patch
  //! @param[in] patch_value    Patch to apply
  //! @param[in] addr_type      Specify if the address should be used as an
  //!                           absolute virtual address or a RVA
  virtual void patch_address(uint64_t address, const std::vector<uint8_t>& patch_value,
                             VA_TYPES addr_type = VA_TYPES::AUTO) = 0;

  //! Patch the address with the given value
  //!
  //! @param[in] address      Address to patch
  //! @param[in] patch_value  Patch to apply
  //! @param[in] size         Size of the value in **bytes** (1, 2, ... 8)
  //! @param[in] addr_type    Specify if the address should be used as an absolute virtual address or an RVA
  virtual void patch_address(uint64_t address, uint64_t patch_value, size_t size = sizeof(uint64_t),
                             VA_TYPES addr_type = VA_TYPES::AUTO) = 0;

  //! Return the content located at the given virtual address
  virtual span<const uint8_t>
    get_content_from_virtual_address(uint64_t virtual_address, uint64_t size,
                                     VA_TYPES addr_type = VA_TYPES::AUTO) const = 0;

  //! @brief Change binary's original size.
  //!
  //! @warning
  //! This function should be used carefully as some optimizations
  //! can be performed with this value
  void original_size(uint64_t size) {
    original_size_ = size;
  }

  //! Check if the binary is position independent
  virtual bool is_pie() const = 0;

  //! Check if the binary uses ``NX`` protection
  virtual bool has_nx() const = 0;

  //! Default image base address if the ASLR is not enabled.
  virtual uint64_t imagebase() const = 0;

  //! Constructor functions that are called prior any other functions
  virtual functions_t ctor_functions() const = 0;

  //! Convert the given offset into a virtual address.
  //!
  //! @param[in] offset   The offset to convert.
  //! @param[in] slide    If not 0, it will replace the default base address (if any)
  virtual result<uint64_t> offset_to_virtual_address(uint64_t offset, uint64_t slide = 0) const = 0;

  virtual std::ostream& print(std::ostream& os) const;

  //! Build & transform the Binary object representation into a *real* executable
  virtual void write(const std::string& name) = 0;
  virtual void write(std::ostream& os) = 0;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const Binary& binary);

  /// Return the debug info if present. It can be either a
  /// LIEF::dwarf::DebugInfo or a LIEF::pdb::DebugInfo
  ///
  /// For ELF and Mach-O binaries, it returns the given DebugInfo object **only**
  /// if the binary embeds the DWARF debug info in the binary itself.
  ///
  /// For PE file, this function tries to find the **external** PDB using
  /// the LIEF::PE::CodeViewPDB::filename() output (if present). One can also
  /// use LIEF::pdb::load() or LIEF::pdb::DebugInfo::from_file() to get PDB debug
  /// info.
  ///
  /// @warning This function requires LIEF's extended version otherwise it
  /// **always** return a nullptr
  DebugInfo* debug_info() const;

  protected:
  FORMATS format_ = FORMATS::UNKNOWN;
  mutable std::unique_ptr<DebugInfo> debug_info_;
  uint64_t original_size_ = 0;

  // These functions need to be overloaded by the object that claims to extend this Abstract Binary
  virtual Header get_abstract_header() const = 0;
  virtual symbols_t get_abstract_symbols() = 0;
  virtual sections_t get_abstract_sections() = 0;
  virtual relocations_t get_abstract_relocations() = 0;

  virtual functions_t  get_abstract_exported_functions() const = 0;
  virtual functions_t  get_abstract_imported_functions() const = 0;
  virtual std::vector<std::string>  get_abstract_imported_libraries() const = 0;
};

LIEF_API const char* to_string(Binary::VA_TYPES e);
LIEF_API const char* to_string(Binary::FORMATS e);

}


#endif

```

`KDemu/include/LIEF/LIEF/Abstract/DebugInfo.hpp`:

```hpp
/* Copyright 2022 - 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_DEBUGINFO_H
#define LIEF_DEBUGINFO_H
#include <memory>
namespace LIEF {

namespace details {
class DebugInfo;
}

class DebugInfo {
  public:
  enum class FORMAT {
    UNKNOWN = 0,
    DWARF, PDB,
  };
  DebugInfo(std::unique_ptr<details::DebugInfo> impl);
  virtual ~DebugInfo();

  virtual FORMAT format() const {
    return FORMAT::UNKNOWN;
  }

  protected:
  std::unique_ptr<details::DebugInfo> impl_;
};

}
#endif

```

`KDemu/include/LIEF/LIEF/Abstract/EnumToString.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ENUM_TO_STRING_H
#define LIEF_ENUM_TO_STRING_H
#include "LIEF/visibility.h"

#include "LIEF/Abstract/enums.hpp"
#include "LIEF/Abstract/Binary.hpp"

namespace LIEF {
LIEF_API const char* to_string(ARCHITECTURES e);
LIEF_API const char* to_string(OBJECT_TYPES e);
LIEF_API const char* to_string(MODES e);
LIEF_API const char* to_string(ENDIANNESS e);
LIEF_API const char* to_string(Function::FLAGS e);
} // namespace LIEF

#endif


```

`KDemu/include/LIEF/LIEF/Abstract/Function.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ABSTRACT_FUNCTION_H
#define LIEF_ABSTRACT_FUNCTION_H

#include <vector>
#include <string>
#include <set>

#include "LIEF/Abstract/Symbol.hpp"
#include "LIEF/visibility.h"

namespace LIEF {

//! Class that represents a function in the binary
class LIEF_API Function : public Symbol {
  public:
  //! Flags used to characterize the semantic
  //! of the function
  enum class FLAGS {
    NONE = 0,
    //! The function acts as constructor.
    //!
    //! Usually this flag is associated with functions
    //! that are located in the ``.init_array``, ``__mod_init_func`` or ``.tls`` sections
    CONSTRUCTOR,

    //! The function acts a destructor.
    //!
    //! Usually this flag is associated with functions
    //! that are located in the ``.fini_array`` or ``__mod_term_func`` sections
    DESTRUCTOR,

    //! The function is associated with Debug information
    DEBUG_INFO,

    //! The function is exported by the binary and the address() method
    //! returns its virtual address in the binary
    EXPORTED,

    //! The function is **imported** by the binary and the address() should return 0
    IMPORTED,
  };

  using flags_list_t = std::vector<FLAGS>;
  using flags_t      = std::set<FLAGS>;

  public:
  Function();
  Function(const std::string& name);
  Function(uint64_t address);
  Function(const std::string& name, uint64_t address);
  Function(const std::string& name, uint64_t address, const flags_list_t& flags);
  Function(const Function&);
  Function& operator=(const Function&);
  ~Function() override;

  //! List of FLAGS
  flags_list_t flags() const;

  //! Add a flag to the current function
  Function& add(FLAGS f);

  //! Address of the current function. For functions that are set with the FLAGS::IMPORTED flag,
  //! this value is likely 0.
  uint64_t address() const;
  void address(uint64_t address);

  //! Method so that the ``visitor`` can visit us
  void accept(Visitor& visitor) const override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const Function& entry);

  protected:
  flags_t flags_;
};
}

#endif


```

`KDemu/include/LIEF/LIEF/Abstract/Header.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ABSTRACT_HEADER_H
#define LIEF_ABSTRACT_HEADER_H

#include <ostream>
#include <set>
#include <cstdint>

#include "LIEF/Object.hpp"
#include "LIEF/visibility.h"

#include "LIEF/Abstract/enums.hpp"

namespace LIEF {
class LIEF_API Header : public Object {
  public:
  Header();
  Header(const Header&);
  Header& operator=(const Header&);
  ~Header() override;


  ARCHITECTURES          architecture() const;
  const std::set<MODES>& modes()        const;
  OBJECT_TYPES           object_type()  const;
  uint64_t               entrypoint()   const;
  ENDIANNESS             endianness()   const;


  //! @brief ``true`` if the binary target a ``32-bits`` architecture
  bool is_32() const;

  //! @brief ``true`` if the binary target a ``64-bits`` architecture
  bool is_64() const;

  //! @brief Method so that the ``visitor`` can visit us
  void accept(Visitor& visitor) const override;

  void architecture(ARCHITECTURES arch);
  void modes(const std::set<MODES>& m);
  void object_type(OBJECT_TYPES type);
  void entrypoint(uint64_t entrypoint);
  void endianness(ENDIANNESS endianness);

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const Header& hdr);

  protected:
  ARCHITECTURES   architecture_ = ARCHITECTURES::ARCH_NONE;
  std::set<MODES> modes_;
  OBJECT_TYPES    object_type_ = OBJECT_TYPES::TYPE_NONE;
  uint64_t        entrypoint_ = 0;
  ENDIANNESS      endianness_ = ENDIANNESS::ENDIAN_NONE;
};
}

#endif

```

`KDemu/include/LIEF/LIEF/Abstract/Parser.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ABSTRACT_PARSER_H
#define LIEF_ABSTRACT_PARSER_H

#include <string>
#include <memory>
#include <vector>

#include "LIEF/visibility.h"

namespace LIEF {
class BinaryStream;
class Binary;

//! Main interface to parse an executable regardless of its format
class LIEF_API Parser {
  public:
  //! Construct an LIEF::Binary from the given filename
  //!
  //! @warning If the target file is a FAT Mach-O, it will return the **last** one
  //! @see LIEF::MachO::Parser::parse
  static std::unique_ptr<Binary> parse(const std::string& filename);


  //! @brief Construct an LIEF::Binary from the given raw data
  //!
  //! @warning If the target file is a FAT Mach-O, it will return the **last** one
  //! @see LIEF::MachO::Parser::parse
  static std::unique_ptr<Binary> parse(const std::vector<uint8_t>& raw);

  //! @brief Construct an LIEF::Binary from the given stream
  //!
  //! @warning If the target file is a FAT Mach-O, it will return the **last** one
  //! @see LIEF::MachO::Parser::parse
  static std::unique_ptr<Binary> parse(std::unique_ptr<BinaryStream> stream);

  protected:
  Parser(const std::string& file);
  uint64_t binary_size_  = 0;

  virtual ~Parser();
  Parser();
};
}

#endif

```

`KDemu/include/LIEF/LIEF/Abstract/Relocation.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ABSTRACT_RELOCATION_H
#define LIEF_ABSTRACT_RELOCATION_H

#include <ostream>
#include <cstdint>

#include "LIEF/Object.hpp"
#include "LIEF/visibility.h"

namespace LIEF {
//! Class which represents an abstracted Relocation
class LIEF_API Relocation : public Object {

  public:
  Relocation();

  //! Constructor from a relocation's address and size
  Relocation(uint64_t address, uint8_t size);

  ~Relocation() override;

  Relocation& operator=(const Relocation&);
  Relocation(const Relocation&);
  void swap(Relocation& other);

  //! Relocation's address
  virtual uint64_t address() const;

  //! Relocation size in **bits**
  virtual size_t size() const;

  virtual void address(uint64_t address);
  virtual void size(size_t size);

  //! Method so that the ``visitor`` can visit us
  void accept(Visitor& visitor) const override;


  //! Comparaison based on the Relocation's **address**
  virtual bool operator<(const Relocation& rhs) const;

  //! Comparaison based on the Relocation's **address**
  virtual bool operator<=(const Relocation& rhs) const;

  //! Comparaison based on the Relocation's **address**
  virtual bool operator>(const Relocation& rhs) const;

  //! Comparaison based on the Relocation's **address**
  virtual bool operator>=(const Relocation& rhs) const;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const Relocation& entry);

  protected:
  uint64_t address_ = 0;
  uint8_t  size_ = 0;
};


}
#endif

```

`KDemu/include/LIEF/LIEF/Abstract/Section.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ABSTRACT_SECTION_H
#define LIEF_ABSTRACT_SECTION_H

#include <string>
#include <vector>
#include <ostream>

#include "LIEF/span.hpp"
#include "LIEF/Object.hpp"
#include "LIEF/visibility.h"

namespace LIEF {
//! Class which represents an abstracted section
class LIEF_API Section : public Object {
  public:
  static constexpr size_t npos = -1;

  Section() = default;
  Section(std::string name) :
    name_(std::move(name))
  {}

  ~Section() override = default;

  Section& operator=(const Section&) = default;
  Section(const Section&) = default;

  //! section's name
  virtual std::string name() const {
    return name_.c_str();
  }

  //! Return the **complete** section's name which might
  //! trailing (``0``) bytes
  virtual const std::string& fullname() const {
    return name_;
  }

  //!  section's content
  virtual span<const uint8_t> content() const {
    return {};
  }

  //! Change the section size
  virtual void size(uint64_t size) {
    size_ = size;
  }

  //! section's size (size in the binary, not the virtual size)
  virtual uint64_t size() const {
    return size_;
  }

  //! Offset in the binary
  virtual uint64_t offset() const {
    return offset_;
  }

  //! Address where the section should be mapped
  virtual uint64_t virtual_address() const {
    return virtual_address_;
  }

  virtual void virtual_address(uint64_t virtual_address) {
    virtual_address_ = virtual_address;
  }

  //! Change the section's name
  virtual void name(std::string name) {
    name_ = std::move(name);
  }

  //! Change section content
  virtual void content(const std::vector<uint8_t>&) {}

  virtual void offset(uint64_t offset) {
    offset_ = offset;
  }

  //! Section's entropy
  double entropy() const;

  // Search functions
  // ================
  size_t search(uint64_t integer, size_t pos, size_t size) const;
  size_t search(const std::vector<uint8_t>& pattern, size_t pos = 0) const;
  size_t search(const std::string& pattern, size_t pos = 0) const;
  size_t search(uint64_t integer, size_t pos = 0) const;

  // Search all functions
  // ====================
  std::vector<size_t> search_all(uint64_t v, size_t size) const;

  std::vector<size_t> search_all(uint64_t v) const;

  std::vector<size_t> search_all(const std::string& v) const;

  //! @brief Method so that the ``visitor`` can visit us
  void accept(Visitor& visitor) const override;


  LIEF_API friend std::ostream& operator<<(std::ostream& os, const Section& entry);

  protected:
  std::string name_;
  uint64_t    virtual_address_ = 0;
  uint64_t    size_ = 0;
  uint64_t    offset_ = 0;

  private:
  template<typename T>
  std::vector<size_t> search_all_(const T& v) const;
};
}

#endif

```

`KDemu/include/LIEF/LIEF/Abstract/Symbol.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ABSTRACT_SYMBOLS_H
#define LIEF_ABSTRACT_SYMBOLS_H

#include <cstdint>
#include <string>

#include "LIEF/Object.hpp"
#include "LIEF/visibility.h"

namespace LIEF {

//! This class represents a symbol in an executable format.
class LIEF_API Symbol : public Object {
  public:
  Symbol() = default;
  Symbol(std::string name) :
    name_(std::move(name))
  {}
  Symbol(std::string name, uint64_t value) :
    name_(std::move(name)),
    value_(value)
  {}
  Symbol(std::string name, uint64_t value, uint64_t size) :
    name_(std::move(name)),
    value_(value),
    size_(size)
  {}

  Symbol(const Symbol&) = default;
  Symbol& operator=(const Symbol&) = default;
  ~Symbol() override = default;

  void swap(Symbol& other) noexcept;

  //! Return the symbol's name
  virtual const std::string& name() const {
    return name_;
  }
  virtual std::string& name() {
    return name_;
  }

  //! Set symbol name
  virtual void name(std::string name) {
    name_ = std::move(name);
  }

  // Symbol's value which is usually the **address** of the symbol
  virtual uint64_t value() const {
    return value_;
  }
  virtual void value(uint64_t value) {
    value_ = value;
  }

  //! This size of the symbol (when applicable)
  virtual uint64_t size() const {
    return size_;
  }

  virtual void size(uint64_t value) {
    size_ = value;
  }

  //! Method so that the ``visitor`` can visit us
  void accept(Visitor& visitor) const override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const Symbol& entry);

  protected:
  std::string name_;
  uint64_t value_ = 0;
  uint64_t size_ = 0;
};
}

#endif


```

`KDemu/include/LIEF/LIEF/Abstract/enums.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ABSTRACT_ENUMS_H
#define LIEF_ABSTRACT_ENUMS_H

namespace LIEF {

enum OBJECT_TYPES {
  TYPE_NONE       = 0,
  TYPE_EXECUTABLE = 1,
  TYPE_LIBRARY    = 2,
  TYPE_OBJECT     = 3,
};

// Inspired from capstone
enum ARCHITECTURES {
  ARCH_NONE  = 0,
  ARCH_ARM   = 1,
  ARCH_ARM64 = 2,
  ARCH_MIPS  = 3,
  ARCH_X86   = 4,
  ARCH_PPC   = 5,
  ARCH_SPARC = 6,
  ARCH_SYSZ  = 7,
  ARCH_XCORE = 8,
  ARCH_INTEL = 9,
  ARCH_RISCV = 10,
  ARCH_LOONGARCH = 11,
};

enum MODES {
  MODE_NONE          = 0,
  MODE_16            = 1,
  MODE_32            = 2,
  MODE_64            = 3,
  MODE_ARM           = 4,
  MODE_THUMB         = 5,
  MODE_MCLASS        = 6,
  MODE_MICRO         = 7,
  MODE_MIPS3         = 8,
  MODE_MIPS32R6      = 9,
  MODE_MIPSGP64      = 10,
  MODE_V7            = 11,
  MODE_V8            = 12,
  MODE_V9            = 13,
  MODE_MIPS32        = 14,
  MODE_MIPS64        = 15,
};

enum ENDIANNESS {
  ENDIAN_NONE   = 0,
  ENDIAN_BIG    = 1,
  ENDIAN_LITTLE = 2,
};

} // namespace LIEF
#endif

```

`KDemu/include/LIEF/LIEF/Abstract/hash.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ABSTRACT_HASH_H
#define LIEF_ABSTRACT_HASH_H

#include "LIEF/visibility.h"
#include "LIEF/hash.hpp"

namespace LIEF {
class Binary;
class Header;
class Relocation;
class Object;

class LIEF_API AbstractHash : public LIEF::Hash {
  public:
  static LIEF::Hash::value_type hash(const Object& obj);

  public:
  using LIEF::Hash::Hash;
  using LIEF::Hash::visit;

  public:
  void visit(const Binary& binary)         override;
  void visit(const Header& header)         override;
  void visit(const Section& section)       override;
  void visit(const Symbol& symbol)         override;
  void visit(const Relocation& relocation) override;
  void visit(const Function& function)     override;

  ~AbstractHash() override;
};

}

#endif

```

`KDemu/include/LIEF/LIEF/Abstract/json.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ABSTRACT_JSON_H
#define LIEF_ABSTRACT_JSON_H

#include "LIEF/visibility.h"
#include <string>

namespace LIEF {
class Object;

LIEF_API std::string to_json_from_abstract(const Object& v);

}

#endif // LIEF_JSON_SUPPORT


```

`KDemu/include/LIEF/LIEF/BinaryStream/ASN1Reader.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ASN1_READER_H
#define LIEF_ASN1_READER_H

#include <vector>
#include <memory>
#include <cstdint>
#include <string>

#include "LIEF/errors.hpp"

struct mbedtls_x509_crt;
struct mbedtls_x509_time;

namespace LIEF {
class BinaryStream;

class ASN1Reader {
  public:
  ASN1Reader() = delete;

  ASN1Reader(BinaryStream& stream) :
    stream_(stream)
  {}

  ASN1Reader(const ASN1Reader&) = delete;
  ASN1Reader& operator=(const ASN1Reader&) = delete;


  result<bool> is_tag(int tag);

  result<size_t> read_tag(int tag);
  result<size_t> read_len();
  result<std::string> read_alg();
  result<std::string> read_oid();
  result<bool> read_bool();
  result<int32_t> read_int();
  result<int64_t> read_int64();
  result<std::vector<uint8_t>> read_large_int();

  result<std::vector<uint8_t>> read_bitstring();
  result<std::vector<uint8_t>> read_octet_string();
  result<std::string> read_utf8_string();
  result<std::unique_ptr<mbedtls_x509_crt>> read_cert();
  result<std::string> x509_read_names();
  result<std::vector<uint8_t>> x509_read_serial();
  result<std::unique_ptr<mbedtls_x509_time>> x509_read_time();

  std::string get_str_tag();

  static std::string tag2str(int tag);

  private:
  BinaryStream& stream_;
};

}
#endif

```

`KDemu/include/LIEF/LIEF/BinaryStream/BinaryStream.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_BINARY_STREAM_H
#define LIEF_BINARY_STREAM_H

#include <cstdint>
#include <vector>
#include <memory>
#include <cstring>
#include <string>
#include <type_traits>
#include <algorithm>

#include "LIEF/BinaryStream/Convert.hpp"
#include "LIEF/errors.hpp"

namespace LIEF {
class ASN1Reader;

//! Class that is used to a read stream of data from different sources
class BinaryStream {
  public:
  friend class ASN1Reader;

  enum class STREAM_TYPE {
    UNKNOWN = 0,
    VECTOR,
    MEMORY,
    SPAN,
    FILE,

    ELF_DATA_HANDLER,
  };

  BinaryStream(STREAM_TYPE type) :
    stype_(type)
  {}
  virtual ~BinaryStream() = default;
  virtual uint64_t size() const = 0;

  STREAM_TYPE type() const {
    return stype_;
  }

  result<uint64_t> read_uleb128() const;
  result<uint64_t> read_sleb128() const;

  result<int64_t> read_dwarf_encoded(uint8_t encoding) const;

  result<std::string> read_string(size_t maxsize = ~static_cast<size_t>(0)) const;
  result<std::string> peek_string(size_t maxsize = ~static_cast<size_t>(0)) const;
  result<std::string> peek_string_at(size_t offset, size_t maxsize = ~static_cast<size_t>(0)) const;

  result<std::u16string> read_u16string() const;
  result<std::u16string> peek_u16string() const;

  result<std::string> read_mutf8(size_t maxsize = ~static_cast<size_t>(0)) const;

  result<std::u16string> read_u16string(size_t length) const;
  result<std::u16string> peek_u16string(size_t length) const;
  result<std::u16string> peek_u16string_at(size_t offset, size_t length) const;


  virtual ok_error_t peek_data(std::vector<uint8_t>& container,
                                      uint64_t offset, uint64_t size)
  {

    if (size == 0) {
      return ok();
    }
    // Even though offset + size < ... => offset < ...
    // the addition could overflow so it's worth checking both
    const bool read_ok = offset <= this->size() && (offset + size) <= this->size()
                                                /* Check for an overflow */
                                                && (static_cast<int64_t>(offset) >= 0 && static_cast<int64_t>(size) >= 0)
                                                && (static_cast<int64_t>(offset + size) >= 0);
    if (!read_ok) {
      return make_error_code(lief_errors::read_error);
    }
    container.resize(size);
    if (peek_in(container.data(), offset, size)) {
      return ok();
    }
    return make_error_code(lief_errors::read_error);
  }

  virtual ok_error_t read_data(std::vector<uint8_t>& container, uint64_t size) {
    if (!peek_data(container, pos(), size)) {
      return make_error_code(lief_errors::read_error);
    }

    increment_pos(size);
    return ok();
  }

  void setpos(size_t pos) const {
    pos_ = pos;
  }

  void increment_pos(size_t value) const {
    pos_ += value;
  }

  void decrement_pos(size_t value) const {
    if (pos_ > value) {
      pos_ -= value;
    } else {
      pos_ = 0;
    }
  }

  size_t pos() const {
    return pos_;
  }

  operator bool() const {
    return pos_ < size();
  }

  template<class T>
  const T* read_array(size_t size) const;

  template<class T>
  result<T> peek() const;

  template<class T>
  result<T> peek(size_t offset) const;

  template<class T>
  const T* peek_array(size_t size) const;

  template<class T>
  const T* peek_array(size_t offset, size_t size) const;

  template<class T>
  result<T> read() const;

  template<typename T>
  bool can_read() const;

  template<typename T>
  bool can_read(size_t offset) const;

  size_t align(size_t align_on) const;

  /* Functions that are endianness aware */
  template<class T>
  typename std::enable_if<std::is_integral<T>::value, result<T>>::type
  peek_conv() const;

  template<class T>
  typename std::enable_if<!std::is_integral<T>::value, result<T>>::type
  peek_conv() const;

  template<class T>
  result<T> peek_conv(size_t offset) const;

  template<class T>
  result<T> read_conv() const;

  /* Read an array of values and adjust endianness as needed */
  template<typename T>
  std::unique_ptr<T[]> read_conv_array(size_t size) const;

  template<typename T>
  std::unique_ptr<T[]> peek_conv_array(size_t offset, size_t size) const;

  template<typename T>
  static T swap_endian(T u);

  void set_endian_swap(bool swap) {
    endian_swap_ = swap;
  }

  template<class T>
  static bool is_all_zero(const T& buffer) {
    const auto* ptr = reinterpret_cast<const uint8_t *const>(&buffer);
    return std::all_of(ptr, ptr + sizeof(T),
                       [] (uint8_t x) { return x == 0; });
  }

  bool should_swap() const {
    return endian_swap_;
  }

  virtual const uint8_t* p() const  {
    return nullptr;
  }

  virtual uint8_t* start() {
    return const_cast<uint8_t*>(static_cast<const BinaryStream*>(this)->start());
  }

  virtual uint8_t* p() {
    return const_cast<uint8_t*>(static_cast<const BinaryStream*>(this)->p());
  }

  virtual uint8_t* end() {
    return const_cast<uint8_t*>(static_cast<const BinaryStream*>(this)->end());
  }

  virtual const uint8_t* start() const {
    return nullptr;
  }

  virtual const uint8_t* end() const {
    return nullptr;
  }

  protected:
  BinaryStream() = default;
  virtual result<const void*> read_at(uint64_t offset, uint64_t size) const = 0;
  virtual ok_error_t peek_in(void* dst, uint64_t offset, uint64_t size) const {
    if (auto raw = read_at(offset, size)) {
      if (dst == nullptr) {
        return make_error_code(lief_errors::read_error);
      }

      const void* ptr = *raw;

      if (ptr == nullptr) {
        return make_error_code(lief_errors::read_error);
      }

      memcpy(dst, ptr, size);
      return ok();
    }
    return make_error_code(lief_errors::read_error);
  }
  mutable size_t pos_ = 0;
  bool endian_swap_ = false;
  STREAM_TYPE stype_ = STREAM_TYPE::UNKNOWN;
};

class ScopedStream {
  public:
  ScopedStream(const ScopedStream&) = delete;
  ScopedStream& operator=(const ScopedStream&) = delete;

  ScopedStream(ScopedStream&&) = delete;
  ScopedStream& operator=(ScopedStream&&) = delete;

  explicit ScopedStream(BinaryStream& stream, uint64_t pos) :
    pos_{stream.pos()},
    stream_{stream}
  {
    stream_.setpos(pos);
  }

  explicit ScopedStream(BinaryStream& stream) :
    pos_{stream.pos()},
    stream_{stream}
  {}

  ~ScopedStream() {
    stream_.setpos(pos_);
  }

  BinaryStream* operator->() {
    return &stream_;
  }

  BinaryStream& operator*() {
    return stream_;
  }

  const BinaryStream& operator*() const {
    return stream_;
  }

  private:
  uint64_t pos_ = 0;
  BinaryStream& stream_;
};


template<class T>
result<T> BinaryStream::read() const {
  result<T> tmp = this->peek<T>();
  if (!tmp) {
    return tmp;
  }
  this->increment_pos(sizeof(T));
  return tmp;
}

template<class T>
result<T> BinaryStream::peek() const {
  const auto current_p = pos();
  T ret{};
  if (auto res = peek_in(&ret, pos(), sizeof(T))) {
    setpos(current_p);
    return ret;
  }

  setpos(current_p);
  return make_error_code(lief_errors::read_error);
}

template<class T>
result<T> BinaryStream::peek(size_t offset) const {
  const size_t saved_offset = this->pos();
  this->setpos(offset);
  result<T> r = this->peek<T>();
  this->setpos(saved_offset);
  return r;
}


template<class T>
const T* BinaryStream::peek_array(size_t size) const {
  result<const void*> raw = this->read_at(this->pos(), sizeof(T) * size);
  if (!raw) {
    return nullptr;
  }
  return reinterpret_cast<const T*>(raw.value());
}

template<class T>
const T* BinaryStream::peek_array(size_t offset, size_t size) const {
  const size_t saved_offset = this->pos();
  this->setpos(offset);
  const T* r = this->peek_array<T>(size);
  this->setpos(saved_offset);
  return r;
}


template<typename T>
bool BinaryStream::can_read() const {
  // Even though pos_ + sizeof(T) < ... => pos_ < ...
  // the addition could overflow so it's worth checking both
  return pos_ < size() && (pos_ + sizeof(T)) < size();
}


template<typename T>
bool BinaryStream::can_read(size_t offset) const {
  // Even though offset + sizeof(T) < ... => offset < ...
  // the addition could overflow so it's worth checking both
  return offset < size() && (offset + sizeof(T)) < size();
}


template<class T>
const T* BinaryStream::read_array(size_t size) const {
  const T* tmp = this->peek_array<T>(size);
  this->increment_pos(sizeof(T) * size);
  return tmp;
}


template<class T>
result<T> BinaryStream::read_conv() const {
  result<T> tmp = this->peek_conv<T>();
  if (!tmp) {
    return tmp;
  }
  this->increment_pos(sizeof(T));
  return tmp;
}

template<class T>
typename std::enable_if<std::is_integral<T>::value, result<T>>::type
BinaryStream::peek_conv() const {
  T ret;
  if (auto res = peek_in(&ret, pos(), sizeof(T))) {
    return endian_swap_ ? swap_endian<T>(ret) : ret;
  }
  return make_error_code(lief_errors::read_error);
}

template<class T>
typename std::enable_if<!std::is_integral<T>::value, result<T>>::type
BinaryStream::peek_conv() const {
  T ret;
  if (auto res = peek_in(&ret, pos(), sizeof(T))) {
    if (endian_swap_) {
      LIEF::Convert::swap_endian<T>(&ret);
    }
    return ret;
  }
  return make_error_code(lief_errors::read_error);
}


template<class T>
result<T> BinaryStream::peek_conv(size_t offset) const {
  const size_t saved_offset = this->pos();
  this->setpos(offset);
  result<T> r = this->peek_conv<T>();
  this->setpos(saved_offset);
  return r;
}


template<typename T>
std::unique_ptr<T[]> BinaryStream::read_conv_array(size_t size) const {
  const T *t = this->read_array<T>(size);

  if (t == nullptr) {
    return nullptr;
  }

  std::unique_ptr<T[]> uptr(new T[size]);

  for (size_t i = 0; i < size; i++) {
    uptr[i] = t[i];
    if (this->endian_swap_) {
      LIEF::Convert::swap_endian<T>(& uptr[i]);
    } /* else no conversion, just provide the copied data */
  }
  return uptr;
}


template<typename T>
std::unique_ptr<T[]> BinaryStream::peek_conv_array(size_t offset, size_t size) const {
  const T *t = this->peek_array<T>(offset, size);

  if (t == nullptr) {
    return nullptr;
  }

  std::unique_ptr<T[]> uptr(new T[size]);

  for (size_t i = 0; i < size; i++) {
    uptr[i] = t[i];
    if (this->endian_swap_) {
      LIEF::Convert::swap_endian<T>(& uptr[i]);
    } /* else no conversion, just provide the copied data */
  }
  return uptr;
}
}
#endif

```

`KDemu/include/LIEF/LIEF/BinaryStream/Convert.hpp`:

```hpp
/* Copyright 2021 - 2024 R. Thomas
 * Copyright 2021 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_CONVERT_H
#define LIEF_CONVERT_H
namespace LIEF {
namespace Convert {

template<typename T>
void swap_endian(T*);

}
}

#endif // LIEF_CONVERT_H

```

`KDemu/include/LIEF/LIEF/BinaryStream/FileStream.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_FILE_STREAM_H
#define LIEF_FILE_STREAM_H

#include <vector>
#include <string>
#include <fstream>

#include "LIEF/errors.hpp"
#include "LIEF/BinaryStream/BinaryStream.hpp"
namespace LIEF {

//! Stream interface over a std::ifstream
class FileStream : public BinaryStream {
  public:
  static result<FileStream> from_file(const std::string& file);
  FileStream(std::ifstream fs, uint64_t size) :
    BinaryStream(STREAM_TYPE::FILE),
    ifs_(std::move(fs)),
    size_(size)
  {}

  FileStream() = delete;

  // VectorStream should not be copyable for performances reasons
  FileStream(const FileStream&) = delete;
  FileStream& operator=(const FileStream&) = delete;

  FileStream(FileStream&& other) noexcept = default;
  FileStream& operator=(FileStream&& other) noexcept = default;

  uint64_t size() const override {
    return size_;
  }

  std::vector<uint8_t> content() const;
  ~FileStream() override = default;

  static bool classof(const BinaryStream& stream) {
    return stream.type() == STREAM_TYPE::FILE;
  }

  protected:
  ok_error_t peek_in(void* dst, uint64_t offset, uint64_t size) const override {
    if (offset > size_ || offset + size > size_) {
      return make_error_code(lief_errors::read_error);
    }
    const auto pos = ifs_.tellg();
    ifs_.seekg(offset);
    ifs_.read(static_cast<char*>(dst), size);
    ifs_.seekg(pos);
    return ok();
  }
  result<const void*> read_at(uint64_t, uint64_t) const override {
    return make_error_code(lief_errors::not_supported);
  }
  mutable std::ifstream ifs_;
  uint64_t size_ = 0;
};
}

#endif

```

`KDemu/include/LIEF/LIEF/BinaryStream/MemoryStream.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MEMORY_STREAM_H
#define LIEF_MEMORY_STREAM_H

#include <cstdint>

#include "LIEF/errors.hpp"
#include "LIEF/BinaryStream/BinaryStream.hpp"

namespace LIEF {
class Binary;
class MemoryStream : public BinaryStream {
  public:
  using BinaryStream::p;
  using BinaryStream::end;
  using BinaryStream::start;

  MemoryStream() = delete;
  MemoryStream(uintptr_t base_address);
  MemoryStream(uintptr_t base_address, uint64_t size) :
    BinaryStream(BinaryStream::STREAM_TYPE::MEMORY),
    baseaddr_(base_address),
    size_(size)
  {}

  MemoryStream(const MemoryStream&) = delete;
  MemoryStream& operator=(const MemoryStream&) = delete;

  MemoryStream(MemoryStream&&) noexcept = default;
  MemoryStream& operator=(MemoryStream&&) noexcept = default;

  uintptr_t base_address() const {
    return this->baseaddr_;
  }

  const uint8_t* p() const override {
    return start() + pos();
  }

  const uint8_t* start() const override {
    return reinterpret_cast<const uint8_t*>(baseaddr_);
  }

  const uint8_t* end() const override {
    return start() + size_;
  }

  void binary(Binary& bin) {
    this->binary_ = &bin;
  }

  Binary* binary() {
    return this->binary_;
  }

  uint64_t size() const override {
    return size_;
  }

  ~MemoryStream() override = default;

  static bool classof(const BinaryStream& stream) {
    return stream.type() == BinaryStream::STREAM_TYPE::MEMORY;
  }

  protected:
  result<const void*> read_at(uint64_t offset, uint64_t size) const override;
  uintptr_t baseaddr_ = 0;
  uint64_t size_ = 0;
  Binary* binary_ = nullptr;
};
}

#endif

```

`KDemu/include/LIEF/LIEF/BinaryStream/SpanStream.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_SPAN_STREAM_H
#define LIEF_SPAN_STREAM_H

#include <cstdint>
#include <vector>
#include <array>
#include <cstddef>

#include "LIEF/errors.hpp"
#include "LIEF/span.hpp"
#include "LIEF/BinaryStream/BinaryStream.hpp"

namespace LIEF {
class SpanStream : public BinaryStream {
  public:
  using BinaryStream::p;
  using BinaryStream::end;
  using BinaryStream::start;

  static result<SpanStream> from_vector(const std::vector<uint8_t>& data) {
    return SpanStream(data);
  }

  template<size_t N>
  static result<SpanStream> from_array(const std::array<uint8_t, N>& data) {
    return SpanStream(data.data(), N);
  }

  SpanStream(span<const uint8_t> data) :
    SpanStream(data.data(), data.size())
  {}

  SpanStream(span<uint8_t> data) :
    SpanStream(data.data(), data.size())
  {}

  SpanStream(const uint8_t* p, size_t size) :
    BinaryStream(BinaryStream::STREAM_TYPE::SPAN),
    data_{p, p + size}
  {}

  SpanStream(const std::vector<uint8_t>& data) :
    SpanStream(data.data(), data.size())
  {}

  SpanStream() = delete;

  SpanStream(const SpanStream&) = delete;
  SpanStream& operator=(const SpanStream&) = delete;

  SpanStream(SpanStream&& other) noexcept = default;
  SpanStream& operator=(SpanStream&& other) noexcept = default;

  uint64_t size() const override {
    return data_.size();
  }

  const uint8_t* p() const override {
    return data_.data() + this->pos();
  }

  const uint8_t* start() const override {
    return data_.data();
  }

  const uint8_t* end() const override {
    return data_.data() + size();
  }

  std::vector<uint8_t> content() const {
    return {data_.begin(), data_.end()};
  }

  result<SpanStream> slice(size_t offset, size_t size) const {
    if (offset > data_.size() || (offset + size) > data_.size()) {
      return make_error_code(lief_errors::read_out_of_bound);
    }
    return data_.subspan(offset, size);
  }
  result<SpanStream> slice(size_t offset) const {
    if (offset > data_.size()) {
      return make_error_code(lief_errors::read_out_of_bound);
    }
    return data_.subspan(offset, data_.size() - offset);
  }

  static bool classof(const BinaryStream& stream) {
    return stream.type() == BinaryStream::STREAM_TYPE::SPAN;
  }

  ~SpanStream() override = default;

  protected:
  result<const void*> read_at(uint64_t offset, uint64_t size) const override {
    const uint64_t stream_size = this->size();
    if (offset > stream_size || (offset + size) > stream_size) {
      return make_error_code(lief_errors::read_error);
    }
    return data_.data() + offset;
  }
  span<const uint8_t> data_;
};
}

#endif

```

`KDemu/include/LIEF/LIEF/BinaryStream/VectorStream.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef VECTOR_BINARY_STREAM_H
#define VECTOR_BINARY_STREAM_H

#include <vector>
#include <string>

#include "LIEF/errors.hpp"
#include "LIEF/BinaryStream/BinaryStream.hpp"

namespace LIEF {
class VectorStream : public BinaryStream {
  public:
  using BinaryStream::p;
  using BinaryStream::end;
  using BinaryStream::start;

  static result<VectorStream> from_file(const std::string& file);
  VectorStream(std::vector<uint8_t> data) :
    BinaryStream(BinaryStream::STREAM_TYPE::VECTOR),
    binary_(std::move(data)),
    size_(binary_.size())
  {}

  VectorStream() = delete;

  // VectorStream should not be copyable for performances reasons
  VectorStream(const VectorStream&) = delete;
  VectorStream& operator=(const VectorStream&) = delete;

  VectorStream(VectorStream&& other) noexcept = default;
  VectorStream& operator=(VectorStream&& other) noexcept = default;

  uint64_t size() const override {
    return size_;
  }

  const std::vector<uint8_t>& content() const {
    return binary_;
  }

  std::vector<uint8_t>&& move_content() {
    size_ = 0;
    return std::move(binary_);
  }

  const uint8_t* p() const override {
    return this->binary_.data() + this->pos();
  }

  const uint8_t* start() const override {
    return this->binary_.data();
  }

  const uint8_t* end() const override {

    return this->binary_.data() + this->binary_.size();
  }

  static bool classof(const BinaryStream& stream) {
    return stream.type() == STREAM_TYPE::VECTOR;
  }

  protected:
  result<const void*> read_at(uint64_t offset, uint64_t size) const override {
    const uint64_t stream_size = this->size();
    if (offset > stream_size || (offset + size) > stream_size) {
      return make_error_code(lief_errors::read_error);
    }
    return binary_.data() + offset;
  }
  std::vector<uint8_t> binary_;
  uint64_t size_ = 0; // Original size without alignment
};
}

#endif

```

`KDemu/include/LIEF/LIEF/DEX.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_DEX_H
#define LIEF_DEX_H
#include "LIEF/config.h"

#if defined(LIEF_DEX_SUPPORT)
#include "LIEF/DEX/Parser.hpp"
#include "LIEF/DEX/utils.hpp"
#include "LIEF/DEX/File.hpp"
#include "LIEF/DEX/Class.hpp"
#include "LIEF/DEX/Prototype.hpp"
#include "LIEF/DEX/Header.hpp"
#include "LIEF/DEX/Method.hpp"
#include "LIEF/DEX/Field.hpp"
#include "LIEF/DEX/EnumToString.hpp"
#endif

#endif

```

`KDemu/include/LIEF/LIEF/DEX/Class.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_DEX_CLASS_H
#define LIEF_DEX_CLASS_H

#include <climits>

#include "LIEF/visibility.h"
#include "LIEF/Object.hpp"
#include "LIEF/iterators.hpp"

#include "LIEF/DEX/enums.hpp"
#include "LIEF/DEX/deopt.hpp"

namespace LIEF {
namespace DEX {
class Parser;
class Field;
class Method;

//! Class which represents a DEX Class (i.e. a Java/Kotlin class)
class LIEF_API Class : public Object {
  friend class Parser;

  public:
  using access_flags_list_t = std::vector<ACCESS_FLAGS>;

  using methods_t = std::vector<Method*>;
  using it_methods = ref_iterator<methods_t&>;
  using it_const_methods = const_ref_iterator<const methods_t&>;

  using fields_t = std::vector<Field*>;
  using it_fields = ref_iterator<fields_t&>;
  using it_const_fields = const_ref_iterator<const fields_t&>;

  using it_named_methods = filter_iterator<methods_t&>;
  using it_const_named_methods = const_filter_iterator<const methods_t&>;

  using it_named_fields = filter_iterator<fields_t&>;
  using it_const_named_fields = const_filter_iterator<const fields_t&>;

  public:
  static std::string package_normalized(const std::string& pkg_name);
  static std::string fullname_normalized(const std::string& pkg_cls);
  static std::string fullname_normalized(const std::string& pkg, const std::string& cls_name);

  Class();
  Class(const Class&) = delete;
  Class& operator=(const Class&) = delete;

  Class(std::string fullname, uint32_t access_flags = ACCESS_FLAGS::ACC_UNKNOWN,
        Class* parent = nullptr, std::string source_filename = "");

  //! Mangled class name (e.g. ``Lcom/example/android/MyActivity;``)
  const std::string& fullname() const;

  //! Package Name
  std::string package_name() const;

  //! Class name
  std::string name() const;

  //! Demangled class name
  std::string pretty_name() const;

  //! Check if the class has the given access flag
  bool has(ACCESS_FLAGS f) const;

  //! Access flags used by this class
  access_flags_list_t access_flags() const;

  //! Filename associated with this class (if any)
  const std::string& source_filename() const;

  //! True if the current class extends another one
  bool has_parent() const;

  //! Parent class
  const Class* parent() const;
  Class* parent();

  //! Methods implemented in this class
  it_const_methods methods() const;
  it_methods methods();

  //! Return Methods having the given name
  it_named_methods methods(const std::string& name);
  it_const_named_methods methods(const std::string& name) const;

  //! Fields implemented in this class
  it_const_fields fields() const;
  it_fields fields();

  //! Return Fields having the given name
  it_named_fields fields(const std::string& name);
  it_const_named_fields fields(const std::string& name) const;

  //! De-optimize information
  dex2dex_class_info_t dex2dex_info() const;

  //! Original index in the DEX class pool
  size_t index() const;

  void accept(Visitor& visitor) const override;


  LIEF_API friend std::ostream& operator<<(std::ostream& os, const Class& cls);

  ~Class() override;

  private:
  std::string fullname_;
  uint32_t    access_flags_ = ACCESS_FLAGS::ACC_UNKNOWN;
  Class*      parent_ = nullptr;
  methods_t   methods_;
  fields_t    fields_;
  std::string source_filename_;

  uint32_t original_index_ = UINT_MAX;
};

} // Namespace DEX
} // Namespace LIEF
#endif

```

`KDemu/include/LIEF/LIEF/DEX/CodeInfo.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_DEX_CODE_INFO_H
#define LIEF_DEX_CODE_INFO_H

#include <cstdint>
#include <ostream>

#include "LIEF/visibility.h"
#include "LIEF/Object.hpp"

namespace LIEF {
namespace DEX {
namespace details {
struct code_item;
}

class Parser;

class LIEF_API CodeInfo : public Object {
  friend class Parser;

  public:
  CodeInfo();
  CodeInfo(const details::code_item& codeitem);

  CodeInfo(const CodeInfo&);
  CodeInfo& operator=(const CodeInfo&);

  void accept(Visitor& visitor) const override;


  ~CodeInfo() override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const CodeInfo& cinfo);

  private:
  uint16_t nb_registers_ = 0;
  uint16_t args_input_sizes_ = 0;
  uint16_t output_sizes_ = 0;

};

} // Namespace DEX
} // Namespace LIEF
#endif

```

`KDemu/include/LIEF/LIEF/DEX/EnumToString.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_DEX_ENUM_TO_STRING_H
#define LIEF_DEX_ENUM_TO_STRING_H
#include "LIEF/visibility.h"
#include "LIEF/DEX/enums.hpp"
#include "LIEF/DEX/MapItem.hpp"
#include "LIEF/DEX/Type.hpp"

namespace LIEF {
namespace DEX {

LIEF_API const char* to_string(MapItem::TYPES e);
LIEF_API const char* to_string(ACCESS_FLAGS e);
LIEF_API const char* to_string(Type::TYPES e);
LIEF_API const char* to_string(Type::PRIMITIVES e);

} // namespace DEX
} // namespace LIEF

#endif


```

`KDemu/include/LIEF/LIEF/DEX/Field.hpp`:

```hpp
/* Copyright 2021 - 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_DEX_FIELD_H
#define LIEF_DEX_FIELD_H

#include <climits>
#include <cstdint>

#include "LIEF/DEX/enums.hpp"

#include "LIEF/visibility.h"
#include "LIEF/Object.hpp"

#include "LIEF/DEX/Type.hpp"

namespace LIEF {
namespace DEX {
class Parser;
class Class;

//! Class which represent a DEX Field
class LIEF_API Field : public Object {
  friend class Parser;
  public:
  using access_flags_list_t = std::vector<ACCESS_FLAGS>;

  public:
  Field();
  Field(std::string name, Class* parent = nullptr);

  Field(const Field&);
  Field& operator=(const Field&);

  //! Name of the Field
  const std::string& name() const;

  //! True if a class is associated with this field
  //! (which should be the case)
  bool has_class() const;

  //! Class associated with this Field
  const Class* cls() const;
  Class* cls();

  //! Index in the DEX Fields pool
  size_t index() const;

  //! True if this field is a static one.
  bool is_static() const;

  //! Field's prototype
  const Type* type() const;
  Type* type();

  void accept(Visitor& visitor) const override;

  //! Check if the field has the given ACCESS_FLAGS
  bool has(ACCESS_FLAGS f) const;

  //! ACCESS_FLAGS as a list
  access_flags_list_t access_flags() const;


  LIEF_API friend std::ostream& operator<<(std::ostream& os, const Field& mtd);

  ~Field() override;

  private:
  void set_static(bool v);

  private:
  std::string name_;
  Class* parent_ = nullptr;
  Type* type_ = nullptr;
  uint32_t access_flags_ = 0;
  uint32_t original_index_ = UINT_MAX;
  bool is_static_ = false;
};

} // Namespace DEX
} // Namespace LIEF
#endif

```

`KDemu/include/LIEF/LIEF/DEX/File.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_DEX_FILE_H
#define LIEF_DEX_FILE_H
#include <memory>

#include "LIEF/visibility.h"
#include "LIEF/Object.hpp"

#include "LIEF/DEX/Header.hpp"
#include "LIEF/DEX/MapList.hpp"
#include "LIEF/DEX/instructions.hpp"
#include "LIEF/DEX/deopt.hpp"
#include "LIEF/DEX/types.hpp"

namespace LIEF {
namespace DEX {
class Parser;
class Class;
class Method;
class Type;
class Prototype;
class Field;

//! Class that represents a DEX file
class LIEF_API File : public Object {
  friend class Parser;

  public:
  using classes_t = std::unordered_map<std::string, Class*>;
  using classes_list_t = std::vector<std::unique_ptr<Class>>;
  using it_classes = ref_iterator<classes_list_t&, Class*>;
  using it_const_classes = const_ref_iterator<const classes_list_t&, const Class*>;

  using methods_t = std::vector<std::unique_ptr<Method>>;
  using it_methods = ref_iterator<methods_t&, Method*>;
  using it_const_methods = const_ref_iterator<const methods_t&, const Method*>;

  using strings_t           = std::vector<std::unique_ptr<std::string>>;
  using it_strings          = ref_iterator<strings_t&, std::string*>;
  using it_const_strings    = const_ref_iterator<const strings_t&, const std::string*>;

  using types_t             = std::vector<std::unique_ptr<Type>>;
  using it_types            = ref_iterator<types_t&, Type*>;
  using it_const_types      = const_ref_iterator<const types_t&, const Type*>;

  using prototypes_t        = std::vector<std::unique_ptr<Prototype>>;
  using it_prototypes       = ref_iterator<prototypes_t&, Prototype*>;
  using it_const_prototypes = const_ref_iterator<const prototypes_t&, const Prototype*>;

  using fields_t            = std::vector<std::unique_ptr<Field>>;
  using it_fields           = ref_iterator<fields_t&, Field*>;
  using it_const_fields     = const_ref_iterator<const fields_t&, const Field*>;

  public:
  File& operator=(const File& copy) = delete;
  File(const File& copy)            = delete;

  //! Version of the current DEX file
  dex_version_t version() const;

  //! Name of this file
  const std::string& name() const;

  void name(const std::string& name);

  //! Location of this file
  const std::string& location() const;
  void location(const std::string& location);

  //! DEX header
  const Header& header() const;
  Header& header();

  //! **All** classes used in the DEX file
  it_const_classes classes() const;
  it_classes classes();

  //! Check if the given class name exists
  bool has_class(const std::string& class_name) const;

  //! Return the DEX::Class object associated with the given name
  const Class* get_class(const std::string& class_name) const;

  Class* get_class(const std::string& class_name);

  //! Return the DEX::Class object associated with the given index
  const Class* get_class(size_t index) const;

  Class* get_class(size_t index);

  //! De-optimize information
  dex2dex_info_t dex2dex_info() const;

  //! De-optimize information as JSON
  std::string dex2dex_json_info() const;

  //! Return an iterator over **all** the DEX::Method used in this DEX file
  it_const_methods methods() const;
  it_methods methods();

  //! Return an iterator over **all** the DEX::Field used in this DEX file
  it_const_fields fields() const;
  it_fields fields();

  //! String pool
  it_const_strings strings() const;
  it_strings strings();

  //! Type pool
  it_const_types types() const;
  it_types types();

  //! Prototype pool
  it_prototypes prototypes();
  it_const_prototypes prototypes() const;

  //! DEX Map
  const MapList& map() const;
  MapList& map();

  //! Extract the current dex file and deoptimize it
  std::string save(const std::string& path = "", bool deoptimize = true) const;

  std::vector<uint8_t> raw(bool deoptimize = true) const;

  void accept(Visitor& visitor) const override;


  ~File() override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const File& file);

  private:
  File();

  void add_class(std::unique_ptr<Class> cls);

  static void deoptimize_nop(uint8_t* inst_ptr, uint32_t value);
  static void deoptimize_return(uint8_t* inst_ptr, uint32_t value);
  static void deoptimize_invoke_virtual(uint8_t* inst_ptr, uint32_t value, OPCODES new_inst);
  static void deoptimize_instance_field_access(uint8_t* inst_ptr, uint32_t value, OPCODES new_inst);

  std::string name_;
  std::string location_;

  Header       header_;
  classes_t    classes_;
  methods_t    methods_;
  fields_t     fields_;
  strings_t    strings_;
  types_t      types_;
  prototypes_t prototypes_;
  MapList      map_;

  classes_list_t class_list_;
  std::vector<uint8_t> original_data_;
};

}
}

#endif

```

`KDemu/include/LIEF/LIEF/DEX/Header.hpp`:

```hpp

/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_DEX_HEADER_H
#define LIEF_DEX_HEADER_H

#include <array>
#include <utility>
#include <cstdint>
#include <ostream>

#include "LIEF/visibility.h"
#include "LIEF/Object.hpp"

namespace LIEF {
class Visitor;

namespace DEX {
class Parser;

//! Class which represents the DEX header.
//! This is the first structure that begins the DEX format.
//!
//! The official documentation is provided here:
//! https://source.android.com/devices/tech/dalvik/dex-format#header-item
class LIEF_API Header : public Object {
  friend class Parser;

  public:
  using location_t = std::pair<uint32_t, uint32_t>;

  using magic_t     = std::array<uint8_t, 8>;
  using signature_t = std::array<uint8_t, 20>;

  Header();
  Header(const Header&);
  Header& operator=(const Header&);

  template<class T>
  LIEF_LOCAL Header(const T& header);

  //! The DEX magic bytes (``DEX\n`` followed by the DEX version)
  magic_t magic() const;

  //! The file checksum
  uint32_t checksum() const;

  //! SHA-1 DEX signature (which is not really used as a signature)
  signature_t signature() const;

  //! Size of the entire file (including the current the header)
  uint32_t file_size() const;

  //! Size of this header. It should be 0x70
  uint32_t header_size() const;

  //! File endianess of the file
  uint32_t endian_tag() const;

  //! Offset from the start of the file to the map list (see: DEX::MapList)
  uint32_t map() const;

  //! Offset and size of the string pool
  location_t strings() const;
  location_t link() const;
  location_t types() const;
  location_t prototypes() const;
  location_t fields() const;
  location_t methods() const;
  location_t classes() const;
  location_t data() const;

  uint32_t nb_classes() const;

  uint32_t nb_methods() const;

  void accept(Visitor& visitor) const override;


  LIEF_API friend std::ostream& operator<<(std::ostream& os, const Header& hdr);

  ~Header() override;

  private:
  magic_t magic_;
  uint32_t checksum_;
  signature_t signature_;
  uint32_t file_size_;

  uint32_t header_size_;
  uint32_t endian_tag_;

  uint32_t link_size_;
  uint32_t link_off_;

  uint32_t map_off_;

  uint32_t string_ids_size_;
  uint32_t string_ids_off_;

  uint32_t type_ids_size_;
  uint32_t type_ids_off_;

  uint32_t proto_ids_size_;
  uint32_t proto_ids_off_;

  uint32_t field_ids_size_;
  uint32_t field_ids_off_;

  uint32_t method_ids_size_;
  uint32_t method_ids_off_;

  uint32_t class_defs_size_;
  uint32_t class_defs_off_;

  uint32_t data_size_;
  uint32_t data_off_;
};

} // Namespace DEX
} // Namespace LIEF

#endif

```

`KDemu/include/LIEF/LIEF/DEX/MapItem.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MAP_ITEM_H
#define LIEF_MAP_ITEM_H

#include <cstdint>
#include <ostream>

#include "LIEF/visibility.h"
#include "LIEF/Object.hpp"

namespace LIEF {
namespace DEX {
class Parser;
class Class;

//! Class which represents an element of the MapList object
class LIEF_API MapItem : public Object {
  friend class Parser;

  public:
  enum class TYPES : uint16_t {
    HEADER                  = 0x0000,
    STRING_ID               = 0x0001,
    TYPE_ID                 = 0x0002,
    PROTO_ID                = 0x0003,
    FIELD_ID                = 0x0004,
    METHOD_ID               = 0x0005,
    CLASS_DEF               = 0x0006,
    CALL_SITE_ID            = 0x0007,
    METHOD_HANDLE           = 0x0008,
    MAP_LIST                = 0x1000,
    TYPE_LIST               = 0x1001,
    ANNOTATION_SET_REF_LIST = 0x1002,
    ANNOTATION_SET          = 0x1003,
    CLASS_DATA              = 0x2000,
    CODE                    = 0x2001,
    STRING_DATA             = 0x2002,
    DEBUG_INFO              = 0x2003,
    ANNOTATION              = 0x2004,
    ENCODED_ARRAY           = 0x2005,
    ANNOTATIONS_DIRECTORY   = 0x2006,

  };

  public:
  MapItem();
  MapItem(TYPES type, uint32_t offset, uint32_t size, uint16_t reserved = 0);

  MapItem(const MapItem&);
  MapItem& operator=(const MapItem&);

  //! The type of the item
  TYPES type() const;

  //! Reserved value (likely for alignment prupose)
  uint16_t reserved() const;

  //! The number of elements (the real meaning depends on the type)
  uint32_t size() const;

  //! Offset from the start of the DEX file to the items associated with
  //! the underlying TYPES
  uint32_t offset() const;

  void accept(Visitor& visitor) const override;


  LIEF_API friend std::ostream& operator<<(std::ostream& os, const MapItem& item);

  ~MapItem() override;

  private:
  TYPES    type_;
  uint16_t reserved_;
  uint32_t size_;
  uint32_t offset_;

};

} // Namespace DEX
} // Namespace LIEF
#endif

```

`KDemu/include/LIEF/LIEF/DEX/MapList.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MAP_LIST_H
#define LIEF_MAP_LIST_H
#include <map>
#include <vector>

#include "LIEF/visibility.h"
#include "LIEF/iterators.hpp"
#include "LIEF/Object.hpp"

#include "LIEF/DEX/MapItem.hpp"

namespace LIEF {
namespace DEX {
class Parser;
class Class;

//! Class which represents the ``map_list`` structure that
//! follows the main DEX header.
//!
//! This MapList aims at referencing the location of other DEX structures as
//! described in https://source.android.com/devices/tech/dalvik/dex-format#map-item
class LIEF_API MapList : public Object {
  friend class Parser;

  public:
  using items_t           = std::map<MapItem::TYPES, MapItem>;
  using it_items_t        = ref_iterator<std::vector<MapItem*>>;
  using it_const_items_t  = const_ref_iterator<std::vector<MapItem*>>;

  public:
  MapList();

  MapList(const MapList&);
  MapList& operator=(const MapList&);

  //! Iterator over LIEF::DEX::MapItem
  it_items_t items();
  it_const_items_t items() const;

  //! Check if the given type exists
  bool has(MapItem::TYPES type) const;

  //! Return the LIEF::DEX::MapItem associated with the given type
  const MapItem& get(MapItem::TYPES type) const;

  //! Return the LIEF::DEX::MapItem associated with the given type
  MapItem& get(MapItem::TYPES type);

  //! Return the LIEF::DEX::MapItem associated with the given type
  const MapItem& operator[](MapItem::TYPES type) const;

  //! Return the LIEF::DEX::MapItem associated with the given type
  MapItem& operator[](MapItem::TYPES type);

  void accept(Visitor& visitor) const override;


  LIEF_API friend std::ostream& operator<<(std::ostream& os, const MapList& mtd);

  ~MapList() override;

  private:
  items_t items_;

};

} // Namespace DEX
} // Namespace LIEF
#endif

```

`KDemu/include/LIEF/LIEF/DEX/Method.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_DEX_METHOD_H
#define LIEF_DEX_METHOD_H

#include <climits>
#include <vector>

#include "LIEF/visibility.h"
#include "LIEF/Object.hpp"

#include "LIEF/DEX/enums.hpp"
#include "LIEF/DEX/CodeInfo.hpp"
#include "LIEF/DEX/deopt.hpp"

namespace LIEF {
namespace DEX {
class Parser;
class Class;
class Prototype;

//! Class which represents a DEX::Method
class LIEF_API Method : public Object {
  friend class Parser;
  public:
  using access_flags_list_t = std::vector<ACCESS_FLAGS>;

  public:
  using bytecode_t = std::vector<uint8_t>;
  Method();
  Method(std::string name, Class* parent = nullptr);

  Method(const Method&);
  Method& operator=(const Method&);

  //! Name of the Method
  const std::string& name() const;

  //! True if a class is associated with this method
  bool has_class() const;

  //! DEX::Class associated with this Method or a nullptr
  //! if not resolved
  const Class* cls() const;
  Class* cls();

  //! Offset to the Dalvik Bytecode
  uint64_t code_offset() const;

  //! Dalvik Bytecode as bytes
  const bytecode_t& bytecode() const;

  //! Index in the DEX Methods pool
  size_t index() const;

  //! True if this method is a virtual one.
  //! i.e. not **static**, **private**, **finale** or constructor
  bool is_virtual() const;

  //! Method's prototype or a nullptr if it is not resolved
  const Prototype* prototype() const;
  Prototype* prototype();

  void insert_dex2dex_info(uint32_t pc, uint32_t index);

  void accept(Visitor& visitor) const override;

  const dex2dex_method_info_t& dex2dex_info() const;

  //! Check if the current method has the given ACCESS_FLAGS
  bool has(ACCESS_FLAGS f) const;

  //! ACCESS_FLAGS as an std::set
  access_flags_list_t access_flags() const;


  LIEF_API friend std::ostream& operator<<(std::ostream& os, const Method& mtd);

  ~Method() override;

  private:
  void set_virtual(bool v);

  private:
  std::string name_;
  Class* parent_ = nullptr;
  Prototype* prototype_ = nullptr;
  uint32_t access_flags_ = ACCESS_FLAGS::ACC_UNKNOWN;
  uint32_t original_index_ = UINT_MAX;
  bool is_virtual_ = false;

  uint64_t code_offset_ = 0;
  std::vector<uint8_t> bytecode_;

  CodeInfo code_info_;

  dex2dex_method_info_t dex2dex_info_;

};

} // Namespace DEX
} // Namespace LIEF
#endif

```

`KDemu/include/LIEF/LIEF/DEX/Parser.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_DEX_PARSER_H
#define LIEF_DEX_PARSER_H

#include <memory>
#include <vector>
#include <string>
#include <unordered_map>

#include "LIEF/visibility.h"
#include "LIEF/DEX/types.hpp"

namespace LIEF {
class VectorStream;

namespace DEX {
class Class;
class Method;
class Field;
class File;
class Type;

//! Class which parses a DEX file to produce a DEX::File object
class LIEF_API Parser {
  public:

  //! Parse the DEX file from the file path given in parameter
  static std::unique_ptr<File> parse(const std::string& file);
  static std::unique_ptr<File> parse(std::vector<uint8_t> data, const std::string& name = "");

  Parser& operator=(const Parser& copy) = delete;
  Parser(const Parser& copy)            = delete;

  private:
  Parser();
  Parser(const std::string& file);
  Parser(std::vector<uint8_t> data);
  ~Parser();

  void init(const std::string& name, dex_version_t version);

  template<typename DEX_T>
  void parse_file();

  template<typename DEX_T>
  void parse_header();

  template<typename DEX_T>
  void parse_map();

  template<typename DEX_T>
  void parse_strings();

  template<typename DEX_T>
  void parse_types();

  template<typename DEX_T>
  void parse_fields();

  template<typename DEX_T>
  void parse_prototypes();

  template<typename DEX_T>
  void parse_methods();

  template<typename DEX_T>
  void parse_classes();

  template<typename DEX_T>
  void parse_class_data(uint32_t offset, Class& cls);

  template<typename DEX_T>
  void parse_field(size_t index, Class& cls, bool is_static);

  template<typename DEX_T>
  void parse_method(size_t index, Class& cls, bool is_virtual);

  template<typename DEX_T>
  void parse_code_info(uint32_t offset, Method& method);

  void resolve_inheritance();

  void resolve_external_methods();

  void resolve_external_fields();

  void resolve_types();

  std::unique_ptr<File> file_;

  // Map of inheritance relationship when parsing classes ('parse_classes')
  // The key is the parent class name of the value
  std::unordered_multimap<std::string, Class*> inheritance_;

  // Map of method/class relationship when parsing methods ('parse_methods')
  // The key is the Class name in which the method is defined
  std::unordered_multimap<std::string, Method*> class_method_map_;

  // Map of field/class relationship when parsing fields ('parse_fields')
  // The key is the Class name in which the field is defined
  std::unordered_multimap<std::string, Field*> class_field_map_;

  std::unordered_multimap<std::string, Type*> class_type_map_;

  std::unique_ptr<VectorStream> stream_;
};

} // namespace DEX
} // namespace LIEF
#endif

```

`KDemu/include/LIEF/LIEF/DEX/Prototype.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_DEX_PROTOTYPE_H
#define LIEF_DEX_PROTOTYPE_H

#include "LIEF/visibility.h"
#include "LIEF/Object.hpp"
#include "LIEF/iterators.hpp"

namespace LIEF {
namespace DEX {
class Parser;
class Type;

//! Class which represents a DEX method prototype
class LIEF_API Prototype : public Object {
  friend class Parser;

  public:
  using parameters_type_t = std::vector<Type*>;
  using it_params         = ref_iterator<parameters_type_t>;
  using it_const_params   = const_ref_iterator<const parameters_type_t>;

  public:
  Prototype();
  Prototype(const Prototype& other);

  //! Type returned or a nullptr if not resolved
  const Type* return_type() const;
  Type* return_type();

  //! Types of the parameters
  it_const_params parameters_type() const;
  it_params parameters_type();

  void accept(Visitor& visitor) const override;


  LIEF_API friend std::ostream& operator<<(std::ostream& os, const Prototype& type);

  ~Prototype() override;

  private:
  Type* return_type_ = nullptr;
  parameters_type_t params_;

};

} // Namespace DEX
} // Namespace LIEF
#endif

```

`KDemu/include/LIEF/LIEF/DEX/Type.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_DEX_TYPE_H
#define LIEF_DEX_TYPE_H

#include <vector>
#include <string>
#include <ostream>

#include "LIEF/visibility.h"
#include "LIEF/Object.hpp"

namespace LIEF {
namespace DEX {
class Parser;
class Class;

//! Class which represents a DEX type as described in the
//! format specifications: https://source.android.com/devices/tech/dalvik/dex-format#typedescriptor
class LIEF_API Type : public Object {
  friend class Parser;

  public:
  enum class TYPES {
    UNKNOWN   = 0,
    PRIMITIVE = 1,
    CLASS     = 2,
    ARRAY     = 3,
  };

  enum class PRIMITIVES {
    VOID_T  = 0x01,
    BOOLEAN = 0x02,
    BYTE    = 0x03,
    SHORT   = 0x04,
    CHAR    = 0x05,
    INT     = 0x06,
    LONG    = 0x07,
    FLOAT   = 0x08,
    DOUBLE  = 0x09,
  };

  using array_t = std::vector<Type>;

  public:
  static std::string pretty_name(PRIMITIVES p);

  public:
  Type();
  Type(const std::string& mangled);
  Type(const Type& other);

  //! Whether it is a primitive type, a class, ...
  TYPES type() const;

  const Class& cls() const;
  const array_t& array() const;
  const PRIMITIVES& primitive() const;

  //! **IF** the current type is a TYPES::CLASS, return the
  //! associated DEX::CLASS. Otherwise the returned value is **undefined**.
  Class& cls();

  //! **IF** the current type is a TYPES::ARRAY, return the
  //! associated array. Otherwise the returned value is **undefined**.
  array_t& array();

  //! **IF** the current type is a TYPES::PRIMITIVE, return the
  //! associated PRIMITIVES. Otherwise the returned value is **undefined**.
  PRIMITIVES& primitive();

  //! Return the array dimension if the current type is
  //! an array. Otherwise it returns 0
  size_t dim() const;

  //! In the case of a TYPES::ARRAY, return the array's type
  const Type& underlying_array_type() const;
  Type& underlying_array_type();

  void accept(Visitor& visitor) const override;


  LIEF_API friend std::ostream& operator<<(std::ostream& os, const Type& type);

  ~Type() override;

  private:
  void parse(const std::string& type);

  TYPES type_{TYPES::UNKNOWN};
  union {
    Class* cls_{nullptr};
    array_t* array_;
    PRIMITIVES* basic_;
  };
};

} // Namespace DEX
} // Namespace LIEF
#endif

```

`KDemu/include/LIEF/LIEF/DEX/deopt.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_DEX_DEOPT_TYPES_H
#define LIEF_DEX_DEOPT_TYPES_H
#include <cstdint>
#include <unordered_map>

namespace LIEF {
namespace DEX {
class Class;
class Method;

// Method Index: {dex_pc: index, ...}
using dex2dex_method_info_t = std::unordered_map<uint32_t, uint32_t>;
using dex2dex_class_info_t  = std::unordered_map<Method*, dex2dex_method_info_t>;
using dex2dex_info_t        = std::unordered_map<Class*, dex2dex_class_info_t>;

}
}

#endif

```

`KDemu/include/LIEF/LIEF/DEX/enums.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_DEX_ENUMS_H
#define LIEF_DEX_ENUMS_H

namespace LIEF {
namespace DEX {

enum ACCESS_FLAGS {
  ACC_UNKNOWN               = 0x0,
  ACC_PUBLIC                = 0x1,
  ACC_PRIVATE               = 0x2,
  ACC_PROTECTED             = 0x4,
  ACC_STATIC                = 0x8,
  ACC_FINAL                 = 0x10,
  ACC_SYNCHRONIZED          = 0x20,
  ACC_VOLATILE              = 0x40,
  ACC_BRIDGE                = 0x40,
  ACC_TRANSIENT             = 0x80,
  ACC_VARARGS               = 0x80,
  ACC_NATIVE                = 0x100,
  ACC_INTERFACE             = 0x200,
  ACC_ABSTRACT              = 0x400,
  ACC_STRICT                = 0x800,
  ACC_SYNTHETIC             = 0x1000,
  ACC_ANNOTATION            = 0x2000,
  ACC_ENUM                  = 0x4000,
  ACC_CONSTRUCTOR           = 0x10000,
  ACC_DECLARED_SYNCHRONIZED = 0x20000
};


enum METHOD_TYPES {
  METHOD_UNKNOWN      = 0x00,
  METHOD_VIRTUAL      = 0x01,
  METHOD_DIRECT       = 0x02, // Deprecated

  METHOD_EXTERN       = 0x03,
  METHOD_CTOR         = 0x04,
  METHOD_STATIC       = 0x05,
  METHOD_STATIC_CTOR  = 0x06,
};

static const ACCESS_FLAGS access_flags_list[] = {
  ACCESS_FLAGS::ACC_UNKNOWN,
  ACCESS_FLAGS::ACC_PUBLIC,
  ACCESS_FLAGS::ACC_PRIVATE,
  ACCESS_FLAGS::ACC_PROTECTED,
  ACCESS_FLAGS::ACC_STATIC,
  ACCESS_FLAGS::ACC_FINAL,
  ACCESS_FLAGS::ACC_SYNCHRONIZED,
  ACCESS_FLAGS::ACC_VOLATILE,
  ACCESS_FLAGS::ACC_BRIDGE,
  ACCESS_FLAGS::ACC_TRANSIENT,
  ACCESS_FLAGS::ACC_VARARGS,
  ACCESS_FLAGS::ACC_NATIVE,
  ACCESS_FLAGS::ACC_INTERFACE,
  ACCESS_FLAGS::ACC_ABSTRACT,
  ACCESS_FLAGS::ACC_STRICT,
  ACCESS_FLAGS::ACC_SYNTHETIC,
  ACCESS_FLAGS::ACC_ANNOTATION,
  ACCESS_FLAGS::ACC_ENUM,
  ACCESS_FLAGS::ACC_CONSTRUCTOR,
  ACCESS_FLAGS::ACC_DECLARED_SYNCHRONIZED,
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/DEX/hash.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_DEX_HASH_H
#define LIEF_DEX_HASH_H

#include "LIEF/visibility.h"
#include "LIEF/hash.hpp"

namespace LIEF {
class Object;

namespace DEX {

class Class;
class Field;
class File;
class Header;
class MapItem;
class MapList;
class Method;
class Prototype;
class CodeInfo;
class Type;

//! Class which implements a visitor to compute
//! a **deterministic** hash for LIEF DEX objects
class LIEF_API Hash : public LIEF::Hash {
  public:
  static LIEF::Hash::value_type hash(const Object& obj);

  public:
  using LIEF::Hash::Hash;
  using LIEF::Hash::visit;

  public:
  void visit(const File& file)          override;
  void visit(const Header& header)      override;
  void visit(const Class& cls)          override;
  void visit(const Field& field)        override;
  void visit(const Method& method)      override;
  void visit(const CodeInfo& code_info) override;
  void visit(const Type& type)          override;
  void visit(const Prototype& type)     override;
  void visit(const MapItem& item)       override;
  void visit(const MapList& list)       override;

  ~Hash() override;
};

}
}

#endif

```

`KDemu/include/LIEF/LIEF/DEX/instructions.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_DEX_INSTRUCTIONS_H
#define LIEF_DEX_INSTRUCTIONS_H
#include "LIEF/visibility.h"
#include "LIEF/types.hpp"
#include <cstddef>

namespace LIEF {
namespace DEX {

enum SWITCH_ARRAY_IDENT : uint16_t {
  IDENT_PACKED_SWITCH = 0x0100,
  IDENT_SPARSE_SWITCH = 0x0200,
  IDENT_FILL_ARRAY    = 0x0300,
};

//! The Dalvik Opcodes
enum OPCODES : uint8_t {
  OP_NOP                    = 0x00,
  OP_MOVE                   = 0x01,
  OP_MOVE_FROM_16           = 0x02,
  OP_MOVE_16                = 0x03,
  OP_MOVE_WIDE              = 0x04,
  OP_MOVE_WIDE_FROM_16      = 0x05,
  OP_MOVE_WIDE_16           = 0x06,
  OP_MOVE_OBJECT            = 0x07,
  OP_MOVE_OBJECT_FROM_16    = 0x08,
  OP_MOVE_OBJECT_16         = 0x09,
  OP_MOVE_RESULT            = 0x0a,
  OP_MOVE_RESULT_WIDE       = 0x0b,
  OP_MOVE_RESULT_OBJECT     = 0x0c,
  OP_MOVE_EXCEPTION         = 0x0d,
  OP_RETURN_VOID            = 0x0e,
  OP_RETURN                 = 0x0f,
  OP_RETURN_WIDE            = 0x10,
  OP_RETURN_OBJECT          = 0x11,
  OP_CONST_4                = 0x12,
  OP_CONST_16               = 0x13,
  OP_CONST                  = 0x14,
  OP_CONST_HIGH_16          = 0x15,
  OP_CONST_WIDE_16          = 0x16,
  OP_CONST_WIDE_32          = 0x17,
  OP_CONST_WIDE             = 0x18,
  OP_CONST_WIDE_HIGH_16     = 0x19,
  OP_CONST_STRING           = 0x1a,
  OP_CONST_STRING_JUMBO     = 0x1b,
  OP_CONST_CLASS            = 0x1c,
  OP_MONITOR_ENTER          = 0x1d,
  OP_MONITOR_EXIT           = 0x1e,
  OP_CHECK_CAST             = 0x1f,
  OP_INSTANCE_OF            = 0x20,
  OP_ARRAY_LENGTH           = 0x21,
  OP_NEW_INSTANCE           = 0x22,
  OP_NEW_ARRAY              = 0x23,
  OP_FILLED_NEW_ARRAY       = 0x24,
  OP_FILLED_NEW_ARRAY_RANGE = 0x25,
  OP_FILL_ARRAY_DATA        = 0x26,
  OP_THROW                  = 0x27,
  OP_GOTO                   = 0x28,
  OP_GOTO_16                = 0x29,
  OP_GOTO_32                = 0x2a,
  OP_PACKED_SWITCH          = 0x2b,
  OP_SPARSE_SWITCH          = 0x2c,
  OP_CMPL_FLOAT             = 0x2d,
  OP_CMPG_FLOAT             = 0x2e,
  OP_CMPL_DOUBLE            = 0x2f,
  OP_CMPG_DOUBLE            = 0x30,
  OP_CMP_LONG               = 0x31,
  OP_IF_EQ                  = 0x32,
  OP_IF_NE                  = 0x33,
  OP_IF_LT                  = 0x34,
  OP_IF_GE                  = 0x35,
  OP_IF_GT                  = 0x36,
  OP_IF_LE                  = 0x37,
  OP_IF_EQZ                 = 0x38,
  OP_IF_NEZ                 = 0x39,
  OP_IF_LTZ                 = 0x3a,
  OP_IF_GEZ                 = 0x3b,
  OP_IF_GTZ                 = 0x3c,
  OP_IF_LEZ                 = 0x3d,
  OP_AGET                   = 0x44,
  OP_AGET_WIDE              = 0x45,
  OP_AGET_OBJECT            = 0x46,
  OP_AGET_BOOLEAN           = 0x47,
  OP_AGET_BYTE              = 0x48,
  OP_AGET_CHAR              = 0x49,
  OP_AGET_SHORT             = 0x4a,
  OP_APUT                   = 0x4b,
  OP_APUT_WIDE              = 0x4c,
  OP_APUT_OBJECT            = 0x4d,
  OP_APUT_BOOLEAN           = 0x4e,
  OP_APUT_BYTE              = 0x4f,
  OP_APUT_CHAR              = 0x50,
  OP_APUT_SHORT             = 0x51,
  OP_IGET                   = 0x52,
  OP_IGET_WIDE              = 0x53,
  OP_IGET_OBJECT            = 0x54,
  OP_IGET_BOOLEAN           = 0x55,
  OP_IGET_BYTE              = 0x56,
  OP_IGET_CHAR              = 0x57,
  OP_IGET_SHORT             = 0x58,
  OP_IPUT                   = 0x59,
  OP_IPUT_WIDE              = 0x5a,
  OP_IPUT_OBJECT            = 0x5b,
  OP_IPUT_BOOLEAN           = 0x5c,
  OP_IPUT_BYTE              = 0x5d,
  OP_IPUT_CHAR              = 0x5e,
  OP_IPUT_SHORT             = 0x5f,
  OP_SGET                   = 0x60,
  OP_SGET_WIDE              = 0x61,
  OP_SGET_OBJECT            = 0x62,
  OP_SGET_BOOLEAN           = 0x63,
  OP_SGET_BYTE              = 0x64,
  OP_SGET_CHAR              = 0x65,
  OP_SGET_SHORT             = 0x66,
  OP_SPUT                   = 0x67,
  OP_SPUT_WIDE              = 0x68,
  OP_SPUT_OBJECT            = 0x69,
  OP_SPUT_BOOLEAN           = 0x6a,
  OP_SPUT_BYTE              = 0x6b,
  OP_SPUT_CHAR              = 0x6c,
  OP_SPUT_SHORT             = 0x6d,
  OP_INVOKE_VIRTUAL         = 0x6e,
  OP_INVOKE_SUPER           = 0x6f,
  OP_INVOKE_DIRECT          = 0x70,
  OP_INVOKE_STATIC          = 0x71,
  OP_INVOKE_INTERFACE       = 0x72,
  OP_RETURN_VOID_NO_BARRIER = 0x73,
  OP_INVOKE_VIRTUAL_RANGE   = 0x74,
  OP_INVOKE_SUPER_RANGE     = 0x75,
  OP_INVOKE_DIRECT_RANGE    = 0x76,
  OP_INVOKE_STATIC_RANGE    = 0x77,
  OP_INVOKE_INTERFACE_RANGE = 0x78,
  OP_NEG_INT                = 0x7b,
  OP_NOT_INT                = 0x7c,
  OP_NEG_LONG               = 0x7d,
  OP_NOT_LONG               = 0x7e,
  OP_NEG_FLOAT              = 0x7f,
  OP_NEG_DOUBLE             = 0x80,
  OP_INT_TO_LONG            = 0x81,
  OP_INT_TO_FLOAT           = 0x82,
  OP_INT_TO_DOUBLE          = 0x83,
  OP_LONG_TO_INT            = 0x84,
  OP_LONG_TO_FLOAT          = 0x85,
  OP_LONG_TO_DOUBLE         = 0x86,
  OP_FLOAT_TO_INT           = 0x87,
  OP_FLOAT_TO_LONG          = 0x88,
  OP_FLOAT_TO_DOUBLE        = 0x89,
  OP_DOUBLE_TO_INT          = 0x8a,
  OP_DOUBLE_TO_LONG         = 0x8b,
  OP_DOUBLE_TO_FLOAT        = 0x8c,
  OP_INT_TO_BYTE            = 0x8d,
  OP_INT_TO_CHAR            = 0x8e,
  OP_INT_TO_SHORT           = 0x8f,
  OP_ADD_INT                = 0x90,
  OP_SUB_INT                = 0x91,
  OP_MUL_INT                = 0x92,
  OP_DIV_INT                = 0x93,
  OP_REM_INT                = 0x94,
  OP_AND_INT                = 0x95,
  OP_OR_INT                 = 0x96,
  OP_XOR_INT                = 0x97,
  OP_SHL_INT                = 0x98,
  OP_SHR_INT                = 0x99,
  OP_USHR_INT               = 0x9a,
  OP_ADD_LONG               = 0x9b,
  OP_SUB_LONG               = 0x9c,
  OP_MUL_LONG               = 0x9d,
  OP_DIV_LONG               = 0x9e,
  OP_REM_LONG               = 0x9f,
  OP_AND_LONG               = 0xa0,
  OP_OR_LONG                = 0xa1,
  OP_XOR_LONG               = 0xa2,
  OP_SHL_LONG               = 0xa3,
  OP_SHR_LONG               = 0xa4,
  OP_USHR_LONG              = 0xa5,
  OP_ADD_FLOAT              = 0xa6,
  OP_SUB_FLOAT              = 0xa7,
  OP_MUL_FLOAT              = 0xa8,
  OP_DIV_FLOAT              = 0xa9,
  OP_REM_FLOAT              = 0xaa,
  OP_ADD_DOUBLE             = 0xab,
  OP_SUB_DOUBLE             = 0xac,
  OP_MUL_DOUBLE             = 0xad,
  OP_DIV_DOUBLE             = 0xae,
  OP_REM_DOUBLE             = 0xaf,
  OP_ADD_INT_2_ADDR         = 0xb0,
  OP_SUB_INT_2_ADDR         = 0xb1,
  OP_MUL_INT_2_ADDR         = 0xb2,
  OP_DIV_INT_2_ADDR         = 0xb3,
  OP_REM_INT_2_ADDR         = 0xb4,
  OP_AND_INT_2_ADDR         = 0xb5,
  OP_OR_INT_2_ADDR          = 0xb6,
  OP_XOR_INT_2_ADDR         = 0xb7,
  OP_SHL_INT_2_ADDR         = 0xb8,
  OP_SHR_INT_2_ADDR         = 0xb9,
  OP_USHR_INT_2_ADDR        = 0xba,
  OP_ADD_LONG_2_ADDR        = 0xbb,
  OP_SUB_LONG_2_ADDR        = 0xbc,
  OP_MUL_LONG_2_ADDR        = 0xbd,
  OP_DIV_LONG_2_ADDR        = 0xbe,
  OP_REM_LONG_2_ADDR        = 0xbf,
  OP_AND_LONG_2_ADDR        = 0xc0,
  OP_OR_LONG_2_ADDR         = 0xc1,
  OP_XOR_LONG_2_ADDR        = 0xc2,
  OP_SHL_LONG_2_ADDR        = 0xc3,
  OP_SHR_LONG_2_ADDR        = 0xc4,
  OP_USHR_LONG_2_ADDR       = 0xc5,
  OP_ADD_FLOAT_2_ADDR       = 0xc6,
  OP_SUB_FLOAT_2_ADDR       = 0xc7,
  OP_MUL_FLOAT_2_ADDR       = 0xc8,
  OP_DIV_FLOAT_2_ADDR       = 0xc9,
  OP_REM_FLOAT_2_ADDR       = 0xca,
  OP_ADD_DOUBLE_2_ADDR      = 0xcb,
  OP_SUB_DOUBLE_2_ADDR      = 0xcc,
  OP_MUL_DOUBLE_2_ADDR      = 0xcd,
  OP_DIV_DOUBLE_2_ADDR      = 0xce,
  OP_REM_DOUBLE_2_ADDR      = 0xcf,
  OP_ADD_INT_LIT_16         = 0xd0,
  OP_RSUB_INT               = 0xd1,
  OP_MUL_INT_LIT_16         = 0xd2,
  OP_DIV_INT_LIT_16         = 0xd3,
  OP_REM_INT_LIT_16         = 0xd4,
  OP_AND_INT_LIT_16         = 0xd5,
  OP_OR_INT_LIT_16          = 0xd6,
  OP_XOR_INT_LIT_16         = 0xd7,
  OP_ADD_INT_LIT_8          = 0xd8,
  OP_RSUB_INT_LIT_8         = 0xd9,
  OP_MUL_INT_LIT_8          = 0xda,
  OP_DIV_INT_LIT_8          = 0xdb,
  OP_REM_INT_LIT_8          = 0xdc,
  OP_AND_INT_LIT_8          = 0xdd,
  OP_OR_INT_LIT_8           = 0xde,
  OP_XOR_INT_LIT_8          = 0xdf,
  OP_SHL_INT_LIT_8          = 0xe0,
  OP_SHR_INT_LIT_8          = 0xe1,
  OP_USHR_INT_LIT_8         = 0xe2,

  // ODEX
  OP_IGET_QUICK                  = 0xe3,
  OP_IGET_WIDE_QUICK             = 0xe4,
  OP_IGET_OBJECT_QUICK           = 0xe5,
  OP_IPUT_QUICK                  = 0xe6,
  OP_IPUT_WIDE_QUICK             = 0xe7,
  OP_IPUT_OBJECT_QUICK           = 0xe8,
  OP_INVOKE_VIRTUAL_QUICK        = 0xe9,
  OP_INVOKE_VIRTUAL_RANGE_QUICK  = 0xea,
  OP_IPUT_BOOLEAN_QUICK          = 0xeb,
  OP_IPUT_BYTE_QUICK             = 0xec,
  OP_IPUT_CHAR_QUICK             = 0xed,
  OP_IPUT_SHORT_QUICK            = 0xee,
  OP_IGET_BOOLEAN_QUICK          = 0xef,
  OP_IGET_BYTE_QUICK             = 0xf0,
  OP_IGET_CHAR_QUICK             = 0xf1,
  OP_IGET_SHORT_QUICK            = 0xf2,

  // From DEX 38
  OP_INVOKE_POLYMORPHIC       = 0xfa,
  OP_INVOKE_POLYMORPHIC_RANGE = 0xfb,
  OP_INVOKE_CUSTOM            = 0xfc,
  OP_INVOKE_CUSTOM_RANGE      = 0xfd,

  // From DEX 39
  OP_CONST_METHOD_HANDLE      = 0xfe,
  OP_CONST_METHOD_TYPE        = 0xff,
};

enum INST_FORMATS : uint8_t {
  F_00x = 0,
  F_10x,
  F_12x,
  F_11n,
  F_11x,
  F_10t,
  F_20t,
  F_20bc,
  F_22x,
  F_21t,
  F_21s,
  F_21h,
  F_21c,
  F_23x,
  F_22b,
  F_22t,
  F_22s,
  F_22c,
  F_22cs,
  F_30t,
  F_32x,
  F_31i,
  F_31t,
  F_31c,
  F_35c,
  F_35ms,
  F_35mi,
  F_3rc,
  F_3rms,
  F_3rmi,
  F_51l,

  // Since DEX 38
  F_45cc,
  F_4rcc,
};

struct packed_switch {
  uint16_t ident; // 0x0100
  uint16_t size;
  uint32_t first_key;
  // uint32_t targets[size]
};


struct sparse_switch {
  uint16_t ident; // 0x0200
  uint16_t size;
  // uint32_t targets[size]
};

struct fill_array_data {
  uint16_t ident;
  uint16_t element_width;
  uint32_t size;
  //uint8_t data[size];
};


//! Return the INST_FORMATS format associated with the given opcode
LIEF_API INST_FORMATS inst_format_from_opcode(OPCODES op);

LIEF_API size_t inst_size_from_format(INST_FORMATS fmt);
LIEF_API size_t inst_size_from_opcode(OPCODES op);

LIEF_API bool is_switch_array(const uint8_t* ptr, const uint8_t* end);

LIEF_API size_t switch_array_size(const uint8_t* ptr, const uint8_t* end);

} // Namespace LIEF
} // Namespace DEX

#endif


```

`KDemu/include/LIEF/LIEF/DEX/json.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_DEX_PUBLIC_JSON_H
#define LIEF_DEX_PUBLIC_JSON_H

#include "LIEF/visibility.h"
#include <string>

namespace LIEF {
class Object;

namespace DEX {

LIEF_API std::string to_json(const Object& v);

}
}


#endif

```

`KDemu/include/LIEF/LIEF/DEX/types.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_DEX_TYPEDEF_H
#define LIEF_DEX_TYPEDEF_H
#include <cstdint>

namespace LIEF {
namespace DEX {

using dex_version_t = uint32_t;

}
}

#endif

```

`KDemu/include/LIEF/LIEF/DEX/utils.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_DEX_UTILS_H
#define LIEF_DEX_UTILS_H

#include <string>
#include <vector>

#include "LIEF/DEX/types.hpp"

#include "LIEF/types.hpp"
#include "LIEF/visibility.h"

namespace LIEF {
class BinaryStream;
namespace DEX {

//! Check if the given file is a DEX.
LIEF_API bool is_dex(const std::string& file);

//! Check if the given raw data is a DEX.
LIEF_API bool is_dex(const std::vector<uint8_t>& raw);

//! Return the DEX version of the given file
LIEF_API dex_version_t version(const std::string& file);

//! Return the DEX version of the raw data
LIEF_API dex_version_t version(const std::vector<uint8_t>& raw);

dex_version_t version(BinaryStream& stream);

}
}


#endif

```

`KDemu/include/LIEF/LIEF/DWARF.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_DWARF_H
#define LIEF_DWARF_H

#include "LIEF/DWARF/enums.hpp"
#include "LIEF/DWARF/DebugInfo.hpp"
#include "LIEF/DWARF/CompilationUnit.hpp"
#include "LIEF/DWARF/Function.hpp"
#include "LIEF/DWARF/Variable.hpp"
#include "LIEF/DWARF/Scope.hpp"
#include "LIEF/DWARF/Type.hpp"
#include "LIEF/DWARF/types.hpp"

#endif

```

`KDemu/include/LIEF/LIEF/DWARF/CompilationUnit.hpp`:

```hpp
/* Copyright 2022 - 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_DWARF_COMPILATION_UNIT_H
#define LIEF_DWARF_COMPILATION_UNIT_H
#include <memory>
#include <string>
#include <vector>

#include "LIEF/visibility.h"
#include "LIEF/range.hpp"
#include "LIEF/iterators.hpp"
#include "LIEF/DWARF/Function.hpp"
#include "LIEF/DWARF/Type.hpp"

namespace LIEF {
namespace dwarf {

namespace details {
class CompilationUnit;
class CompilationUnitIt;
}

/// This class represents a DWARF compilation unit
class LIEF_API CompilationUnit {
  public:
  class LIEF_API Iterator {
    public:
    using iterator_category = std::bidirectional_iterator_tag;
    using value_type = std::unique_ptr<CompilationUnit>;
    using difference_type = std::ptrdiff_t;
    using pointer = CompilationUnit*;
    using reference = std::unique_ptr<CompilationUnit>&;
    using implementation = details::CompilationUnitIt;

    class LIEF_API PointerProxy {
      // Inspired from LLVM's iterator_facade_base
      friend class Iterator;
      public:
      pointer operator->() const { return R.get(); }

      private:
      value_type R;

      template <typename RefT>
      PointerProxy(RefT &&R) : R(std::forward<RefT>(R)) {} // NOLINT(bugprone-forwarding-reference-overload)
    };

    Iterator(const Iterator&);
    Iterator(Iterator&&) noexcept;
    Iterator(std::unique_ptr<details::CompilationUnitIt> impl);
    ~Iterator();

    friend LIEF_API bool operator==(const Iterator& LHS, const Iterator& RHS);
    friend LIEF_API bool operator!=(const Iterator& LHS, const Iterator& RHS) {
      return !(LHS == RHS);
    }

    Iterator& operator++();
    Iterator& operator--();

    Iterator operator--(int) {
      Iterator tmp = *static_cast<Iterator*>(this);
      --*static_cast<Iterator *>(this);
      return tmp;
    }

    Iterator operator++(int) {
      Iterator tmp = *static_cast<Iterator*>(this);
      ++*static_cast<Iterator *>(this);
      return tmp;
    }

    std::unique_ptr<CompilationUnit> operator*() const;

    PointerProxy operator->() const {
      return static_cast<const Iterator*>(this)->operator*();
    }

    private:
    std::unique_ptr<details::CompilationUnitIt> impl_;
  };

  /// Iterator over the dwarf::Function
  using functions_it = iterator_range<Function::Iterator>;

  /// Iterator over the dwarf::Type
  using types_it = iterator_range<Type::Iterator>;

  /// Iterator over the CompilationUnit's variables
  using vars_it = iterator_range<Variable::Iterator>;

  /// Languages supported by the DWARF (v5) format.
  /// See: https://dwarfstd.org/languages.html
  ///
  /// Some languages (like C++11, C++17, ..) have a version (11, 17, ...) which
  /// is stored in a dedicated attribute: #version
  class Language {
    public:
    enum LANG : uint32_t {
      UNKNOWN = 0,
      C,
      CPP,
      RUST,
      DART,
    };

    /// The language itself
    LANG lang = UNKNOWN;

    /// Version of the language (e.g. 17 for C++17)
    uint32_t version = 0;

    Language() = default;
    Language(LANG lang, uint32_t version) :
      lang(lang), version(version)
    {}
    Language(LANG lang) :
      Language(lang, 0)
    {}

    Language(const Language&) = default;
    Language& operator=(const Language&) = default;
    Language(Language&&) = default;
    Language& operator=(Language&&) = default;
    ~Language() = default;
  };
  CompilationUnit(std::unique_ptr<details::CompilationUnit> impl);
  ~CompilationUnit();

  /// Name of the file associated with this compilation unit (e.g. `test.cpp`)
  /// Return an **empty** string if the name is not found or can't be resolved
  ///
  /// This value matches the `DW_AT_name` attribute
  std::string name() const;

  /// Information about the program (or library) that generated this compilation
  /// unit. For instance, it can output: `Debian clang version 17.0.6`.
  ///
  /// It returns an **empty** string if the producer is not present or can't be
  /// resolved
  ///
  /// This value matches the `DW_AT_producer` attribute
  std::string producer() const;

  /// Return the path to the directory in which the compilation took place for
  /// compiling this compilation unit (e.g. `/workdir/build`)
  ///
  /// It returns an **empty** string if the entry is not present or can't be
  /// resolved
  ///
  /// This value matches the `DW_AT_comp_dir` attribute
  std::string compilation_dir() const;

  /// Original Language of this compilation unit.
  ///
  /// This value matches the `DW_AT_language` attribute.
  Language language() const;

  /// Return the lowest virtual address owned by this compilation unit.
  uint64_t low_address() const;

  /// Return the highest virtual address owned by this compilation unit.
  uint64_t high_address() const;

  /// Return the size of the compilation unit according to its range of address.
  ///
  /// If the compilation is fragmented (i.e. there are some address ranges
  /// between the lowest address and the highest that are not owned by the CU),
  /// then it returns the sum of **all** the address ranges owned by this CU.
  ///
  /// If the compilation unit is **not** fragmented, then is basically returns
  /// `high_address - low_address`.
  uint64_t size() const;

  /// Return a list of address ranges owned by this compilation unit.
  ///
  /// If the compilation unit owns a contiguous range, it should return
  /// **a single** range.
  std::vector<range_t> ranges() const;

  /// Try to find the function whose name is given in parameter.
  ///
  /// The provided name can be demangled
  std::unique_ptr<Function> find_function(const std::string& name) const;

  /// Try to find the function at the given address
  std::unique_ptr<Function> find_function(uint64_t addr) const;

  /// Try to find the Variable at the given address
  std::unique_ptr<Variable> find_variable(uint64_t addr) const;

  /// Try to find the Variable with the given name
  std::unique_ptr<Variable> find_variable(const std::string& name) const;

  /// Return an iterator over the functions implemented in this compilation
  /// unit.
  ///
  /// Note that this iterator only iterates over the functions that have a
  /// **concrete** implementation in the compilation unit.
  ///
  /// For instance with this code:
  ///
  /// ```cpp
  /// inline const char* get_secret_env() {
  ///   return getenv("MY_SECRET_ENV");
  /// }
  ///
  /// int main() {
  ///   printf("%s", get_secret_env());
  ///   return 0;
  /// }
  /// ```
  ///
  /// The iterator will only return **one function** for `main` since
  /// `get_secret_env` is inlined and thus, its implementation is located in
  /// `main`.
  functions_it functions() const;

  /// Return an iterator over the different types defined in this
  /// compilation unit.
  types_it types() const;


  /// Return an iterator over all the variables defined in the this compilation
  /// unit:
  ///
  /// ```cpp
  /// static int A = 1; // Returned by the iterator
  /// static const char* B = "Hello"; // Returned by the iterator
  ///
  /// int get() {
  ///   static int C = 2; // Returned by the iterator
  ///   return C;
  /// }
  /// ```
  vars_it variables() const;

  private:
  std::unique_ptr<details::CompilationUnit> impl_;
};

}
}
#endif


```

`KDemu/include/LIEF/LIEF/DWARF/DebugInfo.hpp`:

```hpp
/* Copyright 2022 - 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_DWARF_INFO_H
#define LIEF_DWARF_INFO_H
#include <memory>
#include <string>

#include "LIEF/iterators.hpp"
#include "LIEF/Abstract/DebugInfo.hpp"
#include "LIEF/DWARF/CompilationUnit.hpp"

#include "LIEF/visibility.h"

namespace LIEF {
/// Namespace for the DWARF debug format
namespace dwarf {
class Function;
class Variable;

/// This class represents a DWARF debug information. It can embed different
/// compilation units which can be accessed through compilation_units() .
///
/// This class can be instantiated from LIEF::Binary::debug_info() or load()
class LIEF_API DebugInfo : public LIEF::DebugInfo {
  public:
  using LIEF::DebugInfo::DebugInfo;

  static std::unique_ptr<DebugInfo> from_file(const std::string& path);

  /// Iterator over the CompilationUnit
  using compilation_units_it = iterator_range<CompilationUnit::Iterator>;

  /// Try to find the function with the given name (mangled or not)
  ///
  /// ```cpp
  /// const DebugInfo& info = ...;
  /// if (auto func = info.find_function("_ZNSt6localeD1Ev")) {
  ///   // Found
  /// }
  /// if (auto func = info.find_function("std::locale::~locale()")) {
  ///   // Found
  /// }
  /// ```
  std::unique_ptr<Function> find_function(const std::string& name) const;

  /// Try to find the function at the given **virtual** address
  std::unique_ptr<Function> find_function(uint64_t addr) const;

  /// Try to find the variable with the given name. This name can be mangled or
  /// not.
  std::unique_ptr<Variable> find_variable(const std::string& name) const;

  /// Try to find the variable at the given **virtual** address
  std::unique_ptr<Variable> find_variable(uint64_t addr) const;

  /// Try to find the type with the given name
  std::unique_ptr<Type> find_type(const std::string& name) const;

  /// Iterator on the CompilationUnit embedded in this dwarf
  compilation_units_it compilation_units() const;

  FORMAT format() const override {
    return LIEF::DebugInfo::FORMAT::DWARF;
  }

  static bool classof(const LIEF::DebugInfo* info) {
    return info->format() == LIEF::DebugInfo::FORMAT::DWARF;
  }

  ~DebugInfo() override = default;
};


/// Load DWARF file from the given path
inline std::unique_ptr<DebugInfo> load(const std::string& pdb_path) {
  return DebugInfo::from_file(pdb_path);
}

}
}
#endif

```

`KDemu/include/LIEF/LIEF/DWARF/Function.hpp`:

```hpp
/* Copyright 2022 - 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_DWARF_FUNCTION_H
#define LIEF_DWARF_FUNCTION_H

#include <memory>
#include <string>

#include "LIEF/visibility.h"
#include "LIEF/errors.hpp"
#include "LIEF/iterators.hpp"
#include "LIEF/range.hpp"
#include "LIEF/DWARF/Variable.hpp"
#include "LIEF/DWARF/Type.hpp"

namespace LIEF {
namespace dwarf {

class Scope;

namespace details {
class Function;
class Parameter;
class FunctionIt;
}

/// This class represents a DWARF function which can be associated with either:
/// `DW_TAG_subprogram` or `DW_TAG_inlined_subroutine`.
class LIEF_API Function {
  public:
  class LIEF_API Iterator {
    public:
    using iterator_category = std::bidirectional_iterator_tag;
    using value_type = std::unique_ptr<Function>;
    using difference_type = std::ptrdiff_t;
    using pointer = Function*;
    using reference = std::unique_ptr<Function>&;
    using implementation = details::FunctionIt;

    class LIEF_API PointerProxy {
      // Inspired from LLVM's iterator_facade_base
      friend class Iterator;
      public:
      pointer operator->() const { return R.get(); }

      private:
      value_type R;

      template <typename RefT>
      PointerProxy(RefT &&R) : R(std::forward<RefT>(R)) {} // NOLINT(bugprone-forwarding-reference-overload)
    };

    Iterator(const Iterator&);
    Iterator(Iterator&&) noexcept;
    Iterator(std::unique_ptr<details::FunctionIt> impl);
    ~Iterator();

    friend LIEF_API bool operator==(const Iterator& LHS, const Iterator& RHS);

    friend LIEF_API bool operator!=(const Iterator& LHS, const Iterator& RHS) {
      return !(LHS == RHS);
    }

    Iterator& operator++();
    Iterator& operator--();

    Iterator operator--(int) {
      Iterator tmp = *static_cast<Iterator*>(this);
      --*static_cast<Iterator *>(this);
      return tmp;
    }

    Iterator operator++(int) {
      Iterator tmp = *static_cast<Iterator*>(this);
      ++*static_cast<Iterator *>(this);
      return tmp;
    }

    std::unique_ptr<Function> operator*() const;

    PointerProxy operator->() const {
      return static_cast<const Iterator*>(this)->operator*();
    }

    private:
    std::unique_ptr<details::FunctionIt> impl_;
  };

  /// This class wraps a DWARF function's parameter
  class Parameter {
    public:
    Parameter(std::unique_ptr<details::Parameter> impl);
    Parameter(Parameter&& other) noexcept;
    Parameter& operator=(Parameter&& other) noexcept;

    /// Name of the parameter
    std::string name() const;

    /// Type of the parameter
    std::unique_ptr<Type> type() const;

    ~Parameter();
    private:
    std::unique_ptr<details::Parameter> impl_;
  };

  using vars_it = iterator_range<Variable::Iterator>;

  Function(std::unique_ptr<details::Function> impl);

  /// The name of the function (`DW_AT_name`)
  std::string name() const;

  /// The name of the function which is used for linking (`DW_AT_linkage_name`).
  ///
  /// This name differs from name() as it is usually mangled. The function
  /// return an empty string if the linkage name is not available.
  std::string linkage_name() const;

  /// Return the address of the function (`DW_AT_entry_pc` or `DW_AT_low_pc`).
  result<uint64_t> address() const;

  /// Return an iterator of variables (`DW_TAG_variable`) defined within the
  /// scope of this function. This includes regular stack-based variables as
  /// well as static ones.
  vars_it variables() const;

  /// Whether this function is created by the compiler and not
  /// present in the original source code
  bool is_artificial() const;

  /// Return the size taken by this function in the binary
  uint64_t size() const;

  /// Ranges of virtual addresses owned by this function
  std::vector<range_t> ranges() const;

  /// Original source code location
  debug_location_t debug_location() const;

  /// Return the dwarf::Type associated with the **return type** of this
  /// function
  std::unique_ptr<Type> type() const;

  /// Return the function's parameters
  std::vector<Parameter> parameters() const;

  /// Return the scope in which this function is defined
  std::unique_ptr<Scope> scope() const;

  ~Function();
  private:
  std::unique_ptr<details::Function> impl_;
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/DWARF/Scope.hpp`:

```hpp
/* Copyright 2022 - 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_DWARF_SCOPE_H
#define LIEF_DWARF_SCOPE_H

#include <memory>
#include <string>

#include "LIEF/visibility.h"

namespace LIEF {
namespace dwarf {

namespace details {
class Scope;
}

/// This class materializes a scope in which Function, Variable, Type, ...
/// can be defined.
class LIEF_API Scope {
  public:
  enum class TYPE : uint32_t {
    UNKNOWN = 0,
    UNION,
    CLASS,
    STRUCT,
    NAMESPACE,
    FUNCTION,
    COMPILATION_UNIT,
  };
  Scope(std::unique_ptr<details::Scope> impl);

  /// Name of the scope. For instance namespace's name or function's name.
  std::string name() const;

  /// Parent scope (if any)
  std::unique_ptr<Scope> parent() const;

  /// The current scope type
  TYPE type() const;

  /// Represent the whole chain of all (parent) scopes using the provided
  /// separator. E.g. `ns1::ns2::Class1::Struct2::Type`
  std::string chained(const std::string& sep = "::") const;

  ~Scope();
  private:
  std::unique_ptr<details::Scope> impl_;
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/DWARF/Type.hpp`:

```hpp
/* Copyright 2022 - 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_DWARF_TYPE_H
#define LIEF_DWARF_TYPE_H

#include <memory>

#include "LIEF/visibility.h"
#include "LIEF/errors.hpp"
#include "LIEF/debug_loc.hpp"
#include "LIEF/canbe_unique.hpp"

namespace LIEF {
namespace dwarf {
class Scope;

namespace details {
class Type;
class TypeIt;
}

/// This class represents a DWARF Type which includes:
///
/// - `DW_TAG_array_type`
/// - `DW_TAG_const_type`
/// - `DW_TAG_pointer_type`
/// - `DW_TAG_structure_type`
/// - `DW_TAG_base_type`
/// - `DW_TAG_class_type`
/// - `DW_TAG_enumeration_type`
/// - `DW_TAG_string_type`
/// - `DW_TAG_union_type`
/// - `DW_TAG_volatile_type`
/// - `DW_TAG_unspecified_type`
class LIEF_API Type {
  public:
  class LIEF_API Iterator {
    public:
    using iterator_category = std::bidirectional_iterator_tag;
    using value_type = std::unique_ptr<Type>;
    using difference_type = std::ptrdiff_t;
    using pointer = Type*;
    using reference = std::unique_ptr<Type>&;
    using implementation = details::TypeIt;

    class LIEF_API PointerProxy {
      // Inspired from LLVM's iterator_facade_base
      friend class Iterator;
      public:
      pointer operator->() const { return R.get(); }

      private:
      value_type R;

      template <typename RefT>
      PointerProxy(RefT &&R) : R(std::forward<RefT>(R)) {} // NOLINT(bugprone-forwarding-reference-overload)
    };

    Iterator(const Iterator&);
    Iterator(Iterator&&) noexcept;
    Iterator(std::unique_ptr<details::TypeIt> impl);
    ~Iterator();

    friend LIEF_API bool operator==(const Iterator& LHS, const Iterator& RHS);
    friend LIEF_API bool operator!=(const Iterator& LHS, const Iterator& RHS) {
      return !(LHS == RHS);
    }

    Iterator& operator++();
    Iterator& operator--();

    Iterator operator--(int) {
      Iterator tmp = *static_cast<Iterator*>(this);
      --*static_cast<Iterator *>(this);
      return tmp;
    }

    Iterator operator++(int) {
      Iterator tmp = *static_cast<Iterator*>(this);
      ++*static_cast<Iterator *>(this);
      return tmp;
    }

    std::unique_ptr<Type> operator*() const;

    PointerProxy operator->() const {
      return static_cast<const Iterator*>(this)->operator*();
    }

    private:
    std::unique_ptr<details::TypeIt> impl_;
  };

  virtual ~Type();

  enum class KIND {
    UNKNOWN = 0,
    UNSPECIFIED,
    BASE,
    CONST,
    CLASS,
    ARRAY,
    POINTER,
    STRUCT,
    UNION,
  };

  KIND kind() const;

  /// Whether this type is a `DW_TAG_unspecified_type`
  bool is_unspecified() const {
    return kind() == KIND::UNSPECIFIED;
  }

  /// Return the type's name (if any)
  result<std::string> name() const;

  /// Return the size of the type or an error if it can't be computed.
  ///
  /// This size should match the equivalent of `sizeof(Type)`.
  result<uint64_t> size() const;

  /// Return the debug location where this type is defined.
  debug_location_t location() const;

  /// Return the scope in which this type is defined
  std::unique_ptr<Scope> scope() const;

  template<class T>
  const T* as() const {
    if (T::classof(this)) {
      return static_cast<const T*>(this);
    }
    return nullptr;
  }

  static std::unique_ptr<Type> create(std::unique_ptr<details::Type> impl);

  protected:
  Type(std::unique_ptr<details::Type> impl);
  Type(details::Type& impl);

  LIEF::details::canbe_unique<details::Type> impl_;
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/DWARF/Variable.hpp`:

```hpp
/* Copyright 2022 - 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_DWARF_VARIABLE_H
#define LIEF_DWARF_VARIABLE_H

#include <memory>

#include "LIEF/visibility.h"
#include "LIEF/errors.hpp"
#include "LIEF/debug_loc.hpp"
#include "LIEF/DWARF/Type.hpp"

namespace LIEF {
namespace dwarf {
class Scope;

namespace details {
class Variable;
class VariableIt;
}

/// This class represents a DWARF variable which can be owned by a
/// dwarf::Function or a dwarf::CompilationUnit
class LIEF_API Variable {
  public:
  class LIEF_API Iterator {
    public:
    using iterator_category = std::bidirectional_iterator_tag;
    using value_type = std::unique_ptr<Variable>;
    using difference_type = std::ptrdiff_t;
    using pointer = Variable*;
    using reference = std::unique_ptr<Variable>&;
    using implementation = details::VariableIt;

    class LIEF_API PointerProxy {
      // Inspired from LLVM's iterator_facade_base
      friend class Iterator;
      public:
      pointer operator->() const { return R.get(); }

      private:
      value_type R;

      template <typename RefT>
      PointerProxy(RefT &&R) : R(std::forward<RefT>(R)) {} // NOLINT(bugprone-forwarding-reference-overload)
    };

    Iterator(const Iterator&);
    Iterator(Iterator&&) noexcept;
    Iterator(std::unique_ptr<details::VariableIt> impl);
    ~Iterator();

    friend LIEF_API bool operator==(const Iterator& LHS, const Iterator& RHS);
    friend LIEF_API bool operator!=(const Iterator& LHS, const Iterator& RHS) {
      return !(LHS == RHS);
    }

    Iterator& operator++();
    Iterator& operator--();

    Iterator operator--(int) {
      Iterator tmp = *static_cast<Iterator*>(this);
      --*static_cast<Iterator *>(this);
      return tmp;
    }

    Iterator operator++(int) {
      Iterator tmp = *static_cast<Iterator*>(this);
      ++*static_cast<Iterator *>(this);
      return tmp;
    }

    std::unique_ptr<Variable> operator*() const;

    PointerProxy operator->() const {
      return static_cast<const Iterator*>(this)->operator*();
    }

    private:
    std::unique_ptr<details::VariableIt> impl_;
  };

  Variable(std::unique_ptr<details::Variable> impl);

  /// Name of the variable (usually demangled)
  std::string name() const;

  /// The name of the variable which is used for linking (`DW_AT_linkage_name`).
  ///
  /// This name differs from name() as it is usually mangled. The function
  /// return an empty string if the linkage name is not available.
  std::string linkage_name() const;

  /// Address of the variable.
  ///
  /// If the variable is **static**, it returns the **virtual address**
  /// where it is defined.
  /// If the variable is stack-based, it returns the **relative offset** from
  /// the frame based register.
  ///
  /// If the address can't be resolved, it returns a lief_errors.
  result<int64_t> address() const;

  /// Return the size of the variable (or a lief_errors if it can't be
  /// resolved).
  ///
  /// This size is defined by its type.
  result<uint64_t> size() const;

  /// Whether it's a `constexpr` variable
  bool is_constexpr() const;

  /// The original source location where the variable is defined.
  debug_location_t debug_location() const;

  /// Return the type of this variable
  std::unique_ptr<Type> type() const;

  /// Return the scope in which this variable is defined
  std::unique_ptr<Scope> scope() const;

  ~Variable();
  private:
  std::unique_ptr<details::Variable> impl_;
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/DWARF/enums.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_DWARF_ENUMS_H
#define LIEF_DWARF_ENUMS_H

namespace LIEF {
namespace dwarf {

 enum class EH_ENCODING  {
    ABSPTR   = 0x00,
    OMIT     = 0xff,
    ULEB128  = 0x01,
    UDATA2   = 0x02,
    UDATA4   = 0x03,
    UDATA8   = 0x04,
    SLEB128  = 0x09,
    SDATA2   = 0x0a,
    SDATA4   = 0x0b,
    SDATA8   = 0x0c,
    SIGNED   = 0x09,

    PCREL    = 0x10,
    INDIRECT = 0x80,
    TEXTREL  = 0x20,
    DATAREL  = 0x30,
    FUNCREL  = 0x40,
    ALIGNED  = 0x50,
 };

} // dwarf
} // LIEF

#endif

```

`KDemu/include/LIEF/LIEF/DWARF/types.hpp`:

```hpp
/* Copyright 2022 - 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_DWARF_TYPES_H
#define LIEF_DWARF_TYPES_H
#include <LIEF/DWARF/Type.hpp>
#include <LIEF/DWARF/types/ClassLike.hpp>
#include <LIEF/DWARF/types/Pointer.hpp>
#include <LIEF/DWARF/types/Const.hpp>
#include <LIEF/DWARF/types/Base.hpp>
#include <LIEF/DWARF/types/Array.hpp>
#endif

```

`KDemu/include/LIEF/LIEF/DWARF/types/Array.hpp`:

```hpp
/* Copyright 2022 - 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_DWARF_TYPE_ARRAY_H
#define LIEF_DWARF_TYPE_ARRAY_H

#include "LIEF/visibility.h"
#include "LIEF/DWARF/Type.hpp"

namespace LIEF {
namespace dwarf {
namespace types {

/// This class represents a `DW_TAG_array_type`
class LIEF_API Array : public Type {
  public:
  using Type::Type;

  static bool classof(const Type* type) {
    return type->kind() == Type::KIND::ARRAY;
  }

  /// The underlying type of this array
  const Type* underlying_type() const;

  const Type* operator->() const {
    return underlying_type();
  }

  const Type& operator*() const {
    return *underlying_type();
  }

  ~Array() override;

  protected:
  mutable std::unique_ptr<Type> underlying_;
};

}
}
}
#endif



```

`KDemu/include/LIEF/LIEF/DWARF/types/Base.hpp`:

```hpp
/* Copyright 2022 - 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_DWARF_TYPE_BASE_H
#define LIEF_DWARF_TYPE_BASE_H

#include "LIEF/visibility.h"
#include "LIEF/DWARF/Type.hpp"

namespace LIEF {
namespace dwarf {
namespace types {

/// This class wraps the `DW_TAG_base_type` type which can be used -- for
/// instance -- to represent integers or primitive types.
class LIEF_API Base : public Type {
  public:
  using Type::Type;

  enum class ENCODING {
    NONE = 0,

    /// Mirror `DW_ATE_signed`
    SIGNED,

    /// Mirror `DW_ATE_signed_char`
    SIGNED_CHAR,

    /// Mirror `DW_ATE_unsigned`
    UNSIGNED,

    /// Mirror `DW_ATE_unsigned_char`
    UNSIGNED_CHAR,

    /// Mirror `DW_ATE_float`
    FLOAT,

    /// Mirror `DW_ATE_boolean`
    BOOLEAN,

    /// Mirror `DW_ATE_address`
    ADDRESS,
  };

  static bool classof(const Type* type) {
    return type->kind() == Type::KIND::BASE;
  }

  /// Describe how the the base type is encoded and should be interpreted
  ENCODING encoding() const;

  ~Base() override;
};

}
}
}
#endif



```

`KDemu/include/LIEF/LIEF/DWARF/types/ClassLike.hpp`:

```hpp
/* Copyright 2022 - 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_DWARF_TYPE_STRUCTURE_H
#define LIEF_DWARF_TYPE_STRUCTURE_H

#include "LIEF/visibility.h"
#include "LIEF/DWARF/Type.hpp"

namespace LIEF {
namespace dwarf {
namespace types {

namespace details {
class Member;
}

/// This class abstracts a DWARF aggregate: `DW_TAG_structure_type`,
/// `DW_TAG_class_type`, `DW_TAG_union_type`.
class LIEF_API ClassLike : public Type {
  public:
  using Type::Type;

  /// This represents a class/struct/union attribute
  class Member {
    public:
    Member(std::unique_ptr<details::Member> impl);
    Member(Member&& other) noexcept;
    Member& operator=(Member&& other) noexcept;

    /// Name of the member
    std::string name() const;

    /// Offset of the current member in the struct/union/class
    ///
    /// If the offset can't be resolved it returns a lief_errors
    result<uint64_t> offset() const;

    /// Offset of the current member in **bits** the struct/union/class
    ///
    /// This function differs from offset() for aggregates using bit-field
    /// declaration:
    ///
    /// ```cpp
    /// struct S {
    ///   int flag : 4;
    ///   int opt : 1
    /// };
    /// ```
    ///
    /// Usually, `offset() * 8 == bit_offset()`
    ///
    /// If the offset can't be resolved it returns a lief_errors
    result<uint64_t> bit_offset() const;

    /// Type of the current member
    std::unique_ptr<Type> type() const;

    bool is_external() const;

    bool is_declaration() const;

    ~Member();
    private:
    std::unique_ptr<details::Member> impl_;
  };

  static bool classof(const Type* type) {
    const auto kind = type->kind();
    return kind == Type::KIND::CLASS || kind == Type::KIND::STRUCT || kind == Type::KIND::UNION;
  }

  /// Return the list of all the attributes defined in this class-like type
  std::vector<Member> members() const;

  /// Try to find the attribute at the given offset
  std::unique_ptr<Member> find_member(uint64_t offset) const;

  ~ClassLike() override;
};

/// This class represents a DWARF `struct` type (`DW_TAG_structure_type`)
class LIEF_API Structure : public ClassLike {
  public:
  using ClassLike::ClassLike;

  static bool classof(const Type* type) {
    return type->kind() == Type::KIND::STRUCT;
  }

  ~Structure() override;
};

/// This class represents a DWARF `class` type (`DW_TAG_class_type`)
class LIEF_API Class : public ClassLike {
  public:
  using ClassLike::ClassLike;

  static bool classof(const Type* type) {
    return type->kind() == Type::KIND::CLASS;
  }

  ~Class() override;
};

/// This class represents a DWARF `class` type (`DW_TAG_union_type`)
class LIEF_API Union : public ClassLike {
  public:
  using ClassLike::ClassLike;

  static bool classof(const Type* type) {
    return type->kind() == Type::KIND::UNION;
  }

  ~Union() override;
};

}
}
}
#endif



```

`KDemu/include/LIEF/LIEF/DWARF/types/Const.hpp`:

```hpp
/* Copyright 2022 - 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_DWARF_TYPE_CONST_H
#define LIEF_DWARF_TYPE_CONST_H

#include "LIEF/visibility.h"
#include "LIEF/DWARF/Type.hpp"

namespace LIEF {
namespace dwarf {
namespace types {

/// This class represents a `DW_TAG_const_type`
class LIEF_API Const : public Type {
  public:
  using Type::Type;

  static bool classof(const Type* type) {
    return type->kind() == Type::KIND::CONST;
  }

  /// The underlying type being const-ed
  const Type* underlying_type() const;

  const Type* operator->() const {
    return underlying_type();
  }

  const Type& operator*() const {
    return *underlying_type();
  }

  ~Const() override;

  protected:
  mutable std::unique_ptr<Type> underlying_;
};

}
}
}
#endif



```

`KDemu/include/LIEF/LIEF/DWARF/types/Pointer.hpp`:

```hpp
/* Copyright 2022 - 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_DWARF_TYPE_POINTER_H
#define LIEF_DWARF_TYPE_POINTER_H

#include "LIEF/visibility.h"
#include "LIEF/DWARF/Type.hpp"

namespace LIEF {
namespace dwarf {
namespace types {

/// This class represents a `DW_TAG_pointer_type` DWARF type
class LIEF_API Pointer : public Type {
  public:
  using Type::Type;

  static bool classof(const Type* type) {
    return type->kind() == Type::KIND::POINTER;
  }

  /// The type pointed by this pointer
  const Type* underlying_type() const;

  const Type* operator->() const {
    return underlying_type();
  }

  const Type& operator*() const {
    return *underlying_type();
  }

  ~Pointer() override;

  protected:
  mutable std::unique_ptr<Type> underlying_;
};

}
}
}
#endif



```

`KDemu/include/LIEF/LIEF/ELF.h`:

```h
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef C_LIEF_ELF_H_
#define C_LIEF_ELF_H_

#include "LIEF/ELF/Binary.h"
#include "LIEF/ELF/Symbol.h"
#include "LIEF/ELF/Section.h"
#include "LIEF/ELF/Header.h"
#include "LIEF/ELF/DynamicEntry.h"
#include "LIEF/ELF/utils.h"

#endif

```

`KDemu/include/LIEF/LIEF/ELF.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_H
#define LIEF_ELF_H
#include "LIEF/config.h"

#if defined(LIEF_ELF_SUPPORT)
#include "LIEF/ELF/hash.hpp"
#include "LIEF/ELF/utils.hpp"
#include "LIEF/ELF/enums.hpp"

#include "LIEF/ELF/Parser.hpp"
#include "LIEF/ELF/Header.hpp"
#include "LIEF/ELF/Section.hpp"
#include "LIEF/ELF/Binary.hpp"
#include "LIEF/ELF/Segment.hpp"
#include "LIEF/ELF/Builder.hpp"
#include "LIEF/ELF/EnumToString.hpp"
#include "LIEF/ELF/Relocation.hpp"
#include "LIEF/ELF/DynamicEntryArray.hpp"
#include "LIEF/ELF/DynamicEntryFlags.hpp"
#include "LIEF/ELF/DynamicEntry.hpp"
#include "LIEF/ELF/DynamicEntryLibrary.hpp"
#include "LIEF/ELF/DynamicEntryRpath.hpp"
#include "LIEF/ELF/DynamicEntryRunPath.hpp"
#include "LIEF/ELF/DynamicSharedObject.hpp"
#include "LIEF/ELF/GnuHash.hpp"
#include "LIEF/ELF/Note.hpp"
#include "LIEF/ELF/NoteDetails.hpp"
#include "LIEF/ELF/Symbol.hpp"
#include "LIEF/ELF/SymbolVersion.hpp"
#include "LIEF/ELF/SymbolVersionAux.hpp"
#include "LIEF/ELF/SymbolVersionAuxRequirement.hpp"
#include "LIEF/ELF/SymbolVersionDefinition.hpp"
#include "LIEF/ELF/SymbolVersionRequirement.hpp"
#include "LIEF/ELF/SysvHash.hpp"

#endif

#endif

```

`KDemu/include/LIEF/LIEF/ELF/Binary.h`:

```h
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_C_ELF_BINARY_H
#define LIEF_C_ELF_BINARY_H

#include <stddef.h>

#include "LIEF/visibility.h"

#include "LIEF/ELF/enums.h"

#include "LIEF/ELF/Section.h"
#include "LIEF/ELF/Segment.h"
#include "LIEF/ELF/Header.h"
#include "LIEF/ELF/DynamicEntry.h"
#include "LIEF/ELF/Symbol.h"

#ifdef __cplusplus
extern "C" {
#endif

/** LIEF::ELF::Binary C Handler */
struct Elf_Binary_t {
  void*              handler;
  const char*        interpreter;
  uint32_t           type;
  Elf_Header_t       header;
  Elf_Section_t      **sections;
  Elf_Segment_t      **segments;
  Elf_DynamicEntry_t **dynamic_entries;
  Elf_Symbol_t       **dynamic_symbols;
  Elf_Symbol_t       **symtab_symbols;
};

typedef struct Elf_Binary_t Elf_Binary_t;

/** Wrapper for LIEF::ELF::Parser::parse */
LIEF_API Elf_Binary_t* elf_parse(const char *file);

LIEF_API void elf_binary_destroy(Elf_Binary_t* binary);

/** Update LIEF::ELF::Header object */
LIEF_API int elf_binary_save_header(Elf_Binary_t* binary);

#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/include/LIEF/LIEF/ELF/Binary.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_BINARY_H
#define LIEF_ELF_BINARY_H

#include <vector>
#include <memory>

#include "LIEF/visibility.h"
#include "LIEF/errors.hpp"
#include "LIEF/iterators.hpp"

#include "LIEF/Abstract/Binary.hpp"

#include "LIEF/ELF/Note.hpp"
#include "LIEF/ELF/DynamicEntry.hpp"
#include "LIEF/ELF/Header.hpp"
#include "LIEF/ELF/Section.hpp"
#include "LIEF/ELF/Segment.hpp"
#include "LIEF/ELF/Builder.hpp"

namespace LIEF {
//! Namespace related to the LIEF's ELF module
namespace ELF {
namespace DataHandler {
class Handler;
}

class ExeLayout;
class GnuHash;
class Layout;
class ObjectFileLayout;
class Parser;
class Relocation;
class Section;
class Segment;
class Symbol;
class SymbolVersion;
class SymbolVersionDefinition;
class SymbolVersionRequirement;
class DynamicEntryLibrary;
class SysvHash;
struct sizing_info_t;

//! Class which represents an ELF binary
class LIEF_API Binary : public LIEF::Binary {
  friend class Parser;
  friend class Builder;
  friend class ExeLayout;
  friend class Layout;
  friend class ObjectFileLayout;

  public:
  using string_list_t  = std::vector<std::string>;

  //! Internal container for storing notes
  using notes_t = std::vector<std::unique_ptr<Note>>;

  //! Iterator which outputs Note& object
  using it_notes = ref_iterator<notes_t&, Note*>;

  //! Iterator which outputs const Note& object
  using it_const_notes = const_ref_iterator<const notes_t&, const Note*>;

  //! Internal container for storing SymbolVersionRequirement
  using symbols_version_requirement_t = std::vector<std::unique_ptr<SymbolVersionRequirement>>;

  //! Iterator which outputs SymbolVersionRequirement& object
  using it_symbols_version_requirement = ref_iterator<symbols_version_requirement_t&, SymbolVersionRequirement*>;

  //! Iterator which outputs const SymbolVersionRequirement& object
  using it_const_symbols_version_requirement = const_ref_iterator<const symbols_version_requirement_t&, const SymbolVersionRequirement*>;

  //! Internal container for storing SymbolVersionDefinition
  using symbols_version_definition_t = std::vector<std::unique_ptr<SymbolVersionDefinition>>;

  //! Iterator which outputs SymbolVersionDefinition& object
  using it_symbols_version_definition       = ref_iterator<symbols_version_definition_t&, SymbolVersionDefinition*>;

  //! Iterator which outputs const SymbolVersionDefinition& object
  using it_const_symbols_version_definition = const_ref_iterator<const symbols_version_definition_t&, const SymbolVersionDefinition*>;

  //! Internal container for storing ELF's Segment
  using segments_t = std::vector<std::unique_ptr<Segment>>;

  //! Iterator which outputs Segment& object
  using it_segments = ref_iterator<segments_t&, Segment*>;

  //! Iterator which outputs const Segment& object
  using it_const_segments = const_ref_iterator<const segments_t&, const Segment*>;

  //! Internal container for storing ELF's DynamicEntry
  using dynamic_entries_t = std::vector<std::unique_ptr<DynamicEntry>>;

  //! Iterator which outputs DynamicEntry& object
  using it_dynamic_entries = ref_iterator<dynamic_entries_t&, DynamicEntry*>;

  //! Iterator which outputs const DynamicEntry& object
  using it_const_dynamic_entries = const_ref_iterator<const dynamic_entries_t&, const DynamicEntry*>;

  //! Internal container for storing ELF's SymbolVersion
  using symbols_version_t = std::vector<std::unique_ptr<SymbolVersion>>;

  //! Iterator which outputs SymbolVersion& object
  using it_symbols_version = ref_iterator<symbols_version_t&, SymbolVersion*>;

  //! Iterator which outputs const SymbolVersion& object
  using it_const_symbols_version = const_ref_iterator<const symbols_version_t&, const SymbolVersion*>;

  //! Internal container for storing ELF's Relocation
  using relocations_t = std::vector<std::unique_ptr<Relocation>>;

  //! Iterator which outputs plt/got Relocation& object
  using it_pltgot_relocations = filter_iterator<relocations_t&, Relocation*>;

  //! Iterator which outputs plt/got const Relocation& object
  using it_const_pltgot_relocations = const_filter_iterator<const relocations_t&, const Relocation*>;

  //! Iterator which outputs dynamic Relocation& object (not related to the PLT/GOT mechanism)
  using it_dynamic_relocations = filter_iterator<relocations_t&, Relocation*>;

  //! Iterator which outputs dynamic const Relocation& object (not related to the PLT/GOT mechanism)
  using it_const_dynamic_relocations = const_filter_iterator<const relocations_t&, const Relocation*>;

  //! Iterator which outputs Relocation& object found in object files (.o)
  using it_object_relocations = filter_iterator<relocations_t&, Relocation*>;

  //! Iterator which outputs const Relocation& object found in object files (.o)
  using it_const_object_relocations = const_filter_iterator<const relocations_t&, const Relocation*>;

  //! Iterator which outputs Relocation& object
  using it_relocations = ref_iterator<relocations_t&, Relocation*>;

  //! Iterator which outputs const Relocation& object
  using it_const_relocations = const_ref_iterator<const relocations_t&, const Relocation*>;

  //! Internal container for storing ELF's Symbol
  using symbols_t = std::vector<std::unique_ptr<Symbol>>;

  //! Iterator which outputs the Dynamic Symbol& object
  using it_dynamic_symbols = ref_iterator<symbols_t&, Symbol*>;

  //! Iterator which outputs the Dynamic const Symbol& object
  using it_const_dynamic_symbols = const_ref_iterator<const symbols_t&, const Symbol*>;

  //! Iterator which outputs the static/debug Symbol& object
  using it_symtab_symbols = ref_iterator<symbols_t&, Symbol*>;

  //! Iterator which outputs the static/debug const Symbol& object
  using it_const_symtab_symbols = const_ref_iterator<const symbols_t&, const Symbol*>;

  //! Iterator which outputs static and dynamic Symbol& object
  using it_symbols = ref_iterator<std::vector<Symbol*>>;

  //! Iterator which outputs static and dynamic const Symbol& object
  using it_const_symbols = const_ref_iterator<std::vector<Symbol*>>;

  //! Iterator which outputs exported Symbol& object
  using it_exported_symbols = filter_iterator<std::vector<Symbol*>>;

  //! Iterator which outputs exported const Symbol& object
  using it_const_exported_symbols = const_filter_iterator<std::vector<Symbol*>>;

  //! Iterator which outputs imported Symbol& object
  using it_imported_symbols = filter_iterator<std::vector<Symbol*>>;

  //! Iterator which outputs imported const Symbol& object
  using it_const_imported_symbols = const_filter_iterator<std::vector<Symbol*>>;

  //! Internal container for storing ELF's Section
  using sections_t = std::vector<std::unique_ptr<Section>>;

  //! Iterator which outputs Section& object
  using it_sections = ref_iterator<sections_t&, Section*>;

  //! Iterator which outputs const Section& object
  using it_const_sections = const_ref_iterator<const sections_t&, const Section*>;

  public:
  /**
   * This enum describes the different ways to relocate the segments table.
   */
  enum PHDR_RELOC {
    /**
     * Defer the choice of the layout to LIEF.
     */
    AUTO = 0,

    /**
     * The content of the binary right after the segments table is shifted
     * and the relocations are updated accordingly.
     * This kind of shift only works with PIE binaries.
     */
    PIE_SHIFT,

    /**
     * The new segments table is relocated right after the first bss-like
     * segment.
     */
    BSS_END,
    /**
     * The new segments table is relocated at the end of the binary.
     */
    BINARY_END,
    /**
     * The new segments table is relocated between two LOAD segments.
     * This kind of relocation is only doable when there is an alignment
     * enforcement.
     */
    SEGMENT_GAP,
  };

  public:
  Binary& operator=(const Binary& ) = delete;
  Binary(const Binary& copy) = delete;

  //! Return binary's class (ELF32 or ELF64)
  Header::CLASS type() const {
    return type_;
  }

  //! Return @link ELF::Header Elf header @endlink
  Header& header() {
    return header_;
  }

  const Header& header() const {
    return header_;
  }

  //! Return the last offset used in binary
  //! according to sections table
  uint64_t last_offset_section() const;

  //! Return the last offset used in binary
  //! according to segments table
  uint64_t last_offset_segment() const;

  //! Return the next virtual address available
  uint64_t next_virtual_address() const;

  //! Return an iterator over the binary's sections
  it_sections sections() {
    return sections_;
  }

  it_const_sections sections() const {
    return sections_;
  }

  //! Return the binary's entrypoint
  uint64_t entrypoint() const override {
    return header_.entrypoint();
  }

  //! Return binary's segments
  it_segments segments() {
    return segments_;
  }

  it_const_segments segments() const {
    return segments_;
  }

  //! Return binary's dynamic entries
  it_dynamic_entries dynamic_entries() {
    return dynamic_entries_;
  }

  it_const_dynamic_entries dynamic_entries() const {
    return dynamic_entries_;
  }

  //! Add the given dynamic entry and return the new entry
  DynamicEntry& add(const DynamicEntry& entry);

  //! Add the given note and return the created entry
  Note& add(const Note& note);

  //! Remove the given dynamic entry
  void remove(const DynamicEntry& entry);

  //! Remove **all** dynamic entries with the given tag
  void remove(DynamicEntry::TAG tag);

  //! Remove the given section. The ``clear`` parameter
  //! can be used to zeroize the original content beforehand
  //!
  //! @param[in] section The section to remove
  //! @param[in] clear   Whether zeroize the original content
  void remove(const Section& section, bool clear = false);

  //! Remove the given note
  void remove(const Note& note);

  //! Remove **all** notes with the given type
  void remove(Note::TYPE type);

  //! Remove the given segment
  void remove(const Segment& seg);

  //! Return an iterator over the binary's dynamic symbols
  //! The dynamic symbols are those located in the ``.dynsym`` section
  it_dynamic_symbols dynamic_symbols() {
    return dynamic_symbols_;
  }

  it_const_dynamic_symbols dynamic_symbols() const {
    return dynamic_symbols_;
  }

  //! Return symbols which are exported by the binary
  it_exported_symbols       exported_symbols();
  it_const_exported_symbols exported_symbols() const;

  //! Return symbols which are imported by the binary
  it_imported_symbols       imported_symbols();
  it_const_imported_symbols imported_symbols() const;

  //! Return the debug symbols from the `.symtab` section.
  it_symtab_symbols symtab_symbols() {
    return symtab_symbols_;
  }

  it_const_symtab_symbols symtab_symbols() const {
    return symtab_symbols_;
  }

  //! Return the symbol versions
  it_symbols_version symbols_version() {
    return symbol_version_table_;
  }
  it_const_symbols_version symbols_version() const {
    return symbol_version_table_;
  }

  //! Return symbols version definition
  it_symbols_version_definition symbols_version_definition() {
    return symbol_version_definition_;
  }

  it_const_symbols_version_definition symbols_version_definition() const {
    return symbol_version_definition_;
  }

  //! Return Symbol version requirement
  it_symbols_version_requirement symbols_version_requirement() {
    return symbol_version_requirements_;
  }

  it_const_symbols_version_requirement symbols_version_requirement() const {
    return symbol_version_requirements_;
  }

  //! Return dynamic relocations
  it_dynamic_relocations       dynamic_relocations();
  it_const_dynamic_relocations dynamic_relocations() const;

  //! Add a new *dynamic* relocation.
  //!
  //! We consider a dynamic relocation as a relocation which is not plt-related
  //!
  //! See: add_pltgot_relocation
  Relocation& add_dynamic_relocation(const Relocation& relocation);

  //! Add a .plt.got relocation. This kind of relocation is usually
  //! associated with a PLT stub that aims at resolving the underlying symbol
  //!
  //! See also: add_dynamic_relocation
  Relocation& add_pltgot_relocation(const Relocation& relocation);

  //! Add relocation for object file (.o)
  //!
  //! The first parameter is the section to add while the second parameter
  //! is the LIEF::ELF::Section associated with the relocation.
  //!
  //! If there is an error, this function returns a ``nullptr``. Otherwise, it returns
  //! the relocation added.
  Relocation* add_object_relocation(const Relocation& relocation, const Section& section);

  //! Return `plt.got` relocations
  it_pltgot_relocations       pltgot_relocations();
  it_const_pltgot_relocations pltgot_relocations() const;

  //! Return relocations used in an object file (``*.o``)
  it_object_relocations       object_relocations();
  it_const_object_relocations object_relocations() const;

  //! Return **all** relocations present in the binary
  it_relocations relocations() {
    return relocations_;
  }

  it_const_relocations relocations() const {
    return relocations_;
  }

  //! Return relocation associated with the given address.
  //! It returns a ``nullptr`` if it is not found
  const Relocation* get_relocation(uint64_t address) const;
  Relocation*       get_relocation(uint64_t address);

  //! Return relocation associated with the given Symbol
  //! It returns a ``nullptr`` if it is not found
  const Relocation* get_relocation(const Symbol& symbol) const;
  Relocation*       get_relocation(const Symbol& symbol);

  //! Return relocation associated with the given Symbol name
  //! It returns a ``nullptr`` if it is not found
  const Relocation* get_relocation(const std::string& symbol_name) const;
  Relocation*       get_relocation(const std::string& symbol_name);

  //! ``true`` if GNU hash is used
  //!
  //! @see gnu_hash and use_sysv_hash
  bool use_gnu_hash() const {
    return gnu_hash_ != nullptr && has(DynamicEntry::TAG::GNU_HASH);
  }

  //! Return the GnuHash object in **readonly**
  //! If the ELF binary does not use the GNU hash table, return a nullptr
  const GnuHash* gnu_hash() const {
    return use_gnu_hash() ? gnu_hash_.get() : nullptr;
  }

  //! ``true`` if SYSV hash is used
  //!
  //! @see sysv_hash and use_gnu_hash
  bool use_sysv_hash() const {
    return sysv_hash_ != nullptr && has(DynamicEntry::TAG::HASH);
  }

  //! Return the SysvHash object as a **read-only** object
  //! If the ELF binary does not use the legacy sysv hash table, return a nullptr
  const SysvHash* sysv_hash() const {
    return use_sysv_hash() ? sysv_hash_.get() : nullptr;
  }

  //! Check if a section with the given name exists in the binary
  bool has_section(const std::string& name) const;

  //! Check if a section that handles the given offset exists
  bool has_section_with_offset(uint64_t offset) const;

  //! Check if a section that handles the given virtual address exists
  bool has_section_with_va(uint64_t va) const;

  //! Return Section with the given `name`. If the section can't be
  //! found, it returns a nullptr
  Section*       get_section(const std::string& name);
  const Section* get_section(const std::string& name) const;

  //! Return the `.text` section. If the section
  //! can't be found, it returns a nullptr
  Section* text_section() {
    return get_section(".text");
  }

  //! Return the `.dynamic` section. If the section
  //! can't be found, it returns a nullptr
  Section* dynamic_section();

  //! Return the hash section. If the section
  //! can't be found, it returns a nullptr
  Section* hash_section();

  //! Return section which holds the symtab symbols. If the section
  //! can't be found, it returns a nullptr
  Section* symtab_symbols_section();

  //! Return program image base. For instance ``0x40000``
  //!
  //! To compute the image base, we look for the PT_PHDR segment header (phdr),
  //! and we return ``phdr->p_vaddr - phdr->p_offset``
  uint64_t imagebase() const override;

  //! Return the size of the mapped binary
  uint64_t virtual_size() const;

  //! Check if the binary uses a loader (also named linker or interpreter)
  //! @see interpreter
  bool has_interpreter() const;

  //! Return the ELF interpreter if any. (e.g. `/lib64/ld-linux-x86-64.so.2`)
  //! If the binary does not have an interpreter, it returns an empty string
  //!
  //! @see has_interpreter
  const std::string& interpreter() const;

  //! Change the interpreter
  void interpreter(const std::string& interpreter);

  //! Return an iterator on both static and dynamic symbols
  it_symbols symbols() {
    return symtab_dyn_symbols();
  }

  it_const_symbols symbols() const {
    return symtab_dyn_symbols();
  }

  //! Export the given symbol and create it if it doesn't exist
  Symbol& export_symbol(const Symbol& symbol);

  //! Export the symbol with the given name and create it if it doesn't exist
  Symbol& export_symbol(const std::string& symbol_name, uint64_t value = 0);

  //! Check if the symbol with the given ``name`` exists in the dynamic symbols table
  bool has_dynamic_symbol(const std::string& name) const;

  //! Get the dynamic symbol from the given name.
  //! Return a nullptr if it can't be found
  const Symbol* get_dynamic_symbol(const std::string& name) const;

  Symbol* get_dynamic_symbol(const std::string& name);

  //! Check if the symbol with the given ``name`` exists in the symtab symbol table
  bool has_symtab_symbol(const std::string& name) const {
    return get_symtab_symbol(name) != nullptr;
  }

  //! Get the symtab symbol from the given name
  //! Return a nullptr if it can't be found
  const Symbol* get_symtab_symbol(const std::string& name) const;

  Symbol* get_symtab_symbol(const std::string& name);

  //! Return list of the strings used by the ELF binary.
  //!
  //! Basically, this function looks for string in the ``.roadata`` section
  string_list_t strings(size_t min_size = 5) const;

  //! Remove symbols with the given name in both:
  //!   * dynamic symbols
  //!   * symtab symbols
  //!
  //! @see remove_symtab_symbol, remove_dynamic_symbol
  void remove_symbol(const std::string& name);

  //! Remove symtabl symbols with the given name
  void remove_symtab_symbol(const std::string& name);
  void remove_symtab_symbol(Symbol* symbol);

  //! Remove dynamic symbols with the given name
  void remove_dynamic_symbol(const std::string& name);

  //! Remove the given symbol from the dynamic symbols table.
  //!
  //! As a side effect, it will remove any ELF::Relocation
  //! that refers to this symbol and the SymbolVersion (if any)
  //! associated with this symbol
  void remove_dynamic_symbol(Symbol* symbol);

  //! Return the address of the given function name
  result<uint64_t> get_function_address(const std::string& func_name) const override;

  //! Return the address of the given function name
  //
  //! @param[in] func_name    The function's name target
  //! @param[in] demangled    Use the demangled name
  result<uint64_t> get_function_address(const std::string& func_name, bool demangled) const;

  //! Add a new section in the binary
  //!
  //! @param[in] section    The section object to insert
  //! @param[in] loaded     Boolean value to indicate that section's data must be loaded
  //!                       by a PT_LOAD segment
  //!
  //! @return The section added. The `size` and the `virtual address` might change.
  //!
  //! This function requires a well-formed ELF binary
  Section* add(const Section& section, bool loaded = true);

  Section* extend(const Section& section, uint64_t size);

  //! Add a symtab symbol
  Symbol& add_symtab_symbol(const Symbol& symbol);

  //! Add a dynamic symbol with the associated SymbolVersion
  Symbol& add_dynamic_symbol(const Symbol& symbol, const SymbolVersion* version = nullptr);

  //! Create a symbol for the function at the given address and export it
  Symbol& add_exported_function(uint64_t address, const std::string& name = "");

  //! Add a library as dependency
  DynamicEntryLibrary& add_library(const std::string& library_name);

  //! Remove the given library from the dependencies
  void remove_library(const std::string& library_name);

  //! Get the library object (DynamicEntryLibrary) from the given name
  //! If the library can't be found, it returns a nullptr.
  DynamicEntryLibrary* get_library(const std::string& library_name);

  //! Get the library object (DynamicEntryLibrary) from the given name
  //! If the library can't be found, it returns a nullptr.
  const DynamicEntryLibrary* get_library(const std::string& library_name) const;

  //! Check if the given library name exists in the current binary
  bool has_library(const std::string& name) const;

  //! Add a new segment in the binary
  //!
  //! The segment is inserted at the end
  //!
  //! @return The segment added. `Virtual address` and `File Offset` might change.
  //!
  //! This function requires a well-formed ELF binary
  Segment* add(const Segment& segment, uint64_t base = 0);

  //! Replace the segment given in 2nd parameter with the segment given in the first one and return the updated segment.
  //!
  //! @warning The ``original_segment`` is no longer valid after this function
  Segment* replace(const Segment& new_segment, const Segment& original_segment, uint64_t base = 0);

  Segment* extend(const Segment& segment, uint64_t size);


  //! Patch the content at virtual address @p address with @p patch_value
  //!
  //! @param[in] address      Address to patch
  //! @param[in] patch_value  Patch to apply
  //! @param[in] addr_type    Specify if the address should be used as an absolute virtual address or an RVA
  void patch_address(uint64_t address, const std::vector<uint8_t>& patch_value,
                     LIEF::Binary::VA_TYPES addr_type = LIEF::Binary::VA_TYPES::AUTO) override;


  //! Patch the address with the given value
  //!
  //! @param[in] address        Address to patch
  //! @param[in] patch_value    Patch to apply
  //! @param[in] size           Size of the value in **bytes** (1, 2, ... 8)
  //! @param[in] addr_type      Specify if the address should be used as an absolute virtual address or an RVA
  void patch_address(uint64_t address, uint64_t patch_value,
                     size_t size = sizeof(uint64_t),
                     LIEF::Binary::VA_TYPES addr_type = LIEF::Binary::VA_TYPES::AUTO) override;

  //! Patch the imported symbol with the ``address``
  //!
  //! @param[in] symbol Imported symbol to patch
  //! @param[in] address New address
  void patch_pltgot(const Symbol& symbol, uint64_t address);


  //! Patch the imported symbol's name with the ``address``
  //!
  //! @param[in] symbol_name Imported symbol's name to patch
  //! @param[in] address New address
  void patch_pltgot(const std::string& symbol_name, uint64_t address);

  //! Strip the binary by removing symtab symbols
  void strip();

  //! Remove a binary's section.
  //!
  //! @param[in] name   The name of the section to remove
  //! @param[in] clear  Whether zeroize the original content
  void remove_section(const std::string& name, bool clear = false) override;

  //! Reconstruct the binary object and write it in `filename`
  //!
  //! This function assumes that the layout of the current ELF binary is correct
  //! (i.e. the binary can run).
  //!
  //! @param filename Path for the written ELF binary
  void write(const std::string& filename) override;

  //! Reconstruct the binary object with the given config and write it in `filename`
  //!
  //! This function assumes that the layout of the current ELF binary is correct
  //! (i.e. the binary can run).
  //!
  //! @param filename Path for the written ELF binary
  //! @param config   Builder configuration
  void write(const std::string& filename, Builder::config_t config);

  //! Reconstruct the binary object and write it in `os` stream
  //!
  //! This function assumes that the layout of the current ELF binary is correct
  //! (i.e. the binary can run).
  //!
  //! @param os Output stream for the written ELF binary
  void write(std::ostream& os) override;

  //! Reconstruct the binary object with the given config and write it in `os` stream
  //!
  //! @param os     Output stream for the written ELF binary
  //! @param config Builder configuration
  void write(std::ostream& os, Builder::config_t config);

  //! Reconstruct the binary object and return its content as a byte vector
  std::vector<uint8_t> raw();

  //! Convert a virtual address to a file offset
  result<uint64_t> virtual_address_to_offset(uint64_t virtual_address) const;

  //! Convert the given offset into a virtual address.
  //!
  //! @param[in] offset   The offset to convert.
  //! @param[in] slide    If not 0, it will replace the default base address (if any)
  result<uint64_t> offset_to_virtual_address(uint64_t offset, uint64_t slide = 0) const override;

  //! Check if the binary has been compiled with `-fpie -pie` flags
  //!
  //! To do so we check if there is a `PT_INTERP` segment and if
  //! the binary type is `ET_DYN` (Shared object)
  bool is_pie() const override;

  //! Check if the binary uses the ``NX`` protection (Non executable stack)
  bool has_nx() const override;

  //! Symbol index in the dynamic symbol table or -1 if the symbol
  //! does not exist.
  int64_t dynsym_idx(const std::string& name) const;

  int64_t dynsym_idx(const Symbol& sym) const;

  //! Symbol index from the `.symtab` section or -1 if the symbol is not present
  int64_t symtab_idx(const std::string& name) const;

  int64_t symtab_idx(const Symbol& sym) const;

  //! Return the ELF::Section from the given @p offset. Return a nullptr
  //! if a section can't be found
  //!
  //! If @p skip_nobits is set (which is the case by default), this function won't
  //! consider section for which the type is ``SHT_NOBITS`` (like ``.bss, .tbss, ...``)
  const Section* section_from_offset(uint64_t offset, bool skip_nobits = true) const;
  Section*       section_from_offset(uint64_t offset, bool skip_nobits = true);

  //! Return the ELF::Section from the given @p address. Return a nullptr
  //! if a section can't be found.
  //!
  //! If @p skip_nobits is set (which is the case by default), this function won't
  //! consider section for which type is ``SHT_NOBITS`` (like ``.bss, .tbss, ...``)
  const Section* section_from_virtual_address(uint64_t address, bool skip_nobits = true) const;
  Section*       section_from_virtual_address(uint64_t address, bool skip_nobits = true);

  //! Return the ELF::Segment from the given @p address. Return a nullptr
  //! if a segment can't be found.
  const Segment* segment_from_virtual_address(uint64_t address) const;
  Segment*       segment_from_virtual_address(uint64_t address);


  const Segment* segment_from_virtual_address(Segment::TYPE type, uint64_t address) const;
  Segment*       segment_from_virtual_address(Segment::TYPE type, uint64_t address);

  //! Return the ELF::Segment from the @p offset. Return a nullptr
  //! if a segment can't be found.
  const Segment* segment_from_offset(uint64_t offset) const;
  Segment*       segment_from_offset(uint64_t offset);

  //! Return the **first** ELF::DynamicEntry associated with the given tag
  //! If the tag can't be found, it returns a nullptr
  const DynamicEntry* get(DynamicEntry::TAG tag) const;
  DynamicEntry*       get(DynamicEntry::TAG tag) {
    return const_cast<DynamicEntry*>(static_cast<const Binary*>(this)->get(tag));
  }

  //! Return the **first** ELF::Segment associated with the given type.
  //! If a segment can't be found, it returns a nullptr.
  const Segment* get(Segment::TYPE type) const;
  Segment*       get(Segment::TYPE type);

  //! Return the **first** ELF::Note associated with the given type
  //! If a note can't be found, it returns a nullptr.
  const Note* get(Note::TYPE type) const;
  Note*       get(Note::TYPE type);

  //! Return the **first** ELF::Section associated with the given type
  //! If a section can't be found, it returns a nullptr.
  const Section* get(Section::TYPE type) const;
  Section*       get(Section::TYPE type);

  //! Check if an ELF::DynamicEntry associated with the given tag exists.
  bool has(DynamicEntry::TAG tag) const {
    return get(tag) != nullptr;
  }

  //! Check if ELF::Segment associated with the given type exists.
  bool has(Segment::TYPE type) const {
    return get(type) != nullptr;
  }

  //! Check if a ELF::Note associated with the given type exists.
  bool has(Note::TYPE type) const {
    return get(type) != nullptr;
  }

  //! Check if a ELF::Section associated with the given type exists.
  bool has(Section::TYPE type) const {
    return get(type) != nullptr;
  }

  //! Return the content located at virtual address
  span<const uint8_t> get_content_from_virtual_address(uint64_t virtual_address, uint64_t size,
                                     Binary::VA_TYPES addr_type = Binary::VA_TYPES::AUTO) const override;

  //! Method associated with the visitor pattern.
  void accept(LIEF::Visitor& visitor) const override;

  //! Apply the given permutation on the dynamic symbols table
  void permute_dynamic_symbols(const std::vector<size_t>& permutation);

  //! List of binary constructors (typically, the functions located in the ``.init_array``)
  LIEF::Binary::functions_t ctor_functions() const override;

  //! List of the binary destructors (typically, the functions located in the ``.fini_array``)
  LIEF::Binary::functions_t dtor_functions() const;

  //! List of the functions found the in the binary.
  LIEF::Binary::functions_t functions() const;

  //! ``true`` if the binary embeds notes
  bool has_notes() const;

  //! Return an iterator over the ELF's LIEF::ELF::Note
  //!
  //! @see has_note
  it_const_notes notes() const {
    return notes_;
  }

  it_notes notes() {
    return notes_;
  }

  //! Return the last offset used by the ELF binary according to both: the sections table
  //! and the segments table
  uint64_t eof_offset() const;

  //! True if data are present at the end of the binary
  bool has_overlay() const {
    return !overlay_.empty();
  }

  //! Overlay data (if any)
  span<const uint8_t> overlay() const {
    return overlay_;
  }

  //! Function to set the overlay
  void overlay(std::vector<uint8_t> overlay) {
    overlay_ = std::move(overlay);
  }

  //! Force relocating the segments table in a specific way.
  //!
  //! This function can be used to enforce a specific relocation of the
  //! segments table.
  //!
  //! @param[in] type The relocation type to apply
  //! @return The offset of the new segments table or 0 if it fails with
  //!         the given method.
  uint64_t relocate_phdr_table(PHDR_RELOC type);

  //! Return the array defined by the given tag (e.g.
  //! DynamicEntry::TAG::INIT_ARRAY) with relocations applied (if any)
  std::vector<uint64_t> get_relocated_dynamic_array(DynamicEntry::TAG tag) const;

  static bool classof(const LIEF::Binary* bin) {
    return bin->format() == Binary::FORMATS::ELF ||
           bin->format() == Binary::FORMATS::OAT;
  }

  size_t hash(const std::string& name);

  ~Binary() override;

  std::ostream& print(std::ostream& os) const override;

  Binary& operator+=(const DynamicEntry& entry) {
    add(entry);
    return *this;
  }
  Binary& operator+=(const Section& section) {
    add(section);
    return *this;
  }

  Binary& operator+=(const Segment& segment) {
    add(segment);
    return *this;
  }

  Binary& operator+=(const Note& note) {
    add(note);
    return *this;
  }

  Binary& operator-=(const DynamicEntry& entry) {
    remove(entry);
    return *this;
  }

  Binary& operator-=(DynamicEntry::TAG tag) {
    remove(tag);
    return *this;
  }

  Binary& operator-=(const Note& note) {
    remove(note);
    return *this;
  }

  Binary& operator-=(Note::TYPE type) {
    remove(type);
    return *this;
  }

  Segment* operator[](Segment::TYPE type) {
    return get(type);
  }

  const Segment* operator[](Segment::TYPE type) const {
    return get(type);
  }

  DynamicEntry* operator[](DynamicEntry::TAG tag) {
    return get(tag);
  }

  const DynamicEntry* operator[](DynamicEntry::TAG tag) const {
    return get(tag);
  }

  Note* operator[](Note::TYPE type) {
    return get(type);
  }

  const Note* operator[](Note::TYPE type) const {
    return get(type);
  }

  Section* operator[](Section::TYPE type) {
    return get(type);
  }

  const Section* operator[](Section::TYPE type) const {
    return get(type);
  }

  protected:
  struct phdr_relocation_info_t {
    uint64_t new_offset = 0;
    size_t nb_segments = 0;
    void clear() {
      new_offset = 0;
      nb_segments = 0;
    }
  };
  Binary();

  //! Return an abstraction of binary's section: LIEF::Section
  LIEF::Binary::sections_t get_abstract_sections() override;

  LIEF::Header get_abstract_header() const override;

  LIEF::Binary::functions_t get_abstract_exported_functions() const override;
  LIEF::Binary::functions_t get_abstract_imported_functions() const override;
  std::vector<std::string> get_abstract_imported_libraries() const override;
  LIEF::Binary::symbols_t     get_abstract_symbols() override;
  LIEF::Binary::relocations_t get_abstract_relocations() override;

  template<ELF::ARCH ARCH>
  void patch_relocations(uint64_t from, uint64_t shift);

  template<class T>
  void patch_addend(Relocation& relocatio, uint64_t from, uint64_t shift);

  void shift_sections(uint64_t from, uint64_t shift);
  void shift_segments(uint64_t from, uint64_t shift);
  void shift_dynamic_entries(uint64_t from, uint64_t shift);
  void shift_symbols(uint64_t from, uint64_t shift);
  void shift_relocations(uint64_t from, uint64_t shift);

  template<class ELF_T>
  void fix_got_entries(uint64_t from, uint64_t shift);

  LIEF::Binary::functions_t eh_frame_functions() const;
  LIEF::Binary::functions_t armexid_functions() const;

  template<Header::FILE_TYPE OBJECT_TYPE, bool note = false>
  Segment* add_segment(const Segment& segment, uint64_t base);

  uint64_t relocate_phdr_table_auto();
  uint64_t relocate_phdr_table_pie();
  uint64_t relocate_phdr_table_v1();
  uint64_t relocate_phdr_table_v2();
  uint64_t relocate_phdr_table_v3();

  template<Segment::TYPE PT>
  Segment* extend_segment(const Segment& segment, uint64_t size);

  template<bool LOADED>
  Section* add_section(const Section& section);
  std::vector<Symbol*> symtab_dyn_symbols() const;

  std::string shstrtab_name() const;
  Section* add_frame_section(const Section& sec);

  LIEF::Binary::functions_t tor_functions(DynamicEntry::TAG tag) const;

  Header::CLASS type_ = Header::CLASS::NONE;
  Header header_;
  sections_t sections_;
  segments_t segments_;
  dynamic_entries_t dynamic_entries_;
  symbols_t dynamic_symbols_;
  symbols_t symtab_symbols_;
  relocations_t relocations_;
  symbols_version_t symbol_version_table_;
  symbols_version_requirement_t symbol_version_requirements_;
  symbols_version_definition_t  symbol_version_definition_;
  notes_t notes_;
  std::unique_ptr<GnuHash> gnu_hash_;
  std::unique_ptr<SysvHash> sysv_hash_;
  std::unique_ptr<DataHandler::Handler> datahandler_;
  phdr_relocation_info_t phdr_reloc_info_;

  std::string interpreter_;
  std::vector<uint8_t> overlay_;
  std::unique_ptr<sizing_info_t> sizing_info_;
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/ELF/Builder.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 * Copyright 2017 - 2021, NVIDIA CORPORATION. All rights reserved
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_BUIDLER_H
#define LIEF_ELF_BUIDLER_H

#include <memory>
#include <set>
#include <string>
#include <vector>

#include "LIEF/errors.hpp"

#include "LIEF/visibility.h"
#include "LIEF/iostream.hpp"

namespace LIEF {
namespace ELF {
class Binary;
class Layout;
class Header;
class Note;
class DynamicEntryArray;
class DynamicEntry;
class Section;
class ExeLayout;
class ObjectFileLayout;
class Layout;
class Relocation;

//! Class which takes an ELF::Binary object and reconstructs a valid binary
//!
//! This interface assumes that the layout of input ELF binary is correct (i.e.
//! the binary can run).
class LIEF_API Builder {
  friend class ObjectFileLayout;
  friend class Layout;
  friend class ExeLayout;

  public:
  //! Configuration options to tweak the building process
  struct config_t {
    bool dt_hash         = true;  /// Rebuild DT_HASH
    bool dyn_str         = true;  /// Rebuild DT_STRTAB
    bool dynamic_section = true;  /// Rebuild PT_DYNAMIC segment
    bool fini_array      = true;  /// Rebuild DT_FINI_ARRAY
    bool gnu_hash        = true;  /// Rebuild DT_GNU_HASH
    bool init_array      = true;  /// Rebuild DT_INIT_ARRAY
    bool interpreter     = true;  /// Rebuild PT_INTERPRETER
    bool jmprel          = true;  /// Rebuild DT_JMPREL
    bool notes           = false; /// Disable note building since it can break the default layout
    bool preinit_array   = true;  /// Rebuild DT_PREINIT_ARRAY
    bool relr            = true;  /// Rebuild DT_RELR
    bool android_rela    = true;  /// Rebuild DT_ANDROID_REL[A]
    bool rela            = true;  /// Rebuild DT_REL[A]
    bool static_symtab   = true;  /// Rebuild `.symtab`
    bool sym_verdef      = true;  /// Rebuild DT_VERDEF
    bool sym_verneed     = true;  /// Rebuild DT_VERNEED
    bool sym_versym      = true;  /// Rebuild DT_VERSYM
    bool symtab          = true;  /// Rebuild DT_SYMTAB
    bool coredump_notes  = true;  /// Rebuild the Coredump notes
    bool force_relocate  = false; /// Force to relocating all the ELF structures that are supported by LIEF (mostly for testing)
  };

  Builder(Binary& binary);

  Builder() = delete;
  ~Builder();

  //! Perform the build of the provided ELF binary
  void build();

  //! Tweak the ELF builder with the provided config parameter
  Builder& set_config(config_t conf) {
    config_ = conf;
    return *this;
  }

  config_t& config() {
    return config_;
  }

  //! Return the built ELF binary as a byte vector
  const std::vector<uint8_t>& get_build();

  //! Write the built ELF binary in the ``filename`` given in parameter
  void write(const std::string& filename) const;

  //! Write the built ELF binary in the stream ``os`` given in parameter
  void write(std::ostream& os) const;

  protected:
  template<typename ELF_T>
  ok_error_t build();

  template<typename ELF_T>
  ok_error_t build_relocatable();

  template<typename ELF_T>
  ok_error_t build_exe_lib();

  template<typename ELF_T>
  ok_error_t build(const Header& header);

  template<typename ELF_T>
  ok_error_t build_sections();

  template<typename ELF_T>
  ok_error_t build_segments();

  template<typename ELF_T>
  ok_error_t build_symtab_symbols();

  template<typename ELF_T>
  ok_error_t build_dynamic();

  template<typename ELF_T>
  ok_error_t build_dynamic_section();

  template<typename ELF_T>
  ok_error_t build_dynamic_symbols();

  template<typename ELF_T>
  ok_error_t build_obj_symbols();

  template<typename ELF_T>
  ok_error_t build_dynamic_relocations();

  template<typename ELF_T>
  ok_error_t build_relative_relocations();

  template<typename ELF_T>
  ok_error_t build_android_relocations();

  template<typename ELF_T>
  ok_error_t build_pltgot_relocations();

  template<typename ELF_T>
  ok_error_t build_section_relocations();

  uint32_t sort_dynamic_symbols();

  template<typename ELF_T>
  ok_error_t build_hash_table();

  template<typename ELF_T>
  ok_error_t build_symbol_hash();

  ok_error_t build_empty_symbol_gnuhash();

  template<typename ELF_T>
  ok_error_t build_symbol_requirement();

  template<typename ELF_T>
  ok_error_t build_symbol_definition();

  template<typename ELF_T>
  ok_error_t build_symbol_version();

  template<typename ELF_T>
  ok_error_t build_interpreter();

  template<typename ELF_T>
  ok_error_t build_notes();

  ok_error_t update_note_section(const Note& note, std::set<const Note*>& notes);

  template<typename ELF_T>
  ok_error_t build_overlay();

  bool should_swap() const;

  template<class ELF_T>
  ok_error_t process_object_relocations();

  bool should_build_notes() const;

  config_t config_;
  mutable vector_iostream ios_;
  Binary* binary_{nullptr};
  std::unique_ptr<Layout> layout_;
};

} // namespace ELF
} // namespace LIEF




#endif

```

`KDemu/include/LIEF/LIEF/ELF/DynamicEntry.h`:

```h
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_C_ELF_DYNAMIC_ENTRY_H
#define LIEF_C_ELF_DYNAMIC_ENTRY_H

#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

struct Elf_DynamicEntry_t {
  uint64_t tag;
  uint64_t value;
};

struct Elf_DynamicEntry_Library_t {
  uint64_t    tag;
  uint64_t    value;
  const char* name;
};

struct Elf_DynamicEntry_SharedObject_t {
  uint64_t    tag;
  uint64_t    value;
  const char* name;
};

struct Elf_DynamicEntry_Array_t {
  uint64_t  tag;
  uint64_t  value;
  uint64_t* array;
};

struct Elf_DynamicEntry_Rpath_t {
  uint64_t    tag;
  uint64_t    value;
  const char* rpath;
};

struct Elf_DynamicEntry_RunPath_t {
  uint64_t tag;
  uint64_t value;
  const char* runpath;
};

struct Elf_DynamicEntry_Flags_t {
  uint64_t tag;
  uint64_t value;
};

typedef struct Elf_DynamicEntry_t              Elf_DynamicEntry_t;
typedef struct Elf_DynamicEntry_Library_t      Elf_DynamicEntry_Library_t;
typedef struct Elf_DynamicEntry_SharedObject_t Elf_DynamicEntry_SharedObject_t;
typedef struct Elf_DynamicEntry_Array_t        Elf_DynamicEntry_Array_t;
typedef struct Elf_DynamicEntry_Rpath_t        Elf_DynamicEntry_Rpath_t;
typedef struct Elf_DynamicEntry_RunPath_t      Elf_DynamicEntry_RunPath_t;
typedef struct Elf_DynamicEntry_Flags_t        Elf_DynamicEntry_Flags_t;

#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/include/LIEF/LIEF/ELF/DynamicEntry.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_DYNAMIC_ENTRY_H
#define LIEF_ELF_DYNAMIC_ENTRY_H

#include <ostream>
#include <memory>
#include <cstdint>

#include "LIEF/visibility.h"
#include "LIEF/Object.hpp"
#include "LIEF/ELF/enums.hpp"

namespace LIEF {
namespace ELF {
namespace details {
struct Elf64_Dyn;
struct Elf32_Dyn;
}

//! Class which represents an entry in the dynamic table
//! These entries are located in the ``.dynamic`` section or the ``PT_DYNAMIC`` segment
class LIEF_API DynamicEntry : public Object {
  public:
  static constexpr uint64_t MIPS_DISC    = 0x100000000;
  static constexpr uint64_t AARCH64_DISC = 0x200000000;
  static constexpr uint64_t HEXAGON_DISC = 0x300000000;
  static constexpr uint64_t PPC_DISC     = 0x400000000;
  static constexpr uint64_t PPC64_DISC   = 0x500000000;
  static constexpr uint64_t RISCV_DISC   = 0x600000000;

  enum class TAG : uint64_t {
    UNKNOWN                    = uint64_t(-1),
    DT_NULL                    = 0, /**< Marks end of dynamic array. */
    NEEDED                     = 1, /**< String table offset of needed library. */
    PLTRELSZ                   = 2, /**< Size of relocation entries in PLT. */
    PLTGOT                     = 3, /**< Address associated with linkage table. */
    HASH                       = 4, /**< Address of symbolic hash table. */
    STRTAB                     = 5, /**< Address of dynamic string table. */
    SYMTAB                     = 6, /**< Address of dynamic symbol table. */
    RELA                       = 7, /**< Address of relocation table (Rela entries). */
    RELASZ                     = 8, /**< Size of Rela relocation table. */
    RELAENT                    = 9, /**< Size of a Rela relocation entry. */
    STRSZ                      = 10,/**< Total size of the string table. */
    SYMENT                     = 11,/**< Size of a symbol table entry. */
    INIT                       = 12,/**< Address of initialization function. */
    FINI                       = 13,/**< Address of termination function. */
    SONAME                     = 14,/**< String table offset of a shared objects name. */
    RPATH                      = 15,/**< String table offset of library search path. */
    SYMBOLIC                   = 16,/**< Changes symbol resolution algorithm. */
    REL                        = 17,/**< Address of relocation table (Rel entries). */
    RELSZ                      = 18,/**< Size of Rel relocation table. */
    RELENT                     = 19,/**< Size of a Rel relocation entry. */
    PLTREL                     = 20,/**< Type of relocation entry used for linking. */
    DEBUG_TAG                  = 21,/**< Reserved for debugger. */
    TEXTREL                    = 22,/**< Relocations exist for non-writable segments. */
    JMPREL                     = 23,/**< Address of relocations associated with PLT. */
    BIND_NOW                   = 24,/**< Process all relocations before execution. */
    INIT_ARRAY                 = 25,/**< Pointer to array of initialization functions. */
    FINI_ARRAY                 = 26,/**< Pointer to array of termination functions. */
    INIT_ARRAYSZ               = 27,/**< Size of DT_INIT_ARRAY. */
    FINI_ARRAYSZ               = 28,/**< Size of DT_FINI_ARRAY. */
    RUNPATH                    = 29,/**< String table offset of lib search path. */
    FLAGS                      = 30,/**< Flags. */
    PREINIT_ARRAY              = 32,/**< Pointer to array of preinit functions. */
    PREINIT_ARRAYSZ            = 33,/**< Size of the DT_PREINIT_ARRAY array. */
    SYMTAB_SHNDX               = 34,/**< Address of SYMTAB_SHNDX section */
    RELRSZ                     = 35,/**< Total size of RELR relative relocations */
    RELR                       = 36,/**< Address of RELR relative relocations */
    RELRENT                    = 37,/**< Size of one RELR relative relocaction */

    // GNU Extensions
    GNU_HASH                   = 0x6FFFFEF5, /**< Reference to the GNU hash table. */
    RELACOUNT                  = 0x6FFFFFF9, /**< ELF32_Rela count. */
    RELCOUNT                   = 0x6FFFFFFA, /**< ELF32_Rel count. */
    FLAGS_1                    = 0x6FFFFFFB, /**< Flags_1. */
    VERSYM                     = 0x6FFFFFF0, /**< The address of .gnu.version section. */
    VERDEF                     = 0x6FFFFFFC, /**< The address of the version definition table. */
    VERDEFNUM                  = 0x6FFFFFFD, /**< The number of entries in DT_VERDEF. */
    VERNEED                    = 0x6FFFFFFE, /**< The address of the version Dependency table. */
    VERNEEDNUM                 = 0x6FFFFFFF, /**< The number of entries in DT_VERNEED. */

    // Android Extensions
    ANDROID_REL_OFFSET         = 0x6000000D, /**< The offset of packed relocation data (older version < M) (Android specific). */
    ANDROID_REL_SIZE           = 0x6000000E, /**< The size of packed relocation data in bytes (older version < M) (Android specific). */
    ANDROID_REL                = 0x6000000F, /**< The offset of packed relocation data (Android specific). */
    ANDROID_RELSZ              = 0x60000010, /**< The size of packed relocation data in bytes (Android specific). */
    ANDROID_RELA               = 0x60000011, /**< The offset of packed relocation data (Android specific). */
    ANDROID_RELASZ             = 0x60000012, /**< The size of packed relocation data in bytes (Android specific). */
    ANDROID_RELR               = 0x6FFFE000, /**< The offset of new relr relocation data (Android specific). */
    ANDROID_RELRSZ             = 0x6FFFE001, /**< The size of nre relr relocation data in bytes (Android specific). */
    ANDROID_RELRENT            = 0x6FFFE003, /**< The size of a new relr relocation entry (Android specific). */
    ANDROID_RELRCOUNT          = 0x6FFFE005,  /**< Specifies the relative count of new relr relocation entries (Android specific). */

    /* Mips specific dynamic table entry tags. */
    MIPS_RLD_VERSION           = MIPS_DISC + 0x70000001, /**< 32 bit version number for runtime linker interface. */
    MIPS_TIME_STAMP            = MIPS_DISC + 0x70000002, /**< Time stamp. */
    MIPS_ICHECKSUM             = MIPS_DISC + 0x70000003, /**< Checksum of external strings and common sizes. */
    MIPS_IVERSION              = MIPS_DISC + 0x70000004, /**< Index of version string in string table. */
    MIPS_FLAGS                 = MIPS_DISC + 0x70000005, /**< 32 bits of flags. */
    MIPS_BASE_ADDRESS          = MIPS_DISC + 0x70000006, /**< Base address of the segment. */
    MIPS_MSYM                  = MIPS_DISC + 0x70000007, /**< Address of .msym section. */
    MIPS_CONFLICT              = MIPS_DISC + 0x70000008, /**< Address of .conflict section. */
    MIPS_LIBLIST               = MIPS_DISC + 0x70000009, /**< Address of .liblist section. */
    MIPS_LOCAL_GOTNO           = MIPS_DISC + 0x7000000a, /**< Number of local global offset table entries. */
    MIPS_CONFLICTNO            = MIPS_DISC + 0x7000000b, /**< Number of entries in the .conflict section. */
    MIPS_LIBLISTNO             = MIPS_DISC + 0x70000010, /**< Number of entries in the .liblist section. */
    MIPS_SYMTABNO              = MIPS_DISC + 0x70000011, /**< Number of entries in the .dynsym section. */
    MIPS_UNREFEXTNO            = MIPS_DISC + 0x70000012, /**< Index of first external dynamic symbol not referenced locally. */
    MIPS_GOTSYM                = MIPS_DISC + 0x70000013, /**< Index of first dynamic symbol in global offset table. */
    MIPS_HIPAGENO              = MIPS_DISC + 0x70000014, /**< Number of page table entries in global offset table. */
    MIPS_RLD_MAP               = MIPS_DISC + 0x70000016, /**< Address of run time loader map, used for debugging. */
    MIPS_DELTA_CLASS           = MIPS_DISC + 0x70000017, /**< Delta C++ class definition. */
    MIPS_DELTA_CLASS_NO        = MIPS_DISC + 0x70000018, /**< Number of entries in DT_MIPS_DELTA_CLASS. */
    MIPS_DELTA_INSTANCE        = MIPS_DISC + 0x70000019, /**< Delta C++ class instances. */
    MIPS_DELTA_INSTANCE_NO     = MIPS_DISC + 0x7000001A, /**< Number of entries in DT_MIPS_DELTA_INSTANCE. */
    MIPS_DELTA_RELOC           = MIPS_DISC + 0x7000001B, /**< Delta relocations. */
    MIPS_DELTA_RELOC_NO        = MIPS_DISC + 0x7000001C, /**< Number of entries in DT_MIPS_DELTA_RELOC. */
    MIPS_DELTA_SYM             = MIPS_DISC + 0x7000001D, /**< Delta symbols that Delta relocations refer to. */
    MIPS_DELTA_SYM_NO          = MIPS_DISC + 0x7000001E, /**< Number of entries in DT_MIPS_DELTA_SYM. */
    MIPS_DELTA_CLASSSYM        = MIPS_DISC + 0x70000020, /**< Delta symbols that hold class declarations. */
    MIPS_DELTA_CLASSSYM_NO     = MIPS_DISC + 0x70000021, /**< Number of entries in DT_MIPS_DELTA_CLASSSYM. */
    MIPS_CXX_FLAGS             = MIPS_DISC + 0x70000022, /**< Flags indicating information about C++ flavor. */
    MIPS_PIXIE_INIT            = MIPS_DISC + 0x70000023, /**< Pixie information. */
    MIPS_SYMBOL_LIB            = MIPS_DISC + 0x70000024, /**< Address of .MIPS.symlib */
    MIPS_LOCALPAGE_GOTIDX      = MIPS_DISC + 0x70000025, /**< The GOT index of the first PTE for a segment */
    MIPS_LOCAL_GOTIDX          = MIPS_DISC + 0x70000026, /**< The GOT index of the first PTE for a local symbol */
    MIPS_HIDDEN_GOTIDX         = MIPS_DISC + 0x70000027, /**< The GOT index of the first PTE for a hidden symbol */
    MIPS_PROTECTED_GOTIDX      = MIPS_DISC + 0x70000028, /**< The GOT index of the first PTE for a protected symbol */
    MIPS_OPTIONS               = MIPS_DISC + 0x70000029, /**< Address of `.MIPS.options'. */
    MIPS_INTERFACE             = MIPS_DISC + 0x7000002A, /**< Address of `.interface'. */
    MIPS_DYNSTR_ALIGN          = MIPS_DISC + 0x7000002B, /**< Unknown. */
    MIPS_INTERFACE_SIZE        = MIPS_DISC + 0x7000002C, /**< Size of the .interface section. */
    MIPS_RLD_TEXT_RESOLVE_ADDR = MIPS_DISC + 0x7000002D, /**< Size of rld_text_resolve function stored in the GOT. */
    MIPS_PERF_SUFFIX           = MIPS_DISC + 0x7000002E, /**< Default suffix of DSO to be added by rld on dlopen() calls. */
    MIPS_COMPACT_SIZE          = MIPS_DISC + 0x7000002F, /**< Size of compact relocation section (O32). */
    MIPS_GP_VALUE              = MIPS_DISC + 0x70000030, /**< GP value for auxiliary GOTs. */
    MIPS_AUX_DYNAMIC           = MIPS_DISC + 0x70000031, /**< Address of auxiliary .dynamic. */
    MIPS_PLTGOT                = MIPS_DISC + 0x70000032, /**< Address of the base of the PLTGOT. */
    MIPS_RWPLT                 = MIPS_DISC + 0x70000034,
    MIPS_RLD_MAP_REL           = MIPS_DISC + 0x70000035,
    MIPS_XHASH                 = MIPS_DISC + 0x70000036,

    AARCH64_BTI_PLT            = AARCH64_DISC + 0x70000001,
    AARCH64_PAC_PLT            = AARCH64_DISC + 0x70000003,
    AARCH64_VARIANT_PCS        = AARCH64_DISC + 0x70000005,
    AARCH64_MEMTAG_MODE        = AARCH64_DISC + 0x70000009,
    AARCH64_MEMTAG_HEAP        = AARCH64_DISC + 0x7000000b,
    AARCH64_MEMTAG_STACK       = AARCH64_DISC + 0x7000000c,
    AARCH64_MEMTAG_GLOBALS     = AARCH64_DISC + 0x7000000d,
    AARCH64_MEMTAG_GLOBALSSZ   = AARCH64_DISC + 0x7000000f,

    HEXAGON_SYMSZ              = HEXAGON_DISC + 0x70000000,
    HEXAGON_VER                = HEXAGON_DISC + 0x70000001,
    HEXAGON_PLT                = HEXAGON_DISC + 0x70000002,

    PPC_GOT                    = PPC_DISC     + 0x70000000,
    PPC_OPT                    = PPC_DISC     + 0x70000001,

    PPC64_GLINK                = PPC64_DISC   + 0x70000000,
    PPC64_OPT                  = PPC64_DISC   + 0x70000003,

    RISCV_VARIANT_CC           = RISCV_DISC   + 0x70000003,
  };

  static TAG from_value(uint64_t value, ARCH arch);
  static uint64_t to_value(TAG tag);

  DynamicEntry() = default;
  DynamicEntry(const details::Elf64_Dyn& header, ARCH arch);
  DynamicEntry(const details::Elf32_Dyn& header, ARCH arch);

  DynamicEntry(TAG tag, uint64_t value) :
    tag_(tag), value_(value)
  {}

  DynamicEntry& operator=(const DynamicEntry&) = default;
  DynamicEntry(const DynamicEntry&) = default;
  ~DynamicEntry() override = default;

  virtual std::unique_ptr<DynamicEntry> clone() const {
    return std::unique_ptr<DynamicEntry>(new DynamicEntry(*this));
  }

  //! Tag of the current entry. The most common tags are:
  //! DT_NEEDED, DT_INIT, ...
  TAG tag() const {
    return tag_;
  }

  //! Return the entry's value
  //!
  //! The meaning of the value strongly depends on the tag.
  //! It can be an offset, an index, a flag, ...
  uint64_t value() const {
    return value_;
  }

  void tag(TAG tag) {
    tag_ = tag;
  }

  void value(uint64_t value) {
    value_ = value;
  }

  void accept(Visitor& visitor) const override;

  virtual std::ostream& print(std::ostream& os) const;

  LIEF_API friend
  std::ostream& operator<<(std::ostream& os, const DynamicEntry& entry) {
    return entry.print(os);
  }

  protected:
  TAG      tag_ = TAG::DT_NULL;
  uint64_t value_ = 0;
};

LIEF_API const char* to_string(DynamicEntry::TAG e);

}
}
#endif

```

`KDemu/include/LIEF/LIEF/ELF/DynamicEntryArray.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_DYNAMIC_ENTRY_ARRAY_H
#define LIEF_ELF_DYNAMIC_ENTRY_ARRAY_H

#include "LIEF/visibility.h"
#include "LIEF/ELF/DynamicEntry.hpp"

#include <vector>

namespace LIEF {
namespace ELF {

//! Class that represent an Array in the dynamic table.
//! This entry is associated with constructors:
//! - ``DT_PREINIT_ARRAY``
//! - ``DT_INIT_ARRAY``
//! - ``DT_FINI_ARRAY``
//!
//! The underlying values are 64-bits integers to cover both:
//! ELF32 and ELF64 binaries.
class LIEF_API DynamicEntryArray : public DynamicEntry {
  public:
  using array_t = std::vector<uint64_t>;
  using DynamicEntry::DynamicEntry;

  DynamicEntryArray() = delete;
  DynamicEntryArray(DynamicEntry::TAG tag, array_t array) :
    DynamicEntry(tag, 0),
    array_(std::move(array))
  {}

  DynamicEntryArray& operator=(const DynamicEntryArray&) = default;
  DynamicEntryArray(const DynamicEntryArray&) = default;

  std::unique_ptr<DynamicEntry> clone() const override {
    return std::unique_ptr<DynamicEntryArray>(new DynamicEntryArray(*this));
  }

  //! Return the array values (list of pointers)
  array_t& array() {
    return array_;
  }

  const array_t& array() const {
    return array_;
  }
  void array(const array_t& array) {
    array_ = array;
  }

  //! Insert the given function at ``pos``
  DynamicEntryArray& insert(size_t pos, uint64_t function);

  //! Append the given function
  DynamicEntryArray& append(uint64_t function) {
    array_.push_back(function);
    return *this;
  }

  //! Remove the given function
  DynamicEntryArray& remove(uint64_t function);

  //! Number of function registred in this array
  size_t size() const {
    return array_.size();
  }

  DynamicEntryArray& operator+=(uint64_t value) {
    return append(value);
  }

  DynamicEntryArray& operator-=(uint64_t value) {
    return remove(value);
  }

  const uint64_t& operator[](size_t idx) const;
  uint64_t&       operator[](size_t idx);

  void accept(Visitor& visitor) const override;

  std::ostream& print(std::ostream& os) const override;

  ~DynamicEntryArray() override = default;

  static bool classof(const DynamicEntry* entry) {
    const DynamicEntry::TAG tag = entry->tag();
    return tag == DynamicEntry::TAG::INIT_ARRAY ||
           tag == DynamicEntry::TAG::FINI_ARRAY ||
           tag == DynamicEntry::TAG::PREINIT_ARRAY;
  }

  private:
  array_t array_;
};
}
}

#endif

```

`KDemu/include/LIEF/LIEF/ELF/DynamicEntryFlags.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_DYNAMIC_ENTRY_FLAGS_H
#define LIEF_ELF_DYNAMIC_ENTRY_FLAGS_H

#include <vector>
#include <ostream>

#include "LIEF/visibility.h"
#include "LIEF/ELF/DynamicEntry.hpp"

namespace LIEF {
namespace ELF {

class LIEF_API DynamicEntryFlags : public DynamicEntry {
  public:
  static constexpr uint64_t BASE = 0x100000000;

  enum class FLAG : uint64_t {
    ORIGIN        = 0x00000001, /**< The object may reference $ORIGIN. */
    SYMBOLIC      = 0x00000002, /**< Search the shared lib before searching the exe. */
    TEXTREL       = 0x00000004, /**< Relocations may modify a non-writable segment. */
    BIND_NOW      = 0x00000008, /**< Process all relocations on load. */
    STATIC_TLS    = 0x00000010, /**< Reject attempts to load dynamically. */

    NOW           = BASE + 0x000000001, /**< Set RTLD_NOW for this object. */
    GLOBAL        = BASE + 0x000000002, /**< Set RTLD_GLOBAL for this object. */
    GROUP         = BASE + 0x000000004, /**< Set RTLD_GROUP for this object. */
    NODELETE      = BASE + 0x000000008, /**< Set RTLD_NODELETE for this object. */
    LOADFLTR      = BASE + 0x000000010, /**< Trigger filtee loading at runtime. */
    INITFIRST     = BASE + 0x000000020, /**< Set RTLD_INITFIRST for this object. */
    NOOPEN        = BASE + 0x000000040, /**< Set RTLD_NOOPEN for this object. */
    HANDLE_ORIGIN = BASE + 0x000000080, /**< $ORIGIN must be handled. */
    DIRECT        = BASE + 0x000000100, /**< Direct binding enabled. */
    TRANS         = BASE + 0x000000200,
    INTERPOSE     = BASE + 0x000000400, /**< Object is used to interpose. */
    NODEFLIB      = BASE + 0x000000800, /**< Ignore default lib search path. */
    NODUMP        = BASE + 0x000001000, /**< Object can't be dldump'ed. */
    CONFALT       = BASE + 0x000002000, /**< Configuration alternative created. */
    ENDFILTEE     = BASE + 0x000004000, /**< Filtee terminates filters search. */
    DISPRELDNE    = BASE + 0x000008000, /**< Disp reloc applied at build time. */
    DISPRELPND    = BASE + 0x000010000, /**< Disp reloc applied at run-time. */
    NODIRECT      = BASE + 0x000020000, /**< Object has no-direct binding. */
    IGNMULDEF     = BASE + 0x000040000,
    NOKSYMS       = BASE + 0x000080000,
    NOHDR         = BASE + 0x000100000,
    EDITED        = BASE + 0x000200000, /**< Object is modified after built. */
    NORELOC       = BASE + 0x000400000,
    SYMINTPOSE    = BASE + 0x000800000, /**< Object has individual interposers. */
    GLOBAUDIT     = BASE + 0x001000000, /**< Global auditing required. */
    SINGLETON     = BASE + 0x002000000, /**< Singleton symbols are used. */
    PIE           = BASE + 0x008000000, /**< Singleton symbols are used. */
    KMOD          = BASE + 0x010000000,
    WEAKFILTER    = BASE + 0x020000000,
    NOCOMMON      = BASE + 0x040000000,
  };

  using flags_list_t = std::vector<FLAG>;

  public:
  using DynamicEntry::DynamicEntry;
  DynamicEntryFlags() = delete;

  static DynamicEntryFlags create_dt_flag(uint64_t value) {
    return DynamicEntryFlags(DynamicEntry::TAG::FLAGS, value);
  }

  static DynamicEntryFlags create_dt_flag_1(uint64_t value) {
    return DynamicEntryFlags(DynamicEntry::TAG::FLAGS_1, value);
  }

  DynamicEntryFlags& operator=(const DynamicEntryFlags&) = default;
  DynamicEntryFlags(const DynamicEntryFlags&) = default;

  std::unique_ptr<DynamicEntry> clone() const override {
    return std::unique_ptr<DynamicEntryFlags>(new DynamicEntryFlags(*this));
  }

  //! If the current entry has the given FLAG
  bool has(FLAG f) const;

  //! Return flags as a list of integers
  flags_list_t flags() const;

  //! Add the given FLAG
  void add(FLAG f);

  //! Remove the given FLAG
  void remove(FLAG f);

  DynamicEntryFlags& operator+=(FLAG f) {
    add(f);
    return *this;
  }

  DynamicEntryFlags& operator-=(FLAG f) {
    remove(f);
    return *this;
  }

  void accept(Visitor& visitor) const override;

  static bool classof(const DynamicEntry* entry) {
    return entry->tag() == DynamicEntry::TAG::FLAGS ||
           entry->tag() == DynamicEntry::TAG::FLAGS_1;
  }

  ~DynamicEntryFlags() = default;

  std::ostream& print(std::ostream& os) const override;
  private:
  DynamicEntryFlags(DynamicEntry::TAG tag, uint64_t flags) :
    DynamicEntry(tag, flags)
  {}
};

LIEF_API const char* to_string(DynamicEntryFlags::FLAG e);

}
}

#endif

```

`KDemu/include/LIEF/LIEF/ELF/DynamicEntryLibrary.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_DYNAMIC_ENTRY_LIBRARY_H
#define LIEF_ELF_DYNAMIC_ENTRY_LIBRARY_H

#include <string>
#include "LIEF/visibility.h"
#include "LIEF/ELF/DynamicEntry.hpp"

namespace LIEF {
namespace ELF {

//! Class which represents a ``DT_NEEDED`` entry in the dynamic table.
//!
//! This kind of entry is usually used to create library dependency.
class LIEF_API DynamicEntryLibrary : public DynamicEntry {

  public:
  using DynamicEntry::DynamicEntry;

  DynamicEntryLibrary() :
    DynamicEntry::DynamicEntry{DynamicEntry::TAG::NEEDED, 0}
  {}

  DynamicEntryLibrary(std::string name) :
    DynamicEntry::DynamicEntry{DynamicEntry::TAG::NEEDED, 0},
    libname_(std::move(name))
  {}

  DynamicEntryLibrary& operator=(const DynamicEntryLibrary&) = default;
  DynamicEntryLibrary(const DynamicEntryLibrary&) = default;

  std::unique_ptr<DynamicEntry> clone() const override {
    return std::unique_ptr<DynamicEntryLibrary>(new DynamicEntryLibrary{*this});
  }

  //! Return the library associated with this entry (e.g. ``libc.so.6``)
  const std::string& name() const {
    return libname_;
  }

  void name(std::string name) {
    libname_ = std::move(name);
  }

  static bool classof(const DynamicEntry* entry) {
    return entry->tag() == DynamicEntry::TAG::NEEDED;
  }

  void accept(Visitor& visitor) const override;

  std::ostream& print(std::ostream& os) const override;

  private:
  std::string libname_;
};
}
}

#endif

```

`KDemu/include/LIEF/LIEF/ELF/DynamicEntryRpath.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_DYNAMIC_ENTRY_RPATH_H
#define LIEF_ELF_DYNAMIC_ENTRY_RPATH_H

#include <string>
#include <vector>

#include "LIEF/visibility.h"
#include "LIEF/ELF/DynamicEntry.hpp"

namespace LIEF {
namespace ELF {

//! Class which represents a ``DT_RPATH`` entry. This attribute is
//! deprecated (cf. ``man ld``) in favour of ``DT_RUNPATH`` (See DynamicRunPath)
class LIEF_API DynamicEntryRpath : public DynamicEntry {
  public:
  static constexpr char delimiter = ':';
  using DynamicEntry::DynamicEntry;
  DynamicEntryRpath() :
    DynamicEntry::DynamicEntry(DynamicEntry::TAG::RPATH, 0)
  {}

  DynamicEntryRpath(std::string rpath) :
    DynamicEntry::DynamicEntry(DynamicEntry::TAG::RPATH, 0),
    rpath_(std::move(rpath))
  {}

  //! Constructor from a list of paths
  DynamicEntryRpath(const std::vector<std::string>& paths) :
    DynamicEntry::DynamicEntry(DynamicEntry::TAG::RPATH, 0)
  {
    this->paths(paths);
  }

  DynamicEntryRpath& operator=(const DynamicEntryRpath&) = default;
  DynamicEntryRpath(const DynamicEntryRpath&) = default;

  std::unique_ptr<DynamicEntry> clone() const override {
    return std::unique_ptr<DynamicEntryRpath>(new DynamicEntryRpath(*this));
  }

  //! The actual rpath as a string
  const std::string& rpath() const {
    return rpath_;
  }

  void rpath(std::string name) {
    rpath_ = std::move(name);
  }

  //! Paths as a list
  std::vector<std::string> paths() const;
  void paths(const std::vector<std::string>& paths);

  //! Insert a ``path`` at the given ``position``
  DynamicEntryRpath& insert(size_t pos, const std::string& path);

  //! Append the given ``path``
  DynamicEntryRpath& append(std::string path);

  //! Remove the given ``path``
  DynamicEntryRpath& remove(const std::string& path);

  DynamicEntryRpath& operator+=(std::string path) {
    return append(std::move(path));
  }

  DynamicEntryRpath& operator-=(const std::string& path) {
    return remove(path);
  }

  static bool classof(const DynamicEntry* entry) {
    return entry->tag() == DynamicEntry::TAG::RPATH;
  }

  void accept(Visitor& visitor) const override;

  std::ostream& print(std::ostream& os) const override;

  ~DynamicEntryRpath() = default;

  private:
  std::string rpath_;
};
}
}

#endif

```

`KDemu/include/LIEF/LIEF/ELF/DynamicEntryRunPath.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_DYNAMIC_ENTRY_RUNPATH_H
#define LIEF_ELF_DYNAMIC_ENTRY_RUNPATH_H

#include <string>
#include <vector>

#include "LIEF/visibility.h"
#include "LIEF/ELF/DynamicEntry.hpp"

namespace LIEF {
namespace ELF {

//! Class that represents a ``DT_RUNPATH`` wich is used by the loader
//! to resolve libraries (DynamicEntryLibrary).
class LIEF_API DynamicEntryRunPath : public DynamicEntry {

  public:
  static constexpr char delimiter = ':';
  using DynamicEntry::DynamicEntry;

  DynamicEntryRunPath() :
    DynamicEntry::DynamicEntry(DynamicEntry::TAG::RUNPATH, 0)
  {}

  //! Constructor from (run)path
  DynamicEntryRunPath(std::string runpath) :
    DynamicEntry::DynamicEntry(DynamicEntry::TAG::RUNPATH, 0),
    runpath_(std::move(runpath))
  {}

  //! Constructor from a list of paths
  DynamicEntryRunPath(const std::vector<std::string>& paths) :
    DynamicEntry::DynamicEntry(DynamicEntry::TAG::RUNPATH, 0)
  {
    this->paths(paths);
  }

  DynamicEntryRunPath& operator=(const DynamicEntryRunPath&) = default;
  DynamicEntryRunPath(const DynamicEntryRunPath&) = default;

  std::unique_ptr<DynamicEntry> clone() const override {
    return std::unique_ptr<DynamicEntry>(new DynamicEntryRunPath(*this));
  }

  //! Runpath raw value
  const std::string& runpath() const {
    return runpath_;
  }

  void runpath(std::string runpath) {
    runpath_ = std::move(runpath);
  }

  //! Paths as a list
  std::vector<std::string> paths() const;
  void paths(const std::vector<std::string>& paths);

  //! Insert a ``path`` at the given ``position``
  DynamicEntryRunPath& insert(size_t pos, const std::string& path);

  //! Append the given ``path``
  DynamicEntryRunPath& append(const std::string& path);

  //! Remove the given ``path``
  DynamicEntryRunPath& remove(const std::string& path);

  DynamicEntryRunPath& operator+=(std::string path) {
    return append(std::move(path));
  }

  DynamicEntryRunPath& operator-=(const std::string& path) {
    return remove(path);
  }

  void accept(Visitor& visitor) const override;

  static bool classof(const DynamicEntry* entry) {
    return entry->tag() == DynamicEntry::TAG::RUNPATH;
  }

  std::ostream& print(std::ostream& os) const override;

  ~DynamicEntryRunPath() = default;

  private:
  std::string runpath_;
};
}
}
#endif

```

`KDemu/include/LIEF/LIEF/ELF/DynamicSharedObject.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_DYNAMIC_SHARED_OBJECT_H
#define LIEF_ELF_DYNAMIC_SHARED_OBJECT_H

#include <string>

#include "LIEF/visibility.h"
#include "LIEF/ELF/DynamicEntry.hpp"

namespace LIEF {
namespace ELF {

//! Class which represents a ``DT_SONAME`` entry in the dynamic table
//! This kind of entry is usually used to name the original library.
//!
//! This entry is not present for executable.
class LIEF_API DynamicSharedObject : public DynamicEntry {

  public:
  using DynamicEntry::DynamicEntry;
  DynamicSharedObject() :
    DynamicEntry(DynamicEntry::TAG::SONAME, 0)
  {}

  DynamicSharedObject(std::string name) :
    DynamicEntry(DynamicEntry::TAG::SONAME, 0),
    name_(std::move(name))
  {}

  DynamicSharedObject& operator=(const DynamicSharedObject&) = default;
  DynamicSharedObject(const DynamicSharedObject&) = default;

  std::unique_ptr<DynamicEntry> clone() const override {
    return std::unique_ptr<DynamicSharedObject>(new DynamicSharedObject(*this));
  }

  //! The actual name (e.g. ``libMyLib.so``)
  const std::string& name() const {
    return name_;
  }

  void name(std::string name) {
    name_ = std::move(name);
  }

  void accept(Visitor& visitor) const override;

  std::ostream& print(std::ostream& os) const override;

  static bool classof(const DynamicEntry* entry) {
    return entry->tag() == DynamicEntry::TAG::SONAME;
  }

  ~DynamicSharedObject() override = default;

  private:
  std::string name_;
};
}
}
#endif

```

`KDemu/include/LIEF/LIEF/ELF/EnumToString.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef ELF_ENUM_TO_STRING_H
#define ELF_ENUM_TO_STRING_H
#include "LIEF/visibility.h"
#include "LIEF/ELF/enums.hpp"

namespace LIEF {
namespace ELF {
LIEF_API const char* to_string(ARCH e);
} // namespace ELF
} // namespace LIEF

#endif


```

`KDemu/include/LIEF/LIEF/ELF/GnuHash.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_GNU_HASH_H
#define LIEF_ELF_GNU_HASH_H

#include <vector>
#include <ostream>
#include <cstdint>

#include "LIEF/Object.hpp"
#include "LIEF/visibility.h"

namespace LIEF {
namespace ELF {

class Parser;
class Builder;
class Binary;

//! Class which provides a view over the GNU Hash implementation.
//! Most of the fields are read-only since the values
//! are re-computed by the LIEF::ELF::Builder.
class LIEF_API GnuHash : public Object {

  friend class Parser;
  friend class Builder;
  friend class Binary;

  public:
  GnuHash() = default;
  GnuHash(uint32_t symbol_idx, uint32_t shift2,
          std::vector<uint64_t> bloom_filters, std::vector<uint32_t> buckets,
          std::vector<uint32_t> hash_values = {});


  GnuHash& operator=(const GnuHash& copy) = default;
  GnuHash(const GnuHash& copy) = default;

  GnuHash(GnuHash&&) = default;
  GnuHash& operator=(GnuHash&&) = default;

  ~GnuHash() override = default;

  //! Return the number of buckets
  //! @see GnuHash::buckets
  uint32_t nb_buckets() const {
    return buckets_.size();
  }

  //! Index of the first symbol in the dynamic
  //! symbols table which accessible with the hash table
  uint32_t symbol_index() const {
    return symbol_index_;
  }

  //! Shift count used in the bloom filter
  uint32_t shift2() const {
    return shift2_;
  }

  //! Number of bloom filters used.
  //! It must be a power of 2
  uint32_t maskwords() const {
    return bloom_filters_.size();
  }

  //! Bloom filters
  const std::vector<uint64_t>& bloom_filters() const {
    return bloom_filters_;
  }

  //! Hash buckets
  const std::vector<uint32_t>& buckets() const {
    return buckets_;
  }

  //! Hash values
  const std::vector<uint32_t>& hash_values() const {
    return hash_values_;
  }

  //! Check if the given hash passes the bloom filter
  bool check_bloom_filter(uint32_t hash) const;

  //! Check if the given hash passes the bucket filter
  bool check_bucket(uint32_t hash) const {
    return buckets_[hash % nb_buckets()] > 0;
  }

  //! Check if the symbol *probably* exists. If
  //! the returned value is ``false`` you can assume at ``100%`` that
  //! the symbol with the given name doesn't exist. If ``true``, you can't
  //! do any assumption
  bool check(const std::string& symbol_name) const;

  //! Check if the symbol associated with the given hash *probably* exists. If
  //! the returned value is ``false`` you can assume at ``100%`` that
  //! the symbol doesn't exists. If ``true`` you can't
  //! do any assumption
  bool check(uint32_t hash) const;


  void accept(Visitor& visitor) const override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const GnuHash& gnuhash);

  private:
  uint32_t symbol_index_ = 0;
  uint32_t shift2_       = 0;

  std::vector<uint64_t> bloom_filters_;
  std::vector<uint32_t> buckets_;
  std::vector<uint32_t> hash_values_;

  size_t c_ = 0;
};


} // namepsace ELF
} // namespace LIEF

#endif

```

`KDemu/include/LIEF/LIEF/ELF/Header.h`:

```h
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_C_ELF_HEADER_H
#define LIEF_C_ELF_HEADER_H
#include <inttypes.h>

#include "LIEF/ELF/enums.h"

#ifdef __cplusplus
extern "C" {
#endif

struct Elf_Header_t {
  uint8_t  identity[LIEF_EI_NIDENT];
  uint32_t file_type;
  uint32_t machine_type;
  uint32_t object_file_version;
  uint64_t entrypoint;
  uint64_t program_headers_offset;
  uint64_t section_headers_offset;
  uint32_t processor_flags;
  uint32_t header_size;
  uint32_t program_header_size;
  uint32_t numberof_segments;
  uint32_t section_header_size;
  uint32_t numberof_sections;
  uint32_t name_string_table_idx;
};

typedef struct Elf_Header_t Elf_Header_t;


#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/include/LIEF/LIEF/ELF/Header.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_HEADER_H
#define LIEF_ELF_HEADER_H

#include <ostream>
#include <array>
#include <vector>
#include <set>

#include "LIEF/Object.hpp"
#include "LIEF/visibility.h"
#include "LIEF/Abstract/enums.hpp"

#include "LIEF/ELF/enums.hpp"
#include "LIEF/ELF/ProcessorFlags.hpp"

namespace LIEF {
namespace ELF {
class Parser;

/// Class which represents the ELF's header. This class mirrors the raw
/// ELF `Elfxx_Ehdr` structure
class LIEF_API Header : public Object {
  friend class Parser;
  public:
  using identity_t = std::array<uint8_t, 16>;
  using abstract_architecture_t = std::pair<ARCHITECTURES, std::set<MODES>>;

  public:
  /// e_ident size and indices.
  enum {
    EI_MAG0       = 0,  ///< File identification index.
    EI_MAG1       = 1,  ///< File identification index.
    EI_MAG2       = 2,  ///< File identification index.
    EI_MAG3       = 3,  ///< File identification index.
    EI_CLASS      = 4,  ///< File class.
    EI_DATA       = 5,  ///< Data encoding.
    EI_VERSION    = 6,  ///< File version.
    EI_OSABI      = 7,  ///< OS/ABI identification.
    EI_ABIVERSION = 8,  ///< ABI version.
    EI_PAD        = 9,  ///< Start of padding bytes.
    EI_NIDENT     = 16  ///< Number of bytes in e_ident.
  };

  /// The type of the underlying ELF file. This enum matches
  /// the semantic of `ET_NONE`, `ET_REL`, ...
  enum class FILE_TYPE {
    NONE = 0, ///< Can't be determined
    REL  = 1, ///< Relocatable file (or object file)
    EXEC = 2, ///< non-pie executable
    DYN  = 3, ///< Shared library **or** a pie-executable
    CORE = 4, ///< Core dump file
  };

  /// Match the result of `Elfxx_Ehdr.e_version`
  enum class VERSION {
    NONE    = 0, ///< Invalid ELF version
    CURRENT = 1, ///< Current version (default)
  };

  /// Match the result of `Elfxx_Ehdr.e_ident[EI_CLASS]`
  enum class CLASS {
    NONE = 0, /// Invalid class
    ELF32,    /// 32-bit objects
    ELF64,    /// 64-bits objects
  };

  /// Match the result `Elfxx_Ehdr.e_ident[EI_OSABI]`
  enum class OS_ABI {
    SYSTEMV      = 0,  /// UNIX System V ABI
    HPUX         = 1,  /// HP-UX operating system
    NETBSD       = 2,  /// NetBSD
    GNU          = 3,  /// GNU/Linux
    LINUX        = 3,  /// Historical alias for ELFOSABI_GNU.
    HURD         = 4,  /// GNU/Hurd
    SOLARIS      = 6,  /// Solaris
    AIX          = 7,  /// AIX
    IRIX         = 8,  /// IRIX
    FREEBSD      = 9,  /// FreeBSD
    TRU64        = 10, /// TRU64 UNIX
    MODESTO      = 11, /// Novell Modesto
    OPENBSD      = 12, /// OpenBSD
    OPENVMS      = 13, /// OpenVMS
    NSK          = 14, /// Hewlett-Packard Non-Stop Kernel
    AROS         = 15, /// AROS
    FENIXOS      = 16, /// FenixOS
    CLOUDABI     = 17, /// Nuxi CloudABI
    C6000_ELFABI = 64, /// Bare-metal TMS320C6000
    AMDGPU_HSA   = 64, /// AMD HSA runtime
    C6000_LINUX  = 65, /// Linux TMS320C6000
    ARM          = 97, /// ARM
    STANDALONE   = 255 /// Standalone (embedded) application
  };

  /// Match the result `Elfxx_Ehdr.e_ident[EI_DATA]`
  enum class ELF_DATA {
    NONE = 0, /// Invalid data encoding
    LSB  = 1, /// 2's complement, little endian
    MSB  = 2  /// 2's complement, big endian
  };

  Header() = default;

  Header& operator=(const Header&) = default;
  Header(const Header&) = default;

  ~Header() override = default;

  /// Define the object file type. (e.g. executable, library...)
  FILE_TYPE file_type() const {
    return file_type_;
  }

  /// LIEF abstract object type
  OBJECT_TYPES abstract_object_type() const;

  /// Target architecture
  ARCH machine_type() const {
    return machine_type_;
  }

  /// LIEF abstract architecture
  abstract_architecture_t abstract_architecture() const;

  /// LIEF abstract endianness
  ENDIANNESS abstract_endianness() const;

  /// Version of the object file format
  VERSION object_file_version() const {
    return object_file_version_;
  }

  /// Executable entrypoint
  uint64_t entrypoint() const {
    return entrypoint_;
  }

  /// Offset of the programs table (also known as segments table)
  uint64_t program_headers_offset() const {
    return program_headers_offset_;
  }

  /// Offset of the sections table
  uint64_t section_headers_offset() const {
    return section_headers_offset_;
  }

  /// Processor-specific flags
  uint32_t processor_flag() const {
    return processor_flags_;
  }

  /// Size of the current header (i.e. `sizeof(Elfxx_Ehdr)`)
  /// This size should be 64 for an `ELF64` binary and 52 for an `ELF32`.
  uint32_t header_size() const {
    return header_size_;
  }

  /// Return the size of a program header (i.e. `sizeof(Elfxx_Phdr)`)
  /// This size should be 56 for an `ELF64` binary and 32 for an `ELF32`.
  uint32_t program_header_size() const {
    return program_header_size_;
  }

  /// Return the the number of segments
  uint32_t numberof_segments() const {
    return numberof_segments_;
  }

  /// Return the size of a section header (i.e. `sizeof(Elfxx_Shdr)`)
  /// This size should be 64 for a ``ELF64`` binary and 40 for an ``ELF32``.
  uint32_t section_header_size() const {
    return section_header_size_;
  }

  /// Return the number of sections
  ///
  /// @warning This value could differ from the real number of sections
  /// present in the binary. It must be taken as an *indication*
  uint32_t numberof_sections() const {
    return numberof_sections_;
  }

  /// Return the section's index which contains sections' names
  uint32_t section_name_table_idx() const {
    return section_string_table_idx_;
  }

  /// Return the ELF identity as an `std::array`
  identity_t& identity() {
    return identity_;
  }

  const identity_t& identity() const {
    return identity_;
  }

  /// Return the object's class. `ELF64` or `ELF32`
  CLASS identity_class() const {
    return CLASS(identity_[EI_CLASS]);
  }

  /// Specify the data encoding
  ELF_DATA identity_data() const {
    return ELF_DATA(identity_[EI_DATA]);
  }

  /// @see object_file_version
  VERSION identity_version() const {
    return VERSION(identity_[EI_VERSION]);
  }

  /// Identifies the version of the ABI for which the object is prepared
  OS_ABI identity_os_abi() const {
    return OS_ABI(identity_[EI_OSABI]);
  }

  /// ABI Version
  uint32_t identity_abi_version() const {
    return identity_[EI_ABIVERSION];
  }

  bool has(PROCESSOR_FLAGS flag) const;

  std::vector<PROCESSOR_FLAGS> flags_list() const;

  void file_type(FILE_TYPE type) {
    file_type_ = type;
  }

  void machine_type(ARCH arch) {
    machine_type_ = arch;
  }

  void object_file_version(VERSION version) {
    object_file_version_ = version;
  }

  void entrypoint(uint64_t entry) {
    entrypoint_ = entry;
  }

  void program_headers_offset(uint64_t offset) {
    program_headers_offset_ = offset;
  }

  void section_headers_offset(uint64_t offset) {
    section_headers_offset_ = offset;
  }

  void processor_flag(uint32_t flags) {
    processor_flags_ = flags;
  }

  void header_size(uint32_t size) {
    header_size_ = size;
  }

  void program_header_size(uint32_t size) {
    program_header_size_ = size;
  }

  void numberof_segments(uint32_t n) {
    numberof_segments_ = n;
  }
  void section_header_size(uint32_t size) {
    section_header_size_ = size;
  }

  void numberof_sections(uint32_t n) {
    numberof_sections_ = n;
  }
  void section_name_table_idx(uint32_t idx) {
    section_string_table_idx_ = idx;
  }

  void identity(const std::string& identity);
  void identity(const identity_t& identity);

  void identity_class(CLASS cls) {
    identity_[EI_CLASS] = static_cast<uint8_t>(cls);
  }

  void identity_data(ELF_DATA data) {
    identity_[EI_DATA] = static_cast<uint8_t>(data);
  }

  void identity_version(VERSION version) {
    identity_[EI_VERSION] = static_cast<uint8_t>(version);
  }

  void identity_os_abi(OS_ABI osabi) {
    identity_[EI_OSABI] = static_cast<uint8_t>(osabi);
  }

  void identity_abi_version(uint8_t version) {
    identity_[EI_ABIVERSION] = version;
  }

  void accept(Visitor& visitor) const override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const Header& hdr);

  private:
  template<class T>
  LIEF_LOCAL Header(const T& header);

  identity_t identity_;
  FILE_TYPE file_type_ = FILE_TYPE::NONE;
  ARCH machine_type_ = ARCH::NONE;
  VERSION object_file_version_ = VERSION::NONE;
  uint64_t entrypoint_ = 0;
  uint64_t program_headers_offset_ = 0;
  uint64_t section_headers_offset_ = 0;
  uint32_t processor_flags_ = 0;
  uint32_t header_size_ = 0;
  uint32_t program_header_size_ = 0;
  uint32_t numberof_segments_ = 0;
  uint32_t section_header_size_ = 0;
  uint32_t numberof_sections_ = 0;
  uint32_t section_string_table_idx_ = 0;
};

LIEF_API const char* to_string(Header::FILE_TYPE type);
LIEF_API const char* to_string(Header::VERSION version);
LIEF_API const char* to_string(Header::CLASS version);
LIEF_API const char* to_string(Header::OS_ABI abi);
LIEF_API const char* to_string(Header::ELF_DATA abi);

}
}
#endif

```

`KDemu/include/LIEF/LIEF/ELF/Note.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_NOTE_H
#define LIEF_ELF_NOTE_H

#include <vector>
#include <ostream>
#include <memory>

#include "LIEF/Object.hpp"
#include "LIEF/visibility.h"
#include "LIEF/errors.hpp"
#include "LIEF/span.hpp"

#include "LIEF/ELF/Header.hpp"

namespace LIEF {
class BinaryStream;
namespace ELF {
class Binary;
class Parser;
class Builder;

/// Class which represents an ELF note. This class can be instantiated using
/// the static Note::create functions.
class LIEF_API Note : public Object {
  friend class Parser;
  friend class Builder;
  friend class Binary;

  public:
  //! Container used to handle the description data
  using description_t = std::vector<uint8_t>;

  /// LIEF representation of the ELF `NT_` values.
  enum class TYPE {
    UNKNOWN = 0,
    /// Match `NT_GNU_ABI_TAG`: Operating system (OS) ABI information
    ///
    /// See: NoteAbi
    GNU_ABI_TAG,
    /// Match `NT_HWCAP`: Synthetic hardware capabilities information
    GNU_HWCAP,
    /// Match `NT_GNU_BUILD_ID`: Unique build ID as generated by the GNU ld
    GNU_BUILD_ID,
    /// Match `NT_GNU_GOLD_VERSION`: The version of gold used to link
    GNU_GOLD_VERSION,
    /// Match `NT_GNU_PROPERTY_TYPE_0`: Program property note, as described in
    /// "Linux Extensions to the gABI".
    GNU_PROPERTY_TYPE_0,

    GNU_BUILD_ATTRIBUTE_OPEN,
    GNU_BUILD_ATTRIBUTE_FUNC,

    /// Crashpad note used by the Chromium project
    CRASHPAD,

    /// Coredump that wraps the `elf_prstatus` structure
    CORE_PRSTATUS,
    CORE_FPREGSET,
    /// Coredump that wraps the `elf_prpsinfo` structure
    ///
    /// See: CorePrPsInfo
    CORE_PRPSINFO,
    CORE_TASKSTRUCT,
    /// Coredump that contains a copy of all the auxiliary vectors (auxv)
    ///
    /// See: CoreAuxv
    CORE_AUXV,
    CORE_PSTATUS,
    /// Coredump that wraps the `fpregset` structure
    CORE_FPREGS,
    /// Coredump that wraps the `psinfo` structure
    CORE_PSINFO,
    CORE_LWPSTATUS,
    CORE_LWPSINFO,
    CORE_WIN32PSTATUS,
    CORE_FILE,
    CORE_PRXFPREG,
    CORE_SIGINFO,

    CORE_ARM_VFP,
    CORE_ARM_TLS,
    CORE_ARM_HW_BREAK,
    CORE_ARM_HW_WATCH,
    CORE_ARM_SYSTEM_CALL,
    CORE_ARM_SVE,
    CORE_ARM_PAC_MASK,
    CORE_ARM_PACA_KEYS,
    CORE_ARM_PACG_KEYS,
    CORE_TAGGED_ADDR_CTRL,
    CORE_PAC_ENABLED_KEYS,

    CORE_X86_TLS,
    CORE_X86_IOPERM,
    CORE_X86_XSTATE,
    CORE_X86_CET,

    /// Note that is specific to Android and that describes information such as
    /// the NDK version or the SDK build number.
    ///
    /// See AndroidIdent
    ANDROID_IDENT,
    ANDROID_MEMTAG,
    ANDROID_KUSER,

    /// Note specific to Go binaries
    GO_BUILDID,
    /// Note for SystemTap probes
    STAPSDT,
    /// QNX Note
    QNX_STACK
  };

  public:
  /// Convert the raw integer note type into a TYPE according to the owner
  static result<TYPE> convert_type(Header::FILE_TYPE ftype, uint32_t type,
                                   const std::string& name);

  /// Try to determine the ELF section name associated with the TYPE
  /// provided in parameter
  static result<const char*> type_to_section(TYPE type);

  static result<std::string> note_to_section(const Note& note) {
    const std::string& sec_name = note.section_name();
    if (sec_name.empty()) {
      return type_to_section(note.type());
    }
    return sec_name;
  }

  /// Try to determine the owner's name of the TYPE provided in parameter
  static result<const char*> type_owner(TYPE type);

  /// Create a new note from the given parameters. Additional information
  /// such as the architecture or the ELF class could be required for
  /// creating notes like Coredump notes.
  static std::unique_ptr<Note> create(
      const std::string& name, uint32_t type, description_t description,
      std::string section_name,
      Header::FILE_TYPE ftype = Header::FILE_TYPE::NONE, ARCH arch = ARCH::NONE,
      Header::CLASS cls = Header::CLASS::NONE);

  /// Create a new note from the given parameters. Additional information
  /// such as the architecture or the ELF class could be required for
  /// creating notes like Coredump notes.
  static std::unique_ptr<Note> create(
      const std::string& name, TYPE type, description_t description,
      std::string section_name,
      ARCH arch = ARCH::NONE, Header::CLASS cls = Header::CLASS::NONE);

  /// Create a new note from the given stream. Additional information
  /// such as the architecture or the ELF class could be required for
  /// creating notes like Coredump notes.
  static std::unique_ptr<Note> create(BinaryStream& stream,
      std::string section_name,
      Header::FILE_TYPE ftype = Header::FILE_TYPE::NONE, ARCH arch = ARCH::NONE,
      Header::CLASS cls = Header::CLASS::NONE);

  Note& operator=(const Note& copy) = default;
  Note(const Note& copy) = default;

  ~Note() override = default;

  /// Clone the current note and keep its polymorphic type
  virtual std::unique_ptr<Note> clone() const {
    return std::unique_ptr<Note>(new Note(*this));
  }

  /// Return the *name* of the note (also known as 'owner' )
  const std::string& name() const {
    return name_;
  }

  /// Return the section name in which the note is or should be stored
  const std::string& section_name() const {
    return section_name_;
  }

  /// Return the type of the note. This type does not match the `NT_` type
  /// value. For accessing the original `NT_` value, check original_type()
  TYPE type() const {
    return type_;
  }

  /// The original `NT_xxx` integer value. The meaning of this value likely
  /// depends on the owner of the note.
  uint32_t original_type() const {
    return original_type_;
  }

  /// Return the description associated with the note
  span<const uint8_t> description() const {
    return description_;
  }

  span<uint8_t> description() {
    return description_;
  }

  void name(std::string name) {
    name_ = std::move(name);
  }

  /// Change the description of the note
  void description(description_t description) {
    description_ = std::move(description);
  }

  /// Size of the **raw** note which includes padding
  uint64_t size() const;

  virtual void dump(std::ostream& os) const;

  void accept(Visitor& visitor) const override;

  LIEF_API friend
  std::ostream& operator<<(std::ostream& os, const Note& note) {
    note.dump(os);
    return os;
  }

  protected:
  Note() = default;
  Note(std::string name, TYPE type, uint32_t original_type,
       description_t description, std::string section) :
    name_(std::move(name)),
    type_(type),
    original_type_(original_type),
    description_(std::move(description)),
    section_name_(std::move(section))
  {}

  template<class T>
  LIEF_LOCAL result<T> read_at(size_t offset) const;

  template<class T>
  LIEF_LOCAL ok_error_t write_at(size_t offset, const T& value);

  LIEF_LOCAL ok_error_t write_string_at(size_t offset, const std::string& value);

  LIEF_LOCAL result<std::string>
  read_string_at(size_t offset, size_t maxsize = 0) const;

  std::string  name_;
  TYPE type_ = TYPE::UNKNOWN;
  uint32_t original_type_ = 0;
  description_t description_;
  std::string section_name_;
};

LIEF_API const char* to_string(Note::TYPE type);


} // namepsace ELF
} // namespace LIEF
#endif

```

`KDemu/include/LIEF/LIEF/ELF/NoteDetails.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_NOTE_DETAILS_H
#define LIEF_ELF_NOTE_DETAILS_H
#include "LIEF/ELF/NoteDetails/QNXStack.hpp"
#include "LIEF/ELF/NoteDetails/AndroidIdent.hpp"
#include "LIEF/ELF/NoteDetails/NoteAbi.hpp"
#include "LIEF/ELF/NoteDetails/NoteGnuProperty.hpp"
#include "LIEF/ELF/NoteDetails/Core.hpp"
#include "LIEF/ELF/NoteDetails/Properties.hpp"

#endif

```

`KDemu/include/LIEF/LIEF/ELF/NoteDetails/AndroidIdent.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_ANDROID_IDENT_H
#define LIEF_ELF_ANDROID_IDENT_H

#include <ostream>
#include <memory>

#include "LIEF/visibility.h"
#include "LIEF/ELF/Note.hpp"

namespace LIEF {
namespace ELF {

//! Class representing the ".note.android.ident" section
//!
//! @see: https://android.googlesource.com/platform/ndk/+/ndk-release-r16/sources/crt/crtbrand.S#39
class LIEF_API AndroidIdent : public Note {
  public:
  static constexpr size_t sdk_version_size        = sizeof(uint32_t);
  static constexpr size_t ndk_version_size        = 64 * sizeof(char);
  static constexpr size_t ndk_build_number_size   = 64 * sizeof(char);

  public:
  std::unique_ptr<Note> clone() const override {
    return std::unique_ptr<AndroidIdent>(new AndroidIdent(*this));
  }

  //! Target SDK version (or 0 if it can't be resolved)
  uint32_t sdk_version() const;

  //! NDK version used (or an empty string if it can't be parsed)
  std::string ndk_version() const;

  //! NDK build number (or an empty string if it can't be parsed)
  std::string ndk_build_number() const;

  void sdk_version(uint32_t version);
  void ndk_version(const std::string& ndk_version);
  void ndk_build_number(const std::string& ndk_build_number);

  void dump(std::ostream& os) const override;

  void accept(Visitor& visitor) const override;

  static bool classof(const Note* note) {
    return note->type() == Note::TYPE::ANDROID_IDENT;
  }

  ~AndroidIdent() override = default;

  static constexpr size_t description_size() {
    return sdk_version_size + ndk_version_size + ndk_build_number_size;
  }

  LIEF_API friend
  std::ostream& operator<<(std::ostream& os, const AndroidIdent& note) {
    note.dump(os);
    return os;
  }
  protected:
  using Note::Note;
};


} // namepsace ELF
} // namespace LIEF

#endif

```

`KDemu/include/LIEF/LIEF/ELF/NoteDetails/Core.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_NOTE_DETAILS_CORE_H
#define LIEF_ELF_NOTE_DETAILS_CORE_H

#include "LIEF/ELF/NoteDetails/core/CorePrPsInfo.hpp"
#include "LIEF/ELF/NoteDetails/core/CorePrStatus.hpp"
#include "LIEF/ELF/NoteDetails/core/CoreAuxv.hpp"
#include "LIEF/ELF/NoteDetails/core/CoreSigInfo.hpp"
#include "LIEF/ELF/NoteDetails/core/CoreFile.hpp"

#endif

```

`KDemu/include/LIEF/LIEF/ELF/NoteDetails/NoteAbi.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_NOTE_ABI_H
#define LIEF_ELF_NOTE_ABI_H

#include <ostream>
#include <array>
#include <memory>

#include "LIEF/visibility.h"
#include "LIEF/ELF/Note.hpp"

namespace LIEF {
namespace ELF {

/// Class that wraps the `NT_GNU_ABI_TAG` note
class LIEF_API NoteAbi : public Note {
  public:
  /// ABI recognized by this note
  enum class ABI {
    LINUX = 0,
    GNU,
    SOLARIS2,
    FREEBSD,
    NETBSD,
    SYLLABLE,
    NACL
  };
  /// Version type: (Major, Minor, Patch)
  using version_t = std::array<uint32_t, 3>;

  static constexpr size_t abi_offset      = 0;
  static constexpr size_t abi_size        = sizeof(uint32_t);

  static constexpr size_t version_offset  = abi_size;
  static constexpr size_t version_size    = 3 * sizeof(uint32_t);

  public:
  using Note::Note;

  std::unique_ptr<Note> clone() const override {
    return std::unique_ptr<Note>(new NoteAbi(*this));
  }

  /// Return the version or an error if it can't be parsed
  result<version_t> version() const;

  /// Return the ABI or an error if it can't be parsed
  result<ABI> abi() const;

  void version(const version_t& version);
  void version(ABI abi);

  void dump(std::ostream& os) const override;

  void accept(Visitor& visitor) const override;

  static bool classof(const Note* note) {
    return note->type() == Note::TYPE::GNU_ABI_TAG;
  }

  //// Size of the description content
  static constexpr uint8_t description_size() {
    return /* abi */ sizeof(uint32_t) + /* version */ 3 * sizeof(uint32_t);
  }

  ~NoteAbi() override = default;

  LIEF_API friend
  std::ostream& operator<<(std::ostream& os, const NoteAbi& note) {
    note.dump(os);
    return os;
  }
};

LIEF_API const char* to_string(NoteAbi::ABI abi);

} // namepsace ELF
} // namespace LIEF

#endif

```

`KDemu/include/LIEF/LIEF/ELF/NoteDetails/NoteGnuProperty.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_NOTE_GNU_PROPERTY_H
#define LIEF_ELF_NOTE_GNU_PROPERTY_H

#include <vector>
#include <ostream>
#include <memory>

#include "LIEF/visibility.h"
#include "LIEF/ELF/Note.hpp"

namespace LIEF {
namespace ELF {

/// Class that wraps the `NT_GNU_PROPERTY_TYPE_0` note
class LIEF_API NoteGnuProperty : public Note {
  public:

  /// This class wraps the different properties that can be used in a
  /// `NT_GNU_PROPERTY_TYPE_0` note
  class Property {
    public:

    /// LIEF's mirror types of the original `GNU_PROPERTY_` values
    enum class TYPE {
      UNKNOWN = 0,
      GENERIC,              ///< Property that dont' have special implementation
      AARCH64_FEATURES,     ///< Mirror of `GNU_PROPERTY_AARCH64_FEATURE_1_AND`
      STACK_SIZE,           ///< Mirror of `GNU_PROPERTY_STACK_SIZE`
      NO_COPY_ON_PROTECTED, ///< Mirror of `GNU_PROPERTY_NO_COPY_ON_PROTECTED`
      X86_ISA,              ///< Mirror of `GNU_PROPERTY_X86_ISA_1_*` and `GNU_PROPERTY_X86_COMPAT_*`
      X86_FEATURE,          ///< Mirror of `GNU_PROPERTY_X86_FEATURE_*`
      NEEDED,
    };

    /// Return the LIEF's mirror type of the note.
    TYPE type() const {
      return type_;
    }

    virtual void dump(std::ostream& os) const;

    virtual ~Property() = default;

    LIEF_API friend
    std::ostream& operator<<(std::ostream& os, const Property& prop) {
      prop.dump(os);
      return os;
    }

    protected:
    Property() = delete;
    Property(TYPE type) :
      type_(type) {}
    TYPE type_ = TYPE::UNKNOWN;
  };

  using properties_t = std::vector<std::unique_ptr<NoteGnuProperty::Property>>;

  NoteGnuProperty(ARCH arch, Header::CLASS cls, std::string name,
                  uint32_t type, description_t description,
                  std::string secname) :
    Note(std::move(name), TYPE::GNU_PROPERTY_TYPE_0, type, std::move(description),
         std::move(secname)),
    arch_(arch), class_(cls)
  {}

  std::unique_ptr<Note> clone() const override {
    return std::unique_ptr<Note>(new NoteGnuProperty(*this));
  }

  /// Find the property with the given type or return a `nullptr`
  std::unique_ptr<NoteGnuProperty::Property> find(Property::TYPE type) const;

  /// Return the properties as a list of Property
  properties_t properties() const;

  void dump(std::ostream& os) const override;

  void accept(Visitor& visitor) const override;

  static bool classof(const Note* note) {
    return note->type() == Note::TYPE::GNU_PROPERTY_TYPE_0;
  }

  ~NoteGnuProperty() override = default;

  LIEF_API friend
  std::ostream& operator<<(std::ostream& os, const NoteGnuProperty& note) {
    note.dump(os);
    return os;
  }

  protected:
  ARCH arch_ = ARCH::NONE;
  Header::CLASS class_ = Header::CLASS::NONE;
};

LIEF_API const char* to_string(NoteGnuProperty::Property::TYPE type);

} // namepsace ELF
} // namespace LIEF

#endif

```

`KDemu/include/LIEF/LIEF/ELF/NoteDetails/Properties.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_NOTE_DETAILS_PROPERTIES_H
#define LIEF_ELF_NOTE_DETAILS_PROPERTIES_H

#include "LIEF/ELF/NoteDetails/properties/AArch64Feature.hpp"
#include "LIEF/ELF/NoteDetails/properties/Needed.hpp"
#include "LIEF/ELF/NoteDetails/properties/NoteNoCopyOnProtected.hpp"
#include "LIEF/ELF/NoteDetails/properties/X86ISA.hpp"
#include "LIEF/ELF/NoteDetails/properties/StackSize.hpp"
#include "LIEF/ELF/NoteDetails/properties/X86Feature.hpp"
#include "LIEF/ELF/NoteDetails/properties/Generic.hpp"

#endif

```

`KDemu/include/LIEF/LIEF/ELF/NoteDetails/QNXStack.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_QNX_STACK_H
#define LIEF_ELF_QNX_STACK_H

#include <ostream>
#include <memory>

#include "LIEF/visibility.h"
#include "LIEF/ELF/Note.hpp"

namespace LIEF {
namespace ELF {

/// Class representing the QNX `QNT_STACK` note
class LIEF_API QNXStack : public Note {
  public:
  std::unique_ptr<Note> clone() const override {
    return std::unique_ptr<QNXStack>(new QNXStack(*this));
  }

  /// Size of the stack
  uint32_t stack_size() const;

  /// Size of the stack pre-allocated (upfront)
  uint32_t stack_allocated() const;

  /// Whether the stack is executable
  bool is_executable() const;

  void stack_size(uint32_t value);
  void stack_allocated(uint32_t value);
  void set_is_executable(bool value);

  void dump(std::ostream& os) const override;

  void accept(Visitor& visitor) const override;

  static bool classof(const Note* note) {
    return note->type() == Note::TYPE::QNX_STACK;
  }

  ~QNXStack() override = default;

  LIEF_API friend
  std::ostream& operator<<(std::ostream& os, const QNXStack& note) {
    note.dump(os);
    return os;
  }
  protected:
  using Note::Note;
};


} // namepsace ELF
} // namespace LIEF

#endif

```

`KDemu/include/LIEF/LIEF/ELF/NoteDetails/core/CoreAuxv.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_CORE_AUXV_H
#define LIEF_ELF_CORE_AUXV_H

#include <vector>
#include <ostream>
#include <map>
#include <utility>

#include "LIEF/visibility.h"
#include "LIEF/ELF/enums.hpp"
#include "LIEF/ELF/Note.hpp"

namespace LIEF {
namespace ELF {

//! Class representing core auxv object
class LIEF_API CoreAuxv : public Note {
  public:
  enum class TYPE {
    END = 0,       /**< End of vector */
    IGNORE,        /**< Entry should be ignored */
    EXECFD,        /**< File descriptor of program */
    PHDR,          /**< Program headers for program */
    PHENT,         /**< Size of program header entry */
    PHNUM,         /**< Number of program headers */
    PAGESZ,        /**< System page size */
    BASE,          /**< Base address of interpreter */
    FLAGS,         /**< Flags */
    ENTRY,         /**< Entry point of program */
    NOTELF,        /**< Program is not ELF */
    UID,           /**< Real uid */
    EUID,          /**< Effective uid */
    GID,           /**< Real gid */
    EGID,          /**< Effective gid */
    TGT_PLATFORM,  /**< String identifying platform.  */
    HWCAP,         /**< Machine dependent hints about processor capabilities.  */
    CLKTCK,        /**< Frequency of times() */
    FPUCW,         /**< Used FPU control word.  */
    DCACHEBSIZE,   /**< Data cache block size.  */
    ICACHEBSIZE,   /**< Instruction cache block size.  */
    UCACHEBSIZE,   /**< Instruction cache block size.  */
    IGNOREPPC,     /**< Entry should be ignored.  */
    SECURE,        /**< Boolean, was exec setuid-like?.  */
    BASE_PLATFORM, /**< String identifying real platform  */
    RANDOM,        /**< Address of 16 random bytes  */
    HWCAP2,        /**< Extension of AT_HWCAP  */
    //ENTRY27,
    //ENTRY28,
    //ENTRY29,
    //ENTRY30,
    EXECFN = 31,   /**< Filename of executable  */
    SYSINFO,       /**< Filename of executable  */
    SYSINFO_EHDR,  /**<  Pointer to ELF header of system-supplied DSO. */
  };

  CoreAuxv(ARCH arch, Header::CLASS cls, std::string name,
           uint32_t type, description_t description) :
    Note(std::move(name), Note::TYPE::CORE_AUXV, type, std::move(description), ""),
    arch_(arch), class_(cls)
  {}

  std::unique_ptr<Note> clone() const override {
    return std::unique_ptr<Note>(new CoreAuxv(*this));
  }

  /// A map of CoreAuxv::TYPE and the value
  std::map<TYPE, uint64_t> values() const;

  /// Return the value associated with the provided TYPE or
  /// a lief_errors::not_found if the type is not present.
  result<uint64_t> get(TYPE type) const;

  result<uint64_t> operator[](TYPE type) const {
    return get(type);
  }

  bool set(TYPE type, uint64_t value);
  bool set(const std::map<TYPE, uint64_t>& values);

  void dump(std::ostream& os) const override;

  void accept(Visitor& visitor) const override;

  static bool classof(const Note* note) {
    return note->type() == Note::TYPE::CORE_AUXV;
  }

  ~CoreAuxv() override = default;

  LIEF_API friend
  std::ostream& operator<<(std::ostream& os, const CoreAuxv& note) {
    note.dump(os);
    return os;
  }

  protected:
  ARCH arch_ = ARCH::NONE;
  Header::CLASS class_ = Header::CLASS::NONE;
};

LIEF_API const char* to_string(CoreAuxv::TYPE type);

} // namepsace ELF
} // namespace LIEF

#endif

```

`KDemu/include/LIEF/LIEF/ELF/NoteDetails/core/CoreFile.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_CORE_FILE_H
#define LIEF_ELF_CORE_FILE_H

#include <vector>
#include <ostream>

#include "LIEF/visibility.h"

#include "LIEF/ELF/Note.hpp"

namespace LIEF {
namespace ELF {

/// Class representing a core `NT_FILE` which describes the mapped files
/// of the process
class LIEF_API CoreFile : public Note {
  public:
  //! Core file entry
  struct entry_t {
    uint64_t start = 0;    /// Start address of mapped file
    uint64_t end = 0;      ///< End address of mapped file
    uint64_t file_ofs = 0; ///< Offset (in core) of mapped file
    std::string path;      ///< Path of mapped file

    LIEF_API friend
    std::ostream& operator<<(std::ostream& os, const entry_t& entry);
  };

  using files_t        = std::vector<entry_t>;
  using iterator       = files_t::iterator;
  using const_iterator = files_t::const_iterator;

  public:
  CoreFile(ARCH arch, Header::CLASS cls, std::string name,
           uint32_t type, Note::description_t description);

  std::unique_ptr<Note> clone() const override {
    return std::unique_ptr<Note>(new CoreFile(*this));
  }

  //! Number of coredump file entries
  uint64_t count() const {
    return files_.size();
  }

  //! Coredump file entries
  const files_t& files() const {
    return files_;
  }

  iterator begin() {
    return files_.begin();
  }

  iterator end() {
    return files_.end();
  }

  const_iterator begin() const {
    return files_.begin();
  }

  const_iterator end() const {
    return files_.end();
  }

  void files(const files_t& file);

  void dump(std::ostream& os) const override;
  void accept(Visitor& visitor) const override;

  static bool classof(const Note* note) {
    return note->type() == Note::TYPE::CORE_FILE;
  }

  ~CoreFile() override = default;

  LIEF_API friend
  std::ostream& operator<<(std::ostream& os, const CoreFile& note) {
    note.dump(os);
    return os;
  }

  protected:
  template<class T>
  LIEF_LOCAL void read_files();

  template<class T>
  LIEF_LOCAL void write_files();

  files_t  files_;
  uint64_t page_size_ = 0;
  ARCH arch_ = ARCH::NONE;
  Header::CLASS class_ = Header::CLASS::NONE;
};

} // namepsace ELF
} // namespace LIEF

#endif

```

`KDemu/include/LIEF/LIEF/ELF/NoteDetails/core/CorePrPsInfo.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_CORE_PRPSINFO_H
#define LIEF_ELF_CORE_PRPSINFO_H

#include <vector>
#include <ostream>

#include "LIEF/visibility.h"
#include "LIEF/ELF/enums.hpp"
#include "LIEF/ELF/Note.hpp"

namespace LIEF {
namespace ELF {

/// Class representing the NT_PRPSINFO core note.
/// This kind of note represents general information about the process
class LIEF_API CorePrPsInfo : public Note {
  public:
  struct info_t {
    uint8_t state = 0;    /// Numeric process state
    char sname = ' ';     /// printable character representing state
    bool zombie = false;  /// Whether the process is a zombie
    uint8_t nice = 0;     /// Nice value
    uint64_t flag = 0;    /// Process flag
    uint32_t uid = 0;     /// Process user ID
    uint32_t gid = 0;     /// Process group ID
    uint32_t pid = 0;     /// Process ID
    uint32_t ppid = 0;    /// Process parent ID
    uint32_t pgrp = 0;    /// Process group
    uint32_t sid = 0;     /// Process session id
    std::string filename; /// Filename of the executable
    std::string args;     /// Initial part of the arguments

    /// Return the filename without the ending `\x00`
    std::string filename_stripped() const {
      return filename.c_str();
    }

    /// Return the args without the ending `\x00`
    std::string args_stripped() const {
      return args.c_str();
    }
  };
  CorePrPsInfo(ARCH arch, Header::CLASS cls, std::string name,
               uint32_t type, description_t description) :
    Note(std::move(name), TYPE::CORE_PRPSINFO, type, std::move(description), ""),
    arch_(arch), class_(cls)
  {}

  std::unique_ptr<Note> clone() const override {
    return std::unique_ptr<Note>(new CorePrPsInfo(*this));
  }

  /// Return a `elf_prpsinfo`-like structure or an error if it can't be parsed.
  result<info_t> info() const;
  void info(const info_t& info);

  void dump(std::ostream& os) const override;

  void accept(Visitor& visitor) const override;

  static bool classof(const Note* note) {
    return note->type() == Note::TYPE::CORE_PRPSINFO;
  }

  ~CorePrPsInfo() override = default;

  LIEF_API friend
  std::ostream& operator<<(std::ostream& os, const CorePrPsInfo& note) {
    note.dump(os);
    return os;
  }
  private:
  ARCH arch_ = ARCH::NONE;
  Header::CLASS class_ = Header::CLASS::NONE;
};

} // namepsace ELF
} // namespace LIEF

#endif

```

`KDemu/include/LIEF/LIEF/ELF/NoteDetails/core/CorePrStatus.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_CORE_PRSTATUS_H
#define LIEF_ELF_CORE_PRSTATUS_H

#include <vector>
#include <ostream>
#include <utility>

#include "LIEF/visibility.h"
#include "LIEF/ELF/enums.hpp"
#include "LIEF/ELF/Note.hpp"

namespace LIEF {
namespace ELF {

class Parser;
class Builder;
class Binary;

//! Class representing core PrPsInfo object
class LIEF_API CorePrStatus : public Note {
  public:
  struct siginfo_t {
    int32_t signo = 0;
    int32_t code = 0;
    int32_t err = 0;
  };

  struct timeval_t {
    uint64_t sec = 0;
    uint64_t usec = 0;
  };

  struct pr_status_t {
    siginfo_t info;

    uint16_t cursig = 0;
    uint16_t reserved = 0;

    uint64_t sigpend = 0;
    uint64_t sighold = 0;

    int32_t  pid = 0;
    int32_t  ppid = 0;
    int32_t  pgrp = 0;
    int32_t  sid = 0;

    timeval_t utime;
    timeval_t stime;
    timeval_t cutime;
    timeval_t cstime;
  };

  struct Registers {
    /// Register for the x86 architecture (ARCH::I386).
    enum class X86 {
      EBX = 0, ECX, EDX, ESI, EDI, EBP, EAX,
      DS, ES, FS, GS, ORIG_EAX, EIP, CS, EFLAGS, ESP, SS,
      _COUNT
    };

    /// Register for the x86-64 architecture (ARCH::X86_64).
    enum class X86_64 {
      R15 = 0, R14, R13, R12, RBP, RBX, R11, R10,
      R9, R8, RAX, RCX, RDX, RSI, RDI, ORIG_RAX,
      RIP, CS, EFLAGS, RSP, SS,
      _COUNT
    };

    /// Register for the ARM architecture (ARCH::ARM).
    enum class ARM {
      R0 = 0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, R12, R13, R14, R15,
      CPSR,
      _COUNT
    };

    /// Register for the AARCH64 architecture (ARCH::AARCH64).
    enum class AARCH64 {
      X0 = 0, X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11, X12, X13, X14, X15,
      X16, X17, X18, X19, X20, X21, X22, X23, X24, X25, X26, X27, X28, X29, X30,
      X31, PC, PSTATE,
      _COUNT
    };
  };

  public:
  CorePrStatus(ARCH arch, Header::CLASS cls, std::string name,
               uint32_t type, description_t description) :
    Note(std::move(name), TYPE::CORE_PRSTATUS, type, std::move(description), ""),
    arch_(arch), class_(cls)
  {}

  std::unique_ptr<Note> clone() const override {
    return std::unique_ptr<CorePrStatus>(new CorePrStatus(*this));
  }

  /// Return the pr_status_t structure
  pr_status_t status() const;
  void status(const pr_status_t& status);

  ARCH architecture() const {
    return arch_;
  }

  /// The program counter or an error if not found
  result<uint64_t> pc() const;

  /// The stack pointer or an error if not found
  result<uint64_t> sp() const;

  /// The value of the register that holds the return value according to
  /// the calling convention.
  result<uint64_t> return_value() const;

  /// Get the value for the given X86 register or return an error
  result<uint64_t> get(Registers::X86 reg) const;
  /// Get the value for the given X86_64 register or return an error
  result<uint64_t> get(Registers::X86_64 reg) const;
  /// Get the value for the given ARM register or return an error
  result<uint64_t> get(Registers::ARM reg) const;
  /// Get the value for the given AARCH64 register or return an error
  result<uint64_t> get(Registers::AARCH64 reg) const;

  ok_error_t set(Registers::X86 reg, uint64_t value);
  ok_error_t set(Registers::X86_64 reg, uint64_t value);
  ok_error_t set(Registers::ARM reg, uint64_t value);
  ok_error_t set(Registers::AARCH64 reg, uint64_t value);

  /// A list of the register values.
  /// This list is **guarantee** to be as long as the Registers::ARM::_COUNT or
  /// empty if it can't be resolved. Thus, one can access a specific register
  /// with:
  /// ```cpp
  /// if (architecture() == ARCH::AARCH64) {
  ///   auto reg_vals = register_values()
  ///   if (!reg_vals.empty()) {
  ///     auto x20 = reg_vals[static_cast<size_t>(Register::AARCH64::X20)]
  ///   }
  /// }
  /// ```
  std::vector<uint64_t> register_values() const;

  result<uint64_t> operator[](Registers::X86 reg) const {
    return get(reg);
  }

  result<uint64_t> operator[](Registers::X86_64 reg) const {
    return get(reg);
  }

  result<uint64_t> operator[](Registers::ARM reg) const {
    return get(reg);
  }

  result<uint64_t> operator[](Registers::AARCH64 reg) const {
    return get(reg);
  }

  void dump(std::ostream& os) const override;
  void accept(Visitor& visitor) const override;

  static bool classof(const Note* note) {
    return note->type() == Note::TYPE::CORE_PRSTATUS;
  }

  ~CorePrStatus() override = default;

  LIEF_API friend
  std::ostream& operator<<(std::ostream& os, const CorePrStatus& note) {
    note.dump(os);
    return os;
  }

  private:
  ARCH arch_ = ARCH::NONE;
  Header::CLASS class_ = Header::CLASS::NONE;
};

LIEF_API const char* to_string(CorePrStatus::Registers::X86 e);
LIEF_API const char* to_string(CorePrStatus::Registers::X86_64 e);
LIEF_API const char* to_string(CorePrStatus::Registers::ARM e);
LIEF_API const char* to_string(CorePrStatus::Registers::AARCH64 e);

} // namepsace ELF
} // namespace LIEF

#endif

```

`KDemu/include/LIEF/LIEF/ELF/NoteDetails/core/CoreSigInfo.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_CORE_SIGINFO_H
#define LIEF_ELF_CORE_SIGINFO_H

#include <vector>
#include <ostream>
#include <memory>

#include "LIEF/visibility.h"
#include "LIEF/ELF/Note.hpp"
#include "LIEF/errors.hpp"

namespace LIEF {
namespace ELF {

//! Class representing a core siginfo object
class LIEF_API CoreSigInfo : public Note {
  public:
  std::unique_ptr<Note> clone() const override {
    return std::unique_ptr<CoreSigInfo>(new CoreSigInfo(*this));
  }

  /// Signal number of an error if it can't be resolved
  result<int32_t> signo() const;
  /// Signal code of an error if it can't be resolved
  result<int32_t> sigcode() const;

  /// Signal error number of an error if it can't be resolved
  result<int32_t> sigerrno() const;

  void signo(uint32_t value);
  void sigcode(uint32_t value);
  void sigerrno(uint32_t value);

  void dump(std::ostream& os) const override;
  void accept(Visitor& visitor) const override;

  ~CoreSigInfo() override = default;

  static bool classof(const Note* note) {
    return note->type() == Note::TYPE::CORE_SIGINFO;
  }

  LIEF_API friend
  std::ostream& operator<<(std::ostream& os, const CoreSigInfo& note) {
    note.dump(os);
    return os;
  }
  protected:
  using Note::Note;
};
} // namepsace ELF
} // namespace LIEF

#endif

```

`KDemu/include/LIEF/LIEF/ELF/NoteDetails/properties/AArch64Feature.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_NOTE_DETAILS_PROPERTIES_AARCH64_FEATURE_H
#define LIEF_ELF_NOTE_DETAILS_PROPERTIES_AARCH64_FEATURE_H

#include "LIEF/ELF/NoteDetails/NoteGnuProperty.hpp"

namespace LIEF {
class BinaryStream;

namespace ELF {

/// This class represents the `GNU_PROPERTY_AARCH64_FEATURE_1_AND` property.
class AArch64Feature : public NoteGnuProperty::Property {
  public:
  enum class FEATURE {
    UNKNOWN = 0,
    BTI, ///< Support Branch Target Identification (BTI)
    PAC, ///< Support Pointer authentication (PAC)
  };

  /// Return the list of the supported features
  const std::vector<FEATURE>& features() const {
    return features_;
  }

  static bool classof(const NoteGnuProperty::Property* prop) {
    return prop->type() == NoteGnuProperty::Property::TYPE::AARCH64_FEATURES;
  }

  static std::unique_ptr<AArch64Feature> create(BinaryStream& stream);

  void dump(std::ostream &os) const override;

  ~AArch64Feature() override = default;

  protected:
  AArch64Feature() :
    NoteGnuProperty::Property(NoteGnuProperty::Property::TYPE::AARCH64_FEATURES)
  {}

  AArch64Feature(std::vector<FEATURE> features) :
    NoteGnuProperty::Property(NoteGnuProperty::Property::TYPE::AARCH64_FEATURES),
    features_(std::move(features))
  {}

  std::vector<FEATURE> features_;
};


LIEF_API const char* to_string(AArch64Feature::FEATURE feature);
}
}


#endif

```

`KDemu/include/LIEF/LIEF/ELF/NoteDetails/properties/Generic.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_NOTE_DETAILS_PROPERTIES_GENERIC_H
#define LIEF_ELF_NOTE_DETAILS_PROPERTIES_GENERIC_H

#include "LIEF/ELF/NoteDetails/NoteGnuProperty.hpp"

namespace LIEF {
namespace ELF {

/// This class represents a property which doesn't have a concrete LIEF
/// implementation.
class Generic : public NoteGnuProperty::Property {
  public:

  /// The original raw type as an integer. This value might depends
  /// on the architecture and/or the file type.
  uint32_t type() const {
    return raw_type_;
  }

  static bool classof(const NoteGnuProperty::Property* prop) {
    return prop->type() == NoteGnuProperty::Property::TYPE::GENERIC;
  }

  static std::unique_ptr<Generic> create(uint32_t raw_type) {
    return std::unique_ptr<Generic>(new Generic(raw_type));
  }

  ~Generic() override = default;

  protected:
  Generic(uint32_t raw_type) :
    NoteGnuProperty::Property(NoteGnuProperty::Property::TYPE::GENERIC),
    raw_type_(raw_type)
  {}
  uint32_t raw_type_ = 0;
};
}
}
#endif

```

`KDemu/include/LIEF/LIEF/ELF/NoteDetails/properties/Needed.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_NOTE_DETAILS_PROPERTIES_NEEDED_H
#define LIEF_ELF_NOTE_DETAILS_PROPERTIES_NEEDED_H

#include "LIEF/ELF/NoteDetails/NoteGnuProperty.hpp"

namespace LIEF {
namespace ELF {

class Needed : public NoteGnuProperty::Property {
  public:
  enum class NEED {
    UNKNOWN = 0,
    INDIRECT_EXTERN_ACCESS,
  };
  static bool classof(const NoteGnuProperty::Property* prop) {
    return prop->type() == NoteGnuProperty::Property::TYPE::NEEDED;
  }

  ~Needed() override = default;
};
}
}

#endif

```

`KDemu/include/LIEF/LIEF/ELF/NoteDetails/properties/NoteNoCopyOnProtected.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_NOTE_DETAILS_PROPERTIES_NO_COP_H
#define LIEF_ELF_NOTE_DETAILS_PROPERTIES_NO_COP_H

#include "LIEF/ELF/NoteDetails/NoteGnuProperty.hpp"

namespace LIEF {
namespace ELF {

/// This class provides an interface over the `GNU_PROPERTY_NO_COPY_ON_PROTECTED`
/// property. This property indicates that the linker shouldn't copy relocations
/// against protected symbols.
class NoteNoCopyOnProtected : public NoteGnuProperty::Property {
  public:
  static bool classof(const NoteGnuProperty::Property* prop) {
    return prop->type() == NoteGnuProperty::Property::TYPE::NO_COPY_ON_PROTECTED;
  }

  static std::unique_ptr<NoteNoCopyOnProtected> create() {
    return std::unique_ptr<NoteNoCopyOnProtected>(new NoteNoCopyOnProtected());
  }

  ~NoteNoCopyOnProtected() override = default;

  protected:
  NoteNoCopyOnProtected() :
    NoteGnuProperty::Property(NoteGnuProperty::Property::TYPE::NO_COPY_ON_PROTECTED)
  {}
};
}
}

#endif

```

`KDemu/include/LIEF/LIEF/ELF/NoteDetails/properties/StackSize.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_NOTE_DETAILS_PROPERTIES_STACK_SIZE_H
#define LIEF_ELF_NOTE_DETAILS_PROPERTIES_STACK_SIZE_H

#include "LIEF/ELF/NoteDetails/NoteGnuProperty.hpp"

namespace LIEF {
namespace ELF {
/// This class provides an interface over the `GNU_PROPERTY_STACK_SIZE` property
///
/// This property can be used by the loader to raise the stack limit.
class StackSize : public NoteGnuProperty::Property {
  public:
  static bool classof(const NoteGnuProperty::Property* prop) {
    return prop->type() == NoteGnuProperty::Property::TYPE::STACK_SIZE;
  }

  static std::unique_ptr<StackSize> create(uint64_t stack_size) {
    return std::unique_ptr<StackSize>(new StackSize(stack_size));
  }

  /// The indicated stack size
  uint64_t stack_size() const {
    return stack_size_;
  }

  void dump(std::ostream &os) const override;

  ~StackSize() override = default;

  protected:
  StackSize(uint64_t stack_size) :
    NoteGnuProperty::Property(NoteGnuProperty::Property::TYPE::STACK_SIZE),
    stack_size_(stack_size)
  {}
  uint64_t stack_size_ = 0;
};
}
}

#endif

```

`KDemu/include/LIEF/LIEF/ELF/NoteDetails/properties/X86Feature.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_NOTE_DETAILS_PROPERTIES_X86FEATURES_H
#define LIEF_ELF_NOTE_DETAILS_PROPERTIES_X86FEATURES_H
#include <vector>
#include <utility>

#include "LIEF/ELF/NoteDetails/NoteGnuProperty.hpp"

namespace LIEF {
namespace ELF {

/// This class interfaces the different ``GNU_PROPERTY_X86_FEATURE_*``
/// properties which includes:
/// - ``GNU_PROPERTY_X86_FEATURE_1_AND``
/// - ``GNU_PROPERTY_X86_FEATURE_2_USED``
/// - ``GNU_PROPERTY_X86_FEATURE_2_NEEDED``
class X86Features : public NoteGnuProperty::Property {
  public:

  /// Flag according to the ``_AND``, ``_USED`` or ``_NEEDED`` suffixes
  enum class FLAG {
    NONE = 0, ///< For the original ``GNU_PROPERTY_X86_FEATURE_1_AND`` property
    USED,     ///< For the original ``GNU_PROPERTY_X86_FEATURE_2_USED`` property
    NEEDED,   ///< For the original ``GNU_PROPERTY_X86_FEATURE_2_NEEDED`` property
  };

  /// Features provided by these different properties
  enum class FEATURE {
    UNKNOWN = 0,

    IBT,
    SHSTK,
    LAM_U48,
    LAM_U57,
    X86,
    X87,
    MMX,
    XMM,
    YMM,
    ZMM,
    FXSR,
    XSAVE,
    XSAVEOPT,
    XSAVEC,
    TMM,
    MASK,
  };

  /// List of the features as a pair of FLAG, FEATURE.
  ///
  /// For instance, if the raw property is `GNU_PROPERTY_X86_FEATURE_2_USED`
  /// with a bitmask set to ``GNU_PROPERTY_X86_FEATURE_2_XSAVE``, it generates
  /// the pair: FLAG::USED, FEATURE::XSAVE
  using features_t = std::vector<std::pair<FLAG, FEATURE>>;

  static bool classof(const NoteGnuProperty::Property* prop) {
    return prop->type() == NoteGnuProperty::Property::TYPE::X86_FEATURE;
  }

  static std::unique_ptr<X86Features> create(uint32_t type, BinaryStream& stream);

  /// List of the features
  const features_t& features() const {
    return features_;
  }

  void dump(std::ostream &os) const override;

  ~X86Features() override = default;

  protected:
  inline static std::unique_ptr<X86Features> create_feat1(FLAG flag, BinaryStream& stream);
  inline static std::unique_ptr<X86Features> create_feat2(FLAG flag, BinaryStream& stream);
  X86Features(features_t values) :
    NoteGnuProperty::Property(NoteGnuProperty::Property::TYPE::X86_FEATURE),
    features_(std::move(values))
  {}

  features_t features_;
};

LIEF_API const char* to_string(X86Features::FLAG flag);
LIEF_API const char* to_string(X86Features::FEATURE feat);

}
}

#endif

```

`KDemu/include/LIEF/LIEF/ELF/NoteDetails/properties/X86ISA.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_NOTE_DETAILS_PROPERTIES_X86ISA_H
#define LIEF_ELF_NOTE_DETAILS_PROPERTIES_X86ISA_H
#include <vector>
#include <utility>

#include "LIEF/ELF/NoteDetails/NoteGnuProperty.hpp"

namespace LIEF {
namespace ELF {

/// This class interfaces the different ``GNU_PROPERTY_X86_ISA_*``
/// properties which includes:
/// - ``GNU_PROPERTY_X86_ISA_1_USED``
/// - ``GNU_PROPERTY_X86_ISA_1_NEEDED``
/// - ``GNU_PROPERTY_X86_COMPAT_ISA_1_USED``
/// - ``GNU_PROPERTY_X86_COMPAT_ISA_1_NEEDED``
/// - ``GNU_PROPERTY_X86_COMPAT_2_ISA_1_USED``
/// - ``GNU_PROPERTY_X86_COMPAT_2_ISA_1_NEEDED``
class X86ISA : public NoteGnuProperty::Property {
  public:
  enum class FLAG {
    NONE = 0,
    USED,
    NEEDED,
  };
  enum class ISA {
    UNKNOWN = 0,
    BASELINE,
    V2,
    V3,
    V4,

    CMOV,
    FMA,
    I486,
    I586,
    I686,
    SSE,
    SSE2,
    SSE3,
    SSSE3,
    SSE4_1,
    SSE4_2,
    AVX,
    AVX2,
    AVX512F,
    AVX512CD,
    AVX512ER,
    AVX512PF,
    AVX512VL,
    AVX512DQ,
    AVX512BW,
    AVX512_4FMAPS,
    AVX512_4VNNIW,
    AVX512_BITALG,
    AVX512_IFMA,
    AVX512_VBMI,
    AVX512_VBMI2,
    AVX512_VNNI,
    AVX512_BF16,
  };
  using values_t = std::vector<std::pair<FLAG, ISA>>;

  static bool classof(const NoteGnuProperty::Property* prop) {
    return prop->type() == NoteGnuProperty::Property::TYPE::X86_ISA;
  }

  static std::unique_ptr<X86ISA> create(uint32_t type, BinaryStream& stream);

  /// List of the ISA values in this property
  const values_t& values() const {
    return values_;
  }

  ~X86ISA() override = default;

  void dump(std::ostream &os) const override;

  protected:
  inline static std::unique_ptr<X86ISA>
    create_isa_1(FLAG flag, BinaryStream& stream);
  inline static std::unique_ptr<X86ISA>
    create_compat_isa_1(FLAG flag, BinaryStream& stream, bool is_compat2);
  X86ISA(values_t values) :
    NoteGnuProperty::Property(NoteGnuProperty::Property::TYPE::X86_ISA),
    values_(std::move(values))
  {}

  values_t values_;
};

LIEF_API const char* to_string(X86ISA::FLAG flag);
LIEF_API const char* to_string(X86ISA::ISA isa);

}
}

#endif

```

`KDemu/include/LIEF/LIEF/ELF/Parser.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_PARSER_H
#define LIEF_ELF_PARSER_H
#include <unordered_map>

#include "LIEF/visibility.h"
#include "LIEF/utils.hpp"

#include "LIEF/Abstract/Parser.hpp"
#include "LIEF/errors.hpp"
#include "LIEF/ELF/enums.hpp"

#include "LIEF/ELF/ParserConfig.hpp"

namespace LIEF {
class BinaryStream;

namespace OAT {
class Parser;
}
namespace ELF {

class Section;
class Binary;
class Segment;
class Symbol;
class Note;
class Relocation;

//! Class which parses and transforms an ELF file into a ELF::Binary object
class LIEF_API Parser : public LIEF::Parser {
  friend class OAT::Parser;
  public:
  static constexpr uint32_t NB_MAX_SYMBOLS         = 1000000;
  static constexpr uint32_t DELTA_NB_SYMBOLS       = 3000;
  static constexpr uint32_t NB_MAX_BUCKETS         = NB_MAX_SYMBOLS;
  static constexpr uint32_t NB_MAX_CHAINS          = 1000000;
  static constexpr uint32_t NB_MAX_SEGMENTS        = 10000;
  static constexpr uint32_t NB_MAX_RELOCATIONS     = 3000000;
  static constexpr uint32_t NB_MAX_DYNAMIC_ENTRIES = 1000;
  static constexpr uint32_t NB_MAX_MASKWORD        = 512;
  static constexpr uint32_t MAX_SEGMENT_SIZE       = 3_GB;

  enum ELF_TYPE {
    ELF_UNKNOWN,
    ELF32, ELF64
  };

  //! Parse an ELF file and return a LIEF::ELF::Binary object
  //!
  //! For weird binaries (e.g. sectionless) you can choose which method to use for counting dynamic symbols
  //!
  //! @param[in] file Path to the ELF binary
  //! @param[in] conf Optional configuration for the parser
  //!
  //! @return LIEF::ELF::Binary as a `unique_ptr`
  static std::unique_ptr<Binary> parse(const std::string& file,
                                       const ParserConfig& conf = ParserConfig::all());

  //! Parse the given raw data as an ELF binary and return a LIEF::ELF::Binary object
  //!
  //! For weird binaries (e.g. sectionless) you can choose which method use to count dynamic symbols
  //!
  //! @param[in] data Raw ELF as a std::vector of uint8_t
  //! @param[in] conf Optional configuration for the parser
  //!
  //! @return LIEF::ELF::Binary
  static std::unique_ptr<Binary> parse(const std::vector<uint8_t>& data,
                                       const ParserConfig& conf = ParserConfig::all());

  //! Parse the ELF binary from the given stream and return a LIEF::ELF::Binary object
  //!
  //! For weird binaries (e.g. sectionless) you can choose which method use to count dynamic symbols
  //!
  //! @param[in] stream  The stream which wraps the ELF binary
  //! @param[in] conf    Optional configuration for the parser
  //!
  //! @return LIEF::ELF::Binary
  static std::unique_ptr<Binary> parse(std::unique_ptr<BinaryStream> stream,
                                       const ParserConfig& conf = ParserConfig::all());

  Parser& operator=(const Parser&) = delete;
  Parser(const Parser&)            = delete;

  protected:
  Parser();
  Parser(std::unique_ptr<BinaryStream> stream, ParserConfig config);
  Parser(const std::string& file, ParserConfig config);
  Parser(const std::vector<uint8_t>& data, ParserConfig config);

  ~Parser() override;

  ok_error_t init();

  bool should_swap() const;

  // map, dynamic_symbol.version <----> symbol_version
  // symbol_version comes from symbol_version table
  void link_symbol_version();

  ok_error_t link_symbol_section(Symbol& sym);

  template<typename ELF_T>
  ok_error_t parse_binary();

  template<typename ELF_T>
  ok_error_t parse_header();

  template<typename ELF_T>
  ok_error_t parse_sections();

  template<typename ELF_T>
  ok_error_t parse_segments();

  uint64_t get_dynamic_string_table() const;

  result<uint64_t> get_dynamic_string_table_from_segments() const;

  uint64_t get_dynamic_string_table_from_sections() const;

  //! Return the number of dynamic symbols using the given method
  template<typename ELF_T>
  result<uint32_t> get_numberof_dynamic_symbols(ParserConfig::DYNSYM_COUNT mtd) const;

  //! Count based on hash table (reliable)
  template<typename ELF_T>
  result<uint32_t> nb_dynsym_hash() const;

  //! Count based on SYSV hash table
  template<typename ELF_T>
  result<uint32_t> nb_dynsym_sysv_hash() const;

  //! Count based on GNU hash table
  template<typename ELF_T>
  result<uint32_t> nb_dynsym_gnu_hash() const;

  //! Count based on sections (not very reliable)
  template<typename ELF_T>
  result<uint32_t> nb_dynsym_section() const;

  //! Count based on PLT/GOT relocations (very reliable but not accurate)
  template<typename ELF_T>
  result<uint32_t> nb_dynsym_relocations() const;

  template<typename ELF_T>
  ok_error_t parse_dynamic_entries(uint64_t offset, uint64_t size);

  template<typename ELF_T>
  ok_error_t parse_dynamic_symbols(uint64_t offset);

  //! Parse symtab Symbol
  //!
  //! Parser find Symbols offset by using the file offset attribute of the
  //! ELF_SECTION_TYPES::SHT_SYMTAB Section.
  //!
  //! The number of symbols is taken from the `information` attribute in the section header.
  //!
  //! The section containing symbols name is found with the `link` attribute.
  template<typename ELF_T>
  ok_error_t parse_symtab_symbols(uint64_t offset, uint32_t nb_symbols,
                                  const Section& string_section);

  //! Parse Dynamic relocations
  //!
  //! It uses DT_REL/DT_RELA dynamic entries to parse it
  template<typename ELF_T, typename REL_T>
  ok_error_t parse_dynamic_relocations(uint64_t relocations_offset, uint64_t size);

  //! Parse `.plt.got`/`got` relocations
  //!
  //! For:
  //! * ELF32 it uses **DT_JMPREL** and **DT_PLTRELSZ**
  //! * ELF64 it uses **DT_PLTREL** and **DT_PLTRELSZ**
  template<typename ELF_T, typename REL_T>
  ok_error_t parse_pltgot_relocations(uint64_t offset, uint64_t size);


  //! Parse *relative* relocations
  template<typename ELF_T>
  ok_error_t parse_relative_relocations(uint64_t offset, uint64_t size);

  //! Parse Android packed relocations
  template<typename ELF_T>
  ok_error_t parse_packed_relocations(uint64_t offset, uint64_t size);

  template<typename ELF_T>
  ok_error_t process_dynamic_table();

  //! Parse relocations using LIEF::ELF::Section.
  //! Section relocations are usually found in object files
  template<typename ELF_T, typename REL_T>
  ok_error_t parse_section_relocations(const Section& section);

  //! Parse SymbolVersionRequirement
  //!
  //! We use the virtual address stored in the
  //! DynamicEntry::TAG::VERNEED entry to get the offset.
  //! and DynamicEntry::TAG::VERNEEDNUM to get the number of entries
  template<typename ELF_T>
  ok_error_t parse_symbol_version_requirement(uint64_t offset, uint32_t nb_entries);


  //! Parse SymbolVersionDefinition.
  //!
  //! We use the virtual address stored in
  //! the DynamicEntry::TAG::VERDEF DT_VERDEF entry to get the offset.
  //! DynamicEntry::TAG::VERDEFNUM gives the number of entries
  template<typename ELF_T>
  ok_error_t parse_symbol_version_definition(uint64_t offset, uint32_t nb_entries);


  //! Parse @link SymbolVersion Symbol version @endlink.
  //!
  //! We use the virtual address stored in the
  //! DynamicEntry::TAG::VERSYM entry to parse it.
  //!
  //! @see http://dev.gentoo.org/~solar/elf/symbol-versioning
  ok_error_t parse_symbol_version(uint64_t symbol_version_offset);

  //! Parse Symbols's GNU hash
  //!
  //! @see https://blogs.oracle.com/ali/entry/gnu_hash_elf_sections
  template<typename ELF_T>
  ok_error_t parse_symbol_gnu_hash(uint64_t offset);

  //! Parse Note (.gnu.note)
  ok_error_t parse_notes(uint64_t offset, uint64_t size);

  std::unique_ptr<Note> get_note(uint32_t type, std::string name, std::vector<uint8_t> desc_bytes);

  //! Parse Symbols's SYSV hash
  ok_error_t parse_symbol_sysv_hash(uint64_t offset);

  ok_error_t parse_overlay();

  template<typename ELF_T, typename REL_T>
  uint32_t max_relocation_index(uint64_t relocations_offset, uint64_t size) const;

  //! Check if the given Section is wrapped by the given segment
  static bool check_section_in_segment(const Section& section, const Segment& segment);

  bool bind_symbol(Relocation& R);

  std::unique_ptr<BinaryStream> stream_;
  std::unique_ptr<Binary> binary_;
  ParserConfig config_;
  /*
   * parse_sections() may skip some sections so that
   * binary_->sections_ is not contiguous based on the index of the sections.
   *
   * On the other hand, we need these indexes to bind symbols that
   * reference sections. That's why we have this unordered_map.
   */
  std::unordered_map<size_t, Section*> sections_idx_;
};

} // namespace ELF
} // namespace LIEF
#endif

```

`KDemu/include/LIEF/LIEF/ELF/ParserConfig.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_PARSER_CONFIG_H
#define LIEF_ELF_PARSER_CONFIG_H
#include "LIEF/visibility.h"
#include "LIEF/ELF/enums.hpp"

namespace LIEF {
namespace ELF {

//! This structure is used to tweak the ELF Parser (ELF::Parser)
struct LIEF_API ParserConfig {
  /** Methods that can be used by the LIEF::ELF::Parser
      to count the number of dynamic symbols */
  enum class DYNSYM_COUNT  {
    AUTO        = 0, /**< Automatic detection */
    SECTION     = 1, /**< Count based on sections (not very reliable) */
    HASH        = 2, /**< Count based on hash table (reliable) */
    RELOCATIONS = 3, /**< Count based on PLT/GOT relocations (very reliable but not accurate) */
  };

  //! This returns a ParserConfig object configured to process all the ELF
  //! elements.
  static ParserConfig all() {
    static const ParserConfig DEFAULT;
    return DEFAULT;
  }

  bool parse_relocations     = true; ///< Whether relocations (including plt-like relocations) should be parsed.
  bool parse_dyn_symbols     = true; ///< Whether dynamic symbols (those from `.dynsym`) should be parsed
  bool parse_symtab_symbols  = true; ///< Whether debug symbols (those from `.symtab`) should be parsed
  bool parse_symbol_versions = true; ///< Whether versioning symbols should be parsed
  bool parse_notes           = true; ///< Whether ELF notes  information should be parsed
  bool parse_overlay         = true; ///< Whether the overlay data should be parsed

  /** The method used to count the number of dynamic symbols */
  DYNSYM_COUNT count_mtd = DYNSYM_COUNT::AUTO;
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/ELF/ProcessorFlags.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_PROCESSOR_FLAGS_H
#define LIEF_ELF_PROCESSOR_FLAGS_H
#include <cstdint>
#include "LIEF/visibility.h"

namespace LIEF {
namespace ELF {

static constexpr uint64_t PFLAGS_BIT = 43;
static constexpr uint64_t PFLAGS_MASK = (1LLU << PFLAGS_BIT) - 1;
static constexpr uint64_t PF_ARM_ID = 1;
static constexpr uint64_t PF_HEX_ID = 2;
static constexpr uint64_t PF_LOONGARCH_ID = 3;
static constexpr uint64_t PF_MIPS_ID = 4;

enum class PROCESSOR_FLAGS : uint64_t {
  ARM_EABI_UNKNOWN = 0x00000000 | (PF_ARM_ID << PFLAGS_BIT),
  ARM_SOFT_FLOAT   = 0x00000200 | (PF_ARM_ID << PFLAGS_BIT),
  ARM_VFP_FLOAT    = 0x00000400 | (PF_ARM_ID << PFLAGS_BIT),
  ARM_EABI_VER1    = 0x01000000 | (PF_ARM_ID << PFLAGS_BIT),
  ARM_EABI_VER2    = 0x02000000 | (PF_ARM_ID << PFLAGS_BIT),
  ARM_EABI_VER3    = 0x03000000 | (PF_ARM_ID << PFLAGS_BIT),
  ARM_EABI_VER4    = 0x04000000 | (PF_ARM_ID << PFLAGS_BIT),
  ARM_EABI_VER5    = 0x05000000 | (PF_ARM_ID << PFLAGS_BIT),

  HEXAGON_MACH_V2   = 0x00000001 | (PF_HEX_ID << PFLAGS_BIT),  // Hexagon V2
  HEXAGON_MACH_V3   = 0x00000002 | (PF_HEX_ID << PFLAGS_BIT),  // Hexagon V3
  HEXAGON_MACH_V4   = 0x00000003 | (PF_HEX_ID << PFLAGS_BIT),  // Hexagon V4
  HEXAGON_MACH_V5   = 0x00000004 | (PF_HEX_ID << PFLAGS_BIT),  // Hexagon V5

  HEXAGON_ISA_V2    = 0x00000010 | (PF_HEX_ID << PFLAGS_BIT),  // Hexagon V2 ISA
  HEXAGON_ISA_V3    = 0x00000020 | (PF_HEX_ID << PFLAGS_BIT),  // Hexagon V3 ISA
  HEXAGON_ISA_V4    = 0x00000030 | (PF_HEX_ID << PFLAGS_BIT),  // Hexagon V4 ISA
  HEXAGON_ISA_V5    = 0x00000040 | (PF_HEX_ID << PFLAGS_BIT),  // Hexagon V5 ISA

  LOONGARCH_ABI_SOFT_FLOAT    = 0x1 | (PF_LOONGARCH_ID << PFLAGS_BIT),
  LOONGARCH_ABI_SINGLE_FLOAT  = 0x2 | (PF_LOONGARCH_ID << PFLAGS_BIT),
  LOONGARCH_ABI_DOUBLE_FLOAT  = 0x3 | (PF_LOONGARCH_ID << PFLAGS_BIT),

  MIPS_NOREORDER     = 0x00000001 | (PF_MIPS_ID << PFLAGS_BIT), /* Don't reorder instructions */
  MIPS_PIC           = 0x00000002 | (PF_MIPS_ID << PFLAGS_BIT), /* Position independent code */
  MIPS_CPIC          = 0x00000004 | (PF_MIPS_ID << PFLAGS_BIT), /* Call object with Position independent code */
  MIPS_ABI2          = 0x00000020 | (PF_MIPS_ID << PFLAGS_BIT), /* File uses N32 ABI */
  MIPS_32BITMODE     = 0x00000100 | (PF_MIPS_ID << PFLAGS_BIT), /* Code compiled for a 64-bit machine */
  /* in 32-bit mode */
  MIPS_FP64          = 0x00000200 | (PF_MIPS_ID << PFLAGS_BIT), /* Code compiled for a 32-bit machine */
  /* but uses 64-bit FP registers */
  MIPS_NAN2008       = 0x00000400 | (PF_MIPS_ID << PFLAGS_BIT), /* Uses IEE 754-2008 NaN encoding */

  /* ABI flags */
  MIPS_ABI_O32       = 0x00001000 | (PF_MIPS_ID << PFLAGS_BIT), /* This file follows the first MIPS 32 bit ABI */
  MIPS_ABI_O64       = 0x00002000 | (PF_MIPS_ID << PFLAGS_BIT), /* O32 ABI extended for 64-bit architecture. */
  MIPS_ABI_EABI32    = 0x00003000 | (PF_MIPS_ID << PFLAGS_BIT), /* EABI in 32 bit mode. */
  MIPS_ABI_EABI64    = 0x00004000 | (PF_MIPS_ID << PFLAGS_BIT), /* EABI in 64 bit mode. */

  /* MIPS machine variant */
  MIPS_MACH_3900     = 0x00810000 | (PF_MIPS_ID << PFLAGS_BIT), /* Toshiba R3900 */
  MIPS_MACH_4010     = 0x00820000 | (PF_MIPS_ID << PFLAGS_BIT), /* LSI R4010 */
  MIPS_MACH_4100     = 0x00830000 | (PF_MIPS_ID << PFLAGS_BIT), /* NEC VR4100 */
  MIPS_MACH_4650     = 0x00850000 | (PF_MIPS_ID << PFLAGS_BIT), /* MIPS R4650 */
  MIPS_MACH_4120     = 0x00870000 | (PF_MIPS_ID << PFLAGS_BIT), /* NEC VR4120 */
  MIPS_MACH_4111     = 0x00880000 | (PF_MIPS_ID << PFLAGS_BIT), /* NEC VR4111/VR4181 */
  MIPS_MACH_SB1      = 0x008a0000 | (PF_MIPS_ID << PFLAGS_BIT), /* Broadcom SB-1 */
  MIPS_MACH_OCTEON   = 0x008b0000 | (PF_MIPS_ID << PFLAGS_BIT), /* Cavium Networks Octeon */
  MIPS_MACH_XLR      = 0x008c0000 | (PF_MIPS_ID << PFLAGS_BIT), /* RMI Xlr */
  MIPS_MACH_OCTEON2  = 0x008d0000 | (PF_MIPS_ID << PFLAGS_BIT), /* Cavium Networks Octeon2 */
  MIPS_MACH_OCTEON3  = 0x008e0000 | (PF_MIPS_ID << PFLAGS_BIT), /* Cavium Networks Octeon3 */
  MIPS_MACH_5400     = 0x00910000 | (PF_MIPS_ID << PFLAGS_BIT), /* NEC VR5400 */
  MIPS_MACH_5900     = 0x00920000 | (PF_MIPS_ID << PFLAGS_BIT), /* MIPS R5900 */
  MIPS_MACH_5500     = 0x00980000 | (PF_MIPS_ID << PFLAGS_BIT), /* NEC VR5500 */
  MIPS_MACH_9000     = 0x00990000 | (PF_MIPS_ID << PFLAGS_BIT), /* Unknown */
  MIPS_MACH_LS2E     = 0x00a00000 | (PF_MIPS_ID << PFLAGS_BIT), /* ST Microelectronics Loongson 2E */
  MIPS_MACH_LS2F     = 0x00a10000 | (PF_MIPS_ID << PFLAGS_BIT), /* ST Microelectronics Loongson 2F */
  MIPS_MACH_LS3A     = 0x00a20000 | (PF_MIPS_ID << PFLAGS_BIT), /* Loongson 3A */

  /* ARCH_ASE */
  MIPS_MICROMIPS     = 0x02000000 | (PF_MIPS_ID << PFLAGS_BIT), /* microMIPS */
  MIPS_ARCH_ASE_M16  = 0x04000000 | (PF_MIPS_ID << PFLAGS_BIT), /* Has Mips-16 ISA extensions */
  MIPS_ARCH_ASE_MDMX = 0x08000000 | (PF_MIPS_ID << PFLAGS_BIT), /* Has MDMX multimedia extensions */

  /* ARCH */
  MIPS_ARCH_1        = 0x00000000 | (PF_MIPS_ID << PFLAGS_BIT), /* MIPS1 instruction set */
  MIPS_ARCH_2        = 0x10000000 | (PF_MIPS_ID << PFLAGS_BIT), /* MIPS2 instruction set */
  MIPS_ARCH_3        = 0x20000000 | (PF_MIPS_ID << PFLAGS_BIT), /* MIPS3 instruction set */
  MIPS_ARCH_4        = 0x30000000 | (PF_MIPS_ID << PFLAGS_BIT), /* MIPS4 instruction set */
  MIPS_ARCH_5        = 0x40000000 | (PF_MIPS_ID << PFLAGS_BIT), /* MIPS5 instruction set */
  MIPS_ARCH_32       = 0x50000000 | (PF_MIPS_ID << PFLAGS_BIT), /* MIPS32 instruction set per linux not elf.h */
  MIPS_ARCH_64       = 0x60000000 | (PF_MIPS_ID << PFLAGS_BIT), /* MIPS64 instruction set per linux not elf.h */
  MIPS_ARCH_32R2     = 0x70000000 | (PF_MIPS_ID << PFLAGS_BIT), /* mips32r2, mips32r3, mips32r5 */
  MIPS_ARCH_64R2     = 0x80000000 | (PF_MIPS_ID << PFLAGS_BIT), /* mips64r2, mips64r3, mips64r5 */
  MIPS_ARCH_32R6     = 0x90000000 | (PF_MIPS_ID << PFLAGS_BIT), /* mips32r6 */
  MIPS_ARCH_64R6     = 0xa0000000 | (PF_MIPS_ID << PFLAGS_BIT), /* mips64r6 */
};

LIEF_API const char* to_string(PROCESSOR_FLAGS flag);


}
}
#endif

```

`KDemu/include/LIEF/LIEF/ELF/Relocation.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_RELOCATION_H
#define LIEF_ELF_RELOCATION_H

#include <string>
#include <ostream>

#include "LIEF/Object.hpp"
#include "LIEF/visibility.h"

#include "LIEF/Abstract/Relocation.hpp"

#include "LIEF/ELF/enums.hpp"
#include "LIEF/ELF/Header.hpp"

namespace LIEF {
namespace ELF {

class Parser;
class Binary;
class Builder;
class Symbol;
class Section;

/// Class that represents an ELF relocation.
class LIEF_API Relocation : public LIEF::Relocation {

  friend class Parser;
  friend class Binary;
  friend class Builder;

  public:

  /// The *purpose* of a relocation defines how this relocation is used by the
  /// loader.
  enum class PURPOSE {
    NONE = 0,
    PLTGOT = 1,  ///< The relocation is associated with the PLT/GOT resolution
    DYNAMIC = 2, ///< The relocation is used for regulard data/code relocation
    OBJECT = 3,  ///< The relocation is used in an object file
  };

  enum class ENCODING {
    UNKNOWN = 0,
    REL,   ///< The relocation is using the regular Elf_Rel structure
    RELA,  ///< The relocation is using the regular Elf_Rela structure
    RELR,  ///< The relocation is using the relative relocation format
    ANDROID_SLEB, ///< The relocation is using the packed Android-SLEB128 format
  };

  static constexpr uint64_t R_BIT = 27;
  static constexpr uint64_t R_MASK = (uint64_t(1) << R_BIT) - 1;

  static constexpr uint64_t R_X64     = uint64_t(1)  << R_BIT;
  static constexpr uint64_t R_AARCH64 = uint64_t(2)  << R_BIT;
  static constexpr uint64_t R_ARM     = uint64_t(3)  << R_BIT;
  static constexpr uint64_t R_HEXAGON = uint64_t(4)  << R_BIT;
  static constexpr uint64_t R_X86     = uint64_t(5)  << R_BIT;
  static constexpr uint64_t R_LARCH   = uint64_t(6)  << R_BIT;
  static constexpr uint64_t R_MIPS    = uint64_t(7)  << R_BIT;
  static constexpr uint64_t R_PPC     = uint64_t(8)  << R_BIT;
  static constexpr uint64_t R_PPC64   = uint64_t(9)  << R_BIT;
  static constexpr uint64_t R_SPARC   = uint64_t(10) << R_BIT;
  static constexpr uint64_t R_SYSZ    = uint64_t(11) << R_BIT;

  /// The different types of the relocation
  enum class TYPE : uint32_t {
    UNKNOWN = uint32_t(-1),

    #define ELF_RELOC(name, value) name = (value | R_X64),
      #include "LIEF/ELF/Relocations/x86_64.def"
    #undef ELF_RELOC

    #define ELF_RELOC(name, value) name = (value | R_AARCH64),
      #include "LIEF/ELF/Relocations/AArch64.def"
    #undef ELF_RELOC

    #define ELF_RELOC(name, value) name = (value | R_ARM),
      #include "LIEF/ELF/Relocations/ARM.def"
    #undef ELF_RELOC

    #define ELF_RELOC(name, value) name = (value | R_HEXAGON),
      #include "LIEF/ELF/Relocations/Hexagon.def"
    #undef ELF_RELOC

    #define ELF_RELOC(name, value) name = (value | R_X86),
      #include "LIEF/ELF/Relocations/i386.def"
    #undef ELF_RELOC

    #define ELF_RELOC(name, value) name = (value | R_LARCH),
      #include "LIEF/ELF/Relocations/LoongArch.def"
    #undef ELF_RELOC

    #define ELF_RELOC(name, value) name = (value | R_MIPS),
      #include "LIEF/ELF/Relocations/Mips.def"
    #undef ELF_RELOC

    #define ELF_RELOC(name, value) name = (value | R_PPC),
      #include "LIEF/ELF/Relocations/PowerPC.def"
    #undef ELF_RELOC

    #define ELF_RELOC(name, value) name = (value | R_PPC64),
      #include "LIEF/ELF/Relocations/PowerPC64.def"
    #undef ELF_RELOC

    #define ELF_RELOC(name, value) name = (value | R_SPARC),
      #include "LIEF/ELF/Relocations/Sparc.def"
    #undef ELF_RELOC

    #define ELF_RELOC(name, value) name = (value | R_SYSZ),
      #include "LIEF/ELF/Relocations/SystemZ.def"
    #undef ELF_RELOC
  };

  static TYPE type_from(uint32_t value, ARCH arch);

  static uint32_t to_value(TYPE type) {
    return static_cast<uint32_t>(type) & R_MASK;
  }

  Relocation(uint64_t address, TYPE type, ENCODING enc);

  Relocation() = default;
  Relocation(ARCH arch) {
    architecture_ = arch;
  }
  ~Relocation() override = default;

  Relocation& operator=(Relocation other);
  Relocation(const Relocation& other);
  void swap(Relocation& other);

  /// Additional value that can be involved in the relocation processing
  int64_t addend() const {
    return addend_;
  }

  /// Type of the relocation
  TYPE type() const {
    return type_;
  }

  /// Check if the relocation uses the explicit addend() field
  /// (this is usually the case for 64 bits binaries)
  bool is_rela() const {
    return encoding_ == ENCODING::RELA;
  }

  /// Check if the relocation uses the implicit addend
  /// (i.e. not present in the ELF structure)
  bool is_rel() const {
    return encoding_ == ENCODING::REL;
  }

  /// True if the relocation is using the relative encoding
  bool is_relatively_encoded() const {
    return encoding_ == ENCODING::RELR;
  }

  /// True if the relocation is using the Android packed relocation format
  bool is_android_packed() const {
    return encoding_ == ENCODING::ANDROID_SLEB;
  }

  /// Relocation info which contains, for instance, the symbol index
  uint32_t info() const {
    return info_;
  }

  /// (re)Compute the *raw* `r_info` attribute based on the given ELF class
  uint64_t r_info(Header::CLASS clazz) const {
    if (clazz == Header::CLASS::NONE) {
      return 0;
    }
    return clazz == Header::CLASS::ELF32 ?
           uint32_t(info()) << 8  | to_value(type()) :
           uint64_t(info()) << 32 | (to_value(type()) & 0xffffffffL);
  }

  /// Target architecture for this relocation
  ARCH architecture() const {
    return architecture_;
  }

  PURPOSE purpose() const {
    return purpose_;
  }

  /// The encoding of the relocation
  ENCODING encoding() const {
    return encoding_;
  }

  /// True if the semantic of the relocation is `<ARCH>_RELATIVE`
  bool is_relative() const {
    return type_ == TYPE::AARCH64_RELATIVE || type_ == TYPE::X86_64_RELATIVE ||
           type_ == TYPE::X86_RELATIVE || type_ == TYPE::ARM_RELATIVE ||
           type_ == TYPE::HEX_RELATIVE || type_ == TYPE::PPC64_RELATIVE ||
           type_ == TYPE::PPC_RELATIVE;
  }

  /// Return the size (in **bits**) of the value associated with this relocation
  /// Return -1 if the size can't be determined
  size_t size() const override;

  /// True if the current relocation is associated with a symbol
  bool has_symbol() const {
    return symbol_ != nullptr;
  }

  /// Symbol associated with the relocation (or a nullptr)
  Symbol* symbol() {
    return symbol_;
  }

  const Symbol* symbol() const {
    return symbol_;
  }

  /// True if the relocation has an associated section
  bool has_section() const {
    return section() != nullptr;
  }

  /// The section in which the relocation is applied (or a nullptr)
  Section* section() {
    return section_;
  }

  const Section* section() const {
    return section_;
  }

  /// The associated symbol table (or a nullptr)
  Section* symbol_table() {
    return symbol_table_;
  }

  const Section* symbol_table() const {
    return symbol_table_;
  }

  void addend(int64_t addend) {
    addend_ = addend;
  }

  void type(TYPE type) {
    type_ = type;
  }

  void purpose(PURPOSE purpose) {
    purpose_ = purpose;
  }

  void info(uint32_t v) {
    info_ = v;
  }

  void symbol(Symbol* symbol) {
    symbol_ = symbol;
  }

  void section(Section* section) {
    section_ = section;
  }

  void symbol_table(Section* section) {
    symbol_table_ = section;
  }

  void accept(Visitor& visitor) const override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const Relocation& entry);

  private:
  template<class T>
  LIEF_LOCAL Relocation(const T& header, PURPOSE purpose, ENCODING enc, ARCH arch);

  TYPE type_ = TYPE::UNKNOWN;
  int64_t addend_ = 0;
  ENCODING encoding_ = ENCODING::UNKNOWN;
  Symbol* symbol_ = nullptr;
  ARCH architecture_ = ARCH::NONE;
  PURPOSE purpose_ = PURPOSE::NONE;
  Section* section_ = nullptr;
  Section* symbol_table_ = nullptr;
  uint32_t info_ = 0;
};

LIEF_API const char* to_string(Relocation::TYPE type);

}
}
#endif

```

`KDemu/include/LIEF/LIEF/ELF/Relocations/AArch64.def`:

```def

#ifndef ELF_RELOC
#error "ELF_RELOC must be defined"
#endif

/* ABI release 1.0 */
ELF_RELOC(AARCH64_NONE,                             0)

ELF_RELOC(AARCH64_ABS64,                        0x101)
ELF_RELOC(AARCH64_ABS32,                        0x102)
ELF_RELOC(AARCH64_ABS16,                        0x103)
ELF_RELOC(AARCH64_PREL64,                       0x104)
ELF_RELOC(AARCH64_PREL32,                       0x105)
ELF_RELOC(AARCH64_PREL16,                       0x106)

ELF_RELOC(AARCH64_MOVW_UABS_G0,                 0x107)
ELF_RELOC(AARCH64_MOVW_UABS_G0_NC,              0x108)
ELF_RELOC(AARCH64_MOVW_UABS_G1,                 0x109)
ELF_RELOC(AARCH64_MOVW_UABS_G1_NC,              0x10a)
ELF_RELOC(AARCH64_MOVW_UABS_G2,                 0x10b)
ELF_RELOC(AARCH64_MOVW_UABS_G2_NC,              0x10c)
ELF_RELOC(AARCH64_MOVW_UABS_G3,                 0x10d)
ELF_RELOC(AARCH64_MOVW_SABS_G0,                 0x10e)
ELF_RELOC(AARCH64_MOVW_SABS_G1,                 0x10f)
ELF_RELOC(AARCH64_MOVW_SABS_G2,                 0x110)

ELF_RELOC(AARCH64_LD_PREL_LO19,                 0x111)
ELF_RELOC(AARCH64_ADR_PREL_LO21,                0x112)
ELF_RELOC(AARCH64_ADR_PREL_PG_HI21,             0x113)
ELF_RELOC(AARCH64_ADR_PREL_PG_HI21_NC,          0x114)
ELF_RELOC(AARCH64_ADD_ABS_LO12_NC,              0x115)
ELF_RELOC(AARCH64_LDST8_ABS_LO12_NC,            0x116)

ELF_RELOC(AARCH64_TSTBR14,                      0x117)
ELF_RELOC(AARCH64_CONDBR19,                     0x118)
ELF_RELOC(AARCH64_JUMP26,                       0x11a)
ELF_RELOC(AARCH64_CALL26,                       0x11b)

ELF_RELOC(AARCH64_LDST16_ABS_LO12_NC,           0x11c)
ELF_RELOC(AARCH64_LDST32_ABS_LO12_NC,           0x11d)
ELF_RELOC(AARCH64_LDST64_ABS_LO12_NC,           0x11e)

ELF_RELOC(AARCH64_MOVW_PREL_G0,                 0x11f)
ELF_RELOC(AARCH64_MOVW_PREL_G0_NC,              0x120)
ELF_RELOC(AARCH64_MOVW_PREL_G1,                 0x121)
ELF_RELOC(AARCH64_MOVW_PREL_G1_NC,              0x122)
ELF_RELOC(AARCH64_MOVW_PREL_G2,                 0x123)
ELF_RELOC(AARCH64_MOVW_PREL_G2_NC,              0x124)
ELF_RELOC(AARCH64_MOVW_PREL_G3,                 0x125)

ELF_RELOC(AARCH64_LDST128_ABS_LO12_NC,          0x12b)

ELF_RELOC(AARCH64_MOVW_GOTOFF_G0,               0x12c)
ELF_RELOC(AARCH64_MOVW_GOTOFF_G0_NC,            0x12d)
ELF_RELOC(AARCH64_MOVW_GOTOFF_G1,               0x12e)
ELF_RELOC(AARCH64_MOVW_GOTOFF_G1_NC,            0x12f)
ELF_RELOC(AARCH64_MOVW_GOTOFF_G2,               0x130)
ELF_RELOC(AARCH64_MOVW_GOTOFF_G2_NC,            0x131)
ELF_RELOC(AARCH64_MOVW_GOTOFF_G3,               0x132)

ELF_RELOC(AARCH64_GOTREL64,                     0x133)
ELF_RELOC(AARCH64_GOTREL32,                     0x134)

ELF_RELOC(AARCH64_GOT_LD_PREL19,                0x135)
ELF_RELOC(AARCH64_LD64_GOTOFF_LO15,             0x136)
ELF_RELOC(AARCH64_ADR_GOT_PAGE,                 0x137)
ELF_RELOC(AARCH64_LD64_GOT_LO12_NC,             0x138)
ELF_RELOC(AARCH64_LD64_GOTPAGE_LO15,            0x139)

ELF_RELOC(AARCH64_TLSGD_ADR_PREL21,             0x200)
ELF_RELOC(AARCH64_TLSGD_ADR_PAGE21,             0x201)
ELF_RELOC(AARCH64_TLSGD_ADD_LO12_NC,            0x202)
ELF_RELOC(AARCH64_TLSGD_MOVW_G1,                0x203)
ELF_RELOC(AARCH64_TLSGD_MOVW_G0_NC,             0x204)

ELF_RELOC(AARCH64_TLSLD_ADR_PREL21,             0x205)
ELF_RELOC(AARCH64_TLSLD_ADR_PAGE21,             0x206)
ELF_RELOC(AARCH64_TLSLD_ADD_LO12_NC,            0x207)
ELF_RELOC(AARCH64_TLSLD_MOVW_G1,                0x208)
ELF_RELOC(AARCH64_TLSLD_MOVW_G0_NC,             0x209)
ELF_RELOC(AARCH64_TLSLD_LD_PREL19,              0x20a)
ELF_RELOC(AARCH64_TLSLD_MOVW_DTPREL_G2,         0x20b)
ELF_RELOC(AARCH64_TLSLD_MOVW_DTPREL_G1,         0x20c)
ELF_RELOC(AARCH64_TLSLD_MOVW_DTPREL_G1_NC,      0x20d)
ELF_RELOC(AARCH64_TLSLD_MOVW_DTPREL_G0,         0x20e)
ELF_RELOC(AARCH64_TLSLD_MOVW_DTPREL_G0_NC,      0x20f)
ELF_RELOC(AARCH64_TLSLD_ADD_DTPREL_HI12,        0x210)
ELF_RELOC(AARCH64_TLSLD_ADD_DTPREL_LO12,        0x211)
ELF_RELOC(AARCH64_TLSLD_ADD_DTPREL_LO12_NC,     0x212)
ELF_RELOC(AARCH64_TLSLD_LDST8_DTPREL_LO12,      0x213)
ELF_RELOC(AARCH64_TLSLD_LDST8_DTPREL_LO12_NC,   0x214)
ELF_RELOC(AARCH64_TLSLD_LDST16_DTPREL_LO12,     0x215)
ELF_RELOC(AARCH64_TLSLD_LDST16_DTPREL_LO12_NC,  0x216)
ELF_RELOC(AARCH64_TLSLD_LDST32_DTPREL_LO12,     0x217)
ELF_RELOC(AARCH64_TLSLD_LDST32_DTPREL_LO12_NC,  0x218)
ELF_RELOC(AARCH64_TLSLD_LDST64_DTPREL_LO12,     0x219)
ELF_RELOC(AARCH64_TLSLD_LDST64_DTPREL_LO12_NC,  0x21a)

ELF_RELOC(AARCH64_TLSIE_MOVW_GOTTPREL_G1,       0x21b)
ELF_RELOC(AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC,    0x21c)
ELF_RELOC(AARCH64_TLSIE_ADR_GOTTPREL_PAGE21,    0x21d)
ELF_RELOC(AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC,  0x21e)
ELF_RELOC(AARCH64_TLSIE_LD_GOTTPREL_PREL19,     0x21f)

ELF_RELOC(AARCH64_TLSLE_MOVW_TPREL_G2,          0x220)
ELF_RELOC(AARCH64_TLSLE_MOVW_TPREL_G1,          0x221)
ELF_RELOC(AARCH64_TLSLE_MOVW_TPREL_G1_NC,       0x222)
ELF_RELOC(AARCH64_TLSLE_MOVW_TPREL_G0,          0x223)
ELF_RELOC(AARCH64_TLSLE_MOVW_TPREL_G0_NC,       0x224)
ELF_RELOC(AARCH64_TLSLE_ADD_TPREL_HI12,         0x225)
ELF_RELOC(AARCH64_TLSLE_ADD_TPREL_LO12,         0x226)
ELF_RELOC(AARCH64_TLSLE_ADD_TPREL_LO12_NC,      0x227)
ELF_RELOC(AARCH64_TLSLE_LDST8_TPREL_LO12,       0x228)
ELF_RELOC(AARCH64_TLSLE_LDST8_TPREL_LO12_NC,    0x229)
ELF_RELOC(AARCH64_TLSLE_LDST16_TPREL_LO12,      0x22a)
ELF_RELOC(AARCH64_TLSLE_LDST16_TPREL_LO12_NC,   0x22b)
ELF_RELOC(AARCH64_TLSLE_LDST32_TPREL_LO12,      0x22c)
ELF_RELOC(AARCH64_TLSLE_LDST32_TPREL_LO12_NC,   0x22d)
ELF_RELOC(AARCH64_TLSLE_LDST64_TPREL_LO12,      0x22e)
ELF_RELOC(AARCH64_TLSLE_LDST64_TPREL_LO12_NC,   0x22f)

ELF_RELOC(AARCH64_TLSDESC_LD_PREL19,            0x230)
ELF_RELOC(AARCH64_TLSDESC_ADR_PREL21,           0x231)
ELF_RELOC(AARCH64_TLSDESC_ADR_PAGE21,           0x232)
ELF_RELOC(AARCH64_TLSDESC_LD64_LO12_NC,         0x233)
ELF_RELOC(AARCH64_TLSDESC_ADD_LO12_NC,          0x234)
ELF_RELOC(AARCH64_TLSDESC_OFF_G1,               0x235)
ELF_RELOC(AARCH64_TLSDESC_OFF_G0_NC,            0x236)
ELF_RELOC(AARCH64_TLSDESC_LDR,                  0x237)
ELF_RELOC(AARCH64_TLSDESC_ADD,                  0x238)
ELF_RELOC(AARCH64_TLSDESC_CALL,                 0x239)

ELF_RELOC(AARCH64_TLSLE_LDST128_TPREL_LO12,     0x23a)
ELF_RELOC(AARCH64_TLSLE_LDST128_TPREL_LO12_NC,  0x23b)

ELF_RELOC(AARCH64_TLSLD_LDST128_DTPREL_LO12,    0x23c)
ELF_RELOC(AARCH64_TLSLD_LDST128_DTPREL_LO12_NC, 0x23d)

ELF_RELOC(AARCH64_COPY,                         0x400)
ELF_RELOC(AARCH64_GLOB_DAT,                     0x401)
ELF_RELOC(AARCH64_JUMP_SLOT,                    0x402)
ELF_RELOC(AARCH64_RELATIVE,                     0x403)
ELF_RELOC(AARCH64_TLS_DTPREL64,                 0x404)
ELF_RELOC(AARCH64_TLS_DTPMOD64,                 0x405)
ELF_RELOC(AARCH64_TLS_TPREL64,                  0x406)
ELF_RELOC(AARCH64_TLSDESC,                      0x407)
ELF_RELOC(AARCH64_IRELATIVE,                    0x408)

```

`KDemu/include/LIEF/LIEF/ELF/Relocations/ARM.def`:

```def

#ifndef ELF_RELOC
#error "ELF_RELOC must be defined"
#endif

/* Meets 2.09 ABI Specs. */
ELF_RELOC(ARM_NONE,                   0x00)
ELF_RELOC(ARM_PC24,                   0x01)
ELF_RELOC(ARM_ABS32,                  0x02)
ELF_RELOC(ARM_REL32,                  0x03)
ELF_RELOC(ARM_LDR_PC_G0,              0x04)
ELF_RELOC(ARM_ABS16,                  0x05)
ELF_RELOC(ARM_ABS12,                  0x06)
ELF_RELOC(ARM_THM_ABS5,               0x07)
ELF_RELOC(ARM_ABS8,                   0x08)
ELF_RELOC(ARM_SBREL32,                0x09)
ELF_RELOC(ARM_THM_CALL,               0x0a)
ELF_RELOC(ARM_THM_PC8,                0x0b)
ELF_RELOC(ARM_BREL_ADJ,               0x0c)
ELF_RELOC(ARM_TLS_DESC,               0x0d)
ELF_RELOC(ARM_THM_SWI8,               0x0e)
ELF_RELOC(ARM_XPC25,                  0x0f)
ELF_RELOC(ARM_THM_XPC22,              0x10)
ELF_RELOC(ARM_TLS_DTPMOD32,           0x11)
ELF_RELOC(ARM_TLS_DTPOFF32,           0x12)
ELF_RELOC(ARM_TLS_TPOFF32,            0x13)
ELF_RELOC(ARM_COPY,                   0x14)
ELF_RELOC(ARM_GLOB_DAT,               0x15)
ELF_RELOC(ARM_JUMP_SLOT,              0x16)
ELF_RELOC(ARM_RELATIVE,               0x17)
ELF_RELOC(ARM_GOTOFF32,               0x18)
ELF_RELOC(ARM_BASE_PREL,              0x19)
ELF_RELOC(ARM_GOT_BREL,               0x1a)
ELF_RELOC(ARM_PLT32,                  0x1b)
ELF_RELOC(ARM_CALL,                   0x1c)
ELF_RELOC(ARM_JUMP24,                 0x1d)
ELF_RELOC(ARM_THM_JUMP24,             0x1e)
ELF_RELOC(ARM_BASE_ABS,               0x1f)
ELF_RELOC(ARM_ALU_PCREL_7_0,          0x20)
ELF_RELOC(ARM_ALU_PCREL_15_8,         0x21)
ELF_RELOC(ARM_ALU_PCREL_23_15,        0x22)
ELF_RELOC(ARM_LDR_SBREL_11_0_NC,      0x23)
ELF_RELOC(ARM_ALU_SBREL_19_12_NC,     0x24)
ELF_RELOC(ARM_ALU_SBREL_27_20_CK,     0x25)
ELF_RELOC(ARM_TARGET1,                0x26)
ELF_RELOC(ARM_SBREL31,                0x27)
ELF_RELOC(ARM_V4BX,                   0x28)
ELF_RELOC(ARM_TARGET2,                0x29)
ELF_RELOC(ARM_PREL31,                 0x2a)
ELF_RELOC(ARM_MOVW_ABS_NC,            0x2b)
ELF_RELOC(ARM_MOVT_ABS,               0x2c)
ELF_RELOC(ARM_MOVW_PREL_NC,           0x2d)
ELF_RELOC(ARM_MOVT_PREL,              0x2e)
ELF_RELOC(ARM_THM_MOVW_ABS_NC,        0x2f)
ELF_RELOC(ARM_THM_MOVT_ABS,           0x30)
ELF_RELOC(ARM_THM_MOVW_PREL_NC,       0x31)
ELF_RELOC(ARM_THM_MOVT_PREL,          0x32)
ELF_RELOC(ARM_THM_JUMP19,             0x33)
ELF_RELOC(ARM_THM_JUMP6,              0x34)
ELF_RELOC(ARM_THM_ALU_PREL_11_0,      0x35)
ELF_RELOC(ARM_THM_PC12,               0x36)
ELF_RELOC(ARM_ABS32_NOI,              0x37)
ELF_RELOC(ARM_REL32_NOI,              0x38)
ELF_RELOC(ARM_ALU_PC_G0_NC,           0x39)
ELF_RELOC(ARM_ALU_PC_G0,              0x3a)
ELF_RELOC(ARM_ALU_PC_G1_NC,           0x3b)
ELF_RELOC(ARM_ALU_PC_G1,              0x3c)
ELF_RELOC(ARM_ALU_PC_G2,              0x3d)
ELF_RELOC(ARM_LDR_PC_G1,              0x3e)
ELF_RELOC(ARM_LDR_PC_G2,              0x3f)
ELF_RELOC(ARM_LDRS_PC_G0,             0x40)
ELF_RELOC(ARM_LDRS_PC_G1,             0x41)
ELF_RELOC(ARM_LDRS_PC_G2,             0x42)
ELF_RELOC(ARM_LDC_PC_G0,              0x43)
ELF_RELOC(ARM_LDC_PC_G1,              0x44)
ELF_RELOC(ARM_LDC_PC_G2,              0x45)
ELF_RELOC(ARM_ALU_SB_G0_NC,           0x46)
ELF_RELOC(ARM_ALU_SB_G0,              0x47)
ELF_RELOC(ARM_ALU_SB_G1_NC,           0x48)
ELF_RELOC(ARM_ALU_SB_G1,              0x49)
ELF_RELOC(ARM_ALU_SB_G2,              0x4a)
ELF_RELOC(ARM_LDR_SB_G0,              0x4b)
ELF_RELOC(ARM_LDR_SB_G1,              0x4c)
ELF_RELOC(ARM_LDR_SB_G2,              0x4d)
ELF_RELOC(ARM_LDRS_SB_G0,             0x4e)
ELF_RELOC(ARM_LDRS_SB_G1,             0x4f)
ELF_RELOC(ARM_LDRS_SB_G2,             0x50)
ELF_RELOC(ARM_LDC_SB_G0,              0x51)
ELF_RELOC(ARM_LDC_SB_G1,              0x52)
ELF_RELOC(ARM_LDC_SB_G2,              0x53)
ELF_RELOC(ARM_MOVW_BREL_NC,           0x54)
ELF_RELOC(ARM_MOVT_BREL,              0x55)
ELF_RELOC(ARM_MOVW_BREL,              0x56)
ELF_RELOC(ARM_THM_MOVW_BREL_NC,       0x57)
ELF_RELOC(ARM_THM_MOVT_BREL,          0x58)
ELF_RELOC(ARM_THM_MOVW_BREL,          0x59)
ELF_RELOC(ARM_TLS_GOTDESC,            0x5a)
ELF_RELOC(ARM_TLS_CALL,               0x5b)
ELF_RELOC(ARM_TLS_DESCSEQ,            0x5c)
ELF_RELOC(ARM_THM_TLS_CALL,           0x5d)
ELF_RELOC(ARM_PLT32_ABS,              0x5e)
ELF_RELOC(ARM_GOT_ABS,                0x5f)
ELF_RELOC(ARM_GOT_PREL,               0x60)
ELF_RELOC(ARM_GOT_BREL12,             0x61)
ELF_RELOC(ARM_GOTOFF12,               0x62)
ELF_RELOC(ARM_GOTRELAX,               0x63)
ELF_RELOC(ARM_GNU_VTENTRY,            0x64)
ELF_RELOC(ARM_GNU_VTINHERIT,          0x65)
ELF_RELOC(ARM_THM_JUMP11,             0x66)
ELF_RELOC(ARM_THM_JUMP8,              0x67)
ELF_RELOC(ARM_TLS_GD32,               0x68)
ELF_RELOC(ARM_TLS_LDM32,              0x69)
ELF_RELOC(ARM_TLS_LDO32,              0x6a)
ELF_RELOC(ARM_TLS_IE32,               0x6b)
ELF_RELOC(ARM_TLS_LE32,               0x6c)
ELF_RELOC(ARM_TLS_LDO12,              0x6d)
ELF_RELOC(ARM_TLS_LE12,               0x6e)
ELF_RELOC(ARM_TLS_IE12GP,             0x6f)
ELF_RELOC(ARM_PRIVATE_0,              0x70)
ELF_RELOC(ARM_PRIVATE_1,              0x71)
ELF_RELOC(ARM_PRIVATE_2,              0x72)
ELF_RELOC(ARM_PRIVATE_3,              0x73)
ELF_RELOC(ARM_PRIVATE_4,              0x74)
ELF_RELOC(ARM_PRIVATE_5,              0x75)
ELF_RELOC(ARM_PRIVATE_6,              0x76)
ELF_RELOC(ARM_PRIVATE_7,              0x77)
ELF_RELOC(ARM_PRIVATE_8,              0x78)
ELF_RELOC(ARM_PRIVATE_9,              0x79)
ELF_RELOC(ARM_PRIVATE_10,             0x7a)
ELF_RELOC(ARM_PRIVATE_11,             0x7b)
ELF_RELOC(ARM_PRIVATE_12,             0x7c)
ELF_RELOC(ARM_PRIVATE_13,             0x7d)
ELF_RELOC(ARM_PRIVATE_14,             0x7e)
ELF_RELOC(ARM_PRIVATE_15,             0x7f)
ELF_RELOC(ARM_ME_TOO,                 0x80)
ELF_RELOC(ARM_THM_TLS_DESCSEQ16,      0x81)
ELF_RELOC(ARM_THM_TLS_DESCSEQ32,      0x82)
ELF_RELOC(ARM_IRELATIVE,              0xa0)

ELF_RELOC(ARM_RXPC25,                 0xF9)
ELF_RELOC(ARM_RSBREL32,               0xFA)
ELF_RELOC(ARM_THM_RPC22,              0xFB)
ELF_RELOC(ARM_RREL32,                 0xFC)
ELF_RELOC(ARM_RPC24,                  0xFD)
ELF_RELOC(ARM_RBASE,                  0xFE)

```

`KDemu/include/LIEF/LIEF/ELF/Relocations/Hexagon.def`:

```def

#ifndef ELF_RELOC
#error "ELF_RELOC must be defined"
#endif

/* Release 5 ABI */
ELF_RELOC(HEX_NONE,                0)
ELF_RELOC(HEX_B22_PCREL,           1)
ELF_RELOC(HEX_B15_PCREL,           2)
ELF_RELOC(HEX_B7_PCREL,            3)
ELF_RELOC(HEX_LO16,                4)
ELF_RELOC(HEX_HI16,                5)
ELF_RELOC(HEX_32,                  6)
ELF_RELOC(HEX_16,                  7)
ELF_RELOC(HEX_8,                   8)
ELF_RELOC(HEX_GPREL16_0,           9)
ELF_RELOC(HEX_GPREL16_1,           10)
ELF_RELOC(HEX_GPREL16_2,           11)
ELF_RELOC(HEX_GPREL16_3,           12)
ELF_RELOC(HEX_HL16,                13)
ELF_RELOC(HEX_B13_PCREL,           14)
ELF_RELOC(HEX_B9_PCREL,            15)
ELF_RELOC(HEX_B32_PCREL_X,         16)
ELF_RELOC(HEX_32_6_X,              17)
ELF_RELOC(HEX_B22_PCREL_X,         18)
ELF_RELOC(HEX_B15_PCREL_X,         19)
ELF_RELOC(HEX_B13_PCREL_X,         20)
ELF_RELOC(HEX_B9_PCREL_X,          21)
ELF_RELOC(HEX_B7_PCREL_X,          22)
ELF_RELOC(HEX_16_X,                23)
ELF_RELOC(HEX_12_X,                24)
ELF_RELOC(HEX_11_X,                25)
ELF_RELOC(HEX_10_X,                26)
ELF_RELOC(HEX_9_X,                 27)
ELF_RELOC(HEX_8_X,                 28)
ELF_RELOC(HEX_7_X,                 29)
ELF_RELOC(HEX_6_X,                 30)
ELF_RELOC(HEX_32_PCREL,            31)
ELF_RELOC(HEX_COPY,                32)
ELF_RELOC(HEX_GLOB_DAT,            33)
ELF_RELOC(HEX_JMP_SLOT,            34)
ELF_RELOC(HEX_RELATIVE,            35)
ELF_RELOC(HEX_PLT_B22_PCREL,       36)
ELF_RELOC(HEX_GOTREL_LO16,         37)
ELF_RELOC(HEX_GOTREL_HI16,         38)
ELF_RELOC(HEX_GOTREL_32,           39)
ELF_RELOC(HEX_GOT_LO16,            40)
ELF_RELOC(HEX_GOT_HI16,            41)
ELF_RELOC(HEX_GOT_32,              42)
ELF_RELOC(HEX_GOT_16,              43)
ELF_RELOC(HEX_DTPMOD_32,           44)
ELF_RELOC(HEX_DTPREL_LO16,         45)
ELF_RELOC(HEX_DTPREL_HI16,         46)
ELF_RELOC(HEX_DTPREL_32,           47)
ELF_RELOC(HEX_DTPREL_16,           48)
ELF_RELOC(HEX_GD_PLT_B22_PCREL,    49)
ELF_RELOC(HEX_GD_GOT_LO16,         50)
ELF_RELOC(HEX_GD_GOT_HI16,         51)
ELF_RELOC(HEX_GD_GOT_32,           52)
ELF_RELOC(HEX_GD_GOT_16,           53)
ELF_RELOC(HEX_IE_LO16,             54)
ELF_RELOC(HEX_IE_HI16,             55)
ELF_RELOC(HEX_IE_32,               56)
ELF_RELOC(HEX_IE_GOT_LO16,         57)
ELF_RELOC(HEX_IE_GOT_HI16,         58)
ELF_RELOC(HEX_IE_GOT_32,           59)
ELF_RELOC(HEX_IE_GOT_16,           60)
ELF_RELOC(HEX_TPREL_LO16,          61)
ELF_RELOC(HEX_TPREL_HI16,          62)
ELF_RELOC(HEX_TPREL_32,            63)
ELF_RELOC(HEX_TPREL_16,            64)
ELF_RELOC(HEX_6_PCREL_X,           65)
ELF_RELOC(HEX_GOTREL_32_6_X,       66)
ELF_RELOC(HEX_GOTREL_16_X,         67)
ELF_RELOC(HEX_GOTREL_11_X,         68)
ELF_RELOC(HEX_GOT_32_6_X,          69)
ELF_RELOC(HEX_GOT_16_X,            70)
ELF_RELOC(HEX_GOT_11_X,            71)
ELF_RELOC(HEX_DTPREL_32_6_X,       72)
ELF_RELOC(HEX_DTPREL_16_X,         73)
ELF_RELOC(HEX_DTPREL_11_X,         74)
ELF_RELOC(HEX_GD_GOT_32_6_X,       75)
ELF_RELOC(HEX_GD_GOT_16_X,         76)
ELF_RELOC(HEX_GD_GOT_11_X,         77)
ELF_RELOC(HEX_IE_32_6_X,           78)
ELF_RELOC(HEX_IE_16_X,             79)
ELF_RELOC(HEX_IE_GOT_32_6_X,       80)
ELF_RELOC(HEX_IE_GOT_16_X,         81)
ELF_RELOC(HEX_IE_GOT_11_X,         82)
ELF_RELOC(HEX_TPREL_32_6_X,        83)
ELF_RELOC(HEX_TPREL_16_X,          84)
ELF_RELOC(HEX_TPREL_11_X,          85)
ELF_RELOC(HEX_LD_PLT_B22_PCREL,    86)
ELF_RELOC(HEX_LD_GOT_LO16,         87)
ELF_RELOC(HEX_LD_GOT_HI16,         88)
ELF_RELOC(HEX_LD_GOT_32,           89)
ELF_RELOC(HEX_LD_GOT_16,           90)
ELF_RELOC(HEX_LD_GOT_32_6_X,       91)
ELF_RELOC(HEX_LD_GOT_16_X,         92)
ELF_RELOC(HEX_LD_GOT_11_X,         93)

```

`KDemu/include/LIEF/LIEF/ELF/Relocations/LoongArch.def`:

```def

#ifndef ELF_RELOC
#error "ELF_RELOC must be defined"
#endif

ELF_RELOC(LARCH_NONE, 0)
ELF_RELOC(LARCH_32, 1)
ELF_RELOC(LARCH_64, 2)
ELF_RELOC(LARCH_RELATIVE, 3)
ELF_RELOC(LARCH_COPY, 4)
ELF_RELOC(LARCH_JUMP_SLOT, 5)
ELF_RELOC(LARCH_TLS_DTPMOD32, 6)
ELF_RELOC(LARCH_TLS_DTPMOD64, 7)
ELF_RELOC(LARCH_TLS_DTPREL32, 8)
ELF_RELOC(LARCH_TLS_DTPREL64, 9)
ELF_RELOC(LARCH_TLS_TPREL32, 10)
ELF_RELOC(LARCH_TLS_TPREL64, 11)
ELF_RELOC(LARCH_IRELATIVE, 12)

ELF_RELOC(LARCH_MARK_LA, 20)
ELF_RELOC(LARCH_MARK_PCREL, 21)

ELF_RELOC(LARCH_SOP_PUSH_PCREL, 22)

ELF_RELOC(LARCH_SOP_PUSH_ABSOLUTE, 23)

ELF_RELOC(LARCH_SOP_PUSH_DUP, 24)
ELF_RELOC(LARCH_SOP_PUSH_GPREL, 25)
ELF_RELOC(LARCH_SOP_PUSH_TLS_TPREL, 26)
ELF_RELOC(LARCH_SOP_PUSH_TLS_GOT, 27)
ELF_RELOC(LARCH_SOP_PUSH_TLS_GD, 28)
ELF_RELOC(LARCH_SOP_PUSH_PLT_PCREL, 29)

ELF_RELOC(LARCH_SOP_ASSERT, 30)
ELF_RELOC(LARCH_SOP_NOT, 31)
ELF_RELOC(LARCH_SOP_SUB, 32)
ELF_RELOC(LARCH_SOP_SL, 33)
ELF_RELOC(LARCH_SOP_SR, 34)
ELF_RELOC(LARCH_SOP_ADD, 35)
ELF_RELOC(LARCH_SOP_AND, 36)
ELF_RELOC(LARCH_SOP_IF_ELSE, 37)
ELF_RELOC(LARCH_SOP_POP_32_S_10_5, 38)
ELF_RELOC(LARCH_SOP_POP_32_U_10_12, 39)
ELF_RELOC(LARCH_SOP_POP_32_S_10_12, 40)
ELF_RELOC(LARCH_SOP_POP_32_S_10_16, 41)
ELF_RELOC(LARCH_SOP_POP_32_S_10_16_S2, 42)
ELF_RELOC(LARCH_SOP_POP_32_S_5_20, 43)
ELF_RELOC(LARCH_SOP_POP_32_S_0_5_10_16_S2, 44)
ELF_RELOC(LARCH_SOP_POP_32_S_0_10_10_16_S2, 45)
ELF_RELOC(LARCH_SOP_POP_32_U, 46)

ELF_RELOC(LARCH_ADD8, 47)
ELF_RELOC(LARCH_ADD16, 48)
ELF_RELOC(LARCH_ADD24, 49)
ELF_RELOC(LARCH_ADD32, 50)
ELF_RELOC(LARCH_ADD64, 51)
ELF_RELOC(LARCH_SUB8, 52)
ELF_RELOC(LARCH_SUB16, 53)
ELF_RELOC(LARCH_SUB24, 54)
ELF_RELOC(LARCH_SUB32, 55)
ELF_RELOC(LARCH_SUB64, 56)

ELF_RELOC(LARCH_GNU_VTINHERIT, 57)
ELF_RELOC(LARCH_GNU_VTENTRY, 58)

ELF_RELOC(LARCH_B16,              64)
ELF_RELOC(LARCH_B21,              65)
ELF_RELOC(LARCH_B26,              66)
ELF_RELOC(LARCH_ABS_HI20,         67)
ELF_RELOC(LARCH_ABS_LO12,         68)
ELF_RELOC(LARCH_ABS64_LO20,       69)
ELF_RELOC(LARCH_ABS64_HI12,       70)
ELF_RELOC(LARCH_PCALA_HI20,       71)
ELF_RELOC(LARCH_PCALA_LO12,       72)
ELF_RELOC(LARCH_PCALA64_LO20,     73)
ELF_RELOC(LARCH_PCALA64_HI12,     74)
ELF_RELOC(LARCH_GOT_PC_HI20,      75)
ELF_RELOC(LARCH_GOT_PC_LO12,      76)
ELF_RELOC(LARCH_GOT64_PC_LO20,    77)
ELF_RELOC(LARCH_GOT64_PC_HI12,    78)
ELF_RELOC(LARCH_GOT_HI20,         79)
ELF_RELOC(LARCH_GOT_LO12,         80)
ELF_RELOC(LARCH_GOT64_LO20,       81)
ELF_RELOC(LARCH_GOT64_HI12,       82)
ELF_RELOC(LARCH_TLS_LE_HI20,      83)
ELF_RELOC(LARCH_TLS_LE_LO12,      84)
ELF_RELOC(LARCH_TLS_LE64_LO20,    85)
ELF_RELOC(LARCH_TLS_LE64_HI12,    86)
ELF_RELOC(LARCH_TLS_IE_PC_HI20,   87)
ELF_RELOC(LARCH_TLS_IE_PC_LO12,   88)
ELF_RELOC(LARCH_TLS_IE64_PC_LO20, 89)
ELF_RELOC(LARCH_TLS_IE64_PC_HI12, 90)
ELF_RELOC(LARCH_TLS_IE_HI20,      91)
ELF_RELOC(LARCH_TLS_IE_LO12,      92)
ELF_RELOC(LARCH_TLS_IE64_LO20,    93)
ELF_RELOC(LARCH_TLS_IE64_HI12,    94)
ELF_RELOC(LARCH_TLS_LD_PC_HI20,   95)
ELF_RELOC(LARCH_TLS_LD_HI20,      96)
ELF_RELOC(LARCH_TLS_GD_PC_HI20,   97)
ELF_RELOC(LARCH_TLS_GD_HI20,      98)
ELF_RELOC(LARCH_32_PCREL,         99)
ELF_RELOC(LARCH_RELAX,            100)

```

`KDemu/include/LIEF/LIEF/ELF/Relocations/Mips.def`:

```def

#ifndef ELF_RELOC
#error "ELF_RELOC must be defined"
#endif

ELF_RELOC(MIPS_NONE,                0)
ELF_RELOC(MIPS_16,                  1)
ELF_RELOC(MIPS_32,                  2)
ELF_RELOC(MIPS_REL32,               3)
ELF_RELOC(MIPS_26,                  4)
ELF_RELOC(MIPS_HI16,                5)
ELF_RELOC(MIPS_LO16,                6)
ELF_RELOC(MIPS_GPREL16,             7)
ELF_RELOC(MIPS_LITERAL,             8)
ELF_RELOC(MIPS_GOT16,               9)
ELF_RELOC(MIPS_PC16,               10)
ELF_RELOC(MIPS_CALL16,             11)
ELF_RELOC(MIPS_GPREL32,            12)
ELF_RELOC(MIPS_UNUSED1,            13)
ELF_RELOC(MIPS_UNUSED2,            14)
ELF_RELOC(MIPS_UNUSED3,            15)
ELF_RELOC(MIPS_SHIFT5,             16)
ELF_RELOC(MIPS_SHIFT6,             17)
ELF_RELOC(MIPS_64,                 18)
ELF_RELOC(MIPS_GOT_DISP,           19)
ELF_RELOC(MIPS_GOT_PAGE,           20)
ELF_RELOC(MIPS_GOT_OFST,           21)
ELF_RELOC(MIPS_GOT_HI16,           22)
ELF_RELOC(MIPS_GOT_LO16,           23)
ELF_RELOC(MIPS_SUB,                24)
ELF_RELOC(MIPS_INSERT_A,           25)
ELF_RELOC(MIPS_INSERT_B,           26)
ELF_RELOC(MIPS_DELETE,             27)
ELF_RELOC(MIPS_HIGHER,             28)
ELF_RELOC(MIPS_HIGHEST,            29)
ELF_RELOC(MIPS_CALL_HI16,          30)
ELF_RELOC(MIPS_CALL_LO16,          31)
ELF_RELOC(MIPS_SCN_DISP,           32)
ELF_RELOC(MIPS_REL16,              33)
ELF_RELOC(MIPS_ADD_IMMEDIATE,      34)
ELF_RELOC(MIPS_PJUMP,              35)
ELF_RELOC(MIPS_RELGOT,             36)
ELF_RELOC(MIPS_JALR,               37)
ELF_RELOC(MIPS_TLS_DTPMOD32,       38)
ELF_RELOC(MIPS_TLS_DTPREL32,       39)
ELF_RELOC(MIPS_TLS_DTPMOD64,       40)
ELF_RELOC(MIPS_TLS_DTPREL64,       41)
ELF_RELOC(MIPS_TLS_GD,             42)
ELF_RELOC(MIPS_TLS_LDM,            43)
ELF_RELOC(MIPS_TLS_DTPREL_HI16,    44)
ELF_RELOC(MIPS_TLS_DTPREL_LO16,    45)
ELF_RELOC(MIPS_TLS_GOTTPREL,       46)
ELF_RELOC(MIPS_TLS_TPREL32,        47)
ELF_RELOC(MIPS_TLS_TPREL64,        48)
ELF_RELOC(MIPS_TLS_TPREL_HI16,     49)
ELF_RELOC(MIPS_TLS_TPREL_LO16,     50)
ELF_RELOC(MIPS_GLOB_DAT,           51)
ELF_RELOC(MIPS_PC21_S2,            60)
ELF_RELOC(MIPS_PC26_S2,            61)
ELF_RELOC(MIPS_PC18_S3,            62)
ELF_RELOC(MIPS_PC19_S2,            63)
ELF_RELOC(MIPS_PCHI16,             64)
ELF_RELOC(MIPS_PCLO16,             65)
ELF_RELOC(MIPS16_26,               100)
ELF_RELOC(MIPS16_GPREL,            101)
ELF_RELOC(MIPS16_GOT16,            102)
ELF_RELOC(MIPS16_CALL16,           103)
ELF_RELOC(MIPS16_HI16,             104)
ELF_RELOC(MIPS16_LO16,             105)
ELF_RELOC(MIPS16_TLS_GD,           106)
ELF_RELOC(MIPS16_TLS_LDM,          107)
ELF_RELOC(MIPS16_TLS_DTPREL_HI16,  108)
ELF_RELOC(MIPS16_TLS_DTPREL_LO16,  109)
ELF_RELOC(MIPS16_TLS_GOTTPREL,     110)
ELF_RELOC(MIPS16_TLS_TPREL_HI16,   111)
ELF_RELOC(MIPS16_TLS_TPREL_LO16,   112)
ELF_RELOC(MIPS_COPY,               126)
ELF_RELOC(MIPS_JUMP_SLOT,          127)
ELF_RELOC(MICROMIPS_26_S1,         133)
ELF_RELOC(MICROMIPS_HI16,          134)
ELF_RELOC(MICROMIPS_LO16,          135)
ELF_RELOC(MICROMIPS_GPREL16,       136)
ELF_RELOC(MICROMIPS_LITERAL,       137)
ELF_RELOC(MICROMIPS_GOT16,         138)
ELF_RELOC(MICROMIPS_PC7_S1,        139)
ELF_RELOC(MICROMIPS_PC10_S1,       140)
ELF_RELOC(MICROMIPS_PC16_S1,       141)
ELF_RELOC(MICROMIPS_CALL16,        142)
ELF_RELOC(MICROMIPS_GOT_DISP,      145)
ELF_RELOC(MICROMIPS_GOT_PAGE,      146)
ELF_RELOC(MICROMIPS_GOT_OFST,      147)
ELF_RELOC(MICROMIPS_GOT_HI16,      148)
ELF_RELOC(MICROMIPS_GOT_LO16,      149)
ELF_RELOC(MICROMIPS_SUB,           150)
ELF_RELOC(MICROMIPS_HIGHER,        151)
ELF_RELOC(MICROMIPS_HIGHEST,       152)
ELF_RELOC(MICROMIPS_CALL_HI16,     153)
ELF_RELOC(MICROMIPS_CALL_LO16,     154)
ELF_RELOC(MICROMIPS_SCN_DISP,      155)
ELF_RELOC(MICROMIPS_JALR,          156)
ELF_RELOC(MICROMIPS_HI0_LO16,      157)
ELF_RELOC(MICROMIPS_TLS_GD,           162)
ELF_RELOC(MICROMIPS_TLS_LDM,          163)
ELF_RELOC(MICROMIPS_TLS_DTPREL_HI16,  164)
ELF_RELOC(MICROMIPS_TLS_DTPREL_LO16,  165)
ELF_RELOC(MICROMIPS_TLS_GOTTPREL,     166)
ELF_RELOC(MICROMIPS_TLS_TPREL_HI16,   169)
ELF_RELOC(MICROMIPS_TLS_TPREL_LO16,   170)
ELF_RELOC(MICROMIPS_GPREL7_S2,        172)
ELF_RELOC(MICROMIPS_PC23_S2,          173)
ELF_RELOC(MICROMIPS_PC21_S2,          174)
ELF_RELOC(MICROMIPS_PC26_S2,          175)
ELF_RELOC(MICROMIPS_PC18_S3,          176)
ELF_RELOC(MICROMIPS_PC19_S2,          177)
ELF_RELOC(MIPS_NUM,                218)
ELF_RELOC(MIPS_PC32,               248)
ELF_RELOC(MIPS_EH,                 249)

```

`KDemu/include/LIEF/LIEF/ELF/Relocations/PowerPC.def`:

```def

#ifndef ELF_RELOC
#error "ELF_RELOC must be defined"
#endif

ELF_RELOC(PPC_NONE,                   0)      /* No relocation. */
ELF_RELOC(PPC_ADDR32,                 1)
ELF_RELOC(PPC_ADDR24,                 2)
ELF_RELOC(PPC_ADDR16,                 3)
ELF_RELOC(PPC_ADDR16_LO,              4)
ELF_RELOC(PPC_ADDR16_HI,              5)
ELF_RELOC(PPC_ADDR16_HA,              6)
ELF_RELOC(PPC_ADDR14,                 7)
ELF_RELOC(PPC_ADDR14_BRTAKEN,         8)
ELF_RELOC(PPC_ADDR14_BRNTAKEN,        9)
ELF_RELOC(PPC_REL24,                  10)
ELF_RELOC(PPC_REL14,                  11)
ELF_RELOC(PPC_REL14_BRTAKEN,          12)
ELF_RELOC(PPC_REL14_BRNTAKEN,         13)
ELF_RELOC(PPC_GOT16,                  14)
ELF_RELOC(PPC_GOT16_LO,               15)
ELF_RELOC(PPC_GOT16_HI,               16)
ELF_RELOC(PPC_GOT16_HA,               17)
ELF_RELOC(PPC_PLTREL24,               18)
ELF_RELOC(PPC_JMP_SLOT,               21)
ELF_RELOC(PPC_RELATIVE,               22)
ELF_RELOC(PPC_LOCAL24PC,              23)
ELF_RELOC(PPC_REL32,                  26)
ELF_RELOC(PPC_TLS,                    67)
ELF_RELOC(PPC_DTPMOD32,               68)
ELF_RELOC(PPC_TPREL16,                69)
ELF_RELOC(PPC_TPREL16_LO,             70)
ELF_RELOC(PPC_TPREL16_HI,             71)
ELF_RELOC(PPC_TPREL16_HA,             72)
ELF_RELOC(PPC_TPREL32,                73)
ELF_RELOC(PPC_DTPREL16,               74)
ELF_RELOC(PPC_DTPREL16_LO,            75)
ELF_RELOC(PPC_DTPREL16_HI,            76)
ELF_RELOC(PPC_DTPREL16_HA,            77)
ELF_RELOC(PPC_DTPREL32,               78)
ELF_RELOC(PPC_GOT_TLSGD16,            79)
ELF_RELOC(PPC_GOT_TLSGD16_LO,         80)
ELF_RELOC(PPC_GOT_TLSGD16_HI,         81)
ELF_RELOC(PPC_GOT_TLSGD16_HA,         82)
ELF_RELOC(PPC_GOT_TLSLD16,            83)
ELF_RELOC(PPC_GOT_TLSLD16_LO,         84)
ELF_RELOC(PPC_GOT_TLSLD16_HI,         85)
ELF_RELOC(PPC_GOT_TLSLD16_HA,         86)
ELF_RELOC(PPC_GOT_TPREL16,            87)
ELF_RELOC(PPC_GOT_TPREL16_LO,         88)
ELF_RELOC(PPC_GOT_TPREL16_HI,         89)
ELF_RELOC(PPC_GOT_TPREL16_HA,         90)
ELF_RELOC(PPC_GOT_DTPREL16,           91)
ELF_RELOC(PPC_GOT_DTPREL16_LO,        92)
ELF_RELOC(PPC_GOT_DTPREL16_HI,        93)
ELF_RELOC(PPC_GOT_DTPREL16_HA,        94)
ELF_RELOC(PPC_TLSGD,                  95)
ELF_RELOC(PPC_TLSLD,                  96)
ELF_RELOC(PPC_REL16,                  249)
ELF_RELOC(PPC_REL16_LO,               250)
ELF_RELOC(PPC_REL16_HI,               251)
ELF_RELOC(PPC_REL16_HA,               252)

```

`KDemu/include/LIEF/LIEF/ELF/Relocations/PowerPC64.def`:

```def

#ifndef ELF_RELOC
#error "ELF_RELOC must be defined"
#endif

ELF_RELOC(PPC64_NONE,                 0)
ELF_RELOC(PPC64_ADDR32,               1)
ELF_RELOC(PPC64_ADDR24,               2)
ELF_RELOC(PPC64_ADDR16,               3)
ELF_RELOC(PPC64_ADDR16_LO,            4)
ELF_RELOC(PPC64_ADDR16_HI,            5)
ELF_RELOC(PPC64_ADDR16_HA,            6)
ELF_RELOC(PPC64_ADDR14,               7)
ELF_RELOC(PPC64_ADDR14_BRTAKEN,       8)
ELF_RELOC(PPC64_ADDR14_BRNTAKEN,      9)
ELF_RELOC(PPC64_REL24,                10)
ELF_RELOC(PPC64_REL14,                11)
ELF_RELOC(PPC64_REL14_BRTAKEN,        12)
ELF_RELOC(PPC64_REL14_BRNTAKEN,       13)
ELF_RELOC(PPC64_GOT16,                14)
ELF_RELOC(PPC64_GOT16_LO,             15)
ELF_RELOC(PPC64_GOT16_HI,             16)
ELF_RELOC(PPC64_GOT16_HA,             17)
ELF_RELOC(PPC64_JMP_SLOT,             21)
ELF_RELOC(PPC64_RELATIVE,             22)
ELF_RELOC(PPC64_REL32,                26)
ELF_RELOC(PPC64_ADDR64,               38)
ELF_RELOC(PPC64_ADDR16_HIGHER,        39)
ELF_RELOC(PPC64_ADDR16_HIGHERA,       40)
ELF_RELOC(PPC64_ADDR16_HIGHEST,       41)
ELF_RELOC(PPC64_ADDR16_HIGHESTA,      42)
ELF_RELOC(PPC64_REL64,                44)
ELF_RELOC(PPC64_TOC16,                47)
ELF_RELOC(PPC64_TOC16_LO,             48)
ELF_RELOC(PPC64_TOC16_HI,             49)
ELF_RELOC(PPC64_TOC16_HA,             50)
ELF_RELOC(PPC64_TOC,                  51)
ELF_RELOC(PPC64_ADDR16_DS,            56)
ELF_RELOC(PPC64_ADDR16_LO_DS,         57)
ELF_RELOC(PPC64_GOT16_DS,             58)
ELF_RELOC(PPC64_GOT16_LO_DS,          59)
ELF_RELOC(PPC64_TOC16_DS,             63)
ELF_RELOC(PPC64_TOC16_LO_DS,          64)
ELF_RELOC(PPC64_TLS,                  67)
ELF_RELOC(PPC64_DTPMOD64,             68)
ELF_RELOC(PPC64_TPREL16,              69)
ELF_RELOC(PPC64_TPREL16_LO,           70)
ELF_RELOC(PPC64_TPREL16_HI,           71)
ELF_RELOC(PPC64_TPREL16_HA,           72)
ELF_RELOC(PPC64_TPREL64,              73)
ELF_RELOC(PPC64_DTPREL16,             74)
ELF_RELOC(PPC64_DTPREL16_LO,          75)
ELF_RELOC(PPC64_DTPREL16_HI,          76)
ELF_RELOC(PPC64_DTPREL16_HA,          77)
ELF_RELOC(PPC64_DTPREL64,             78)
ELF_RELOC(PPC64_GOT_TLSGD16,          79)
ELF_RELOC(PPC64_GOT_TLSGD16_LO,       80)
ELF_RELOC(PPC64_GOT_TLSGD16_HI,       81)
ELF_RELOC(PPC64_GOT_TLSGD16_HA,       82)
ELF_RELOC(PPC64_GOT_TLSLD16,          83)
ELF_RELOC(PPC64_GOT_TLSLD16_LO,       84)
ELF_RELOC(PPC64_GOT_TLSLD16_HI,       85)
ELF_RELOC(PPC64_GOT_TLSLD16_HA,       86)
ELF_RELOC(PPC64_GOT_TPREL16_DS,       87)
ELF_RELOC(PPC64_GOT_TPREL16_LO_DS,    88)
ELF_RELOC(PPC64_GOT_TPREL16_HI,       89)
ELF_RELOC(PPC64_GOT_TPREL16_HA,       90)
ELF_RELOC(PPC64_GOT_DTPREL16_DS,      91)
ELF_RELOC(PPC64_GOT_DTPREL16_LO_DS,   92)
ELF_RELOC(PPC64_GOT_DTPREL16_HI,      93)
ELF_RELOC(PPC64_GOT_DTPREL16_HA,      94)
ELF_RELOC(PPC64_TPREL16_DS,           95)
ELF_RELOC(PPC64_TPREL16_LO_DS,        96)
ELF_RELOC(PPC64_TPREL16_HIGHER,       97)
ELF_RELOC(PPC64_TPREL16_HIGHERA,      98)
ELF_RELOC(PPC64_TPREL16_HIGHEST,      99)
ELF_RELOC(PPC64_TPREL16_HIGHESTA,     100)
ELF_RELOC(PPC64_DTPREL16_DS,          101)
ELF_RELOC(PPC64_DTPREL16_LO_DS,       102)
ELF_RELOC(PPC64_DTPREL16_HIGHER,      103)
ELF_RELOC(PPC64_DTPREL16_HIGHERA,     104)
ELF_RELOC(PPC64_DTPREL16_HIGHEST,     105)
ELF_RELOC(PPC64_DTPREL16_HIGHESTA,    106)
ELF_RELOC(PPC64_TLSGD,                107)
ELF_RELOC(PPC64_TLSLD,                108)
ELF_RELOC(PPC64_REL16,                249)
ELF_RELOC(PPC64_REL16_LO,             250)
ELF_RELOC(PPC64_REL16_HI,             251)
ELF_RELOC(PPC64_REL16_HA,             252)

```

`KDemu/include/LIEF/LIEF/ELF/Relocations/Sparc.def`:

```def

#ifndef ELF_RELOC
#error "ELF_RELOC must be defined"
#endif

ELF_RELOC(SPARC_NONE,         0)
ELF_RELOC(SPARC_8,            1)
ELF_RELOC(SPARC_16,           2)
ELF_RELOC(SPARC_32,           3)
ELF_RELOC(SPARC_DISP8,        4)
ELF_RELOC(SPARC_DISP16,       5)
ELF_RELOC(SPARC_DISP32,       6)
ELF_RELOC(SPARC_WDISP30,      7)
ELF_RELOC(SPARC_WDISP22,      8)
ELF_RELOC(SPARC_HI22,         9)
ELF_RELOC(SPARC_22,           10)
ELF_RELOC(SPARC_13,           11)
ELF_RELOC(SPARC_LO10,         12)
ELF_RELOC(SPARC_GOT10,        13)
ELF_RELOC(SPARC_GOT13,        14)
ELF_RELOC(SPARC_GOT22,        15)
ELF_RELOC(SPARC_PC10,         16)
ELF_RELOC(SPARC_PC22,         17)
ELF_RELOC(SPARC_WPLT30,       18)
ELF_RELOC(SPARC_COPY,         19)
ELF_RELOC(SPARC_GLOB_DAT,     20)
ELF_RELOC(SPARC_JMP_SLOT,     21)
ELF_RELOC(SPARC_RELATIVE,     22)
ELF_RELOC(SPARC_UA32,         23)
ELF_RELOC(SPARC_PLT32,        24)
ELF_RELOC(SPARC_HIPLT22,      25)
ELF_RELOC(SPARC_LOPLT10,      26)
ELF_RELOC(SPARC_PCPLT32,      27)
ELF_RELOC(SPARC_PCPLT22,      28)
ELF_RELOC(SPARC_PCPLT10,      29)
ELF_RELOC(SPARC_10,           30)
ELF_RELOC(SPARC_11,           31)
ELF_RELOC(SPARC_64,           32)
ELF_RELOC(SPARC_OLO10,        33)
ELF_RELOC(SPARC_HH22,         34)
ELF_RELOC(SPARC_HM10,         35)
ELF_RELOC(SPARC_LM22,         36)
ELF_RELOC(SPARC_PC_HH22,      37)
ELF_RELOC(SPARC_PC_HM10,      38)
ELF_RELOC(SPARC_PC_LM22,      39)
ELF_RELOC(SPARC_WDISP16,      40)
ELF_RELOC(SPARC_WDISP19,      41)
ELF_RELOC(SPARC_7,            43)
ELF_RELOC(SPARC_5,            44)
ELF_RELOC(SPARC_6,            45)
ELF_RELOC(SPARC_DISP64,       46)
ELF_RELOC(SPARC_PLT64,        47)
ELF_RELOC(SPARC_HIX22,        48)
ELF_RELOC(SPARC_LOX10,        49)
ELF_RELOC(SPARC_H44,          50)
ELF_RELOC(SPARC_M44,          51)
ELF_RELOC(SPARC_L44,          52)
ELF_RELOC(SPARC_REGISTER,     53)
ELF_RELOC(SPARC_UA64,         54)
ELF_RELOC(SPARC_UA16,         55)
ELF_RELOC(SPARC_TLS_GD_HI22,    56)
ELF_RELOC(SPARC_TLS_GD_LO10,    57)
ELF_RELOC(SPARC_TLS_GD_ADD,     58)
ELF_RELOC(SPARC_TLS_GD_CALL,    59)
ELF_RELOC(SPARC_TLS_LDM_HI22,   60)
ELF_RELOC(SPARC_TLS_LDM_LO10,   61)
ELF_RELOC(SPARC_TLS_LDM_ADD,    62)
ELF_RELOC(SPARC_TLS_LDM_CALL,   63)
ELF_RELOC(SPARC_TLS_LDO_HIX22,  64)
ELF_RELOC(SPARC_TLS_LDO_LOX10,  65)
ELF_RELOC(SPARC_TLS_LDO_ADD,    66)
ELF_RELOC(SPARC_TLS_IE_HI22,    67)
ELF_RELOC(SPARC_TLS_IE_LO10,    68)
ELF_RELOC(SPARC_TLS_IE_LD,      69)
ELF_RELOC(SPARC_TLS_IE_LDX,     70)
ELF_RELOC(SPARC_TLS_IE_ADD,     71)
ELF_RELOC(SPARC_TLS_LE_HIX22,   72)
ELF_RELOC(SPARC_TLS_LE_LOX10,   73)
ELF_RELOC(SPARC_TLS_DTPMOD32,   74)
ELF_RELOC(SPARC_TLS_DTPMOD64,   75)
ELF_RELOC(SPARC_TLS_DTPOFF32,   76)
ELF_RELOC(SPARC_TLS_DTPOFF64,   77)
ELF_RELOC(SPARC_TLS_TPOFF32,    78)
ELF_RELOC(SPARC_TLS_TPOFF64,    79)
ELF_RELOC(SPARC_GOTDATA_HIX22,  80)
ELF_RELOC(SPARC_GOTDATA_LOX10,  81)
ELF_RELOC(SPARC_GOTDATA_OP_HIX22,  82)
ELF_RELOC(SPARC_GOTDATA_OP_LOX10,  83)
ELF_RELOC(SPARC_GOTDATA_OP,     84)

```

`KDemu/include/LIEF/LIEF/ELF/Relocations/SystemZ.def`:

```def

#ifndef ELF_RELOC
#error "ELF_RELOC must be defined"
#endif

ELF_RELOC(SYSZ_NONE,          0)
ELF_RELOC(SYSZ_8,             1)
ELF_RELOC(SYSZ_12,            2)
ELF_RELOC(SYSZ_16,            3)
ELF_RELOC(SYSZ_32,            4)
ELF_RELOC(SYSZ_PC32,          5)
ELF_RELOC(SYSZ_GOT12,         6)
ELF_RELOC(SYSZ_GOT32,         7)
ELF_RELOC(SYSZ_PLT32,         8)
ELF_RELOC(SYSZ_COPY,          9)
ELF_RELOC(SYSZ_GLOB_DAT,     10)
ELF_RELOC(SYSZ_JMP_SLOT,     11)
ELF_RELOC(SYSZ_RELATIVE,     12)
ELF_RELOC(SYSZ_GOTOFF,       13)
ELF_RELOC(SYSZ_GOTPC,        14)
ELF_RELOC(SYSZ_GOT16,        15)
ELF_RELOC(SYSZ_PC16,         16)
ELF_RELOC(SYSZ_PC16DBL,      17)
ELF_RELOC(SYSZ_PLT16DBL,     18)
ELF_RELOC(SYSZ_PC32DBL,      19)
ELF_RELOC(SYSZ_PLT32DBL,     20)
ELF_RELOC(SYSZ_GOTPCDBL,     21)
ELF_RELOC(SYSZ_64,           22)
ELF_RELOC(SYSZ_PC64,         23)
ELF_RELOC(SYSZ_GOT64,        24)
ELF_RELOC(SYSZ_PLT64,        25)
ELF_RELOC(SYSZ_GOTENT,       26)
ELF_RELOC(SYSZ_GOTOFF16,     27)
ELF_RELOC(SYSZ_GOTOFF64,     28)
ELF_RELOC(SYSZ_GOTPLT12,     29)
ELF_RELOC(SYSZ_GOTPLT16,     30)
ELF_RELOC(SYSZ_GOTPLT32,     31)
ELF_RELOC(SYSZ_GOTPLT64,     32)
ELF_RELOC(SYSZ_GOTPLTENT,    33)
ELF_RELOC(SYSZ_PLTOFF16,     34)
ELF_RELOC(SYSZ_PLTOFF32,     35)
ELF_RELOC(SYSZ_PLTOFF64,     36)
ELF_RELOC(SYSZ_TLS_LOAD,     37)
ELF_RELOC(SYSZ_TLS_GDCALL,   38)
ELF_RELOC(SYSZ_TLS_LDCALL,   39)
ELF_RELOC(SYSZ_TLS_GD32,     40)
ELF_RELOC(SYSZ_TLS_GD64,     41)
ELF_RELOC(SYSZ_TLS_GOTIE12,  42)
ELF_RELOC(SYSZ_TLS_GOTIE32,  43)
ELF_RELOC(SYSZ_TLS_GOTIE64,  44)
ELF_RELOC(SYSZ_TLS_LDM32,    45)
ELF_RELOC(SYSZ_TLS_LDM64,    46)
ELF_RELOC(SYSZ_TLS_IE32,     47)
ELF_RELOC(SYSZ_TLS_IE64,     48)
ELF_RELOC(SYSZ_TLS_IEENT,    49)
ELF_RELOC(SYSZ_TLS_LE32,     50)
ELF_RELOC(SYSZ_TLS_LE64,     51)
ELF_RELOC(SYSZ_TLS_LDO32,    52)
ELF_RELOC(SYSZ_TLS_LDO64,    53)
ELF_RELOC(SYSZ_TLS_DTPMOD,   54)
ELF_RELOC(SYSZ_TLS_DTPOFF,   55)
ELF_RELOC(SYSZ_TLS_TPOFF,    56)
ELF_RELOC(SYSZ_20,           57)
ELF_RELOC(SYSZ_GOT20,        58)
ELF_RELOC(SYSZ_GOTPLT20,     59)
ELF_RELOC(SYSZ_TLS_GOTIE20,  60)
ELF_RELOC(SYSZ_IRELATIVE,    61)

```

`KDemu/include/LIEF/LIEF/ELF/Relocations/i386.def`:

```def

#ifndef ELF_RELOC
#error "ELF_RELOC must be defined"
#endif

/* TODO: this is just a subset */
ELF_RELOC(X86_NONE,           0)
ELF_RELOC(X86_32,             1)
ELF_RELOC(X86_PC32,           2)
ELF_RELOC(X86_GOT32,          3)
ELF_RELOC(X86_PLT32,          4)
ELF_RELOC(X86_COPY,           5)
ELF_RELOC(X86_GLOB_DAT,       6)
ELF_RELOC(X86_JUMP_SLOT,      7)
ELF_RELOC(X86_RELATIVE,       8)
ELF_RELOC(X86_GOTOFF,         9)
ELF_RELOC(X86_GOTPC,          10)
ELF_RELOC(X86_32PLT,          11)
ELF_RELOC(X86_TLS_TPOFF,      14)
ELF_RELOC(X86_TLS_IE,         15)
ELF_RELOC(X86_TLS_GOTIE,      16)
ELF_RELOC(X86_TLS_LE,         17)
ELF_RELOC(X86_TLS_GD,         18)
ELF_RELOC(X86_TLS_LDM,        19)
ELF_RELOC(X86_16,             20)
ELF_RELOC(X86_PC16,           21)
ELF_RELOC(X86_8,              22)
ELF_RELOC(X86_PC8,            23)
ELF_RELOC(X86_TLS_GD_32,      24)
ELF_RELOC(X86_TLS_GD_PUSH,    25)
ELF_RELOC(X86_TLS_GD_CALL,    26)
ELF_RELOC(X86_TLS_GD_POP,     27)
ELF_RELOC(X86_TLS_LDM_32,     28)
ELF_RELOC(X86_TLS_LDM_PUSH,   29)
ELF_RELOC(X86_TLS_LDM_CALL,   30)
ELF_RELOC(X86_TLS_LDM_POP,    31)
ELF_RELOC(X86_TLS_LDO_32,     32)
ELF_RELOC(X86_TLS_IE_32,      33)
ELF_RELOC(X86_TLS_LE_32,      34)
ELF_RELOC(X86_TLS_DTPMOD32,   35)
ELF_RELOC(X86_TLS_DTPOFF32,   36)
ELF_RELOC(X86_TLS_TPOFF32,    37)
ELF_RELOC(X86_TLS_GOTDESC,    39)
ELF_RELOC(X86_TLS_DESC_CALL,  40)
ELF_RELOC(X86_TLS_DESC,       41)
ELF_RELOC(X86_IRELATIVE,      42)

```

`KDemu/include/LIEF/LIEF/ELF/Relocations/x86_64.def`:

```def

#ifndef ELF_RELOC
#error "ELF_RELOC must be defined"
#endif

ELF_RELOC(X86_64_NONE,             0)
ELF_RELOC(X86_64_64,               1)
ELF_RELOC(X86_64_PC32,             2)
ELF_RELOC(X86_64_GOT32,            3)
ELF_RELOC(X86_64_PLT32,            4)
ELF_RELOC(X86_64_COPY,             5)
ELF_RELOC(X86_64_GLOB_DAT,         6)
ELF_RELOC(X86_64_JUMP_SLOT,        7)
ELF_RELOC(X86_64_RELATIVE,         8)
ELF_RELOC(X86_64_GOTPCREL,         9)
ELF_RELOC(X86_64_32,               10)
ELF_RELOC(X86_64_32S,              11)
ELF_RELOC(X86_64_16,               12)
ELF_RELOC(X86_64_PC16,             13)
ELF_RELOC(X86_64_8,                14)
ELF_RELOC(X86_64_PC8,              15)
ELF_RELOC(X86_64_DTPMOD64,         16)
ELF_RELOC(X86_64_DTPOFF64,         17)
ELF_RELOC(X86_64_TPOFF64,          18)
ELF_RELOC(X86_64_TLSGD,            19)
ELF_RELOC(X86_64_TLSLD,            20)
ELF_RELOC(X86_64_DTPOFF32,         21)
ELF_RELOC(X86_64_GOTTPOFF,         22)
ELF_RELOC(X86_64_TPOFF32,          23)
ELF_RELOC(X86_64_PC64,             24)
ELF_RELOC(X86_64_GOTOFF64,         25)
ELF_RELOC(X86_64_GOTPC32,          26)
ELF_RELOC(X86_64_GOT64,            27)
ELF_RELOC(X86_64_GOTPCREL64,       28)
ELF_RELOC(X86_64_GOTPC64,          29)
ELF_RELOC(X86_64_GOTPLT64,         30)
ELF_RELOC(X86_64_PLTOFF64,         31)
ELF_RELOC(X86_64_SIZE32,           32)
ELF_RELOC(X86_64_SIZE64,           33)
ELF_RELOC(X86_64_GOTPC32_TLSDESC,  34)
ELF_RELOC(X86_64_TLSDESC_CALL,     35)
ELF_RELOC(X86_64_TLSDESC,          36)
ELF_RELOC(X86_64_IRELATIVE,        37)

ELF_RELOC(X86_64_RELATIVE64,       38)
ELF_RELOC(X86_64_PC32_BND,         39)
ELF_RELOC(X86_64_PLT32_BND,        40)
ELF_RELOC(X86_64_GOTPCRELX,        41)
ELF_RELOC(X86_64_REX_GOTPCRELX,    42)


```

`KDemu/include/LIEF/LIEF/ELF/Section.h`:

```h
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_C_ELF_SECTION_H
#define LIEF_C_ELF_SECTION_H

#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

struct Elf_Section_t {
  const char* name;
  uint32_t    flags;
  uint32_t    type;
  uint64_t    virtual_address;
  uint64_t    offset;
  uint64_t    original_size;
  uint32_t    link;
  uint32_t    info;
  uint64_t    alignment;
  uint64_t    entry_size;
  uint64_t    size;
  uint8_t*    content;
  double      entropy;
};

typedef struct Elf_Section_t Elf_Section_t;

#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/include/LIEF/LIEF/ELF/Section.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_SECTION_H
#define LIEF_ELF_SECTION_H

#include <string>
#include <ostream>
#include <vector>

#include "LIEF/utils.hpp"
#include "LIEF/visibility.h"
#include "LIEF/Abstract/Section.hpp"

#include "LIEF/ELF/enums.hpp"
#include "LIEF/iterators.hpp"

namespace LIEF {
namespace ELF {

namespace DataHandler {
class Handler;
}

class Segment;
class Parser;
class Binary;
class Builder;
class ExeLayout;
class ObjectFileLayout;


//! Class wich represents an ELF Section
class LIEF_API Section : public LIEF::Section {
  friend class Parser;
  friend class Binary;
  friend class Builder;
  friend class ExeLayout;
  friend class ObjectFileLayout;

  public:
  using segments_t        = std::vector<Segment*>;
  using it_segments       = ref_iterator<segments_t&>;
  using it_const_segments = const_ref_iterator<const segments_t&>;

  static constexpr uint32_t MAX_SECTION_SIZE = 2_GB;

  enum class TYPE : uint64_t {
    SHT_NULL            = 0,  /**< No associated section (inactive entry). */
    PROGBITS            = 1,  /**< Program-defined contents. */
    SYMTAB              = 2,  /**< Symbol table. */
    STRTAB              = 3,  /**< String table. */
    RELA                = 4,  /**< Relocation entries; explicit addends. */
    HASH                = 5,  /**< Symbol hash table. */
    DYNAMIC             = 6,  /**< Information for dynamic linking. */
    NOTE                = 7,  /**< Information about the file. */
    NOBITS              = 8,  /**< Data occupies no space in the file. */
    REL                 = 9,  /**< Relocation entries; no explicit addends. */
    SHLIB               = 10, /**< Reserved. */
    DYNSYM              = 11, /**< Symbol table. */
    INIT_ARRAY          = 14, /**< Pointers to initialization functions. */
    FINI_ARRAY          = 15, /**< Pointers to termination functions. */
    PREINIT_ARRAY       = 16, /**< Pointers to pre-init functions. */
    GROUP               = 17, /**< Section group. */
    SYMTAB_SHNDX        = 18, /**< Indices for SHN_XINDEX entries. */
    RELR                = 19, /**< Relocation entries; only offsets. */

    ANDROID_REL         = 0x60000001, /**< Packed relocations (Android specific). */
    ANDROID_RELA        = 0x60000002, /**< Packed relocations (Android specific). */
    LLVM_ADDRSIG        = 0x6fff4c03, /**< This section is used to mark symbols as address-significant. */
    ANDROID_RELR        = 0x6fffff00, /**< New relr relocations (Android specific). */
    GNU_ATTRIBUTES      = 0x6ffffff5, /**< Object attributes. */
    GNU_HASH            = 0x6ffffff6, /**< GNU-style hash table. */
    GNU_VERDEF          = 0x6ffffffd, /**< GNU version definitions. */
    GNU_VERNEED         = 0x6ffffffe, /**< GNU version references. */
    GNU_VERSYM          = 0x6fffffff, /**< GNU symbol versions table. */

    _ID_SHIFT_ = 32,
    _ARM_ID_ = 1LLU, _HEX_ID_ = 2LLU, _X86_64_ID_ = 2LLU,
    _MIPS_ID_ = 3LLU,

    ARM_EXIDX           = 0x70000001U + (_ARM_ID_ << _ID_SHIFT_), /**< Exception Index table */
    ARM_PREEMPTMAP      = 0x70000002U + (_ARM_ID_ << _ID_SHIFT_), /**< BPABI DLL dynamic linking pre-emption map */
    ARM_ATTRIBUTES      = 0x70000003U + (_ARM_ID_ << _ID_SHIFT_), /**< Object file compatibility attributes */
    ARM_DEBUGOVERLAY    = 0x70000004U + (_ARM_ID_ << _ID_SHIFT_),
    ARM_OVERLAYSECTION  = 0x70000005U + (_ARM_ID_ << _ID_SHIFT_),

    HEX_ORDERED         = 0x70000000 + (_HEX_ID_ << _ID_SHIFT_), /**< Link editor is to sort the entries in this section based on their sizes */

    /* this section based on their sizes */
    X86_64_UNWIND       = 0x70000001 + (_X86_64_ID_ << _ID_SHIFT_), /**< Unwind information */

    MIPS_REGINFO        = 0x70000006 + (_MIPS_ID_ << _ID_SHIFT_), /**< Register usage information */
    MIPS_OPTIONS        = 0x7000000d + (_MIPS_ID_ << _ID_SHIFT_), /**< General options */
    MIPS_ABIFLAGS       = 0x7000002a + (_MIPS_ID_ << _ID_SHIFT_), /**< ABI information. */
  };

  enum class FLAGS : uint64_t {
    NONE                 = 0x000000000,
    WRITE                = 0x000000001,  /**< Section data should be writable during execution. */
    ALLOC                = 0x000000002,  /**< Section occupies memory during program execution. */
    EXECINSTR            = 0x000000004,  /**< Section contains executable machine instructions. */
    MERGE                = 0x000000010,  /**< The data in this section may be merged. */
    STRINGS              = 0x000000020,  /**< The data in this section is null-terminated strings. */
    INFO_LINK            = 0x000000040,  /**< A field in this section holds a section header table index. */
    LINK_ORDER           = 0x000000080,  /**< Adds special ordering requirements for link editors. */
    OS_NONCONFORMING     = 0x000000100,  /**< This section requires special OS-specific processing to avoid incorrect behavior */
    GROUP                = 0x000000200,  /**< This section is a member of a section group. */
    TLS                  = 0x000000400,  /**< This section holds Thread-Local Storage. */
    COMPRESSED           = 0x000000800,
    GNU_RETAIN           = 0x000200000,
    EXCLUDE              = 0x080000000,

    _ID_SHIFT_ = 32,
    _XCORE_ID_ = 1LLU, _HEX_ID_ = 3LLU, _X86_64_ID_ = 2LLU,
    _MIPS_ID_  = 4LLU, _ARM_ID_ = 5LLU,

    XCORE_SHF_DP_SECTION = 0x010000000 + (_XCORE_ID_ << _ID_SHIFT_),
    XCORE_SHF_CP_SECTION = 0x020000000 + (_XCORE_ID_ << _ID_SHIFT_),

    X86_64_LARGE         = 0x010000000 + (_X86_64_ID_ << _ID_SHIFT_),

    HEX_GPREL            = 0x010000000 + (_HEX_ID_ << _ID_SHIFT_),

    MIPS_NODUPES         = 0x001000000 + (_MIPS_ID_ << _ID_SHIFT_),
    MIPS_NAMES           = 0x002000000 + (_MIPS_ID_ << _ID_SHIFT_),
    MIPS_LOCAL           = 0x004000000 + (_MIPS_ID_ << _ID_SHIFT_),
    MIPS_NOSTRIP         = 0x008000000 + (_MIPS_ID_ << _ID_SHIFT_),
    MIPS_GPREL           = 0x010000000 + (_MIPS_ID_ << _ID_SHIFT_),
    MIPS_MERGE           = 0x020000000 + (_MIPS_ID_ << _ID_SHIFT_),
    MIPS_ADDR            = 0x040000000 + (_MIPS_ID_ << _ID_SHIFT_),
    MIPS_STRING          = 0x080000000 + (_MIPS_ID_ << _ID_SHIFT_),

    ARM_PURECODE         = 0x020000000 + (_ARM_ID_  << _ID_SHIFT_),
  };

  static constexpr uint64_t FLAG_MASK = (uint64_t(1) << uint8_t(FLAGS::_ID_SHIFT_)) - 1;
  static constexpr uint64_t TYPE_MASK = (uint64_t(1) << uint8_t(TYPE::_ID_SHIFT_)) - 1;

  static TYPE type_from(uint32_t value, ARCH arch);
  static uint32_t to_value(TYPE type) {
    return static_cast<uint64_t>(type) & TYPE_MASK;
  }

  Section(const std::string& name, TYPE type = TYPE::PROGBITS) :
    LIEF::Section(name),
    type_{type}
  {}

  Section() = default;
  ~Section() override = default;

  Section& operator=(Section other) {
    swap(other);
    return *this;
  }
  Section(const Section& other);
  void swap(Section& other) noexcept;

  TYPE type() const {
    return type_;
  }

  //! Section's content
  span<const uint8_t> content() const override;

  //! Set section content
  void content(const std::vector<uint8_t>& data) override;

  void content(std::vector<uint8_t>&& data);

  //! Section flags
  uint64_t flags() const {
    return flags_;
  }

  //! ``True`` if the section has the given flag
  bool has(FLAGS flag) const;

  //! ``True`` if the section is wrapped by the given Segment
  bool has(const Segment& segment) const;

  //! Return section flags as a ``std::set``
  std::vector<FLAGS> flags_list() const;

  uint64_t size() const override {
    return size_;
  }

  void size(uint64_t size) override;

  void offset(uint64_t offset) override;

  uint64_t offset() const override {
    return offset_;
  }

  //! @see offset
  uint64_t file_offset() const {
    return this->offset();
  }

  //! Original size of the section's data.
  //!
  //! This value is used by the ELF::Builder to determines if it needs
  //! to be relocated to avoid an override of the data
  uint64_t original_size() const {
    return original_size_;
  }

  //! Section file alignment
  uint64_t alignment() const {
    return address_align_;
  }

  //! Section information.
  //! The meaning of this value depends on the section's type
  uint64_t information() const {
    return info_;
  }

  //! This function returns the size of an element in the case of a section that contains
  //! an array.
  //!
  //! For instance, the `.dynamic` section contains an array of DynamicEntry. As the
  //! size of the raw C structure of this entry is 0x10 (`sizeoe(Elf64_Dyn)`)
  //! in a ELF64, the `entry_size` is set to this value.
  uint64_t entry_size() const {
    return entry_size_;
  }

  //! Index to another section
  uint32_t link() const {
    return link_;
  }

  //! Clear the content of the section with the given ``value``
  Section& clear(uint8_t value = 0);

  //! Add the given ELF_SECTION_FLAGS
  void add(FLAGS flag);

  //! Remove the given ELF_SECTION_FLAGS
  void remove(FLAGS flag);

  void type(TYPE type) {
    type_  = type;
  }

  void flags(uint64_t flags) {
    flags_ = flags;
  }

  void clear_flags() {
    flags_ = 0;
  }

  void file_offset(uint64_t offset) {
    this->offset(offset);
  }

  void link(uint32_t link) {
    link_ = link;
  }

  void information(uint32_t info) {
    info_ = info;
  }

  void alignment(uint64_t alignment) {
    address_align_ = alignment;
  }

  void entry_size(uint64_t entry_size) {
    entry_size_ = entry_size;
  }

  it_segments segments() {
    return segments_;
  }

  it_const_segments segments() const {
    return segments_;
  }

  Section& as_frame() {
    is_frame_ = true;
    return *this;
  }

  bool is_frame() const {
    return is_frame_;
  }

  void accept(Visitor& visitor) const override;

  Section& operator+=(FLAGS c) {
    add(c);
    return *this;
  }

  Section& operator-=(FLAGS c) {
    remove(c);
    return *this;
  }

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const Section& section);

  private:
  template<class T>
  LIEF_LOCAL Section(const T& header, ARCH arch);

  span<uint8_t> writable_content();
  ARCH arch_ = ARCH::NONE;
  TYPE type_ = TYPE::SHT_NULL;
  uint64_t flags_ = 0;
  uint64_t original_size_ = 0;
  uint32_t link_ = 0;
  uint32_t info_ = 0;
  uint64_t address_align_ = 0;
  uint64_t entry_size_ = 0;
  segments_t segments_;
  bool is_frame_ = false;
  DataHandler::Handler* datahandler_ = nullptr;
  std::vector<uint8_t> content_c_;
};

LIEF_API const char* to_string(Section::TYPE e);
LIEF_API const char* to_string(Section::FLAGS e);

}
}

ENABLE_BITMASK_OPERATORS(LIEF::ELF::Section::FLAGS)

#endif

```

`KDemu/include/LIEF/LIEF/ELF/Segment.h`:

```h
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_C_ELF_SEGMENT_H_
#define LIEF_C_ELF_SEGMENT_H_

#include <stdint.h>
#include "LIEF/ELF/enums.h"

#ifdef __cplusplus
extern "C" {
#endif

struct Elf_Segment_t {
  uint32_t type;
  uint32_t flags;
  uint64_t virtual_address;
  uint64_t virtual_size;
  uint64_t offset;
  uint64_t alignment;
  uint64_t size;
  uint8_t* content;
};

typedef struct Elf_Segment_t Elf_Segment_t;

#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/include/LIEF/LIEF/ELF/Segment.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_SEGMENT_H
#define LIEF_ELF_SEGMENT_H

#include <string>
#include <vector>
#include <ostream>
#include <memory>

#include "LIEF/Object.hpp"
#include "LIEF/visibility.h"
#include "LIEF/errors.hpp"
#include "LIEF/iterators.hpp"
#include "LIEF/span.hpp"

#include "LIEF/ELF/enums.hpp"

namespace LIEF {
namespace ELF {
namespace DataHandler {
class Handler;
}

class Parser;
class Binary;
class Section;
class Builder;

//! Class which represents the ELF segments
class LIEF_API Segment : public Object {

  friend class Parser;
  friend class Section;
  friend class Binary;
  friend class Builder;

  public:
  using sections_t        = std::vector<Section*>;
  using it_sections       = ref_iterator<sections_t&>;
  using it_const_sections = const_ref_iterator<const sections_t&>;

  static constexpr uint64_t PT_BIT = 33;
  static constexpr uint64_t PT_MASK = (uint64_t(1) << PT_BIT) - 1;

  static constexpr uint64_t PT_ARM      = uint64_t(1) << PT_BIT;
  static constexpr uint64_t PT_AARCH64  = uint64_t(2) << PT_BIT;
  static constexpr uint64_t PT_MIPS     = uint64_t(3) << PT_BIT;
  static constexpr uint64_t PT_RISCV    = uint64_t(4) << PT_BIT;

  enum class TYPE : uint64_t {
    UNKNOWN       = uint64_t(-1),
    PT_NULL       = 0, /**< Unused segment. */
    LOAD          = 1, /**< Loadable segment. */
    DYNAMIC       = 2, /**< Dynamic linking information. */
    INTERP        = 3, /**< Interpreter pathname. */
    NOTE          = 4, /**< Auxiliary information. */
    SHLIB         = 5, /**< Reserved. */
    PHDR          = 6, /**< The program header table itself. */
    TLS           = 7, /**< The thread-local storage template. */

    GNU_EH_FRAME  = 0x6474e550,

    GNU_STACK     = 0x6474e551, /**< Indicates stack executability. */
    GNU_PROPERTY  = 0x6474e553, /**< GNU property */
    GNU_RELRO     = 0x6474e552, /**< Read-only after relocation. */

    ARM_ARCHEXT   = 0x70000000 | PT_ARM, /**< Platform architecture compatibility info */
    ARM_EXIDX     = 0x70000001 | PT_ARM,

    AARCH64_MEMTAG_MTE = 0x70000002 | PT_AARCH64,

    MIPS_REGINFO  = 0x70000000 | PT_MIPS,  /**< Register usage information. */
    MIPS_RTPROC   = 0x70000001 | PT_MIPS,  /**< Runtime procedure table. */
    MIPS_OPTIONS  = 0x70000002 | PT_MIPS,  /**< Options segment. */
    MIPS_ABIFLAGS = 0x70000003 | PT_MIPS,  /**< Abiflags segment. */

    RISCV_ATTRIBUTES = 0x70000003 | PT_RISCV,
  };

  enum class FLAGS {
    NONE = 0,
    X    = 1,
    W    = 2,
    R    = 4,
  };

  static TYPE type_from(uint64_t value, ARCH arch);
  static uint64_t to_value(TYPE type) {
    return static_cast<uint64_t>(type) & PT_MASK;
  }

  static result<Segment> from_raw(const uint8_t* ptr, size_t size);
  static result<Segment> from_raw(const std::vector<uint8_t>& raw) {
    return from_raw(raw.data(), raw.size());
  }

  Segment() = default;

  ~Segment() override = default;

  Segment& operator=(Segment other);
  Segment(const Segment& other);

  Segment& operator=(Segment&&) = default;
  Segment(Segment&&) = default;

  void swap(Segment& other);

  bool is_load() const {
    return type() == TYPE::LOAD;
  }

  bool is_interpreter() const {
    return type() == TYPE::INTERP;
  }

  bool is_phdr() const {
    return type() == TYPE::PHDR;
  }

  //! The segment's type (LOAD, DYNAMIC, ...)
  TYPE type() const {
    return type_;
  }

  //! The flag permissions associated with this segment
  FLAGS flags() const {
    return FLAGS(flags_);
  }

  //! The file offset of the data associated with this segment
  uint64_t file_offset() const {
    return file_offset_;
  }

  //! The virtual address of the segment.
  uint64_t virtual_address() const {
    return virtual_address_;
  }

  //! The physical address of the segment.
  //! This value is not really relevant on systems like Linux or Android.
  //! On the other hand, Qualcomm trustlets might use this value.
  //!
  //! Usually this value matches virtual_address
  uint64_t physical_address() const {
    return physical_address_;
  }

  //! The **file** size of the data associated with this segment
  uint64_t physical_size() const {
    return size_;
  }

  //! The in-memory size of this segment.
  //! Usually, if the `.bss` segment is wrapped by this segment
  //! then, virtual_size is larger than physical_size
  uint64_t virtual_size() const {
    return virtual_size_;
  }

  //! The offset alignment of the segment
  uint64_t alignment() const {
    return alignment_;
  }

  //! The raw data associated with this segment.
  span<const uint8_t> content() const;

  //! Check if the current segment has the given flag
  bool has(FLAGS flag) const {
    return (flags_ & static_cast<uint64_t>(flag)) != 0;
  }

  //! Check if the current segment wraps the given ELF::Section
  bool has(const Section& section) const;

  //! Check if the current segment wraps the given section's name
  bool has(const std::string& section_name) const;

  //! Append the given ELF_SEGMENT_FLAGS
  void add(FLAGS flag);

  //! Remove the given ELF_SEGMENT_FLAGS
  void remove(FLAGS flag);

  void type(TYPE type) {
    type_ = type;
  }

  void flags(FLAGS flags) {
    flags_ = static_cast<uint32_t>(flags);
  }

  void flags(uint32_t flags) {
    flags_ = flags;
  }

  void clear_flags() {
    flags_ = 0;
  }

  void file_offset(uint64_t file_offset);

  void virtual_address(uint64_t virtual_address) {
    virtual_address_ = virtual_address;
  }

  void physical_address(uint64_t physical_address) {
    physical_address_ = physical_address;
  }

  void physical_size(uint64_t physical_size);

  void virtual_size(uint64_t virtual_size) {
    virtual_size_ = virtual_size;
  }

  void alignment(uint64_t alignment) {
    alignment_ = alignment;
  }

  void content(std::vector<uint8_t> content);

  template<typename T> T get_content_value(size_t offset) const;
  template<typename T> void set_content_value(size_t offset, T value);
  size_t get_content_size() const;

  //! Iterator over the sections wrapped by this segment
  it_sections sections() {
    return sections_;
  }

  it_const_sections sections() const {
    return sections_;
  }

  void accept(Visitor& visitor) const override;

  Segment& operator+=(FLAGS flag) {
    add(flag);
    return *this;
  }

  Segment& operator-=(FLAGS flag) {
    remove(flag);
    return *this;
  }

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const Segment& segment);

  private:
  template<class T>
  LIEF_LOCAL Segment(const T& header, ARCH arch = ARCH::NONE);

  uint64_t handler_size() const;
  span<uint8_t> writable_content();

  TYPE type_ = TYPE::PT_NULL;
  ARCH arch_ = ARCH::NONE;
  uint32_t flags_ = 0;
  uint64_t file_offset_ = 0;
  uint64_t virtual_address_ = 0;
  uint64_t physical_address_ = 0;
  uint64_t size_ = 0;
  uint64_t virtual_size_ = 0;
  uint64_t alignment_ = 0;
  uint64_t handler_size_ = 0;
  sections_t sections_;
  DataHandler::Handler* datahandler_ = nullptr;
  std::vector<uint8_t>  content_c_;
};

LIEF_API const char* to_string(Segment::TYPE e);
LIEF_API const char* to_string(Segment::FLAGS e);
}
}


ENABLE_BITMASK_OPERATORS(LIEF::ELF::Segment::FLAGS)

#endif /* _ELF_SEGMENT_H */

```

`KDemu/include/LIEF/LIEF/ELF/Symbol.h`:

```h
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_C_ELF_SYMBOL_H
#define LIEF_C_ELF_SYMBOL_H

#include <stdint.h>
#include "LIEF/types.h"

#ifdef __cplusplus
extern "C" {
#endif

struct Elf_Symbol_t {
  const char* name;
  uint32_t    type;
  uint32_t    binding;
  uint8_t     information;
  uint8_t     other;
  uint16_t    shndx;
  uint64_t    value;
  uint64_t    size;
  bool        is_exported; /**< Whether or not the symbol is exported */
  bool        is_imported; /**< Whether or not the symbol is imported */
};

typedef struct Elf_Symbol_t Elf_Symbol_t;

#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/include/LIEF/LIEF/ELF/Symbol.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_SYMBOL_H
#define LIEF_ELF_SYMBOL_H

#include <string>
#include <vector>
#include <ostream>

#include "LIEF/visibility.h"
#include "LIEF/Abstract/Symbol.hpp"
#include "LIEF/ELF/enums.hpp"

namespace LIEF {
namespace ELF {
class Parser;
class Binary;
class SymbolVersion;
class Section;

/// Class which represents an ELF symbol
class LIEF_API Symbol : public LIEF::Symbol {
  friend class Parser;
  friend class Binary;
  public:

  enum class BINDING {
    LOCAL      = 0,  ///< Local symbol
    GLOBAL     = 1,  ///< Global symbol
    WEAK       = 2,  ///< Weak symbol
    GNU_UNIQUE = 10, ///< Unique symbol
  };

  /// Type of the symbol. This enum matches the `STT_xxx` values of the ELF
  /// specs
  enum class TYPE {
    NOTYPE    = 0,   ///< Symbol's type is not specified
    OBJECT    = 1,   ///< Symbol is a data object (variable, array, etc.)
    FUNC      = 2,   ///< Symbol is executable code (function, etc.)
    SECTION   = 3,   ///< Symbol refers to a section
    FILE      = 4,   ///< Local, absolute symbol that refers to a file
    COMMON    = 5,   ///< An uninitialized common block
    TLS       = 6,   ///< Thread local data object
    GNU_IFUNC = 10,  ///< GNU indirect function
  };

  /// Visibility of the symbol. This enum matches the `STV_xxx` values of the
  /// official ELF specs
  enum class VISIBILITY {
    DEFAULT   = 0,  ///< Visibility is specified by binding type
    INTERNAL  = 1,  ///< Defined by processor supplements
    HIDDEN    = 2,  ///< Not visible to other components
    PROTECTED = 3   ///< Visible in other components but not preemptable
  };

  /// Special section indices
  enum SECTION_INDEX {
    UNDEF  = 0,      ///< Undefined section
    ABS    = 0xfff1, ///< Associated symbol is absolute
    COMMON = 0xfff2, ///< Associated symbol is common
  };

  public:
  Symbol(std::string name):
    LIEF::Symbol(std::move(name), 0, 0)
  {}

  static BINDING binding_from(uint32_t value, ARCH) {
    return BINDING(value);
  }

  static TYPE type_from(uint32_t value, ARCH) {
    return TYPE(value);
  }

  static uint8_t to_value(BINDING binding) {
    return static_cast<uint8_t>(binding);
  }

  static uint8_t to_value(TYPE type) {
    return static_cast<uint8_t>(type);
  }

  Symbol() = default;
  ~Symbol() override = default;

  Symbol& operator=(Symbol other);
  Symbol(const Symbol& other);
  void swap(Symbol& other);

  /// The symbol's type provides a general classification for the associated entity
  TYPE type() const {
    return type_;
  }

  /// The symbol's binding determines the linkage visibility and behavior
  BINDING binding() const {
    return binding_;
  }

  /// This member specifies the symbol's type and binding attributes.
  uint8_t information() const;

  /// Alias for visibility()
  uint8_t other() const {
    return other_;
  }

  /// ELF::Section index associated with the symbol
  uint16_t section_idx() const {
    return shndx();
  }

  /// Symbol visibility
  VISIBILITY visibility() const {
    return VISIBILITY(other_);
  }

  /// Section associated with the symbol or a nullptr if it does not exist.
  Section* section() {
    return section_;
  }

  const Section* section() const {
    return section_;
  }

  /// This member has slightly different interpretations:
  ///   * In relocatable files, `value` holds alignment constraints for a symbol for which section index
  ///     is SHN_COMMON
  ///   * In relocatable files, `value` holds a section offset for a defined symbol. That is, `value` is an
  ///     offset from the beginning of the section associated with this symbol.
  ///   * In executable and shared object files, `value` holds a virtual address. To make these files's
  ///     symbols more useful for the dynamic linker, the section offset (file interpretation) gives way to
  ///     a virtual address (memory interpretation) for which the section number is irrelevant.
  uint64_t value() const override {
    return value_;
  }

  /// Symbol size
  ///
  /// Many symbols have associated sizes. For example, a data object's size is the number of
  /// bytes contained in the object. This member holds `0` if the symbol has no size or
  /// an unknown size.
  uint64_t size() const override {
    return size_;
  }

  /// @see Symbol::section_idx
  uint16_t shndx() const {
    return shndx_;
  }

  /// Check if this symbols has a @link ELF::SymbolVersion symbol version @endlink
  bool has_version() const {
    return symbol_version_ != nullptr;
  }

  /// Return the SymbolVersion associated with this symbol.
  /// If there is no symbol version, return a nullptr
  SymbolVersion* symbol_version() {
    return symbol_version_;
  }

  const SymbolVersion* symbol_version() const {
    return symbol_version_;
  }

  bool is_local() const {
    return binding() == BINDING::LOCAL;
  }

  bool is_global() const {
    return binding() == BINDING::GLOBAL;
  }

  bool is_weak() const {
    return binding() == BINDING::WEAK;
  }

  /// Symbol's unmangled name. If not available, it returns an empty string
  std::string demangled_name() const;

  void type(TYPE type) {
    type_ = type;
  }

  void binding(BINDING binding) {
    binding_ = binding;
  }

  void other(uint8_t other) {
    other_ = other;
  }

  void visibility(VISIBILITY visibility) {
    other_ = static_cast<uint8_t>(visibility);
  }

  void information(uint8_t info);

  void shndx(uint16_t idx) {
    shndx_ = idx;
  }

  void value(uint64_t value) override {
    value_ = value;
  }

  void size(uint64_t size) override {
    size_ = size;
  }

  /// Check if the current symbol is exported
  bool is_exported() const;

  /// Set whether or not the symbol is exported
  void set_exported(bool flag = true);

  /// Check if the current symbol is imported
  bool is_imported() const;

  /// Set whether or not the symbol is imported
  void set_imported(bool flag = true);

  /// True if the symbol is a static one
  bool is_static() const {
    return this->binding() == BINDING::GLOBAL;
  }

  /// True if the symbol represent a function
  bool is_function() const {
    return this->type() == TYPE::FUNC;
  }

  /// True if the symbol represent a variable
  bool is_variable() const {
    return this->type() == TYPE::OBJECT;
  }

  void accept(Visitor& visitor) const override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const Symbol& entry);

  private:
  template<class T>
  LIEF_API Symbol(const T& header, ARCH arch);

  TYPE    type_ = TYPE::NOTYPE;
  BINDING binding_ = BINDING::LOCAL;
  uint8_t other_   = 0;
  uint16_t shndx_   = 0;
  Section* section_ = nullptr;
  SymbolVersion* symbol_version_ = nullptr;
  ARCH arch_ = ARCH::NONE;
};

LIEF_API const char* to_string(Symbol::BINDING binding);
LIEF_API const char* to_string(Symbol::TYPE type);
LIEF_API const char* to_string(Symbol::VISIBILITY viz);
}
}
#endif /* _ELF_SYMBOL_H */

```

`KDemu/include/LIEF/LIEF/ELF/SymbolVersion.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_SYMBOL_VERSION_H
#define LIEF_ELF_SYMBOL_VERSION_H
#include <ostream>
#include <cstdint>

#include "LIEF/Object.hpp"
#include "LIEF/visibility.h"

namespace LIEF {
namespace ELF {
class Parser;
class SymbolVersionAux;
class SymbolVersionAuxRequirement;

//! Class which represents an entry defined in the `DT_VERSYM`
//! dynamic entry
class LIEF_API SymbolVersion : public Object {
  friend class Parser;

  public:
  SymbolVersion(uint16_t value) :
    value_(value)
  {}
  SymbolVersion() = default;

  //! Generate a *local* SymbolVersion
  static SymbolVersion local() {
    return SymbolVersion(0);
  }

  //! Generate a *global* SymbolVersion
  static SymbolVersion global() {
    return SymbolVersion(1);
  }

  ~SymbolVersion() override = default;

  SymbolVersion& operator=(const SymbolVersion&) = default;
  SymbolVersion(const SymbolVersion&) = default;

  //! Value associated with the symbol
  //!
  //! If the given SymbolVersion hasn't Auxiliary version:
  //!
  //! * ``0`` means **Local**
  //! * ``1`` means **Global**
  uint16_t value() const {
    return value_;
  }

  //! Whether the current SymbolVersion has an auxiliary one
  bool has_auxiliary_version() const {
    return symbol_version_auxiliary() != nullptr;
  }

  //! SymbolVersionAux associated with the current Version if any,
  //! or a nullptr
  SymbolVersionAux* symbol_version_auxiliary() {
    return symbol_aux_;
  }

  const SymbolVersionAux* symbol_version_auxiliary() const {
    return symbol_aux_;
  }

  //! Set the version's auxiliary requirement
  //! The given SymbolVersionAuxRequirement must be an existing
  //! reference in the ELF::Binary.
  //!
  //! On can add a new SymbolVersionAuxRequirement by using
  //! SymbolVersionRequirement::add_aux_requirement
  void symbol_version_auxiliary(SymbolVersionAuxRequirement& svauxr);

  void value(uint16_t v) {
    value_ = v;
  }

  void accept(Visitor& visitor) const override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const SymbolVersion& symv);

  private:
  uint16_t          value_ = 0;
  SymbolVersionAux* symbol_aux_ = nullptr;
};
}
}
#endif

```

`KDemu/include/LIEF/LIEF/ELF/SymbolVersionAux.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_SYMBOL_VERSION_AUX_H
#define LIEF_ELF_SYMBOL_VERSION_AUX_H

#include <string>
#include <ostream>

#include "LIEF/Object.hpp"
#include "LIEF/visibility.h"

namespace LIEF {
namespace ELF {
class Parser;

//! @brief Class which represents an Auxiliary Symbol version
class LIEF_API SymbolVersionAux : public Object {
  friend class Parser;
  public:
  SymbolVersionAux(std::string name) :
    name_(std::move(name))
  {}
  SymbolVersionAux() = default;
  ~SymbolVersionAux() override = default;

  SymbolVersionAux& operator=(const SymbolVersionAux&) = default;
  SymbolVersionAux(const SymbolVersionAux&) = default;

  //! Symbol's aux name (e.g. ``GLIBC_2.2.5``)
  const std::string& name() const {
    return name_;
  }

  void name(std::string name) {
    name_ = std::move(name);
  }

  void accept(Visitor& visitor) const override;

  LIEF_API friend
  std::ostream& operator<<(std::ostream& os, const SymbolVersionAux& aux) {
    os << aux.name();
    return os;
  }

  protected:
  std::string name_;
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/ELF/SymbolVersionAuxRequirement.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_SYMBOL_VERSION_AUX_REQUIREMENT_H
#define LIEF_ELF_SYMBOL_VERSION_AUX_REQUIREMENT_H

#include <string>
#include <ostream>
#include <cstdint>

#include "LIEF/visibility.h"
#include "LIEF/iterators.hpp"

#include "LIEF/ELF/SymbolVersionAux.hpp"

namespace LIEF {
namespace ELF {
namespace details {
struct Elf64_Vernaux;
struct Elf32_Vernaux;
}

class LIEF_API SymbolVersionAuxRequirement : public SymbolVersionAux {
  public:
  using SymbolVersionAux::name;

  SymbolVersionAuxRequirement(const details::Elf64_Vernaux& header);
  SymbolVersionAuxRequirement(const details::Elf32_Vernaux& header);
  SymbolVersionAuxRequirement() = default;

  SymbolVersionAuxRequirement& operator=(const SymbolVersionAuxRequirement&) = default;
  SymbolVersionAuxRequirement(const SymbolVersionAuxRequirement&) = default;

  ~SymbolVersionAuxRequirement() override = default;

  //! Hash value of the dependency name (use ELF hashing function)
  uint32_t hash() const {
    return hash_;
  }

  //! Bitmask of flags
  uint16_t flags() const {
    return flags_;
  }

  //! It returns the unique version index for the file which is used in the
  //! version symbol table. If the highest bit (bit 15) is set this
  //! is a hidden symbol which cannot be referenced from outside the
  //! object.
  uint16_t other() const {
    return other_;
  }

  void hash(uint32_t hash) {
    hash_ = hash;
  }

  void flags(uint16_t flags) {
    flags_ = flags;
  }

  void other(uint16_t other) {
    other_ = other;
  }

  void accept(Visitor& visitor) const override;

  LIEF_API friend
  std::ostream& operator<<(std::ostream& os, const SymbolVersionAuxRequirement& aux) {
    os << aux.name();
    return os;
  }

  private:
  uint32_t hash_ = 0;
  uint16_t flags_ = 0;
  uint16_t other_ = 0;
};
}
}
#endif

```

`KDemu/include/LIEF/LIEF/ELF/SymbolVersionDefinition.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_SYMBOL_VERSION_DEFINITION_H
#define LIEF_ELF_SYMBOL_VERSION_DEFINITION_H
#include <ostream>
#include <memory>

#include "LIEF/Object.hpp"
#include "LIEF/visibility.h"
#include "LIEF/iterators.hpp"

namespace LIEF {
namespace ELF {

class SymbolVersionAux;
class Parser;

namespace details {
struct Elf64_Verdef;
struct Elf32_Verdef;
}

//! Class which represents an entry defined in `DT_VERDEF` or `.gnu.version_d`
class LIEF_API SymbolVersionDefinition : public Object {
  friend class Parser;
  public:
  using version_aux_t        = std::vector<std::unique_ptr<SymbolVersionAux>>;
  using it_version_aux       = ref_iterator<version_aux_t&, SymbolVersionAux*>;
  using it_const_version_aux = const_ref_iterator<const version_aux_t&, const SymbolVersionAux*>;

  SymbolVersionDefinition() = default;
  SymbolVersionDefinition(const details::Elf64_Verdef& header);
  SymbolVersionDefinition(const details::Elf32_Verdef& header);
  ~SymbolVersionDefinition() override;

  SymbolVersionDefinition& operator=(SymbolVersionDefinition other);
  SymbolVersionDefinition(const SymbolVersionDefinition& other);
  void swap(SymbolVersionDefinition& other);

  //! Version revision
  //!
  //! This field should always have the value ``1``. It will be changed
  //! if the versioning implementation has to be changed in an incompatible way.
  uint16_t version() const {
    return version_;
  }

  //! Version information
  uint16_t flags() const {
    return flags_;
  }

  //! Version index
  //!
  //! Numeric value used as an index in the LIEF::ELF::SymbolVersion table
  uint16_t ndx() const {
    return ndx_;
  }

  //! Hash value of the symbol's name (using ELF hash function)
  uint32_t hash() const {
    return hash_;
  }

  //! SymbolVersionAux entries
  it_version_aux symbols_aux() {
    return symbol_version_aux_;
  }

  it_const_version_aux symbols_aux() const {
    return symbol_version_aux_;
  }

  void version(uint16_t version) {
    version_ = version;
  }

  void flags(uint16_t flags) {
    flags_ = flags;
  }

  void hash(uint32_t hash) {
    hash_ = hash;
  }

  void accept(Visitor& visitor) const override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const SymbolVersionDefinition& sym);

  private:
  uint16_t version_ = 1;
  uint16_t flags_ = 0;
  uint16_t ndx_  = 0;
  uint32_t hash_ = 0;
  version_aux_t symbol_version_aux_;
};
}
}
#endif


```

`KDemu/include/LIEF/LIEF/ELF/SymbolVersionRequirement.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_SYMBOL_VERSION_REQUIREMENTS_H
#define LIEF_ELF_SYMBOL_VERSION_REQUIREMENTS_H

#include <string>
#include <ostream>
#include <vector>
#include <memory>

#include "LIEF/Object.hpp"
#include "LIEF/visibility.h"
#include "LIEF/iterators.hpp"

namespace LIEF {
namespace ELF {
class Parser;
class SymbolVersionAuxRequirement;

namespace details {
struct Elf64_Verneed;
struct Elf32_Verneed;
}

//! Class which represents an entry in the `DT_VERNEED` or `.gnu.version_r` table
class LIEF_API SymbolVersionRequirement : public Object {
  friend class Parser;

  public:
  using aux_requirement_t        = std::vector<std::unique_ptr<SymbolVersionAuxRequirement>>;
  using it_aux_requirement       = ref_iterator<aux_requirement_t&, SymbolVersionAuxRequirement*>;
  using it_const_aux_requirement = const_ref_iterator<const aux_requirement_t&, const SymbolVersionAuxRequirement*>;

  SymbolVersionRequirement() = default;
  SymbolVersionRequirement(const details::Elf64_Verneed& header);
  SymbolVersionRequirement(const details::Elf32_Verneed& header);
  ~SymbolVersionRequirement() override = default;

  SymbolVersionRequirement& operator=(SymbolVersionRequirement other);
  SymbolVersionRequirement(const SymbolVersionRequirement& other);
  void swap(SymbolVersionRequirement& other);

  //! Version revision
  //!
  //! This field should always have the value ``1``. It will be changed
  //! if the versioning implementation has to be changed in an incompatible way.
  uint16_t version() const {
    return version_;
  }

  //! Number of auxiliary entries
  size_t cnt() const {
    return aux_requirements_.size();
  }

  //! Auxiliary entries as an iterator over SymbolVersionAuxRequirement
  it_aux_requirement auxiliary_symbols() {
    return aux_requirements_;
  }

  it_const_aux_requirement auxiliary_symbols() const {
    return aux_requirements_;
  }

  //! Return the library name associated with this requirement (e.g. ``libc.so.6``)
  const std::string& name() const {
    return name_;
  }

  void version(uint16_t version) {
    version_ = version;
  }

  void name(const std::string& name) {
    name_ = name;
  }

  //! Add a version auxiliary requirement to the existing list
  SymbolVersionAuxRequirement& add_aux_requirement(const SymbolVersionAuxRequirement& aux_requirement);

  void accept(Visitor& visitor) const override;

  LIEF_API friend
  std::ostream& operator<<(std::ostream& os, const SymbolVersionRequirement& symr) {
    os << symr.version() << " " << symr.name();
    return os;
  }

  private:
  aux_requirement_t aux_requirements_;
  uint16_t    version_ = 0;
  std::string name_;
};

}
}
#endif


```

`KDemu/include/LIEF/LIEF/ELF/SysvHash.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_SYSV_HASH_H
#define LIEF_ELF_SYSV_HASH_H

#include <cstdint>
#include <vector>
#include <ostream>

#include "LIEF/Object.hpp"
#include "LIEF/visibility.h"

namespace LIEF {
namespace ELF {

class Parser;
class Builder;
class Binary;

//! Class which represents the SYSV hash for the symbols
//! resolution.
//!
//! References:
//! - http://www.linker-aliens.org/blogs/ali/entry/gnu_hash_elf_sections/
//! - https://docs.oracle.com/cd/E23824_01/html/819-0690/chapter6-48031.html
class LIEF_API SysvHash : public Object {

  friend class Parser;
  friend class Builder;
  friend class Binary;

  public:
  SysvHash() = default;
  SysvHash& operator=(const SysvHash& copy) = default;
  SysvHash(const SysvHash& copy) = default;

  SysvHash& operator=(SysvHash&&) = default;
  SysvHash(SysvHash&&) = default;
  ~SysvHash() override = default;

  //! @brief Return the number of buckets used
  uint32_t nbucket() const {
    return buckets_.size();
  }

  //! @brief Return the number of chain used
  uint32_t nchain() const {
    return chains_.size();
  }

  //! @brief Buckets values
  const std::vector<uint32_t>& buckets() const {
    return buckets_;
  }

  //! @brief Chains values
  const std::vector<uint32_t>& chains() const {
    return chains_;
  }

  void nchain(uint32_t nb) {
    chains_.resize(nb);
  }

  void accept(Visitor& visitor) const override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const SysvHash& sysvhash);

  private:
  std::vector<uint32_t> buckets_;
  std::vector<uint32_t> chains_;
};

} // namepsace ELF
} // namespace LIEF

#endif

```

`KDemu/include/LIEF/LIEF/ELF/enums.h`:

```h
#ifndef LIEF_ELF_C_ENUMS_H_
#define LIEF_ELF_C_ENUMS_H_
#include "LIEF/ELF/undef.h"

#ifdef __cplusplus
extern "C" {
#endif

/** e_ident size and indices. */
enum LIEF_IDENTITY {
  LIEF_EI_MAG0       = 0,  /**< File identification index. */
  LIEF_EI_MAG1       = 1,  /**< File identification index. */
  LIEF_EI_MAG2       = 2,  /**< File identification index. */
  LIEF_EI_MAG3       = 3,  /**< File identification index. */
  LIEF_EI_CLASS      = 4,  /**< File class. */
  LIEF_EI_DATA       = 5,  /**< Data encoding. */
  LIEF_EI_VERSION    = 6,  /**< File version. */
  LIEF_EI_OSABI      = 7,  /**< OS/ABI identification. */
  LIEF_EI_ABIVERSION = 8,  /**< ABI version. */
  LIEF_EI_PAD        = 9,  /**< Start of padding bytes. */
  LIEF_EI_NIDENT     = 16  /**< Number of bytes in e_ident. */
};


/** Enum associated with *e_type* */
enum LIEF_E_TYPE {
  LIEF_ET_NONE   = 0,      /**< No file type */
  LIEF_ET_REL    = 1,      /**< Relocatable file */
  LIEF_ET_EXEC   = 2,      /**< Executable file */
  LIEF_ET_DYN    = 3,      /**< Shared object file */
  LIEF_ET_CORE   = 4,      /**< Core file */
  LIEF_ET_LOPROC = 0xff00, /**< Beginning of processor-specific codes */
  LIEF_ET_HIPROC = 0xffff  /**< Processor-specific */
};


/** Versioning */
enum LIEF_VERSION {
  LIEF_EV_NONE    = 0,
  LIEF_EV_CURRENT = 1  /**< Default value */
};

/**
 * @brief Machine architectures
 * See current registered ELF machine architectures at:
 * http://www.sco.com/developers/gabi/latest/ch4.eheader.html
 */
enum LIEF_ARCH {
  LIEF_EM_NONE          = 0,  /**< No machine */
  LIEF_EM_M32           = 1,  /**< AT&T WE 32100 */
  LIEF_EM_SPARC         = 2,  /**< SPARC */
  LIEF_EM_386           = 3,  /**< Intel 386 */
  LIEF_EM_68K           = 4,  /**< Motorola 68000 */
  LIEF_EM_88K           = 5,  /**< Motorola 88000 */
  LIEF_EM_IAMCU         = 6,  /**< Intel MCU */
  LIEF_EM_860           = 7,  /**< Intel 80860 */
  LIEF_EM_MIPS          = 8,  /**< MIPS R3000 */
  LIEF_EM_S370          = 9,  /**< IBM System/370 */
  LIEF_EM_MIPS_RS3_LE   = 10, /**< MIPS RS3000 Little-endian */
  LIEF_EM_PARISC        = 15, /**< Hewlett-Packard PA-RISC */
  LIEF_EM_VPP500        = 17, /**< Fujitsu VPP500 */
  LIEF_EM_SPARC32PLUS   = 18, /**< Enhanced instruction set SPARC */
  LIEF_EM_960           = 19, /**< Intel 80960 */
  LIEF_EM_PPC           = 20, /**< PowerPC */
  LIEF_EM_PPC64         = 21, /**< PowerPC64 */
  LIEF_EM_S390          = 22, /**< IBM System/390 */
  LIEF_EM_SPU           = 23, /**< IBM SPU/SPC */
  LIEF_EM_V800          = 36, /**< NEC V800 */
  LIEF_EM_FR20          = 37, /**< Fujitsu FR20 */
  LIEF_EM_RH32          = 38, /**< TRW RH-32 */
  LIEF_EM_RCE           = 39, /**< Motorola RCE */
  LIEF_EM_ARM           = 40, /**< ARM */
  LIEF_EM_ALPHA         = 41, /**< DEC Alpha */
  LIEF_EM_SH            = 42, /**< Hitachi SH */
  LIEF_EM_SPARCV9       = 43, /**< SPARC V9 */
  LIEF_EM_TRICORE       = 44, /**< Siemens TriCore */
  LIEF_EM_ARC           = 45, /**< Argonaut RISC Core */
  LIEF_EM_H8_300        = 46, /**< Hitachi H8/300 */
  LIEF_EM_H8_300H       = 47, /**< Hitachi H8/300H */
  LIEF_EM_H8S           = 48, /**< Hitachi H8S */
  LIEF_EM_H8_500        = 49, /**< Hitachi H8/500 */
  LIEF_EM_IA_64         = 50, /**< Intel IA-64 processor architecture */
  LIEF_EM_MIPS_X        = 51, /**< Stanford MIPS-X */
  LIEF_EM_COLDFIRE      = 52, /**< Motorola ColdFire */
  LIEF_EM_68HC12        = 53, /**< Motorola M68HC12 */
  LIEF_EM_MMA           = 54, /**< Fujitsu MMA Multimedia Accelerator */
  LIEF_EM_PCP           = 55, /**< Siemens PCP */
  LIEF_EM_NCPU          = 56, /**< Sony nCPU embedded RISC processor */
  LIEF_EM_NDR1          = 57, /**< Denso NDR1 microprocessor */
  LIEF_EM_STARCORE      = 58, /**< Motorola Star*Core processor */
  LIEF_EM_ME16          = 59, /**< Toyota ME16 processor */
  LIEF_EM_ST100         = 60, /**< STMicroelectronics ST100 processor */
  LIEF_EM_TINYJ         = 61, /**< Advanced Logic Corp. TinyJ embedded processor family */
  LIEF_EM_X86_64        = 62, /**< AMD x86-64 architecture */
  LIEF_EM_PDSP          = 63, /**< Sony DSP Processor */
  LIEF_EM_PDP10         = 64, /**< Digital Equipment Corp. PDP-10 */
  LIEF_EM_PDP11         = 65, /**< Digital Equipment Corp. PDP-11 */
  LIEF_EM_FX66          = 66, /**< Siemens FX66 microcontroller */
  LIEF_EM_ST9PLUS       = 67, /**< STMicroelectronics ST9+ 8/16 bit microcontroller */
  LIEF_EM_ST7           = 68, /**< STMicroelectronics ST7 8-bit microcontroller */
  LIEF_EM_68HC16        = 69, /**< Motorola MC68HC16 Microcontroller */
  LIEF_EM_68HC11        = 70, /**< Motorola MC68HC11 Microcontroller */
  LIEF_EM_68HC08        = 71, /**< Motorola MC68HC08 Microcontroller */
  LIEF_EM_68HC05        = 72, /**< Motorola MC68HC05 Microcontroller */
  LIEF_EM_SVX           = 73, /**< Silicon Graphics SVx */
  LIEF_EM_ST19          = 74, /**< STMicroelectronics ST19 8-bit microcontroller */
  LIEF_EM_VAX           = 75, /**< Digital VAX */
  LIEF_EM_CRIS          = 76, /**< Axis Communications 32-bit embedded processor */
  LIEF_EM_JAVELIN       = 77, /**< Infineon Technologies 32-bit embedded processor */
  LIEF_EM_FIREPATH      = 78, /**< Element 14 64-bit DSP Processor */
  LIEF_EM_ZSP           = 79, /**< LSI Logic 16-bit DSP Processor */
  LIEF_EM_MMIX          = 80, /**< Donald Knuth's educational 64-bit processor */
  LIEF_EM_HUANY         = 81, /**< Harvard University machine-independent object files */
  LIEF_EM_PRISM         = 82, /**< SiTera Prism */
  LIEF_EM_AVR           = 83, /**< Atmel AVR 8-bit microcontroller */
  LIEF_EM_FR30          = 84, /**< Fujitsu FR30 */
  LIEF_EM_D10V          = 85, /**< Mitsubishi D10V */
  LIEF_EM_D30V          = 86, /**< Mitsubishi D30V */
  LIEF_EM_V850          = 87, /**< NEC v850 */
  LIEF_EM_M32R          = 88, /**< Mitsubishi M32R */
  LIEF_EM_MN10300       = 89, /**< Matsushita MN10300 */
  LIEF_EM_MN10200       = 90, /**< Matsushita MN10200 */
  LIEF_EM_PJ            = 91, /**< picoJava */
  LIEF_EM_OPENRISC      = 92, /**< OpenRISC 32-bit embedded processor */
  LIEF_EM_ARC_COMPACT   = 93, /**< ARC International ARCompact processor (old spelling/synonym: EM_ARC_A5 */
  LIEF_EM_XTENSA        = 94,  /**< Tensilica Xtensa Architecture */
  LIEF_EM_VIDEOCORE     = 95,  /**< Alphamosaic VideoCore processor */
  LIEF_EM_TMM_GPP       = 96,  /**< Thompson Multimedia General Purpose Processor */
  LIEF_EM_NS32K         = 97,  /**< National Semiconductor 32000 series */
  LIEF_EM_TPC           = 98,  /**< Tenor Network TPC processor */
  LIEF_EM_SNP1K         = 99,  /**< Trebia SNP 1000 processor */
  LIEF_EM_ST200         = 100, /**< STMicroelectronics (www.st.com ST200 */
  LIEF_EM_IP2K          = 101, /**< Ubicom IP2xxx microcontroller family */
  LIEF_EM_MAX           = 102, /**< MAX Processor */
  LIEF_EM_CR            = 103, /**< National Semiconductor CompactRISC microprocessor */
  LIEF_EM_F2MC16        = 104, /**< Fujitsu F2MC16 */
  LIEF_EM_MSP430        = 105, /**< Texas Instruments embedded microcontroller msp430 */
  LIEF_EM_BLACKFIN      = 106, /**< Analog Devices Blackfin (DSP processor */
  LIEF_EM_SE_C33        = 107, /**< S1C33 Family of Seiko Epson processors */
  LIEF_EM_SEP           = 108, /**< Sharp embedded microprocessor */
  LIEF_EM_ARCA          = 109, /**< Arca RISC Microprocessor */
  LIEF_EM_UNICORE       = 110, /**< Microprocessor series from PKU-Unity Ltd. and MPRC of Peking University */
  LIEF_EM_EXCESS        = 111, /**< eXcess: 16/32/64-bit configurable embedded CPU */
  LIEF_EM_DXP           = 112, /**< Icera Semiconductor Inc. Deep Execution Processor */
  LIEF_EM_ALTERA_NIOS2  = 113, /**< Altera Nios II soft-core processor */
  LIEF_EM_CRX           = 114, /**< National Semiconductor CompactRISC CRX */
  LIEF_EM_XGATE         = 115, /**< Motorola XGATE embedded processor */
  LIEF_EM_C166          = 116, /**< Infineon C16x/XC16x processor */
  LIEF_EM_M16C          = 117, /**< Renesas M16C series microprocessors */
  LIEF_EM_DSPIC30F      = 118, /**< Microchip Technology dsPIC30F Digital Signal */
  /* Controller */
  LIEF_EM_CE            = 119, /**< Freescale Communication Engine RISC core */
  LIEF_EM_M32C          = 120, /**< Renesas M32C series microprocessors */
  LIEF_EM_TSK3000       = 131, /**< Altium TSK3000 core */
  LIEF_EM_RS08          = 132, /**< Freescale RS08 embedded processor */
  LIEF_EM_SHARC         = 133, /**< Analog Devices SHARC family of 32-bit DSP */
  /* processors */
  LIEF_EM_ECOG2         = 134, /**< Cyan Technology eCOG2 microprocessor */
  LIEF_EM_SCORE7        = 135, /**< Sunplus S+core7 RISC processor */
  LIEF_EM_DSP24         = 136, /**< New Japan Radio (NJR 24-bit DSP Processor */
  LIEF_EM_VIDEOCORE3    = 137, /**< Broadcom VideoCore III processor */
  LIEF_EM_LATTICEMICO32 = 138, /**< RISC processor for Lattice FPGA architecture */
  LIEF_EM_SE_C17        = 139, /**< Seiko Epson C17 family */
  LIEF_EM_TI_C6000      = 140, /**< The Texas Instruments TMS320C6000 DSP family */
  LIEF_EM_TI_C2000      = 141, /**< The Texas Instruments TMS320C2000 DSP family */
  LIEF_EM_TI_C5500      = 142, /**< The Texas Instruments TMS320C55x DSP family */
  LIEF_EM_MMDSP_PLUS    = 160, /**< STMicroelectronics 64bit VLIW Data Signal Processor */
  LIEF_EM_CYPRESS_M8C   = 161, /**< Cypress M8C microprocessor */
  LIEF_EM_R32C          = 162, /**< Renesas R32C series microprocessors */
  LIEF_EM_TRIMEDIA      = 163, /**< NXP Semiconductors TriMedia architecture family */
  LIEF_EM_HEXAGON       = 164, /**< Qualcomm Hexagon processor */
  LIEF_EM_8051          = 165, /**< Intel 8051 and variants */
  LIEF_EM_STXP7X        = 166, /**< STMicroelectronics STxP7x family of configurable */
  /* and extensible RISC processors */
  LIEF_EM_NDS32         = 167, /* Andes Technology compact code size embedded RISC */
  /* processor family */
  LIEF_EM_ECOG1         = 168, /**< Cyan Technology eCOG1X family */
  LIEF_EM_ECOG1X        = 168, /**< Cyan Technology eCOG1X family */
  LIEF_EM_MAXQ30        = 169, /**< Dallas Semiconductor MAXQ30 Core Micro-controllers */
  LIEF_EM_XIMO16        = 170, /**< New Japan Radio (NJR 16-bit DSP Processor */
  LIEF_EM_MANIK         = 171, /**< M2000 Reconfigurable RISC Microprocessor */
  LIEF_EM_CRAYNV2       = 172, /**< Cray Inc. NV2 vector architecture */
  LIEF_EM_RX            = 173, /**< Renesas RX family */
  LIEF_EM_METAG         = 174, /**< Imagination Technologies META processor */
  /* architecture */
  LIEF_EM_MCST_ELBRUS   = 175, /**< MCST Elbrus general purpose hardware architecture */
  LIEF_EM_ECOG16        = 176, /**< Cyan Technology eCOG16 family */
  LIEF_EM_CR16          = 177, /**< National Semiconductor CompactRISC CR16 16-bit */
  /* microprocessor */
  LIEF_EM_ETPU          = 178, /**< Freescale Extended Time Processing Unit */
  LIEF_EM_SLE9X         = 179, /**< Infineon Technologies SLE9X core */
  LIEF_EM_L10M          = 180, /**< Intel L10M */
  LIEF_EM_K10M          = 181, /**< Intel K10M */
  LIEF_EM_AARCH64       = 183, /**< ARM AArch64 */
  LIEF_EM_AVR32         = 185, /**< Atmel Corporation 32-bit microprocessor family */
  LIEF_EM_STM8          = 186, /**< STMicroeletronics STM8 8-bit microcontroller */
  LIEF_EM_TILE64        = 187, /**< Tilera TILE64 multicore architecture family */
  LIEF_EM_TILEPRO       = 188, /**< Tilera TILEPro multicore architecture family */
  LIEF_EM_CUDA          = 190, /**< NVIDIA CUDA architecture */
  LIEF_EM_TILEGX        = 191, /**< Tilera TILE-Gx multicore architecture family */
  LIEF_EM_CLOUDSHIELD   = 192, /**< CloudShield architecture family */
  LIEF_EM_COREA_1ST     = 193, /**< KIPO-KAIST Core-A 1st generation processor family */
  LIEF_EM_COREA_2ND     = 194, /**< KIPO-KAIST Core-A 2nd generation processor family */
  LIEF_EM_ARC_COMPACT2  = 195, /**< Synopsys ARCompact V2 */
  LIEF_EM_OPEN8         = 196, /**< Open8 8-bit RISC soft processor core */
  LIEF_EM_RL78          = 197, /**< Renesas RL78 family */
  LIEF_EM_VIDEOCORE5    = 198, /**< Broadcom VideoCore V processor */
  LIEF_EM_78KOR         = 199, /**< Renesas 78KOR family */
  LIEF_EM_56800EX       = 200, /**< Freescale 56800EX Digital Signal Controller (DSC */
  LIEF_EM_BA1           = 201, /**< Beyond BA1 CPU architecture */
  LIEF_EM_BA2           = 202, /**< Beyond BA2 CPU architecture */
  LIEF_EM_XCORE         = 203, /**< XMOS xCORE processor family */
  LIEF_EM_MCHP_PIC      = 204, /**< Microchip 8-bit PIC(r family */
  LIEF_EM_INTEL205      = 205, /**< Reserved by Intel */
  LIEF_EM_INTEL206      = 206, /**< Reserved by Intel */
  LIEF_EM_INTEL207      = 207, /**< Reserved by Intel */
  LIEF_EM_INTEL208      = 208, /**< Reserved by Intel */
  LIEF_EM_INTEL209      = 209, /**< Reserved by Intel */
  LIEF_EM_KM32          = 210, /**< KM211 KM32 32-bit processor */
  LIEF_EM_KMX32         = 211, /**< KM211 KMX32 32-bit processor */
  LIEF_EM_KMX16         = 212, /**< KM211 KMX16 16-bit processor */
  LIEF_EM_KMX8          = 213, /**< KM211 KMX8 8-bit processor */
  LIEF_EM_KVARC         = 214, /**< KM211 KVARC processor */
  LIEF_EM_CDP           = 215, /**< Paneve CDP architecture family */
  LIEF_EM_COGE          = 216, /**< Cognitive Smart Memory Processor */
  LIEF_EM_COOL          = 217, /**< iCelero CoolEngine */
  LIEF_EM_NORC          = 218, /**< Nanoradio Optimized RISC */
  LIEF_EM_CSR_KALIMBA   = 219, /**< CSR Kalimba architecture family */
  LIEF_EM_AMDGPU        = 224, /**< AMD GPU architecture */
  LIEF_EM_RISCV         = 243, /**< RISC-V */
  LIEF_EM_BPF           = 247, /**< eBPF Filter */
  LIEF_EM_LOONGARCH     = 258  /**< LoongArch */
};


/** Object file classes. */
enum LIEF_ELF_CLASS {
  LIEF_ELFCLASSNONE = 0, /**< Unknown */
  LIEF_ELFCLASS32   = 1, /**< 32-bit object file */
  LIEF_ELFCLASS64   = 2  /**< 64-bit object file */
};

/** Object file byte orderings. */
enum LIEF_ELF_DATA {
  LIEF_ELFDATANONE = 0, /**< Invalid data encoding. */
  LIEF_ELFDATA2LSB = 1, /**< Little-endian object file */
  LIEF_ELFDATA2MSB = 2  /**< Big-endian object file */
};

/** OS ABI identification. */
enum LIEF_OS_ABI {
  LIEF_OSABI_SYSTEMV      = 0,  /**< UNIX System V ABI */
  LIEF_OSABI_HPUX         = 1,  /**< HP-UX operating system */
  LIEF_OSABI_NETBSD       = 2,  /**< NetBSD */
  LIEF_OSABI_GNU          = 3,  /**< GNU/Linux */
  LIEF_OSABI_LINUX        = 3,  /**< Historical alias for ELFOSABI_GNU. */
  LIEF_OSABI_HURD         = 4,  /**< GNU/Hurd */
  LIEF_OSABI_SOLARIS      = 6,  /**< Solaris */
  LIEF_OSABI_AIX          = 7,  /**< AIX */
  LIEF_OSABI_IRIX         = 8,  /**< IRIX */
  LIEF_OSABI_FREEBSD      = 9,  /**< FreeBSD */
  LIEF_OSABI_TRU64        = 10, /**< TRU64 UNIX */
  LIEF_OSABI_MODESTO      = 11, /**< Novell Modesto */
  LIEF_OSABI_OPENBSD      = 12, /**< OpenBSD */
  LIEF_OSABI_OPENVMS      = 13, /**< OpenVMS */
  LIEF_OSABI_NSK          = 14, /**< Hewlett-Packard Non-Stop Kernel */
  LIEF_OSABI_AROS         = 15, /**< AROS */
  LIEF_OSABI_FENIXOS      = 16, /**< FenixOS */
  LIEF_OSABI_CLOUDABI     = 17, /**< Nuxi CloudABI */
  LIEF_OSABI_C6000_ELFABI = 64, /**< Bare-metal TMS320C6000 */
  LIEF_OSABI_AMDGPU_HSA   = 64, /**< AMD HSA runtime */
  LIEF_OSABI_C6000_LINUX  = 65, /**< Linux TMS320C6000 */
  LIEF_OSABI_ARM          = 97, /**< ARM */
  LIEF_OSABI_STANDALONE   = 255 /**< Standalone (embedded application */
};

/* ELF Relocations */

#define ELF_RELOC(name, value) name = value,

/** x86_64 relocations. */
enum LIEF_RELOC_x86_64 {
   #include "LIEF/ELF/Relocations/x86_64.def"
};

/** i386 relocations. */
enum  RELOC_i386 {
   #include "LIEF/ELF/Relocations/i386.def"
};

/* ELF Relocation types for PPC32 */
enum LIEF_RELOC_POWERPC32 {
   #include "LIEF/ELF/Relocations/PowerPC.def"
};

/* ELF Relocation types for PPC64 */
enum LIEF_RELOC_POWERPC64 {
   #include "LIEF/ELF/Relocations/PowerPC64.def"
};

/* ELF Relocation types for AArch64 */
enum LIEF_RELOC_AARCH64 {
   #include "LIEF/ELF/Relocations/AArch64.def"
};

/* ELF Relocation types for ARM */
enum LIEF_RELOC_ARM {
  #include "LIEF/ELF/Relocations/ARM.def"
};

/* ELF Relocation types for Mips */
enum LIEF_RELOC_MIPS {
  #include "LIEF/ELF/Relocations/Mips.def"
};

/* ELF Relocation types for Hexagon */
enum LIEF_RELOC_HEXAGON {
  #include "LIEF/ELF/Relocations/Hexagon.def"
};

/* ELF Relocation types for S390/zSeries */
enum LIEF_RELOC_SYSTEMZ {
  #include "LIEF/ELF/Relocations/SystemZ.def"
};

/* ELF Relocation type for Sparc. */
enum LIEF_RELOC_SPARC {
  #include "LIEF/ELF/Relocations/Sparc.def"
};

/* ELF Relocation types for LoongArch. */
enum LIEF_RELOC_LOONGARCH {
  #include "LIEF/ELF/Relocations/LoongArch.def"
};

#undef ELF_RELOC

/* Specific e_flags for PPC64 */
enum LIEF_PPC64_EFLAGS {
  /* e_flags bits specifying ABI: */
  /* 1 for original ABI using function descriptors, */
  /* 2 for revised ABI without function descriptors, */
  /* 0 for unspecified or not using any features affected by the differences. */
  LIEF_EF_PPC64_ABI = 3
};

/* ARM Specific e_flags */
enum LIEF_ARM_EFLAGS {
  LIEF_EF_ARM_SOFT_FLOAT   = 0x00000200U,
  LIEF_EF_ARM_VFP_FLOAT    = 0x00000400U,
  LIEF_EF_ARM_EABI_UNKNOWN = 0x00000000U,
  LIEF_EF_ARM_EABI_VER1    = 0x01000000U,
  LIEF_EF_ARM_EABI_VER2    = 0x02000000U,
  LIEF_EF_ARM_EABI_VER3    = 0x03000000U,
  LIEF_EF_ARM_EABI_VER4    = 0x04000000U,
  LIEF_EF_ARM_EABI_VER5    = 0x05000000U,
  LIEF_EF_ARM_EABIMASK     = 0xFF000000U
};

/* Mips Specific e_flags */
enum LIEF_MIPS_EFLAGS {
  LIEF_EF_MIPS_NOREORDER = 0x00000001, /* Don't reorder instructions */
  LIEF_EF_MIPS_PIC       = 0x00000002, /* Position independent code */
  LIEF_EF_MIPS_CPIC      = 0x00000004, /* Call object with Position independent code */
  LIEF_EF_MIPS_ABI2      = 0x00000020, /* File uses N32 ABI */
  LIEF_EF_MIPS_32BITMODE = 0x00000100, /* Code compiled for a 64-bit machine */
  /* in 32-bit mode */
  LIEF_EF_MIPS_FP64      = 0x00000200, /* Code compiled for a 32-bit machine */
  /* but uses 64-bit FP registers */
  LIEF_EF_MIPS_NAN2008   = 0x00000400, /* Uses IEE 754-2008 NaN encoding */

  /* ABI flags */
  LIEF_EF_MIPS_ABI_O32    = 0x00001000, /* This file follows the first MIPS 32 bit ABI */
  LIEF_EF_MIPS_ABI_O64    = 0x00002000, /* O32 ABI extended for 64-bit architecture. */
  LIEF_EF_MIPS_ABI_EABI32 = 0x00003000, /* EABI in 32 bit mode. */
  LIEF_EF_MIPS_ABI_EABI64 = 0x00004000, /* EABI in 64 bit mode. */
  LIEF_EF_MIPS_ABI        = 0x0000f000, /* Mask for selecting EF_MIPS_ABI_ variant. */

  /* MIPS machine variant */
  LIEF_EF_MIPS_MACH_3900    = 0x00810000, /* Toshiba R3900 */
  LIEF_EF_MIPS_MACH_4010    = 0x00820000, /* LSI R4010 */
  LIEF_EF_MIPS_MACH_4100    = 0x00830000, /* NEC VR4100 */
  LIEF_EF_MIPS_MACH_4650    = 0x00850000, /* MIPS R4650 */
  LIEF_EF_MIPS_MACH_4120    = 0x00870000, /* NEC VR4120 */
  LIEF_EF_MIPS_MACH_4111    = 0x00880000, /* NEC VR4111/VR4181 */
  LIEF_EF_MIPS_MACH_SB1     = 0x008a0000, /* Broadcom SB-1 */
  LIEF_EF_MIPS_MACH_OCTEON  = 0x008b0000, /* Cavium Networks Octeon */
  LIEF_EF_MIPS_MACH_XLR     = 0x008c0000, /* RMI Xlr */
  LIEF_EF_MIPS_MACH_OCTEON2 = 0x008d0000, /* Cavium Networks Octeon2 */
  LIEF_EF_MIPS_MACH_OCTEON3 = 0x008e0000, /* Cavium Networks Octeon3 */
  LIEF_EF_MIPS_MACH_5400    = 0x00910000, /* NEC VR5400 */
  LIEF_EF_MIPS_MACH_5900    = 0x00920000, /* MIPS R5900 */
  LIEF_EF_MIPS_MACH_5500    = 0x00980000, /* NEC VR5500 */
  LIEF_EF_MIPS_MACH_9000    = 0x00990000, /* Unknown */
  LIEF_EF_MIPS_MACH_LS2E    = 0x00a00000, /* ST Microelectronics Loongson 2E */
  LIEF_EF_MIPS_MACH_LS2F    = 0x00a10000, /* ST Microelectronics Loongson 2F */
  LIEF_EF_MIPS_MACH_LS3A    = 0x00a20000, /* Loongson 3A */
  LIEF_EF_MIPS_MACH         = 0x00ff0000, /* EF_MIPS_MACH_xxx selection mask */

  /* ARCH_ASE */
  LIEF_EF_MIPS_MICROMIPS     = 0x02000000, /* microMIPS */
  LIEF_EF_MIPS_ARCH_ASE_M16  = 0x04000000, /* Has Mips-16 ISA extensions */
  LIEF_EF_MIPS_ARCH_ASE_MDMX = 0x08000000, /* Has MDMX multimedia extensions */
  LIEF_EF_MIPS_ARCH_ASE      = 0x0f000000, /* Mask for EF_MIPS_ARCH_ASE_xxx flags */

  /* ARCH */
  LIEF_EF_MIPS_ARCH_1    = 0x00000000, /* MIPS1 instruction set */
  LIEF_EF_MIPS_ARCH_2    = 0x10000000, /* MIPS2 instruction set */
  LIEF_EF_MIPS_ARCH_3    = 0x20000000, /* MIPS3 instruction set */
  LIEF_EF_MIPS_ARCH_4    = 0x30000000, /* MIPS4 instruction set */
  LIEF_EF_MIPS_ARCH_5    = 0x40000000, /* MIPS5 instruction set */
  LIEF_EF_MIPS_ARCH_32   = 0x50000000, /* MIPS32 instruction set per linux not elf.h */
  LIEF_EF_MIPS_ARCH_64   = 0x60000000, /* MIPS64 instruction set per linux not elf.h */
  LIEF_EF_MIPS_ARCH_32R2 = 0x70000000, /* mips32r2, mips32r3, mips32r5 */
  LIEF_EF_MIPS_ARCH_64R2 = 0x80000000, /* mips64r2, mips64r3, mips64r5 */
  LIEF_EF_MIPS_ARCH_32R6 = 0x90000000, /* mips32r6 */
  LIEF_EF_MIPS_ARCH_64R6 = 0xa0000000, /* mips64r6 */
  LIEF_EF_MIPS_ARCH      = 0xf0000000  /* Mask for applying EF_MIPS_ARCH_ variant */
};

/* Hexagon Specific e_flags */
/* Release 5 ABI */
enum LIEF_HEXAGON_EFLAGS {
  /* Object processor version flags, bits[3:0] */
  LIEF_EF_HEXAGON_MACH_V2      = 0x00000001,   /* Hexagon V2 */
  LIEF_EF_HEXAGON_MACH_V3      = 0x00000002,   /* Hexagon V3 */
  LIEF_EF_HEXAGON_MACH_V4      = 0x00000003,   /* Hexagon V4 */
  LIEF_EF_HEXAGON_MACH_V5      = 0x00000004,   /* Hexagon V5 */

  /* Highest ISA version flags */
  LIEF_EF_HEXAGON_ISA_MACH     = 0x00000000,   /* Same as specified in bits[3:0] */
  /* of e_flags */
  LIEF_EF_HEXAGON_ISA_V2       = 0x00000010,   /* Hexagon V2 ISA */
  LIEF_EF_HEXAGON_ISA_V3       = 0x00000020,   /* Hexagon V3 ISA */
  LIEF_EF_HEXAGON_ISA_V4       = 0x00000030,   /* Hexagon V4 ISA */
  LIEF_EF_HEXAGON_ISA_V5       = 0x00000040    /* Hexagon V5 ISA */
};


/* LoongArch Specific e_flags */
enum LIEF_LOONGARCH_EFLAGS {
  LIEF_EF_LOONGARCH_ABI_SOFT_FLOAT        = 0x1,
  LIEF_EF_LOONGARCH_ABI_SINGLE_FLOAT      = 0x2,
  LIEF_EF_LOONGARCH_ABI_DOUBLE_FLOAT      = 0x3
};

/** Special section indices. */
enum LIEF_SYMBOL_SECTION_INDEX {
  LIEF_SHN_UNDEF     = 0,      /**< Undefined, missing, irrelevant, or meaningless */
  LIEF_SHN_LORESERVE = 0xff00, /**< Lowest reserved index */
  LIEF_SHN_LOPROC    = 0xff00, /**< Lowest processor-specific index */
  LIEF_SHN_HIPROC    = 0xff1f, /**< Highest processor-specific index */
  LIEF_SHN_LOOS      = 0xff20, /**< Lowest operating system-specific index */
  LIEF_SHN_HIOS      = 0xff3f, /**< Highest operating system-specific index */
  LIEF_SHN_ABS       = 0xfff1, /**< Symbol has absolute value; does not need relocation */
  LIEF_SHN_COMMON    = 0xfff2, /**< FORTRAN COMMON or C external global variables */
  LIEF_SHN_XINDEX    = 0xffff, /**< Mark that the index is >= SHN_LORESERVE */
  LIEF_SHN_HIRESERVE = 0xffff  /**< Highest reserved index */
};

/** Section types. */
enum LIEF_ELF_SECTION_TYPES {
  LIEF_SHT_NULL                = 0,  /**< No associated section (inactive entry. */
  LIEF_SHT_PROGBITS            = 1,  /**< Program-defined contents. */
  LIEF_SHT_SYMTAB              = 2,  /**< Symbol table. */
  LIEF_SHT_STRTAB              = 3,  /**< String table. */
  LIEF_SHT_RELA                = 4,  /**< Relocation entries; explicit addends. */
  LIEF_SHT_HASH                = 5,  /**< Symbol hash table. */
  LIEF_SHT_DYNAMIC             = 6,  /**< Information for dynamic linking. */
  LIEF_SHT_NOTE                = 7,  /**< Information about the file. */
  LIEF_SHT_NOBITS              = 8,  /**< Data occupies no space in the file. */
  LIEF_SHT_REL                 = 9,  /**< Relocation entries; no explicit addends. */
  LIEF_SHT_SHLIB               = 10, /**< Reserved. */
  LIEF_SHT_DYNSYM              = 11, /**< Symbol table. */
  LIEF_SHT_INIT_ARRAY          = 14, /**< Pointers to initialization functions. */
  LIEF_SHT_FINI_ARRAY          = 15, /**< Pointers to termination functions. */
  LIEF_SHT_PREINIT_ARRAY       = 16, /**< Pointers to pre-init functions. */
  LIEF_SHT_GROUP               = 17, /**< Section group. */
  LIEF_SHT_SYMTAB_SHNDX        = 18, /**< Indices for SHN_XINDEX entries. */
  LIEF_SHT_LOOS                = 0x60000000, /**< Lowest operating system-specific type. */
  LIEF_SHT_ANDROID_REL         = 0x60000001, /**< Packed relocations (Android specific. */
  LIEF_SHT_ANDROID_RELA        = 0x60000002, /**< Packed relocations (Android specific. */
  LIEF_SHT_LLVM_ADDRSIG        = 0x6fff4c03, /**< This section is used to mark symbols as address-significant. */
  LIEF_SHT_RELR                = 0x6fffff00, /**< New relr relocations (Android specific. */
  LIEF_SHT_GNU_ATTRIBUTES      = 0x6ffffff5, /**< Object attributes. */
  LIEF_SHT_GNU_HASH            = 0x6ffffff6, /**< GNU-style hash table. */
  LIEF_SHT_GNU_verdef          = 0x6ffffffd, /**< GNU version definitions. */
  LIEF_SHT_GNU_verneed         = 0x6ffffffe, /**< GNU version references. */
  LIEF_SHT_GNU_versym          = 0x6fffffff, /**< GNU symbol versions table. */
  LIEF_SHT_HIOS                = 0x6fffffff, /**< Highest operating system-specific type. */
  LIEF_SHT_LOPROC              = 0x70000000, /**< Lowest processor arch-specific type. */
  LIEF_SHT_ARM_EXIDX           = 0x70000001U, /**< Exception Index table */
  LIEF_SHT_ARM_PREEMPTMAP      = 0x70000002U, /**< BPABI DLL dynamic linking pre-emption map */
  LIEF_SHT_ARM_ATTRIBUTES      = 0x70000003U, /**<  Object file compatibility attributes */
  LIEF_SHT_ARM_DEBUGOVERLAY    = 0x70000004U,
  LIEF_SHT_ARM_OVERLAYSECTION  = 0x70000005U,
  LIEF_SHT_HEX_ORDERED         = 0x70000000, /**< Link editor is to sort the entries in */

  /* this section based on their sizes */
  LIEF_SHT_X86_64_UNWIND       = 0x70000001, /**< Unwind information */
  LIEF_SHT_MIPS_REGINFO        = 0x70000006, /**< Register usage information */
  LIEF_SHT_MIPS_OPTIONS        = 0x7000000d, /**< General options */
  LIEF_SHT_MIPS_ABIFLAGS       = 0x7000002a, /**< ABI information. */

  LIEF_SHT_HIPROC              = 0x7fffffff, /**< Highest processor arch-specific type. */
  LIEF_SHT_LOUSER              = 0x80000000, /**< Lowest type reserved for applications. */
  LIEF_SHT_HIUSER              = 0xffffffff  /**< Highest type reserved for applications. */
};



/** Section flags. */
enum LIEF_ELF_SECTION_FLAGS {
  LIEF_SHF_NONE             = 0x0,
  LIEF_SHF_WRITE            = 0x1,         /**< Section data should be writable during execution. */
  LIEF_SHF_ALLOC            = 0x2,         /**< Section occupies memory during program execution. */
  LIEF_SHF_EXECINSTR        = 0x4,         /**< Section contains executable machine instructions. */
  LIEF_SHF_MERGE            = 0x10,        /**< The data in this section may be merged. */
  LIEF_SHF_STRINGS          = 0x20,        /**< The data in this section is null-terminated strings. */
  LIEF_SHF_INFO_LINK        = 0x40U,       /**< A field in this section holds a section header table index. */
  LIEF_SHF_LINK_ORDER       = 0x80U,       /**< Adds special ordering requirements for link editors. */
  LIEF_SHF_OS_NONCONFORMING = 0x100U,      /**< This section requires special OS-specific processing to avoid incorrect behavior */
  LIEF_SHF_GROUP            = 0x200U,      /**< This section is a member of a section group. */
  LIEF_SHF_TLS              = 0x400U,      /**< This section holds Thread-Local Storage. */
  LIEF_SHF_EXCLUDE          = 0x80000000U, /**< This section is excluded from the final executable or shared library. */
  /* Start of target-specific flags. */

  /* XCORE_SHF_CP_SECTION - All sections with the "c" flag are grouped
   * together by the linker to form the constant pool and the cp register is
   * set to the start of the constant pool by the boot code.
   */
  LIEF_XCORE_SHF_CP_SECTION = 0x800U,

  /* XCORE_SHF_DP_SECTION - All sections with the "d" flag are grouped
   * together by the linker to form the data section and the dp register is
   * set to the start of the section by the boot code.
   */
  LIEF_XCORE_SHF_DP_SECTION = 0x1000U,
  LIEF_SHF_MASKOS   = 0x0ff00000,
  LIEF_SHF_MASKPROC = 0xf0000000, /**< Bits indicating processor-specific flags. */

  /* If an object file section does not have this flag set, then it may not hold
   * more than 2GB and can be freely referred to in objects using smaller code
   * models. Otherwise, only objects using larger code models can refer to them.
   * For example, a medium code model object can refer to data in a section that
   * sets this flag besides being able to refer to data in a section that does
   * not set it; likewise, a small code model object can refer only to code in a
   * section that does not set this flag.
   */
  LIEF_SHF_X86_64_LARGE = 0x10000000,

  /* All sections with the GPREL flag are grouped into a global data area
   * for faster accesses.
   */
  LIEF_SHF_HEX_GPREL = 0x10000000,

  /* Section contains text/data which may be replicated in other sections.
   * Linker must retain only one copy.
   */
  LIEF_SHF_MIPS_NODUPES = 0x01000000,

  LIEF_SHF_MIPS_NAMES   = 0x02000000, /**< Linker must generate implicit hidden weak names. */
  LIEF_SHF_MIPS_LOCAL   = 0x04000000, /**< Section data local to process. */
  LIEF_SHF_MIPS_NOSTRIP = 0x08000000, /**< Do not strip this section. */
  LIEF_SHF_MIPS_GPREL   = 0x10000000, /**< Section must be part of global data area. */
  LIEF_SHF_MIPS_MERGE   = 0x20000000, /**< This section should be merged. */
  LIEF_SHF_MIPS_ADDR    = 0x40000000, /**< Address size to be inferred from section entry size. */
  LIEF_SHF_MIPS_STRING  = 0x80000000  /**< Section data is string data by default. */
};


/** Symbol bindings. */
enum LIEF_SYMBOL_BINDINGS {
  LIEF_STB_LOCAL      = 0,  /**< Local symbol, not visible outside obj file containing def */
  LIEF_STB_GLOBAL     = 1,  /**< Global symbol, visible to all object files being combined */
  LIEF_STB_WEAK       = 2,  /**< Weak symbol, like global but lower-precedence */
  LIEF_STB_GNU_UNIQUE = 10,
  LIEF_STB_LOOS       = 10, /**< Lowest operating system-specific binding type */
  LIEF_STB_HIOS       = 12, /**< Highest operating system-specific binding type */
  LIEF_STB_LOPROC     = 13, /**< Lowest processor-specific binding type */
  LIEF_STB_HIPROC     = 15  /**< Highest processor-specific binding type */
};


/* Symbol types. */
enum LIEF_ELF_SYMBOL_TYPES {
  LIEF_STT_NOTYPE    = 0,   /* Symbol's type is not specified */
  LIEF_STT_OBJECT    = 1,   /* Symbol is a data object (variable, array, etc. */
  LIEF_STT_FUNC      = 2,   /* Symbol is executable code (function, etc. */
  LIEF_STT_SECTION   = 3,   /* Symbol refers to a section */
  LIEF_STT_FILE      = 4,   /* Local, absolute symbol that refers to a file */
  LIEF_STT_COMMON    = 5,   /* An uninitialized common block */
  LIEF_STT_TLS       = 6,   /* Thread local data object */
  LIEF_STT_GNU_IFUNC = 10,  /* GNU indirect function */
  LIEF_STT_LOOS      = 10,  /* Lowest operating system-specific symbol type */
  LIEF_STT_HIOS      = 12,  /* Highest operating system-specific symbol type */
  LIEF_STT_LOPROC    = 13,  /* Lowest processor-specific symbol type */
  LIEF_STT_HIPROC    = 15   /* Highest processor-specific symbol type */
};

enum LIEF_ELF_SYMBOL_VISIBILITY {
  LIEF_STV_DEFAULT   = 0,  /* Visibility is specified by binding type */
  LIEF_STV_INTERNAL  = 1,  /* Defined by processor supplements */
  LIEF_STV_HIDDEN    = 2,  /* Not visible to other components */
  LIEF_STV_PROTECTED = 3   /* Visible in other components but not preemptable */
};


/** @brief Segment types. */
enum LIEF_SEGMENT_TYPES {
  LIEF_PT_NULL          = 0,          /**< Unused segment. */
  LIEF_PT_LOAD          = 1,          /**< Loadable segment. */
  LIEF_PT_DYNAMIC       = 2,          /**< Dynamic linking information. */
  LIEF_PT_INTERP        = 3,          /**< Interpreter pathname. */
  LIEF_PT_NOTE          = 4,          /**< Auxiliary information. */
  LIEF_PT_SHLIB         = 5,          /**< Reserved. */
  LIEF_PT_PHDR          = 6,          /**< The program header table itself. */
  LIEF_PT_TLS           = 7,          /**< The thread-local storage template. */
  LIEF_PT_LOOS          = 0x60000000, /**< Lowest operating system-specific pt entry type. */
  LIEF_PT_HIOS          = 0x6fffffff, /**< Highest operating system-specific pt entry type. */
  LIEF_PT_LOPROC        = 0x70000000, /**< Lowest processor-specific program hdr entry type. */
  LIEF_PT_HIPROC        = 0x7fffffff, /**< Highest processor-specific program hdr entry type. */

  /* x86-64 program header types. */
  /* These all contain stack unwind tables. */
  LIEF_PT_GNU_EH_FRAME  = 0x6474e550,
  LIEF_PT_SUNW_EH_FRAME = 0x6474e550,
  LIEF_PT_SUNW_UNWIND   = 0x6464e550,

  LIEF_PT_GNU_STACK     = 0x6474e551, /**< Indicates stack executability. */
  LIEF_PT_GNU_PROPERTY  = 0x6474e553, /**< GNU property */
  LIEF_PT_GNU_RELRO     = 0x6474e552, /**< Read-only after relocation. */

  /* ARM program header types. */
  LIEF_PT_ARM_ARCHEXT   = 0x70000000, /**< Platform architecture compatibility info */

  /* These all contain stack unwind tables. */
  LIEF_PT_ARM_EXIDX     = 0x70000001,
  LIEF_PT_ARM_UNWIND    = 0x70000001,

  /* MIPS program header types. */
  LIEF_PT_MIPS_REGINFO  = 0x70000000,  /**< Register usage information. */
  LIEF_PT_MIPS_RTPROC   = 0x70000001,  /**< Runtime procedure table. */
  LIEF_PT_MIPS_OPTIONS  = 0x70000002,  /**< Options segment. */
  LIEF_PT_MIPS_ABIFLAGS = 0x70000003   /**< Abiflags segment. */
};


/** Segment flags. */
enum LIEF_ELF_SEGMENT_FLAGS {
   LIEF_PF_NONE     = 0,
   LIEF_PF_X        = 1,         /**< Execute */
   LIEF_PF_W        = 2,         /**< Write */
   LIEF_PF_R        = 4,         /**< Read */
   LIEF_PF_MASKOS   = 0x0ff00000,/**< Bits for operating system-specific semantics. */
   LIEF_PF_MASKPROC = 0xf0000000 /**< Bits for processor-specific semantics. */
};


/** Dynamic table entry tags. */
enum LIEF_DYNAMIC_TAGS {
  LIEF_DT_NULL                       = 0,          /**< Marks end of dynamic array. */
  LIEF_DT_NEEDED                     = 1,          /**< String table offset of needed library. */
  LIEF_DT_PLTRELSZ                   = 2,          /**< Size of relocation entries in PLT. */
  LIEF_DT_PLTGOT                     = 3,          /**< Address associated with linkage table. */
  LIEF_DT_HASH                       = 4,          /**< Address of symbolic hash table. */
  LIEF_DT_STRTAB                     = 5,          /**< Address of dynamic string table. */
  LIEF_DT_SYMTAB                     = 6,          /**< Address of dynamic symbol table. */
  LIEF_DT_RELA                       = 7,          /**< Address of relocation table (Rela entries. */
  LIEF_DT_RELASZ                     = 8,          /**< Size of Rela relocation table. */
  LIEF_DT_RELAENT                    = 9,          /**< Size of a Rela relocation entry. */
  LIEF_DT_STRSZ                      = 10,         /**< Total size of the string table. */
  LIEF_DT_SYMENT                     = 11,         /**< Size of a symbol table entry. */
  LIEF_DT_INIT                       = 12,         /**< Address of initialization function. */
  LIEF_DT_FINI                       = 13,         /**< Address of termination function. */
  LIEF_DT_SONAME                     = 14,         /**< String table offset of a shared objects name. */
  LIEF_DT_RPATH                      = 15,         /**< String table offset of library search path. */
  LIEF_DT_SYMBOLIC                   = 16,         /**< Changes symbol resolution algorithm. */
  LIEF_DT_REL                        = 17,         /**< Address of relocation table (Rel entries. */
  LIEF_DT_RELSZ                      = 18,         /**< Size of Rel relocation table. */
  LIEF_DT_RELENT                     = 19,         /**< Size of a Rel relocation entry. */
  LIEF_DT_PLTREL                     = 20,         /**< Type of relocation entry used for linking. */
  LIEF_DT_DEBUG                      = 21,         /**< Reserved for debugger. */
  LIEF_DT_TEXTREL                    = 22,         /**< Relocations exist for non-writable segments. */
  LIEF_DT_JMPREL                     = 23,         /**< Address of relocations associated with PLT. */
  LIEF_DT_BIND_NOW                   = 24,         /**< Process all relocations before execution. */
  LIEF_DT_INIT_ARRAY                 = 25,         /**< Pointer to array of initialization functions. */
  LIEF_DT_FINI_ARRAY                 = 26,         /**< Pointer to array of termination functions. */
  LIEF_DT_INIT_ARRAYSZ               = 27,         /**< Size of DT_INIT_ARRAY. */
  LIEF_DT_FINI_ARRAYSZ               = 28,         /**< Size of DT_FINI_ARRAY. */
  LIEF_DT_RUNPATH                    = 29,         /**< String table offset of lib search path. */
  LIEF_DT_FLAGS                      = 30,         /**< Flags. */
  LIEF_DT_ENCODING                   = 32,         /**< Values from here to DT_LOOS follow the rules for the interpretation of the d_un union. */

  LIEF_DT_PREINIT_ARRAY              = 32,         /**< Pointer to array of preinit functions. */
  LIEF_DT_PREINIT_ARRAYSZ            = 33,         /**< Size of the DT_PREINIT_ARRAY array. */

  LIEF_DT_LOOS                       = 0x60000000, /**< Start of environment specific tags. */
  LIEF_DT_HIOS                       = 0x6FFFFFFF, /**< End of environment specific tags. */
  LIEF_DT_LOPROC                     = 0x70000000, /**< Start of processor specific tags. */
  LIEF_DT_HIPROC                     = 0x7FFFFFFF, /**< End of processor specific tags. */

  LIEF_DT_GNU_HASH                   = 0x6FFFFEF5, /**< Reference to the GNU hash table. */
  LIEF_DT_RELACOUNT                  = 0x6FFFFFF9, /**< ELF32_Rela count. */
  LIEF_DT_RELCOUNT                   = 0x6FFFFFFA, /**< ELF32_Rel count. */

  LIEF_DT_FLAGS_1                    = 0x6FFFFFFB, /**< Flags_1. */
  LIEF_DT_VERSYM                     = 0x6FFFFFF0, /**< The address of .gnu.version section. */
  LIEF_DT_VERDEF                     = 0x6FFFFFFC, /**< The address of the version definition table. */
  LIEF_DT_VERDEFNUM                  = 0x6FFFFFFD, /**< The number of entries in DT_VERDEF. */
  LIEF_DT_VERNEED                    = 0x6FFFFFFE, /**< The address of the version Dependency table. */
  LIEF_DT_VERNEEDNUM                 = 0x6FFFFFFF, /**< The number of entries in DT_VERNEED. */

  /* Mips specific dynamic table entry tags. */
  LIEF_DT_MIPS_RLD_VERSION           = 0x70000001, /**< 32 bit version number for runtime linker interface. */
  LIEF_DT_MIPS_TIME_STAMP            = 0x70000002, /**< Time stamp. */
  LIEF_DT_MIPS_ICHECKSUM             = 0x70000003, /**< Checksum of external strings and common sizes. */
  LIEF_DT_MIPS_IVERSION              = 0x70000004, /**< Index of version string in string table. */
  LIEF_DT_MIPS_FLAGS                 = 0x70000005, /**< 32 bits of flags. */
  LIEF_DT_MIPS_BASE_ADDRESS          = 0x70000006, /**< Base address of the segment. */
  LIEF_DT_MIPS_MSYM                  = 0x70000007, /**< Address of .msym section. */
  LIEF_DT_MIPS_CONFLICT              = 0x70000008, /**< Address of .conflict section. */
  LIEF_DT_MIPS_LIBLIST               = 0x70000009, /**< Address of .liblist section. */
  LIEF_DT_MIPS_LOCAL_GOTNO           = 0x7000000a, /**< Number of local global offset table entries. */
  LIEF_DT_MIPS_CONFLICTNO            = 0x7000000b, /**< Number of entries in the .conflict section. */
  LIEF_DT_MIPS_LIBLISTNO             = 0x70000010, /**< Number of entries in the .liblist section. */
  LIEF_DT_MIPS_SYMTABNO              = 0x70000011, /**< Number of entries in the .dynsym section. */
  LIEF_DT_MIPS_UNREFEXTNO            = 0x70000012, /**< Index of first external dynamic symbol not referenced locally. */
  LIEF_DT_MIPS_GOTSYM                = 0x70000013, /**< Index of first dynamic symbol in global offset table. */
  LIEF_DT_MIPS_HIPAGENO              = 0x70000014, /**< Number of page table entries in global offset table. */
  LIEF_DT_MIPS_RLD_MAP               = 0x70000016, /**< Address of run time loader map, used for debugging. */
  LIEF_DT_MIPS_DELTA_CLASS           = 0x70000017, /**< Delta C++ class definition. */
  LIEF_DT_MIPS_DELTA_CLASS_NO        = 0x70000018, /**< Number of entries in DT_MIPS_DELTA_CLASS. */
  LIEF_DT_MIPS_DELTA_INSTANCE        = 0x70000019, /**< Delta C++ class instances. */
  LIEF_DT_MIPS_DELTA_INSTANCE_NO     = 0x7000001A, /**< Number of entries in DT_MIPS_DELTA_INSTANCE. */
  LIEF_DT_MIPS_DELTA_RELOC           = 0x7000001B, /**< Delta relocations. */
  LIEF_DT_MIPS_DELTA_RELOC_NO        = 0x7000001C, /**< Number of entries in DT_MIPS_DELTA_RELOC. */
  LIEF_DT_MIPS_DELTA_SYM             = 0x7000001D, /**< Delta symbols that Delta relocations refer to. */
  LIEF_DT_MIPS_DELTA_SYM_NO          = 0x7000001E, /**< Number of entries in DT_MIPS_DELTA_SYM. */
  LIEF_DT_MIPS_DELTA_CLASSSYM        = 0x70000020, /**< Delta symbols that hold class declarations. */
  LIEF_DT_MIPS_DELTA_CLASSSYM_NO     = 0x70000021, /**< Number of entries in DT_MIPS_DELTA_CLASSSYM. */
  LIEF_DT_MIPS_CXX_FLAGS             = 0x70000022, /**< Flags indicating information about C++ flavor. */
  LIEF_DT_MIPS_PIXIE_INIT            = 0x70000023, /**< Pixie information. */
  LIEF_DT_MIPS_SYMBOL_LIB            = 0x70000024, /**< Address of .MIPS.symlib */
  LIEF_DT_MIPS_LOCALPAGE_GOTIDX      = 0x70000025, /**< The GOT index of the first PTE for a segment */
  LIEF_DT_MIPS_LOCAL_GOTIDX          = 0x70000026, /**< The GOT index of the first PTE for a local symbol */
  LIEF_DT_MIPS_HIDDEN_GOTIDX         = 0x70000027, /**< The GOT index of the first PTE for a hidden symbol */
  LIEF_DT_MIPS_PROTECTED_GOTIDX      = 0x70000028, /**< The GOT index of the first PTE for a protected symbol */
  LIEF_DT_MIPS_OPTIONS               = 0x70000029, /**< Address of `.MIPS.options'. */
  LIEF_DT_MIPS_INTERFACE             = 0x7000002A, /**< Address of `.interface'. */
  LIEF_DT_MIPS_DYNSTR_ALIGN          = 0x7000002B, /**< Unknown. */
  LIEF_DT_MIPS_INTERFACE_SIZE        = 0x7000002C, /**< Size of the .interface section. */
  LIEF_DT_MIPS_RLD_TEXT_RESOLVE_ADDR = 0x7000002D, /**< Size of rld_text_resolve function stored in the GOT. */
  LIEF_DT_MIPS_PERF_SUFFIX           = 0x7000002E, /**< Default suffix of DSO to be added by rld on dlopen( calls. */
  LIEF_DT_MIPS_COMPACT_SIZE          = 0x7000002F, /**< Size of compact relocation section (O32. */
  LIEF_DT_MIPS_GP_VALUE              = 0x70000030, /**< GP value for auxiliary GOTs. */
  LIEF_DT_MIPS_AUX_DYNAMIC           = 0x70000031, /**< Address of auxiliary .dynamic. */
  LIEF_DT_MIPS_PLTGOT                = 0x70000032, /**< Address of the base of the PLTGOT. */
  LIEF_DT_MIPS_RWPLT                 = 0x70000034, /**< Points to the base of a writable PLT. */

  /* Android specific dynamic table entry tags. */
  LIEF_DT_ANDROID_REL_OFFSET         = 0x6000000D, /**< The offset of packed relocation data (older version < M) (Android specific. */
  LIEF_DT_ANDROID_REL_SIZE           = 0x6000000E, /**< The size of packed relocation data in bytes (older version < M) (Android specific. */
  LIEF_DT_ANDROID_REL                = 0x6000000F, /**< The offset of packed relocation data (Android specific. */
  LIEF_DT_ANDROID_RELSZ              = 0x60000010, /**< The size of packed relocation data in bytes (Android specific. */
  LIEF_DT_ANDROID_RELA               = 0x60000011, /**< The offset of packed relocation data (Android specific. */
  LIEF_DT_ANDROID_RELASZ             = 0x60000012, /**< The size of packed relocation data in bytes (Android specific. */
  LIEF_DT_RELR                       = 0x6FFFE000, /**< The offset of new relr relocation data (Android specific. */
  LIEF_DT_RELRSZ                     = 0x6FFFE001, /**< The size of nre relr relocation data in bytes (Android specific. */
  LIEF_DT_RELRENT                    = 0x6FFFE003, /**< The size of a new relr relocation entry (Android specific. */
  LIEF_DT_RELRCOUNT                  = 0x6FFFE005 /**< Specifies the relative count of new relr relocation entries (Android specific. */
};

/** DT_FLAGS and DT_FLAGS_1 values. */
enum LIEF_DYNAMIC_FLAGS {
  LIEF_DF_ORIGIN       = 0x00000001, /**< The object may reference $ORIGIN. */
  LIEF_DF_SYMBOLIC     = 0x00000002, /**< Search the shared lib before searching the exe. */
  LIEF_DF_TEXTREL      = 0x00000004, /**< Relocations may modify a non-writable segment. */
  LIEF_DF_BIND_NOW     = 0x00000008, /**< Process all relocations on load. */
  LIEF_DF_STATIC_TLS   = 0x00000010, /**< Reject attempts to load dynamically. */
};

enum LIEF_DYNAMIC_FLAGS_1 {
  LIEF_DF_1_NOW        = 0x00000001, /**< Set RTLD_NOW for this object. */
  LIEF_DF_1_GLOBAL     = 0x00000002, /**< Set RTLD_GLOBAL for this object. */
  LIEF_DF_1_GROUP      = 0x00000004, /**< Set RTLD_GROUP for this object. */
  LIEF_DF_1_NODELETE   = 0x00000008, /**< Set RTLD_NODELETE for this object. */
  LIEF_DF_1_LOADFLTR   = 0x00000010, /**< Trigger filtee loading at runtime. */
  LIEF_DF_1_INITFIRST  = 0x00000020, /**< Set RTLD_INITFIRST for this object. */
  LIEF_DF_1_NOOPEN     = 0x00000040, /**< Set RTLD_NOOPEN for this object. */
  LIEF_DF_1_ORIGIN     = 0x00000080, /**< $ORIGIN must be handled. */
  LIEF_DF_1_DIRECT     = 0x00000100, /**< Direct binding enabled. */
  LIEF_DF_1_TRANS      = 0x00000200,
  LIEF_DF_1_INTERPOSE  = 0x00000400, /**< Object is used to interpose. */
  LIEF_DF_1_NODEFLIB   = 0x00000800, /**< Ignore default lib search path. */
  LIEF_DF_1_NODUMP     = 0x00001000, /**< Object can't be dldump'ed. */
  LIEF_DF_1_CONFALT    = 0x00002000, /**< Configuration alternative created. */
  LIEF_DF_1_ENDFILTEE  = 0x00004000, /**< Filtee terminates filters search. */
  LIEF_DF_1_DISPRELDNE = 0x00008000, /**< Disp reloc applied at build time. */
  LIEF_DF_1_DISPRELPND = 0x00010000, /**< Disp reloc applied at run-time. */
  LIEF_DF_1_NODIRECT   = 0x00020000, /**< Object has no-direct binding. */
  LIEF_DF_1_IGNMULDEF  = 0x00040000,
  LIEF_DF_1_NOKSYMS    = 0x00080000,
  LIEF_DF_1_NOHDR      = 0x00100000,
  LIEF_DF_1_EDITED     = 0x00200000, /**< Object is modified after built. */
  LIEF_DF_1_NORELOC    = 0x00400000,
  LIEF_DF_1_SYMINTPOSE = 0x00800000, /**< Object has individual interposers. */
  LIEF_DF_1_GLOBAUDIT  = 0x01000000, /**< Global auditing required. */
  LIEF_DF_1_SINGLETON  = 0x02000000,  /**< Singleton symbols are used. */
  LIEF_DF_1_PIE        = 0x08000000  /**< Singleton symbols are used. */
};

/* DT_MIPS_FLAGS values. */
enum {
  LIEF_RHF_NONE                    = 0x00000000, /* No flags. */
  LIEF_RHF_QUICKSTART              = 0x00000001, /* Uses shortcut pointers. */
  LIEF_RHF_NOTPOT                  = 0x00000002, /* Hash size is not a power of two. */
  LIEF_RHS_NO_LIBRARY_REPLACEMENT  = 0x00000004, /* Ignore LD_LIBRARY_PATH. */
  LIEF_RHF_NO_MOVE                 = 0x00000008, /* DSO address may not be relocated. */
  LIEF_RHF_SGI_ONLY                = 0x00000010, /* SGI specific features. */
  LIEF_RHF_GUARANTEE_INIT          = 0x00000020, /* Guarantee that .init will finish */
  /* executing before any non-init */
  /* code in DSO is called. */
  LIEF_RHF_DELTA_C_PLUS_PLUS       = 0x00000040, /* Contains Delta C++ code. */
  LIEF_RHF_GUARANTEE_START_INIT    = 0x00000080, /* Guarantee that .init will start */
  /* executing before any non-init */
  /* code in DSO is called. */
  LIEF_RHF_PIXIE                   = 0x00000100, /* Generated by pixie. */
  LIEF_RHF_DEFAULT_DELAY_LOAD      = 0x00000200, /* Delay-load DSO by default. */
  LIEF_RHF_REQUICKSTART            = 0x00000400, /* Object may be requickstarted */
  LIEF_RHF_REQUICKSTARTED          = 0x00000800, /* Object has been requickstarted */
  LIEF_RHF_CORD                    = 0x00001000, /* Generated by cord. */
  LIEF_RHF_NO_UNRES_UNDEF          = 0x00002000, /* Object contains no unresolved */
  /* undef symbols. */
  LIEF_RHF_RLD_ORDER_SAFE          = 0x00004000  /* Symbol table is in a safe order. */
};

/** ElfXX_VerDef structure version (GNU versioning) */
enum {
  LIEF_VER_DEF_NONE    = 0,
  LIEF_VER_DEF_CURRENT = 1
};

/** VerDef Flags (ElfXX_VerDef::vd_flags) */
enum {
  LIEF_VER_FLG_BASE = 0x1,
  LIEF_VER_FLG_WEAK = 0x2,
  LIEF_VER_FLG_INFO = 0x4
};

/** Special constants for the version table. (SHT_GNU_versym/.gnu.version) */
enum {
  LIEF_VER_NDX_LOCAL  = 0,      /**< Unversioned local symbol */
  LIEF_VER_NDX_GLOBAL = 1,      /**< Unversioned global symbol */
  LIEF_VERSYM_VERSION = 0x7fff, /**< Version Index mask */
  LIEF_VERSYM_HIDDEN  = 0x8000  /**< Hidden bit (non-default version */
};

/** ElfXX_VerNeed structure version (GNU versioning) */
enum {
  LIEF_VER_NEED_NONE = 0,
  LIEF_VER_NEED_CURRENT = 1
};

enum LIEF_AUX_TYPE {
   LIEF_AT_NULL          = 0,     /**< End of vector */
   LIEF_AT_IGNORE        = 1,     /**< Entry should be ignored */
   LIEF_AT_EXECFD        = 2,     /**< File descriptor of program */
   LIEF_AT_PHDR          = 3,     /**< Program headers for program */
   LIEF_AT_PHENT         = 4,     /**< Size of program header entry */
   LIEF_AT_PHNUM         = 5,     /**< Number of program headers */
   LIEF_AT_PAGESZ        = 6,     /**< System page size */
   LIEF_AT_BASE          = 7,     /**< Base address of interpreter */
   LIEF_AT_FLAGS         = 8,     /**< Flags */
   LIEF_AT_ENTRY         = 9,     /**< Entry point of program */
   LIEF_AT_NOTELF        = 10,    /**< Program is not ELF */
   LIEF_AT_UID           = 11,    /**< Real uid */
   LIEF_AT_EUID          = 12,    /**< Effective uid */
   LIEF_AT_GID           = 13,    /**< Real gid */
   LIEF_AT_EGID          = 14,    /**< Effective gid */
   LIEF_AT_CLKTCK        = 17,    /**< Frequency of times( */

   /* Some more special a_type values describing the hardware.  */

   LIEF_AT_PLATFORM      = 15,    /**< String identifying platform.  */
   LIEF_AT_HWCAP         = 16,    /**< Machine dependent hints about processor capabilities.  */

   /* This entry gives some information about the FPU initialization
      performed by the kernel. */

   LIEF_AT_FPUCW        = 18,    /**< Used FPU control word.  */

   /* Cache block sizes. */
   LIEF_AT_DCACHEBSIZE   = 19,    /**< Data cache block size.  */
   LIEF_AT_ICACHEBSIZE   = 20,    /**< Instruction cache block size.  */
   LIEF_AT_UCACHEBSIZE   = 21,    /**< Unified cache block size.  */

   /* A special ignored value for PPC, used by the kernel to control the
      interpretation of the AUXV. Must be > 16.  */

   LIEF_AT_IGNOREPPC     = 22,    /**< Entry should be ignored.  */
   LIEF_AT_SECURE        = 23,    /**< Boolean, was exec setuid-like?  */
   LIEF_AT_BASE_PLATFORM = 24,    /**< String identifying real platforms.*/
   LIEF_AT_RANDOM        = 25,    /**< Address of 16 random bytes.  */
   LIEF_AT_HWCAP2        = 26,    /**< Extension of AT_HWCAP.  */
   LIEF_AT_EXECFN        = 31,    /**< Filename of executable.  */

   /* Pointer to the global system page used for system calls and other
      nice things. */
   LIEF_AT_SYSINFO       = 32,
   LIEF_AT_SYSINFO_EHDR  = 33,

   /* Shapes of the caches.  Bits 0-3 contains associativity; bits 4-7 contains
      log2 of line size; mask those to get cache size.  */
   LIEF_AT_L1I_CACHESHAPE  = 34,
   LIEF_AT_L1D_CACHESHAPE  = 35,
   LIEF_AT_L2_CACHESHAPE   = 36,
   LIEF_AT_L3_CACHESHAPE   = 37
};

/** Methods that can be used by the LIEF::ELF::Parser
    to count the number of dynamic symbols */
enum LIEF_DYNSYM_COUNT_METHODS {
  LIEF_COUNT_AUTO        = 0, /**< Automatic detection */
  LIEF_COUNT_SECTION     = 1, /**< Count based on sections (not very reliable */
  LIEF_COUNT_HASH        = 2, /**< Count based on hash table (reliable */
  LIEF_COUNT_RELOCATIONS = 3, /**< Count based on PLT/GOT relocations (very reliable but not accurate */
};

enum LIEF_NOTE_TYPES {
  LIEF_NT_UNKNOWN                  = 0,
  LIEF_NT_GNU_ABI_TAG              = 1,
  LIEF_NT_GNU_HWCAP                = 2,
  LIEF_NT_GNU_BUILD_ID             = 3,
  LIEF_NT_GNU_GOLD_VERSION         = 4,
  LIEF_NT_GNU_PROPERTY_TYPE_0      = 5,
  LIEF_NT_GNU_BUILD_ATTRIBUTE_OPEN = 0x100,
  LIEF_NT_GNU_BUILD_ATTRIBUTE_FUNC = 0x101,
  LIEF_NT_CRASHPAD                 = 0x4f464e49,
};

enum LIEF_NOTE_TYPES_CORE {
  LIEF_NT_CORE_UNKNOWN     = 0,
  LIEF_NT_PRSTATUS         = 1,
  LIEF_NT_PRFPREG          = 2,
  LIEF_NT_PRPSINFO         = 3,
  LIEF_NT_TASKSTRUCT       = 4,
  LIEF_NT_AUXV             = 6,
  LIEF_NT_SIGINFO          = 0x53494749,
  LIEF_NT_FILE             = 0x46494c45,
  LIEF_NT_PRXFPREG         = 0x46e62b7f,

  LIEF_NT_ARM_VFP          = 0x400,
  LIEF_NT_ARM_TLS          = 0x401,
  LIEF_NT_ARM_HW_BREAK     = 0x402,
  LIEF_NT_ARM_HW_WATCH     = 0x403,
  LIEF_NT_ARM_SYSTEM_CALL  = 0x404,
  LIEF_NT_ARM_SVE          = 0x405,

  LIEF_NT_386_TLS          = 0x200,
  LIEF_NT_386_IOPERM       = 0x201,
  LIEF_NT_386_XSTATE       = 0x202,

};


enum LIEF_NOTE_ABIS {
  LIEF_ELF_NOTE_UNKNOWN     = ~(unsigned int)(0),
  LIEF_ELF_NOTE_OS_LINUX    = 0,
  LIEF_ELF_NOTE_OS_GNU      = 1,
  LIEF_ELF_NOTE_OS_SOLARIS2 = 2,
  LIEF_ELF_NOTE_OS_FREEBSD  = 3,
  LIEF_ELF_NOTE_OS_NETBSD   = 4,
  LIEF_ELF_NOTE_OS_SYLLABLE = 5,
};

enum LIEF_RELOCATION_PURPOSES {
  LIEF_RELOC_PURPOSE_NONE    = 0,
  LIEF_RELOC_PURPOSE_PLTGOT  = 1,
  LIEF_RELOC_PURPOSE_DYNAMIC = 2,
  LIEF_RELOC_PURPOSE_OBJECT  = 3,
};

#ifdef __cplusplus
}
#endif


#endif

```

`KDemu/include/LIEF/LIEF/ELF/enums.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_ENUMS_H
#define LIEF_ELF_ENUMS_H
#include "LIEF/enums.hpp"
#include <cstdint>
#include <cstddef>

namespace LIEF {
namespace ELF {

/**
 * @brief Machine architectures
 * See current registered ELF machine architectures at:
 * http://www.sco.com/developers/gabi/latest/ch4.eheader.html
 */
enum class ARCH {
  NONE          = 0,  /**< No machine */
  M32           = 1,  /**< AT&T WE 32100 */
  SPARC         = 2,  /**< SPARC */
  I386          = 3,  /**< Intel 386 */
  M68K          = 4,  /**< Motorola 68000 */
  M88K          = 5,  /**< Motorola 88000 */
  IAMCU         = 6,  /**< Intel MCU */
  I860          = 7,  /**< Intel 80860 */
  MIPS          = 8,  /**< MIPS R3000 */
  S370          = 9,  /**< IBM System/370 */
  MIPS_RS3_LE   = 10, /**< MIPS RS3000 Little-endian */
  PARISC        = 15, /**< Hewlett-Packard PA-RISC */
  VPP500        = 17, /**< Fujitsu VPP500 */
  SPARC32PLUS   = 18, /**< Enhanced instruction set SPARC */
  I60           = 19, /**< Intel 80960 */
  PPC           = 20, /**< PowerPC */
  PPC64         = 21, /**< PowerPC64 */
  S390          = 22, /**< IBM System/390 */
  SPU           = 23, /**< IBM SPU/SPC */
  V800          = 36, /**< NEC V800 */
  FR20          = 37, /**< Fujitsu FR20 */
  RH32          = 38, /**< TRW RH-32 */
  RCE           = 39, /**< Motorola RCE */
  ARM           = 40, /**< ARM */
  ALPHA         = 41, /**< DEC Alpha */
  SH            = 42, /**< Hitachi SH */
  SPARCV9       = 43, /**< SPARC V9 */
  TRICORE       = 44, /**< Siemens TriCore */
  ARC           = 45, /**< Argonaut RISC Core */
  H8_300        = 46, /**< Hitachi H8/300 */
  H8_300H       = 47, /**< Hitachi H8/300H */
  H8S           = 48, /**< Hitachi H8S */
  H8_500        = 49, /**< Hitachi H8/500 */
  IA_64         = 50, /**< Intel IA-64 processor architecture */
  MIPS_X        = 51, /**< Stanford MIPS-X */
  COLDFIRE      = 52, /**< Motorola ColdFire */
  M68HC12       = 53, /**< Motorola M68HC12 */
  MMA           = 54, /**< Fujitsu MMA Multimedia Accelerator */
  PCP           = 55, /**< Siemens PCP */
  NCPU          = 56, /**< Sony nCPU embedded RISC processor */
  NDR1          = 57, /**< Denso NDR1 microprocessor */
  STARCORE      = 58, /**< Motorola Star*Core processor */
  ME16          = 59, /**< Toyota ME16 processor */
  ST100         = 60, /**< STMicroelectronics ST100 processor */
  TINYJ         = 61, /**< Advanced Logic Corp. TinyJ embedded processor family */
  X86_64        = 62, /**< AMD x86-64 architecture */
  PDSP          = 63, /**< Sony DSP Processor */
  PDP10         = 64, /**< Digital Equipment Corp. PDP-10 */
  PDP11         = 65, /**< Digital Equipment Corp. PDP-11 */
  FX66          = 66, /**< Siemens FX66 microcontroller */
  ST9PLUS       = 67, /**< STMicroelectronics ST9+ 8/16 bit microcontroller */
  ST7           = 68, /**< STMicroelectronics ST7 8-bit microcontroller */
  M68HC16       = 69, /**< Motorola MC68HC16 Microcontroller */
  M68HC11       = 70, /**< Motorola MC68HC11 Microcontroller */
  M68HC08       = 71, /**< Motorola MC68HC08 Microcontroller */
  M68HC05       = 72, /**< Motorola MC68HC05 Microcontroller */
  SVX           = 73, /**< Silicon Graphics SVx */
  ST19          = 74, /**< STMicroelectronics ST19 8-bit microcontroller */
  VAX           = 75, /**< Digital VAX */
  CRIS          = 76, /**< Axis Communications 32-bit embedded processor */
  JAVELIN       = 77, /**< Infineon Technologies 32-bit embedded processor */
  FIREPATH      = 78, /**< Element 14 64-bit DSP Processor */
  ZSP           = 79, /**< LSI Logic 16-bit DSP Processor */
  MMIX          = 80, /**< Donald Knuth's educational 64-bit processor */
  HUANY         = 81, /**< Harvard University machine-independent object files */
  PRISM         = 82, /**< SiTera Prism */
  AVR           = 83, /**< Atmel AVR 8-bit microcontroller */
  FR30          = 84, /**< Fujitsu FR30 */
  D10V          = 85, /**< Mitsubishi D10V */
  D30V          = 86, /**< Mitsubishi D30V */
  V850          = 87, /**< NEC v850 */
  M32R          = 88, /**< Mitsubishi M32R */
  MN10300       = 89, /**< Matsushita MN10300 */
  MN10200       = 90, /**< Matsushita MN10200 */
  PJ            = 91, /**< picoJava */
  OPENRISC      = 92, /**< OpenRISC 32-bit embedded processor */
  ARC_COMPACT   = 93, /**< ARC International ARCompact processor (old spelling/synonym: EM_ARC_A5) */
  XTENSA        = 94,  /**< Tensilica Xtensa Architecture */
  VIDEOCORE     = 95,  /**< Alphamosaic VideoCore processor */
  TMM_GPP       = 96,  /**< Thompson Multimedia General Purpose Processor */
  NS32K         = 97,  /**< National Semiconductor 32000 series */
  TPC           = 98,  /**< Tenor Network TPC processor */
  SNP1K         = 99,  /**< Trebia SNP 1000 processor */
  ST200         = 100, /**< STMicroelectronics (www.st.com) ST200 */
  IP2K          = 101, /**< Ubicom IP2xxx microcontroller family */
  MAX           = 102, /**< MAX Processor */
  CR            = 103, /**< National Semiconductor CompactRISC microprocessor */
  F2MC16        = 104, /**< Fujitsu F2MC16 */
  MSP430        = 105, /**< Texas Instruments embedded microcontroller msp430 */
  BLACKFIN      = 106, /**< Analog Devices Blackfin (DSP) processor */
  SE_C33        = 107, /**< S1C33 Family of Seiko Epson processors */
  SEP           = 108, /**< Sharp embedded microprocessor */
  ARCA          = 109, /**< Arca RISC Microprocessor */
  UNICORE       = 110, /**< Microprocessor series from PKU-Unity Ltd. and MPRC of Peking University */
  EXCESS        = 111, /**< eXcess: 16/32/64-bit configurable embedded CPU */
  DXP           = 112, /**< Icera Semiconductor Inc. Deep Execution Processor */
  ALTERA_NIOS2  = 113, /**< Altera Nios II soft-core processor */
  CRX           = 114, /**< National Semiconductor CompactRISC CRX */
  XGATE         = 115, /**< Motorola XGATE embedded processor */
  C166          = 116, /**< Infineon C16x/XC16x processor */
  M16C          = 117, /**< Renesas M16C series microprocessors */
  DSPIC30F      = 118, /**< Microchip Technology dsPIC30F Digital Signal */
  CE            = 119, /**< Freescale Communication Engine RISC core */
  M32C          = 120, /**< Renesas M32C series microprocessors */
  TSK3000       = 131, /**< Altium TSK3000 core */
  RS08          = 132, /**< Freescale RS08 embedded processor */
  SHARC         = 133, /**< Analog Devices SHARC family of 32-bit DSP */
  ECOG2         = 134, /**< Cyan Technology eCOG2 microprocessor */
  SCORE7        = 135, /**< Sunplus S+core7 RISC processor */
  DSP24         = 136, /**< New Japan Radio (NJR) 24-bit DSP Processor */
  VIDEOCORE3    = 137, /**< Broadcom VideoCore III processor */
  LATTICEMICO32 = 138, /**< RISC processor for Lattice FPGA architecture */
  SE_C17        = 139, /**< Seiko Epson C17 family */
  TI_C6000      = 140, /**< The Texas Instruments TMS320C6000 DSP family */
  TI_C2000      = 141, /**< The Texas Instruments TMS320C2000 DSP family */
  TI_C5500      = 142, /**< The Texas Instruments TMS320C55x DSP family */
  MMDSP_PLUS    = 160, /**< STMicroelectronics 64bit VLIW Data Signal Processor */
  CYPRESS_M8C   = 161, /**< Cypress M8C microprocessor */
  R32C          = 162, /**< Renesas R32C series microprocessors */
  TRIMEDIA      = 163, /**< NXP Semiconductors TriMedia architecture family */
  HEXAGON       = 164, /**< Qualcomm Hexagon processor */
  M8051          = 165, /**< Intel 8051 and variants */
  STXP7X        = 166, /**< STMicroelectronics STxP7x family of configurable */
  NDS32         = 167, /* Andes Technology compact code size embedded RISC */
  ECOG1         = 168, /**< Cyan Technology eCOG1X family */
  ECOG1X        = 168, /**< Cyan Technology eCOG1X family */
  MAXQ30        = 169, /**< Dallas Semiconductor MAXQ30 Core Micro-controllers */
  XIMO16        = 170, /**< New Japan Radio (NJR) 16-bit DSP Processor */
  MANIK         = 171, /**< M2000 Reconfigurable RISC Microprocessor */
  CRAYNV2       = 172, /**< Cray Inc. NV2 vector architecture */
  RX            = 173, /**< Renesas RX family */
  METAG         = 174, /**< Imagination Technologies META processor */
  MCST_ELBRUS   = 175, /**< MCST Elbrus general purpose hardware architecture */
  ECOG16        = 176, /**< Cyan Technology eCOG16 family */
  CR16          = 177, /**< National Semiconductor CompactRISC CR16 16-bit */
  ETPU          = 178, /**< Freescale Extended Time Processing Unit */
  SLE9X         = 179, /**< Infineon Technologies SLE9X core */
  L10M          = 180, /**< Intel L10M */
  K10M          = 181, /**< Intel K10M */
  AARCH64       = 183, /**< ARM AArch64 */
  AVR32         = 185, /**< Atmel Corporation 32-bit microprocessor family */
  STM8          = 186, /**< STMicroeletronics STM8 8-bit microcontroller */
  TILE64        = 187, /**< Tilera TILE64 multicore architecture family */
  TILEPRO       = 188, /**< Tilera TILEPro multicore architecture family */
  CUDA          = 190, /**< NVIDIA CUDA architecture */
  TILEGX        = 191, /**< Tilera TILE-Gx multicore architecture family */
  CLOUDSHIELD   = 192, /**< CloudShield architecture family */
  COREA_1ST     = 193, /**< KIPO-KAIST Core-A 1st generation processor family */
  COREA_2ND     = 194, /**< KIPO-KAIST Core-A 2nd generation processor family */
  ARC_COMPACT2  = 195, /**< Synopsys ARCompact V2 */
  OPEN8         = 196, /**< Open8 8-bit RISC soft processor core */
  RL78          = 197, /**< Renesas RL78 family */
  VIDEOCORE5    = 198, /**< Broadcom VideoCore V processor */
  M78KOR        = 199, /**< Renesas 78KOR family */
  M56800EX      = 200, /**< Freescale 56800EX Digital Signal Controller (DSC) */
  BA1           = 201, /**< Beyond BA1 CPU architecture */
  BA2           = 202, /**< Beyond BA2 CPU architecture */
  XCORE         = 203, /**< XMOS xCORE processor family */
  MCHP_PIC      = 204, /**< Microchip 8-bit PIC(r) family */
  INTEL205      = 205, /**< Reserved by Intel */
  INTEL206      = 206, /**< Reserved by Intel */
  INTEL207      = 207, /**< Reserved by Intel */
  INTEL208      = 208, /**< Reserved by Intel */
  INTEL209      = 209, /**< Reserved by Intel */
  KM32          = 210, /**< KM211 KM32 32-bit processor */
  KMX32         = 211, /**< KM211 KMX32 32-bit processor */
  KMX16         = 212, /**< KM211 KMX16 16-bit processor */
  KMX8          = 213, /**< KM211 KMX8 8-bit processor */
  KVARC         = 214, /**< KM211 KVARC processor */
  CDP           = 215, /**< Paneve CDP architecture family */
  COGE          = 216, /**< Cognitive Smart Memory Processor */
  COOL          = 217, /**< iCelero CoolEngine */
  NORC          = 218, /**< Nanoradio Optimized RISC */
  CSR_KALIMBA   = 219, /**< CSR Kalimba architecture family */
  AMDGPU        = 224, /**< AMD GPU architecture */
  RISCV         = 243, /**< RISC-V */
  BPF           = 247,  /**< eBPF Filter */
  LOONGARCH     = 258  /**< LoongArch */
};

}
}

#endif

```

`KDemu/include/LIEF/LIEF/ELF/hash.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_HASH_H
#define LIEF_ELF_HASH_H

#include "LIEF/visibility.h"
#include "LIEF/hash.hpp"

namespace LIEF {
namespace ELF {

class Binary;
class Header;
class Section;
class Segment;
class DynamicEntry;
class DynamicEntryArray;
class DynamicEntryLibrary;
class DynamicEntryRpath;
class DynamicEntryRunPath;
class DynamicSharedObject;
class DynamicEntryFlags;
class Symbol;
class Relocation;
class SymbolVersion;
class SymbolVersionAux;
class SymbolVersionAuxRequirement;
class SymbolVersionRequirement;
class SymbolVersionDefinition;
class Note;
class NoteDetails;
class AndroidNote;
class NoteAbi;
class NoteGnuProperty;
class CorePrPsInfo;
class CorePrStatus;
class CoreAuxv;
class CoreSigInfo;
class CoreFile;
class GnuHash;
class SysvHash;

//! Class which implements a visitor to compute
//! a **deterministic** hash for LIEF ELF objects
class LIEF_API Hash : public LIEF::Hash {
  public:
  static LIEF::Hash::value_type hash(const Object& obj);

  public:
  using LIEF::Hash::Hash;
  using LIEF::Hash::visit;

  public:
  void visit(const Binary& binary)                  override;
  void visit(const Header& header)                  override;
  void visit(const Section& section)                override;
  void visit(const Segment& segment)                override;
  void visit(const DynamicEntry& entry)             override;
  void visit(const DynamicEntryArray& entry)        override;
  void visit(const DynamicEntryLibrary& entry)      override;
  void visit(const DynamicEntryRpath& entry)        override;
  void visit(const DynamicEntryRunPath& entry)      override;
  void visit(const DynamicSharedObject& entry)      override;
  void visit(const DynamicEntryFlags& entry)        override;
  void visit(const Symbol& symbol)                  override;
  void visit(const Relocation& relocation)          override;
  void visit(const SymbolVersion& sv)               override;
  void visit(const SymbolVersionAux& sv)            override;
  void visit(const SymbolVersionAuxRequirement& sv) override;
  void visit(const SymbolVersionRequirement& svr)   override;
  void visit(const SymbolVersionDefinition& svd)    override;
  void visit(const Note& note)                      override;
  void visit(const AndroidIdent& note)              override;
  void visit(const QNXStack& note)                  override;
  void visit(const NoteAbi& note)                   override;
  void visit(const NoteGnuProperty& note)           override;
  void visit(const CorePrPsInfo& pinfo)             override;
  void visit(const CorePrStatus& pstatus)           override;
  void visit(const CoreAuxv& auxv)                  override;
  void visit(const CoreSigInfo& siginfo)            override;
  void visit(const CoreFile& file)                  override;
  void visit(const GnuHash& gnuhash)                override;
  void visit(const SysvHash& sysvhash)              override;

  ~Hash() override;
};

}
}

#endif

```

`KDemu/include/LIEF/LIEF/ELF/json.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_PUBLIC_JSON_H
#define LIEF_ELF_PUBLIC_JSON_H

#include "LIEF/visibility.h"
#include <string>

namespace LIEF {
class Object;

namespace ELF {

LIEF_API std::string to_json(const Object& v);

}
}
#endif

```

`KDemu/include/LIEF/LIEF/ELF/undef.h`:

```h
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_UNDEF_H
#define LIEF_ELF_UNDEF_H

#ifdef PT_LOAD
#pragma message("LIEF will disable #define enums. Please use LIEF_ELF_XXXX or LIEF::ELF::XXXX instead!")
#endif

#undef EI_MAG0
#undef EI_MAG1
#undef EI_MAG2
#undef EI_MAG3
#undef EI_CLASS
#undef EI_DATA
#undef EI_VERSION
#undef EI_OSABI
#undef EI_ABIVERSION
#undef EI_PAD
#undef EI_NIDENT


#undef ET_NONE
#undef ET_REL
#undef ET_EXEC
#undef ET_DYN
#undef ET_CORE
#undef ET_LOPROC
#undef ET_HIPROC


#undef EV_NONE
#undef EV_CURRENT



#undef EM_NONE
#undef EM_M32
#undef EM_SPARC
#undef EM_386
#undef EM_68K
#undef EM_88K
#undef EM_IAMCU
#undef EM_860
#undef EM_MIPS
#undef EM_S370
#undef EM_MIPS_RS3_LE
#undef EM_PARISC
#undef EM_VPP500
#undef EM_SPARC32PLUS
#undef EM_960
#undef EM_PPC
#undef EM_PPC64
#undef EM_S390
#undef EM_SPU
#undef EM_V800
#undef EM_FR20
#undef EM_RH32
#undef EM_RCE
#undef EM_ARM
#undef EM_ALPHA
#undef EM_SH
#undef EM_SPARCV9
#undef EM_TRICORE
#undef EM_ARC
#undef EM_H8_300
#undef EM_H8_300H
#undef EM_H8S
#undef EM_H8_500
#undef EM_IA_64
#undef EM_MIPS_X
#undef EM_COLDFIRE
#undef EM_68HC12
#undef EM_MMA
#undef EM_PCP
#undef EM_NCPU
#undef EM_NDR1
#undef EM_STARCORE
#undef EM_ME16
#undef EM_ST100
#undef EM_TINYJ
#undef EM_X86_64
#undef EM_PDSP
#undef EM_PDP10
#undef EM_PDP11
#undef EM_FX66
#undef EM_ST9PLUS
#undef EM_ST7
#undef EM_68HC16
#undef EM_68HC11
#undef EM_68HC08
#undef EM_68HC05
#undef EM_SVX
#undef EM_ST19
#undef EM_VAX
#undef EM_CRIS
#undef EM_JAVELIN
#undef EM_FIREPATH
#undef EM_ZSP
#undef EM_MMIX
#undef EM_HUANY
#undef EM_PRISM
#undef EM_AVR
#undef EM_FR30
#undef EM_D10V
#undef EM_D30V
#undef EM_V850
#undef EM_M32R
#undef EM_MN10300
#undef EM_MN10200
#undef EM_PJ
#undef EM_OPENRISC
#undef EM_ARC_COMPACT
#undef EM_XTENSA
#undef EM_VIDEOCORE
#undef EM_TMM_GPP
#undef EM_NS32K
#undef EM_TPC
#undef EM_SNP1K
#undef EM_ST200
#undef EM_IP2K
#undef EM_MAX
#undef EM_CR
#undef EM_F2MC16
#undef EM_MSP430
#undef EM_BLACKFIN
#undef EM_SE_C33
#undef EM_SEP
#undef EM_ARCA
#undef EM_UNICORE
#undef EM_EXCESS
#undef EM_DXP
#undef EM_ALTERA_NIOS2
#undef EM_CRX
#undef EM_XGATE
#undef EM_C166
#undef EM_M16C
#undef EM_DSPIC30F

#undef EM_CE
#undef EM_M32C
#undef EM_TSK3000
#undef EM_RS08
#undef EM_SHARC

#undef EM_ECOG2
#undef EM_SCORE7
#undef EM_DSP24
#undef EM_VIDEOCORE3
#undef EM_LATTICEMICO32
#undef EM_SE_C17
#undef EM_TI_C6000
#undef EM_TI_C2000
#undef EM_TI_C5500
#undef EM_MMDSP_PLUS
#undef EM_CYPRESS_M8C
#undef EM_R32C
#undef EM_TRIMEDIA
#undef EM_HEXAGON
#undef EM_8051
#undef EM_STXP7X

#undef EM_NDS32

#undef EM_ECOG1
#undef EM_ECOG1X
#undef EM_MAXQ30
#undef EM_XIMO16
#undef EM_MANIK
#undef EM_CRAYNV2
#undef EM_RX
#undef EM_METAG

#undef EM_MCST_ELBRUS
#undef EM_ECOG16
#undef EM_CR16

#undef EM_ETPU
#undef EM_SLE9X
#undef EM_L10M
#undef EM_K10M
#undef EM_AARCH64
#undef EM_AVR32
#undef EM_STM8
#undef EM_TILE64
#undef EM_TILEPRO
#undef EM_CUDA
#undef EM_TILEGX
#undef EM_CLOUDSHIELD
#undef EM_COREA_1ST
#undef EM_COREA_2ND
#undef EM_ARC_COMPACT2
#undef EM_OPEN8
#undef EM_RL78
#undef EM_VIDEOCORE5
#undef EM_78KOR
#undef EM_56800EX
#undef EM_BA1
#undef EM_BA2
#undef EM_XCORE
#undef EM_MCHP_PIC
#undef EM_INTEL205
#undef EM_INTEL206
#undef EM_INTEL207
#undef EM_INTEL208
#undef EM_INTEL209
#undef EM_KM32
#undef EM_KMX32
#undef EM_KMX16
#undef EM_KMX8
#undef EM_KVARC
#undef EM_CDP
#undef EM_COGE
#undef EM_COOL
#undef EM_NORC
#undef EM_CSR_KALIMBA
#undef EM_AMDGPU
#undef EM_RISCV
#undef EM_BPF
#undef EM_LOONGARCH


#undef ELFCLASSNONE
#undef ELFCLASS32
#undef ELFCLASS64

#undef ELFDATANONE
#undef ELFDATA2LSB
#undef ELFDATA2MSB

#undef ELFOSABI_SYSTEMV
#undef ELFOSABI_HPUX
#undef ELFOSABI_NETBSD
#undef ELFOSABI_GNU
#undef ELFOSABI_LINUX
#undef ELFOSABI_HURD
#undef ELFOSABI_SOLARIS
#undef ELFOSABI_AIX
#undef ELFOSABI_IRIX
#undef ELFOSABI_FREEBSD
#undef ELFOSABI_TRU64
#undef ELFOSABI_MODESTO
#undef ELFOSABI_OPENBSD
#undef ELFOSABI_OPENVMS
#undef ELFOSABI_NSK
#undef ELFOSABI_AROS
#undef ELFOSABI_FENIXOS
#undef ELFOSABI_CLOUDABI
#undef ELFOSABI_C6000_ELFABI
#undef ELFOSABI_AMDGPU_HSA
#undef ELFOSABI_C6000_LINUX
#undef ELFOSABI_ARM
#undef ELFOSABI_STANDALONE

#undef EF_PPC64_ABI
#undef EF_ARM_SOFT_FLOAT
#undef EF_ARM_VFP_FLOAT
#undef EF_ARM_EABI_UNKNOWN
#undef EF_ARM_EABI_VER1
#undef EF_ARM_EABI_VER2
#undef EF_ARM_EABI_VER3
#undef EF_ARM_EABI_VER4
#undef EF_ARM_EABI_VER5
#undef EF_ARM_EABIMASK

#undef EF_MIPS_NOREORDER
#undef EF_MIPS_PIC
#undef EF_MIPS_CPIC
#undef EF_MIPS_ABI2
#undef EF_MIPS_32BITMODE

#undef EF_MIPS_FP64

#undef EF_MIPS_NAN2008


#undef EF_MIPS_ABI_O32
#undef EF_MIPS_ABI_O64
#undef EF_MIPS_ABI_EABI32
#undef EF_MIPS_ABI_EABI64
#undef EF_MIPS_ABI


#undef EF_MIPS_MACH_3900
#undef EF_MIPS_MACH_4010
#undef EF_MIPS_MACH_4100
#undef EF_MIPS_MACH_4650
#undef EF_MIPS_MACH_4120
#undef EF_MIPS_MACH_4111
#undef EF_MIPS_MACH_SB1
#undef EF_MIPS_MACH_OCTEON
#undef EF_MIPS_MACH_XLR
#undef EF_MIPS_MACH_OCTEON2
#undef EF_MIPS_MACH_OCTEON3
#undef EF_MIPS_MACH_5400
#undef EF_MIPS_MACH_5900
#undef EF_MIPS_MACH_5500
#undef EF_MIPS_MACH_9000
#undef EF_MIPS_MACH_LS2E
#undef EF_MIPS_MACH_LS2F
#undef EF_MIPS_MACH_LS3A
#undef EF_MIPS_MACH


#undef EF_MIPS_MICROMIPS
#undef EF_MIPS_ARCH_ASE_M16
#undef EF_MIPS_ARCH_ASE_MDMX
#undef EF_MIPS_ARCH_ASE


#undef EF_MIPS_ARCH_1
#undef EF_MIPS_ARCH_2
#undef EF_MIPS_ARCH_3
#undef EF_MIPS_ARCH_4
#undef EF_MIPS_ARCH_5
#undef EF_MIPS_ARCH_32
#undef EF_MIPS_ARCH_64
#undef EF_MIPS_ARCH_32R2
#undef EF_MIPS_ARCH_64R2
#undef EF_MIPS_ARCH_32R6
#undef EF_MIPS_ARCH_64R6
#undef EF_MIPS_ARCH


#undef EF_HEXAGON_MACH_V2
#undef EF_HEXAGON_MACH_V3
#undef EF_HEXAGON_MACH_V4
#undef EF_HEXAGON_MACH_V5

#undef EF_HEXAGON_ISA_MACH
#undef EF_HEXAGON_ISA_V2
#undef EF_HEXAGON_ISA_V3
#undef EF_HEXAGON_ISA_V4
#undef EF_HEXAGON_ISA_V5


#undef EF_LOONGARCH_ABI_SOFT_FLOAT
#undef EF_LOONGARCH_ABI_SINGLE_FLOAT
#undef EF_LOONGARCH_ABI_DOUBLE_FLOAT


#undef SHN_UNDEF
#undef SHN_LORESERVE
#undef SHN_LOPROC
#undef SHN_HIPROC
#undef SHN_LOOS
#undef SHN_HIOS
#undef SHN_ABS
#undef SHN_COMMON
#undef SHN_XINDEX
#undef SHN_HIRESERVE


#undef SHT_NULL
#undef SHT_PROGBITS
#undef SHT_SYMTAB
#undef SHT_STRTAB
#undef SHT_RELA
#undef SHT_HASH
#undef SHT_DYNAMIC
#undef SHT_NOTE
#undef SHT_NOBITS
#undef SHT_REL
#undef SHT_SHLIB
#undef SHT_DYNSYM
#undef SHT_INIT_ARRAY
#undef SHT_FINI_ARRAY
#undef SHT_PREINIT_ARRAY
#undef SHT_GROUP
#undef SHT_SYMTAB_SHNDX
#undef SHT_LOOS
#undef SHT_GNU_ATTRIBUTES
#undef SHT_GNU_HASH
#undef SHT_GNU_verdef
#undef SHT_GNU_verneed
#undef SHT_GNU_versym
#undef SHT_HIOS
#undef SHT_LOPROC
#undef SHT_ARM_EXIDX
#undef SHT_ARM_PREEMPTMAP
#undef SHT_ARM_ATTRIBUTES
#undef SHT_ARM_DEBUGOVERLAY
#undef SHT_ARM_OVERLAYSECTION
#undef SHT_HEX_ORDERED

#undef SHT_X86_64_UNWIND
#undef SHT_MIPS_REGINFO
#undef SHT_MIPS_OPTIONS
#undef SHT_MIPS_ABIFLAGS

#undef SHT_HIPROC
#undef SHT_LOUSER
#undef SHT_HIUSER

#undef SHT_ANDROID_REL
#undef SHT_ANDROID_RELA
#undef SHT_LLVM_ADDRSIG
#undef SHT_RELR

#undef SHF_NONE
#undef SHF_WRITE
#undef SHF_ALLOC
#undef SHF_EXECINSTR
#undef SHF_MERGE
#undef SHF_STRINGS
#undef SHF_INFO_LINK
#undef SHF_LINK_ORDER
#undef SHF_OS_NONCONFORMING
#undef SHF_GROUP
#undef SHF_TLS
#undef SHF_EXCLUDE
#undef XCORE_SHF_CP_SECTION
#undef XCORE_SHF_DP_SECTION
#undef SHF_MASKOS
#undef SHF_MASKPROC
#undef SHF_X86_64_LARGE
#undef SHF_HEX_GPREL
#undef SHF_MIPS_NODUPES

#undef SHF_MIPS_NAMES
#undef SHF_MIPS_LOCAL
#undef SHF_MIPS_NOSTRIP
#undef SHF_MIPS_GPREL
#undef SHF_MIPS_MERGE
#undef SHF_MIPS_ADDR
#undef SHF_MIPS_STRING

#undef STB_LOCAL
#undef STB_GLOBAL
#undef STB_WEAK
#undef STB_GNU_UNIQUE
#undef STB_LOOS
#undef STB_HIOS
#undef STB_LOPROC
#undef STB_HIPROC

#undef STT_NOTYPE
#undef STT_OBJECT
#undef STT_FUNC
#undef STT_SECTION
#undef STT_FILE
#undef STT_COMMON
#undef STT_TLS
#undef STT_GNU_IFUNC
#undef STT_LOOS
#undef STT_HIOS
#undef STT_LOPROC
#undef STT_HIPROC

#undef STV_DEFAULT
#undef STV_INTERNAL
#undef STV_HIDDEN
#undef STV_PROTECTED

#undef PT_NULL
#undef PT_LOAD
#undef PT_DYNAMIC
#undef PT_INTERP
#undef PT_NOTE
#undef PT_SHLIB
#undef PT_PHDR
#undef PT_TLS
#undef PT_LOOS
#undef PT_HIOS
#undef PT_LOPROC
#undef PT_HIPROC

#undef PT_GNU_EH_FRAME
#undef PT_SUNW_EH_FRAME
#undef PT_SUNW_UNWIND

#undef PT_GNU_STACK
#undef PT_GNU_RELRO

#undef PT_ARM_ARCHEXT

#undef PT_ARM_EXIDX
#undef PT_ARM_UNWIND

#undef PT_MIPS_REGINFO
#undef PT_MIPS_RTPROC
#undef PT_MIPS_OPTIONS
#undef PT_MIPS_ABIFLAGS


#undef PF_NONE
#undef PF_X
#undef PF_W
#undef PF_R
#undef PF_MASKOS
#undef PF_MASKPROC

#undef DT_NULL
#undef DT_NEEDED
#undef DT_PLTRELSZ
#undef DT_PLTGOT
#undef DT_HASH
#undef DT_STRTAB
#undef DT_SYMTAB
#undef DT_RELA
#undef DT_RELASZ
#undef DT_RELAENT
#undef DT_STRSZ
#undef DT_SYMENT
#undef DT_INIT
#undef DT_FINI
#undef DT_SONAME
#undef DT_RPATH
#undef DT_SYMBOLIC
#undef DT_REL
#undef DT_RELSZ
#undef DT_RELENT
#undef DT_PLTREL
#undef DT_DEBUG
#undef DT_TEXTREL
#undef DT_JMPREL
#undef DT_BIND_NOW
#undef DT_INIT_ARRAY
#undef DT_FINI_ARRAY
#undef DT_INIT_ARRAYSZ
#undef DT_FINI_ARRAYSZ
#undef DT_RUNPATH
#undef DT_FLAGS
#undef DT_ENCODING

#undef DT_PREINIT_ARRAY
#undef DT_PREINIT_ARRAYSZ

#undef DT_LOOS
#undef DT_HIOS
#undef DT_LOPROC
#undef DT_HIPROC

#undef DT_GNU_HASH
#undef DT_RELACOUNT
#undef DT_RELCOUNT

#undef DT_FLAGS_1
#undef DT_VERSYM
#undef DT_VERDEF
#undef DT_VERDEFNUM
#undef DT_VERNEED
#undef DT_VERNEEDNUM

#undef DT_MIPS_RLD_VERSION
#undef DT_MIPS_TIME_STAMP
#undef DT_MIPS_ICHECKSUM
#undef DT_MIPS_IVERSION
#undef DT_MIPS_FLAGS
#undef DT_MIPS_BASE_ADDRESS
#undef DT_MIPS_MSYM
#undef DT_MIPS_CONFLICT
#undef DT_MIPS_LIBLIST
#undef DT_MIPS_LOCAL_GOTNO
#undef DT_MIPS_CONFLICTNO
#undef DT_MIPS_LIBLISTNO
#undef DT_MIPS_SYMTABNO
#undef DT_MIPS_UNREFEXTNO
#undef DT_MIPS_GOTSYM
#undef DT_MIPS_HIPAGENO
#undef DT_MIPS_RLD_MAP
#undef DT_MIPS_DELTA_CLASS
#undef DT_MIPS_DELTA_CLASS_NO
#undef DT_MIPS_DELTA_INSTANCE
#undef DT_MIPS_DELTA_INSTANCE_NO
#undef DT_MIPS_DELTA_RELOC
#undef DT_MIPS_DELTA_RELOC_NO
#undef DT_MIPS_DELTA_SYM
#undef DT_MIPS_DELTA_SYM_NO
#undef DT_MIPS_DELTA_CLASSSYM
#undef DT_MIPS_DELTA_CLASSSYM_NO
#undef DT_MIPS_CXX_FLAGS
#undef DT_MIPS_PIXIE_INIT
#undef DT_MIPS_SYMBOL_LIB
#undef DT_MIPS_LOCALPAGE_GOTIDX
#undef DT_MIPS_LOCAL_GOTIDX
#undef DT_MIPS_HIDDEN_GOTIDX
#undef DT_MIPS_PROTECTED_GOTIDX
#undef DT_MIPS_OPTIONS
#undef DT_MIPS_INTERFACE
#undef DT_MIPS_DYNSTR_ALIGN
#undef DT_MIPS_INTERFACE_SIZE
#undef DT_MIPS_RLD_TEXT_RESOLVE_ADDR
#undef DT_MIPS_PERF_SUFFIX
#undef DT_MIPS_COMPACT_SIZE
#undef DT_MIPS_GP_VALUE
#undef DT_MIPS_AUX_DYNAMIC
#undef DT_MIPS_PLTGOT
#undef DT_MIPS_RWPLT

#undef DT_ANDROID_REL_OFFSET
#undef DT_ANDROID_REL_SIZE
#undef DT_ANDROID_REL
#undef DT_ANDROID_RELSZ
#undef DT_ANDROID_RELA
#undef DT_ANDROID_RELASZ
#undef DT_RELR
#undef DT_RELRSZ
#undef DT_RELRENT
#undef DT_RELRCOUNT

#undef DF_ORIGIN
#undef DF_SYMBOLIC
#undef DF_TEXTREL
#undef DF_BIND_NOW
#undef DF_STATIC_TLS

#undef DF_1_NOW
#undef DF_1_GLOBAL
#undef DF_1_GROUP
#undef DF_1_NODELETE
#undef DF_1_LOADFLTR
#undef DF_1_INITFIRST
#undef DF_1_NOOPEN
#undef DF_1_ORIGIN
#undef DF_1_DIRECT
#undef DF_1_TRANS
#undef DF_1_INTERPOSE
#undef DF_1_NODEFLIB
#undef DF_1_NODUMP
#undef DF_1_CONFALT
#undef DF_1_ENDFILTEE
#undef DF_1_DISPRELDNE
#undef DF_1_DISPRELPND
#undef DF_1_NODIRECT
#undef DF_1_IGNMULDEF
#undef DF_1_NOKSYMS
#undef DF_1_NOHDR
#undef DF_1_EDITED
#undef DF_1_NORELOC
#undef DF_1_SYMINTPOSE
#undef DF_1_GLOBAUDIT
#undef DF_1_SINGLETON
#undef DF_1_PIE

#undef RHF_NONE
#undef RHF_QUICKSTART
#undef RHF_NOTPOT
#undef RHS_NO_LIBRARY_REPLACEMENT
#undef RHF_NO_MOVE
#undef RHF_SGI_ONLY
#undef RHF_GUARANTEE_INIT
#undef RHF_DELTA_C_PLUS_PLUS
#undef RHF_GUARANTEE_START_INIT
#undef RHF_PIXIE
#undef RHF_DEFAULT_DELAY_LOAD
#undef RHF_REQUICKSTART
#undef RHF_REQUICKSTARTED
#undef RHF_CORD
#undef RHF_NO_UNRES_UNDEF
#undef RHF_RLD_ORDER_SAFE

#undef VER_DEF_NONE
#undef VER_DEF_CURRENT

#undef VER_FLG_BASE
#undef VER_FLG_WEAK
#undef VER_FLG_INFO

#undef VER_NDX_LOCAL
#undef VER_NDX_GLOBAL
#undef VERSYM_VERSION
#undef VERSYM_HIDDEN

#undef VER_NEED_NONE
#undef VER_NEED_CURRENT
#undef COUNT_AUTO
#undef COUNT_SECTION
#undef COUNT_HASH
#undef COUNT_RELOCATIONS

#undef NT_ARM_VFP
#undef NT_ARM_TLS
#undef NT_ARM_HW_BREAK
#undef NT_ARM_HW_WATCH
#undef NT_ARM_SYSTEM_CALL
#undef NT_ARM_SVE

#undef NT_386_TLS
#undef NT_386_IOPERM

#undef NT_UNKNOWN
#undef NT_GNU_ABI_TAG
#undef NT_GNU_HWCAP
#undef NT_GNU_BUILD_ID
#undef NT_GNU_GOLD_VERSION
#undef NT_GNU_BUILD_ATTRIBUTE_OPEN
#undef NT_GNU_BUILD_ATTRIBUTE_FUNC
#undef NT_PRSTATUS
#undef NT_PRFPREG
#undef NT_PRPSINFO
#undef NT_TASKSTRUCT
#undef NT_AUXV
#undef NT_SIGINFO
#undef NT_FILE
#undef NT_PRXFPREG

#undef ELF_NOTE_UNKNOWN
#undef ELF_NOTE_OS_LINUX
#undef ELF_NOTE_OS_GNU
#undef ELF_NOTE_OS_SOLARIS2
#undef ELF_NOTE_OS_FREEBSD
#undef ELF_NOTE_OS_NETBSD
#undef ELF_NOTE_OS_SYLLABLE


#undef RELOC_PURPOSE_NONE
#undef RELOC_PURPOSE_PLTGOT
#undef RELOC_PURPOSE_DYNAMIC
#undef RELOC_PURPOSE_OBJECT

#undef R_AARCH64_NONE

#undef R_AARCH64_ABS64
#undef R_AARCH64_ABS32
#undef R_AARCH64_ABS16
#undef R_AARCH64_PREL64
#undef R_AARCH64_PREL32
#undef R_AARCH64_PREL16

#undef R_AARCH64_MOVW_UABS_G0
#undef R_AARCH64_MOVW_UABS_G0_NC
#undef R_AARCH64_MOVW_UABS_G1
#undef R_AARCH64_MOVW_UABS_G1_NC
#undef R_AARCH64_MOVW_UABS_G2
#undef R_AARCH64_MOVW_UABS_G2_NC
#undef R_AARCH64_MOVW_UABS_G3
#undef R_AARCH64_MOVW_SABS_G0
#undef R_AARCH64_MOVW_SABS_G1
#undef R_AARCH64_MOVW_SABS_G2

#undef R_AARCH64_LD_PREL_LO19
#undef R_AARCH64_ADR_PREL_LO21
#undef R_AARCH64_ADR_PREL_PG_HI21
#undef R_AARCH64_ADR_PREL_PG_HI21_NC
#undef R_AARCH64_ADD_ABS_LO12_NC
#undef R_AARCH64_LDST8_ABS_LO12_NC

#undef R_AARCH64_TSTBR14
#undef R_AARCH64_CONDBR19
#undef R_AARCH64_JUMP26
#undef R_AARCH64_CALL26

#undef R_AARCH64_LDST16_ABS_LO12_NC
#undef R_AARCH64_LDST32_ABS_LO12_NC
#undef R_AARCH64_LDST64_ABS_LO12_NC

#undef R_AARCH64_MOVW_PREL_G0
#undef R_AARCH64_MOVW_PREL_G0_NC
#undef R_AARCH64_MOVW_PREL_G1
#undef R_AARCH64_MOVW_PREL_G1_NC
#undef R_AARCH64_MOVW_PREL_G2
#undef R_AARCH64_MOVW_PREL_G2_NC
#undef R_AARCH64_MOVW_PREL_G3

#undef R_AARCH64_LDST128_ABS_LO12_NC

#undef R_AARCH64_MOVW_GOTOFF_G0
#undef R_AARCH64_MOVW_GOTOFF_G0_NC
#undef R_AARCH64_MOVW_GOTOFF_G1
#undef R_AARCH64_MOVW_GOTOFF_G1_NC
#undef R_AARCH64_MOVW_GOTOFF_G2
#undef R_AARCH64_MOVW_GOTOFF_G2_NC
#undef R_AARCH64_MOVW_GOTOFF_G3

#undef R_AARCH64_GOTREL64
#undef R_AARCH64_GOTREL32

#undef R_AARCH64_GOT_LD_PREL19
#undef R_AARCH64_LD64_GOTOFF_LO15
#undef R_AARCH64_ADR_GOT_PAGE
#undef R_AARCH64_LD64_GOT_LO12_NC
#undef R_AARCH64_LD64_GOTPAGE_LO15

#undef R_AARCH64_TLSGD_ADR_PREL21
#undef R_AARCH64_TLSGD_ADR_PAGE21
#undef R_AARCH64_TLSGD_ADD_LO12_NC
#undef R_AARCH64_TLSGD_MOVW_G1
#undef R_AARCH64_TLSGD_MOVW_G0_NC

#undef R_AARCH64_TLSLD_ADR_PREL21
#undef R_AARCH64_TLSLD_ADR_PAGE21
#undef R_AARCH64_TLSLD_ADD_LO12_NC
#undef R_AARCH64_TLSLD_MOVW_G1
#undef R_AARCH64_TLSLD_MOVW_G0_NC
#undef R_AARCH64_TLSLD_LD_PREL19
#undef R_AARCH64_TLSLD_MOVW_DTPREL_G2
#undef R_AARCH64_TLSLD_MOVW_DTPREL_G1
#undef R_AARCH64_TLSLD_MOVW_DTPREL_G1_NC
#undef R_AARCH64_TLSLD_MOVW_DTPREL_G0
#undef R_AARCH64_TLSLD_MOVW_DTPREL_G0_NC
#undef R_AARCH64_TLSLD_ADD_DTPREL_HI12
#undef R_AARCH64_TLSLD_ADD_DTPREL_LO12
#undef R_AARCH64_TLSLD_ADD_DTPREL_LO12_NC
#undef R_AARCH64_TLSLD_LDST8_DTPREL_LO12
#undef R_AARCH64_TLSLD_LDST8_DTPREL_LO12_NC
#undef R_AARCH64_TLSLD_LDST16_DTPREL_LO12
#undef R_AARCH64_TLSLD_LDST16_DTPREL_LO12_NC
#undef R_AARCH64_TLSLD_LDST32_DTPREL_LO12
#undef R_AARCH64_TLSLD_LDST32_DTPREL_LO12_NC
#undef R_AARCH64_TLSLD_LDST64_DTPREL_LO12
#undef R_AARCH64_TLSLD_LDST64_DTPREL_LO12_NC

#undef R_AARCH64_TLSIE_MOVW_GOTTPREL_G1
#undef R_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC
#undef R_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21
#undef R_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC
#undef R_AARCH64_TLSIE_LD_GOTTPREL_PREL19

#undef R_AARCH64_TLSLE_MOVW_TPREL_G2
#undef R_AARCH64_TLSLE_MOVW_TPREL_G1
#undef R_AARCH64_TLSLE_MOVW_TPREL_G1_NC
#undef R_AARCH64_TLSLE_MOVW_TPREL_G0
#undef R_AARCH64_TLSLE_MOVW_TPREL_G0_NC
#undef R_AARCH64_TLSLE_ADD_TPREL_HI12
#undef R_AARCH64_TLSLE_ADD_TPREL_LO12
#undef R_AARCH64_TLSLE_ADD_TPREL_LO12_NC
#undef R_AARCH64_TLSLE_LDST8_TPREL_LO12
#undef R_AARCH64_TLSLE_LDST8_TPREL_LO12_NC
#undef R_AARCH64_TLSLE_LDST16_TPREL_LO12
#undef R_AARCH64_TLSLE_LDST16_TPREL_LO12_NC
#undef R_AARCH64_TLSLE_LDST32_TPREL_LO12
#undef R_AARCH64_TLSLE_LDST32_TPREL_LO12_NC
#undef R_AARCH64_TLSLE_LDST64_TPREL_LO12
#undef R_AARCH64_TLSLE_LDST64_TPREL_LO12_NC

#undef R_AARCH64_TLSDESC_LD_PREL19
#undef R_AARCH64_TLSDESC_ADR_PREL21
#undef R_AARCH64_TLSDESC_ADR_PAGE21
#undef R_AARCH64_TLSDESC_LD64_LO12_NC
#undef R_AARCH64_TLSDESC_ADD_LO12_NC
#undef R_AARCH64_TLSDESC_OFF_G1
#undef R_AARCH64_TLSDESC_OFF_G0_NC
#undef R_AARCH64_TLSDESC_LDR
#undef R_AARCH64_TLSDESC_ADD
#undef R_AARCH64_TLSDESC_CALL

#undef R_AARCH64_TLSLE_LDST128_TPREL_LO12
#undef R_AARCH64_TLSLE_LDST128_TPREL_LO12_NC

#undef R_AARCH64_TLSLD_LDST128_DTPREL_LO12
#undef R_AARCH64_TLSLD_LDST128_DTPREL_LO12_NC

#undef R_AARCH64_COPY
#undef R_AARCH64_GLOB_DAT
#undef R_AARCH64_JUMP_SLOT
#undef R_AARCH64_RELATIVE
#undef R_AARCH64_TLS_DTPREL64
#undef R_AARCH64_TLS_DTPMOD64
#undef R_AARCH64_TLS_TPREL64
#undef R_AARCH64_TLSDESC
#undef R_AARCH64_IRELATIVE

#undef R_ARM_NONE
#undef R_ARM_PC24
#undef R_ARM_ABS32
#undef R_ARM_REL32
#undef R_ARM_LDR_PC_G0
#undef R_ARM_ABS16
#undef R_ARM_ABS12
#undef R_ARM_THM_ABS5
#undef R_ARM_ABS8
#undef R_ARM_SBREL32
#undef R_ARM_THM_CALL
#undef R_ARM_THM_PC8
#undef R_ARM_BREL_ADJ
#undef R_ARM_TLS_DESC
#undef R_ARM_THM_SWI8
#undef R_ARM_XPC25
#undef R_ARM_THM_XPC22
#undef R_ARM_TLS_DTPMOD32
#undef R_ARM_TLS_DTPOFF32
#undef R_ARM_TLS_TPOFF32
#undef R_ARM_COPY
#undef R_ARM_GLOB_DAT
#undef R_ARM_JUMP_SLOT
#undef R_ARM_RELATIVE
#undef R_ARM_GOTOFF32
#undef R_ARM_BASE_PREL
#undef R_ARM_GOT_BREL
#undef R_ARM_PLT32
#undef R_ARM_CALL
#undef R_ARM_JUMP24
#undef R_ARM_THM_JUMP24
#undef R_ARM_BASE_ABS
#undef R_ARM_ALU_PCREL_7_0
#undef R_ARM_ALU_PCREL_15_8
#undef R_ARM_ALU_PCREL_23_15
#undef R_ARM_LDR_SBREL_11_0_NC
#undef R_ARM_ALU_SBREL_19_12_NC
#undef R_ARM_ALU_SBREL_27_20_CK
#undef R_ARM_TARGET1
#undef R_ARM_SBREL31
#undef R_ARM_V4BX
#undef R_ARM_TARGET2
#undef R_ARM_PREL31
#undef R_ARM_MOVW_ABS_NC
#undef R_ARM_MOVT_ABS
#undef R_ARM_MOVW_PREL_NC
#undef R_ARM_MOVT_PREL
#undef R_ARM_THM_MOVW_ABS_NC
#undef R_ARM_THM_MOVT_ABS
#undef R_ARM_THM_MOVW_PREL_NC
#undef R_ARM_THM_MOVT_PREL
#undef R_ARM_THM_JUMP19
#undef R_ARM_THM_JUMP6
#undef R_ARM_THM_ALU_PREL_11_0
#undef R_ARM_THM_PC12
#undef R_ARM_ABS32_NOI
#undef R_ARM_REL32_NOI
#undef R_ARM_ALU_PC_G0_NC
#undef R_ARM_ALU_PC_G0
#undef R_ARM_ALU_PC_G1_NC
#undef R_ARM_ALU_PC_G1
#undef R_ARM_ALU_PC_G2
#undef R_ARM_LDR_PC_G1
#undef R_ARM_LDR_PC_G2
#undef R_ARM_LDRS_PC_G0
#undef R_ARM_LDRS_PC_G1
#undef R_ARM_LDRS_PC_G2
#undef R_ARM_LDC_PC_G0
#undef R_ARM_LDC_PC_G1
#undef R_ARM_LDC_PC_G2
#undef R_ARM_ALU_SB_G0_NC
#undef R_ARM_ALU_SB_G0
#undef R_ARM_ALU_SB_G1_NC
#undef R_ARM_ALU_SB_G1
#undef R_ARM_ALU_SB_G2
#undef R_ARM_LDR_SB_G0
#undef R_ARM_LDR_SB_G1
#undef R_ARM_LDR_SB_G2
#undef R_ARM_LDRS_SB_G0
#undef R_ARM_LDRS_SB_G1
#undef R_ARM_LDRS_SB_G2
#undef R_ARM_LDC_SB_G0
#undef R_ARM_LDC_SB_G1
#undef R_ARM_LDC_SB_G2
#undef R_ARM_MOVW_BREL_NC
#undef R_ARM_MOVT_BREL
#undef R_ARM_MOVW_BREL
#undef R_ARM_THM_MOVW_BREL_NC
#undef R_ARM_THM_MOVT_BREL
#undef R_ARM_THM_MOVW_BREL
#undef R_ARM_TLS_GOTDESC
#undef R_ARM_TLS_CALL
#undef R_ARM_TLS_DESCSEQ
#undef R_ARM_THM_TLS_CALL
#undef R_ARM_PLT32_ABS
#undef R_ARM_GOT_ABS
#undef R_ARM_GOT_PREL
#undef R_ARM_GOT_BREL12
#undef R_ARM_GOTOFF12
#undef R_ARM_GOTRELAX
#undef R_ARM_GNU_VTENTRY
#undef R_ARM_GNU_VTINHERIT
#undef R_ARM_THM_JUMP11
#undef R_ARM_THM_JUMP8
#undef R_ARM_TLS_GD32
#undef R_ARM_TLS_LDM32
#undef R_ARM_TLS_LDO32
#undef R_ARM_TLS_IE32
#undef R_ARM_TLS_LE32
#undef R_ARM_TLS_LDO12
#undef R_ARM_TLS_LE12
#undef R_ARM_TLS_IE12GP
#undef R_ARM_PRIVATE_0
#undef R_ARM_PRIVATE_1
#undef R_ARM_PRIVATE_2
#undef R_ARM_PRIVATE_3
#undef R_ARM_PRIVATE_4
#undef R_ARM_PRIVATE_5
#undef R_ARM_PRIVATE_6
#undef R_ARM_PRIVATE_7
#undef R_ARM_PRIVATE_8
#undef R_ARM_PRIVATE_9
#undef R_ARM_PRIVATE_10
#undef R_ARM_PRIVATE_11
#undef R_ARM_PRIVATE_12
#undef R_ARM_PRIVATE_13
#undef R_ARM_PRIVATE_14
#undef R_ARM_PRIVATE_15
#undef R_ARM_ME_TOO
#undef R_ARM_THM_TLS_DESCSEQ16
#undef R_ARM_THM_TLS_DESCSEQ32
#undef R_ARM_IRELATIVE

#undef R_ARM_RXPC25
#undef R_ARM_RSBREL32
#undef R_ARM_THM_RPC22
#undef R_ARM_RREL32
#undef R_ARM_RPC24
#undef R_ARM_RBASE

#undef R_HEX_NONE
#undef R_HEX_B22_PCREL
#undef R_HEX_B15_PCREL
#undef R_HEX_B7_PCREL
#undef R_HEX_LO16
#undef R_HEX_HI16
#undef R_HEX_32
#undef R_HEX_16
#undef R_HEX_8
#undef R_HEX_GPREL16_0
#undef R_HEX_GPREL16_1
#undef R_HEX_GPREL16_2
#undef R_HEX_GPREL16_3
#undef R_HEX_HL16
#undef R_HEX_B13_PCREL
#undef R_HEX_B9_PCREL
#undef R_HEX_B32_PCREL_X
#undef R_HEX_32_6_X
#undef R_HEX_B22_PCREL_X
#undef R_HEX_B15_PCREL_X
#undef R_HEX_B13_PCREL_X
#undef R_HEX_B9_PCREL_X
#undef R_HEX_B7_PCREL_X
#undef R_HEX_16_X
#undef R_HEX_12_X
#undef R_HEX_11_X
#undef R_HEX_10_X
#undef R_HEX_9_X
#undef R_HEX_8_X
#undef R_HEX_7_X
#undef R_HEX_6_X
#undef R_HEX_32_PCREL
#undef R_HEX_COPY
#undef R_HEX_GLOB_DAT
#undef R_HEX_JMP_SLOT
#undef R_HEX_RELATIVE
#undef R_HEX_PLT_B22_PCREL
#undef R_HEX_GOTREL_LO16
#undef R_HEX_GOTREL_HI16
#undef R_HEX_GOTREL_32
#undef R_HEX_GOT_LO16
#undef R_HEX_GOT_HI16
#undef R_HEX_GOT_32
#undef R_HEX_GOT_16
#undef R_HEX_DTPMOD_32
#undef R_HEX_DTPREL_LO16
#undef R_HEX_DTPREL_HI16
#undef R_HEX_DTPREL_32
#undef R_HEX_DTPREL_16
#undef R_HEX_GD_PLT_B22_PCREL
#undef R_HEX_GD_GOT_LO16
#undef R_HEX_GD_GOT_HI16
#undef R_HEX_GD_GOT_32
#undef R_HEX_GD_GOT_16
#undef R_HEX_IE_LO16
#undef R_HEX_IE_HI16
#undef R_HEX_IE_32
#undef R_HEX_IE_GOT_LO16
#undef R_HEX_IE_GOT_HI16
#undef R_HEX_IE_GOT_32
#undef R_HEX_IE_GOT_16
#undef R_HEX_TPREL_LO16
#undef R_HEX_TPREL_HI16
#undef R_HEX_TPREL_32
#undef R_HEX_TPREL_16
#undef R_HEX_6_PCREL_X
#undef R_HEX_GOTREL_32_6_X
#undef R_HEX_GOTREL_16_X
#undef R_HEX_GOTREL_11_X
#undef R_HEX_GOT_32_6_X
#undef R_HEX_GOT_16_X
#undef R_HEX_GOT_11_X
#undef R_HEX_DTPREL_32_6_X
#undef R_HEX_DTPREL_16_X
#undef R_HEX_DTPREL_11_X
#undef R_HEX_GD_GOT_32_6_X
#undef R_HEX_GD_GOT_16_X
#undef R_HEX_GD_GOT_11_X
#undef R_HEX_IE_32_6_X
#undef R_HEX_IE_16_X
#undef R_HEX_IE_GOT_32_6_X
#undef R_HEX_IE_GOT_16_X
#undef R_HEX_IE_GOT_11_X
#undef R_HEX_TPREL_32_6_X
#undef R_HEX_TPREL_16_X
#undef R_HEX_TPREL_11_X
#undef R_HEX_LD_PLT_B22_PCREL
#undef R_HEX_LD_GOT_LO16
#undef R_HEX_LD_GOT_HI16
#undef R_HEX_LD_GOT_32
#undef R_HEX_LD_GOT_16
#undef R_HEX_LD_GOT_32_6_X
#undef R_HEX_LD_GOT_16_X
#undef R_HEX_LD_GOT_11_X

#undef R_386_NONE
#undef R_386_32
#undef R_386_PC32
#undef R_386_GOT32
#undef R_386_PLT32
#undef R_386_COPY
#undef R_386_GLOB_DAT
#undef R_386_JUMP_SLOT
#undef R_386_RELATIVE
#undef R_386_GOTOFF
#undef R_386_GOTPC
#undef R_386_32PLT
#undef R_386_TLS_TPOFF
#undef R_386_TLS_IE
#undef R_386_TLS_GOTIE
#undef R_386_TLS_LE
#undef R_386_TLS_GD
#undef R_386_TLS_LDM
#undef R_386_16
#undef R_386_PC16
#undef R_386_8
#undef R_386_PC8
#undef R_386_TLS_GD_32
#undef R_386_TLS_GD_PUSH
#undef R_386_TLS_GD_CALL
#undef R_386_TLS_GD_POP
#undef R_386_TLS_LDM_32
#undef R_386_TLS_LDM_PUSH
#undef R_386_TLS_LDM_CALL
#undef R_386_TLS_LDM_POP
#undef R_386_TLS_LDO_32
#undef R_386_TLS_IE_32
#undef R_386_TLS_LE_32
#undef R_386_TLS_DTPMOD32
#undef R_386_TLS_DTPOFF32
#undef R_386_TLS_TPOFF32
#undef R_386_TLS_GOTDESC
#undef R_386_TLS_DESC_CALL
#undef R_386_TLS_DESC
#undef R_386_IRELATIVE
#undef R_386_NUM

#undef R_MIPS_NONE
#undef R_MIPS_16
#undef R_MIPS_32
#undef R_MIPS_REL32
#undef R_MIPS_26
#undef R_MIPS_HI16
#undef R_MIPS_LO16
#undef R_MIPS_GPREL16
#undef R_MIPS_LITERAL
#undef R_MIPS_GOT16
#undef R_MIPS_PC16
#undef R_MIPS_CALL16
#undef R_MIPS_GPREL32
#undef R_MIPS_UNUSED1
#undef R_MIPS_UNUSED2
#undef R_MIPS_UNUSED3
#undef R_MIPS_SHIFT5
#undef R_MIPS_SHIFT6
#undef R_MIPS_64
#undef R_MIPS_GOT_DISP
#undef R_MIPS_GOT_PAGE
#undef R_MIPS_GOT_OFST
#undef R_MIPS_GOT_HI16
#undef R_MIPS_GOT_LO16
#undef R_MIPS_SUB
#undef R_MIPS_INSERT_A
#undef R_MIPS_INSERT_B
#undef R_MIPS_DELETE
#undef R_MIPS_HIGHER
#undef R_MIPS_HIGHEST
#undef R_MIPS_CALL_HI16
#undef R_MIPS_CALL_LO16
#undef R_MIPS_SCN_DISP
#undef R_MIPS_REL16
#undef R_MIPS_ADD_IMMEDIATE
#undef R_MIPS_PJUMP
#undef R_MIPS_RELGOT
#undef R_MIPS_JALR
#undef R_MIPS_TLS_DTPMOD32
#undef R_MIPS_TLS_DTPREL32
#undef R_MIPS_TLS_DTPMOD64
#undef R_MIPS_TLS_DTPREL64
#undef R_MIPS_TLS_GD
#undef R_MIPS_TLS_LDM
#undef R_MIPS_TLS_DTPREL_HI16
#undef R_MIPS_TLS_DTPREL_LO16
#undef R_MIPS_TLS_GOTTPREL
#undef R_MIPS_TLS_TPREL32
#undef R_MIPS_TLS_TPREL64
#undef R_MIPS_TLS_TPREL_HI16
#undef R_MIPS_TLS_TPREL_LO16
#undef R_MIPS_GLOB_DAT
#undef R_MIPS_PC21_S2
#undef R_MIPS_PC26_S2
#undef R_MIPS_PC18_S3
#undef R_MIPS_PC19_S2
#undef R_MIPS_PCHI16
#undef R_MIPS_PCLO16
#undef R_MIPS16_26
#undef R_MIPS16_GPREL
#undef R_MIPS16_GOT16
#undef R_MIPS16_CALL16
#undef R_MIPS16_HI16
#undef R_MIPS16_LO16
#undef R_MIPS16_TLS_GD
#undef R_MIPS16_TLS_LDM
#undef R_MIPS16_TLS_DTPREL_HI16
#undef R_MIPS16_TLS_DTPREL_LO16
#undef R_MIPS16_TLS_GOTTPREL
#undef R_MIPS16_TLS_TPREL_HI16
#undef R_MIPS16_TLS_TPREL_LO16
#undef R_MIPS_COPY
#undef R_MIPS_JUMP_SLOT
#undef R_MICROMIPS_26_S1
#undef R_MICROMIPS_HI16
#undef R_MICROMIPS_LO16
#undef R_MICROMIPS_GPREL16
#undef R_MICROMIPS_LITERAL
#undef R_MICROMIPS_GOT16
#undef R_MICROMIPS_PC7_S1
#undef R_MICROMIPS_PC10_S1
#undef R_MICROMIPS_PC16_S1
#undef R_MICROMIPS_CALL16
#undef R_MICROMIPS_GOT_DISP
#undef R_MICROMIPS_GOT_PAGE
#undef R_MICROMIPS_GOT_OFST
#undef R_MICROMIPS_GOT_HI16
#undef R_MICROMIPS_GOT_LO16
#undef R_MICROMIPS_SUB
#undef R_MICROMIPS_HIGHER
#undef R_MICROMIPS_HIGHEST
#undef R_MICROMIPS_CALL_HI16
#undef R_MICROMIPS_CALL_LO16
#undef R_MICROMIPS_SCN_DISP
#undef R_MICROMIPS_JALR
#undef R_MICROMIPS_HI0_LO16
#undef R_MICROMIPS_TLS_GD
#undef R_MICROMIPS_TLS_LDM
#undef R_MICROMIPS_TLS_DTPREL_HI16
#undef R_MICROMIPS_TLS_DTPREL_LO16
#undef R_MICROMIPS_TLS_GOTTPREL
#undef R_MICROMIPS_TLS_TPREL_HI16
#undef R_MICROMIPS_TLS_TPREL_LO16
#undef R_MICROMIPS_GPREL7_S2
#undef R_MICROMIPS_PC23_S2
#undef R_MICROMIPS_PC21_S2
#undef R_MICROMIPS_PC26_S2
#undef R_MICROMIPS_PC18_S3
#undef R_MICROMIPS_PC19_S2
#undef R_MIPS_NUM
#undef R_MIPS_PC32
#undef R_MIPS_EH

#undef R_PPC_NONE
#undef R_PPC_ADDR32
#undef R_PPC_ADDR24
#undef R_PPC_ADDR16
#undef R_PPC_ADDR16_LO
#undef R_PPC_ADDR16_HI
#undef R_PPC_ADDR16_HA
#undef R_PPC_ADDR14
#undef R_PPC_ADDR14_BRTAKEN
#undef R_PPC_ADDR14_BRNTAKEN
#undef R_PPC_REL24
#undef R_PPC_REL14
#undef R_PPC_REL14_BRTAKEN
#undef R_PPC_REL14_BRNTAKEN
#undef R_PPC_GOT16
#undef R_PPC_GOT16_LO
#undef R_PPC_GOT16_HI
#undef R_PPC_GOT16_HA
#undef R_PPC_PLTREL24
#undef R_PPC_JMP_SLOT
#undef R_PPC_RELATIVE
#undef R_PPC_LOCAL24PC
#undef R_PPC_REL32
#undef R_PPC_TLS
#undef R_PPC_DTPMOD32
#undef R_PPC_TPREL16
#undef R_PPC_TPREL16_LO
#undef R_PPC_TPREL16_HI
#undef R_PPC_TPREL16_HA
#undef R_PPC_TPREL32
#undef R_PPC_DTPREL16
#undef R_PPC_DTPREL16_LO
#undef R_PPC_DTPREL16_HI
#undef R_PPC_DTPREL16_HA
#undef R_PPC_DTPREL32
#undef R_PPC_GOT_TLSGD16
#undef R_PPC_GOT_TLSGD16_LO
#undef R_PPC_GOT_TLSGD16_HI
#undef R_PPC_GOT_TLSGD16_HA
#undef R_PPC_GOT_TLSLD16
#undef R_PPC_GOT_TLSLD16_LO
#undef R_PPC_GOT_TLSLD16_HI
#undef R_PPC_GOT_TLSLD16_HA
#undef R_PPC_GOT_TPREL16
#undef R_PPC_GOT_TPREL16_LO
#undef R_PPC_GOT_TPREL16_HI
#undef R_PPC_GOT_TPREL16_HA
#undef R_PPC_GOT_DTPREL16
#undef R_PPC_GOT_DTPREL16_LO
#undef R_PPC_GOT_DTPREL16_HI
#undef R_PPC_GOT_DTPREL16_HA
#undef R_PPC_TLSGD
#undef R_PPC_TLSLD
#undef R_PPC_REL16
#undef R_PPC_REL16_LO
#undef R_PPC_REL16_HI
#undef R_PPC_REL16_HA

#undef R_PPC64_NONE
#undef R_PPC64_ADDR32
#undef R_PPC64_ADDR24
#undef R_PPC64_ADDR16
#undef R_PPC64_ADDR16_LO
#undef R_PPC64_ADDR16_HI
#undef R_PPC64_ADDR16_HA
#undef R_PPC64_ADDR14
#undef R_PPC64_ADDR14_BRTAKEN
#undef R_PPC64_ADDR14_BRNTAKEN
#undef R_PPC64_REL24
#undef R_PPC64_REL14
#undef R_PPC64_REL14_BRTAKEN
#undef R_PPC64_REL14_BRNTAKEN
#undef R_PPC64_GOT16
#undef R_PPC64_GOT16_LO
#undef R_PPC64_GOT16_HI
#undef R_PPC64_GOT16_HA
#undef R_PPC64_JMP_SLOT
#undef R_PPC64_RELATIVE
#undef R_PPC64_REL32
#undef R_PPC64_ADDR64
#undef R_PPC64_ADDR16_HIGHER
#undef R_PPC64_ADDR16_HIGHERA
#undef R_PPC64_ADDR16_HIGHEST
#undef R_PPC64_ADDR16_HIGHESTA
#undef R_PPC64_REL64
#undef R_PPC64_TOC16
#undef R_PPC64_TOC16_LO
#undef R_PPC64_TOC16_HI
#undef R_PPC64_TOC16_HA
#undef R_PPC64_TOC
#undef R_PPC64_ADDR16_DS
#undef R_PPC64_ADDR16_LO_DS
#undef R_PPC64_GOT16_DS
#undef R_PPC64_GOT16_LO_DS
#undef R_PPC64_TOC16_DS
#undef R_PPC64_TOC16_LO_DS
#undef R_PPC64_TLS
#undef R_PPC64_DTPMOD64
#undef R_PPC64_TPREL16
#undef R_PPC64_TPREL16_LO
#undef R_PPC64_TPREL16_HI
#undef R_PPC64_TPREL16_HA
#undef R_PPC64_TPREL64
#undef R_PPC64_DTPREL16
#undef R_PPC64_DTPREL16_LO
#undef R_PPC64_DTPREL16_HI
#undef R_PPC64_DTPREL16_HA
#undef R_PPC64_DTPREL64
#undef R_PPC64_GOT_TLSGD16
#undef R_PPC64_GOT_TLSGD16_LO
#undef R_PPC64_GOT_TLSGD16_HI
#undef R_PPC64_GOT_TLSGD16_HA
#undef R_PPC64_GOT_TLSLD16
#undef R_PPC64_GOT_TLSLD16_LO
#undef R_PPC64_GOT_TLSLD16_HI
#undef R_PPC64_GOT_TLSLD16_HA
#undef R_PPC64_GOT_TPREL16_DS
#undef R_PPC64_GOT_TPREL16_LO_DS
#undef R_PPC64_GOT_TPREL16_HI
#undef R_PPC64_GOT_TPREL16_HA
#undef R_PPC64_GOT_DTPREL16_DS
#undef R_PPC64_GOT_DTPREL16_LO_DS
#undef R_PPC64_GOT_DTPREL16_HI
#undef R_PPC64_GOT_DTPREL16_HA
#undef R_PPC64_TPREL16_DS
#undef R_PPC64_TPREL16_LO_DS
#undef R_PPC64_TPREL16_HIGHER
#undef R_PPC64_TPREL16_HIGHERA
#undef R_PPC64_TPREL16_HIGHEST
#undef R_PPC64_TPREL16_HIGHESTA
#undef R_PPC64_DTPREL16_DS
#undef R_PPC64_DTPREL16_LO_DS
#undef R_PPC64_DTPREL16_HIGHER
#undef R_PPC64_DTPREL16_HIGHERA
#undef R_PPC64_DTPREL16_HIGHEST
#undef R_PPC64_DTPREL16_HIGHESTA
#undef R_PPC64_TLSGD
#undef R_PPC64_TLSLD
#undef R_PPC64_REL16
#undef R_PPC64_REL16_LO
#undef R_PPC64_REL16_HI
#undef R_PPC64_REL16_HA

#undef R_SPARC_NONE
#undef R_SPARC_8
#undef R_SPARC_16
#undef R_SPARC_32
#undef R_SPARC_DISP8
#undef R_SPARC_DISP16
#undef R_SPARC_DISP32
#undef R_SPARC_WDISP30
#undef R_SPARC_WDISP22
#undef R_SPARC_HI22
#undef R_SPARC_22
#undef R_SPARC_13
#undef R_SPARC_LO10
#undef R_SPARC_GOT10
#undef R_SPARC_GOT13
#undef R_SPARC_GOT22
#undef R_SPARC_PC10
#undef R_SPARC_PC22
#undef R_SPARC_WPLT30
#undef R_SPARC_COPY
#undef R_SPARC_GLOB_DAT
#undef R_SPARC_JMP_SLOT
#undef R_SPARC_RELATIVE
#undef R_SPARC_UA32
#undef R_SPARC_PLT32
#undef R_SPARC_HIPLT22
#undef R_SPARC_LOPLT10
#undef R_SPARC_PCPLT32
#undef R_SPARC_PCPLT22
#undef R_SPARC_PCPLT10
#undef R_SPARC_10
#undef R_SPARC_11
#undef R_SPARC_64
#undef R_SPARC_OLO10
#undef R_SPARC_HH22
#undef R_SPARC_HM10
#undef R_SPARC_LM22
#undef R_SPARC_PC_HH22
#undef R_SPARC_PC_HM10
#undef R_SPARC_PC_LM22
#undef R_SPARC_WDISP16
#undef R_SPARC_WDISP19
#undef R_SPARC_7
#undef R_SPARC_5
#undef R_SPARC_6
#undef R_SPARC_DISP64
#undef R_SPARC_PLT64
#undef R_SPARC_HIX22
#undef R_SPARC_LOX10
#undef R_SPARC_H44
#undef R_SPARC_M44
#undef R_SPARC_L44
#undef R_SPARC_REGISTER
#undef R_SPARC_UA64
#undef R_SPARC_UA16
#undef R_SPARC_TLS_GD_HI22
#undef R_SPARC_TLS_GD_LO10
#undef R_SPARC_TLS_GD_ADD
#undef R_SPARC_TLS_GD_CALL
#undef R_SPARC_TLS_LDM_HI22
#undef R_SPARC_TLS_LDM_LO10
#undef R_SPARC_TLS_LDM_ADD
#undef R_SPARC_TLS_LDM_CALL
#undef R_SPARC_TLS_LDO_HIX22
#undef R_SPARC_TLS_LDO_LOX10
#undef R_SPARC_TLS_LDO_ADD
#undef R_SPARC_TLS_IE_HI22
#undef R_SPARC_TLS_IE_LO10
#undef R_SPARC_TLS_IE_LD
#undef R_SPARC_TLS_IE_LDX
#undef R_SPARC_TLS_IE_ADD
#undef R_SPARC_TLS_LE_HIX22
#undef R_SPARC_TLS_LE_LOX10
#undef R_SPARC_TLS_DTPMOD32
#undef R_SPARC_TLS_DTPMOD64
#undef R_SPARC_TLS_DTPOFF32
#undef R_SPARC_TLS_DTPOFF64
#undef R_SPARC_TLS_TPOFF32
#undef R_SPARC_TLS_TPOFF64
#undef R_SPARC_GOTDATA_HIX22
#undef R_SPARC_GOTDATA_LOX10
#undef R_SPARC_GOTDATA_OP_HIX22
#undef R_SPARC_GOTDATA_OP_LOX10
#undef R_SPARC_GOTDATA_OP

#undef R_390_NONE
#undef R_390_8
#undef R_390_12
#undef R_390_16
#undef R_390_32
#undef R_390_PC32
#undef R_390_GOT12
#undef R_390_GOT32
#undef R_390_PLT32
#undef R_390_COPY
#undef R_390_GLOB_DAT
#undef R_390_JMP_SLOT
#undef R_390_RELATIVE
#undef R_390_GOTOFF
#undef R_390_GOTPC
#undef R_390_GOT16
#undef R_390_PC16
#undef R_390_PC16DBL
#undef R_390_PLT16DBL
#undef R_390_PC32DBL
#undef R_390_PLT32DBL
#undef R_390_GOTPCDBL
#undef R_390_64
#undef R_390_PC64
#undef R_390_GOT64
#undef R_390_PLT64
#undef R_390_GOTENT
#undef R_390_GOTOFF16
#undef R_390_GOTOFF64
#undef R_390_GOTPLT12
#undef R_390_GOTPLT16
#undef R_390_GOTPLT32
#undef R_390_GOTPLT64
#undef R_390_GOTPLTENT
#undef R_390_PLTOFF16
#undef R_390_PLTOFF32
#undef R_390_PLTOFF64
#undef R_390_TLS_LOAD
#undef R_390_TLS_GDCALL
#undef R_390_TLS_LDCALL
#undef R_390_TLS_GD32
#undef R_390_TLS_GD64
#undef R_390_TLS_GOTIE12
#undef R_390_TLS_GOTIE32
#undef R_390_TLS_GOTIE64
#undef R_390_TLS_LDM32
#undef R_390_TLS_LDM64
#undef R_390_TLS_IE32
#undef R_390_TLS_IE64
#undef R_390_TLS_IEENT
#undef R_390_TLS_LE32
#undef R_390_TLS_LE64
#undef R_390_TLS_LDO32
#undef R_390_TLS_LDO64
#undef R_390_TLS_DTPMOD
#undef R_390_TLS_DTPOFF
#undef R_390_TLS_TPOFF
#undef R_390_20
#undef R_390_GOT20
#undef R_390_GOTPLT20
#undef R_390_TLS_GOTIE20
#undef R_390_IRELATIVE

#undef R_X86_64_NONE
#undef R_X86_64_64
#undef R_X86_64_PC32
#undef R_X86_64_GOT32
#undef R_X86_64_PLT32
#undef R_X86_64_COPY
#undef R_X86_64_GLOB_DAT
#undef R_X86_64_JUMP_SLOT
#undef R_X86_64_RELATIVE
#undef R_X86_64_GOTPCREL
#undef R_X86_64_32
#undef R_X86_64_32S
#undef R_X86_64_16
#undef R_X86_64_PC16
#undef R_X86_64_8
#undef R_X86_64_PC8
#undef R_X86_64_DTPMOD64
#undef R_X86_64_DTPOFF64
#undef R_X86_64_TPOFF64
#undef R_X86_64_TLSGD
#undef R_X86_64_TLSLD
#undef R_X86_64_DTPOFF32
#undef R_X86_64_GOTTPOFF
#undef R_X86_64_TPOFF32
#undef R_X86_64_PC64
#undef R_X86_64_GOTOFF64
#undef R_X86_64_GOTPC32
#undef R_X86_64_GOT64
#undef R_X86_64_GOTPCREL64
#undef R_X86_64_GOTPC64
#undef R_X86_64_GOTPLT64
#undef R_X86_64_PLTOFF64
#undef R_X86_64_SIZE32
#undef R_X86_64_SIZE64
#undef R_X86_64_GOTPC32_TLSDESC
#undef R_X86_64_TLSDESC_CALL
#undef R_X86_64_TLSDESC
#undef R_X86_64_IRELATIVE

#undef R_X86_64_RELATIVE64
#undef R_X86_64_PC32_BND
#undef R_X86_64_PLT32_BND
#undef R_X86_64_GOTPCRELX
#undef R_X86_64_REX_GOTPCRELX

#undef R_LARCH_NONE
#undef R_LARCH_32
#undef R_LARCH_64
#undef R_LARCH_RELATIVE
#undef R_LARCH_COPY
#undef R_LARCH_JUMP_SLOT
#undef R_LARCH_TLS_DTPMOD32
#undef R_LARCH_TLS_DTPMOD64
#undef R_LARCH_TLS_DTPREL32
#undef R_LARCH_TLS_DTPREL64
#undef R_LARCH_TLS_TPREL32
#undef R_LARCH_TLS_TPREL64
#undef R_LARCH_IRELATIVE
#undef R_LARCH_MARK_LA
#undef R_LARCH_MARK_PCREL
#undef R_LARCH_SOP_PUSH_PCREL
#undef R_LARCH_SOP_PUSH_ABSOLUTE
#undef R_LARCH_SOP_PUSH_DUP
#undef R_LARCH_SOP_PUSH_GPREL
#undef R_LARCH_SOP_PUSH_TLS_TPREL
#undef R_LARCH_SOP_PUSH_TLS_GOT
#undef R_LARCH_SOP_PUSH_TLS_GD
#undef R_LARCH_SOP_PUSH_PLT_PCREL
#undef R_LARCH_SOP_ASSERT
#undef R_LARCH_SOP_NOT
#undef R_LARCH_SOP_SUB
#undef R_LARCH_SOP_SL
#undef R_LARCH_SOP_SR
#undef R_LARCH_SOP_ADD
#undef R_LARCH_SOP_AND
#undef R_LARCH_SOP_IF_ELSE
#undef R_LARCH_SOP_POP_32_S_10_5
#undef R_LARCH_SOP_POP_32_U_10_12
#undef R_LARCH_SOP_POP_32_S_10_12
#undef R_LARCH_SOP_POP_32_S_10_16
#undef R_LARCH_SOP_POP_32_S_10_16_S2
#undef R_LARCH_SOP_POP_32_S_5_20
#undef R_LARCH_SOP_POP_32_S_0_5_10_16_S2
#undef R_LARCH_SOP_POP_32_S_0_10_10_16_S2
#undef R_LARCH_SOP_POP_32_U
#undef R_LARCH_ADD8
#undef R_LARCH_ADD16
#undef R_LARCH_ADD24
#undef R_LARCH_ADD32
#undef R_LARCH_ADD64
#undef R_LARCH_SUB8
#undef R_LARCH_SUB16
#undef R_LARCH_SUB24
#undef R_LARCH_SUB32
#undef R_LARCH_SUB64
#undef R_LARCH_GNU_VTINHERIT
#undef R_LARCH_GNU_VTENTRY
#undef R_LARCH_B16
#undef R_LARCH_B21
#undef R_LARCH_B26
#undef R_LARCH_ABS_HI20
#undef R_LARCH_ABS_LO12
#undef R_LARCH_ABS64_LO20
#undef R_LARCH_ABS64_HI12
#undef R_LARCH_PCALA_HI20
#undef R_LARCH_PCALA_LO12
#undef R_LARCH_PCALA64_LO20
#undef R_LARCH_PCALA64_HI12
#undef R_LARCH_GOT_PC_HI20
#undef R_LARCH_GOT_PC_LO12
#undef R_LARCH_GOT64_PC_LO20
#undef R_LARCH_GOT64_PC_HI12
#undef R_LARCH_GOT_HI20
#undef R_LARCH_GOT_LO12
#undef R_LARCH_GOT64_LO20
#undef R_LARCH_GOT64_HI12
#undef R_LARCH_TLS_LE_HI20
#undef R_LARCH_TLS_LE_LO12
#undef R_LARCH_TLS_LE64_LO20
#undef R_LARCH_TLS_LE64_HI12
#undef R_LARCH_TLS_IE_PC_HI20
#undef R_LARCH_TLS_IE_PC_LO12
#undef R_LARCH_TLS_IE64_PC_LO20
#undef R_LARCH_TLS_IE64_PC_HI12
#undef R_LARCH_TLS_IE_HI20
#undef R_LARCH_TLS_IE_LO12
#undef R_LARCH_TLS_IE64_LO20
#undef R_LARCH_TLS_IE64_HI12
#undef R_LARCH_TLS_LD_PC_HI20
#undef R_LARCH_TLS_LD_HI20
#undef R_LARCH_TLS_GD_PC_HI20
#undef R_LARCH_TLS_GD_HI20
#undef R_LARCH_32_PCREL
#undef R_LARCH_RELAX

#undef AT_NULL
#undef AT_IGNORE
#undef AT_EXECFD
#undef AT_PHDR
#undef AT_PHENT
#undef AT_PHNUM
#undef AT_PAGESZ
#undef AT_BASE
#undef AT_FLAGS
#undef AT_ENTRY
#undef AT_NOTELF
#undef AT_UID
#undef AT_EUID
#undef AT_GID
#undef AT_EGID
#undef AT_CLKTCK

#undef AT_PLATFORM
#undef AT_HWCAP
#undef AT_HWCAP2
#undef AT_FPUCW
#undef AT_DCACHEBSIZE
#undef AT_ICACHEBSIZE
#undef AT_UCACHEBSIZE
#undef AT_IGNOREPPC
#undef AT_SECURE
#undef AT_BASE_PLATFORM
#undef AT_RANDOM
#undef AT_EXECFN
#undef AT_SYSINFO
#undef AT_SYSINFO_EHDR
#undef AT_L1I_CACHESHAPE
#undef AT_L1D_CACHESHAPE
#undef AT_L2_CACHESHAPE
#undef AT_L3_CACHESHAPE

#undef NT_GNU_PROPERTY_TYPE_0


#endif

```

`KDemu/include/LIEF/LIEF/ELF/utils.h`:

```h
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_C_ELF_UTILS_H
#define LIEF_C_ELF_UTILS_H

#include <stddef.h>

#include "LIEF/visibility.h"
#include "LIEF/types.h"


#ifdef __cplusplus
extern "C" {
#endif

/** @brief Check if the given file is an ELF one. */
LIEF_API bool is_elf(const char* file);

#ifdef __cplusplus
}
#endif


#endif

```

`KDemu/include/LIEF/LIEF/ELF/utils.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ELF_UTILS_H
#define LIEF_ELF_UTILS_H

#include <string>
#include <vector>

#include "LIEF/types.hpp"
#include "LIEF/visibility.h"

namespace LIEF {
class BinaryStream;

namespace ELF {

//! @brief Check if given stream wraps an ELF file
LIEF_API bool is_elf(BinaryStream& stream);

//! @brief Check if the given file is an ELF one.
LIEF_API bool is_elf(const std::string& file);

//! @brief check if the raw data is a ELF file
LIEF_API bool is_elf(const std::vector<uint8_t>& raw);

LIEF_API unsigned long hash32(const char* name);
LIEF_API unsigned long hash64(const char* name);
LIEF_API uint32_t dl_new_hash(const char* name);
}
}


#endif

```

`KDemu/include/LIEF/LIEF/LIEF.h`:

```h
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef C_LIEF_H_
#define C_LIEF_H_

#include <LIEF/MachO.h>
#include <LIEF/PE.h>
#include <LIEF/ELF.h>
#include <LIEF/logging.h>

#endif

```

`KDemu/include/LIEF/LIEF/LIEF.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MAIN_HEADER_H
#define LIEF_MAIN_HEADER_H
#include <LIEF/config.h>

#include <LIEF/Abstract.hpp>

#include <LIEF/OAT.hpp>
#include <LIEF/VDEX.hpp>
#include <LIEF/ART.hpp>
#include <LIEF/DEX.hpp>
#include <LIEF/ELF.hpp>
#include <LIEF/PE.hpp>
#include <LIEF/MachO.hpp>
#include <LIEF/DWARF.hpp>
#include <LIEF/PDB.hpp>
#include <LIEF/ObjC.hpp>
#include <LIEF/logging.hpp>
#include <LIEF/platforms.hpp>
#include <LIEF/debug_loc.hpp>


#endif

```

`KDemu/include/LIEF/LIEF/MachO.h`:

```h
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef C_LIEF_MACHO_H_
#define C_LIEF_MACHO_H_

#include "LIEF/MachO/Binary.h"
#include "LIEF/MachO/Symbol.h"
#include "LIEF/MachO/Segment.h"
#include "LIEF/MachO/Section.h"
#include "LIEF/MachO/LoadCommand.h"
#include "LIEF/MachO/Header.h"
#endif

```

`KDemu/include/LIEF/LIEF/MachO.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_H
#define LIEF_MACHO_H

#include "LIEF/config.h"

#if defined(LIEF_MACHO_SUPPORT)

#include "LIEF/MachO/Binary.hpp"
#include "LIEF/MachO/BinaryParser.hpp"
#include "LIEF/MachO/BindingInfo.hpp"
#include "LIEF/MachO/BuildToolVersion.hpp"
#include "LIEF/MachO/BuildVersion.hpp"
#include "LIEF/MachO/Builder.hpp"
#include "LIEF/MachO/ChainedBindingInfo.hpp"
#include "LIEF/MachO/CodeSignature.hpp"
#include "LIEF/MachO/CodeSignatureDir.hpp"
#include "LIEF/MachO/DataCodeEntry.hpp"
#include "LIEF/MachO/DataInCode.hpp"
#include "LIEF/MachO/DyldBindingInfo.hpp"
#include "LIEF/MachO/DyldChainedFixups.hpp"
#include "LIEF/MachO/DyldEnvironment.hpp"
#include "LIEF/MachO/DyldExportsTrie.hpp"
#include "LIEF/MachO/DyldInfo.hpp"
#include "LIEF/MachO/DylibCommand.hpp"
#include "LIEF/MachO/DylinkerCommand.hpp"
#include "LIEF/MachO/DynamicSymbolCommand.hpp"
#include "LIEF/MachO/EncryptionInfo.hpp"
#include "LIEF/MachO/EnumToString.hpp"
#include "LIEF/MachO/ExportInfo.hpp"
#include "LIEF/MachO/FatBinary.hpp"
#include "LIEF/MachO/FilesetCommand.hpp"
#include "LIEF/MachO/FunctionStarts.hpp"
#include "LIEF/MachO/Header.hpp"
#include "LIEF/MachO/LinkEdit.hpp"
#include "LIEF/MachO/LinkerOptHint.hpp"
#include "LIEF/MachO/LoadCommand.hpp"
#include "LIEF/MachO/MainCommand.hpp"
#include "LIEF/MachO/Parser.hpp"
#include "LIEF/MachO/ParserConfig.hpp"
#include "LIEF/MachO/RPathCommand.hpp"
#include "LIEF/MachO/Relocation.hpp"
#include "LIEF/MachO/RelocationDyld.hpp"
#include "LIEF/MachO/RelocationFixup.hpp"
#include "LIEF/MachO/RelocationObject.hpp"
#include "LIEF/MachO/Section.hpp"
#include "LIEF/MachO/SegmentCommand.hpp"
#include "LIEF/MachO/SegmentSplitInfo.hpp"
#include "LIEF/MachO/SourceVersion.hpp"
#include "LIEF/MachO/SubFramework.hpp"
#include "LIEF/MachO/Symbol.hpp"
#include "LIEF/MachO/SymbolCommand.hpp"
#include "LIEF/MachO/ThreadCommand.hpp"
#include "LIEF/MachO/TwoLevelHints.hpp"
#include "LIEF/MachO/UUIDCommand.hpp"
#include "LIEF/MachO/UnknownCommand.hpp"
#include "LIEF/MachO/VersionMin.hpp"
#include "LIEF/MachO/enums.hpp"
#include "LIEF/MachO/hash.hpp"
#include "LIEF/MachO/json.hpp"
#include "LIEF/MachO/type_traits.hpp"
#include "LIEF/MachO/utils.hpp"

#include "LIEF/ObjC/Metadata.hpp"

#endif
#endif

```

`KDemu/include/LIEF/LIEF/MachO/Binary.h`:

```h
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef C_LIEF_MACHO_BINARY_H_
#define C_LIEF_MACHO_BINARY_H_

#include <stdint.h>

#include "LIEF/visibility.h"

#include "LIEF/MachO/Header.h"
#include "LIEF/MachO/LoadCommand.h"
#include "LIEF/MachO/Symbol.h"
#include "LIEF/MachO/Section.h"
#include "LIEF/MachO/Segment.h"

#ifdef __cplusplus
extern "C" {
#endif

/** @brief LIEF::MachO::Binary C Handler */
struct Macho_Binary_t {
  void*               handler;
  uint64_t            imagebase;
  Macho_Header_t      header;
  Macho_Command_t**   commands;
  Macho_Symbol_t**    symbols;
  Macho_Section_t**   sections;
  Macho_Segment_t**   segments;

};

typedef struct Macho_Binary_t Macho_Binary_t;

/** @brief Wrapper on LIEF::MachO::Parser::parse */
LIEF_API Macho_Binary_t** macho_parse(const char *file);

LIEF_API void macho_binaries_destroy(Macho_Binary_t** binaries);

#ifdef __cplusplus
}
#endif


#endif

```

`KDemu/include/LIEF/LIEF/MachO/Binary.hpp`:

```hpp

/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_BINARY_H
#define LIEF_MACHO_BINARY_H

#include <vector>
#include <map>
#include <memory>

#include "LIEF/MachO/LoadCommand.hpp"
#include "LIEF/visibility.h"

#include "LIEF/Abstract/Binary.hpp"

#include "LIEF/iterators.hpp"
#include "LIEF/MachO/Header.hpp"
#include "LIEF/errors.hpp"

namespace LIEF {

namespace objc {
class Metadata;
}

//! Namespace related to the LIEF's Mach-O module
namespace MachO {

class BinaryParser;
class BuildVersion;
class Builder;
class CodeSignature;
class CodeSignatureDir;
class DataInCode;
class DyldChainedFixups;
class DyldEnvironment;
class DyldExportsTrie;
class DyldInfo;
class DylibCommand;
class DylinkerCommand;
class DynamicSymbolCommand;
class EncryptionInfo;
class ExportInfo;
class FunctionStarts;
class Header;
class LinkerOptHint;
class MainCommand;
class Parser;
class RPathCommand;
class Relocation;
class Section;
class SegmentCommand;
class SegmentSplitInfo;
class SourceVersion;
class SubFramework;
class Symbol;
class SymbolCommand;
class ThreadCommand;
class TwoLevelHints;
class UUIDCommand;
class VersionMin;

//! Class which represents a MachO binary
class LIEF_API Binary : public LIEF::Binary  {

  friend class Parser;
  friend class BinaryParser;
  friend class Builder;
  friend class DyldInfo;

  public:
  struct range_t {
    uint64_t start = 0;
    uint64_t end   = 0;
  };

  //! Internal container for storing Mach-O LoadCommand
  using commands_t = std::vector<std::unique_ptr<LoadCommand>>;

  //! Iterator that outputs LoadCommand&
  using it_commands = ref_iterator<commands_t&, LoadCommand*>;

  //! Iterator that outputs const LoadCommand&
  using it_const_commands = const_ref_iterator<const commands_t&, LoadCommand*>;

  //! Internal container for storing Mach-O Symbol
  using symbols_t = std::vector<std::unique_ptr<Symbol>>;

  //! Iterator that outputs Symbol&
  using it_symbols = ref_iterator<symbols_t&, Symbol*>;

  //! Iterator that outputs const Symbol&
  using it_const_symbols = const_ref_iterator<const symbols_t&, const Symbol*>;

  //! Iterator that outputs exported Symbol&
  using it_exported_symbols = filter_iterator<symbols_t&, Symbol*>;

  //! Iterator that outputs exported const Symbol&
  using it_const_exported_symbols = const_filter_iterator<const symbols_t&, const Symbol*>;

  //! Iterator that outputs imported Symbol&
  using it_imported_symbols = filter_iterator<symbols_t&, Symbol*>;

  //! Iterator that outputs imported const Symbol&
  using it_const_imported_symbols = const_filter_iterator<const symbols_t&, const Symbol*>;

  //! Internal container for caching Mach-O Section
  using sections_cache_t = std::vector<Section*>;

  //! Iterator that outputs Section&
  using it_sections = ref_iterator<sections_cache_t&>;

  //! Iterator that outputs const Section&
  using it_const_sections = const_ref_iterator<const sections_cache_t&>;

  //! Internal container for storing Mach-O SegmentCommand
  using segments_cache_t = std::vector<SegmentCommand*>;

  //! Iterator that outputs SegmentCommand&
  using it_segments = ref_iterator<segments_cache_t&>;

  //! Iterator that outputs const SegmentCommand&
  using it_const_segments = const_ref_iterator<const segments_cache_t&>;

  //! Internal container for storing Mach-O DylibCommand
  using libraries_cache_t = std::vector<DylibCommand*>;

  //! Iterator that outputs DylibCommand&
  using it_libraries = ref_iterator<libraries_cache_t&>;

  //! Iterator that outputs const DylibCommand&
  using it_const_libraries = const_ref_iterator<const libraries_cache_t&>;

  //! Internal container for storing Mach-O Fileset Binary
  using fileset_binaries_t = std::vector<std::unique_ptr<Binary>>;

  //! Iterator that outputs Binary&
  using it_fileset_binaries = ref_iterator<fileset_binaries_t&, Binary*>;

  //! Iterator that outputs const Binary&
  using it_const_fileset_binaries = const_ref_iterator<const fileset_binaries_t&, Binary*>;

  struct KeyCmp {
    bool operator() (const Relocation* lhs, const Relocation* rhs) const;
  };

  //! Internal container that store all the relocations
  //! found in a Mach-O. The relocations are actually owned
  //! by Section & SegmentCommand and these references are used for convenience
  using relocations_t = std::set<Relocation*, KeyCmp>;

  //! Iterator which outputs Relocation&
  using it_relocations = ref_iterator<relocations_t&, Relocation*>;

  //! Iterator which outputs const Relocation&
  using it_const_relocations = const_ref_iterator<const relocations_t&, const Relocation*>;

  //! Iterator which outputs RPathCommand&
  using it_rpaths = filter_iterator<commands_t&, RPathCommand*>;

  //! Iterator which outputs const RPathCommand&
  using it_const_rpaths = const_filter_iterator<const commands_t&, const RPathCommand*>;

  public:
  Binary(const Binary&) = delete;
  Binary& operator=(const Binary&) = delete;

  //! Return a reference to the MachO::Header
  Header& header() {
    return header_;
  }

  const Header& header() const {
    return header_;
  }

  //! Return an iterator over the MachO LoadCommand present
  //! in the binary
  it_commands commands() {
    return commands_;
  }

  it_const_commands commands() const {
    return commands_;
  }

  //! Return an iterator over the MachO::Binary associated
  //! with the LoadCommand::TYPE::FILESET_ENTRY commands
  it_fileset_binaries filesets() {
    return filesets_;
  }

  it_const_fileset_binaries filesets() const {
    return filesets_;
  }

  //! Return binary's @link MachO::Symbol symbols @endlink
  it_symbols symbols() {
    return symbols_;
  }
  it_const_symbols symbols() const {
    return symbols_;
  }

  //! Check if a symbol with the given name exists
  bool has_symbol(const std::string& name) const {
    return get_symbol(name) != nullptr;
  }

  //! Return Symbol from the given name. If the symbol does not
  //! exists, it returns a null pointer
  const Symbol* get_symbol(const std::string& name) const;
  Symbol* get_symbol(const std::string& name);

  //! Check if the given symbol is exported
  static bool is_exported(const Symbol& symbol);

  //! Return binary's exported symbols (iterator over LIEF::MachO::Symbol)
  it_exported_symbols exported_symbols() {
    return {symbols_, [] (const std::unique_ptr<Symbol>& symbol) {
      return is_exported(*symbol); }
    };
  }
  it_const_exported_symbols exported_symbols() const {
    return {symbols_, [] (const std::unique_ptr<Symbol>& symbol) {
      return is_exported(*symbol);
    }};
  }

  //! Check if the given symbol is an imported one
  static bool is_imported(const Symbol& symbol);

  //! Return binary's imported symbols (iterator over LIEF::MachO::Symbol)
  it_imported_symbols imported_symbols() {
    return {symbols_, [] (const std::unique_ptr<Symbol>& symbol) {
      return is_imported(*symbol);
    }};
  }

  it_const_imported_symbols imported_symbols() const {
    return {symbols_, [] (const std::unique_ptr<Symbol>& symbol) {
      return is_imported(*symbol);
    }};
  }

  //! Return binary imported libraries (MachO::DylibCommand)
  it_libraries libraries() {
    return libraries_;
  }

  it_const_libraries libraries() const {
    return libraries_;
  }

  //! Return an iterator over the SegmentCommand
  it_segments segments() {
    return segments_;
  }
  it_const_segments segments() const {
    return segments_;
  }

  //! Return an iterator over the MachO::Section
  it_sections sections() {
    return sections_;
  }
  it_const_sections sections() const {
    return sections_;
  }

  //! Return an iterator over the MachO::Relocation
  it_relocations       relocations();
  it_const_relocations relocations() const;

  //! Reconstruct the binary object and write the result in the given `filename`
  //!
  //! @param filename Path to write the reconstructed binary
  void write(const std::string& filename) override;

  //! Reconstruct the binary object and write the result in the given `os` stream
  //!
  //! @param os Output stream to write the reconstructed binary
  void write(std::ostream& os) override;

  //! Reconstruct the binary object and return its content as bytes
  std::vector<uint8_t> raw();

  //! Check if the current binary has the given MachO::LoadCommand::TYPE
  bool has(LoadCommand::TYPE type) const;

  //! Return the LoadCommand associated with the given LoadCommand::TYPE
  //! or a nullptr if the command can't be found.
  const LoadCommand* get(LoadCommand::TYPE type) const;
  LoadCommand* get(LoadCommand::TYPE type);

  //! Insert a new LoadCommand
  LoadCommand* add(const LoadCommand& command);

  //! Insert a new LoadCommand at the specified ``index``
  LoadCommand* add(const LoadCommand& command, size_t index);

  //! Insert the given DylibCommand
  LoadCommand* add(const DylibCommand& library);

  //! Add a new LC_SEGMENT command from the given SegmentCommand
  LoadCommand* add(const SegmentCommand& segment);

  //! Insert a new shared library through a ``LC_LOAD_DYLIB`` command
  LoadCommand* add_library(const std::string& name);

  //! Add a new MachO::Section in the __TEXT segment
  Section* add_section(const Section& section);

  //! Add a section in the given MachO::SegmentCommand.
  //!
  //! @warning This method may corrupt the file if the segment is not the first one
  //!          nor the last one
  Section* add_section(const SegmentCommand& segment, const Section& section);

  //! Remove the section with the name provided in the first parameter.
  //!
  //! @param name     Name of the MachO::Section to remove
  //! @param clear    If ``true`` clear the content of the section before removing
  void remove_section(const std::string& name, bool clear = false) override;

  //! Remove the section from the segment with the name
  //! given in the first parameter and with the section's name provided in the
  //! second parameter
  //!
  //! @param segname     Name of the MachO::Segment
  //! @param secname     Name of the MachO::Section to remove
  //! @param clear       If ``true`` clear the content of the section before removing
  void remove_section(const std::string& segname, const std::string& secname, bool clear = false);

  //! Remove the given LoadCommand
  bool remove(const LoadCommand& command);

  //! Remove **all** LoadCommand with the given type (MachO::LoadCommand::TYPE)
  bool remove(LoadCommand::TYPE type);

  //! Remove the Load Command at the provided ``index``
  bool remove_command(size_t index);

  //! Remove the LC_SIGNATURE command
  bool remove_signature();

  //! Extend the **size** of the given LoadCommand
  bool extend(const LoadCommand& command, uint64_t size);

  //! Extend the **content** of the given SegmentCommand
  bool extend_segment(const SegmentCommand& segment, size_t size);

  //! Remove the ``PIE`` flag
  bool disable_pie();

  //! Return the binary's imagebase. ``0`` if not relevant
  uint64_t imagebase() const override;

  //! Size of the binary in memory when mapped by the loader (``dyld``)
  uint64_t virtual_size() const;

  //! Return the binary's loader (e.g. ``/usr/lib/dyld``) or an
  //! empty string if the binary does not use a loader/linker
  std::string loader() const;

  //! Check if a section with the given name exists
  bool has_section(const std::string& name) const {
    return get_section(name) != nullptr;
  }

  //! Return the section from the given name of a nullptr
  //! if the section can't be found.
  Section* get_section(const std::string& name);

  //! Return the section from the given name or a nullptr
  //! if the section can't be found
  const Section* get_section(const std::string& name) const;

  //! Return the section from the segment with the name
  //! given in the first parameter and with the section's name provided in the
  //! second parameter. If the section cannot be found, it returns a nullptr
  Section* get_section(const std::string& segname, const std::string& secname);

  const Section* get_section(const std::string& segname, const std::string& secname) const;

  //! Check if a segment with the given name exists
  bool has_segment(const std::string& name) const {
    return get_segment(name) != nullptr;
  }

  //! Return the segment from the given name
  const SegmentCommand* get_segment(const std::string& name) const;

  //! Return the segment from the given name
  SegmentCommand* get_segment(const std::string& name);

  //! Remove the symbol with the given name
  bool remove_symbol(const std::string& name);

  //! Remove the given symbol
  bool remove(const Symbol& sym);

  //! Check if the given symbol can be safely removed.
  bool can_remove(const Symbol& sym) const;

  //! Check if the MachO::Symbol with the given name can be safely removed.
  bool can_remove_symbol(const std::string& name) const;

  //! Remove the given MachO::Symbol with the given name from the export table
  bool unexport(const std::string& name);

  //! Remove the given symbol from the export table
  bool unexport(const Symbol& sym);

  //! Return the MachO::Section that encompasses the provided offset.
  //! If a section can't be found, it returns a null pointer (``nullptr``)
  Section* section_from_offset(uint64_t offset);
  const Section* section_from_offset(uint64_t offset) const;

  //! Return the MachO::Section that encompasses the provided virtual address.
  //! If a section can't be found, it returns a null pointer (``nullptr``)
  Section* section_from_virtual_address(uint64_t virtual_address);
  const Section* section_from_virtual_address(uint64_t virtual_address) const;

  //! Convert a virtual address to an offset in the file
  result<uint64_t> virtual_address_to_offset(uint64_t virtual_address) const;

  //! Convert the given offset into a virtual address.
  //!
  //! @param[in] offset    The offset to convert.
  //! @param[in] slide     If not 0, it will replace the default base address (if any)
  result<uint64_t> offset_to_virtual_address(uint64_t offset, uint64_t slide = 0) const override;

  //! Return the binary's SegmentCommand that encompasses the provided offset
  //!
  //! If a SegmentCommand can't be found it returns a null pointer (``nullptr``).
  SegmentCommand* segment_from_offset(uint64_t offset);
  const SegmentCommand* segment_from_offset(uint64_t offset) const;

  //! Return the index of the given SegmentCommand
  size_t segment_index(const SegmentCommand& segment) const;

  //! Return binary's *fat offset*. ``0`` if not relevant.
  uint64_t fat_offset() const {
    return fat_offset_;
  }

  //! Return the binary's SegmentCommand which encompasses the given virtual address
  //! or a nullptr if not found.
  SegmentCommand* segment_from_virtual_address(uint64_t virtual_address);
  const SegmentCommand* segment_from_virtual_address(uint64_t virtual_address) const;

  //! Return the range of virtual addresses
  range_t va_ranges() const;

  //! Return the range of offsets
  range_t off_ranges() const;

  //! Check if the given address is encompassed in the
  //! binary's virtual addresses range
  bool is_valid_addr(uint64_t address) const;

  //! Method so that the ``visitor`` can visit us
  void accept(LIEF::Visitor& visitor) const override;

  std::ostream& print(std::ostream& os) const override;

  //! Patch the content at virtual address @p address with @p patch_value
  //!
  //! @param[in] address       Address to patch
  //! @param[in] patch_value   Patch to apply
  //! @param[in] addr_type     Specify if the address should be used as
  //!                          an absolute virtual address or an RVA
  void patch_address(uint64_t address, const std::vector<uint8_t>& patch_value,
                     LIEF::Binary::VA_TYPES addr_type = LIEF::Binary::VA_TYPES::AUTO) override;

  //! Patch the address with the given value
  //!
  //! @param[in] address       Address to patch
  //! @param[in] patch_value   Patch to apply
  //! @param[in] size          Size of the value in **bytes** (1, 2, ... 8)
  //! @param[in] addr_type     Specify if the address should be used as
  //!                          an absolute virtual address or an RVA
  void patch_address(uint64_t address, uint64_t patch_value,
                     size_t size = sizeof(uint64_t),
                     LIEF::Binary::VA_TYPES addr_type = LIEF::Binary::VA_TYPES::AUTO) override;

  //! Return the content located at virtual address
  span<const uint8_t> get_content_from_virtual_address(
      uint64_t virtual_address, uint64_t size,
      Binary::VA_TYPES addr_type = Binary::VA_TYPES::AUTO) const override;

  //! The binary entrypoint
  uint64_t entrypoint() const override;

  //! Check if the binary is position independent
  bool is_pie() const override {
    return header().has(Header::FLAGS::PIE);
  }

  //! Check if the binary uses ``NX`` protection
  bool has_nx() const override {
    return !has_nx_stack();
  }

  /// Return True if the **heap** is flagged as non-executable. False otherwise
  bool has_nx_stack() const {
    return !header().has(Header::FLAGS::ALLOW_STACK_EXECUTION);
  }

  /// Return True if the **stack** is flagged as non-executable. False otherwise
  bool has_nx_heap() const {
    return !header().has(Header::FLAGS::NO_HEAP_EXECUTION);
  }

  //! ``true`` if the binary has an entrypoint.
  //!
  //! Basically for libraries it will return ``false``
  bool has_entrypoint() const {
    return has_main_command() || has_thread_command();
  }

  //! ``true`` if the binary has a MachO::UUIDCommand command.
  bool has_uuid() const;

  //! Return the MachO::UUIDCommand if present, a nullptr otherwise.
  UUIDCommand* uuid();
  const UUIDCommand* uuid() const;

  //! ``true`` if the binary has a MachO::MainCommand command.
  bool has_main_command() const;

  //! Return the MachO::MainCommand if present, a nullptr otherwise.
  MainCommand* main_command();
  const MainCommand* main_command() const;

  //! ``true`` if the binary has a MachO::DylinkerCommand.
  bool has_dylinker() const;

  //! Return the MachO::DylinkerCommand if present, a nullptr otherwise.
  DylinkerCommand* dylinker();
  const DylinkerCommand* dylinker() const;

  //! ``true`` if the binary has a MachO::DyldInfo command.
  bool has_dyld_info() const;

  //! Return the MachO::Dyld command if present, a nullptr otherwise.
  DyldInfo* dyld_info();
  const DyldInfo* dyld_info() const;

  //! ``true`` if the binary has a MachO::FunctionStarts command.
  bool has_function_starts() const;

  //! Return the MachO::FunctionStarts command if present, a nullptr otherwise.
  FunctionStarts* function_starts();
  const FunctionStarts* function_starts() const;

  //! ``true`` if the binary has a MachO::SourceVersion command.
  bool has_source_version() const;

  //! Return the MachO::SourceVersion command if present, a nullptr otherwise.
  SourceVersion* source_version();
  const SourceVersion* source_version() const;

  //! ``true`` if the binary has a MachO::VersionMin command.
  bool has_version_min() const;

  //! Return the MachO::VersionMin command if present, a nullptr otherwise.
  VersionMin* version_min();
  const VersionMin* version_min() const;

  //! ``true`` if the binary has a MachO::ThreadCommand command.
  bool has_thread_command() const;

  //! Return the MachO::ThreadCommand command if present, a nullptr otherwise.
  ThreadCommand* thread_command();
  const ThreadCommand* thread_command() const;

  //! ``true`` if the binary has a MachO::RPathCommand command.
  bool has_rpath() const;

  //! Return the MachO::RPathCommand command if present, a nullptr otherwise.
  RPathCommand* rpath();
  const RPathCommand* rpath() const;

  //! Iterator over **all** the MachO::RPathCommand commands.
  it_rpaths rpaths();
  it_const_rpaths rpaths() const;

  //! ``true`` if the binary has a MachO::SymbolCommand command.
  bool has_symbol_command() const;

  //! Return the MachO::SymbolCommand if present, a nullptr otherwise.
  SymbolCommand* symbol_command();
  const SymbolCommand* symbol_command() const;

  //! ``true`` if the binary has a MachO::DynamicSymbolCommand command.
  bool has_dynamic_symbol_command() const;

  //! Return the MachO::SymbolCommand if present, a nullptr otherwise.
  DynamicSymbolCommand* dynamic_symbol_command();
  const DynamicSymbolCommand* dynamic_symbol_command() const;

  //! ``true`` if the binary is signed with `LC_CODE_SIGNATURE` command
  bool has_code_signature() const;

  //! Return the MachO::CodeSignature if present, a nullptr otherwise.
  CodeSignature* code_signature();
  const CodeSignature* code_signature() const;

  //! ``true`` if the binary is signed with the command `DYLIB_CODE_SIGN_DRS`
  bool has_code_signature_dir() const;

  //! Return the MachO::CodeSignatureDir if present, a nullptr otherwise.
  CodeSignatureDir* code_signature_dir();
  const CodeSignatureDir* code_signature_dir() const;

  //! ``true`` if the binary has a MachO::DataInCode command.
  bool has_data_in_code() const;

  //! Return the MachO::DataInCode if present, a nullptr otherwise.
  DataInCode* data_in_code();
  const DataInCode* data_in_code() const;

  //! ``true`` if the binary has segment split info.
  bool has_segment_split_info() const;

  //! Return the MachO::SegmentSplitInfo if present, a nullptr otherwise.
  SegmentSplitInfo* segment_split_info();
  const SegmentSplitInfo* segment_split_info() const;

  //! ``true`` if the binary has a sub framework command.
  bool has_sub_framework() const;

  //! ``true`` if the binary has Encryption Info.
  bool has_encryption_info() const;

  //! Return the MachO::DyldEnvironment if present, a nullptr otherwise.
  EncryptionInfo* encryption_info();
  const EncryptionInfo* encryption_info() const;

  //! Return the MachO::SubFramework if present, a nullptr otherwise.
  SubFramework* sub_framework();
  const SubFramework* sub_framework() const;

  //! ``true`` if the binary has Dyld envrionment variables.
  bool has_dyld_environment() const;

  //! Return the MachO::DyldEnvironment if present, a nullptr otherwise
  DyldEnvironment* dyld_environment();
  const DyldEnvironment* dyld_environment() const;

  //! ``true`` if the binary has the BuildVersion command.
  bool has_build_version() const;

  //! Return the MachO::BuildVersion if present, a nullptr otherwise.
  BuildVersion* build_version();
  const BuildVersion* build_version() const;

  //! ``true`` if the binary has the command LC_DYLD_CHAINED_FIXUPS.
  bool has_dyld_chained_fixups() const;

  //! Return the MachO::DyldChainedFixups if present, a nullptr otherwise.
  DyldChainedFixups* dyld_chained_fixups();
  const DyldChainedFixups* dyld_chained_fixups() const;

  //! ``true`` if the binary has the command LC_DYLD_CHAINED_FIXUPS.
  bool has_dyld_exports_trie() const;

  //! Return the MachO::DyldChainedFixups if present, a nullptr otherwise.
  DyldExportsTrie* dyld_exports_trie();
  const DyldExportsTrie* dyld_exports_trie() const;

  //! ``true`` if the binary has the command LC_TWO_LEVEL_HINTS.
  bool has_two_level_hints() const;

  //! Return the MachO::DyldChainedFixups if present, a nullptr otherwise.
  TwoLevelHints* two_level_hints();
  const TwoLevelHints* two_level_hints() const;

  //! ``true`` if the binary has the command LC_LINKER_OPTIMIZATION_HINT.
  bool has_linker_opt_hint() const;

  //! Return the MachO::LinkerOptHint if present, a nullptr otherwise.
  LinkerOptHint* linker_opt_hint();
  const LinkerOptHint* linker_opt_hint() const;

  //! Add a symbol in the export trie of the current binary
  ExportInfo* add_exported_function(uint64_t address, const std::string& name);

  //! Add a symbol in LC_SYMTAB command of the current binary
  Symbol* add_local_symbol(uint64_t address, const std::string& name);

  //! Return Objective-C metadata if present
  std::unique_ptr<objc::Metadata> objc_metadata() const;

  template<class T>
  LIEF_LOCAL bool has_command() const;

  template<class T>
  LIEF_LOCAL T* command();

  template<class T>
  LIEF_LOCAL const T* command() const;

  template<class T>
  LIEF_LOCAL size_t count_commands() const;

  template<class CMD, class Func>
  LIEF_LOCAL Binary& for_commands(Func f);

  LoadCommand* operator[](LoadCommand::TYPE type) {
    return get(type);
  }
  const LoadCommand* operator[](LoadCommand::TYPE type) const {
    return get(type);
  }

  //! Return the list of the MachO's constructors
  LIEF::Binary::functions_t ctor_functions() const override;

  //! Return all the functions found in this MachO
  LIEF::Binary::functions_t functions() const;

  //! Return the functions found in the ``__unwind_info`` section
  LIEF::Binary::functions_t unwind_functions() const;

  //! ``true`` if the binary has a LoadCommand::TYPE::FILESET_ENTRY command
  bool has_filesets() const;

  //! Name associated with the LC_FILESET_ENTRY binary
  const std::string& fileset_name() const {
    return fileset_name_;
  }

  ~Binary() override;

  //! Shift the content located right after the Load commands table.
  //! This operation can be used to add a new command
  ok_error_t shift(size_t value);

  //! Shift the position on the __LINKEDIT data by `width`
  ok_error_t shift_linkedit(size_t width);

  //! If this Mach-O binary has been parsed from memory,
  //! it returns the in-memory base address of this binary.
  //!
  //! Otherwise, it returns 0
  uint64_t memory_base_address() const {
    return in_memory_base_addr_;
  }

  // Check if the binary is supporting ARM64 pointer authentication (arm64e)
  bool support_arm64_ptr_auth() const {
    static constexpr auto CPU_SUBTYPE_ARM64E = 2;
    return header().cpu_type() == Header::CPU_TYPE::ARM64 &&
           (header().cpu_subtype() & ~Header::CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM64E;
  }

  uint32_t page_size() const;

  static bool classof(const LIEF::Binary* bin) {
    return bin->format() == Binary::FORMATS::MACHO;
  }

  span<const uint8_t> overlay() const {
    return overlay_;
  }

  private:
  //! Default constructor
  Binary();

  void shift_command(size_t width, uint64_t from_offset);

  //! Insert a Segment command in the cache field (segments_)
  //! and keep a consistent state of the indexes.
  size_t add_cached_segment(SegmentCommand& segment);
  void refresh_seg_offset();

  template<class T>
  LIEF_LOCAL ok_error_t patch_relocation(Relocation& relocation, uint64_t from, uint64_t shift);

  LIEF::Header              get_abstract_header() const override;
  LIEF::Binary::sections_t          get_abstract_sections() override;
  LIEF::Binary::symbols_t           get_abstract_symbols() override;
  LIEF::Binary::relocations_t       get_abstract_relocations() override;
  LIEF::Binary::functions_t get_abstract_exported_functions() const override;
  LIEF::Binary::functions_t get_abstract_imported_functions() const override;
  std::vector<std::string>  get_abstract_imported_libraries() const override;

  relocations_t& relocations_list() {
    return this->relocations_;
  }

  const relocations_t& relocations_list() const {
    return this->relocations_;
  }

  size_t pointer_size() const {
    return this->is64_ ? sizeof(uint64_t) : sizeof(uint32_t);
  }

  bool        is64_ = true;
  Header      header_;
  commands_t  commands_;
  symbols_t   symbols_;

  // Same purpose as sections_cache_t
  libraries_cache_t libraries_;

  // The sections are owned by the SegmentCommand object.
  // This attribute is a cache to speed-up the iteration
  sections_cache_t sections_;

  // Same purpose as sections_cache_t
  segments_cache_t segments_;

  fileset_binaries_t filesets_;

  // Cached relocations from segment / sections
  mutable relocations_t relocations_;
  int32_t available_command_space_ = 0;

  // This is used to improve performances of
  // offset_to_virtual_address
  std::map<uint64_t, SegmentCommand*> offset_seg_;

  protected:
  uint64_t fat_offset_ = 0;
  uint64_t fileset_offset_ = 0;
  uint64_t in_memory_base_addr_ = 0;
  std::string fileset_name_;
  std::vector<uint8_t> overlay_;
};

} // namespace MachO
} // namespace LIEF
#endif

```

`KDemu/include/LIEF/LIEF/MachO/BinaryParser.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_BINARY_PARSER_H
#define LIEF_MACHO_BINARY_PARSER_H
#include <memory>
#include <string>
#include <vector>
#include <limits>
#include <set>
#include <map>
#include <unordered_map>

#include "LIEF/visibility.h"
#include "LIEF/errors.hpp"

#include "LIEF/Abstract/Parser.hpp"

#include "LIEF/MachO/enums.hpp"
#include "LIEF/MachO/DyldChainedFormat.hpp"
#include "LIEF/MachO/ParserConfig.hpp"
#include "LIEF/MachO/DyldBindingInfo.hpp"

namespace LIEF {
class BinaryStream;
class SpanStream;

namespace MachO {
class ChainedBindingInfo;
class CodeSignature;
class CodeSignatureDir;
class DataInCode;
class DyldChainedFixups;
class DylibCommand;
class DynamicSymbolCommand;
class ExportInfo;
class FunctionStarts;
class LinkerOptHint;
class Parser;
class Section;
class SegmentCommand;
class SegmentSplitInfo;
class Symbol;
class SymbolCommand;
class TwoLevelHints;
struct ParserConfig;


namespace details {
struct dyld_chained_starts_in_segment;
struct dyld_chained_fixups_header;
union dyld_chained_ptr_arm64e;
union dyld_chained_ptr_generic64;
union dyld_chained_ptr_generic32;
}

//! Class used to parse a **single** binary (i.e. non-FAT)
//!
//! @warning This class should not be directly used.
//!
//! @see MachO::Parser
class LIEF_API BinaryParser : public LIEF::Parser {

  friend class MachO::Parser;

  //! Maximum number of relocations
  constexpr static size_t MAX_RELOCATIONS = (std::numeric_limits<uint16_t>::max)();

  //! Maximum number of MachO LoadCommand
  constexpr static size_t MAX_COMMANDS = (std::numeric_limits<uint16_t>::max)();

  public:
  static std::unique_ptr<Binary> parse(const std::string& file);
  static std::unique_ptr<Binary> parse(const std::string& file, const ParserConfig& conf);
  static std::unique_ptr<Binary> parse(const std::vector<uint8_t>& data,
                                       const ParserConfig& conf = ParserConfig::deep());

  static std::unique_ptr<Binary> parse(const std::vector<uint8_t>& data, uint64_t fat_offset,
                                       const ParserConfig& conf = ParserConfig::deep());

  static std::unique_ptr<Binary> parse(std::unique_ptr<BinaryStream> stream, uint64_t fat_offset,
                                       const ParserConfig& conf);

  BinaryParser& operator=(const BinaryParser& copy) = delete;
  BinaryParser(const BinaryParser& copy) = delete;

  ~BinaryParser() override;

  private:
  using exports_list_t = std::vector<std::unique_ptr<ExportInfo>>;
  BinaryParser();

  ok_error_t init_and_parse();

  template<class MACHO_T>
  ok_error_t parse();

  template<class MACHO_T>
  ok_error_t parse_header();

  template<class MACHO_T>
  ok_error_t parse_load_commands();

  template<class MACHO_T>
  ok_error_t parse_relocations(Section& section);

  // Dyld info parser
  // ================

  // Rebase
  // ------
  template<class MACHO_T>
  ok_error_t parse_dyldinfo_rebases();

  // Bindings
  // --------
  template<class MACHO_T>
  ok_error_t parse_dyldinfo_binds();

  template<class MACHO_T>
  ok_error_t parse_dyldinfo_generic_bind();

  template<class MACHO_T>
  ok_error_t parse_dyldinfo_weak_bind();

  template<class MACHO_T>
  ok_error_t parse_dyldinfo_lazy_bind();

  using it_opaque_segments = void*; // To avoid including Binary.hpp. It must contains it_opaque_segments

  template<class MACHO_T>
  ok_error_t do_bind(DyldBindingInfo::CLASS cls, uint8_t type, uint8_t segment_idx,
                     uint64_t segment_offset, const std::string& symbol_name,
                     int32_t ord, int64_t addend, bool is_weak,
                     bool is_non_weak_definition, it_opaque_segments segments_ptr, uint64_t offset = 0);


  template<class MACHO_T>
  ok_error_t do_rebase(uint8_t type, uint8_t segment_idx, uint64_t segment_offset,
                       it_opaque_segments segments);

  /*
   * This set of functions are related to the parsing of LC_DYLD_CHAINED_FIXUPS
   */

  template<class MACHO_T>
  ok_error_t parse_chained_payload(SpanStream& stream);

  template<class MACHO_T>
  ok_error_t parse_chained_import(const details::dyld_chained_fixups_header& header,
                                  SpanStream& stream, SpanStream& symbol_pool);
  template<class MACHO_T>
  ok_error_t parse_chained_fixup(const details::dyld_chained_fixups_header& header,
                                 SpanStream& stream);

  template<class MACHO_T>
  ok_error_t parse_fixup_seg(SpanStream& stream, uint32_t seg_info_offset,
                             uint64_t offset, uint32_t seg_idx);

  template<class MACHO_T>
  ok_error_t do_fixup(DYLD_CHAINED_FORMAT fmt, int32_t ord, const std::string& symbol_name,
                      int64_t addend, bool is_weak);

  template<class MACHO_T>
  ok_error_t process_fixup(SegmentCommand& segment, uint64_t chain_offset,
                           const details::dyld_chained_starts_in_segment& seg_info);

  template<class MACHO_T>
  result<uint64_t> next_chain(uint64_t chain_offset, const details::dyld_chained_starts_in_segment& seg_info);

  template<class MACHO_T>
  ok_error_t walk_chain(SegmentCommand& segment, uint64_t chain_offset,
                        const details::dyld_chained_starts_in_segment& seg_info);

  ok_error_t do_chained_fixup(SegmentCommand& segment, uint32_t chain_offset,
                              const details::dyld_chained_starts_in_segment& seg_info,
                              const details::dyld_chained_ptr_arm64e& fixup);

  ok_error_t do_chained_fixup(SegmentCommand& segment, uint32_t chain_offset,
                              const details::dyld_chained_starts_in_segment& seg_info,
                              const details::dyld_chained_ptr_generic64& fixup);

  ok_error_t do_chained_fixup(SegmentCommand& segment, uint32_t chain_offset,
                              const details::dyld_chained_starts_in_segment& seg_info,
                              const details::dyld_chained_ptr_generic32 & fixup);

  template<class MACHO_T>
  ok_error_t post_process(SymbolCommand& cmd);

  template<class MACHO_T>
  ok_error_t post_process(FunctionStarts& cmd);

  template<class MACHO_T>
  ok_error_t post_process(DataInCode& cmd);

  template<class MACHO_T>
  ok_error_t post_process(SegmentSplitInfo& cmd);

  template<class MACHO_T>
  ok_error_t post_process(DynamicSymbolCommand& cmd);

  template<class MACHO_T>
  ok_error_t post_process(LinkerOptHint& cmd);

  template<class MACHO_T>
  ok_error_t post_process(TwoLevelHints& cmd);

  template<class MACHO_T>
  ok_error_t post_process(CodeSignature& cmd);

  template<class MACHO_T>
  ok_error_t post_process(CodeSignatureDir& cmd);

  ok_error_t parse_overlay();

  // Exports
  // -------
  ok_error_t parse_dyldinfo_export();
  ok_error_t parse_dyld_exports();

  ok_error_t parse_export_trie(exports_list_t& exports, uint64_t start,
                               uint64_t end, const std::string& prefix,
                               bool* invalid_names);

  void copy_from(ChainedBindingInfo& to, ChainedBindingInfo& from);

  std::unique_ptr<BinaryStream>  stream_;
  std::unique_ptr<Binary>        binary_;
  MACHO_TYPES                    type_ = MACHO_TYPES::MH_MAGIC_64;
  bool                           is64_ = true;
  ParserConfig                   config_;
  std::set<uint64_t>             visited_;
  std::unordered_map<std::string, Symbol*> memoized_symbols_;
  std::map<uint64_t, Symbol*>    memoized_symbols_by_address_;

  std::vector<DylibCommand*> binding_libs_;
  std::set<uint64_t> dyld_reloc_addrs_;

  // Cache of DyldChainedFixups
  DyldChainedFixups* chained_fixups_ = nullptr;
};


} // namespace MachO
} // namespace LIEF
#endif

```

`KDemu/include/LIEF/LIEF/MachO/BindingInfo.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_BINDING_INFO_H
#define LIEF_MACHO_BINDING_INFO_H
#include <ostream>
#include <cstdint>

#include "LIEF/visibility.h"
#include "LIEF/Object.hpp"

namespace LIEF {
namespace MachO {
class DylibCommand;
class SegmentCommand;
class Symbol;
class BinaryParser;

//! Class that provides an interface over a *binding* operation.
//!
//! This class does not represent a structure that exists in the Mach-O format
//! specifications but it provides a *view* of a binding operation that is performed
//! by the Dyld binding bytecode (`LC_DYLD_INFO`) or the Dyld chained fixups (`DYLD_CHAINED_FIXUPS`)
//!
//! See: LIEF::MachO::ChainedBindingInfo, LIEF::MachO::DyldBindingInfo
class LIEF_API BindingInfo : public Object {

  friend class BinaryParser;

  public:
  enum class TYPES {
    UNKNOWN = 0,
    DYLD_INFO,    /// Binding associated with the Dyld info opcodes
    CHAINED,      /// Binding associated with the chained fixups
    CHAINED_LIST, /// Internal use
  };

  BindingInfo() = default;

  BindingInfo(const BindingInfo& other);
  void swap(BindingInfo& other) noexcept;

  //! Check if a MachO::SegmentCommand is associated with this binding
  bool has_segment() const {
    return segment_ != nullptr;
  }

  //! The MachO::SegmentCommand associated with the BindingInfo or
  //! a nullptr of it is not bind to a SegmentCommand
  const SegmentCommand* segment() const {
    return segment_;
  }
  SegmentCommand* segment() {
    return segment_;
  }

  //! Check if a MachO::DylibCommand is tied with the BindingInfo
  bool has_library() const {
    return library_ != nullptr;
  }

  //! MachO::DylibCommand associated with the BindingInfo or a nullptr
  //! if not present
  const DylibCommand* library() const {
    return library_;
  }
  DylibCommand* library() {
    return library_;
  }

  //! Check if a MachO::Symbol is associated with the BindingInfo
  bool has_symbol() const {
    return symbol_ != nullptr;
  }

  //! MachO::Symbol associated with the BindingInfo or
  //! a nullptr if not present
  const Symbol* symbol() const {
    return symbol_;
  }
  Symbol* symbol() {
    return symbol_;
  }

  //! Address of the binding
  virtual uint64_t address() const {
    return address_;
  }

  virtual void address(uint64_t addr) {
    address_ = addr;
  }

  int32_t library_ordinal() const {
    return library_ordinal_;
  }

  void library_ordinal(int32_t ordinal) {
    library_ordinal_ = ordinal;
  }

  //! Value added to the segment's virtual address when bound
  int64_t addend() const {
    return addend_;
  }

  void addend(int64_t addend) {
    addend_ = addend;
  }

  bool is_weak_import() const {
    return is_weak_import_;
  }

  void set_weak_import(bool val = true) {
    is_weak_import_ = val;
  }

  //! The type of the binding. This type provides the origin
  //! of the binding (LC_DYLD_INFO or LC_DYLD_CHAINED_FIXUPS)
  virtual TYPES type() const = 0;

  ~BindingInfo() override = default;

  void accept(Visitor& visitor) const override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const BindingInfo& binding_info);

  protected:
  SegmentCommand* segment_ = nullptr;
  Symbol*         symbol_ = nullptr;
  int32_t         library_ordinal_ = 0;
  int64_t         addend_ = 0;
  bool            is_weak_import_ = false;
  DylibCommand*   library_ = nullptr;
  uint64_t        address_ = 0;
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/MachO/BuildToolVersion.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_BUILD_TOOL_VERSION_COMMAND_H
#define LIEF_MACHO_BUILD_TOOL_VERSION_COMMAND_H
#include <ostream>
#include <array>
#include <cstdint>

#include "LIEF/Object.hpp"
#include "LIEF/visibility.h"

namespace LIEF {
namespace MachO {

namespace details {
struct build_tool_version;
}

//! Class that represents a tool's version that was
//! involved in the build of the binary
class LIEF_API BuildToolVersion : public Object {
  public:
  //! A version is an array of **3** integers
  using version_t = std::array<uint32_t, 3>;

  public:
  enum class TOOLS {
    UNKNOWN = 0,
    CLANG   = 1,
    SWIFT   = 2,
    LD      = 3,
  };

  public:
  BuildToolVersion() = default;
  BuildToolVersion(const details::build_tool_version& tool);

  //! The tools used
  TOOLS tool() const {
    return tool_;
  }

  //! Version associated with the tool
  version_t version() const {
    return version_;
  }

  ~BuildToolVersion() override = default;

  void accept(Visitor& visitor) const override;

  LIEF_API friend
  std::ostream& operator<<(std::ostream& os, const BuildToolVersion& tool);

  private:
  TOOLS tool_ = TOOLS::UNKNOWN;
  version_t version_;
};

LIEF_API const char* to_string(BuildToolVersion::TOOLS tool);

}
}
#endif

```

`KDemu/include/LIEF/LIEF/MachO/BuildVersion.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_BUILD_VERSION_COMMAND_H
#define LIEF_MACHO_BUILD_VERSION_COMMAND_H
#include <vector>
#include <ostream>
#include <array>

#include "LIEF/visibility.h"

#include "LIEF/MachO/LoadCommand.hpp"
#include "LIEF/MachO/BuildToolVersion.hpp"

namespace LIEF {
namespace MachO {

namespace details {
struct build_version_command;
}

class LIEF_API BuildVersion : public LoadCommand {
  friend class BinaryParser;

  public:
  //! Version is an array of **3** integers
  using version_t = std::array<uint32_t, 3>;

  using tools_list_t = std::vector<BuildToolVersion>;

  public:
  enum class PLATFORMS {
    UNKNOWN = 0,
    MACOS   = 1,
    IOS     = 2,
    TVOS    = 3,
    WATCHOS = 4,
  };

  public:
  BuildVersion() = default;
  BuildVersion(const details::build_version_command& version_cmd);
  BuildVersion(const PLATFORMS platform,
               const version_t &minos,
               const version_t &sdk,
               const tools_list_t &tools);

  BuildVersion& operator=(const BuildVersion& copy) = default;
  BuildVersion(const BuildVersion& copy) = default;

  std::unique_ptr<LoadCommand> clone() const override {
    return std::unique_ptr<BuildVersion>(new BuildVersion(*this));
  }

  version_t minos() const {
    return minos_;
  }

  void minos(version_t version) {
    minos_ = version;
  }

  version_t sdk() const {
    return sdk_;
  }
  void sdk(version_t version) {
    sdk_ = version;
  }

  PLATFORMS platform() const {
    return platform_;
  }
  void platform(PLATFORMS plat) {
    platform_ = plat;
  }

  const tools_list_t& tools() const {
    return tools_;
  }

  ~BuildVersion() override = default;

  void accept(Visitor& visitor) const override;

  std::ostream& print(std::ostream& os) const override;

  static bool classof(const LoadCommand* cmd) {
    return cmd->command() == LoadCommand::TYPE::BUILD_VERSION;
  }

  private:
  PLATFORMS platform_ = PLATFORMS::UNKNOWN;
  version_t minos_;
  version_t sdk_;
  tools_list_t tools_;
};

LIEF_API const char* to_string(BuildVersion::PLATFORMS e);

}
}
#endif

```

`KDemu/include/LIEF/LIEF/MachO/Builder.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_BUIDLER_H
#define LIEF_MACHO_BUIDLER_H

#include <vector>

#include "LIEF/errors.hpp"
#include "LIEF/visibility.h"

#include "LIEF/iostream.hpp"

namespace LIEF {
namespace MachO {

class Binary;
class BuildVersion;
class CodeSignature;
class CodeSignatureDir;
class DataInCode;
class DyldChainedFixups;
class DyldEnvironment;
class DyldExportsTrie;
class DyldInfo;
class DylibCommand;
class DylinkerCommand;
class DynamicSymbolCommand;
class FatBinary;
class FunctionStarts;
class LinkerOptHint;
class MainCommand;
class SegmentSplitInfo;
class SourceVersion;
class SubFramework;
class SymbolCommand;
class ThreadCommand;
class TwoLevelHints;
class VersionMin;
class RPathCommand;

//! Class used to rebuild a Mach-O file
class LIEF_API Builder {
  public:
  //! Options to tweak the building process
  struct config_t {
    bool linkedit = true;
  };

  Builder() = delete;

  static ok_error_t write(Binary& binary, const std::string& filename);
  static ok_error_t write(Binary& binary, const std::string& filename, config_t config);

  static ok_error_t write(Binary& binary, std::vector<uint8_t>& out);
  static ok_error_t write(Binary& binary, std::vector<uint8_t>& out, config_t config);

  static ok_error_t write(Binary& binary, std::ostream& out);
  static ok_error_t write(Binary& binary, std::ostream& out, config_t config);

  static ok_error_t write(FatBinary& fat, const std::string& filename);
  static ok_error_t write(FatBinary& fat, const std::string& filename, config_t config);

  static ok_error_t write(FatBinary& fat, std::vector<uint8_t>& out);
  static ok_error_t write(FatBinary& fat, std::vector<uint8_t>& out, config_t config);

  static ok_error_t write(FatBinary& fat, std::ostream& out);
  static ok_error_t write(FatBinary& fat, std::ostream& out, config_t config);

  ~Builder();
  private:
  ok_error_t build();

  const std::vector<uint8_t>& get_build();
  ok_error_t write(const std::string& filename) const;
  ok_error_t write(std::ostream& os) const;

  Builder(Binary& binary, config_t config);
  Builder(std::vector<Binary*> binaries, config_t config);

  static std::vector<uint8_t> build_raw(Binary& binary, config_t config);
  static std::vector<uint8_t> build_raw(FatBinary& binary, config_t config);

  template<typename T>
  ok_error_t build();

  ok_error_t build_fat();
  ok_error_t build_fat_header();
  ok_error_t build_header();
  ok_error_t build_load_commands();

  template<typename T>
  ok_error_t build_linkedit();

  template<typename T>
  ok_error_t build(DylibCommand& library);

  template<typename T>
  ok_error_t build(DylinkerCommand& linker);

  template<class T>
  ok_error_t build(VersionMin& version_min);

  template<class T>
  ok_error_t build(SourceVersion& source_version);

  template<class T>
  ok_error_t build(FunctionStarts& function_starts);

  template<class T>
  ok_error_t build(MainCommand& main_cmd);

  template<class T>
  ok_error_t build(RPathCommand& rpath_cmd);

  template<class T>
  ok_error_t build(DyldInfo& dyld_info);

  template<class T>
  ok_error_t build(SymbolCommand& symbol_command);

  template<class T>
  ok_error_t build(DynamicSymbolCommand& symbol_command);

  template<class T>
  ok_error_t build(DataInCode& datacode);

  template<class T>
  ok_error_t build(CodeSignature& code_signature);

  template<class T>
  ok_error_t build(SegmentSplitInfo& ssi);

  template<class T>
  ok_error_t build(SubFramework& sf);

  template<class T>
  ok_error_t build(DyldEnvironment& de);

  template<class T>
  ok_error_t build(ThreadCommand& tc);

  template<class T>
  ok_error_t build(DyldChainedFixups& fixups);

  template<class T>
  ok_error_t build(DyldExportsTrie& exports);

  template<class T>
  ok_error_t build(TwoLevelHints& two);

  template<class T>
  ok_error_t build(LinkerOptHint& opt);

  template<class T>
  ok_error_t build(CodeSignatureDir& sig);

  template <typename T>
  ok_error_t build_segments();

  template<class T>
  ok_error_t build(BuildVersion& bv);

  template <typename T>
  ok_error_t build_symbols();

  ok_error_t build_uuid();

  template <typename T>
  ok_error_t update_fixups(DyldChainedFixups& fixups);

  std::vector<Binary*> binaries_;
  Binary* binary_ = nullptr;
  mutable vector_iostream raw_;
  uint64_t linkedit_offset_ = 0;
  mutable vector_iostream linkedit_;
  config_t config_;
};

} // namespace MachO
} // namespace LIEF
#endif

```

`KDemu/include/LIEF/LIEF/MachO/ChainedBindingInfo.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_CHAINED_BINDING_INFO_H
#define LIEF_MACHO_CHAINED_BINDING_INFO_H
#include <ostream>

#include "LIEF/visibility.h"
#include "LIEF/MachO/BindingInfo.hpp"
#include "LIEF/MachO/DyldChainedFormat.hpp"

namespace LIEF {
namespace MachO {
class Symbol;
class BinaryParser;
class Builder;

namespace details {
struct dyld_chained_ptr_arm64e_bind;
struct dyld_chained_ptr_arm64e_auth_bind;
struct dyld_chained_ptr_arm64e_bind24;
struct dyld_chained_ptr_arm64e_auth_bind24;
struct dyld_chained_ptr_64_bind;
struct dyld_chained_ptr_32_bind;
}

//! This class represents a symbol binding operation associated with
//! the LC_DYLD_CHAINED_FIXUPS command.
//!
//! This class does not represent a structure that exists in the Mach-O format
//! specifications but it provides a *view* on an entry.
//!
//! @see: BindingInfo
class LIEF_API ChainedBindingInfo : public BindingInfo {

  friend class BinaryParser;
  friend class Builder;

  public:

  ChainedBindingInfo() = delete;
  explicit ChainedBindingInfo(DYLD_CHAINED_FORMAT fmt, bool is_weak);

  ChainedBindingInfo& operator=(ChainedBindingInfo other);
  ChainedBindingInfo(const ChainedBindingInfo& other);
  ChainedBindingInfo(ChainedBindingInfo&&) noexcept;

  void swap(ChainedBindingInfo& other) noexcept;

  //! Format of the imports
  DYLD_CHAINED_FORMAT format() const {
    return format_;
  }

  //! Format of the pointer
  DYLD_CHAINED_PTR_FORMAT ptr_format() const {
    return ptr_format_;
  }

  //! Original offset in the chain of this binding
  uint32_t offset() const {
    return offset_;
  }

  void offset(uint32_t offset) {
    offset_ = offset;
  }

  uint64_t address() const override {
    return /* imagebase */ address_ + offset_;
  }

  void address(uint64_t address) override {
    offset_ = address - /* imagebase */ address_;
  }

  uint64_t sign_extended_addend() const;

  BindingInfo::TYPES type() const override {
    return BindingInfo::TYPES::CHAINED;
  }

  static bool classof(const BindingInfo* info) {
    return info->type() == BindingInfo::TYPES::CHAINED;
  }

  ~ChainedBindingInfo() override {
    clear();
  }

  void accept(Visitor& visitor) const override;

  LIEF_API friend
  std::ostream& operator<<(std::ostream& os, const ChainedBindingInfo& info) {
    os << static_cast<const BindingInfo&>(info);
    return os;
  }

  private:
  void clear();
  enum class BIND_TYPES {
    UNKNOWN = 0,

    ARM64E_BIND,
    ARM64E_AUTH_BIND,

    ARM64E_BIND24,
    ARM64E_AUTH_BIND24,

    PTR64_BIND,
    PTR32_BIND,
  };

  void set(const details::dyld_chained_ptr_arm64e_bind& bind);
  void set(const details::dyld_chained_ptr_arm64e_auth_bind& bind);
  void set(const details::dyld_chained_ptr_arm64e_bind24& bind);
  void set(const details::dyld_chained_ptr_arm64e_auth_bind24& bind);
  void set(const details::dyld_chained_ptr_64_bind& bind);
  void set(const details::dyld_chained_ptr_32_bind& bind);

  DYLD_CHAINED_FORMAT format_;
  DYLD_CHAINED_PTR_FORMAT ptr_format_;
  uint32_t offset_ = 0;

  BIND_TYPES btypes_ = BIND_TYPES::UNKNOWN;

  union {
    details::dyld_chained_ptr_arm64e_bind*        arm64_bind_ = nullptr;
    details::dyld_chained_ptr_arm64e_auth_bind*   arm64_auth_bind_;
    details::dyld_chained_ptr_arm64e_bind24*      arm64_bind24_;
    details::dyld_chained_ptr_arm64e_auth_bind24* arm64_auth_bind24_;
    details::dyld_chained_ptr_64_bind*            p64_bind_;
    details::dyld_chained_ptr_32_bind*            p32_bind_;
  };
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/MachO/CodeSignature.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_CODE_SIGNATURE_COMMAND_H
#define LIEF_MACHO_CODE_SIGNATURE_COMMAND_H
#include <ostream>
#include <cstdint>

#include "LIEF/span.hpp"
#include "LIEF/visibility.h"

#include "LIEF/MachO/LoadCommand.hpp"

namespace LIEF {
namespace MachO {

class BinaryParser;
class Builder;
class LinkEdit;

namespace details {
struct linkedit_data_command;
}

class LIEF_API CodeSignature : public LoadCommand {
  friend class BinaryParser;
  friend class Builder;
  friend class LinkEdit;

  public:
  CodeSignature() = default;
  CodeSignature(const details::linkedit_data_command& cmd);

  CodeSignature& operator=(const CodeSignature& copy) = default;
  CodeSignature(const CodeSignature& copy) = default;

  std::unique_ptr<LoadCommand> clone() const override {
    return std::unique_ptr<CodeSignature>(new CodeSignature(*this));
  }

  //! Offset in the binary where the signature starts
  uint32_t data_offset() const {
    return data_offset_;
  }

  //! Size of the raw signature
  uint32_t data_size() const {
    return data_size_;
  }

  void data_offset(uint32_t offset) {
    data_offset_ = offset;
  }
  void data_size(uint32_t size) {
    data_size_ = size;
  }

  span<uint8_t> content() {
    return content_;
  }

  span<const uint8_t> content() const {
    return content_;
  }

  ~CodeSignature() override = default;

  void accept(Visitor& visitor) const override;

  std::ostream& print(std::ostream& os) const override;

  static bool classof(const LoadCommand* cmd) {
    return cmd->command() == LoadCommand::TYPE::CODE_SIGNATURE;
  }

  private:
  uint32_t data_offset_ = 0;
  uint32_t data_size_ = 0;
  span<uint8_t> content_;

};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/MachO/CodeSignatureDir.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_CODE_SIGNATURE_DIR_COMMAND_H
#define LIEF_MACHO_CODE_SIGNATURE_DIR_COMMAND_H
#include <ostream>

#include "LIEF/visibility.h"
#include "LIEF/span.hpp"

#include "LIEF/MachO/LoadCommand.hpp"

namespace LIEF {
namespace MachO {

class BinaryParser;
class Builder;
class LinkEdit;

namespace details {
struct linkedit_data_command;
}

class LIEF_API CodeSignatureDir : public LoadCommand {
  friend class BinaryParser;
  friend class Builder;
  friend class LinkEdit;

  public:
  CodeSignatureDir() = default;
  CodeSignatureDir(const details::linkedit_data_command& cmd);

  CodeSignatureDir& operator=(const CodeSignatureDir& copy) = default;
  CodeSignatureDir(const CodeSignatureDir& copy) = default;

  std::unique_ptr<LoadCommand> clone() const override {
    return std::unique_ptr<CodeSignatureDir>(new CodeSignatureDir(*this));
  }

  //! Offset in the binary where the signature starts
  uint32_t data_offset() const {
    return data_offset_;
  }

  //! Size of the raw signature
  uint32_t data_size() const {
    return data_size_;
  }

  void data_offset(uint32_t offset) {
    data_offset_ = offset;
  }

  void data_size(uint32_t size) {
    data_size_ = size;
  }

  span<const uint8_t> content() const {
    return content_;
  }

  span<uint8_t> content() {
    return content_;
  }

  ~CodeSignatureDir() override = default;

  void accept(Visitor& visitor) const override;

  std::ostream& print(std::ostream& os) const override;

  static bool classof(const LoadCommand* cmd) {
    return cmd->command() == LoadCommand::TYPE::DYLIB_CODE_SIGN_DRS;
  }

  private:
  uint32_t      data_offset_ = 0;
  uint32_t      data_size_   = 0;
  span<uint8_t> content_;

};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/MachO/DataCodeEntry.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_DATA_CODE_ENTRY_H
#define LIEF_MACHO_DATA_CODE_ENTRY_H
#include <ostream>
#include <cstdint>

#include "LIEF/visibility.h"

#include "LIEF/Object.hpp"

namespace LIEF {
namespace MachO {

namespace details {
struct data_in_code_entry;
}

//! Interface over an entry in the DataInCode command
class LIEF_API DataCodeEntry : public LIEF::Object {
  public:
  enum class TYPES {
    UNKNOWN           = 0,
    DATA              = 1,
    JUMP_TABLE_8      = 2,
    JUMP_TABLE_16     = 3,
    JUMP_TABLE_32     = 4,
    ABS_JUMP_TABLE_32 = 5,
  };

  public:
  DataCodeEntry() = default;
  DataCodeEntry(uint32_t off, uint16_t length, TYPES type) :
    offset_(off),
    length_(length),
    type_(type)
  {}
  DataCodeEntry(const details::data_in_code_entry& entry);

  DataCodeEntry& operator=(const DataCodeEntry&) = default;
  DataCodeEntry(const DataCodeEntry&) = default;

  //! Offset of the data
  uint32_t offset() const {
    return offset_;
  }

  //! Length of the data
  uint16_t length() const {
    return length_;
  }

  // Type of the data
  TYPES type() const {
    return type_;
  }

  void offset(uint32_t off) {
    offset_ = off;
  }
  void length(uint16_t length) {
    length_ = length;
  }
  void type(TYPES type) {
    type_ = type;
  }

  ~DataCodeEntry() override = default;

  void accept(Visitor& visitor) const override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const DataCodeEntry& entry);

  private:
  uint32_t offset_ = 0;
  uint16_t length_ = 0;
  TYPES type_ = TYPES::UNKNOWN;
};

LIEF_API const char* to_string(DataCodeEntry::TYPES e);

}
}

#endif

```

`KDemu/include/LIEF/LIEF/MachO/DataInCode.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_DATA_IN_CODE_COMMAND_H
#define LIEF_MACHO_DATA_IN_CODE_COMMAND_H
#include <vector>
#include <ostream>

#include "LIEF/visibility.h"
#include "LIEF/iterators.hpp"
#include "LIEF/span.hpp"

#include "LIEF/MachO/LoadCommand.hpp"
#include "LIEF/MachO/DataCodeEntry.hpp"

namespace LIEF {
namespace MachO {
class BinaryParser;
class LinkEdit;

namespace details {
struct linkedit_data_command;
}

//! Interface of the LC_DATA_IN_CODE command
//! This command is used to list slices of code sections that contain data. The *slices*
//! information are stored as an array of DataCodeEntry
//!
//! @see DataCodeEntry
class LIEF_API DataInCode : public LoadCommand {
  friend class BinaryParser;
  friend class LinkEdit;
  public:
  using entries_t        = std::vector<DataCodeEntry>;
  using it_const_entries = const_ref_iterator<const entries_t&>;
  using it_entries       = ref_iterator<entries_t&>;

  public:
  DataInCode() = default;
  DataInCode(const details::linkedit_data_command& cmd);

  DataInCode& operator=(const DataInCode&) = default;
  DataInCode(const DataInCode&) = default;

  std::unique_ptr<LoadCommand> clone() const override {
    return std::unique_ptr<DataInCode>(new DataInCode(*this));
  }

  //! Start of the array of the DataCodeEntry entries
  uint32_t data_offset() const {
    return data_offset_;
  }

  //! Size of the raw array (``size = sizeof(DataCodeEntry) * nb_elements``)
  uint32_t data_size() const {
    return data_size_;
  }

  void data_offset(uint32_t offset) {
    data_offset_ = offset;
  }
  void data_size(uint32_t size) {
    data_size_ = size;
  }

  //! Add a new entry
  DataInCode& add(DataCodeEntry entry) {
    entries_.push_back(std::move(entry));
    return *this;
  }

  //! Iterator over the DataCodeEntry
  it_const_entries entries() const {
    return entries_;
  }

  it_entries entries() {
    return entries_;
  }

  span<uint8_t> content() {
    return content_;
  }

  span<const uint8_t> content() const {
    return content_;
  }

  ~DataInCode() override = default;

  void accept(Visitor& visitor) const override;

  std::ostream& print(std::ostream& os) const override;

  static bool classof(const LoadCommand* cmd) {
    return cmd->command() == LoadCommand::TYPE::DATA_IN_CODE;
  }

  private:
  uint32_t  data_offset_ = 0;
  uint32_t  data_size_   = 0;
  entries_t entries_;
  span<uint8_t> content_;

};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/MachO/DyldBindingInfo.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_DYLD_INFO_BINDING_INFO_H
#define LIEF_MACHO_DYLD_INFO_BINDING_INFO_H
#include <ostream>
#include <cstdint>

#include "LIEF/visibility.h"
#include "LIEF/MachO/BindingInfo.hpp"

namespace LIEF {
namespace MachO {

//! This class represents a symbol binding operation associated with
//! the LC_DYLD_INFO bytecode.
//!
//! It does not represent a structure that exists in the Mach-O format
//! specifications but it provides a *view* on an entry of the Dyld binding opcodes.
//!
//! @see: BindingInfo
class LIEF_API DyldBindingInfo : public BindingInfo {
  friend class BinaryParser;

  public:
  enum class CLASS: uint64_t  {
    WEAK     = 1u,
    LAZY     = 2u,
    STANDARD = 3u,
    THREADED = 100u
  };

  enum class TYPE: uint64_t  {
    POINTER         = 1u,
    TEXT_ABSOLUTE32 = 2u,
    TEXT_PCREL32    = 3u
  };

  public:
  DyldBindingInfo() = default;
  DyldBindingInfo(CLASS cls, TYPE type,
                  uint64_t address, int64_t addend = 0,
                  int32_t oridnal = 0, bool is_weak = false,
                  bool is_non_weak_definition = false, uint64_t offset = 0);

  DyldBindingInfo& operator=(const DyldBindingInfo& other) = default;
  DyldBindingInfo(const DyldBindingInfo& other) = default;

  DyldBindingInfo(DyldBindingInfo&&) noexcept = default;

  void swap(DyldBindingInfo& other) noexcept;

  //! Class of the binding (weak, lazy, ...)
  CLASS binding_class() const {
    return class_;
  }
  void binding_class(CLASS bind_class) {
    class_ = bind_class;
  }

  //! Type of the binding. Most of the times it's TYPE::POINTER
  TYPE binding_type() const {
    return binding_type_;
  }

  void binding_type(TYPE type) {
    binding_type_ = type;
  }

  bool is_non_weak_definition() const {
    return this->is_non_weak_definition_;
  }

  void set_non_weak_definition(bool val) {
    this->is_non_weak_definition_ = val;
  }

  //! Original relative offset of the binding opcodes
  uint64_t original_offset() const {
    return offset_;
  }

  BindingInfo::TYPES type() const override {
    return BindingInfo::TYPES::DYLD_INFO;
  }

  static bool classof(const BindingInfo* info) {
    return info->type() == BindingInfo::TYPES::DYLD_INFO;
  }

  ~DyldBindingInfo() override = default;

  void accept(Visitor& visitor) const override;

  LIEF_API friend
  std::ostream& operator<<(std::ostream& os, const DyldBindingInfo& info) {
    os << static_cast<const BindingInfo&>(info);
    return os;
  }

  private:
  CLASS class_ = CLASS::STANDARD;
  TYPE binding_type_ = TYPE::POINTER;
  bool is_non_weak_definition_ = false;
  uint64_t offset_ = 0;
};

LIEF_API const char* to_string(DyldBindingInfo::CLASS e);
LIEF_API const char* to_string(DyldBindingInfo::TYPE e);

}
}
#endif

```

`KDemu/include/LIEF/LIEF/MachO/DyldChainedFixups.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_DYLD_CHAINED_FIXUPS_H
#define LIEF_MACHO_DYLD_CHAINED_FIXUPS_H
#include <memory>
#include "LIEF/span.hpp"
#include "LIEF/iterators.hpp"
#include "LIEF/visibility.h"
#include "LIEF/MachO/LoadCommand.hpp"
#include "LIEF/MachO/DyldChainedFormat.hpp"

namespace LIEF {
namespace MachO {

class BinaryParser;
class Builder;
class ChainedBindingInfo;
class ChainedBindingInfoList;
class LinkEdit;
class SegmentCommand;

namespace details {
struct linkedit_data_command;
struct dyld_chained_fixups_header;
struct dyld_chained_starts_in_segment;
}

//! Class that represents the LC_DYLD_CHAINED_FIXUPS command
//!
//! This command aims at providing rebase and binding information like
//! the DyldInfo's bytecode. Compared to the DyldInfo bytecode, these chained
//! fixups are taking less space.
class LIEF_API DyldChainedFixups : public LoadCommand {
  friend class BinaryParser;
  friend class Builder;
  friend class LinkEdit;

  public:
  //! Structure that mirrors the raw dyld_chained_starts_in_segment
  //! which aims at providing information about the chained rebase/bind fixups
  //!
  //! The relocations provided by this structure can be accessed through SegmentCommand::relocations
  struct chained_starts_in_segment {
    uint32_t offset            = 0; ///< Original offset of the structure, relative to DyldChainedFixups::starts_offset
    uint32_t size              = 0; ///< sizeof(size) + sizeof(page_size) + ... + sizeof(pointer_format)
    uint16_t page_size         = 0; ///< Likely 0x1000 for x86/x86_64 architectures and 0x4000 for ARM64 architecture
    uint64_t segment_offset    = 0; ///< Offset of the segment's data from the beginning of the file (it should match SegmentCommand::file_offset)
    uint32_t max_valid_pointer = 0; ///< for 32-bit OS, any value beyond this is not a pointer
    DYLD_CHAINED_PTR_FORMAT pointer_format; ///< How pointers are encoded

    //! How many pages are in the page_start array
    size_t page_count() const {
      return page_start.size();
    }

    std::vector<uint16_t> page_start;   ///< Offset in the SegmentCommand of the first element of the chain
    std::vector<uint16_t> chain_starts; ///< Currently not supported

    SegmentCommand& segment; ///< Segment in which the rebase/bind fixups take place

    LIEF_API friend std::ostream& operator<<(std::ostream& os, const chained_starts_in_segment& info);

    private:
    friend class BinaryParser;
    chained_starts_in_segment(uint32_t offset, SegmentCommand& segment);
    chained_starts_in_segment(uint32_t offset, const details::dyld_chained_starts_in_segment& info,
                              SegmentCommand& segment);
  };

  //! Internal container for storing chained_starts_in_segment
  using chained_starts_in_segments_t = std::vector<chained_starts_in_segment>;

  //! Iterator that outputs chained_starts_in_segment&
  using it_chained_starts_in_segments_t = ref_iterator<chained_starts_in_segments_t&>;

  //! Iterator that outputs const chained_starts_in_segment&
  using it_const_chained_starts_in_segments_t = const_ref_iterator<const chained_starts_in_segments_t&>;

  //! Internal container for storing DyldBindingInfo
  using binding_info_t = std::vector<std::unique_ptr<ChainedBindingInfo>>;

  //! Iterator which outputs DyldBindingInfo&
  using it_binding_info = ref_iterator<binding_info_t&, ChainedBindingInfo*>;

  //! Iterator which outputs const DyldBindingInfo&
  using it_const_binding_info = const_ref_iterator<const binding_info_t&, ChainedBindingInfo*>;


  DyldChainedFixups();
  DyldChainedFixups(const details::linkedit_data_command& cmd);
  std::unique_ptr<LoadCommand> clone() const override {
    return std::unique_ptr<DyldChainedFixups>(new DyldChainedFixups(*this));
  }

  ~DyldChainedFixups() override;

  //! Offset of the LC_DYLD_CHAINED_FIXUPS chained payload.
  //! This offset should point in the __LINKEDIT segment
  uint32_t data_offset() const {
    return data_offset_;
  }

  //! Size of the LC_DYLD_CHAINED_FIXUPS payload.
  uint32_t data_size() const {
    return data_size_;
  }

  void data_offset(uint32_t offset) {
    data_offset_ = offset;
  }
  void data_size(uint32_t size) {
    data_size_ = size;
  }

  //! Iterator over the bindings (ChainedBindingInfo) associated with this command
  it_binding_info bindings() {
    return all_bindings_;
  }

  //! Iterator over the bindings (ChainedBindingInfo) associated with this command
  it_const_binding_info bindings() const {
    return all_bindings_;
  }

  //! Iterator over the chained fixup metadata
  it_chained_starts_in_segments_t chained_starts_in_segments() {
    return chained_starts_in_segment_;
  }

  it_const_chained_starts_in_segments_t chained_starts_in_segments() const {
    return chained_starts_in_segment_;
  }

  //! Chained fixups version. The loader (dyld v852.2) checks
  //! that this value is set to 0
  uint32_t fixups_version() const { return fixups_version_; }
  void fixups_version(uint32_t version) { fixups_version_ = version; }

  //! offset of dyld_chained_starts_in_image in chain_data
  uint32_t starts_offset() const { return starts_offset_; }
  void starts_offset(uint32_t offset) { starts_offset_ = offset; }

  //! Offset of imports table in chain data
  uint32_t imports_offset() const { return imports_offset_; }
  void imports_offset(uint32_t offset) { imports_offset_ = offset; }

  //! Offset of symbol strings in chain data
  uint32_t symbols_offset() const { return symbols_offset_; }
  void symbols_offset(uint32_t offset) { symbols_offset_ = offset; }

  //! Number of imported symbol names
  uint32_t imports_count() const { return imports_count_; }
  void imports_count(uint32_t cnt) { imports_count_ = cnt; }

  //! The compression algorithm (if any) used to store the symbols
  //! 0 means uncompressed while 1 means zlib compressed.
  //!
  //! As far of the version v852.2 of dyld loader, it only supports
  //! **uncompressed** format
  uint32_t symbols_format() const { return symbols_format_; }
  void symbols_format(uint32_t fmt) { symbols_format_ = fmt; }

  //! The format of the imports (ChainedBindingInfo)
  DYLD_CHAINED_FORMAT imports_format() const { return imports_format_; }
  void imports_format(DYLD_CHAINED_FORMAT fmt) { imports_format_ = fmt; }


  void accept(Visitor& visitor) const override;

  std::ostream& print(std::ostream& os) const override;

  static bool classof(const LoadCommand* cmd) {
    return cmd->command() == LoadCommand::TYPE::DYLD_CHAINED_FIXUPS;
  }

  private:
  void update_with(const details::dyld_chained_fixups_header& header);
  DyldChainedFixups& operator=(const DyldChainedFixups& other);
  DyldChainedFixups(const DyldChainedFixups& other);

  uint32_t data_offset_ = 0;
  uint32_t data_size_   = 0;

  // Raw payload of the DyldChainedFixups.
  // This payload is located in the __LINKEDIT segment
  span<uint8_t> content_;

  uint32_t fixups_version_ = 0;
  uint32_t starts_offset_  = 0;
  uint32_t imports_offset_ = 0;
  uint32_t symbols_offset_ = 0;
  uint32_t imports_count_  = 0;
  uint32_t symbols_format_ = 0;
  DYLD_CHAINED_FORMAT imports_format_ = DYLD_CHAINED_FORMAT::IMPORT;

  chained_starts_in_segments_t chained_starts_in_segment_;

  std::vector<std::unique_ptr<ChainedBindingInfoList>> internal_bindings_;
  binding_info_t all_bindings_;
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/MachO/DyldChainedFormat.hpp`:

```hpp
/* Copyright 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_DYLD_CHAINED_FMT_H
#define LIEF_MACHO_DYLD_CHAINED_FMT_H
#include "LIEF/visibility.h"
namespace LIEF {
namespace MachO {

// values for dyld_chained_fixups_header.imports_format
enum class DYLD_CHAINED_FORMAT {
  IMPORT          = 1, // Originally: DYLD_CHAINED_IMPORT
  IMPORT_ADDEND   = 2, // Originally: DYLD_CHAINED_IMPORT_ADDEND
  IMPORT_ADDEND64 = 3, // Originally: DYLD_CHAINED_IMPORT_ADDEND64
};

// values for dyld_chained_starts_in_segment.pointer_format
enum DYLD_CHAINED_PTR_FORMAT {
  PTR_ARM64E                 =  1, // stride 8, unauth target is vmaddr
  PTR_64                     =  2, // target is vmaddr
  PTR_32                     =  3,
  PTR_32_CACHE               =  4,
  PTR_32_FIRMWARE            =  5,
  PTR_64_OFFSET              =  6, // target is vm offset
  PTR_ARM64E_OFFSET          =  7, // old name
  PTR_ARM64E_KERNEL          =  7, // stride 4, unauth target is vm offset
  PTR_64_KERNEL_CACHE        =  8,
  PTR_ARM64E_USERLAND        =  9, // stride 8, unauth target is vm offset
  PTR_ARM64E_FIRMWARE        = 10, // stride 4, unauth target is vmaddr
  PTR_X86_64_KERNEL_CACHE    = 11, // stride 1, x86_64 kernel caches
  PTR_ARM64E_USERLAND24      = 12, // stride 8, unauth target is vm offset, 24-bit bind
};

LIEF_API const char* to_string(DYLD_CHAINED_FORMAT fmt);
LIEF_API const char* to_string(DYLD_CHAINED_PTR_FORMAT ptr_fmt);

}
}
#endif

```

`KDemu/include/LIEF/LIEF/MachO/DyldEnvironment.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_DYLD_ENVIROMENT_COMMAND_H
#define LIEF_MACHO_DYLD_ENVIROMENT_COMMAND_H
#include <string>
#include <ostream>

#include "LIEF/visibility.h"

#include "LIEF/MachO/LoadCommand.hpp"

namespace LIEF {
namespace MachO {

namespace details {
struct dylinker_command;
}

//! Class that represents a `LC_DYLD_ENVIRONMENT` command which is
//! used by the Mach-O linker/loader to initialize an environment variable
class LIEF_API DyldEnvironment : public LoadCommand {
  public:
  DyldEnvironment() = default;
  DyldEnvironment(const details::dylinker_command& cmd);

  DyldEnvironment& operator=(const DyldEnvironment& copy) = default;
  DyldEnvironment(const DyldEnvironment& copy) = default;

  std::unique_ptr<LoadCommand> clone() const override {
    return std::unique_ptr<DyldEnvironment>(new DyldEnvironment(*this));
  }

  ~DyldEnvironment() override = default;

  std::ostream& print(std::ostream& os) const override;

  //! The actual environment variable
  const std::string& value() const {
    return value_;
  }

  void value(std::string value) {
    value_ = std::move(value);
  }

  void accept(Visitor& visitor) const override;

  static bool classof(const LoadCommand* cmd) {
    return cmd->command() == LoadCommand::TYPE::DYLD_ENVIRONMENT;
  }

  private:
  std::string value_;
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/MachO/DyldExportsTrie.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_DYLD_EXPORTS_TRIE_H
#define LIEF_MACHO_DYLD_EXPORTS_TRIE_H
#include <memory>
#include "LIEF/span.hpp"
#include "LIEF/iterators.hpp"
#include "LIEF/visibility.h"
#include "LIEF/MachO/LoadCommand.hpp"

namespace LIEF {
namespace MachO {

class BinaryParser;
class Builder;
class LinkEdit;
class ExportInfo;
class Binary;

namespace details {
struct linkedit_data_command;
}

//! Class that represents the LC_DYLD_EXPORTS_TRIE command
//!
//! In recent Mach-O binaries, this command replace the DyldInfo export trie buffer
class LIEF_API DyldExportsTrie : public LoadCommand {
  friend class BinaryParser;
  friend class Builder;
  friend class LinkEdit;
  friend class Binary;

  public:
  //! Internal container for storing ExportInfo
  using export_info_t = std::vector<std::unique_ptr<ExportInfo>>;

  //! Iterator which outputs const ExportInfo&
  using it_export_info = ref_iterator<export_info_t&, ExportInfo*>;

  //! Iterator which outputs const ExportInfo&
  using it_const_export_info = const_ref_iterator<const export_info_t&, ExportInfo*>;

  DyldExportsTrie();
  DyldExportsTrie(const details::linkedit_data_command& cmd);
  std::unique_ptr<LoadCommand> clone() const override {
    return std::unique_ptr<DyldExportsTrie>(new DyldExportsTrie(*this));
  }

  void swap(DyldExportsTrie& other) noexcept;

  ~DyldExportsTrie() override;

  //! Offset of the LC_DYLD_EXPORTS_TRIE.
  //! This offset should point in the __LINKEDIT segment
  uint32_t data_offset() const {
    return data_offset_;
  }

  //! Size of the LC_DYLD_EXPORTS_TRIE payload.
  uint32_t data_size() const {
    return data_size_;
  }

  void data_offset(uint32_t offset) {
    data_offset_ = offset;
  }
  void data_size(uint32_t size) {
    data_size_ = size;
  }

  span<const uint8_t> content() const {
    return content_;
  }

  //! Iterator over the ExportInfo entries
  it_export_info exports() {
    return export_info_;
  }

  it_const_export_info exports() const {
    return export_info_;
  }

  //! Print the exports trie in a humman-readable way
  std::string show_export_trie() const;

  //! Add an entrie in the current trie.
  //! See also: LIEF::MachO::Binary::add_exported_function
  void add(std::unique_ptr<ExportInfo> info);

  void accept(Visitor& visitor) const override;

  std::ostream& print(std::ostream& os) const override;

  static bool classof(const LoadCommand* cmd) {
    return cmd->command() == LoadCommand::TYPE::DYLD_EXPORTS_TRIE;
  }

  private:
  DyldExportsTrie& operator=(DyldExportsTrie other);
  DyldExportsTrie(const DyldExportsTrie& other);

  uint32_t data_offset_ = 0;
  uint32_t data_size_   = 0;

  // Raw payload of the DyldChainedFixups.
  // This payload is located in the __LINKEDIT segment
  span<uint8_t> content_;

  export_info_t  export_info_;
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/MachO/DyldInfo.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_DYLD_INFO_COMMAND_H
#define LIEF_MACHO_DYLD_INFO_COMMAND_H
#include <string>
#include <set>
#include <vector>
#include <ostream>
#include <memory>

#include "LIEF/visibility.h"
#include "LIEF/span.hpp"

#include "LIEF/MachO/LoadCommand.hpp"
#include "LIEF/MachO/type_traits.hpp"
#include "LIEF/iterators.hpp"

namespace LIEF {
class vector_iostream;
class BinaryStream;
namespace MachO {

class Binary;
class BinaryParser;
class Builder;
class DyldBindingInfo;
class ExportInfo;
class LinkEdit;
class RelocationDyld;

namespace details {
struct dyld_info_command;
}

//! Class that represents the LC_DYLD_INFO and LC_DYLD_INFO_ONLY commands
class LIEF_API DyldInfo : public LoadCommand {

  friend class BinaryParser;
  friend class Binary;
  friend class Builder;
  friend class LinkEdit;

  public:
  //! Tuple of ``offset`` and ``size``
  using info_t = std::pair<uint32_t, uint32_t>;

  //! Internal container for storing DyldBindingInfo
  using binding_info_t = std::vector<std::unique_ptr<DyldBindingInfo>>;

  //! Iterator which outputs DyldBindingInfo&
  using it_binding_info = ref_iterator<binding_info_t&, DyldBindingInfo*>;

  //! Iterator which outputs const DyldBindingInfo&
  using it_const_binding_info = const_ref_iterator<const binding_info_t&, DyldBindingInfo*>;

  //! Internal container for storing ExportInfo
  using export_info_t = std::vector<std::unique_ptr<ExportInfo>>;

  //! Iterator which outputs const ExportInfo&
  using it_export_info = ref_iterator<export_info_t&, ExportInfo*>;

  //! Iterator which outputs const ExportInfo&
  using it_const_export_info = const_ref_iterator<const export_info_t&, ExportInfo*>;

  enum class BINDING_ENCODING_VERSION {
    UNKNOWN = 0,
    V1,
    V2
  };

  enum class REBASE_TYPE: uint64_t  {
    POINTER         = 1u,
    TEXT_ABSOLUTE32 = 2u,
    TEXT_PCREL32    = 3u,
    THREADED        = 102u,
  };

  enum class REBASE_OPCODES: uint8_t {
    DONE                               = 0x00u, ///< It's finished
    SET_TYPE_IMM                       = 0x10u, ///< Set type to immediate (lower 4-bits). Used for ordinal numbers from 0-15
    SET_SEGMENT_AND_OFFSET_ULEB        = 0x20u, ///< Set segment's index to immediate (lower 4-bits) and segment's offset to following ULEB128 encoding.
    ADD_ADDR_ULEB                      = 0x30u, ///< Add segment's offset with the following ULEB128 encoding.
    ADD_ADDR_IMM_SCALED                = 0x40u, ///< Add segment's offset with immediate scaling
    DO_REBASE_IMM_TIMES                = 0x50u, ///< Rebase in the range of ``[segment's offset; segment's offset + immediate * sizeof(ptr)]``
    DO_REBASE_ULEB_TIMES               = 0x60u, ///< Same as REBASE_OPCODE_DO_REBASE_IMM_TIMES but *immediate* is replaced with ULEB128 value
    DO_REBASE_ADD_ADDR_ULEB            = 0x70u, ///< Rebase and increment segment's offset with following ULEB128 encoding + pointer's size
    DO_REBASE_ULEB_TIMES_SKIPPING_ULEB = 0x80u  ///< Rebase and skip several bytes
  };

  //! @brief Opcodes used by Dyld info to bind symbols
  enum class BIND_OPCODES: uint8_t {
    DONE                             = 0x00u, ///< It's finished
    SET_DYLIB_ORDINAL_IMM            = 0x10u, ///< Set ordinal to immediate (lower 4-bits). Used for ordinal numbers from 0-15
    SET_DYLIB_ORDINAL_ULEB           = 0x20u, ///< Set ordinal to following ULEB128 encoding. Used for ordinal numbers from 16+
    SET_DYLIB_SPECIAL_IMM            = 0x30u, ///< Set ordinal, with 0 or negative number as immediate. the value is sign extended.
    SET_SYMBOL_TRAILING_FLAGS_IMM    = 0x40u, ///< Set the following symbol (NULL-terminated char*).
    SET_TYPE_IMM                     = 0x50u, ///< Set the type to immediate (lower 4-bits). See BIND_TYPES
    SET_ADDEND_SLEB                  = 0x60u, ///< Set the addend field to the following SLEB128 encoding.
    SET_SEGMENT_AND_OFFSET_ULEB      = 0x70u, ///< Set Segment to immediate value, and address to the following SLEB128 encoding
    ADD_ADDR_ULEB                    = 0x80u, ///< Set the address field to the following SLEB128 encoding.
    DO_BIND                          = 0x90u, ///< Perform binding of current table row
    DO_BIND_ADD_ADDR_ULEB            = 0xA0u, ///< Perform binding, also add following ULEB128 as address
    DO_BIND_ADD_ADDR_IMM_SCALED      = 0xB0u, ///< Perform binding, also add immediate (lower 4-bits) using scaling
    DO_BIND_ULEB_TIMES_SKIPPING_ULEB = 0xC0u, ///< Perform binding for several symbols (as following ULEB128), and skip several bytes.
    THREADED                         = 0xD0u,

    THREADED_APPLY                            = 0xD0u | 0x01u,
    THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB = 0xD0u | 0x00u,
  };

  enum class BIND_SUBOPCODE_THREADED: uint8_t {
    SET_BIND_ORDINAL_TABLE_SIZE_ULEB = 0x00u,
    APPLY                            = 0x01u,
  };

  enum BIND_SYMBOL_FLAGS {
    WEAK_IMPORT = 0x1u,
    NON_WEAK_DEFINITION = 0x8u,
  };

  static constexpr auto OPCODE_MASK = uint32_t(0xF0);
  static constexpr auto IMMEDIATE_MASK = uint32_t(0x0F);

  DyldInfo();
  DyldInfo(const details::dyld_info_command& dyld_info_cmd);

  DyldInfo& operator=(DyldInfo other);
  DyldInfo(const DyldInfo& copy);

  void swap(DyldInfo& other) noexcept;

  std::unique_ptr<LoadCommand> clone() const override {
    return std::unique_ptr<DyldInfo>(new DyldInfo(*this));
  }

  ~DyldInfo() override;

  //! *Rebase* information
  //!
  //! Dyld rebases an image whenever dyld loads it at an address different
  //! from its preferred address.  The rebase information is a stream
  //! of byte sized opcodes for which symbolic names start with REBASE_OPCODE_.
  //! Conceptually the rebase information is a table of tuples:
  //!    <seg-index, seg-offset, type>
  //! The opcodes are a compressed way to encode the table by only
  //! encoding when a column changes.  In addition simple patterns
  //! like "every n'th offset for m times" can be encoded in a few
  //! bytes.
  //!
  //! @see ``/usr/include/mach-o/loader.h``
  const info_t& rebase() const {
    return rebase_;
  }

  //! Return Rebase's opcodes as raw data
  span<const uint8_t> rebase_opcodes() const {
    return rebase_opcodes_;
  }
  span<uint8_t> rebase_opcodes() {
    return rebase_opcodes_;
  }

  //! Set new opcodes
  void rebase_opcodes(buffer_t raw);

  //! Return the rebase opcodes in a humman-readable way
  std::string show_rebases_opcodes() const;

  //! *Bind* information
  //!
  //! Dyld binds an image during the loading process, if the image
  //! requires any pointers to be initialized to symbols in other images.
  //! The rebase information is a stream of byte sized
  //! opcodes for which symbolic names start with BIND_OPCODE_.
  //! Conceptually the bind information is a table of tuples:
  //!    <seg-index, seg-offset, type, symbol-library-ordinal, symbol-name, addend>
  //! The opcodes are a compressed way to encode the table by only
  //! encoding when a column changes.  In addition simple patterns
  //! like for runs of pointers initialzed to the same value can be
  //! encoded in a few bytes.
  //!
  //! @see ``/usr/include/mach-o/loader.h``
  const info_t& bind() const {
    return bind_;
  }

  //! Return Binding's opcodes as raw data
  span<const uint8_t> bind_opcodes() const {
    return bind_opcodes_;
  }
  span<uint8_t> bind_opcodes() {
    return bind_opcodes_;
  }

  //! Set new opcodes
  void bind_opcodes(buffer_t raw);

  //! Return the bind opcodes in a humman-readable way
  std::string show_bind_opcodes() const;

  //! *Weak Bind* information
  //!
  //! Some C++ programs require dyld to unique symbols so that all
  //! images in the process use the same copy of some code/data.
  //! This step is done after binding. The content of the weak_bind
  //! info is an opcode stream like the bind_info.  But it is sorted
  //! alphabetically by symbol name.  This enables dyld to walk
  //! all images with weak binding information in order and look
  //! for collisions.  If there are no collisions, dyld does
  //! no updating.  That means that some fixups are also encoded
  //! in the bind_info.  For instance, all calls to "operator new"
  //! are first bound to libstdc++.dylib using the information
  //! in bind_info.  Then if some image overrides operator new
  //! that is detected when the weak_bind information is processed
  //! and the call to operator new is then rebound.
  //!
  //! @see ``/usr/include/mach-o/loader.h``
  const info_t& weak_bind() const {
    return weak_bind_;
  }

  //! Return **Weak** Binding's opcodes as raw data
  span<const uint8_t> weak_bind_opcodes() const {
    return weak_bind_opcodes_;
  }
  span<uint8_t> weak_bind_opcodes() {
    return weak_bind_opcodes_;
  }

  //! Set new opcodes
  void weak_bind_opcodes(buffer_t raw);

  //! Return the bind opcodes in a humman-readable way
  std::string show_weak_bind_opcodes() const;

  //! *Lazy Bind* information
  //!
  //! Some uses of external symbols do not need to be bound immediately.
  //! Instead they can be lazily bound on first use.  The lazy_bind
  //! are contains a stream of BIND opcodes to bind all lazy symbols.
  //! Normal use is that dyld ignores the lazy_bind section when
  //! loading an image.  Instead the static linker arranged for the
  //! lazy pointer to initially point to a helper function which
  //! pushes the offset into the lazy_bind area for the symbol
  //! needing to be bound, then jumps to dyld which simply adds
  //! the offset to lazy_bind_off to get the information on what
  //! to bind.
  //!
  //! @see ``/usr/include/mach-o/loader.h``
  const info_t& lazy_bind() const {
    return lazy_bind_;
  }

  //! Return **Lazy** Binding's opcodes as raw data
  span<const uint8_t> lazy_bind_opcodes() const {
    return lazy_bind_opcodes_;
  }
  span<uint8_t> lazy_bind_opcodes() {
    return lazy_bind_opcodes_;
  }

  //! Set new opcodes
  void lazy_bind_opcodes(buffer_t raw);

  //! Return the lazy opcodes in a humman-readable way
  std::string show_lazy_bind_opcodes() const;

  //! Iterator over BindingInfo entries
  it_binding_info bindings() {
    return binding_info_;
  }

  it_const_binding_info bindings() const {
    return binding_info_;
  }

  //! *Export* information
  //!
  //! The symbols exported by a dylib are encoded in a trie.  This
  //! is a compact representation that factors out common prefixes.
  //! It also reduces LINKEDIT pages in RAM because it encodes all
  //! information (name, address, flags) in one small, contiguous range.
  //! The export area is a stream of nodes.  The first node sequentially
  //! is the start node for the trie.
  //!
  //! Nodes for a symbol start with a byte that is the length of
  //! the exported symbol information for the string so far.
  //! If there is no exported symbol, the byte is zero. If there
  //! is exported info, it follows the length byte.  The exported
  //! info normally consists of a flags and offset both encoded
  //! in uleb128.  The offset is location of the content named
  //! by the symbol.  It is the offset from the mach_header for
  //! the image.
  //!
  //! After the initial byte and optional exported symbol information
  //! is a byte of how many edges (0-255) that this node has leaving
  //! it, followed by each edge.
  //! Each edge is a zero terminated cstring of the addition chars
  //! in the symbol, followed by a uleb128 offset for the node that
  //! edge points to.
  //!
  //! @see ``/usr/include/mach-o/loader.h``
  const info_t& export_info() const {
    return export_;
  }

  //! Iterator over ExportInfo entries
  it_export_info exports() {
    return export_info_;
  }
  it_const_export_info exports() const {
    return export_info_;
  }

  //! Return Export's trie as raw data
  span<const uint8_t> export_trie() const {
    return export_trie_;
  }
  span<uint8_t> export_trie() {
    return export_trie_;
  }

  //! Set new trie
  void export_trie(buffer_t raw);

  //! Return the export trie in a humman-readable way
  std::string show_export_trie() const;

  void rebase(const info_t& info) {
    rebase_ = info;
  }
  void bind(const info_t& info) {
    bind_ = info;
  }
  void weak_bind(const info_t& info) {
    weak_bind_ = info;
  }
  void lazy_bind(const info_t& info) {
    lazy_bind_ = info;
  }
  void export_info(const info_t& info) {
    export_ = info;
  }

  void set_rebase_offset(uint32_t offset) {
    rebase_ = {offset, std::get<1>(rebase())};
  }
  void set_rebase_size(uint32_t size) {
  rebase_ = {std::get<0>(rebase()), size};
  }

  void set_bind_offset(uint32_t offset) {
    bind_ = {offset, std::get<1>(bind())};
  }
  void set_bind_size(uint32_t size) {
    bind_ = {std::get<0>(bind()), size};
  }

  void set_weak_bind_offset(uint32_t offset) {
    weak_bind_ = {offset, std::get<1>(weak_bind())};
  }
  void set_weak_bind_size(uint32_t size) {
    weak_bind_ = {std::get<0>(weak_bind()), size};
  }

  void set_lazy_bind_offset(uint32_t offset) {
    lazy_bind_ = {offset, std::get<1>(lazy_bind())};
  }
  void set_lazy_bind_size(uint32_t size) {
    lazy_bind_ = {std::get<0>(lazy_bind()), size};
  }

  void set_export_offset(uint32_t offset) {
    export_ = {offset, std::get<1>(export_info())};
  }

  void set_export_size(uint32_t size) {
    export_ = {std::get<0>(export_info()), size};
  }

  void add(std::unique_ptr<ExportInfo> info);

  void accept(Visitor& visitor) const override;

  std::ostream& print(std::ostream& os) const override;

  static bool classof(const LoadCommand* cmd) {
    const LoadCommand::TYPE type = cmd->command();
    return type == LoadCommand::TYPE::DYLD_INFO ||
           type == LoadCommand::TYPE::DYLD_INFO_ONLY;
  }

  private:
  using bind_container_t = std::set<DyldBindingInfo*, std::function<bool(DyldBindingInfo*, DyldBindingInfo*)>>;

  void show_bindings(std::ostream& os, span<const uint8_t> buffer, bool is_lazy = false) const;

  void show_trie(std::ostream& output, std::string output_prefix, BinaryStream& stream, uint64_t start, uint64_t end, const std::string& prefix) const;

  LIEF_LOCAL DyldInfo& update_standard_bindings(const bind_container_t& bindings, vector_iostream& stream);
  LIEF_LOCAL DyldInfo& update_standard_bindings_v1(const bind_container_t& bindings, vector_iostream& stream);
  LIEF_LOCAL DyldInfo& update_standard_bindings_v2(const bind_container_t& bindings,
                                                   std::vector<RelocationDyld*> rebases, vector_iostream& stream);

  LIEF_LOCAL DyldInfo& update_weak_bindings(const bind_container_t& bindings, vector_iostream& stream);
  LIEF_LOCAL DyldInfo& update_lazy_bindings(const bind_container_t& bindings, vector_iostream& stream);

  LIEF_LOCAL DyldInfo& update_rebase_info(vector_iostream& stream);
  LIEF_LOCAL DyldInfo& update_binding_info(vector_iostream& stream, details::dyld_info_command& cmd);
  LIEF_LOCAL DyldInfo& update_export_trie(vector_iostream& stream);

  info_t   rebase_;
  span<uint8_t> rebase_opcodes_;

  info_t   bind_;
  span<uint8_t> bind_opcodes_;

  info_t   weak_bind_;
  span<uint8_t> weak_bind_opcodes_;

  info_t   lazy_bind_;
  span<uint8_t> lazy_bind_opcodes_;

  info_t   export_;
  span<uint8_t> export_trie_;

  export_info_t  export_info_;
  binding_info_t binding_info_;

  BINDING_ENCODING_VERSION binding_encoding_version_ = BINDING_ENCODING_VERSION::UNKNOWN;

  Binary* binary_ = nullptr;
};

LIEF_API const char* to_string(DyldInfo::REBASE_TYPE e);
LIEF_API const char* to_string(DyldInfo::REBASE_OPCODES e);
LIEF_API const char* to_string(DyldInfo::BIND_OPCODES e);
LIEF_API const char* to_string(DyldInfo::BIND_SUBOPCODE_THREADED e);


}
}
#endif

```

`KDemu/include/LIEF/LIEF/MachO/DylibCommand.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_DYLIB_COMMAND_H
#define LIEF_MACHO_DYLIB_COMMAND_H
#include <array>
#include <string>
#include <ostream>

#include "LIEF/visibility.h"

#include "LIEF/MachO/LoadCommand.hpp"

namespace LIEF {
namespace MachO {

namespace details {
struct dylib_command;
}

//! Class which represents a library dependency
class LIEF_API DylibCommand : public LoadCommand {
  public:
  using version_t = std::array<uint16_t, 3>;

  public:
  //! Helper to convert an integer into a version array
  static version_t int2version(uint32_t version) {
    return {{
      static_cast<uint16_t>(version >> 16),
      static_cast<uint16_t>((version >> 8) & 0xFF),
      static_cast<uint16_t>(version & 0xFF),
    }};
  }

  //! Helper to convert a version array into an integer
  static uint32_t version2int(version_t version) {
    return (version[2]) | (version[1] << 8) | (version[0] << 16);
  }

  //! Factory function to generate a LC_LOAD_WEAK_DYLIB library
  static DylibCommand weak_dylib(const std::string& name,
      uint32_t timestamp = 0,
      uint32_t current_version = 0,
      uint32_t compat_version = 0);

  //! Factory function to generate a LC_ID_DYLIB library
  static DylibCommand id_dylib(const std::string& name,
      uint32_t timestamp = 0,
      uint32_t current_version = 0,
      uint32_t compat_version = 0);

  //! Factory function to generate a LC_LOAD_DYLIB library
  static DylibCommand load_dylib(const std::string& name,
      uint32_t timestamp = 2,
      uint32_t current_version = 0,
      uint32_t compat_version = 0);

  //! Factory function to generate a LC_REEXPORT_DYLIB library
  static DylibCommand reexport_dylib(const std::string& name,
      uint32_t timestamp = 0,
      uint32_t current_version = 0,
      uint32_t compat_version = 0);

  //! Factory function to generate a LC_LOAD_UPWARD_DYLIB library
  static DylibCommand load_upward_dylib(const std::string& name,
      uint32_t timestamp = 0,
      uint32_t current_version = 0,
      uint32_t compat_version = 0);

  //! Factory function to generate a LC_LAZY_LOAD_DYLIB library
  static DylibCommand lazy_load_dylib(const std::string& name,
      uint32_t timestamp = 0,
      uint32_t current_version = 0,
      uint32_t compat_version = 0);

  public:
  DylibCommand() = default;
  DylibCommand(const details::dylib_command& cmd);

  DylibCommand& operator=(const DylibCommand& copy) = default;
  DylibCommand(const DylibCommand& copy) = default;

  ~DylibCommand() override = default;

  std::unique_ptr<LoadCommand> clone() const override {
    return std::unique_ptr<DylibCommand>(new DylibCommand(*this));
  }

  //! Library name
  const std::string& name() const {
    return name_;
  }

  //! Date and Time when the shared library was built
  uint32_t timestamp() const {
    return timestamp_;
  }

  //! Current version of the shared library
  version_t current_version() const {
    return int2version(current_version_);
  }

  //! Compatibility version of the shared library
  version_t compatibility_version() const {
    return int2version(compatibility_version_);
  }

  void name(std::string name) {
    name_ = std::move(name);
  }
  void timestamp(uint32_t timestamp) {
    timestamp_ = timestamp;
  }
  void current_version(version_t version) {
    current_version_ = version2int(version);
  }
  void compatibility_version(version_t version) {
    compatibility_version_ = version2int(version);
  }

  std::ostream& print(std::ostream& os) const override;

  void accept(Visitor& visitor) const override;

  static bool classof(const LoadCommand* cmd) {
    const LoadCommand::TYPE type = cmd->command();
    return type == LoadCommand::TYPE::LOAD_WEAK_DYLIB ||
           type == LoadCommand::TYPE::ID_DYLIB ||
           type == LoadCommand::TYPE::LOAD_DYLIB ||
           type == LoadCommand::TYPE::LOAD_UPWARD_DYLIB ||
           type == LoadCommand::TYPE::REEXPORT_DYLIB ||
           type == LoadCommand::TYPE::LOAD_UPWARD_DYLIB ||
           type == LoadCommand::TYPE::LAZY_LOAD_DYLIB;
  }

  private:
  static DylibCommand create(LoadCommand::TYPE type,
                             const std::string& name,
                             uint32_t timestamp,
                             uint32_t current_version,
                             uint32_t compat_version);
  std::string name_;
  uint32_t timestamp_ = 0;
  uint32_t current_version_ = 0;
  uint32_t compatibility_version_ = 0;
};


}
}
#endif

```

`KDemu/include/LIEF/LIEF/MachO/DylinkerCommand.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_DYLINKER_COMMAND_H
#define LIEF_MACHO_DYLINKER_COMMAND_H
#include <string>
#include <ostream>

#include "LIEF/visibility.h"

#include "LIEF/MachO/LoadCommand.hpp"

namespace LIEF {
namespace MachO {

namespace details {
struct dylinker_command;
}

//! Class that represents the Mach-O linker, also named loader.
//! Most of the time, DylinkerCommand::name() should return ``/usr/lib/dyld``
class LIEF_API DylinkerCommand : public LoadCommand {
  public:
  DylinkerCommand() = default;
  DylinkerCommand(const details::dylinker_command& cmd);
  DylinkerCommand(std::string name);

  DylinkerCommand& operator=(const DylinkerCommand& copy) = default;
  DylinkerCommand(const DylinkerCommand& copy) = default;

  std::unique_ptr<LoadCommand> clone() const override {
    return std::unique_ptr<DylinkerCommand>(new DylinkerCommand(*this));
  }

  ~DylinkerCommand() override = default;

  std::ostream& print(std::ostream& os) const override;

  //! Path to the linker (or loader)
  const std::string& name() const {
    return name_;
  }

  void name(std::string name) {
    name_ = std::move(name);
  }

  void accept(Visitor& visitor) const override;

  static bool classof(const LoadCommand* cmd) {
    const LoadCommand::TYPE type = cmd->command();
    return type == LoadCommand::TYPE::ID_DYLINKER ||
           type == LoadCommand::TYPE::LOAD_DYLINKER;
  }

  private:
  std::string name_;
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/MachO/DynamicSymbolCommand.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_DYNAMIC_SYMBOL_COMMAND_H
#define LIEF_MACHO_DYNAMIC_SYMBOL_COMMAND_H
#include <ostream>

#include "LIEF/visibility.h"

#include "LIEF/MachO/LoadCommand.hpp"

namespace LIEF {
namespace MachO {
class Symbol;
class BinaryParser;
class Builder;
class Binary;

namespace details {
struct dysymtab_command;
}

//! Class that represents the LC_DYSYMTAB command.
//!
//! This command completes the LC_SYMTAB (SymbolCommand) to provide
//! a better granularity over the symbols layout.
class LIEF_API DynamicSymbolCommand : public LoadCommand {
  friend class BinaryParser;
  friend class Builder;
  friend class Binary;

  public:
  DynamicSymbolCommand();

  DynamicSymbolCommand(const details::dysymtab_command& cmd);

  DynamicSymbolCommand& operator=(const DynamicSymbolCommand& copy) = default;
  DynamicSymbolCommand(const DynamicSymbolCommand& copy) = default;

  std::unique_ptr<LoadCommand> clone() const override {
    return std::unique_ptr<DynamicSymbolCommand>(new DynamicSymbolCommand(*this));
  }

  ~DynamicSymbolCommand() override = default;

  void accept(Visitor& visitor) const override;

  std::ostream& print(std::ostream& os) const override;

  //! Index of the first symbol in the group of local symbols.
  uint32_t idx_local_symbol() const {
    return idx_local_symbol_;
  }

  //! Number of symbols in the group of local symbols.
  uint32_t nb_local_symbols() const {
    return nb_local_symbols_;
  }

  //! Index of the first symbol in the group of defined external symbols.
  uint32_t idx_external_define_symbol() const {
    return idx_external_define_symbol_;
  }

  //! Number of symbols in the group of defined external symbols.
  uint32_t nb_external_define_symbols() const {
    return nb_external_define_symbols_;
  }

  //! Index of the first symbol in the group of undefined external symbols.
  uint32_t idx_undefined_symbol() const {
    return idx_undefined_symbol_;
  }

  //! Number of symbols in the group of undefined external symbols.
  uint32_t nb_undefined_symbols() const {
    return nb_undefined_symbols_;
  }

  //! Byte offset from the start of the file to the table of contents data
  //!
  //! Table of content is used by legacy Mach-O loader and this field should be
  //! set to 0
  uint32_t toc_offset() const {
    return toc_offset_;
  }

  //! Number of entries in the table of contents.
  //!
  //! Should be set to 0 on recent Mach-O
  uint32_t nb_toc() const {
    return nb_toc_;
  }

  //! Byte offset from the start of the file to the module table data.
  //!
  //! This field seems unused by recent Mach-O loader and should be set to 0
  uint32_t module_table_offset() const {
    return module_table_offset_;
  }

  //! Number of entries in the module table.
  //!
  //! This field seems unused by recent Mach-O loader and should be set to 0
  uint32_t nb_module_table() const {
    return nb_module_table_;
  }

  //! Byte offset from the start of the file to the external reference table data.
  //!
  //! This field seems unused by recent Mach-O loader and should be set to 0
  uint32_t external_reference_symbol_offset() const {
    return external_reference_symbol_offset_;
  }

  //! Number of entries in the external reference table
  //!
  //! This field seems unused by recent Mach-O loader and should be set to 0
  uint32_t nb_external_reference_symbols() const {
    return nb_external_reference_symbols_;
  }

  //! Byte offset from the start of the file to the indirect symbol table data.
  //!
  //! Indirect symbol table is used by the loader to speed-up symbol resolution during
  //! the *lazy binding* process
  //!
  //! References:
  //!   * dyld-519.2.1/src/ImageLoaderMachOCompressed.cpp
  //!   * dyld-519.2.1/src/ImageLoaderMachOClassic.cpp
  uint32_t indirect_symbol_offset() const {
    return indirect_sym_offset_;
  }

  //! Number of entries in the indirect symbol table.
  //!
  //! @see indirect_symbol_offset
  uint32_t nb_indirect_symbols() const {
    return nb_indirect_symbols_;
  }


  //! Byte offset from the start of the file to the external relocation table data.
  //!
  //! This field seems unused by recent Mach-O loader and should be set to 0
  uint32_t external_relocation_offset() const {
    return external_relocation_offset_;
  }

  //! Number of entries in the external relocation table.
  //!
  //! This field seems unused by recent Mach-O loader and should be set to 0
  uint32_t nb_external_relocations() const {
    return nb_external_relocations_;
  }

  //! Byte offset from the start of the file to the local relocation table data.
  //!
  //! This field seems unused by recent Mach-O loader and should be set to 0
  uint32_t local_relocation_offset() const {
    return local_relocation_offset_;
  }

  //! Number of entries in the local relocation table.
  //!
  //! This field seems unused by recent Mach-O loader and should be set to 0
  uint32_t nb_local_relocations() const {
    return nb_local_relocations_;
  }

  void idx_local_symbol(uint32_t value) {
    idx_local_symbol_ = value;
  }
  void nb_local_symbols(uint32_t value) {
    nb_local_symbols_ = value;
  }

  void idx_external_define_symbol(uint32_t value) {
    idx_external_define_symbol_ = value;
  }
  void nb_external_define_symbols(uint32_t value) {
    nb_external_define_symbols_ = value;
  }

  void idx_undefined_symbol(uint32_t value) {
    idx_undefined_symbol_ = value;
  }
  void nb_undefined_symbols(uint32_t value) {
    nb_undefined_symbols_ = value;
  }

  void toc_offset(uint32_t value) {
    toc_offset_ = value;
  }
  void nb_toc(uint32_t value) {
    nb_toc_ = value;
  }

  void module_table_offset(uint32_t value) {
    module_table_offset_ = value;
  }
  void nb_module_table(uint32_t value) {
    nb_module_table_ = value;
  }

  void external_reference_symbol_offset(uint32_t value) {
    external_reference_symbol_offset_ = value;
  }
  void nb_external_reference_symbols(uint32_t value) {
    nb_external_reference_symbols_ = value;
  }

  void indirect_symbol_offset(uint32_t value) {
    indirect_sym_offset_ = value;
  }
  void nb_indirect_symbols(uint32_t value) {
    nb_indirect_symbols_ = value;
  }

  void external_relocation_offset(uint32_t value) {
    external_relocation_offset_ = value;
  }
  void nb_external_relocations(uint32_t value) {
    nb_external_relocations_ = value;
  }

  void local_relocation_offset(uint32_t value) {
    local_relocation_offset_ = value;
  }
  void nb_local_relocations(uint32_t value) {
    nb_local_relocations_ = value;
  }

  static bool classof(const LoadCommand* cmd) {
    return cmd->command() == LoadCommand::TYPE::DYSYMTAB;
  }

  private:
  uint32_t idx_local_symbol_ = 0;
  uint32_t nb_local_symbols_ = 0;

  uint32_t idx_external_define_symbol_ = 0;
  uint32_t nb_external_define_symbols_ = 0;

  uint32_t idx_undefined_symbol_ = 0;
  uint32_t nb_undefined_symbols_ = 0;

  uint32_t toc_offset_ = 0;
  uint32_t nb_toc_ = 0;

  uint32_t module_table_offset_ = 0;
  uint32_t nb_module_table_ = 0;

  uint32_t external_reference_symbol_offset_ = 0;
  uint32_t nb_external_reference_symbols_ = 0;

  uint32_t indirect_sym_offset_ = 0;
  uint32_t nb_indirect_symbols_ = 0;

  uint32_t external_relocation_offset_ = 0;
  uint32_t nb_external_relocations_ = 0;

  uint32_t local_relocation_offset_ = 0;
  uint32_t nb_local_relocations_ = 0;

  std::vector<Symbol*> indirect_symbols_;
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/MachO/EncryptionInfo.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_ENCRYPTION_INFO_COMMAND_H
#define LIEF_MACHO_ENCRYPTION_INFO_COMMAND_H
#include <ostream>

#include "LIEF/visibility.h"

#include "LIEF/MachO/LoadCommand.hpp"

namespace LIEF {
namespace MachO {

namespace details {
struct encryption_info_command;
}

//! Class that represents the LC_ENCRYPTION_INFO / LC_ENCRYPTION_INFO_64 commands
//!
//! The encryption info is usually present in Mach-O executables that
//! target iOS to encrypt some sections of the binary
class LIEF_API EncryptionInfo : public LoadCommand {
  public:
  EncryptionInfo() = default;
  EncryptionInfo(const details::encryption_info_command& cmd);

  EncryptionInfo& operator=(const EncryptionInfo& copy) = default;
  EncryptionInfo(const EncryptionInfo& copy) = default;

  ~EncryptionInfo() override = default;

  std::unique_ptr<LoadCommand> clone() const override {
    return std::unique_ptr<EncryptionInfo>(new EncryptionInfo(*this));
  }

  //! The beginning of the encrypted area
  uint32_t crypt_offset() const {
    return coff_;
  }

  //! The size of the encrypted area
  uint32_t crypt_size() const {
    return csize_;
  }

  //! The encryption system. 0 means no encrypted
  uint32_t crypt_id() const {
    return cid_;
  }

  void crypt_offset(uint32_t offset) {
    coff_ = offset;
  }

  void crypt_size(uint32_t size) {
    csize_ = size;
  }
  void crypt_id(uint32_t id) {
    cid_ = id;
  }

  void accept(Visitor& visitor) const override;

  std::ostream& print(std::ostream& os) const override;

  static bool classof(const LoadCommand* cmd) {
    const LoadCommand::TYPE type = cmd->command();
    return type == LoadCommand::TYPE::ENCRYPTION_INFO ||
           type == LoadCommand::TYPE::ENCRYPTION_INFO_64;
  }

  private:
  uint32_t coff_ = 0;
  uint32_t csize_ = 0;
  uint32_t cid_ = 0;
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/MachO/EnumToString.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_ENUM_TO_STRING_H
#define LIEF_MACHO_ENUM_TO_STRING_H
#include "LIEF/visibility.h"

#include "LIEF/MachO/enums.hpp"

namespace LIEF {
namespace MachO {

LIEF_API const char* to_string(MACHO_TYPES e);

LIEF_API const char* to_string(X86_RELOCATION e);
LIEF_API const char* to_string(X86_64_RELOCATION e);
LIEF_API const char* to_string(PPC_RELOCATION e);
LIEF_API const char* to_string(ARM_RELOCATION e);
LIEF_API const char* to_string(ARM64_RELOCATION e);

} // namespace MachO
} // namespace LIEF

#endif

```

`KDemu/include/LIEF/LIEF/MachO/ExportInfo.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_EXPORT_INFO_COMMAND_H
#define LIEF_MACHO_EXPORT_INFO_COMMAND_H
#include <vector>
#include <ostream>
#include <cstdint>

#include "LIEF/visibility.h"
#include "LIEF/enums.hpp"
#include "LIEF/Object.hpp"

namespace LIEF {
namespace MachO {

class BinaryParser;
class Symbol;
class DylibCommand;
class Binary;

//! Class that provides an interface over the Dyld export info
//!
//! This class does not represent a structure that exists in the Mach-O format
//! specification but provides a *view* on an entry of the Dyld export trie.
class LIEF_API ExportInfo : public Object {

  friend class BinaryParser;
  friend class Binary;

  public:
  enum class KIND: uint64_t  {
    REGULAR           = 0x00u,
    THREAD_LOCAL_KIND = 0x01u,
    ABSOLUTE_KIND     = 0x02u
  };

  enum class FLAGS: uint64_t  {
    WEAK_DEFINITION     = 0x04u,
    REEXPORT            = 0x08u,
    STUB_AND_RESOLVER   = 0x10u
  };

  using flag_list_t = std::vector<FLAGS>;

  ExportInfo() = default;
  ExportInfo(uint64_t address, uint64_t flags, uint64_t offset = 0) :
    node_offset_(offset),
    flags_(flags),
    address_(address)
  {}

  ExportInfo& operator=(ExportInfo copy);
  ExportInfo(const ExportInfo& copy);
  void swap(ExportInfo& other) noexcept;

  //! Original offset in the export Trie
  uint64_t node_offset() const {
    return node_offset_;
  }

  //! Some information (ExportInfo::FLAGS) about the export.
  //! (like weak export, reexport, ...)
  uint64_t flags() const {
    return flags_;
  }

  void flags(uint64_t flags) {
    flags_ = flags;
  }

  //! The export flags() as a list
  flag_list_t flags_list() const;

  //! Check if the current entry contains the provided ExportInfo::FLAGS
  bool has(FLAGS flag) const;

  //! The export's kind (regular, thread local, absolute, ...)
  KIND kind() const {
    static constexpr auto MASK = uint64_t(3);
    return KIND(flags_ & MASK);
  }

  uint64_t other() const {
    return other_;
  }

  //! The address of the export
  uint64_t address() const {
    return address_;
  }
  void address(uint64_t addr) {
    address_ = addr;
  }

  //! Check if a symbol is associated with this export
  bool has_symbol() const {
    return symbol() != nullptr;
  }

  //! MachO::Symbol associated with this export or a nullptr if no symbol
  const Symbol* symbol() const {
    return symbol_;
  }
  Symbol* symbol() {
    return symbol_;
  }

  //! If the export is a ExportInfo::FLAGS::REEXPORT,
  //! this returns the (optional) MachO::Symbol
  Symbol* alias() {
    return alias_;
  }
  const Symbol* alias() const {
    return alias_;
  }

  //! If the export is a ExportInfo::FLAGS::REEXPORT,
  //! this returns the (optional) library (MachO::DylibCommand)
  DylibCommand* alias_library() {
    return alias_location_;
  }
  const DylibCommand* alias_library() const {
    return alias_location_;
  }

  ~ExportInfo() override = default;

  void accept(Visitor& visitor) const override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const ExportInfo& export_info);

  private:
  uint64_t node_offset_ = 0;
  uint64_t flags_ = 0;
  uint64_t address_ = 0;
  uint64_t other_ = 0;
  Symbol* symbol_ = nullptr;

  Symbol* alias_ = nullptr;
  DylibCommand* alias_location_ = nullptr;
};

LIEF_API const char* to_string(ExportInfo::KIND kind);
LIEF_API const char* to_string(ExportInfo::FLAGS flags);

}
}

ENABLE_BITMASK_OPERATORS(LIEF::MachO::ExportInfo::FLAGS);

#endif

```

`KDemu/include/LIEF/LIEF/MachO/FatBinary.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_FAT_BINARY_H
#define LIEF_MACHO_FAT_BINARY_H
#include <string>
#include <vector>
#include <memory>

#include "LIEF/visibility.h"
#include "LIEF/iterators.hpp"
#include "LIEF/MachO/Header.hpp"

namespace LIEF {
class Parser;
namespace MachO {

class Parser;
class Builder;
class Binary;

//! Class which represent a Mach-O (fat) binary
//! This object is also used for representing Mach-O binaries that are **NOT FAT**
class LIEF_API FatBinary {

  friend class LIEF::Parser;
  friend class Parser;
  friend class Builder;

  public:

  //! Internal containter used to store Binary objects within a Fat Mach-O
  using binaries_t = std::vector<std::unique_ptr<Binary>>;

  //! Iterator that outputs Binary&
  using it_binaries = ref_iterator<binaries_t&, Binary*>;

  //! Iterator that outputs const Binary&
  using it_const_binaries = const_ref_iterator<const binaries_t&, Binary*>;

  FatBinary(const FatBinary&) = delete;
  FatBinary& operator=(const FatBinary&) = delete;

  virtual ~FatBinary();

  //! Number of MachO::Binary wrapped by this object
  size_t size() const {
    return binaries_.size();
  }

  //! Checks whether this object contains MachO::Binary
  bool empty() const {
    return binaries_.empty();
  }

  it_binaries begin() {
    return binaries_;
  }
  it_const_binaries begin() const {
    return binaries_;
  }

  it_binaries end() {
    return it_binaries(binaries_).end();
  }

  it_const_binaries end() const {
    return it_const_binaries(binaries_).end();
  }

  void release_all_binaries();

  //! Get a pointer to the last MachO::Binary object presents in this Fat Binary.
  //! It returns a nullptr if no binary are present.
  std::unique_ptr<Binary> pop_back();

  //! Get a pointer to the MachO::Binary specified by the ``index``.
  //! It returns a nullptr if the binary does not exist at the given index.
  Binary*       at(size_t index);
  const Binary* at(size_t index) const;

  Binary*       back();
  const Binary* back() const;

  Binary*       front();
  const Binary* front() const;

  Binary* operator[](size_t index) {
    return at(index);
  }
  const Binary* operator[](size_t index) const {
    return at(index);
  }

  //! Extract a MachO::Binary object. Gives ownership to the caller, and
  //! remove it from this FatBinary object.
  //!
  //! @warning: this invalidates any previously hold iterator!
  std::unique_ptr<Binary> take(size_t index);

  //! Take the underlying MachO::Binary that matches the given architecture
  //! If no binary with the architecture can be found, return a nullptr
  std::unique_ptr<Binary> take(Header::CPU_TYPE cpu);

  //! Reconstruct the Fat binary object and write it in `filename`
  //! @param filename Path to write the reconstructed binary
  void write(const std::string& filename);

  //! Reconstruct the Fat binary object and return his content as bytes
  std::vector<uint8_t> raw();

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const FatBinary& fatbinary);

  private:
  FatBinary();
  FatBinary(binaries_t binaries);
  binaries_t binaries_;
};

} // namespace MachO
} // namespace LIEF
#endif

```

`KDemu/include/LIEF/LIEF/MachO/FilesetCommand.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_FILESET_COMMAND_H
#define LIEF_MACHO_FILESET_COMMAND_H
#include <ostream>

#include "LIEF/visibility.h"

#include "LIEF/MachO/LoadCommand.hpp"


namespace LIEF {
namespace MachO {
class Binary;
class BinaryParser;

namespace details {
struct fileset_entry_command;
}

//! Class associated with the LC_FILESET_ENTRY commands
class LIEF_API FilesetCommand : public LoadCommand {
  public:
  friend class BinaryParser;
  using content_t = std::vector<uint8_t>;

  FilesetCommand() = default;
  FilesetCommand(const details::fileset_entry_command& command);
  FilesetCommand(std::string name) :
    name_(std::move(name))
  {}

  FilesetCommand& operator=(FilesetCommand copy);
  FilesetCommand(const FilesetCommand& copy);

  void swap(FilesetCommand& other) noexcept;

  std::unique_ptr<LoadCommand> clone() const override {
    return std::unique_ptr<FilesetCommand>(new FilesetCommand(*this));
  }

  ~FilesetCommand() override = default;

  //! Name of the underlying MachO binary (e.g. ``com.apple.security.quarantine``)
  const std::string& name() const {
    return name_;
  }

  //! Memory address where the MachO file should be mapped
  uint64_t virtual_address() const {
    return virtual_address_;
  }

  //! Original offset in the kernel cache
  uint64_t file_offset() const {
    return file_offset_;
  }

  //! Return a pointer on the LIEF::MachO::Binary associated
  //! with this entry
  const Binary* binary() const {
    return binary_;
  }

  Binary* binary() {
    return binary_;
  }

  void name(std::string name) {
    name_ = std::move(name);
  }

  void virtual_address(uint64_t virtual_address) {
    virtual_address_ = virtual_address;
  }
  void file_offset(uint64_t file_offset) {
    file_offset_ = file_offset;
  }

  std::ostream& print(std::ostream& os) const override;

  static bool classof(const LoadCommand* cmd) {
    return cmd->command() == LoadCommand::TYPE::FILESET_ENTRY;
  }

  private:
  std::string name_;
  uint64_t virtual_address_ = 0;
  uint64_t file_offset_ = 0;
  Binary* binary_ = nullptr;
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/MachO/FunctionStarts.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_FUNCTION_STARTS_COMMAND_H
#define LIEF_MACHO_FUNCTION_STARTS_COMMAND_H
#include <vector>
#include <ostream>

#include "LIEF/visibility.h"

#include "LIEF/span.hpp"
#include "LIEF/MachO/LoadCommand.hpp"

namespace LIEF {
namespace MachO {
class BinaryParser;
class LinkEdit;

namespace details {
struct linkedit_data_command;
}


//! Class which represents the LC_FUNCTION_STARTS command
//!
//! This command is an array of ULEB128 encoded values
class LIEF_API FunctionStarts : public LoadCommand {
  friend class BinaryParser;
  friend class LinkEdit;

  public:
  FunctionStarts() = default;
  FunctionStarts(const details::linkedit_data_command& cmd);

  FunctionStarts& operator=(const FunctionStarts& copy) = default;
  FunctionStarts(const FunctionStarts& copy) = default;

  std::unique_ptr<LoadCommand> clone() const override {
    return std::unique_ptr<FunctionStarts>(new FunctionStarts(*this));
  }

  //! Offset in the ``__LINKEDIT`` SegmentCommand where *start functions* are located
  uint32_t data_offset() const {
    return data_offset_;
  }

  //! Size of the functions list in the binary
  uint32_t data_size() const {
    return data_size_;
  }

  //! Addresses of every function entry point in the executable.
  //!
  //! This allows functions to exist for which there are no entries in the symbol table.
  //!
  //! @warning The address is relative to the ``__TEXT`` segment
  const std::vector<uint64_t>& functions() const {
    return functions_;
  }

  std::vector<uint64_t>& functions() {
    return functions_;
  }

  //! Add a new function
  void add_function(uint64_t address) {
    functions_.emplace_back(address);
  }

  void data_offset(uint32_t offset) {
    data_offset_ = offset;
  }
  void data_size(uint32_t size) {
    data_size_ = size;
  }

  void functions(std::vector<uint64_t> funcs) {
    functions_ = std::move(funcs);
  }

  span<const uint8_t> content() const {
    return content_;
  }

  span<uint8_t> content() {
    return content_;
  }

  ~FunctionStarts() override = default;

  void accept(Visitor& visitor) const override;

  std::ostream& print(std::ostream& os) const override;

  static bool classof(const LoadCommand* cmd) {
    return cmd->command() == LoadCommand::TYPE::FUNCTION_STARTS;
  }
  private:
  uint32_t data_offset_ = 0;
  uint32_t data_size_ = 0;
  span<uint8_t> content_;
  std::vector<uint64_t> functions_;
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/MachO/Header.h`:

```h
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef C_LIEF_MACHO_HEADER_H_
#define C_LIEF_MACHO_HEADER_H_
#include <inttypes.h>

#include "LIEF/MachO/enums.h"

#ifdef __cplusplus
extern "C" {
#endif

struct Macho_Header_t {
  uint32_t        magic;
  enum LIEF_MACHO_CPU_TYPES  cpu_type;
  uint32_t        cpu_subtype;
  enum LIEF_MACHO_FILE_TYPES file_type;
  uint32_t        nb_cmds;
  uint32_t        sizeof_cmds;
  uint32_t        flags;
  uint32_t        reserved;
};

typedef struct Macho_Header_t Macho_Header_t;


#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/include/LIEF/LIEF/MachO/Header.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_HEADER_H
#define LIEF_MACHO_HEADER_H

#include <ostream>
#include <set>
#include <vector>

#include "LIEF/Object.hpp"
#include "LIEF/visibility.h"
#include "LIEF/enums.hpp"

#include "LIEF/Abstract/enums.hpp"

#include "LIEF/MachO/enums.hpp"

namespace LIEF {
namespace MachO {
class BinaryParser;

namespace details {
struct mach_header_64;
struct mach_header;
}

//! Class that represents the Mach-O header
class LIEF_API Header : public Object {
  friend class BinaryParser;
  public:
  Header() = default;

  Header& operator=(const Header& copy) = default;
  Header(const Header& copy) = default;

  ~Header() override = default;

  enum class FILE_TYPE : uint32_t {
    UNKNOWN     = 0,
    OBJECT      = 0x1u,
    EXECUTE     = 0x2u,
    FVMLIB      = 0x3u,
    CORE        = 0x4u,
    PRELOAD     = 0x5u,
    DYLIB       = 0x6u,
    DYLINKER    = 0x7u,
    BUNDLE      = 0x8u,
    DYLIB_STUB  = 0x9u,
    DSYM        = 0xAu,
    KEXT_BUNDLE = 0xBu
  };

  enum class FLAGS : uint32_t {
    NOUNDEFS                = 0x00000001u,
    INCRLINK                = 0x00000002u,
    DYLDLINK                = 0x00000004u,
    BINDATLOAD              = 0x00000008u,
    PREBOUND                = 0x00000010u,
    SPLIT_SEGS              = 0x00000020u,
    LAZY_INIT               = 0x00000040u,
    TWOLEVEL                = 0x00000080u,
    FORCE_FLAT              = 0x00000100u,
    NOMULTIDEFS             = 0x00000200u,
    NOFIXPREBINDING         = 0x00000400u,
    PREBINDABLE             = 0x00000800u,
    ALLMODSBOUND            = 0x00001000u,
    SUBSECTIONS_VIA_SYMBOLS = 0x00002000u,
    CANONICAL               = 0x00004000u,
    WEAK_DEFINES            = 0x00008000u,
    BINDS_TO_WEAK           = 0x00010000u,
    ALLOW_STACK_EXECUTION   = 0x00020000u,
    ROOT_SAFE               = 0x00040000u,
    SETUID_SAFE             = 0x00080000u,
    NO_REEXPORTED_DYLIBS    = 0x00100000u,
    PIE                     = 0x00200000u,
    DEAD_STRIPPABLE_DYLIB   = 0x00400000u,
    HAS_TLV_DESCRIPTORS     = 0x00800000u,
    NO_HEAP_EXECUTION       = 0x01000000u,
    APP_EXTENSION_SAFE      = 0x02000000u
  };

  static constexpr int ABI64 = 0x01000000;

  enum class CPU_TYPE: int32_t {
    ANY       = -1,
    X86       = 7,
    X86_64    = 7 | ABI64,
    MIPS      = 8,
    MC98000   = 10,
    ARM       = 12,
    ARM64     = 12 | ABI64,
    SPARC     = 14,
    POWERPC   = 18,
    POWERPC64 = 18 | ABI64,
  };

  static constexpr uint32_t CPU_SUBTYPE_MASK = 0xff000000;
  static constexpr uint32_t CPU_SUBTYPE_LIB64 = 0x80000000;

  //! The Mach-O magic bytes. These bytes determine whether it is
  //! a 32 bits Mach-O, a 64 bits Mach-O files etc.
  MACHO_TYPES magic() const {
    return magic_;
  }

  //! The CPU architecture targeted by this binary
  CPU_TYPE cpu_type() const {
    return cputype_;
  }

  //! Return the CPU subtype supported by the Mach-O binary.
  //! For ARM architectures, this value could represent the minimum version
  //! for which the Mach-O binary has been compiled for.
  uint32_t cpu_subtype() const {
    return cpusubtype_;
  }

  //! Return the type of the Mach-O file (executable, object, shared library, ...)
  FILE_TYPE file_type() const {
    return filetype_;
  }

  //! Return the FLAGS as a list
  std::vector<FLAGS> flags_list() const;

  //! Check if the given HEADER_FLAGS is present in the header's flags
  bool has(FLAGS flag) const;

  //! Number of LoadCommand present in the Mach-O binary
  uint32_t nb_cmds() const {
    return ncmds_;
  }

  //! The size of **all** the LoadCommand
  uint32_t sizeof_cmds() const {
    return sizeofcmds_;
  }

  //! Header flags (cf. HEADER_FLAGS)
  //!
  //! @see flags_list
  uint32_t flags() const {
    return flags_;
  }

  //! According to the official documentation, a reserved value
  uint32_t reserved() const {
    return reserved_;
  }

  void add(FLAGS flag);

  //! LIEF abstract object type
  OBJECT_TYPES abstract_object_type() const;

  std::pair<ARCHITECTURES, std::set<MODES>> abstract_architecture() const;

  //! LIEF abstract endiannes
  ENDIANNESS abstract_endianness() const;

  void magic(MACHO_TYPES magic) {
    magic_ = magic;
  }
  void cpu_type(CPU_TYPE type) {
    cputype_ = type;
  }

  void cpu_subtype(uint32_t cpusubtype) {
    cpusubtype_ = cpusubtype;
  }

  void file_type(FILE_TYPE filetype) {
    filetype_ = filetype;
  }

  void nb_cmds(uint32_t ncmds) {
    ncmds_ = ncmds;
  }

  void sizeof_cmds(uint32_t sizeofcmds) {
    sizeofcmds_ = sizeofcmds;
  }

  void flags(uint32_t flags) {
    flags_ = flags;
  }

  void remove(FLAGS flag);

  void reserved(uint32_t reserved) {
    reserved_ = reserved;
  }

  Header& operator+=(FLAGS c) {
    add(c);
    return *this;
  }
  Header& operator-=(FLAGS c) {
    remove(c);
    return *this;
  }

  void accept(Visitor& visitor) const override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const Header& hdr);

  private:
  template<class T>
  LIEF_LOCAL Header(const T& header);

  MACHO_TYPES magic_ = MACHO_TYPES::UNKNOWN;
  CPU_TYPE   cputype_ = CPU_TYPE::ANY;
  uint32_t   cpusubtype_;
  FILE_TYPE  filetype_ = FILE_TYPE::UNKNOWN;
  uint32_t   ncmds_ = 0;
  uint32_t   sizeofcmds_ = 0;
  uint32_t   flags_ = 0;
  uint32_t   reserved_ = 0;
};

LIEF_API const char* to_string(Header::FILE_TYPE e);
LIEF_API const char* to_string(Header::CPU_TYPE e);
LIEF_API const char* to_string(Header::FLAGS e);

}
}

ENABLE_BITMASK_OPERATORS(LIEF::MachO::Header::FLAGS)

#endif

```

`KDemu/include/LIEF/LIEF/MachO/LinkEdit.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_LINK_EDIT_H
#define LIEF_MACHO_LINK_EDIT_H
#include <memory>

#include "LIEF/visibility.h"

#include "LIEF/MachO/SegmentCommand.hpp"

namespace LIEF {
namespace MachO {

class Binary;
class BinaryParser;
class Builder;
class CodeSignatureDir;
class DataInCode;
class DyldChainedFixups;
class DyldExportsTrie;
class DyldInfo;
class FunctionStarts;
class LinkerOptHint;
class SymbolCommand;
class TwoLevelHints;
class SegmentSplitInfo;
class CodeSignature;

class LIEF_API LinkEdit : public SegmentCommand {

  friend class BinaryParser;
  friend class Binary;
  friend class Builder;

  public:
  using SegmentCommand::SegmentCommand;

  LinkEdit& operator=(LinkEdit other);
  LinkEdit(const LinkEdit& copy) = default;

  void swap(LinkEdit& other) noexcept;

  std::unique_ptr<LoadCommand> clone() const override {
    return std::unique_ptr<LinkEdit>(new LinkEdit(*this));
  }

  ~LinkEdit() override = default;

  static bool classof(const LoadCommand* cmd) {
    return SegmentCommand::classof(cmd);
  }

  static bool segmentof(const SegmentCommand& segment) {
    return segment.name() == "__LINKEDIT";
  }

  private:
  LIEF_LOCAL void update_data(const update_fnc_t& f) override;
  LIEF_LOCAL void update_data(const update_fnc_ws_t& f,
                              size_t where, size_t size) override;

  //x-ref to keep the spans in a consistent state
  DyldInfo* dyld_                    = nullptr;
  DyldChainedFixups* chained_fixups_ = nullptr;
  DyldExportsTrie* exports_trie_     = nullptr;
  SegmentSplitInfo* seg_split_       = nullptr;
  FunctionStarts* fstarts_           = nullptr;
  DataInCode* data_code_             = nullptr;
  CodeSignatureDir* code_sig_dir_    = nullptr;
  LinkerOptHint* linker_opt_         = nullptr;
  SymbolCommand* symtab_             = nullptr;
  TwoLevelHints* two_lvl_hint_       = nullptr;
  CodeSignature* code_sig_           = nullptr;
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/MachO/LinkerOptHint.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_LINKER_OPT_HINT_COMMAND_H
#define LIEF_MACHO_LINKER_OPT_HINT_COMMAND_H
#include <ostream>

#include "LIEF/visibility.h"
#include "LIEF/span.hpp"

#include "LIEF/MachO/LoadCommand.hpp"

namespace LIEF {
namespace MachO {

class BinaryParser;
class Builder;
class LinkEdit;

namespace details {
struct linkedit_data_command;
}

//! Class which represents the `LC_LINKER_OPTIMIZATION_HINT` command
class LIEF_API LinkerOptHint : public LoadCommand {
  friend class BinaryParser;
  friend class Builder;
  friend class LinkEdit;

  public:
  LinkerOptHint() = default;
  LinkerOptHint(const details::linkedit_data_command& cmd);

  LinkerOptHint& operator=(const LinkerOptHint& copy) = default;
  LinkerOptHint(const LinkerOptHint& copy) = default;

  std::unique_ptr<LoadCommand> clone() const override {
    return std::unique_ptr<LinkerOptHint>(new LinkerOptHint(*this));
  }

  //! Offset in the binary where the *hint* starts
  uint32_t data_offset() const {
    return data_offset_;
  }

  //! Size of the payload
  uint32_t data_size() const {
    return data_size_;
  }

  void data_offset(uint32_t offset) {
    data_offset_ = offset;
  }

  void data_size(uint32_t size) {
    data_size_ = size;
  }

  span<const uint8_t> content() const {
    return content_;
  }

  span<uint8_t> content() {
    return content_;
  }

  ~LinkerOptHint() override = default;

  void accept(Visitor& visitor) const override;

  std::ostream& print(std::ostream& os) const override;

  static bool classof(const LoadCommand* cmd) {
    return cmd->command() == LoadCommand::TYPE::LINKER_OPTIMIZATION_HINT;
  }

  private:
  uint32_t      data_offset_ = 0;
  uint32_t      data_size_   = 0;
  span<uint8_t> content_;

};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/MachO/LoadCommand.h`:

```h
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef C_LIEF_MACHO_LOAD_COMMAND_H_
#define C_LIEF_MACHO_LOAD_COMMAND_H_
#include <inttypes.h>

#include "LIEF/MachO/enums.h"
#ifdef __cplusplus
extern "C" {
#endif

struct Macho_Command_t {
  enum LIEF_MACHO_LOAD_COMMAND_TYPES command;
  uint32_t                size;
  uint8_t*                data;
  uint32_t                offset;
};

typedef struct Macho_Command_t Macho_Command_t;


#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/include/LIEF/LIEF/MachO/LoadCommand.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_LOAD_COMMAND_H
#define LIEF_MACHO_LOAD_COMMAND_H

#include <memory>
#include <vector>

#include "LIEF/Object.hpp"
#include "LIEF/visibility.h"
#include "LIEF/span.hpp"

namespace LIEF {
namespace MachO {
class Builder;
class BinaryParser;

namespace details {
struct load_command;
}

//! Based class for the Mach-O load commands
class LIEF_API LoadCommand : public Object {
  friend class Builder;
  friend class BinaryParser;
  public:
  using raw_t = std::vector<uint8_t>;

  enum class TYPE: uint64_t {
    UNKNOWN                  = 0,
    SEGMENT                  = 0x00000001u,
    SYMTAB                   = 0x00000002u,
    SYMSEG                   = 0x00000003u,
    THREAD                   = 0x00000004u,
    UNIXTHREAD               = 0x00000005u,
    LOADFVMLIB               = 0x00000006u,
    IDFVMLIB                 = 0x00000007u,
    IDENT                    = 0x00000008u,
    FVMFILE                  = 0x00000009u,
    PREPAGE                  = 0x0000000Au,
    DYSYMTAB                 = 0x0000000Bu,
    LOAD_DYLIB               = 0x0000000Cu,
    ID_DYLIB                 = 0x0000000Du,
    LOAD_DYLINKER            = 0x0000000Eu,
    ID_DYLINKER              = 0x0000000Fu,
    PREBOUND_DYLIB           = 0x00000010u,
    ROUTINES                 = 0x00000011u,
    SUB_FRAMEWORK            = 0x00000012u,
    SUB_UMBRELLA             = 0x00000013u,
    SUB_CLIENT               = 0x00000014u,
    SUB_LIBRARY              = 0x00000015u,
    TWOLEVEL_HINTS           = 0x00000016u,
    PREBIND_CKSUM            = 0x00000017u,
    LOAD_WEAK_DYLIB          = 0x80000018u,
    SEGMENT_64               = 0x00000019u,
    ROUTINES_64              = 0x0000001Au,
    UUID                     = 0x0000001Bu,
    RPATH                    = 0x8000001Cu,
    CODE_SIGNATURE           = 0x0000001Du,
    SEGMENT_SPLIT_INFO       = 0x0000001Eu,
    REEXPORT_DYLIB           = 0x8000001Fu,
    LAZY_LOAD_DYLIB          = 0x00000020u,
    ENCRYPTION_INFO          = 0x00000021u,
    DYLD_INFO                = 0x00000022u,
    DYLD_INFO_ONLY           = 0x80000022u,
    LOAD_UPWARD_DYLIB        = 0x80000023u,
    VERSION_MIN_MACOSX       = 0x00000024u,
    VERSION_MIN_IPHONEOS     = 0x00000025u,
    FUNCTION_STARTS          = 0x00000026u,
    DYLD_ENVIRONMENT         = 0x00000027u,
    MAIN                     = 0x80000028u,
    DATA_IN_CODE             = 0x00000029u,
    SOURCE_VERSION           = 0x0000002Au,
    DYLIB_CODE_SIGN_DRS      = 0x0000002Bu,
    ENCRYPTION_INFO_64       = 0x0000002Cu,
    LINKER_OPTION            = 0x0000002Du,
    LINKER_OPTIMIZATION_HINT = 0x0000002Eu,
    VERSION_MIN_TVOS         = 0x0000002Fu,
    VERSION_MIN_WATCHOS      = 0x00000030u,
    NOTE                     = 0x00000031u,
    BUILD_VERSION            = 0x00000032u,
    DYLD_EXPORTS_TRIE        = 0x80000033u,
    DYLD_CHAINED_FIXUPS      = 0x80000034u,
    FILESET_ENTRY            = 0x80000035u,

    LIEF_UNKNOWN             = 0xffee0001u
  };

  public:
  LoadCommand() = default;
  LoadCommand(const details::load_command& command);
  LoadCommand(LoadCommand::TYPE type, uint32_t size) :
    command_(type),
    size_(size)
  {}

  LoadCommand& operator=(const LoadCommand& copy) = default;
  LoadCommand(const LoadCommand& copy) = default;

  void swap(LoadCommand& other) noexcept;

  virtual std::unique_ptr<LoadCommand> clone() const {
    return std::unique_ptr<LoadCommand>(new LoadCommand(*this));
  }

  ~LoadCommand() override = default;

  //! Command type
  LoadCommand::TYPE command() const {
    return command_;
  }

  //! Size of the command (should be greather than ``sizeof(load_command)``)
  uint32_t size() const {
    return size_;
  }

  //! Raw command
  span<const uint8_t> data() const {
    return original_data_;
  }

  //! Offset of the command within the *Load Command Table*
  uint64_t command_offset() const {
    return command_offset_;
  }

  void data(raw_t data) {
    original_data_ = std::move(data);
  }

  void command(LoadCommand::TYPE command) {
    command_ = command;
  }

  void size(uint32_t size) {
    size_ = size;
  }

  void command_offset(uint64_t offset) {
    command_offset_ = offset;
  }

  virtual std::ostream& print(std::ostream& os) const;

  void accept(Visitor& visitor) const override;

  static bool is_linkedit_data(const LoadCommand& cmd);

  LIEF_API friend
  std::ostream& operator<<(std::ostream& os, const LoadCommand& cmd) {
    return cmd.print(os);
  }

  protected:
  raw_t original_data_;
  LoadCommand::TYPE command_ = LoadCommand::TYPE::UNKNOWN;
  uint32_t size_ = 0;
  uint64_t command_offset_ = 0;
};

const char* to_string(LoadCommand::TYPE type);

}
}
#endif

```

`KDemu/include/LIEF/LIEF/MachO/MainCommand.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_MAIN_COMMAND_H
#define LIEF_MACHO_MAIN_COMMAND_H
#include <ostream>

#include "LIEF/visibility.h"

#include "LIEF/MachO/LoadCommand.hpp"

namespace LIEF {
namespace MachO {

namespace details {
struct entry_point_command;
}

//! Class that represent the LC_MAIN command. This kind
//! of command can be used to determine the entrypoint of an executable
class LIEF_API MainCommand : public LoadCommand {
  public:
  MainCommand() = default;
  MainCommand(const details::entry_point_command& cmd);
  MainCommand(uint64_t entrypoint, uint64_t stacksize);

  MainCommand& operator=(const MainCommand& copy) = default;
  MainCommand(const MainCommand& copy) = default;

  std::unique_ptr<LoadCommand> clone() const override {
    return std::unique_ptr<MainCommand>(new MainCommand(*this));
  }

  ~MainCommand() override = default;

  //! Offset of the *main* function relative to the ``__TEXT``
  //! segment
  uint64_t entrypoint() const {
    return entrypoint_;
  }

  //! The initial stack size
  uint64_t stack_size() const {
    return stack_size_;
  }

  void entrypoint(uint64_t entrypoint) {
    entrypoint_ = entrypoint;
  }
  void stack_size(uint64_t stacksize) {
    stack_size_ = stacksize;
  }

  std::ostream& print(std::ostream& os) const override;

  void accept(Visitor& visitor) const override;

  static bool classof(const LoadCommand* cmd) {
    return cmd->command() == LoadCommand::TYPE::MAIN;
  }

  private:
  uint64_t entrypoint_ = 0;
  uint64_t stack_size_ = 0;
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/MachO/Parser.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_PARSER_H
#define LIEF_MACHO_PARSER_H
#include <string>
#include <vector>
#include <memory>

#include "LIEF/errors.hpp"
#include "LIEF/visibility.h"

#include "LIEF/Abstract/Parser.hpp"

#include "LIEF/MachO/ParserConfig.hpp"

namespace LIEF {
class BinaryStream;

namespace MachO {
class Binary;
class FatBinary;

//! The main interface to parse a Mach-O binary.
//!
//! This class is used to parse both Fat & non-Fat binary.
//! Non-fat binaries are considerated as a **fat** with
//! only one architecture. This is why MachO::Parser::parse outputs
//! a FatBinary object.
class LIEF_API Parser : public LIEF::Parser {
  public:
  Parser& operator=(const Parser& copy) = delete;
  Parser(const Parser& copy)            = delete;

  ~Parser() override;

  //! Parse a Mach-O file from the path provided by the ``filename``
  //! parameter
  //!
  //! The @p conf parameter can be used to tweak the configuration
  //! of the parser
  //!
  //! @param[in] filename   Path to the Mach-O file
  //! @param[in] conf       Parser configuration (Defaut: ParserConfig::deep)
  static std::unique_ptr<FatBinary> parse(const std::string& filename,
                                          const ParserConfig& conf = ParserConfig::deep());

  //! Parse a Mach-O file from the raw content provided by the ``data``
  //! parameter
  //!
  //! The @p conf parameter can be used to tweak the configuration
  //! of the parser
  //!
  //! @param[in] data       Mach-O file as a vector of bytes
  //! @param[in] conf       Parser configuration (Defaut: ParserConfig::deep)
  static std::unique_ptr<FatBinary> parse(const std::vector<uint8_t>& data,
                                          const ParserConfig& conf = ParserConfig::deep());


  //! Parser a Mach-O binary from the provided BinaryStream.
  static std::unique_ptr<FatBinary> parse(std::unique_ptr<BinaryStream> stream,
                                          const ParserConfig& conf = ParserConfig::deep());

  //! Parse the Mach-O binary from the address given in the first parameter
  static std::unique_ptr<FatBinary> parse_from_memory(uintptr_t address,
                                                      const ParserConfig& conf = ParserConfig::deep());

  //! Parse the Mach-O binary from the address given in the first parameter
  //! and the size given in the second parameter
  static std::unique_ptr<FatBinary> parse_from_memory(uintptr_t address, size_t size,
                                                      const ParserConfig& conf = ParserConfig::deep());

  private:
  Parser(const std::string& file, const ParserConfig& conf);
  Parser(std::vector<uint8_t> data, const ParserConfig& conf);
  Parser();

  ok_error_t build();
  ok_error_t build_fat();

  ok_error_t undo_reloc_bindings(uintptr_t base_address);

  std::unique_ptr<BinaryStream> stream_;
  std::vector<std::unique_ptr<Binary>> binaries_;
  ParserConfig config_;
};
}
}
#endif

```

`KDemu/include/LIEF/LIEF/MachO/ParserConfig.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_PARSER_CONFIG_H
#define LIEF_MACHO_PARSER_CONFIG_H
#include "LIEF/visibility.h"

namespace LIEF {
namespace MachO {

//! This structure is used to tweak the MachO Parser (MachO::Parser)
struct LIEF_API ParserConfig {
  //! Return a parser configuration such as all the objects supported by
  //! LIEF are parsed
  static ParserConfig deep();

  //! Return a configuration to parse the most important MachO
  //! structures
  static ParserConfig quick();

  //! If ``flag`` is set to ``true``, Exports, Bindings and Rebases opcodes are
  //! parsed.
  //!
  //! @warning Enabling this flag can slow down the parsing
  ParserConfig& full_dyldinfo(bool flag);

  bool parse_dyld_exports  = true; ///< Parse the Dyld export trie
  bool parse_dyld_bindings = true; ///< Parse the Dyld binding opcodes
  bool parse_dyld_rebases  = true; ///< Parse the Dyld rebase opcodes
  bool parse_overlay = true; ///< Whether the overlay data should be parsed

  /// When parsing Mach-O from memory, this option
  /// can be used to *undo* relocations and symbols bindings.
  ///
  /// When activated, this option requires parse_dyld_bindings
  /// and parse_dyld_rebases to be enabled.
  bool fix_from_memory = false;
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/MachO/RPathCommand.hpp`:

```hpp
/* Copyright 2017 - 2021 J. Rieck (based on R. Thomas's work)
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_RPATH_COMMAND_H
#define LIEF_MACHO_RPATH_COMMAND_H
#include <string>
#include <ostream>

#include "LIEF/visibility.h"

#include "LIEF/MachO/LoadCommand.hpp"

namespace LIEF {
namespace MachO {

namespace details {
struct rpath_command;
}

//! Class that represents the LC_RPATH command.
//!
//! This command is used to add path for searching libraries
//! associated with the ``@rpath`` prefix.
class LIEF_API RPathCommand : public LoadCommand {
  public:
  RPathCommand() = default;
  RPathCommand(const details::rpath_command& rpathCmd);

  RPathCommand& operator=(const RPathCommand& copy) = default;
  RPathCommand(const RPathCommand& copy) = default;

  std::unique_ptr<LoadCommand> clone() const override {
    return std::unique_ptr<RPathCommand>(new RPathCommand(*this));
  }

  ~RPathCommand() override = default;

  //! The rpath value as a string
  const std::string& path() const {
    return path_;
  }

  void path(std::string path) {
    path_ = std::move(path);
  }

  void accept(Visitor& visitor) const override;

  std::ostream& print(std::ostream& os) const override;

  static bool classof(const LoadCommand* cmd) {
    return cmd->command() == LoadCommand::TYPE::RPATH;
  }

  private:
  std::string path_;
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/MachO/Relocation.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_RELOCATION_COMMAND_H
#define LIEF_MACHO_RELOCATION_COMMAND_H
#include <ostream>
#include <memory>

#include "LIEF/Abstract/Relocation.hpp"

#include "LIEF/MachO/Header.hpp"
#include "LIEF/visibility.h"
#include "LIEF/Object.hpp"

namespace LIEF {
namespace MachO {
class BinaryParser;
class Section;
class SegmentCommand;
class Symbol;

//! Class that represents a Mach-O relocation
//!
//! @see:
//!   * MachO::RelocationObject
//!   * MachO::RelocationDyld
//!   * MachO::RelocationFixup
class LIEF_API Relocation : public LIEF::Relocation {

  friend class BinaryParser;

  public:
  using LIEF::Relocation::address;
  using LIEF::Relocation::size;

  enum class ORIGIN {
    UNKNOWN        = 0,
    DYLDINFO       = 1,
    RELOC_TABLE    = 2,
    CHAINED_FIXUPS = 3,
  };

  static constexpr auto R_SCATTERED = uint32_t(0x80000000);
  static constexpr auto R_ABS = uint32_t(0);

  Relocation() = default;
  Relocation(uint64_t address, uint8_t type);

  Relocation& operator=(const Relocation& other);
  Relocation(const Relocation& other);
  void swap(Relocation& other) noexcept;

  ~Relocation() override = default;

  virtual std::unique_ptr<Relocation> clone() const = 0;

  //! Indicates whether the item containing the address to be
  //! relocated is part of a CPU instruction that uses PC-relative addressing.
  //!
  //! For addresses contained in PC-relative instructions, the CPU adds the address of
  //! the instruction to the address contained in the instruction.
  virtual bool is_pc_relative() const = 0;

  //! Type of the relocation according to the
  //! Relocation::architecture and/or the Relocation::origin
  //!
  //! See:
  //!   * MachO::X86_RELOCATION
  //!   * MachO::X86_64_RELOCATION
  //!   * MachO::PPC_RELOCATION
  //!   * MachO::ARM_RELOCATION
  //!   * MachO::ARM64_RELOCATION
  //!   * MachO::REBASE_TYPES
  virtual uint8_t type() const {
    return type_;
  }

  //! Achitecture targeted by this relocation
  Header::CPU_TYPE architecture() const {
    return architecture_;
  }

  //! Origin of the relocation
  virtual ORIGIN origin() const = 0;

  //! ``true`` if the relocation has a symbol associated with
  bool has_symbol() const {
    return symbol() != nullptr;
  }

  //! Symbol associated with the relocation, if any,
  //! otherwise a nullptr.
  Symbol* symbol() {
    return symbol_;
  }
  const Symbol* symbol() const {
    return symbol_;
  }

  //! ``true`` if the relocation has a section associated with
  bool has_section() const {
    return section() != nullptr;
  }

  //! Section associated with the relocation, if any,
  //! otherwise a nullptr.
  Section* section() {
    return section_;
  }
  const Section* section() const {
    return section_;
  }

  //! ``true`` if the relocation has a SegmentCommand associated with
  bool has_segment() const {
    return segment() != nullptr;
  }

  //! SegmentCommand associated with the relocation, if any,
  //! otherwise a nullptr.
  SegmentCommand* segment() {
    return segment_;
  }
  const SegmentCommand* segment() const {
    return segment_;
  }

  virtual void pc_relative(bool val) = 0;
  virtual void type(uint8_t type);

  void accept(Visitor& visitor) const override;

  virtual std::ostream& print(std::ostream& os) const;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const Relocation& relocation);

  protected:
  Symbol*         symbol_ = nullptr;
  uint8_t         type_ = 0;
  Header::CPU_TYPE architecture_ = Header::CPU_TYPE::ANY;
  Section*        section_ = nullptr;
  SegmentCommand* segment_ = nullptr;
};


LIEF_API const char* to_string(Relocation::ORIGIN e);

}
}
#endif

```

`KDemu/include/LIEF/LIEF/MachO/RelocationDyld.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_RELOCATION_DYLD_COMMAND_H
#define LIEF_MACHO_RELOCATION_DYLD_COMMAND_H
#include <ostream>

#include "LIEF/visibility.h"

#include "LIEF/MachO/Relocation.hpp"

namespace LIEF {
namespace MachO {

class BinaryParser;

//! Class that represents a relocation found in the DyldInfo structure.
//!
//! While this class does not have an associated structure in the Mach-O format specification,
//! it provides a convenient interface for the Dyld::rebase
class LIEF_API RelocationDyld : public Relocation {

  friend class BinaryParser;

  public:
  using Relocation::Relocation;
  using LIEF::Relocation::operator<;
  using LIEF::Relocation::operator<=;
  using LIEF::Relocation::operator>;
  using LIEF::Relocation::operator>=;
  RelocationDyld() = default;

  RelocationDyld& operator=(const RelocationDyld&) = default;
  RelocationDyld(const RelocationDyld&) = default;

  ~RelocationDyld() override = default;

  std::unique_ptr<Relocation> clone() const override {
    return std::unique_ptr<RelocationDyld>(new RelocationDyld(*this));
  }

  //! Indicates whether the item containing the address to be
  //! relocated is part of a CPU instruction that uses PC-relative addressing.
  //!
  //! For addresses contained in PC-relative instructions, the CPU adds the address of
  //! the instruction to the address contained in the instruction.
  bool is_pc_relative() const override;

  //! Origin of the relocation. For this concrete object, it
  //! should be Relocation::ORIGIN::DYLDINFO
  ORIGIN origin() const override {
    return ORIGIN::DYLDINFO;
  }

  void pc_relative(bool val) override;

  bool operator<(const RelocationDyld& rhs) const;
  bool operator>=(const RelocationDyld& rhs) const {
    return !(*this < rhs);
  }

  bool operator>(const RelocationDyld& rhs) const;
  bool operator<=(const RelocationDyld& rhs) const {
    return !(*this > rhs);
  }

  void accept(Visitor& visitor) const override;

  static bool classof(const Relocation& r) {
    return r.origin() == Relocation::ORIGIN::DYLDINFO;
  }

  std::ostream& print(std::ostream& os) const override {
    return Relocation::print(os);
  }
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/MachO/RelocationFixup.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_RELOCATION_FIXUP_H
#define LIEF_MACHO_RELOCATION_FIXUP_H
#include <ostream>
#include <memory>

#include "LIEF/visibility.h"

#include "LIEF/MachO/Relocation.hpp"
#include "LIEF/MachO/DyldChainedFormat.hpp"

namespace LIEF {
namespace MachO {

namespace details {
struct dyld_chained_ptr_arm64e_rebase;
struct dyld_chained_ptr_arm64e_auth_rebase;
struct dyld_chained_ptr_64_rebase;
struct dyld_chained_ptr_32_rebase;
}

class BinaryParser;
class Builder;

//! Class that represents a rebase relocation found in the `LC_DYLD_CHAINED_FIXUPS` command.
//!
//! This class extends LIEF::Relocation in which LIEF::Relocation::address is set to
//! the absolute virtual address where the relocation must take place (e.g. `0x10000d270`).
//!
//! On the other hand, RelocationFixup::target contains the value that should be
//! set at LIEF::Relocation::address if the imagebase is LIEF::Binary::imagebase (e.g. `0x1000073a8`).
//!
//! If the Mach-O loader chooses another base address (like 0x7ff100000), it must set
//! `0x10000d270` to `0x7ff1073a8`.
class LIEF_API RelocationFixup : public Relocation {

  friend class BinaryParser;
  friend class Builder;

  public:
  RelocationFixup() = delete;
  RelocationFixup(DYLD_CHAINED_PTR_FORMAT fmt, uint64_t imagebase);

  RelocationFixup& operator=(const RelocationFixup&);
  RelocationFixup(const RelocationFixup&);

  RelocationFixup& operator=(RelocationFixup&&) noexcept = default;
  RelocationFixup(RelocationFixup&&) noexcept = default;

  ~RelocationFixup() override;

  std::unique_ptr<Relocation> clone() const override {
    return std::unique_ptr<RelocationFixup>(new RelocationFixup(*this));
  }

  //! Not relevant for this kind of relocation
  bool is_pc_relative() const override {
    return false;
  }

  //! Origin of the relocation. For this concrete object, it
  //! should be Relocation::ORIGIN::CHAINED_FIXUPS
  ORIGIN origin() const override {
    return ORIGIN::CHAINED_FIXUPS;
  }

  DYLD_CHAINED_PTR_FORMAT ptr_format() const {
    return ptr_fmt_;
  }

  //! The value that should be set at the address pointed by LIEF::Relocation::address
  //! if the imagebase chosen by the loader is LIEF::Binary::imagebase.
  //! Otherwise: target() - LIEF::Binary::imagebase() + new_imagebase.
  uint64_t target() const;
  void target(uint64_t target);

  //! Not relevant for this kind of relocation
  void pc_relative(bool) override {}

  uint32_t offset() const {
    return offset_;
  }

  void offset(uint32_t offset) {
    offset_ = offset;
  }

  //! The address of this relocation is bound to its offset.
  uint64_t address() const override {
    return imagebase_ + offset_;
  }

  //! Changing the address means changing the offset
  void address(uint64_t address) override {
    offset_ = address - imagebase_;
  }

  void accept(Visitor& visitor) const override;

  static bool classof(const Relocation& r) {
    return r.origin() == Relocation::ORIGIN::CHAINED_FIXUPS;
  }

  std::ostream& print(std::ostream& os) const override;

  private:
  enum class REBASE_TYPES {
    UNKNOWN = 0,

    ARM64E_REBASE,
    ARM64E_AUTH_REBASE,
    PTR64_REBASE,
    PTR32_REBASE,
  };

  void set(const details::dyld_chained_ptr_arm64e_rebase& fixup);
  void set(const details::dyld_chained_ptr_arm64e_auth_rebase& fixup);
  void set(const details::dyld_chained_ptr_64_rebase& fixup);
  void set(const details::dyld_chained_ptr_32_rebase& fixup);

  DYLD_CHAINED_PTR_FORMAT ptr_fmt_ = DYLD_CHAINED_PTR_FORMAT::PTR_32;
  uint64_t imagebase_ = 0;
  uint32_t offset_ = 0;

  REBASE_TYPES rtypes_ = REBASE_TYPES::UNKNOWN;

  union {
    details::dyld_chained_ptr_arm64e_rebase*      arm64_rebase_ = nullptr;
    details::dyld_chained_ptr_arm64e_auth_rebase* arm64_auth_rebase_;
    details::dyld_chained_ptr_64_rebase*          p64_rebase_;
    details::dyld_chained_ptr_32_rebase*          p32_rebase_;
  };
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/MachO/RelocationObject.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_RELOCATION_OBJECT_COMMAND_H
#define LIEF_MACHO_RELOCATION_OBJECT_COMMAND_H
#include <ostream>

#include "LIEF/visibility.h"

#include "LIEF/MachO/Relocation.hpp"

namespace LIEF {
namespace MachO {

class BinaryParser;

namespace details {
struct relocation_info;
struct scattered_relocation_info;
}

//! Class that represents a relocation presents in the MachO object
//! file (``.o``). Usually, this kind of relocation is found in the MachO::Section
//!
//! @see RelocationDyld
class LIEF_API RelocationObject : public Relocation {

  friend class BinaryParser;

  public:
  using Relocation::Relocation;
  RelocationObject() = default;
  RelocationObject(const details::relocation_info& relocinfo);
  RelocationObject(const details::scattered_relocation_info& scattered_relocinfo);

  RelocationObject& operator=(const RelocationObject& other) = default;
  RelocationObject(const RelocationObject& other) = default;

  void swap(RelocationObject& other) noexcept;

  ~RelocationObject() override = default;

  std::unique_ptr<Relocation> clone() const override {
    return std::unique_ptr<RelocationObject>(new RelocationObject(*this));
  }

  //! Whether the relocation is PC relative
  bool is_pc_relative() const override {
    return is_pcrel_;
  }

  //! Size of the relocation
  size_t size() const override;

  //! Address where the relocation is applied
  //! This address is relative to the start of the section where the relocation takes place
  uint64_t address() const override;

  //! ``true`` if the relocation is a scattered one
  bool is_scattered() const {
    return is_scattered_;
  }

  //! For **scattered** relocations:
  //! The address of the relocatable expression for the item in the file that needs
  //! to be updated if the address is changed.
  //!
  //! For relocatable expressions with the difference of two section addresses,
  //! the address from which to subtract (in mathematical terms, the minuend)
  //! is contained in the first relocation entry and the address to subtract (the subtrahend)
  //! is contained in the second relocation entry.
  int32_t value() const;

  //! Origin of the relocation. For this object it should be Relocation::ORIGIN::RELOC_TABLE)
  ORIGIN origin() const override {
    return ORIGIN::RELOC_TABLE;
  }

  void pc_relative(bool val) override {
    is_pcrel_ = val;
  }
  void size(size_t size) override;

  void value(int32_t value);

  void accept(Visitor& visitor) const override;

  std::ostream& print(std::ostream& os) const override {
    return Relocation::print(os);
  }

  static bool classof(const Relocation& r) {
    return r.origin() == Relocation::ORIGIN::RELOC_TABLE;
  }

  private:
  bool is_pcrel_ = false;
  bool is_scattered_ = false;
  int32_t value_ = 0;
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/MachO/Section.h`:

```h
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef C_LIEF_MACHO_SECTION_H_
#define C_LIEF_MACHO_SECTION_H_
#include <inttypes.h>

#include "LIEF/MachO/enums.h"
#ifdef __cplusplus
extern "C" {
#endif

struct Macho_Section_t {

  const char*              name;
  uint32_t                 alignment;
  uint32_t                 relocation_offset;
  uint32_t                 numberof_relocations;
  uint32_t                 flags;
  enum LIEF_MACHO_MACHO_SECTION_TYPES type;
  uint32_t                 reserved1;
  uint32_t                 reserved2;
  uint32_t                 reserved3;
  uint64_t                 virtual_address;
  uint64_t                 offset;
  uint64_t                 size;
  uint8_t*                 content;
  double                   entropy;
};

typedef struct Macho_Section_t Macho_Section_t;


#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/include/LIEF/LIEF/MachO/Section.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_SECTION_H
#define LIEF_MACHO_SECTION_H
#include <string>
#include <vector>
#include <ostream>
#include <memory>

#include "LIEF/visibility.h"

#include "LIEF/Abstract/Section.hpp"
#include "LIEF/enums.hpp"

#include "LIEF/iterators.hpp"

namespace LIEF {
namespace MachO {

class BinaryParser;
class SegmentCommand;
class Binary;
class Relocation;

namespace details {
struct section_32;
struct section_64;
}

//! Class that represents a Mach-O section
class LIEF_API Section : public LIEF::Section {

  friend class BinaryParser;
  friend class Binary;
  friend class SegmentCommand;

  public:
  using content_t   = std::vector<uint8_t>;

  //! Internal container for storing Mach-O Relocation
  using relocations_t = std::vector<std::unique_ptr<Relocation>>;

  //! Iterator which outputs Relocation&
  using it_relocations = ref_iterator<relocations_t&, Relocation*>;

  //! Iterator which outputs const Relocation&
  using it_const_relocations = const_ref_iterator<const relocations_t&, const Relocation*>;

  static constexpr auto FLAGS_MASK = uint32_t(0xffffff00u);
  static constexpr auto TYPE_MASK = uint32_t(0xff);

  enum class TYPE: uint64_t  {
    REGULAR                             = 0x00u, ///< Regular section.
    ZEROFILL                            = 0x01u, ///< Zero fill on demand section.
    CSTRING_LITERALS                    = 0x02u, ///< Section with literal C strings.
    S_4BYTE_LITERALS                    = 0x03u, ///< Section with 4 byte literals.
    S_8BYTE_LITERALS                    = 0x04u, ///< Section with 8 byte literals.
    LITERAL_POINTERS                    = 0x05u, ///< Section with pointers to literals.
    NON_LAZY_SYMBOL_POINTERS            = 0x06u, ///< Section with non-lazy symbol pointers.
    LAZY_SYMBOL_POINTERS                = 0x07u, ///< Section with lazy symbol pointers.
    SYMBOL_STUBS                        = 0x08u, ///< Section with symbol stubs, byte size of stub in the Reserved2 field.
    MOD_INIT_FUNC_POINTERS              = 0x09u, ///< Section with only function pointers for initialization.
    MOD_TERM_FUNC_POINTERS              = 0x0au, ///< Section with only function pointers for termination.
    COALESCED                           = 0x0bu, ///< Section contains symbols that are to be coalesced.
    GB_ZEROFILL                         = 0x0cu, ///< Zero fill on demand section (that can be larger than 4 gigabytes).
    INTERPOSING                         = 0x0du, ///< Section with only pairs of function pointers for interposing.
    S_16BYTE_LITERALS                   = 0x0eu, ///< Section with only 16 byte literals.
    DTRACE_DOF                          = 0x0fu, ///< Section contains DTrace Object Format.
    LAZY_DYLIB_SYMBOL_POINTERS          = 0x10u, ///< Section with lazy symbol pointers to lazy loaded dylibs.
    THREAD_LOCAL_REGULAR                = 0x11u, ///< Thread local data section.
    THREAD_LOCAL_ZEROFILL               = 0x12u, ///< Thread local zerofill section.
    THREAD_LOCAL_VARIABLES              = 0x13u, ///< Section with thread local variable structure data.
    THREAD_LOCAL_VARIABLE_POINTERS      = 0x14u, ///< Section with pointers to thread local structures.
    THREAD_LOCAL_INIT_FUNCTION_POINTERS = 0x15u, ///< Section with thread local variable initialization pointers to functions.
    INIT_FUNC_OFFSETS                   = 0x16u, ///< Section with 32-bit offsets to initializer functions
  };

  enum class FLAGS: uint64_t  {
    PURE_INSTRUCTIONS   = 0x80000000u, ///< Section contains only true machine instructions
    NO_TOC              = 0x40000000u, ///< Section contains coalesced symbols that are not to be in a ranlib table of contents.
    STRIP_STATIC_SYMS   = 0x20000000u, ///< Ok to strip static symbols in this section in files with the MY_DYLDLINK flag.
    NO_DEAD_STRIP       = 0x10000000u, ///< No dead stripping.
    LIVE_SUPPORT        = 0x08000000u, ///< Blocks are live if they reference live blocks.
    SELF_MODIFYING_CODE = 0x04000000u, ///< Used with i386 code stubs written on by dyld
    DEBUG_INFO          = 0x02000000u, ///< A debug section.

    SOME_INSTRUCTIONS   = 0x00000400u, ///< Section contains some machine instructions.
    EXT_RELOC           = 0x00000200u, ///< Section has external relocation entries.
    LOC_RELOC           = 0x00000100u, ///< Section has local relocation entries.
  };

  public:
  Section();
  Section(const details::section_32& section_cmd);
  Section(const details::section_64& section_cmd);

  Section(std::string name);
  Section(std::string name, content_t content);

  Section& operator=(Section copy);
  Section(const Section& copy);

  void swap(Section& other) noexcept;

  ~Section() override;

  span<const uint8_t> content() const override;

  //! Update the content of the section
  void content(const content_t& data) override;

  //! Return the name of the segment linked to this section
  const std::string& segment_name() const;

  //! Virtual base address of the section
  uint64_t address() const {
    return virtual_address();
  }

  //! Section alignment as a power of 2
  uint32_t alignment() const {
    return align_;
  }

  //! Offset of the relocation table. This value should be 0
  //! for executable and libraries as the relocations are managed by the DyldInfo::rebase
  //!
  //! On the other hand, for object files (``.o``) this value should not be 0
  //!
  //! @see numberof_relocations
  //! @see relocations
  uint32_t relocation_offset() const {
    return relocations_offset_;
  }

  //! Number of relocations associated with this section
  uint32_t numberof_relocations() const {
    return nbof_relocations_;
  }

  //! Section's flags masked with SECTION_FLAGS_MASK (see: Section::FLAGS)
  //!
  //! @see flags
  FLAGS flags() const {
    return FLAGS(flags_ & FLAGS_MASK);
  }

  //! Type of the section. This value can help to determine
  //! the purpose of the section (e.g. MACHO_SECTION_TYPES::MACHO_SECTION_TYPES)
  TYPE type() const {
    return TYPE(flags_ & TYPE_MASK);
  }

  //! According to the official ``loader.h`` file, this value is reserved
  //! for *offset* or *index*
  uint32_t reserved1() const {
    return reserved1_;
  }

  //! According to the official ``loader.h`` file, this value is reserved
  //! for *count* or *sizeof*
  uint32_t reserved2() const {
    return reserved2_;
  }

  //! This value is only present for 64 bits Mach-O files. In that case,
  //! the value is *reserved*.
  uint32_t reserved3() const {
    return reserved3_;
  }

  //! Return the Section::flags as a list of Section::FLAGS
  //! @see flags
  std::vector<FLAGS> flags_list() const;

  //! Section flags without applying the SECTION_FLAGS_MASK mask
  uint32_t raw_flags() const {
    return flags_;
  }

  //! Check if this section is correctly linked with a MachO::SegmentCommand
  bool has_segment() const {
    return segment() != nullptr;
  }

  //! The segment associated with this section or a nullptr
  //! if not present
  SegmentCommand* segment() {
    return segment_;
  }
  const SegmentCommand* segment() const {
    return segment_;
  }

  //! Clear the content of this section by filling its values
  //! with the byte provided in parameter
  void clear(uint8_t v);

  //! Return an iterator over the MachO::Relocation associated with this section
  //!
  //! This iterator is likely to be empty of executable and libraries while it should not
  //! for object files (``.o``)
  it_relocations relocations() {
    return relocations_;
  }
  it_const_relocations relocations() const {
    return relocations_;
  }

  void segment_name(const std::string& name);
  void address(uint64_t address) {
    virtual_address(address);
  }
  void alignment(uint32_t align) {
    align_ = align;
  }
  void relocation_offset(uint32_t offset) {
    relocations_offset_ = offset;
  }
  void numberof_relocations(uint32_t nb_reloc) {
    nbof_relocations_ = nb_reloc;
  }
  void flags(uint32_t flags) {
    flags_ = flags_ | flags;
  }
  void flags(std::vector<FLAGS> flags);
  void type(TYPE type) {
    flags_ = (flags_ & FLAGS_MASK) | uint8_t(type);
  }
  void reserved1(uint32_t reserved1) {
    reserved1_ = reserved1;
  }
  void reserved2(uint32_t reserved2) {
    reserved2_ = reserved2;
  }
  void reserved3(uint32_t reserved3) {
    reserved3_ = reserved3;
  }

  //! Check if the section has the given Section::FLAGS flag
  bool has(FLAGS flag) const;

  //! Append a Section::FLAGS to the current section
  void add(FLAGS flag);

  //! Remove a Section::FLAGS to the current section
  void remove(FLAGS flag);

  Section& operator+=(FLAGS flag) {
    add(flag);
    return *this;
  }
  Section& operator-=(FLAGS flag) {
    remove(flag);
    return *this;
  }

  void accept(Visitor& visitor) const override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const Section& section);

  private:
  std::string segment_name_;
  uint64_t original_size_ = 0;
  uint32_t align_ = 0;
  uint32_t relocations_offset_ = 0;
  uint32_t nbof_relocations_ = 0;
  uint32_t flags_ = 0;
  uint32_t reserved1_ = 0;
  uint32_t reserved2_ = 0;
  uint32_t reserved3_ = 0;
  content_t content_;
  SegmentCommand *segment_ = nullptr;
  relocations_t relocations_;
};

LIEF_API const char* to_string(Section::TYPE type);
LIEF_API const char* to_string(Section::FLAGS flag);

}
}

ENABLE_BITMASK_OPERATORS(LIEF::MachO::Section::FLAGS)
#endif

```

`KDemu/include/LIEF/LIEF/MachO/Segment.h`:

```h
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef C_LIEF_MACHO_SEGMENT_H_
#define C_LIEF_MACHO_SEGMENT_H_
#include <inttypes.h>

#include "LIEF/MachO/enums.h"
#include "LIEF/MachO/Section.h"
#ifdef __cplusplus
extern "C" {
#endif

struct Macho_Segment_t {
  const char*       name;
  uint64_t          virtual_address;
  uint64_t          virtual_size;
  uint64_t          file_size;
  uint64_t          file_offset;
  uint32_t          max_protection;
  uint32_t          init_protection;
  uint32_t          numberof_sections;
  uint32_t          flags;
  uint8_t*          content;
  uint64_t          size;
  Macho_Section_t** sections;
};

typedef struct Macho_Segment_t Macho_Segment_t;


#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/include/LIEF/LIEF/MachO/SegmentCommand.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_SEGMENT_COMMAND_H
#define LIEF_MACHO_SEGMENT_COMMAND_H

#include <string>
#include <vector>
#include <ostream>
#include <memory>

#include "LIEF/enums.hpp"
#include "LIEF/span.hpp"
#include "LIEF/visibility.h"

#include "LIEF/iterators.hpp"
#include "LIEF/MachO/LoadCommand.hpp"


namespace LIEF {
namespace MachO {

class BinaryParser;
class Binary;
class Builder;
class Section;
class Relocation;
class DyldInfo;

namespace details {
struct segment_command_32;
struct segment_command_64;
}

//! Class which represents a LoadCommand::TYPE::SEGMENT / LoadCommand::TYPE::SEGMENT_64 command
class LIEF_API SegmentCommand : public LoadCommand {

  friend class BinaryParser;
  friend class Binary;
  friend class Section;
  friend class Builder;

  public:
  using content_t = std::vector<uint8_t>;

  //! Internal container for storing Mach-O Section
  using sections_t = std::vector<std::unique_ptr<Section>>;

  //! Iterator which outputs Section&
  using it_sections = ref_iterator<sections_t&, Section*>;

  //! Iterator which outputs const Section&
  using it_const_sections = const_ref_iterator<const sections_t&, const Section*>;

  //! Internal container for storing Mach-O Relocation
  using relocations_t = std::vector<std::unique_ptr<Relocation>>;

  //! Iterator which outputs Relocation&
  using it_relocations = ref_iterator<relocations_t&, Relocation*>;

  //! Iterator which outputs const Relocation&
  using it_const_relocations = const_ref_iterator<const relocations_t&, const Relocation*>;

  enum class FLAGS: uint64_t  {
    HIGHVM              = 0x1u, ///< The file contents for this segment are for the high part of the virtual memory space; the low part is zero filled (for stacks in core files).
    FVMLIB              = 0x2u, ///< this segment is the VM that is allocated by a fixed VM library, for overlap checking in the link editor.
    NORELOC             = 0x4u, ///< This segment has nothing that was relocated in it and nothing relocated to it. It may be safely replaced without relocation.
    PROTECTED_VERSION_1 = 0x8u,
    READ_ONLY           = 0x10u,
  };

  //! Values for segment_command.initprot.
  //! From <mach/vm_prot.h>
  enum class VM_PROTECTIONS  {
    READ    = 0x1, ///< Reading data within the segment is allowed
    WRITE   = 0x2, ///< Writing data within the segment is allowed
    EXECUTE = 0x4, ///< Executing data within the segment is allowed
  };

  public:
  SegmentCommand();
  SegmentCommand(const details::segment_command_32& cmd);
  SegmentCommand(const details::segment_command_64& cmd);

  SegmentCommand& operator=(SegmentCommand other);
  SegmentCommand(const SegmentCommand& copy);

  SegmentCommand(std::string name, content_t content);

  SegmentCommand(std::string name);

  void swap(SegmentCommand& other) noexcept;

  std::unique_ptr<LoadCommand> clone() const override {
    return std::unique_ptr<SegmentCommand>(new SegmentCommand(*this));
  }

  ~SegmentCommand() override;

  //! Name of the segment (e.g. ``__TEXT``)
  const std::string& name() const {
    return name_;
  }

  //! Absolute virtual base address of the segment
  uint64_t virtual_address() const {
    return virtual_address_;
  }

  //! Virtual size of the segment
  uint64_t virtual_size() const {
    return virtual_size_;
  }

  //! Size of this segment in the binary file
  uint64_t file_size() const {
    return file_size_;
  }

  //! Offset of the data of this segment in the file
  uint64_t file_offset() const {
    return file_offset_;
  }

  //! The maximum of protections for this segment (cf. VM_PROTECTIONS)
  uint32_t max_protection() const {
    return max_protection_;
  }

  //! The initial protections of this segment (cf. VM_PROTECTIONS)
  uint32_t init_protection() const {
    return init_protection_;
  }

  //! The number of sections associated with this segment
  uint32_t numberof_sections() const {
    return nb_sections_;
  }

  //! Flags associated with this segment (cf. SegmentCommand::FLAGS)
  uint32_t flags() const {
    return flags_;
  }

  //! Return an iterator over the MachO::Section linked to this segment
  it_sections sections() {
    return sections_;
  }

  it_const_sections sections() const {
    return sections_;
  }

  //! Return an iterator over the MachO::Relocation linked to this segment
  //!
  //! For Mach-O executable or library this iterator should be empty as
  //! the relocations are managed by the Dyld::rebase_opcodes.
  //! On the other hand, for object files (``.o``) this iterator should not be empty
  it_relocations relocations() {
    return relocations_;
  }
  it_const_relocations relocations() const {
    return relocations_;
  }

  //! Get the section with the given name
  const Section* get_section(const std::string& name) const;
  Section* get_section(const std::string& name);

  //! The raw content of this segment
  span<const uint8_t> content() const {
    return data_;
  }

  //! The original index of this segment or -1 if not defined
  int8_t index() const {
    return this->index_;
  }

  void name(std::string name) {
    name_ = std::move(name);
  }

  void virtual_address(uint64_t virtual_address) {
    virtual_address_ = virtual_address;
  }
  void virtual_size(uint64_t virtual_size) {
    virtual_size_ = virtual_size;
  }
  void file_offset(uint64_t file_offset) {
    file_offset_ = file_offset;
  }
  void file_size(uint64_t file_size) {
    file_size_ = file_size;
  }
  void max_protection(uint32_t max_protection) {
    max_protection_ = max_protection;
  }
  void init_protection(uint32_t init_protection) {
    init_protection_ = init_protection;
  }
  void numberof_sections(uint32_t nb_section) {
    nb_sections_ = nb_section;
  }
  void flags(uint32_t flags) {
    flags_ = flags;
  }

  void content(content_t data);

  //! Add a new section in this segment
  Section& add_section(const Section& section);

  //! Remove all the sections linked to this segment
  void remove_all_sections();

  //! Check if the current segment embeds the given section
  bool has(const Section& section) const;

  //! Check if the current segment embeds the given section name
  bool has_section(const std::string& section_name) const;

  std::ostream& print(std::ostream& os) const override;

  void accept(Visitor& visitor) const override;

  static bool classof(const LoadCommand* cmd) {
    const LoadCommand::TYPE type = cmd->command();
    return type == LoadCommand::TYPE::SEGMENT ||
           type == LoadCommand::TYPE::SEGMENT_64;
  }

  protected:
  span<uint8_t> writable_content() {
    return data_;
  }

  void content_resize(size_t size);
  void content_insert(size_t where, size_t size);

  void content_extend(size_t width) {
    content_resize(data_.size() + width);
  }

  using update_fnc_t    = std::function<void(std::vector<uint8_t>&)>;
  using update_fnc_ws_t = std::function<void(std::vector<uint8_t>&, size_t, size_t)>;

  LIEF_LOCAL virtual void update_data(const update_fnc_t& f);
  LIEF_LOCAL virtual void update_data(const update_fnc_ws_t& f,
                                      size_t where, size_t size);

  std::string name_;
  uint64_t virtual_address_ = 0;
  uint64_t virtual_size_ = 0;
  uint64_t file_offset_ = 0;
  uint64_t file_size_ = 0;
  uint32_t max_protection_ = 0;
  uint32_t init_protection_ = 0;
  uint32_t nb_sections_ = 0;
  uint32_t flags_ = 0;
  int8_t  index_ = -1;
  content_t data_;
  sections_t sections_;
  relocations_t relocations_;
};

LIEF_API const char* to_string(SegmentCommand::FLAGS flag);
LIEF_API const char* to_string(SegmentCommand::VM_PROTECTIONS protection);

}
}

ENABLE_BITMASK_OPERATORS(LIEF::MachO::SegmentCommand::FLAGS)
ENABLE_BITMASK_OPERATORS(LIEF::MachO::SegmentCommand::VM_PROTECTIONS)

#endif

```

`KDemu/include/LIEF/LIEF/MachO/SegmentSplitInfo.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_SEGMENT_SPLIT_INFO_H
#define LIEF_MACHO_SEGMENT_SPLIT_INFO_H
#include <ostream>

#include "LIEF/visibility.h"
#include "LIEF/span.hpp"

#include "LIEF/MachO/LoadCommand.hpp"

namespace LIEF {
namespace MachO {
class BinaryParser;
class LinkEdit;

namespace details {
struct linkedit_data_command;
}

//! Class that represents the LoadCommand::TYPE::SEGMENT_SPLIT_INFO command
class LIEF_API SegmentSplitInfo : public LoadCommand {
  friend class BinaryParser;
  friend class LinkEdit;
  public:
  SegmentSplitInfo() = default;
  SegmentSplitInfo(const details::linkedit_data_command& cmd);

  SegmentSplitInfo& operator=(const SegmentSplitInfo& copy) = default;
  SegmentSplitInfo(const SegmentSplitInfo& copy) = default;

  std::unique_ptr<LoadCommand> clone() const override {
    return std::unique_ptr<SegmentSplitInfo>(new SegmentSplitInfo(*this));
  }

  uint32_t data_offset() const {
    return data_offset_;
  }
  uint32_t data_size() const {
    return data_size_;
  }

  void data_offset(uint32_t offset) {
    data_offset_ = offset;
  }
  void data_size(uint32_t size) {
    data_size_ = size;
  }

  span<uint8_t> content() {
    return content_;
  }

  span<const uint8_t> content() const {
    return content_;
  }

  ~SegmentSplitInfo() override = default;

  void accept(Visitor& visitor) const override;

  std::ostream& print(std::ostream& os) const override;

  static bool classof(const LoadCommand* cmd) {
    return cmd->command() == LoadCommand::TYPE::SEGMENT_SPLIT_INFO;
  }

  private:
  uint32_t data_offset_ = 0;
  uint32_t data_size_   = 0;
  span<uint8_t> content_;

};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/MachO/SourceVersion.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_SOURCE_VERSION_COMMAND_H
#define LIEF_MACHO_SOURCE_VERSION_COMMAND_H
#include <ostream>
#include <array>

#include "LIEF/visibility.h"

#include "LIEF/MachO/LoadCommand.hpp"

namespace LIEF {
namespace MachO {

namespace details {
struct source_version_command;
}

//! Class that represents the MachO LoadCommand::TYPE::SOURCE_VERSION
//! This command is used to provide the *version* of the sources used to
//! build the binary
class LIEF_API SourceVersion : public LoadCommand {

  public:
  //! Version is an array of **5** integers
  using version_t = std::array<uint32_t, 5>;

  SourceVersion() = default;
  SourceVersion(const details::source_version_command& version_cmd);

  SourceVersion& operator=(const SourceVersion& copy) = default;
  SourceVersion(const SourceVersion& copy) = default;

  std::unique_ptr<LoadCommand> clone() const override {
    return std::unique_ptr<SourceVersion>(new SourceVersion(*this));
  }

  ~SourceVersion() override = default;

  //! Return the version as an array
  const version_t& version() const {
    return version_;
  }
  void version(const version_t& version) {
    version_ = version;
  }

  void accept(Visitor& visitor) const override;

  std::ostream& print(std::ostream& os) const override;

  static bool classof(const LoadCommand* cmd) {
    return cmd->command() == LoadCommand::TYPE::SOURCE_VERSION;
  }

  private:
  version_t version_ = {0};
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/MachO/SubFramework.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_SUB_FRAMEWORK_H
#define LIEF_MACHO_SUB_FRAMEWORK_H
#include <string>
#include <ostream>

#include "LIEF/visibility.h"

#include "LIEF/MachO/LoadCommand.hpp"

namespace LIEF {
namespace MachO {

class BinaryParser;

namespace details {
struct sub_framework_command;
}

//! Class that represents the SubFramework command.
//! Accodring to the Mach-O ``loader.h`` documentation:
//!
//!
//! > A dynamically linked shared library may be a subframework of an umbrella
//! > framework.  If so it will be linked with "-umbrella umbrella_name" where
//! > Where "umbrella_name" is the name of the umbrella framework. A subframework
//! > can only be linked against by its umbrella framework or other subframeworks
//! > that are part of the same umbrella framework.  Otherwise the static link
//! > editor produces an error and states to link against the umbrella framework.
//! > The name of the umbrella framework for subframeworks is recorded in the
//! > following structure.
class LIEF_API SubFramework : public LoadCommand {
  friend class BinaryParser;
  public:
  SubFramework() = default;
  SubFramework(const details::sub_framework_command& cmd);

  SubFramework& operator=(const SubFramework& copy) = default;
  SubFramework(const SubFramework& copy) = default;

  std::unique_ptr<LoadCommand> clone() const override {
    return std::unique_ptr<SubFramework>(new SubFramework(*this));
  }

  //! Name of the umbrella framework
  const std::string& umbrella() const {
    return umbrella_;
  }
  void umbrella(std::string u) {
    umbrella_ = std::move(u);
  }

  ~SubFramework() override = default;

  void accept(Visitor& visitor) const override;

  std::ostream& print(std::ostream& os) const override;

  static bool classof(const LoadCommand* cmd) {
    return cmd->command() == LoadCommand::TYPE::SUB_FRAMEWORK;
  }

  private:
  std::string umbrella_;
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/MachO/Symbol.h`:

```h
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef C_LIEF_MACHO_SYMBOL_H_
#define C_LIEF_MACHO_SYMBOL_H_
#include <inttypes.h>

#include "LIEF/MachO/enums.h"

#ifdef __cplusplus
extern "C" {
#endif

struct Macho_Symbol_t {
  const char* name;
  uint8_t     type;
  uint8_t     numberof_sections;
  uint16_t    description;
  uint64_t    value;
};

typedef struct Macho_Symbol_t Macho_Symbol_t;


#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/include/LIEF/LIEF/MachO/Symbol.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_SYMBOL_H
#define LIEF_MACHO_SYMBOL_H

#include <ostream>

#include "LIEF/visibility.h"

#include "LIEF/Abstract/Symbol.hpp"

#include "LIEF/MachO/LoadCommand.hpp"

namespace LIEF {
namespace MachO {

class BinaryParser;
class BindingInfo;
class ExportInfo;
class DylibCommand;
class Binary;

namespace details {
struct nlist_32;
struct nlist_64;
}

//! Class that represents a Symbol in a Mach-O file.
//!
//! A Mach-O symbol can come from:
//! 1. The symbols command (LC_SYMTAB / SymbolCommand)
//! 2. The Dyld Export trie
//! 3. The Dyld Symbol bindings
class LIEF_API Symbol : public LIEF::Symbol {

  friend class BinaryParser;
  friend class Binary;

  public:

  //! Category of the symbol when the symbol comes from the `LC_SYMTAB` command.
  //! The category is defined according to the `LC_DYSYMTAB` (DynamicSymbolCommand) command.
  enum class CATEGORY : uint32_t {
    NONE = 0,
    LOCAL,
    EXTERNAL,
    UNDEFINED,

    INDIRECT_ABS,
    INDIRECT_LOCAL,
  };

  enum class ORIGIN : uint32_t {
    UNKNOWN     = 0,
    DYLD_EXPORT = 1,
    DYLD_BIND   = 2, /// The symbol comes from the binding opcodes
    LC_SYMTAB   = 3,
  };

  enum class TYPE : uint32_t{
    UNDEFINED     = 0x0u, ///< The symbol is undefined. It is referenced in a different module.
    ABSOLUTE_SYM  = 0x2u, ///< The symbol is absolute. The linker doesn't update his value.
    SECTION       = 0xeu, ///< The symbol is defined in the section number given in nlist_base.n_sect .
    PREBOUND      = 0xcu, ///< The symbol is undefined and the image is using a prebound value for the symbol. Set the n_sect field to NO_SECT .
    INDIRECT      = 0xau  ///< The symbol is defined to be the same as another symbol. The n_value field is an index into the string table specifying the name of the other symbol. When that symbol is linked, both this and the other symbol point to the same defined type and value.
  };

  //! Same as N_TYPE
  static constexpr uint32_t TYPE_MASK = 0x0e;

  Symbol() = default;

  Symbol(const details::nlist_32& cmd);
  Symbol(const details::nlist_64& cmd);

  Symbol& operator=(Symbol other);
  Symbol(const Symbol& other);
  void swap(Symbol& other) noexcept;

  ~Symbol() override = default;

  //! Raw value of `nlist_xx.n_type`
  uint8_t raw_type() const {
    return type_;
  }

  //! Type as defined by `nlist_xx.n_type & N_TYPE`
  TYPE type() const {
    return TYPE(type_ & TYPE_MASK);
  }

  //! It returns the number of sections in which this symbol can be found.
  //! If the symbol can't be found in any section, it returns 0 (NO_SECT)
  uint8_t numberof_sections() const {
    return numberof_sections_;
  }

  //! Return information about the symbol (SYMBOL_DESCRIPTIONS)
  uint16_t description() const {
    return description_;
  }

  //! True if the symbol is associated with an ExportInfo
  //! This value is set when the symbol comes from the Dyld Export trie
  bool has_export_info() const {
    return export_info() != nullptr;
  }

  //! Return the ExportInfo associated with this symbol (or nullptr if not present)
  //! @see has_export_info
  const ExportInfo* export_info() const {
    return export_info_;
  }
  ExportInfo* export_info() {
    return export_info_;
  }

  //! True if the symbol is associated with a BindingInfo
  //! This value is set when the symbol comes from the Dyld symbol bindings
  bool has_binding_info() const {
    return binding_info() != nullptr;
  }

  //! Return the BindingInfo associated with this symbol (or nullptr if not present)
  //! @see has_binding_info
  const BindingInfo* binding_info() const {
    return binding_info_;
  }

  BindingInfo* binding_info() {
    return binding_info_;
  }

  //! Try to demangle the symbol or return an empty string if it is not possible
  std::string demangled_name() const;

  //! True if the symbol is defined as an external symbol.
  bool is_external() const {
    return type() == TYPE::UNDEFINED;
  }

  //! Return the library in which the symbol is defined.
  //! It returns a null pointer if the library can't be resolved
  const DylibCommand* library() const {
    return library_;
  }

  DylibCommand* library() {
    return library_;
  }

  //! Return the origin of the symbol: from LC_SYMTAB command or from the Dyld information
  ORIGIN origin() const {
    return origin_;
  }

  //! Category of the symbol according to the `LC_DYSYMTAB` command
  CATEGORY category() const {
    return category_;
  }

  void raw_type(uint8_t type) {
    type_ = type;
  }
  void numberof_sections(uint8_t nbsections) {
    numberof_sections_ = nbsections;
  }
  void description(uint16_t desc) {
    description_ = desc;
  }

  void accept(Visitor& visitor) const override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const Symbol& symbol);

  static const Symbol& indirect_abs();
  static const Symbol& indirect_local();

  private:
  Symbol(CATEGORY cat) :
    category_(cat)
  {}
  void library(DylibCommand& library) {
    this->library_ = &library;
  }

  uint8_t type_ = 0;
  uint8_t numberof_sections_ = 0;
  uint16_t description_ = 0;

  BindingInfo* binding_info_ = nullptr;
  ExportInfo* export_info_ = nullptr;

  DylibCommand* library_ = nullptr;

  ORIGIN origin_ = ORIGIN::UNKNOWN;
  CATEGORY category_ = CATEGORY::NONE;
};

LIEF_API const char* to_string(Symbol::ORIGIN e);
LIEF_API const char* to_string(Symbol::CATEGORY e);
LIEF_API const char* to_string(Symbol::TYPE e);

}
}
#endif

```

`KDemu/include/LIEF/LIEF/MachO/SymbolCommand.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_SYMBOL_COMMAND_H
#define LIEF_MACHO_SYMBOL_COMMAND_H
#include <ostream>

#include "LIEF/visibility.h"
#include "LIEF/span.hpp"

#include "LIEF/MachO/LoadCommand.hpp"

namespace LIEF {
namespace MachO {
class BinaryParser;
class LinkEdit;

namespace details {
struct symtab_command;
}

//! Class that represents the LC_SYMTAB command
class LIEF_API SymbolCommand : public LoadCommand {
  friend class BinaryParser;
  friend class LinkEdit;

  public:
  SymbolCommand() = default;
  SymbolCommand(const details::symtab_command& command);

  SymbolCommand& operator=(const SymbolCommand& copy) = default;
  SymbolCommand(const SymbolCommand& copy) = default;

  std::unique_ptr<LoadCommand> clone() const override {
    return std::unique_ptr<SymbolCommand>(new SymbolCommand(*this));
  }

  ~SymbolCommand() override = default;

  //! Offset from the start of the file to the n_list associated with the command
  uint32_t symbol_offset() const {
    return symbols_offset_;
  }

  //! Number of symbols registered
  uint32_t numberof_symbols() const {
    return nb_symbols_;
  }

  //! Offset from the start of the file to the string table
  uint32_t strings_offset() const {
    return strings_offset_;
  }

  //! Size of the size string table
  uint32_t strings_size() const {
    return strings_size_;
  }

  void symbol_offset(uint32_t offset) {
    symbols_offset_ = offset;
  }
  void numberof_symbols(uint32_t nb) {
    nb_symbols_ = nb;
  }
  void strings_offset(uint32_t offset) {
    strings_offset_ = offset;
  }
  void strings_size(uint32_t size) {
    strings_size_ = size;
  }

  span<const uint8_t> symbol_table() const {
    return symbol_table_;
  }

  span<uint8_t> symbol_table() {
    return symbol_table_;
  }

  span<const uint8_t> string_table() const {
    return string_table_;
  }

  span<uint8_t> string_table() {
    return string_table_;
  }

  uint32_t original_str_size() const {
    return original_str_size_;
  }

  uint32_t original_nb_symbols() const {
    return original_nb_symbols_;
  }

  std::ostream& print(std::ostream& os) const override;

  void accept(Visitor& visitor) const override;

  static bool classof(const LoadCommand* cmd) {
    return cmd->command() == LoadCommand::TYPE::SYMTAB;
  }

  private:
  uint32_t symbols_offset_ = 0;
  uint32_t nb_symbols_     = 0;
  uint32_t strings_offset_ = 0;
  uint32_t strings_size_   = 0;

  uint32_t original_str_size_   = 0;
  uint32_t original_nb_symbols_ = 0;

  span<uint8_t> symbol_table_;
  span<uint8_t> string_table_;
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/MachO/ThreadCommand.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_THREAD_COMMAND_H
#define LIEF_MACHO_THREAD_COMMAND_H
#include <vector>
#include <ostream>

#include "LIEF/visibility.h"
#include "LIEF/span.hpp"

#include "LIEF/MachO/LoadCommand.hpp"
#include "LIEF/MachO/Header.hpp"

namespace LIEF {
namespace MachO {

class BinaryParser;

namespace details {
struct thread_command;
}

//! Class that represents the LC_THREAD / LC_UNIXTHREAD commands and that
//! can be used to get the binary entrypoint when the LC_MAIN (MainCommand) is not present
//!
//! Generally speaking, this command aims at defining the original state
//! of the main thread which includes the registers' values
class LIEF_API ThreadCommand : public LoadCommand {
  friend class BinaryParser;
  public:
  ThreadCommand() = default;
  ThreadCommand(const details::thread_command& cmd,
                Header::CPU_TYPE arch = Header::CPU_TYPE::ANY);
  ThreadCommand(uint32_t flavor, uint32_t count,
                Header::CPU_TYPE arch= Header::CPU_TYPE::ANY);

  ThreadCommand& operator=(const ThreadCommand& copy) = default;
  ThreadCommand(const ThreadCommand& copy) = default;

  std::unique_ptr<LoadCommand> clone() const override {
    return std::unique_ptr<ThreadCommand>(new ThreadCommand(*this));
  }

  ~ThreadCommand() override = default;

  //! Integer that defines a special *flavor* for the thread.
  //!
  //! The meaning of this value depends on the architecture(). The list of
  //! the values can be found in the XNU kernel files:
  //! - xnu/osfmk/mach/arm/thread_status.h  for the ARM/AArch64 architectures
  //! - xnu/osfmk/mach/i386/thread_status.h for the x86/x86-64 architectures
  uint32_t flavor() const {
    return flavor_;
  }

  //! Size of the thread state data with 32-bits alignment.
  //!
  //! This value should match state().size()
  uint32_t count() const {
    return count_;
  }

  //! The CPU architecture that is targeted by this ThreadCommand
  Header::CPU_TYPE architecture() const {
    return architecture_;
  }

  //! The actual thread state as a vector of bytes. Depending on the architecture(),
  //! these data can be casted into x86_thread_state_t, x86_thread_state64_t, ...
  span<const uint8_t> state() const {
    return  state_;
  }

  span<uint8_t> state() {
    return state_;
  }

  //! Return the initial Program Counter regardless of the underlying architecture.
  //! This value, when non null, can be used to determine the binary's entrypoint.
  //!
  //! Underneath, it works by looking for the PC register value in the state() data
  uint64_t pc() const;

  void state(std::vector<uint8_t> state) {
    state_ = std::move(state);
  }

  void flavor(uint32_t flavor) {
    flavor_ = flavor;
  }
  void count(uint32_t count) {
    count_ = count;
  }
  void architecture(Header::CPU_TYPE arch) {
    architecture_ = arch;
  }

  void accept(Visitor& visitor) const override;

  std::ostream& print(std::ostream& os) const override;

  static bool classof(const LoadCommand* cmd) {
    const LoadCommand::TYPE type = cmd->command();
    return type == LoadCommand::TYPE::THREAD ||
           type == LoadCommand::TYPE::UNIXTHREAD;
  }

  private:
  uint32_t flavor_ = 0;
  uint32_t count_ = 0;
  Header::CPU_TYPE architecture_  = Header::CPU_TYPE::ANY;
  std::vector<uint8_t> state_;

};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/MachO/TwoLevelHints.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_TWO_LEVEL_HINTS_H
#define LIEF_MACHO_TWO_LEVEL_HINTS_H
#include <vector>
#include <ostream>

#include "LIEF/visibility.h"
#include "LIEF/span.hpp"
#include "LIEF/iterators.hpp"

#include "LIEF/MachO/LoadCommand.hpp"

namespace LIEF {
namespace MachO {

class BinaryParser;
class Builder;
class LinkEdit;

namespace details {
struct twolevel_hints_command;
}

//! Class which represents the `LC_TWOLEVEL_HINTS` command
class LIEF_API TwoLevelHints : public LoadCommand {
  friend class BinaryParser;
  friend class LinkEdit;
  friend class Builder;

  public:
  using hints_list_t     = std::vector<uint32_t>;
  using it_hints_t       = ref_iterator<hints_list_t&>;
  using it_const_hints_t = const_ref_iterator<const hints_list_t&>;

  TwoLevelHints() = default;
  TwoLevelHints(const details::twolevel_hints_command& cmd);

  TwoLevelHints& operator=(const TwoLevelHints& copy) = default;
  TwoLevelHints(const TwoLevelHints& copy) = default;

  std::unique_ptr<LoadCommand> clone() const override {
    return std::unique_ptr<TwoLevelHints>(new TwoLevelHints(*this));
  }

  //! Original payload of the command
  span<const uint8_t> content() const { return content_; }
  span<uint8_t> content() { return content_; }

  //! Iterator over the hints (`uint32_t` integers)
  it_hints_t hints() { return hints_; }
  it_const_hints_t hints() const { return hints_; }

  //! Original offset of the command. It should point in the
  //! `__LINKEDIT` segment
  uint32_t offset() const { return offset_; }
  void offset(uint32_t offset)  { offset_ = offset; }

  uint32_t original_nb_hints() const {
    return original_nb_hints_;
  }

  ~TwoLevelHints() override = default;

  void accept(Visitor& visitor) const override;

  std::ostream& print(std::ostream& os) const override;

  static bool classof(const LoadCommand* cmd) {
    return cmd->command() == LoadCommand::TYPE::TWOLEVEL_HINTS;
  }

  private:
  uint32_t offset_ = 0;
  hints_list_t hints_;
  span<uint8_t> content_;
  uint32_t original_nb_hints_ = 0;
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/MachO/UUIDCommand.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_UUID_COMMAND_H
#define LIEF_MACHO_UUID_COMMAND_H
#include <ostream>
#include <array>

#include "LIEF/visibility.h"

#include "LIEF/MachO/LoadCommand.hpp"

namespace LIEF {
namespace MachO {

namespace details {
struct uuid_command;
}

using uuid_t = std::array<uint8_t, 16>;

//! Class that represents the UUID command
class LIEF_API UUIDCommand : public LoadCommand {
  public:
  UUIDCommand() = default;
  UUIDCommand(const details::uuid_command& cmd);

  UUIDCommand& operator=(const UUIDCommand& copy) = default;
  UUIDCommand(const UUIDCommand& copy) = default;

  std::unique_ptr<LoadCommand> clone() const override {
    return std::unique_ptr<UUIDCommand>(new UUIDCommand(*this));
  }

  ~UUIDCommand() override = default;

  //! The UUID as a 16-bytes array
  const uuid_t& uuid() const {
    return uuid_;
  }
  void uuid(const uuid_t& uuid) {
    uuid_ = uuid;
  }

  void accept(Visitor& visitor) const override;

  std::ostream& print(std::ostream& os) const override;

  static bool classof(const LoadCommand* cmd) {
    return cmd->command() == LoadCommand::TYPE::UUID;
  }

  private:
  uuid_t uuid_ = {0};
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/MachO/UnknownCommand.hpp`:

```hpp
/* Copyright 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_UNKNOWN_COMMAND_H
#define LIEF_MACHO_UNKNOWN_COMMAND_H
#include <ostream>

#include "LIEF/visibility.h"

#include "LIEF/MachO/LoadCommand.hpp"

namespace LIEF {
namespace MachO {

namespace details {
struct load_command;
}


//! Generic class when the command is not recognized by LIEF
class LIEF_API UnknownCommand : public LoadCommand {

  public:
  UnknownCommand() = delete;
  UnknownCommand(const details::load_command& command) :
    LoadCommand(command),
    original_command_(static_cast<uint64_t>(command_))
  {
    command_ = LoadCommand::TYPE::LIEF_UNKNOWN;
  }

  UnknownCommand& operator=(const UnknownCommand& copy) = default;
  UnknownCommand(const UnknownCommand& copy) = default;

  std::unique_ptr<LoadCommand> clone() const override {
    return std::unique_ptr<UnknownCommand>(new UnknownCommand(*this));
  }

  ~UnknownCommand() override = default;

  /// The original `LC_` int that is not supported by LIEF
  uint64_t original_command() const {
    return original_command_;
  }

  void accept(Visitor& visitor) const override;

  std::ostream& print(std::ostream& os) const override;

  static bool classof(const LoadCommand* cmd) {
    return cmd->command() == LoadCommand::TYPE::LIEF_UNKNOWN;
  }

  private:
  uint64_t original_command_ = 0;
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/MachO/VersionMin.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_VERSION_MIN_COMMAND_H
#define LIEF_MACHO_VERSION_MIN_COMMAND_H
#include <ostream>
#include <array>

#include "LIEF/visibility.h"

#include "LIEF/MachO/LoadCommand.hpp"

namespace LIEF {
namespace MachO {

namespace details {
struct version_min_command;
}

//! Class that wraps the LC_VERSION_MIN_MACOSX, LC_VERSION_MIN_IPHONEOS, ... commands.
class LIEF_API VersionMin : public LoadCommand {

  public:
  //! Version is an array of **3** integers
  using version_t = std::array<uint32_t, 3>;

  VersionMin() = default;
  VersionMin(const details::version_min_command& version_cmd);

  VersionMin& operator=(const VersionMin& copy) = default;
  VersionMin(const VersionMin& copy) = default;

  std::unique_ptr<LoadCommand> clone() const override {
    return std::unique_ptr<VersionMin>(new VersionMin(*this));
  }

  ~VersionMin() override = default;

  //! Return the version as an array
  const version_t& version() const {
    return version_;
  }
  void version(const version_t& version) {
    version_ = version;
  }

  //! Return the sdk version as an array
  const version_t& sdk() const {
    return sdk_;
  }
  void sdk(const version_t& sdk) {
    sdk_ = sdk;
  }

  void accept(Visitor& visitor) const override;

  std::ostream& print(std::ostream& os) const override;

  static bool classof(const LoadCommand* cmd) {
    const LoadCommand::TYPE type = cmd->command();
    return type == LoadCommand::TYPE::VERSION_MIN_MACOSX ||
           type == LoadCommand::TYPE::VERSION_MIN_IPHONEOS;
  }

  private:
  version_t version_;
  version_t sdk_;
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/MachO/enums.h`:

```h
#ifndef LIEF_MACHO_C_ENUMS_H_
#define LIEF_MACHO_C_ENUMS_H_
#include "LIEF/MachO/undef.h"

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _LIEF_EN
  #undef _LIEF_EN
#endif

#ifdef _LIEF_EN_2
  #undef _LIEF_EN_2
#endif

#ifdef _LIEF_EI
  #undef _LIEF_EI
#endif

#define _LIEF_EN(N) LIEF_MACHO_##N
#define _LIEF_EN_2(N, TYPE) LIEF_MACHO_##N
#define _LIEF_EI(X) LIEF_MACHO_##X

#include "LIEF/MachO/enums.inc"

#undef _LIEF_EN
#undef _LIEF_EN_2
#undef _LIEF_EI

#ifdef __cplusplus
}
#endif


#endif

```

`KDemu/include/LIEF/LIEF/MachO/enums.hpp`:

```hpp
/* Copyright 2021 - 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_ENUMS_H
#define LIEF_MACHO_ENUMS_H

#include "LIEF/MachO/undef.h"
#include <cstdint>

namespace LIEF {
namespace MachO {

enum class MACHO_TYPES: uint32_t {
  UNKNOWN     = 0,
  MH_MAGIC    = 0xFEEDFACEu, ///< 32-bit big-endian magic
  MH_CIGAM    = 0xCEFAEDFEu, ///< 32-bit little-endian magic
  MH_MAGIC_64 = 0xFEEDFACFu, ///< 64-bit big-endian magic
  MH_CIGAM_64 = 0xCFFAEDFEu, ///< 64-bit little-endian magic
  FAT_MAGIC   = 0xCAFEBABEu, ///< big-endian fat magic
  FAT_CIGAM   = 0xBEBAFECAu,  ///< little-endian fat magic

  NEURAL_MODEL = 0xbeeffaceu,
};

enum class X86_RELOCATION  {
  GENERIC_RELOC_VANILLA        = 0, /**< A generic relocation entry for both addresses contained in data and addresses contained in CPU instructions. */
  GENERIC_RELOC_PAIR           = 1, /**< The second relocation entry of a pair. */
  GENERIC_RELOC_SECTDIFF       = 2, /**< A relocation entry for an item that contains the difference of two section addresses. This is generally used for position-independent code generation. */
  GENERIC_RELOC_PB_LA_PTR      = 3, /**< contains the address from which to subtract; it must be followed by a X86_RELOCATION::GENERIC_RELOC_PAIR containing the address to subtract.*/
  GENERIC_RELOC_LOCAL_SECTDIFF = 4, /**< Similar to X86_RELOCATION::GENERIC_RELOC_SECTDIFF except that this entry refers specifically to the address in this item. If the address is that of a globally visible coalesced symbol, this relocation entry does not change if the symbol is overridden. This is used to associate stack unwinding information with the object code this relocation entry describes.*/
  GENERIC_RELOC_TLV            = 5, /**< A relocation entry for a prebound lazy pointer. This is always a scattered relocation entry. The MachO::Relocation::value field contains the non-prebound value of the lazy pointer.*/
};

enum class X86_64_RELOCATION  {
  X86_64_RELOC_UNSIGNED        = 0, /**< A CALL/JMP instruction with 32-bit displacement. */
  X86_64_RELOC_SIGNED          = 1, /**< A MOVQ load of a GOT entry. */
  X86_64_RELOC_BRANCH          = 2, /**< Other GOT references. */
  X86_64_RELOC_GOT_LOAD        = 3, /**< Signed 32-bit displacement. */
  X86_64_RELOC_GOT             = 4, /**< Absolute address. */
  X86_64_RELOC_SUBTRACTOR      = 5, /**< Must be followed by a X86_64_RELOCATION::X86_64_RELOC_UNSIGNED relocation. */
  X86_64_RELOC_SIGNED_1        = 6, /**< */
  X86_64_RELOC_SIGNED_2        = 7, /**< */
  X86_64_RELOC_SIGNED_4        = 8, /**< */
  X86_64_RELOC_TLV             = 9, /**< */
};


enum class PPC_RELOCATION  {
  PPC_RELOC_VANILLA            = 0,
  PPC_RELOC_PAIR               = 1,
  PPC_RELOC_BR14               = 2,
  PPC_RELOC_BR24               = 3,
  PPC_RELOC_HI16               = 4,
  PPC_RELOC_LO16               = 5,
  PPC_RELOC_HA16               = 6,
  PPC_RELOC_LO14               = 7,
  PPC_RELOC_SECTDIFF           = 8,
  PPC_RELOC_PB_LA_PTR          = 9,
  PPC_RELOC_HI16_SECTDIFF      = 10,
  PPC_RELOC_LO16_SECTDIFF      = 11,
  PPC_RELOC_HA16_SECTDIFF      = 12,
  PPC_RELOC_JBSR               = 13,
  PPC_RELOC_LO14_SECTDIFF      = 14,
  PPC_RELOC_LOCAL_SECTDIFF     = 15,
};


enum class ARM_RELOCATION  {
  ARM_RELOC_VANILLA            = 0,
  ARM_RELOC_PAIR               = 1,
  ARM_RELOC_SECTDIFF           = 2,
  ARM_RELOC_LOCAL_SECTDIFF     = 3,
  ARM_RELOC_PB_LA_PTR          = 4,
  ARM_RELOC_BR24               = 5,
  ARM_THUMB_RELOC_BR22         = 6,
  ARM_THUMB_32BIT_BRANCH       = 7, // obsolete
  ARM_RELOC_HALF               = 8,
  ARM_RELOC_HALF_SECTDIFF      = 9,
};


enum class ARM64_RELOCATION  {
  ARM64_RELOC_UNSIGNED            = 0,  /**< For pointers. */
  ARM64_RELOC_SUBTRACTOR          = 1,  /**< Must be followed by an ARM64_RELOCATION::ARM64_RELOC_UNSIGNED */
  ARM64_RELOC_BRANCH26            = 2,  /**< A B/BL instruction with 26-bit displacement. */
  ARM64_RELOC_PAGE21              = 3,  /**< PC-rel distance to page of target. */
  ARM64_RELOC_PAGEOFF12           = 4,  /**< Offset within page, scaled by MachO::Relocation::size. */
  ARM64_RELOC_GOT_LOAD_PAGE21     = 5,  /**< PC-rel distance to page of GOT slot */
  ARM64_RELOC_GOT_LOAD_PAGEOFF12  = 6,  /**< Offset within page of GOT slot, scaled by MachO::Relocation::size. */
  ARM64_RELOC_POINTER_TO_GOT      = 7,  /**< For pointers to GOT slots. */
  ARM64_RELOC_TLVP_LOAD_PAGE21    = 8,  /**< PC-rel distance to page of TLVP slot. */
  ARM64_RELOC_TLVP_LOAD_PAGEOFF12 = 9,  /**< Offset within page of TLVP slot, scaled by MachO::Relocation::size.*/
  ARM64_RELOC_ADDEND              = 10, /**< Must be followed by ARM64_RELOCATION::ARM64_RELOC_PAGE21 or ARM64_RELOCATION::ARM64_RELOC_PAGEOFF12. */
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/MachO/enums.inc`:

```inc


enum _LIEF_EN_2(MACHO_TYPES, uint32_t) {
  _LIEF_EI(MH_MAGIC)    = 0xFEEDFACEu, /**< 32-bit big-endian magic */
  _LIEF_EI(MH_CIGAM)    = 0xCEFAEDFEu, /**< 32-bit little-endian magic */
  _LIEF_EI(MH_MAGIC_64) = 0xFEEDFACFu, /**< 64-bit big-endian magic */
  _LIEF_EI(MH_CIGAM_64) = 0xCFFAEDFEu, /**< 64-bit little-endian magic */
  _LIEF_EI(FAT_MAGIC)   = 0xCAFEBABEu, /**< big-endian fat magic */
  _LIEF_EI(FAT_CIGAM)   = 0xBEBAFECAu  /**< little-endian fat magic */
};

enum _LIEF_EN(FILE_TYPES) {
  _LIEF_EI(MH_OBJECT)      = 0x1u,
  _LIEF_EI(MH_EXECUTE)     = 0x2u,
  _LIEF_EI(MH_FVMLIB)      = 0x3u,
  _LIEF_EI(MH_CORE)        = 0x4u,
  _LIEF_EI(MH_PRELOAD)     = 0x5u,
  _LIEF_EI(MH_DYLIB)       = 0x6u,
  _LIEF_EI(MH_DYLINKER)    = 0x7u,
  _LIEF_EI(MH_BUNDLE)      = 0x8u,
  _LIEF_EI(MH_DYLIB_STUB)  = 0x9u,
  _LIEF_EI(MH_DSYM)        = 0xAu,
  _LIEF_EI(MH_KEXT_BUNDLE) = 0xBu
};


enum _LIEF_EN(HEADER_FLAGS) {
  _LIEF_EI(MH_NOUNDEFS)                = 0x00000001u,
  _LIEF_EI(MH_INCRLINK)                = 0x00000002u,
  _LIEF_EI(MH_DYLDLINK)                = 0x00000004u,
  _LIEF_EI(MH_BINDATLOAD)              = 0x00000008u,
  _LIEF_EI(MH_PREBOUND)                = 0x00000010u,
  _LIEF_EI(MH_SPLIT_SEGS)              = 0x00000020u,
  _LIEF_EI(MH_LAZY_INIT)               = 0x00000040u,
  _LIEF_EI(MH_TWOLEVEL)                = 0x00000080u,
  _LIEF_EI(MH_FORCE_FLAT)              = 0x00000100u,
  _LIEF_EI(MH_NOMULTIDEFS)             = 0x00000200u,
  _LIEF_EI(MH_NOFIXPREBINDING)         = 0x00000400u,
  _LIEF_EI(MH_PREBINDABLE)             = 0x00000800u,
  _LIEF_EI(MH_ALLMODSBOUND)            = 0x00001000u,
  _LIEF_EI(MH_SUBSECTIONS_VIA_SYMBOLS) = 0x00002000u,
  _LIEF_EI(MH_CANONICAL)               = 0x00004000u,
  _LIEF_EI(MH_WEAK_DEFINES)            = 0x00008000u,
  _LIEF_EI(MH_BINDS_TO_WEAK)           = 0x00010000u,
  _LIEF_EI(MH_ALLOW_STACK_EXECUTION)   = 0x00020000u,
  _LIEF_EI(MH_ROOT_SAFE)               = 0x00040000u,
  _LIEF_EI(MH_SETUID_SAFE)             = 0x00080000u,
  _LIEF_EI(MH_NO_REEXPORTED_DYLIBS)    = 0x00100000u,
  _LIEF_EI(MH_PIE)                     = 0x00200000u,
  _LIEF_EI(MH_DEAD_STRIPPABLE_DYLIB)   = 0x00400000u,
  _LIEF_EI(MH_HAS_TLV_DESCRIPTORS)     = 0x00800000u,
  _LIEF_EI(MH_NO_HEAP_EXECUTION)       = 0x01000000u,
  _LIEF_EI(MH_APP_EXTENSION_SAFE)      = 0x02000000u
};


enum _LIEF_EN(LOAD_COMMAND_TYPES) {
  /* Constants for the "cmd" field in llvm::MachO::load_command */
  _LIEF_EI(LC_SEGMENT)                  = 0x00000001u,
  _LIEF_EI(LC_SYMTAB)                   = 0x00000002u,
  _LIEF_EI(LC_SYMSEG)                   = 0x00000003u,
  _LIEF_EI(LC_THREAD)                   = 0x00000004u,
  _LIEF_EI(LC_UNIXTHREAD)               = 0x00000005u,
  _LIEF_EI(LC_LOADFVMLIB)               = 0x00000006u,
  _LIEF_EI(LC_IDFVMLIB)                 = 0x00000007u,
  _LIEF_EI(LC_IDENT)                    = 0x00000008u,
  _LIEF_EI(LC_FVMFILE)                  = 0x00000009u,
  _LIEF_EI(LC_PREPAGE)                  = 0x0000000Au,
  _LIEF_EI(LC_DYSYMTAB)                 = 0x0000000Bu,
  _LIEF_EI(LC_LOAD_DYLIB)               = 0x0000000Cu,
  _LIEF_EI(LC_ID_DYLIB)                 = 0x0000000Du,
  _LIEF_EI(LC_LOAD_DYLINKER)            = 0x0000000Eu,
  _LIEF_EI(LC_ID_DYLINKER)              = 0x0000000Fu,
  _LIEF_EI(LC_PREBOUND_DYLIB)           = 0x00000010u,
  _LIEF_EI(LC_ROUTINES)                 = 0x00000011u,
  _LIEF_EI(LC_SUB_FRAMEWORK)            = 0x00000012u,
  _LIEF_EI(LC_SUB_UMBRELLA)             = 0x00000013u,
  _LIEF_EI(LC_SUB_CLIENT)               = 0x00000014u,
  _LIEF_EI(LC_SUB_LIBRARY)              = 0x00000015u,
  _LIEF_EI(LC_TWOLEVEL_HINTS)           = 0x00000016u,
  _LIEF_EI(LC_PREBIND_CKSUM)            = 0x00000017u,
  _LIEF_EI(LC_LOAD_WEAK_DYLIB)          = 0x80000018u,
  _LIEF_EI(LC_SEGMENT_64)               = 0x00000019u,
  _LIEF_EI(LC_ROUTINES_64)              = 0x0000001Au,
  _LIEF_EI(LC_UUID)                     = 0x0000001Bu,
  _LIEF_EI(LC_RPATH)                    = 0x8000001Cu,
  _LIEF_EI(LC_CODE_SIGNATURE)           = 0x0000001Du,
  _LIEF_EI(LC_SEGMENT_SPLIT_INFO)       = 0x0000001Eu,
  _LIEF_EI(LC_REEXPORT_DYLIB)           = 0x8000001Fu,
  _LIEF_EI(LC_LAZY_LOAD_DYLIB)          = 0x00000020u,
  _LIEF_EI(LC_ENCRYPTION_INFO)          = 0x00000021u,
  _LIEF_EI(LC_DYLD_INFO)                = 0x00000022u,
  _LIEF_EI(LC_DYLD_INFO_ONLY)           = 0x80000022u,
  _LIEF_EI(LC_LOAD_UPWARD_DYLIB)        = 0x80000023u,
  _LIEF_EI(LC_VERSION_MIN_MACOSX)       = 0x00000024u,
  _LIEF_EI(LC_VERSION_MIN_IPHONEOS)     = 0x00000025u,
  _LIEF_EI(LC_FUNCTION_STARTS)          = 0x00000026u,
  _LIEF_EI(LC_DYLD_ENVIRONMENT)         = 0x00000027u,
  _LIEF_EI(LC_MAIN)                     = 0x80000028u,
  _LIEF_EI(LC_DATA_IN_CODE)             = 0x00000029u,
  _LIEF_EI(LC_SOURCE_VERSION)           = 0x0000002Au,
  _LIEF_EI(LC_DYLIB_CODE_SIGN_DRS)      = 0x0000002Bu,
  _LIEF_EI(LC_ENCRYPTION_INFO_64)       = 0x0000002Cu,
  _LIEF_EI(LC_LINKER_OPTION)            = 0x0000002Du,
  _LIEF_EI(LC_LINKER_OPTIMIZATION_HINT) = 0x0000002Eu,
  _LIEF_EI(LC_VERSION_MIN_TVOS)         = 0x0000002Fu,
  _LIEF_EI(LC_VERSION_MIN_WATCHOS)      = 0x00000030u,
  _LIEF_EI(LC_NOTE)                     = 0x00000031u,
  _LIEF_EI(LC_BUILD_VERSION)            = 0x00000032u,
  _LIEF_EI(LC_DYLD_EXPORTS_TRIE)        = 0x80000033u,
  _LIEF_EI(LC_DYLD_CHAINED_FIXUPS)      = 0x80000034u,
  _LIEF_EI(LC_FILESET_ENTRY)            = 0x80000035u,
};


enum {
    /* Flags for the "cmd" field in llvm::MachO::load_command */
    _LIEF_EI(LC_REQ_DYLD)    = 0x80000000u
  };


enum _LIEF_EN(MACHO_SEGMENTS_FLAGS) {
  /* Constant bits for the "flags" field in llvm::MachO::segment_command */
  _LIEF_EI(SG_HIGHVM)              = 0x1u, /**< The file contents for this segment are for the high part of the virtual memory space; the low part is zero filled (for stacks in core files). */
  _LIEF_EI(SG_FVMLIB)              = 0x2u, /**< this segment is the VM that is allocated by a fixed VM library, for overlap checking in the link editor. */
  _LIEF_EI(SG_NORELOC)             = 0x4u, /**< This segment has nothing that was relocated in it and nothing relocated to it. It may be safely replaced without relocation. */
  _LIEF_EI(SG_PROTECTED_VERSION_1) = 0x8u,
};

enum _LIEF_EN(SECTION_FLAGS_HELPER)  {
  /* Constant masks for the "flags" field in llvm::MachO::section and */
  /* llvm::MachO::section_64 */
  _LIEF_EI(SECTION_TYPE_MASK)      = 0x000000ffu, /* SECTION_TYPE */
  _LIEF_EI(SECTION_FLAGS_MASK)     = 0xffffff00u, /* SECTION_ATTRIBUTES */
  _LIEF_EI(SECTION_FLAGS_USR_MASK) = 0xff000000u, /* SECTION_ATTRIBUTES_USR */
  _LIEF_EI(SECTION_FLAGS_SYS_MASK) = 0x00ffff00u  /* SECTION_ATTRIBUTES_SYS */
};

/**
 * @brief These are the section type and attributes fields. A MachO section can
 * have only one Type, but can have any of the attributes specified.
 */
enum _LIEF_EN(MACHO_SECTION_TYPES) {
  /* Constant masks for the "flags[7:0]" field in llvm::MachO::section and */
  /* llvm::MachO::section_64 (mask "flags" with SECTION_TYPE) */
  _LIEF_EI(S_REGULAR)                             = 0x00u, /**< Regular section. */
  _LIEF_EI(S_ZEROFILL)                            = 0x01u, /**< Zero fill on demand section. */
  _LIEF_EI(S_CSTRING_LITERALS)                    = 0x02u, /**< Section with literal C strings. */
  _LIEF_EI(S_4BYTE_LITERALS)                      = 0x03u, /**< Section with 4 byte literals. */
  _LIEF_EI(S_8BYTE_LITERALS)                      = 0x04u, /**< Section with 8 byte literals. */
  _LIEF_EI(S_LITERAL_POINTERS)                    = 0x05u, /**< Section with pointers to literals. */
  _LIEF_EI(S_NON_LAZY_SYMBOL_POINTERS)            = 0x06u, /**< Section with non-lazy symbol pointers. */
  _LIEF_EI(S_LAZY_SYMBOL_POINTERS)                = 0x07u, /**< Section with lazy symbol pointers. */
  _LIEF_EI(S_SYMBOL_STUBS)                        = 0x08u, /**< Section with symbol stubs, byte size of stub in the Reserved2 field. */
  _LIEF_EI(S_MOD_INIT_FUNC_POINTERS)              = 0x09u, /**< Section with only function pointers for initialization. */
  _LIEF_EI(S_MOD_TERM_FUNC_POINTERS)              = 0x0au, /**< Section with only function pointers for termination. */
  _LIEF_EI(S_COALESCED)                           = 0x0bu, /**< Section contains symbols that are to be coalesced. */
  _LIEF_EI(S_GB_ZEROFILL)                         = 0x0cu, /**< Zero fill on demand section (that can be larger than 4 gigabytes). */
  _LIEF_EI(S_INTERPOSING)                         = 0x0du, /**< Section with only pairs of function pointers for interposing. */
  _LIEF_EI(S_16BYTE_LITERALS)                     = 0x0eu, /**< Section with only 16 byte literals. */
  _LIEF_EI(S_DTRACE_DOF)                          = 0x0fu, /**< Section contains DTrace Object Format. */
  _LIEF_EI(S_LAZY_DYLIB_SYMBOL_POINTERS)          = 0x10u, /**< Section with lazy symbol pointers to lazy loaded dylibs. */
  _LIEF_EI(S_THREAD_LOCAL_REGULAR)                = 0x11u, /**< Thread local data section. */
  _LIEF_EI(S_THREAD_LOCAL_ZEROFILL)               = 0x12u, /**< Thread local zerofill section. */
  _LIEF_EI(S_THREAD_LOCAL_VARIABLES)              = 0x13u, /**< Section with thread local variable structure data. */
  _LIEF_EI(S_THREAD_LOCAL_VARIABLE_POINTERS)      = 0x14u, /**< Section with pointers to thread local structures. */
  _LIEF_EI(S_THREAD_LOCAL_INIT_FUNCTION_POINTERS) = 0x15u, /**< Section with thread local variable initialization pointers to functions. */

  _LIEF_EI(LAST_KNOWN_SECTION_TYPE) = 0x15u, /* S_THREAD_LOCAL_INIT_FUNCTION_POINTERS */
};

enum _LIEF_EN(MACHO_SECTION_FLAGS) {

  /* Constant masks for the "flags[31:24]" field in llvm::MachO::section and */
  /* llvm::MachO::section_64 (mask "flags" with SECTION_ATTRIBUTES_USR) */
  _LIEF_EI(S_ATTR_PURE_INSTRUCTIONS)   = 0x80000000u, /**< Section contains only true machine instructions */
  _LIEF_EI(S_ATTR_NO_TOC)              = 0x40000000u, /**< Section contains coalesced symbols that are not to be in a ranlib table of contents. */
  _LIEF_EI(S_ATTR_STRIP_STATIC_SYMS)   = 0x20000000u, /**< Ok to strip static symbols in this section in files with the MY_DYLDLINK flag. */
  _LIEF_EI(S_ATTR_NO_DEAD_STRIP)       = 0x10000000u, /**< No dead stripping. */
  _LIEF_EI(S_ATTR_LIVE_SUPPORT)        = 0x08000000u, /**< Blocks are live if they reference live blocks. */
  _LIEF_EI(S_ATTR_SELF_MODIFYING_CODE) = 0x04000000u, /**< Used with i386 code stubs written on by dyld */
  _LIEF_EI(S_ATTR_DEBUG)               = 0x02000000u, /**< A debug section. */

  /* Constant masks for the "flags[23:8]" field in llvm::MachO::section and */
  /* llvm::MachO::section_64 (mask "flags" with SECTION_ATTRIBUTES_SYS) */
  _LIEF_EI(S_ATTR_SOME_INSTRUCTIONS)   = 0x00000400u, /**< Section contains some machine instructions. */
  _LIEF_EI(S_ATTR_EXT_RELOC)           = 0x00000200u, /**< Section has external relocation entries. */
  _LIEF_EI(S_ATTR_LOC_RELOC)           = 0x00000100u, /**< Section has local relocation entries. */

  /* Constant masks for the value of an indirect symbol in an indirect */
  /* symbol table */
  _LIEF_EI(INDIRECT_SYMBOL_LOCAL) = 0x80000000u,
  _LIEF_EI(INDIRECT_SYMBOL_ABS)   = 0x40000000u
};


enum _LIEF_EN(DataRegionType) {
  /* Constants for the "kind" field in a data_in_code_entry structure */
  _LIEF_EI(DICE_KIND_DATA)             = 1u,
  _LIEF_EI(DICE_KIND_JUMP_TABLE8)      = 2u,
  _LIEF_EI(DICE_KIND_JUMP_TABLE16)     = 3u,
  _LIEF_EI(DICE_KIND_JUMP_TABLE32)     = 4u,
  _LIEF_EI(DICE_KIND_ABS_JUMP_TABLE32) = 5u
};

enum _LIEF_EN(REBASE_TYPES) {
  _LIEF_EI(REBASE_TYPE_POINTER)         = 1u,
  _LIEF_EI(REBASE_TYPE_TEXT_ABSOLUTE32) = 2u,
  _LIEF_EI(REBASE_TYPE_TEXT_PCREL32)    = 3u,
  _LIEF_EI(REBASE_TYPE_THREADED)        = 102u,
};

enum {
  _LIEF_EI(REBASE_OPCODE_MASK)    = 0xF0u,
  _LIEF_EI(REBASE_IMMEDIATE_MASK) = 0x0Fu
};


/** @brief Opcodes used by Dyld info to rebase a Mach-O image */
enum _LIEF_EN_2(REBASE_OPCODES, uint8_t) {
  _LIEF_EI(REBASE_OPCODE_DONE)                               = 0x00u, /**< It's finished */
  _LIEF_EI(REBASE_OPCODE_SET_TYPE_IMM)                       = 0x10u, /**< Set type to immediate (lower 4-bits). Used for ordinal numbers from 0-15 */
  _LIEF_EI(REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB)        = 0x20u, /**< Set segment's index to immediate (lower 4-bits) and segment's offset to following ULEB128 encoding. */
  _LIEF_EI(REBASE_OPCODE_ADD_ADDR_ULEB)                      = 0x30u, /**< Add segment's offset with the following ULEB128 encoding. */
  _LIEF_EI(REBASE_OPCODE_ADD_ADDR_IMM_SCALED)                = 0x40u, /**< Add segment's offset with immediate scaling */
  _LIEF_EI(REBASE_OPCODE_DO_REBASE_IMM_TIMES)                = 0x50u, /**< Rebase in the range of ``[segment's offset; segment's offset + immediate * sizeof(ptr)]`` */
  _LIEF_EI(REBASE_OPCODE_DO_REBASE_ULEB_TIMES)               = 0x60u, /**< Same as REBASE_OPCODE_DO_REBASE_IMM_TIMES but *immediate* is replaced with ULEB128 value */
  _LIEF_EI(REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB)            = 0x70u, /**< Rebase and increment segment's offset with following ULEB128 encoding + pointer's size */
  _LIEF_EI(REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB) = 0x80u  /**< Rebase and skip several bytes */
};


/**
 * Within the dyld_info_command there are
 * differents area of binding. These enums tag these areas.
 */
enum _LIEF_EN(BINDING_CLASS) {
  _LIEF_EI(BIND_CLASS_WEAK)     = 1u,
  _LIEF_EI(BIND_CLASS_LAZY)     = 2u,
  _LIEF_EI(BIND_CLASS_STANDARD) = 3u,
  _LIEF_EI(BIND_CLASS_THREADED) = 100u
};


enum _LIEF_EN(BIND_TYPES) {
  _LIEF_EI(BIND_TYPE_POINTER)         = 1u,
  _LIEF_EI(BIND_TYPE_TEXT_ABSOLUTE32) = 2u,
  _LIEF_EI(BIND_TYPE_TEXT_PCREL32)    = 3u
};

enum _LIEF_EN_2(BIND_SPECIAL_DYLIB, int) {
  _LIEF_EI(BIND_SPECIAL_DYLIB_SELF)            =  0,
  _LIEF_EI(BIND_SPECIAL_DYLIB_MAIN_EXECUTABLE) = -1,
  _LIEF_EI(BIND_SPECIAL_DYLIB_FLAT_LOOKUP)     = -2
};

enum {
  _LIEF_EI(BIND_SYMBOL_FLAGS_WEAK_IMPORT)         = 0x1u,
  _LIEF_EI(BIND_SYMBOL_FLAGS_NON_WEAK_DEFINITION) = 0x8u,

  _LIEF_EI(BIND_OPCODE_MASK)                      = 0xF0u,
  _LIEF_EI(BIND_IMMEDIATE_MASK)                   = 0x0Fu
};

/** Opcodes used by Dyld info to bind symbols */
enum _LIEF_EN_2(BIND_OPCODES, uint8_t) {
  _LIEF_EI(BIND_OPCODE_DONE)                             = 0x00u, /**< It's finished */
  _LIEF_EI(BIND_OPCODE_SET_DYLIB_ORDINAL_IMM)            = 0x10u, /**< Set ordinal to immediate (lower 4-bits). Used for ordinal numbers from 0-15 */
  _LIEF_EI(BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB)           = 0x20u, /**< Set ordinal to following ULEB128 encoding. Used for ordinal numbers from 16+ */
  _LIEF_EI(BIND_OPCODE_SET_DYLIB_SPECIAL_IMM)            = 0x30u, /**< Set ordinal, with 0 or negative number as immediate. the value is sign extended. */
  _LIEF_EI(BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM)    = 0x40u, /**< Set the following symbol (NULL-terminated char*). */
  _LIEF_EI(BIND_OPCODE_SET_TYPE_IMM)                     = 0x50u, /**< Set the type to immediate (lower 4-bits). See BIND_TYPES */
  _LIEF_EI(BIND_OPCODE_SET_ADDEND_SLEB)                  = 0x60u, /**< Set the addend field to the following SLEB128 encoding. */
  _LIEF_EI(BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB)      = 0x70u, /**< Set Segment to immediate value, and address to the following SLEB128 encoding */
  _LIEF_EI(BIND_OPCODE_ADD_ADDR_ULEB)                    = 0x80u, /**< Set the address field to the following SLEB128 encoding. */
  _LIEF_EI(BIND_OPCODE_DO_BIND)                          = 0x90u, /**< Perform binding of current table row */
  _LIEF_EI(BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB)            = 0xA0u, /**< Perform binding, also add following ULEB128 as address */
  _LIEF_EI(BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED)      = 0xB0u, /**< Perform binding, also add immediate (lower 4-bits) using scaling */
  _LIEF_EI(BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB) = 0xC0u, /**< Perform binding for several symbols (as following ULEB128), and skip several bytes. */
  _LIEF_EI(BIND_OPCODE_THREADED)                         = 0xD0u,

  _LIEF_EI(BIND_OPCODE_THREADED_APPLY)                            = 0xD0u | 0x01u,
  _LIEF_EI(BIND_OPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB) = 0xD0u | 0x00u,
};

enum _LIEF_EN_2(BIND_SUBOPCODE_THREADED, uint8_t) {
  _LIEF_EI(BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB) = 0x00u,
  _LIEF_EI(BIND_SUBOPCODE_THREADED_APPLY)                            = 0x01u,
};

enum _LIEF_EN(EXPORT_SYMBOL_FLAGS) {
  _LIEF_EI(EXPORT_SYMBOL_FLAGS_KIND_MASK)           = 0x03u, /**< Mask to access to EXPORT_SYMBOL_KINDS */
  _LIEF_EI(EXPORT_SYMBOL_FLAGS_WEAK_DEFINITION)     = 0x04u,
  _LIEF_EI(EXPORT_SYMBOL_FLAGS_REEXPORT)            = 0x08u,
  _LIEF_EI(EXPORT_SYMBOL_FLAGS_STUB_AND_RESOLVER)   = 0x10u
};

enum _LIEF_EN(EXPORT_SYMBOL_KINDS) {
  _LIEF_EI(EXPORT_SYMBOL_FLAGS_KIND_REGULAR)        = 0x00u,
  _LIEF_EI(EXPORT_SYMBOL_FLAGS_KIND_THREAD_LOCAL)   = 0x01u,
  _LIEF_EI(EXPORT_SYMBOL_FLAGS_KIND_ABSOLUTE)       = 0x02u
};

enum _LIEF_EN(MACHO_SYMBOL_TYPES) {
  _LIEF_EI(N_STAB) = 0xe0, /**< The symbol is symbolic debugging table */
  _LIEF_EI(N_PEXT) = 0x10, /**< Limited global scope symbol. */
  _LIEF_EI(N_TYPE) = 0x0e, /**< Define the type of the symbol. @see N_LIST_TYPES */
  _LIEF_EI(N_EXT)  = 0x01  /**< External symbol, a symbol that is either defined outside this file or that is defined in this file but can be referenced by other files. */
};

/** Constants for the "n_type & SYMBOL_TYPES::N_TYPE" in nlist. @see nlist */
enum _LIEF_EN(N_LIST_TYPES) {
  _LIEF_EI(N_UNDF) = 0x0u, /**< The symbol is undefined. It is referenced in a different module. */
  _LIEF_EI(N_ABS)  = 0x2u, /**< The symbol is absolute. The linker doesn't update his value. */
  _LIEF_EI(N_SECT) = 0xeu, /**< The symbol is defined in the section number given in nlist_base.n_sect . */
  _LIEF_EI(N_PBUD) = 0xcu, /**< The symbol is undefined and the image is using a prebound value for the symbol. Set the n_sect field to NO_SECT . */
  _LIEF_EI(N_INDR) = 0xau  /**< The symbol is defined to be the same as another symbol. The n_value field is an index into the string table specifying the name of the other symbol. When that symbol is linked, both this and the other symbol point to the same defined type and value. */
};

enum _LIEF_EN(SectionOrdinal) {
  /* Constants for the "n_sect" field in llvm::MachO::nlist and */
  /* llvm::MachO::nlist_64 */
  _LIEF_EI(NO_SECT)  = 0u,
  _LIEF_EI(MAX_SECT) = 0xffu
};

enum _LIEF_EN(SYMBOL_DESCRIPTIONS) {

  /* The low 3 bits are the for the REFERENCE_TYPE. */
  _LIEF_EI(REFERENCE_TYPE)                            = 0x7,
  _LIEF_EI(REFERENCE_FLAG_UNDEFINED_NON_LAZY)         = 0, /**< Reference to an external non-lazy (data) symbol. */
  _LIEF_EI(REFERENCE_FLAG_UNDEFINED_LAZY)             = 1, /**< Reference to an external lazy symbol - that is, to a function call. */
  _LIEF_EI(REFERENCE_FLAG_DEFINED)                    = 2, /**< Defined in this module. */
  _LIEF_EI(REFERENCE_FLAG_PRIVATE_DEFINED)            = 3, /**< Defined in this module and is visible only to modules within this shared library. */
  _LIEF_EI(REFERENCE_FLAG_PRIVATE_UNDEFINED_NON_LAZY) = 4, /**< Defined in another module in this file, is a non-lazy (data) symbol, and is visible only to modules within this shared library. */
  _LIEF_EI(REFERENCE_FLAG_PRIVATE_UNDEFINED_LAZY)     = 5, /**< Defined in another module in this file, is a lazy (function) symbol, and is visible only to modules within this shared library. */

  /* Flag bits (some overlap with the library ordinal bits). */
  _LIEF_EI(N_ARM_THUMB_DEF)        = 0x0008u,
  _LIEF_EI(REFERENCED_DYNAMICALLY) = 0x0010u,
  _LIEF_EI(N_NO_DEAD_STRIP)        = 0x0020u,
  _LIEF_EI(N_WEAK_REF)             = 0x0040u,
  _LIEF_EI(N_WEAK_DEF)             = 0x0080u,
  _LIEF_EI(N_SYMBOL_RESOLVER)      = 0x0100u,
  _LIEF_EI(N_ALT_ENTRY)            = 0x0200u,

  /* For undefined symbols coming from libraries, see GET_LIBRARY_ORDINAL() */
  /* as these are in the top 8 bits. */
  _LIEF_EI(SELF_LIBRARY_ORDINAL)   = 0x0,
  _LIEF_EI(MAX_LIBRARY_ORDINAL)    = 0xfd,
  _LIEF_EI(DYNAMIC_LOOKUP_ORDINAL) = 0xfe,
  _LIEF_EI(EXECUTABLE_ORDINAL)     = 0xff
};

enum _LIEF_EN(StabType) {
  /* Constant values for the "n_type" field in llvm::MachO::nlist and */
  /* llvm::MachO::nlist_64 when "(n_type & N_STAB) != 0" */
  _LIEF_EI(N_GSYM)    = 0x20u,
  _LIEF_EI(N_FNAME)   = 0x22u,
  _LIEF_EI(N_FUN)     = 0x24u,
  _LIEF_EI(N_STSYM)   = 0x26u,
  _LIEF_EI(N_LCSYM)   = 0x28u,
  _LIEF_EI(N_BNSYM)   = 0x2Eu,
  _LIEF_EI(N_PC)      = 0x30u,
  _LIEF_EI(N_AST)     = 0x32u,
  _LIEF_EI(N_OPT)     = 0x3Cu,
  _LIEF_EI(N_RSYM)    = 0x40u,
  _LIEF_EI(N_SLINE)   = 0x44u,
  _LIEF_EI(N_ENSYM)   = 0x4Eu,
  _LIEF_EI(N_SSYM)    = 0x60u,
  _LIEF_EI(N_SO)      = 0x64u,
  _LIEF_EI(N_OSO)     = 0x66u,
  _LIEF_EI(N_LSYM)    = 0x80u,
  _LIEF_EI(N_BINCL)   = 0x82u,
  _LIEF_EI(N_SOL)     = 0x84u,
  _LIEF_EI(N_PARAMS)  = 0x86u,
  _LIEF_EI(N_VERSION) = 0x88u,
  _LIEF_EI(N_OLEVEL)  = 0x8Au,
  _LIEF_EI(N_PSYM)    = 0xA0u,
  _LIEF_EI(N_EINCL)   = 0xA2u,
  _LIEF_EI(N_ENTRY)   = 0xA4u,
  _LIEF_EI(N_LBRAC)   = 0xC0u,
  _LIEF_EI(N_EXCL)    = 0xC2u,
  _LIEF_EI(N_RBRAC)   = 0xE0u,
  _LIEF_EI(N_BCOMM)   = 0xE2u,
  _LIEF_EI(N_ECOMM)   = 0xE4u,
  _LIEF_EI(N_ECOML)   = 0xE8u,
  _LIEF_EI(N_LENG)    = 0xFEu
};


enum {
  /* Constant values for the r_symbolnum field in an */
  /* llvm::MachO::relocation_info structure when r_extern is 0. */
  _LIEF_EI(R_ABS) = 0,

  /* Constant bits for the r_address field in an */
  /* llvm::MachO::relocation_info structure. */
  _LIEF_EI(R_SCATTERED) = 0x80000000
};

enum _LIEF_EN(RELOCATION_ORIGINS) {
  _LIEF_EI(ORIGIN_UNKNOWN)     = 0,
  _LIEF_EI(ORIGIN_DYLDINFO)    = 1,
  _LIEF_EI(ORIGIN_RELOC_TABLE) = 2,
};


enum _LIEF_EN(SYMBOL_ORIGINS) {
  _LIEF_EI(SYM_ORIGIN_UNKNOWN)     = 0,
  _LIEF_EI(SYM_ORIGIN_DYLD_EXPORT) = 1,
  _LIEF_EI(SYM_ORIGIN_DYLD_BIND)   = 2, /**< The symbol comes from the binding opcodes */
  _LIEF_EI(SYM_ORIGIN_LC_SYMTAB)   = 3,
};

enum _LIEF_EN(X86_RELOCATION) {
  _LIEF_EI(GENERIC_RELOC_VANILLA)        = 0, /**< A generic relocation entry for both addresses contained in data and addresses contained in CPU instructions. */
  _LIEF_EI(GENERIC_RELOC_PAIR)           = 1, /**< The second relocation entry of a pair. */
  _LIEF_EI(GENERIC_RELOC_SECTDIFF)       = 2, /**< A relocation entry for an item that contains the difference of two section addresses. This is generally used for position-independent code generation. */
  _LIEF_EI(GENERIC_RELOC_PB_LA_PTR)      = 3, /**< contains the address from which to subtract; it must be followed by a X86_RELOCATION::GENERIC_RELOC_PAIR containing the address to subtract.*/
  _LIEF_EI(GENERIC_RELOC_LOCAL_SECTDIFF) = 4, /**< Similar to X86_RELOCATION::GENERIC_RELOC_SECTDIFF except that this entry refers specifically to the address in this item. If the address is that of a globally visible coalesced symbol, this relocation entry does not change if the symbol is overridden. This is used to associate stack unwinding information with the object code this relocation entry describes.*/
  _LIEF_EI(GENERIC_RELOC_TLV)            = 5, /**< A relocation entry for a prebound lazy pointer. This is always a scattered relocation entry. The MachO::Relocation::value field contains the non-prebound value of the lazy pointer.*/
};


enum _LIEF_EN(X86_64_RELOCATION) {
  _LIEF_EI(X86_64_RELOC_UNSIGNED)        = 0, /**< A CALL/JMP instruction with 32-bit displacement. */
  _LIEF_EI(X86_64_RELOC_SIGNED)          = 1, /**< A MOVQ load of a GOT entry. */
  _LIEF_EI(X86_64_RELOC_BRANCH)          = 2, /**< Other GOT references. */
  _LIEF_EI(X86_64_RELOC_GOT_LOAD)        = 3, /**< Signed 32-bit displacement. */
  _LIEF_EI(X86_64_RELOC_GOT)             = 4, /**< Absolute address. */
  _LIEF_EI(X86_64_RELOC_SUBTRACTOR)      = 5, /**< Must be followed by a X86_64_RELOCATION::X86_64_RELOC_UNSIGNED relocation. */
  _LIEF_EI(X86_64_RELOC_SIGNED_1)        = 6, /**< */
  _LIEF_EI(X86_64_RELOC_SIGNED_2)        = 7, /**< */
  _LIEF_EI(X86_64_RELOC_SIGNED_4)        = 8, /**< */
  _LIEF_EI(X86_64_RELOC_TLV)             = 9, /**< */
};


enum _LIEF_EN(PPC_RELOCATION) {
  _LIEF_EI(PPC_RELOC_VANILLA)            = 0,
  _LIEF_EI(PPC_RELOC_PAIR)               = 1,
  _LIEF_EI(PPC_RELOC_BR14)               = 2,
  _LIEF_EI(PPC_RELOC_BR24)               = 3,
  _LIEF_EI(PPC_RELOC_HI16)               = 4,
  _LIEF_EI(PPC_RELOC_LO16)               = 5,
  _LIEF_EI(PPC_RELOC_HA16)               = 6,
  _LIEF_EI(PPC_RELOC_LO14)               = 7,
  _LIEF_EI(PPC_RELOC_SECTDIFF)           = 8,
  _LIEF_EI(PPC_RELOC_PB_LA_PTR)          = 9,
  _LIEF_EI(PPC_RELOC_HI16_SECTDIFF)      = 10,
  _LIEF_EI(PPC_RELOC_LO16_SECTDIFF)      = 11,
  _LIEF_EI(PPC_RELOC_HA16_SECTDIFF)      = 12,
  _LIEF_EI(PPC_RELOC_JBSR)               = 13,
  _LIEF_EI(PPC_RELOC_LO14_SECTDIFF)      = 14,
  _LIEF_EI(PPC_RELOC_LOCAL_SECTDIFF)     = 15,
};


enum _LIEF_EN(ARM_RELOCATION) {
  _LIEF_EI(ARM_RELOC_VANILLA)            = 0,
  _LIEF_EI(ARM_RELOC_PAIR)               = 1,
  _LIEF_EI(ARM_RELOC_SECTDIFF)           = 2,
  _LIEF_EI(ARM_RELOC_LOCAL_SECTDIFF)     = 3,
  _LIEF_EI(ARM_RELOC_PB_LA_PTR)          = 4,
  _LIEF_EI(ARM_RELOC_BR24)               = 5,
  _LIEF_EI(ARM_THUMB_RELOC_BR22)         = 6,
  _LIEF_EI(ARM_THUMB_32BIT_BRANCH)       = 7, /* obsolete */
  _LIEF_EI(ARM_RELOC_HALF)               = 8,
  _LIEF_EI(ARM_RELOC_HALF_SECTDIFF)      = 9,
};


enum _LIEF_EN(ARM64_RELOCATION) {
  _LIEF_EI(ARM64_RELOC_UNSIGNED)            = 0,  /**< For pointers. */
  _LIEF_EI(ARM64_RELOC_SUBTRACTOR)          = 1,  /**< Must be followed by an ARM64_RELOCATION::ARM64_RELOC_UNSIGNED */
  _LIEF_EI(ARM64_RELOC_BRANCH26)            = 2,  /**< A B/BL instruction with 26-bit displacement. */
  _LIEF_EI(ARM64_RELOC_PAGE21)              = 3,  /**< PC-rel distance to page of target. */
  _LIEF_EI(ARM64_RELOC_PAGEOFF12)           = 4,  /**< Offset within page, scaled by MachO::Relocation::size. */
  _LIEF_EI(ARM64_RELOC_GOT_LOAD_PAGE21)     = 5,  /**< PC-rel distance to page of GOT slot */
  _LIEF_EI(ARM64_RELOC_GOT_LOAD_PAGEOFF12)  = 6,  /**< Offset within page of GOT slot, scaled by MachO::Relocation::size. */
  _LIEF_EI(ARM64_RELOC_POINTER_TO_GOT)      = 7,  /**< For pointers to GOT slots. */
  _LIEF_EI(ARM64_RELOC_TLVP_LOAD_PAGE21)    = 8,  /**< PC-rel distance to page of TLVP slot. */
  _LIEF_EI(ARM64_RELOC_TLVP_LOAD_PAGEOFF12) = 9,  /**< Offset within page of TLVP slot, scaled by MachO::Relocation::size.*/
  _LIEF_EI(ARM64_RELOC_ADDEND)              = 10, /**< Must be followed by ARM64_RELOCATION::ARM64_RELOC_PAGE21 or ARM64_RELOCATION::ARM64_RELOC_PAGEOFF12. */
};

/** Values for segment_command.initprot (From <mach/vm_prot.h>). */
enum _LIEF_EN(VM_PROTECTIONS) {
  _LIEF_EI(VM_PROT_READ)    = 0x1, /**< Reading data within the segment is allowed */
  _LIEF_EI(VM_PROT_WRITE)   = 0x2, /**< Writing data within the segment is allowed */
  _LIEF_EI(VM_PROT_EXECUTE) = 0x4, /**< Executing data within the segment is allowed */
};


/* Enums from <mach/machine.h> */
enum {
  /* Capability bits used in the definition of cpu_type. */
  _LIEF_EI(CPU_ARCH_MASK)  = 0xff000000,   /* Mask for architecture bits */
  _LIEF_EI(CPU_ARCH_ABI64) = 0x01000000    /* 64 bit ABI */
};

/* Constants for the cputype field. */
enum _LIEF_EN_2(CPU_TYPES, int) {
  _LIEF_EI(CPU_TYPE_ANY)       = -1,
  _LIEF_EI(CPU_TYPE_X86)       = 7,
  _LIEF_EI(CPU_TYPE_I386)      = 7,              /* CPU_TYPE_X86, */
  _LIEF_EI(CPU_TYPE_X86_64)    = 7 | 0x01000000, /* CPU_TYPE_X86 | CPU_ARCH_ABI64, */
/* _LIEF_EI(CPU_TYPE_MIPS)      = 8, */
  _LIEF_EI(CPU_TYPE_MC98000)   = 10, /* Old Motorola PowerPC */
  _LIEF_EI(CPU_TYPE_ARM)       = 12,
  _LIEF_EI(CPU_TYPE_ARM64)     = 12 | 0x01000000, /* CPU_TYPE_ARM | CPU_ARCH_ABI64, */
  _LIEF_EI(CPU_TYPE_SPARC)     = 14,
  _LIEF_EI(CPU_TYPE_POWERPC)   = 18,
  _LIEF_EI(CPU_TYPE_POWERPC64) = 18 | 0x01000000, /* CPU_TYPE_POWERPC | CPU_ARCH_ABI64 */
};

enum {
  /* Capability bits used in the definition of cpusubtype. */
  _LIEF_EI(CPU_SUBTYPE_MASK)  = 0xff000000,   /* Mask for architecture bits */
  _LIEF_EI(CPU_SUBTYPE_LIB64) = 0x80000000,   /* 64 bit libraries */

  /* Special CPU subtype constants. */
  _LIEF_EI(CPU_SUBTYPE_MULTIPLE) = ~0u
};

/* Constants for the cpusubtype field. */
enum _LIEF_EN(CPU_SUBTYPES_X86) {
  _LIEF_EI(CPU_SUBTYPE_I386_ALL)       = 3,
  _LIEF_EI(CPU_SUBTYPE_386)            = 3,
  _LIEF_EI(CPU_SUBTYPE_486)            = 4,
  _LIEF_EI(CPU_SUBTYPE_486SX)          = 0x84,
  _LIEF_EI(CPU_SUBTYPE_586)            = 5,
  _LIEF_EI(CPU_SUBTYPE_PENT)           = 5, /* CPU_SUBTYPE_586, */
  _LIEF_EI(CPU_SUBTYPE_PENTPRO)        = 0x16,
  _LIEF_EI(CPU_SUBTYPE_PENTII_M3)      = 0x36,
  _LIEF_EI(CPU_SUBTYPE_PENTII_M5)      = 0x56,
  _LIEF_EI(CPU_SUBTYPE_CELERON)        = 0x67,
  _LIEF_EI(CPU_SUBTYPE_CELERON_MOBILE) = 0x77,
  _LIEF_EI(CPU_SUBTYPE_PENTIUM_3)      = 0x08,
  _LIEF_EI(CPU_SUBTYPE_PENTIUM_3_M)    = 0x18,
  _LIEF_EI(CPU_SUBTYPE_PENTIUM_3_XEON) = 0x28,
  _LIEF_EI(CPU_SUBTYPE_PENTIUM_M)      = 0x09,
  _LIEF_EI(CPU_SUBTYPE_PENTIUM_4)      = 0x0a,
  _LIEF_EI(CPU_SUBTYPE_PENTIUM_4_M)    = 0x1a,
  _LIEF_EI(CPU_SUBTYPE_ITANIUM)        = 0x0b,
  _LIEF_EI(CPU_SUBTYPE_ITANIUM_2)      = 0x1b,
  _LIEF_EI(CPU_SUBTYPE_XEON)           = 0x0c,
  _LIEF_EI(CPU_SUBTYPE_XEON_MP)        = 0x1c,

  _LIEF_EI(CPU_SUBTYPE_X86_ALL)     = 3,
  _LIEF_EI(CPU_SUBTYPE_X86_64_ALL)  = 3,
  _LIEF_EI(CPU_SUBTYPE_X86_ARCH1)   = 4,
  _LIEF_EI(CPU_SUBTYPE_X86_64_H)    = 8
};


enum {
  _LIEF_EI(CPU_SUBTYPE_INTEL_FAMILY_MAX) = 15,
  _LIEF_EI(CPU_SUBTYPE_INTEL_MODEL_ALL)  = 0
};

enum _LIEF_EN(CPU_SUBTYPES_ARM) {
  _LIEF_EI(CPU_SUBTYPE_ARM_ALL)     = 0,
  _LIEF_EI(CPU_SUBTYPE_ARM_V4T)     = 5,
  _LIEF_EI(CPU_SUBTYPE_ARM_V6)      = 6,
  _LIEF_EI(CPU_SUBTYPE_ARM_V5)      = 7,
  _LIEF_EI(CPU_SUBTYPE_ARM_V5TEJ)   = 7,
  _LIEF_EI(CPU_SUBTYPE_ARM_XSCALE)  = 8,
  _LIEF_EI(CPU_SUBTYPE_ARM_V7)      = 9,
  /*  unused  _LIEF_EI(ARM_V7F)     = 10, */
  _LIEF_EI(CPU_SUBTYPE_ARM_V7S)     = 11,
  _LIEF_EI(CPU_SUBTYPE_ARM_V7K)     = 12,
  _LIEF_EI(CPU_SUBTYPE_ARM_V6M)     = 14,
  _LIEF_EI(CPU_SUBTYPE_ARM_V7M)     = 15,
  _LIEF_EI(CPU_SUBTYPE_ARM_V7EM)    = 16
};

enum _LIEF_EN(CPU_SUBTYPES_ARM64) {
  _LIEF_EI(CPU_SUBTYPE_ARM64_ALL)   = 0
};

enum _LIEF_EN(CPU_SUBTYPES_SPARC) {
  _LIEF_EI(CPU_SUBTYPE_SPARC_ALL)   = 0
};

enum _LIEF_EN(CPU_SUBTYPES_POWERPC) {
  _LIEF_EI(CPU_SUBTYPE_POWERPC_ALL)   = 0,
  _LIEF_EI(CPU_SUBTYPE_POWERPC_601)   = 1,
  _LIEF_EI(CPU_SUBTYPE_POWERPC_602)   = 2,
  _LIEF_EI(CPU_SUBTYPE_POWERPC_603)   = 3,
  _LIEF_EI(CPU_SUBTYPE_POWERPC_603e)  = 4,
  _LIEF_EI(CPU_SUBTYPE_POWERPC_603ev) = 5,
  _LIEF_EI(CPU_SUBTYPE_POWERPC_604)   = 6,
  _LIEF_EI(CPU_SUBTYPE_POWERPC_604e)  = 7,
  _LIEF_EI(CPU_SUBTYPE_POWERPC_620)   = 8,
  _LIEF_EI(CPU_SUBTYPE_POWERPC_750)   = 9,
  _LIEF_EI(CPU_SUBTYPE_POWERPC_7400)  = 10,
  _LIEF_EI(CPU_SUBTYPE_POWERPC_7450)  = 11,
  _LIEF_EI(CPU_SUBTYPE_POWERPC_970)   = 100,

  _LIEF_EI(CPU_SUBTYPE_MC980000_ALL)  = 0, /* CPU_SUBTYPE_POWERPC_ALL, */
  _LIEF_EI(CPU_SUBTYPE_MC98601)       = 1, /* CPU_SUBTYPE_POWERPC_601 */
};



```

`KDemu/include/LIEF/LIEF/MachO/hash.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_HASH_H
#define LIEF_MACHO_HASH_H

#include "LIEF/visibility.h"
#include "LIEF/hash.hpp"

namespace LIEF {
namespace MachO {

class Binary;
class BindingInfo;
class BuildToolVersion;
class BuildVersion;
class ChainedBindingInfo;
class CodeSignature;
class CodeSignatureDir;
class DataCodeEntry;
class DataInCode;
class DyldBindingInfo;
class DyldEnvironment;
class DyldExportsTrie;
class DylibCommand;
class DylinkerCommand;
class DynamicSymbolCommand;
class EncryptionInfo;
class ExportInfo;
class FilesetCommand;
class FunctionStarts;
class Header;
class LinkerOptHint;
class LoadCommand;
class MainCommand;
class RPathCommand;
class Relocation;
class RelocationDyld;
class RelocationFixup;
class RelocationObject;
class Section;
class SegmentCommand;
class SegmentSplitInfo;
class SourceVersion;
class SubFramework;
class Symbol;
class SymbolCommand;
class ThreadCommand;
class TwoLevelHints;
class UUIDCommand;
class VersionMin;
class UnknownCommand;

//! Class which implements a visitor to compute
//! a **deterministic** hash for LIEF MachO objects
class LIEF_API Hash : public LIEF::Hash {
  public:
  static LIEF::Hash::value_type hash(const Object& obj);

  public:
  using LIEF::Hash::Hash;
  using LIEF::Hash::visit;

  public:
  void visit(const Binary& binary)                        override;
  void visit(const BindingInfo& binding)                  override;
  void visit(const BuildToolVersion& e)                   override;
  void visit(const BuildVersion& e)                       override;
  void visit(const ChainedBindingInfo& binding)           override;
  void visit(const CodeSignature& cs)                     override;
  void visit(const CodeSignatureDir& e)                   override;
  void visit(const DataCodeEntry& dce)                    override;
  void visit(const DataInCode& dic)                       override;
  void visit(const DyldBindingInfo& binding)              override;
  void visit(const DyldEnvironment& sf)                   override;
  void visit(const DyldExportsTrie& trie)                 override;
  void visit(const DylibCommand& dylib)                   override;
  void visit(const DylinkerCommand& dylinker)             override;
  void visit(const DynamicSymbolCommand& dynamic_symbol)  override;
  void visit(const EncryptionInfo& e)                     override;
  void visit(const ExportInfo& einfo)                     override;
  void visit(const FilesetCommand& e)                     override;
  void visit(const FunctionStarts& fs)                    override;
  void visit(const Header& header)                        override;
  void visit(const LinkerOptHint& e)                      override;
  void visit(const LoadCommand& cmd)                      override;
  void visit(const MainCommand& maincmd)                  override;
  void visit(const RPathCommand& rpath)                   override;
  void visit(const Relocation& relocation)                override;
  void visit(const RelocationDyld& rdyld)                 override;
  void visit(const RelocationFixup& fixup)                override;
  void visit(const RelocationObject& robject)             override;
  void visit(const Section& section)                      override;
  void visit(const SegmentCommand& segment)               override;
  void visit(const SegmentSplitInfo& ssi)                 override;
  void visit(const SourceVersion& sv)                     override;
  void visit(const SubFramework& sf)                      override;
  void visit(const Symbol& symbol)                        override;
  void visit(const SymbolCommand& symbol)                 override;
  void visit(const ThreadCommand& threadcmd)              override;
  void visit(const TwoLevelHints& e)                      override;
  void visit(const UUIDCommand& uuid)                     override;
  void visit(const VersionMin& vmin)                      override;
  void visit(const UnknownCommand& ukn)                   override;

  ~Hash() override;
};

}
}

#endif

```

`KDemu/include/LIEF/LIEF/MachO/json.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_PUBLIC_JSON_H
#define LIEF_MACHO_PUBLIC_JSON_H
#include "LIEF/visibility.h"
#include <string>

namespace LIEF {
class Object;

namespace MachO {

LIEF_API std::string to_json(const Object& v);

}
}

#endif

```

`KDemu/include/LIEF/LIEF/MachO/type_traits.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_TYPE_TRAITS_H
#define LIEF_MACHO_TYPE_TRAITS_H
#include <vector>
#include <cstdint>

namespace LIEF {
namespace MachO {

using buffer_t = std::vector<uint8_t>;

}
}

#endif

```

`KDemu/include/LIEF/LIEF/MachO/undef.h`:

```h
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_UNDEF_H
#define LIEF_MACHO_UNDEF_H

#ifdef MH_MAGIC
#pragma message("LIEF will disable #define enums. Please use LIEF_MACHO_XXXX or LIEF::MACHO::XXXX instead!")
#endif

#undef  MH_MAGIC
#undef  MH_CIGAM
#undef  MH_MAGIC_64
#undef  MH_CIGAM_64
#undef  FAT_MAGIC
#undef  FAT_CIGAM

#undef  MH_OBJECT
#undef  MH_EXECUTE
#undef  MH_FVMLIB
#undef  MH_CORE
#undef  MH_PRELOAD
#undef  MH_DYLIB
#undef  MH_DYLINKER
#undef  MH_BUNDLE
#undef  MH_DYLIB_STUB
#undef  MH_DSYM
#undef  MH_KEXT_BUNDLE


#undef  MH_NOUNDEFS
#undef  MH_INCRLINK
#undef  MH_DYLDLINK
#undef  MH_BINDATLOAD
#undef  MH_PREBOUND
#undef  MH_SPLIT_SEGS
#undef  MH_LAZY_INIT
#undef  MH_TWOLEVEL
#undef  MH_FORCE_FLAT
#undef  MH_NOMULTIDEFS
#undef  MH_NOFIXPREBINDING
#undef  MH_PREBINDABLE
#undef  MH_ALLMODSBOUND
#undef  MH_SUBSECTIONS_VIA_SYMBOLS
#undef  MH_CANONICAL
#undef  MH_WEAK_DEFINES
#undef  MH_BINDS_TO_WEAK
#undef  MH_ALLOW_STACK_EXECUTION
#undef  MH_ROOT_SAFE
#undef  MH_SETUID_SAFE
#undef  MH_NO_REEXPORTED_DYLIBS
#undef  MH_PIE
#undef  MH_DEAD_STRIPPABLE_DYLIB
#undef  MH_HAS_TLV_DESCRIPTORS
#undef  MH_NO_HEAP_EXECUTION
#undef  MH_APP_EXTENSION_SAFE


#undef  LC_SEGMENT
#undef  LC_SYMTAB
#undef  LC_SYMSEG
#undef  LC_THREAD
#undef  LC_UNIXTHREAD
#undef  LC_LOADFVMLIB
#undef  LC_IDFVMLIB
#undef  LC_IDENT
#undef  LC_FVMFILE
#undef  LC_PREPAGE
#undef  LC_DYSYMTAB
#undef  LC_LOAD_DYLIB
#undef  LC_ID_DYLIB
#undef  LC_LOAD_DYLINKER
#undef  LC_ID_DYLINKER
#undef  LC_PREBOUND_DYLIB
#undef  LC_ROUTINES
#undef  LC_SUB_FRAMEWORK
#undef  LC_SUB_UMBRELLA
#undef  LC_SUB_CLIENT
#undef  LC_SUB_LIBRARY
#undef  LC_TWOLEVEL_HINTS
#undef  LC_PREBIND_CKSUM
#undef  LC_LOAD_WEAK_DYLIB
#undef  LC_SEGMENT_64
#undef  LC_ROUTINES_64
#undef  LC_UUID
#undef  LC_RPATH
#undef  LC_CODE_SIGNATURE
#undef  LC_SEGMENT_SPLIT_INFO
#undef  LC_REEXPORT_DYLIB
#undef  LC_LAZY_LOAD_DYLIB
#undef  LC_ENCRYPTION_INFO
#undef  LC_DYLD_INFO
#undef  LC_DYLD_INFO_ONLY
#undef  LC_LOAD_UPWARD_DYLIB
#undef  LC_VERSION_MIN_MACOSX
#undef  LC_VERSION_MIN_IPHONEOS
#undef  LC_FUNCTION_STARTS
#undef  LC_DYLD_ENVIRONMENT
#undef  LC_MAIN
#undef  LC_DATA_IN_CODE
#undef  LC_SOURCE_VERSION
#undef  LC_DYLIB_CODE_SIGN_DRS
#undef  LC_ENCRYPTION_INFO_64
#undef  LC_LINKER_OPTION
#undef  LC_LINKER_OPTIMIZATION_HINT
#undef  LC_VERSION_MIN_TVOS
#undef  LC_VERSION_MIN_WATCHOS


#undef  SG_HIGHVM
#undef  SG_FVMLIB
#undef  SG_NORELOC
#undef  SG_PROTECTED_VERSION_1


#undef  SECTION_TYPE_MASK
#undef  SECTION_FLAGS_MASK
#undef  SECTION_FLAGS_USR_MASK
#undef  SECTION_FLAGS_SYS_MASK


#undef  S_REGULAR
#undef  S_ZEROFILL
#undef  S_CSTRING_LITERALS
#undef  S_4BYTE_LITERALS
#undef  S_8BYTE_LITERALS
#undef  S_LITERAL_POINTERS
#undef  S_NON_LAZY_SYMBOL_POINTERS
#undef  S_LAZY_SYMBOL_POINTERS
#undef  S_SYMBOL_STUBS
#undef  S_MOD_INIT_FUNC_POINTERS
#undef  S_MOD_TERM_FUNC_POINTERS
#undef  S_COALESCED
#undef  S_GB_ZEROFILL
#undef  S_INTERPOSING
#undef  S_16BYTE_LITERALS
#undef  S_DTRACE_DOF
#undef  S_LAZY_DYLIB_SYMBOL_POINTERS
#undef  S_THREAD_LOCAL_REGULAR
#undef  S_THREAD_LOCAL_ZEROFILL
#undef  S_THREAD_LOCAL_VARIABLES
#undef  S_THREAD_LOCAL_VARIABLE_POINTERS
#undef  S_THREAD_LOCAL_INIT_FUNCTION_POINTERS

#undef  LAST_KNOWN_SECTION_TYPE


#undef  S_ATTR_PURE_INSTRUCTIONS
#undef  S_ATTR_NO_TOC
#undef  S_ATTR_STRIP_STATIC_SYMS
#undef  S_ATTR_NO_DEAD_STRIP
#undef  S_ATTR_LIVE_SUPPORT
#undef  S_ATTR_SELF_MODIFYING_CODE
#undef  S_ATTR_DEBUG

#undef  S_ATTR_SOME_INSTRUCTIONS
#undef  S_ATTR_EXT_RELOC
#undef  S_ATTR_LOC_RELOC

#undef  INDIRECT_SYMBOL_LOCAL
#undef  INDIRECT_SYMBOL_ABS


#undef  DICE_KIND_DATA
#undef  DICE_KIND_JUMP_TABLE8
#undef  DICE_KIND_JUMP_TABLE16
#undef  DICE_KIND_JUMP_TABLE32
#undef  DICE_KIND_ABS_JUMP_TABLE32


#undef  REBASE_TYPE_POINTER
#undef  REBASE_TYPE_TEXT_ABSOLUTE32
#undef  REBASE_TYPE_TEXT_PCREL32


#undef  REBASE_OPCODE_MASK
#undef  REBASE_IMMEDIATE_MASK


#undef  REBASE_OPCODE_DONE
#undef  REBASE_OPCODE_SET_TYPE_IMM
#undef  REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB
#undef  REBASE_OPCODE_ADD_ADDR_ULEB
#undef  REBASE_OPCODE_ADD_ADDR_IMM_SCALED
#undef  REBASE_OPCODE_DO_REBASE_IMM_TIMES
#undef  REBASE_OPCODE_DO_REBASE_ULEB_TIMES
#undef  REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB
#undef  REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB


#undef  BIND_CLASS_WEAK
#undef  BIND_CLASS_LAZY
#undef  BIND_CLASS_STANDARD


#undef  BIND_TYPE_POINTER
#undef  BIND_TYPE_TEXT_ABSOLUTE32
#undef  BIND_TYPE_TEXT_PCREL32


#undef  BIND_SPECIAL_DYLIB_SELF
#undef  BIND_SPECIAL_DYLIB_MAIN_EXECUTABLE
#undef  BIND_SPECIAL_DYLIB_FLAT_LOOKUP


#undef  BIND_SYMBOL_FLAGS_WEAK_IMPORT
#undef  BIND_SYMBOL_FLAGS_NON_WEAK_DEFINITION

#undef  BIND_OPCODE_MASK
#undef  BIND_IMMEDIATE_MASK


#undef  BIND_OPCODE_DONE
#undef  BIND_OPCODE_SET_DYLIB_ORDINAL_IMM
#undef  BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB
#undef  BIND_OPCODE_SET_DYLIB_SPECIAL_IMM
#undef  BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM
#undef  BIND_OPCODE_SET_TYPE_IMM
#undef  BIND_OPCODE_SET_ADDEND_SLEB
#undef  BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB
#undef  BIND_OPCODE_ADD_ADDR_ULEB
#undef  BIND_OPCODE_DO_BIND
#undef  BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB
#undef  BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED
#undef  BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB


#undef  EXPORT_SYMBOL_FLAGS_KIND_MASK
#undef  EXPORT_SYMBOL_FLAGS_WEAK_DEFINITION
#undef  EXPORT_SYMBOL_FLAGS_REEXPORT
#undef  EXPORT_SYMBOL_FLAGS_STUB_AND_RESOLVER


#undef  EXPORT_SYMBOL_FLAGS_KIND_REGULAR
#undef  EXPORT_SYMBOL_FLAGS_KIND_THREAD_LOCAL
#undef  EXPORT_SYMBOL_FLAGS_KIND_ABSOLUTE


#undef  N_STAB
#undef  N_PEXT
#undef  N_TYPE
#undef  N_EXT


#undef  N_UNDF
#undef  N_ABS
#undef  N_SECT
#undef  N_PBUD
#undef  N_INDR


#undef  NO_SECT
#undef  MAX_SECT


#undef  REFERENCE_TYPE
#undef  REFERENCE_FLAG_UNDEFINED_NON_LAZY
#undef  REFERENCE_FLAG_UNDEFINED_LAZY
#undef  REFERENCE_FLAG_DEFINED
#undef  REFERENCE_FLAG_PRIVATE_DEFINED
#undef  REFERENCE_FLAG_PRIVATE_UNDEFINED_NON_LAZY
#undef  REFERENCE_FLAG_PRIVATE_UNDEFINED_LAZY

#undef  N_ARM_THUMB_DEF
#undef  REFERENCED_DYNAMICALLY
#undef  N_NO_DEAD_STRIP
#undef  N_WEAK_REF
#undef  N_WEAK_DEF
#undef  N_SYMBOL_RESOLVER
#undef  N_ALT_ENTRY

#undef  SELF_LIBRARY_ORDINAL
#undef  MAX_LIBRARY_ORDINAL
#undef  DYNAMIC_LOOKUP_ORDINAL
#undef  EXECUTABLE_ORDINAL


#undef  N_GSYM
#undef  N_FNAME
#undef  N_FUN
#undef  N_STSYM
#undef  N_LCSYM
#undef  N_BNSYM
#undef  N_PC
#undef  N_AST
#undef  N_OPT
#undef  N_RSYM
#undef  N_SLINE
#undef  N_ENSYM
#undef  N_SSYM
#undef  N_SO
#undef  N_OSO
#undef  N_LSYM
#undef  N_BINCL
#undef  N_SOL
#undef  N_PARAMS
#undef  N_VERSION
#undef  N_OLEVEL
#undef  N_PSYM
#undef  N_EINCL
#undef  N_ENTRY
#undef  N_LBRAC
#undef  N_EXCL
#undef  N_RBRAC
#undef  N_BCOMM
#undef  N_ECOMM
#undef  N_ECOML
#undef  N_LENG


#undef  R_ABS

#undef  R_SCATTERED


#undef  GENERIC_RELOC_VANILLA
#undef  GENERIC_RELOC_PAIR
#undef  GENERIC_RELOC_SECTDIFF
#undef  GENERIC_RELOC_PB_LA_PTR
#undef  GENERIC_RELOC_LOCAL_SECTDIFF
#undef  GENERIC_RELOC_TLV


#undef  X86_64_RELOC_UNSIGNED
#undef  X86_64_RELOC_SIGNED
#undef  X86_64_RELOC_BRANCH
#undef  X86_64_RELOC_GOT_LOAD
#undef  X86_64_RELOC_GOT
#undef  X86_64_RELOC_SUBTRACTOR
#undef  X86_64_RELOC_SIGNED_1
#undef  X86_64_RELOC_SIGNED_2
#undef  X86_64_RELOC_SIGNED_4
#undef  X86_64_RELOC_TLV


#undef  PPC_RELOC_VANILLA
#undef  PPC_RELOC_PAIR
#undef  PPC_RELOC_BR14
#undef  PPC_RELOC_BR24
#undef  PPC_RELOC_HI16
#undef  PPC_RELOC_LO16
#undef  PPC_RELOC_HA16
#undef  PPC_RELOC_LO14
#undef  PPC_RELOC_SECTDIFF
#undef  PPC_RELOC_PB_LA_PTR
#undef  PPC_RELOC_HI16_SECTDIFF
#undef  PPC_RELOC_LO16_SECTDIFF
#undef  PPC_RELOC_HA16_SECTDIFF
#undef  PPC_RELOC_JBSR
#undef  PPC_RELOC_LO14_SECTDIFF
#undef  PPC_RELOC_LOCAL_SECTDIFF

#undef  ARM_RELOC_VANILLA
#undef  ARM_RELOC_PAIR
#undef  ARM_RELOC_SECTDIFF
#undef  ARM_RELOC_LOCAL_SECTDIFF
#undef  ARM_RELOC_PB_LA_PTR
#undef  ARM_RELOC_BR24
#undef  ARM_THUMB_RELOC_BR22
#undef  ARM_THUMB_32BIT_BRANCH
#undef  ARM_RELOC_HALF
#undef  ARM_RELOC_HALF_SECTDIFF

#undef  ARM64_RELOC_UNSIGNED
#undef  ARM64_RELOC_SUBTRACTOR
#undef  ARM64_RELOC_BRANCH26
#undef  ARM64_RELOC_PAGE21
#undef  ARM64_RELOC_PAGEOFF12
#undef  ARM64_RELOC_GOT_LOAD_PAGE21
#undef  ARM64_RELOC_GOT_LOAD_PAGEOFF12
#undef  ARM64_RELOC_POINTER_TO_GOT
#undef  ARM64_RELOC_TLVP_LOAD_PAGE21
#undef  ARM64_RELOC_TLVP_LOAD_PAGEOFF12
#undef  ARM64_RELOC_ADDEND


#undef  VM_PROT_READ
#undef  VM_PROT_WRITE
#undef  VM_PROT_EXECUTE

#undef  CPU_ARCH_MASK
#undef  CPU_ARCH_ABI64


#undef  CPU_TYPE_ANY
#undef  CPU_TYPE_X86
#undef  CPU_TYPE_I386
#undef  CPU_TYPE_X86_64
#undef  CPU_TYPE_MC98000
#undef  CPU_TYPE_ARM
#undef  CPU_TYPE_ARM64
#undef  CPU_TYPE_SPARC
#undef  CPU_TYPE_POWERPC
#undef  CPU_TYPE_POWERPC64


#undef  CPU_SUBTYPE_MASK
#undef  CPU_SUBTYPE_LIB64

#undef  CPU_SUBTYPE_MULTIPLE


#undef  CPU_SUBTYPE_I386_ALL
#undef  CPU_SUBTYPE_386
#undef  CPU_SUBTYPE_486
#undef  CPU_SUBTYPE_486SX
#undef  CPU_SUBTYPE_586
#undef  CPU_SUBTYPE_PENT
#undef  CPU_SUBTYPE_PENTPRO
#undef  CPU_SUBTYPE_PENTII_M3
#undef  CPU_SUBTYPE_PENTII_M5
#undef  CPU_SUBTYPE_CELERON
#undef  CPU_SUBTYPE_CELERON_MOBILE
#undef  CPU_SUBTYPE_PENTIUM_3
#undef  CPU_SUBTYPE_PENTIUM_3_M
#undef  CPU_SUBTYPE_PENTIUM_3_XEON
#undef  CPU_SUBTYPE_PENTIUM_M
#undef  CPU_SUBTYPE_PENTIUM_4
#undef  CPU_SUBTYPE_PENTIUM_4_M
#undef  CPU_SUBTYPE_ITANIUM
#undef  CPU_SUBTYPE_ITANIUM_2
#undef  CPU_SUBTYPE_XEON
#undef  CPU_SUBTYPE_XEON_MP

#undef  CPU_SUBTYPE_X86_ALL
#undef  CPU_SUBTYPE_X86_64_ALL
#undef  CPU_SUBTYPE_X86_ARCH1
#undef  CPU_SUBTYPE_X86_64_H

#undef  CPU_SUBTYPE_INTEL_FAMILY_MAX
#undef  CPU_SUBTYPE_INTEL_MODEL_ALL


#undef  CPU_SUBTYPE_ARM_ALL
#undef  CPU_SUBTYPE_ARM_V4T
#undef  CPU_SUBTYPE_ARM_V6
#undef  CPU_SUBTYPE_ARM_V5
#undef  CPU_SUBTYPE_ARM_V5TEJ
#undef  CPU_SUBTYPE_ARM_XSCALE
#undef  CPU_SUBTYPE_ARM_V7
#undef  CPU_SUBTYPE_ARM_V7S
#undef  CPU_SUBTYPE_ARM_V7K
#undef  CPU_SUBTYPE_ARM_V6M
#undef  CPU_SUBTYPE_ARM_V7M
#undef  CPU_SUBTYPE_ARM_V7EM

#undef  CPU_SUBTYPE_ARM64_ALL

#undef  CPU_SUBTYPE_SPARC_ALL

#undef  CPU_SUBTYPE_POWERPC_ALL
#undef  CPU_SUBTYPE_POWERPC_601
#undef  CPU_SUBTYPE_POWERPC_602
#undef  CPU_SUBTYPE_POWERPC_603
#undef  CPU_SUBTYPE_POWERPC_603e
#undef  CPU_SUBTYPE_POWERPC_603ev
#undef  CPU_SUBTYPE_POWERPC_604
#undef  CPU_SUBTYPE_POWERPC_604e
#undef  CPU_SUBTYPE_POWERPC_620
#undef  CPU_SUBTYPE_POWERPC_750
#undef  CPU_SUBTYPE_POWERPC_7400
#undef  CPU_SUBTYPE_POWERPC_7450
#undef  CPU_SUBTYPE_POWERPC_970

#undef  CPU_SUBTYPE_MC980000_ALL
#undef  CPU_SUBTYPE_MC98601


#endif

```

`KDemu/include/LIEF/LIEF/MachO/utils.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_MACHO_UTILS_H
#define LIEF_MACHO_UTILS_H

#include <cstdint>
#include "LIEF/visibility.h"

#include <string>
#include <vector>

namespace LIEF {
class BinaryStream;
namespace MachO {
class Binary;
class FatBinary;

//! Check if the given stream wraps a Mach-O binary
LIEF_API bool is_macho(BinaryStream& stream);

//! Check if the given file is a Mach-O binary
LIEF_API bool is_macho(const std::string& file);

//! Check if the given raw data is a Mach-O binary
LIEF_API bool is_macho(const std::vector<uint8_t>& raw);

//! Check if the given file is a FAT Mach-O
LIEF_API bool is_fat(const std::string& file);

//! Check if the given Mach-O is 64-bits
LIEF_API bool is_64(const std::string& file);

//! Check the layout of the given Mach-O binary. It checks if it can be signed
//! according to cctools-921/libstuff/checkout.c
LIEF_API bool check_layout(const Binary& binary, std::string* error = nullptr);

//! Check the layout of the given FAT Mach-O by checking individually the layout
//! of the binaries embedded in the FAT
LIEF_API bool check_layout(const FatBinary& binary, std::string* error = nullptr);
}
}


#endif

```

`KDemu/include/LIEF/LIEF/OAT.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_OAT_H
#define LIEF_OAT_H

#include "LIEF/config.h"

#if defined(LIEF_OAT_SUPPORT)
#include "LIEF/OAT/Parser.hpp"
#include "LIEF/OAT/utils.hpp"
#include "LIEF/OAT/Binary.hpp"
#include "LIEF/OAT/Header.hpp"
#include "LIEF/OAT/DexFile.hpp"
#include "LIEF/OAT/Class.hpp"
#include "LIEF/OAT/Method.hpp"
#include "LIEF/OAT/EnumToString.hpp"
#endif

#endif

```

`KDemu/include/LIEF/LIEF/OAT/Binary.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_OAT_BINARY_H
#define LIEF_OAT_BINARY_H
#include <ostream>

#include "LIEF/visibility.h"

#include "LIEF/ELF/Binary.hpp"
#include "LIEF/OAT/Header.hpp"
#include "LIEF/DEX/deopt.hpp"

namespace LIEF {
namespace DEX {
class File;
}

namespace VDEX {
class File;
}

namespace OAT {
class Parser;
class Class;
class Method;
class DexFile;

class LIEF_API Binary : public ELF::Binary {
  friend class Parser;

  public:
  using dex_files_t        = std::vector<std::unique_ptr<DEX::File>>;
  using it_dex_files       = ref_iterator<dex_files_t&, DEX::File*>;
  using it_const_dex_files = const_ref_iterator<const dex_files_t&, const DEX::File*>;

  using classes_t         = std::unordered_map<std::string, Class*>;
  using classes_list_t    = std::vector<std::unique_ptr<Class>>;
  using it_classes        = ref_iterator<classes_list_t&, Class*>;
  using it_const_classes  = const_ref_iterator<const classes_list_t&, const Class*>;

  using oat_dex_files_t        = std::vector<std::unique_ptr<DexFile>>;
  using it_oat_dex_files       = ref_iterator<oat_dex_files_t&, DexFile*>;
  using it_const_oat_dex_files = const_ref_iterator<const oat_dex_files_t&, const DexFile*>;

  using methods_t         = std::vector<std::unique_ptr<Method>>;
  using it_methods        = ref_iterator<methods_t&, Method*>;
  using it_const_methods  = const_ref_iterator<const methods_t&, const Method*>;

  using dex2dex_info_t = std::unordered_map<const DEX::File*, DEX::dex2dex_info_t>;

  public:
  Binary& operator=(const Binary& copy) = delete;
  Binary(const Binary& copy)            = delete;

  //! OAT Header
  const Header& header() const;
  Header& header();

  //! Iterator over LIEF::DEX::File
  it_dex_files dex_files();
  it_const_dex_files dex_files() const;

  //! Iterator over LIEF::OAT::DexFile
  it_oat_dex_files       oat_dex_files();
  it_const_oat_dex_files oat_dex_files() const;

  //! Iterator over LIEF::OAT::Class
  it_const_classes classes() const;
  it_classes classes();

  //! Check if the current OAT has the given class
  bool has_class(const std::string& class_name) const;


  //! Return the LIEF::OAT::Class with the given name or
  //! a nullptr if the class can't be found
  const Class* get_class(const std::string& class_name) const;

  Class* get_class(const std::string& class_name);

  //! Return the LIEF::OAT::Class at the given index or a nullptr
  //! if it does not exist
  const Class* get_class(size_t index) const;

  Class* get_class(size_t index);

  //! Iterator over LIEF::OAT::Method
  it_const_methods methods() const;
  it_methods methods();

  dex2dex_info_t dex2dex_info() const;

  std::string dex2dex_json_info();

  bool has_vdex() const {
    return vdex_ != nullptr;
  }

  static bool classof(const LIEF::Binary* bin) {
    return bin->format() == Binary::FORMATS::OAT;
  }

  void accept(Visitor& visitor) const override;

  ~Binary() override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const Binary& binary);

  private:
  Binary();
  void add_class(std::unique_ptr<Class> cls);

  Header header_;
  methods_t methods_;
  dex_files_t dex_files_;
  oat_dex_files_t oat_dex_files_;

  classes_t classes_;
  classes_list_t classes_list_;

  // For OAT > 79
  std::unique_ptr<VDEX::File> vdex_;
};

}
}

#endif

```

`KDemu/include/LIEF/LIEF/OAT/Class.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_OAT_CLASS_H
#define LIEF_OAT_CLASS_H

#include "LIEF/iterators.hpp"
#include "LIEF/OAT/enums.hpp"
#include "LIEF/DEX/deopt.hpp"

#include "LIEF/visibility.h"
#include "LIEF/Object.hpp"


namespace LIEF {
namespace DEX {
class Class;
}
namespace OAT {
class Parser;
class Method;

class LIEF_API Class : public Object {
  friend class Parser;

  public:
  using methods_t = std::vector<Method*>;
  using it_methods = ref_iterator<methods_t&>;
  using it_const_methods = const_ref_iterator<const methods_t&>;

  public:
  Class();

  Class(OAT_CLASS_STATUS status, OAT_CLASS_TYPES type,
        DEX::Class* dex_class, std::vector<uint32_t> bitmap = {});

  Class(const Class&);
  Class& operator=(const Class&);

  bool has_dex_class() const;
  const DEX::Class* dex_class() const;
  DEX::Class* dex_class();

  OAT_CLASS_STATUS status() const;
  OAT_CLASS_TYPES type() const;

  const std::string& fullname() const;
  size_t index() const;

  it_methods methods();
  it_const_methods methods() const;

  const std::vector<uint32_t>& bitmap() const;

  bool is_quickened(const DEX::Method& m) const;
  bool is_quickened(uint32_t relative_index) const;

  uint32_t method_offsets_index(const DEX::Method& m) const;
  uint32_t method_offsets_index(uint32_t relative_index) const;

  uint32_t relative_index(const DEX::Method& m) const;
  uint32_t relative_index(uint32_t method_absolute_index) const;

  DEX::dex2dex_class_info_t dex2dex_info() const;

  void accept(Visitor& visitor) const override;


  LIEF_API friend std::ostream& operator<<(std::ostream& os, const Class& cls);

  ~Class() override;

  private:

  DEX::Class* dex_class_ = nullptr;

  OAT_CLASS_STATUS status_ = OAT_CLASS_STATUS::STATUS_NOTREADY;
  OAT_CLASS_TYPES  type_   = OAT_CLASS_TYPES::OAT_CLASS_NONE_COMPILED;

  std::vector<uint32_t> method_bitmap_;
  methods_t methods_;

};

} // Namespace OAT
} // Namespace LIEF
#endif

```

`KDemu/include/LIEF/LIEF/OAT/DexFile.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_OAT_DEXFILE_H
#define LIEF_OAT_DEXFILE_H

#include <cstdint>
#include <string>
#include <vector>

#include "LIEF/visibility.h"
#include "LIEF/Object.hpp"

namespace LIEF {
class Visitor;

namespace DEX {
class File;
}

namespace OAT {
class Parser;

class LIEF_API DexFile : public Object {
  friend class Parser;

  public:
  DexFile();
  DexFile(const DexFile&);
  DexFile& operator=(const DexFile&);

  const std::string& location() const;

  uint32_t checksum() const;
  uint32_t dex_offset() const;

  bool has_dex_file() const;

  const DEX::File* dex_file() const;
  DEX::File* dex_file();

  void location(const std::string& location);
  void checksum(uint32_t checksum);
  void dex_offset(uint32_t dex_offset);

  const std::vector<uint32_t>& classes_offsets() const;

  // Android 7.X.X and Android 8.0.0
  // ===============================
  uint32_t lookup_table_offset() const;

  void class_offsets_offset(uint32_t offset);
  void lookup_table_offset(uint32_t offset);
  // ===============================

  void accept(Visitor& visitor) const override;


  ~DexFile() override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const DexFile& dex_file);

  private:
  std::string location_;
  uint32_t checksum_ = 0;
  uint32_t dex_offset_ = 0;

  DEX::File* dex_file_ = nullptr;

  // OAT 64 (Android 6.X.X)
  std::vector<uint32_t> classes_offsets_;

  // OAT 79 / 88 (Android 7.X.X)
  uint32_t lookup_table_offset_ = 0;

  // OAT 131 (Android 8.1.0)
  uint32_t method_bss_mapping_offset_ = 0;
  uint32_t dex_sections_layout_offset_ = 0;
};

} // Namespace OAT
} // Namespace LIEF
#endif

```

`KDemu/include/LIEF/LIEF/OAT/EnumToString.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef OAT_ENUM_TO_STRING_H
#define OAT_ENUM_TO_STRING_H
#include "LIEF/visibility.h"
#include "LIEF/OAT/enums.hpp"

namespace LIEF {
namespace OAT {

LIEF_API const char* to_string(OAT_CLASS_TYPES e);
LIEF_API const char* to_string(OAT_CLASS_STATUS e);
LIEF_API const char* to_string(HEADER_KEYS e);
LIEF_API const char* to_string(INSTRUCTION_SETS e);

} // namespace OAT
} // namespace LIEF

#endif


```

`KDemu/include/LIEF/LIEF/OAT/Header.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_OAT_HEADER_H
#define LIEF_OAT_HEADER_H
#include <functional>
#include <map>
#include <string>
#include <vector>
#include <utility>
#include <array>

#include "LIEF/iterators.hpp"
#include "LIEF/OAT/type_traits.hpp"
#include "LIEF/OAT/enums.hpp"

#include "LIEF/visibility.h"
#include "LIEF/Object.hpp"

namespace LIEF {
namespace OAT {
class Parser;

class LIEF_API Header : public Object {
  friend class Parser;

  public:
  struct element_t {
    element_t(HEADER_KEYS key, const std::string& value) :
      key(key), value(const_cast<std::string*>(&value)) {}

    HEADER_KEYS key;
    std::string* value = nullptr;
  };
  using magic_t               = std::array<uint8_t, 4>; // oat\n
  using key_values_t          = std::map<HEADER_KEYS, std::string>;
  using it_key_values_t       = ref_iterator<std::vector<element_t>>;
  using it_const_key_values_t = const_ref_iterator<std::vector<element_t>>;

  //! @brief Iterator type over
  using keys_t   = std::vector<HEADER_KEYS>;
  using values_t = std::vector<std::string>;

  public:
  //! Return the string value associated with the given key
  static std::string key_to_string(HEADER_KEYS key);

  public:
  Header();
  Header(const Header&);
  Header& operator=(const Header&);

  template<class T>
  LIEF_LOCAL Header(const T* header);

  //! Magic value: ``oat``
  Header::magic_t magic() const;

  //! OAT version
  oat_version_t version() const;

  uint32_t checksum() const;

  INSTRUCTION_SETS instruction_set() const;
  // TODO instruction_set_features_bitmap_() const;


  uint32_t nb_dex_files() const;

  // Since OAT 131
  uint32_t oat_dex_files_offset() const;

  uint32_t executable_offset() const;
  uint32_t i2i_bridge_offset() const;
  uint32_t i2c_code_bridge_offset() const;
  uint32_t jni_dlsym_lookup_offset() const;

  uint32_t quick_generic_jni_trampoline_offset() const;
  uint32_t quick_imt_conflict_trampoline_offset() const;
  uint32_t quick_resolution_trampoline_offset() const;
  uint32_t quick_to_interpreter_bridge_offset() const;

  int32_t image_patch_delta() const;

  uint32_t image_file_location_oat_checksum() const;
  uint32_t image_file_location_oat_data_begin() const;

  uint32_t key_value_size() const;

  it_key_values_t       key_values();
  it_const_key_values_t key_values() const;

  keys_t keys() const;
  values_t values() const;

  const std::string* get(HEADER_KEYS key) const;
  std::string* get(HEADER_KEYS key);

  Header& set(HEADER_KEYS key, const std::string& value);

  const std::string* operator[](HEADER_KEYS key) const;
  std::string* operator[](HEADER_KEYS key);

  void magic(const magic_t& magic);

  void accept(Visitor& visitor) const override;


  LIEF_API friend std::ostream& operator<<(std::ostream& os, const Header& hdr);

  private:
  magic_t magic_;
  oat_version_t version_ = 0;
  uint32_t checksum_ = 0;
  INSTRUCTION_SETS instruction_set_ = INSTRUCTION_SETS::INST_SET_NONE;
  uint32_t instruction_set_features_bitmap_ = 0;
  uint32_t dex_file_count_ = 0;
  uint32_t oat_dex_files_offset_ = 0; // Since OAT 131 / Android 8.1.0
  uint32_t executable_offset_ = 0;
  uint32_t i2i_bridge_offset_ = 0;
  uint32_t i2c_code_bridge_offset_ = 0;
  uint32_t jni_dlsym_lookup_offset_ = 0;

  uint32_t quick_generic_jni_trampoline_offset_ = 0;
  uint32_t quick_imt_conflict_trampoline_offset_ = 0;
  uint32_t quick_resolution_trampoline_offset_ = 0;
  uint32_t quick_to_interpreter_bridge_offset_ = 0;

  int32_t image_patch_delta_ = 0;

  uint32_t image_file_location_oat_checksum_ = 0;
  uint32_t image_file_location_oat_data_begin_ = 0;

  uint32_t key_value_store_size_ = 0;

  key_values_t dex2oat_context_;


};

}
}

#endif

```

`KDemu/include/LIEF/LIEF/OAT/Method.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_OAT_METHOD_H
#define LIEF_OAT_METHOD_H

#include <vector>
#include <string>
#include <ostream>
#include "LIEF/visibility.h"
#include "LIEF/Object.hpp"
#include "LIEF/DEX/deopt.hpp"

namespace LIEF {
namespace DEX {
class Method;
}
namespace OAT {
class Parser;
class Class;

class LIEF_API Method : public Object {
  friend class Parser;
  public:

  //! Container for the Quick Code
  using quick_code_t = std::vector<uint8_t>;

  public:
  Method();
  Method(DEX::Method* method, Class* oat_class, std::vector<uint8_t>  code = {});
  Method(const Method&);
  Method& operator=(const Method&);


  //! Method's name
  std::string name() const;

  //! OAT Class associated with this Method
  const Class* oat_class() const;
  Class* oat_class();

  //! Check if a LIEF::DEX::Method is associated with
  //! this Method
  bool has_dex_method() const;

  //! LIEF::DEX::Method associated (if any)
  const DEX::Method* dex_method() const;
  DEX::Method* dex_method();

  //! True if the optimization is DEX
  bool is_dex2dex_optimized() const;

  // True if the optimization is native
  bool is_compiled() const;

  const DEX::dex2dex_method_info_t& dex2dex_info() const;

  //! Quick code associated with the method
  const quick_code_t& quick_code() const;
  void quick_code(const quick_code_t& code);

  void accept(Visitor& visitor) const override;


  LIEF_API friend std::ostream& operator<<(std::ostream& os, const Method& meth);

  ~Method() override;

  private:
  DEX::Method* dex_method_ = nullptr;
  Class* class_ = nullptr;

  quick_code_t quick_code_;
};

} // Namespace OAT
} // Namespace LIEF
#endif

```

`KDemu/include/LIEF/LIEF/OAT/Parser.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_OAT_PARSER_H
#define LIEF_OAT_PARSER_H
#include <memory>

#include "LIEF/visibility.h"
#include "LIEF/ELF/Parser.hpp"

namespace LIEF {

namespace VDEX {
class File;
}

namespace DEX {
class Class;
}

namespace OAT {
class Binary;
class Class;

//! Class to parse an OAT file to produce an OAT::Binary
class LIEF_API Parser : public ELF::Parser {
  public:
  //! Parse an OAT file
  static std::unique_ptr<Binary> parse(const std::string& oat_file);
  static std::unique_ptr<Binary> parse(const std::string& oat_file,
                                       const std::string& vdex_file);

  static std::unique_ptr<Binary> parse(std::vector<uint8_t> data);

  Parser& operator=(const Parser& copy) = delete;
  Parser(const Parser& copy)            = delete;

  protected:
  Parser();
  Parser(const std::string& oat_file);
  Parser(std::vector<uint8_t> data);
  ~Parser() override;

  Binary& oat_binary() {
    // The type of the parent binary_ is guaranteed by the constructor
    return *reinterpret_cast<Binary*>(binary_.get());
  }

  bool has_vdex() const;
  void set_vdex(std::unique_ptr<VDEX::File> file);

  template<typename OAT_T>
  void parse_binary();

  template<typename OAT_T>
  void parse_header();

  template<typename OAT_T>
  void parse_header_keys();

  template<typename OAT_T>
  void parse_dex_files();

  template<typename OAT_T>
  void parse_type_lookup_table();

  template<typename OAT_T>
  void parse_oat_classes();

  template<typename OAT_T>
  void parse_oat_methods(uint64_t methods_offsets, Class& clazz, const DEX::Class& dex_class);

  void init();

  std::unique_ptr<LIEF::VDEX::File> vdex_file_;

  uint64_t data_address_ = 0;
  uint64_t data_size_ = 0;

  uint64_t exec_start_ = 0;
  uint64_t exec_size_ = 0;
};

} // namespace OAT
} // namespace LIEF
#endif

```

`KDemu/include/LIEF/LIEF/OAT/enums.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_OAT_ENUMS_H
#define LIEF_OAT_ENUMS_H

namespace LIEF {
namespace OAT {

enum OAT_CLASS_TYPES {
  OAT_CLASS_ALL_COMPILED  = 0, //! OatClass is followed by an OatMethodOffsets for each method.
  OAT_CLASS_SOME_COMPILED = 1, //! A bitmap of which OatMethodOffsets are present follows the OatClass.
  OAT_CLASS_NONE_COMPILED = 2, //! All methods are interpreted so no OatMethodOffsets are necessary.
};

// From art/runtime/mirror/class.h
enum OAT_CLASS_STATUS {
  STATUS_RETIRED                       = -2,  // Retired, should not be used. Use the newly cloned one instead.
  STATUS_ERROR                         = -1,
  STATUS_NOTREADY                      = 0,
  STATUS_IDX                           = 1,  // Loaded, DEX idx in super_class_type_idx_ and interfaces_type_idx_.
  STATUS_LOADED                        = 2,  // DEX idx values resolved.
  STATUS_RESOLVING                     = 3,  // Just cloned from temporary class object.
  STATUS_RESOLVED                      = 4,  // Part of linking.
  STATUS_VERIFYING                     = 5,  // In the process of being verified.
  STATUS_RETRY_VERIFICATION_AT_RUNTIME = 6,  // Compile time verification failed, retry at runtime.
  STATUS_VERIFYING_AT_RUNTIME          = 7,  // Retrying verification at runtime.
  STATUS_VERIFIED                      = 8,  // Logically part of linking; done pre-init.
  STATUS_INITIALIZING                  = 9,  // Class init in progress.
  STATUS_INITIALIZED                   = 10, // Ready to go.
};

enum HEADER_KEYS {
  KEY_IMAGE_LOCATION     = 0,
  KEY_DEX2OAT_CMD_LINE   = 1,
  KEY_DEX2OAT_HOST       = 2,
  KEY_PIC                = 3,
  KEY_HAS_PATCH_INFO     = 4,
  KEY_DEBUGGABLE         = 5,
  KEY_NATIVE_DEBUGGABLE  = 6,
  KEY_COMPILER_FILTER    = 7,
  KEY_CLASS_PATH         = 8,
  KEY_BOOT_CLASS_PATH    = 9,
  KEY_CONCURRENT_COPYING = 10,
  KE_COMPILATION_REASON  = 11,
};

enum INSTRUCTION_SETS {
  INST_SET_NONE    = 0,
  INST_SET_ARM     = 1,
  INST_SET_ARM_64  = 2,
  INST_SET_THUMB2  = 3,
  INST_SET_X86     = 4,
  INST_SET_X86_64  = 5,
  INST_SET_MIPS    = 6,
  INST_SET_MIPS_64 = 7,
};



static const HEADER_KEYS header_keys_list[] = {
  HEADER_KEYS::KEY_IMAGE_LOCATION     ,
  HEADER_KEYS::KEY_DEX2OAT_CMD_LINE   ,
  HEADER_KEYS::KEY_DEX2OAT_HOST       ,
  HEADER_KEYS::KEY_PIC                ,
  HEADER_KEYS::KEY_HAS_PATCH_INFO     ,
  HEADER_KEYS::KEY_DEBUGGABLE         ,
  HEADER_KEYS::KEY_NATIVE_DEBUGGABLE  ,
  HEADER_KEYS::KEY_COMPILER_FILTER    ,
  HEADER_KEYS::KEY_CLASS_PATH         ,
  HEADER_KEYS::KEY_BOOT_CLASS_PATH    ,
  HEADER_KEYS::KEY_CONCURRENT_COPYING ,
  HEADER_KEYS::KE_COMPILATION_REASON  ,
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/OAT/hash.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_OAT_HASH_H
#define LIEF_OAT_HASH_H

#include "LIEF/visibility.h"
#include "LIEF/hash.hpp"

namespace LIEF {
class Object;
namespace OAT {

class Binary;
class Class;
class DexFile;
class Header;
class Method;

class LIEF_API Hash : public LIEF::Hash {
  public:
  static LIEF::Hash::value_type hash(const Object& obj);

  public:
  using LIEF::Hash::Hash;
  using LIEF::Hash::visit;

  public:
  void visit(const Binary& binary)        override;
  void visit(const Header& header)        override;
  void visit(const DexFile& dex_file)     override;
  void visit(const Class& cls)            override;
  void visit(const Method& method)        override;

  ~Hash() override;
};

}
}

#endif

```

`KDemu/include/LIEF/LIEF/OAT/json.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_OAT_PUBLIC_JSON_H
#define LIEF_OAT_PUBLIC_JSON_H

#include "LIEF/visibility.h"
#include <string>
namespace LIEF {
class Object;

namespace OAT {
LIEF_API std::string to_json(const Object& v);
}
}


#endif

```

`KDemu/include/LIEF/LIEF/OAT/type_traits.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_OAT_TYPES_H
#define LIEF_OAT_TYPES_H
#include <cstdint>

namespace LIEF {
namespace OAT {
using oat_version_t = uint32_t;
}
}

#endif

```

`KDemu/include/LIEF/LIEF/OAT/utils.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_OAT_UTILS_H
#define LIEF_OAT_UTILS_H

#include <string>
#include <vector>

#include "LIEF/types.hpp"
#include "LIEF/visibility.h"

#include "LIEF/OAT/type_traits.hpp"
#include "LIEF/platforms/android.hpp"

namespace LIEF {
namespace ELF {
class Binary;
}
namespace OAT {

//! @brief Check if the given LIEF::ELF::Binary is an OAT one.
LIEF_API bool is_oat(const LIEF::ELF::Binary& elf_binary);

//! @brief Check if the given file is an OAT one.
LIEF_API bool is_oat(const std::string& file);

//! @brief Check if the given raw data is an OAT one.
LIEF_API bool is_oat(const std::vector<uint8_t>& raw);

//! @brief Return the OAT version of the given file
LIEF_API oat_version_t version(const std::string& file);

//! @brief Return the OAT version of the raw data
LIEF_API oat_version_t version(const std::vector<uint8_t>& raw);

//! @brief Return the OAT version of the given LIEF::ELF::Binary
LIEF_API oat_version_t version(const LIEF::ELF::Binary& elf_binary);

//! @brief Return the ANDROID_VERSIONS associated with the given OAT version
LIEF_API LIEF::Android::ANDROID_VERSIONS android_version(oat_version_t version);


}
}


#endif

```

`KDemu/include/LIEF/LIEF/ObjC.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_OBJC_H
#define LIEF_OBJC_H
#include <LIEF/ObjC/Metadata.hpp>
#include <LIEF/ObjC/Class.hpp>
#include <LIEF/ObjC/IVar.hpp>
#include <LIEF/ObjC/Method.hpp>
#include <LIEF/ObjC/Property.hpp>
#include <LIEF/ObjC/Protocol.hpp>
#endif

```

`KDemu/include/LIEF/LIEF/ObjC/Class.hpp`:

```hpp
/* Copyright 2022 - 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_OBJC_CLASS_H
#define LIEF_OBJC_CLASS_H
#include <LIEF/visibility.h>
#include <LIEF/ObjC/IVar.hpp>
#include <LIEF/ObjC/Protocol.hpp>
#include <LIEF/ObjC/Method.hpp>
#include <LIEF/ObjC/Property.hpp>

#include <memory>
#include <string>

namespace LIEF {
namespace objc {

namespace details {
class Class;
class ClassIt;
}

/// This class represents an Objective-C class (`@interface`)
class LIEF_API Class {
  public:
  class LIEF_API Iterator {
    public:
    using iterator_category = std::bidirectional_iterator_tag;
    using value_type = std::unique_ptr<Class>;
    using difference_type = std::ptrdiff_t;
    using pointer = Class*;
    using reference = std::unique_ptr<Class>&;
    using implementation = details::ClassIt;

    class LIEF_API PointerProxy {
      // Inspired from LLVM's iterator_facade_base
      friend class Iterator;
      public:
      pointer operator->() const { return R.get(); }

      private:
      value_type R;

      template <typename RefT>
      PointerProxy(RefT &&R) : R(std::forward<RefT>(R)) {} // NOLINT(bugprone-forwarding-reference-overload)
    };

    Iterator(const Iterator&);
    Iterator(Iterator&&) noexcept;
    Iterator(std::unique_ptr<details::ClassIt> impl);
    ~Iterator();

    friend LIEF_API bool operator==(const Iterator& LHS, const Iterator& RHS);

    friend LIEF_API bool operator!=(const Iterator& LHS, const Iterator& RHS) {
      return !(LHS == RHS);
    }

    Iterator& operator++();
    Iterator& operator--();

    Iterator operator--(int) {
      Iterator tmp = *static_cast<Iterator*>(this);
      --*static_cast<Iterator *>(this);
      return tmp;
    }

    Iterator operator++(int) {
      Iterator tmp = *static_cast<Iterator*>(this);
      ++*static_cast<Iterator *>(this);
      return tmp;
    }

    std::unique_ptr<Class> operator*() const;

    PointerProxy operator->() const {
      return static_cast<const Iterator*>(this)->operator*();
    }

    private:
    std::unique_ptr<details::ClassIt> impl_;
  };

  public:
  /// Iterator for the class's method
  using methods_t = iterator_range<Method::Iterator>;

  /// Iterator for the protocols implemented by this class
  using protocols_t = iterator_range<Protocol::Iterator>;

  /// Iterator for the properties declared by this class
  using properties_t = iterator_range<Property::Iterator>;

  /// Iterator for the instance variables defined by this class
  using ivars_t = iterator_range<IVar::Iterator>;

  Class(std::unique_ptr<details::Class> impl);

  /// Name of the class
  std::string name() const;

  /// Demangled name of the class
  std::string demangled_name() const;

  /// Parent class in case of inheritance
  std::unique_ptr<Class> super_class() const;

  bool is_meta() const;

  /// Iterator over the different methods defined by this class
  methods_t methods() const;

  /// Iterator over the different protocols implemented by this class
  protocols_t protocols() const;

  /// Iterator over the properties of this class
  properties_t properties() const;

  /// Iterator over the different instance variables defined in this class
  ivars_t ivars() const;

  ~Class();
  private:
  std::unique_ptr<details::Class> impl_;
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/ObjC/IVar.hpp`:

```hpp
/* Copyright 2022 - 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_OBJC_IVAR_H
#define LIEF_OBJC_IVAR_H
#include <LIEF/visibility.h>
#include <LIEF/ObjC/Method.hpp>
#include <LIEF/ObjC/Property.hpp>
#include <LIEF/iterators.hpp>

#include <memory>
#include <string>

namespace LIEF {
namespace objc {

namespace details {
class IVar;
class IVarIt;
}

/// This class represents an instance variable (ivar)
class LIEF_API IVar {
  public:
  class LIEF_API Iterator {
    public:
    using iterator_category = std::bidirectional_iterator_tag;
    using value_type = std::unique_ptr<IVar>;
    using difference_type = std::ptrdiff_t;
    using pointer = IVar*;
    using reference = std::unique_ptr<IVar>&;
    using implementation = details::IVarIt;

    class LIEF_API PointerProxy {
      // Inspired from LLVM's iterator_facade_base
      friend class Iterator;
      public:
      pointer operator->() const { return R.get(); }

      private:
      value_type R;

      template <typename RefT>
      PointerProxy(RefT &&R) : R(std::forward<RefT>(R)) {} // NOLINT(bugprone-forwarding-reference-overload)
    };

    Iterator(const Iterator&);
    Iterator(Iterator&&) noexcept;
    Iterator(std::unique_ptr<details::IVarIt> impl);
    ~Iterator();

    friend LIEF_API bool operator==(const Iterator& LHS, const Iterator& RHS);

    friend LIEF_API bool operator!=(const Iterator& LHS, const Iterator& RHS) {
      return !(LHS == RHS);
    }

    Iterator& operator++();
    Iterator& operator--();

    Iterator operator--(int) {
      Iterator tmp = *static_cast<Iterator*>(this);
      --*static_cast<Iterator *>(this);
      return tmp;
    }

    Iterator operator++(int) {
      Iterator tmp = *static_cast<Iterator*>(this);
      ++*static_cast<Iterator *>(this);
      return tmp;
    }

    std::unique_ptr<IVar> operator*() const;

    PointerProxy operator->() const {
      return static_cast<const Iterator*>(this)->operator*();
    }

    private:
    std::unique_ptr<details::IVarIt> impl_;
  };

  public:
  IVar(std::unique_ptr<details::IVar> impl);

  /// Name of the instance variable
  std::string name() const;

  /// Type of the instance var in its mangled representation (`[29i]`)
  std::string mangled_type() const;

  ~IVar();
  private:
  std::unique_ptr<details::IVar> impl_;
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/ObjC/Metadata.hpp`:

```hpp
/* Copyright 2022 - 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_OBJC_METADATA_H
#define LIEF_OBJC_METADATA_H
#include <LIEF/visibility.h>
#include <LIEF/ObjC/Class.hpp>
#include <LIEF/ObjC/Protocol.hpp>

#include <LIEF/iterators.hpp>

#include <memory>

namespace LIEF {
namespace objc {

namespace details {
class Metadata;
}

/// This class is the main interface to inspect Objective-C metadata
///
/// It can be instantiated using the function LIEF::MachO::Binary::objc_metadata
class LIEF_API Metadata {
  public:
  using classes_it = iterator_range<Class::Iterator>;
  using protocols_it = iterator_range<Protocol::Iterator>;

  Metadata(std::unique_ptr<details::Metadata> impl);

  /// Return an iterator over the different Objective-C classes (`@interface`)
  classes_it classes() const;

  /// Return an iterator over the Objective-C protocols declared in this binary (`@protocol`).
  protocols_it protocols() const;

  /// Try to find the Objective-C class with the given **mangled** name
  std::unique_ptr<Class> get_class(const std::string& name) const;

  /// Try to find the Objective-C protocol with the given **mangled** name
  std::unique_ptr<Protocol> get_protocol(const std::string& name) const;

  /// Generate a header-like of all the Objective-C metadata identified in the
  /// binary.
  std::string to_decl() const;

  ~Metadata();
  private:
  std::unique_ptr<details::Metadata> impl_;
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/ObjC/Method.hpp`:

```hpp
/* Copyright 2022 - 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_OBJC_METHOD_H
#define LIEF_OBJC_METHOD_H
#include <LIEF/visibility.h>

#include <memory>
#include <string>

namespace LIEF {
namespace objc {

namespace details {
class Method;
class MethodIt;
}

/// This class represents an Objective-C Method
class LIEF_API Method {
  public:
  class LIEF_API Iterator {
    public:
    using iterator_category = std::bidirectional_iterator_tag;
    using value_type = std::unique_ptr<Method>;
    using difference_type = std::ptrdiff_t;
    using pointer = Method*;
    using reference = std::unique_ptr<Method>&;
    using implementation = details::MethodIt;

    class LIEF_API PointerProxy {
      // Inspired from LLVM's iterator_facade_base
      friend class Iterator;
      public:
      pointer operator->() const { return R.get(); }

      private:
      value_type R;

      template <typename RefT>
      PointerProxy(RefT &&R) : R(std::forward<RefT>(R)) {} // NOLINT(bugprone-forwarding-reference-overload)
    };

    Iterator(const Iterator&);
    Iterator(Iterator&&) noexcept;
    Iterator(std::unique_ptr<details::MethodIt> impl);
    ~Iterator();

    friend LIEF_API bool operator==(const Iterator& LHS, const Iterator& RHS);

    friend LIEF_API bool operator!=(const Iterator& LHS, const Iterator& RHS) {
      return !(LHS == RHS);
    }

    Iterator& operator++();
    Iterator& operator--();

    Iterator operator--(int) {
      Iterator tmp = *static_cast<Iterator*>(this);
      --*static_cast<Iterator *>(this);
      return tmp;
    }

    Iterator operator++(int) {
      Iterator tmp = *static_cast<Iterator*>(this);
      ++*static_cast<Iterator *>(this);
      return tmp;
    }

    std::unique_ptr<Method> operator*() const;

    PointerProxy operator->() const {
      return static_cast<const Iterator*>(this)->operator*();
    }

    private:
    std::unique_ptr<details::MethodIt> impl_;
  };

  public:
  Method(std::unique_ptr<details::Method> impl);

  /// Name of the method
  std::string name() const;

  /// Prototype of the method in its mangled representation (e.g. `@16@0:8`)
  std::string mangled_type() const;

  /// Virtual address where this method is implemented in the binary
  uintptr_t address() const;

  /// Whether it's an instance method
  bool is_instance() const;

  ~Method();
  private:
  std::unique_ptr<details::Method> impl_;
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/ObjC/Property.hpp`:

```hpp
/* Copyright 2022 - 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_OBJC_PROPERTY_H
#define LIEF_OBJC_PROPERTY_H
#include <LIEF/visibility.h>

#include <memory>
#include <string>

namespace LIEF {
namespace objc {

namespace details {
class Property;
class PropertyIt;
}

/// This class represents a `@property` in Objective-C
class LIEF_API Property {
  public:
  class LIEF_API Iterator {
    public:
    using iterator_category = std::bidirectional_iterator_tag;
    using value_type = std::unique_ptr<Property>;
    using difference_type = std::ptrdiff_t;
    using pointer = Property*;
    using reference = std::unique_ptr<Property>&;
    using implementation = details::PropertyIt;

    class LIEF_API PointerProxy {
      // Inspired from LLVM's iterator_facade_base
      friend class Iterator;
      public:
      pointer operator->() const { return R.get(); }

      private:
      value_type R;

      template <typename RefT>
      PointerProxy(RefT &&R) : R(std::forward<RefT>(R)) {} // NOLINT(bugprone-forwarding-reference-overload)
    };

    Iterator(const Iterator&);
    Iterator(Iterator&&) noexcept;
    Iterator(std::unique_ptr<details::PropertyIt> impl);
    ~Iterator();

    friend LIEF_API bool operator==(const Iterator& LHS, const Iterator& RHS);

    friend LIEF_API bool operator!=(const Iterator& LHS, const Iterator& RHS) {
      return !(LHS == RHS);
    }

    Iterator& operator++();
    Iterator& operator--();

    Iterator operator--(int) {
      Iterator tmp = *static_cast<Iterator*>(this);
      --*static_cast<Iterator *>(this);
      return tmp;
    }

    Iterator operator++(int) {
      Iterator tmp = *static_cast<Iterator*>(this);
      ++*static_cast<Iterator *>(this);
      return tmp;
    }

    std::unique_ptr<Property> operator*() const;

    PointerProxy operator->() const {
      return static_cast<const Iterator*>(this)->operator*();
    }

    private:
    std::unique_ptr<details::PropertyIt> impl_;
  };

  public:
  Property(std::unique_ptr<details::Property> impl);

  /// Name of the property
  std::string name() const;

  /// (raw) property's attributes (e.g. `T@"NSString",C,D,N`)
  std::string attribute() const;

  ~Property();
  private:
  std::unique_ptr<details::Property> impl_;
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/ObjC/Protocol.hpp`:

```hpp
/* Copyright 2022 - 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_OBJC_PROTOCOL_H
#define LIEF_OBJC_PROTOCOL_H
#include <LIEF/visibility.h>
#include <LIEF/ObjC/Method.hpp>
#include <LIEF/ObjC/Property.hpp>
#include <LIEF/iterators.hpp>

#include <memory>
#include <string>

namespace LIEF {
namespace objc {

namespace details {
class Protocol;
class ProtocolIt;
}

/// This class represents an Objective-C `@protocol`
class LIEF_API Protocol {
  public:
  class LIEF_API Iterator {
    public:
    using iterator_category = std::bidirectional_iterator_tag;
    using value_type = std::unique_ptr<Protocol>;
    using difference_type = std::ptrdiff_t;
    using pointer = Protocol*;
    using reference = std::unique_ptr<Protocol>&;
    using implementation = details::ProtocolIt;

    class LIEF_API PointerProxy {
      // Inspired from LLVM's iterator_facade_base
      friend class Iterator;
      public:
      pointer operator->() const { return R.get(); }

      private:
      value_type R;

      template <typename RefT>
      PointerProxy(RefT &&R) : R(std::forward<RefT>(R)) {} // NOLINT(bugprone-forwarding-reference-overload)
    };

    Iterator(const Iterator&);
    Iterator(Iterator&&) noexcept;
    Iterator(std::unique_ptr<details::ProtocolIt> impl);
    ~Iterator();

    friend LIEF_API bool operator==(const Iterator& LHS, const Iterator& RHS);

    friend LIEF_API bool operator!=(const Iterator& LHS, const Iterator& RHS) {
      return !(LHS == RHS);
    }

    Iterator& operator++();
    Iterator& operator--();

    Iterator operator--(int) {
      Iterator tmp = *static_cast<Iterator*>(this);
      --*static_cast<Iterator *>(this);
      return tmp;
    }

    Iterator operator++(int) {
      Iterator tmp = *static_cast<Iterator*>(this);
      ++*static_cast<Iterator *>(this);
      return tmp;
    }

    std::unique_ptr<Protocol> operator*() const;

    PointerProxy operator->() const {
      return static_cast<const Iterator*>(this)->operator*();
    }

    private:
    std::unique_ptr<details::ProtocolIt> impl_;
  };

  public:
  using methods_it = iterator_range<Method::Iterator>;
  using properties_it = iterator_range<Property::Iterator>;

  Protocol(std::unique_ptr<details::Protocol> impl);

  /// Mangled name of the protocol
  std::string mangled_name() const;

  /// Iterator over the methods that could be overridden
  methods_it optional_methods() const;

  /// Iterator over the methods of this protocol that must be implemented
  methods_it required_methods() const;

  /// Iterator over the properties defined in this protocol
  properties_it properties() const;

  ~Protocol();
  private:
  std::unique_ptr<details::Protocol> impl_;
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/Object.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_OBJECT_H
#define LIEF_OBJECT_H
#include <type_traits>
#include "LIEF/visibility.h"

namespace LIEF {

class Visitor;

class LIEF_API Object {

  template<class T>
  using add_pointer_t = typename std::add_pointer<T>::type;

  template<class T>
  using decay_t = typename std::decay<T>::type;

  template<class T>
  using add_const_t = typename std::add_const<T>::type;

  public:
  template<class T>
  using output_t = add_pointer_t<decay_t<T>>;

  template<class T>
  using output_const_t = add_pointer_t<add_const_t<decay_t<T>>>;

  public:
  Object();
  Object(const Object& other);
  Object& operator=(const Object& other);

  template<class T>
  LIEF_LOCAL output_t<T> as();

  template<class T>
  LIEF_LOCAL output_const_t<T> as() const;

  virtual bool operator==(const Object& other) const;
  virtual bool operator!=(const Object& other) const {
    return !(*this == other);
  }

  virtual ~Object();
  virtual void accept(Visitor& visitor) const = 0;
};
}

#endif

```

`KDemu/include/LIEF/LIEF/PDB.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef  LIEF_PDB_H
#define  LIEF_PDB_H
#include <LIEF/PDB/CompilationUnit.hpp>
#include <LIEF/PDB/Function.hpp>
#include <LIEF/PDB/PublicSymbol.hpp>
#include <LIEF/PDB/DebugInfo.hpp>
#include <LIEF/PDB/Type.hpp>
#include <LIEF/PDB/types.hpp>
#endif

```

`KDemu/include/LIEF/LIEF/PDB/CompilationUnit.hpp`:

```hpp
/* Copyright 2022 - 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PDB_COMPILATION_UNIT_H
#define LIEF_PDB_COMPILATION_UNIT_H
#include <memory>
#include <string>
#include <vector>

#include "LIEF/iterators.hpp"
#include "LIEF/PDB/Function.hpp"

#include "LIEF/visibility.h"

namespace LIEF {
namespace pdb {

namespace details {
class CompilationUnit;
class CompilationUnitIt;
}

/// This class represents a CompilationUnit (or Module) in a PDB file
class LIEF_API CompilationUnit {
  public:
  class LIEF_API Iterator {
    public:
    using iterator_category = std::bidirectional_iterator_tag;
    using value_type = std::unique_ptr<CompilationUnit>;
    using difference_type = std::ptrdiff_t;
    using pointer = CompilationUnit*;
    using reference = CompilationUnit&;
    using implementation = details::CompilationUnitIt;

    class PointerProxy {
      // Inspired from LLVM's iterator_facade_base
      friend class Iterator;
      public:
      pointer operator->() const { return R.get(); }

      private:
      value_type R;

      template <typename RefT>
      PointerProxy(RefT &&R) : R(std::forward<RefT>(R)) {} // NOLINT(bugprone-forwarding-reference-overload)
    };

    Iterator(const Iterator&);
    Iterator(Iterator&&);
    Iterator(std::unique_ptr<details::CompilationUnitIt> impl);
    ~Iterator();

    friend LIEF_API bool operator==(const Iterator& LHS, const Iterator& RHS);
    friend LIEF_API bool operator!=(const Iterator& LHS, const Iterator& RHS) {
      return !(LHS == RHS);
    }

    Iterator& operator++();
    Iterator& operator--();

    Iterator operator--(int) {
      Iterator tmp = *static_cast<Iterator*>(this);
      --*static_cast<Iterator *>(this);
      return tmp;
    }

    Iterator operator++(int) {
      Iterator tmp = *static_cast<Iterator*>(this);
      ++*static_cast<Iterator *>(this);
      return tmp;
    }

    std::unique_ptr<CompilationUnit> operator*() const;

    PointerProxy operator->() const {
      return static_cast<const Iterator*>(this)->operator*();
    }

    private:
    std::unique_ptr<details::CompilationUnitIt> impl_;
  };

  /// Iterator over the sources file (std::string)
  using sources_iterator = iterator_range<std::vector<std::string>::const_iterator>;

  using function_iterator = iterator_range<Function::Iterator>;

  CompilationUnit(std::unique_ptr<details::CompilationUnit> impl);
  ~CompilationUnit();

  /// Name (or path) to the COFF object (`.obj`) associated with this
  /// compilation unit (e.g. `e:\obj.amd64fre\minkernel\ntos\hvl\mp\objfre\amd64\hvlp.obj`)
  std::string module_name() const;

  /// Name of path to the original binary object (COFF, Archive) in which
  /// the compilation unit was located before being linked.
  /// e.g. `e:\obj.amd64fre\minkernel\ntos\hvl\mp\objfre\amd64\hvl.lib`
  std::string object_filename() const;

  /// Iterator over the sources files that compose this compilation unit.
  /// These files also include **headers** (`.h, .hpp`, ...).
  sources_iterator sources() const;

  /// Return an iterator over the function defined in this compilation unit.
  /// If the PDB does not contain or has an empty DBI stream, it returns
  /// an empty iterator.
  function_iterator functions() const;

  private:
  std::unique_ptr<details::CompilationUnit> impl_;
};

}
}
#endif


```

`KDemu/include/LIEF/LIEF/PDB/DebugInfo.hpp`:

```hpp
/* Copyright 2022 - 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PDB_INFO_H
#define LIEF_PDB_INFO_H
#include <memory>
#include <string>

#include "LIEF/iterators.hpp"
#include "LIEF/Abstract/DebugInfo.hpp"

#include "LIEF/PDB/CompilationUnit.hpp"
#include "LIEF/PDB/PublicSymbol.hpp"
#include "LIEF/PDB/Type.hpp"

#include "LIEF/visibility.h"

namespace LIEF {
namespace pdb {
class Function;

/// This class provides an interface for PDB files.
/// One can instantiate this class using LIEF::pdb::load() or
/// LIEF::pdb::DebugInfo::from_file
class LIEF_API DebugInfo : public LIEF::DebugInfo {
  public:
  using LIEF::DebugInfo::DebugInfo;

  /// Iterator over the CompilationUnit
  using compilation_units_it = iterator_range<CompilationUnit::Iterator>;

  /// Iterator over the symbols located in the PDB public symbol stream
  using public_symbols_it = iterator_range<PublicSymbol::Iterator>;

  /// Iterator over the PDB's types
  using types_it = iterator_range<Type::Iterator>;

  /// Instantiate this class from the given PDB file. It returns a nullptr
  /// if the PDB can't be processed.
  static std::unique_ptr<DebugInfo> from_file(const std::string& pdb_path);

  FORMAT format() const override {
    return LIEF::DebugInfo::FORMAT::PDB;
  }

  static bool classof(const LIEF::DebugInfo* info) {
    return info->format() == LIEF::DebugInfo::FORMAT::PDB;
  }

  /// Iterator over the CompilationUnit from the PDB's DBI stream.
  /// CompilationUnit are also named "Module" in the PDB's official documentation
  compilation_units_it compilation_units() const;

  /// Return an iterator over the public symbol stream
  public_symbols_it public_symbols() const;

  /// Return an iterator over the different types registered in this PDB.
  types_it types() const;

  /// Find the type with the given name
  std::unique_ptr<Type> find_type(const std::string& name) const;

  /// Try to find the PublicSymbol from the given name (based on the public symbol stream)
  ///
  /// The function returns a nullptr if the symbol can't be found
  ///
  /// ```cpp
  /// const DebugInfo& info = ...;
  /// if (auto found = info.find_public_symbol("MiSyncSystemPdes")) {
  ///   // FOUND!
  /// }
  /// ```
  std::unique_ptr<PublicSymbol> find_public_symbol(const std::string& name) const;

  /// The number of times the PDB file has been written.
  uint32_t age() const;

  /// Unique identifier of the PDB file
  std::string guid() const;


  ~DebugInfo() override = default;
};


/// Load the PDB file from the given path
inline std::unique_ptr<DebugInfo> load(const std::string& pdb_path) {
  return DebugInfo::from_file(pdb_path);
}

}
}
#endif

```

`KDemu/include/LIEF/LIEF/PDB/Function.hpp`:

```hpp
/* Copyright 2022 - 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PDB_FUNCTION_H
#define LIEF_PDB_FUNCTION_H
#include <memory>
#include <string>

#include "LIEF/visibility.h"
#include "LIEF/debug_loc.hpp"

namespace LIEF {
namespace pdb {

namespace details {
class Function;
class FunctionIt;
}

class LIEF_API Function {
  public:
  class LIEF_API Iterator {
    public:
    using iterator_category = std::forward_iterator_tag;
    using value_type = std::unique_ptr<Function>;
    using difference_type = std::ptrdiff_t;
    using pointer = Function*;
    using reference = Function&;
    using implementation = details::FunctionIt;

    class LIEF_API PointerProxy {
      // Inspired from LLVM's iterator_facade_base
      friend class Iterator;
      public:
      pointer operator->() const { return R.get(); }

      private:
      value_type R;

      template <typename RefT>
      PointerProxy(RefT &&R) : R(std::forward<RefT>(R)) {} // NOLINT(bugprone-forwarding-reference-overload)
    };

    Iterator(const Iterator&);
    Iterator(Iterator&&);
    Iterator(std::unique_ptr<details::FunctionIt> impl);
    ~Iterator();

    friend LIEF_API bool operator==(const Iterator& LHS, const Iterator& RHS);
    friend LIEF_API bool operator!=(const Iterator& LHS, const Iterator& RHS) {
      return !(LHS == RHS);
    }

    Iterator& operator++();

    Iterator operator++(int) {
      Iterator tmp = *static_cast<Iterator*>(this);
      ++*static_cast<Iterator *>(this);
      return tmp;
    }

    std::unique_ptr<Function> operator*() const;

    PointerProxy operator->() const {
      return static_cast<const Iterator*>(this)->operator*();
    }

    private:
    std::unique_ptr<details::FunctionIt> impl_;
  };
  Function(std::unique_ptr<details::Function> impl);
  ~Function();

  /// The name of the function (this name is usually demangled)
  std::string name() const;

  /// The **Relative** Virtual Address of the function
  uint32_t RVA() const;

  /// The size of the function
  uint32_t code_size() const;

  /// The name of the section in which this function is defined
  std::string section_name() const;

  /// Original source code location
  debug_location_t debug_location() const;

  private:
  std::unique_ptr<details::Function> impl_;
};

}
}
#endif


```

`KDemu/include/LIEF/LIEF/PDB/PublicSymbol.hpp`:

```hpp
/* Copyright 2022 - 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PDB_PUBLIC_SYMBOL_H
#define LIEF_PDB_PUBLIC_SYMBOL_H
#include <memory>
#include <string>

#include "LIEF/visibility.h"

namespace LIEF {
namespace pdb {

namespace details {
class PublicSymbol;
class PublicSymbolIt;
}

/// This class provides general information (RVA, name) about a symbol
/// from the PDB's public symbol stream (or Public symbol hash stream)
class LIEF_API PublicSymbol {
  public:
  class LIEF_API Iterator {
    public:
    using iterator_category = std::forward_iterator_tag;
    using value_type = std::unique_ptr<PublicSymbol>;
    using difference_type = std::ptrdiff_t;
    using pointer = PublicSymbol*;
    using reference = PublicSymbol&;
    using implementation = details::PublicSymbolIt;

    class LIEF_API PointerProxy {
      // Inspired from LLVM's iterator_facade_base
      friend class Iterator;
      public:
      pointer operator->() const { return R.get(); }

      private:
      value_type R;

      template <typename RefT>
      PointerProxy(RefT &&R) : R(std::forward<RefT>(R)) {} // NOLINT(bugprone-forwarding-reference-overload)
    };

    Iterator(const Iterator&);
    Iterator(Iterator&&);
    Iterator(std::unique_ptr<details::PublicSymbolIt> impl);
    ~Iterator();

    friend LIEF_API bool operator==(const Iterator& LHS, const Iterator& RHS);

    friend LIEF_API bool operator!=(const Iterator& LHS, const Iterator& RHS) {
      return !(LHS == RHS);
    }

    Iterator& operator++();

    Iterator operator++(int) {
      Iterator tmp = *static_cast<Iterator*>(this);
      ++*static_cast<Iterator *>(this);
      return tmp;
    }

    std::unique_ptr<PublicSymbol> operator*() const;

    PointerProxy operator->() const {
      return static_cast<const Iterator*>(this)->operator*();
    }

    private:
    std::unique_ptr<details::PublicSymbolIt> impl_;
  };
  PublicSymbol(std::unique_ptr<details::PublicSymbol> impl);
  ~PublicSymbol();

  enum class FLAGS : uint32_t {
    NONE     = 0,
    CODE     = 1 << 0,
    FUNCTION = 1 << 1,
    MANAGED  = 1 << 2,
    MSIL     = 1 << 3,
  };

  /// Name of the symbol
  std::string name() const;

  /// Demangled representation of the symbol
  std::string demangled_name() const;

  /// Name of the section in which this symbol is defined (e.g. `.text`).
  ///
  /// This function returns an empty string if the section's name can't be found
  std::string section_name() const;

  /// **Relative** Virtual Address of this symbol.
  ///
  /// This function returns 0 if the RVA can't be computed.
  uint32_t RVA() const;

  private:
  std::unique_ptr<details::PublicSymbol> impl_;
};

}
}
#endif


```

`KDemu/include/LIEF/LIEF/PDB/Type.hpp`:

```hpp
/* Copyright 2022 - 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PDB_TYPE_H
#define LIEF_PDB_TYPE_H
#include <memory>

#include "LIEF/visibility.h"

namespace LIEF {
namespace pdb {

namespace details {
class Type;
class TypeIt;
}

/// This is the base class for any PDB type
class LIEF_API Type {
  public:
  class LIEF_API Iterator {
    public:
    using iterator_category = std::forward_iterator_tag;
    using value_type = std::unique_ptr<Type>;
    using difference_type = std::ptrdiff_t;
    using pointer = Type*;
    using reference = Type&;
    using implementation = details::TypeIt;

    class LIEF_API PointerProxy {
      // Inspired from LLVM's iterator_facade_base
      friend class Iterator;
      public:
      pointer operator->() const { return R.get(); }

      private:
      value_type R;

      template <typename RefT>
      PointerProxy(RefT &&R) : R(std::forward<RefT>(R)) {} // NOLINT(bugprone-forwarding-reference-overload)
    };

    Iterator(const Iterator&);
    Iterator(Iterator&&) noexcept;
    Iterator(std::unique_ptr<details::TypeIt> impl);
    ~Iterator();

    friend LIEF_API bool operator==(const Iterator& LHS, const Iterator& RHS);

    friend LIEF_API bool operator!=(const Iterator& LHS, const Iterator& RHS) {
      return !(LHS == RHS);
    }

    Iterator& operator++();

    Iterator operator++(int) {
      Iterator tmp = *static_cast<Iterator*>(this);
      ++*static_cast<Iterator *>(this);
      return tmp;
    }

    std::unique_ptr<Type> operator*() const;

    PointerProxy operator->() const {
      return static_cast<const Iterator*>(this)->operator*();
    }

    private:
    std::unique_ptr<details::TypeIt> impl_;
  };

  enum class KIND {
    UNKNOWN = 0,
    CLASS,
    POINTER,
    SIMPLE,
    ENUM,
    FUNCTION,
    MODIFIER,
    BITFIELD,
    ARRAY,
    UNION,
    STRUCTURE,
    INTERFACE,
  };

  KIND kind() const;

  template<class T>
  const T* as() const {
    if (T::classof(this)) {
      return static_cast<const T*>(this);
    }
    return nullptr;
  }

  static std::unique_ptr<Type> create(std::unique_ptr<details::Type> impl);

  virtual ~Type();

  protected:
  Type(std::unique_ptr<details::Type> impl);
  std::unique_ptr<details::Type> impl_;
};

}
}
#endif


```

`KDemu/include/LIEF/LIEF/PDB/types.hpp`:

```hpp
/* Copyright 2022 - 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PDB_TYPES_H
#define LIEF_PDB_TYPES_H
#include <LIEF/PDB/Type.hpp>
#include <LIEF/PDB/types/Simple.hpp>
#include <LIEF/PDB/types/Array.hpp>
#include <LIEF/PDB/types/BitField.hpp>
#include <LIEF/PDB/types/ClassLike.hpp>
#include <LIEF/PDB/types/Enum.hpp>
#include <LIEF/PDB/types/Function.hpp>
#include <LIEF/PDB/types/Attribute.hpp>
#include <LIEF/PDB/types/Method.hpp>
#include <LIEF/PDB/types/Modifier.hpp>
#include <LIEF/PDB/types/Pointer.hpp>
#include <LIEF/PDB/types/Union.hpp>
#endif

```

`KDemu/include/LIEF/LIEF/PDB/types/Array.hpp`:

```hpp
/* Copyright 2022 - 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PDB_TYPE_ARRAY_H
#define LIEF_PDB_TYPE_ARRAY_H

#include "LIEF/visibility.h"
#include "LIEF/PDB/Type.hpp"

namespace LIEF {
namespace pdb {
namespace types {

/// This class represents a `LF_ARRAY` PDB type
class LIEF_API Array : public Type {
  public:
  using Type::Type;

  static bool classof(const Type* type) {
    return type->kind() == Type::KIND::ARRAY;
  }

  ~Array() override;
};

}
}
}
#endif



```

`KDemu/include/LIEF/LIEF/PDB/types/Attribute.hpp`:

```hpp
/* Copyright 2022 - 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PDB_TYPE_ATTRIBUTE_H
#define LIEF_PDB_TYPE_ATTRIBUTE_H

#include "LIEF/visibility.h"

#include <string>
#include <memory>

namespace LIEF {
namespace pdb {
class Type;
namespace types {

namespace details {
class Attribute;
class AttributeIt;
}

/// This class represents an attribute (`LF_MEMBER`) in an aggregate (class,
/// struct, union, ...)
class LIEF_API Attribute {
  public:
  class LIEF_API Iterator {
    public:
    using iterator_category = std::forward_iterator_tag;
    using value_type = std::unique_ptr<Attribute>;
    using difference_type = std::ptrdiff_t;
    using pointer = Attribute*;
    using reference = Attribute&;
    using implementation = details::AttributeIt;

    class LIEF_API PointerProxy {
      // Inspired from LLVM's iterator_facade_base
      friend class Iterator;
      public:
      pointer operator->() const { return R.get(); }

      private:
      value_type R;

      template <typename RefT>
      PointerProxy(RefT &&R) : R(std::forward<RefT>(R)) {} // NOLINT(bugprone-forwarding-reference-overload)
    };
    Iterator(const Iterator&);
    Iterator(Iterator&&) noexcept;
    Iterator(std::unique_ptr<details::AttributeIt> impl);
    ~Iterator();

    friend LIEF_API bool operator==(const Iterator& LHS, const Iterator& RHS);
    friend LIEF_API bool operator!=(const Iterator& LHS, const Iterator& RHS) {
      return !(LHS == RHS);
    }

    Iterator& operator++();

    Iterator operator++(int) {
      Iterator tmp = *static_cast<Iterator*>(this);
      ++*static_cast<Iterator *>(this);
      return tmp;
    }

    std::unique_ptr<Attribute> operator*() const;

    PointerProxy operator->() const {
      return static_cast<const Iterator*>(this)->operator*();
    }

    private:
    std::unique_ptr<details::AttributeIt> impl_;
  };
  public:
  Attribute(std::unique_ptr<details::Attribute> impl);

  /// Name of the attribute
  std::string name() const;

  /// Type of this attribute
  std::unique_ptr<Type> type() const;

  /// Offset of this attribute in the aggregate
  uint64_t field_offset() const;

  ~Attribute();

  private:
  std::unique_ptr<details::Attribute> impl_;
};

}
}
}
#endif


```

`KDemu/include/LIEF/LIEF/PDB/types/BitField.hpp`:

```hpp
/* Copyright 2022 - 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PDB_TYPE_BITFIELD_H
#define LIEF_PDB_TYPE_BITFIELD_H

#include "LIEF/visibility.h"
#include "LIEF/PDB/Type.hpp"

namespace LIEF {
namespace pdb {
namespace types {

/// This class represents a `LF_BITFIELD` PDB type
class LIEF_API BitField : public Type {
  public:
  using Type::Type;

  static bool classof(const Type* type) {
    return type->kind() == Type::KIND::BITFIELD;
  }

  ~BitField() override;
};

}
}
}
#endif



```

`KDemu/include/LIEF/LIEF/PDB/types/ClassLike.hpp`:

```hpp
/* Copyright 2022 - 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PDB_TYPE_CLASS_H
#define LIEF_PDB_TYPE_CLASS_H

#include "LIEF/visibility.h"
#include "LIEF/PDB/Type.hpp"
#include "LIEF/PDB/types/Attribute.hpp"
#include "LIEF/PDB/types/Method.hpp"
#include "LIEF/iterators.hpp"

#include <type_traits>

namespace LIEF {
namespace pdb {
namespace types {

/// This class abstracts the following PDB types: `LF_STRUCTURE`, `LF_INTERFACE`, `LF_CLASS`
/// or `LF_UNION`.
class LIEF_API ClassLike : public Type {
  public:
  using Type::Type;

  /// Attributes iterator
  using attributes_iterator = iterator_range<Attribute::Iterator>;

  /// Methods iterator
  using methods_iterator = iterator_range<Method::Iterator>;

  /// Mangled type name
  std::string unique_name() const;

  /// Demangled type name
  std::string name() const;

  /// Iterator over the different attributes defined in this class-like type
  attributes_iterator attributes() const;

  /// Iterator over the different methods implemented in this class-type type
  methods_iterator methods() const;

  /// Size of the the type including all its attributes. This size should match
  /// the `sizeof(...)` this type.
  uint64_t size() const;

  template <class T>
  static bool classof(const T*, typename std::enable_if<std::is_base_of<ClassLike, T>::value>::type* = 0)
  {
    return true;
  }

  ~ClassLike() override;
};


/// Interface for the `LF_STRUCTURE` PDB type
class LIEF_API Structure : public ClassLike {
  public:
  using ClassLike::ClassLike;

  static bool classof(const Type* type) {
    return type->kind() == Type::KIND::STRUCTURE;
  }

  ~Structure() override;
};

/// Interface for the `LF_CLASS` PDB type
class LIEF_API Class : public ClassLike {
  public:
  using ClassLike::ClassLike;

  static bool classof(const Type* type) {
    return type->kind() == Type::KIND::CLASS;
  }

  ~Class() override;
};

/// Interface for the `LF_INTERFACE` PDB type
class LIEF_API Interface : public ClassLike {
  public:
  using ClassLike::ClassLike;

  static bool classof(const Type* type) {
    return type->kind() == Type::KIND::INTERFACE;
  }

  ~Interface() override;
};


}
}
}
#endif



```

`KDemu/include/LIEF/LIEF/PDB/types/Enum.hpp`:

```hpp
/* Copyright 2022 - 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PDB_TYPE_ENUM_H
#define LIEF_PDB_TYPE_ENUM_H

#include "LIEF/visibility.h"
#include "LIEF/PDB/Type.hpp"

namespace LIEF {
namespace pdb {
namespace types {

/// This class represents a `LF_ENUM` PDB type
class LIEF_API Enum : public Type {
  public:
  using Type::Type;

  static bool classof(const Type* type) {
    return type->kind() == Type::KIND::ENUM;
  }

  ~Enum() override;
};

}
}
}
#endif



```

`KDemu/include/LIEF/LIEF/PDB/types/Function.hpp`:

```hpp
/* Copyright 2022 - 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PDB_TYPE_FUNCTION_H
#define LIEF_PDB_TYPE_FUNCTION_H

#include "LIEF/visibility.h"
#include "LIEF/PDB/Type.hpp"

namespace LIEF {
namespace pdb {
namespace types {

/// This class represents a `LF_PROCEDURE` PDB type
class LIEF_API Function : public Type {
  public:
  using Type::Type;

  static bool classof(const Type* type) {
    return type->kind() == Type::KIND::FUNCTION;
  }

  ~Function() override;
};

}
}
}
#endif



```

`KDemu/include/LIEF/LIEF/PDB/types/Method.hpp`:

```hpp
/* Copyright 2022 - 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PDB_TYPE_METHOD_H
#define LIEF_PDB_TYPE_METHOD_H

#include "LIEF/visibility.h"

#include <string>
#include <memory>

namespace LIEF {
namespace pdb {
class Type;
namespace types {

namespace details {
class Method;
class MethodIt;
}

/// This class represents a Method (`LF_ONEMETHOD`) that can be defined in
/// ClassLike PDB type
class LIEF_API Method {
  public:
  class LIEF_API Iterator {
    public:
    using iterator_category = std::forward_iterator_tag;
    using value_type = std::unique_ptr<Method>;
    using difference_type = std::ptrdiff_t;
    using pointer = Method*;
    using reference = Method&;
    using implementation = details::MethodIt;

    class LIEF_API PointerProxy {
      // Inspired from LLVM's iterator_facade_base
      friend class Iterator;
      public:
      pointer operator->() const { return R.get(); }

      private:
      value_type R;

      template <typename RefT>
      PointerProxy(RefT &&R) : R(std::forward<RefT>(R)) {} // NOLINT(bugprone-forwarding-reference-overload)
    };
    Iterator(const Iterator&);
    Iterator(Iterator&&) noexcept;
    Iterator(std::unique_ptr<details::MethodIt> impl);
    ~Iterator();

    friend LIEF_API bool operator==(const Iterator& LHS, const Iterator& RHS);

    friend LIEF_API bool operator!=(const Iterator& LHS, const Iterator& RHS) {
      return !(LHS == RHS);
    }

    Iterator& operator++();

    Iterator operator++(int) {
      Iterator tmp = *static_cast<Iterator*>(this);
      ++*static_cast<Iterator *>(this);
      return tmp;
    }

    std::unique_ptr<Method> operator*() const;

    PointerProxy operator->() const {
      return static_cast<const Iterator*>(this)->operator*();
    }

    private:
    std::unique_ptr<details::MethodIt> impl_;
  };
  public:
  Method(std::unique_ptr<details::Method> impl);

  /// Name of the method
  std::string name() const;

  ~Method();

  private:
  std::unique_ptr<details::Method> impl_;
};

}
}
}
#endif


```

`KDemu/include/LIEF/LIEF/PDB/types/Modifier.hpp`:

```hpp
/* Copyright 2022 - 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PDB_TYPE_MODIFIER_H
#define LIEF_PDB_TYPE_MODIFIER_H

#include "LIEF/visibility.h"
#include "LIEF/PDB/Type.hpp"

namespace LIEF {
namespace pdb {
namespace types {

/// This class represents a `LF_MODIFIER` PDB type
class LIEF_API Modifier : public Type {
  public:
  using Type::Type;

  static bool classof(const Type* type) {
    return type->kind() == Type::KIND::MODIFIER;
  }

  /// Underlying type targeted by this modifier
  std::unique_ptr<Type> underlying_type() const;

  ~Modifier() override;
};

}
}
}
#endif



```

`KDemu/include/LIEF/LIEF/PDB/types/Pointer.hpp`:

```hpp
/* Copyright 2022 - 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PDB_TYPE_POINTER_H
#define LIEF_PDB_TYPE_POINTER_H

#include "LIEF/visibility.h"
#include "LIEF/PDB/Type.hpp"

namespace LIEF {
namespace pdb {
namespace types {

/// This class represents a `LF_POINTER` PDB type
class LIEF_API Pointer : public Type {
  public:
  using Type::Type;

  static bool classof(const Type* type) {
    return type->kind() == Type::KIND::POINTER;
  }

  /// The underlying type pointed by this pointer
  std::unique_ptr<Type> underlying_type() const;

  ~Pointer() override;
};

}
}
}
#endif



```

`KDemu/include/LIEF/LIEF/PDB/types/Simple.hpp`:

```hpp
/* Copyright 2022 - 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PDB_TYPE_SIMPLE_H
#define LIEF_PDB_TYPE_SIMPLE_H

#include "LIEF/visibility.h"
#include "LIEF/PDB/Type.hpp"

namespace LIEF {
namespace pdb {
namespace types {

/// This class represents a primitive types (int, float, ...) which are
/// also named *simple* types in the PDB format.
class LIEF_API Simple : public Type {
  public:
  using Type::Type;

  static bool classof(const Type* type) {
    return type->kind() == Type::KIND::SIMPLE;
  }

  ~Simple() override;
};

}
}
}
#endif



```

`KDemu/include/LIEF/LIEF/PDB/types/Union.hpp`:

```hpp
/* Copyright 2022 - 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PDB_TYPE_UNION_H
#define LIEF_PDB_TYPE_UNION_H

#include "LIEF/visibility.h"
#include "LIEF/PDB/types/ClassLike.hpp"

namespace LIEF {
namespace pdb {
namespace types {

/// This class represents a `LF_UNION` PDB type
class LIEF_API Union : public ClassLike {
  public:
  using ClassLike::ClassLike;

  static bool classof(const Type* type) {
    return type->kind() == Type::KIND::UNION;
  }

  ~Union() override;
};

}
}
}
#endif



```

`KDemu/include/LIEF/LIEF/PE.h`:

```h
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef C_LIEF_PE_H_
#define C_LIEF_PE_H_

#include "LIEF/PE/Binary.h"
#include "LIEF/PE/EnumToString.h"
#endif

```

`KDemu/include/LIEF/LIEF/PE.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_H
#define LIEF_PE_H

#include "LIEF/config.h"

#if defined(LIEF_PE_SUPPORT)

#include "LIEF/PE/Parser.hpp"
#include "LIEF/PE/Section.hpp"
#include "LIEF/PE/TLS.hpp"
#include "LIEF/PE/Export.hpp"
#include "LIEF/PE/ExportEntry.hpp"
#include "LIEF/PE/Import.hpp"
#include "LIEF/PE/ImportEntry.hpp"
#include "LIEF/PE/DelayImport.hpp"
#include "LIEF/PE/DelayImportEntry.hpp"
#include "LIEF/PE/DataDirectory.hpp"
#include "LIEF/PE/ResourcesManager.hpp"
#include "LIEF/PE/ResourceData.hpp"
#include "LIEF/PE/ResourceNode.hpp"
#include "LIEF/PE/ResourceDirectory.hpp"
#include "LIEF/PE/resources/LangCodeItem.hpp"
#include "LIEF/PE/resources/ResourceAccelerator.hpp"
#include "LIEF/PE/resources/ResourceDialog.hpp"
#include "LIEF/PE/resources/ResourceDialogItem.hpp"
#include "LIEF/PE/resources/ResourceFixedFileInfo.hpp"
#include "LIEF/PE/resources/ResourceIcon.hpp"
#include "LIEF/PE/resources/ResourceStringFileInfo.hpp"
#include "LIEF/PE/resources/ResourceStringTable.hpp"
#include "LIEF/PE/resources/ResourceVarFileInfo.hpp"
#include "LIEF/PE/resources/ResourceVersion.hpp"
#include "LIEF/PE/RichEntry.hpp"
#include "LIEF/PE/RichHeader.hpp"
#include "LIEF/PE/Symbol.hpp"
#include "LIEF/PE/Relocation.hpp"
#include "LIEF/PE/RelocationEntry.hpp"
#include "LIEF/PE/Builder.hpp"
#include "LIEF/PE/Binary.hpp"
#include "LIEF/PE/Debug.hpp"
#include "LIEF/PE/DosHeader.hpp"
#include "LIEF/PE/Header.hpp"
#include "LIEF/PE/OptionalHeader.hpp"
#include "LIEF/PE/LoadConfigurations.hpp"
#include "LIEF/PE/AuxiliarySymbol.hpp"
#include "LIEF/PE/CodeIntegrity.hpp"

#include "LIEF/PE/signature/Attribute.hpp"
#include "LIEF/PE/signature/ContentInfo.hpp"
#include "LIEF/PE/signature/GenericContent.hpp"
#include "LIEF/PE/signature/OIDToString.hpp"
#include "LIEF/PE/signature/Signature.hpp"
#include "LIEF/PE/signature/SignerInfo.hpp"
#include "LIEF/PE/signature/SpcIndirectData.hpp"
#include "LIEF/PE/signature/attributes.hpp"
#include "LIEF/PE/signature/types.hpp"
#include "LIEF/PE/signature/x509.hpp"
#include "LIEF/PE/signature/SpcIndirectData.hpp"
#include "LIEF/PE/signature/GenericContent.hpp"
#include "LIEF/PE/signature/PKCS9TSTInfo.hpp"

#include "LIEF/PE/hash.hpp"
#include "LIEF/PE/enums.hpp"
#include "LIEF/PE/EnumToString.hpp"
#include "LIEF/PE/utils.hpp"

#endif

#endif

```

`KDemu/include/LIEF/LIEF/PE/AuxiliarySymbol.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_AUXILIARY_SYMBOL_H
#define LIEF_PE_AUXILIARY_SYMBOL_H

#include "LIEF/visibility.h"
namespace LIEF {
namespace PE {
class LIEF_API AuxiliarySymbol {
};
}
}


#endif


```

`KDemu/include/LIEF/LIEF/PE/Binary.h`:

```h
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef C_LIEF_PE_BINARY_H_
#define C_LIEF_PE_BINARY_H_

#include <stddef.h>

#include "LIEF/visibility.h"

#include "LIEF/PE/enums.h"

#include "LIEF/PE/DosHeader.h"
#include "LIEF/PE/Header.h"
#include "LIEF/PE/OptionalHeader.h"
#include "LIEF/PE/DataDirectory.h"
#include "LIEF/PE/Section.h"
#include "LIEF/PE/Import.h"

#ifdef __cplusplus
extern "C" {
#endif

/** @brief LIEF::PE::Binary C Handler */
struct Pe_Binary_t {
  void*                handler;
  Pe_DosHeader_t       dos_header;
  Pe_Header_t          header;
  Pe_OptionalHeader_t  optional_header;
  Pe_DataDirectory_t** data_directories;
  Pe_Section_t**       sections;
  Pe_Import_t**        imports;
};

typedef struct Pe_Binary_t Pe_Binary_t;

/** Wrapper on LIEF::PE::Parser::parse */
LIEF_API Pe_Binary_t* pe_parse(const char *file);

LIEF_API void pe_binary_destroy(Pe_Binary_t* binary);

#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/include/LIEF/LIEF/PE/Binary.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_BINARY_H
#define LIEF_PE_BINARY_H

#include "LIEF/PE/Header.hpp"
#include "LIEF/PE/OptionalHeader.hpp"
#include "LIEF/PE/DosHeader.hpp"
#include "LIEF/PE/Import.hpp"
#include "LIEF/PE/DelayImport.hpp"
#include "LIEF/PE/Symbol.hpp"
#include "LIEF/PE/DataDirectory.hpp"
#include "LIEF/PE/ResourcesManager.hpp"
#include "LIEF/PE/signature/Signature.hpp"

#include "LIEF/Abstract/Binary.hpp"

#include "LIEF/visibility.h"

namespace LIEF {

//! Namespace related to the LIEF's PE module
namespace PE {
class Builder;
class CodeViewPDB;
class Debug;
class Export;
class LoadConfiguration;
class Parser;
class Relocation;
class ResourceData;
class ResourceDirectory;
class ResourceNode;
class RichHeader;
class TLS;

//! Class which represents a PE binary
//! This is the main interface to manage and modify a PE executable
class LIEF_API Binary : public LIEF::Binary {
  friend class Parser;
  friend class Builder;

  public:
  //! Internal container for storing PE's Section
  using sections_t = std::vector<std::unique_ptr<Section>>;

  //! Iterator that outputs Section& object
  using it_sections = ref_iterator<sections_t&, Section*>;

  //! Iterator that outputs const Section& object
  using it_const_sections = const_ref_iterator<const sections_t&, const Section*>;

  //! Internal container for storing PE's DataDirectory
  using data_directories_t = std::vector<std::unique_ptr<DataDirectory>>;

  //! Iterator that outputs DataDirectory&
  using it_data_directories = ref_iterator<data_directories_t&, DataDirectory*>;

  //! Iterator that outputs const DataDirectory&
  using it_const_data_directories = const_ref_iterator<const data_directories_t&, const DataDirectory*>;

  //! Internal container for storing PE's Relocation
  using relocations_t = std::vector<std::unique_ptr<Relocation>>;

  //! Iterator that outputs Relocation&
  using it_relocations = ref_iterator<relocations_t&, Relocation*>;

  //! Iterator that outputs const Relocation&
  using it_const_relocations = const_ref_iterator<const relocations_t&, const Relocation*>;

  //! Internal container for storing PE's Import
  using imports_t = std::vector<Import>;

  //! Iterator that output Import&
  using it_imports = ref_iterator<imports_t&>;

  //! Iterator that outputs const Import&
  using it_const_imports = const_ref_iterator<const imports_t&>;

  //! Internal container for storing PE's DelayImport
  using delay_imports_t = std::vector<DelayImport>;

  //! Iterator that output DelayImport&
  using it_delay_imports = ref_iterator<delay_imports_t&>;

  //! Iterator that outputs const DelayImport&
  using it_const_delay_imports = const_ref_iterator<const delay_imports_t&>;

  //! Internal container for storing Debug information
  using debug_entries_t = std::vector<std::unique_ptr<Debug>>;

  //! Iterator that outputs Debug&
  using it_debug_entries = ref_iterator<debug_entries_t&, Debug*>;

  //! Iterator that outputs const Debug&
  using it_const_debug_entries = const_ref_iterator<const debug_entries_t&, const Debug*>;

  //! Internal container for storing COFF Symbols
  using symbols_t = std::vector<Symbol>;

  //! Iterator that outputs Symbol&
  using it_symbols = ref_iterator<symbols_t&>;

  //! Iterator that outputs const Symbol&
  using it_const_symbols = const_ref_iterator<const symbols_t&>;

  //! Internal container for storing strings
  using strings_table_t = std::vector<std::string>;

  //! Iterator that outputs std::string&
  using it_strings_table = ref_iterator<strings_table_t&>;

  //! Iterator that outputs const std::string&
  using it_const_strings_table = const_ref_iterator<const strings_table_t&>;

  //! Internal container for storing PE's authenticode Signature
  using signatures_t = std::vector<Signature>;

  //! Iterator that outputs Signature&
  using it_signatures = ref_iterator<signatures_t&>;

  //! Iterator that outputs const Signature&
  using it_const_signatures = const_ref_iterator<const signatures_t&>;

  Binary(PE_TYPE type);

  ~Binary() override;

  //! Return `PE32` or `PE32+`
  PE_TYPE type() const {
    return type_;
  }

  //! Convert a Relative Virtual Address into an offset
  //!
  //! The conversion is performed by looking for the section that
  //! encompasses the provided RVA.
  uint64_t rva_to_offset(uint64_t RVA) const;

  //! Convert the **absolute** virtual address into an offset.
  //! @see rva_to_offset
  uint64_t va_to_offset(uint64_t VA) const;

  //! Convert the given offset into a virtual address.
  //!
  //! @param[in] offset The offset to convert.
  //! @param[in] slide  If not 0, it will replace the default base address (if any)
  result<uint64_t> offset_to_virtual_address(uint64_t offset, uint64_t slide = 0) const override;

  //! Return binary's imagebase. ``0`` if not relevant
  //!
  //! The value is the same as those returned by OptionalHeader::imagebase
  uint64_t imagebase() const override {
    return optional_header().imagebase();
  }

  //! Find the section associated that encompasses the given offset.
  //!
  //! If no section can be found, return a nullptr
  Section* section_from_offset(uint64_t offset);
  const Section* section_from_offset(uint64_t offset) const;

  //! Find the section associated that encompasses the given RVA.
  //!
  //! If no section can be found, return a nullptr
  Section* section_from_rva(uint64_t virtual_address);
  const Section* section_from_rva(uint64_t virtual_address) const;

  //! Return an iterator over the PE's Section
  it_sections sections() {
    return sections_;
  }

  it_const_sections sections() const {
    return sections_;
  }

  //! Return a reference to the PE::DosHeader object
  DosHeader& dos_header() {
    return dos_header_;
  }

  const DosHeader& dos_header() const {
    return dos_header_;
  }

  //! Return a reference to the PE::Header object
  Header& header() {
    return header_;
  }

  const Header& header() const {
    return header_;
  }

  //! Header that follows the header(). It is named optional from the COFF
  //! specfication but it is mandatory in a PE file.
  OptionalHeader& optional_header() {
    return optional_header_;
  }

  const OptionalHeader& optional_header() const {
    return optional_header_;
  }

  //! Re-compute the value of OptionalHeader::checksum.
  //! If both values do not match, it could mean that the binary has been modified
  //! after the compilation.
  //!
  //! This value is computed by LIEF for the current binary object.
  uint32_t compute_checksum() const;

  //! Compute the binary's virtual size.
  //! It should match OptionalHeader::sizeof_image
  uint64_t virtual_size() const;

  //! Compute the size of all the headers
  uint32_t sizeof_headers() const;

  //! Return a reference to the TLS object
  TLS* tls() {
    return tls_.get();
  }

  const TLS* tls() const {
    return tls_.get();
  }

  //! Set a TLS object in the current Binary
  void tls(const TLS& tls);

  //! Check if the current binary has a TLS object
  bool has_tls() const {
    return tls_ != nullptr;
  }

  //! Check if the current binary contains imports
  //!
  //! @see Import
  bool has_imports() const {
    return !imports_.empty();
  }

  //! Check if the current binary contains signatures
  //!
  //! @see signatures
  bool has_signatures() const {
    return !signatures_.empty();
  }

  //! Check if the current binary has exports.
  //!
  //! @see Export
  bool has_exports() const {
    return export_ != nullptr;
  }

  //! Check if the current binary has resources
  bool has_resources() const {
    return resources_ != nullptr;
  }

  //! Check if the current binary has exceptions
  bool has_exceptions() const;

  //! Check if the current binary has relocations
  //!
  //! @see Relocation
  bool has_relocations() const {
    return !relocations_.empty();
  }

  //! Check if the current binary contains debug information
  bool has_debug() const {
    return !debug_.empty();
  }

  //! Check if the current binary has a load configuration
  bool has_configuration() const {
    return load_configuration_ != nullptr;
  }

  //! Check if the current binary is *reproducible build*, replacing timestamps by a compile hash.
  //!
  //! @see Repro
  bool is_reproducible_build() const;

  //! Return an iterator over the Signature object(s) if the binary is signed
  it_const_signatures signatures() const {
    return signatures_;
  }

  it_signatures signatures() {
    return signatures_;
  }

  //! Verify the binary against the embedded signature(s) (if any)
  //! First, it checks that the embedded signatures are correct (c.f. Signature::check)
  //! and then, it checks that the authentihash matches ContentInfo::digest
  //!
  //! One can tweak the verification process with the Signature::VERIFICATION_CHECKS flags
  //!
  //! @see LIEF::PE::Signature::check
  Signature::VERIFICATION_FLAGS verify_signature(
      Signature::VERIFICATION_CHECKS checks = Signature::VERIFICATION_CHECKS::DEFAULT) const;

  //! Verify the binary with the Signature object provided in the first parameter.
  //! It can be used to verify a detached signature:
  //!
  //! \code{.cpp}
  //! result<Signature> detached = LIEF::PE::SignatureParser::parse("sig.pkcs7")
  //! if (detached) {
  //!   binary->verify_signature(detached.value());
  //! }
  //! \endcode
  Signature::VERIFICATION_FLAGS verify_signature(const Signature& sig,
      Signature::VERIFICATION_CHECKS checks = Signature::VERIFICATION_CHECKS::DEFAULT) const;

  //! Compute the authentihash according to the algorithm provided in the first
  //! parameter
  std::vector<uint8_t> authentihash(ALGORITHMS algo) const;

  //! Try to predict the RVA of the function `function` in the import library `library`
  //!
  //! @warning
  //! The value could be chang if imports change
  //!
  //! @note
  //! It should be used with:
  //! LIEF::PE::Builder::build_imports set to ``true``
  //!
  //! @param[in] library  Library name in which the function is located
  //! @param[in] function Function name
  //! @return The address of the function (``IAT``)  in the new import table
  uint32_t predict_function_rva(const std::string& library, const std::string& function);

  //! Return the Export object
  Export* get_export() {
    return export_.get();
  }

  const Export* get_export() const {
    return export_.get();
  }

  //! Return binary Symbols
  std::vector<Symbol>& symbols() {
    return symbols_;
  }

  const std::vector<Symbol>& symbols() const {
    return symbols_;
  }

  //! Return resources as a tree or a nullptr if there is no resources
  ResourceNode* resources() {
    return resources_.get();
  }

  const ResourceNode* resources() const {
    return resources_.get();
  }

  //! Set a new resource tree
  void set_resources(const ResourceDirectory& resource);

  //! Set a new resource tree
  void set_resources(const ResourceData& resource);

  //! Return the ResourcesManager (class to manage resources more easily than the tree one)
  result<ResourcesManager> resources_manager() const;

  //! Return binary's section from its name.
  //! If the secion can't be found, return a nullptr
  //!
  //! @param[in] name Name of the Section
  Section* get_section(const std::string& name);
  const Section* get_section(const std::string& name) const;

  //! Return the section associated with import table or a
  //! nullptr if the binary does not have an import table
  const Section* import_section() const;
  Section*       import_section();

  //! Delete the section with the given name
  //!
  //! @param[in] name    Name of section to delete
  //! @param[in] clear   if ``true`` clear the section's content with 0
  //!                    before removing (default: ``false``)
  void remove_section(const std::string& name, bool clear = false) override;

  //! Remove the given section
  //!
  //! @see remove_section
  void remove(const Section& section, bool clear = false);

  //! Add a section to the binary and return the section added.
  Section* add_section(const Section& section,
                       PE_SECTION_TYPES type = PE_SECTION_TYPES::UNKNOWN);

  //! Return an iterator over the PE's Relocation
  it_relocations relocations() {
    return relocations_;
  }

  it_const_relocations relocations() const {
    return relocations_;
  }

  //! Add a PE::Relocation
  Relocation& add_relocation(const Relocation& relocation);

  //! Remove all the relocations
  void remove_all_relocations();

  //! Return an iterator over the DataDirectory present in the Binary
  it_data_directories data_directories() {
    return data_directories_;
  }

  it_const_data_directories data_directories() const {
    return data_directories_;
  }

  //! Return the DataDirectory with the given type (or index)
  DataDirectory* data_directory(DataDirectory::TYPES type);
  const DataDirectory* data_directory(DataDirectory::TYPES type) const;

  //! Check if the current binary has the given DataDirectory::TYPES
  bool has(DataDirectory::TYPES type) const {
    return data_directory(type) != nullptr;
  }

  //! Return an iterator over the Debug entries
  it_debug_entries debug() {
    return debug_;
  }

  it_const_debug_entries debug() const {
    return debug_;
  }

  //! Return the CodeViewPDB object if present
  const CodeViewPDB* codeview_pdb() const;

  //! Retrun the LoadConfiguration object or a nullptr
  //! if the binary does not use the LoadConfiguration
  const LoadConfiguration* load_configuration() const {
    return load_configuration_.get();
  }

  LoadConfiguration* load_configuration() {
    return load_configuration_.get();
  }

  //! Return the overlay content
  span<const uint8_t> overlay() const {
    return overlay_;
  }

  span<uint8_t> overlay() {
    return overlay_;
  }

  //! Return the original overlay offset
  uint64_t overlay_offset() const {
    return overlay_offset_;
  }

  //! Return the DOS stub content
  span<const uint8_t> dos_stub() const {
    return dos_stub_;
  }

  span<uint8_t> dos_stub() {
    return dos_stub_;
  }

  //! Update the DOS stub content
  void dos_stub(std::vector<uint8_t> content) {
    dos_stub_ = std::move(content);
  }

  // Rich Header
  // -----------

  //! Return a reference to the RichHeader object
  RichHeader* rich_header() {
    return rich_header_.get();
  }

  const RichHeader* rich_header() const {
    return rich_header_.get();
  }

  //! Set a RichHeader object in the current Binary
  void rich_header(const RichHeader& rich_header);

  //! Check if the current binary has a RichHeader object
  bool has_rich_header() const {
    return rich_header_ != nullptr;
  }

  //! Return an iterator over the binary imports
  it_imports imports() {
    return imports_;
  }

  it_const_imports imports() const {
    return imports_;
  }

  //! Returns the PE::Import from the given name. If it can't be
  //! found, return a nullptr
  //!
  //! @param[in] import_name Name of the import
  Import* get_import(const std::string& import_name);
  const Import* get_import(const std::string& import_name) const;

  //! ``True`` if the binary imports the given library name
  //!
  //! @param[in] import_name Name of the import
  bool has_import(const std::string& import_name) const {
    return get_import(import_name) != nullptr;
  }

  //! Check if the current binary contains delay imports
  //!
  //! @see DelayImport
  //! @see has_import
  bool has_delay_imports() const {
    return !delay_imports_.empty();
  }

  //! Return an iterator over the binary's delay imports
  it_delay_imports delay_imports() {
    return delay_imports_;
  }

  it_const_delay_imports delay_imports() const {
    return delay_imports_;
  }

  //! Returns the PE::DelayImport from the given name. If it can't be
  //! found, return a nullptr
  //!
  //! @param[in] import_name Name of the delay import
  DelayImport* get_delay_import(const std::string& import_name);
  const DelayImport* get_delay_import(const std::string& import_name) const;


  //! ``True`` if the binary delay-imports the given library name
  //!
  //! @param[in] import_name Name of the delay import
  bool has_delay_import(const std::string& import_name) const {
    return get_delay_import(import_name) != nullptr;
  }


  //! Add the function @p function of the library @p library.
  //! If the function fails, it returns a nullptr
  //!
  //! @param[in] library  Library name of the function
  //! @param[in] function Function's name from the library to import
  ImportEntry* add_import_function(const std::string& library, const std::string& function);

  //! Add an imported library (i.e. `DLL`) to the binary
  Import& add_library(const std::string& name) {
    imports_.emplace_back(name);
    return imports_.back();
  }

  //! Remove the library with the given `name`
  void remove_library(const std::string& name);

  //! Remove all libraries in the binary
  void remove_all_libraries() {
    imports_.clear();
  }

  //! Reconstruct the binary object and write the raw PE in `filename`
  //!
  //! Rebuild a PE binary from the current Binary object.
  //! When rebuilding, import table and relocations are not rebuilt.
  void write(const std::string& filename) override;

  //! Reconstruct the binary object and write the raw PE in `os` stream
  //!
  //! Rebuild a PE binary from the current Binary object.
  //! When rebuilding, import table and relocations are not rebuilt.
  void write(std::ostream& os) override;

  void accept(Visitor& visitor) const override;

  //! Patch the content at virtual address @p address with @p patch_value
  //!
  //! @param[in] address      Address to patch
  //! @param[in] patch_value  Patch to apply
  //! @param[in] addr_type    Type of the Virtual address: VA or RVA. Default: Auto
  void patch_address(uint64_t address, const std::vector<uint8_t>& patch_value,
                     LIEF::Binary::VA_TYPES addr_type = LIEF::Binary::VA_TYPES::AUTO) override;


  //! Patch the address with the given value
  //!
  //! @param[in] address        Address to patch
  //! @param[in] patch_value    Patch to apply
  //! @param[in] size           Size of the value in **bytes** (1, 2, ... 8)
  //! @param[in] addr_type      Type of the Virtual address: VA or RVA. Default: Auto
  void patch_address(uint64_t address, uint64_t patch_value, size_t size = sizeof(uint64_t),
                     LIEF::Binary::VA_TYPES addr_type = LIEF::Binary::VA_TYPES::AUTO) override;

  //! Return the content located at the provided virtual address
  //!
  //! @param[in] virtual_address    Virtual address of the data to retrieve
  //! @param[in] size               Size in bytes of the data to retrieve
  //! @param[in] addr_type          Type of the Virtual address: VA or RVA. Default: Auto
  span<const uint8_t> get_content_from_virtual_address(
      uint64_t virtual_address, uint64_t size,
      Binary::VA_TYPES addr_type = Binary::VA_TYPES::AUTO) const override;

  //! Return the binary's entrypoint (It is the same value as OptionalHeader::addressof_entrypoint
  uint64_t entrypoint() const override {
    return optional_header_.imagebase() + optional_header_.addressof_entrypoint();
  }

  //! Check if the binary is position independent
  bool is_pie() const override {
    return optional_header_.has(OptionalHeader::DLL_CHARACTERISTICS::DYNAMIC_BASE);
  }

  //! Check if the binary uses ``NX`` protection
  bool has_nx() const override {
    return optional_header_.has(OptionalHeader::DLL_CHARACTERISTICS::NX_COMPAT);
  }

  //! Return the list of the binary constructors.
  //!
  //! In a PE file, we consider a constructors as a callback in the TLS object
  LIEF::Binary::functions_t ctor_functions() const override;

  //! **All** functions found in the binary
  LIEF::Binary::functions_t functions() const;

  //! Functions found in the Exception table directory
  LIEF::Binary::functions_t exception_functions() const;

  static bool classof(const LIEF::Binary* bin) {
    return bin->format() == Binary::FORMATS::PE;
  }

  std::ostream& print(std::ostream& os) const override;

  private:
  Binary();

  //! Make space between the last section header and the beginning of the
  //! content of first section
  void make_space_for_new_section();

  //! Return binary's symbols as LIEF::Symbol
  LIEF::Binary::symbols_t get_abstract_symbols() override;

  LIEF::Header get_abstract_header() const override;

  //! Return binary's section as LIEF::Section
  LIEF::Binary::sections_t get_abstract_sections() override;

  LIEF::Binary::relocations_t get_abstract_relocations() override;

  LIEF::Binary::functions_t get_abstract_exported_functions() const override;
  LIEF::Binary::functions_t get_abstract_imported_functions() const override;
  std::vector<std::string> get_abstract_imported_libraries() const override;

  void update_lookup_address_table_offset();
  void update_iat();

  PE_TYPE        type_ = PE_TYPE::PE32_PLUS;
  DosHeader      dos_header_;
  Header         header_;
  OptionalHeader optional_header_;

  int32_t available_sections_space_ = 0;

  signatures_t signatures_;
  sections_t           sections_;
  data_directories_t   data_directories_;
  symbols_t            symbols_;
  strings_table_t      strings_table_;
  relocations_t        relocations_;
  imports_t            imports_;
  delay_imports_t      delay_imports_;
  debug_entries_t      debug_;
  uint64_t overlay_offset_ = 0;
  std::vector<uint8_t> overlay_;
  std::vector<uint8_t> dos_stub_;
  std::vector<uint8_t> section_offset_padding_;

  std::unique_ptr<RichHeader> rich_header_;
  std::unique_ptr<Export> export_;
  std::unique_ptr<ResourceNode> resources_;
  std::unique_ptr<TLS> tls_;
  std::unique_ptr<LoadConfiguration> load_configuration_;
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/PE/Builder.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_BUILDER_H
#define LIEF_PE_BUILDER_H

#include <cstring>
#include <string>
#include <vector>
#include <iterator>
#include <ostream>
#include <sstream>
#include <algorithm>
#include <iomanip>

#include "LIEF/visibility.h"
#include "LIEF/utils.hpp"
#include "LIEF/iostream.hpp"

#include "LIEF/errors.hpp"

namespace LIEF {
namespace PE {
class Binary;
class ResourceNode;
class DosHeader;
class Header;
class OptionalHeader;
class DataDirectory;
class Section;

//! Class that is used to rebuild a raw PE binary from a PE::Binary object
class LIEF_API Builder {
  public:

  Builder() = delete;
  Builder(Binary& binary);
  ~Builder();

  //! Perform the build process
  ok_error_t build();

  //! @brief Construct a ``jmp [address] @ from``.
  //!
  //! It is used when patching import table
  template<typename PE_T>
  static std::vector<uint8_t> build_jmp(uint64_t from, uint64_t address);


  //! @brief Construct a ``jmp far address @ from``.
  //!
  //! It is used for hooking
  template<typename PE_T>
  static std::vector<uint8_t> build_jmp_hook(uint64_t from, uint64_t address);

  //! @brief Rebuild the import table in new section
  Builder& build_imports(bool flag = true);

  //! @brief Patch the original import table in order to
  //! redirect functions to the new import table.
  //!
  //! This setting should be used with LIEF::PE::Builder::build_imports set to ``true``
  Builder& patch_imports(bool flag = true);

  //! @brief Rebuild the relocation table in another section
  Builder& build_relocations(bool flag = true);

  //! @brief Rebuild TLS object in another section
  Builder& build_tls(bool flag = true);

  //! @brief Rebuid the resources in another section
  Builder& build_resources(bool flag);

  //! @brief Rebuild the binary's overlay
  Builder& build_overlay(bool flag);

  //! @brief Rebuild the DOS stub content
  Builder& build_dos_stub(bool flag);

  //! @brief Return the build result
  const std::vector<uint8_t>& get_build();

  //! @brief Write the build result into the ``output`` file
  void write(const std::string& filename) const;

  //! @brief Write the build result into the ``os`` stream
  void write(std::ostream& os) const;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const Builder& b);

  ok_error_t build(const DosHeader& dos_header);
  ok_error_t build(const Header& bHeader);
  ok_error_t build(const OptionalHeader& optional_header);
  ok_error_t build(const DataDirectory& data_directory);
  ok_error_t build(const Section& section);

  protected:
  template<typename PE_T>
  ok_error_t build_optional_header(const OptionalHeader& optional_header);

  //! @brief Rebuild Import Table
  // TODO: Bug with x86
  template<typename PE_T>
  void build_import_table();

  template<typename PE_T>
  ok_error_t build_tls();

  ok_error_t build_relocation();
  ok_error_t build_resources();
  ok_error_t build_overlay();
  ok_error_t build_dos_stub();

  ok_error_t compute_resources_size(ResourceNode& node, uint32_t *header_size,
                              uint32_t *data_size, uint32_t *name_size);

  ok_error_t construct_resources(ResourceNode& node, std::vector<uint8_t>* content,
                           uint32_t* offset_header, uint32_t* offset_data, uint32_t* offset_name,
                           uint32_t base_rva, uint32_t depth);


  mutable vector_iostream ios_;
  Binary* binary_ = nullptr;

  bool build_imports_ = false;
  bool patch_imports_ = false;
  bool build_relocations_ = false;
  bool build_tls_ = false;
  bool build_resources_ = false;
  bool build_overlay_ = true;
  bool build_dos_stub_ = true;

};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/PE/CodeIntegrity.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_CODE_INTEGRITY_H
#define LIEF_PE_CODE_INTEGRITY_H
#include <ostream>
#include <cstdint>

#include "LIEF/Object.hpp"
#include "LIEF/visibility.h"

namespace LIEF {
namespace PE {
namespace details {
struct pe_code_integrity;
}

class LIEF_API CodeIntegrity : public Object {
  public:
  CodeIntegrity() = default;
  CodeIntegrity(const details::pe_code_integrity& header);
  ~CodeIntegrity() override = default;

  CodeIntegrity& operator=(const CodeIntegrity&) = default;
  CodeIntegrity(const CodeIntegrity&) = default;

  //! Flags to indicate if CI information is available, etc.
  uint16_t flags() const {
    return flags_;
  }

  //! 0xFFFF means not available
  uint16_t catalog() const {
    return catalog_;
  }
  uint32_t catalog_offset() const {
    return catalog_offset_;
  }

  //! Additional bitmask to be defined later
  uint32_t reserved() const {
    return reserved_;
  }

  void flags(uint16_t flags) {
    flags_ = flags;
  }
  void catalog(uint16_t catalog) {
    catalog_ = catalog;
  }
  void catalog_offset(uint32_t catalog_offset) {
    catalog_offset_ = catalog_offset;
  }
  void reserved(uint32_t reserved) {
    reserved_ = reserved;
  }

  void accept(Visitor& visitor) const override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const CodeIntegrity& entry);

  private:
  uint16_t flags_ = 0;
  uint16_t catalog_ = 0;

  uint32_t catalog_offset_ = 0;
  uint32_t reserved_ = 0;

};
}
}

#endif

```

`KDemu/include/LIEF/LIEF/PE/DataDirectory.h`:

```h
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License",;
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef C_LIEF_PE_DATA_DIRECTORY_H
#define C_LIEF_PE_DATA_DIRECTORY_H

#include <inttypes.h>

#include "LIEF/PE/enums.h"

#ifdef __cplusplus
extern "C" {
#endif


enum LIEF_PE_DATA_DIRECTORY {
  LIEF_PE_DATA_DIR_EXPORT_TABLE = 0,
  LIEF_PE_DATA_DIR_IMPORT_TABLE,
  LIEF_PE_DATA_DIR_RESOURCE_TABLE,
  LIEF_PE_DATA_DIR_EXCEPTION_TABLE,
  LIEF_PE_DATA_DIR_CERTIFICATE_TABLE,
  LIEF_PE_DATA_DIR_BASE_RELOCATION_TABLE,
  LIEF_PE_DATA_DIR_DEBUG,
  LIEF_PE_DATA_DIR_ARCHITECTURE,
  LIEF_PE_DATA_DIR_GLOBAL_PTR,
  LIEF_PE_DATA_DIR_TLS_TABLE,
  LIEF_PE_DATA_DIR_LOAD_CONFIG_TABLE,
  LIEF_PE_DATA_DIR_BOUND_IMPORT,
  LIEF_PE_DATA_DIR_IAT,
  LIEF_PE_DATA_DIR_DELAY_IMPORT_DESCRIPTOR,
  LIEF_PE_DATA_DIR_CLR_RUNTIME_HEADER,
  LIEF_PE_DATA_DIR_RESERVED,

  LIEF_PE_DATA_DIR_NONE,
};

struct Pe_DataDirectory_t {
  uint32_t rva;
  uint32_t size;
};

typedef struct Pe_DataDirectory_t Pe_DataDirectory_t;


#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/include/LIEF/LIEF/PE/DataDirectory.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_DATADIRECTORY_H
#define LIEF_PE_DATADIRECTORY_H

#include <cstdint>
#include <ostream>

#include "LIEF/Object.hpp"
#include "LIEF/visibility.h"

namespace LIEF {
namespace PE {

class Builder;
class Parser;
class Binary;
class Section;

namespace details {
struct pe_data_directory;
}

//! Class that represents a PE data directory entry
class LIEF_API DataDirectory : public Object {

  friend class Builder;
  friend class Parser;
  friend class Binary;

  public:
  static constexpr size_t DEFAULT_NB = 16;

  enum class TYPES: uint32_t  {
    EXPORT_TABLE = 0,
    IMPORT_TABLE,
    RESOURCE_TABLE,
    EXCEPTION_TABLE,
    CERTIFICATE_TABLE,
    BASE_RELOCATION_TABLE,
    DEBUG_DIR,
    ARCHITECTURE,
    GLOBAL_PTR,
    TLS_TABLE,
    LOAD_CONFIG_TABLE,
    BOUND_IMPORT,
    IAT,
    DELAY_IMPORT_DESCRIPTOR,
    CLR_RUNTIME_HEADER,
    RESERVED,

    UNKNOWN,
  };
  DataDirectory() = default;
  DataDirectory(TYPES type) :
    type_{type}
  {}

  DataDirectory(const details::pe_data_directory& header, TYPES type);

  DataDirectory(const DataDirectory& other) = default;
  DataDirectory& operator=(const DataDirectory& other) = default;

  DataDirectory(DataDirectory&& other) noexcept = default;
  DataDirectory& operator=(DataDirectory&& other) noexcept = default;

  ~DataDirectory() override = default;

  //! The relative virtual address of the content of this data
  //! directory
  uint32_t RVA() const {
    return rva_;
  }

  //! The size of the content
  uint32_t size() const {
    return size_;
  }

  //! Check if the content of this data directory is associated
  //! with a PE Cection
  bool has_section() const {
    return section_ != nullptr;
  }

  //! Section associated with the DataDirectory
  Section* section() {
    return section_;
  }
  const Section* section() const {
    return section_;
  }

  //! Type of the data directory
  TYPES type() const {
    return type_;
  }

  void size(uint32_t size) {
    size_ = size;
  }

  void RVA(uint32_t rva) {
    rva_ = rva;
  }

  void accept(Visitor& visitor) const override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const DataDirectory& entry);

  private:
  uint32_t rva_ = 0;
  uint32_t size_ = 0;
  TYPES type_ = TYPES::UNKNOWN;
  Section* section_ = nullptr;
};

LIEF_API const char* to_string(DataDirectory::TYPES e);

}
}

#endif /* LIEF_PE_DATADIRECTORY_H */

```

`KDemu/include/LIEF/LIEF/PE/Debug.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_DEBUG_INC_H
#define LIEF_PE_DEBUG_INC_H
#include <LIEF/PE/debug/Debug.hpp>
#include <LIEF/PE/debug/CodeView.hpp>
#include <LIEF/PE/debug/Pogo.hpp>
#include <LIEF/PE/debug/PogoEntry.hpp>
#include <LIEF/PE/debug/Repro.hpp>
#include <LIEF/PE/debug/CodeViewPDB.hpp>
#endif

```

`KDemu/include/LIEF/LIEF/PE/DelayImport.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_DELAY_IMPORT_H
#define LIEF_PE_DELAY_IMPORT_H

#include <string>
#include <ostream>

#include "LIEF/Object.hpp"
#include "LIEF/visibility.h"
#include "LIEF/iterators.hpp"

#include "LIEF/PE/DelayImportEntry.hpp"

namespace LIEF {
namespace PE {

namespace details {
struct delay_imports;
}

//! Class that represents a PE delayed import.
class LIEF_API DelayImport : public Object {

  friend class Parser;
  friend class Builder;

  public:
  using entries_t        = std::vector<DelayImportEntry>;
  using it_entries       = ref_iterator<entries_t&>;
  using it_const_entries = const_ref_iterator<const entries_t&>;

  DelayImport() = default;
  DelayImport(const details::delay_imports& import, PE_TYPE type);
  DelayImport(std::string name) :
    name_(std::move(name))
  {}

  ~DelayImport() override = default;

  DelayImport(const DelayImport&) = default;
  DelayImport& operator=(const DelayImport&) = default;

  DelayImport(DelayImport&&) noexcept = default;
  DelayImport& operator=(DelayImport&&) noexcept = default;

  void swap(DelayImport& other);

  //! According to the official PE specifications,
  //! this value is reserved and should be set to 0.
  uint32_t attribute() const {
    return attribute_;
  }
  void attribute(uint32_t hdl) {
    attribute_ = hdl;
  }

  //! Return the library's name (e.g. `kernel32.dll`)
  const std::string& name() const {
    return name_;
  }
  void name(std::string name) {
    name_ = std::move(name);
  }

  //! The RVA of the module handle (in the ``.data`` section)
  //! It is used for storage by the routine that is supplied to
  //! manage delay-loading.
  uint32_t handle() const {
    return handle_;
  }
  void handle(uint32_t hdl) {
    handle_ = hdl;
  }

  //! RVA of the delay-load import address table.
  uint32_t iat() const {
    return iat_;
  }
  void iat(uint32_t iat) {
    iat_ = iat;
  }

  //! RVA of the delay-load import names table.
  //! The content of this table has the layout as the Import lookup table
  uint32_t names_table() const {
    return names_table_;
  }
  void names_table(uint32_t value) {
    names_table_ = value;
  }

  //! RVA of the **bound** delay-load import address table or 0
  //! if the table does not exist.
  uint32_t biat() const {
    return bound_iat_;
  }
  void biat(uint32_t value) {
    bound_iat_ = value;
  }

  //! RVA of the **unload** delay-load import address table or 0
  //! if the table does not exist.
  //!
  //! According to the PE specifications, this table is an
  //! exact copy of the delay import address table that can be
  //! used to to restore the original IAT the case of unloading.
  uint32_t uiat() const {
    return unload_iat_;
  }
  void uiat(uint32_t value) {
    unload_iat_ = value;
  }

  //! The timestamp of the DLL to which this image has been bound.
  uint32_t timestamp() const {
    return timestamp_;
  }
  void timestamp(uint32_t value) {
    timestamp_ = value;
  }

  //! Iterator over the DelayImport's entries (DelayImportEntry)
  it_entries entries() {
    return entries_;
  }

  //! Iterator over the DelayImport's entries (DelayImportEntry)
  it_const_entries entries() const {
    return entries_;
  }

  void accept(Visitor& visitor) const override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const DelayImport& entry);

  private:
  uint32_t attribute_ = 0;
  std::string name_;
  uint32_t handle_ = 0;
  uint32_t iat_ = 0;
  uint32_t names_table_ = 0;
  uint32_t bound_iat_ = 0;
  uint32_t unload_iat_ = 0;
  uint32_t timestamp_ = 0;
  entries_t entries_;

  PE_TYPE type_ = PE_TYPE::PE32;
};

}
}

#endif

```

`KDemu/include/LIEF/LIEF/PE/DelayImportEntry.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_DELAY_IMPORT_ENTRY_H
#define LIEF_PE_DELAY_IMPORT_ENTRY_H
#include <ostream>

#include "LIEF/Object.hpp"
#include "LIEF/visibility.h"
#include "LIEF/Abstract/Symbol.hpp"

#include "LIEF/PE/enums.hpp"

namespace LIEF {
namespace PE {
class Parser;
class Builder;

//! Class that represents an entry (i.e. an import) in the delay import table (DelayImport).
//!
//! It extends the LIEF::Symbol generic class that exposes the LIEF::Symbol::name and
//! LIEF::Symbol::value API.
//!
//! The meaning of LIEF::Symbol::value for this PE object is the address (as an RVA) in the IAT
//! where the resolution should take place.
class LIEF_API DelayImportEntry : public LIEF::Symbol {
  friend class Parser;
  friend class Builder;

  public:
  DelayImportEntry() = default;
  DelayImportEntry(uint64_t data, PE_TYPE type) :
    data_(data),
    type_(type)
  {}

  DelayImportEntry(const DelayImportEntry&) = default;
  DelayImportEntry& operator=(const DelayImportEntry&) = default;

  DelayImportEntry(DelayImportEntry&&) noexcept = default;
  DelayImportEntry& operator=(DelayImportEntry&&) noexcept = default;

  ~DelayImportEntry() override = default;

  //! `True` if it is an import by ordinal
  bool is_ordinal() const;

  //! The ordinal value
  uint16_t ordinal() const {
    static constexpr auto MASK = 0xFFFF;
    return data_ & MASK;
  }

  //! @see DelayImportEntry::data
  uint64_t hint_name_rva() const {
    return data();
  }

  //! Index into the Export::entries that is used to speed-up
  //! the symbol resolution.
  uint16_t hint() const {
    return hint_;
  }

  //! Value of the current entry in the Import Address Table.
  uint64_t iat_value() const {
    return iat_value_;
  }

  //! Raw value
  uint64_t data() const {
    return data_;
  }

  void data(uint64_t data) {
    data_ = data;
  }

  void accept(Visitor& visitor) const override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const DelayImportEntry& entry);

  private:
  uint64_t data_ = 0;
  uint16_t hint_ = 0;
  uint64_t iat_offset_ = 0;
  uint64_t iat_value_ = 0;
  PE_TYPE  type_ = PE_TYPE::PE32_PLUS;
};

}
}

#endif /* LIEF_PE_DELAY_IMPORT_ENTRY_H */

```

`KDemu/include/LIEF/LIEF/PE/DosHeader.h`:

```h
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef C_LIEF_PE_DOS_HEADER_H_
#define C_LIEF_PE_DOS_HEADER_H_
#include <inttypes.h>

#include "LIEF/ELF/enums.h"

#ifdef __cplusplus
extern "C" {
#endif

struct Pe_DosHeader_t {
  uint16_t magic ;
  uint16_t used_bytes_in_last_page;
  uint16_t file_size_in_pages;
  uint16_t numberof_relocation;
  uint16_t header_size_in_paragraphs;
  uint16_t minimum_extra_paragraphs;
  uint16_t maximum_extra_paragraphs;
  uint16_t initial_relative_ss;
  uint16_t initial_sp;
  uint16_t checksum;
  uint16_t initial_ip;
  uint16_t initial_relative_cs;
  uint16_t addressof_relocation_table;
  uint16_t overlay_number;
  uint16_t reserved[4];
  uint16_t oem_id;
  uint16_t oem_info;
  uint16_t reserved2[10];
  uint32_t addressof_new_exeheader;
};

typedef struct Pe_DosHeader_t Pe_DosHeader_t;


#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/include/LIEF/LIEF/PE/DosHeader.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_DOS_HEADER_H
#define LIEF_PE_DOS_HEADER_H
#include <cstdint>
#include <array>
#include <ostream>

#include "LIEF/Object.hpp"
#include "LIEF/visibility.h"

namespace LIEF {
namespace PE {

enum class PE_TYPE : uint16_t;

namespace details {
struct pe_dos_header;
}

//! Class which represents the DosHeader, the **first**
//! structure presents at the beginning of a PE file.
//!
//! Most of the attributes of this structures are no longer relevant.
class LIEF_API DosHeader : public Object {
  public:
  using reserved_t  = std::array<uint16_t, 4>;
  using reserved2_t = std::array<uint16_t, 10>;

  static constexpr uint16_t MAGIC = 0x5a4d; // MZ

  DosHeader(const details::pe_dos_header& header);
  DosHeader(const DosHeader&) = default;
  DosHeader& operator=(const DosHeader&) = default;

  DosHeader(DosHeader&&) = default;
  DosHeader& operator=(DosHeader&&) = default;

  ~DosHeader() override = default;

  //! Magic bytes identifying a DOS/PE binary
  uint16_t magic() const {
    return magic_;
  }

  uint16_t used_bytes_in_last_page() const {
    return used_bytes_in_last_page_;
  }

  uint16_t file_size_in_pages() const {
    return file_sz_in_pages_;
  }

  uint16_t numberof_relocation() const {
    return nb_relocations_;
  }

  uint16_t header_size_in_paragraphs() const {
    return header_sz_in_paragraphs_;
  }

  uint16_t minimum_extra_paragraphs() const {
    return min_extra_paragraphs_;
  }

  uint16_t maximum_extra_paragraphs() const {
    return max_extra_paragraphs_;
  }

  uint16_t initial_relative_ss() const {
    return init_relative_ss_;
  }

  uint16_t initial_sp() const {
    return init_sp_;
  }

  uint16_t checksum() const {
    return checksum_;
  }

  uint16_t initial_ip() const {
    return init_ip_;
  }

  uint16_t initial_relative_cs() const {
    return init_rel_cs_;
  }

  uint16_t addressof_relocation_table() const {
    return addr_reloc_table_;
  }

  uint16_t overlay_number() const {
    return overlay_number_;
  }

  const reserved_t& reserved() const {
    return reserved_;
  }

  uint16_t oem_id() const {
    return oem_id_;
  }

  uint16_t oem_info() const {
    return oem_info_;
  }

  const reserved2_t& reserved2() const {
    return reserved2_;
  }

  //! Return the offset to the PE::Header structure.
  uint32_t addressof_new_exeheader() const {
    return addr_new_exe_header_;
  }

  void magic(uint16_t magic) {
    magic_ = magic;
  }

  void used_bytes_in_last_page(uint16_t value) {
    used_bytes_in_last_page_ = value;
  }

  void file_size_in_pages(uint16_t value) {
    file_sz_in_pages_ = value;
  }

  void numberof_relocation(uint16_t value) {
    nb_relocations_ = value;
  }

  void header_size_in_paragraphs(uint16_t value) {
    header_sz_in_paragraphs_ = value;
  }

  void minimum_extra_paragraphs(uint16_t value) {
    min_extra_paragraphs_ = value;
  }

  void maximum_extra_paragraphs(uint16_t value) {
    max_extra_paragraphs_ = value;
  }

  void initial_relative_ss(uint16_t value) {
    init_relative_ss_ = value;
  }

  void initial_sp(uint16_t value) {
    init_sp_ = value;
  }

  void checksum(uint16_t value) {
    checksum_ = value;
  }

  void initial_ip(uint16_t value) {
    init_ip_ = value;
  }

  void initial_relative_cs(uint16_t value) {
    init_rel_cs_ = value;
  }

  void addressof_relocation_table(uint16_t value) {
    addr_reloc_table_ = value;
  }

  void overlay_number(uint16_t value) {
    overlay_number_ = value;
  }

  void reserved(const reserved_t& reserved) {
    reserved_ = reserved;
  }

  void oem_id(uint16_t value) {
    oem_id_ = value;
  }

  void oem_info(uint16_t value) {
    oem_info_ = value;
  }

  void reserved2(const reserved2_t& reserved2) {
    reserved2_ = reserved2;
  }

  void addressof_new_exeheader(uint32_t value) {
    addr_new_exe_header_ = value;
  }

  void accept(Visitor& visitor) const override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const DosHeader& entry);

  static DosHeader create(PE_TYPE type);

  private:
  DosHeader() = default;

  uint16_t    magic_ = 0;
  uint16_t    used_bytes_in_last_page_ = 0;
  uint16_t    file_sz_in_pages_ = 0;
  uint16_t    nb_relocations_ = 0;
  uint16_t    header_sz_in_paragraphs_ = 0;
  uint16_t    min_extra_paragraphs_ = 0;
  uint16_t    max_extra_paragraphs_ = 0;
  uint16_t    init_relative_ss_ = 0;
  uint16_t    init_sp_ = 0;
  uint16_t    checksum_ = 0;
  uint16_t    init_ip_ = 0;
  uint16_t    init_rel_cs_ = 0;
  uint16_t    addr_reloc_table_ = 0;
  uint16_t    overlay_number_ = 0;
  reserved_t  reserved_;
  uint16_t    oem_id_ = 0;
  uint16_t    oem_info_ = 0;
  reserved2_t reserved2_;
  uint32_t    addr_new_exe_header_ = 0;
};
}
}

#endif


```

`KDemu/include/LIEF/LIEF/PE/EnumToString.h`:

```h
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef C_LIEF_PE_ENUM_TO_STRING_H_
#define C_LIEF_PE_ENUM_TO_STRING_H_

#include "LIEF/visibility.h"

#include "LIEF/PE/enums.h"

#ifdef __cplusplus
extern "C" {
#endif

LIEF_API const char* PE_TYPES_to_string(enum LIEF_PE_PE_TYPES e);

#ifdef __cplusplus
}
#endif


#endif

```

`KDemu/include/LIEF/LIEF/PE/EnumToString.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_ENUM_TO_STRING_H
#define LIEF_PE_ENUM_TO_STRING_H

#include <cstdint>
#include <cstddef>

#include "LIEF/visibility.h"

namespace LIEF {
namespace PE {

enum SYMBOL_SECTION_NUMBER : int;
enum SYMBOL_STORAGE_CLASS : int;
enum class ACCELERATOR_FLAGS : size_t;
enum class ACCELERATOR_VK_CODES : size_t;
enum class ALGORITHMS : uint32_t;
enum class CODE_PAGES : size_t;
enum class DIALOG_BOX_STYLES : size_t;
enum class EXTENDED_WINDOW_STYLES : size_t;
enum class FIXED_VERSION_FILE_FLAGS : size_t;
enum class FIXED_VERSION_FILE_SUB_TYPES : size_t;
enum class FIXED_VERSION_FILE_TYPES : size_t;
enum class FIXED_VERSION_OS : size_t;
enum class PE_SECTION_TYPES : uint8_t;
enum class PE_TYPE : uint16_t;
enum class RELOCATIONS_AMD64 : size_t;
enum class RELOCATIONS_ARM : size_t;
enum class RELOCATIONS_BASE_TYPES : size_t;
enum class RELOCATIONS_I386 : size_t;
enum class SUBSYSTEM : size_t;
enum class SYMBOL_BASE_TYPES : size_t;
enum class SYMBOL_COMPLEX_TYPES : size_t;
enum class WINDOW_STYLES : size_t;

LIEF_API const char* to_string(PE_TYPE e);

LIEF_API const char* to_string(PE_SECTION_TYPES e);

LIEF_API const char* to_string(SYMBOL_BASE_TYPES e);
LIEF_API const char* to_string(SYMBOL_COMPLEX_TYPES e);
LIEF_API const char* to_string(SYMBOL_SECTION_NUMBER e);
LIEF_API const char* to_string(SYMBOL_STORAGE_CLASS e);

LIEF_API const char* to_string(RELOCATIONS_BASE_TYPES e);
LIEF_API const char* to_string(RELOCATIONS_I386 e);
LIEF_API const char* to_string(RELOCATIONS_AMD64 e);
LIEF_API const char* to_string(RELOCATIONS_ARM e);

LIEF_API const char* to_string(CODE_PAGES e);

LIEF_API const char* to_string(EXTENDED_WINDOW_STYLES e);
LIEF_API const char* to_string(WINDOW_STYLES e);
LIEF_API const char* to_string(DIALOG_BOX_STYLES e);

LIEF_API const char* to_string(FIXED_VERSION_OS e);
LIEF_API const char* to_string(FIXED_VERSION_FILE_FLAGS e);
LIEF_API const char* to_string(FIXED_VERSION_FILE_TYPES e);
LIEF_API const char* to_string(FIXED_VERSION_FILE_SUB_TYPES e);

LIEF_API const char* to_string(ACCELERATOR_FLAGS e);
LIEF_API const char* to_string(ACCELERATOR_VK_CODES e);

LIEF_API const char* to_string(ALGORITHMS e);

} // namespace PE
} // namespace LIEF
#endif



```

`KDemu/include/LIEF/LIEF/PE/Export.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_EXPORT_H
#define LIEF_PE_EXPORT_H

#include <ostream>
#include <string>

#include "LIEF/Object.hpp"
#include "LIEF/visibility.h"
#include "LIEF/iterators.hpp"
#include "LIEF/PE/ExportEntry.hpp"

namespace LIEF {
namespace PE {

class Builder;
class Parser;

namespace details {
struct pe_export_directory_table;
}

//! Class which represents a PE Export
class LIEF_API Export : public Object {
  friend class Builder;
  friend class Parser;

  public:
  using entries_t        = std::vector<ExportEntry>;
  using it_entries       = ref_iterator<entries_t&>;
  using it_const_entries = const_ref_iterator<const entries_t&>;

  Export() = default;
  Export(const details::pe_export_directory_table& header);
  Export(const Export&) = default;
  Export& operator=(const Export&) = default;
  ~Export() override = default;

  //! According to the PE specifications this value is reserved
  //! and should be set to 0
  uint32_t export_flags() const {
    return export_flags_;
  }

  //! The time and date that the export data was created
  uint32_t timestamp() const {
    return timestamp_;
  }

  //! The major version number (can be user-defined)
  uint16_t major_version() const {
    return major_version_;
  }

  //! The minor version number (can be user-defined)
  uint16_t minor_version() const {
    return minor_version_;
  }

  //! The starting number for the exports. Usually this value is set to 1
  uint32_t ordinal_base() const {
    return ordinal_base_;
  }

  //! The name of the library exported (e.g. `KERNEL32.dll`)
  const std::string& name() const {
    return name_;
  }

  //! Iterator over the ExportEntry
  it_entries entries() {
    return entries_;
  }

  it_const_entries entries() const {
    return entries_;
  }

  void export_flags(uint32_t flags) {
    export_flags_ = flags;
  }
  void timestamp(uint32_t timestamp) {
    timestamp_ = timestamp;
  }

  void major_version(uint16_t major_version) {
    major_version_ = major_version;
  }

  void minor_version(uint16_t minor_version) {
    minor_version_ = minor_version;
  }
  void ordinal_base(uint32_t ordinal_base) {
    ordinal_base_ = ordinal_base;
  }

  void name(std::string name) {
    name_ = std::move(name);
  }

  void accept(Visitor& visitor) const override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const Export& exp);

  private:
  uint32_t export_flags_ = 0;
  uint32_t timestamp_ = 0;
  uint16_t major_version_ = 0;
  uint16_t minor_version_ = 0;
  uint32_t ordinal_base_ = 0;
  entries_t entries_;
  std::string name_;

};

}
}

#endif /* PE_EXPORT_H */

```

`KDemu/include/LIEF/LIEF/PE/ExportEntry.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_EXPORT_ENTRY_H
#define LIEF_PE_EXPORT_ENTRY_H

#include <string>
#include <ostream>

#include "LIEF/Object.hpp"
#include "LIEF/visibility.h"
#include "LIEF/Abstract/Symbol.hpp"

namespace LIEF {
namespace PE {

class Builder;
class Parser;

//! Class which represents a PE Export entry (cf. PE::Export)
class LIEF_API ExportEntry : public LIEF::Symbol {

  friend class Builder;
  friend class Parser;

  public:
  struct LIEF_API forward_information_t {
    std::string library;
    std::string function;

    operator bool() const {
      return !library.empty() || !function.empty();
    }

    LIEF_API friend std::ostream& operator<<(std::ostream& os, const forward_information_t& info);
  };

  public:
  ExportEntry() = default;
  ExportEntry(uint32_t address, bool is_extern,
              uint16_t ordinal, uint32_t function_rva);
  ExportEntry(const ExportEntry&) = default;
  ExportEntry& operator=(const ExportEntry&) = default;
  ~ExportEntry() override = default;

  uint16_t ordinal() const {
    return ordinal_;
  }
  uint32_t address() const {
    return address_;
  }
  bool is_extern() const {
    return is_extern_;
  }
  bool is_forwarded() const {
    return forward_info_;
  }

  forward_information_t forward_information() const {
    return is_forwarded() ? forward_info_ : forward_information_t{};
  }

  uint32_t function_rva() const {
    return function_rva_;
  }

  void ordinal(uint16_t ordinal) {
    ordinal_ = ordinal;
  }

  void address(uint32_t address) {
    address_ = address;
  }

  void is_extern(bool is_extern) {
    is_extern_ = is_extern;
  }

  uint64_t value() const override {
    return address();
  }

  void value(uint64_t value) override {
    address(static_cast<uint32_t>(value));
  }

  void set_forward_info(std::string lib, std::string function)  {
    forward_info_.library =  std::move(lib);
    forward_info_.function = std::move(function);
  }

  void accept(Visitor& visitor) const override;


  LIEF_API friend std::ostream& operator<<(std::ostream& os, const ExportEntry& exportEntry);

  private:
  uint32_t function_rva_ = 0;
  uint16_t ordinal_ = 0;
  uint32_t address_ = 0;
  bool     is_extern_ = false;

  forward_information_t forward_info_;

};

}
}

#endif /* PE_EXPORTENTRY_H */

```

`KDemu/include/LIEF/LIEF/PE/Header.h`:

```h
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef C_LIEF_PE_HEADER_H
#define C_LIEF_PE_HEADER_H

#include <inttypes.h>

#include "LIEF/visibility.h"

#ifdef __cplusplus
extern "C" {
#endif

enum LIEF_PE_MACHINE_TYPES {
  LIEF_PE_MACHINE_UNKNOWN   = 0x0,
  LIEF_PE_MACHINE_AM33      = 0x1D3,  /**< Matsushita AM33                */
  LIEF_PE_MACHINE_AMD64     = 0x8664, /**< AMD x64                        */
  LIEF_PE_MACHINE_ARM       = 0x1C0,  /**< ARM little endian              */
  LIEF_PE_MACHINE_ARMNT     = 0x1C4,  /**< ARMv7 Thumb mode only          */
  LIEF_PE_MACHINE_ARM64     = 0xAA64, /**< ARMv8 in 64-bits mode          */
  LIEF_PE_MACHINE_EBC       = 0xEBC,  /**< EFI byte code                  */
  LIEF_PE_MACHINE_I386      = 0x14C,  /**< Intel 386 or later             */
  LIEF_PE_MACHINE_IA64      = 0x200,  /**< Intel Itanium processor family */
  LIEF_PE_MACHINE_M32R      = 0x9041, /**< Mitsubishi M32R little endian  */
  LIEF_PE_MACHINE_MIPS16    = 0x266,  /**< MIPS16                         */
  LIEF_PE_MACHINE_MIPSFPU   = 0x366,  /**< MIPS with FPU                  */
  LIEF_PE_MACHINE_MIPSFPU16 = 0x466,  /**< MIPS16 with FPU                */
  LIEF_PE_MACHINE_POWERPC   = 0x1F0,  /**< Power PC little endian         */
  LIEF_PE_MACHINE_POWERPCFP = 0x1F1,  /**< Power PC with floating point   */
  LIEF_PE_MACHINE_R4000     = 0x166,  /**< MIPS with little endian        */
  LIEF_PE_MACHINE_RISCV32   = 0x5032, /**< RISC-V 32-bit address space    */
  LIEF_PE_MACHINE_RISCV64   = 0x5064, /**< RISC-V 64-bit address space    */
  LIEF_PE_MACHINE_RISCV128  = 0x5128, /**< RISC-V 128-bit address space   */
  LIEF_PE_MACHINE_SH3       = 0x1A2,  /**< Hitachi SH3                    */
  LIEF_PE_MACHINE_SH3DSP    = 0x1A3,  /**< Hitachi SH3 DSP                */
  LIEF_PE_MACHINE_SH4       = 0x1A6,  /**< Hitachi SH4                    */
  LIEF_PE_MACHINE_SH5       = 0x1A8,  /**< Hitachi SH5                    */
  LIEF_PE_MACHINE_THUMB     = 0x1C2,  /**< ARM or Thumb                   */
  LIEF_PE_MACHINE_WCEMIPSV2 = 0x169   /**< MIPS little-endian WCE v2      */
};

enum LIEF_PE_HEADER_CHARACTERISTICS {
  LIEF_PE_HEADER_CHARACTERISTICS_INVALID                 = 0x0000,
  LIEF_PE_HEADER_CHARACTERISTICS_RELOCS_STRIPPED         = 0x0001, /**< The file does not contain base relocations and must be loaded at its preferred base. If this cannot be done, the loader will error.*/
  LIEF_PE_HEADER_CHARACTERISTICS_EXECUTABLE_IMAGE        = 0x0002, /**< The file is valid and can be run.*/
  LIEF_PE_HEADER_CHARACTERISTICS_LINE_NUMS_STRIPPED      = 0x0004, /**< COFF line numbers have been stripped. This is deprecated and should be 0*/
  LIEF_PE_HEADER_CHARACTERISTICS_LOCAL_SYMS_STRIPPED     = 0x0008, /**< COFF symbol table entries for local symbols have been removed. This is deprecated and should be 0.*/
  LIEF_PE_HEADER_CHARACTERISTICS_AGGRESSIVE_WS_TRIM      = 0x0010, /**< Aggressively trim working set. This is deprecated and must be 0.*/
  LIEF_PE_HEADER_CHARACTERISTICS_LARGE_ADDRESS_AWARE     = 0x0020, /**< Image can handle > 2GiB addresses. */
  LIEF_PE_HEADER_CHARACTERISTICS_BYTES_REVERSED_LO       = 0x0080, /**< Little endian: the LSB precedes the MSB in memory. This is deprecated and should be 0.*/
  LIEF_PE_HEADER_CHARACTERISTICS_32BIT_MACHINE           = 0x0100, /**< Machine is based on a 32bit word architecture. */
  LIEF_PE_HEADER_CHARACTERISTICS_DEBUG_STRIPPED          = 0x0200, /**< Debugging info has been removed. */
  LIEF_PE_HEADER_CHARACTERISTICS_REMOVABLE_RUN_FROM_SWAP = 0x0400, /**< If the image is on removable media, fully load it and copy it to swap. */
  LIEF_PE_HEADER_CHARACTERISTICS_NET_RUN_FROM_SWAP       = 0x0800, /**< If the image is on network media, fully load it and copy it to swap. */
  LIEF_PE_HEADER_CHARACTERISTICS_SYSTEM                  = 0x1000, /**< The image file is a system file, not a user program.*/
  LIEF_PE_HEADER_CHARACTERISTICS_DLL                     = 0x2000, /**< The image file is a DLL. */
  LIEF_PE_HEADER_CHARACTERISTICS_UP_SYSTEM_ONLY          = 0x4000, /**< This file should only be run on a uniprocessor machine. */
  LIEF_PE_HEADER_CHARACTERISTICS_BYTES_REVERSED_HI       = 0x8000  /**< Big endian: the MSB precedes the LSB in memory. This is deprecated */
};

struct Pe_Header_t {
  uint8_t            signature[4];
  enum LIEF_PE_MACHINE_TYPES machine;
  uint16_t           numberof_sections;
  uint32_t           time_date_stamp;
  uint32_t           pointerto_symbol_table;
  uint32_t           numberof_symbols;
  uint16_t           sizeof_optional_header;
  uint16_t           characteristics;
};

typedef struct Pe_Header_t Pe_Header_t;

LIEF_API const char* lief_pe_header_machine_str(enum LIEF_PE_MACHINE_TYPES e);
LIEF_API const char* lief_pe_header_characteristics_str(enum LIEF_PE_HEADER_CHARACTERISTICS e);

#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/include/LIEF/LIEF/PE/Header.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_HEADER_H
#define LIEF_PE_HEADER_H
#include <array>
#include <vector>
#include <ostream>
#include <cstdint>

#include "LIEF/Object.hpp"
#include "LIEF/visibility.h"
#include "LIEF/enums.hpp"
#include "LIEF/PE/enums.hpp"

namespace LIEF {
namespace PE {

namespace details {
struct pe_header;
}

//! Class that represents the PE header (which follows the DosHeader)
class LIEF_API Header : public Object {
  public:
  using signature_t = std::array<uint8_t, /* PE Magic */ 4>;

  enum class MACHINE_TYPES {
    UNKNOWN   = 0x0,
    AM33      = 0x1D3,  /**< Matsushita AM33                */
    AMD64     = 0x8664, /**< AMD x64                        */
    ARM       = 0x1C0,  /**< ARM little endian              */
    ARMNT     = 0x1C4,  /**< ARMv7 Thumb mode only          */
    ARM64     = 0xAA64, /**< ARMv8 in 64-bits mode          */
    EBC       = 0xEBC,  /**< EFI byte code                  */
    I386      = 0x14C,  /**< Intel 386 or later             */
    IA64      = 0x200,  /**< Intel Itanium processor family */
    M32R      = 0x9041, /**< Mitsubishi M32R little endian  */
    MIPS16    = 0x266,  /**< MIPS16                         */
    MIPSFPU   = 0x366,  /**< MIPS with FPU                  */
    MIPSFPU16 = 0x466,  /**< MIPS16 with FPU                */
    POWERPC   = 0x1F0,  /**< Power PC little endian         */
    POWERPCFP = 0x1F1,  /**< Power PC with floating point   */
    R4000     = 0x166,  /**< MIPS with little endian        */
    RISCV32   = 0x5032, /**< RISC-V 32-bit address space    */
    RISCV64   = 0x5064, /**< RISC-V 64-bit address space    */
    RISCV128  = 0x5128, /**< RISC-V 128-bit address space   */
    SH3       = 0x1A2,  /**< Hitachi SH3                    */
    SH3DSP    = 0x1A3,  /**< Hitachi SH3 DSP                */
    SH4       = 0x1A6,  /**< Hitachi SH4                    */
    SH5       = 0x1A8,  /**< Hitachi SH5                    */
    THUMB     = 0x1C2,  /**< ARM or Thumb                   */
    WCEMIPSV2 = 0x169   /**< MIPS little-endian WCE v2      */
  };

  enum class CHARACTERISTICS {
    NONE                    = 0x0000,
    RELOCS_STRIPPED         = 0x0001, /**< The file does not contain base relocations and must be loaded at its preferred base. If this cannot be done, the loader will error.*/
    EXECUTABLE_IMAGE        = 0x0002, /**< File is executable (i.e. no unresolved externel references). */
    LINE_NUMS_STRIPPED      = 0x0004, /**< COFF line numbers have been stripped. This is deprecated and should be 0 */
    LOCAL_SYMS_STRIPPED     = 0x0008, /**< COFF symbol table entries for local symbols have been removed. This is deprecated and should be 0.*/
    AGGRESSIVE_WS_TRIM      = 0x0010, /**< Aggressively trim working set. This is deprecated and must be 0. */
    LARGE_ADDRESS_AWARE     = 0x0020, /**< Image can handle > 2GiB addresses. */
    BYTES_REVERSED_LO       = 0x0080, /**< Little endian: the LSB precedes the MSB in memory. This is deprecated and should be 0.*/
    NEED_32BIT_MACHINE      = 0x0100, /**< Machine is based on a 32bit word architecture. */
    DEBUG_STRIPPED          = 0x0200, /**< Debugging info has been removed. */
    REMOVABLE_RUN_FROM_SWAP = 0x0400, /**< If the image is on removable media, fully load it and copy it to swap. */
    NET_RUN_FROM_SWAP       = 0x0800, /**< If the image is on network media, fully load it and copy it to swap. */
    SYSTEM                  = 0x1000, /**< The image file is a system file, not a user program.*/
    DLL                     = 0x2000, /**< The image file is a DLL. */
    UP_SYSTEM_ONLY          = 0x4000, /**< This file should only be run on a uniprocessor machine. */
    BYTES_REVERSED_HI       = 0x8000  /**< Big endian: the MSB precedes the LSB in memory. This is deprecated */
  };
  static Header create(PE_TYPE type);

  Header(const details::pe_header& header);
  ~Header() override = default;

  Header& operator=(const Header&) = default;
  Header(const Header&) = default;

  //! Signature (or magic byte) of the header. It must be: ``PE\0\0``
  const signature_t& signature() const {
    return signature_;
  }

  //! The targeted machine architecture like ARM, x86, AMD64, ...
  MACHINE_TYPES machine() const {
    return machine_;
  }

  //! The number of sections in the binary.
  uint16_t numberof_sections() const {
    return nb_sections_;
  }

  //! The low 32 bits of the number of seconds since
  //! January 1, 1970. It **indicates** when the file was created.
  uint32_t time_date_stamp() const {
    return timedatestamp_;
  }

  //! The offset of the **COFF** symbol table.
  //!
  //! This value should be zero for an image because COFF debugging information is deprecated.
  uint32_t pointerto_symbol_table() const {
    return pointerto_symtab_;
  }

  //! The number of entries in the symbol table. This data can be used to locate the string table
  //! which immediately follows the symbol table.
  //!
  //! This value should be zero for an image because COFF debugging information is deprecated.
  uint32_t numberof_symbols() const {
    return nb_symbols_;
  }

  //! Size of the OptionalHeader **AND** the data directories which follows this header.
  //!
  //! This value is equivalent to: ``sizeof(pe_optional_header) + NB_DATA_DIR * sizeof(data_directory)``
  //!
  //! This size **should** be either:
  //! * 0xE0 (224) for a PE32  (32 bits)
  //! * 0xF0 (240) for a PE32+ (64 bits)
  uint16_t sizeof_optional_header() const {
    return sizeof_opt_header_;
  }

  //! Characteristics of the binary like whether it is a DLL or an executable
  uint32_t characteristics() const {
    return characteristics_;
  }

  //! Check if the given CHARACTERISTICS is present
  bool has_characteristic(CHARACTERISTICS c) const {
    return (characteristics() & static_cast<uint32_t>(c)) > 0;
  }

  //! The list of the CHARACTERISTICS
  std::vector<CHARACTERISTICS> characteristics_list() const;

  void machine(MACHINE_TYPES type) {
    machine_ = type;
  }

  void numberof_sections(uint16_t nb) {
    nb_sections_ = nb;
  }

  void time_date_stamp(uint32_t timestamp) {
    timedatestamp_ = timestamp;
  }

  void pointerto_symbol_table(uint32_t ptr) {
    pointerto_symtab_ = ptr;
  }

  void numberof_symbols(uint32_t nb) {
    nb_symbols_ = nb;
  }

  void sizeof_optional_header(uint16_t size) {
    sizeof_opt_header_ = size;
  }

  void characteristics(uint32_t characteristics) {
    characteristics_ = characteristics;
  }

  void signature(const signature_t& sig) {
    signature_ = sig;
  }

  void add_characteristic(CHARACTERISTICS c) {
    characteristics_ |= static_cast<uint32_t>(c);
  }

  void remove_characteristic(CHARACTERISTICS c) {
    characteristics_ &= ~static_cast<uint32_t>(c);
  }

  void accept(Visitor& visitor) const override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const Header& entry);

  private:
  Header() = default;
  signature_t signature_;
  MACHINE_TYPES machine_ = MACHINE_TYPES::UNKNOWN;
  uint16_t nb_sections_ = 0;
  uint32_t timedatestamp_ = 0;
  uint32_t pointerto_symtab_;
  uint32_t nb_symbols_ = 0;
  uint16_t sizeof_opt_header_ = 0;
  uint32_t characteristics_ = 0;
};

LIEF_API const char* to_string(Header::CHARACTERISTICS c);
LIEF_API const char* to_string(Header::MACHINE_TYPES c);
}
}

ENABLE_BITMASK_OPERATORS(LIEF::PE::Header::CHARACTERISTICS);
#endif

```

`KDemu/include/LIEF/LIEF/PE/Import.h`:

```h
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef C_LIEF_PE_IMPORT_H_
#define C_LIEF_PE_IMPORT_H_

#include <inttypes.h>

#include "LIEF/PE/enums.h"
#include "LIEF/PE/ImportEntry.h"

#ifdef __cplusplus
extern "C" {
#endif

struct Pe_Import_t {
  const char*        name;
  uint32_t           forwarder_chain;
  uint32_t           timedatestamp;
  Pe_ImportEntry_t** entries;
  uint32_t           import_address_table_rva;
  uint32_t           import_lookup_table_rva;
};

typedef struct Pe_Import_t Pe_Import_t;


#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/include/LIEF/LIEF/PE/Import.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_IMPORT_H
#define LIEF_PE_IMPORT_H

#include <string>
#include <ostream>

#include "LIEF/errors.hpp"
#include "LIEF/Object.hpp"
#include "LIEF/visibility.h"
#include "LIEF/iterators.hpp"
#include "LIEF/PE/ImportEntry.hpp"

namespace LIEF {
namespace PE {
class Parser;
class Builder;
class DataDirectory;

namespace details {
struct pe_import;
}

//! Class that represents a PE import.
class LIEF_API Import : public Object {

  friend class Parser;
  friend class Builder;

  public:
  using entries_t        = std::vector<ImportEntry>;
  using it_entries       = ref_iterator<entries_t&>;
  using it_const_entries = const_ref_iterator<const entries_t&>;

  Import(const details::pe_import& import);
  Import(std::string name) :
    name_(std::move(name))
  {}
  Import() = default;
  ~Import() override = default;

  Import(const Import& other) = default;
  Import(Import&& other) noexcept = default;
  Import& operator=(Import&& other) noexcept = default;
  Import& operator=(const Import& other) = default;

  //! The index of the first forwarder reference
  uint32_t forwarder_chain() const {
    return forwarder_chain_;
  }

  //! The stamp that is set to zero until the image is bound.
  //! After the image is bound, this field is set to the time/data stamp of the DLL
  uint32_t timedatestamp() const {
    return timedatestamp_;
  }

  //! Iterator over the PE::ImportEntry
  it_const_entries entries() const {
    return entries_;
  }

  it_entries entries() {
    return entries_;
  }

  //! The RVA of the import address table (``IAT``). The content of this table is
  //! **identical** to the content of the Import Lookup Table (``ILT``) until the
  //! image is bound.
  //!
  //! @warning
  //! This address could change when re-building the binary
  uint32_t import_address_table_rva() const {
    return import_address_table_RVA_;
  }

  //! Return the relative virtual address of the import lookup table.
  //!
  //! @warning
  //! This address could change when re-building the binary
  uint32_t import_lookup_table_rva() const {
    return import_lookup_table_RVA_;
  }

  //! Return the Function's RVA from the import address table (`IAT`)
  //!
  //! @warning
  //! This address could change when re-building the binary
  result<uint32_t> get_function_rva_from_iat(const std::string& function) const;

  //! Return the imported function with the given name
  ImportEntry* get_entry(const std::string& name) {
    return const_cast<ImportEntry*>(static_cast<const Import*>(this)->get_entry(name));
  }
  const ImportEntry* get_entry(const std::string& name) const;

  //! Return the library's name (e.g. `kernel32.dll`)
  const std::string& name() const {
    return name_;
  }

  //! Change the current import name
  void name(std::string name) {
    name_ = std::move(name);
  }

  //! Return the PE::DataDirectory associated with this import.
  //! It should be the one at index PE::DataDirectory::TYPES::IMPORT_TABLE
  //!
  //! If the data directory can't be found, return a nullptr
  DataDirectory* directory() {
    return directory_;
  }
  const DataDirectory* directory() const {
    return directory_;
  }

  //! Return the PE::DataDirectory associated associated with the IAT.
  //! It should be the one at index PE::DataDirectory::TYPES::IAT
  //!
  //! If the data directory can't be found, return a nullptr
  DataDirectory* iat_directory() {
    return iat_directory_;
  }
  const DataDirectory* iat_directory() const {
    return iat_directory_;
  }

  //! Add a new import entry (i.e. an imported function)
  ImportEntry& add_entry(ImportEntry entry) {
    entries_.push_back(std::move(entry));
    return entries_.back();
  }

  //! Add a new import entry with the given name (i.e. an imported function)
  ImportEntry& add_entry(const std::string& name) {
    entries_.emplace_back(name);
    return entries_.back();
  }

  void import_lookup_table_rva(uint32_t rva) {
    import_lookup_table_RVA_ = rva;
  }
  void import_address_table_rva(uint32_t rva) {
    import_address_table_RVA_ = rva;
  }

  void accept(Visitor& visitor) const override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const Import& entry);

  private:
  entries_t        entries_;
  DataDirectory*   directory_ = nullptr;
  DataDirectory*   iat_directory_ = nullptr;
  uint32_t         import_lookup_table_RVA_ = 0;
  uint32_t         timedatestamp_ = 0;
  uint32_t         forwarder_chain_ = 0;
  uint32_t         name_RVA_ = 0;
  uint32_t         import_address_table_RVA_ = 0;
  std::string      name_;
  PE_TYPE          type_ = PE_TYPE::PE32;
};

}
}

#endif

```

`KDemu/include/LIEF/LIEF/PE/ImportEntry.h`:

```h
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef C_LIEF_PE_IMPORT_ENTRY_H_
#define C_LIEF_PE_IMPORT_ENTRY_H_

#include <inttypes.h>

#include "LIEF/types.h"

#include "LIEF/PE/enums.h"

#ifdef __cplusplus
extern "C" {
#endif

struct Pe_ImportEntry_t {
  bool        is_ordinal;
  const char* name;
  uint16_t    ordinal;
  uint64_t    hint_name_rva;
  uint16_t    hint;
  uint64_t    iat_value;
  uint64_t    data;
  uint64_t    iat_address;
};

typedef struct Pe_ImportEntry_t Pe_ImportEntry_t;


#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/include/LIEF/LIEF/PE/ImportEntry.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_IMPORT_ENTRY_H
#define LIEF_PE_IMPORT_ENTRY_H
#include <string>
#include <ostream>

#include "LIEF/Object.hpp"
#include "LIEF/visibility.h"
#include "LIEF/Abstract/Symbol.hpp"

#include "LIEF/PE/enums.hpp"

namespace LIEF {
namespace PE {
class Parser;
class Builder;

//! Class that represents an entry (i.e. an import) in the import table (Import).
//!
//! It extends the LIEF::Symbol generic class that exposes the LIEF::Symbol::name and
//! LIEF::Symbol::value API
class LIEF_API ImportEntry : public LIEF::Symbol {
  friend class Parser;
  friend class Builder;

  public:
  ImportEntry() = default;
  ImportEntry(uint64_t data, const std::string& name = "");
  ImportEntry(uint64_t data, PE_TYPE type, const std::string& name);
  ImportEntry(const std::string& name);
  ImportEntry(const std::string& name, PE_TYPE type);
  ImportEntry(const ImportEntry&) = default;
  ImportEntry& operator=(const ImportEntry&) = default;
  ~ImportEntry() override = default;

  //! `True` if it is an import by ordinal
  bool is_ordinal() const;

  //! The ordinal value
  uint16_t ordinal() const {
    static constexpr auto MASK = 0xFFFF;
    return is_ordinal() ? (data_ & MASK) : 0;
  }

  //! @see ImportEntry::data
  uint64_t hint_name_rva() const {
    return data();
  }

  //! Index into the Export::entries that is used to speed-up
  //! the symbol resolution.
  uint16_t hint() const {
    return hint_;
  }

  //! Value of the current entry in the Import Address Table.
  //! It should match the lookup table value
  uint64_t iat_value() const {
    return iat_value_;
  }

  //! Raw value
  uint64_t data() const {
    return data_;
  }

  //! **Original** address of the entry in the Import Address Table
  uint64_t iat_address() const {
    return rva_;
  }

  void data(uint64_t data) {
    data_ = data;
  }

  void accept(Visitor& visitor) const override;


  LIEF_API friend std::ostream& operator<<(std::ostream& os, const ImportEntry& entry);

  private:
  uint64_t data_ = 0;
  uint16_t hint_ = 0;
  uint64_t iat_value_ = 0;
  uint64_t rva_ = 0;
  PE_TYPE  type_ = PE_TYPE::PE32_PLUS;
};

}
}

#endif /* IMPORTENTRY_H */

```

`KDemu/include/LIEF/LIEF/PE/LoadConfigurations.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_LOAD_CONFIGURATIONS_H
#define LIEF_PE_LOAD_CONFIGURATIONS_H

#include "LIEF/PE/LoadConfigurations/LoadConfigurationV11.hpp"
#include "LIEF/PE/LoadConfigurations/LoadConfigurationV10.hpp"
#include "LIEF/PE/LoadConfigurations/LoadConfigurationV9.hpp"
#include "LIEF/PE/LoadConfigurations/LoadConfigurationV8.hpp"
#include "LIEF/PE/LoadConfigurations/LoadConfigurationV7.hpp"
#include "LIEF/PE/LoadConfigurations/LoadConfigurationV6.hpp"
#include "LIEF/PE/LoadConfigurations/LoadConfigurationV5.hpp"
#include "LIEF/PE/LoadConfigurations/LoadConfigurationV4.hpp"
#include "LIEF/PE/LoadConfigurations/LoadConfigurationV3.hpp"
#include "LIEF/PE/LoadConfigurations/LoadConfigurationV2.hpp"
#include "LIEF/PE/LoadConfigurations/LoadConfigurationV1.hpp"
#include "LIEF/PE/LoadConfigurations/LoadConfigurationV0.hpp"
#include "LIEF/PE/LoadConfigurations/LoadConfiguration.hpp"

#endif

```

`KDemu/include/LIEF/LIEF/PE/LoadConfigurations/LoadConfiguration.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_LOAD_CONFIGURATION_H
#define LIEF_PE_LOAD_CONFIGURATION_H
#include <ostream>
#include <cstdint>

#include "LIEF/Object.hpp"
#include "LIEF/visibility.h"

namespace LIEF {
namespace PE {

namespace details {
template<class T>
struct load_configuration;
}

//! Class that represents the default PE's ``LoadConfiguration``
//!
//! It's the base class for any future versions of the structure
class LIEF_API LoadConfiguration : public Object {
  public:
  enum class VERSION {
    UNKNOWN = 0,
    SEH,
    WIN_8_1,
    WIN_10_0_9879,
    WIN_10_0_14286,
    WIN_10_0_14383,
    WIN_10_0_14901,
    WIN_10_0_15002,
    WIN_10_0_16237,
    WIN_10_0_18362,
    WIN_10_0_19534,
    WIN_10_0_MSVC_2019,
    WIN_10_0_MSVC_2019_16,
  };

  static constexpr VERSION WIN_VERSION = VERSION::UNKNOWN;

  LoadConfiguration() = default;

  template<class T>
  LIEF_LOCAL LoadConfiguration(const details::load_configuration<T>& header);

  LoadConfiguration& operator=(const LoadConfiguration&) = default;
  LoadConfiguration(const LoadConfiguration&) = default;

  //! (SDK) Version of the structure
  virtual VERSION version() const {
    return WIN_VERSION;
  }

  //! Characteristics of the structure
  //! It usually holds its size
  //!
  //! @see @link version LoadConfiguration::version@endlink
  uint32_t characteristics() const {
    return characteristics_;
  }

  //! Size of the current structure which is an alias for characteristics
  uint32_t size() const {
    return characteristics_;
  }

  //! Date and time stamp value
  uint32_t timedatestamp() const {
    return timedatestamp_;
  }

  //! Major Version
  uint16_t major_version() const {
    return major_version_;
  }

  //! Minor version
  uint16_t minor_version() const {
    return minor_version_;
  }

  //! The global loader flags to clear for
  //! this process as the loader start the process.
  uint32_t global_flags_clear() const {
    return global_flags_clear_;
  }

  //! The global loader flags to set for
  //! this process as the loader starts the process.
  uint32_t global_flags_set() const {
    return global_flags_set_;
  }

  //! The default timeout value to use for
  //! this process’s critical sections that are abandoned.
  uint32_t critical_section_default_timeout() const {
    return critical_section_default_timeout_;
  }

  //! Memory that must be freed before
  //! it is returned to the system, in bytes.
  uint64_t decommit_free_block_threshold() const {
    return decommit_free_block_threshold_;
  }

  //! Total amount of free memory, in
  //! bytes.
  uint64_t decommit_total_free_threshold() const {
    return decommit_total_free_threshold_;
  }

  //! The VA of a list of
  //! addresses where the LOCK prefix
  //! is used so that they can be replaced with NOP on single
  //! processor machines.
  //!
  //! @warning For ``x86`` only
  uint64_t lock_prefix_table() const {
    return lock_prefix_table_;
  }

  //! Maximum allocation size, in bytes.
  uint64_t maximum_allocation_size() const {
    return maximum_allocation_size_;
  }

  //! Maximum virtual memory size, in bytes.
  uint64_t virtual_memory_threshold() const {
    return virtual_memory_threshold_;
  }

  //! Setting this field to a non-zero value is equivalent to calling
  //! ``SetProcessAffinityMask`` with this value during process startup (.exe only)
  uint64_t process_affinity_mask() const {
    return process_affinity_mask_;
  }

  //! Process heap flags that correspond to the first argument of the
  //! ``HeapCreate`` function. These flags apply to the process heap that is
  //! created during process startup.
  uint32_t process_heap_flags() const {
    return process_heap_flags_;
  }

  //! The service pack version identifier.
  uint16_t csd_version() const {
    return csd_version_;
  }

  //! Must be zero.
  uint16_t reserved1() const {
    return reserved1_;
  }

  //! Alias for reserved1.
  //!
  //! On recent the version of the structure, Microsoft renamed reserved1 to DependentLoadFlags
  uint16_t dependent_load_flags() const {
    return reserved1_;
  }

  //! Reserved for use by the system.
  uint32_t editlist() const {
    return editlist_;
  }

  //! A pointer to a cookie that is used by Visual C++ or GS
  //! implementation.
  uint64_t security_cookie() const {
    return security_cookie_;
  }


  void characteristics(uint32_t characteristics) {
    characteristics_ = characteristics;
  }

  void timedatestamp(uint32_t timedatestamp) {
    timedatestamp_ = timedatestamp;
  }

  void major_version(uint16_t major_version) {
    major_version_ = major_version;
  }

  void minor_version(uint16_t minor_version) {
    minor_version_ = minor_version;
  }

  void global_flags_clear(uint32_t global_flags_clear) {
    global_flags_clear_ = global_flags_clear;
  }

  void global_flags_set(uint32_t global_flags_set) {
    global_flags_set_ = global_flags_set;
  }

  void critical_section_default_timeout(uint32_t critical_section_default_timeout) {
    critical_section_default_timeout_ = critical_section_default_timeout;
  }

  void decommit_free_block_threshold(uint64_t decommit_free_block_threshold) {
    decommit_free_block_threshold_ = decommit_free_block_threshold;
  }

  void decommit_total_free_threshold(uint64_t decommit_total_free_threshold) {
    decommit_total_free_threshold_ = decommit_total_free_threshold;
  }

  void lock_prefix_table(uint64_t lock_prefix_table) {
    lock_prefix_table_ = lock_prefix_table;
  }

  void maximum_allocation_size(uint64_t maximum_allocation_size) {
    maximum_allocation_size_ = maximum_allocation_size;
  }

  void virtual_memory_threshold(uint64_t virtual_memory_threshold) {
    virtual_memory_threshold_ = virtual_memory_threshold;
  }

  void process_affinity_mask(uint64_t process_affinity_mask) {
    process_affinity_mask_ = process_affinity_mask;
  }

  void process_heap_flags(uint32_t process_heap_flagsid) {
    process_heap_flags_ = process_heap_flagsid;
  }

  void csd_version(uint16_t csd_version) {
    csd_version_ = csd_version;
  }

  void reserved1(uint16_t reserved1) {
    reserved1_ = reserved1;
  }

  void dependent_load_flags(uint16_t flags) {
    reserved1(flags);
  }

  void editlist(uint32_t editlist) {
    editlist_ = editlist;
  }

  void security_cookie(uint32_t security_cookie) {
    security_cookie_ = security_cookie;
  }

  ~LoadConfiguration() override = default;

  static bool classof(const LoadConfiguration* /*config*/) {
    // This is the base class, thus all the other
    // classes can be safely casted into this one.
    return true;
  }

  template<class T>
  static const T* cast(const LoadConfiguration* config) {
    if (config->version() >= T::WIN_VERSION) {
      return static_cast<const T*>(config);
    }
    return nullptr;
  }

  void accept(Visitor& visitor) const override;

  virtual std::ostream& print(std::ostream& os) const;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const LoadConfiguration& config);

  protected:
  uint32_t characteristics_ = 0; // also named size
  uint32_t timedatestamp_ = 0;

  uint16_t major_version_ = 0;
  uint16_t minor_version_ = 0;

  uint32_t global_flags_clear_ = 0;
  uint32_t global_flags_set_ = 0;

  uint32_t critical_section_default_timeout_ = 0;

  uint64_t decommit_free_block_threshold_ = 0;
  uint64_t decommit_total_free_threshold_ = 0;

  uint64_t lock_prefix_table_ = 0;
  uint64_t maximum_allocation_size_ = 0;
  uint64_t virtual_memory_threshold_ = 0;
  uint64_t process_affinity_mask_ = 0;
  uint32_t process_heap_flags_ = 0;
  uint16_t csd_version_ = 0;
  uint16_t reserved1_ = 0;  // named DependentLoadFlags in recent headers
  uint64_t editlist_ = 0;
  uint64_t security_cookie_ = 0;
};

LIEF_API const char* to_string(LoadConfiguration::VERSION e);

}
}

#endif

```

`KDemu/include/LIEF/LIEF/PE/LoadConfigurations/LoadConfigurationV0.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_LOAD_CONFIGURATION_V0_H
#define LIEF_PE_LOAD_CONFIGURATION_V0_H
#include <ostream>

#include "LIEF/visibility.h"
#include "LIEF/PE/LoadConfigurations/LoadConfiguration.hpp"

namespace LIEF {
namespace PE {

namespace details {
template<class T>
struct load_configuration_v0;
}

//! LoadConfiguration enhanced with SEH
class LIEF_API LoadConfigurationV0 : public LoadConfiguration {
  public:
  static constexpr VERSION WIN_VERSION = VERSION::SEH;

  LoadConfigurationV0() = default;

  LoadConfigurationV0& operator=(const LoadConfigurationV0&) = default;
  LoadConfigurationV0(const LoadConfigurationV0&) = default;

  template<class T>
  LIEF_LOCAL LoadConfigurationV0(const details::load_configuration_v0<T>& header);

  VERSION version() const override {
    return WIN_VERSION;
  }

  //! The VA of the sorted table of RVAs of each valid, unique
  //! SE handler in the image.
  uint64_t se_handler_table() const {
    return se_handler_table_;
  }

  //! The count of unique handlers in the table.
  uint64_t se_handler_count() const {
    return se_handler_count_;
  }

  void se_handler_table(uint64_t se_handler_table) {
    se_handler_table_ = se_handler_table;
  }
  void se_handler_count(uint64_t se_handler_count) {
    se_handler_count_ = se_handler_count;
  }

  ~LoadConfigurationV0() override = default;

  static bool classof(const LoadConfiguration* config) {
    return config->version() == WIN_VERSION;
  }

  void accept(Visitor& visitor) const override;

  std::ostream& print(std::ostream& os) const override;

  protected:
  uint64_t se_handler_table_ = 0;
  uint64_t se_handler_count_ = 0;
};
}
}

#endif

```

`KDemu/include/LIEF/LIEF/PE/LoadConfigurations/LoadConfigurationV1.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_LOAD_CONFIGURATION_V1_H
#define LIEF_PE_LOAD_CONFIGURATION_V1_H
#include <ostream>
#include <vector>

#include "LIEF/enums.hpp"
#include "LIEF/visibility.h"

#include "LIEF/PE/LoadConfigurations/LoadConfigurationV0.hpp"

namespace LIEF {
namespace PE {

namespace details {
template<class T>
struct load_configuration_v1;
}
//! LoadConfiguration enhanced with Control Flow Guard
//!
//! This structure is available from Windows 8.1
class LIEF_API LoadConfigurationV1 : public LoadConfigurationV0 {
  public:
  static constexpr VERSION WIN_VERSION = VERSION::WIN_8_1;

  enum class IMAGE_GUARD : uint32_t {
    NONE                               = 0x00000000,
    CF_INSTRUMENTED                    = 0x00000100, /**< Module performs control flow integrity checks using system-supplied support */
    CFW_INSTRUMENTED                   = 0x00000200, /**< Module performs control flow and write integrity checks */
    CF_FUNCTION_TABLE_PRESENT          = 0x00000400, /**< Module contains valid control flow target metadata */
    SECURITY_COOKIE_UNUSED             = 0x00000800, /**< Module does not make use of the /GS security cookie */
    PROTECT_DELAYLOAD_IAT              = 0x00001000, /**< Module supports read only delay load IAT */
    DELAYLOAD_IAT_IN_ITS_OWN_SECTION   = 0x00002000, /**< Delayload import table in its own .didat section (with nothing else in it) that can be freely reprotected */
    CF_EXPORT_SUPPRESSION_INFO_PRESENT = 0x00004000, /**< Module contains suppressed export information. This also infers that the address taken taken IAT table is also present in the load config. */
    CF_ENABLE_EXPORT_SUPPRESSION       = 0x00008000, /**< Module enables suppression of exports */
    CF_LONGJUMP_TABLE_PRESENT          = 0x00010000, /**< Module contains longjmp target information */
    RF_INSTRUMENTED                    = 0x00020000, /**< Module contains return flow instrumentation and metadata */
    RF_ENABLE                          = 0x00040000, /**< Module requests that the OS enable return flow protection */
    RF_STRICT                          = 0x00080000, /**< Module requests that the OS enable return flow protection in strict mode */
    RETPOLINE_PRESENT                  = 0x00100000, /**< Module was built with retpoline support */
    EH_CONTINUATION_TABLE_PRESENT      = 0x00200000, /**< Module contains EH continuation target information */
  };

  LoadConfigurationV1() = default;

  template<class T>
  LIEF_LOCAL LoadConfigurationV1(const details::load_configuration_v1<T>& header);

  LoadConfigurationV1& operator=(const LoadConfigurationV1&) = default;
  LoadConfigurationV1(const LoadConfigurationV1&) = default;

  VERSION version() const override {
    return WIN_VERSION;
  }

  //! @brief The VA where Control Flow Guard check-function pointer is stored.
  uint64_t guard_cf_check_function_pointer() const {
    return guard_cf_check_function_pointer_;
  }

  //! @brief The VA where Control Flow Guard dispatch-function pointer is stored.
  uint64_t guard_cf_dispatch_function_pointer() const {
    return guard_cf_dispatch_function_pointer_;
  }

  //! @brief The VA of the sorted table of RVAs of each Control Flow Guard
  //! function in the image.
  uint64_t guard_cf_function_table() const {
    return guard_cf_function_table_;
  }

  //! @brief The count of unique RVAs in the
  //! LoadConfigurationV1::guard_cf_function_table.
  uint64_t guard_cf_function_count() const {
    return guard_cf_function_count_;
  }

  //! @brief Control Flow Guard related flags.
  IMAGE_GUARD guard_flags() const {
    return flags_;
  }

  //! @brief Check if the given flag is present in LoadConfigurationV1::guard_flags
  bool has(IMAGE_GUARD flag) const;

  //! @brief LoadConfigurationV1::guard_flags as a list of LIEF::PE::GUARD_CF_FLAGS
  std::vector<IMAGE_GUARD> guard_cf_flags_list() const;

  void guard_cf_check_function_pointer(uint64_t check_pointer) {
    guard_cf_check_function_pointer_ = check_pointer;
  }
  void guard_cf_dispatch_function_pointer(uint64_t dispatch_pointer) {
    guard_cf_dispatch_function_pointer_ = dispatch_pointer;
  }
  void guard_cf_function_table(uint64_t guard_cf_function_table) {
    guard_cf_function_table_ = guard_cf_function_table;
  }
  void guard_cf_function_count(uint64_t guard_cf_function_count) {
    guard_cf_function_count_ = guard_cf_function_count;
  }
  void guard_flags(IMAGE_GUARD flags) {
    flags_ = flags;
  }

  static bool classof(const LoadConfiguration* config) {
    return config->version() == WIN_VERSION;
  }

  ~LoadConfigurationV1() override = default;

  void accept(Visitor& visitor) const override;

  std::ostream& print(std::ostream& os) const override;

  protected:
  uint64_t guard_cf_check_function_pointer_ = 0;
  uint64_t guard_cf_dispatch_function_pointer_ = 0;
  uint64_t guard_cf_function_table_ = 0;
  uint64_t guard_cf_function_count_ = 0;
  IMAGE_GUARD flags_ = IMAGE_GUARD::NONE;
};

LIEF_API const char* to_string(LoadConfigurationV1::IMAGE_GUARD e);

}
}

ENABLE_BITMASK_OPERATORS(LIEF::PE::LoadConfigurationV1::IMAGE_GUARD);

#endif

```

`KDemu/include/LIEF/LIEF/PE/LoadConfigurations/LoadConfigurationV10.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_LOAD_CONFIGURATION_V10_H
#define LIEF_PE_LOAD_CONFIGURATION_V10_H
#include <ostream>

#include "LIEF/visibility.h"

#include "LIEF/PE/LoadConfigurations/LoadConfigurationV9.hpp"

namespace LIEF {
namespace PE {

namespace details {
template<class T>
struct load_configuration_v10;
}

class LIEF_API LoadConfigurationV10 : public LoadConfigurationV9 {
  public:

  static constexpr VERSION WIN_VERSION = VERSION::WIN_10_0_MSVC_2019;
  LoadConfigurationV10() = default;

  template<class T>
  LIEF_LOCAL LoadConfigurationV10(const details::load_configuration_v10<T>& header);

  LoadConfigurationV10& operator=(const LoadConfigurationV10&) = default;
  LoadConfigurationV10(const LoadConfigurationV10&) = default;

  VERSION version() const override {
    return WIN_VERSION;
  }

  uint64_t guard_xfg_check_function_pointer() const {
    return guard_xfg_check_function_pointer_;
  }

  uint64_t guard_xfg_dispatch_function_pointer() const {
    return guard_xfg_dispatch_function_pointer_;
  }

  uint64_t guard_xfg_table_dispatch_function_pointer() const {
    return guard_xfg_table_dispatch_function_pointer_;
  }

  void guard_xfg_check_function_pointer(uint64_t value) {
    guard_xfg_check_function_pointer_ = value;
  }

  void guard_xfg_dispatch_function_pointer(uint64_t value) {
    guard_xfg_dispatch_function_pointer_ = value;
  }

  void guard_xfg_table_dispatch_function_pointer(uint64_t value) {
    guard_xfg_table_dispatch_function_pointer_ = value;
  }

  static bool classof(const LoadConfiguration* config) {
    return config->version() == WIN_VERSION;
  }

  ~LoadConfigurationV10() override = default;

  void accept(Visitor& visitor) const override;

  std::ostream& print(std::ostream& os) const override;

  protected:
  uint64_t guard_xfg_check_function_pointer_ = 0;
  uint64_t guard_xfg_dispatch_function_pointer_ = 0;
  uint64_t guard_xfg_table_dispatch_function_pointer_ = 0;
};
}
}

#endif

```

`KDemu/include/LIEF/LIEF/PE/LoadConfigurations/LoadConfigurationV11.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_LOAD_CONFIGURATION_V11_H
#define LIEF_PE_LOAD_CONFIGURATION_V11_H
#include <ostream>

#include "LIEF/visibility.h"

#include "LIEF/PE/LoadConfigurations/LoadConfigurationV10.hpp"

namespace LIEF {
namespace PE {

namespace details {
template<class T>
struct load_configuration_v11;
}

class LIEF_API LoadConfigurationV11 : public LoadConfigurationV10 {
  public:
  static constexpr VERSION WIN_VERSION = VERSION::WIN_10_0_MSVC_2019_16;
  LoadConfigurationV11() = default;

  template<class T>
  LIEF_LOCAL LoadConfigurationV11(const details::load_configuration_v11<T>& header);

  LoadConfigurationV11& operator=(const LoadConfigurationV11&) = default;
  LoadConfigurationV11(const LoadConfigurationV11&) = default;

  VERSION version() const override {
    return WIN_VERSION;
  }

  uint64_t cast_guard_os_determined_failure_mode() const {
    return cast_guard_os_determined_failure_mode_;
  }

  void cast_guard_os_determined_failure_mode(uint64_t value) {
    cast_guard_os_determined_failure_mode_ = value;
  }

  static bool classof(const LoadConfiguration* config) {
    return config->version() == WIN_VERSION;
  }

  ~LoadConfigurationV11() override = default;

  void accept(Visitor& visitor) const override;

  std::ostream& print(std::ostream& os) const override;

  protected:
  uint64_t cast_guard_os_determined_failure_mode_ = 0;
};
}
}

#endif

```

`KDemu/include/LIEF/LIEF/PE/LoadConfigurations/LoadConfigurationV2.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_LOAD_CONFIGURATION_V2_H
#define LIEF_PE_LOAD_CONFIGURATION_V2_H
#include <ostream>

#include "LIEF/visibility.h"

#include "LIEF/PE/CodeIntegrity.hpp"
#include "LIEF/PE/LoadConfigurations/LoadConfigurationV1.hpp"

namespace LIEF {
namespace PE {

namespace details {
template<class T>
struct load_configuration_v2;
}

//! @brief LoadConfiguration enhanced with code integrity
class LIEF_API LoadConfigurationV2 : public LoadConfigurationV1 {
  public:
  static constexpr VERSION WIN_VERSION = VERSION::WIN_10_0_9879;

  LoadConfigurationV2() = default;

  LoadConfigurationV2& operator=(const LoadConfigurationV2&) = default;
  LoadConfigurationV2(const LoadConfigurationV2&) = default;

  template<class T>
  LIEF_LOCAL LoadConfigurationV2(const details::load_configuration_v2<T>& header);

  VERSION version() const override {
    return WIN_VERSION;
  }

  //! @brief CodeIntegrity associated with
  const CodeIntegrity& code_integrity() const {
    return code_integrity_;
  }

  CodeIntegrity& code_integrity() {
    return code_integrity_;
  }

  static bool classof(const LoadConfiguration* config) {
    return config->version() == WIN_VERSION;
  }

  ~LoadConfigurationV2() override = default;

  void accept(Visitor& visitor) const override;

  std::ostream& print(std::ostream& os) const override;

  protected:
  CodeIntegrity code_integrity_;
};
}
}

#endif

```

`KDemu/include/LIEF/LIEF/PE/LoadConfigurations/LoadConfigurationV3.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_LOAD_CONFIGURATION_V3_H
#define LIEF_PE_LOAD_CONFIGURATION_V3_H
#include <ostream>

#include "LIEF/visibility.h"
#include "LIEF/PE/LoadConfigurations/LoadConfigurationV2.hpp"

namespace LIEF {
namespace PE {

namespace details {
template<class T>
struct load_configuration_v3;
}

//! @brief LoadConfiguration with Control Flow Guard improved
class LIEF_API LoadConfigurationV3 : public LoadConfigurationV2 {
  public:

  static constexpr VERSION WIN_VERSION = VERSION::WIN_10_0_14286;

  LoadConfigurationV3() = default;

  template<class T>
  LIEF_LOCAL LoadConfigurationV3(const details::load_configuration_v3<T>& header);

  LoadConfigurationV3& operator=(const LoadConfigurationV3&) = default;
  LoadConfigurationV3(const LoadConfigurationV3&) = default;

  VERSION version() const override {
    return WIN_VERSION;
  }

  //! @brief VA of a table associated with CFG's *IAT* checks
  uint64_t guard_address_taken_iat_entry_table() const {
    return guard_address_taken_iat_entry_table_;
  }

  //! @brief Number of entries in the LoadConfigurationV3::guard_address_taken_iat_entry_table
  uint64_t guard_address_taken_iat_entry_count() const {
    return guard_address_taken_iat_entry_count_;
  }

  //! @brief VA of a table associated with CFG's *long jump*
  uint64_t guard_long_jump_target_table() const {
    return guard_long_jump_target_table_;
  }

  //! @brief Number of entries in the LoadConfigurationV3::guard_long_jump_target_table
  uint64_t guard_long_jump_target_count() const {
    return guard_long_jump_target_count_;
  }

  void guard_address_taken_iat_entry_table(uint64_t value) {
    guard_address_taken_iat_entry_table_ = value;
  }

  void guard_address_taken_iat_entry_count(uint64_t value) {
    guard_address_taken_iat_entry_count_ = value;
  }

  void guard_long_jump_target_table(uint64_t value) {
    guard_long_jump_target_table_ = value;
  }

  void guard_long_jump_target_count(uint64_t value) {
    guard_long_jump_target_count_ = value;
  }

  static bool classof(const LoadConfiguration* config) {
    return config->version() == WIN_VERSION;
  }

  ~LoadConfigurationV3() override = default;

  void accept(Visitor& visitor) const override;

  std::ostream& print(std::ostream& os) const override;

  protected:
  uint64_t guard_address_taken_iat_entry_table_ = 0;
  uint64_t guard_address_taken_iat_entry_count_ = 0;
  uint64_t guard_long_jump_target_table_ = 0;
  uint64_t guard_long_jump_target_count_ = 0;
};
}
}

#endif

```

`KDemu/include/LIEF/LIEF/PE/LoadConfigurations/LoadConfigurationV4.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_LOAD_CONFIGURATION_V4_H
#define LIEF_PE_LOAD_CONFIGURATION_V4_H
#include <ostream>

#include "LIEF/visibility.h"

#include "LIEF/PE/LoadConfigurations/LoadConfigurationV3.hpp"

namespace LIEF {
namespace PE {

namespace details {
template<class T>
struct load_configuration_v4;
}

//! @brief Load Configuration enhanced with
//! * Kind of dynamic relocations
//! * *Hybrid Metadata Pointer*
class LIEF_API LoadConfigurationV4 : public LoadConfigurationV3 {
  public:
  static constexpr VERSION WIN_VERSION = VERSION::WIN_10_0_14383;

  LoadConfigurationV4() = default;

  template<class T>
  LIEF_LOCAL LoadConfigurationV4(const details::load_configuration_v4<T>& header);

  LoadConfigurationV4& operator=(const LoadConfigurationV4&) = default;
  LoadConfigurationV4(const LoadConfigurationV4&) = default;

  VERSION version() const override {
    return WIN_VERSION;
  }

  //! @brief VA of pointing to a ``IMAGE_DYNAMIC_RELOCATION_TABLE``
  uint64_t dynamic_value_reloc_table() const {
    return dynamic_value_reloc_table_;
  }

  uint64_t hybrid_metadata_pointer() const {
    return hybrid_metadata_pointer_;
  }

  void dynamic_value_reloc_table(uint64_t value) {
    dynamic_value_reloc_table_ = value;
  }

  void hybrid_metadata_pointer(uint64_t value) {
    hybrid_metadata_pointer_ = value;
  }

  static bool classof(const LoadConfiguration* config) {
    return config->version() == WIN_VERSION;
  }

  ~LoadConfigurationV4() override = default;

  void accept(Visitor& visitor) const override;

  std::ostream& print(std::ostream& os) const override;

  protected:
  uint64_t dynamic_value_reloc_table_ = 0;
  uint64_t hybrid_metadata_pointer_ = 0;
};
}
}

#endif

```

`KDemu/include/LIEF/LIEF/PE/LoadConfigurations/LoadConfigurationV5.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_LOAD_CONFIGURATION_V5_H
#define LIEF_PE_LOAD_CONFIGURATION_V5_H
#include <ostream>

#include "LIEF/visibility.h"
#include "LIEF/PE/LoadConfigurations/LoadConfigurationV4.hpp"

namespace LIEF {
namespace PE {

namespace details {
template<class T>
struct load_configuration_v5;
}

//! @brief Load Configuration enhanced with Return Flow Guard
class LIEF_API LoadConfigurationV5 : public LoadConfigurationV4 {
  public:
  static constexpr VERSION WIN_VERSION = VERSION::WIN_10_0_14901;
  LoadConfigurationV5() = default;

  template<class T>
  LIEF_LOCAL LoadConfigurationV5(const details::load_configuration_v5<T>& header);

  LoadConfigurationV5& operator=(const LoadConfigurationV5&) = default;
  LoadConfigurationV5(const LoadConfigurationV5&) = default;

  VERSION version() const override {
    return WIN_VERSION;
  }

  //! @brief VA of the failure routine
  uint64_t guard_rf_failure_routine() const {
    return guard_rf_failure_routine_;
  }

  //! @brief VA of the failure routine ``fptr``.
  uint64_t guard_rf_failure_routine_function_pointer() const {
    return guard_rf_failure_routine_function_pointer_;
  }

  //! @brief Offset of dynamic relocation table relative to the relocation table
  uint32_t dynamic_value_reloctable_offset() const {
    return dynamic_value_reloctable_offset_;
  }

  //! The section index of the dynamic value relocation table
  uint16_t dynamic_value_reloctable_section() const {
    return dynamic_value_reloctable_section_;
  }

  //! @brief Must be zero
  uint16_t reserved2() const {
    return reserved2_;
  }

  void guard_rf_failure_routine(uint64_t value) {
    guard_rf_failure_routine_ = value;
  }

  void guard_rf_failure_routine_function_pointer(uint64_t value) {
    guard_rf_failure_routine_function_pointer_ = value;
  }

  void dynamic_value_reloctable_offset(uint32_t value) {
    dynamic_value_reloctable_offset_ = value;
  }

  void dynamic_value_reloctable_section(uint16_t value) {
    dynamic_value_reloctable_section_ = value;
  }

  void reserved2(uint16_t value) {
    reserved2_ = value;
  }

  static bool classof(const LoadConfiguration* config) {
    return config->version() == WIN_VERSION;
  }

  ~LoadConfigurationV5() override = default;

  void accept(Visitor& visitor) const override;

  std::ostream& print(std::ostream& os) const override;

  protected:
  uint64_t guard_rf_failure_routine_ = 0;
  uint64_t guard_rf_failure_routine_function_pointer_ = 0;
  uint32_t dynamic_value_reloctable_offset_ = 0;
  uint16_t dynamic_value_reloctable_section_ = 0;
  uint16_t reserved2_ = 0;
};
}
}

#endif

```

`KDemu/include/LIEF/LIEF/PE/LoadConfigurations/LoadConfigurationV6.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_LOAD_CONFIGURATION_V6_H
#define LIEF_PE_LOAD_CONFIGURATION_V6_H
#include <ostream>

#include "LIEF/visibility.h"

#include "LIEF/PE/LoadConfigurations/LoadConfigurationV5.hpp"

namespace LIEF {
namespace PE {

namespace details {
template<class T>
struct load_configuration_v6;
}

//! @brief Load Configuration enhanced with Hotpatch and improved RFG
class LIEF_API LoadConfigurationV6 : public LoadConfigurationV5 {
  public:
  static constexpr VERSION WIN_VERSION = VERSION::WIN_10_0_15002;

  LoadConfigurationV6() = default;

  template<class T>
  LIEF_LOCAL LoadConfigurationV6(const details::load_configuration_v6<T>& header);

  LoadConfigurationV6& operator=(const LoadConfigurationV6&) = default;
  LoadConfigurationV6(const LoadConfigurationV6&) = default;

  VERSION version() const override {
    return WIN_VERSION;
  }

  //! @brief VA of the Function verifying the stack pointer
  uint64_t guard_rf_verify_stackpointer_function_pointer() const {
    return guardrf_verify_stackpointer_function_pointer_;
  }

  //! @brief Offset to the *hotpatch* table
  uint32_t hotpatch_table_offset() const {
    return hotpatch_table_offset_;
  }

  void guard_rf_verify_stackpointer_function_pointer(uint64_t value) {
    guardrf_verify_stackpointer_function_pointer_ = value;
  }
  void hotpatch_table_offset(uint32_t value) {
    hotpatch_table_offset_ = value;
  }

  static bool classof(const LoadConfiguration* config) {
    return config->version() == WIN_VERSION;
  }

  ~LoadConfigurationV6() override = default;

  void accept(Visitor& visitor) const override;

  std::ostream& print(std::ostream& os) const override;

  protected:
  uint64_t guardrf_verify_stackpointer_function_pointer_ = 0;
  uint32_t hotpatch_table_offset_ = 0;
};
}
}

#endif

```

`KDemu/include/LIEF/LIEF/PE/LoadConfigurations/LoadConfigurationV7.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_LOAD_CONFIGURATION_V7_H
#define LIEF_PE_LOAD_CONFIGURATION_V7_H
#include <ostream>

#include "LIEF/visibility.h"

#include "LIEF/PE/LoadConfigurations/LoadConfigurationV6.hpp"

namespace LIEF {
namespace PE {

namespace details {
template<class T>
struct load_configuration_v7;
}

class LIEF_API LoadConfigurationV7 : public LoadConfigurationV6 {
  public:

  static constexpr VERSION WIN_VERSION = VERSION::WIN_10_0_16237;
  LoadConfigurationV7() = default;

  template<class T>
  LIEF_LOCAL LoadConfigurationV7(const details::load_configuration_v7<T>& header);

  LoadConfigurationV7& operator=(const LoadConfigurationV7&) = default;
  LoadConfigurationV7(const LoadConfigurationV7&) = default;

  VERSION version() const override {
    return WIN_VERSION;
  }

  uint32_t reserved3() const {
    return reserved3_;
  }
  uint64_t addressof_unicode_string() const {
    return addressof_unicode_string_;
  }

  void reserved3(uint32_t value) {
    reserved3_ = value;
  }
  void addressof_unicode_string(uint64_t value) {
    addressof_unicode_string_ = value;
  }

  static bool classof(const LoadConfiguration* config) {
    return config->version() == WIN_VERSION;
  }

  ~LoadConfigurationV7() override = default;

  void accept(Visitor& visitor) const override;

  std::ostream& print(std::ostream& os) const override;

  protected:
  uint32_t reserved3_ = 0;
  uint64_t addressof_unicode_string_ = 0;
};
}
}

#endif

```

`KDemu/include/LIEF/LIEF/PE/LoadConfigurations/LoadConfigurationV8.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_LOAD_CONFIGURATION_V8_H
#define LIEF_PE_LOAD_CONFIGURATION_V8_H
#include <ostream>

#include "LIEF/visibility.h"

#include "LIEF/PE/enums.hpp"
#include "LIEF/PE/LoadConfigurations/LoadConfigurationV7.hpp"

namespace LIEF {
namespace PE {

namespace details {
template<class T>
struct load_configuration_v8;
}

class LIEF_API LoadConfigurationV8 : public LoadConfigurationV7 {
  public:

  static constexpr VERSION WIN_VERSION = VERSION::WIN_10_0_18362;
  LoadConfigurationV8() = default;

  template<class T>
  LIEF_LOCAL LoadConfigurationV8(const details::load_configuration_v8<T>& header);

  LoadConfigurationV8& operator=(const LoadConfigurationV8&) = default;
  LoadConfigurationV8(const LoadConfigurationV8&) = default;

  VERSION version() const override {
    return WIN_VERSION;
  }

  uint64_t volatile_metadata_pointer() const {
    return volatile_metadata_pointer_;
  }

  void volatile_metadata_pointer(uint64_t value) {
    volatile_metadata_pointer_ = value;
  }

  static bool classof(const LoadConfiguration* config) {
    return config->version() == WIN_VERSION;
  }

  ~LoadConfigurationV8() override = default;

  void accept(Visitor& visitor) const override;

  std::ostream& print(std::ostream& os) const override;

  protected:
  uint64_t volatile_metadata_pointer_ = 0;
};
}
}

#endif

```

`KDemu/include/LIEF/LIEF/PE/LoadConfigurations/LoadConfigurationV9.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_LOAD_CONFIGURATION_V9_H
#define LIEF_PE_LOAD_CONFIGURATION_V9_H
#include <ostream>
#include "LIEF/visibility.h"

#include "LIEF/PE/LoadConfigurations/LoadConfigurationV8.hpp"

namespace LIEF {
namespace PE {

namespace details {
template<class T>
struct load_configuration_v9;
}

class LIEF_API LoadConfigurationV9 : public LoadConfigurationV8 {
  public:

  static constexpr VERSION WIN_VERSION = VERSION::WIN_10_0_19534;
  LoadConfigurationV9() = default;

  template<class T>
  LIEF_LOCAL LoadConfigurationV9(const details::load_configuration_v9<T>& header);

  LoadConfigurationV9& operator=(const LoadConfigurationV9&) = default;
  LoadConfigurationV9(const LoadConfigurationV9&) = default;

  VERSION version() const override {
    return WIN_VERSION;
  }

  uint64_t guard_eh_continuation_table() const {
    return guard_eh_continuation_table_;
  }

  uint64_t guard_eh_continuation_count() const {
    return guard_eh_continuation_count_;
  }

  void guard_eh_continuation_table(uint64_t value) {
    guard_eh_continuation_table_ = value;
  }

  void guard_eh_continuation_count(uint64_t value) {
    guard_eh_continuation_count_ = value;
  }

  static bool classof(const LoadConfiguration* config) {
    return config->version() == WIN_VERSION;
  }

  ~LoadConfigurationV9() override = default;

  void accept(Visitor& visitor) const override;


  std::ostream& print(std::ostream& os) const override;

  protected:
  uint64_t guard_eh_continuation_table_ = 0;
  uint64_t guard_eh_continuation_count_ = 0;
};
}
}

#endif

```

`KDemu/include/LIEF/LIEF/PE/OptionalHeader.h`:

```h
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef C_LIEF_PE_OPTIONAL_HEADER_H
#define C_LIEF_PE_OPTIONAL_HEADER_H
#include <inttypes.h>

#include "LIEF/PE/enums.h"
#include "LIEF/visibility.h"

#ifdef __cplusplus
extern "C" {
#endif

enum LIEF_PE_DLL_CHARACTERISTICS {
  LIEF_PE_DLL_CHARACTERISTICS_HIGH_ENTROPY_VA       = 0x0020, /**< ASLR with 64 bit address space. */
  LIEF_PE_DLL_CHARACTERISTICS_DYNAMIC_BASE          = 0x0040, /**< DLL can be relocated at load time. */
  LIEF_PE_DLL_CHARACTERISTICS_FORCE_INTEGRITY       = 0x0080, /**< Code integrity checks are enforced. */
  LIEF_PE_DLL_CHARACTERISTICS_NX_COMPAT             = 0x0100, /**< Image is NX compatible. */
  LIEF_PE_DLL_CHARACTERISTICS_NO_ISOLATION          = 0x0200, /**< Isolation aware, but do not isolate the image. */
  LIEF_PE_DLL_CHARACTERISTICS_NO_SEH                = 0x0400, /**< Does not use structured exception handling (SEH). No SEH handler may be called in this image. */
  LIEF_PE_DLL_CHARACTERISTICS_NO_BIND               = 0x0800, /**< Do not bind the image. */
  LIEF_PE_DLL_CHARACTERISTICS_APPCONTAINER          = 0x1000, /**< Image should execute in an AppContainer. */
  LIEF_PE_DLL_CHARACTERISTICS_WDM_DRIVER            = 0x2000, /**< A WDM driver. */
  LIEF_PE_DLL_CHARACTERISTICS_GUARD_CF              = 0x4000, /**< Image supports Control Flow Guard. */
  LIEF_PE_DLL_CHARACTERISTICS_TERMINAL_SERVER_AWARE = 0x8000  /**< Terminal Server aware. */
};

enum LIEF_PE_SUBSYSTEM {
  LIEF_PE_SUBSYSTEM_UNKNOWN                  = 0,  /**< An unknown subsystem. */
  LIEF_PE_SUBSYSTEM_NATIVE                   = 1,  /**< Device drivers and native Windows processes */
  LIEF_PE_SUBSYSTEM_WINDOWS_GUI              = 2,  /**< The Windows GUI subsystem. */
  LIEF_PE_SUBSYSTEM_WINDOWS_CUI              = 3,  /**< The Windows character subsystem. */
  LIEF_PE_SUBSYSTEM_OS2_CUI                  = 5,  /**< The OS/2 character subsytem. */
  LIEF_PE_SUBSYSTEM_POSIX_CUI                = 7,  /**< The POSIX character subsystem. */
  LIEF_PE_SUBSYSTEM_NATIVE_WINDOWS           = 8,  /**< Native Windows 9x driver. */
  LIEF_PE_SUBSYSTEM_WINDOWS_CE_GUI           = 9,  /**< Windows CE. */
  LIEF_PE_SUBSYSTEM_EFI_APPLICATION          = 10, /**< An EFI application. */
  LIEF_PE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER  = 11, /**< An EFI driver with boot services. */
  LIEF_PE_SUBSYSTEM_EFI_RUNTIME_DRIVER       = 12, /**< An EFI driver with run-time services. */
  LIEF_PE_SUBSYSTEM_EFI_ROM                  = 13, /**< An EFI ROM image. */
  LIEF_PE_SUBSYSTEM_XBOX                     = 14, /**< XBOX. */
  LIEF_PE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION = 16  /**< A BCD application. */
};

struct Pe_OptionalHeader_t {
  enum LIEF_PE_PE_TYPES  magic;
  uint8_t        major_linker_version;
  uint8_t        minor_linker_version;
  uint32_t       sizeof_code;
  uint32_t       sizeof_initialized_data;
  uint32_t       sizeof_uninitialized_data;
  uint32_t       addressof_entrypoint;
  uint32_t       baseof_code;
  uint32_t       baseof_data;
  uint64_t       imagebase;
  uint32_t       section_alignment;
  uint32_t       file_alignment;
  uint16_t       major_operating_system_version;
  uint16_t       minor_operating_system_version;
  uint16_t       major_image_version;
  uint16_t       minor_image_version;
  uint16_t       major_subsystem_version;
  uint16_t       minor_subsystem_version;
  uint32_t       win32_version_value;
  uint32_t       sizeof_image;
  uint32_t       sizeof_headers;
  uint32_t       checksum;
  enum LIEF_PE_SUBSYSTEM subsystem;
  uint32_t       dll_characteristics;
  uint64_t       sizeof_stack_reserve;
  uint64_t       sizeof_stack_commit;
  uint64_t       sizeof_heap_reserve;
  uint64_t       sizeof_heap_commit;
  uint32_t       loader_flags;
  uint32_t       numberof_rva_and_size;
};

typedef struct Pe_OptionalHeader_t Pe_OptionalHeader_t;

LIEF_API const char* lief_pe_subsytem_str(enum LIEF_PE_SUBSYSTEM e);

#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/include/LIEF/LIEF/PE/OptionalHeader.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_OPTIONAL_HEADER_H
#define LIEF_PE_OPTIONAL_HEADER_H
#include <ostream>
#include <vector>
#include <cstdint>

#include "LIEF/Object.hpp"
#include "LIEF/visibility.h"

#include "LIEF/enums.hpp"
#include "LIEF/PE/enums.hpp"

namespace LIEF {
namespace PE {
class Parser;
class Binary;

namespace details {
struct pe32_optional_header;
struct pe64_optional_header;
}

//! Class which represents the PE OptionalHeader structure
//!
//! Note that the term *optional* comes from the COFF specifications but this
//! header is **mandatory** for a PE binary.
class LIEF_API OptionalHeader : public Object {
  friend class Parser;
  friend class Binary;
  public:

  enum class DLL_CHARACTERISTICS: size_t  {
    HIGH_ENTROPY_VA       = 0x0020, ///< ASLR with 64 bit address space.
    DYNAMIC_BASE          = 0x0040, ///< DLL can be relocated at load time.
    FORCE_INTEGRITY       = 0x0080, ///< Code integrity checks are enforced.
    NX_COMPAT             = 0x0100, ///< Image is NX compatible.
    NO_ISOLATION          = 0x0200, ///< Isolation aware, but do not isolate the image.
    NO_SEH                = 0x0400, ///< Does not use structured exception handling (SEH). No SEH handler may be called in this image.
    NO_BIND               = 0x0800, ///< Do not bind the image.
    APPCONTAINER          = 0x1000, ///< Image should execute in an AppContainer.
    WDM_DRIVER            = 0x2000, ///< A WDM driver.
    GUARD_CF              = 0x4000, ///< Image supports Control Flow Guard.
    TERMINAL_SERVER_AWARE = 0x8000  ///< Terminal Server aware.
  };

  enum class SUBSYSTEM: size_t  {
    UNKNOWN                  = 0,  ///< An unknown subsystem.
    NATIVE                   = 1,  ///< Device drivers and native Windows processes
    WINDOWS_GUI              = 2,  ///< The Windows GUI subsystem.
    WINDOWS_CUI              = 3,  ///< The Windows character subsystem.
    OS2_CUI                  = 5,  ///< The OS/2 character subsytem.
    POSIX_CUI                = 7,  ///< The POSIX character subsystem.
    NATIVE_WINDOWS           = 8,  ///< Native Windows 9x driver.
    WINDOWS_CE_GUI           = 9,  ///< Windows CE.
    EFI_APPLICATION          = 10, ///< An EFI application.
    EFI_BOOT_SERVICE_DRIVER  = 11, ///< An EFI driver with boot services.
    EFI_RUNTIME_DRIVER       = 12, ///< An EFI driver with run-time services.
    EFI_ROM                  = 13, ///< An EFI ROM image.
    XBOX                     = 14, ///< XBOX.
    WINDOWS_BOOT_APPLICATION = 16  ///< A BCD application.
  };

  OptionalHeader(const details::pe32_optional_header& header);
  OptionalHeader(const details::pe64_optional_header& header);
  ~OptionalHeader() override = default;

  OptionalHeader& operator=(const OptionalHeader&) = default;
  OptionalHeader(const OptionalHeader&) = default;

  static OptionalHeader create(PE_TYPE type);

  //! Magic bytes: either ``PE32`` or ``PE32+`` for 64-bits PE files
  PE_TYPE magic() const {
    return magic_;
  }

  //! The linker major version
  uint8_t major_linker_version() const {
    return major_linker_version_;
  }

  //! The linker minor version
  uint8_t minor_linker_version() const {
    return minor_linker_version_;
  }

  //! The size of the code ``.text`` section or the sum of
  //! all the sections that contain code (i.e. PE::Section with the flag Section::CHARACTERISTICS::CNT_CODE)
  uint32_t sizeof_code() const {
    return sizeof_code_;
  }

  //! The size of the initialized data which are usually located in the ``.data`` section.
  //! If the initialized data are split across multiple sections, it is the sum of the sections.
  //!
  //! The sections associated with the initialized data are usually identified with the
  //! flag Section::CHARACTERISTICS::CNT_INITIALIZED_DATA
  uint32_t sizeof_initialized_data() const {
    return sizeof_initialized_data_;
  }

  //! The size of the uninitialized data which are usually located in the ``.bss`` section.
  //! If the uninitialized data are split across multiple sections, it is the sum of the sections.
  //!
  //! The sections associated with the uninitialized data are usually identified with the
  //! flag Section::CHARACTERISTICS::CNT_UNINITIALIZED_DATA
  uint32_t sizeof_uninitialized_data() const {
    return sizeof_uninitialized_data_;
  }

  //! The address of the entry point relative to the image base when the executable file is
  //! loaded into memory. For program images, this is the starting address. For device
  //! drivers, this is the address of the initialization function.
  //!
  //! An entry point is optional for DLLs. When no entry point is present, this field must be zero.
  uint32_t addressof_entrypoint() const {
    return entrypoint_;
  }

  //! Address relative to the imagebase where the binary's code starts.
  uint32_t baseof_code() const {
    return baseof_code_;
  }

  //! Address relative to the imagebase where the binary's data starts.
  //!
  //! @warning This value is not present for PE64 files
  uint32_t baseof_data() const {
    return baseof_data_;
  }

  //! The preferred base address when mapping the binary in memory
  uint64_t imagebase() const {
    return imagebase_;
  }

  //! The alignment (in bytes) of sections when they are loaded into memory.
  //!
  //! It must be greater than or equal to file_alignment and
  //! the default is the page size for the architecture.
  uint32_t section_alignment() const {
    return section_align_;
  }

  //! The section's file alignment. This value must be a power of 2 between 512 and 64K.
  //! The default value is usually 512
  uint32_t file_alignment() const {
    return file_align_;
  }

  //! The **major** version number of the required operating system
  uint16_t major_operating_system_version() const {
    return major_os_version_;
  }

  //! The **minor** version number of the required operating system
  uint16_t minor_operating_system_version() const {
    return minor_os_version_;
  }

  //! The major version number of the image
  uint16_t major_image_version() const {
    return major_image_version_;
  }

  //! The minor version number of the image
  uint16_t minor_image_version() const {
    return minor_image_version_;
  }

  //! The major version number of the subsystem
  uint16_t major_subsystem_version() const {
    return major_subsys_version_;
  }

  //! The minor version number of the subsystem
  uint16_t minor_subsystem_version() const {
    return minor_subsys_version_;
  }

  //! According to the official PE specifications, this value
  //! is reserved and **should** be 0.
  uint32_t win32_version_value() const {
    return win32_version_value_;
  }

  //! The size (in bytes) of the image, including all headers, as the image is loaded in memory.
  //!
  //! It must be a multiple of section_alignment and should match Binary::virtual_size
  uint32_t sizeof_image() const {
    return sizeof_image_;
  }

  //! Size of the DosHeader + PE Header + Section headers rounded up to a multiple of the file_alignment
  uint32_t sizeof_headers() const {
    return sizeof_headers_;
  }

  //! The image file checksum. The algorithm for computing the checksum is incorporated into ``IMAGHELP.DLL``.
  //!
  //! The following are checked for validation at load time all **drivers**, any **DLL loaded at boot**
  //! time, and any **DLL** that is loaded into a **critical** Windows process.
  uint32_t checksum() const {
    return checksum_;
  }

  //! Target subsystem like Driver, XBox, Windows GUI, ...
  SUBSYSTEM subsystem() const {
    return subsystem_;
  }

  //! Some characteristics of the underlying binary like the support of the PIE.
  //! The prefix ``dll`` comes from the official PE specifications but these characteristics
  //! are also used for **executables**
  uint32_t dll_characteristics() const {
    return dll_characteristics_;
  }

  //! Size of the stack to reserve when loading the PE binary
  //!
  //! Only OptionalHeader::sizeof_stack_commit is committed, the rest is made
  //! available one page at a time until the reserve size is reached.
  uint64_t sizeof_stack_reserve() const {
    return sizeof_stack_reserve_;
  }

  //! Size of the stack to commit
  uint64_t sizeof_stack_commit() const {
    return sizeof_stack_commit_;
  }

  //! Size of the heap to reserve when loading the PE binary
  uint64_t sizeof_heap_reserve() const {
    return sizeof_heap_reserve_;
  }

  //! Size of the heap to commit
  uint64_t sizeof_heap_commit() const {
    return sizeof_heap_commit_;
  }

  //! According to the PE specifications, this value is *reserved* and **should** be 0.
  uint32_t loader_flags() const {
    return loader_flags_;
  }

  //! The number of DataDirectory that follow this header.
  uint32_t numberof_rva_and_size() const {
    return nb_rva_size_;
  }

  //! Check if the given DLL_CHARACTERISTICS is included in the dll_characteristics
  bool has(DLL_CHARACTERISTICS c) const {
    return (dll_characteristics() & static_cast<uint32_t>(c)) != 0;
  }

  //! Return the list of the dll_characteristics as an std::set of DLL_CHARACTERISTICS
  std::vector<DLL_CHARACTERISTICS> dll_characteristics_list() const;

  //! Add a DLL_CHARACTERISTICS to the current characteristics
  void add(DLL_CHARACTERISTICS c) {
    dll_characteristics(dll_characteristics() | static_cast<uint32_t>(c));
  }

  //! Remove a DLL_CHARACTERISTICS from the current characteristics
  void remove(DLL_CHARACTERISTICS c) {
    dll_characteristics(dll_characteristics() & (~ static_cast<uint32_t>(c)));
  }

  void magic(PE_TYPE magic) {
    magic_ = magic;
  }

  void major_linker_version(uint8_t value) {
    major_linker_version_ = value;
  }

  void minor_linker_version(uint8_t value) {
    minor_linker_version_ = value;
  }

  void sizeof_code(uint32_t value) {
    sizeof_code_ = value;
  }

  void sizeof_initialized_data(uint32_t value) {
    sizeof_initialized_data_ = value;
  }

  void sizeof_uninitialized_data(uint32_t value) {
    sizeof_uninitialized_data_ = value;
  }

  void addressof_entrypoint(uint32_t value) {
    entrypoint_ = value;
  }

  void baseof_code(uint32_t value) {
    baseof_code_ = value;
  }

  void baseof_data(uint32_t value) {
    baseof_data_ = value;
  }

  void imagebase(uint64_t value) {
    imagebase_ = value;
  }

  void section_alignment(uint32_t value) {
    section_align_ = value;
  }

  void file_alignment(uint32_t value) {
    file_align_ = value;
  }

  void major_operating_system_version(uint16_t value) {
    major_os_version_ = value;
  }

  void minor_operating_system_version(uint16_t value) {
    minor_os_version_ = value;
  }

  void major_image_version(uint16_t value) {
    major_image_version_ = value;
  }

  void minor_image_version(uint16_t value) {
    minor_image_version_ = value;
  }

  void major_subsystem_version(uint16_t value) {
    major_subsys_version_ = value;
  }

  void minor_subsystem_version(uint16_t value) {
    minor_subsys_version_ = value;
  }

  void win32_version_value(uint32_t value) {
    win32_version_value_ = value;
  }

  void sizeof_image(uint32_t value) {
    sizeof_image_ = value;
  }

  void sizeof_headers(uint32_t value) {
    sizeof_headers_ = value;
  }

  void checksum(uint32_t value) {
    checksum_ = value;
  }

  void subsystem(SUBSYSTEM value) {
    subsystem_ = value;
  }

  void dll_characteristics(uint32_t value) {
    dll_characteristics_ = value;
  }

  void sizeof_stack_reserve(uint64_t value) {
    sizeof_stack_reserve_ = value;
  }

  void sizeof_stack_commit(uint64_t value) {
    sizeof_stack_commit_ = value;
  }

  void sizeof_heap_reserve(uint64_t value) {
    sizeof_heap_reserve_ = value;
  }

  void sizeof_heap_commit(uint64_t value) {
    sizeof_heap_commit_ = value;
  }

  void loader_flags(uint32_t value) {
    loader_flags_ = value;
  }

  void numberof_rva_and_size(uint32_t value) {
    nb_rva_size_ = value;
  }

  void accept(Visitor& visitor) const override;

  OptionalHeader& operator+=(DLL_CHARACTERISTICS c) {
    add(c);
    return *this;
  }
  OptionalHeader& operator-=(DLL_CHARACTERISTICS c) {
    remove(c);
    return *this;
  }

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const OptionalHeader& entry);

  private:
  OptionalHeader() = default;

  PE_TYPE   magic_ = PE_TYPE::PE32;
  uint8_t   major_linker_version_ = 0;
  uint8_t   minor_linker_version_ = 0;
  uint32_t  sizeof_code_ = 0;
  uint32_t  sizeof_initialized_data_ = 0;
  uint32_t  sizeof_uninitialized_data_ = 0;
  uint32_t  entrypoint_ = 0;
  uint32_t  baseof_code_ = 0;
  uint32_t  baseof_data_ = 0;
  uint64_t  imagebase_ = 0;
  uint32_t  section_align_ = 0;
  uint32_t  file_align_ = 0;
  uint16_t  major_os_version_ = 0;
  uint16_t  minor_os_version_ = 0;
  uint16_t  major_image_version_ = 0;
  uint16_t  minor_image_version_ = 0;
  uint16_t  major_subsys_version_ = 0;
  uint16_t  minor_subsys_version_ = 0;
  uint32_t  win32_version_value_ = 0;
  uint32_t  sizeof_image_ = 0;
  uint32_t  sizeof_headers_ = 0;
  uint32_t  checksum_ = 0;
  SUBSYSTEM subsystem_ = SUBSYSTEM::UNKNOWN;
  uint32_t  dll_characteristics_ = 0;
  uint64_t  sizeof_stack_reserve_ = 0;
  uint64_t  sizeof_stack_commit_ = 0;
  uint64_t  sizeof_heap_reserve_ = 0;
  uint64_t  sizeof_heap_commit_ = 0;
  uint32_t  loader_flags_ = 0;
  uint32_t  nb_rva_size_ = 0;
};

LIEF_API const char* to_string(OptionalHeader::DLL_CHARACTERISTICS);
LIEF_API const char* to_string(OptionalHeader::SUBSYSTEM);

}
}

ENABLE_BITMASK_OPERATORS(LIEF::PE::OptionalHeader::DLL_CHARACTERISTICS);

#endif

```

`KDemu/include/LIEF/LIEF/PE/Parser.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_PARSER_H
#define LIEF_PE_PARSER_H

#include <set>
#include <string>
#include <vector>

#include "LIEF/visibility.h"
#include "LIEF/utils.hpp"
#include "LIEF/errors.hpp"

#include "LIEF/Abstract/Parser.hpp"
#include "LIEF/PE/enums.hpp"
#include "LIEF/PE/ParserConfig.hpp"

namespace LIEF {
class BinaryStream;

namespace PE {
class Debug;
class ResourceNode;
class Binary;
class DelayImport;

namespace details {
struct pe_resource_directory_table;
struct pe_debug;
}

//! Main interface to parse PE binaries. In particular the **static** functions:
//! Parser::parse should be used to get a LIEF::PE::Binary
class LIEF_API Parser : public LIEF::Parser {
  public:

  //! Maximum size of the data read
  static constexpr size_t MAX_DATA_SIZE = 3_GB;

  static constexpr size_t MAX_TLS_CALLBACKS = 3000;

  // According to https://stackoverflow.com/a/265782/87207
  static constexpr size_t MAX_DLL_NAME_SIZE = 255;

  //! Max size of the padding section
  static constexpr size_t MAX_PADDING_SIZE = 1_GB;

  public:
  //! Check if the given name is a valid import.
  //!
  //! This check verified that:
  //!   1. The name is not too large or empty (cf. https://stackoverflow.com/a/23340781)
  //!   2. All the characters are printable
  static bool is_valid_import_name(const std::string& name);

  //! Check if the given name is a valid DLL name.
  //!
  //! This check verifies that:
  //!   1. The name of the DLL is at 4
  //!   2. All the characters are printable
  static bool is_valid_dll_name(const std::string& name);

  public:
  //! Parse a PE binary from the given filename
  static std::unique_ptr<Binary> parse(const std::string& filename,
                                       const ParserConfig& conf = ParserConfig::all());

  //! Parse a PE binary from a data buffer
  static std::unique_ptr<Binary> parse(std::vector<uint8_t> data,
                                       const ParserConfig& conf = ParserConfig::all());

  //! Parse a PE binary from the given BinaryStream
  static std::unique_ptr<Binary> parse(std::unique_ptr<BinaryStream> stream,
                                       const ParserConfig& conf = ParserConfig::all());

  Parser& operator=(const Parser& copy) = delete;
  Parser(const Parser& copy)            = delete;

  private:
  Parser(const std::string& file);
  Parser(std::vector<uint8_t> data);
  Parser(std::unique_ptr<BinaryStream> stream);

  ~Parser() override;
  Parser();

  void init(const ParserConfig& config);

  template<typename PE_T>
  ok_error_t parse();

  ok_error_t parse_exports();
  ok_error_t parse_sections();

  template<typename PE_T>
  ok_error_t parse_headers();

  ok_error_t parse_configuration();

  template<typename PE_T>
  ok_error_t parse_data_directories();

  template<typename PE_T>
  ok_error_t parse_import_table();

  template<typename PE_T>
  ok_error_t parse_delay_imports();

  template<typename PE_T>
  ok_error_t parse_delay_names_table(DelayImport& import, uint32_t names_offset);

  ok_error_t parse_export_table();
  ok_error_t parse_debug();

  std::unique_ptr<Debug> parse_code_view(const details::pe_debug& debug_info);
  std::unique_ptr<Debug> parse_pogo(const details::pe_debug& debug_info);
  std::unique_ptr<Debug> parse_repro(const details::pe_debug& debug_info);

  template<typename PE_T>
  ok_error_t parse_tls();

  template<typename PE_T>
  ok_error_t parse_load_config();

  ok_error_t parse_relocations();
  ok_error_t parse_resources();
  ok_error_t parse_string_table();
  ok_error_t parse_symbols();
  ok_error_t parse_signature();
  ok_error_t parse_overlay();
  ok_error_t parse_dos_stub();
  ok_error_t parse_rich_header();

  std::unique_ptr<ResourceNode> parse_resource_node(
      const details::pe_resource_directory_table& directory_table,
      uint32_t base_offset, uint32_t current_offset, uint32_t depth = 0);


  PE_TYPE type_ = PE_TYPE::PE32_PLUS;
  std::unique_ptr<Binary> binary_;
  std::set<uint32_t> resource_visited_;
  std::unique_ptr<BinaryStream> stream_;
  ParserConfig config_;
};


}
}
#endif

```

`KDemu/include/LIEF/LIEF/PE/ParserConfig.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_PARSER_CONFIG_H
#define LIEF_PE_PARSER_CONFIG_H
#include "LIEF/visibility.h"

namespace LIEF {
namespace PE {

//! This structure is used to tweak the PE Parser (PE::Parser)
struct LIEF_API ParserConfig {
  static ParserConfig all() {
    static const ParserConfig DEFAULT;
    return DEFAULT;
  }

  bool parse_signature = true; ///< Parse PE Authenticode signature
  bool parse_exports   = true; ///< Parse PE Exports Directory
  bool parse_imports   = true; ///< Parse PE Import Directory
  bool parse_rsrc      = true; ///< Parse PE resources tree
  bool parse_reloc     = true; ///< Parse PE relocations
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/PE/Relocation.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_RELOCATION_H
#define LIEF_PE_RELOCATION_H
#include <vector>
#include <ostream>
#include <memory>

#include "LIEF/Object.hpp"
#include "LIEF/visibility.h"
#include "LIEF/iterators.hpp"

namespace LIEF {
namespace PE {

class RelocationEntry;

namespace details {
struct pe_base_relocation_block;
}

//! Class which represents the *Base Relocation Block*
//! We usually find this structure in the ``.reloc`` section
class LIEF_API Relocation : public Object {
  friend class Parser;
  friend class Builder;

  public:
  using entries_t        = std::vector<std::unique_ptr<RelocationEntry>>;
  using it_entries       = ref_iterator<entries_t&, RelocationEntry*>;
  using it_const_entries = const_ref_iterator<const entries_t&, RelocationEntry*>;

  Relocation() = default;
  Relocation(const Relocation& other);
  Relocation& operator=(Relocation other);
  Relocation(const details::pe_base_relocation_block& header);
  ~Relocation() override = default;

  void swap(Relocation& other);

  //! The RVA for which the offset of the relocation entries (RelocationEntry) is added
  uint32_t virtual_address() const {
    return virtual_address_;
  }

  //! The total number of bytes in the base relocation block.
  //! ``block_size = sizeof(BaseRelocationBlock) + nb_of_relocs * sizeof(uint16_t = RelocationEntry)``
  uint32_t block_size() const {
    return block_size_;
  }

  //! Iterator over the RelocationEntry
  it_const_entries entries() const {
    return entries_;
  }
  it_entries entries() {
    return entries_;
  }

  void virtual_address(uint32_t virtual_address) {
    virtual_address_ = virtual_address;
  }
  void block_size(uint32_t block_size) {
    block_size_ = block_size;
  }

  RelocationEntry& add_entry(const RelocationEntry& entry);

  void accept(Visitor& visitor) const override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const Relocation& relocation);

  private:
  uint32_t  block_size_ = 0;
  uint32_t  virtual_address_ = 0;
  entries_t entries_;
};

}
}
#endif /* RELOCATION_H */

```

`KDemu/include/LIEF/LIEF/PE/RelocationEntry.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_RELOCATION_ENTRY_H
#define LIEF_PE_RELOCATION_ENTRY_H

#include <ostream>

#include "LIEF/Abstract/Relocation.hpp"

#include "LIEF/Object.hpp"
#include "LIEF/visibility.h"

#include "LIEF/PE/Header.hpp"

namespace LIEF {
namespace PE {

class Relocation;

//! Class which represents an entry of the PE relocation table
//!
//! It extends the LIEF::Relocation object to provide an uniform API across the file formats
class LIEF_API RelocationEntry : public LIEF::Relocation {

  friend class Parser;
  friend class Builder;
  friend class PE::Relocation;

  public:
  enum class BASE_TYPES {
    UNKNOWN        = -1,

    ABS            = 0,
    HIGH           = 1,
    LOW            = 2,
    HIGHLOW        = 3,
    HIGHADJ        = 4,

    MIPS_JMPADDR   = 5,
    ARM_MOV32A     = 5 + 0x101,
    ARM_MOV32      = 5 + 0x102,
    RISCV_HI20     = 5 + 0x103,

    SECTION        = 6,

    REL            = 7,
    ARM_MOV32T     = 7 + 0x201,
    THUMB_MOV32    = 7 + 0x202,
    RISCV_LOW12I   = 7 + 0x203,

    RISCV_LOW12S   = 8,

    IA64_IMM64     = 9,
    MIPS_JMPADDR16 = 9 + 0x300,

    DIR64          = 10,
    HIGH3ADJ       = 11,
  };
  static RelocationEntry from_raw(Header::MACHINE_TYPES arch, uint16_t raw) {
    return RelocationEntry(raw, arch);
  }

  RelocationEntry() = default;
  RelocationEntry(const RelocationEntry& other);
  RelocationEntry& operator=(RelocationEntry other);

  RelocationEntry(uint16_t position, BASE_TYPES type);
  ~RelocationEntry() override = default;

  void swap(RelocationEntry& other);

  //! The address of the relocation
  uint64_t address() const override;

  void address(uint64_t address) override;

  //! The size of the relocatable pointer
  size_t size() const override;

  void size(size_t size) override;

  //! Raw data of the relocation:
  //! - The **high** 4 bits store the relocation type
  //! - The **low** 12 bits store the relocation offset
  uint16_t data() const;

  //! Offset relative to Relocation::virtual_address where the relocation occurs.
  uint16_t position() const {
    return position_;
  }

  //! Type of the relocation
  BASE_TYPES type() const {
    return type_;
  }

  void data(uint16_t data);

  void position(uint16_t position) {
    position_ = position;
  }

  void type(BASE_TYPES type) {
    type_ = type;
  }

  void accept(Visitor& visitor) const override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const RelocationEntry& entry);

  private:
  RelocationEntry(uint16_t data, Header::MACHINE_TYPES arch);

  uint16_t               position_ = 0;
  BASE_TYPES             type_ = BASE_TYPES::ABS;
  Header::MACHINE_TYPES  arch_ = Header::MACHINE_TYPES::UNKNOWN;
  PE::Relocation*        relocation_ = nullptr; // Used to compute some information
};

LIEF_API const char* to_string(RelocationEntry::BASE_TYPES e);

}
}
#endif

```

`KDemu/include/LIEF/LIEF/PE/ResourceData.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_RESOURCE_DATA_H
#define LIEF_PE_RESOURCE_DATA_H

#include <vector>

#include "LIEF/visibility.h"
#include "LIEF/PE/ResourceNode.hpp"
#include "LIEF/span.hpp"

namespace LIEF {
namespace PE {

class Parser;
class Builder;

//! Class which represents a Data Node in the PE resources tree
class LIEF_API ResourceData : public ResourceNode {

  friend class Parser;
  friend class Builder;

  public:
  ResourceData() :
    ResourceNode(ResourceNode::TYPE::DATA)
  {}
  ResourceData(std::vector<uint8_t> content, uint32_t code_page) :
    ResourceNode(ResourceNode::TYPE::DATA),
    content_(std::move(content)),
    code_page_(code_page)
  {}

  ResourceData(const ResourceData& other) = default;
  ResourceData& operator=(const ResourceData& other) = default;
  void swap(ResourceData& other) noexcept;

  ~ResourceData() override = default;

  std::unique_ptr<ResourceNode> clone() const override {
    return std::unique_ptr<ResourceNode>{new ResourceData{*this}};
  }

  //! Return the code page that is used to decode code point
  //! values within the resource data. Typically, the code page is the unicode code page.
  uint32_t code_page() const {
    return code_page_;
  }

  //! Resource content
  span<const uint8_t> content() const {
    return content_;
  }
  span<uint8_t> content() {
    return content_;
  }

  //! Reserved value. Should be ``0``
  uint32_t reserved() const {
    return reserved_;
  }

  //! Offset of the content within the resource
  //!
  //! @warning This value may change when rebuilding resource table
  uint32_t offset() const {
    return offset_;
  }

  void code_page(uint32_t code_page) {
    code_page_ = code_page;
  }

  void content(std::vector<uint8_t> content) {
    content_ = std::move(content);
  }

  void reserved(uint32_t value) {
    reserved_ = value;
  }

  static bool classof(const ResourceNode* node) {
    return node->is_data();
  }

  void accept(Visitor& visitor) const override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const ResourceData& data);

  private:
  std::vector<uint8_t> content_;
  uint32_t code_page_ = 0;
  uint32_t reserved_ = 0;
  uint32_t offset_ = 0;

};

} // namespace PE
} // namepsace LIEF
#endif /* RESOURCEDATA_H */

```

`KDemu/include/LIEF/LIEF/PE/ResourceDirectory.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_RESOURCE_DIRECTORY_H
#define LIEF_PE_RESOURCE_DIRECTORY_H

#include "LIEF/visibility.h"

#include "LIEF/PE/ResourceNode.hpp"

namespace LIEF {
namespace PE {

class Parser;
class Builder;

namespace details {
struct pe_resource_directory_table;
}

class LIEF_API ResourceDirectory : public ResourceNode {

  friend class Parser;
  friend class Builder;

  public:
  ResourceDirectory() :
    ResourceNode(ResourceNode::TYPE::DIRECTORY)
  {}
  ResourceDirectory(const details::pe_resource_directory_table& header);

  ResourceDirectory(const ResourceDirectory& other) = default;
  ResourceDirectory& operator=(const ResourceDirectory& other) = default;

  void swap(ResourceDirectory& other) noexcept;

  ~ResourceDirectory() override = default;

  std::unique_ptr<ResourceNode> clone() const override {
    return std::unique_ptr<ResourceNode>(new ResourceDirectory{*this});
  }

  //! Resource characteristics. This field is reserved for future use.
  //! It is currently set to zero.
  uint32_t characteristics() const {
    return characteristics_;
  }

  //! The time that the resource data was created by the
  //! resource compiler.
  uint32_t time_date_stamp() const {
    return timedatestamp_;
  }

  //! The major version number, set by the user.
  uint16_t major_version() const {
    return majorversion_;
  }

  //! The minor version number, set by the user.
  uint16_t minor_version() const {
    return minorversion_;
  }

  //! The number of directory entries immediately
  //! following the table that use strings to identify Type,
  //! Name, or Language entries (depending on the level of the table).
  uint16_t numberof_name_entries() const {
    return numberof_name_entries_;
  }

  //! The number of directory entries immediately
  //! following the Name entries that use numeric IDs for
  //! Type, Name, or Language entries.
  uint16_t numberof_id_entries() const {
    return numberof_id_entries_;
  }

  void characteristics(uint32_t characteristics) {
    characteristics_ = characteristics;
  }
  void time_date_stamp(uint32_t time_date_stamp) {
    timedatestamp_ = time_date_stamp;
  }
  void major_version(uint16_t major_version) {
    majorversion_ = major_version;
  }
  void minor_version(uint16_t minor_version) {
    minorversion_ = minor_version;
  }
  void numberof_name_entries(uint16_t numberof_name_entries) {
    numberof_name_entries_ = numberof_name_entries;
  }
  void numberof_id_entries(uint16_t numberof_id_entries) {
    numberof_id_entries_ = numberof_id_entries;
  }

  static bool classof(const ResourceNode* node) {
    return node->is_directory();
  }

  void accept(Visitor& visitor) const override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const ResourceDirectory& directory);

  private:
  uint32_t characteristics_ = 0;
  uint32_t timedatestamp_ = 0;
  uint16_t majorversion_ = 0;
  uint16_t minorversion_ = 0;
  uint16_t numberof_name_entries_ = 0;
  uint16_t numberof_id_entries_ = 0;

};
}
}
#endif /* RESOURCEDIRECTORY_H */

```

`KDemu/include/LIEF/LIEF/PE/ResourceNode.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_RESOURCE_NODE_H
#define LIEF_PE_RESOURCE_NODE_H
#include <string>
#include <vector>
#include <memory>

#include "LIEF/Object.hpp"
#include "LIEF/visibility.h"
#include "LIEF/iterators.hpp"

namespace LIEF {
namespace PE {

class ResourceDirectory;
class ResourceData;

class Parser;
class Builder;

//! Class which represents a Node in the resource tree.
class LIEF_API ResourceNode : public Object {

  friend class Parser;
  friend class Builder;

  public:
  using childs_t        = std::vector<std::unique_ptr<ResourceNode>>;
  using it_childs       = ref_iterator<childs_t&, ResourceNode*>;
  using it_const_childs = const_ref_iterator<const childs_t&, ResourceNode*>;

  /// Enum that identifies the type of a node in the resource tree
  enum class TYPE {
    UNKNOWN = 0,
    DATA,
    DIRECTORY,
  };

  ResourceNode(const ResourceNode& other);
  ResourceNode& operator=(const ResourceNode& other);

  ResourceNode(ResourceNode&& other);
  ResourceNode& operator=(ResourceNode&& other);

  void swap(ResourceNode& other);

  ~ResourceNode() override;

  virtual std::unique_ptr<ResourceNode> clone() const = 0;

  //! Integer that identifies the Type, Name, or Language ID of the entry
  //! depending on its depth in the tree
  uint32_t id() const {
    return id_;
  }

  //! Name of the entry
  const std::u16string& name() const {
    return name_;
  }

  //! Iterator on node's children
  it_childs childs() {
    return childs_;
  }
  it_const_childs childs() const {
    return childs_;
  }

  //! ``True`` if the entry uses a name as ID
  bool has_name() const {
    return static_cast<bool>(id() & 0x80000000);
  }

  //! Current depth of the Node in the resource tree
  uint32_t depth() const {
    return depth_;
  }

  //! ``True`` if the current entry is a ResourceDirectory.
  //!
  //! It can be safely casted with:
  //!
  //! ```cpp
  //! const auto& dir_node = static_cast<const ResourceDirectory&>(node);
  //! ```
  bool is_directory() const {
    return type_ == TYPE::DIRECTORY;
  }

  //! ``True`` if the current entry is a ResourceData.
  //!
  //! It can be safely casted with:
  //!
  //! ```cpp
  //! const auto& data_node = static_cast<const ResourceData&>(node);
  //! ```
  bool is_data() const {
    return type_ == TYPE::DATA;
  }

  void id(uint32_t id) {
    id_ = id;
  }
  void name(const std::string& name);

  void name(std::u16string name) {
    name_ = std::move(name);
  }

  //! Add a ResourceDirectory to the current node
  ResourceNode& add_child(const ResourceDirectory& child);

  //! Add a ResourceData to the current node
  ResourceNode& add_child(const ResourceData& child);

  //! Delete the node with the given ``id``
  void delete_child(uint32_t id);

  //! Delete the given node from the node's children
  void delete_child(const ResourceNode& node);

  void accept(Visitor& visitor) const override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const ResourceNode& node);

  protected:
  ResourceNode();
  ResourceNode(TYPE type);
  childs_t::iterator insert_child(std::unique_ptr<ResourceNode> child);
  TYPE           type_ = TYPE::UNKNOWN;
  uint32_t       id_ = 0;
  std::u16string name_;
  childs_t       childs_;
  uint32_t       depth_ = 0;
};
}
}
#endif /* RESOURCENODE_H */

```

`KDemu/include/LIEF/LIEF/PE/ResourcesManager.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 * Copyright 2017 - 2021 K. Nakagawa
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_RESOURCES_MANAGER_H
#define LIEF_PE_RESOURCES_MANAGER_H
#include <ostream>

#include "LIEF/errors.hpp"
#include "LIEF/visibility.h"
#include "LIEF/Object.hpp"

#include "LIEF/PE/resources/ResourceVersion.hpp"
#include "LIEF/PE/resources/ResourceIcon.hpp"
#include "LIEF/PE/resources/ResourceDialog.hpp"
#include "LIEF/PE/resources/ResourceStringTable.hpp"
#include "LIEF/PE/resources/ResourceAccelerator.hpp"

namespace LIEF {
class VectorStream;

namespace PE {
class ResourceNode;

//! The Resource Manager provides an enhanced API to manipulate the resource tree.
class LIEF_API ResourcesManager : public Object {
  public:

  /// The different types of resources
  /// Ref: From https://docs.microsoft.com/en-us/windows/win32/menurc/resource-types
  enum class TYPE {
    CURSOR       = 1,
    BITMAP       = 2,
    ICON         = 3,
    MENU         = 4,
    DIALOG       = 5,
    STRING       = 6,
    FONTDIR      = 7,
    FONT         = 8,
    ACCELERATOR  = 9,
    RCDATA       = 10,
    MESSAGETABLE = 11,
    GROUP_CURSOR = 12,
    GROUP_ICON   = 14,
    VERSION      = 16,
    DLGINCLUDE   = 17,
    PLUGPLAY     = 19,
    VXD          = 20,
    ANICURSOR    = 21,
    ANIICON      = 22,
    HTML         = 23,
    MANIFEST     = 24
  };

  static constexpr uint32_t lang_from_id(size_t id) {
    return id & 0x3ff;
  }

  static constexpr uint32_t sublang_from_id(size_t id) {
    return id >> 10;
  }

  public:
  using dialogs_t = std::vector<ResourceDialog>;
  using it_const_dialogs = const_ref_iterator<dialogs_t>;

  using icons_t = std::vector<ResourceIcon>;
  using it_const_icons = const_ref_iterator<icons_t>;

  using strings_table_t = std::vector<ResourceStringTable>;
  using it_const_strings_table = const_ref_iterator<strings_table_t>;

  using accelerators_t = std::vector<ResourceAccelerator>;
  using it_const_accelerators = const_ref_iterator<accelerators_t>;

  ResourcesManager() = delete;
  ResourcesManager(ResourceNode& rsrc) :
    resources_{&rsrc}
  {}

  ResourcesManager(const ResourcesManager&) = default;
  ResourcesManager& operator=(const ResourcesManager&) = default;

  ResourcesManager(ResourcesManager&&) = default;
  ResourcesManager& operator=(ResourcesManager&&) = default;

  ~ResourcesManager() override = default;

  //! Return the ResourceNode associated with the given KIND
  //! or a nullptr if not found;
  ResourceNode*       get_node_type(TYPE type);
  const ResourceNode* get_node_type(TYPE type) const;

  //! List of TYPE present in the resources
  std::vector<TYPE> get_types() const;

  //! ``true`` if the resource has the given LIEF::PE::KIND
  bool has_type(TYPE type) const {
    return get_node_type(type) != nullptr;
  }

    //! ``true`` if resources contain the Manifest element
  bool has_manifest() const {
    return get_node_type(TYPE::MANIFEST) != nullptr;
  }

  //! Return the manifest as a std::string or an empty string if not found
  //! or corrupted
  std::string manifest() const;

  //! Update the manifest with the given string
  void manifest(const std::string& manifest);

  //! ``true`` if resources contain a LIEF::PE::ResourceVersion
  bool has_version() const {
    return get_node_type(TYPE::VERSION) != nullptr;
  }

  //! Return the ResourceVersion if any
  result<ResourceVersion> version() const;

  //! ``true`` if resources contain a LIEF::PE::ResourceIcon
  bool has_icons() const {
    return get_node_type(TYPE::ICON)       != nullptr &&
           get_node_type(TYPE::GROUP_ICON) != nullptr;
  }

  //! Return the list of the icons present in the resources
  it_const_icons icons() const;

  //! Add an icon to the resources
  void add_icon(const ResourceIcon& icon);

  void change_icon(const ResourceIcon& original, const ResourceIcon& newone);

  //! ``true`` if resources contain @link LIEF::PE::ResourceDialog dialogs @endlink
  bool has_dialogs() const {
    return get_node_type(TYPE::DIALOG) != nullptr;
  }

  //! Return the list of the dialogs present in the resource
  it_const_dialogs dialogs() const;

  //! ``true`` if the resources contain a @link LIEF::PE::ResourceStringTable @endlink
  bool has_string_table() const {
    return get_node_type(TYPE::STRING) != nullptr;
  }

  //! Return the list of the string table in the resource
  it_const_strings_table string_table() const;

  //! ``true`` if the resources contain html
  bool has_html() const {
    return get_node_type(TYPE::HTML) != nullptr;
  }

  //! Return the list of the html resources
  std::vector<std::string> html() const;

  //! ``true`` if the resources contain @link LIEF::PE::ResourceAccelerator @endlink
  bool has_accelerator() const {
    return get_node_type(TYPE::ACCELERATOR) != nullptr;
  }

  //! Return the list of the accelerator in the resource
  it_const_accelerators accelerator() const;

  //!Print the resource tree to the given depth
  std::string print(uint32_t depth = 0) const;

  void accept(Visitor& visitor) const override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const ResourcesManager& m);

  private:
  void print_tree(const ResourceNode& node, std::ostringstream& stream,
                  uint32_t current_depth, uint32_t max_depth) const;
  ResourceNode* resources_ = nullptr;
};

LIEF_API const char* to_string(ResourcesManager::TYPE type);

} // namespace PE
} // namespace LIEF

#endif

```

`KDemu/include/LIEF/LIEF/PE/RichEntry.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_RICH_ENTRY_H
#define LIEF_PE_RICH_ENTRY_H
#include <cstdint>
#include <ostream>

#include "LIEF/Object.hpp"
#include "LIEF/visibility.h"

namespace LIEF {
namespace PE {

//! Class which represents an entry associated to the RichHeader
class LIEF_API RichEntry : public Object {
  public:

  RichEntry() = default;
  RichEntry(uint16_t id, uint16_t build_id, uint32_t count) :
    id_(id),
    build_id_(build_id),
    count_(count)
  {}

  RichEntry(const RichEntry&) = default;
  RichEntry& operator=(const RichEntry&) = default;
  ~RichEntry() override = default;

  //! Entry type
  uint16_t id() const {
    return id_;
  }

  //! Build number of the tool (if any)
  uint16_t build_id() const {
    return build_id_;
  }

  //! *Occurrence* count.
  uint32_t count() const {
    return count_;
  }

  void id(uint16_t id) {
    id_ = id;
  }
  void build_id(uint16_t build_id) {
    build_id_ = build_id;
  }
  void count(uint32_t count) {
    count_ = count;
  }

  void accept(Visitor& visitor) const override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const RichEntry& rich_entry);

  private:
  uint16_t id_ = 0;
  uint16_t build_id_ = 0;
  uint32_t count_ = 0;

};
}
}

#endif


```

`KDemu/include/LIEF/LIEF/PE/RichHeader.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_RICH_HEADER_H
#define LIEF_PE_RICH_HEADER_H
#include <ostream>

#include "LIEF/Object.hpp"
#include "LIEF/visibility.h"

#include "LIEF/iterators.hpp"

#include "LIEF/PE/RichEntry.hpp"
#include "LIEF/PE/enums.hpp"

namespace LIEF {
namespace PE {

//! Class which represents the not-so-documented rich header
//!
//! This structure is usually located at the end of the Binary::dos_stub
//! and contains information about the build environment.
//! It is generated by the Microsoft linker `link.exe` and there are no options to disable
//! or remove this information.
class LIEF_API RichHeader : public Object {
  public:

  using entries_t        = std::vector<RichEntry>;
  using it_entries       = ref_iterator<entries_t&>;
  using it_const_entries = const_ref_iterator<const entries_t&>;

  RichHeader() = default;
  RichHeader(const RichHeader&) = default;
  RichHeader& operator=(const RichHeader&) = default;
  ~RichHeader() override = default;

  //! Key used to encode the header (xor operation)
  uint32_t key() const {
    return key_;
  }

  //! Return an iterator over the PE::RichEntry within the header
  it_entries entries() {
    return entries_;
  }

  it_const_entries entries() const {
    return entries_;
  }

  void key(uint32_t key) {
    key_ = key;
  }

  //! Add a new PE::RichEntry
  void add_entry(RichEntry entry) {
    entries_.push_back(std::move(entry));
  }

  //! Add a new entry given the id, build_id and count
  void add_entry(uint16_t id, uint16_t build_id, uint32_t count) {
    entries_.emplace_back(id, build_id, count);
  }

  //! The raw structure of the Rich header without xor-encoding.
  //!
  //! This function is equivalent as calling RichHeader::raw(uint32_t) with a `xor_key` set to 0
  std::vector<uint8_t> raw() const {
    return raw(/*xor_key=*/0);
  }

  //! Given this rich header, this function re-computes
  //! the raw bytes of the structure with the provided xor-key.
  //!
  //! You can access the decoded data's structure with the @p xor_key set to 0
  //!
  //! @param[in] xor_key   The key to use for the xor-encoding (can be 0)
  std::vector<uint8_t> raw(uint32_t xor_key) const;

  //! Compute the hash of the decoded rich header structure with
  //! the given hash algorithm
  std::vector<uint8_t> hash(ALGORITHMS algo) const {
    return hash(algo, /*xor_key=*/0);
  }

  //! Compute the hash of the rich header structure encoded with the provided key.
  std::vector<uint8_t> hash(ALGORITHMS algo, uint32_t xor_key) const;

  void accept(Visitor& visitor) const override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const RichHeader& rich_header);

  private:
  uint32_t key_ = 0;
  entries_t entries_;

};
}
}

#endif


```

`KDemu/include/LIEF/LIEF/PE/Section.h`:

```h
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef C_LIEF_PE_SECTION_H_
#define C_LIEF_PE_SECTION_H_

#include <inttypes.h>

#include "LIEF/PE/enums.h"

#ifdef __cplusplus
extern "C" {
#endif

enum LIEF_PE_SECTION_CHARACTERISTICS {
  LIEF_PE_SECTION_CHARACTERISTICS_TYPE_NO_PAD            = 0x00000008,
  LIEF_PE_SECTION_CHARACTERISTICS_CNT_CODE               = 0x00000020,
  LIEF_PE_SECTION_CHARACTERISTICS_CNT_INITIALIZED_DATA   = 0x00000040,
  LIEF_PE_SECTION_CHARACTERISTICS_CNT_UNINITIALIZED_DATA = 0x00000080,
  LIEF_PE_SECTION_CHARACTERISTICS_LNK_OTHER              = 0x00000100,
  LIEF_PE_SECTION_CHARACTERISTICS_LNK_INFO               = 0x00000200,
  LIEF_PE_SECTION_CHARACTERISTICS_LNK_REMOVE             = 0x00000800,
  LIEF_PE_SECTION_CHARACTERISTICS_LNK_COMDAT             = 0x00001000,
  LIEF_PE_SECTION_CHARACTERISTICS_GPREL                  = 0x00008000,
  LIEF_PE_SECTION_CHARACTERISTICS_MEM_PURGEABLE          = 0x00010000,
  LIEF_PE_SECTION_CHARACTERISTICS_MEM_16BIT              = 0x00020000,
  LIEF_PE_SECTION_CHARACTERISTICS_MEM_LOCKED             = 0x00040000,
  LIEF_PE_SECTION_CHARACTERISTICS_MEM_PRELOAD            = 0x00080000,
  LIEF_PE_SECTION_CHARACTERISTICS_ALIGN_1BYTES           = 0x00100000,
  LIEF_PE_SECTION_CHARACTERISTICS_ALIGN_2BYTES           = 0x00200000,
  LIEF_PE_SECTION_CHARACTERISTICS_ALIGN_4BYTES           = 0x00300000,
  LIEF_PE_SECTION_CHARACTERISTICS_ALIGN_8BYTES           = 0x00400000,
  LIEF_PE_SECTION_CHARACTERISTICS_ALIGN_16BYTES          = 0x00500000,
  LIEF_PE_SECTION_CHARACTERISTICS_ALIGN_32BYTES          = 0x00600000,
  LIEF_PE_SECTION_CHARACTERISTICS_ALIGN_64BYTES          = 0x00700000,
  LIEF_PE_SECTION_CHARACTERISTICS_ALIGN_128BYTES         = 0x00800000,
  LIEF_PE_SECTION_CHARACTERISTICS_ALIGN_256BYTES         = 0x00900000,
  LIEF_PE_SECTION_CHARACTERISTICS_ALIGN_512BYTES         = 0x00A00000,
  LIEF_PE_SECTION_CHARACTERISTICS_ALIGN_1024BYTES        = 0x00B00000,
  LIEF_PE_SECTION_CHARACTERISTICS_ALIGN_2048BYTES        = 0x00C00000,
  LIEF_PE_SECTION_CHARACTERISTICS_ALIGN_4096BYTES        = 0x00D00000,
  LIEF_PE_SECTION_CHARACTERISTICS_ALIGN_8192BYTES        = 0x00E00000,
  LIEF_PE_SECTION_CHARACTERISTICS_LNK_NRELOC_OVFL        = 0x01000000,
  LIEF_PE_SECTION_CHARACTERISTICS_MEM_DISCARDABLE        = 0x02000000,
  LIEF_PE_SECTION_CHARACTERISTICS_MEM_NOT_CACHED         = 0x04000000,
  LIEF_PE_SECTION_CHARACTERISTICS_MEM_NOT_PAGED          = 0x08000000,
  LIEF_PE_SECTION_CHARACTERISTICS_MEM_SHARED             = 0x10000000,
  LIEF_PE_SECTION_CHARACTERISTICS_MEM_EXECUTE            = 0x20000000,
  LIEF_PE_SECTION_CHARACTERISTICS_MEM_READ               = 0x40000000,
  LIEF_PE_SECTION_CHARACTERISTICS_MEM_WRITE              = 0x80000000
};


struct Pe_Section_t {
  const char* name;
  uint64_t    virtual_address;
  uint64_t    size;
  uint64_t    offset;

  uint32_t    virtual_size;
  uint32_t    pointerto_relocation;
  uint32_t    pointerto_line_numbers;
  uint32_t    characteristics;

  uint8_t*    content;
  uint64_t    content_size;
  double      entropy;

};

typedef struct Pe_Section_t Pe_Section_t;

#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/include/LIEF/LIEF/PE/Section.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_SECTION_H
#define LIEF_PE_SECTION_H
#include <ostream>
#include <vector>
#include <string>
#include <set>

#include "LIEF/visibility.h"
#include "LIEF/Abstract/Section.hpp"
#include "LIEF/enums.hpp"
#include "LIEF/PE/enums.hpp"

namespace LIEF {
namespace PE {

class Parser;
class Builder;
class Binary;

namespace details {
struct pe_section;
}

//! Class which represents a PE section
class LIEF_API Section : public LIEF::Section {

  friend class Parser;
  friend class Builder;
  friend class Binary;

  public:
  using LIEF::Section::name;
  static constexpr size_t MAX_SECTION_NAME = 8;

  enum class CHARACTERISTICS: uint64_t  {
    TYPE_NO_PAD            = 0x00000008,
    CNT_CODE               = 0x00000020,
    CNT_INITIALIZED_DATA   = 0x00000040,
    CNT_UNINITIALIZED_DATA = 0x00000080,
    LNK_OTHER              = 0x00000100,
    LNK_INFO               = 0x00000200,
    LNK_REMOVE             = 0x00000800,
    LNK_COMDAT             = 0x00001000,
    GPREL                  = 0x00008000,
    MEM_PURGEABLE          = 0x00010000,
    MEM_16BIT              = 0x00020000,
    MEM_LOCKED             = 0x00040000,
    MEM_PRELOAD            = 0x00080000,
    ALIGN_1BYTES           = 0x00100000,
    ALIGN_2BYTES           = 0x00200000,
    ALIGN_4BYTES           = 0x00300000,
    ALIGN_8BYTES           = 0x00400000,
    ALIGN_16BYTES          = 0x00500000,
    ALIGN_32BYTES          = 0x00600000,
    ALIGN_64BYTES          = 0x00700000,
    ALIGN_128BYTES         = 0x00800000,
    ALIGN_256BYTES         = 0x00900000,
    ALIGN_512BYTES         = 0x00A00000,
    ALIGN_1024BYTES        = 0x00B00000,
    ALIGN_2048BYTES        = 0x00C00000,
    ALIGN_4096BYTES        = 0x00D00000,
    ALIGN_8192BYTES        = 0x00E00000,
    LNK_NRELOC_OVFL        = 0x01000000,
    MEM_DISCARDABLE        = 0x02000000,
    MEM_NOT_CACHED         = 0x04000000,
    MEM_NOT_PAGED          = 0x08000000,
    MEM_SHARED             = 0x10000000,
    MEM_EXECUTE            = 0x20000000,
    MEM_READ               = 0x40000000,
    MEM_WRITE              = 0x80000000
  };

  Section(const details::pe_section& header);
  Section() = default;
  Section(const std::vector<uint8_t>& data,
          const std::string& name = "", uint32_t characteristics = 0);
  Section(const std::string& name);

  Section& operator=(const Section&) = default;
  Section(const Section&) = default;
  ~Section() override = default;

  //! Return the size of the data in the section.
  uint32_t sizeof_raw_data() const;

  //! Return the size of the data when mapped in memory
  //!
  //! If this value is greater than sizeof_raw_data, the section is zero-padded.
  uint32_t virtual_size() const {
    return virtual_size_;
  }

  //! The actual content of the section
  span<const uint8_t> content() const override {
    return content_;
  }

  //! Content of the section's padding area
  span<const uint8_t> padding() const {
    return padding_;
  }

  //! The offset of the section data in the PE file
  uint32_t pointerto_raw_data() const;

  //! The file pointer to the beginning of the COFF relocation entries for the section. This is set to zero for
  //! executable images or if there are no relocations.
  //!
  //! For modern PE binaries, this value is usually set to 0 as the relocations are managed by
  //! PE::Relocation.
  uint32_t pointerto_relocation() const {
    return pointer_to_relocations_;
  }

  //! The file pointer to the beginning of line-number entries for the section.
  //! This is set to zero if there are no COFF line numbers. This value should be zero for an image because COFF
  //! debugging information is deprecated and modern debug information relies on the PDB files.
  uint32_t pointerto_line_numbers() const {
    return pointer_to_linenumbers_;
  }

  //! No longer used in recent PE binaries produced by Visual Studio
  uint16_t numberof_relocations() const {
    return number_of_relocations_;
  }

  //! No longer used in recent PE binaries produced by Visual Studio
  uint16_t numberof_line_numbers() const {
    return number_of_linenumbers_;
  }

  //! Characteristics of the section: it provides information about
  //! the permissions of the section when mapped. It can also provide
  //! information about the *purpose* of the section (contain code, BSS-like, ...)
  uint32_t characteristics() const {
    return characteristics_;
  }

  //! Deprecated do not use. It will likely change in a future release of LIEF
  bool is_type(PE_SECTION_TYPES type) const;

  //! Deprecated do not use. It will likely change in a future release of LIEF
  const std::set<PE_SECTION_TYPES>& types() const;

  //! Check if the section has the given CHARACTERISTICS
  bool has_characteristic(CHARACTERISTICS c) const {
    return (characteristics() & static_cast<size_t>(c)) > 0;
  }

  //! List of the section characteristics as a std::set
  std::vector<CHARACTERISTICS> characteristics_list() const;

  //! Fill the content of the section with the given ``char``
  void clear(uint8_t c);
  void content(const std::vector<uint8_t>& data) override;

  void name(std::string name) override;

  void virtual_size(uint32_t virtual_sz) {
    virtual_size_ = virtual_sz;
  }

  void pointerto_raw_data(uint32_t ptr);

  void pointerto_relocation(uint32_t ptr) {
    pointer_to_relocations_ = ptr;
  }

  void pointerto_line_numbers(uint32_t ptr) {
    pointer_to_linenumbers_ = ptr;
  }

  void numberof_relocations(uint16_t nb) {
    number_of_relocations_ = nb;
  }

  void numberof_line_numbers(uint16_t nb) {
    number_of_linenumbers_ = nb;
  }

  void sizeof_raw_data(uint32_t sizeOfRawData);

  void characteristics(uint32_t characteristics) {
    characteristics_ = characteristics;
  }

  void type(PE_SECTION_TYPES type);
  void add_type(PE_SECTION_TYPES type);
  void remove_type(PE_SECTION_TYPES type);

  Section& remove_characteristic(CHARACTERISTICS characteristic) {
    characteristics_ &= ~static_cast<size_t>(characteristic);
    return *this;
  }

  Section& add_characteristic(CHARACTERISTICS characteristic) {
    characteristics_ |= static_cast<size_t>(characteristic);
    return *this;
  }

  void accept(Visitor& visitor) const override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const Section& section);

  private:
  span<uint8_t> writable_content() {
    return content_;
  }

  std::vector<uint8_t> content_;
  std::vector<uint8_t> padding_;
  uint32_t virtual_size_           = 0;
  uint32_t pointer_to_relocations_ = 0;
  uint32_t pointer_to_linenumbers_ = 0;
  uint16_t number_of_relocations_  = 0;
  uint16_t number_of_linenumbers_  = 0;
  uint32_t characteristics_        = 0;
  std::set<PE_SECTION_TYPES> types_ = {PE_SECTION_TYPES::UNKNOWN};
};

LIEF_API const char* to_string(Section::CHARACTERISTICS e);

} // namespace PE
} // namespace LIEF

ENABLE_BITMASK_OPERATORS(LIEF::PE::Section::CHARACTERISTICS)

#endif

```

`KDemu/include/LIEF/LIEF/PE/Symbol.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_SYMBOLS_H
#define LIEF_PE_SYMBOLS_H

#include <string>
#include <ostream>

#include "LIEF/Object.hpp"
#include "LIEF/visibility.h"

#include "LIEF/Abstract/Symbol.hpp"
#include "LIEF/PE/enums.hpp"

namespace LIEF {
namespace PE {

class Parser;
class Builder;
class Section;

namespace details {
struct pe_symbol;
}

//! Class that represents a PE symbol.
class LIEF_API Symbol : public LIEF::Symbol {

  friend class Parser;
  friend class Builder;

  public:
  Symbol(const details::pe_symbol& header);

  Symbol();
  ~Symbol() override;

  Symbol& operator=(Symbol other);
  Symbol(const Symbol& other);
  void swap(Symbol& other);

  int16_t              section_number() const;
  uint16_t             type() const;
  SYMBOL_BASE_TYPES    base_type() const;
  SYMBOL_COMPLEX_TYPES complex_type() const;
  SYMBOL_STORAGE_CLASS storage_class() const;
  uint8_t              numberof_aux_symbols() const;
  std::wstring         wname() const;
  Section*             section();
  const Section*       section() const;

  //! @brief ``True`` if symbols are located in a section
  bool has_section() const;

  void accept(Visitor& visitor) const override;


  LIEF_API friend std::ostream& operator<<(std::ostream& os, const Symbol& entry);

  private:
  int16_t  section_number_ = 0;
  uint16_t type_ = 0;
  uint8_t  numberof_aux_symbols_ = 0;
  Section* section_ = nullptr;
  SYMBOL_STORAGE_CLASS storage_class_ = SYMBOL_STORAGE_CLASS::IMAGE_SYM_CLASS_INVALID;
};


} // namespace PE
} // namespace LIEF
#endif /* SYMBOLS_H */

```

`KDemu/include/LIEF/LIEF/PE/TLS.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_TLS_H
#define LIEF_PE_TLS_H

#include <vector>
#include <ostream>

#include "LIEF/span.hpp"
#include "LIEF/Object.hpp"
#include "LIEF/visibility.h"

namespace LIEF {
namespace PE {

class Parser;
class Builder;
class DataDirectory;
class Section;

namespace details {
struct pe32_tls;
struct pe64_tls;
}

//! Class which represents the PE Thread Local Storage
//!
//! This PE structure is also used to implement binary/library constructors.
class LIEF_API TLS : public Object {
  friend class Parser;
  friend class Builder;

  public:
  TLS() = default;
  TLS(const details::pe32_tls& header);
  TLS(const details::pe64_tls& header);
  ~TLS() override = default;

  TLS(const TLS& copy) = default;
  TLS& operator=(const TLS& copy) = default;

  TLS(TLS&& other) noexcept = default;
  TLS& operator=(TLS&& other) noexcept = default;

  //! List of the callback associated with the current TLS.
  //!
  //! These functions are called before any other functions .
  const std::vector<uint64_t>& callbacks() const {
    return callbacks_;
  }

  //! Pair ``(start address, end address)`` of the TLS template.
  //! The template is a block of data that is used to initialize TLS data.
  //! The system copies all of this data each time a thread is created, so it must not be
  //! corrupted.

  //! @note
  //! These addresses are not RVA. It is addresses for which there should be a rebase
  //! relocation in the ``.reloc`` section.
  const std::pair<uint64_t, uint64_t>& addressof_raw_data() const {
    return va_rawdata_;
  }

  //! The location to receive the TLS index assigned by the loader.
  //! This location should be located in a writable section like `.data`
  uint64_t addressof_index() const {
    return addressof_index_;
  }

  //! Pointer to an array of TLS callback functions.
  //!
  //! The array is null-terminated, so if there is no callback function
  //! this field points to 4 bytes set to zero.
  uint64_t addressof_callbacks() const {
    return addressof_callbacks_;
  }

  //! Size in bytes of the zero to be *padded* after the data specified by
  //! data_template.
  uint32_t sizeof_zero_fill() const {
    return sizeof_zero_fill_;
  }

  //! The four bits [23:20] describe alignment info.
  //! Possible values are those defined as `IMAGE_SCN_ALIGN_*`, which are also
  //! used to describe alignment of section in object files.
  //! The other 28 bits are reserved for future use.
  uint32_t characteristics() const {
    return characteristics_;
  }

  //! The initial content used to initialize TLS data.
  span<const uint8_t> data_template() const {
    return data_template_;
  }

  //! True if there is a data directory associated with this entry
  bool has_data_directory() const {
    return directory_ != nullptr;
  }

  //! Return the DataDirectory associated with this object or a nullptr
  //! If it exists, its type should be DataDirectory::TYPES::TLS_TABLE
  DataDirectory* directory() {
    return directory_;
  }

  const DataDirectory* directory() const {
    return directory_;
  }

  //! Check if there is a section associated with this entry
  bool has_section() const {
    return section_ != nullptr;
  }

  //! The section associated with the entry (or a nullptr)
  Section* section() {
    return section_;
  }

  const Section* section() const {
    return section_;
  }

  void callbacks(std::vector<uint64_t> callbacks) {
    callbacks_ = std::move(callbacks);
  }

  void addressof_raw_data(std::pair<uint64_t, uint64_t> addresses) {
    va_rawdata_ = addresses;
  }

  void addressof_index(uint64_t addr_idx) {
    addressof_index_ = addr_idx;
  }

  void addressof_callbacks(uint64_t addr) {
    addressof_callbacks_ = addr;
  }

  void sizeof_zero_fill(uint32_t size) {
    sizeof_zero_fill_ = size;
  }

  void characteristics(uint32_t characteristics) {
    characteristics_ = characteristics;
  }

  void data_template(std::vector<uint8_t> data_template) {
    data_template_ = std::move(data_template);
  }

  void accept(Visitor& visitor) const override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const TLS& entry);

  private:
  std::vector<uint64_t> callbacks_;
  std::pair<uint64_t, uint64_t> va_rawdata_;
  uint64_t addressof_index_ = 0;
  uint64_t addressof_callbacks_ = 0;
  uint32_t sizeof_zero_fill_ = 0;
  uint32_t characteristics_ = 0;
  DataDirectory* directory_ = nullptr;
  Section* section_ = nullptr;
  std::vector<uint8_t> data_template_;
};
}
}
#endif

```

`KDemu/include/LIEF/LIEF/PE/debug/CodeView.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_DEBUG_CODE_VIEW_H
#define LIEF_PE_DEBUG_CODE_VIEW_H
#include "LIEF/PE/debug/Debug.hpp"

namespace LIEF {
namespace PE {
class Parser;
class Builder;

//! Interface for the (generic) Debug CodeView (``IMAGE_DEBUG_TYPE_CODEVIEW``)
class LIEF_API CodeView : public Debug {
  friend class Parser;
  friend class Builder;

  public:
  //! Code view signatures
  //! @see: http://llvm.org/doxygen/CVDebugRecord_8h_source.html
  enum class SIGNATURES {
    UNKNOWN = 0,

    PDB_70 = 0x53445352, // RSDS
    PDB_20 = 0x3031424e, // NB10
    CV_50  = 0x3131424e, // NB11
    CV_41  = 0x3930424e, // NB09
  };

  CodeView() :
    Debug(Debug::TYPES::CODEVIEW)
  {}
  CodeView(SIGNATURES sig) :
    Debug{Debug::TYPES::CODEVIEW},
    sig_{sig}
  {}

  CodeView(const details::pe_debug& debug, SIGNATURES sig);

  CodeView(const CodeView& other) = default;
  CodeView& operator=(const CodeView& other) = default;

  ~CodeView() override = default;

  //! The signature that defines the underlying type of the payload
  SIGNATURES signature() const {
    return sig_;
  }

  std::unique_ptr<Debug> clone() const override {
    return std::unique_ptr<Debug>(new CodeView(*this));
  }

  static bool classof(const Debug* debug) {
    return debug->type() == Debug::TYPES::CODEVIEW;
  }

  void accept(Visitor& visitor) const override;
  LIEF_API friend std::ostream& operator<<(std::ostream& os, const CodeView& entry);

  protected:
  SIGNATURES sig_ = SIGNATURES::UNKNOWN;
};

LIEF_API const char* to_string(CodeView::SIGNATURES e);

} // namespace PE
} // namespace LIEF
#endif

```

`KDemu/include/LIEF/LIEF/PE/debug/CodeViewPDB.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_DEBUG_CODE_VIEW_PDB_H
#define LIEF_PE_DEBUG_CODE_VIEW_PDB_H
#include "LIEF/PE/debug/CodeView.hpp"

#include <cstdint>
#include <array>
#include <ostream>

namespace LIEF {
namespace PE {
class Parser;
class Builder;

namespace details {
struct pe_pdb_70;
}

//! CodeView PDB specialization
class LIEF_API CodeViewPDB : public CodeView {
  friend class Parser;
  friend class Builder;

  public:
  using signature_t = std::array<uint8_t, 16>;
  CodeViewPDB() = default;
  CodeViewPDB(const details::pe_debug& debug_info,
              const details::pe_pdb_70& pdb_70);
  CodeViewPDB(const CodeViewPDB& other) = default;
  CodeViewPDB& operator=(const CodeViewPDB& other) = default;

  /// The GUID signature to verify against the .pdb file signature.
  /// This attribute might be used to lookup remote PDB file on a symbol server
  std::string guid() const;

  /// Age value to verify. The age does not necessarily correspond to any known
  /// time value, it is used to determine if a .pdb file is out of sync with a corresponding .exe file.
  uint32_t age() const {
    return age_;
  }

  /// The 32-bit signature to verify against the .pdb file signature.
  const signature_t& signature() const {
    return signature_;
  }

  /// The path to the `.pdb` file
  const std::string& filename() const {
    return filename_;
  }

  void age(uint32_t age) {
    age_ = age;
  }

  void signature(const signature_t& sig) {
    signature_ = sig;
  }

  void filename(std::string filename) {
    filename_ = std::move(filename);
  }

  std::unique_ptr<Debug> clone() const override {
    return std::unique_ptr<Debug>(new CodeViewPDB(*this));
  }

  static bool classof(const Debug* debug) {
    if (!CodeView::classof(debug)) {
      return false;
    }
    const auto& cv = static_cast<const CodeView&>(*debug);

    return cv.signature() == SIGNATURES::PDB_20 ||
           cv.signature() == SIGNATURES::PDB_70;
  }

  void accept(Visitor& visitor) const override;
  LIEF_API friend std::ostream& operator<<(std::ostream& os, const CodeViewPDB& entry);

  ~CodeViewPDB() override = default;

  protected:
  uint32_t    age_ = 0;
  signature_t signature_;
  std::string filename_;
};

} // namespace PE
} // namespace LIEF
#endif

```

`KDemu/include/LIEF/LIEF/PE/debug/Debug.hpp`:

```hpp

/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_DEBUG_H
#define LIEF_PE_DEBUG_H
#include <cstdint>
#include <ostream>
#include <memory>

#include "LIEF/Object.hpp"
#include "LIEF/visibility.h"

namespace LIEF {
namespace PE {
class Parser;
class Builder;

namespace details {
struct pe_debug;
}

//! This class represents a generic entry in the debug data directory.
//! For known types, this class is extended to provide a dedicated API
//! (see: ! CodeCodeView)
class LIEF_API Debug : public Object {
  friend class Parser;
  friend class Builder;

  public:
  //! The entry types
  enum class TYPES {
    UNKNOWN               = 0,
    COFF                  = 1, ///< COFF debug information
    CODEVIEW              = 2, ///< CodeView debug information (pdb & cie)
    FPO                   = 3, ///< Frame pointer omission information
    MISC                  = 4, ///< CodeView Debug Information
    EXCEPTION             = 5, ///< A copy of .pdata section.
    FIXUP                 = 6, ///< Reserved.
    OMAP_TO_SRC           = 7, ///< The mapping from an RVA in image to an RVA in source image.
    OMAP_FROM_SRC         = 8, ///< The mapping from an RVA in source image to an RVA in image.
    BORLAND               = 9, ///< Reserved for Borland.
    RESERVED10            = 10, ///< Reserved
    CLSID                 = 11, ///< Reserved
    VC_FEATURE            = 12,
    POGO                  = 13, ///< Profile Guided Optimization metadata
    ILTCG                 = 14,
    MPX                   = 15,
    REPRO                 = 16, ///< PE determinism or reproducibility.
    EX_DLLCHARACTERISTICS = 20,
  };
  Debug() = default;
  Debug(TYPES type) {
    type_ = type;
  }

  Debug(const details::pe_debug& debug_s);
  Debug(const Debug& other) = default;
  Debug& operator=(const Debug& other) = default;

  ~Debug() override = default;

  virtual std::unique_ptr<Debug> clone() const {
    return std::unique_ptr<Debug>(new Debug(*this));
  }

  //! Reserved should be 0
  uint32_t characteristics() const {
    return characteristics_;
  }

  //! The time and date when the debug data was created.
  uint32_t timestamp() const {
    return timestamp_;
  }

  //! The major version number of the debug data format.
  uint16_t major_version() const {
    return major_version_;
  }

  //! The minor version number of the debug data format.
  uint16_t minor_version() const {
    return minor_version_;
  }

  //! The format DEBUG_TYPES of the debugging information
  TYPES type() const {
    return type_;
  }

  //! Size of the debug data
  uint32_t sizeof_data() const {
    return sizeof_data_;
  }

  //! Address of the debug data relative to the image base
  uint32_t addressof_rawdata() const {
    return addressof_rawdata_;
  }

  //! File offset of the debug data
  uint32_t pointerto_rawdata() const {
    return pointerto_rawdata_;
  }

  void characteristics(uint32_t characteristics) {
    characteristics_ = characteristics;
  }

  void timestamp(uint32_t timestamp) {
    timestamp_ = timestamp;
  }

  void major_version(uint16_t major_version) {
    major_version_ = major_version;
  }

  void minor_version(uint16_t minor_version) {
    minor_version_ = minor_version;
  }

  void sizeof_data(uint32_t sizeof_data) {
    sizeof_data_ = sizeof_data;
  }

  void addressof_rawdata(uint32_t addressof_rawdata) {
    addressof_rawdata_ = addressof_rawdata;
  }

  void pointerto_rawdata(uint32_t pointerto_rawdata) {
    pointerto_rawdata_ = pointerto_rawdata;
  }

  void accept(Visitor& visitor) const override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const Debug& entry);

  protected:
  TYPES type_ = TYPES::UNKNOWN;
  uint32_t characteristics_ = 0;
  uint32_t timestamp_ = 0;
  uint16_t major_version_ = 0;
  uint16_t minor_version_ = 0;
  uint32_t sizeof_data_ = 0;
  uint32_t addressof_rawdata_ = 0;
  uint32_t pointerto_rawdata_ = 0;
};

LIEF_API const char* to_string(Debug::TYPES e);

}
}
#endif

```

`KDemu/include/LIEF/LIEF/PE/debug/Pogo.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_POGO_H
#define LIEF_PE_POGO_H
#include <ostream>

#include "LIEF/visibility.h"
#include "LIEF/iterators.hpp"
#include "LIEF/PE/debug/Debug.hpp"
#include "LIEF/PE/debug/PogoEntry.hpp"

namespace LIEF {
namespace PE {

class Builder;
class Parser;

//! This class represents a *Profile Guided Optimization* entry from the
//! debug directory (``IMAGE_DEBUG_TYPE_POGO``).
class LIEF_API Pogo : public Debug {

  friend class Builder;
  friend class Parser;

  public:
  using entries_t        = std::vector<PogoEntry>;
  using it_entries       = ref_iterator<entries_t&>;
  using it_const_entries = const_ref_iterator<const entries_t&>;

  enum class SIGNATURES {
    UNKNOWN = 0x0fffffff,
    ZERO    = 0x00000000,
    LCTG    = 0x4C544347, // LCTG
    PGI     = 0x50474900, // PGI\0
  };

  Pogo();
  Pogo(SIGNATURES sig) :
    Debug{Debug::TYPES::POGO},
    sig_{sig}
  {}

  Pogo(const details::pe_debug& debug, SIGNATURES sig);
  Pogo(const Pogo&) = default;
  Pogo& operator=(const Pogo&) = default;

  std::unique_ptr<Debug> clone() const override {
    return std::unique_ptr<Debug>(new Pogo(*this));
  }

  SIGNATURES signature() const {
    return sig_;
  }

  //! An iterator over the different POGO elements
  it_entries entries() {
    return entries_;
  }

  it_const_entries entries() const {
    return entries_;
  }

  void add(PogoEntry entry) {
    entries_.push_back(std::move(entry));
  }

  static bool classof(const Debug* debug) {
    return debug->type() == Debug::TYPES::POGO;
  }

  void accept(Visitor& visitor) const override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const Pogo& entry);

  ~Pogo() override = default;

  protected:
  SIGNATURES sig_ = SIGNATURES::UNKNOWN;
  entries_t entries_;
};

LIEF_API const char* to_string(Pogo::SIGNATURES e);

} // Namespace PE
} // Namespace LIEF

#endif

```

`KDemu/include/LIEF/LIEF/PE/debug/PogoEntry.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_DEBUG_POGO_ENTRY_H
#define LIEF_PE_DEBUG_POGO_ENTRY_H
#include <ostream>
#include <cstdint>

#include "LIEF/Object.hpp"
#include "LIEF/visibility.h"

namespace LIEF {
namespace PE {

class Builder;
class Parser;

class LIEF_API PogoEntry : public Object {
  friend class Builder;
  friend class Parser;

  public:
  PogoEntry() = default;
  PogoEntry(PogoEntry&& other) = default;
  PogoEntry& operator=(PogoEntry&& other) = default;
  PogoEntry(const PogoEntry&) = default;
  PogoEntry(uint32_t start_rva, uint32_t size, std::string name) :
    start_rva_{start_rva},
    size_{size},
    name_{std::move(name)}
  {}

  PogoEntry(uint32_t start_rva, uint32_t size) :
    PogoEntry{start_rva, size, ""}
  {}

  PogoEntry& operator=(const PogoEntry&) = default;
  ~PogoEntry() override = default;

  uint32_t start_rva() const {
    return start_rva_;
  }

  uint32_t size() const {
    return size_;
  }

  const std::string& name() const {
    return name_;
  }

  void start_rva(uint32_t start_rva) {
    start_rva_ = start_rva;
  }

  void size(uint32_t size) {
    size_ = size;
  }

  void name(std::string name) {
    name_ = std::move(name);
  }

  void accept(Visitor& visitor) const override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const PogoEntry& entry);

  protected:
  uint32_t start_rva_ = 0;
  uint32_t size_ = 0;
  std::string name_;
};

} // Namespace PE
} // Namespace LIEF

#endif

```

`KDemu/include/LIEF/LIEF/PE/debug/Repro.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_REPRO_H
#define LIEF_PE_REPRO_H
#include <ostream>
#include <vector>

#include "LIEF/visibility.h"
#include "LIEF/PE/debug/Debug.hpp"
#include "LIEF/span.hpp"

namespace LIEF {
namespace PE {

class Builder;
class Parser;

//! This class represents a reproducible build entry from the debug directory.
//! (``IMAGE_DEBUG_TYPE_REPRO``).
//! This entry is usually generated with the undocumented `/Brepro` linker flag.
//!
//! See: https://nikhilism.com/post/2020/windows-deterministic-builds/
class LIEF_API Repro : public Debug {

  friend class Builder;
  friend class Parser;

  public:
  Repro() :
    Debug{Debug::TYPES::REPRO}
  {}

  Repro(std::vector<uint8_t> hash) :
    Debug{Debug::TYPES::REPRO},
    hash_{std::move(hash)}
  {}

  Repro(const details::pe_debug& dbg, std::vector<uint8_t> hash) :
    Debug{dbg},
    hash_{std::move(hash)}
  {}

  Repro(const Repro& other) = default;
  Repro& operator=(const Repro& other) = default;

  //! The hash associated with the reproducible build
  span<const uint8_t> hash() const {
    return hash_;
  }

  span<uint8_t> hash() {
    return hash_;
  }

  void hash(std::vector<uint8_t> h) {
    hash_ = std::move(h);
  }

  std::unique_ptr<Debug> clone() const override {
    return std::unique_ptr<Debug>(new Repro(*this));
  }

  static bool classof(const Debug* debug) {
    return debug->type() == Debug::TYPES::REPRO;
  }

  void accept(Visitor& visitor) const override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const Repro& entry);

  ~Repro() override = default;

  protected:
  std::vector<uint8_t> hash_;
};

} // Namespace PE
} // Namespace LIEF

#endif

```

`KDemu/include/LIEF/LIEF/PE/enums.h`:

```h
#ifndef LIEF_PE_C_ENUMS_H_
#define LIEF_PE_C_ENUMS_H_
#include "LIEF/PE/undef.h"

#ifdef __cplusplus
extern "C" {
#endif

#define _LIEF_EN(N) LIEF_PE_##N
#define _LIEF_EN_2(N, TYPE) LIEF_PE_##N
#define _LIEF_EI(X) LIEF_PE_##X

#include "LIEF/PE/enums.inc"

#undef _LIEF_EN
#undef _LIEF_EN_2
#undef _LIEF_EI


#ifdef __cplusplus
}
#endif


#endif

```

`KDemu/include/LIEF/LIEF/PE/enums.hpp`:

```hpp
/* Copyright 2021 - 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_ENUMS_H
#define LIEF_PE_ENUMS_H
#include <cinttypes>
#include <cstddef>
#include "LIEF/enums.hpp"
#define LIEF_PE_FORCE_UNDEF
#include "LIEF/PE/undef.h"

namespace LIEF {
namespace PE {

enum class PE_TYPES: size_t  {
    PE32      = 0x10b, /** 32bits  */
    PE32_PLUS = 0x20b  /** 64 bits */
};


enum SYMBOL_SECTION_NUMBER: int {
  IMAGE_SYM_DEBUG     = -2,
  IMAGE_SYM_ABSOLUTE  = -1,
  IMAGE_SYM_UNDEFINED = 0
};

/// Storage class tells where and what the symbol represents
enum SYMBOL_STORAGE_CLASS: int {
  IMAGE_SYM_CLASS_INVALID = 0xFF,

  IMAGE_SYM_CLASS_END_OF_FUNCTION  = -1,  ///< Physical end of function
  IMAGE_SYM_CLASS_NULL             = 0,   ///< No symbol
  IMAGE_SYM_CLASS_AUTOMATIC        = 1,   ///< Stack variable
  IMAGE_SYM_CLASS_EXTERNAL         = 2,   ///< External symbol
  IMAGE_SYM_CLASS_STATIC           = 3,   ///< Static
  IMAGE_SYM_CLASS_REGISTER         = 4,   ///< Register variable
  IMAGE_SYM_CLASS_EXTERNAL_DEF     = 5,   ///< External definition
  IMAGE_SYM_CLASS_LABEL            = 6,   ///< Label
  IMAGE_SYM_CLASS_UNDEFINED_LABEL  = 7,   ///< Undefined label
  IMAGE_SYM_CLASS_MEMBER_OF_STRUCT = 8,   ///< Member of structure
  IMAGE_SYM_CLASS_ARGUMENT         = 9,   ///< Function argument
  IMAGE_SYM_CLASS_STRUCT_TAG       = 10,  ///< Structure tag
  IMAGE_SYM_CLASS_MEMBER_OF_UNION  = 11,  ///< Member of union
  IMAGE_SYM_CLASS_UNION_TAG        = 12,  ///< Union tag
  IMAGE_SYM_CLASS_TYPE_DEFINITION  = 13,  ///< Type definition
  IMAGE_SYM_CLASS_UNDEFINED_STATIC = 14,  ///< Undefined static
  IMAGE_SYM_CLASS_ENUM_TAG         = 15,  ///< Enumeration tag
  IMAGE_SYM_CLASS_MEMBER_OF_ENUM   = 16,  ///< Member of enumeration
  IMAGE_SYM_CLASS_REGISTER_PARAM   = 17,  ///< Register parameter
  IMAGE_SYM_CLASS_BIT_FIELD        = 18,  ///< Bit field ".bb" or ".eb" - beginning or end of block
  IMAGE_SYM_CLASS_BLOCK            = 100, ///< ".bf" or ".ef" - beginning or end of function
  IMAGE_SYM_CLASS_FUNCTION         = 101,
  IMAGE_SYM_CLASS_END_OF_STRUCT    = 102, ///< End of structure
  IMAGE_SYM_CLASS_FILE             = 103, ///< File name line number, reformatted as symbol
  IMAGE_SYM_CLASS_SECTION          = 104,
  IMAGE_SYM_CLASS_WEAK_EXTERNAL    = 105, ///< Duplicate tag external symbol in dmert public lib
  IMAGE_SYM_CLASS_CLR_TOKEN        = 107
};


enum class SYMBOL_BASE_TYPES: size_t  {
  IMAGE_SYM_TYPE_NULL   = 0,  ///< No type information or unknown base type.
  IMAGE_SYM_TYPE_VOID   = 1,  ///< Used with void pointers and functions.
  IMAGE_SYM_TYPE_CHAR   = 2,  ///< A character (signed byte).
  IMAGE_SYM_TYPE_SHORT  = 3,  ///< A 2-byte signed integer.
  IMAGE_SYM_TYPE_INT    = 4,  ///< A natural integer type on the target.
  IMAGE_SYM_TYPE_LONG   = 5,  ///< A 4-byte signed integer.
  IMAGE_SYM_TYPE_FLOAT  = 6,  ///< A 4-byte floating-point number.
  IMAGE_SYM_TYPE_DOUBLE = 7,  ///< An 8-byte floating-point number.
  IMAGE_SYM_TYPE_STRUCT = 8,  ///< A structure.
  IMAGE_SYM_TYPE_UNION  = 9,  ///< An union.
  IMAGE_SYM_TYPE_ENUM   = 10, ///< An enumerated type.
  IMAGE_SYM_TYPE_MOE    = 11, ///< A member of enumeration (a specific value).
  IMAGE_SYM_TYPE_BYTE   = 12, ///< A byte; unsigned 1-byte integer.
  IMAGE_SYM_TYPE_WORD   = 13, ///< A word; unsigned 2-byte integer.
  IMAGE_SYM_TYPE_UINT   = 14, ///< An unsigned integer of natural size.
  IMAGE_SYM_TYPE_DWORD  = 15  ///< An unsigned 4-byte integer.
};

enum class SYMBOL_COMPLEX_TYPES: size_t  {
  IMAGE_SYM_DTYPE_NULL     = 0, ///< No complex type; simple scalar variable.
  IMAGE_SYM_DTYPE_POINTER  = 1, ///< A pointer to base type.
  IMAGE_SYM_DTYPE_FUNCTION = 2, ///< A function that returns a base type.
  IMAGE_SYM_DTYPE_ARRAY    = 3, ///< An array of base type.
  SCT_COMPLEX_TYPE_SHIFT   = 4  ///< Type is formed as (base + (derived << SCT_COMPLEX_TYPE_SHIFT))
};

enum class AuxSymbolType: size_t  {
  IMAGE_AUX_SYMBOL_TYPE_TOKEN_DEF = 1
};


enum class RELOCATIONS_I386: size_t  {
  IMAGE_REL_I386_ABSOLUTE = 0x0000,
  IMAGE_REL_I386_DIR16    = 0x0001,
  IMAGE_REL_I386_REL16    = 0x0002,
  IMAGE_REL_I386_DIR32    = 0x0006,
  IMAGE_REL_I386_DIR32NB  = 0x0007,
  IMAGE_REL_I386_SEG12    = 0x0009,
  IMAGE_REL_I386_SECTION  = 0x000A,
  IMAGE_REL_I386_SECREL   = 0x000B,
  IMAGE_REL_I386_TOKEN    = 0x000C,
  IMAGE_REL_I386_SECREL7  = 0x000D,
  IMAGE_REL_I386_REL32    = 0x0014
};

enum class RELOCATIONS_AMD64: size_t  {
  IMAGE_REL_AMD64_ABSOLUTE = 0x0000,
  IMAGE_REL_AMD64_ADDR64   = 0x0001,
  IMAGE_REL_AMD64_ADDR32   = 0x0002,
  IMAGE_REL_AMD64_ADDR32NB = 0x0003,
  IMAGE_REL_AMD64_REL32    = 0x0004,
  IMAGE_REL_AMD64_REL32_1  = 0x0005,
  IMAGE_REL_AMD64_REL32_2  = 0x0006,
  IMAGE_REL_AMD64_REL32_3  = 0x0007,
  IMAGE_REL_AMD64_REL32_4  = 0x0008,
  IMAGE_REL_AMD64_REL32_5  = 0x0009,
  IMAGE_REL_AMD64_SECTION  = 0x000A,
  IMAGE_REL_AMD64_SECREL   = 0x000B,
  IMAGE_REL_AMD64_SECREL7  = 0x000C,
  IMAGE_REL_AMD64_TOKEN    = 0x000D,
  IMAGE_REL_AMD64_SREL32   = 0x000E,
  IMAGE_REL_AMD64_PAIR     = 0x000F,
  IMAGE_REL_AMD64_SSPAN32  = 0x0010
};

enum class RELOCATIONS_ARM: size_t  {
  IMAGE_REL_ARM_ABSOLUTE  = 0x0000,
  IMAGE_REL_ARM_ADDR32    = 0x0001,
  IMAGE_REL_ARM_ADDR32NB  = 0x0002,
  IMAGE_REL_ARM_BRANCH24  = 0x0003,
  IMAGE_REL_ARM_BRANCH11  = 0x0004,
  IMAGE_REL_ARM_TOKEN     = 0x0005,
  IMAGE_REL_ARM_BLX24     = 0x0008,
  IMAGE_REL_ARM_BLX11     = 0x0009,
  IMAGE_REL_ARM_SECTION   = 0x000E,
  IMAGE_REL_ARM_SECREL    = 0x000F,
  IMAGE_REL_ARM_MOV32A    = 0x0010,
  IMAGE_REL_ARM_MOV32T    = 0x0011,
  IMAGE_REL_ARM_BRANCH20T = 0x0012,
  IMAGE_REL_ARM_BRANCH24T = 0x0014,
  IMAGE_REL_ARM_BLX23T    = 0x0015
};


/// These are not documented in the spec, but are located in WinNT.h.
enum class WeakExternalCharacteristics: size_t  {
  IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY = 1,
  IMAGE_WEAK_EXTERN_SEARCH_LIBRARY   = 2,
  IMAGE_WEAK_EXTERN_SEARCH_ALIAS     = 3
};


enum class ImportType: size_t  {
  IMPORT_CODE  = 0,
  IMPORT_DATA  = 1,
  IMPORT_CONST = 2
};


enum class ImportNameType: size_t  {
  /// Import is by ordinal. This indicates that the value in the Ordinal/Hint
  /// field of the import header is the import's ordinal. If this constant is
  /// not specified, then the Ordinal/Hint field should always be interpreted
  /// as the import's hint.
  IMPORT_ORDINAL         = 0,
  /// The import name is identical to the public symbol name
  IMPORT_NAME            = 1,
  /// The import name is the public symbol name, but skipping the leading ?,
  /// @, or optionally _.
  IMPORT_NAME_NOPREFIX   = 2,
  /// The import name is the public symbol name, but skipping the leading ?,
  /// @, or optionally _, and truncating at the first @.
  IMPORT_NAME_UNDECORATE = 3
};


enum class CodeViewIdentifiers: size_t  {
  DEBUG_LINE_TABLES_HAVE_COLUMN_RECORDS = 0x1,
  DEBUG_SECTION_MAGIC = 0x4,
  DEBUG_SYMBOL_SUBSECTION = 0xF1,
  DEBUG_LINE_TABLE_SUBSECTION = 0xF2,
  DEBUG_STRING_TABLE_SUBSECTION = 0xF3,
  DEBUG_INDEX_SUBSECTION = 0xF4,

  // Symbol subsections are split into records of different types.
  DEBUG_SYMBOL_TYPE_PROC_START = 0x1147,
  DEBUG_SYMBOL_TYPE_PROC_END = 0x114F
};


//! From https://docs.microsoft.com/en-us/windows/win32/winmsg/extended-window-styles
enum class EXTENDED_WINDOW_STYLES: size_t  {
  WS_EX_DLGMODALFRAME    = 0x00000001L,
  WS_EX_NOPARENTNOTIFY   = 0x00000004L,
  WS_EX_TOPMOST          = 0x00000008L,
  WS_EX_ACCEPTFILES      = 0x00000010L,
  WS_EX_TRANSPARENT      = 0x00000020L,
  WS_EX_MDICHILD         = 0x00000040L,
  WS_EX_TOOLWINDOW       = 0x00000080L,
  WS_EX_WINDOWEDGE       = 0x00000100L,
  WS_EX_CLIENTEDGE       = 0x00000200L,
  WS_EX_CONTEXTHELP      = 0x00000400L,

  WS_EX_RIGHT            = 0x00001000L,
  WS_EX_LEFT             = 0x00000000L,
  WS_EX_RTLREADING       = 0x00002000L,
  WS_EX_LTRREADING       = 0x00000000L,
  WS_EX_LEFTSCROLLBAR    = 0x00004000L,
  WS_EX_RIGHTSCROLLBAR   = 0x00000000L,

  WS_EX_CONTROLPARENT    = 0x00010000L,
  WS_EX_STATICEDGE       = 0x00020000L,
  WS_EX_APPWINDOW        = 0x00040000L,
};

//! From: https://docs.microsoft.com/en-us/windows/win32/winmsg/window-styles
enum class WINDOW_STYLES: size_t  {
  WS_OVERLAPPED      = 0x00000000L,
  WS_POPUP           = 0x80000000L,
  WS_CHILD           = 0x40000000L,
  WS_MINIMIZE        = 0x20000000L,
  WS_VISIBLE         = 0x10000000L,
  WS_DISABLED        = 0x08000000L,
  WS_CLIPSIBLINGS    = 0x04000000L,
  WS_CLIPCHILDREN    = 0x02000000L,
  WS_MAXIMIZE        = 0x01000000L,
  WS_CAPTION         = 0x00C00000L,
  WS_BORDER          = 0x00800000L,
  WS_DLGFRAME        = 0x00400000L,
  WS_VSCROLL         = 0x00200000L,
  WS_HSCROLL         = 0x00100000L,
  WS_SYSMENU         = 0x00080000L,
  WS_THICKFRAME      = 0x00040000L,
  WS_GROUP           = 0x00020000L,
  WS_TABSTOP         = 0x00010000L,

  WS_MINIMIZEBOX     = 0x00020000L,
  WS_MAXIMIZEBOX     = 0x00010000L,
};


//! From https://docs.microsoft.com/en-us/windows/win32/dlgbox/dialog-box-styles
enum class DIALOG_BOX_STYLES: size_t  {
  DS_ABSALIGN      = 0x0001L,
  DS_SYSMODAL      = 0x0002L,
  DS_LOCALEDIT     = 0x0020L,
  DS_SETFONT       = 0x0040L,
  DS_MODALFRAME    = 0x0080L,
  DS_NOIDLEMSG     = 0x0100L,
  DS_SETFOREGROUND = 0x0200L,
  DS_3DLOOK        = 0x0004L,
  DS_FIXEDSYS      = 0x0008L,
  DS_NOFAILCREATE  = 0x0010L,
  DS_CONTROL       = 0x0400L,
  DS_CENTER        = 0x0800L,
  DS_CENTERMOUSE   = 0x1000L,
  DS_CONTEXTHELP   = 0x2000L,
  DS_SHELLFONT     = 0x0040L | 0x0008L, // DS_SETFONT | DS_FIXEDSYS
};

enum class FIXED_VERSION_OS: size_t  {
  VOS_UNKNOWN       = 0x00000000L,
  VOS_DOS           = 0x00010000L,
  VOS_NT            = 0x00040000L,
  VOS__WINDOWS16    = 0x00000001L,
  VOS__WINDOWS32    = 0x00000004L,
  VOS_OS216         = 0x00020000L,
  VOS_OS232         = 0x00030000L,
  VOS__PM16         = 0x00000002L,
  VOS__PM32         = 0x00000003L,
  VOS_DOS_WINDOWS16 = 0x00010000L | 0x00000001L, // VOS_DOS   | VOS__WINDOWS16
  VOS_DOS_WINDOWS32 = 0x00010000L | 0x00000004L, // VOS_DOS   | VOS__WINDOWS32
  VOS_NT_WINDOWS32  = 0x00040000L | 0x00000004L, // VOS_NT    | VOS__WINDOWS32
  VOS_OS216_PM16    = 0x00020000L | 0x00000002L, // VOS_OS216 | VOS__PM16
  VOS_OS232_PM32    = 0x00030000L | 0x00000003L, // VOS_OS232 | VOS__PM32
};


enum class FIXED_VERSION_FILE_FLAGS: size_t  {
  VS_FF_DEBUG        = 0x00000001L,
  VS_FF_INFOINFERRED = 0x00000010L,
  VS_FF_PATCHED      = 0x00000004L,
  VS_FF_PRERELEASE   = 0x00000002L,
  VS_FF_PRIVATEBUILD = 0x00000008L,
  VS_FF_SPECIALBUILD = 0x00000020L,
};


enum class FIXED_VERSION_FILE_TYPES: size_t  {
  VFT_APP        = 0x00000001L,
  VFT_DLL        = 0x00000002L,
  VFT_DRV        = 0x00000003L,
  VFT_FONT       = 0x00000004L,
  VFT_STATIC_LIB = 0x00000007L,
  VFT_UNKNOWN    = 0x00000000L,
  VFT_VXD        = 0x00000005L,
};


enum class FIXED_VERSION_FILE_SUB_TYPES: size_t  {
  VFT2_DRV_COMM              = 0x0000000AL,
  VFT2_DRV_DISPLAY           = 0x00000004L,
  VFT2_DRV_INSTALLABLE       = 0x00000008L,
  VFT2_DRV_KEYBOARD          = 0x00000002L,
  VFT2_DRV_LANGUAGE          = 0x00000003L,
  VFT2_DRV_MOUSE             = 0x00000005L,
  VFT2_DRV_NETWORK           = 0x00000006L,
  VFT2_DRV_PRINTER           = 0x00000001L,
  VFT2_DRV_SOUND             = 0x00000009L,
  VFT2_DRV_SYSTEM            = 0x00000007L,
  VFT2_DRV_VERSIONED_PRINTER = 0x0000000CL,

  VFT2_FONT_RASTER           = 0x00000001L,
  VFT2_FONT_TRUETYPE         = 0x00000003L,
  VFT2_FONT_VECTOR           = 0x00000002L,

  VFT2_UNKNOWN               = 0x00000000L,
};

//! Code page from https://docs.microsoft.com/en-us/windows/win32/intl/code-page-identifiers
enum class CODE_PAGES: size_t  {
  CP_IBM037                  = 37,    /**< IBM EBCDIC US-Canada */
  CP_IBM437                  = 437,   /**< OEM United States */
  CP_IBM500                  = 500,   /**< IBM EBCDIC International */
  CP_ASMO_708                = 708,   /**< Arabic (ASMO 708) */
  CP_DOS_720                 = 720,   /**< Arabic (Transparent ASMO); Arabic (DOS) */
  CP_IBM737                  = 737,   /**< OEM Greek (formerly 437G); Greek (DOS) */
  CP_IBM775                  = 775,   /**< OEM Baltic; Baltic (DOS) */
  CP_IBM850                  = 850,   /**< OEM Multilingual Latin 1; Western European (DOS) */
  CP_IBM852                  = 852,   /**< OEM Latin 2; Central European (DOS) */
  CP_IBM855                  = 855,   /**< OEM Cyrillic (primarily Russian) */
  CP_IBM857                  = 857,   /**< OEM Turkish; Turkish (DOS) */
  CP_IBM00858                = 858,   /**< OEM Multilingual Latin 1 + Euro symbol */
  CP_IBM860                  = 860,   /**< OEM Portuguese; Portuguese (DOS) */
  CP_IBM861                  = 861,   /**< OEM Icelandic; Icelandic (DOS) */
  CP_DOS_862                 = 862,   /**< OEM Hebrew; Hebrew (DOS) */
  CP_IBM863                  = 863,   /**< OEM French Canadian; French Canadian (DOS) */
  CP_IBM864                  = 864,   /**< OEM Arabic; Arabic (864) */
  CP_IBM865                  = 865,   /**< OEM Nordic; Nordic (DOS) */
  CP_CP866                   = 866,   /**< OEM Russian; Cyrillic (DOS) */
  CP_IBM869                  = 869,   /**< OEM Modern Greek; Greek, Modern (DOS) */
  CP_IBM870                  = 870,   /**< IBM EBCDIC Multilingual/ROECE (Latin 2); IBM EBCDIC Multilingual Latin 2 */
  CP_WINDOWS_874             = 874,   /**< ANSI/OEM Thai (same as 28605, ISO 8859-15); Thai (Windows) */
  CP_CP875                   = 875,   /**< IBM EBCDIC Greek Modern */
  CP_SHIFT_JIS               = 932,   /**< ANSI/OEM Japanese; Japanese (Shift-JIS) */
  CP_GB2312                  = 936,   /**< ANSI/OEM Simplified Chinese (PRC, Singapore); Chinese Simplified (GB2312) */
  CP_KS_C_5601_1987          = 949,   /**< ANSI/OEM Korean (Unified Hangul Code) */
  CP_BIG5                    = 950,   /**< ANSI/OEM Traditional Chinese (Taiwan; Hong Kong SAR, PRC); Chinese Traditional (Big5) */
  CP_IBM1026                 = 1026,  /**< IBM EBCDIC Turkish (Latin 5) */
  CP_IBM01047                = 1047,  /**< IBM EBCDIC Latin 1/Open System */
  CP_IBM01140                = 1140,  /**< IBM EBCDIC US-Canada (037 + Euro symbol); IBM EBCDIC (US-Canada-Euro) */
  CP_IBM01141                = 1141,  /**< IBM EBCDIC Germany (20273 + Euro symbol); IBM EBCDIC (Germany-Euro) */
  CP_IBM01142                = 1142,  /**< IBM EBCDIC Denmark-Norway (20277 + Euro symbol); IBM EBCDIC (Denmark-Norway-Euro) */
  CP_IBM01143                = 1143,  /**< IBM EBCDIC Finland-Sweden (20278 + Euro symbol); IBM EBCDIC (Finland-Sweden-Euro) */
  CP_IBM01144                = 1144,  /**< IBM EBCDIC Italy (20280 + Euro symbol); IBM EBCDIC (Italy-Euro) */
  CP_IBM01145                = 1145,  /**< IBM EBCDIC Latin America-Spain (20284 + Euro symbol); IBM EBCDIC (Spain-Euro) */
  CP_IBM01146                = 1146,  /**< IBM EBCDIC United Kingdom (20285 + Euro symbol); IBM EBCDIC (UK-Euro) */
  CP_IBM01147                = 1147,  /**< IBM EBCDIC France (20297 + Euro symbol); IBM EBCDIC (France-Euro) */
  CP_IBM01148                = 1148,  /**< IBM EBCDIC International (500 + Euro symbol); IBM EBCDIC (International-Euro) */
  CP_IBM01149                = 1149,  /**< IBM EBCDIC Icelandic (20871 + Euro symbol); IBM EBCDIC (Icelandic-Euro) */
  CP_UTF_16                  = 1200,  /**< Unicode UTF-16, little endian byte order (BMP of ISO 10646); available only to managed applications */
  CP_UNICODEFFFE             = 1201,  /**< Unicode UTF-16, big endian byte order; available only to managed applications */
  CP_WINDOWS_1250            = 1250,  /**< ANSI Central European; Central European (Windows) */
  CP_WINDOWS_1251            = 1251,  /**< ANSI Cyrillic; Cyrillic (Windows) */
  CP_WINDOWS_1252            = 1252,  /**< ANSI Latin 1; Western European (Windows) */
  CP_WINDOWS_1253            = 1253,  /**< ANSI Greek; Greek (Windows) */
  CP_WINDOWS_1254            = 1254,  /**< ANSI Turkish; Turkish (Windows) */
  CP_WINDOWS_1255            = 1255,  /**< ANSI Hebrew; Hebrew (Windows) */
  CP_WINDOWS_1256            = 1256,  /**< ANSI Arabic; Arabic (Windows) */
  CP_WINDOWS_1257            = 1257,  /**< ANSI Baltic; Baltic (Windows) */
  CP_WINDOWS_1258            = 1258,  /**< ANSI/OEM Vietnamese; Vietnamese (Windows) */
  CP_JOHAB                   = 1361,  /**< Korean (Johab) */
  CP_MACINTOSH               = 10000, /**< MAC Roman; Western European (Mac) */
  CP_X_MAC_JAPANESE          = 10001, /**< Japanese (Mac) */
  CP_X_MAC_CHINESETRAD       = 10002, /**< MAC Traditional Chinese (Big5); Chinese Traditional (Mac) */
  CP_X_MAC_KOREAN            = 10003, /**< Korean (Mac) */
  CP_X_MAC_ARABIC            = 10004, /**< Arabic (Mac) */
  CP_X_MAC_HEBREW            = 10005, /**< Hebrew (Mac) */
  CP_X_MAC_GREEK             = 10006, /**< Greek (Mac) */
  CP_X_MAC_CYRILLIC          = 10007, /**< Cyrillic (Mac) */
  CP_X_MAC_CHINESESIMP       = 10008, /**< MAC Simplified Chinese (GB 2312); Chinese Simplified (Mac) */
  CP_X_MAC_ROMANIAN          = 10010, /**< Romanian (Mac) */
  CP_X_MAC_UKRAINIAN         = 10017, /**< Ukrainian (Mac) */
  CP_X_MAC_THAI              = 10021, /**< Thai (Mac) */
  CP_X_MAC_CE                = 10029, /**< MAC Latin 2; Central European (Mac) */
  CP_X_MAC_ICELANDIC         = 10079, /**< Icelandic (Mac) */
  CP_X_MAC_TURKISH           = 10081, /**< Turkish (Mac) */
  CP_X_MAC_CROATIAN          = 10082, /**< Croatian (Mac) */
  CP_UTF_32                  = 12000, /**< Unicode UTF-32, little endian byte order; available only to managed applications */
  CP_UTF_32BE                = 12001, /**< Unicode UTF-32, big endian byte order; available only to managed applications */
  CP_X_CHINESE_CNS           = 20000, /**< CNS Taiwan; Chinese Traditional (CNS) */
  CP_X_CP20001               = 20001, /**< TCA Taiwan */
  CP_X_CHINESE_ETEN          = 20002, /**< Eten Taiwan; Chinese Traditional (Eten) */
  CP_X_CP20003               = 20003, /**< IBM5550 Taiwan */
  CP_X_CP20004               = 20004, /**< TeleText Taiwan */
  CP_X_CP20005               = 20005, /**< Wang Taiwan */
  CP_X_IA5                   = 20105, /**< IA5 (IRV International Alphabet No. 5, 7-bit); Western European (IA5) */
  CP_X_IA5_GERMAN            = 20106, /**< IA5 German (7-bit) */
  CP_X_IA5_SWEDISH           = 20107, /**< IA5 Swedish (7-bit) */
  CP_X_IA5_NORWEGIAN         = 20108, /**< IA5 Norwegian (7-bit) */
  CP_US_ASCII                = 20127, /**< US-ASCII (7-bit) */
  CP_X_CP20261               = 20261, /**< T.61 */
  CP_X_CP20269               = 20269, /**< ISO 6937 Non-Spacing Accent */
  CP_IBM273                  = 20273, /**< IBM EBCDIC Germany */
  CP_IBM277                  = 20277, /**< IBM EBCDIC Denmark-Norway */
  CP_IBM278                  = 20278, /**< IBM EBCDIC Finland-Sweden */
  CP_IBM280                  = 20280, /**< IBM EBCDIC Italy */
  CP_IBM284                  = 20284, /**< IBM EBCDIC Latin America-Spain */
  CP_IBM285                  = 20285, /**< IBM EBCDIC United Kingdom */
  CP_IBM290                  = 20290, /**< IBM EBCDIC Japanese Katakana Extended */
  CP_IBM297                  = 20297, /**< IBM EBCDIC France */
  CP_IBM420                  = 20420, /**< IBM EBCDIC Arabic */
  CP_IBM423                  = 20423, /**< IBM EBCDIC Greek */
  CP_IBM424                  = 20424, /**< IBM EBCDIC Hebrew */
  CP_X_EBCDIC_KOREANEXTENDED = 20833, /**< IBM EBCDIC Korean Extended */
  CP_IBM_THAI                = 20838, /**< IBM EBCDIC Thai */
  CP_KOI8_R                  = 20866, /**< Russian (KOI8-R); Cyrillic (KOI8-R) */
  CP_IBM871                  = 20871, /**< IBM EBCDIC Icelandic */
  CP_IBM880                  = 20880, /**< IBM EBCDIC Cyrillic Russian */
  CP_IBM905                  = 20905, /**< IBM EBCDIC Turkish */
  CP_IBM00924                = 20924, /**< IBM EBCDIC Latin 1/Open System (1047 + Euro symbol) */
  CP_EUC_JP_JIS              = 20932, /**< Japanese (JIS 0208-1990 and 0121-1990) */
  CP_X_CP20936               = 20936, /**< Simplified Chinese (GB2312); Chinese Simplified (GB2312-80) */
  CP_X_CP20949               = 20949, /**< Korean Wansung */
  CP_CP1025                  = 21025, /**< IBM EBCDIC Cyrillic Serbian-Bulgarian */
  CP_KOI8_U                  = 21866, /**< Ukrainian (KOI8-U); Cyrillic (KOI8-U) */
  CP_ISO_8859_1              = 28591, /**< ISO 8859-1 Latin 1; Western European (ISO) */
  CP_ISO_8859_2              = 28592, /**< ISO 8859-2 Central European; Central European (ISO) */
  CP_ISO_8859_3              = 28593, /**< ISO 8859-3 Latin 3 */
  CP_ISO_8859_4              = 28594, /**< ISO 8859-4 Baltic */
  CP_ISO_8859_5              = 28595, /**< ISO 8859-5 Cyrillic */
  CP_ISO_8859_6              = 28596, /**< ISO 8859-6 Arabic */
  CP_ISO_8859_7              = 28597, /**< ISO 8859-7 Greek */
  CP_ISO_8859_8              = 28598, /**< ISO 8859-8 Hebrew; Hebrew (ISO-Visual) */
  CP_ISO_8859_9              = 28599, /**< ISO 8859-9 Turkish */
  CP_ISO_8859_13             = 28603, /**< ISO 8859-13 Estonian */
  CP_ISO_8859_15             = 28605, /**< ISO 8859-15 Latin 9 */
  CP_X_EUROPA                = 29001, /**< Europa 3 */
  CP_ISO_8859_8_I            = 38598, /**< ISO 8859-8 Hebrew; Hebrew (ISO-Logical) */
  CP_ISO_2022_JP             = 50220, /**< ISO 2022 Japanese with no halfwidth Katakana; Japanese (JIS) */
  CP_CSISO2022JP             = 50221, /**< ISO 2022 Japanese with halfwidth Katakana; Japanese (JIS-Allow 1 byte Kana) */
  CP_ISO_2022_JP_JIS         = 50222, /**< ISO 2022 Japanese JIS X 0201-1989; Japanese (JIS-Allow 1 byte Kana - SO/SI) */
  CP_ISO_2022_KR             = 50225, /**< ISO 2022 Korean */
  CP_X_CP50227               = 50227, /**< ISO 2022 Simplified Chinese; Chinese Simplified (ISO 2022) */
  CP_EUC_JP                  = 51932, /**< EUC Japanese */
  CP_EUC_CN                  = 51936, /**< EUC Simplified Chinese; Chinese Simplified (EUC) */
  CP_EUC_KR                  = 51949, /**< EUC Korean */
  CP_HZ_GB_2312              = 52936, /**< HZ-GB2312 Simplified Chinese; Chinese Simplified (HZ) */
  CP_GB18030                 = 54936, /**< Windows XP and later: GB18030 Simplified Chinese (4 byte); Chinese Simplified (GB18030) */
  CP_X_ISCII_DE              = 57002, /**< ISCII Devanagari */
  CP_X_ISCII_BE              = 57003, /**< ISCII Bengali */
  CP_X_ISCII_TA              = 57004, /**< ISCII Tamil */
  CP_X_ISCII_TE              = 57005, /**< ISCII Telugu */
  CP_X_ISCII_AS              = 57006, /**< ISCII Assamese */
  CP_X_ISCII_OR              = 57007, /**< ISCII Oriya */
  CP_X_ISCII_KA              = 57008, /**< ISCII Kannada */
  CP_X_ISCII_MA              = 57009, /**< ISCII Malayalam */
  CP_X_ISCII_GU              = 57010, /**< ISCII Gujarati */
  CP_X_ISCII_PA              = 57011, /**< ISCII Punjabi */
  CP_UTF_7                   = 65000, /**< Unicode (UTF-7) */
  CP_UTF_8                   = 65001, /**< Unicode (UTF-8) */
};

//! From https://docs.microsoft.com/en-us/windows/win32/menurc/acceltableentry
enum class ACCELERATOR_FLAGS: size_t  {
  FVIRTKEY  = 0x01,
  FNOINVERT = 0x02,
  FSHIFT    = 0x04,
  FCONTROL  = 0x08,
  FALT      = 0x10,
  END       = 0x80,
};

//! From https://docs.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes
enum class ACCELERATOR_VK_CODES: size_t  {
  VK_LBUTTON             = 0x01,
  VK_RBUTTON             = 0x02,
  VK_CANCEL              = 0x03,
  VK_MBUTTON             = 0x04,
  VK_XBUTTON1            = 0x05,
  VK_XBUTTON2            = 0x06,
  VK_BACK                = 0x08,
  VK_TAB                 = 0x09,
  VK_CLEAR               = 0x0C,
  VK_RETURN              = 0x0D,
  VK_SHIFT               = 0x10,
  VK_CONTROL             = 0x11,
  VK_MENU                = 0x12,
  VK_PAUSE               = 0x13,
  VK_CAPITAL             = 0x14,
  VK_KANA                = 0x15,
  VK_HANGUEL             = 0x15,
  VK_HANGUL              = 0x15,
  VK_IME_ON              = 0x16,
  VK_JUNJA               = 0x17,
  VK_FINAL               = 0x18,
  VK_HANJA               = 0x19,
  VK_KANJI               = 0x19,
  VK_IME_OFF             = 0x1A,
  VK_ESCAPE              = 0x1B,
  VK_CONVERT             = 0x1C,
  VK_NONCONVERT          = 0x1D,
  VK_ACCEPT              = 0x1E,
  VK_MODECHANGE          = 0x1F,
  VK_SPACE               = 0x20,
  VK_PRIOR               = 0x21,
  VK_NEXT                = 0x22,
  VK_END                 = 0x23,
  VK_HOME                = 0x24,
  VK_LEFT                = 0x25,
  VK_UP                  = 0x26,
  VK_RIGHT               = 0x27,
  VK_DOWN                = 0x28,
  VK_SELECT              = 0x29,
  VK_PRINT               = 0x2A,
  VK_EXECUTE             = 0x2B,
  VK_SNAPSHOT            = 0x2C,
  VK_INSERT              = 0x2D,
  VK_DELETE              = 0x2E,
  VK_HELP                = 0x2F,
  VK_0                   = 0x30,
  VK_1                   = 0x31,
  VK_2                   = 0x32,
  VK_3                   = 0x33,
  VK_4                   = 0x34,
  VK_5                   = 0x35,
  VK_6                   = 0x36,
  VK_7                   = 0x37,
  VK_8                   = 0x38,
  VK_9                   = 0x39,
  VK_A                   = 0x41,
  VK_B                   = 0x42,
  VK_C                   = 0x43,
  VK_D                   = 0x44,
  VK_E                   = 0x45,
  VK_F                   = 0x46,
  VK_G                   = 0x47,
  VK_H                   = 0x48,
  VK_I                   = 0x49,
  VK_J                   = 0x4A,
  VK_K                   = 0x4B,
  VK_L                   = 0x4C,
  VK_M                   = 0x4D,
  VK_N                   = 0x4E,
  VK_O                   = 0x4F,
  VK_P                   = 0x50,
  VK_Q                   = 0x51,
  VK_R                   = 0x52,
  VK_S                   = 0x53,
  VK_T                   = 0x54,
  VK_U                   = 0x55,
  VK_V                   = 0x56,
  VK_W                   = 0x57,
  VK_X                   = 0x58,
  VK_Y                   = 0x59,
  VK_Z                   = 0x60,
  VK_LWIN                = 0x5B,
  VK_RWIN                = 0x5C,
  VK_APPS                = 0x5D,
  VK_SLEEP               = 0x5F,
  VK_NUMPAD0             = 0x60,
  VK_NUMPAD1             = 0x61,
  VK_NUMPAD2             = 0x62,
  VK_NUMPAD3             = 0x63,
  VK_NUMPAD4             = 0x64,
  VK_NUMPAD5             = 0x65,
  VK_NUMPAD6             = 0x66,
  VK_NUMPAD7             = 0x67,
  VK_NUMPAD8             = 0x68,
  VK_NUMPAD9             = 0x69,
  VK_MULTIPLY            = 0x6A,
  VK_ADD                 = 0x6B,
  VK_SEPARATOR           = 0x6C,
  VK_SUBTRACT            = 0x6D,
  VK_DECIMAL             = 0x6E,
  VK_DIVIDE              = 0x6F,
  VK_F1                  = 0x70,
  VK_F2                  = 0x71,
  VK_F3                  = 0x72,
  VK_F4                  = 0x73,
  VK_F5                  = 0x74,
  VK_F6                  = 0x75,
  VK_F7                  = 0x76,
  VK_F8                  = 0x77,
  VK_F9                  = 0x78,
  VK_F10                 = 0x79,
  VK_F11                 = 0x7A,
  VK_F12                 = 0x7B,
  VK_F13                 = 0x7C,
  VK_F14                 = 0x7D,
  VK_F15                 = 0x7E,
  VK_F16                 = 0x7F,
  VK_F17                 = 0x80,
  VK_F18                 = 0x81,
  VK_F19                 = 0x82,
  VK_F20                 = 0x83,
  VK_F21                 = 0x84,
  VK_F22                 = 0x85,
  VK_F23                 = 0x86,
  VK_F24                 = 0x87,
  VK_NUMLOCK             = 0x90,
  VK_SCROLL              = 0x91,
  VK_LSHIFT              = 0xA0,
  VK_RSHIFT              = 0xA1,
  VK_LCONTROL            = 0xA2,
  VK_RCONTROL            = 0xA3,
  VK_LMENU               = 0xA4,
  VK_RMENU               = 0xA5,
  VK_BROWSER_BACK        = 0xA6,
  VK_BROWSER_FORWARD     = 0xA7,
  VK_BROWSER_REFRESH     = 0xA8,
  VK_BROWSER_STOP        = 0xA9,
  VK_BROWSER_SEARCH      = 0xAA,
  VK_BROWSER_FAVORITES   = 0xAB,
  VK_BROWSER_HOME        = 0xAC,
  VK_VOLUME_MUTE         = 0xAD,
  VK_VOLUME_DOWN         = 0xAE,
  VK_VOLUME_UP           = 0xAF,
  VK_MEDIA_NEXT_TRACK    = 0xB0,
  VK_MEDIA_PREV_TRACK    = 0xB1,
  VK_MEDIA_STOP          = 0xB2,
  VK_MEDIA_PLAY_PAUSE    = 0xB3,
  VK_LAUNCH_MAIL         = 0xB4,
  VK_LAUNCH_MEDIA_SELECT = 0xB5,
  VK_LAUNCH_APP1         = 0xB6,
  VK_LAUNCH_APP2         = 0xB7,
  VK_OEM_1               = 0xBA,
  VK_OEM_PLUS            = 0xBB,
  VK_OEM_COMMA           = 0xBC,
  VK_OEM_MINUS           = 0xBD,
  VK_OEM_PERIOD          = 0xBE,
  VK_OEM_2               = 0xBF,
  VK_OEM_4               = 0xDB,
  VK_OEM_5               = 0xDC,
  VK_OEM_6               = 0xDD,
  VK_OEM_7               = 0xDE,
  VK_OEM_8               = 0xDF,
  VK_OEM_102             = 0xE2,
  VK_PROCESSKEY          = 0xE5,
  VK_PACKET              = 0xE7,
  VK_ATTN                = 0xF6,
  VK_CRSEL               = 0xF7,
  VK_EXSEL               = 0xF8,
  VK_EREOF               = 0xF9,
  VK_PLAY                = 0xFA,
  VK_ZOOM                = 0xFB,
  VK_NONAME              = 0xFC,
  VK_PA1                 = 0xFD,
  VK_OEM_CLEAR           = 0xFE,
};


//! Common section type
enum class PE_SECTION_TYPES : uint8_t {
  TEXT       = 0,
  TLS        = 1,
  IMPORT     = 2,
  DATA       = 3,
  BSS        = 4,
  RESOURCE   = 5,
  RELOCATION = 6,
  EXPORT     = 7,
  DEBUG_TYPE = 8,
  LOAD_CONFIG = 9,
  UNKNOWN     = 10
};

enum class PE_TYPE : uint16_t {
    PE32      = 0x10b, ///< 32bits
    PE32_PLUS = 0x20b  ///< 64 bits
};

//! Cryptography algorithms
enum class ALGORITHMS : uint32_t {
  UNKNOWN = 0,
  SHA_512,
  SHA_384,
  SHA_256,
  SHA_1,

  MD5,
  MD4,
  MD2,

  RSA,
  EC,

  MD5_RSA,
  SHA1_DSA,
  SHA1_RSA,
  SHA_256_RSA,
  SHA_384_RSA,
  SHA_512_RSA,
  SHA1_ECDSA,
  SHA_256_ECDSA,
  SHA_384_ECDSA,
  SHA_512_ECDSA,
};

}
}

ENABLE_BITMASK_OPERATORS(LIEF::PE::ACCELERATOR_FLAGS)
#endif

```

`KDemu/include/LIEF/LIEF/PE/enums.inc`:

```inc

enum _LIEF_EN(PE_TYPES) {
    _LIEF_EI(PE32)      = 0x10b, /** 32bits  */
    _LIEF_EI(PE32_PLUS) = 0x20b  /** 64 bits */
};

enum _LIEF_EN_2(SYMBOL_SECTION_NUMBER, int) {
  _LIEF_EI(IMAGE_SYM_DEBUG)     = -2,
  _LIEF_EI(IMAGE_SYM_ABSOLUTE)  = -1,
  _LIEF_EI(IMAGE_SYM_UNDEFINED) = 0
};


/** Storage class tells where and what the symbol represents */
enum _LIEF_EN_2(SYMBOL_STORAGE_CLASS, int) {
  _LIEF_EI(IMAGE_SYM_CLASS_INVALID) = 0xFF,

  _LIEF_EI(IMAGE_SYM_CLASS_END_OF_FUNCTION)  = -1,  /**< Physical end of function */
  _LIEF_EI(IMAGE_SYM_CLASS_NULL)             = 0,   /**< No symbol */
  _LIEF_EI(IMAGE_SYM_CLASS_AUTOMATIC)        = 1,   /**< Stack variable */
  _LIEF_EI(IMAGE_SYM_CLASS_EXTERNAL)         = 2,   /**< External symbol */
  _LIEF_EI(IMAGE_SYM_CLASS_STATIC)           = 3,   /**< Static */
  _LIEF_EI(IMAGE_SYM_CLASS_REGISTER)         = 4,   /**< Register variable */
  _LIEF_EI(IMAGE_SYM_CLASS_EXTERNAL_DEF)     = 5,   /**< External definition */
  _LIEF_EI(IMAGE_SYM_CLASS_LABEL)            = 6,   /**< Label */
  _LIEF_EI(IMAGE_SYM_CLASS_UNDEFINED_LABEL)  = 7,   /**< Undefined label */
  _LIEF_EI(IMAGE_SYM_CLASS_MEMBER_OF_STRUCT) = 8,   /**< Member of structure */
  _LIEF_EI(IMAGE_SYM_CLASS_ARGUMENT)         = 9,   /**< Function argument */
  _LIEF_EI(IMAGE_SYM_CLASS_STRUCT_TAG)       = 10,  /**< Structure tag */
  _LIEF_EI(IMAGE_SYM_CLASS_MEMBER_OF_UNION)  = 11,  /**< Member of union */
  _LIEF_EI(IMAGE_SYM_CLASS_UNION_TAG)        = 12,  /**< Union tag */
  _LIEF_EI(IMAGE_SYM_CLASS_TYPE_DEFINITION)  = 13,  /**< Type definition */
  _LIEF_EI(IMAGE_SYM_CLASS_UNDEFINED_STATIC) = 14,  /**< Undefined static */
  _LIEF_EI(IMAGE_SYM_CLASS_ENUM_TAG)         = 15,  /**< Enumeration tag */
  _LIEF_EI(IMAGE_SYM_CLASS_MEMBER_OF_ENUM)   = 16,  /**< Member of enumeration */
  _LIEF_EI(IMAGE_SYM_CLASS_REGISTER_PARAM)   = 17,  /**< Register parameter */
  _LIEF_EI(IMAGE_SYM_CLASS_BIT_FIELD)        = 18,  /**< Bit field ".bb" or ".eb" - beginning or end of block */
  _LIEF_EI(IMAGE_SYM_CLASS_BLOCK)            = 100, /**< ".bf" or ".ef" - beginning or end of function */
  _LIEF_EI(IMAGE_SYM_CLASS_FUNCTION)         = 101,
  _LIEF_EI(IMAGE_SYM_CLASS_END_OF_STRUCT)    = 102, /**< End of structure */
  _LIEF_EI(IMAGE_SYM_CLASS_FILE)             = 103, /**< File name line number, reformatted as symbol */
  _LIEF_EI(IMAGE_SYM_CLASS_SECTION)          = 104,
  _LIEF_EI(IMAGE_SYM_CLASS_WEAK_EXTERNAL)    = 105, /**< Duplicate tag external symbol in dmert public lib */
  _LIEF_EI(IMAGE_SYM_CLASS_CLR_TOKEN)        = 107
};


enum _LIEF_EN(SYMBOL_BASE_TYPES) {
  _LIEF_EI(IMAGE_SYM_TYPE_NULL)   = 0,  /**< No type information or unknown base type. */
  _LIEF_EI(IMAGE_SYM_TYPE_VOID)   = 1,  /**< Used with void pointers and functions. */
  _LIEF_EI(IMAGE_SYM_TYPE_CHAR)   = 2,  /**< A character (signed byte). */
  _LIEF_EI(IMAGE_SYM_TYPE_SHORT)  = 3,  /**< A 2-byte signed integer. */
  _LIEF_EI(IMAGE_SYM_TYPE_INT)    = 4,  /**< A natural integer type on the target. */
  _LIEF_EI(IMAGE_SYM_TYPE_LONG)   = 5,  /**< A 4-byte signed integer. */
  _LIEF_EI(IMAGE_SYM_TYPE_FLOAT)  = 6,  /**< A 4-byte floating-point number. */
  _LIEF_EI(IMAGE_SYM_TYPE_DOUBLE) = 7,  /**< An 8-byte floating-point number. */
  _LIEF_EI(IMAGE_SYM_TYPE_STRUCT) = 8,  /**< A structure. */
  _LIEF_EI(IMAGE_SYM_TYPE_UNION)  = 9,  /**< An union. */
  _LIEF_EI(IMAGE_SYM_TYPE_ENUM)   = 10, /**< An enumerated type. */
  _LIEF_EI(IMAGE_SYM_TYPE_MOE)    = 11, /**< A member of enumeration (a specific value). */
  _LIEF_EI(IMAGE_SYM_TYPE_BYTE)   = 12, /**< A byte; unsigned 1-byte integer. */
  _LIEF_EI(IMAGE_SYM_TYPE_WORD)   = 13, /**< A word; unsigned 2-byte integer. */
  _LIEF_EI(IMAGE_SYM_TYPE_UINT)   = 14, /**< An unsigned integer of natural size. */
  _LIEF_EI(IMAGE_SYM_TYPE_DWORD)  = 15  /**< An unsigned 4-byte integer. */
};

enum _LIEF_EN(SYMBOL_COMPLEX_TYPES) {
  _LIEF_EI(IMAGE_SYM_DTYPE_NULL)     = 0, /**< No complex type; simple scalar variable. */
  _LIEF_EI(IMAGE_SYM_DTYPE_POINTER)  = 1, /**< A pointer to base type. */
  _LIEF_EI(IMAGE_SYM_DTYPE_FUNCTION) = 2, /**< A function that returns a base type. */
  _LIEF_EI(IMAGE_SYM_DTYPE_ARRAY)    = 3, /**< An array of base type. */
  _LIEF_EI(SCT_COMPLEX_TYPE_SHIFT)   = 4  /**< Type is formed as (base + (derived << SCT_COMPLEX_TYPE_SHIFT)) */
};

enum _LIEF_EN(AuxSymbolType) {
  _LIEF_EI(IMAGE_AUX_SYMBOL_TYPE_TOKEN_DEF) = 1
};


enum _LIEF_EN(RELOCATIONS_BASE_TYPES) {
  _LIEF_EI(IMAGE_REL_BASED_ABSOLUTE)       = 0,
  _LIEF_EI(IMAGE_REL_BASED_HIGH)           = 1,
  _LIEF_EI(IMAGE_REL_BASED_LOW)            = 2,
  _LIEF_EI(IMAGE_REL_BASED_HIGHLOW)        = 3,
  _LIEF_EI(IMAGE_REL_BASED_HIGHADJ)        = 4,
  _LIEF_EI(IMAGE_REL_BASED_MIPS_JMPADDR)   = 5,
  _LIEF_EI(IMAGE_REL_BASED_ARM_MOV32A)     = 5,
  _LIEF_EI(IMAGE_REL_BASED_ARM_MOV32)      = 5,
  _LIEF_EI(IMAGE_REL_BASED_RISCV_HI20)     = 5,
  _LIEF_EI(IMAGE_REL_BASED_SECTION)        = 6,
  _LIEF_EI(IMAGE_REL_BASED_REL)            = 7,
  _LIEF_EI(IMAGE_REL_BASED_ARM_MOV32T)     = 7,
  _LIEF_EI(IMAGE_REL_BASED_THUMB_MOV32)    = 7,
  _LIEF_EI(IMAGE_REL_BASED_RISCV_LOW12I)   = 7,
  _LIEF_EI(IMAGE_REL_BASED_RISCV_LOW12S)   = 8,
  _LIEF_EI(IMAGE_REL_BASED_MIPS_JMPADDR16) = 9,
  _LIEF_EI(IMAGE_REL_BASED_IA64_IMM64)     = 9,
  _LIEF_EI(IMAGE_REL_BASED_DIR64)          = 10,
  _LIEF_EI(IMAGE_REL_BASED_HIGH3ADJ)       = 11,
};

enum _LIEF_EN(RELOCATIONS_I386) {
  _LIEF_EI(IMAGE_REL_I386_ABSOLUTE) = 0x0000,
  _LIEF_EI(IMAGE_REL_I386_DIR16)    = 0x0001,
  _LIEF_EI(IMAGE_REL_I386_REL16)    = 0x0002,
  _LIEF_EI(IMAGE_REL_I386_DIR32)    = 0x0006,
  _LIEF_EI(IMAGE_REL_I386_DIR32NB)  = 0x0007,
  _LIEF_EI(IMAGE_REL_I386_SEG12)    = 0x0009,
  _LIEF_EI(IMAGE_REL_I386_SECTION)  = 0x000A,
  _LIEF_EI(IMAGE_REL_I386_SECREL)   = 0x000B,
  _LIEF_EI(IMAGE_REL_I386_TOKEN)    = 0x000C,
  _LIEF_EI(IMAGE_REL_I386_SECREL7)  = 0x000D,
  _LIEF_EI(IMAGE_REL_I386_REL32)    = 0x0014
};

enum _LIEF_EN(RELOCATIONS_AMD64) {
  _LIEF_EI(IMAGE_REL_AMD64_ABSOLUTE) = 0x0000,
  _LIEF_EI(IMAGE_REL_AMD64_ADDR64)   = 0x0001,
  _LIEF_EI(IMAGE_REL_AMD64_ADDR32)   = 0x0002,
  _LIEF_EI(IMAGE_REL_AMD64_ADDR32NB) = 0x0003,
  _LIEF_EI(IMAGE_REL_AMD64_REL32)    = 0x0004,
  _LIEF_EI(IMAGE_REL_AMD64_REL32_1)  = 0x0005,
  _LIEF_EI(IMAGE_REL_AMD64_REL32_2)  = 0x0006,
  _LIEF_EI(IMAGE_REL_AMD64_REL32_3)  = 0x0007,
  _LIEF_EI(IMAGE_REL_AMD64_REL32_4)  = 0x0008,
  _LIEF_EI(IMAGE_REL_AMD64_REL32_5)  = 0x0009,
  _LIEF_EI(IMAGE_REL_AMD64_SECTION)  = 0x000A,
  _LIEF_EI(IMAGE_REL_AMD64_SECREL)   = 0x000B,
  _LIEF_EI(IMAGE_REL_AMD64_SECREL7)  = 0x000C,
  _LIEF_EI(IMAGE_REL_AMD64_TOKEN)    = 0x000D,
  _LIEF_EI(IMAGE_REL_AMD64_SREL32)   = 0x000E,
  _LIEF_EI(IMAGE_REL_AMD64_PAIR)     = 0x000F,
  _LIEF_EI(IMAGE_REL_AMD64_SSPAN32)  = 0x0010
};

enum _LIEF_EN(RELOCATIONS_ARM) {
  _LIEF_EI(IMAGE_REL_ARM_ABSOLUTE)  = 0x0000,
  _LIEF_EI(IMAGE_REL_ARM_ADDR32)    = 0x0001,
  _LIEF_EI(IMAGE_REL_ARM_ADDR32NB)  = 0x0002,
  _LIEF_EI(IMAGE_REL_ARM_BRANCH24)  = 0x0003,
  _LIEF_EI(IMAGE_REL_ARM_BRANCH11)  = 0x0004,
  _LIEF_EI(IMAGE_REL_ARM_TOKEN)     = 0x0005,
  _LIEF_EI(IMAGE_REL_ARM_BLX24)     = 0x0008,
  _LIEF_EI(IMAGE_REL_ARM_BLX11)     = 0x0009,
  _LIEF_EI(IMAGE_REL_ARM_SECTION)   = 0x000E,
  _LIEF_EI(IMAGE_REL_ARM_SECREL)    = 0x000F,
  _LIEF_EI(IMAGE_REL_ARM_MOV32A)    = 0x0010,
  _LIEF_EI(IMAGE_REL_ARM_MOV32T)    = 0x0011,
  _LIEF_EI(IMAGE_REL_ARM_BRANCH20T) = 0x0012,
  _LIEF_EI(IMAGE_REL_ARM_BRANCH24T) = 0x0014,
  _LIEF_EI(IMAGE_REL_ARM_BLX23T)    = 0x0015
};


/** These are not documented in the spec, but are located in WinNT.h. */
enum _LIEF_EN(WeakExternalCharacteristics) {
  _LIEF_EI(IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY) = 1,
  _LIEF_EI(IMAGE_WEAK_EXTERN_SEARCH_LIBRARY)   = 2,
  _LIEF_EI(IMAGE_WEAK_EXTERN_SEARCH_ALIAS)     = 3
};



enum _LIEF_EN(DEBUG_TYPES) {
  _LIEF_EI(IMAGE_DEBUG_TYPE_UNKNOWN)               = 0,
  _LIEF_EI(IMAGE_DEBUG_TYPE_COFF)                  = 1, /**< COFF debug information */
  _LIEF_EI(IMAGE_DEBUG_TYPE_CODEVIEW)              = 2, /**< CodeView debug information (pdb & cie) */
  _LIEF_EI(IMAGE_DEBUG_TYPE_FPO)                   = 3, /**< Frame pointer omission information */
  _LIEF_EI(IMAGE_DEBUG_TYPE_MISC)                  = 4, /**< CodeView Debug Information */
  _LIEF_EI(IMAGE_DEBUG_TYPE_EXCEPTION)             = 5, /**< A copy of .pdata section. */
  _LIEF_EI(IMAGE_DEBUG_TYPE_FIXUP)                 = 6, /**< Reserved. */
  _LIEF_EI(IMAGE_DEBUG_TYPE_OMAP_TO_SRC)           = 7, /**< The mapping from an RVA in image to an RVA in source image. */
  _LIEF_EI(IMAGE_DEBUG_TYPE_OMAP_FROM_SRC)         = 8, /**< The mapping from an RVA in source image to an RVA in image. */
  _LIEF_EI(IMAGE_DEBUG_TYPE_BORLAND)               = 9, /**< Reserved for Borland. */
  _LIEF_EI(IMAGE_DEBUG_TYPE_RESERVED10)            = 10, /**< Reserved for future use. */
  _LIEF_EI(IMAGE_DEBUG_TYPE_CLSID)                 = 11,
  _LIEF_EI(IMAGE_DEBUG_TYPE_VC_FEATURE)            = 12,
  _LIEF_EI(IMAGE_DEBUG_TYPE_POGO)                  = 13,
  _LIEF_EI(IMAGE_DEBUG_TYPE_ILTCG)                 = 14,
  _LIEF_EI(IMAGE_DEBUG_TYPE_MPX)                   = 15,
  _LIEF_EI(IMAGE_DEBUG_TYPE_REPRO)                 = 16,
  _LIEF_EI(IMAGE_DEBUG_TYPE_EX_DLLCHARACTERISTICS) = 20,
};


/** Code view signatures
 * @see: http://llvm.org/doxygen/CVDebugRecord_8h_source.html
 */
enum _LIEF_EN(CODE_VIEW_SIGNATURES) {
  _LIEF_EI(CVS_UNKNOWN) = 0,
  _LIEF_EI(CVS_PDB_70) = 0x53445352, /* RSDS */
  _LIEF_EI(CVS_PDB_20) = 0x3031424e, /* NB10 */
  _LIEF_EI(CVS_CV_50)  = 0x3131424e, /* NB11 */
  _LIEF_EI(CVS_CV_41)  = 0x3930424e, /* NB09 */
};

enum _LIEF_EN(POGO_SIGNATURES) {
  _LIEF_EI(POGO_UNKNOWN) = 0,
  _LIEF_EI(POGO_LCTG)    = 0x4C544347,  /* LCTG */
  _LIEF_EI(POGO_PGI)     = 0x50474900 , /* PGI\0 */
};

enum _LIEF_EN(ImportType) {
  _LIEF_EI(IMPORT_CODE)  = 0,
  _LIEF_EI(IMPORT_DATA)  = 1,
  _LIEF_EI(IMPORT_CONST) = 2
};


enum _LIEF_EN(ImportNameType) {
  /** Import is by ordinal. This indicates that the value in the Ordinal/Hint
   * field of the import header is the import's ordinal. If this constant is
   * not specified, then the Ordinal/Hint field should always be interpreted
   * as the import's hint.
   */
  _LIEF_EI(IMPORT_ORDINAL)         = 0,
  /** The import name is identical to the public symbol name */
  _LIEF_EI(IMPORT_NAME)            = 1,
  /** The import name is the public symbol name, but skipping the leading ?,
   * @, or optionally _.
   */
  _LIEF_EI(IMPORT_NAME_NOPREFIX)   = 2,
  /** The import name is the public symbol name, but skipping the leading ?,
   * @, or optionally _, and truncating at the first @.
   */
  _LIEF_EI(IMPORT_NAME_UNDECORATE) = 3
};


enum _LIEF_EN(CodeViewIdentifiers) {
  _LIEF_EI(DEBUG_LINE_TABLES_HAVE_COLUMN_RECORDS) = 0x1,
  _LIEF_EI(DEBUG_SECTION_MAGIC) = 0x4,
  _LIEF_EI(DEBUG_SYMBOL_SUBSECTION) = 0xF1,
  _LIEF_EI(DEBUG_LINE_TABLE_SUBSECTION) = 0xF2,
  _LIEF_EI(DEBUG_STRING_TABLE_SUBSECTION) = 0xF3,
  _LIEF_EI(DEBUG_INDEX_SUBSECTION) = 0xF4,

  /* Symbol subsections are split into records of different types. */
  _LIEF_EI(DEBUG_SYMBOL_TYPE_PROC_START) = 0x1147,
  _LIEF_EI(DEBUG_SYMBOL_TYPE_PROC_END) = 0x114F
};


/* =========================
 * Reources
 * =========================
 */

/** From https://docs.microsoft.com/en-us/windows/win32/menurc/resource-types */
enum _LIEF_EN(RESOURCE_TYPES) {
  _LIEF_EI(CURSOR)       = 1,
  _LIEF_EI(BITMAP)       = 2,
  _LIEF_EI(ICON)         = 3,
  _LIEF_EI(MENU)         = 4,
  _LIEF_EI(DIALOG)       = 5,
  _LIEF_EI(STRING)       = 6,
  _LIEF_EI(FONTDIR)      = 7,
  _LIEF_EI(FONT)         = 8,
  _LIEF_EI(ACCELERATOR)  = 9,
  _LIEF_EI(RCDATA)       = 10,
  _LIEF_EI(MESSAGETABLE) = 11,
  _LIEF_EI(GROUP_CURSOR) = 12,
  _LIEF_EI(GROUP_ICON)   = 14,
  _LIEF_EI(VERSION)      = 16,
  _LIEF_EI(DLGINCLUDE)   = 17,
  _LIEF_EI(PLUGPLAY)     = 19,
  _LIEF_EI(VXD)          = 20,
  _LIEF_EI(ANICURSOR)    = 21,
  _LIEF_EI(ANIICON)      = 22,
  _LIEF_EI(HTML)         = 23,
  _LIEF_EI(MANIFEST)     = 24
};

enum _LIEF_EN(RESOURCE_LANGS) {
  _LIEF_EI(LANG_NEUTRAL)        = 0x00,
  _LIEF_EI(LANG_INVARIANT)      = 0x7f,
  _LIEF_EI(LANG_AFRIKAANS)      = 0x36,
  _LIEF_EI(LANG_ALBANIAN)       = 0x1c,
  _LIEF_EI(LANG_ARABIC)         = 0x01,
  _LIEF_EI(LANG_ARMENIAN)       = 0x2b,
  _LIEF_EI(LANG_ASSAMESE)       = 0x4d,
  _LIEF_EI(LANG_AZERI)          = 0x2c,
  _LIEF_EI(LANG_BASQUE)         = 0x2d,
  _LIEF_EI(LANG_BELARUSIAN)     = 0x23,
  _LIEF_EI(LANG_BANGLA)         = 0x45,
  _LIEF_EI(LANG_BULGARIAN)      = 0x02,
  _LIEF_EI(LANG_CATALAN)        = 0x03,
  _LIEF_EI(LANG_CHINESE)        = 0x04,
  _LIEF_EI(LANG_CROATIAN)       = 0x1a,
  _LIEF_EI(LANG_BOSNIAN)        = 0x1a,
  _LIEF_EI(LANG_CZECH)          = 0x05,
  _LIEF_EI(LANG_DANISH)         = 0x06,
  _LIEF_EI(LANG_DIVEHI)         = 0x65,
  _LIEF_EI(LANG_DUTCH)          = 0x13,
  _LIEF_EI(LANG_ENGLISH)        = 0x09,
  _LIEF_EI(LANG_ESTONIAN)       = 0x25,
  _LIEF_EI(LANG_FAEROESE)       = 0x38,
  _LIEF_EI(LANG_FARSI)          = 0x29,
  _LIEF_EI(LANG_FINNISH)        = 0x0b,
  _LIEF_EI(LANG_FRENCH)         = 0x0c,
  _LIEF_EI(LANG_GALICIAN)       = 0x56,
  _LIEF_EI(LANG_GEORGIAN)       = 0x37,
  _LIEF_EI(LANG_GERMAN)         = 0x07,
  _LIEF_EI(LANG_GREEK)          = 0x08,
  _LIEF_EI(LANG_GUJARATI)       = 0x47,
  _LIEF_EI(LANG_HEBREW)         = 0x0d,
  _LIEF_EI(LANG_HINDI)          = 0x39,
  _LIEF_EI(LANG_HUNGARIAN)      = 0x0e,
  _LIEF_EI(LANG_ICELANDIC)      = 0x0f,
  _LIEF_EI(LANG_INDONESIAN)     = 0x21,
  _LIEF_EI(LANG_ITALIAN)        = 0x10,
  _LIEF_EI(LANG_JAPANESE)       = 0x11,
  _LIEF_EI(LANG_KANNADA)        = 0x4b,
  _LIEF_EI(LANG_KASHMIRI)       = 0x60,
  _LIEF_EI(LANG_KAZAK)          = 0x3f,
  _LIEF_EI(LANG_KONKANI)        = 0x57,
  _LIEF_EI(LANG_KOREAN)         = 0x12,
  _LIEF_EI(LANG_KYRGYZ)         = 0x40,
  _LIEF_EI(LANG_LATVIAN)        = 0x26,
  _LIEF_EI(LANG_LITHUANIAN)     = 0x27,
  _LIEF_EI(LANG_MACEDONIAN)     = 0x2f,
  _LIEF_EI(LANG_MALAY)          = 0x3e,
  _LIEF_EI(LANG_MALAYALAM)      = 0x4c,
  _LIEF_EI(LANG_MANIPURI)       = 0x58,
  _LIEF_EI(LANG_MARATHI)        = 0x4e,
  _LIEF_EI(LANG_MONGOLIAN)      = 0x50,
  _LIEF_EI(LANG_NEPALI)         = 0x61,
  _LIEF_EI(LANG_NORWEGIAN)      = 0x14,
  _LIEF_EI(LANG_ORIYA)          = 0x48,
  _LIEF_EI(LANG_POLISH)         = 0x15,
  _LIEF_EI(LANG_PORTUGUESE)     = 0x16,
  _LIEF_EI(LANG_PUNJABI)        = 0x46,
  _LIEF_EI(LANG_ROMANIAN)       = 0x18,
  _LIEF_EI(LANG_RUSSIAN)        = 0x19,
  _LIEF_EI(LANG_SANSKRIT)       = 0x4f,
  _LIEF_EI(LANG_SERBIAN)        = 0x1a,
  _LIEF_EI(LANG_SINDHI)         = 0x59,
  _LIEF_EI(LANG_SLOVAK)         = 0x1b,
  _LIEF_EI(LANG_SLOVENIAN)      = 0x24,
  _LIEF_EI(LANG_SPANISH)        = 0x0a,
  _LIEF_EI(LANG_SWAHILI)        = 0x41,
  _LIEF_EI(LANG_SWEDISH)        = 0x1d,
  _LIEF_EI(LANG_SYRIAC)         = 0x5a,
  _LIEF_EI(LANG_TAMIL)          = 0x49,
  _LIEF_EI(LANG_TATAR)          = 0x44,
  _LIEF_EI(LANG_TELUGU)         = 0x4a,
  _LIEF_EI(LANG_THAI)           = 0x1e,
  _LIEF_EI(LANG_TURKISH)        = 0x1f,
  _LIEF_EI(LANG_UKRAINIAN)      = 0x22,
  _LIEF_EI(LANG_URDU)           = 0x20,
  _LIEF_EI(LANG_UZBEK)          = 0x43,
  _LIEF_EI(LANG_VIETNAMESE)     = 0x2a,
  _LIEF_EI(LANG_GAELIC)         = 0x3c,
  _LIEF_EI(LANG_MALTESE)        = 0x3a,
  _LIEF_EI(LANG_MAORI)          = 0x28,
  _LIEF_EI(LANG_RHAETO_ROMANCE) = 0x17,
  _LIEF_EI(LANG_SAMI)           = 0x3b,
  _LIEF_EI(LANG_SORBIAN)        = 0x2e,
  _LIEF_EI(LANG_SUTU)           = 0x30,
  _LIEF_EI(LANG_TSONGA)         = 0x31,
  _LIEF_EI(LANG_TSWANA)         = 0x32,
  _LIEF_EI(LANG_VENDA)          = 0x33,
  _LIEF_EI(LANG_XHOSA)          = 0x34,
  _LIEF_EI(LANG_ZULU)           = 0x35,
  _LIEF_EI(LANG_ESPERANTO)      = 0x8f,
  _LIEF_EI(LANG_WALON)          = 0x90,
  _LIEF_EI(LANG_CORNISH)        = 0x91,
  _LIEF_EI(LANG_WELSH)          = 0x92,
  _LIEF_EI(LANG_BRETON)         = 0x93,
  _LIEF_EI(LANG_INUKTITUT)      = 0x5d,
  _LIEF_EI(LANG_IRISH)          = 0x3C,
  _LIEF_EI(LANG_LOWER_SORBIAN)  = 0x2E,
  _LIEF_EI(LANG_PULAR)          = 0x67,
  _LIEF_EI(LANG_QUECHUA)        = 0x6B,
  _LIEF_EI(LANG_TAMAZIGHT)      = 0x5F,
  _LIEF_EI(LANG_TIGRINYA)       = 0x73,
  _LIEF_EI(LANG_VALENCIAN)      = 0x03,
};

enum _LIEF_EN(RESOURCE_SUBLANGS) {
  _LIEF_EI(SUBLANG_AFRIKAANS_SOUTH_AFRICA) = 0,
  _LIEF_EI(SUBLANG_ALBANIAN_ALBANIA),
  _LIEF_EI(SUBLANG_ALSATIAN_FRANCE),
  _LIEF_EI(SUBLANG_AMHARIC_ETHIOPIA),
  _LIEF_EI(SUBLANG_ARABIC_ALGERIA),
  _LIEF_EI(SUBLANG_ARABIC_BAHRAIN),
  _LIEF_EI(SUBLANG_ARABIC_EGYPT),
  _LIEF_EI(SUBLANG_ARABIC_IRAQ),
  _LIEF_EI(SUBLANG_ARABIC_JORDAN),
  _LIEF_EI(SUBLANG_ARABIC_KUWAIT),
  _LIEF_EI(SUBLANG_ARABIC_LEBANON),
  _LIEF_EI(SUBLANG_ARABIC_LIBYA),
  _LIEF_EI(SUBLANG_ARABIC_MOROCCO),
  _LIEF_EI(SUBLANG_ARABIC_OMAN),
  _LIEF_EI(SUBLANG_ARABIC_QATAR),
  _LIEF_EI(SUBLANG_ARABIC_SAUDI_ARABIA),
  _LIEF_EI(SUBLANG_ARABIC_SYRIA),
  _LIEF_EI(SUBLANG_ARABIC_TUNISIA),
  _LIEF_EI(SUBLANG_ARABIC_UAE),
  _LIEF_EI(SUBLANG_ARABIC_YEMEN),
  _LIEF_EI(SUBLANG_ARMENIAN_ARMENIA),
  _LIEF_EI(SUBLANG_ASSAMESE_INDIA),
  _LIEF_EI(SUBLANG_AZERI_CYRILLIC),
  _LIEF_EI(SUBLANG_AZERI_LATIN),
  _LIEF_EI(SUBLANG_BASHKIR_RUSSIA),
  _LIEF_EI(SUBLANG_BASQUE_BASQUE),
  _LIEF_EI(SUBLANG_BELARUSIAN_BELARUS),
  _LIEF_EI(SUBLANG_BANGLA_BANGLADESH),
  _LIEF_EI(SUBLANG_BANGLA_INDIA),
  _LIEF_EI(SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_CYRILLIC),
  _LIEF_EI(SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_LATIN),
  _LIEF_EI(SUBLANG_BRETON_FRANCE),
  _LIEF_EI(SUBLANG_BULGARIAN_BULGARIA),
  _LIEF_EI(SUBLANG_CATALAN_CATALAN),
  _LIEF_EI(SUBLANG_CHINESE_HONGKONG),
  _LIEF_EI(SUBLANG_CHINESE_MACAU),
  _LIEF_EI(SUBLANG_CHINESE_SIMPLIFIED),
  _LIEF_EI(SUBLANG_CHINESE_SINGAPORE),
  _LIEF_EI(SUBLANG_CHINESE_TRADITIONAL),
  _LIEF_EI(SUBLANG_CORSICAN_FRANCE),
  _LIEF_EI(SUBLANG_CROATIAN_BOSNIA_HERZEGOVINA_LATIN),
  _LIEF_EI(SUBLANG_CROATIAN_CROATIA),
  _LIEF_EI(SUBLANG_CUSTOM_DEFAULT),
  _LIEF_EI(SUBLANG_CUSTOM_UNSPECIFIED),
  _LIEF_EI(SUBLANG_CZECH_CZECH_REPUBLIC),
  _LIEF_EI(SUBLANG_DANISH_DENMARK),
  _LIEF_EI(SUBLANG_DARI_AFGHANISTAN),
  _LIEF_EI(SUBLANG_DEFAULT),
  _LIEF_EI(SUBLANG_DIVEHI_MALDIVES),
  _LIEF_EI(SUBLANG_DUTCH_BELGIAN),
  _LIEF_EI(SUBLANG_DUTCH),
  _LIEF_EI(SUBLANG_ENGLISH_AUS),
  _LIEF_EI(SUBLANG_ENGLISH_BELIZE),
  _LIEF_EI(SUBLANG_ENGLISH_CAN),
  _LIEF_EI(SUBLANG_ENGLISH_CARIBBEAN),
  _LIEF_EI(SUBLANG_ENGLISH_EIRE),
  _LIEF_EI(SUBLANG_ENGLISH_INDIA),
  _LIEF_EI(SUBLANG_ENGLISH_JAMAICA),
  _LIEF_EI(SUBLANG_ENGLISH_MALAYSIA),
  _LIEF_EI(SUBLANG_ENGLISH_NZ),
  _LIEF_EI(SUBLANG_ENGLISH_PHILIPPINES),
  _LIEF_EI(SUBLANG_ENGLISH_SINGAPORE),
  _LIEF_EI(SUBLANG_ENGLISH_SOUTH_AFRICA),
  _LIEF_EI(SUBLANG_ENGLISH_TRINIDAD),
  _LIEF_EI(SUBLANG_ENGLISH_UK),
  _LIEF_EI(SUBLANG_ENGLISH_US),
  _LIEF_EI(SUBLANG_ENGLISH_ZIMBABWE),
  _LIEF_EI(SUBLANG_ENGLISH_IRELAND),
  _LIEF_EI(SUBLANG_ESTONIAN_ESTONIA),
  _LIEF_EI(SUBLANG_FAEROESE_FAROE_ISLANDS),
  _LIEF_EI(SUBLANG_FILIPINO_PHILIPPINES),
  _LIEF_EI(SUBLANG_FINNISH_FINLAND),
  _LIEF_EI(SUBLANG_FRENCH_BELGIAN),
  _LIEF_EI(SUBLANG_FRENCH_CANADIAN),
  _LIEF_EI(SUBLANG_FRENCH_LUXEMBOURG),
  _LIEF_EI(SUBLANG_FRENCH_MONACO),
  _LIEF_EI(SUBLANG_FRENCH_SWISS),
  _LIEF_EI(SUBLANG_FRENCH),
  _LIEF_EI(SUBLANG_FRISIAN_NETHERLANDS),
  _LIEF_EI(SUBLANG_GALICIAN_GALICIAN),
  _LIEF_EI(SUBLANG_GEORGIAN_GEORGIA),
  _LIEF_EI(SUBLANG_GERMAN_AUSTRIAN),
  _LIEF_EI(SUBLANG_GERMAN_LIECHTENSTEIN),
  _LIEF_EI(SUBLANG_GERMAN_LUXEMBOURG),
  _LIEF_EI(SUBLANG_GERMAN_SWISS),
  _LIEF_EI(SUBLANG_GERMAN),
  _LIEF_EI(SUBLANG_GREEK_GREECE),
  _LIEF_EI(SUBLANG_GREENLANDIC_GREENLAND),
  _LIEF_EI(SUBLANG_GUJARATI_INDIA),
  _LIEF_EI(SUBLANG_HAUSA_NIGERIA_LATIN),
  _LIEF_EI(SUBLANG_HEBREW_ISRAEL),
  _LIEF_EI(SUBLANG_HINDI_INDIA),
  _LIEF_EI(SUBLANG_HUNGARIAN_HUNGARY),
  _LIEF_EI(SUBLANG_ICELANDIC_ICELAND),
  _LIEF_EI(SUBLANG_IGBO_NIGERIA),
  _LIEF_EI(SUBLANG_INDONESIAN_INDONESIA),
  _LIEF_EI(SUBLANG_INUKTITUT_CANADA_LATIN),
  _LIEF_EI(SUBLANG_INUKTITUT_CANADA),
  _LIEF_EI(SUBLANG_IRISH_IRELAND),
  _LIEF_EI(SUBLANG_ITALIAN_SWISS),
  _LIEF_EI(SUBLANG_ITALIAN),
  _LIEF_EI(SUBLANG_JAPANESE_JAPAN),
  _LIEF_EI(SUBLANG_KANNADA_INDIA),
  _LIEF_EI(SUBLANG_KASHMIRI_INDIA),
  _LIEF_EI(SUBLANG_KASHMIRI_SASIA),
  _LIEF_EI(SUBLANG_KAZAK_KAZAKHSTAN),
  _LIEF_EI(SUBLANG_KHMER_CAMBODIA),
  _LIEF_EI(SUBLANG_KICHE_GUATEMALA),
  _LIEF_EI(SUBLANG_KINYARWANDA_RWANDA),
  _LIEF_EI(SUBLANG_KONKANI_INDIA),
  _LIEF_EI(SUBLANG_KOREAN),
  _LIEF_EI(SUBLANG_KYRGYZ_KYRGYZSTAN),
  _LIEF_EI(SUBLANG_LAO_LAO),
  _LIEF_EI(SUBLANG_LATVIAN_LATVIA),
  _LIEF_EI(SUBLANG_LITHUANIAN_CLASSIC),
  _LIEF_EI(SUBLANG_LITHUANIAN),
  _LIEF_EI(SUBLANG_LOWER_SORBIAN_GERMANY),
  _LIEF_EI(SUBLANG_LUXEMBOURGISH_LUXEMBOURG),
  _LIEF_EI(SUBLANG_MACEDONIAN_MACEDONIA),
  _LIEF_EI(SUBLANG_MALAY_BRUNEI_DARUSSALAM),
  _LIEF_EI(SUBLANG_MALAY_MALAYSIA),
  _LIEF_EI(SUBLANG_MALAYALAM_INDIA),
  _LIEF_EI(SUBLANG_MALTESE_MALTA),
  _LIEF_EI(SUBLANG_MAORI_NEW_ZEALAND),
  _LIEF_EI(SUBLANG_MAPUDUNGUN_CHILE),
  _LIEF_EI(SUBLANG_MARATHI_INDIA),
  _LIEF_EI(SUBLANG_MOHAWK_MOHAWK),
  _LIEF_EI(SUBLANG_MONGOLIAN_CYRILLIC_MONGOLIA),
  _LIEF_EI(SUBLANG_MONGOLIAN_PRC),
  _LIEF_EI(SUBLANG_NEPALI_INDIA),
  _LIEF_EI(SUBLANG_NEPALI_NEPAL),
  _LIEF_EI(SUBLANG_NEUTRAL),
  _LIEF_EI(SUBLANG_NORWEGIAN_BOKMAL),
  _LIEF_EI(SUBLANG_NORWEGIAN_NYNORSK),
  _LIEF_EI(SUBLANG_OCCITAN_FRANCE),
  _LIEF_EI(SUBLANG_ORIYA_INDIA),
  _LIEF_EI(SUBLANG_PASHTO_AFGHANISTAN),
  _LIEF_EI(SUBLANG_PERSIAN_IRAN),
  _LIEF_EI(SUBLANG_POLISH_POLAND),
  _LIEF_EI(SUBLANG_PORTUGUESE_BRAZILIAN),
  _LIEF_EI(SUBLANG_PORTUGUESE),
  _LIEF_EI(SUBLANG_PUNJABI_INDIA),
  _LIEF_EI(SUBLANG_QUECHUA_BOLIVIA),
  _LIEF_EI(SUBLANG_QUECHUA_ECUADOR),
  _LIEF_EI(SUBLANG_QUECHUA_PERU),
  _LIEF_EI(SUBLANG_ROMANIAN_ROMANIA),
  _LIEF_EI(SUBLANG_ROMANSH_SWITZERLAND),
  _LIEF_EI(SUBLANG_RUSSIAN_RUSSIA),
  _LIEF_EI(SUBLANG_SAMI_INARI_FINLAND),
  _LIEF_EI(SUBLANG_SAMI_LULE_NORWAY),
  _LIEF_EI(SUBLANG_SAMI_LULE_SWEDEN),
  _LIEF_EI(SUBLANG_SAMI_NORTHERN_FINLAND),
  _LIEF_EI(SUBLANG_SAMI_NORTHERN_NORWAY),
  _LIEF_EI(SUBLANG_SAMI_NORTHERN_SWEDEN),
  _LIEF_EI(SUBLANG_SAMI_SKOLT_FINLAND),
  _LIEF_EI(SUBLANG_SAMI_SOUTHERN_NORWAY),
  _LIEF_EI(SUBLANG_SAMI_SOUTHERN_SWEDEN),
  _LIEF_EI(SUBLANG_SANSKRIT_INDIA),
  _LIEF_EI(SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_CYRILLIC),
  _LIEF_EI(SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_LATIN),
  _LIEF_EI(SUBLANG_SERBIAN_CROATIA),
  _LIEF_EI(SUBLANG_SERBIAN_CYRILLIC),
  _LIEF_EI(SUBLANG_SERBIAN_LATIN),
  _LIEF_EI(SUBLANG_SINDHI_AFGHANISTAN),
  _LIEF_EI(SUBLANG_SINDHI_INDIA),
  _LIEF_EI(SUBLANG_SINDHI_PAKISTAN),
  _LIEF_EI(SUBLANG_SINHALESE_SRI_LANKA),
  _LIEF_EI(SUBLANG_SLOVAK_SLOVAKIA),
  _LIEF_EI(SUBLANG_SLOVENIAN_SLOVENIA),
  _LIEF_EI(SUBLANG_SOTHO_NORTHERN_SOUTH_AFRICA),
  _LIEF_EI(SUBLANG_SPANISH_ARGENTINA),
  _LIEF_EI(SUBLANG_SPANISH_BOLIVIA),
  _LIEF_EI(SUBLANG_SPANISH_CHILE),
  _LIEF_EI(SUBLANG_SPANISH_COLOMBIA),
  _LIEF_EI(SUBLANG_SPANISH_COSTA_RICA),
  _LIEF_EI(SUBLANG_SPANISH_DOMINICAN_REPUBLIC),
  _LIEF_EI(SUBLANG_SPANISH_ECUADOR),
  _LIEF_EI(SUBLANG_SPANISH_EL_SALVADOR),
  _LIEF_EI(SUBLANG_SPANISH_GUATEMALA),
  _LIEF_EI(SUBLANG_SPANISH_HONDURAS),
  _LIEF_EI(SUBLANG_SPANISH_MEXICAN),
  _LIEF_EI(SUBLANG_SPANISH_MODERN),
  _LIEF_EI(SUBLANG_SPANISH_NICARAGUA),
  _LIEF_EI(SUBLANG_SPANISH_PANAMA),
  _LIEF_EI(SUBLANG_SPANISH_PARAGUAY),
  _LIEF_EI(SUBLANG_SPANISH_PERU),
  _LIEF_EI(SUBLANG_SPANISH_PUERTO_RICO),
  _LIEF_EI(SUBLANG_SPANISH_URUGUAY),
  _LIEF_EI(SUBLANG_SPANISH_US),
  _LIEF_EI(SUBLANG_SPANISH_VENEZUELA),
  _LIEF_EI(SUBLANG_SPANISH),
  _LIEF_EI(SUBLANG_SWAHILI_KENYA),
  _LIEF_EI(SUBLANG_SWEDISH_FINLAND),
  _LIEF_EI(SUBLANG_SWEDISH),
  _LIEF_EI(SUBLANG_SYRIAC_SYRIA),
  _LIEF_EI(SUBLANG_SYS_DEFAULT),
  _LIEF_EI(SUBLANG_TAJIK_TAJIKISTAN),
  _LIEF_EI(SUBLANG_TAMAZIGHT_ALGERIA_LATIN),
  _LIEF_EI(SUBLANG_TAMIL_INDIA),
  _LIEF_EI(SUBLANG_TATAR_RUSSIA),
  _LIEF_EI(SUBLANG_TELUGU_INDIA),
  _LIEF_EI(SUBLANG_THAI_THAILAND),
  _LIEF_EI(SUBLANG_TIBETAN_PRC),
  _LIEF_EI(SUBLANG_TIGRIGNA_ERITREA),
  _LIEF_EI(SUBLANG_TSWANA_SOUTH_AFRICA),
  _LIEF_EI(SUBLANG_TURKISH_TURKEY),
  _LIEF_EI(SUBLANG_TURKMEN_TURKMENISTAN),
  _LIEF_EI(SUBLANG_UI_CUSTOM_DEFAULT),
  _LIEF_EI(SUBLANG_UIGHUR_PRC),
  _LIEF_EI(SUBLANG_UKRAINIAN_UKRAINE),
  _LIEF_EI(SUBLANG_UPPER_SORBIAN_GERMANY),
  _LIEF_EI(SUBLANG_URDU_INDIA),
  _LIEF_EI(SUBLANG_URDU_PAKISTAN),
  _LIEF_EI(SUBLANG_UZBEK_CYRILLIC),
  _LIEF_EI(SUBLANG_UZBEK_LATIN),
  _LIEF_EI(SUBLANG_VIETNAMESE_VIETNAM),
  _LIEF_EI(SUBLANG_WELSH_UNITED_KINGDOM),
  _LIEF_EI(SUBLANG_WOLOF_SENEGAL),
  _LIEF_EI(SUBLANG_XHOSA_SOUTH_AFRICA),
  _LIEF_EI(SUBLANG_YAKUT_RUSSIA),
  _LIEF_EI(SUBLANG_YI_PRC),
  _LIEF_EI(SUBLANG_YORUBA_NIGERIA),
  _LIEF_EI(SUBLANG_ZULU_SOUTH_AFRICA),
  _LIEF_EI(SUBLANG_PULAR_SENEGAL),
  _LIEF_EI(SUBLANG_PUNJABI_PAKISTAN),
  _LIEF_EI(SUBLANG_TSWANA_BOTSWANA),
  _LIEF_EI(SUBLANG_TAMIL_SRI_LANKA),
  _LIEF_EI(SUBLANG_TIGRINYA_ETHIOPIA),
  _LIEF_EI(SUBLANG_TIGRINYA_ERITREA),
  _LIEF_EI(SUBLANG_VALENCIAN_VALENCIA),
};


/** From https://docs.microsoft.com/en-us/windows/win32/winmsg/extended-window-styles */
enum _LIEF_EN(EXTENDED_WINDOW_STYLES) {
  _LIEF_EI(WS_EX_DLGMODALFRAME)    = 0x00000001L,
  _LIEF_EI(WS_EX_NOPARENTNOTIFY)   = 0x00000004L,
  _LIEF_EI(WS_EX_TOPMOST)          = 0x00000008L,
  _LIEF_EI(WS_EX_ACCEPTFILES)      = 0x00000010L,
  _LIEF_EI(WS_EX_TRANSPARENT)      = 0x00000020L,
  _LIEF_EI(WS_EX_MDICHILD)         = 0x00000040L,
  _LIEF_EI(WS_EX_TOOLWINDOW)       = 0x00000080L,
  _LIEF_EI(WS_EX_WINDOWEDGE)       = 0x00000100L,
  _LIEF_EI(WS_EX_CLIENTEDGE)       = 0x00000200L,
  _LIEF_EI(WS_EX_CONTEXTHELP)      = 0x00000400L,

  _LIEF_EI(WS_EX_RIGHT)            = 0x00001000L,
  _LIEF_EI(WS_EX_LEFT)             = 0x00000000L,
  _LIEF_EI(WS_EX_RTLREADING)       = 0x00002000L,
  _LIEF_EI(WS_EX_LTRREADING)       = 0x00000000L,
  _LIEF_EI(WS_EX_LEFTSCROLLBAR)    = 0x00004000L,
  _LIEF_EI(WS_EX_RIGHTSCROLLBAR)   = 0x00000000L,

  _LIEF_EI(WS_EX_CONTROLPARENT)    = 0x00010000L,
  _LIEF_EI(WS_EX_STATICEDGE)       = 0x00020000L,
  _LIEF_EI(WS_EX_APPWINDOW)        = 0x00040000L,
};

/** From: https://docs.microsoft.com/en-us/windows/win32/winmsg/window-styles */
enum _LIEF_EN(WINDOW_STYLES) {
  _LIEF_EI(WS_OVERLAPPED)      = 0x00000000L,
  _LIEF_EI(WS_POPUP)           = 0x80000000L,
  _LIEF_EI(WS_CHILD)           = 0x40000000L,
  _LIEF_EI(WS_MINIMIZE)        = 0x20000000L,
  _LIEF_EI(WS_VISIBLE)         = 0x10000000L,
  _LIEF_EI(WS_DISABLED)        = 0x08000000L,
  _LIEF_EI(WS_CLIPSIBLINGS)    = 0x04000000L,
  _LIEF_EI(WS_CLIPCHILDREN)    = 0x02000000L,
  _LIEF_EI(WS_MAXIMIZE)        = 0x01000000L,
  _LIEF_EI(WS_CAPTION)         = 0x00C00000L,
  _LIEF_EI(WS_BORDER)          = 0x00800000L,
  _LIEF_EI(WS_DLGFRAME)        = 0x00400000L,
  _LIEF_EI(WS_VSCROLL)         = 0x00200000L,
  _LIEF_EI(WS_HSCROLL)         = 0x00100000L,
  _LIEF_EI(WS_SYSMENU)         = 0x00080000L,
  _LIEF_EI(WS_THICKFRAME)      = 0x00040000L,
  _LIEF_EI(WS_GROUP)           = 0x00020000L,
  _LIEF_EI(WS_TABSTOP)         = 0x00010000L,

  _LIEF_EI(WS_MINIMIZEBOX)     = 0x00020000L,
  _LIEF_EI(WS_MAXIMIZEBOX)     = 0x00010000L,
};


/** From https://docs.microsoft.com/en-us/windows/win32/dlgbox/dialog-box-styles */
enum _LIEF_EN(DIALOG_BOX_STYLES) {
  _LIEF_EI(DS_ABSALIGN)      = 0x0001L,
  _LIEF_EI(DS_SYSMODAL)      = 0x0002L,
  _LIEF_EI(DS_LOCALEDIT)     = 0x0020L,
  _LIEF_EI(DS_SETFONT)       = 0x0040L,
  _LIEF_EI(DS_MODALFRAME)    = 0x0080L,
  _LIEF_EI(DS_NOIDLEMSG)     = 0x0100L,
  _LIEF_EI(DS_SETFOREGROUND) = 0x0200L,
  _LIEF_EI(DS_3DLOOK)        = 0x0004L,
  _LIEF_EI(DS_FIXEDSYS)      = 0x0008L,
  _LIEF_EI(DS_NOFAILCREATE)  = 0x0010L,
  _LIEF_EI(DS_CONTROL)       = 0x0400L,
  _LIEF_EI(DS_CENTER)        = 0x0800L,
  _LIEF_EI(DS_CENTERMOUSE)   = 0x1000L,
  _LIEF_EI(DS_CONTEXTHELP)   = 0x2000L,
  _LIEF_EI(DS_SHELLFONT)     = 0x0040L | 0x0008L, /* DS_SETFONT | DS_FIXEDSYS */
};

enum _LIEF_EN(FIXED_VERSION_OS) {
  _LIEF_EI(VOS_UNKNOWN)       = 0x00000000L,
  _LIEF_EI(VOS_DOS)           = 0x00010000L,
  _LIEF_EI(VOS_NT)            = 0x00040000L,
  _LIEF_EI(VOS__WINDOWS16)    = 0x00000001L,
  _LIEF_EI(VOS__WINDOWS32)    = 0x00000004L,
  _LIEF_EI(VOS_OS216)         = 0x00020000L,
  _LIEF_EI(VOS_OS232)         = 0x00030000L,
  _LIEF_EI(VOS__PM16)         = 0x00000002L,
  _LIEF_EI(VOS__PM32)         = 0x00000003L,
  _LIEF_EI(VOS_DOS_WINDOWS16) = 0x00010000L | 0x00000001L, /* VOS_DOS   | VOS__WINDOWS16 */
  _LIEF_EI(VOS_DOS_WINDOWS32) = 0x00010000L | 0x00000004L, /* VOS_DOS   | VOS__WINDOWS32 */
  _LIEF_EI(VOS_NT_WINDOWS32)  = 0x00040000L | 0x00000004L, /* VOS_NT    | VOS__WINDOWS32 */
  _LIEF_EI(VOS_OS216_PM16)    = 0x00020000L | 0x00000002L, /* VOS_OS216 | VOS__PM16 */
  _LIEF_EI(VOS_OS232_PM32)    = 0x00030000L | 0x00000003L, /* VOS_OS232 | VOS__PM32 */
};


enum _LIEF_EN(FIXED_VERSION_FILE_FLAGS) {
  _LIEF_EI(VS_FF_DEBUG)        = 0x00000001L,
  _LIEF_EI(VS_FF_INFOINFERRED) = 0x00000010L,
  _LIEF_EI(VS_FF_PATCHED)      = 0x00000004L,
  _LIEF_EI(VS_FF_PRERELEASE)   = 0x00000002L,
  _LIEF_EI(VS_FF_PRIVATEBUILD) = 0x00000008L,
  _LIEF_EI(VS_FF_SPECIALBUILD) = 0x00000020L,
};


enum _LIEF_EN(FIXED_VERSION_FILE_TYPES) {
  _LIEF_EI(VFT_APP)        = 0x00000001L,
  _LIEF_EI(VFT_DLL)        = 0x00000002L,
  _LIEF_EI(VFT_DRV)        = 0x00000003L,
  _LIEF_EI(VFT_FONT)       = 0x00000004L,
  _LIEF_EI(VFT_STATIC_LIB) = 0x00000007L,
  _LIEF_EI(VFT_UNKNOWN)    = 0x00000000L,
  _LIEF_EI(VFT_VXD)        = 0x00000005L,
};


enum _LIEF_EN(FIXED_VERSION_FILE_SUB_TYPES) {
  _LIEF_EI(VFT2_DRV_COMM)              = 0x0000000AL,
  _LIEF_EI(VFT2_DRV_DISPLAY)           = 0x00000004L,
  _LIEF_EI(VFT2_DRV_INSTALLABLE)       = 0x00000008L,
  _LIEF_EI(VFT2_DRV_KEYBOARD)          = 0x00000002L,
  _LIEF_EI(VFT2_DRV_LANGUAGE)          = 0x00000003L,
  _LIEF_EI(VFT2_DRV_MOUSE)             = 0x00000005L,
  _LIEF_EI(VFT2_DRV_NETWORK)           = 0x00000006L,
  _LIEF_EI(VFT2_DRV_PRINTER)           = 0x00000001L,
  _LIEF_EI(VFT2_DRV_SOUND)             = 0x00000009L,
  _LIEF_EI(VFT2_DRV_SYSTEM)            = 0x00000007L,
  _LIEF_EI(VFT2_DRV_VERSIONED_PRINTER) = 0x0000000CL,

  _LIEF_EI(VFT2_FONT_RASTER)           = 0x00000001L,
  _LIEF_EI(VFT2_FONT_TRUETYPE)         = 0x00000003L,
  _LIEF_EI(VFT2_FONT_VECTOR)           = 0x00000002L,

  _LIEF_EI(VFT2_UNKNOWN)               = 0x00000000L,
};

/** Code page from https://docs.microsoft.com/en-us/windows/win32/intl/code-page-identifiers */
enum _LIEF_EN(CODE_PAGES) {
  _LIEF_EI(CP_IBM037)                  = 37,    /**< IBM EBCDIC US-Canada */
  _LIEF_EI(CP_IBM437)                  = 437,   /**< OEM United States */
  _LIEF_EI(CP_IBM500)                  = 500,   /**< IBM EBCDIC International */
  _LIEF_EI(CP_ASMO_708)                = 708,   /**< Arabic (ASMO 708) */
  _LIEF_EI(CP_DOS_720)                 = 720,   /**< Arabic (Transparent ASMO); Arabic (DOS) */
  _LIEF_EI(CP_IBM737)                  = 737,   /**< OEM Greek (formerly 437G); Greek (DOS) */
  _LIEF_EI(CP_IBM775)                  = 775,   /**< OEM Baltic; Baltic (DOS) */
  _LIEF_EI(CP_IBM850)                  = 850,   /**< OEM Multilingual Latin 1; Western European (DOS) */
  _LIEF_EI(CP_IBM852)                  = 852,   /**< OEM Latin 2; Central European (DOS) */
  _LIEF_EI(CP_IBM855)                  = 855,   /**< OEM Cyrillic (primarily Russian) */
  _LIEF_EI(CP_IBM857)                  = 857,   /**< OEM Turkish; Turkish (DOS) */
  _LIEF_EI(CP_IBM00858)                = 858,   /**< OEM Multilingual Latin 1 + Euro symbol */
  _LIEF_EI(CP_IBM860)                  = 860,   /**< OEM Portuguese; Portuguese (DOS) */
  _LIEF_EI(CP_IBM861)                  = 861,   /**< OEM Icelandic; Icelandic (DOS) */
  _LIEF_EI(CP_DOS_862)                 = 862,   /**< OEM Hebrew; Hebrew (DOS) */
  _LIEF_EI(CP_IBM863)                  = 863,   /**< OEM French Canadian; French Canadian (DOS) */
  _LIEF_EI(CP_IBM864)                  = 864,   /**< OEM Arabic; Arabic (864) */
  _LIEF_EI(CP_IBM865)                  = 865,   /**< OEM Nordic; Nordic (DOS) */
  _LIEF_EI(CP_CP866)                   = 866,   /**< OEM Russian; Cyrillic (DOS) */
  _LIEF_EI(CP_IBM869)                  = 869,   /**< OEM Modern Greek; Greek, Modern (DOS) */
  _LIEF_EI(CP_IBM870)                  = 870,   /**< IBM EBCDIC Multilingual/ROECE (Latin 2); IBM EBCDIC Multilingual Latin 2 */
  _LIEF_EI(CP_WINDOWS_874)             = 874,   /**< ANSI/OEM Thai (same as 28605, ISO 8859-15); Thai (Windows) */
  _LIEF_EI(CP_CP875)                   = 875,   /**< IBM EBCDIC Greek Modern */
  _LIEF_EI(CP_SHIFT_JIS)               = 932,   /**< ANSI/OEM Japanese; Japanese (Shift-JIS) */
  _LIEF_EI(CP_GB2312)                  = 936,   /**< ANSI/OEM Simplified Chinese (PRC, Singapore); Chinese Simplified (GB2312) */
  _LIEF_EI(CP_KS_C_5601_1987)          = 949,   /**< ANSI/OEM Korean (Unified Hangul Code) */
  _LIEF_EI(CP_BIG5)                    = 950,   /**< ANSI/OEM Traditional Chinese (Taiwan; Hong Kong SAR, PRC); Chinese Traditional (Big5) */
  _LIEF_EI(CP_IBM1026)                 = 1026,  /**< IBM EBCDIC Turkish (Latin 5) */
  _LIEF_EI(CP_IBM01047)                = 1047,  /**< IBM EBCDIC Latin 1/Open System */
  _LIEF_EI(CP_IBM01140)                = 1140,  /**< IBM EBCDIC US-Canada (037 + Euro symbol); IBM EBCDIC (US-Canada-Euro) */
  _LIEF_EI(CP_IBM01141)                = 1141,  /**< IBM EBCDIC Germany (20273 + Euro symbol); IBM EBCDIC (Germany-Euro) */
  _LIEF_EI(CP_IBM01142)                = 1142,  /**< IBM EBCDIC Denmark-Norway (20277 + Euro symbol); IBM EBCDIC (Denmark-Norway-Euro) */
  _LIEF_EI(CP_IBM01143)                = 1143,  /**< IBM EBCDIC Finland-Sweden (20278 + Euro symbol); IBM EBCDIC (Finland-Sweden-Euro) */
  _LIEF_EI(CP_IBM01144)                = 1144,  /**< IBM EBCDIC Italy (20280 + Euro symbol); IBM EBCDIC (Italy-Euro) */
  _LIEF_EI(CP_IBM01145)                = 1145,  /**< IBM EBCDIC Latin America-Spain (20284 + Euro symbol); IBM EBCDIC (Spain-Euro) */
  _LIEF_EI(CP_IBM01146)                = 1146,  /**< IBM EBCDIC United Kingdom (20285 + Euro symbol); IBM EBCDIC (UK-Euro) */
  _LIEF_EI(CP_IBM01147)                = 1147,  /**< IBM EBCDIC France (20297 + Euro symbol); IBM EBCDIC (France-Euro) */
  _LIEF_EI(CP_IBM01148)                = 1148,  /**< IBM EBCDIC International (500 + Euro symbol); IBM EBCDIC (International-Euro) */
  _LIEF_EI(CP_IBM01149)                = 1149,  /**< IBM EBCDIC Icelandic (20871 + Euro symbol); IBM EBCDIC (Icelandic-Euro) */
  _LIEF_EI(CP_UTF_16)                  = 1200,  /**< Unicode UTF-16, little endian byte order (BMP of ISO 10646); available only to managed applications */
  _LIEF_EI(CP_UNICODEFFFE)             = 1201,  /**< Unicode UTF-16, big endian byte order; available only to managed applications */
  _LIEF_EI(CP_WINDOWS_1250)            = 1250,  /**< ANSI Central European; Central European (Windows) */
  _LIEF_EI(CP_WINDOWS_1251)            = 1251,  /**< ANSI Cyrillic; Cyrillic (Windows) */
  _LIEF_EI(CP_WINDOWS_1252)            = 1252,  /**< ANSI Latin 1; Western European (Windows) */
  _LIEF_EI(CP_WINDOWS_1253)            = 1253,  /**< ANSI Greek; Greek (Windows) */
  _LIEF_EI(CP_WINDOWS_1254)            = 1254,  /**< ANSI Turkish; Turkish (Windows) */
  _LIEF_EI(CP_WINDOWS_1255)            = 1255,  /**< ANSI Hebrew; Hebrew (Windows) */
  _LIEF_EI(CP_WINDOWS_1256)            = 1256,  /**< ANSI Arabic; Arabic (Windows) */
  _LIEF_EI(CP_WINDOWS_1257)            = 1257,  /**< ANSI Baltic; Baltic (Windows) */
  _LIEF_EI(CP_WINDOWS_1258)            = 1258,  /**< ANSI/OEM Vietnamese; Vietnamese (Windows) */
  _LIEF_EI(CP_JOHAB)                   = 1361,  /**< Korean (Johab) */
  _LIEF_EI(CP_MACINTOSH)               = 10000, /**< MAC Roman; Western European (Mac) */
  _LIEF_EI(CP_X_MAC_JAPANESE)          = 10001, /**< Japanese (Mac) */
  _LIEF_EI(CP_X_MAC_CHINESETRAD)       = 10002, /**< MAC Traditional Chinese (Big5); Chinese Traditional (Mac) */
  _LIEF_EI(CP_X_MAC_KOREAN)            = 10003, /**< Korean (Mac) */
  _LIEF_EI(CP_X_MAC_ARABIC)            = 10004, /**< Arabic (Mac) */
  _LIEF_EI(CP_X_MAC_HEBREW)            = 10005, /**< Hebrew (Mac) */
  _LIEF_EI(CP_X_MAC_GREEK)             = 10006, /**< Greek (Mac) */
  _LIEF_EI(CP_X_MAC_CYRILLIC)          = 10007, /**< Cyrillic (Mac) */
  _LIEF_EI(CP_X_MAC_CHINESESIMP)       = 10008, /**< MAC Simplified Chinese (GB 2312); Chinese Simplified (Mac) */
  _LIEF_EI(CP_X_MAC_ROMANIAN)          = 10010, /**< Romanian (Mac) */
  _LIEF_EI(CP_X_MAC_UKRAINIAN)         = 10017, /**< Ukrainian (Mac) */
  _LIEF_EI(CP_X_MAC_THAI)              = 10021, /**< Thai (Mac) */
  _LIEF_EI(CP_X_MAC_CE)                = 10029, /**< MAC Latin 2; Central European (Mac) */
  _LIEF_EI(CP_X_MAC_ICELANDIC)         = 10079, /**< Icelandic (Mac) */
  _LIEF_EI(CP_X_MAC_TURKISH)           = 10081, /**< Turkish (Mac) */
  _LIEF_EI(CP_X_MAC_CROATIAN)          = 10082, /**< Croatian (Mac) */
  _LIEF_EI(CP_UTF_32)                  = 12000, /**< Unicode UTF-32, little endian byte order; available only to managed applications */
  _LIEF_EI(CP_UTF_32BE)                = 12001, /**< Unicode UTF-32, big endian byte order; available only to managed applications */
  _LIEF_EI(CP_X_CHINESE_CNS)           = 20000, /**< CNS Taiwan; Chinese Traditional (CNS) */
  _LIEF_EI(CP_X_CP20001)               = 20001, /**< TCA Taiwan */
  _LIEF_EI(CP_X_CHINESE_ETEN)          = 20002, /**< Eten Taiwan; Chinese Traditional (Eten) */
  _LIEF_EI(CP_X_CP20003)               = 20003, /**< IBM5550 Taiwan */
  _LIEF_EI(CP_X_CP20004)               = 20004, /**< TeleText Taiwan */
  _LIEF_EI(CP_X_CP20005)               = 20005, /**< Wang Taiwan */
  _LIEF_EI(CP_X_IA5)                   = 20105, /**< IA5 (IRV International Alphabet No. 5, 7-bit); Western European (IA5) */
  _LIEF_EI(CP_X_IA5_GERMAN)            = 20106, /**< IA5 German (7-bit) */
  _LIEF_EI(CP_X_IA5_SWEDISH)           = 20107, /**< IA5 Swedish (7-bit) */
  _LIEF_EI(CP_X_IA5_NORWEGIAN)         = 20108, /**< IA5 Norwegian (7-bit) */
  _LIEF_EI(CP_US_ASCII)                = 20127, /**< US-ASCII (7-bit) */
  _LIEF_EI(CP_X_CP20261)               = 20261, /**< T.61 */
  _LIEF_EI(CP_X_CP20269)               = 20269, /**< ISO 6937 Non-Spacing Accent */
  _LIEF_EI(CP_IBM273)                  = 20273, /**< IBM EBCDIC Germany */
  _LIEF_EI(CP_IBM277)                  = 20277, /**< IBM EBCDIC Denmark-Norway */
  _LIEF_EI(CP_IBM278)                  = 20278, /**< IBM EBCDIC Finland-Sweden */
  _LIEF_EI(CP_IBM280)                  = 20280, /**< IBM EBCDIC Italy */
  _LIEF_EI(CP_IBM284)                  = 20284, /**< IBM EBCDIC Latin America-Spain */
  _LIEF_EI(CP_IBM285)                  = 20285, /**< IBM EBCDIC United Kingdom */
  _LIEF_EI(CP_IBM290)                  = 20290, /**< IBM EBCDIC Japanese Katakana Extended */
  _LIEF_EI(CP_IBM297)                  = 20297, /**< IBM EBCDIC France */
  _LIEF_EI(CP_IBM420)                  = 20420, /**< IBM EBCDIC Arabic */
  _LIEF_EI(CP_IBM423)                  = 20423, /**< IBM EBCDIC Greek */
  _LIEF_EI(CP_IBM424)                  = 20424, /**< IBM EBCDIC Hebrew */
  _LIEF_EI(CP_X_EBCDIC_KOREANEXTENDED) = 20833, /**< IBM EBCDIC Korean Extended */
  _LIEF_EI(CP_IBM_THAI)                = 20838, /**< IBM EBCDIC Thai */
  _LIEF_EI(CP_KOI8_R)                  = 20866, /**< Russian (KOI8-R); Cyrillic (KOI8-R) */
  _LIEF_EI(CP_IBM871)                  = 20871, /**< IBM EBCDIC Icelandic */
  _LIEF_EI(CP_IBM880)                  = 20880, /**< IBM EBCDIC Cyrillic Russian */
  _LIEF_EI(CP_IBM905)                  = 20905, /**< IBM EBCDIC Turkish */
  _LIEF_EI(CP_IBM00924)                = 20924, /**< IBM EBCDIC Latin 1/Open System (1047 + Euro symbol) */
  _LIEF_EI(CP_EUC_JP_JIS)              = 20932, /**< Japanese (JIS 0208-1990 and 0121-1990) */
  _LIEF_EI(CP_X_CP20936)               = 20936, /**< Simplified Chinese (GB2312); Chinese Simplified (GB2312-80) */
  _LIEF_EI(CP_X_CP20949)               = 20949, /**< Korean Wansung */
  _LIEF_EI(CP_CP1025)                  = 21025, /**< IBM EBCDIC Cyrillic Serbian-Bulgarian */
  _LIEF_EI(CP_KOI8_U)                  = 21866, /**< Ukrainian (KOI8-U); Cyrillic (KOI8-U) */
  _LIEF_EI(CP_ISO_8859_1)              = 28591, /**< ISO 8859-1 Latin 1; Western European (ISO) */
  _LIEF_EI(CP_ISO_8859_2)              = 28592, /**< ISO 8859-2 Central European; Central European (ISO) */
  _LIEF_EI(CP_ISO_8859_3)              = 28593, /**< ISO 8859-3 Latin 3 */
  _LIEF_EI(CP_ISO_8859_4)              = 28594, /**< ISO 8859-4 Baltic */
  _LIEF_EI(CP_ISO_8859_5)              = 28595, /**< ISO 8859-5 Cyrillic */
  _LIEF_EI(CP_ISO_8859_6)              = 28596, /**< ISO 8859-6 Arabic */
  _LIEF_EI(CP_ISO_8859_7)              = 28597, /**< ISO 8859-7 Greek */
  _LIEF_EI(CP_ISO_8859_8)              = 28598, /**< ISO 8859-8 Hebrew; Hebrew (ISO-Visual) */
  _LIEF_EI(CP_ISO_8859_9)              = 28599, /**< ISO 8859-9 Turkish */
  _LIEF_EI(CP_ISO_8859_13)             = 28603, /**< ISO 8859-13 Estonian */
  _LIEF_EI(CP_ISO_8859_15)             = 28605, /**< ISO 8859-15 Latin 9 */
  _LIEF_EI(CP_X_EUROPA)                = 29001, /**< Europa 3 */
  _LIEF_EI(CP_ISO_8859_8_I)            = 38598, /**< ISO 8859-8 Hebrew; Hebrew (ISO-Logical) */
  _LIEF_EI(CP_ISO_2022_JP)             = 50220, /**< ISO 2022 Japanese with no halfwidth Katakana; Japanese (JIS) */
  _LIEF_EI(CP_CSISO2022JP)             = 50221, /**< ISO 2022 Japanese with halfwidth Katakana; Japanese (JIS-Allow 1 byte Kana) */
  _LIEF_EI(CP_ISO_2022_JP_JIS)         = 50222, /**< ISO 2022 Japanese JIS X 0201-1989; Japanese (JIS-Allow 1 byte Kana - SO/SI) */
  _LIEF_EI(CP_ISO_2022_KR)             = 50225, /**< ISO 2022 Korean */
  _LIEF_EI(CP_X_CP50227)               = 50227, /**< ISO 2022 Simplified Chinese; Chinese Simplified (ISO 2022) */
  _LIEF_EI(CP_EUC_JP)                  = 51932, /**< EUC Japanese */
  _LIEF_EI(CP_EUC_CN)                  = 51936, /**< EUC Simplified Chinese; Chinese Simplified (EUC) */
  _LIEF_EI(CP_EUC_KR)                  = 51949, /**< EUC Korean */
  _LIEF_EI(CP_HZ_GB_2312)              = 52936, /**< HZ-GB2312 Simplified Chinese; Chinese Simplified (HZ) */
  _LIEF_EI(CP_GB18030)                 = 54936, /**< Windows XP and later: GB18030 Simplified Chinese (4 byte); Chinese Simplified (GB18030) */
  _LIEF_EI(CP_X_ISCII_DE)              = 57002, /**< ISCII Devanagari */
  _LIEF_EI(CP_X_ISCII_BE)              = 57003, /**< ISCII Bengali */
  _LIEF_EI(CP_X_ISCII_TA)              = 57004, /**< ISCII Tamil */
  _LIEF_EI(CP_X_ISCII_TE)              = 57005, /**< ISCII Telugu */
  _LIEF_EI(CP_X_ISCII_AS)              = 57006, /**< ISCII Assamese */
  _LIEF_EI(CP_X_ISCII_OR)              = 57007, /**< ISCII Oriya */
  _LIEF_EI(CP_X_ISCII_KA)              = 57008, /**< ISCII Kannada */
  _LIEF_EI(CP_X_ISCII_MA)              = 57009, /**< ISCII Malayalam */
  _LIEF_EI(CP_X_ISCII_GU)              = 57010, /**< ISCII Gujarati */
  _LIEF_EI(CP_X_ISCII_PA)              = 57011, /**< ISCII Punjabi */
  _LIEF_EI(CP_UTF_7)                   = 65000, /**< Unicode (UTF-7) */
  _LIEF_EI(CP_UTF_8)                   = 65001, /**< Unicode (UTF-8) */
};

enum _LIEF_EN(WIN_VERSION) {
  _LIEF_EI(WIN_UNKNOWN)   = 0,
  _LIEF_EI(WIN_SEH)       = 1,
  _LIEF_EI(WIN8_1)        = 2,
  _LIEF_EI(WIN10_0_9879)  = 3,
  _LIEF_EI(WIN10_0_14286) = 4,
  _LIEF_EI(WIN10_0_14383) = 5,
  _LIEF_EI(WIN10_0_14901) = 6,
  _LIEF_EI(WIN10_0_15002) = 7,
  _LIEF_EI(WIN10_0_16237) = 8,
};

enum _LIEF_EN(GUARD_CF_FLAGS) {
  _LIEF_EI(GCF_NONE)                            = 0x00000000,
  _LIEF_EI(GCF_INSTRUMENTED)                    = 0x00000100, /**< Module performs control flow integrity checks using system-supplied support */
  _LIEF_EI(GCF_W_INSTRUMENTED)                  = 0x00000200, /**< Module performs control flow and write integrity checks */
  _LIEF_EI(GCF_FUNCTION_TABLE_PRESENT)          = 0x00000400, /**< Module contains valid control flow target metadata */
  _LIEF_EI(GCF_EXPORT_SUPPRESSION_INFO_PRESENT) = 0x00004000, /**< Module contains suppressed export information. This also infers that the address taken taken IAT table is also present in the load config. */
  _LIEF_EI(GCF_ENABLE_EXPORT_SUPPRESSION)       = 0x00008000, /**< Module enables suppression of exports */
  _LIEF_EI(GCF_LONGJUMP_TABLE_PRESENT)          = 0x00010000, /**< Module contains longjmp target information */

  _LIEF_EI(GRF_INSTRUMENTED)                    = 0x00020000, /**< Module contains return flow instrumentation and metadata */
  _LIEF_EI(GRF_ENABLE)                          = 0x00040000, /**< Module requests that the OS enable return flow protection */
  _LIEF_EI(GRF_STRICT)                          = 0x00080000, /**< Module requests that the OS enable return flow protection in strict mode */
};

/** From https://docs.microsoft.com/en-us/windows/win32/menurc/acceltableentry */
enum _LIEF_EN(ACCELERATOR_FLAGS) {
  _LIEF_EI(FVIRTKEY)  = 0x01,
  _LIEF_EI(FNOINVERT) = 0x02,
  _LIEF_EI(FSHIFT)    = 0x04,
  _LIEF_EI(FCONTROL)  = 0x08,
  _LIEF_EI(FALT)      = 0x10,
  _LIEF_EI(END)       = 0x80,
};

/** From https://docs.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes */
enum _LIEF_EN(ACCELERATOR_VK_CODES) {
  _LIEF_EI(VK_LBUTTON)             = 0x01,
  _LIEF_EI(VK_RBUTTON)             = 0x02,
  _LIEF_EI(VK_CANCEL)              = 0x03,
  _LIEF_EI(VK_MBUTTON)             = 0x04,
  _LIEF_EI(VK_XBUTTON1)            = 0x05,
  _LIEF_EI(VK_XBUTTON2)            = 0x06,
  _LIEF_EI(VK_BACK)                = 0x08,
  _LIEF_EI(VK_TAB)                 = 0x09,
  _LIEF_EI(VK_CLEAR)               = 0x0C,
  _LIEF_EI(VK_RETURN)              = 0x0D,
  _LIEF_EI(VK_SHIFT)               = 0x10,
  _LIEF_EI(VK_CONTROL)             = 0x11,
  _LIEF_EI(VK_MENU)                = 0x12,
  _LIEF_EI(VK_PAUSE)               = 0x13,
  _LIEF_EI(VK_CAPITAL)             = 0x14,
  _LIEF_EI(VK_KANA)                = 0x15,
  _LIEF_EI(VK_HANGUEL)             = 0x15,
  _LIEF_EI(VK_HANGUL)              = 0x15,
  _LIEF_EI(VK_IME_ON)              = 0x16,
  _LIEF_EI(VK_JUNJA)               = 0x17,
  _LIEF_EI(VK_FINAL)               = 0x18,
  _LIEF_EI(VK_HANJA)               = 0x19,
  _LIEF_EI(VK_KANJI)               = 0x19,
  _LIEF_EI(VK_IME_OFF)             = 0x1A,
  _LIEF_EI(VK_ESCAPE)              = 0x1B,
  _LIEF_EI(VK_CONVERT)             = 0x1C,
  _LIEF_EI(VK_NONCONVERT)          = 0x1D,
  _LIEF_EI(VK_ACCEPT)              = 0x1E,
  _LIEF_EI(VK_MODECHANGE)          = 0x1F,
  _LIEF_EI(VK_SPACE)               = 0x20,
  _LIEF_EI(VK_PRIOR)               = 0x21,
  _LIEF_EI(VK_NEXT)                = 0x22,
  _LIEF_EI(VK_END)                 = 0x23,
  _LIEF_EI(VK_HOME)                = 0x24,
  _LIEF_EI(VK_LEFT)                = 0x25,
  _LIEF_EI(VK_UP)                  = 0x26,
  _LIEF_EI(VK_RIGHT)               = 0x27,
  _LIEF_EI(VK_DOWN)                = 0x28,
  _LIEF_EI(VK_SELECT)              = 0x29,
  _LIEF_EI(VK_PRINT)               = 0x2A,
  _LIEF_EI(VK_EXECUTE)             = 0x2B,
  _LIEF_EI(VK_SNAPSHOT)            = 0x2C,
  _LIEF_EI(VK_INSERT)              = 0x2D,
  _LIEF_EI(VK_DELETE)              = 0x2E,
  _LIEF_EI(VK_HELP)                = 0x2F,
  _LIEF_EI(VK_0)                   = 0x30,
  _LIEF_EI(VK_1)                   = 0x31,
  _LIEF_EI(VK_2)                   = 0x32,
  _LIEF_EI(VK_3)                   = 0x33,
  _LIEF_EI(VK_4)                   = 0x34,
  _LIEF_EI(VK_5)                   = 0x35,
  _LIEF_EI(VK_6)                   = 0x36,
  _LIEF_EI(VK_7)                   = 0x37,
  _LIEF_EI(VK_8)                   = 0x38,
  _LIEF_EI(VK_9)                   = 0x39,
  _LIEF_EI(VK_A)                   = 0x41,
  _LIEF_EI(VK_B)                   = 0x42,
  _LIEF_EI(VK_C)                   = 0x43,
  _LIEF_EI(VK_D)                   = 0x44,
  _LIEF_EI(VK_E)                   = 0x45,
  _LIEF_EI(VK_F)                   = 0x46,
  _LIEF_EI(VK_G)                   = 0x47,
  _LIEF_EI(VK_H)                   = 0x48,
  _LIEF_EI(VK_I)                   = 0x49,
  _LIEF_EI(VK_J)                   = 0x4A,
  _LIEF_EI(VK_K)                   = 0x4B,
  _LIEF_EI(VK_L)                   = 0x4C,
  _LIEF_EI(VK_M)                   = 0x4D,
  _LIEF_EI(VK_N)                   = 0x4E,
  _LIEF_EI(VK_O)                   = 0x4F,
  _LIEF_EI(VK_P)                   = 0x50,
  _LIEF_EI(VK_Q)                   = 0x51,
  _LIEF_EI(VK_R)                   = 0x52,
  _LIEF_EI(VK_S)                   = 0x53,
  _LIEF_EI(VK_T)                   = 0x54,
  _LIEF_EI(VK_U)                   = 0x55,
  _LIEF_EI(VK_V)                   = 0x56,
  _LIEF_EI(VK_W)                   = 0x57,
  _LIEF_EI(VK_X)                   = 0x58,
  _LIEF_EI(VK_Y)                   = 0x59,
  _LIEF_EI(VK_Z)                   = 0x60,
  _LIEF_EI(VK_LWIN)                = 0x5B,
  _LIEF_EI(VK_RWIN)                = 0x5C,
  _LIEF_EI(VK_APPS)                = 0x5D,
  _LIEF_EI(VK_SLEEP)               = 0x5F,
  _LIEF_EI(VK_NUMPAD0)             = 0x60,
  _LIEF_EI(VK_NUMPAD1)             = 0x61,
  _LIEF_EI(VK_NUMPAD2)             = 0x62,
  _LIEF_EI(VK_NUMPAD3)             = 0x63,
  _LIEF_EI(VK_NUMPAD4)             = 0x64,
  _LIEF_EI(VK_NUMPAD5)             = 0x65,
  _LIEF_EI(VK_NUMPAD6)             = 0x66,
  _LIEF_EI(VK_NUMPAD7)             = 0x67,
  _LIEF_EI(VK_NUMPAD8)             = 0x68,
  _LIEF_EI(VK_NUMPAD9)             = 0x69,
  _LIEF_EI(VK_MULTIPLY)            = 0x6A,
  _LIEF_EI(VK_ADD)                 = 0x6B,
  _LIEF_EI(VK_SEPARATOR)           = 0x6C,
  _LIEF_EI(VK_SUBTRACT)            = 0x6D,
  _LIEF_EI(VK_DECIMAL)             = 0x6E,
  _LIEF_EI(VK_DIVIDE)              = 0x6F,
  _LIEF_EI(VK_F1)                  = 0x70,
  _LIEF_EI(VK_F2)                  = 0x71,
  _LIEF_EI(VK_F3)                  = 0x72,
  _LIEF_EI(VK_F4)                  = 0x73,
  _LIEF_EI(VK_F5)                  = 0x74,
  _LIEF_EI(VK_F6)                  = 0x75,
  _LIEF_EI(VK_F7)                  = 0x76,
  _LIEF_EI(VK_F8)                  = 0x77,
  _LIEF_EI(VK_F9)                  = 0x78,
  _LIEF_EI(VK_F10)                 = 0x79,
  _LIEF_EI(VK_F11)                 = 0x7A,
  _LIEF_EI(VK_F12)                 = 0x7B,
  _LIEF_EI(VK_F13)                 = 0x7C,
  _LIEF_EI(VK_F14)                 = 0x7D,
  _LIEF_EI(VK_F15)                 = 0x7E,
  _LIEF_EI(VK_F16)                 = 0x7F,
  _LIEF_EI(VK_F17)                 = 0x80,
  _LIEF_EI(VK_F18)                 = 0x81,
  _LIEF_EI(VK_F19)                 = 0x82,
  _LIEF_EI(VK_F20)                 = 0x83,
  _LIEF_EI(VK_F21)                 = 0x84,
  _LIEF_EI(VK_F22)                 = 0x85,
  _LIEF_EI(VK_F23)                 = 0x86,
  _LIEF_EI(VK_F24)                 = 0x87,
  _LIEF_EI(VK_NUMLOCK)             = 0x90,
  _LIEF_EI(VK_SCROLL)              = 0x91,
  _LIEF_EI(VK_LSHIFT)              = 0xA0,
  _LIEF_EI(VK_RSHIFT)              = 0xA1,
  _LIEF_EI(VK_LCONTROL)            = 0xA2,
  _LIEF_EI(VK_RCONTROL)            = 0xA3,
  _LIEF_EI(VK_LMENU)               = 0xA4,
  _LIEF_EI(VK_RMENU)               = 0xA5,
  _LIEF_EI(VK_BROWSER_BACK)        = 0xA6,
  _LIEF_EI(VK_BROWSER_FORWARD)     = 0xA7,
  _LIEF_EI(VK_BROWSER_REFRESH)     = 0xA8,
  _LIEF_EI(VK_BROWSER_STOP)        = 0xA9,
  _LIEF_EI(VK_BROWSER_SEARCH)      = 0xAA,
  _LIEF_EI(VK_BROWSER_FAVORITES)   = 0xAB,
  _LIEF_EI(VK_BROWSER_HOME)        = 0xAC,
  _LIEF_EI(VK_VOLUME_MUTE)         = 0xAD,
  _LIEF_EI(VK_VOLUME_DOWN)         = 0xAE,
  _LIEF_EI(VK_VOLUME_UP)           = 0xAF,
  _LIEF_EI(VK_MEDIA_NEXT_TRACK)    = 0xB0,
  _LIEF_EI(VK_MEDIA_PREV_TRACK)    = 0xB1,
  _LIEF_EI(VK_MEDIA_STOP)          = 0xB2,
  _LIEF_EI(VK_MEDIA_PLAY_PAUSE)    = 0xB3,
  _LIEF_EI(VK_LAUNCH_MAIL)         = 0xB4,
  _LIEF_EI(VK_LAUNCH_MEDIA_SELECT) = 0xB5,
  _LIEF_EI(VK_LAUNCH_APP1)         = 0xB6,
  _LIEF_EI(VK_LAUNCH_APP2)         = 0xB7,
  _LIEF_EI(VK_OEM_1)               = 0xBA,
  _LIEF_EI(VK_OEM_PLUS)            = 0xBB,
  _LIEF_EI(VK_OEM_COMMA)           = 0xBC,
  _LIEF_EI(VK_OEM_MINUS)           = 0xBD,
  _LIEF_EI(VK_OEM_PERIOD)          = 0xBE,
  _LIEF_EI(VK_OEM_2)               = 0xBF,
  _LIEF_EI(VK_OEM_4)               = 0xDB,
  _LIEF_EI(VK_OEM_5)               = 0xDC,
  _LIEF_EI(VK_OEM_6)               = 0xDD,
  _LIEF_EI(VK_OEM_7)               = 0xDE,
  _LIEF_EI(VK_OEM_8)               = 0xDF,
  _LIEF_EI(VK_OEM_102)             = 0xE2,
  _LIEF_EI(VK_PROCESSKEY)          = 0xE5,
  _LIEF_EI(VK_PACKET)              = 0xE7,
  _LIEF_EI(VK_ATTN)                = 0xF6,
  _LIEF_EI(VK_CRSEL)               = 0xF7,
  _LIEF_EI(VK_EXSEL)               = 0xF8,
  _LIEF_EI(VK_EREOF)               = 0xF9,
  _LIEF_EI(VK_PLAY)                = 0xFA,
  _LIEF_EI(VK_ZOOM)                = 0xFB,
  _LIEF_EI(VK_NONAME)              = 0xFC,
  _LIEF_EI(VK_PA1)                 = 0xFD,
  _LIEF_EI(VK_OEM_CLEAR)           = 0xFE,
};


```

`KDemu/include/LIEF/LIEF/PE/hash.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 * Copyright 2017 - 2021 K. Nakagawa
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_HASH_H
#define LIEF_PE_HASH_H

#include "LIEF/visibility.h"
#include "LIEF/hash.hpp"

namespace LIEF {
namespace PE {

class Binary;
class DosHeader;
class RichHeader;
class RichEntry;
class Header;
class OptionalHeader;
class DataDirectory;
class Section;
class Relocation;
class RelocationEntry;
class Export;
class ExportEntry;
class TLS;
class Symbol;
class Debug;
class CodeView;
class CodeViewPDB;
class Import;
class ImportEntry;
class DelayImport;
class DelayImportEntry;
class ResourceNode;
class ResourceData;
class ResourceDirectory;
class ResourcesManager;
class ResourceVersion;
class ResourceStringFileInfo;
class ResourceFixedFileInfo;
class ResourceVarFileInfo;
class LangCodeItem;
class ResourceIcon;
class ResourceDialog;
class ResourceDialogItem;
class ResourceStringTable;
class ResourceAccelerator;
class Signature;
class x509;
class SignerInfo;
class ContentInfo;
class Attribute;
class ContentType;
class GenericType;
class MsCounterSign;
class MsSpcNestedSignature;
class MsSpcStatementType;
class PKCS9AtSequenceNumber;
class PKCS9CounterSignature;
class PKCS9MessageDigest;
class PKCS9SigningTime;
class SpcSpOpusInfo;
class SpcRelaxedPeMarkerCheck;
class SigningCertificateV2;
class CodeIntegrity;
class LoadConfiguration;
class LoadConfigurationV0;
class LoadConfigurationV1;
class LoadConfigurationV2;
class LoadConfigurationV3;
class LoadConfigurationV4;
class LoadConfigurationV5;
class LoadConfigurationV6;
class LoadConfigurationV7;
class LoadConfigurationV8;
class LoadConfigurationV9;
class LoadConfigurationV10;
class LoadConfigurationV11;
class Pogo;
class PogoEntry;
class Repro;

//! Class which implements a visitor to compute
//! a **deterministic** hash for LIEF PE objects
class LIEF_API Hash : public LIEF::Hash {
  public:
  static LIEF::Hash::value_type hash(const Object& obj);

  public:
  using LIEF::Hash::Hash;
  using LIEF::Hash::hash;
  using LIEF::Hash::visit;
  using LIEF::Hash::process;

  public:
  void visit(const Binary& Binary)                        override;
  void visit(const DosHeader& dos_header)                 override;
  void visit(const RichHeader& rich_header)               override;
  void visit(const RichEntry& rich_entry)                 override;
  void visit(const Header& header)                        override;
  void visit(const OptionalHeader& optional_header)       override;
  void visit(const DataDirectory& data_directory)         override;
  void visit(const Section& section)                      override;
  void visit(const Relocation& relocation)                override;
  void visit(const RelocationEntry& relocation_entry)     override;
  void visit(const Export& export_)                       override;
  void visit(const ExportEntry& export_entry)             override;
  void visit(const TLS& tls)                              override;
  void visit(const Symbol& Symbol)                        override;
  void visit(const Debug& debug)                          override;
  void visit(const CodeView& cv)                          override;
  void visit(const CodeViewPDB& cvpdb)                    override;
  void visit(const Import& import)                        override;
  void visit(const ImportEntry& import_entry)             override;
  void visit(const DelayImport& import)                   override;
  void visit(const DelayImportEntry& import_entry)        override;
  void visit(const ResourceNode& resource_node)           override;
  void visit(const ResourceData& resource_data)           override;
  void visit(const ResourceDirectory& resource_directory) override;
  void visit(const ResourcesManager& resources_manager)   override;
  void visit(const ResourceVersion& resource_version)     override;
  void visit(const ResourceStringFileInfo& resource_sfi)  override;
  void visit(const ResourceFixedFileInfo& resource_ffi)   override;
  void visit(const ResourceVarFileInfo& resource_vfi)     override;
  void visit(const LangCodeItem& resource_lci)            override;
  void visit(const ResourceIcon& resource_icon)           override;
  void visit(const ResourceDialog& dialog)                override;
  void visit(const ResourceDialogItem& dialog_item)       override;
  void visit(const ResourceStringTable& string_table)     override;
  void visit(const ResourceAccelerator& acc)              override;
  void visit(const Signature& signature)                  override;
  void visit(const x509& x509)                            override;
  void visit(const SignerInfo& signerinfo)                override;
  void visit(const ContentInfo& contentinfo)              override;
  void visit(const GenericContent& content)               override;
  void visit(const SpcIndirectData& content)              override;
  void visit(const Attribute& attr)                       override;
  void visit(const ContentType& attr)                     override;
  void visit(const GenericType& attr)                     override;
  void visit(const MsCounterSign& attr)                   override;
  void visit(const MsSpcNestedSignature& attr)            override;
  void visit(const MsSpcStatementType& attr)              override;
  void visit(const MsManifestBinaryID& attr)              override;
  void visit(const PKCS9AtSequenceNumber& attr)           override;
  void visit(const PKCS9CounterSignature& attr)           override;
  void visit(const PKCS9MessageDigest& attr)              override;
  void visit(const PKCS9SigningTime& attr)                override;
  void visit(const SpcSpOpusInfo& attr)                   override;
  void visit(const SpcRelaxedPeMarkerCheck& attr)         override;
  void visit(const SigningCertificateV2& attr)            override;
  void visit(const CodeIntegrity& code_integrity)         override;
  void visit(const LoadConfiguration& config)             override;
  void visit(const LoadConfigurationV0& config)           override;
  void visit(const LoadConfigurationV1& config)           override;
  void visit(const LoadConfigurationV2& config)           override;
  void visit(const LoadConfigurationV3& config)           override;
  void visit(const LoadConfigurationV4& config)           override;
  void visit(const LoadConfigurationV5& config)           override;
  void visit(const LoadConfigurationV6& config)           override;
  void visit(const LoadConfigurationV7& config)           override;
  void visit(const LoadConfigurationV8& config)           override;
  void visit(const LoadConfigurationV9& config)           override;
  void visit(const LoadConfigurationV10& config)          override;
  void visit(const LoadConfigurationV11& config)          override;

  void visit(const Pogo& pogo)        override;
  void visit(const PogoEntry& entry)  override;
  void visit(const Repro& entry)      override;

  ~Hash() override;
};

}
}

#endif

```

`KDemu/include/LIEF/LIEF/PE/json.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 * Copyright 2017 - 2021 K. Nakagawa
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_JSON_H
#define LIEF_PE_JSON_H

#include "LIEF/visibility.h"
#include <string>

namespace LIEF {
class Object;
namespace PE {

LIEF_API std::string to_json(const Object& v);

}
}

#endif

```

`KDemu/include/LIEF/LIEF/PE/resources/LangCodeItem.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_RESOURCE_LANG_CODE_ITEM_H
#define LIEF_PE_RESOURCE_LANG_CODE_ITEM_H
#include <ostream>
#include <unordered_map>

#include "LIEF/visibility.h"

#include "LIEF/Object.hpp"

#include "LIEF/PE/enums.hpp"

namespace LIEF {
namespace PE {

class ResourcesManager;
struct ResourcesParser;

//! Class which represents the childs of the ResourceStringFileInfo
//!
//! @see: LIEF::PE::ResourceStringFileInfo
//! @see: https://docs.microsoft.com/en-us/windows/win32/menurc/stringtable
class LIEF_API LangCodeItem : public Object {

  friend class ResourcesManager;
  friend struct ResourcesParser;

  public:
  using items_t = std::unordered_map<std::u16string, std::u16string>;
  LangCodeItem();
  LangCodeItem(uint16_t type, std::u16string key) :
    type_(type),
    key_(std::move(key))
  {}

  LangCodeItem(const LangCodeItem&) = default;
  LangCodeItem& operator=(const LangCodeItem&) = default;
  ~LangCodeItem() override = default;

  //! The type of data in the version resource
  //! * ``1`` if it contains text data
  //! * ``0`` if it contains binary data
  uint16_t type() const {
    return type_;
  }

  //! A 8-digit hexadecimal number stored as an Unicode string.
  //! * The four most significant digits represent the language identifier.
  //! * The four least significant digits represent the code page for which the data is formatted.
  //!
  //! @see LangCodeItem::code_page, LangCodeItem::lang, LangCodeItem::sublang
  const std::u16string& key() const {
    return key_;
  }

  //! [Code page](https://docs.microsoft.com/en-us/windows/win32/intl/code-page-identifiers)
  //! for which LangCodeItem::items are defined
  CODE_PAGES code_page() const;

  //! Lang for which LangCodeItem::items are defined
  uint32_t lang() const;

  //! Sublang for which LangCodeItem::items are defined
  uint32_t sublang() const;

  const items_t& items() const {
    return items_;
  }

  items_t& items() {
    return items_;
  }

  void type(uint16_t type) {
    type_ = type;
  }

  void key(const std::u16string& key) {
    key_ = key;
  }
  void key(const std::string& key);

  void code_page(CODE_PAGES code_page);
  void lang(uint32_t lang);
  void sublang(uint32_t lang);

  void items(const items_t& items);

  void accept(Visitor& visitor) const override;


  LIEF_API friend std::ostream& operator<<(std::ostream& os, const LangCodeItem& item);

  private:
  uint16_t       type_ = 0;
  std::u16string key_;
  items_t        items_;
};




}
}


#endif

```

`KDemu/include/LIEF/LIEF/PE/resources/ResourceAccelerator.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 * Copyright 2017 - 2021 K. Nakagawa
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_RESOURCE_ACCELERATOR_H
#define LIEF_PE_RESOURCE_ACCELERATOR_H

#include <string>
#include <set>
#include <ostream>

#include "LIEF/visibility.h"

#include "LIEF/Object.hpp"

#include "LIEF/PE/enums.hpp"

namespace LIEF {
namespace PE {
class ResourcesManager;

namespace details {
struct pe_resource_acceltableentry;
}

class LIEF_API ResourceAccelerator : public Object {

  friend class ResourcesManager;

  public:
  ResourceAccelerator() = default;
  explicit ResourceAccelerator(const details::pe_resource_acceltableentry&);

  ResourceAccelerator(const ResourceAccelerator&) = default;
  ResourceAccelerator& operator=(const ResourceAccelerator&) = default;

  ~ResourceAccelerator() override = default;

  std::set<ACCELERATOR_FLAGS> flags_list() const;
  std::string ansi_str() const;

  //! Describe the keyboard accelerator characteristics
  int16_t flags() const {
    return flags_;
  }

  //! An ANSI character value or a virtual-key code that identifies the accelerator key
  int16_t ansi() const {
    return ansi_;
  }

  //! An identifier for the keyboard accelerator
  uint16_t id() const {
    return id_;
  }

  //! The number of bytes inserted to ensure that the structure is aligned on a DWORD boundary.
  int16_t padding() const {
    return padding_;
  }

  void accept(Visitor& visitor) const override;


  LIEF_API friend std::ostream& operator<<(std::ostream& os, const ResourceAccelerator& acc);

  private:
  int16_t flags_ = 0;
  int16_t ansi_ = 0;
  uint16_t id_ = 0;
  int16_t padding_ = 0;

};

}
}

#endif

```

`KDemu/include/LIEF/LIEF/PE/resources/ResourceDialog.hpp`:

```hpp

/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_RESOURCE_DIALOG_H
#define LIEF_PE_RESOURCE_DIALOG_H
#include <ostream>
#include <sstream>
#include <set>

#include "LIEF/visibility.h"
#include "LIEF/Object.hpp"
#include "LIEF/iterators.hpp"

#include "LIEF/PE/enums.hpp"
#include "LIEF/PE/resources/ResourceDialogItem.hpp"

namespace LIEF {
namespace PE {
class ResourcesManager;
struct ResourcesParser;

namespace details {
struct pe_dialog_template_ext;
struct pe_dialog_template;
}

//! Representation of a dialog box
//!
//! Windows allows two kinds of dialog box:
//! * Simple one
//! * Extended one
//!
//! ResourceDialog::is_extended determine the type of the Dialog
class LIEF_API ResourceDialog : public Object {

  friend class ResourcesManager;
  friend struct ResourcesParser;

  public:
  using items_t        = std::vector<ResourceDialogItem>;
  using it_items       = ref_iterator<items_t&>;
  using it_const_items = const_ref_iterator<const items_t&>;

  ResourceDialog();
  ResourceDialog(const details::pe_dialog_template_ext& header);
  ResourceDialog(const details::pe_dialog_template& header);

  ResourceDialog(const ResourceDialog&);
  ResourceDialog& operator=(const ResourceDialog&);

  ~ResourceDialog() override;

  //! ``true`` if the dialog is an extended one
  bool is_extended() const;

  //! The extended windows styles
  uint32_t extended_style() const;

  //! Return list of LIEF::PE::EXTENDED_WINDOW_STYLES associated with the
  //! ResourceDialog::extended_style value
  std::set<EXTENDED_WINDOW_STYLES> extended_style_list() const;

  bool has_extended_style(EXTENDED_WINDOW_STYLES style) const;

  //! The style of the dialog box. This member can be a combination of LIEF::PE::WINDOW_STYLES values and
  //! LIEF::PE::DIALOG_BOX_STYLES values.
  uint32_t style() const;

  //! Return list of LIEF::PE::WINDOW_STYLES associated with the
  //! ResourceDialog::style value
  std::set<WINDOW_STYLES> style_list() const;
  bool has_style(WINDOW_STYLES style) const;

  //! Return list of LIEF::PE::DIALOG_BOX_STYLES associated with the
  //! ResourceDialog::style value
  std::set<DIALOG_BOX_STYLES> dialogbox_style_list() const;
  bool has_dialogbox_style(DIALOG_BOX_STYLES style) const;

  //! The x-coordinate, in dialog box units, of the upper-left corner of the dialog box.
  int16_t x() const;

  //! The y-coordinate, in dialog box units, of the upper-left corner of the dialog box.
  int16_t y() const;

  //! The width, in dialog box units, of the dialog box.
  int16_t cx() const;

  //! The height, in dialog box units, of the dialog box.
  int16_t cy() const;

  //! Iterator on the controls (ResourceDialogItem) that defines the Dialog (Button, Label...)
  it_const_items items() const;

  //! RESOURCE_LANGS associated with the Dialog
  uint32_t lang() const;

  //! RESOURCE_SUBLANGS associated with the Dialog
  uint32_t sub_lang() const;

  void lang(uint32_t lang);
  void sub_lang(uint32_t sub_lang);


  // Extended API
  // ============

  //! The version number of the extended dialog box template. This member must be set to 1.
  uint16_t version() const;

  //! Indicates whether a template is an extended dialog box template:
  //!
  //! * ``0xFFFF``: Extended dialog box template
  //! * Other value: Standard dialog box template
  //!
  //! @see ResourceDialog::is_extended
  uint16_t signature() const;

  //! The help context identifier for the dialog box window
  uint32_t help_id() const;

  //! The weight of the font
  uint16_t weight() const;

  //! The point size of the font to use for the text in the dialog box and its controls.
  uint16_t point_size() const;

  //! Indicates whether the font is italic. If this value is ``true``, the font is italic
  bool is_italic() const;

  //! The character to be used
  uint8_t charset() const;

  //! The title of the dialog box
  const std::u16string& title() const;

  //! The name of the typeface for the font
  const std::u16string& typeface() const;

  void accept(Visitor& visitor) const override;


  LIEF_API friend std::ostream& operator<<(std::ostream& os, const ResourceDialog& dialog);

  private:
  uint16_t version_;
  uint16_t signature_;
  uint32_t help_id_;
  uint32_t ext_style_;
  uint32_t style_;

  int16_t x_;
  int16_t y_;
  int16_t cx_;
  int16_t cy_;

  std::u16string menu_;
  std::u16string window_class_;
  std::u16string title_;

  uint16_t       point_size_;
  uint16_t       weight_;
  bool           italic_;
  uint8_t        charset_;
  std::u16string typeface_;

  items_t items_;

  uint32_t lang_;
  uint32_t sublang_;
};


}
}


#endif

```

`KDemu/include/LIEF/LIEF/PE/resources/ResourceDialogItem.hpp`:

```hpp

/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_RESOURCE_DIALOG_ITEM_H
#define LIEF_PE_RESOURCE_DIALOG_ITEM_H
#include <ostream>
#include <sstream>
#include <set>

#include "LIEF/visibility.h"

#include "LIEF/Object.hpp"

#include "LIEF/PE/enums.hpp"

namespace LIEF {
namespace PE {
class ResourcesManager;
struct ResourcesParser;

namespace details {
struct pe_dialog_item_template_ext;
struct pe_dialog_item_template;
}

//! This class represents an item in the ResourceDialog
class LIEF_API ResourceDialogItem : public Object {

  friend class ResourcesManager;
  friend struct ResourcesParser;

  public:
  ResourceDialogItem();
  ResourceDialogItem(const details::pe_dialog_item_template_ext& header);
  ResourceDialogItem(const details::pe_dialog_item_template& header);

  ResourceDialogItem(const ResourceDialogItem&);
  ResourceDialogItem& operator=(const ResourceDialogItem&);

  ~ResourceDialogItem() override;

  //! ``True`` if the control is an extended one
  bool is_extended() const;

  //! The extended styles for a window
  uint32_t extended_style() const;

  //! List of PE::EXTENDED_WINDOW_STYLES associated with
  //! the ResourceDialogItem::extended_style value
  std::set<EXTENDED_WINDOW_STYLES> extended_style_list() const;

  //! Check if the DialogItem has the given PE::EXTENDED_WINDOW_STYLES
  bool has_extended_style(EXTENDED_WINDOW_STYLES style) const;

  //! The style of the control
  uint32_t style() const;

  std::set<WINDOW_STYLES> style_list() const;
  bool has_style(WINDOW_STYLES style) const;

  //! The x-coordinate, in dialog box units, of the upper-left corner of the control.
  //! This coordinate is always relative to the upper-left corner of the dialog box's client area.
  int16_t x() const;

  //! The y-coordinate, in dialog box units, of the upper-left corner of the control.
  //! This coordinate is always relative to the upper-left corner of the dialog box's client area.
  int16_t y() const;

  //! The width, in dialog box units, of the control.
  int16_t cx() const;

  //! The height, in dialog box units, of the control.
  int16_t cy() const;

  //! The control identifier.
  uint32_t id() const;


  // Extended API
  // ============

  //! The help context identifier for the control
  uint32_t help_id() const;

  //! Initial text of the control
  const std::u16string& title() const;

  void accept(Visitor& visitor) const override;


  LIEF_API friend std::ostream& operator<<(std::ostream& os, const ResourceDialogItem& dialog_item);

  private:
  bool     is_extended_ = true;
  uint32_t help_id_ = 0;
  uint32_t ext_style_ = 0;
  uint32_t style_ = 0;
  uint32_t id_ = 0;

  int16_t x_ = 0;
  int16_t y_ = 0;
  int16_t cx_ = 0;
  int16_t cy_ = 0;

  std::u16string window_class_;
  std::u16string title_;

  uint16_t extra_count_ = 0;
};


}
}


#endif

```

`KDemu/include/LIEF/LIEF/PE/resources/ResourceFixedFileInfo.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_RESOURCE_FIXED_FILE_INFO_H
#define LIEF_PE_RESOURCE_FIXED_FILE_INFO_H
#include <ostream>
#include <sstream>

#include "LIEF/visibility.h"

#include "LIEF/Object.hpp"

#include "LIEF/PE/enums.hpp"

namespace LIEF {
namespace PE {

namespace details {
struct pe_resource_fixed_file_info;
}

//! Representation of [VS_FIXEDFILEINFO](https://docs.microsoft.com/en-us/windows/win32/api/verrsrc/ns-verrsrc-vs_fixedfileinfo)
//! Structure
class LIEF_API ResourceFixedFileInfo : public Object {

  public:
  ResourceFixedFileInfo();
  ResourceFixedFileInfo(const details::pe_resource_fixed_file_info& header);

  ResourceFixedFileInfo(const ResourceFixedFileInfo&);
  ResourceFixedFileInfo& operator=(const ResourceFixedFileInfo&);
  ~ResourceFixedFileInfo() override;

  //! Must be set to ``0xFEEF04BD``
  uint32_t signature() const;

  //! The binary version number of this structure.
  //!
  //! The high-order word of this member contains the major version number,
  //! and the low-order word contains the minor version number.
  uint32_t struct_version() const;

  //! The **most** significant 32 bits of the file's binary version number.
  //!
  //! This member is used with ResourceFixedFileInfo::file_version_LS to form a 64-bits
  //! value used for numeric comparisons.
  uint32_t file_version_MS() const;

  //! The **least** significant 32 bits of the file's binary version number.
  //!
  //! This member is used with ResourceFixedFileInfo::file_version_MS to form a 64-bits value used for numeric comparisons.
  uint32_t file_version_LS() const;

  //! The **most** significant 32 bits of the product with which this file was distributed
  //!
  //! This member is used with ResourceFixedFileInfo::product_version_LS to form a 64-bits value used for numeric comparisons.
  uint32_t product_version_MS() const;

  //! The **least** significant 32 bits of the product with which this file was distributed
  //!
  //! This member is used with ResourceFixedFileInfo::product_version_MS to form a 64-bits value used for numeric comparisons.
  uint32_t product_version_LS() const;

  //! Contains a bitmask that specifies the valid bits in ResourceFixedFileInfo::file_flags.
  //!
  //! A bit is valid only if it was defined when the file was created.
  uint32_t file_flags_mask() const;

  //! Contains a bitmask that specifies the Boolean attributes of the file
  //! (PE::FIXED_VERSION_FILE_FLAGS)
  uint32_t file_flags() const;

  //! The operating system for which this file was designed (PE::FIXED_VERSION_OS).
  FIXED_VERSION_OS file_os() const;

  //! The general type of file (PE::FIXED_VERSION_FILE_TYPES)
  FIXED_VERSION_FILE_TYPES file_type() const;

  //! The function of the file (PE::FIXED_VERSION_FILE_SUB_TYPES)
  FIXED_VERSION_FILE_SUB_TYPES file_subtype() const;

  //! The **most** significant 32 bits of the file's 64-bit binary creation date and time stamp.
  uint32_t file_date_MS() const;

  //! The **least** significant 32 bits of the file's 64-bit binary creation date and time stamp.
  uint32_t file_date_LS() const;

  void signature(uint32_t signature);
  void struct_version(uint32_t struct_version);
  void file_version_MS(uint32_t file_version_MS);
  void file_version_LS(uint32_t file_version_LS);
  void product_version_MS(uint32_t product_version_MS);
  void product_version_LS(uint32_t product_version_LS);
  void file_flags_mask(uint32_t file_flags_mask);
  void file_flags(uint32_t file_flags);
  void file_os(FIXED_VERSION_OS file_os);
  void file_type(FIXED_VERSION_FILE_TYPES file_type);
  void file_subtype(FIXED_VERSION_FILE_SUB_TYPES file_subtype);
  void file_date_MS(uint32_t file_date_MS);
  void file_date_LS(uint32_t file_date_LS);

  void accept(Visitor& visitor) const override;


  LIEF_API friend std::ostream& operator<<(std::ostream& os, const ResourceFixedFileInfo& fixed_info);

  private:
  uint32_t                     signature_;
  uint32_t                     struct_version_;
  uint32_t                     file_version_MS_;
  uint32_t                     file_version_LS_;
  uint32_t                     product_version_MS_;
  uint32_t                     product_version_LS_;
  uint32_t                     file_flags_mask_;
  uint32_t                     file_flags_;
  FIXED_VERSION_OS             file_os_;
  FIXED_VERSION_FILE_TYPES     file_type_;
  FIXED_VERSION_FILE_SUB_TYPES file_subtype_;
  uint32_t                     file_date_MS_;
  uint32_t                     file_date_LS_;


};




}
}


#endif

```

`KDemu/include/LIEF/LIEF/PE/resources/ResourceIcon.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_RESOURCE_ICON_H
#define LIEF_PE_RESOURCE_ICON_H
#include <ostream>
#include <sstream>
#include <climits>
#include <vector>

#include "LIEF/visibility.h"

#include "LIEF/span.hpp"
#include "LIEF/Object.hpp"

#include "LIEF/PE/enums.hpp"

namespace LIEF {
namespace PE {
class ResourcesManager;

namespace details {
struct pe_resource_icon_group;
struct pe_icon_header;
}

class LIEF_API ResourceIcon : public Object {

  friend class ResourcesManager;

  public:
  ResourceIcon();
  ResourceIcon(const details::pe_resource_icon_group& header);
  ResourceIcon(const details::pe_icon_header& header);

  ResourceIcon(const ResourceIcon&);
  ResourceIcon& operator=(const ResourceIcon&);

  ~ResourceIcon() override;

  //! Id associated with the icon
  uint32_t id() const;

  //! Language associated with the icon
  uint32_t lang() const;

  //! Sub language associated with the icon
  uint32_t sublang() const;

  //! Width in pixels of the image
  uint8_t width() const;

  //! Height in pixels of the image
  uint8_t height() const;

  //! Number of colors in image (0 if >=8bpp)
  uint8_t color_count() const;

  //! Reserved (must be 0)
  uint8_t reserved() const;

  //! Color Planes
  uint16_t planes() const;

  //! Bits per pixel
  uint16_t bit_count() const;

  //! Size in bytes of the image
  uint32_t size() const;

  //! Pixels of the image (as bytes)
  span<const uint8_t> pixels() const;

  void id(uint32_t id);
  void lang(uint32_t lang);
  void sublang(uint32_t sublang);
  void width(uint8_t width);
  void height(uint8_t height);
  void color_count(uint8_t color_count);
  void reserved(uint8_t reserved);
  void planes(uint16_t planes);
  void bit_count(uint16_t bit_count);
  void pixels(const std::vector<uint8_t>& pixels);

  //! Save the icon to the given filename
  //!
  //! @param[in] filename Path to file in which the icon will be saved
  void save(const std::string& filename) const;

  void accept(Visitor& visitor) const override;


  LIEF_API friend std::ostream& operator<<(std::ostream& os, const ResourceIcon& entry);

  private:
  uint8_t              width_ = 0;
  uint8_t              height_ = 0;
  uint8_t              color_count_ = 0;
  uint8_t              reserved_ = 0;
  uint16_t             planes_ = 0;
  uint16_t             bit_count_ = 0;
  uint32_t             id_ = UINT_MAX;
  uint32_t             lang_ = /* LANG_NEUTRAL */0;
  uint32_t             sublang_ = 0 /* SUBLANG_NEUTRAL */;
  std::vector<uint8_t> pixels_;
};

}
}


#endif

```

`KDemu/include/LIEF/LIEF/PE/resources/ResourceStringFileInfo.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_RESOURCE_STRING_FILE_INFO_H
#define LIEF_PE_RESOURCE_STRING_FILE_INFO_H
#include <ostream>
#include <vector>

#include "LIEF/visibility.h"

#include "LIEF/Object.hpp"
#include "LIEF/PE/resources/LangCodeItem.hpp"

namespace LIEF {
namespace PE {

class ResourcesManager;
class ResourceVersion;
struct ResourcesParser;

//! Representation of the ``StringFileInfo`` structure
//!
//! It contains version information that can be displayed for a particular language and code page.
//!
//! See: https://docs.microsoft.com/en-us/windows/win32/menurc/stringfileinfo
class LIEF_API ResourceStringFileInfo : public Object {

  friend class ResourcesManager;
  friend class ResourceVersion;
  friend struct ResourcesParser;

  public:
  ResourceStringFileInfo();
  ResourceStringFileInfo(uint16_t type, std::u16string key) :
    type_(type),
    key_(std::move(key))
  {}
  ResourceStringFileInfo(const ResourceStringFileInfo&) = default;
  ResourceStringFileInfo& operator=(const ResourceStringFileInfo&) = default;
  ~ResourceStringFileInfo() override = default;

  //! The type of data in the version resource
  //! * ``1`` if it contains text data
  //! * ``0`` if it contains binary data
  uint16_t type() const {
    return type_;
  }

  //! Signature of the structure:
  //! Must be the unicode string "StringFileInfo"
  const std::u16string& key() const {
    return key_;
  }

  //! List of the LangCodeItem items.
  //!
  //! Each LangCodeItem::key indicates the appropriate
  //! language and code page for displaying the ``key: value`` of
  //! LangCodeItem::items
  const std::vector<LangCodeItem>& langcode_items() const {
    return childs_;
  }
  std::vector<LangCodeItem>& langcode_items() {
    return childs_;
  }

  void type(uint16_t type) {
    type_ = type;
  }

  void key(std::u16string key) {
    key_ = std::move(key);
  }
  void key(const std::string& key);

  void langcode_items(std::vector<LangCodeItem> items) {
    childs_ = std::move(items);
  }

  void accept(Visitor& visitor) const override;


  LIEF_API friend std::ostream& operator<<(std::ostream& os, const ResourceStringFileInfo& string_file_info);

  private:
  uint16_t       type_ = 0;
  std::u16string key_;
  std::vector<LangCodeItem> childs_;


};




}
}


#endif

```

`KDemu/include/LIEF/LIEF/PE/resources/ResourceStringTable.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 * Copyright 2017 - 2021 K. Nakagawa
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_RESOURCE_STRING_TABLE_H
#define LIEF_PE_RESOURCE_STRING_TABLE_H
#include <string>

#include "LIEF/visibility.h"
#include "LIEF/Object.hpp"

namespace LIEF {
namespace PE {
class ResourcesManager;

class LIEF_API ResourceStringTable : public Object {

  friend class ResourcesManager;
  public:
  ResourceStringTable() = default;

  ResourceStringTable(int16_t length, std::u16string name) :
    name_(std::move(name)),
    length_(length)
  {}

  ResourceStringTable(const ResourceStringTable&) = default;
  ResourceStringTable& operator=(const ResourceStringTable&) = default;

  ~ResourceStringTable() override = default;

  void accept(Visitor& visitor) const override;

  //! The size of the string, not including length field itself.
  int16_t length() const {
    return length_;
  }

  //! The variable-length Unicode string data, word-aligned.
  const std::u16string& name() const {
    return name_;
  }

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const ResourceStringTable& string_table);

  private:
  std::u16string name_;
  int16_t length_ = 0;
};

}
}

#endif

```

`KDemu/include/LIEF/LIEF/PE/resources/ResourceVarFileInfo.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_RESOURCE_VAR_FILE_INFO_H
#define LIEF_PE_RESOURCE_VAR_FILE_INFO_H
#include <ostream>
#include <cstdint>
#include <vector>

#include "LIEF/visibility.h"

#include "LIEF/Object.hpp"

namespace LIEF {
namespace PE {

class ResourcesManager;
class ResourceVersion;
struct ResourcesParser;

//! This object describes information about languages supported by the application
//!
//! @see LIEF::PE::ResourceVersion
class LIEF_API ResourceVarFileInfo : public Object {

  friend class ResourcesManager;
  friend class ResourceVersion;
  friend struct ResourcesParser;

  public:
  ResourceVarFileInfo();
  ResourceVarFileInfo(uint16_t type, std::u16string key);
  ResourceVarFileInfo(const ResourceVarFileInfo&) = default;
  ResourceVarFileInfo& operator=(const ResourceVarFileInfo&) = default;
  ~ResourceVarFileInfo() override = default;

  //! The type of data in the version resource
  //! * ``1`` if it contains text data
  //! * ``0`` if it contains binary data
  uint16_t type() const {
    return type_;
  }

  //! Signature of the structure:
  //! Must be the unicode string "VarFileInfo"
  const std::u16string& key() const {
    return key_;
  }

  //! List of languages that the application supports
  //!
  //! The **least** significant 16-bits  must contain a Microsoft language identifier,
  //! and the **most** significant 16-bits must contain the PE::CODE_PAGES
  //! Either **most** or **least** 16-bits can be zero, indicating that the file is language or code page independent.
  const std::vector<uint32_t>& translations() const {
    return translations_;
  }

  std::vector<uint32_t>& translations() {
    return translations_;
  }

  void type(uint16_t type) {
    type_ = type;
  }

  void key(std::u16string key) {
    key_ = std::move(key);
  }

  void key(const std::string& key);

  void translations(std::vector<uint32_t> translations) {
    translations_ = std::move(translations);
  }

  void accept(Visitor& visitor) const override;


  LIEF_API friend std::ostream& operator<<(std::ostream& os, const ResourceVarFileInfo& entry);

  private:
  uint16_t  type_ = 0;
  std::u16string key_;
  std::vector<uint32_t> translations_;

};
}
}

#endif

```

`KDemu/include/LIEF/LIEF/PE/resources/ResourceVersion.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_RESOURCE_VERSION_H
#define LIEF_PE_RESOURCE_VERSION_H
#include <ostream>
#include <sstream>
#include <memory>

#include "LIEF/visibility.h"

#include "LIEF/Object.hpp"

namespace LIEF {
namespace PE {
class ResourceFixedFileInfo;
class ResourceStringFileInfo;
class ResourceVarFileInfo;

class ResourcesManager;
struct ResourcesParser;

//! Representation of the data associated with the ``RT_VERSION`` entry
//!
//! See: ``VS_VERSIONINFO`` - https://docs.microsoft.com/en-us/windows/win32/menurc/vs-versioninfo
class LIEF_API ResourceVersion : public Object {
  friend class ResourcesManager;
  friend struct ResourcesParser;

  public:
  ResourceVersion(const ResourceVersion&);
  ResourceVersion& operator=(const ResourceVersion&);
  ~ResourceVersion() override;

  //! The type of data in the version resource
  //! * ``1`` if it contains text data
  //! * ``0`` if it contains binary data
  uint16_t type() const;

  //! Signature of the structure:
  //! Must be the unicode string "VS_VERSION_INFO"
  const std::u16string& key() const;

  //! ``true`` if the version contains a ResourceFixedFileInfo
  bool has_fixed_file_info() const;

  //! ``true`` if the version contains a ResourceStringFileInfo
  bool has_string_file_info() const;

  //! ``true`` if the version contains a ResourceVarFileInfo
  bool has_var_file_info() const;

  //! Object that describes various information about the application's version.
  //! This is an optional information and if it is not present, it returns a nullptr
  const ResourceFixedFileInfo* fixed_file_info() const;
  ResourceFixedFileInfo*       fixed_file_info();

  //! Object that describes various information about the application's version.
  //! The underlying structure is basically a dictionary (key/value)
  //!
  //! This structure is not always present and if not, it returns a nullptr
  const ResourceStringFileInfo* string_file_info() const;
  ResourceStringFileInfo*       string_file_info();

  //! Object that describes information about languages supported by the application
  //! This structure is not always present and if not, it returns a nullptr
  const ResourceVarFileInfo* var_file_info() const;
  ResourceVarFileInfo*       var_file_info();

  void type(uint16_t type);

  void key(std::u16string key) {
    key_ = std::move(key);
  }
  void key(const std::string& key);

  void fixed_file_info(const ResourceFixedFileInfo& fixed_file_info);
  void remove_fixed_file_info();

  void string_file_info(const ResourceStringFileInfo& string_file_info);
  void remove_string_file_info();

  void var_file_info(const ResourceVarFileInfo& var_file_info);
  void remove_var_file_info();

  void accept(Visitor& visitor) const override;


  LIEF_API friend std::ostream& operator<<(std::ostream& os, const ResourceVersion& version);

  private:
  ResourceVersion();

  uint16_t       type_;
  std::u16string key_;

  // Optional structures
  std::unique_ptr<ResourceFixedFileInfo>  fixed_file_info_;
  std::unique_ptr<ResourceStringFileInfo> string_file_info_;
  std::unique_ptr<ResourceVarFileInfo>    var_file_info_;
};




}
}


#endif

```

`KDemu/include/LIEF/LIEF/PE/resources/langs.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_RESOURCE_LANG_H
#define LIEF_PE_RESOURCE_LANG_H
namespace LIEF {
namespace PE {

enum class RESOURCE_LANGS  {
  NEUTRAL        = 0x00,
  INVARIANT      = 0x7f,
  AFRIKAANS      = 0x36,
  ALBANIAN       = 0x1c,
  ARABIC         = 0x01,
  ARMENIAN       = 0x2b,
  ASSAMESE       = 0x4d,
  AZERI          = 0x2c,
  BASQUE         = 0x2d,
  BELARUSIAN     = 0x23,
  BANGLA         = 0x45,
  BULGARIAN      = 0x02,
  CATALAN        = 0x03,
  CHINESE        = 0x04,
  CROATIAN       = 0x1a,
  BOSNIAN        = 0x1a,
  CZECH          = 0x05,
  DANISH         = 0x06,
  DIVEHI         = 0x65,
  DUTCH          = 0x13,
  ENGLISH        = 0x09,
  ESTONIAN       = 0x25,
  FAEROESE       = 0x38,
  FARSI          = 0x29,
  FINNISH        = 0x0b,
  FRENCH         = 0x0c,
  GALICIAN       = 0x56,
  GEORGIAN       = 0x37,
  GERMAN         = 0x07,
  GREEK          = 0x08,
  GUJARATI       = 0x47,
  HEBREW         = 0x0d,
  HINDI          = 0x39,
  HUNGARIAN      = 0x0e,
  ICELANDIC      = 0x0f,
  INDONESIAN     = 0x21,
  ITALIAN        = 0x10,
  JAPANESE       = 0x11,
  KANNADA        = 0x4b,
  KASHMIRI       = 0x60,
  KAZAK          = 0x3f,
  KONKANI        = 0x57,
  KOREAN         = 0x12,
  KYRGYZ         = 0x40,
  LATVIAN        = 0x26,
  LITHUANIAN     = 0x27,
  MACEDONIAN     = 0x2f,
  MALAY          = 0x3e,
  MALAYALAM      = 0x4c,
  MANIPURI       = 0x58,
  MARATHI        = 0x4e,
  MONGOLIAN      = 0x50,
  NEPALI         = 0x61,
  NORWEGIAN      = 0x14,
  ORIYA          = 0x48,
  POLISH         = 0x15,
  PORTUGUESE     = 0x16,
  PUNJABI        = 0x46,
  ROMANIAN       = 0x18,
  RUSSIAN        = 0x19,
  SANSKRIT       = 0x4f,
  SERBIAN        = 0x1a,
  SINDHI         = 0x59,
  SLOVAK         = 0x1b,
  SLOVENIAN      = 0x24,
  SPANISH        = 0x0a,
  SWAHILI        = 0x41,
  SWEDISH        = 0x1d,
  SYRIAC         = 0x5a,
  TAMIL          = 0x49,
  TATAR          = 0x44,
  TELUGU         = 0x4a,
  THAI           = 0x1e,
  TURKISH        = 0x1f,
  UKRAINIAN      = 0x22,
  URDU           = 0x20,
  UZBEK          = 0x43,
  VIETNAMESE     = 0x2a,
  GAELIC         = 0x3c,
  MALTESE        = 0x3a,
  MAORI          = 0x28,
  RHAETO_ROMANCE = 0x17,
  SAMI           = 0x3b,
  SORBIAN        = 0x2e,
  SUTU           = 0x30,
  TSONGA         = 0x31,
  TSWANA         = 0x32,
  VENDA          = 0x33,
  XHOSA          = 0x34,
  ZULU           = 0x35,
  ESPERANTO      = 0x8f,
  WALON          = 0x90,
  CORNISH        = 0x91,
  WELSH          = 0x92,
  BRETON         = 0x93,
  INUKTITUT      = 0x5d,
  IRISH          = 0x3C,
  LOWER_SORBIAN  = 0x2E,
  PULAR          = 0x67,
  QUECHUA        = 0x6B,
  TAMAZIGHT      = 0x5F,
  TIGRINYA       = 0x73,
  VALENCIAN      = 0x03,
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/PE/signature/Attribute.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_ATTRIBUTES_H
#define LIEF_PE_ATTRIBUTES_H
#include <memory>
#include <string>

#include "LIEF/Object.hpp"
#include "LIEF/visibility.h"

namespace LIEF {
namespace PE {

//! Interface over PKCS #7 attribute
class LIEF_API Attribute : public Object {

  friend class Parser;
  friend class SignatureParser;

  public:
  enum class TYPE {
    UNKNOWN = 0,
    CONTENT_TYPE,
    GENERIC_TYPE,
    SIGNING_CERTIFICATE_V2,

    SPC_SP_OPUS_INFO,
    SPC_RELAXED_PE_MARKER_CHECK,

    MS_COUNTER_SIGN,
    MS_SPC_NESTED_SIGN,
    MS_SPC_STATEMENT_TYPE,
    MS_PLATFORM_MANIFEST_BINARY_ID,

    PKCS9_AT_SEQUENCE_NUMBER,
    PKCS9_COUNTER_SIGNATURE,
    PKCS9_MESSAGE_DIGEST,
    PKCS9_SIGNING_TIME,
  };

  Attribute() = delete;
  Attribute(const Attribute&) = default;
  Attribute& operator=(const Attribute&) = default;

  virtual std::unique_ptr<Attribute> clone() const = 0;

  //! Concrete type of the attribute
  virtual TYPE type() const {
    return type_;
  }

  //! Print information about the underlying attribute
  virtual std::string print() const = 0;

  void accept(Visitor& visitor) const override;

  ~Attribute() override = default;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const Attribute& Attribute);

  protected:
  Attribute(TYPE type) :
    type_(type)
  {}
  TYPE type_ = TYPE::UNKNOWN;
};

LIEF_API const char* to_string(Attribute::TYPE e);

}
}

#endif

```

`KDemu/include/LIEF/LIEF/PE/signature/ContentInfo.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_CONTENT_INFO_H
#define LIEF_PE_CONTENT_INFO_H

#include <vector>
#include <ostream>
#include <memory>

#include "LIEF/Object.hpp"
#include "LIEF/visibility.h"

#include "LIEF/PE/signature/types.hpp"
#include "LIEF/PE/enums.hpp"

namespace LIEF {
namespace PE {

class Parser;
class SignatureParser;

/**
 * ContentInfo as described in the RFC2315 (https://tools.ietf.org/html/rfc2315#section-7)
 *
 * ```text
 * ContentInfo ::= SEQUENCE {
 *   contentType ContentType,
 *   content     [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL
 * }
 *
 * ContentType ::= OBJECT IDENTIFIER
 * ```
 *
 * In the case of PE signature, ContentType **must** be set to SPC_INDIRECT_DATA_OBJID
 * OID: ``1.3.6.1.4.1.311.2.1.4`` and content is defined by the structure: ``SpcIndirectDataContent``
 *
 * ```text
 * SpcIndirectDataContent ::= SEQUENCE {
 *  data          SpcAttributeTypeAndOptionalValue,
 *  messageDigest DigestInfo
 * }
 *
 * SpcAttributeTypeAndOptionalValue ::= SEQUENCE {
 *  type  ObjectID,
 *  value [0] EXPLICIT ANY OPTIONAL
 * }
 * ```
 *
 * For PE signature, ``SpcAttributeTypeAndOptionalValue.type``
 * is set to ``SPC_PE_IMAGE_DATAOBJ`` (OID: ``1.3.6.1.4.1.311.2.1.15``) and the value is defined by
 * ``SpcPeImageData``
 *
 * ```text
 * DigestInfo ::= SEQUENCE {
 *  digestAlgorithm  AlgorithmIdentifier,
 *  digest           OCTETSTRING
 * }
 *
 * AlgorithmIdentifier ::= SEQUENCE {
 *  algorithm  ObjectID,
 *  parameters [0] EXPLICIT ANY OPTIONAL
 * }
 * ```
 */
class LIEF_API ContentInfo : public Object {
  friend class Parser;
  friend class SignatureParser;

  public:
  class Content : public Object {
    public:
    Content(oid_t oid) :
      type_(std::move(oid))
    {}

    const oid_t& content_type() const {
      return type_;
    }

    virtual std::unique_ptr<Content> clone() const = 0;
    virtual void print(std::ostream& os) const = 0;

    LIEF_API friend std::ostream& operator<<(std::ostream& os, const Content& content) {
      content.print(os);
      return os;
    }

    ~Content() override = default;
    private:
    oid_t type_;
  };
  ContentInfo();
  ContentInfo(const ContentInfo& other);
  ContentInfo(ContentInfo&& other) noexcept = default;
  ContentInfo& operator=(ContentInfo other);

  void swap(ContentInfo& other) noexcept;

  //! Return the OID that describes the content wrapped by this object.
  //! It should match SPC_INDIRECT_DATA_OBJID (1.3.6.1.4.1.311.2.1.4)
  oid_t content_type() const {
    return value_->content_type();
  }

  Content& value() {
    return *value_;
  }

  const Content& value() const {
    return *value_;
  }

  /// Return the digest (authentihash) if the underlying content type is `SPC_INDIRECT_DATA_OBJID`
  /// Otherwise, return an empty vector
  std::vector<uint8_t> digest() const;

  /// Return the digest used to hash the file
  ALGORITHMS digest_algorithm() const;

  void accept(Visitor& visitor) const override;

  ~ContentInfo() override = default;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const ContentInfo& content_info);

  private:
  std::unique_ptr<Content> value_;
};

}
}

#endif

```

`KDemu/include/LIEF/LIEF/PE/signature/GenericContent.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_GENERIC_CONTENT_H
#define LIEF_PE_GENERIC_CONTENT_H

#include "LIEF/visibility.h"
#include "LIEF/span.hpp"

#include "LIEF/PE/signature/ContentInfo.hpp"

namespace LIEF {
namespace PE {
class LIEF_API GenericContent : public ContentInfo::Content {
  friend class SignatureParser;

  public:
  GenericContent();
  GenericContent(oid_t oid);
  GenericContent(const GenericContent&) = default;
  GenericContent& operator=(const GenericContent&) = default;

  std::unique_ptr<Content> clone() const override {
    return std::unique_ptr<Content>(new GenericContent{*this});
  }

  const oid_t& oid() const {
    return oid_;
  }

  span<const uint8_t> raw() const {
    return raw_;
  }

  span<uint8_t> raw() {
    return raw_;
  }

  ~GenericContent() override;

  void print(std::ostream& os) const override;
  void accept(Visitor& visitor) const override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const GenericContent& content) {
    content.print(os);
    return os;
  }

  static bool classof(const ContentInfo::Content* content);

  private:
  oid_t oid_;
  std::vector<uint8_t> raw_;
};
}
}
#endif

```

`KDemu/include/LIEF/LIEF/PE/signature/OIDToString.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_OID_TO_STRING_H
#define LIEF_PE_OID_TO_STRING_H
#include "LIEF/visibility.h"
#include "LIEF/PE/signature/types.hpp"

namespace LIEF {
namespace PE {

//! @brief Convert an OID to a human-readable string
LIEF_API const char* oid_to_string(const oid_t& oid);

}
}

#endif

```

`KDemu/include/LIEF/LIEF/PE/signature/PKCS9TSTInfo.hpp`:

```hpp
/* Copyright 2017 - 2023 R. Thomas
 * Copyright 2017 - 2023 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_PKCS9_TSTINFO_H
#define LIEF_PE_PKCS9_TSTINFO_H
#include <ostream>
#include <memory>

#include "LIEF/Visitor.hpp"
#include "LIEF/PE/signature/ContentInfo.hpp"

namespace LIEF {
namespace PE {

//! Interface over the structure described by the OID `1.2.840.113549.1.9.16.1.4` (PKCS #9)
//!
//! The internal structure is described in the
//! [RFC #3161](https://tools.ietf.org/html/rfc3161)
//!
//! ```text
//! TSTInfo ::= SEQUENCE  {
//!  version        INTEGER  { v1(1) },
//!  policy         TSAPolicyId,
//!  messageImprint MessageImprint,
//!  serialNumber   INTEGER,
//!  genTime        GeneralizedTime,
//!  accuracy       Accuracy                OPTIONAL,
//!  ordering       BOOLEAN                 DEFAULT FALSE,
//!  nonce          INTEGER                 OPTIONAL,
//!  tsa            [0] GeneralName         OPTIONAL,
//!  extensions     [1] IMPLICIT Extensions OPTIONAL
//! }
//!
//! TSAPolicyId    ::= OBJECT IDENTIFIER
//! MessageImprint ::= SEQUENCE {
//!   hashAlgorithm  AlgorithmIdentifier,
//!   hashedMessage  OCTET STRING
//! }
//!
//! Accuracy ::= SEQUENCE {
//!   seconds        INTEGER           OPTIONAL,
//!   millis     [0] INTEGER  (1..999) OPTIONAL,
//!   micros     [1] INTEGER  (1..999) OPTIONAL
//! }
//! ```
class PKCS9TSTInfo : public ContentInfo::Content {
  friend class SignatureParser;

  public:
  static constexpr auto PKCS9_TSTINFO_OBJID = "1.2.840.113549.1.9.16.1.4";
  PKCS9TSTInfo() :
    ContentInfo::Content(PKCS9_TSTINFO_OBJID)
  {}
  PKCS9TSTInfo(const PKCS9TSTInfo&) = default;
  PKCS9TSTInfo& operator=(const PKCS9TSTInfo&) = default;

  std::unique_ptr<Content> clone() const override {
    return std::unique_ptr<Content>(new PKCS9TSTInfo{*this});
  }

  void print(std::ostream& /*os*/) const override {
    return;
  }

  void accept(Visitor& visitor) const override;

  ~PKCS9TSTInfo() override = default;

  static bool classof(const ContentInfo::Content* content) {
    return content->content_type() == PKCS9_TSTINFO_OBJID;
  }

  private:
  uint32_t version_;
};
}
}
#endif

```

`KDemu/include/LIEF/LIEF/PE/signature/RsaInfo.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_SIGNATURE_RSA_INFO_H
#define LIEF_PE_SIGNATURE_RSA_INFO_H
#include <vector>
#include <ostream>
#include <cstdint>

#include "LIEF/visibility.h"

namespace LIEF {
namespace PE {
class x509;

//! Object that wraps a RSA key
class LIEF_API RsaInfo {
  friend class x509;

  public:
  using rsa_ctx_handle = void*;
  using bignum_wrapper_t = std::vector<uint8_t>; ///< Container for BigInt

  public:
  RsaInfo(const RsaInfo& other);
  RsaInfo(RsaInfo&& other);
  RsaInfo& operator=(RsaInfo other);

  //! True if it embeds a public key
  bool has_public_key() const;

  //! True if it embeds a private key
  bool has_private_key() const;

  //! RSA public modulus
  bignum_wrapper_t N() const;

  //! RSA public exponent
  bignum_wrapper_t E() const;

  //! RSA private exponent
  bignum_wrapper_t D() const;

  //! First prime factor
  bignum_wrapper_t P() const;

  //! Second prime factor
  bignum_wrapper_t Q() const;

  //! Size of the public modulus (in bits)
  size_t key_size() const;

  void swap(RsaInfo& other);
  operator bool() const;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const RsaInfo& info);

  ~RsaInfo();

  private:
  RsaInfo();
  RsaInfo(const rsa_ctx_handle ctx);
  rsa_ctx_handle ctx_;
};

}
}
#endif

```

`KDemu/include/LIEF/LIEF/PE/signature/Signature.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_SIGNATURE_H
#define LIEF_PE_SIGNATURE_H

#include "LIEF/Object.hpp"
#include "LIEF/visibility.h"
#include "LIEF/span.hpp"

#include "LIEF/PE/signature/x509.hpp"
#include "LIEF/PE/signature/SignerInfo.hpp"
#include "LIEF/PE/signature/ContentInfo.hpp"

#include "LIEF/PE/enums.hpp"

#include "LIEF/iterators.hpp"
#include "LIEF/enums.hpp"

namespace LIEF {
namespace PE {

class SignatureParser;
class Binary;

//! Main interface for the PKCS #7 signature scheme
class LIEF_API Signature : public Object {

  friend class SignatureParser;
  friend class Parser;
  friend class Binary;

  public:
  //! Hash the input given the algorithm
  static std::vector<uint8_t> hash(const std::vector<uint8_t>& input, ALGORITHMS algo) {
    return hash(input.data(), input.size(), algo);
  }

  static std::vector<uint8_t> hash(const uint8_t* buffer, size_t size, ALGORITHMS algo);

  public:

  //! Iterator which outputs const x509& certificates
  using it_const_crt = const_ref_iterator<const std::vector<x509>&>;

  //! Iterator which outputs x509& certificates
  using it_crt = ref_iterator<std::vector<x509>&>;

  //! Iterator which outputs const SignerInfo&
  using it_const_signers_t = const_ref_iterator<const std::vector<SignerInfo>&>;

  //! Iterator which outputs SignerInfo&
  using it_signers_t = ref_iterator<std::vector<SignerInfo>&>;

  //! Flags returned by the verification functions
  enum class VERIFICATION_FLAGS : uint32_t {
    OK = 0,
    INVALID_SIGNER                = 1 << 0,
    UNSUPPORTED_ALGORITHM         = 1 << 1,
    INCONSISTENT_DIGEST_ALGORITHM = 1 << 2,
    CERT_NOT_FOUND                = 1 << 3,
    CORRUPTED_CONTENT_INFO        = 1 << 4,
    CORRUPTED_AUTH_DATA           = 1 << 5,
    MISSING_PKCS9_MESSAGE_DIGEST  = 1 << 6,
    BAD_DIGEST                    = 1 << 7,
    BAD_SIGNATURE                 = 1 << 8,
    NO_SIGNATURE                  = 1 << 9,
    CERT_EXPIRED                  = 1 << 10,
    CERT_FUTURE                   = 1 << 11,
  };

  //! Convert a verification flag into a humman representation.
  //! e.g VERIFICATION_FLAGS.BAD_DIGEST | VERIFICATION_FLAGS.BAD_SIGNATURE | VERIFICATION_FLAGS.CERT_EXPIRED
  static std::string flag_to_string(VERIFICATION_FLAGS flag);

  //! Flags to tweak the verification process of the signature
  //!
  //! See Signature::check and LIEF::PE::Binary::verify_signature
  enum class VERIFICATION_CHECKS : uint32_t {
    DEFAULT          = 1 << 0, /**< Default behavior that tries to follow the Microsoft verification process as close as possible */
    HASH_ONLY        = 1 << 1, /**< Only check that Binary::authentihash matches ContentInfo::digest regardless of the signature's validity */
    LIFETIME_SIGNING = 1 << 2, /**< Same semantic as [WTD_LIFETIME_SIGNING_FLAG](https://docs.microsoft.com/en-us/windows/win32/api/wintrust/ns-wintrust-wintrust_data#WTD_LIFETIME_SIGNING_FLAG) */
    SKIP_CERT_TIME   = 1 << 3, /**< Skip the verification of the certificates time validities so that even though a certificate expired, it returns VERIFICATION_FLAGS::OK */
  };

  Signature();
  Signature(const Signature&);
  Signature& operator=(const Signature&);

  Signature(Signature&&);
  Signature& operator=(Signature&&);

  //! Should be 1
  uint32_t version() const {
    return version_;
  }

  //! Algorithm used to *digest* the file.
  //!
  //! It should match SignerInfo::digest_algorithm
  ALGORITHMS digest_algorithm() const {
    return digest_algorithm_;
  }

  //! Return the ContentInfo
  const ContentInfo& content_info() const {
    return content_info_;
  }

  //! Return an iterator over x509 certificates
  it_const_crt certificates() const {
    return certificates_;
  }

  it_crt certificates()  {
    return certificates_;
  }

  //! Return an iterator over the signers (SignerInfo) defined in the PKCS #7 signature
  it_const_signers_t signers() const {
    return signers_;
  }

  it_signers_t signers() {
    return signers_;
  }

  //! Return the raw original PKCS7 signature
  span<const uint8_t> raw_der() const {
    return original_raw_signature_;
  }

  //! Find x509 certificate according to its serial number
  const x509* find_crt(const std::vector<uint8_t>& serialno) const;

  //! Find x509 certificate according to its subject
  const x509* find_crt_subject(const std::string& subject) const;

  //! Find x509 certificate according to its subject **AND** serial number
  const x509* find_crt_subject(const std::string& subject, const std::vector<uint8_t>& serialno) const;

  //! Find x509 certificate according to its issuer
  const x509* find_crt_issuer(const std::string& issuer) const;

  //! Find x509 certificate according to its issuer **AND** serial number
  const x509* find_crt_issuer(const std::string& issuer, const std::vector<uint8_t>& serialno) const;

  //! Check if this signature is valid according to the Authenticode/PKCS #7 verification scheme
  //!
  //! By default, it performs the following verifications:
  //!
  //! 1. It must contain only **one** signer info
  //! 2. Signature::digest_algorithm must match:
  //!    * ContentInfo::digest_algorithm
  //!    * SignerInfo::digest_algorithm
  //! 3. The x509 certificate specified by SignerInfo::serial_number **and** SignerInfo::issuer
  //!    must exist within Signature::certificates
  //! 4. Given the x509 certificate, compare SignerInfo::encrypted_digest against either:
  //!    * hash of authenticated attributes if present
  //!    * hash of ContentInfo
  //! 5. If authenticated attributes are present, check that a PKCS9_MESSAGE_DIGEST attribute exists
  //!    and that its value matches hash of ContentInfo
  //! 6. Check the validity of the PKCS #9 counter signature if present
  //! 7. If the signature doesn't embed a signing-time in the counter signature, check the certificate
  //!    validity. (See LIEF::PE::Signature::VERIFICATION_CHECKS::LIFETIME_SIGNING and LIEF::PE::Signature::VERIFICATION_CHECKS::SKIP_CERT_TIME)
  //!
  //! See: LIEF::PE::Signature::VERIFICATION_CHECKS to tweak the behavior
  VERIFICATION_FLAGS check(VERIFICATION_CHECKS checks = VERIFICATION_CHECKS::DEFAULT) const;

  void accept(Visitor& visitor) const override;

  ~Signature() override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const Signature& signature);

  private:
  uint32_t                version_ = 0;
  ALGORITHMS              digest_algorithm_ = ALGORITHMS::UNKNOWN;
  ContentInfo             content_info_;
  std::vector<x509>       certificates_;
  std::vector<SignerInfo> signers_;

  uint64_t                content_info_start_ = 0;
  uint64_t                content_info_end_ = 0;

  std::vector<uint8_t> original_raw_signature_;
};


}
}

ENABLE_BITMASK_OPERATORS(LIEF::PE::Signature::VERIFICATION_FLAGS)
ENABLE_BITMASK_OPERATORS(LIEF::PE::Signature::VERIFICATION_CHECKS)


#endif


```

`KDemu/include/LIEF/LIEF/PE/signature/SignatureParser.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_SIGNATURE_PARSER_H
#define LIEF_PE_SIGNATURE_PARSER_H
#include <memory>
#include <string>
#include <array>

#include "LIEF/errors.hpp"

#include "LIEF/PE/signature/Signature.hpp"
#include "LIEF/PE/signature/OIDToString.hpp"

namespace LIEF {
class BinaryStream;
class VectorStream;

namespace PE {
class Parser;
class Attribute;
class SpcIndirectData;
class PKCS9TSTInfo;

class LIEF_API SignatureParser {
  friend class Parser;
  struct SpcPeImageData {
    uint32_t flags;
    std::string file;
  };

  struct SpcSpOpusInfo {
    std::string program_name;
    std::string more_info;
  };
  struct range_t {
    uint64_t start = 0;
    uint64_t end = 0;
  };

  public:
  using attributes_t = std::vector<std::unique_ptr<Attribute>>;
  using signer_infos_t = std::vector<SignerInfo>;
  using x509_certificates_t = std::vector<x509>;
  using time_t = std::array<int32_t, 6>;

  //! Parse a PKCS #7 signature given a raw blob
  static result<Signature> parse(std::vector<uint8_t> data, bool skip_header = false);

  //! Parse a PKCS #7 signature given a BinaryStream
  static result<Signature> parse(BinaryStream& stream, bool skip_header = false);

  //! Parse a PKCS #7 signature from a file path
  static result<Signature> parse(const std::string& path);
  SignatureParser(const SignatureParser&) = delete;
  SignatureParser& operator=(const SignatureParser&) = delete;
  private:

  ~SignatureParser() = default;
  SignatureParser() = default;

  static result<Signature> parse_signature(BinaryStream& stream);

  static result<ContentInfo> parse_content_info(BinaryStream& stream, range_t& range);
  static result<x509_certificates_t> parse_certificates(BinaryStream& stream);
  static result<signer_infos_t> parse_signer_infos(BinaryStream& stream);
  static result<attributes_t> parse_attributes(BinaryStream& stream);
  static result<std::unique_ptr<Attribute>> parse_content_type(BinaryStream& stream);

  static result<signer_infos_t> parse_pkcs9_counter_sign(BinaryStream& stream);
  static result<std::vector<uint8_t>> parse_pkcs9_message_digest(BinaryStream& stream);
  static result<int32_t> parse_pkcs9_at_sequence_number(BinaryStream& stream);
  static result<time_t> parse_pkcs9_signing_time(BinaryStream& stream);
  static result<std::unique_ptr<PKCS9TSTInfo>> parse_pkcs9_tstinfo(BinaryStream& stream);

  static result<std::unique_ptr<Attribute>> parse_ms_counter_sign(BinaryStream& stream);
  static result<Signature> parse_ms_spc_nested_signature(BinaryStream& stream);
  static result<oid_t> parse_ms_spc_statement_type(BinaryStream& stream);
  static result<SpcSpOpusInfo> parse_spc_sp_opus_info(BinaryStream& stream);
  static result<std::string> parse_spc_string(BinaryStream& stream);
  static result<std::string> parse_spc_link(BinaryStream& stream);
  static result<std::unique_ptr<Attribute>> parse_spc_relaxed_pe_marker_check(BinaryStream& stream);
  static result<SpcPeImageData> parse_spc_pe_image_data(BinaryStream& stream);
  static result<std::unique_ptr<SpcIndirectData>> parse_spc_indirect_data(BinaryStream& stream, range_t& range);
  static result<std::unique_ptr<Attribute>> parse_ms_platform_manifest_binary_id(BinaryStream& stream);

  static result<std::unique_ptr<Attribute>> parse_signing_certificate_v2(BinaryStream& stream);
};

}
}

#endif

```

`KDemu/include/LIEF/LIEF/PE/signature/SignerInfo.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_SIGNER_INFO_H
#define LIEF_PE_SIGNER_INFO_H
#include <memory>

#include "LIEF/Object.hpp"
#include "LIEF/visibility.h"
#include "LIEF/span.hpp"

#include "LIEF/PE/signature/types.hpp"
#include "LIEF/iterators.hpp"
#include "LIEF/PE/enums.hpp"
#include "LIEF/PE/signature/Attribute.hpp"

namespace LIEF {
namespace PE {

class Signature;
class Attribute;
class Parser;
class SignatureParser;
class x509;

/** SignerInfo as described in the [RFC 2315](https://tools.ietf.org/html/rfc2315#section-9.2)
 *
 * ```text
 * SignerInfo ::= SEQUENCE {
 *  version Version,
 *  issuerAndSerialNumber     IssuerAndSerialNumber,
 *  digestAlgorithm           DigestAlgorithmIdentifier,
 *  authenticatedAttributes   [0] IMPLICIT Attributes OPTIONAL,
 *  digestEncryptionAlgorithm DigestEncryptionAlgorithmIdentifier,
 *  encryptedDigest           EncryptedDigest,
 *  unauthenticatedAttributes [1] IMPLICIT Attributes OPTIONAL
 * }
 *
 * EncryptedDigest ::= OCTET STRING
 * ```
 */
class LIEF_API SignerInfo : public Object {
  friend class Parser;
  friend class SignatureParser;
  friend class Signature;

  public:
  using encrypted_digest_t = std::vector<uint8_t>;

  //! Internal container used to store both
  //! authenticated and unauthenticated attributes
  using attributes_t = std::vector<std::unique_ptr<Attribute>>;

  //! Iterator which outputs const Attribute&
  using it_const_attributes_t = const_ref_iterator<const attributes_t&, const Attribute*>;

  SignerInfo();

  SignerInfo(const SignerInfo& other);
  SignerInfo& operator=(SignerInfo other);

  SignerInfo(SignerInfo&&);
  SignerInfo& operator=(SignerInfo&&);

  void swap(SignerInfo& other);

  //! Should be 1
  uint32_t version() const {
    return version_;
  }

  //! Return the serial number associated with the x509 certificate
  //! used by this signer.
  //!
  //! @see
  //! LIEF::PE::x509::serial_number
  //! SignerInfo::issuer
  span<const uint8_t> serial_number() const {
    return serialno_;
  }

  //! Return the x509::issuer used by this signer
  const std::string& issuer() const {
    return issuer_;
  }

  //! Algorithm (OID) used to hash the file.
  //!
  //! This value should match LIEF::PE::ContentInfo::digest_algorithm and
  //! LIEF::PE::Signature::digest_algorithm
  ALGORITHMS digest_algorithm() const {
    return digest_algorithm_;
  }

  //! Return the (public-key) algorithm used to encrypt
  //! the signature
  ALGORITHMS encryption_algorithm() const {
    return digest_enc_algorithm_;
  }

  //! Return the signature created by the signing
  //! certificate's private key
  const encrypted_digest_t& encrypted_digest() const {
    return encrypted_digest_;
  }

  //! Iterator over LIEF::PE::Attribute for **authenticated** attributes
  it_const_attributes_t authenticated_attributes() const {
    return authenticated_attributes_;
  }

  //! Iterator over LIEF::PE::Attribute for **unauthenticated** attributes
  it_const_attributes_t unauthenticated_attributes() const {
    return unauthenticated_attributes_;
  }

  //! Return the authenticated or un-authenticated attribute matching the
  //! given PE::SIG_ATTRIBUTE_TYPES.
  //!
  //! It returns **the first** entry that matches the given type. If it can't be
  //! found, it returns a nullptr.
  const Attribute* get_attribute(Attribute::TYPE type) const;

  //! Return the authenticated attribute matching the given PE::SIG_ATTRIBUTE_TYPES.
  //!
  //! It returns **the first** entry that matches the given type. If it can't be
  //! found, it returns a nullptr.
  const Attribute* get_auth_attribute(Attribute::TYPE type) const;

  //! Return the un-authenticated attribute matching the given PE::SIG_ATTRIBUTE_TYPES.
  //!
  //! It returns **the first** entry that matches the given type. If it can't be
  //! found, it returns a nullptr.
  const Attribute* get_unauth_attribute(Attribute::TYPE type) const;

  //! x509 certificate used by this signer. If it can't be found, it returns a nullptr
  const x509* cert() const {
    return cert_.get();
  }

  //! x509 certificate used by this signer. If it can't be found, it returns a nullptr
  x509* cert() {
    return cert_.get();
  }

  //! Raw blob that is signed by the signer certificate
  span<const uint8_t> raw_auth_data() const {
    return raw_auth_data_;
  }

  void accept(Visitor& visitor) const override;

  ~SignerInfo() override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const SignerInfo& signer_info);

  private:
  uint32_t version_ = 0;
  std::string issuer_;
  std::vector<uint8_t> serialno_;

  ALGORITHMS digest_algorithm_     = ALGORITHMS::UNKNOWN;
  ALGORITHMS digest_enc_algorithm_ = ALGORITHMS::UNKNOWN;

  encrypted_digest_t encrypted_digest_;

  std::vector<uint8_t> raw_auth_data_;

  attributes_t authenticated_attributes_;
  attributes_t unauthenticated_attributes_;

  std::unique_ptr<x509> cert_;
};

}
}

#endif

```

`KDemu/include/LIEF/LIEF/PE/signature/SpcIndirectData.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_SPC_INDIRECT_DATA_H
#define LIEF_PE_SPC_INDIRECT_DATA_H
#include <ostream>
#include <string>
#include <vector>
#include <cstdint>

#include "LIEF/visibility.h"
#include "LIEF/span.hpp"

#include "LIEF/PE/signature/ContentInfo.hpp"

namespace LIEF {
namespace PE {
class LIEF_API SpcIndirectData : public ContentInfo::Content {
  friend class SignatureParser;

  public:
  static constexpr auto SPC_INDIRECT_DATA_OBJID = "1.3.6.1.4.1.311.2.1.4";

  SpcIndirectData() :
    ContentInfo::Content(SPC_INDIRECT_DATA_OBJID)
  {}
  SpcIndirectData(const SpcIndirectData&) = default;
  SpcIndirectData& operator=(const SpcIndirectData&) = default;

  std::unique_ptr<Content> clone() const override {
    return std::unique_ptr<Content>(new SpcIndirectData{*this});
  }

  //! Digest used to hash the file
  //!
  //! It should match LIEF::PE::SignerInfo::digest_algorithm
  ALGORITHMS digest_algorithm() const {
    return digest_algorithm_;
  }

  //! PE's authentihash
  //!
  //! @see LIEF::PE::Binary::authentihash
  span<const uint8_t> digest() const {
    return digest_;
  }

  const std::string& file() const {
    return file_;
  }

  void print(std::ostream& os) const override;

  void accept(Visitor& visitor) const override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const SpcIndirectData& content) {
    content.print(os);
    return os;
  }

  ~SpcIndirectData() override = default;

  static bool classof(const ContentInfo::Content* content) {
    return content->content_type() == SPC_INDIRECT_DATA_OBJID;
  }

  private:
  std::string file_;
  uint8_t flags_ = 0;
  ALGORITHMS digest_algorithm_ = ALGORITHMS::UNKNOWN;
  std::vector<uint8_t> digest_;
};
}
}
#endif

```

`KDemu/include/LIEF/LIEF/PE/signature/attributes.hpp`:

```hpp
/* Copyright 2021 - 2024 R. Thomas
 * Copyright 2021 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_SIGNATURE_ATTRIBUTES_H
#define LIEF_PE_SIGNATURE_ATTRIBUTES_H
#include "LIEF/PE/signature/attributes/ContentType.hpp"
#include "LIEF/PE/signature/attributes/GenericType.hpp"
#include "LIEF/PE/signature/attributes/MsCounterSign.hpp"
#include "LIEF/PE/signature/attributes/MsManifestBinaryID.hpp"
#include "LIEF/PE/signature/attributes/MsSpcNestedSignature.hpp"
#include "LIEF/PE/signature/attributes/MsSpcStatementType.hpp"
#include "LIEF/PE/signature/attributes/PKCS9AtSequenceNumber.hpp"
#include "LIEF/PE/signature/attributes/PKCS9CounterSignature.hpp"
#include "LIEF/PE/signature/attributes/PKCS9MessageDigest.hpp"
#include "LIEF/PE/signature/attributes/PKCS9SigningTime.hpp"
#include "LIEF/PE/signature/attributes/SigningCertificateV2.hpp"
#include "LIEF/PE/signature/attributes/SpcSpOpusInfo.hpp"
#include "LIEF/PE/signature/attributes/SpcRelaxedPeMarkerCheck.hpp"
#endif


```

`KDemu/include/LIEF/LIEF/PE/signature/attributes/ContentType.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_ATTRIBUTES_CONTENT_TYPE_H
#define LIEF_PE_ATTRIBUTES_CONTENT_TYPE_H
#include <memory>

#include "LIEF/visibility.h"
#include "LIEF/PE/signature/Attribute.hpp"
#include "LIEF/PE/signature/types.hpp"


namespace LIEF {
class VectorStream;
namespace PE {

//! Interface over the structure described by the OID ``1.2.840.113549.1.9.3`` (PKCS #9)
//!
//! The internal structure is described in the
//! [RFC #2985: PKCS #9 - Selected Object Classes and Attribute Types Version 2.0](https://tools.ietf.org/html/rfc2985)
//!
//! ```text
//! ContentType ::= OBJECT IDENTIFIER
//! ```
class LIEF_API ContentType : public Attribute {

  friend class Parser;
  friend class SignatureParser;

  public:
  ContentType() :
    Attribute(Attribute::TYPE::CONTENT_TYPE)
  {}
  ContentType(oid_t oid) :
    Attribute(Attribute::TYPE::CONTENT_TYPE),
    oid_{std::move(oid)}
  {}
  ContentType(const ContentType&) = default;
  ContentType& operator=(const ContentType&) = default;

  //! OID as described in RFC #2985
  const oid_t& oid() const {
    return oid_;
  }

  //! Print information about the attribute
  std::string print() const override;

  std::unique_ptr<Attribute> clone() const override {
    return std::unique_ptr<Attribute>(new ContentType{*this});
  }

  static bool classof(const Attribute* attr) {
    return attr->type() == Attribute::TYPE::CONTENT_TYPE;
  }

  void accept(Visitor& visitor) const override;
  ~ContentType() override = default;

  private:
  oid_t oid_;
};

}
}

#endif

```

`KDemu/include/LIEF/LIEF/PE/signature/attributes/GenericType.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_ATTRIBUTES_GENERIC_TYPE_H
#define LIEF_PE_ATTRIBUTES_GENERIC_TYPE_H
#include <memory>
#include <vector>

#include "LIEF/visibility.h"
#include "LIEF/span.hpp"
#include "LIEF/PE/signature/Attribute.hpp"
#include "LIEF/PE/signature/types.hpp"

namespace LIEF {
class VectorStream;
namespace PE {

//! Interface over an attribute for which the internal structure is not supported by LIEF
class LIEF_API GenericType : public Attribute {
  friend class Parser;
  friend class SignatureParser;

  public:
  GenericType() :
    Attribute(Attribute::TYPE::GENERIC_TYPE)
  {}
  GenericType(oid_t oid, std::vector<uint8_t> raw) :
    Attribute(Attribute::TYPE::GENERIC_TYPE),
    oid_{std::move(oid)},
    raw_{std::move(raw)}
  {}
  GenericType(const GenericType&) = default;
  GenericType& operator=(const GenericType&) = default;

  std::unique_ptr<Attribute> clone() const override {
    return std::unique_ptr<Attribute>(new GenericType{*this});
  }

  //! OID of the original attribute
  const oid_t& oid() const {
    return oid_;
  }

  //! Original DER blob of the attribute
  span<const uint8_t> raw_content() const {
    return raw_;
  }

  //! Print information about the attribute
  std::string print() const override;

  void accept(Visitor& visitor) const override;

  ~GenericType() override = default;

  static bool classof(const Attribute* attr) {
    return attr->type() == Attribute::TYPE::GENERIC_TYPE;
  }

  private:
  oid_t oid_;
  std::vector<uint8_t> raw_;
};

}
}

#endif

```

`KDemu/include/LIEF/LIEF/PE/signature/attributes/MsCounterSign.hpp`:

```hpp
/* Copyright 2017 - 2023 R. Thomas
 * Copyright 2017 - 2023 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_ATTRIBUTES_MS_COUNTER_SIGNATURE_H
#define LIEF_PE_ATTRIBUTES_MS_COUNTER_SIGNATURE_H

#include "LIEF/visibility.h"
#include "LIEF/PE/signature/Attribute.hpp"

#include "LIEF/PE/signature/x509.hpp"
#include "LIEF/PE/signature/SignerInfo.hpp"
#include "LIEF/PE/signature/ContentInfo.hpp"

#include <vector>

namespace LIEF {
namespace PE {

/// This class exposes the MS Counter Signature attribute
class LIEF_API MsCounterSign : public Attribute {
  friend class Parser;
  friend class SignatureParser;

  public:
  using certificates_t = std::vector<x509>;
  using it_const_certificates = const_ref_iterator<const certificates_t&>;
  using it_certificates = ref_iterator<certificates_t&>;

  using signers_t = std::vector<SignerInfo>;
  using it_const_signers = const_ref_iterator<const signers_t&>;
  using it_signers = ref_iterator<signers_t&>;

  MsCounterSign() :
    Attribute(Attribute::TYPE::MS_COUNTER_SIGN)
  {}

  MsCounterSign(const MsCounterSign&) = default;
  MsCounterSign& operator=(const MsCounterSign&) = default;

  std::unique_ptr<Attribute> clone() const override {
    return std::unique_ptr<Attribute>(new MsCounterSign{*this});
  }

  uint32_t version() const {
    return version_;
  }

  /// Iterator over the LIEF::PE::x509 certificates of this counter signature
  it_const_certificates certificates() const {
    return certificates_;
  }

  it_certificates certificates() {
    return certificates_;
  }

  /// Signer iterator (same as LIEF::PE::SignerInfo)
  it_const_signers signers() const {
    return signers_;
  }

  it_signers signers() {
    return signers_;
  }

  ALGORITHMS digest_algorithm() const {
    return digest_algorithm_;
  }

  const ContentInfo& content_info() const {
    return content_info_;
  }

  std::string print() const override;

  void accept(Visitor& visitor) const override;

  static bool classof(const Attribute* attr) {
    return attr->type() == Attribute::TYPE::MS_COUNTER_SIGN;
  }

  ~MsCounterSign() override = default;

  private:
  uint32_t version_ = 0;
  ALGORITHMS digest_algorithm_ = ALGORITHMS::UNKNOWN;
  ContentInfo content_info_;
  certificates_t certificates_;
  std::vector<SignerInfo> signers_;
};

}
}

#endif

```

`KDemu/include/LIEF/LIEF/PE/signature/attributes/MsManifestBinaryID.hpp`:

```hpp

/* Copyright 2017 - 2023 R. Thomas
 * Copyright 2017 - 2023 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_ATTRIBUTES_MS_MANIFEST_BINARY_ID_H
#define LIEF_PE_ATTRIBUTES_MS_MANIFEST_BINARY_ID_H

#include "LIEF/visibility.h"
#include "LIEF/PE/signature/Attribute.hpp"

namespace LIEF {
namespace PE {

//! Interface over the structure described by the OID `1.3.6.1.4.1.311.10.3.28` (szOID_PLATFORM_MANIFEST_BINARY_ID)
//!
//! The internal structure is not documented but we can infer the following structure:
//!
//! ```text
//! szOID_PLATFORM_MANIFEST_BINARY_ID ::= SET OF BinaryID
//! ```
//!
//! `BinaryID` being an alias of UTF8STRING
class LIEF_API MsManifestBinaryID : public Attribute {

  friend class Parser;
  friend class SignatureParser;

  public:
  MsManifestBinaryID() = delete;
  MsManifestBinaryID(std::string binid) :
    Attribute(Attribute::TYPE::MS_PLATFORM_MANIFEST_BINARY_ID),
    id_(std::move(binid))
  {}

  MsManifestBinaryID(const MsManifestBinaryID&) = default;
  MsManifestBinaryID& operator=(const MsManifestBinaryID&) = default;

  //! Print information about the attribute
  std::string print() const override {
    return id_;
  }

  //! The manifest id as a string
  const std::string& manifest_id() const {
    return id_;
  }

  void manifest_id(const std::string& id) {
    id_ = id;
  }

  std::unique_ptr<Attribute> clone() const override {
    return std::unique_ptr<Attribute>(new MsManifestBinaryID{*this});
  }

  static bool classof(const Attribute* attr) {
    return attr->type() == Attribute::TYPE::MS_PLATFORM_MANIFEST_BINARY_ID;
  }

  void accept(Visitor& visitor) const override;

  virtual ~MsManifestBinaryID() = default;

  private:
  std::string id_;
};

}
}

#endif

```

`KDemu/include/LIEF/LIEF/PE/signature/attributes/MsSpcNestedSignature.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_ATTRIBUTES_MS_SPC_NESTED_SIG_H
#define LIEF_PE_ATTRIBUTES_MS_SPC_NESTED_SIG_H

#include "LIEF/visibility.h"
#include "LIEF/PE/signature/Attribute.hpp"
#include "LIEF/PE/signature/Signature.hpp"


namespace LIEF {
namespace PE {

//! Interface over the structure described by the OID ``1.3.6.1.4.1.311.2.4.1``
//!
//! The internal structure is not documented but we can infer the following structure:
//!
//! ```text
//! MsSpcNestedSignature ::= SET OF SignedData
//! ```
//!
//! ``SignedData`` is the structure described in PKCS #7 RFC (LIEF::PE::Signature)
class LIEF_API MsSpcNestedSignature : public Attribute {

  friend class Parser;
  friend class SignatureParser;

  public:
  MsSpcNestedSignature() = delete;
  MsSpcNestedSignature(Signature sig) :
    Attribute(Attribute::TYPE::MS_SPC_NESTED_SIGN),
    sig_{std::move(sig)}
  {}
  MsSpcNestedSignature(const MsSpcNestedSignature&) = default;
  MsSpcNestedSignature& operator=(const MsSpcNestedSignature&) = default;

  std::unique_ptr<Attribute> clone() const override {
    return std::unique_ptr<Attribute>(new MsSpcNestedSignature{*this});
  }

  //! Underlying Signature object
  const Signature& sig() const {
    return sig_;
  }

  //! Print information about the attribute
  std::string print() const override;

  void accept(Visitor& visitor) const override;

  static bool classof(const Attribute* attr) {
    return attr->type() == Attribute::TYPE::MS_SPC_NESTED_SIGN;
  }

  ~MsSpcNestedSignature() override = default;

  private:
  Signature sig_;
};

}
}

#endif

```

`KDemu/include/LIEF/LIEF/PE/signature/attributes/MsSpcStatementType.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_ATTRIBUTES_MS_SPC_STATEMENT_TYPE_H
#define LIEF_PE_ATTRIBUTES_MS_SPC_STATEMENT_TYPE_H

#include "LIEF/visibility.h"
#include "LIEF/PE/signature/Attribute.hpp"
#include "LIEF/PE/signature/types.hpp"

namespace LIEF {
namespace PE {

//! Interface over the structure described by the OID ``1.3.6.1.4.1.311.2.1.11``
//!
//! The internal structure is described in the official document:
//! [Windows Authenticode Portable Executable Signature Format](http://download.microsoft.com/download/9/c/5/9c5b2167-8017-4bae-9fde-d599bac8184a/Authenticode_PE.docx)
//!
//! ```text
//! SpcStatementType ::= SEQUENCE of OBJECT IDENTIFIER
//! ```
class LIEF_API MsSpcStatementType : public Attribute {

  friend class Parser;
  friend class SignatureParser;

  public:
  MsSpcStatementType() = delete;
  MsSpcStatementType(oid_t oid) :
    Attribute(Attribute::TYPE::MS_SPC_STATEMENT_TYPE),
    oid_{std::move(oid)}
  {}

  MsSpcStatementType(const MsSpcStatementType&) = default;
  MsSpcStatementType& operator=(const MsSpcStatementType&) = default;

  std::unique_ptr<Attribute> clone() const override {
    return std::unique_ptr<Attribute>(new MsSpcStatementType{*this});
  }

  //! According to the documentation:
  //! > The SpcStatementType MUST contain one Object Identifier with either
  //! > the value ``1.3.6.1.4.1.311.2.1.21 (SPC_INDIVIDUAL_SP_KEY_PURPOSE_OBJID)`` or
  //! > ``1.3.6.1.4.1.311.2.1.22 (SPC_COMMERCIAL_SP_KEY_PURPOSE_OBJID)``.
  const oid_t& oid() const {
    return oid_;
  }

  //! Print information about the attribute
  std::string print() const override;

  static bool classof(const Attribute* attr) {
    return attr->type() == Attribute::TYPE::MS_SPC_STATEMENT_TYPE;
  }

  void accept(Visitor& visitor) const override;
  ~MsSpcStatementType() override = default;

  private:
  oid_t oid_;
};

}
}

#endif

```

`KDemu/include/LIEF/LIEF/PE/signature/attributes/PKCS9AtSequenceNumber.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_ATTRIBUTES_PKCS9_AT_SEQUENCE_NUMBER_H
#define LIEF_PE_ATTRIBUTES_PKCS9_AT_SEQUENCE_NUMBER_H

#include "LIEF/visibility.h"
#include "LIEF/PE/signature/Attribute.hpp"

namespace LIEF {
namespace PE {

class Parser;
class SignatureParser;

//! Interface over the structure described by the OID ``1.2.840.113549.1.9.25.4`` (PKCS #9)
//!
//! The internal structure is described in the
//! [RFC #2985: PKCS #9 - Selected Object Classes and Attribute Types Version 2.0](https://tools.ietf.org/html/rfc2985)
//!
//! ```text
//! sequenceNumber ATTRIBUTE ::= {
//!   WITH SYNTAX SequenceNumber
//!   EQUALITY MATCHING RULE integerMatch
//!   SINGLE VALUE TRUE
//!   ID pkcs-9-at-sequenceNumber
//! }
//!
//! SequenceNumber ::= INTEGER (1..MAX)
//! ```
class LIEF_API PKCS9AtSequenceNumber : public Attribute {

  friend class Parser;
  friend class SignatureParser;

  public:
  PKCS9AtSequenceNumber() = delete;
  PKCS9AtSequenceNumber(uint32_t num) :
    Attribute(Attribute::TYPE::PKCS9_AT_SEQUENCE_NUMBER),
    number_{num}
  {}

  PKCS9AtSequenceNumber(const PKCS9AtSequenceNumber&) = default;
  PKCS9AtSequenceNumber& operator=(const PKCS9AtSequenceNumber&) = default;

  std::unique_ptr<Attribute> clone() const override {
    return std::unique_ptr<Attribute>(new PKCS9AtSequenceNumber{*this});
  }

  //! Number as described in the RFC
  uint32_t number() const {
    return number_;
  }

  //! Print information about the attribute
  std::string print() const override;

  static bool classof(const Attribute* attr) {
    return attr->type() == Attribute::TYPE::PKCS9_AT_SEQUENCE_NUMBER;
  }

  void accept(Visitor& visitor) const override;

  ~PKCS9AtSequenceNumber() override = default;

  private:
  uint32_t number_ = 0;
};

}
}

#endif

```

`KDemu/include/LIEF/LIEF/PE/signature/attributes/PKCS9CounterSignature.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_ATTRIBUTES_PKCS9_COUNTER_SIG_H
#define LIEF_PE_ATTRIBUTES_PKCS9_COUNTER_SIG_H

#include "LIEF/visibility.h"
#include "LIEF/PE/signature/Attribute.hpp"
#include "LIEF/PE/signature/SignerInfo.hpp"

namespace LIEF {
class VectorStream;
namespace PE {

//! Interface over the structure described by the OID ``1.2.840.113549.1.9.6`` (PKCS #9)
//!
//! The internal structure is described in the
//! [RFC #2985: PKCS #9 - Selected Object Classes and Attribute Types Version 2.0](https://tools.ietf.org/html/rfc2985)
//!
//! ```text
//! counterSignature ATTRIBUTE ::= {
//!   WITH SYNTAX SignerInfo
//!   ID pkcs-9-at-counterSignature
//! }
//! ```
class LIEF_API PKCS9CounterSignature : public Attribute {

  friend class Parser;
  friend class SignatureParser;

  public:
  PKCS9CounterSignature() = delete;
  PKCS9CounterSignature(SignerInfo signer) :
    Attribute(Attribute::TYPE::PKCS9_COUNTER_SIGNATURE),
    signer_{std::move(signer)}
  {}

  PKCS9CounterSignature(const PKCS9CounterSignature&) = default;
  PKCS9CounterSignature& operator=(const PKCS9CounterSignature&) = default;

  std::unique_ptr<Attribute> clone() const override {
    return std::unique_ptr<Attribute>(new PKCS9CounterSignature{*this});
  }

  //! SignerInfo as described in the RFC #2985
  const SignerInfo& signer() const {
    return this->signer_;
  }

  //! Print information about the attribute
  std::string print() const override;

  static bool classof(const Attribute* attr) {
    return attr->type() == Attribute::TYPE::PKCS9_COUNTER_SIGNATURE;
  }

  void accept(Visitor& visitor) const override;

  ~PKCS9CounterSignature() override = default;

  private:
  SignerInfo signer_;
};

}
}

#endif

```

`KDemu/include/LIEF/LIEF/PE/signature/attributes/PKCS9MessageDigest.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_ATTRIBUTES_PKCS9_MESSAGE_DIGEST_H
#define LIEF_PE_ATTRIBUTES_PKCS9_MESSAGE_DIGEST_H

#include "LIEF/visibility.h"
#include "LIEF/PE/signature/Attribute.hpp"
#include "LIEF/span.hpp"

#include <vector>

namespace LIEF {
namespace PE {

class Parser;
class SignatureParser;

//! Interface over the structure described by the OID ``1.2.840.113549.1.9.4`` (PKCS #9)
//!
//! The internal structure is described in the
//! [RFC #2985: PKCS #9 - Selected Object Classes and Attribute Types Version 2.0](https://tools.ietf.org/html/rfc2985)
//!
//! ```text
//! messageDigest ATTRIBUTE ::= {
//!   WITH SYNTAX MessageDigest
//!   EQUALITY MATCHING RULE octetStringMatch
//!   SINGLE VALUE TRUE
//!   ID pkcs-9-at-messageDigest
//! }
//!
//! MessageDigest ::= OCTET STRING
//! ```
class LIEF_API PKCS9MessageDigest : public Attribute {

  friend class Parser;
  friend class SignatureParser;

  public:
  PKCS9MessageDigest() = delete;
  PKCS9MessageDigest(std::vector<uint8_t> digest) :
    Attribute(Attribute::TYPE::PKCS9_MESSAGE_DIGEST),
    digest_{std::move(digest)}
  {}

  PKCS9MessageDigest(const PKCS9MessageDigest&) = default;
  PKCS9MessageDigest& operator=(const PKCS9MessageDigest&) = default;

  std::unique_ptr<Attribute> clone() const override {
    return std::unique_ptr<Attribute>(new PKCS9MessageDigest{*this});
  }

  //! Message digeset as a blob of bytes as described in the RFC
  span<const uint8_t> digest() const {
    return digest_;
  }

  //! Print information about the attribute
  std::string print() const override;

  static bool classof(const Attribute* attr) {
    return attr->type() == Attribute::TYPE::PKCS9_MESSAGE_DIGEST;
  }

  void accept(Visitor& visitor) const override;

  ~PKCS9MessageDigest() override = default;

  private:
  std::vector<uint8_t> digest_;
};

}
}

#endif

```

`KDemu/include/LIEF/LIEF/PE/signature/attributes/PKCS9SigningTime.hpp`:

```hpp

/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_ATTRIBUTES_PKCS9_SIGNING_TIME_H
#define LIEF_PE_ATTRIBUTES_PKCS9_SIGNING_TIME_H
#include <array>

#include "LIEF/visibility.h"
#include "LIEF/PE/signature/Attribute.hpp"

namespace LIEF {
namespace PE {

//! Interface over the structure described by the OID ``1.2.840.113549.1.9.5`` (PKCS #9)
//!
//! The internal structure is described in the
//! [RFC #2985: PKCS #9 - Selected Object Classes and Attribute Types Version 2.0](https://tools.ietf.org/html/rfc2985)
//!
//! ```text
//! signingTime ATTRIBUTE ::= {
//!         WITH SYNTAX SigningTime
//!         EQUALITY MATCHING RULE signingTimeMatch
//!         SINGLE VALUE TRUE
//!         ID pkcs-9-at-signingTime
//! }
//!
//! SigningTime ::= Time -- imported from ISO/IEC 9594-8
//! ```
class LIEF_API PKCS9SigningTime : public Attribute {

  friend class Parser;
  friend class SignatureParser;

  public:
  //! Time as an array [year, month, day, hour, min, sec]
  using time_t = std::array<int32_t, 6>;

  PKCS9SigningTime() = delete;
  PKCS9SigningTime(time_t time) :
    Attribute(Attribute::TYPE::PKCS9_SIGNING_TIME),
    time_{time}
  {}

  PKCS9SigningTime(const PKCS9SigningTime&) = default;
  PKCS9SigningTime& operator=(const PKCS9SigningTime&) = default;

  //! Time as an array [year, month, day, hour, min, sec]
  const time_t& time() const {
    return time_;
  }

  //! Print information about the attribute
  std::string print() const override;

  std::unique_ptr<Attribute> clone() const override {
    return std::unique_ptr<Attribute>(new PKCS9SigningTime{*this});
  }

  static bool classof(const Attribute* attr) {
    return attr->type() == Attribute::TYPE::PKCS9_SIGNING_TIME;
  }

  void accept(Visitor& visitor) const override;

  ~PKCS9SigningTime() override = default;

  private:
  time_t time_;
};

}
}

#endif

```

`KDemu/include/LIEF/LIEF/PE/signature/attributes/SigningCertificateV2.hpp`:

```hpp
/* Copyright 2017 - 2023 R. Thomas
 * Copyright 2017 - 2023 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_ATTRIBUTES_SIGNING_CERTIFICATE_V2_H
#define LIEF_PE_ATTRIBUTES_SIGNING_CERTIFICATE_V2_H

#include "LIEF/visibility.h"
#include "LIEF/PE/signature/Attribute.hpp"

namespace LIEF {
namespace PE {
//! SigningCertificateV2 ::= SEQUENCE {
//!   certs    SEQUENCE OF ESSCertIDv2,
//!   policies SEQUENCE OF PolicyInformation OPTIONAL
//! }
//!
//! ESSCertIDv2 ::= SEQUENCE {
//!   hashAlgorithm AlgorithmIdentifier DEFAULT {algorithm id-sha256},
//!   certHash      OCTET STRING,
//!   issuerSerial  IssuerSerial OPTIONAL
//! }
//!
//! IssuerSerial ::= SEQUENCE {
//!   issuer       GeneralNames,
//!   serialNumber CertificateSerialNumber
//! }
//!
//! PolicyInformation ::= SEQUENCE {
//!   policyIdentifier   OBJECT IDENTIFIER,
//!   policyQualifiers   SEQUENCE SIZE (1..MAX) OF PolicyQualifierInfo OPTIONAL
//! }
class LIEF_API SigningCertificateV2 : public Attribute {
  friend class Parser;
  friend class SignatureParser;

  public:
  SigningCertificateV2() :
    Attribute(Attribute::TYPE::SIGNING_CERTIFICATE_V2)
  {}
  SigningCertificateV2(const SigningCertificateV2&) = default;
  SigningCertificateV2& operator=(const SigningCertificateV2&) = default;

  std::unique_ptr<Attribute> clone() const override {
    return std::unique_ptr<Attribute>(new SigningCertificateV2{*this});
  }

  static bool classof(const Attribute* attr) {
    return attr->type() == Attribute::TYPE::SIGNING_CERTIFICATE_V2;
  }

  std::string print() const override;

  void accept(Visitor& visitor) const override;

  ~SigningCertificateV2() override = default;
};

}
}

#endif

```

`KDemu/include/LIEF/LIEF/PE/signature/attributes/SpcRelaxedPeMarkerCheck.hpp`:

```hpp
/* Copyright 2017 - 2023 R. Thomas
 * Copyright 2017 - 2023 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_ATTRIBUTES_SPC_RELAXED_PE_MARKER_CHECK_H
#define LIEF_PE_ATTRIBUTES_SPC_RELAXED_PE_MARKER_CHECK_H

#include "LIEF/visibility.h"
#include "LIEF/PE/signature/Attribute.hpp"

namespace LIEF {
namespace PE {

class LIEF_API SpcRelaxedPeMarkerCheck : public Attribute {
  friend class Parser;
  friend class SignatureParser;

  public:
  SpcRelaxedPeMarkerCheck() :
    SpcRelaxedPeMarkerCheck(0)
  {}

  SpcRelaxedPeMarkerCheck(uint32_t value) :
    Attribute(Attribute::TYPE::SPC_RELAXED_PE_MARKER_CHECK),
    value_(value)
  {}

  SpcRelaxedPeMarkerCheck(const SpcRelaxedPeMarkerCheck&) = default;
  SpcRelaxedPeMarkerCheck& operator=(const SpcRelaxedPeMarkerCheck&) = default;

  uint32_t value() const {
    return value_;
  }

  void value(uint32_t v) {
    value_ = v;
  }

  std::unique_ptr<Attribute> clone() const override {
    return std::unique_ptr<Attribute>(new SpcRelaxedPeMarkerCheck{*this});
  }

  std::string print() const override {
    return "value=" + std::to_string(value_);
  }

  static bool classof(const Attribute* attr) {
    return attr->type() == Attribute::TYPE::SPC_RELAXED_PE_MARKER_CHECK;
  }

  void accept(Visitor& visitor) const override;

  ~SpcRelaxedPeMarkerCheck() override = default;

  private:
  uint32_t value_ = 0;
};

}
}

#endif

```

`KDemu/include/LIEF/LIEF/PE/signature/attributes/SpcSpOpusInfo.hpp`:

```hpp

/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_ATTRIBUTES_SPC_SP_OPUS_INFO_H
#define LIEF_PE_ATTRIBUTES_SPC_SP_OPUS_INFO_H
#include <memory>

#include "LIEF/visibility.h"
#include "LIEF/PE/signature/Attribute.hpp"


namespace LIEF {
namespace PE {

//! Interface over the structure described by the OID ``1.3.6.1.4.1.311.2.1.12``
//!
//! The internal structure is described in the official document:
//! [Windows Authenticode Portable Executable Signature Format](http://download.microsoft.com/download/9/c/5/9c5b2167-8017-4bae-9fde-d599bac8184a/Authenticode_PE.docx)
//!
//! ```text
//! SpcSpOpusInfo ::= SEQUENCE {
//!     programName  [0] EXPLICIT SpcString OPTIONAL,
//!     moreInfo     [1] EXPLICIT SpcLink OPTIONAL
//! }
//! ```
class LIEF_API SpcSpOpusInfo : public Attribute {

  friend class Parser;
  friend class SignatureParser;

  public:
  SpcSpOpusInfo(std::string program_name, std::string more_info) :
    Attribute(Attribute::TYPE::SPC_SP_OPUS_INFO),
    program_name_(std::move(program_name)),
    more_info_(std::move(more_info))
  {}

  SpcSpOpusInfo() :
    SpcSpOpusInfo("", "")
  {}

  SpcSpOpusInfo(const SpcSpOpusInfo&) = default;
  SpcSpOpusInfo& operator=(const SpcSpOpusInfo&) = default;

  std::unique_ptr<Attribute> clone() const override {
    return std::unique_ptr<Attribute>(new SpcSpOpusInfo{*this});
  }

  //! Program description provided by the publisher
  const std::string& program_name() const {
    return program_name_;
  }

  //! Other information such as an url
  const std::string& more_info() const {
    return more_info_;
  }

  //! Print information about the attribute
  std::string print() const override;

  static bool classof(const Attribute* attr) {
    return attr->type() == Attribute::TYPE::SPC_SP_OPUS_INFO;
  }

  void accept(Visitor& visitor) const override;

  ~SpcSpOpusInfo() override = default;

  private:
  std::string program_name_;
  std::string more_info_;
};

}
}

#endif

```

`KDemu/include/LIEF/LIEF/PE/signature/types.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_SIGNATURE_TYPES_H
#define LIEF_PE_SIGNATURE_TYPES_H
#include <string>

namespace LIEF {
namespace PE {

using oid_t = std::string;


}
}

#endif

```

`KDemu/include/LIEF/LIEF/PE/signature/x509.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_X509_H
#define LIEF_PE_X509_H
#include <array>
#include <memory>
#include <vector>

#include "LIEF/Object.hpp"
#include "LIEF/visibility.h"

#include "LIEF/PE/enums.hpp"

#include "LIEF/PE/signature/types.hpp"

#include "LIEF/enums.hpp"

struct mbedtls_x509_crt;

namespace LIEF {
namespace PE {

class Parser;
class SignatureParser;
class Signature;

class RsaInfo;

//! Interface over a x509 certificate
class LIEF_API x509 : public Object {

  friend class Parser;
  friend class SignatureParser;
  friend class Signature;

  public:
  //! Tuple (Year, Month, Day, Hour, Minute, Second)
  using date_t = std::array<int32_t, 6>;

  using certificates_t = std::vector<x509>;

  //! Parse x509 certificate(s) from file path
  static certificates_t parse(const std::string& path);

  //! Parse x509 certificate(s) from raw blob
  static certificates_t parse(const std::vector<uint8_t>& content);

  //! Return True if ``before`` is *before* than ``after``. False otherwise
  static bool check_time(const date_t& before, const date_t& after);

  //! True if the given time is in the **past** according to the clock's system
  static bool time_is_past(const date_t& to);

  //! True if the given time is in the future according to the clock's system
  static bool time_is_future(const date_t& from);

  //! Public key scheme
  enum class KEY_TYPES : uint32_t {
    NONE = 0,    ///< Unknown scheme
    RSA,         ///< RSA Scheme
    ECKEY,       ///< Elliptic-curve scheme
    ECKEY_DH,    ///< Elliptic-curve Diffie-Hellman
    ECDSA,       ///< Elliptic-curve Digital Signature Algorithm
    RSA_ALT,     ///< RSA scheme with an alternative implementation for signing and decrypting
    RSASSA_PSS,  ///< RSA Probabilistic signature scheme
  };

  //! Mirror of mbedtls's X509 Verify codes: MBEDTLS_X509_XX
  //!
  //! It must be sync with include/mbedtls/x509.h
  enum class VERIFICATION_FLAGS : uint32_t {
    OK                     = 0,       /**< The verification succeed  */
    BADCERT_EXPIRED        = 1 << 0,  /**< The certificate validity has expired. */
    BADCERT_REVOKED        = 1 << 1,  /**< The certificate has been revoked (is on a CRL). */
    BADCERT_CN_MISMATCH    = 1 << 2,  /**< The certificate Common Name (CN) does not match with the expected CN. */
    BADCERT_NOT_TRUSTED    = 1 << 3,  /**< The certificate is not correctly signed by the trusted CA. */
    BADCRL_NOT_TRUSTED     = 1 << 4,  /**< The CRL is not correctly signed by the trusted CA. */
    BADCRL_EXPIRED         = 1 << 5,  /**< The CRL is expired. */
    BADCERT_MISSING        = 1 << 6,  /**< Certificate was missing. */
    BADCERT_SKIP_VERIFY    = 1 << 7,  /**< Certificate verification was skipped. */
    BADCERT_OTHER          = 1 << 8,  /**< Other reason (can be used by verify callback) */
    BADCERT_FUTURE         = 1 << 9,  /**< The certificate validity starts in the future. */
    BADCRL_FUTURE          = 1 << 10, /**< The CRL is from the future */
    BADCERT_KEY_USAGE      = 1 << 11, /**< Usage does not match the keyUsage extension. */
    BADCERT_EXT_KEY_USAGE  = 1 << 12, /**< Usage does not match the extendedKeyUsage extension. */
    BADCERT_NS_CERT_TYPE   = 1 << 13, /**< Usage does not match the nsCertType extension. */
    BADCERT_BAD_MD         = 1 << 14, /**< The certificate is signed with an unacceptable hash. */
    BADCERT_BAD_PK         = 1 << 15, /**< The certificate is signed with an unacceptable PK alg (eg RSA vs ECDSA). */
    BADCERT_BAD_KEY        = 1 << 16, /**< The certificate is signed with an unacceptable key (eg bad curve, RSA too short). */
    BADCRL_BAD_MD          = 1 << 17, /**< The CRL is signed with an unacceptable hash. */
    BADCRL_BAD_PK          = 1 << 18, /**< The CRL is signed with an unacceptable PK alg (eg RSA vs ECDSA). */
    BADCRL_BAD_KEY         = 1 << 19, /**< The CRL is signed with an unacceptable key (eg bad curve, RSA too short). */
  };

  //! Key usage as defined in [RFC #5280 - section-4.2.1.3](https://tools.ietf.org/html/rfc5280#section-4.2.1.3)
  enum class KEY_USAGE : uint32_t {
    DIGITAL_SIGNATURE = 0, /**< The key is used for digital signature */
    NON_REPUDIATION,       /**< The key is used for digital signature AND to protects against falsely denying some action */
    KEY_ENCIPHERMENT,      /**< The key is used for enciphering private or secret keys */
    DATA_ENCIPHERMENT,     /**< The key is used for directly enciphering raw user data without the use of an intermediate symmetric cipher */
    KEY_AGREEMENT,         /**< The Key is used for key agreement. (e.g. with Diffie-Hellman) */
    KEY_CERT_SIGN,         /**< The key is used for verifying signatures on public key certificates */
    CRL_SIGN,              /**< The key is used for verifying signatures on certificate revocation lists */
    ENCIPHER_ONLY,         /**< In **association with** KEY_AGREEMENT (otherwise the meaning is undefined), the key is only used for enciphering data while performing key agreement */
    DECIPHER_ONLY,         /**< In **association with** KEY_AGREEMENT (otherwise the meaning is undefined), the key is only used for deciphering data while performing key agreement */
  };

  x509(mbedtls_x509_crt* ca);
  x509(const x509& other);
  x509& operator=(x509 other);
  void swap(x509& other);

  //! X.509 version. (1=v1, 2=v2, 3=v3)
  uint32_t version() const;

  //! Unique id for certificate issued by a specific CA.
  std::vector<uint8_t> serial_number() const;

  //! Signature algorithm (OID)
  oid_t signature_algorithm() const;

  //! Start time of certificate validity
  date_t valid_from() const;

  //! End time of certificate validity
  date_t valid_to() const;

  //! Issuer informations
  std::string issuer() const;

  //! Subject informations
  std::string subject() const;

  //! Try to decrypt the given signature and check if it matches the given hash according to
  //! the hash algorithm provided
  bool check_signature(const std::vector<uint8_t>& hash,
                       const std::vector<uint8_t>& signature, ALGORITHMS digest) const;

  //! The raw x509 bytes (DER encoded)
  std::vector<uint8_t> raw() const;

  //! Return the underlying public-key scheme
  KEY_TYPES key_type() const;

  //! **If** the underlying public-key scheme is RSA, return the RSA information.
  //! Otherwise, return a nullptr
  std::unique_ptr<RsaInfo> rsa_info() const;

  //! Verify that this certificate has been used **to trust** the given certificate
  VERIFICATION_FLAGS verify(const x509& ca) const;

  //! Verify that this certificate **is trusted** by the given CA list
  VERIFICATION_FLAGS is_trusted_by(const std::vector<x509>& ca) const;

  //! Policy information terms as OID (see RFC #5280)
  std::vector<oid_t> certificate_policies() const;

  //! Purpose of the key contained in the certificate
  std::vector<KEY_USAGE> key_usage() const;

  //! Indicates one or more purposes for which the certified public key may be used (OID types)
  std::vector<oid_t> ext_key_usage() const;

  bool is_ca() const;

  //! The signature of the certificate
  std::vector<uint8_t> signature() const;

  void accept(Visitor& visitor) const override;

  ~x509() override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const x509& x509_cert);

  private:
  x509();
  mbedtls_x509_crt* x509_cert_ = nullptr;

};

}
}

ENABLE_BITMASK_OPERATORS(LIEF::PE::x509::VERIFICATION_FLAGS)

#endif

```

`KDemu/include/LIEF/LIEF/PE/undef.h`:

```h
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 * Copyright 2017 - 2021 K. Nakagawa
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#if !defined(LIEF_PE_UNDEF_H) || defined(LIEF_PE_FORCE_UNDEF)
#define LIEF_PE_UNDEF_H

#ifdef IMAGE_FILE_MACHINE_UNKNOWN
#pragma message("LIEF will disable #define enums. Please use LIEF_PE_XXXX or LIEF::PE::XXXX instead!")
#endif

#undef IMAGE_FILE_MACHINE_UNKNOWN
#undef IMAGE_FILE_MACHINE_AM33
#undef IMAGE_FILE_MACHINE_AMD64
#undef IMAGE_FILE_MACHINE_ARM
#undef IMAGE_FILE_MACHINE_ARMNT
#undef IMAGE_FILE_MACHINE_ARM64
#undef IMAGE_FILE_MACHINE_EBC
#undef IMAGE_FILE_MACHINE_I386
#undef IMAGE_FILE_MACHINE_IA64
#undef IMAGE_FILE_MACHINE_M32R
#undef IMAGE_FILE_MACHINE_MIPS16
#undef IMAGE_FILE_MACHINE_MIPSFPU
#undef IMAGE_FILE_MACHINE_MIPSFPU16
#undef IMAGE_FILE_MACHINE_POWERPC
#undef IMAGE_FILE_MACHINE_POWERPCFP
#undef IMAGE_FILE_MACHINE_R4000
#undef IMAGE_FILE_MACHINE_RISCV32
#undef IMAGE_FILE_MACHINE_RISCV64
#undef IMAGE_FILE_MACHINE_RISCV128
#undef IMAGE_FILE_MACHINE_SH3
#undef IMAGE_FILE_MACHINE_SH3DSP
#undef IMAGE_FILE_MACHINE_SH4
#undef IMAGE_FILE_MACHINE_SH5
#undef IMAGE_FILE_MACHINE_THUMB
#undef IMAGE_FILE_MACHINE_WCEMIPSV2

#undef IMAGE_SYM_DEBUG
#undef IMAGE_SYM_ABSOLUTE
#undef IMAGE_SYM_UNDEFINED


#undef IMAGE_FILE_INVALID
#undef IMAGE_FILE_RELOCS_STRIPPED
#undef IMAGE_FILE_EXECUTABLE_IMAGE
#undef IMAGE_FILE_LINE_NUMS_STRIPPED
#undef IMAGE_FILE_LOCAL_SYMS_STRIPPED
#undef IMAGE_FILE_AGGRESSIVE_WS_TRIM
#undef IMAGE_FILE_LARGE_ADDRESS_AWARE
#undef IMAGE_FILE_BYTES_REVERSED_LO
#undef IMAGE_FILE_32BIT_MACHINE
#undef IMAGE_FILE_DEBUG_STRIPPED
#undef IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP
#undef IMAGE_FILE_NET_RUN_FROM_SWAP
#undef IMAGE_FILE_SYSTEM
#undef IMAGE_FILE_DLL
#undef IMAGE_FILE_UP_SYSTEM_ONLY
#undef IMAGE_FILE_BYTES_REVERSED_HI

#undef IMAGE_SYM_CLASS_END_OF_FUNCTION
#undef IMAGE_SYM_CLASS_NULL
#undef IMAGE_SYM_CLASS_AUTOMATIC
#undef IMAGE_SYM_CLASS_EXTERNAL
#undef IMAGE_SYM_CLASS_STATIC
#undef IMAGE_SYM_CLASS_REGISTER
#undef IMAGE_SYM_CLASS_EXTERNAL_DEF
#undef IMAGE_SYM_CLASS_LABEL
#undef IMAGE_SYM_CLASS_UNDEFINED_LABEL
#undef IMAGE_SYM_CLASS_MEMBER_OF_STRUCT
#undef IMAGE_SYM_CLASS_ARGUMENT
#undef IMAGE_SYM_CLASS_STRUCT_TAG
#undef IMAGE_SYM_CLASS_MEMBER_OF_UNION
#undef IMAGE_SYM_CLASS_UNION_TAG
#undef IMAGE_SYM_CLASS_TYPE_DEFINITION
#undef IMAGE_SYM_CLASS_UNDEFINED_STATIC
#undef IMAGE_SYM_CLASS_ENUM_TAG
#undef IMAGE_SYM_CLASS_MEMBER_OF_ENUM
#undef IMAGE_SYM_CLASS_REGISTER_PARAM
#undef IMAGE_SYM_CLASS_BIT_FIELD
#undef IMAGE_SYM_CLASS_BLOCK
#undef IMAGE_SYM_CLASS_FUNCTION
#undef IMAGE_SYM_CLASS_END_OF_STRUCT
#undef IMAGE_SYM_CLASS_FILE
#undef IMAGE_SYM_CLASS_SECTION
#undef IMAGE_SYM_CLASS_WEAK_EXTERNAL
#undef IMAGE_SYM_CLASS_CLR_TOKEN

#undef IMAGE_SYM_TYPE_NULL
#undef IMAGE_SYM_TYPE_VOID
#undef IMAGE_SYM_TYPE_CHAR
#undef IMAGE_SYM_TYPE_SHORT
#undef IMAGE_SYM_TYPE_INT
#undef IMAGE_SYM_TYPE_LONG
#undef IMAGE_SYM_TYPE_FLOAT
#undef IMAGE_SYM_TYPE_DOUBLE
#undef IMAGE_SYM_TYPE_STRUCT
#undef IMAGE_SYM_TYPE_UNION
#undef IMAGE_SYM_TYPE_ENUM
#undef IMAGE_SYM_TYPE_MOE
#undef IMAGE_SYM_TYPE_BYTE
#undef IMAGE_SYM_TYPE_WORD
#undef IMAGE_SYM_TYPE_UINT
#undef IMAGE_SYM_TYPE_DWORD



#undef IMAGE_SYM_DTYPE_NULL
#undef IMAGE_SYM_DTYPE_POINTER
#undef IMAGE_SYM_DTYPE_FUNCTION
#undef IMAGE_SYM_DTYPE_ARRAY
#undef SCT_COMPLEX_TYPE_SHIFT

#undef IMAGE_REL_BASED_ABSOLUTE
#undef IMAGE_REL_BASED_HIGH
#undef IMAGE_REL_BASED_LOW
#undef IMAGE_REL_BASED_HIGHLOW
#undef IMAGE_REL_BASED_HIGHADJ
#undef IMAGE_REL_BASED_MIPS_JMPADDR
#undef IMAGE_REL_BASED_SECTION
#undef IMAGE_REL_BASED_REL
#undef IMAGE_REL_BASED_MIPS_JMPADDR16
#undef IMAGE_REL_BASED_IA64_IMM64
#undef IMAGE_REL_BASED_DIR64
#undef IMAGE_REL_BASED_HIGH3ADJ

#undef IMAGE_REL_I386_ABSOLUTE
#undef IMAGE_REL_I386_DIR16
#undef IMAGE_REL_I386_REL16
#undef IMAGE_REL_I386_DIR32
#undef IMAGE_REL_I386_DIR32NB
#undef IMAGE_REL_I386_SEG12
#undef IMAGE_REL_I386_SECTION
#undef IMAGE_REL_I386_SECREL
#undef IMAGE_REL_I386_TOKEN
#undef IMAGE_REL_I386_SECREL7
#undef IMAGE_REL_I386_REL32
#undef IMAGE_REL_BASED_ARM_MOV32A
#undef IMAGE_REL_BASED_ARM_MOV32
#undef IMAGE_REL_BASED_RISCV_HI20
#undef IMAGE_REL_BASED_ARM_MOV32T
#undef IMAGE_REL_BASED_THUMB_MOV32
#undef IMAGE_REL_BASED_RISCV_LOW12I
#undef IMAGE_REL_BASED_RISCV_LOW12S

#undef IMAGE_REL_AMD64_ABSOLUTE
#undef IMAGE_REL_AMD64_ADDR64
#undef IMAGE_REL_AMD64_ADDR32
#undef IMAGE_REL_AMD64_ADDR32NB
#undef IMAGE_REL_AMD64_REL32
#undef IMAGE_REL_AMD64_REL32_1
#undef IMAGE_REL_AMD64_REL32_2
#undef IMAGE_REL_AMD64_REL32_3
#undef IMAGE_REL_AMD64_REL32_4
#undef IMAGE_REL_AMD64_REL32_5
#undef IMAGE_REL_AMD64_SECTION
#undef IMAGE_REL_AMD64_SECREL
#undef IMAGE_REL_AMD64_SECREL7
#undef IMAGE_REL_AMD64_TOKEN
#undef IMAGE_REL_AMD64_SREL32
#undef IMAGE_REL_AMD64_PAIR
#undef IMAGE_REL_AMD64_SSPAN32

#undef IMAGE_REL_ARM_ABSOLUTE
#undef IMAGE_REL_ARM_ADDR32
#undef IMAGE_REL_ARM_ADDR32NB
#undef IMAGE_REL_ARM_BRANCH24
#undef IMAGE_REL_ARM_BRANCH11
#undef IMAGE_REL_ARM_TOKEN
#undef IMAGE_REL_ARM_BLX24
#undef IMAGE_REL_ARM_BLX11
#undef IMAGE_REL_ARM_SECTION
#undef IMAGE_REL_ARM_SECREL
#undef IMAGE_REL_ARM_MOV32A
#undef IMAGE_REL_ARM_MOV32T
#undef IMAGE_REL_ARM_BRANCH20T
#undef IMAGE_REL_ARM_BRANCH24T
#undef IMAGE_REL_ARM_BLX23T


#undef IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY
#undef IMAGE_WEAK_EXTERN_SEARCH_LIBRARY
#undef IMAGE_WEAK_EXTERN_SEARCH_ALIAS


#undef EXPORT_TABLE
#undef IMPORT_TABLE
#undef RESOURCE_TABLE
#undef EXCEPTION_TABLE
#undef CERTIFICATE_TABLE
#undef BASE_RELOCATION_TABLE
#undef DEBUG
#undef ARCHITECTURE
#undef GLOBAL_PTR
#undef TLS_TABLE
#undef LOAD_CONFIG_TABLE
#undef BOUND_IMPORT
#undef IAT
#undef DELAY_IMPORT_DESCRIPTOR
#undef CLR_RUNTIME_HEADER
#undef NUM_DATA_DIRECTORIES

#undef IMAGE_SUBSYSTEM_UNKNOWN
#undef IMAGE_SUBSYSTEM_NATIVE
#undef IMAGE_SUBSYSTEM_WINDOWS_GUI
#undef IMAGE_SUBSYSTEM_WINDOWS_CUI
#undef IMAGE_SUBSYSTEM_OS2_CUI
#undef IMAGE_SUBSYSTEM_POSIX_CUI
#undef IMAGE_SUBSYSTEM_NATIVE_WINDOWS
#undef IMAGE_SUBSYSTEM_WINDOWS_CE_GUI
#undef IMAGE_SUBSYSTEM_EFI_APPLICATION
#undef IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER
#undef IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER
#undef IMAGE_SUBSYSTEM_EFI_ROM
#undef IMAGE_SUBSYSTEM_XBOX
#undef IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION



#undef IMAGE_DLL_CHARACTERISTICS_HIGH_ENTROPY_VA
#undef IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE
#undef IMAGE_DLL_CHARACTERISTICS_FORCE_INTEGRITY
#undef IMAGE_DLL_CHARACTERISTICS_NX_COMPAT
#undef IMAGE_DLL_CHARACTERISTICS_NO_ISOLATION
#undef IMAGE_DLL_CHARACTERISTICS_NO_SEH
#undef IMAGE_DLL_CHARACTERISTICS_NO_BIND
#undef IMAGE_DLL_CHARACTERISTICS_APPCONTAINER
#undef IMAGE_DLL_CHARACTERISTICS_WDM_DRIVER
#undef IMAGE_DLL_CHARACTERISTICS_GUARD_CF
#undef IMAGE_DLL_CHARACTERISTICS_TERMINAL_SERVER_AWARE

#undef IMAGE_DEBUG_TYPE_UNKNOWN
#undef IMAGE_DEBUG_TYPE_COFF
#undef IMAGE_DEBUG_TYPE_CODEVIEW
#undef IMAGE_DEBUG_TYPE_FPO
#undef IMAGE_DEBUG_TYPE_MISC
#undef IMAGE_DEBUG_TYPE_EXCEPTION
#undef IMAGE_DEBUG_TYPE_FIXUP
#undef IMAGE_DEBUG_TYPE_OMAP_TO_SRC
#undef IMAGE_DEBUG_TYPE_OMAP_FROM_SRC
#undef IMAGE_DEBUG_TYPE_BORLAND
#undef IMAGE_DEBUG_TYPE_RESERVED10
#undef IMAGE_DEBUG_TYPE_CLSID
#undef IMAGE_DEBUG_TYPE_VC_FEATURE
#undef IMAGE_DEBUG_TYPE_POGO
#undef IMAGE_DEBUG_TYPE_ILTCG
#undef IMAGE_DEBUG_TYPE_MPX
#undef IMAGE_DEBUG_TYPE_REPRO
#undef IMAGE_DEBUG_TYPE_EX_DLLCHARACTERISTICS

#undef IMAGE_SCN_TYPE_NO_PAD
#undef IMAGE_SCN_CNT_CODE
#undef IMAGE_SCN_CNT_INITIALIZED_DATA
#undef IMAGE_SCN_CNT_UNINITIALIZED_DATA
#undef IMAGE_SCN_LNK_OTHER
#undef IMAGE_SCN_LNK_INFO
#undef IMAGE_SCN_LNK_REMOVE
#undef IMAGE_SCN_LNK_COMDAT
#undef IMAGE_SCN_GPREL
#undef IMAGE_SCN_MEM_PURGEABLE
#undef IMAGE_SCN_MEM_16BIT
#undef IMAGE_SCN_MEM_LOCKED
#undef IMAGE_SCN_MEM_PRELOAD
#undef IMAGE_SCN_ALIGN_1BYTES
#undef IMAGE_SCN_ALIGN_2BYTES
#undef IMAGE_SCN_ALIGN_4BYTES
#undef IMAGE_SCN_ALIGN_8BYTES
#undef IMAGE_SCN_ALIGN_16BYTES
#undef IMAGE_SCN_ALIGN_32BYTES
#undef IMAGE_SCN_ALIGN_64BYTES
#undef IMAGE_SCN_ALIGN_128BYTES
#undef IMAGE_SCN_ALIGN_256BYTES
#undef IMAGE_SCN_ALIGN_512BYTES
#undef IMAGE_SCN_ALIGN_1024BYTES
#undef IMAGE_SCN_ALIGN_2048BYTES
#undef IMAGE_SCN_ALIGN_4096BYTES
#undef IMAGE_SCN_ALIGN_8192BYTES
#undef IMAGE_SCN_LNK_NRELOC_OVFL
#undef IMAGE_SCN_MEM_DISCARDABLE
#undef IMAGE_SCN_MEM_NOT_CACHED
#undef IMAGE_SCN_MEM_NOT_PAGED
#undef IMAGE_SCN_MEM_SHARED
#undef IMAGE_SCN_MEM_EXECUTE
#undef IMAGE_SCN_MEM_READ
#undef IMAGE_SCN_MEM_WRITE

#undef RESOURCE_LANGS


#undef LANG_NEUTRAL
#undef LANG_INVARIANT
#undef LANG_AFRIKAANS
#undef LANG_ALBANIAN
#undef LANG_ARABIC
#undef LANG_ARMENIAN
#undef LANG_ASSAMESE
#undef LANG_AZERI
#undef LANG_BASQUE
#undef LANG_BELARUSIAN
#undef LANG_BENGALI
#undef LANG_BANGLA
#undef LANG_BULGARIAN
#undef LANG_CATALAN
#undef LANG_CHINESE
#undef LANG_CROATIAN
#undef LANG_BOSNIAN
#undef LANG_CZECH
#undef LANG_DANISH
#undef LANG_DIVEHI
#undef LANG_DUTCH
#undef LANG_ENGLISH
#undef LANG_ESTONIAN
#undef LANG_FAEROESE
#undef LANG_FARSI
#undef LANG_FINNISH
#undef LANG_FRENCH
#undef LANG_GALICIAN
#undef LANG_GEORGIAN
#undef LANG_GERMAN
#undef LANG_GREEK
#undef LANG_GUJARATI
#undef LANG_HEBREW
#undef LANG_HINDI
#undef LANG_HUNGARIAN
#undef LANG_ICELANDIC
#undef LANG_INDONESIAN
#undef LANG_ITALIAN
#undef LANG_JAPANESE
#undef LANG_KANNADA
#undef LANG_KASHMIRI
#undef LANG_KAZAK
#undef LANG_KONKANI
#undef LANG_KOREAN
#undef LANG_KYRGYZ
#undef LANG_LATVIAN
#undef LANG_LITHUANIAN
#undef LANG_MACEDONIAN
#undef LANG_MALAY
#undef LANG_MALAYALAM
#undef LANG_MANIPURI
#undef LANG_MARATHI
#undef LANG_MONGOLIAN
#undef LANG_NEPALI
#undef LANG_NORWEGIAN
#undef LANG_ORIYA
#undef LANG_POLISH
#undef LANG_PORTUGUESE
#undef LANG_PUNJABI
#undef LANG_ROMANIAN
#undef LANG_RUSSIAN
#undef LANG_SANSKRIT
#undef LANG_SERBIAN
#undef LANG_SINDHI
#undef LANG_SLOVAK
#undef LANG_SLOVENIAN
#undef LANG_SPANISH
#undef LANG_SWAHILI
#undef LANG_SWEDISH
#undef LANG_SYRIAC
#undef LANG_TAMIL
#undef LANG_TATAR
#undef LANG_TELUGU
#undef LANG_THAI
#undef LANG_TURKISH
#undef LANG_UKRAINIAN
#undef LANG_URDU
#undef LANG_UZBEK
#undef LANG_VIETNAMESE
#undef LANG_GAELIC
#undef LANG_MALTESE
#undef LANG_MAORI
#undef LANG_RHAETO_ROMANCE
#undef LANG_SAMI
#undef LANG_SORBIAN
#undef LANG_SUTU
#undef LANG_TSONGA
#undef LANG_TSWANA
#undef LANG_VENDA
#undef LANG_XHOSA
#undef LANG_ZULU
#undef LANG_ESPERANTO
#undef LANG_WALON
#undef LANG_CORNISH
#undef LANG_WELSH
#undef LANG_BRETON
#undef LANG_INUKTITUT
#undef LANG_IRISH
#undef LANG_LOWER_SORBIAN
#undef LANG_PULAR
#undef LANG_QUECHUA
#undef LANG_TAMAZIGHT
#undef LANG_TIGRINYA
#undef LANG_VALENCIAN



#undef SUBLANG_AFRIKAANS_SOUTH_AFRICA
#undef SUBLANG_ALBANIAN_ALBANIA
#undef SUBLANG_ALSATIAN_FRANCE
#undef SUBLANG_AMHARIC_ETHIOPIA
#undef SUBLANG_ARABIC_ALGERIA
#undef SUBLANG_ARABIC_BAHRAIN
#undef SUBLANG_ARABIC_EGYPT
#undef SUBLANG_ARABIC_IRAQ
#undef SUBLANG_ARABIC_JORDAN
#undef SUBLANG_ARABIC_KUWAIT
#undef SUBLANG_ARABIC_LEBANON
#undef SUBLANG_ARABIC_LIBYA
#undef SUBLANG_ARABIC_MOROCCO
#undef SUBLANG_ARABIC_OMAN
#undef SUBLANG_ARABIC_QATAR
#undef SUBLANG_ARABIC_SAUDI_ARABIA
#undef SUBLANG_ARABIC_SYRIA
#undef SUBLANG_ARABIC_TUNISIA
#undef SUBLANG_ARABIC_UAE
#undef SUBLANG_ARABIC_YEMEN
#undef SUBLANG_ARMENIAN_ARMENIA
#undef SUBLANG_ASSAMESE_INDIA
#undef SUBLANG_AZERI_CYRILLIC
#undef SUBLANG_AZERI_LATIN
#undef SUBLANG_BASHKIR_RUSSIA
#undef SUBLANG_BASQUE_BASQUE
#undef SUBLANG_BELARUSIAN_BELARUS
#undef SUBLANG_BANGLA_BANGLADESH
#undef SUBLANG_BANGLA_INDIA
#undef SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_CYRILLIC
#undef SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_LATIN
#undef SUBLANG_BRETON_FRANCE
#undef SUBLANG_BULGARIAN_BULGARIA
#undef SUBLANG_CATALAN_CATALAN
#undef SUBLANG_CHINESE_HONGKONG
#undef SUBLANG_CHINESE_MACAU
#undef SUBLANG_CHINESE_SIMPLIFIED
#undef SUBLANG_CHINESE_SINGAPORE
#undef SUBLANG_CHINESE_TRADITIONAL
#undef SUBLANG_CORSICAN_FRANCE
#undef SUBLANG_CROATIAN_BOSNIA_HERZEGOVINA_LATIN
#undef SUBLANG_CROATIAN_CROATIA
#undef SUBLANG_CUSTOM_DEFAULT
#undef SUBLANG_CUSTOM_UNSPECIFIED
#undef SUBLANG_CZECH_CZECH_REPUBLIC
#undef SUBLANG_DANISH_DENMARK
#undef SUBLANG_DARI_AFGHANISTAN
#undef SUBLANG_DEFAULT
#undef SUBLANG_DIVEHI_MALDIVES
#undef SUBLANG_DUTCH_BELGIAN
#undef SUBLANG_DUTCH
#undef SUBLANG_ENGLISH_AUS
#undef SUBLANG_ENGLISH_BELIZE
#undef SUBLANG_ENGLISH_CAN
#undef SUBLANG_ENGLISH_CARIBBEAN
#undef SUBLANG_ENGLISH_EIRE
#undef SUBLANG_ENGLISH_INDIA
#undef SUBLANG_ENGLISH_JAMAICA
#undef SUBLANG_ENGLISH_MALAYSIA
#undef SUBLANG_ENGLISH_NZ
#undef SUBLANG_ENGLISH_PHILIPPINES
#undef SUBLANG_ENGLISH_SINGAPORE
#undef SUBLANG_ENGLISH_SOUTH_AFRICA
#undef SUBLANG_ENGLISH_TRINIDAD
#undef SUBLANG_ENGLISH_UK
#undef SUBLANG_ENGLISH_US
#undef SUBLANG_ENGLISH_ZIMBABWE
#undef SUBLANG_ENGLISH_IRELAND
#undef SUBLANG_ESTONIAN_ESTONIA
#undef SUBLANG_FAEROESE_FAROE_ISLANDS
#undef SUBLANG_FILIPINO_PHILIPPINES
#undef SUBLANG_FINNISH_FINLAND
#undef SUBLANG_FRENCH_BELGIAN
#undef SUBLANG_FRENCH_CANADIAN
#undef SUBLANG_FRENCH_LUXEMBOURG
#undef SUBLANG_FRENCH_MONACO
#undef SUBLANG_FRENCH_SWISS
#undef SUBLANG_FRENCH
#undef SUBLANG_FRISIAN_NETHERLANDS
#undef SUBLANG_GALICIAN_GALICIAN
#undef SUBLANG_GEORGIAN_GEORGIA
#undef SUBLANG_GERMAN_AUSTRIAN
#undef SUBLANG_GERMAN_LIECHTENSTEIN
#undef SUBLANG_GERMAN_LUXEMBOURG
#undef SUBLANG_GERMAN_SWISS
#undef SUBLANG_GERMAN
#undef SUBLANG_GREEK_GREECE
#undef SUBLANG_GREENLANDIC_GREENLAND
#undef SUBLANG_GUJARATI_INDIA
#undef SUBLANG_HAUSA_NIGERIA_LATIN
#undef SUBLANG_HEBREW_ISRAEL
#undef SUBLANG_HINDI_INDIA
#undef SUBLANG_HUNGARIAN_HUNGARY
#undef SUBLANG_ICELANDIC_ICELAND
#undef SUBLANG_IGBO_NIGERIA
#undef SUBLANG_INDONESIAN_INDONESIA
#undef SUBLANG_INUKTITUT_CANADA_LATIN
#undef SUBLANG_INUKTITUT_CANADA
#undef SUBLANG_IRISH_IRELAND
#undef SUBLANG_ITALIAN_SWISS
#undef SUBLANG_ITALIAN
#undef SUBLANG_JAPANESE_JAPAN
#undef SUBLANG_KANNADA_INDIA
#undef SUBLANG_KASHMIRI_INDIA
#undef SUBLANG_KASHMIRI_SASIA
#undef SUBLANG_KAZAK_KAZAKHSTAN
#undef SUBLANG_KHMER_CAMBODIA
#undef SUBLANG_KICHE_GUATEMALA
#undef SUBLANG_KINYARWANDA_RWANDA
#undef SUBLANG_KONKANI_INDIA
#undef SUBLANG_KOREAN
#undef SUBLANG_KYRGYZ_KYRGYZSTAN
#undef SUBLANG_LAO_LAO
#undef SUBLANG_LATVIAN_LATVIA
#undef SUBLANG_LITHUANIAN_CLASSIC
#undef SUBLANG_LITHUANIAN
#undef SUBLANG_LOWER_SORBIAN_GERMANY
#undef SUBLANG_LUXEMBOURGISH_LUXEMBOURG
#undef SUBLANG_MACEDONIAN_MACEDONIA
#undef SUBLANG_MALAY_BRUNEI_DARUSSALAM
#undef SUBLANG_MALAY_MALAYSIA
#undef SUBLANG_MALAYALAM_INDIA
#undef SUBLANG_MALTESE_MALTA
#undef SUBLANG_MAORI_NEW_ZEALAND
#undef SUBLANG_MAPUDUNGUN_CHILE
#undef SUBLANG_MARATHI_INDIA
#undef SUBLANG_MOHAWK_MOHAWK
#undef SUBLANG_MONGOLIAN_CYRILLIC_MONGOLIA
#undef SUBLANG_MONGOLIAN_PRC
#undef SUBLANG_NEPALI_INDIA
#undef SUBLANG_NEPALI_NEPAL
#undef SUBLANG_NEUTRAL
#undef SUBLANG_NORWEGIAN_BOKMAL
#undef SUBLANG_NORWEGIAN_NYNORSK
#undef SUBLANG_OCCITAN_FRANCE
#undef SUBLANG_ORIYA_INDIA
#undef SUBLANG_PASHTO_AFGHANISTAN
#undef SUBLANG_PERSIAN_IRAN
#undef SUBLANG_POLISH_POLAND
#undef SUBLANG_PORTUGUESE_BRAZILIAN
#undef SUBLANG_PORTUGUESE
#undef SUBLANG_PUNJABI_INDIA
#undef SUBLANG_QUECHUA_BOLIVIA
#undef SUBLANG_QUECHUA_ECUADOR
#undef SUBLANG_QUECHUA_PERU
#undef SUBLANG_ROMANIAN_ROMANIA
#undef SUBLANG_ROMANSH_SWITZERLAND
#undef SUBLANG_RUSSIAN_RUSSIA
#undef SUBLANG_SAMI_INARI_FINLAND
#undef SUBLANG_SAMI_LULE_NORWAY
#undef SUBLANG_SAMI_LULE_SWEDEN
#undef SUBLANG_SAMI_NORTHERN_FINLAND
#undef SUBLANG_SAMI_NORTHERN_NORWAY
#undef SUBLANG_SAMI_NORTHERN_SWEDEN
#undef SUBLANG_SAMI_SKOLT_FINLAND
#undef SUBLANG_SAMI_SOUTHERN_NORWAY
#undef SUBLANG_SAMI_SOUTHERN_SWEDEN
#undef SUBLANG_SANSKRIT_INDIA
#undef SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_CYRILLIC
#undef SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_LATIN
#undef SUBLANG_SERBIAN_CROATIA
#undef SUBLANG_SERBIAN_CYRILLIC
#undef SUBLANG_SERBIAN_LATIN
#undef SUBLANG_SINDHI_AFGHANISTAN
#undef SUBLANG_SINDHI_INDIA
#undef SUBLANG_SINDHI_PAKISTAN
#undef SUBLANG_SINHALESE_SRI_LANKA
#undef SUBLANG_SLOVAK_SLOVAKIA
#undef SUBLANG_SLOVENIAN_SLOVENIA
#undef SUBLANG_SOTHO_NORTHERN_SOUTH_AFRICA
#undef SUBLANG_SPANISH_ARGENTINA
#undef SUBLANG_SPANISH_BOLIVIA
#undef SUBLANG_SPANISH_CHILE
#undef SUBLANG_SPANISH_COLOMBIA
#undef SUBLANG_SPANISH_COSTA_RICA
#undef SUBLANG_SPANISH_DOMINICAN_REPUBLIC
#undef SUBLANG_SPANISH_ECUADOR
#undef SUBLANG_SPANISH_EL_SALVADOR
#undef SUBLANG_SPANISH_GUATEMALA
#undef SUBLANG_SPANISH_HONDURAS
#undef SUBLANG_SPANISH_MEXICAN
#undef SUBLANG_SPANISH_MODERN
#undef SUBLANG_SPANISH_NICARAGUA
#undef SUBLANG_SPANISH_PANAMA
#undef SUBLANG_SPANISH_PARAGUAY
#undef SUBLANG_SPANISH_PERU
#undef SUBLANG_SPANISH_PUERTO_RICO
#undef SUBLANG_SPANISH_URUGUAY
#undef SUBLANG_SPANISH_US
#undef SUBLANG_SPANISH_VENEZUELA
#undef SUBLANG_SPANISH
#undef SUBLANG_SWAHILI_KENYA
#undef SUBLANG_SWEDISH_FINLAND
#undef SUBLANG_SWEDISH
#undef SUBLANG_SYRIAC_SYRIA
#undef SUBLANG_SYS_DEFAULT
#undef SUBLANG_TAJIK_TAJIKISTAN
#undef SUBLANG_TAMAZIGHT_ALGERIA_LATIN
#undef SUBLANG_TAMIL_INDIA
#undef SUBLANG_TATAR_RUSSIA
#undef SUBLANG_TELUGU_INDIA
#undef SUBLANG_THAI_THAILAND
#undef SUBLANG_TIBETAN_PRC
#undef SUBLANG_TIGRIGNA_ERITREA
#undef SUBLANG_TSWANA_SOUTH_AFRICA
#undef SUBLANG_TURKISH_TURKEY
#undef SUBLANG_TURKMEN_TURKMENISTAN
#undef SUBLANG_UI_CUSTOM_DEFAULT
#undef SUBLANG_UIGHUR_PRC
#undef SUBLANG_UKRAINIAN_UKRAINE
#undef SUBLANG_UPPER_SORBIAN_GERMANY
#undef SUBLANG_URDU_INDIA
#undef SUBLANG_URDU_PAKISTAN
#undef SUBLANG_UZBEK_CYRILLIC
#undef SUBLANG_UZBEK_LATIN
#undef SUBLANG_VIETNAMESE_VIETNAM
#undef SUBLANG_WELSH_UNITED_KINGDOM
#undef SUBLANG_WOLOF_SENEGAL
#undef SUBLANG_XHOSA_SOUTH_AFRICA
#undef SUBLANG_YAKUT_RUSSIA
#undef SUBLANG_YI_PRC
#undef SUBLANG_YORUBA_NIGERIA
#undef SUBLANG_ZULU_SOUTH_AFRICA
#undef SUBLANG_PULAR_SENEGAL
#undef SUBLANG_PUNJABI_PAKISTAN
#undef SUBLANG_TSWANA_BOTSWANA
#undef SUBLANG_TAMIL_SRI_LANKA
#undef SUBLANG_TIGRINYA_ETHIOPIA
#undef SUBLANG_TIGRINYA_ERITREA
#undef SUBLANG_VALENCIAN_VALENCIA

#undef WS_EX_DLGMODALFRAME
#undef WS_EX_NOPARENTNOTIFY
#undef WS_EX_TOPMOST
#undef WS_EX_ACCEPTFILES
#undef WS_EX_TRANSPARENT
#undef WS_EX_MDICHILD
#undef WS_EX_TOOLWINDOW
#undef WS_EX_WINDOWEDGE
#undef WS_EX_CLIENTEDGE
#undef WS_EX_CONTEXTHELP
#undef WS_EX_RIGHT
#undef WS_EX_LEFT
#undef WS_EX_RTLREADING
#undef WS_EX_LTRREADING
#undef WS_EX_LEFTSCROLLBAR
#undef WS_EX_RIGHTSCROLLBAR
#undef WS_EX_CONTROLPARENT
#undef WS_EX_STATICEDGE
#undef WS_EX_APPWINDOW


#undef WS_OVERLAPPED
#undef WS_POPUP
#undef WS_CHILD
#undef WS_MINIMIZE
#undef WS_VISIBLE
#undef WS_DISABLED
#undef WS_CLIPSIBLINGS
#undef WS_CLIPCHILDREN
#undef WS_MAXIMIZE
#undef WS_CAPTION
#undef WS_BORDER
#undef WS_DLGFRAME
#undef WS_VSCROLL
#undef WS_HSCROLL
#undef WS_SYSMENU
#undef WS_THICKFRAME
#undef WS_GROUP
#undef WS_TABSTOP
#undef WS_MINIMIZEBOX
#undef WS_MAXIMIZEBOX

#undef DS_ABSALIGN
#undef DS_SYSMODAL
#undef DS_LOCALEDIT
#undef DS_SETFONT
#undef DS_MODALFRAME
#undef DS_NOIDLEMSG
#undef DS_SETFOREGROUND
#undef DS_3DLOOK
#undef DS_FIXEDSYS
#undef DS_NOFAILCREATE
#undef DS_CONTROL
#undef DS_CENTER
#undef DS_CENTERMOUSE
#undef DS_CONTEXTHELP
#undef DS_SHELLFONT

#undef VOS_UNKNOWN
#undef VOS_DOS
#undef VOS_NT
#undef VOS__WINDOWS16
#undef VOS__WINDOWS32
#undef VOS_OS216
#undef VOS_OS232
#undef VOS__PM16
#undef VOS__PM32
#undef VOS_DOS_WINDOWS16
#undef VOS_DOS_WINDOWS32
#undef VOS_NT_WINDOWS32
#undef VOS_OS216_PM16
#undef VOS_OS232_PM32

#undef VS_FF_DEBUG
#undef VS_FF_INFOINFERRED
#undef VS_FF_PATCHED
#undef VS_FF_PRERELEASE
#undef VS_FF_PRIVATEBUILD
#undef VS_FF_SPECIALBUILD

#undef VFT_APP
#undef VFT_DLL
#undef VFT_DRV
#undef VFT_FONT
#undef VFT_STATIC_LIB
#undef VFT_UNKNOWN
#undef VFT_VXD

#undef VFT2_DRV_COMM
#undef VFT2_DRV_DISPLAY
#undef VFT2_DRV_INSTALLABLE
#undef VFT2_DRV_KEYBOARD
#undef VFT2_DRV_LANGUAGE
#undef VFT2_DRV_MOUSE
#undef VFT2_DRV_NETWORK
#undef VFT2_DRV_PRINTER
#undef VFT2_DRV_SOUND
#undef VFT2_DRV_SYSTEM
#undef VFT2_DRV_VERSIONED_PRINTER
#undef VFT2_FONT_RASTER
#undef VFT2_FONT_TRUETYPE
#undef VFT2_FONT_VECTOR
#undef VFT2_UNKNOWN

#undef FVIRTKEY
#undef FNOINVERT
#undef FSHIFT
#undef FCONTROL
#undef FALT
#undef END

#undef VK_LBUTTON
#undef VK_RBUTTON
#undef VK_CANCEL
#undef VK_MBUTTON
#undef VK_XBUTTON1
#undef VK_XBUTTON2
#undef VK_BACK
#undef VK_TAB
#undef VK_CLEAR
#undef VK_RETURN
#undef VK_SHIFT
#undef VK_CONTROL
#undef VK_MENU
#undef VK_PAUSE
#undef VK_CAPITAL
#undef VK_KANA
#undef VK_HANGUEL
#undef VK_HANGUL
#undef VK_IME_ON
#undef VK_JUNJA
#undef VK_FINAL
#undef VK_HANJA
#undef VK_KANJI
#undef VK_IME_OFF
#undef VK_ESCAPE
#undef VK_CONVERT
#undef VK_NONCONVERT
#undef VK_ACCEPT
#undef VK_MODECHANGE
#undef VK_SPACE
#undef VK_PRIOR
#undef VK_NEXT
#undef VK_END
#undef VK_HOME
#undef VK_LEFT
#undef VK_UP
#undef VK_RIGHT
#undef VK_DOWN
#undef VK_SELECT
#undef VK_PRINT
#undef VK_EXECUTE
#undef VK_SNAPSHOT
#undef VK_INSERT
#undef VK_DELETE
#undef VK_HELP
#undef VK_0
#undef VK_1
#undef VK_2
#undef VK_3
#undef VK_4
#undef VK_5
#undef VK_6
#undef VK_7
#undef VK_8
#undef VK_9
#undef VK_A
#undef VK_B
#undef VK_C
#undef VK_D
#undef VK_E
#undef VK_F
#undef VK_G
#undef VK_H
#undef VK_I
#undef VK_J
#undef VK_K
#undef VK_L
#undef VK_M
#undef VK_N
#undef VK_O
#undef VK_P
#undef VK_Q
#undef VK_R
#undef VK_S
#undef VK_T
#undef VK_U
#undef VK_V
#undef VK_W
#undef VK_X
#undef VK_Y
#undef VK_Z
#undef VK_LWIN
#undef VK_RWIN
#undef VK_APPS
#undef VK_SLEEP
#undef VK_NUMPAD0
#undef VK_NUMPAD1
#undef VK_NUMPAD2
#undef VK_NUMPAD3
#undef VK_NUMPAD4
#undef VK_NUMPAD5
#undef VK_NUMPAD6
#undef VK_NUMPAD7
#undef VK_NUMPAD8
#undef VK_NUMPAD9
#undef VK_MULTIPLY
#undef VK_ADD
#undef VK_SEPARATOR
#undef VK_SUBTRACT
#undef VK_DECIMAL
#undef VK_DIVIDE
#undef VK_F1
#undef VK_F2
#undef VK_F3
#undef VK_F4
#undef VK_F5
#undef VK_F6
#undef VK_F7
#undef VK_F8
#undef VK_F9
#undef VK_F10
#undef VK_F11
#undef VK_F12
#undef VK_F13
#undef VK_F14
#undef VK_F15
#undef VK_F16
#undef VK_F17
#undef VK_F18
#undef VK_F19
#undef VK_F20
#undef VK_F21
#undef VK_F22
#undef VK_F23
#undef VK_F24
#undef VK_NUMLOCK
#undef VK_SCROLL
#undef VK_LSHIFT
#undef VK_RSHIFT
#undef VK_LCONTROL
#undef VK_RCONTROL
#undef VK_LMENU
#undef VK_RMENU
#undef VK_BROWSER_BACK
#undef VK_BROWSER_FORWARD
#undef VK_BROWSER_REFRESH
#undef VK_BROWSER_STOP
#undef VK_BROWSER_SEARCH
#undef VK_BROWSER_FAVORITES
#undef VK_BROWSER_HOME
#undef VK_VOLUME_MUTE
#undef VK_VOLUME_DOWN
#undef VK_VOLUME_UP
#undef VK_MEDIA_NEXT_TRACK
#undef VK_MEDIA_PREV_TRACK
#undef VK_MEDIA_STOP
#undef VK_MEDIA_PLAY_PAUSE
#undef VK_LAUNCH_MAIL
#undef VK_LAUNCH_MEDIA_SELECT
#undef VK_LAUNCH_APP1
#undef VK_LAUNCH_APP2
#undef VK_OEM_1
#undef VK_OEM_PLUS
#undef VK_OEM_COMMA
#undef VK_OEM_MINUS
#undef VK_OEM_PERIOD
#undef VK_OEM_2
#undef VK_OEM_4
#undef VK_OEM_5
#undef VK_OEM_6
#undef VK_OEM_7
#undef VK_OEM_8
#undef VK_OEM_102
#undef VK_PROCESSKEY
#undef VK_PACKET
#undef VK_ATTN
#undef VK_CRSEL
#undef VK_EXSEL
#undef VK_EREOF
#undef VK_PLAY
#undef VK_ZOOM
#undef VK_NONAME
#undef VK_PA1
#undef VK_OEM_CLEAR

#endif

```

`KDemu/include/LIEF/LIEF/PE/utils.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PE_UTILS_H
#define LIEF_PE_UTILS_H
#include <vector>
#include <string>

#include "LIEF/PE/enums.hpp"
#include "LIEF/visibility.h"
#include "LIEF/errors.hpp"

namespace LIEF {
class BinaryStream;

namespace PE {
class Binary;
class Import;

//! Enum to define the behavior of LIEF::PE::get_imphash
enum class IMPHASH_MODE {
  DEFAULT = 0,    /**< Default implementation */
  LIEF = DEFAULT, /**< Same as IMPHASH_MODE::DEFAULT */
  PEFILE,         /**< Use pefile algorithm */
  VT = PEFILE,    /**< Same as IMPHASH_MODE::PEFILE since Virus Total is using pefile */
};

//Check if the given stream wraps a PE binary
LIEF_API bool is_pe(BinaryStream& stream);

//! check if the `file` is a PE file
LIEF_API bool is_pe(const std::string& file);

//! check if the raw data is a PE file
LIEF_API bool is_pe(const std::vector<uint8_t>& raw);

//! if the input `file` is a PE one, return `PE32` or `PE32+`
LIEF_API result<PE_TYPE> get_type(const std::string& file);

//! Return `PE32` or `PE32+`
LIEF_API result<PE_TYPE> get_type(const std::vector<uint8_t>& raw);

// In this case we assume that stream contains a valid PE stream
LIEF_LOCAL result<PE_TYPE> get_type_from_stream(BinaryStream& stream);

//! Compute the hash of imported functions
//!
//! By default, it generates an hash with the following properties:
//!   * Order agnostic
//!   * Casse agnostic
//!   * Ordinal (**in some extent**) agnostic
//!
//! If one needs the same output as Virus Total (i.e. pefile), you can pass IMPHASH_MODE::PEFILE
//! as second parameter.
//!
//! @warning The default algorithm used to compute the *imphash* value has some variations compared to Yara, pefile, VT implementation
//!
//! @see https://www.fireeye.com/blog/threat-research/2014/01/tracking-malware-import-hashing.html
LIEF_API std::string get_imphash(const Binary& binary, IMPHASH_MODE mode = IMPHASH_MODE::DEFAULT);

//! Take a PE::Import as entry and try to resolve imports
//! by ordinal.
//!
//! The ``strict`` boolean parameter enables to throw an LIEF::not_found exception
//! if the ordinal can't be resolved. Otherwise it skips the entry.
//!
//! @param[in] import Import to resolve
//! @param[in] strict If set to ``true``, throw an exception if the import can't be resolved
//! @param[in] use_std If ``true``, it will use the [pefile](https://github.com/erocarrera/pefile/tree/09264be6f731bf8578aee8638cc4046154e03abf/ordlookup) look-up table for resolving imports
//!
//! @return The PE::import resolved with PE::ImportEntry::name set
LIEF_API result<Import> resolve_ordinals(const Import& import, bool strict=false, bool use_std=false);

LIEF_API ALGORITHMS algo_from_oid(const std::string& oid);
}
}
#endif

```

`KDemu/include/LIEF/LIEF/VDEX.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_VDEX_H
#define LIEF_VDEX_H

#include "LIEF/config.h"

#if defined(LIEF_VDEX_SUPPORT)
#if !defined(LIEF_DEX_SUPPORT)
#error "The VDEX module can't be used without the DEX support"
#endif
#include "LIEF/DEX.hpp"
#include "LIEF/VDEX/Parser.hpp"
#include "LIEF/VDEX/utils.hpp"
#include "LIEF/VDEX/File.hpp"
#endif

#endif

```

`KDemu/include/LIEF/LIEF/VDEX/File.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_VDEX_FILE_H
#define LIEF_VDEX_FILE_H
#include <ostream>

#include "LIEF/VDEX/Header.hpp"
#include "LIEF/VDEX/type_traits.hpp"

#include "LIEF/visibility.h"
#include "LIEF/Object.hpp"
#include "LIEF/iterators.hpp"

#include <vector>
#include <memory>

namespace LIEF {
namespace DEX {
class File;
}
namespace OAT {
class Binary;
}

namespace VDEX {
class Parser;

//! Main class for the VDEX module which represents a VDEX file
class LIEF_API File : public Object {
  friend class Parser;
  friend class OAT::Binary;

  public:
  using dex_files_t = std::vector<std::unique_ptr<DEX::File>>;
  using it_dex_files = ref_iterator<dex_files_t&, DEX::File*>;
  using it_const_dex_files = const_ref_iterator<const dex_files_t&, const DEX::File*>;

  File& operator=(const File& copy) = delete;
  File(const File& copy)            = delete;

  //! VDEX Header
  const Header& header() const;
  Header& header();

  //! Iterator over LIEF::DEX::Files registered
  it_dex_files       dex_files();
  it_const_dex_files dex_files() const;

  dex2dex_info_t dex2dex_info() const;

  std::string dex2dex_json_info();

  void accept(Visitor& visitor) const override;


  ~File() override;

  LIEF_API friend std::ostream& operator<<(std::ostream& os, const File& vdex_file);

  private:
  File();

  Header header_;
  dex_files_t dex_files_;
};

}
}

#endif

```

`KDemu/include/LIEF/LIEF/VDEX/Header.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_VDEX_HEADER_H
#define LIEF_VDEX_HEADER_H
#include <ostream>
#include <array>

#include "LIEF/VDEX/type_traits.hpp"
#include "LIEF/visibility.h"
#include "LIEF/Object.hpp"

namespace LIEF {
namespace VDEX {
class Parser;

class LIEF_API Header : public Object {
  friend class Parser;

  public:
  using magic_t = std::array<uint8_t, 4>;

  Header();

  template<class T>
  LIEF_LOCAL Header(const T* header);

  Header(const Header&);
  Header& operator=(const Header&);

  //! Magic value used to identify VDEX
  magic_t magic() const;

  //! VDEX version number
  vdex_version_t version() const;

  //! Number of LIEF::DEX::File files registered
  uint32_t nb_dex_files() const;

  //! Size of **all** LIEF::DEX::File
  uint32_t dex_size() const;

  //! Size of verifier deps section
  uint32_t verifier_deps_size() const;

  //! Size of quickening info section
  uint32_t quickening_info_size() const;

  void accept(Visitor& visitor) const override;


  LIEF_API friend std::ostream& operator<<(std::ostream& os, const Header& header);

  ~Header() override;

  private:
  magic_t magic_;
  vdex_version_t version_;

  uint32_t nb_dex_files_;
  uint32_t dex_size_;

  uint32_t verifier_deps_size_;
  uint32_t quickening_info_size_;
};

} // Namespace VDEX
} // Namespace LIEF

#endif

```

`KDemu/include/LIEF/LIEF/VDEX/Parser.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_VDEX_PARSER_H
#define LIEF_VDEX_PARSER_H

#include <memory>
#include <vector>
#include <string>

#include "LIEF/VDEX/type_traits.hpp"
#include "LIEF/visibility.h"

namespace LIEF {
class VectorStream;
namespace VDEX {
class File;

//! @brief Class which parse an VDEX file and transform into a VDEX::File object
class LIEF_API Parser {
  public:
  static std::unique_ptr<File> parse(const std::string& file);
  static std::unique_ptr<File> parse(const std::vector<uint8_t>& data,
                                     const std::string& name = "");

  Parser& operator=(const Parser& copy) = delete;
  Parser(const Parser& copy)            = delete;

  private:
  Parser();
  Parser(const std::string& file);
  Parser(const std::vector<uint8_t>& data, const std::string& name);
  virtual ~Parser();

  void init(const std::string& name, vdex_version_t version);

  template<typename VDEX_T>
  void parse_file();

  template<typename VDEX_T>
  void parse_header();

  template<typename VDEX_T>
  void parse_checksums();

  template<typename VDEX_T>
  void parse_dex_files();

  template<typename VDEX_T>
  void parse_verifier_deps();

  template<typename VDEX_T>
  void parse_quickening_info();

  LIEF::VDEX::File* file_ = nullptr;
  std::unique_ptr<VectorStream> stream_;
};

} // namespace VDEX
} // namespace LIEF
#endif

```

`KDemu/include/LIEF/LIEF/VDEX/hash.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_VDEX_HASH_H
#define LIEF_VDEX_HASH_H

#include "LIEF/visibility.h"
#include "LIEF/hash.hpp"

namespace LIEF {
namespace VDEX {
class File;
class Header;

class LIEF_API Hash : public LIEF::Hash {
  public:
  static LIEF::Hash::value_type hash(const Object& obj);

  public:
  using LIEF::Hash::Hash;
  using LIEF::Hash::visit;

  public:
  void visit(const File& file)     override;
  void visit(const Header& header) override;

  ~Hash() override;
};

}
}

#endif

```

`KDemu/include/LIEF/LIEF/VDEX/json.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_VDEX_PUBLIC_JSON_H
#define LIEF_VDEX_PUBLIC_JSON_H

#include "LIEF/visibility.h"
#include <string>

namespace LIEF {
class Object;

namespace VDEX {

LIEF_API std::string to_json(const Object& v);

}
}

#endif

```

`KDemu/include/LIEF/LIEF/VDEX/type_traits.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_VDEX_TYPE_TRAITS_H
#define LIEF_VDEX_TYPE_TRAITS_H
#include <cstdint>
#include <unordered_map>
#include <LIEF/DEX/deopt.hpp>

namespace LIEF {
namespace DEX {
class File;
} // namespace DEX

namespace VDEX {
using vdex_version_t = uint32_t;
using dex2dex_info_t = std::unordered_map<const DEX::File*, DEX::dex2dex_info_t>;
} // namespace VDEX
} // namespace LIEF


#endif

```

`KDemu/include/LIEF/LIEF/VDEX/utils.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_VDEX_UTILS_H
#define LIEF_VDEX_UTILS_H

#include <string>
#include <vector>

#include "LIEF/VDEX/type_traits.hpp"

#include "LIEF/platforms/android.hpp"

#include "LIEF/types.hpp"
#include "LIEF/visibility.h"

namespace LIEF {
namespace VDEX {

//! @brief Check if the given file is an VDEX one.
LIEF_API bool is_vdex(const std::string& file);

//! @brief Check if the given raw data is an VDEX one.
LIEF_API bool is_vdex(const std::vector<uint8_t>& raw);

//! @brief Return the VDEX version of the given file
LIEF_API vdex_version_t version(const std::string& file);

//! @brief Return the VDEX version of the raw data
LIEF_API vdex_version_t version(const std::vector<uint8_t>& raw);

//! @brief Return the ANDROID_VERSIONS associated with the given VDEX version
LIEF_API Android::ANDROID_VERSIONS android_version(vdex_version_t version);

}
}


#endif

```

`KDemu/include/LIEF/LIEF/Visitor.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
* Copyright 2017 - 2024 Quarkslab
* Copyright 2017 - 2021 K. Nakagawa
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
#ifndef LIEF_VISITOR_H
#define LIEF_VISITOR_H
#include <set>
#include <utility>
#include <cstddef>

#include "LIEF/visibility.h"
#include "LIEF/visitor_macros.hpp"


namespace LIEF {
// Forward declarations
// ====================
class Object;
LIEF_ABSTRACT_FORWARD(Binary)
LIEF_ABSTRACT_FORWARD(Header)
LIEF_ABSTRACT_FORWARD(Section)
LIEF_ABSTRACT_FORWARD(Symbol)
LIEF_ABSTRACT_FORWARD(Relocation)
LIEF_ABSTRACT_FORWARD(Function)

// PE
// ===============================
LIEF_PE_FORWARD(Binary)
LIEF_PE_FORWARD(DelayImport)
LIEF_PE_FORWARD(DelayImportEntry)
LIEF_PE_FORWARD(DosHeader)
LIEF_PE_FORWARD(Header)
LIEF_PE_FORWARD(OptionalHeader)
LIEF_PE_FORWARD(RichHeader)
LIEF_PE_FORWARD(RichEntry)
LIEF_PE_FORWARD(DataDirectory)
LIEF_PE_FORWARD(Section)
LIEF_PE_FORWARD(Relocation)
LIEF_PE_FORWARD(RelocationEntry)
LIEF_PE_FORWARD(Export)
LIEF_PE_FORWARD(ExportEntry)
LIEF_PE_FORWARD(TLS)
LIEF_PE_FORWARD(Symbol)
LIEF_PE_FORWARD(Debug)
LIEF_PE_FORWARD(CodeView)
LIEF_PE_FORWARD(CodeViewPDB)
LIEF_PE_FORWARD(Import)
LIEF_PE_FORWARD(ImportEntry)
LIEF_PE_FORWARD(ResourceNode)
LIEF_PE_FORWARD(ResourceData)
LIEF_PE_FORWARD(ResourceDirectory)
LIEF_PE_FORWARD(ResourcesManager)
LIEF_PE_FORWARD(ResourceVersion)
LIEF_PE_FORWARD(ResourceStringFileInfo)
LIEF_PE_FORWARD(ResourceFixedFileInfo)
LIEF_PE_FORWARD(ResourceVarFileInfo)
LIEF_PE_FORWARD(LangCodeItem)
LIEF_PE_FORWARD(ResourceIcon)
LIEF_PE_FORWARD(ResourceDialog)
LIEF_PE_FORWARD(ResourceDialogItem)
LIEF_PE_FORWARD(ResourceStringTable)
LIEF_PE_FORWARD(ResourceAccelerator)

LIEF_PE_FORWARD(Signature)
LIEF_PE_FORWARD(x509)
LIEF_PE_FORWARD(SignerInfo)
LIEF_PE_FORWARD(ContentInfo)
LIEF_PE_FORWARD(GenericContent)
LIEF_PE_FORWARD(SpcIndirectData)
LIEF_PE_FORWARD(Attribute)
LIEF_PE_FORWARD(ContentType)
LIEF_PE_FORWARD(GenericType)
LIEF_PE_FORWARD(MsCounterSign)
LIEF_PE_FORWARD(MsSpcNestedSignature)
LIEF_PE_FORWARD(MsSpcStatementType)
LIEF_PE_FORWARD(MsManifestBinaryID)
LIEF_PE_FORWARD(PKCS9AtSequenceNumber)
LIEF_PE_FORWARD(PKCS9CounterSignature)
LIEF_PE_FORWARD(PKCS9MessageDigest)
LIEF_PE_FORWARD(PKCS9SigningTime)
LIEF_PE_FORWARD(SpcSpOpusInfo)
LIEF_PE_FORWARD(SigningCertificateV2)
LIEF_PE_FORWARD(SpcRelaxedPeMarkerCheck)

LIEF_PE_FORWARD(CodeIntegrity)
LIEF_PE_FORWARD(LoadConfiguration)
LIEF_PE_FORWARD(LoadConfigurationV0)
LIEF_PE_FORWARD(LoadConfigurationV1)
LIEF_PE_FORWARD(LoadConfigurationV10)
LIEF_PE_FORWARD(LoadConfigurationV11)
LIEF_PE_FORWARD(LoadConfigurationV2)
LIEF_PE_FORWARD(LoadConfigurationV3)
LIEF_PE_FORWARD(LoadConfigurationV4)
LIEF_PE_FORWARD(LoadConfigurationV5)
LIEF_PE_FORWARD(LoadConfigurationV6)
LIEF_PE_FORWARD(LoadConfigurationV7)
LIEF_PE_FORWARD(LoadConfigurationV8)
LIEF_PE_FORWARD(LoadConfigurationV9)
LIEF_PE_FORWARD(Pogo)
LIEF_PE_FORWARD(PogoEntry)
LIEF_PE_FORWARD(Repro)

// ELF
// ==================================
LIEF_ELF_FORWARD(Binary)
LIEF_ELF_FORWARD(Header)
LIEF_ELF_FORWARD(Section)
LIEF_ELF_FORWARD(Segment)
LIEF_ELF_FORWARD(DynamicEntry)
LIEF_ELF_FORWARD(DynamicEntryArray)
LIEF_ELF_FORWARD(DynamicEntryLibrary)
LIEF_ELF_FORWARD(DynamicSharedObject)
LIEF_ELF_FORWARD(DynamicEntryRunPath)
LIEF_ELF_FORWARD(DynamicEntryRpath)
LIEF_ELF_FORWARD(DynamicEntryFlags)
LIEF_ELF_FORWARD(Symbol)
LIEF_ELF_FORWARD(Relocation)
LIEF_ELF_FORWARD(SymbolVersion)
LIEF_ELF_FORWARD(SymbolVersionRequirement)
LIEF_ELF_FORWARD(SymbolVersionDefinition)
LIEF_ELF_FORWARD(SymbolVersionAux)
LIEF_ELF_FORWARD(SymbolVersionAuxRequirement)
LIEF_ELF_FORWARD(Note)
LIEF_ELF_FORWARD(AndroidIdent)
LIEF_ELF_FORWARD(QNXStack)
LIEF_ELF_FORWARD(NoteAbi)
LIEF_ELF_FORWARD(NoteGnuProperty)
LIEF_ELF_FORWARD(CorePrPsInfo)
LIEF_ELF_FORWARD(CorePrStatus)
LIEF_ELF_FORWARD(CoreAuxv)
LIEF_ELF_FORWARD(CoreSigInfo)
LIEF_ELF_FORWARD(CoreFile)
LIEF_ELF_FORWARD(GnuHash)
LIEF_ELF_FORWARD(SysvHash)


// MACHO
// ===============================
LIEF_MACHO_FORWARD(Binary)
LIEF_MACHO_FORWARD(Header)
LIEF_MACHO_FORWARD(LoadCommand)
LIEF_MACHO_FORWARD(UUIDCommand)
LIEF_MACHO_FORWARD(SymbolCommand)
LIEF_MACHO_FORWARD(SegmentCommand)
LIEF_MACHO_FORWARD(Section)
LIEF_MACHO_FORWARD(MainCommand)
LIEF_MACHO_FORWARD(DynamicSymbolCommand)
LIEF_MACHO_FORWARD(DylinkerCommand)
LIEF_MACHO_FORWARD(DylibCommand)
LIEF_MACHO_FORWARD(ThreadCommand)
LIEF_MACHO_FORWARD(RPathCommand)
LIEF_MACHO_FORWARD(Symbol)
LIEF_MACHO_FORWARD(Relocation)
LIEF_MACHO_FORWARD(RelocationObject)
LIEF_MACHO_FORWARD(RelocationDyld)
LIEF_MACHO_FORWARD(RelocationFixup)
LIEF_MACHO_FORWARD(BindingInfo)
LIEF_MACHO_FORWARD(DyldBindingInfo)
LIEF_MACHO_FORWARD(DyldExportsTrie)
LIEF_MACHO_FORWARD(ChainedBindingInfo)
LIEF_MACHO_FORWARD(ExportInfo)
LIEF_MACHO_FORWARD(FunctionStarts)
LIEF_MACHO_FORWARD(CodeSignature)
LIEF_MACHO_FORWARD(DataInCode)
LIEF_MACHO_FORWARD(DataCodeEntry)
LIEF_MACHO_FORWARD(SourceVersion)
LIEF_MACHO_FORWARD(VersionMin)
LIEF_MACHO_FORWARD(SegmentSplitInfo)
LIEF_MACHO_FORWARD(SubFramework)
LIEF_MACHO_FORWARD(DyldEnvironment)
LIEF_MACHO_FORWARD(EncryptionInfo)
LIEF_MACHO_FORWARD(BuildVersion)
LIEF_MACHO_FORWARD(BuildToolVersion)
LIEF_MACHO_FORWARD(FilesetCommand)
LIEF_MACHO_FORWARD(TwoLevelHints)
LIEF_MACHO_FORWARD(CodeSignatureDir)
LIEF_MACHO_FORWARD(LinkerOptHint)
LIEF_MACHO_FORWARD(UnknownCommand)

// OAT
// ===============================
LIEF_OAT_FORWARD(Binary)
LIEF_OAT_FORWARD(Header)
LIEF_OAT_FORWARD(DexFile)
LIEF_OAT_FORWARD(Method)
LIEF_OAT_FORWARD(Class)

// DEX
// ===============================
LIEF_DEX_FORWARD(File)
LIEF_DEX_FORWARD(Field)
LIEF_DEX_FORWARD(Method)
LIEF_DEX_FORWARD(Header)
LIEF_DEX_FORWARD(Class)
LIEF_DEX_FORWARD(CodeInfo)
LIEF_DEX_FORWARD(Type)
LIEF_DEX_FORWARD(Prototype)
LIEF_DEX_FORWARD(MapItem)
LIEF_DEX_FORWARD(MapList)

// VDEX
// ===============================
LIEF_VDEX_FORWARD(File)
LIEF_VDEX_FORWARD(Header)

// ART
// ===============================
LIEF_ART_FORWARD(File)
LIEF_ART_FORWARD(Header)


class LIEF_API Visitor {
  public:
  Visitor();
  virtual ~Visitor();

  virtual void operator()();

  template<typename Arg1, typename... Args>
  void operator()(Arg1&& arg1, Args&&... args);

  virtual void visit(const Object&);

  // Abstract Part
  // =============

  //! Method to visit a LIEF::Binary
  LIEF_ABSTRACT_VISITABLE(Binary)

  //! Method to visit a LIEF::Header
  LIEF_ABSTRACT_VISITABLE(Header)

  //! Method to visit a LIEF::Section
  LIEF_ABSTRACT_VISITABLE(Section)

  //! Method to visit a LIEF::Symbol
  LIEF_ABSTRACT_VISITABLE(Symbol)

  //! Method to visit a LIEF::Relocation
  LIEF_ABSTRACT_VISITABLE(Relocation)

  //! Method to visit a LIEF::Function
  LIEF_ABSTRACT_VISITABLE(Function)

  LIEF_ELF_VISITABLE(Binary)
  LIEF_ELF_VISITABLE(Header)
  LIEF_ELF_VISITABLE(Section)
  LIEF_ELF_VISITABLE(Segment)
  LIEF_ELF_VISITABLE(DynamicEntry)
  LIEF_ELF_VISITABLE(DynamicEntryArray)
  LIEF_ELF_VISITABLE(DynamicEntryLibrary)
  LIEF_ELF_VISITABLE(DynamicSharedObject)
  LIEF_ELF_VISITABLE(DynamicEntryRunPath)
  LIEF_ELF_VISITABLE(DynamicEntryRpath)
  LIEF_ELF_VISITABLE(DynamicEntryFlags)
  LIEF_ELF_VISITABLE(Symbol)
  LIEF_ELF_VISITABLE(Relocation)
  LIEF_ELF_VISITABLE(SymbolVersion)
  LIEF_ELF_VISITABLE(SymbolVersionRequirement)
  LIEF_ELF_VISITABLE(SymbolVersionDefinition)
  LIEF_ELF_VISITABLE(SymbolVersionAux)
  LIEF_ELF_VISITABLE(SymbolVersionAuxRequirement)
  LIEF_ELF_VISITABLE(Note)
  LIEF_ELF_VISITABLE(AndroidIdent)
  LIEF_ELF_VISITABLE(QNXStack)
  LIEF_ELF_VISITABLE(NoteAbi)
  LIEF_ELF_VISITABLE(NoteGnuProperty)
  LIEF_ELF_VISITABLE(CorePrPsInfo)
  LIEF_ELF_VISITABLE(CorePrStatus)
  LIEF_ELF_VISITABLE(CoreAuxv)
  LIEF_ELF_VISITABLE(CoreSigInfo)
  LIEF_ELF_VISITABLE(CoreFile)
  LIEF_ELF_VISITABLE(GnuHash)
  LIEF_ELF_VISITABLE(SysvHash)

  // PE Part
  // =======
  //! Method to visit a LIEF::PE::Binary
  LIEF_PE_VISITABLE(Binary)

  //! Method to visit a LIEF::PE::DosHeader
  LIEF_PE_VISITABLE(DosHeader)

  //! Method to visit a LIEF::PE:RichHeader
  LIEF_PE_VISITABLE(RichHeader)

  //! Method to visit a LIEF::PE:RichEntry
  LIEF_PE_VISITABLE(RichEntry)

  //! Method to visit a LIEF::PE::Header
  LIEF_PE_VISITABLE(Header)

  //! Method to visit a LIEF::PE::OptionalHeader
  LIEF_PE_VISITABLE(OptionalHeader)

  //! Method to visit a LIEF::PE::DataDirectory
  LIEF_PE_VISITABLE(DataDirectory)

  //! Method to visit a LIEF::PE::TLS
  LIEF_PE_VISITABLE(TLS)

  //! Method to visit a LIEF::PE::Symbol
  LIEF_PE_VISITABLE(Symbol)

  //! Method to visit a LIEF::PE::Section
  LIEF_PE_VISITABLE(Section)

  //! Method to visit a LIEF::PE::Relocation
  LIEF_PE_VISITABLE(Relocation)

  //! Method to visit a LIEF::PE::RelocationEntry
  LIEF_PE_VISITABLE(RelocationEntry)

  //! Method to visit a LIEF::PE::Export
  LIEF_PE_VISITABLE(Export)

  //! Method to visit a LIEF::PE::ExportEntry
  LIEF_PE_VISITABLE(ExportEntry)

  //! Method to visit a LIEF::PE::Debug
  LIEF_PE_VISITABLE(Debug)

  //! Method to visit a LIEF::PE::CodeView
  LIEF_PE_VISITABLE(CodeView)

  //! Method to visit a LIEF::PE::CodeViewPDB
  LIEF_PE_VISITABLE(CodeViewPDB)

  //! Method to visit a LIEF::PE::Import
  LIEF_PE_VISITABLE(Import)

  //! Method to visit a LIEF::PE::ImportEntry
  LIEF_PE_VISITABLE(ImportEntry)

  //! Method to visit a LIEF::PE::DelayImport
  LIEF_PE_VISITABLE(DelayImport)

  //! Method to visit a LIEF::PE::DelayImportEntry
  LIEF_PE_VISITABLE(DelayImportEntry)

  //! Method to visit a LIEF::PE::ResourceNode
  LIEF_PE_VISITABLE(ResourceNode)

  //! Method to visit a LIEF::PE::ResourceData
  LIEF_PE_VISITABLE(ResourceData)

  //! Method to visit a LIEF::PE::ResourceDirectory
  LIEF_PE_VISITABLE(ResourceDirectory)

  //! Method to visit a LIEF::PE::ResourceVersion
  LIEF_PE_VISITABLE(ResourcesManager)

  //! Method to visit a LIEF::PE::ResourceVersion
  LIEF_PE_VISITABLE(ResourceVersion)

  //! Method to visit a LIEF::PE::ResourceStringFileInfo
  LIEF_PE_VISITABLE(ResourceStringFileInfo)

  //! Method to visit a LIEF::PE::ResourceFixedFileInfo
  LIEF_PE_VISITABLE(ResourceFixedFileInfo)

  //! Method to visit a LIEF::PE::ResourceVarFileInfo
  LIEF_PE_VISITABLE(ResourceVarFileInfo)

  //! Method to visit a LIEF::PE::ResourceStringTable
  LIEF_PE_VISITABLE(ResourceStringTable)

  //! Method to visit a LIEF::PE::ResourceAccelerator
  LIEF_PE_VISITABLE(ResourceAccelerator)

  //! Method to visit a LIEF::PE::LangCodeItem
  LIEF_PE_VISITABLE(LangCodeItem)

  //! Method to visit a LIEF::PE::ResourceIcon
  LIEF_PE_VISITABLE(ResourceIcon)

  //! Method to visit a LIEF::PE::ResourceDialog
  LIEF_PE_VISITABLE(ResourceDialog)

  //! Method to visit a LIEF::PE::ResourceDialogItem
  LIEF_PE_VISITABLE(ResourceDialogItem)

  //! Method to visit a LIEF::PE::Signature
  LIEF_PE_VISITABLE(Signature)

  //! Method to visit a LIEF::PE::x509
  LIEF_PE_VISITABLE(x509)

  //! Method to visit a LIEF::PE::SignerInfo
  LIEF_PE_VISITABLE(SignerInfo)

  //! Method to visit a LIEF::PE::ContentInfo
  LIEF_PE_VISITABLE(ContentInfo)

  //! Method to visit a LIEF::PE::Attribute
  LIEF_PE_VISITABLE(Attribute)

  //! Method to visit a LIEF::PE::ContentType
  LIEF_PE_VISITABLE(ContentType)

  //! Method to visit a LIEF::PE::GenericContent
  LIEF_PE_VISITABLE(GenericContent)

  //! Method to visit a LIEF::PE::SpcIndirectData
  LIEF_PE_VISITABLE(SpcIndirectData)

  //! Method to visit a LIEF::PE::GenericType
  LIEF_PE_VISITABLE(GenericType)

  //! Method to visit a LIEF::PE::MsCounterSign
  LIEF_PE_VISITABLE(MsCounterSign)

  //! Method to visit a LIEF::PE::MsManifestBinaryID
  LIEF_PE_VISITABLE(MsManifestBinaryID)

  //! Method to visit a LIEF::PE::MsSpcNestedSignature
  LIEF_PE_VISITABLE(MsSpcNestedSignature)

  //! Method to visit a LIEF::PE::MsSpcStatementType
  LIEF_PE_VISITABLE(MsSpcStatementType)

  //! Method to visit a LIEF::PE::PKCS9AtSequenceNumber
  LIEF_PE_VISITABLE(PKCS9AtSequenceNumber)

  //! Method to visit a LIEF::PE::PKCS9CounterSignature
  LIEF_PE_VISITABLE(PKCS9CounterSignature)

  //! Method to visit a LIEF::PE::PKCS9MessageDigest
  LIEF_PE_VISITABLE(PKCS9MessageDigest)

  //! Method to visit a LIEF::PE::PKCS9SigningTime
  LIEF_PE_VISITABLE(PKCS9SigningTime)

  //! Method to visit a LIEF::PE::SpcSpOpusInfo
  LIEF_PE_VISITABLE(SpcSpOpusInfo)

  //! Method to visit a LIEF::PE::SpcRelaxedPeMarkerCheck
  LIEF_PE_VISITABLE(SpcRelaxedPeMarkerCheck)

  //! Method to visit a LIEF::PE::SigningCertificateV2
  LIEF_PE_VISITABLE(SigningCertificateV2)

  //! Method to visit a LIEF::PE::LoadConfiguration
  LIEF_PE_VISITABLE(LoadConfiguration)

  //! Method to visit a LIEF::PE::LoadConfigurationV0
  LIEF_PE_VISITABLE(LoadConfigurationV0)

  //! Method to visit a LIEF::PE::LoadConfigurationV1
  LIEF_PE_VISITABLE(LoadConfigurationV1)

  //! Method to visit a LIEF::PE::LoadConfigurationV2
  LIEF_PE_VISITABLE(LoadConfigurationV2)

  //! Method to visit a LIEF::PE::LoadConfigurationV3
  LIEF_PE_VISITABLE(LoadConfigurationV3)

  //! Method to visit a LIEF::PE::LoadConfigurationV4
  LIEF_PE_VISITABLE(LoadConfigurationV4)

  //! Method to visit a LIEF::PE::LoadConfigurationV5
  LIEF_PE_VISITABLE(LoadConfigurationV5)

  //! Method to visit a LIEF::PE::LoadConfigurationV6
  LIEF_PE_VISITABLE(LoadConfigurationV6)

  //! Method to visit a LIEF::PE::LoadConfigurationV7
  LIEF_PE_VISITABLE(LoadConfigurationV7)

  //! Method to visit a LIEF::PE::LoadConfigurationV8
  LIEF_PE_VISITABLE(LoadConfigurationV8)

  //! Method to visit a LIEF::PE::LoadConfigurationV9
  LIEF_PE_VISITABLE(LoadConfigurationV9)

  //! Method to visit a LIEF::PE::LoadConfigurationV10
  LIEF_PE_VISITABLE(LoadConfigurationV10)

  //! Method to visit a LIEF::PE::LoadConfigurationV11
  LIEF_PE_VISITABLE(LoadConfigurationV11)

  //! Method to visit a LIEF::PE::CodeIntegrity
  LIEF_PE_VISITABLE(CodeIntegrity)

  //! Method to visit a LIEF::PE::Pogo
  LIEF_PE_VISITABLE(Pogo)

  //! Method to visit a LIEF::PE::PogoEntry
  LIEF_PE_VISITABLE(PogoEntry)

  //! Method to visit a LIEF::PE::Repro
  LIEF_PE_VISITABLE(Repro)

  // MachO part
  // ==========
  //! Method to visit a LIEF::MachO::Binary
  LIEF_MACHO_VISITABLE(Binary)

  //! Method to visit a LIEF::MachO::Header
  LIEF_MACHO_VISITABLE(Header)

  //! Method to visit a LIEF::MachO::LoadCommand
  LIEF_MACHO_VISITABLE(LoadCommand)

  //! Method to visit a LIEF::MachO::UUIDCommand
  LIEF_MACHO_VISITABLE(UUIDCommand)

  //! Method to visit a LIEF::MachO::SymbolCommand
  LIEF_MACHO_VISITABLE(SymbolCommand)

  //! Method to visit a LIEF::MachO::SegmentCommand
  LIEF_MACHO_VISITABLE(SegmentCommand)

  //! Method to visit a LIEF::MachO::Section
  LIEF_MACHO_VISITABLE(Section)

  //! Method to visit a LIEF::MachO::MainCommand
  LIEF_MACHO_VISITABLE(MainCommand)

  //! Method to visit a LIEF::MachO::DynamicSymbolCommand
  LIEF_MACHO_VISITABLE(DynamicSymbolCommand)

  //! Method to visit a LIEF::MachO::DylinkerCommand
  LIEF_MACHO_VISITABLE(DylinkerCommand)

  //! Method to visit a LIEF::MachO::DylibCommand
  LIEF_MACHO_VISITABLE(DylibCommand)

  //! Method to visit a LIEF::MachO::ThreadCommand
  LIEF_MACHO_VISITABLE(ThreadCommand)

  //! Method to visit a LIEF::MachO::RPathCommand
  LIEF_MACHO_VISITABLE(RPathCommand)

  //! Method to visit a LIEF::MachO::Symbol
  LIEF_MACHO_VISITABLE(Symbol)

  //! Method to visit a LIEF::MachO::Relocation
  LIEF_MACHO_VISITABLE(Relocation)

  //! Method to visit a LIEF::MachO::RelocationObject
  LIEF_MACHO_VISITABLE(RelocationObject)

  //! Method to visit a LIEF::MachO::RelocationDyld
  LIEF_MACHO_VISITABLE(RelocationDyld)

  //! Method to visit a LIEF::MachO::RelocationFixup
  LIEF_MACHO_VISITABLE(RelocationFixup)

  //! Method to visit a LIEF::MachO::BindingInfo
  LIEF_MACHO_VISITABLE(BindingInfo)

  //! Method to visit a LIEF::MachO::DyldBindingInfo
  LIEF_MACHO_VISITABLE(DyldBindingInfo)

  //! Method to visit a LIEF::MachO::ChainedBindingInfo
  LIEF_MACHO_VISITABLE(ChainedBindingInfo)

  //! Method to visit a LIEF::MachO::DyldExportsTrie
  LIEF_MACHO_VISITABLE(DyldExportsTrie)

  //! Method to visit a LIEF::MachO::ExportInfo
  LIEF_MACHO_VISITABLE(ExportInfo)

  //! @brief Method to visit a LIEF::MachO::FunctionStarts
  LIEF_MACHO_VISITABLE(FunctionStarts)

  //! @brief Method to visit a LIEF::MachO::CodeSignature
  LIEF_MACHO_VISITABLE(CodeSignature)

  //! @brief Method to visit a LIEF::MachO::DataInCode
  LIEF_MACHO_VISITABLE(DataInCode)

  //! @brief Method to visit a LIEF::MachO::DataCodeEntry
  LIEF_MACHO_VISITABLE(DataCodeEntry)

  //! @brief Method to visit a LIEF::MachO::SourceVersion
  LIEF_MACHO_VISITABLE(SourceVersion)

  //! @brief Method to visit a LIEF::MachO::VersionMin
  LIEF_MACHO_VISITABLE(VersionMin)

  //! @brief Method to visit a LIEF::MachO::SegmentSplitInfo
  LIEF_MACHO_VISITABLE(SegmentSplitInfo)

  //! @brief Method to visit a LIEF::MachO::SubFramework
  LIEF_MACHO_VISITABLE(SubFramework)

  //! @brief Method to visit a LIEF::MachO::DyldEnvironment
  LIEF_MACHO_VISITABLE(DyldEnvironment)

  //! @brief Method to visit a LIEF::MachO::DyldEnvironment
  LIEF_MACHO_VISITABLE(EncryptionInfo)

  //! @brief Method to visit a LIEF::MachO:BuildVersion:
  LIEF_MACHO_VISITABLE(BuildVersion)

  //! @brief Method to visit a LIEF::MachO:BuildToolVersion:
  LIEF_MACHO_VISITABLE(BuildToolVersion)

  //! @brief Method to visit a LIEF::MachO:BuildToolVersion:
  LIEF_MACHO_VISITABLE(FilesetCommand)

  //! Method to visit a LIEF::MachO::CodeSignatureDir
  LIEF_MACHO_VISITABLE(CodeSignatureDir)

  //! Method to visit a LIEF::MachO::TwoLevelHints
  LIEF_MACHO_VISITABLE(TwoLevelHints)

  //! Method to visit a LIEF::MachO::LinkerOptHint
  LIEF_MACHO_VISITABLE(LinkerOptHint)

  //! @brief Method to visit a LIEF::MachO::UnknownCommand
  LIEF_MACHO_VISITABLE(UnknownCommand)

  // OAT part
  // ========

  //! Method to visit a LIEF::OAT::Binary
  LIEF_OAT_VISITABLE(Binary)

  //! Method to visit a LIEF::OAT::Header
  LIEF_OAT_VISITABLE(Header)

  //! Method to visit a LIEF::OAT::DexFile
  LIEF_OAT_VISITABLE(DexFile)

  //! Method to visit a LIEF::OAT::Class
  LIEF_OAT_VISITABLE(Class)

  //! Method to visit a LIEF::OAT::Method
  LIEF_OAT_VISITABLE(Method)


  // DEX part
  // ========

  //! Method to visit a LIEF::DEX::File
  LIEF_DEX_VISITABLE(File)

//! Method to visit a LIEF::DEX::Field
  LIEF_DEX_VISITABLE(Field)

  //! Method to visit a LIEF::DEX::Method
  LIEF_DEX_VISITABLE(Method)

  //! Method to visit a LIEF::DEX::Header
  LIEF_DEX_VISITABLE(Header)

  //! Method to visit a LIEF::DEX::Class
  LIEF_DEX_VISITABLE(Class)

  //! Method to visit a LIEF::DEX::CodeInfo
  LIEF_DEX_VISITABLE(CodeInfo)

  //! Method to visit a LIEF::DEX::Type
  LIEF_DEX_VISITABLE(Type)

  //! Method to visit a LIEF::DEX:Prototype:
  LIEF_DEX_VISITABLE(Prototype)

  //! Method to visit a LIEF::DEX:MapList:
  LIEF_DEX_VISITABLE(MapList)

  //! Method to visit a LIEF::DEX:MapItem:
  LIEF_DEX_VISITABLE(MapItem)

  // VDEX part
  // =========

  //! Method to visit a LIEF::VDEX::File
  LIEF_VDEX_VISITABLE(File)

  //! Method to visit a LIEF::VDEX::Header
  LIEF_VDEX_VISITABLE(Header)

  // ART part
  // =========

  //! Method to visit a LIEF::ART::File
  LIEF_ART_VISITABLE(File)

  //! Method to visit a LIEF::ART::Header
  LIEF_ART_VISITABLE(Header)

  template<class T>
  void dispatch(const T& obj);


  private:
  std::set<size_t> visited_;
};



template<typename Arg1, typename... Args>
void Visitor::operator()(Arg1&& arg1, Args&&... args) {
  dispatch(std::forward<Arg1>(arg1));
  operator()(std::forward<Args>(args)... );
}

template<class T>
void Visitor::dispatch(const T& obj) {
  auto hash = reinterpret_cast<size_t>(&obj);
  if (visited_.find(hash) != std::end(visited_)) {
    // Already visited
    return;
  }

  visited_.insert(hash);
  visit(obj);
}

}
#endif

```

`KDemu/include/LIEF/LIEF/canbe_unique.hpp`:

```hpp
/* Copyright 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_CAN_BE_UNIQUE_H
#define LIEF_CAN_BE_UNIQUE_H
#include <memory>

namespace LIEF {
namespace details {
template<class T>
class canbe_unique {
  public:
  canbe_unique() = default;
  canbe_unique(const canbe_unique&) = delete;
  canbe_unique& operator=(const canbe_unique&) = delete;

  canbe_unique& operator=(std::nullptr_t) {
    reset();
    return *this;
  }

  canbe_unique(canbe_unique&& other) noexcept {
    std::swap(ptr_, other.ptr_);
    owned_ = other.owned_;
  }

  canbe_unique& operator=(canbe_unique&& other) noexcept {
    if (&other != this) {
      std::swap(ptr_, other.ptr_);
      owned_ = other.owned_;
    }
    return *this;
  }

  canbe_unique(T& ptr) :
    ptr_(&ptr),
    owned_(false)
  {}

  canbe_unique(const T& ptr) :
    ptr_(const_cast<T*>(&ptr)),
    owned_(false)
  {}

  canbe_unique(std::unique_ptr<T> unique_ptr) :
    ptr_(unique_ptr.release()),
    owned_(true)
  {}

  T* get() {
    return ptr_;
  }

  const T* get() const {
    return ptr_;
  }

  T* operator->() {
    return ptr_;
  }

  const T* operator->() const {
    return ptr_;
  }

  T& operator*() {
    return *ptr_;
  }

  const T& operator*() const {
    return *ptr_;
  }

  void reset() {
    if (!owned_) {
      return;
    }
    if (ptr_ != nullptr) {
      delete ptr_;
    }
    ptr_ = nullptr;
  }

  operator bool() const {
    return ptr_ != nullptr;
  }

  ~canbe_unique() {
    reset();
  }

  private:
  T* ptr_ = nullptr;
  bool owned_ = false;
};

template<class T>
inline bool operator==(const canbe_unique<T>& lhs, std::nullptr_t) {
  return !lhs;
}

template<class T>
inline bool operator==(std::nullptr_t, const canbe_unique<T>& lhs) {
  return !lhs;
}

}
}
#endif

```

`KDemu/include/LIEF/LIEF/compiler_attributes.hpp`:

```hpp
/* Copyright 2021 - 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_COMPILER_ATTR_H
#define LIEF_COMPILER_ATTR_H

#if !defined(_MSC_VER)
#   if __cplusplus >= 201103L
#     define LIEF_CPP11
#     if __cplusplus >= 201402L
#       define LIEF_CPP14
#       if __cplusplus >= 201703L
#         define LIEF_CPP17
#         if __cplusplus >= 202002L
#           define LIEF_CPP20
#         endif
#       endif
#     endif
#   endif
#elif defined(_MSC_VER)
#   if _MSVC_LANG >= 201103L
#     define LIEF_CPP11
#     if _MSVC_LANG >= 201402L
#       define LIEF_CPP14
#       if _MSVC_LANG > 201402L
#         define LIEF_CPP17
#         if _MSVC_LANG >= 202002L
#           define LIEF_CPP20
#         endif
#       endif
#     endif
#   endif
#endif

#if defined(__MINGW32__)
#   define LIEF_DEPRECATED(reason)
#elif defined(LIEF_CPP14)
#   define LIEF_DEPRECATED(reason) [[deprecated(reason)]]
#else
#   define LIEF_DEPRECATED(reason) __attribute__((deprecated(reason)))
#endif

#endif

```

`KDemu/include/LIEF/LIEF/config.h`:

```h
/* Copyright 2017 - 2021 A. Guinet
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef LIEF_CONFIG_H
#define LIEF_CONFIG_H

// Main formats
#define LIEF_PE_SUPPORT       1
#define LIEF_ELF_SUPPORT      1
#define LIEF_MACHO_SUPPORT    1

// Android formats
#define LIEF_OAT_SUPPORT      1
#define LIEF_DEX_SUPPORT      1
#define LIEF_VDEX_SUPPORT     1
#define LIEF_ART_SUPPORT      1

// Extended features
/* #undef LIEF_DEBUG_INFO */
/* #undef LIEF_OBJC */
/* #undef LIEF_EXTENDED */

// LIEF options
#define LIEF_JSON_SUPPORT      1
#define LIEF_LOGGING_SUPPORT   1
#define LIEF_LOGGING_DEBUG     1
#define LIEF_FROZEN_ENABLED    1
/* #undef LIEF_EXTERNAL_EXPECTED */
/* #undef LIEF_EXTERNAL_UTF8CPP */
/* #undef LIEF_EXTERNAL_MBEDTLS */
/* #undef LIEF_EXTERNAL_FROZEN */
/* #undef LIEF_EXTERNAL_SPAN */

/* #undef LIEF_NLOHMANN_JSON_EXTERNAL */


#ifdef __cplusplus

static constexpr bool lief_pe_support      = 1;
static constexpr bool lief_elf_support     = 1;
static constexpr bool lief_macho_support   = 1;

static constexpr bool lief_oat_support     = 1;
static constexpr bool lief_dex_support     = 1;
static constexpr bool lief_vdex_support    = 1;
static constexpr bool lief_art_support     = 1;

static constexpr bool lief_debug_info      = 0;
static constexpr bool lief_objc            = 0;
static constexpr bool lief_extended        = 0;

static constexpr bool lief_json_support    = 1;
static constexpr bool lief_logging_support = 1;
static constexpr bool lief_logging_debug   = 1;
static constexpr bool lief_frozen_enabled  = 1;


#endif // __cplusplus

#endif

```

`KDemu/include/LIEF/LIEF/debug_loc.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_DEBUG_LOCATION_H
#define LIEF_DEBUG_LOCATION_H
#include <string>
#include <cstdint>

namespace LIEF {
/// This structure holds a debug location (source filename & line)
struct debug_location_t {
  std::string file;
  uint64_t line = 0;
};

}
#endif

```

`KDemu/include/LIEF/LIEF/enums.hpp`:

```hpp
/* Copyright 2021 - 2024 R. Thomas
 * Copyright 2021 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ENUMS_H
#define LIEF_ENUMS_H
#include <type_traits>

#define _LIEF_EN(N) class N : size_t
#define _LIEF_EN_2(N, TYPE) class N : TYPE
#define _LIEF_EI(X) X

#define ENABLE_BITMASK_OPERATORS(X)  \
template<>                           \
struct EnableBitMaskOperators<X>     \
{                                    \
  static const bool bit_mask_enabled = true;   \
};

template<typename Enum>
struct EnableBitMaskOperators
{
  static const bool bit_mask_enabled = false;
};

template<typename Enum>
typename std::enable_if<EnableBitMaskOperators<Enum>::bit_mask_enabled, Enum>::type
operator |(Enum lhs, Enum rhs)
{
    using underlying = typename std::underlying_type<Enum>::type;
    return static_cast<Enum> (
        static_cast<underlying>(lhs) |
        static_cast<underlying>(rhs)
    );
}

template<typename Enum>
typename std::enable_if<EnableBitMaskOperators<Enum>::bit_mask_enabled, Enum>::type
operator &(Enum lhs, Enum rhs)
{
    using underlying = typename std::underlying_type<Enum>::type;
    return static_cast<Enum> (
        static_cast<underlying>(lhs) &
        static_cast<underlying>(rhs)
    );
}

template<typename Enum>
typename std::enable_if<EnableBitMaskOperators<Enum>::bit_mask_enabled, Enum>::type
operator ~(Enum e)
{
    using underlying = typename std::underlying_type<Enum>::type;
    return static_cast<Enum>(~static_cast<underlying>(e));
}

template<typename Enum>
typename std::enable_if<EnableBitMaskOperators<Enum>::bit_mask_enabled, typename std::add_lvalue_reference<Enum>::type>::type
operator |=(Enum& lhs, Enum rhs)
{
    using underlying = typename std::underlying_type<Enum>::type;
    lhs = static_cast<Enum>(static_cast<underlying>(lhs) | static_cast<underlying>(rhs));
    return lhs;
}

template<typename Enum>
typename std::enable_if<EnableBitMaskOperators<Enum>::bit_mask_enabled, typename std::add_lvalue_reference<Enum>::type>::type
operator &=(Enum& lhs, Enum rhs)
{
    using underlying = typename std::underlying_type<Enum>::type;
    lhs = static_cast<Enum>(static_cast<underlying>(lhs) & static_cast<underlying>(rhs));
    return lhs;
}

template<typename Enum>
typename std::enable_if<EnableBitMaskOperators<Enum>::bit_mask_enabled, bool>::type
is_true(Enum e)
{
  using underlying = typename std::underlying_type<Enum>::type;
  return static_cast<underlying>(e) > 0;
}
#endif

```

`KDemu/include/LIEF/LIEF/errors.hpp`:

```hpp
/* Copyright 2021 - 2024 R. Thomas
 * Copyright 2021 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ERROR_H
#define LIEF_ERROR_H
#include <cstdint>
#include <LIEF/third-party/expected.hpp>
#include <cstdint>

//! LIEF error codes definition
enum class lief_errors : uint32_t {
  read_error = 1,
  not_found,
  not_implemented,
  not_supported,

  corrupted,
  conversion_error,

  read_out_of_bound,
  asn1_bad_tag,
  file_error,

  file_format_error,
  parsing_error,
  build_error,

  data_too_large,
  /*
   * When adding a new error, do not forget
   * to update the Python bindings as well (pyErr.cpp) and Rust bindings:
   * lief/src/error.rs
   */
};

const char* to_string(lief_errors err);

//! Create an standard error code from lief_errors
inline tl::unexpected<lief_errors> make_error_code(lief_errors e) {
  return tl::make_unexpected(e);
}


namespace LIEF {
//! Wrapper that contains an Object (``T``) or an error
//!
//! The tl/expected implementation exposes the method ``value()`` to access the underlying object (if no error)
//!
//! Typical usage is:
//!
//! \code{.cpp}
//! result<int> intval = my_function();
//! if (intval) {
//!  int val = intval.value();
//! } else { // There is an error
//!  std::cout << get_error(intval).message() << "\n";
//! }
//! \endcode
//!
//! See https://tl.tartanllama.xyz/en/latest/api/expected.html for more details
template<typename T>
using result = tl::expected<T, lief_errors>;

//! Get the error code associated with the result
template<class T>
lief_errors get_error(result<T>& err) {
  return err.error();
}

//! Return the lief_errors when the provided ``result<T>`` is an error
template<class T>
lief_errors as_lief_err(result<T>& err) {
  return err.error();
}

//! Opaque structure used by ok_error_t
struct ok_t {};

//! Return success for function with return type ok_error_t.
inline ok_t ok() {
  return ok_t{};
}

//! Opaque structure that is used by LIEF to avoid
//! writing ``result<void> f(...)``. Instead, it makes the output
//! explicit such as:
//!
//! \code{.cpp}
//! ok_error_t process() {
//!   if (fail) {
//!     return make_error_code(...);
//!   }
//!   return ok();
//! }
//! \endcode
using ok_error_t = result<ok_t>;

inline bool is_ok(const ok_error_t& val) {
  return val.has_value();
}

inline bool is_err(const ok_error_t& val) {
  return !is_ok(val);
}

}





#endif

```

`KDemu/include/LIEF/LIEF/hash.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_HASH_H
#define LIEF_HASH_H

#include <ostream>
#include <vector>

#include "LIEF/visibility.h"
#include "LIEF/Object.hpp"
#include "LIEF/Visitor.hpp"
#include "LIEF/span.hpp"


namespace LIEF {


class LIEF_API Hash : public Visitor {
  public:
  using value_type = size_t;
  template<class H = Hash>
  static value_type hash(const Object& obj);

  static value_type hash(const std::vector<uint8_t>& raw);
  static value_type hash(span<const uint8_t> raw);
  static value_type hash(const void* raw, size_t size);

  // combine two elements to produce a size_t.
  template<typename U = value_type>
  static value_type combine(value_type lhs, U rhs) {
    return (lhs ^ rhs) + 0x9e3779b9 + (lhs << 6) + (rhs >> 2);
  }

  public:
  using Visitor::visit;
  Hash();
  Hash(value_type init_value);

  virtual Hash& process(const Object& obj);
  virtual Hash& process(size_t integer);
  virtual Hash& process(const std::string& str);
  virtual Hash& process(const std::u16string& str);
  virtual Hash& process(const std::vector<uint8_t>& raw);
  virtual Hash& process(span<const uint8_t> raw);

  template<class T, typename = typename std::enable_if<std::is_enum<T>::value>::type>
  Hash& process(T v) {
    return process(static_cast<value_type>(v));
  }

  template<class It>
  Hash& process(typename It::iterator v) {
    return process(std::begin(v), std::end(v));
  }


  template<class T, size_t N>
  Hash& process(const std::array<T, N>& array) {
    process(std::begin(array), std::end(array));
    return *this;
  }

  template<class T>
  Hash& process(const std::vector<T>& vector) {
    process(std::begin(vector), std::end(vector));
    return *this;
  }

  template<class T>
  Hash& process(const std::set<T>& set) {
    process(std::begin(set), std::end(set));
    return *this;
  }

  template<class U, class V>
  Hash& process(const std::pair<U, V>& p) {
    process(p.first);
    process(p.second);
    return *this;
  }

  template<class InputIt>
  Hash& process(InputIt begin, InputIt end) {
    for (auto&& it = begin; it != end; ++it) {
      process(*it);
    }
    return *this;
  }

  value_type value() const {
    return value_;
  }

  ~Hash() override;

  protected:
  value_type value_ = 0;

};

LIEF_API Hash::value_type hash(const Object& v);
LIEF_API Hash::value_type hash(const std::vector<uint8_t>& raw);
LIEF_API Hash::value_type hash(span<const uint8_t> raw);

template<class Hasher>
Hash::value_type Hash::hash(const Object& obj) {
  Hasher hasher;
  obj.accept(hasher);
  return hasher.value();
}

}


#endif

```

`KDemu/include/LIEF/LIEF/iostream.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_OSTREAM_H
#define LIEF_OSTREAM_H
#include <limits>
#include <ios>
#include <cstdint>
#include <cstring>
#include <vector>
#include <array>

#include "LIEF/span.hpp"
#include "LIEF/BinaryStream/Convert.hpp"

namespace LIEF {
class vector_iostream {
  public:
  static size_t uleb128_size(uint64_t value);
  static size_t sleb128_size(int64_t value);
  using pos_type = std::streampos;
  using off_type = std::streamoff;
  vector_iostream() = default;
  vector_iostream(bool endian_swap) :
    endian_swap_(endian_swap)
  {}
  void reserve(size_t size) {
    raw_.reserve(size);
  }

  vector_iostream& put(uint8_t c);
  vector_iostream& write(const uint8_t* s, std::streamsize n);
  vector_iostream& write(span<const uint8_t> sp) {
    return write(sp.data(), sp.size());
  }

  vector_iostream& write(std::vector<uint8_t> s);
  vector_iostream& write(const std::string& s);
  vector_iostream& write(size_t count, uint8_t value) {
    raw_.insert(std::end(raw_), count, value);
    current_pos_ += count;
    return *this;
  }
  vector_iostream& write_sized_int(uint64_t value, size_t size) {
    const uint64_t stack_val = value;
    return write(reinterpret_cast<const uint8_t*>(&stack_val), size);
  }
  vector_iostream& write(const vector_iostream& other) {
    return write(other.raw());
  }

  template<class T, typename = typename std::enable_if<std::is_standard_layout<T>::value && std::is_trivial<T>::value>::type>
  vector_iostream& write(const T& t) {
    const auto pos = static_cast<size_t>(tellp());
    if (raw_.size() < (pos + sizeof(T))) {
      raw_.resize(pos + sizeof(T));
    }
    memcpy(raw_.data() + pos, &t, sizeof(T));
    current_pos_ += sizeof(T);
    return *this;
  }

  template<typename T>
  vector_iostream& write_conv(const T& t);

  template<typename T>
  vector_iostream& write_conv_array(const std::vector<T>& v);

  vector_iostream& align(size_t alignment, uint8_t fill = 0);

  template<typename T, size_t size>
  vector_iostream& write(const std::array<T, size>& t) {
    static_assert(std::numeric_limits<T>::is_integer, "Requires integer type");
    for (T val : t) {
      write<T>(val);
    }
    return *this;
  }


  template<typename T>
  vector_iostream& write(const std::vector<T>& elements) {
    for (const T& e : elements) {
      write(e);
    }
    return *this;
  }

  vector_iostream& write_uleb128(uint64_t value);
  vector_iostream& write_sleb128(int64_t value);

  vector_iostream& get(std::vector<uint8_t>& c) {
    c = raw_;
    return *this;
  }
  vector_iostream& move(std::vector<uint8_t>& c) {
    c = std::move(raw_);
    return *this;
  }

  vector_iostream& flush() {
    return *this;
  }

  size_t size() const {
    return raw_.size();
  }

  // seeks:
  pos_type tellp() const {
    return current_pos_;
  }

  vector_iostream& seekp(pos_type p) {
    current_pos_ = p;
    return *this;
  }

  vector_iostream& seekp(vector_iostream::off_type p, std::ios_base::seekdir dir);

  const std::vector<uint8_t>& raw() const {
    return raw_;
  }

  std::vector<uint8_t>& raw() {
    return raw_;
  }

  void set_endian_swap(bool swap) {
    endian_swap_ = swap;
  }

  private:
  pos_type             current_pos_ = 0;
  std::vector<uint8_t> raw_;
  bool                 endian_swap_ = false;
};


template<typename T>
vector_iostream& vector_iostream::write_conv(const T& t) {
  const uint8_t *ptr = nullptr;
  T tmp = t;
  if (endian_swap_) {
    LIEF::Convert::swap_endian<T>(&tmp);
    ptr = reinterpret_cast<const uint8_t*>(&tmp);
  } else {
    ptr = reinterpret_cast<const uint8_t*>(&t);
  }
  write(ptr, sizeof(T));
  return *this;
}

template<typename T>
vector_iostream& vector_iostream::write_conv_array(const std::vector<T>& v) {
  for (const T& i: v) {
    const uint8_t* ptr = nullptr;
    T tmp = i;
    if (endian_swap_) {
      LIEF::Convert::swap_endian<T>(&tmp);
      ptr = reinterpret_cast<const uint8_t*>(&tmp);
    } else {
      ptr = reinterpret_cast<const uint8_t*>(&i);
    }
    write(ptr, sizeof(T));
  }
  return *this;
}


}
#endif

```

`KDemu/include/LIEF/LIEF/iterators.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 * Copyright 2017 - 2021, NVIDIA CORPORATION. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_ITERATORS_H
#define LIEF_ITERATORS_H
#include <ostream>
#include <cmath>
#include <cstddef>
#include <cassert>
#include <iterator>
#include <functional>
#include <algorithm>
#include <type_traits>
#include <vector>


namespace LIEF {

template<class T>
using decay_t = typename std::decay<T>::type;

template<class T>
using add_const_t = typename std::add_const<T>::type;

template<class T>
using remove_const_t = typename std::remove_const<T>::type;

template< class T >
using add_lvalue_reference_t = typename std::add_lvalue_reference<T>::type;


//! Iterator which returns reference on container's values
template<class T, typename U = typename decay_t<T>::value_type,
         class ITERATOR_T = typename decay_t<T>::iterator>
class ref_iterator {
  public:
  using iterator_category = std::bidirectional_iterator_tag;
  using value_type = decay_t<U>;
  using difference_type = ptrdiff_t;
  using pointer = typename std::remove_pointer<U>::type*;
  using reference = typename std::remove_pointer<U>::type&;

  using container_type = T;          // e.g. std::vector<Section*>&
  using DT_VAL         = U;          // e.g. Section*
  using DT             = decay_t<T>; // e.g. std::vector<Section>
  using ref_t          = typename ref_iterator::reference;
  using pointer_t      = typename ref_iterator::pointer;

  ref_iterator(T container) :
    container_{std::forward<T>(container)}
  {
    it_ = std::begin(container_);
  }

  ref_iterator(const ref_iterator& copy) :
    container_{copy.container_},
    it_{std::begin(container_)},
    distance_{copy.distance_}
  {
    std::advance(it_, distance_);
  }


  ref_iterator& operator=(ref_iterator other) {
    swap(other);
    return *this;
  }

  void swap(ref_iterator& other) noexcept {
    std::swap(const_cast<add_lvalue_reference_t<remove_const_t<DT>>>(container_),
              const_cast<add_lvalue_reference_t<remove_const_t<DT>>>(other.container_));
    std::swap(it_, other.it_);
    std::swap(distance_, other.distance_);
  }


  ref_iterator& operator++() {
    it_ = std::next(it_);
    distance_++;
    return *this;
  }

  ref_iterator operator++(int) {
    ref_iterator retval = *this;
    ++(*this);
    return retval;
  }

  ref_iterator& operator--() {
    if (it_ != std::begin(container_)) {
      it_ = std::prev(it_);
      distance_--;
    }
    return *this;
  }

  ref_iterator operator--(int) {
    ref_iterator retval = *this;
    --(*this);
    return retval;
  }


  ref_iterator& operator+=(const typename ref_iterator::difference_type& movement) {
    std::advance(it_, movement);
    distance_ += movement;
    return *this;
  }


  ref_iterator& operator-=(const typename ref_iterator::difference_type& movement) {
    return (*this) += -movement;
  }


  typename std::enable_if<!std::is_const<ref_t>::value, remove_const_t<ref_t>>::type
  operator[](size_t n) {
    return const_cast<remove_const_t<ref_t>>(static_cast<const ref_iterator*>(this)->operator[](n));
  }


  add_const_t<ref_t> operator[](size_t n) const {
    assert(n < size() && "integrity error: out of bound");

    auto* no_const_this = const_cast<ref_iterator*>(this);

    typename ref_iterator::difference_type saved_dist = std::distance(std::begin(no_const_this->container_), no_const_this->it_);
    no_const_this->it_ = std::begin(no_const_this->container_);
    std::advance(no_const_this->it_, n);

    auto&& v = const_cast<add_const_t<ref_t>>(no_const_this->operator*());

    no_const_this->it_ = std::begin(no_const_this->container_);
    std::advance(no_const_this->it_, saved_dist);

    return v;
  }

  ref_iterator operator+(typename ref_iterator::difference_type n) const {
    ref_iterator tmp = *this;
    return tmp += n;
  }


  ref_iterator operator-(typename ref_iterator::difference_type n) const {
    ref_iterator tmp = *this;
    return tmp -= n;
  }


  typename ref_iterator::difference_type operator-(const ref_iterator& rhs) const {
    return distance_ - rhs.distance_;
  }

  bool operator<(const ref_iterator& rhs) const {
    return (rhs - *this) > 0;
  }


  bool operator>(const ref_iterator& rhs) const {
    return rhs < *this;
  }


  bool operator>=(const ref_iterator& rhs) const {
    return !(*this < rhs);
  }


  bool operator<=(const ref_iterator& rhs) const {
    return !(*this > rhs);
  }

  ref_iterator begin() const {
    return container_;
  }

  ref_iterator cbegin() const {
    return begin();
  }

  ref_iterator end()  const {
    ref_iterator it = ref_iterator{container_};
    it.it_ = std::end(it.container_);
    it.distance_ = it.size();
    return it;
  }

  ref_iterator cend() const {
    return end();
  }

  bool operator==(const ref_iterator& other) const {
    return (size() == other.size() && distance_ == other.distance_);
  }

  bool operator!=(const ref_iterator& other) const {
    return !(*this == other);
  }

  size_t size() const {
    return container_.size();
  }

  bool empty() const {
    return container_.empty();
  }

  typename std::enable_if<!std::is_const<ref_t>::value, remove_const_t<ref_t>>::type
  operator*() {
    return const_cast<remove_const_t<ref_t>>(static_cast<const ref_iterator*>(this)->operator*());
  }

  template<typename V = DT_VAL>
  typename std::enable_if<std::is_pointer<V>::value, add_const_t<ref_t>>::type
  operator*() const {
    assert(*it_ && "integrity error: nullptr");
    return const_cast<add_const_t<ref_t>>(static_cast<ref_t>(**it_));
  }

  template<typename V = DT_VAL>
  typename std::enable_if<!std::is_pointer<V>::value, add_const_t<ref_t>>::type
  operator*() const {
    return const_cast<add_const_t<ref_t>>(*(it_));
  }


  typename std::enable_if<!std::is_const<pointer_t>::value, pointer_t>::type
  operator->() {
    return const_cast<remove_const_t<pointer_t>>(static_cast<const ref_iterator*>(this)->operator->());
  }

  add_const_t<pointer_t> operator->() const {
    return const_cast<add_const_t<pointer_t>>(&(operator*()));
  }

  protected:
  T container_;
  ITERATOR_T it_;
  typename ref_iterator::difference_type distance_{};
};


//! Iterator which return const ref on container's values
template<class T, typename U = typename decay_t<T>::value_type, class CT = typename std::add_const<T>::type>
using const_ref_iterator = ref_iterator<CT, U, typename decay_t<CT>::const_iterator>;


//! Iterator which return a ref on container's values given predicates
template<class T, typename U = typename decay_t<T>::value_type,
         class ITERATOR_T = typename decay_t<T>::iterator>
class filter_iterator {

  public:
  using iterator_category = std::forward_iterator_tag;
  using value_type = decay_t<U>;
  using difference_type = ptrdiff_t;
  using pointer = typename std::remove_pointer<U>::type*;
  using reference = typename std::remove_pointer<U>::type&;

  using container_type = T;
  using DT_VAL         = U;
  using DT        = decay_t<T>;
  using ref_t     = typename filter_iterator::reference;
  using pointer_t = typename filter_iterator::pointer;
  using filter_t  = std::function<bool (const typename DT::value_type&)>;

  filter_iterator(T container, filter_t filter) :
    container_{std::forward<T>(container)},
    filters_{}
  {

    it_ = std::begin(container_);

    filters_.push_back(filter),
    it_ = std::begin(container_);

    if (it_ != std::end(container_)) {
      if (!std::all_of(std::begin(filters_), std::end(filters_), [this] (const filter_t& f) {return f(*it_);})) {
        next();
      }
    }
  }

  filter_iterator(T container, const std::vector<filter_t>& filters) :
    container_{std::forward<T>(container)},
    filters_{filters}
  {

    it_ = std::begin(container_);

    if (it_ != std::end(container_)) {
      if (!std::all_of(std::begin(filters_), std::end(filters_), [this] (const filter_t& f) {return f(*it_);})) {
        next();
      }
    }
  }

  filter_iterator(T container) :
    container_{std::forward<T>(container)},
    filters_{}
  {
    it_ = std::begin(container_);
  }

  filter_iterator(const filter_iterator& copy) :
    container_{copy.container_},
    it_{std::begin(container_)},
    filters_{copy.filters_},
    distance_{copy.distance_}
  {
    std::advance(it_, distance_);
  }

  filter_iterator& operator=(filter_iterator other) {
    swap(other);
    return *this;
  }

  void swap(filter_iterator& other) noexcept {
    std::swap(const_cast<remove_const_t<DT>&>(container_), const_cast<remove_const_t<DT>&>(other.container_));
    std::swap(it_,        other.it_);
    std::swap(filters_,   other.filters_);
    std::swap(size_c_,    other.size_c_);
    std::swap(distance_,  other.distance_);
  }


  filter_iterator& def(filter_t func) {
    filters_.push_back(func);
    size_c_ = 0;
    return *this;
  }

  filter_iterator& operator++() {
    next();
    return *this;
  }

  filter_iterator operator++(int) {
    filter_iterator retval = *this;
    ++(*this);
    return retval;
  }

  filter_iterator begin() const {
    return {container_, filters_};
  }

  filter_iterator cbegin() const {
    return begin();
  }

  filter_iterator end() const {
    // we don't need filter for the end iterator
    filter_iterator it_end{container_};

    it_end.it_       =  it_end.container_.end();
    it_end.distance_ = it_end.container_.size();

    return it_end;
  }

  filter_iterator cend() const {
    return end();
  }

  typename std::enable_if<!std::is_const<ref_t>::value, remove_const_t<ref_t>>::type
  operator*() {
    return const_cast<remove_const_t<ref_t>>(static_cast<const filter_iterator*>(this)->operator*());
  }

  template<typename V = DT_VAL>
  typename std::enable_if<std::is_pointer<V>::value, add_const_t<ref_t>>::type
  operator*() const {
    assert(*it_ && "integrity error: nullptr");
    return const_cast<add_const_t<ref_t>>(static_cast<ref_t>(**it_));
  }

  template<typename V = DT_VAL>
  typename std::enable_if<!std::is_pointer<V>::value, add_const_t<ref_t>>::type
  operator*() const {
    return const_cast<add_const_t<ref_t>>(*(it_));
  }


  typename std::enable_if<!std::is_const<ref_t>::value, remove_const_t<ref_t>>::type
  operator[](size_t n) {
    return const_cast<remove_const_t<ref_t>>(static_cast<const filter_iterator*>(this)->operator[](n));
  }

  add_const_t<ref_t> operator[](size_t n) const {
    assert(n < size() && "integrity error: out of bound");

    auto it = begin();
    std::advance(it, n);
    return const_cast<add_const_t<ref_t>>(*it);
  }


  typename std::enable_if<!std::is_const<pointer_t>::value, pointer_t>::type
  operator->() {
    return const_cast<remove_const_t<pointer_t>>(static_cast<const filter_iterator*>(this)->operator->());
  }

  add_const_t<pointer_t> operator->() const {
    return const_cast<add_const_t<pointer_t>>(&(operator*()));
  }

  size_t size() const {
    if (filters_.empty()) {
      return container_.size();
    }

    if (size_c_ > 0) {
      return size_c_;
    }
    filter_iterator it = begin();
    size_t size = 0;

    auto end_iter = std::end(it);
    for (; it != end_iter; ++it) ++size;
    size_c_ = size;
    return size_c_;
  }


  bool empty() const {
    return size() == 0;
  }


  bool operator==(const filter_iterator& other) const {
    return (container_.size() == other.container_.size() && distance_ == other.distance_);
  }

  bool operator!=(const filter_iterator& other) const {
    return !(*this == other);
  }

  protected:
  void next() {
    if (it_ == std::end(container_)) {
      distance_ = container_.size();
      return;
    }

    do {
      it_ = std::next(it_);
      distance_++;
    } while(it_ != std::end(container_) &&
            !std::all_of(std::begin(filters_), std::end(filters_),
                         [this] (const filter_t& f) { return f(*it_); }));

  }


  mutable size_t size_c_ = 0;
  T container_;
  ITERATOR_T it_;
  std::vector<filter_t> filters_;
  typename filter_iterator::difference_type distance_ = 0;
};

//! Iterator which return a const ref on container's values given predicates
template<class T, typename U = typename decay_t<T>::value_type,
         class CT = typename std::add_const<T>::type>
using const_filter_iterator = filter_iterator<CT, U, typename decay_t<CT>::const_iterator>;


template <typename IteratorT>
class iterator_range {
  public:
  using IteratorTy = IteratorT;
  iterator_range(IteratorT it_begin, IteratorT it_end)
      : begin_(std::move(it_begin)),
        end_(std::move(it_end)) {}

  IteratorT begin() const { return begin_; }
  IteratorT end() const { return end_; }
  bool empty() const { return begin_ == end_; }
  private:
  IteratorT begin_;
  IteratorT end_;
};

template <class T> iterator_range<T> make_range(T x, T y) {
  return iterator_range<T>(std::move(x), std::move(y));
}

}

#endif

```

`KDemu/include/LIEF/LIEF/json.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_JSON_MAIN_H
#define LIEF_JSON_MAIN_H
#include <string>
#include <LIEF/visibility.h>
namespace LIEF {
class Object;

LIEF_API std::string to_json(const Object& v);

}
#endif

```

`KDemu/include/LIEF/LIEF/logging.h`:

```h
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <stdint.h>
#include "LIEF/visibility.h"

#ifndef C_LIEF_LOGGING_H_
#define C_LIEF_LOGGING_H_

#ifdef __cplusplus
extern "C" {
#endif

/** @brief Disable the logging module */
LIEF_API void lief_logging_disable(void);

/** @brief Enable the logging module globally*/
LIEF_API void lief_logging_enable(void);

/** @brief Update logging level */
LIEF_API void lief_logging_set_level(uint32_t level);

#ifdef __cplusplus
}
#endif

#endif


```

`KDemu/include/LIEF/LIEF/logging.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_LOGGING_H
#define LIEF_LOGGING_H

#include "LIEF/visibility.h"

#include <string>
#include <vector>

namespace spdlog {
class logger;
}

namespace LIEF {
namespace logging {

//! **Hierarchical** logging level
//!
//! From a given level set, all levels below this ! level are enabled
//!
//! For example, if LOG_INFO is enabled then LOG_WARN, LOG_ERR are also enabled
enum class LEVEL {
  TRACE = 0,
  DEBUG,
  INFO,
  WARN,
  ERR,
  CRITICAL,
};

LIEF_API const char* to_string(LEVEL e);

//! Globally disable the logging module
LIEF_API void disable();

//! Globally enable the logging module
LIEF_API void enable();

//! Change the logging level (**hierarchical**)
LIEF_API void set_level(LEVEL level);

//! Change the logger as a file-base logging and set its path
LIEF_API void set_path(const std::string& path);

//! Log a message with the LIEF's logger
LIEF_API void log(LEVEL level, const std::string& msg);

LIEF_API void log(LEVEL level, const std::string& fmt,
                  const std::vector<std::string>& args);

template <typename... Args>
void log(LEVEL level, const std::string& fmt, const Args &... args) {
  std::vector<std::string> vec_args;
  vec_args.insert(vec_args.end(), { static_cast<decltype(vec_args)::value_type>(args)...});
  return log(level, fmt, vec_args);
}

LIEF_API void set_logger(const spdlog::logger& logger);

LIEF_API void reset();

}
}

#endif

```

`KDemu/include/LIEF/LIEF/platforms.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PLATFORMS_H
#define LIEF_PLATFORMS_H
#include "LIEF/platforms/android.hpp"

#if defined(__APPLE__)
  #include "TargetConditionals.h"
#endif

namespace LIEF {

enum class PLATFORMS {
  UNKNOWN = 0,
  LINUX,
  ANDROID_PLAT,
  WINDOWS,
  IOS,
  OSX,
};

constexpr PLATFORMS current_platform() {
#if defined(__ANDROID__)
  return PLATFORMS::ANDROID_PLAT;
#elif defined(__linux__)
  return PLATFORMS::LINUX;
#elif defined(_WIN64) || defined(_WIN32)
  return PLATFORMS::WINDOWS;
#elif defined(__APPLE__)
  #if defined(TARGET_OS_IPHONE) && TARGET_OS_IPHONE
    return PLATFORMS::IOS;
  #else
    return PLATFORMS::OSX;
  #endif
#else
  return PLATFORMS::UNKNOWN;
#endif

}


}

#endif

```

`KDemu/include/LIEF/LIEF/platforms/android.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PLATFORMS_ANDROID_H
#define LIEF_PLATFORMS_ANDROID_H
#include "LIEF/platforms/android/version.hpp"
#endif

```

`KDemu/include/LIEF/LIEF/platforms/android/version.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_PLATFORMS_ANDROID_VERSIONS_H
#define LIEF_PLATFORMS_ANDROID_VERSIONS_H
#include "LIEF/visibility.h"

namespace LIEF {
namespace Android {

enum class ANDROID_VERSIONS {
  VERSION_UNKNOWN = 0,
  VERSION_601     = 1,

  VERSION_700     = 2,
  VERSION_710     = 3,
  VERSION_712     = 4,

  VERSION_800     = 5,
  VERSION_810     = 6,

  VERSION_900     = 7,
};

LIEF_API const char* code_name(ANDROID_VERSIONS version);
LIEF_API const char* version_string(ANDROID_VERSIONS version);
LIEF_API const char* to_string(ANDROID_VERSIONS version);


}
}
#endif

```

`KDemu/include/LIEF/LIEF/range.hpp`:

```hpp
/* Copyright 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_RANGE_H
#define LIEF_RANGE_H
#include <cstdint>
#include <ostream>

namespace LIEF {
struct range_t {
  uint64_t low = 0;
  uint64_t high = 0;

  uint64_t size() const {
    return high - low;
  }

  friend std::ostream& operator<<(std::ostream& os, const range_t& range);
};

}
#endif

```

`KDemu/include/LIEF/LIEF/span.hpp`:

```hpp
/* Copyright 2021 - 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_SPAN_H
#define LIEF_SPAN_H
#include <LIEF/third-party/span.hpp>

namespace LIEF {

template <typename ElementType, std::size_t Extent = tcb::dynamic_extent>
using span = tcb::span<ElementType, Extent>;
}

#endif

```

`KDemu/include/LIEF/LIEF/third-party/expected.hpp`:

```hpp
/* Copyright 2021 - 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_EXPECTED_H
#define LIEF_EXPECTED_H
#include "LIEF/config.h"

#undef TL_EXPECTED_EXCEPTIONS_ENABLED

#ifndef LIEF_EXTERNAL_EXPECTED
#include <LIEF/third-party/internal/expected.hpp>
#else
#include <tl/expected.hpp>
#endif

#endif

```

`KDemu/include/LIEF/LIEF/third-party/internal/expected.hpp`:

```hpp
///
// expected - An implementation of std::expected with extensions
// Written in 2017 by Sy Brand (tartanllama@gmail.com, @TartanLlama)
//
// Documentation available at http://tl.tartanllama.xyz/
//
// To the extent possible under law, the author(s) have dedicated all
// copyright and related and neighboring rights to this software to the
// public domain worldwide. This software is distributed without any warranty.
//
// You should have received a copy of the CC0 Public Domain Dedication
// along with this software. If not, see
// <http://creativecommons.org/publicdomain/zero/1.0/>.
///

#ifndef TL_EXPECTED_HPP
#define TL_EXPECTED_HPP

#define TL_EXPECTED_VERSION_MAJOR 1
#define TL_EXPECTED_VERSION_MINOR 1
#define TL_EXPECTED_VERSION_PATCH 0

#include <exception>
#include <functional>
#include <type_traits>
#include <utility>

#if defined(__EXCEPTIONS) || defined(_CPPUNWIND)
#define TL_EXPECTED_EXCEPTIONS_ENABLED
#endif

#if (defined(_MSC_VER) && _MSC_VER == 1900)
#define TL_EXPECTED_MSVC2015
#define TL_EXPECTED_MSVC2015_CONSTEXPR
#else
#define TL_EXPECTED_MSVC2015_CONSTEXPR constexpr
#endif

#if (defined(__GNUC__) && __GNUC__ == 4 && __GNUC_MINOR__ <= 9 &&              \
     !defined(__clang__))
#define TL_EXPECTED_GCC49
#endif

#if (defined(__GNUC__) && __GNUC__ == 5 && __GNUC_MINOR__ <= 4 &&              \
     !defined(__clang__))
#define TL_EXPECTED_GCC54
#endif

#if (defined(__GNUC__) && __GNUC__ == 5 && __GNUC_MINOR__ <= 5 &&              \
     !defined(__clang__))
#define TL_EXPECTED_GCC55
#endif

#if !defined(TL_ASSERT)
//can't have assert in constexpr in C++11 and GCC 4.9 has a compiler bug
#if (__cplusplus > 201103L) && !defined(TL_EXPECTED_GCC49)
#include <cassert>
#define TL_ASSERT(x) assert(x)
#else 
#define TL_ASSERT(x)
#endif
#endif

#if (defined(__GNUC__) && __GNUC__ == 4 && __GNUC_MINOR__ <= 9 &&              \
     !defined(__clang__))
// GCC < 5 doesn't support overloading on const&& for member functions

#define TL_EXPECTED_NO_CONSTRR
// GCC < 5 doesn't support some standard C++11 type traits
#define TL_EXPECTED_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(T)                         \
  std::has_trivial_copy_constructor<T>
#define TL_EXPECTED_IS_TRIVIALLY_COPY_ASSIGNABLE(T)                            \
  std::has_trivial_copy_assign<T>

// This one will be different for GCC 5.7 if it's ever supported
#define TL_EXPECTED_IS_TRIVIALLY_DESTRUCTIBLE(T)                               \
  std::is_trivially_destructible<T>

// GCC 5 < v < 8 has a bug in is_trivially_copy_constructible which breaks
// std::vector for non-copyable types
#elif (defined(__GNUC__) && __GNUC__ < 8 && !defined(__clang__))
#ifndef TL_GCC_LESS_8_TRIVIALLY_COPY_CONSTRUCTIBLE_MUTEX
#define TL_GCC_LESS_8_TRIVIALLY_COPY_CONSTRUCTIBLE_MUTEX
namespace tl {
namespace detail {
template <class T>
struct is_trivially_copy_constructible
    : std::is_trivially_copy_constructible<T> {};
#ifdef _GLIBCXX_VECTOR
template <class T, class A>
struct is_trivially_copy_constructible<std::vector<T, A>> : std::false_type {};
#endif
} // namespace detail
} // namespace tl
#endif

#define TL_EXPECTED_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(T)                         \
  tl::detail::is_trivially_copy_constructible<T>
#define TL_EXPECTED_IS_TRIVIALLY_COPY_ASSIGNABLE(T)                            \
  std::is_trivially_copy_assignable<T>
#define TL_EXPECTED_IS_TRIVIALLY_DESTRUCTIBLE(T)                               \
  std::is_trivially_destructible<T>
#else
#define TL_EXPECTED_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(T)                         \
  std::is_trivially_copy_constructible<T>
#define TL_EXPECTED_IS_TRIVIALLY_COPY_ASSIGNABLE(T)                            \
  std::is_trivially_copy_assignable<T>
#define TL_EXPECTED_IS_TRIVIALLY_DESTRUCTIBLE(T)                               \
  std::is_trivially_destructible<T>
#endif

#if __cplusplus > 201103L
#define TL_EXPECTED_CXX14
#endif

#ifdef TL_EXPECTED_GCC49
#define TL_EXPECTED_GCC49_CONSTEXPR
#else
#define TL_EXPECTED_GCC49_CONSTEXPR constexpr
#endif

#if (__cplusplus == 201103L || defined(TL_EXPECTED_MSVC2015) ||                \
     defined(TL_EXPECTED_GCC49))
#define TL_EXPECTED_11_CONSTEXPR
#else
#define TL_EXPECTED_11_CONSTEXPR constexpr
#endif

namespace tl {
template <class T, class E> class expected;

#ifndef TL_MONOSTATE_INPLACE_MUTEX
#define TL_MONOSTATE_INPLACE_MUTEX
class monostate {};

struct in_place_t {
  explicit in_place_t() = default;
};
static constexpr in_place_t in_place{};
#endif

template <class E> class unexpected {
public:
  static_assert(!std::is_same<E, void>::value, "E must not be void");

  unexpected() = delete;
  constexpr explicit unexpected(const E &e) : m_val(e) {}

  constexpr explicit unexpected(E &&e) : m_val(std::move(e)) {}

  template <class... Args, typename std::enable_if<std::is_constructible<
                               E, Args &&...>::value>::type * = nullptr>
  constexpr explicit unexpected(Args &&...args)
      : m_val(std::forward<Args>(args)...) {}
  template <
      class U, class... Args,
      typename std::enable_if<std::is_constructible<
          E, std::initializer_list<U> &, Args &&...>::value>::type * = nullptr>
  constexpr explicit unexpected(std::initializer_list<U> l, Args &&...args)
      : m_val(l, std::forward<Args>(args)...) {}

  constexpr const E &value() const & { return m_val; }
  TL_EXPECTED_11_CONSTEXPR E &value() & { return m_val; }
  TL_EXPECTED_11_CONSTEXPR E &&value() && { return std::move(m_val); }
  constexpr const E &&value() const && { return std::move(m_val); }

private:
  E m_val;
};

#ifdef __cpp_deduction_guides
template <class E> unexpected(E) -> unexpected<E>;
#endif

template <class E>
constexpr bool operator==(const unexpected<E> &lhs, const unexpected<E> &rhs) {
  return lhs.value() == rhs.value();
}
template <class E>
constexpr bool operator!=(const unexpected<E> &lhs, const unexpected<E> &rhs) {
  return lhs.value() != rhs.value();
}
template <class E>
constexpr bool operator<(const unexpected<E> &lhs, const unexpected<E> &rhs) {
  return lhs.value() < rhs.value();
}
template <class E>
constexpr bool operator<=(const unexpected<E> &lhs, const unexpected<E> &rhs) {
  return lhs.value() <= rhs.value();
}
template <class E>
constexpr bool operator>(const unexpected<E> &lhs, const unexpected<E> &rhs) {
  return lhs.value() > rhs.value();
}
template <class E>
constexpr bool operator>=(const unexpected<E> &lhs, const unexpected<E> &rhs) {
  return lhs.value() >= rhs.value();
}

template <class E>
unexpected<typename std::decay<E>::type> make_unexpected(E &&e) {
  return unexpected<typename std::decay<E>::type>(std::forward<E>(e));
}

struct unexpect_t {
  unexpect_t() = default;
};
static constexpr unexpect_t unexpect{};

namespace detail {
template <typename E>
[[noreturn]] TL_EXPECTED_11_CONSTEXPR void throw_exception(E &&e) {
#ifdef TL_EXPECTED_EXCEPTIONS_ENABLED
  throw std::forward<E>(e);
#else
  (void)e;
#ifdef _MSC_VER
  __assume(0);
#else
  __builtin_unreachable();
#endif
#endif
}

#ifndef TL_TRAITS_MUTEX
#define TL_TRAITS_MUTEX
// C++14-style aliases for brevity
template <class T> using remove_const_t = typename std::remove_const<T>::type;
template <class T>
using remove_reference_t = typename std::remove_reference<T>::type;
template <class T> using decay_t = typename std::decay<T>::type;
template <bool E, class T = void>
using enable_if_t = typename std::enable_if<E, T>::type;
template <bool B, class T, class F>
using conditional_t = typename std::conditional<B, T, F>::type;

// std::conjunction from C++17
template <class...> struct conjunction : std::true_type {};
template <class B> struct conjunction<B> : B {};
template <class B, class... Bs>
struct conjunction<B, Bs...>
    : std::conditional<bool(B::value), conjunction<Bs...>, B>::type {};

#if defined(_LIBCPP_VERSION) && __cplusplus == 201103L
#define TL_TRAITS_LIBCXX_MEM_FN_WORKAROUND
#endif

// In C++11 mode, there's an issue in libc++'s std::mem_fn
// which results in a hard-error when using it in a noexcept expression
// in some cases. This is a check to workaround the common failing case.
#ifdef TL_TRAITS_LIBCXX_MEM_FN_WORKAROUND
template <class T>
struct is_pointer_to_non_const_member_func : std::false_type {};
template <class T, class Ret, class... Args>
struct is_pointer_to_non_const_member_func<Ret (T::*)(Args...)>
    : std::true_type {};
template <class T, class Ret, class... Args>
struct is_pointer_to_non_const_member_func<Ret (T::*)(Args...) &>
    : std::true_type {};
template <class T, class Ret, class... Args>
struct is_pointer_to_non_const_member_func<Ret (T::*)(Args...) &&>
    : std::true_type {};
template <class T, class Ret, class... Args>
struct is_pointer_to_non_const_member_func<Ret (T::*)(Args...) volatile>
    : std::true_type {};
template <class T, class Ret, class... Args>
struct is_pointer_to_non_const_member_func<Ret (T::*)(Args...) volatile &>
    : std::true_type {};
template <class T, class Ret, class... Args>
struct is_pointer_to_non_const_member_func<Ret (T::*)(Args...) volatile &&>
    : std::true_type {};

template <class T> struct is_const_or_const_ref : std::false_type {};
template <class T> struct is_const_or_const_ref<T const &> : std::true_type {};
template <class T> struct is_const_or_const_ref<T const> : std::true_type {};
#endif

// std::invoke from C++17
// https://stackoverflow.com/questions/38288042/c11-14-invoke-workaround
template <
    typename Fn, typename... Args,
#ifdef TL_TRAITS_LIBCXX_MEM_FN_WORKAROUND
    typename = enable_if_t<!(is_pointer_to_non_const_member_func<Fn>::value &&
                             is_const_or_const_ref<Args...>::value)>,
#endif
    typename = enable_if_t<std::is_member_pointer<decay_t<Fn>>::value>, int = 0>
constexpr auto invoke(Fn &&f, Args &&...args) noexcept(
    noexcept(std::mem_fn(f)(std::forward<Args>(args)...)))
    -> decltype(std::mem_fn(f)(std::forward<Args>(args)...)) {
  return std::mem_fn(f)(std::forward<Args>(args)...);
}

template <typename Fn, typename... Args,
          typename = enable_if_t<!std::is_member_pointer<decay_t<Fn>>::value>>
constexpr auto invoke(Fn &&f, Args &&...args) noexcept(
    noexcept(std::forward<Fn>(f)(std::forward<Args>(args)...)))
    -> decltype(std::forward<Fn>(f)(std::forward<Args>(args)...)) {
  return std::forward<Fn>(f)(std::forward<Args>(args)...);
}

// std::invoke_result from C++17
template <class F, class, class... Us> struct invoke_result_impl;

template <class F, class... Us>
struct invoke_result_impl<
    F,
    decltype(detail::invoke(std::declval<F>(), std::declval<Us>()...), void()),
    Us...> {
  using type =
      decltype(detail::invoke(std::declval<F>(), std::declval<Us>()...));
};

template <class F, class... Us>
using invoke_result = invoke_result_impl<F, void, Us...>;

template <class F, class... Us>
using invoke_result_t = typename invoke_result<F, Us...>::type;

#if defined(_MSC_VER) && _MSC_VER <= 1900
// TODO make a version which works with MSVC 2015
template <class T, class U = T> struct is_swappable : std::true_type {};

template <class T, class U = T> struct is_nothrow_swappable : std::true_type {};
#else
// https://stackoverflow.com/questions/26744589/what-is-a-proper-way-to-implement-is-swappable-to-test-for-the-swappable-concept
namespace swap_adl_tests {
// if swap ADL finds this then it would call std::swap otherwise (same
// signature)
struct tag {};

template <class T> tag swap(T &, T &);
template <class T, std::size_t N> tag swap(T (&a)[N], T (&b)[N]);

// helper functions to test if an unqualified swap is possible, and if it
// becomes std::swap
template <class, class> std::false_type can_swap(...) noexcept(false);
template <class T, class U,
          class = decltype(swap(std::declval<T &>(), std::declval<U &>()))>
std::true_type can_swap(int) noexcept(noexcept(swap(std::declval<T &>(),
                                                    std::declval<U &>())));

template <class, class> std::false_type uses_std(...);
template <class T, class U>
std::is_same<decltype(swap(std::declval<T &>(), std::declval<U &>())), tag>
uses_std(int);

template <class T>
struct is_std_swap_noexcept
    : std::integral_constant<bool,
                             std::is_nothrow_move_constructible<T>::value &&
                                 std::is_nothrow_move_assignable<T>::value> {};

template <class T, std::size_t N>
struct is_std_swap_noexcept<T[N]> : is_std_swap_noexcept<T> {};

template <class T, class U>
struct is_adl_swap_noexcept
    : std::integral_constant<bool, noexcept(can_swap<T, U>(0))> {};
} // namespace swap_adl_tests

template <class T, class U = T>
struct is_swappable
    : std::integral_constant<
          bool,
          decltype(detail::swap_adl_tests::can_swap<T, U>(0))::value &&
              (!decltype(detail::swap_adl_tests::uses_std<T, U>(0))::value ||
               (std::is_move_assignable<T>::value &&
                std::is_move_constructible<T>::value))> {};

template <class T, std::size_t N>
struct is_swappable<T[N], T[N]>
    : std::integral_constant<
          bool,
          decltype(detail::swap_adl_tests::can_swap<T[N], T[N]>(0))::value &&
              (!decltype(detail::swap_adl_tests::uses_std<T[N], T[N]>(
                   0))::value ||
               is_swappable<T, T>::value)> {};

template <class T, class U = T>
struct is_nothrow_swappable
    : std::integral_constant<
          bool,
          is_swappable<T, U>::value &&
              ((decltype(detail::swap_adl_tests::uses_std<T, U>(0))::value &&
                detail::swap_adl_tests::is_std_swap_noexcept<T>::value) ||
               (!decltype(detail::swap_adl_tests::uses_std<T, U>(0))::value &&
                detail::swap_adl_tests::is_adl_swap_noexcept<T, U>::value))> {};
#endif
#endif

// Trait for checking if a type is a tl::expected
template <class T> struct is_expected_impl : std::false_type {};
template <class T, class E>
struct is_expected_impl<expected<T, E>> : std::true_type {};
template <class T> using is_expected = is_expected_impl<decay_t<T>>;

template <class T, class E, class U>
using expected_enable_forward_value = detail::enable_if_t<
    std::is_constructible<T, U &&>::value &&
    !std::is_same<detail::decay_t<U>, in_place_t>::value &&
    !std::is_same<expected<T, E>, detail::decay_t<U>>::value &&
    !std::is_same<unexpected<E>, detail::decay_t<U>>::value>;

template <class T, class E, class U, class G, class UR, class GR>
using expected_enable_from_other = detail::enable_if_t<
    std::is_constructible<T, UR>::value &&
    std::is_constructible<E, GR>::value &&
    !std::is_constructible<T, expected<U, G> &>::value &&
    !std::is_constructible<T, expected<U, G> &&>::value &&
    !std::is_constructible<T, const expected<U, G> &>::value &&
    !std::is_constructible<T, const expected<U, G> &&>::value &&
    !std::is_convertible<expected<U, G> &, T>::value &&
    !std::is_convertible<expected<U, G> &&, T>::value &&
    !std::is_convertible<const expected<U, G> &, T>::value &&
    !std::is_convertible<const expected<U, G> &&, T>::value>;

template <class T, class U>
using is_void_or = conditional_t<std::is_void<T>::value, std::true_type, U>;

template <class T>
using is_copy_constructible_or_void =
    is_void_or<T, std::is_copy_constructible<T>>;

template <class T>
using is_move_constructible_or_void =
    is_void_or<T, std::is_move_constructible<T>>;

template <class T>
using is_copy_assignable_or_void = is_void_or<T, std::is_copy_assignable<T>>;

template <class T>
using is_move_assignable_or_void = is_void_or<T, std::is_move_assignable<T>>;

} // namespace detail

namespace detail {
struct no_init_t {};
static constexpr no_init_t no_init{};

// Implements the storage of the values, and ensures that the destructor is
// trivial if it can be.
//
// This specialization is for where neither `T` or `E` is trivially
// destructible, so the destructors must be called on destruction of the
// `expected`
template <class T, class E, bool = std::is_trivially_destructible<T>::value,
          bool = std::is_trivially_destructible<E>::value>
struct expected_storage_base {
  constexpr expected_storage_base() : m_val(T{}), m_has_val(true) {}
  constexpr expected_storage_base(no_init_t) : m_no_init(), m_has_val(false) {}

  template <class... Args,
            detail::enable_if_t<std::is_constructible<T, Args &&...>::value> * =
                nullptr>
  constexpr expected_storage_base(in_place_t, Args &&...args)
      : m_val(std::forward<Args>(args)...), m_has_val(true) {}

  template <class U, class... Args,
            detail::enable_if_t<std::is_constructible<
                T, std::initializer_list<U> &, Args &&...>::value> * = nullptr>
  constexpr expected_storage_base(in_place_t, std::initializer_list<U> il,
                                  Args &&...args)
      : m_val(il, std::forward<Args>(args)...), m_has_val(true) {}
  template <class... Args,
            detail::enable_if_t<std::is_constructible<E, Args &&...>::value> * =
                nullptr>
  constexpr explicit expected_storage_base(unexpect_t, Args &&...args)
      : m_unexpect(std::forward<Args>(args)...), m_has_val(false) {}

  template <class U, class... Args,
            detail::enable_if_t<std::is_constructible<
                E, std::initializer_list<U> &, Args &&...>::value> * = nullptr>
  constexpr explicit expected_storage_base(unexpect_t,
                                           std::initializer_list<U> il,
                                           Args &&...args)
      : m_unexpect(il, std::forward<Args>(args)...), m_has_val(false) {}

  ~expected_storage_base() {
    if (m_has_val) {
      m_val.~T();
    } else {
      m_unexpect.~unexpected<E>();
    }
  }
  union {
    T m_val;
    unexpected<E> m_unexpect;
    char m_no_init;
  };
  bool m_has_val;
};

// This specialization is for when both `T` and `E` are trivially-destructible,
// so the destructor of the `expected` can be trivial.
template <class T, class E> struct expected_storage_base<T, E, true, true> {
  constexpr expected_storage_base() : m_val(T{}), m_has_val(true) {}
  constexpr expected_storage_base(no_init_t) : m_no_init(), m_has_val(false) {}

  template <class... Args,
            detail::enable_if_t<std::is_constructible<T, Args &&...>::value> * =
                nullptr>
  constexpr expected_storage_base(in_place_t, Args &&...args)
      : m_val(std::forward<Args>(args)...), m_has_val(true) {}

  template <class U, class... Args,
            detail::enable_if_t<std::is_constructible<
                T, std::initializer_list<U> &, Args &&...>::value> * = nullptr>
  constexpr expected_storage_base(in_place_t, std::initializer_list<U> il,
                                  Args &&...args)
      : m_val(il, std::forward<Args>(args)...), m_has_val(true) {}
  template <class... Args,
            detail::enable_if_t<std::is_constructible<E, Args &&...>::value> * =
                nullptr>
  constexpr explicit expected_storage_base(unexpect_t, Args &&...args)
      : m_unexpect(std::forward<Args>(args)...), m_has_val(false) {}

  template <class U, class... Args,
            detail::enable_if_t<std::is_constructible<
                E, std::initializer_list<U> &, Args &&...>::value> * = nullptr>
  constexpr explicit expected_storage_base(unexpect_t,
                                           std::initializer_list<U> il,
                                           Args &&...args)
      : m_unexpect(il, std::forward<Args>(args)...), m_has_val(false) {}

  ~expected_storage_base() = default;
  union {
    T m_val;
    unexpected<E> m_unexpect;
    char m_no_init;
  };
  bool m_has_val;
};

// T is trivial, E is not.
template <class T, class E> struct expected_storage_base<T, E, true, false> {
  constexpr expected_storage_base() : m_val(T{}), m_has_val(true) {}
  TL_EXPECTED_MSVC2015_CONSTEXPR expected_storage_base(no_init_t)
      : m_no_init(), m_has_val(false) {}

  template <class... Args,
            detail::enable_if_t<std::is_constructible<T, Args &&...>::value> * =
                nullptr>
  constexpr expected_storage_base(in_place_t, Args &&...args)
      : m_val(std::forward<Args>(args)...), m_has_val(true) {}

  template <class U, class... Args,
            detail::enable_if_t<std::is_constructible<
                T, std::initializer_list<U> &, Args &&...>::value> * = nullptr>
  constexpr expected_storage_base(in_place_t, std::initializer_list<U> il,
                                  Args &&...args)
      : m_val(il, std::forward<Args>(args)...), m_has_val(true) {}
  template <class... Args,
            detail::enable_if_t<std::is_constructible<E, Args &&...>::value> * =
                nullptr>
  constexpr explicit expected_storage_base(unexpect_t, Args &&...args)
      : m_unexpect(std::forward<Args>(args)...), m_has_val(false) {}

  template <class U, class... Args,
            detail::enable_if_t<std::is_constructible<
                E, std::initializer_list<U> &, Args &&...>::value> * = nullptr>
  constexpr explicit expected_storage_base(unexpect_t,
                                           std::initializer_list<U> il,
                                           Args &&...args)
      : m_unexpect(il, std::forward<Args>(args)...), m_has_val(false) {}

  ~expected_storage_base() {
    if (!m_has_val) {
      m_unexpect.~unexpected<E>();
    }
  }

  union {
    T m_val;
    unexpected<E> m_unexpect;
    char m_no_init;
  };
  bool m_has_val;
};

// E is trivial, T is not.
template <class T, class E> struct expected_storage_base<T, E, false, true> {
  constexpr expected_storage_base() : m_val(T{}), m_has_val(true) {}
  constexpr expected_storage_base(no_init_t) : m_no_init(), m_has_val(false) {}

  template <class... Args,
            detail::enable_if_t<std::is_constructible<T, Args &&...>::value> * =
                nullptr>
  constexpr expected_storage_base(in_place_t, Args &&...args)
      : m_val(std::forward<Args>(args)...), m_has_val(true) {}

  template <class U, class... Args,
            detail::enable_if_t<std::is_constructible<
                T, std::initializer_list<U> &, Args &&...>::value> * = nullptr>
  constexpr expected_storage_base(in_place_t, std::initializer_list<U> il,
                                  Args &&...args)
      : m_val(il, std::forward<Args>(args)...), m_has_val(true) {}
  template <class... Args,
            detail::enable_if_t<std::is_constructible<E, Args &&...>::value> * =
                nullptr>
  constexpr explicit expected_storage_base(unexpect_t, Args &&...args)
      : m_unexpect(std::forward<Args>(args)...), m_has_val(false) {}

  template <class U, class... Args,
            detail::enable_if_t<std::is_constructible<
                E, std::initializer_list<U> &, Args &&...>::value> * = nullptr>
  constexpr explicit expected_storage_base(unexpect_t,
                                           std::initializer_list<U> il,
                                           Args &&...args)
      : m_unexpect(il, std::forward<Args>(args)...), m_has_val(false) {}

  ~expected_storage_base() {
    if (m_has_val) {
      m_val.~T();
    }
  }
  union {
    T m_val;
    unexpected<E> m_unexpect;
    char m_no_init;
  };
  bool m_has_val;
};

// `T` is `void`, `E` is trivially-destructible
template <class E> struct expected_storage_base<void, E, false, true> {
  #if __GNUC__ <= 5
  //no constexpr for GCC 4/5 bug
  #else
  TL_EXPECTED_MSVC2015_CONSTEXPR
  #endif 
  expected_storage_base() : m_has_val(true) {}
     
  constexpr expected_storage_base(no_init_t) : m_val(), m_has_val(false) {}

  constexpr expected_storage_base(in_place_t) : m_has_val(true) {}

  template <class... Args,
            detail::enable_if_t<std::is_constructible<E, Args &&...>::value> * =
                nullptr>
  constexpr explicit expected_storage_base(unexpect_t, Args &&...args)
      : m_unexpect(std::forward<Args>(args)...), m_has_val(false) {}

  template <class U, class... Args,
            detail::enable_if_t<std::is_constructible<
                E, std::initializer_list<U> &, Args &&...>::value> * = nullptr>
  constexpr explicit expected_storage_base(unexpect_t,
                                           std::initializer_list<U> il,
                                           Args &&...args)
      : m_unexpect(il, std::forward<Args>(args)...), m_has_val(false) {}

  ~expected_storage_base() = default;
  struct dummy {};
  union {
    unexpected<E> m_unexpect;
    dummy m_val;
  };
  bool m_has_val;
};

// `T` is `void`, `E` is not trivially-destructible
template <class E> struct expected_storage_base<void, E, false, false> {
  constexpr expected_storage_base() : m_dummy(), m_has_val(true) {}
  constexpr expected_storage_base(no_init_t) : m_dummy(), m_has_val(false) {}

  constexpr expected_storage_base(in_place_t) : m_dummy(), m_has_val(true) {}

  template <class... Args,
            detail::enable_if_t<std::is_constructible<E, Args &&...>::value> * =
                nullptr>
  constexpr explicit expected_storage_base(unexpect_t, Args &&...args)
      : m_unexpect(std::forward<Args>(args)...), m_has_val(false) {}

  template <class U, class... Args,
            detail::enable_if_t<std::is_constructible<
                E, std::initializer_list<U> &, Args &&...>::value> * = nullptr>
  constexpr explicit expected_storage_base(unexpect_t,
                                           std::initializer_list<U> il,
                                           Args &&...args)
      : m_unexpect(il, std::forward<Args>(args)...), m_has_val(false) {}

  ~expected_storage_base() {
    if (!m_has_val) {
      m_unexpect.~unexpected<E>();
    }
  }

  union {
    unexpected<E> m_unexpect;
    char m_dummy;
  };
  bool m_has_val;
};

// This base class provides some handy member functions which can be used in
// further derived classes
template <class T, class E>
struct expected_operations_base : expected_storage_base<T, E> {
  using expected_storage_base<T, E>::expected_storage_base;

  template <class... Args> void construct(Args &&...args) noexcept {
    new (std::addressof(this->m_val)) T(std::forward<Args>(args)...);
    this->m_has_val = true;
  }

  template <class Rhs> void construct_with(Rhs &&rhs) noexcept {
    new (std::addressof(this->m_val)) T(std::forward<Rhs>(rhs).get());
    this->m_has_val = true;
  }

  template <class... Args> void construct_error(Args &&...args) noexcept {
    new (std::addressof(this->m_unexpect))
        unexpected<E>(std::forward<Args>(args)...);
    this->m_has_val = false;
  }

#ifdef TL_EXPECTED_EXCEPTIONS_ENABLED

  // These assign overloads ensure that the most efficient assignment
  // implementation is used while maintaining the strong exception guarantee.
  // The problematic case is where rhs has a value, but *this does not.
  //
  // This overload handles the case where we can just copy-construct `T`
  // directly into place without throwing.
  template <class U = T,
            detail::enable_if_t<std::is_nothrow_copy_constructible<U>::value>
                * = nullptr>
  void assign(const expected_operations_base &rhs) noexcept {
    if (!this->m_has_val && rhs.m_has_val) {
      geterr().~unexpected<E>();
      construct(rhs.get());
    } else {
      assign_common(rhs);
    }
  }

  // This overload handles the case where we can attempt to create a copy of
  // `T`, then no-throw move it into place if the copy was successful.
  template <class U = T,
            detail::enable_if_t<!std::is_nothrow_copy_constructible<U>::value &&
                                std::is_nothrow_move_constructible<U>::value>
                * = nullptr>
  void assign(const expected_operations_base &rhs) noexcept {
    if (!this->m_has_val && rhs.m_has_val) {
      T tmp = rhs.get();
      geterr().~unexpected<E>();
      construct(std::move(tmp));
    } else {
      assign_common(rhs);
    }
  }

  // This overload is the worst-case, where we have to move-construct the
  // unexpected value into temporary storage, then try to copy the T into place.
  // If the construction succeeds, then everything is fine, but if it throws,
  // then we move the old unexpected value back into place before rethrowing the
  // exception.
  template <class U = T,
            detail::enable_if_t<!std::is_nothrow_copy_constructible<U>::value &&
                                !std::is_nothrow_move_constructible<U>::value>
                * = nullptr>
  void assign(const expected_operations_base &rhs) {
    if (!this->m_has_val && rhs.m_has_val) {
      auto tmp = std::move(geterr());
      geterr().~unexpected<E>();

#ifdef TL_EXPECTED_EXCEPTIONS_ENABLED
      try {
        construct(rhs.get());
      } catch (...) {
        geterr() = std::move(tmp);
        throw;
      }
#else
      construct(rhs.get());
#endif
    } else {
      assign_common(rhs);
    }
  }

  // These overloads do the same as above, but for rvalues
  template <class U = T,
            detail::enable_if_t<std::is_nothrow_move_constructible<U>::value>
                * = nullptr>
  void assign(expected_operations_base &&rhs) noexcept {
    if (!this->m_has_val && rhs.m_has_val) {
      geterr().~unexpected<E>();
      construct(std::move(rhs).get());
    } else {
      assign_common(std::move(rhs));
    }
  }

  template <class U = T,
            detail::enable_if_t<!std::is_nothrow_move_constructible<U>::value>
                * = nullptr>
  void assign(expected_operations_base &&rhs) {
    if (!this->m_has_val && rhs.m_has_val) {
      auto tmp = std::move(geterr());
      geterr().~unexpected<E>();
#ifdef TL_EXPECTED_EXCEPTIONS_ENABLED
      try {
        construct(std::move(rhs).get());
      } catch (...) {
        geterr() = std::move(tmp);
        throw;
      }
#else
      construct(std::move(rhs).get());
#endif
    } else {
      assign_common(std::move(rhs));
    }
  }

#else

  // If exceptions are disabled then we can just copy-construct
  void assign(const expected_operations_base &rhs) noexcept {
    if (!this->m_has_val && rhs.m_has_val) {
      geterr().~unexpected<E>();
      construct(rhs.get());
    } else {
      assign_common(rhs);
    }
  }

  void assign(expected_operations_base &&rhs) noexcept {
    if (!this->m_has_val && rhs.m_has_val) {
      geterr().~unexpected<E>();
      construct(std::move(rhs).get());
    } else {
      assign_common(std::move(rhs));
    }
  }

#endif

  // The common part of move/copy assigning
  template <class Rhs> void assign_common(Rhs &&rhs) {
    if (this->m_has_val) {
      if (rhs.m_has_val) {
        get() = std::forward<Rhs>(rhs).get();
      } else {
        destroy_val();
        construct_error(std::forward<Rhs>(rhs).geterr());
      }
    } else {
      if (!rhs.m_has_val) {
        geterr() = std::forward<Rhs>(rhs).geterr();
      }
    }
  }

  bool has_value() const { return this->m_has_val; }

  TL_EXPECTED_11_CONSTEXPR T &get() & { return this->m_val; }
  constexpr const T &get() const & { return this->m_val; }
  TL_EXPECTED_11_CONSTEXPR T &&get() && { return std::move(this->m_val); }
#ifndef TL_EXPECTED_NO_CONSTRR
  constexpr const T &&get() const && { return std::move(this->m_val); }
#endif

  TL_EXPECTED_11_CONSTEXPR unexpected<E> &geterr() & {
    return this->m_unexpect;
  }
  constexpr const unexpected<E> &geterr() const & { return this->m_unexpect; }
  TL_EXPECTED_11_CONSTEXPR unexpected<E> &&geterr() && {
    return std::move(this->m_unexpect);
  }
#ifndef TL_EXPECTED_NO_CONSTRR
  constexpr const unexpected<E> &&geterr() const && {
    return std::move(this->m_unexpect);
  }
#endif

  TL_EXPECTED_11_CONSTEXPR void destroy_val() { get().~T(); }
};

// This base class provides some handy member functions which can be used in
// further derived classes
template <class E>
struct expected_operations_base<void, E> : expected_storage_base<void, E> {
  using expected_storage_base<void, E>::expected_storage_base;

  template <class... Args> void construct() noexcept { this->m_has_val = true; }

  // This function doesn't use its argument, but needs it so that code in
  // levels above this can work independently of whether T is void
  template <class Rhs> void construct_with(Rhs &&) noexcept {
    this->m_has_val = true;
  }

  template <class... Args> void construct_error(Args &&...args) noexcept {
    new (std::addressof(this->m_unexpect))
        unexpected<E>(std::forward<Args>(args)...);
    this->m_has_val = false;
  }

  template <class Rhs> void assign(Rhs &&rhs) noexcept {
    if (!this->m_has_val) {
      if (rhs.m_has_val) {
        geterr().~unexpected<E>();
        construct();
      } else {
        geterr() = std::forward<Rhs>(rhs).geterr();
      }
    } else {
      if (!rhs.m_has_val) {
        construct_error(std::forward<Rhs>(rhs).geterr());
      }
    }
  }

  bool has_value() const { return this->m_has_val; }

  TL_EXPECTED_11_CONSTEXPR unexpected<E> &geterr() & {
    return this->m_unexpect;
  }
  constexpr const unexpected<E> &geterr() const & { return this->m_unexpect; }
  TL_EXPECTED_11_CONSTEXPR unexpected<E> &&geterr() && {
    return std::move(this->m_unexpect);
  }
#ifndef TL_EXPECTED_NO_CONSTRR
  constexpr const unexpected<E> &&geterr() const && {
    return std::move(this->m_unexpect);
  }
#endif

  TL_EXPECTED_11_CONSTEXPR void destroy_val() {
    // no-op
  }
};

// This class manages conditionally having a trivial copy constructor
// This specialization is for when T and E are trivially copy constructible
template <class T, class E,
          bool = is_void_or<T, TL_EXPECTED_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(T)>::
              value &&TL_EXPECTED_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(E)::value>
struct expected_copy_base : expected_operations_base<T, E> {
  using expected_operations_base<T, E>::expected_operations_base;
};

// This specialization is for when T or E are not trivially copy constructible
template <class T, class E>
struct expected_copy_base<T, E, false> : expected_operations_base<T, E> {
  using expected_operations_base<T, E>::expected_operations_base;

  expected_copy_base() = default;
  expected_copy_base(const expected_copy_base &rhs)
      : expected_operations_base<T, E>(no_init) {
    if (rhs.has_value()) {
      this->construct_with(rhs);
    } else {
      this->construct_error(rhs.geterr());
    }
  }

  expected_copy_base(expected_copy_base &&rhs) = default;
  expected_copy_base &operator=(const expected_copy_base &rhs) = default;
  expected_copy_base &operator=(expected_copy_base &&rhs) = default;
};

// This class manages conditionally having a trivial move constructor
// Unfortunately there's no way to achieve this in GCC < 5 AFAIK, since it
// doesn't implement an analogue to std::is_trivially_move_constructible. We
// have to make do with a non-trivial move constructor even if T is trivially
// move constructible
#ifndef TL_EXPECTED_GCC49
template <class T, class E,
          bool = is_void_or<T, std::is_trivially_move_constructible<T>>::value
              &&std::is_trivially_move_constructible<E>::value>
struct expected_move_base : expected_copy_base<T, E> {
  using expected_copy_base<T, E>::expected_copy_base;
};
#else
template <class T, class E, bool = false> struct expected_move_base;
#endif
template <class T, class E>
struct expected_move_base<T, E, false> : expected_copy_base<T, E> {
  using expected_copy_base<T, E>::expected_copy_base;

  expected_move_base() = default;
  expected_move_base(const expected_move_base &rhs) = default;

  expected_move_base(expected_move_base &&rhs) noexcept(
      std::is_nothrow_move_constructible<T>::value)
      : expected_copy_base<T, E>(no_init) {
    if (rhs.has_value()) {
      this->construct_with(std::move(rhs));
    } else {
      this->construct_error(std::move(rhs.geterr()));
    }
  }
  expected_move_base &operator=(const expected_move_base &rhs) = default;
  expected_move_base &operator=(expected_move_base &&rhs) = default;
};

// This class manages conditionally having a trivial copy assignment operator
template <class T, class E,
          bool = is_void_or<
              T, conjunction<TL_EXPECTED_IS_TRIVIALLY_COPY_ASSIGNABLE(T),
                             TL_EXPECTED_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(T),
                             TL_EXPECTED_IS_TRIVIALLY_DESTRUCTIBLE(T)>>::value
              &&TL_EXPECTED_IS_TRIVIALLY_COPY_ASSIGNABLE(E)::value
                  &&TL_EXPECTED_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(E)::value
                      &&TL_EXPECTED_IS_TRIVIALLY_DESTRUCTIBLE(E)::value>
struct expected_copy_assign_base : expected_move_base<T, E> {
  using expected_move_base<T, E>::expected_move_base;
};

template <class T, class E>
struct expected_copy_assign_base<T, E, false> : expected_move_base<T, E> {
  using expected_move_base<T, E>::expected_move_base;

  expected_copy_assign_base() = default;
  expected_copy_assign_base(const expected_copy_assign_base &rhs) = default;

  expected_copy_assign_base(expected_copy_assign_base &&rhs) = default;
  expected_copy_assign_base &operator=(const expected_copy_assign_base &rhs) {
    this->assign(rhs);
    return *this;
  }
  expected_copy_assign_base &
  operator=(expected_copy_assign_base &&rhs) = default;
};

// This class manages conditionally having a trivial move assignment operator
// Unfortunately there's no way to achieve this in GCC < 5 AFAIK, since it
// doesn't implement an analogue to std::is_trivially_move_assignable. We have
// to make do with a non-trivial move assignment operator even if T is trivially
// move assignable
#ifndef TL_EXPECTED_GCC49
template <class T, class E,
          bool =
              is_void_or<T, conjunction<std::is_trivially_destructible<T>,
                                        std::is_trivially_move_constructible<T>,
                                        std::is_trivially_move_assignable<T>>>::
                  value &&std::is_trivially_destructible<E>::value
                      &&std::is_trivially_move_constructible<E>::value
                          &&std::is_trivially_move_assignable<E>::value>
struct expected_move_assign_base : expected_copy_assign_base<T, E> {
  using expected_copy_assign_base<T, E>::expected_copy_assign_base;
};
#else
template <class T, class E, bool = false> struct expected_move_assign_base;
#endif

template <class T, class E>
struct expected_move_assign_base<T, E, false>
    : expected_copy_assign_base<T, E> {
  using expected_copy_assign_base<T, E>::expected_copy_assign_base;

  expected_move_assign_base() = default;
  expected_move_assign_base(const expected_move_assign_base &rhs) = default;

  expected_move_assign_base(expected_move_assign_base &&rhs) = default;

  expected_move_assign_base &
  operator=(const expected_move_assign_base &rhs) = default;

  expected_move_assign_base &
  operator=(expected_move_assign_base &&rhs) noexcept(
      std::is_nothrow_move_constructible<T>::value
          &&std::is_nothrow_move_assignable<T>::value) {
    this->assign(std::move(rhs));
    return *this;
  }
};

// expected_delete_ctor_base will conditionally delete copy and move
// constructors depending on whether T is copy/move constructible
template <class T, class E,
          bool EnableCopy = (is_copy_constructible_or_void<T>::value &&
                             std::is_copy_constructible<E>::value),
          bool EnableMove = (is_move_constructible_or_void<T>::value &&
                             std::is_move_constructible<E>::value)>
struct expected_delete_ctor_base {
  expected_delete_ctor_base() = default;
  expected_delete_ctor_base(const expected_delete_ctor_base &) = default;
  expected_delete_ctor_base(expected_delete_ctor_base &&) noexcept = default;
  expected_delete_ctor_base &
  operator=(const expected_delete_ctor_base &) = default;
  expected_delete_ctor_base &
  operator=(expected_delete_ctor_base &&) noexcept = default;
};

template <class T, class E>
struct expected_delete_ctor_base<T, E, true, false> {
  expected_delete_ctor_base() = default;
  expected_delete_ctor_base(const expected_delete_ctor_base &) = default;
  expected_delete_ctor_base(expected_delete_ctor_base &&) noexcept = delete;
  expected_delete_ctor_base &
  operator=(const expected_delete_ctor_base &) = default;
  expected_delete_ctor_base &
  operator=(expected_delete_ctor_base &&) noexcept = default;
};

template <class T, class E>
struct expected_delete_ctor_base<T, E, false, true> {
  expected_delete_ctor_base() = default;
  expected_delete_ctor_base(const expected_delete_ctor_base &) = delete;
  expected_delete_ctor_base(expected_delete_ctor_base &&) noexcept = default;
  expected_delete_ctor_base &
  operator=(const expected_delete_ctor_base &) = default;
  expected_delete_ctor_base &
  operator=(expected_delete_ctor_base &&) noexcept = default;
};

template <class T, class E>
struct expected_delete_ctor_base<T, E, false, false> {
  expected_delete_ctor_base() = default;
  expected_delete_ctor_base(const expected_delete_ctor_base &) = delete;
  expected_delete_ctor_base(expected_delete_ctor_base &&) noexcept = delete;
  expected_delete_ctor_base &
  operator=(const expected_delete_ctor_base &) = default;
  expected_delete_ctor_base &
  operator=(expected_delete_ctor_base &&) noexcept = default;
};

// expected_delete_assign_base will conditionally delete copy and move
// constructors depending on whether T and E are copy/move constructible +
// assignable
template <class T, class E,
          bool EnableCopy = (is_copy_constructible_or_void<T>::value &&
                             std::is_copy_constructible<E>::value &&
                             is_copy_assignable_or_void<T>::value &&
                             std::is_copy_assignable<E>::value),
          bool EnableMove = (is_move_constructible_or_void<T>::value &&
                             std::is_move_constructible<E>::value &&
                             is_move_assignable_or_void<T>::value &&
                             std::is_move_assignable<E>::value)>
struct expected_delete_assign_base {
  expected_delete_assign_base() = default;
  expected_delete_assign_base(const expected_delete_assign_base &) = default;
  expected_delete_assign_base(expected_delete_assign_base &&) noexcept =
      default;
  expected_delete_assign_base &
  operator=(const expected_delete_assign_base &) = default;
  expected_delete_assign_base &
  operator=(expected_delete_assign_base &&) noexcept = default;
};

template <class T, class E>
struct expected_delete_assign_base<T, E, true, false> {
  expected_delete_assign_base() = default;
  expected_delete_assign_base(const expected_delete_assign_base &) = default;
  expected_delete_assign_base(expected_delete_assign_base &&) noexcept =
      default;
  expected_delete_assign_base &
  operator=(const expected_delete_assign_base &) = default;
  expected_delete_assign_base &
  operator=(expected_delete_assign_base &&) noexcept = delete;
};

template <class T, class E>
struct expected_delete_assign_base<T, E, false, true> {
  expected_delete_assign_base() = default;
  expected_delete_assign_base(const expected_delete_assign_base &) = default;
  expected_delete_assign_base(expected_delete_assign_base &&) noexcept =
      default;
  expected_delete_assign_base &
  operator=(const expected_delete_assign_base &) = delete;
  expected_delete_assign_base &
  operator=(expected_delete_assign_base &&) noexcept = default;
};

template <class T, class E>
struct expected_delete_assign_base<T, E, false, false> {
  expected_delete_assign_base() = default;
  expected_delete_assign_base(const expected_delete_assign_base &) = default;
  expected_delete_assign_base(expected_delete_assign_base &&) noexcept =
      default;
  expected_delete_assign_base &
  operator=(const expected_delete_assign_base &) = delete;
  expected_delete_assign_base &
  operator=(expected_delete_assign_base &&) noexcept = delete;
};

// This is needed to be able to construct the expected_default_ctor_base which
// follows, while still conditionally deleting the default constructor.
struct default_constructor_tag {
  explicit constexpr default_constructor_tag() = default;
};

// expected_default_ctor_base will ensure that expected has a deleted default
// consturctor if T is not default constructible.
// This specialization is for when T is default constructible
template <class T, class E,
          bool Enable =
              std::is_default_constructible<T>::value || std::is_void<T>::value>
struct expected_default_ctor_base {
  constexpr expected_default_ctor_base() noexcept = default;
  constexpr expected_default_ctor_base(
      expected_default_ctor_base const &) noexcept = default;
  constexpr expected_default_ctor_base(expected_default_ctor_base &&) noexcept =
      default;
  expected_default_ctor_base &
  operator=(expected_default_ctor_base const &) noexcept = default;
  expected_default_ctor_base &
  operator=(expected_default_ctor_base &&) noexcept = default;

  constexpr explicit expected_default_ctor_base(default_constructor_tag) {}
};

// This specialization is for when T is not default constructible
template <class T, class E> struct expected_default_ctor_base<T, E, false> {
  constexpr expected_default_ctor_base() noexcept = delete;
  constexpr expected_default_ctor_base(
      expected_default_ctor_base const &) noexcept = default;
  constexpr expected_default_ctor_base(expected_default_ctor_base &&) noexcept =
      default;
  expected_default_ctor_base &
  operator=(expected_default_ctor_base const &) noexcept = default;
  expected_default_ctor_base &
  operator=(expected_default_ctor_base &&) noexcept = default;

  constexpr explicit expected_default_ctor_base(default_constructor_tag) {}
};
} // namespace detail

template <class E> class bad_expected_access : public std::exception {
public:
  explicit bad_expected_access(E e) : m_val(std::move(e)) {}

  virtual const char *what() const noexcept override {
    return "Bad expected access";
  }

  const E &error() const & { return m_val; }
  E &error() & { return m_val; }
  const E &&error() const && { return std::move(m_val); }
  E &&error() && { return std::move(m_val); }

private:
  E m_val;
};

/// An `expected<T, E>` object is an object that contains the storage for
/// another object and manages the lifetime of this contained object `T`.
/// Alternatively it could contain the storage for another unexpected object
/// `E`. The contained object may not be initialized after the expected object
/// has been initialized, and may not be destroyed before the expected object
/// has been destroyed. The initialization state of the contained object is
/// tracked by the expected object.
template <class T, class E>
class expected : private detail::expected_move_assign_base<T, E>,
                 private detail::expected_delete_ctor_base<T, E>,
                 private detail::expected_delete_assign_base<T, E>,
                 private detail::expected_default_ctor_base<T, E> {
  static_assert(!std::is_reference<T>::value, "T must not be a reference");
  static_assert(!std::is_same<T, std::remove_cv<in_place_t>::type>::value,
                "T must not be in_place_t");
  static_assert(!std::is_same<T, std::remove_cv<unexpect_t>::type>::value,
                "T must not be unexpect_t");
  static_assert(
      !std::is_same<T, typename std::remove_cv<unexpected<E>>::type>::value,
      "T must not be unexpected<E>");
  static_assert(!std::is_reference<E>::value, "E must not be a reference");

  T *valptr() { return std::addressof(this->m_val); }
  const T *valptr() const { return std::addressof(this->m_val); }
  unexpected<E> *errptr() { return std::addressof(this->m_unexpect); }
  const unexpected<E> *errptr() const {
    return std::addressof(this->m_unexpect);
  }

  template <class U = T,
            detail::enable_if_t<!std::is_void<U>::value> * = nullptr>
  TL_EXPECTED_11_CONSTEXPR U &val() {
    return this->m_val;
  }
  TL_EXPECTED_11_CONSTEXPR unexpected<E> &err() { return this->m_unexpect; }

  template <class U = T,
            detail::enable_if_t<!std::is_void<U>::value> * = nullptr>
  constexpr const U &val() const {
    return this->m_val;
  }
  constexpr const unexpected<E> &err() const { return this->m_unexpect; }

  using impl_base = detail::expected_move_assign_base<T, E>;
  using ctor_base = detail::expected_default_ctor_base<T, E>;

public:
  typedef T value_type;
  typedef E error_type;
  typedef unexpected<E> unexpected_type;

#if defined(TL_EXPECTED_CXX14) && !defined(TL_EXPECTED_GCC49) &&               \
    !defined(TL_EXPECTED_GCC54) && !defined(TL_EXPECTED_GCC55)
  template <class F> TL_EXPECTED_11_CONSTEXPR auto and_then(F &&f) & {
    return and_then_impl(*this, std::forward<F>(f));
  }
  template <class F> TL_EXPECTED_11_CONSTEXPR auto and_then(F &&f) && {
    return and_then_impl(std::move(*this), std::forward<F>(f));
  }
  template <class F> constexpr auto and_then(F &&f) const & {
    return and_then_impl(*this, std::forward<F>(f));
  }

#ifndef TL_EXPECTED_NO_CONSTRR
  template <class F> constexpr auto and_then(F &&f) const && {
    return and_then_impl(std::move(*this), std::forward<F>(f));
  }
#endif

#else
  template <class F>
  TL_EXPECTED_11_CONSTEXPR auto
  and_then(F &&f) & -> decltype(and_then_impl(std::declval<expected &>(),
                                              std::forward<F>(f))) {
    return and_then_impl(*this, std::forward<F>(f));
  }
  template <class F>
  TL_EXPECTED_11_CONSTEXPR auto
  and_then(F &&f) && -> decltype(and_then_impl(std::declval<expected &&>(),
                                               std::forward<F>(f))) {
    return and_then_impl(std::move(*this), std::forward<F>(f));
  }
  template <class F>
  constexpr auto and_then(F &&f) const & -> decltype(and_then_impl(
      std::declval<expected const &>(), std::forward<F>(f))) {
    return and_then_impl(*this, std::forward<F>(f));
  }

#ifndef TL_EXPECTED_NO_CONSTRR
  template <class F>
  constexpr auto and_then(F &&f) const && -> decltype(and_then_impl(
      std::declval<expected const &&>(), std::forward<F>(f))) {
    return and_then_impl(std::move(*this), std::forward<F>(f));
  }
#endif
#endif

#if defined(TL_EXPECTED_CXX14) && !defined(TL_EXPECTED_GCC49) &&               \
    !defined(TL_EXPECTED_GCC54) && !defined(TL_EXPECTED_GCC55)
  template <class F> TL_EXPECTED_11_CONSTEXPR auto map(F &&f) & {
    return expected_map_impl(*this, std::forward<F>(f));
  }
  template <class F> TL_EXPECTED_11_CONSTEXPR auto map(F &&f) && {
    return expected_map_impl(std::move(*this), std::forward<F>(f));
  }
  template <class F> constexpr auto map(F &&f) const & {
    return expected_map_impl(*this, std::forward<F>(f));
  }
  template <class F> constexpr auto map(F &&f) const && {
    return expected_map_impl(std::move(*this), std::forward<F>(f));
  }
#else
  template <class F>
  TL_EXPECTED_11_CONSTEXPR decltype(expected_map_impl(
      std::declval<expected &>(), std::declval<F &&>()))
  map(F &&f) & {
    return expected_map_impl(*this, std::forward<F>(f));
  }
  template <class F>
  TL_EXPECTED_11_CONSTEXPR decltype(expected_map_impl(std::declval<expected>(),
                                                      std::declval<F &&>()))
  map(F &&f) && {
    return expected_map_impl(std::move(*this), std::forward<F>(f));
  }
  template <class F>
  constexpr decltype(expected_map_impl(std::declval<const expected &>(),
                                       std::declval<F &&>()))
  map(F &&f) const & {
    return expected_map_impl(*this, std::forward<F>(f));
  }

#ifndef TL_EXPECTED_NO_CONSTRR
  template <class F>
  constexpr decltype(expected_map_impl(std::declval<const expected &&>(),
                                       std::declval<F &&>()))
  map(F &&f) const && {
    return expected_map_impl(std::move(*this), std::forward<F>(f));
  }
#endif
#endif

#if defined(TL_EXPECTED_CXX14) && !defined(TL_EXPECTED_GCC49) &&               \
    !defined(TL_EXPECTED_GCC54) && !defined(TL_EXPECTED_GCC55)
  template <class F> TL_EXPECTED_11_CONSTEXPR auto transform(F &&f) & {
    return expected_map_impl(*this, std::forward<F>(f));
  }
  template <class F> TL_EXPECTED_11_CONSTEXPR auto transform(F &&f) && {
    return expected_map_impl(std::move(*this), std::forward<F>(f));
  }
  template <class F> constexpr auto transform(F &&f) const & {
    return expected_map_impl(*this, std::forward<F>(f));
  }
  template <class F> constexpr auto transform(F &&f) const && {
    return expected_map_impl(std::move(*this), std::forward<F>(f));
  }
#else
  template <class F>
  TL_EXPECTED_11_CONSTEXPR decltype(expected_map_impl(
      std::declval<expected &>(), std::declval<F &&>()))
  transform(F &&f) & {
    return expected_map_impl(*this, std::forward<F>(f));
  }
  template <class F>
  TL_EXPECTED_11_CONSTEXPR decltype(expected_map_impl(std::declval<expected>(),
                                                      std::declval<F &&>()))
  transform(F &&f) && {
    return expected_map_impl(std::move(*this), std::forward<F>(f));
  }
  template <class F>
  constexpr decltype(expected_map_impl(std::declval<const expected &>(),
                                       std::declval<F &&>()))
  transform(F &&f) const & {
    return expected_map_impl(*this, std::forward<F>(f));
  }

#ifndef TL_EXPECTED_NO_CONSTRR
  template <class F>
  constexpr decltype(expected_map_impl(std::declval<const expected &&>(),
                                       std::declval<F &&>()))
  transform(F &&f) const && {
    return expected_map_impl(std::move(*this), std::forward<F>(f));
  }
#endif
#endif

#if defined(TL_EXPECTED_CXX14) && !defined(TL_EXPECTED_GCC49) &&               \
    !defined(TL_EXPECTED_GCC54) && !defined(TL_EXPECTED_GCC55)
  template <class F> TL_EXPECTED_11_CONSTEXPR auto map_error(F &&f) & {
    return map_error_impl(*this, std::forward<F>(f));
  }
  template <class F> TL_EXPECTED_11_CONSTEXPR auto map_error(F &&f) && {
    return map_error_impl(std::move(*this), std::forward<F>(f));
  }
  template <class F> constexpr auto map_error(F &&f) const & {
    return map_error_impl(*this, std::forward<F>(f));
  }
  template <class F> constexpr auto map_error(F &&f) const && {
    return map_error_impl(std::move(*this), std::forward<F>(f));
  }
#else
  template <class F>
  TL_EXPECTED_11_CONSTEXPR decltype(map_error_impl(std::declval<expected &>(),
                                                   std::declval<F &&>()))
  map_error(F &&f) & {
    return map_error_impl(*this, std::forward<F>(f));
  }
  template <class F>
  TL_EXPECTED_11_CONSTEXPR decltype(map_error_impl(std::declval<expected &&>(),
                                                   std::declval<F &&>()))
  map_error(F &&f) && {
    return map_error_impl(std::move(*this), std::forward<F>(f));
  }
  template <class F>
  constexpr decltype(map_error_impl(std::declval<const expected &>(),
                                    std::declval<F &&>()))
  map_error(F &&f) const & {
    return map_error_impl(*this, std::forward<F>(f));
  }

#ifndef TL_EXPECTED_NO_CONSTRR
  template <class F>
  constexpr decltype(map_error_impl(std::declval<const expected &&>(),
                                    std::declval<F &&>()))
  map_error(F &&f) const && {
    return map_error_impl(std::move(*this), std::forward<F>(f));
  }
#endif
#endif
#if defined(TL_EXPECTED_CXX14) && !defined(TL_EXPECTED_GCC49) &&               \
    !defined(TL_EXPECTED_GCC54) && !defined(TL_EXPECTED_GCC55)
  template <class F> TL_EXPECTED_11_CONSTEXPR auto transform_error(F &&f) & {
    return map_error_impl(*this, std::forward<F>(f));
  }
  template <class F> TL_EXPECTED_11_CONSTEXPR auto transform_error(F &&f) && {
    return map_error_impl(std::move(*this), std::forward<F>(f));
  }
  template <class F> constexpr auto transform_error(F &&f) const & {
    return map_error_impl(*this, std::forward<F>(f));
  }
  template <class F> constexpr auto transform_error(F &&f) const && {
    return map_error_impl(std::move(*this), std::forward<F>(f));
  }
#else
  template <class F>
  TL_EXPECTED_11_CONSTEXPR decltype(map_error_impl(std::declval<expected &>(),
                                                   std::declval<F &&>()))
  transform_error(F &&f) & {
    return map_error_impl(*this, std::forward<F>(f));
  }
  template <class F>
  TL_EXPECTED_11_CONSTEXPR decltype(map_error_impl(std::declval<expected &&>(),
                                                   std::declval<F &&>()))
  transform_error(F &&f) && {
    return map_error_impl(std::move(*this), std::forward<F>(f));
  }
  template <class F>
  constexpr decltype(map_error_impl(std::declval<const expected &>(),
                                    std::declval<F &&>()))
  transform_error(F &&f) const & {
    return map_error_impl(*this, std::forward<F>(f));
  }

#ifndef TL_EXPECTED_NO_CONSTRR
  template <class F>
  constexpr decltype(map_error_impl(std::declval<const expected &&>(),
                                    std::declval<F &&>()))
  transform_error(F &&f) const && {
    return map_error_impl(std::move(*this), std::forward<F>(f));
  }
#endif
#endif
  template <class F> expected TL_EXPECTED_11_CONSTEXPR or_else(F &&f) & {
    return or_else_impl(*this, std::forward<F>(f));
  }

  template <class F> expected TL_EXPECTED_11_CONSTEXPR or_else(F &&f) && {
    return or_else_impl(std::move(*this), std::forward<F>(f));
  }

  template <class F> expected constexpr or_else(F &&f) const & {
    return or_else_impl(*this, std::forward<F>(f));
  }

#ifndef TL_EXPECTED_NO_CONSTRR
  template <class F> expected constexpr or_else(F &&f) const && {
    return or_else_impl(std::move(*this), std::forward<F>(f));
  }
#endif
  constexpr expected() = default;
  constexpr expected(const expected &rhs) = default;
  constexpr expected(expected &&rhs) = default;
  expected &operator=(const expected &rhs) = default;
  expected &operator=(expected &&rhs) = default;

  template <class... Args,
            detail::enable_if_t<std::is_constructible<T, Args &&...>::value> * =
                nullptr>
  constexpr expected(in_place_t, Args &&...args)
      : impl_base(in_place, std::forward<Args>(args)...),
        ctor_base(detail::default_constructor_tag{}) {}

  template <class U, class... Args,
            detail::enable_if_t<std::is_constructible<
                T, std::initializer_list<U> &, Args &&...>::value> * = nullptr>
  constexpr expected(in_place_t, std::initializer_list<U> il, Args &&...args)
      : impl_base(in_place, il, std::forward<Args>(args)...),
        ctor_base(detail::default_constructor_tag{}) {}

  template <class G = E,
            detail::enable_if_t<std::is_constructible<E, const G &>::value> * =
                nullptr,
            detail::enable_if_t<!std::is_convertible<const G &, E>::value> * =
                nullptr>
  explicit constexpr expected(const unexpected<G> &e)
      : impl_base(unexpect, e.value()),
        ctor_base(detail::default_constructor_tag{}) {}

  template <
      class G = E,
      detail::enable_if_t<std::is_constructible<E, const G &>::value> * =
          nullptr,
      detail::enable_if_t<std::is_convertible<const G &, E>::value> * = nullptr>
  constexpr expected(unexpected<G> const &e)
      : impl_base(unexpect, e.value()),
        ctor_base(detail::default_constructor_tag{}) {}

  template <
      class G = E,
      detail::enable_if_t<std::is_constructible<E, G &&>::value> * = nullptr,
      detail::enable_if_t<!std::is_convertible<G &&, E>::value> * = nullptr>
  explicit constexpr expected(unexpected<G> &&e) noexcept(
      std::is_nothrow_constructible<E, G &&>::value)
      : impl_base(unexpect, std::move(e.value())),
        ctor_base(detail::default_constructor_tag{}) {}

  template <
      class G = E,
      detail::enable_if_t<std::is_constructible<E, G &&>::value> * = nullptr,
      detail::enable_if_t<std::is_convertible<G &&, E>::value> * = nullptr>
  constexpr expected(unexpected<G> &&e) noexcept(
      std::is_nothrow_constructible<E, G &&>::value)
      : impl_base(unexpect, std::move(e.value())),
        ctor_base(detail::default_constructor_tag{}) {}

  template <class... Args,
            detail::enable_if_t<std::is_constructible<E, Args &&...>::value> * =
                nullptr>
  constexpr explicit expected(unexpect_t, Args &&...args)
      : impl_base(unexpect, std::forward<Args>(args)...),
        ctor_base(detail::default_constructor_tag{}) {}

  template <class U, class... Args,
            detail::enable_if_t<std::is_constructible<
                E, std::initializer_list<U> &, Args &&...>::value> * = nullptr>
  constexpr explicit expected(unexpect_t, std::initializer_list<U> il,
                              Args &&...args)
      : impl_base(unexpect, il, std::forward<Args>(args)...),
        ctor_base(detail::default_constructor_tag{}) {}

  template <class U, class G,
            detail::enable_if_t<!(std::is_convertible<U const &, T>::value &&
                                  std::is_convertible<G const &, E>::value)> * =
                nullptr,
            detail::expected_enable_from_other<T, E, U, G, const U &, const G &>
                * = nullptr>
  explicit TL_EXPECTED_11_CONSTEXPR expected(const expected<U, G> &rhs)
      : ctor_base(detail::default_constructor_tag{}) {
    if (rhs.has_value()) {
      this->construct(*rhs);
    } else {
      this->construct_error(rhs.error());
    }
  }

  template <class U, class G,
            detail::enable_if_t<(std::is_convertible<U const &, T>::value &&
                                 std::is_convertible<G const &, E>::value)> * =
                nullptr,
            detail::expected_enable_from_other<T, E, U, G, const U &, const G &>
                * = nullptr>
  TL_EXPECTED_11_CONSTEXPR expected(const expected<U, G> &rhs)
      : ctor_base(detail::default_constructor_tag{}) {
    if (rhs.has_value()) {
      this->construct(*rhs);
    } else {
      this->construct_error(rhs.error());
    }
  }

  template <
      class U, class G,
      detail::enable_if_t<!(std::is_convertible<U &&, T>::value &&
                            std::is_convertible<G &&, E>::value)> * = nullptr,
      detail::expected_enable_from_other<T, E, U, G, U &&, G &&> * = nullptr>
  explicit TL_EXPECTED_11_CONSTEXPR expected(expected<U, G> &&rhs)
      : ctor_base(detail::default_constructor_tag{}) {
    if (rhs.has_value()) {
      this->construct(std::move(*rhs));
    } else {
      this->construct_error(std::move(rhs.error()));
    }
  }

  template <
      class U, class G,
      detail::enable_if_t<(std::is_convertible<U &&, T>::value &&
                           std::is_convertible<G &&, E>::value)> * = nullptr,
      detail::expected_enable_from_other<T, E, U, G, U &&, G &&> * = nullptr>
  TL_EXPECTED_11_CONSTEXPR expected(expected<U, G> &&rhs)
      : ctor_base(detail::default_constructor_tag{}) {
    if (rhs.has_value()) {
      this->construct(std::move(*rhs));
    } else {
      this->construct_error(std::move(rhs.error()));
    }
  }

  template <
      class U = T,
      detail::enable_if_t<!std::is_convertible<U &&, T>::value> * = nullptr,
      detail::expected_enable_forward_value<T, E, U> * = nullptr>
  explicit TL_EXPECTED_MSVC2015_CONSTEXPR expected(U &&v)
      : expected(in_place, std::forward<U>(v)) {}

  template <
      class U = T,
      detail::enable_if_t<std::is_convertible<U &&, T>::value> * = nullptr,
      detail::expected_enable_forward_value<T, E, U> * = nullptr>
  TL_EXPECTED_MSVC2015_CONSTEXPR expected(U &&v)
      : expected(in_place, std::forward<U>(v)) {}

  template <
      class U = T, class G = T,
      detail::enable_if_t<std::is_nothrow_constructible<T, U &&>::value> * =
          nullptr,
      detail::enable_if_t<!std::is_void<G>::value> * = nullptr,
      detail::enable_if_t<
          (!std::is_same<expected<T, E>, detail::decay_t<U>>::value &&
           !detail::conjunction<std::is_scalar<T>,
                                std::is_same<T, detail::decay_t<U>>>::value &&
           std::is_constructible<T, U>::value &&
           std::is_assignable<G &, U>::value &&
           std::is_nothrow_move_constructible<E>::value)> * = nullptr>
  expected &operator=(U &&v) {
    if (has_value()) {
      val() = std::forward<U>(v);
    } else {
      err().~unexpected<E>();
      ::new (valptr()) T(std::forward<U>(v));
      this->m_has_val = true;
    }

    return *this;
  }

  template <
      class U = T, class G = T,
      detail::enable_if_t<!std::is_nothrow_constructible<T, U &&>::value> * =
          nullptr,
      detail::enable_if_t<!std::is_void<U>::value> * = nullptr,
      detail::enable_if_t<
          (!std::is_same<expected<T, E>, detail::decay_t<U>>::value &&
           !detail::conjunction<std::is_scalar<T>,
                                std::is_same<T, detail::decay_t<U>>>::value &&
           std::is_constructible<T, U>::value &&
           std::is_assignable<G &, U>::value &&
           std::is_nothrow_move_constructible<E>::value)> * = nullptr>
  expected &operator=(U &&v) {
    if (has_value()) {
      val() = std::forward<U>(v);
    } else {
      auto tmp = std::move(err());
      err().~unexpected<E>();

#ifdef TL_EXPECTED_EXCEPTIONS_ENABLED
      try {
        ::new (valptr()) T(std::forward<U>(v));
        this->m_has_val = true;
      } catch (...) {
        err() = std::move(tmp);
        throw;
      }
#else
      ::new (valptr()) T(std::forward<U>(v));
      this->m_has_val = true;
#endif
    }

    return *this;
  }

  template <class G = E,
            detail::enable_if_t<std::is_nothrow_copy_constructible<G>::value &&
                                std::is_assignable<G &, G>::value> * = nullptr>
  expected &operator=(const unexpected<G> &rhs) {
    if (!has_value()) {
      err() = rhs;
    } else {
      this->destroy_val();
      ::new (errptr()) unexpected<E>(rhs);
      this->m_has_val = false;
    }

    return *this;
  }

  template <class G = E,
            detail::enable_if_t<std::is_nothrow_move_constructible<G>::value &&
                                std::is_move_assignable<G>::value> * = nullptr>
  expected &operator=(unexpected<G> &&rhs) noexcept {
    if (!has_value()) {
      err() = std::move(rhs);
    } else {
      this->destroy_val();
      ::new (errptr()) unexpected<E>(std::move(rhs));
      this->m_has_val = false;
    }

    return *this;
  }

  template <class... Args, detail::enable_if_t<std::is_nothrow_constructible<
                               T, Args &&...>::value> * = nullptr>
  void emplace(Args &&...args) {
    if (has_value()) {
      val().~T();
    } else {
      err().~unexpected<E>();
      this->m_has_val = true;
    }
    ::new (valptr()) T(std::forward<Args>(args)...);
  }

  template <class... Args, detail::enable_if_t<!std::is_nothrow_constructible<
                               T, Args &&...>::value> * = nullptr>
  void emplace(Args &&...args) {
    if (has_value()) {
      val().~T();
      ::new (valptr()) T(std::forward<Args>(args)...);
    } else {
      auto tmp = std::move(err());
      err().~unexpected<E>();

#ifdef TL_EXPECTED_EXCEPTIONS_ENABLED
      try {
        ::new (valptr()) T(std::forward<Args>(args)...);
        this->m_has_val = true;
      } catch (...) {
        err() = std::move(tmp);
        throw;
      }
#else
      ::new (valptr()) T(std::forward<Args>(args)...);
      this->m_has_val = true;
#endif
    }
  }

  template <class U, class... Args,
            detail::enable_if_t<std::is_nothrow_constructible<
                T, std::initializer_list<U> &, Args &&...>::value> * = nullptr>
  void emplace(std::initializer_list<U> il, Args &&...args) {
    if (has_value()) {
      T t(il, std::forward<Args>(args)...);
      val() = std::move(t);
    } else {
      err().~unexpected<E>();
      ::new (valptr()) T(il, std::forward<Args>(args)...);
      this->m_has_val = true;
    }
  }

  template <class U, class... Args,
            detail::enable_if_t<!std::is_nothrow_constructible<
                T, std::initializer_list<U> &, Args &&...>::value> * = nullptr>
  void emplace(std::initializer_list<U> il, Args &&...args) {
    if (has_value()) {
      T t(il, std::forward<Args>(args)...);
      val() = std::move(t);
    } else {
      auto tmp = std::move(err());
      err().~unexpected<E>();

#ifdef TL_EXPECTED_EXCEPTIONS_ENABLED
      try {
        ::new (valptr()) T(il, std::forward<Args>(args)...);
        this->m_has_val = true;
      } catch (...) {
        err() = std::move(tmp);
        throw;
      }
#else
      ::new (valptr()) T(il, std::forward<Args>(args)...);
      this->m_has_val = true;
#endif
    }
  }

private:
  using t_is_void = std::true_type;
  using t_is_not_void = std::false_type;
  using t_is_nothrow_move_constructible = std::true_type;
  using move_constructing_t_can_throw = std::false_type;
  using e_is_nothrow_move_constructible = std::true_type;
  using move_constructing_e_can_throw = std::false_type;

  void swap_where_both_have_value(expected & /*rhs*/, t_is_void) noexcept {
    // swapping void is a no-op
  }

  void swap_where_both_have_value(expected &rhs, t_is_not_void) {
    using std::swap;
    swap(val(), rhs.val());
  }

  void swap_where_only_one_has_value(expected &rhs, t_is_void) noexcept(
      std::is_nothrow_move_constructible<E>::value) {
    ::new (errptr()) unexpected_type(std::move(rhs.err()));
    rhs.err().~unexpected_type();
    std::swap(this->m_has_val, rhs.m_has_val);
  }

  void swap_where_only_one_has_value(expected &rhs, t_is_not_void) {
    swap_where_only_one_has_value_and_t_is_not_void(
        rhs, typename std::is_nothrow_move_constructible<T>::type{},
        typename std::is_nothrow_move_constructible<E>::type{});
  }

  void swap_where_only_one_has_value_and_t_is_not_void(
      expected &rhs, t_is_nothrow_move_constructible,
      e_is_nothrow_move_constructible) noexcept {
    auto temp = std::move(val());
    val().~T();
    ::new (errptr()) unexpected_type(std::move(rhs.err()));
    rhs.err().~unexpected_type();
    ::new (rhs.valptr()) T(std::move(temp));
    std::swap(this->m_has_val, rhs.m_has_val);
  }

  void swap_where_only_one_has_value_and_t_is_not_void(
      expected &rhs, t_is_nothrow_move_constructible,
      move_constructing_e_can_throw) {
    auto temp = std::move(val());
    val().~T();
#ifdef TL_EXPECTED_EXCEPTIONS_ENABLED
    try {
      ::new (errptr()) unexpected_type(std::move(rhs.err()));
      rhs.err().~unexpected_type();
      ::new (rhs.valptr()) T(std::move(temp));
      std::swap(this->m_has_val, rhs.m_has_val);
    } catch (...) {
      val() = std::move(temp);
      throw;
    }
#else
    ::new (errptr()) unexpected_type(std::move(rhs.err()));
    rhs.err().~unexpected_type();
    ::new (rhs.valptr()) T(std::move(temp));
    std::swap(this->m_has_val, rhs.m_has_val);
#endif
  }

  void swap_where_only_one_has_value_and_t_is_not_void(
      expected &rhs, move_constructing_t_can_throw,
      e_is_nothrow_move_constructible) {
    auto temp = std::move(rhs.err());
    rhs.err().~unexpected_type();
#ifdef TL_EXPECTED_EXCEPTIONS_ENABLED
    try {
      ::new (rhs.valptr()) T(std::move(val()));
      val().~T();
      ::new (errptr()) unexpected_type(std::move(temp));
      std::swap(this->m_has_val, rhs.m_has_val);
    } catch (...) {
      rhs.err() = std::move(temp);
      throw;
    }
#else
    ::new (rhs.valptr()) T(std::move(val()));
    val().~T();
    ::new (errptr()) unexpected_type(std::move(temp));
    std::swap(this->m_has_val, rhs.m_has_val);
#endif
  }

public:
  template <class OT = T, class OE = E>
  detail::enable_if_t<detail::is_swappable<OT>::value &&
                      detail::is_swappable<OE>::value &&
                      (std::is_nothrow_move_constructible<OT>::value ||
                       std::is_nothrow_move_constructible<OE>::value)>
  swap(expected &rhs) noexcept(
      std::is_nothrow_move_constructible<T>::value
          &&detail::is_nothrow_swappable<T>::value
              &&std::is_nothrow_move_constructible<E>::value
                  &&detail::is_nothrow_swappable<E>::value) {
    if (has_value() && rhs.has_value()) {
      swap_where_both_have_value(rhs, typename std::is_void<T>::type{});
    } else if (!has_value() && rhs.has_value()) {
      rhs.swap(*this);
    } else if (has_value()) {
      swap_where_only_one_has_value(rhs, typename std::is_void<T>::type{});
    } else {
      using std::swap;
      swap(err(), rhs.err());
    }
  }

  constexpr const T *operator->() const {
    TL_ASSERT(has_value());
    return valptr();
  }
  TL_EXPECTED_11_CONSTEXPR T *operator->() {
    TL_ASSERT(has_value());
    return valptr();
  }

  template <class U = T,
            detail::enable_if_t<!std::is_void<U>::value> * = nullptr>
  constexpr const U &operator*() const & {
    TL_ASSERT(has_value());
    return val();
  }
  template <class U = T,
            detail::enable_if_t<!std::is_void<U>::value> * = nullptr>
  TL_EXPECTED_11_CONSTEXPR U &operator*() & {
    TL_ASSERT(has_value());
    return val();
  }
  template <class U = T,
            detail::enable_if_t<!std::is_void<U>::value> * = nullptr>
  constexpr const U &&operator*() const && {
    TL_ASSERT(has_value());
    return std::move(val());
  }
  template <class U = T,
            detail::enable_if_t<!std::is_void<U>::value> * = nullptr>
  TL_EXPECTED_11_CONSTEXPR U &&operator*() && {
    TL_ASSERT(has_value());
    return std::move(val());
  }

  constexpr bool has_value() const noexcept { return this->m_has_val; }
  constexpr explicit operator bool() const noexcept { return this->m_has_val; }

  template <class U = T,
            detail::enable_if_t<!std::is_void<U>::value> * = nullptr>
  TL_EXPECTED_11_CONSTEXPR const U &value() const & {
    if (!has_value())
      detail::throw_exception(bad_expected_access<E>(err().value()));
    return val();
  }
  template <class U = T,
            detail::enable_if_t<!std::is_void<U>::value> * = nullptr>
  TL_EXPECTED_11_CONSTEXPR U &value() & {
    if (!has_value())
      detail::throw_exception(bad_expected_access<E>(err().value()));
    return val();
  }
  template <class U = T,
            detail::enable_if_t<!std::is_void<U>::value> * = nullptr>
  TL_EXPECTED_11_CONSTEXPR const U &&value() const && {
    if (!has_value())
      detail::throw_exception(bad_expected_access<E>(std::move(err()).value()));
    return std::move(val());
  }
  template <class U = T,
            detail::enable_if_t<!std::is_void<U>::value> * = nullptr>
  TL_EXPECTED_11_CONSTEXPR U &&value() && {
    if (!has_value())
      detail::throw_exception(bad_expected_access<E>(std::move(err()).value()));
    return std::move(val());
  }

  constexpr const E &error() const & {
    TL_ASSERT(!has_value());
    return err().value();
  }
  TL_EXPECTED_11_CONSTEXPR E &error() & {
    TL_ASSERT(!has_value());
    return err().value();
  }
  constexpr const E &&error() const && {
    TL_ASSERT(!has_value());
    return std::move(err().value());
  }
  TL_EXPECTED_11_CONSTEXPR E &&error() && {
    TL_ASSERT(!has_value());
    return std::move(err().value());
  }

  template <class U> constexpr T value_or(U &&v) const & {
    static_assert(std::is_copy_constructible<T>::value &&
                      std::is_convertible<U &&, T>::value,
                  "T must be copy-constructible and convertible to from U&&");
    return bool(*this) ? **this : static_cast<T>(std::forward<U>(v));
  }
  template <class U> TL_EXPECTED_11_CONSTEXPR T value_or(U &&v) && {
    static_assert(std::is_move_constructible<T>::value &&
                      std::is_convertible<U &&, T>::value,
                  "T must be move-constructible and convertible to from U&&");
    return bool(*this) ? std::move(**this) : static_cast<T>(std::forward<U>(v));
  }
};

namespace detail {
template <class Exp> using exp_t = typename detail::decay_t<Exp>::value_type;
template <class Exp> using err_t = typename detail::decay_t<Exp>::error_type;
template <class Exp, class Ret> using ret_t = expected<Ret, err_t<Exp>>;

#ifdef TL_EXPECTED_CXX14
template <class Exp, class F,
          detail::enable_if_t<!std::is_void<exp_t<Exp>>::value> * = nullptr,
          class Ret = decltype(detail::invoke(std::declval<F>(),
                                              *std::declval<Exp>()))>
constexpr auto and_then_impl(Exp &&exp, F &&f) {
  static_assert(detail::is_expected<Ret>::value, "F must return an expected");

  return exp.has_value()
             ? detail::invoke(std::forward<F>(f), *std::forward<Exp>(exp))
             : Ret(unexpect, std::forward<Exp>(exp).error());
}

template <class Exp, class F,
          detail::enable_if_t<std::is_void<exp_t<Exp>>::value> * = nullptr,
          class Ret = decltype(detail::invoke(std::declval<F>()))>
constexpr auto and_then_impl(Exp &&exp, F &&f) {
  static_assert(detail::is_expected<Ret>::value, "F must return an expected");

  return exp.has_value() ? detail::invoke(std::forward<F>(f))
                         : Ret(unexpect, std::forward<Exp>(exp).error());
}
#else
template <class> struct TC;
template <class Exp, class F,
          class Ret = decltype(detail::invoke(std::declval<F>(),
                                              *std::declval<Exp>())),
          detail::enable_if_t<!std::is_void<exp_t<Exp>>::value> * = nullptr>
auto and_then_impl(Exp &&exp, F &&f) -> Ret {
  static_assert(detail::is_expected<Ret>::value, "F must return an expected");

  return exp.has_value()
             ? detail::invoke(std::forward<F>(f), *std::forward<Exp>(exp))
             : Ret(unexpect, std::forward<Exp>(exp).error());
}

template <class Exp, class F,
          class Ret = decltype(detail::invoke(std::declval<F>())),
          detail::enable_if_t<std::is_void<exp_t<Exp>>::value> * = nullptr>
constexpr auto and_then_impl(Exp &&exp, F &&f) -> Ret {
  static_assert(detail::is_expected<Ret>::value, "F must return an expected");

  return exp.has_value() ? detail::invoke(std::forward<F>(f))
                         : Ret(unexpect, std::forward<Exp>(exp).error());
}
#endif

#ifdef TL_EXPECTED_CXX14
template <class Exp, class F,
          detail::enable_if_t<!std::is_void<exp_t<Exp>>::value> * = nullptr,
          class Ret = decltype(detail::invoke(std::declval<F>(),
                                              *std::declval<Exp>())),
          detail::enable_if_t<!std::is_void<Ret>::value> * = nullptr>
constexpr auto expected_map_impl(Exp &&exp, F &&f) {
  using result = ret_t<Exp, detail::decay_t<Ret>>;
  return exp.has_value() ? result(detail::invoke(std::forward<F>(f),
                                                 *std::forward<Exp>(exp)))
                         : result(unexpect, std::forward<Exp>(exp).error());
}

template <class Exp, class F,
          detail::enable_if_t<!std::is_void<exp_t<Exp>>::value> * = nullptr,
          class Ret = decltype(detail::invoke(std::declval<F>(),
                                              *std::declval<Exp>())),
          detail::enable_if_t<std::is_void<Ret>::value> * = nullptr>
auto expected_map_impl(Exp &&exp, F &&f) {
  using result = expected<void, err_t<Exp>>;
  if (exp.has_value()) {
    detail::invoke(std::forward<F>(f), *std::forward<Exp>(exp));
    return result();
  }

  return result(unexpect, std::forward<Exp>(exp).error());
}

template <class Exp, class F,
          detail::enable_if_t<std::is_void<exp_t<Exp>>::value> * = nullptr,
          class Ret = decltype(detail::invoke(std::declval<F>())),
          detail::enable_if_t<!std::is_void<Ret>::value> * = nullptr>
constexpr auto expected_map_impl(Exp &&exp, F &&f) {
  using result = ret_t<Exp, detail::decay_t<Ret>>;
  return exp.has_value() ? result(detail::invoke(std::forward<F>(f)))
                         : result(unexpect, std::forward<Exp>(exp).error());
}

template <class Exp, class F,
          detail::enable_if_t<std::is_void<exp_t<Exp>>::value> * = nullptr,
          class Ret = decltype(detail::invoke(std::declval<F>())),
          detail::enable_if_t<std::is_void<Ret>::value> * = nullptr>
auto expected_map_impl(Exp &&exp, F &&f) {
  using result = expected<void, err_t<Exp>>;
  if (exp.has_value()) {
    detail::invoke(std::forward<F>(f));
    return result();
  }

  return result(unexpect, std::forward<Exp>(exp).error());
}
#else
template <class Exp, class F,
          detail::enable_if_t<!std::is_void<exp_t<Exp>>::value> * = nullptr,
          class Ret = decltype(detail::invoke(std::declval<F>(),
                                              *std::declval<Exp>())),
          detail::enable_if_t<!std::is_void<Ret>::value> * = nullptr>

constexpr auto expected_map_impl(Exp &&exp, F &&f)
    -> ret_t<Exp, detail::decay_t<Ret>> {
  using result = ret_t<Exp, detail::decay_t<Ret>>;

  return exp.has_value() ? result(detail::invoke(std::forward<F>(f),
                                                 *std::forward<Exp>(exp)))
                         : result(unexpect, std::forward<Exp>(exp).error());
}

template <class Exp, class F,
          detail::enable_if_t<!std::is_void<exp_t<Exp>>::value> * = nullptr,
          class Ret = decltype(detail::invoke(std::declval<F>(),
                                              *std::declval<Exp>())),
          detail::enable_if_t<std::is_void<Ret>::value> * = nullptr>

auto expected_map_impl(Exp &&exp, F &&f) -> expected<void, err_t<Exp>> {
  if (exp.has_value()) {
    detail::invoke(std::forward<F>(f), *std::forward<Exp>(exp));
    return {};
  }

  return unexpected<err_t<Exp>>(std::forward<Exp>(exp).error());
}

template <class Exp, class F,
          detail::enable_if_t<std::is_void<exp_t<Exp>>::value> * = nullptr,
          class Ret = decltype(detail::invoke(std::declval<F>())),
          detail::enable_if_t<!std::is_void<Ret>::value> * = nullptr>

constexpr auto expected_map_impl(Exp &&exp, F &&f)
    -> ret_t<Exp, detail::decay_t<Ret>> {
  using result = ret_t<Exp, detail::decay_t<Ret>>;

  return exp.has_value() ? result(detail::invoke(std::forward<F>(f)))
                         : result(unexpect, std::forward<Exp>(exp).error());
}

template <class Exp, class F,
          detail::enable_if_t<std::is_void<exp_t<Exp>>::value> * = nullptr,
          class Ret = decltype(detail::invoke(std::declval<F>())),
          detail::enable_if_t<std::is_void<Ret>::value> * = nullptr>

auto expected_map_impl(Exp &&exp, F &&f) -> expected<void, err_t<Exp>> {
  if (exp.has_value()) {
    detail::invoke(std::forward<F>(f));
    return {};
  }

  return unexpected<err_t<Exp>>(std::forward<Exp>(exp).error());
}
#endif

#if defined(TL_EXPECTED_CXX14) && !defined(TL_EXPECTED_GCC49) &&               \
    !defined(TL_EXPECTED_GCC54) && !defined(TL_EXPECTED_GCC55)
template <class Exp, class F,
          detail::enable_if_t<!std::is_void<exp_t<Exp>>::value> * = nullptr,
          class Ret = decltype(detail::invoke(std::declval<F>(),
                                              std::declval<Exp>().error())),
          detail::enable_if_t<!std::is_void<Ret>::value> * = nullptr>
constexpr auto map_error_impl(Exp &&exp, F &&f) {
  using result = expected<exp_t<Exp>, detail::decay_t<Ret>>;
  return exp.has_value()
             ? result(*std::forward<Exp>(exp))
             : result(unexpect, detail::invoke(std::forward<F>(f),
                                               std::forward<Exp>(exp).error()));
}
template <class Exp, class F,
          detail::enable_if_t<!std::is_void<exp_t<Exp>>::value> * = nullptr,
          class Ret = decltype(detail::invoke(std::declval<F>(),
                                              std::declval<Exp>().error())),
          detail::enable_if_t<std::is_void<Ret>::value> * = nullptr>
auto map_error_impl(Exp &&exp, F &&f) {
  using result = expected<exp_t<Exp>, monostate>;
  if (exp.has_value()) {
    return result(*std::forward<Exp>(exp));
  }

  detail::invoke(std::forward<F>(f), std::forward<Exp>(exp).error());
  return result(unexpect, monostate{});
}
template <class Exp, class F,
          detail::enable_if_t<std::is_void<exp_t<Exp>>::value> * = nullptr,
          class Ret = decltype(detail::invoke(std::declval<F>(),
                                              std::declval<Exp>().error())),
          detail::enable_if_t<!std::is_void<Ret>::value> * = nullptr>
constexpr auto map_error_impl(Exp &&exp, F &&f) {
  using result = expected<exp_t<Exp>, detail::decay_t<Ret>>;
  return exp.has_value()
             ? result()
             : result(unexpect, detail::invoke(std::forward<F>(f),
                                               std::forward<Exp>(exp).error()));
}
template <class Exp, class F,
          detail::enable_if_t<std::is_void<exp_t<Exp>>::value> * = nullptr,
          class Ret = decltype(detail::invoke(std::declval<F>(),
                                              std::declval<Exp>().error())),
          detail::enable_if_t<std::is_void<Ret>::value> * = nullptr>
auto map_error_impl(Exp &&exp, F &&f) {
  using result = expected<exp_t<Exp>, monostate>;
  if (exp.has_value()) {
    return result();
  }

  detail::invoke(std::forward<F>(f), std::forward<Exp>(exp).error());
  return result(unexpect, monostate{});
}
#else
template <class Exp, class F,
          detail::enable_if_t<!std::is_void<exp_t<Exp>>::value> * = nullptr,
          class Ret = decltype(detail::invoke(std::declval<F>(),
                                              std::declval<Exp>().error())),
          detail::enable_if_t<!std::is_void<Ret>::value> * = nullptr>
constexpr auto map_error_impl(Exp &&exp, F &&f)
    -> expected<exp_t<Exp>, detail::decay_t<Ret>> {
  using result = expected<exp_t<Exp>, detail::decay_t<Ret>>;

  return exp.has_value()
             ? result(*std::forward<Exp>(exp))
             : result(unexpect, detail::invoke(std::forward<F>(f),
                                               std::forward<Exp>(exp).error()));
}

template <class Exp, class F,
          detail::enable_if_t<!std::is_void<exp_t<Exp>>::value> * = nullptr,
          class Ret = decltype(detail::invoke(std::declval<F>(),
                                              std::declval<Exp>().error())),
          detail::enable_if_t<std::is_void<Ret>::value> * = nullptr>
auto map_error_impl(Exp &&exp, F &&f) -> expected<exp_t<Exp>, monostate> {
  using result = expected<exp_t<Exp>, monostate>;
  if (exp.has_value()) {
    return result(*std::forward<Exp>(exp));
  }

  detail::invoke(std::forward<F>(f), std::forward<Exp>(exp).error());
  return result(unexpect, monostate{});
}

template <class Exp, class F,
          detail::enable_if_t<std::is_void<exp_t<Exp>>::value> * = nullptr,
          class Ret = decltype(detail::invoke(std::declval<F>(),
                                              std::declval<Exp>().error())),
          detail::enable_if_t<!std::is_void<Ret>::value> * = nullptr>
constexpr auto map_error_impl(Exp &&exp, F &&f)
    -> expected<exp_t<Exp>, detail::decay_t<Ret>> {
  using result = expected<exp_t<Exp>, detail::decay_t<Ret>>;

  return exp.has_value()
             ? result()
             : result(unexpect, detail::invoke(std::forward<F>(f),
                                               std::forward<Exp>(exp).error()));
}

template <class Exp, class F,
          detail::enable_if_t<std::is_void<exp_t<Exp>>::value> * = nullptr,
          class Ret = decltype(detail::invoke(std::declval<F>(),
                                              std::declval<Exp>().error())),
          detail::enable_if_t<std::is_void<Ret>::value> * = nullptr>
auto map_error_impl(Exp &&exp, F &&f) -> expected<exp_t<Exp>, monostate> {
  using result = expected<exp_t<Exp>, monostate>;
  if (exp.has_value()) {
    return result();
  }

  detail::invoke(std::forward<F>(f), std::forward<Exp>(exp).error());
  return result(unexpect, monostate{});
}
#endif

#ifdef TL_EXPECTED_CXX14
template <class Exp, class F,
          class Ret = decltype(detail::invoke(std::declval<F>(),
                                              std::declval<Exp>().error())),
          detail::enable_if_t<!std::is_void<Ret>::value> * = nullptr>
constexpr auto or_else_impl(Exp &&exp, F &&f) {
  static_assert(detail::is_expected<Ret>::value, "F must return an expected");
  return exp.has_value() ? std::forward<Exp>(exp)
                         : detail::invoke(std::forward<F>(f),
                                          std::forward<Exp>(exp).error());
}

template <class Exp, class F,
          class Ret = decltype(detail::invoke(std::declval<F>(),
                                              std::declval<Exp>().error())),
          detail::enable_if_t<std::is_void<Ret>::value> * = nullptr>
detail::decay_t<Exp> or_else_impl(Exp &&exp, F &&f) {
  return exp.has_value() ? std::forward<Exp>(exp)
                         : (detail::invoke(std::forward<F>(f),
                                           std::forward<Exp>(exp).error()),
                            std::forward<Exp>(exp));
}
#else
template <class Exp, class F,
          class Ret = decltype(detail::invoke(std::declval<F>(),
                                              std::declval<Exp>().error())),
          detail::enable_if_t<!std::is_void<Ret>::value> * = nullptr>
auto or_else_impl(Exp &&exp, F &&f) -> Ret {
  static_assert(detail::is_expected<Ret>::value, "F must return an expected");
  return exp.has_value() ? std::forward<Exp>(exp)
                         : detail::invoke(std::forward<F>(f),
                                          std::forward<Exp>(exp).error());
}

template <class Exp, class F,
          class Ret = decltype(detail::invoke(std::declval<F>(),
                                              std::declval<Exp>().error())),
          detail::enable_if_t<std::is_void<Ret>::value> * = nullptr>
detail::decay_t<Exp> or_else_impl(Exp &&exp, F &&f) {
  return exp.has_value() ? std::forward<Exp>(exp)
                         : (detail::invoke(std::forward<F>(f),
                                           std::forward<Exp>(exp).error()),
                            std::forward<Exp>(exp));
}
#endif
} // namespace detail

template <class T, class E, class U, class F>
constexpr bool operator==(const expected<T, E> &lhs,
                          const expected<U, F> &rhs) {
  return (lhs.has_value() != rhs.has_value())
             ? false
             : (!lhs.has_value() ? lhs.error() == rhs.error() : *lhs == *rhs);
}
template <class T, class E, class U, class F>
constexpr bool operator!=(const expected<T, E> &lhs,
                          const expected<U, F> &rhs) {
  return (lhs.has_value() != rhs.has_value())
             ? true
             : (!lhs.has_value() ? lhs.error() != rhs.error() : *lhs != *rhs);
}
template <class E, class F>
constexpr bool operator==(const expected<void, E> &lhs,
                          const expected<void, F> &rhs) {
  return (lhs.has_value() != rhs.has_value())
             ? false
             : (!lhs.has_value() ? lhs.error() == rhs.error() : true);
}
template <class E, class F>
constexpr bool operator!=(const expected<void, E> &lhs,
                          const expected<void, F> &rhs) {
  return (lhs.has_value() != rhs.has_value())
             ? true
             : (!lhs.has_value() ? lhs.error() == rhs.error() : false);
}

template <class T, class E, class U>
constexpr bool operator==(const expected<T, E> &x, const U &v) {
  return x.has_value() ? *x == v : false;
}
template <class T, class E, class U>
constexpr bool operator==(const U &v, const expected<T, E> &x) {
  return x.has_value() ? *x == v : false;
}
template <class T, class E, class U>
constexpr bool operator!=(const expected<T, E> &x, const U &v) {
  return x.has_value() ? *x != v : true;
}
template <class T, class E, class U>
constexpr bool operator!=(const U &v, const expected<T, E> &x) {
  return x.has_value() ? *x != v : true;
}

template <class T, class E>
constexpr bool operator==(const expected<T, E> &x, const unexpected<E> &e) {
  return x.has_value() ? false : x.error() == e.value();
}
template <class T, class E>
constexpr bool operator==(const unexpected<E> &e, const expected<T, E> &x) {
  return x.has_value() ? false : x.error() == e.value();
}
template <class T, class E>
constexpr bool operator!=(const expected<T, E> &x, const unexpected<E> &e) {
  return x.has_value() ? true : x.error() != e.value();
}
template <class T, class E>
constexpr bool operator!=(const unexpected<E> &e, const expected<T, E> &x) {
  return x.has_value() ? true : x.error() != e.value();
}

template <class T, class E,
          detail::enable_if_t<(std::is_void<T>::value ||
                               std::is_move_constructible<T>::value) &&
                              detail::is_swappable<T>::value &&
                              std::is_move_constructible<E>::value &&
                              detail::is_swappable<E>::value> * = nullptr>
void swap(expected<T, E> &lhs,
          expected<T, E> &rhs) noexcept(noexcept(lhs.swap(rhs))) {
  lhs.swap(rhs);
}
} // namespace tl

#endif

```

`KDemu/include/LIEF/LIEF/third-party/internal/span.hpp`:

```hpp

/*
This is an implementation of C++20's std::span
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/n4820.pdf
*/

//          Copyright Tristan Brindle 2018.
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file ../../LICENSE_1_0.txt or copy at
//          https://www.boost.org/LICENSE_1_0.txt)

#ifndef TCB_SPAN_HPP_INCLUDED
#define TCB_SPAN_HPP_INCLUDED

#include <array>
#include <cstddef>
#include <cstdint>
#include <type_traits>

#ifndef TCB_SPAN_NO_EXCEPTIONS
// Attempt to discover whether we're being compiled with exception support
#if !(defined(__cpp_exceptions) || defined(__EXCEPTIONS) || defined(_CPPUNWIND))
#define TCB_SPAN_NO_EXCEPTIONS
#endif
#endif

#ifndef TCB_SPAN_NO_EXCEPTIONS
#include <cstdio>
#include <stdexcept>
#else
#include <exception> // for std::terminate
#endif

// Various feature test macros

#ifndef TCB_SPAN_NAMESPACE_NAME
#define TCB_SPAN_NAMESPACE_NAME tcb
#endif

#if __cplusplus >= 201703L || (defined(_MSVC_LANG) && _MSVC_LANG >= 201703L)
#define TCB_SPAN_HAVE_CPP17
#endif

#if __cplusplus >= 201402L || (defined(_MSVC_LANG) && _MSVC_LANG >= 201402L)
#define TCB_SPAN_HAVE_CPP14
#endif

namespace TCB_SPAN_NAMESPACE_NAME {

// Establish default contract checking behavior
#if !defined(TCB_SPAN_THROW_ON_CONTRACT_VIOLATION) &&                          \
    !defined(TCB_SPAN_TERMINATE_ON_CONTRACT_VIOLATION) &&                      \
    !defined(TCB_SPAN_NO_CONTRACT_CHECKING)
#if defined(NDEBUG) || !defined(TCB_SPAN_HAVE_CPP14)
#define TCB_SPAN_NO_CONTRACT_CHECKING
#else
#define TCB_SPAN_TERMINATE_ON_CONTRACT_VIOLATION
#endif
#endif

#if defined(TCB_SPAN_THROW_ON_CONTRACT_VIOLATION)
struct contract_violation_error : std::logic_error {
    explicit contract_violation_error(const char* msg) : std::logic_error(msg)
    {}
};

inline void contract_violation(const char* msg)
{
    throw contract_violation_error(msg);
}

#elif defined(TCB_SPAN_TERMINATE_ON_CONTRACT_VIOLATION)
[[noreturn]] inline void contract_violation(const char* /*unused*/)
{
    std::terminate();
}
#endif

#if !defined(TCB_SPAN_NO_CONTRACT_CHECKING)
#define TCB_SPAN_STRINGIFY(cond) #cond
#define TCB_SPAN_EXPECT(cond)                                                  \
    cond ? (void) 0 : contract_violation("Expected " TCB_SPAN_STRINGIFY(cond))
#else
#define TCB_SPAN_EXPECT(cond)
#endif

#if defined(TCB_SPAN_HAVE_CPP17) || defined(__cpp_inline_variables)
#define TCB_SPAN_INLINE_VAR inline
#else
#define TCB_SPAN_INLINE_VAR
#endif

#if defined(TCB_SPAN_HAVE_CPP14) ||                                            \
    (defined(__cpp_constexpr) && __cpp_constexpr >= 201304)
#define TCB_SPAN_HAVE_CPP14_CONSTEXPR
#endif

#if defined(TCB_SPAN_HAVE_CPP14_CONSTEXPR)
#define TCB_SPAN_CONSTEXPR14 constexpr
#else
#define TCB_SPAN_CONSTEXPR14
#endif

#if defined(TCB_SPAN_HAVE_CPP14_CONSTEXPR) &&                                  \
    (!defined(_MSC_VER) || _MSC_VER > 1900)
#define TCB_SPAN_CONSTEXPR_ASSIGN constexpr
#else
#define TCB_SPAN_CONSTEXPR_ASSIGN
#endif

#if defined(TCB_SPAN_NO_CONTRACT_CHECKING)
#define TCB_SPAN_CONSTEXPR11 constexpr
#else
#define TCB_SPAN_CONSTEXPR11 TCB_SPAN_CONSTEXPR14
#endif

#if defined(TCB_SPAN_HAVE_CPP17) || defined(__cpp_deduction_guides)
#define TCB_SPAN_HAVE_DEDUCTION_GUIDES
#endif

#if defined(TCB_SPAN_HAVE_CPP17) || defined(__cpp_lib_byte)
#define TCB_SPAN_HAVE_STD_BYTE
#endif

#if defined(TCB_SPAN_HAVE_CPP17) || defined(__cpp_lib_array_constexpr)
#define TCB_SPAN_HAVE_CONSTEXPR_STD_ARRAY_ETC
#endif

#if defined(TCB_SPAN_HAVE_CONSTEXPR_STD_ARRAY_ETC)
#define TCB_SPAN_ARRAY_CONSTEXPR constexpr
#else
#define TCB_SPAN_ARRAY_CONSTEXPR
#endif

#ifdef TCB_SPAN_HAVE_STD_BYTE
using byte = std::byte;
#else
using byte = unsigned char;
#endif

#if defined(TCB_SPAN_HAVE_CPP17)
#define TCB_SPAN_NODISCARD [[nodiscard]]
#else
#define TCB_SPAN_NODISCARD
#endif

TCB_SPAN_INLINE_VAR constexpr std::size_t dynamic_extent = SIZE_MAX;

template <typename ElementType, std::size_t Extent = dynamic_extent>
class span;

namespace detail {

template <typename E, std::size_t S>
struct span_storage {
    constexpr span_storage() noexcept = default;

    constexpr span_storage(E* p_ptr, std::size_t /*unused*/) noexcept
       : ptr(p_ptr)
    {}

    E* ptr = nullptr;
    static constexpr std::size_t size = S;
};

template <typename E>
struct span_storage<E, dynamic_extent> {
    constexpr span_storage() noexcept = default;

    constexpr span_storage(E* p_ptr, std::size_t p_size) noexcept
        : ptr(p_ptr), size(p_size)
    {}

    E* ptr = nullptr;
    std::size_t size = 0;
};

// Reimplementation of C++17 std::size() and std::data()
#if defined(TCB_SPAN_HAVE_CPP17) ||                                            \
    defined(__cpp_lib_nonmember_container_access)
using std::data;
using std::size;
#else
template <class C>
constexpr auto size(const C& c) -> decltype(c.size())
{
    return c.size();
}

template <class T, std::size_t N>
constexpr std::size_t size(const T (&)[N]) noexcept
{
    return N;
}

template <class C>
constexpr auto data(C& c) -> decltype(c.data())
{
    return c.data();
}

template <class C>
constexpr auto data(const C& c) -> decltype(c.data())
{
    return c.data();
}

template <class T, std::size_t N>
constexpr T* data(T (&array)[N]) noexcept
{
    return array;
}

template <class E>
constexpr const E* data(std::initializer_list<E> il) noexcept
{
    return il.begin();
}
#endif // TCB_SPAN_HAVE_CPP17

#if defined(TCB_SPAN_HAVE_CPP17) || defined(__cpp_lib_void_t)
using std::void_t;
#else
template <typename...>
using void_t = void;
#endif

template <typename T>
using uncvref_t =
    typename std::remove_cv<typename std::remove_reference<T>::type>::type;

template <typename>
struct is_span : std::false_type {};

template <typename T, std::size_t S>
struct is_span<span<T, S>> : std::true_type {};

template <typename>
struct is_std_array : std::false_type {};

template <typename T, std::size_t N>
struct is_std_array<std::array<T, N>> : std::true_type {};

template <typename, typename = void>
struct has_size_and_data : std::false_type {};

template <typename T>
struct has_size_and_data<T, void_t<decltype(detail::size(std::declval<T>())),
                                   decltype(detail::data(std::declval<T>()))>>
    : std::true_type {};

template <typename C, typename U = uncvref_t<C>>
struct is_container {
    static constexpr bool value =
        !is_span<U>::value && !is_std_array<U>::value &&
        !std::is_array<U>::value && has_size_and_data<C>::value;
};

template <typename T>
using remove_pointer_t = typename std::remove_pointer<T>::type;

template <typename, typename, typename = void>
struct is_container_element_type_compatible : std::false_type {};

template <typename T, typename E>
struct is_container_element_type_compatible<
    T, E,
    typename std::enable_if<
        !std::is_same<
            typename std::remove_cv<decltype(detail::data(std::declval<T>()))>::type,
            void>::value &&
        std::is_convertible<
            remove_pointer_t<decltype(detail::data(std::declval<T>()))> (*)[],
            E (*)[]>::value
        >::type>
    : std::true_type {};

template <typename, typename = size_t>
struct is_complete : std::false_type {};

template <typename T>
struct is_complete<T, decltype(sizeof(T))> : std::true_type {};

} // namespace detail

template <typename ElementType, std::size_t Extent>
class span {
    static_assert(std::is_object<ElementType>::value,
                  "A span's ElementType must be an object type (not a "
                  "reference type or void)");
    static_assert(detail::is_complete<ElementType>::value,
                  "A span's ElementType must be a complete type (not a forward "
                  "declaration)");
    static_assert(!std::is_abstract<ElementType>::value,
                  "A span's ElementType cannot be an abstract class type");

    using storage_type = detail::span_storage<ElementType, Extent>;

public:
    // constants and types
    using element_type = ElementType;
    using value_type = typename std::remove_cv<ElementType>::type;
    using size_type = std::size_t;
    using difference_type = std::ptrdiff_t;
    using pointer = element_type*;
    using const_pointer = const element_type*;
    using reference = element_type&;
    using const_reference = const element_type&;
    using iterator = pointer;
    using reverse_iterator = std::reverse_iterator<iterator>;

    static constexpr size_type extent = Extent;

    // [span.cons], span constructors, copy, assignment, and destructor
    template <
        std::size_t E = Extent,
        typename std::enable_if<(E == dynamic_extent || E <= 0), int>::type = 0>
    constexpr span() noexcept
    {}

    TCB_SPAN_CONSTEXPR11 span(pointer ptr, size_type count)
        : storage_(ptr, count)
    {
        TCB_SPAN_EXPECT(extent == dynamic_extent || count == extent);
    }

    TCB_SPAN_CONSTEXPR11 span(pointer first_elem, pointer last_elem)
        : storage_(first_elem, last_elem - first_elem)
    {
        TCB_SPAN_EXPECT(extent == dynamic_extent ||
                        last_elem - first_elem ==
                            static_cast<std::ptrdiff_t>(extent));
    }

    template <std::size_t N, std::size_t E = Extent,
              typename std::enable_if<
                  (E == dynamic_extent || N == E) &&
                      detail::is_container_element_type_compatible<
                          element_type (&)[N], ElementType>::value,
                  int>::type = 0>
    constexpr span(element_type (&arr)[N]) noexcept : storage_(arr, N)
    {}

    template <typename T, std::size_t N, std::size_t E = Extent,
              typename std::enable_if<
                  (E == dynamic_extent || N == E) &&
                      detail::is_container_element_type_compatible<
                          std::array<T, N>&, ElementType>::value,
                  int>::type = 0>
    TCB_SPAN_ARRAY_CONSTEXPR span(std::array<T, N>& arr) noexcept
        : storage_(arr.data(), N)
    {}

    template <typename T, std::size_t N, std::size_t E = Extent,
              typename std::enable_if<
                  (E == dynamic_extent || N == E) &&
                      detail::is_container_element_type_compatible<
                          const std::array<T, N>&, ElementType>::value,
                  int>::type = 0>
    TCB_SPAN_ARRAY_CONSTEXPR span(const std::array<T, N>& arr) noexcept
        : storage_(arr.data(), N)
    {}

    template <
        typename Container, std::size_t E = Extent,
        typename std::enable_if<
            E == dynamic_extent && detail::is_container<Container>::value &&
                detail::is_container_element_type_compatible<
                    Container&, ElementType>::value,
            int>::type = 0>
    constexpr span(Container& cont)
        : storage_(detail::data(cont), detail::size(cont))
    {}

    template <
        typename Container, std::size_t E = Extent,
        typename std::enable_if<
            E == dynamic_extent && detail::is_container<Container>::value &&
                detail::is_container_element_type_compatible<
                    const Container&, ElementType>::value,
            int>::type = 0>
    constexpr span(const Container& cont)
        : storage_(detail::data(cont), detail::size(cont))
    {}

    constexpr span(const span& other) noexcept = default;

    template <typename OtherElementType, std::size_t OtherExtent,
              typename std::enable_if<
                  (Extent == dynamic_extent || OtherExtent == dynamic_extent ||
                   Extent == OtherExtent) &&
                      std::is_convertible<OtherElementType (*)[],
                                          ElementType (*)[]>::value,
                  int>::type = 0>
    constexpr span(const span<OtherElementType, OtherExtent>& other) noexcept
        : storage_(other.data(), other.size())
    {}

    ~span() noexcept = default;

    TCB_SPAN_CONSTEXPR_ASSIGN span&
    operator=(const span& other) noexcept = default;

    // [span.sub], span subviews
    template <std::size_t Count>
    TCB_SPAN_CONSTEXPR11 span<element_type, Count> first() const
    {
        TCB_SPAN_EXPECT(Count <= size());
        return {data(), Count};
    }

    template <std::size_t Count>
    TCB_SPAN_CONSTEXPR11 span<element_type, Count> last() const
    {
        TCB_SPAN_EXPECT(Count <= size());
        return {data() + (size() - Count), Count};
    }

    template <std::size_t Offset, std::size_t Count = dynamic_extent>
    using subspan_return_t =
        span<ElementType, Count != dynamic_extent
                              ? Count
                              : (Extent != dynamic_extent ? Extent - Offset
                                                          : dynamic_extent)>;

    template <std::size_t Offset, std::size_t Count = dynamic_extent>
    TCB_SPAN_CONSTEXPR11 subspan_return_t<Offset, Count> subspan() const
    {
        TCB_SPAN_EXPECT(Offset <= size() &&
                        (Count == dynamic_extent || Offset + Count <= size()));
        return {data() + Offset,
                Count != dynamic_extent ? Count : size() - Offset};
    }

    TCB_SPAN_CONSTEXPR11 span<element_type, dynamic_extent>
    first(size_type count) const
    {
        TCB_SPAN_EXPECT(count <= size());
        return {data(), count};
    }

    TCB_SPAN_CONSTEXPR11 span<element_type, dynamic_extent>
    last(size_type count) const
    {
        TCB_SPAN_EXPECT(count <= size());
        return {data() + (size() - count), count};
    }

    TCB_SPAN_CONSTEXPR11 span<element_type, dynamic_extent>
    subspan(size_type offset, size_type count = dynamic_extent) const
    {
        TCB_SPAN_EXPECT(offset <= size() &&
                        (count == dynamic_extent || offset + count <= size()));
        return {data() + offset,
                count == dynamic_extent ? size() - offset : count};
    }

    // [span.obs], span observers
    constexpr size_type size() const noexcept { return storage_.size; }

    constexpr size_type size_bytes() const noexcept
    {
        return size() * sizeof(element_type);
    }

    TCB_SPAN_NODISCARD constexpr bool empty() const noexcept
    {
        return size() == 0;
    }

    // [span.elem], span element access
    TCB_SPAN_CONSTEXPR11 reference operator[](size_type idx) const
    {
        TCB_SPAN_EXPECT(idx < size());
        return *(data() + idx);
    }

    TCB_SPAN_CONSTEXPR11 reference front() const
    {
        TCB_SPAN_EXPECT(!empty());
        return *data();
    }

    TCB_SPAN_CONSTEXPR11 reference back() const
    {
        TCB_SPAN_EXPECT(!empty());
        return *(data() + (size() - 1));
    }

    constexpr pointer data() const noexcept { return storage_.ptr; }

    // [span.iterators], span iterator support
    constexpr iterator begin() const noexcept { return data(); }

    constexpr iterator end() const noexcept { return data() + size(); }

    TCB_SPAN_ARRAY_CONSTEXPR reverse_iterator rbegin() const noexcept
    {
        return reverse_iterator(end());
    }

    TCB_SPAN_ARRAY_CONSTEXPR reverse_iterator rend() const noexcept
    {
        return reverse_iterator(begin());
    }

private:
    storage_type storage_{};
};

#ifdef TCB_SPAN_HAVE_DEDUCTION_GUIDES

/* Deduction Guides */
template <class T, size_t N>
span(T (&)[N])->span<T, N>;

template <class T, size_t N>
span(std::array<T, N>&)->span<T, N>;

template <class T, size_t N>
span(const std::array<T, N>&)->span<const T, N>;

template <class Container>
span(Container&)->span<typename std::remove_reference<
    decltype(*detail::data(std::declval<Container&>()))>::type>;

template <class Container>
span(const Container&)->span<const typename Container::value_type>;

#endif // TCB_HAVE_DEDUCTION_GUIDES

template <typename ElementType, std::size_t Extent>
constexpr span<ElementType, Extent>
make_span(span<ElementType, Extent> s) noexcept
{
    return s;
}

template <typename T, std::size_t N>
constexpr span<T, N> make_span(T (&arr)[N]) noexcept
{
    return {arr};
}

template <typename T, std::size_t N>
TCB_SPAN_ARRAY_CONSTEXPR span<T, N> make_span(std::array<T, N>& arr) noexcept
{
    return {arr};
}

template <typename T, std::size_t N>
TCB_SPAN_ARRAY_CONSTEXPR span<const T, N>
make_span(const std::array<T, N>& arr) noexcept
{
    return {arr};
}

template <typename Container>
constexpr span<typename std::remove_reference<
    decltype(*detail::data(std::declval<Container&>()))>::type>
make_span(Container& cont)
{
    return {cont};
}

template <typename Container>
constexpr span<const typename Container::value_type>
make_span(const Container& cont)
{
    return {cont};
}

template <typename ElementType, std::size_t Extent>
span<const byte, ((Extent == dynamic_extent) ? dynamic_extent
                                             : sizeof(ElementType) * Extent)>
as_bytes(span<ElementType, Extent> s) noexcept
{
    return {reinterpret_cast<const byte*>(s.data()), s.size_bytes()};
}

template <
    class ElementType, size_t Extent,
    typename std::enable_if<!std::is_const<ElementType>::value, int>::type = 0>
span<byte, ((Extent == dynamic_extent) ? dynamic_extent
                                       : sizeof(ElementType) * Extent)>
as_writable_bytes(span<ElementType, Extent> s) noexcept
{
    return {reinterpret_cast<byte*>(s.data()), s.size_bytes()};
}

template <std::size_t N, typename E, std::size_t S>
constexpr auto get(span<E, S> s) -> decltype(s[N])
{
    return s[N];
}

} // namespace TCB_SPAN_NAMESPACE_NAME

namespace std {

template <typename ElementType, size_t Extent>
class tuple_size<TCB_SPAN_NAMESPACE_NAME::span<ElementType, Extent>>
    : public integral_constant<size_t, Extent> {};

template <typename ElementType>
class tuple_size<TCB_SPAN_NAMESPACE_NAME::span<
    ElementType, TCB_SPAN_NAMESPACE_NAME::dynamic_extent>>; // not defined

template <size_t I, typename ElementType, size_t Extent>
class tuple_element<I, TCB_SPAN_NAMESPACE_NAME::span<ElementType, Extent>> {
public:
    static_assert(Extent != TCB_SPAN_NAMESPACE_NAME::dynamic_extent &&
                      I < Extent,
                  "");
    using type = ElementType;
};

} // end namespace std

#endif // TCB_SPAN_HPP_INCLUDED

```

`KDemu/include/LIEF/LIEF/third-party/span.hpp`:

```hpp
/* Copyright 2021 - 2024 R. Thomas
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_THIRD_PARTY_SPAN_H
#define LIEF_THIRD_PARTY_SPAN_H
#include "LIEF/config.h"

#ifndef LIEF_EXTERNAL_SPAN
#include <LIEF/third-party/internal/span.hpp>
#else
#include <tcb/span.hpp>
#endif

#endif

```

`KDemu/include/LIEF/LIEF/to_json.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_TO_JSON_H
#define LIEF_TO_JSON_H

#include "LIEF/config.h"

#ifdef LIEF_JSON_SUPPORT


#ifdef LIEF_ELF_SUPPORT
#include "LIEF/ELF/json.hpp"
#endif

#ifdef LIEF_PE_SUPPORT
#include "LIEF/PE/json.hpp"
#endif

#include "LIEF/Abstract/json.hpp"

#include "LIEF/Abstract.hpp"
#include "LIEF/ELF.hpp"
#include "LIEF/PE.hpp"

#endif // LIEF_JSON_SUPPORT

#endif

```

`KDemu/include/LIEF/LIEF/types.h`:

```h
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_C_TYPES_H_
#define LIEF_C_TYPES_H_
#include <stdint.h>
#ifndef __cplusplus
#ifndef bool
typedef int bool;
#endif
#endif
#endif

```

`KDemu/include/LIEF/LIEF/types.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_TYPES_H
#define LIEF_TYPES_H
#include <cstdint>
#include <cinttypes>
#include <cstddef>

#if defined(_MSC_VER)
#define ALIGNED_(x) __declspec(align(x))
#elif defined(__GNUC__)
#define ALIGNED_(x) __attribute__ ((__aligned__(x), __packed__))
#endif


#endif

```

`KDemu/include/LIEF/LIEF/utils.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_UTILS_HEADER
#define LIEF_UTILS_HEADER
#include <vector>
#include <string>

#include "LIEF/span.hpp"
#include "LIEF/types.hpp"
#include "LIEF/visibility.h"

#include "LIEF/errors.hpp"


namespace LIEF {
inline uint64_t align(uint64_t value, uint64_t align_on) {
  if (align_on == 0) {
    return value;
  }
  const auto r = value % align_on;
  if (r > 0) {
    return value + (align_on - r);
  }
  return value;
}


template<typename T>
inline constexpr T round(T x) {
  return static_cast<T>(round<uint64_t>(x));
}


template<>
inline uint64_t round<uint64_t>(uint64_t x) {
  //From http://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2
  x--;
  x |= x >> 1;  // handle  2 bit numbers
  x |= x >> 2;  // handle  4 bit numbers
  x |= x >> 4;  // handle  8 bit numbers
  x |= x >> 8;  // handle 16 bit numbers
  x |= x >> 16; // handle 32 bit numbers
  x |= x >> 32; // handle 64 bit numbers
  x++;
  return x;
}


constexpr size_t operator ""_KB(unsigned long long kbs)
{
    return 1024LLU * kbs;
}

constexpr size_t operator ""_MB(unsigned long long mbs)
{
    return 1024LLU * 1024LLU * mbs;
}

constexpr size_t operator ""_GB(unsigned long long gbs)
{
    return 1024LLU * 1024LLU * 1024LLU * gbs;
}


//! Convert a UTF-16 string to a UTF-8 one
LIEF_API std::string u16tou8(const std::u16string& string, bool remove_null_char = false);

//! Convert a UTF-8 string to a UTF-16 one
LIEF_API result<std::u16string> u8tou16(const std::string& string);

LIEF_API std::string hex_str(uint8_t c);

LIEF_API std::string hex_dump(const std::vector<uint8_t>& data,
                              const std::string& sep = ":");

LIEF_API std::string hex_dump(span<const uint8_t> data,
                              const std::string& sep = ":");

//! Check if the given number is a hex-like string
LIEF_API bool is_hex_number(const std::string& nb);

//! Whether this version of LIEF includes extended features
LIEF_API bool is_extended();
}

namespace LIEF {
namespace LEB128 {
std::vector<uint8_t> uencode(uint64_t value);
}
}

#endif

```

`KDemu/include/LIEF/LIEF/version.h`:

```h
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_VERSION_H
#define LIEF_VERSION_H

#if defined(NDEBUG)
  #define LIEF_NAME "LIEF"
#else
  #define LIEF_NAME "LIEF (Debug)"
#endif

#define LIEF_VERSION "0.15.1-"
#define LIEF_TAGGED 
#define LIEF_TAG    ""
#define LIEF_COMMIT ""

#define HUMAN_VERSION " v" LIEF_VERSION
#define HUMAN_NAME NAME HUMAN_VERSION

#endif

```

`KDemu/include/LIEF/LIEF/visibility.h`:

```h
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef LIEF_SYMBOL_VISIBILITY_H
#define LIEF_SYMBOL_VISIBILITY_H

/* Thanks to https://github.com/aguinet/dragonffi/blob/40f3fecb9530a2ef840f63882c5284ea5e8dc9e8/include/dffi/exports.h */
#if defined _WIN32 || defined __CYGWIN__
  #define LIEF_HELPER_IMPORT __declspec(dllimport)
  #define LIEF_HELPER_EXPORT __declspec(dllexport)
  #define LIEF_HELPER_LOCAL
#else
  #define LIEF_HELPER_IMPORT __attribute__ ((visibility ("default")))
  #define LIEF_HELPER_EXPORT __attribute__ ((visibility ("default")))
  #define LIEF_HELPER_LOCAL  __attribute__ ((visibility ("hidden")))
#endif

#if defined(LIEF_STATIC)
  #define LIEF_API
  #define LIEF_LOCAL
#elif defined(LIEF_EXPORTS)
  #define LIEF_API   LIEF_HELPER_EXPORT
  #define LIEF_LOCAL LIEF_HELPER_LOCAL
#elif defined(LIEF_IMPORT)
  #define LIEF_API   LIEF_HELPER_IMPORT
  #define LIEF_LOCAL LIEF_HELPER_LOCAL
#else
  #define LIEF_API
  #define LIEF_LOCAL LIEF_HELPER_LOCAL
#endif

#endif

```

`KDemu/include/LIEF/LIEF/visitor_macros.hpp`:

```hpp
/* Copyright 2017 - 2024 R. Thomas
 * Copyright 2017 - 2024 Quarkslab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef LIEF_VISITOR_MACROS_H
#define LIEF_VISITOR_MACROS_H
#include "LIEF/config.h"

// PE Support
// ==========
#if defined(LIEF_PE_SUPPORT)
  #define LIEF_PE_FORWARD(OBJ) \
    namespace PE   {           \
    class OBJ;                 \
    }

  #define LIEF_PE_VISITABLE(OBJ) \
    virtual void visit(const PE::OBJ&) {}
#else
  #define LIEF_PE_VISITABLE(OBJ)
  #define LIEF_PE_FORWARD(OBJ)
#endif


// ELF Support
// ===========
#if defined(LIEF_ELF_SUPPORT)
  #define LIEF_ELF_FORWARD(OBJ) \
    namespace ELF   {           \
    class OBJ;                 \
    }
  #define LIEF_ELF_VISITABLE(OBJ)         \
    virtual void visit(const ELF::OBJ&) {}
#else
  #define LIEF_ELF_FORWARD(OBJ)
  #define LIEF_ELF_VISITABLE(OBJ)
#endif

// MachO Support
// =============
#if defined(LIEF_MACHO_SUPPORT)
  #define LIEF_MACHO_FORWARD(OBJ) \
    namespace MachO   {           \
    class OBJ;                 \
    }
  #define LIEF_MACHO_VISITABLE(OBJ) \
    virtual void visit(const MachO::OBJ&) {}
#else
  #define LIEF_MACHO_FORWARD(OBJ)
  #define LIEF_MACHO_VISITABLE(OBJ)
#endif


// OAT Support
// ===========
#if defined(LIEF_OAT_SUPPORT)
  #define LIEF_OAT_FORWARD(OBJ) \
    namespace OAT   {           \
    class OBJ;                 \
    }
  #define LIEF_OAT_VISITABLE(OBJ) \
    virtual void visit(const OAT::OBJ&) {}
#else
  #define LIEF_OAT_FORWARD(OBJ)
  #define LIEF_OAT_VISITABLE(OBJ)
#endif


// DEX Support
// ===========
#if defined(LIEF_DEX_SUPPORT)
  #define LIEF_DEX_FORWARD(OBJ) \
    namespace DEX   {           \
    class OBJ;                 \
    }
  #define LIEF_DEX_VISITABLE(OBJ) \
    virtual void visit(const DEX::OBJ&) {}
#else
  #define LIEF_DEX_FORWARD(OBJ)
  #define LIEF_DEX_VISITABLE(OBJ)
#endif


// VDEX Support
// ===========
#if defined(LIEF_VDEX_SUPPORT)
  #define LIEF_VDEX_FORWARD(OBJ) \
    namespace VDEX   {           \
    class OBJ;                 \
    }
  #define LIEF_VDEX_VISITABLE(OBJ) \
    virtual void visit(const VDEX::OBJ&) {}
#else
  #define LIEF_VDEX_FORWARD(OBJ)
  #define LIEF_VDEX_VISITABLE(OBJ)
#endif


// ART Support
// ===========
#if defined(LIEF_ART_SUPPORT)
  #define LIEF_ART_FORWARD(OBJ) \
    namespace ART   {           \
    class OBJ;                 \
    }
  #define LIEF_ART_VISITABLE(OBJ) \
    virtual void visit(const ART::OBJ&) {}
#else
  #define LIEF_ART_FORWARD(OBJ)
  #define LIEF_ART_VISITABLE(OBJ)
#endif

// Abstract
// ========
#define LIEF_ABSTRACT_FORWARD(OBJ) \
  class OBJ;

#define LIEF_ABSTRACT_VISITABLE(OBJ) \
  virtual void visit(const OBJ&) {}


#endif

```

`KDemu/include/capstone/capstone/arm.h`:

```h
#ifndef CAPSTONE_ARM_H
#define CAPSTONE_ARM_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2015 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

/// ARM shift type
typedef enum arm_shifter {
	ARM_SFT_INVALID = 0,
	ARM_SFT_ASR,	///< shift with immediate const
	ARM_SFT_LSL,	///< shift with immediate const
	ARM_SFT_LSR,	///< shift with immediate const
	ARM_SFT_ROR,	///< shift with immediate const
	ARM_SFT_RRX,	///< shift with immediate const
	ARM_SFT_ASR_REG,	///< shift with register
	ARM_SFT_LSL_REG,	///< shift with register
	ARM_SFT_LSR_REG,	///< shift with register
	ARM_SFT_ROR_REG,	///< shift with register
	ARM_SFT_RRX_REG,	///< shift with register
} arm_shifter;

/// ARM condition code
typedef enum arm_cc {
	ARM_CC_INVALID = 0,
	ARM_CC_EQ,            ///< Equal                      Equal
	ARM_CC_NE,            ///< Not equal                  Not equal, or unordered
	ARM_CC_HS,            ///< Carry set                  >, ==, or unordered
	ARM_CC_LO,            ///< Carry clear                Less than
	ARM_CC_MI,            ///< Minus, negative            Less than
	ARM_CC_PL,            ///< Plus, positive or zero     >, ==, or unordered
	ARM_CC_VS,            ///< Overflow                   Unordered
	ARM_CC_VC,            ///< No overflow                Not unordered
	ARM_CC_HI,            ///< Unsigned higher            Greater than, or unordered
	ARM_CC_LS,            ///< Unsigned lower or same     Less than or equal
	ARM_CC_GE,            ///< Greater than or equal      Greater than or equal
	ARM_CC_LT,            ///< Less than                  Less than, or unordered
	ARM_CC_GT,            ///< Greater than               Greater than
	ARM_CC_LE,            ///< Less than or equal         <, ==, or unordered
	ARM_CC_AL             ///< Always (unconditional)     Always (unconditional)
} arm_cc;

typedef enum arm_sysreg {
	/// Special registers for MSR
	ARM_SYSREG_INVALID = 0,

	// SPSR* registers can be OR combined
	ARM_SYSREG_SPSR_C = 1,
	ARM_SYSREG_SPSR_X = 2,
	ARM_SYSREG_SPSR_S = 4,
	ARM_SYSREG_SPSR_F = 8,

	// CPSR* registers can be OR combined
	ARM_SYSREG_CPSR_C = 16,
	ARM_SYSREG_CPSR_X = 32,
	ARM_SYSREG_CPSR_S = 64,
	ARM_SYSREG_CPSR_F = 128,

	// independent registers
	ARM_SYSREG_APSR = 256,
	ARM_SYSREG_APSR_G,
	ARM_SYSREG_APSR_NZCVQ,
	ARM_SYSREG_APSR_NZCVQG,

	ARM_SYSREG_IAPSR,
	ARM_SYSREG_IAPSR_G,
	ARM_SYSREG_IAPSR_NZCVQG,
	ARM_SYSREG_IAPSR_NZCVQ,

	ARM_SYSREG_EAPSR,
	ARM_SYSREG_EAPSR_G,
	ARM_SYSREG_EAPSR_NZCVQG,
	ARM_SYSREG_EAPSR_NZCVQ,

	ARM_SYSREG_XPSR,
	ARM_SYSREG_XPSR_G,
	ARM_SYSREG_XPSR_NZCVQG,
	ARM_SYSREG_XPSR_NZCVQ,

	ARM_SYSREG_IPSR,
	ARM_SYSREG_EPSR,
	ARM_SYSREG_IEPSR,

	ARM_SYSREG_MSP,
	ARM_SYSREG_PSP,
	ARM_SYSREG_PRIMASK,
	ARM_SYSREG_BASEPRI,
	ARM_SYSREG_BASEPRI_MAX,
	ARM_SYSREG_FAULTMASK,
	ARM_SYSREG_CONTROL,

	// Banked Registers
	ARM_SYSREG_R8_USR,
	ARM_SYSREG_R9_USR,
	ARM_SYSREG_R10_USR,
	ARM_SYSREG_R11_USR,
	ARM_SYSREG_R12_USR,
	ARM_SYSREG_SP_USR,
	ARM_SYSREG_LR_USR,
	ARM_SYSREG_R8_FIQ,
	ARM_SYSREG_R9_FIQ,
	ARM_SYSREG_R10_FIQ,
	ARM_SYSREG_R11_FIQ,
	ARM_SYSREG_R12_FIQ,
	ARM_SYSREG_SP_FIQ,
	ARM_SYSREG_LR_FIQ,
	ARM_SYSREG_LR_IRQ,
	ARM_SYSREG_SP_IRQ,
	ARM_SYSREG_LR_SVC,
	ARM_SYSREG_SP_SVC,
	ARM_SYSREG_LR_ABT,
	ARM_SYSREG_SP_ABT,
	ARM_SYSREG_LR_UND,
	ARM_SYSREG_SP_UND,
	ARM_SYSREG_LR_MON,
	ARM_SYSREG_SP_MON,
	ARM_SYSREG_ELR_HYP,
	ARM_SYSREG_SP_HYP,

	ARM_SYSREG_SPSR_FIQ,
	ARM_SYSREG_SPSR_IRQ,
	ARM_SYSREG_SPSR_SVC,
	ARM_SYSREG_SPSR_ABT,
	ARM_SYSREG_SPSR_UND,
	ARM_SYSREG_SPSR_MON,
	ARM_SYSREG_SPSR_HYP,
} arm_sysreg;

/// The memory barrier constants map directly to the 4-bit encoding of
/// the option field for Memory Barrier operations.
typedef enum arm_mem_barrier {
	ARM_MB_INVALID = 0,
	ARM_MB_RESERVED_0,
	ARM_MB_OSHLD,
	ARM_MB_OSHST,
	ARM_MB_OSH,
	ARM_MB_RESERVED_4,
	ARM_MB_NSHLD,
	ARM_MB_NSHST,
	ARM_MB_NSH,
	ARM_MB_RESERVED_8,
	ARM_MB_ISHLD,
	ARM_MB_ISHST,
	ARM_MB_ISH,
	ARM_MB_RESERVED_12,
	ARM_MB_LD,
	ARM_MB_ST,
	ARM_MB_SY,
} arm_mem_barrier;

/// Operand type for instruction's operands
typedef enum arm_op_type {
	ARM_OP_INVALID = 0, ///< = CS_OP_INVALID (Uninitialized).
	ARM_OP_REG, ///< = CS_OP_REG (Register operand).
	ARM_OP_IMM, ///< = CS_OP_IMM (Immediate operand).
	ARM_OP_MEM, ///< = CS_OP_MEM (Memory operand).
	ARM_OP_FP,  ///< = CS_OP_FP (Floating-Point operand).
	ARM_OP_CIMM = 64, ///< C-Immediate (coprocessor registers)
	ARM_OP_PIMM, ///< P-Immediate (coprocessor registers)
	ARM_OP_SETEND,	///< operand for SETEND instruction
	ARM_OP_SYSREG,	///< MSR/MRS special register operand
} arm_op_type;

/// Operand type for SETEND instruction
typedef enum arm_setend_type {
	ARM_SETEND_INVALID = 0,	///< Uninitialized.
	ARM_SETEND_BE,	///< BE operand.
	ARM_SETEND_LE, ///< LE operand
} arm_setend_type;

typedef enum arm_cpsmode_type {
	ARM_CPSMODE_INVALID = 0,
	ARM_CPSMODE_IE = 2,
	ARM_CPSMODE_ID = 3
} arm_cpsmode_type;

/// Operand type for SETEND instruction
typedef enum arm_cpsflag_type {
	ARM_CPSFLAG_INVALID = 0,
	ARM_CPSFLAG_F = 1,
	ARM_CPSFLAG_I = 2,
	ARM_CPSFLAG_A = 4,
	ARM_CPSFLAG_NONE = 16,	///< no flag
} arm_cpsflag_type;

/// Data type for elements of vector instructions.
typedef enum arm_vectordata_type {
	ARM_VECTORDATA_INVALID = 0,

	// Integer type
	ARM_VECTORDATA_I8,
	ARM_VECTORDATA_I16,
	ARM_VECTORDATA_I32,
	ARM_VECTORDATA_I64,

	// Signed integer type
	ARM_VECTORDATA_S8,
	ARM_VECTORDATA_S16,
	ARM_VECTORDATA_S32,
	ARM_VECTORDATA_S64,

	// Unsigned integer type
	ARM_VECTORDATA_U8,
	ARM_VECTORDATA_U16,
	ARM_VECTORDATA_U32,
	ARM_VECTORDATA_U64,

	// Data type for VMUL/VMULL
	ARM_VECTORDATA_P8,

	// Floating type
	ARM_VECTORDATA_F32,
	ARM_VECTORDATA_F64,

	// Convert float <-> float
	ARM_VECTORDATA_F16F64,	// f16.f64
	ARM_VECTORDATA_F64F16,	// f64.f16
	ARM_VECTORDATA_F32F16,	// f32.f16
	ARM_VECTORDATA_F16F32,	// f32.f16
	ARM_VECTORDATA_F64F32,	// f64.f32
	ARM_VECTORDATA_F32F64,	// f32.f64

	// Convert integer <-> float
	ARM_VECTORDATA_S32F32,	// s32.f32
	ARM_VECTORDATA_U32F32,	// u32.f32
	ARM_VECTORDATA_F32S32,	// f32.s32
	ARM_VECTORDATA_F32U32,	// f32.u32
	ARM_VECTORDATA_F64S16,	// f64.s16
	ARM_VECTORDATA_F32S16,	// f32.s16
	ARM_VECTORDATA_F64S32,	// f64.s32
	ARM_VECTORDATA_S16F64,	// s16.f64
	ARM_VECTORDATA_S16F32,	// s16.f64
	ARM_VECTORDATA_S32F64,	// s32.f64
	ARM_VECTORDATA_U16F64,	// u16.f64
	ARM_VECTORDATA_U16F32,	// u16.f32
	ARM_VECTORDATA_U32F64,	// u32.f64
	ARM_VECTORDATA_F64U16,	// f64.u16
	ARM_VECTORDATA_F32U16,	// f32.u16
	ARM_VECTORDATA_F64U32,	// f64.u32
} arm_vectordata_type;

/// ARM registers
typedef enum arm_reg {
	ARM_REG_INVALID = 0,
	ARM_REG_APSR,
	ARM_REG_APSR_NZCV,
	ARM_REG_CPSR,
	ARM_REG_FPEXC,
	ARM_REG_FPINST,
	ARM_REG_FPSCR,
	ARM_REG_FPSCR_NZCV,
	ARM_REG_FPSID,
	ARM_REG_ITSTATE,
	ARM_REG_LR,
	ARM_REG_PC,
	ARM_REG_SP,
	ARM_REG_SPSR,
	ARM_REG_D0,
	ARM_REG_D1,
	ARM_REG_D2,
	ARM_REG_D3,
	ARM_REG_D4,
	ARM_REG_D5,
	ARM_REG_D6,
	ARM_REG_D7,
	ARM_REG_D8,
	ARM_REG_D9,
	ARM_REG_D10,
	ARM_REG_D11,
	ARM_REG_D12,
	ARM_REG_D13,
	ARM_REG_D14,
	ARM_REG_D15,
	ARM_REG_D16,
	ARM_REG_D17,
	ARM_REG_D18,
	ARM_REG_D19,
	ARM_REG_D20,
	ARM_REG_D21,
	ARM_REG_D22,
	ARM_REG_D23,
	ARM_REG_D24,
	ARM_REG_D25,
	ARM_REG_D26,
	ARM_REG_D27,
	ARM_REG_D28,
	ARM_REG_D29,
	ARM_REG_D30,
	ARM_REG_D31,
	ARM_REG_FPINST2,
	ARM_REG_MVFR0,
	ARM_REG_MVFR1,
	ARM_REG_MVFR2,
	ARM_REG_Q0,
	ARM_REG_Q1,
	ARM_REG_Q2,
	ARM_REG_Q3,
	ARM_REG_Q4,
	ARM_REG_Q5,
	ARM_REG_Q6,
	ARM_REG_Q7,
	ARM_REG_Q8,
	ARM_REG_Q9,
	ARM_REG_Q10,
	ARM_REG_Q11,
	ARM_REG_Q12,
	ARM_REG_Q13,
	ARM_REG_Q14,
	ARM_REG_Q15,
	ARM_REG_R0,
	ARM_REG_R1,
	ARM_REG_R2,
	ARM_REG_R3,
	ARM_REG_R4,
	ARM_REG_R5,
	ARM_REG_R6,
	ARM_REG_R7,
	ARM_REG_R8,
	ARM_REG_R9,
	ARM_REG_R10,
	ARM_REG_R11,
	ARM_REG_R12,
	ARM_REG_S0,
	ARM_REG_S1,
	ARM_REG_S2,
	ARM_REG_S3,
	ARM_REG_S4,
	ARM_REG_S5,
	ARM_REG_S6,
	ARM_REG_S7,
	ARM_REG_S8,
	ARM_REG_S9,
	ARM_REG_S10,
	ARM_REG_S11,
	ARM_REG_S12,
	ARM_REG_S13,
	ARM_REG_S14,
	ARM_REG_S15,
	ARM_REG_S16,
	ARM_REG_S17,
	ARM_REG_S18,
	ARM_REG_S19,
	ARM_REG_S20,
	ARM_REG_S21,
	ARM_REG_S22,
	ARM_REG_S23,
	ARM_REG_S24,
	ARM_REG_S25,
	ARM_REG_S26,
	ARM_REG_S27,
	ARM_REG_S28,
	ARM_REG_S29,
	ARM_REG_S30,
	ARM_REG_S31,

	ARM_REG_ENDING,		// <-- mark the end of the list or registers

	// alias registers
	ARM_REG_R13 = ARM_REG_SP,
	ARM_REG_R14 = ARM_REG_LR,
	ARM_REG_R15 = ARM_REG_PC,

	ARM_REG_SB = ARM_REG_R9,
	ARM_REG_SL = ARM_REG_R10,
	ARM_REG_FP = ARM_REG_R11,
	ARM_REG_IP = ARM_REG_R12,
} arm_reg;

/// Instruction's operand referring to memory
/// This is associated with ARM_OP_MEM operand type above
typedef struct arm_op_mem {
	arm_reg base;	///< base register
	arm_reg index;	///< index register
	int scale;	///< scale for index register (can be 1, or -1)
	int disp;	///< displacement/offset value
	/// left-shift on index register, or 0 if irrelevant
	/// NOTE: this value can also be fetched via operand.shift.value
	int lshift;
} arm_op_mem;

/// Instruction operand
typedef struct cs_arm_op {
	int vector_index;	///< Vector Index for some vector operands (or -1 if irrelevant)

	struct {
		arm_shifter type;
		unsigned int value;
	} shift;

	arm_op_type type;	///< operand type

	union {
		int reg;	///< register value for REG/SYSREG operand
		int32_t imm;			///< immediate value for C-IMM, P-IMM or IMM operand
		double fp;			///< floating point value for FP operand
		arm_op_mem mem;		///< base/index/scale/disp value for MEM operand
		arm_setend_type setend; ///< SETEND instruction's operand type
	};

	/// in some instructions, an operand can be subtracted or added to
	/// the base register,
	/// if TRUE, this operand is subtracted. otherwise, it is added.
	bool subtracted;

	/// How is this operand accessed? (READ, WRITE or READ|WRITE)
	/// This field is combined of cs_ac_type.
	/// NOTE: this field is irrelevant if engine is compiled in DIET mode.
	uint8_t access;

	/// Neon lane index for NEON instructions (or -1 if irrelevant)
	int8_t neon_lane;
} cs_arm_op;

/// Instruction structure
typedef struct cs_arm {
	bool usermode;	///< User-mode registers to be loaded (for LDM/STM instructions)
	int vector_size; 	///< Scalar size for vector instructions
	arm_vectordata_type vector_data; ///< Data type for elements of vector instructions
	arm_cpsmode_type cps_mode;	///< CPS mode for CPS instruction
	arm_cpsflag_type cps_flag;	///< CPS mode for CPS instruction
	arm_cc cc;			///< conditional code for this insn
	bool update_flags;	///< does this insn update flags?
	bool writeback;		///< does this insn write-back?
	arm_mem_barrier mem_barrier;	///< Option for some memory barrier instructions

	/// Number of operands of this instruction,
	/// or 0 when instruction has no operand.
	uint8_t op_count;

	cs_arm_op operands[36];	///< operands for this instruction.
} cs_arm;

/// ARM instruction
typedef enum arm_insn {
	ARM_INS_INVALID = 0,

	ARM_INS_ADC,
	ARM_INS_ADD,
	ARM_INS_ADR,
	ARM_INS_AESD,
	ARM_INS_AESE,
	ARM_INS_AESIMC,
	ARM_INS_AESMC,
	ARM_INS_AND,
	ARM_INS_BFC,
	ARM_INS_BFI,
	ARM_INS_BIC,
	ARM_INS_BKPT,
	ARM_INS_BL,
	ARM_INS_BLX,
	ARM_INS_BX,
	ARM_INS_BXJ,
	ARM_INS_B,
	ARM_INS_CDP,
	ARM_INS_CDP2,
	ARM_INS_CLREX,
	ARM_INS_CLZ,
	ARM_INS_CMN,
	ARM_INS_CMP,
	ARM_INS_CPS,
	ARM_INS_CRC32B,
	ARM_INS_CRC32CB,
	ARM_INS_CRC32CH,
	ARM_INS_CRC32CW,
	ARM_INS_CRC32H,
	ARM_INS_CRC32W,
	ARM_INS_DBG,
	ARM_INS_DMB,
	ARM_INS_DSB,
	ARM_INS_EOR,
	ARM_INS_ERET,
	ARM_INS_VMOV,
	ARM_INS_FLDMDBX,
	ARM_INS_FLDMIAX,
	ARM_INS_VMRS,
	ARM_INS_FSTMDBX,
	ARM_INS_FSTMIAX,
	ARM_INS_HINT,
	ARM_INS_HLT,
	ARM_INS_HVC,
	ARM_INS_ISB,
	ARM_INS_LDA,
	ARM_INS_LDAB,
	ARM_INS_LDAEX,
	ARM_INS_LDAEXB,
	ARM_INS_LDAEXD,
	ARM_INS_LDAEXH,
	ARM_INS_LDAH,
	ARM_INS_LDC2L,
	ARM_INS_LDC2,
	ARM_INS_LDCL,
	ARM_INS_LDC,
	ARM_INS_LDMDA,
	ARM_INS_LDMDB,
	ARM_INS_LDM,
	ARM_INS_LDMIB,
	ARM_INS_LDRBT,
	ARM_INS_LDRB,
	ARM_INS_LDRD,
	ARM_INS_LDREX,
	ARM_INS_LDREXB,
	ARM_INS_LDREXD,
	ARM_INS_LDREXH,
	ARM_INS_LDRH,
	ARM_INS_LDRHT,
	ARM_INS_LDRSB,
	ARM_INS_LDRSBT,
	ARM_INS_LDRSH,
	ARM_INS_LDRSHT,
	ARM_INS_LDRT,
	ARM_INS_LDR,
	ARM_INS_MCR,
	ARM_INS_MCR2,
	ARM_INS_MCRR,
	ARM_INS_MCRR2,
	ARM_INS_MLA,
	ARM_INS_MLS,
	ARM_INS_MOV,
	ARM_INS_MOVT,
	ARM_INS_MOVW,
	ARM_INS_MRC,
	ARM_INS_MRC2,
	ARM_INS_MRRC,
	ARM_INS_MRRC2,
	ARM_INS_MRS,
	ARM_INS_MSR,
	ARM_INS_MUL,
	ARM_INS_MVN,
	ARM_INS_ORR,
	ARM_INS_PKHBT,
	ARM_INS_PKHTB,
	ARM_INS_PLDW,
	ARM_INS_PLD,
	ARM_INS_PLI,
	ARM_INS_QADD,
	ARM_INS_QADD16,
	ARM_INS_QADD8,
	ARM_INS_QASX,
	ARM_INS_QDADD,
	ARM_INS_QDSUB,
	ARM_INS_QSAX,
	ARM_INS_QSUB,
	ARM_INS_QSUB16,
	ARM_INS_QSUB8,
	ARM_INS_RBIT,
	ARM_INS_REV,
	ARM_INS_REV16,
	ARM_INS_REVSH,
	ARM_INS_RFEDA,
	ARM_INS_RFEDB,
	ARM_INS_RFEIA,
	ARM_INS_RFEIB,
	ARM_INS_RSB,
	ARM_INS_RSC,
	ARM_INS_SADD16,
	ARM_INS_SADD8,
	ARM_INS_SASX,
	ARM_INS_SBC,
	ARM_INS_SBFX,
	ARM_INS_SDIV,
	ARM_INS_SEL,
	ARM_INS_SETEND,
	ARM_INS_SHA1C,
	ARM_INS_SHA1H,
	ARM_INS_SHA1M,
	ARM_INS_SHA1P,
	ARM_INS_SHA1SU0,
	ARM_INS_SHA1SU1,
	ARM_INS_SHA256H,
	ARM_INS_SHA256H2,
	ARM_INS_SHA256SU0,
	ARM_INS_SHA256SU1,
	ARM_INS_SHADD16,
	ARM_INS_SHADD8,
	ARM_INS_SHASX,
	ARM_INS_SHSAX,
	ARM_INS_SHSUB16,
	ARM_INS_SHSUB8,
	ARM_INS_SMC,
	ARM_INS_SMLABB,
	ARM_INS_SMLABT,
	ARM_INS_SMLAD,
	ARM_INS_SMLADX,
	ARM_INS_SMLAL,
	ARM_INS_SMLALBB,
	ARM_INS_SMLALBT,
	ARM_INS_SMLALD,
	ARM_INS_SMLALDX,
	ARM_INS_SMLALTB,
	ARM_INS_SMLALTT,
	ARM_INS_SMLATB,
	ARM_INS_SMLATT,
	ARM_INS_SMLAWB,
	ARM_INS_SMLAWT,
	ARM_INS_SMLSD,
	ARM_INS_SMLSDX,
	ARM_INS_SMLSLD,
	ARM_INS_SMLSLDX,
	ARM_INS_SMMLA,
	ARM_INS_SMMLAR,
	ARM_INS_SMMLS,
	ARM_INS_SMMLSR,
	ARM_INS_SMMUL,
	ARM_INS_SMMULR,
	ARM_INS_SMUAD,
	ARM_INS_SMUADX,
	ARM_INS_SMULBB,
	ARM_INS_SMULBT,
	ARM_INS_SMULL,
	ARM_INS_SMULTB,
	ARM_INS_SMULTT,
	ARM_INS_SMULWB,
	ARM_INS_SMULWT,
	ARM_INS_SMUSD,
	ARM_INS_SMUSDX,
	ARM_INS_SRSDA,
	ARM_INS_SRSDB,
	ARM_INS_SRSIA,
	ARM_INS_SRSIB,
	ARM_INS_SSAT,
	ARM_INS_SSAT16,
	ARM_INS_SSAX,
	ARM_INS_SSUB16,
	ARM_INS_SSUB8,
	ARM_INS_STC2L,
	ARM_INS_STC2,
	ARM_INS_STCL,
	ARM_INS_STC,
	ARM_INS_STL,
	ARM_INS_STLB,
	ARM_INS_STLEX,
	ARM_INS_STLEXB,
	ARM_INS_STLEXD,
	ARM_INS_STLEXH,
	ARM_INS_STLH,
	ARM_INS_STMDA,
	ARM_INS_STMDB,
	ARM_INS_STM,
	ARM_INS_STMIB,
	ARM_INS_STRBT,
	ARM_INS_STRB,
	ARM_INS_STRD,
	ARM_INS_STREX,
	ARM_INS_STREXB,
	ARM_INS_STREXD,
	ARM_INS_STREXH,
	ARM_INS_STRH,
	ARM_INS_STRHT,
	ARM_INS_STRT,
	ARM_INS_STR,
	ARM_INS_SUB,
	ARM_INS_SVC,
	ARM_INS_SWP,
	ARM_INS_SWPB,
	ARM_INS_SXTAB,
	ARM_INS_SXTAB16,
	ARM_INS_SXTAH,
	ARM_INS_SXTB,
	ARM_INS_SXTB16,
	ARM_INS_SXTH,
	ARM_INS_TEQ,
	ARM_INS_TRAP,
	ARM_INS_TST,
	ARM_INS_UADD16,
	ARM_INS_UADD8,
	ARM_INS_UASX,
	ARM_INS_UBFX,
	ARM_INS_UDF,
	ARM_INS_UDIV,
	ARM_INS_UHADD16,
	ARM_INS_UHADD8,
	ARM_INS_UHASX,
	ARM_INS_UHSAX,
	ARM_INS_UHSUB16,
	ARM_INS_UHSUB8,
	ARM_INS_UMAAL,
	ARM_INS_UMLAL,
	ARM_INS_UMULL,
	ARM_INS_UQADD16,
	ARM_INS_UQADD8,
	ARM_INS_UQASX,
	ARM_INS_UQSAX,
	ARM_INS_UQSUB16,
	ARM_INS_UQSUB8,
	ARM_INS_USAD8,
	ARM_INS_USADA8,
	ARM_INS_USAT,
	ARM_INS_USAT16,
	ARM_INS_USAX,
	ARM_INS_USUB16,
	ARM_INS_USUB8,
	ARM_INS_UXTAB,
	ARM_INS_UXTAB16,
	ARM_INS_UXTAH,
	ARM_INS_UXTB,
	ARM_INS_UXTB16,
	ARM_INS_UXTH,
	ARM_INS_VABAL,
	ARM_INS_VABA,
	ARM_INS_VABDL,
	ARM_INS_VABD,
	ARM_INS_VABS,
	ARM_INS_VACGE,
	ARM_INS_VACGT,
	ARM_INS_VADD,
	ARM_INS_VADDHN,
	ARM_INS_VADDL,
	ARM_INS_VADDW,
	ARM_INS_VAND,
	ARM_INS_VBIC,
	ARM_INS_VBIF,
	ARM_INS_VBIT,
	ARM_INS_VBSL,
	ARM_INS_VCEQ,
	ARM_INS_VCGE,
	ARM_INS_VCGT,
	ARM_INS_VCLE,
	ARM_INS_VCLS,
	ARM_INS_VCLT,
	ARM_INS_VCLZ,
	ARM_INS_VCMP,
	ARM_INS_VCMPE,
	ARM_INS_VCNT,
	ARM_INS_VCVTA,
	ARM_INS_VCVTB,
	ARM_INS_VCVT,
	ARM_INS_VCVTM,
	ARM_INS_VCVTN,
	ARM_INS_VCVTP,
	ARM_INS_VCVTT,
	ARM_INS_VDIV,
	ARM_INS_VDUP,
	ARM_INS_VEOR,
	ARM_INS_VEXT,
	ARM_INS_VFMA,
	ARM_INS_VFMS,
	ARM_INS_VFNMA,
	ARM_INS_VFNMS,
	ARM_INS_VHADD,
	ARM_INS_VHSUB,
	ARM_INS_VLD1,
	ARM_INS_VLD2,
	ARM_INS_VLD3,
	ARM_INS_VLD4,
	ARM_INS_VLDMDB,
	ARM_INS_VLDMIA,
	ARM_INS_VLDR,
	ARM_INS_VMAXNM,
	ARM_INS_VMAX,
	ARM_INS_VMINNM,
	ARM_INS_VMIN,
	ARM_INS_VMLA,
	ARM_INS_VMLAL,
	ARM_INS_VMLS,
	ARM_INS_VMLSL,
	ARM_INS_VMOVL,
	ARM_INS_VMOVN,
	ARM_INS_VMSR,
	ARM_INS_VMUL,
	ARM_INS_VMULL,
	ARM_INS_VMVN,
	ARM_INS_VNEG,
	ARM_INS_VNMLA,
	ARM_INS_VNMLS,
	ARM_INS_VNMUL,
	ARM_INS_VORN,
	ARM_INS_VORR,
	ARM_INS_VPADAL,
	ARM_INS_VPADDL,
	ARM_INS_VPADD,
	ARM_INS_VPMAX,
	ARM_INS_VPMIN,
	ARM_INS_VQABS,
	ARM_INS_VQADD,
	ARM_INS_VQDMLAL,
	ARM_INS_VQDMLSL,
	ARM_INS_VQDMULH,
	ARM_INS_VQDMULL,
	ARM_INS_VQMOVUN,
	ARM_INS_VQMOVN,
	ARM_INS_VQNEG,
	ARM_INS_VQRDMULH,
	ARM_INS_VQRSHL,
	ARM_INS_VQRSHRN,
	ARM_INS_VQRSHRUN,
	ARM_INS_VQSHL,
	ARM_INS_VQSHLU,
	ARM_INS_VQSHRN,
	ARM_INS_VQSHRUN,
	ARM_INS_VQSUB,
	ARM_INS_VRADDHN,
	ARM_INS_VRECPE,
	ARM_INS_VRECPS,
	ARM_INS_VREV16,
	ARM_INS_VREV32,
	ARM_INS_VREV64,
	ARM_INS_VRHADD,
	ARM_INS_VRINTA,
	ARM_INS_VRINTM,
	ARM_INS_VRINTN,
	ARM_INS_VRINTP,
	ARM_INS_VRINTR,
	ARM_INS_VRINTX,
	ARM_INS_VRINTZ,
	ARM_INS_VRSHL,
	ARM_INS_VRSHRN,
	ARM_INS_VRSHR,
	ARM_INS_VRSQRTE,
	ARM_INS_VRSQRTS,
	ARM_INS_VRSRA,
	ARM_INS_VRSUBHN,
	ARM_INS_VSELEQ,
	ARM_INS_VSELGE,
	ARM_INS_VSELGT,
	ARM_INS_VSELVS,
	ARM_INS_VSHLL,
	ARM_INS_VSHL,
	ARM_INS_VSHRN,
	ARM_INS_VSHR,
	ARM_INS_VSLI,
	ARM_INS_VSQRT,
	ARM_INS_VSRA,
	ARM_INS_VSRI,
	ARM_INS_VST1,
	ARM_INS_VST2,
	ARM_INS_VST3,
	ARM_INS_VST4,
	ARM_INS_VSTMDB,
	ARM_INS_VSTMIA,
	ARM_INS_VSTR,
	ARM_INS_VSUB,
	ARM_INS_VSUBHN,
	ARM_INS_VSUBL,
	ARM_INS_VSUBW,
	ARM_INS_VSWP,
	ARM_INS_VTBL,
	ARM_INS_VTBX,
	ARM_INS_VCVTR,
	ARM_INS_VTRN,
	ARM_INS_VTST,
	ARM_INS_VUZP,
	ARM_INS_VZIP,
	ARM_INS_ADDW,
	ARM_INS_ASR,
	ARM_INS_DCPS1,
	ARM_INS_DCPS2,
	ARM_INS_DCPS3,
	ARM_INS_IT,
	ARM_INS_LSL,
	ARM_INS_LSR,
	ARM_INS_ORN,
	ARM_INS_ROR,
	ARM_INS_RRX,
	ARM_INS_SUBW,
	ARM_INS_TBB,
	ARM_INS_TBH,
	ARM_INS_CBNZ,
	ARM_INS_CBZ,
	ARM_INS_POP,
	ARM_INS_PUSH,

	// special instructions
	ARM_INS_NOP,
	ARM_INS_YIELD,
	ARM_INS_WFE,
	ARM_INS_WFI,
	ARM_INS_SEV,
	ARM_INS_SEVL,
	ARM_INS_VPUSH,
	ARM_INS_VPOP,

	ARM_INS_ENDING,	// <-- mark the end of the list of instructions
} arm_insn;

/// Group of ARM instructions
typedef enum arm_insn_group {
	ARM_GRP_INVALID = 0, ///< = CS_GRP_INVALID

	// Generic groups
	// all jump instructions (conditional+direct+indirect jumps)
	ARM_GRP_JUMP,	///< = CS_GRP_JUMP
	ARM_GRP_CALL,	///< = CS_GRP_CALL
	ARM_GRP_INT = 4, ///< = CS_GRP_INT
	ARM_GRP_PRIVILEGE = 6, ///< = CS_GRP_PRIVILEGE
	ARM_GRP_BRANCH_RELATIVE, ///< = CS_GRP_BRANCH_RELATIVE

	// Architecture-specific groups
	ARM_GRP_CRYPTO = 128,
	ARM_GRP_DATABARRIER,
	ARM_GRP_DIVIDE,
	ARM_GRP_FPARMV8,
	ARM_GRP_MULTPRO,
	ARM_GRP_NEON,
	ARM_GRP_T2EXTRACTPACK,
	ARM_GRP_THUMB2DSP,
	ARM_GRP_TRUSTZONE,
	ARM_GRP_V4T,
	ARM_GRP_V5T,
	ARM_GRP_V5TE,
	ARM_GRP_V6,
	ARM_GRP_V6T2,
	ARM_GRP_V7,
	ARM_GRP_V8,
	ARM_GRP_VFP2,
	ARM_GRP_VFP3,
	ARM_GRP_VFP4,
	ARM_GRP_ARM,
	ARM_GRP_MCLASS,
	ARM_GRP_NOTMCLASS,
	ARM_GRP_THUMB,
	ARM_GRP_THUMB1ONLY,
	ARM_GRP_THUMB2,
	ARM_GRP_PREV8,
	ARM_GRP_FPVMLX,
	ARM_GRP_MULOPS,
	ARM_GRP_CRC,
	ARM_GRP_DPVFP,
	ARM_GRP_V6M,
	ARM_GRP_VIRTUALIZATION,

	ARM_GRP_ENDING,
} arm_insn_group;

#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/include/capstone/capstone/arm64.h`:

```h
#ifndef CAPSTONE_ARM64_H
#define CAPSTONE_ARM64_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2015 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

/// ARM64 shift type
typedef enum arm64_shifter {
	ARM64_SFT_INVALID = 0,
	ARM64_SFT_LSL = 1,
	ARM64_SFT_MSL = 2,
	ARM64_SFT_LSR = 3,
	ARM64_SFT_ASR = 4,
	ARM64_SFT_ROR = 5,
} arm64_shifter;

/// ARM64 extender type
typedef enum arm64_extender {
	ARM64_EXT_INVALID = 0,
	ARM64_EXT_UXTB = 1,
	ARM64_EXT_UXTH = 2,
	ARM64_EXT_UXTW = 3,
	ARM64_EXT_UXTX = 4,
	ARM64_EXT_SXTB = 5,
	ARM64_EXT_SXTH = 6,
	ARM64_EXT_SXTW = 7,
	ARM64_EXT_SXTX = 8,
} arm64_extender;

/// ARM64 condition code
typedef enum arm64_cc {
	ARM64_CC_INVALID = 0,
	ARM64_CC_EQ = 1,     ///< Equal
	ARM64_CC_NE = 2,     ///< Not equal:                 Not equal, or unordered
	ARM64_CC_HS = 3,     ///< Unsigned higher or same:   >, ==, or unordered
	ARM64_CC_LO = 4,     ///< Unsigned lower or same:    Less than
	ARM64_CC_MI = 5,     ///< Minus, negative:           Less than
	ARM64_CC_PL = 6,     ///< Plus, positive or zero:    >, ==, or unordered
	ARM64_CC_VS = 7,     ///< Overflow:                  Unordered
	ARM64_CC_VC = 8,     ///< No overflow:               Ordered
	ARM64_CC_HI = 9,     ///< Unsigned higher:           Greater than, or unordered
	ARM64_CC_LS = 10,     ///< Unsigned lower or same:    Less than or equal
	ARM64_CC_GE = 11,     ///< Greater than or equal:     Greater than or equal
	ARM64_CC_LT = 12,     ///< Less than:                 Less than, or unordered
	ARM64_CC_GT = 13,     ///< Signed greater than:       Greater than
	ARM64_CC_LE = 14,     ///< Signed less than or equal: <, ==, or unordered
	ARM64_CC_AL = 15,     ///< Always (unconditional):    Always (unconditional)
	ARM64_CC_NV = 16,     ///< Always (unconditional):   Always (unconditional)
	//< Note the NV exists purely to disassemble 0b1111. Execution
	//< is "always".
} arm64_cc;

/// System registers
typedef enum arm64_sysreg {
	// System registers for MRS
	ARM64_SYSREG_INVALID           = 0,
	ARM64_SYSREG_MDCCSR_EL0        = 0x9808, // 10  011  0000  0001  000
	ARM64_SYSREG_DBGDTRRX_EL0      = 0x9828, // 10  011  0000  0101  000
	ARM64_SYSREG_MDRAR_EL1         = 0x8080, // 10  000  0001  0000  000
	ARM64_SYSREG_OSLSR_EL1         = 0x808c, // 10  000  0001  0001  100
	ARM64_SYSREG_DBGAUTHSTATUS_EL1 = 0x83f6, // 10  000  0111  1110  110
	ARM64_SYSREG_PMCEID0_EL0       = 0xdce6, // 11  011  1001  1100  110
	ARM64_SYSREG_PMCEID1_EL0       = 0xdce7, // 11  011  1001  1100  111
	ARM64_SYSREG_MIDR_EL1          = 0xc000, // 11  000  0000  0000  000
	ARM64_SYSREG_CCSIDR_EL1        = 0xc800, // 11  001  0000  0000  000
	ARM64_SYSREG_CLIDR_EL1         = 0xc801, // 11  001  0000  0000  001
	ARM64_SYSREG_CTR_EL0           = 0xd801, // 11  011  0000  0000  001
	ARM64_SYSREG_MPIDR_EL1         = 0xc005, // 11  000  0000  0000  101
	ARM64_SYSREG_REVIDR_EL1        = 0xc006, // 11  000  0000  0000  110
	ARM64_SYSREG_AIDR_EL1          = 0xc807, // 11  001  0000  0000  111
	ARM64_SYSREG_DCZID_EL0         = 0xd807, // 11  011  0000  0000  111
	ARM64_SYSREG_ID_PFR0_EL1       = 0xc008, // 11  000  0000  0001  000
	ARM64_SYSREG_ID_PFR1_EL1       = 0xc009, // 11  000  0000  0001  001
	ARM64_SYSREG_ID_DFR0_EL1       = 0xc00a, // 11  000  0000  0001  010
	ARM64_SYSREG_ID_AFR0_EL1       = 0xc00b, // 11  000  0000  0001  011
	ARM64_SYSREG_ID_MMFR0_EL1      = 0xc00c, // 11  000  0000  0001  100
	ARM64_SYSREG_ID_MMFR1_EL1      = 0xc00d, // 11  000  0000  0001  101
	ARM64_SYSREG_ID_MMFR2_EL1      = 0xc00e, // 11  000  0000  0001  110
	ARM64_SYSREG_ID_MMFR3_EL1      = 0xc00f, // 11  000  0000  0001  111
	ARM64_SYSREG_ID_ISAR0_EL1      = 0xc010, // 11  000  0000  0010  000
	ARM64_SYSREG_ID_ISAR1_EL1      = 0xc011, // 11  000  0000  0010  001
	ARM64_SYSREG_ID_ISAR2_EL1      = 0xc012, // 11  000  0000  0010  010
	ARM64_SYSREG_ID_ISAR3_EL1      = 0xc013, // 11  000  0000  0010  011
	ARM64_SYSREG_ID_ISAR4_EL1      = 0xc014, // 11  000  0000  0010  100
	ARM64_SYSREG_ID_ISAR5_EL1      = 0xc015, // 11  000  0000  0010  101
	ARM64_SYSREG_ID_A64PFR0_EL1   = 0xc020, // 11  000  0000  0100  000
	ARM64_SYSREG_ID_A64PFR1_EL1   = 0xc021, // 11  000  0000  0100  001
	ARM64_SYSREG_ID_A64DFR0_EL1   = 0xc028, // 11  000  0000  0101  000
	ARM64_SYSREG_ID_A64DFR1_EL1   = 0xc029, // 11  000  0000  0101  001
	ARM64_SYSREG_ID_A64AFR0_EL1   = 0xc02c, // 11  000  0000  0101  100
	ARM64_SYSREG_ID_A64AFR1_EL1   = 0xc02d, // 11  000  0000  0101  101
	ARM64_SYSREG_ID_A64ISAR0_EL1  = 0xc030, // 11  000  0000  0110  000
	ARM64_SYSREG_ID_A64ISAR1_EL1  = 0xc031, // 11  000  0000  0110  001
	ARM64_SYSREG_ID_A64MMFR0_EL1  = 0xc038, // 11  000  0000  0111  000
	ARM64_SYSREG_ID_A64MMFR1_EL1  = 0xc039, // 11  000  0000  0111  001
	ARM64_SYSREG_MVFR0_EL1         = 0xc018, // 11  000  0000  0011  000
	ARM64_SYSREG_MVFR1_EL1         = 0xc019, // 11  000  0000  0011  001
	ARM64_SYSREG_MVFR2_EL1         = 0xc01a, // 11  000  0000  0011  010
	ARM64_SYSREG_RVBAR_EL1         = 0xc601, // 11  000  1100  0000  001
	ARM64_SYSREG_RVBAR_EL2         = 0xe601, // 11  100  1100  0000  001
	ARM64_SYSREG_RVBAR_EL3         = 0xf601, // 11  110  1100  0000  001
	ARM64_SYSREG_ISR_EL1           = 0xc608, // 11  000  1100  0001  000
	ARM64_SYSREG_CNTPCT_EL0        = 0xdf01, // 11  011  1110  0000  001
	ARM64_SYSREG_CNTVCT_EL0        = 0xdf02,  // 11  011  1110  0000  010

	// Trace registers
	ARM64_SYSREG_TRCSTATR          = 0x8818, // 10  001  0000  0011  000
	ARM64_SYSREG_TRCIDR8           = 0x8806, // 10  001  0000  0000  110
	ARM64_SYSREG_TRCIDR9           = 0x880e, // 10  001  0000  0001  110
	ARM64_SYSREG_TRCIDR10          = 0x8816, // 10  001  0000  0010  110
	ARM64_SYSREG_TRCIDR11          = 0x881e, // 10  001  0000  0011  110
	ARM64_SYSREG_TRCIDR12          = 0x8826, // 10  001  0000  0100  110
	ARM64_SYSREG_TRCIDR13          = 0x882e, // 10  001  0000  0101  110
	ARM64_SYSREG_TRCIDR0           = 0x8847, // 10  001  0000  1000  111
	ARM64_SYSREG_TRCIDR1           = 0x884f, // 10  001  0000  1001  111
	ARM64_SYSREG_TRCIDR2           = 0x8857, // 10  001  0000  1010  111
	ARM64_SYSREG_TRCIDR3           = 0x885f, // 10  001  0000  1011  111
	ARM64_SYSREG_TRCIDR4           = 0x8867, // 10  001  0000  1100  111
	ARM64_SYSREG_TRCIDR5           = 0x886f, // 10  001  0000  1101  111
	ARM64_SYSREG_TRCIDR6           = 0x8877, // 10  001  0000  1110  111
	ARM64_SYSREG_TRCIDR7           = 0x887f, // 10  001  0000  1111  111
	ARM64_SYSREG_TRCOSLSR          = 0x888c, // 10  001  0001  0001  100
	ARM64_SYSREG_TRCPDSR           = 0x88ac, // 10  001  0001  0101  100
	ARM64_SYSREG_TRCDEVAFF0        = 0x8bd6, // 10  001  0111  1010  110
	ARM64_SYSREG_TRCDEVAFF1        = 0x8bde, // 10  001  0111  1011  110
	ARM64_SYSREG_TRCLSR            = 0x8bee, // 10  001  0111  1101  110
	ARM64_SYSREG_TRCAUTHSTATUS     = 0x8bf6, // 10  001  0111  1110  110
	ARM64_SYSREG_TRCDEVARCH        = 0x8bfe, // 10  001  0111  1111  110
	ARM64_SYSREG_TRCDEVID          = 0x8b97, // 10  001  0111  0010  111
	ARM64_SYSREG_TRCDEVTYPE        = 0x8b9f, // 10  001  0111  0011  111
	ARM64_SYSREG_TRCPIDR4          = 0x8ba7, // 10  001  0111  0100  111
	ARM64_SYSREG_TRCPIDR5          = 0x8baf, // 10  001  0111  0101  111
	ARM64_SYSREG_TRCPIDR6          = 0x8bb7, // 10  001  0111  0110  111
	ARM64_SYSREG_TRCPIDR7          = 0x8bbf, // 10  001  0111  0111  111
	ARM64_SYSREG_TRCPIDR0          = 0x8bc7, // 10  001  0111  1000  111
	ARM64_SYSREG_TRCPIDR1          = 0x8bcf, // 10  001  0111  1001  111
	ARM64_SYSREG_TRCPIDR2          = 0x8bd7, // 10  001  0111  1010  111
	ARM64_SYSREG_TRCPIDR3          = 0x8bdf, // 10  001  0111  1011  111
	ARM64_SYSREG_TRCCIDR0          = 0x8be7, // 10  001  0111  1100  111
	ARM64_SYSREG_TRCCIDR1          = 0x8bef, // 10  001  0111  1101  111
	ARM64_SYSREG_TRCCIDR2          = 0x8bf7, // 10  001  0111  1110  111
	ARM64_SYSREG_TRCCIDR3          = 0x8bff, // 10  001  0111  1111  111

	// GICv3 registers
	ARM64_SYSREG_ICC_IAR1_EL1      = 0xc660, // 11  000  1100  1100  000
	ARM64_SYSREG_ICC_IAR0_EL1      = 0xc640, // 11  000  1100  1000  000
	ARM64_SYSREG_ICC_HPPIR1_EL1    = 0xc662, // 11  000  1100  1100  010
	ARM64_SYSREG_ICC_HPPIR0_EL1    = 0xc642, // 11  000  1100  1000  010
	ARM64_SYSREG_ICC_RPR_EL1       = 0xc65b, // 11  000  1100  1011  011
	ARM64_SYSREG_ICH_VTR_EL2       = 0xe659, // 11  100  1100  1011  001
	ARM64_SYSREG_ICH_EISR_EL2      = 0xe65b, // 11  100  1100  1011  011
	ARM64_SYSREG_ICH_ELSR_EL2      = 0xe65d, // 11  100  1100  1011  101
} arm64_sysreg;

typedef enum arm64_msr_reg {
	// System registers for MSR
	ARM64_SYSREG_DBGDTRTX_EL0      = 0x9828, // 10  011  0000  0101  000
	ARM64_SYSREG_OSLAR_EL1         = 0x8084, // 10  000  0001  0000  100
	ARM64_SYSREG_PMSWINC_EL0       = 0xdce4,  // 11  011  1001  1100  100

	// Trace Registers
	ARM64_SYSREG_TRCOSLAR          = 0x8884, // 10  001  0001  0000  100
	ARM64_SYSREG_TRCLAR            = 0x8be6, // 10  001  0111  1100  110

	// GICv3 registers
	ARM64_SYSREG_ICC_EOIR1_EL1     = 0xc661, // 11  000  1100  1100  001
	ARM64_SYSREG_ICC_EOIR0_EL1     = 0xc641, // 11  000  1100  1000  001
	ARM64_SYSREG_ICC_DIR_EL1       = 0xc659, // 11  000  1100  1011  001
	ARM64_SYSREG_ICC_SGI1R_EL1     = 0xc65d, // 11  000  1100  1011  101
	ARM64_SYSREG_ICC_ASGI1R_EL1    = 0xc65e, // 11  000  1100  1011  110
	ARM64_SYSREG_ICC_SGI0R_EL1     = 0xc65f, // 11  000  1100  1011  111
} arm64_msr_reg;

/// System PState Field (MSR instruction)
typedef enum arm64_pstate {
	ARM64_PSTATE_INVALID = 0,
	ARM64_PSTATE_SPSEL = 0x05,
	ARM64_PSTATE_DAIFSET = 0x1e,
	ARM64_PSTATE_DAIFCLR = 0x1f
} arm64_pstate;

/// Vector arrangement specifier (for FloatingPoint/Advanced SIMD insn)
typedef enum arm64_vas {
	ARM64_VAS_INVALID = 0,
	ARM64_VAS_8B,
	ARM64_VAS_16B,
	ARM64_VAS_4H,
	ARM64_VAS_8H,
	ARM64_VAS_2S,
	ARM64_VAS_4S,
	ARM64_VAS_1D,
	ARM64_VAS_2D,
	ARM64_VAS_1Q,
} arm64_vas;

/// Vector element size specifier
typedef enum arm64_vess {
	ARM64_VESS_INVALID = 0,
	ARM64_VESS_B,
	ARM64_VESS_H,
	ARM64_VESS_S,
	ARM64_VESS_D,
} arm64_vess;

/// Memory barrier operands
typedef enum arm64_barrier_op {
	ARM64_BARRIER_INVALID = 0,
	ARM64_BARRIER_OSHLD = 0x1,
	ARM64_BARRIER_OSHST = 0x2,
	ARM64_BARRIER_OSH =   0x3,
	ARM64_BARRIER_NSHLD = 0x5,
	ARM64_BARRIER_NSHST = 0x6,
	ARM64_BARRIER_NSH =   0x7,
	ARM64_BARRIER_ISHLD = 0x9,
	ARM64_BARRIER_ISHST = 0xa,
	ARM64_BARRIER_ISH =   0xb,
	ARM64_BARRIER_LD =    0xd,
	ARM64_BARRIER_ST =    0xe,
	ARM64_BARRIER_SY =    0xf
} arm64_barrier_op;

/// Operand type for instruction's operands
typedef enum arm64_op_type {
	ARM64_OP_INVALID = 0, ///< = CS_OP_INVALID (Uninitialized).
	ARM64_OP_REG, ///< = CS_OP_REG (Register operand).
	ARM64_OP_IMM, ///< = CS_OP_IMM (Immediate operand).
	ARM64_OP_MEM, ///< = CS_OP_MEM (Memory operand).
	ARM64_OP_FP,  ///< = CS_OP_FP (Floating-Point operand).
	ARM64_OP_CIMM = 64, ///< C-Immediate
	ARM64_OP_REG_MRS, ///< MRS register operand.
	ARM64_OP_REG_MSR, ///< MSR register operand.
	ARM64_OP_PSTATE, ///< PState operand.
	ARM64_OP_SYS, ///< SYS operand for IC/DC/AT/TLBI instructions.
	ARM64_OP_PREFETCH, ///< Prefetch operand (PRFM).
	ARM64_OP_BARRIER, ///< Memory barrier operand (ISB/DMB/DSB instructions).
} arm64_op_type;

/// TLBI operations
typedef enum arm64_tlbi_op {
	ARM64_TLBI_INVALID = 0,
	ARM64_TLBI_VMALLE1IS,
	ARM64_TLBI_VAE1IS,
	ARM64_TLBI_ASIDE1IS,
	ARM64_TLBI_VAAE1IS,
	ARM64_TLBI_VALE1IS,
	ARM64_TLBI_VAALE1IS,
	ARM64_TLBI_ALLE2IS,
	ARM64_TLBI_VAE2IS,
	ARM64_TLBI_ALLE1IS,
	ARM64_TLBI_VALE2IS,
	ARM64_TLBI_VMALLS12E1IS,
	ARM64_TLBI_ALLE3IS,
	ARM64_TLBI_VAE3IS,
	ARM64_TLBI_VALE3IS,
	ARM64_TLBI_IPAS2E1IS,
	ARM64_TLBI_IPAS2LE1IS,
	ARM64_TLBI_IPAS2E1,
	ARM64_TLBI_IPAS2LE1,
	ARM64_TLBI_VMALLE1,
	ARM64_TLBI_VAE1,
	ARM64_TLBI_ASIDE1,
	ARM64_TLBI_VAAE1,
	ARM64_TLBI_VALE1,
	ARM64_TLBI_VAALE1,
	ARM64_TLBI_ALLE2,
	ARM64_TLBI_VAE2,
	ARM64_TLBI_ALLE1,
	ARM64_TLBI_VALE2,
	ARM64_TLBI_VMALLS12E1,
	ARM64_TLBI_ALLE3,
	ARM64_TLBI_VAE3,
	ARM64_TLBI_VALE3,
} arm64_tlbi_op;

/// AT operations
typedef enum arm64_at_op {
	ARM64_AT_S1E1R,
	ARM64_AT_S1E1W,
	ARM64_AT_S1E0R,
	ARM64_AT_S1E0W,
	ARM64_AT_S1E2R,
	ARM64_AT_S1E2W,
	ARM64_AT_S12E1R,
	ARM64_AT_S12E1W,
	ARM64_AT_S12E0R,
	ARM64_AT_S12E0W,
	ARM64_AT_S1E3R,
	ARM64_AT_S1E3W,
} arm64_at_op;

/// DC operations
typedef enum arm64_dc_op {
	ARM64_DC_INVALID = 0,
	ARM64_DC_ZVA,
	ARM64_DC_IVAC,
	ARM64_DC_ISW,
	ARM64_DC_CVAC,
	ARM64_DC_CSW,
	ARM64_DC_CVAU,
	ARM64_DC_CIVAC,
	ARM64_DC_CISW,
} arm64_dc_op;

/// IC operations
typedef enum arm64_ic_op {
	ARM64_IC_INVALID = 0,
	ARM64_IC_IALLUIS,
	ARM64_IC_IALLU,
	ARM64_IC_IVAU,
} arm64_ic_op;

/// Prefetch operations (PRFM)
typedef enum arm64_prefetch_op {
	ARM64_PRFM_INVALID = 0,
	ARM64_PRFM_PLDL1KEEP = 0x00 + 1,
	ARM64_PRFM_PLDL1STRM = 0x01 + 1,
	ARM64_PRFM_PLDL2KEEP = 0x02 + 1,
	ARM64_PRFM_PLDL2STRM = 0x03 + 1,
	ARM64_PRFM_PLDL3KEEP = 0x04 + 1,
	ARM64_PRFM_PLDL3STRM = 0x05 + 1,
	ARM64_PRFM_PLIL1KEEP = 0x08 + 1,
	ARM64_PRFM_PLIL1STRM = 0x09 + 1,
	ARM64_PRFM_PLIL2KEEP = 0x0a + 1,
	ARM64_PRFM_PLIL2STRM = 0x0b + 1,
	ARM64_PRFM_PLIL3KEEP = 0x0c + 1,
	ARM64_PRFM_PLIL3STRM = 0x0d + 1,
	ARM64_PRFM_PSTL1KEEP = 0x10 + 1,
	ARM64_PRFM_PSTL1STRM = 0x11 + 1,
	ARM64_PRFM_PSTL2KEEP = 0x12 + 1,
	ARM64_PRFM_PSTL2STRM = 0x13 + 1,
	ARM64_PRFM_PSTL3KEEP = 0x14 + 1,
	ARM64_PRFM_PSTL3STRM = 0x15 + 1,
} arm64_prefetch_op;


/// ARM64 registers
typedef enum arm64_reg {
	ARM64_REG_INVALID = 0,

	ARM64_REG_X29,
	ARM64_REG_X30,
	ARM64_REG_NZCV,
	ARM64_REG_SP,
	ARM64_REG_WSP,
	ARM64_REG_WZR,
	ARM64_REG_XZR,
	ARM64_REG_B0,
	ARM64_REG_B1,
	ARM64_REG_B2,
	ARM64_REG_B3,
	ARM64_REG_B4,
	ARM64_REG_B5,
	ARM64_REG_B6,
	ARM64_REG_B7,
	ARM64_REG_B8,
	ARM64_REG_B9,
	ARM64_REG_B10,
	ARM64_REG_B11,
	ARM64_REG_B12,
	ARM64_REG_B13,
	ARM64_REG_B14,
	ARM64_REG_B15,
	ARM64_REG_B16,
	ARM64_REG_B17,
	ARM64_REG_B18,
	ARM64_REG_B19,
	ARM64_REG_B20,
	ARM64_REG_B21,
	ARM64_REG_B22,
	ARM64_REG_B23,
	ARM64_REG_B24,
	ARM64_REG_B25,
	ARM64_REG_B26,
	ARM64_REG_B27,
	ARM64_REG_B28,
	ARM64_REG_B29,
	ARM64_REG_B30,
	ARM64_REG_B31,
	ARM64_REG_D0,
	ARM64_REG_D1,
	ARM64_REG_D2,
	ARM64_REG_D3,
	ARM64_REG_D4,
	ARM64_REG_D5,
	ARM64_REG_D6,
	ARM64_REG_D7,
	ARM64_REG_D8,
	ARM64_REG_D9,
	ARM64_REG_D10,
	ARM64_REG_D11,
	ARM64_REG_D12,
	ARM64_REG_D13,
	ARM64_REG_D14,
	ARM64_REG_D15,
	ARM64_REG_D16,
	ARM64_REG_D17,
	ARM64_REG_D18,
	ARM64_REG_D19,
	ARM64_REG_D20,
	ARM64_REG_D21,
	ARM64_REG_D22,
	ARM64_REG_D23,
	ARM64_REG_D24,
	ARM64_REG_D25,
	ARM64_REG_D26,
	ARM64_REG_D27,
	ARM64_REG_D28,
	ARM64_REG_D29,
	ARM64_REG_D30,
	ARM64_REG_D31,
	ARM64_REG_H0,
	ARM64_REG_H1,
	ARM64_REG_H2,
	ARM64_REG_H3,
	ARM64_REG_H4,
	ARM64_REG_H5,
	ARM64_REG_H6,
	ARM64_REG_H7,
	ARM64_REG_H8,
	ARM64_REG_H9,
	ARM64_REG_H10,
	ARM64_REG_H11,
	ARM64_REG_H12,
	ARM64_REG_H13,
	ARM64_REG_H14,
	ARM64_REG_H15,
	ARM64_REG_H16,
	ARM64_REG_H17,
	ARM64_REG_H18,
	ARM64_REG_H19,
	ARM64_REG_H20,
	ARM64_REG_H21,
	ARM64_REG_H22,
	ARM64_REG_H23,
	ARM64_REG_H24,
	ARM64_REG_H25,
	ARM64_REG_H26,
	ARM64_REG_H27,
	ARM64_REG_H28,
	ARM64_REG_H29,
	ARM64_REG_H30,
	ARM64_REG_H31,
	ARM64_REG_Q0,
	ARM64_REG_Q1,
	ARM64_REG_Q2,
	ARM64_REG_Q3,
	ARM64_REG_Q4,
	ARM64_REG_Q5,
	ARM64_REG_Q6,
	ARM64_REG_Q7,
	ARM64_REG_Q8,
	ARM64_REG_Q9,
	ARM64_REG_Q10,
	ARM64_REG_Q11,
	ARM64_REG_Q12,
	ARM64_REG_Q13,
	ARM64_REG_Q14,
	ARM64_REG_Q15,
	ARM64_REG_Q16,
	ARM64_REG_Q17,
	ARM64_REG_Q18,
	ARM64_REG_Q19,
	ARM64_REG_Q20,
	ARM64_REG_Q21,
	ARM64_REG_Q22,
	ARM64_REG_Q23,
	ARM64_REG_Q24,
	ARM64_REG_Q25,
	ARM64_REG_Q26,
	ARM64_REG_Q27,
	ARM64_REG_Q28,
	ARM64_REG_Q29,
	ARM64_REG_Q30,
	ARM64_REG_Q31,
	ARM64_REG_S0,
	ARM64_REG_S1,
	ARM64_REG_S2,
	ARM64_REG_S3,
	ARM64_REG_S4,
	ARM64_REG_S5,
	ARM64_REG_S6,
	ARM64_REG_S7,
	ARM64_REG_S8,
	ARM64_REG_S9,
	ARM64_REG_S10,
	ARM64_REG_S11,
	ARM64_REG_S12,
	ARM64_REG_S13,
	ARM64_REG_S14,
	ARM64_REG_S15,
	ARM64_REG_S16,
	ARM64_REG_S17,
	ARM64_REG_S18,
	ARM64_REG_S19,
	ARM64_REG_S20,
	ARM64_REG_S21,
	ARM64_REG_S22,
	ARM64_REG_S23,
	ARM64_REG_S24,
	ARM64_REG_S25,
	ARM64_REG_S26,
	ARM64_REG_S27,
	ARM64_REG_S28,
	ARM64_REG_S29,
	ARM64_REG_S30,
	ARM64_REG_S31,
	ARM64_REG_W0,
	ARM64_REG_W1,
	ARM64_REG_W2,
	ARM64_REG_W3,
	ARM64_REG_W4,
	ARM64_REG_W5,
	ARM64_REG_W6,
	ARM64_REG_W7,
	ARM64_REG_W8,
	ARM64_REG_W9,
	ARM64_REG_W10,
	ARM64_REG_W11,
	ARM64_REG_W12,
	ARM64_REG_W13,
	ARM64_REG_W14,
	ARM64_REG_W15,
	ARM64_REG_W16,
	ARM64_REG_W17,
	ARM64_REG_W18,
	ARM64_REG_W19,
	ARM64_REG_W20,
	ARM64_REG_W21,
	ARM64_REG_W22,
	ARM64_REG_W23,
	ARM64_REG_W24,
	ARM64_REG_W25,
	ARM64_REG_W26,
	ARM64_REG_W27,
	ARM64_REG_W28,
	ARM64_REG_W29,
	ARM64_REG_W30,
	ARM64_REG_X0,
	ARM64_REG_X1,
	ARM64_REG_X2,
	ARM64_REG_X3,
	ARM64_REG_X4,
	ARM64_REG_X5,
	ARM64_REG_X6,
	ARM64_REG_X7,
	ARM64_REG_X8,
	ARM64_REG_X9,
	ARM64_REG_X10,
	ARM64_REG_X11,
	ARM64_REG_X12,
	ARM64_REG_X13,
	ARM64_REG_X14,
	ARM64_REG_X15,
	ARM64_REG_X16,
	ARM64_REG_X17,
	ARM64_REG_X18,
	ARM64_REG_X19,
	ARM64_REG_X20,
	ARM64_REG_X21,
	ARM64_REG_X22,
	ARM64_REG_X23,
	ARM64_REG_X24,
	ARM64_REG_X25,
	ARM64_REG_X26,
	ARM64_REG_X27,
	ARM64_REG_X28,

	ARM64_REG_V0,
	ARM64_REG_V1,
	ARM64_REG_V2,
	ARM64_REG_V3,
	ARM64_REG_V4,
	ARM64_REG_V5,
	ARM64_REG_V6,
	ARM64_REG_V7,
	ARM64_REG_V8,
	ARM64_REG_V9,
	ARM64_REG_V10,
	ARM64_REG_V11,
	ARM64_REG_V12,
	ARM64_REG_V13,
	ARM64_REG_V14,
	ARM64_REG_V15,
	ARM64_REG_V16,
	ARM64_REG_V17,
	ARM64_REG_V18,
	ARM64_REG_V19,
	ARM64_REG_V20,
	ARM64_REG_V21,
	ARM64_REG_V22,
	ARM64_REG_V23,
	ARM64_REG_V24,
	ARM64_REG_V25,
	ARM64_REG_V26,
	ARM64_REG_V27,
	ARM64_REG_V28,
	ARM64_REG_V29,
	ARM64_REG_V30,
	ARM64_REG_V31,

	ARM64_REG_ENDING,		// <-- mark the end of the list of registers

	// alias registers

	ARM64_REG_IP0 = ARM64_REG_X16,
	ARM64_REG_IP1 = ARM64_REG_X17,
	ARM64_REG_FP = ARM64_REG_X29,
	ARM64_REG_LR = ARM64_REG_X30,
} arm64_reg;

/// Instruction's operand referring to memory
/// This is associated with ARM64_OP_MEM operand type above
typedef struct arm64_op_mem {
	arm64_reg base;	///< base register
	arm64_reg index;	///< index register
	int32_t disp;	///< displacement/offset value
} arm64_op_mem;

/// Instruction operand
typedef struct cs_arm64_op {
	int vector_index;	///< Vector Index for some vector operands (or -1 if irrelevant)
	arm64_vas vas;		///< Vector Arrangement Specifier
	arm64_vess vess;	///< Vector Element Size Specifier
	struct {
		arm64_shifter type;	///< shifter type of this operand
		unsigned int value;	///< shifter value of this operand
	} shift;
	arm64_extender ext;		///< extender type of this operand
	arm64_op_type type;	///< operand type
	union {
		arm64_reg reg;	///< register value for REG operand
		int64_t imm;		///< immediate value, or index for C-IMM or IMM operand
		double fp;			///< floating point value for FP operand
		arm64_op_mem mem;		///< base/index/scale/disp value for MEM operand
		arm64_pstate pstate;		///< PState field of MSR instruction.
		unsigned int sys;  ///< IC/DC/AT/TLBI operation (see arm64_ic_op, arm64_dc_op, arm64_at_op, arm64_tlbi_op)
		arm64_prefetch_op prefetch;  ///< PRFM operation.
		arm64_barrier_op barrier;  ///< Memory barrier operation (ISB/DMB/DSB instructions).
	};

	/// How is this operand accessed? (READ, WRITE or READ|WRITE)
	/// This field is combined of cs_ac_type.
	/// NOTE: this field is irrelevant if engine is compiled in DIET mode.
	uint8_t access;
} cs_arm64_op;

/// Instruction structure
typedef struct cs_arm64 {
	arm64_cc cc;	///< conditional code for this insn
	bool update_flags;	///< does this insn update flags?
	bool writeback;	///< does this insn request writeback? 'True' means 'yes'

	/// Number of operands of this instruction,
	/// or 0 when instruction has no operand.
	uint8_t op_count;

	cs_arm64_op operands[8]; ///< operands for this instruction.
} cs_arm64;

/// ARM64 instruction
typedef enum arm64_insn {
	ARM64_INS_INVALID = 0,

	ARM64_INS_ABS,
	ARM64_INS_ADC,
	ARM64_INS_ADDHN,
	ARM64_INS_ADDHN2,
	ARM64_INS_ADDP,
	ARM64_INS_ADD,
	ARM64_INS_ADDV,
	ARM64_INS_ADR,
	ARM64_INS_ADRP,
	ARM64_INS_AESD,
	ARM64_INS_AESE,
	ARM64_INS_AESIMC,
	ARM64_INS_AESMC,
	ARM64_INS_AND,
	ARM64_INS_ASR,
	ARM64_INS_B,
	ARM64_INS_BFM,
	ARM64_INS_BIC,
	ARM64_INS_BIF,
	ARM64_INS_BIT,
	ARM64_INS_BL,
	ARM64_INS_BLR,
	ARM64_INS_BR,
	ARM64_INS_BRK,
	ARM64_INS_BSL,
	ARM64_INS_CBNZ,
	ARM64_INS_CBZ,
	ARM64_INS_CCMN,
	ARM64_INS_CCMP,
	ARM64_INS_CLREX,
	ARM64_INS_CLS,
	ARM64_INS_CLZ,
	ARM64_INS_CMEQ,
	ARM64_INS_CMGE,
	ARM64_INS_CMGT,
	ARM64_INS_CMHI,
	ARM64_INS_CMHS,
	ARM64_INS_CMLE,
	ARM64_INS_CMLT,
	ARM64_INS_CMTST,
	ARM64_INS_CNT,
	ARM64_INS_MOV,
	ARM64_INS_CRC32B,
	ARM64_INS_CRC32CB,
	ARM64_INS_CRC32CH,
	ARM64_INS_CRC32CW,
	ARM64_INS_CRC32CX,
	ARM64_INS_CRC32H,
	ARM64_INS_CRC32W,
	ARM64_INS_CRC32X,
	ARM64_INS_CSEL,
	ARM64_INS_CSINC,
	ARM64_INS_CSINV,
	ARM64_INS_CSNEG,
	ARM64_INS_DCPS1,
	ARM64_INS_DCPS2,
	ARM64_INS_DCPS3,
	ARM64_INS_DMB,
	ARM64_INS_DRPS,
	ARM64_INS_DSB,
	ARM64_INS_DUP,
	ARM64_INS_EON,
	ARM64_INS_EOR,
	ARM64_INS_ERET,
	ARM64_INS_EXTR,
	ARM64_INS_EXT,
	ARM64_INS_FABD,
	ARM64_INS_FABS,
	ARM64_INS_FACGE,
	ARM64_INS_FACGT,
	ARM64_INS_FADD,
	ARM64_INS_FADDP,
	ARM64_INS_FCCMP,
	ARM64_INS_FCCMPE,
	ARM64_INS_FCMEQ,
	ARM64_INS_FCMGE,
	ARM64_INS_FCMGT,
	ARM64_INS_FCMLE,
	ARM64_INS_FCMLT,
	ARM64_INS_FCMP,
	ARM64_INS_FCMPE,
	ARM64_INS_FCSEL,
	ARM64_INS_FCVTAS,
	ARM64_INS_FCVTAU,
	ARM64_INS_FCVT,
	ARM64_INS_FCVTL,
	ARM64_INS_FCVTL2,
	ARM64_INS_FCVTMS,
	ARM64_INS_FCVTMU,
	ARM64_INS_FCVTNS,
	ARM64_INS_FCVTNU,
	ARM64_INS_FCVTN,
	ARM64_INS_FCVTN2,
	ARM64_INS_FCVTPS,
	ARM64_INS_FCVTPU,
	ARM64_INS_FCVTXN,
	ARM64_INS_FCVTXN2,
	ARM64_INS_FCVTZS,
	ARM64_INS_FCVTZU,
	ARM64_INS_FDIV,
	ARM64_INS_FMADD,
	ARM64_INS_FMAX,
	ARM64_INS_FMAXNM,
	ARM64_INS_FMAXNMP,
	ARM64_INS_FMAXNMV,
	ARM64_INS_FMAXP,
	ARM64_INS_FMAXV,
	ARM64_INS_FMIN,
	ARM64_INS_FMINNM,
	ARM64_INS_FMINNMP,
	ARM64_INS_FMINNMV,
	ARM64_INS_FMINP,
	ARM64_INS_FMINV,
	ARM64_INS_FMLA,
	ARM64_INS_FMLS,
	ARM64_INS_FMOV,
	ARM64_INS_FMSUB,
	ARM64_INS_FMUL,
	ARM64_INS_FMULX,
	ARM64_INS_FNEG,
	ARM64_INS_FNMADD,
	ARM64_INS_FNMSUB,
	ARM64_INS_FNMUL,
	ARM64_INS_FRECPE,
	ARM64_INS_FRECPS,
	ARM64_INS_FRECPX,
	ARM64_INS_FRINTA,
	ARM64_INS_FRINTI,
	ARM64_INS_FRINTM,
	ARM64_INS_FRINTN,
	ARM64_INS_FRINTP,
	ARM64_INS_FRINTX,
	ARM64_INS_FRINTZ,
	ARM64_INS_FRSQRTE,
	ARM64_INS_FRSQRTS,
	ARM64_INS_FSQRT,
	ARM64_INS_FSUB,
	ARM64_INS_HINT,
	ARM64_INS_HLT,
	ARM64_INS_HVC,
	ARM64_INS_INS,

	ARM64_INS_ISB,
	ARM64_INS_LD1,
	ARM64_INS_LD1R,
	ARM64_INS_LD2R,
	ARM64_INS_LD2,
	ARM64_INS_LD3R,
	ARM64_INS_LD3,
	ARM64_INS_LD4,
	ARM64_INS_LD4R,

	ARM64_INS_LDARB,
	ARM64_INS_LDARH,
	ARM64_INS_LDAR,
	ARM64_INS_LDAXP,
	ARM64_INS_LDAXRB,
	ARM64_INS_LDAXRH,
	ARM64_INS_LDAXR,
	ARM64_INS_LDNP,
	ARM64_INS_LDP,
	ARM64_INS_LDPSW,
	ARM64_INS_LDRB,
	ARM64_INS_LDR,
	ARM64_INS_LDRH,
	ARM64_INS_LDRSB,
	ARM64_INS_LDRSH,
	ARM64_INS_LDRSW,
	ARM64_INS_LDTRB,
	ARM64_INS_LDTRH,
	ARM64_INS_LDTRSB,

	ARM64_INS_LDTRSH,
	ARM64_INS_LDTRSW,
	ARM64_INS_LDTR,
	ARM64_INS_LDURB,
	ARM64_INS_LDUR,
	ARM64_INS_LDURH,
	ARM64_INS_LDURSB,
	ARM64_INS_LDURSH,
	ARM64_INS_LDURSW,
	ARM64_INS_LDXP,
	ARM64_INS_LDXRB,
	ARM64_INS_LDXRH,
	ARM64_INS_LDXR,
	ARM64_INS_LSL,
	ARM64_INS_LSR,
	ARM64_INS_MADD,
	ARM64_INS_MLA,
	ARM64_INS_MLS,
	ARM64_INS_MOVI,
	ARM64_INS_MOVK,
	ARM64_INS_MOVN,
	ARM64_INS_MOVZ,
	ARM64_INS_MRS,
	ARM64_INS_MSR,
	ARM64_INS_MSUB,
	ARM64_INS_MUL,
	ARM64_INS_MVNI,
	ARM64_INS_NEG,
	ARM64_INS_NOT,
	ARM64_INS_ORN,
	ARM64_INS_ORR,
	ARM64_INS_PMULL2,
	ARM64_INS_PMULL,
	ARM64_INS_PMUL,
	ARM64_INS_PRFM,
	ARM64_INS_PRFUM,
	ARM64_INS_RADDHN,
	ARM64_INS_RADDHN2,
	ARM64_INS_RBIT,
	ARM64_INS_RET,
	ARM64_INS_REV16,
	ARM64_INS_REV32,
	ARM64_INS_REV64,
	ARM64_INS_REV,
	ARM64_INS_ROR,
	ARM64_INS_RSHRN2,
	ARM64_INS_RSHRN,
	ARM64_INS_RSUBHN,
	ARM64_INS_RSUBHN2,
	ARM64_INS_SABAL2,
	ARM64_INS_SABAL,

	ARM64_INS_SABA,
	ARM64_INS_SABDL2,
	ARM64_INS_SABDL,
	ARM64_INS_SABD,
	ARM64_INS_SADALP,
	ARM64_INS_SADDLP,
	ARM64_INS_SADDLV,
	ARM64_INS_SADDL2,
	ARM64_INS_SADDL,
	ARM64_INS_SADDW2,
	ARM64_INS_SADDW,
	ARM64_INS_SBC,
	ARM64_INS_SBFM,
	ARM64_INS_SCVTF,
	ARM64_INS_SDIV,
	ARM64_INS_SHA1C,
	ARM64_INS_SHA1H,
	ARM64_INS_SHA1M,
	ARM64_INS_SHA1P,
	ARM64_INS_SHA1SU0,
	ARM64_INS_SHA1SU1,
	ARM64_INS_SHA256H2,
	ARM64_INS_SHA256H,
	ARM64_INS_SHA256SU0,
	ARM64_INS_SHA256SU1,
	ARM64_INS_SHADD,
	ARM64_INS_SHLL2,
	ARM64_INS_SHLL,
	ARM64_INS_SHL,
	ARM64_INS_SHRN2,
	ARM64_INS_SHRN,
	ARM64_INS_SHSUB,
	ARM64_INS_SLI,
	ARM64_INS_SMADDL,
	ARM64_INS_SMAXP,
	ARM64_INS_SMAXV,
	ARM64_INS_SMAX,
	ARM64_INS_SMC,
	ARM64_INS_SMINP,
	ARM64_INS_SMINV,
	ARM64_INS_SMIN,
	ARM64_INS_SMLAL2,
	ARM64_INS_SMLAL,
	ARM64_INS_SMLSL2,
	ARM64_INS_SMLSL,
	ARM64_INS_SMOV,
	ARM64_INS_SMSUBL,
	ARM64_INS_SMULH,
	ARM64_INS_SMULL2,
	ARM64_INS_SMULL,
	ARM64_INS_SQABS,
	ARM64_INS_SQADD,
	ARM64_INS_SQDMLAL,
	ARM64_INS_SQDMLAL2,
	ARM64_INS_SQDMLSL,
	ARM64_INS_SQDMLSL2,
	ARM64_INS_SQDMULH,
	ARM64_INS_SQDMULL,
	ARM64_INS_SQDMULL2,
	ARM64_INS_SQNEG,
	ARM64_INS_SQRDMULH,
	ARM64_INS_SQRSHL,
	ARM64_INS_SQRSHRN,
	ARM64_INS_SQRSHRN2,
	ARM64_INS_SQRSHRUN,
	ARM64_INS_SQRSHRUN2,
	ARM64_INS_SQSHLU,
	ARM64_INS_SQSHL,
	ARM64_INS_SQSHRN,
	ARM64_INS_SQSHRN2,
	ARM64_INS_SQSHRUN,
	ARM64_INS_SQSHRUN2,
	ARM64_INS_SQSUB,
	ARM64_INS_SQXTN2,
	ARM64_INS_SQXTN,
	ARM64_INS_SQXTUN2,
	ARM64_INS_SQXTUN,
	ARM64_INS_SRHADD,
	ARM64_INS_SRI,
	ARM64_INS_SRSHL,
	ARM64_INS_SRSHR,
	ARM64_INS_SRSRA,
	ARM64_INS_SSHLL2,
	ARM64_INS_SSHLL,
	ARM64_INS_SSHL,
	ARM64_INS_SSHR,
	ARM64_INS_SSRA,
	ARM64_INS_SSUBL2,
	ARM64_INS_SSUBL,
	ARM64_INS_SSUBW2,
	ARM64_INS_SSUBW,
	ARM64_INS_ST1,
	ARM64_INS_ST2,
	ARM64_INS_ST3,
	ARM64_INS_ST4,
	ARM64_INS_STLRB,
	ARM64_INS_STLRH,
	ARM64_INS_STLR,
	ARM64_INS_STLXP,
	ARM64_INS_STLXRB,
	ARM64_INS_STLXRH,
	ARM64_INS_STLXR,
	ARM64_INS_STNP,
	ARM64_INS_STP,
	ARM64_INS_STRB,
	ARM64_INS_STR,
	ARM64_INS_STRH,
	ARM64_INS_STTRB,
	ARM64_INS_STTRH,
	ARM64_INS_STTR,
	ARM64_INS_STURB,
	ARM64_INS_STUR,
	ARM64_INS_STURH,
	ARM64_INS_STXP,
	ARM64_INS_STXRB,
	ARM64_INS_STXRH,
	ARM64_INS_STXR,
	ARM64_INS_SUBHN,
	ARM64_INS_SUBHN2,
	ARM64_INS_SUB,
	ARM64_INS_SUQADD,
	ARM64_INS_SVC,
	ARM64_INS_SYSL,
	ARM64_INS_SYS,
	ARM64_INS_TBL,
	ARM64_INS_TBNZ,
	ARM64_INS_TBX,
	ARM64_INS_TBZ,
	ARM64_INS_TRN1,
	ARM64_INS_TRN2,
	ARM64_INS_UABAL2,
	ARM64_INS_UABAL,
	ARM64_INS_UABA,
	ARM64_INS_UABDL2,
	ARM64_INS_UABDL,
	ARM64_INS_UABD,
	ARM64_INS_UADALP,
	ARM64_INS_UADDLP,
	ARM64_INS_UADDLV,
	ARM64_INS_UADDL2,
	ARM64_INS_UADDL,
	ARM64_INS_UADDW2,
	ARM64_INS_UADDW,
	ARM64_INS_UBFM,
	ARM64_INS_UCVTF,
	ARM64_INS_UDIV,
	ARM64_INS_UHADD,
	ARM64_INS_UHSUB,
	ARM64_INS_UMADDL,
	ARM64_INS_UMAXP,
	ARM64_INS_UMAXV,
	ARM64_INS_UMAX,
	ARM64_INS_UMINP,
	ARM64_INS_UMINV,
	ARM64_INS_UMIN,
	ARM64_INS_UMLAL2,
	ARM64_INS_UMLAL,
	ARM64_INS_UMLSL2,
	ARM64_INS_UMLSL,
	ARM64_INS_UMOV,
	ARM64_INS_UMSUBL,
	ARM64_INS_UMULH,
	ARM64_INS_UMULL2,
	ARM64_INS_UMULL,
	ARM64_INS_UQADD,
	ARM64_INS_UQRSHL,
	ARM64_INS_UQRSHRN,
	ARM64_INS_UQRSHRN2,
	ARM64_INS_UQSHL,
	ARM64_INS_UQSHRN,
	ARM64_INS_UQSHRN2,
	ARM64_INS_UQSUB,
	ARM64_INS_UQXTN2,
	ARM64_INS_UQXTN,
	ARM64_INS_URECPE,
	ARM64_INS_URHADD,
	ARM64_INS_URSHL,
	ARM64_INS_URSHR,
	ARM64_INS_URSQRTE,
	ARM64_INS_URSRA,
	ARM64_INS_USHLL2,
	ARM64_INS_USHLL,
	ARM64_INS_USHL,
	ARM64_INS_USHR,
	ARM64_INS_USQADD,
	ARM64_INS_USRA,
	ARM64_INS_USUBL2,
	ARM64_INS_USUBL,
	ARM64_INS_USUBW2,
	ARM64_INS_USUBW,
	ARM64_INS_UZP1,
	ARM64_INS_UZP2,
	ARM64_INS_XTN2,
	ARM64_INS_XTN,
	ARM64_INS_ZIP1,
	ARM64_INS_ZIP2,

	// alias insn
	ARM64_INS_MNEG,
	ARM64_INS_UMNEGL,
	ARM64_INS_SMNEGL,
	ARM64_INS_NOP,
	ARM64_INS_YIELD,
	ARM64_INS_WFE,
	ARM64_INS_WFI,
	ARM64_INS_SEV,
	ARM64_INS_SEVL,
	ARM64_INS_NGC,
	ARM64_INS_SBFIZ,
	ARM64_INS_UBFIZ,
	ARM64_INS_SBFX,
	ARM64_INS_UBFX,
	ARM64_INS_BFI,
	ARM64_INS_BFXIL,
	ARM64_INS_CMN,
	ARM64_INS_MVN,
	ARM64_INS_TST,
	ARM64_INS_CSET,
	ARM64_INS_CINC,
	ARM64_INS_CSETM,
	ARM64_INS_CINV,
	ARM64_INS_CNEG,
	ARM64_INS_SXTB,
	ARM64_INS_SXTH,
	ARM64_INS_SXTW,
	ARM64_INS_CMP,
	ARM64_INS_UXTB,
	ARM64_INS_UXTH,
	ARM64_INS_UXTW,
	ARM64_INS_IC,
	ARM64_INS_DC,
	ARM64_INS_AT,
	ARM64_INS_TLBI,

	ARM64_INS_NEGS,
	ARM64_INS_NGCS,

	ARM64_INS_ENDING,  // <-- mark the end of the list of insn
} arm64_insn;

/// Group of ARM64 instructions
typedef enum arm64_insn_group {
	ARM64_GRP_INVALID = 0, ///< = CS_GRP_INVALID

	// Generic groups
	// all jump instructions (conditional+direct+indirect jumps)
	ARM64_GRP_JUMP,	///< = CS_GRP_JUMP
	ARM64_GRP_CALL,
	ARM64_GRP_RET,
	ARM64_GRP_INT,
	ARM64_GRP_PRIVILEGE = 6, ///< = CS_GRP_PRIVILEGE
	ARM64_GRP_BRANCH_RELATIVE, ///< = CS_GRP_BRANCH_RELATIVE

	// Architecture-specific groups
	ARM64_GRP_CRYPTO = 128,
	ARM64_GRP_FPARMV8,
	ARM64_GRP_NEON,
	ARM64_GRP_CRC,

	ARM64_GRP_ENDING,  // <-- mark the end of the list of groups
} arm64_insn_group;

#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/include/capstone/capstone/capstone.h`:

```h
#ifndef CAPSTONE_ENGINE_H
#define CAPSTONE_ENGINE_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2016 */

#ifdef __cplusplus
extern "C" {
#endif

#include <stdarg.h>

#if defined(CAPSTONE_HAS_OSXKERNEL)
#include <libkern/libkern.h>
#else
#include <stdlib.h>
#include <stdio.h>
#endif

#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#pragma warning(disable:4100)
#define CAPSTONE_API __cdecl
#ifdef CAPSTONE_SHARED
#define CAPSTONE_EXPORT __declspec(dllexport)
#else    // defined(CAPSTONE_STATIC)
#define CAPSTONE_EXPORT
#endif
#else
#define CAPSTONE_API
#if defined(__GNUC__) && !defined(CAPSTONE_STATIC)
#define CAPSTONE_EXPORT __attribute__((visibility("default")))
#else    // defined(CAPSTONE_STATIC)
#define CAPSTONE_EXPORT
#endif
#endif

#ifdef __GNUC__
#define CAPSTONE_DEPRECATED __attribute__((deprecated))
#elif defined(_MSC_VER)
#define CAPSTONE_DEPRECATED __declspec(deprecated)
#else
#pragma message("WARNING: You need to implement CAPSTONE_DEPRECATED for this compiler")
#define CAPSTONE_DEPRECATED
#endif

// Capstone API version
#define CS_API_MAJOR 4
#define CS_API_MINOR 0

// Version for bleeding edge code of the Github's "next" branch.
// Use this if you want the absolutely latest development code.
// This version number will be bumped up whenever we have a new major change.
#define CS_NEXT_VERSION 5

// Capstone package version
#define CS_VERSION_MAJOR CS_API_MAJOR
#define CS_VERSION_MINOR CS_API_MINOR
#define CS_VERSION_EXTRA 2

/// Macro to create combined version which can be compared to
/// result of cs_version() API.
#define CS_MAKE_VERSION(major, minor) ((major << 8) + minor)

/// Maximum size of an instruction mnemonic string.
#define CS_MNEMONIC_SIZE 32

// Handle using with all API
typedef size_t csh;

/// Architecture type
typedef enum cs_arch {
	CS_ARCH_ARM = 0,	///< ARM architecture (including Thumb, Thumb-2)
	CS_ARCH_ARM64,		///< ARM-64, also called AArch64
	CS_ARCH_MIPS,		///< Mips architecture
	CS_ARCH_X86,		///< X86 architecture (including x86 & x86-64)
	CS_ARCH_PPC,		///< PowerPC architecture
	CS_ARCH_SPARC,		///< Sparc architecture
	CS_ARCH_SYSZ,		///< SystemZ architecture
	CS_ARCH_XCORE,		///< XCore architecture
	CS_ARCH_M68K,		///< 68K architecture
	CS_ARCH_TMS320C64X,	///< TMS320C64x architecture
	CS_ARCH_M680X,		///< 680X architecture
	CS_ARCH_EVM,		///< Ethereum architecture
	CS_ARCH_MAX,
	CS_ARCH_ALL = 0xFFFF, // All architectures - for cs_support()
} cs_arch;

// Support value to verify diet mode of the engine.
// If cs_support(CS_SUPPORT_DIET) return True, the engine was compiled
// in diet mode.
#define CS_SUPPORT_DIET (CS_ARCH_ALL + 1)

// Support value to verify X86 reduce mode of the engine.
// If cs_support(CS_SUPPORT_X86_REDUCE) return True, the engine was compiled
// in X86 reduce mode.
#define CS_SUPPORT_X86_REDUCE (CS_ARCH_ALL + 2)

/// Mode type
typedef enum cs_mode {
	CS_MODE_LITTLE_ENDIAN = 0,	///< little-endian mode (default mode)
	CS_MODE_ARM = 0,	///< 32-bit ARM
	CS_MODE_16 = 1 << 1,	///< 16-bit mode (X86)
	CS_MODE_32 = 1 << 2,	///< 32-bit mode (X86)
	CS_MODE_64 = 1 << 3,	///< 64-bit mode (X86, PPC)
	CS_MODE_THUMB = 1 << 4,	///< ARM's Thumb mode, including Thumb-2
	CS_MODE_MCLASS = 1 << 5,	///< ARM's Cortex-M series
	CS_MODE_V8 = 1 << 6,	///< ARMv8 A32 encodings for ARM
	CS_MODE_MICRO = 1 << 4, ///< MicroMips mode (MIPS)
	CS_MODE_MIPS3 = 1 << 5, ///< Mips III ISA
	CS_MODE_MIPS32R6 = 1 << 6, ///< Mips32r6 ISA
	CS_MODE_MIPS2 = 1 << 7, ///< Mips II ISA
	CS_MODE_V9 = 1 << 4, ///< SparcV9 mode (Sparc)
	CS_MODE_QPX = 1 << 4, ///< Quad Processing eXtensions mode (PPC)
	CS_MODE_M68K_000 = 1 << 1, ///< M68K 68000 mode
	CS_MODE_M68K_010 = 1 << 2, ///< M68K 68010 mode
	CS_MODE_M68K_020 = 1 << 3, ///< M68K 68020 mode
	CS_MODE_M68K_030 = 1 << 4, ///< M68K 68030 mode
	CS_MODE_M68K_040 = 1 << 5, ///< M68K 68040 mode
	CS_MODE_M68K_060 = 1 << 6, ///< M68K 68060 mode
	CS_MODE_BIG_ENDIAN = 1 << 31,	///< big-endian mode
	CS_MODE_MIPS32 = CS_MODE_32,	///< Mips32 ISA (Mips)
	CS_MODE_MIPS64 = CS_MODE_64,	///< Mips64 ISA (Mips)
	CS_MODE_M680X_6301 = 1 << 1, ///< M680X Hitachi 6301,6303 mode
	CS_MODE_M680X_6309 = 1 << 2, ///< M680X Hitachi 6309 mode
	CS_MODE_M680X_6800 = 1 << 3, ///< M680X Motorola 6800,6802 mode
	CS_MODE_M680X_6801 = 1 << 4, ///< M680X Motorola 6801,6803 mode
	CS_MODE_M680X_6805 = 1 << 5, ///< M680X Motorola/Freescale 6805 mode
	CS_MODE_M680X_6808 = 1 << 6, ///< M680X Motorola/Freescale/NXP 68HC08 mode
	CS_MODE_M680X_6809 = 1 << 7, ///< M680X Motorola 6809 mode
	CS_MODE_M680X_6811 = 1 << 8, ///< M680X Motorola/Freescale/NXP 68HC11 mode
	CS_MODE_M680X_CPU12 = 1 << 9, ///< M680X Motorola/Freescale/NXP CPU12
					///< used on M68HC12/HCS12
	CS_MODE_M680X_HCS08 = 1 << 10, ///< M680X Freescale/NXP HCS08 mode
} cs_mode;

typedef void* (CAPSTONE_API *cs_malloc_t)(size_t size);
typedef void* (CAPSTONE_API *cs_calloc_t)(size_t nmemb, size_t size);
typedef void* (CAPSTONE_API *cs_realloc_t)(void *ptr, size_t size);
typedef void (CAPSTONE_API *cs_free_t)(void *ptr);
typedef int (CAPSTONE_API *cs_vsnprintf_t)(char *str, size_t size, const char *format, va_list ap);


/// User-defined dynamic memory related functions: malloc/calloc/realloc/free/vsnprintf()
/// By default, Capstone uses system's malloc(), calloc(), realloc(), free() & vsnprintf().
typedef struct cs_opt_mem {
	cs_malloc_t malloc;
	cs_calloc_t calloc;
	cs_realloc_t realloc;
	cs_free_t free;
	cs_vsnprintf_t vsnprintf;
} cs_opt_mem;

/// Customize mnemonic for instructions with alternative name.
/// To reset existing customized instruction to its default mnemonic,
/// call cs_option(CS_OPT_MNEMONIC) again with the same @id and NULL value
/// for @mnemonic.
typedef struct cs_opt_mnem {
	/// ID of instruction to be customized.
	unsigned int id;
	/// Customized instruction mnemonic.
	const char *mnemonic;
} cs_opt_mnem;

/// Runtime option for the disassembled engine
typedef enum cs_opt_type {
	CS_OPT_INVALID = 0,	///< No option specified
	CS_OPT_SYNTAX,	///< Assembly output syntax
	CS_OPT_DETAIL,	///< Break down instruction structure into details
	CS_OPT_MODE,	///< Change engine's mode at run-time
	CS_OPT_MEM,	///< User-defined dynamic memory related functions
	CS_OPT_SKIPDATA, ///< Skip data when disassembling. Then engine is in SKIPDATA mode.
	CS_OPT_SKIPDATA_SETUP, ///< Setup user-defined function for SKIPDATA option
	CS_OPT_MNEMONIC, ///< Customize instruction mnemonic
	CS_OPT_UNSIGNED, ///< print immediate operands in unsigned form
} cs_opt_type;

/// Runtime option value (associated with option type above)
typedef enum cs_opt_value {
	CS_OPT_OFF = 0,  ///< Turn OFF an option - default for CS_OPT_DETAIL, CS_OPT_SKIPDATA, CS_OPT_UNSIGNED.
	CS_OPT_ON = 3, ///< Turn ON an option (CS_OPT_DETAIL, CS_OPT_SKIPDATA).
	CS_OPT_SYNTAX_DEFAULT = 0, ///< Default asm syntax (CS_OPT_SYNTAX).
	CS_OPT_SYNTAX_INTEL, ///< X86 Intel asm syntax - default on X86 (CS_OPT_SYNTAX).
	CS_OPT_SYNTAX_ATT,   ///< X86 ATT asm syntax (CS_OPT_SYNTAX).
	CS_OPT_SYNTAX_NOREGNAME, ///< Prints register name with only number (CS_OPT_SYNTAX)
	CS_OPT_SYNTAX_MASM, ///< X86 Intel Masm syntax (CS_OPT_SYNTAX).
} cs_opt_value;

/// Common instruction operand types - to be consistent across all architectures.
typedef enum cs_op_type {
	CS_OP_INVALID = 0,  ///< uninitialized/invalid operand.
	CS_OP_REG,          ///< Register operand.
	CS_OP_IMM,          ///< Immediate operand.
	CS_OP_MEM,          ///< Memory operand.
	CS_OP_FP,           ///< Floating-Point operand.
} cs_op_type;

/// Common instruction operand access types - to be consistent across all architectures.
/// It is possible to combine access types, for example: CS_AC_READ | CS_AC_WRITE
typedef enum cs_ac_type {
	CS_AC_INVALID = 0,        ///< Uninitialized/invalid access type.
	CS_AC_READ    = 1 << 0,   ///< Operand read from memory or register.
	CS_AC_WRITE   = 1 << 1,   ///< Operand write to memory or register.
} cs_ac_type;

/// Common instruction groups - to be consistent across all architectures.
typedef enum cs_group_type {
	CS_GRP_INVALID = 0,  ///< uninitialized/invalid group.
	CS_GRP_JUMP,    ///< all jump instructions (conditional+direct+indirect jumps)
	CS_GRP_CALL,    ///< all call instructions
	CS_GRP_RET,     ///< all return instructions
	CS_GRP_INT,     ///< all interrupt instructions (int+syscall)
	CS_GRP_IRET,    ///< all interrupt return instructions
	CS_GRP_PRIVILEGE,    ///< all privileged instructions
	CS_GRP_BRANCH_RELATIVE, ///< all relative branching instructions
} cs_group_type;

/**
 User-defined callback function for SKIPDATA option.
 See tests/test_skipdata.c for sample code demonstrating this API.

 @code: the input buffer containing code to be disassembled.
        This is the same buffer passed to cs_disasm().
 @code_size: size (in bytes) of the above @code buffer.
 @offset: the position of the currently-examining byte in the input
      buffer @code mentioned above.
 @user_data: user-data passed to cs_option() via @user_data field in
      cs_opt_skipdata struct below.

 @return: return number of bytes to skip, or 0 to immediately stop disassembling.
*/
typedef size_t (CAPSTONE_API *cs_skipdata_cb_t)(const uint8_t *code, size_t code_size, size_t offset, void *user_data);

/// User-customized setup for SKIPDATA option
typedef struct cs_opt_skipdata {
	/// Capstone considers data to skip as special "instructions".
	/// User can specify the string for this instruction's "mnemonic" here.
	/// By default (if @mnemonic is NULL), Capstone use ".byte".
	const char *mnemonic;

	/// User-defined callback function to be called when Capstone hits data.
	/// If the returned value from this callback is positive (>0), Capstone
	/// will skip exactly that number of bytes & continue. Otherwise, if
	/// the callback returns 0, Capstone stops disassembling and returns
	/// immediately from cs_disasm()
	/// NOTE: if this callback pointer is NULL, Capstone would skip a number
	/// of bytes depending on architectures, as following:
	/// Arm:     2 bytes (Thumb mode) or 4 bytes.
	/// Arm64:   4 bytes.
	/// Mips:    4 bytes.
	/// M680x:   1 byte.
	/// PowerPC: 4 bytes.
	/// Sparc:   4 bytes.
	/// SystemZ: 2 bytes.
	/// X86:     1 bytes.
	/// XCore:   2 bytes.
	/// EVM:     1 bytes.
	cs_skipdata_cb_t callback; 	// default value is NULL

	/// User-defined data to be passed to @callback function pointer.
	void *user_data;
} cs_opt_skipdata;


#include "arm.h"
#include "arm64.h"
#include "m68k.h"
#include "mips.h"
#include "ppc.h"
#include "sparc.h"
#include "systemz.h"
#include "x86.h"
#include "xcore.h"
#include "tms320c64x.h"
#include "m680x.h"
#include "evm.h"

/// NOTE: All information in cs_detail is only available when CS_OPT_DETAIL = CS_OPT_ON
/// Initialized as memset(., 0, offsetof(cs_detail, ARCH)+sizeof(cs_ARCH))
/// by ARCH_getInstruction in arch/ARCH/ARCHDisassembler.c
/// if cs_detail changes, in particular if a field is added after the union,
/// then update arch/ARCH/ARCHDisassembler.c accordingly
typedef struct cs_detail {
	uint16_t regs_read[12]; ///< list of implicit registers read by this insn
	uint8_t regs_read_count; ///< number of implicit registers read by this insn

	uint16_t regs_write[20]; ///< list of implicit registers modified by this insn
	uint8_t regs_write_count; ///< number of implicit registers modified by this insn

	uint8_t groups[8]; ///< list of group this instruction belong to
	uint8_t groups_count; ///< number of groups this insn belongs to

	/// Architecture-specific instruction info
	union {
		cs_x86 x86;     ///< X86 architecture, including 16-bit, 32-bit & 64-bit mode
		cs_arm64 arm64; ///< ARM64 architecture (aka AArch64)
		cs_arm arm;     ///< ARM architecture (including Thumb/Thumb2)
		cs_m68k m68k;   ///< M68K architecture
		cs_mips mips;   ///< MIPS architecture
		cs_ppc ppc;	    ///< PowerPC architecture
		cs_sparc sparc; ///< Sparc architecture
		cs_sysz sysz;   ///< SystemZ architecture
		cs_xcore xcore; ///< XCore architecture
		cs_tms320c64x tms320c64x;  ///< TMS320C64x architecture
		cs_m680x m680x; ///< M680X architecture
		cs_evm evm;	    ///< Ethereum architecture
	};
} cs_detail;

/// Detail information of disassembled instruction
typedef struct cs_insn {
	/// Instruction ID (basically a numeric ID for the instruction mnemonic)
	/// Find the instruction id in the '[ARCH]_insn' enum in the header file
	/// of corresponding architecture, such as 'arm_insn' in arm.h for ARM,
	/// 'x86_insn' in x86.h for X86, etc...
	/// This information is available even when CS_OPT_DETAIL = CS_OPT_OFF
	/// NOTE: in Skipdata mode, "data" instruction has 0 for this id field.
	unsigned int id;

	/// Address (EIP) of this instruction
	/// This information is available even when CS_OPT_DETAIL = CS_OPT_OFF
	uint64_t address;

	/// Size of this instruction
	/// This information is available even when CS_OPT_DETAIL = CS_OPT_OFF
	uint16_t size;

	/// Machine bytes of this instruction, with number of bytes indicated by @size above
	/// This information is available even when CS_OPT_DETAIL = CS_OPT_OFF
	uint8_t bytes[16];

	/// Ascii text of instruction mnemonic
	/// This information is available even when CS_OPT_DETAIL = CS_OPT_OFF
	char mnemonic[CS_MNEMONIC_SIZE];

	/// Ascii text of instruction operands
	/// This information is available even when CS_OPT_DETAIL = CS_OPT_OFF
	char op_str[160];

	/// Pointer to cs_detail.
	/// NOTE: detail pointer is only valid when both requirements below are met:
	/// (1) CS_OP_DETAIL = CS_OPT_ON
	/// (2) Engine is not in Skipdata mode (CS_OP_SKIPDATA option set to CS_OPT_ON)
	///
	/// NOTE 2: when in Skipdata mode, or when detail mode is OFF, even if this pointer
	///     is not NULL, its content is still irrelevant.
	cs_detail *detail;
} cs_insn;


/// Calculate the offset of a disassembled instruction in its buffer, given its position
/// in its array of disassembled insn
/// NOTE: this macro works with position (>=1), not index
#define CS_INSN_OFFSET(insns, post) (insns[post - 1].address - insns[0].address)


/// All type of errors encountered by Capstone API.
/// These are values returned by cs_errno()
typedef enum cs_err {
	CS_ERR_OK = 0,   ///< No error: everything was fine
	CS_ERR_MEM,      ///< Out-Of-Memory error: cs_open(), cs_disasm(), cs_disasm_iter()
	CS_ERR_ARCH,     ///< Unsupported architecture: cs_open()
	CS_ERR_HANDLE,   ///< Invalid handle: cs_op_count(), cs_op_index()
	CS_ERR_CSH,      ///< Invalid csh argument: cs_close(), cs_errno(), cs_option()
	CS_ERR_MODE,     ///< Invalid/unsupported mode: cs_open()
	CS_ERR_OPTION,   ///< Invalid/unsupported option: cs_option()
	CS_ERR_DETAIL,   ///< Information is unavailable because detail option is OFF
	CS_ERR_MEMSETUP, ///< Dynamic memory management uninitialized (see CS_OPT_MEM)
	CS_ERR_VERSION,  ///< Unsupported version (bindings)
	CS_ERR_DIET,     ///< Access irrelevant data in "diet" engine
	CS_ERR_SKIPDATA, ///< Access irrelevant data for "data" instruction in SKIPDATA mode
	CS_ERR_X86_ATT,  ///< X86 AT&T syntax is unsupported (opt-out at compile time)
	CS_ERR_X86_INTEL, ///< X86 Intel syntax is unsupported (opt-out at compile time)
	CS_ERR_X86_MASM, ///< X86 Masm syntax is unsupported (opt-out at compile time)
} cs_err;

/**
 Return combined API version & major and minor version numbers.

 @major: major number of API version
 @minor: minor number of API version

 @return hexical number as (major << 8 | minor), which encodes both
	 major & minor versions.
	 NOTE: This returned value can be compared with version number made
	 with macro CS_MAKE_VERSION

 For example, second API version would return 1 in @major, and 1 in @minor
 The return value would be 0x0101

 NOTE: if you only care about returned value, but not major and minor values,
 set both @major & @minor arguments to NULL.
*/
CAPSTONE_EXPORT
unsigned int CAPSTONE_API cs_version(int *major, int *minor);


/**
 This API can be used to either ask for archs supported by this library,
 or check to see if the library was compile with 'diet' option (or called
 in 'diet' mode).

 To check if a particular arch is supported by this library, set @query to
 arch mode (CS_ARCH_* value).
 To verify if this library supports all the archs, use CS_ARCH_ALL.

 To check if this library is in 'diet' mode, set @query to CS_SUPPORT_DIET.

 @return True if this library supports the given arch, or in 'diet' mode.
*/
CAPSTONE_EXPORT
bool CAPSTONE_API cs_support(int query);

/**
 Initialize CS handle: this must be done before any usage of CS.

 @arch: architecture type (CS_ARCH_*)
 @mode: hardware mode. This is combined of CS_MODE_*
 @handle: pointer to handle, which will be updated at return time

 @return CS_ERR_OK on success, or other value on failure (refer to cs_err enum
 for detailed error).
*/
CAPSTONE_EXPORT
cs_err CAPSTONE_API cs_open(cs_arch arch, cs_mode mode, csh *handle);

/**
 Close CS handle: MUST do to release the handle when it is not used anymore.
 NOTE: this must be only called when there is no longer usage of Capstone,
 not even access to cs_insn array. The reason is the this API releases some
 cached memory, thus access to any Capstone API after cs_close() might crash
 your application.

 In fact,this API invalidate @handle by ZERO out its value (i.e *handle = 0).

 @handle: pointer to a handle returned by cs_open()

 @return CS_ERR_OK on success, or other value on failure (refer to cs_err enum
 for detailed error).
*/
CAPSTONE_EXPORT
cs_err CAPSTONE_API cs_close(csh *handle);

/**
 Set option for disassembling engine at runtime

 @handle: handle returned by cs_open()
 @type: type of option to be set
 @value: option value corresponding with @type

 @return: CS_ERR_OK on success, or other value on failure.
 Refer to cs_err enum for detailed error.

 NOTE: in the case of CS_OPT_MEM, handle's value can be anything,
 so that cs_option(handle, CS_OPT_MEM, value) can (i.e must) be called
 even before cs_open()
*/
CAPSTONE_EXPORT
cs_err CAPSTONE_API cs_option(csh handle, cs_opt_type type, size_t value);

/**
 Report the last error number when some API function fail.
 Like glibc's errno, cs_errno might not retain its old value once accessed.

 @handle: handle returned by cs_open()

 @return: error code of cs_err enum type (CS_ERR_*, see above)
*/
CAPSTONE_EXPORT
cs_err CAPSTONE_API cs_errno(csh handle);


/**
 Return a string describing given error code.

 @code: error code (see CS_ERR_* above)

 @return: returns a pointer to a string that describes the error code
	passed in the argument @code
*/
CAPSTONE_EXPORT
const char * CAPSTONE_API cs_strerror(cs_err code);

/**
 Disassemble binary code, given the code buffer, size, address and number
 of instructions to be decoded.
 This API dynamically allocate memory to contain disassembled instruction.
 Resulting instructions will be put into @*insn

 NOTE 1: this API will automatically determine memory needed to contain
 output disassembled instructions in @insn.

 NOTE 2: caller must free the allocated memory itself to avoid memory leaking.

 NOTE 3: for system with scarce memory to be dynamically allocated such as
 OS kernel or firmware, the API cs_disasm_iter() might be a better choice than
 cs_disasm(). The reason is that with cs_disasm(), based on limited available
 memory, we have to calculate in advance how many instructions to be disassembled,
 which complicates things. This is especially troublesome for the case @count=0,
 when cs_disasm() runs uncontrollably (until either end of input buffer, or
 when it encounters an invalid instruction).
 
 @handle: handle returned by cs_open()
 @code: buffer containing raw binary code to be disassembled.
 @code_size: size of the above code buffer.
 @address: address of the first instruction in given raw code buffer.
 @insn: array of instructions filled in by this API.
	   NOTE: @insn will be allocated by this function, and should be freed
	   with cs_free() API.
 @count: number of instructions to be disassembled, or 0 to get all of them

 @return: the number of successfully disassembled instructions,
 or 0 if this function failed to disassemble the given code

 On failure, call cs_errno() for error code.
*/
CAPSTONE_EXPORT
size_t CAPSTONE_API cs_disasm(csh handle,
		const uint8_t *code, size_t code_size,
		uint64_t address,
		size_t count,
		cs_insn **insn);

/**
  Deprecated function - to be retired in the next version!
  Use cs_disasm() instead of cs_disasm_ex()
*/
CAPSTONE_EXPORT
CAPSTONE_DEPRECATED
size_t CAPSTONE_API cs_disasm_ex(csh handle,
		const uint8_t *code, size_t code_size,
		uint64_t address,
		size_t count,
		cs_insn **insn);

/**
 Free memory allocated by cs_malloc() or cs_disasm() (argument @insn)

 @insn: pointer returned by @insn argument in cs_disasm() or cs_malloc()
 @count: number of cs_insn structures returned by cs_disasm(), or 1
     to free memory allocated by cs_malloc().
*/
CAPSTONE_EXPORT
void CAPSTONE_API cs_free(cs_insn *insn, size_t count);


/**
 Allocate memory for 1 instruction to be used by cs_disasm_iter().

 @handle: handle returned by cs_open()

 NOTE: when no longer in use, you can reclaim the memory allocated for
 this instruction with cs_free(insn, 1)
*/
CAPSTONE_EXPORT
cs_insn * CAPSTONE_API cs_malloc(csh handle);

/**
 Fast API to disassemble binary code, given the code buffer, size, address
 and number of instructions to be decoded.
 This API puts the resulting instruction into a given cache in @insn.
 See tests/test_iter.c for sample code demonstrating this API.

 NOTE 1: this API will update @code, @size & @address to point to the next
 instruction in the input buffer. Therefore, it is convenient to use
 cs_disasm_iter() inside a loop to quickly iterate all the instructions.
 While decoding one instruction at a time can also be achieved with
 cs_disasm(count=1), some benchmarks shown that cs_disasm_iter() can be 30%
 faster on random input.

 NOTE 2: the cache in @insn can be created with cs_malloc() API.

 NOTE 3: for system with scarce memory to be dynamically allocated such as
 OS kernel or firmware, this API is recommended over cs_disasm(), which
 allocates memory based on the number of instructions to be disassembled.
 The reason is that with cs_disasm(), based on limited available memory,
 we have to calculate in advance how many instructions to be disassembled,
 which complicates things. This is especially troublesome for the case
 @count=0, when cs_disasm() runs uncontrollably (until either end of input
 buffer, or when it encounters an invalid instruction).
 
 @handle: handle returned by cs_open()
 @code: buffer containing raw binary code to be disassembled
 @size: size of above code
 @address: address of the first insn in given raw code buffer
 @insn: pointer to instruction to be filled in by this API.

 @return: true if this API successfully decode 1 instruction,
 or false otherwise.

 On failure, call cs_errno() for error code.
*/
CAPSTONE_EXPORT
bool CAPSTONE_API cs_disasm_iter(csh handle,
	const uint8_t **code, size_t *size,
	uint64_t *address, cs_insn *insn);

/**
 Return friendly name of register in a string.
 Find the instruction id from header file of corresponding architecture (arm.h for ARM,
 x86.h for X86, ...)

 WARN: when in 'diet' mode, this API is irrelevant because engine does not
 store register name.

 @handle: handle returned by cs_open()
 @reg_id: register id

 @return: string name of the register, or NULL if @reg_id is invalid.
*/
CAPSTONE_EXPORT
const char * CAPSTONE_API cs_reg_name(csh handle, unsigned int reg_id);

/**
 Return friendly name of an instruction in a string.
 Find the instruction id from header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)

 WARN: when in 'diet' mode, this API is irrelevant because the engine does not
 store instruction name.

 @handle: handle returned by cs_open()
 @insn_id: instruction id

 @return: string name of the instruction, or NULL if @insn_id is invalid.
*/
CAPSTONE_EXPORT
const char * CAPSTONE_API cs_insn_name(csh handle, unsigned int insn_id);

/**
 Return friendly name of a group id (that an instruction can belong to)
 Find the group id from header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)

 WARN: when in 'diet' mode, this API is irrelevant because the engine does not
 store group name.

 @handle: handle returned by cs_open()
 @group_id: group id

 @return: string name of the group, or NULL if @group_id is invalid.
*/
CAPSTONE_EXPORT
const char * CAPSTONE_API cs_group_name(csh handle, unsigned int group_id);

/**
 Check if a disassembled instruction belong to a particular group.
 Find the group id from header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)
 Internally, this simply verifies if @group_id matches any member of insn->groups array.

 NOTE: this API is only valid when detail option is ON (which is OFF by default).

 WARN: when in 'diet' mode, this API is irrelevant because the engine does not
 update @groups array.

 @handle: handle returned by cs_open()
 @insn: disassembled instruction structure received from cs_disasm() or cs_disasm_iter()
 @group_id: group that you want to check if this instruction belong to.

 @return: true if this instruction indeed belongs to the given group, or false otherwise.
*/
CAPSTONE_EXPORT
bool CAPSTONE_API cs_insn_group(csh handle, const cs_insn *insn, unsigned int group_id);

/**
 Check if a disassembled instruction IMPLICITLY used a particular register.
 Find the register id from header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)
 Internally, this simply verifies if @reg_id matches any member of insn->regs_read array.

 NOTE: this API is only valid when detail option is ON (which is OFF by default)

 WARN: when in 'diet' mode, this API is irrelevant because the engine does not
 update @regs_read array.

 @insn: disassembled instruction structure received from cs_disasm() or cs_disasm_iter()
 @reg_id: register that you want to check if this instruction used it.

 @return: true if this instruction indeed implicitly used the given register, or false otherwise.
*/
CAPSTONE_EXPORT
bool CAPSTONE_API cs_reg_read(csh handle, const cs_insn *insn, unsigned int reg_id);

/**
 Check if a disassembled instruction IMPLICITLY modified a particular register.
 Find the register id from header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)
 Internally, this simply verifies if @reg_id matches any member of insn->regs_write array.

 NOTE: this API is only valid when detail option is ON (which is OFF by default)

 WARN: when in 'diet' mode, this API is irrelevant because the engine does not
 update @regs_write array.

 @insn: disassembled instruction structure received from cs_disasm() or cs_disasm_iter()
 @reg_id: register that you want to check if this instruction modified it.

 @return: true if this instruction indeed implicitly modified the given register, or false otherwise.
*/
CAPSTONE_EXPORT
bool CAPSTONE_API cs_reg_write(csh handle, const cs_insn *insn, unsigned int reg_id);

/**
 Count the number of operands of a given type.
 Find the operand type in header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)

 NOTE: this API is only valid when detail option is ON (which is OFF by default)

 @handle: handle returned by cs_open()
 @insn: disassembled instruction structure received from cs_disasm() or cs_disasm_iter()
 @op_type: Operand type to be found.

 @return: number of operands of given type @op_type in instruction @insn,
 or -1 on failure.
*/
CAPSTONE_EXPORT
int CAPSTONE_API cs_op_count(csh handle, const cs_insn *insn, unsigned int op_type);

/**
 Retrieve the position of operand of given type in <arch>.operands[] array.
 Later, the operand can be accessed using the returned position.
 Find the operand type in header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)

 NOTE: this API is only valid when detail option is ON (which is OFF by default)

 @handle: handle returned by cs_open()
 @insn: disassembled instruction structure received from cs_disasm() or cs_disasm_iter()
 @op_type: Operand type to be found.
 @position: position of the operand to be found. This must be in the range
			[1, cs_op_count(handle, insn, op_type)]

 @return: index of operand of given type @op_type in <arch>.operands[] array
 in instruction @insn, or -1 on failure.
*/
CAPSTONE_EXPORT
int CAPSTONE_API cs_op_index(csh handle, const cs_insn *insn, unsigned int op_type,
		unsigned int position);

/// Type of array to keep the list of registers
typedef uint16_t cs_regs[64];

/**
 Retrieve all the registers accessed by an instruction, either explicitly or
 implicitly.

 WARN: when in 'diet' mode, this API is irrelevant because engine does not
 store registers.

 @handle: handle returned by cs_open()
 @insn: disassembled instruction structure returned from cs_disasm() or cs_disasm_iter()
 @regs_read: on return, this array contains all registers read by instruction.
 @regs_read_count: number of registers kept inside @regs_read array.
 @regs_write: on return, this array contains all registers written by instruction.
 @regs_write_count: number of registers kept inside @regs_write array.

 @return CS_ERR_OK on success, or other value on failure (refer to cs_err enum
 for detailed error).
*/
CAPSTONE_EXPORT
cs_err CAPSTONE_API cs_regs_access(csh handle, const cs_insn *insn,
		cs_regs regs_read, uint8_t *regs_read_count,
		cs_regs regs_write, uint8_t *regs_write_count);

#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/include/capstone/capstone/evm.h`:

```h
#ifndef CAPSTONE_EVM_H
#define CAPSTONE_EVM_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2018 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

/// Instruction structure
typedef struct cs_evm {
    unsigned char pop;    ///< number of items popped from the stack
    unsigned char push;   ///< number of items pushed into the stack
    unsigned int  fee;    ///< gas fee for the instruction
} cs_evm;

/// EVM instruction
typedef enum evm_insn {
	EVM_INS_STOP = 0,
	EVM_INS_ADD = 1,
	EVM_INS_MUL = 2,
	EVM_INS_SUB = 3,
	EVM_INS_DIV = 4,
	EVM_INS_SDIV = 5,
	EVM_INS_MOD = 6,
	EVM_INS_SMOD = 7,
	EVM_INS_ADDMOD = 8,
	EVM_INS_MULMOD = 9,
	EVM_INS_EXP = 10,
	EVM_INS_SIGNEXTEND = 11,
	EVM_INS_LT = 16,
	EVM_INS_GT = 17,
	EVM_INS_SLT = 18,
	EVM_INS_SGT = 19,
	EVM_INS_EQ = 20,
	EVM_INS_ISZERO = 21,
	EVM_INS_AND = 22,
	EVM_INS_OR = 23,
	EVM_INS_XOR = 24,
	EVM_INS_NOT = 25,
	EVM_INS_BYTE = 26,
	EVM_INS_SHA3 = 32,
	EVM_INS_ADDRESS = 48,
	EVM_INS_BALANCE = 49,
	EVM_INS_ORIGIN = 50,
	EVM_INS_CALLER = 51,
	EVM_INS_CALLVALUE = 52,
	EVM_INS_CALLDATALOAD = 53,
	EVM_INS_CALLDATASIZE = 54,
	EVM_INS_CALLDATACOPY = 55,
	EVM_INS_CODESIZE = 56,
	EVM_INS_CODECOPY = 57,
	EVM_INS_GASPRICE = 58,
	EVM_INS_EXTCODESIZE = 59,
	EVM_INS_EXTCODECOPY = 60,
	EVM_INS_RETURNDATASIZE = 61,
	EVM_INS_RETURNDATACOPY = 62,
	EVM_INS_BLOCKHASH = 64,
	EVM_INS_COINBASE = 65,
	EVM_INS_TIMESTAMP = 66,
	EVM_INS_NUMBER = 67,
	EVM_INS_DIFFICULTY = 68,
	EVM_INS_GASLIMIT = 69,
	EVM_INS_POP = 80,
	EVM_INS_MLOAD = 81,
	EVM_INS_MSTORE = 82,
	EVM_INS_MSTORE8 = 83,
	EVM_INS_SLOAD = 84,
	EVM_INS_SSTORE = 85,
	EVM_INS_JUMP = 86,
	EVM_INS_JUMPI = 87,
	EVM_INS_PC = 88,
	EVM_INS_MSIZE = 89,
	EVM_INS_GAS = 90,
	EVM_INS_JUMPDEST = 91,
	EVM_INS_PUSH1 = 96,
	EVM_INS_PUSH2 = 97,
	EVM_INS_PUSH3 = 98,
	EVM_INS_PUSH4 = 99,
	EVM_INS_PUSH5 = 100,
	EVM_INS_PUSH6 = 101,
	EVM_INS_PUSH7 = 102,
	EVM_INS_PUSH8 = 103,
	EVM_INS_PUSH9 = 104,
	EVM_INS_PUSH10 = 105,
	EVM_INS_PUSH11 = 106,
	EVM_INS_PUSH12 = 107,
	EVM_INS_PUSH13 = 108,
	EVM_INS_PUSH14 = 109,
	EVM_INS_PUSH15 = 110,
	EVM_INS_PUSH16 = 111,
	EVM_INS_PUSH17 = 112,
	EVM_INS_PUSH18 = 113,
	EVM_INS_PUSH19 = 114,
	EVM_INS_PUSH20 = 115,
	EVM_INS_PUSH21 = 116,
	EVM_INS_PUSH22 = 117,
	EVM_INS_PUSH23 = 118,
	EVM_INS_PUSH24 = 119,
	EVM_INS_PUSH25 = 120,
	EVM_INS_PUSH26 = 121,
	EVM_INS_PUSH27 = 122,
	EVM_INS_PUSH28 = 123,
	EVM_INS_PUSH29 = 124,
	EVM_INS_PUSH30 = 125,
	EVM_INS_PUSH31 = 126,
	EVM_INS_PUSH32 = 127,
	EVM_INS_DUP1 = 128,
	EVM_INS_DUP2 = 129,
	EVM_INS_DUP3 = 130,
	EVM_INS_DUP4 = 131,
	EVM_INS_DUP5 = 132,
	EVM_INS_DUP6 = 133,
	EVM_INS_DUP7 = 134,
	EVM_INS_DUP8 = 135,
	EVM_INS_DUP9 = 136,
	EVM_INS_DUP10 = 137,
	EVM_INS_DUP11 = 138,
	EVM_INS_DUP12 = 139,
	EVM_INS_DUP13 = 140,
	EVM_INS_DUP14 = 141,
	EVM_INS_DUP15 = 142,
	EVM_INS_DUP16 = 143,
	EVM_INS_SWAP1 = 144,
	EVM_INS_SWAP2 = 145,
	EVM_INS_SWAP3 = 146,
	EVM_INS_SWAP4 = 147,
	EVM_INS_SWAP5 = 148,
	EVM_INS_SWAP6 = 149,
	EVM_INS_SWAP7 = 150,
	EVM_INS_SWAP8 = 151,
	EVM_INS_SWAP9 = 152,
	EVM_INS_SWAP10 = 153,
	EVM_INS_SWAP11 = 154,
	EVM_INS_SWAP12 = 155,
	EVM_INS_SWAP13 = 156,
	EVM_INS_SWAP14 = 157,
	EVM_INS_SWAP15 = 158,
	EVM_INS_SWAP16 = 159,
	EVM_INS_LOG0 = 160,
	EVM_INS_LOG1 = 161,
	EVM_INS_LOG2 = 162,
	EVM_INS_LOG3 = 163,
	EVM_INS_LOG4 = 164,
	EVM_INS_CREATE = 240,
	EVM_INS_CALL = 241,
	EVM_INS_CALLCODE = 242,
	EVM_INS_RETURN = 243,
	EVM_INS_DELEGATECALL = 244,
	EVM_INS_CALLBLACKBOX = 245,
	EVM_INS_STATICCALL = 250,
	EVM_INS_REVERT = 253,
	EVM_INS_SUICIDE = 255,

	EVM_INS_INVALID = 512,
	EVM_INS_ENDING,   // <-- mark the end of the list of instructions
} evm_insn;

/// Group of EVM instructions
typedef enum evm_insn_group {
	EVM_GRP_INVALID = 0, ///< = CS_GRP_INVALID

	EVM_GRP_JUMP,          ///< all jump instructions

	EVM_GRP_MATH = 8,      ///< math instructions
	EVM_GRP_STACK_WRITE,   ///< instructions write to stack
	EVM_GRP_STACK_READ,    ///< instructions read from stack
	EVM_GRP_MEM_WRITE,     ///< instructions write to memory
	EVM_GRP_MEM_READ,      ///< instructions read from memory
	EVM_GRP_STORE_WRITE,   ///< instructions write to storage
	EVM_GRP_STORE_READ,    ///< instructions read from storage
	EVM_GRP_HALT,    ///< instructions halt execution

	EVM_GRP_ENDING,   ///< <-- mark the end of the list of groups
} evm_insn_group;

#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/include/capstone/capstone/m680x.h`:

```h
#ifndef CAPSTONE_M680X_H
#define CAPSTONE_M680X_H

/* Capstone Disassembly Engine */
/* M680X Backend by Wolfgang Schwotzer <wolfgang.schwotzer@gmx.net> 2017 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

#define M680X_OPERAND_COUNT 9

/// M680X registers and special registers
typedef enum m680x_reg {
	M680X_REG_INVALID = 0,

	M680X_REG_A, ///< M6800/1/2/3/9, HD6301/9
	M680X_REG_B, ///< M6800/1/2/3/9, HD6301/9
	M680X_REG_E, ///< HD6309
	M680X_REG_F, ///< HD6309
	M680X_REG_0, ///< HD6309

	M680X_REG_D, ///< M6801/3/9, HD6301/9
	M680X_REG_W, ///< HD6309

	M680X_REG_CC, ///< M6800/1/2/3/9, M6301/9
	M680X_REG_DP, ///< M6809/M6309
	M680X_REG_MD, ///< M6309

	M680X_REG_HX, ///< M6808
	M680X_REG_H, ///< M6808
	M680X_REG_X, ///< M6800/1/2/3/9, M6301/9
	M680X_REG_Y, ///< M6809/M6309
	M680X_REG_S, ///< M6809/M6309
	M680X_REG_U, ///< M6809/M6309
	M680X_REG_V, ///< M6309

	M680X_REG_Q, ///< M6309

	M680X_REG_PC, ///< M6800/1/2/3/9, M6301/9

	M680X_REG_TMP2, ///< CPU12
	M680X_REG_TMP3, ///< CPU12

	M680X_REG_ENDING,   ///< <-- mark the end of the list of registers
} m680x_reg;

/// Operand type for instruction's operands
typedef enum m680x_op_type {
	M680X_OP_INVALID = 0, ///< = CS_OP_INVALID (Uninitialized).
	M680X_OP_REGISTER,    ///< = Register operand.
	M680X_OP_IMMEDIATE,   ///< = Immediate operand.
	M680X_OP_INDEXED,     ///< = Indexed addressing operand.
	M680X_OP_EXTENDED,    ///< = Extended addressing operand.
	M680X_OP_DIRECT,      ///< = Direct addressing operand.
	M680X_OP_RELATIVE,    ///< = Relative addressing operand.
	M680X_OP_CONSTANT,    ///< = constant operand (Displayed as number only).
				///< Used e.g. for a bit index or page number.
} m680x_op_type;

// Supported bit values for mem.idx.offset_bits
#define M680X_OFFSET_NONE      0
#define M680X_OFFSET_BITS_5    5
#define M680X_OFFSET_BITS_8    8
#define M680X_OFFSET_BITS_9    9
#define M680X_OFFSET_BITS_16  16

// Supported bit flags for mem.idx.flags
// These flags can be combined
#define M680X_IDX_INDIRECT     1
#define M680X_IDX_NO_COMMA     2
#define M680X_IDX_POST_INC_DEC 4

/// Instruction's operand referring to indexed addressing
typedef struct m680x_op_idx {
	m680x_reg base_reg;	///< base register (or M680X_REG_INVALID if
				///< irrelevant)
	m680x_reg offset_reg;	///< offset register (or M680X_REG_INVALID if
				///< irrelevant)
	int16_t offset;		///< 5-,8- or 16-bit offset. See also offset_bits.
	uint16_t offset_addr;	///< = offset addr. if base_reg == M680X_REG_PC.
				///< calculated as offset + PC
	uint8_t offset_bits;	///< offset width in bits for indexed addressing
	int8_t inc_dec;		///< inc. or dec. value:
				///<    0: no inc-/decrement
				///<    1 .. 8: increment by 1 .. 8
				///<    -1 .. -8: decrement by 1 .. 8
				///< if flag M680X_IDX_POST_INC_DEC set it is post
				///< inc-/decrement otherwise pre inc-/decrement
	uint8_t flags;		///< 8-bit flags (see above)
} m680x_op_idx;

/// Instruction's memory operand referring to relative addressing (Bcc/LBcc)
typedef struct m680x_op_rel {
	uint16_t address;	///< The absolute address.
				///< calculated as PC + offset. PC is the first
				///< address after the instruction.
	int16_t offset;		///< the offset/displacement value
} m680x_op_rel;

/// Instruction's operand referring to extended addressing
typedef struct m680x_op_ext {
	uint16_t address;      ///< The absolute address
	bool indirect;         ///< true if extended indirect addressing
} m680x_op_ext;

/// Instruction operand
typedef struct cs_m680x_op {
	m680x_op_type type;
	union {
		int32_t imm;		///< immediate value for IMM operand
		m680x_reg reg;		///< register value for REG operand
		m680x_op_idx idx;	///< Indexed addressing operand
		m680x_op_rel rel;	///< Relative address. operand (Bcc/LBcc)
		m680x_op_ext ext;	///< Extended address
		uint8_t direct_addr;	///<</ Direct address (lower 8-bit)
		uint8_t const_val;	///< constant value (bit index, page nr.)
	};
	uint8_t size;			///< size of this operand (in bytes)
	/// How is this operand accessed? (READ, WRITE or READ|WRITE)
	/// This field is combined of cs_ac_type.
	/// NOTE: this field is irrelevant if engine is compiled in DIET 
	uint8_t access;
} cs_m680x_op;

/// Group of M680X instructions
typedef enum m680x_group_type {
	M680X_GRP_INVALID = 0,	/// = CS_GRP_INVALID
	// Generic groups
	// all jump instructions (conditional+direct+indirect jumps)
	M680X_GRP_JUMP,		///< = CS_GRP_JUMP
	// all call instructions
	M680X_GRP_CALL,		///< = CS_GRP_CALL
	// all return instructions
	M680X_GRP_RET,		///< = CS_GRP_RET
	// all interrupt instructions (int+syscall)
	M680X_GRP_INT,		///< = CS_GRP_INT
	// all interrupt return instructions
	M680X_GRP_IRET,		///< = CS_GRP_IRET
	// all privileged instructions
	M680X_GRP_PRIV,		///< = CS_GRP_PRIVILEDGE; not used
	// all relative branching instructions
	M680X_GRP_BRAREL,	///< = CS_GRP_BRANCH_RELATIVE

	// Architecture-specific groups
	M680X_GRP_ENDING,	// <-- mark the end of the list of groups
} m680x_group_type;

// M680X instruction flags:

/// The first (register) operand is part of the
/// instruction mnemonic
#define M680X_FIRST_OP_IN_MNEM    1
/// The second (register) operand is part of the
/// instruction mnemonic
#define M680X_SECOND_OP_IN_MNEM   2

/// The M680X instruction and it's operands
typedef struct cs_m680x {
	uint8_t flags;		///< See: M680X instruction flags
	uint8_t op_count;	///< number of operands for the instruction or 0
	cs_m680x_op operands[M680X_OPERAND_COUNT]; ///< operands for this insn.
} cs_m680x;

/// M680X instruction IDs
typedef enum m680x_insn {
	M680X_INS_INVLD = 0,
	M680X_INS_ABA, ///< M6800/1/2/3
	M680X_INS_ABX,
	M680X_INS_ABY,
	M680X_INS_ADC,
	M680X_INS_ADCA,
	M680X_INS_ADCB,
	M680X_INS_ADCD,
	M680X_INS_ADCR,
	M680X_INS_ADD,
	M680X_INS_ADDA,
	M680X_INS_ADDB,
	M680X_INS_ADDD,
	M680X_INS_ADDE,
	M680X_INS_ADDF,
	M680X_INS_ADDR,
	M680X_INS_ADDW,
	M680X_INS_AIM,
	M680X_INS_AIS,
	M680X_INS_AIX,
	M680X_INS_AND,
	M680X_INS_ANDA,
	M680X_INS_ANDB,
	M680X_INS_ANDCC,
	M680X_INS_ANDD,
	M680X_INS_ANDR,
	M680X_INS_ASL,
	M680X_INS_ASLA,
	M680X_INS_ASLB,
	M680X_INS_ASLD, ///< or LSLD
	M680X_INS_ASR,
	M680X_INS_ASRA,
	M680X_INS_ASRB,
	M680X_INS_ASRD,
	M680X_INS_ASRX,
	M680X_INS_BAND,
	M680X_INS_BCC, ///< or BHS
	M680X_INS_BCLR,
	M680X_INS_BCS, ///< or BLO
	M680X_INS_BEOR,
	M680X_INS_BEQ,
	M680X_INS_BGE,
	M680X_INS_BGND,
	M680X_INS_BGT,
	M680X_INS_BHCC,
	M680X_INS_BHCS,
	M680X_INS_BHI,
	M680X_INS_BIAND,
	M680X_INS_BIEOR,
	M680X_INS_BIH,
	M680X_INS_BIL,
	M680X_INS_BIOR,
	M680X_INS_BIT,
	M680X_INS_BITA,
	M680X_INS_BITB,
	M680X_INS_BITD,
	M680X_INS_BITMD,
	M680X_INS_BLE,
	M680X_INS_BLS,
	M680X_INS_BLT,
	M680X_INS_BMC,
	M680X_INS_BMI,
	M680X_INS_BMS,
	M680X_INS_BNE,
	M680X_INS_BOR,
	M680X_INS_BPL,
	M680X_INS_BRCLR,
	M680X_INS_BRSET,
	M680X_INS_BRA,
	M680X_INS_BRN,
	M680X_INS_BSET,
	M680X_INS_BSR,
	M680X_INS_BVC,
	M680X_INS_BVS,
	M680X_INS_CALL,
	M680X_INS_CBA, ///< M6800/1/2/3
	M680X_INS_CBEQ,
	M680X_INS_CBEQA,
	M680X_INS_CBEQX,
	M680X_INS_CLC, ///< M6800/1/2/3
	M680X_INS_CLI, ///< M6800/1/2/3
	M680X_INS_CLR,
	M680X_INS_CLRA,
	M680X_INS_CLRB,
	M680X_INS_CLRD,
	M680X_INS_CLRE,
	M680X_INS_CLRF,
	M680X_INS_CLRH,
	M680X_INS_CLRW,
	M680X_INS_CLRX,
	M680X_INS_CLV, ///< M6800/1/2/3
	M680X_INS_CMP,
	M680X_INS_CMPA,
	M680X_INS_CMPB,
	M680X_INS_CMPD,
	M680X_INS_CMPE,
	M680X_INS_CMPF,
	M680X_INS_CMPR,
	M680X_INS_CMPS,
	M680X_INS_CMPU,
	M680X_INS_CMPW,
	M680X_INS_CMPX,
	M680X_INS_CMPY,
	M680X_INS_COM,
	M680X_INS_COMA,
	M680X_INS_COMB,
	M680X_INS_COMD,
	M680X_INS_COME,
	M680X_INS_COMF,
	M680X_INS_COMW,
	M680X_INS_COMX,
	M680X_INS_CPD,
	M680X_INS_CPHX,
	M680X_INS_CPS,
	M680X_INS_CPX, ///< M6800/1/2/3
	M680X_INS_CPY,
	M680X_INS_CWAI,
	M680X_INS_DAA,
	M680X_INS_DBEQ,
	M680X_INS_DBNE,
	M680X_INS_DBNZ,
	M680X_INS_DBNZA,
	M680X_INS_DBNZX,
	M680X_INS_DEC,
	M680X_INS_DECA,
	M680X_INS_DECB,
	M680X_INS_DECD,
	M680X_INS_DECE,
	M680X_INS_DECF,
	M680X_INS_DECW,
	M680X_INS_DECX,
	M680X_INS_DES, ///< M6800/1/2/3
	M680X_INS_DEX, ///< M6800/1/2/3
	M680X_INS_DEY,
	M680X_INS_DIV,
	M680X_INS_DIVD,
	M680X_INS_DIVQ,
	M680X_INS_EDIV,
	M680X_INS_EDIVS,
	M680X_INS_EIM,
	M680X_INS_EMACS,
	M680X_INS_EMAXD,
	M680X_INS_EMAXM,
	M680X_INS_EMIND,
	M680X_INS_EMINM,
	M680X_INS_EMUL,
	M680X_INS_EMULS,
	M680X_INS_EOR,
	M680X_INS_EORA,
	M680X_INS_EORB,
	M680X_INS_EORD,
	M680X_INS_EORR,
	M680X_INS_ETBL,
	M680X_INS_EXG,
	M680X_INS_FDIV,
	M680X_INS_IBEQ,
	M680X_INS_IBNE,
	M680X_INS_IDIV,
	M680X_INS_IDIVS,
	M680X_INS_ILLGL,
	M680X_INS_INC,
	M680X_INS_INCA,
	M680X_INS_INCB,
	M680X_INS_INCD,
	M680X_INS_INCE,
	M680X_INS_INCF,
	M680X_INS_INCW,
	M680X_INS_INCX,
	M680X_INS_INS, ///< M6800/1/2/3
	M680X_INS_INX, ///< M6800/1/2/3
	M680X_INS_INY,
	M680X_INS_JMP,
	M680X_INS_JSR,
	M680X_INS_LBCC, ///< or LBHS
	M680X_INS_LBCS, ///< or LBLO
	M680X_INS_LBEQ,
	M680X_INS_LBGE,
	M680X_INS_LBGT,
	M680X_INS_LBHI,
	M680X_INS_LBLE,
	M680X_INS_LBLS,
	M680X_INS_LBLT,
	M680X_INS_LBMI,
	M680X_INS_LBNE,
	M680X_INS_LBPL,
	M680X_INS_LBRA,
	M680X_INS_LBRN,
	M680X_INS_LBSR,
	M680X_INS_LBVC,
	M680X_INS_LBVS,
	M680X_INS_LDA,
	M680X_INS_LDAA, ///< M6800/1/2/3
	M680X_INS_LDAB, ///< M6800/1/2/3
	M680X_INS_LDB,
	M680X_INS_LDBT,
	M680X_INS_LDD,
	M680X_INS_LDE,
	M680X_INS_LDF,
	M680X_INS_LDHX,
	M680X_INS_LDMD,
	M680X_INS_LDQ,
	M680X_INS_LDS,
	M680X_INS_LDU,
	M680X_INS_LDW,
	M680X_INS_LDX,
	M680X_INS_LDY,
	M680X_INS_LEAS,
	M680X_INS_LEAU,
	M680X_INS_LEAX,
	M680X_INS_LEAY,
	M680X_INS_LSL,
	M680X_INS_LSLA,
	M680X_INS_LSLB,
	M680X_INS_LSLD,
	M680X_INS_LSLX,
	M680X_INS_LSR,
	M680X_INS_LSRA,
	M680X_INS_LSRB,
	M680X_INS_LSRD, ///< or ASRD
	M680X_INS_LSRW,
	M680X_INS_LSRX,
	M680X_INS_MAXA,
	M680X_INS_MAXM,
	M680X_INS_MEM,
	M680X_INS_MINA,
	M680X_INS_MINM,
	M680X_INS_MOV,
	M680X_INS_MOVB,
	M680X_INS_MOVW,
	M680X_INS_MUL,
	M680X_INS_MULD,
	M680X_INS_NEG,
	M680X_INS_NEGA,
	M680X_INS_NEGB,
	M680X_INS_NEGD,
	M680X_INS_NEGX,
	M680X_INS_NOP,
	M680X_INS_NSA,
	M680X_INS_OIM,
	M680X_INS_ORA,
	M680X_INS_ORAA, ///< M6800/1/2/3
	M680X_INS_ORAB, ///< M6800/1/2/3
	M680X_INS_ORB,
	M680X_INS_ORCC,
	M680X_INS_ORD,
	M680X_INS_ORR,
	M680X_INS_PSHA, ///< M6800/1/2/3
	M680X_INS_PSHB, ///< M6800/1/2/3
	M680X_INS_PSHC,
	M680X_INS_PSHD,
	M680X_INS_PSHH,
	M680X_INS_PSHS,
	M680X_INS_PSHSW,
	M680X_INS_PSHU,
	M680X_INS_PSHUW,
	M680X_INS_PSHX, ///< M6800/1/2/3
	M680X_INS_PSHY,
	M680X_INS_PULA, ///< M6800/1/2/3
	M680X_INS_PULB, ///< M6800/1/2/3
	M680X_INS_PULC,
	M680X_INS_PULD,
	M680X_INS_PULH,
	M680X_INS_PULS,
	M680X_INS_PULSW,
	M680X_INS_PULU,
	M680X_INS_PULUW,
	M680X_INS_PULX, ///< M6800/1/2/3
	M680X_INS_PULY,
	M680X_INS_REV,
	M680X_INS_REVW,
	M680X_INS_ROL,
	M680X_INS_ROLA,
	M680X_INS_ROLB,
	M680X_INS_ROLD,
	M680X_INS_ROLW,
	M680X_INS_ROLX,
	M680X_INS_ROR,
	M680X_INS_RORA,
	M680X_INS_RORB,
	M680X_INS_RORD,
	M680X_INS_RORW,
	M680X_INS_RORX,
	M680X_INS_RSP,
	M680X_INS_RTC,
	M680X_INS_RTI,
	M680X_INS_RTS,
	M680X_INS_SBA, ///< M6800/1/2/3
	M680X_INS_SBC,
	M680X_INS_SBCA,
	M680X_INS_SBCB,
	M680X_INS_SBCD,
	M680X_INS_SBCR,
	M680X_INS_SEC,
	M680X_INS_SEI,
	M680X_INS_SEV,
	M680X_INS_SEX,
	M680X_INS_SEXW,
	M680X_INS_SLP,
	M680X_INS_STA,
	M680X_INS_STAA, ///< M6800/1/2/3
	M680X_INS_STAB, ///< M6800/1/2/3
	M680X_INS_STB,
	M680X_INS_STBT,
	M680X_INS_STD,
	M680X_INS_STE,
	M680X_INS_STF,
	M680X_INS_STOP,
	M680X_INS_STHX,
	M680X_INS_STQ,
	M680X_INS_STS,
	M680X_INS_STU,
	M680X_INS_STW,
	M680X_INS_STX,
	M680X_INS_STY,
	M680X_INS_SUB,
	M680X_INS_SUBA,
	M680X_INS_SUBB,
	M680X_INS_SUBD,
	M680X_INS_SUBE,
	M680X_INS_SUBF,
	M680X_INS_SUBR,
	M680X_INS_SUBW,
	M680X_INS_SWI,
	M680X_INS_SWI2,
	M680X_INS_SWI3,
	M680X_INS_SYNC,
	M680X_INS_TAB, ///< M6800/1/2/3
	M680X_INS_TAP, ///< M6800/1/2/3
	M680X_INS_TAX,
	M680X_INS_TBA, ///< M6800/1/2/3
	M680X_INS_TBEQ,
	M680X_INS_TBL,
	M680X_INS_TBNE,
	M680X_INS_TEST,
	M680X_INS_TFM,
	M680X_INS_TFR,
	M680X_INS_TIM,
	M680X_INS_TPA, ///< M6800/1/2/3
	M680X_INS_TST,
	M680X_INS_TSTA,
	M680X_INS_TSTB,
	M680X_INS_TSTD,
	M680X_INS_TSTE,
	M680X_INS_TSTF,
	M680X_INS_TSTW,
	M680X_INS_TSTX,
	M680X_INS_TSX, ///< M6800/1/2/3
	M680X_INS_TSY,
	M680X_INS_TXA,
	M680X_INS_TXS, ///< M6800/1/2/3
	M680X_INS_TYS,
	M680X_INS_WAI, ///< M6800/1/2/3
	M680X_INS_WAIT,
	M680X_INS_WAV,
	M680X_INS_WAVR,
	M680X_INS_XGDX, ///< HD6301
	M680X_INS_XGDY,
	M680X_INS_ENDING,   // <-- mark the end of the list of instructions
} m680x_insn;

#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/include/capstone/capstone/m68k.h`:

```h
#ifndef CAPSTONE_M68K_H
#define CAPSTONE_M68K_H

/* Capstone Disassembly Engine */
/* By Daniel Collin <daniel@collin.com>, 2015-2016 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

#define M68K_OPERAND_COUNT 4

/// M68K registers and special registers
typedef enum m68k_reg {
	M68K_REG_INVALID = 0,

	M68K_REG_D0,
	M68K_REG_D1,
	M68K_REG_D2,
	M68K_REG_D3,
	M68K_REG_D4,
	M68K_REG_D5,
	M68K_REG_D6,
	M68K_REG_D7,

	M68K_REG_A0,
	M68K_REG_A1,
	M68K_REG_A2,
	M68K_REG_A3,
	M68K_REG_A4,
	M68K_REG_A5,
	M68K_REG_A6,
	M68K_REG_A7,

	M68K_REG_FP0,
	M68K_REG_FP1,
	M68K_REG_FP2,
	M68K_REG_FP3,
	M68K_REG_FP4,
	M68K_REG_FP5,
	M68K_REG_FP6,
	M68K_REG_FP7,

	M68K_REG_PC,

	M68K_REG_SR,
	M68K_REG_CCR,
	M68K_REG_SFC,
	M68K_REG_DFC,
	M68K_REG_USP,
	M68K_REG_VBR,
	M68K_REG_CACR,
	M68K_REG_CAAR,
	M68K_REG_MSP,
	M68K_REG_ISP,
	M68K_REG_TC,
	M68K_REG_ITT0,
	M68K_REG_ITT1,
	M68K_REG_DTT0,
	M68K_REG_DTT1,
	M68K_REG_MMUSR,
	M68K_REG_URP,
	M68K_REG_SRP,

	M68K_REG_FPCR,
	M68K_REG_FPSR,
	M68K_REG_FPIAR,

	M68K_REG_ENDING,   // <-- mark the end of the list of registers
} m68k_reg;

/// M68K Addressing Modes
typedef enum m68k_address_mode {
	M68K_AM_NONE = 0,			///< No address mode.

	M68K_AM_REG_DIRECT_DATA,		///< Register Direct - Data
	M68K_AM_REG_DIRECT_ADDR,		///< Register Direct - Address

	M68K_AM_REGI_ADDR,				///< Register Indirect - Address
	M68K_AM_REGI_ADDR_POST_INC,		///< Register Indirect - Address with Postincrement
	M68K_AM_REGI_ADDR_PRE_DEC,		///< Register Indirect - Address with Predecrement
	M68K_AM_REGI_ADDR_DISP,			///< Register Indirect - Address with Displacement

	M68K_AM_AREGI_INDEX_8_BIT_DISP,	///< Address Register Indirect With Index- 8-bit displacement
	M68K_AM_AREGI_INDEX_BASE_DISP,	///< Address Register Indirect With Index- Base displacement

	M68K_AM_MEMI_POST_INDEX,		///< Memory indirect - Postindex
	M68K_AM_MEMI_PRE_INDEX,			///< Memory indirect - Preindex

	M68K_AM_PCI_DISP,				///< Program Counter Indirect - with Displacement

	M68K_AM_PCI_INDEX_8_BIT_DISP,	///< Program Counter Indirect with Index - with 8-Bit Displacement
	M68K_AM_PCI_INDEX_BASE_DISP,	///< Program Counter Indirect with Index - with Base Displacement

	M68K_AM_PC_MEMI_POST_INDEX,		///< Program Counter Memory Indirect - Postindexed
	M68K_AM_PC_MEMI_PRE_INDEX,		///< Program Counter Memory Indirect - Preindexed

	M68K_AM_ABSOLUTE_DATA_SHORT,	///< Absolute Data Addressing  - Short
	M68K_AM_ABSOLUTE_DATA_LONG,		///< Absolute Data Addressing  - Long
	M68K_AM_IMMEDIATE,              ///< Immediate value

	M68K_AM_BRANCH_DISPLACEMENT,    ///< Address as displacement from (PC+2) used by branches
} m68k_address_mode;

/// Operand type for instruction's operands
typedef enum m68k_op_type {
	M68K_OP_INVALID = 0, ///< = CS_OP_INVALID (Uninitialized).
	M68K_OP_REG,         ///< = CS_OP_REG (Register operand).
	M68K_OP_IMM,         ///< = CS_OP_IMM (Immediate operand).
	M68K_OP_MEM,         ///< = CS_OP_MEM (Memory operand).
	M68K_OP_FP_SINGLE,   ///< single precision Floating-Point operand
	M68K_OP_FP_DOUBLE,   ///< double precision Floating-Point operand
	M68K_OP_REG_BITS,    ///< Register bits move
	M68K_OP_REG_PAIR,    ///< Register pair in the same op (upper 4 bits for first reg, lower for second)
	M68K_OP_BR_DISP,     ///< Branch displacement
} m68k_op_type;

/// Instruction's operand referring to memory
/// This is associated with M68K_OP_MEM operand type above
typedef struct m68k_op_mem {
	m68k_reg base_reg;      ///< base register (or M68K_REG_INVALID if irrelevant)
	m68k_reg index_reg;     ///< index register (or M68K_REG_INVALID if irrelevant)
	m68k_reg in_base_reg;   ///< indirect base register (or M68K_REG_INVALID if irrelevant)
	uint32_t in_disp; 	    ///< indirect displacement
	uint32_t out_disp;      ///< other displacement
	int16_t disp;	        ///< displacement value
	uint8_t scale;	        ///< scale for index register
	uint8_t bitfield;       ///< set to true if the two values below should be used
	uint8_t width;	        ///< used for bf* instructions
	uint8_t offset;	        ///< used for bf* instructions
	uint8_t index_size;     ///< 0 = w, 1 = l
} m68k_op_mem;

/// Operand type for instruction's operands
typedef enum m68k_op_br_disp_size {
	M68K_OP_BR_DISP_SIZE_INVALID = 0, ///< = CS_OP_INVALID (Uninitialized).
	M68K_OP_BR_DISP_SIZE_BYTE = 1,    ///< signed 8-bit displacement
	M68K_OP_BR_DISP_SIZE_WORD = 2,    ///< signed 16-bit displacement
	M68K_OP_BR_DISP_SIZE_LONG = 4,    ///< signed 32-bit displacement
} m68k_op_br_disp_size;

typedef struct m68k_op_br_disp {
	int32_t disp;	        ///< displacement value
	uint8_t disp_size;		///< Size from m68k_op_br_disp_size type above
} m68k_op_br_disp;

/// Register pair in one operand.
typedef struct cs_m68k_op_reg_pair {
	m68k_reg reg_0;
	m68k_reg reg_1;
} cs_m68k_op_reg_pair;

/// Instruction operand
typedef struct cs_m68k_op {
	union {
		uint64_t imm;               ///< immediate value for IMM operand
		double dimm; 		    ///< double imm
		float simm; 		    ///< float imm
		m68k_reg reg;		    ///< register value for REG operand
		cs_m68k_op_reg_pair reg_pair; ///< register pair in one operand
	};

	m68k_op_mem mem; 	    ///< data when operand is targeting memory
	m68k_op_br_disp br_disp; ///< data when operand is a branch displacement
	uint32_t register_bits; ///< register bits for movem etc. (always in d0-d7, a0-a7, fp0 - fp7 order)
	m68k_op_type type;
	m68k_address_mode address_mode;	///< M68K addressing mode for this op
} cs_m68k_op;

/// Operation size of the CPU instructions
typedef enum m68k_cpu_size {
	M68K_CPU_SIZE_NONE = 0,		///< unsized or unspecified
	M68K_CPU_SIZE_BYTE = 1,		///< 1 byte in size
	M68K_CPU_SIZE_WORD = 2,		///< 2 bytes in size
	M68K_CPU_SIZE_LONG = 4,		///< 4 bytes in size
} m68k_cpu_size;

/// Operation size of the FPU instructions (Notice that FPU instruction can also use CPU sizes if needed)
typedef enum m68k_fpu_size {
	M68K_FPU_SIZE_NONE = 0,		///< unsized like fsave/frestore
	M68K_FPU_SIZE_SINGLE = 4,		///< 4 byte in size (single float)
	M68K_FPU_SIZE_DOUBLE = 8,		///< 8 byte in size (double)
	M68K_FPU_SIZE_EXTENDED = 12,	///< 12 byte in size (extended real format)
} m68k_fpu_size;

/// Type of size that is being used for the current instruction
typedef enum m68k_size_type {
	M68K_SIZE_TYPE_INVALID = 0,

	M68K_SIZE_TYPE_CPU,
	M68K_SIZE_TYPE_FPU,
} m68k_size_type;

/// Operation size of the current instruction (NOT the actually size of instruction)
typedef struct m68k_op_size {
	m68k_size_type type;
	union {
		m68k_cpu_size cpu_size;
		m68k_fpu_size fpu_size;
	};
} m68k_op_size;

/// The M68K instruction and it's operands
typedef struct cs_m68k {
	// Number of operands of this instruction or 0 when instruction has no operand.
	cs_m68k_op operands[M68K_OPERAND_COUNT]; ///< operands for this instruction.
	m68k_op_size op_size;	///< size of data operand works on in bytes (.b, .w, .l, etc)
	uint8_t op_count; ///< number of operands for the instruction
} cs_m68k;

/// M68K instruction
typedef enum m68k_insn {
	M68K_INS_INVALID = 0,

	M68K_INS_ABCD,
	M68K_INS_ADD,
	M68K_INS_ADDA,
	M68K_INS_ADDI,
	M68K_INS_ADDQ,
	M68K_INS_ADDX,
	M68K_INS_AND,
	M68K_INS_ANDI,
	M68K_INS_ASL,
	M68K_INS_ASR,
	M68K_INS_BHS,
	M68K_INS_BLO,
	M68K_INS_BHI,
	M68K_INS_BLS,
	M68K_INS_BCC,
	M68K_INS_BCS,
	M68K_INS_BNE,
	M68K_INS_BEQ,
	M68K_INS_BVC,
	M68K_INS_BVS,
	M68K_INS_BPL,
	M68K_INS_BMI,
	M68K_INS_BGE,
	M68K_INS_BLT,
	M68K_INS_BGT,
	M68K_INS_BLE,
	M68K_INS_BRA,
	M68K_INS_BSR,
	M68K_INS_BCHG,
	M68K_INS_BCLR,
	M68K_INS_BSET,
	M68K_INS_BTST,
	M68K_INS_BFCHG,
	M68K_INS_BFCLR,
	M68K_INS_BFEXTS,
	M68K_INS_BFEXTU,
	M68K_INS_BFFFO,
	M68K_INS_BFINS,
	M68K_INS_BFSET,
	M68K_INS_BFTST,
	M68K_INS_BKPT,
	M68K_INS_CALLM,
	M68K_INS_CAS,
	M68K_INS_CAS2,
	M68K_INS_CHK,
	M68K_INS_CHK2,
	M68K_INS_CLR,
	M68K_INS_CMP,
	M68K_INS_CMPA,
	M68K_INS_CMPI,
	M68K_INS_CMPM,
	M68K_INS_CMP2,
	M68K_INS_CINVL,
	M68K_INS_CINVP,
	M68K_INS_CINVA,
	M68K_INS_CPUSHL,
	M68K_INS_CPUSHP,
	M68K_INS_CPUSHA,
	M68K_INS_DBT,
	M68K_INS_DBF,
	M68K_INS_DBHI,
	M68K_INS_DBLS,
	M68K_INS_DBCC,
	M68K_INS_DBCS,
	M68K_INS_DBNE,
	M68K_INS_DBEQ,
	M68K_INS_DBVC,
	M68K_INS_DBVS,
	M68K_INS_DBPL,
	M68K_INS_DBMI,
	M68K_INS_DBGE,
	M68K_INS_DBLT,
	M68K_INS_DBGT,
	M68K_INS_DBLE,
	M68K_INS_DBRA,
	M68K_INS_DIVS,
	M68K_INS_DIVSL,
	M68K_INS_DIVU,
	M68K_INS_DIVUL,
	M68K_INS_EOR,
	M68K_INS_EORI,
	M68K_INS_EXG,
	M68K_INS_EXT,
	M68K_INS_EXTB,
	M68K_INS_FABS,
	M68K_INS_FSABS,
	M68K_INS_FDABS,
	M68K_INS_FACOS,
	M68K_INS_FADD,
	M68K_INS_FSADD,
	M68K_INS_FDADD,
	M68K_INS_FASIN,
	M68K_INS_FATAN,
	M68K_INS_FATANH,
	M68K_INS_FBF,
	M68K_INS_FBEQ,
	M68K_INS_FBOGT,
	M68K_INS_FBOGE,
	M68K_INS_FBOLT,
	M68K_INS_FBOLE,
	M68K_INS_FBOGL,
	M68K_INS_FBOR,
	M68K_INS_FBUN,
	M68K_INS_FBUEQ,
	M68K_INS_FBUGT,
	M68K_INS_FBUGE,
	M68K_INS_FBULT,
	M68K_INS_FBULE,
	M68K_INS_FBNE,
	M68K_INS_FBT,
	M68K_INS_FBSF,
	M68K_INS_FBSEQ,
	M68K_INS_FBGT,
	M68K_INS_FBGE,
	M68K_INS_FBLT,
	M68K_INS_FBLE,
	M68K_INS_FBGL,
	M68K_INS_FBGLE,
	M68K_INS_FBNGLE,
	M68K_INS_FBNGL,
	M68K_INS_FBNLE,
	M68K_INS_FBNLT,
	M68K_INS_FBNGE,
	M68K_INS_FBNGT,
	M68K_INS_FBSNE,
	M68K_INS_FBST,
	M68K_INS_FCMP,
	M68K_INS_FCOS,
	M68K_INS_FCOSH,
	M68K_INS_FDBF,
	M68K_INS_FDBEQ,
	M68K_INS_FDBOGT,
	M68K_INS_FDBOGE,
	M68K_INS_FDBOLT,
	M68K_INS_FDBOLE,
	M68K_INS_FDBOGL,
	M68K_INS_FDBOR,
	M68K_INS_FDBUN,
	M68K_INS_FDBUEQ,
	M68K_INS_FDBUGT,
	M68K_INS_FDBUGE,
	M68K_INS_FDBULT,
	M68K_INS_FDBULE,
	M68K_INS_FDBNE,
	M68K_INS_FDBT,
	M68K_INS_FDBSF,
	M68K_INS_FDBSEQ,
	M68K_INS_FDBGT,
	M68K_INS_FDBGE,
	M68K_INS_FDBLT,
	M68K_INS_FDBLE,
	M68K_INS_FDBGL,
	M68K_INS_FDBGLE,
	M68K_INS_FDBNGLE,
	M68K_INS_FDBNGL,
	M68K_INS_FDBNLE,
	M68K_INS_FDBNLT,
	M68K_INS_FDBNGE,
	M68K_INS_FDBNGT,
	M68K_INS_FDBSNE,
	M68K_INS_FDBST,
	M68K_INS_FDIV,
	M68K_INS_FSDIV,
	M68K_INS_FDDIV,
	M68K_INS_FETOX,
	M68K_INS_FETOXM1,
	M68K_INS_FGETEXP,
	M68K_INS_FGETMAN,
	M68K_INS_FINT,
	M68K_INS_FINTRZ,
	M68K_INS_FLOG10,
	M68K_INS_FLOG2,
	M68K_INS_FLOGN,
	M68K_INS_FLOGNP1,
	M68K_INS_FMOD,
	M68K_INS_FMOVE,
	M68K_INS_FSMOVE,
	M68K_INS_FDMOVE,
	M68K_INS_FMOVECR,
	M68K_INS_FMOVEM,
	M68K_INS_FMUL,
	M68K_INS_FSMUL,
	M68K_INS_FDMUL,
	M68K_INS_FNEG,
	M68K_INS_FSNEG,
	M68K_INS_FDNEG,
	M68K_INS_FNOP,
	M68K_INS_FREM,
	M68K_INS_FRESTORE,
	M68K_INS_FSAVE,
	M68K_INS_FSCALE,
	M68K_INS_FSGLDIV,
	M68K_INS_FSGLMUL,
	M68K_INS_FSIN,
	M68K_INS_FSINCOS,
	M68K_INS_FSINH,
	M68K_INS_FSQRT,
	M68K_INS_FSSQRT,
	M68K_INS_FDSQRT,
	M68K_INS_FSF,
	M68K_INS_FSBEQ,
	M68K_INS_FSOGT,
	M68K_INS_FSOGE,
	M68K_INS_FSOLT,
	M68K_INS_FSOLE,
	M68K_INS_FSOGL,
	M68K_INS_FSOR,
	M68K_INS_FSUN,
	M68K_INS_FSUEQ,
	M68K_INS_FSUGT,
	M68K_INS_FSUGE,
	M68K_INS_FSULT,
	M68K_INS_FSULE,
	M68K_INS_FSNE,
	M68K_INS_FST,
	M68K_INS_FSSF,
	M68K_INS_FSSEQ,
	M68K_INS_FSGT,
	M68K_INS_FSGE,
	M68K_INS_FSLT,
	M68K_INS_FSLE,
	M68K_INS_FSGL,
	M68K_INS_FSGLE,
	M68K_INS_FSNGLE,
	M68K_INS_FSNGL,
	M68K_INS_FSNLE,
	M68K_INS_FSNLT,
	M68K_INS_FSNGE,
	M68K_INS_FSNGT,
	M68K_INS_FSSNE,
	M68K_INS_FSST,
	M68K_INS_FSUB,
	M68K_INS_FSSUB,
	M68K_INS_FDSUB,
	M68K_INS_FTAN,
	M68K_INS_FTANH,
	M68K_INS_FTENTOX,
	M68K_INS_FTRAPF,
	M68K_INS_FTRAPEQ,
	M68K_INS_FTRAPOGT,
	M68K_INS_FTRAPOGE,
	M68K_INS_FTRAPOLT,
	M68K_INS_FTRAPOLE,
	M68K_INS_FTRAPOGL,
	M68K_INS_FTRAPOR,
	M68K_INS_FTRAPUN,
	M68K_INS_FTRAPUEQ,
	M68K_INS_FTRAPUGT,
	M68K_INS_FTRAPUGE,
	M68K_INS_FTRAPULT,
	M68K_INS_FTRAPULE,
	M68K_INS_FTRAPNE,
	M68K_INS_FTRAPT,
	M68K_INS_FTRAPSF,
	M68K_INS_FTRAPSEQ,
	M68K_INS_FTRAPGT,
	M68K_INS_FTRAPGE,
	M68K_INS_FTRAPLT,
	M68K_INS_FTRAPLE,
	M68K_INS_FTRAPGL,
	M68K_INS_FTRAPGLE,
	M68K_INS_FTRAPNGLE,
	M68K_INS_FTRAPNGL,
	M68K_INS_FTRAPNLE,
	M68K_INS_FTRAPNLT,
	M68K_INS_FTRAPNGE,
	M68K_INS_FTRAPNGT,
	M68K_INS_FTRAPSNE,
	M68K_INS_FTRAPST,
	M68K_INS_FTST,
	M68K_INS_FTWOTOX,
	M68K_INS_HALT,
	M68K_INS_ILLEGAL,
	M68K_INS_JMP,
	M68K_INS_JSR,
	M68K_INS_LEA,
	M68K_INS_LINK,
	M68K_INS_LPSTOP,
	M68K_INS_LSL,
	M68K_INS_LSR,
	M68K_INS_MOVE,
	M68K_INS_MOVEA,
	M68K_INS_MOVEC,
	M68K_INS_MOVEM,
	M68K_INS_MOVEP,
	M68K_INS_MOVEQ,
	M68K_INS_MOVES,
	M68K_INS_MOVE16,
	M68K_INS_MULS,
	M68K_INS_MULU,
	M68K_INS_NBCD,
	M68K_INS_NEG,
	M68K_INS_NEGX,
	M68K_INS_NOP,
	M68K_INS_NOT,
	M68K_INS_OR,
	M68K_INS_ORI,
	M68K_INS_PACK,
	M68K_INS_PEA,
	M68K_INS_PFLUSH,
	M68K_INS_PFLUSHA,
	M68K_INS_PFLUSHAN,
	M68K_INS_PFLUSHN,
	M68K_INS_PLOADR,
	M68K_INS_PLOADW,
	M68K_INS_PLPAR,
	M68K_INS_PLPAW,
	M68K_INS_PMOVE,
	M68K_INS_PMOVEFD,
	M68K_INS_PTESTR,
	M68K_INS_PTESTW,
	M68K_INS_PULSE,
	M68K_INS_REMS,
	M68K_INS_REMU,
	M68K_INS_RESET,
	M68K_INS_ROL,
	M68K_INS_ROR,
	M68K_INS_ROXL,
	M68K_INS_ROXR,
	M68K_INS_RTD,
	M68K_INS_RTE,
	M68K_INS_RTM,
	M68K_INS_RTR,
	M68K_INS_RTS,
	M68K_INS_SBCD,
	M68K_INS_ST,
	M68K_INS_SF,
	M68K_INS_SHI,
	M68K_INS_SLS,
	M68K_INS_SCC,
	M68K_INS_SHS,
	M68K_INS_SCS,
	M68K_INS_SLO,
	M68K_INS_SNE,
	M68K_INS_SEQ,
	M68K_INS_SVC,
	M68K_INS_SVS,
	M68K_INS_SPL,
	M68K_INS_SMI,
	M68K_INS_SGE,
	M68K_INS_SLT,
	M68K_INS_SGT,
	M68K_INS_SLE,
	M68K_INS_STOP,
	M68K_INS_SUB,
	M68K_INS_SUBA,
	M68K_INS_SUBI,
	M68K_INS_SUBQ,
	M68K_INS_SUBX,
	M68K_INS_SWAP,
	M68K_INS_TAS,
	M68K_INS_TRAP,
	M68K_INS_TRAPV,
	M68K_INS_TRAPT,
	M68K_INS_TRAPF,
	M68K_INS_TRAPHI,
	M68K_INS_TRAPLS,
	M68K_INS_TRAPCC,
	M68K_INS_TRAPHS,
	M68K_INS_TRAPCS,
	M68K_INS_TRAPLO,
	M68K_INS_TRAPNE,
	M68K_INS_TRAPEQ,
	M68K_INS_TRAPVC,
	M68K_INS_TRAPVS,
	M68K_INS_TRAPPL,
	M68K_INS_TRAPMI,
	M68K_INS_TRAPGE,
	M68K_INS_TRAPLT,
	M68K_INS_TRAPGT,
	M68K_INS_TRAPLE,
	M68K_INS_TST,
	M68K_INS_UNLK,
	M68K_INS_UNPK,
	M68K_INS_ENDING,   // <-- mark the end of the list of instructions
} m68k_insn;

/// Group of M68K instructions
typedef enum m68k_group_type {
	M68K_GRP_INVALID = 0,  ///< CS_GRUP_INVALID
	M68K_GRP_JUMP,  ///< = CS_GRP_JUMP
	M68K_GRP_RET = 3,  ///< = CS_GRP_RET
	M68K_GRP_IRET = 5, ///< = CS_GRP_IRET
	M68K_GRP_BRANCH_RELATIVE = 7, ///< = CS_GRP_BRANCH_RELATIVE

	M68K_GRP_ENDING,// <-- mark the end of the list of groups
} m68k_group_type;

#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/include/capstone/capstone/mips.h`:

```h
#ifndef CAPSTONE_MIPS_H
#define CAPSTONE_MIPS_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2015 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

// GCC MIPS toolchain has a default macro called "mips" which breaks
// compilation
#undef mips

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

/// Operand type for instruction's operands
typedef enum mips_op_type {
	MIPS_OP_INVALID = 0, ///< = CS_OP_INVALID (Uninitialized).
	MIPS_OP_REG, ///< = CS_OP_REG (Register operand).
	MIPS_OP_IMM, ///< = CS_OP_IMM (Immediate operand).
	MIPS_OP_MEM, ///< = CS_OP_MEM (Memory operand).
} mips_op_type;

/// MIPS registers
typedef enum mips_reg {
	MIPS_REG_INVALID = 0,
	// General purpose registers
	MIPS_REG_PC,

	MIPS_REG_0,
	MIPS_REG_1,
	MIPS_REG_2,
	MIPS_REG_3,
	MIPS_REG_4,
	MIPS_REG_5,
	MIPS_REG_6,
	MIPS_REG_7,
	MIPS_REG_8,
	MIPS_REG_9,
	MIPS_REG_10,
	MIPS_REG_11,
	MIPS_REG_12,
	MIPS_REG_13,
	MIPS_REG_14,
	MIPS_REG_15,
	MIPS_REG_16,
	MIPS_REG_17,
	MIPS_REG_18,
	MIPS_REG_19,
	MIPS_REG_20,
	MIPS_REG_21,
	MIPS_REG_22,
	MIPS_REG_23,
	MIPS_REG_24,
	MIPS_REG_25,
	MIPS_REG_26,
	MIPS_REG_27,
	MIPS_REG_28,
	MIPS_REG_29,
	MIPS_REG_30,
	MIPS_REG_31,

	// DSP registers
	MIPS_REG_DSPCCOND,
	MIPS_REG_DSPCARRY,
	MIPS_REG_DSPEFI,
	MIPS_REG_DSPOUTFLAG,
	MIPS_REG_DSPOUTFLAG16_19,
	MIPS_REG_DSPOUTFLAG20,
	MIPS_REG_DSPOUTFLAG21,
	MIPS_REG_DSPOUTFLAG22,
	MIPS_REG_DSPOUTFLAG23,
	MIPS_REG_DSPPOS,
	MIPS_REG_DSPSCOUNT,

	// ACC registers
	MIPS_REG_AC0,
	MIPS_REG_AC1,
	MIPS_REG_AC2,
	MIPS_REG_AC3,

	// COP registers
	MIPS_REG_CC0,
	MIPS_REG_CC1,
	MIPS_REG_CC2,
	MIPS_REG_CC3,
	MIPS_REG_CC4,
	MIPS_REG_CC5,
	MIPS_REG_CC6,
	MIPS_REG_CC7,

	// FPU registers
	MIPS_REG_F0,
	MIPS_REG_F1,
	MIPS_REG_F2,
	MIPS_REG_F3,
	MIPS_REG_F4,
	MIPS_REG_F5,
	MIPS_REG_F6,
	MIPS_REG_F7,
	MIPS_REG_F8,
	MIPS_REG_F9,
	MIPS_REG_F10,
	MIPS_REG_F11,
	MIPS_REG_F12,
	MIPS_REG_F13,
	MIPS_REG_F14,
	MIPS_REG_F15,
	MIPS_REG_F16,
	MIPS_REG_F17,
	MIPS_REG_F18,
	MIPS_REG_F19,
	MIPS_REG_F20,
	MIPS_REG_F21,
	MIPS_REG_F22,
	MIPS_REG_F23,
	MIPS_REG_F24,
	MIPS_REG_F25,
	MIPS_REG_F26,
	MIPS_REG_F27,
	MIPS_REG_F28,
	MIPS_REG_F29,
	MIPS_REG_F30,
	MIPS_REG_F31,

	MIPS_REG_FCC0,
	MIPS_REG_FCC1,
	MIPS_REG_FCC2,
	MIPS_REG_FCC3,
	MIPS_REG_FCC4,
	MIPS_REG_FCC5,
	MIPS_REG_FCC6,
	MIPS_REG_FCC7,

	// AFPR128
	MIPS_REG_W0,
	MIPS_REG_W1,
	MIPS_REG_W2,
	MIPS_REG_W3,
	MIPS_REG_W4,
	MIPS_REG_W5,
	MIPS_REG_W6,
	MIPS_REG_W7,
	MIPS_REG_W8,
	MIPS_REG_W9,
	MIPS_REG_W10,
	MIPS_REG_W11,
	MIPS_REG_W12,
	MIPS_REG_W13,
	MIPS_REG_W14,
	MIPS_REG_W15,
	MIPS_REG_W16,
	MIPS_REG_W17,
	MIPS_REG_W18,
	MIPS_REG_W19,
	MIPS_REG_W20,
	MIPS_REG_W21,
	MIPS_REG_W22,
	MIPS_REG_W23,
	MIPS_REG_W24,
	MIPS_REG_W25,
	MIPS_REG_W26,
	MIPS_REG_W27,
	MIPS_REG_W28,
	MIPS_REG_W29,
	MIPS_REG_W30,
	MIPS_REG_W31,

	MIPS_REG_HI,
	MIPS_REG_LO,

	MIPS_REG_P0,
	MIPS_REG_P1,
	MIPS_REG_P2,

	MIPS_REG_MPL0,
	MIPS_REG_MPL1,
	MIPS_REG_MPL2,

	MIPS_REG_ENDING,	// <-- mark the end of the list or registers

	// alias registers
	MIPS_REG_ZERO = MIPS_REG_0,
	MIPS_REG_AT = MIPS_REG_1,
	MIPS_REG_V0 = MIPS_REG_2,
	MIPS_REG_V1 = MIPS_REG_3,
	MIPS_REG_A0 = MIPS_REG_4,
	MIPS_REG_A1 = MIPS_REG_5,
	MIPS_REG_A2 = MIPS_REG_6,
	MIPS_REG_A3 = MIPS_REG_7,
	MIPS_REG_T0 = MIPS_REG_8,
	MIPS_REG_T1 = MIPS_REG_9,
	MIPS_REG_T2 = MIPS_REG_10,
	MIPS_REG_T3 = MIPS_REG_11,
	MIPS_REG_T4 = MIPS_REG_12,
	MIPS_REG_T5 = MIPS_REG_13,
	MIPS_REG_T6 = MIPS_REG_14,
	MIPS_REG_T7 = MIPS_REG_15,
	MIPS_REG_S0 = MIPS_REG_16,
	MIPS_REG_S1 = MIPS_REG_17,
	MIPS_REG_S2 = MIPS_REG_18,
	MIPS_REG_S3 = MIPS_REG_19,
	MIPS_REG_S4 = MIPS_REG_20,
	MIPS_REG_S5 = MIPS_REG_21,
	MIPS_REG_S6 = MIPS_REG_22,
	MIPS_REG_S7 = MIPS_REG_23,
	MIPS_REG_T8 = MIPS_REG_24,
	MIPS_REG_T9 = MIPS_REG_25,
	MIPS_REG_K0 = MIPS_REG_26,
	MIPS_REG_K1 = MIPS_REG_27,
	MIPS_REG_GP = MIPS_REG_28,
	MIPS_REG_SP = MIPS_REG_29,
	MIPS_REG_FP = MIPS_REG_30, MIPS_REG_S8 = MIPS_REG_30,
	MIPS_REG_RA = MIPS_REG_31,

	MIPS_REG_HI0 = MIPS_REG_AC0,
	MIPS_REG_HI1 = MIPS_REG_AC1,
	MIPS_REG_HI2 = MIPS_REG_AC2,
	MIPS_REG_HI3 = MIPS_REG_AC3,

	MIPS_REG_LO0 = MIPS_REG_HI0,
	MIPS_REG_LO1 = MIPS_REG_HI1,
	MIPS_REG_LO2 = MIPS_REG_HI2,
	MIPS_REG_LO3 = MIPS_REG_HI3,
} mips_reg;

/// Instruction's operand referring to memory
/// This is associated with MIPS_OP_MEM operand type above
typedef struct mips_op_mem {
	mips_reg base;	///< base register
	int64_t disp;	///< displacement/offset value
} mips_op_mem;

/// Instruction operand
typedef struct cs_mips_op {
	mips_op_type type;	///< operand type
	union {
		mips_reg reg;		///< register value for REG operand
		int64_t imm;		///< immediate value for IMM operand
		mips_op_mem mem;	///< base/index/scale/disp value for MEM operand
	};
} cs_mips_op;

/// Instruction structure
typedef struct cs_mips {
	/// Number of operands of this instruction,
	/// or 0 when instruction has no operand.
	uint8_t op_count;
	cs_mips_op operands[10]; ///< operands for this instruction.
} cs_mips;

/// MIPS instruction
typedef enum mips_insn {
	MIPS_INS_INVALID = 0,

	MIPS_INS_ABSQ_S,
	MIPS_INS_ADD,
	MIPS_INS_ADDIUPC,
	MIPS_INS_ADDIUR1SP,
	MIPS_INS_ADDIUR2,
	MIPS_INS_ADDIUS5,
	MIPS_INS_ADDIUSP,
	MIPS_INS_ADDQH,
	MIPS_INS_ADDQH_R,
	MIPS_INS_ADDQ,
	MIPS_INS_ADDQ_S,
	MIPS_INS_ADDSC,
	MIPS_INS_ADDS_A,
	MIPS_INS_ADDS_S,
	MIPS_INS_ADDS_U,
	MIPS_INS_ADDU16,
	MIPS_INS_ADDUH,
	MIPS_INS_ADDUH_R,
	MIPS_INS_ADDU,
	MIPS_INS_ADDU_S,
	MIPS_INS_ADDVI,
	MIPS_INS_ADDV,
	MIPS_INS_ADDWC,
	MIPS_INS_ADD_A,
	MIPS_INS_ADDI,
	MIPS_INS_ADDIU,
	MIPS_INS_ALIGN,
	MIPS_INS_ALUIPC,
	MIPS_INS_AND,
	MIPS_INS_AND16,
	MIPS_INS_ANDI16,
	MIPS_INS_ANDI,
	MIPS_INS_APPEND,
	MIPS_INS_ASUB_S,
	MIPS_INS_ASUB_U,
	MIPS_INS_AUI,
	MIPS_INS_AUIPC,
	MIPS_INS_AVER_S,
	MIPS_INS_AVER_U,
	MIPS_INS_AVE_S,
	MIPS_INS_AVE_U,
	MIPS_INS_B16,
	MIPS_INS_BADDU,
	MIPS_INS_BAL,
	MIPS_INS_BALC,
	MIPS_INS_BALIGN,
	MIPS_INS_BBIT0,
	MIPS_INS_BBIT032,
	MIPS_INS_BBIT1,
	MIPS_INS_BBIT132,
	MIPS_INS_BC,
	MIPS_INS_BC0F,
	MIPS_INS_BC0FL,
	MIPS_INS_BC0T,
	MIPS_INS_BC0TL,
	MIPS_INS_BC1EQZ,
	MIPS_INS_BC1F,
	MIPS_INS_BC1FL,
	MIPS_INS_BC1NEZ,
	MIPS_INS_BC1T,
	MIPS_INS_BC1TL,
	MIPS_INS_BC2EQZ,
	MIPS_INS_BC2F,
	MIPS_INS_BC2FL,
	MIPS_INS_BC2NEZ,
	MIPS_INS_BC2T,
	MIPS_INS_BC2TL,
	MIPS_INS_BC3F,
	MIPS_INS_BC3FL,
	MIPS_INS_BC3T,
	MIPS_INS_BC3TL,
	MIPS_INS_BCLRI,
	MIPS_INS_BCLR,
	MIPS_INS_BEQ,
	MIPS_INS_BEQC,
	MIPS_INS_BEQL,
	MIPS_INS_BEQZ16,
	MIPS_INS_BEQZALC,
	MIPS_INS_BEQZC,
	MIPS_INS_BGEC,
	MIPS_INS_BGEUC,
	MIPS_INS_BGEZ,
	MIPS_INS_BGEZAL,
	MIPS_INS_BGEZALC,
	MIPS_INS_BGEZALL,
	MIPS_INS_BGEZALS,
	MIPS_INS_BGEZC,
	MIPS_INS_BGEZL,
	MIPS_INS_BGTZ,
	MIPS_INS_BGTZALC,
	MIPS_INS_BGTZC,
	MIPS_INS_BGTZL,
	MIPS_INS_BINSLI,
	MIPS_INS_BINSL,
	MIPS_INS_BINSRI,
	MIPS_INS_BINSR,
	MIPS_INS_BITREV,
	MIPS_INS_BITSWAP,
	MIPS_INS_BLEZ,
	MIPS_INS_BLEZALC,
	MIPS_INS_BLEZC,
	MIPS_INS_BLEZL,
	MIPS_INS_BLTC,
	MIPS_INS_BLTUC,
	MIPS_INS_BLTZ,
	MIPS_INS_BLTZAL,
	MIPS_INS_BLTZALC,
	MIPS_INS_BLTZALL,
	MIPS_INS_BLTZALS,
	MIPS_INS_BLTZC,
	MIPS_INS_BLTZL,
	MIPS_INS_BMNZI,
	MIPS_INS_BMNZ,
	MIPS_INS_BMZI,
	MIPS_INS_BMZ,
	MIPS_INS_BNE,
	MIPS_INS_BNEC,
	MIPS_INS_BNEGI,
	MIPS_INS_BNEG,
	MIPS_INS_BNEL,
	MIPS_INS_BNEZ16,
	MIPS_INS_BNEZALC,
	MIPS_INS_BNEZC,
	MIPS_INS_BNVC,
	MIPS_INS_BNZ,
	MIPS_INS_BOVC,
	MIPS_INS_BPOSGE32,
	MIPS_INS_BREAK,
	MIPS_INS_BREAK16,
	MIPS_INS_BSELI,
	MIPS_INS_BSEL,
	MIPS_INS_BSETI,
	MIPS_INS_BSET,
	MIPS_INS_BZ,
	MIPS_INS_BEQZ,
	MIPS_INS_B,
	MIPS_INS_BNEZ,
	MIPS_INS_BTEQZ,
	MIPS_INS_BTNEZ,
	MIPS_INS_CACHE,
	MIPS_INS_CEIL,
	MIPS_INS_CEQI,
	MIPS_INS_CEQ,
	MIPS_INS_CFC1,
	MIPS_INS_CFCMSA,
	MIPS_INS_CINS,
	MIPS_INS_CINS32,
	MIPS_INS_CLASS,
	MIPS_INS_CLEI_S,
	MIPS_INS_CLEI_U,
	MIPS_INS_CLE_S,
	MIPS_INS_CLE_U,
	MIPS_INS_CLO,
	MIPS_INS_CLTI_S,
	MIPS_INS_CLTI_U,
	MIPS_INS_CLT_S,
	MIPS_INS_CLT_U,
	MIPS_INS_CLZ,
	MIPS_INS_CMPGDU,
	MIPS_INS_CMPGU,
	MIPS_INS_CMPU,
	MIPS_INS_CMP,
	MIPS_INS_COPY_S,
	MIPS_INS_COPY_U,
	MIPS_INS_CTC1,
	MIPS_INS_CTCMSA,
	MIPS_INS_CVT,
	MIPS_INS_C,
	MIPS_INS_CMPI,
	MIPS_INS_DADD,
	MIPS_INS_DADDI,
	MIPS_INS_DADDIU,
	MIPS_INS_DADDU,
	MIPS_INS_DAHI,
	MIPS_INS_DALIGN,
	MIPS_INS_DATI,
	MIPS_INS_DAUI,
	MIPS_INS_DBITSWAP,
	MIPS_INS_DCLO,
	MIPS_INS_DCLZ,
	MIPS_INS_DDIV,
	MIPS_INS_DDIVU,
	MIPS_INS_DERET,
	MIPS_INS_DEXT,
	MIPS_INS_DEXTM,
	MIPS_INS_DEXTU,
	MIPS_INS_DI,
	MIPS_INS_DINS,
	MIPS_INS_DINSM,
	MIPS_INS_DINSU,
	MIPS_INS_DIV,
	MIPS_INS_DIVU,
	MIPS_INS_DIV_S,
	MIPS_INS_DIV_U,
	MIPS_INS_DLSA,
	MIPS_INS_DMFC0,
	MIPS_INS_DMFC1,
	MIPS_INS_DMFC2,
	MIPS_INS_DMOD,
	MIPS_INS_DMODU,
	MIPS_INS_DMTC0,
	MIPS_INS_DMTC1,
	MIPS_INS_DMTC2,
	MIPS_INS_DMUH,
	MIPS_INS_DMUHU,
	MIPS_INS_DMUL,
	MIPS_INS_DMULT,
	MIPS_INS_DMULTU,
	MIPS_INS_DMULU,
	MIPS_INS_DOTP_S,
	MIPS_INS_DOTP_U,
	MIPS_INS_DPADD_S,
	MIPS_INS_DPADD_U,
	MIPS_INS_DPAQX_SA,
	MIPS_INS_DPAQX_S,
	MIPS_INS_DPAQ_SA,
	MIPS_INS_DPAQ_S,
	MIPS_INS_DPAU,
	MIPS_INS_DPAX,
	MIPS_INS_DPA,
	MIPS_INS_DPOP,
	MIPS_INS_DPSQX_SA,
	MIPS_INS_DPSQX_S,
	MIPS_INS_DPSQ_SA,
	MIPS_INS_DPSQ_S,
	MIPS_INS_DPSUB_S,
	MIPS_INS_DPSUB_U,
	MIPS_INS_DPSU,
	MIPS_INS_DPSX,
	MIPS_INS_DPS,
	MIPS_INS_DROTR,
	MIPS_INS_DROTR32,
	MIPS_INS_DROTRV,
	MIPS_INS_DSBH,
	MIPS_INS_DSHD,
	MIPS_INS_DSLL,
	MIPS_INS_DSLL32,
	MIPS_INS_DSLLV,
	MIPS_INS_DSRA,
	MIPS_INS_DSRA32,
	MIPS_INS_DSRAV,
	MIPS_INS_DSRL,
	MIPS_INS_DSRL32,
	MIPS_INS_DSRLV,
	MIPS_INS_DSUB,
	MIPS_INS_DSUBU,
	MIPS_INS_EHB,
	MIPS_INS_EI,
	MIPS_INS_ERET,
	MIPS_INS_EXT,
	MIPS_INS_EXTP,
	MIPS_INS_EXTPDP,
	MIPS_INS_EXTPDPV,
	MIPS_INS_EXTPV,
	MIPS_INS_EXTRV_RS,
	MIPS_INS_EXTRV_R,
	MIPS_INS_EXTRV_S,
	MIPS_INS_EXTRV,
	MIPS_INS_EXTR_RS,
	MIPS_INS_EXTR_R,
	MIPS_INS_EXTR_S,
	MIPS_INS_EXTR,
	MIPS_INS_EXTS,
	MIPS_INS_EXTS32,
	MIPS_INS_ABS,
	MIPS_INS_FADD,
	MIPS_INS_FCAF,
	MIPS_INS_FCEQ,
	MIPS_INS_FCLASS,
	MIPS_INS_FCLE,
	MIPS_INS_FCLT,
	MIPS_INS_FCNE,
	MIPS_INS_FCOR,
	MIPS_INS_FCUEQ,
	MIPS_INS_FCULE,
	MIPS_INS_FCULT,
	MIPS_INS_FCUNE,
	MIPS_INS_FCUN,
	MIPS_INS_FDIV,
	MIPS_INS_FEXDO,
	MIPS_INS_FEXP2,
	MIPS_INS_FEXUPL,
	MIPS_INS_FEXUPR,
	MIPS_INS_FFINT_S,
	MIPS_INS_FFINT_U,
	MIPS_INS_FFQL,
	MIPS_INS_FFQR,
	MIPS_INS_FILL,
	MIPS_INS_FLOG2,
	MIPS_INS_FLOOR,
	MIPS_INS_FMADD,
	MIPS_INS_FMAX_A,
	MIPS_INS_FMAX,
	MIPS_INS_FMIN_A,
	MIPS_INS_FMIN,
	MIPS_INS_MOV,
	MIPS_INS_FMSUB,
	MIPS_INS_FMUL,
	MIPS_INS_MUL,
	MIPS_INS_NEG,
	MIPS_INS_FRCP,
	MIPS_INS_FRINT,
	MIPS_INS_FRSQRT,
	MIPS_INS_FSAF,
	MIPS_INS_FSEQ,
	MIPS_INS_FSLE,
	MIPS_INS_FSLT,
	MIPS_INS_FSNE,
	MIPS_INS_FSOR,
	MIPS_INS_FSQRT,
	MIPS_INS_SQRT,
	MIPS_INS_FSUB,
	MIPS_INS_SUB,
	MIPS_INS_FSUEQ,
	MIPS_INS_FSULE,
	MIPS_INS_FSULT,
	MIPS_INS_FSUNE,
	MIPS_INS_FSUN,
	MIPS_INS_FTINT_S,
	MIPS_INS_FTINT_U,
	MIPS_INS_FTQ,
	MIPS_INS_FTRUNC_S,
	MIPS_INS_FTRUNC_U,
	MIPS_INS_HADD_S,
	MIPS_INS_HADD_U,
	MIPS_INS_HSUB_S,
	MIPS_INS_HSUB_U,
	MIPS_INS_ILVEV,
	MIPS_INS_ILVL,
	MIPS_INS_ILVOD,
	MIPS_INS_ILVR,
	MIPS_INS_INS,
	MIPS_INS_INSERT,
	MIPS_INS_INSV,
	MIPS_INS_INSVE,
	MIPS_INS_J,
	MIPS_INS_JAL,
	MIPS_INS_JALR,
	MIPS_INS_JALRS16,
	MIPS_INS_JALRS,
	MIPS_INS_JALS,
	MIPS_INS_JALX,
	MIPS_INS_JIALC,
	MIPS_INS_JIC,
	MIPS_INS_JR,
	MIPS_INS_JR16,
	MIPS_INS_JRADDIUSP,
	MIPS_INS_JRC,
	MIPS_INS_JALRC,
	MIPS_INS_LB,
	MIPS_INS_LBU16,
	MIPS_INS_LBUX,
	MIPS_INS_LBU,
	MIPS_INS_LD,
	MIPS_INS_LDC1,
	MIPS_INS_LDC2,
	MIPS_INS_LDC3,
	MIPS_INS_LDI,
	MIPS_INS_LDL,
	MIPS_INS_LDPC,
	MIPS_INS_LDR,
	MIPS_INS_LDXC1,
	MIPS_INS_LH,
	MIPS_INS_LHU16,
	MIPS_INS_LHX,
	MIPS_INS_LHU,
	MIPS_INS_LI16,
	MIPS_INS_LL,
	MIPS_INS_LLD,
	MIPS_INS_LSA,
	MIPS_INS_LUXC1,
	MIPS_INS_LUI,
	MIPS_INS_LW,
	MIPS_INS_LW16,
	MIPS_INS_LWC1,
	MIPS_INS_LWC2,
	MIPS_INS_LWC3,
	MIPS_INS_LWL,
	MIPS_INS_LWM16,
	MIPS_INS_LWM32,
	MIPS_INS_LWPC,
	MIPS_INS_LWP,
	MIPS_INS_LWR,
	MIPS_INS_LWUPC,
	MIPS_INS_LWU,
	MIPS_INS_LWX,
	MIPS_INS_LWXC1,
	MIPS_INS_LWXS,
	MIPS_INS_LI,
	MIPS_INS_MADD,
	MIPS_INS_MADDF,
	MIPS_INS_MADDR_Q,
	MIPS_INS_MADDU,
	MIPS_INS_MADDV,
	MIPS_INS_MADD_Q,
	MIPS_INS_MAQ_SA,
	MIPS_INS_MAQ_S,
	MIPS_INS_MAXA,
	MIPS_INS_MAXI_S,
	MIPS_INS_MAXI_U,
	MIPS_INS_MAX_A,
	MIPS_INS_MAX,
	MIPS_INS_MAX_S,
	MIPS_INS_MAX_U,
	MIPS_INS_MFC0,
	MIPS_INS_MFC1,
	MIPS_INS_MFC2,
	MIPS_INS_MFHC1,
	MIPS_INS_MFHI,
	MIPS_INS_MFLO,
	MIPS_INS_MINA,
	MIPS_INS_MINI_S,
	MIPS_INS_MINI_U,
	MIPS_INS_MIN_A,
	MIPS_INS_MIN,
	MIPS_INS_MIN_S,
	MIPS_INS_MIN_U,
	MIPS_INS_MOD,
	MIPS_INS_MODSUB,
	MIPS_INS_MODU,
	MIPS_INS_MOD_S,
	MIPS_INS_MOD_U,
	MIPS_INS_MOVE,
	MIPS_INS_MOVEP,
	MIPS_INS_MOVF,
	MIPS_INS_MOVN,
	MIPS_INS_MOVT,
	MIPS_INS_MOVZ,
	MIPS_INS_MSUB,
	MIPS_INS_MSUBF,
	MIPS_INS_MSUBR_Q,
	MIPS_INS_MSUBU,
	MIPS_INS_MSUBV,
	MIPS_INS_MSUB_Q,
	MIPS_INS_MTC0,
	MIPS_INS_MTC1,
	MIPS_INS_MTC2,
	MIPS_INS_MTHC1,
	MIPS_INS_MTHI,
	MIPS_INS_MTHLIP,
	MIPS_INS_MTLO,
	MIPS_INS_MTM0,
	MIPS_INS_MTM1,
	MIPS_INS_MTM2,
	MIPS_INS_MTP0,
	MIPS_INS_MTP1,
	MIPS_INS_MTP2,
	MIPS_INS_MUH,
	MIPS_INS_MUHU,
	MIPS_INS_MULEQ_S,
	MIPS_INS_MULEU_S,
	MIPS_INS_MULQ_RS,
	MIPS_INS_MULQ_S,
	MIPS_INS_MULR_Q,
	MIPS_INS_MULSAQ_S,
	MIPS_INS_MULSA,
	MIPS_INS_MULT,
	MIPS_INS_MULTU,
	MIPS_INS_MULU,
	MIPS_INS_MULV,
	MIPS_INS_MUL_Q,
	MIPS_INS_MUL_S,
	MIPS_INS_NLOC,
	MIPS_INS_NLZC,
	MIPS_INS_NMADD,
	MIPS_INS_NMSUB,
	MIPS_INS_NOR,
	MIPS_INS_NORI,
	MIPS_INS_NOT16,
	MIPS_INS_NOT,
	MIPS_INS_OR,
	MIPS_INS_OR16,
	MIPS_INS_ORI,
	MIPS_INS_PACKRL,
	MIPS_INS_PAUSE,
	MIPS_INS_PCKEV,
	MIPS_INS_PCKOD,
	MIPS_INS_PCNT,
	MIPS_INS_PICK,
	MIPS_INS_POP,
	MIPS_INS_PRECEQU,
	MIPS_INS_PRECEQ,
	MIPS_INS_PRECEU,
	MIPS_INS_PRECRQU_S,
	MIPS_INS_PRECRQ,
	MIPS_INS_PRECRQ_RS,
	MIPS_INS_PRECR,
	MIPS_INS_PRECR_SRA,
	MIPS_INS_PRECR_SRA_R,
	MIPS_INS_PREF,
	MIPS_INS_PREPEND,
	MIPS_INS_RADDU,
	MIPS_INS_RDDSP,
	MIPS_INS_RDHWR,
	MIPS_INS_REPLV,
	MIPS_INS_REPL,
	MIPS_INS_RINT,
	MIPS_INS_ROTR,
	MIPS_INS_ROTRV,
	MIPS_INS_ROUND,
	MIPS_INS_SAT_S,
	MIPS_INS_SAT_U,
	MIPS_INS_SB,
	MIPS_INS_SB16,
	MIPS_INS_SC,
	MIPS_INS_SCD,
	MIPS_INS_SD,
	MIPS_INS_SDBBP,
	MIPS_INS_SDBBP16,
	MIPS_INS_SDC1,
	MIPS_INS_SDC2,
	MIPS_INS_SDC3,
	MIPS_INS_SDL,
	MIPS_INS_SDR,
	MIPS_INS_SDXC1,
	MIPS_INS_SEB,
	MIPS_INS_SEH,
	MIPS_INS_SELEQZ,
	MIPS_INS_SELNEZ,
	MIPS_INS_SEL,
	MIPS_INS_SEQ,
	MIPS_INS_SEQI,
	MIPS_INS_SH,
	MIPS_INS_SH16,
	MIPS_INS_SHF,
	MIPS_INS_SHILO,
	MIPS_INS_SHILOV,
	MIPS_INS_SHLLV,
	MIPS_INS_SHLLV_S,
	MIPS_INS_SHLL,
	MIPS_INS_SHLL_S,
	MIPS_INS_SHRAV,
	MIPS_INS_SHRAV_R,
	MIPS_INS_SHRA,
	MIPS_INS_SHRA_R,
	MIPS_INS_SHRLV,
	MIPS_INS_SHRL,
	MIPS_INS_SLDI,
	MIPS_INS_SLD,
	MIPS_INS_SLL,
	MIPS_INS_SLL16,
	MIPS_INS_SLLI,
	MIPS_INS_SLLV,
	MIPS_INS_SLT,
	MIPS_INS_SLTI,
	MIPS_INS_SLTIU,
	MIPS_INS_SLTU,
	MIPS_INS_SNE,
	MIPS_INS_SNEI,
	MIPS_INS_SPLATI,
	MIPS_INS_SPLAT,
	MIPS_INS_SRA,
	MIPS_INS_SRAI,
	MIPS_INS_SRARI,
	MIPS_INS_SRAR,
	MIPS_INS_SRAV,
	MIPS_INS_SRL,
	MIPS_INS_SRL16,
	MIPS_INS_SRLI,
	MIPS_INS_SRLRI,
	MIPS_INS_SRLR,
	MIPS_INS_SRLV,
	MIPS_INS_SSNOP,
	MIPS_INS_ST,
	MIPS_INS_SUBQH,
	MIPS_INS_SUBQH_R,
	MIPS_INS_SUBQ,
	MIPS_INS_SUBQ_S,
	MIPS_INS_SUBSUS_U,
	MIPS_INS_SUBSUU_S,
	MIPS_INS_SUBS_S,
	MIPS_INS_SUBS_U,
	MIPS_INS_SUBU16,
	MIPS_INS_SUBUH,
	MIPS_INS_SUBUH_R,
	MIPS_INS_SUBU,
	MIPS_INS_SUBU_S,
	MIPS_INS_SUBVI,
	MIPS_INS_SUBV,
	MIPS_INS_SUXC1,
	MIPS_INS_SW,
	MIPS_INS_SW16,
	MIPS_INS_SWC1,
	MIPS_INS_SWC2,
	MIPS_INS_SWC3,
	MIPS_INS_SWL,
	MIPS_INS_SWM16,
	MIPS_INS_SWM32,
	MIPS_INS_SWP,
	MIPS_INS_SWR,
	MIPS_INS_SWXC1,
	MIPS_INS_SYNC,
	MIPS_INS_SYNCI,
	MIPS_INS_SYSCALL,
	MIPS_INS_TEQ,
	MIPS_INS_TEQI,
	MIPS_INS_TGE,
	MIPS_INS_TGEI,
	MIPS_INS_TGEIU,
	MIPS_INS_TGEU,
	MIPS_INS_TLBP,
	MIPS_INS_TLBR,
	MIPS_INS_TLBWI,
	MIPS_INS_TLBWR,
	MIPS_INS_TLT,
	MIPS_INS_TLTI,
	MIPS_INS_TLTIU,
	MIPS_INS_TLTU,
	MIPS_INS_TNE,
	MIPS_INS_TNEI,
	MIPS_INS_TRUNC,
	MIPS_INS_V3MULU,
	MIPS_INS_VMM0,
	MIPS_INS_VMULU,
	MIPS_INS_VSHF,
	MIPS_INS_WAIT,
	MIPS_INS_WRDSP,
	MIPS_INS_WSBH,
	MIPS_INS_XOR,
	MIPS_INS_XOR16,
	MIPS_INS_XORI,

	//> some alias instructions
	MIPS_INS_NOP,
	MIPS_INS_NEGU,

	//> special instructions
	MIPS_INS_JALR_HB,	// jump and link with Hazard Barrier
	MIPS_INS_JR_HB,		// jump register with Hazard Barrier

	MIPS_INS_ENDING,
} mips_insn;

/// Group of MIPS instructions
typedef enum mips_insn_group {
	MIPS_GRP_INVALID = 0, ///< = CS_GRP_INVALID

	// Generic groups
	// all jump instructions (conditional+direct+indirect jumps)
	MIPS_GRP_JUMP,	///< = CS_GRP_JUMP
	// all call instructions
	MIPS_GRP_CALL,	///< = CS_GRP_CALL
	// all return instructions
	MIPS_GRP_RET,	///< = CS_GRP_RET
	// all interrupt instructions (int+syscall)
	MIPS_GRP_INT,	///< = CS_GRP_INT
	// all interrupt return instructions
	MIPS_GRP_IRET,	///< = CS_GRP_IRET
	// all privileged instructions
	MIPS_GRP_PRIVILEGE,	///< = CS_GRP_PRIVILEGE
	// all relative branching instructions
	MIPS_GRP_BRANCH_RELATIVE, ///< = CS_GRP_BRANCH_RELATIVE

	// Architecture-specific groups
	MIPS_GRP_BITCOUNT = 128,
	MIPS_GRP_DSP,
	MIPS_GRP_DSPR2,
	MIPS_GRP_FPIDX,
	MIPS_GRP_MSA,
	MIPS_GRP_MIPS32R2,
	MIPS_GRP_MIPS64,
	MIPS_GRP_MIPS64R2,
	MIPS_GRP_SEINREG,
	MIPS_GRP_STDENC,
	MIPS_GRP_SWAP,
	MIPS_GRP_MICROMIPS,
	MIPS_GRP_MIPS16MODE,
	MIPS_GRP_FP64BIT,
	MIPS_GRP_NONANSFPMATH,
	MIPS_GRP_NOTFP64BIT,
	MIPS_GRP_NOTINMICROMIPS,
	MIPS_GRP_NOTNACL,
	MIPS_GRP_NOTMIPS32R6,
	MIPS_GRP_NOTMIPS64R6,
	MIPS_GRP_CNMIPS,
	MIPS_GRP_MIPS32,
	MIPS_GRP_MIPS32R6,
	MIPS_GRP_MIPS64R6,
	MIPS_GRP_MIPS2,
	MIPS_GRP_MIPS3,
	MIPS_GRP_MIPS3_32,
	MIPS_GRP_MIPS3_32R2,
	MIPS_GRP_MIPS4_32,
	MIPS_GRP_MIPS4_32R2,
	MIPS_GRP_MIPS5_32R2,
	MIPS_GRP_GP32BIT,
	MIPS_GRP_GP64BIT,

	MIPS_GRP_ENDING,
} mips_insn_group;

#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/include/capstone/capstone/platform.h`:

```h
/* Capstone Disassembly Engine */
/* By Axel Souchet & Nguyen Anh Quynh, 2014 */

#ifndef CAPSTONE_PLATFORM_H
#define CAPSTONE_PLATFORM_H


// handle C99 issue (for pre-2013 VisualStudio)
#if !defined(__CYGWIN__) && !defined(__MINGW32__) && !defined(__MINGW64__) && (defined (WIN32) || defined (WIN64) || defined (_WIN32) || defined (_WIN64))
// MSVC

// stdbool.h
#if (_MSC_VER < 1800) || defined(_KERNEL_MODE)
// this system does not have stdbool.h
#ifndef __cplusplus
typedef unsigned char bool;
#define false 0
#define true 1
#endif  // __cplusplus

#else
// VisualStudio 2013+ -> C99 is supported
#include <stdbool.h>
#endif  // (_MSC_VER < 1800) || defined(_KERNEL_MODE)

#else
// not MSVC -> C99 is supported
#include <stdbool.h>
#endif  // !defined(__CYGWIN__) && !defined(__MINGW32__) && !defined(__MINGW64__) && (defined (WIN32) || defined (WIN64) || defined (_WIN32) || defined (_WIN64))


// handle inttypes.h / stdint.h compatibility
#if defined(_WIN32_WCE) && (_WIN32_WCE < 0x800)
#include "windowsce/stdint.h"
#endif  // defined(_WIN32_WCE) && (_WIN32_WCE < 0x800)

#if defined(CAPSTONE_HAS_OSXKERNEL) || (defined(_MSC_VER) && (_MSC_VER <= 1700 || defined(_KERNEL_MODE)))
// this system does not have inttypes.h

#if defined(_MSC_VER) && (_MSC_VER <= 1600 || defined(_KERNEL_MODE))
// this system does not have stdint.h
typedef signed char  int8_t;
typedef signed short int16_t;
typedef signed int   int32_t;
typedef unsigned char  uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int   uint32_t;
typedef signed long long   int64_t;
typedef unsigned long long uint64_t;
#endif  // defined(_MSC_VER) && (_MSC_VER <= 1600 || defined(_KERNEL_MODE))

#if defined(_MSC_VER) && (_MSC_VER < 1600 || defined(_KERNEL_MODE))
#define INT8_MIN         (-127i8 - 1)
#define INT16_MIN        (-32767i16 - 1)
#define INT32_MIN        (-2147483647i32 - 1)
#define INT64_MIN        (-9223372036854775807i64 - 1)
#define INT8_MAX         127i8
#define INT16_MAX        32767i16
#define INT32_MAX        2147483647i32
#define INT64_MAX        9223372036854775807i64
#define UINT8_MAX        0xffui8
#define UINT16_MAX       0xffffui16
#define UINT32_MAX       0xffffffffui32
#define UINT64_MAX       0xffffffffffffffffui64
#endif  // defined(_MSC_VER) && (_MSC_VER < 1600 || defined(_KERNEL_MODE))

#ifdef CAPSTONE_HAS_OSXKERNEL
// this system has stdint.h
#include <stdint.h>
#endif

#define __PRI_8_LENGTH_MODIFIER__ "hh"
#define __PRI_64_LENGTH_MODIFIER__ "ll"

#define PRId8         __PRI_8_LENGTH_MODIFIER__ "d"
#define PRIi8         __PRI_8_LENGTH_MODIFIER__ "i"
#define PRIo8         __PRI_8_LENGTH_MODIFIER__ "o"
#define PRIu8         __PRI_8_LENGTH_MODIFIER__ "u"
#define PRIx8         __PRI_8_LENGTH_MODIFIER__ "x"
#define PRIX8         __PRI_8_LENGTH_MODIFIER__ "X"

#define PRId16        "hd"
#define PRIi16        "hi"
#define PRIo16        "ho"
#define PRIu16        "hu"
#define PRIx16        "hx"
#define PRIX16        "hX"

#if defined(_MSC_VER) && _MSC_VER <= 1700
#define PRId32        "ld"
#define PRIi32        "li"
#define PRIo32        "lo"
#define PRIu32        "lu"
#define PRIx32        "lx"
#define PRIX32        "lX"
#else	// OSX
#define PRId32        "d"
#define PRIi32        "i"
#define PRIo32        "o"
#define PRIu32        "u"
#define PRIx32        "x"
#define PRIX32        "X"
#endif  // defined(_MSC_VER) && _MSC_VER <= 1700

#if defined(_MSC_VER) && _MSC_VER <= 1700
// redefine functions from inttypes.h used in cstool
#define strtoull _strtoui64
#endif

#define PRId64        __PRI_64_LENGTH_MODIFIER__ "d"
#define PRIi64        __PRI_64_LENGTH_MODIFIER__ "i"
#define PRIo64        __PRI_64_LENGTH_MODIFIER__ "o"
#define PRIu64        __PRI_64_LENGTH_MODIFIER__ "u"
#define PRIx64        __PRI_64_LENGTH_MODIFIER__ "x"
#define PRIX64        __PRI_64_LENGTH_MODIFIER__ "X"

#else
// this system has inttypes.h by default
#include <inttypes.h>
#endif  // defined(CAPSTONE_HAS_OSXKERNEL) || (defined(_MSC_VER) && (_MSC_VER <= 1700 || defined(_KERNEL_MODE)))

#endif

```

`KDemu/include/capstone/capstone/ppc.h`:

```h
#ifndef CAPSTONE_PPC_H
#define CAPSTONE_PPC_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2015 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

/// PPC branch codes for some branch instructions
typedef enum ppc_bc {
	PPC_BC_INVALID  = 0,
	PPC_BC_LT       = (0 << 5) | 12,
	PPC_BC_LE       = (1 << 5) |  4,
	PPC_BC_EQ       = (2 << 5) | 12,
	PPC_BC_GE       = (0 << 5) |  4,
	PPC_BC_GT       = (1 << 5) | 12,
	PPC_BC_NE       = (2 << 5) |  4,
	PPC_BC_UN       = (3 << 5) | 12,
	PPC_BC_NU       = (3 << 5) |  4,

	// extra conditions
	PPC_BC_SO = (4 << 5) | 12,	///< summary overflow
	PPC_BC_NS = (4 << 5) | 4,	///< not summary overflow
} ppc_bc;

/// PPC branch hint for some branch instructions
typedef enum ppc_bh {
	PPC_BH_INVALID = 0,	///< no hint
	PPC_BH_PLUS,	///< PLUS hint
	PPC_BH_MINUS,	///< MINUS hint
} ppc_bh;

/// Operand type for instruction's operands
typedef enum ppc_op_type {
	PPC_OP_INVALID = 0, ///< = CS_OP_INVALID (Uninitialized).
	PPC_OP_REG, ///< = CS_OP_REG (Register operand).
	PPC_OP_IMM, ///< = CS_OP_IMM (Immediate operand).
	PPC_OP_MEM, ///< = CS_OP_MEM (Memory operand).
	PPC_OP_CRX = 64,	///< Condition Register field
} ppc_op_type;

/// PPC registers
typedef enum ppc_reg {
	PPC_REG_INVALID = 0,

	PPC_REG_CARRY,
	PPC_REG_CR0,
	PPC_REG_CR1,
	PPC_REG_CR2,
	PPC_REG_CR3,
	PPC_REG_CR4,
	PPC_REG_CR5,
	PPC_REG_CR6,
	PPC_REG_CR7,
	PPC_REG_CTR,
	PPC_REG_F0,
	PPC_REG_F1,
	PPC_REG_F2,
	PPC_REG_F3,
	PPC_REG_F4,
	PPC_REG_F5,
	PPC_REG_F6,
	PPC_REG_F7,
	PPC_REG_F8,
	PPC_REG_F9,
	PPC_REG_F10,
	PPC_REG_F11,
	PPC_REG_F12,
	PPC_REG_F13,
	PPC_REG_F14,
	PPC_REG_F15,
	PPC_REG_F16,
	PPC_REG_F17,
	PPC_REG_F18,
	PPC_REG_F19,
	PPC_REG_F20,
	PPC_REG_F21,
	PPC_REG_F22,
	PPC_REG_F23,
	PPC_REG_F24,
	PPC_REG_F25,
	PPC_REG_F26,
	PPC_REG_F27,
	PPC_REG_F28,
	PPC_REG_F29,
	PPC_REG_F30,
	PPC_REG_F31,
	PPC_REG_LR,
	PPC_REG_R0,
	PPC_REG_R1,
	PPC_REG_R2,
	PPC_REG_R3,
	PPC_REG_R4,
	PPC_REG_R5,
	PPC_REG_R6,
	PPC_REG_R7,
	PPC_REG_R8,
	PPC_REG_R9,
	PPC_REG_R10,
	PPC_REG_R11,
	PPC_REG_R12,
	PPC_REG_R13,
	PPC_REG_R14,
	PPC_REG_R15,
	PPC_REG_R16,
	PPC_REG_R17,
	PPC_REG_R18,
	PPC_REG_R19,
	PPC_REG_R20,
	PPC_REG_R21,
	PPC_REG_R22,
	PPC_REG_R23,
	PPC_REG_R24,
	PPC_REG_R25,
	PPC_REG_R26,
	PPC_REG_R27,
	PPC_REG_R28,
	PPC_REG_R29,
	PPC_REG_R30,
	PPC_REG_R31,
	PPC_REG_V0,
	PPC_REG_V1,
	PPC_REG_V2,
	PPC_REG_V3,
	PPC_REG_V4,
	PPC_REG_V5,
	PPC_REG_V6,
	PPC_REG_V7,
	PPC_REG_V8,
	PPC_REG_V9,
	PPC_REG_V10,
	PPC_REG_V11,
	PPC_REG_V12,
	PPC_REG_V13,
	PPC_REG_V14,
	PPC_REG_V15,
	PPC_REG_V16,
	PPC_REG_V17,
	PPC_REG_V18,
	PPC_REG_V19,
	PPC_REG_V20,
	PPC_REG_V21,
	PPC_REG_V22,
	PPC_REG_V23,
	PPC_REG_V24,
	PPC_REG_V25,
	PPC_REG_V26,
	PPC_REG_V27,
	PPC_REG_V28,
	PPC_REG_V29,
	PPC_REG_V30,
	PPC_REG_V31,
	PPC_REG_VRSAVE,
	PPC_REG_VS0,
	PPC_REG_VS1,
	PPC_REG_VS2,
	PPC_REG_VS3,
	PPC_REG_VS4,
	PPC_REG_VS5,
	PPC_REG_VS6,
	PPC_REG_VS7,
	PPC_REG_VS8,
	PPC_REG_VS9,
	PPC_REG_VS10,
	PPC_REG_VS11,
	PPC_REG_VS12,
	PPC_REG_VS13,
	PPC_REG_VS14,
	PPC_REG_VS15,
	PPC_REG_VS16,
	PPC_REG_VS17,
	PPC_REG_VS18,
	PPC_REG_VS19,
	PPC_REG_VS20,
	PPC_REG_VS21,
	PPC_REG_VS22,
	PPC_REG_VS23,
	PPC_REG_VS24,
	PPC_REG_VS25,
	PPC_REG_VS26,
	PPC_REG_VS27,
	PPC_REG_VS28,
	PPC_REG_VS29,
	PPC_REG_VS30,
	PPC_REG_VS31,
	PPC_REG_VS32,
	PPC_REG_VS33,
	PPC_REG_VS34,
	PPC_REG_VS35,
	PPC_REG_VS36,
	PPC_REG_VS37,
	PPC_REG_VS38,
	PPC_REG_VS39,
	PPC_REG_VS40,
	PPC_REG_VS41,
	PPC_REG_VS42,
	PPC_REG_VS43,
	PPC_REG_VS44,
	PPC_REG_VS45,
	PPC_REG_VS46,
	PPC_REG_VS47,
	PPC_REG_VS48,
	PPC_REG_VS49,
	PPC_REG_VS50,
	PPC_REG_VS51,
	PPC_REG_VS52,
	PPC_REG_VS53,
	PPC_REG_VS54,
	PPC_REG_VS55,
	PPC_REG_VS56,
	PPC_REG_VS57,
	PPC_REG_VS58,
	PPC_REG_VS59,
	PPC_REG_VS60,
	PPC_REG_VS61,
	PPC_REG_VS62,
	PPC_REG_VS63,
	PPC_REG_Q0,
	PPC_REG_Q1,
	PPC_REG_Q2,
	PPC_REG_Q3,
	PPC_REG_Q4,
	PPC_REG_Q5,
	PPC_REG_Q6,
	PPC_REG_Q7,
	PPC_REG_Q8,
	PPC_REG_Q9,
	PPC_REG_Q10,
	PPC_REG_Q11,
	PPC_REG_Q12,
	PPC_REG_Q13,
	PPC_REG_Q14,
	PPC_REG_Q15,
	PPC_REG_Q16,
	PPC_REG_Q17,
	PPC_REG_Q18,
	PPC_REG_Q19,
	PPC_REG_Q20,
	PPC_REG_Q21,
	PPC_REG_Q22,
	PPC_REG_Q23,
	PPC_REG_Q24,
	PPC_REG_Q25,
	PPC_REG_Q26,
	PPC_REG_Q27,
	PPC_REG_Q28,
	PPC_REG_Q29,
	PPC_REG_Q30,
	PPC_REG_Q31,

	// extra registers for PPCMapping.c
	PPC_REG_RM,
	PPC_REG_CTR8,
	PPC_REG_LR8,
	PPC_REG_CR1EQ,
	PPC_REG_X2,

	PPC_REG_ENDING,   // <-- mark the end of the list of registers
} ppc_reg;

/// Instruction's operand referring to memory
/// This is associated with PPC_OP_MEM operand type above
typedef struct ppc_op_mem {
	ppc_reg base;	///< base register
	int32_t disp;	///< displacement/offset value
} ppc_op_mem;

typedef struct ppc_op_crx {
	unsigned int scale;
	ppc_reg reg;
	ppc_bc cond;
} ppc_op_crx;

/// Instruction operand
typedef struct cs_ppc_op {
	ppc_op_type type;	///< operand type
	union {
		ppc_reg reg;	///< register value for REG operand
		int64_t imm;		///< immediate value for IMM operand
		ppc_op_mem mem;		///< base/disp value for MEM operand
		ppc_op_crx crx;		///< operand with condition register
	};
} cs_ppc_op;

/// Instruction structure
typedef struct cs_ppc {
	/// branch code for branch instructions
	ppc_bc bc;

	/// branch hint for branch instructions
	ppc_bh bh;

	/// if update_cr0 = True, then this 'dot' insn updates CR0
	bool update_cr0;

	/// Number of operands of this instruction,
	/// or 0 when instruction has no operand.
	uint8_t op_count;
	cs_ppc_op operands[8]; ///< operands for this instruction.
} cs_ppc;

/// PPC instruction
typedef enum ppc_insn {
	PPC_INS_INVALID = 0,

	PPC_INS_ADD,
	PPC_INS_ADDC,
	PPC_INS_ADDE,
	PPC_INS_ADDI,
	PPC_INS_ADDIC,
	PPC_INS_ADDIS,
	PPC_INS_ADDME,
	PPC_INS_ADDZE,
	PPC_INS_AND,
	PPC_INS_ANDC,
	PPC_INS_ANDIS,
	PPC_INS_ANDI,
	PPC_INS_ATTN,
	PPC_INS_B,
	PPC_INS_BA,
	PPC_INS_BC,
	PPC_INS_BCCTR,
	PPC_INS_BCCTRL,
	PPC_INS_BCL,
	PPC_INS_BCLR,
	PPC_INS_BCLRL,
	PPC_INS_BCTR,
	PPC_INS_BCTRL,
	PPC_INS_BCT,
	PPC_INS_BDNZ,
	PPC_INS_BDNZA,
	PPC_INS_BDNZL,
	PPC_INS_BDNZLA,
	PPC_INS_BDNZLR,
	PPC_INS_BDNZLRL,
	PPC_INS_BDZ,
	PPC_INS_BDZA,
	PPC_INS_BDZL,
	PPC_INS_BDZLA,
	PPC_INS_BDZLR,
	PPC_INS_BDZLRL,
	PPC_INS_BL,
	PPC_INS_BLA,
	PPC_INS_BLR,
	PPC_INS_BLRL,
	PPC_INS_BRINC,
	PPC_INS_CMPB,
	PPC_INS_CMPD,
	PPC_INS_CMPDI,
	PPC_INS_CMPLD,
	PPC_INS_CMPLDI,
	PPC_INS_CMPLW,
	PPC_INS_CMPLWI,
	PPC_INS_CMPW,
	PPC_INS_CMPWI,
	PPC_INS_CNTLZD,
	PPC_INS_CNTLZW,
	PPC_INS_CREQV,
	PPC_INS_CRXOR,
	PPC_INS_CRAND,
	PPC_INS_CRANDC,
	PPC_INS_CRNAND,
	PPC_INS_CRNOR,
	PPC_INS_CROR,
	PPC_INS_CRORC,
	PPC_INS_DCBA,
	PPC_INS_DCBF,
	PPC_INS_DCBI,
	PPC_INS_DCBST,
	PPC_INS_DCBT,
	PPC_INS_DCBTST,
	PPC_INS_DCBZ,
	PPC_INS_DCBZL,
	PPC_INS_DCCCI,
	PPC_INS_DIVD,
	PPC_INS_DIVDU,
	PPC_INS_DIVW,
	PPC_INS_DIVWU,
	PPC_INS_DSS,
	PPC_INS_DSSALL,
	PPC_INS_DST,
	PPC_INS_DSTST,
	PPC_INS_DSTSTT,
	PPC_INS_DSTT,
	PPC_INS_EQV,
	PPC_INS_EVABS,
	PPC_INS_EVADDIW,
	PPC_INS_EVADDSMIAAW,
	PPC_INS_EVADDSSIAAW,
	PPC_INS_EVADDUMIAAW,
	PPC_INS_EVADDUSIAAW,
	PPC_INS_EVADDW,
	PPC_INS_EVAND,
	PPC_INS_EVANDC,
	PPC_INS_EVCMPEQ,
	PPC_INS_EVCMPGTS,
	PPC_INS_EVCMPGTU,
	PPC_INS_EVCMPLTS,
	PPC_INS_EVCMPLTU,
	PPC_INS_EVCNTLSW,
	PPC_INS_EVCNTLZW,
	PPC_INS_EVDIVWS,
	PPC_INS_EVDIVWU,
	PPC_INS_EVEQV,
	PPC_INS_EVEXTSB,
	PPC_INS_EVEXTSH,
	PPC_INS_EVLDD,
	PPC_INS_EVLDDX,
	PPC_INS_EVLDH,
	PPC_INS_EVLDHX,
	PPC_INS_EVLDW,
	PPC_INS_EVLDWX,
	PPC_INS_EVLHHESPLAT,
	PPC_INS_EVLHHESPLATX,
	PPC_INS_EVLHHOSSPLAT,
	PPC_INS_EVLHHOSSPLATX,
	PPC_INS_EVLHHOUSPLAT,
	PPC_INS_EVLHHOUSPLATX,
	PPC_INS_EVLWHE,
	PPC_INS_EVLWHEX,
	PPC_INS_EVLWHOS,
	PPC_INS_EVLWHOSX,
	PPC_INS_EVLWHOU,
	PPC_INS_EVLWHOUX,
	PPC_INS_EVLWHSPLAT,
	PPC_INS_EVLWHSPLATX,
	PPC_INS_EVLWWSPLAT,
	PPC_INS_EVLWWSPLATX,
	PPC_INS_EVMERGEHI,
	PPC_INS_EVMERGEHILO,
	PPC_INS_EVMERGELO,
	PPC_INS_EVMERGELOHI,
	PPC_INS_EVMHEGSMFAA,
	PPC_INS_EVMHEGSMFAN,
	PPC_INS_EVMHEGSMIAA,
	PPC_INS_EVMHEGSMIAN,
	PPC_INS_EVMHEGUMIAA,
	PPC_INS_EVMHEGUMIAN,
	PPC_INS_EVMHESMF,
	PPC_INS_EVMHESMFA,
	PPC_INS_EVMHESMFAAW,
	PPC_INS_EVMHESMFANW,
	PPC_INS_EVMHESMI,
	PPC_INS_EVMHESMIA,
	PPC_INS_EVMHESMIAAW,
	PPC_INS_EVMHESMIANW,
	PPC_INS_EVMHESSF,
	PPC_INS_EVMHESSFA,
	PPC_INS_EVMHESSFAAW,
	PPC_INS_EVMHESSFANW,
	PPC_INS_EVMHESSIAAW,
	PPC_INS_EVMHESSIANW,
	PPC_INS_EVMHEUMI,
	PPC_INS_EVMHEUMIA,
	PPC_INS_EVMHEUMIAAW,
	PPC_INS_EVMHEUMIANW,
	PPC_INS_EVMHEUSIAAW,
	PPC_INS_EVMHEUSIANW,
	PPC_INS_EVMHOGSMFAA,
	PPC_INS_EVMHOGSMFAN,
	PPC_INS_EVMHOGSMIAA,
	PPC_INS_EVMHOGSMIAN,
	PPC_INS_EVMHOGUMIAA,
	PPC_INS_EVMHOGUMIAN,
	PPC_INS_EVMHOSMF,
	PPC_INS_EVMHOSMFA,
	PPC_INS_EVMHOSMFAAW,
	PPC_INS_EVMHOSMFANW,
	PPC_INS_EVMHOSMI,
	PPC_INS_EVMHOSMIA,
	PPC_INS_EVMHOSMIAAW,
	PPC_INS_EVMHOSMIANW,
	PPC_INS_EVMHOSSF,
	PPC_INS_EVMHOSSFA,
	PPC_INS_EVMHOSSFAAW,
	PPC_INS_EVMHOSSFANW,
	PPC_INS_EVMHOSSIAAW,
	PPC_INS_EVMHOSSIANW,
	PPC_INS_EVMHOUMI,
	PPC_INS_EVMHOUMIA,
	PPC_INS_EVMHOUMIAAW,
	PPC_INS_EVMHOUMIANW,
	PPC_INS_EVMHOUSIAAW,
	PPC_INS_EVMHOUSIANW,
	PPC_INS_EVMRA,
	PPC_INS_EVMWHSMF,
	PPC_INS_EVMWHSMFA,
	PPC_INS_EVMWHSMI,
	PPC_INS_EVMWHSMIA,
	PPC_INS_EVMWHSSF,
	PPC_INS_EVMWHSSFA,
	PPC_INS_EVMWHUMI,
	PPC_INS_EVMWHUMIA,
	PPC_INS_EVMWLSMIAAW,
	PPC_INS_EVMWLSMIANW,
	PPC_INS_EVMWLSSIAAW,
	PPC_INS_EVMWLSSIANW,
	PPC_INS_EVMWLUMI,
	PPC_INS_EVMWLUMIA,
	PPC_INS_EVMWLUMIAAW,
	PPC_INS_EVMWLUMIANW,
	PPC_INS_EVMWLUSIAAW,
	PPC_INS_EVMWLUSIANW,
	PPC_INS_EVMWSMF,
	PPC_INS_EVMWSMFA,
	PPC_INS_EVMWSMFAA,
	PPC_INS_EVMWSMFAN,
	PPC_INS_EVMWSMI,
	PPC_INS_EVMWSMIA,
	PPC_INS_EVMWSMIAA,
	PPC_INS_EVMWSMIAN,
	PPC_INS_EVMWSSF,
	PPC_INS_EVMWSSFA,
	PPC_INS_EVMWSSFAA,
	PPC_INS_EVMWSSFAN,
	PPC_INS_EVMWUMI,
	PPC_INS_EVMWUMIA,
	PPC_INS_EVMWUMIAA,
	PPC_INS_EVMWUMIAN,
	PPC_INS_EVNAND,
	PPC_INS_EVNEG,
	PPC_INS_EVNOR,
	PPC_INS_EVOR,
	PPC_INS_EVORC,
	PPC_INS_EVRLW,
	PPC_INS_EVRLWI,
	PPC_INS_EVRNDW,
	PPC_INS_EVSLW,
	PPC_INS_EVSLWI,
	PPC_INS_EVSPLATFI,
	PPC_INS_EVSPLATI,
	PPC_INS_EVSRWIS,
	PPC_INS_EVSRWIU,
	PPC_INS_EVSRWS,
	PPC_INS_EVSRWU,
	PPC_INS_EVSTDD,
	PPC_INS_EVSTDDX,
	PPC_INS_EVSTDH,
	PPC_INS_EVSTDHX,
	PPC_INS_EVSTDW,
	PPC_INS_EVSTDWX,
	PPC_INS_EVSTWHE,
	PPC_INS_EVSTWHEX,
	PPC_INS_EVSTWHO,
	PPC_INS_EVSTWHOX,
	PPC_INS_EVSTWWE,
	PPC_INS_EVSTWWEX,
	PPC_INS_EVSTWWO,
	PPC_INS_EVSTWWOX,
	PPC_INS_EVSUBFSMIAAW,
	PPC_INS_EVSUBFSSIAAW,
	PPC_INS_EVSUBFUMIAAW,
	PPC_INS_EVSUBFUSIAAW,
	PPC_INS_EVSUBFW,
	PPC_INS_EVSUBIFW,
	PPC_INS_EVXOR,
	PPC_INS_EXTSB,
	PPC_INS_EXTSH,
	PPC_INS_EXTSW,
	PPC_INS_EIEIO,
	PPC_INS_FABS,
	PPC_INS_FADD,
	PPC_INS_FADDS,
	PPC_INS_FCFID,
	PPC_INS_FCFIDS,
	PPC_INS_FCFIDU,
	PPC_INS_FCFIDUS,
	PPC_INS_FCMPU,
	PPC_INS_FCPSGN,
	PPC_INS_FCTID,
	PPC_INS_FCTIDUZ,
	PPC_INS_FCTIDZ,
	PPC_INS_FCTIW,
	PPC_INS_FCTIWUZ,
	PPC_INS_FCTIWZ,
	PPC_INS_FDIV,
	PPC_INS_FDIVS,
	PPC_INS_FMADD,
	PPC_INS_FMADDS,
	PPC_INS_FMR,
	PPC_INS_FMSUB,
	PPC_INS_FMSUBS,
	PPC_INS_FMUL,
	PPC_INS_FMULS,
	PPC_INS_FNABS,
	PPC_INS_FNEG,
	PPC_INS_FNMADD,
	PPC_INS_FNMADDS,
	PPC_INS_FNMSUB,
	PPC_INS_FNMSUBS,
	PPC_INS_FRE,
	PPC_INS_FRES,
	PPC_INS_FRIM,
	PPC_INS_FRIN,
	PPC_INS_FRIP,
	PPC_INS_FRIZ,
	PPC_INS_FRSP,
	PPC_INS_FRSQRTE,
	PPC_INS_FRSQRTES,
	PPC_INS_FSEL,
	PPC_INS_FSQRT,
	PPC_INS_FSQRTS,
	PPC_INS_FSUB,
	PPC_INS_FSUBS,
	PPC_INS_ICBI,
	PPC_INS_ICBT,
	PPC_INS_ICCCI,
	PPC_INS_ISEL,
	PPC_INS_ISYNC,
	PPC_INS_LA,
	PPC_INS_LBZ,
	PPC_INS_LBZCIX,
	PPC_INS_LBZU,
	PPC_INS_LBZUX,
	PPC_INS_LBZX,
	PPC_INS_LD,
	PPC_INS_LDARX,
	PPC_INS_LDBRX,
	PPC_INS_LDCIX,
	PPC_INS_LDU,
	PPC_INS_LDUX,
	PPC_INS_LDX,
	PPC_INS_LFD,
	PPC_INS_LFDU,
	PPC_INS_LFDUX,
	PPC_INS_LFDX,
	PPC_INS_LFIWAX,
	PPC_INS_LFIWZX,
	PPC_INS_LFS,
	PPC_INS_LFSU,
	PPC_INS_LFSUX,
	PPC_INS_LFSX,
	PPC_INS_LHA,
	PPC_INS_LHAU,
	PPC_INS_LHAUX,
	PPC_INS_LHAX,
	PPC_INS_LHBRX,
	PPC_INS_LHZ,
	PPC_INS_LHZCIX,
	PPC_INS_LHZU,
	PPC_INS_LHZUX,
	PPC_INS_LHZX,
	PPC_INS_LI,
	PPC_INS_LIS,
	PPC_INS_LMW,
	PPC_INS_LSWI,
	PPC_INS_LVEBX,
	PPC_INS_LVEHX,
	PPC_INS_LVEWX,
	PPC_INS_LVSL,
	PPC_INS_LVSR,
	PPC_INS_LVX,
	PPC_INS_LVXL,
	PPC_INS_LWA,
	PPC_INS_LWARX,
	PPC_INS_LWAUX,
	PPC_INS_LWAX,
	PPC_INS_LWBRX,
	PPC_INS_LWZ,
	PPC_INS_LWZCIX,
	PPC_INS_LWZU,
	PPC_INS_LWZUX,
	PPC_INS_LWZX,
	PPC_INS_LXSDX,
	PPC_INS_LXVD2X,
	PPC_INS_LXVDSX,
	PPC_INS_LXVW4X,
	PPC_INS_MBAR,
	PPC_INS_MCRF,
	PPC_INS_MCRFS,
	PPC_INS_MFCR,
	PPC_INS_MFCTR,
	PPC_INS_MFDCR,
	PPC_INS_MFFS,
	PPC_INS_MFLR,
	PPC_INS_MFMSR,
	PPC_INS_MFOCRF,
	PPC_INS_MFSPR,
	PPC_INS_MFSR,
	PPC_INS_MFSRIN,
	PPC_INS_MFTB,
	PPC_INS_MFVSCR,
	PPC_INS_MSYNC,
	PPC_INS_MTCRF,
	PPC_INS_MTCTR,
	PPC_INS_MTDCR,
	PPC_INS_MTFSB0,
	PPC_INS_MTFSB1,
	PPC_INS_MTFSF,
	PPC_INS_MTFSFI,
	PPC_INS_MTLR,
	PPC_INS_MTMSR,
	PPC_INS_MTMSRD,
	PPC_INS_MTOCRF,
	PPC_INS_MTSPR,
	PPC_INS_MTSR,
	PPC_INS_MTSRIN,
	PPC_INS_MTVSCR,
	PPC_INS_MULHD,
	PPC_INS_MULHDU,
	PPC_INS_MULHW,
	PPC_INS_MULHWU,
	PPC_INS_MULLD,
	PPC_INS_MULLI,
	PPC_INS_MULLW,
	PPC_INS_NAND,
	PPC_INS_NEG,
	PPC_INS_NOP,
	PPC_INS_ORI,
	PPC_INS_NOR,
	PPC_INS_OR,
	PPC_INS_ORC,
	PPC_INS_ORIS,
	PPC_INS_POPCNTD,
	PPC_INS_POPCNTW,
	PPC_INS_QVALIGNI,
	PPC_INS_QVESPLATI,
	PPC_INS_QVFABS,
	PPC_INS_QVFADD,
	PPC_INS_QVFADDS,
	PPC_INS_QVFCFID,
	PPC_INS_QVFCFIDS,
	PPC_INS_QVFCFIDU,
	PPC_INS_QVFCFIDUS,
	PPC_INS_QVFCMPEQ,
	PPC_INS_QVFCMPGT,
	PPC_INS_QVFCMPLT,
	PPC_INS_QVFCPSGN,
	PPC_INS_QVFCTID,
	PPC_INS_QVFCTIDU,
	PPC_INS_QVFCTIDUZ,
	PPC_INS_QVFCTIDZ,
	PPC_INS_QVFCTIW,
	PPC_INS_QVFCTIWU,
	PPC_INS_QVFCTIWUZ,
	PPC_INS_QVFCTIWZ,
	PPC_INS_QVFLOGICAL,
	PPC_INS_QVFMADD,
	PPC_INS_QVFMADDS,
	PPC_INS_QVFMR,
	PPC_INS_QVFMSUB,
	PPC_INS_QVFMSUBS,
	PPC_INS_QVFMUL,
	PPC_INS_QVFMULS,
	PPC_INS_QVFNABS,
	PPC_INS_QVFNEG,
	PPC_INS_QVFNMADD,
	PPC_INS_QVFNMADDS,
	PPC_INS_QVFNMSUB,
	PPC_INS_QVFNMSUBS,
	PPC_INS_QVFPERM,
	PPC_INS_QVFRE,
	PPC_INS_QVFRES,
	PPC_INS_QVFRIM,
	PPC_INS_QVFRIN,
	PPC_INS_QVFRIP,
	PPC_INS_QVFRIZ,
	PPC_INS_QVFRSP,
	PPC_INS_QVFRSQRTE,
	PPC_INS_QVFRSQRTES,
	PPC_INS_QVFSEL,
	PPC_INS_QVFSUB,
	PPC_INS_QVFSUBS,
	PPC_INS_QVFTSTNAN,
	PPC_INS_QVFXMADD,
	PPC_INS_QVFXMADDS,
	PPC_INS_QVFXMUL,
	PPC_INS_QVFXMULS,
	PPC_INS_QVFXXCPNMADD,
	PPC_INS_QVFXXCPNMADDS,
	PPC_INS_QVFXXMADD,
	PPC_INS_QVFXXMADDS,
	PPC_INS_QVFXXNPMADD,
	PPC_INS_QVFXXNPMADDS,
	PPC_INS_QVGPCI,
	PPC_INS_QVLFCDUX,
	PPC_INS_QVLFCDUXA,
	PPC_INS_QVLFCDX,
	PPC_INS_QVLFCDXA,
	PPC_INS_QVLFCSUX,
	PPC_INS_QVLFCSUXA,
	PPC_INS_QVLFCSX,
	PPC_INS_QVLFCSXA,
	PPC_INS_QVLFDUX,
	PPC_INS_QVLFDUXA,
	PPC_INS_QVLFDX,
	PPC_INS_QVLFDXA,
	PPC_INS_QVLFIWAX,
	PPC_INS_QVLFIWAXA,
	PPC_INS_QVLFIWZX,
	PPC_INS_QVLFIWZXA,
	PPC_INS_QVLFSUX,
	PPC_INS_QVLFSUXA,
	PPC_INS_QVLFSX,
	PPC_INS_QVLFSXA,
	PPC_INS_QVLPCLDX,
	PPC_INS_QVLPCLSX,
	PPC_INS_QVLPCRDX,
	PPC_INS_QVLPCRSX,
	PPC_INS_QVSTFCDUX,
	PPC_INS_QVSTFCDUXA,
	PPC_INS_QVSTFCDUXI,
	PPC_INS_QVSTFCDUXIA,
	PPC_INS_QVSTFCDX,
	PPC_INS_QVSTFCDXA,
	PPC_INS_QVSTFCDXI,
	PPC_INS_QVSTFCDXIA,
	PPC_INS_QVSTFCSUX,
	PPC_INS_QVSTFCSUXA,
	PPC_INS_QVSTFCSUXI,
	PPC_INS_QVSTFCSUXIA,
	PPC_INS_QVSTFCSX,
	PPC_INS_QVSTFCSXA,
	PPC_INS_QVSTFCSXI,
	PPC_INS_QVSTFCSXIA,
	PPC_INS_QVSTFDUX,
	PPC_INS_QVSTFDUXA,
	PPC_INS_QVSTFDUXI,
	PPC_INS_QVSTFDUXIA,
	PPC_INS_QVSTFDX,
	PPC_INS_QVSTFDXA,
	PPC_INS_QVSTFDXI,
	PPC_INS_QVSTFDXIA,
	PPC_INS_QVSTFIWX,
	PPC_INS_QVSTFIWXA,
	PPC_INS_QVSTFSUX,
	PPC_INS_QVSTFSUXA,
	PPC_INS_QVSTFSUXI,
	PPC_INS_QVSTFSUXIA,
	PPC_INS_QVSTFSX,
	PPC_INS_QVSTFSXA,
	PPC_INS_QVSTFSXI,
	PPC_INS_QVSTFSXIA,
	PPC_INS_RFCI,
	PPC_INS_RFDI,
	PPC_INS_RFI,
	PPC_INS_RFID,
	PPC_INS_RFMCI,
	PPC_INS_RLDCL,
	PPC_INS_RLDCR,
	PPC_INS_RLDIC,
	PPC_INS_RLDICL,
	PPC_INS_RLDICR,
	PPC_INS_RLDIMI,
	PPC_INS_RLWIMI,
	PPC_INS_RLWINM,
	PPC_INS_RLWNM,
	PPC_INS_SC,
	PPC_INS_SLBIA,
	PPC_INS_SLBIE,
	PPC_INS_SLBMFEE,
	PPC_INS_SLBMTE,
	PPC_INS_SLD,
	PPC_INS_SLW,
	PPC_INS_SRAD,
	PPC_INS_SRADI,
	PPC_INS_SRAW,
	PPC_INS_SRAWI,
	PPC_INS_SRD,
	PPC_INS_SRW,
	PPC_INS_STB,
	PPC_INS_STBCIX,
	PPC_INS_STBU,
	PPC_INS_STBUX,
	PPC_INS_STBX,
	PPC_INS_STD,
	PPC_INS_STDBRX,
	PPC_INS_STDCIX,
	PPC_INS_STDCX,
	PPC_INS_STDU,
	PPC_INS_STDUX,
	PPC_INS_STDX,
	PPC_INS_STFD,
	PPC_INS_STFDU,
	PPC_INS_STFDUX,
	PPC_INS_STFDX,
	PPC_INS_STFIWX,
	PPC_INS_STFS,
	PPC_INS_STFSU,
	PPC_INS_STFSUX,
	PPC_INS_STFSX,
	PPC_INS_STH,
	PPC_INS_STHBRX,
	PPC_INS_STHCIX,
	PPC_INS_STHU,
	PPC_INS_STHUX,
	PPC_INS_STHX,
	PPC_INS_STMW,
	PPC_INS_STSWI,
	PPC_INS_STVEBX,
	PPC_INS_STVEHX,
	PPC_INS_STVEWX,
	PPC_INS_STVX,
	PPC_INS_STVXL,
	PPC_INS_STW,
	PPC_INS_STWBRX,
	PPC_INS_STWCIX,
	PPC_INS_STWCX,
	PPC_INS_STWU,
	PPC_INS_STWUX,
	PPC_INS_STWX,
	PPC_INS_STXSDX,
	PPC_INS_STXVD2X,
	PPC_INS_STXVW4X,
	PPC_INS_SUBF,
	PPC_INS_SUBFC,
	PPC_INS_SUBFE,
	PPC_INS_SUBFIC,
	PPC_INS_SUBFME,
	PPC_INS_SUBFZE,
	PPC_INS_SYNC,
	PPC_INS_TD,
	PPC_INS_TDI,
	PPC_INS_TLBIA,
	PPC_INS_TLBIE,
	PPC_INS_TLBIEL,
	PPC_INS_TLBIVAX,
	PPC_INS_TLBLD,
	PPC_INS_TLBLI,
	PPC_INS_TLBRE,
	PPC_INS_TLBSX,
	PPC_INS_TLBSYNC,
	PPC_INS_TLBWE,
	PPC_INS_TRAP,
	PPC_INS_TW,
	PPC_INS_TWI,
	PPC_INS_VADDCUW,
	PPC_INS_VADDFP,
	PPC_INS_VADDSBS,
	PPC_INS_VADDSHS,
	PPC_INS_VADDSWS,
	PPC_INS_VADDUBM,
	PPC_INS_VADDUBS,
	PPC_INS_VADDUDM,
	PPC_INS_VADDUHM,
	PPC_INS_VADDUHS,
	PPC_INS_VADDUWM,
	PPC_INS_VADDUWS,
	PPC_INS_VAND,
	PPC_INS_VANDC,
	PPC_INS_VAVGSB,
	PPC_INS_VAVGSH,
	PPC_INS_VAVGSW,
	PPC_INS_VAVGUB,
	PPC_INS_VAVGUH,
	PPC_INS_VAVGUW,
	PPC_INS_VCFSX,
	PPC_INS_VCFUX,
	PPC_INS_VCLZB,
	PPC_INS_VCLZD,
	PPC_INS_VCLZH,
	PPC_INS_VCLZW,
	PPC_INS_VCMPBFP,
	PPC_INS_VCMPEQFP,
	PPC_INS_VCMPEQUB,
	PPC_INS_VCMPEQUD,
	PPC_INS_VCMPEQUH,
	PPC_INS_VCMPEQUW,
	PPC_INS_VCMPGEFP,
	PPC_INS_VCMPGTFP,
	PPC_INS_VCMPGTSB,
	PPC_INS_VCMPGTSD,
	PPC_INS_VCMPGTSH,
	PPC_INS_VCMPGTSW,
	PPC_INS_VCMPGTUB,
	PPC_INS_VCMPGTUD,
	PPC_INS_VCMPGTUH,
	PPC_INS_VCMPGTUW,
	PPC_INS_VCTSXS,
	PPC_INS_VCTUXS,
	PPC_INS_VEQV,
	PPC_INS_VEXPTEFP,
	PPC_INS_VLOGEFP,
	PPC_INS_VMADDFP,
	PPC_INS_VMAXFP,
	PPC_INS_VMAXSB,
	PPC_INS_VMAXSD,
	PPC_INS_VMAXSH,
	PPC_INS_VMAXSW,
	PPC_INS_VMAXUB,
	PPC_INS_VMAXUD,
	PPC_INS_VMAXUH,
	PPC_INS_VMAXUW,
	PPC_INS_VMHADDSHS,
	PPC_INS_VMHRADDSHS,
	PPC_INS_VMINUD,
	PPC_INS_VMINFP,
	PPC_INS_VMINSB,
	PPC_INS_VMINSD,
	PPC_INS_VMINSH,
	PPC_INS_VMINSW,
	PPC_INS_VMINUB,
	PPC_INS_VMINUH,
	PPC_INS_VMINUW,
	PPC_INS_VMLADDUHM,
	PPC_INS_VMRGHB,
	PPC_INS_VMRGHH,
	PPC_INS_VMRGHW,
	PPC_INS_VMRGLB,
	PPC_INS_VMRGLH,
	PPC_INS_VMRGLW,
	PPC_INS_VMSUMMBM,
	PPC_INS_VMSUMSHM,
	PPC_INS_VMSUMSHS,
	PPC_INS_VMSUMUBM,
	PPC_INS_VMSUMUHM,
	PPC_INS_VMSUMUHS,
	PPC_INS_VMULESB,
	PPC_INS_VMULESH,
	PPC_INS_VMULESW,
	PPC_INS_VMULEUB,
	PPC_INS_VMULEUH,
	PPC_INS_VMULEUW,
	PPC_INS_VMULOSB,
	PPC_INS_VMULOSH,
	PPC_INS_VMULOSW,
	PPC_INS_VMULOUB,
	PPC_INS_VMULOUH,
	PPC_INS_VMULOUW,
	PPC_INS_VMULUWM,
	PPC_INS_VNAND,
	PPC_INS_VNMSUBFP,
	PPC_INS_VNOR,
	PPC_INS_VOR,
	PPC_INS_VORC,
	PPC_INS_VPERM,
	PPC_INS_VPKPX,
	PPC_INS_VPKSHSS,
	PPC_INS_VPKSHUS,
	PPC_INS_VPKSWSS,
	PPC_INS_VPKSWUS,
	PPC_INS_VPKUHUM,
	PPC_INS_VPKUHUS,
	PPC_INS_VPKUWUM,
	PPC_INS_VPKUWUS,
	PPC_INS_VPOPCNTB,
	PPC_INS_VPOPCNTD,
	PPC_INS_VPOPCNTH,
	PPC_INS_VPOPCNTW,
	PPC_INS_VREFP,
	PPC_INS_VRFIM,
	PPC_INS_VRFIN,
	PPC_INS_VRFIP,
	PPC_INS_VRFIZ,
	PPC_INS_VRLB,
	PPC_INS_VRLD,
	PPC_INS_VRLH,
	PPC_INS_VRLW,
	PPC_INS_VRSQRTEFP,
	PPC_INS_VSEL,
	PPC_INS_VSL,
	PPC_INS_VSLB,
	PPC_INS_VSLD,
	PPC_INS_VSLDOI,
	PPC_INS_VSLH,
	PPC_INS_VSLO,
	PPC_INS_VSLW,
	PPC_INS_VSPLTB,
	PPC_INS_VSPLTH,
	PPC_INS_VSPLTISB,
	PPC_INS_VSPLTISH,
	PPC_INS_VSPLTISW,
	PPC_INS_VSPLTW,
	PPC_INS_VSR,
	PPC_INS_VSRAB,
	PPC_INS_VSRAD,
	PPC_INS_VSRAH,
	PPC_INS_VSRAW,
	PPC_INS_VSRB,
	PPC_INS_VSRD,
	PPC_INS_VSRH,
	PPC_INS_VSRO,
	PPC_INS_VSRW,
	PPC_INS_VSUBCUW,
	PPC_INS_VSUBFP,
	PPC_INS_VSUBSBS,
	PPC_INS_VSUBSHS,
	PPC_INS_VSUBSWS,
	PPC_INS_VSUBUBM,
	PPC_INS_VSUBUBS,
	PPC_INS_VSUBUDM,
	PPC_INS_VSUBUHM,
	PPC_INS_VSUBUHS,
	PPC_INS_VSUBUWM,
	PPC_INS_VSUBUWS,
	PPC_INS_VSUM2SWS,
	PPC_INS_VSUM4SBS,
	PPC_INS_VSUM4SHS,
	PPC_INS_VSUM4UBS,
	PPC_INS_VSUMSWS,
	PPC_INS_VUPKHPX,
	PPC_INS_VUPKHSB,
	PPC_INS_VUPKHSH,
	PPC_INS_VUPKLPX,
	PPC_INS_VUPKLSB,
	PPC_INS_VUPKLSH,
	PPC_INS_VXOR,
	PPC_INS_WAIT,
	PPC_INS_WRTEE,
	PPC_INS_WRTEEI,
	PPC_INS_XOR,
	PPC_INS_XORI,
	PPC_INS_XORIS,
	PPC_INS_XSABSDP,
	PPC_INS_XSADDDP,
	PPC_INS_XSCMPODP,
	PPC_INS_XSCMPUDP,
	PPC_INS_XSCPSGNDP,
	PPC_INS_XSCVDPSP,
	PPC_INS_XSCVDPSXDS,
	PPC_INS_XSCVDPSXWS,
	PPC_INS_XSCVDPUXDS,
	PPC_INS_XSCVDPUXWS,
	PPC_INS_XSCVSPDP,
	PPC_INS_XSCVSXDDP,
	PPC_INS_XSCVUXDDP,
	PPC_INS_XSDIVDP,
	PPC_INS_XSMADDADP,
	PPC_INS_XSMADDMDP,
	PPC_INS_XSMAXDP,
	PPC_INS_XSMINDP,
	PPC_INS_XSMSUBADP,
	PPC_INS_XSMSUBMDP,
	PPC_INS_XSMULDP,
	PPC_INS_XSNABSDP,
	PPC_INS_XSNEGDP,
	PPC_INS_XSNMADDADP,
	PPC_INS_XSNMADDMDP,
	PPC_INS_XSNMSUBADP,
	PPC_INS_XSNMSUBMDP,
	PPC_INS_XSRDPI,
	PPC_INS_XSRDPIC,
	PPC_INS_XSRDPIM,
	PPC_INS_XSRDPIP,
	PPC_INS_XSRDPIZ,
	PPC_INS_XSREDP,
	PPC_INS_XSRSQRTEDP,
	PPC_INS_XSSQRTDP,
	PPC_INS_XSSUBDP,
	PPC_INS_XSTDIVDP,
	PPC_INS_XSTSQRTDP,
	PPC_INS_XVABSDP,
	PPC_INS_XVABSSP,
	PPC_INS_XVADDDP,
	PPC_INS_XVADDSP,
	PPC_INS_XVCMPEQDP,
	PPC_INS_XVCMPEQSP,
	PPC_INS_XVCMPGEDP,
	PPC_INS_XVCMPGESP,
	PPC_INS_XVCMPGTDP,
	PPC_INS_XVCMPGTSP,
	PPC_INS_XVCPSGNDP,
	PPC_INS_XVCPSGNSP,
	PPC_INS_XVCVDPSP,
	PPC_INS_XVCVDPSXDS,
	PPC_INS_XVCVDPSXWS,
	PPC_INS_XVCVDPUXDS,
	PPC_INS_XVCVDPUXWS,
	PPC_INS_XVCVSPDP,
	PPC_INS_XVCVSPSXDS,
	PPC_INS_XVCVSPSXWS,
	PPC_INS_XVCVSPUXDS,
	PPC_INS_XVCVSPUXWS,
	PPC_INS_XVCVSXDDP,
	PPC_INS_XVCVSXDSP,
	PPC_INS_XVCVSXWDP,
	PPC_INS_XVCVSXWSP,
	PPC_INS_XVCVUXDDP,
	PPC_INS_XVCVUXDSP,
	PPC_INS_XVCVUXWDP,
	PPC_INS_XVCVUXWSP,
	PPC_INS_XVDIVDP,
	PPC_INS_XVDIVSP,
	PPC_INS_XVMADDADP,
	PPC_INS_XVMADDASP,
	PPC_INS_XVMADDMDP,
	PPC_INS_XVMADDMSP,
	PPC_INS_XVMAXDP,
	PPC_INS_XVMAXSP,
	PPC_INS_XVMINDP,
	PPC_INS_XVMINSP,
	PPC_INS_XVMSUBADP,
	PPC_INS_XVMSUBASP,
	PPC_INS_XVMSUBMDP,
	PPC_INS_XVMSUBMSP,
	PPC_INS_XVMULDP,
	PPC_INS_XVMULSP,
	PPC_INS_XVNABSDP,
	PPC_INS_XVNABSSP,
	PPC_INS_XVNEGDP,
	PPC_INS_XVNEGSP,
	PPC_INS_XVNMADDADP,
	PPC_INS_XVNMADDASP,
	PPC_INS_XVNMADDMDP,
	PPC_INS_XVNMADDMSP,
	PPC_INS_XVNMSUBADP,
	PPC_INS_XVNMSUBASP,
	PPC_INS_XVNMSUBMDP,
	PPC_INS_XVNMSUBMSP,
	PPC_INS_XVRDPI,
	PPC_INS_XVRDPIC,
	PPC_INS_XVRDPIM,
	PPC_INS_XVRDPIP,
	PPC_INS_XVRDPIZ,
	PPC_INS_XVREDP,
	PPC_INS_XVRESP,
	PPC_INS_XVRSPI,
	PPC_INS_XVRSPIC,
	PPC_INS_XVRSPIM,
	PPC_INS_XVRSPIP,
	PPC_INS_XVRSPIZ,
	PPC_INS_XVRSQRTEDP,
	PPC_INS_XVRSQRTESP,
	PPC_INS_XVSQRTDP,
	PPC_INS_XVSQRTSP,
	PPC_INS_XVSUBDP,
	PPC_INS_XVSUBSP,
	PPC_INS_XVTDIVDP,
	PPC_INS_XVTDIVSP,
	PPC_INS_XVTSQRTDP,
	PPC_INS_XVTSQRTSP,
	PPC_INS_XXLAND,
	PPC_INS_XXLANDC,
	PPC_INS_XXLEQV,
	PPC_INS_XXLNAND,
	PPC_INS_XXLNOR,
	PPC_INS_XXLOR,
	PPC_INS_XXLORC,
	PPC_INS_XXLXOR,
	PPC_INS_XXMRGHW,
	PPC_INS_XXMRGLW,
	PPC_INS_XXPERMDI,
	PPC_INS_XXSEL,
	PPC_INS_XXSLDWI,
	PPC_INS_XXSPLTW,
	PPC_INS_BCA,
	PPC_INS_BCLA,

	// extra & alias instructions
	PPC_INS_SLWI,
	PPC_INS_SRWI,
	PPC_INS_SLDI,

	PPC_INS_BTA,
	PPC_INS_CRSET,
	PPC_INS_CRNOT,
	PPC_INS_CRMOVE,
	PPC_INS_CRCLR,
	PPC_INS_MFBR0,
	PPC_INS_MFBR1,
	PPC_INS_MFBR2,
	PPC_INS_MFBR3,
	PPC_INS_MFBR4,
	PPC_INS_MFBR5,
	PPC_INS_MFBR6,
	PPC_INS_MFBR7,
	PPC_INS_MFXER,
	PPC_INS_MFRTCU,
	PPC_INS_MFRTCL,
	PPC_INS_MFDSCR,
	PPC_INS_MFDSISR,
	PPC_INS_MFDAR,
	PPC_INS_MFSRR2,
	PPC_INS_MFSRR3,
	PPC_INS_MFCFAR,
	PPC_INS_MFAMR,
	PPC_INS_MFPID,
	PPC_INS_MFTBLO,
	PPC_INS_MFTBHI,
	PPC_INS_MFDBATU,
	PPC_INS_MFDBATL,
	PPC_INS_MFIBATU,
	PPC_INS_MFIBATL,
	PPC_INS_MFDCCR,
	PPC_INS_MFICCR,
	PPC_INS_MFDEAR,
	PPC_INS_MFESR,
	PPC_INS_MFSPEFSCR,
	PPC_INS_MFTCR,
	PPC_INS_MFASR,
	PPC_INS_MFPVR,
	PPC_INS_MFTBU,
	PPC_INS_MTCR,
	PPC_INS_MTBR0,
	PPC_INS_MTBR1,
	PPC_INS_MTBR2,
	PPC_INS_MTBR3,
	PPC_INS_MTBR4,
	PPC_INS_MTBR5,
	PPC_INS_MTBR6,
	PPC_INS_MTBR7,
	PPC_INS_MTXER,
	PPC_INS_MTDSCR,
	PPC_INS_MTDSISR,
	PPC_INS_MTDAR,
	PPC_INS_MTSRR2,
	PPC_INS_MTSRR3,
	PPC_INS_MTCFAR,
	PPC_INS_MTAMR,
	PPC_INS_MTPID,
	PPC_INS_MTTBL,
	PPC_INS_MTTBU,
	PPC_INS_MTTBLO,
	PPC_INS_MTTBHI,
	PPC_INS_MTDBATU,
	PPC_INS_MTDBATL,
	PPC_INS_MTIBATU,
	PPC_INS_MTIBATL,
	PPC_INS_MTDCCR,
	PPC_INS_MTICCR,
	PPC_INS_MTDEAR,
	PPC_INS_MTESR,
	PPC_INS_MTSPEFSCR,
	PPC_INS_MTTCR,
	PPC_INS_NOT,
	PPC_INS_MR,
	PPC_INS_ROTLD,
	PPC_INS_ROTLDI,
	PPC_INS_CLRLDI,
	PPC_INS_ROTLWI,
	PPC_INS_CLRLWI,
	PPC_INS_ROTLW,
	PPC_INS_SUB,
	PPC_INS_SUBC,
	PPC_INS_LWSYNC,
	PPC_INS_PTESYNC,
	PPC_INS_TDLT,
	PPC_INS_TDEQ,
	PPC_INS_TDGT,
	PPC_INS_TDNE,
	PPC_INS_TDLLT,
	PPC_INS_TDLGT,
	PPC_INS_TDU,
	PPC_INS_TDLTI,
	PPC_INS_TDEQI,
	PPC_INS_TDGTI,
	PPC_INS_TDNEI,
	PPC_INS_TDLLTI,
	PPC_INS_TDLGTI,
	PPC_INS_TDUI,
	PPC_INS_TLBREHI,
	PPC_INS_TLBRELO,
	PPC_INS_TLBWEHI,
	PPC_INS_TLBWELO,
	PPC_INS_TWLT,
	PPC_INS_TWEQ,
	PPC_INS_TWGT,
	PPC_INS_TWNE,
	PPC_INS_TWLLT,
	PPC_INS_TWLGT,
	PPC_INS_TWU,
	PPC_INS_TWLTI,
	PPC_INS_TWEQI,
	PPC_INS_TWGTI,
	PPC_INS_TWNEI,
	PPC_INS_TWLLTI,
	PPC_INS_TWLGTI,
	PPC_INS_TWUI,
	PPC_INS_WAITRSV,
	PPC_INS_WAITIMPL,
	PPC_INS_XNOP,
	PPC_INS_XVMOVDP,
	PPC_INS_XVMOVSP,
	PPC_INS_XXSPLTD,
	PPC_INS_XXMRGHD,
	PPC_INS_XXMRGLD,
	PPC_INS_XXSWAPD,
	PPC_INS_BT,
	PPC_INS_BF,
	PPC_INS_BDNZT,
	PPC_INS_BDNZF,
	PPC_INS_BDZF,
	PPC_INS_BDZT,
	PPC_INS_BFA,
	PPC_INS_BDNZTA,
	PPC_INS_BDNZFA,
	PPC_INS_BDZTA,
	PPC_INS_BDZFA,
	PPC_INS_BTCTR,
	PPC_INS_BFCTR,
	PPC_INS_BTCTRL,
	PPC_INS_BFCTRL,
	PPC_INS_BTL,
	PPC_INS_BFL,
	PPC_INS_BDNZTL,
	PPC_INS_BDNZFL,
	PPC_INS_BDZTL,
	PPC_INS_BDZFL,
	PPC_INS_BTLA,
	PPC_INS_BFLA,
	PPC_INS_BDNZTLA,
	PPC_INS_BDNZFLA,
	PPC_INS_BDZTLA,
	PPC_INS_BDZFLA,
	PPC_INS_BTLR,
	PPC_INS_BFLR,
	PPC_INS_BDNZTLR,
	PPC_INS_BDZTLR,
	PPC_INS_BDZFLR,
	PPC_INS_BTLRL,
	PPC_INS_BFLRL,
	PPC_INS_BDNZTLRL,
	PPC_INS_BDNZFLRL,
	PPC_INS_BDZTLRL,
	PPC_INS_BDZFLRL,

	// QPX
	PPC_INS_QVFAND,
	PPC_INS_QVFCLR,
	PPC_INS_QVFANDC,
	PPC_INS_QVFCTFB,
	PPC_INS_QVFXOR,
	PPC_INS_QVFOR,
	PPC_INS_QVFNOR,
	PPC_INS_QVFEQU,
	PPC_INS_QVFNOT,
	PPC_INS_QVFORC,
	PPC_INS_QVFNAND,
	PPC_INS_QVFSET,

	PPC_INS_ENDING,   // <-- mark the end of the list of instructions
} ppc_insn;

/// Group of PPC instructions
typedef enum ppc_insn_group {
	PPC_GRP_INVALID = 0, ///< = CS_GRP_INVALID

	// Generic groups
	// all jump instructions (conditional+direct+indirect jumps)
	PPC_GRP_JUMP,	///< = CS_GRP_JUMP

	// Architecture-specific groups
	PPC_GRP_ALTIVEC = 128,
	PPC_GRP_MODE32,
	PPC_GRP_MODE64,
	PPC_GRP_BOOKE,
	PPC_GRP_NOTBOOKE,
	PPC_GRP_SPE,
	PPC_GRP_VSX,
	PPC_GRP_E500,
	PPC_GRP_PPC4XX,
	PPC_GRP_PPC6XX,
	PPC_GRP_ICBT,
	PPC_GRP_P8ALTIVEC,
	PPC_GRP_P8VECTOR,
	PPC_GRP_QPX,

	PPC_GRP_ENDING,   // <-- mark the end of the list of groups
} ppc_insn_group;

#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/include/capstone/capstone/sparc.h`:

```h
#ifndef CAPSTONE_SPARC_H
#define CAPSTONE_SPARC_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2014-2015 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

// GCC SPARC toolchain has a default macro called "sparc" which breaks
// compilation
#undef sparc

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

/// Enums corresponding to Sparc condition codes, both icc's and fcc's.
typedef enum sparc_cc {
	SPARC_CC_INVALID = 0,	///< invalid CC (default)
	// Integer condition codes
	SPARC_CC_ICC_A   =  8+256,  ///< Always
	SPARC_CC_ICC_N   =  0+256,  ///< Never
	SPARC_CC_ICC_NE  =  9+256,  ///< Not Equal
	SPARC_CC_ICC_E   =  1+256,  ///< Equal
	SPARC_CC_ICC_G   = 10+256,  ///< Greater
	SPARC_CC_ICC_LE  =  2+256,  ///< Less or Equal
	SPARC_CC_ICC_GE  = 11+256,  ///< Greater or Equal
	SPARC_CC_ICC_L   =  3+256,  ///< Less
	SPARC_CC_ICC_GU  = 12+256,  ///< Greater Unsigned
	SPARC_CC_ICC_LEU =  4+256,  ///< Less or Equal Unsigned
	SPARC_CC_ICC_CC  = 13+256,  ///< Carry Clear/Great or Equal Unsigned
	SPARC_CC_ICC_CS  =  5+256,  ///< Carry Set/Less Unsigned
	SPARC_CC_ICC_POS = 14+256,  ///< Positive
	SPARC_CC_ICC_NEG =  6+256,  ///< Negative
	SPARC_CC_ICC_VC  = 15+256,  ///< Overflow Clear
	SPARC_CC_ICC_VS  =  7+256,  ///< Overflow Set

	// Floating condition codes
	SPARC_CC_FCC_A   =  8+16+256,  ///< Always
	SPARC_CC_FCC_N   =  0+16+256,  ///< Never
	SPARC_CC_FCC_U   =  7+16+256,  ///< Unordered
	SPARC_CC_FCC_G   =  6+16+256,  ///< Greater
	SPARC_CC_FCC_UG  =  5+16+256,  ///< Unordered or Greater
	SPARC_CC_FCC_L   =  4+16+256,  ///< Less
	SPARC_CC_FCC_UL  =  3+16+256,  ///< Unordered or Less
	SPARC_CC_FCC_LG  =  2+16+256,  ///< Less or Greater
	SPARC_CC_FCC_NE  =  1+16+256,  ///< Not Equal
	SPARC_CC_FCC_E   =  9+16+256,  ///< Equal
	SPARC_CC_FCC_UE  = 10+16+256,  ///< Unordered or Equal
	SPARC_CC_FCC_GE  = 11+16+256,  ///< Greater or Equal
	SPARC_CC_FCC_UGE = 12+16+256,  ///< Unordered or Greater or Equal
	SPARC_CC_FCC_LE  = 13+16+256,  ///< Less or Equal
	SPARC_CC_FCC_ULE = 14+16+256,  ///< Unordered or Less or Equal
	SPARC_CC_FCC_O   = 15+16+256,  ///< Ordered
} sparc_cc;

/// Branch hint
typedef enum sparc_hint {
	SPARC_HINT_INVALID = 0,	///< no hint
	SPARC_HINT_A	= 1 << 0,	///< annul delay slot instruction
	SPARC_HINT_PT	= 1 << 1,	///< branch taken
	SPARC_HINT_PN	= 1 << 2,	///< branch NOT taken
} sparc_hint;

/// Operand type for instruction's operands
typedef enum sparc_op_type {
	SPARC_OP_INVALID = 0, ///< = CS_OP_INVALID (Uninitialized).
	SPARC_OP_REG, ///< = CS_OP_REG (Register operand).
	SPARC_OP_IMM, ///< = CS_OP_IMM (Immediate operand).
	SPARC_OP_MEM, ///< = CS_OP_MEM (Memory operand).
} sparc_op_type;

/// SPARC registers
typedef enum sparc_reg {
	SPARC_REG_INVALID = 0,

	SPARC_REG_F0,
	SPARC_REG_F1,
	SPARC_REG_F2,
	SPARC_REG_F3,
	SPARC_REG_F4,
	SPARC_REG_F5,
	SPARC_REG_F6,
	SPARC_REG_F7,
	SPARC_REG_F8,
	SPARC_REG_F9,
	SPARC_REG_F10,
	SPARC_REG_F11,
	SPARC_REG_F12,
	SPARC_REG_F13,
	SPARC_REG_F14,
	SPARC_REG_F15,
	SPARC_REG_F16,
	SPARC_REG_F17,
	SPARC_REG_F18,
	SPARC_REG_F19,
	SPARC_REG_F20,
	SPARC_REG_F21,
	SPARC_REG_F22,
	SPARC_REG_F23,
	SPARC_REG_F24,
	SPARC_REG_F25,
	SPARC_REG_F26,
	SPARC_REG_F27,
	SPARC_REG_F28,
	SPARC_REG_F29,
	SPARC_REG_F30,
	SPARC_REG_F31,
	SPARC_REG_F32,
	SPARC_REG_F34,
	SPARC_REG_F36,
	SPARC_REG_F38,
	SPARC_REG_F40,
	SPARC_REG_F42,
	SPARC_REG_F44,
	SPARC_REG_F46,
	SPARC_REG_F48,
	SPARC_REG_F50,
	SPARC_REG_F52,
	SPARC_REG_F54,
	SPARC_REG_F56,
	SPARC_REG_F58,
	SPARC_REG_F60,
	SPARC_REG_F62,
	SPARC_REG_FCC0,	// Floating condition codes
	SPARC_REG_FCC1,
	SPARC_REG_FCC2,
	SPARC_REG_FCC3,
	SPARC_REG_FP,
	SPARC_REG_G0,
	SPARC_REG_G1,
	SPARC_REG_G2,
	SPARC_REG_G3,
	SPARC_REG_G4,
	SPARC_REG_G5,
	SPARC_REG_G6,
	SPARC_REG_G7,
	SPARC_REG_I0,
	SPARC_REG_I1,
	SPARC_REG_I2,
	SPARC_REG_I3,
	SPARC_REG_I4,
	SPARC_REG_I5,
	SPARC_REG_I7,
	SPARC_REG_ICC,	// Integer condition codes
	SPARC_REG_L0,
	SPARC_REG_L1,
	SPARC_REG_L2,
	SPARC_REG_L3,
	SPARC_REG_L4,
	SPARC_REG_L5,
	SPARC_REG_L6,
	SPARC_REG_L7,
	SPARC_REG_O0,
	SPARC_REG_O1,
	SPARC_REG_O2,
	SPARC_REG_O3,
	SPARC_REG_O4,
	SPARC_REG_O5,
	SPARC_REG_O7,
	SPARC_REG_SP,
	SPARC_REG_Y,

	// special register
	SPARC_REG_XCC,

	SPARC_REG_ENDING,   // <-- mark the end of the list of registers

	// extras
	SPARC_REG_O6 = SPARC_REG_SP,
	SPARC_REG_I6 = SPARC_REG_FP,
} sparc_reg;

/// Instruction's operand referring to memory
/// This is associated with SPARC_OP_MEM operand type above
typedef struct sparc_op_mem {
	uint8_t base;		///< base register, can be safely interpreted as
				///< a value of type `sparc_reg`, but it is only
				///< one byte wide
	uint8_t index;		///< index register, same conditions apply here
	int32_t disp;		///< displacement/offset value
} sparc_op_mem;

/// Instruction operand
typedef struct cs_sparc_op {
	sparc_op_type type;	///< operand type
	union {
		sparc_reg reg;	///< register value for REG operand
		int64_t imm;		///< immediate value for IMM operand
		sparc_op_mem mem;		///< base/disp value for MEM operand
	};
} cs_sparc_op;

/// Instruction structure
typedef struct cs_sparc {
	sparc_cc cc;	///< code condition for this insn
	sparc_hint hint;	///< branch hint: encoding as bitwise OR of sparc_hint.
	/// Number of operands of this instruction,
	/// or 0 when instruction has no operand.
	uint8_t op_count;
	cs_sparc_op operands[4]; ///< operands for this instruction.
} cs_sparc;

/// SPARC instruction
typedef enum sparc_insn {
	SPARC_INS_INVALID = 0,

	SPARC_INS_ADDCC,
	SPARC_INS_ADDX,
	SPARC_INS_ADDXCC,
	SPARC_INS_ADDXC,
	SPARC_INS_ADDXCCC,
	SPARC_INS_ADD,
	SPARC_INS_ALIGNADDR,
	SPARC_INS_ALIGNADDRL,
	SPARC_INS_ANDCC,
	SPARC_INS_ANDNCC,
	SPARC_INS_ANDN,
	SPARC_INS_AND,
	SPARC_INS_ARRAY16,
	SPARC_INS_ARRAY32,
	SPARC_INS_ARRAY8,
	SPARC_INS_B,
	SPARC_INS_JMP,
	SPARC_INS_BMASK,
	SPARC_INS_FB,
	SPARC_INS_BRGEZ,
	SPARC_INS_BRGZ,
	SPARC_INS_BRLEZ,
	SPARC_INS_BRLZ,
	SPARC_INS_BRNZ,
	SPARC_INS_BRZ,
	SPARC_INS_BSHUFFLE,
	SPARC_INS_CALL,
	SPARC_INS_CASX,
	SPARC_INS_CAS,
	SPARC_INS_CMASK16,
	SPARC_INS_CMASK32,
	SPARC_INS_CMASK8,
	SPARC_INS_CMP,
	SPARC_INS_EDGE16,
	SPARC_INS_EDGE16L,
	SPARC_INS_EDGE16LN,
	SPARC_INS_EDGE16N,
	SPARC_INS_EDGE32,
	SPARC_INS_EDGE32L,
	SPARC_INS_EDGE32LN,
	SPARC_INS_EDGE32N,
	SPARC_INS_EDGE8,
	SPARC_INS_EDGE8L,
	SPARC_INS_EDGE8LN,
	SPARC_INS_EDGE8N,
	SPARC_INS_FABSD,
	SPARC_INS_FABSQ,
	SPARC_INS_FABSS,
	SPARC_INS_FADDD,
	SPARC_INS_FADDQ,
	SPARC_INS_FADDS,
	SPARC_INS_FALIGNDATA,
	SPARC_INS_FAND,
	SPARC_INS_FANDNOT1,
	SPARC_INS_FANDNOT1S,
	SPARC_INS_FANDNOT2,
	SPARC_INS_FANDNOT2S,
	SPARC_INS_FANDS,
	SPARC_INS_FCHKSM16,
	SPARC_INS_FCMPD,
	SPARC_INS_FCMPEQ16,
	SPARC_INS_FCMPEQ32,
	SPARC_INS_FCMPGT16,
	SPARC_INS_FCMPGT32,
	SPARC_INS_FCMPLE16,
	SPARC_INS_FCMPLE32,
	SPARC_INS_FCMPNE16,
	SPARC_INS_FCMPNE32,
	SPARC_INS_FCMPQ,
	SPARC_INS_FCMPS,
	SPARC_INS_FDIVD,
	SPARC_INS_FDIVQ,
	SPARC_INS_FDIVS,
	SPARC_INS_FDMULQ,
	SPARC_INS_FDTOI,
	SPARC_INS_FDTOQ,
	SPARC_INS_FDTOS,
	SPARC_INS_FDTOX,
	SPARC_INS_FEXPAND,
	SPARC_INS_FHADDD,
	SPARC_INS_FHADDS,
	SPARC_INS_FHSUBD,
	SPARC_INS_FHSUBS,
	SPARC_INS_FITOD,
	SPARC_INS_FITOQ,
	SPARC_INS_FITOS,
	SPARC_INS_FLCMPD,
	SPARC_INS_FLCMPS,
	SPARC_INS_FLUSHW,
	SPARC_INS_FMEAN16,
	SPARC_INS_FMOVD,
	SPARC_INS_FMOVQ,
	SPARC_INS_FMOVRDGEZ,
	SPARC_INS_FMOVRQGEZ,
	SPARC_INS_FMOVRSGEZ,
	SPARC_INS_FMOVRDGZ,
	SPARC_INS_FMOVRQGZ,
	SPARC_INS_FMOVRSGZ,
	SPARC_INS_FMOVRDLEZ,
	SPARC_INS_FMOVRQLEZ,
	SPARC_INS_FMOVRSLEZ,
	SPARC_INS_FMOVRDLZ,
	SPARC_INS_FMOVRQLZ,
	SPARC_INS_FMOVRSLZ,
	SPARC_INS_FMOVRDNZ,
	SPARC_INS_FMOVRQNZ,
	SPARC_INS_FMOVRSNZ,
	SPARC_INS_FMOVRDZ,
	SPARC_INS_FMOVRQZ,
	SPARC_INS_FMOVRSZ,
	SPARC_INS_FMOVS,
	SPARC_INS_FMUL8SUX16,
	SPARC_INS_FMUL8ULX16,
	SPARC_INS_FMUL8X16,
	SPARC_INS_FMUL8X16AL,
	SPARC_INS_FMUL8X16AU,
	SPARC_INS_FMULD,
	SPARC_INS_FMULD8SUX16,
	SPARC_INS_FMULD8ULX16,
	SPARC_INS_FMULQ,
	SPARC_INS_FMULS,
	SPARC_INS_FNADDD,
	SPARC_INS_FNADDS,
	SPARC_INS_FNAND,
	SPARC_INS_FNANDS,
	SPARC_INS_FNEGD,
	SPARC_INS_FNEGQ,
	SPARC_INS_FNEGS,
	SPARC_INS_FNHADDD,
	SPARC_INS_FNHADDS,
	SPARC_INS_FNOR,
	SPARC_INS_FNORS,
	SPARC_INS_FNOT1,
	SPARC_INS_FNOT1S,
	SPARC_INS_FNOT2,
	SPARC_INS_FNOT2S,
	SPARC_INS_FONE,
	SPARC_INS_FONES,
	SPARC_INS_FOR,
	SPARC_INS_FORNOT1,
	SPARC_INS_FORNOT1S,
	SPARC_INS_FORNOT2,
	SPARC_INS_FORNOT2S,
	SPARC_INS_FORS,
	SPARC_INS_FPACK16,
	SPARC_INS_FPACK32,
	SPARC_INS_FPACKFIX,
	SPARC_INS_FPADD16,
	SPARC_INS_FPADD16S,
	SPARC_INS_FPADD32,
	SPARC_INS_FPADD32S,
	SPARC_INS_FPADD64,
	SPARC_INS_FPMERGE,
	SPARC_INS_FPSUB16,
	SPARC_INS_FPSUB16S,
	SPARC_INS_FPSUB32,
	SPARC_INS_FPSUB32S,
	SPARC_INS_FQTOD,
	SPARC_INS_FQTOI,
	SPARC_INS_FQTOS,
	SPARC_INS_FQTOX,
	SPARC_INS_FSLAS16,
	SPARC_INS_FSLAS32,
	SPARC_INS_FSLL16,
	SPARC_INS_FSLL32,
	SPARC_INS_FSMULD,
	SPARC_INS_FSQRTD,
	SPARC_INS_FSQRTQ,
	SPARC_INS_FSQRTS,
	SPARC_INS_FSRA16,
	SPARC_INS_FSRA32,
	SPARC_INS_FSRC1,
	SPARC_INS_FSRC1S,
	SPARC_INS_FSRC2,
	SPARC_INS_FSRC2S,
	SPARC_INS_FSRL16,
	SPARC_INS_FSRL32,
	SPARC_INS_FSTOD,
	SPARC_INS_FSTOI,
	SPARC_INS_FSTOQ,
	SPARC_INS_FSTOX,
	SPARC_INS_FSUBD,
	SPARC_INS_FSUBQ,
	SPARC_INS_FSUBS,
	SPARC_INS_FXNOR,
	SPARC_INS_FXNORS,
	SPARC_INS_FXOR,
	SPARC_INS_FXORS,
	SPARC_INS_FXTOD,
	SPARC_INS_FXTOQ,
	SPARC_INS_FXTOS,
	SPARC_INS_FZERO,
	SPARC_INS_FZEROS,
	SPARC_INS_JMPL,
	SPARC_INS_LDD,
	SPARC_INS_LD,
	SPARC_INS_LDQ,
	SPARC_INS_LDSB,
	SPARC_INS_LDSH,
	SPARC_INS_LDSW,
	SPARC_INS_LDUB,
	SPARC_INS_LDUH,
	SPARC_INS_LDX,
	SPARC_INS_LZCNT,
	SPARC_INS_MEMBAR,
	SPARC_INS_MOVDTOX,
	SPARC_INS_MOV,
	SPARC_INS_MOVRGEZ,
	SPARC_INS_MOVRGZ,
	SPARC_INS_MOVRLEZ,
	SPARC_INS_MOVRLZ,
	SPARC_INS_MOVRNZ,
	SPARC_INS_MOVRZ,
	SPARC_INS_MOVSTOSW,
	SPARC_INS_MOVSTOUW,
	SPARC_INS_MULX,
	SPARC_INS_NOP,
	SPARC_INS_ORCC,
	SPARC_INS_ORNCC,
	SPARC_INS_ORN,
	SPARC_INS_OR,
	SPARC_INS_PDIST,
	SPARC_INS_PDISTN,
	SPARC_INS_POPC,
	SPARC_INS_RD,
	SPARC_INS_RESTORE,
	SPARC_INS_RETT,
	SPARC_INS_SAVE,
	SPARC_INS_SDIVCC,
	SPARC_INS_SDIVX,
	SPARC_INS_SDIV,
	SPARC_INS_SETHI,
	SPARC_INS_SHUTDOWN,
	SPARC_INS_SIAM,
	SPARC_INS_SLLX,
	SPARC_INS_SLL,
	SPARC_INS_SMULCC,
	SPARC_INS_SMUL,
	SPARC_INS_SRAX,
	SPARC_INS_SRA,
	SPARC_INS_SRLX,
	SPARC_INS_SRL,
	SPARC_INS_STBAR,
	SPARC_INS_STB,
	SPARC_INS_STD,
	SPARC_INS_ST,
	SPARC_INS_STH,
	SPARC_INS_STQ,
	SPARC_INS_STX,
	SPARC_INS_SUBCC,
	SPARC_INS_SUBX,
	SPARC_INS_SUBXCC,
	SPARC_INS_SUB,
	SPARC_INS_SWAP,
	SPARC_INS_TADDCCTV,
	SPARC_INS_TADDCC,
	SPARC_INS_T,
	SPARC_INS_TSUBCCTV,
	SPARC_INS_TSUBCC,
	SPARC_INS_UDIVCC,
	SPARC_INS_UDIVX,
	SPARC_INS_UDIV,
	SPARC_INS_UMULCC,
	SPARC_INS_UMULXHI,
	SPARC_INS_UMUL,
	SPARC_INS_UNIMP,
	SPARC_INS_FCMPED,
	SPARC_INS_FCMPEQ,
	SPARC_INS_FCMPES,
	SPARC_INS_WR,
	SPARC_INS_XMULX,
	SPARC_INS_XMULXHI,
	SPARC_INS_XNORCC,
	SPARC_INS_XNOR,
	SPARC_INS_XORCC,
	SPARC_INS_XOR,

	// alias instructions
	SPARC_INS_RET,
	SPARC_INS_RETL,

	SPARC_INS_ENDING,   // <-- mark the end of the list of instructions
} sparc_insn;

/// Group of SPARC instructions
typedef enum sparc_insn_group {
	SPARC_GRP_INVALID = 0, ///< = CS_GRP_INVALID

	// Generic groups
	// all jump instructions (conditional+direct+indirect jumps)
	SPARC_GRP_JUMP,	///< = CS_GRP_JUMP

	// Architecture-specific groups
	SPARC_GRP_HARDQUAD = 128,
	SPARC_GRP_V9,
	SPARC_GRP_VIS,
	SPARC_GRP_VIS2,
	SPARC_GRP_VIS3, 
	SPARC_GRP_32BIT,
	SPARC_GRP_64BIT,

	SPARC_GRP_ENDING,   // <-- mark the end of the list of groups
} sparc_insn_group;

#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/include/capstone/capstone/systemz.h`:

```h
#ifndef CAPSTONE_SYSTEMZ_H
#define CAPSTONE_SYSTEMZ_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2014-2015 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

/// Enums corresponding to SystemZ condition codes
typedef enum sysz_cc {
	SYSZ_CC_INVALID = 0,	///< invalid CC (default)

	SYSZ_CC_O,
	SYSZ_CC_H,
	SYSZ_CC_NLE,
	SYSZ_CC_L,
	SYSZ_CC_NHE,
	SYSZ_CC_LH,
	SYSZ_CC_NE,
	SYSZ_CC_E,
	SYSZ_CC_NLH,
	SYSZ_CC_HE,
	SYSZ_CC_NL,
	SYSZ_CC_LE,
	SYSZ_CC_NH,
	SYSZ_CC_NO,
} sysz_cc;

/// Operand type for instruction's operands
typedef enum sysz_op_type {
	SYSZ_OP_INVALID = 0, ///< = CS_OP_INVALID (Uninitialized).
	SYSZ_OP_REG, ///< = CS_OP_REG (Register operand).
	SYSZ_OP_IMM, ///< = CS_OP_IMM (Immediate operand).
	SYSZ_OP_MEM, ///< = CS_OP_MEM (Memory operand).
	SYSZ_OP_ACREG = 64,	///< Access register operand.
} sysz_op_type;

/// SystemZ registers
typedef enum sysz_reg {
	SYSZ_REG_INVALID = 0,

	SYSZ_REG_0, 
	SYSZ_REG_1, 
	SYSZ_REG_2, 
	SYSZ_REG_3, 
	SYSZ_REG_4, 
	SYSZ_REG_5, 
	SYSZ_REG_6, 
	SYSZ_REG_7, 
	SYSZ_REG_8, 
	SYSZ_REG_9, 
	SYSZ_REG_10,
	SYSZ_REG_11,
	SYSZ_REG_12,
	SYSZ_REG_13,
	SYSZ_REG_14,
	SYSZ_REG_15,
	SYSZ_REG_CC,
	SYSZ_REG_F0,
	SYSZ_REG_F1,
	SYSZ_REG_F2,
	SYSZ_REG_F3,
	SYSZ_REG_F4,
	SYSZ_REG_F5,
	SYSZ_REG_F6,
	SYSZ_REG_F7,
	SYSZ_REG_F8,
	SYSZ_REG_F9,
	SYSZ_REG_F10,
	SYSZ_REG_F11,
	SYSZ_REG_F12,
	SYSZ_REG_F13,
	SYSZ_REG_F14,
	SYSZ_REG_F15,

	SYSZ_REG_R0L,

	SYSZ_REG_ENDING,
} sysz_reg;

/// Instruction's operand referring to memory
/// This is associated with SYSZ_OP_MEM operand type above
typedef struct sysz_op_mem {
	uint8_t base;		///< base register, can be safely interpreted as
				///< a value of type `sysz_reg`, but it is only
				///< one byte wide
	uint8_t index;		///< index register, same conditions apply here
	uint64_t length;	///< BDLAddr operand
	int64_t disp;	///< displacement/offset value
} sysz_op_mem;

/// Instruction operand
typedef struct cs_sysz_op {
	sysz_op_type type;	///< operand type
	union {
		sysz_reg reg;		///< register value for REG operand
		int64_t imm;		///< immediate value for IMM operand
		sysz_op_mem mem;	///< base/disp value for MEM operand
	};
} cs_sysz_op;

// Instruction structure
typedef struct cs_sysz {
	sysz_cc cc;		///< Code condition
	/// Number of operands of this instruction,
	/// or 0 when instruction has no operand.
	uint8_t op_count;
	cs_sysz_op operands[6]; ///< operands for this instruction.
} cs_sysz;

/// SystemZ instruction
typedef enum sysz_insn {
	SYSZ_INS_INVALID = 0,

	SYSZ_INS_A,
	SYSZ_INS_ADB,
	SYSZ_INS_ADBR,
	SYSZ_INS_AEB,
	SYSZ_INS_AEBR,
	SYSZ_INS_AFI,
	SYSZ_INS_AG,
	SYSZ_INS_AGF,
	SYSZ_INS_AGFI,
	SYSZ_INS_AGFR,
	SYSZ_INS_AGHI,
	SYSZ_INS_AGHIK,
	SYSZ_INS_AGR,
	SYSZ_INS_AGRK,
	SYSZ_INS_AGSI,
	SYSZ_INS_AH,
	SYSZ_INS_AHI,
	SYSZ_INS_AHIK,
	SYSZ_INS_AHY,
	SYSZ_INS_AIH,
	SYSZ_INS_AL,
	SYSZ_INS_ALC,
	SYSZ_INS_ALCG,
	SYSZ_INS_ALCGR,
	SYSZ_INS_ALCR,
	SYSZ_INS_ALFI,
	SYSZ_INS_ALG,
	SYSZ_INS_ALGF,
	SYSZ_INS_ALGFI,
	SYSZ_INS_ALGFR,
	SYSZ_INS_ALGHSIK,
	SYSZ_INS_ALGR,
	SYSZ_INS_ALGRK,
	SYSZ_INS_ALHSIK,
	SYSZ_INS_ALR,
	SYSZ_INS_ALRK,
	SYSZ_INS_ALY,
	SYSZ_INS_AR,
	SYSZ_INS_ARK,
	SYSZ_INS_ASI,
	SYSZ_INS_AXBR,
	SYSZ_INS_AY,
	SYSZ_INS_BCR,
	SYSZ_INS_BRC,
	SYSZ_INS_BRCL,
	SYSZ_INS_CGIJ,
	SYSZ_INS_CGRJ,
	SYSZ_INS_CIJ,
	SYSZ_INS_CLGIJ,
	SYSZ_INS_CLGRJ,
	SYSZ_INS_CLIJ,
	SYSZ_INS_CLRJ,
	SYSZ_INS_CRJ,
	SYSZ_INS_BER,
	SYSZ_INS_JE,
	SYSZ_INS_JGE,
	SYSZ_INS_LOCE,
	SYSZ_INS_LOCGE,
	SYSZ_INS_LOCGRE,
	SYSZ_INS_LOCRE,
	SYSZ_INS_STOCE,
	SYSZ_INS_STOCGE,
	SYSZ_INS_BHR,
	SYSZ_INS_BHER,
	SYSZ_INS_JHE,
	SYSZ_INS_JGHE,
	SYSZ_INS_LOCHE,
	SYSZ_INS_LOCGHE,
	SYSZ_INS_LOCGRHE,
	SYSZ_INS_LOCRHE,
	SYSZ_INS_STOCHE,
	SYSZ_INS_STOCGHE,
	SYSZ_INS_JH,
	SYSZ_INS_JGH,
	SYSZ_INS_LOCH,
	SYSZ_INS_LOCGH,
	SYSZ_INS_LOCGRH,
	SYSZ_INS_LOCRH,
	SYSZ_INS_STOCH,
	SYSZ_INS_STOCGH,
	SYSZ_INS_CGIJNLH,
	SYSZ_INS_CGRJNLH,
	SYSZ_INS_CIJNLH,
	SYSZ_INS_CLGIJNLH,
	SYSZ_INS_CLGRJNLH,
	SYSZ_INS_CLIJNLH,
	SYSZ_INS_CLRJNLH,
	SYSZ_INS_CRJNLH,
	SYSZ_INS_CGIJE,
	SYSZ_INS_CGRJE,
	SYSZ_INS_CIJE,
	SYSZ_INS_CLGIJE,
	SYSZ_INS_CLGRJE,
	SYSZ_INS_CLIJE,
	SYSZ_INS_CLRJE,
	SYSZ_INS_CRJE,
	SYSZ_INS_CGIJNLE,
	SYSZ_INS_CGRJNLE,
	SYSZ_INS_CIJNLE,
	SYSZ_INS_CLGIJNLE,
	SYSZ_INS_CLGRJNLE,
	SYSZ_INS_CLIJNLE,
	SYSZ_INS_CLRJNLE,
	SYSZ_INS_CRJNLE,
	SYSZ_INS_CGIJH,
	SYSZ_INS_CGRJH,
	SYSZ_INS_CIJH,
	SYSZ_INS_CLGIJH,
	SYSZ_INS_CLGRJH,
	SYSZ_INS_CLIJH,
	SYSZ_INS_CLRJH,
	SYSZ_INS_CRJH,
	SYSZ_INS_CGIJNL,
	SYSZ_INS_CGRJNL,
	SYSZ_INS_CIJNL,
	SYSZ_INS_CLGIJNL,
	SYSZ_INS_CLGRJNL,
	SYSZ_INS_CLIJNL,
	SYSZ_INS_CLRJNL,
	SYSZ_INS_CRJNL,
	SYSZ_INS_CGIJHE,
	SYSZ_INS_CGRJHE,
	SYSZ_INS_CIJHE,
	SYSZ_INS_CLGIJHE,
	SYSZ_INS_CLGRJHE,
	SYSZ_INS_CLIJHE,
	SYSZ_INS_CLRJHE,
	SYSZ_INS_CRJHE,
	SYSZ_INS_CGIJNHE,
	SYSZ_INS_CGRJNHE,
	SYSZ_INS_CIJNHE,
	SYSZ_INS_CLGIJNHE,
	SYSZ_INS_CLGRJNHE,
	SYSZ_INS_CLIJNHE,
	SYSZ_INS_CLRJNHE,
	SYSZ_INS_CRJNHE,
	SYSZ_INS_CGIJL,
	SYSZ_INS_CGRJL,
	SYSZ_INS_CIJL,
	SYSZ_INS_CLGIJL,
	SYSZ_INS_CLGRJL,
	SYSZ_INS_CLIJL,
	SYSZ_INS_CLRJL,
	SYSZ_INS_CRJL,
	SYSZ_INS_CGIJNH,
	SYSZ_INS_CGRJNH,
	SYSZ_INS_CIJNH,
	SYSZ_INS_CLGIJNH,
	SYSZ_INS_CLGRJNH,
	SYSZ_INS_CLIJNH,
	SYSZ_INS_CLRJNH,
	SYSZ_INS_CRJNH,
	SYSZ_INS_CGIJLE,
	SYSZ_INS_CGRJLE,
	SYSZ_INS_CIJLE,
	SYSZ_INS_CLGIJLE,
	SYSZ_INS_CLGRJLE,
	SYSZ_INS_CLIJLE,
	SYSZ_INS_CLRJLE,
	SYSZ_INS_CRJLE,
	SYSZ_INS_CGIJNE,
	SYSZ_INS_CGRJNE,
	SYSZ_INS_CIJNE,
	SYSZ_INS_CLGIJNE,
	SYSZ_INS_CLGRJNE,
	SYSZ_INS_CLIJNE,
	SYSZ_INS_CLRJNE,
	SYSZ_INS_CRJNE,
	SYSZ_INS_CGIJLH,
	SYSZ_INS_CGRJLH,
	SYSZ_INS_CIJLH,
	SYSZ_INS_CLGIJLH,
	SYSZ_INS_CLGRJLH,
	SYSZ_INS_CLIJLH,
	SYSZ_INS_CLRJLH,
	SYSZ_INS_CRJLH,
	SYSZ_INS_BLR,
	SYSZ_INS_BLER,
	SYSZ_INS_JLE,
	SYSZ_INS_JGLE,
	SYSZ_INS_LOCLE,
	SYSZ_INS_LOCGLE,
	SYSZ_INS_LOCGRLE,
	SYSZ_INS_LOCRLE,
	SYSZ_INS_STOCLE,
	SYSZ_INS_STOCGLE,
	SYSZ_INS_BLHR,
	SYSZ_INS_JLH,
	SYSZ_INS_JGLH,
	SYSZ_INS_LOCLH,
	SYSZ_INS_LOCGLH,
	SYSZ_INS_LOCGRLH,
	SYSZ_INS_LOCRLH,
	SYSZ_INS_STOCLH,
	SYSZ_INS_STOCGLH,
	SYSZ_INS_JL,
	SYSZ_INS_JGL,
	SYSZ_INS_LOCL,
	SYSZ_INS_LOCGL,
	SYSZ_INS_LOCGRL,
	SYSZ_INS_LOCRL,
	SYSZ_INS_LOC,
	SYSZ_INS_LOCG,
	SYSZ_INS_LOCGR,
	SYSZ_INS_LOCR,
	SYSZ_INS_STOCL,
	SYSZ_INS_STOCGL,
	SYSZ_INS_BNER,
	SYSZ_INS_JNE,
	SYSZ_INS_JGNE,
	SYSZ_INS_LOCNE,
	SYSZ_INS_LOCGNE,
	SYSZ_INS_LOCGRNE,
	SYSZ_INS_LOCRNE,
	SYSZ_INS_STOCNE,
	SYSZ_INS_STOCGNE,
	SYSZ_INS_BNHR,
	SYSZ_INS_BNHER,
	SYSZ_INS_JNHE,
	SYSZ_INS_JGNHE,
	SYSZ_INS_LOCNHE,
	SYSZ_INS_LOCGNHE,
	SYSZ_INS_LOCGRNHE,
	SYSZ_INS_LOCRNHE,
	SYSZ_INS_STOCNHE,
	SYSZ_INS_STOCGNHE,
	SYSZ_INS_JNH,
	SYSZ_INS_JGNH,
	SYSZ_INS_LOCNH,
	SYSZ_INS_LOCGNH,
	SYSZ_INS_LOCGRNH,
	SYSZ_INS_LOCRNH,
	SYSZ_INS_STOCNH,
	SYSZ_INS_STOCGNH,
	SYSZ_INS_BNLR,
	SYSZ_INS_BNLER,
	SYSZ_INS_JNLE,
	SYSZ_INS_JGNLE,
	SYSZ_INS_LOCNLE,
	SYSZ_INS_LOCGNLE,
	SYSZ_INS_LOCGRNLE,
	SYSZ_INS_LOCRNLE,
	SYSZ_INS_STOCNLE,
	SYSZ_INS_STOCGNLE,
	SYSZ_INS_BNLHR,
	SYSZ_INS_JNLH,
	SYSZ_INS_JGNLH,
	SYSZ_INS_LOCNLH,
	SYSZ_INS_LOCGNLH,
	SYSZ_INS_LOCGRNLH,
	SYSZ_INS_LOCRNLH,
	SYSZ_INS_STOCNLH,
	SYSZ_INS_STOCGNLH,
	SYSZ_INS_JNL,
	SYSZ_INS_JGNL,
	SYSZ_INS_LOCNL,
	SYSZ_INS_LOCGNL,
	SYSZ_INS_LOCGRNL,
	SYSZ_INS_LOCRNL,
	SYSZ_INS_STOCNL,
	SYSZ_INS_STOCGNL,
	SYSZ_INS_BNOR,
	SYSZ_INS_JNO,
	SYSZ_INS_JGNO,
	SYSZ_INS_LOCNO,
	SYSZ_INS_LOCGNO,
	SYSZ_INS_LOCGRNO,
	SYSZ_INS_LOCRNO,
	SYSZ_INS_STOCNO,
	SYSZ_INS_STOCGNO,
	SYSZ_INS_BOR,
	SYSZ_INS_JO,
	SYSZ_INS_JGO,
	SYSZ_INS_LOCO,
	SYSZ_INS_LOCGO,
	SYSZ_INS_LOCGRO,
	SYSZ_INS_LOCRO,
	SYSZ_INS_STOCO,
	SYSZ_INS_STOCGO,
	SYSZ_INS_STOC,
	SYSZ_INS_STOCG,
	SYSZ_INS_BASR,
	SYSZ_INS_BR,
	SYSZ_INS_BRAS,
	SYSZ_INS_BRASL,
	SYSZ_INS_J,
	SYSZ_INS_JG,
	SYSZ_INS_BRCT,
	SYSZ_INS_BRCTG,
	SYSZ_INS_C,
	SYSZ_INS_CDB,
	SYSZ_INS_CDBR,
	SYSZ_INS_CDFBR,
	SYSZ_INS_CDGBR,
	SYSZ_INS_CDLFBR,
	SYSZ_INS_CDLGBR,
	SYSZ_INS_CEB,
	SYSZ_INS_CEBR,
	SYSZ_INS_CEFBR,
	SYSZ_INS_CEGBR,
	SYSZ_INS_CELFBR,
	SYSZ_INS_CELGBR,
	SYSZ_INS_CFDBR,
	SYSZ_INS_CFEBR,
	SYSZ_INS_CFI,
	SYSZ_INS_CFXBR,
	SYSZ_INS_CG,
	SYSZ_INS_CGDBR,
	SYSZ_INS_CGEBR,
	SYSZ_INS_CGF,
	SYSZ_INS_CGFI,
	SYSZ_INS_CGFR,
	SYSZ_INS_CGFRL,
	SYSZ_INS_CGH,
	SYSZ_INS_CGHI,
	SYSZ_INS_CGHRL,
	SYSZ_INS_CGHSI,
	SYSZ_INS_CGR,
	SYSZ_INS_CGRL,
	SYSZ_INS_CGXBR,
	SYSZ_INS_CH,
	SYSZ_INS_CHF,
	SYSZ_INS_CHHSI,
	SYSZ_INS_CHI,
	SYSZ_INS_CHRL,
	SYSZ_INS_CHSI,
	SYSZ_INS_CHY,
	SYSZ_INS_CIH,
	SYSZ_INS_CL,
	SYSZ_INS_CLC,
	SYSZ_INS_CLFDBR,
	SYSZ_INS_CLFEBR,
	SYSZ_INS_CLFHSI,
	SYSZ_INS_CLFI,
	SYSZ_INS_CLFXBR,
	SYSZ_INS_CLG,
	SYSZ_INS_CLGDBR,
	SYSZ_INS_CLGEBR,
	SYSZ_INS_CLGF,
	SYSZ_INS_CLGFI,
	SYSZ_INS_CLGFR,
	SYSZ_INS_CLGFRL,
	SYSZ_INS_CLGHRL,
	SYSZ_INS_CLGHSI,
	SYSZ_INS_CLGR,
	SYSZ_INS_CLGRL,
	SYSZ_INS_CLGXBR,
	SYSZ_INS_CLHF,
	SYSZ_INS_CLHHSI,
	SYSZ_INS_CLHRL,
	SYSZ_INS_CLI,
	SYSZ_INS_CLIH,
	SYSZ_INS_CLIY,
	SYSZ_INS_CLR,
	SYSZ_INS_CLRL,
	SYSZ_INS_CLST,
	SYSZ_INS_CLY,
	SYSZ_INS_CPSDR,
	SYSZ_INS_CR,
	SYSZ_INS_CRL,
	SYSZ_INS_CS,
	SYSZ_INS_CSG,
	SYSZ_INS_CSY,
	SYSZ_INS_CXBR,
	SYSZ_INS_CXFBR,
	SYSZ_INS_CXGBR,
	SYSZ_INS_CXLFBR,
	SYSZ_INS_CXLGBR,
	SYSZ_INS_CY,
	SYSZ_INS_DDB,
	SYSZ_INS_DDBR,
	SYSZ_INS_DEB,
	SYSZ_INS_DEBR,
	SYSZ_INS_DL,
	SYSZ_INS_DLG,
	SYSZ_INS_DLGR,
	SYSZ_INS_DLR,
	SYSZ_INS_DSG,
	SYSZ_INS_DSGF,
	SYSZ_INS_DSGFR,
	SYSZ_INS_DSGR,
	SYSZ_INS_DXBR,
	SYSZ_INS_EAR,
	SYSZ_INS_FIDBR,
	SYSZ_INS_FIDBRA,
	SYSZ_INS_FIEBR,
	SYSZ_INS_FIEBRA,
	SYSZ_INS_FIXBR,
	SYSZ_INS_FIXBRA,
	SYSZ_INS_FLOGR,
	SYSZ_INS_IC,
	SYSZ_INS_ICY,
	SYSZ_INS_IIHF,
	SYSZ_INS_IIHH,
	SYSZ_INS_IIHL,
	SYSZ_INS_IILF,
	SYSZ_INS_IILH,
	SYSZ_INS_IILL,
	SYSZ_INS_IPM,
	SYSZ_INS_L,
	SYSZ_INS_LA,
	SYSZ_INS_LAA,
	SYSZ_INS_LAAG,
	SYSZ_INS_LAAL,
	SYSZ_INS_LAALG,
	SYSZ_INS_LAN,
	SYSZ_INS_LANG,
	SYSZ_INS_LAO,
	SYSZ_INS_LAOG,
	SYSZ_INS_LARL,
	SYSZ_INS_LAX,
	SYSZ_INS_LAXG,
	SYSZ_INS_LAY,
	SYSZ_INS_LB,
	SYSZ_INS_LBH,
	SYSZ_INS_LBR,
	SYSZ_INS_LCDBR,
	SYSZ_INS_LCEBR,
	SYSZ_INS_LCGFR,
	SYSZ_INS_LCGR,
	SYSZ_INS_LCR,
	SYSZ_INS_LCXBR,
	SYSZ_INS_LD,
	SYSZ_INS_LDEB,
	SYSZ_INS_LDEBR,
	SYSZ_INS_LDGR,
	SYSZ_INS_LDR,
	SYSZ_INS_LDXBR,
	SYSZ_INS_LDXBRA,
	SYSZ_INS_LDY,
	SYSZ_INS_LE,
	SYSZ_INS_LEDBR,
	SYSZ_INS_LEDBRA,
	SYSZ_INS_LER,
	SYSZ_INS_LEXBR,
	SYSZ_INS_LEXBRA,
	SYSZ_INS_LEY,
	SYSZ_INS_LFH,
	SYSZ_INS_LG,
	SYSZ_INS_LGB,
	SYSZ_INS_LGBR,
	SYSZ_INS_LGDR,
	SYSZ_INS_LGF,
	SYSZ_INS_LGFI,
	SYSZ_INS_LGFR,
	SYSZ_INS_LGFRL,
	SYSZ_INS_LGH,
	SYSZ_INS_LGHI,
	SYSZ_INS_LGHR,
	SYSZ_INS_LGHRL,
	SYSZ_INS_LGR,
	SYSZ_INS_LGRL,
	SYSZ_INS_LH,
	SYSZ_INS_LHH,
	SYSZ_INS_LHI,
	SYSZ_INS_LHR,
	SYSZ_INS_LHRL,
	SYSZ_INS_LHY,
	SYSZ_INS_LLC,
	SYSZ_INS_LLCH,
	SYSZ_INS_LLCR,
	SYSZ_INS_LLGC,
	SYSZ_INS_LLGCR,
	SYSZ_INS_LLGF,
	SYSZ_INS_LLGFR,
	SYSZ_INS_LLGFRL,
	SYSZ_INS_LLGH,
	SYSZ_INS_LLGHR,
	SYSZ_INS_LLGHRL,
	SYSZ_INS_LLH,
	SYSZ_INS_LLHH,
	SYSZ_INS_LLHR,
	SYSZ_INS_LLHRL,
	SYSZ_INS_LLIHF,
	SYSZ_INS_LLIHH,
	SYSZ_INS_LLIHL,
	SYSZ_INS_LLILF,
	SYSZ_INS_LLILH,
	SYSZ_INS_LLILL,
	SYSZ_INS_LMG,
	SYSZ_INS_LNDBR,
	SYSZ_INS_LNEBR,
	SYSZ_INS_LNGFR,
	SYSZ_INS_LNGR,
	SYSZ_INS_LNR,
	SYSZ_INS_LNXBR,
	SYSZ_INS_LPDBR,
	SYSZ_INS_LPEBR,
	SYSZ_INS_LPGFR,
	SYSZ_INS_LPGR,
	SYSZ_INS_LPR,
	SYSZ_INS_LPXBR,
	SYSZ_INS_LR,
	SYSZ_INS_LRL,
	SYSZ_INS_LRV,
	SYSZ_INS_LRVG,
	SYSZ_INS_LRVGR,
	SYSZ_INS_LRVR,
	SYSZ_INS_LT,
	SYSZ_INS_LTDBR,
	SYSZ_INS_LTEBR,
	SYSZ_INS_LTG,
	SYSZ_INS_LTGF,
	SYSZ_INS_LTGFR,
	SYSZ_INS_LTGR,
	SYSZ_INS_LTR,
	SYSZ_INS_LTXBR,
	SYSZ_INS_LXDB,
	SYSZ_INS_LXDBR,
	SYSZ_INS_LXEB,
	SYSZ_INS_LXEBR,
	SYSZ_INS_LXR,
	SYSZ_INS_LY,
	SYSZ_INS_LZDR,
	SYSZ_INS_LZER,
	SYSZ_INS_LZXR,
	SYSZ_INS_MADB,
	SYSZ_INS_MADBR,
	SYSZ_INS_MAEB,
	SYSZ_INS_MAEBR,
	SYSZ_INS_MDB,
	SYSZ_INS_MDBR,
	SYSZ_INS_MDEB,
	SYSZ_INS_MDEBR,
	SYSZ_INS_MEEB,
	SYSZ_INS_MEEBR,
	SYSZ_INS_MGHI,
	SYSZ_INS_MH,
	SYSZ_INS_MHI,
	SYSZ_INS_MHY,
	SYSZ_INS_MLG,
	SYSZ_INS_MLGR,
	SYSZ_INS_MS,
	SYSZ_INS_MSDB,
	SYSZ_INS_MSDBR,
	SYSZ_INS_MSEB,
	SYSZ_INS_MSEBR,
	SYSZ_INS_MSFI,
	SYSZ_INS_MSG,
	SYSZ_INS_MSGF,
	SYSZ_INS_MSGFI,
	SYSZ_INS_MSGFR,
	SYSZ_INS_MSGR,
	SYSZ_INS_MSR,
	SYSZ_INS_MSY,
	SYSZ_INS_MVC,
	SYSZ_INS_MVGHI,
	SYSZ_INS_MVHHI,
	SYSZ_INS_MVHI,
	SYSZ_INS_MVI,
	SYSZ_INS_MVIY,
	SYSZ_INS_MVST,
	SYSZ_INS_MXBR,
	SYSZ_INS_MXDB,
	SYSZ_INS_MXDBR,
	SYSZ_INS_N,
	SYSZ_INS_NC,
	SYSZ_INS_NG,
	SYSZ_INS_NGR,
	SYSZ_INS_NGRK,
	SYSZ_INS_NI,
	SYSZ_INS_NIHF,
	SYSZ_INS_NIHH,
	SYSZ_INS_NIHL,
	SYSZ_INS_NILF,
	SYSZ_INS_NILH,
	SYSZ_INS_NILL,
	SYSZ_INS_NIY,
	SYSZ_INS_NR,
	SYSZ_INS_NRK,
	SYSZ_INS_NY,
	SYSZ_INS_O,
	SYSZ_INS_OC,
	SYSZ_INS_OG,
	SYSZ_INS_OGR,
	SYSZ_INS_OGRK,
	SYSZ_INS_OI,
	SYSZ_INS_OIHF,
	SYSZ_INS_OIHH,
	SYSZ_INS_OIHL,
	SYSZ_INS_OILF,
	SYSZ_INS_OILH,
	SYSZ_INS_OILL,
	SYSZ_INS_OIY,
	SYSZ_INS_OR,
	SYSZ_INS_ORK,
	SYSZ_INS_OY,
	SYSZ_INS_PFD,
	SYSZ_INS_PFDRL,
	SYSZ_INS_RISBG,
	SYSZ_INS_RISBHG,
	SYSZ_INS_RISBLG,
	SYSZ_INS_RLL,
	SYSZ_INS_RLLG,
	SYSZ_INS_RNSBG,
	SYSZ_INS_ROSBG,
	SYSZ_INS_RXSBG,
	SYSZ_INS_S,
	SYSZ_INS_SDB,
	SYSZ_INS_SDBR,
	SYSZ_INS_SEB,
	SYSZ_INS_SEBR,
	SYSZ_INS_SG,
	SYSZ_INS_SGF,
	SYSZ_INS_SGFR,
	SYSZ_INS_SGR,
	SYSZ_INS_SGRK,
	SYSZ_INS_SH,
	SYSZ_INS_SHY,
	SYSZ_INS_SL,
	SYSZ_INS_SLB,
	SYSZ_INS_SLBG,
	SYSZ_INS_SLBR,
	SYSZ_INS_SLFI,
	SYSZ_INS_SLG,
	SYSZ_INS_SLBGR,
	SYSZ_INS_SLGF,
	SYSZ_INS_SLGFI,
	SYSZ_INS_SLGFR,
	SYSZ_INS_SLGR,
	SYSZ_INS_SLGRK,
	SYSZ_INS_SLL,
	SYSZ_INS_SLLG,
	SYSZ_INS_SLLK,
	SYSZ_INS_SLR,
	SYSZ_INS_SLRK,
	SYSZ_INS_SLY,
	SYSZ_INS_SQDB,
	SYSZ_INS_SQDBR,
	SYSZ_INS_SQEB,
	SYSZ_INS_SQEBR,
	SYSZ_INS_SQXBR,
	SYSZ_INS_SR,
	SYSZ_INS_SRA,
	SYSZ_INS_SRAG,
	SYSZ_INS_SRAK,
	SYSZ_INS_SRK,
	SYSZ_INS_SRL,
	SYSZ_INS_SRLG,
	SYSZ_INS_SRLK,
	SYSZ_INS_SRST,
	SYSZ_INS_ST,
	SYSZ_INS_STC,
	SYSZ_INS_STCH,
	SYSZ_INS_STCY,
	SYSZ_INS_STD,
	SYSZ_INS_STDY,
	SYSZ_INS_STE,
	SYSZ_INS_STEY,
	SYSZ_INS_STFH,
	SYSZ_INS_STG,
	SYSZ_INS_STGRL,
	SYSZ_INS_STH,
	SYSZ_INS_STHH,
	SYSZ_INS_STHRL,
	SYSZ_INS_STHY,
	SYSZ_INS_STMG,
	SYSZ_INS_STRL,
	SYSZ_INS_STRV,
	SYSZ_INS_STRVG,
	SYSZ_INS_STY,
	SYSZ_INS_SXBR,
	SYSZ_INS_SY,
	SYSZ_INS_TM,
	SYSZ_INS_TMHH,
	SYSZ_INS_TMHL,
	SYSZ_INS_TMLH,
	SYSZ_INS_TMLL,
	SYSZ_INS_TMY,
	SYSZ_INS_X,
	SYSZ_INS_XC,
	SYSZ_INS_XG,
	SYSZ_INS_XGR,
	SYSZ_INS_XGRK,
	SYSZ_INS_XI,
	SYSZ_INS_XIHF,
	SYSZ_INS_XILF,
	SYSZ_INS_XIY,
	SYSZ_INS_XR,
	SYSZ_INS_XRK,
	SYSZ_INS_XY,

	SYSZ_INS_ENDING,   // <-- mark the end of the list of instructions
} sysz_insn;

/// Group of SystemZ instructions
typedef enum sysz_insn_group {
	SYSZ_GRP_INVALID = 0, ///< = CS_GRP_INVALID

	// Generic groups
	// all jump instructions (conditional+direct+indirect jumps)
	SYSZ_GRP_JUMP,	///< = CS_GRP_JUMP

	// Architecture-specific groups
	SYSZ_GRP_DISTINCTOPS = 128,
	SYSZ_GRP_FPEXTENSION,
	SYSZ_GRP_HIGHWORD,
	SYSZ_GRP_INTERLOCKEDACCESS1,
	SYSZ_GRP_LOADSTOREONCOND,

	SYSZ_GRP_ENDING,   // <-- mark the end of the list of groups
} sysz_insn_group;

#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/include/capstone/capstone/tms320c64x.h`:

```h
/* Capstone Disassembly Engine */
/* TMS320C64x Backend by Fotis Loukos <me@fotisl.com> 2016 */

#ifndef CAPSTONE_TMS320C64X_H
#define CAPSTONE_TMS320C64X_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

typedef enum tms320c64x_op_type {
	TMS320C64X_OP_INVALID = 0, ///< = CS_OP_INVALID (Uninitialized).
	TMS320C64X_OP_REG, ///< = CS_OP_REG (Register operand).
	TMS320C64X_OP_IMM, ///< = CS_OP_IMM (Immediate operand).
	TMS320C64X_OP_MEM, ///< = CS_OP_MEM (Memory operand).
	TMS320C64X_OP_REGPAIR = 64, ///< Register pair for double word ops
} tms320c64x_op_type;

typedef enum tms320c64x_mem_disp {
	TMS320C64X_MEM_DISP_INVALID = 0,
	TMS320C64X_MEM_DISP_CONSTANT,
	TMS320C64X_MEM_DISP_REGISTER,
} tms320c64x_mem_disp;

typedef enum tms320c64x_mem_dir {
	TMS320C64X_MEM_DIR_INVALID = 0,
	TMS320C64X_MEM_DIR_FW,
	TMS320C64X_MEM_DIR_BW,
} tms320c64x_mem_dir;

typedef enum tms320c64x_mem_mod {
	TMS320C64X_MEM_MOD_INVALID = 0,
	TMS320C64X_MEM_MOD_NO,
	TMS320C64X_MEM_MOD_PRE,
	TMS320C64X_MEM_MOD_POST,
} tms320c64x_mem_mod;

typedef struct tms320c64x_op_mem {
	unsigned int	base;	///< base register
	unsigned int	disp;	///< displacement/offset value
	unsigned int	unit;	///< unit of base and offset register
	unsigned int	scaled;	///< offset scaled
	unsigned int	disptype;	///< displacement type
	unsigned int	direction;	///< direction
	unsigned int	modify;	///< modification
} tms320c64x_op_mem;

typedef struct cs_tms320c64x_op {
	tms320c64x_op_type type;	///< operand type
	union {
		unsigned int reg;	///< register value for REG operand or first register for REGPAIR operand
		int32_t imm;		///< immediate value for IMM operand
		tms320c64x_op_mem mem;		///< base/disp value for MEM operand
	};
} cs_tms320c64x_op;

typedef struct cs_tms320c64x {
	uint8_t op_count;
	cs_tms320c64x_op operands[8]; ///< operands for this instruction.
	struct {
		unsigned int reg;
		unsigned int zero;
	} condition;
	struct {
		unsigned int unit;
		unsigned int side;
		unsigned int crosspath;
	} funit;
	unsigned int parallel;
} cs_tms320c64x;

typedef enum tms320c64x_reg {
	TMS320C64X_REG_INVALID = 0,

	TMS320C64X_REG_AMR,
	TMS320C64X_REG_CSR,
	TMS320C64X_REG_DIER,
	TMS320C64X_REG_DNUM,
	TMS320C64X_REG_ECR,
	TMS320C64X_REG_GFPGFR,
	TMS320C64X_REG_GPLYA,
	TMS320C64X_REG_GPLYB,
	TMS320C64X_REG_ICR,
	TMS320C64X_REG_IER,
	TMS320C64X_REG_IERR,
	TMS320C64X_REG_ILC,
	TMS320C64X_REG_IRP,
	TMS320C64X_REG_ISR,
	TMS320C64X_REG_ISTP,
	TMS320C64X_REG_ITSR,
	TMS320C64X_REG_NRP,
	TMS320C64X_REG_NTSR,
	TMS320C64X_REG_REP,
	TMS320C64X_REG_RILC,
	TMS320C64X_REG_SSR,
	TMS320C64X_REG_TSCH,
	TMS320C64X_REG_TSCL,
	TMS320C64X_REG_TSR,
	TMS320C64X_REG_A0,
	TMS320C64X_REG_A1,
	TMS320C64X_REG_A2,
	TMS320C64X_REG_A3,
	TMS320C64X_REG_A4,
	TMS320C64X_REG_A5,
	TMS320C64X_REG_A6,
	TMS320C64X_REG_A7,
	TMS320C64X_REG_A8,
	TMS320C64X_REG_A9,
	TMS320C64X_REG_A10,
	TMS320C64X_REG_A11,
	TMS320C64X_REG_A12,
	TMS320C64X_REG_A13,
	TMS320C64X_REG_A14,
	TMS320C64X_REG_A15,
	TMS320C64X_REG_A16,
	TMS320C64X_REG_A17,
	TMS320C64X_REG_A18,
	TMS320C64X_REG_A19,
	TMS320C64X_REG_A20,
	TMS320C64X_REG_A21,
	TMS320C64X_REG_A22,
	TMS320C64X_REG_A23,
	TMS320C64X_REG_A24,
	TMS320C64X_REG_A25,
	TMS320C64X_REG_A26,
	TMS320C64X_REG_A27,
	TMS320C64X_REG_A28,
	TMS320C64X_REG_A29,
	TMS320C64X_REG_A30,
	TMS320C64X_REG_A31,
	TMS320C64X_REG_B0,
	TMS320C64X_REG_B1,
	TMS320C64X_REG_B2,
	TMS320C64X_REG_B3,
	TMS320C64X_REG_B4,
	TMS320C64X_REG_B5,
	TMS320C64X_REG_B6,
	TMS320C64X_REG_B7,
	TMS320C64X_REG_B8,
	TMS320C64X_REG_B9,
	TMS320C64X_REG_B10,
	TMS320C64X_REG_B11,
	TMS320C64X_REG_B12,
	TMS320C64X_REG_B13,
	TMS320C64X_REG_B14,
	TMS320C64X_REG_B15,
	TMS320C64X_REG_B16,
	TMS320C64X_REG_B17,
	TMS320C64X_REG_B18,
	TMS320C64X_REG_B19,
	TMS320C64X_REG_B20,
	TMS320C64X_REG_B21,
	TMS320C64X_REG_B22,
	TMS320C64X_REG_B23,
	TMS320C64X_REG_B24,
	TMS320C64X_REG_B25,
	TMS320C64X_REG_B26,
	TMS320C64X_REG_B27,
	TMS320C64X_REG_B28,
	TMS320C64X_REG_B29,
	TMS320C64X_REG_B30,
	TMS320C64X_REG_B31,
	TMS320C64X_REG_PCE1,

	TMS320C64X_REG_ENDING,	// <-- mark the end of the list of registers

	// Alias registers
	TMS320C64X_REG_EFR = TMS320C64X_REG_ECR,
	TMS320C64X_REG_IFR = TMS320C64X_REG_ISR,
} tms320c64x_reg;

typedef enum tms320c64x_insn {
	TMS320C64X_INS_INVALID = 0,

	TMS320C64X_INS_ABS,
	TMS320C64X_INS_ABS2,
	TMS320C64X_INS_ADD,
	TMS320C64X_INS_ADD2,
	TMS320C64X_INS_ADD4,
	TMS320C64X_INS_ADDAB,
	TMS320C64X_INS_ADDAD,
	TMS320C64X_INS_ADDAH,
	TMS320C64X_INS_ADDAW,
	TMS320C64X_INS_ADDK,
	TMS320C64X_INS_ADDKPC,
	TMS320C64X_INS_ADDU,
	TMS320C64X_INS_AND,
	TMS320C64X_INS_ANDN,
	TMS320C64X_INS_AVG2,
	TMS320C64X_INS_AVGU4,
	TMS320C64X_INS_B,
	TMS320C64X_INS_BDEC,
	TMS320C64X_INS_BITC4,
	TMS320C64X_INS_BNOP,
	TMS320C64X_INS_BPOS,
	TMS320C64X_INS_CLR,
	TMS320C64X_INS_CMPEQ,
	TMS320C64X_INS_CMPEQ2,
	TMS320C64X_INS_CMPEQ4,
	TMS320C64X_INS_CMPGT,
	TMS320C64X_INS_CMPGT2,
	TMS320C64X_INS_CMPGTU4,
	TMS320C64X_INS_CMPLT,
	TMS320C64X_INS_CMPLTU,
	TMS320C64X_INS_DEAL,
	TMS320C64X_INS_DOTP2,
	TMS320C64X_INS_DOTPN2,
	TMS320C64X_INS_DOTPNRSU2,
	TMS320C64X_INS_DOTPRSU2,
	TMS320C64X_INS_DOTPSU4,
	TMS320C64X_INS_DOTPU4,
	TMS320C64X_INS_EXT,
	TMS320C64X_INS_EXTU,
	TMS320C64X_INS_GMPGTU,
	TMS320C64X_INS_GMPY4,
	TMS320C64X_INS_LDB,
	TMS320C64X_INS_LDBU,
	TMS320C64X_INS_LDDW,
	TMS320C64X_INS_LDH,
	TMS320C64X_INS_LDHU,
	TMS320C64X_INS_LDNDW,
	TMS320C64X_INS_LDNW,
	TMS320C64X_INS_LDW,
	TMS320C64X_INS_LMBD,
	TMS320C64X_INS_MAX2,
	TMS320C64X_INS_MAXU4,
	TMS320C64X_INS_MIN2,
	TMS320C64X_INS_MINU4,
	TMS320C64X_INS_MPY,
	TMS320C64X_INS_MPY2,
	TMS320C64X_INS_MPYH,
	TMS320C64X_INS_MPYHI,
	TMS320C64X_INS_MPYHIR,
	TMS320C64X_INS_MPYHL,
	TMS320C64X_INS_MPYHLU,
	TMS320C64X_INS_MPYHSLU,
	TMS320C64X_INS_MPYHSU,
	TMS320C64X_INS_MPYHU,
	TMS320C64X_INS_MPYHULS,
	TMS320C64X_INS_MPYHUS,
	TMS320C64X_INS_MPYLH,
	TMS320C64X_INS_MPYLHU,
	TMS320C64X_INS_MPYLI,
	TMS320C64X_INS_MPYLIR,
	TMS320C64X_INS_MPYLSHU,
	TMS320C64X_INS_MPYLUHS,
	TMS320C64X_INS_MPYSU,
	TMS320C64X_INS_MPYSU4,
	TMS320C64X_INS_MPYU,
	TMS320C64X_INS_MPYU4,
	TMS320C64X_INS_MPYUS,
	TMS320C64X_INS_MVC,
	TMS320C64X_INS_MVD,
	TMS320C64X_INS_MVK,
	TMS320C64X_INS_MVKL,
	TMS320C64X_INS_MVKLH,
	TMS320C64X_INS_NOP,
	TMS320C64X_INS_NORM,
	TMS320C64X_INS_OR,
	TMS320C64X_INS_PACK2,
	TMS320C64X_INS_PACKH2,
	TMS320C64X_INS_PACKH4,
	TMS320C64X_INS_PACKHL2,
	TMS320C64X_INS_PACKL4,
	TMS320C64X_INS_PACKLH2,
	TMS320C64X_INS_ROTL,
	TMS320C64X_INS_SADD,
	TMS320C64X_INS_SADD2,
	TMS320C64X_INS_SADDU4,
	TMS320C64X_INS_SADDUS2,
	TMS320C64X_INS_SAT,
	TMS320C64X_INS_SET,
	TMS320C64X_INS_SHFL,
	TMS320C64X_INS_SHL,
	TMS320C64X_INS_SHLMB,
	TMS320C64X_INS_SHR,
	TMS320C64X_INS_SHR2,
	TMS320C64X_INS_SHRMB,
	TMS320C64X_INS_SHRU,
	TMS320C64X_INS_SHRU2,
	TMS320C64X_INS_SMPY,
	TMS320C64X_INS_SMPY2,
	TMS320C64X_INS_SMPYH,
	TMS320C64X_INS_SMPYHL,
	TMS320C64X_INS_SMPYLH,
	TMS320C64X_INS_SPACK2,
	TMS320C64X_INS_SPACKU4,
	TMS320C64X_INS_SSHL,
	TMS320C64X_INS_SSHVL,
	TMS320C64X_INS_SSHVR,
	TMS320C64X_INS_SSUB,
	TMS320C64X_INS_STB,
	TMS320C64X_INS_STDW,
	TMS320C64X_INS_STH,
	TMS320C64X_INS_STNDW,
	TMS320C64X_INS_STNW,
	TMS320C64X_INS_STW,
	TMS320C64X_INS_SUB,
	TMS320C64X_INS_SUB2,
	TMS320C64X_INS_SUB4,
	TMS320C64X_INS_SUBAB,
	TMS320C64X_INS_SUBABS4,
	TMS320C64X_INS_SUBAH,
	TMS320C64X_INS_SUBAW,
	TMS320C64X_INS_SUBC,
	TMS320C64X_INS_SUBU,
	TMS320C64X_INS_SWAP4,
	TMS320C64X_INS_UNPKHU4,
	TMS320C64X_INS_UNPKLU4,
	TMS320C64X_INS_XOR,
	TMS320C64X_INS_XPND2,
	TMS320C64X_INS_XPND4,
	// Aliases
	TMS320C64X_INS_IDLE,
	TMS320C64X_INS_MV,
	TMS320C64X_INS_NEG,
	TMS320C64X_INS_NOT,
	TMS320C64X_INS_SWAP2,
	TMS320C64X_INS_ZERO,

	TMS320C64X_INS_ENDING,   // <-- mark the end of the list of instructions
} tms320c64x_insn;

typedef enum tms320c64x_insn_group {
	TMS320C64X_GRP_INVALID = 0, ///< = CS_GRP_INVALID

	TMS320C64X_GRP_JUMP,	///< = CS_GRP_JUMP

	TMS320C64X_GRP_FUNIT_D = 128,
	TMS320C64X_GRP_FUNIT_L,
	TMS320C64X_GRP_FUNIT_M,
	TMS320C64X_GRP_FUNIT_S,
	TMS320C64X_GRP_FUNIT_NO,

	TMS320C64X_GRP_ENDING,   // <-- mark the end of the list of groups
} tms320c64x_insn_group;

typedef enum tms320c64x_funit {
	TMS320C64X_FUNIT_INVALID = 0,
	TMS320C64X_FUNIT_D,
	TMS320C64X_FUNIT_L,
	TMS320C64X_FUNIT_M,
	TMS320C64X_FUNIT_S,
	TMS320C64X_FUNIT_NO
} tms320c64x_funit;

#ifdef __cplusplus
}
#endif

#endif


```

`KDemu/include/capstone/capstone/x86.h`:

```h
#ifndef CAPSTONE_X86_H
#define CAPSTONE_X86_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2015 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

/// Calculate relative address for X86-64, given cs_insn structure
#define X86_REL_ADDR(insn) (((insn).detail->x86.operands[0].type == X86_OP_IMM) \
	? (uint64_t)((insn).detail->x86.operands[0].imm) \
	: (((insn).address + (insn).size) + (uint64_t)(insn).detail->x86.disp))

/// X86 registers
typedef enum x86_reg {
	X86_REG_INVALID = 0,
	X86_REG_AH, X86_REG_AL, X86_REG_AX, X86_REG_BH, X86_REG_BL,
	X86_REG_BP, X86_REG_BPL, X86_REG_BX, X86_REG_CH, X86_REG_CL,
	X86_REG_CS, X86_REG_CX, X86_REG_DH, X86_REG_DI, X86_REG_DIL,
	X86_REG_DL, X86_REG_DS, X86_REG_DX, X86_REG_EAX, X86_REG_EBP,
	X86_REG_EBX, X86_REG_ECX, X86_REG_EDI, X86_REG_EDX, X86_REG_EFLAGS,
	X86_REG_EIP, X86_REG_EIZ, X86_REG_ES, X86_REG_ESI, X86_REG_ESP,
	X86_REG_FPSW, X86_REG_FS, X86_REG_GS, X86_REG_IP, X86_REG_RAX,
	X86_REG_RBP, X86_REG_RBX, X86_REG_RCX, X86_REG_RDI, X86_REG_RDX,
	X86_REG_RIP, X86_REG_RIZ, X86_REG_RSI, X86_REG_RSP, X86_REG_SI,
	X86_REG_SIL, X86_REG_SP, X86_REG_SPL, X86_REG_SS, X86_REG_CR0,
	X86_REG_CR1, X86_REG_CR2, X86_REG_CR3, X86_REG_CR4, X86_REG_CR5,
	X86_REG_CR6, X86_REG_CR7, X86_REG_CR8, X86_REG_CR9, X86_REG_CR10,
	X86_REG_CR11, X86_REG_CR12, X86_REG_CR13, X86_REG_CR14, X86_REG_CR15,
	X86_REG_DR0, X86_REG_DR1, X86_REG_DR2, X86_REG_DR3, X86_REG_DR4,
	X86_REG_DR5, X86_REG_DR6, X86_REG_DR7, X86_REG_DR8, X86_REG_DR9,
	X86_REG_DR10, X86_REG_DR11, X86_REG_DR12, X86_REG_DR13, X86_REG_DR14,
	X86_REG_DR15, X86_REG_FP0, X86_REG_FP1, X86_REG_FP2, X86_REG_FP3,
	X86_REG_FP4, X86_REG_FP5, X86_REG_FP6, X86_REG_FP7,
	X86_REG_K0, X86_REG_K1, X86_REG_K2, X86_REG_K3, X86_REG_K4,
	X86_REG_K5, X86_REG_K6, X86_REG_K7, X86_REG_MM0, X86_REG_MM1,
	X86_REG_MM2, X86_REG_MM3, X86_REG_MM4, X86_REG_MM5, X86_REG_MM6,
	X86_REG_MM7, X86_REG_R8, X86_REG_R9, X86_REG_R10, X86_REG_R11,
	X86_REG_R12, X86_REG_R13, X86_REG_R14, X86_REG_R15,
	X86_REG_ST0, X86_REG_ST1, X86_REG_ST2, X86_REG_ST3,
	X86_REG_ST4, X86_REG_ST5, X86_REG_ST6, X86_REG_ST7,
	X86_REG_XMM0, X86_REG_XMM1, X86_REG_XMM2, X86_REG_XMM3, X86_REG_XMM4,
	X86_REG_XMM5, X86_REG_XMM6, X86_REG_XMM7, X86_REG_XMM8, X86_REG_XMM9,
	X86_REG_XMM10, X86_REG_XMM11, X86_REG_XMM12, X86_REG_XMM13, X86_REG_XMM14,
	X86_REG_XMM15, X86_REG_XMM16, X86_REG_XMM17, X86_REG_XMM18, X86_REG_XMM19,
	X86_REG_XMM20, X86_REG_XMM21, X86_REG_XMM22, X86_REG_XMM23, X86_REG_XMM24,
	X86_REG_XMM25, X86_REG_XMM26, X86_REG_XMM27, X86_REG_XMM28, X86_REG_XMM29,
	X86_REG_XMM30, X86_REG_XMM31, X86_REG_YMM0, X86_REG_YMM1, X86_REG_YMM2,
	X86_REG_YMM3, X86_REG_YMM4, X86_REG_YMM5, X86_REG_YMM6, X86_REG_YMM7,
	X86_REG_YMM8, X86_REG_YMM9, X86_REG_YMM10, X86_REG_YMM11, X86_REG_YMM12,
	X86_REG_YMM13, X86_REG_YMM14, X86_REG_YMM15, X86_REG_YMM16, X86_REG_YMM17,
	X86_REG_YMM18, X86_REG_YMM19, X86_REG_YMM20, X86_REG_YMM21, X86_REG_YMM22,
	X86_REG_YMM23, X86_REG_YMM24, X86_REG_YMM25, X86_REG_YMM26, X86_REG_YMM27,
	X86_REG_YMM28, X86_REG_YMM29, X86_REG_YMM30, X86_REG_YMM31, X86_REG_ZMM0,
	X86_REG_ZMM1, X86_REG_ZMM2, X86_REG_ZMM3, X86_REG_ZMM4, X86_REG_ZMM5,
	X86_REG_ZMM6, X86_REG_ZMM7, X86_REG_ZMM8, X86_REG_ZMM9, X86_REG_ZMM10,
	X86_REG_ZMM11, X86_REG_ZMM12, X86_REG_ZMM13, X86_REG_ZMM14, X86_REG_ZMM15,
	X86_REG_ZMM16, X86_REG_ZMM17, X86_REG_ZMM18, X86_REG_ZMM19, X86_REG_ZMM20,
	X86_REG_ZMM21, X86_REG_ZMM22, X86_REG_ZMM23, X86_REG_ZMM24, X86_REG_ZMM25,
	X86_REG_ZMM26, X86_REG_ZMM27, X86_REG_ZMM28, X86_REG_ZMM29, X86_REG_ZMM30,
	X86_REG_ZMM31, X86_REG_R8B, X86_REG_R9B, X86_REG_R10B, X86_REG_R11B,
	X86_REG_R12B, X86_REG_R13B, X86_REG_R14B, X86_REG_R15B, X86_REG_R8D,
	X86_REG_R9D, X86_REG_R10D, X86_REG_R11D, X86_REG_R12D, X86_REG_R13D,
	X86_REG_R14D, X86_REG_R15D, X86_REG_R8W, X86_REG_R9W, X86_REG_R10W,
	X86_REG_R11W, X86_REG_R12W, X86_REG_R13W, X86_REG_R14W, X86_REG_R15W,

	X86_REG_ENDING		// <-- mark the end of the list of registers
} x86_reg;

// Sub-flags of EFLAGS
#define X86_EFLAGS_MODIFY_AF (1ULL << 0)
#define X86_EFLAGS_MODIFY_CF (1ULL << 1)
#define X86_EFLAGS_MODIFY_SF (1ULL << 2)
#define X86_EFLAGS_MODIFY_ZF (1ULL << 3)
#define X86_EFLAGS_MODIFY_PF (1ULL << 4)
#define X86_EFLAGS_MODIFY_OF (1ULL << 5)
#define X86_EFLAGS_MODIFY_TF (1ULL << 6)
#define X86_EFLAGS_MODIFY_IF (1ULL << 7)
#define X86_EFLAGS_MODIFY_DF (1ULL << 8)
#define X86_EFLAGS_MODIFY_NT (1ULL << 9)
#define X86_EFLAGS_MODIFY_RF (1ULL << 10)
#define X86_EFLAGS_PRIOR_OF (1ULL << 11)
#define X86_EFLAGS_PRIOR_SF (1ULL << 12)
#define X86_EFLAGS_PRIOR_ZF (1ULL << 13)
#define X86_EFLAGS_PRIOR_AF (1ULL << 14)
#define X86_EFLAGS_PRIOR_PF (1ULL << 15)
#define X86_EFLAGS_PRIOR_CF (1ULL << 16)
#define X86_EFLAGS_PRIOR_TF (1ULL << 17)
#define X86_EFLAGS_PRIOR_IF (1ULL << 18)
#define X86_EFLAGS_PRIOR_DF (1ULL << 19)
#define X86_EFLAGS_PRIOR_NT (1ULL << 20)
#define X86_EFLAGS_RESET_OF (1ULL << 21)
#define X86_EFLAGS_RESET_CF (1ULL << 22)
#define X86_EFLAGS_RESET_DF (1ULL << 23)
#define X86_EFLAGS_RESET_IF (1ULL << 24)
#define X86_EFLAGS_RESET_SF (1ULL << 25)
#define X86_EFLAGS_RESET_AF (1ULL << 26)
#define X86_EFLAGS_RESET_TF (1ULL << 27)
#define X86_EFLAGS_RESET_NT (1ULL << 28)
#define X86_EFLAGS_RESET_PF (1ULL << 29)
#define X86_EFLAGS_SET_CF (1ULL << 30)
#define X86_EFLAGS_SET_DF (1ULL << 31)
#define X86_EFLAGS_SET_IF (1ULL << 32)
#define X86_EFLAGS_TEST_OF (1ULL << 33)
#define X86_EFLAGS_TEST_SF (1ULL << 34)
#define X86_EFLAGS_TEST_ZF (1ULL << 35)
#define X86_EFLAGS_TEST_PF (1ULL << 36)
#define X86_EFLAGS_TEST_CF (1ULL << 37)
#define X86_EFLAGS_TEST_NT (1ULL << 38)
#define X86_EFLAGS_TEST_DF (1ULL << 39)
#define X86_EFLAGS_UNDEFINED_OF (1ULL << 40)
#define X86_EFLAGS_UNDEFINED_SF (1ULL << 41)
#define X86_EFLAGS_UNDEFINED_ZF (1ULL << 42)
#define X86_EFLAGS_UNDEFINED_PF (1ULL << 43)
#define X86_EFLAGS_UNDEFINED_AF (1ULL << 44)
#define X86_EFLAGS_UNDEFINED_CF (1ULL << 45)
#define X86_EFLAGS_RESET_RF (1ULL << 46)
#define X86_EFLAGS_TEST_RF (1ULL << 47)
#define X86_EFLAGS_TEST_IF (1ULL << 48)
#define X86_EFLAGS_TEST_TF (1ULL << 49)
#define X86_EFLAGS_TEST_AF (1ULL << 50)
#define X86_EFLAGS_RESET_ZF (1ULL << 51)
#define X86_EFLAGS_SET_OF (1ULL << 52)
#define X86_EFLAGS_SET_SF (1ULL << 53)
#define X86_EFLAGS_SET_ZF (1ULL << 54)
#define X86_EFLAGS_SET_AF (1ULL << 55)
#define X86_EFLAGS_SET_PF (1ULL << 56)
#define X86_EFLAGS_RESET_0F (1ULL << 57)
#define X86_EFLAGS_RESET_AC (1ULL << 58)

#define X86_FPU_FLAGS_MODIFY_C0 (1ULL << 0)
#define X86_FPU_FLAGS_MODIFY_C1 (1ULL << 1)
#define X86_FPU_FLAGS_MODIFY_C2 (1ULL << 2)
#define X86_FPU_FLAGS_MODIFY_C3 (1ULL << 3)
#define X86_FPU_FLAGS_RESET_C0 (1ULL << 4)
#define X86_FPU_FLAGS_RESET_C1 (1ULL << 5)
#define X86_FPU_FLAGS_RESET_C2 (1ULL << 6)
#define X86_FPU_FLAGS_RESET_C3 (1ULL << 7)
#define X86_FPU_FLAGS_SET_C0 (1ULL << 8)
#define X86_FPU_FLAGS_SET_C1 (1ULL << 9)
#define X86_FPU_FLAGS_SET_C2 (1ULL << 10)
#define X86_FPU_FLAGS_SET_C3 (1ULL << 11)
#define X86_FPU_FLAGS_UNDEFINED_C0 (1ULL << 12)
#define X86_FPU_FLAGS_UNDEFINED_C1 (1ULL << 13)
#define X86_FPU_FLAGS_UNDEFINED_C2 (1ULL << 14)
#define X86_FPU_FLAGS_UNDEFINED_C3 (1ULL << 15)
#define X86_FPU_FLAGS_TEST_C0 (1ULL << 16)
#define X86_FPU_FLAGS_TEST_C1 (1ULL << 17)
#define X86_FPU_FLAGS_TEST_C2 (1ULL << 18)
#define X86_FPU_FLAGS_TEST_C3 (1ULL << 19)


/// Operand type for instruction's operands
typedef enum x86_op_type {
	X86_OP_INVALID = 0, ///< = CS_OP_INVALID (Uninitialized).
	X86_OP_REG, ///< = CS_OP_REG (Register operand).
	X86_OP_IMM, ///< = CS_OP_IMM (Immediate operand).
	X86_OP_MEM, ///< = CS_OP_MEM (Memory operand).
} x86_op_type;

/// XOP Code Condition type
typedef enum x86_xop_cc {
	X86_XOP_CC_INVALID = 0,	///< Uninitialized.
	X86_XOP_CC_LT,
	X86_XOP_CC_LE,
	X86_XOP_CC_GT,
	X86_XOP_CC_GE,
	X86_XOP_CC_EQ,
	X86_XOP_CC_NEQ,
	X86_XOP_CC_FALSE,
	X86_XOP_CC_TRUE,
} x86_xop_cc;

/// AVX broadcast type
typedef enum x86_avx_bcast {
	X86_AVX_BCAST_INVALID = 0,	///< Uninitialized.
	X86_AVX_BCAST_2,	///< AVX512 broadcast type {1to2}
	X86_AVX_BCAST_4,	///< AVX512 broadcast type {1to4}
	X86_AVX_BCAST_8,	///< AVX512 broadcast type {1to8}
	X86_AVX_BCAST_16,	///< AVX512 broadcast type {1to16}
} x86_avx_bcast;

/// SSE Code Condition type
typedef enum x86_sse_cc {
	X86_SSE_CC_INVALID = 0,	///< Uninitialized.
	X86_SSE_CC_EQ,
	X86_SSE_CC_LT,
	X86_SSE_CC_LE,
	X86_SSE_CC_UNORD,
	X86_SSE_CC_NEQ,
	X86_SSE_CC_NLT,
	X86_SSE_CC_NLE,
	X86_SSE_CC_ORD,
} x86_sse_cc;

/// AVX Code Condition type
typedef enum x86_avx_cc {
	X86_AVX_CC_INVALID = 0,	///< Uninitialized.
	X86_AVX_CC_EQ,
	X86_AVX_CC_LT,
	X86_AVX_CC_LE,
	X86_AVX_CC_UNORD,
	X86_AVX_CC_NEQ,
	X86_AVX_CC_NLT,
	X86_AVX_CC_NLE,
	X86_AVX_CC_ORD,
	X86_AVX_CC_EQ_UQ,
	X86_AVX_CC_NGE,
	X86_AVX_CC_NGT,
	X86_AVX_CC_FALSE,
	X86_AVX_CC_NEQ_OQ,
	X86_AVX_CC_GE,
	X86_AVX_CC_GT,
	X86_AVX_CC_TRUE,
	X86_AVX_CC_EQ_OS,
	X86_AVX_CC_LT_OQ,
	X86_AVX_CC_LE_OQ,
	X86_AVX_CC_UNORD_S,
	X86_AVX_CC_NEQ_US,
	X86_AVX_CC_NLT_UQ,
	X86_AVX_CC_NLE_UQ,
	X86_AVX_CC_ORD_S,
	X86_AVX_CC_EQ_US,
	X86_AVX_CC_NGE_UQ,
	X86_AVX_CC_NGT_UQ,
	X86_AVX_CC_FALSE_OS,
	X86_AVX_CC_NEQ_OS,
	X86_AVX_CC_GE_OQ,
	X86_AVX_CC_GT_OQ,
	X86_AVX_CC_TRUE_US,
} x86_avx_cc;

/// AVX static rounding mode type
typedef enum x86_avx_rm {
	X86_AVX_RM_INVALID = 0,	///< Uninitialized.
	X86_AVX_RM_RN,	///< Round to nearest
	X86_AVX_RM_RD,	///< Round down
	X86_AVX_RM_RU,	///< Round up
	X86_AVX_RM_RZ,	///< Round toward zero
} x86_avx_rm;

/// Instruction prefixes - to be used in cs_x86.prefix[]
typedef enum x86_prefix {
	X86_PREFIX_LOCK		= 	0xf0,	///< lock (cs_x86.prefix[0]
	X86_PREFIX_REP		= 	0xf3,	///< rep (cs_x86.prefix[0]
	X86_PREFIX_REPE		= 	0xf3,	///< repe/repz (cs_x86.prefix[0]
	X86_PREFIX_REPNE	= 	0xf2,	///< repne/repnz (cs_x86.prefix[0]

	X86_PREFIX_CS		= 	0x2e,	///< segment override CS (cs_x86.prefix[1]
	X86_PREFIX_SS		= 	0x36,	///< segment override SS (cs_x86.prefix[1]
	X86_PREFIX_DS		= 	0x3e,	///< segment override DS (cs_x86.prefix[1]
	X86_PREFIX_ES		= 	0x26,	///< segment override ES (cs_x86.prefix[1]
	X86_PREFIX_FS		= 	0x64,	///< segment override FS (cs_x86.prefix[1]
	X86_PREFIX_GS		= 	0x65,	///< segment override GS (cs_x86.prefix[1]

	X86_PREFIX_OPSIZE	=	0x66,	///< operand-size override (cs_x86.prefix[2]
	X86_PREFIX_ADDRSIZE	=	0x67,	///< address-size override (cs_x86.prefix[3]
} x86_prefix;

/// Instruction's operand referring to memory
/// This is associated with X86_OP_MEM operand type above
typedef struct x86_op_mem {
	x86_reg segment; ///< segment register (or X86_REG_INVALID if irrelevant)
	x86_reg base;	///< base register (or X86_REG_INVALID if irrelevant)
	x86_reg index;	///< index register (or X86_REG_INVALID if irrelevant)
	int scale;	///< scale for index register
	int64_t disp;	///< displacement value
} x86_op_mem;

/// Instruction operand
typedef struct cs_x86_op {
		x86_op_type type;	///< operand type
		union {
			x86_reg reg;	  ///< register value for REG operand
			int64_t imm;		///< immediate value for IMM operand
			x86_op_mem mem;		///< base/index/scale/disp value for MEM operand
		};

		/// size of this operand (in bytes).
		uint8_t size;

		/// How is this operand accessed? (READ, WRITE or READ|WRITE)
		/// This field is combined of cs_ac_type.
		/// NOTE: this field is irrelevant if engine is compiled in DIET mode.
		uint8_t access;

		/// AVX broadcast type, or 0 if irrelevant
		x86_avx_bcast avx_bcast;

		/// AVX zero opmask {z}
		bool avx_zero_opmask;
} cs_x86_op;

typedef struct cs_x86_encoding {
	/// ModR/M offset, or 0 when irrelevant
	uint8_t modrm_offset;

	/// Displacement offset, or 0 when irrelevant.
	uint8_t disp_offset;
	uint8_t disp_size;

	/// Immediate offset, or 0 when irrelevant.
	uint8_t imm_offset;
	uint8_t imm_size;
} cs_x86_encoding;

/// Instruction structure
typedef struct cs_x86 {
	/// Instruction prefix, which can be up to 4 bytes.
	/// A prefix byte gets value 0 when irrelevant.
	/// prefix[0] indicates REP/REPNE/LOCK prefix (See X86_PREFIX_REP/REPNE/LOCK above)
	/// prefix[1] indicates segment override (irrelevant for x86_64):
	/// See X86_PREFIX_CS/SS/DS/ES/FS/GS above.
	/// prefix[2] indicates operand-size override (X86_PREFIX_OPSIZE)
	/// prefix[3] indicates address-size override (X86_PREFIX_ADDRSIZE)
	uint8_t prefix[4];

	/// Instruction opcode, which can be from 1 to 4 bytes in size.
	/// This contains VEX opcode as well.
	/// An trailing opcode byte gets value 0 when irrelevant.
	uint8_t opcode[4];

	/// REX prefix: only a non-zero value is relevant for x86_64
	uint8_t rex;

	/// Address size, which can be overridden with above prefix[5].
	uint8_t addr_size;

	/// ModR/M byte
	uint8_t modrm;

	/// SIB value, or 0 when irrelevant.
	uint8_t sib;

	/// Displacement value, valid if encoding.disp_offset != 0
	int64_t disp;

	/// SIB index register, or X86_REG_INVALID when irrelevant.
	x86_reg sib_index;
	/// SIB scale, only applicable if sib_index is valid.
	int8_t sib_scale;
	/// SIB base register, or X86_REG_INVALID when irrelevant.
	x86_reg sib_base;

	/// XOP Code Condition
	x86_xop_cc xop_cc;

	/// SSE Code Condition
	x86_sse_cc sse_cc;

	/// AVX Code Condition
	x86_avx_cc avx_cc;

	/// AVX Suppress all Exception
	bool avx_sae;

	/// AVX static rounding mode
	x86_avx_rm avx_rm;

	
	union {
		/// EFLAGS updated by this instruction.
		/// This can be formed from OR combination of X86_EFLAGS_* symbols in x86.h
		uint64_t eflags;
		/// FPU_FLAGS updated by this instruction.
		/// This can be formed from OR combination of X86_FPU_FLAGS_* symbols in x86.h
		uint64_t fpu_flags;
	};

	/// Number of operands of this instruction,
	/// or 0 when instruction has no operand.
	uint8_t op_count;

	cs_x86_op operands[8];	///< operands for this instruction.

	cs_x86_encoding encoding;  ///< encoding information
} cs_x86;

/// X86 instructions
typedef enum x86_insn {
	X86_INS_INVALID = 0,

	X86_INS_AAA,
	X86_INS_AAD,
	X86_INS_AAM,
	X86_INS_AAS,
	X86_INS_FABS,
	X86_INS_ADC,
	X86_INS_ADCX,
	X86_INS_ADD,
	X86_INS_ADDPD,
	X86_INS_ADDPS,
	X86_INS_ADDSD,
	X86_INS_ADDSS,
	X86_INS_ADDSUBPD,
	X86_INS_ADDSUBPS,
	X86_INS_FADD,
	X86_INS_FIADD,
	X86_INS_FADDP,
	X86_INS_ADOX,
	X86_INS_AESDECLAST,
	X86_INS_AESDEC,
	X86_INS_AESENCLAST,
	X86_INS_AESENC,
	X86_INS_AESIMC,
	X86_INS_AESKEYGENASSIST,
	X86_INS_AND,
	X86_INS_ANDN,
	X86_INS_ANDNPD,
	X86_INS_ANDNPS,
	X86_INS_ANDPD,
	X86_INS_ANDPS,
	X86_INS_ARPL,
	X86_INS_BEXTR,
	X86_INS_BLCFILL,
	X86_INS_BLCI,
	X86_INS_BLCIC,
	X86_INS_BLCMSK,
	X86_INS_BLCS,
	X86_INS_BLENDPD,
	X86_INS_BLENDPS,
	X86_INS_BLENDVPD,
	X86_INS_BLENDVPS,
	X86_INS_BLSFILL,
	X86_INS_BLSI,
	X86_INS_BLSIC,
	X86_INS_BLSMSK,
	X86_INS_BLSR,
	X86_INS_BOUND,
	X86_INS_BSF,
	X86_INS_BSR,
	X86_INS_BSWAP,
	X86_INS_BT,
	X86_INS_BTC,
	X86_INS_BTR,
	X86_INS_BTS,
	X86_INS_BZHI,
	X86_INS_CALL,
	X86_INS_CBW,
	X86_INS_CDQ,
	X86_INS_CDQE,
	X86_INS_FCHS,
	X86_INS_CLAC,
	X86_INS_CLC,
	X86_INS_CLD,
	X86_INS_CLFLUSH,
	X86_INS_CLFLUSHOPT,
	X86_INS_CLGI,
	X86_INS_CLI,
	X86_INS_CLTS,
	X86_INS_CLWB,
	X86_INS_CMC,
	X86_INS_CMOVA,
	X86_INS_CMOVAE,
	X86_INS_CMOVB,
	X86_INS_CMOVBE,
	X86_INS_FCMOVBE,
	X86_INS_FCMOVB,
	X86_INS_CMOVE,
	X86_INS_FCMOVE,
	X86_INS_CMOVG,
	X86_INS_CMOVGE,
	X86_INS_CMOVL,
	X86_INS_CMOVLE,
	X86_INS_FCMOVNBE,
	X86_INS_FCMOVNB,
	X86_INS_CMOVNE,
	X86_INS_FCMOVNE,
	X86_INS_CMOVNO,
	X86_INS_CMOVNP,
	X86_INS_FCMOVNU,
	X86_INS_CMOVNS,
	X86_INS_CMOVO,
	X86_INS_CMOVP,
	X86_INS_FCMOVU,
	X86_INS_CMOVS,
	X86_INS_CMP,
	X86_INS_CMPSB,
	X86_INS_CMPSQ,
	X86_INS_CMPSW,
	X86_INS_CMPXCHG16B,
	X86_INS_CMPXCHG,
	X86_INS_CMPXCHG8B,
	X86_INS_COMISD,
	X86_INS_COMISS,
	X86_INS_FCOMP,
	X86_INS_FCOMIP,
	X86_INS_FCOMI,
	X86_INS_FCOM,
	X86_INS_FCOS,
	X86_INS_CPUID,
	X86_INS_CQO,
	X86_INS_CRC32,
	X86_INS_CVTDQ2PD,
	X86_INS_CVTDQ2PS,
	X86_INS_CVTPD2DQ,
	X86_INS_CVTPD2PS,
	X86_INS_CVTPS2DQ,
	X86_INS_CVTPS2PD,
	X86_INS_CVTSD2SI,
	X86_INS_CVTSD2SS,
	X86_INS_CVTSI2SD,
	X86_INS_CVTSI2SS,
	X86_INS_CVTSS2SD,
	X86_INS_CVTSS2SI,
	X86_INS_CVTTPD2DQ,
	X86_INS_CVTTPS2DQ,
	X86_INS_CVTTSD2SI,
	X86_INS_CVTTSS2SI,
	X86_INS_CWD,
	X86_INS_CWDE,
	X86_INS_DAA,
	X86_INS_DAS,
	X86_INS_DATA16,
	X86_INS_DEC,
	X86_INS_DIV,
	X86_INS_DIVPD,
	X86_INS_DIVPS,
	X86_INS_FDIVR,
	X86_INS_FIDIVR,
	X86_INS_FDIVRP,
	X86_INS_DIVSD,
	X86_INS_DIVSS,
	X86_INS_FDIV,
	X86_INS_FIDIV,
	X86_INS_FDIVP,
	X86_INS_DPPD,
	X86_INS_DPPS,
	X86_INS_RET,
	X86_INS_ENCLS,
	X86_INS_ENCLU,
	X86_INS_ENTER,
	X86_INS_EXTRACTPS,
	X86_INS_EXTRQ,
	X86_INS_F2XM1,
	X86_INS_LCALL,
	X86_INS_LJMP,
	X86_INS_FBLD,
	X86_INS_FBSTP,
	X86_INS_FCOMPP,
	X86_INS_FDECSTP,
	X86_INS_FEMMS,
	X86_INS_FFREE,
	X86_INS_FICOM,
	X86_INS_FICOMP,
	X86_INS_FINCSTP,
	X86_INS_FLDCW,
	X86_INS_FLDENV,
	X86_INS_FLDL2E,
	X86_INS_FLDL2T,
	X86_INS_FLDLG2,
	X86_INS_FLDLN2,
	X86_INS_FLDPI,
	X86_INS_FNCLEX,
	X86_INS_FNINIT,
	X86_INS_FNOP,
	X86_INS_FNSTCW,
	X86_INS_FNSTSW,
	X86_INS_FPATAN,
	X86_INS_FPREM,
	X86_INS_FPREM1,
	X86_INS_FPTAN,
	X86_INS_FFREEP,
	X86_INS_FRNDINT,
	X86_INS_FRSTOR,
	X86_INS_FNSAVE,
	X86_INS_FSCALE,
	X86_INS_FSETPM,
	X86_INS_FSINCOS,
	X86_INS_FNSTENV,
	X86_INS_FXAM,
	X86_INS_FXRSTOR,
	X86_INS_FXRSTOR64,
	X86_INS_FXSAVE,
	X86_INS_FXSAVE64,
	X86_INS_FXTRACT,
	X86_INS_FYL2X,
	X86_INS_FYL2XP1,
	X86_INS_MOVAPD,
	X86_INS_MOVAPS,
	X86_INS_ORPD,
	X86_INS_ORPS,
	X86_INS_VMOVAPD,
	X86_INS_VMOVAPS,
	X86_INS_XORPD,
	X86_INS_XORPS,
	X86_INS_GETSEC,
	X86_INS_HADDPD,
	X86_INS_HADDPS,
	X86_INS_HLT,
	X86_INS_HSUBPD,
	X86_INS_HSUBPS,
	X86_INS_IDIV,
	X86_INS_FILD,
	X86_INS_IMUL,
	X86_INS_IN,
	X86_INS_INC,
	X86_INS_INSB,
	X86_INS_INSERTPS,
	X86_INS_INSERTQ,
	X86_INS_INSD,
	X86_INS_INSW,
	X86_INS_INT,
	X86_INS_INT1,
	X86_INS_INT3,
	X86_INS_INTO,
	X86_INS_INVD,
	X86_INS_INVEPT,
	X86_INS_INVLPG,
	X86_INS_INVLPGA,
	X86_INS_INVPCID,
	X86_INS_INVVPID,
	X86_INS_IRET,
	X86_INS_IRETD,
	X86_INS_IRETQ,
	X86_INS_FISTTP,
	X86_INS_FIST,
	X86_INS_FISTP,
	X86_INS_UCOMISD,
	X86_INS_UCOMISS,
	X86_INS_VCOMISD,
	X86_INS_VCOMISS,
	X86_INS_VCVTSD2SS,
	X86_INS_VCVTSI2SD,
	X86_INS_VCVTSI2SS,
	X86_INS_VCVTSS2SD,
	X86_INS_VCVTTSD2SI,
	X86_INS_VCVTTSD2USI,
	X86_INS_VCVTTSS2SI,
	X86_INS_VCVTTSS2USI,
	X86_INS_VCVTUSI2SD,
	X86_INS_VCVTUSI2SS,
	X86_INS_VUCOMISD,
	X86_INS_VUCOMISS,
	X86_INS_JAE,
	X86_INS_JA,
	X86_INS_JBE,
	X86_INS_JB,
	X86_INS_JCXZ,
	X86_INS_JECXZ,
	X86_INS_JE,
	X86_INS_JGE,
	X86_INS_JG,
	X86_INS_JLE,
	X86_INS_JL,
	X86_INS_JMP,
	X86_INS_JNE,
	X86_INS_JNO,
	X86_INS_JNP,
	X86_INS_JNS,
	X86_INS_JO,
	X86_INS_JP,
	X86_INS_JRCXZ,
	X86_INS_JS,
	X86_INS_KANDB,
	X86_INS_KANDD,
	X86_INS_KANDNB,
	X86_INS_KANDND,
	X86_INS_KANDNQ,
	X86_INS_KANDNW,
	X86_INS_KANDQ,
	X86_INS_KANDW,
	X86_INS_KMOVB,
	X86_INS_KMOVD,
	X86_INS_KMOVQ,
	X86_INS_KMOVW,
	X86_INS_KNOTB,
	X86_INS_KNOTD,
	X86_INS_KNOTQ,
	X86_INS_KNOTW,
	X86_INS_KORB,
	X86_INS_KORD,
	X86_INS_KORQ,
	X86_INS_KORTESTB,
	X86_INS_KORTESTD,
	X86_INS_KORTESTQ,
	X86_INS_KORTESTW,
	X86_INS_KORW,
	X86_INS_KSHIFTLB,
	X86_INS_KSHIFTLD,
	X86_INS_KSHIFTLQ,
	X86_INS_KSHIFTLW,
	X86_INS_KSHIFTRB,
	X86_INS_KSHIFTRD,
	X86_INS_KSHIFTRQ,
	X86_INS_KSHIFTRW,
	X86_INS_KUNPCKBW,
	X86_INS_KXNORB,
	X86_INS_KXNORD,
	X86_INS_KXNORQ,
	X86_INS_KXNORW,
	X86_INS_KXORB,
	X86_INS_KXORD,
	X86_INS_KXORQ,
	X86_INS_KXORW,
	X86_INS_LAHF,
	X86_INS_LAR,
	X86_INS_LDDQU,
	X86_INS_LDMXCSR,
	X86_INS_LDS,
	X86_INS_FLDZ,
	X86_INS_FLD1,
	X86_INS_FLD,
	X86_INS_LEA,
	X86_INS_LEAVE,
	X86_INS_LES,
	X86_INS_LFENCE,
	X86_INS_LFS,
	X86_INS_LGDT,
	X86_INS_LGS,
	X86_INS_LIDT,
	X86_INS_LLDT,
	X86_INS_LMSW,
	X86_INS_OR,
	X86_INS_SUB,
	X86_INS_XOR,
	X86_INS_LODSB,
	X86_INS_LODSD,
	X86_INS_LODSQ,
	X86_INS_LODSW,
	X86_INS_LOOP,
	X86_INS_LOOPE,
	X86_INS_LOOPNE,
	X86_INS_RETF,
	X86_INS_RETFQ,
	X86_INS_LSL,
	X86_INS_LSS,
	X86_INS_LTR,
	X86_INS_XADD,
	X86_INS_LZCNT,
	X86_INS_MASKMOVDQU,
	X86_INS_MAXPD,
	X86_INS_MAXPS,
	X86_INS_MAXSD,
	X86_INS_MAXSS,
	X86_INS_MFENCE,
	X86_INS_MINPD,
	X86_INS_MINPS,
	X86_INS_MINSD,
	X86_INS_MINSS,
	X86_INS_CVTPD2PI,
	X86_INS_CVTPI2PD,
	X86_INS_CVTPI2PS,
	X86_INS_CVTPS2PI,
	X86_INS_CVTTPD2PI,
	X86_INS_CVTTPS2PI,
	X86_INS_EMMS,
	X86_INS_MASKMOVQ,
	X86_INS_MOVD,
	X86_INS_MOVDQ2Q,
	X86_INS_MOVNTQ,
	X86_INS_MOVQ2DQ,
	X86_INS_MOVQ,
	X86_INS_PABSB,
	X86_INS_PABSD,
	X86_INS_PABSW,
	X86_INS_PACKSSDW,
	X86_INS_PACKSSWB,
	X86_INS_PACKUSWB,
	X86_INS_PADDB,
	X86_INS_PADDD,
	X86_INS_PADDQ,
	X86_INS_PADDSB,
	X86_INS_PADDSW,
	X86_INS_PADDUSB,
	X86_INS_PADDUSW,
	X86_INS_PADDW,
	X86_INS_PALIGNR,
	X86_INS_PANDN,
	X86_INS_PAND,
	X86_INS_PAVGB,
	X86_INS_PAVGW,
	X86_INS_PCMPEQB,
	X86_INS_PCMPEQD,
	X86_INS_PCMPEQW,
	X86_INS_PCMPGTB,
	X86_INS_PCMPGTD,
	X86_INS_PCMPGTW,
	X86_INS_PEXTRW,
	X86_INS_PHADDSW,
	X86_INS_PHADDW,
	X86_INS_PHADDD,
	X86_INS_PHSUBD,
	X86_INS_PHSUBSW,
	X86_INS_PHSUBW,
	X86_INS_PINSRW,
	X86_INS_PMADDUBSW,
	X86_INS_PMADDWD,
	X86_INS_PMAXSW,
	X86_INS_PMAXUB,
	X86_INS_PMINSW,
	X86_INS_PMINUB,
	X86_INS_PMOVMSKB,
	X86_INS_PMULHRSW,
	X86_INS_PMULHUW,
	X86_INS_PMULHW,
	X86_INS_PMULLW,
	X86_INS_PMULUDQ,
	X86_INS_POR,
	X86_INS_PSADBW,
	X86_INS_PSHUFB,
	X86_INS_PSHUFW,
	X86_INS_PSIGNB,
	X86_INS_PSIGND,
	X86_INS_PSIGNW,
	X86_INS_PSLLD,
	X86_INS_PSLLQ,
	X86_INS_PSLLW,
	X86_INS_PSRAD,
	X86_INS_PSRAW,
	X86_INS_PSRLD,
	X86_INS_PSRLQ,
	X86_INS_PSRLW,
	X86_INS_PSUBB,
	X86_INS_PSUBD,
	X86_INS_PSUBQ,
	X86_INS_PSUBSB,
	X86_INS_PSUBSW,
	X86_INS_PSUBUSB,
	X86_INS_PSUBUSW,
	X86_INS_PSUBW,
	X86_INS_PUNPCKHBW,
	X86_INS_PUNPCKHDQ,
	X86_INS_PUNPCKHWD,
	X86_INS_PUNPCKLBW,
	X86_INS_PUNPCKLDQ,
	X86_INS_PUNPCKLWD,
	X86_INS_PXOR,
	X86_INS_MONITOR,
	X86_INS_MONTMUL,
	X86_INS_MOV,
	X86_INS_MOVABS,
	X86_INS_MOVBE,
	X86_INS_MOVDDUP,
	X86_INS_MOVDQA,
	X86_INS_MOVDQU,
	X86_INS_MOVHLPS,
	X86_INS_MOVHPD,
	X86_INS_MOVHPS,
	X86_INS_MOVLHPS,
	X86_INS_MOVLPD,
	X86_INS_MOVLPS,
	X86_INS_MOVMSKPD,
	X86_INS_MOVMSKPS,
	X86_INS_MOVNTDQA,
	X86_INS_MOVNTDQ,
	X86_INS_MOVNTI,
	X86_INS_MOVNTPD,
	X86_INS_MOVNTPS,
	X86_INS_MOVNTSD,
	X86_INS_MOVNTSS,
	X86_INS_MOVSB,
	X86_INS_MOVSD,
	X86_INS_MOVSHDUP,
	X86_INS_MOVSLDUP,
	X86_INS_MOVSQ,
	X86_INS_MOVSS,
	X86_INS_MOVSW,
	X86_INS_MOVSX,
	X86_INS_MOVSXD,
	X86_INS_MOVUPD,
	X86_INS_MOVUPS,
	X86_INS_MOVZX,
	X86_INS_MPSADBW,
	X86_INS_MUL,
	X86_INS_MULPD,
	X86_INS_MULPS,
	X86_INS_MULSD,
	X86_INS_MULSS,
	X86_INS_MULX,
	X86_INS_FMUL,
	X86_INS_FIMUL,
	X86_INS_FMULP,
	X86_INS_MWAIT,
	X86_INS_NEG,
	X86_INS_NOP,
	X86_INS_NOT,
	X86_INS_OUT,
	X86_INS_OUTSB,
	X86_INS_OUTSD,
	X86_INS_OUTSW,
	X86_INS_PACKUSDW,
	X86_INS_PAUSE,
	X86_INS_PAVGUSB,
	X86_INS_PBLENDVB,
	X86_INS_PBLENDW,
	X86_INS_PCLMULQDQ,
	X86_INS_PCMPEQQ,
	X86_INS_PCMPESTRI,
	X86_INS_PCMPESTRM,
	X86_INS_PCMPGTQ,
	X86_INS_PCMPISTRI,
	X86_INS_PCMPISTRM,
	X86_INS_PCOMMIT,
	X86_INS_PDEP,
	X86_INS_PEXT,
	X86_INS_PEXTRB,
	X86_INS_PEXTRD,
	X86_INS_PEXTRQ,
	X86_INS_PF2ID,
	X86_INS_PF2IW,
	X86_INS_PFACC,
	X86_INS_PFADD,
	X86_INS_PFCMPEQ,
	X86_INS_PFCMPGE,
	X86_INS_PFCMPGT,
	X86_INS_PFMAX,
	X86_INS_PFMIN,
	X86_INS_PFMUL,
	X86_INS_PFNACC,
	X86_INS_PFPNACC,
	X86_INS_PFRCPIT1,
	X86_INS_PFRCPIT2,
	X86_INS_PFRCP,
	X86_INS_PFRSQIT1,
	X86_INS_PFRSQRT,
	X86_INS_PFSUBR,
	X86_INS_PFSUB,
	X86_INS_PHMINPOSUW,
	X86_INS_PI2FD,
	X86_INS_PI2FW,
	X86_INS_PINSRB,
	X86_INS_PINSRD,
	X86_INS_PINSRQ,
	X86_INS_PMAXSB,
	X86_INS_PMAXSD,
	X86_INS_PMAXUD,
	X86_INS_PMAXUW,
	X86_INS_PMINSB,
	X86_INS_PMINSD,
	X86_INS_PMINUD,
	X86_INS_PMINUW,
	X86_INS_PMOVSXBD,
	X86_INS_PMOVSXBQ,
	X86_INS_PMOVSXBW,
	X86_INS_PMOVSXDQ,
	X86_INS_PMOVSXWD,
	X86_INS_PMOVSXWQ,
	X86_INS_PMOVZXBD,
	X86_INS_PMOVZXBQ,
	X86_INS_PMOVZXBW,
	X86_INS_PMOVZXDQ,
	X86_INS_PMOVZXWD,
	X86_INS_PMOVZXWQ,
	X86_INS_PMULDQ,
	X86_INS_PMULHRW,
	X86_INS_PMULLD,
	X86_INS_POP,
	X86_INS_POPAW,
	X86_INS_POPAL,
	X86_INS_POPCNT,
	X86_INS_POPF,
	X86_INS_POPFD,
	X86_INS_POPFQ,
	X86_INS_PREFETCH,
	X86_INS_PREFETCHNTA,
	X86_INS_PREFETCHT0,
	X86_INS_PREFETCHT1,
	X86_INS_PREFETCHT2,
	X86_INS_PREFETCHW,
	X86_INS_PSHUFD,
	X86_INS_PSHUFHW,
	X86_INS_PSHUFLW,
	X86_INS_PSLLDQ,
	X86_INS_PSRLDQ,
	X86_INS_PSWAPD,
	X86_INS_PTEST,
	X86_INS_PUNPCKHQDQ,
	X86_INS_PUNPCKLQDQ,
	X86_INS_PUSH,
	X86_INS_PUSHAW,
	X86_INS_PUSHAL,
	X86_INS_PUSHF,
	X86_INS_PUSHFD,
	X86_INS_PUSHFQ,
	X86_INS_RCL,
	X86_INS_RCPPS,
	X86_INS_RCPSS,
	X86_INS_RCR,
	X86_INS_RDFSBASE,
	X86_INS_RDGSBASE,
	X86_INS_RDMSR,
	X86_INS_RDPMC,
	X86_INS_RDRAND,
	X86_INS_RDSEED,
	X86_INS_RDTSC,
	X86_INS_RDTSCP,
	X86_INS_ROL,
	X86_INS_ROR,
	X86_INS_RORX,
	X86_INS_ROUNDPD,
	X86_INS_ROUNDPS,
	X86_INS_ROUNDSD,
	X86_INS_ROUNDSS,
	X86_INS_RSM,
	X86_INS_RSQRTPS,
	X86_INS_RSQRTSS,
	X86_INS_SAHF,
	X86_INS_SAL,
	X86_INS_SALC,
	X86_INS_SAR,
	X86_INS_SARX,
	X86_INS_SBB,
	X86_INS_SCASB,
	X86_INS_SCASD,
	X86_INS_SCASQ,
	X86_INS_SCASW,
	X86_INS_SETAE,
	X86_INS_SETA,
	X86_INS_SETBE,
	X86_INS_SETB,
	X86_INS_SETE,
	X86_INS_SETGE,
	X86_INS_SETG,
	X86_INS_SETLE,
	X86_INS_SETL,
	X86_INS_SETNE,
	X86_INS_SETNO,
	X86_INS_SETNP,
	X86_INS_SETNS,
	X86_INS_SETO,
	X86_INS_SETP,
	X86_INS_SETS,
	X86_INS_SFENCE,
	X86_INS_SGDT,
	X86_INS_SHA1MSG1,
	X86_INS_SHA1MSG2,
	X86_INS_SHA1NEXTE,
	X86_INS_SHA1RNDS4,
	X86_INS_SHA256MSG1,
	X86_INS_SHA256MSG2,
	X86_INS_SHA256RNDS2,
	X86_INS_SHL,
	X86_INS_SHLD,
	X86_INS_SHLX,
	X86_INS_SHR,
	X86_INS_SHRD,
	X86_INS_SHRX,
	X86_INS_SHUFPD,
	X86_INS_SHUFPS,
	X86_INS_SIDT,
	X86_INS_FSIN,
	X86_INS_SKINIT,
	X86_INS_SLDT,
	X86_INS_SMSW,
	X86_INS_SQRTPD,
	X86_INS_SQRTPS,
	X86_INS_SQRTSD,
	X86_INS_SQRTSS,
	X86_INS_FSQRT,
	X86_INS_STAC,
	X86_INS_STC,
	X86_INS_STD,
	X86_INS_STGI,
	X86_INS_STI,
	X86_INS_STMXCSR,
	X86_INS_STOSB,
	X86_INS_STOSD,
	X86_INS_STOSQ,
	X86_INS_STOSW,
	X86_INS_STR,
	X86_INS_FST,
	X86_INS_FSTP,
	X86_INS_FSTPNCE,
	X86_INS_FXCH,
	X86_INS_SUBPD,
	X86_INS_SUBPS,
	X86_INS_FSUBR,
	X86_INS_FISUBR,
	X86_INS_FSUBRP,
	X86_INS_SUBSD,
	X86_INS_SUBSS,
	X86_INS_FSUB,
	X86_INS_FISUB,
	X86_INS_FSUBP,
	X86_INS_SWAPGS,
	X86_INS_SYSCALL,
	X86_INS_SYSENTER,
	X86_INS_SYSEXIT,
	X86_INS_SYSRET,
	X86_INS_T1MSKC,
	X86_INS_TEST,
	X86_INS_UD2,
	X86_INS_FTST,
	X86_INS_TZCNT,
	X86_INS_TZMSK,
	X86_INS_FUCOMIP,
	X86_INS_FUCOMI,
	X86_INS_FUCOMPP,
	X86_INS_FUCOMP,
	X86_INS_FUCOM,
	X86_INS_UD2B,
	X86_INS_UNPCKHPD,
	X86_INS_UNPCKHPS,
	X86_INS_UNPCKLPD,
	X86_INS_UNPCKLPS,
	X86_INS_VADDPD,
	X86_INS_VADDPS,
	X86_INS_VADDSD,
	X86_INS_VADDSS,
	X86_INS_VADDSUBPD,
	X86_INS_VADDSUBPS,
	X86_INS_VAESDECLAST,
	X86_INS_VAESDEC,
	X86_INS_VAESENCLAST,
	X86_INS_VAESENC,
	X86_INS_VAESIMC,
	X86_INS_VAESKEYGENASSIST,
	X86_INS_VALIGND,
	X86_INS_VALIGNQ,
	X86_INS_VANDNPD,
	X86_INS_VANDNPS,
	X86_INS_VANDPD,
	X86_INS_VANDPS,
	X86_INS_VBLENDMPD,
	X86_INS_VBLENDMPS,
	X86_INS_VBLENDPD,
	X86_INS_VBLENDPS,
	X86_INS_VBLENDVPD,
	X86_INS_VBLENDVPS,
	X86_INS_VBROADCASTF128,
	X86_INS_VBROADCASTI32X4,
	X86_INS_VBROADCASTI64X4,
	X86_INS_VBROADCASTSD,
	X86_INS_VBROADCASTSS,
	X86_INS_VCOMPRESSPD,
	X86_INS_VCOMPRESSPS,
	X86_INS_VCVTDQ2PD,
	X86_INS_VCVTDQ2PS,
	X86_INS_VCVTPD2DQX,
	X86_INS_VCVTPD2DQ,
	X86_INS_VCVTPD2PSX,
	X86_INS_VCVTPD2PS,
	X86_INS_VCVTPD2UDQ,
	X86_INS_VCVTPH2PS,
	X86_INS_VCVTPS2DQ,
	X86_INS_VCVTPS2PD,
	X86_INS_VCVTPS2PH,
	X86_INS_VCVTPS2UDQ,
	X86_INS_VCVTSD2SI,
	X86_INS_VCVTSD2USI,
	X86_INS_VCVTSS2SI,
	X86_INS_VCVTSS2USI,
	X86_INS_VCVTTPD2DQX,
	X86_INS_VCVTTPD2DQ,
	X86_INS_VCVTTPD2UDQ,
	X86_INS_VCVTTPS2DQ,
	X86_INS_VCVTTPS2UDQ,
	X86_INS_VCVTUDQ2PD,
	X86_INS_VCVTUDQ2PS,
	X86_INS_VDIVPD,
	X86_INS_VDIVPS,
	X86_INS_VDIVSD,
	X86_INS_VDIVSS,
	X86_INS_VDPPD,
	X86_INS_VDPPS,
	X86_INS_VERR,
	X86_INS_VERW,
	X86_INS_VEXP2PD,
	X86_INS_VEXP2PS,
	X86_INS_VEXPANDPD,
	X86_INS_VEXPANDPS,
	X86_INS_VEXTRACTF128,
	X86_INS_VEXTRACTF32X4,
	X86_INS_VEXTRACTF64X4,
	X86_INS_VEXTRACTI128,
	X86_INS_VEXTRACTI32X4,
	X86_INS_VEXTRACTI64X4,
	X86_INS_VEXTRACTPS,
	X86_INS_VFMADD132PD,
	X86_INS_VFMADD132PS,
	X86_INS_VFMADDPD,
	X86_INS_VFMADD213PD,
	X86_INS_VFMADD231PD,
	X86_INS_VFMADDPS,
	X86_INS_VFMADD213PS,
	X86_INS_VFMADD231PS,
	X86_INS_VFMADDSD,
	X86_INS_VFMADD213SD,
	X86_INS_VFMADD132SD,
	X86_INS_VFMADD231SD,
	X86_INS_VFMADDSS,
	X86_INS_VFMADD213SS,
	X86_INS_VFMADD132SS,
	X86_INS_VFMADD231SS,
	X86_INS_VFMADDSUB132PD,
	X86_INS_VFMADDSUB132PS,
	X86_INS_VFMADDSUBPD,
	X86_INS_VFMADDSUB213PD,
	X86_INS_VFMADDSUB231PD,
	X86_INS_VFMADDSUBPS,
	X86_INS_VFMADDSUB213PS,
	X86_INS_VFMADDSUB231PS,
	X86_INS_VFMSUB132PD,
	X86_INS_VFMSUB132PS,
	X86_INS_VFMSUBADD132PD,
	X86_INS_VFMSUBADD132PS,
	X86_INS_VFMSUBADDPD,
	X86_INS_VFMSUBADD213PD,
	X86_INS_VFMSUBADD231PD,
	X86_INS_VFMSUBADDPS,
	X86_INS_VFMSUBADD213PS,
	X86_INS_VFMSUBADD231PS,
	X86_INS_VFMSUBPD,
	X86_INS_VFMSUB213PD,
	X86_INS_VFMSUB231PD,
	X86_INS_VFMSUBPS,
	X86_INS_VFMSUB213PS,
	X86_INS_VFMSUB231PS,
	X86_INS_VFMSUBSD,
	X86_INS_VFMSUB213SD,
	X86_INS_VFMSUB132SD,
	X86_INS_VFMSUB231SD,
	X86_INS_VFMSUBSS,
	X86_INS_VFMSUB213SS,
	X86_INS_VFMSUB132SS,
	X86_INS_VFMSUB231SS,
	X86_INS_VFNMADD132PD,
	X86_INS_VFNMADD132PS,
	X86_INS_VFNMADDPD,
	X86_INS_VFNMADD213PD,
	X86_INS_VFNMADD231PD,
	X86_INS_VFNMADDPS,
	X86_INS_VFNMADD213PS,
	X86_INS_VFNMADD231PS,
	X86_INS_VFNMADDSD,
	X86_INS_VFNMADD213SD,
	X86_INS_VFNMADD132SD,
	X86_INS_VFNMADD231SD,
	X86_INS_VFNMADDSS,
	X86_INS_VFNMADD213SS,
	X86_INS_VFNMADD132SS,
	X86_INS_VFNMADD231SS,
	X86_INS_VFNMSUB132PD,
	X86_INS_VFNMSUB132PS,
	X86_INS_VFNMSUBPD,
	X86_INS_VFNMSUB213PD,
	X86_INS_VFNMSUB231PD,
	X86_INS_VFNMSUBPS,
	X86_INS_VFNMSUB213PS,
	X86_INS_VFNMSUB231PS,
	X86_INS_VFNMSUBSD,
	X86_INS_VFNMSUB213SD,
	X86_INS_VFNMSUB132SD,
	X86_INS_VFNMSUB231SD,
	X86_INS_VFNMSUBSS,
	X86_INS_VFNMSUB213SS,
	X86_INS_VFNMSUB132SS,
	X86_INS_VFNMSUB231SS,
	X86_INS_VFRCZPD,
	X86_INS_VFRCZPS,
	X86_INS_VFRCZSD,
	X86_INS_VFRCZSS,
	X86_INS_VORPD,
	X86_INS_VORPS,
	X86_INS_VXORPD,
	X86_INS_VXORPS,
	X86_INS_VGATHERDPD,
	X86_INS_VGATHERDPS,
	X86_INS_VGATHERPF0DPD,
	X86_INS_VGATHERPF0DPS,
	X86_INS_VGATHERPF0QPD,
	X86_INS_VGATHERPF0QPS,
	X86_INS_VGATHERPF1DPD,
	X86_INS_VGATHERPF1DPS,
	X86_INS_VGATHERPF1QPD,
	X86_INS_VGATHERPF1QPS,
	X86_INS_VGATHERQPD,
	X86_INS_VGATHERQPS,
	X86_INS_VHADDPD,
	X86_INS_VHADDPS,
	X86_INS_VHSUBPD,
	X86_INS_VHSUBPS,
	X86_INS_VINSERTF128,
	X86_INS_VINSERTF32X4,
	X86_INS_VINSERTF32X8,
	X86_INS_VINSERTF64X2,
	X86_INS_VINSERTF64X4,
	X86_INS_VINSERTI128,
	X86_INS_VINSERTI32X4,
	X86_INS_VINSERTI32X8,
	X86_INS_VINSERTI64X2,
	X86_INS_VINSERTI64X4,
	X86_INS_VINSERTPS,
	X86_INS_VLDDQU,
	X86_INS_VLDMXCSR,
	X86_INS_VMASKMOVDQU,
	X86_INS_VMASKMOVPD,
	X86_INS_VMASKMOVPS,
	X86_INS_VMAXPD,
	X86_INS_VMAXPS,
	X86_INS_VMAXSD,
	X86_INS_VMAXSS,
	X86_INS_VMCALL,
	X86_INS_VMCLEAR,
	X86_INS_VMFUNC,
	X86_INS_VMINPD,
	X86_INS_VMINPS,
	X86_INS_VMINSD,
	X86_INS_VMINSS,
	X86_INS_VMLAUNCH,
	X86_INS_VMLOAD,
	X86_INS_VMMCALL,
	X86_INS_VMOVQ,
	X86_INS_VMOVDDUP,
	X86_INS_VMOVD,
	X86_INS_VMOVDQA32,
	X86_INS_VMOVDQA64,
	X86_INS_VMOVDQA,
	X86_INS_VMOVDQU16,
	X86_INS_VMOVDQU32,
	X86_INS_VMOVDQU64,
	X86_INS_VMOVDQU8,
	X86_INS_VMOVDQU,
	X86_INS_VMOVHLPS,
	X86_INS_VMOVHPD,
	X86_INS_VMOVHPS,
	X86_INS_VMOVLHPS,
	X86_INS_VMOVLPD,
	X86_INS_VMOVLPS,
	X86_INS_VMOVMSKPD,
	X86_INS_VMOVMSKPS,
	X86_INS_VMOVNTDQA,
	X86_INS_VMOVNTDQ,
	X86_INS_VMOVNTPD,
	X86_INS_VMOVNTPS,
	X86_INS_VMOVSD,
	X86_INS_VMOVSHDUP,
	X86_INS_VMOVSLDUP,
	X86_INS_VMOVSS,
	X86_INS_VMOVUPD,
	X86_INS_VMOVUPS,
	X86_INS_VMPSADBW,
	X86_INS_VMPTRLD,
	X86_INS_VMPTRST,
	X86_INS_VMREAD,
	X86_INS_VMRESUME,
	X86_INS_VMRUN,
	X86_INS_VMSAVE,
	X86_INS_VMULPD,
	X86_INS_VMULPS,
	X86_INS_VMULSD,
	X86_INS_VMULSS,
	X86_INS_VMWRITE,
	X86_INS_VMXOFF,
	X86_INS_VMXON,
	X86_INS_VPABSB,
	X86_INS_VPABSD,
	X86_INS_VPABSQ,
	X86_INS_VPABSW,
	X86_INS_VPACKSSDW,
	X86_INS_VPACKSSWB,
	X86_INS_VPACKUSDW,
	X86_INS_VPACKUSWB,
	X86_INS_VPADDB,
	X86_INS_VPADDD,
	X86_INS_VPADDQ,
	X86_INS_VPADDSB,
	X86_INS_VPADDSW,
	X86_INS_VPADDUSB,
	X86_INS_VPADDUSW,
	X86_INS_VPADDW,
	X86_INS_VPALIGNR,
	X86_INS_VPANDD,
	X86_INS_VPANDND,
	X86_INS_VPANDNQ,
	X86_INS_VPANDN,
	X86_INS_VPANDQ,
	X86_INS_VPAND,
	X86_INS_VPAVGB,
	X86_INS_VPAVGW,
	X86_INS_VPBLENDD,
	X86_INS_VPBLENDMB,
	X86_INS_VPBLENDMD,
	X86_INS_VPBLENDMQ,
	X86_INS_VPBLENDMW,
	X86_INS_VPBLENDVB,
	X86_INS_VPBLENDW,
	X86_INS_VPBROADCASTB,
	X86_INS_VPBROADCASTD,
	X86_INS_VPBROADCASTMB2Q,
	X86_INS_VPBROADCASTMW2D,
	X86_INS_VPBROADCASTQ,
	X86_INS_VPBROADCASTW,
	X86_INS_VPCLMULQDQ,
	X86_INS_VPCMOV,
	X86_INS_VPCMPB,
	X86_INS_VPCMPD,
	X86_INS_VPCMPEQB,
	X86_INS_VPCMPEQD,
	X86_INS_VPCMPEQQ,
	X86_INS_VPCMPEQW,
	X86_INS_VPCMPESTRI,
	X86_INS_VPCMPESTRM,
	X86_INS_VPCMPGTB,
	X86_INS_VPCMPGTD,
	X86_INS_VPCMPGTQ,
	X86_INS_VPCMPGTW,
	X86_INS_VPCMPISTRI,
	X86_INS_VPCMPISTRM,
	X86_INS_VPCMPQ,
	X86_INS_VPCMPUB,
	X86_INS_VPCMPUD,
	X86_INS_VPCMPUQ,
	X86_INS_VPCMPUW,
	X86_INS_VPCMPW,
	X86_INS_VPCOMB,
	X86_INS_VPCOMD,
	X86_INS_VPCOMPRESSD,
	X86_INS_VPCOMPRESSQ,
	X86_INS_VPCOMQ,
	X86_INS_VPCOMUB,
	X86_INS_VPCOMUD,
	X86_INS_VPCOMUQ,
	X86_INS_VPCOMUW,
	X86_INS_VPCOMW,
	X86_INS_VPCONFLICTD,
	X86_INS_VPCONFLICTQ,
	X86_INS_VPERM2F128,
	X86_INS_VPERM2I128,
	X86_INS_VPERMD,
	X86_INS_VPERMI2D,
	X86_INS_VPERMI2PD,
	X86_INS_VPERMI2PS,
	X86_INS_VPERMI2Q,
	X86_INS_VPERMIL2PD,
	X86_INS_VPERMIL2PS,
	X86_INS_VPERMILPD,
	X86_INS_VPERMILPS,
	X86_INS_VPERMPD,
	X86_INS_VPERMPS,
	X86_INS_VPERMQ,
	X86_INS_VPERMT2D,
	X86_INS_VPERMT2PD,
	X86_INS_VPERMT2PS,
	X86_INS_VPERMT2Q,
	X86_INS_VPEXPANDD,
	X86_INS_VPEXPANDQ,
	X86_INS_VPEXTRB,
	X86_INS_VPEXTRD,
	X86_INS_VPEXTRQ,
	X86_INS_VPEXTRW,
	X86_INS_VPGATHERDD,
	X86_INS_VPGATHERDQ,
	X86_INS_VPGATHERQD,
	X86_INS_VPGATHERQQ,
	X86_INS_VPHADDBD,
	X86_INS_VPHADDBQ,
	X86_INS_VPHADDBW,
	X86_INS_VPHADDDQ,
	X86_INS_VPHADDD,
	X86_INS_VPHADDSW,
	X86_INS_VPHADDUBD,
	X86_INS_VPHADDUBQ,
	X86_INS_VPHADDUBW,
	X86_INS_VPHADDUDQ,
	X86_INS_VPHADDUWD,
	X86_INS_VPHADDUWQ,
	X86_INS_VPHADDWD,
	X86_INS_VPHADDWQ,
	X86_INS_VPHADDW,
	X86_INS_VPHMINPOSUW,
	X86_INS_VPHSUBBW,
	X86_INS_VPHSUBDQ,
	X86_INS_VPHSUBD,
	X86_INS_VPHSUBSW,
	X86_INS_VPHSUBWD,
	X86_INS_VPHSUBW,
	X86_INS_VPINSRB,
	X86_INS_VPINSRD,
	X86_INS_VPINSRQ,
	X86_INS_VPINSRW,
	X86_INS_VPLZCNTD,
	X86_INS_VPLZCNTQ,
	X86_INS_VPMACSDD,
	X86_INS_VPMACSDQH,
	X86_INS_VPMACSDQL,
	X86_INS_VPMACSSDD,
	X86_INS_VPMACSSDQH,
	X86_INS_VPMACSSDQL,
	X86_INS_VPMACSSWD,
	X86_INS_VPMACSSWW,
	X86_INS_VPMACSWD,
	X86_INS_VPMACSWW,
	X86_INS_VPMADCSSWD,
	X86_INS_VPMADCSWD,
	X86_INS_VPMADDUBSW,
	X86_INS_VPMADDWD,
	X86_INS_VPMASKMOVD,
	X86_INS_VPMASKMOVQ,
	X86_INS_VPMAXSB,
	X86_INS_VPMAXSD,
	X86_INS_VPMAXSQ,
	X86_INS_VPMAXSW,
	X86_INS_VPMAXUB,
	X86_INS_VPMAXUD,
	X86_INS_VPMAXUQ,
	X86_INS_VPMAXUW,
	X86_INS_VPMINSB,
	X86_INS_VPMINSD,
	X86_INS_VPMINSQ,
	X86_INS_VPMINSW,
	X86_INS_VPMINUB,
	X86_INS_VPMINUD,
	X86_INS_VPMINUQ,
	X86_INS_VPMINUW,
	X86_INS_VPMOVDB,
	X86_INS_VPMOVDW,
	X86_INS_VPMOVM2B,
	X86_INS_VPMOVM2D,
	X86_INS_VPMOVM2Q,
	X86_INS_VPMOVM2W,
	X86_INS_VPMOVMSKB,
	X86_INS_VPMOVQB,
	X86_INS_VPMOVQD,
	X86_INS_VPMOVQW,
	X86_INS_VPMOVSDB,
	X86_INS_VPMOVSDW,
	X86_INS_VPMOVSQB,
	X86_INS_VPMOVSQD,
	X86_INS_VPMOVSQW,
	X86_INS_VPMOVSXBD,
	X86_INS_VPMOVSXBQ,
	X86_INS_VPMOVSXBW,
	X86_INS_VPMOVSXDQ,
	X86_INS_VPMOVSXWD,
	X86_INS_VPMOVSXWQ,
	X86_INS_VPMOVUSDB,
	X86_INS_VPMOVUSDW,
	X86_INS_VPMOVUSQB,
	X86_INS_VPMOVUSQD,
	X86_INS_VPMOVUSQW,
	X86_INS_VPMOVZXBD,
	X86_INS_VPMOVZXBQ,
	X86_INS_VPMOVZXBW,
	X86_INS_VPMOVZXDQ,
	X86_INS_VPMOVZXWD,
	X86_INS_VPMOVZXWQ,
	X86_INS_VPMULDQ,
	X86_INS_VPMULHRSW,
	X86_INS_VPMULHUW,
	X86_INS_VPMULHW,
	X86_INS_VPMULLD,
	X86_INS_VPMULLQ,
	X86_INS_VPMULLW,
	X86_INS_VPMULUDQ,
	X86_INS_VPORD,
	X86_INS_VPORQ,
	X86_INS_VPOR,
	X86_INS_VPPERM,
	X86_INS_VPROTB,
	X86_INS_VPROTD,
	X86_INS_VPROTQ,
	X86_INS_VPROTW,
	X86_INS_VPSADBW,
	X86_INS_VPSCATTERDD,
	X86_INS_VPSCATTERDQ,
	X86_INS_VPSCATTERQD,
	X86_INS_VPSCATTERQQ,
	X86_INS_VPSHAB,
	X86_INS_VPSHAD,
	X86_INS_VPSHAQ,
	X86_INS_VPSHAW,
	X86_INS_VPSHLB,
	X86_INS_VPSHLD,
	X86_INS_VPSHLQ,
	X86_INS_VPSHLW,
	X86_INS_VPSHUFB,
	X86_INS_VPSHUFD,
	X86_INS_VPSHUFHW,
	X86_INS_VPSHUFLW,
	X86_INS_VPSIGNB,
	X86_INS_VPSIGND,
	X86_INS_VPSIGNW,
	X86_INS_VPSLLDQ,
	X86_INS_VPSLLD,
	X86_INS_VPSLLQ,
	X86_INS_VPSLLVD,
	X86_INS_VPSLLVQ,
	X86_INS_VPSLLW,
	X86_INS_VPSRAD,
	X86_INS_VPSRAQ,
	X86_INS_VPSRAVD,
	X86_INS_VPSRAVQ,
	X86_INS_VPSRAW,
	X86_INS_VPSRLDQ,
	X86_INS_VPSRLD,
	X86_INS_VPSRLQ,
	X86_INS_VPSRLVD,
	X86_INS_VPSRLVQ,
	X86_INS_VPSRLW,
	X86_INS_VPSUBB,
	X86_INS_VPSUBD,
	X86_INS_VPSUBQ,
	X86_INS_VPSUBSB,
	X86_INS_VPSUBSW,
	X86_INS_VPSUBUSB,
	X86_INS_VPSUBUSW,
	X86_INS_VPSUBW,
	X86_INS_VPTESTMD,
	X86_INS_VPTESTMQ,
	X86_INS_VPTESTNMD,
	X86_INS_VPTESTNMQ,
	X86_INS_VPTEST,
	X86_INS_VPUNPCKHBW,
	X86_INS_VPUNPCKHDQ,
	X86_INS_VPUNPCKHQDQ,
	X86_INS_VPUNPCKHWD,
	X86_INS_VPUNPCKLBW,
	X86_INS_VPUNPCKLDQ,
	X86_INS_VPUNPCKLQDQ,
	X86_INS_VPUNPCKLWD,
	X86_INS_VPXORD,
	X86_INS_VPXORQ,
	X86_INS_VPXOR,
	X86_INS_VRCP14PD,
	X86_INS_VRCP14PS,
	X86_INS_VRCP14SD,
	X86_INS_VRCP14SS,
	X86_INS_VRCP28PD,
	X86_INS_VRCP28PS,
	X86_INS_VRCP28SD,
	X86_INS_VRCP28SS,
	X86_INS_VRCPPS,
	X86_INS_VRCPSS,
	X86_INS_VRNDSCALEPD,
	X86_INS_VRNDSCALEPS,
	X86_INS_VRNDSCALESD,
	X86_INS_VRNDSCALESS,
	X86_INS_VROUNDPD,
	X86_INS_VROUNDPS,
	X86_INS_VROUNDSD,
	X86_INS_VROUNDSS,
	X86_INS_VRSQRT14PD,
	X86_INS_VRSQRT14PS,
	X86_INS_VRSQRT14SD,
	X86_INS_VRSQRT14SS,
	X86_INS_VRSQRT28PD,
	X86_INS_VRSQRT28PS,
	X86_INS_VRSQRT28SD,
	X86_INS_VRSQRT28SS,
	X86_INS_VRSQRTPS,
	X86_INS_VRSQRTSS,
	X86_INS_VSCATTERDPD,
	X86_INS_VSCATTERDPS,
	X86_INS_VSCATTERPF0DPD,
	X86_INS_VSCATTERPF0DPS,
	X86_INS_VSCATTERPF0QPD,
	X86_INS_VSCATTERPF0QPS,
	X86_INS_VSCATTERPF1DPD,
	X86_INS_VSCATTERPF1DPS,
	X86_INS_VSCATTERPF1QPD,
	X86_INS_VSCATTERPF1QPS,
	X86_INS_VSCATTERQPD,
	X86_INS_VSCATTERQPS,
	X86_INS_VSHUFPD,
	X86_INS_VSHUFPS,
	X86_INS_VSQRTPD,
	X86_INS_VSQRTPS,
	X86_INS_VSQRTSD,
	X86_INS_VSQRTSS,
	X86_INS_VSTMXCSR,
	X86_INS_VSUBPD,
	X86_INS_VSUBPS,
	X86_INS_VSUBSD,
	X86_INS_VSUBSS,
	X86_INS_VTESTPD,
	X86_INS_VTESTPS,
	X86_INS_VUNPCKHPD,
	X86_INS_VUNPCKHPS,
	X86_INS_VUNPCKLPD,
	X86_INS_VUNPCKLPS,
	X86_INS_VZEROALL,
	X86_INS_VZEROUPPER,
	X86_INS_WAIT,
	X86_INS_WBINVD,
	X86_INS_WRFSBASE,
	X86_INS_WRGSBASE,
	X86_INS_WRMSR,
	X86_INS_XABORT,
	X86_INS_XACQUIRE,
	X86_INS_XBEGIN,
	X86_INS_XCHG,
	X86_INS_XCRYPTCBC,
	X86_INS_XCRYPTCFB,
	X86_INS_XCRYPTCTR,
	X86_INS_XCRYPTECB,
	X86_INS_XCRYPTOFB,
	X86_INS_XEND,
	X86_INS_XGETBV,
	X86_INS_XLATB,
	X86_INS_XRELEASE,
	X86_INS_XRSTOR,
	X86_INS_XRSTOR64,
	X86_INS_XRSTORS,
	X86_INS_XRSTORS64,
	X86_INS_XSAVE,
	X86_INS_XSAVE64,
	X86_INS_XSAVEC,
	X86_INS_XSAVEC64,
	X86_INS_XSAVEOPT,
	X86_INS_XSAVEOPT64,
	X86_INS_XSAVES,
	X86_INS_XSAVES64,
	X86_INS_XSETBV,
	X86_INS_XSHA1,
	X86_INS_XSHA256,
	X86_INS_XSTORE,
	X86_INS_XTEST,
	X86_INS_FDISI8087_NOP,
	X86_INS_FENI8087_NOP,

	// pseudo instructions
	X86_INS_CMPSS,
	X86_INS_CMPEQSS,
	X86_INS_CMPLTSS,
	X86_INS_CMPLESS,
	X86_INS_CMPUNORDSS,
	X86_INS_CMPNEQSS,
	X86_INS_CMPNLTSS,
	X86_INS_CMPNLESS,
	X86_INS_CMPORDSS,

	X86_INS_CMPSD,
	X86_INS_CMPEQSD,
	X86_INS_CMPLTSD,
	X86_INS_CMPLESD,
	X86_INS_CMPUNORDSD,
	X86_INS_CMPNEQSD,
	X86_INS_CMPNLTSD,
	X86_INS_CMPNLESD,
	X86_INS_CMPORDSD,

	X86_INS_CMPPS,
	X86_INS_CMPEQPS,
	X86_INS_CMPLTPS,
	X86_INS_CMPLEPS,
	X86_INS_CMPUNORDPS,
	X86_INS_CMPNEQPS,
	X86_INS_CMPNLTPS,
	X86_INS_CMPNLEPS,
	X86_INS_CMPORDPS,

	X86_INS_CMPPD,
	X86_INS_CMPEQPD,
	X86_INS_CMPLTPD,
	X86_INS_CMPLEPD,
	X86_INS_CMPUNORDPD,
	X86_INS_CMPNEQPD,
	X86_INS_CMPNLTPD,
	X86_INS_CMPNLEPD,
	X86_INS_CMPORDPD,

	X86_INS_VCMPSS,
	X86_INS_VCMPEQSS,
	X86_INS_VCMPLTSS,
	X86_INS_VCMPLESS,
	X86_INS_VCMPUNORDSS,
	X86_INS_VCMPNEQSS,
	X86_INS_VCMPNLTSS,
	X86_INS_VCMPNLESS,
	X86_INS_VCMPORDSS,
	X86_INS_VCMPEQ_UQSS,
	X86_INS_VCMPNGESS,
	X86_INS_VCMPNGTSS,
	X86_INS_VCMPFALSESS,
	X86_INS_VCMPNEQ_OQSS,
	X86_INS_VCMPGESS,
	X86_INS_VCMPGTSS,
	X86_INS_VCMPTRUESS,
	X86_INS_VCMPEQ_OSSS,
	X86_INS_VCMPLT_OQSS,
	X86_INS_VCMPLE_OQSS,
	X86_INS_VCMPUNORD_SSS,
	X86_INS_VCMPNEQ_USSS,
	X86_INS_VCMPNLT_UQSS,
	X86_INS_VCMPNLE_UQSS,
	X86_INS_VCMPORD_SSS,
	X86_INS_VCMPEQ_USSS,
	X86_INS_VCMPNGE_UQSS,
	X86_INS_VCMPNGT_UQSS,
	X86_INS_VCMPFALSE_OSSS,
	X86_INS_VCMPNEQ_OSSS,
	X86_INS_VCMPGE_OQSS,
	X86_INS_VCMPGT_OQSS,
	X86_INS_VCMPTRUE_USSS,

	X86_INS_VCMPSD,
	X86_INS_VCMPEQSD,
	X86_INS_VCMPLTSD,
	X86_INS_VCMPLESD,
	X86_INS_VCMPUNORDSD,
	X86_INS_VCMPNEQSD,
	X86_INS_VCMPNLTSD,
	X86_INS_VCMPNLESD,
	X86_INS_VCMPORDSD,
	X86_INS_VCMPEQ_UQSD,
	X86_INS_VCMPNGESD,
	X86_INS_VCMPNGTSD,
	X86_INS_VCMPFALSESD,
	X86_INS_VCMPNEQ_OQSD,
	X86_INS_VCMPGESD,
	X86_INS_VCMPGTSD,
	X86_INS_VCMPTRUESD,
	X86_INS_VCMPEQ_OSSD,
	X86_INS_VCMPLT_OQSD,
	X86_INS_VCMPLE_OQSD,
	X86_INS_VCMPUNORD_SSD,
	X86_INS_VCMPNEQ_USSD,
	X86_INS_VCMPNLT_UQSD,
	X86_INS_VCMPNLE_UQSD,
	X86_INS_VCMPORD_SSD,
	X86_INS_VCMPEQ_USSD,
	X86_INS_VCMPNGE_UQSD,
	X86_INS_VCMPNGT_UQSD,
	X86_INS_VCMPFALSE_OSSD,
	X86_INS_VCMPNEQ_OSSD,
	X86_INS_VCMPGE_OQSD,
	X86_INS_VCMPGT_OQSD,
	X86_INS_VCMPTRUE_USSD,

	X86_INS_VCMPPS,
	X86_INS_VCMPEQPS,
	X86_INS_VCMPLTPS,
	X86_INS_VCMPLEPS,
	X86_INS_VCMPUNORDPS,
	X86_INS_VCMPNEQPS,
	X86_INS_VCMPNLTPS,
	X86_INS_VCMPNLEPS,
	X86_INS_VCMPORDPS,
	X86_INS_VCMPEQ_UQPS,
	X86_INS_VCMPNGEPS,
	X86_INS_VCMPNGTPS,
	X86_INS_VCMPFALSEPS,
	X86_INS_VCMPNEQ_OQPS,
	X86_INS_VCMPGEPS,
	X86_INS_VCMPGTPS,
	X86_INS_VCMPTRUEPS,
	X86_INS_VCMPEQ_OSPS,
	X86_INS_VCMPLT_OQPS,
	X86_INS_VCMPLE_OQPS,
	X86_INS_VCMPUNORD_SPS,
	X86_INS_VCMPNEQ_USPS,
	X86_INS_VCMPNLT_UQPS,
	X86_INS_VCMPNLE_UQPS,
	X86_INS_VCMPORD_SPS,
	X86_INS_VCMPEQ_USPS,
	X86_INS_VCMPNGE_UQPS,
	X86_INS_VCMPNGT_UQPS,
	X86_INS_VCMPFALSE_OSPS,
	X86_INS_VCMPNEQ_OSPS,
	X86_INS_VCMPGE_OQPS,
	X86_INS_VCMPGT_OQPS,
	X86_INS_VCMPTRUE_USPS,

	X86_INS_VCMPPD,
	X86_INS_VCMPEQPD,
	X86_INS_VCMPLTPD,
	X86_INS_VCMPLEPD,
	X86_INS_VCMPUNORDPD,
	X86_INS_VCMPNEQPD,
	X86_INS_VCMPNLTPD,
	X86_INS_VCMPNLEPD,
	X86_INS_VCMPORDPD,
	X86_INS_VCMPEQ_UQPD,
	X86_INS_VCMPNGEPD,
	X86_INS_VCMPNGTPD,
	X86_INS_VCMPFALSEPD,
	X86_INS_VCMPNEQ_OQPD,
	X86_INS_VCMPGEPD,
	X86_INS_VCMPGTPD,
	X86_INS_VCMPTRUEPD,
	X86_INS_VCMPEQ_OSPD,
	X86_INS_VCMPLT_OQPD,
	X86_INS_VCMPLE_OQPD,
	X86_INS_VCMPUNORD_SPD,
	X86_INS_VCMPNEQ_USPD,
	X86_INS_VCMPNLT_UQPD,
	X86_INS_VCMPNLE_UQPD,
	X86_INS_VCMPORD_SPD,
	X86_INS_VCMPEQ_USPD,
	X86_INS_VCMPNGE_UQPD,
	X86_INS_VCMPNGT_UQPD,
	X86_INS_VCMPFALSE_OSPD,
	X86_INS_VCMPNEQ_OSPD,
	X86_INS_VCMPGE_OQPD,
	X86_INS_VCMPGT_OQPD,
	X86_INS_VCMPTRUE_USPD,

	X86_INS_UD0,
	X86_INS_ENDBR32,
	X86_INS_ENDBR64,

	X86_INS_ENDING, // mark the end of the list of insn
} x86_insn;

/// Group of X86 instructions
typedef enum  x86_insn_group {
	X86_GRP_INVALID = 0, ///< = CS_GRP_INVALID

	// Generic groups
	// all jump instructions (conditional+direct+indirect jumps)
	X86_GRP_JUMP,	///< = CS_GRP_JUMP
	// all call instructions
	X86_GRP_CALL,	///< = CS_GRP_CALL
	// all return instructions
	X86_GRP_RET,	///< = CS_GRP_RET
	// all interrupt instructions (int+syscall)
	X86_GRP_INT,	///< = CS_GRP_INT
	// all interrupt return instructions
	X86_GRP_IRET,	///< = CS_GRP_IRET
	// all privileged instructions
	X86_GRP_PRIVILEGE,	///< = CS_GRP_PRIVILEGE
	// all relative branching instructions
	X86_GRP_BRANCH_RELATIVE, ///< = CS_GRP_BRANCH_RELATIVE

	// Architecture-specific groups
	X86_GRP_VM = 128,	///< all virtualization instructions (VT-x + AMD-V)
	X86_GRP_3DNOW,
	X86_GRP_AES,
	X86_GRP_ADX,
	X86_GRP_AVX,
	X86_GRP_AVX2,
	X86_GRP_AVX512,
	X86_GRP_BMI,
	X86_GRP_BMI2,
	X86_GRP_CMOV,
	X86_GRP_F16C,
	X86_GRP_FMA,
	X86_GRP_FMA4,
	X86_GRP_FSGSBASE,
	X86_GRP_HLE,
	X86_GRP_MMX,
	X86_GRP_MODE32,
	X86_GRP_MODE64,
	X86_GRP_RTM,
	X86_GRP_SHA,
	X86_GRP_SSE1,
	X86_GRP_SSE2,
	X86_GRP_SSE3,
	X86_GRP_SSE41,
	X86_GRP_SSE42,
	X86_GRP_SSE4A,
	X86_GRP_SSSE3,
	X86_GRP_PCLMUL,
	X86_GRP_XOP,
	X86_GRP_CDI,
	X86_GRP_ERI,
	X86_GRP_TBM,
	X86_GRP_16BITMODE,
	X86_GRP_NOT64BITMODE,
	X86_GRP_SGX,
	X86_GRP_DQI,
	X86_GRP_BWI,
	X86_GRP_PFI,
	X86_GRP_VLX,
	X86_GRP_SMAP,
	X86_GRP_NOVLX,
	X86_GRP_FPU,

	X86_GRP_ENDING
} x86_insn_group;

#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/include/capstone/capstone/xcore.h`:

```h
#ifndef CAPSTONE_XCORE_H
#define CAPSTONE_XCORE_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2014-2015 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

/// Operand type for instruction's operands
typedef enum xcore_op_type {
	XCORE_OP_INVALID = 0, ///< = CS_OP_INVALID (Uninitialized).
	XCORE_OP_REG, ///< = CS_OP_REG (Register operand).
	XCORE_OP_IMM, ///< = CS_OP_IMM (Immediate operand).
	XCORE_OP_MEM, ///< = CS_OP_MEM (Memory operand).
} xcore_op_type;

/// XCore registers
typedef enum xcore_reg {
	XCORE_REG_INVALID = 0,

	XCORE_REG_CP,
	XCORE_REG_DP,
	XCORE_REG_LR,
	XCORE_REG_SP,
	XCORE_REG_R0,
	XCORE_REG_R1,
	XCORE_REG_R2,
	XCORE_REG_R3,
	XCORE_REG_R4,
	XCORE_REG_R5,
	XCORE_REG_R6,
	XCORE_REG_R7,
	XCORE_REG_R8,
	XCORE_REG_R9,
	XCORE_REG_R10,
	XCORE_REG_R11,

	// pseudo registers
	XCORE_REG_PC,	///< pc

	// internal thread registers
	// see The-XMOS-XS1-Architecture(X7879A).pdf
	XCORE_REG_SCP,	///< save pc
	XCORE_REG_SSR,	//< save status
	XCORE_REG_ET,	//< exception type
	XCORE_REG_ED,	//< exception data
	XCORE_REG_SED,	//< save exception data
	XCORE_REG_KEP,	//< kernel entry pointer
	XCORE_REG_KSP,	//< kernel stack pointer
	XCORE_REG_ID,	//< thread ID

	XCORE_REG_ENDING,	// <-- mark the end of the list of registers
} xcore_reg;

/// Instruction's operand referring to memory
/// This is associated with XCORE_OP_MEM operand type above
typedef struct xcore_op_mem {
	uint8_t base;		///< base register, can be safely interpreted as
				///< a value of type `xcore_reg`, but it is only
				///< one byte wide
	uint8_t index;		///< index register, same conditions apply here
	int32_t disp;	///< displacement/offset value
	int     direct;	///< +1: forward, -1: backward
} xcore_op_mem;

/// Instruction operand
typedef struct cs_xcore_op {
	xcore_op_type type;	///< operand type
	union {
		xcore_reg reg;	///< register value for REG operand
		int32_t imm;		///< immediate value for IMM operand
		xcore_op_mem mem;		///< base/disp value for MEM operand
	};
} cs_xcore_op;

/// Instruction structure
typedef struct cs_xcore {
	/// Number of operands of this instruction,
	/// or 0 when instruction has no operand.
	uint8_t op_count;
	cs_xcore_op operands[8]; ///< operands for this instruction.
} cs_xcore;

/// XCore instruction
typedef enum xcore_insn {
	XCORE_INS_INVALID = 0,

	XCORE_INS_ADD,
	XCORE_INS_ANDNOT,
	XCORE_INS_AND,
	XCORE_INS_ASHR,
	XCORE_INS_BAU,
	XCORE_INS_BITREV,
	XCORE_INS_BLA,
	XCORE_INS_BLAT,
	XCORE_INS_BL,
	XCORE_INS_BF,
	XCORE_INS_BT,
	XCORE_INS_BU,
	XCORE_INS_BRU,
	XCORE_INS_BYTEREV,
	XCORE_INS_CHKCT,
	XCORE_INS_CLRE,
	XCORE_INS_CLRPT,
	XCORE_INS_CLRSR,
	XCORE_INS_CLZ,
	XCORE_INS_CRC8,
	XCORE_INS_CRC32,
	XCORE_INS_DCALL,
	XCORE_INS_DENTSP,
	XCORE_INS_DGETREG,
	XCORE_INS_DIVS,
	XCORE_INS_DIVU,
	XCORE_INS_DRESTSP,
	XCORE_INS_DRET,
	XCORE_INS_ECALLF,
	XCORE_INS_ECALLT,
	XCORE_INS_EDU,
	XCORE_INS_EEF,
	XCORE_INS_EET,
	XCORE_INS_EEU,
	XCORE_INS_ENDIN,
	XCORE_INS_ENTSP,
	XCORE_INS_EQ,
	XCORE_INS_EXTDP,
	XCORE_INS_EXTSP,
	XCORE_INS_FREER,
	XCORE_INS_FREET,
	XCORE_INS_GETD,
	XCORE_INS_GET,
	XCORE_INS_GETN,
	XCORE_INS_GETR,
	XCORE_INS_GETSR,
	XCORE_INS_GETST,
	XCORE_INS_GETTS,
	XCORE_INS_INCT,
	XCORE_INS_INIT,
	XCORE_INS_INPW,
	XCORE_INS_INSHR,
	XCORE_INS_INT,
	XCORE_INS_IN,
	XCORE_INS_KCALL,
	XCORE_INS_KENTSP,
	XCORE_INS_KRESTSP,
	XCORE_INS_KRET,
	XCORE_INS_LADD,
	XCORE_INS_LD16S,
	XCORE_INS_LD8U,
	XCORE_INS_LDA16,
	XCORE_INS_LDAP,
	XCORE_INS_LDAW,
	XCORE_INS_LDC,
	XCORE_INS_LDW,
	XCORE_INS_LDIVU,
	XCORE_INS_LMUL,
	XCORE_INS_LSS,
	XCORE_INS_LSUB,
	XCORE_INS_LSU,
	XCORE_INS_MACCS,
	XCORE_INS_MACCU,
	XCORE_INS_MJOIN,
	XCORE_INS_MKMSK,
	XCORE_INS_MSYNC,
	XCORE_INS_MUL,
	XCORE_INS_NEG,
	XCORE_INS_NOT,
	XCORE_INS_OR,
	XCORE_INS_OUTCT,
	XCORE_INS_OUTPW,
	XCORE_INS_OUTSHR,
	XCORE_INS_OUTT,
	XCORE_INS_OUT,
	XCORE_INS_PEEK,
	XCORE_INS_REMS,
	XCORE_INS_REMU,
	XCORE_INS_RETSP,
	XCORE_INS_SETCLK,
	XCORE_INS_SET,
	XCORE_INS_SETC,
	XCORE_INS_SETD,
	XCORE_INS_SETEV,
	XCORE_INS_SETN,
	XCORE_INS_SETPSC,
	XCORE_INS_SETPT,
	XCORE_INS_SETRDY,
	XCORE_INS_SETSR,
	XCORE_INS_SETTW,
	XCORE_INS_SETV,
	XCORE_INS_SEXT,
	XCORE_INS_SHL,
	XCORE_INS_SHR,
	XCORE_INS_SSYNC,
	XCORE_INS_ST16,
	XCORE_INS_ST8,
	XCORE_INS_STW,
	XCORE_INS_SUB,
	XCORE_INS_SYNCR,
	XCORE_INS_TESTCT,
	XCORE_INS_TESTLCL,
	XCORE_INS_TESTWCT,
	XCORE_INS_TSETMR,
	XCORE_INS_START,
	XCORE_INS_WAITEF,
	XCORE_INS_WAITET,
	XCORE_INS_WAITEU,
	XCORE_INS_XOR,
	XCORE_INS_ZEXT,

	XCORE_INS_ENDING,   // <-- mark the end of the list of instructions
} xcore_insn;

/// Group of XCore instructions
typedef enum xcore_insn_group {
	XCORE_GRP_INVALID = 0, ///< = CS_GRP_INVALID

	// Generic groups
	// all jump instructions (conditional+direct+indirect jumps)
	XCORE_GRP_JUMP,	///< = CS_GRP_JUMP

	XCORE_GRP_ENDING,   // <-- mark the end of the list of groups
} xcore_insn_group;

#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/include/kdmp-parser/filemap.h`:

```h
// Axel '0vercl0k' Souchet - April 28 2020
#include "platform.h"
#include <cstdint>
#include <cstdio>

#if defined(LINUX)
#include <errno.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#endif

namespace kdmpparser {
namespace Page {

//
// Page size.
//

constexpr uint64_t Size = 0x1000;

//
// Page align an address.
//

constexpr uint64_t Align(const uint64_t Address) { return Address & ~0xfff; }

//
// Extract the page offset off an address.
//

constexpr uint64_t Offset(const uint64_t Address) { return Address & 0xfff; }
} // namespace Page

#if defined(WINDOWS)
class FileMap_t {
  //
  // Handle to the input file.
  //

  HANDLE File_ = nullptr;

  //
  // Handle to the file mapping.
  //

  HANDLE FileMap_ = nullptr;

  //
  // Base address of the file view.
  //

  PVOID ViewBase_ = nullptr;

  //
  // File size
  //

  uint64_t FileSize_ = 0;

public:
  ~FileMap_t() {
    //
    // Unmap the view of the mapping..
    //

    if (ViewBase_ != nullptr) {
      UnmapViewOfFile(ViewBase_);
      ViewBase_ = nullptr;
    }

    //
    // Close the handle to the file mapping..
    //

    if (FileMap_ != nullptr) {
      CloseHandle(FileMap_);
      FileMap_ = nullptr;
    }

    //
    // And finally the file itself.
    //

    if (File_ != nullptr) {
      CloseHandle(File_);
      File_ = nullptr;
    }
  }

  FileMap_t() = default;
  FileMap_t(const FileMap_t &) = delete;
  FileMap_t &operator=(const FileMap_t &) = delete;

  constexpr void *ViewBase() const { return ViewBase_; }

  bool MapFile(const char *PathFile) {
    bool Success = true;
    HANDLE File = nullptr;
    HANDLE FileMap = nullptr;
    PVOID ViewBase = nullptr;
    LARGE_INTEGER FileSize = {0};

    //
    // Open the dump file in read-only.
    //

    File = CreateFileA(PathFile, GENERIC_READ, FILE_SHARE_READ, nullptr,
                       OPEN_EXISTING, 0, nullptr);

    if (File == nullptr) {

      //
      // If we fail to open the file, let the user know.
      //

      const DWORD GLE = GetLastError();
      printf("CreateFile failed with GLE=%lu.\n", GLE);

      if (GLE == ERROR_FILE_NOT_FOUND) {
        printf("  The file %s was not found.\n", PathFile);
      }

      Success = false;
      goto clean;
    }

    //
    // Create the ro file mapping.
    //

    FileMap = CreateFileMappingA(File, nullptr, PAGE_READONLY, 0, 0, nullptr);

    if (FileMap == nullptr) {

      //
      // If we fail to create a file mapping, let
      // the user know.
      //

      const DWORD GLE = GetLastError();
      printf("CreateFileMapping failed with GLE=%lu.\n", GLE);
      Success = false;
      goto clean;
    }

    //
    // Map a view of the file in memory.
    //

    ViewBase = MapViewOfFile(FileMap, FILE_MAP_READ, 0, 0, 0);

    if (ViewBase == nullptr) {

      //
      // If we fail to map the view, let the user know.
      //

      const DWORD GLE = GetLastError();
      printf("MapViewOfFile failed with GLE=%lu.\n", GLE);
      Success = false;
      goto clean;
    }

    //
    // Get the file size.
    //

    if (!GetFileSizeEx(File, &FileSize)) {
      const DWORD GLE = GetLastError();
      printf("GetFileSizeEx failed with GLE=%lu.\n", GLE);
      Success = false;
      goto clean;
    }

    FileSize_ = Page::Align(FileSize.QuadPart) + Page::Size;

    //
    // Everything went well, so grab a copy of the handles for
    // our class and null-out the temporary variables.
    //

    File_ = File;
    File = nullptr;

    FileMap_ = FileMap;
    FileMap = nullptr;

    ViewBase_ = ViewBase;
    ViewBase = nullptr;

  clean:

    //
    // Close the handle to the file mapping..
    //

    if (FileMap != nullptr) {
      CloseHandle(FileMap);
      FileMap = nullptr;
    }

    //
    // And finally the file itself.
    //

    if (File != nullptr) {
      CloseHandle(File);
      File = nullptr;
    }

    return Success;
  }

  bool InBounds(const void *Ptr, const size_t Size) const {
    const uint8_t *ViewEnd = (uint8_t *)ViewBase_ + FileSize_;
    const uint8_t *PtrEnd = (uint8_t *)Ptr + Size;
    return PtrEnd > Ptr && ViewEnd > ViewBase_ && Ptr >= ViewBase_ &&
           PtrEnd < ViewEnd;
  }
};

#elif defined(LINUX)

class FileMap_t {
  void *ViewBase_ = nullptr;
  off_t ViewSize_ = 0;
  int Fd_ = -1;

public:
  ~FileMap_t() {
    if (ViewBase_) {
      munmap(ViewBase_, ViewSize_);
      ViewBase_ = nullptr;
      ViewSize_ = 0;
    }

    if (Fd_ != -1) {
      close(Fd_);
      Fd_ = -1;
    }
  }

  FileMap_t() = default;
  FileMap_t(const FileMap_t &) = delete;
  FileMap_t &operator=(const FileMap_t &) = delete;

  constexpr void *ViewBase() const { return ViewBase_; }

  bool MapFile(const char *PathFile) {
    Fd_ = open(PathFile, O_RDONLY);
    if (Fd_ < 0) {
      perror("Could not open dump file");
      return false;
    }

    struct stat Stat;
    if (fstat(Fd_, &Stat) < 0) {
      perror("Could not stat dump file");
      return false;
    }

    ViewSize_ = Page::Align(Stat.st_size) + Page::Size;
    ViewBase_ = mmap(nullptr, ViewSize_, PROT_READ, MAP_SHARED, Fd_, 0);
    if (ViewBase_ == MAP_FAILED) {
      perror("Could not mmap");
      return false;
    }

    return true;
  }

  bool InBounds(const void *Ptr, const size_t Size) const {
    const uint8_t *ViewEnd = (uint8_t *)ViewBase_ + ViewSize_;
    const uint8_t *PtrEnd = (uint8_t *)Ptr + Size;
    return PtrEnd > Ptr && ViewEnd > ViewBase_ && Ptr >= ViewBase_ &&
           PtrEnd < ViewEnd;
  }
};
#endif
} // namespace kdmpparser

```

`KDemu/include/kdmp-parser/kdmp-parser-structs.h`:

```h
// Axel '0vercl0k' Souchet - February 15 2019
#pragma once

#include "platform.h"
#include <array>
#include <cinttypes>
#include <cstddef>
#include <cstdint>
#include <cstdio>
#include <string_view>
#include <type_traits>
#include <variant>

namespace kdmpparser {

//
// We need a way to represent 128-bits integers so here goes.
//

struct uint128_t {
  uint64_t Low;
  uint64_t High;
};

static_assert(sizeof(uint128_t) == 16, "uint128_t's size looks wrong.");

enum class DumpType_t : uint32_t {
  // Old dump types from dbgeng.dll
  FullDump = 0x1,
  KernelDump = 0x2,
  BMPDump = 0x5,

  // New stuff
  MiniDump = 0x4,             // Produced by `.dump /m`
  LiveKernelBitmapDump = 0x6, // (22h2+) Produced by TaskMgr > System > Create
                              // Live Kernel Memory Dump
  KernelMemoryDump = 0x8,     // Produced by `.dump /k`
  KernelAndUserMemoryDump = 0x9, // Produced by `.dump /ka`
  CompleteMemoryDump = 0xa,      // Produced by `.dump /f`
};

//
// Save off the alignement setting and disable
// alignement.
//

#pragma pack(push)
#pragma pack(1)

//
// Field is a pointer inside the this object and this function
// returns the offset of Field in the object via pointer arithmetic.
//

constexpr uint64_t OffsetFromThis(const uintptr_t This, const uintptr_t Field) {
  return uint64_t(Field) - uint64_t(This);
}

static void DisplayHeader(const uint32_t Prefix, const char *FieldName,
                          const void *This, const void *Field) {
  printf("%*s+0x%04" PRIx64 ": %-25s", Prefix, "",
         OffsetFromThis(uintptr_t(This), uintptr_t(Field)), FieldName);
}

//
// This is the macro we use to get the field name via the preprocessor.
//

#define DISPLAY_FIELD(FieldName)                                               \
  DisplayField(Prefix + 2, #FieldName, this, &FieldName)

#define DISPLAY_FIELD_OFFSET(FieldName)                                        \
  DisplayHeader(Prefix + 2, #FieldName, this, &FieldName);                     \
  printf("\n")

//
// This takes care of displaying basic types.
//

constexpr std::string_view DumpTypeToString(const DumpType_t Type) {
  switch (Type) {
  // Old dump types from dbgeng.dll
  case DumpType_t::FullDump:
    return "FullDump";
  case DumpType_t::KernelDump:
    return "KernelDump";
  case DumpType_t::BMPDump:
    return "BMPDump";

  // New stuff
  case DumpType_t::MiniDump:
    return "MiniDump";
  case DumpType_t::LiveKernelBitmapDump:
    return "LiveKernelBitmapDump";
  case DumpType_t::KernelMemoryDump:
    return "KernelMemoryDump";
  case DumpType_t::KernelAndUserMemoryDump:
    return "KernelAndUserMemoryDump";
  case DumpType_t::CompleteMemoryDump:
    return "CompleteMemoryDump";
  }

  return "Unknown";
}

template <typename Field_t>
static void DisplayField(const uint32_t Prefix, const char *FieldName,
                         const void *This, const Field_t *Field) {
  DisplayHeader(Prefix, FieldName, This, Field);
  if constexpr (std::is_same<Field_t, uint8_t>::value) {
    printf(": 0x%02x.\n", *Field);
  } else if constexpr (std::is_same<Field_t, uint16_t>::value) {
    printf(": 0x%04x.\n", *Field);
  } else if constexpr (std::is_same<Field_t, uint32_t>::value) {
    printf(": 0x%08x.\n", *Field);
  } else if constexpr (std::is_same<Field_t, uint64_t>::value) {
    printf(": 0x%016" PRIx64 ".\n", *Field);
  } else if constexpr (std::is_same<Field_t, int64_t>::value) {
    printf(": 0x%016" PRIx64 ".\n", *Field);
  } else if constexpr (std::is_same<Field_t, uint128_t>::value) {
    printf(": 0x%016" PRIx64 "%016" PRIx64 ".\n", Field->High, Field->Low);
  } else if constexpr (std::is_same<Field_t, DumpType_t>::value) {
    printf(": %s.\n", DumpTypeToString(*Field).data());
  } else {

    //
    // We use std::is_same<> here because otherwise the static_assert fires
    // immediately on g++/clang++ without even instantiating FieldType_t.
    // So we kind of trick the compiler into doing what we want.
    //

    static_assert(std::is_same<Field_t, uint8_t>::value,
                  "DisplayField: Unknown type trying to be displayed.");
  }
}

//
// Display the header of a dump section.
//

#define DISPLAY_HEADER(Name) printf("%*s" Name "\n", Prefix, "")

//
// All credit goes to the rekall project for the RE of the file format.
// https://github.com/google/rekall/blob/master/rekall-core/rekall/plugins/overlays/windows/crashdump.py
//

struct PHYSMEM_RUN {
  uint64_t BasePage;
  uint64_t PageCount;

  void Show(const uint32_t Prefix = 0) const {
    DISPLAY_HEADER("PHYSMEM_RUN");
    DISPLAY_FIELD(BasePage);
    DISPLAY_FIELD(PageCount);
  }
};

static_assert(sizeof(PHYSMEM_RUN) == 0x10, "PHYSMEM_RUN's size looks wrong.");

struct PHYSMEM_DESC {
  uint32_t NumberOfRuns;
  uint32_t Padding0;
  uint64_t NumberOfPages;
  PHYSMEM_RUN Run[1];

  void Show(const uint32_t Prefix = 0) const {
    DISPLAY_HEADER("PHYSMEM_DESC");
    DISPLAY_FIELD(NumberOfRuns);
    DISPLAY_FIELD(NumberOfPages);
    DISPLAY_FIELD_OFFSET(Run);
    if (!LooksGood()) {
      return;
    }

    for (uint32_t RunIdx = 0; RunIdx < NumberOfRuns; RunIdx++) {
      Run[RunIdx].Show(Prefix + 2);
    }
  }

  constexpr bool LooksGood() const {
    if (NumberOfRuns == 0x45474150 || NumberOfPages == 0x4547415045474150ULL) {
      return false;
    }

    return true;
  }
};

static_assert(sizeof(PHYSMEM_DESC) == 0x20,
              "PHYSICAL_MEMORY_DESCRIPTOR's size looks wrong.");

struct BMP_HEADER64 {
  static constexpr uint32_t ExpectedSignature = 0x50'4D'44'53;  // 'PMDS'
  static constexpr uint32_t ExpectedSignature2 = 0x50'4D'44'46; // 'PMDF'
  static constexpr uint32_t ExpectedValidDump = 0x50'4D'55'44;  // 'PMUD'

  //
  // Should be FDMP.
  //

  uint32_t Signature;

  //
  // Should be DUMP.
  //

  uint32_t ValidDump;

  //
  // According to rekall there's a gap there:
  // 'ValidDump': [0x4, ['String', dict(
  //    length=4,
  //    term=None,
  //    )]],
  // # The offset of the first page in the file.
  // 'FirstPage': [0x20, ['unsigned long long']],
  //

  std::array<uint8_t, 0x20 - (0x4 + sizeof(ValidDump))> Padding0;

  //
  // The offset of the first page in the file.
  //

  uint64_t FirstPage;

  //
  // Total number of pages present in the bitmap.
  //
  uint64_t TotalPresentPages;

  //
  // Total number of pages in image.This dictates the total size of the
  // bitmap.This is not the same as the TotalPresentPages which is only
  // the sum of the bits set to 1.
  //

  uint64_t Pages;

  std::array<uint8_t, 1> Bitmap;

  bool LooksGood() const {

    //
    // Integrity check the headers.
    //

    if (Signature != ExpectedSignature && Signature != ExpectedSignature2) {
      printf("BMP_HEADER64::Signature looks wrong.\n");
      return false;
    }

    if (ValidDump != ExpectedValidDump) {
      printf("BMP_HEADER64::ValidDump looks wrong.\n");
      return false;
    }

    return true;
  }

  void Show(const uint32_t Prefix = 0) const {
    DISPLAY_HEADER("BMP_HEADER64");
    DISPLAY_FIELD(Signature);
    DISPLAY_FIELD(ValidDump);
    DISPLAY_FIELD(FirstPage);
    DISPLAY_FIELD(TotalPresentPages);
    DISPLAY_FIELD(Pages);
    DISPLAY_FIELD_OFFSET(Bitmap);
  }
};

static_assert(offsetof(BMP_HEADER64, FirstPage) == 0x20,
              "First page offset looks wrong.");

struct RDMP_HEADER64 {
  static constexpr uint32_t ExpectedMarker = 0x40;
  static constexpr uint32_t ExpectedSignature = 0x50'4D'44'52; // 'PMDR'
  static constexpr uint32_t ExpectedValidDump = 0x50'4D'55'44; // 'PMUD'

  uint32_t Marker;
  uint32_t Signature;
  uint32_t ValidDump;
  uint32_t __Unused;
  uint64_t MetadataSize;
  uint64_t FirstPageOffset;

  bool LooksGood() const {
    if (Marker != ExpectedMarker) {
      return false;
    }

    if (Signature != RDMP_HEADER64::ExpectedSignature) {
      return false;
    }

    if (ValidDump != RDMP_HEADER64::ExpectedValidDump) {
      return false;
    }

    if (MetadataSize - 0x20 !=
        FirstPageOffset -
            0x20'40) { // sizeof(HEADER64) + sizeof(RDMP_HEADERS64)
      return false;
    }

    return true;
  }

  void Show(const uint32_t Prefix = 0) const {
    DISPLAY_HEADER("RDMP_HEADER64");
    DISPLAY_FIELD(Signature);
    DISPLAY_FIELD(ValidDump);
    DISPLAY_FIELD(FirstPageOffset);
    DISPLAY_FIELD(MetadataSize);
  }
};

static_assert(sizeof(RDMP_HEADER64) == 0x20, "Invalid size for RDMP_HEADER64");

struct KERNEL_RDMP_HEADER64 {
  RDMP_HEADER64 Hdr;
  uint64_t __Unknown1;
  uint64_t __Unknown2;
  std::array<uint8_t, 1> Bitmap;
};

static_assert(sizeof(KERNEL_RDMP_HEADER64) == 0x30 + 1,
              "Invalid size for KERNEL_RDMP_HEADER64");

static_assert(offsetof(KERNEL_RDMP_HEADER64, Bitmap) == 0x30,
              "Invalid offset for KERNEL_RDMP_HEADER64");

struct FULL_RDMP_HEADER64 {
  RDMP_HEADER64 Hdr;
  uint32_t NumberOfRanges;
  uint16_t __Unknown1;
  uint16_t __Unknown2;
  uint64_t TotalNumberOfPages;
  std::array<uint8_t, 1> Bitmap;
};

static_assert(sizeof(FULL_RDMP_HEADER64) == 0x30 + 1,
              "Invalid size for FULL_RDMP_HEADER64");

static_assert(offsetof(FULL_RDMP_HEADER64, Bitmap) == 0x30,
              "Invalid offset for FULL_RDMP_HEADER64");

struct CONTEXT {

  //
  // Note that the below definition has been stolen directly from the windows
  // headers. Why you might ask? Well the structure comes with DECLSPEC_ALIGN
  // that was preventing me from layoung the Context structure at the offset I
  // wanted. Maybe there's a cleaner way to do this, if so let me know :)
  //

  //
  // Register parameter home addresses.
  //
  // N.B. These fields are for convience - they could be used to extend the
  //      context record in the future.
  //

  uint64_t P1Home;
  uint64_t P2Home;
  uint64_t P3Home;
  uint64_t P4Home;
  uint64_t P5Home;
  uint64_t P6Home;

  //
  // Control flags.
  //

  uint32_t ContextFlags;
  uint32_t MxCsr;

  //
  // Segment Registers and processor flags.
  //

  uint16_t SegCs;
  uint16_t SegDs;
  uint16_t SegEs;
  uint16_t SegFs;
  uint16_t SegGs;
  uint16_t SegSs;
  uint32_t EFlags;

  //
  // Debug registers
  //

  uint64_t Dr0;
  uint64_t Dr1;
  uint64_t Dr2;
  uint64_t Dr3;
  uint64_t Dr6;
  uint64_t Dr7;

  //
  // Integer registers.
  //

  uint64_t Rax;
  uint64_t Rcx;
  uint64_t Rdx;
  uint64_t Rbx;
  uint64_t Rsp;
  uint64_t Rbp;
  uint64_t Rsi;
  uint64_t Rdi;
  uint64_t R8;
  uint64_t R9;
  uint64_t R10;
  uint64_t R11;
  uint64_t R12;
  uint64_t R13;
  uint64_t R14;
  uint64_t R15;

  //
  // Program counter.
  //

  uint64_t Rip;

  //
  // Floating point state.
  //

  uint16_t ControlWord;
  uint16_t StatusWord;
  uint8_t TagWord;
  uint8_t Reserved1;
  uint16_t ErrorOpcode;
  uint32_t ErrorOffset;
  uint16_t ErrorSelector;
  uint16_t Reserved2;
  uint32_t DataOffset;
  uint16_t DataSelector;
  uint16_t Reserved3;
  uint32_t MxCsr2;
  uint32_t MxCsr_Mask;
  std::array<uint128_t, 8> FloatRegisters;
  uint128_t Xmm0;
  uint128_t Xmm1;
  uint128_t Xmm2;
  uint128_t Xmm3;
  uint128_t Xmm4;
  uint128_t Xmm5;
  uint128_t Xmm6;
  uint128_t Xmm7;
  uint128_t Xmm8;
  uint128_t Xmm9;
  uint128_t Xmm10;
  uint128_t Xmm11;
  uint128_t Xmm12;
  uint128_t Xmm13;
  uint128_t Xmm14;
  uint128_t Xmm15;

  //
  // Vector registers.
  //

  std::array<uint128_t, 26> VectorRegister;
  uint64_t VectorControl;

  //
  // Special debug control registers.
  //

  uint64_t DebugControl;
  uint64_t LastBranchToRip;
  uint64_t LastBranchFromRip;
  uint64_t LastExceptionToRip;
  uint64_t LastExceptionFromRip;

  bool LooksGood() const {

    //
    // Integrity check the CONTEXT record.
    //

    if (MxCsr != MxCsr2) {
      printf("CONTEXT::MxCsr doesn't match MxCsr2.\n");
      return false;
    }

    return true;
  }

  void Show(const uint32_t Prefix = 0) const {
    DISPLAY_HEADER("CONTEXT");
    DISPLAY_FIELD(P1Home);
    DISPLAY_FIELD(P2Home);
    DISPLAY_FIELD(P3Home);
    DISPLAY_FIELD(P4Home);
    DISPLAY_FIELD(P5Home);
    DISPLAY_FIELD(P6Home);

    //
    // Control flags.
    //

    DISPLAY_FIELD(ContextFlags);
    DISPLAY_FIELD(MxCsr);

    //
    // Segment Registers and processor flags.
    //

    DISPLAY_FIELD(SegCs);
    DISPLAY_FIELD(SegDs);
    DISPLAY_FIELD(SegEs);
    DISPLAY_FIELD(SegFs);
    DISPLAY_FIELD(SegGs);
    DISPLAY_FIELD(SegSs);
    DISPLAY_FIELD(EFlags);

    //
    // Debug registers.
    // XXX: Figure out what they don't look right.
    //

    DISPLAY_FIELD(Dr0);
    DISPLAY_FIELD(Dr1);
    DISPLAY_FIELD(Dr2);
    DISPLAY_FIELD(Dr3);
    DISPLAY_FIELD(Dr6);
    DISPLAY_FIELD(Dr7);

    //
    // Integer registers.
    //

    DISPLAY_FIELD(Rax);
    DISPLAY_FIELD(Rcx);
    DISPLAY_FIELD(Rdx);
    DISPLAY_FIELD(Rbx);
    DISPLAY_FIELD(Rsp);
    DISPLAY_FIELD(Rbp);
    DISPLAY_FIELD(Rsi);
    DISPLAY_FIELD(Rdi);
    DISPLAY_FIELD(R8);
    DISPLAY_FIELD(R9);
    DISPLAY_FIELD(R10);
    DISPLAY_FIELD(R11);
    DISPLAY_FIELD(R12);
    DISPLAY_FIELD(R13);
    DISPLAY_FIELD(R14);
    DISPLAY_FIELD(R15);

    //
    // Program counter.
    //

    DISPLAY_FIELD(Rip);

    //
    // Floating point state.
    //

    DISPLAY_FIELD(ControlWord);
    DISPLAY_FIELD(StatusWord);
    DISPLAY_FIELD(TagWord);
    DISPLAY_FIELD(ErrorOpcode);
    DISPLAY_FIELD(ErrorOffset);
    DISPLAY_FIELD(ErrorSelector);
    DISPLAY_FIELD(DataOffset);
    DISPLAY_FIELD(DataSelector);
    DISPLAY_FIELD(MxCsr2);
    DISPLAY_FIELD(MxCsr_Mask);
    DISPLAY_FIELD(FloatRegisters[0]);
    DISPLAY_FIELD(FloatRegisters[1]);
    DISPLAY_FIELD(FloatRegisters[2]);
    DISPLAY_FIELD(FloatRegisters[3]);
    DISPLAY_FIELD(FloatRegisters[4]);
    DISPLAY_FIELD(FloatRegisters[5]);
    DISPLAY_FIELD(FloatRegisters[6]);
    DISPLAY_FIELD(FloatRegisters[7]);
    DISPLAY_FIELD(Xmm0);
    DISPLAY_FIELD(Xmm1);
    DISPLAY_FIELD(Xmm2);
    DISPLAY_FIELD(Xmm3);
    DISPLAY_FIELD(Xmm4);
    DISPLAY_FIELD(Xmm5);
    DISPLAY_FIELD(Xmm6);
    DISPLAY_FIELD(Xmm7);
    DISPLAY_FIELD(Xmm8);
    DISPLAY_FIELD(Xmm9);
    DISPLAY_FIELD(Xmm10);
    DISPLAY_FIELD(Xmm11);
    DISPLAY_FIELD(Xmm12);
    DISPLAY_FIELD(Xmm13);
    DISPLAY_FIELD(Xmm14);
    DISPLAY_FIELD(Xmm15);

    //
    // Vector registers.
    //

    // M128A VectorRegister[26];
    DISPLAY_FIELD(VectorControl);

    //
    // Special debug control registers.
    //

    DISPLAY_FIELD(DebugControl);
    DISPLAY_FIELD(LastBranchToRip);
    DISPLAY_FIELD(LastBranchFromRip);
    DISPLAY_FIELD(LastExceptionToRip);
    DISPLAY_FIELD(LastExceptionFromRip);
  }
};

static_assert(offsetof(CONTEXT, Xmm0) == 0x1a0,
              "The offset of Xmm0 looks wrong.");

struct EXCEPTION_RECORD64 {
  uint32_t ExceptionCode;
  uint32_t ExceptionFlags;
  uint64_t ExceptionRecord;
  uint64_t ExceptionAddress;
  uint32_t NumberParameters;
  uint32_t __unusedAlignment;
  std::array<uint64_t, 15> ExceptionInformation;

  void Show(const uint32_t Prefix = 0) const {
    DISPLAY_HEADER("KDMP_PARSER_EXCEPTION_RECORD64");
    DISPLAY_FIELD(ExceptionCode);
    DISPLAY_FIELD(ExceptionFlags);
    DISPLAY_FIELD(ExceptionRecord);
    DISPLAY_FIELD(ExceptionAddress);
    DISPLAY_FIELD(NumberParameters);
    DISPLAY_FIELD(ExceptionInformation[0]);
    DISPLAY_FIELD(ExceptionInformation[1]);
    DISPLAY_FIELD(ExceptionInformation[2]);
    DISPLAY_FIELD(ExceptionInformation[3]);
    DISPLAY_FIELD(ExceptionInformation[4]);
    DISPLAY_FIELD(ExceptionInformation[5]);
    DISPLAY_FIELD(ExceptionInformation[6]);
    DISPLAY_FIELD(ExceptionInformation[7]);
    DISPLAY_FIELD(ExceptionInformation[8]);
    DISPLAY_FIELD(ExceptionInformation[9]);
    DISPLAY_FIELD(ExceptionInformation[10]);
    DISPLAY_FIELD(ExceptionInformation[11]);
    DISPLAY_FIELD(ExceptionInformation[12]);
    DISPLAY_FIELD(ExceptionInformation[13]);
    DISPLAY_FIELD(ExceptionInformation[14]);
  }
};

static_assert(sizeof(EXCEPTION_RECORD64) == 0x98,
              "KDMP_PARSER_EXCEPTION_RECORD64's size looks wrong.");

union DUMP_FILE_ATTRIBUTES {
  struct DUMP_FILE_ATTRIBUTES_0 {
    uint32_t _bitfield;
  } Anonymous;
  uint32_t Attributes;
};

//
// Adjusted C struct for `DUMP_HEADERS64` from MS Rust docs. Padding
// adjustment added from reversing `nt!IoFillDumpHeader`.
//
// @link
// https://microsoft.github.io/windows-docs-rs/doc/windows/Win32/System/Diagnostics/Debug/struct.DUMP_HEADER64.html#structfield.DumpType
//

struct HEADER64 {
  static constexpr uint32_t ExpectedSignature = 0x45474150; // 'EGAP'
  static constexpr uint32_t ExpectedValidDump = 0x34365544; // '46UD'

  /* 0x0000 */ uint32_t Signature;
  /* 0x0004 */ uint32_t ValidDump;
  /* 0x0008 */ uint32_t MajorVersion;
  /* 0x000c */ uint32_t MinorVersion;
  /* 0x0010 */ uint64_t DirectoryTableBase;
  /* 0x0018 */ uint64_t PfnDatabase;
  /* 0x0020 */ uint64_t PsLoadedModuleList;
  /* 0x0028 */ uint64_t PsActiveProcessHead;
  /* 0x0030 */ uint32_t MachineImageType;
  /* 0x0034 */ uint32_t NumberProcessors;
  /* 0x0038 */ uint32_t BugCheckCode;
  /* 0x003c */ uint32_t __Padding0;
  /* 0x0040 */ std::array<uint64_t, 4> BugCheckCodeParameters;
  /* 0x0060 */ std::array<uint8_t, 32> VersionUser;
  /* 0x0080 */ uint64_t KdDebuggerDataBlock;
  /* 0x0088 */ union DUMP_HEADER64_0 {
    PHYSMEM_DESC PhysicalMemoryBlock;
    std::array<uint8_t, 700> PhysicalMemoryBlockBuffer;
  } u1;
  /* 0x0344 */ uint32_t __Padding1;
  /* 0x0348 */ union CONTEXT_RECORD64_0 {
    CONTEXT ContextRecord;
    std::array<uint8_t, 3000> ContextRecordBuffer;
  } u2;
  /* 0x0f00 */ EXCEPTION_RECORD64 Exception;
  /* 0x0f98 */ DumpType_t DumpType;
  /* 0x0f9c */ uint32_t __Padding2;
  /* 0x0fa0 */ int64_t RequiredDumpSpace;
  /* 0x0fa8 */ int64_t SystemTime;
  /* 0x0fb0 */ std::array<uint8_t, 128> Comment;
  /* 0x1030 */ int64_t SystemUpTime;
  /* 0x1038 */ uint32_t MiniDumpFields;
  /* 0x103c */ uint32_t SecondaryDataState;
  /* 0x1040 */ uint32_t ProductType;
  /* 0x1044 */ uint32_t SuiteMask;
  /* 0x1048 */ uint32_t WriterStatus;
  /* 0x104c */ uint8_t Unused1;
  /* 0x104d */ uint8_t KdSecondaryVersion;
  /* 0x104e */ std::array<uint8_t, 2> Unused;
  /* 0x1050 */ DUMP_FILE_ATTRIBUTES Attributes;
  /* 0x1054 */ uint32_t BootId;
  /* 0x1058 */ std::array<uint8_t, 4008> _reserved0;

  union {
    BMP_HEADER64 BmpHeader;
    KERNEL_RDMP_HEADER64 RdmpHeader;
    FULL_RDMP_HEADER64 FullRdmpHeader;
  } u3;

  bool LooksGood() const {

    //
    // Integrity check the headers.
    //

    if (Signature != ExpectedSignature) {
      printf("HEADER64::Signature looks wrong.\n");
      return false;
    }

    if (ValidDump != ExpectedValidDump) {
      printf("HEADER64::ValidDump looks wrong.\n");
      return false;
    }

    //
    // Make sure it's a dump type we know how to handle.
    //

    switch (DumpType) {
    case DumpType_t::FullDump: {
      if (!u1.PhysicalMemoryBlock.LooksGood()) {
        printf("The PhysicalMemoryBlockBuffer looks wrong.\n");
        return false;
      }
      break;
    }

    case DumpType_t::LiveKernelBitmapDump:
    case DumpType_t::BMPDump: {
      if (!u3.BmpHeader.LooksGood()) {
        printf("The BmpHeader looks wrong.\n");
        return false;
      }
      break;
    }

    case DumpType_t::KernelAndUserMemoryDump:
    case DumpType_t::KernelMemoryDump: {
      if (!u3.RdmpHeader.Hdr.LooksGood()) {
        printf("The RdmpHeader looks wrong.\n");
        return false;
      }
      break;
    }

    case DumpType_t::CompleteMemoryDump: {
      if (!u3.FullRdmpHeader.Hdr.LooksGood()) {
        printf("The RdmpHeader looks wrong.\n");
        return false;
      }
      break;
    }

    case DumpType_t::MiniDump: {
      printf("Unsupported type %s (%#x).\n", DumpTypeToString(DumpType).data(),
             uint32_t(DumpType));
      return false;
    }

    default: {
      printf("Unknown Type %#x.\n", uint32_t(DumpType));
      return false;
    }
    }

    //
    // Integrity check the CONTEXT record.
    //

    if (!u2.ContextRecord.LooksGood()) {
      return false;
    }

    return true;
  }

  void Show(const uint32_t Prefix = 0) const {
    DISPLAY_HEADER("HEADER64");
    DISPLAY_FIELD(Signature);
    DISPLAY_FIELD(ValidDump);
    DISPLAY_FIELD(MajorVersion);
    DISPLAY_FIELD(MinorVersion);
    DISPLAY_FIELD(DirectoryTableBase);
    DISPLAY_FIELD(PfnDatabase);
    DISPLAY_FIELD(PsLoadedModuleList);
    DISPLAY_FIELD(PsActiveProcessHead);
    DISPLAY_FIELD(MachineImageType);
    DISPLAY_FIELD(NumberProcessors);
    DISPLAY_FIELD(BugCheckCode);
    DISPLAY_FIELD_OFFSET(BugCheckCodeParameters);
    DISPLAY_FIELD(KdDebuggerDataBlock);
    DISPLAY_FIELD_OFFSET(u1.PhysicalMemoryBlockBuffer);
    u1.PhysicalMemoryBlock.Show(Prefix + 2);
    DISPLAY_FIELD_OFFSET(u2.ContextRecordBuffer);
    u2.ContextRecord.Show(Prefix + 2);
    DISPLAY_FIELD_OFFSET(Exception);
    Exception.Show(Prefix + 2);
    DISPLAY_FIELD(DumpType);
    DISPLAY_FIELD(RequiredDumpSpace);
    DISPLAY_FIELD(SystemTime);
    DISPLAY_FIELD_OFFSET(Comment);
    DISPLAY_FIELD(SystemUpTime);
    DISPLAY_FIELD(MiniDumpFields);
    DISPLAY_FIELD(SecondaryDataState);
    DISPLAY_FIELD(ProductType);
    DISPLAY_FIELD(SuiteMask);
    DISPLAY_FIELD(WriterStatus);
    DISPLAY_FIELD(KdSecondaryVersion);
    if (DumpType == DumpType_t::BMPDump) {
      DISPLAY_FIELD_OFFSET(u3.BmpHeader);
      u3.BmpHeader.Show();
    }
  }
};

//
// Restore the default alignement setting.
//

#pragma pack(pop)

//
// Prevent the user to play around with those.
//

#undef DISPLAY_HEADER
#undef DISPLAY_FIELD

//
// Those asserts are the results of a lot of frustration getting the right
// layout, so hopefully they prevent any regressions regarding the layout.
//

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Winvalid-offsetof"
#endif //__GNUC__
static_assert(offsetof(HEADER64, Signature) == 0x00,
              "The offset of KdDebuggerDataBlock looks wrong.");

static_assert(offsetof(HEADER64, BugCheckCodeParameters) == 0x40,
              "The offset of KdDebuggerDataBlock looks wrong.");

static_assert(offsetof(HEADER64, KdDebuggerDataBlock) == 0x80,
              "The offset of KdDebuggerDataBlock looks wrong.");

static_assert(offsetof(HEADER64, u2.ContextRecord) == 0x348,
              "The offset of ContextRecord looks wrong.");

static_assert(offsetof(HEADER64, Exception) == 0xf00,
              "The offset of Exception looks wrong.");

static_assert(offsetof(HEADER64, Comment) == 0xfb0,
              "The offset of Comment looks wrong.");

static_assert(offsetof(HEADER64, u3.BmpHeader) == 0x2000,
              "The offset of BmpHeaders looks wrong.");
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif //__GNUC__

//
// Structure for parsing a PTE.
//

union MMPTE_HARDWARE {
  struct {
    uint64_t Present : 1;
    uint64_t Write : 1;
    uint64_t UserAccessible : 1;
    uint64_t WriteThrough : 1;
    uint64_t CacheDisable : 1;
    uint64_t Accessed : 1;
    uint64_t Dirty : 1;
    uint64_t LargePage : 1;
    uint64_t Available : 4;
    uint64_t PageFrameNumber : 36;
    uint64_t ReservedForHardware : 4;
    uint64_t ReservedForSoftware : 11;
    uint64_t NoExecute : 1;
  } u;
  uint64_t AsUINT64;
  constexpr MMPTE_HARDWARE(const uint64_t Value) : AsUINT64(Value) {}
};

//
// Structure to parse a virtual address.
//

union VIRTUAL_ADDRESS {
  struct {
    uint64_t Offset : 12;
    uint64_t PtIndex : 9;
    uint64_t PdIndex : 9;
    uint64_t PdPtIndex : 9;
    uint64_t Pml4Index : 9;
    uint64_t Reserved : 16;
  } u;
  uint64_t AsUINT64;
  constexpr VIRTUAL_ADDRESS(const uint64_t Value) : AsUINT64(Value) {}
};

static_assert(sizeof(MMPTE_HARDWARE) == 8);
static_assert(sizeof(VIRTUAL_ADDRESS) == 8);
} // namespace kdmpparser
```

`KDemu/include/kdmp-parser/kdmp-parser-version.h.in`:

```in
#pragma once

// clang-format off
#define KDMPPARSER_PROJECT_NAME "@PROJECT_NAME@"
#define KDMPPARSER_PROJECT_AUTHOR "@PROJECT_AUTHOR@"
#define KDMPPARSER_PROJECT_LICENSE "@PROJECT_LICENSE@"
#define KDMPPARSER_VERSION_MAJOR @PROJECT_VERSION_MAJOR@
#define KDMPPARSER_VERSION_MINOR @PROJECT_VERSION_MINOR@
#define KDMPPARSER_VERSION_PATCH @PROJECT_VERSION_PATCH@
#define KDMPPARSER_VERSION_RELEASE "@PROJECT_VERSION_MAJOR@.@PROJECT_VERSION_MINOR@.@PROJECT_VERSION_PATCH@"
// clang-format on

```

`KDemu/include/kdmp-parser/kdmp-parser.h`:

```h
// Axel '0vercl0k' Souchet - February 15 2019
#pragma once

#include "filemap.h"
#include "kdmp-parser-structs.h"
#include "kdmp-parser-version.h"

#include <array>
#include <cstdint>
#include <cstdio>
#include <filesystem>
#include <optional>
#include <string>
#include <unordered_map>

namespace kdmpparser {

using Page_t = std::array<uint8_t, kdmpparser::Page::Size>;
using Physmem_t = std::unordered_map<uint64_t, const uint8_t *>;

struct BugCheckParameters_t {
  uint32_t BugCheckCode;
  std::array<uint64_t, 4> BugCheckCodeParameter;
};

class KernelDumpParser {

  //
  // The mapped file.
  //

  FileMap_t FileMap_;

  //
  // Header of the crash-dump.
  //

  HEADER64 *DmpHdr_ = nullptr;

  //
  // File path to the crash-dump.
  //

  std::filesystem::path PathFile_;

  //
  // Mapping between physical addresses / page data.
  //

  Physmem_t Physmem_;

public:
  //
  // Actually do the parsing of the file.
  //

  bool Parse(const char *PathFile) {

    //
    // Copy the path file.
    //

    PathFile_ = std::filesystem::path(PathFile);
    if (!std::filesystem::exists(PathFile_)) {
      printf("Invalid file: %s.\n", (char *)PathFile_.string().c_str());
      return false;
    }

    //
    // Map a view of the file.
    //

    if (!MapFile()) {
      printf("MapFile failed.\n");
      return false;
    }

    //
    // Parse the DMP_HEADER.
    //

    if (!ParseDmpHeader()) {
      printf("ParseDmpHeader failed.\n");
      return false;
    }

    //
    // Retrieve the physical memory according to the type of dump we have.
    //

    switch (DmpHdr_->DumpType) {
    case DumpType_t::FullDump: {
      if (!BuildPhysmemFullDump()) {
        printf("BuildPhysmemFullDump failed.\n");
        return false;
      }
      break;
    }
    case DumpType_t::LiveKernelBitmapDump:
    case DumpType_t::BMPDump: {
      if (!BuildPhysmemBMPDump()) {
        printf("BuildPhysmemBMPDump failed.\n");
        return false;
      }
      break;
    }

    case DumpType_t::CompleteMemoryDump:
    case DumpType_t::KernelAndUserMemoryDump:
    case DumpType_t::KernelMemoryDump: {
      if (!BuildPhysicalMemoryFromDump(DmpHdr_->DumpType)) {
        printf("BuildPhysicalMemoryFromDump failed.\n");
        return false;
      }
      break;
    }

    default: {
      printf("Invalid type\n");
      return false;
    }
    }

    return true;
  }

  //
  // Give the Context record to the user.
  //

  constexpr const CONTEXT &GetContext() const {

    //
    // Give the user a view of the context record.
    //

    return DmpHdr_->u2.ContextRecord;
  }

  //
  // Give the bugcheck parameters to the user.
  //

  constexpr BugCheckParameters_t GetBugCheckParameters() const {

    //
    // Give the user a view of the bugcheck parameters.
    //

    return {DmpHdr_->BugCheckCode,
            {DmpHdr_->BugCheckCodeParameters[0],
             DmpHdr_->BugCheckCodeParameters[1],
             DmpHdr_->BugCheckCodeParameters[2],
             DmpHdr_->BugCheckCodeParameters[3]}};
  }

  //
  // Get the path of dump.
  //

  const std::filesystem::path &GetDumpPath() const { return PathFile_; }

  //
  // Get the type of dump.
  //

  constexpr DumpType_t GetDumpType() const { return DmpHdr_->DumpType; }

  //
  // Get the physmem.
  //

  constexpr const Physmem_t &GetPhysmem() const { return Physmem_; }

  //
  // Show the exception record.
  //

  void ShowExceptionRecord(const uint32_t Prefix) const {
    DmpHdr_->Exception.Show(Prefix);
  }

  //
  // Show the context record.
  //

  void ShowContextRecord(const uint32_t Prefix) const {
    const CONTEXT &Context = GetContext();
    printf("%*srax=%016" PRIx64 " rbx=%016" PRIx64 " rcx=%016" PRIx64 "\n",
           Prefix, "", Context.Rax, Context.Rbx, Context.Rcx);
    printf("%*srdx=%016" PRIx64 " rsi=%016" PRIx64 " rdi=%016" PRIx64 "\n",
           Prefix, "", Context.Rdx, Context.Rsi, Context.Rdi);
    printf("%*srip=%016" PRIx64 " rsp=%016" PRIx64 " rbp=%016" PRIx64 "\n",
           Prefix, "", Context.Rip, Context.Rsp, Context.Rbp);
    printf("%*s r8=%016" PRIx64 "  r9=%016" PRIx64 " r10=%016" PRIx64 "\n",
           Prefix, "", Context.R8, Context.R9, Context.R10);
    printf("%*sr11=%016" PRIx64 " r12=%016" PRIx64 " r13=%016" PRIx64 "\n",
           Prefix, "", Context.R11, Context.R12, Context.R13);
    printf("%*sr14=%016" PRIx64 " r15=%016" PRIx64 "\n", Prefix, "",
           Context.R14, Context.R15);
    printf("%*scs=%04x ss=%04x ds=%04x es=%04x fs=%04x gs=%04x    "
           "             efl=%08x\n",
           Prefix, "", Context.SegCs, Context.SegSs, Context.SegDs,
           Context.SegEs, Context.SegFs, Context.SegGs, Context.EFlags);
    printf("%*sfpcw=%04x    fpsw=%04x    fptw=%04x\n", Prefix, "",
           Context.ControlWord, Context.StatusWord, 1);
    printf("%*s  st0=%016" PRIx64 "%016" PRIx64 "       st1=%016" PRIx64
           "%016" PRIx64 "\n",
           Prefix, "", Context.FloatRegisters[0].High,
           Context.FloatRegisters[0].Low, Context.FloatRegisters[1].High,
           Context.FloatRegisters[1].Low);
    printf("%*s  st2=%016" PRIx64 "%016" PRIx64 "       st3=%016" PRIx64
           "%016" PRIx64 "\n",
           Prefix, "", Context.FloatRegisters[2].High,
           Context.FloatRegisters[2].Low, Context.FloatRegisters[3].High,
           Context.FloatRegisters[3].Low);
    printf("%*s  st4=%016" PRIx64 "%016" PRIx64 "       st5=%016" PRIx64
           "%016" PRIx64 "\n",
           Prefix, "", Context.FloatRegisters[4].High,
           Context.FloatRegisters[4].Low, Context.FloatRegisters[5].High,
           Context.FloatRegisters[5].Low);
    printf("%*s  st6=%016" PRIx64 "%016" PRIx64 "       st7=%016" PRIx64
           "%016" PRIx64 "\n",
           Prefix, "", Context.FloatRegisters[6].High,
           Context.FloatRegisters[6].Low, Context.FloatRegisters[7].High,
           Context.FloatRegisters[7].Low);
    printf("%*s xmm0=%016" PRIx64 "%016" PRIx64 "      xmm1=%016" PRIx64
           "%016" PRIx64 "\n",
           Prefix, "", Context.Xmm0.High, Context.Xmm0.Low, Context.Xmm1.High,
           Context.Xmm1.Low);
    printf("%*s xmm2=%016" PRIx64 "%016" PRIx64 "      xmm3=%016" PRIx64
           "%016" PRIx64 "\n",
           Prefix, "", Context.Xmm2.High, Context.Xmm2.Low, Context.Xmm3.High,
           Context.Xmm3.Low);
    printf("%*s xmm4=%016" PRIx64 "%016" PRIx64 "      xmm5=%016" PRIx64
           "%016" PRIx64 "\n",
           Prefix, "", Context.Xmm4.High, Context.Xmm4.Low, Context.Xmm5.High,
           Context.Xmm5.Low);
    printf("%*s xmm6=%016" PRIx64 "%016" PRIx64 "      xmm7=%016" PRIx64
           "%016" PRIx64 "\n",
           Prefix, "", Context.Xmm6.High, Context.Xmm6.Low, Context.Xmm7.High,
           Context.Xmm7.Low);
    printf("%*s xmm8=%016" PRIx64 "%016" PRIx64 "      xmm9=%016" PRIx64
           "%016" PRIx64 "\n",
           Prefix, "", Context.Xmm8.High, Context.Xmm8.Low, Context.Xmm9.High,
           Context.Xmm9.Low);
    printf("%*sxmm10=%016" PRIx64 "%016" PRIx64 "     xmm11=%016" PRIx64
           "%016" PRIx64 "\n",
           Prefix, "", Context.Xmm10.High, Context.Xmm10.Low,
           Context.Xmm11.High, Context.Xmm11.Low);
    printf("%*sxmm12=%016" PRIx64 "%016" PRIx64 "     xmm13=%016" PRIx64
           "%016" PRIx64 "\n",
           Prefix, "", Context.Xmm12.High, Context.Xmm12.Low,
           Context.Xmm13.High, Context.Xmm13.Low);
    printf("%*sxmm14=%016" PRIx64 "%016" PRIx64 "     xmm15=%016" PRIx64
           "%016" PRIx64 "\n",
           Prefix, "", Context.Xmm14.High, Context.Xmm14.Low,
           Context.Xmm15.High, Context.Xmm15.Low);
  }

  //
  // Show all the structures of the dump.
  //

  void ShowAllStructures(const uint32_t Prefix) const { DmpHdr_->Show(Prefix); }

  //
  // Get the content of a physical address.
  //

  const uint8_t *GetPhysicalPage(const uint64_t PhysicalAddress) const {

    //
    // Attempt to find the physical address.
    //

    const auto &Pair = Physmem_.find(PhysicalAddress);

    //
    // If it doesn't exist then return nullptr.
    //

    if (Pair == Physmem_.end()) {
      return nullptr;
    }

    //
    // Otherwise we return a pointer to the content of the page.
    //

    return Pair->second;
  }

  //
  // Get the directory table base.
  //

  constexpr uint64_t GetDirectoryTableBase() const {
    return DmpHdr_->DirectoryTableBase;
  }

  //
  // Translate a virtual address to physical address using a directory table
  // base.
  //

  std::optional<uint64_t>
  VirtTranslate(const uint64_t VirtualAddress,
                const uint64_t DirectoryTableBase = 0) const {

    //
    // If DirectoryTableBase is null ; use the one from the dump header and
    // clear PCID bits (bits 11:0).
    //

    uint64_t LocalDTB = Page::Align(GetDirectoryTableBase());

    if (DirectoryTableBase) {
      LocalDTB = Page::Align(DirectoryTableBase);
    }

    //
    // Stole code from @yrp604 and @0vercl0k.
    //

    const VIRTUAL_ADDRESS GuestAddress(VirtualAddress);
    const MMPTE_HARDWARE Pml4(LocalDTB);
    const uint64_t Pml4Base = Pml4.u.PageFrameNumber * Page::Size;
    const uint64_t Pml4eGpa = Pml4Base + GuestAddress.u.Pml4Index * 8;
    const MMPTE_HARDWARE Pml4e(PhyRead8(Pml4eGpa));
    if (!Pml4e.u.Present) {
      printf("Invalid page map level 4, address translation failed!\n");
      return {};
    }

    const uint64_t PdptBase = Pml4e.u.PageFrameNumber * Page::Size;
    const uint64_t PdpteGpa = PdptBase + GuestAddress.u.PdPtIndex * 8;
    const MMPTE_HARDWARE Pdpte(PhyRead8(PdpteGpa));
    if (!Pdpte.u.Present) {
      printf("Invalid page directory pointer table, address translation "
             "failed!\n");
      return {};
    }

    //
    // huge pages:
    // 7 (PS) - Page size; must be 1 (otherwise, this entry references a page
    // directory; see Table 4-1
    //

    const uint64_t PdBase = Pdpte.u.PageFrameNumber * Page::Size;
    if (Pdpte.u.LargePage) {
      return PdBase + (VirtualAddress & 0x3fff'ffff);
    }

    const uint64_t PdeGpa = PdBase + GuestAddress.u.PdIndex * 8;
    const MMPTE_HARDWARE Pde(PhyRead8(PdeGpa));
    if (!Pde.u.Present) {
      printf("Invalid page directory entry, address translation failed!\n");
      return {};
    }

    //
    // large pages:
    // 7 (PS) - Page size; must be 1 (otherwise, this entry references a page
    // table; see Table 4-18
    //

    const uint64_t PtBase = Pde.u.PageFrameNumber * Page::Size;
    if (Pde.u.LargePage) {
      return PtBase + (VirtualAddress & 0x1f'ffff);
    }

    const uint64_t PteGpa = PtBase + GuestAddress.u.PtIndex * 8;
    const MMPTE_HARDWARE Pte(PhyRead8(PteGpa));
    if (!Pte.u.Present) {
      printf("Invalid page table entry, address translation failed!\n");
      return {};
    }

    const uint64_t PageBase = Pte.u.PageFrameNumber * Page::Size;
    return PageBase + GuestAddress.u.Offset;
  }

  //
  // Get the content of a virtual address.
  //

  const uint8_t *GetVirtualPage(const uint64_t VirtualAddress,
                                const uint64_t DirectoryTableBase = 0) const {

    //
    // First remove offset and translate the virtual address.
    //

    const auto &PhysicalAddress =
        VirtTranslate(Page::Align(VirtualAddress), DirectoryTableBase);

    if (!PhysicalAddress) {
      return nullptr;
    }

    //
    // Then get the physical page.
    //

    return GetPhysicalPage(*PhysicalAddress);
  }

  const HEADER64 &GetDumpHeader() const {
    if (!DmpHdr_) {
      std::abort();
    }

    return *DmpHdr_;
  }

private:
  //
  // Utility function to read an uint64_t from a physical address.
  //

  uint64_t PhyRead8(const uint64_t PhysicalAddress) const {

    //
    // Get the physical page and read from the offset.
    //

    const uint8_t *PhysicalPage = GetPhysicalPage(Page::Align(PhysicalAddress));

    if (!PhysicalPage) {
      printf("Internal page table parsing failed!\n");
      return 0;
    }

    const uint64_t *Ptr =
        (uint64_t *)(PhysicalPage + Page::Offset(PhysicalAddress));
    return *Ptr;
  }

  //
  // Build a map of physical addresses / page data pointers for full dump.
  //

  bool BuildPhysmemFullDump() {

    //
    // Walk through the runs.
    //

    uint8_t *RunBase = (uint8_t *)&DmpHdr_->u3.BmpHeader;
    const uint32_t NumberOfRuns = DmpHdr_->u1.PhysicalMemoryBlock.NumberOfRuns;

    //
    // Back at it, this time building the index!
    //

    for (uint32_t RunIdx = 0; RunIdx < NumberOfRuns; RunIdx++) {

      //
      // Grab the current run as well as its base page and page count.
      //

      const PHYSMEM_RUN *Run = DmpHdr_->u1.PhysicalMemoryBlock.Run + RunIdx;

      const uint64_t BasePage = Run->BasePage;
      const uint64_t PageCount = Run->PageCount;

      //
      // Walk the pages from the run.
      //

      for (uint64_t PageIdx = 0; PageIdx < PageCount; PageIdx++) {

        //
        // Compute the current PFN as well as the actual physical address of
        // the page.
        //

        const uint64_t Pfn = BasePage + PageIdx;
        const uint64_t Pa = Pfn * Page::Size;

        //
        // Now one thing to understand is that the Runs structure allows to
        // skip for holes in memory. Instead of, padding them with empty
        // spaces to conserve a 1:1 mapping between physical address and file
        // offset, the Run gives you the base Pfn. This means that we don't
        // have a 1:1 mapping between file offset and physical addresses so we
        // need to keep track of where the Run starts in memory and then we
        // can simply access our pages one after the other.
        //
        // If this is not clear enough, here is a small example:
        //  Run[0]
        //    BasePage = 1337, PageCount = 2
        //  Run[1]
        //    BasePage = 1400, PageCount = 1
        //
        // In the above we clearly see that there is a hole between the two
        // runs; the dump file has 2+1 memory pages. Their Pfns are: 1337+0,
        // 1337+1, 1400+0.
        //
        // Now if we want to get the file offset of those pages we start at
        // Run0:
        //   Run0 starts at file offset 0x2000 so Page0 is at file offset
        //   0x2000, Page1 is at file offset 0x3000. Run1 starts at file
        //   offset 0x2000+(2*0x1000) so Page3 is at file offset
        //   0x2000+(2*0x1000)+0x1000.
        //
        // That is the reason why the computation below is RunBase + (PageIdx
        // * 0x1000) instead of RunBase + (Pfn * 0x1000).

        const uint8_t *PageBase = RunBase + (PageIdx * Page::Size);

        //
        // Map the Pfn to a page.
        //

        Physmem_.try_emplace(Pa, PageBase);
      }

      //
      // Move the run base past all the pages in the current run.
      //

      RunBase += PageCount * Page::Size;
    }

    return true;
  }

  //
  // Build a map of physical addresses / page data pointers for BMP dump.
  //

  bool BuildPhysmemBMPDump() {
    const uint8_t *Page = (uint8_t *)DmpHdr_ + DmpHdr_->u3.BmpHeader.FirstPage;
    const uint64_t BitmapSize = DmpHdr_->u3.BmpHeader.Pages / 8;
    const uint8_t *Bitmap = DmpHdr_->u3.BmpHeader.Bitmap.data();

    //
    // Walk the bitmap byte per byte.
    //

    for (uint64_t BitmapIdx = 0; BitmapIdx < BitmapSize; BitmapIdx++) {

      //
      // Now walk the bits of the current byte.
      //

      const uint8_t Byte = Bitmap[BitmapIdx];
      for (uint8_t BitIdx = 0; BitIdx < 8; BitIdx++) {

        //
        // If the bit is not set we just skip to the next.
        //

        const bool BitSet = ((Byte >> BitIdx) & 1) == 1;
        if (!BitSet) {
          continue;
        }

        //
        // If the bit is one we add the page to the physmem.
        //

        const uint64_t Pfn = (BitmapIdx * 8) + BitIdx;
        const uint64_t Pa = Pfn * Page::Size;
        Physmem_.try_emplace(Pa, Page);
        Page += Page::Size;
      }
    }

    return true;
  }

  //
  // Populate the physical memory map for the 'new' dump types.
  // `Type` must be either `KernelMemoryDump`, `KernelAndUserMemoryDump`,
  // or `CompleteMemoryDump`.
  //
  // Returns true on success, false otherwise.
  //

  bool BuildPhysicalMemoryFromDump(const DumpType_t Type) {
    uint64_t FirstPageOffset = 0;
    uint8_t *Page = nullptr;
    uint64_t MetadataSize = 0;
    uint8_t *Bitmap = nullptr;
    uint64_t TotalNumberOfPages = 0;
    uint64_t CurrentPageCount = 0;

    switch (Type) {
    case DumpType_t::KernelMemoryDump:
    case DumpType_t::KernelAndUserMemoryDump: {
      FirstPageOffset = DmpHdr_->u3.RdmpHeader.Hdr.FirstPageOffset;
      Page = (uint8_t *)DmpHdr_ + FirstPageOffset;
      MetadataSize = DmpHdr_->u3.RdmpHeader.Hdr.MetadataSize;
      Bitmap = DmpHdr_->u3.RdmpHeader.Bitmap.data();
      break;
    }

    case DumpType_t::CompleteMemoryDump: {
      FirstPageOffset = DmpHdr_->u3.FullRdmpHeader.Hdr.FirstPageOffset;
      Page = (uint8_t *)DmpHdr_ + FirstPageOffset;
      MetadataSize = DmpHdr_->u3.FullRdmpHeader.Hdr.MetadataSize;
      Bitmap = DmpHdr_->u3.FullRdmpHeader.Bitmap.data();
      TotalNumberOfPages = DmpHdr_->u3.FullRdmpHeader.TotalNumberOfPages;
      break;
    }

    default: {
      return false;
    }
    }

    if (!FirstPageOffset || !Page || !MetadataSize || !Bitmap) {
      return false;
    }

    auto IsPageInBounds = [&](const uint8_t *Ptr) {
      return FileMap_.InBounds(Ptr, Page::Size);
    };

    if (!IsPageInBounds(Page)) {
      return false;
    }

    struct PfnRange {
      uint64_t PageFileNumber;
      uint64_t NumberOfPages;
    };

    // Sanity check
    if (MetadataSize % sizeof(PfnRange)) {
      return false;
    }

    for (uint64_t Offset = 0; Offset < MetadataSize;
         Offset += sizeof(PfnRange)) {

      if (Type == DumpType_t::CompleteMemoryDump) {
        // `CompleteMemoryDump` type seems to be bound by the
        // `TotalNumberOfPages` field, *not* by `MetadataSize`.
        if (CurrentPageCount == TotalNumberOfPages) {
          break;
        }

        if (CurrentPageCount > TotalNumberOfPages) {
          return false;
        }
      }

      const PfnRange &Entry = (PfnRange &)Bitmap[Offset];
      if (!FileMap_.InBounds(&Entry, sizeof(Entry))) {
        return false;
      }

      CurrentPageCount += Entry.NumberOfPages;

      const uint64_t Pfn = Entry.PageFileNumber;
      if (!Pfn) {
        break;
      }

      for (uint64_t PageIdx = 0; PageIdx < Entry.NumberOfPages; PageIdx++) {
        if (!IsPageInBounds(Page)) {
          return false;
        }

        const uint64_t Pa = (Pfn * Page::Size) + (PageIdx * Page::Size);
        Physmem_.try_emplace(Pa, Page);
        Page += Page::Size;
      }
    }

    return true;
  }

  //
  // Parse the DMP_HEADER.
  //

  bool ParseDmpHeader() {

    //
    // The base of the view points on the HEADER64.
    //

    DmpHdr_ = (HEADER64 *)FileMap_.ViewBase();

    //
    // Now let's make sure the structures look right.
    //

    if (!DmpHdr_->LooksGood()) {
      printf("The header looks wrong.\n");
      return false;
    }

    return true;
  }

  //
  // Map a view of the file in memory.
  //

  bool MapFile() { return FileMap_.MapFile(PathFile_.string().c_str()); }
};

struct Version_t {
  static inline const uint16_t Major = KDMPPARSER_VERSION_MAJOR;
  static inline const uint16_t Minor = KDMPPARSER_VERSION_MINOR;
  static inline const uint16_t Patch = KDMPPARSER_VERSION_PATCH;
  static inline const std::string Release = KDMPPARSER_VERSION_RELEASE;
};

} // namespace kdmpparser

```

`KDemu/include/kdmp-parser/platform.h`:

```h
// Axel '0vercl0k' Souchet - April 18 2020
#pragma once

#if defined(__i386__) || defined(_M_IX86)
#define ARCH_X86
#elif defined(__amd64__) || defined(_M_X64)
#define ARCH_X64
#elif defined(__aarch64__) || defined(_M_ARM64)
#define ARCH_ARM64
#else
#error Architecture not supported.
#endif

#if defined(WIN32) || defined(WIN64) || defined(_WIN32) || defined(_WIN64)
#define WINDOWS
#define SYSTEM_PLATFORM "Windows"

#include <windows.h>
#if defined(ARCH_X86)
#define WINDOWS_X86
#elif defined(ARCH_X64)
#define WINDOWS_X64
#elif defined(ARCH_ARM64)
#define WINDOWS_ARM64
#endif

#elif defined(linux) || defined(__linux) || defined(__FreeBSD__) ||            \
    defined(__FreeBSD_kernel__) || defined(__MACH__)
#define LINUX

#if defined(linux) || defined(__linux)
#define SYSTEM_PLATFORM "Linux"

#if defined(ARCH_X86)
#define LINUX_X86
#elif defined(ARCH_X64)
#define LINUX_X64
#elif defined(ARCH_ARM64)
#define LINUX_ARM64
#endif

#elif defined(__APPLE__)

#define SYSTEM_PLATFORM "OSX"
#if defined(ARCH_X86)
#define OSX_X86
#elif defined(ARCH_X64)
#define OSX_X64
#elif defined(ARCH_ARM64)
#define OSX_ARM64
#endif
#else
#error An error occured
#endif

#define EXIT_FAILURE 1
#define EXIT_SUCCESS 0

#else
#error Platform not supported.
#endif

```

`KDemu/include/unicorn/list.h`:

```h
#ifndef UC_LLIST_H
#define UC_LLIST_H

#include "unicorn/platform.h"

typedef void (*delete_fn)(void *data);

struct list_item {
    struct list_item *next;
    void *data;
};

struct list {
    struct list_item *head, *tail;
    delete_fn delete_fn;
};

// create a new list
struct list *list_new(void);

// removed linked list nodes but does not free their content
void list_clear(struct list *list);

// insert a new item at the begin of the list.
void *list_insert(struct list *list, void *data);

// append a new item at the end of the list.
void *list_append(struct list *list, void *data);

// returns true if entry was removed, false otherwise
bool list_remove(struct list *list, void *data);

// returns true if the data exists in the list
bool list_exists(struct list *list, void *data);

#endif

```

`KDemu/include/unicorn/qemu.h`:

```h
/* By Dang Hoang Vu <dang.hvu -at- gmail.com>, 2015 */
/* Modified for Unicorn Engine by Chen Huitao<chenhuitao@hfmrit.com>, 2020 */

#ifndef UC_QEMU_H
#define UC_QEMU_H

struct uc_struct;

#define OPC_BUF_SIZE 640

#include "sysemu/sysemu.h"
#include "sysemu/cpus.h"
#include "exec/cpu-common.h"
#include "exec/memory.h"

#include "qemu/thread.h"
#include "hw/core/cpu.h"

#include "vl.h"

// This struct is originally from qemu/include/exec/ramblock.h
// Temporarily moved here since there is circular inclusion.
struct RAMBlock {
    struct MemoryRegion *mr;
    uint8_t *host;
    ram_addr_t offset;
    ram_addr_t used_length;
    ram_addr_t max_length;
    uint32_t flags;
    /* RCU-enabled, writes protected by the ramlist lock */
    QLIST_ENTRY(RAMBlock) next;
    size_t page_size;
};

typedef struct {
    MemoryRegion *mr;
    void *buffer;
    hwaddr addr;
    hwaddr len;
} BounceBuffer;

// This struct is originally from qemu/include/exec/ramlist.h
typedef struct RAMList {
    bool freed;
    RAMBlock *mru_block;
    RAMBlock *last_block;
    QLIST_HEAD(, RAMBlock) blocks;
} RAMList;

#endif

```

`KDemu/include/unicorn/uc_priv.h`:

```h
/* Unicorn Emulator Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2015 */
/* Modified for Unicorn Engine by Chen Huitao<chenhuitao@hfmrit.com>, 2020 */

#ifndef UC_PRIV_H
#define UC_PRIV_H

#include "unicorn/platform.h"
#include <stdio.h>

#include "qemu.h"
#include "qemu/xxhash.h"
#include "unicorn/unicorn.h"
#include "list.h"

// The max recursive nested uc_emu_start levels
#define UC_MAX_NESTED_LEVEL (64)

// These are masks of supported modes for each cpu/arch.
// They should be updated when changes are made to the uc_mode enum typedef.
#define UC_MODE_ARM_MASK                                                       \
    (UC_MODE_ARM | UC_MODE_THUMB | UC_MODE_LITTLE_ENDIAN | UC_MODE_MCLASS |    \
     UC_MODE_ARM926 | UC_MODE_ARM946 | UC_MODE_ARM1176 | UC_MODE_BIG_ENDIAN |  \
     UC_MODE_ARMBE8)
#define UC_MODE_MIPS_MASK                                                      \
    (UC_MODE_MIPS32 | UC_MODE_MIPS64 | UC_MODE_LITTLE_ENDIAN |                 \
     UC_MODE_BIG_ENDIAN)
#define UC_MODE_X86_MASK                                                       \
    (UC_MODE_16 | UC_MODE_32 | UC_MODE_64 | UC_MODE_LITTLE_ENDIAN)
#define UC_MODE_PPC_MASK (UC_MODE_PPC32 | UC_MODE_PPC64 | UC_MODE_BIG_ENDIAN)
#define UC_MODE_SPARC_MASK                                                     \
    (UC_MODE_SPARC32 | UC_MODE_SPARC64 | UC_MODE_BIG_ENDIAN)
#define UC_MODE_M68K_MASK (UC_MODE_BIG_ENDIAN)
#define UC_MODE_RISCV_MASK                                                     \
    (UC_MODE_RISCV32 | UC_MODE_RISCV64 | UC_MODE_LITTLE_ENDIAN)
#define UC_MODE_S390X_MASK (UC_MODE_BIG_ENDIAN)
#define UC_MODE_TRICORE_MASK (UC_MODE_LITTLE_ENDIAN)

#define ARR_SIZE(a) (sizeof(a) / sizeof(a[0]))

#define READ_QWORD(x) ((uint64_t)x)
#define READ_DWORD(x) (x & 0xffffffff)
#define READ_WORD(x) (x & 0xffff)
#define READ_BYTE_H(x) ((x & 0xffff) >> 8)
#define READ_BYTE_L(x) (x & 0xff)
#define WRITE_DWORD(x, w) (x = (x & ~0xffffffffLL) | (w & 0xffffffff))
#define WRITE_WORD(x, w) (x = (x & ~0xffff) | (w & 0xffff))
#define WRITE_BYTE_H(x, b) (x = (x & ~0xff00) | ((b & 0xff) << 8))
#define WRITE_BYTE_L(x, b) (x = (x & ~0xff) | (b & 0xff))

struct TranslationBlock;

// Place the struct here since we need it in uc.c
typedef struct _mmio_cbs {
    uc_cb_mmio_read_t read;
    void *user_data_read;
    uc_cb_mmio_write_t write;
    void *user_data_write;
    MemoryRegionOps ops;
} mmio_cbs;

typedef uc_err (*query_t)(struct uc_struct *uc, uc_query_type type,
                          size_t *result);

typedef uc_err (*reg_read_t)(void *env, int mode, unsigned int regid,
                             void *value, size_t *size);
typedef uc_err (*reg_write_t)(void *env, int mode, unsigned int regid,
                              const void *value, size_t *size, int *setpc);

typedef struct {
    reg_read_t read;
    reg_write_t write;
} context_reg_rw_t;

typedef void (*reg_reset_t)(struct uc_struct *uc);

typedef bool (*uc_write_mem_t)(AddressSpace *as, hwaddr addr,
                               const uint8_t *buf, hwaddr len);

typedef bool (*uc_read_mem_t)(AddressSpace *as, hwaddr addr, uint8_t *buf,
                              hwaddr len);

typedef MemoryRegion *(*uc_mem_cow_t)(struct uc_struct *uc,
                                      MemoryRegion *current, hwaddr begin,
                                      size_t size);

typedef void (*uc_args_void_t)(void *);

typedef void (*uc_args_uc_t)(struct uc_struct *);
typedef void (*uc_args_int_uc_t)(struct uc_struct *);

typedef void (*uc_args_uc_long_t)(struct uc_struct *, uint32_t);

typedef void (*uc_args_uc_u64_t)(struct uc_struct *, uint64_t addr);

typedef uint64_t (*uc_get_pc_t)(struct uc_struct *);

typedef MemoryRegion *(*uc_args_uc_ram_size_t)(struct uc_struct *, hwaddr begin,
                                               size_t size, uint32_t perms);

typedef MemoryRegion *(*uc_args_uc_ram_size_ptr_t)(struct uc_struct *,
                                                   hwaddr begin, size_t size,
                                                   uint32_t perms, void *ptr);

typedef void (*uc_mem_unmap_t)(struct uc_struct *, MemoryRegion *mr);

typedef MemoryRegion *(*uc_memory_mapping_t)(struct uc_struct *, hwaddr addr);

typedef void (*uc_memory_filter_t)(MemoryRegion *, int32_t);

typedef bool (*uc_flatview_copy_t)(struct uc_struct *, FlatView *, FlatView *,
                                   bool);

typedef void (*uc_readonly_mem_t)(MemoryRegion *mr, bool readonly);

typedef int (*uc_cpus_init)(struct uc_struct *, const char *);

typedef MemoryRegion *(*uc_memory_map_io_t)(struct uc_struct *uc,
                                            ram_addr_t begin, size_t size,
                                            uc_cb_mmio_read_t read_cb,
                                            uc_cb_mmio_write_t write_cb,
                                            void *user_data_read,
                                            void *user_data_write);

// which interrupt should make emulation stop?
typedef bool (*uc_args_int_t)(struct uc_struct *uc, int intno);

// validate if Unicorn supports hooking a given instruction
typedef bool (*uc_insn_hook_validate)(uint32_t insn_enum);

typedef bool (*uc_opcode_hook_validate_t)(uint32_t op, uint32_t flags);

// init target page
typedef void (*uc_target_page_init)(struct uc_struct *);

// soft float init
typedef void (*uc_softfloat_initialize)(void);

// tcg flush softmmu tlb
typedef void (*uc_tcg_flush_tlb)(struct uc_struct *uc);

// Invalidate the TB at given address
typedef void (*uc_invalidate_tb_t)(struct uc_struct *uc, uint64_t start,
                                   size_t len);

// Request generating TB at given address
typedef uc_err (*uc_gen_tb_t)(struct uc_struct *uc, uint64_t pc, uc_tb *out_tb);

// tb flush
typedef uc_tcg_flush_tlb uc_tb_flush_t;

typedef uc_err (*uc_set_tlb_t)(struct uc_struct *uc, int mode);

struct hook {
    int type;       // UC_HOOK_*
    int insn;       // instruction for HOOK_INSN
    int refs;       // reference count to free hook stored in multiple lists
    int op;         // opcode for HOOK_TCG_OPCODE
    int op_flags;   // opcode flags for HOOK_TCG_OPCODE
    bool to_delete; // set to true when the hook is deleted by the user. The
                    // destruction of the hook is delayed.
    uint64_t begin, end; // only trigger if PC or memory access is in this
                         // address (depends on hook type)
    void *callback;      // a uc_cb_* type
    void *user_data;
    GHashTable *hooked_regions; // The regions this hook instrumented on
};

// Add an inline hook to helper_table
typedef void (*uc_add_inline_hook_t)(struct uc_struct *uc, struct hook *hk,
                                     void **args, int args_len);

// Delete a hook from helper_table
typedef void (*uc_del_inline_hook_t)(struct uc_struct *uc, struct hook *hk);

// Return the size of a CPU context
typedef size_t (*uc_context_size_t)(struct uc_struct *uc);

// Generate a CPU context
typedef uc_err (*uc_context_save_t)(struct uc_struct *uc, uc_context *context);

// Restore a CPU context
typedef uc_err (*uc_context_restore_t)(struct uc_struct *uc,
                                       uc_context *context);

// hook list offsets
//
// The lowest 6 bits are used for hook type index while the others
// are used for hook flags.
//
// mirrors the order of uc_hook_type from include/unicorn/unicorn.h
typedef enum uc_hook_idx {
    UC_HOOK_INTR_IDX,
    UC_HOOK_INSN_IDX,
    UC_HOOK_CODE_IDX,
    UC_HOOK_BLOCK_IDX,
    UC_HOOK_MEM_READ_UNMAPPED_IDX,
    UC_HOOK_MEM_WRITE_UNMAPPED_IDX,
    UC_HOOK_MEM_FETCH_UNMAPPED_IDX,
    UC_HOOK_MEM_READ_PROT_IDX,
    UC_HOOK_MEM_WRITE_PROT_IDX,
    UC_HOOK_MEM_FETCH_PROT_IDX,
    UC_HOOK_MEM_READ_IDX,
    UC_HOOK_MEM_WRITE_IDX,
    UC_HOOK_MEM_FETCH_IDX,
    UC_HOOK_MEM_READ_AFTER_IDX,
    UC_HOOK_INSN_INVALID_IDX,
    UC_HOOK_EDGE_GENERATED_IDX,
    UC_HOOK_TCG_OPCODE_IDX,
    UC_HOOK_TLB_FILL_IDX,

    UC_HOOK_MAX,
} uc_hook_idx;

// Copy the essential information from TranslationBlock
#define UC_TB_COPY(uc_tb, tb)                                                  \
    do {                                                                       \
        (uc_tb)->pc = tb->pc;                                                  \
        (uc_tb)->icount = tb->icount;                                          \
        (uc_tb)->size = tb->size;                                              \
    } while (0)

// The lowest 6 bits are used for hook type index.
#define UC_HOOK_IDX_MASK ((1 << 6) - 1)

// hook flags
#define UC_HOOK_FLAG_NO_STOP                                                   \
    (1 << 6) // Don't stop emulation in this uc_tracecode.

// The rest of bits are reserved for hook flags.
#define UC_HOOK_FLAG_MASK (~(UC_HOOK_IDX_MASK))

#define HOOK_FOREACH_VAR_DECLARE struct list_item *cur

// for loop macro to loop over hook lists
#define HOOK_FOREACH(uc, hh, idx)                                              \
    for (cur = (uc)->hook[idx##_IDX].head;                                     \
         cur != NULL && ((hh) = (struct hook *)cur->data); cur = cur->next)

// if statement to check hook bounds
#define HOOK_BOUND_CHECK(hh, addr)                                             \
    ((((addr) >= (hh)->begin && (addr) <= (hh)->end) ||                        \
      (hh)->begin > (hh)->end) &&                                              \
     !((hh)->to_delete))

#define HOOK_EXISTS(uc, idx) ((uc)->hook[idx##_IDX].head != NULL)
#define HOOK_EXISTS_BOUNDED(uc, idx, addr)                                     \
    _hook_exists_bounded((uc)->hook[idx##_IDX].head, addr)

static inline bool _hook_exists_bounded(struct list_item *cur, uint64_t addr)
{
    while (cur != NULL) {
        if (HOOK_BOUND_CHECK((struct hook *)cur->data, addr))
            return true;
        cur = cur->next;
    }
    return false;
}

// relloc increment, KEEP THIS A POWER OF 2!
#define MEM_BLOCK_INCR 32

typedef struct TargetPageBits TargetPageBits;
typedef struct TCGContext TCGContext;

struct uc_struct {
    uc_arch arch;
    uc_mode mode;
    uc_err errnum; // qemu/cpu-exec.c
    AddressSpace address_space_memory;
    AddressSpace address_space_io;
    query_t query;
    reg_read_t reg_read;
    reg_write_t reg_write;
    reg_reset_t reg_reset;

    uc_write_mem_t write_mem;
    uc_read_mem_t read_mem;
    uc_mem_cow_t memory_cow;
    uc_args_void_t release;  // release resource when uc_close()
    uc_args_uc_u64_t set_pc; // set PC for tracecode
    uc_get_pc_t get_pc;
    uc_args_int_t
        stop_interrupt; // check if the interrupt should stop emulation
    uc_memory_map_io_t memory_map_io;

    uc_args_uc_t init_arch, cpu_exec_init_all;
    uc_args_int_uc_t vm_start;
    uc_args_uc_long_t tcg_exec_init;
    uc_args_uc_ram_size_t memory_map;
    uc_args_uc_ram_size_ptr_t memory_map_ptr;
    uc_memory_mapping_t memory_mapping;
    uc_memory_filter_t memory_filter_subregions;
    uc_flatview_copy_t flatview_copy;
    uc_mem_unmap_t memory_unmap;
    uc_mem_unmap_t memory_moveout;
    uc_mem_unmap_t memory_movein;
    uc_readonly_mem_t readonly_mem;
    uc_cpus_init cpus_init;
    uc_target_page_init target_page;
    uc_softfloat_initialize softfloat_initialize;
    uc_tcg_flush_tlb tcg_flush_tlb;
    uc_invalidate_tb_t uc_invalidate_tb;
    uc_gen_tb_t uc_gen_tb;
    uc_tb_flush_t tb_flush;
    uc_add_inline_hook_t add_inline_hook;
    uc_del_inline_hook_t del_inline_hook;

    uc_context_size_t context_size;
    uc_context_save_t context_save;
    uc_context_restore_t context_restore;

    /*  only 1 cpu in unicorn,
        do not need current_cpu to handle current running cpu. */
    CPUState *cpu;

    uc_insn_hook_validate insn_hook_validate;
    uc_opcode_hook_validate_t opcode_hook_invalidate;

    MemoryRegion *system_memory;    // qemu/exec.c
    MemoryRegion *system_io;        // qemu/exec.c
    MemoryRegion io_mem_unassigned; // qemu/exec.c
    RAMList ram_list;               // qemu/exec.c
    /* qemu/exec.c */
    unsigned int alloc_hint;
    /* qemu/exec-vary.c */
    TargetPageBits *init_target_page;
    int target_bits; // User defined page bits by uc_ctl
    int cpu_model;
    BounceBuffer bounce;                // qemu/cpu-exec.c
    volatile sig_atomic_t exit_request; // qemu/cpu-exec.c
    /* qemu/accel/tcg/cpu-exec-common.c */
    /* always be true after call tcg_exec_init(). */
    bool tcg_allowed;
    /* This is a multi-level map on the virtual address space.
       The bottom level has pointers to PageDesc.  */
    void **l1_map; // qemu/accel/tcg/translate-all.c
    size_t l1_map_size;
    /* qemu/accel/tcg/translate-all.c */
    int v_l1_size;
    int v_l1_shift;
    int v_l2_levels;
    /* code generation context */
    TCGContext *tcg_ctx;
    /* memory.c */
    QTAILQ_HEAD(memory_listeners, MemoryListener) memory_listeners;
    QTAILQ_HEAD(, AddressSpace) address_spaces;
    GHashTable *flat_views;
    bool memory_region_update_pending;

    uc_set_tlb_t set_tlb;

    // linked lists containing hooks per type
    struct list hook[UC_HOOK_MAX];
    struct list hooks_to_del;
    int hooks_count[UC_HOOK_MAX];

    // hook to count number of instructions for uc_emu_start()
    uc_hook count_hook;

    size_t emu_counter; // current counter of uc_emu_start()
    size_t emu_count;   // save counter of uc_emu_start()

    int size_recur_mem; // size for mem access when in a recursive call

    bool init_tcg;       // already initialized local TCGv variables?
    bool stop_request;   // request to immediately stop emulation - for
                         // uc_emu_stop()
    bool quit_request;   // request to quit the current TB, but continue to
                         // emulate - for uc_mem_protect()
    bool emulation_done; // emulation is done by uc_emu_start()
    bool timed_out;      // emulation timed out, that can retrieve via
                         // uc_query(UC_QUERY_TIMEOUT)
    QemuThread timer;    // timer for emulation timeout
    uint64_t timeout;    // timeout for uc_emu_start()

    uint64_t invalid_addr; // invalid address to be accessed
    int invalid_error;     // invalid memory code: 1 = READ, 2 = WRITE, 3 = CODE

    int use_exits;
    uint64_t exits[UC_MAX_NESTED_LEVEL]; // When multiple exits is not enabled.
    GTree *ctl_exits; // addresses where emulation stops (@until param of
                      // uc_emu_start()) Also see UC_CTL_USE_EXITS for more
                      // details.

    int thumb; // thumb mode for ARM
    MemoryRegion **mapped_blocks;
    uint32_t mapped_block_count;
    uint32_t mapped_block_cache_index;
    void *qemu_thread_data; // to support cross compile to Windows
                            // (qemu-thread-win32.c)
    uint32_t target_page_size;
    uint32_t target_page_align;
    uint64_t qemu_host_page_size;
    uint64_t qemu_real_host_page_size;
    int qemu_icache_linesize;
    /* ARCH_REGS_STORAGE_SIZE */
    uc_context_content context_content;
    int cpu_context_size;
    uint64_t next_pc; // save next PC for some special cases
    bool hook_insert; // insert new hook at begin of the hook list (append by
                      // default)
    bool first_tb; // is this the first Translation-Block ever generated since
                   // uc_emu_start()?
    bool no_exit_request; // Disable check_exit_request temporarily. A
                          // workaround to treat the IT block as a whole block.
    bool init_done;       // Whether the initialization is done.

    sigjmp_buf jmp_bufs[UC_MAX_NESTED_LEVEL]; // To support nested uc_emu_start
    int nested_level;                         // Current nested_level

    struct TranslationBlock *last_tb; // The real last tb we executed.

    FlatView *empty_view; // Static function variable moved from flatviews_init

    uint32_t tcg_buffer_size; // The buffer size we are going to use
#ifdef WIN32
    PVOID seh_handle;
    void *seh_closure;
#endif
    GArray *unmapped_regions;
    int32_t snapshot_level;
    uint64_t nested; // the nested level of all exposed API
    bool thread_executable_entry;
    bool current_executable;
    bool skip_sync_pc_on_exit;
};

// Metadata stub for the variable-size cpu context used with uc_context_*()
struct uc_context {
    size_t context_size;  // size of the real internal context structure
    uc_mode mode;         // the mode of this context
    uc_arch arch;         // the arch of this context
    int snapshot_level;   // the memory snapshot level to restore
    bool ramblock_freed;  // wheter there was a some ramblock freed
    RAMBlock *last_block; // The last element of the ramblock list
    FlatView *fv;         // The current flatview of the memory
    char data[0];         // context
};

// We have to support 32bit system so we can't hold uint64_t on void*
static inline void uc_add_exit(uc_engine *uc, uint64_t addr)
{
    uint64_t *new_exit = g_malloc(sizeof(uint64_t));
    *new_exit = addr;
    g_tree_insert(uc->ctl_exits, (gpointer)new_exit, (gpointer)1);
}

// This function has to exist since we would like to accept uint32_t or
// it's complex to achieve so.
static inline int uc_addr_is_exit(uc_engine *uc, uint64_t addr)
{
    if (uc->use_exits) {
        return g_tree_lookup(uc->ctl_exits, (gpointer)(&addr)) == (gpointer)1;
    } else {
        return uc->exits[uc->nested_level - 1] == addr;
    }
}

typedef struct HookedRegion {
    uint64_t start;
    uint64_t length;
} HookedRegion;

// hooked_regions related functions
static inline guint hooked_regions_hash(const void *p)
{
    HookedRegion *region = (HookedRegion *)p;

    return qemu_xxhash4(region->start, region->length);
}

static inline gboolean hooked_regions_equal(const void *lhs, const void *rhs)
{
    HookedRegion *l = (HookedRegion *)lhs;
    HookedRegion *r = (HookedRegion *)rhs;

    return l->start == r->start && l->length == r->length;
}

static inline void hooked_regions_add(struct hook *h, uint64_t start,
                                      uint64_t length)
{
    HookedRegion tmp;
    tmp.start = start;
    tmp.length = length;

    if (!g_hash_table_lookup(h->hooked_regions, (void *)&tmp)) {
        HookedRegion *r = malloc(sizeof(HookedRegion));
        r->start = start;
        r->length = length;
        g_hash_table_insert(h->hooked_regions, (void *)r, (void *)1);
    }
}

static inline void hooked_regions_check_single(struct list_item *cur,
                                               uint64_t start, uint64_t length)
{
    while (cur != NULL) {
        if (HOOK_BOUND_CHECK((struct hook *)cur->data, start)) {
            hooked_regions_add((struct hook *)cur->data, start, length);
        }
        cur = cur->next;
    }
}

static inline void hooked_regions_check(uc_engine *uc, uint64_t start,
                                        uint64_t length)
{
    // Only UC_HOOK_BLOCK and UC_HOOK_CODE might be wrongle cached!
    hooked_regions_check_single(uc->hook[UC_HOOK_CODE_IDX].head, start, length);
    hooked_regions_check_single(uc->hook[UC_HOOK_BLOCK_IDX].head, start,
                                length);
}

/*
 break translation loop:
 This is done in two cases:
 1. the user wants to stop the emulation.
 2. the user has set it IP. This requires to restart the internal
 CPU emulation and rebuild some translation blocks
*/
static inline uc_err break_translation_loop(uc_engine *uc)
{
    if (uc->emulation_done) {
        return UC_ERR_OK;
    }

    // TODO: make this atomic somehow?
    if (uc->cpu) {
        // exit the current TB
        cpu_exit(uc->cpu);
    }

    return UC_ERR_OK;
}

static inline void revert_uc_emu_stop(uc_engine *uc)
{
    uc->stop_request = 0;
    uc->cpu->exit_request = 0;
    uc->cpu->tcg_exit_req = 0;
    uc->cpu->icount_decr_ptr->u16.high = 0;
}

#ifdef UNICORN_TRACER
#define UC_TRACE_START(loc) trace_start(get_tracer(), loc)
#define UC_TRACE_END(loc, fmt, ...)                                            \
    trace_end(get_tracer(), loc, fmt, __VA_ARGS__)

typedef enum trace_loc {
    UC_TRACE_TB_EXEC = 0,
    UC_TRACE_TB_TRANS,
    UC_TRACER_MAX
} trace_loc;

typedef struct uc_tracer {
    int64_t starts[UC_TRACER_MAX];
} uc_tracer;

uc_tracer *get_tracer();

void trace_start(uc_tracer *tracer, trace_loc loc);

void trace_end(uc_tracer *tracer, trace_loc loc, const char *fmt, ...);

#else
#define UC_TRACE_START(loc)
#define UC_TRACE_END(loc, fmt, ...)
#endif

#endif
/* vim: set ts=4 noet:  */

```

`KDemu/include/unicorn/unicorn/arm.h`:

```h
/* Unicorn Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2015-2017 */
/* This file is released under LGPL2.
   See COPYING.LGPL2 in root directory for more details
*/

#ifndef UNICORN_ARM_H
#define UNICORN_ARM_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _MSC_VER
#pragma warning(disable : 4201)
#endif

//> ARM CPU
typedef enum uc_cpu_arm {
    UC_CPU_ARM_926 = 0,
    UC_CPU_ARM_946,
    UC_CPU_ARM_1026,
    UC_CPU_ARM_1136_R2,
    UC_CPU_ARM_1136,
    UC_CPU_ARM_1176,
    UC_CPU_ARM_11MPCORE,
    UC_CPU_ARM_CORTEX_M0,
    UC_CPU_ARM_CORTEX_M3,
    UC_CPU_ARM_CORTEX_M4,
    UC_CPU_ARM_CORTEX_M7,
    UC_CPU_ARM_CORTEX_M33,
    UC_CPU_ARM_CORTEX_R5,
    UC_CPU_ARM_CORTEX_R5F,
    UC_CPU_ARM_CORTEX_A7,
    UC_CPU_ARM_CORTEX_A8,
    UC_CPU_ARM_CORTEX_A9,
    UC_CPU_ARM_CORTEX_A15,
    UC_CPU_ARM_TI925T,
    UC_CPU_ARM_SA1100,
    UC_CPU_ARM_SA1110,
    UC_CPU_ARM_PXA250,
    UC_CPU_ARM_PXA255,
    UC_CPU_ARM_PXA260,
    UC_CPU_ARM_PXA261,
    UC_CPU_ARM_PXA262,
    UC_CPU_ARM_PXA270,
    UC_CPU_ARM_PXA270A0,
    UC_CPU_ARM_PXA270A1,
    UC_CPU_ARM_PXA270B0,
    UC_CPU_ARM_PXA270B1,
    UC_CPU_ARM_PXA270C0,
    UC_CPU_ARM_PXA270C5,
    UC_CPU_ARM_MAX,

    UC_CPU_ARM_ENDING
} uc_cpu_arm;

// ARM coprocessor registers, use this with UC_ARM_REG_CP_REG to
// in call to uc_reg_write/read() to access the registers.
typedef struct uc_arm_cp_reg {
    uint32_t cp;   // The coprocessor identifier
    uint32_t is64; // Is it a 64 bit control register
    uint32_t sec;  // Security state
    uint32_t crn;  // Coprocessor register number
    uint32_t crm;  // Coprocessor register number
    uint32_t opc1; // Opcode1
    uint32_t opc2; // Opcode2
    uint64_t val;  // The value to read/write
} uc_arm_cp_reg;

//> ARM registers
typedef enum uc_arm_reg {
    UC_ARM_REG_INVALID = 0,
    UC_ARM_REG_APSR,
    UC_ARM_REG_APSR_NZCV,
    UC_ARM_REG_CPSR,
    UC_ARM_REG_FPEXC,
    UC_ARM_REG_FPINST,
    UC_ARM_REG_FPSCR,
    UC_ARM_REG_FPSCR_NZCV,
    UC_ARM_REG_FPSID,
    UC_ARM_REG_ITSTATE,
    UC_ARM_REG_LR,
    UC_ARM_REG_PC,
    UC_ARM_REG_SP,
    UC_ARM_REG_SPSR,
    UC_ARM_REG_D0,
    UC_ARM_REG_D1,
    UC_ARM_REG_D2,
    UC_ARM_REG_D3,
    UC_ARM_REG_D4,
    UC_ARM_REG_D5,
    UC_ARM_REG_D6,
    UC_ARM_REG_D7,
    UC_ARM_REG_D8,
    UC_ARM_REG_D9,
    UC_ARM_REG_D10,
    UC_ARM_REG_D11,
    UC_ARM_REG_D12,
    UC_ARM_REG_D13,
    UC_ARM_REG_D14,
    UC_ARM_REG_D15,
    UC_ARM_REG_D16,
    UC_ARM_REG_D17,
    UC_ARM_REG_D18,
    UC_ARM_REG_D19,
    UC_ARM_REG_D20,
    UC_ARM_REG_D21,
    UC_ARM_REG_D22,
    UC_ARM_REG_D23,
    UC_ARM_REG_D24,
    UC_ARM_REG_D25,
    UC_ARM_REG_D26,
    UC_ARM_REG_D27,
    UC_ARM_REG_D28,
    UC_ARM_REG_D29,
    UC_ARM_REG_D30,
    UC_ARM_REG_D31,
    UC_ARM_REG_FPINST2,
    UC_ARM_REG_MVFR0,
    UC_ARM_REG_MVFR1,
    UC_ARM_REG_MVFR2,
    UC_ARM_REG_Q0,
    UC_ARM_REG_Q1,
    UC_ARM_REG_Q2,
    UC_ARM_REG_Q3,
    UC_ARM_REG_Q4,
    UC_ARM_REG_Q5,
    UC_ARM_REG_Q6,
    UC_ARM_REG_Q7,
    UC_ARM_REG_Q8,
    UC_ARM_REG_Q9,
    UC_ARM_REG_Q10,
    UC_ARM_REG_Q11,
    UC_ARM_REG_Q12,
    UC_ARM_REG_Q13,
    UC_ARM_REG_Q14,
    UC_ARM_REG_Q15,
    UC_ARM_REG_R0,
    UC_ARM_REG_R1,
    UC_ARM_REG_R2,
    UC_ARM_REG_R3,
    UC_ARM_REG_R4,
    UC_ARM_REG_R5,
    UC_ARM_REG_R6,
    UC_ARM_REG_R7,
    UC_ARM_REG_R8,
    UC_ARM_REG_R9,
    UC_ARM_REG_R10,
    UC_ARM_REG_R11,
    UC_ARM_REG_R12,
    UC_ARM_REG_S0,
    UC_ARM_REG_S1,
    UC_ARM_REG_S2,
    UC_ARM_REG_S3,
    UC_ARM_REG_S4,
    UC_ARM_REG_S5,
    UC_ARM_REG_S6,
    UC_ARM_REG_S7,
    UC_ARM_REG_S8,
    UC_ARM_REG_S9,
    UC_ARM_REG_S10,
    UC_ARM_REG_S11,
    UC_ARM_REG_S12,
    UC_ARM_REG_S13,
    UC_ARM_REG_S14,
    UC_ARM_REG_S15,
    UC_ARM_REG_S16,
    UC_ARM_REG_S17,
    UC_ARM_REG_S18,
    UC_ARM_REG_S19,
    UC_ARM_REG_S20,
    UC_ARM_REG_S21,
    UC_ARM_REG_S22,
    UC_ARM_REG_S23,
    UC_ARM_REG_S24,
    UC_ARM_REG_S25,
    UC_ARM_REG_S26,
    UC_ARM_REG_S27,
    UC_ARM_REG_S28,
    UC_ARM_REG_S29,
    UC_ARM_REG_S30,
    UC_ARM_REG_S31,

    UC_ARM_REG_C1_C0_2,  // Depreciated, use UC_ARM_REG_CP_REG instead
    UC_ARM_REG_C13_C0_2, // Depreciated, use UC_ARM_REG_CP_REG instead
    UC_ARM_REG_C13_C0_3, // Depreciated, use UC_ARM_REG_CP_REG instead

    UC_ARM_REG_IPSR,
    UC_ARM_REG_MSP,
    UC_ARM_REG_PSP,
    UC_ARM_REG_CONTROL,
    UC_ARM_REG_IAPSR,
    UC_ARM_REG_EAPSR,
    UC_ARM_REG_XPSR,
    UC_ARM_REG_EPSR,
    UC_ARM_REG_IEPSR,
    UC_ARM_REG_PRIMASK,
    UC_ARM_REG_BASEPRI,
    UC_ARM_REG_BASEPRI_MAX,
    UC_ARM_REG_FAULTMASK,
    UC_ARM_REG_APSR_NZCVQ,
    UC_ARM_REG_APSR_G,
    UC_ARM_REG_APSR_NZCVQG,
    UC_ARM_REG_IAPSR_NZCVQ,
    UC_ARM_REG_IAPSR_G,
    UC_ARM_REG_IAPSR_NZCVQG,
    UC_ARM_REG_EAPSR_NZCVQ,
    UC_ARM_REG_EAPSR_G,
    UC_ARM_REG_EAPSR_NZCVQG,
    UC_ARM_REG_XPSR_NZCVQ,
    UC_ARM_REG_XPSR_G,
    UC_ARM_REG_XPSR_NZCVQG,
    UC_ARM_REG_CP_REG,
	// A pseudo-register for fetching the exception syndrome
	// from the CPU state. This is not a real register.
    UC_ARM_REG_ESR,
    UC_ARM_REG_ENDING, // <-- mark the end of the list or registers

    //> alias registers
    UC_ARM_REG_R13 = UC_ARM_REG_SP,
    UC_ARM_REG_R14 = UC_ARM_REG_LR,
    UC_ARM_REG_R15 = UC_ARM_REG_PC,

    UC_ARM_REG_SB = UC_ARM_REG_R9,
    UC_ARM_REG_SL = UC_ARM_REG_R10,
    UC_ARM_REG_FP = UC_ARM_REG_R11,
    UC_ARM_REG_IP = UC_ARM_REG_R12,
} uc_arm_reg;

#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/include/unicorn/unicorn/arm64.h`:

```h
/* Unicorn Emulator Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2015-2017 */
/* This file is released under LGPL2.
   See COPYING.LGPL2 in root directory for more details
*/

#ifndef UNICORN_ARM64_H
#define UNICORN_ARM64_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _MSC_VER
#pragma warning(disable : 4201)
#endif

//> ARM64 CPU
typedef enum uc_cpu_arm64 {
    UC_CPU_ARM64_A57 = 0,
    UC_CPU_ARM64_A53,
    UC_CPU_ARM64_A72,
    UC_CPU_ARM64_MAX,

    UC_CPU_ARM64_ENDING
} uc_cpu_arm64;

// ARM64 coprocessor registers, use this with UC_ARM64_REG_CP_REG to
// in call to uc_reg_write/read() to access the registers.
typedef struct uc_arm64_cp_reg {
    uint32_t crn; // Coprocessor register number
    uint32_t crm; // Coprocessor register number
    uint32_t op0; // Opcode0
    uint32_t op1; // Opcode1
    uint32_t op2; // Opcode2
    uint64_t val; // The value to read/write
} uc_arm64_cp_reg;

//> ARM64 registers
typedef enum uc_arm64_reg {
    UC_ARM64_REG_INVALID = 0,

    UC_ARM64_REG_X29,
    UC_ARM64_REG_X30,
    UC_ARM64_REG_NZCV,
    UC_ARM64_REG_SP,
    UC_ARM64_REG_WSP,
    UC_ARM64_REG_WZR,
    UC_ARM64_REG_XZR,
    UC_ARM64_REG_B0,
    UC_ARM64_REG_B1,
    UC_ARM64_REG_B2,
    UC_ARM64_REG_B3,
    UC_ARM64_REG_B4,
    UC_ARM64_REG_B5,
    UC_ARM64_REG_B6,
    UC_ARM64_REG_B7,
    UC_ARM64_REG_B8,
    UC_ARM64_REG_B9,
    UC_ARM64_REG_B10,
    UC_ARM64_REG_B11,
    UC_ARM64_REG_B12,
    UC_ARM64_REG_B13,
    UC_ARM64_REG_B14,
    UC_ARM64_REG_B15,
    UC_ARM64_REG_B16,
    UC_ARM64_REG_B17,
    UC_ARM64_REG_B18,
    UC_ARM64_REG_B19,
    UC_ARM64_REG_B20,
    UC_ARM64_REG_B21,
    UC_ARM64_REG_B22,
    UC_ARM64_REG_B23,
    UC_ARM64_REG_B24,
    UC_ARM64_REG_B25,
    UC_ARM64_REG_B26,
    UC_ARM64_REG_B27,
    UC_ARM64_REG_B28,
    UC_ARM64_REG_B29,
    UC_ARM64_REG_B30,
    UC_ARM64_REG_B31,
    UC_ARM64_REG_D0,
    UC_ARM64_REG_D1,
    UC_ARM64_REG_D2,
    UC_ARM64_REG_D3,
    UC_ARM64_REG_D4,
    UC_ARM64_REG_D5,
    UC_ARM64_REG_D6,
    UC_ARM64_REG_D7,
    UC_ARM64_REG_D8,
    UC_ARM64_REG_D9,
    UC_ARM64_REG_D10,
    UC_ARM64_REG_D11,
    UC_ARM64_REG_D12,
    UC_ARM64_REG_D13,
    UC_ARM64_REG_D14,
    UC_ARM64_REG_D15,
    UC_ARM64_REG_D16,
    UC_ARM64_REG_D17,
    UC_ARM64_REG_D18,
    UC_ARM64_REG_D19,
    UC_ARM64_REG_D20,
    UC_ARM64_REG_D21,
    UC_ARM64_REG_D22,
    UC_ARM64_REG_D23,
    UC_ARM64_REG_D24,
    UC_ARM64_REG_D25,
    UC_ARM64_REG_D26,
    UC_ARM64_REG_D27,
    UC_ARM64_REG_D28,
    UC_ARM64_REG_D29,
    UC_ARM64_REG_D30,
    UC_ARM64_REG_D31,
    UC_ARM64_REG_H0,
    UC_ARM64_REG_H1,
    UC_ARM64_REG_H2,
    UC_ARM64_REG_H3,
    UC_ARM64_REG_H4,
    UC_ARM64_REG_H5,
    UC_ARM64_REG_H6,
    UC_ARM64_REG_H7,
    UC_ARM64_REG_H8,
    UC_ARM64_REG_H9,
    UC_ARM64_REG_H10,
    UC_ARM64_REG_H11,
    UC_ARM64_REG_H12,
    UC_ARM64_REG_H13,
    UC_ARM64_REG_H14,
    UC_ARM64_REG_H15,
    UC_ARM64_REG_H16,
    UC_ARM64_REG_H17,
    UC_ARM64_REG_H18,
    UC_ARM64_REG_H19,
    UC_ARM64_REG_H20,
    UC_ARM64_REG_H21,
    UC_ARM64_REG_H22,
    UC_ARM64_REG_H23,
    UC_ARM64_REG_H24,
    UC_ARM64_REG_H25,
    UC_ARM64_REG_H26,
    UC_ARM64_REG_H27,
    UC_ARM64_REG_H28,
    UC_ARM64_REG_H29,
    UC_ARM64_REG_H30,
    UC_ARM64_REG_H31,
    UC_ARM64_REG_Q0,
    UC_ARM64_REG_Q1,
    UC_ARM64_REG_Q2,
    UC_ARM64_REG_Q3,
    UC_ARM64_REG_Q4,
    UC_ARM64_REG_Q5,
    UC_ARM64_REG_Q6,
    UC_ARM64_REG_Q7,
    UC_ARM64_REG_Q8,
    UC_ARM64_REG_Q9,
    UC_ARM64_REG_Q10,
    UC_ARM64_REG_Q11,
    UC_ARM64_REG_Q12,
    UC_ARM64_REG_Q13,
    UC_ARM64_REG_Q14,
    UC_ARM64_REG_Q15,
    UC_ARM64_REG_Q16,
    UC_ARM64_REG_Q17,
    UC_ARM64_REG_Q18,
    UC_ARM64_REG_Q19,
    UC_ARM64_REG_Q20,
    UC_ARM64_REG_Q21,
    UC_ARM64_REG_Q22,
    UC_ARM64_REG_Q23,
    UC_ARM64_REG_Q24,
    UC_ARM64_REG_Q25,
    UC_ARM64_REG_Q26,
    UC_ARM64_REG_Q27,
    UC_ARM64_REG_Q28,
    UC_ARM64_REG_Q29,
    UC_ARM64_REG_Q30,
    UC_ARM64_REG_Q31,
    UC_ARM64_REG_S0,
    UC_ARM64_REG_S1,
    UC_ARM64_REG_S2,
    UC_ARM64_REG_S3,
    UC_ARM64_REG_S4,
    UC_ARM64_REG_S5,
    UC_ARM64_REG_S6,
    UC_ARM64_REG_S7,
    UC_ARM64_REG_S8,
    UC_ARM64_REG_S9,
    UC_ARM64_REG_S10,
    UC_ARM64_REG_S11,
    UC_ARM64_REG_S12,
    UC_ARM64_REG_S13,
    UC_ARM64_REG_S14,
    UC_ARM64_REG_S15,
    UC_ARM64_REG_S16,
    UC_ARM64_REG_S17,
    UC_ARM64_REG_S18,
    UC_ARM64_REG_S19,
    UC_ARM64_REG_S20,
    UC_ARM64_REG_S21,
    UC_ARM64_REG_S22,
    UC_ARM64_REG_S23,
    UC_ARM64_REG_S24,
    UC_ARM64_REG_S25,
    UC_ARM64_REG_S26,
    UC_ARM64_REG_S27,
    UC_ARM64_REG_S28,
    UC_ARM64_REG_S29,
    UC_ARM64_REG_S30,
    UC_ARM64_REG_S31,
    UC_ARM64_REG_W0,
    UC_ARM64_REG_W1,
    UC_ARM64_REG_W2,
    UC_ARM64_REG_W3,
    UC_ARM64_REG_W4,
    UC_ARM64_REG_W5,
    UC_ARM64_REG_W6,
    UC_ARM64_REG_W7,
    UC_ARM64_REG_W8,
    UC_ARM64_REG_W9,
    UC_ARM64_REG_W10,
    UC_ARM64_REG_W11,
    UC_ARM64_REG_W12,
    UC_ARM64_REG_W13,
    UC_ARM64_REG_W14,
    UC_ARM64_REG_W15,
    UC_ARM64_REG_W16,
    UC_ARM64_REG_W17,
    UC_ARM64_REG_W18,
    UC_ARM64_REG_W19,
    UC_ARM64_REG_W20,
    UC_ARM64_REG_W21,
    UC_ARM64_REG_W22,
    UC_ARM64_REG_W23,
    UC_ARM64_REG_W24,
    UC_ARM64_REG_W25,
    UC_ARM64_REG_W26,
    UC_ARM64_REG_W27,
    UC_ARM64_REG_W28,
    UC_ARM64_REG_W29,
    UC_ARM64_REG_W30,
    UC_ARM64_REG_X0,
    UC_ARM64_REG_X1,
    UC_ARM64_REG_X2,
    UC_ARM64_REG_X3,
    UC_ARM64_REG_X4,
    UC_ARM64_REG_X5,
    UC_ARM64_REG_X6,
    UC_ARM64_REG_X7,
    UC_ARM64_REG_X8,
    UC_ARM64_REG_X9,
    UC_ARM64_REG_X10,
    UC_ARM64_REG_X11,
    UC_ARM64_REG_X12,
    UC_ARM64_REG_X13,
    UC_ARM64_REG_X14,
    UC_ARM64_REG_X15,
    UC_ARM64_REG_X16,
    UC_ARM64_REG_X17,
    UC_ARM64_REG_X18,
    UC_ARM64_REG_X19,
    UC_ARM64_REG_X20,
    UC_ARM64_REG_X21,
    UC_ARM64_REG_X22,
    UC_ARM64_REG_X23,
    UC_ARM64_REG_X24,
    UC_ARM64_REG_X25,
    UC_ARM64_REG_X26,
    UC_ARM64_REG_X27,
    UC_ARM64_REG_X28,

    UC_ARM64_REG_V0,
    UC_ARM64_REG_V1,
    UC_ARM64_REG_V2,
    UC_ARM64_REG_V3,
    UC_ARM64_REG_V4,
    UC_ARM64_REG_V5,
    UC_ARM64_REG_V6,
    UC_ARM64_REG_V7,
    UC_ARM64_REG_V8,
    UC_ARM64_REG_V9,
    UC_ARM64_REG_V10,
    UC_ARM64_REG_V11,
    UC_ARM64_REG_V12,
    UC_ARM64_REG_V13,
    UC_ARM64_REG_V14,
    UC_ARM64_REG_V15,
    UC_ARM64_REG_V16,
    UC_ARM64_REG_V17,
    UC_ARM64_REG_V18,
    UC_ARM64_REG_V19,
    UC_ARM64_REG_V20,
    UC_ARM64_REG_V21,
    UC_ARM64_REG_V22,
    UC_ARM64_REG_V23,
    UC_ARM64_REG_V24,
    UC_ARM64_REG_V25,
    UC_ARM64_REG_V26,
    UC_ARM64_REG_V27,
    UC_ARM64_REG_V28,
    UC_ARM64_REG_V29,
    UC_ARM64_REG_V30,
    UC_ARM64_REG_V31,

    //> pseudo registers
    UC_ARM64_REG_PC, // program counter register

    UC_ARM64_REG_CPACR_EL1,

    //> thread registers, depreciated, use UC_ARM64_REG_CP_REG instead
    UC_ARM64_REG_TPIDR_EL0,
    UC_ARM64_REG_TPIDRRO_EL0,
    UC_ARM64_REG_TPIDR_EL1,

    UC_ARM64_REG_PSTATE,

    //> exception link registers, depreciated, use UC_ARM64_REG_CP_REG instead
    UC_ARM64_REG_ELR_EL0,
    UC_ARM64_REG_ELR_EL1,
    UC_ARM64_REG_ELR_EL2,
    UC_ARM64_REG_ELR_EL3,

    //> stack pointers registers, depreciated, use UC_ARM64_REG_CP_REG instead
    UC_ARM64_REG_SP_EL0,
    UC_ARM64_REG_SP_EL1,
    UC_ARM64_REG_SP_EL2,
    UC_ARM64_REG_SP_EL3,

    //> other CP15 registers, depreciated, use UC_ARM64_REG_CP_REG instead
    UC_ARM64_REG_TTBR0_EL1,
    UC_ARM64_REG_TTBR1_EL1,

    UC_ARM64_REG_ESR_EL0,
    UC_ARM64_REG_ESR_EL1,
    UC_ARM64_REG_ESR_EL2,
    UC_ARM64_REG_ESR_EL3,

    UC_ARM64_REG_FAR_EL0,
    UC_ARM64_REG_FAR_EL1,
    UC_ARM64_REG_FAR_EL2,
    UC_ARM64_REG_FAR_EL3,

    UC_ARM64_REG_PAR_EL1,

    UC_ARM64_REG_MAIR_EL1,

    UC_ARM64_REG_VBAR_EL0,
    UC_ARM64_REG_VBAR_EL1,
    UC_ARM64_REG_VBAR_EL2,
    UC_ARM64_REG_VBAR_EL3,

    UC_ARM64_REG_CP_REG,

    //> floating point control and status registers
    UC_ARM64_REG_FPCR,
    UC_ARM64_REG_FPSR,

    UC_ARM64_REG_ENDING, // <-- mark the end of the list of registers

    //> alias registers

    UC_ARM64_REG_IP0 = UC_ARM64_REG_X16,
    UC_ARM64_REG_IP1 = UC_ARM64_REG_X17,
    UC_ARM64_REG_FP = UC_ARM64_REG_X29,
    UC_ARM64_REG_LR = UC_ARM64_REG_X30,
} uc_arm64_reg;

// Callback function for tracing MRS/MSR/SYS/SYSL. If this callback returns
// true, the read/write to system registers would be skipped (even though it may
// cause exceptions!). Note one callback per instruction is allowed.
// @reg: The source/destination register.
// @cp_reg: The source/destincation system register.
// @user_data: The user data.
typedef uint32_t (*uc_cb_insn_sys_t)(uc_engine *uc, uc_arm64_reg reg,
                                     const uc_arm64_cp_reg *cp_reg,
                                     void *user_data);

//> ARM64 instructions
typedef enum uc_arm64_insn {
    UC_ARM64_INS_INVALID = 0,

    UC_ARM64_INS_MRS,
    UC_ARM64_INS_MSR,
    UC_ARM64_INS_SYS,
    UC_ARM64_INS_SYSL,

    UC_ARM64_INS_ENDING
} uc_arm64_insn;

#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/include/unicorn/unicorn/m68k.h`:

```h
/* Unicorn Emulator Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2014-2017 */
/* This file is released under LGPL2.
   See COPYING.LGPL2 in root directory for more details
*/

#ifndef UNICORN_M68K_H
#define UNICORN_M68K_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _MSC_VER
#pragma warning(disable : 4201)
#endif

//> M68K CPU
typedef enum uc_cpu_m68k {
    UC_CPU_M68K_M5206 = 0,
    UC_CPU_M68K_M68000,
    UC_CPU_M68K_M68020,
    UC_CPU_M68K_M68030,
    UC_CPU_M68K_M68040,
    UC_CPU_M68K_M68060,
    UC_CPU_M68K_M5208,
    UC_CPU_M68K_CFV4E,
    UC_CPU_M68K_ANY,

    UC_CPU_M68K_ENDING
} uc_cpu_m68k;

//> M68K registers
typedef enum uc_m68k_reg {
    UC_M68K_REG_INVALID = 0,

    UC_M68K_REG_A0,
    UC_M68K_REG_A1,
    UC_M68K_REG_A2,
    UC_M68K_REG_A3,
    UC_M68K_REG_A4,
    UC_M68K_REG_A5,
    UC_M68K_REG_A6,
    UC_M68K_REG_A7,

    UC_M68K_REG_D0,
    UC_M68K_REG_D1,
    UC_M68K_REG_D2,
    UC_M68K_REG_D3,
    UC_M68K_REG_D4,
    UC_M68K_REG_D5,
    UC_M68K_REG_D6,
    UC_M68K_REG_D7,

    UC_M68K_REG_SR,
    UC_M68K_REG_PC,

    UC_M68K_REG_CR_SFC,
    UC_M68K_REG_CR_DFC,
    UC_M68K_REG_CR_VBR,
    UC_M68K_REG_CR_CACR,
    UC_M68K_REG_CR_TC,
    UC_M68K_REG_CR_MMUSR,
    UC_M68K_REG_CR_SRP,
    UC_M68K_REG_CR_USP,
    UC_M68K_REG_CR_MSP,
    UC_M68K_REG_CR_ISP,
    UC_M68K_REG_CR_URP,
    UC_M68K_REG_CR_ITT0,
    UC_M68K_REG_CR_ITT1,
    UC_M68K_REG_CR_DTT0,
    UC_M68K_REG_CR_DTT1,

    UC_M68K_REG_ENDING, // <-- mark the end of the list of registers
} uc_m68k_reg;

#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/include/unicorn/unicorn/mips.h`:

```h
/* Unicorn Emulator Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2015-2017 */
/* This file is released under LGPL2.
   See COPYING.LGPL2 in root directory for more details
*/

#ifndef UNICORN_MIPS_H
#define UNICORN_MIPS_H

#ifdef __cplusplus
extern "C" {
#endif

// GCC MIPS toolchain has a default macro called "mips" which breaks
// compilation
#undef mips

#ifdef _MSC_VER
#pragma warning(disable : 4201)
#endif

//> MIPS32 CPUS
typedef enum uc_cpu_mips32 {
    UC_CPU_MIPS32_4KC = 0,
    UC_CPU_MIPS32_4KM,
    UC_CPU_MIPS32_4KECR1,
    UC_CPU_MIPS32_4KEMR1,
    UC_CPU_MIPS32_4KEC,
    UC_CPU_MIPS32_4KEM,
    UC_CPU_MIPS32_24KC,
    UC_CPU_MIPS32_24KEC,
    UC_CPU_MIPS32_24KF,
    UC_CPU_MIPS32_34KF,
    UC_CPU_MIPS32_74KF,
    UC_CPU_MIPS32_M14K,
    UC_CPU_MIPS32_M14KC,
    UC_CPU_MIPS32_P5600,
    UC_CPU_MIPS32_MIPS32R6_GENERIC,
    UC_CPU_MIPS32_I7200,

    UC_CPU_MIPS32_ENDING
} uc_cpu_mips32;

//> MIPS64 CPUS
typedef enum uc_cpu_mips64 {
    UC_CPU_MIPS64_R4000 = 0,
    UC_CPU_MIPS64_VR5432,
    UC_CPU_MIPS64_5KC,
    UC_CPU_MIPS64_5KF,
    UC_CPU_MIPS64_20KC,
    UC_CPU_MIPS64_MIPS64R2_GENERIC,
    UC_CPU_MIPS64_5KEC,
    UC_CPU_MIPS64_5KEF,
    UC_CPU_MIPS64_I6400,
    UC_CPU_MIPS64_I6500,
    UC_CPU_MIPS64_LOONGSON_2E,
    UC_CPU_MIPS64_LOONGSON_2F,
    UC_CPU_MIPS64_MIPS64DSPR2,

    UC_CPU_MIPS64_ENDING
} uc_cpu_mips64;

//> MIPS registers
typedef enum uc_mips_reg {
    UC_MIPS_REG_INVALID = 0,
    //> General purpose registers
    UC_MIPS_REG_PC,

    UC_MIPS_REG_0,
    UC_MIPS_REG_1,
    UC_MIPS_REG_2,
    UC_MIPS_REG_3,
    UC_MIPS_REG_4,
    UC_MIPS_REG_5,
    UC_MIPS_REG_6,
    UC_MIPS_REG_7,
    UC_MIPS_REG_8,
    UC_MIPS_REG_9,
    UC_MIPS_REG_10,
    UC_MIPS_REG_11,
    UC_MIPS_REG_12,
    UC_MIPS_REG_13,
    UC_MIPS_REG_14,
    UC_MIPS_REG_15,
    UC_MIPS_REG_16,
    UC_MIPS_REG_17,
    UC_MIPS_REG_18,
    UC_MIPS_REG_19,
    UC_MIPS_REG_20,
    UC_MIPS_REG_21,
    UC_MIPS_REG_22,
    UC_MIPS_REG_23,
    UC_MIPS_REG_24,
    UC_MIPS_REG_25,
    UC_MIPS_REG_26,
    UC_MIPS_REG_27,
    UC_MIPS_REG_28,
    UC_MIPS_REG_29,
    UC_MIPS_REG_30,
    UC_MIPS_REG_31,

    //> DSP registers
    UC_MIPS_REG_DSPCCOND,
    UC_MIPS_REG_DSPCARRY,
    UC_MIPS_REG_DSPEFI,
    UC_MIPS_REG_DSPOUTFLAG,
    UC_MIPS_REG_DSPOUTFLAG16_19,
    UC_MIPS_REG_DSPOUTFLAG20,
    UC_MIPS_REG_DSPOUTFLAG21,
    UC_MIPS_REG_DSPOUTFLAG22,
    UC_MIPS_REG_DSPOUTFLAG23,
    UC_MIPS_REG_DSPPOS,
    UC_MIPS_REG_DSPSCOUNT,

    //> ACC registers
    UC_MIPS_REG_AC0,
    UC_MIPS_REG_AC1,
    UC_MIPS_REG_AC2,
    UC_MIPS_REG_AC3,

    //> COP registers
    UC_MIPS_REG_CC0,
    UC_MIPS_REG_CC1,
    UC_MIPS_REG_CC2,
    UC_MIPS_REG_CC3,
    UC_MIPS_REG_CC4,
    UC_MIPS_REG_CC5,
    UC_MIPS_REG_CC6,
    UC_MIPS_REG_CC7,

    //> FPU registers
    UC_MIPS_REG_F0,
    UC_MIPS_REG_F1,
    UC_MIPS_REG_F2,
    UC_MIPS_REG_F3,
    UC_MIPS_REG_F4,
    UC_MIPS_REG_F5,
    UC_MIPS_REG_F6,
    UC_MIPS_REG_F7,
    UC_MIPS_REG_F8,
    UC_MIPS_REG_F9,
    UC_MIPS_REG_F10,
    UC_MIPS_REG_F11,
    UC_MIPS_REG_F12,
    UC_MIPS_REG_F13,
    UC_MIPS_REG_F14,
    UC_MIPS_REG_F15,
    UC_MIPS_REG_F16,
    UC_MIPS_REG_F17,
    UC_MIPS_REG_F18,
    UC_MIPS_REG_F19,
    UC_MIPS_REG_F20,
    UC_MIPS_REG_F21,
    UC_MIPS_REG_F22,
    UC_MIPS_REG_F23,
    UC_MIPS_REG_F24,
    UC_MIPS_REG_F25,
    UC_MIPS_REG_F26,
    UC_MIPS_REG_F27,
    UC_MIPS_REG_F28,
    UC_MIPS_REG_F29,
    UC_MIPS_REG_F30,
    UC_MIPS_REG_F31,

    UC_MIPS_REG_FCC0,
    UC_MIPS_REG_FCC1,
    UC_MIPS_REG_FCC2,
    UC_MIPS_REG_FCC3,
    UC_MIPS_REG_FCC4,
    UC_MIPS_REG_FCC5,
    UC_MIPS_REG_FCC6,
    UC_MIPS_REG_FCC7,

    //> AFPR128
    UC_MIPS_REG_W0,
    UC_MIPS_REG_W1,
    UC_MIPS_REG_W2,
    UC_MIPS_REG_W3,
    UC_MIPS_REG_W4,
    UC_MIPS_REG_W5,
    UC_MIPS_REG_W6,
    UC_MIPS_REG_W7,
    UC_MIPS_REG_W8,
    UC_MIPS_REG_W9,
    UC_MIPS_REG_W10,
    UC_MIPS_REG_W11,
    UC_MIPS_REG_W12,
    UC_MIPS_REG_W13,
    UC_MIPS_REG_W14,
    UC_MIPS_REG_W15,
    UC_MIPS_REG_W16,
    UC_MIPS_REG_W17,
    UC_MIPS_REG_W18,
    UC_MIPS_REG_W19,
    UC_MIPS_REG_W20,
    UC_MIPS_REG_W21,
    UC_MIPS_REG_W22,
    UC_MIPS_REG_W23,
    UC_MIPS_REG_W24,
    UC_MIPS_REG_W25,
    UC_MIPS_REG_W26,
    UC_MIPS_REG_W27,
    UC_MIPS_REG_W28,
    UC_MIPS_REG_W29,
    UC_MIPS_REG_W30,
    UC_MIPS_REG_W31,

    UC_MIPS_REG_HI,
    UC_MIPS_REG_LO,

    UC_MIPS_REG_P0,
    UC_MIPS_REG_P1,
    UC_MIPS_REG_P2,

    UC_MIPS_REG_MPL0,
    UC_MIPS_REG_MPL1,
    UC_MIPS_REG_MPL2,

    UC_MIPS_REG_CP0_CONFIG3,
    UC_MIPS_REG_CP0_USERLOCAL,
    UC_MIPS_REG_CP0_STATUS,

    // FCR(s) Ref:
    // https://s3-eu-west-1.amazonaws.com/downloads-mips/documents/MD00083-2B-MIPS64INT-AFP-06.01.pdf
    UC_MIPS_REG_FIR,
    UC_MIPS_REG_FCSR,

    UC_MIPS_REG_ENDING, // <-- mark the end of the list or registers

    // alias registers
    UC_MIPS_REG_ZERO = UC_MIPS_REG_0,
    UC_MIPS_REG_AT = UC_MIPS_REG_1,
    UC_MIPS_REG_V0 = UC_MIPS_REG_2,
    UC_MIPS_REG_V1 = UC_MIPS_REG_3,
    UC_MIPS_REG_A0 = UC_MIPS_REG_4,
    UC_MIPS_REG_A1 = UC_MIPS_REG_5,
    UC_MIPS_REG_A2 = UC_MIPS_REG_6,
    UC_MIPS_REG_A3 = UC_MIPS_REG_7,
    UC_MIPS_REG_T0 = UC_MIPS_REG_8,
    UC_MIPS_REG_T1 = UC_MIPS_REG_9,
    UC_MIPS_REG_T2 = UC_MIPS_REG_10,
    UC_MIPS_REG_T3 = UC_MIPS_REG_11,
    UC_MIPS_REG_T4 = UC_MIPS_REG_12,
    UC_MIPS_REG_T5 = UC_MIPS_REG_13,
    UC_MIPS_REG_T6 = UC_MIPS_REG_14,
    UC_MIPS_REG_T7 = UC_MIPS_REG_15,
    UC_MIPS_REG_S0 = UC_MIPS_REG_16,
    UC_MIPS_REG_S1 = UC_MIPS_REG_17,
    UC_MIPS_REG_S2 = UC_MIPS_REG_18,
    UC_MIPS_REG_S3 = UC_MIPS_REG_19,
    UC_MIPS_REG_S4 = UC_MIPS_REG_20,
    UC_MIPS_REG_S5 = UC_MIPS_REG_21,
    UC_MIPS_REG_S6 = UC_MIPS_REG_22,
    UC_MIPS_REG_S7 = UC_MIPS_REG_23,
    UC_MIPS_REG_T8 = UC_MIPS_REG_24,
    UC_MIPS_REG_T9 = UC_MIPS_REG_25,
    UC_MIPS_REG_K0 = UC_MIPS_REG_26,
    UC_MIPS_REG_K1 = UC_MIPS_REG_27,
    UC_MIPS_REG_GP = UC_MIPS_REG_28,
    UC_MIPS_REG_SP = UC_MIPS_REG_29,
    UC_MIPS_REG_FP = UC_MIPS_REG_30,
    UC_MIPS_REG_S8 = UC_MIPS_REG_30,
    UC_MIPS_REG_RA = UC_MIPS_REG_31,

    UC_MIPS_REG_HI0 = UC_MIPS_REG_AC0,
    UC_MIPS_REG_HI1 = UC_MIPS_REG_AC1,
    UC_MIPS_REG_HI2 = UC_MIPS_REG_AC2,
    UC_MIPS_REG_HI3 = UC_MIPS_REG_AC3,

    UC_MIPS_REG_LO0 = UC_MIPS_REG_HI0,
    UC_MIPS_REG_LO1 = UC_MIPS_REG_HI1,
    UC_MIPS_REG_LO2 = UC_MIPS_REG_HI2,
    UC_MIPS_REG_LO3 = UC_MIPS_REG_HI3,
} uc_mips_reg;

// This is only for backwards compatibility
typedef uc_mips_reg UC_MIPS_REG;

#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/include/unicorn/unicorn/platform.h`:

```h
/* This file is released under LGPL2.
   See COPYING.LGPL2 in root directory for more details
*/

/*
 This file is to support header files that are missing in MSVC and
 other non-standard compilers.
*/
#ifndef UNICORN_PLATFORM_H
#define UNICORN_PLATFORM_H

/*
These are the various MSVC versions as given by _MSC_VER:
MSVC++ 14.0 _MSC_VER == 1900 (Visual Studio 2015)
MSVC++ 12.0 _MSC_VER == 1800 (Visual Studio 2013)
MSVC++ 11.0 _MSC_VER == 1700 (Visual Studio 2012)
MSVC++ 10.0 _MSC_VER == 1600 (Visual Studio 2010)
MSVC++ 9.0  _MSC_VER == 1500 (Visual Studio 2008)
MSVC++ 8.0  _MSC_VER == 1400 (Visual Studio 2005)
MSVC++ 7.1  _MSC_VER == 1310 (Visual Studio 2003)
MSVC++ 7.0  _MSC_VER == 1300
MSVC++ 6.0  _MSC_VER == 1200
MSVC++ 5.0  _MSC_VER == 1100
*/
#define MSC_VER_VS2003 1310
#define MSC_VER_VS2005 1400
#define MSC_VER_VS2008 1500
#define MSC_VER_VS2010 1600
#define MSC_VER_VS2012 1700
#define MSC_VER_VS2013 1800
#define MSC_VER_VS2015 1900

// handle stdbool.h compatibility
#if !defined(__CYGWIN__) && !defined(__MINGW32__) && !defined(__MINGW64__) &&  \
    (defined(WIN32) || defined(WIN64) || defined(_WIN32) || defined(_WIN64))
// MSVC

// stdbool.h
#if (_MSC_VER < MSC_VER_VS2013) || defined(_KERNEL_MODE)
// this system does not have stdbool.h
#ifndef __cplusplus
typedef unsigned char bool;
#define false 0
#define true 1
#endif // __cplusplus

#else
// VisualStudio 2013+ -> C99 is supported
#include <stdbool.h>
#endif // (_MSC_VER < MSC_VER_VS2013) || defined(_KERNEL_MODE)

#else
// not MSVC -> C99 is supported
#include <stdbool.h>
#endif // !defined(__CYGWIN__) && !defined(__MINGW32__) && !defined(__MINGW64__)
       // && (defined (WIN32) || defined (WIN64) || defined (_WIN32) || defined
       // (_WIN64))

#if (defined(_MSC_VER) && (_MSC_VER < MSC_VER_VS2010)) || defined(_KERNEL_MODE)
// this system does not have stdint.h
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed int int32_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef signed long long int64_t;
typedef unsigned long long uint64_t;

typedef signed char int_fast8_t;
typedef int int_fast16_t;
typedef int int_fast32_t;
typedef long long int_fast64_t;
typedef unsigned char uint_fast8_t;
typedef unsigned int uint_fast16_t;
typedef unsigned int uint_fast32_t;
typedef unsigned long long uint_fast64_t;

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

#ifndef _INTPTR_T_DEFINED
#define _INTPTR_T_DEFINED
#ifdef _WIN64
typedef long long intptr_t;
#else  /* _WIN64 */
typedef _W64 int intptr_t;
#endif /* _WIN64 */
#endif /* _INTPTR_T_DEFINED */

#ifndef _UINTPTR_T_DEFINED
#define _UINTPTR_T_DEFINED
#ifdef _WIN64
typedef unsigned long long uintptr_t;
#else  /* _WIN64 */
typedef _W64 unsigned int uintptr_t;
#endif /* _WIN64 */
#endif /* _UINTPTR_T_DEFINED */

#define INT8_MIN (-127i8 - 1)
#define INT16_MIN (-32767i16 - 1)
#define INT32_MIN (-2147483647i32 - 1)
#define INT64_MIN (-9223372036854775807i64 - 1)
#define INT8_MAX 127i8
#define INT16_MAX 32767i16
#define INT32_MAX 2147483647i32
#define INT64_MAX 9223372036854775807i64
#define UINT8_MAX 0xffui8
#define UINT16_MAX 0xffffui16
#define UINT32_MAX 0xffffffffui32
#define UINT64_MAX 0xffffffffffffffffui64

#define INT_FAST8_MIN INT8_MIN
#define INT_FAST16_MIN INT32_MIN
#define INT_FAST32_MIN INT32_MIN
#define INT_FAST64_MIN INT64_MIN
#define INT_FAST8_MAX INT8_MAX
#define INT_FAST16_MAX INT32_MAX
#define INT_FAST32_MAX INT32_MAX
#define INT_FAST64_MAX INT64_MAX
#define UINT_FAST8_MAX UINT8_MAX
#define UINT_FAST16_MAX UINT32_MAX
#define UINT_FAST32_MAX UINT32_MAX
#define UINT_FAST64_MAX UINT64_MAX

#ifdef _WIN64
#define INTPTR_MIN INT64_MIN
#define INTPTR_MAX INT64_MAX
#define UINTPTR_MAX UINT64_MAX
#else /* _WIN64 */
#define INTPTR_MIN INT32_MIN
#define INTPTR_MAX INT32_MAX
#define UINTPTR_MAX UINT32_MAX
#endif /* _WIN64 */

#else // this system has stdint.h

#if defined(_MSC_VER) && (_MSC_VER == MSC_VER_VS2010)
#define _INTPTR 2
#endif

#include <stdint.h>
#endif // (defined(_MSC_VER) && (_MSC_VER < MSC_VER_VS2010)) ||
       // defined(_KERNEL_MODE)

// handle inttypes.h compatibility
#if (defined(_MSC_VER) && (_MSC_VER < MSC_VER_VS2013)) || defined(_KERNEL_MODE)
// this system does not have inttypes.h

#define __PRI_8_LENGTH_MODIFIER__ "hh"
#define __PRI_64_LENGTH_MODIFIER__ "ll"

#define PRId8 __PRI_8_LENGTH_MODIFIER__ "d"
#define PRIi8 __PRI_8_LENGTH_MODIFIER__ "i"
#define PRIo8 __PRI_8_LENGTH_MODIFIER__ "o"
#define PRIu8 __PRI_8_LENGTH_MODIFIER__ "u"
#define PRIx8 __PRI_8_LENGTH_MODIFIER__ "x"
#define PRIX8 __PRI_8_LENGTH_MODIFIER__ "X"

#define PRId16 "hd"
#define PRIi16 "hi"
#define PRIo16 "ho"
#define PRIu16 "hu"
#define PRIx16 "hx"
#define PRIX16 "hX"

#if defined(_MSC_VER) && (_MSC_VER <= MSC_VER_VS2012)
#define PRId32 "ld"
#define PRIi32 "li"
#define PRIo32 "lo"
#define PRIu32 "lu"
#define PRIx32 "lx"
#define PRIX32 "lX"
#else // OSX
#define PRId32 "d"
#define PRIi32 "i"
#define PRIo32 "o"
#define PRIu32 "u"
#define PRIx32 "x"
#define PRIX32 "X"
#endif // defined(_MSC_VER) && (_MSC_VER <= MSC_VER_VS2012)

#if defined(_MSC_VER) && (_MSC_VER <= MSC_VER_VS2012)
// redefine functions from inttypes.h used in cstool
#define strtoull _strtoui64
#endif

#define PRId64 __PRI_64_LENGTH_MODIFIER__ "d"
#define PRIi64 __PRI_64_LENGTH_MODIFIER__ "i"
#define PRIo64 __PRI_64_LENGTH_MODIFIER__ "o"
#define PRIu64 __PRI_64_LENGTH_MODIFIER__ "u"
#define PRIx64 __PRI_64_LENGTH_MODIFIER__ "x"
#define PRIX64 __PRI_64_LENGTH_MODIFIER__ "X"

#else
// this system has inttypes.h by default
#include <inttypes.h>
#endif // #if defined(_MSC_VER) && (_MSC_VER < MSC_VER_VS2013) ||
       // defined(_KERNEL_MODE)

// sys/time.h compatibility
#if defined(_MSC_VER)
#include <sys/types.h>
#include <sys/timeb.h>
#include <windows.h>

#else
#include <sys/time.h>
#endif

// unistd.h compatibility
#if defined(_MSC_VER)

static int usleep(uint32_t usec)
{
    HANDLE timer;
    LARGE_INTEGER due;

    timer = CreateWaitableTimer(NULL, TRUE, NULL);
    if (!timer)
        return -1;

    due.QuadPart = (-((int64_t)usec)) * 10LL;
    if (!SetWaitableTimer(timer, &due, 0, NULL, NULL, 0)) {
        CloseHandle(timer);
        return -1;
    }
    WaitForSingleObject(timer, INFINITE);
    CloseHandle(timer);

    return 0;
}

#else
#include <unistd.h>
#endif

// misc support
#if defined(_MSC_VER)
#ifdef _WIN64
typedef signed __int64 ssize_t;
#else
typedef _W64 signed int ssize_t;
#endif

#ifndef va_copy
#define va_copy(d, s) ((d) = (s))
#endif
#define strcasecmp _stricmp
#if (_MSC_VER < MSC_VER_VS2015)
#define snprintf _snprintf
#endif
#if (_MSC_VER <= MSC_VER_VS2013)
#define strtoll _strtoi64
#endif
#endif

#endif // UNICORN_PLATFORM_H

```

`KDemu/include/unicorn/unicorn/ppc.h`:

```h
/* Unicorn Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2015-2017 */
/* This file is released under LGPL2.
   See COPYING.LGPL2 in root directory for more details
*/

#ifndef UNICORN_PPC_H
#define UNICORN_PPC_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _MSC_VER
#pragma warning(disable : 4201)
#endif

//> PPC CPU
typedef enum uc_cpu_ppc {
    UC_CPU_PPC32_401 = 0,
    UC_CPU_PPC32_401A1,
    UC_CPU_PPC32_401B2,
    UC_CPU_PPC32_401C2,
    UC_CPU_PPC32_401D2,
    UC_CPU_PPC32_401E2,
    UC_CPU_PPC32_401F2,
    UC_CPU_PPC32_401G2,
    UC_CPU_PPC32_IOP480,
    UC_CPU_PPC32_COBRA,
    UC_CPU_PPC32_403GA,
    UC_CPU_PPC32_403GB,
    UC_CPU_PPC32_403GC,
    UC_CPU_PPC32_403GCX,
    UC_CPU_PPC32_405D2,
    UC_CPU_PPC32_405D4,
    UC_CPU_PPC32_405CRA,
    UC_CPU_PPC32_405CRB,
    UC_CPU_PPC32_405CRC,
    UC_CPU_PPC32_405EP,
    UC_CPU_PPC32_405EZ,
    UC_CPU_PPC32_405GPA,
    UC_CPU_PPC32_405GPB,
    UC_CPU_PPC32_405GPC,
    UC_CPU_PPC32_405GPD,
    UC_CPU_PPC32_405GPR,
    UC_CPU_PPC32_405LP,
    UC_CPU_PPC32_NPE405H,
    UC_CPU_PPC32_NPE405H2,
    UC_CPU_PPC32_NPE405L,
    UC_CPU_PPC32_NPE4GS3,
    UC_CPU_PPC32_STB03,
    UC_CPU_PPC32_STB04,
    UC_CPU_PPC32_STB25,
    UC_CPU_PPC32_X2VP4,
    UC_CPU_PPC32_X2VP20,
    UC_CPU_PPC32_440_XILINX,
    UC_CPU_PPC32_440_XILINX_W_DFPU,
    UC_CPU_PPC32_440EPA,
    UC_CPU_PPC32_440EPB,
    UC_CPU_PPC32_440EPX,
    UC_CPU_PPC32_460EXB,
    UC_CPU_PPC32_G2,
    UC_CPU_PPC32_G2H4,
    UC_CPU_PPC32_G2GP,
    UC_CPU_PPC32_G2LS,
    UC_CPU_PPC32_G2HIP3,
    UC_CPU_PPC32_G2HIP4,
    UC_CPU_PPC32_MPC603,
    UC_CPU_PPC32_G2LE,
    UC_CPU_PPC32_G2LEGP,
    UC_CPU_PPC32_G2LELS,
    UC_CPU_PPC32_G2LEGP1,
    UC_CPU_PPC32_G2LEGP3,
    UC_CPU_PPC32_MPC5200_V10,
    UC_CPU_PPC32_MPC5200_V11,
    UC_CPU_PPC32_MPC5200_V12,
    UC_CPU_PPC32_MPC5200B_V20,
    UC_CPU_PPC32_MPC5200B_V21,
    UC_CPU_PPC32_E200Z5,
    UC_CPU_PPC32_E200Z6,
    UC_CPU_PPC32_E300C1,
    UC_CPU_PPC32_E300C2,
    UC_CPU_PPC32_E300C3,
    UC_CPU_PPC32_E300C4,
    UC_CPU_PPC32_MPC8343,
    UC_CPU_PPC32_MPC8343A,
    UC_CPU_PPC32_MPC8343E,
    UC_CPU_PPC32_MPC8343EA,
    UC_CPU_PPC32_MPC8347T,
    UC_CPU_PPC32_MPC8347P,
    UC_CPU_PPC32_MPC8347AT,
    UC_CPU_PPC32_MPC8347AP,
    UC_CPU_PPC32_MPC8347ET,
    UC_CPU_PPC32_MPC8347EP,
    UC_CPU_PPC32_MPC8347EAT,
    UC_CPU_PPC32_MPC8347EAP,
    UC_CPU_PPC32_MPC8349,
    UC_CPU_PPC32_MPC8349A,
    UC_CPU_PPC32_MPC8349E,
    UC_CPU_PPC32_MPC8349EA,
    UC_CPU_PPC32_MPC8377,
    UC_CPU_PPC32_MPC8377E,
    UC_CPU_PPC32_MPC8378,
    UC_CPU_PPC32_MPC8378E,
    UC_CPU_PPC32_MPC8379,
    UC_CPU_PPC32_MPC8379E,
    UC_CPU_PPC32_E500_V10,
    UC_CPU_PPC32_E500_V20,
    UC_CPU_PPC32_E500V2_V10,
    UC_CPU_PPC32_E500V2_V20,
    UC_CPU_PPC32_E500V2_V21,
    UC_CPU_PPC32_E500V2_V22,
    UC_CPU_PPC32_E500V2_V30,
    UC_CPU_PPC32_E500MC,
    UC_CPU_PPC32_MPC8533_V10,
    UC_CPU_PPC32_MPC8533_V11,
    UC_CPU_PPC32_MPC8533E_V10,
    UC_CPU_PPC32_MPC8533E_V11,
    UC_CPU_PPC32_MPC8540_V10,
    UC_CPU_PPC32_MPC8540_V20,
    UC_CPU_PPC32_MPC8540_V21,
    UC_CPU_PPC32_MPC8541_V10,
    UC_CPU_PPC32_MPC8541_V11,
    UC_CPU_PPC32_MPC8541E_V10,
    UC_CPU_PPC32_MPC8541E_V11,
    UC_CPU_PPC32_MPC8543_V10,
    UC_CPU_PPC32_MPC8543_V11,
    UC_CPU_PPC32_MPC8543_V20,
    UC_CPU_PPC32_MPC8543_V21,
    UC_CPU_PPC32_MPC8543E_V10,
    UC_CPU_PPC32_MPC8543E_V11,
    UC_CPU_PPC32_MPC8543E_V20,
    UC_CPU_PPC32_MPC8543E_V21,
    UC_CPU_PPC32_MPC8544_V10,
    UC_CPU_PPC32_MPC8544_V11,
    UC_CPU_PPC32_MPC8544E_V10,
    UC_CPU_PPC32_MPC8544E_V11,
    UC_CPU_PPC32_MPC8545_V20,
    UC_CPU_PPC32_MPC8545_V21,
    UC_CPU_PPC32_MPC8545E_V20,
    UC_CPU_PPC32_MPC8545E_V21,
    UC_CPU_PPC32_MPC8547E_V20,
    UC_CPU_PPC32_MPC8547E_V21,
    UC_CPU_PPC32_MPC8548_V10,
    UC_CPU_PPC32_MPC8548_V11,
    UC_CPU_PPC32_MPC8548_V20,
    UC_CPU_PPC32_MPC8548_V21,
    UC_CPU_PPC32_MPC8548E_V10,
    UC_CPU_PPC32_MPC8548E_V11,
    UC_CPU_PPC32_MPC8548E_V20,
    UC_CPU_PPC32_MPC8548E_V21,
    UC_CPU_PPC32_MPC8555_V10,
    UC_CPU_PPC32_MPC8555_V11,
    UC_CPU_PPC32_MPC8555E_V10,
    UC_CPU_PPC32_MPC8555E_V11,
    UC_CPU_PPC32_MPC8560_V10,
    UC_CPU_PPC32_MPC8560_V20,
    UC_CPU_PPC32_MPC8560_V21,
    UC_CPU_PPC32_MPC8567,
    UC_CPU_PPC32_MPC8567E,
    UC_CPU_PPC32_MPC8568,
    UC_CPU_PPC32_MPC8568E,
    UC_CPU_PPC32_MPC8572,
    UC_CPU_PPC32_MPC8572E,
    UC_CPU_PPC32_E600,
    UC_CPU_PPC32_MPC8610,
    UC_CPU_PPC32_MPC8641,
    UC_CPU_PPC32_MPC8641D,
    UC_CPU_PPC32_601_V0,
    UC_CPU_PPC32_601_V1,
    UC_CPU_PPC32_601_V2,
    UC_CPU_PPC32_602,
    UC_CPU_PPC32_603,
    UC_CPU_PPC32_603E_V1_1,
    UC_CPU_PPC32_603E_V1_2,
    UC_CPU_PPC32_603E_V1_3,
    UC_CPU_PPC32_603E_V1_4,
    UC_CPU_PPC32_603E_V2_2,
    UC_CPU_PPC32_603E_V3,
    UC_CPU_PPC32_603E_V4,
    UC_CPU_PPC32_603E_V4_1,
    UC_CPU_PPC32_603E7,
    UC_CPU_PPC32_603E7T,
    UC_CPU_PPC32_603E7V,
    UC_CPU_PPC32_603E7V1,
    UC_CPU_PPC32_603E7V2,
    UC_CPU_PPC32_603P,
    UC_CPU_PPC32_604,
    UC_CPU_PPC32_604E_V1_0,
    UC_CPU_PPC32_604E_V2_2,
    UC_CPU_PPC32_604E_V2_4,
    UC_CPU_PPC32_604R,
    UC_CPU_PPC32_740_V1_0,
    UC_CPU_PPC32_750_V1_0,
    UC_CPU_PPC32_740_V2_0,
    UC_CPU_PPC32_750_V2_0,
    UC_CPU_PPC32_740_V2_1,
    UC_CPU_PPC32_750_V2_1,
    UC_CPU_PPC32_740_V2_2,
    UC_CPU_PPC32_750_V2_2,
    UC_CPU_PPC32_740_V3_0,
    UC_CPU_PPC32_750_V3_0,
    UC_CPU_PPC32_740_V3_1,
    UC_CPU_PPC32_750_V3_1,
    UC_CPU_PPC32_740E,
    UC_CPU_PPC32_750E,
    UC_CPU_PPC32_740P,
    UC_CPU_PPC32_750P,
    UC_CPU_PPC32_750CL_V1_0,
    UC_CPU_PPC32_750CL_V2_0,
    UC_CPU_PPC32_750CX_V1_0,
    UC_CPU_PPC32_750CX_V2_0,
    UC_CPU_PPC32_750CX_V2_1,
    UC_CPU_PPC32_750CX_V2_2,
    UC_CPU_PPC32_750CXE_V2_1,
    UC_CPU_PPC32_750CXE_V2_2,
    UC_CPU_PPC32_750CXE_V2_3,
    UC_CPU_PPC32_750CXE_V2_4,
    UC_CPU_PPC32_750CXE_V2_4B,
    UC_CPU_PPC32_750CXE_V3_0,
    UC_CPU_PPC32_750CXE_V3_1,
    UC_CPU_PPC32_750CXE_V3_1B,
    UC_CPU_PPC32_750CXR,
    UC_CPU_PPC32_750FL,
    UC_CPU_PPC32_750FX_V1_0,
    UC_CPU_PPC32_750FX_V2_0,
    UC_CPU_PPC32_750FX_V2_1,
    UC_CPU_PPC32_750FX_V2_2,
    UC_CPU_PPC32_750FX_V2_3,
    UC_CPU_PPC32_750GL,
    UC_CPU_PPC32_750GX_V1_0,
    UC_CPU_PPC32_750GX_V1_1,
    UC_CPU_PPC32_750GX_V1_2,
    UC_CPU_PPC32_750L_V2_0,
    UC_CPU_PPC32_750L_V2_1,
    UC_CPU_PPC32_750L_V2_2,
    UC_CPU_PPC32_750L_V3_0,
    UC_CPU_PPC32_750L_V3_2,
    UC_CPU_PPC32_745_V1_0,
    UC_CPU_PPC32_755_V1_0,
    UC_CPU_PPC32_745_V1_1,
    UC_CPU_PPC32_755_V1_1,
    UC_CPU_PPC32_745_V2_0,
    UC_CPU_PPC32_755_V2_0,
    UC_CPU_PPC32_745_V2_1,
    UC_CPU_PPC32_755_V2_1,
    UC_CPU_PPC32_745_V2_2,
    UC_CPU_PPC32_755_V2_2,
    UC_CPU_PPC32_745_V2_3,
    UC_CPU_PPC32_755_V2_3,
    UC_CPU_PPC32_745_V2_4,
    UC_CPU_PPC32_755_V2_4,
    UC_CPU_PPC32_745_V2_5,
    UC_CPU_PPC32_755_V2_5,
    UC_CPU_PPC32_745_V2_6,
    UC_CPU_PPC32_755_V2_6,
    UC_CPU_PPC32_745_V2_7,
    UC_CPU_PPC32_755_V2_7,
    UC_CPU_PPC32_745_V2_8,
    UC_CPU_PPC32_755_V2_8,
    UC_CPU_PPC32_7400_V1_0,
    UC_CPU_PPC32_7400_V1_1,
    UC_CPU_PPC32_7400_V2_0,
    UC_CPU_PPC32_7400_V2_1,
    UC_CPU_PPC32_7400_V2_2,
    UC_CPU_PPC32_7400_V2_6,
    UC_CPU_PPC32_7400_V2_7,
    UC_CPU_PPC32_7400_V2_8,
    UC_CPU_PPC32_7400_V2_9,
    UC_CPU_PPC32_7410_V1_0,
    UC_CPU_PPC32_7410_V1_1,
    UC_CPU_PPC32_7410_V1_2,
    UC_CPU_PPC32_7410_V1_3,
    UC_CPU_PPC32_7410_V1_4,
    UC_CPU_PPC32_7448_V1_0,
    UC_CPU_PPC32_7448_V1_1,
    UC_CPU_PPC32_7448_V2_0,
    UC_CPU_PPC32_7448_V2_1,
    UC_CPU_PPC32_7450_V1_0,
    UC_CPU_PPC32_7450_V1_1,
    UC_CPU_PPC32_7450_V1_2,
    UC_CPU_PPC32_7450_V2_0,
    UC_CPU_PPC32_7450_V2_1,
    UC_CPU_PPC32_7441_V2_1,
    UC_CPU_PPC32_7441_V2_3,
    UC_CPU_PPC32_7451_V2_3,
    UC_CPU_PPC32_7441_V2_10,
    UC_CPU_PPC32_7451_V2_10,
    UC_CPU_PPC32_7445_V1_0,
    UC_CPU_PPC32_7455_V1_0,
    UC_CPU_PPC32_7445_V2_1,
    UC_CPU_PPC32_7455_V2_1,
    UC_CPU_PPC32_7445_V3_2,
    UC_CPU_PPC32_7455_V3_2,
    UC_CPU_PPC32_7445_V3_3,
    UC_CPU_PPC32_7455_V3_3,
    UC_CPU_PPC32_7445_V3_4,
    UC_CPU_PPC32_7455_V3_4,
    UC_CPU_PPC32_7447_V1_0,
    UC_CPU_PPC32_7457_V1_0,
    UC_CPU_PPC32_7447_V1_1,
    UC_CPU_PPC32_7457_V1_1,
    UC_CPU_PPC32_7457_V1_2,
    UC_CPU_PPC32_7447A_V1_0,
    UC_CPU_PPC32_7457A_V1_0,
    UC_CPU_PPC32_7447A_V1_1,
    UC_CPU_PPC32_7457A_V1_1,
    UC_CPU_PPC32_7447A_V1_2,
    UC_CPU_PPC32_7457A_V1_2,

    UC_CPU_PPC32_ENDING
} uc_cpu_ppc;

//> PPC64 CPU
typedef enum uc_cpu_ppc64 {
    UC_CPU_PPC64_E5500 = 0,
    UC_CPU_PPC64_E6500,
    UC_CPU_PPC64_970_V2_2,
    UC_CPU_PPC64_970FX_V1_0,
    UC_CPU_PPC64_970FX_V2_0,
    UC_CPU_PPC64_970FX_V2_1,
    UC_CPU_PPC64_970FX_V3_0,
    UC_CPU_PPC64_970FX_V3_1,
    UC_CPU_PPC64_970MP_V1_0,
    UC_CPU_PPC64_970MP_V1_1,
    UC_CPU_PPC64_POWER5_V2_1,
    UC_CPU_PPC64_POWER7_V2_3,
    UC_CPU_PPC64_POWER7_V2_1,
    UC_CPU_PPC64_POWER8E_V2_1,
    UC_CPU_PPC64_POWER8_V2_0,
    UC_CPU_PPC64_POWER8NVL_V1_0,
    UC_CPU_PPC64_POWER9_V1_0,
    UC_CPU_PPC64_POWER9_V2_0,
    UC_CPU_PPC64_POWER10_V1_0,

    UC_CPU_PPC64_ENDING
} uc_cpu_ppc64;

//> PPC registers
typedef enum uc_ppc_reg {
    UC_PPC_REG_INVALID = 0,
    //> General purpose registers
    UC_PPC_REG_PC,

    UC_PPC_REG_0,
    UC_PPC_REG_1,
    UC_PPC_REG_2,
    UC_PPC_REG_3,
    UC_PPC_REG_4,
    UC_PPC_REG_5,
    UC_PPC_REG_6,
    UC_PPC_REG_7,
    UC_PPC_REG_8,
    UC_PPC_REG_9,
    UC_PPC_REG_10,
    UC_PPC_REG_11,
    UC_PPC_REG_12,
    UC_PPC_REG_13,
    UC_PPC_REG_14,
    UC_PPC_REG_15,
    UC_PPC_REG_16,
    UC_PPC_REG_17,
    UC_PPC_REG_18,
    UC_PPC_REG_19,
    UC_PPC_REG_20,
    UC_PPC_REG_21,
    UC_PPC_REG_22,
    UC_PPC_REG_23,
    UC_PPC_REG_24,
    UC_PPC_REG_25,
    UC_PPC_REG_26,
    UC_PPC_REG_27,
    UC_PPC_REG_28,
    UC_PPC_REG_29,
    UC_PPC_REG_30,
    UC_PPC_REG_31,

    UC_PPC_REG_CR0,
    UC_PPC_REG_CR1,
    UC_PPC_REG_CR2,
    UC_PPC_REG_CR3,
    UC_PPC_REG_CR4,
    UC_PPC_REG_CR5,
    UC_PPC_REG_CR6,
    UC_PPC_REG_CR7,

    UC_PPC_REG_FPR0,
    UC_PPC_REG_FPR1,
    UC_PPC_REG_FPR2,
    UC_PPC_REG_FPR3,
    UC_PPC_REG_FPR4,
    UC_PPC_REG_FPR5,
    UC_PPC_REG_FPR6,
    UC_PPC_REG_FPR7,
    UC_PPC_REG_FPR8,
    UC_PPC_REG_FPR9,
    UC_PPC_REG_FPR10,
    UC_PPC_REG_FPR11,
    UC_PPC_REG_FPR12,
    UC_PPC_REG_FPR13,
    UC_PPC_REG_FPR14,
    UC_PPC_REG_FPR15,
    UC_PPC_REG_FPR16,
    UC_PPC_REG_FPR17,
    UC_PPC_REG_FPR18,
    UC_PPC_REG_FPR19,
    UC_PPC_REG_FPR20,
    UC_PPC_REG_FPR21,
    UC_PPC_REG_FPR22,
    UC_PPC_REG_FPR23,
    UC_PPC_REG_FPR24,
    UC_PPC_REG_FPR25,
    UC_PPC_REG_FPR26,
    UC_PPC_REG_FPR27,
    UC_PPC_REG_FPR28,
    UC_PPC_REG_FPR29,
    UC_PPC_REG_FPR30,
    UC_PPC_REG_FPR31,

    UC_PPC_REG_LR,
    UC_PPC_REG_XER,
    UC_PPC_REG_CTR,
    UC_PPC_REG_MSR,
    UC_PPC_REG_FPSCR,
    UC_PPC_REG_CR,

    UC_PPC_REG_ENDING, // <-- mark the end of the list or registers
} uc_ppc_reg;

#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/include/unicorn/unicorn/riscv.h`:

```h
/* Unicorn Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2015-2020 */
/* This file is released under LGPL2.
   See COPYING.LGPL2 in root directory for more details
 */

#ifndef UNICORN_RISCV_H
#define UNICORN_RISCV_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _MSC_VER
#pragma warning(disable : 4201)
#endif

//> RISCV32 CPU
typedef enum uc_cpu_riscv32 {
    UC_CPU_RISCV32_ANY = 0,
    UC_CPU_RISCV32_BASE32,
    UC_CPU_RISCV32_SIFIVE_E31,
    UC_CPU_RISCV32_SIFIVE_U34,

    UC_CPU_RISCV32_ENDING
} uc_cpu_riscv32;

//> RISCV64 CPU
typedef enum uc_cpu_riscv64 {
    UC_CPU_RISCV64_ANY = 0,
    UC_CPU_RISCV64_BASE64,
    UC_CPU_RISCV64_SIFIVE_E51,
    UC_CPU_RISCV64_SIFIVE_U54,

    UC_CPU_RISCV64_ENDING
} uc_cpu_riscv64;

//> RISCV registers
typedef enum uc_riscv_reg {
    UC_RISCV_REG_INVALID = 0,
    //> General purpose registers
    UC_RISCV_REG_X0,
    UC_RISCV_REG_X1,
    UC_RISCV_REG_X2,
    UC_RISCV_REG_X3,
    UC_RISCV_REG_X4,
    UC_RISCV_REG_X5,
    UC_RISCV_REG_X6,
    UC_RISCV_REG_X7,
    UC_RISCV_REG_X8,
    UC_RISCV_REG_X9,
    UC_RISCV_REG_X10,
    UC_RISCV_REG_X11,
    UC_RISCV_REG_X12,
    UC_RISCV_REG_X13,
    UC_RISCV_REG_X14,
    UC_RISCV_REG_X15,
    UC_RISCV_REG_X16,
    UC_RISCV_REG_X17,
    UC_RISCV_REG_X18,
    UC_RISCV_REG_X19,
    UC_RISCV_REG_X20,
    UC_RISCV_REG_X21,
    UC_RISCV_REG_X22,
    UC_RISCV_REG_X23,
    UC_RISCV_REG_X24,
    UC_RISCV_REG_X25,
    UC_RISCV_REG_X26,
    UC_RISCV_REG_X27,
    UC_RISCV_REG_X28,
    UC_RISCV_REG_X29,
    UC_RISCV_REG_X30,
    UC_RISCV_REG_X31,

    //> RISCV CSR
    UC_RISCV_REG_USTATUS,
    UC_RISCV_REG_UIE,
    UC_RISCV_REG_UTVEC,
    UC_RISCV_REG_USCRATCH,
    UC_RISCV_REG_UEPC,
    UC_RISCV_REG_UCAUSE,
    UC_RISCV_REG_UTVAL,
    UC_RISCV_REG_UIP,
    UC_RISCV_REG_FFLAGS,
    UC_RISCV_REG_FRM,
    UC_RISCV_REG_FCSR,
    UC_RISCV_REG_CYCLE,
    UC_RISCV_REG_TIME,
    UC_RISCV_REG_INSTRET,
    UC_RISCV_REG_HPMCOUNTER3,
    UC_RISCV_REG_HPMCOUNTER4,
    UC_RISCV_REG_HPMCOUNTER5,
    UC_RISCV_REG_HPMCOUNTER6,
    UC_RISCV_REG_HPMCOUNTER7,
    UC_RISCV_REG_HPMCOUNTER8,
    UC_RISCV_REG_HPMCOUNTER9,
    UC_RISCV_REG_HPMCOUNTER10,
    UC_RISCV_REG_HPMCOUNTER11,
    UC_RISCV_REG_HPMCOUNTER12,
    UC_RISCV_REG_HPMCOUNTER13,
    UC_RISCV_REG_HPMCOUNTER14,
    UC_RISCV_REG_HPMCOUNTER15,
    UC_RISCV_REG_HPMCOUNTER16,
    UC_RISCV_REG_HPMCOUNTER17,
    UC_RISCV_REG_HPMCOUNTER18,
    UC_RISCV_REG_HPMCOUNTER19,
    UC_RISCV_REG_HPMCOUNTER20,
    UC_RISCV_REG_HPMCOUNTER21,
    UC_RISCV_REG_HPMCOUNTER22,
    UC_RISCV_REG_HPMCOUNTER23,
    UC_RISCV_REG_HPMCOUNTER24,
    UC_RISCV_REG_HPMCOUNTER25,
    UC_RISCV_REG_HPMCOUNTER26,
    UC_RISCV_REG_HPMCOUNTER27,
    UC_RISCV_REG_HPMCOUNTER28,
    UC_RISCV_REG_HPMCOUNTER29,
    UC_RISCV_REG_HPMCOUNTER30,
    UC_RISCV_REG_HPMCOUNTER31,
    UC_RISCV_REG_CYCLEH,
    UC_RISCV_REG_TIMEH,
    UC_RISCV_REG_INSTRETH,
    UC_RISCV_REG_HPMCOUNTER3H,
    UC_RISCV_REG_HPMCOUNTER4H,
    UC_RISCV_REG_HPMCOUNTER5H,
    UC_RISCV_REG_HPMCOUNTER6H,
    UC_RISCV_REG_HPMCOUNTER7H,
    UC_RISCV_REG_HPMCOUNTER8H,
    UC_RISCV_REG_HPMCOUNTER9H,
    UC_RISCV_REG_HPMCOUNTER10H,
    UC_RISCV_REG_HPMCOUNTER11H,
    UC_RISCV_REG_HPMCOUNTER12H,
    UC_RISCV_REG_HPMCOUNTER13H,
    UC_RISCV_REG_HPMCOUNTER14H,
    UC_RISCV_REG_HPMCOUNTER15H,
    UC_RISCV_REG_HPMCOUNTER16H,
    UC_RISCV_REG_HPMCOUNTER17H,
    UC_RISCV_REG_HPMCOUNTER18H,
    UC_RISCV_REG_HPMCOUNTER19H,
    UC_RISCV_REG_HPMCOUNTER20H,
    UC_RISCV_REG_HPMCOUNTER21H,
    UC_RISCV_REG_HPMCOUNTER22H,
    UC_RISCV_REG_HPMCOUNTER23H,
    UC_RISCV_REG_HPMCOUNTER24H,
    UC_RISCV_REG_HPMCOUNTER25H,
    UC_RISCV_REG_HPMCOUNTER26H,
    UC_RISCV_REG_HPMCOUNTER27H,
    UC_RISCV_REG_HPMCOUNTER28H,
    UC_RISCV_REG_HPMCOUNTER29H,
    UC_RISCV_REG_HPMCOUNTER30H,
    UC_RISCV_REG_HPMCOUNTER31H,
    UC_RISCV_REG_MCYCLE,
    UC_RISCV_REG_MINSTRET,
    UC_RISCV_REG_MCYCLEH,
    UC_RISCV_REG_MINSTRETH,
    UC_RISCV_REG_MVENDORID,
    UC_RISCV_REG_MARCHID,
    UC_RISCV_REG_MIMPID,
    UC_RISCV_REG_MHARTID,
    UC_RISCV_REG_MSTATUS,
    UC_RISCV_REG_MISA,
    UC_RISCV_REG_MEDELEG,
    UC_RISCV_REG_MIDELEG,
    UC_RISCV_REG_MIE,
    UC_RISCV_REG_MTVEC,
    UC_RISCV_REG_MCOUNTEREN,
    UC_RISCV_REG_MSTATUSH,
    UC_RISCV_REG_MUCOUNTEREN,
    UC_RISCV_REG_MSCOUNTEREN,
    UC_RISCV_REG_MHCOUNTEREN,
    UC_RISCV_REG_MSCRATCH,
    UC_RISCV_REG_MEPC,
    UC_RISCV_REG_MCAUSE,
    UC_RISCV_REG_MTVAL,
    UC_RISCV_REG_MIP,
    UC_RISCV_REG_MBADADDR,
    UC_RISCV_REG_SSTATUS,
    UC_RISCV_REG_SEDELEG,
    UC_RISCV_REG_SIDELEG,
    UC_RISCV_REG_SIE,
    UC_RISCV_REG_STVEC,
    UC_RISCV_REG_SCOUNTEREN,
    UC_RISCV_REG_SSCRATCH,
    UC_RISCV_REG_SEPC,
    UC_RISCV_REG_SCAUSE,
    UC_RISCV_REG_STVAL,
    UC_RISCV_REG_SIP,
    UC_RISCV_REG_SBADADDR,
    UC_RISCV_REG_SPTBR,
    UC_RISCV_REG_SATP,
    UC_RISCV_REG_HSTATUS,
    UC_RISCV_REG_HEDELEG,
    UC_RISCV_REG_HIDELEG,
    UC_RISCV_REG_HIE,
    UC_RISCV_REG_HCOUNTEREN,
    UC_RISCV_REG_HTVAL,
    UC_RISCV_REG_HIP,
    UC_RISCV_REG_HTINST,
    UC_RISCV_REG_HGATP,
    UC_RISCV_REG_HTIMEDELTA,
    UC_RISCV_REG_HTIMEDELTAH,

    //> Floating-point registers
    UC_RISCV_REG_F0,  // "ft0"
    UC_RISCV_REG_F1,  // "ft1"
    UC_RISCV_REG_F2,  // "ft2"
    UC_RISCV_REG_F3,  // "ft3"
    UC_RISCV_REG_F4,  // "ft4"
    UC_RISCV_REG_F5,  // "ft5"
    UC_RISCV_REG_F6,  // "ft6"
    UC_RISCV_REG_F7,  // "ft7"
    UC_RISCV_REG_F8,  // "fs0"
    UC_RISCV_REG_F9,  // "fs1"
    UC_RISCV_REG_F10, // "fa0"
    UC_RISCV_REG_F11, // "fa1"
    UC_RISCV_REG_F12, // "fa2"
    UC_RISCV_REG_F13, // "fa3"
    UC_RISCV_REG_F14, // "fa4"
    UC_RISCV_REG_F15, // "fa5"
    UC_RISCV_REG_F16, // "fa6"
    UC_RISCV_REG_F17, // "fa7"
    UC_RISCV_REG_F18, // "fs2"
    UC_RISCV_REG_F19, // "fs3"
    UC_RISCV_REG_F20, // "fs4"
    UC_RISCV_REG_F21, // "fs5"
    UC_RISCV_REG_F22, // "fs6"
    UC_RISCV_REG_F23, // "fs7"
    UC_RISCV_REG_F24, // "fs8"
    UC_RISCV_REG_F25, // "fs9"
    UC_RISCV_REG_F26, // "fs10"
    UC_RISCV_REG_F27, // "fs11"
    UC_RISCV_REG_F28, // "ft8"
    UC_RISCV_REG_F29, // "ft9"
    UC_RISCV_REG_F30, // "ft10"
    UC_RISCV_REG_F31, // "ft11"

    UC_RISCV_REG_PC, // PC register

    UC_RISCV_REG_PRIV, // Virtual register for the current privilege level

    UC_RISCV_REG_ENDING, // <-- mark the end of the list or registers

    //> Alias registers
    UC_RISCV_REG_ZERO = UC_RISCV_REG_X0, // "zero"
    UC_RISCV_REG_RA = UC_RISCV_REG_X1,   // "ra"
    UC_RISCV_REG_SP = UC_RISCV_REG_X2,   // "sp"
    UC_RISCV_REG_GP = UC_RISCV_REG_X3,   // "gp"
    UC_RISCV_REG_TP = UC_RISCV_REG_X4,   // "tp"
    UC_RISCV_REG_T0 = UC_RISCV_REG_X5,   // "t0"
    UC_RISCV_REG_T1 = UC_RISCV_REG_X6,   // "t1"
    UC_RISCV_REG_T2 = UC_RISCV_REG_X7,   // "t2"
    UC_RISCV_REG_S0 = UC_RISCV_REG_X8,   // "s0"
    UC_RISCV_REG_FP = UC_RISCV_REG_X8,   // "fp"
    UC_RISCV_REG_S1 = UC_RISCV_REG_X9,   // "s1"
    UC_RISCV_REG_A0 = UC_RISCV_REG_X10,  // "a0"
    UC_RISCV_REG_A1 = UC_RISCV_REG_X11,  // "a1"
    UC_RISCV_REG_A2 = UC_RISCV_REG_X12,  // "a2"
    UC_RISCV_REG_A3 = UC_RISCV_REG_X13,  // "a3"
    UC_RISCV_REG_A4 = UC_RISCV_REG_X14,  // "a4"
    UC_RISCV_REG_A5 = UC_RISCV_REG_X15,  // "a5"
    UC_RISCV_REG_A6 = UC_RISCV_REG_X16,  // "a6"
    UC_RISCV_REG_A7 = UC_RISCV_REG_X17,  // "a7"
    UC_RISCV_REG_S2 = UC_RISCV_REG_X18,  // "s2"
    UC_RISCV_REG_S3 = UC_RISCV_REG_X19,  // "s3"
    UC_RISCV_REG_S4 = UC_RISCV_REG_X20,  // "s4"
    UC_RISCV_REG_S5 = UC_RISCV_REG_X21,  // "s5"
    UC_RISCV_REG_S6 = UC_RISCV_REG_X22,  // "s6"
    UC_RISCV_REG_S7 = UC_RISCV_REG_X23,  // "s7"
    UC_RISCV_REG_S8 = UC_RISCV_REG_X24,  // "s8"
    UC_RISCV_REG_S9 = UC_RISCV_REG_X25,  // "s9"
    UC_RISCV_REG_S10 = UC_RISCV_REG_X26, // "s10"
    UC_RISCV_REG_S11 = UC_RISCV_REG_X27, // "s11"
    UC_RISCV_REG_T3 = UC_RISCV_REG_X28,  // "t3"
    UC_RISCV_REG_T4 = UC_RISCV_REG_X29,  // "t4"
    UC_RISCV_REG_T5 = UC_RISCV_REG_X30,  // "t5"
    UC_RISCV_REG_T6 = UC_RISCV_REG_X31,  // "t6"

    UC_RISCV_REG_FT0 = UC_RISCV_REG_F0, // "ft0"
    UC_RISCV_REG_FT1 = UC_RISCV_REG_F1, // "ft1"
    UC_RISCV_REG_FT2 = UC_RISCV_REG_F2, // "ft2"
    UC_RISCV_REG_FT3 = UC_RISCV_REG_F3, // "ft3"
    UC_RISCV_REG_FT4 = UC_RISCV_REG_F4, // "ft4"
    UC_RISCV_REG_FT5 = UC_RISCV_REG_F5, // "ft5"
    UC_RISCV_REG_FT6 = UC_RISCV_REG_F6, // "ft6"
    UC_RISCV_REG_FT7 = UC_RISCV_REG_F7, // "ft7"
    UC_RISCV_REG_FS0 = UC_RISCV_REG_F8, // "fs0"
    UC_RISCV_REG_FS1 = UC_RISCV_REG_F9, // "fs1"

    UC_RISCV_REG_FA0 = UC_RISCV_REG_F10,  // "fa0"
    UC_RISCV_REG_FA1 = UC_RISCV_REG_F11,  // "fa1"
    UC_RISCV_REG_FA2 = UC_RISCV_REG_F12,  // "fa2"
    UC_RISCV_REG_FA3 = UC_RISCV_REG_F13,  // "fa3"
    UC_RISCV_REG_FA4 = UC_RISCV_REG_F14,  // "fa4"
    UC_RISCV_REG_FA5 = UC_RISCV_REG_F15,  // "fa5"
    UC_RISCV_REG_FA6 = UC_RISCV_REG_F16,  // "fa6"
    UC_RISCV_REG_FA7 = UC_RISCV_REG_F17,  // "fa7"
    UC_RISCV_REG_FS2 = UC_RISCV_REG_F18,  // "fs2"
    UC_RISCV_REG_FS3 = UC_RISCV_REG_F19,  // "fs3"
    UC_RISCV_REG_FS4 = UC_RISCV_REG_F20,  // "fs4"
    UC_RISCV_REG_FS5 = UC_RISCV_REG_F21,  // "fs5"
    UC_RISCV_REG_FS6 = UC_RISCV_REG_F22,  // "fs6"
    UC_RISCV_REG_FS7 = UC_RISCV_REG_F23,  // "fs7"
    UC_RISCV_REG_FS8 = UC_RISCV_REG_F24,  // "fs8"
    UC_RISCV_REG_FS9 = UC_RISCV_REG_F25,  // "fs9"
    UC_RISCV_REG_FS10 = UC_RISCV_REG_F26, // "fs10"
    UC_RISCV_REG_FS11 = UC_RISCV_REG_F27, // "fs11"
    UC_RISCV_REG_FT8 = UC_RISCV_REG_F28,  // "ft8"
    UC_RISCV_REG_FT9 = UC_RISCV_REG_F29,  // "ft9"
    UC_RISCV_REG_FT10 = UC_RISCV_REG_F30, // "ft10"
    UC_RISCV_REG_FT11 = UC_RISCV_REG_F31, // "ft11"
} uc_riscv_reg;

#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/include/unicorn/unicorn/s390x.h`:

```h
/* Unicorn Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2015-2021 */

#ifndef UNICORN_S390X_H
#define UNICORN_S390X_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _MSC_VER
#pragma warning(disable : 4201)
#endif

//> S390X CPU
typedef enum uc_cpu_s390x {
    UC_CPU_S390X_Z900 = 0,
    UC_CPU_S390X_Z900_2,
    UC_CPU_S390X_Z900_3,
    UC_CPU_S390X_Z800,
    UC_CPU_S390X_Z990,
    UC_CPU_S390X_Z990_2,
    UC_CPU_S390X_Z990_3,
    UC_CPU_S390X_Z890,
    UC_CPU_S390X_Z990_4,
    UC_CPU_S390X_Z890_2,
    UC_CPU_S390X_Z990_5,
    UC_CPU_S390X_Z890_3,
    UC_CPU_S390X_Z9EC,
    UC_CPU_S390X_Z9EC_2,
    UC_CPU_S390X_Z9BC,
    UC_CPU_S390X_Z9EC_3,
    UC_CPU_S390X_Z9BC_2,
    UC_CPU_S390X_Z10EC,
    UC_CPU_S390X_Z10EC_2,
    UC_CPU_S390X_Z10BC,
    UC_CPU_S390X_Z10EC_3,
    UC_CPU_S390X_Z10BC_2,
    UC_CPU_S390X_Z196,
    UC_CPU_S390X_Z196_2,
    UC_CPU_S390X_Z114,
    UC_CPU_S390X_ZEC12,
    UC_CPU_S390X_ZEC12_2,
    UC_CPU_S390X_ZBC12,
    UC_CPU_S390X_Z13,
    UC_CPU_S390X_Z13_2,
    UC_CPU_S390X_Z13S,
    UC_CPU_S390X_Z14,
    UC_CPU_S390X_Z14_2,
    UC_CPU_S390X_Z14ZR1,
    UC_CPU_S390X_GEN15A,
    UC_CPU_S390X_GEN15B,
    UC_CPU_S390X_QEMU,
    UC_CPU_S390X_MAX,

    UC_CPU_S390X_ENDING
} uc_cpu_s390x;

//> S390X registers
typedef enum uc_s390x_reg {
    UC_S390X_REG_INVALID = 0,
    //> General purpose registers
    UC_S390X_REG_R0,
    UC_S390X_REG_R1,
    UC_S390X_REG_R2,
    UC_S390X_REG_R3,
    UC_S390X_REG_R4,
    UC_S390X_REG_R5,
    UC_S390X_REG_R6,
    UC_S390X_REG_R7,
    UC_S390X_REG_R8,
    UC_S390X_REG_R9,
    UC_S390X_REG_R10,
    UC_S390X_REG_R11,
    UC_S390X_REG_R12,
    UC_S390X_REG_R13,
    UC_S390X_REG_R14,
    UC_S390X_REG_R15,

    //> Floating point registers
    UC_S390X_REG_F0,
    UC_S390X_REG_F1,
    UC_S390X_REG_F2,
    UC_S390X_REG_F3,
    UC_S390X_REG_F4,
    UC_S390X_REG_F5,
    UC_S390X_REG_F6,
    UC_S390X_REG_F7,
    UC_S390X_REG_F8,
    UC_S390X_REG_F9,
    UC_S390X_REG_F10,
    UC_S390X_REG_F11,
    UC_S390X_REG_F12,
    UC_S390X_REG_F13,
    UC_S390X_REG_F14,
    UC_S390X_REG_F15,
    //> Not real registers, low half of vr16-vr31
    UC_S390X_REG_F16,
    UC_S390X_REG_F17,
    UC_S390X_REG_F18,
    UC_S390X_REG_F19,
    UC_S390X_REG_F20,
    UC_S390X_REG_F21,
    UC_S390X_REG_F22,
    UC_S390X_REG_F23,
    UC_S390X_REG_F24,
    UC_S390X_REG_F25,
    UC_S390X_REG_F26,
    UC_S390X_REG_F27,
    UC_S390X_REG_F28,
    UC_S390X_REG_F29,
    UC_S390X_REG_F30,
    UC_S390X_REG_F31,

    //> Access registers
    UC_S390X_REG_A0,
    UC_S390X_REG_A1,
    UC_S390X_REG_A2,
    UC_S390X_REG_A3,
    UC_S390X_REG_A4,
    UC_S390X_REG_A5,
    UC_S390X_REG_A6,
    UC_S390X_REG_A7,
    UC_S390X_REG_A8,
    UC_S390X_REG_A9,
    UC_S390X_REG_A10,
    UC_S390X_REG_A11,
    UC_S390X_REG_A12,
    UC_S390X_REG_A13,
    UC_S390X_REG_A14,
    UC_S390X_REG_A15,

    UC_S390X_REG_PC, // PC register
    UC_S390X_REG_PSWM,

    //> pseudo registers, high half of vr16-vr31
    UC_S390X_REG_F0_HI,
    UC_S390X_REG_F1_HI,
    UC_S390X_REG_F2_HI,
    UC_S390X_REG_F3_HI,
    UC_S390X_REG_F4_HI,
    UC_S390X_REG_F5_HI,
    UC_S390X_REG_F6_HI,
    UC_S390X_REG_F7_HI,
    UC_S390X_REG_F8_HI,
    UC_S390X_REG_F9_HI,
    UC_S390X_REG_F10_HI,
    UC_S390X_REG_F11_HI,
    UC_S390X_REG_F12_HI,
    UC_S390X_REG_F13_HI,
    UC_S390X_REG_F14_HI,
    UC_S390X_REG_F15_HI,
    UC_S390X_REG_F16_HI,
    UC_S390X_REG_F17_HI,
    UC_S390X_REG_F18_HI,
    UC_S390X_REG_F19_HI,
    UC_S390X_REG_F20_HI,
    UC_S390X_REG_F21_HI,
    UC_S390X_REG_F22_HI,
    UC_S390X_REG_F23_HI,
    UC_S390X_REG_F24_HI,
    UC_S390X_REG_F25_HI,
    UC_S390X_REG_F26_HI,
    UC_S390X_REG_F27_HI,
    UC_S390X_REG_F28_HI,
    UC_S390X_REG_F29_HI,
    UC_S390X_REG_F30_HI,
    UC_S390X_REG_F31_HI,

    //> float control register
    UC_S390X_REG_FPC,

    //> control registers
    UC_S390X_REG_CR0,
    UC_S390X_REG_CR1,
    UC_S390X_REG_CR2,
    UC_S390X_REG_CR3,
    UC_S390X_REG_CR4,
    UC_S390X_REG_CR5,
    UC_S390X_REG_CR6,
    UC_S390X_REG_CR7,
    UC_S390X_REG_CR8,
    UC_S390X_REG_CR9,
    UC_S390X_REG_CR10,
    UC_S390X_REG_CR11,
    UC_S390X_REG_CR12,
    UC_S390X_REG_CR13,
    UC_S390X_REG_CR14,
    UC_S390X_REG_CR15,

    UC_S390X_REG_ENDING, // <-- mark the end of the list or registers

    //> Alias registers
} uc_s390x_reg;

#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/include/unicorn/unicorn/sparc.h`:

```h
/* Unicorn Emulator Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2014-2017 */
/* This file is released under LGPL2.
   See COPYING.LGPL2 in root directory for more details
*/

#ifndef UNICORN_SPARC_H
#define UNICORN_SPARC_H

#ifdef __cplusplus
extern "C" {
#endif

// GCC SPARC toolchain has a default macro called "sparc" which breaks
// compilation
#undef sparc

#ifdef _MSC_VER
#pragma warning(disable : 4201)
#endif

//> SPARC32 CPU
typedef enum uc_cpu_sparc32 {
    UC_CPU_SPARC32_FUJITSU_MB86904 = 0,
    UC_CPU_SPARC32_FUJITSU_MB86907,
    UC_CPU_SPARC32_TI_MICROSPARC_I,
    UC_CPU_SPARC32_TI_MICROSPARC_II,
    UC_CPU_SPARC32_TI_MICROSPARC_IIEP,
    UC_CPU_SPARC32_TI_SUPERSPARC_40,
    UC_CPU_SPARC32_TI_SUPERSPARC_50,
    UC_CPU_SPARC32_TI_SUPERSPARC_51,
    UC_CPU_SPARC32_TI_SUPERSPARC_60,
    UC_CPU_SPARC32_TI_SUPERSPARC_61,
    UC_CPU_SPARC32_TI_SUPERSPARC_II,
    UC_CPU_SPARC32_LEON2,
    UC_CPU_SPARC32_LEON3,

    UC_CPU_SPARC32_ENDING
} uc_cpu_sparc32;

//> SPARC64 CPU
typedef enum uc_cpu_sparc64 {
    UC_CPU_SPARC64_FUJITSU = 0,
    UC_CPU_SPARC64_FUJITSU_III,
    UC_CPU_SPARC64_FUJITSU_IV,
    UC_CPU_SPARC64_FUJITSU_V,
    UC_CPU_SPARC64_TI_ULTRASPARC_I,
    UC_CPU_SPARC64_TI_ULTRASPARC_II,
    UC_CPU_SPARC64_TI_ULTRASPARC_III,
    UC_CPU_SPARC64_TI_ULTRASPARC_IIE,
    UC_CPU_SPARC64_SUN_ULTRASPARC_III,
    UC_CPU_SPARC64_SUN_ULTRASPARC_III_CU,
    UC_CPU_SPARC64_SUN_ULTRASPARC_IIII,
    UC_CPU_SPARC64_SUN_ULTRASPARC_IV,
    UC_CPU_SPARC64_SUN_ULTRASPARC_IV_PLUS,
    UC_CPU_SPARC64_SUN_ULTRASPARC_IIII_PLUS,
    UC_CPU_SPARC64_SUN_ULTRASPARC_T1,
    UC_CPU_SPARC64_SUN_ULTRASPARC_T2,
    UC_CPU_SPARC64_NEC_ULTRASPARC_I,

    UC_CPU_SPARC64_ENDING
} uc_cpu_sparc64;

//> SPARC registers
typedef enum uc_sparc_reg {
    UC_SPARC_REG_INVALID = 0,

    UC_SPARC_REG_F0,
    UC_SPARC_REG_F1,
    UC_SPARC_REG_F2,
    UC_SPARC_REG_F3,
    UC_SPARC_REG_F4,
    UC_SPARC_REG_F5,
    UC_SPARC_REG_F6,
    UC_SPARC_REG_F7,
    UC_SPARC_REG_F8,
    UC_SPARC_REG_F9,
    UC_SPARC_REG_F10,
    UC_SPARC_REG_F11,
    UC_SPARC_REG_F12,
    UC_SPARC_REG_F13,
    UC_SPARC_REG_F14,
    UC_SPARC_REG_F15,
    UC_SPARC_REG_F16,
    UC_SPARC_REG_F17,
    UC_SPARC_REG_F18,
    UC_SPARC_REG_F19,
    UC_SPARC_REG_F20,
    UC_SPARC_REG_F21,
    UC_SPARC_REG_F22,
    UC_SPARC_REG_F23,
    UC_SPARC_REG_F24,
    UC_SPARC_REG_F25,
    UC_SPARC_REG_F26,
    UC_SPARC_REG_F27,
    UC_SPARC_REG_F28,
    UC_SPARC_REG_F29,
    UC_SPARC_REG_F30,
    UC_SPARC_REG_F31,
    UC_SPARC_REG_F32,
    UC_SPARC_REG_F34,
    UC_SPARC_REG_F36,
    UC_SPARC_REG_F38,
    UC_SPARC_REG_F40,
    UC_SPARC_REG_F42,
    UC_SPARC_REG_F44,
    UC_SPARC_REG_F46,
    UC_SPARC_REG_F48,
    UC_SPARC_REG_F50,
    UC_SPARC_REG_F52,
    UC_SPARC_REG_F54,
    UC_SPARC_REG_F56,
    UC_SPARC_REG_F58,
    UC_SPARC_REG_F60,
    UC_SPARC_REG_F62,
    UC_SPARC_REG_FCC0, // Floating condition codes
    UC_SPARC_REG_FCC1,
    UC_SPARC_REG_FCC2,
    UC_SPARC_REG_FCC3,
    UC_SPARC_REG_G0,
    UC_SPARC_REG_G1,
    UC_SPARC_REG_G2,
    UC_SPARC_REG_G3,
    UC_SPARC_REG_G4,
    UC_SPARC_REG_G5,
    UC_SPARC_REG_G6,
    UC_SPARC_REG_G7,
    UC_SPARC_REG_I0,
    UC_SPARC_REG_I1,
    UC_SPARC_REG_I2,
    UC_SPARC_REG_I3,
    UC_SPARC_REG_I4,
    UC_SPARC_REG_I5,
    UC_SPARC_REG_FP,
    UC_SPARC_REG_I7,
    UC_SPARC_REG_ICC, // Integer condition codes
    UC_SPARC_REG_L0,
    UC_SPARC_REG_L1,
    UC_SPARC_REG_L2,
    UC_SPARC_REG_L3,
    UC_SPARC_REG_L4,
    UC_SPARC_REG_L5,
    UC_SPARC_REG_L6,
    UC_SPARC_REG_L7,
    UC_SPARC_REG_O0,
    UC_SPARC_REG_O1,
    UC_SPARC_REG_O2,
    UC_SPARC_REG_O3,
    UC_SPARC_REG_O4,
    UC_SPARC_REG_O5,
    UC_SPARC_REG_SP,
    UC_SPARC_REG_O7,
    UC_SPARC_REG_Y,

    // special register
    UC_SPARC_REG_XCC,

    // pseudo register
    UC_SPARC_REG_PC, // program counter register

    UC_SPARC_REG_ENDING, // <-- mark the end of the list of registers

    // extras
    UC_SPARC_REG_O6 = UC_SPARC_REG_SP,
    UC_SPARC_REG_I6 = UC_SPARC_REG_FP,
} uc_sparc_reg;

#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/include/unicorn/unicorn/tricore.h`:

```h
/* This file is released under LGPL2.
   See COPYING.LGPL2 in root directory for more details
*/

/*
   Created for Unicorn Engine by Eric Poole <eric.poole@aptiv.com>, 2022
   Copyright 2022 Aptiv
*/

#ifndef UNICORN_TRICORE_H
#define UNICORN_TRICORE_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _MSC_VER
#pragma warning(disable : 4201)
#endif

//> TRICORE CPU
typedef enum uc_cpu_tricore {
    UC_CPU_TRICORE_TC1796,
    UC_CPU_TRICORE_TC1797,
    UC_CPU_TRICORE_TC27X,

    UC_CPU_TRICORE_ENDING
} uc_cpu_tricore;

//> TRICORE registers
typedef enum uc_tricore_reg {
    UC_TRICORE_REG_INVALID = 0,

    // General purpose registers (GPR)
    // Address GPR
    UC_TRICORE_REG_A0,
    UC_TRICORE_REG_A1,
    UC_TRICORE_REG_A2,
    UC_TRICORE_REG_A3,
    UC_TRICORE_REG_A4,
    UC_TRICORE_REG_A5,
    UC_TRICORE_REG_A6,
    UC_TRICORE_REG_A7,
    UC_TRICORE_REG_A8,
    UC_TRICORE_REG_A9,
    UC_TRICORE_REG_A10,
    UC_TRICORE_REG_A11,
    UC_TRICORE_REG_A12,
    UC_TRICORE_REG_A13,
    UC_TRICORE_REG_A14,
    UC_TRICORE_REG_A15,
    // Data GPR
    UC_TRICORE_REG_D0,
    UC_TRICORE_REG_D1,
    UC_TRICORE_REG_D2,
    UC_TRICORE_REG_D3,
    UC_TRICORE_REG_D4,
    UC_TRICORE_REG_D5,
    UC_TRICORE_REG_D6,
    UC_TRICORE_REG_D7,
    UC_TRICORE_REG_D8,
    UC_TRICORE_REG_D9,
    UC_TRICORE_REG_D10,
    UC_TRICORE_REG_D11,
    UC_TRICORE_REG_D12,
    UC_TRICORE_REG_D13,
    UC_TRICORE_REG_D14,
    UC_TRICORE_REG_D15,

    /* CSFR Register */
    UC_TRICORE_REG_PCXI,

    UC_TRICORE_REG_PSW,

    /* PSW flag cache for faster execution */
    UC_TRICORE_REG_PSW_USB_C,
    UC_TRICORE_REG_PSW_USB_V,
    UC_TRICORE_REG_PSW_USB_SV,
    UC_TRICORE_REG_PSW_USB_AV,
    UC_TRICORE_REG_PSW_USB_SAV,

    UC_TRICORE_REG_PC,
    UC_TRICORE_REG_SYSCON,
    UC_TRICORE_REG_CPU_ID,
    UC_TRICORE_REG_BIV,
    UC_TRICORE_REG_BTV,
    UC_TRICORE_REG_ISP,
    UC_TRICORE_REG_ICR,
    UC_TRICORE_REG_FCX,
    UC_TRICORE_REG_LCX,
    UC_TRICORE_REG_COMPAT,

    UC_TRICORE_REG_DPR0_U,
    UC_TRICORE_REG_DPR1_U,
    UC_TRICORE_REG_DPR2_U,
    UC_TRICORE_REG_DPR3_U,
    UC_TRICORE_REG_DPR0_L,
    UC_TRICORE_REG_DPR1_L,
    UC_TRICORE_REG_DPR2_L,
    UC_TRICORE_REG_DPR3_L,

    UC_TRICORE_REG_CPR0_U,
    UC_TRICORE_REG_CPR1_U,
    UC_TRICORE_REG_CPR2_U,
    UC_TRICORE_REG_CPR3_U,
    UC_TRICORE_REG_CPR0_L,
    UC_TRICORE_REG_CPR1_L,
    UC_TRICORE_REG_CPR2_L,
    UC_TRICORE_REG_CPR3_L,

    UC_TRICORE_REG_DPM0,
    UC_TRICORE_REG_DPM1,
    UC_TRICORE_REG_DPM2,
    UC_TRICORE_REG_DPM3,

    UC_TRICORE_REG_CPM0,
    UC_TRICORE_REG_CPM1,
    UC_TRICORE_REG_CPM2,
    UC_TRICORE_REG_CPM3,

    /* Memory Management Registers */
    UC_TRICORE_REG_MMU_CON,
    UC_TRICORE_REG_MMU_ASI,
    UC_TRICORE_REG_MMU_TVA,
    UC_TRICORE_REG_MMU_TPA,
    UC_TRICORE_REG_MMU_TPX,
    UC_TRICORE_REG_MMU_TFA,

    // 1.3.1 Only
    UC_TRICORE_REG_BMACON,
    UC_TRICORE_REG_SMACON,
    UC_TRICORE_REG_DIEAR,
    UC_TRICORE_REG_DIETR,
    UC_TRICORE_REG_CCDIER,
    UC_TRICORE_REG_MIECON,
    UC_TRICORE_REG_PIEAR,
    UC_TRICORE_REG_PIETR,
    UC_TRICORE_REG_CCPIER,

    /* Debug Registers */
    UC_TRICORE_REG_DBGSR,
    UC_TRICORE_REG_EXEVT,
    UC_TRICORE_REG_CREVT,
    UC_TRICORE_REG_SWEVT,
    UC_TRICORE_REG_TR0EVT,
    UC_TRICORE_REG_TR1EVT,
    UC_TRICORE_REG_DMS,
    UC_TRICORE_REG_DCX,
    UC_TRICORE_REG_DBGTCR,
    UC_TRICORE_REG_CCTRL,
    UC_TRICORE_REG_CCNT,
    UC_TRICORE_REG_ICNT,
    UC_TRICORE_REG_M1CNT,
    UC_TRICORE_REG_M2CNT,
    UC_TRICORE_REG_M3CNT,

    UC_TRICORE_REG_ENDING, // <-- mark the end of the list of registers

    // alias registers
    UC_TRICORE_REG_GA0 = UC_TRICORE_REG_A0,
    UC_TRICORE_REG_GA1 = UC_TRICORE_REG_A1,
    UC_TRICORE_REG_GA8 = UC_TRICORE_REG_A8,
    UC_TRICORE_REG_GA9 = UC_TRICORE_REG_A9,
    UC_TRICORE_REG_SP = UC_TRICORE_REG_A10,
    UC_TRICORE_REG_LR = UC_TRICORE_REG_A11,
    UC_TRICORE_REG_IA = UC_TRICORE_REG_A15,
    UC_TRICORE_REG_ID = UC_TRICORE_REG_D15,
} uc_tricore_reg;

#ifdef __cplusplus
}
#endif

#endif
```

`KDemu/include/unicorn/unicorn/unicorn.h`:

```h
/* Unicorn Emulator Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2015-2017 */
/* This file is released under LGPL2.
   See COPYING.LGPL2 in root directory for more details
*/

#ifndef UNICORN_ENGINE_H
#define UNICORN_ENGINE_H

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"
#include <stdarg.h>

#if defined(UNICORN_HAS_OSXKERNEL)
#include <libkern/libkern.h>
#else
#include <stdlib.h>
#include <stdio.h>
#endif

struct uc_struct;
typedef struct uc_struct uc_engine;

typedef size_t uc_hook;

#include "m68k.h"
#include "x86.h"
#include "arm.h"
#include "arm64.h"
#include "mips.h"
#include "sparc.h"
#include "ppc.h"
#include "riscv.h"
#include "s390x.h"
#include "tricore.h"

#ifdef __GNUC__
#define DEFAULT_VISIBILITY __attribute__((visibility("default")))
#else
#define DEFAULT_VISIBILITY
#endif

#ifdef _MSC_VER
#pragma warning(disable : 4201)
#pragma warning(disable : 4100)
#ifdef UNICORN_SHARED
#define UNICORN_EXPORT __declspec(dllexport)
#else // defined(UNICORN_STATIC)
#define UNICORN_EXPORT
#endif
#else
#ifdef __GNUC__
#define UNICORN_EXPORT __attribute__((visibility("default")))
#else
#define UNICORN_EXPORT
#endif
#endif

#ifdef __GNUC__
#define UNICORN_DEPRECATED __attribute__((deprecated))
#elif defined(_MSC_VER)
#define UNICORN_DEPRECATED __declspec(deprecated)
#else
#pragma message(                                                               \
    "WARNING: You need to implement UNICORN_DEPRECATED for this compiler")
#define UNICORN_DEPRECATED
#endif

// Unicorn API version
#define UC_API_MAJOR 2
#define UC_API_MINOR 1
#define UC_API_PATCH 3
// Release candidate version, 255 means the official release.
#define UC_API_EXTRA 255

// Unicorn package version
#define UC_VERSION_MAJOR UC_API_MAJOR
#define UC_VERSION_MINOR UC_API_MINOR
#define UC_VERSION_PATCH UC_API_PATCH
#define UC_VERSION_EXTRA UC_API_EXTRA

/*
  Macro to create combined version which can be compared to
  result of uc_version() API.
*/
#define UC_MAKE_VERSION(major, minor) (((major) << 24) + ((minor) << 16))

// Scales to calculate timeout on microsecond unit
// 1 second = 1000,000 microseconds
#define UC_SECOND_SCALE 1000000
// 1 milisecond = 1000 nanoseconds
#define UC_MILISECOND_SCALE 1000

// Architecture type
typedef enum uc_arch {
    UC_ARCH_ARM = 1, // ARM architecture (including Thumb, Thumb-2)
    UC_ARCH_ARM64,   // ARM-64, also called AArch64
    UC_ARCH_MIPS,    // Mips architecture
    UC_ARCH_X86,     // X86 architecture (including x86 & x86-64)
    UC_ARCH_PPC,     // PowerPC architecture
    UC_ARCH_SPARC,   // Sparc architecture
    UC_ARCH_M68K,    // M68K architecture
    UC_ARCH_RISCV,   // RISCV architecture
    UC_ARCH_S390X,   // S390X architecture
    UC_ARCH_TRICORE, // TriCore architecture
    UC_ARCH_MAX,
} uc_arch;

// Mode type
typedef enum uc_mode {
    UC_MODE_LITTLE_ENDIAN = 0,    // little-endian mode (default mode)
    UC_MODE_BIG_ENDIAN = 1 << 30, // big-endian mode

    // arm / arm64
    UC_MODE_ARM = 0,        // ARM mode
    UC_MODE_THUMB = 1 << 4, // THUMB mode (including Thumb-2)
    // Depreciated, use UC_ARM_CPU_* with uc_ctl instead.
    UC_MODE_MCLASS = 1 << 5,  // ARM's Cortex-M series.
    UC_MODE_V8 = 1 << 6,      // ARMv8 A32 encodings for ARM
    UC_MODE_ARMBE8 = 1 << 10, // Big-endian data and Little-endian code.
                              // Legacy support for UC1 only.

    // arm (32bit) cpu types
    // Depreciated, use UC_ARM_CPU_* with uc_ctl instead.
    UC_MODE_ARM926 = 1 << 7,  // ARM926 CPU type
    UC_MODE_ARM946 = 1 << 8,  // ARM946 CPU type
    UC_MODE_ARM1176 = 1 << 9, // ARM1176 CPU type

    // mips
    UC_MODE_MICRO = 1 << 4,    // MicroMips mode (currently unsupported)
    UC_MODE_MIPS3 = 1 << 5,    // Mips III ISA (currently unsupported)
    UC_MODE_MIPS32R6 = 1 << 6, // Mips32r6 ISA (currently unsupported)
    UC_MODE_MIPS32 = 1 << 2,   // Mips32 ISA
    UC_MODE_MIPS64 = 1 << 3,   // Mips64 ISA

    // x86 / x64
    UC_MODE_16 = 1 << 1, // 16-bit mode
    UC_MODE_32 = 1 << 2, // 32-bit mode
    UC_MODE_64 = 1 << 3, // 64-bit mode

    // ppc
    UC_MODE_PPC32 = 1 << 2, // 32-bit mode
    UC_MODE_PPC64 = 1 << 3, // 64-bit mode (currently unsupported)
    UC_MODE_QPX =
        1 << 4, // Quad Processing eXtensions mode (currently unsupported)

    // sparc
    UC_MODE_SPARC32 = 1 << 2, // 32-bit mode
    UC_MODE_SPARC64 = 1 << 3, // 64-bit mode
    UC_MODE_V9 = 1 << 4,      // SparcV9 mode (currently unsupported)

    // riscv
    UC_MODE_RISCV32 = 1 << 2, // 32-bit mode
    UC_MODE_RISCV64 = 1 << 3, // 64-bit mode

    // m68k
} uc_mode;

// All type of errors encountered by Unicorn API.
// These are values returned by uc_errno()
typedef enum uc_err {
    UC_ERR_OK = 0,         // No error: everything was fine
    UC_ERR_NOMEM,          // Out-Of-Memory error: uc_open(), uc_emulate()
    UC_ERR_ARCH,           // Unsupported architecture: uc_open()
    UC_ERR_HANDLE,         // Invalid handle
    UC_ERR_MODE,           // Invalid/unsupported mode: uc_open()
    UC_ERR_VERSION,        // Unsupported version (bindings)
    UC_ERR_READ_UNMAPPED,  // Quit emulation due to READ on unmapped memory:
                           // uc_emu_start()
    UC_ERR_WRITE_UNMAPPED, // Quit emulation due to WRITE on unmapped memory:
                           // uc_emu_start()
    UC_ERR_FETCH_UNMAPPED, // Quit emulation due to FETCH on unmapped memory:
                           // uc_emu_start()
    UC_ERR_HOOK,           // Invalid hook type: uc_hook_add()
    UC_ERR_INSN_INVALID,   // Quit emulation due to invalid instruction:
                           // uc_emu_start()
    UC_ERR_MAP,            // Invalid memory mapping: uc_mem_map()
    UC_ERR_WRITE_PROT,     // Quit emulation due to UC_MEM_WRITE_PROT violation:
                           // uc_emu_start()
    UC_ERR_READ_PROT,      // Quit emulation due to UC_MEM_READ_PROT violation:
                           // uc_emu_start()
    UC_ERR_FETCH_PROT,     // Quit emulation due to UC_MEM_FETCH_PROT violation:
                           // uc_emu_start()
    UC_ERR_ARG, // Inavalid argument provided to uc_xxx function (See specific
                // function API)
    UC_ERR_READ_UNALIGNED,  // Unaligned read
    UC_ERR_WRITE_UNALIGNED, // Unaligned write
    UC_ERR_FETCH_UNALIGNED, // Unaligned fetch
    UC_ERR_HOOK_EXIST,      // hook for this event already existed
    UC_ERR_RESOURCE,        // Insufficient resource: uc_emu_start()
    UC_ERR_EXCEPTION,       // Unhandled CPU exception
    UC_ERR_OVERFLOW,        // Provided buffer is not large enough: uc_reg_*2()
} uc_err;

/*
  Callback function for tracing code (UC_HOOK_CODE & UC_HOOK_BLOCK)

  @address: address where the code is being executed
  @size: size of machine instruction(s) being executed, or 0 when size is
  unknown
  @user_data: user data passed to tracing APIs.
*/
typedef void (*uc_cb_hookcode_t)(uc_engine *uc, uint64_t address, uint32_t size,
                                 void *user_data);

/*
  Callback function for tracing interrupts (for uc_hook_intr())

  @intno: interrupt number
  @user_data: user data passed to tracing APIs.
*/
typedef void (*uc_cb_hookintr_t)(uc_engine *uc, uint32_t intno,
                                 void *user_data);

/*
  Callback function for tracing invalid instructions

  @user_data: user data passed to tracing APIs.

  @return: return true to continue, or false to stop program (due to invalid
  instruction).
*/
typedef bool (*uc_cb_hookinsn_invalid_t)(uc_engine *uc, void *user_data);

/*
  Callback function for tracing IN instruction of X86

  @port: port number
  @size: data size (1/2/4) to be read from this port
  @user_data: user data passed to tracing APIs.
*/
typedef uint32_t (*uc_cb_insn_in_t)(uc_engine *uc, uint32_t port, int size,
                                    void *user_data);

/*
  Callback function for OUT instruction of X86

  @port: port number
  @size: data size (1/2/4) to be written to this port
  @value: data value to be written to this port
*/
typedef void (*uc_cb_insn_out_t)(uc_engine *uc, uint32_t port, int size,
                                 uint32_t value, void *user_data);

typedef struct uc_tlb_entry uc_tlb_entry;
// All type of memory accesses for UC_HOOK_MEM_*
typedef enum uc_mem_type {
    UC_MEM_READ = 16,      // Memory is read from
    UC_MEM_WRITE,          // Memory is written to
    UC_MEM_FETCH,          // Memory is fetched
    UC_MEM_READ_UNMAPPED,  // Unmapped memory is read from
    UC_MEM_WRITE_UNMAPPED, // Unmapped memory is written to
    UC_MEM_FETCH_UNMAPPED, // Unmapped memory is fetched
    UC_MEM_WRITE_PROT,     // Write to write protected, but mapped, memory
    UC_MEM_READ_PROT,      // Read from read protected, but mapped, memory
    UC_MEM_FETCH_PROT,     // Fetch from non-executable, but mapped, memory
    UC_MEM_READ_AFTER,     // Memory is read from (successful access)
} uc_mem_type;

/*
  Callback function for tlb lookups

  @vaddr: virtuall address for lookup
  @rw: the access mode
  @result: result entry, contains physical address (paddr) and permitted access
  type (perms) for the entry

  @return: return true if the entry was found. If a callback is present but
  no one returns true a pagefault is generated.
*/
typedef bool (*uc_cb_tlbevent_t)(uc_engine *uc, uint64_t vaddr,
                                 uc_mem_type type, uc_tlb_entry *result,
                                 void *user_data);

// Represent a TranslationBlock.
typedef struct uc_tb {
    uint64_t pc;
    uint16_t icount;
    uint16_t size;
} uc_tb;

/*
  Callback function for new edges between translation blocks.

  @cur_tb: Current TB which is to be generated.
  @prev_tb: The previous TB.
*/
typedef void (*uc_hook_edge_gen_t)(uc_engine *uc, uc_tb *cur_tb, uc_tb *prev_tb,
                                   void *user_data);

/*
  Callback function for tcg opcodes that fits in two arguments.

  @address: Current pc.
  @arg1: The first argument.
  @arg2: The second argument.
*/
typedef void (*uc_hook_tcg_op_2)(uc_engine *uc, uint64_t address, uint64_t arg1,
                                 uint64_t arg2, uint32_t size, void *user_data);

typedef uc_hook_tcg_op_2 uc_hook_tcg_sub_t;

/*
  Callback function for MMIO read

  @offset: offset to the base address of the IO memory.
  @size: data size to read
  @user_data: user data passed to uc_mmio_map()
*/
typedef uint64_t (*uc_cb_mmio_read_t)(uc_engine *uc, uint64_t offset,
                                      unsigned size, void *user_data);

/*
  Callback function for MMIO write

  @offset: offset to the base address of the IO memory.
  @size: data size to write
  @value: data value to be written
  @user_data: user data passed to uc_mmio_map()
*/
typedef void (*uc_cb_mmio_write_t)(uc_engine *uc, uint64_t offset,
                                   unsigned size, uint64_t value,
                                   void *user_data);

// These are all op codes we support to hook for UC_HOOK_TCG_OP_CODE.
// Be cautious since it may bring much more overhead than UC_HOOK_CODE without
// proper flags.
// TODO: Tracing UC_TCG_OP_CALL should be interesting.
typedef enum uc_tcg_op_code {
    UC_TCG_OP_SUB = 0, // Both sub_i32 and sub_i64
} uc_tcg_op_code;

// These are extra flags to be paired with uc_tcg_op_code which is helpful to
// instrument in some certain cases.
typedef enum uc_tcg_op_flag {
    // Only instrument opcode if it would set cc_dst, i.e. cmp instruction.
    UC_TCG_OP_FLAG_CMP = 1 << 0,
    // Only instrument opcode which is directly translated.
    // i.e. x86 sub/subc -> tcg sub_i32/64
    UC_TCG_OP_FLAG_DIRECT = 1 << 1
} uc_tcg_op_flag;

// All type of hooks for uc_hook_add() API.
typedef enum uc_hook_type {
    // Hook all interrupt/syscall events
    UC_HOOK_INTR = 1 << 0,
    // Hook a particular instruction - only a very small subset of instructions
    // supported here
    UC_HOOK_INSN = 1 << 1,
    // Hook a range of code
    UC_HOOK_CODE = 1 << 2,
    // Hook basic blocks
    UC_HOOK_BLOCK = 1 << 3,
    // Hook for memory read on unmapped memory
    UC_HOOK_MEM_READ_UNMAPPED = 1 << 4,
    // Hook for invalid memory write events
    UC_HOOK_MEM_WRITE_UNMAPPED = 1 << 5,
    // Hook for invalid memory fetch for execution events
    UC_HOOK_MEM_FETCH_UNMAPPED = 1 << 6,
    // Hook for memory read on read-protected memory
    UC_HOOK_MEM_READ_PROT = 1 << 7,
    // Hook for memory write on write-protected memory
    UC_HOOK_MEM_WRITE_PROT = 1 << 8,
    // Hook for memory fetch on non-executable memory
    UC_HOOK_MEM_FETCH_PROT = 1 << 9,
    // Hook memory read events.
    UC_HOOK_MEM_READ = 1 << 10,
    // Hook memory write events.
    UC_HOOK_MEM_WRITE = 1 << 11,
    // Hook memory fetch for execution events
    UC_HOOK_MEM_FETCH = 1 << 12,
    // Hook memory read events, but only successful access.
    // The callback will be triggered after successful read.
    UC_HOOK_MEM_READ_AFTER = 1 << 13,
    // Hook invalid instructions exceptions.
    UC_HOOK_INSN_INVALID = 1 << 14,
    // Hook on new edge generation. Could be useful in program analysis.
    //
    // NOTE: This is different from UC_HOOK_BLOCK in 2 ways:
    //       1. The hook is called before executing code.
    //       2. The hook is only called when generation is triggered.
    UC_HOOK_EDGE_GENERATED = 1 << 15,
    // Hook on specific tcg op code. The usage of this hook is similar to
    // UC_HOOK_INSN.
    UC_HOOK_TCG_OPCODE = 1 << 16,
    // Hook on tlb fill requests.
    // Register tlb fill request hook on the virtuall addresses.
    // The callback will be triggert if the tlb cache don't contain an address.
    UC_HOOK_TLB_FILL = 1 << 17,
} uc_hook_type;

// Hook type for all events of unmapped memory access
#define UC_HOOK_MEM_UNMAPPED                                                   \
    (UC_HOOK_MEM_READ_UNMAPPED + UC_HOOK_MEM_WRITE_UNMAPPED +                  \
     UC_HOOK_MEM_FETCH_UNMAPPED)
// Hook type for all events of illegal protected memory access
#define UC_HOOK_MEM_PROT                                                       \
    (UC_HOOK_MEM_READ_PROT + UC_HOOK_MEM_WRITE_PROT + UC_HOOK_MEM_FETCH_PROT)
// Hook type for all events of illegal read memory access
#define UC_HOOK_MEM_READ_INVALID                                               \
    (UC_HOOK_MEM_READ_PROT + UC_HOOK_MEM_READ_UNMAPPED)
// Hook type for all events of illegal write memory access
#define UC_HOOK_MEM_WRITE_INVALID                                              \
    (UC_HOOK_MEM_WRITE_PROT + UC_HOOK_MEM_WRITE_UNMAPPED)
// Hook type for all events of illegal fetch memory access
#define UC_HOOK_MEM_FETCH_INVALID                                              \
    (UC_HOOK_MEM_FETCH_PROT + UC_HOOK_MEM_FETCH_UNMAPPED)
// Hook type for all events of illegal memory access
#define UC_HOOK_MEM_INVALID (UC_HOOK_MEM_UNMAPPED + UC_HOOK_MEM_PROT)
// Hook type for all events of valid memory access
// NOTE: UC_HOOK_MEM_READ is triggered before UC_HOOK_MEM_READ_PROT and
// UC_HOOK_MEM_READ_UNMAPPED, so
//       this hook may technically trigger on some invalid reads.
#define UC_HOOK_MEM_VALID                                                      \
    (UC_HOOK_MEM_READ + UC_HOOK_MEM_WRITE + UC_HOOK_MEM_FETCH)

/*
  Callback function for hooking memory (READ, WRITE & FETCH).

  NOTE: The access might be splitted depending on the MMU implementation.
  UC_TLB_VIRTUAL provides more fine-grained control about memory accessing.

  @type: this memory is being READ, or WRITE
  @address: address where memory is being written or read to
  @size: size of data being read or written
  @value: value of data being written to memory, or irrelevant if type = READ.
  @user_data: user data passed to tracing APIs
*/
typedef void (*uc_cb_hookmem_t)(uc_engine *uc, uc_mem_type type,
                                uint64_t address, int size, int64_t value,
                                void *user_data);

/*
  Callback function for handling invalid memory access events (UNMAPPED and
    PROT events)

  NOTE: The access might be splitted depending on the MMU implementation.
  UC_TLB_VIRTUAL provides more fine-grained control about memory accessing.

  @type: this memory is being READ, or WRITE
  @address: address where memory is being written or read to
  @size: size of data being read or written
  @value: value of data being written to memory, or irrelevant if type = READ.
  @user_data: user data passed to tracing APIs

  @return: return true to continue, or false to stop program (due to invalid
  memory). NOTE: returning true to continue execution will only work if the
  accessed memory is made accessible with the correct permissions during the
  hook.

           In the event of a UC_MEM_READ_UNMAPPED or UC_MEM_WRITE_UNMAPPED
  callback, the memory should be uc_mem_map()-ed with the correct permissions,
  and the instruction will then read or write to the address as it was supposed
  to.

           In the event of a UC_MEM_FETCH_UNMAPPED callback, the memory can be
  mapped in as executable, in which case execution will resume from the fetched
  address. The instruction pointer may be written to in order to change where
  execution resumes, but the fetch must succeed if execution is to resume.
*/
typedef bool (*uc_cb_eventmem_t)(uc_engine *uc, uc_mem_type type,
                                 uint64_t address, int size, int64_t value,
                                 void *user_data);

/*
  Memory region mapped by uc_mem_map() and uc_mem_map_ptr()
  Retrieve the list of memory regions with uc_mem_regions()
*/
typedef struct uc_mem_region {
    uint64_t begin; // begin address of the region (inclusive)
    uint64_t end;   // end address of the region (inclusive)
    uint32_t perms; // memory permissions of the region
} uc_mem_region;

// All type of queries for uc_query() API.
typedef enum uc_query_type {
    // Dynamically query current hardware mode.
    UC_QUERY_MODE = 1,
    UC_QUERY_PAGE_SIZE, // query pagesize of engine
    UC_QUERY_ARCH, // query architecture of engine (for ARM to query Thumb mode)
    UC_QUERY_TIMEOUT, // query if emulation stops due to timeout (indicated if
                      // result = True)
} uc_query_type;

// The implementation of uc_ctl is like what Linux ioctl does but slightly
// different.
//
// A uc_control_type passed to uc_ctl is constructed as:
//
//    R/W       NR       Reserved     Type
//  [      ] [      ]  [         ] [       ]
//  31    30 29     26 25       16 15      0
//
//  @R/W: Whether the operation is a read or write access.
//  @NR: Number of arguments.
//  @Reserved: Should be zero, reserved for future extension.
//  @Type: Taken from uc_control_type enum.
//
// See the helper macros below.

// No input and output arguments.
#define UC_CTL_IO_NONE (0)
// Only input arguments for a write operation.
#define UC_CTL_IO_WRITE (1)
// Only output arguments for a read operation.
#define UC_CTL_IO_READ (2)
// The arguments include both input and output arugments.
#define UC_CTL_IO_READ_WRITE (UC_CTL_IO_WRITE | UC_CTL_IO_READ)

#define UC_CTL(type, nr, rw)                                                   \
    (uc_control_type)((type) | ((nr) << 26) | ((rw) << 30))
#define UC_CTL_NONE(type, nr) UC_CTL(type, nr, UC_CTL_IO_NONE)
#define UC_CTL_READ(type, nr) UC_CTL(type, nr, UC_CTL_IO_READ)
#define UC_CTL_WRITE(type, nr) UC_CTL(type, nr, UC_CTL_IO_WRITE)
#define UC_CTL_READ_WRITE(type, nr) UC_CTL(type, nr, UC_CTL_IO_READ_WRITE)

// unicorn tlb type selection
typedef enum uc_tlb_type {
    // The default unicorn virtuall TLB implementation.
    // The tlb implementation of the CPU, best to use for full system emulation.
    UC_TLB_CPU = 0,
    // This tlb defaults to virtuall address == physical address
    // Also a hook is availible to override the tlb entries (see
    // uc_cb_tlbevent_t).
    UC_TLB_VIRTUAL
} uc_tlb_type;

// All type of controls for uc_ctl API.
// The controls are organized in a tree level.
// If a control don't have `Set` or `Get` for @args, it means it's r/o or w/o.
typedef enum uc_control_type {
    // Current mode.
    // Read: @args = (int*)
    UC_CTL_UC_MODE = 0,
    // Curent page size.
    // Write: @args = (uint32_t)
    // Read: @args = (uint32_t*)
    UC_CTL_UC_PAGE_SIZE,
    // Current arch.
    // Read: @args = (int*)
    UC_CTL_UC_ARCH,
    // Current timeout.
    // Read: @args = (uint64_t*)
    UC_CTL_UC_TIMEOUT,
    // Enable multiple exits.
    // Without this control, reading/setting exits won't work.
    // This is for API backward compatibility.
    // Write: @args = (int)
    UC_CTL_UC_USE_EXITS,
    // The number of current exits.
    // Read: @args = (size_t*)
    UC_CTL_UC_EXITS_CNT,
    // Current exits.
    // Write: @args = (uint64_t* exits, size_t len)
    //        @len = UC_CTL_UC_EXITS_CNT
    // Read: @args = (uint64_t* exits, size_t len)
    //       @len = UC_CTL_UC_EXITS_CNT
    UC_CTL_UC_EXITS,

    // Set the cpu model of uc.
    // Note this option can only be set before any Unicorn
    // API is called except for uc_open.
    // Write: @args = (int)
    // Read:  @args = (int*)
    UC_CTL_CPU_MODEL,
    // Request a tb cache at a specific address
    // Read: @args = (uint64_t, uc_tb*)
    UC_CTL_TB_REQUEST_CACHE,
    // Invalidate a tb cache at a specific address
    // Write: @args = (uint64_t, uint64_t)
    UC_CTL_TB_REMOVE_CACHE,
    // Invalidate all translation blocks.
    // No arguments.
    UC_CTL_TB_FLUSH,
    // Invalidate all TLB cache entries and translation blocks.
    // No arguments
    UC_CTL_TLB_FLUSH,
    // Change the tlb implementation
    // see uc_tlb_type for current implemented types
    // Write: @args = (int)
    UC_CTL_TLB_TYPE,
    // Change the tcg translation buffer size, note that
    // unicorn may adjust this value.
    // Write: @args = (uint32_t)
    // Read: @args = (uint32_t*)
    UC_CTL_TCG_BUFFER_SIZE,
    // controle if context_save/restore should work with snapshots
    // Write: @args = (int)
    UC_CTL_CONTEXT_MODE,
} uc_control_type;

/*

Exits Mechanism

In some cases, users may have multiple exits and the @until parameter of
uc_emu_start is not sufficient to control the emulation. The exits mechanism is
designed to solve this problem. Note that using hooks is aslo feasible, but the
exits could be slightly more efficient and easy to implement.

By default, the exits mechanism is disabled to keep backward compatibility. That
is to say, calling uc_ctl_set/get_exits would return an error. Thus, to enable
the exits firstly, call:

  uc_ctl_exits_enable(uc)

After this call, the @until parameter of uc_emu_start would have no effect on
the emulation, so:

  uc_emu_start(uc, 0x1000, 0 ...)
  uc_emu_start(uc, 0x1000, 0x1000 ...)
  uc_emu_start(uc, 0x1000, -1 ...)

The three calls are totally equavelent since the @until is ignored.

To setup the exits, users may call:

  uc_ctl_set/get_exits(uc, exits, len)

For example, with an exits array [0x1000, 0x2000], uc_emu_start would stop at
either 0x1000 and 0x2000. With an exits array [], uc_emu_start won't stop unless
some hooks request a stop.

If users would like to restore the default behavior of @until parameter, users
may call:

  uc_ctl_exits_disable(uc)

After that, all exits setup previously would be cleared and @until parameter
would take effect again.

See sample_ctl.c for a detailed example.

*/
#define uc_ctl_get_mode(uc, mode)                                              \
    uc_ctl(uc, UC_CTL_READ(UC_CTL_UC_MODE, 1), (mode))
#define uc_ctl_get_page_size(uc, ptr)                                          \
    uc_ctl(uc, UC_CTL_READ(UC_CTL_UC_PAGE_SIZE, 1), (ptr))
#define uc_ctl_set_page_size(uc, page_size)                                    \
    uc_ctl(uc, UC_CTL_WRITE(UC_CTL_UC_PAGE_SIZE, 1), (page_size))
#define uc_ctl_get_arch(uc, arch)                                              \
    uc_ctl(uc, UC_CTL_READ(UC_CTL_UC_ARCH, 1), (arch))
#define uc_ctl_get_timeout(uc, ptr)                                            \
    uc_ctl(uc, UC_CTL_READ(UC_CTL_UC_TIMEOUT, 1), (ptr))
#define uc_ctl_exits_enable(uc)                                                \
    uc_ctl(uc, UC_CTL_WRITE(UC_CTL_UC_USE_EXITS, 1), 1)
#define uc_ctl_exits_disable(uc)                                               \
    uc_ctl(uc, UC_CTL_WRITE(UC_CTL_UC_USE_EXITS, 1), 0)
#define uc_ctl_get_exits_cnt(uc, ptr)                                          \
    uc_ctl(uc, UC_CTL_READ(UC_CTL_UC_EXITS_CNT, 1), (ptr))
#define uc_ctl_get_exits(uc, buffer, len)                                      \
    uc_ctl(uc, UC_CTL_READ(UC_CTL_UC_EXITS, 2), (buffer), (len))
#define uc_ctl_set_exits(uc, buffer, len)                                      \
    uc_ctl(uc, UC_CTL_WRITE(UC_CTL_UC_EXITS, 2), (buffer), (len))
#define uc_ctl_get_cpu_model(uc, model)                                        \
    uc_ctl(uc, UC_CTL_READ(UC_CTL_CPU_MODEL, 1), (model))
#define uc_ctl_set_cpu_model(uc, model)                                        \
    uc_ctl(uc, UC_CTL_WRITE(UC_CTL_CPU_MODEL, 1), (model))
#define uc_ctl_remove_cache(uc, address, end)                                  \
    uc_ctl(uc, UC_CTL_WRITE(UC_CTL_TB_REMOVE_CACHE, 2), (address), (end))
#define uc_ctl_request_cache(uc, address, tb)                                  \
    uc_ctl(uc, UC_CTL_READ_WRITE(UC_CTL_TB_REQUEST_CACHE, 2), (address), (tb))
#define uc_ctl_flush_tb(uc) uc_ctl(uc, UC_CTL_WRITE(UC_CTL_TB_FLUSH, 0))
#define uc_ctl_flush_tlb(uc) uc_ctl(uc, UC_CTL_WRITE(UC_CTL_TLB_FLUSH, 0))
#define uc_ctl_tlb_mode(uc, mode)                                              \
    uc_ctl(uc, UC_CTL_WRITE(UC_CTL_TLB_TYPE, 1), (mode))
#define uc_ctl_get_tcg_buffer_size(uc, size)                                   \
    uc_ctl(uc, UC_CTL_READ(UC_CTL_TCG_BUFFER_SIZE, 1), (size))
#define uc_ctl_set_tcg_buffer_size(uc, size)                                   \
    uc_ctl(uc, UC_CTL_WRITE(UC_CTL_TCG_BUFFER_SIZE, 1), (size))
#define uc_ctl_context_mode(uc, mode)                                          \
    uc_ctl(uc, UC_CTL_WRITE(UC_CTL_CONTEXT_MODE, 1), (mode))

// Opaque storage for CPU context, used with uc_context_*()
struct uc_context;
typedef struct uc_context uc_context;

/*
 Return combined API version & major and minor version numbers.

 @major: major number of API version
 @minor: minor number of API version

 @return hexadecimal number as (major << 24 | minor << 16 | patch << 8 | extra).
     NOTE: This returned value can be compared with version number made
     with macro UC_MAKE_VERSION

 For example, Unicorn version 2.0.1 final would be 0x020001ff.

 NOTE: if you only care about returned value, but not major and minor values,
 set both @major & @minor arguments to NULL.
*/
UNICORN_EXPORT
unsigned int uc_version(unsigned int *major, unsigned int *minor);

/*
 Determine if the given architecture is supported by this library.

 @arch: architecture type (UC_ARCH_*)

 @return True if this library supports the given arch.
*/
UNICORN_EXPORT
bool uc_arch_supported(uc_arch arch);

/*
 Create new instance of unicorn engine.

 @arch: architecture type (UC_ARCH_*)
 @mode: hardware mode. This is combined of UC_MODE_*
 @uc: pointer to uc_engine, which will be updated at return time

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_open(uc_arch arch, uc_mode mode, uc_engine **uc);

/*
 Close a Unicorn engine instance.
 NOTE: this must be called only when there is no longer any
 usage of @uc. This API releases some of @uc's cached memory, thus
 any use of the Unicorn API with @uc after it has been closed may
 crash your application. After this, @uc is invalid, and is no
 longer usable.

 @uc: pointer to a handle returned by uc_open()

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_close(uc_engine *uc);

/*
 Query internal status of engine.

 @uc: handle returned by uc_open()
 @type: query type. See uc_query_type

 @result: save the internal status queried

 @return: error code of uc_err enum type (UC_ERR_*, see above)
*/
UNICORN_EXPORT
uc_err uc_query(uc_engine *uc, uc_query_type type, size_t *result);

/*
 Control internal states of engine.

 Also see uc_ctl_* macro helpers for easy use.

 @uc: handle returned by uc_open()
 @control: the control type.
 @args: See uc_control_type for details about variadic arguments.

 @return: error code of uc_err enum type (UC_ERR_*, see above)
*/
UNICORN_EXPORT
uc_err uc_ctl(uc_engine *uc, uc_control_type control, ...);

/*
 Report the last error number when some API function fails.
 Like glibc's errno, uc_errno might not retain its old value once accessed.

 @uc: handle returned by uc_open()

 @return: error code of uc_err enum type (UC_ERR_*, see above)
*/
UNICORN_EXPORT
uc_err uc_errno(uc_engine *uc);

/*
 Return a string describing given error code.

 @code: error code (see UC_ERR_* above)

 @return: returns a pointer to a string that describes the error code
   passed in the argument @code
 */
UNICORN_EXPORT
const char *uc_strerror(uc_err code);

/*
 Write to register.

 @uc: handle returned by uc_open()
 @regid:  register ID that is to be modified.
 @value:  pointer to the value that will be written to register @regid

 @return UC_ERR_OK on success; UC_ERR_ARG if register number or value is invalid
*/
UNICORN_EXPORT
uc_err uc_reg_write(uc_engine *uc, int regid, const void *value);

/*
 Read register value.

 @uc: handle returned by uc_open()
 @regid:  register ID that is to be retrieved.
 @value:  pointer to a variable storing the register value.

 @return UC_ERR_OK on success; UC_ERR_ARG if register number or value is invalid
*/
UNICORN_EXPORT
uc_err uc_reg_read(uc_engine *uc, int regid, void *value);

/*
 Write to register.

 @uc: handle returned by uc_open()
 @regid:  register ID that is to be modified.
 @value:  pointer to the value that will be written to register @regid
 @size:   size of value being written; on return, size of value written

 @return UC_ERR_OK on success; UC_ERR_ARG if register number or value is
 invalid; UC_ERR_OVERFLOW if value is not large enough for the register.
*/
UNICORN_EXPORT
uc_err uc_reg_write2(uc_engine *uc, int regid, const void *value, size_t *size);

/*
 Read register value.

 @uc: handle returned by uc_open()
 @regid:  register ID that is to be retrieved.
 @value:  pointer to a variable storing the register value.
 @size:   size of value buffer; on return, size of value read

 @return UC_ERR_OK on success; UC_ERR_ARG if register number or value is
 invalid; UC_ERR_OVERFLOW if value is not large enough to hold the register.
*/
UNICORN_EXPORT
uc_err uc_reg_read2(uc_engine *uc, int regid, void *value, size_t *size);

/*
 Write multiple register values.

 @uc: handle returned by uc_open()
 @regs:  array of register IDs to store
 @vals:  array of pointers to register values
 @count: length of both *regs and *vals

 @return UC_ERR_OK on success; UC_ERR_ARG if some register number or value is
 invalid
*/
UNICORN_EXPORT
uc_err uc_reg_write_batch(uc_engine *uc, int const *regs, void *const *vals,
                          int count);

/*
 Read multiple register values.

 @uc: handle returned by uc_open()
 @regs:  array of register IDs to retrieve
 @vals:  array of pointers to register values
 @count: length of both *regs and *vals

 @return UC_ERR_OK on success; UC_ERR_ARG if some register number or value is
 invalid
*/
UNICORN_EXPORT
uc_err uc_reg_read_batch(uc_engine *uc, int const *regs, void **vals,
                         int count);

/*
 Write multiple register values.

 @uc: handle returned by uc_open()
 @regs:  array of register IDs to store
 @value: array of pointers to register values
 @sizes: array of sizes of each value; on return, sizes of each stored register
 @count: length of *regs, *vals and *sizes

 @return UC_ERR_OK on success; UC_ERR_ARG if some register number or value is
 invalid; UC_ERR_OVERFLOW if some value is not large enough for the
 corresponding register.
*/
UNICORN_EXPORT
uc_err uc_reg_write_batch2(uc_engine *uc, int const *regs,
                           const void *const *vals, size_t *sizes, int count);

/*
 Read multiple register values.

 @uc: handle returned by uc_open()
 @regs:  array of register IDs to retrieve
 @value: pointer to array of values to hold registers
 @sizes: array of sizes of each value; on return, sizes of each retrieved
 register
 @count: length of *regs, *vals and *sizes

 @return UC_ERR_OK on success; UC_ERR_ARG if some register number or value is
 invalid; UC_ERR_OVERFLOW if some value is not large enough to hold the
 corresponding register.
*/
UNICORN_EXPORT
uc_err uc_reg_read_batch2(uc_engine *uc, int const *regs, void *const *vals,
                          size_t *sizes, int count);

/*
 Write to a range of bytes in memory.

 @uc: handle returned by uc_open()
 @address: starting memory address of bytes to set.
 @bytes:   pointer to a variable containing data to be written to memory.
 @size:   size of memory to write to.

 NOTE: @bytes must be big enough to contain @size bytes.

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_mem_write(uc_engine *uc, uint64_t address, const void *bytes,
                    uint64_t size);

/*
 Read a range of bytes in memory.

 @uc: handle returned by uc_open()
 @address: starting memory address of bytes to get.
 @bytes:   pointer to a variable containing data copied from memory.
 @size:   size of memory to read.

 NOTE: @bytes must be big enough to contain @size bytes.

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_mem_read(uc_engine *uc, uint64_t address, void *bytes, uint64_t size);

/*
 Emulate machine code in a specific duration of time.

 @uc: handle returned by uc_open()
 @begin: address where emulation starts
 @until: address where emulation stops (i.e. when this address is hit)
 @timeout: duration to emulate the code (in microseconds). When this value is 0,
        we will emulate the code in infinite time, until the code is finished.
 @count: the number of instructions to be emulated. When this value is 0,
        we will emulate all the code available, until the code is finished.

 NOTE: The internal states of the engine is guranteed to be correct if and only
       if uc_emu_start returns without any errors or errors have been handled in
       the callbacks.

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_emu_start(uc_engine *uc, uint64_t begin, uint64_t until,
                    uint64_t timeout, size_t count);

/*
 Stop emulation (which was started by uc_emu_start() API.
 This is typically called from callback functions registered via tracing APIs.

 @uc: handle returned by uc_open()

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_emu_stop(uc_engine *uc);

/*
 Register callback for a hook event.
 The callback will be run when the hook event is hit.

 @uc: handle returned by uc_open()
 @hh: hook handle returned from this registration. To be used in uc_hook_del()
 API
 @type: hook type, refer to uc_hook_type enum
 @callback: callback to be run when instruction is hit
 @user_data: user-defined data. This will be passed to callback function in its
      last argument @user_data
 @begin: start address of the area where the callback is in effect (inclusive)
 @end: end address of the area where the callback is in effect (inclusive)
   NOTE 1: the callback is called only if related address is in range [@begin,
 @end] NOTE 2: if @begin > @end, callback is called whenever this hook type is
 triggered
 @...: variable arguments (depending on @type)
   NOTE: if @type = UC_HOOK_INSN, this is the instruction ID.
         currently, only x86 in, out, syscall, sysenter, cpuid are supported.
   NOTE: if @type = UC_HOOK_TCG_OPCODE, arguments are @opcode and @flags. See
 @uc_tcg_op_code and @uc_tcg_op_flag for details.

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_hook_add(uc_engine *uc, uc_hook *hh, int type, void *callback,
                   void *user_data, uint64_t begin, uint64_t end, ...);

/*
 Unregister (remove) a hook callback.
 This API removes the hook callback registered by uc_hook_add().
 NOTE: this should be called only when you no longer want to trace.
 After this, @hh is invalid, and no longer usable.

 @uc: handle returned by uc_open()
 @hh: handle returned by uc_hook_add()

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_hook_del(uc_engine *uc, uc_hook hh);

typedef enum uc_prot {
    UC_PROT_NONE = 0,
    UC_PROT_READ = 1,
    UC_PROT_WRITE = 2,
    UC_PROT_EXEC = 4,
    UC_PROT_ALL = 7,
} uc_prot;

struct uc_tlb_entry {
    uint64_t paddr;
    uc_prot perms;
};

/*
 Variables to control which state should be stored in the context.
 Defaults to UC_CTL_CONTEXT_CPU. The options are used in a bitfield
 so to enable more then one content the binary or of the required
 contents can be use.
 The UC_CTL_CONTEXT_MEMORY stores some pointers to internal allocated
 memory. Therefor it's not possible to use this context with another
 unicorn object.
*/

typedef enum uc_context_content {
    UC_CTL_CONTEXT_CPU = 1,
    UC_CTL_CONTEXT_MEMORY = 2,
} uc_context_content;

/*
 Map memory in for emulation.
 This API adds a memory region that can be used by emulation.

 @uc: handle returned by uc_open()
 @address: starting address of the new memory region to be mapped in.
    This address must be aligned to 4KB, or this will return with UC_ERR_ARG
 error.
 @size: size of the new memory region to be mapped in.
    This size must be a multiple of 4KB, or this will return with UC_ERR_ARG
 error.
 @perms: Permissions for the newly mapped region.
    This must be some combination of UC_PROT_READ | UC_PROT_WRITE |
 UC_PROT_EXEC, or this will return with UC_ERR_ARG error.

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_mem_map(uc_engine *uc, uint64_t address, uint64_t size,
                  uint32_t perms);

/*
 Map existing host memory in for emulation.
 This API adds a memory region that can be used by emulation.

 @uc: handle returned by uc_open()
 @address: starting address of the new memory region to be mapped in.
    This address must be aligned to 4KB, or this will return with UC_ERR_ARG
 error.
 @size: size of the new memory region to be mapped in.
    This size must be a multiple of 4KB, or this will return with UC_ERR_ARG
 error.
 @perms: Permissions for the newly mapped region.
    This must be some combination of UC_PROT_READ | UC_PROT_WRITE |
 UC_PROT_EXEC, or this will return with UC_ERR_ARG error.
 @ptr: pointer to host memory backing the newly mapped memory. This host memory
 is expected to be an equal or larger size than provided, and be mapped with at
    least PROT_READ | PROT_WRITE. If it is not, the resulting behavior is
 undefined.

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_mem_map_ptr(uc_engine *uc, uint64_t address, uint64_t size,
                      uint32_t perms, void *ptr);

/*
 Map MMIO in for emulation.
 This API adds a MMIO region that can be used by emulation.

 @uc: handle returned by uc_open()
 @address: starting address of the new MMIO region to be mapped in.
   This address must be aligned to 4KB, or this will return with UC_ERR_ARG
 error.
 @size: size of the new MMIO region to be mapped in.
   This size must be multiple of 4KB, or this will return with UC_ERR_ARG error.
 @read_cb: function for handling reads from this MMIO region.
 @user_data_read: user-defined data. This will be passed to @read_cb function in
 its last argument @user_data
 @write_cb: function for handling writes to this MMIO region.
 @user_data_write: user-defined data. This will be passed to @write_cb function
 in its last argument @user_data
 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
 */
UNICORN_EXPORT
uc_err uc_mmio_map(uc_engine *uc, uint64_t address, uint64_t size,
                   uc_cb_mmio_read_t read_cb, void *user_data_read,
                   uc_cb_mmio_write_t write_cb, void *user_data_write);

/*
 Unmap a region of emulation memory.
 This API deletes a memory mapping from the emulation memory space.

 @uc: handle returned by uc_open()
 @address: starting address of the memory region to be unmapped.
    This address must be aligned to 4KB, or this will return with UC_ERR_ARG
 error.
 @size: size of the memory region to be modified.
    This size must be a multiple of 4KB, or this will return with UC_ERR_ARG
 error.

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_mem_unmap(uc_engine *uc, uint64_t address, uint64_t size);

/*
 Set memory permissions for emulation memory.
 This API changes permissions on an existing memory region.

 @uc: handle returned by uc_open()
 @address: starting address of the memory region to be modified.
    This address must be aligned to 4KB, or this will return with UC_ERR_ARG
 error.
 @size: size of the memory region to be modified.
    This size must be a multiple of 4KB, or this will return with UC_ERR_ARG
 error.
 @perms: New permissions for the mapped region.
    This must be some combination of UC_PROT_READ | UC_PROT_WRITE |
 UC_PROT_EXEC, or this will return with UC_ERR_ARG error.

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_mem_protect(uc_engine *uc, uint64_t address, uint64_t size,
                      uint32_t perms);

/*
 Retrieve all memory regions mapped by uc_mem_map() and uc_mem_map_ptr()
 This API allocates memory for @regions, and user must free this memory later
 by uc_free() to avoid leaking memory.
 NOTE: memory regions may be split by uc_mem_unmap()

 @uc: handle returned by uc_open()
 @regions: pointer to an array of uc_mem_region struct. This is allocated by
   Unicorn, and must be freed by user later with uc_free()
 @count: pointer to number of struct uc_mem_region contained in @regions

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_mem_regions(uc_engine *uc, uc_mem_region **regions, uint32_t *count);

/*
 Allocate a region that can be used with uc_context_{save,restore} to perform
 quick save/rollback of the CPU context, which includes registers and some
 internal metadata. Contexts may not be shared across engine instances with
 differing arches or modes.

 @uc: handle returned by uc_open()
 @context: pointer to a uc_context*. This will be updated with the pointer to
   the new context on successful return of this function.
   Later, this allocated memory must be freed with uc_context_free().

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_context_alloc(uc_engine *uc, uc_context **context);

/*
 Free the memory allocated by uc_mem_regions.
 WARNING: After Unicorn 1.0.1rc5, the memory allocated by uc_context_alloc
 should be freed by uc_context_free(). Calling uc_free() may still work, but
 the result is **undefined**.

 @mem: memory allocated by uc_mem_regions (returned in *regions).

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_free(void *mem);

/*
 Save a copy of the internal CPU context.
 This API should be used to efficiently make or update a saved copy of the
 internal CPU state.

 @uc: handle returned by uc_open()
 @context: handle returned by uc_context_alloc()

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_context_save(uc_engine *uc, uc_context *context);

/*
 Write value to a register of a context.

 @ctx: handle returned by uc_context_alloc()
 @regid:  register ID that is to be modified.
 @value:  pointer to the value that will be written to register @regid

 @return UC_ERR_OK on success; UC_ERR_ARG if register number or value is invalid
*/
UNICORN_EXPORT
uc_err uc_context_reg_write(uc_context *ctx, int regid, const void *value);

/*
 Read register value from a context.

 @ctx: handle returned by uc_context_alloc()
 @regid:  register ID that is to be retrieved.
 @value:  pointer to a variable storing the register value.

 @return UC_ERR_OK on success; UC_ERR_ARG if register number or value is invalid
*/
UNICORN_EXPORT
uc_err uc_context_reg_read(uc_context *ctx, int regid, void *value);

/*
 Write value to a register of a context.

 @ctx: handle returned by uc_context_alloc()
 @regid:  register ID that is to be modified.
 @value:  pointer to the value that will be written to register @regid
 @size:   size of value being written; on return, size of value written

 @return UC_ERR_OK on success; UC_ERR_ARG if register number or value is
 invalid; UC_ERR_OVERFLOW if value is not large enough for the register.
*/
UNICORN_EXPORT
uc_err uc_context_reg_write2(uc_context *ctx, int regid, const void *value,
                             size_t *size);

/*
 Read register value from a context.

 @ctx: handle returned by uc_context_alloc()
 @regid:  register ID that is to be retrieved.
 @value:  pointer to a variable storing the register value.
 @size:   size of value buffer; on return, size of value read

 @return UC_ERR_OK on success; UC_ERR_ARG if register number or value is
 invalid; UC_ERR_OVERFLOW if value is not large enough to hold the register.
*/
UNICORN_EXPORT
uc_err uc_context_reg_read2(uc_context *ctx, int regid, void *value,
                            size_t *size);

/*
 Write multiple register values to registers of a context.

 @ctx: handle returned by uc_context_alloc()
 @regs:  array of register IDs to store
 @value: pointer to array of register values
 @count: length of both *regs and *vals

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_context_reg_write_batch(uc_context *ctx, int const *regs,
                                  void *const *vals, int count);

/*
 Read multiple register values from a context.

 @ctx: handle returned by uc_context_alloc()
 @regs:  array of register IDs to retrieve
 @value: pointer to array of values to hold registers
 @count: length of both *regs and *vals

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_context_reg_read_batch(uc_context *ctx, int const *regs, void **vals,
                                 int count);

/*
 Write multiple register values to registers of a context.

 @ctx: handle returned by uc_context_alloc()
 @regs:  array of register IDs to store
 @value: array of pointers to register values
 @sizes: array of sizes of each value; on return, sizes of each stored register
 @count: length of *regs, *vals and *sizes

 @return UC_ERR_OK on success; UC_ERR_ARG if some register number or value is
 invalid; UC_ERR_OVERFLOW if some value is not large enough for the
 corresponding register.
*/
UNICORN_EXPORT
uc_err uc_context_reg_write_batch2(uc_context *ctx, int const *regs,
                                   const void *const *vals, size_t *sizes,
                                   int count);

/*
 Read multiple register values from a context.

 @ctx: handle returned by uc_context_alloc()
 @regs:  array of register IDs to retrieve
 @value: pointer to array of values to hold registers
 @sizes: array of sizes of each value; on return, sizes of each retrieved
 register
 @count: length of *regs, *vals and *sizes

 @return UC_ERR_OK on success; UC_ERR_ARG if some register number or value is
 invalid; UC_ERR_OVERFLOW if some value is not large enough to hold the
 corresponding register.
*/
UNICORN_EXPORT
uc_err uc_context_reg_read_batch2(uc_context *ctx, int const *regs,
                                  void *const *vals, size_t *sizes, int count);

/*
 Restore the current CPU context from a saved copy.
 This API should be used to roll the CPU context back to a previous
 state saved by uc_context_save().

 @uc: handle returned by uc_open()
 @context: handle returned by uc_context_alloc that has been used with
 uc_context_save

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_context_restore(uc_engine *uc, uc_context *context);

/*
  Return the size needed to store the cpu context. Can be used to allocate a
  buffer to contain the cpu context and directly call uc_context_save.

  @uc: handle returned by uc_open()

  @return the size for needed to store the cpu context as as size_t.
*/
UNICORN_EXPORT
size_t uc_context_size(uc_engine *uc);

/*
  Free the context allocated by uc_context_alloc().

  @context: handle returned by uc_context_alloc()

  @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_context_free(uc_context *context);

#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/include/unicorn/unicorn/x86.h`:

```h
/* Unicorn Emulator Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2015-2017 */
/* This file is released under LGPL2.
   See COPYING.LGPL2 in root directory for more details
*/

#ifndef UNICORN_X86_H
#define UNICORN_X86_H

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

//> X86 CPU
typedef enum uc_cpu_x86 {
    UC_CPU_X86_QEMU64 = 0,
    UC_CPU_X86_PHENOM,
    UC_CPU_X86_CORE2DUO,
    UC_CPU_X86_KVM64,
    UC_CPU_X86_QEMU32,
    UC_CPU_X86_KVM32,
    UC_CPU_X86_COREDUO,
    UC_CPU_X86_486,
    UC_CPU_X86_PENTIUM,
    UC_CPU_X86_PENTIUM2,
    UC_CPU_X86_PENTIUM3,
    UC_CPU_X86_ATHLON,
    UC_CPU_X86_N270,
    UC_CPU_X86_CONROE,
    UC_CPU_X86_PENRYN,
    UC_CPU_X86_NEHALEM,
    UC_CPU_X86_WESTMERE,
    UC_CPU_X86_SANDYBRIDGE,
    UC_CPU_X86_IVYBRIDGE,
    UC_CPU_X86_HASWELL,
    UC_CPU_X86_BROADWELL,
    UC_CPU_X86_SKYLAKE_CLIENT,
    UC_CPU_X86_SKYLAKE_SERVER,
    UC_CPU_X86_CASCADELAKE_SERVER,
    UC_CPU_X86_COOPERLAKE,
    UC_CPU_X86_ICELAKE_CLIENT,
    UC_CPU_X86_ICELAKE_SERVER,
    UC_CPU_X86_DENVERTON,
    UC_CPU_X86_SNOWRIDGE,
    UC_CPU_X86_KNIGHTSMILL,
    UC_CPU_X86_OPTERON_G1,
    UC_CPU_X86_OPTERON_G2,
    UC_CPU_X86_OPTERON_G3,
    UC_CPU_X86_OPTERON_G4,
    UC_CPU_X86_OPTERON_G5,
    UC_CPU_X86_EPYC,
    UC_CPU_X86_DHYANA,
    UC_CPU_X86_EPYC_ROME,

    UC_CPU_X86_ENDING
} uc_cpu_x86;

// Memory-Management Register for instructions IDTR, GDTR, LDTR, TR.
// Borrow from SegmentCache in qemu/target-i386/cpu.h
typedef struct uc_x86_mmr {
    uint16_t selector; /* not used by GDTR and IDTR */
    uint64_t base;     /* handle 32 or 64 bit CPUs */
    uint32_t limit;
    uint32_t flags; /* not used by GDTR and IDTR */
} uc_x86_mmr;

// Model-Specific Register structure, use this with UC_X86_REG_MSR (as the
// register ID) in call to uc_reg_write/uc_reg_read() to manipulate MSRs.
typedef struct uc_x86_msr {
    uint32_t rid;   // MSR id
    uint64_t value; // MSR value
} uc_x86_msr;

// Callback function for tracing SYSCALL/SYSENTER (for uc_hook_intr())
// @user_data: user data passed to tracing APIs.
typedef void (*uc_cb_insn_syscall_t)(struct uc_struct *uc, void *user_data);

// Callback function for tracing cpuid (for uc_hook_intr())
// @user_data: user data passed to tracing APIs.
//
// @return: true indicates the callback overwrites the cpuid instruction while
// false
//          indicates cpuid instruction will still be executed.
typedef int (*uc_cb_insn_cpuid_t)(struct uc_struct *uc, void *user_data);

//> X86 registers
typedef enum uc_x86_reg {
    UC_X86_REG_INVALID = 0,
    UC_X86_REG_AH,
    UC_X86_REG_AL,
    UC_X86_REG_AX,
    UC_X86_REG_BH,
    UC_X86_REG_BL,
    UC_X86_REG_BP,
    UC_X86_REG_BPL,
    UC_X86_REG_BX,
    UC_X86_REG_CH,
    UC_X86_REG_CL,
    UC_X86_REG_CS,
    UC_X86_REG_CX,
    UC_X86_REG_DH,
    UC_X86_REG_DI,
    UC_X86_REG_DIL,
    UC_X86_REG_DL,
    UC_X86_REG_DS,
    UC_X86_REG_DX,
    UC_X86_REG_EAX,
    UC_X86_REG_EBP,
    UC_X86_REG_EBX,
    UC_X86_REG_ECX,
    UC_X86_REG_EDI,
    UC_X86_REG_EDX,
    UC_X86_REG_EFLAGS,
    UC_X86_REG_EIP,
    UC_X86_REG_ES = UC_X86_REG_EIP + 2,
    UC_X86_REG_ESI,
    UC_X86_REG_ESP,
    UC_X86_REG_FPSW,
    UC_X86_REG_FS,
    UC_X86_REG_GS,
    UC_X86_REG_IP,
    UC_X86_REG_RAX,
    UC_X86_REG_RBP,
    UC_X86_REG_RBX,
    UC_X86_REG_RCX,
    UC_X86_REG_RDI,
    UC_X86_REG_RDX,
    UC_X86_REG_RIP,
    UC_X86_REG_RSI = UC_X86_REG_RIP + 2,
    UC_X86_REG_RSP,
    UC_X86_REG_SI,
    UC_X86_REG_SIL,
    UC_X86_REG_SP,
    UC_X86_REG_SPL,
    UC_X86_REG_SS,
    UC_X86_REG_CR0,
    UC_X86_REG_CR1,
    UC_X86_REG_CR2,
    UC_X86_REG_CR3,
    UC_X86_REG_CR4,
    UC_X86_REG_CR8 = UC_X86_REG_CR4 + 4,
    UC_X86_REG_DR0 = UC_X86_REG_CR8 + 8,
    UC_X86_REG_DR1,
    UC_X86_REG_DR2,
    UC_X86_REG_DR3,
    UC_X86_REG_DR4,
    UC_X86_REG_DR5,
    UC_X86_REG_DR6,
    UC_X86_REG_DR7,
    UC_X86_REG_FP0 = UC_X86_REG_DR7 + 9,
    UC_X86_REG_FP1,
    UC_X86_REG_FP2,
    UC_X86_REG_FP3,
    UC_X86_REG_FP4,
    UC_X86_REG_FP5,
    UC_X86_REG_FP6,
    UC_X86_REG_FP7,
    UC_X86_REG_K0,
    UC_X86_REG_K1,
    UC_X86_REG_K2,
    UC_X86_REG_K3,
    UC_X86_REG_K4,
    UC_X86_REG_K5,
    UC_X86_REG_K6,
    UC_X86_REG_K7,
    UC_X86_REG_MM0,
    UC_X86_REG_MM1,
    UC_X86_REG_MM2,
    UC_X86_REG_MM3,
    UC_X86_REG_MM4,
    UC_X86_REG_MM5,
    UC_X86_REG_MM6,
    UC_X86_REG_MM7,
    UC_X86_REG_R8,
    UC_X86_REG_R9,
    UC_X86_REG_R10,
    UC_X86_REG_R11,
    UC_X86_REG_R12,
    UC_X86_REG_R13,
    UC_X86_REG_R14,
    UC_X86_REG_R15,
    UC_X86_REG_ST0,
    UC_X86_REG_ST1,
    UC_X86_REG_ST2,
    UC_X86_REG_ST3,
    UC_X86_REG_ST4,
    UC_X86_REG_ST5,
    UC_X86_REG_ST6,
    UC_X86_REG_ST7,
    UC_X86_REG_XMM0,
    UC_X86_REG_XMM1,
    UC_X86_REG_XMM2,
    UC_X86_REG_XMM3,
    UC_X86_REG_XMM4,
    UC_X86_REG_XMM5,
    UC_X86_REG_XMM6,
    UC_X86_REG_XMM7,
    UC_X86_REG_XMM8,
    UC_X86_REG_XMM9,
    UC_X86_REG_XMM10,
    UC_X86_REG_XMM11,
    UC_X86_REG_XMM12,
    UC_X86_REG_XMM13,
    UC_X86_REG_XMM14,
    UC_X86_REG_XMM15,
    UC_X86_REG_XMM16,
    UC_X86_REG_XMM17,
    UC_X86_REG_XMM18,
    UC_X86_REG_XMM19,
    UC_X86_REG_XMM20,
    UC_X86_REG_XMM21,
    UC_X86_REG_XMM22,
    UC_X86_REG_XMM23,
    UC_X86_REG_XMM24,
    UC_X86_REG_XMM25,
    UC_X86_REG_XMM26,
    UC_X86_REG_XMM27,
    UC_X86_REG_XMM28,
    UC_X86_REG_XMM29,
    UC_X86_REG_XMM30,
    UC_X86_REG_XMM31,
    UC_X86_REG_YMM0,
    UC_X86_REG_YMM1,
    UC_X86_REG_YMM2,
    UC_X86_REG_YMM3,
    UC_X86_REG_YMM4,
    UC_X86_REG_YMM5,
    UC_X86_REG_YMM6,
    UC_X86_REG_YMM7,
    UC_X86_REG_YMM8,
    UC_X86_REG_YMM9,
    UC_X86_REG_YMM10,
    UC_X86_REG_YMM11,
    UC_X86_REG_YMM12,
    UC_X86_REG_YMM13,
    UC_X86_REG_YMM14,
    UC_X86_REG_YMM15,
    UC_X86_REG_YMM16,
    UC_X86_REG_YMM17,
    UC_X86_REG_YMM18,
    UC_X86_REG_YMM19,
    UC_X86_REG_YMM20,
    UC_X86_REG_YMM21,
    UC_X86_REG_YMM22,
    UC_X86_REG_YMM23,
    UC_X86_REG_YMM24,
    UC_X86_REG_YMM25,
    UC_X86_REG_YMM26,
    UC_X86_REG_YMM27,
    UC_X86_REG_YMM28,
    UC_X86_REG_YMM29,
    UC_X86_REG_YMM30,
    UC_X86_REG_YMM31,
    UC_X86_REG_ZMM0,
    UC_X86_REG_ZMM1,
    UC_X86_REG_ZMM2,
    UC_X86_REG_ZMM3,
    UC_X86_REG_ZMM4,
    UC_X86_REG_ZMM5,
    UC_X86_REG_ZMM6,
    UC_X86_REG_ZMM7,
    UC_X86_REG_ZMM8,
    UC_X86_REG_ZMM9,
    UC_X86_REG_ZMM10,
    UC_X86_REG_ZMM11,
    UC_X86_REG_ZMM12,
    UC_X86_REG_ZMM13,
    UC_X86_REG_ZMM14,
    UC_X86_REG_ZMM15,
    UC_X86_REG_ZMM16,
    UC_X86_REG_ZMM17,
    UC_X86_REG_ZMM18,
    UC_X86_REG_ZMM19,
    UC_X86_REG_ZMM20,
    UC_X86_REG_ZMM21,
    UC_X86_REG_ZMM22,
    UC_X86_REG_ZMM23,
    UC_X86_REG_ZMM24,
    UC_X86_REG_ZMM25,
    UC_X86_REG_ZMM26,
    UC_X86_REG_ZMM27,
    UC_X86_REG_ZMM28,
    UC_X86_REG_ZMM29,
    UC_X86_REG_ZMM30,
    UC_X86_REG_ZMM31,
    UC_X86_REG_R8B,
    UC_X86_REG_R9B,
    UC_X86_REG_R10B,
    UC_X86_REG_R11B,
    UC_X86_REG_R12B,
    UC_X86_REG_R13B,
    UC_X86_REG_R14B,
    UC_X86_REG_R15B,
    UC_X86_REG_R8D,
    UC_X86_REG_R9D,
    UC_X86_REG_R10D,
    UC_X86_REG_R11D,
    UC_X86_REG_R12D,
    UC_X86_REG_R13D,
    UC_X86_REG_R14D,
    UC_X86_REG_R15D,
    UC_X86_REG_R8W,
    UC_X86_REG_R9W,
    UC_X86_REG_R10W,
    UC_X86_REG_R11W,
    UC_X86_REG_R12W,
    UC_X86_REG_R13W,
    UC_X86_REG_R14W,
    UC_X86_REG_R15W,
    UC_X86_REG_IDTR,
    UC_X86_REG_GDTR,
    UC_X86_REG_LDTR,
    UC_X86_REG_TR,
    UC_X86_REG_FPCW,
    UC_X86_REG_FPTAG,
    UC_X86_REG_MSR, // Model-Specific Register
    UC_X86_REG_MXCSR,
    UC_X86_REG_FS_BASE, // Base regs for x86_64
    UC_X86_REG_GS_BASE,
    UC_X86_REG_FLAGS,
    UC_X86_REG_RFLAGS,
    UC_X86_REG_FIP,
    UC_X86_REG_FCS,
    UC_X86_REG_FDP,
    UC_X86_REG_FDS,
    UC_X86_REG_FOP,
    UC_X86_REG_ENDING // <-- mark the end of the list of registers
} uc_x86_reg;

//> X86 instructions
typedef enum uc_x86_insn {
    UC_X86_INS_INVALID = 0,

    UC_X86_INS_AAA,
    UC_X86_INS_AAD,
    UC_X86_INS_AAM,
    UC_X86_INS_AAS,
    UC_X86_INS_FABS,
    UC_X86_INS_ADC,
    UC_X86_INS_ADCX,
    UC_X86_INS_ADD,
    UC_X86_INS_ADDPD,
    UC_X86_INS_ADDPS,
    UC_X86_INS_ADDSD,
    UC_X86_INS_ADDSS,
    UC_X86_INS_ADDSUBPD,
    UC_X86_INS_ADDSUBPS,
    UC_X86_INS_FADD,
    UC_X86_INS_FIADD,
    UC_X86_INS_FADDP,
    UC_X86_INS_ADOX,
    UC_X86_INS_AESDECLAST,
    UC_X86_INS_AESDEC,
    UC_X86_INS_AESENCLAST,
    UC_X86_INS_AESENC,
    UC_X86_INS_AESIMC,
    UC_X86_INS_AESKEYGENASSIST,
    UC_X86_INS_AND,
    UC_X86_INS_ANDN,
    UC_X86_INS_ANDNPD,
    UC_X86_INS_ANDNPS,
    UC_X86_INS_ANDPD,
    UC_X86_INS_ANDPS,
    UC_X86_INS_ARPL,
    UC_X86_INS_BEXTR,
    UC_X86_INS_BLCFILL,
    UC_X86_INS_BLCI,
    UC_X86_INS_BLCIC,
    UC_X86_INS_BLCMSK,
    UC_X86_INS_BLCS,
    UC_X86_INS_BLENDPD,
    UC_X86_INS_BLENDPS,
    UC_X86_INS_BLENDVPD,
    UC_X86_INS_BLENDVPS,
    UC_X86_INS_BLSFILL,
    UC_X86_INS_BLSI,
    UC_X86_INS_BLSIC,
    UC_X86_INS_BLSMSK,
    UC_X86_INS_BLSR,
    UC_X86_INS_BOUND,
    UC_X86_INS_BSF,
    UC_X86_INS_BSR,
    UC_X86_INS_BSWAP,
    UC_X86_INS_BT,
    UC_X86_INS_BTC,
    UC_X86_INS_BTR,
    UC_X86_INS_BTS,
    UC_X86_INS_BZHI,
    UC_X86_INS_CALL,
    UC_X86_INS_CBW,
    UC_X86_INS_CDQ,
    UC_X86_INS_CDQE,
    UC_X86_INS_FCHS,
    UC_X86_INS_CLAC,
    UC_X86_INS_CLC,
    UC_X86_INS_CLD,
    UC_X86_INS_CLFLUSH,
    UC_X86_INS_CLFLUSHOPT,
    UC_X86_INS_CLGI,
    UC_X86_INS_CLI,
    UC_X86_INS_CLTS,
    UC_X86_INS_CLWB,
    UC_X86_INS_CMC,
    UC_X86_INS_CMOVA,
    UC_X86_INS_CMOVAE,
    UC_X86_INS_CMOVB,
    UC_X86_INS_CMOVBE,
    UC_X86_INS_FCMOVBE,
    UC_X86_INS_FCMOVB,
    UC_X86_INS_CMOVE,
    UC_X86_INS_FCMOVE,
    UC_X86_INS_CMOVG,
    UC_X86_INS_CMOVGE,
    UC_X86_INS_CMOVL,
    UC_X86_INS_CMOVLE,
    UC_X86_INS_FCMOVNBE,
    UC_X86_INS_FCMOVNB,
    UC_X86_INS_CMOVNE,
    UC_X86_INS_FCMOVNE,
    UC_X86_INS_CMOVNO,
    UC_X86_INS_CMOVNP,
    UC_X86_INS_FCMOVNU,
    UC_X86_INS_CMOVNS,
    UC_X86_INS_CMOVO,
    UC_X86_INS_CMOVP,
    UC_X86_INS_FCMOVU,
    UC_X86_INS_CMOVS,
    UC_X86_INS_CMP,
    UC_X86_INS_CMPPD,
    UC_X86_INS_CMPPS,
    UC_X86_INS_CMPSB,
    UC_X86_INS_CMPSD,
    UC_X86_INS_CMPSQ,
    UC_X86_INS_CMPSS,
    UC_X86_INS_CMPSW,
    UC_X86_INS_CMPXCHG16B,
    UC_X86_INS_CMPXCHG,
    UC_X86_INS_CMPXCHG8B,
    UC_X86_INS_COMISD,
    UC_X86_INS_COMISS,
    UC_X86_INS_FCOMP,
    UC_X86_INS_FCOMPI,
    UC_X86_INS_FCOMI,
    UC_X86_INS_FCOM,
    UC_X86_INS_FCOS,
    UC_X86_INS_CPUID,
    UC_X86_INS_CQO,
    UC_X86_INS_CRC32,
    UC_X86_INS_CVTDQ2PD,
    UC_X86_INS_CVTDQ2PS,
    UC_X86_INS_CVTPD2DQ,
    UC_X86_INS_CVTPD2PS,
    UC_X86_INS_CVTPS2DQ,
    UC_X86_INS_CVTPS2PD,
    UC_X86_INS_CVTSD2SI,
    UC_X86_INS_CVTSD2SS,
    UC_X86_INS_CVTSI2SD,
    UC_X86_INS_CVTSI2SS,
    UC_X86_INS_CVTSS2SD,
    UC_X86_INS_CVTSS2SI,
    UC_X86_INS_CVTTPD2DQ,
    UC_X86_INS_CVTTPS2DQ,
    UC_X86_INS_CVTTSD2SI,
    UC_X86_INS_CVTTSS2SI,
    UC_X86_INS_CWD,
    UC_X86_INS_CWDE,
    UC_X86_INS_DAA,
    UC_X86_INS_DAS,
    UC_X86_INS_DATA16,
    UC_X86_INS_DEC,
    UC_X86_INS_DIV,
    UC_X86_INS_DIVPD,
    UC_X86_INS_DIVPS,
    UC_X86_INS_FDIVR,
    UC_X86_INS_FIDIVR,
    UC_X86_INS_FDIVRP,
    UC_X86_INS_DIVSD,
    UC_X86_INS_DIVSS,
    UC_X86_INS_FDIV,
    UC_X86_INS_FIDIV,
    UC_X86_INS_FDIVP,
    UC_X86_INS_DPPD,
    UC_X86_INS_DPPS,
    UC_X86_INS_RET,
    UC_X86_INS_ENCLS,
    UC_X86_INS_ENCLU,
    UC_X86_INS_ENTER,
    UC_X86_INS_EXTRACTPS,
    UC_X86_INS_EXTRQ,
    UC_X86_INS_F2XM1,
    UC_X86_INS_LCALL,
    UC_X86_INS_LJMP,
    UC_X86_INS_FBLD,
    UC_X86_INS_FBSTP,
    UC_X86_INS_FCOMPP,
    UC_X86_INS_FDECSTP,
    UC_X86_INS_FEMMS,
    UC_X86_INS_FFREE,
    UC_X86_INS_FICOM,
    UC_X86_INS_FICOMP,
    UC_X86_INS_FINCSTP,
    UC_X86_INS_FLDCW,
    UC_X86_INS_FLDENV,
    UC_X86_INS_FLDL2E,
    UC_X86_INS_FLDL2T,
    UC_X86_INS_FLDLG2,
    UC_X86_INS_FLDLN2,
    UC_X86_INS_FLDPI,
    UC_X86_INS_FNCLEX,
    UC_X86_INS_FNINIT,
    UC_X86_INS_FNOP,
    UC_X86_INS_FNSTCW,
    UC_X86_INS_FNSTSW,
    UC_X86_INS_FPATAN,
    UC_X86_INS_FPREM,
    UC_X86_INS_FPREM1,
    UC_X86_INS_FPTAN,
    UC_X86_INS_FFREEP,
    UC_X86_INS_FRNDINT,
    UC_X86_INS_FRSTOR,
    UC_X86_INS_FNSAVE,
    UC_X86_INS_FSCALE,
    UC_X86_INS_FSETPM,
    UC_X86_INS_FSINCOS,
    UC_X86_INS_FNSTENV,
    UC_X86_INS_FXAM,
    UC_X86_INS_FXRSTOR,
    UC_X86_INS_FXRSTOR64,
    UC_X86_INS_FXSAVE,
    UC_X86_INS_FXSAVE64,
    UC_X86_INS_FXTRACT,
    UC_X86_INS_FYL2X,
    UC_X86_INS_FYL2XP1,
    UC_X86_INS_MOVAPD,
    UC_X86_INS_MOVAPS,
    UC_X86_INS_ORPD,
    UC_X86_INS_ORPS,
    UC_X86_INS_VMOVAPD,
    UC_X86_INS_VMOVAPS,
    UC_X86_INS_XORPD,
    UC_X86_INS_XORPS,
    UC_X86_INS_GETSEC,
    UC_X86_INS_HADDPD,
    UC_X86_INS_HADDPS,
    UC_X86_INS_HLT,
    UC_X86_INS_HSUBPD,
    UC_X86_INS_HSUBPS,
    UC_X86_INS_IDIV,
    UC_X86_INS_FILD,
    UC_X86_INS_IMUL,
    UC_X86_INS_IN,
    UC_X86_INS_INC,
    UC_X86_INS_INSB,
    UC_X86_INS_INSERTPS,
    UC_X86_INS_INSERTQ,
    UC_X86_INS_INSD,
    UC_X86_INS_INSW,
    UC_X86_INS_INT,
    UC_X86_INS_INT1,
    UC_X86_INS_INT3,
    UC_X86_INS_INTO,
    UC_X86_INS_INVD,
    UC_X86_INS_INVEPT,
    UC_X86_INS_INVLPG,
    UC_X86_INS_INVLPGA,
    UC_X86_INS_INVPCID,
    UC_X86_INS_INVVPID,
    UC_X86_INS_IRET,
    UC_X86_INS_IRETD,
    UC_X86_INS_IRETQ,
    UC_X86_INS_FISTTP,
    UC_X86_INS_FIST,
    UC_X86_INS_FISTP,
    UC_X86_INS_UCOMISD,
    UC_X86_INS_UCOMISS,
    UC_X86_INS_VCOMISD,
    UC_X86_INS_VCOMISS,
    UC_X86_INS_VCVTSD2SS,
    UC_X86_INS_VCVTSI2SD,
    UC_X86_INS_VCVTSI2SS,
    UC_X86_INS_VCVTSS2SD,
    UC_X86_INS_VCVTTSD2SI,
    UC_X86_INS_VCVTTSD2USI,
    UC_X86_INS_VCVTTSS2SI,
    UC_X86_INS_VCVTTSS2USI,
    UC_X86_INS_VCVTUSI2SD,
    UC_X86_INS_VCVTUSI2SS,
    UC_X86_INS_VUCOMISD,
    UC_X86_INS_VUCOMISS,
    UC_X86_INS_JAE,
    UC_X86_INS_JA,
    UC_X86_INS_JBE,
    UC_X86_INS_JB,
    UC_X86_INS_JCXZ,
    UC_X86_INS_JECXZ,
    UC_X86_INS_JE,
    UC_X86_INS_JGE,
    UC_X86_INS_JG,
    UC_X86_INS_JLE,
    UC_X86_INS_JL,
    UC_X86_INS_JMP,
    UC_X86_INS_JNE,
    UC_X86_INS_JNO,
    UC_X86_INS_JNP,
    UC_X86_INS_JNS,
    UC_X86_INS_JO,
    UC_X86_INS_JP,
    UC_X86_INS_JRCXZ,
    UC_X86_INS_JS,
    UC_X86_INS_KANDB,
    UC_X86_INS_KANDD,
    UC_X86_INS_KANDNB,
    UC_X86_INS_KANDND,
    UC_X86_INS_KANDNQ,
    UC_X86_INS_KANDNW,
    UC_X86_INS_KANDQ,
    UC_X86_INS_KANDW,
    UC_X86_INS_KMOVB,
    UC_X86_INS_KMOVD,
    UC_X86_INS_KMOVQ,
    UC_X86_INS_KMOVW,
    UC_X86_INS_KNOTB,
    UC_X86_INS_KNOTD,
    UC_X86_INS_KNOTQ,
    UC_X86_INS_KNOTW,
    UC_X86_INS_KORB,
    UC_X86_INS_KORD,
    UC_X86_INS_KORQ,
    UC_X86_INS_KORTESTB,
    UC_X86_INS_KORTESTD,
    UC_X86_INS_KORTESTQ,
    UC_X86_INS_KORTESTW,
    UC_X86_INS_KORW,
    UC_X86_INS_KSHIFTLB,
    UC_X86_INS_KSHIFTLD,
    UC_X86_INS_KSHIFTLQ,
    UC_X86_INS_KSHIFTLW,
    UC_X86_INS_KSHIFTRB,
    UC_X86_INS_KSHIFTRD,
    UC_X86_INS_KSHIFTRQ,
    UC_X86_INS_KSHIFTRW,
    UC_X86_INS_KUNPCKBW,
    UC_X86_INS_KXNORB,
    UC_X86_INS_KXNORD,
    UC_X86_INS_KXNORQ,
    UC_X86_INS_KXNORW,
    UC_X86_INS_KXORB,
    UC_X86_INS_KXORD,
    UC_X86_INS_KXORQ,
    UC_X86_INS_KXORW,
    UC_X86_INS_LAHF,
    UC_X86_INS_LAR,
    UC_X86_INS_LDDQU,
    UC_X86_INS_LDMXCSR,
    UC_X86_INS_LDS,
    UC_X86_INS_FLDZ,
    UC_X86_INS_FLD1,
    UC_X86_INS_FLD,
    UC_X86_INS_LEA,
    UC_X86_INS_LEAVE,
    UC_X86_INS_LES,
    UC_X86_INS_LFENCE,
    UC_X86_INS_LFS,
    UC_X86_INS_LGDT,
    UC_X86_INS_LGS,
    UC_X86_INS_LIDT,
    UC_X86_INS_LLDT,
    UC_X86_INS_LMSW,
    UC_X86_INS_OR,
    UC_X86_INS_SUB,
    UC_X86_INS_XOR,
    UC_X86_INS_LODSB,
    UC_X86_INS_LODSD,
    UC_X86_INS_LODSQ,
    UC_X86_INS_LODSW,
    UC_X86_INS_LOOP,
    UC_X86_INS_LOOPE,
    UC_X86_INS_LOOPNE,
    UC_X86_INS_RETF,
    UC_X86_INS_RETFQ,
    UC_X86_INS_LSL,
    UC_X86_INS_LSS,
    UC_X86_INS_LTR,
    UC_X86_INS_XADD,
    UC_X86_INS_LZCNT,
    UC_X86_INS_MASKMOVDQU,
    UC_X86_INS_MAXPD,
    UC_X86_INS_MAXPS,
    UC_X86_INS_MAXSD,
    UC_X86_INS_MAXSS,
    UC_X86_INS_MFENCE,
    UC_X86_INS_MINPD,
    UC_X86_INS_MINPS,
    UC_X86_INS_MINSD,
    UC_X86_INS_MINSS,
    UC_X86_INS_CVTPD2PI,
    UC_X86_INS_CVTPI2PD,
    UC_X86_INS_CVTPI2PS,
    UC_X86_INS_CVTPS2PI,
    UC_X86_INS_CVTTPD2PI,
    UC_X86_INS_CVTTPS2PI,
    UC_X86_INS_EMMS,
    UC_X86_INS_MASKMOVQ,
    UC_X86_INS_MOVD,
    UC_X86_INS_MOVDQ2Q,
    UC_X86_INS_MOVNTQ,
    UC_X86_INS_MOVQ2DQ,
    UC_X86_INS_MOVQ,
    UC_X86_INS_PABSB,
    UC_X86_INS_PABSD,
    UC_X86_INS_PABSW,
    UC_X86_INS_PACKSSDW,
    UC_X86_INS_PACKSSWB,
    UC_X86_INS_PACKUSWB,
    UC_X86_INS_PADDB,
    UC_X86_INS_PADDD,
    UC_X86_INS_PADDQ,
    UC_X86_INS_PADDSB,
    UC_X86_INS_PADDSW,
    UC_X86_INS_PADDUSB,
    UC_X86_INS_PADDUSW,
    UC_X86_INS_PADDW,
    UC_X86_INS_PALIGNR,
    UC_X86_INS_PANDN,
    UC_X86_INS_PAND,
    UC_X86_INS_PAVGB,
    UC_X86_INS_PAVGW,
    UC_X86_INS_PCMPEQB,
    UC_X86_INS_PCMPEQD,
    UC_X86_INS_PCMPEQW,
    UC_X86_INS_PCMPGTB,
    UC_X86_INS_PCMPGTD,
    UC_X86_INS_PCMPGTW,
    UC_X86_INS_PEXTRW,
    UC_X86_INS_PHADDSW,
    UC_X86_INS_PHADDW,
    UC_X86_INS_PHADDD,
    UC_X86_INS_PHSUBD,
    UC_X86_INS_PHSUBSW,
    UC_X86_INS_PHSUBW,
    UC_X86_INS_PINSRW,
    UC_X86_INS_PMADDUBSW,
    UC_X86_INS_PMADDWD,
    UC_X86_INS_PMAXSW,
    UC_X86_INS_PMAXUB,
    UC_X86_INS_PMINSW,
    UC_X86_INS_PMINUB,
    UC_X86_INS_PMOVMSKB,
    UC_X86_INS_PMULHRSW,
    UC_X86_INS_PMULHUW,
    UC_X86_INS_PMULHW,
    UC_X86_INS_PMULLW,
    UC_X86_INS_PMULUDQ,
    UC_X86_INS_POR,
    UC_X86_INS_PSADBW,
    UC_X86_INS_PSHUFB,
    UC_X86_INS_PSHUFW,
    UC_X86_INS_PSIGNB,
    UC_X86_INS_PSIGND,
    UC_X86_INS_PSIGNW,
    UC_X86_INS_PSLLD,
    UC_X86_INS_PSLLQ,
    UC_X86_INS_PSLLW,
    UC_X86_INS_PSRAD,
    UC_X86_INS_PSRAW,
    UC_X86_INS_PSRLD,
    UC_X86_INS_PSRLQ,
    UC_X86_INS_PSRLW,
    UC_X86_INS_PSUBB,
    UC_X86_INS_PSUBD,
    UC_X86_INS_PSUBQ,
    UC_X86_INS_PSUBSB,
    UC_X86_INS_PSUBSW,
    UC_X86_INS_PSUBUSB,
    UC_X86_INS_PSUBUSW,
    UC_X86_INS_PSUBW,
    UC_X86_INS_PUNPCKHBW,
    UC_X86_INS_PUNPCKHDQ,
    UC_X86_INS_PUNPCKHWD,
    UC_X86_INS_PUNPCKLBW,
    UC_X86_INS_PUNPCKLDQ,
    UC_X86_INS_PUNPCKLWD,
    UC_X86_INS_PXOR,
    UC_X86_INS_MONITOR,
    UC_X86_INS_MONTMUL,
    UC_X86_INS_MOV,
    UC_X86_INS_MOVABS,
    UC_X86_INS_MOVBE,
    UC_X86_INS_MOVDDUP,
    UC_X86_INS_MOVDQA,
    UC_X86_INS_MOVDQU,
    UC_X86_INS_MOVHLPS,
    UC_X86_INS_MOVHPD,
    UC_X86_INS_MOVHPS,
    UC_X86_INS_MOVLHPS,
    UC_X86_INS_MOVLPD,
    UC_X86_INS_MOVLPS,
    UC_X86_INS_MOVMSKPD,
    UC_X86_INS_MOVMSKPS,
    UC_X86_INS_MOVNTDQA,
    UC_X86_INS_MOVNTDQ,
    UC_X86_INS_MOVNTI,
    UC_X86_INS_MOVNTPD,
    UC_X86_INS_MOVNTPS,
    UC_X86_INS_MOVNTSD,
    UC_X86_INS_MOVNTSS,
    UC_X86_INS_MOVSB,
    UC_X86_INS_MOVSD,
    UC_X86_INS_MOVSHDUP,
    UC_X86_INS_MOVSLDUP,
    UC_X86_INS_MOVSQ,
    UC_X86_INS_MOVSS,
    UC_X86_INS_MOVSW,
    UC_X86_INS_MOVSX,
    UC_X86_INS_MOVSXD,
    UC_X86_INS_MOVUPD,
    UC_X86_INS_MOVUPS,
    UC_X86_INS_MOVZX,
    UC_X86_INS_MPSADBW,
    UC_X86_INS_MUL,
    UC_X86_INS_MULPD,
    UC_X86_INS_MULPS,
    UC_X86_INS_MULSD,
    UC_X86_INS_MULSS,
    UC_X86_INS_MULX,
    UC_X86_INS_FMUL,
    UC_X86_INS_FIMUL,
    UC_X86_INS_FMULP,
    UC_X86_INS_MWAIT,
    UC_X86_INS_NEG,
    UC_X86_INS_NOP,
    UC_X86_INS_NOT,
    UC_X86_INS_OUT,
    UC_X86_INS_OUTSB,
    UC_X86_INS_OUTSD,
    UC_X86_INS_OUTSW,
    UC_X86_INS_PACKUSDW,
    UC_X86_INS_PAUSE,
    UC_X86_INS_PAVGUSB,
    UC_X86_INS_PBLENDVB,
    UC_X86_INS_PBLENDW,
    UC_X86_INS_PCLMULQDQ,
    UC_X86_INS_PCMPEQQ,
    UC_X86_INS_PCMPESTRI,
    UC_X86_INS_PCMPESTRM,
    UC_X86_INS_PCMPGTQ,
    UC_X86_INS_PCMPISTRI,
    UC_X86_INS_PCMPISTRM,
    UC_X86_INS_PCOMMIT,
    UC_X86_INS_PDEP,
    UC_X86_INS_PEXT,
    UC_X86_INS_PEXTRB,
    UC_X86_INS_PEXTRD,
    UC_X86_INS_PEXTRQ,
    UC_X86_INS_PF2ID,
    UC_X86_INS_PF2IW,
    UC_X86_INS_PFACC,
    UC_X86_INS_PFADD,
    UC_X86_INS_PFCMPEQ,
    UC_X86_INS_PFCMPGE,
    UC_X86_INS_PFCMPGT,
    UC_X86_INS_PFMAX,
    UC_X86_INS_PFMIN,
    UC_X86_INS_PFMUL,
    UC_X86_INS_PFNACC,
    UC_X86_INS_PFPNACC,
    UC_X86_INS_PFRCPIT1,
    UC_X86_INS_PFRCPIT2,
    UC_X86_INS_PFRCP,
    UC_X86_INS_PFRSQIT1,
    UC_X86_INS_PFRSQRT,
    UC_X86_INS_PFSUBR,
    UC_X86_INS_PFSUB,
    UC_X86_INS_PHMINPOSUW,
    UC_X86_INS_PI2FD,
    UC_X86_INS_PI2FW,
    UC_X86_INS_PINSRB,
    UC_X86_INS_PINSRD,
    UC_X86_INS_PINSRQ,
    UC_X86_INS_PMAXSB,
    UC_X86_INS_PMAXSD,
    UC_X86_INS_PMAXUD,
    UC_X86_INS_PMAXUW,
    UC_X86_INS_PMINSB,
    UC_X86_INS_PMINSD,
    UC_X86_INS_PMINUD,
    UC_X86_INS_PMINUW,
    UC_X86_INS_PMOVSXBD,
    UC_X86_INS_PMOVSXBQ,
    UC_X86_INS_PMOVSXBW,
    UC_X86_INS_PMOVSXDQ,
    UC_X86_INS_PMOVSXWD,
    UC_X86_INS_PMOVSXWQ,
    UC_X86_INS_PMOVZXBD,
    UC_X86_INS_PMOVZXBQ,
    UC_X86_INS_PMOVZXBW,
    UC_X86_INS_PMOVZXDQ,
    UC_X86_INS_PMOVZXWD,
    UC_X86_INS_PMOVZXWQ,
    UC_X86_INS_PMULDQ,
    UC_X86_INS_PMULHRW,
    UC_X86_INS_PMULLD,
    UC_X86_INS_POP,
    UC_X86_INS_POPAW,
    UC_X86_INS_POPAL,
    UC_X86_INS_POPCNT,
    UC_X86_INS_POPF,
    UC_X86_INS_POPFD,
    UC_X86_INS_POPFQ,
    UC_X86_INS_PREFETCH,
    UC_X86_INS_PREFETCHNTA,
    UC_X86_INS_PREFETCHT0,
    UC_X86_INS_PREFETCHT1,
    UC_X86_INS_PREFETCHT2,
    UC_X86_INS_PREFETCHW,
    UC_X86_INS_PSHUFD,
    UC_X86_INS_PSHUFHW,
    UC_X86_INS_PSHUFLW,
    UC_X86_INS_PSLLDQ,
    UC_X86_INS_PSRLDQ,
    UC_X86_INS_PSWAPD,
    UC_X86_INS_PTEST,
    UC_X86_INS_PUNPCKHQDQ,
    UC_X86_INS_PUNPCKLQDQ,
    UC_X86_INS_PUSH,
    UC_X86_INS_PUSHAW,
    UC_X86_INS_PUSHAL,
    UC_X86_INS_PUSHF,
    UC_X86_INS_PUSHFD,
    UC_X86_INS_PUSHFQ,
    UC_X86_INS_RCL,
    UC_X86_INS_RCPPS,
    UC_X86_INS_RCPSS,
    UC_X86_INS_RCR,
    UC_X86_INS_RDFSBASE,
    UC_X86_INS_RDGSBASE,
    UC_X86_INS_RDMSR,
    UC_X86_INS_RDPMC,
    UC_X86_INS_RDRAND,
    UC_X86_INS_RDSEED,
    UC_X86_INS_RDTSC,
    UC_X86_INS_RDTSCP,
    UC_X86_INS_ROL,
    UC_X86_INS_ROR,
    UC_X86_INS_RORX,
    UC_X86_INS_ROUNDPD,
    UC_X86_INS_ROUNDPS,
    UC_X86_INS_ROUNDSD,
    UC_X86_INS_ROUNDSS,
    UC_X86_INS_RSM,
    UC_X86_INS_RSQRTPS,
    UC_X86_INS_RSQRTSS,
    UC_X86_INS_SAHF,
    UC_X86_INS_SAL,
    UC_X86_INS_SALC,
    UC_X86_INS_SAR,
    UC_X86_INS_SARX,
    UC_X86_INS_SBB,
    UC_X86_INS_SCASB,
    UC_X86_INS_SCASD,
    UC_X86_INS_SCASQ,
    UC_X86_INS_SCASW,
    UC_X86_INS_SETAE,
    UC_X86_INS_SETA,
    UC_X86_INS_SETBE,
    UC_X86_INS_SETB,
    UC_X86_INS_SETE,
    UC_X86_INS_SETGE,
    UC_X86_INS_SETG,
    UC_X86_INS_SETLE,
    UC_X86_INS_SETL,
    UC_X86_INS_SETNE,
    UC_X86_INS_SETNO,
    UC_X86_INS_SETNP,
    UC_X86_INS_SETNS,
    UC_X86_INS_SETO,
    UC_X86_INS_SETP,
    UC_X86_INS_SETS,
    UC_X86_INS_SFENCE,
    UC_X86_INS_SGDT,
    UC_X86_INS_SHA1MSG1,
    UC_X86_INS_SHA1MSG2,
    UC_X86_INS_SHA1NEXTE,
    UC_X86_INS_SHA1RNDS4,
    UC_X86_INS_SHA256MSG1,
    UC_X86_INS_SHA256MSG2,
    UC_X86_INS_SHA256RNDS2,
    UC_X86_INS_SHL,
    UC_X86_INS_SHLD,
    UC_X86_INS_SHLX,
    UC_X86_INS_SHR,
    UC_X86_INS_SHRD,
    UC_X86_INS_SHRX,
    UC_X86_INS_SHUFPD,
    UC_X86_INS_SHUFPS,
    UC_X86_INS_SIDT,
    UC_X86_INS_FSIN,
    UC_X86_INS_SKINIT,
    UC_X86_INS_SLDT,
    UC_X86_INS_SMSW,
    UC_X86_INS_SQRTPD,
    UC_X86_INS_SQRTPS,
    UC_X86_INS_SQRTSD,
    UC_X86_INS_SQRTSS,
    UC_X86_INS_FSQRT,
    UC_X86_INS_STAC,
    UC_X86_INS_STC,
    UC_X86_INS_STD,
    UC_X86_INS_STGI,
    UC_X86_INS_STI,
    UC_X86_INS_STMXCSR,
    UC_X86_INS_STOSB,
    UC_X86_INS_STOSD,
    UC_X86_INS_STOSQ,
    UC_X86_INS_STOSW,
    UC_X86_INS_STR,
    UC_X86_INS_FST,
    UC_X86_INS_FSTP,
    UC_X86_INS_FSTPNCE,
    UC_X86_INS_FXCH,
    UC_X86_INS_SUBPD,
    UC_X86_INS_SUBPS,
    UC_X86_INS_FSUBR,
    UC_X86_INS_FISUBR,
    UC_X86_INS_FSUBRP,
    UC_X86_INS_SUBSD,
    UC_X86_INS_SUBSS,
    UC_X86_INS_FSUB,
    UC_X86_INS_FISUB,
    UC_X86_INS_FSUBP,
    UC_X86_INS_SWAPGS,
    UC_X86_INS_SYSCALL,
    UC_X86_INS_SYSENTER,
    UC_X86_INS_SYSEXIT,
    UC_X86_INS_SYSRET,
    UC_X86_INS_T1MSKC,
    UC_X86_INS_TEST,
    UC_X86_INS_UD2,
    UC_X86_INS_FTST,
    UC_X86_INS_TZCNT,
    UC_X86_INS_TZMSK,
    UC_X86_INS_FUCOMPI,
    UC_X86_INS_FUCOMI,
    UC_X86_INS_FUCOMPP,
    UC_X86_INS_FUCOMP,
    UC_X86_INS_FUCOM,
    UC_X86_INS_UD2B,
    UC_X86_INS_UNPCKHPD,
    UC_X86_INS_UNPCKHPS,
    UC_X86_INS_UNPCKLPD,
    UC_X86_INS_UNPCKLPS,
    UC_X86_INS_VADDPD,
    UC_X86_INS_VADDPS,
    UC_X86_INS_VADDSD,
    UC_X86_INS_VADDSS,
    UC_X86_INS_VADDSUBPD,
    UC_X86_INS_VADDSUBPS,
    UC_X86_INS_VAESDECLAST,
    UC_X86_INS_VAESDEC,
    UC_X86_INS_VAESENCLAST,
    UC_X86_INS_VAESENC,
    UC_X86_INS_VAESIMC,
    UC_X86_INS_VAESKEYGENASSIST,
    UC_X86_INS_VALIGND,
    UC_X86_INS_VALIGNQ,
    UC_X86_INS_VANDNPD,
    UC_X86_INS_VANDNPS,
    UC_X86_INS_VANDPD,
    UC_X86_INS_VANDPS,
    UC_X86_INS_VBLENDMPD,
    UC_X86_INS_VBLENDMPS,
    UC_X86_INS_VBLENDPD,
    UC_X86_INS_VBLENDPS,
    UC_X86_INS_VBLENDVPD,
    UC_X86_INS_VBLENDVPS,
    UC_X86_INS_VBROADCASTF128,
    UC_X86_INS_VBROADCASTI32X4,
    UC_X86_INS_VBROADCASTI64X4,
    UC_X86_INS_VBROADCASTSD,
    UC_X86_INS_VBROADCASTSS,
    UC_X86_INS_VCMPPD,
    UC_X86_INS_VCMPPS,
    UC_X86_INS_VCMPSD,
    UC_X86_INS_VCMPSS,
    UC_X86_INS_VCOMPRESSPD,
    UC_X86_INS_VCOMPRESSPS,
    UC_X86_INS_VCVTDQ2PD,
    UC_X86_INS_VCVTDQ2PS,
    UC_X86_INS_VCVTPD2DQX,
    UC_X86_INS_VCVTPD2DQ,
    UC_X86_INS_VCVTPD2PSX,
    UC_X86_INS_VCVTPD2PS,
    UC_X86_INS_VCVTPD2UDQ,
    UC_X86_INS_VCVTPH2PS,
    UC_X86_INS_VCVTPS2DQ,
    UC_X86_INS_VCVTPS2PD,
    UC_X86_INS_VCVTPS2PH,
    UC_X86_INS_VCVTPS2UDQ,
    UC_X86_INS_VCVTSD2SI,
    UC_X86_INS_VCVTSD2USI,
    UC_X86_INS_VCVTSS2SI,
    UC_X86_INS_VCVTSS2USI,
    UC_X86_INS_VCVTTPD2DQX,
    UC_X86_INS_VCVTTPD2DQ,
    UC_X86_INS_VCVTTPD2UDQ,
    UC_X86_INS_VCVTTPS2DQ,
    UC_X86_INS_VCVTTPS2UDQ,
    UC_X86_INS_VCVTUDQ2PD,
    UC_X86_INS_VCVTUDQ2PS,
    UC_X86_INS_VDIVPD,
    UC_X86_INS_VDIVPS,
    UC_X86_INS_VDIVSD,
    UC_X86_INS_VDIVSS,
    UC_X86_INS_VDPPD,
    UC_X86_INS_VDPPS,
    UC_X86_INS_VERR,
    UC_X86_INS_VERW,
    UC_X86_INS_VEXP2PD,
    UC_X86_INS_VEXP2PS,
    UC_X86_INS_VEXPANDPD,
    UC_X86_INS_VEXPANDPS,
    UC_X86_INS_VEXTRACTF128,
    UC_X86_INS_VEXTRACTF32X4,
    UC_X86_INS_VEXTRACTF64X4,
    UC_X86_INS_VEXTRACTI128,
    UC_X86_INS_VEXTRACTI32X4,
    UC_X86_INS_VEXTRACTI64X4,
    UC_X86_INS_VEXTRACTPS,
    UC_X86_INS_VFMADD132PD,
    UC_X86_INS_VFMADD132PS,
    UC_X86_INS_VFMADDPD,
    UC_X86_INS_VFMADD213PD,
    UC_X86_INS_VFMADD231PD,
    UC_X86_INS_VFMADDPS,
    UC_X86_INS_VFMADD213PS,
    UC_X86_INS_VFMADD231PS,
    UC_X86_INS_VFMADDSD,
    UC_X86_INS_VFMADD213SD,
    UC_X86_INS_VFMADD132SD,
    UC_X86_INS_VFMADD231SD,
    UC_X86_INS_VFMADDSS,
    UC_X86_INS_VFMADD213SS,
    UC_X86_INS_VFMADD132SS,
    UC_X86_INS_VFMADD231SS,
    UC_X86_INS_VFMADDSUB132PD,
    UC_X86_INS_VFMADDSUB132PS,
    UC_X86_INS_VFMADDSUBPD,
    UC_X86_INS_VFMADDSUB213PD,
    UC_X86_INS_VFMADDSUB231PD,
    UC_X86_INS_VFMADDSUBPS,
    UC_X86_INS_VFMADDSUB213PS,
    UC_X86_INS_VFMADDSUB231PS,
    UC_X86_INS_VFMSUB132PD,
    UC_X86_INS_VFMSUB132PS,
    UC_X86_INS_VFMSUBADD132PD,
    UC_X86_INS_VFMSUBADD132PS,
    UC_X86_INS_VFMSUBADDPD,
    UC_X86_INS_VFMSUBADD213PD,
    UC_X86_INS_VFMSUBADD231PD,
    UC_X86_INS_VFMSUBADDPS,
    UC_X86_INS_VFMSUBADD213PS,
    UC_X86_INS_VFMSUBADD231PS,
    UC_X86_INS_VFMSUBPD,
    UC_X86_INS_VFMSUB213PD,
    UC_X86_INS_VFMSUB231PD,
    UC_X86_INS_VFMSUBPS,
    UC_X86_INS_VFMSUB213PS,
    UC_X86_INS_VFMSUB231PS,
    UC_X86_INS_VFMSUBSD,
    UC_X86_INS_VFMSUB213SD,
    UC_X86_INS_VFMSUB132SD,
    UC_X86_INS_VFMSUB231SD,
    UC_X86_INS_VFMSUBSS,
    UC_X86_INS_VFMSUB213SS,
    UC_X86_INS_VFMSUB132SS,
    UC_X86_INS_VFMSUB231SS,
    UC_X86_INS_VFNMADD132PD,
    UC_X86_INS_VFNMADD132PS,
    UC_X86_INS_VFNMADDPD,
    UC_X86_INS_VFNMADD213PD,
    UC_X86_INS_VFNMADD231PD,
    UC_X86_INS_VFNMADDPS,
    UC_X86_INS_VFNMADD213PS,
    UC_X86_INS_VFNMADD231PS,
    UC_X86_INS_VFNMADDSD,
    UC_X86_INS_VFNMADD213SD,
    UC_X86_INS_VFNMADD132SD,
    UC_X86_INS_VFNMADD231SD,
    UC_X86_INS_VFNMADDSS,
    UC_X86_INS_VFNMADD213SS,
    UC_X86_INS_VFNMADD132SS,
    UC_X86_INS_VFNMADD231SS,
    UC_X86_INS_VFNMSUB132PD,
    UC_X86_INS_VFNMSUB132PS,
    UC_X86_INS_VFNMSUBPD,
    UC_X86_INS_VFNMSUB213PD,
    UC_X86_INS_VFNMSUB231PD,
    UC_X86_INS_VFNMSUBPS,
    UC_X86_INS_VFNMSUB213PS,
    UC_X86_INS_VFNMSUB231PS,
    UC_X86_INS_VFNMSUBSD,
    UC_X86_INS_VFNMSUB213SD,
    UC_X86_INS_VFNMSUB132SD,
    UC_X86_INS_VFNMSUB231SD,
    UC_X86_INS_VFNMSUBSS,
    UC_X86_INS_VFNMSUB213SS,
    UC_X86_INS_VFNMSUB132SS,
    UC_X86_INS_VFNMSUB231SS,
    UC_X86_INS_VFRCZPD,
    UC_X86_INS_VFRCZPS,
    UC_X86_INS_VFRCZSD,
    UC_X86_INS_VFRCZSS,
    UC_X86_INS_VORPD,
    UC_X86_INS_VORPS,
    UC_X86_INS_VXORPD,
    UC_X86_INS_VXORPS,
    UC_X86_INS_VGATHERDPD,
    UC_X86_INS_VGATHERDPS,
    UC_X86_INS_VGATHERPF0DPD,
    UC_X86_INS_VGATHERPF0DPS,
    UC_X86_INS_VGATHERPF0QPD,
    UC_X86_INS_VGATHERPF0QPS,
    UC_X86_INS_VGATHERPF1DPD,
    UC_X86_INS_VGATHERPF1DPS,
    UC_X86_INS_VGATHERPF1QPD,
    UC_X86_INS_VGATHERPF1QPS,
    UC_X86_INS_VGATHERQPD,
    UC_X86_INS_VGATHERQPS,
    UC_X86_INS_VHADDPD,
    UC_X86_INS_VHADDPS,
    UC_X86_INS_VHSUBPD,
    UC_X86_INS_VHSUBPS,
    UC_X86_INS_VINSERTF128,
    UC_X86_INS_VINSERTF32X4,
    UC_X86_INS_VINSERTF32X8,
    UC_X86_INS_VINSERTF64X2,
    UC_X86_INS_VINSERTF64X4,
    UC_X86_INS_VINSERTI128,
    UC_X86_INS_VINSERTI32X4,
    UC_X86_INS_VINSERTI32X8,
    UC_X86_INS_VINSERTI64X2,
    UC_X86_INS_VINSERTI64X4,
    UC_X86_INS_VINSERTPS,
    UC_X86_INS_VLDDQU,
    UC_X86_INS_VLDMXCSR,
    UC_X86_INS_VMASKMOVDQU,
    UC_X86_INS_VMASKMOVPD,
    UC_X86_INS_VMASKMOVPS,
    UC_X86_INS_VMAXPD,
    UC_X86_INS_VMAXPS,
    UC_X86_INS_VMAXSD,
    UC_X86_INS_VMAXSS,
    UC_X86_INS_VMCALL,
    UC_X86_INS_VMCLEAR,
    UC_X86_INS_VMFUNC,
    UC_X86_INS_VMINPD,
    UC_X86_INS_VMINPS,
    UC_X86_INS_VMINSD,
    UC_X86_INS_VMINSS,
    UC_X86_INS_VMLAUNCH,
    UC_X86_INS_VMLOAD,
    UC_X86_INS_VMMCALL,
    UC_X86_INS_VMOVQ,
    UC_X86_INS_VMOVDDUP,
    UC_X86_INS_VMOVD,
    UC_X86_INS_VMOVDQA32,
    UC_X86_INS_VMOVDQA64,
    UC_X86_INS_VMOVDQA,
    UC_X86_INS_VMOVDQU16,
    UC_X86_INS_VMOVDQU32,
    UC_X86_INS_VMOVDQU64,
    UC_X86_INS_VMOVDQU8,
    UC_X86_INS_VMOVDQU,
    UC_X86_INS_VMOVHLPS,
    UC_X86_INS_VMOVHPD,
    UC_X86_INS_VMOVHPS,
    UC_X86_INS_VMOVLHPS,
    UC_X86_INS_VMOVLPD,
    UC_X86_INS_VMOVLPS,
    UC_X86_INS_VMOVMSKPD,
    UC_X86_INS_VMOVMSKPS,
    UC_X86_INS_VMOVNTDQA,
    UC_X86_INS_VMOVNTDQ,
    UC_X86_INS_VMOVNTPD,
    UC_X86_INS_VMOVNTPS,
    UC_X86_INS_VMOVSD,
    UC_X86_INS_VMOVSHDUP,
    UC_X86_INS_VMOVSLDUP,
    UC_X86_INS_VMOVSS,
    UC_X86_INS_VMOVUPD,
    UC_X86_INS_VMOVUPS,
    UC_X86_INS_VMPSADBW,
    UC_X86_INS_VMPTRLD,
    UC_X86_INS_VMPTRST,
    UC_X86_INS_VMREAD,
    UC_X86_INS_VMRESUME,
    UC_X86_INS_VMRUN,
    UC_X86_INS_VMSAVE,
    UC_X86_INS_VMULPD,
    UC_X86_INS_VMULPS,
    UC_X86_INS_VMULSD,
    UC_X86_INS_VMULSS,
    UC_X86_INS_VMWRITE,
    UC_X86_INS_VMXOFF,
    UC_X86_INS_VMXON,
    UC_X86_INS_VPABSB,
    UC_X86_INS_VPABSD,
    UC_X86_INS_VPABSQ,
    UC_X86_INS_VPABSW,
    UC_X86_INS_VPACKSSDW,
    UC_X86_INS_VPACKSSWB,
    UC_X86_INS_VPACKUSDW,
    UC_X86_INS_VPACKUSWB,
    UC_X86_INS_VPADDB,
    UC_X86_INS_VPADDD,
    UC_X86_INS_VPADDQ,
    UC_X86_INS_VPADDSB,
    UC_X86_INS_VPADDSW,
    UC_X86_INS_VPADDUSB,
    UC_X86_INS_VPADDUSW,
    UC_X86_INS_VPADDW,
    UC_X86_INS_VPALIGNR,
    UC_X86_INS_VPANDD,
    UC_X86_INS_VPANDND,
    UC_X86_INS_VPANDNQ,
    UC_X86_INS_VPANDN,
    UC_X86_INS_VPANDQ,
    UC_X86_INS_VPAND,
    UC_X86_INS_VPAVGB,
    UC_X86_INS_VPAVGW,
    UC_X86_INS_VPBLENDD,
    UC_X86_INS_VPBLENDMB,
    UC_X86_INS_VPBLENDMD,
    UC_X86_INS_VPBLENDMQ,
    UC_X86_INS_VPBLENDMW,
    UC_X86_INS_VPBLENDVB,
    UC_X86_INS_VPBLENDW,
    UC_X86_INS_VPBROADCASTB,
    UC_X86_INS_VPBROADCASTD,
    UC_X86_INS_VPBROADCASTMB2Q,
    UC_X86_INS_VPBROADCASTMW2D,
    UC_X86_INS_VPBROADCASTQ,
    UC_X86_INS_VPBROADCASTW,
    UC_X86_INS_VPCLMULQDQ,
    UC_X86_INS_VPCMOV,
    UC_X86_INS_VPCMPB,
    UC_X86_INS_VPCMPD,
    UC_X86_INS_VPCMPEQB,
    UC_X86_INS_VPCMPEQD,
    UC_X86_INS_VPCMPEQQ,
    UC_X86_INS_VPCMPEQW,
    UC_X86_INS_VPCMPESTRI,
    UC_X86_INS_VPCMPESTRM,
    UC_X86_INS_VPCMPGTB,
    UC_X86_INS_VPCMPGTD,
    UC_X86_INS_VPCMPGTQ,
    UC_X86_INS_VPCMPGTW,
    UC_X86_INS_VPCMPISTRI,
    UC_X86_INS_VPCMPISTRM,
    UC_X86_INS_VPCMPQ,
    UC_X86_INS_VPCMPUB,
    UC_X86_INS_VPCMPUD,
    UC_X86_INS_VPCMPUQ,
    UC_X86_INS_VPCMPUW,
    UC_X86_INS_VPCMPW,
    UC_X86_INS_VPCOMB,
    UC_X86_INS_VPCOMD,
    UC_X86_INS_VPCOMPRESSD,
    UC_X86_INS_VPCOMPRESSQ,
    UC_X86_INS_VPCOMQ,
    UC_X86_INS_VPCOMUB,
    UC_X86_INS_VPCOMUD,
    UC_X86_INS_VPCOMUQ,
    UC_X86_INS_VPCOMUW,
    UC_X86_INS_VPCOMW,
    UC_X86_INS_VPCONFLICTD,
    UC_X86_INS_VPCONFLICTQ,
    UC_X86_INS_VPERM2F128,
    UC_X86_INS_VPERM2I128,
    UC_X86_INS_VPERMD,
    UC_X86_INS_VPERMI2D,
    UC_X86_INS_VPERMI2PD,
    UC_X86_INS_VPERMI2PS,
    UC_X86_INS_VPERMI2Q,
    UC_X86_INS_VPERMIL2PD,
    UC_X86_INS_VPERMIL2PS,
    UC_X86_INS_VPERMILPD,
    UC_X86_INS_VPERMILPS,
    UC_X86_INS_VPERMPD,
    UC_X86_INS_VPERMPS,
    UC_X86_INS_VPERMQ,
    UC_X86_INS_VPERMT2D,
    UC_X86_INS_VPERMT2PD,
    UC_X86_INS_VPERMT2PS,
    UC_X86_INS_VPERMT2Q,
    UC_X86_INS_VPEXPANDD,
    UC_X86_INS_VPEXPANDQ,
    UC_X86_INS_VPEXTRB,
    UC_X86_INS_VPEXTRD,
    UC_X86_INS_VPEXTRQ,
    UC_X86_INS_VPEXTRW,
    UC_X86_INS_VPGATHERDD,
    UC_X86_INS_VPGATHERDQ,
    UC_X86_INS_VPGATHERQD,
    UC_X86_INS_VPGATHERQQ,
    UC_X86_INS_VPHADDBD,
    UC_X86_INS_VPHADDBQ,
    UC_X86_INS_VPHADDBW,
    UC_X86_INS_VPHADDDQ,
    UC_X86_INS_VPHADDD,
    UC_X86_INS_VPHADDSW,
    UC_X86_INS_VPHADDUBD,
    UC_X86_INS_VPHADDUBQ,
    UC_X86_INS_VPHADDUBW,
    UC_X86_INS_VPHADDUDQ,
    UC_X86_INS_VPHADDUWD,
    UC_X86_INS_VPHADDUWQ,
    UC_X86_INS_VPHADDWD,
    UC_X86_INS_VPHADDWQ,
    UC_X86_INS_VPHADDW,
    UC_X86_INS_VPHMINPOSUW,
    UC_X86_INS_VPHSUBBW,
    UC_X86_INS_VPHSUBDQ,
    UC_X86_INS_VPHSUBD,
    UC_X86_INS_VPHSUBSW,
    UC_X86_INS_VPHSUBWD,
    UC_X86_INS_VPHSUBW,
    UC_X86_INS_VPINSRB,
    UC_X86_INS_VPINSRD,
    UC_X86_INS_VPINSRQ,
    UC_X86_INS_VPINSRW,
    UC_X86_INS_VPLZCNTD,
    UC_X86_INS_VPLZCNTQ,
    UC_X86_INS_VPMACSDD,
    UC_X86_INS_VPMACSDQH,
    UC_X86_INS_VPMACSDQL,
    UC_X86_INS_VPMACSSDD,
    UC_X86_INS_VPMACSSDQH,
    UC_X86_INS_VPMACSSDQL,
    UC_X86_INS_VPMACSSWD,
    UC_X86_INS_VPMACSSWW,
    UC_X86_INS_VPMACSWD,
    UC_X86_INS_VPMACSWW,
    UC_X86_INS_VPMADCSSWD,
    UC_X86_INS_VPMADCSWD,
    UC_X86_INS_VPMADDUBSW,
    UC_X86_INS_VPMADDWD,
    UC_X86_INS_VPMASKMOVD,
    UC_X86_INS_VPMASKMOVQ,
    UC_X86_INS_VPMAXSB,
    UC_X86_INS_VPMAXSD,
    UC_X86_INS_VPMAXSQ,
    UC_X86_INS_VPMAXSW,
    UC_X86_INS_VPMAXUB,
    UC_X86_INS_VPMAXUD,
    UC_X86_INS_VPMAXUQ,
    UC_X86_INS_VPMAXUW,
    UC_X86_INS_VPMINSB,
    UC_X86_INS_VPMINSD,
    UC_X86_INS_VPMINSQ,
    UC_X86_INS_VPMINSW,
    UC_X86_INS_VPMINUB,
    UC_X86_INS_VPMINUD,
    UC_X86_INS_VPMINUQ,
    UC_X86_INS_VPMINUW,
    UC_X86_INS_VPMOVDB,
    UC_X86_INS_VPMOVDW,
    UC_X86_INS_VPMOVM2B,
    UC_X86_INS_VPMOVM2D,
    UC_X86_INS_VPMOVM2Q,
    UC_X86_INS_VPMOVM2W,
    UC_X86_INS_VPMOVMSKB,
    UC_X86_INS_VPMOVQB,
    UC_X86_INS_VPMOVQD,
    UC_X86_INS_VPMOVQW,
    UC_X86_INS_VPMOVSDB,
    UC_X86_INS_VPMOVSDW,
    UC_X86_INS_VPMOVSQB,
    UC_X86_INS_VPMOVSQD,
    UC_X86_INS_VPMOVSQW,
    UC_X86_INS_VPMOVSXBD,
    UC_X86_INS_VPMOVSXBQ,
    UC_X86_INS_VPMOVSXBW,
    UC_X86_INS_VPMOVSXDQ,
    UC_X86_INS_VPMOVSXWD,
    UC_X86_INS_VPMOVSXWQ,
    UC_X86_INS_VPMOVUSDB,
    UC_X86_INS_VPMOVUSDW,
    UC_X86_INS_VPMOVUSQB,
    UC_X86_INS_VPMOVUSQD,
    UC_X86_INS_VPMOVUSQW,
    UC_X86_INS_VPMOVZXBD,
    UC_X86_INS_VPMOVZXBQ,
    UC_X86_INS_VPMOVZXBW,
    UC_X86_INS_VPMOVZXDQ,
    UC_X86_INS_VPMOVZXWD,
    UC_X86_INS_VPMOVZXWQ,
    UC_X86_INS_VPMULDQ,
    UC_X86_INS_VPMULHRSW,
    UC_X86_INS_VPMULHUW,
    UC_X86_INS_VPMULHW,
    UC_X86_INS_VPMULLD,
    UC_X86_INS_VPMULLQ,
    UC_X86_INS_VPMULLW,
    UC_X86_INS_VPMULUDQ,
    UC_X86_INS_VPORD,
    UC_X86_INS_VPORQ,
    UC_X86_INS_VPOR,
    UC_X86_INS_VPPERM,
    UC_X86_INS_VPROTB,
    UC_X86_INS_VPROTD,
    UC_X86_INS_VPROTQ,
    UC_X86_INS_VPROTW,
    UC_X86_INS_VPSADBW,
    UC_X86_INS_VPSCATTERDD,
    UC_X86_INS_VPSCATTERDQ,
    UC_X86_INS_VPSCATTERQD,
    UC_X86_INS_VPSCATTERQQ,
    UC_X86_INS_VPSHAB,
    UC_X86_INS_VPSHAD,
    UC_X86_INS_VPSHAQ,
    UC_X86_INS_VPSHAW,
    UC_X86_INS_VPSHLB,
    UC_X86_INS_VPSHLD,
    UC_X86_INS_VPSHLQ,
    UC_X86_INS_VPSHLW,
    UC_X86_INS_VPSHUFB,
    UC_X86_INS_VPSHUFD,
    UC_X86_INS_VPSHUFHW,
    UC_X86_INS_VPSHUFLW,
    UC_X86_INS_VPSIGNB,
    UC_X86_INS_VPSIGND,
    UC_X86_INS_VPSIGNW,
    UC_X86_INS_VPSLLDQ,
    UC_X86_INS_VPSLLD,
    UC_X86_INS_VPSLLQ,
    UC_X86_INS_VPSLLVD,
    UC_X86_INS_VPSLLVQ,
    UC_X86_INS_VPSLLW,
    UC_X86_INS_VPSRAD,
    UC_X86_INS_VPSRAQ,
    UC_X86_INS_VPSRAVD,
    UC_X86_INS_VPSRAVQ,
    UC_X86_INS_VPSRAW,
    UC_X86_INS_VPSRLDQ,
    UC_X86_INS_VPSRLD,
    UC_X86_INS_VPSRLQ,
    UC_X86_INS_VPSRLVD,
    UC_X86_INS_VPSRLVQ,
    UC_X86_INS_VPSRLW,
    UC_X86_INS_VPSUBB,
    UC_X86_INS_VPSUBD,
    UC_X86_INS_VPSUBQ,
    UC_X86_INS_VPSUBSB,
    UC_X86_INS_VPSUBSW,
    UC_X86_INS_VPSUBUSB,
    UC_X86_INS_VPSUBUSW,
    UC_X86_INS_VPSUBW,
    UC_X86_INS_VPTESTMD,
    UC_X86_INS_VPTESTMQ,
    UC_X86_INS_VPTESTNMD,
    UC_X86_INS_VPTESTNMQ,
    UC_X86_INS_VPTEST,
    UC_X86_INS_VPUNPCKHBW,
    UC_X86_INS_VPUNPCKHDQ,
    UC_X86_INS_VPUNPCKHQDQ,
    UC_X86_INS_VPUNPCKHWD,
    UC_X86_INS_VPUNPCKLBW,
    UC_X86_INS_VPUNPCKLDQ,
    UC_X86_INS_VPUNPCKLQDQ,
    UC_X86_INS_VPUNPCKLWD,
    UC_X86_INS_VPXORD,
    UC_X86_INS_VPXORQ,
    UC_X86_INS_VPXOR,
    UC_X86_INS_VRCP14PD,
    UC_X86_INS_VRCP14PS,
    UC_X86_INS_VRCP14SD,
    UC_X86_INS_VRCP14SS,
    UC_X86_INS_VRCP28PD,
    UC_X86_INS_VRCP28PS,
    UC_X86_INS_VRCP28SD,
    UC_X86_INS_VRCP28SS,
    UC_X86_INS_VRCPPS,
    UC_X86_INS_VRCPSS,
    UC_X86_INS_VRNDSCALEPD,
    UC_X86_INS_VRNDSCALEPS,
    UC_X86_INS_VRNDSCALESD,
    UC_X86_INS_VRNDSCALESS,
    UC_X86_INS_VROUNDPD,
    UC_X86_INS_VROUNDPS,
    UC_X86_INS_VROUNDSD,
    UC_X86_INS_VROUNDSS,
    UC_X86_INS_VRSQRT14PD,
    UC_X86_INS_VRSQRT14PS,
    UC_X86_INS_VRSQRT14SD,
    UC_X86_INS_VRSQRT14SS,
    UC_X86_INS_VRSQRT28PD,
    UC_X86_INS_VRSQRT28PS,
    UC_X86_INS_VRSQRT28SD,
    UC_X86_INS_VRSQRT28SS,
    UC_X86_INS_VRSQRTPS,
    UC_X86_INS_VRSQRTSS,
    UC_X86_INS_VSCATTERDPD,
    UC_X86_INS_VSCATTERDPS,
    UC_X86_INS_VSCATTERPF0DPD,
    UC_X86_INS_VSCATTERPF0DPS,
    UC_X86_INS_VSCATTERPF0QPD,
    UC_X86_INS_VSCATTERPF0QPS,
    UC_X86_INS_VSCATTERPF1DPD,
    UC_X86_INS_VSCATTERPF1DPS,
    UC_X86_INS_VSCATTERPF1QPD,
    UC_X86_INS_VSCATTERPF1QPS,
    UC_X86_INS_VSCATTERQPD,
    UC_X86_INS_VSCATTERQPS,
    UC_X86_INS_VSHUFPD,
    UC_X86_INS_VSHUFPS,
    UC_X86_INS_VSQRTPD,
    UC_X86_INS_VSQRTPS,
    UC_X86_INS_VSQRTSD,
    UC_X86_INS_VSQRTSS,
    UC_X86_INS_VSTMXCSR,
    UC_X86_INS_VSUBPD,
    UC_X86_INS_VSUBPS,
    UC_X86_INS_VSUBSD,
    UC_X86_INS_VSUBSS,
    UC_X86_INS_VTESTPD,
    UC_X86_INS_VTESTPS,
    UC_X86_INS_VUNPCKHPD,
    UC_X86_INS_VUNPCKHPS,
    UC_X86_INS_VUNPCKLPD,
    UC_X86_INS_VUNPCKLPS,
    UC_X86_INS_VZEROALL,
    UC_X86_INS_VZEROUPPER,
    UC_X86_INS_WAIT,
    UC_X86_INS_WBINVD,
    UC_X86_INS_WRFSBASE,
    UC_X86_INS_WRGSBASE,
    UC_X86_INS_WRMSR,
    UC_X86_INS_XABORT,
    UC_X86_INS_XACQUIRE,
    UC_X86_INS_XBEGIN,
    UC_X86_INS_XCHG,
    UC_X86_INS_XCRYPTCBC,
    UC_X86_INS_XCRYPTCFB,
    UC_X86_INS_XCRYPTCTR,
    UC_X86_INS_XCRYPTECB,
    UC_X86_INS_XCRYPTOFB,
    UC_X86_INS_XEND,
    UC_X86_INS_XGETBV,
    UC_X86_INS_XLATB,
    UC_X86_INS_XRELEASE,
    UC_X86_INS_XRSTOR,
    UC_X86_INS_XRSTOR64,
    UC_X86_INS_XRSTORS,
    UC_X86_INS_XRSTORS64,
    UC_X86_INS_XSAVE,
    UC_X86_INS_XSAVE64,
    UC_X86_INS_XSAVEC,
    UC_X86_INS_XSAVEC64,
    UC_X86_INS_XSAVEOPT,
    UC_X86_INS_XSAVEOPT64,
    UC_X86_INS_XSAVES,
    UC_X86_INS_XSAVES64,
    UC_X86_INS_XSETBV,
    UC_X86_INS_XSHA1,
    UC_X86_INS_XSHA256,
    UC_X86_INS_XSTORE,
    UC_X86_INS_XTEST,
    UC_X86_INS_FDISI8087_NOP,
    UC_X86_INS_FENI8087_NOP,

    UC_X86_INS_ENDING, // mark the end of the list of insn
} uc_x86_insn;

#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/kdmp-parser/filemap.h`:

```h
// Axel '0vercl0k' Souchet - April 28 2020
#include "platform.h"
#include <cstdint>
#include <cstdio>

#if defined(LINUX)
#include <errno.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#endif

namespace kdmpparser {
namespace Page {

//
// Page size.
//

constexpr uint64_t Size = 0x1000;

//
// Page align an address.
//

constexpr uint64_t Align(const uint64_t Address) { return Address & ~0xfff; }

//
// Extract the page offset off an address.
//

constexpr uint64_t Offset(const uint64_t Address) { return Address & 0xfff; }
} // namespace Page

#if defined(WINDOWS)
class FileMap_t {
  //
  // Handle to the input file.
  //

  HANDLE File_ = nullptr;

  //
  // Handle to the file mapping.
  //

  HANDLE FileMap_ = nullptr;

  //
  // Base address of the file view.
  //

  PVOID ViewBase_ = nullptr;

  //
  // File size
  //

  uint64_t FileSize_ = 0;

public:
  ~FileMap_t() {
    //
    // Unmap the view of the mapping..
    //

    if (ViewBase_ != nullptr) {
      UnmapViewOfFile(ViewBase_);
      ViewBase_ = nullptr;
    }

    //
    // Close the handle to the file mapping..
    //

    if (FileMap_ != nullptr) {
      CloseHandle(FileMap_);
      FileMap_ = nullptr;
    }

    //
    // And finally the file itself.
    //

    if (File_ != nullptr) {
      CloseHandle(File_);
      File_ = nullptr;
    }
  }

  FileMap_t() = default;
  FileMap_t(const FileMap_t &) = delete;
  FileMap_t &operator=(const FileMap_t &) = delete;

  constexpr void *ViewBase() const { return ViewBase_; }

  bool MapFile(const char *PathFile) {
    bool Success = true;
    HANDLE File = nullptr;
    HANDLE FileMap = nullptr;
    PVOID ViewBase = nullptr;
    LARGE_INTEGER FileSize = {0};

    //
    // Open the dump file in read-only.
    //

    File = CreateFileA(PathFile, GENERIC_READ, FILE_SHARE_READ, nullptr,
                       OPEN_EXISTING, 0, nullptr);

    if (File == nullptr) {

      //
      // If we fail to open the file, let the user know.
      //

      const DWORD GLE = GetLastError();
      printf("CreateFile failed with GLE=%lu.\n", GLE);

      if (GLE == ERROR_FILE_NOT_FOUND) {
        printf("  The file %s was not found.\n", PathFile);
      }

      Success = false;
      goto clean;
    }

    //
    // Create the ro file mapping.
    //

    FileMap = CreateFileMappingA(File, nullptr, PAGE_READONLY, 0, 0, nullptr);

    if (FileMap == nullptr) {

      //
      // If we fail to create a file mapping, let
      // the user know.
      //

      const DWORD GLE = GetLastError();
      printf("CreateFileMapping failed with GLE=%lu.\n", GLE);
      Success = false;
      goto clean;
    }

    //
    // Map a view of the file in memory.
    //

    ViewBase = MapViewOfFile(FileMap, FILE_MAP_READ, 0, 0, 0);

    if (ViewBase == nullptr) {

      //
      // If we fail to map the view, let the user know.
      //

      const DWORD GLE = GetLastError();
      printf("MapViewOfFile failed with GLE=%lu.\n", GLE);
      Success = false;
      goto clean;
    }

    //
    // Get the file size.
    //

    if (!GetFileSizeEx(File, &FileSize)) {
      const DWORD GLE = GetLastError();
      printf("GetFileSizeEx failed with GLE=%lu.\n", GLE);
      Success = false;
      goto clean;
    }

    FileSize_ = Page::Align(FileSize.QuadPart) + Page::Size;

    //
    // Everything went well, so grab a copy of the handles for
    // our class and null-out the temporary variables.
    //

    File_ = File;
    File = nullptr;

    FileMap_ = FileMap;
    FileMap = nullptr;

    ViewBase_ = ViewBase;
    ViewBase = nullptr;

  clean:

    //
    // Close the handle to the file mapping..
    //

    if (FileMap != nullptr) {
      CloseHandle(FileMap);
      FileMap = nullptr;
    }

    //
    // And finally the file itself.
    //

    if (File != nullptr) {
      CloseHandle(File);
      File = nullptr;
    }

    return Success;
  }

  bool InBounds(const void *Ptr, const size_t Size) const {
    const uint8_t *ViewEnd = (uint8_t *)ViewBase_ + FileSize_;
    const uint8_t *PtrEnd = (uint8_t *)Ptr + Size;
    return PtrEnd > Ptr && ViewEnd > ViewBase_ && Ptr >= ViewBase_ &&
           PtrEnd < ViewEnd;
  }
};

#elif defined(LINUX)

class FileMap_t {
  void *ViewBase_ = nullptr;
  off_t ViewSize_ = 0;
  int Fd_ = -1;

public:
  ~FileMap_t() {
    if (ViewBase_) {
      munmap(ViewBase_, ViewSize_);
      ViewBase_ = nullptr;
      ViewSize_ = 0;
    }

    if (Fd_ != -1) {
      close(Fd_);
      Fd_ = -1;
    }
  }

  FileMap_t() = default;
  FileMap_t(const FileMap_t &) = delete;
  FileMap_t &operator=(const FileMap_t &) = delete;

  constexpr void *ViewBase() const { return ViewBase_; }

  bool MapFile(const char *PathFile) {
    Fd_ = open(PathFile, O_RDONLY);
    if (Fd_ < 0) {
      perror("Could not open dump file");
      return false;
    }

    struct stat Stat;
    if (fstat(Fd_, &Stat) < 0) {
      perror("Could not stat dump file");
      return false;
    }

    ViewSize_ = Page::Align(Stat.st_size) + Page::Size;
    ViewBase_ = mmap(nullptr, ViewSize_, PROT_READ, MAP_SHARED, Fd_, 0);
    if (ViewBase_ == MAP_FAILED) {
      perror("Could not mmap");
      return false;
    }

    return true;
  }

  bool InBounds(const void *Ptr, const size_t Size) const {
    const uint8_t *ViewEnd = (uint8_t *)ViewBase_ + ViewSize_;
    const uint8_t *PtrEnd = (uint8_t *)Ptr + Size;
    return PtrEnd > Ptr && ViewEnd > ViewBase_ && Ptr >= ViewBase_ &&
           PtrEnd < ViewEnd;
  }
};
#endif
} // namespace kdmpparser

```

`KDemu/kdmp-parser/kdmp-parser-structs.h`:

```h
// Axel '0vercl0k' Souchet - February 15 2019
#pragma once

#include "platform.h"
#include <array>
#include <cinttypes>
#include <cstddef>
#include <cstdint>
#include <cstdio>
#include <string_view>
#include <type_traits>
#include <variant>

namespace kdmpparser {

//
// We need a way to represent 128-bits integers so here goes.
//

struct uint128_t {
  uint64_t Low;
  uint64_t High;
};

static_assert(sizeof(uint128_t) == 16, "uint128_t's size looks wrong.");

enum class DumpType_t : uint32_t {
  // Old dump types from dbgeng.dll
  FullDump = 0x1,
  KernelDump = 0x2,
  BMPDump = 0x5,

  // New stuff
  MiniDump = 0x4,             // Produced by `.dump /m`
  LiveKernelBitmapDump = 0x6, // (22h2+) Produced by TaskMgr > System > Create
                              // Live Kernel Memory Dump
  KernelMemoryDump = 0x8,     // Produced by `.dump /k`
  KernelAndUserMemoryDump = 0x9, // Produced by `.dump /ka`
  CompleteMemoryDump = 0xa,      // Produced by `.dump /f`
};

//
// Save off the alignement setting and disable
// alignement.
//

#pragma pack(push)
#pragma pack(1)

//
// Field is a pointer inside the this object and this function
// returns the offset of Field in the object via pointer arithmetic.
//

constexpr uint64_t OffsetFromThis(const uintptr_t This, const uintptr_t Field) {
  return uint64_t(Field) - uint64_t(This);
}

static void DisplayHeader(const uint32_t Prefix, const char *FieldName,
                          const void *This, const void *Field) {
  printf("%*s+0x%04" PRIx64 ": %-25s", Prefix, "",
         OffsetFromThis(uintptr_t(This), uintptr_t(Field)), FieldName);
}

//
// This is the macro we use to get the field name via the preprocessor.
//

#define DISPLAY_FIELD(FieldName)                                               \
  DisplayField(Prefix + 2, #FieldName, this, &FieldName)

#define DISPLAY_FIELD_OFFSET(FieldName)                                        \
  DisplayHeader(Prefix + 2, #FieldName, this, &FieldName);                     \
  printf("\n")

//
// This takes care of displaying basic types.
//

constexpr std::string_view DumpTypeToString(const DumpType_t Type) {
  switch (Type) {
  // Old dump types from dbgeng.dll
  case DumpType_t::FullDump:
    return "FullDump";
  case DumpType_t::KernelDump:
    return "KernelDump";
  case DumpType_t::BMPDump:
    return "BMPDump";

  // New stuff
  case DumpType_t::MiniDump:
    return "MiniDump";
  case DumpType_t::LiveKernelBitmapDump:
    return "LiveKernelBitmapDump";
  case DumpType_t::KernelMemoryDump:
    return "KernelMemoryDump";
  case DumpType_t::KernelAndUserMemoryDump:
    return "KernelAndUserMemoryDump";
  case DumpType_t::CompleteMemoryDump:
    return "CompleteMemoryDump";
  }

  return "Unknown";
}

template <typename Field_t>
static void DisplayField(const uint32_t Prefix, const char *FieldName,
                         const void *This, const Field_t *Field) {
  DisplayHeader(Prefix, FieldName, This, Field);
  if constexpr (std::is_same<Field_t, uint8_t>::value) {
    printf(": 0x%02x.\n", *Field);
  } else if constexpr (std::is_same<Field_t, uint16_t>::value) {
    printf(": 0x%04x.\n", *Field);
  } else if constexpr (std::is_same<Field_t, uint32_t>::value) {
    printf(": 0x%08x.\n", *Field);
  } else if constexpr (std::is_same<Field_t, uint64_t>::value) {
    printf(": 0x%016" PRIx64 ".\n", *Field);
  } else if constexpr (std::is_same<Field_t, int64_t>::value) {
    printf(": 0x%016" PRIx64 ".\n", *Field);
  } else if constexpr (std::is_same<Field_t, uint128_t>::value) {
    printf(": 0x%016" PRIx64 "%016" PRIx64 ".\n", Field->High, Field->Low);
  } else if constexpr (std::is_same<Field_t, DumpType_t>::value) {
    printf(": %s.\n", DumpTypeToString(*Field).data());
  } else {

    //
    // We use std::is_same<> here because otherwise the static_assert fires
    // immediately on g++/clang++ without even instantiating FieldType_t.
    // So we kind of trick the compiler into doing what we want.
    //

    static_assert(std::is_same<Field_t, uint8_t>::value,
                  "DisplayField: Unknown type trying to be displayed.");
  }
}

//
// Display the header of a dump section.
//

#define DISPLAY_HEADER(Name) printf("%*s" Name "\n", Prefix, "")

//
// All credit goes to the rekall project for the RE of the file format.
// https://github.com/google/rekall/blob/master/rekall-core/rekall/plugins/overlays/windows/crashdump.py
//

struct PHYSMEM_RUN {
  uint64_t BasePage;
  uint64_t PageCount;

  void Show(const uint32_t Prefix = 0) const {
    DISPLAY_HEADER("PHYSMEM_RUN");
    DISPLAY_FIELD(BasePage);
    DISPLAY_FIELD(PageCount);
  }
};

static_assert(sizeof(PHYSMEM_RUN) == 0x10, "PHYSMEM_RUN's size looks wrong.");

struct PHYSMEM_DESC {
  uint32_t NumberOfRuns;
  uint32_t Padding0;
  uint64_t NumberOfPages;
  PHYSMEM_RUN Run[1];

  void Show(const uint32_t Prefix = 0) const {
    DISPLAY_HEADER("PHYSMEM_DESC");
    DISPLAY_FIELD(NumberOfRuns);
    DISPLAY_FIELD(NumberOfPages);
    DISPLAY_FIELD_OFFSET(Run);
    if (!LooksGood()) {
      return;
    }

    for (uint32_t RunIdx = 0; RunIdx < NumberOfRuns; RunIdx++) {
      Run[RunIdx].Show(Prefix + 2);
    }
  }

  constexpr bool LooksGood() const {
    if (NumberOfRuns == 0x45474150 || NumberOfPages == 0x4547415045474150ULL) {
      return false;
    }

    return true;
  }
};

static_assert(sizeof(PHYSMEM_DESC) == 0x20,
              "PHYSICAL_MEMORY_DESCRIPTOR's size looks wrong.");

struct BMP_HEADER64 {
  static constexpr uint32_t ExpectedSignature = 0x50'4D'44'53;  // 'PMDS'
  static constexpr uint32_t ExpectedSignature2 = 0x50'4D'44'46; // 'PMDF'
  static constexpr uint32_t ExpectedValidDump = 0x50'4D'55'44;  // 'PMUD'

  //
  // Should be FDMP.
  //

  uint32_t Signature;

  //
  // Should be DUMP.
  //

  uint32_t ValidDump;

  //
  // According to rekall there's a gap there:
  // 'ValidDump': [0x4, ['String', dict(
  //    length=4,
  //    term=None,
  //    )]],
  // # The offset of the first page in the file.
  // 'FirstPage': [0x20, ['unsigned long long']],
  //

  std::array<uint8_t, 0x20 - (0x4 + sizeof(ValidDump))> Padding0;

  //
  // The offset of the first page in the file.
  //

  uint64_t FirstPage;

  //
  // Total number of pages present in the bitmap.
  //
  uint64_t TotalPresentPages;

  //
  // Total number of pages in image.This dictates the total size of the
  // bitmap.This is not the same as the TotalPresentPages which is only
  // the sum of the bits set to 1.
  //

  uint64_t Pages;

  std::array<uint8_t, 1> Bitmap;

  bool LooksGood() const {

    //
    // Integrity check the headers.
    //

    if (Signature != ExpectedSignature && Signature != ExpectedSignature2) {
      printf("BMP_HEADER64::Signature looks wrong.\n");
      return false;
    }

    if (ValidDump != ExpectedValidDump) {
      printf("BMP_HEADER64::ValidDump looks wrong.\n");
      return false;
    }

    return true;
  }

  void Show(const uint32_t Prefix = 0) const {
    DISPLAY_HEADER("BMP_HEADER64");
    DISPLAY_FIELD(Signature);
    DISPLAY_FIELD(ValidDump);
    DISPLAY_FIELD(FirstPage);
    DISPLAY_FIELD(TotalPresentPages);
    DISPLAY_FIELD(Pages);
    DISPLAY_FIELD_OFFSET(Bitmap);
  }
};

static_assert(offsetof(BMP_HEADER64, FirstPage) == 0x20,
              "First page offset looks wrong.");

struct RDMP_HEADER64 {
  static constexpr uint32_t ExpectedMarker = 0x40;
  static constexpr uint32_t ExpectedSignature = 0x50'4D'44'52; // 'PMDR'
  static constexpr uint32_t ExpectedValidDump = 0x50'4D'55'44; // 'PMUD'

  uint32_t Marker;
  uint32_t Signature;
  uint32_t ValidDump;
  uint32_t __Unused;
  uint64_t MetadataSize;
  uint64_t FirstPageOffset;

  bool LooksGood() const {
    if (Marker != ExpectedMarker) {
      return false;
    }

    if (Signature != RDMP_HEADER64::ExpectedSignature) {
      return false;
    }

    if (ValidDump != RDMP_HEADER64::ExpectedValidDump) {
      return false;
    }

    if (MetadataSize - 0x20 !=
        FirstPageOffset -
            0x20'40) { // sizeof(HEADER64) + sizeof(RDMP_HEADERS64)
      return false;
    }

    return true;
  }

  void Show(const uint32_t Prefix = 0) const {
    DISPLAY_HEADER("RDMP_HEADER64");
    DISPLAY_FIELD(Signature);
    DISPLAY_FIELD(ValidDump);
    DISPLAY_FIELD(FirstPageOffset);
    DISPLAY_FIELD(MetadataSize);
  }
};

static_assert(sizeof(RDMP_HEADER64) == 0x20, "Invalid size for RDMP_HEADER64");

struct KERNEL_RDMP_HEADER64 {
  RDMP_HEADER64 Hdr;
  uint64_t __Unknown1;
  uint64_t __Unknown2;
  std::array<uint8_t, 1> Bitmap;
};

static_assert(sizeof(KERNEL_RDMP_HEADER64) == 0x30 + 1,
              "Invalid size for KERNEL_RDMP_HEADER64");

static_assert(offsetof(KERNEL_RDMP_HEADER64, Bitmap) == 0x30,
              "Invalid offset for KERNEL_RDMP_HEADER64");

struct FULL_RDMP_HEADER64 {
  RDMP_HEADER64 Hdr;
  uint32_t NumberOfRanges;
  uint16_t __Unknown1;
  uint16_t __Unknown2;
  uint64_t TotalNumberOfPages;
  std::array<uint8_t, 1> Bitmap;
};

static_assert(sizeof(FULL_RDMP_HEADER64) == 0x30 + 1,
              "Invalid size for FULL_RDMP_HEADER64");

static_assert(offsetof(FULL_RDMP_HEADER64, Bitmap) == 0x30,
              "Invalid offset for FULL_RDMP_HEADER64");

struct CONTEXT {

  //
  // Note that the below definition has been stolen directly from the windows
  // headers. Why you might ask? Well the structure comes with DECLSPEC_ALIGN
  // that was preventing me from layoung the Context structure at the offset I
  // wanted. Maybe there's a cleaner way to do this, if so let me know :)
  //

  //
  // Register parameter home addresses.
  //
  // N.B. These fields are for convience - they could be used to extend the
  //      context record in the future.
  //

  uint64_t P1Home;
  uint64_t P2Home;
  uint64_t P3Home;
  uint64_t P4Home;
  uint64_t P5Home;
  uint64_t P6Home;

  //
  // Control flags.
  //

  uint32_t ContextFlags;
  uint32_t MxCsr;

  //
  // Segment Registers and processor flags.
  //

  uint16_t SegCs;
  uint16_t SegDs;
  uint16_t SegEs;
  uint16_t SegFs;
  uint16_t SegGs;
  uint16_t SegSs;
  uint32_t EFlags;

  //
  // Debug registers
  //

  uint64_t Dr0;
  uint64_t Dr1;
  uint64_t Dr2;
  uint64_t Dr3;
  uint64_t Dr6;
  uint64_t Dr7;

  //
  // Integer registers.
  //

  uint64_t Rax;
  uint64_t Rcx;
  uint64_t Rdx;
  uint64_t Rbx;
  uint64_t Rsp;
  uint64_t Rbp;
  uint64_t Rsi;
  uint64_t Rdi;
  uint64_t R8;
  uint64_t R9;
  uint64_t R10;
  uint64_t R11;
  uint64_t R12;
  uint64_t R13;
  uint64_t R14;
  uint64_t R15;

  //
  // Program counter.
  //

  uint64_t Rip;

  //
  // Floating point state.
  //

  uint16_t ControlWord;
  uint16_t StatusWord;
  uint8_t TagWord;
  uint8_t Reserved1;
  uint16_t ErrorOpcode;
  uint32_t ErrorOffset;
  uint16_t ErrorSelector;
  uint16_t Reserved2;
  uint32_t DataOffset;
  uint16_t DataSelector;
  uint16_t Reserved3;
  uint32_t MxCsr2;
  uint32_t MxCsr_Mask;
  std::array<uint128_t, 8> FloatRegisters;
  uint128_t Xmm0;
  uint128_t Xmm1;
  uint128_t Xmm2;
  uint128_t Xmm3;
  uint128_t Xmm4;
  uint128_t Xmm5;
  uint128_t Xmm6;
  uint128_t Xmm7;
  uint128_t Xmm8;
  uint128_t Xmm9;
  uint128_t Xmm10;
  uint128_t Xmm11;
  uint128_t Xmm12;
  uint128_t Xmm13;
  uint128_t Xmm14;
  uint128_t Xmm15;

  //
  // Vector registers.
  //

  std::array<uint128_t, 26> VectorRegister;
  uint64_t VectorControl;

  //
  // Special debug control registers.
  //

  uint64_t DebugControl;
  uint64_t LastBranchToRip;
  uint64_t LastBranchFromRip;
  uint64_t LastExceptionToRip;
  uint64_t LastExceptionFromRip;

  bool LooksGood() const {

    //
    // Integrity check the CONTEXT record.
    //

    if (MxCsr != MxCsr2) {
      printf("CONTEXT::MxCsr doesn't match MxCsr2.\n");
      return false;
    }

    return true;
  }

  void Show(const uint32_t Prefix = 0) const {
    DISPLAY_HEADER("CONTEXT");
    DISPLAY_FIELD(P1Home);
    DISPLAY_FIELD(P2Home);
    DISPLAY_FIELD(P3Home);
    DISPLAY_FIELD(P4Home);
    DISPLAY_FIELD(P5Home);
    DISPLAY_FIELD(P6Home);

    //
    // Control flags.
    //

    DISPLAY_FIELD(ContextFlags);
    DISPLAY_FIELD(MxCsr);

    //
    // Segment Registers and processor flags.
    //

    DISPLAY_FIELD(SegCs);
    DISPLAY_FIELD(SegDs);
    DISPLAY_FIELD(SegEs);
    DISPLAY_FIELD(SegFs);
    DISPLAY_FIELD(SegGs);
    DISPLAY_FIELD(SegSs);
    DISPLAY_FIELD(EFlags);

    //
    // Debug registers.
    // XXX: Figure out what they don't look right.
    //

    DISPLAY_FIELD(Dr0);
    DISPLAY_FIELD(Dr1);
    DISPLAY_FIELD(Dr2);
    DISPLAY_FIELD(Dr3);
    DISPLAY_FIELD(Dr6);
    DISPLAY_FIELD(Dr7);

    //
    // Integer registers.
    //

    DISPLAY_FIELD(Rax);
    DISPLAY_FIELD(Rcx);
    DISPLAY_FIELD(Rdx);
    DISPLAY_FIELD(Rbx);
    DISPLAY_FIELD(Rsp);
    DISPLAY_FIELD(Rbp);
    DISPLAY_FIELD(Rsi);
    DISPLAY_FIELD(Rdi);
    DISPLAY_FIELD(R8);
    DISPLAY_FIELD(R9);
    DISPLAY_FIELD(R10);
    DISPLAY_FIELD(R11);
    DISPLAY_FIELD(R12);
    DISPLAY_FIELD(R13);
    DISPLAY_FIELD(R14);
    DISPLAY_FIELD(R15);

    //
    // Program counter.
    //

    DISPLAY_FIELD(Rip);

    //
    // Floating point state.
    //

    DISPLAY_FIELD(ControlWord);
    DISPLAY_FIELD(StatusWord);
    DISPLAY_FIELD(TagWord);
    DISPLAY_FIELD(ErrorOpcode);
    DISPLAY_FIELD(ErrorOffset);
    DISPLAY_FIELD(ErrorSelector);
    DISPLAY_FIELD(DataOffset);
    DISPLAY_FIELD(DataSelector);
    DISPLAY_FIELD(MxCsr2);
    DISPLAY_FIELD(MxCsr_Mask);
    DISPLAY_FIELD(FloatRegisters[0]);
    DISPLAY_FIELD(FloatRegisters[1]);
    DISPLAY_FIELD(FloatRegisters[2]);
    DISPLAY_FIELD(FloatRegisters[3]);
    DISPLAY_FIELD(FloatRegisters[4]);
    DISPLAY_FIELD(FloatRegisters[5]);
    DISPLAY_FIELD(FloatRegisters[6]);
    DISPLAY_FIELD(FloatRegisters[7]);
    DISPLAY_FIELD(Xmm0);
    DISPLAY_FIELD(Xmm1);
    DISPLAY_FIELD(Xmm2);
    DISPLAY_FIELD(Xmm3);
    DISPLAY_FIELD(Xmm4);
    DISPLAY_FIELD(Xmm5);
    DISPLAY_FIELD(Xmm6);
    DISPLAY_FIELD(Xmm7);
    DISPLAY_FIELD(Xmm8);
    DISPLAY_FIELD(Xmm9);
    DISPLAY_FIELD(Xmm10);
    DISPLAY_FIELD(Xmm11);
    DISPLAY_FIELD(Xmm12);
    DISPLAY_FIELD(Xmm13);
    DISPLAY_FIELD(Xmm14);
    DISPLAY_FIELD(Xmm15);

    //
    // Vector registers.
    //

    // M128A VectorRegister[26];
    DISPLAY_FIELD(VectorControl);

    //
    // Special debug control registers.
    //

    DISPLAY_FIELD(DebugControl);
    DISPLAY_FIELD(LastBranchToRip);
    DISPLAY_FIELD(LastBranchFromRip);
    DISPLAY_FIELD(LastExceptionToRip);
    DISPLAY_FIELD(LastExceptionFromRip);
  }
};

static_assert(offsetof(CONTEXT, Xmm0) == 0x1a0,
              "The offset of Xmm0 looks wrong.");

struct EXCEPTION_RECORD64 {
  uint32_t ExceptionCode;
  uint32_t ExceptionFlags;
  uint64_t ExceptionRecord;
  uint64_t ExceptionAddress;
  uint32_t NumberParameters;
  uint32_t __unusedAlignment;
  std::array<uint64_t, 15> ExceptionInformation;

  void Show(const uint32_t Prefix = 0) const {
    DISPLAY_HEADER("KDMP_PARSER_EXCEPTION_RECORD64");
    DISPLAY_FIELD(ExceptionCode);
    DISPLAY_FIELD(ExceptionFlags);
    DISPLAY_FIELD(ExceptionRecord);
    DISPLAY_FIELD(ExceptionAddress);
    DISPLAY_FIELD(NumberParameters);
    DISPLAY_FIELD(ExceptionInformation[0]);
    DISPLAY_FIELD(ExceptionInformation[1]);
    DISPLAY_FIELD(ExceptionInformation[2]);
    DISPLAY_FIELD(ExceptionInformation[3]);
    DISPLAY_FIELD(ExceptionInformation[4]);
    DISPLAY_FIELD(ExceptionInformation[5]);
    DISPLAY_FIELD(ExceptionInformation[6]);
    DISPLAY_FIELD(ExceptionInformation[7]);
    DISPLAY_FIELD(ExceptionInformation[8]);
    DISPLAY_FIELD(ExceptionInformation[9]);
    DISPLAY_FIELD(ExceptionInformation[10]);
    DISPLAY_FIELD(ExceptionInformation[11]);
    DISPLAY_FIELD(ExceptionInformation[12]);
    DISPLAY_FIELD(ExceptionInformation[13]);
    DISPLAY_FIELD(ExceptionInformation[14]);
  }
};

static_assert(sizeof(EXCEPTION_RECORD64) == 0x98,
              "KDMP_PARSER_EXCEPTION_RECORD64's size looks wrong.");

union DUMP_FILE_ATTRIBUTES {
  struct DUMP_FILE_ATTRIBUTES_0 {
    uint32_t _bitfield;
  } Anonymous;
  uint32_t Attributes;
};

//
// Adjusted C struct for `DUMP_HEADERS64` from MS Rust docs. Padding
// adjustment added from reversing `nt!IoFillDumpHeader`.
//
// @link
// https://microsoft.github.io/windows-docs-rs/doc/windows/Win32/System/Diagnostics/Debug/struct.DUMP_HEADER64.html#structfield.DumpType
//

struct HEADER64 {
  static constexpr uint32_t ExpectedSignature = 0x45474150; // 'EGAP'
  static constexpr uint32_t ExpectedValidDump = 0x34365544; // '46UD'

  /* 0x0000 */ uint32_t Signature;
  /* 0x0004 */ uint32_t ValidDump;
  /* 0x0008 */ uint32_t MajorVersion;
  /* 0x000c */ uint32_t MinorVersion;
  /* 0x0010 */ uint64_t DirectoryTableBase;
  /* 0x0018 */ uint64_t PfnDatabase;
  /* 0x0020 */ uint64_t PsLoadedModuleList;
  /* 0x0028 */ uint64_t PsActiveProcessHead;
  /* 0x0030 */ uint32_t MachineImageType;
  /* 0x0034 */ uint32_t NumberProcessors;
  /* 0x0038 */ uint32_t BugCheckCode;
  /* 0x003c */ uint32_t __Padding0;
  /* 0x0040 */ std::array<uint64_t, 4> BugCheckCodeParameters;
  /* 0x0060 */ std::array<uint8_t, 32> VersionUser;
  /* 0x0080 */ uint64_t KdDebuggerDataBlock;
  /* 0x0088 */ union DUMP_HEADER64_0 {
    PHYSMEM_DESC PhysicalMemoryBlock;
    std::array<uint8_t, 700> PhysicalMemoryBlockBuffer;
  } u1;
  /* 0x0344 */ uint32_t __Padding1;
  /* 0x0348 */ union CONTEXT_RECORD64_0 {
    CONTEXT ContextRecord;
    std::array<uint8_t, 3000> ContextRecordBuffer;
  } u2;
  /* 0x0f00 */ EXCEPTION_RECORD64 Exception;
  /* 0x0f98 */ DumpType_t DumpType;
  /* 0x0f9c */ uint32_t __Padding2;
  /* 0x0fa0 */ int64_t RequiredDumpSpace;
  /* 0x0fa8 */ int64_t SystemTime;
  /* 0x0fb0 */ std::array<uint8_t, 128> Comment;
  /* 0x1030 */ int64_t SystemUpTime;
  /* 0x1038 */ uint32_t MiniDumpFields;
  /* 0x103c */ uint32_t SecondaryDataState;
  /* 0x1040 */ uint32_t ProductType;
  /* 0x1044 */ uint32_t SuiteMask;
  /* 0x1048 */ uint32_t WriterStatus;
  /* 0x104c */ uint8_t Unused1;
  /* 0x104d */ uint8_t KdSecondaryVersion;
  /* 0x104e */ std::array<uint8_t, 2> Unused;
  /* 0x1050 */ DUMP_FILE_ATTRIBUTES Attributes;
  /* 0x1054 */ uint32_t BootId;
  /* 0x1058 */ std::array<uint8_t, 4008> _reserved0;

  union {
    BMP_HEADER64 BmpHeader;
    KERNEL_RDMP_HEADER64 RdmpHeader;
    FULL_RDMP_HEADER64 FullRdmpHeader;
  } u3;

  bool LooksGood() const {

    //
    // Integrity check the headers.
    //

    if (Signature != ExpectedSignature) {
      printf("HEADER64::Signature looks wrong.\n");
      return false;
    }

    if (ValidDump != ExpectedValidDump) {
      printf("HEADER64::ValidDump looks wrong.\n");
      return false;
    }

    //
    // Make sure it's a dump type we know how to handle.
    //

    switch (DumpType) {
    case DumpType_t::FullDump: {
      if (!u1.PhysicalMemoryBlock.LooksGood()) {
        printf("The PhysicalMemoryBlockBuffer looks wrong.\n");
        return false;
      }
      break;
    }

    case DumpType_t::LiveKernelBitmapDump:
    case DumpType_t::BMPDump: {
      if (!u3.BmpHeader.LooksGood()) {
        printf("The BmpHeader looks wrong.\n");
        return false;
      }
      break;
    }

    case DumpType_t::KernelAndUserMemoryDump:
    case DumpType_t::KernelMemoryDump: {
      if (!u3.RdmpHeader.Hdr.LooksGood()) {
        printf("The RdmpHeader looks wrong.\n");
        return false;
      }
      break;
    }

    case DumpType_t::CompleteMemoryDump: {
      if (!u3.FullRdmpHeader.Hdr.LooksGood()) {
        printf("The RdmpHeader looks wrong.\n");
        return false;
      }
      break;
    }

    case DumpType_t::MiniDump: {
      printf("Unsupported type %s (%#x).\n", DumpTypeToString(DumpType).data(),
             uint32_t(DumpType));
      return false;
    }

    default: {
      printf("Unknown Type %#x.\n", uint32_t(DumpType));
      return false;
    }
    }

    //
    // Integrity check the CONTEXT record.
    //

    if (!u2.ContextRecord.LooksGood()) {
      return false;
    }

    return true;
  }

  void Show(const uint32_t Prefix = 0) const {
    DISPLAY_HEADER("HEADER64");
    DISPLAY_FIELD(Signature);
    DISPLAY_FIELD(ValidDump);
    DISPLAY_FIELD(MajorVersion);
    DISPLAY_FIELD(MinorVersion);
    DISPLAY_FIELD(DirectoryTableBase);
    DISPLAY_FIELD(PfnDatabase);
    DISPLAY_FIELD(PsLoadedModuleList);
    DISPLAY_FIELD(PsActiveProcessHead);
    DISPLAY_FIELD(MachineImageType);
    DISPLAY_FIELD(NumberProcessors);
    DISPLAY_FIELD(BugCheckCode);
    DISPLAY_FIELD_OFFSET(BugCheckCodeParameters);
    DISPLAY_FIELD(KdDebuggerDataBlock);
    DISPLAY_FIELD_OFFSET(u1.PhysicalMemoryBlockBuffer);
    u1.PhysicalMemoryBlock.Show(Prefix + 2);
    DISPLAY_FIELD_OFFSET(u2.ContextRecordBuffer);
    u2.ContextRecord.Show(Prefix + 2);
    DISPLAY_FIELD_OFFSET(Exception);
    Exception.Show(Prefix + 2);
    DISPLAY_FIELD(DumpType);
    DISPLAY_FIELD(RequiredDumpSpace);
    DISPLAY_FIELD(SystemTime);
    DISPLAY_FIELD_OFFSET(Comment);
    DISPLAY_FIELD(SystemUpTime);
    DISPLAY_FIELD(MiniDumpFields);
    DISPLAY_FIELD(SecondaryDataState);
    DISPLAY_FIELD(ProductType);
    DISPLAY_FIELD(SuiteMask);
    DISPLAY_FIELD(WriterStatus);
    DISPLAY_FIELD(KdSecondaryVersion);
    if (DumpType == DumpType_t::BMPDump) {
      DISPLAY_FIELD_OFFSET(u3.BmpHeader);
      u3.BmpHeader.Show();
    }
  }
};

//
// Restore the default alignement setting.
//

#pragma pack(pop)

//
// Prevent the user to play around with those.
//

#undef DISPLAY_HEADER
#undef DISPLAY_FIELD

//
// Those asserts are the results of a lot of frustration getting the right
// layout, so hopefully they prevent any regressions regarding the layout.
//

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Winvalid-offsetof"
#endif //__GNUC__
static_assert(offsetof(HEADER64, Signature) == 0x00,
              "The offset of KdDebuggerDataBlock looks wrong.");

static_assert(offsetof(HEADER64, BugCheckCodeParameters) == 0x40,
              "The offset of KdDebuggerDataBlock looks wrong.");

static_assert(offsetof(HEADER64, KdDebuggerDataBlock) == 0x80,
              "The offset of KdDebuggerDataBlock looks wrong.");

static_assert(offsetof(HEADER64, u2.ContextRecord) == 0x348,
              "The offset of ContextRecord looks wrong.");

static_assert(offsetof(HEADER64, Exception) == 0xf00,
              "The offset of Exception looks wrong.");

static_assert(offsetof(HEADER64, Comment) == 0xfb0,
              "The offset of Comment looks wrong.");

static_assert(offsetof(HEADER64, u3.BmpHeader) == 0x2000,
              "The offset of BmpHeaders looks wrong.");
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif //__GNUC__

//
// Structure for parsing a PTE.
//

union MMPTE_HARDWARE {
  struct {
    uint64_t Present : 1;
    uint64_t Write : 1;
    uint64_t UserAccessible : 1;
    uint64_t WriteThrough : 1;
    uint64_t CacheDisable : 1;
    uint64_t Accessed : 1;
    uint64_t Dirty : 1;
    uint64_t LargePage : 1;
    uint64_t Available : 4;
    uint64_t PageFrameNumber : 36;
    uint64_t ReservedForHardware : 4;
    uint64_t ReservedForSoftware : 11;
    uint64_t NoExecute : 1;
  } u;
  uint64_t AsUINT64;
  constexpr MMPTE_HARDWARE(const uint64_t Value) : AsUINT64(Value) {}
};

//
// Structure to parse a virtual address.
//

union VIRTUAL_ADDRESS {
  struct {
    uint64_t Offset : 12;
    uint64_t PtIndex : 9;
    uint64_t PdIndex : 9;
    uint64_t PdPtIndex : 9;
    uint64_t Pml4Index : 9;
    uint64_t Reserved : 16;
  } u;
  uint64_t AsUINT64;
  constexpr VIRTUAL_ADDRESS(const uint64_t Value) : AsUINT64(Value) {}
};

static_assert(sizeof(MMPTE_HARDWARE) == 8);
static_assert(sizeof(VIRTUAL_ADDRESS) == 8);
} // namespace kdmpparser
```

`KDemu/kdmp-parser/kdmp-parser-version.h.in`:

```in
#pragma once

// clang-format off
#define KDMPPARSER_PROJECT_NAME "@PROJECT_NAME@"
#define KDMPPARSER_PROJECT_AUTHOR "@PROJECT_AUTHOR@"
#define KDMPPARSER_PROJECT_LICENSE "@PROJECT_LICENSE@"
#define KDMPPARSER_VERSION_MAJOR @PROJECT_VERSION_MAJOR@
#define KDMPPARSER_VERSION_MINOR @PROJECT_VERSION_MINOR@
#define KDMPPARSER_VERSION_PATCH @PROJECT_VERSION_PATCH@
#define KDMPPARSER_VERSION_RELEASE "@PROJECT_VERSION_MAJOR@.@PROJECT_VERSION_MINOR@.@PROJECT_VERSION_PATCH@"
// clang-format on

```

`KDemu/kdmp-parser/kdmp-parser.h`:

```h
// Axel '0vercl0k' Souchet - February 15 2019
#pragma once

#include "filemap.h"
#include "kdmp-parser-structs.h"

#include <array>
#include <cstdint>
#include <cstdio>
#include <filesystem>
#include <optional>
#include <string>
#include <unordered_map>

namespace kdmpparser {

using Page_t = std::array<uint8_t, kdmpparser::Page::Size>;
using Physmem_t = std::unordered_map<uint64_t, const uint8_t *>;

struct BugCheckParameters_t {
  uint32_t BugCheckCode;
  std::array<uint64_t, 4> BugCheckCodeParameter;
};

class KernelDumpParser {

  //
  // The mapped file.
  //

  FileMap_t FileMap_;

  //
  // Header of the crash-dump.
  //

  HEADER64 *DmpHdr_ = nullptr;

  //
  // File path to the crash-dump.
  //

  std::filesystem::path PathFile_;

  //
  // Mapping between physical addresses / page data.
  //

  Physmem_t Physmem_;

public:
  //
  // Actually do the parsing of the file.
  //

  bool Parse(const char *PathFile) {

    //
    // Copy the path file.
    //

    PathFile_ = std::filesystem::path(PathFile);
    if (!std::filesystem::exists(PathFile_)) {
      printf("Invalid file: %s.\n", (char *)PathFile_.string().c_str());
      return false;
    }

    //
    // Map a view of the file.
    //

    if (!MapFile()) {
      printf("MapFile failed.\n");
      return false;
    }

    //
    // Parse the DMP_HEADER.
    //

    if (!ParseDmpHeader()) {
      printf("ParseDmpHeader failed.\n");
      return false;
    }

    //
    // Retrieve the physical memory according to the type of dump we have.
    //

    switch (DmpHdr_->DumpType) {
    case DumpType_t::FullDump: {
      if (!BuildPhysmemFullDump()) {
        printf("BuildPhysmemFullDump failed.\n");
        return false;
      }
      break;
    }
    case DumpType_t::LiveKernelBitmapDump:
    case DumpType_t::BMPDump: {
      if (!BuildPhysmemBMPDump()) {
        printf("BuildPhysmemBMPDump failed.\n");
        return false;
      }
      break;
    }

    case DumpType_t::CompleteMemoryDump:
    case DumpType_t::KernelAndUserMemoryDump:
    case DumpType_t::KernelMemoryDump: {
      if (!BuildPhysicalMemoryFromDump(DmpHdr_->DumpType)) {
        printf("BuildPhysicalMemoryFromDump failed.\n");
        return false;
      }
      break;
    }

    default: {
      printf("Invalid type\n");
      return false;
    }
    }

    return true;
  }

  //
  // Give the Context record to the user.
  //

  constexpr const CONTEXT &GetContext() const {

    //
    // Give the user a view of the context record.
    //

    return DmpHdr_->u2.ContextRecord;
  }

  //
  // Give the bugcheck parameters to the user.
  //

  constexpr BugCheckParameters_t GetBugCheckParameters() const {

    //
    // Give the user a view of the bugcheck parameters.
    //

    return {DmpHdr_->BugCheckCode,
            {DmpHdr_->BugCheckCodeParameters[0],
             DmpHdr_->BugCheckCodeParameters[1],
             DmpHdr_->BugCheckCodeParameters[2],
             DmpHdr_->BugCheckCodeParameters[3]}};
  }

  //
  // Get the path of dump.
  //

  const std::filesystem::path &GetDumpPath() const { return PathFile_; }

  //
  // Get the type of dump.
  //

  constexpr DumpType_t GetDumpType() const { return DmpHdr_->DumpType; }

  //
  // Get the physmem.
  //

  constexpr const Physmem_t &GetPhysmem() const { return Physmem_; }

  //
  // Show the exception record.
  //

  void ShowExceptionRecord(const uint32_t Prefix) const {
    DmpHdr_->Exception.Show(Prefix);
  }

  //
  // Show the context record.
  //

  void ShowContextRecord(const uint32_t Prefix) const {
    const CONTEXT &Context = GetContext();
    printf("%*srax=%016" PRIx64 " rbx=%016" PRIx64 " rcx=%016" PRIx64 "\n",
           Prefix, "", Context.Rax, Context.Rbx, Context.Rcx);
    printf("%*srdx=%016" PRIx64 " rsi=%016" PRIx64 " rdi=%016" PRIx64 "\n",
           Prefix, "", Context.Rdx, Context.Rsi, Context.Rdi);
    printf("%*srip=%016" PRIx64 " rsp=%016" PRIx64 " rbp=%016" PRIx64 "\n",
           Prefix, "", Context.Rip, Context.Rsp, Context.Rbp);
    printf("%*s r8=%016" PRIx64 "  r9=%016" PRIx64 " r10=%016" PRIx64 "\n",
           Prefix, "", Context.R8, Context.R9, Context.R10);
    printf("%*sr11=%016" PRIx64 " r12=%016" PRIx64 " r13=%016" PRIx64 "\n",
           Prefix, "", Context.R11, Context.R12, Context.R13);
    printf("%*sr14=%016" PRIx64 " r15=%016" PRIx64 "\n", Prefix, "",
           Context.R14, Context.R15);
    printf("%*scs=%04x ss=%04x ds=%04x es=%04x fs=%04x gs=%04x    "
           "             efl=%08x\n",
           Prefix, "", Context.SegCs, Context.SegSs, Context.SegDs,
           Context.SegEs, Context.SegFs, Context.SegGs, Context.EFlags);
    printf("%*sfpcw=%04x    fpsw=%04x    fptw=%04x\n", Prefix, "",
           Context.ControlWord, Context.StatusWord, 1);
    printf("%*s  st0=%016" PRIx64 "%016" PRIx64 "       st1=%016" PRIx64
           "%016" PRIx64 "\n",
           Prefix, "", Context.FloatRegisters[0].High,
           Context.FloatRegisters[0].Low, Context.FloatRegisters[1].High,
           Context.FloatRegisters[1].Low);
    printf("%*s  st2=%016" PRIx64 "%016" PRIx64 "       st3=%016" PRIx64
           "%016" PRIx64 "\n",
           Prefix, "", Context.FloatRegisters[2].High,
           Context.FloatRegisters[2].Low, Context.FloatRegisters[3].High,
           Context.FloatRegisters[3].Low);
    printf("%*s  st4=%016" PRIx64 "%016" PRIx64 "       st5=%016" PRIx64
           "%016" PRIx64 "\n",
           Prefix, "", Context.FloatRegisters[4].High,
           Context.FloatRegisters[4].Low, Context.FloatRegisters[5].High,
           Context.FloatRegisters[5].Low);
    printf("%*s  st6=%016" PRIx64 "%016" PRIx64 "       st7=%016" PRIx64
           "%016" PRIx64 "\n",
           Prefix, "", Context.FloatRegisters[6].High,
           Context.FloatRegisters[6].Low, Context.FloatRegisters[7].High,
           Context.FloatRegisters[7].Low);
    printf("%*s xmm0=%016" PRIx64 "%016" PRIx64 "      xmm1=%016" PRIx64
           "%016" PRIx64 "\n",
           Prefix, "", Context.Xmm0.High, Context.Xmm0.Low, Context.Xmm1.High,
           Context.Xmm1.Low);
    printf("%*s xmm2=%016" PRIx64 "%016" PRIx64 "      xmm3=%016" PRIx64
           "%016" PRIx64 "\n",
           Prefix, "", Context.Xmm2.High, Context.Xmm2.Low, Context.Xmm3.High,
           Context.Xmm3.Low);
    printf("%*s xmm4=%016" PRIx64 "%016" PRIx64 "      xmm5=%016" PRIx64
           "%016" PRIx64 "\n",
           Prefix, "", Context.Xmm4.High, Context.Xmm4.Low, Context.Xmm5.High,
           Context.Xmm5.Low);
    printf("%*s xmm6=%016" PRIx64 "%016" PRIx64 "      xmm7=%016" PRIx64
           "%016" PRIx64 "\n",
           Prefix, "", Context.Xmm6.High, Context.Xmm6.Low, Context.Xmm7.High,
           Context.Xmm7.Low);
    printf("%*s xmm8=%016" PRIx64 "%016" PRIx64 "      xmm9=%016" PRIx64
           "%016" PRIx64 "\n",
           Prefix, "", Context.Xmm8.High, Context.Xmm8.Low, Context.Xmm9.High,
           Context.Xmm9.Low);
    printf("%*sxmm10=%016" PRIx64 "%016" PRIx64 "     xmm11=%016" PRIx64
           "%016" PRIx64 "\n",
           Prefix, "", Context.Xmm10.High, Context.Xmm10.Low,
           Context.Xmm11.High, Context.Xmm11.Low);
    printf("%*sxmm12=%016" PRIx64 "%016" PRIx64 "     xmm13=%016" PRIx64
           "%016" PRIx64 "\n",
           Prefix, "", Context.Xmm12.High, Context.Xmm12.Low,
           Context.Xmm13.High, Context.Xmm13.Low);
    printf("%*sxmm14=%016" PRIx64 "%016" PRIx64 "     xmm15=%016" PRIx64
           "%016" PRIx64 "\n",
           Prefix, "", Context.Xmm14.High, Context.Xmm14.Low,
           Context.Xmm15.High, Context.Xmm15.Low);
  }

  //
  // Show all the structures of the dump.
  //

  void ShowAllStructures(const uint32_t Prefix) const { DmpHdr_->Show(Prefix); }

  //
  // Get the content of a physical address.
  //

  const uint8_t *GetPhysicalPage(const uint64_t PhysicalAddress) const {

    //
    // Attempt to find the physical address.
    //

    const auto &Pair = Physmem_.find(PhysicalAddress);

    //
    // If it doesn't exist then return nullptr.
    //

    if (Pair == Physmem_.end()) {
      return nullptr;
    }

    //
    // Otherwise we return a pointer to the content of the page.
    //

    return Pair->second;
  }

  //
  // Get the directory table base.
  //

  constexpr uint64_t GetDirectoryTableBase() const {
    return DmpHdr_->DirectoryTableBase;
  }

  //
  // Translate a virtual address to physical address using a directory table
  // base.
  //

  std::optional<uint64_t>
  VirtTranslate(const uint64_t VirtualAddress,
                const uint64_t DirectoryTableBase = 0) const {

    //
    // If DirectoryTableBase is null ; use the one from the dump header and
    // clear PCID bits (bits 11:0).
    //

    uint64_t LocalDTB = Page::Align(GetDirectoryTableBase());

    if (DirectoryTableBase) {
      LocalDTB = Page::Align(DirectoryTableBase);
    }

    //
    // Stole code from @yrp604 and @0vercl0k.
    //

    const VIRTUAL_ADDRESS GuestAddress(VirtualAddress);
    const MMPTE_HARDWARE Pml4(LocalDTB);
    const uint64_t Pml4Base = Pml4.u.PageFrameNumber * Page::Size;
    const uint64_t Pml4eGpa = Pml4Base + GuestAddress.u.Pml4Index * 8;
    const MMPTE_HARDWARE Pml4e(PhyRead8(Pml4eGpa));
    if (!Pml4e.u.Present) {
      printf("Invalid page map level 4, address translation failed!\n");
      return {};
    }

    const uint64_t PdptBase = Pml4e.u.PageFrameNumber * Page::Size;
    const uint64_t PdpteGpa = PdptBase + GuestAddress.u.PdPtIndex * 8;
    const MMPTE_HARDWARE Pdpte(PhyRead8(PdpteGpa));
    if (!Pdpte.u.Present) {
      printf("Invalid page directory pointer table, address translation "
             "failed!\n");
      return {};
    }

    //
    // huge pages:
    // 7 (PS) - Page size; must be 1 (otherwise, this entry references a page
    // directory; see Table 4-1
    //

    const uint64_t PdBase = Pdpte.u.PageFrameNumber * Page::Size;
    if (Pdpte.u.LargePage) {
      return PdBase + (VirtualAddress & 0x3fff'ffff);
    }

    const uint64_t PdeGpa = PdBase + GuestAddress.u.PdIndex * 8;
    const MMPTE_HARDWARE Pde(PhyRead8(PdeGpa));
    if (!Pde.u.Present) {
      printf("Invalid page directory entry, address translation failed!\n");
      return {};
    }

    //
    // large pages:
    // 7 (PS) - Page size; must be 1 (otherwise, this entry references a page
    // table; see Table 4-18
    //

    const uint64_t PtBase = Pde.u.PageFrameNumber * Page::Size;
    if (Pde.u.LargePage) {
      return PtBase + (VirtualAddress & 0x1f'ffff);
    }

    const uint64_t PteGpa = PtBase + GuestAddress.u.PtIndex * 8;
    const MMPTE_HARDWARE Pte(PhyRead8(PteGpa));
    if (!Pte.u.Present) {
      //printf("Invalid page table entry, address translation failed!\n");
      return {};
    }

    const uint64_t PageBase = Pte.u.PageFrameNumber * Page::Size;
    return PageBase + GuestAddress.u.Offset;
  }

  //
  // Get the content of a virtual address.
  //

  const uint8_t *GetVirtualPage(const uint64_t VirtualAddress,
                                const uint64_t DirectoryTableBase = 0) const {

    //
    // First remove offset and translate the virtual address.
    //

    const auto &PhysicalAddress =
        VirtTranslate(Page::Align(VirtualAddress), DirectoryTableBase);

    if (!PhysicalAddress) {
      return nullptr;
    }

    //
    // Then get the physical page.
    //

    return GetPhysicalPage(*PhysicalAddress);
  }

  const HEADER64 &GetDumpHeader() const {
    if (!DmpHdr_) {
      std::abort();
    }

    return *DmpHdr_;
  }

private:
  //
  // Utility function to read an uint64_t from a physical address.
  //

  uint64_t PhyRead8(const uint64_t PhysicalAddress) const {

    //
    // Get the physical page and read from the offset.
    //

    const uint8_t *PhysicalPage = GetPhysicalPage(Page::Align(PhysicalAddress));

    if (!PhysicalPage) {
      printf("Internal page table parsing failed!\n");
      return 0;
    }

    const uint64_t *Ptr =
        (uint64_t *)(PhysicalPage + Page::Offset(PhysicalAddress));
    return *Ptr;
  }

  //
  // Build a map of physical addresses / page data pointers for full dump.
  //

  bool BuildPhysmemFullDump() {

    //
    // Walk through the runs.
    //

    uint8_t *RunBase = (uint8_t *)&DmpHdr_->u3.BmpHeader;
    const uint32_t NumberOfRuns = DmpHdr_->u1.PhysicalMemoryBlock.NumberOfRuns;

    //
    // Back at it, this time building the index!
    //

    for (uint32_t RunIdx = 0; RunIdx < NumberOfRuns; RunIdx++) {

      //
      // Grab the current run as well as its base page and page count.
      //

      const PHYSMEM_RUN *Run = DmpHdr_->u1.PhysicalMemoryBlock.Run + RunIdx;

      const uint64_t BasePage = Run->BasePage;
      const uint64_t PageCount = Run->PageCount;

      //
      // Walk the pages from the run.
      //

      for (uint64_t PageIdx = 0; PageIdx < PageCount; PageIdx++) {

        //
        // Compute the current PFN as well as the actual physical address of
        // the page.
        //

        const uint64_t Pfn = BasePage + PageIdx;
        const uint64_t Pa = Pfn * Page::Size;

        //
        // Now one thing to understand is that the Runs structure allows to
        // skip for holes in memory. Instead of, padding them with empty
        // spaces to conserve a 1:1 mapping between physical address and file
        // offset, the Run gives you the base Pfn. This means that we don't
        // have a 1:1 mapping between file offset and physical addresses so we
        // need to keep track of where the Run starts in memory and then we
        // can simply access our pages one after the other.
        //
        // If this is not clear enough, here is a small example:
        //  Run[0]
        //    BasePage = 1337, PageCount = 2
        //  Run[1]
        //    BasePage = 1400, PageCount = 1
        //
        // In the above we clearly see that there is a hole between the two
        // runs; the dump file has 2+1 memory pages. Their Pfns are: 1337+0,
        // 1337+1, 1400+0.
        //
        // Now if we want to get the file offset of those pages we start at
        // Run0:
        //   Run0 starts at file offset 0x2000 so Page0 is at file offset
        //   0x2000, Page1 is at file offset 0x3000. Run1 starts at file
        //   offset 0x2000+(2*0x1000) so Page3 is at file offset
        //   0x2000+(2*0x1000)+0x1000.
        //
        // That is the reason why the computation below is RunBase + (PageIdx
        // * 0x1000) instead of RunBase + (Pfn * 0x1000).

        const uint8_t *PageBase = RunBase + (PageIdx * Page::Size);

        //
        // Map the Pfn to a page.
        //

        Physmem_.try_emplace(Pa, PageBase);
      }

      //
      // Move the run base past all the pages in the current run.
      //

      RunBase += PageCount * Page::Size;
    }

    return true;
  }

  //
  // Build a map of physical addresses / page data pointers for BMP dump.
  //

  bool BuildPhysmemBMPDump() {
    const uint8_t *Page = (uint8_t *)DmpHdr_ + DmpHdr_->u3.BmpHeader.FirstPage;
    const uint64_t BitmapSize = DmpHdr_->u3.BmpHeader.Pages / 8;
    const uint8_t *Bitmap = DmpHdr_->u3.BmpHeader.Bitmap.data();

    //
    // Walk the bitmap byte per byte.
    //

    for (uint64_t BitmapIdx = 0; BitmapIdx < BitmapSize; BitmapIdx++) {

      //
      // Now walk the bits of the current byte.
      //

      const uint8_t Byte = Bitmap[BitmapIdx];
      for (uint8_t BitIdx = 0; BitIdx < 8; BitIdx++) {

        //
        // If the bit is not set we just skip to the next.
        //

        const bool BitSet = ((Byte >> BitIdx) & 1) == 1;
        if (!BitSet) {
          continue;
        }

        //
        // If the bit is one we add the page to the physmem.
        //

        const uint64_t Pfn = (BitmapIdx * 8) + BitIdx;
        const uint64_t Pa = Pfn * Page::Size;
        Physmem_.try_emplace(Pa, Page);
        Page += Page::Size;
      }
    }

    return true;
  }

  //
  // Populate the physical memory map for the 'new' dump types.
  // `Type` must be either `KernelMemoryDump`, `KernelAndUserMemoryDump`,
  // or `CompleteMemoryDump`.
  //
  // Returns true on success, false otherwise.
  //

  bool BuildPhysicalMemoryFromDump(const DumpType_t Type) {
    uint64_t FirstPageOffset = 0;
    uint8_t *Page = nullptr;
    uint64_t MetadataSize = 0;
    uint8_t *Bitmap = nullptr;
    uint64_t TotalNumberOfPages = 0;
    uint64_t CurrentPageCount = 0;

    switch (Type) {
    case DumpType_t::KernelMemoryDump:
    case DumpType_t::KernelAndUserMemoryDump: {
      FirstPageOffset = DmpHdr_->u3.RdmpHeader.Hdr.FirstPageOffset;
      Page = (uint8_t *)DmpHdr_ + FirstPageOffset;
      MetadataSize = DmpHdr_->u3.RdmpHeader.Hdr.MetadataSize;
      Bitmap = DmpHdr_->u3.RdmpHeader.Bitmap.data();
      break;
    }

    case DumpType_t::CompleteMemoryDump: {
      FirstPageOffset = DmpHdr_->u3.FullRdmpHeader.Hdr.FirstPageOffset;
      Page = (uint8_t *)DmpHdr_ + FirstPageOffset;
      MetadataSize = DmpHdr_->u3.FullRdmpHeader.Hdr.MetadataSize;
      Bitmap = DmpHdr_->u3.FullRdmpHeader.Bitmap.data();
      TotalNumberOfPages = DmpHdr_->u3.FullRdmpHeader.TotalNumberOfPages;
      break;
    }

    default: {
      return false;
    }
    }

    if (!FirstPageOffset || !Page || !MetadataSize || !Bitmap) {
      return false;
    }

    auto IsPageInBounds = [&](const uint8_t *Ptr) {
      return FileMap_.InBounds(Ptr, Page::Size);
    };

    if (!IsPageInBounds(Page)) {
      return false;
    }

    struct PfnRange {
      uint64_t PageFileNumber;
      uint64_t NumberOfPages;
    };

    // Sanity check
    if (MetadataSize % sizeof(PfnRange)) {
      return false;
    }

    for (uint64_t Offset = 0; Offset < MetadataSize;
         Offset += sizeof(PfnRange)) {

      if (Type == DumpType_t::CompleteMemoryDump) {
        // `CompleteMemoryDump` type seems to be bound by the
        // `TotalNumberOfPages` field, *not* by `MetadataSize`.
        if (CurrentPageCount == TotalNumberOfPages) {
          break;
        }

        if (CurrentPageCount > TotalNumberOfPages) {
          return false;
        }
      }

      const PfnRange &Entry = (PfnRange &)Bitmap[Offset];
      if (!FileMap_.InBounds(&Entry, sizeof(Entry))) {
        return false;
      }

      CurrentPageCount += Entry.NumberOfPages;

      const uint64_t Pfn = Entry.PageFileNumber;
      if (!Pfn) {
        break;
      }

      for (uint64_t PageIdx = 0; PageIdx < Entry.NumberOfPages; PageIdx++) {
        if (!IsPageInBounds(Page)) {
          return false;
        }

        const uint64_t Pa = (Pfn * Page::Size) + (PageIdx * Page::Size);
        Physmem_.try_emplace(Pa, Page);
        Page += Page::Size;
      }
    }

    return true;
  }

  //
  // Parse the DMP_HEADER.
  //

  bool ParseDmpHeader() {

    //
    // The base of the view points on the HEADER64.
    //

    DmpHdr_ = (HEADER64 *)FileMap_.ViewBase();

    //
    // Now let's make sure the structures look right.
    //

    if (!DmpHdr_->LooksGood()) {
      printf("The header looks wrong.\n");
      return false;
    }

    return true;
  }

  //
  // Map a view of the file in memory.
  //

  bool MapFile() { return FileMap_.MapFile(PathFile_.string().c_str()); }
};

} // namespace kdmpparser

```

`KDemu/kdmp-parser/platform.h`:

```h
// Axel '0vercl0k' Souchet - April 18 2020
#pragma once

#if defined(__i386__) || defined(_M_IX86)
#define ARCH_X86
#elif defined(__amd64__) || defined(_M_X64)
#define ARCH_X64
#elif defined(__aarch64__) || defined(_M_ARM64)
#define ARCH_ARM64
#else
#error Architecture not supported.
#endif

#if defined(WIN32) || defined(WIN64) || defined(_WIN32) || defined(_WIN64)
#define WINDOWS
#define SYSTEM_PLATFORM "Windows"

#include <windows.h>
#if defined(ARCH_X86)
#define WINDOWS_X86
#elif defined(ARCH_X64)
#define WINDOWS_X64
#elif defined(ARCH_ARM64)
#define WINDOWS_ARM64
#endif

#elif defined(linux) || defined(__linux) || defined(__FreeBSD__) ||            \
    defined(__FreeBSD_kernel__) || defined(__MACH__)
#define LINUX

#if defined(linux) || defined(__linux)
#define SYSTEM_PLATFORM "Linux"

#if defined(ARCH_X86)
#define LINUX_X86
#elif defined(ARCH_X64)
#define LINUX_X64
#elif defined(ARCH_ARM64)
#define LINUX_ARM64
#endif

#elif defined(__APPLE__)

#define SYSTEM_PLATFORM "OSX"
#if defined(ARCH_X86)
#define OSX_X86
#elif defined(ARCH_X64)
#define OSX_X64
#elif defined(ARCH_ARM64)
#define OSX_ARM64
#endif
#else
#error An error occured
#endif

#define EXIT_FAILURE 1
#define EXIT_SUCCESS 0

#else
#error Platform not supported.
#endif

```

`KDemu/unicorn.cpp`:

```cpp
#include "Emulate.hpp"
#include <fstream>
#include <conio.h>
#include "LoadPE.hpp"
#include "UnicornEmu.hpp"
#include "NtType.hpp"
#define MAX_INSTRUCTION_SIZE 16

PEloader* Unicorn::loader = &PEloader::GetInstance();
uint64_t Previous_address = 0;


namespace {
	constexpr size_t kPageSize = 0x1000;
	inline bool match(const uint8_t* buf, uint32_t size, std::initializer_list<uint8_t> pattern) {
		if (size < pattern.size()) return false;
		size_t i = 0;
		for (auto b : pattern) {
			if (buf[i++] != b) return false;
		}
		return true;
	}

	inline int32_t read_disp32_at(const uint8_t* buf, uint32_t size, uint32_t offset) {
		if (size < offset + 4) return 0;
		return static_cast<int32_t>(
			(uint32_t)buf[offset + 0] |
			((uint32_t)buf[offset + 1] << 8) |
			((uint32_t)buf[offset + 2] << 16) |
			((uint32_t)buf[offset + 3] << 24)
			);
	}

	inline void log_addr(const char* msg, uint64_t addr) {
		Logger::Log(true, ConsoleColor::DARK_GREEN, "%s 0x%llx \n", msg, addr);
	}
}


Unicorn::Unicorn() {

}

void Unicorn::seh_Handle(uc_engine* uc)
{
	auto emu = Emu(uc);
	uint64_t rsp = emu->rsp();
	uint64_t rip = emu->rip();
	uint64_t error = 0xC0000094;
	rsp -= 8;
	emu->qword(rsp, rip);
	emu->rcx(error);
	emu->rsp(rsp);
	emu->rip(loader->RtlRaiseStatusBase);
	Sleep(10);
}

void Unicorn::register_hook(uc_engine* uc, uint64_t address, const byte size, void* user_data)
{
	PEloader* loader = &PEloader::GetInstance();
	auto emu = Emu(uc);
	if (loader->errorevent != nullptr)
	{
		for (auto& ti : loader->Threads) {
			if (ti->threadId == GetCurrentThreadId() && loader->errorevent != ti->Event)
			{
				WaitForSingleObject(loader->errorevent, INFINITE);
				Sleep(100);
			}
		}
	}

	std::vector<uint8_t> code = emu->read(address, size);
	if (size >= 1) {
		if (match(code.data(), size, { 0xFA })) {
			Logger::Log(true, 12, "Clearing Interrupts %llx\n", address);
		}
		if (match(code.data(), size, { 0xFB })) {
			Logger::Log(true, 12, "Restoring Interrupts %llx\n", address);
		}
	}
	if (size >= 2) {
		if (match(code.data(), size, { 0x48, 0xCF })) {
			Logger::Log(true, 13, "IRET %llx\n", address);

			uint64_t old_rsp = emu->rsp();
			uint64_t old_cs = emu->cs();

			uint64_t new_rip = qword_load(uc, old_rsp + 0x00);
			uint64_t new_cs = qword_load(uc, old_rsp + 0x08);
			uint64_t new_fl = qword_load(uc, old_rsp + 0x10);
			uint64_t new_rsp = qword_load(uc, old_rsp + 0x18);
			uint64_t new_ss = qword_load(uc, old_rsp + 0x20);
			emu->eflags(new_fl);
			emu->cs(new_cs);
			emu->rsp(new_rsp);
			emu->rip(new_rip);
		}
		if (match(code.data(), size, { 0x0f, 0x05 })) {
			Logger::Log(true, 13, "SYSCALL  address: %llx \n", address);
			ShowRegister(uc);
		}
		if (match(code.data(), size, { 0x0F, 0x20 })) {
			Logger::Log(true, 13, "Read CR0 register address: %llx \n", address);
			/*return;
			uint64_t cr0 = emu->cr0();
			cr0 = 0x000000080050033;
			emu->rax(cr0);
			address += 2;
			emu->rip(address);
			ShowRegister(uc);*/
		}
		if (match(code.data(), size, { 0x0F, 0x30 })) {
			uint64_t rip = emu->rip();
			uint64_t rcx = emu->rcx();
			uint32_t edx = emu->edx();
			uint32_t eax = emu->eax();
			auto value = static_cast<uint64_t>(static_cast<uint64_t>(edx) << 32) | static_cast<uint64_t>(eax);
			if (!loader->MSRList[rcx].second.empty()) {
				Logger::Log(true, 10, "%s\n", loader->MSRList[rcx].second.c_str());
				loader->MSRList[rcx] = { value, loader->MSRList[rcx].second };
				if (loader->MSRList[rcx].second == "MSR_LSTAR") {
					uint64_t h = emu->read<uint64_t>(0xfffff30000010000);
					Logger::Log(true, 12, "Value: %llx\n", h);
				}
				Logger::Log(true, 12, "WRITE MSR: %llx Addr: %llx, value : 0x%llx \n", loader->MSRList[rcx].first, rip, value);
				emu->rax(value);
				uint64_t addr = address + 2;
				emu->rip(addr);
				return;
			}
		}
		if (match(code.data(), size, { 0x0f, 0x32 })) {
			uint64_t rcx = emu->rcx();
			Logger::Log(true, 12, "RDMSR %llx\n", rcx);
			Logger::Log(true, 10, "Addr: %llx\n", address);
			if (!loader->MSRList[rcx].second.empty()) {

				Logger::Log(true, 10, "%s\n", loader->MSRList[rcx].second.c_str());
				auto value1 = loader->MSRList[rcx].first & 0xFFFFFFFF;
				auto value2 = (loader->MSRList[rcx].first >> 32) & 0xFFFFFFFF;
				emu->eax(static_cast<uint32_t>(value1));
				emu->edx(static_cast<uint32_t>(value2));
				uint64_t addr = address + 2;
				emu->rip(addr);
				Logger::Log(true, 12, "READ MSR: %llx\n", loader->MSRList[rcx].first);
				Sleep(1000);
			}
			else {
				seh_Handle(uc);
			}

		}
		if (match(code.data(), size, { 0xCD, 0x20 }))
		{
			Logger::Log(true, 12, "INT 20\n");
			uint64_t rip = emu->rip();
			rip += 2;
			emu->rip(rip);
		}
	}

	if (size >= 3) {
		if (match(code.data(), size, { 0x0F, 0x23 })) {
			if (size >= 3) {
				uint8_t modrm = code[2];
				uint8_t reg = (modrm >> 3) & 0x7;
				if (reg <= 7) {
					int dr_reg_id = UC_X86_REG_DR0 + reg;
					uint64_t value;
					uc_reg_read(uc, dr_reg_id, &value);
					Logger::Log(true, ConsoleColor::DARK_GREEN, "DR%d  modified at 0x%llx with value 0x%llx \n", int(reg), address, value);
				}
			}
		}
		if (match(code.data(), size, { 0x0f, 0x01, 0xF8 })) {
			Logger::Log(true, ConsoleColor::RED, "SWAPGS\n");
		}
		if (match(code.data(), size, { 0x0F, 0x01, 0xF9 }))
		{
			uint64_t fake_tsc = (uint64_t)__rdtsc();
			emu->rax(fake_tsc);
			Logger::Log(true, 13, "rdtscp!!!!!!!!!!! address: %llx code: %x\n", address, code[2]);
			address += 3;
			emu->rip(address);
		}
		if (match(code.data(), size, { 0x0F, 0x20, 0xD8 }))
		{
			uint64_t rcx = emu->rcx();
			Logger::Log(true, 13, "Suck my CR3 DICK~~~~~~~~~~~~~~~~~~~~~~~~~~!!!!!!!!!!! address: %llx code: %x\n", address, code[2]);
		}

		if (match(code.data(), size, { 0x0F, 0x20 })) {
			Logger::Log(true, 13, "Read CR register address: %llx code: %x\n", address, code[2]);
		}
		if (size >= 4 && match(code.data(), size, { 0xF0, 0x0F, 0xB1 }))
		{
			uint64_t rcx = emu->rcx();
			if (code[3] == 0x0D)
			{
				int32_t disp32_alt = static_cast<int32_t>(
					(uint32_t)code[size - 4] |
					((uint32_t)code[size - 3] << 8) |
					((uint32_t)code[size - 2] << 16) |
					((uint32_t)code[size - 1] << 24)
					);
				uint64_t temp = address + size + disp32_alt;
				uint32_t temp_value = emu->read<uint32_t>(temp);
				if (temp_value != 0)
				{
					/*int o = 0;
					do {
						temp_value = emu->read<uint32_t>(temp);
						if (temp_value == 0)
							break;
					} while (true);*/
				}
			}
		}
	}

	if (size >= 4) {
		if (match(code.data(), size, { 0x41, 0x0f, 0x01 })) {
			Logger::Log(true, 13, "Read CR0 register address: %llx \n", address);
		}
	}

	Previous_address = address;
	for (auto& ti : loader->Threads) {
		if (ti->threadId == GetCurrentThreadId())
		{
			ti->paddress = address;
		}
	}
}

void Unicorn::catch_error(uc_engine* uc, int exception, void* user_data) {
	PEloader* loader = &PEloader::GetInstance();
	uint64_t rip;
	uc_reg_read(uc, UC_X86_REG_RIP, &rip);
	if (loader->peFiles[1]->Base < rip && loader->peFiles[1]->End > rip)
	{
		uc_hook t;
		uc_hook_add(uc, &t, UC_HOOK_CODE, Unicorn::register_hook, NULL, rip, rip + 10);
		return;
	}
	Logger::Log(true, ConsoleColor::DARK_GREEN, "exception # 0x%x \n", exception);
	seh_Handle(uc);
	return;
	ShowRegister(uc);
	uint64_t rsp;
	uc_reg_read(uc, UC_X86_REG_RSP, &rsp);
	dump_stack(uc, rsp, 12);
	uint64_t ExceptionRecord, EstablisherFrame, ContextRecord, DispatcherContext;
	uc_reg_read(uc, UC_X86_REG_RCX, &ExceptionRecord);
	uc_reg_read(uc, UC_X86_REG_RDX, &EstablisherFrame);
	uc_reg_read(uc, UC_X86_REG_R8, &ContextRecord);
	uc_reg_read(uc, UC_X86_REG_R9, &DispatcherContext);
	EXCEPTION_RECORD exp;
	uc_mem_read(uc, ExceptionRecord, &exp, sizeof(exp));
	switch (exception) {
	case EXCP00_DIVZ:
	case EXCP08_DBLE:
		loader->LastException = EXCEPTION_INT_DIVIDE_BY_ZERO;
		break;
	case EXCP01_DB:
		loader->LastException = STATUS_SINGLE_STEP;
		break;
	case EXCP03_INT3:
	case 0x2d:
		loader->LastException = 0x80000003;
		break;
	case 0x20:
		return;
	case 0x29:
		loader->LastException = 0xC0000409;
		break;
	default:
		loader->LastException = STATUS_SUCCESS;
		break;
	}
	seh_Handle(uc);
}


bool Unicorn::check_is_ntFunc(uint64_t _register)
{
	for (auto& peFile : loader->peFiles) {

		if (peFile->FileName == "ntoskrnl.exe")
		{
			if (peFile->Base < _register && _register < peFile->End)
			{
				auto Ntstr = peFile->FuncRVA[_register - peFile->Base];
				Unicorn _uc{};
				if (Ntstr != "" && (
					Ntstr != "_stricmp" &&
					Ntstr != "DbgPrompt" &&
					Ntstr != "KeInitializeGuardedMutex" &&
					Ntstr != "qsort" &&
					Ntstr != "KeReadStateTimer" &&
					Ntstr != "ExAcquireSpinLockShared" &&
					Ntstr != "ExReleaseSpinLockShared" &&
					Ntstr != "memset" &&
					Ntstr != "RtlRaiseStatus" &&
					Ntstr != "__chkstk" &&
					Ntstr != "RtlUnwindEx" &&
					Ntstr != "NtQuerySystemInformation" &&
					Ntstr != "RtlUnicodeToMultiByteSize" &&
					Ntstr != "RtlUnicodeToMultiByteN")) {
					if (_uc.NtfuncMap.find(Ntstr) == _uc.NtfuncMap.end())
					{
						Logger::Log(true, ConsoleColor::DARK_GREEN, "Previous_address : 0x%llx\n", Previous_address);
						Logger::Log(true, 5, "NT Function %s \n", Ntstr.c_str());
						return true;
					}
				}
			}
		}
		else if (peFile->FileName == "cng.sys")
		{
			if (peFile->Base < _register && _register < peFile->End)
			{
				auto str = peFile->FuncRVA[_register - peFile->Base];
				if (str != "") {
					Logger::Log(true, 5, "Cng Function %s \n", str.c_str());
					return true;
				}
			}
		}
		else if (peFile->FileName == "CI.dll")
		{
			if (peFile->Base < _register && _register < peFile->End)
			{
				auto str = peFile->FuncRVA[_register - peFile->Base];
				if (str != "" && (str != "CiFreePolicyInfo" && str != "CiCheckSignedFile" && str != "KeInitializeGuardedMutex"))
				{
					Logger::Log(true, 5, "Ci Function %s \n", str.c_str());

					return true;
				}
			}
		}
		else
		{

			if (peFile->Base < _register && _register < peFile->End)
			{
				Logger::Log(true, ConsoleColor::DARK_GREEN, "next RIP : %llx \n", _register);
				return true;
			}
		}

	}
	return false;
}

bool Unicorn::hook_mem_invalid(uc_engine* uc, uc_mem_type type, uint64_t address, int size, int64_t value, void* user_data) {
	DWORD tid = GetCurrentThreadId();

	for (auto& ti : loader->Threads) {
		ResetEvent(ti->Event);
		if (ti->threadId == tid) {
			if (loader->errorevent != nullptr && loader->errorevent != ti->Event)
			{
				WaitForSingleObject(loader->errorevent, INFINITE);
				Sleep(10);
			}
			loader->errorevent = ti->Event;
			Previous_address = ti->paddress;
			Sleep(10);
		}
	}

	uint32_t count;
	uint64_t msize, rip, rsp;
	my_uc_prot my_ucport;
	void* real_addr = nullptr;
	uc_hook trace;
	size_t page_size = 0x1000;
	uint64_t aligned_address = address & ~0xFFF;

	std::vector<uint8_t> memory_data;
	uc_reg_read(uc, UC_X86_REG_RSP, &rsp);
	uc_reg_read(uc, UC_X86_REG_RIP, &rip);

	uc_err err, check;
	switch (type) {
	case UC_MEM_WRITE_PROT:
		for (auto& map : loader->real_mem_map_type_read)
		{
			aligned_address = map.first;
			msize = loader->real_mem_map[aligned_address].second;
			real_addr = map.second.first;
			if (aligned_address <= address && address <= aligned_address + msize - 1)
			{
				break;
			}
		}
		if (real_addr != nullptr)
		{
			uc_err err = uc_mem_protect(uc, aligned_address, msize, MUC_PORT_READ_WRITE);
			if (err != UC_ERR_OK) {
				Logger::Log(true, ConsoleColor::YELLOW, "uc_mem_protect failed at %llx err : %llx\n", aligned_address, err);
				return false;
			}
			loader->real_mem_map_type_read_write[aligned_address] = { real_addr, MUC_PORT_READ_WRITE };
			loader->real_mem_map_type_all.erase(aligned_address);
			loader->real_mem_map_type_read.erase(aligned_address);

			Logger::Log(true, ConsoleColor::YELLOW, "UC_MEM_WRITE_PROT memory AT %llx  msize : %llx\n", address, msize);
		}

		break;
	case UC_MEM_FETCH_PROT:
		for (auto& map : loader->real_mem_map_type_read)
		{
			aligned_address = map.first;
			msize = loader->real_mem_map[aligned_address].second;
			real_addr = map.second.first;
			if (aligned_address <= address && address <= aligned_address + msize - 1)
			{
				break;
			}
		}
		if (real_addr != nullptr)
		{
			check = uc_mem_protect(uc, aligned_address, msize, MUC_PROT_ALL);
			Logger::Log(true, ConsoleColor::RED, "EXECUTE on non-executable memory at 0x%llx\n", address);
			loader->real_mem_map_type_all[aligned_address] = { real_addr ,MUC_PROT_ALL };
			loader->real_mem_map_type_read_write.erase(aligned_address);
			loader->real_mem_map_type_read.erase(aligned_address);
			return true;
		}
		break;
	case UC_MEM_READ_UNMAPPED:

		for (auto& map : loader->real_mem_map)
		{
			aligned_address = map.first;
			msize = map.second.second;
			real_addr = map.second.first;
			my_ucport = loader->real_mem_map_type_read[aligned_address].second;
			if (my_ucport == 0)
			{
				my_ucport = loader->real_mem_map_type_read_write[aligned_address].second;
				loader->real_mem_map_type_read.erase(aligned_address);
			}

			if (my_ucport == 0)
			{
				my_ucport = loader->real_mem_map_type_all[aligned_address].second;
				loader->real_mem_map_type_read_write.erase(aligned_address);
			}

			if (aligned_address <= address && address <= aligned_address + msize - 1)
			{
				Logger::Log(true, ConsoleColor::RED, "UC_MEM_READ_UNMAPPED Remap Region AT %llx, %llx size : %llx\n",
					aligned_address,
					real_addr,
					msize);
				err = uc_mem_map_ptr(uc, aligned_address, msize, my_ucport, real_addr);
				if (err != UC_ERR_OK) {
					Logger::Log(true, ConsoleColor::YELLOW, "UC_MEM_READ_UNMAPPED failed at %llx err : %d\n", aligned_address, err);
					return false;
				}
				for (auto& ti : loader->Threads) {
					SetEvent(ti->Event);
					loader->errorevent = nullptr;
				}
				return true;
			}
		}
		aligned_address = address & ~0xFFF;

		if (aligned_address > 0)
		{
			auto page1 = loader->kdmp.GetVirtualPage(aligned_address);
			if (page1 != 0)
			{
				Emu(uc)->alloc(kPageSize, aligned_address, false);
				err = uc_mem_write(uc, aligned_address, loader->kdmp.GetVirtualPage(aligned_address), 0x1000);
				if (err != UC_ERR_OK)
				{
					Logger::Log(true, ConsoleColor::RED, "READ from unmapped memory Address error: %d\n", err);
				}
				break;
			}
			else {
				Logger::Log(true, ConsoleColor::RED, "KDMP not found address: 0x%llx\n", address);
				Emu(uc)->alloc(kPageSize, aligned_address, MUC_PROT_READ);
			}
		}

		Logger::Log(true, ConsoleColor::RED, "------------------------------\n");
		Logger::Log(true, ConsoleColor::RED, "READ from unmapped memory Address : 0x%llx\n", address);
		Logger::Log(true, ConsoleColor::RED, "------------------------------\n");
		Logger::Log(true, ConsoleColor::DARK_GREEN, "Previous_address : %llx\n", Previous_address);
		Logger::Log(true, ConsoleColor::RED, "------------------------------\n");
		break;
	case UC_MEM_WRITE_UNMAPPED:

		for (auto& map : loader->real_mem_map)
		{
			aligned_address = map.first;
			msize = map.second.second;
			real_addr = map.second.first;
			my_ucport = loader->real_mem_map_type_read[aligned_address].second;
			if (my_ucport == 0)
			{
				my_ucport = loader->real_mem_map_type_read_write[aligned_address].second;
				loader->real_mem_map_type_read.erase(aligned_address);
			}

			if (my_ucport == 0)
			{
				my_ucport = loader->real_mem_map_type_all[aligned_address].second;
				loader->real_mem_map_type_read_write.erase(aligned_address);
			}

			if (aligned_address <= address && address <= aligned_address + msize - 1)
			{
				Logger::Log(true, ConsoleColor::RED, "UC_MEM_WRITE_UNMAPPED Remap Region AT %llx, %llx size : %llx\n",
					aligned_address,
					real_addr,
					msize);
				err = uc_mem_map_ptr(uc, aligned_address, msize, my_ucport, real_addr);

				if (err != UC_ERR_OK) {
					Logger::Log(true, ConsoleColor::YELLOW, "UC_MEM_WRITE_UNMAPPED failed at %llx err : %d\n", aligned_address, err);
					return false;
				}
				for (auto& ti : loader->Threads) {
					SetEvent(ti->Event);
					loader->errorevent = nullptr;
				}
				return true;
			}
		}
		aligned_address = address & ~0xFFF;

		if (aligned_address > 0)
		{
			auto page1 = loader->kdmp.GetVirtualPage(aligned_address);
			if (page1 != 0)
			{
				Emu(uc)->alloc(kPageSize, aligned_address, false);
				uc_mem_write(uc, aligned_address, loader->kdmp.GetVirtualPage(aligned_address), 0x1000);
				break;
			}
			else {
				Logger::Log(true, ConsoleColor::RED, "KDMP not found address: 0x%llx\n", address);
				Emu(uc)->alloc(kPageSize, aligned_address, MUC_PROT_ALL);
			}
		}
		ShowRegister(uc);
		dump_stack(uc, rsp, 10);
		break;
	case UC_MEM_FETCH_UNMAPPED:
		for (auto& map : loader->real_mem_map)
		{
			aligned_address = map.first;
			msize = map.second.second;
			real_addr = map.second.first;
			my_ucport = loader->real_mem_map_type_read[aligned_address].second;
			if (my_ucport == 0)
			{
				my_ucport = loader->real_mem_map_type_read_write[aligned_address].second;
				loader->real_mem_map_type_read.erase(aligned_address);
			}

			if (my_ucport == 0)
			{
				my_ucport = loader->real_mem_map_type_all[aligned_address].second;
				loader->real_mem_map_type_read_write.erase(aligned_address);
			}
			if (aligned_address <= address && address <= aligned_address + msize - 1)
			{
				Logger::Log(true, ConsoleColor::RED, "UC_MEM_FETCH_UNMAPPED Remap Region AT %llx, %llx size : %llx\n",
					aligned_address,
					real_addr,
					msize);
				err = uc_mem_map_ptr(uc, aligned_address, msize, my_ucport, real_addr);

				if (err != UC_ERR_OK) {
					Logger::Log(true, ConsoleColor::YELLOW, "UC_MEM_FETCH_UNMAPPED failed at %llx err : %d\n", aligned_address, err);
					return false;
				}
				for (auto& ti : loader->Threads) {
					SetEvent(ti->Event);
					loader->errorevent = nullptr;
				}
				return true;
			}
		}
		for (auto& map : loader->real_mem_map)
		{
			aligned_address = map.first;
			msize = loader->real_mem_map[aligned_address].second;
			real_addr = map.second.first;
			if (my_ucport == 0)
				my_ucport = loader->real_mem_map_type_read[aligned_address].second;
			if (my_ucport == 0)
				my_ucport = loader->real_mem_map_type_read_write[aligned_address].second;
			if (my_ucport == 0)
				my_ucport = loader->real_mem_map_type_all[aligned_address].second;
			if (aligned_address <= address && address <= aligned_address + msize - 1)
			{
				Logger::Log(true, ConsoleColor::RED, "UC_MEM_FETCH_UNMAPPED Remap Region AT %llx, %llx size : %llx\n",
					aligned_address,
					real_addr,
					msize);
				err = uc_mem_map_ptr(uc, aligned_address, msize, my_ucport, real_addr);

				if (err != UC_ERR_OK) {
					Logger::Log(true, ConsoleColor::YELLOW, "UC_MEM_FETCH_UNMAPPED failed at %llx err : %d\n", aligned_address, err);
					return false;
				}
				for (auto& ti : loader->Threads) {
					SetEvent(ti->Event);
					loader->errorevent = nullptr;
				}
				return true;
			}
		}
		aligned_address = address & ~0xFFF;
		if (aligned_address > 0)
		{

			auto page2 = loader->kdmp.GetVirtualPage(aligned_address);
			if (page2 != 0)
			{
				Emu(uc)->alloc(kPageSize, aligned_address, false);
				uc_mem_write(uc, aligned_address, page2, 0x1000);
			}
			else {
				Logger::Log(true, ConsoleColor::RED, "KDMP not found address: 0x%llx\n", address);
				Emu(uc)->alloc(kPageSize, aligned_address, MUC_PROT_ALL);
			}
		}

		Logger::Log(true, ConsoleColor::RED, "------------------------------\n");
		Logger::Log(true, ConsoleColor::RED, "EXECUTE from unmapped memory Address : 0x%llx\n", address);
		Logger::Log(true, ConsoleColor::RED, "------------------------------\n");
		Logger::Log(true, ConsoleColor::DARK_GREEN, "Previous_address : %llx\n", Previous_address);
		break;

	default:
		Logger::Log(true, ConsoleColor::RED, "------------------------------\n");
		Logger::Log(true, ConsoleColor::RED, "Unknown memory error Address : 0x%llx\n", address);
		Logger::Log(true, ConsoleColor::RED, "------------------------------\n");
		Logger::Log(true, ConsoleColor::DARK_GREEN, "Previous_address : %llx\n", Previous_address);
		ShowRegister(uc);
		dump_stack(uc, rsp, 10);
		uc_emu_stop(uc);
		break;
	}

	for (auto& ti : loader->Threads) {
		SetEvent(ti->Event);
		loader->errorevent = nullptr;
	}
	return true;
}

void Unicorn::hook_access_object(uc_engine* uc, uc_mem_type type, uint64_t address, int size, int64_t value, void* user_data) {
	Object* obj = (Object*)user_data;
	uint64_t rip;
	uc_reg_read(uc, UC_X86_REG_RIP, &rip);
	switch (type) {
	case UC_MEM_READ:
		uc_mem_read(uc, address, &value, sizeof(value));
		Logger::Log(true, ConsoleColor::BLUE, "Read %s + 0x%llx at address: 0x%llx Value: %llx\n", obj->name.c_str(), address - obj->address, rip, value);
		break;
	case UC_MEM_WRITE:
		Logger::Log(true, ConsoleColor::BLUE, "Write %s + 0x%llx at address: 0x%llx Value: %llx\n", obj->name.c_str(), address - obj->address, rip, value);
		break;
	}
}

void Unicorn::hook_mem_access(uc_engine* uc, uc_mem_type type, uint64_t address, int size, int64_t value, void* user_data)
{
	uint64_t addr;
	uc_reg_read(uc, UC_X86_REG_RIP, &addr);
	_LDR_DATA_TABLE_ENTRY val;
	uint64_t useraddress;
	switch (type) {
	case UC_MEM_READ:
		uc_mem_read(uc, address, &useraddress, sizeof(useraddress));
		Logger::Log(true, 14, "[RIP address : 0x%llx ]  Read at address: 0x%llx Value: %llx\n", addr, address, useraddress);

		break;
	case UC_MEM_WRITE:
		Logger::Log(true, 11, "[RIP address : 0x%llx ]  Write in address: 0x%llx Value: %llx\n", addr, address, value);
		break;
	default:
		Logger::Log(true, ConsoleColor::DARK_GREEN, "[RIP address : 0x%llx ] Unknown memory access type at address: 0x%llx \n", address);
		break;
	}
}

void Unicorn::hook_mem_write(uc_engine* uc, uc_mem_type type, uint64_t address, int size, int64_t value, void* user_data)
{
	uint64_t addr;
	uc_reg_read(uc, UC_X86_REG_RIP, &addr);
	Logger::Log(true, 11, "RIP : 0x%llx Write in address: 0x%llx Value: %llx\n", addr, address, value);
}

void Unicorn::hook_File_func(uc_engine* uc, std::string fileName, std::string funcName, void(*func)(uc_engine*, uint64_t, uint32_t, void*)) {
	for (auto& peFile : loader->peFiles) {
		uint64_t Base = peFile->Base;
		uint64_t RVA = peFile->FuncAddr[funcName];
		uc_hook trace;
		if (RVA != 0) {
			uc_hook_add(uc, &trace, UC_HOOK_CODE, (void*)func, NULL, Base + RVA, Base + RVA + sizeof(uint8_t));
		}
	}
}

crt_buffer_t::crt_buffer_t() : m_cbSize(0), m_pBuffer(NULL)
{
}

crt_buffer_t::crt_buffer_t(size_t size) : m_cbSize(size), m_pBuffer(malloc(size))
{
}

crt_buffer_t::~crt_buffer_t()
{
	if (m_pBuffer)
		free(m_pBuffer);
}

void* crt_buffer_t::GetSpace(size_t needSize)
{
	if (m_cbSize < needSize)
	{
		if (m_pBuffer)
			m_pBuffer = realloc(m_pBuffer, needSize);
		else
			m_pBuffer = malloc(needSize);
		m_cbSize = needSize;
	}
	return m_pBuffer;
}


```

`KDemu/unicorn/unicorn/arm.h`:

```h
/* Unicorn Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2015-2017 */
/* This file is released under LGPL2.
   See COPYING.LGPL2 in root directory for more details
*/

#ifndef UNICORN_ARM_H
#define UNICORN_ARM_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _MSC_VER
#pragma warning(disable : 4201)
#endif

//> ARM CPU
typedef enum uc_cpu_arm {
    UC_CPU_ARM_926 = 0,
    UC_CPU_ARM_946,
    UC_CPU_ARM_1026,
    UC_CPU_ARM_1136_R2,
    UC_CPU_ARM_1136,
    UC_CPU_ARM_1176,
    UC_CPU_ARM_11MPCORE,
    UC_CPU_ARM_CORTEX_M0,
    UC_CPU_ARM_CORTEX_M3,
    UC_CPU_ARM_CORTEX_M4,
    UC_CPU_ARM_CORTEX_M7,
    UC_CPU_ARM_CORTEX_M33,
    UC_CPU_ARM_CORTEX_R5,
    UC_CPU_ARM_CORTEX_R5F,
    UC_CPU_ARM_CORTEX_A7,
    UC_CPU_ARM_CORTEX_A8,
    UC_CPU_ARM_CORTEX_A9,
    UC_CPU_ARM_CORTEX_A15,
    UC_CPU_ARM_TI925T,
    UC_CPU_ARM_SA1100,
    UC_CPU_ARM_SA1110,
    UC_CPU_ARM_PXA250,
    UC_CPU_ARM_PXA255,
    UC_CPU_ARM_PXA260,
    UC_CPU_ARM_PXA261,
    UC_CPU_ARM_PXA262,
    UC_CPU_ARM_PXA270,
    UC_CPU_ARM_PXA270A0,
    UC_CPU_ARM_PXA270A1,
    UC_CPU_ARM_PXA270B0,
    UC_CPU_ARM_PXA270B1,
    UC_CPU_ARM_PXA270C0,
    UC_CPU_ARM_PXA270C5,
    UC_CPU_ARM_MAX,

    UC_CPU_ARM_ENDING
} uc_cpu_arm;

// ARM coprocessor registers, use this with UC_ARM_REG_CP_REG to
// in call to uc_reg_write/read() to access the registers.
typedef struct uc_arm_cp_reg {
    uint32_t cp;   // The coprocessor identifier
    uint32_t is64; // Is it a 64 bit control register
    uint32_t sec;  // Security state
    uint32_t crn;  // Coprocessor register number
    uint32_t crm;  // Coprocessor register number
    uint32_t opc1; // Opcode1
    uint32_t opc2; // Opcode2
    uint64_t val;  // The value to read/write
} uc_arm_cp_reg;

//> ARM registers
typedef enum uc_arm_reg {
    UC_ARM_REG_INVALID = 0,
    UC_ARM_REG_APSR,
    UC_ARM_REG_APSR_NZCV,
    UC_ARM_REG_CPSR,
    UC_ARM_REG_FPEXC,
    UC_ARM_REG_FPINST,
    UC_ARM_REG_FPSCR,
    UC_ARM_REG_FPSCR_NZCV,
    UC_ARM_REG_FPSID,
    UC_ARM_REG_ITSTATE,
    UC_ARM_REG_LR,
    UC_ARM_REG_PC,
    UC_ARM_REG_SP,
    UC_ARM_REG_SPSR,
    UC_ARM_REG_D0,
    UC_ARM_REG_D1,
    UC_ARM_REG_D2,
    UC_ARM_REG_D3,
    UC_ARM_REG_D4,
    UC_ARM_REG_D5,
    UC_ARM_REG_D6,
    UC_ARM_REG_D7,
    UC_ARM_REG_D8,
    UC_ARM_REG_D9,
    UC_ARM_REG_D10,
    UC_ARM_REG_D11,
    UC_ARM_REG_D12,
    UC_ARM_REG_D13,
    UC_ARM_REG_D14,
    UC_ARM_REG_D15,
    UC_ARM_REG_D16,
    UC_ARM_REG_D17,
    UC_ARM_REG_D18,
    UC_ARM_REG_D19,
    UC_ARM_REG_D20,
    UC_ARM_REG_D21,
    UC_ARM_REG_D22,
    UC_ARM_REG_D23,
    UC_ARM_REG_D24,
    UC_ARM_REG_D25,
    UC_ARM_REG_D26,
    UC_ARM_REG_D27,
    UC_ARM_REG_D28,
    UC_ARM_REG_D29,
    UC_ARM_REG_D30,
    UC_ARM_REG_D31,
    UC_ARM_REG_FPINST2,
    UC_ARM_REG_MVFR0,
    UC_ARM_REG_MVFR1,
    UC_ARM_REG_MVFR2,
    UC_ARM_REG_Q0,
    UC_ARM_REG_Q1,
    UC_ARM_REG_Q2,
    UC_ARM_REG_Q3,
    UC_ARM_REG_Q4,
    UC_ARM_REG_Q5,
    UC_ARM_REG_Q6,
    UC_ARM_REG_Q7,
    UC_ARM_REG_Q8,
    UC_ARM_REG_Q9,
    UC_ARM_REG_Q10,
    UC_ARM_REG_Q11,
    UC_ARM_REG_Q12,
    UC_ARM_REG_Q13,
    UC_ARM_REG_Q14,
    UC_ARM_REG_Q15,
    UC_ARM_REG_R0,
    UC_ARM_REG_R1,
    UC_ARM_REG_R2,
    UC_ARM_REG_R3,
    UC_ARM_REG_R4,
    UC_ARM_REG_R5,
    UC_ARM_REG_R6,
    UC_ARM_REG_R7,
    UC_ARM_REG_R8,
    UC_ARM_REG_R9,
    UC_ARM_REG_R10,
    UC_ARM_REG_R11,
    UC_ARM_REG_R12,
    UC_ARM_REG_S0,
    UC_ARM_REG_S1,
    UC_ARM_REG_S2,
    UC_ARM_REG_S3,
    UC_ARM_REG_S4,
    UC_ARM_REG_S5,
    UC_ARM_REG_S6,
    UC_ARM_REG_S7,
    UC_ARM_REG_S8,
    UC_ARM_REG_S9,
    UC_ARM_REG_S10,
    UC_ARM_REG_S11,
    UC_ARM_REG_S12,
    UC_ARM_REG_S13,
    UC_ARM_REG_S14,
    UC_ARM_REG_S15,
    UC_ARM_REG_S16,
    UC_ARM_REG_S17,
    UC_ARM_REG_S18,
    UC_ARM_REG_S19,
    UC_ARM_REG_S20,
    UC_ARM_REG_S21,
    UC_ARM_REG_S22,
    UC_ARM_REG_S23,
    UC_ARM_REG_S24,
    UC_ARM_REG_S25,
    UC_ARM_REG_S26,
    UC_ARM_REG_S27,
    UC_ARM_REG_S28,
    UC_ARM_REG_S29,
    UC_ARM_REG_S30,
    UC_ARM_REG_S31,

    UC_ARM_REG_C1_C0_2,  // Depreciated, use UC_ARM_REG_CP_REG instead
    UC_ARM_REG_C13_C0_2, // Depreciated, use UC_ARM_REG_CP_REG instead
    UC_ARM_REG_C13_C0_3, // Depreciated, use UC_ARM_REG_CP_REG instead

    UC_ARM_REG_IPSR,
    UC_ARM_REG_MSP,
    UC_ARM_REG_PSP,
    UC_ARM_REG_CONTROL,
    UC_ARM_REG_IAPSR,
    UC_ARM_REG_EAPSR,
    UC_ARM_REG_XPSR,
    UC_ARM_REG_EPSR,
    UC_ARM_REG_IEPSR,
    UC_ARM_REG_PRIMASK,
    UC_ARM_REG_BASEPRI,
    UC_ARM_REG_BASEPRI_MAX,
    UC_ARM_REG_FAULTMASK,
    UC_ARM_REG_APSR_NZCVQ,
    UC_ARM_REG_APSR_G,
    UC_ARM_REG_APSR_NZCVQG,
    UC_ARM_REG_IAPSR_NZCVQ,
    UC_ARM_REG_IAPSR_G,
    UC_ARM_REG_IAPSR_NZCVQG,
    UC_ARM_REG_EAPSR_NZCVQ,
    UC_ARM_REG_EAPSR_G,
    UC_ARM_REG_EAPSR_NZCVQG,
    UC_ARM_REG_XPSR_NZCVQ,
    UC_ARM_REG_XPSR_G,
    UC_ARM_REG_XPSR_NZCVQG,
    UC_ARM_REG_CP_REG,
    UC_ARM_REG_ENDING, // <-- mark the end of the list or registers

    //> alias registers
    UC_ARM_REG_R13 = UC_ARM_REG_SP,
    UC_ARM_REG_R14 = UC_ARM_REG_LR,
    UC_ARM_REG_R15 = UC_ARM_REG_PC,

    UC_ARM_REG_SB = UC_ARM_REG_R9,
    UC_ARM_REG_SL = UC_ARM_REG_R10,
    UC_ARM_REG_FP = UC_ARM_REG_R11,
    UC_ARM_REG_IP = UC_ARM_REG_R12,
} uc_arm_reg;

#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/unicorn/unicorn/arm64.h`:

```h
/* Unicorn Emulator Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2015-2017 */
/* This file is released under LGPL2.
   See COPYING.LGPL2 in root directory for more details
*/

#ifndef UNICORN_ARM64_H
#define UNICORN_ARM64_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _MSC_VER
#pragma warning(disable : 4201)
#endif

//> ARM64 CPU
typedef enum uc_cpu_arm64 {
    UC_CPU_ARM64_A57 = 0,
    UC_CPU_ARM64_A53,
    UC_CPU_ARM64_A72,
    UC_CPU_ARM64_MAX,

    UC_CPU_ARM64_ENDING
} uc_cpu_arm64;

// ARM64 coprocessor registers, use this with UC_ARM64_REG_CP_REG to
// in call to uc_reg_write/read() to access the registers.
typedef struct uc_arm64_cp_reg {
    uint32_t crn; // Coprocessor register number
    uint32_t crm; // Coprocessor register number
    uint32_t op0; // Opcode0
    uint32_t op1; // Opcode1
    uint32_t op2; // Opcode2
    uint64_t val; // The value to read/write
} uc_arm64_cp_reg;

//> ARM64 registers
typedef enum uc_arm64_reg {
    UC_ARM64_REG_INVALID = 0,

    UC_ARM64_REG_X29,
    UC_ARM64_REG_X30,
    UC_ARM64_REG_NZCV,
    UC_ARM64_REG_SP,
    UC_ARM64_REG_WSP,
    UC_ARM64_REG_WZR,
    UC_ARM64_REG_XZR,
    UC_ARM64_REG_B0,
    UC_ARM64_REG_B1,
    UC_ARM64_REG_B2,
    UC_ARM64_REG_B3,
    UC_ARM64_REG_B4,
    UC_ARM64_REG_B5,
    UC_ARM64_REG_B6,
    UC_ARM64_REG_B7,
    UC_ARM64_REG_B8,
    UC_ARM64_REG_B9,
    UC_ARM64_REG_B10,
    UC_ARM64_REG_B11,
    UC_ARM64_REG_B12,
    UC_ARM64_REG_B13,
    UC_ARM64_REG_B14,
    UC_ARM64_REG_B15,
    UC_ARM64_REG_B16,
    UC_ARM64_REG_B17,
    UC_ARM64_REG_B18,
    UC_ARM64_REG_B19,
    UC_ARM64_REG_B20,
    UC_ARM64_REG_B21,
    UC_ARM64_REG_B22,
    UC_ARM64_REG_B23,
    UC_ARM64_REG_B24,
    UC_ARM64_REG_B25,
    UC_ARM64_REG_B26,
    UC_ARM64_REG_B27,
    UC_ARM64_REG_B28,
    UC_ARM64_REG_B29,
    UC_ARM64_REG_B30,
    UC_ARM64_REG_B31,
    UC_ARM64_REG_D0,
    UC_ARM64_REG_D1,
    UC_ARM64_REG_D2,
    UC_ARM64_REG_D3,
    UC_ARM64_REG_D4,
    UC_ARM64_REG_D5,
    UC_ARM64_REG_D6,
    UC_ARM64_REG_D7,
    UC_ARM64_REG_D8,
    UC_ARM64_REG_D9,
    UC_ARM64_REG_D10,
    UC_ARM64_REG_D11,
    UC_ARM64_REG_D12,
    UC_ARM64_REG_D13,
    UC_ARM64_REG_D14,
    UC_ARM64_REG_D15,
    UC_ARM64_REG_D16,
    UC_ARM64_REG_D17,
    UC_ARM64_REG_D18,
    UC_ARM64_REG_D19,
    UC_ARM64_REG_D20,
    UC_ARM64_REG_D21,
    UC_ARM64_REG_D22,
    UC_ARM64_REG_D23,
    UC_ARM64_REG_D24,
    UC_ARM64_REG_D25,
    UC_ARM64_REG_D26,
    UC_ARM64_REG_D27,
    UC_ARM64_REG_D28,
    UC_ARM64_REG_D29,
    UC_ARM64_REG_D30,
    UC_ARM64_REG_D31,
    UC_ARM64_REG_H0,
    UC_ARM64_REG_H1,
    UC_ARM64_REG_H2,
    UC_ARM64_REG_H3,
    UC_ARM64_REG_H4,
    UC_ARM64_REG_H5,
    UC_ARM64_REG_H6,
    UC_ARM64_REG_H7,
    UC_ARM64_REG_H8,
    UC_ARM64_REG_H9,
    UC_ARM64_REG_H10,
    UC_ARM64_REG_H11,
    UC_ARM64_REG_H12,
    UC_ARM64_REG_H13,
    UC_ARM64_REG_H14,
    UC_ARM64_REG_H15,
    UC_ARM64_REG_H16,
    UC_ARM64_REG_H17,
    UC_ARM64_REG_H18,
    UC_ARM64_REG_H19,
    UC_ARM64_REG_H20,
    UC_ARM64_REG_H21,
    UC_ARM64_REG_H22,
    UC_ARM64_REG_H23,
    UC_ARM64_REG_H24,
    UC_ARM64_REG_H25,
    UC_ARM64_REG_H26,
    UC_ARM64_REG_H27,
    UC_ARM64_REG_H28,
    UC_ARM64_REG_H29,
    UC_ARM64_REG_H30,
    UC_ARM64_REG_H31,
    UC_ARM64_REG_Q0,
    UC_ARM64_REG_Q1,
    UC_ARM64_REG_Q2,
    UC_ARM64_REG_Q3,
    UC_ARM64_REG_Q4,
    UC_ARM64_REG_Q5,
    UC_ARM64_REG_Q6,
    UC_ARM64_REG_Q7,
    UC_ARM64_REG_Q8,
    UC_ARM64_REG_Q9,
    UC_ARM64_REG_Q10,
    UC_ARM64_REG_Q11,
    UC_ARM64_REG_Q12,
    UC_ARM64_REG_Q13,
    UC_ARM64_REG_Q14,
    UC_ARM64_REG_Q15,
    UC_ARM64_REG_Q16,
    UC_ARM64_REG_Q17,
    UC_ARM64_REG_Q18,
    UC_ARM64_REG_Q19,
    UC_ARM64_REG_Q20,
    UC_ARM64_REG_Q21,
    UC_ARM64_REG_Q22,
    UC_ARM64_REG_Q23,
    UC_ARM64_REG_Q24,
    UC_ARM64_REG_Q25,
    UC_ARM64_REG_Q26,
    UC_ARM64_REG_Q27,
    UC_ARM64_REG_Q28,
    UC_ARM64_REG_Q29,
    UC_ARM64_REG_Q30,
    UC_ARM64_REG_Q31,
    UC_ARM64_REG_S0,
    UC_ARM64_REG_S1,
    UC_ARM64_REG_S2,
    UC_ARM64_REG_S3,
    UC_ARM64_REG_S4,
    UC_ARM64_REG_S5,
    UC_ARM64_REG_S6,
    UC_ARM64_REG_S7,
    UC_ARM64_REG_S8,
    UC_ARM64_REG_S9,
    UC_ARM64_REG_S10,
    UC_ARM64_REG_S11,
    UC_ARM64_REG_S12,
    UC_ARM64_REG_S13,
    UC_ARM64_REG_S14,
    UC_ARM64_REG_S15,
    UC_ARM64_REG_S16,
    UC_ARM64_REG_S17,
    UC_ARM64_REG_S18,
    UC_ARM64_REG_S19,
    UC_ARM64_REG_S20,
    UC_ARM64_REG_S21,
    UC_ARM64_REG_S22,
    UC_ARM64_REG_S23,
    UC_ARM64_REG_S24,
    UC_ARM64_REG_S25,
    UC_ARM64_REG_S26,
    UC_ARM64_REG_S27,
    UC_ARM64_REG_S28,
    UC_ARM64_REG_S29,
    UC_ARM64_REG_S30,
    UC_ARM64_REG_S31,
    UC_ARM64_REG_W0,
    UC_ARM64_REG_W1,
    UC_ARM64_REG_W2,
    UC_ARM64_REG_W3,
    UC_ARM64_REG_W4,
    UC_ARM64_REG_W5,
    UC_ARM64_REG_W6,
    UC_ARM64_REG_W7,
    UC_ARM64_REG_W8,
    UC_ARM64_REG_W9,
    UC_ARM64_REG_W10,
    UC_ARM64_REG_W11,
    UC_ARM64_REG_W12,
    UC_ARM64_REG_W13,
    UC_ARM64_REG_W14,
    UC_ARM64_REG_W15,
    UC_ARM64_REG_W16,
    UC_ARM64_REG_W17,
    UC_ARM64_REG_W18,
    UC_ARM64_REG_W19,
    UC_ARM64_REG_W20,
    UC_ARM64_REG_W21,
    UC_ARM64_REG_W22,
    UC_ARM64_REG_W23,
    UC_ARM64_REG_W24,
    UC_ARM64_REG_W25,
    UC_ARM64_REG_W26,
    UC_ARM64_REG_W27,
    UC_ARM64_REG_W28,
    UC_ARM64_REG_W29,
    UC_ARM64_REG_W30,
    UC_ARM64_REG_X0,
    UC_ARM64_REG_X1,
    UC_ARM64_REG_X2,
    UC_ARM64_REG_X3,
    UC_ARM64_REG_X4,
    UC_ARM64_REG_X5,
    UC_ARM64_REG_X6,
    UC_ARM64_REG_X7,
    UC_ARM64_REG_X8,
    UC_ARM64_REG_X9,
    UC_ARM64_REG_X10,
    UC_ARM64_REG_X11,
    UC_ARM64_REG_X12,
    UC_ARM64_REG_X13,
    UC_ARM64_REG_X14,
    UC_ARM64_REG_X15,
    UC_ARM64_REG_X16,
    UC_ARM64_REG_X17,
    UC_ARM64_REG_X18,
    UC_ARM64_REG_X19,
    UC_ARM64_REG_X20,
    UC_ARM64_REG_X21,
    UC_ARM64_REG_X22,
    UC_ARM64_REG_X23,
    UC_ARM64_REG_X24,
    UC_ARM64_REG_X25,
    UC_ARM64_REG_X26,
    UC_ARM64_REG_X27,
    UC_ARM64_REG_X28,

    UC_ARM64_REG_V0,
    UC_ARM64_REG_V1,
    UC_ARM64_REG_V2,
    UC_ARM64_REG_V3,
    UC_ARM64_REG_V4,
    UC_ARM64_REG_V5,
    UC_ARM64_REG_V6,
    UC_ARM64_REG_V7,
    UC_ARM64_REG_V8,
    UC_ARM64_REG_V9,
    UC_ARM64_REG_V10,
    UC_ARM64_REG_V11,
    UC_ARM64_REG_V12,
    UC_ARM64_REG_V13,
    UC_ARM64_REG_V14,
    UC_ARM64_REG_V15,
    UC_ARM64_REG_V16,
    UC_ARM64_REG_V17,
    UC_ARM64_REG_V18,
    UC_ARM64_REG_V19,
    UC_ARM64_REG_V20,
    UC_ARM64_REG_V21,
    UC_ARM64_REG_V22,
    UC_ARM64_REG_V23,
    UC_ARM64_REG_V24,
    UC_ARM64_REG_V25,
    UC_ARM64_REG_V26,
    UC_ARM64_REG_V27,
    UC_ARM64_REG_V28,
    UC_ARM64_REG_V29,
    UC_ARM64_REG_V30,
    UC_ARM64_REG_V31,

    //> pseudo registers
    UC_ARM64_REG_PC, // program counter register

    UC_ARM64_REG_CPACR_EL1,

    //> thread registers, depreciated, use UC_ARM64_REG_CP_REG instead
    UC_ARM64_REG_TPIDR_EL0,
    UC_ARM64_REG_TPIDRRO_EL0,
    UC_ARM64_REG_TPIDR_EL1,

    UC_ARM64_REG_PSTATE,

    //> exception link registers, depreciated, use UC_ARM64_REG_CP_REG instead
    UC_ARM64_REG_ELR_EL0,
    UC_ARM64_REG_ELR_EL1,
    UC_ARM64_REG_ELR_EL2,
    UC_ARM64_REG_ELR_EL3,

    //> stack pointers registers, depreciated, use UC_ARM64_REG_CP_REG instead
    UC_ARM64_REG_SP_EL0,
    UC_ARM64_REG_SP_EL1,
    UC_ARM64_REG_SP_EL2,
    UC_ARM64_REG_SP_EL3,

    //> other CP15 registers, depreciated, use UC_ARM64_REG_CP_REG instead
    UC_ARM64_REG_TTBR0_EL1,
    UC_ARM64_REG_TTBR1_EL1,

    UC_ARM64_REG_ESR_EL0,
    UC_ARM64_REG_ESR_EL1,
    UC_ARM64_REG_ESR_EL2,
    UC_ARM64_REG_ESR_EL3,

    UC_ARM64_REG_FAR_EL0,
    UC_ARM64_REG_FAR_EL1,
    UC_ARM64_REG_FAR_EL2,
    UC_ARM64_REG_FAR_EL3,

    UC_ARM64_REG_PAR_EL1,

    UC_ARM64_REG_MAIR_EL1,

    UC_ARM64_REG_VBAR_EL0,
    UC_ARM64_REG_VBAR_EL1,
    UC_ARM64_REG_VBAR_EL2,
    UC_ARM64_REG_VBAR_EL3,

    UC_ARM64_REG_CP_REG,

    //> floating point control and status registers
    UC_ARM64_REG_FPCR,
    UC_ARM64_REG_FPSR,

    UC_ARM64_REG_ENDING, // <-- mark the end of the list of registers

    //> alias registers

    UC_ARM64_REG_IP0 = UC_ARM64_REG_X16,
    UC_ARM64_REG_IP1 = UC_ARM64_REG_X17,
    UC_ARM64_REG_FP = UC_ARM64_REG_X29,
    UC_ARM64_REG_LR = UC_ARM64_REG_X30,
} uc_arm64_reg;

// Callback function for tracing MRS/MSR/SYS/SYSL. If this callback returns
// true, the read/write to system registers would be skipped (even though it may
// cause exceptions!). Note one callback per instruction is allowed.
// @reg: The source/destination register.
// @cp_reg: The source/destincation system register.
// @user_data: The user data.
typedef uint32_t (*uc_cb_insn_sys_t)(uc_engine *uc, uc_arm64_reg reg,
                                     const uc_arm64_cp_reg *cp_reg,
                                     void *user_data);

//> ARM64 instructions
typedef enum uc_arm64_insn {
    UC_ARM64_INS_INVALID = 0,

    UC_ARM64_INS_MRS,
    UC_ARM64_INS_MSR,
    UC_ARM64_INS_SYS,
    UC_ARM64_INS_SYSL,

    UC_ARM64_INS_ENDING
} uc_arm64_insn;

#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/unicorn/unicorn/m68k.h`:

```h
/* Unicorn Emulator Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2014-2017 */
/* This file is released under LGPL2.
   See COPYING.LGPL2 in root directory for more details
*/

#ifndef UNICORN_M68K_H
#define UNICORN_M68K_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _MSC_VER
#pragma warning(disable : 4201)
#endif

//> M68K CPU
typedef enum uc_cpu_m68k {
    UC_CPU_M68K_M5206 = 0,
    UC_CPU_M68K_M68000,
    UC_CPU_M68K_M68020,
    UC_CPU_M68K_M68030,
    UC_CPU_M68K_M68040,
    UC_CPU_M68K_M68060,
    UC_CPU_M68K_M5208,
    UC_CPU_M68K_CFV4E,
    UC_CPU_M68K_ANY,

    UC_CPU_M68K_ENDING
} uc_cpu_m68k;

//> M68K registers
typedef enum uc_m68k_reg {
    UC_M68K_REG_INVALID = 0,

    UC_M68K_REG_A0,
    UC_M68K_REG_A1,
    UC_M68K_REG_A2,
    UC_M68K_REG_A3,
    UC_M68K_REG_A4,
    UC_M68K_REG_A5,
    UC_M68K_REG_A6,
    UC_M68K_REG_A7,

    UC_M68K_REG_D0,
    UC_M68K_REG_D1,
    UC_M68K_REG_D2,
    UC_M68K_REG_D3,
    UC_M68K_REG_D4,
    UC_M68K_REG_D5,
    UC_M68K_REG_D6,
    UC_M68K_REG_D7,

    UC_M68K_REG_SR,
    UC_M68K_REG_PC,

    UC_M68K_REG_ENDING, // <-- mark the end of the list of registers
} uc_m68k_reg;

#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/unicorn/unicorn/mips.h`:

```h
/* Unicorn Emulator Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2015-2017 */
/* This file is released under LGPL2.
   See COPYING.LGPL2 in root directory for more details
*/

#ifndef UNICORN_MIPS_H
#define UNICORN_MIPS_H

#ifdef __cplusplus
extern "C" {
#endif

// GCC MIPS toolchain has a default macro called "mips" which breaks
// compilation
#undef mips

#ifdef _MSC_VER
#pragma warning(disable : 4201)
#endif

//> MIPS32 CPUS
typedef enum uc_cpu_mips32 {
    UC_CPU_MIPS32_4KC = 0,
    UC_CPU_MIPS32_4KM,
    UC_CPU_MIPS32_4KECR1,
    UC_CPU_MIPS32_4KEMR1,
    UC_CPU_MIPS32_4KEC,
    UC_CPU_MIPS32_4KEM,
    UC_CPU_MIPS32_24KC,
    UC_CPU_MIPS32_24KEC,
    UC_CPU_MIPS32_24KF,
    UC_CPU_MIPS32_34KF,
    UC_CPU_MIPS32_74KF,
    UC_CPU_MIPS32_M14K,
    UC_CPU_MIPS32_M14KC,
    UC_CPU_MIPS32_P5600,
    UC_CPU_MIPS32_MIPS32R6_GENERIC,
    UC_CPU_MIPS32_I7200,

    UC_CPU_MIPS32_ENDING
} uc_cpu_mips32;

//> MIPS64 CPUS
typedef enum uc_cpu_mips64 {
    UC_CPU_MIPS64_R4000 = 0,
    UC_CPU_MIPS64_VR5432,
    UC_CPU_MIPS64_5KC,
    UC_CPU_MIPS64_5KF,
    UC_CPU_MIPS64_20KC,
    UC_CPU_MIPS64_MIPS64R2_GENERIC,
    UC_CPU_MIPS64_5KEC,
    UC_CPU_MIPS64_5KEF,
    UC_CPU_MIPS64_I6400,
    UC_CPU_MIPS64_I6500,
    UC_CPU_MIPS64_LOONGSON_2E,
    UC_CPU_MIPS64_LOONGSON_2F,
    UC_CPU_MIPS64_MIPS64DSPR2,

    UC_CPU_MIPS64_ENDING
} uc_cpu_mips64;

//> MIPS registers
typedef enum UC_MIPS_REG {
    UC_MIPS_REG_INVALID = 0,
    //> General purpose registers
    UC_MIPS_REG_PC,

    UC_MIPS_REG_0,
    UC_MIPS_REG_1,
    UC_MIPS_REG_2,
    UC_MIPS_REG_3,
    UC_MIPS_REG_4,
    UC_MIPS_REG_5,
    UC_MIPS_REG_6,
    UC_MIPS_REG_7,
    UC_MIPS_REG_8,
    UC_MIPS_REG_9,
    UC_MIPS_REG_10,
    UC_MIPS_REG_11,
    UC_MIPS_REG_12,
    UC_MIPS_REG_13,
    UC_MIPS_REG_14,
    UC_MIPS_REG_15,
    UC_MIPS_REG_16,
    UC_MIPS_REG_17,
    UC_MIPS_REG_18,
    UC_MIPS_REG_19,
    UC_MIPS_REG_20,
    UC_MIPS_REG_21,
    UC_MIPS_REG_22,
    UC_MIPS_REG_23,
    UC_MIPS_REG_24,
    UC_MIPS_REG_25,
    UC_MIPS_REG_26,
    UC_MIPS_REG_27,
    UC_MIPS_REG_28,
    UC_MIPS_REG_29,
    UC_MIPS_REG_30,
    UC_MIPS_REG_31,

    //> DSP registers
    UC_MIPS_REG_DSPCCOND,
    UC_MIPS_REG_DSPCARRY,
    UC_MIPS_REG_DSPEFI,
    UC_MIPS_REG_DSPOUTFLAG,
    UC_MIPS_REG_DSPOUTFLAG16_19,
    UC_MIPS_REG_DSPOUTFLAG20,
    UC_MIPS_REG_DSPOUTFLAG21,
    UC_MIPS_REG_DSPOUTFLAG22,
    UC_MIPS_REG_DSPOUTFLAG23,
    UC_MIPS_REG_DSPPOS,
    UC_MIPS_REG_DSPSCOUNT,

    //> ACC registers
    UC_MIPS_REG_AC0,
    UC_MIPS_REG_AC1,
    UC_MIPS_REG_AC2,
    UC_MIPS_REG_AC3,

    //> COP registers
    UC_MIPS_REG_CC0,
    UC_MIPS_REG_CC1,
    UC_MIPS_REG_CC2,
    UC_MIPS_REG_CC3,
    UC_MIPS_REG_CC4,
    UC_MIPS_REG_CC5,
    UC_MIPS_REG_CC6,
    UC_MIPS_REG_CC7,

    //> FPU registers
    UC_MIPS_REG_F0,
    UC_MIPS_REG_F1,
    UC_MIPS_REG_F2,
    UC_MIPS_REG_F3,
    UC_MIPS_REG_F4,
    UC_MIPS_REG_F5,
    UC_MIPS_REG_F6,
    UC_MIPS_REG_F7,
    UC_MIPS_REG_F8,
    UC_MIPS_REG_F9,
    UC_MIPS_REG_F10,
    UC_MIPS_REG_F11,
    UC_MIPS_REG_F12,
    UC_MIPS_REG_F13,
    UC_MIPS_REG_F14,
    UC_MIPS_REG_F15,
    UC_MIPS_REG_F16,
    UC_MIPS_REG_F17,
    UC_MIPS_REG_F18,
    UC_MIPS_REG_F19,
    UC_MIPS_REG_F20,
    UC_MIPS_REG_F21,
    UC_MIPS_REG_F22,
    UC_MIPS_REG_F23,
    UC_MIPS_REG_F24,
    UC_MIPS_REG_F25,
    UC_MIPS_REG_F26,
    UC_MIPS_REG_F27,
    UC_MIPS_REG_F28,
    UC_MIPS_REG_F29,
    UC_MIPS_REG_F30,
    UC_MIPS_REG_F31,

    UC_MIPS_REG_FCC0,
    UC_MIPS_REG_FCC1,
    UC_MIPS_REG_FCC2,
    UC_MIPS_REG_FCC3,
    UC_MIPS_REG_FCC4,
    UC_MIPS_REG_FCC5,
    UC_MIPS_REG_FCC6,
    UC_MIPS_REG_FCC7,

    //> AFPR128
    UC_MIPS_REG_W0,
    UC_MIPS_REG_W1,
    UC_MIPS_REG_W2,
    UC_MIPS_REG_W3,
    UC_MIPS_REG_W4,
    UC_MIPS_REG_W5,
    UC_MIPS_REG_W6,
    UC_MIPS_REG_W7,
    UC_MIPS_REG_W8,
    UC_MIPS_REG_W9,
    UC_MIPS_REG_W10,
    UC_MIPS_REG_W11,
    UC_MIPS_REG_W12,
    UC_MIPS_REG_W13,
    UC_MIPS_REG_W14,
    UC_MIPS_REG_W15,
    UC_MIPS_REG_W16,
    UC_MIPS_REG_W17,
    UC_MIPS_REG_W18,
    UC_MIPS_REG_W19,
    UC_MIPS_REG_W20,
    UC_MIPS_REG_W21,
    UC_MIPS_REG_W22,
    UC_MIPS_REG_W23,
    UC_MIPS_REG_W24,
    UC_MIPS_REG_W25,
    UC_MIPS_REG_W26,
    UC_MIPS_REG_W27,
    UC_MIPS_REG_W28,
    UC_MIPS_REG_W29,
    UC_MIPS_REG_W30,
    UC_MIPS_REG_W31,

    UC_MIPS_REG_HI,
    UC_MIPS_REG_LO,

    UC_MIPS_REG_P0,
    UC_MIPS_REG_P1,
    UC_MIPS_REG_P2,

    UC_MIPS_REG_MPL0,
    UC_MIPS_REG_MPL1,
    UC_MIPS_REG_MPL2,

    UC_MIPS_REG_CP0_CONFIG3,
    UC_MIPS_REG_CP0_USERLOCAL,
    UC_MIPS_REG_CP0_STATUS,

    UC_MIPS_REG_ENDING, // <-- mark the end of the list or registers

    // alias registers
    UC_MIPS_REG_ZERO = UC_MIPS_REG_0,
    UC_MIPS_REG_AT = UC_MIPS_REG_1,
    UC_MIPS_REG_V0 = UC_MIPS_REG_2,
    UC_MIPS_REG_V1 = UC_MIPS_REG_3,
    UC_MIPS_REG_A0 = UC_MIPS_REG_4,
    UC_MIPS_REG_A1 = UC_MIPS_REG_5,
    UC_MIPS_REG_A2 = UC_MIPS_REG_6,
    UC_MIPS_REG_A3 = UC_MIPS_REG_7,
    UC_MIPS_REG_T0 = UC_MIPS_REG_8,
    UC_MIPS_REG_T1 = UC_MIPS_REG_9,
    UC_MIPS_REG_T2 = UC_MIPS_REG_10,
    UC_MIPS_REG_T3 = UC_MIPS_REG_11,
    UC_MIPS_REG_T4 = UC_MIPS_REG_12,
    UC_MIPS_REG_T5 = UC_MIPS_REG_13,
    UC_MIPS_REG_T6 = UC_MIPS_REG_14,
    UC_MIPS_REG_T7 = UC_MIPS_REG_15,
    UC_MIPS_REG_S0 = UC_MIPS_REG_16,
    UC_MIPS_REG_S1 = UC_MIPS_REG_17,
    UC_MIPS_REG_S2 = UC_MIPS_REG_18,
    UC_MIPS_REG_S3 = UC_MIPS_REG_19,
    UC_MIPS_REG_S4 = UC_MIPS_REG_20,
    UC_MIPS_REG_S5 = UC_MIPS_REG_21,
    UC_MIPS_REG_S6 = UC_MIPS_REG_22,
    UC_MIPS_REG_S7 = UC_MIPS_REG_23,
    UC_MIPS_REG_T8 = UC_MIPS_REG_24,
    UC_MIPS_REG_T9 = UC_MIPS_REG_25,
    UC_MIPS_REG_K0 = UC_MIPS_REG_26,
    UC_MIPS_REG_K1 = UC_MIPS_REG_27,
    UC_MIPS_REG_GP = UC_MIPS_REG_28,
    UC_MIPS_REG_SP = UC_MIPS_REG_29,
    UC_MIPS_REG_FP = UC_MIPS_REG_30,
    UC_MIPS_REG_S8 = UC_MIPS_REG_30,
    UC_MIPS_REG_RA = UC_MIPS_REG_31,

    UC_MIPS_REG_HI0 = UC_MIPS_REG_AC0,
    UC_MIPS_REG_HI1 = UC_MIPS_REG_AC1,
    UC_MIPS_REG_HI2 = UC_MIPS_REG_AC2,
    UC_MIPS_REG_HI3 = UC_MIPS_REG_AC3,

    UC_MIPS_REG_LO0 = UC_MIPS_REG_HI0,
    UC_MIPS_REG_LO1 = UC_MIPS_REG_HI1,
    UC_MIPS_REG_LO2 = UC_MIPS_REG_HI2,
    UC_MIPS_REG_LO3 = UC_MIPS_REG_HI3,
} UC_MIPS_REG;

#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/unicorn/unicorn/platform.h`:

```h
/* This file is released under LGPL2.
   See COPYING.LGPL2 in root directory for more details
*/

/*
 This file is to support header files that are missing in MSVC and
 other non-standard compilers.
*/
#ifndef UNICORN_PLATFORM_H
#define UNICORN_PLATFORM_H

/*
These are the various MSVC versions as given by _MSC_VER:
MSVC++ 14.0 _MSC_VER == 1900 (Visual Studio 2015)
MSVC++ 12.0 _MSC_VER == 1800 (Visual Studio 2013)
MSVC++ 11.0 _MSC_VER == 1700 (Visual Studio 2012)
MSVC++ 10.0 _MSC_VER == 1600 (Visual Studio 2010)
MSVC++ 9.0  _MSC_VER == 1500 (Visual Studio 2008)
MSVC++ 8.0  _MSC_VER == 1400 (Visual Studio 2005)
MSVC++ 7.1  _MSC_VER == 1310 (Visual Studio 2003)
MSVC++ 7.0  _MSC_VER == 1300
MSVC++ 6.0  _MSC_VER == 1200
MSVC++ 5.0  _MSC_VER == 1100
*/
#define MSC_VER_VS2003 1310
#define MSC_VER_VS2005 1400
#define MSC_VER_VS2008 1500
#define MSC_VER_VS2010 1600
#define MSC_VER_VS2012 1700
#define MSC_VER_VS2013 1800
#define MSC_VER_VS2015 1900

// handle stdbool.h compatibility
#if !defined(__CYGWIN__) && !defined(__MINGW32__) && !defined(__MINGW64__) &&  \
    (defined(WIN32) || defined(WIN64) || defined(_WIN32) || defined(_WIN64))
// MSVC

// stdbool.h
#if (_MSC_VER < MSC_VER_VS2013) || defined(_KERNEL_MODE)
// this system does not have stdbool.h
#ifndef __cplusplus
typedef unsigned char bool;
#define false 0
#define true 1
#endif // __cplusplus

#else
// VisualStudio 2013+ -> C99 is supported
#include <stdbool.h>
#endif // (_MSC_VER < MSC_VER_VS2013) || defined(_KERNEL_MODE)

#else
// not MSVC -> C99 is supported
#include <stdbool.h>
#endif // !defined(__CYGWIN__) && !defined(__MINGW32__) && !defined(__MINGW64__)
       // && (defined (WIN32) || defined (WIN64) || defined (_WIN32) || defined
       // (_WIN64))

#if (defined(_MSC_VER) && (_MSC_VER < MSC_VER_VS2010)) || defined(_KERNEL_MODE)
// this system does not have stdint.h
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed int int32_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef signed long long int64_t;
typedef unsigned long long uint64_t;

typedef signed char int_fast8_t;
typedef int int_fast16_t;
typedef int int_fast32_t;
typedef long long int_fast64_t;
typedef unsigned char uint_fast8_t;
typedef unsigned int uint_fast16_t;
typedef unsigned int uint_fast32_t;
typedef unsigned long long uint_fast64_t;

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

#ifndef _INTPTR_T_DEFINED
#define _INTPTR_T_DEFINED
#ifdef _WIN64
typedef long long intptr_t;
#else  /* _WIN64 */
typedef _W64 int intptr_t;
#endif /* _WIN64 */
#endif /* _INTPTR_T_DEFINED */

#ifndef _UINTPTR_T_DEFINED
#define _UINTPTR_T_DEFINED
#ifdef _WIN64
typedef unsigned long long uintptr_t;
#else  /* _WIN64 */
typedef _W64 unsigned int uintptr_t;
#endif /* _WIN64 */
#endif /* _UINTPTR_T_DEFINED */

#define INT8_MIN (-127i8 - 1)
#define INT16_MIN (-32767i16 - 1)
#define INT32_MIN (-2147483647i32 - 1)
#define INT64_MIN (-9223372036854775807i64 - 1)
#define INT8_MAX 127i8
#define INT16_MAX 32767i16
#define INT32_MAX 2147483647i32
#define INT64_MAX 9223372036854775807i64
#define UINT8_MAX 0xffui8
#define UINT16_MAX 0xffffui16
#define UINT32_MAX 0xffffffffui32
#define UINT64_MAX 0xffffffffffffffffui64

#define INT_FAST8_MIN INT8_MIN
#define INT_FAST16_MIN INT32_MIN
#define INT_FAST32_MIN INT32_MIN
#define INT_FAST64_MIN INT64_MIN
#define INT_FAST8_MAX INT8_MAX
#define INT_FAST16_MAX INT32_MAX
#define INT_FAST32_MAX INT32_MAX
#define INT_FAST64_MAX INT64_MAX
#define UINT_FAST8_MAX UINT8_MAX
#define UINT_FAST16_MAX UINT32_MAX
#define UINT_FAST32_MAX UINT32_MAX
#define UINT_FAST64_MAX UINT64_MAX

#ifdef _WIN64
#define INTPTR_MIN INT64_MIN
#define INTPTR_MAX INT64_MAX
#define UINTPTR_MAX UINT64_MAX
#else /* _WIN64 */
#define INTPTR_MIN INT32_MIN
#define INTPTR_MAX INT32_MAX
#define UINTPTR_MAX UINT32_MAX
#endif /* _WIN64 */

#else // this system has stdint.h

#if defined(_MSC_VER) && (_MSC_VER == MSC_VER_VS2010)
#define _INTPTR 2
#endif

#include <stdint.h>
#endif // (defined(_MSC_VER) && (_MSC_VER < MSC_VER_VS2010)) ||
       // defined(_KERNEL_MODE)

// handle inttypes.h compatibility
#if (defined(_MSC_VER) && (_MSC_VER < MSC_VER_VS2013)) || defined(_KERNEL_MODE)
// this system does not have inttypes.h

#define __PRI_8_LENGTH_MODIFIER__ "hh"
#define __PRI_64_LENGTH_MODIFIER__ "ll"

#define PRId8 __PRI_8_LENGTH_MODIFIER__ "d"
#define PRIi8 __PRI_8_LENGTH_MODIFIER__ "i"
#define PRIo8 __PRI_8_LENGTH_MODIFIER__ "o"
#define PRIu8 __PRI_8_LENGTH_MODIFIER__ "u"
#define PRIx8 __PRI_8_LENGTH_MODIFIER__ "x"
#define PRIX8 __PRI_8_LENGTH_MODIFIER__ "X"

#define PRId16 "hd"
#define PRIi16 "hi"
#define PRIo16 "ho"
#define PRIu16 "hu"
#define PRIx16 "hx"
#define PRIX16 "hX"

#if defined(_MSC_VER) && (_MSC_VER <= MSC_VER_VS2012)
#define PRId32 "ld"
#define PRIi32 "li"
#define PRIo32 "lo"
#define PRIu32 "lu"
#define PRIx32 "lx"
#define PRIX32 "lX"
#else // OSX
#define PRId32 "d"
#define PRIi32 "i"
#define PRIo32 "o"
#define PRIu32 "u"
#define PRIx32 "x"
#define PRIX32 "X"
#endif // defined(_MSC_VER) && (_MSC_VER <= MSC_VER_VS2012)

#if defined(_MSC_VER) && (_MSC_VER <= MSC_VER_VS2012)
// redefine functions from inttypes.h used in cstool
#define strtoull _strtoui64
#endif

#define PRId64 __PRI_64_LENGTH_MODIFIER__ "d"
#define PRIi64 __PRI_64_LENGTH_MODIFIER__ "i"
#define PRIo64 __PRI_64_LENGTH_MODIFIER__ "o"
#define PRIu64 __PRI_64_LENGTH_MODIFIER__ "u"
#define PRIx64 __PRI_64_LENGTH_MODIFIER__ "x"
#define PRIX64 __PRI_64_LENGTH_MODIFIER__ "X"

#else
// this system has inttypes.h by default
#include <inttypes.h>
#endif // #if defined(_MSC_VER) && (_MSC_VER < MSC_VER_VS2013) ||
       // defined(_KERNEL_MODE)

// sys/time.h compatibility
#if defined(_MSC_VER)
#include <sys/types.h>
#include <sys/timeb.h>
#include <windows.h>

#else
#include <sys/time.h>
#endif

// unistd.h compatibility
#if defined(_MSC_VER)

static int usleep(uint32_t usec)
{
    HANDLE timer;
    LARGE_INTEGER due;

    timer = CreateWaitableTimer(NULL, TRUE, NULL);
    if (!timer)
        return -1;

    due.QuadPart = (-((int64_t)usec)) * 10LL;
    if (!SetWaitableTimer(timer, &due, 0, NULL, NULL, 0)) {
        CloseHandle(timer);
        return -1;
    }
    WaitForSingleObject(timer, INFINITE);
    CloseHandle(timer);

    return 0;
}

#else
#include <unistd.h>
#endif

// misc support
#if defined(_MSC_VER)
#ifdef _WIN64
typedef signed __int64 ssize_t;
#else
typedef _W64 signed int ssize_t;
#endif

#ifndef va_copy
#define va_copy(d, s) ((d) = (s))
#endif
#define strcasecmp _stricmp
#if (_MSC_VER < MSC_VER_VS2015)
#define snprintf _snprintf
#endif
#if (_MSC_VER <= MSC_VER_VS2013)
#define strtoll _strtoi64
#endif
#endif

#endif // UNICORN_PLATFORM_H

```

`KDemu/unicorn/unicorn/ppc.h`:

```h
/* Unicorn Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2015-2017 */
/* This file is released under LGPL2.
   See COPYING.LGPL2 in root directory for more details
*/

#ifndef UNICORN_PPC_H
#define UNICORN_PPC_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _MSC_VER
#pragma warning(disable : 4201)
#endif

//> PPC CPU
typedef enum uc_cpu_ppc {
    UC_CPU_PPC32_401 = 0,
    UC_CPU_PPC32_401A1,
    UC_CPU_PPC32_401B2,
    UC_CPU_PPC32_401C2,
    UC_CPU_PPC32_401D2,
    UC_CPU_PPC32_401E2,
    UC_CPU_PPC32_401F2,
    UC_CPU_PPC32_401G2,
    UC_CPU_PPC32_IOP480,
    UC_CPU_PPC32_COBRA,
    UC_CPU_PPC32_403GA,
    UC_CPU_PPC32_403GB,
    UC_CPU_PPC32_403GC,
    UC_CPU_PPC32_403GCX,
    UC_CPU_PPC32_405D2,
    UC_CPU_PPC32_405D4,
    UC_CPU_PPC32_405CRA,
    UC_CPU_PPC32_405CRB,
    UC_CPU_PPC32_405CRC,
    UC_CPU_PPC32_405EP,
    UC_CPU_PPC32_405EZ,
    UC_CPU_PPC32_405GPA,
    UC_CPU_PPC32_405GPB,
    UC_CPU_PPC32_405GPC,
    UC_CPU_PPC32_405GPD,
    UC_CPU_PPC32_405GPR,
    UC_CPU_PPC32_405LP,
    UC_CPU_PPC32_NPE405H,
    UC_CPU_PPC32_NPE405H2,
    UC_CPU_PPC32_NPE405L,
    UC_CPU_PPC32_NPE4GS3,
    UC_CPU_PPC32_STB03,
    UC_CPU_PPC32_STB04,
    UC_CPU_PPC32_STB25,
    UC_CPU_PPC32_X2VP4,
    UC_CPU_PPC32_X2VP20,
    UC_CPU_PPC32_440_XILINX,
    UC_CPU_PPC32_440_XILINX_W_DFPU,
    UC_CPU_PPC32_440EPA,
    UC_CPU_PPC32_440EPB,
    UC_CPU_PPC32_440EPX,
    UC_CPU_PPC32_460EXB,
    UC_CPU_PPC32_G2,
    UC_CPU_PPC32_G2H4,
    UC_CPU_PPC32_G2GP,
    UC_CPU_PPC32_G2LS,
    UC_CPU_PPC32_G2HIP3,
    UC_CPU_PPC32_G2HIP4,
    UC_CPU_PPC32_MPC603,
    UC_CPU_PPC32_G2LE,
    UC_CPU_PPC32_G2LEGP,
    UC_CPU_PPC32_G2LELS,
    UC_CPU_PPC32_G2LEGP1,
    UC_CPU_PPC32_G2LEGP3,
    UC_CPU_PPC32_MPC5200_V10,
    UC_CPU_PPC32_MPC5200_V11,
    UC_CPU_PPC32_MPC5200_V12,
    UC_CPU_PPC32_MPC5200B_V20,
    UC_CPU_PPC32_MPC5200B_V21,
    UC_CPU_PPC32_E200Z5,
    UC_CPU_PPC32_E200Z6,
    UC_CPU_PPC32_E300C1,
    UC_CPU_PPC32_E300C2,
    UC_CPU_PPC32_E300C3,
    UC_CPU_PPC32_E300C4,
    UC_CPU_PPC32_MPC8343,
    UC_CPU_PPC32_MPC8343A,
    UC_CPU_PPC32_MPC8343E,
    UC_CPU_PPC32_MPC8343EA,
    UC_CPU_PPC32_MPC8347T,
    UC_CPU_PPC32_MPC8347P,
    UC_CPU_PPC32_MPC8347AT,
    UC_CPU_PPC32_MPC8347AP,
    UC_CPU_PPC32_MPC8347ET,
    UC_CPU_PPC32_MPC8347EP,
    UC_CPU_PPC32_MPC8347EAT,
    UC_CPU_PPC32_MPC8347EAP,
    UC_CPU_PPC32_MPC8349,
    UC_CPU_PPC32_MPC8349A,
    UC_CPU_PPC32_MPC8349E,
    UC_CPU_PPC32_MPC8349EA,
    UC_CPU_PPC32_MPC8377,
    UC_CPU_PPC32_MPC8377E,
    UC_CPU_PPC32_MPC8378,
    UC_CPU_PPC32_MPC8378E,
    UC_CPU_PPC32_MPC8379,
    UC_CPU_PPC32_MPC8379E,
    UC_CPU_PPC32_E500_V10,
    UC_CPU_PPC32_E500_V20,
    UC_CPU_PPC32_E500V2_V10,
    UC_CPU_PPC32_E500V2_V20,
    UC_CPU_PPC32_E500V2_V21,
    UC_CPU_PPC32_E500V2_V22,
    UC_CPU_PPC32_E500V2_V30,
    UC_CPU_PPC32_E500MC,
    UC_CPU_PPC32_MPC8533_V10,
    UC_CPU_PPC32_MPC8533_V11,
    UC_CPU_PPC32_MPC8533E_V10,
    UC_CPU_PPC32_MPC8533E_V11,
    UC_CPU_PPC32_MPC8540_V10,
    UC_CPU_PPC32_MPC8540_V20,
    UC_CPU_PPC32_MPC8540_V21,
    UC_CPU_PPC32_MPC8541_V10,
    UC_CPU_PPC32_MPC8541_V11,
    UC_CPU_PPC32_MPC8541E_V10,
    UC_CPU_PPC32_MPC8541E_V11,
    UC_CPU_PPC32_MPC8543_V10,
    UC_CPU_PPC32_MPC8543_V11,
    UC_CPU_PPC32_MPC8543_V20,
    UC_CPU_PPC32_MPC8543_V21,
    UC_CPU_PPC32_MPC8543E_V10,
    UC_CPU_PPC32_MPC8543E_V11,
    UC_CPU_PPC32_MPC8543E_V20,
    UC_CPU_PPC32_MPC8543E_V21,
    UC_CPU_PPC32_MPC8544_V10,
    UC_CPU_PPC32_MPC8544_V11,
    UC_CPU_PPC32_MPC8544E_V10,
    UC_CPU_PPC32_MPC8544E_V11,
    UC_CPU_PPC32_MPC8545_V20,
    UC_CPU_PPC32_MPC8545_V21,
    UC_CPU_PPC32_MPC8545E_V20,
    UC_CPU_PPC32_MPC8545E_V21,
    UC_CPU_PPC32_MPC8547E_V20,
    UC_CPU_PPC32_MPC8547E_V21,
    UC_CPU_PPC32_MPC8548_V10,
    UC_CPU_PPC32_MPC8548_V11,
    UC_CPU_PPC32_MPC8548_V20,
    UC_CPU_PPC32_MPC8548_V21,
    UC_CPU_PPC32_MPC8548E_V10,
    UC_CPU_PPC32_MPC8548E_V11,
    UC_CPU_PPC32_MPC8548E_V20,
    UC_CPU_PPC32_MPC8548E_V21,
    UC_CPU_PPC32_MPC8555_V10,
    UC_CPU_PPC32_MPC8555_V11,
    UC_CPU_PPC32_MPC8555E_V10,
    UC_CPU_PPC32_MPC8555E_V11,
    UC_CPU_PPC32_MPC8560_V10,
    UC_CPU_PPC32_MPC8560_V20,
    UC_CPU_PPC32_MPC8560_V21,
    UC_CPU_PPC32_MPC8567,
    UC_CPU_PPC32_MPC8567E,
    UC_CPU_PPC32_MPC8568,
    UC_CPU_PPC32_MPC8568E,
    UC_CPU_PPC32_MPC8572,
    UC_CPU_PPC32_MPC8572E,
    UC_CPU_PPC32_E600,
    UC_CPU_PPC32_MPC8610,
    UC_CPU_PPC32_MPC8641,
    UC_CPU_PPC32_MPC8641D,
    UC_CPU_PPC32_601_V0,
    UC_CPU_PPC32_601_V1,
    UC_CPU_PPC32_601_V2,
    UC_CPU_PPC32_602,
    UC_CPU_PPC32_603,
    UC_CPU_PPC32_603E_V1_1,
    UC_CPU_PPC32_603E_V1_2,
    UC_CPU_PPC32_603E_V1_3,
    UC_CPU_PPC32_603E_V1_4,
    UC_CPU_PPC32_603E_V2_2,
    UC_CPU_PPC32_603E_V3,
    UC_CPU_PPC32_603E_V4,
    UC_CPU_PPC32_603E_V4_1,
    UC_CPU_PPC32_603E7,
    UC_CPU_PPC32_603E7T,
    UC_CPU_PPC32_603E7V,
    UC_CPU_PPC32_603E7V1,
    UC_CPU_PPC32_603E7V2,
    UC_CPU_PPC32_603P,
    UC_CPU_PPC32_604,
    UC_CPU_PPC32_604E_V1_0,
    UC_CPU_PPC32_604E_V2_2,
    UC_CPU_PPC32_604E_V2_4,
    UC_CPU_PPC32_604R,
    UC_CPU_PPC32_740_V1_0,
    UC_CPU_PPC32_750_V1_0,
    UC_CPU_PPC32_740_V2_0,
    UC_CPU_PPC32_750_V2_0,
    UC_CPU_PPC32_740_V2_1,
    UC_CPU_PPC32_750_V2_1,
    UC_CPU_PPC32_740_V2_2,
    UC_CPU_PPC32_750_V2_2,
    UC_CPU_PPC32_740_V3_0,
    UC_CPU_PPC32_750_V3_0,
    UC_CPU_PPC32_740_V3_1,
    UC_CPU_PPC32_750_V3_1,
    UC_CPU_PPC32_740E,
    UC_CPU_PPC32_750E,
    UC_CPU_PPC32_740P,
    UC_CPU_PPC32_750P,
    UC_CPU_PPC32_750CL_V1_0,
    UC_CPU_PPC32_750CL_V2_0,
    UC_CPU_PPC32_750CX_V1_0,
    UC_CPU_PPC32_750CX_V2_0,
    UC_CPU_PPC32_750CX_V2_1,
    UC_CPU_PPC32_750CX_V2_2,
    UC_CPU_PPC32_750CXE_V2_1,
    UC_CPU_PPC32_750CXE_V2_2,
    UC_CPU_PPC32_750CXE_V2_3,
    UC_CPU_PPC32_750CXE_V2_4,
    UC_CPU_PPC32_750CXE_V2_4B,
    UC_CPU_PPC32_750CXE_V3_0,
    UC_CPU_PPC32_750CXE_V3_1,
    UC_CPU_PPC32_750CXE_V3_1B,
    UC_CPU_PPC32_750CXR,
    UC_CPU_PPC32_750FL,
    UC_CPU_PPC32_750FX_V1_0,
    UC_CPU_PPC32_750FX_V2_0,
    UC_CPU_PPC32_750FX_V2_1,
    UC_CPU_PPC32_750FX_V2_2,
    UC_CPU_PPC32_750FX_V2_3,
    UC_CPU_PPC32_750GL,
    UC_CPU_PPC32_750GX_V1_0,
    UC_CPU_PPC32_750GX_V1_1,
    UC_CPU_PPC32_750GX_V1_2,
    UC_CPU_PPC32_750L_V2_0,
    UC_CPU_PPC32_750L_V2_1,
    UC_CPU_PPC32_750L_V2_2,
    UC_CPU_PPC32_750L_V3_0,
    UC_CPU_PPC32_750L_V3_2,
    UC_CPU_PPC32_745_V1_0,
    UC_CPU_PPC32_755_V1_0,
    UC_CPU_PPC32_745_V1_1,
    UC_CPU_PPC32_755_V1_1,
    UC_CPU_PPC32_745_V2_0,
    UC_CPU_PPC32_755_V2_0,
    UC_CPU_PPC32_745_V2_1,
    UC_CPU_PPC32_755_V2_1,
    UC_CPU_PPC32_745_V2_2,
    UC_CPU_PPC32_755_V2_2,
    UC_CPU_PPC32_745_V2_3,
    UC_CPU_PPC32_755_V2_3,
    UC_CPU_PPC32_745_V2_4,
    UC_CPU_PPC32_755_V2_4,
    UC_CPU_PPC32_745_V2_5,
    UC_CPU_PPC32_755_V2_5,
    UC_CPU_PPC32_745_V2_6,
    UC_CPU_PPC32_755_V2_6,
    UC_CPU_PPC32_745_V2_7,
    UC_CPU_PPC32_755_V2_7,
    UC_CPU_PPC32_745_V2_8,
    UC_CPU_PPC32_755_V2_8,
    UC_CPU_PPC32_7400_V1_0,
    UC_CPU_PPC32_7400_V1_1,
    UC_CPU_PPC32_7400_V2_0,
    UC_CPU_PPC32_7400_V2_1,
    UC_CPU_PPC32_7400_V2_2,
    UC_CPU_PPC32_7400_V2_6,
    UC_CPU_PPC32_7400_V2_7,
    UC_CPU_PPC32_7400_V2_8,
    UC_CPU_PPC32_7400_V2_9,
    UC_CPU_PPC32_7410_V1_0,
    UC_CPU_PPC32_7410_V1_1,
    UC_CPU_PPC32_7410_V1_2,
    UC_CPU_PPC32_7410_V1_3,
    UC_CPU_PPC32_7410_V1_4,
    UC_CPU_PPC32_7448_V1_0,
    UC_CPU_PPC32_7448_V1_1,
    UC_CPU_PPC32_7448_V2_0,
    UC_CPU_PPC32_7448_V2_1,
    UC_CPU_PPC32_7450_V1_0,
    UC_CPU_PPC32_7450_V1_1,
    UC_CPU_PPC32_7450_V1_2,
    UC_CPU_PPC32_7450_V2_0,
    UC_CPU_PPC32_7450_V2_1,
    UC_CPU_PPC32_7441_V2_1,
    UC_CPU_PPC32_7441_V2_3,
    UC_CPU_PPC32_7451_V2_3,
    UC_CPU_PPC32_7441_V2_10,
    UC_CPU_PPC32_7451_V2_10,
    UC_CPU_PPC32_7445_V1_0,
    UC_CPU_PPC32_7455_V1_0,
    UC_CPU_PPC32_7445_V2_1,
    UC_CPU_PPC32_7455_V2_1,
    UC_CPU_PPC32_7445_V3_2,
    UC_CPU_PPC32_7455_V3_2,
    UC_CPU_PPC32_7445_V3_3,
    UC_CPU_PPC32_7455_V3_3,
    UC_CPU_PPC32_7445_V3_4,
    UC_CPU_PPC32_7455_V3_4,
    UC_CPU_PPC32_7447_V1_0,
    UC_CPU_PPC32_7457_V1_0,
    UC_CPU_PPC32_7447_V1_1,
    UC_CPU_PPC32_7457_V1_1,
    UC_CPU_PPC32_7457_V1_2,
    UC_CPU_PPC32_7447A_V1_0,
    UC_CPU_PPC32_7457A_V1_0,
    UC_CPU_PPC32_7447A_V1_1,
    UC_CPU_PPC32_7457A_V1_1,
    UC_CPU_PPC32_7447A_V1_2,
    UC_CPU_PPC32_7457A_V1_2,

    UC_CPU_PPC32_ENDING
} uc_cpu_ppc;

//> PPC64 CPU
typedef enum uc_cpu_ppc64 {
    UC_CPU_PPC64_E5500 = 0,
    UC_CPU_PPC64_E6500,
    UC_CPU_PPC64_970_V2_2,
    UC_CPU_PPC64_970FX_V1_0,
    UC_CPU_PPC64_970FX_V2_0,
    UC_CPU_PPC64_970FX_V2_1,
    UC_CPU_PPC64_970FX_V3_0,
    UC_CPU_PPC64_970FX_V3_1,
    UC_CPU_PPC64_970MP_V1_0,
    UC_CPU_PPC64_970MP_V1_1,
    UC_CPU_PPC64_POWER5_V2_1,
    UC_CPU_PPC64_POWER7_V2_3,
    UC_CPU_PPC64_POWER7_V2_1,
    UC_CPU_PPC64_POWER8E_V2_1,
    UC_CPU_PPC64_POWER8_V2_0,
    UC_CPU_PPC64_POWER8NVL_V1_0,
    UC_CPU_PPC64_POWER9_V1_0,
    UC_CPU_PPC64_POWER9_V2_0,
    UC_CPU_PPC64_POWER10_V1_0,

    UC_CPU_PPC64_ENDING
} uc_cpu_ppc64;

//> PPC registers
typedef enum uc_ppc_reg {
    UC_PPC_REG_INVALID = 0,
    //> General purpose registers
    UC_PPC_REG_PC,

    UC_PPC_REG_0,
    UC_PPC_REG_1,
    UC_PPC_REG_2,
    UC_PPC_REG_3,
    UC_PPC_REG_4,
    UC_PPC_REG_5,
    UC_PPC_REG_6,
    UC_PPC_REG_7,
    UC_PPC_REG_8,
    UC_PPC_REG_9,
    UC_PPC_REG_10,
    UC_PPC_REG_11,
    UC_PPC_REG_12,
    UC_PPC_REG_13,
    UC_PPC_REG_14,
    UC_PPC_REG_15,
    UC_PPC_REG_16,
    UC_PPC_REG_17,
    UC_PPC_REG_18,
    UC_PPC_REG_19,
    UC_PPC_REG_20,
    UC_PPC_REG_21,
    UC_PPC_REG_22,
    UC_PPC_REG_23,
    UC_PPC_REG_24,
    UC_PPC_REG_25,
    UC_PPC_REG_26,
    UC_PPC_REG_27,
    UC_PPC_REG_28,
    UC_PPC_REG_29,
    UC_PPC_REG_30,
    UC_PPC_REG_31,

    UC_PPC_REG_CR0,
    UC_PPC_REG_CR1,
    UC_PPC_REG_CR2,
    UC_PPC_REG_CR3,
    UC_PPC_REG_CR4,
    UC_PPC_REG_CR5,
    UC_PPC_REG_CR6,
    UC_PPC_REG_CR7,

    UC_PPC_REG_FPR0,
    UC_PPC_REG_FPR1,
    UC_PPC_REG_FPR2,
    UC_PPC_REG_FPR3,
    UC_PPC_REG_FPR4,
    UC_PPC_REG_FPR5,
    UC_PPC_REG_FPR6,
    UC_PPC_REG_FPR7,
    UC_PPC_REG_FPR8,
    UC_PPC_REG_FPR9,
    UC_PPC_REG_FPR10,
    UC_PPC_REG_FPR11,
    UC_PPC_REG_FPR12,
    UC_PPC_REG_FPR13,
    UC_PPC_REG_FPR14,
    UC_PPC_REG_FPR15,
    UC_PPC_REG_FPR16,
    UC_PPC_REG_FPR17,
    UC_PPC_REG_FPR18,
    UC_PPC_REG_FPR19,
    UC_PPC_REG_FPR20,
    UC_PPC_REG_FPR21,
    UC_PPC_REG_FPR22,
    UC_PPC_REG_FPR23,
    UC_PPC_REG_FPR24,
    UC_PPC_REG_FPR25,
    UC_PPC_REG_FPR26,
    UC_PPC_REG_FPR27,
    UC_PPC_REG_FPR28,
    UC_PPC_REG_FPR29,
    UC_PPC_REG_FPR30,
    UC_PPC_REG_FPR31,

    UC_PPC_REG_LR,
    UC_PPC_REG_XER,
    UC_PPC_REG_CTR,
    UC_PPC_REG_MSR,
    UC_PPC_REG_FPSCR,
    UC_PPC_REG_CR,

    UC_PPC_REG_ENDING, // <-- mark the end of the list or registers
} uc_ppc_reg;

#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/unicorn/unicorn/riscv.h`:

```h
/* Unicorn Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2015-2020 */
/* This file is released under LGPL2.
   See COPYING.LGPL2 in root directory for more details
 */

#ifndef UNICORN_RISCV_H
#define UNICORN_RISCV_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _MSC_VER
#pragma warning(disable : 4201)
#endif

//> RISCV32 CPU
typedef enum uc_cpu_riscv32 {
    UC_CPU_RISCV32_ANY = 0,
    UC_CPU_RISCV32_BASE32,
    UC_CPU_RISCV32_SIFIVE_E31,
    UC_CPU_RISCV32_SIFIVE_U34,

    UC_CPU_RISCV32_ENDING
} uc_cpu_riscv32;

//> RISCV64 CPU
typedef enum uc_cpu_riscv64 {
    UC_CPU_RISCV64_ANY = 0,
    UC_CPU_RISCV64_BASE64,
    UC_CPU_RISCV64_SIFIVE_E51,
    UC_CPU_RISCV64_SIFIVE_U54,

    UC_CPU_RISCV64_ENDING
} uc_cpu_riscv64;

//> RISCV registers
typedef enum uc_riscv_reg {
    UC_RISCV_REG_INVALID = 0,
    //> General purpose registers
    UC_RISCV_REG_X0,
    UC_RISCV_REG_X1,
    UC_RISCV_REG_X2,
    UC_RISCV_REG_X3,
    UC_RISCV_REG_X4,
    UC_RISCV_REG_X5,
    UC_RISCV_REG_X6,
    UC_RISCV_REG_X7,
    UC_RISCV_REG_X8,
    UC_RISCV_REG_X9,
    UC_RISCV_REG_X10,
    UC_RISCV_REG_X11,
    UC_RISCV_REG_X12,
    UC_RISCV_REG_X13,
    UC_RISCV_REG_X14,
    UC_RISCV_REG_X15,
    UC_RISCV_REG_X16,
    UC_RISCV_REG_X17,
    UC_RISCV_REG_X18,
    UC_RISCV_REG_X19,
    UC_RISCV_REG_X20,
    UC_RISCV_REG_X21,
    UC_RISCV_REG_X22,
    UC_RISCV_REG_X23,
    UC_RISCV_REG_X24,
    UC_RISCV_REG_X25,
    UC_RISCV_REG_X26,
    UC_RISCV_REG_X27,
    UC_RISCV_REG_X28,
    UC_RISCV_REG_X29,
    UC_RISCV_REG_X30,
    UC_RISCV_REG_X31,

    //> RISCV CSR
    UC_RISCV_REG_USTATUS,
    UC_RISCV_REG_UIE,
    UC_RISCV_REG_UTVEC,
    UC_RISCV_REG_USCRATCH,
    UC_RISCV_REG_UEPC,
    UC_RISCV_REG_UCAUSE,
    UC_RISCV_REG_UTVAL,
    UC_RISCV_REG_UIP,
    UC_RISCV_REG_FFLAGS,
    UC_RISCV_REG_FRM,
    UC_RISCV_REG_FCSR,
    UC_RISCV_REG_CYCLE,
    UC_RISCV_REG_TIME,
    UC_RISCV_REG_INSTRET,
    UC_RISCV_REG_HPMCOUNTER3,
    UC_RISCV_REG_HPMCOUNTER4,
    UC_RISCV_REG_HPMCOUNTER5,
    UC_RISCV_REG_HPMCOUNTER6,
    UC_RISCV_REG_HPMCOUNTER7,
    UC_RISCV_REG_HPMCOUNTER8,
    UC_RISCV_REG_HPMCOUNTER9,
    UC_RISCV_REG_HPMCOUNTER10,
    UC_RISCV_REG_HPMCOUNTER11,
    UC_RISCV_REG_HPMCOUNTER12,
    UC_RISCV_REG_HPMCOUNTER13,
    UC_RISCV_REG_HPMCOUNTER14,
    UC_RISCV_REG_HPMCOUNTER15,
    UC_RISCV_REG_HPMCOUNTER16,
    UC_RISCV_REG_HPMCOUNTER17,
    UC_RISCV_REG_HPMCOUNTER18,
    UC_RISCV_REG_HPMCOUNTER19,
    UC_RISCV_REG_HPMCOUNTER20,
    UC_RISCV_REG_HPMCOUNTER21,
    UC_RISCV_REG_HPMCOUNTER22,
    UC_RISCV_REG_HPMCOUNTER23,
    UC_RISCV_REG_HPMCOUNTER24,
    UC_RISCV_REG_HPMCOUNTER25,
    UC_RISCV_REG_HPMCOUNTER26,
    UC_RISCV_REG_HPMCOUNTER27,
    UC_RISCV_REG_HPMCOUNTER28,
    UC_RISCV_REG_HPMCOUNTER29,
    UC_RISCV_REG_HPMCOUNTER30,
    UC_RISCV_REG_HPMCOUNTER31,
    UC_RISCV_REG_CYCLEH,
    UC_RISCV_REG_TIMEH,
    UC_RISCV_REG_INSTRETH,
    UC_RISCV_REG_HPMCOUNTER3H,
    UC_RISCV_REG_HPMCOUNTER4H,
    UC_RISCV_REG_HPMCOUNTER5H,
    UC_RISCV_REG_HPMCOUNTER6H,
    UC_RISCV_REG_HPMCOUNTER7H,
    UC_RISCV_REG_HPMCOUNTER8H,
    UC_RISCV_REG_HPMCOUNTER9H,
    UC_RISCV_REG_HPMCOUNTER10H,
    UC_RISCV_REG_HPMCOUNTER11H,
    UC_RISCV_REG_HPMCOUNTER12H,
    UC_RISCV_REG_HPMCOUNTER13H,
    UC_RISCV_REG_HPMCOUNTER14H,
    UC_RISCV_REG_HPMCOUNTER15H,
    UC_RISCV_REG_HPMCOUNTER16H,
    UC_RISCV_REG_HPMCOUNTER17H,
    UC_RISCV_REG_HPMCOUNTER18H,
    UC_RISCV_REG_HPMCOUNTER19H,
    UC_RISCV_REG_HPMCOUNTER20H,
    UC_RISCV_REG_HPMCOUNTER21H,
    UC_RISCV_REG_HPMCOUNTER22H,
    UC_RISCV_REG_HPMCOUNTER23H,
    UC_RISCV_REG_HPMCOUNTER24H,
    UC_RISCV_REG_HPMCOUNTER25H,
    UC_RISCV_REG_HPMCOUNTER26H,
    UC_RISCV_REG_HPMCOUNTER27H,
    UC_RISCV_REG_HPMCOUNTER28H,
    UC_RISCV_REG_HPMCOUNTER29H,
    UC_RISCV_REG_HPMCOUNTER30H,
    UC_RISCV_REG_HPMCOUNTER31H,
    UC_RISCV_REG_MCYCLE,
    UC_RISCV_REG_MINSTRET,
    UC_RISCV_REG_MCYCLEH,
    UC_RISCV_REG_MINSTRETH,
    UC_RISCV_REG_MVENDORID,
    UC_RISCV_REG_MARCHID,
    UC_RISCV_REG_MIMPID,
    UC_RISCV_REG_MHARTID,
    UC_RISCV_REG_MSTATUS,
    UC_RISCV_REG_MISA,
    UC_RISCV_REG_MEDELEG,
    UC_RISCV_REG_MIDELEG,
    UC_RISCV_REG_MIE,
    UC_RISCV_REG_MTVEC,
    UC_RISCV_REG_MCOUNTEREN,
    UC_RISCV_REG_MSTATUSH,
    UC_RISCV_REG_MUCOUNTEREN,
    UC_RISCV_REG_MSCOUNTEREN,
    UC_RISCV_REG_MHCOUNTEREN,
    UC_RISCV_REG_MSCRATCH,
    UC_RISCV_REG_MEPC,
    UC_RISCV_REG_MCAUSE,
    UC_RISCV_REG_MTVAL,
    UC_RISCV_REG_MIP,
    UC_RISCV_REG_MBADADDR,
    UC_RISCV_REG_SSTATUS,
    UC_RISCV_REG_SEDELEG,
    UC_RISCV_REG_SIDELEG,
    UC_RISCV_REG_SIE,
    UC_RISCV_REG_STVEC,
    UC_RISCV_REG_SCOUNTEREN,
    UC_RISCV_REG_SSCRATCH,
    UC_RISCV_REG_SEPC,
    UC_RISCV_REG_SCAUSE,
    UC_RISCV_REG_STVAL,
    UC_RISCV_REG_SIP,
    UC_RISCV_REG_SBADADDR,
    UC_RISCV_REG_SPTBR,
    UC_RISCV_REG_SATP,
    UC_RISCV_REG_HSTATUS,
    UC_RISCV_REG_HEDELEG,
    UC_RISCV_REG_HIDELEG,
    UC_RISCV_REG_HIE,
    UC_RISCV_REG_HCOUNTEREN,
    UC_RISCV_REG_HTVAL,
    UC_RISCV_REG_HIP,
    UC_RISCV_REG_HTINST,
    UC_RISCV_REG_HGATP,
    UC_RISCV_REG_HTIMEDELTA,
    UC_RISCV_REG_HTIMEDELTAH,

    //> Floating-point registers
    UC_RISCV_REG_F0,  // "ft0"
    UC_RISCV_REG_F1,  // "ft1"
    UC_RISCV_REG_F2,  // "ft2"
    UC_RISCV_REG_F3,  // "ft3"
    UC_RISCV_REG_F4,  // "ft4"
    UC_RISCV_REG_F5,  // "ft5"
    UC_RISCV_REG_F6,  // "ft6"
    UC_RISCV_REG_F7,  // "ft7"
    UC_RISCV_REG_F8,  // "fs0"
    UC_RISCV_REG_F9,  // "fs1"
    UC_RISCV_REG_F10, // "fa0"
    UC_RISCV_REG_F11, // "fa1"
    UC_RISCV_REG_F12, // "fa2"
    UC_RISCV_REG_F13, // "fa3"
    UC_RISCV_REG_F14, // "fa4"
    UC_RISCV_REG_F15, // "fa5"
    UC_RISCV_REG_F16, // "fa6"
    UC_RISCV_REG_F17, // "fa7"
    UC_RISCV_REG_F18, // "fs2"
    UC_RISCV_REG_F19, // "fs3"
    UC_RISCV_REG_F20, // "fs4"
    UC_RISCV_REG_F21, // "fs5"
    UC_RISCV_REG_F22, // "fs6"
    UC_RISCV_REG_F23, // "fs7"
    UC_RISCV_REG_F24, // "fs8"
    UC_RISCV_REG_F25, // "fs9"
    UC_RISCV_REG_F26, // "fs10"
    UC_RISCV_REG_F27, // "fs11"
    UC_RISCV_REG_F28, // "ft8"
    UC_RISCV_REG_F29, // "ft9"
    UC_RISCV_REG_F30, // "ft10"
    UC_RISCV_REG_F31, // "ft11"

    UC_RISCV_REG_PC, // PC register

    UC_RISCV_REG_ENDING, // <-- mark the end of the list or registers

    //> Alias registers
    UC_RISCV_REG_ZERO = UC_RISCV_REG_X0, // "zero"
    UC_RISCV_REG_RA = UC_RISCV_REG_X1,   // "ra"
    UC_RISCV_REG_SP = UC_RISCV_REG_X2,   // "sp"
    UC_RISCV_REG_GP = UC_RISCV_REG_X3,   // "gp"
    UC_RISCV_REG_TP = UC_RISCV_REG_X4,   // "tp"
    UC_RISCV_REG_T0 = UC_RISCV_REG_X5,   // "t0"
    UC_RISCV_REG_T1 = UC_RISCV_REG_X6,   // "t1"
    UC_RISCV_REG_T2 = UC_RISCV_REG_X7,   // "t2"
    UC_RISCV_REG_S0 = UC_RISCV_REG_X8,   // "s0"
    UC_RISCV_REG_FP = UC_RISCV_REG_X8,   // "fp"
    UC_RISCV_REG_S1 = UC_RISCV_REG_X9,   // "s1"
    UC_RISCV_REG_A0 = UC_RISCV_REG_X10,  // "a0"
    UC_RISCV_REG_A1 = UC_RISCV_REG_X11,  // "a1"
    UC_RISCV_REG_A2 = UC_RISCV_REG_X12,  // "a2"
    UC_RISCV_REG_A3 = UC_RISCV_REG_X13,  // "a3"
    UC_RISCV_REG_A4 = UC_RISCV_REG_X14,  // "a4"
    UC_RISCV_REG_A5 = UC_RISCV_REG_X15,  // "a5"
    UC_RISCV_REG_A6 = UC_RISCV_REG_X16,  // "a6"
    UC_RISCV_REG_A7 = UC_RISCV_REG_X17,  // "a7"
    UC_RISCV_REG_S2 = UC_RISCV_REG_X18,  // "s2"
    UC_RISCV_REG_S3 = UC_RISCV_REG_X19,  // "s3"
    UC_RISCV_REG_S4 = UC_RISCV_REG_X20,  // "s4"
    UC_RISCV_REG_S5 = UC_RISCV_REG_X21,  // "s5"
    UC_RISCV_REG_S6 = UC_RISCV_REG_X22,  // "s6"
    UC_RISCV_REG_S7 = UC_RISCV_REG_X23,  // "s7"
    UC_RISCV_REG_S8 = UC_RISCV_REG_X24,  // "s8"
    UC_RISCV_REG_S9 = UC_RISCV_REG_X25,  // "s9"
    UC_RISCV_REG_S10 = UC_RISCV_REG_X26, // "s10"
    UC_RISCV_REG_S11 = UC_RISCV_REG_X27, // "s11"
    UC_RISCV_REG_T3 = UC_RISCV_REG_X28,  // "t3"
    UC_RISCV_REG_T4 = UC_RISCV_REG_X29,  // "t4"
    UC_RISCV_REG_T5 = UC_RISCV_REG_X30,  // "t5"
    UC_RISCV_REG_T6 = UC_RISCV_REG_X31,  // "t6"

    UC_RISCV_REG_FT0 = UC_RISCV_REG_F0, // "ft0"
    UC_RISCV_REG_FT1 = UC_RISCV_REG_F1, // "ft1"
    UC_RISCV_REG_FT2 = UC_RISCV_REG_F2, // "ft2"
    UC_RISCV_REG_FT3 = UC_RISCV_REG_F3, // "ft3"
    UC_RISCV_REG_FT4 = UC_RISCV_REG_F4, // "ft4"
    UC_RISCV_REG_FT5 = UC_RISCV_REG_F5, // "ft5"
    UC_RISCV_REG_FT6 = UC_RISCV_REG_F6, // "ft6"
    UC_RISCV_REG_FT7 = UC_RISCV_REG_F7, // "ft7"
    UC_RISCV_REG_FS0 = UC_RISCV_REG_F8, // "fs0"
    UC_RISCV_REG_FS1 = UC_RISCV_REG_F9, // "fs1"

    UC_RISCV_REG_FA0 = UC_RISCV_REG_F10,  // "fa0"
    UC_RISCV_REG_FA1 = UC_RISCV_REG_F11,  // "fa1"
    UC_RISCV_REG_FA2 = UC_RISCV_REG_F12,  // "fa2"
    UC_RISCV_REG_FA3 = UC_RISCV_REG_F13,  // "fa3"
    UC_RISCV_REG_FA4 = UC_RISCV_REG_F14,  // "fa4"
    UC_RISCV_REG_FA5 = UC_RISCV_REG_F15,  // "fa5"
    UC_RISCV_REG_FA6 = UC_RISCV_REG_F16,  // "fa6"
    UC_RISCV_REG_FA7 = UC_RISCV_REG_F17,  // "fa7"
    UC_RISCV_REG_FS2 = UC_RISCV_REG_F18,  // "fs2"
    UC_RISCV_REG_FS3 = UC_RISCV_REG_F19,  // "fs3"
    UC_RISCV_REG_FS4 = UC_RISCV_REG_F20,  // "fs4"
    UC_RISCV_REG_FS5 = UC_RISCV_REG_F21,  // "fs5"
    UC_RISCV_REG_FS6 = UC_RISCV_REG_F22,  // "fs6"
    UC_RISCV_REG_FS7 = UC_RISCV_REG_F23,  // "fs7"
    UC_RISCV_REG_FS8 = UC_RISCV_REG_F24,  // "fs8"
    UC_RISCV_REG_FS9 = UC_RISCV_REG_F25,  // "fs9"
    UC_RISCV_REG_FS10 = UC_RISCV_REG_F26, // "fs10"
    UC_RISCV_REG_FS11 = UC_RISCV_REG_F27, // "fs11"
    UC_RISCV_REG_FT8 = UC_RISCV_REG_F28,  // "ft8"
    UC_RISCV_REG_FT9 = UC_RISCV_REG_F29,  // "ft9"
    UC_RISCV_REG_FT10 = UC_RISCV_REG_F30, // "ft10"
    UC_RISCV_REG_FT11 = UC_RISCV_REG_F31, // "ft11"
} uc_riscv_reg;

#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/unicorn/unicorn/s390x.h`:

```h
/* Unicorn Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2015-2021 */

#ifndef UNICORN_S390X_H
#define UNICORN_S390X_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _MSC_VER
#pragma warning(disable : 4201)
#endif

//> S390X CPU
typedef enum uc_cpu_s390x {
    UC_CPU_S390X_Z900 = 0,
    UC_CPU_S390X_Z900_2,
    UC_CPU_S390X_Z900_3,
    UC_CPU_S390X_Z800,
    UC_CPU_S390X_Z990,
    UC_CPU_S390X_Z990_2,
    UC_CPU_S390X_Z990_3,
    UC_CPU_S390X_Z890,
    UC_CPU_S390X_Z990_4,
    UC_CPU_S390X_Z890_2,
    UC_CPU_S390X_Z990_5,
    UC_CPU_S390X_Z890_3,
    UC_CPU_S390X_Z9EC,
    UC_CPU_S390X_Z9EC_2,
    UC_CPU_S390X_Z9BC,
    UC_CPU_S390X_Z9EC_3,
    UC_CPU_S390X_Z9BC_2,
    UC_CPU_S390X_Z10EC,
    UC_CPU_S390X_Z10EC_2,
    UC_CPU_S390X_Z10BC,
    UC_CPU_S390X_Z10EC_3,
    UC_CPU_S390X_Z10BC_2,
    UC_CPU_S390X_Z196,
    UC_CPU_S390X_Z196_2,
    UC_CPU_S390X_Z114,
    UC_CPU_S390X_ZEC12,
    UC_CPU_S390X_ZEC12_2,
    UC_CPU_S390X_ZBC12,
    UC_CPU_S390X_Z13,
    UC_CPU_S390X_Z13_2,
    UC_CPU_S390X_Z13S,
    UC_CPU_S390X_Z14,
    UC_CPU_S390X_Z14_2,
    UC_CPU_S390X_Z14ZR1,
    UC_CPU_S390X_GEN15A,
    UC_CPU_S390X_GEN15B,
    UC_CPU_S390X_QEMU,
    UC_CPU_S390X_MAX,

    UC_CPU_S390X_ENDING
} uc_cpu_s390x;

//> S390X registers
typedef enum uc_s390x_reg {
    UC_S390X_REG_INVALID = 0,
    //> General purpose registers
    UC_S390X_REG_R0,
    UC_S390X_REG_R1,
    UC_S390X_REG_R2,
    UC_S390X_REG_R3,
    UC_S390X_REG_R4,
    UC_S390X_REG_R5,
    UC_S390X_REG_R6,
    UC_S390X_REG_R7,
    UC_S390X_REG_R8,
    UC_S390X_REG_R9,
    UC_S390X_REG_R10,
    UC_S390X_REG_R11,
    UC_S390X_REG_R12,
    UC_S390X_REG_R13,
    UC_S390X_REG_R14,
    UC_S390X_REG_R15,

    //> Floating point registers
    UC_S390X_REG_F0,
    UC_S390X_REG_F1,
    UC_S390X_REG_F2,
    UC_S390X_REG_F3,
    UC_S390X_REG_F4,
    UC_S390X_REG_F5,
    UC_S390X_REG_F6,
    UC_S390X_REG_F7,
    UC_S390X_REG_F8,
    UC_S390X_REG_F9,
    UC_S390X_REG_F10,
    UC_S390X_REG_F11,
    UC_S390X_REG_F12,
    UC_S390X_REG_F13,
    UC_S390X_REG_F14,
    UC_S390X_REG_F15,
    UC_S390X_REG_F16,
    UC_S390X_REG_F17,
    UC_S390X_REG_F18,
    UC_S390X_REG_F19,
    UC_S390X_REG_F20,
    UC_S390X_REG_F21,
    UC_S390X_REG_F22,
    UC_S390X_REG_F23,
    UC_S390X_REG_F24,
    UC_S390X_REG_F25,
    UC_S390X_REG_F26,
    UC_S390X_REG_F27,
    UC_S390X_REG_F28,
    UC_S390X_REG_F29,
    UC_S390X_REG_F30,
    UC_S390X_REG_F31,

    //> Access registers
    UC_S390X_REG_A0,
    UC_S390X_REG_A1,
    UC_S390X_REG_A2,
    UC_S390X_REG_A3,
    UC_S390X_REG_A4,
    UC_S390X_REG_A5,
    UC_S390X_REG_A6,
    UC_S390X_REG_A7,
    UC_S390X_REG_A8,
    UC_S390X_REG_A9,
    UC_S390X_REG_A10,
    UC_S390X_REG_A11,
    UC_S390X_REG_A12,
    UC_S390X_REG_A13,
    UC_S390X_REG_A14,
    UC_S390X_REG_A15,

    UC_S390X_REG_PC, // PC register
    UC_S390X_REG_PSWM,

    UC_S390X_REG_ENDING, // <-- mark the end of the list or registers

    //> Alias registers
} uc_s390x_reg;

#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/unicorn/unicorn/sparc.h`:

```h
/* Unicorn Emulator Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2014-2017 */
/* This file is released under LGPL2.
   See COPYING.LGPL2 in root directory for more details
*/

#ifndef UNICORN_SPARC_H
#define UNICORN_SPARC_H

#ifdef __cplusplus
extern "C" {
#endif

// GCC SPARC toolchain has a default macro called "sparc" which breaks
// compilation
#undef sparc

#ifdef _MSC_VER
#pragma warning(disable : 4201)
#endif

//> SPARC32 CPU
typedef enum uc_cpu_sparc32 {
    UC_CPU_SPARC32_FUJITSU_MB86904 = 0,
    UC_CPU_SPARC32_FUJITSU_MB86907,
    UC_CPU_SPARC32_TI_MICROSPARC_I,
    UC_CPU_SPARC32_TI_MICROSPARC_II,
    UC_CPU_SPARC32_TI_MICROSPARC_IIEP,
    UC_CPU_SPARC32_TI_SUPERSPARC_40,
    UC_CPU_SPARC32_TI_SUPERSPARC_50,
    UC_CPU_SPARC32_TI_SUPERSPARC_51,
    UC_CPU_SPARC32_TI_SUPERSPARC_60,
    UC_CPU_SPARC32_TI_SUPERSPARC_61,
    UC_CPU_SPARC32_TI_SUPERSPARC_II,
    UC_CPU_SPARC32_LEON2,
    UC_CPU_SPARC32_LEON3,

    UC_CPU_SPARC32_ENDING
} uc_cpu_sparc32;

//> SPARC64 CPU
typedef enum uc_cpu_sparc64 {
    UC_CPU_SPARC64_FUJITSU = 0,
    UC_CPU_SPARC64_FUJITSU_III,
    UC_CPU_SPARC64_FUJITSU_IV,
    UC_CPU_SPARC64_FUJITSU_V,
    UC_CPU_SPARC64_TI_ULTRASPARC_I,
    UC_CPU_SPARC64_TI_ULTRASPARC_II,
    UC_CPU_SPARC64_TI_ULTRASPARC_III,
    UC_CPU_SPARC64_TI_ULTRASPARC_IIE,
    UC_CPU_SPARC64_SUN_ULTRASPARC_III,
    UC_CPU_SPARC64_SUN_ULTRASPARC_III_CU,
    UC_CPU_SPARC64_SUN_ULTRASPARC_IIII,
    UC_CPU_SPARC64_SUN_ULTRASPARC_IV,
    UC_CPU_SPARC64_SUN_ULTRASPARC_IV_PLUS,
    UC_CPU_SPARC64_SUN_ULTRASPARC_IIII_PLUS,
    UC_CPU_SPARC64_SUN_ULTRASPARC_T1,
    UC_CPU_SPARC64_SUN_ULTRASPARC_T2,
    UC_CPU_SPARC64_NEC_ULTRASPARC_I,

    UC_CPU_SPARC64_ENDING
} uc_cpu_sparc64;

//> SPARC registers
typedef enum uc_sparc_reg {
    UC_SPARC_REG_INVALID = 0,

    UC_SPARC_REG_F0,
    UC_SPARC_REG_F1,
    UC_SPARC_REG_F2,
    UC_SPARC_REG_F3,
    UC_SPARC_REG_F4,
    UC_SPARC_REG_F5,
    UC_SPARC_REG_F6,
    UC_SPARC_REG_F7,
    UC_SPARC_REG_F8,
    UC_SPARC_REG_F9,
    UC_SPARC_REG_F10,
    UC_SPARC_REG_F11,
    UC_SPARC_REG_F12,
    UC_SPARC_REG_F13,
    UC_SPARC_REG_F14,
    UC_SPARC_REG_F15,
    UC_SPARC_REG_F16,
    UC_SPARC_REG_F17,
    UC_SPARC_REG_F18,
    UC_SPARC_REG_F19,
    UC_SPARC_REG_F20,
    UC_SPARC_REG_F21,
    UC_SPARC_REG_F22,
    UC_SPARC_REG_F23,
    UC_SPARC_REG_F24,
    UC_SPARC_REG_F25,
    UC_SPARC_REG_F26,
    UC_SPARC_REG_F27,
    UC_SPARC_REG_F28,
    UC_SPARC_REG_F29,
    UC_SPARC_REG_F30,
    UC_SPARC_REG_F31,
    UC_SPARC_REG_F32,
    UC_SPARC_REG_F34,
    UC_SPARC_REG_F36,
    UC_SPARC_REG_F38,
    UC_SPARC_REG_F40,
    UC_SPARC_REG_F42,
    UC_SPARC_REG_F44,
    UC_SPARC_REG_F46,
    UC_SPARC_REG_F48,
    UC_SPARC_REG_F50,
    UC_SPARC_REG_F52,
    UC_SPARC_REG_F54,
    UC_SPARC_REG_F56,
    UC_SPARC_REG_F58,
    UC_SPARC_REG_F60,
    UC_SPARC_REG_F62,
    UC_SPARC_REG_FCC0, // Floating condition codes
    UC_SPARC_REG_FCC1,
    UC_SPARC_REG_FCC2,
    UC_SPARC_REG_FCC3,
    UC_SPARC_REG_G0,
    UC_SPARC_REG_G1,
    UC_SPARC_REG_G2,
    UC_SPARC_REG_G3,
    UC_SPARC_REG_G4,
    UC_SPARC_REG_G5,
    UC_SPARC_REG_G6,
    UC_SPARC_REG_G7,
    UC_SPARC_REG_I0,
    UC_SPARC_REG_I1,
    UC_SPARC_REG_I2,
    UC_SPARC_REG_I3,
    UC_SPARC_REG_I4,
    UC_SPARC_REG_I5,
    UC_SPARC_REG_FP,
    UC_SPARC_REG_I7,
    UC_SPARC_REG_ICC, // Integer condition codes
    UC_SPARC_REG_L0,
    UC_SPARC_REG_L1,
    UC_SPARC_REG_L2,
    UC_SPARC_REG_L3,
    UC_SPARC_REG_L4,
    UC_SPARC_REG_L5,
    UC_SPARC_REG_L6,
    UC_SPARC_REG_L7,
    UC_SPARC_REG_O0,
    UC_SPARC_REG_O1,
    UC_SPARC_REG_O2,
    UC_SPARC_REG_O3,
    UC_SPARC_REG_O4,
    UC_SPARC_REG_O5,
    UC_SPARC_REG_SP,
    UC_SPARC_REG_O7,
    UC_SPARC_REG_Y,

    // special register
    UC_SPARC_REG_XCC,

    // pseudo register
    UC_SPARC_REG_PC, // program counter register

    UC_SPARC_REG_ENDING, // <-- mark the end of the list of registers

    // extras
    UC_SPARC_REG_O6 = UC_SPARC_REG_SP,
    UC_SPARC_REG_I6 = UC_SPARC_REG_FP,
} uc_sparc_reg;

#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/unicorn/unicorn/tricore.h`:

```h
/* This file is released under LGPL2.
   See COPYING.LGPL2 in root directory for more details
*/

/*
   Created for Unicorn Engine by Eric Poole <eric.poole@aptiv.com>, 2022
   Copyright 2022 Aptiv
*/

#ifndef UNICORN_TRICORE_H
#define UNICORN_TRICORE_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _MSC_VER
#pragma warning(disable : 4201)
#endif

//> TRICORE CPU
typedef enum uc_cpu_tricore {
    UC_CPU_TRICORE_TC1796,
    UC_CPU_TRICORE_TC1797,
    UC_CPU_TRICORE_TC27X,

    UC_CPU_TRICORE_ENDING
} uc_cpu_tricore;

//> TRICORE registers
typedef enum uc_tricore_reg {
    UC_TRICORE_REG_INVALID = 0,

    // General purpose registers (GPR)
    // Address GPR
    UC_TRICORE_REG_A0,
    UC_TRICORE_REG_A1,
    UC_TRICORE_REG_A2,
    UC_TRICORE_REG_A3,
    UC_TRICORE_REG_A4,
    UC_TRICORE_REG_A5,
    UC_TRICORE_REG_A6,
    UC_TRICORE_REG_A7,
    UC_TRICORE_REG_A8,
    UC_TRICORE_REG_A9,
    UC_TRICORE_REG_A10,
    UC_TRICORE_REG_A11,
    UC_TRICORE_REG_A12,
    UC_TRICORE_REG_A13,
    UC_TRICORE_REG_A14,
    UC_TRICORE_REG_A15,
    // Data GPR
    UC_TRICORE_REG_D0,
    UC_TRICORE_REG_D1,
    UC_TRICORE_REG_D2,
    UC_TRICORE_REG_D3,
    UC_TRICORE_REG_D4,
    UC_TRICORE_REG_D5,
    UC_TRICORE_REG_D6,
    UC_TRICORE_REG_D7,
    UC_TRICORE_REG_D8,
    UC_TRICORE_REG_D9,
    UC_TRICORE_REG_D10,
    UC_TRICORE_REG_D11,
    UC_TRICORE_REG_D12,
    UC_TRICORE_REG_D13,
    UC_TRICORE_REG_D14,
    UC_TRICORE_REG_D15,

    /* CSFR Register */
    UC_TRICORE_REG_PCXI,

    UC_TRICORE_REG_PSW,

    /* PSW flag cache for faster execution */
    UC_TRICORE_REG_PSW_USB_C,
    UC_TRICORE_REG_PSW_USB_V,
    UC_TRICORE_REG_PSW_USB_SV,
    UC_TRICORE_REG_PSW_USB_AV,
    UC_TRICORE_REG_PSW_USB_SAV,

    UC_TRICORE_REG_PC,
    UC_TRICORE_REG_SYSCON,
    UC_TRICORE_REG_CPU_ID,
    UC_TRICORE_REG_BIV,
    UC_TRICORE_REG_BTV,
    UC_TRICORE_REG_ISP,
    UC_TRICORE_REG_ICR,
    UC_TRICORE_REG_FCX,
    UC_TRICORE_REG_LCX,
    UC_TRICORE_REG_COMPAT,

    UC_TRICORE_REG_DPR0_U,
    UC_TRICORE_REG_DPR1_U,
    UC_TRICORE_REG_DPR2_U,
    UC_TRICORE_REG_DPR3_U,
    UC_TRICORE_REG_DPR0_L,
    UC_TRICORE_REG_DPR1_L,
    UC_TRICORE_REG_DPR2_L,
    UC_TRICORE_REG_DPR3_L,

    UC_TRICORE_REG_CPR0_U,
    UC_TRICORE_REG_CPR1_U,
    UC_TRICORE_REG_CPR2_U,
    UC_TRICORE_REG_CPR3_U,
    UC_TRICORE_REG_CPR0_L,
    UC_TRICORE_REG_CPR1_L,
    UC_TRICORE_REG_CPR2_L,
    UC_TRICORE_REG_CPR3_L,

    UC_TRICORE_REG_DPM0,
    UC_TRICORE_REG_DPM1,
    UC_TRICORE_REG_DPM2,
    UC_TRICORE_REG_DPM3,

    UC_TRICORE_REG_CPM0,
    UC_TRICORE_REG_CPM1,
    UC_TRICORE_REG_CPM2,
    UC_TRICORE_REG_CPM3,

    /* Memory Management Registers */
    UC_TRICORE_REG_MMU_CON,
    UC_TRICORE_REG_MMU_ASI,
    UC_TRICORE_REG_MMU_TVA,
    UC_TRICORE_REG_MMU_TPA,
    UC_TRICORE_REG_MMU_TPX,
    UC_TRICORE_REG_MMU_TFA,

    // 1.3.1 Only
    UC_TRICORE_REG_BMACON,
    UC_TRICORE_REG_SMACON,
    UC_TRICORE_REG_DIEAR,
    UC_TRICORE_REG_DIETR,
    UC_TRICORE_REG_CCDIER,
    UC_TRICORE_REG_MIECON,
    UC_TRICORE_REG_PIEAR,
    UC_TRICORE_REG_PIETR,
    UC_TRICORE_REG_CCPIER,

    /* Debug Registers */
    UC_TRICORE_REG_DBGSR,
    UC_TRICORE_REG_EXEVT,
    UC_TRICORE_REG_CREVT,
    UC_TRICORE_REG_SWEVT,
    UC_TRICORE_REG_TR0EVT,
    UC_TRICORE_REG_TR1EVT,
    UC_TRICORE_REG_DMS,
    UC_TRICORE_REG_DCX,
    UC_TRICORE_REG_DBGTCR,
    UC_TRICORE_REG_CCTRL,
    UC_TRICORE_REG_CCNT,
    UC_TRICORE_REG_ICNT,
    UC_TRICORE_REG_M1CNT,
    UC_TRICORE_REG_M2CNT,
    UC_TRICORE_REG_M3CNT,

    UC_TRICORE_REG_ENDING, // <-- mark the end of the list of registers

    // alias registers
    UC_TRICORE_REG_GA0 = UC_TRICORE_REG_A0,
    UC_TRICORE_REG_GA1 = UC_TRICORE_REG_A1,
    UC_TRICORE_REG_GA8 = UC_TRICORE_REG_A8,
    UC_TRICORE_REG_GA9 = UC_TRICORE_REG_A9,
    UC_TRICORE_REG_SP = UC_TRICORE_REG_A10,
    UC_TRICORE_REG_LR = UC_TRICORE_REG_A11,
    UC_TRICORE_REG_IA = UC_TRICORE_REG_A15,
    UC_TRICORE_REG_ID = UC_TRICORE_REG_D15,
} uc_tricore_reg;

#ifdef __cplusplus
}
#endif

#endif
```

`KDemu/unicorn/unicorn/unicorn.h`:

```h
/* Unicorn Emulator Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2015-2017 */
/* This file is released under LGPL2.
   See COPYING.LGPL2 in root directory for more details
*/

#ifndef UNICORN_ENGINE_H
#define UNICORN_ENGINE_H

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"
#include <stdarg.h>

#if defined(UNICORN_HAS_OSXKERNEL)
#include <libkern/libkern.h>
#else
#include <stdlib.h>
#include <stdio.h>
#endif

struct uc_struct;
typedef struct uc_struct uc_engine;

typedef size_t uc_hook;

#include "m68k.h"
#include "x86.h"
#include "arm.h"
#include "arm64.h"
#include "mips.h"
#include "sparc.h"
#include "ppc.h"
#include "riscv.h"
#include "s390x.h"
#include "tricore.h"

#ifdef __GNUC__
#define DEFAULT_VISIBILITY __attribute__((visibility("default")))
#else
#define DEFAULT_VISIBILITY
#endif

#ifdef _MSC_VER
#pragma warning(disable : 4201)
#pragma warning(disable : 4100)
#ifdef UNICORN_SHARED
#define UNICORN_EXPORT __declspec(dllexport)
#else // defined(UNICORN_STATIC)
#define UNICORN_EXPORT
#endif
#else
#ifdef __GNUC__
#define UNICORN_EXPORT __attribute__((visibility("default")))
#else
#define UNICORN_EXPORT
#endif
#endif

#ifdef __GNUC__
#define UNICORN_DEPRECATED __attribute__((deprecated))
#elif defined(_MSC_VER)
#define UNICORN_DEPRECATED __declspec(deprecated)
#else
#pragma message(                                                               \
    "WARNING: You need to implement UNICORN_DEPRECATED for this compiler")
#define UNICORN_DEPRECATED
#endif

// Unicorn API version
#define UC_API_MAJOR 2
#define UC_API_MINOR 0
#define UC_API_PATCH 1
// Release candidate version, 255 means the official release.
#define UC_API_EXTRA 255

// Unicorn package version
#define UC_VERSION_MAJOR UC_API_MAJOR
#define UC_VERSION_MINOR UC_API_MINOR
#define UC_VERSION_PATCH UC_API_PATCH
#define UC_VERSION_EXTRA UC_API_EXTRA

/*
  Macro to create combined version which can be compared to
  result of uc_version() API.
*/
#define UC_MAKE_VERSION(major, minor) ((major << 8) + minor)

// Scales to calculate timeout on microsecond unit
// 1 second = 1000,000 microseconds
#define UC_SECOND_SCALE 1000000
// 1 milisecond = 1000 nanoseconds
#define UC_MILISECOND_SCALE 1000

// Architecture type
typedef enum uc_arch {
    UC_ARCH_ARM = 1, // ARM architecture (including Thumb, Thumb-2)
    UC_ARCH_ARM64,   // ARM-64, also called AArch64
    UC_ARCH_MIPS,    // Mips architecture
    UC_ARCH_X86,     // X86 architecture (including x86 & x86-64)
    UC_ARCH_PPC,     // PowerPC architecture
    UC_ARCH_SPARC,   // Sparc architecture
    UC_ARCH_M68K,    // M68K architecture
    UC_ARCH_RISCV,   // RISCV architecture
    UC_ARCH_S390X,   // S390X architecture
    UC_ARCH_TRICORE, // TriCore architecture
    UC_ARCH_MAX,
} uc_arch;

// Mode type
typedef enum uc_mode {
    UC_MODE_LITTLE_ENDIAN = 0,    // little-endian mode (default mode)
    UC_MODE_BIG_ENDIAN = 1 << 30, // big-endian mode

    // arm / arm64
    UC_MODE_ARM = 0,        // ARM mode
    UC_MODE_THUMB = 1 << 4, // THUMB mode (including Thumb-2)
    // Depreciated, use UC_ARM_CPU_* with uc_ctl instead.
    UC_MODE_MCLASS = 1 << 5,  // ARM's Cortex-M series.
    UC_MODE_V8 = 1 << 6,      // ARMv8 A32 encodings for ARM
    UC_MODE_ARMBE8 = 1 << 10, // Big-endian data and Little-endian code.
                              // Legacy support for UC1 only.

    // arm (32bit) cpu types
    // Depreciated, use UC_ARM_CPU_* with uc_ctl instead.
    UC_MODE_ARM926 = 1 << 7,  // ARM926 CPU type
    UC_MODE_ARM946 = 1 << 8,  // ARM946 CPU type
    UC_MODE_ARM1176 = 1 << 9, // ARM1176 CPU type

    // mips
    UC_MODE_MICRO = 1 << 4,    // MicroMips mode (currently unsupported)
    UC_MODE_MIPS3 = 1 << 5,    // Mips III ISA (currently unsupported)
    UC_MODE_MIPS32R6 = 1 << 6, // Mips32r6 ISA (currently unsupported)
    UC_MODE_MIPS32 = 1 << 2,   // Mips32 ISA
    UC_MODE_MIPS64 = 1 << 3,   // Mips64 ISA

    // x86 / x64
    UC_MODE_16 = 1 << 1, // 16-bit mode
    UC_MODE_32 = 1 << 2, // 32-bit mode
    UC_MODE_64 = 1 << 3, // 64-bit mode

    // ppc
    UC_MODE_PPC32 = 1 << 2, // 32-bit mode
    UC_MODE_PPC64 = 1 << 3, // 64-bit mode (currently unsupported)
    UC_MODE_QPX =
        1 << 4, // Quad Processing eXtensions mode (currently unsupported)

    // sparc
    UC_MODE_SPARC32 = 1 << 2, // 32-bit mode
    UC_MODE_SPARC64 = 1 << 3, // 64-bit mode
    UC_MODE_V9 = 1 << 4,      // SparcV9 mode (currently unsupported)

    // riscv
    UC_MODE_RISCV32 = 1 << 2, // 32-bit mode
    UC_MODE_RISCV64 = 1 << 3, // 64-bit mode

    // m68k
} uc_mode;

// All type of errors encountered by Unicorn API.
// These are values returned by uc_errno()
typedef enum uc_err {
    UC_ERR_OK = 0,         // No error: everything was fine
    UC_ERR_NOMEM,          // Out-Of-Memory error: uc_open(), uc_emulate()
    UC_ERR_ARCH,           // Unsupported architecture: uc_open()
    UC_ERR_HANDLE,         // Invalid handle
    UC_ERR_MODE,           // Invalid/unsupported mode: uc_open()
    UC_ERR_VERSION,        // Unsupported version (bindings)
    UC_ERR_READ_UNMAPPED,  // Quit emulation due to READ on unmapped memory:
                           // uc_emu_start()
    UC_ERR_WRITE_UNMAPPED, // Quit emulation due to WRITE on unmapped memory:
                           // uc_emu_start()
    UC_ERR_FETCH_UNMAPPED, // Quit emulation due to FETCH on unmapped memory:
                           // uc_emu_start()
    UC_ERR_HOOK,           // Invalid hook type: uc_hook_add()
    UC_ERR_INSN_INVALID,   // Quit emulation due to invalid instruction:
                           // uc_emu_start()
    UC_ERR_MAP,            // Invalid memory mapping: uc_mem_map()
    UC_ERR_WRITE_PROT,     // Quit emulation due to UC_MEM_WRITE_PROT violation:
                           // uc_emu_start()
    UC_ERR_READ_PROT,      // Quit emulation due to UC_MEM_READ_PROT violation:
                           // uc_emu_start()
    UC_ERR_FETCH_PROT,     // Quit emulation due to UC_MEM_FETCH_PROT violation:
                           // uc_emu_start()
    UC_ERR_ARG, // Inavalid argument provided to uc_xxx function (See specific
                // function API)
    UC_ERR_READ_UNALIGNED,  // Unaligned read
    UC_ERR_WRITE_UNALIGNED, // Unaligned write
    UC_ERR_FETCH_UNALIGNED, // Unaligned fetch
    UC_ERR_HOOK_EXIST,      // hook for this event already existed
    UC_ERR_RESOURCE,        // Insufficient resource: uc_emu_start()
    UC_ERR_EXCEPTION,       // Unhandled CPU exception
} uc_err;

/*
  Callback function for tracing code (UC_HOOK_CODE & UC_HOOK_BLOCK)

  @address: address where the code is being executed
  @size: size of machine instruction(s) being executed, or 0 when size is
  unknown
  @user_data: user data passed to tracing APIs.
*/
typedef void (*uc_cb_hookcode_t)(uc_engine *uc, uint64_t address, uint32_t size,
                                 void *user_data);

/*
  Callback function for tracing interrupts (for uc_hook_intr())

  @intno: interrupt number
  @user_data: user data passed to tracing APIs.
*/
typedef void (*uc_cb_hookintr_t)(uc_engine *uc, uint32_t intno,
                                 void *user_data);

/*
  Callback function for tracing invalid instructions

  @user_data: user data passed to tracing APIs.

  @return: return true to continue, or false to stop program (due to invalid
  instruction).
*/
typedef bool (*uc_cb_hookinsn_invalid_t)(uc_engine *uc, void *user_data);

/*
  Callback function for tracing IN instruction of X86

  @port: port number
  @size: data size (1/2/4) to be read from this port
  @user_data: user data passed to tracing APIs.
*/
typedef uint32_t (*uc_cb_insn_in_t)(uc_engine *uc, uint32_t port, int size,
                                    void *user_data);

/*
  Callback function for OUT instruction of X86

  @port: port number
  @size: data size (1/2/4) to be written to this port
  @value: data value to be written to this port
*/
typedef void (*uc_cb_insn_out_t)(uc_engine *uc, uint32_t port, int size,
                                 uint32_t value, void *user_data);

// Represent a TranslationBlock.
typedef struct uc_tb {
    uint64_t pc;
    uint16_t icount;
    uint16_t size;
} uc_tb;

/*
  Callback function for new edges between translation blocks.

  @cur_tb: Current TB which is to be generated.
  @prev_tb: The previous TB.
*/
typedef void (*uc_hook_edge_gen_t)(uc_engine *uc, uc_tb *cur_tb, uc_tb *prev_tb,
                                   void *user_data);

/*
  Callback function for tcg opcodes that fits in two arguments.

  @address: Current pc.
  @arg1: The first argument.
  @arg2: The second argument.
*/
typedef void (*uc_hook_tcg_op_2)(uc_engine *uc, uint64_t address, uint64_t arg1,
                                 uint64_t arg2, uint32_t size, void *user_data);

typedef uc_hook_tcg_op_2 uc_hook_tcg_sub_t;

/*
  Callback function for MMIO read

  @offset: offset to the base address of the IO memory.
  @size: data size to read
  @user_data: user data passed to uc_mmio_map()
*/
typedef uint64_t (*uc_cb_mmio_read_t)(uc_engine *uc, uint64_t offset,
                                      unsigned size, void *user_data);

/*
  Callback function for MMIO write

  @offset: offset to the base address of the IO memory.
  @size: data size to write
  @value: data value to be written
  @user_data: user data passed to uc_mmio_map()
*/
typedef void (*uc_cb_mmio_write_t)(uc_engine *uc, uint64_t offset,
                                   unsigned size, uint64_t value,
                                   void *user_data);

// All type of memory accesses for UC_HOOK_MEM_*
typedef enum uc_mem_type {
    UC_MEM_READ = 16,      // Memory is read from
    UC_MEM_WRITE,          // Memory is written to
    UC_MEM_FETCH,          // Memory is fetched
    UC_MEM_READ_UNMAPPED,  // Unmapped memory is read from
    UC_MEM_WRITE_UNMAPPED, // Unmapped memory is written to
    UC_MEM_FETCH_UNMAPPED, // Unmapped memory is fetched
    UC_MEM_WRITE_PROT,     // Write to write protected, but mapped, memory
    UC_MEM_READ_PROT,      // Read from read protected, but mapped, memory
    UC_MEM_FETCH_PROT,     // Fetch from non-executable, but mapped, memory
    UC_MEM_READ_AFTER,     // Memory is read from (successful access)
} uc_mem_type;

// These are all op codes we support to hook for UC_HOOK_TCG_OP_CODE.
// Be cautious since it may bring much more overhead than UC_HOOK_CODE without
// proper flags.
// TODO: Tracing UC_TCG_OP_CALL should be interesting.
typedef enum uc_tcg_op_code {
    UC_TCG_OP_SUB = 0, // Both sub_i32 and sub_i64
} uc_tcg_op_code;

// These are extra flags to be paired with uc_tcg_op_code which is helpful to
// instrument in some certain cases.
typedef enum uc_tcg_op_flag {
    // Only instrument opcode if it would set cc_dst, i.e. cmp instruction.
    UC_TCG_OP_FLAG_CMP = 1 << 0,
    // Only instrument opcode which is directly translated.
    // i.e. x86 sub/subc -> tcg sub_i32/64
    UC_TCG_OP_FLAG_DIRECT = 1 << 1
} uc_tcg_op_flag;

// All type of hooks for uc_hook_add() API.
typedef enum uc_hook_type {
    // Hook all interrupt/syscall events
    UC_HOOK_INTR = 1 << 0,
    // Hook a particular instruction - only a very small subset of instructions
    // supported here
    UC_HOOK_INSN = 1 << 1,
    // Hook a range of code
    UC_HOOK_CODE = 1 << 2,
    // Hook basic blocks
    UC_HOOK_BLOCK = 1 << 3,
    // Hook for memory read on unmapped memory
    UC_HOOK_MEM_READ_UNMAPPED = 1 << 4,
    // Hook for invalid memory write events
    UC_HOOK_MEM_WRITE_UNMAPPED = 1 << 5,
    // Hook for invalid memory fetch for execution events
    UC_HOOK_MEM_FETCH_UNMAPPED = 1 << 6,
    // Hook for memory read on read-protected memory
    UC_HOOK_MEM_READ_PROT = 1 << 7,
    // Hook for memory write on write-protected memory
    UC_HOOK_MEM_WRITE_PROT = 1 << 8,
    // Hook for memory fetch on non-executable memory
    UC_HOOK_MEM_FETCH_PROT = 1 << 9,
    // Hook memory read events.
    UC_HOOK_MEM_READ = 1 << 10,
    // Hook memory write events.
    UC_HOOK_MEM_WRITE = 1 << 11,
    // Hook memory fetch for execution events
    UC_HOOK_MEM_FETCH = 1 << 12,
    // Hook memory read events, but only successful access.
    // The callback will be triggered after successful read.
    UC_HOOK_MEM_READ_AFTER = 1 << 13,
    // Hook invalid instructions exceptions.
    UC_HOOK_INSN_INVALID = 1 << 14,
    // Hook on new edge generation. Could be useful in program analysis.
    //
    // NOTE: This is different from UC_HOOK_BLOCK in 2 ways:
    //       1. The hook is called before executing code.
    //       2. The hook is only called when generation is triggered.
    UC_HOOK_EDGE_GENERATED = 1 << 15,
    // Hook on specific tcg op code. The usage of this hook is similar to
    // UC_HOOK_INSN.
    UC_HOOK_TCG_OPCODE = 1 << 16,
} uc_hook_type;

// Hook type for all events of unmapped memory access
#define UC_HOOK_MEM_UNMAPPED                                                   \
    (UC_HOOK_MEM_READ_UNMAPPED + UC_HOOK_MEM_WRITE_UNMAPPED +                  \
     UC_HOOK_MEM_FETCH_UNMAPPED)
// Hook type for all events of illegal protected memory access
#define UC_HOOK_MEM_PROT                                                       \
    (UC_HOOK_MEM_READ_PROT + UC_HOOK_MEM_WRITE_PROT + UC_HOOK_MEM_FETCH_PROT)
// Hook type for all events of illegal read memory access
#define UC_HOOK_MEM_READ_INVALID                                               \
    (UC_HOOK_MEM_READ_PROT + UC_HOOK_MEM_READ_UNMAPPED)
// Hook type for all events of illegal write memory access
#define UC_HOOK_MEM_WRITE_INVALID                                              \
    (UC_HOOK_MEM_WRITE_PROT + UC_HOOK_MEM_WRITE_UNMAPPED)
// Hook type for all events of illegal fetch memory access
#define UC_HOOK_MEM_FETCH_INVALID                                              \
    (UC_HOOK_MEM_FETCH_PROT + UC_HOOK_MEM_FETCH_UNMAPPED)
// Hook type for all events of illegal memory access
#define UC_HOOK_MEM_INVALID (UC_HOOK_MEM_UNMAPPED + UC_HOOK_MEM_PROT)
// Hook type for all events of valid memory access
// NOTE: UC_HOOK_MEM_READ is triggered before UC_HOOK_MEM_READ_PROT and
// UC_HOOK_MEM_READ_UNMAPPED, so
//       this hook may technically trigger on some invalid reads.
#define UC_HOOK_MEM_VALID                                                      \
    (UC_HOOK_MEM_READ + UC_HOOK_MEM_WRITE + UC_HOOK_MEM_FETCH)

/*
  Callback function for hooking memory (READ, WRITE & FETCH)

  @type: this memory is being READ, or WRITE
  @address: address where the code is being executed
  @size: size of data being read or written
  @value: value of data being written to memory, or irrelevant if type = READ.
  @user_data: user data passed to tracing APIs
*/
typedef void (*uc_cb_hookmem_t)(uc_engine *uc, uc_mem_type type,
                                uint64_t address, int size, int64_t value,
                                void *user_data);

/*
  Callback function for handling invalid memory access events (UNMAPPED and
    PROT events)

  @type: this memory is being READ, or WRITE
  @address: address where the code is being executed
  @size: size of data being read or written
  @value: value of data being written to memory, or irrelevant if type = READ.
  @user_data: user data passed to tracing APIs

  @return: return true to continue, or false to stop program (due to invalid
  memory). NOTE: returning true to continue execution will only work if the
  accessed memory is made accessible with the correct permissions during the
  hook.

           In the event of a UC_MEM_READ_UNMAPPED or UC_MEM_WRITE_UNMAPPED
  callback, the memory should be uc_mem_map()-ed with the correct permissions,
  and the instruction will then read or write to the address as it was supposed
  to.

           In the event of a UC_MEM_FETCH_UNMAPPED callback, the memory can be
  mapped in as executable, in which case execution will resume from the fetched
  address. The instruction pointer may be written to in order to change where
  execution resumes, but the fetch must succeed if execution is to resume.
*/
typedef bool (*uc_cb_eventmem_t)(uc_engine *uc, uc_mem_type type,
                                 uint64_t address, int size, int64_t value,
                                 void *user_data);

/*
  Memory region mapped by uc_mem_map() and uc_mem_map_ptr()
  Retrieve the list of memory regions with uc_mem_regions()
*/
typedef struct uc_mem_region {
    uint64_t begin; // begin address of the region (inclusive)
    uint64_t end;   // end address of the region (inclusive)
    uint32_t perms; // memory permissions of the region
} uc_mem_region;

// All type of queries for uc_query() API.
typedef enum uc_query_type {
    // Dynamically query current hardware mode.
    UC_QUERY_MODE = 1,
    UC_QUERY_PAGE_SIZE, // query pagesize of engine
    UC_QUERY_ARCH, // query architecture of engine (for ARM to query Thumb mode)
    UC_QUERY_TIMEOUT, // query if emulation stops due to timeout (indicated if
                      // result = True)
} uc_query_type;

// The implementation of uc_ctl is like what Linux ioctl does but slightly
// different.
//
// A uc_control_type passed to uc_ctl is constructed as:
//
//    R/W       NR       Reserved     Type
//  [      ] [      ]  [         ] [       ]
//  31    30 29     26 25       16 15      0
//
//  @R/W: Whether the operation is a read or write access.
//  @NR: Number of arguments.
//  @Reserved: Should be zero, reserved for future extension.
//  @Type: Taken from uc_control_type enum.
//
// See the helper macros below.

// No input and output arguments.
#define UC_CTL_IO_NONE (0)
// Only input arguments for a write operation.
#define UC_CTL_IO_WRITE (1)
// Only output arguments for a read operation.
#define UC_CTL_IO_READ (2)
// The arguments include both input and output arugments.
#define UC_CTL_IO_READ_WRITE (UC_CTL_IO_WRITE | UC_CTL_IO_READ)

#define UC_CTL(type, nr, rw)                                                   \
    (uc_control_type)((type) | ((nr) << 26) | ((rw) << 30))
#define UC_CTL_NONE(type, nr) UC_CTL(type, nr, UC_CTL_IO_NONE)
#define UC_CTL_READ(type, nr) UC_CTL(type, nr, UC_CTL_IO_READ)
#define UC_CTL_WRITE(type, nr) UC_CTL(type, nr, UC_CTL_IO_WRITE)
#define UC_CTL_READ_WRITE(type, nr) UC_CTL(type, nr, UC_CTL_IO_READ_WRITE)

// All type of controls for uc_ctl API.
// The controls are organized in a tree level.
// If a control don't have `Set` or `Get` for @args, it means it's r/o or w/o.
typedef enum uc_control_type {
    // Current mode.
    // Read: @args = (int*)
    UC_CTL_UC_MODE = 0,
    // Curent page size.
    // Write: @args = (uint32_t)
    // Read: @args = (uint32_t*)
    UC_CTL_UC_PAGE_SIZE,
    // Current arch.
    // Read: @args = (int*)
    UC_CTL_UC_ARCH,
    // Current timeout.
    // Read: @args = (uint64_t*)
    UC_CTL_UC_TIMEOUT,
    // Enable multiple exits.
    // Without this control, reading/setting exits won't work.
    // This is for API backward compatibility.
    // Write: @args = (int)
    UC_CTL_UC_USE_EXITS,
    // The number of current exits.
    // Read: @args = (size_t*)
    UC_CTL_UC_EXITS_CNT,
    // Current exits.
    // Write: @args = (uint64_t* exits, size_t len)
    //        @len = UC_CTL_UC_EXITS_CNT
    // Read: @args = (uint64_t* exits, size_t len)
    //       @len = UC_CTL_UC_EXITS_CNT
    UC_CTL_UC_EXITS,

    // Set the cpu model of uc.
    // Note this option can only be set before any Unicorn
    // API is called except for uc_open.
    // Write: @args = (int)
    // Read:  @args = (int*)
    UC_CTL_CPU_MODEL,
    // Request a tb cache at a specific address
    // Read: @args = (uint64_t, uc_tb*)
    UC_CTL_TB_REQUEST_CACHE,
    // Invalidate a tb cache at a specific address
    // Write: @args = (uint64_t, uint64_t)
    UC_CTL_TB_REMOVE_CACHE,
    // Invalidate all translation blocks.
    // No arguments.
    UC_CTL_TB_FLUSH

} uc_control_type;

/*

Exits Mechanism

In some cases, users may have multiple exits and the @until parameter of
uc_emu_start is not sufficient to control the emulation. The exits mechanism is
designed to solve this problem. Note that using hooks is aslo feasible, but the
exits could be slightly more efficient and easy to implement.

By default, the exits mechanism is disabled to keep backward compatibility. That
is to say, calling uc_ctl_set/get_exits would return an error. Thus, to enable
the exits firstly, call:

  uc_ctl_exits_enable(uc)

After this call, the @until parameter of uc_emu_start would have no effect on
the emulation, so:

  uc_emu_start(uc, 0x1000, 0 ...)
  uc_emu_start(uc, 0x1000, 0x1000 ...)
  uc_emu_start(uc, 0x1000, -1 ...)

The three calls are totally equavelent since the @until is ignored.

To setup the exits, users may call:

  uc_ctl_set/get_exits(uc, exits, len)

For example, with an exits array [0x1000, 0x2000], uc_emu_start would stop at
either 0x1000 and 0x2000. With an exits array [], uc_emu_start won't stop unless
some hooks request a stop.

If users would like to restore the default behavior of @until parameter, users
may call:

  uc_ctl_exits_disable(uc)

After that, all exits setup previously would be cleared and @until parameter
would take effect again.

See sample_ctl.c for a detailed example.

*/
#define uc_ctl_get_mode(uc, mode)                                              \
    uc_ctl(uc, UC_CTL_READ(UC_CTL_UC_MODE, 1), (mode))
#define uc_ctl_get_page_size(uc, ptr)                                          \
    uc_ctl(uc, UC_CTL_READ(UC_CTL_UC_PAGE_SIZE, 1), (ptr))
#define uc_ctl_set_page_size(uc, page_size)                                    \
    uc_ctl(uc, UC_CTL_WRITE(UC_CTL_UC_PAGE_SIZE, 1), (page_size))
#define uc_ctl_get_arch(uc, arch)                                              \
    uc_ctl(uc, UC_CTL_READ(UC_CTL_UC_ARCH, 1), (arch))
#define uc_ctl_get_timeout(uc, ptr)                                            \
    uc_ctl(uc, UC_CTL_READ(UC_CTL_UC_TIMEOUT, 1), (ptr))
#define uc_ctl_exits_enable(uc)                                                \
    uc_ctl(uc, UC_CTL_WRITE(UC_CTL_UC_USE_EXITS, 1), 1)
#define uc_ctl_exits_disable(uc)                                               \
    uc_ctl(uc, UC_CTL_WRITE(UC_CTL_UC_USE_EXITS, 1), 0)
#define uc_ctl_get_exits_cnt(uc, ptr)                                          \
    uc_ctl(uc, UC_CTL_READ(UC_CTL_UC_EXITS_CNT, 1), (ptr))
#define uc_ctl_get_exits(uc, buffer, len)                                      \
    uc_ctl(uc, UC_CTL_READ(UC_CTL_UC_EXITS, 2), (buffer), (len))
#define uc_ctl_set_exits(uc, buffer, len)                                      \
    uc_ctl(uc, UC_CTL_WRITE(UC_CTL_UC_EXITS, 2), (buffer), (len))
#define uc_ctl_get_cpu_model(uc, model)                                        \
    uc_ctl(uc, UC_CTL_READ(UC_CTL_CPU_MODEL, 1), (model))
#define uc_ctl_set_cpu_model(uc, model)                                        \
    uc_ctl(uc, UC_CTL_WRITE(UC_CTL_CPU_MODEL, 1), (model))
#define uc_ctl_remove_cache(uc, address, end)                                  \
    uc_ctl(uc, UC_CTL_WRITE(UC_CTL_TB_REMOVE_CACHE, 2), (address), (end))
#define uc_ctl_request_cache(uc, address, tb)                                  \
    uc_ctl(uc, UC_CTL_READ_WRITE(UC_CTL_TB_REQUEST_CACHE, 2), (address), (tb))
#define uc_ctl_flush_tlb(uc) uc_ctl(uc, UC_CTL_WRITE(UC_CTL_TB_FLUSH, 0))
// Opaque storage for CPU context, used with uc_context_*()
struct uc_context;
typedef struct uc_context uc_context;

/*
 Return combined API version & major and minor version numbers.

 @major: major number of API version
 @minor: minor number of API version

 @return hexical number as (major << 8 | minor), which encodes both
     major & minor versions.
     NOTE: This returned value can be compared with version number made
     with macro UC_MAKE_VERSION

 For example, second API version would return 1 in @major, and 1 in @minor
 The return value would be 0x0101

 NOTE: if you only care about returned value, but not major and minor values,
 set both @major & @minor arguments to NULL.
*/
UNICORN_EXPORT
unsigned int uc_version(unsigned int *major, unsigned int *minor);

/*
 Determine if the given architecture is supported by this library.

 @arch: architecture type (UC_ARCH_*)

 @return True if this library supports the given arch.
*/
UNICORN_EXPORT
bool uc_arch_supported(uc_arch arch);

/*
 Create new instance of unicorn engine.

 @arch: architecture type (UC_ARCH_*)
 @mode: hardware mode. This is combined of UC_MODE_*
 @uc: pointer to uc_engine, which will be updated at return time

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_open(uc_arch arch, uc_mode mode, uc_engine **uc);

/*
 Close a Unicorn engine instance.
 NOTE: this must be called only when there is no longer any
 usage of @uc. This API releases some of @uc's cached memory, thus
 any use of the Unicorn API with @uc after it has been closed may
 crash your application. After this, @uc is invalid, and is no
 longer usable.

 @uc: pointer to a handle returned by uc_open()

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_close(uc_engine *uc);

/*
 Query internal status of engine.

 @uc: handle returned by uc_open()
 @type: query type. See uc_query_type

 @result: save the internal status queried

 @return: error code of uc_err enum type (UC_ERR_*, see above)
*/
UNICORN_EXPORT
uc_err uc_query(uc_engine *uc, uc_query_type type, size_t *result);

/*
 Control internal states of engine.

 Also see uc_ctl_* macro helpers for easy use.

 @uc: handle returned by uc_open()
 @control: the control type.
 @args: See uc_control_type for details about variadic arguments.

 @return: error code of uc_err enum type (UC_ERR_*, see above)
*/
UNICORN_EXPORT
uc_err uc_ctl(uc_engine *uc, uc_control_type control, ...);

/*
 Report the last error number when some API function fails.
 Like glibc's errno, uc_errno might not retain its old value once accessed.

 @uc: handle returned by uc_open()

 @return: error code of uc_err enum type (UC_ERR_*, see above)
*/
UNICORN_EXPORT
uc_err uc_errno(uc_engine *uc);

/*
 Return a string describing given error code.

 @code: error code (see UC_ERR_* above)

 @return: returns a pointer to a string that describes the error code
   passed in the argument @code
 */
UNICORN_EXPORT
const char *uc_strerror(uc_err code);

/*
 Write to register.

 @uc: handle returned by uc_open()
 @regid:  register ID that is to be modified.
 @value:  pointer to the value that will set to register @regid

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_reg_write(uc_engine *uc, int regid, const void *value);

/*
 Read register value.

 @uc: handle returned by uc_open()
 @regid:  register ID that is to be retrieved.
 @value:  pointer to a variable storing the register value.

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_reg_read(uc_engine *uc, int regid, void *value);

/*
 Write multiple register values.

 @uc: handle returned by uc_open()
 @rges:  array of register IDs to store
 @value: pointer to array of register values
 @count: length of both *regs and *vals

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_reg_write_batch(uc_engine *uc, int *regs, void *const *vals,
                          int count);

/*
 Read multiple register values.

 @uc: handle returned by uc_open()
 @rges:  array of register IDs to retrieve
 @value: pointer to array of values to hold registers
 @count: length of both *regs and *vals

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_reg_read_batch(uc_engine *uc, int *regs, void **vals, int count);

/*
 Write to a range of bytes in memory.

 @uc: handle returned by uc_open()
 @address: starting memory address of bytes to set.
 @bytes:   pointer to a variable containing data to be written to memory.
 @size:   size of memory to write to.

 NOTE: @bytes must be big enough to contain @size bytes.

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_mem_write(uc_engine *uc, uint64_t address, const void *bytes,
                    size_t size);

/*
 Read a range of bytes in memory.

 @uc: handle returned by uc_open()
 @address: starting memory address of bytes to get.
 @bytes:   pointer to a variable containing data copied from memory.
 @size:   size of memory to read.

 NOTE: @bytes must be big enough to contain @size bytes.

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_mem_read(uc_engine *uc, uint64_t address, void *bytes, size_t size);

/*
 Emulate machine code in a specific duration of time.

 @uc: handle returned by uc_open()
 @begin: address where emulation starts
 @until: address where emulation stops (i.e. when this address is hit)
 @timeout: duration to emulate the code (in microseconds). When this value is 0,
        we will emulate the code in infinite time, until the code is finished.
 @count: the number of instructions to be emulated. When this value is 0,
        we will emulate all the code available, until the code is finished.

 NOTE: The internal states of the engine is guranteed to be correct if and only
       if uc_emu_start returns without any errors or errors have been handled in
       the callbacks.

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_emu_start(uc_engine *uc, uint64_t begin, uint64_t until,
                    uint64_t timeout, size_t count);

/*
 Stop emulation (which was started by uc_emu_start() API.
 This is typically called from callback functions registered via tracing APIs.

 @uc: handle returned by uc_open()

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_emu_stop(uc_engine *uc);

/*
 Register callback for a hook event.
 The callback will be run when the hook event is hit.

 @uc: handle returned by uc_open()
 @hh: hook handle returned from this registration. To be used in uc_hook_del()
 API
 @type: hook type, refer to uc_hook_type enum
 @callback: callback to be run when instruction is hit
 @user_data: user-defined data. This will be passed to callback function in its
      last argument @user_data
 @begin: start address of the area where the callback is in effect (inclusive)
 @end: end address of the area where the callback is in effect (inclusive)
   NOTE 1: the callback is called only if related address is in range [@begin,
 @end] NOTE 2: if @begin > @end, callback is called whenever this hook type is
 triggered
 @...: variable arguments (depending on @type)
   NOTE: if @type = UC_HOOK_INSN, this is the instruction ID.
         currently, only x86 in, out, syscall, sysenter, cpuid are supported.
   NOTE: if @type = UC_HOOK_TCG_OPCODE, arguments are @opcode and @flags. See
 @uc_tcg_op_code and @uc_tcg_op_flag for details.

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_hook_add(uc_engine *uc, uc_hook *hh, int type, void *callback,
                   void *user_data, uint64_t begin, uint64_t end, ...);

/*
 Unregister (remove) a hook callback.
 This API removes the hook callback registered by uc_hook_add().
 NOTE: this should be called only when you no longer want to trace.
 After this, @hh is invalid, and no longer usable.

 @uc: handle returned by uc_open()
 @hh: handle returned by uc_hook_add()

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_hook_del(uc_engine *uc, uc_hook hh);

typedef enum uc_prot {
    UC_PROT_NONE = 0,
    UC_PROT_READ = 1,
    UC_PROT_WRITE = 2,
    UC_PROT_EXEC = 4,
    UC_PROT_ALL = 7,
} uc_prot;

/*
 Map memory in for emulation.
 This API adds a memory region that can be used by emulation.

 @uc: handle returned by uc_open()
 @address: starting address of the new memory region to be mapped in.
    This address must be aligned to 4KB, or this will return with UC_ERR_ARG
 error.
 @size: size of the new memory region to be mapped in.
    This size must be a multiple of 4KB, or this will return with UC_ERR_ARG
 error.
 @perms: Permissions for the newly mapped region.
    This must be some combination of UC_PROT_READ | UC_PROT_WRITE |
 UC_PROT_EXEC, or this will return with UC_ERR_ARG error.

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_mem_map(uc_engine *uc, uint64_t address, size_t size, uint32_t perms);

/*
 Map existing host memory in for emulation.
 This API adds a memory region that can be used by emulation.

 @uc: handle returned by uc_open()
 @address: starting address of the new memory region to be mapped in.
    This address must be aligned to 4KB, or this will return with UC_ERR_ARG
 error.
 @size: size of the new memory region to be mapped in.
    This size must be a multiple of 4KB, or this will return with UC_ERR_ARG
 error.
 @perms: Permissions for the newly mapped region.
    This must be some combination of UC_PROT_READ | UC_PROT_WRITE |
 UC_PROT_EXEC, or this will return with UC_ERR_ARG error.
 @ptr: pointer to host memory backing the newly mapped memory. This host memory
 is expected to be an equal or larger size than provided, and be mapped with at
    least PROT_READ | PROT_WRITE. If it is not, the resulting behavior is
 undefined.

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_mem_map_ptr(uc_engine *uc, uint64_t address, size_t size,
                      uint32_t perms, void *ptr);

/*
 Map MMIO in for emulation.
 This API adds a MMIO region that can be used by emulation.

 @uc: handle returned by uc_open()
 @address: starting address of the new MMIO region to be mapped in.
   This address must be aligned to 4KB, or this will return with UC_ERR_ARG
 error.
 @size: size of the new MMIO region to be mapped in.
   This size must be multiple of 4KB, or this will return with UC_ERR_ARG error.
 @read_cb: function for handling reads from this MMIO region.
 @user_data_read: user-defined data. This will be passed to @read_cb function in
 its last argument @user_data
 @write_cb: function for handling writes to this MMIO region.
 @user_data_write: user-defined data. This will be passed to @write_cb function
 in its last argument @user_data
 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
 */
UNICORN_EXPORT
uc_err uc_mmio_map(uc_engine *uc, uint64_t address, size_t size,
                   uc_cb_mmio_read_t read_cb, void *user_data_read,
                   uc_cb_mmio_write_t write_cb, void *user_data_write);

/*
 Unmap a region of emulation memory.
 This API deletes a memory mapping from the emulation memory space.

 @uc: handle returned by uc_open()
 @address: starting address of the memory region to be unmapped.
    This address must be aligned to 4KB, or this will return with UC_ERR_ARG
 error.
 @size: size of the memory region to be modified.
    This size must be a multiple of 4KB, or this will return with UC_ERR_ARG
 error.

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_mem_unmap(uc_engine *uc, uint64_t address, size_t size);

/*
 Set memory permissions for emulation memory.
 This API changes permissions on an existing memory region.

 @uc: handle returned by uc_open()
 @address: starting address of the memory region to be modified.
    This address must be aligned to 4KB, or this will return with UC_ERR_ARG
 error.
 @size: size of the memory region to be modified.
    This size must be a multiple of 4KB, or this will return with UC_ERR_ARG
 error.
 @perms: New permissions for the mapped region.
    This must be some combination of UC_PROT_READ | UC_PROT_WRITE |
 UC_PROT_EXEC, or this will return with UC_ERR_ARG error.

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_mem_protect(uc_engine *uc, uint64_t address, size_t size,
                      uint32_t perms);

/*
 Retrieve all memory regions mapped by uc_mem_map() and uc_mem_map_ptr()
 This API allocates memory for @regions, and user must free this memory later
 by uc_free() to avoid leaking memory.
 NOTE: memory regions may be split by uc_mem_unmap()

 @uc: handle returned by uc_open()
 @regions: pointer to an array of uc_mem_region struct. This is allocated by
   Unicorn, and must be freed by user later with uc_free()
 @count: pointer to number of struct uc_mem_region contained in @regions

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_mem_regions(uc_engine *uc, uc_mem_region **regions, uint32_t *count);

/*
 Allocate a region that can be used with uc_context_{save,restore} to perform
 quick save/rollback of the CPU context, which includes registers and some
 internal metadata. Contexts may not be shared across engine instances with
 differing arches or modes.

 @uc: handle returned by uc_open()
 @context: pointer to a uc_context*. This will be updated with the pointer to
   the new context on successful return of this function.
   Later, this allocated memory must be freed with uc_context_free().

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_context_alloc(uc_engine *uc, uc_context **context);

/*
 Free the memory allocated by uc_mem_regions.
 WARNING: After Unicorn 1.0.1rc5, the memory allocated by uc_context_alloc
 should be freed by uc_context_free(). Calling uc_free() may still work, but
 the result is **undefined**.

 @mem: memory allocated by uc_mem_regions (returned in *regions).

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_free(void *mem);

/*
 Save a copy of the internal CPU context.
 This API should be used to efficiently make or update a saved copy of the
 internal CPU state.

 @uc: handle returned by uc_open()
 @context: handle returned by uc_context_alloc()

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_context_save(uc_engine *uc, uc_context *context);

/*
 Write value to a register of a context.

 @ctx: handle returned by uc_context_alloc()
 @regid:  register ID that is to be modified.
 @value:  pointer to the value that will set to register @regid

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_context_reg_write(uc_context *ctx, int regid, const void *value);

/*
 Read register value from a context.

 @ctx: handle returned by uc_context_alloc()
 @regid:  register ID that is to be retrieved.
 @value:  pointer to a variable storing the register value.

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_context_reg_read(uc_context *ctx, int regid, void *value);

/*
 Write multiple register values to registers of a context.

 @ctx: handle returned by uc_context_alloc()
 @regs:  array of register IDs to store
 @value: pointer to array of register values
 @count: length of both *regs and *vals

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_context_reg_write_batch(uc_context *ctx, int *regs, void *const *vals,
                                  int count);

/*
 Read multiple register values from a context.

 @ctx: handle returned by uc_context_alloc()
 @regs:  array of register IDs to retrieve
 @value: pointer to array of values to hold registers
 @count: length of both *regs and *vals

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_context_reg_read_batch(uc_context *ctx, int *regs, void **vals,
                                 int count);

/*
 Restore the current CPU context from a saved copy.
 This API should be used to roll the CPU context back to a previous
 state saved by uc_context_save().

 @uc: handle returned by uc_open()
 @context: handle returned by uc_context_alloc that has been used with
 uc_context_save

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_context_restore(uc_engine *uc, uc_context *context);

/*
  Return the size needed to store the cpu context. Can be used to allocate a
  buffer to contain the cpu context and directly call uc_context_save.

  @uc: handle returned by uc_open()

  @return the size for needed to store the cpu context as as size_t.
*/
UNICORN_EXPORT
size_t uc_context_size(uc_engine *uc);

/*
  Free the context allocated by uc_context_alloc().

  @context: handle returned by uc_context_alloc()

  @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_context_free(uc_context *context);

#ifdef __cplusplus
}
#endif

#endif

```

`KDemu/unicorn/unicorn/x86.h`:

```h
/* Unicorn Emulator Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2015-2017 */
/* This file is released under LGPL2.
   See COPYING.LGPL2 in root directory for more details
*/

#ifndef UNICORN_X86_H
#define UNICORN_X86_H

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

//> X86 CPU
typedef enum uc_cpu_x86 {
    UC_CPU_X86_QEMU64 = 0,
    UC_CPU_X86_PHENOM,
    UC_CPU_X86_CORE2DUO,
    UC_CPU_X86_KVM64,
    UC_CPU_X86_QEMU32,
    UC_CPU_X86_KVM32,
    UC_CPU_X86_COREDUO,
    UC_CPU_X86_486,
    UC_CPU_X86_PENTIUM,
    UC_CPU_X86_PENTIUM2,
    UC_CPU_X86_PENTIUM3,
    UC_CPU_X86_ATHLON,
    UC_CPU_X86_N270,
    UC_CPU_X86_CONROE,
    UC_CPU_X86_PENRYN,
    UC_CPU_X86_NEHALEM,
    UC_CPU_X86_WESTMERE,
    UC_CPU_X86_SANDYBRIDGE,
    UC_CPU_X86_IVYBRIDGE,
    UC_CPU_X86_HASWELL,
    UC_CPU_X86_BROADWELL,
    UC_CPU_X86_SKYLAKE_CLIENT,
    UC_CPU_X86_SKYLAKE_SERVER,
    UC_CPU_X86_CASCADELAKE_SERVER,
    UC_CPU_X86_COOPERLAKE,
    UC_CPU_X86_ICELAKE_CLIENT,
    UC_CPU_X86_ICELAKE_SERVER,
    UC_CPU_X86_DENVERTON,
    UC_CPU_X86_SNOWRIDGE,
    UC_CPU_X86_KNIGHTSMILL,
    UC_CPU_X86_OPTERON_G1,
    UC_CPU_X86_OPTERON_G2,
    UC_CPU_X86_OPTERON_G3,
    UC_CPU_X86_OPTERON_G4,
    UC_CPU_X86_OPTERON_G5,
    UC_CPU_X86_EPYC,
    UC_CPU_X86_DHYANA,
    UC_CPU_X86_EPYC_ROME,

    UC_CPU_X86_ENDING
} uc_cpu_x86;

// Memory-Management Register for instructions IDTR, GDTR, LDTR, TR.
// Borrow from SegmentCache in qemu/target-i386/cpu.h
typedef struct uc_x86_mmr {
    uint16_t selector; /* not used by GDTR and IDTR */
    uint64_t base;     /* handle 32 or 64 bit CPUs */
    uint32_t limit;
    uint32_t flags; /* not used by GDTR and IDTR */
} uc_x86_mmr;

// Model-Specific Register structure, use this with UC_X86_REG_MSR (as the
// register ID) in call to uc_reg_write/uc_reg_read() to manipulate MSRs.
typedef struct uc_x86_msr {
    uint32_t rid;   // MSR id
    uint64_t value; // MSR value
} uc_x86_msr;

// Callback function for tracing SYSCALL/SYSENTER (for uc_hook_intr())
// @user_data: user data passed to tracing APIs.
typedef void (*uc_cb_insn_syscall_t)(struct uc_struct *uc, void *user_data);

// Callback function for tracing cpuid (for uc_hook_intr())
// @user_data: user data passed to tracing APIs.
//
// @return: true indicates the callback overwrites the cpuid instruction while
// false
//          indicates cpuid instruction will still be executed.
typedef int (*uc_cb_insn_cpuid_t)(struct uc_struct *uc, void *user_data);

//> X86 registers
typedef enum uc_x86_reg {
    UC_X86_REG_INVALID = 0,
    UC_X86_REG_AH,
    UC_X86_REG_AL,
    UC_X86_REG_AX,
    UC_X86_REG_BH,
    UC_X86_REG_BL,
    UC_X86_REG_BP,
    UC_X86_REG_BPL,
    UC_X86_REG_BX,
    UC_X86_REG_CH,
    UC_X86_REG_CL,
    UC_X86_REG_CS,
    UC_X86_REG_CX,
    UC_X86_REG_DH,
    UC_X86_REG_DI,
    UC_X86_REG_DIL,
    UC_X86_REG_DL,
    UC_X86_REG_DS,
    UC_X86_REG_DX,
    UC_X86_REG_EAX,
    UC_X86_REG_EBP,
    UC_X86_REG_EBX,
    UC_X86_REG_ECX,
    UC_X86_REG_EDI,
    UC_X86_REG_EDX,
    UC_X86_REG_EFLAGS,
    UC_X86_REG_EIP,
    UC_X86_REG_ES = UC_X86_REG_EIP + 2,
    UC_X86_REG_ESI,
    UC_X86_REG_ESP,
    UC_X86_REG_FPSW,
    UC_X86_REG_FS,
    UC_X86_REG_GS,
    UC_X86_REG_IP,
    UC_X86_REG_RAX,
    UC_X86_REG_RBP,
    UC_X86_REG_RBX,
    UC_X86_REG_RCX,
    UC_X86_REG_RDI,
    UC_X86_REG_RDX,
    UC_X86_REG_RIP,
    UC_X86_REG_RSI = UC_X86_REG_RIP + 2,
    UC_X86_REG_RSP,
    UC_X86_REG_SI,
    UC_X86_REG_SIL,
    UC_X86_REG_SP,
    UC_X86_REG_SPL,
    UC_X86_REG_SS,
    UC_X86_REG_CR0,
    UC_X86_REG_CR1,
    UC_X86_REG_CR2,
    UC_X86_REG_CR3,
    UC_X86_REG_CR4,
    UC_X86_REG_CR8 = UC_X86_REG_CR4 + 4,
    UC_X86_REG_DR0 = UC_X86_REG_CR8 + 8,
    UC_X86_REG_DR1,
    UC_X86_REG_DR2,
    UC_X86_REG_DR3,
    UC_X86_REG_DR4,
    UC_X86_REG_DR5,
    UC_X86_REG_DR6,
    UC_X86_REG_DR7,
    UC_X86_REG_FP0 = UC_X86_REG_DR7 + 9,
    UC_X86_REG_FP1,
    UC_X86_REG_FP2,
    UC_X86_REG_FP3,
    UC_X86_REG_FP4,
    UC_X86_REG_FP5,
    UC_X86_REG_FP6,
    UC_X86_REG_FP7,
    UC_X86_REG_K0,
    UC_X86_REG_K1,
    UC_X86_REG_K2,
    UC_X86_REG_K3,
    UC_X86_REG_K4,
    UC_X86_REG_K5,
    UC_X86_REG_K6,
    UC_X86_REG_K7,
    UC_X86_REG_MM0,
    UC_X86_REG_MM1,
    UC_X86_REG_MM2,
    UC_X86_REG_MM3,
    UC_X86_REG_MM4,
    UC_X86_REG_MM5,
    UC_X86_REG_MM6,
    UC_X86_REG_MM7,
    UC_X86_REG_R8,
    UC_X86_REG_R9,
    UC_X86_REG_R10,
    UC_X86_REG_R11,
    UC_X86_REG_R12,
    UC_X86_REG_R13,
    UC_X86_REG_R14,
    UC_X86_REG_R15,
    UC_X86_REG_ST0,
    UC_X86_REG_ST1,
    UC_X86_REG_ST2,
    UC_X86_REG_ST3,
    UC_X86_REG_ST4,
    UC_X86_REG_ST5,
    UC_X86_REG_ST6,
    UC_X86_REG_ST7,
    UC_X86_REG_XMM0,
    UC_X86_REG_XMM1,
    UC_X86_REG_XMM2,
    UC_X86_REG_XMM3,
    UC_X86_REG_XMM4,
    UC_X86_REG_XMM5,
    UC_X86_REG_XMM6,
    UC_X86_REG_XMM7,
    UC_X86_REG_XMM8,
    UC_X86_REG_XMM9,
    UC_X86_REG_XMM10,
    UC_X86_REG_XMM11,
    UC_X86_REG_XMM12,
    UC_X86_REG_XMM13,
    UC_X86_REG_XMM14,
    UC_X86_REG_XMM15,
    UC_X86_REG_XMM16,
    UC_X86_REG_XMM17,
    UC_X86_REG_XMM18,
    UC_X86_REG_XMM19,
    UC_X86_REG_XMM20,
    UC_X86_REG_XMM21,
    UC_X86_REG_XMM22,
    UC_X86_REG_XMM23,
    UC_X86_REG_XMM24,
    UC_X86_REG_XMM25,
    UC_X86_REG_XMM26,
    UC_X86_REG_XMM27,
    UC_X86_REG_XMM28,
    UC_X86_REG_XMM29,
    UC_X86_REG_XMM30,
    UC_X86_REG_XMM31,
    UC_X86_REG_YMM0,
    UC_X86_REG_YMM1,
    UC_X86_REG_YMM2,
    UC_X86_REG_YMM3,
    UC_X86_REG_YMM4,
    UC_X86_REG_YMM5,
    UC_X86_REG_YMM6,
    UC_X86_REG_YMM7,
    UC_X86_REG_YMM8,
    UC_X86_REG_YMM9,
    UC_X86_REG_YMM10,
    UC_X86_REG_YMM11,
    UC_X86_REG_YMM12,
    UC_X86_REG_YMM13,
    UC_X86_REG_YMM14,
    UC_X86_REG_YMM15,
    UC_X86_REG_YMM16,
    UC_X86_REG_YMM17,
    UC_X86_REG_YMM18,
    UC_X86_REG_YMM19,
    UC_X86_REG_YMM20,
    UC_X86_REG_YMM21,
    UC_X86_REG_YMM22,
    UC_X86_REG_YMM23,
    UC_X86_REG_YMM24,
    UC_X86_REG_YMM25,
    UC_X86_REG_YMM26,
    UC_X86_REG_YMM27,
    UC_X86_REG_YMM28,
    UC_X86_REG_YMM29,
    UC_X86_REG_YMM30,
    UC_X86_REG_YMM31,
    UC_X86_REG_ZMM0,
    UC_X86_REG_ZMM1,
    UC_X86_REG_ZMM2,
    UC_X86_REG_ZMM3,
    UC_X86_REG_ZMM4,
    UC_X86_REG_ZMM5,
    UC_X86_REG_ZMM6,
    UC_X86_REG_ZMM7,
    UC_X86_REG_ZMM8,
    UC_X86_REG_ZMM9,
    UC_X86_REG_ZMM10,
    UC_X86_REG_ZMM11,
    UC_X86_REG_ZMM12,
    UC_X86_REG_ZMM13,
    UC_X86_REG_ZMM14,
    UC_X86_REG_ZMM15,
    UC_X86_REG_ZMM16,
    UC_X86_REG_ZMM17,
    UC_X86_REG_ZMM18,
    UC_X86_REG_ZMM19,
    UC_X86_REG_ZMM20,
    UC_X86_REG_ZMM21,
    UC_X86_REG_ZMM22,
    UC_X86_REG_ZMM23,
    UC_X86_REG_ZMM24,
    UC_X86_REG_ZMM25,
    UC_X86_REG_ZMM26,
    UC_X86_REG_ZMM27,
    UC_X86_REG_ZMM28,
    UC_X86_REG_ZMM29,
    UC_X86_REG_ZMM30,
    UC_X86_REG_ZMM31,
    UC_X86_REG_R8B,
    UC_X86_REG_R9B,
    UC_X86_REG_R10B,
    UC_X86_REG_R11B,
    UC_X86_REG_R12B,
    UC_X86_REG_R13B,
    UC_X86_REG_R14B,
    UC_X86_REG_R15B,
    UC_X86_REG_R8D,
    UC_X86_REG_R9D,
    UC_X86_REG_R10D,
    UC_X86_REG_R11D,
    UC_X86_REG_R12D,
    UC_X86_REG_R13D,
    UC_X86_REG_R14D,
    UC_X86_REG_R15D,
    UC_X86_REG_R8W,
    UC_X86_REG_R9W,
    UC_X86_REG_R10W,
    UC_X86_REG_R11W,
    UC_X86_REG_R12W,
    UC_X86_REG_R13W,
    UC_X86_REG_R14W,
    UC_X86_REG_R15W,
    UC_X86_REG_IDTR,
    UC_X86_REG_GDTR,
    UC_X86_REG_LDTR,
    UC_X86_REG_TR,
    UC_X86_REG_FPCW,
    UC_X86_REG_FPTAG,
    UC_X86_REG_MSR, // Model-Specific Register
    UC_X86_REG_MXCSR,
    UC_X86_REG_FS_BASE, // Base regs for x86_64
    UC_X86_REG_GS_BASE,
    UC_X86_REG_FLAGS,
    UC_X86_REG_RFLAGS,
    UC_X86_REG_FIP,
    UC_X86_REG_FCS,
    UC_X86_REG_FDP,
    UC_X86_REG_FDS,
    UC_X86_REG_FOP,
    UC_X86_REG_ENDING // <-- mark the end of the list of registers
} uc_x86_reg;

//> X86 instructions
typedef enum uc_x86_insn {
    UC_X86_INS_INVALID = 0,

    UC_X86_INS_AAA,
    UC_X86_INS_AAD,
    UC_X86_INS_AAM,
    UC_X86_INS_AAS,
    UC_X86_INS_FABS,
    UC_X86_INS_ADC,
    UC_X86_INS_ADCX,
    UC_X86_INS_ADD,
    UC_X86_INS_ADDPD,
    UC_X86_INS_ADDPS,
    UC_X86_INS_ADDSD,
    UC_X86_INS_ADDSS,
    UC_X86_INS_ADDSUBPD,
    UC_X86_INS_ADDSUBPS,
    UC_X86_INS_FADD,
    UC_X86_INS_FIADD,
    UC_X86_INS_FADDP,
    UC_X86_INS_ADOX,
    UC_X86_INS_AESDECLAST,
    UC_X86_INS_AESDEC,
    UC_X86_INS_AESENCLAST,
    UC_X86_INS_AESENC,
    UC_X86_INS_AESIMC,
    UC_X86_INS_AESKEYGENASSIST,
    UC_X86_INS_AND,
    UC_X86_INS_ANDN,
    UC_X86_INS_ANDNPD,
    UC_X86_INS_ANDNPS,
    UC_X86_INS_ANDPD,
    UC_X86_INS_ANDPS,
    UC_X86_INS_ARPL,
    UC_X86_INS_BEXTR,
    UC_X86_INS_BLCFILL,
    UC_X86_INS_BLCI,
    UC_X86_INS_BLCIC,
    UC_X86_INS_BLCMSK,
    UC_X86_INS_BLCS,
    UC_X86_INS_BLENDPD,
    UC_X86_INS_BLENDPS,
    UC_X86_INS_BLENDVPD,
    UC_X86_INS_BLENDVPS,
    UC_X86_INS_BLSFILL,
    UC_X86_INS_BLSI,
    UC_X86_INS_BLSIC,
    UC_X86_INS_BLSMSK,
    UC_X86_INS_BLSR,
    UC_X86_INS_BOUND,
    UC_X86_INS_BSF,
    UC_X86_INS_BSR,
    UC_X86_INS_BSWAP,
    UC_X86_INS_BT,
    UC_X86_INS_BTC,
    UC_X86_INS_BTR,
    UC_X86_INS_BTS,
    UC_X86_INS_BZHI,
    UC_X86_INS_CALL,
    UC_X86_INS_CBW,
    UC_X86_INS_CDQ,
    UC_X86_INS_CDQE,
    UC_X86_INS_FCHS,
    UC_X86_INS_CLAC,
    UC_X86_INS_CLC,
    UC_X86_INS_CLD,
    UC_X86_INS_CLFLUSH,
    UC_X86_INS_CLFLUSHOPT,
    UC_X86_INS_CLGI,
    UC_X86_INS_CLI,
    UC_X86_INS_CLTS,
    UC_X86_INS_CLWB,
    UC_X86_INS_CMC,
    UC_X86_INS_CMOVA,
    UC_X86_INS_CMOVAE,
    UC_X86_INS_CMOVB,
    UC_X86_INS_CMOVBE,
    UC_X86_INS_FCMOVBE,
    UC_X86_INS_FCMOVB,
    UC_X86_INS_CMOVE,
    UC_X86_INS_FCMOVE,
    UC_X86_INS_CMOVG,
    UC_X86_INS_CMOVGE,
    UC_X86_INS_CMOVL,
    UC_X86_INS_CMOVLE,
    UC_X86_INS_FCMOVNBE,
    UC_X86_INS_FCMOVNB,
    UC_X86_INS_CMOVNE,
    UC_X86_INS_FCMOVNE,
    UC_X86_INS_CMOVNO,
    UC_X86_INS_CMOVNP,
    UC_X86_INS_FCMOVNU,
    UC_X86_INS_CMOVNS,
    UC_X86_INS_CMOVO,
    UC_X86_INS_CMOVP,
    UC_X86_INS_FCMOVU,
    UC_X86_INS_CMOVS,
    UC_X86_INS_CMP,
    UC_X86_INS_CMPPD,
    UC_X86_INS_CMPPS,
    UC_X86_INS_CMPSB,
    UC_X86_INS_CMPSD,
    UC_X86_INS_CMPSQ,
    UC_X86_INS_CMPSS,
    UC_X86_INS_CMPSW,
    UC_X86_INS_CMPXCHG16B,
    UC_X86_INS_CMPXCHG,
    UC_X86_INS_CMPXCHG8B,
    UC_X86_INS_COMISD,
    UC_X86_INS_COMISS,
    UC_X86_INS_FCOMP,
    UC_X86_INS_FCOMPI,
    UC_X86_INS_FCOMI,
    UC_X86_INS_FCOM,
    UC_X86_INS_FCOS,
    UC_X86_INS_CPUID,
    UC_X86_INS_CQO,
    UC_X86_INS_CRC32,
    UC_X86_INS_CVTDQ2PD,
    UC_X86_INS_CVTDQ2PS,
    UC_X86_INS_CVTPD2DQ,
    UC_X86_INS_CVTPD2PS,
    UC_X86_INS_CVTPS2DQ,
    UC_X86_INS_CVTPS2PD,
    UC_X86_INS_CVTSD2SI,
    UC_X86_INS_CVTSD2SS,
    UC_X86_INS_CVTSI2SD,
    UC_X86_INS_CVTSI2SS,
    UC_X86_INS_CVTSS2SD,
    UC_X86_INS_CVTSS2SI,
    UC_X86_INS_CVTTPD2DQ,
    UC_X86_INS_CVTTPS2DQ,
    UC_X86_INS_CVTTSD2SI,
    UC_X86_INS_CVTTSS2SI,
    UC_X86_INS_CWD,
    UC_X86_INS_CWDE,
    UC_X86_INS_DAA,
    UC_X86_INS_DAS,
    UC_X86_INS_DATA16,
    UC_X86_INS_DEC,
    UC_X86_INS_DIV,
    UC_X86_INS_DIVPD,
    UC_X86_INS_DIVPS,
    UC_X86_INS_FDIVR,
    UC_X86_INS_FIDIVR,
    UC_X86_INS_FDIVRP,
    UC_X86_INS_DIVSD,
    UC_X86_INS_DIVSS,
    UC_X86_INS_FDIV,
    UC_X86_INS_FIDIV,
    UC_X86_INS_FDIVP,
    UC_X86_INS_DPPD,
    UC_X86_INS_DPPS,
    UC_X86_INS_RET,
    UC_X86_INS_ENCLS,
    UC_X86_INS_ENCLU,
    UC_X86_INS_ENTER,
    UC_X86_INS_EXTRACTPS,
    UC_X86_INS_EXTRQ,
    UC_X86_INS_F2XM1,
    UC_X86_INS_LCALL,
    UC_X86_INS_LJMP,
    UC_X86_INS_FBLD,
    UC_X86_INS_FBSTP,
    UC_X86_INS_FCOMPP,
    UC_X86_INS_FDECSTP,
    UC_X86_INS_FEMMS,
    UC_X86_INS_FFREE,
    UC_X86_INS_FICOM,
    UC_X86_INS_FICOMP,
    UC_X86_INS_FINCSTP,
    UC_X86_INS_FLDCW,
    UC_X86_INS_FLDENV,
    UC_X86_INS_FLDL2E,
    UC_X86_INS_FLDL2T,
    UC_X86_INS_FLDLG2,
    UC_X86_INS_FLDLN2,
    UC_X86_INS_FLDPI,
    UC_X86_INS_FNCLEX,
    UC_X86_INS_FNINIT,
    UC_X86_INS_FNOP,
    UC_X86_INS_FNSTCW,
    UC_X86_INS_FNSTSW,
    UC_X86_INS_FPATAN,
    UC_X86_INS_FPREM,
    UC_X86_INS_FPREM1,
    UC_X86_INS_FPTAN,
    UC_X86_INS_FFREEP,
    UC_X86_INS_FRNDINT,
    UC_X86_INS_FRSTOR,
    UC_X86_INS_FNSAVE,
    UC_X86_INS_FSCALE,
    UC_X86_INS_FSETPM,
    UC_X86_INS_FSINCOS,
    UC_X86_INS_FNSTENV,
    UC_X86_INS_FXAM,
    UC_X86_INS_FXRSTOR,
    UC_X86_INS_FXRSTOR64,
    UC_X86_INS_FXSAVE,
    UC_X86_INS_FXSAVE64,
    UC_X86_INS_FXTRACT,
    UC_X86_INS_FYL2X,
    UC_X86_INS_FYL2XP1,
    UC_X86_INS_MOVAPD,
    UC_X86_INS_MOVAPS,
    UC_X86_INS_ORPD,
    UC_X86_INS_ORPS,
    UC_X86_INS_VMOVAPD,
    UC_X86_INS_VMOVAPS,
    UC_X86_INS_XORPD,
    UC_X86_INS_XORPS,
    UC_X86_INS_GETSEC,
    UC_X86_INS_HADDPD,
    UC_X86_INS_HADDPS,
    UC_X86_INS_HLT,
    UC_X86_INS_HSUBPD,
    UC_X86_INS_HSUBPS,
    UC_X86_INS_IDIV,
    UC_X86_INS_FILD,
    UC_X86_INS_IMUL,
    UC_X86_INS_IN,
    UC_X86_INS_INC,
    UC_X86_INS_INSB,
    UC_X86_INS_INSERTPS,
    UC_X86_INS_INSERTQ,
    UC_X86_INS_INSD,
    UC_X86_INS_INSW,
    UC_X86_INS_INT,
    UC_X86_INS_INT1,
    UC_X86_INS_INT3,
    UC_X86_INS_INTO,
    UC_X86_INS_INVD,
    UC_X86_INS_INVEPT,
    UC_X86_INS_INVLPG,
    UC_X86_INS_INVLPGA,
    UC_X86_INS_INVPCID,
    UC_X86_INS_INVVPID,
    UC_X86_INS_IRET,
    UC_X86_INS_IRETD,
    UC_X86_INS_IRETQ,
    UC_X86_INS_FISTTP,
    UC_X86_INS_FIST,
    UC_X86_INS_FISTP,
    UC_X86_INS_UCOMISD,
    UC_X86_INS_UCOMISS,
    UC_X86_INS_VCOMISD,
    UC_X86_INS_VCOMISS,
    UC_X86_INS_VCVTSD2SS,
    UC_X86_INS_VCVTSI2SD,
    UC_X86_INS_VCVTSI2SS,
    UC_X86_INS_VCVTSS2SD,
    UC_X86_INS_VCVTTSD2SI,
    UC_X86_INS_VCVTTSD2USI,
    UC_X86_INS_VCVTTSS2SI,
    UC_X86_INS_VCVTTSS2USI,
    UC_X86_INS_VCVTUSI2SD,
    UC_X86_INS_VCVTUSI2SS,
    UC_X86_INS_VUCOMISD,
    UC_X86_INS_VUCOMISS,
    UC_X86_INS_JAE,
    UC_X86_INS_JA,
    UC_X86_INS_JBE,
    UC_X86_INS_JB,
    UC_X86_INS_JCXZ,
    UC_X86_INS_JECXZ,
    UC_X86_INS_JE,
    UC_X86_INS_JGE,
    UC_X86_INS_JG,
    UC_X86_INS_JLE,
    UC_X86_INS_JL,
    UC_X86_INS_JMP,
    UC_X86_INS_JNE,
    UC_X86_INS_JNO,
    UC_X86_INS_JNP,
    UC_X86_INS_JNS,
    UC_X86_INS_JO,
    UC_X86_INS_JP,
    UC_X86_INS_JRCXZ,
    UC_X86_INS_JS,
    UC_X86_INS_KANDB,
    UC_X86_INS_KANDD,
    UC_X86_INS_KANDNB,
    UC_X86_INS_KANDND,
    UC_X86_INS_KANDNQ,
    UC_X86_INS_KANDNW,
    UC_X86_INS_KANDQ,
    UC_X86_INS_KANDW,
    UC_X86_INS_KMOVB,
    UC_X86_INS_KMOVD,
    UC_X86_INS_KMOVQ,
    UC_X86_INS_KMOVW,
    UC_X86_INS_KNOTB,
    UC_X86_INS_KNOTD,
    UC_X86_INS_KNOTQ,
    UC_X86_INS_KNOTW,
    UC_X86_INS_KORB,
    UC_X86_INS_KORD,
    UC_X86_INS_KORQ,
    UC_X86_INS_KORTESTB,
    UC_X86_INS_KORTESTD,
    UC_X86_INS_KORTESTQ,
    UC_X86_INS_KORTESTW,
    UC_X86_INS_KORW,
    UC_X86_INS_KSHIFTLB,
    UC_X86_INS_KSHIFTLD,
    UC_X86_INS_KSHIFTLQ,
    UC_X86_INS_KSHIFTLW,
    UC_X86_INS_KSHIFTRB,
    UC_X86_INS_KSHIFTRD,
    UC_X86_INS_KSHIFTRQ,
    UC_X86_INS_KSHIFTRW,
    UC_X86_INS_KUNPCKBW,
    UC_X86_INS_KXNORB,
    UC_X86_INS_KXNORD,
    UC_X86_INS_KXNORQ,
    UC_X86_INS_KXNORW,
    UC_X86_INS_KXORB,
    UC_X86_INS_KXORD,
    UC_X86_INS_KXORQ,
    UC_X86_INS_KXORW,
    UC_X86_INS_LAHF,
    UC_X86_INS_LAR,
    UC_X86_INS_LDDQU,
    UC_X86_INS_LDMXCSR,
    UC_X86_INS_LDS,
    UC_X86_INS_FLDZ,
    UC_X86_INS_FLD1,
    UC_X86_INS_FLD,
    UC_X86_INS_LEA,
    UC_X86_INS_LEAVE,
    UC_X86_INS_LES,
    UC_X86_INS_LFENCE,
    UC_X86_INS_LFS,
    UC_X86_INS_LGDT,
    UC_X86_INS_LGS,
    UC_X86_INS_LIDT,
    UC_X86_INS_LLDT,
    UC_X86_INS_LMSW,
    UC_X86_INS_OR,
    UC_X86_INS_SUB,
    UC_X86_INS_XOR,
    UC_X86_INS_LODSB,
    UC_X86_INS_LODSD,
    UC_X86_INS_LODSQ,
    UC_X86_INS_LODSW,
    UC_X86_INS_LOOP,
    UC_X86_INS_LOOPE,
    UC_X86_INS_LOOPNE,
    UC_X86_INS_RETF,
    UC_X86_INS_RETFQ,
    UC_X86_INS_LSL,
    UC_X86_INS_LSS,
    UC_X86_INS_LTR,
    UC_X86_INS_XADD,
    UC_X86_INS_LZCNT,
    UC_X86_INS_MASKMOVDQU,
    UC_X86_INS_MAXPD,
    UC_X86_INS_MAXPS,
    UC_X86_INS_MAXSD,
    UC_X86_INS_MAXSS,
    UC_X86_INS_MFENCE,
    UC_X86_INS_MINPD,
    UC_X86_INS_MINPS,
    UC_X86_INS_MINSD,
    UC_X86_INS_MINSS,
    UC_X86_INS_CVTPD2PI,
    UC_X86_INS_CVTPI2PD,
    UC_X86_INS_CVTPI2PS,
    UC_X86_INS_CVTPS2PI,
    UC_X86_INS_CVTTPD2PI,
    UC_X86_INS_CVTTPS2PI,
    UC_X86_INS_EMMS,
    UC_X86_INS_MASKMOVQ,
    UC_X86_INS_MOVD,
    UC_X86_INS_MOVDQ2Q,
    UC_X86_INS_MOVNTQ,
    UC_X86_INS_MOVQ2DQ,
    UC_X86_INS_MOVQ,
    UC_X86_INS_PABSB,
    UC_X86_INS_PABSD,
    UC_X86_INS_PABSW,
    UC_X86_INS_PACKSSDW,
    UC_X86_INS_PACKSSWB,
    UC_X86_INS_PACKUSWB,
    UC_X86_INS_PADDB,
    UC_X86_INS_PADDD,
    UC_X86_INS_PADDQ,
    UC_X86_INS_PADDSB,
    UC_X86_INS_PADDSW,
    UC_X86_INS_PADDUSB,
    UC_X86_INS_PADDUSW,
    UC_X86_INS_PADDW,
    UC_X86_INS_PALIGNR,
    UC_X86_INS_PANDN,
    UC_X86_INS_PAND,
    UC_X86_INS_PAVGB,
    UC_X86_INS_PAVGW,
    UC_X86_INS_PCMPEQB,
    UC_X86_INS_PCMPEQD,
    UC_X86_INS_PCMPEQW,
    UC_X86_INS_PCMPGTB,
    UC_X86_INS_PCMPGTD,
    UC_X86_INS_PCMPGTW,
    UC_X86_INS_PEXTRW,
    UC_X86_INS_PHADDSW,
    UC_X86_INS_PHADDW,
    UC_X86_INS_PHADDD,
    UC_X86_INS_PHSUBD,
    UC_X86_INS_PHSUBSW,
    UC_X86_INS_PHSUBW,
    UC_X86_INS_PINSRW,
    UC_X86_INS_PMADDUBSW,
    UC_X86_INS_PMADDWD,
    UC_X86_INS_PMAXSW,
    UC_X86_INS_PMAXUB,
    UC_X86_INS_PMINSW,
    UC_X86_INS_PMINUB,
    UC_X86_INS_PMOVMSKB,
    UC_X86_INS_PMULHRSW,
    UC_X86_INS_PMULHUW,
    UC_X86_INS_PMULHW,
    UC_X86_INS_PMULLW,
    UC_X86_INS_PMULUDQ,
    UC_X86_INS_POR,
    UC_X86_INS_PSADBW,
    UC_X86_INS_PSHUFB,
    UC_X86_INS_PSHUFW,
    UC_X86_INS_PSIGNB,
    UC_X86_INS_PSIGND,
    UC_X86_INS_PSIGNW,
    UC_X86_INS_PSLLD,
    UC_X86_INS_PSLLQ,
    UC_X86_INS_PSLLW,
    UC_X86_INS_PSRAD,
    UC_X86_INS_PSRAW,
    UC_X86_INS_PSRLD,
    UC_X86_INS_PSRLQ,
    UC_X86_INS_PSRLW,
    UC_X86_INS_PSUBB,
    UC_X86_INS_PSUBD,
    UC_X86_INS_PSUBQ,
    UC_X86_INS_PSUBSB,
    UC_X86_INS_PSUBSW,
    UC_X86_INS_PSUBUSB,
    UC_X86_INS_PSUBUSW,
    UC_X86_INS_PSUBW,
    UC_X86_INS_PUNPCKHBW,
    UC_X86_INS_PUNPCKHDQ,
    UC_X86_INS_PUNPCKHWD,
    UC_X86_INS_PUNPCKLBW,
    UC_X86_INS_PUNPCKLDQ,
    UC_X86_INS_PUNPCKLWD,
    UC_X86_INS_PXOR,
    UC_X86_INS_MONITOR,
    UC_X86_INS_MONTMUL,
    UC_X86_INS_MOV,
    UC_X86_INS_MOVABS,
    UC_X86_INS_MOVBE,
    UC_X86_INS_MOVDDUP,
    UC_X86_INS_MOVDQA,
    UC_X86_INS_MOVDQU,
    UC_X86_INS_MOVHLPS,
    UC_X86_INS_MOVHPD,
    UC_X86_INS_MOVHPS,
    UC_X86_INS_MOVLHPS,
    UC_X86_INS_MOVLPD,
    UC_X86_INS_MOVLPS,
    UC_X86_INS_MOVMSKPD,
    UC_X86_INS_MOVMSKPS,
    UC_X86_INS_MOVNTDQA,
    UC_X86_INS_MOVNTDQ,
    UC_X86_INS_MOVNTI,
    UC_X86_INS_MOVNTPD,
    UC_X86_INS_MOVNTPS,
    UC_X86_INS_MOVNTSD,
    UC_X86_INS_MOVNTSS,
    UC_X86_INS_MOVSB,
    UC_X86_INS_MOVSD,
    UC_X86_INS_MOVSHDUP,
    UC_X86_INS_MOVSLDUP,
    UC_X86_INS_MOVSQ,
    UC_X86_INS_MOVSS,
    UC_X86_INS_MOVSW,
    UC_X86_INS_MOVSX,
    UC_X86_INS_MOVSXD,
    UC_X86_INS_MOVUPD,
    UC_X86_INS_MOVUPS,
    UC_X86_INS_MOVZX,
    UC_X86_INS_MPSADBW,
    UC_X86_INS_MUL,
    UC_X86_INS_MULPD,
    UC_X86_INS_MULPS,
    UC_X86_INS_MULSD,
    UC_X86_INS_MULSS,
    UC_X86_INS_MULX,
    UC_X86_INS_FMUL,
    UC_X86_INS_FIMUL,
    UC_X86_INS_FMULP,
    UC_X86_INS_MWAIT,
    UC_X86_INS_NEG,
    UC_X86_INS_NOP,
    UC_X86_INS_NOT,
    UC_X86_INS_OUT,
    UC_X86_INS_OUTSB,
    UC_X86_INS_OUTSD,
    UC_X86_INS_OUTSW,
    UC_X86_INS_PACKUSDW,
    UC_X86_INS_PAUSE,
    UC_X86_INS_PAVGUSB,
    UC_X86_INS_PBLENDVB,
    UC_X86_INS_PBLENDW,
    UC_X86_INS_PCLMULQDQ,
    UC_X86_INS_PCMPEQQ,
    UC_X86_INS_PCMPESTRI,
    UC_X86_INS_PCMPESTRM,
    UC_X86_INS_PCMPGTQ,
    UC_X86_INS_PCMPISTRI,
    UC_X86_INS_PCMPISTRM,
    UC_X86_INS_PCOMMIT,
    UC_X86_INS_PDEP,
    UC_X86_INS_PEXT,
    UC_X86_INS_PEXTRB,
    UC_X86_INS_PEXTRD,
    UC_X86_INS_PEXTRQ,
    UC_X86_INS_PF2ID,
    UC_X86_INS_PF2IW,
    UC_X86_INS_PFACC,
    UC_X86_INS_PFADD,
    UC_X86_INS_PFCMPEQ,
    UC_X86_INS_PFCMPGE,
    UC_X86_INS_PFCMPGT,
    UC_X86_INS_PFMAX,
    UC_X86_INS_PFMIN,
    UC_X86_INS_PFMUL,
    UC_X86_INS_PFNACC,
    UC_X86_INS_PFPNACC,
    UC_X86_INS_PFRCPIT1,
    UC_X86_INS_PFRCPIT2,
    UC_X86_INS_PFRCP,
    UC_X86_INS_PFRSQIT1,
    UC_X86_INS_PFRSQRT,
    UC_X86_INS_PFSUBR,
    UC_X86_INS_PFSUB,
    UC_X86_INS_PHMINPOSUW,
    UC_X86_INS_PI2FD,
    UC_X86_INS_PI2FW,
    UC_X86_INS_PINSRB,
    UC_X86_INS_PINSRD,
    UC_X86_INS_PINSRQ,
    UC_X86_INS_PMAXSB,
    UC_X86_INS_PMAXSD,
    UC_X86_INS_PMAXUD,
    UC_X86_INS_PMAXUW,
    UC_X86_INS_PMINSB,
    UC_X86_INS_PMINSD,
    UC_X86_INS_PMINUD,
    UC_X86_INS_PMINUW,
    UC_X86_INS_PMOVSXBD,
    UC_X86_INS_PMOVSXBQ,
    UC_X86_INS_PMOVSXBW,
    UC_X86_INS_PMOVSXDQ,
    UC_X86_INS_PMOVSXWD,
    UC_X86_INS_PMOVSXWQ,
    UC_X86_INS_PMOVZXBD,
    UC_X86_INS_PMOVZXBQ,
    UC_X86_INS_PMOVZXBW,
    UC_X86_INS_PMOVZXDQ,
    UC_X86_INS_PMOVZXWD,
    UC_X86_INS_PMOVZXWQ,
    UC_X86_INS_PMULDQ,
    UC_X86_INS_PMULHRW,
    UC_X86_INS_PMULLD,
    UC_X86_INS_POP,
    UC_X86_INS_POPAW,
    UC_X86_INS_POPAL,
    UC_X86_INS_POPCNT,
    UC_X86_INS_POPF,
    UC_X86_INS_POPFD,
    UC_X86_INS_POPFQ,
    UC_X86_INS_PREFETCH,
    UC_X86_INS_PREFETCHNTA,
    UC_X86_INS_PREFETCHT0,
    UC_X86_INS_PREFETCHT1,
    UC_X86_INS_PREFETCHT2,
    UC_X86_INS_PREFETCHW,
    UC_X86_INS_PSHUFD,
    UC_X86_INS_PSHUFHW,
    UC_X86_INS_PSHUFLW,
    UC_X86_INS_PSLLDQ,
    UC_X86_INS_PSRLDQ,
    UC_X86_INS_PSWAPD,
    UC_X86_INS_PTEST,
    UC_X86_INS_PUNPCKHQDQ,
    UC_X86_INS_PUNPCKLQDQ,
    UC_X86_INS_PUSH,
    UC_X86_INS_PUSHAW,
    UC_X86_INS_PUSHAL,
    UC_X86_INS_PUSHF,
    UC_X86_INS_PUSHFD,
    UC_X86_INS_PUSHFQ,
    UC_X86_INS_RCL,
    UC_X86_INS_RCPPS,
    UC_X86_INS_RCPSS,
    UC_X86_INS_RCR,
    UC_X86_INS_RDFSBASE,
    UC_X86_INS_RDGSBASE,
    UC_X86_INS_RDMSR,
    UC_X86_INS_RDPMC,
    UC_X86_INS_RDRAND,
    UC_X86_INS_RDSEED,
    UC_X86_INS_RDTSC,
    UC_X86_INS_RDTSCP,
    UC_X86_INS_ROL,
    UC_X86_INS_ROR,
    UC_X86_INS_RORX,
    UC_X86_INS_ROUNDPD,
    UC_X86_INS_ROUNDPS,
    UC_X86_INS_ROUNDSD,
    UC_X86_INS_ROUNDSS,
    UC_X86_INS_RSM,
    UC_X86_INS_RSQRTPS,
    UC_X86_INS_RSQRTSS,
    UC_X86_INS_SAHF,
    UC_X86_INS_SAL,
    UC_X86_INS_SALC,
    UC_X86_INS_SAR,
    UC_X86_INS_SARX,
    UC_X86_INS_SBB,
    UC_X86_INS_SCASB,
    UC_X86_INS_SCASD,
    UC_X86_INS_SCASQ,
    UC_X86_INS_SCASW,
    UC_X86_INS_SETAE,
    UC_X86_INS_SETA,
    UC_X86_INS_SETBE,
    UC_X86_INS_SETB,
    UC_X86_INS_SETE,
    UC_X86_INS_SETGE,
    UC_X86_INS_SETG,
    UC_X86_INS_SETLE,
    UC_X86_INS_SETL,
    UC_X86_INS_SETNE,
    UC_X86_INS_SETNO,
    UC_X86_INS_SETNP,
    UC_X86_INS_SETNS,
    UC_X86_INS_SETO,
    UC_X86_INS_SETP,
    UC_X86_INS_SETS,
    UC_X86_INS_SFENCE,
    UC_X86_INS_SGDT,
    UC_X86_INS_SHA1MSG1,
    UC_X86_INS_SHA1MSG2,
    UC_X86_INS_SHA1NEXTE,
    UC_X86_INS_SHA1RNDS4,
    UC_X86_INS_SHA256MSG1,
    UC_X86_INS_SHA256MSG2,
    UC_X86_INS_SHA256RNDS2,
    UC_X86_INS_SHL,
    UC_X86_INS_SHLD,
    UC_X86_INS_SHLX,
    UC_X86_INS_SHR,
    UC_X86_INS_SHRD,
    UC_X86_INS_SHRX,
    UC_X86_INS_SHUFPD,
    UC_X86_INS_SHUFPS,
    UC_X86_INS_SIDT,
    UC_X86_INS_FSIN,
    UC_X86_INS_SKINIT,
    UC_X86_INS_SLDT,
    UC_X86_INS_SMSW,
    UC_X86_INS_SQRTPD,
    UC_X86_INS_SQRTPS,
    UC_X86_INS_SQRTSD,
    UC_X86_INS_SQRTSS,
    UC_X86_INS_FSQRT,
    UC_X86_INS_STAC,
    UC_X86_INS_STC,
    UC_X86_INS_STD,
    UC_X86_INS_STGI,
    UC_X86_INS_STI,
    UC_X86_INS_STMXCSR,
    UC_X86_INS_STOSB,
    UC_X86_INS_STOSD,
    UC_X86_INS_STOSQ,
    UC_X86_INS_STOSW,
    UC_X86_INS_STR,
    UC_X86_INS_FST,
    UC_X86_INS_FSTP,
    UC_X86_INS_FSTPNCE,
    UC_X86_INS_FXCH,
    UC_X86_INS_SUBPD,
    UC_X86_INS_SUBPS,
    UC_X86_INS_FSUBR,
    UC_X86_INS_FISUBR,
    UC_X86_INS_FSUBRP,
    UC_X86_INS_SUBSD,
    UC_X86_INS_SUBSS,
    UC_X86_INS_FSUB,
    UC_X86_INS_FISUB,
    UC_X86_INS_FSUBP,
    UC_X86_INS_SWAPGS,
    UC_X86_INS_SYSCALL,
    UC_X86_INS_SYSENTER,
    UC_X86_INS_SYSEXIT,
    UC_X86_INS_SYSRET,
    UC_X86_INS_T1MSKC,
    UC_X86_INS_TEST,
    UC_X86_INS_UD2,
    UC_X86_INS_FTST,
    UC_X86_INS_TZCNT,
    UC_X86_INS_TZMSK,
    UC_X86_INS_FUCOMPI,
    UC_X86_INS_FUCOMI,
    UC_X86_INS_FUCOMPP,
    UC_X86_INS_FUCOMP,
    UC_X86_INS_FUCOM,
    UC_X86_INS_UD2B,
    UC_X86_INS_UNPCKHPD,
    UC_X86_INS_UNPCKHPS,
    UC_X86_INS_UNPCKLPD,
    UC_X86_INS_UNPCKLPS,
    UC_X86_INS_VADDPD,
    UC_X86_INS_VADDPS,
    UC_X86_INS_VADDSD,
    UC_X86_INS_VADDSS,
    UC_X86_INS_VADDSUBPD,
    UC_X86_INS_VADDSUBPS,
    UC_X86_INS_VAESDECLAST,
    UC_X86_INS_VAESDEC,
    UC_X86_INS_VAESENCLAST,
    UC_X86_INS_VAESENC,
    UC_X86_INS_VAESIMC,
    UC_X86_INS_VAESKEYGENASSIST,
    UC_X86_INS_VALIGND,
    UC_X86_INS_VALIGNQ,
    UC_X86_INS_VANDNPD,
    UC_X86_INS_VANDNPS,
    UC_X86_INS_VANDPD,
    UC_X86_INS_VANDPS,
    UC_X86_INS_VBLENDMPD,
    UC_X86_INS_VBLENDMPS,
    UC_X86_INS_VBLENDPD,
    UC_X86_INS_VBLENDPS,
    UC_X86_INS_VBLENDVPD,
    UC_X86_INS_VBLENDVPS,
    UC_X86_INS_VBROADCASTF128,
    UC_X86_INS_VBROADCASTI32X4,
    UC_X86_INS_VBROADCASTI64X4,
    UC_X86_INS_VBROADCASTSD,
    UC_X86_INS_VBROADCASTSS,
    UC_X86_INS_VCMPPD,
    UC_X86_INS_VCMPPS,
    UC_X86_INS_VCMPSD,
    UC_X86_INS_VCMPSS,
    UC_X86_INS_VCOMPRESSPD,
    UC_X86_INS_VCOMPRESSPS,
    UC_X86_INS_VCVTDQ2PD,
    UC_X86_INS_VCVTDQ2PS,
    UC_X86_INS_VCVTPD2DQX,
    UC_X86_INS_VCVTPD2DQ,
    UC_X86_INS_VCVTPD2PSX,
    UC_X86_INS_VCVTPD2PS,
    UC_X86_INS_VCVTPD2UDQ,
    UC_X86_INS_VCVTPH2PS,
    UC_X86_INS_VCVTPS2DQ,
    UC_X86_INS_VCVTPS2PD,
    UC_X86_INS_VCVTPS2PH,
    UC_X86_INS_VCVTPS2UDQ,
    UC_X86_INS_VCVTSD2SI,
    UC_X86_INS_VCVTSD2USI,
    UC_X86_INS_VCVTSS2SI,
    UC_X86_INS_VCVTSS2USI,
    UC_X86_INS_VCVTTPD2DQX,
    UC_X86_INS_VCVTTPD2DQ,
    UC_X86_INS_VCVTTPD2UDQ,
    UC_X86_INS_VCVTTPS2DQ,
    UC_X86_INS_VCVTTPS2UDQ,
    UC_X86_INS_VCVTUDQ2PD,
    UC_X86_INS_VCVTUDQ2PS,
    UC_X86_INS_VDIVPD,
    UC_X86_INS_VDIVPS,
    UC_X86_INS_VDIVSD,
    UC_X86_INS_VDIVSS,
    UC_X86_INS_VDPPD,
    UC_X86_INS_VDPPS,
    UC_X86_INS_VERR,
    UC_X86_INS_VERW,
    UC_X86_INS_VEXP2PD,
    UC_X86_INS_VEXP2PS,
    UC_X86_INS_VEXPANDPD,
    UC_X86_INS_VEXPANDPS,
    UC_X86_INS_VEXTRACTF128,
    UC_X86_INS_VEXTRACTF32X4,
    UC_X86_INS_VEXTRACTF64X4,
    UC_X86_INS_VEXTRACTI128,
    UC_X86_INS_VEXTRACTI32X4,
    UC_X86_INS_VEXTRACTI64X4,
    UC_X86_INS_VEXTRACTPS,
    UC_X86_INS_VFMADD132PD,
    UC_X86_INS_VFMADD132PS,
    UC_X86_INS_VFMADDPD,
    UC_X86_INS_VFMADD213PD,
    UC_X86_INS_VFMADD231PD,
    UC_X86_INS_VFMADDPS,
    UC_X86_INS_VFMADD213PS,
    UC_X86_INS_VFMADD231PS,
    UC_X86_INS_VFMADDSD,
    UC_X86_INS_VFMADD213SD,
    UC_X86_INS_VFMADD132SD,
    UC_X86_INS_VFMADD231SD,
    UC_X86_INS_VFMADDSS,
    UC_X86_INS_VFMADD213SS,
    UC_X86_INS_VFMADD132SS,
    UC_X86_INS_VFMADD231SS,
    UC_X86_INS_VFMADDSUB132PD,
    UC_X86_INS_VFMADDSUB132PS,
    UC_X86_INS_VFMADDSUBPD,
    UC_X86_INS_VFMADDSUB213PD,
    UC_X86_INS_VFMADDSUB231PD,
    UC_X86_INS_VFMADDSUBPS,
    UC_X86_INS_VFMADDSUB213PS,
    UC_X86_INS_VFMADDSUB231PS,
    UC_X86_INS_VFMSUB132PD,
    UC_X86_INS_VFMSUB132PS,
    UC_X86_INS_VFMSUBADD132PD,
    UC_X86_INS_VFMSUBADD132PS,
    UC_X86_INS_VFMSUBADDPD,
    UC_X86_INS_VFMSUBADD213PD,
    UC_X86_INS_VFMSUBADD231PD,
    UC_X86_INS_VFMSUBADDPS,
    UC_X86_INS_VFMSUBADD213PS,
    UC_X86_INS_VFMSUBADD231PS,
    UC_X86_INS_VFMSUBPD,
    UC_X86_INS_VFMSUB213PD,
    UC_X86_INS_VFMSUB231PD,
    UC_X86_INS_VFMSUBPS,
    UC_X86_INS_VFMSUB213PS,
    UC_X86_INS_VFMSUB231PS,
    UC_X86_INS_VFMSUBSD,
    UC_X86_INS_VFMSUB213SD,
    UC_X86_INS_VFMSUB132SD,
    UC_X86_INS_VFMSUB231SD,
    UC_X86_INS_VFMSUBSS,
    UC_X86_INS_VFMSUB213SS,
    UC_X86_INS_VFMSUB132SS,
    UC_X86_INS_VFMSUB231SS,
    UC_X86_INS_VFNMADD132PD,
    UC_X86_INS_VFNMADD132PS,
    UC_X86_INS_VFNMADDPD,
    UC_X86_INS_VFNMADD213PD,
    UC_X86_INS_VFNMADD231PD,
    UC_X86_INS_VFNMADDPS,
    UC_X86_INS_VFNMADD213PS,
    UC_X86_INS_VFNMADD231PS,
    UC_X86_INS_VFNMADDSD,
    UC_X86_INS_VFNMADD213SD,
    UC_X86_INS_VFNMADD132SD,
    UC_X86_INS_VFNMADD231SD,
    UC_X86_INS_VFNMADDSS,
    UC_X86_INS_VFNMADD213SS,
    UC_X86_INS_VFNMADD132SS,
    UC_X86_INS_VFNMADD231SS,
    UC_X86_INS_VFNMSUB132PD,
    UC_X86_INS_VFNMSUB132PS,
    UC_X86_INS_VFNMSUBPD,
    UC_X86_INS_VFNMSUB213PD,
    UC_X86_INS_VFNMSUB231PD,
    UC_X86_INS_VFNMSUBPS,
    UC_X86_INS_VFNMSUB213PS,
    UC_X86_INS_VFNMSUB231PS,
    UC_X86_INS_VFNMSUBSD,
    UC_X86_INS_VFNMSUB213SD,
    UC_X86_INS_VFNMSUB132SD,
    UC_X86_INS_VFNMSUB231SD,
    UC_X86_INS_VFNMSUBSS,
    UC_X86_INS_VFNMSUB213SS,
    UC_X86_INS_VFNMSUB132SS,
    UC_X86_INS_VFNMSUB231SS,
    UC_X86_INS_VFRCZPD,
    UC_X86_INS_VFRCZPS,
    UC_X86_INS_VFRCZSD,
    UC_X86_INS_VFRCZSS,
    UC_X86_INS_VORPD,
    UC_X86_INS_VORPS,
    UC_X86_INS_VXORPD,
    UC_X86_INS_VXORPS,
    UC_X86_INS_VGATHERDPD,
    UC_X86_INS_VGATHERDPS,
    UC_X86_INS_VGATHERPF0DPD,
    UC_X86_INS_VGATHERPF0DPS,
    UC_X86_INS_VGATHERPF0QPD,
    UC_X86_INS_VGATHERPF0QPS,
    UC_X86_INS_VGATHERPF1DPD,
    UC_X86_INS_VGATHERPF1DPS,
    UC_X86_INS_VGATHERPF1QPD,
    UC_X86_INS_VGATHERPF1QPS,
    UC_X86_INS_VGATHERQPD,
    UC_X86_INS_VGATHERQPS,
    UC_X86_INS_VHADDPD,
    UC_X86_INS_VHADDPS,
    UC_X86_INS_VHSUBPD,
    UC_X86_INS_VHSUBPS,
    UC_X86_INS_VINSERTF128,
    UC_X86_INS_VINSERTF32X4,
    UC_X86_INS_VINSERTF32X8,
    UC_X86_INS_VINSERTF64X2,
    UC_X86_INS_VINSERTF64X4,
    UC_X86_INS_VINSERTI128,
    UC_X86_INS_VINSERTI32X4,
    UC_X86_INS_VINSERTI32X8,
    UC_X86_INS_VINSERTI64X2,
    UC_X86_INS_VINSERTI64X4,
    UC_X86_INS_VINSERTPS,
    UC_X86_INS_VLDDQU,
    UC_X86_INS_VLDMXCSR,
    UC_X86_INS_VMASKMOVDQU,
    UC_X86_INS_VMASKMOVPD,
    UC_X86_INS_VMASKMOVPS,
    UC_X86_INS_VMAXPD,
    UC_X86_INS_VMAXPS,
    UC_X86_INS_VMAXSD,
    UC_X86_INS_VMAXSS,
    UC_X86_INS_VMCALL,
    UC_X86_INS_VMCLEAR,
    UC_X86_INS_VMFUNC,
    UC_X86_INS_VMINPD,
    UC_X86_INS_VMINPS,
    UC_X86_INS_VMINSD,
    UC_X86_INS_VMINSS,
    UC_X86_INS_VMLAUNCH,
    UC_X86_INS_VMLOAD,
    UC_X86_INS_VMMCALL,
    UC_X86_INS_VMOVQ,
    UC_X86_INS_VMOVDDUP,
    UC_X86_INS_VMOVD,
    UC_X86_INS_VMOVDQA32,
    UC_X86_INS_VMOVDQA64,
    UC_X86_INS_VMOVDQA,
    UC_X86_INS_VMOVDQU16,
    UC_X86_INS_VMOVDQU32,
    UC_X86_INS_VMOVDQU64,
    UC_X86_INS_VMOVDQU8,
    UC_X86_INS_VMOVDQU,
    UC_X86_INS_VMOVHLPS,
    UC_X86_INS_VMOVHPD,
    UC_X86_INS_VMOVHPS,
    UC_X86_INS_VMOVLHPS,
    UC_X86_INS_VMOVLPD,
    UC_X86_INS_VMOVLPS,
    UC_X86_INS_VMOVMSKPD,
    UC_X86_INS_VMOVMSKPS,
    UC_X86_INS_VMOVNTDQA,
    UC_X86_INS_VMOVNTDQ,
    UC_X86_INS_VMOVNTPD,
    UC_X86_INS_VMOVNTPS,
    UC_X86_INS_VMOVSD,
    UC_X86_INS_VMOVSHDUP,
    UC_X86_INS_VMOVSLDUP,
    UC_X86_INS_VMOVSS,
    UC_X86_INS_VMOVUPD,
    UC_X86_INS_VMOVUPS,
    UC_X86_INS_VMPSADBW,
    UC_X86_INS_VMPTRLD,
    UC_X86_INS_VMPTRST,
    UC_X86_INS_VMREAD,
    UC_X86_INS_VMRESUME,
    UC_X86_INS_VMRUN,
    UC_X86_INS_VMSAVE,
    UC_X86_INS_VMULPD,
    UC_X86_INS_VMULPS,
    UC_X86_INS_VMULSD,
    UC_X86_INS_VMULSS,
    UC_X86_INS_VMWRITE,
    UC_X86_INS_VMXOFF,
    UC_X86_INS_VMXON,
    UC_X86_INS_VPABSB,
    UC_X86_INS_VPABSD,
    UC_X86_INS_VPABSQ,
    UC_X86_INS_VPABSW,
    UC_X86_INS_VPACKSSDW,
    UC_X86_INS_VPACKSSWB,
    UC_X86_INS_VPACKUSDW,
    UC_X86_INS_VPACKUSWB,
    UC_X86_INS_VPADDB,
    UC_X86_INS_VPADDD,
    UC_X86_INS_VPADDQ,
    UC_X86_INS_VPADDSB,
    UC_X86_INS_VPADDSW,
    UC_X86_INS_VPADDUSB,
    UC_X86_INS_VPADDUSW,
    UC_X86_INS_VPADDW,
    UC_X86_INS_VPALIGNR,
    UC_X86_INS_VPANDD,
    UC_X86_INS_VPANDND,
    UC_X86_INS_VPANDNQ,
    UC_X86_INS_VPANDN,
    UC_X86_INS_VPANDQ,
    UC_X86_INS_VPAND,
    UC_X86_INS_VPAVGB,
    UC_X86_INS_VPAVGW,
    UC_X86_INS_VPBLENDD,
    UC_X86_INS_VPBLENDMB,
    UC_X86_INS_VPBLENDMD,
    UC_X86_INS_VPBLENDMQ,
    UC_X86_INS_VPBLENDMW,
    UC_X86_INS_VPBLENDVB,
    UC_X86_INS_VPBLENDW,
    UC_X86_INS_VPBROADCASTB,
    UC_X86_INS_VPBROADCASTD,
    UC_X86_INS_VPBROADCASTMB2Q,
    UC_X86_INS_VPBROADCASTMW2D,
    UC_X86_INS_VPBROADCASTQ,
    UC_X86_INS_VPBROADCASTW,
    UC_X86_INS_VPCLMULQDQ,
    UC_X86_INS_VPCMOV,
    UC_X86_INS_VPCMPB,
    UC_X86_INS_VPCMPD,
    UC_X86_INS_VPCMPEQB,
    UC_X86_INS_VPCMPEQD,
    UC_X86_INS_VPCMPEQQ,
    UC_X86_INS_VPCMPEQW,
    UC_X86_INS_VPCMPESTRI,
    UC_X86_INS_VPCMPESTRM,
    UC_X86_INS_VPCMPGTB,
    UC_X86_INS_VPCMPGTD,
    UC_X86_INS_VPCMPGTQ,
    UC_X86_INS_VPCMPGTW,
    UC_X86_INS_VPCMPISTRI,
    UC_X86_INS_VPCMPISTRM,
    UC_X86_INS_VPCMPQ,
    UC_X86_INS_VPCMPUB,
    UC_X86_INS_VPCMPUD,
    UC_X86_INS_VPCMPUQ,
    UC_X86_INS_VPCMPUW,
    UC_X86_INS_VPCMPW,
    UC_X86_INS_VPCOMB,
    UC_X86_INS_VPCOMD,
    UC_X86_INS_VPCOMPRESSD,
    UC_X86_INS_VPCOMPRESSQ,
    UC_X86_INS_VPCOMQ,
    UC_X86_INS_VPCOMUB,
    UC_X86_INS_VPCOMUD,
    UC_X86_INS_VPCOMUQ,
    UC_X86_INS_VPCOMUW,
    UC_X86_INS_VPCOMW,
    UC_X86_INS_VPCONFLICTD,
    UC_X86_INS_VPCONFLICTQ,
    UC_X86_INS_VPERM2F128,
    UC_X86_INS_VPERM2I128,
    UC_X86_INS_VPERMD,
    UC_X86_INS_VPERMI2D,
    UC_X86_INS_VPERMI2PD,
    UC_X86_INS_VPERMI2PS,
    UC_X86_INS_VPERMI2Q,
    UC_X86_INS_VPERMIL2PD,
    UC_X86_INS_VPERMIL2PS,
    UC_X86_INS_VPERMILPD,
    UC_X86_INS_VPERMILPS,
    UC_X86_INS_VPERMPD,
    UC_X86_INS_VPERMPS,
    UC_X86_INS_VPERMQ,
    UC_X86_INS_VPERMT2D,
    UC_X86_INS_VPERMT2PD,
    UC_X86_INS_VPERMT2PS,
    UC_X86_INS_VPERMT2Q,
    UC_X86_INS_VPEXPANDD,
    UC_X86_INS_VPEXPANDQ,
    UC_X86_INS_VPEXTRB,
    UC_X86_INS_VPEXTRD,
    UC_X86_INS_VPEXTRQ,
    UC_X86_INS_VPEXTRW,
    UC_X86_INS_VPGATHERDD,
    UC_X86_INS_VPGATHERDQ,
    UC_X86_INS_VPGATHERQD,
    UC_X86_INS_VPGATHERQQ,
    UC_X86_INS_VPHADDBD,
    UC_X86_INS_VPHADDBQ,
    UC_X86_INS_VPHADDBW,
    UC_X86_INS_VPHADDDQ,
    UC_X86_INS_VPHADDD,
    UC_X86_INS_VPHADDSW,
    UC_X86_INS_VPHADDUBD,
    UC_X86_INS_VPHADDUBQ,
    UC_X86_INS_VPHADDUBW,
    UC_X86_INS_VPHADDUDQ,
    UC_X86_INS_VPHADDUWD,
    UC_X86_INS_VPHADDUWQ,
    UC_X86_INS_VPHADDWD,
    UC_X86_INS_VPHADDWQ,
    UC_X86_INS_VPHADDW,
    UC_X86_INS_VPHMINPOSUW,
    UC_X86_INS_VPHSUBBW,
    UC_X86_INS_VPHSUBDQ,
    UC_X86_INS_VPHSUBD,
    UC_X86_INS_VPHSUBSW,
    UC_X86_INS_VPHSUBWD,
    UC_X86_INS_VPHSUBW,
    UC_X86_INS_VPINSRB,
    UC_X86_INS_VPINSRD,
    UC_X86_INS_VPINSRQ,
    UC_X86_INS_VPINSRW,
    UC_X86_INS_VPLZCNTD,
    UC_X86_INS_VPLZCNTQ,
    UC_X86_INS_VPMACSDD,
    UC_X86_INS_VPMACSDQH,
    UC_X86_INS_VPMACSDQL,
    UC_X86_INS_VPMACSSDD,
    UC_X86_INS_VPMACSSDQH,
    UC_X86_INS_VPMACSSDQL,
    UC_X86_INS_VPMACSSWD,
    UC_X86_INS_VPMACSSWW,
    UC_X86_INS_VPMACSWD,
    UC_X86_INS_VPMACSWW,
    UC_X86_INS_VPMADCSSWD,
    UC_X86_INS_VPMADCSWD,
    UC_X86_INS_VPMADDUBSW,
    UC_X86_INS_VPMADDWD,
    UC_X86_INS_VPMASKMOVD,
    UC_X86_INS_VPMASKMOVQ,
    UC_X86_INS_VPMAXSB,
    UC_X86_INS_VPMAXSD,
    UC_X86_INS_VPMAXSQ,
    UC_X86_INS_VPMAXSW,
    UC_X86_INS_VPMAXUB,
    UC_X86_INS_VPMAXUD,
    UC_X86_INS_VPMAXUQ,
    UC_X86_INS_VPMAXUW,
    UC_X86_INS_VPMINSB,
    UC_X86_INS_VPMINSD,
    UC_X86_INS_VPMINSQ,
    UC_X86_INS_VPMINSW,
    UC_X86_INS_VPMINUB,
    UC_X86_INS_VPMINUD,
    UC_X86_INS_VPMINUQ,
    UC_X86_INS_VPMINUW,
    UC_X86_INS_VPMOVDB,
    UC_X86_INS_VPMOVDW,
    UC_X86_INS_VPMOVM2B,
    UC_X86_INS_VPMOVM2D,
    UC_X86_INS_VPMOVM2Q,
    UC_X86_INS_VPMOVM2W,
    UC_X86_INS_VPMOVMSKB,
    UC_X86_INS_VPMOVQB,
    UC_X86_INS_VPMOVQD,
    UC_X86_INS_VPMOVQW,
    UC_X86_INS_VPMOVSDB,
    UC_X86_INS_VPMOVSDW,
    UC_X86_INS_VPMOVSQB,
    UC_X86_INS_VPMOVSQD,
    UC_X86_INS_VPMOVSQW,
    UC_X86_INS_VPMOVSXBD,
    UC_X86_INS_VPMOVSXBQ,
    UC_X86_INS_VPMOVSXBW,
    UC_X86_INS_VPMOVSXDQ,
    UC_X86_INS_VPMOVSXWD,
    UC_X86_INS_VPMOVSXWQ,
    UC_X86_INS_VPMOVUSDB,
    UC_X86_INS_VPMOVUSDW,
    UC_X86_INS_VPMOVUSQB,
    UC_X86_INS_VPMOVUSQD,
    UC_X86_INS_VPMOVUSQW,
    UC_X86_INS_VPMOVZXBD,
    UC_X86_INS_VPMOVZXBQ,
    UC_X86_INS_VPMOVZXBW,
    UC_X86_INS_VPMOVZXDQ,
    UC_X86_INS_VPMOVZXWD,
    UC_X86_INS_VPMOVZXWQ,
    UC_X86_INS_VPMULDQ,
    UC_X86_INS_VPMULHRSW,
    UC_X86_INS_VPMULHUW,
    UC_X86_INS_VPMULHW,
    UC_X86_INS_VPMULLD,
    UC_X86_INS_VPMULLQ,
    UC_X86_INS_VPMULLW,
    UC_X86_INS_VPMULUDQ,
    UC_X86_INS_VPORD,
    UC_X86_INS_VPORQ,
    UC_X86_INS_VPOR,
    UC_X86_INS_VPPERM,
    UC_X86_INS_VPROTB,
    UC_X86_INS_VPROTD,
    UC_X86_INS_VPROTQ,
    UC_X86_INS_VPROTW,
    UC_X86_INS_VPSADBW,
    UC_X86_INS_VPSCATTERDD,
    UC_X86_INS_VPSCATTERDQ,
    UC_X86_INS_VPSCATTERQD,
    UC_X86_INS_VPSCATTERQQ,
    UC_X86_INS_VPSHAB,
    UC_X86_INS_VPSHAD,
    UC_X86_INS_VPSHAQ,
    UC_X86_INS_VPSHAW,
    UC_X86_INS_VPSHLB,
    UC_X86_INS_VPSHLD,
    UC_X86_INS_VPSHLQ,
    UC_X86_INS_VPSHLW,
    UC_X86_INS_VPSHUFB,
    UC_X86_INS_VPSHUFD,
    UC_X86_INS_VPSHUFHW,
    UC_X86_INS_VPSHUFLW,
    UC_X86_INS_VPSIGNB,
    UC_X86_INS_VPSIGND,
    UC_X86_INS_VPSIGNW,
    UC_X86_INS_VPSLLDQ,
    UC_X86_INS_VPSLLD,
    UC_X86_INS_VPSLLQ,
    UC_X86_INS_VPSLLVD,
    UC_X86_INS_VPSLLVQ,
    UC_X86_INS_VPSLLW,
    UC_X86_INS_VPSRAD,
    UC_X86_INS_VPSRAQ,
    UC_X86_INS_VPSRAVD,
    UC_X86_INS_VPSRAVQ,
    UC_X86_INS_VPSRAW,
    UC_X86_INS_VPSRLDQ,
    UC_X86_INS_VPSRLD,
    UC_X86_INS_VPSRLQ,
    UC_X86_INS_VPSRLVD,
    UC_X86_INS_VPSRLVQ,
    UC_X86_INS_VPSRLW,
    UC_X86_INS_VPSUBB,
    UC_X86_INS_VPSUBD,
    UC_X86_INS_VPSUBQ,
    UC_X86_INS_VPSUBSB,
    UC_X86_INS_VPSUBSW,
    UC_X86_INS_VPSUBUSB,
    UC_X86_INS_VPSUBUSW,
    UC_X86_INS_VPSUBW,
    UC_X86_INS_VPTESTMD,
    UC_X86_INS_VPTESTMQ,
    UC_X86_INS_VPTESTNMD,
    UC_X86_INS_VPTESTNMQ,
    UC_X86_INS_VPTEST,
    UC_X86_INS_VPUNPCKHBW,
    UC_X86_INS_VPUNPCKHDQ,
    UC_X86_INS_VPUNPCKHQDQ,
    UC_X86_INS_VPUNPCKHWD,
    UC_X86_INS_VPUNPCKLBW,
    UC_X86_INS_VPUNPCKLDQ,
    UC_X86_INS_VPUNPCKLQDQ,
    UC_X86_INS_VPUNPCKLWD,
    UC_X86_INS_VPXORD,
    UC_X86_INS_VPXORQ,
    UC_X86_INS_VPXOR,
    UC_X86_INS_VRCP14PD,
    UC_X86_INS_VRCP14PS,
    UC_X86_INS_VRCP14SD,
    UC_X86_INS_VRCP14SS,
    UC_X86_INS_VRCP28PD,
    UC_X86_INS_VRCP28PS,
    UC_X86_INS_VRCP28SD,
    UC_X86_INS_VRCP28SS,
    UC_X86_INS_VRCPPS,
    UC_X86_INS_VRCPSS,
    UC_X86_INS_VRNDSCALEPD,
    UC_X86_INS_VRNDSCALEPS,
    UC_X86_INS_VRNDSCALESD,
    UC_X86_INS_VRNDSCALESS,
    UC_X86_INS_VROUNDPD,
    UC_X86_INS_VROUNDPS,
    UC_X86_INS_VROUNDSD,
    UC_X86_INS_VROUNDSS,
    UC_X86_INS_VRSQRT14PD,
    UC_X86_INS_VRSQRT14PS,
    UC_X86_INS_VRSQRT14SD,
    UC_X86_INS_VRSQRT14SS,
    UC_X86_INS_VRSQRT28PD,
    UC_X86_INS_VRSQRT28PS,
    UC_X86_INS_VRSQRT28SD,
    UC_X86_INS_VRSQRT28SS,
    UC_X86_INS_VRSQRTPS,
    UC_X86_INS_VRSQRTSS,
    UC_X86_INS_VSCATTERDPD,
    UC_X86_INS_VSCATTERDPS,
    UC_X86_INS_VSCATTERPF0DPD,
    UC_X86_INS_VSCATTERPF0DPS,
    UC_X86_INS_VSCATTERPF0QPD,
    UC_X86_INS_VSCATTERPF0QPS,
    UC_X86_INS_VSCATTERPF1DPD,
    UC_X86_INS_VSCATTERPF1DPS,
    UC_X86_INS_VSCATTERPF1QPD,
    UC_X86_INS_VSCATTERPF1QPS,
    UC_X86_INS_VSCATTERQPD,
    UC_X86_INS_VSCATTERQPS,
    UC_X86_INS_VSHUFPD,
    UC_X86_INS_VSHUFPS,
    UC_X86_INS_VSQRTPD,
    UC_X86_INS_VSQRTPS,
    UC_X86_INS_VSQRTSD,
    UC_X86_INS_VSQRTSS,
    UC_X86_INS_VSTMXCSR,
    UC_X86_INS_VSUBPD,
    UC_X86_INS_VSUBPS,
    UC_X86_INS_VSUBSD,
    UC_X86_INS_VSUBSS,
    UC_X86_INS_VTESTPD,
    UC_X86_INS_VTESTPS,
    UC_X86_INS_VUNPCKHPD,
    UC_X86_INS_VUNPCKHPS,
    UC_X86_INS_VUNPCKLPD,
    UC_X86_INS_VUNPCKLPS,
    UC_X86_INS_VZEROALL,
    UC_X86_INS_VZEROUPPER,
    UC_X86_INS_WAIT,
    UC_X86_INS_WBINVD,
    UC_X86_INS_WRFSBASE,
    UC_X86_INS_WRGSBASE,
    UC_X86_INS_WRMSR,
    UC_X86_INS_XABORT,
    UC_X86_INS_XACQUIRE,
    UC_X86_INS_XBEGIN,
    UC_X86_INS_XCHG,
    UC_X86_INS_XCRYPTCBC,
    UC_X86_INS_XCRYPTCFB,
    UC_X86_INS_XCRYPTCTR,
    UC_X86_INS_XCRYPTECB,
    UC_X86_INS_XCRYPTOFB,
    UC_X86_INS_XEND,
    UC_X86_INS_XGETBV,
    UC_X86_INS_XLATB,
    UC_X86_INS_XRELEASE,
    UC_X86_INS_XRSTOR,
    UC_X86_INS_XRSTOR64,
    UC_X86_INS_XRSTORS,
    UC_X86_INS_XRSTORS64,
    UC_X86_INS_XSAVE,
    UC_X86_INS_XSAVE64,
    UC_X86_INS_XSAVEC,
    UC_X86_INS_XSAVEC64,
    UC_X86_INS_XSAVEOPT,
    UC_X86_INS_XSAVEOPT64,
    UC_X86_INS_XSAVES,
    UC_X86_INS_XSAVES64,
    UC_X86_INS_XSETBV,
    UC_X86_INS_XSHA1,
    UC_X86_INS_XSHA256,
    UC_X86_INS_XSTORE,
    UC_X86_INS_XTEST,
    UC_X86_INS_FDISI8087_NOP,
    UC_X86_INS_FENI8087_NOP,

    UC_X86_INS_ENDING, // mark the end of the list of insn
} uc_x86_insn;

#ifdef __cplusplus
}
#endif

#endif

```

`README.md`:

```md
# KDemu

A hybrid semi-emulated, semi-native Windows kernel driver emulator designed for advanced rootkit and anti-cheat analysis, addressing the limitations of existing emulation solutions.

## Conference
This project have been accept by CODEBLUE 2025

[Bypassing Anti-Debugging: A Hybrid Real-Simulated Approach to Rootkit Analysis
]("https://codeblue.jp/en/program/time-table/day2-t2-01/)

## Architecture

KDemu's hybrid architecture consists of:

- **Emulation Engine** (`Emulate.cpp/hpp`): kernel API implementations with intelligent hook management
- **PE Loader** (`LoadPE.cpp/hpp`): Advanced PE parsing with kernel dump integration and driver overwriting
- **Kernel Dump Manager**: Real-time kernel memory dump analysis and parameter extraction
- **SEH Handler**: Native Windows exception handling using InvertedFunctionTableList
- **Multithreading Engine**: Parallel execution with memory locking and context management
- **Anti-Detection Layer**: MSR handling, hypervisor evasion, and detection countermeasures
- **Monitoring System**: Object access tracking and register operation logging

## Installation

1. **Clone the repository**:
   ```bash
   git clone <repository-url>
   cd KDemu
   ```

2. **Install dependencies via vcpkg**:
   ```bash
   vcpkg install unicorn capstone
   ```

3. **Build the project**:
   - Open `KDemu.sln` in Visual Studio
   - Select Release configuration (x64)
   - Build the solution

4. **Download Memory Dump**:
   https://drive.google.com/file/d/1MDZ2s7RLGvypC0FDS6MOYgMglTyU6O9n/view?usp=sharing
   
   Put it into the KDemu folder

## Usage

### Prerequisites Setup

1. **Kernel Memory Dump**: Obtain a Windows kernel memory dump (`mem.dmp`) captured at a driver entry breakpoint
> if you use another kernel dump, you have to change some of the parmenter like some of base addr..register..etc
2. **Target Driver**: Place the driver you want to analyze in the project directory

### Debugging
Enable GDB server support by uncommenting the `gdbServer()` call in `mainThread()`.

## Project Structure

```
KDemu/
├── KDemu/
│   ├── KDemu.cpp           # Main entry point
│   ├── Emulate.cpp/hpp     # API emulation engine
│   ├── LoadPE.cpp/hpp      # PE loader and memory management
│   ├── UnicornEmu.hpp      # Unicorn engine wrapper
│   ├── Global.h            # Common definitions
│   ├── NtType.hpp          # Windows type definitions
│   ├── include/            # Third-party headers
│   └── lib/                # Static libraries
├── vcpkg.json              # Package dependencies
└── KDemu.sln              # Visual Studio solution
```

## Author
ShallowFeather & HeroBurger

## Acknowledgments

### Core Technologies
- [Unicorn Engine](https://www.unicorn-engine.org/) - CPU emulation framework
- [Capstone](https://www.capstone-engine.org/) - Disassembly engine  
- [LIEF](https://lief.quarkslab.com/) - Binary analysis library (contributed bug fix)
- [kdmp-parser](https://github.com/0vercl0k/kdmp-parser) - Kernel dump parsing

### Research References
- [**KACE (Kernel AntiCheat Emulator)**]("https://github.com/waryas/KACE") - Inspiration for user-mode to kernel-mode mapping
- [**What The Fuzz**]("https://github.com/0vercl0k/wtf) - Kernel dump utilization concepts
- **Speakeasy & Qiling** - Object monitoring and API emulation approaches

```

`vcpkg-configuration.json`:

```json
{
  "registries": [
    {
      "kind": "artifact",
      "location": "https://github.com/microsoft/vcpkg-ce-catalog/archive/refs/heads/main.zip",
      "name": "microsoft"
    }
  ]
}

```

`vcpkg.json`:

```json
{
  "dependencies": [
    "unicorn",
    "capstone"
  ],
  "builtin-baseline": "6ecbbbdf31cba47aafa7cf6189b1e73e10ac61f8"
}

```