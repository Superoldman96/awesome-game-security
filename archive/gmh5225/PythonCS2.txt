Project Path: arc_gmh5225_PythonCS2_3lke2ohb

Source Tree:

```txt
arc_gmh5225_PythonCS2_3lke2ohb
├── Cheat
│   ├── Cheat.py
│   ├── Configs.py
│   ├── Main.py
│   ├── RCS.py
│   ├── Utils.py
│   └── gui.py
├── LICENSE
└── README.md

```

`Cheat/Cheat.py`:

```py
import math
import ctypes

import Utils
import Configs as cfg
import RCS

user32 = ctypes.windll.user32
pm = Utils.get_pyMeow()
rq = Utils.get_requests()
rcs = RCS.RCS()

weapon_names = { 
        1: "deagle", 
        2: "elite", 
        3: "fiveseven", 
        4: "glock", 
        7: "ak47", 
        8: "aug", 
        9: "awp", 
        10: "famas", 
        11: "g3Sg1", 
        13: "galilar", 
        14: "m249", 
        17: "mac10", 
        19: "p90", 
        23: "mp5sd", 
        24: "ump45", 
        25: "xm1014", 
        26: "bizon", 
        27: "mag7", 
        28: "negev", 
        29: "sawedoff", 
        30: "tec9", 
        31: "zeus", 
        32: "p2000", 
        33: "mp7", 
        34: "mp9", 
        35: "nova", 
        36: "p250", 
        38: "scar20", 
        39: "sg556", 
        40: "ssg08", 
        42: "ct_knife", 
        43: "flashbang", 
        44: "hegrenade", 
        45: "smokegrenade", 
        46: "molotov", 
        47: "decoy", 
        48: "incgrenade", 
        49: "c4", 
        16: "m4a1", 
        61: "usp", 
        60: "m4a1_silencer", 
        63: "cz75a", 
        64: "revolver", 
        59: "t_knife"
    }

AimKey = 0x01

class Offsets:
    m_pBoneArray = 496


class Colors:
    green = pm.get_color("#00FF00")
    orange = pm.fade_color(pm.get_color("#FFA500"), 0.3)
    black = pm.get_color("black")
    cyan = pm.fade_color(pm.get_color("#00F6F6"), 0.3)
    white = pm.get_color("white")
    grey = pm.fade_color(pm.get_color("#242625"), 0.7)


class Entity:

    def __init__(self, ptr, pawn_ptr, proc):
        self.ptr = ptr
        self.pawn_ptr = pawn_ptr
        self.proc = proc
        self.pos2d = None
        self.head_pos2d = None

    @property
    def name(self):
        return pm.r_string(self.proc, self.ptr + Offsets.m_iszPlayerName)

    @property
    def health(self):
        return pm.r_int(self.proc, self.pawn_ptr + Offsets.m_iHealth)

    @property
    def team(self):
        return pm.r_int(self.proc, self.pawn_ptr + Offsets.m_iTeamNum)

    @property
    def pos(self):
        return pm.r_vec3(self.proc, self.pawn_ptr + Offsets.m_vOldOrigin)
    
    @property
    def dormant(self):
        return pm.r_bool(self.proc, self.pawn_ptr + Offsets.m_bDormant)

    @property
    def weaponIndex(self):
        currentWeapon = pm.r_int64(self.proc, self.pawn_ptr + Offsets.m_pClippingWeapon)
        weaponIndex = pm.r_int(self.proc, currentWeapon + Offsets.m_AttributeManager + Offsets.m_Item + Offsets.m_iItemDefinitionIndex)
        return weaponIndex
    
    def get_weapon_name(self):
        return weapon_names.get(self.weaponIndex, "None")
        
    def get_distance(self, localPos):
        dx = self.pos["x"] - localPos["x"]
        dy = self.pos["y"] - localPos["y"]
        dz = self.pos["z"] - localPos["z"]
        return int(math.sqrt(dx * dx + dy * dy + dz * dz) / 100)

    def bone_pos(self, bone):
        game_scene = pm.r_int64(self.proc, self.pawn_ptr + Offsets.m_pGameSceneNode)
        bone_array_ptr = pm.r_int64(self.proc, game_scene + Offsets.m_pBoneArray)
        return pm.r_vec3(self.proc, bone_array_ptr + bone * 32)
    
    def wts(self, view_matrix):
        try:
            self.pos2d = pm.world_to_screen(view_matrix, self.pos, 1)
            self.head_pos2d = pm.world_to_screen(view_matrix, self.bone_pos(6), 1)
        except:
            return False
        return True

class Render:
    def draw_health(max, current, PosX, PosY, width, height):
        if cfg.ESP.show_health:
            Proportion = current / max
            Height = height * Proportion
            offsetY = height * (max - current) / max

            pm.draw_rectangle(PosX + 1, PosY + 1 + offsetY, width / 2, Height, Colors.green)
            pm.draw_rectangle_lines(PosX, PosY, width, height, Colors.black)

    def draw_box(PosX, PosY, width, height, color, filled_color):
        if cfg.ESP.show_filled_box:
            pm.draw_rectangle(PosX, PosY, width, height, filled_color)
        if cfg.ESP.show_box:
            pm.draw_rectangle_lines(PosX + 1, PosY + 1, width, height, Colors.black, 1.2)   # Shadow
            pm.draw_rectangle_lines(PosX, PosY, width, height, color, 1.2)
    
    def draw_distance(distance, PosX, PosY, Color):
        pm.draw_text(f"{distance}m", PosX + 1, PosY + 1, 15, Colors.black)  # Shadow
        pm.draw_text(f"{distance}m", PosX, PosY, 15, Color)

    def draw_weapon(weaponName, PosX, PosY, Color):
        pm.draw_text(f"{weaponName}", PosX + 1, PosY + 1, 15, Colors.black)  # Shadow
        pm.draw_text(f"{weaponName}", PosX, PosY, 15, Color)

class Aimbot:
    def run(viewAngle, localPos, AimPos, viewMatrix):
        smooth = 3
        AimFov = 5

        CenterX = pm.get_screen_width() / 2
        CenterY = pm.get_screen_height() / 2
        OppPos = pm.vec3_subtract(AimPos, localPos)
        Distance = math.sqrt(math.pow(OppPos["x"], 2) + math.pow(OppPos["y"], 2))
        TargetX: int
        TargetY: int

        Yaw = viewAngle["y"] - CenterY
        Pitch = viewAngle["x"] - CenterX
        Norm = math.sqrt(math.pow(Yaw, 2) + math.pow(Pitch, 2))

        Yaw = Yaw*2 - smooth + viewAngle["y"]
        Pitch = Pitch*2 - smooth + viewAngle["x"]

        ScreenPos = pm.world_to_screen(viewMatrix, AimPos, 1)

        if Norm > AimFov:
            if ScreenPos["x"] > CenterX:
                TargetX = -(CenterX - ScreenPos["x"])
                TargetX /= smooth
                if TargetX + CenterX > CenterX * 2:
                    TargetX = 0
            if ScreenPos["x"] < CenterX:
                TargetX = CenterX - ScreenPos["x"]
                TargetX /= smooth
                if TargetX + CenterX < 0:
                    TargetX = 0

            if ScreenPos["y"] != 0:
                if ScreenPos["y"] > CenterY:
                    TargetY = -(CenterY - ScreenPos["y"])
                    TargetY /= smooth
                    if TargetY + ScreenPos["y"] > CenterY * 2:
                        TargetY = 0
                if ScreenPos["y"] < CenterY:
                    TargetY = ScreenPos["y"] - CenterY
                    TargetY /= smooth
                    if TargetY + ScreenPos["y"] < 0:
                        TargetY = 0
            
            TargetX /= 10
            TargetY /= 10
            if math.fabs(TargetX) < 1:
                if TargetX > 0:
                    TargetX = 1
                if TargetX < 0:
                    TargetX = -1
            if math.fabs(TargetY) < 1:
                if TargetY > 0:
                    TargetY = 1
                if TargetY < 0:
                    TargetY = -1

            pm.mouse_move(int(TargetX), int(TargetY))

class Cheat:
    def __init__(self):
        self.proc = pm.open_process("cs2.exe")
        self.mod = pm.get_module(self.proc, "client.dll")["base"]

        offsets_name = ["dwViewMatrix", "dwEntityList", "dwLocalPlayerController", "dwLocalPlayerPawn"]
        offsets = rq.get("https://raw.githubusercontent.com/a2x/cs2-dumper/main/output/offsets.json").json()
        [setattr(Offsets, k, offsets["client.dll"][k]) for k in offsets_name]
        client_dll_name = {
            "m_iIDEntIndex": "C_CSPlayerPawnBase",
            "m_hPlayerPawn": "CCSPlayerController",
            "m_fFlags": "C_BaseEntity",
            "m_iszPlayerName": "CBasePlayerController",
            "m_iHealth": "C_BaseEntity",
            "m_iTeamNum": "C_BaseEntity",
            "m_vOldOrigin": "C_BasePlayerPawn",
            "m_pGameSceneNode": "C_BaseEntity",
            "m_bDormant": "CGameSceneNode",
            "m_flFlashDuration": "C_CSPlayerPawnBase",
            "m_pClippingWeapon": "C_CSPlayerPawnBase",
            "m_iShotsFired": "C_CSPlayerPawn",
            "m_angEyeAngles": "C_CSPlayerPawnBase",
            "m_aimPunchAngle": "C_CSPlayerPawn",

            "m_AttributeManager": "C_EconEntity",
            "m_Item": "C_AttributeContainer",
            "m_iItemDefinitionIndex": "C_EconItemView"
        }
        clientDll = rq.get("https://raw.githubusercontent.com/a2x/cs2-dumper/main/output/client_dll.json").json()
        [setattr(Offsets, k, clientDll["client.dll"]["classes"][client_dll_name[k]]["fields"][k]) for k in client_dll_name]

    def it_entities(self):
        ent_list = pm.r_int64(self.proc, self.mod + Offsets.dwEntityList)
        local = pm.r_int64(self.proc, self.mod + Offsets.dwLocalPlayerController)
        for i in range(1, 65):
            try:
                entry_ptr = pm.r_int64(self.proc, ent_list + (8 * (i & 0x7FFF) >> 9) + 16)
                controller_ptr = pm.r_int64(self.proc, entry_ptr + 120 * (i & 0x1FF))
                if controller_ptr == local:
                    continue
                controller_pawn_ptr = pm.r_int64(self.proc, controller_ptr + Offsets.m_hPlayerPawn)
                list_entry_ptr = pm.r_int64(self.proc, ent_list + 0x8 * ((controller_pawn_ptr & 0x7FFF) >> 9) + 16)
                pawn_ptr = pm.r_int64(self.proc, list_entry_ptr + 120 * (controller_pawn_ptr & 0x1FF))
            except:
                continue

            yield Entity(controller_ptr, pawn_ptr, self.proc)

    def get_local_pawn(self):
        return pm.r_int64(self.proc, self.mod + Offsets.dwLocalPlayerPawn)

    def get_local_player_pos(self):
        return pm.r_vec3(self.proc, self.get_local_pawn() + Offsets.m_vOldOrigin)
    
    def run(self):
        pm.overlay_init("Counter-Strike 2", fps=144)
        while pm.overlay_loop():
            view_matrix = pm.r_floats(self.proc, self.mod + Offsets.dwViewMatrix, 16)

            pm.begin_drawing()
            pm.draw_fps(0, 0)
            for ent in self.it_entities():
                if ent.wts(view_matrix) and ent.health > 0 and not ent.dormant:
                    color = Colors.cyan if ent.team != 2 else Colors.orange
                    head = ent.pos2d["y"] - ent.head_pos2d["y"]
                    width = head / 2
                    center = width / 2

                    if cfg.ESP.show_line:
                        pm.draw_line(pm.get_screen_width() / 2 + 1, 1, ent.head_pos2d["x"], ent.head_pos2d["y"] - center / 2, Colors.black, 0.5)
                        pm.draw_line(pm.get_screen_width() / 2, 0, ent.head_pos2d["x"], ent.head_pos2d["y"] - center / 2, Colors.white, 0.5)
                    
                    Render.draw_box(ent.head_pos2d["x"] - center, ent.head_pos2d["y"] - center / 2, width, head + center / 2, Colors.white, color)
                    Render.draw_health(100, ent.health, 
                                        ent.head_pos2d["x"] + center + 2,
                                        ent.head_pos2d["y"] - center / 2, 
                                        4, 
                                        head + center / 2)
                    if cfg.ESP.show_distance:
                        distance = ent.get_distance(self.get_local_player_pos())
                        Render.draw_distance(distance, ent.head_pos2d["x"] + center + 8, ent.head_pos2d["y"] - center / 2, pm.get_color("#00FFFF"))
                    if cfg.ESP.show_weapon:
                        Render.draw_weapon(ent.get_weapon_name(), ent.head_pos2d["x"] + center + 8, ent.head_pos2d["y"] - center / 2 + 15, pm.get_color("#FF7700"))

            pm.end_drawing()
            rcs.update()
```

`Cheat/Configs.py`:

```py
class ESP:
    show_box = True
    show_filled_box = True
    show_line = True
    show_health = True
    show_distance = False
    show_weapon = False

class MISC:
    rcs = False
```

`Cheat/Main.py`:

```py
import threading

from Cheat import Cheat
import gui

cheat = Cheat()

gui_thread = threading.Thread(target=gui.render)
cheat_thread = threading.Thread(target=cheat.run)

gui_thread.start()
cheat_thread.start()

gui_thread.join()
cheat_thread.join()
```

`Cheat/RCS.py`:

```py
import win32api
import time
import pyMeow as pm
import win32api
import win32con

import Utils
import Configs

class Offsets:
    dwLocalPlayerPawn = 0

class RCS:
    def __init__(self):
        self.proc = pm.open_process("cs2.exe")
        self.mod = pm.get_module(self.proc, "client.dll")["base"]
        self.enabled = True
        self.old_punch = {"x": 0, "y": 0}
        self.rcs_bullet = 0
        self.rcs_scale = {"x": 2.0, "y": 2.0}
        
        self.load_offsets()
        
        self.rcs_config = {
            'intensity': 2.5,
            'recovery_time': 0.3,
            'max_shots': 30,
            'vertical_scale': 1.0,
            'horizontal_scale': 0.0,
            'smoothing': 1.0,
        }
    
    def load_offsets(self):

        offsets_name = ["dwViewMatrix", "dwEntityList", "dwLocalPlayerController", "dwLocalPlayerPawn"]
        offsets = Utils.rq.get("https://raw.githubusercontent.com/a2x/cs2-dumper/main/output/offsets.json").json()
        [setattr(Offsets, k, offsets["client.dll"][k]) for k in offsets_name]
        self.dwLocalPlayerPawn = Offsets.dwLocalPlayerPawn
    
        client_dll_name = {
            "m_iShotsFired": "C_CSPlayerPawn",
            "m_aimPunchAngle": "C_CSPlayerPawn",
        }
        clientDll = Utils.rq.get("https://raw.githubusercontent.com/a2x/cs2-dumper/main/output/client_dll.json").json()
        [setattr(Offsets, k, clientDll["client.dll"]["classes"][client_dll_name[k]]["fields"][k]) for k in client_dll_name]
        self.m_iShotsFired = Offsets.m_iShotsFired
        self.m_aimPunchAngle = Offsets.m_aimPunchAngle
    
    def get_local_player(self):
        return pm.r_int64(self.proc, self.mod + self.dwLocalPlayerPawn)
    
    def get_shots_fired(self, local_player):
        return pm.r_int(self.proc, local_player + self.m_iShotsFired)
    
    def get_aim_punch(self, local_player):
        return pm.r_vec2(self.proc, local_player + self.m_aimPunchAngle)
    
    def is_shooting(self):
        return win32api.GetKeyState(0x01) < 0
    
    def update(self):
        if Configs.MISC.rcs == False:
            return
        
        if not self.enabled:
            return
        
        try:
            local_player = self.get_local_player()
            if not local_player:
                return
            
            shots_fired = self.get_shots_fired(local_player)
            if shots_fired <= self.rcs_bullet:
                self.old_punch = {"x": 0, "y": 0}
                return
            
            aim_punch = self.get_aim_punch(local_player)
            
            sensitivity = 3.0
            delta = {
                "x": (aim_punch["x"] - self.old_punch["x"]) * 2.0,
                "y": (aim_punch["y"] - self.old_punch["y"]) * 2.0
            }
            
            mouse_x = int(delta["y"] / (sensitivity * 0.11) * self.rcs_scale["x"] * self.rcs_config['intensity'])
            mouse_y = int(delta["x"] / (sensitivity * 0.11) * self.rcs_scale["y"] * self.rcs_config['intensity'])
            
            if self.is_shooting():
                win32api.mouse_event(win32con.MOUSEEVENTF_MOVE, mouse_x, -mouse_y, 0, 0)
            
            self.old_punch = aim_punch
            
        except Exception as e:
            print(f"Error: {str(e)}")

def main():
    rcs = RCS()
    print("Press END to exit.")
    
    try:
        while True:
            if win32api.GetKeyState(0x23) < 0:
                break
            rcs.update()
            time.sleep(0.001)
    except KeyboardInterrupt:
        pass
    finally:
        print("Cheat has exited.")

if __name__ == "__main__":
    main()
```

`Cheat/Utils.py`:

```py
import requests as rq
import pyMeow as pm

def get_pyMeow(): 
    return pm

def get_requests():
    return rq

class Mem:
    def trace_address(proc, base_address, offsets):
        address = 0

        if len(offsets) == 0:
            return base_address
        
        address = pm.r_int(proc, base_address)
        if address == 0:
            return 0
        
        for i in range(len(offsets) - 1):
            address = pm.r_int(proc, address + offsets[i])
            if address == 0:
                return 0
            
        return address + offsets[-1] if address != 0 else 0
```

`Cheat/gui.py`:

```py
import Configs as cfg

from dearpygui.dearpygui import create_context, destroy_context, start_dearpygui,create_viewport, setup_dearpygui, show_viewport, is_dearpygui_running, render_dearpygui_frame, set_primary_window
from dearpygui.dearpygui import window, child_window, tab_bar, tab
from dearpygui.dearpygui import add_checkbox, add_text, add_combo, add_input_text

GUI_WIDTH = 340
GUI_HEIGHT = 420

checkbox_config_map1 = {
    "Show Box": ("ESP", "show_box"),
    "Filled Box": ("ESP", "show_filled_box"), 
    "Show Line": ("ESP", "show_line"), 
    "Show Health Bar": ("ESP", "show_health"),
    "Show Distance": ("ESP", "show_distance"),
    "Show Weapon": ("ESP", "show_weapon"),
    }

checkbox_config_map2 = {
    "Recoil Control": ("MISC", "rcs"),
    }

def checkbox_callback(sender, app_data, user_data):
    class_name, attr_name = user_data
    setattr(getattr(cfg, class_name), attr_name, app_data)

def render():
    create_context()
    with window(label="", width=GUI_WIDTH, height=GUI_HEIGHT, no_move=True, no_resize=True, no_title_bar=True, tag="Primary Window"):
        with tab_bar():
            with tab(label="ESP"):
                for label, (class_name, attr_name) in checkbox_config_map1.items():
                    initial_value = getattr(getattr(cfg, class_name), attr_name)
                    add_checkbox(label=label, default_value=initial_value, callback=checkbox_callback, user_data=(class_name, attr_name))
            with tab(label="Misc"):
                for label, (class_name, attr_name) in checkbox_config_map2.items():
                    initial_value = getattr(getattr(cfg, class_name), attr_name)
                    add_checkbox(label=label, default_value=initial_value, callback=checkbox_callback, user_data=(class_name, attr_name))
        
    create_viewport(title="CS2", width=GUI_WIDTH, height=GUI_HEIGHT, x_pos=0, y_pos=0, resizable=False)
    setup_dearpygui()
    show_viewport()
    set_primary_window("Primary Window", True)

    while is_dearpygui_running():
        render_dearpygui_frame()

    destroy_context()

if __name__ == '__main__':
    render()
```

`LICENSE`:

```
MIT License

Copyright (c) 2024 Vekor64

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# NOTICE
This source just used to study how to code a simple CS2 external hack in python.

# Library
[PyMeow](https://github.com/qb-0/PyMeow)
[DearPyGui](https://github.com/hoffstadt/DearPyGui)

# Functions
- box esp
- health bar esp
- weapon esp
- distance esp
- line esp
- recoil control

![image](https://github.com/user-attachments/assets/98f8e77b-e623-45c6-8456-7dab79287c00)


```