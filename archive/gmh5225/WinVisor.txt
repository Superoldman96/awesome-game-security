Project Path: arc_gmh5225_WinVisor_w0dsos4c

Source Tree:

```txt
arc_gmh5225_WinVisor_w0dsos4c
├── Common
│   └── WinVisorCommon.h
├── LICENSE
├── README.md
├── WinVisor
│   ├── LaunchTargetProcess.cpp
│   ├── LogClient.cpp
│   ├── Main.cpp
│   ├── ParseCommandLine.cpp
│   ├── WinVisor.h
│   └── WinVisor.vcproj
├── WinVisor.sln
├── WinVisorDLL
│   ├── CreateCpuState.cpp
│   ├── FixModuleImports.cpp
│   ├── HandleVmExit.cpp
│   ├── HypervisorEntryPoint.cpp
│   ├── HypervisorUtils.cpp
│   ├── InterruptHandler_Breakpoint.cpp
│   ├── InterruptHandler_LegacySyscall.cpp
│   ├── InterruptHandler_SingleStep.cpp
│   ├── Interrupts.cpp
│   ├── LogServer.cpp
│   ├── Main.cpp
│   ├── Misc.cpp
│   ├── PageFault.cpp
│   ├── PageTable.cpp
│   ├── PrepareCPL0.cpp
│   ├── PrepareCPL3.cpp
│   ├── SyscallHook_NtTerminateProcess.cpp
│   ├── SyscallHook_NtTerminateThread.cpp
│   ├── SyscallNames.cpp
│   ├── SyscallParamCount.cpp
│   ├── SyscallProxy.cpp
│   ├── WinHvApi.h
│   ├── WinVisorDLL.h
│   └── WinVisorDLL.vcproj
├── winvisor_screenshot.png
└── x64
    └── release
        ├── WinVisor.exe
        └── WinVisorDLL.dll

```

`Common/WinVisorCommon.h`:

```h
#define LOG_PIPE_NAME "\\\\.\\pipe\\WinVisorLog"

#define HOOK_ENTRY_POINT_CODE_SIZE 16

#define WINVISOR_FLAG_DEBUG_LOG 0x1
#define WINVISOR_FLAG_NX 0x2
#define WINVISOR_FLAG_IMPORTS 0x4

struct WinVisorStartDataStruct
{
	BYTE bOrigEntryPointCode[HOOK_ENTRY_POINT_CODE_SIZE];
	UINT64 qwWinVisorFlags;
	IMAGE_NT_HEADERS64 OrigNtHeader;
};

```

`LICENSE`:

```
MIT License

Copyright (c) 2025 x86matthew

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# WinVisor

## Overview

In Windows 10 (version RS4), Microsoft introduced the Windows Hypervisor Platform (WHP) API. This API exposes Microsoft's built-in hypervisor functionality to user-mode Windows applications. In 2024, I used this API to create another project: a 16-bit MS-DOS emulator called DOSVisor. This project takes the concept further, and allows Windows x64 executables to be emulated within a virtualized environment.

The WHP API allows applications to create a virtual CPU, and map virtual memory from the host process directly into the guest's physical memory. The emulator uses this functionality to build a virtual environment which contains everything needed to execute a Windows user-mode process. This involves building up the memory space within the guest, including mapping the target executable and all DLL dependencies, followed by populating other internal data structures such as the `PEB`, `TEB`, `KUSER_SHARED_DATA`, etc.

Mapping the EXE and DLL dependencies into memory is a simple task, but accurately maintaining internal structures, such as the PEB, is more complex. These structures are large, mostly undocumented, and their contents can vary between Windows versions. Instead of manually building up the memory layout within the virtual environment, WinVisor launches a suspended instance of the target process and clones the entire address space into the guest. The IAT and TLS data directories are temporarily removed from the PE headers in memory to stop DLL dependencies from loading and to prevent TLS callbacks from executing before reaching the entry point. The process is then resumed, allowing the usual process initialization to continue until it reaches the entry point of the target executable, at which point the hypervisor launches and takes control.

As the WHP API only allows memory from the current process to be mapped into the guest, the main hypervisor logic is encapsulated within a DLL that gets injected into the target process.

At the present time, the emulator simply forwards all syscalls to the host OS and logs them to the console. However, the project provides a framework to easily facilitate syscall hooks if necessary.

## Usage

WinVisor has some limitations in its current form - the biggest one being that it currently only supports virtualizing a single thread. Other examples are described in further detail in the **Limitations** section below.

Despite these limitations, it still works well with many executables. It has been tested successfully against built-in Windows executables such as `cmd.exe`, `ping.exe`, and even GUI applications such as `mspaint.exe` and `notepad.exe` (although these only run partially virtualized as described later).

To launch WinVisor, simply execute the following command:
`WinVisor.exe <target_executable_path>`

Command-line parameters can also be specified for the target application, for example:
`WinVisor.exe c:\windows\system32\ping.exe 8.8.8.8`

If `[ERROR] Failed to initialise Windows Hypervisor Platform API` is displayed, please ensure that `Windows Hypervisor Platform` is installed and enabled in "Windows Features".

![cmd.exe running under WinVisor](https://github.com/x86matthew/WinVisor/blob/main/winvisor_screenshot.png?raw=true)
*(screenshot above shows WinVisor emulating `cmd.exe` within a virtualized environment)*

## Virtual CPU

The emulator creates a virtual CPU via WHP to execute the target binary. The virtual CPU operates almost exclusively in CPL3 (user-mode), except for a small bootloader that runs at CPL0 (kernel-mode) to initialize the CPU state before execution. The initialization process involves setting up the following aspects:

- Control registers (`CR0`, `CR3`, `CR4`, `XCR0`)
- MSRs (`MSR_EFER`, `MSR_LSTAR`, `MSR_STAR`, `MSR_GS_BASE`)
- GDT
- IDT
- TSS
- Initial segment selectors and register values
- Paging table (4-layer)

Once the initial CPU state has been set up, it switches to CPL3 via a `SYSRET` instruction and begins executing the target application.

The emulator handles both `SYSCALL` instructions and legacy (`INT 2E`) syscalls. To catch system calls performed via the `SYSCALL` instruction, the `MSR_LSTAR` value is set to a reserved placeholder address. This placeholder address exists in kernel space, ensuring that no conflicts occur with real user-mode memory within the process. When the virtual CPU attempts to execute the `SYSCALL` instruction, a page fault exception is generated, causing a VM exit which indicates to the host that a syscall is pending.

Legacy interrupt-based syscalls are handled in a very similar way. The IDT is pre-populated with a range of placeholder handler addresses, causing a VM exit when an interrupt occurs. As the placeholder addresses are unique, the host can easily calculate which interrupt type is pending. In the case of legacy syscalls, an internal wrapper is used to proxy these calls to the same handler that is used by the `SYSCALL` instruction, before returning cleanly via `IRETQ`.

## Memory Paging

As mentioned earlier, the emulator creates a child process, and all virtual memory within that process is mapped directly into the guest using the same address layout. A paging table is used to map virtual addresses to the corresponding physical pages.

Instead of mapping the entire address space of the process upfront, a fixed number of physical pages are allocated for the guest. The emulator contains a very basic memory manager, and pages are mapped "on demand". When a page fault occurs, the requested page will be paged in, and execution resumes. If all page "slots" are full, the oldest entry is swapped out to make room for the new one.

In addition to using a fixed number of currently-mapped pages, the emulator also uses a fixed-size page table. The size of the page table is determined by calculating the maximum possible number of tables (`PML4`, `PDPT`, `PD`, `PT`) for the amount of mapped page entries. This model results in a simple and consistent physical memory layout but comes at the cost of efficiency. In fact, the paging tables take up more space than the actual page entries. However, as the emulator functions well even with a small number of allocated pages, this level of overhead is not a major concern.

## Limitations

**Single-thread only**

The emulator currently only supports virtualizing a single thread. If the target executable creates additional threads, they will be executed natively. To support multiple threads, a pseudo-scheduler could be developed to handle this in the future.

The Windows parallel loader is disabled to ensure all module dependencies are loaded by a single thread.

**Software exceptions**

Virtualized software exceptions are not currently supported. If an exception occurs, the system will call the `KiUserExceptionDispatcher` function natively within the target process as usual.

**Safety issues**

There are several ways to "escape" the VM, such as simply creating a new process/thread, scheduling APC calls, etc. Windows GUI-related syscalls can also make nested calls directly back into user-mode from the kernel, which would currently bypass the hypervisor layer. For this reason, GUI executables such as `notepad.exe` are only partially virtualized when run under WinVisor at this time.

**Shared host memory**

As the WinVisor host DLL is injected into the target process, it exists within the same virtual address space as the target executable in the guest. This means the code running within the virtual CPU is able to directly access the memory within the host hypervisor module, and could potentially corrupt it.

**Non-executable guest memory**

While the virtual CPU is set up to support NX, all memory regions are currently mirrored into the guest with full RWX access.

## Further Reading

This project is described in further detail in the following article: https://www.elastic.co/security-labs/winvisor-hypervisor-based-emulator

During development, I came across a similar project called [Simpleator](https://github.com/ionescu007/Simpleator) by Alex Ionescu. His project also utilizes the WHP API to emulate Windows x64 binaries, but is implemented in a very different way.

```

`WinVisor.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 9.00
# Visual Studio 2005
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "WinVisor", "WinVisor\WinVisor.vcproj", "{EB976AD4-A58B-4E10-B351-B4A36537FA5E}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "WinVisorDLL", "WinVisorDLL\WinVisorDLL.vcproj", "{BF705FB8-4B81-4092-8F99-603FE08884FD}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{EB976AD4-A58B-4E10-B351-B4A36537FA5E}.Debug|x64.ActiveCfg = Debug|x64
		{EB976AD4-A58B-4E10-B351-B4A36537FA5E}.Debug|x64.Build.0 = Debug|x64
		{EB976AD4-A58B-4E10-B351-B4A36537FA5E}.Release|x64.ActiveCfg = Release|x64
		{EB976AD4-A58B-4E10-B351-B4A36537FA5E}.Release|x64.Build.0 = Release|x64
		{BF705FB8-4B81-4092-8F99-603FE08884FD}.Debug|x64.ActiveCfg = Debug|x64
		{BF705FB8-4B81-4092-8F99-603FE08884FD}.Debug|x64.Build.0 = Debug|x64
		{BF705FB8-4B81-4092-8F99-603FE08884FD}.Release|x64.ActiveCfg = Release|x64
		{BF705FB8-4B81-4092-8F99-603FE08884FD}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`WinVisor/LaunchTargetProcess.cpp`:

```cpp
#include "WinVisor.h"

char gszDllPath[512];

DWORD GetDllPath()
{
	char szBaseDirectory[512];
	char *pLastSlash = NULL;

	// get full path of current exe
	memset(szBaseDirectory, 0, sizeof(szBaseDirectory));
	if(GetModuleFileNameA(NULL, szBaseDirectory, sizeof(szBaseDirectory) - 1) == 0)
	{
		return 1;
	}

	// terminate string at the last slash
	pLastSlash = strrchr(szBaseDirectory, '\\');
	if(pLastSlash == NULL)
	{
		return 1;
	}
	*pLastSlash = '\0';

	// append the dll name
	memset(gszDllPath, 0, sizeof(gszDllPath));
	_snprintf(gszDllPath, sizeof(gszDllPath) - 1, "%s\\WinVisorDLL.dll", szBaseDirectory);

	return 0;
}

DWORD GetStartHypervisorExportRVA(DWORD *pdwStartHypervisorExportRVA)
{
	HMODULE hWinVisorDLL = NULL;
	void *pStartHypervisorExport = NULL;
	DWORD dwStartHypervisorExportRVA = 0;

	// temporarily load WinVisor DLL
	hWinVisorDLL = LoadLibraryA(gszDllPath);
	if(hWinVisorDLL == NULL)
	{
		printf("Error: Failed to load DLL\n");
		return 1;
	}

	// get StartHypervisor function address
	pStartHypervisorExport = GetProcAddress(hWinVisorDLL, "StartHypervisor");
	if(pStartHypervisorExport == NULL)
	{
		FreeLibrary(hWinVisorDLL);
		return 1;
	}

	// calculate RVA
	dwStartHypervisorExportRVA = (DWORD)((UINT64)pStartHypervisorExport - (UINT64)hWinVisorDLL);

	// unload DLL
	FreeLibrary(hWinVisorDLL);

	// store RVA
	*pdwStartHypervisorExportRVA = dwStartHypervisorExportRVA;

	return 0;
}

DWORD PatchHypervisorSharedPage(HANDLE hProcess)
{
	VOID *pNtQuerySystemInformation = NULL;
	VOID *pRemoteNtQuerySystemInformationHook = NULL;
	BYTE bNtQuerySystemInformationHookPrefix[] =
	{
		// cmp rcx, 0xC5 <SystemHypervisorSharedPageInformation>
		0x48, 0x81, 0xF9, 0xC5, 0x00, 0x00, 0x00,
		// jnz call_original
		0x75, 0x06,
		// mov eax, 0xC0000003 <STATUS_INVALID_INFO_CLASS>
		0xB8, 0x03, 0x00, 0x00, 0xC0,
		// ret
		0xC3,
		// call_original:
		// ...
	};
	BYTE bJumpToHook[] =
	{
		// mov rax, 0x0000000000000000
		0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		// jmp rax
		0xFF, 0xE0
	};

	// get NtQuerySystemInformation address
	pNtQuerySystemInformation = GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtQuerySystemInformation");
	if(pNtQuerySystemInformation == NULL)
	{
		return 1;
	}

	// allocate memory for NtQuerySystemInformation hook in remote process
	pRemoteNtQuerySystemInformationHook = VirtualAllocEx(hProcess, NULL, sizeof(bNtQuerySystemInformationHookPrefix) + SYSCALL_COPY_BYTE_COUNT, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if(pRemoteNtQuerySystemInformationHook == NULL)
	{
		return 1;
	}

	// copy hook prefix code
	if(WriteProcessMemory(hProcess, pRemoteNtQuerySystemInformationHook, bNtQuerySystemInformationHookPrefix, sizeof(bNtQuerySystemInformationHookPrefix), NULL) == 0)
	{
		return 1;
	}

	// append original syscall code
	if(WriteProcessMemory(hProcess, (BYTE*)pRemoteNtQuerySystemInformationHook + sizeof(bNtQuerySystemInformationHookPrefix), pNtQuerySystemInformation, SYSCALL_COPY_BYTE_COUNT, NULL) == 0)
	{
		return 1;
	}

	// patch NtQuerySystemInformation in remote process - jump to hook
	*(UINT64*)&bJumpToHook[2] = (UINT64)pRemoteNtQuerySystemInformationHook;
	if(WriteProcessMemory(hProcess, (BYTE*)pNtQuerySystemInformation, bJumpToHook, sizeof(bJumpToHook), NULL) == 0)
	{
		return 1;
	}

	return 0;
}

DWORD DisableParallelLoader(HANDLE hProcess)
{
	VOID *pNtOpenSection = NULL;
	BYTE bExpectedOrigBytes[] = 
	{
		// mov r10, rcx
		0x4C, 0x8B, 0xD1
	};
	BYTE bPushRcxPopR10[] = 
	{
		// push rcx
		0x51,
		// pop r10
		0x41, 0x5A
	};
	BYTE bOrigBytes[sizeof(bExpectedOrigBytes)];

	// get NtOpenSection address
	pNtOpenSection = GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtOpenSection");
	if(pNtOpenSection == NULL)
	{
		return 1;
	}

	// read original bytes from NtOpenSection
	if(ReadProcessMemory(hProcess, pNtOpenSection, bOrigBytes, sizeof(bOrigBytes), NULL) == 0)
	{
		return 1;
	}

	// ensure the first instruction is "mov r10, rcx"
	if(memcmp(bOrigBytes, bExpectedOrigBytes, sizeof(bOrigBytes)) != 0)
	{
		return 1;
	}

	// overwrite with "push rcx; pop r10".
	// this has the same effect as the original instruction, but will cause ntdll to set LdrpDetectDetour to 1 and therefore disable the parallel loader.
	if(WriteProcessMemory(hProcess, pNtOpenSection, bPushRcxPopR10, sizeof(bPushRcxPopR10), NULL) == 0)
	{
		return 1;
	}

	return 0;
}

VOID *GetRemoteExeBase(HANDLE hProcess)
{
	PROCESS_BASIC_INFORMATION ProcessBasicInfo;
	PEB RemotePEB;
	DWORD (WINAPI *pNtQueryInformationProcess)(HANDLE ProcessHandle, DWORD ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength) = NULL;

	// get NtQueryInformationProcess address
	pNtQueryInformationProcess = (DWORD(WINAPI*)(HANDLE,DWORD,PVOID,ULONG,PULONG))GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtQueryInformationProcess");
	if(pNtQueryInformationProcess == NULL)
	{
		return NULL;
	}

	// get PEB address
	memset(&ProcessBasicInfo, 0, sizeof(ProcessBasicInfo));
	if(pNtQueryInformationProcess(hProcess, ProcessBasicInformation, &ProcessBasicInfo, sizeof(ProcessBasicInfo), NULL) != 0)
	{
		return NULL;
	}

	// read PEB data from process
	memset(&RemotePEB, 0, sizeof(RemotePEB));
	if(ReadProcessMemory(hProcess, ProcessBasicInfo.PebBaseAddress, &RemotePEB, sizeof(RemotePEB), NULL) == 0)
	{
		return NULL;
	}
	
	return RemotePEB.ImageBaseAddress;
}

VOID *GetRemoteModuleNtHeaderAddress(HANDLE hProcess, VOID *pRemoteModuleBase)
{
	IMAGE_DOS_HEADER RemoteDosHeader;

	// read DOS header
	memset(&RemoteDosHeader, 0, sizeof(RemoteDosHeader));
	if(ReadProcessMemory(hProcess, pRemoteModuleBase, &RemoteDosHeader, sizeof(RemoteDosHeader), NULL) == 0)
	{
		return NULL;
	}

	// return NT header address
	return (BYTE*)pRemoteModuleBase + RemoteDosHeader.e_lfanew;
}

DWORD ReadRemoteModuleNtHeader(HANDLE hProcess, VOID *pRemoteModuleBase, IMAGE_NT_HEADERS64 *pRemoteNtHeader)
{
	VOID *pRemoteNtHeaderAddress = NULL;
	IMAGE_NT_HEADERS64 RemoteNtHeader;

	// get NT header address for remote module
	pRemoteNtHeaderAddress = GetRemoteModuleNtHeaderAddress(hProcess, pRemoteModuleBase);
	if(pRemoteNtHeaderAddress == NULL)
	{
		return 1;
	}

	// read NT header
	memset(&RemoteNtHeader, 0, sizeof(RemoteNtHeader));
	if(ReadProcessMemory(hProcess, pRemoteNtHeaderAddress, &RemoteNtHeader, sizeof(RemoteNtHeader), NULL) == 0)
	{
		return 1;
	}

	// ensure this is a 64-bit module
	if(RemoteNtHeader.OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC || RemoteNtHeader.FileHeader.Machine != IMAGE_FILE_MACHINE_AMD64)
	{
		return 1;
	}

	if(pRemoteNtHeader != NULL)
	{
		// copy headers
		memcpy(pRemoteNtHeader, &RemoteNtHeader, sizeof(RemoteNtHeader));
	}

	return 0;
}

DWORD WriteRemoteModuleNtHeader(HANDLE hProcess, VOID *pRemoteModuleBase, IMAGE_NT_HEADERS64 *pRemoteNtHeader)
{
	VOID *pRemoteExeNtHeaderAddress = NULL;
	DWORD dwOrigProtect = 0;

	// get NT header address for remote EXE
	pRemoteExeNtHeaderAddress = GetRemoteModuleNtHeaderAddress(hProcess, pRemoteModuleBase);
	if(pRemoteExeNtHeaderAddress == NULL)
	{
		return 1;
	}

	if(VirtualProtectEx(hProcess, pRemoteExeNtHeaderAddress, sizeof(IMAGE_NT_HEADERS64), PAGE_READWRITE, &dwOrigProtect) == 0)
	{
		return 1;
	}

	if(WriteProcessMemory(hProcess, pRemoteExeNtHeaderAddress, pRemoteNtHeader, sizeof(IMAGE_NT_HEADERS64), NULL) == 0)
	{
		return 1;
	}
	
	if(VirtualProtectEx(hProcess, pRemoteExeNtHeaderAddress, sizeof(IMAGE_NT_HEADERS64), dwOrigProtect, &dwOrigProtect) == 0)
	{
		return 1;
	}

	return 0;
}

DWORD PatchRemoteExeDataDirectories(HANDLE hProcess, VOID *pRemoteExeModuleBase)
{
	IMAGE_NT_HEADERS64 RemoteNtHeader;

	// read NT header
	if(ReadRemoteModuleNtHeader(hProcess, pRemoteExeModuleBase, &RemoteNtHeader) != 0)
	{
		return 1;
	}

	// remove import directories
	RemoteNtHeader.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress = 0;
	RemoteNtHeader.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size = 0;
	RemoteNtHeader.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress = 0;
	RemoteNtHeader.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].Size = 0;
	RemoteNtHeader.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress = 0;
	RemoteNtHeader.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size = 0;

	// remove TLS directory
	RemoteNtHeader.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress = 0;
	RemoteNtHeader.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size = 0;

	// write NT header
	if(WriteRemoteModuleNtHeader(hProcess, pRemoteExeModuleBase, &RemoteNtHeader) != 0)
	{
		return 1;
	}

	return 0;
}

DWORD PatchRemoteExeEntryPoint(HANDLE hProcess, VOID *pRemoteExeModuleBase, IMAGE_NT_HEADERS64 *pOrigRemoteExeNtHeader, UINT64 qwWinVisorFlags)
{
	VOID *pRemoteEntryPoint = NULL;
	VOID *pRemoteDllPath = NULL;
	VOID *pRemoteWinVisorStartData = NULL;
	VOID *pLoadWinVisorDllCode = NULL;
	DWORD dwStartHypervisorExportRVA = 0;
	WinVisorStartDataStruct WinVisorStartData;
	BYTE bOrigEntryPointCode[HOOK_ENTRY_POINT_CODE_SIZE];
	BYTE bHookEntryPointCode[HOOK_ENTRY_POINT_CODE_SIZE] = 
	{
		// mov rax, 0x0000000000000000
		0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		// jmp rax
		0xFF, 0xE0,
		// (padding)
		0x90, 0x90, 0x90, 0x90
	};
	BYTE bLoadWinVisorDllCode[] =
	{
		// sub rsp, 0x28
		0x48, 0x83, 0xEC, 0x28,

		// mov rcx, <DLLPath>
		0x48, 0xB9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		// mov rax, <LoadLibraryA>
		0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		// call rax
		0xFF, 0xD0,
		// test rax, rax
		0x48, 0x85, 0xC0,
		// jz <LoadLibraryFailed>
		0x74, 0x26,
		// add rax, <StartHypervisorExportRVA>
		0x48, 0x05, 0x00, 0x00, 0x00, 0x00,
		// mov rcx, <WinVisorStartData>
		0x48, 0xB9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		// call rax
		0xFF, 0xD0,

		// LoadLibraryFailed:
		// add rsp, 0x28
		0x48, 0x83, 0xC4, 0x28,
		// ret
		0xC3
	};

	// get entry-point
	pRemoteEntryPoint = (BYTE*)pRemoteExeModuleBase + pOrigRemoteExeNtHeader->OptionalHeader.AddressOfEntryPoint;

	// allocate memory in remote process for winvisor dll path
	pRemoteDllPath = VirtualAllocEx(hProcess, NULL, sizeof(gszDllPath), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	if(pRemoteDllPath == NULL)
	{
		return 1;
	}

	// allocate memory in remote process for winvisor start data
	pRemoteWinVisorStartData = VirtualAllocEx(hProcess, NULL, sizeof(WinVisorStartData), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	if(pRemoteWinVisorStartData == NULL)
	{
		return 1;
	}

	// allocate memory in remote process for winvisor loader code
	pLoadWinVisorDllCode = VirtualAllocEx(hProcess, NULL, sizeof(bLoadWinVisorDllCode), MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if(pLoadWinVisorDllCode == NULL)
	{
		return 1;
	}

	// calculate RVA of StartHypervisor export in winvisor dll
	if(GetStartHypervisorExportRVA(&dwStartHypervisorExportRVA) != 0)
	{
		return 1;
	}

	// store original entry-point code (first 16 bytes)
	memset(bOrigEntryPointCode, 0, sizeof(bOrigEntryPointCode));
	if(ReadProcessMemory(hProcess, pRemoteEntryPoint, bOrigEntryPointCode, sizeof(bOrigEntryPointCode), NULL) == 0)
	{
		return 1;
	}

	// copy full dll path to remote process
	if(WriteProcessMemory(hProcess, pRemoteDllPath, gszDllPath, sizeof(gszDllPath), NULL) == 0)
	{
		return 1;
	}

	// copy start data to remote process
	memset(&WinVisorStartData, 0, sizeof(WinVisorStartData));
	memcpy(WinVisorStartData.bOrigEntryPointCode, bOrigEntryPointCode, sizeof(WinVisorStartData.bOrigEntryPointCode));
	WinVisorStartData.qwWinVisorFlags = qwWinVisorFlags;
	memcpy(&WinVisorStartData.OrigNtHeader, pOrigRemoteExeNtHeader, sizeof(WinVisorStartData.OrigNtHeader));
	if(WriteProcessMemory(hProcess, pRemoteWinVisorStartData, &WinVisorStartData, sizeof(WinVisorStartData), NULL) == 0)
	{
		return 1;
	}

	// populate values/pointers in winvisor loader code and copy to remote process
	*(UINT64*)&bLoadWinVisorDllCode[6] = (UINT64)pRemoteDllPath;
	*(UINT64*)&bLoadWinVisorDllCode[16] = (UINT64)LoadLibraryA;
	*(DWORD*)&bLoadWinVisorDllCode[33] = dwStartHypervisorExportRVA;
	*(UINT64*)&bLoadWinVisorDllCode[39] = (UINT64)pRemoteWinVisorStartData;
	if(WriteProcessMemory(hProcess, pLoadWinVisorDllCode, bLoadWinVisorDllCode, sizeof(bLoadWinVisorDllCode), NULL) == 0)
	{
		return 1;
	}

	// temporarily overwrite the entry-point to load the winvisor dll on startup
	*(UINT64*)&bHookEntryPointCode[2] = (UINT64)pLoadWinVisorDllCode;
	if(WriteProcessMemory(hProcess, pRemoteEntryPoint, bHookEntryPointCode, sizeof(bHookEntryPointCode), NULL) == 0)
	{
		return 1;
	}

	return 0;
}

DWORD AttachWinVisor(HANDLE hProcess, UINT64 qwWinVisorFlags)
{
	VOID *pRemoteExeModuleBase = NULL;
	IMAGE_NT_HEADERS64 OrigRemoteExeNtHeader;

	// get remote EXE base address
	pRemoteExeModuleBase = GetRemoteExeBase(hProcess);
	if(pRemoteExeModuleBase == NULL)
	{
		return 1;
	}

	// store original NT headers for remote exe
	if(ReadRemoteModuleNtHeader(hProcess, pRemoteExeModuleBase, &OrigRemoteExeNtHeader) != 0)
	{
		printf("Error: Target is not a valid x64 executable\n");
		return 1;
	}

	// hook the entry-point of the remote process - load WinVisor DLL
	if(PatchRemoteExeEntryPoint(hProcess, pRemoteExeModuleBase, &OrigRemoteExeNtHeader, qwWinVisorFlags) != 0)
	{
		return 1;
	}

	// temporarily remove the import and TLS data directories for the remote exe.
	// this prevents any DLL dependencies and TLS callbacks from executing before the hypervisor takes over.
	// these will be restored later, and the virtual CPU will load DLL dependencies and execute TLS callbacks manually before executing the entry-point.
	if(PatchRemoteExeDataDirectories(hProcess, pRemoteExeModuleBase) != 0)
	{
		return 1;
	}

	// windows 10 introduced a new shared page which is located close to KUSER_SHARED_DATA.
	// the exact address can be retrieved with NtQuerySystemInformation(SystemHypervisorSharedPageInformation).
	// this page is used by timing-related functions such as RtlQueryPerformanceCounter / RtlGetMultiTimePrecise.
	// the hypervisor platform api contains a bug which causes WHvRunVirtualProcessor to get stuck in an infinite loop if the guest attempts to access this shared page.
	// to work around this bug, NtQuerySystemInformation will be patched to return STATUS_INVALID_INFO_CLASS for SystemHypervisorSharedPageInformation requests.
	// this causes the code in ntdll to fall back to traditional methods.
	// it needs to be patched early as LdrpInitializeProcess stores the address of this page in a global variable (ntdll!RtlpHypervisorSharedUserVa).
	if(PatchHypervisorSharedPage(hProcess) != 0)
	{
		return 1;
	}

	// windows 10 added a parallel loader which loads DLL dependencies using multiple background threads via a thread-pool.
	// as this emulator currently only virtualizes a single thread, this behaviour should be disabled to ensure DLL loads are all performed by the calling thread.
	// it is possible to disable the parallel loader by setting PEB->ProcessParameters->LoaderThreads to 1 before resuming the process, but this value can still be
	// overridden by the MaxLoaderThreads IFEO value.
	// the windows loader also checks for inline patches within a hardcoded list of functions (LdrpCriticalLoaderFunctions), and if any patches are
	// detected, parallel loading is disabled for stability reasons.
	// this function patches the first instruction (mov r10, rcx) of a known LdrpCriticalLoaderFunctions entry (NtOpenSection) to an equivalent operation
	// of the same size (push rcx; pop r10), which forces the parallel loader to be disabled without affecting any other functionality.
	if(DisableParallelLoader(hProcess) != 0)
	{
		return 1;
	}

	return 0;
}

DWORD LaunchTargetProcess(char *pTargetCommandLine, UINT64 qwWinVisorFlags, DWORD *pdwPID)
{
	STARTUPINFOA StartupInfo;
	PROCESS_INFORMATION ProcessInfo;

	printf("Launching target process: %s...\n", pTargetCommandLine);

	// get full WinVisor DLL path
	if(GetDllPath() != 0)
	{
		return 1;
	}

	// create suspended process
	memset(&StartupInfo, 0, sizeof(StartupInfo));
	StartupInfo.cb = sizeof(StartupInfo);
	if(CreateProcessA(NULL, pTargetCommandLine, NULL, NULL, 0, CREATE_NEW_CONSOLE | CREATE_SUSPENDED, NULL, NULL, &StartupInfo, &ProcessInfo) == 0)
	{
		printf("Error: Failed to launch target process\n");
		return 1;
	}

	// attach WinVisor to remote process
	if(AttachWinVisor(ProcessInfo.hProcess, qwWinVisorFlags) != 0)
	{
		printf("Error: Failed to attach WinVisor to remote process\n");
		TerminateProcess(ProcessInfo.hProcess, 0);
		CloseHandle(ProcessInfo.hProcess);
		CloseHandle(ProcessInfo.hThread);
		return 1;
	}

	// start remote process
	ResumeThread(ProcessInfo.hThread);

	// close handles
	CloseHandle(ProcessInfo.hProcess);
	CloseHandle(ProcessInfo.hThread);

	// store PID
	*pdwPID = ProcessInfo.dwProcessId;

	return 0;
}

```

`WinVisor/LogClient.cpp`:

```cpp
#include "WinVisor.h"

DWORD StartLogClient(DWORD dwPID)
{
	BYTE bByte = 0;
	DWORD dwRead = 0;
	HANDLE hPipe = NULL;
	char szPipeName[512];

	// append target PID to pipe name to allow multiple instances
	memset(szPipeName, 0, sizeof(szPipeName));
	_snprintf(szPipeName, sizeof(szPipeName) - 1, "%s_%u", LOG_PIPE_NAME, dwPID);

	for(;;)
	{
		// open named pipe from parent process
		hPipe = CreateFileA(szPipeName, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
		if(hPipe == INVALID_HANDLE_VALUE)
		{
			Sleep(100);
			continue;
		}

		break;
	}

	// read from pipe and print to console
	for(;;)
	{
		// get next character
		if(ReadFile(hPipe, &bByte, 1, &dwRead, NULL) == 0)
		{
			break;
		}

		if(dwRead == 0)
		{
			break;
		}

		printf("%c", bByte);
	}

	// finished
	CloseHandle(hPipe);

	return 0;
}

```

`WinVisor/Main.cpp`:

```cpp
#include "WinVisor.h"

#ifndef _WIN64
#error Must be compiled as 64-bit
#endif

int main(int argc, char *argv[])
{
	char *pTargetCommandLine = NULL;
	UINT64 qwWinVisorFlags = 0;
	DWORD dwPID = 0;

	printf("WinVisor\n");
	printf(" - x86matthew\n\n");

	// validate params
	if(argc < 2)
	{
		printf("Usage: %s [-debug] [-nx] <exe_name> [exe_params]\n", argv[0]);
		printf("   -debug    : Enable debug logging\n");
		printf("   -nx       : Set entire EXE image to non-executable in host process\n");
		printf("   -imports  : Include syscall logging for initial imported modules\n");
		return 1;
	}

	// parse command-line
	if(ParseCommandLine(argv[0], &pTargetCommandLine, &qwWinVisorFlags) != 0)
	{
		printf("Error: Invalid parameters\n");
		return 1;
	}

	// launch target process and attach WinVisor
	if(LaunchTargetProcess(pTargetCommandLine, qwWinVisorFlags, &dwPID) != 0)
	{
		printf("Error: Failed to launch WinVisor\n");
		return 1;
	}

	// read log messages
	if(StartLogClient(dwPID) != 0)
	{
		return 1;
	}

	return 0;
}

```

`WinVisor/ParseCommandLine.cpp`:

```cpp
#include "WinVisor.h"

char *SkipWhitespace(char *pString)
{
	char *pCurrPtr = NULL;

	// find first non-space character
	pCurrPtr = pString;
	for(;;)
	{
		if(*pCurrPtr != ' ')
		{
			break;
		}
		pCurrPtr++;
	}

	return pCurrPtr;
}

DWORD CheckCommandLineSwitch(char *pCommandLinePtr, char *pSwitchName, char **ppUpdatedCommandLinePtr)
{
	char szTemp[64];
	char *pUpdatedCommandLinePtr = NULL;

	// check if this is the specified command-line switch
	memset(szTemp, 0, sizeof(szTemp));
	_snprintf(szTemp, sizeof(szTemp) - 1, "-%s ", pSwitchName);
	if(strncmp(pCommandLinePtr, szTemp, strlen(szTemp)) != 0)
	{
		return 1;
	}

	// update command line ptr
	pUpdatedCommandLinePtr = pCommandLinePtr;
	pUpdatedCommandLinePtr += strlen(szTemp);
	pUpdatedCommandLinePtr = SkipWhitespace(pUpdatedCommandLinePtr);

	// store ptr
	*ppUpdatedCommandLinePtr = pUpdatedCommandLinePtr;

	return 0;
}

DWORD ParseCommandLine(char *pFirstParam, char **ppTargetCommandLine, UINT64 *pqwWinVisorFlags)
{
	DWORD dwIgnoreCharCount = 0;
	char *pTargetCommandLine = NULL;
	UINT64 qwWinVisorFlags = 0;

	// skip the first param (this exe)
	dwIgnoreCharCount = (DWORD)strlen(pFirstParam);
	pTargetCommandLine = GetCommandLineA();
	if(*pTargetCommandLine == '\"')
	{
		dwIgnoreCharCount += 2;
	}
	pTargetCommandLine += dwIgnoreCharCount;

	// ignore leading spaces
	pTargetCommandLine = SkipWhitespace(pTargetCommandLine);

	for(;;)
	{
		// check if this is a command-line switch
		if(*pTargetCommandLine == '-')
		{
			// check switch type
			if(CheckCommandLineSwitch(pTargetCommandLine, "debug", &pTargetCommandLine) == 0)
			{
				qwWinVisorFlags |= WINVISOR_FLAG_DEBUG_LOG;
			}
			else if(CheckCommandLineSwitch(pTargetCommandLine, "nx", &pTargetCommandLine) == 0)
			{
				qwWinVisorFlags |= WINVISOR_FLAG_NX;
			}
			else if(CheckCommandLineSwitch(pTargetCommandLine, "imports", &pTargetCommandLine) == 0)
			{
				qwWinVisorFlags |= WINVISOR_FLAG_IMPORTS;
			}
			else
			{
				// unknown switch
				return 1;
			}
		}
		else
		{
			break;
		}
	}

	// store cmdline ptr and flags
	*ppTargetCommandLine = pTargetCommandLine;
	*pqwWinVisorFlags = qwWinVisorFlags;

	return 0;
}

```

`WinVisor/WinVisor.h`:

```h
#define _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_DEPRECATE
#include <stdio.h>
#include <windows.h>
#include "..\Common\WinVisorCommon.h"

#define ProcessBasicInformation 0

#define SYSCALL_COPY_BYTE_COUNT 64

struct PEB
{
	BYTE Reserved1[2];
	BYTE BeingDebugged;
	BYTE Reserved2[1];
	PVOID Reserved3[1];
	PVOID ImageBaseAddress;
	PVOID Ldr;
	PVOID ProcessParameters;
	PVOID Reserved4[3];
	PVOID AtlThunkSListPtr;
	PVOID Reserved5;
	ULONG Reserved6;
	PVOID Reserved7;
	ULONG Reserved8;
	ULONG AtlThunkSListPtr32;
	PVOID Reserved9[45];
	BYTE Reserved10[96];
	PVOID PostProcessInitRoutine;
	BYTE Reserved11[128];
	PVOID Reserved12[1];
	ULONG SessionId;
};

struct PROCESS_BASIC_INFORMATION
{
	DWORD ExitStatus;
	PEB *PebBaseAddress;
	ULONG_PTR AffinityMask;
	DWORD BasePriority;
	ULONG_PTR UniqueProcessId;
	ULONG_PTR InheritedFromUniqueProcessId;
};

extern DWORD StartLogClient(DWORD dwPID);
extern DWORD ParseCommandLine(char *pFirstParam, char **ppTargetCommandLine, UINT64 *pqwWinVisorFlags);
extern DWORD LaunchTargetProcess(char *pTargetCommandLine, UINT64 qwWinVisorFlags, DWORD *pdwPID);

```

`WinVisor/WinVisor.vcproj`:

```vcproj
<?xml version="1.0" encoding="Windows-1252"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="8.00"
	Name="WinVisor"
	ProjectGUID="{EB976AD4-A58B-4E10-B351-B4A36537FA5E}"
	RootNamespace="WinVisor"
	Keyword="Win32Proj"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
		<Platform
			Name="x64"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Debug|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="1"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE"
				MinimalRebuild="true"
				BasicRuntimeChecks="3"
				RuntimeLibrary="3"
				UsePrecompiledHeader="0"
				WarningLevel="3"
				Detect64BitPortabilityProblems="true"
				DebugInformationFormat="4"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				LinkIncremental="2"
				GenerateDebugInformation="true"
				SubSystem="1"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Debug|x64"
			OutputDirectory="$(SolutionDir)$(PlatformName)\$(ConfigurationName)"
			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
			ConfigurationType="1"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
				TargetEnvironment="3"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE"
				MinimalRebuild="true"
				BasicRuntimeChecks="3"
				RuntimeLibrary="3"
				UsePrecompiledHeader="0"
				WarningLevel="3"
				Detect64BitPortabilityProblems="true"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				LinkIncremental="2"
				GenerateDebugInformation="true"
				SubSystem="1"
				TargetMachine="17"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="1"
			CharacterSet="1"
			WholeProgramOptimization="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE"
				RuntimeLibrary="2"
				UsePrecompiledHeader="0"
				WarningLevel="3"
				Detect64BitPortabilityProblems="true"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				LinkIncremental="1"
				GenerateDebugInformation="true"
				SubSystem="1"
				OptimizeReferences="2"
				EnableCOMDATFolding="2"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Release|x64"
			OutputDirectory="$(SolutionDir)$(PlatformName)\$(ConfigurationName)"
			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
			ConfigurationType="1"
			CharacterSet="1"
			WholeProgramOptimization="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
				TargetEnvironment="3"
			/>
			<Tool
				Name="VCCLCompilerTool"
				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE"
				RuntimeLibrary="0"
				UsePrecompiledHeader="0"
				WarningLevel="3"
				Detect64BitPortabilityProblems="true"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				LinkIncremental="1"
				GenerateDebugInformation="true"
				SubSystem="1"
				OptimizeReferences="2"
				EnableCOMDATFolding="2"
				TargetMachine="17"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="Source Files"
			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
			>
			<File
				RelativePath=".\LaunchTargetProcess.cpp"
				>
			</File>
			<File
				RelativePath=".\LogClient.cpp"
				>
			</File>
			<File
				RelativePath=".\Main.cpp"
				>
			</File>
			<File
				RelativePath=".\ParseCommandLine.cpp"
				>
			</File>
		</Filter>
		<Filter
			Name="Header Files"
			Filter="h;hpp;hxx;hm;inl;inc;xsd"
			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
			>
			<File
				RelativePath=".\WinVisor.h"
				>
			</File>
			<File
				RelativePath="..\Common\WinVisorCommon.h"
				>
			</File>
		</Filter>
		<Filter
			Name="Resource Files"
			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
			>
		</Filter>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>

```

`WinVisorDLL/CreateCpuState.cpp`:

```cpp
#include "WinVisorDLL.h"

CpuStateStruct *CreateCpuState(WinVisorStartDataStruct *pWinVisorStartData)
{
	CpuStateStruct *pCpuState = NULL;

	// allocate cpu state object
	pCpuState = (CpuStateStruct*)VirtualAlloc(NULL, sizeof(CpuStateStruct), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	if(pCpuState == NULL)
	{
		WriteLog(LOG_ERROR, "Failed to allocate CPU state object");
		return NULL;
	}

	// prepare CPL3 state
	if(PrepareCPL3(pCpuState, pWinVisorStartData) != 0)
	{
		WriteLog(LOG_ERROR, "Failed to prepare user-mode entry environment");
		DeleteCpuState(pCpuState);
		return NULL;
	}

	// prepare CPL0 bootloader
	if(PrepareCPL0(pCpuState) != 0)
	{
		WriteLog(LOG_ERROR, "Failed to prepare bootloader");
		DeleteCpuState(pCpuState);
		return NULL;
	}

	return pCpuState;
}

DWORD DeleteCpuState(CpuStateStruct *pCpuState)
{
	if(pCpuState != NULL)
	{
		if(pCpuState->pCPL0_Stack != NULL)
		{
			// free memory
			VirtualFree(pCpuState->pCPL0_Stack, 0, MEM_RELEASE);
		}

		if(pCpuState->pCPL3_Stack != NULL)
		{
			// free memory
			VirtualFree(pCpuState->pCPL3_Stack, 0, MEM_RELEASE);
		}

		if(pCpuState->hHostThread != NULL)
		{
			// terminate thread
			TerminateThread(pCpuState->hHostThread, 0);
			CloseHandle(pCpuState->hHostThread);
		}

		if(pCpuState->hSyscallProxyReadyEvent != NULL)
		{
			// delete event object
			CloseHandle(pCpuState->hSyscallProxyReadyEvent);
		}

		if(pCpuState->hSyscallWaitingEvent != NULL)
		{
			// delete event object
			CloseHandle(pCpuState->hSyscallWaitingEvent);
		}

		if(pCpuState->hSyscallCompleteEvent != NULL)
		{
			// delete event object
			CloseHandle(pCpuState->hSyscallCompleteEvent);
		}

		// free main object
		VirtualFree(pCpuState, 0, MEM_RELEASE);
	}

	return 0;
}

```

`WinVisorDLL/FixModuleImports.cpp`:

```cpp
#include "WinVisorDLL.h"

DWORD FixModuleImports_ProcessModule(VOID *pModuleBase, char *pModuleName, DWORD dwFirstThunkOffset)
{
	IMAGE_THUNK_DATA64 *pCurrThunkData64 = NULL;
	DWORD dwCurrThunkOffset = 0;
	DWORD dwOrdinal = 0;
	IMAGE_IMPORT_BY_NAME *pImageImportByName = NULL;
	DWORD dwVirtualAddress = 0;
	HMODULE hModule = NULL;
	VOID *pCurrResolvedAddr = NULL;
	UINT64 *pImportPtr = NULL;

	// load target library
	hModule = LoadLibraryA(pModuleName);
	if(hModule == NULL)
	{
		WriteLog(LOG_ERROR, "Failed to load DLL: %s", pModuleName);
		return 1;
	}

	// process module imports
	dwCurrThunkOffset = dwFirstThunkOffset;
	for(;;)
	{
		// get current thunk ptr
		pCurrThunkData64 = (IMAGE_THUNK_DATA64*)((BYTE*)pModuleBase + dwCurrThunkOffset);
		if(pCurrThunkData64->u1.AddressOfData == 0)
		{
			// finished
			break;
		}

		// get virtual address of import entry
		dwVirtualAddress = (DWORD)((BYTE*)&pCurrThunkData64->u1.Function - (BYTE*)pModuleBase);

		// check import type
		if(pCurrThunkData64->u1.Ordinal & IMAGE_ORDINAL_FLAG64)
		{
			// resolve import by ordinal
			dwOrdinal = (DWORD)(pCurrThunkData64->u1.Ordinal & 0xFFFF);
			pCurrResolvedAddr = GetProcAddress(hModule, (char*)((SIZE_T)dwOrdinal));
			if(pCurrResolvedAddr == NULL)
			{
				WriteLog(LOG_ERROR, "Failed to locate import entry: %s!#%u", pModuleName, dwOrdinal);
				return 1;
			}
		}
		else
		{
			// get imported function name
			pImageImportByName = (IMAGE_IMPORT_BY_NAME*)((BYTE*)pModuleBase + (DWORD)pCurrThunkData64->u1.AddressOfData);

			pCurrResolvedAddr = GetProcAddress(hModule, (char*)pImageImportByName->Name);
			if(pCurrResolvedAddr == NULL)
			{
				WriteLog(LOG_ERROR, "Failed to locate import entry: %s!#%s", pModuleName, (char*)pImageImportByName->Name);
				return 1;
			}
		}

		// update address
		pImportPtr = (UINT64*)((BYTE*)pModuleBase + dwVirtualAddress);
		if(CopyMemoryAndRestoreProtection(pImportPtr, &pCurrResolvedAddr, sizeof(pCurrResolvedAddr)) != 0)
		{
			return 1;
		}

		// update thunk offset
		dwCurrThunkOffset += sizeof(IMAGE_THUNK_DATA64);
	}

	return 0;
}

DWORD FixModuleImports(VOID *pModuleBase)
{
	IMAGE_NT_HEADERS64 *pImageNtHeader = NULL;
	IMAGE_DATA_DIRECTORY *pImportDirectory = NULL;
	DWORD dwCurrImportBlockOffset = 0;
	IMAGE_IMPORT_DESCRIPTOR *pImageImportDescriptor = NULL;
	char *pCurrModuleName = NULL;
	DWORD dwFirstThunkOffset = 0;

	pImageNtHeader = (IMAGE_NT_HEADERS64*)GetNtHeader((HMODULE)pModuleBase);
	if(pImageNtHeader == NULL)
	{
		return 1;
	}

	// check if this module contains an import directory
	pImportDirectory = &pImageNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
	if(pImportDirectory->VirtualAddress != 0 && pImportDirectory->Size != 0)
	{
		// process import table
		dwCurrImportBlockOffset = pImportDirectory->VirtualAddress;
		for(;;)
		{
			pImageImportDescriptor = (IMAGE_IMPORT_DESCRIPTOR*)((BYTE*)pModuleBase + dwCurrImportBlockOffset);
			if(pImageImportDescriptor->Name == 0)
			{
				// finished
				break;
			}

			// get current module name
			pCurrModuleName = (char*)((BYTE*)pModuleBase + pImageImportDescriptor->Name);

			// process the imports for the current module
			dwFirstThunkOffset = pImageImportDescriptor->FirstThunk;
			if(FixModuleImports_ProcessModule(pModuleBase, pCurrModuleName, dwFirstThunkOffset) != 0)
			{
				return 1;
			}

			// update import block offset
			dwCurrImportBlockOffset += sizeof(IMAGE_IMPORT_DESCRIPTOR);
		}
	}

	return 0;
}

```

`WinVisorDLL/HandleVmExit.cpp`:

```cpp
#include "WinVisorDLL.h"

DWORD HandleVmExit(CpuStateStruct *pCpuState, CpuRegisterStateStruct *pCpuRegisterState, WHV_RUN_VP_EXIT_CONTEXT *pVmExitContext)
{
	// check vmexit reason
	if(pVmExitContext->ExitReason == WHvRunVpExitReasonMemoryAccess)
	{
		// invalid memory access
		WriteLog(LOG_ERROR, "Invalid physical memory access at 0x%p (RIP: 0x%p)", pVmExitContext->MemoryAccess.Gpa, pCpuRegisterState->RIP);
		return 1;
	}
	else if(pVmExitContext->ExitReason == WHvRunVpExitReasonException)
	{
		// exception
		if(pVmExitContext->VpException.ExceptionType == WHvX64ExceptionTypePageFault)
		{
			// page fault
			if(HandlePageFault(pCpuState, pCpuRegisterState, pVmExitContext->VpException.ExceptionParameter) != 0)
			{
				WriteLog(LOG_ERROR, "Failed to handle page fault (RIP: 0x%p)", pCpuRegisterState->RIP);
				return 1;
			}
		}
		else if(pVmExitContext->VpException.ExceptionType == WHvX64ExceptionTypeGeneralProtectionFault)
		{
			// general protection fault
			WriteLog(LOG_ERROR, "General protection fault (RIP: 0x%p)", pCpuRegisterState->RIP);
			return 1;
		}
		else
		{
			// unknown type
			WriteLog(LOG_ERROR, "Unhandled exception type: 0x%02X (RIP: 0x%p)", pVmExitContext->VpException.ExceptionType, pCpuRegisterState->RIP);
			return 1;
		}
	}
	else
	{
		// unknown vmexit reason
		WriteLog(LOG_ERROR, "Unhandled VmExit reason: 0x%08X (RIP: 0x%p)", pVmExitContext->ExitReason, pCpuRegisterState->RIP);
		return 1;
	}

	return 0;
}
```

`WinVisorDLL/HypervisorEntryPoint.cpp`:

```cpp
#include "WinVisorDLL.h"

DWORD gdwLoadedModuleImports = 0;

DWORD ExecuteTlsCallbacks(VOID *pModuleBase)
{
	IMAGE_NT_HEADERS64 *pImageNtHeader = NULL;
	IMAGE_DATA_DIRECTORY *pTlsDirectory = NULL;
	IMAGE_TLS_DIRECTORY *pImageTlsDirectory = NULL;
	UINT64 *pqwCurrCallbackEntry = NULL;

	pImageNtHeader = (IMAGE_NT_HEADERS64*)GetNtHeader((HMODULE)pModuleBase);
	if(pImageNtHeader == NULL)
	{
		return 1;
	}

	// check if this module contains a TLS directory
	pTlsDirectory = &pImageNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS];
	if(pTlsDirectory->VirtualAddress != 0 && pTlsDirectory->Size != 0)
	{
		pImageTlsDirectory = (IMAGE_TLS_DIRECTORY*)((BYTE*)pModuleBase + pTlsDirectory->VirtualAddress);
		if(pImageTlsDirectory->AddressOfCallBacks != 0)
		{
			// execute all callbacks
			pqwCurrCallbackEntry = (UINT64*)pImageTlsDirectory->AddressOfCallBacks;
			for(;;)
			{
				if(*pqwCurrCallbackEntry == 0)
				{
					// end of list
					break;
				}

				// execute current callback function
				((PIMAGE_TLS_CALLBACK)*pqwCurrCallbackEntry)(pModuleBase, DLL_PROCESS_ATTACH, NULL);

				// move to next entry
				pqwCurrCallbackEntry++;
			}
		}
	}

	return 0;
}

DWORD HypervisorEntryPoint_StartExe(VOID *pExeEntryPoint, DWORD *pdwExitCode)
{
	DWORD dwExitCode = 0;

	// load EXE imports
	if(FixModuleImports(ghExeBase) != 0)
	{
		return 1;
	}

	// loaded imports - set flag for logging purposes
	gdwLoadedModuleImports = 1;

	// execute TLS callbacks
	if(ExecuteTlsCallbacks(ghExeBase) != 0)
	{
		return 1;
	}

	// execute original entry-point
	dwExitCode = ((DWORD(*)(VOID*))pExeEntryPoint)((VOID*)__readgsqword(0x60));

	// store exit code
	*pdwExitCode = dwExitCode;

	return 0;
}

DWORD HypervisorEntryPoint(VOID *pExeEntryPoint)
{
	DWORD dwExitCode = 0;

	// start exe
	HypervisorEntryPoint_StartExe(pExeEntryPoint, &dwExitCode);

	// ensure the current thread is terminated after the entry-point returns
	TerminateThread(GetCurrentThread(), dwExitCode);

	return 0;
}

```

`WinVisorDLL/HypervisorUtils.cpp`:

```cpp
#include "WinVisorDLL.h"

HRESULT (WINAPI *WHvCreatePartition)(WHV_PARTITION_HANDLE* Partition) = NULL;
HRESULT (WINAPI *WHvDeletePartition)(WHV_PARTITION_HANDLE Partition) = NULL;
HRESULT (WINAPI *WHvMapGpaRange)(WHV_PARTITION_HANDLE Partition, VOID* SourceAddress, WHV_GUEST_PHYSICAL_ADDRESS GuestAddress, UINT64 SizeInBytes, WHV_MAP_GPA_RANGE_FLAGS Flags) = NULL;
HRESULT (WINAPI *WHvUnmapGpaRange)(WHV_PARTITION_HANDLE Partition, WHV_GUEST_PHYSICAL_ADDRESS GuestAddress, UINT64 SizeInBytes);
HRESULT (WINAPI *WHvSetVirtualProcessorRegisters)(WHV_PARTITION_HANDLE Partition, UINT32 VpIndex, const WHV_REGISTER_NAME* RegisterNames, UINT32 RegisterCount, const WHV_REGISTER_VALUE* RegisterValues) = NULL;
HRESULT (WINAPI *WHvRunVirtualProcessor)(WHV_PARTITION_HANDLE Partition, UINT32 VpIndex, VOID* ExitContext, UINT32 ExitContextSizeInBytes) = NULL;
HRESULT (WINAPI *WHvSetPartitionProperty)(WHV_PARTITION_HANDLE Partition, WHV_PARTITION_PROPERTY_CODE PropertyCode, const VOID* PropertyBuffer, UINT32 PropertyBufferSizeInBytes) = NULL;
HRESULT (WINAPI *WHvSetupPartition)(WHV_PARTITION_HANDLE Partition) = NULL;
HRESULT (WINAPI *WHvCreateVirtualProcessor)(WHV_PARTITION_HANDLE Partition, UINT32 VpIndex, UINT32 Flags) = NULL;
HRESULT (WINAPI *WHvGetVirtualProcessorRegisters)(WHV_PARTITION_HANDLE Partition, UINT32 VpIndex, const WHV_REGISTER_NAME* RegisterNames, UINT32 RegisterCount, WHV_REGISTER_VALUE* RegisterValues) = NULL;
HRESULT (WINAPI *WHvGetCapability)(WHV_CAPABILITY_CODE CapabilityCode, VOID* CapabilityBuffer, UINT32 CapabilityBufferSizeInBytes, UINT32 *WrittenSizeInBytes) = NULL;

ImportFunctionStruct gImportHypervisorPlatformFunctionList[] =
{
	{ "WHvCreatePartition", (void**)&WHvCreatePartition },
	{ "WHvDeletePartition", (void**)&WHvDeletePartition },
	{ "WHvMapGpaRange", (void**)&WHvMapGpaRange },
	{ "WHvUnmapGpaRange", (void**)&WHvUnmapGpaRange },
	{ "WHvSetVirtualProcessorRegisters", (void**)&WHvSetVirtualProcessorRegisters },
	{ "WHvRunVirtualProcessor", (void**)&WHvRunVirtualProcessor },
	{ "WHvSetPartitionProperty", (void**)&WHvSetPartitionProperty },
	{ "WHvSetupPartition", (void**)&WHvSetupPartition },
	{ "WHvCreateVirtualProcessor", (void**)&WHvCreateVirtualProcessor },
	{ "WHvGetVirtualProcessorRegisters", (void**)&WHvGetVirtualProcessorRegisters },
	{ "WHvGetCapability", (void**)&WHvGetCapability },
};

HANDLE ghPartitionHandle = NULL;

DWORD HypervisorUtils_Initialise()
{
	HMODULE hModule = NULL;
	void *pImportAddr = NULL;
	DWORD dwFunctionCount = 0;
	WHV_CAPABILITY HypervisorCapability;
	UINT32 dwHypervisorCapabilitySize = 0;

	// load hypervisor module
	hModule = LoadLibraryA("winhvplatform.dll");
	if(hModule == NULL)
	{
		return 1;
	}

	// resolve imported functions
	dwFunctionCount = sizeof(gImportHypervisorPlatformFunctionList) / sizeof(gImportHypervisorPlatformFunctionList[0]);
	for(DWORD i = 0; i < dwFunctionCount; i++)
	{
		// resolve current function
		pImportAddr = GetProcAddress(hModule, gImportHypervisorPlatformFunctionList[i].pName);
		if(pImportAddr == NULL)
		{
			return 1;
		}

		// store function ptr
		*gImportHypervisorPlatformFunctionList[i].pFunctionPtrAddr = pImportAddr;
	}

	// ensure the hypervisor platform is enabled
	memset(&HypervisorCapability, 0, sizeof(HypervisorCapability));
	if(WHvGetCapability(WHvCapabilityCodeHypervisorPresent, &HypervisorCapability, sizeof(HypervisorCapability), &dwHypervisorCapabilitySize) != S_OK)
	{
		return 1;
	}
	if(HypervisorCapability.HypervisorPresent == 0)
	{
		return 1;
	}

	return 0;
}

DWORD HypervisorUtils_CreateEnvironment()
{
	WHV_PARTITION_HANDLE hPartitionHandle = NULL;
	WHV_PARTITION_PROPERTY PartitionPropertyData;
	WHV_EXTENDED_VM_EXITS ExtendedVmExits;
	UINT64 qwExceptionExitBitmap = 0;

	// create hypervisor partition
	if(WHvCreatePartition(&hPartitionHandle) != S_OK)
	{
		return 1;
	}

	// single processor
	memset(&PartitionPropertyData, 0, sizeof(PartitionPropertyData));
	PartitionPropertyData.ProcessorCount = 1;
	if(WHvSetPartitionProperty(hPartitionHandle, WHvPartitionPropertyCodeProcessorCount, &PartitionPropertyData, sizeof(PartitionPropertyData)) != S_OK)
	{
		WHvDeletePartition(hPartitionHandle);
		return 1;
	}

	// enable vmexit for exceptions
	memset(&ExtendedVmExits, 0, sizeof(ExtendedVmExits));
	ExtendedVmExits.ExceptionExit = 1;
	if(WHvSetPartitionProperty(hPartitionHandle, WHvPartitionPropertyCodeExtendedVmExits, &ExtendedVmExits, sizeof(ExtendedVmExits)) != S_OK)
	{
		WHvDeletePartition(hPartitionHandle);
		return 1;
	}

	// update exception bitmap to catch page faults and general protection faults
	qwExceptionExitBitmap = (1 << WHvX64ExceptionTypePageFault) | (1 << WHvX64ExceptionTypeGeneralProtectionFault);
	if(WHvSetPartitionProperty(hPartitionHandle, WHvPartitionPropertyCodeExceptionExitBitmap, &qwExceptionExitBitmap, sizeof(qwExceptionExitBitmap)) != S_OK)
	{
		WHvDeletePartition(hPartitionHandle);
		return 1;
	}

	// hypervisor partition ready
	if(WHvSetupPartition(hPartitionHandle) != S_OK)
	{
		WHvDeletePartition(hPartitionHandle);
		return 1;
	}

	// create virtual CPU
	if(WHvCreateVirtualProcessor(hPartitionHandle, 0, 0) != S_OK)
	{
		WHvDeletePartition(hPartitionHandle);
		return 1;
	}

	// store handle
	ghPartitionHandle = hPartitionHandle;

	return 0;
}

DWORD HypervisorUtils_DeleteEnvironment()
{
	if(ghPartitionHandle != NULL)
	{
		WHvDeletePartition(ghPartitionHandle);
	}

	return 0;
}

DWORD HypervisorUtils_GetRegisterValue_U64(WHV_REGISTER_NAME RegisterName, QWORD *pqwRegisterValue)
{
	WHV_REGISTER_VALUE RegisterValue;

	// get uint64 register value
	memset(&RegisterValue, 0, sizeof(RegisterValue));
	if(WHvGetVirtualProcessorRegisters(ghPartitionHandle, 0, &RegisterName, 1, &RegisterValue) != S_OK)
	{
		return 1;
	}

	*pqwRegisterValue = RegisterValue.Reg64;

	return 0;
}

DWORD HypervisorUtils_SetRegisterValue_U64(WHV_REGISTER_NAME RegisterName, QWORD qwRegisterValue)
{
	WHV_REGISTER_VALUE RegisterValue;

	// set uint64 register value
	memset(&RegisterValue, 0, sizeof(RegisterValue));
	RegisterValue.Reg64 = qwRegisterValue;
	if(WHvSetVirtualProcessorRegisters(ghPartitionHandle, 0, &RegisterName, 1, &RegisterValue) != S_OK)
	{
		return 1;
	}

	return 0;
}

DWORD HypervisorUtils_SetRegisterValue_Segment(WHV_REGISTER_NAME RegisterName, WORD wSelector, DWORD dwCode)
{
	WHV_REGISTER_VALUE RegisterValue;

	// set segment register value
	memset(&RegisterValue, 0, sizeof(RegisterValue));
	RegisterValue.Segment.Selector = wSelector;
	RegisterValue.Segment.NonSystemSegment = 1;
	RegisterValue.Segment.DescriptorPrivilegeLevel = wSelector & 0x3;
	RegisterValue.Segment.Present = 1;
	if(dwCode == 0)
	{
		// data (write, accessed)
		RegisterValue.Segment.SegmentType = 0x3;
	}
	else
	{
		// code (execute, read, accessed)
		RegisterValue.Segment.SegmentType = 0xB;
		RegisterValue.Segment.Long = 1;
	}
	if(WHvSetVirtualProcessorRegisters(ghPartitionHandle, 0, &RegisterName, 1, &RegisterValue) != S_OK)
	{
		return 1;
	}

	return 0;
}

DWORD HypervisorUtils_GetRegisters(CpuRegisterStateStruct *pCpuRegisterState)
{
	CpuRegisterStateStruct CpuRegisterState;

	// get register values
	memset(&CpuRegisterState, 0, sizeof(CpuRegisterState));
	HypervisorUtils_GetRegisterValue_U64(WHvX64RegisterRax, &CpuRegisterState.RAX);
	HypervisorUtils_GetRegisterValue_U64(WHvX64RegisterRcx, &CpuRegisterState.RCX);
	HypervisorUtils_GetRegisterValue_U64(WHvX64RegisterRdx, &CpuRegisterState.RDX);
	HypervisorUtils_GetRegisterValue_U64(WHvX64RegisterRbx, &CpuRegisterState.RBX);
	HypervisorUtils_GetRegisterValue_U64(WHvX64RegisterRsp, &CpuRegisterState.RSP);
	HypervisorUtils_GetRegisterValue_U64(WHvX64RegisterRbp, &CpuRegisterState.RBP);
	HypervisorUtils_GetRegisterValue_U64(WHvX64RegisterRsi, &CpuRegisterState.RSI);
	HypervisorUtils_GetRegisterValue_U64(WHvX64RegisterRdi, &CpuRegisterState.RDI);
	HypervisorUtils_GetRegisterValue_U64(WHvX64RegisterR8, &CpuRegisterState.R8);
	HypervisorUtils_GetRegisterValue_U64(WHvX64RegisterR9, &CpuRegisterState.R9);
	HypervisorUtils_GetRegisterValue_U64(WHvX64RegisterR10, &CpuRegisterState.R10);
	HypervisorUtils_GetRegisterValue_U64(WHvX64RegisterR11, &CpuRegisterState.R11);
	HypervisorUtils_GetRegisterValue_U64(WHvX64RegisterR12, &CpuRegisterState.R12);
	HypervisorUtils_GetRegisterValue_U64(WHvX64RegisterR13, &CpuRegisterState.R13);
	HypervisorUtils_GetRegisterValue_U64(WHvX64RegisterR14, &CpuRegisterState.R14);
	HypervisorUtils_GetRegisterValue_U64(WHvX64RegisterR15, &CpuRegisterState.R15);
	HypervisorUtils_GetRegisterValue_U64(WHvX64RegisterRip, &CpuRegisterState.RIP);
	HypervisorUtils_GetRegisterValue_U64(WHvX64RegisterRflags, &CpuRegisterState.RFLAGS);
	memcpy(pCpuRegisterState, &CpuRegisterState, sizeof(CpuRegisterState));

	return 0;
}

DWORD HypervisorUtils_SetRegisters(CpuRegisterStateStruct *pCpuRegisterState)
{
	// set register values
	HypervisorUtils_SetRegisterValue_U64(WHvX64RegisterRax, pCpuRegisterState->RAX);
	HypervisorUtils_SetRegisterValue_U64(WHvX64RegisterRcx, pCpuRegisterState->RCX);
	HypervisorUtils_SetRegisterValue_U64(WHvX64RegisterRdx, pCpuRegisterState->RDX);
	HypervisorUtils_SetRegisterValue_U64(WHvX64RegisterRbx, pCpuRegisterState->RBX);
	HypervisorUtils_SetRegisterValue_U64(WHvX64RegisterRsp, pCpuRegisterState->RSP);
	HypervisorUtils_SetRegisterValue_U64(WHvX64RegisterRbp, pCpuRegisterState->RBP);
	HypervisorUtils_SetRegisterValue_U64(WHvX64RegisterRsi, pCpuRegisterState->RSI);
	HypervisorUtils_SetRegisterValue_U64(WHvX64RegisterRdi, pCpuRegisterState->RDI);
	HypervisorUtils_SetRegisterValue_U64(WHvX64RegisterR8, pCpuRegisterState->R8);
	HypervisorUtils_SetRegisterValue_U64(WHvX64RegisterR9, pCpuRegisterState->R9);
	HypervisorUtils_SetRegisterValue_U64(WHvX64RegisterR10, pCpuRegisterState->R10);
	HypervisorUtils_SetRegisterValue_U64(WHvX64RegisterR11, pCpuRegisterState->R11);
	HypervisorUtils_SetRegisterValue_U64(WHvX64RegisterR12, pCpuRegisterState->R12);
	HypervisorUtils_SetRegisterValue_U64(WHvX64RegisterR13, pCpuRegisterState->R13);
	HypervisorUtils_SetRegisterValue_U64(WHvX64RegisterR14, pCpuRegisterState->R14);
	HypervisorUtils_SetRegisterValue_U64(WHvX64RegisterR15, pCpuRegisterState->R15);
	HypervisorUtils_SetRegisterValue_U64(WHvX64RegisterRip, pCpuRegisterState->RIP);
	HypervisorUtils_SetRegisterValue_U64(WHvX64RegisterRflags, pCpuRegisterState->RFLAGS);

	return 0;
}

DWORD HypervisorUtils_MapGuestMemory(void *pHostVirtualAddress, void *pGuestPhysicalAddress, DWORD dwSize)
{
	// map virtual memory region from host process into the guest
	if(WHvMapGpaRange(ghPartitionHandle, pHostVirtualAddress, (WHV_GUEST_PHYSICAL_ADDRESS)pGuestPhysicalAddress, dwSize, WHvMapGpaRangeFlagRead | WHvMapGpaRangeFlagWrite | WHvMapGpaRangeFlagExecute) != S_OK)
	{
		return 1;
	}

	return 0;
}

DWORD HypervisorUtils_UnmapGuestMemory(void *pGuestPhysicalAddress, DWORD dwSize)
{
	// unmap region
	if(WHvUnmapGpaRange(ghPartitionHandle, (WHV_GUEST_PHYSICAL_ADDRESS)pGuestPhysicalAddress, dwSize) != S_OK)
	{
		return 1;
	}

	return 0;
}

DWORD HypervisorUtils_ResumeExecution(WHV_RUN_VP_EXIT_CONTEXT *pVmExitContext)
{
	// resume cpu execution until next vmexit event
	if(WHvRunVirtualProcessor(ghPartitionHandle, 0, pVmExitContext, sizeof(WHV_RUN_VP_EXIT_CONTEXT)) != S_OK)
	{
		return 1;
	}

	return 0;
}

DWORD HypervisorUtils_FlushTLB()
{
	// reset cr3 register to force a TLB flush
	HypervisorUtils_SetRegisterValue_U64(WHvX64RegisterCr3, PAGE_TABLE_BASE_PHYSICAL_ADDRESS);

	return 0;
}

```

`WinVisorDLL/InterruptHandler_Breakpoint.cpp`:

```cpp
#include "WinVisorDLL.h"

DWORD InterruptHandler_Breakpoint(CpuStateStruct *pCpuState, CpuRegisterStateStruct *pCpuRegisterState)
{
	// software breakpoint - skip over and continue
	WriteLog(LOG_INFO, "Caught breakpoint");

	return 0;
}

```

`WinVisorDLL/InterruptHandler_LegacySyscall.cpp`:

```cpp
#include "WinVisorDLL.h"

DWORD InterruptHandler_LegacySyscall(CpuStateStruct *pCpuState, CpuRegisterStateStruct *pCpuRegisterState)
{
	void *pUserStackPtr = NULL;

	// get user-mode RSP from kernel stack
	pUserStackPtr = (void*)*(UINT64*)(pCpuRegisterState->RSP + 0x18);

	// handle legacy syscall
	if(HandleGuestSyscall(pCpuState, pCpuRegisterState, pUserStackPtr) != 0)
	{
		return 1;
	}

	return 0;
}

```

`WinVisorDLL/InterruptHandler_SingleStep.cpp`:

```cpp
#include "WinVisorDLL.h"

DWORD InterruptHandler_SingleStep(CpuStateStruct *pCpuState, CpuRegisterStateStruct *pCpuRegisterState)
{
	void *pUserInstructionPtr = NULL;

	// get user-mode RIP from kernel stack
	pUserInstructionPtr = (void*)*(UINT64*)(pCpuRegisterState->RSP);

	WriteLog(LOG_INFO, "Single-step: 0x%p", pUserInstructionPtr);

	return 0;
}

```

`WinVisorDLL/Interrupts.cpp`:

```cpp
#include "WinVisorDLL.h"

BYTE gbInterruptRet_ErrorCode[] =
{
	// (some interrupts push an error code onto the stack, this must be removed before returning)
	// add rsp, 8
	0x48, 0x83, 0xC4, 0x08,
	// iretq
	0x48, 0xCF
};

BYTE gbInterruptRet[] =
{
	// iretq
	0x48, 0xCF
};

InterruptHandlerEntryStruct gInterruptHandlerList[] =
{
	{ 0x01, InterruptHandler_SingleStep, 0 },
	{ 0x03, InterruptHandler_Breakpoint, 0 },
	{ 0x2E, InterruptHandler_LegacySyscall, 0 },
};

InterruptHandlerEntryStruct *GetInterruptHandler(BYTE bInterruptIndex)
{
	// find interrupt handler for this index
	for(DWORD i = 0; i < sizeof(gInterruptHandlerList) / sizeof(gInterruptHandlerList[0]); i++)
	{
		if(gInterruptHandlerList[i].bInterruptIndex == bInterruptIndex)
		{
			// found
			return &gInterruptHandlerList[i];
		}
	}

	// not found
	return NULL;
}

BYTE *GetInterruptReturn(InterruptHandlerEntryStruct *pInterruptHandlerEntry)
{
	if(pInterruptHandlerEntry->dwHasErrorCode != 0)
	{
		// this interrupt type has an error code - stack must be adjusted before returning
		return gbInterruptRet_ErrorCode;
	}

	// no error code
	return gbInterruptRet;
}

```

`WinVisorDLL/LogServer.cpp`:

```cpp
#include "WinVisorDLL.h"

DWORD gdwStopLog = 0;
DWORD gdwDebugLogEnabled = 0;
HANDLE ghLogPipe = NULL;

DWORD InitialiseLogServer()
{
	char szPipeName[512];

	// append PID to pipe name to allow multiple instances
	memset(szPipeName, 0, sizeof(szPipeName));
	_snprintf(szPipeName, sizeof(szPipeName) - 1, "%s_%u", LOG_PIPE_NAME, GetCurrentProcessId());

	// create logging pipe
	ghLogPipe = CreateNamedPipeA(szPipeName, PIPE_ACCESS_OUTBOUND, PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT, 1, 0, 0, 0, NULL);
	if(ghLogPipe == INVALID_HANDLE_VALUE)
	{
		return 1;
	}

	// wait for child process to connect
	ConnectNamedPipe(ghLogPipe, NULL);

	return 0;
}

DWORD CloseLogServer()
{
	if(ghLogPipe != NULL)
	{
		// close log pipe
		CloseHandle(ghLogPipe);
	}

	return 0;
}

DWORD WriteLog(DWORD dwLogType, char *pStringFormat, ...)
{
	va_list VaList;
	char szFormattedString[1024];
	char szFullMsg[2048];
	DWORD dwWritten = 0;
	char *pLogType = NULL;

	// format string
	va_start(VaList, pStringFormat);
	memset(szFormattedString, 0, sizeof(szFormattedString));
	_vsnprintf(szFormattedString, sizeof(szFormattedString) - 1, pStringFormat, VaList);
	va_end(VaList);

	// check type
	if(dwLogType == LOG_INFO)
	{
		pLogType = "INFO";
	}
	else if(dwLogType == LOG_ERROR)
	{
		pLogType = "ERROR";
	}
	else if(dwLogType == LOG_DEBUG)
	{
		if(gdwDebugLogEnabled == 0)
		{
			// debug logging disabled
			return 1;
		}

		pLogType = "DEBUG";
	}
	else
	{
		return 1;
	}

	// generate full log message
	memset(szFullMsg, 0, sizeof(szFullMsg));
	_snprintf(szFullMsg, sizeof(szFullMsg) - 1, "[%s] %s\n", pLogType, szFormattedString);

	if(gdwStopLog == 0)
	{
		// write to pipe
		WriteFile(ghLogPipe, szFullMsg, (DWORD)strlen(szFullMsg), &dwWritten, NULL);
	}

	return 0;
}

```

`WinVisorDLL/Main.cpp`:

```cpp
#include "WinVisorDLL.h"

#ifndef _WIN64
#error Must be compiled as 64-bit
#endif

HMODULE ghNtdllBase = NULL;
DWORD (WINAPI *pNtQueryInformationThread)(HANDLE ThreadHandle, DWORD ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength, PULONG ReturnLength) = NULL;
DWORD (WINAPI *pNtQuerySystemInformation)(DWORD SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength) = NULL;

DWORD StartHypervisor_Initialise(WinVisorStartDataStruct *pWinVisorStartData, CpuStateStruct **ppCpuState)
{
	CpuStateStruct *pCpuState = NULL;

	// check if the "debug" command-line switch was specified
	if(pWinVisorStartData->qwWinVisorFlags & WINVISOR_FLAG_DEBUG_LOG)
	{
		gdwDebugLogEnabled = 1;
	}

	// check if the "imports" command-line switch was specified
	if(pWinVisorStartData->qwWinVisorFlags & WINVISOR_FLAG_IMPORTS)
	{
		gdwLogImportSyscallsEnabled = 1;
	}

	// get ntdll base
	ghNtdllBase = GetModuleHandleA("ntdll.dll");

	// get NtQueryInformationThread ptr
	pNtQueryInformationThread = (DWORD(WINAPI*)(HANDLE,DWORD,PVOID,ULONG,PULONG))GetProcAddress(ghNtdllBase, "NtQueryInformationThread");
	if(pNtQueryInformationThread == NULL)
	{
		return 1;
	}

	// get NtQuerySystemInformation ptr
	pNtQuerySystemInformation = (DWORD(WINAPI*)(DWORD,PVOID,ULONG,PULONG))GetProcAddress(ghNtdllBase, "NtQuerySystemInformation");
	if(pNtQuerySystemInformation == NULL)
	{
		return 1;
	}

	// initialise log pipe
	if(InitialiseLogServer() != 0)
	{
		return 1;
	}

	WriteLog(LOG_INFO, "Starting...");

	// initialise hypervisor platform api
	if(HypervisorUtils_Initialise() != 0)
	{
		WriteLog(LOG_ERROR, "Failed to initialise Windows Hypervisor Platform API");
		return 1;
	}

	// initialise virtual CPU
	if(HypervisorUtils_CreateEnvironment() != 0)
	{
		WriteLog(LOG_ERROR, "Failed to create hypervisor environment");
		return 1;
	}

	// populate list of syscall names / param counts
	if(CreateSyscallLists() != 0)
	{
		WriteLog(LOG_ERROR, "Failed to create syscall lists");
		return 1;
	}

	// allocate page tables
	if(CreatePageTables() != 0)
	{
		WriteLog(LOG_ERROR, "Failed to create page tables");
		return 1;
	}

	// prepare environment
	pCpuState = CreateCpuState(pWinVisorStartData);
	if(pCpuState == NULL)
	{
		WriteLog(LOG_ERROR, "Failed to create initial CPU state");
		return 1;
	}

	// store cpu state object ptr
	*ppCpuState = pCpuState;

	return 0;
}

DWORD StartHypervisor_Cleanup(CpuStateStruct *pCpuState, DWORD dwIgnoreHypervisorEnvironment)
{
	// clean up - all of these functions must succeed even if they haven't yet been initialised
	DeleteCpuState(pCpuState);
	DeletePageTables();
	DeleteSyscallLists();
	if(dwIgnoreHypervisorEnvironment == 0)
	{
		HypervisorUtils_DeleteEnvironment();
	}
	CloseLogServer();

	return 0;
}

extern "C" __declspec(dllexport) DWORD StartHypervisor(WinVisorStartDataStruct *pWinVisorStartData)
{
	CpuStateStruct *pCpuState = NULL;
	CpuRegisterStateStruct CpuRegisterState;
	WHV_RUN_VP_EXIT_CONTEXT VmExitContext;

	// initialise hypervisor
	if(StartHypervisor_Initialise(pWinVisorStartData, &pCpuState) != 0)
	{
		WriteLog(LOG_ERROR, "Failed to start hypervisor");
		StartHypervisor_Cleanup(NULL, 0);
		return 1;
	}

	// begin execution
	WriteLog(LOG_INFO, "Launching virtual CPU...");
	for(;;)
	{
		// resume virtual CPU
		memset(&VmExitContext, 0, sizeof(VmExitContext));
		if(HypervisorUtils_ResumeExecution(&VmExitContext) != 0)
		{
			// error
			break;
		}

		// caught vmexit - get register values
		HypervisorUtils_GetRegisters(&CpuRegisterState);

		// handle vmexit
		if(HandleVmExit(pCpuState, &CpuRegisterState, &VmExitContext) != 0)
		{
			// error (or guest process exited)
			break;
		}

		// update register values
		HypervisorUtils_SetRegisters(&CpuRegisterState);
	}

	// clean up - HypervisorUtils_DeleteEnvironment is intentionally skipped here.
	// the guest process may have left the CRT in an unknown state after exiting which can lead to deadlocks within the hypervisor platform module.
	// clean up local objects and then terminate the process immediately to prevent any potential issues.
	StartHypervisor_Cleanup(pCpuState, 1);
	TerminateProcess(GetCurrentProcess(), 0);

	return 0;
}

```

`WinVisorDLL/Misc.cpp`:

```cpp
#include "WinVisorDLL.h"

IMAGE_NT_HEADERS *GetNtHeader(VOID *pModuleBase)
{
	IMAGE_DOS_HEADER *pImageDosHeader = NULL;
	IMAGE_NT_HEADERS *pImageNtHeader = NULL;

	// get dos header
	pImageDosHeader = (IMAGE_DOS_HEADER*)pModuleBase;
	if(pImageDosHeader->e_magic != IMAGE_DOS_SIGNATURE)
	{
		return NULL;
	}

	// get nt header
	pImageNtHeader = (IMAGE_NT_HEADERS*)((BYTE*)pModuleBase + pImageDosHeader->e_lfanew);
	if(pImageNtHeader->Signature != IMAGE_NT_SIGNATURE)
	{
		return NULL;
	}

	return pImageNtHeader;
}

DWORD ValidateReadPointer(VOID *pAddress, SIZE_T dwLength)
{
	BYTE *pCurrPtr = NULL;
	MEMORY_BASIC_INFORMATION MemoryBasicInfo;

	pCurrPtr = (BYTE*)pAddress;
	for(SIZE_T i = 0; i < dwLength; i++)
	{
		if(i == 0 || ((UINT64)pCurrPtr % PAGE_SIZE) == 0)
		{
			memset(&MemoryBasicInfo, 0, sizeof(MemoryBasicInfo));
			if(VirtualQuery(pCurrPtr, &MemoryBasicInfo, sizeof(MemoryBasicInfo)) != sizeof(MemoryBasicInfo))
			{
				return 1;
			}

			if(MemoryBasicInfo.State != MEM_COMMIT)
			{
				return 1;
			}

			if(MemoryBasicInfo.Protect & PAGE_NOACCESS)
			{
				return 1;
			}

			if(MemoryBasicInfo.Protect & PAGE_GUARD)
			{
				return 1;
			}
		}

		pCurrPtr++;
	}

	return 0;
}

DWORD CopyMemoryAndRestoreProtection(VOID *pDestination, VOID *pSource, DWORD dwLength)
{
	DWORD dwOrigProtect = 0;

	// make region writable
	if(VirtualProtect(pDestination, dwLength, PAGE_READWRITE, &dwOrigProtect) == 0)
	{
		return 1;
	}

	// copy data
	memcpy(pDestination, pSource, dwLength);

	// restore original protection
	if(VirtualProtect(pDestination, dwLength, dwOrigProtect, &dwOrigProtect) == 0)
	{
		return 1;
	}

	return 0;
}

DWORD AppendString(char *pString, SIZE_T dwMaxLength, char *pAppend)
{
	SIZE_T dwOrigLength = 0;
	SIZE_T dwAppendLength = 0;
	SIZE_T dwNewLength = 0;

	// get lengths
	dwOrigLength = strlen(pString);
	dwAppendLength = strlen(pAppend);

	// validate new length
	dwNewLength = dwOrigLength + dwAppendLength;
	if(dwNewLength > dwMaxLength)
	{
		return 1;
	}

	// append data
	memcpy((pString + dwOrigLength), pAppend, dwAppendLength);

	// add null terminator if the buffer is not full.
	// if the maximum length has been reached, it isn't necessary to add a null-terminator.
	// it is assumed that the maximum specified length is [sizeof(buffer)-1] and the final character is already a null.
	if(dwNewLength != dwMaxLength)
	{
		*(BYTE*)((BYTE*)pString + dwNewLength) = '\0';
	}

	return 0;
}

DWORD ExecXGETBV(DWORD dwIndex, QWORD *pqwReturnValue)
{
	VOID *pCode = NULL;
	UINT64 qwReturnValue = 0;
	BYTE bXGETBV[] =
	{
		// xgetbv
		0x0F, 0x01, 0xD0,
		// shl rdx, 0x20
		0x48, 0xC1, 0xE2, 0x20,
		// add rdx, rax
		0x48, 0x01, 0xC2,
		// mov rax, rdx
		0x48, 0x89, 0xD0,
		// ret
		0xC3
	};

	// allocate code
	pCode = VirtualAlloc(NULL, sizeof(bXGETBV), MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if(pCode == NULL)
	{
		return 1;
	}

	// execute syscall
	memcpy(pCode, bXGETBV, sizeof(bXGETBV));
	qwReturnValue = ((UINT64(*)(DWORD))pCode)(dwIndex);

	// free temporary memory
	VirtualFree(pCode, 0, MEM_RELEASE);

	// store return value
	*pqwReturnValue = qwReturnValue;

	return 0;
}

```

`WinVisorDLL/PageFault.cpp`:

```cpp
#include "WinVisorDLL.h"

DWORD HandlePageFault_CheckSpecialAddress(CpuStateStruct *pCpuState, CpuRegisterStateStruct *pCpuRegisterState, DWORD *pdwHandled)
{
	DWORD dwHandled = 0;
	BYTE bInterruptIndex = 0;
	InterruptHandlerEntryStruct *pInterruptHandler = NULL;

	// check if the page-fault occurred on a special address
	dwHandled = 1;
	if(pCpuRegisterState->RIP == SYSCALL_VIRTUAL_ADDRESS)
	{
		// syscall instruction
		if(HandleSyscallInstruction(pCpuState, pCpuRegisterState) != 0)
		{
			WriteLog(LOG_ERROR, "Failed to handle syscall");
			return 1;
		}
	}
	else if(pCpuRegisterState->RIP == CPL3_ENTRY_VIRTUAL_ADDRESS)
	{
		WriteLog(LOG_INFO, "Bootloader complete, transitioning to CPL3...");

		// copy CPL3 entry context
		memcpy((void*)pCpuRegisterState, (void*)&pCpuState->CPL3_InitialCpuRegisterState, sizeof(pCpuState->CPL3_InitialCpuRegisterState));
	}
	else if((pCpuRegisterState->RIP >= INTERRUPT_HANDLER_VIRTUAL_ADDRESS) && (pCpuRegisterState->RIP < (INTERRUPT_HANDLER_VIRTUAL_ADDRESS + MAX_IDT_ENTRY_COUNT)))
	{
		// find interrupt handler
		bInterruptIndex = (BYTE)(pCpuRegisterState->RIP - INTERRUPT_HANDLER_VIRTUAL_ADDRESS);
		pInterruptHandler = GetInterruptHandler(bInterruptIndex);
		if(pInterruptHandler == NULL)
		{
			WriteLog(LOG_ERROR, "Unhandled interrupt: 0x%02X", bInterruptIndex);
			return 1;
		}

		// execute handler
		if(pInterruptHandler->pHandler(pCpuState, pCpuRegisterState) != 0)
		{
			WriteLog(LOG_ERROR, "Interrupt handler error: 0x%02X", bInterruptIndex);
			return 1;
		}

		// return from interrupt
		pCpuRegisterState->RIP = (UINT64)GetInterruptReturn(pInterruptHandler);
	}
	else
	{
		// not handled
		dwHandled = 0;
	}

	*pdwHandled = dwHandled;

	return 0;
}

DWORD HandlePageFault(CpuStateStruct *pCpuState, CpuRegisterStateStruct *pCpuRegisterState, UINT64 qwVirtualAddress)
{
	DWORD dwHandled = 0;

	// check if this is a special (reserved) address
	if(HandlePageFault_CheckSpecialAddress(pCpuState, pCpuRegisterState, &dwHandled) != 0)
	{
		return 1;
	}

	// if not, treat this as a standard page-fault and attempt to page it into memory
	if(dwHandled == 0)
	{
		// WHvMapGpaRange allows an invalid virtual address to be mapped into the guest without any errors - it will only throw an error when it attempts to read from it later.
		// manually validate the target address within the current process first - this makes it easier to debug.
		if(ValidateReadPointer((void*)qwVirtualAddress, 1) != 0)
		{
			WriteLog(LOG_ERROR, "Attempt to access invalid virtual address: 0x%p (RIP: 0x%p)", qwVirtualAddress, pCpuRegisterState->RIP);
			return 1;
		}

		WriteLog(LOG_DEBUG, "Caught page fault: 0x%p (RIP: 0x%p)", qwVirtualAddress, pCpuRegisterState->RIP);	

		// add this page to the mapped page table
		if(AddPagedVirtualAddress(qwVirtualAddress) != 0)
		{
			WriteLog(LOG_ERROR, "Failed to add paged virtual address: 0x%p (RIP: 0x%p)", qwVirtualAddress, pCpuRegisterState->RIP);
			return 1;
		}
	}
	
	return 0;
}

```

`WinVisorDLL/PageTable.cpp`:

```cpp
#include "WinVisorDLL.h"

void *gpPageTableBase = NULL;
DWORD gdwPageTableAllocSize = 0;

MappedVirtualAddressStruct gPagedVirtualAddressList[MAX_MAPPED_PAGE_COUNT];

QWORD gqwCurrPagedVirtualAddressListCreationIndex = 0;

DWORD GetVirtualAddressTableIndexes(UINT64 qwVirtualAddress, VirtualAddressTableIndexesStruct *pVirtualAddressTableIndexes)
{
	// virtual address must be canonical (bits 48-63 must match bit 47)
	if((qwVirtualAddress >> 48) != (WORD)(0 - ((qwVirtualAddress >> 47) & 1)))
	{
		return 1;
	}

	// extract page table indexes from virtual address
	pVirtualAddressTableIndexes->wOffset = (WORD)(qwVirtualAddress & 0xFFF);
	pVirtualAddressTableIndexes->wPT = (WORD)((qwVirtualAddress >> 12) & 0x1FF);
	pVirtualAddressTableIndexes->wPD = (WORD)((qwVirtualAddress >> 21) & 0x1FF);
	pVirtualAddressTableIndexes->wPDPT = (WORD)((qwVirtualAddress >> 30) & 0x1FF);
	pVirtualAddressTableIndexes->wPML4 = (WORD)((qwVirtualAddress >> 39) & 0x1FF);

	return 0;
}

DWORD ResetPageTable(PageTableStruct *pPageTable)
{
	// clear all entries within the specified page table
	for(DWORD i = 0; i < 512; i++)
	{
		pPageTable->qwEntries[i] = 0;
	}

	return 0;
}

PageTableStruct *GetNextTableLevel(PagingStateStruct *pPagingState, PageTableStruct *pPageTable, WORD wIndex)
{
	UINT64 qwTempPhysicalAddress = 0;
	PageTableStruct *pNextPageTable = NULL;

	// check if a child entry already exists for this index
	if(pPageTable->qwEntries[wIndex] != 0)
	{
		qwTempPhysicalAddress = ((pPageTable->qwEntries[wIndex] >> 12) & 0xFFFFFF) * 0x1000;
		pNextPageTable = (PageTableStruct*)((BYTE*)gpPageTableBase + qwTempPhysicalAddress - PAGE_TABLE_BASE_PHYSICAL_ADDRESS);
	}
	else
	{
		// create a new entry
		if(pPagingState->dwNextEntryIndex >= pPagingState->dwTotalEntryCount)
		{
			return NULL;
		}
		pNextPageTable = (PageTableStruct*)((BYTE*)gpPageTableBase + (pPagingState->dwNextEntryIndex * sizeof(PageTableStruct)));
		pPageTable->qwEntries[wIndex] = (PAGE_TABLE_BASE_PHYSICAL_ADDRESS + (pPagingState->dwNextEntryIndex * sizeof(PageTableStruct))) | PAGE_PRESENT | PAGE_WRITABLE | PAGE_USER;
		pPagingState->dwNextEntryIndex++;
		ResetPageTable(pNextPageTable);
	}

	return pNextPageTable;
}

DWORD CreatePageTables()
{
	// allocate page tables (PML4 + all possible tables for next 3 levels)
	gdwPageTableAllocSize = sizeof(PageTableStruct) + (MAX_MAPPED_PAGE_COUNT * (3 * sizeof(PageTableStruct)));
	gpPageTableBase = VirtualAlloc(NULL, gdwPageTableAllocSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	if(gpPageTableBase == NULL)
	{
		return 1;
	}

	// map page tables into the guest at a fixed physical address
	if(HypervisorUtils_MapGuestMemory(gpPageTableBase, (void*)PAGE_TABLE_BASE_PHYSICAL_ADDRESS, gdwPageTableAllocSize) != 0)
	{
		DeletePageTables();
		return 1;
	}

	// initialise mapped address list
	memset(gPagedVirtualAddressList, 0, sizeof(gPagedVirtualAddressList));
	for(DWORD i = 0; i < MAX_MAPPED_PAGE_COUNT; i++)
	{
		gPagedVirtualAddressList[i].dwInUse = 0;
		gPagedVirtualAddressList[i].qwCreationIndex = 0;
		gPagedVirtualAddressList[i].qwVirtualAddress = 0;
		gPagedVirtualAddressList[i].qwPhysicalAddress = PAGE_TABLE_BASE_PHYSICAL_ADDRESS + gdwPageTableAllocSize + (i * PAGE_SIZE);
	}

	return 0;
}

DWORD DeletePageTables()
{
	if(gpPageTableBase != NULL)
	{
		// free memory
		VirtualFree(gpPageTableBase, 0, MEM_RELEASE);
	}

	return 0;
}

DWORD RebuildPageTables()
{
	PageTableStruct *pPML4 = NULL;
	PageTableStruct *pPDPT = NULL;
	PageTableStruct *pPD = NULL;
	PageTableStruct *pPT = NULL;
	VirtualAddressTableIndexesStruct VirtualAddressTableIndexes;
	PagingStateStruct PagingState;

	// reset PML4
	pPML4 = (PageTableStruct*)gpPageTableBase;
	ResetPageTable(pPML4);

	// initialise state
	memset(&PagingState, 0, sizeof(PagingState));
	PagingState.dwTotalEntryCount = (gdwPageTableAllocSize / 0x1000);
	PagingState.dwNextEntryIndex = 1;

	// rebuild page tables
	for(DWORD i = 0; i < MAX_MAPPED_PAGE_COUNT; i++)
	{
		if(gPagedVirtualAddressList[i].dwInUse == 0)
		{
			continue;
		}

		// extract table indexes from current virtual address
		memset(&VirtualAddressTableIndexes, 0, sizeof(VirtualAddressTableIndexes));
		if(GetVirtualAddressTableIndexes(gPagedVirtualAddressList[i].qwVirtualAddress, &VirtualAddressTableIndexes) != 0)
		{
			return 1;
		}

		// navigate to the final level of the paging table
		pPDPT = GetNextTableLevel(&PagingState, pPML4, VirtualAddressTableIndexes.wPML4);
		pPD = GetNextTableLevel(&PagingState, pPDPT, VirtualAddressTableIndexes.wPDPT);
		pPT = GetNextTableLevel(&PagingState, pPD, VirtualAddressTableIndexes.wPD);

		// set mirrored page physical address
		pPT->qwEntries[VirtualAddressTableIndexes.wPT] = gPagedVirtualAddressList[i].qwPhysicalAddress | PAGE_PRESENT | PAGE_WRITABLE | PAGE_USER;
	}

	// flush TLB
	HypervisorUtils_FlushTLB();

	return 0;
}

DWORD AddPagedVirtualAddress(UINT64 qwVirtualAddress)
{
	QWORD qwVirtualAddressPage = 0;
	MappedVirtualAddressStruct *pFreeEntry = NULL;
	MappedVirtualAddressStruct *pOldestEntry = NULL;

	// round virtual address down to page base
	qwVirtualAddressPage = qwVirtualAddress & ~0xFFF;

	// check if this page is already mapped
	for(DWORD i = 0; i < MAX_MAPPED_PAGE_COUNT; i++)
	{
		if(gPagedVirtualAddressList[i].dwInUse == 0)
		{
			continue;
		}

		if(gPagedVirtualAddressList[i].qwVirtualAddress == qwVirtualAddressPage)
		{
			// this entry is already paged in - unknown error
			return 1;
		}
	}

	// check for a free entry in the list
	for(DWORD i = 0; i < MAX_MAPPED_PAGE_COUNT; i++)
	{
		if(gPagedVirtualAddressList[i].dwInUse == 0)
		{
			pFreeEntry = &gPagedVirtualAddressList[i];
			break;
		}
	}

	if(pFreeEntry == NULL)
	{
		// list is full - find the oldest entry and remove it
		for(DWORD i = 0; i < MAX_MAPPED_PAGE_COUNT; i++)
		{
			if(gPagedVirtualAddressList[i].dwInUse == 0)
			{
				continue;
			}

			if(pOldestEntry == NULL)
			{
				pOldestEntry = &gPagedVirtualAddressList[i];
			}
			else
			{
				if(gPagedVirtualAddressList[i].qwCreationIndex < pOldestEntry->qwCreationIndex)
				{
					pOldestEntry = &gPagedVirtualAddressList[i];
				}
			}
		}

		if(pOldestEntry == NULL)
		{
			return 1;
		}

		// remove oldest entry
		HypervisorUtils_UnmapGuestMemory((void*)pOldestEntry->qwPhysicalAddress, PAGE_SIZE);
		pOldestEntry->dwInUse = 0;
		pFreeEntry = pOldestEntry;
	}

	// map page into guest
	if(HypervisorUtils_MapGuestMemory((void*)qwVirtualAddressPage, (void*)pFreeEntry->qwPhysicalAddress, PAGE_SIZE) != 0)
	{
		return 1;
	}

	// store current entry in list
	pFreeEntry->dwInUse = 1;
	pFreeEntry->qwVirtualAddress = qwVirtualAddressPage;
	pFreeEntry->qwCreationIndex = gqwCurrPagedVirtualAddressListCreationIndex;
	gqwCurrPagedVirtualAddressListCreationIndex++;

	// rebuild page tables
	if(RebuildPageTables() != 0)
	{
		return 1;
	}

	return 0;
}

```

`WinVisorDLL/PrepareCPL0.cpp`:

```cpp
#include "WinVisorDLL.h"

BootloaderParamsStruct gCPL0_BootloaderParams;

BYTE gbCPL0_BootloaderCode[] =
{
	// (store BootloaderParams ptr)
	// mov rdi, rcx
	0x48, 0x89, 0xCF,

	// lgdt tword ptr [rdi + 0x06] (BootloaderParams.qwGDT_Limit + BootloaderParams.qwGDT_Base)
	0x0F, 0x01, 0x57, 0x06,

	// lidt tword ptr [rdi + 0x16] (BootloaderParams.qwIDT_Limit + BootloaderParams.qwIDT_Base)
	0x0F, 0x01, 0x5F, 0x16,

	// (set TSS selector index)
	// mov ax, word ptr [rdi + 0x20] (BootloaderParams.qwTSS_Selector)
	0x66, 0x8B, 0x47, 0x20,
	// ltr ax
	0x0F, 0x00, 0xD8,

	// (update XCR0 value to match host - this enables AVX etc)
	// xor rcx, rcx
	0x48, 0x31, 0xC9,
	// mov edx, dword ptr [rdi + 0x2C] (BootloaderParams.qwXCR0 - HIGH)
	0x8B, 0x57, 0x2C,
	// mov eax, dword ptr [rdi + 0x28] (BootloaderParams.qwXCR0 - LOW)
	0x8B, 0x47, 0x28,
	// xsetbv
	0x0F, 0x01, 0xD1,

	// (enter CPL3 code)
	// mov ax, word ptr [rdi + 0x30] (BootloaderParams.qwCPL3_DataSelector)
	0x66, 0x8B, 0x47, 0x30,
	// mov ds, ax
	0x66, 0x8E, 0xD8,
	// mov es, ax
	0x66, 0x8E, 0xC0,
	// mov gs, ax
	0x66, 0x8E, 0xE8,
	// swapgs
	0x0F, 0x01, 0xF8,
	// mov rcx, qword ptr [rdi + 0x40] (BootloaderParams.qwCPL3_EntryPlaceholderAddress)
	0x48, 0x8B, 0x4F, 0x40,
	// mov r11, qword ptr [rdi + 0x38] (BootloaderParams.qwCPL3_RFLAGS)
	0x4C, 0x8B, 0x5F, 0x38,
	// sysret
	0x48, 0x0F, 0x07
};

DWORD PrepareCPL0(CpuStateStruct *pCpuState)
{
	CpuRegisterStateStruct InitialCpuRegisterState;
	WORD wCodeSelector = 0;
	UINT64 qwHandlerAddress = 0;
	UINT64 qwXCR0 = 0;

	// allocate CPL0 stack
	pCpuState->pCPL0_Stack = VirtualAlloc(NULL, CPL0_STACK_SIZE, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	if(pCpuState->pCPL0_Stack == NULL)
	{
		return 1;
	}

	// create GDT
	// 0 / 0x0000 (null)
	// 1 / 0x0008 (reserved)
	// 2 / 0x0010 (ring0 code)
	// 3 / 0x0018 (ring0 data)
	// 4 / 0x0020 (reserved - wow64)
	// 5 / 0x0028 (ring3 data)
	// 6 / 0x0030 (ring3 code)
	// 7 / 0x0038 (reserved)
	// 8 / 0x0040 (TSS)
	// 9 / 0x0048 (TSS continued)
	// 10 / 0x0050 (reserved - wow64)
	pCpuState->GDT[0] = 0;
	pCpuState->GDT[1] = 0;
	pCpuState->GDT[2] = GDT_PRESENT | GDT_DPL0 | GDT_NON_SYSTEM | GDT_CODE | GDT_CODE_READ | GDT_ACCESSED | GDT_LONG;
	pCpuState->GDT[3] = GDT_PRESENT | GDT_DPL0 | GDT_NON_SYSTEM | GDT_DATA | GDT_DATA_WRITE | GDT_ACCESSED;
	pCpuState->GDT[4] = 0;
	pCpuState->GDT[5] = GDT_PRESENT | GDT_DPL3 | GDT_NON_SYSTEM | GDT_DATA | GDT_DATA_WRITE | GDT_ACCESSED;
	pCpuState->GDT[6] = GDT_PRESENT | GDT_DPL3 | GDT_NON_SYSTEM | GDT_CODE | GDT_CODE_READ | GDT_ACCESSED | GDT_LONG;
	pCpuState->GDT[7] = 0;
	pCpuState->GDT[8] = GDT_PRESENT | GDT_TSS | GDT_DB | (sizeof(pCpuState->TSS) - 1) | (((UINT64)&pCpuState->TSS[0] & 0xFFFFFF) << 16) | ((((UINT64)&pCpuState->TSS[0] >> 24) & 0xFF) << 56);
	pCpuState->GDT[9] = ((UINT64)&pCpuState->TSS[0] >> 32);
	pCpuState->GDT[10] = 0;

	// create IDT - set all interrupts to placeholder address (INTERRUPT_HANDLER_VIRTUAL_ADDRESS + index)
	for(DWORD i = 0; i < MAX_IDT_ENTRY_COUNT; i++)
	{
		// set current entry
		wCodeSelector = SEGMENT_SELECTOR_CODE_CPL0;
		qwHandlerAddress = INTERRUPT_HANDLER_VIRTUAL_ADDRESS + i;
		pCpuState->IDT[i].Low = (qwHandlerAddress & 0xFFFF) | (((qwHandlerAddress >> 16) & 0xFFFF) << 48) | (wCodeSelector << 16) | IDT_INTERRUPT_GATE | IDT_DPL3 | IDT_PRESENT;
		pCpuState->IDT[i].High = (qwHandlerAddress >> 32);
	}

	// set TSS values (RSP0 only)
	memset(pCpuState->TSS, 0, sizeof(pCpuState->TSS));
	*(UINT64*)&pCpuState->TSS[4] = (UINT64)pCpuState->pCPL0_Stack + CPL0_STACK_SIZE;

	// set control registers
	HypervisorUtils_SetRegisterValue_U64(WHvX64RegisterCr0, CR0_PROTECTED_MODE | CR0_PAGING | CR0_COPROCESSOR_MONITORING);
	HypervisorUtils_SetRegisterValue_U64(WHvX64RegisterCr3, PAGE_TABLE_BASE_PHYSICAL_ADDRESS);
	HypervisorUtils_SetRegisterValue_U64(WHvX64RegisterCr4, CR4_PAE | CR4_OSFXSR | CR4_OSXSAVE);

	// set EFER
	HypervisorUtils_SetRegisterValue_U64(WHvX64RegisterEfer, EFER_SYSCALL_ENABLE | EFER_LONG_MODE_ENABLE | EFER_LONG_MODE_ACTIVE | EFER_NX_ENABLE);

	// set STAR/LSTAR MSRs for syscalls
	HypervisorUtils_SetRegisterValue_U64(WHvX64RegisterStar, ((UINT64)SEGMENT_SELECTOR_CODE_CPL0 << 32) | ((UINT64)(SEGMENT_SELECTOR_CODE_CPL3 - 0x10) << 48));
	HypervisorUtils_SetRegisterValue_U64(WHvX64RegisterLstar, SYSCALL_VIRTUAL_ADDRESS);

	// set KERNEL_GS_BASE to TEB base (swapgs will swap this value to user-mode later)
	HypervisorUtils_SetRegisterValue_U64(WHvX64RegisterKernelGsBase, (UINT64)pCpuState->pHostThreadTEB);

	// set CPL0 selectors
	HypervisorUtils_SetRegisterValue_Segment(WHvX64RegisterCs, SEGMENT_SELECTOR_CODE_CPL0, 1);
	HypervisorUtils_SetRegisterValue_Segment(WHvX64RegisterSs, SEGMENT_SELECTOR_DATA_CPL0, 0);

	// get XCR0 from host
	if(ExecXGETBV(0, &qwXCR0) != 0)
	{
		return 1;
	}

	// set bootloader params
	memset(&gCPL0_BootloaderParams, 0, sizeof(gCPL0_BootloaderParams));
	gCPL0_BootloaderParams.qwGDT_Limit = (sizeof(pCpuState->GDT) - 1) << TABLE_REGISTER_LIMIT_SHIFT;
	gCPL0_BootloaderParams.qwGDT_Base = (UINT64)&pCpuState->GDT[0];
	gCPL0_BootloaderParams.qwIDT_Limit = (sizeof(pCpuState->IDT) - 1) << TABLE_REGISTER_LIMIT_SHIFT;
	gCPL0_BootloaderParams.qwIDT_Base = (UINT64)&pCpuState->IDT[0];
	gCPL0_BootloaderParams.qwTSS_Selector = SEGMENT_SELECTOR_TSS;
	gCPL0_BootloaderParams.qwCPL3_DataSelector = SEGMENT_SELECTOR_DATA_CPL3;
	gCPL0_BootloaderParams.qwCPL3_RFLAGS = CPL3_INITIAL_RFLAGS;
	gCPL0_BootloaderParams.qwCPL3_EntryPlaceholderAddress = CPL3_ENTRY_VIRTUAL_ADDRESS;
	gCPL0_BootloaderParams.qwXCR0 = qwXCR0;

	// execute CPL0 bootloader first
	memset(&InitialCpuRegisterState, 0, sizeof(InitialCpuRegisterState));
	InitialCpuRegisterState.RFLAGS = EFLAGS_RESERVED_ALWAYS_ON;
	InitialCpuRegisterState.RIP = (UINT64)gbCPL0_BootloaderCode;
	InitialCpuRegisterState.RCX = (UINT64)&gCPL0_BootloaderParams;

	// set initial registers
	HypervisorUtils_SetRegisters(&InitialCpuRegisterState);

	return 0;
}

```

`WinVisorDLL/PrepareCPL3.cpp`:

```cpp
#include "WinVisorDLL.h"

HMODULE ghExeBase = NULL;

DWORD PrepareCPL3_FixExecutable(WinVisorStartDataStruct *pWinVisorStartData, VOID **ppEntryPoint)
{
	IMAGE_NT_HEADERS64 *pExeNtHeader = NULL;
	VOID *pEntryPoint = NULL;
	IMAGE_DATA_DIRECTORY *pExeDataDirectory = NULL;
	IMAGE_DATA_DIRECTORY *pOrigExeDataDirectory = NULL;
	DWORD dwOrigProtect = 0;

	// get entry-point for main executable
	pExeNtHeader = GetNtHeader(ghExeBase);
	if(pExeNtHeader == NULL)
	{
		return 1;
	}
	pEntryPoint = (BYTE*)ghExeBase + pExeNtHeader->OptionalHeader.AddressOfEntryPoint;

	// check if the "nx" command-line switch was specified
	if(pWinVisorStartData->qwWinVisorFlags & WINVISOR_FLAG_NX)
	{
		// remove executable flag from all pages within the exe image
		if(VirtualProtect(ghExeBase, pExeNtHeader->OptionalHeader.SizeOfImage, PAGE_READWRITE, &dwOrigProtect) == 0)
		{
			return 1;
		}
	}

	// restore original entry-point code (this was temporarily overwritten by the WinVisor exe to load this DLL)
	if(CopyMemoryAndRestoreProtection(pEntryPoint, pWinVisorStartData->bOrigEntryPointCode, sizeof(pWinVisorStartData->bOrigEntryPointCode)) != 0)
	{
		return 1;
	}

	// restore import table data directory entry
	pExeDataDirectory = &pExeNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
	pOrigExeDataDirectory = &pWinVisorStartData->OrigNtHeader.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
	if(CopyMemoryAndRestoreProtection(pExeDataDirectory, pOrigExeDataDirectory, sizeof(IMAGE_DATA_DIRECTORY)) != 0)
	{
		return 1;
	}

	// restore TLS data directory entry
	pExeDataDirectory = &pExeNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS];
	pOrigExeDataDirectory = &pWinVisorStartData->OrigNtHeader.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS];
	if(CopyMemoryAndRestoreProtection(pExeDataDirectory, pOrigExeDataDirectory, sizeof(IMAGE_DATA_DIRECTORY)) != 0)
	{
		return 1;
	}

	// store entry-point address
	*ppEntryPoint = pEntryPoint;

	return 0;
}

DWORD PrepareCPL3_GetHostThreadStackInfo(CpuStateStruct *pCpuState, VOID **ppStackAllocBase, DWORD *pdwTotalStackSize)
{
	NT_TIB *pTIB = NULL;
	MEMORY_BASIC_INFORMATION MemoryBasicInfo;
	DWORD dwTotalStackSize = 0;

	// calculate total stack size
	pTIB = (NT_TIB*)pCpuState->pHostThreadTEB;
	memset(&MemoryBasicInfo, 0, sizeof(MemoryBasicInfo));
	if(VirtualQuery(pTIB->StackLimit, &MemoryBasicInfo, sizeof(MemoryBasicInfo)) != sizeof(MemoryBasicInfo))
	{
		return 1;
	}

	// calculate total stack size
	dwTotalStackSize = (DWORD)((UINT64)pTIB->StackBase - (UINT64)MemoryBasicInfo.AllocationBase);

	// store base/size
	*ppStackAllocBase = MemoryBasicInfo.AllocationBase;
	*pdwTotalStackSize = dwTotalStackSize;

	return 0;
}

DWORD PrepareCPL3_CreateHostThread(CpuStateStruct *pCpuState)
{
	THREAD_BASIC_INFORMATION ThreadBasicInfo;

	// create thread for virtual CPU (entry-point will be overwritten later)
	pCpuState->hHostThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)ExitThread, (VOID*)0, CREATE_SUSPENDED, NULL);
	if(pCpuState->hHostThread == NULL)
	{
		return 1;
	}

	// get TEB base
	memset(&ThreadBasicInfo, 0, sizeof(ThreadBasicInfo));
	if(pNtQueryInformationThread(pCpuState->hHostThread, ThreadBasicInformation, &ThreadBasicInfo, sizeof(ThreadBasicInfo), NULL) != 0)
	{
		return 1;
	}

	// store TEB ptr
	pCpuState->pHostThreadTEB = ThreadBasicInfo.TebBaseAddress;

	return 0;
}

DWORD PrepareCPL3_StoreInitialGuestContext(CpuStateStruct *pCpuState, VOID *pEntryPoint)
{
	CONTEXT Context;
	VOID *pStackAllocBase = NULL;
	DWORD dwTotalStackSize = 0;

	// get stack base/size for the new thread
	if(PrepareCPL3_GetHostThreadStackInfo(pCpuState, &pStackAllocBase, &dwTotalStackSize) != 0)
	{
		return 1;
	}

	// get thread context
	memset(&Context, 0, sizeof(Context));
	Context.ContextFlags = CONTEXT_FULL;
	if(GetThreadContext(pCpuState->hHostThread, &Context) == 0)
	{
		return 1;
	}

	// create a second stack to allow code to be executed in real thread without interfering with guest
	pCpuState->pCPL3_Stack = VirtualAlloc(NULL, dwTotalStackSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	if(pCpuState->pCPL3_Stack == NULL)
	{
		return 1;
	}

	// set initial CPL3 register values
	memset(&pCpuState->CPL3_InitialCpuRegisterState, 0, sizeof(pCpuState->CPL3_InitialCpuRegisterState));
	pCpuState->CPL3_InitialCpuRegisterState.RAX = Context.Rax;
	pCpuState->CPL3_InitialCpuRegisterState.RCX = Context.Rcx;
	pCpuState->CPL3_InitialCpuRegisterState.RDX = Context.Rdx;
	pCpuState->CPL3_InitialCpuRegisterState.RBX = Context.Rbx;
	pCpuState->CPL3_InitialCpuRegisterState.RSP = Context.Rsp;
	pCpuState->CPL3_InitialCpuRegisterState.RBP = Context.Rbp;
	pCpuState->CPL3_InitialCpuRegisterState.RSI = Context.Rsi;
	pCpuState->CPL3_InitialCpuRegisterState.RDI = Context.Rdi;
	pCpuState->CPL3_InitialCpuRegisterState.R8 = Context.R8;
	pCpuState->CPL3_InitialCpuRegisterState.R9 = Context.R9;
	pCpuState->CPL3_InitialCpuRegisterState.R10 = Context.R10;
	pCpuState->CPL3_InitialCpuRegisterState.R11 = Context.R11;
	pCpuState->CPL3_InitialCpuRegisterState.R12 = Context.R12;
	pCpuState->CPL3_InitialCpuRegisterState.R13 = Context.R13;
	pCpuState->CPL3_InitialCpuRegisterState.R14 = Context.R14;
	pCpuState->CPL3_InitialCpuRegisterState.R15 = Context.R15;
	pCpuState->CPL3_InitialCpuRegisterState.RIP = Context.Rip;
	pCpuState->CPL3_InitialCpuRegisterState.RFLAGS = Context.EFlags | EFLAGS_RESERVED_ALWAYS_ON;

	// update virtual CPU entry-point: HypervisorEntryPoint(pEntryPoint)
	pCpuState->CPL3_InitialCpuRegisterState.RCX = (UINT64)pEntryPoint;
	pCpuState->CPL3_InitialCpuRegisterState.RIP = (UINT64)HypervisorEntryPoint;

	// update guest stack ptr
	pCpuState->CPL3_InitialCpuRegisterState.RSP -= (UINT64)pStackAllocBase;
	pCpuState->CPL3_InitialCpuRegisterState.RSP += (UINT64)pCpuState->pCPL3_Stack;

	return 0;
}

DWORD PrepareCPL3_BeginSyscallProxyThread(CpuStateStruct *pCpuState)
{
	CONTEXT Context;

	// get thread context
	memset(&Context, 0, sizeof(Context));
	Context.ContextFlags = CONTEXT_FULL;
	if(GetThreadContext(pCpuState->hHostThread, &Context) == 0)
	{
		return 1;
	}

	// update the entry-point of the host thread to: SyscallProxyThread(pCpuState)
	Context.Rcx = (UINT64)SyscallProxyThread;
	Context.Rdx = (UINT64)pCpuState;
	if(SetThreadContext(pCpuState->hHostThread, &Context) == 0)
	{
		return 1;
	}

	// create hSyscallProxyReadyEvent event object
	pCpuState->hSyscallProxyReadyEvent = CreateEvent(NULL, 0, 0, NULL);
	if(pCpuState->hSyscallProxyReadyEvent == NULL)
	{
		return 1;
	}

	// create hSyscallWaitingEvent event object
	pCpuState->hSyscallWaitingEvent = CreateEvent(NULL, 0, 0, NULL);
	if(pCpuState->hSyscallWaitingEvent == NULL)
	{
		return 1;
	}

	// create hSyscallCompleteEvent event object
	pCpuState->hSyscallCompleteEvent = CreateEvent(NULL, 0, 0, NULL);
	if(pCpuState->hSyscallCompleteEvent == NULL)
	{
		return 1;
	}

	// begin syscall proxy thread and wait for the "ready" event to be triggered
	ResumeThread(pCpuState->hHostThread);
	WaitForSingleObject(pCpuState->hSyscallProxyReadyEvent, INFINITE);

	return 0;
}

DWORD PrepareCPL3(CpuStateStruct *pCpuState, WinVisorStartDataStruct *pWinVisorStartData)
{
	VOID *pEntryPoint = NULL;

	// store exe base
	ghExeBase = GetModuleHandleA(NULL);

	// fix target executable - restore original entry-point, and optionally set all pages to non-executable
	if(PrepareCPL3_FixExecutable(pWinVisorStartData, &pEntryPoint) != 0)
	{
		return 1;
	}

	// create suspended host thread at the original entry-point
	if(PrepareCPL3_CreateHostThread(pCpuState) != 0)
	{
		return 1;
	}

	// copy the initial thread state into a temporary structure which will be used by the virtual cpu later, and allocate a new stack for the guest
	if(PrepareCPL3_StoreInitialGuestContext(pCpuState, pEntryPoint) != 0)
	{
		return 1;
	}

	// convert the host thread into a syscall proxy thread - this will be used to forward syscalls from the guest to the host.
	// using the same thread ensures that the TEB and any thread-specific behaviour will remain consistent with the guest.
	// as mentioned above, a second stack has been allocated for the guest to prevent it from interfering with the native host thread.
	if(PrepareCPL3_BeginSyscallProxyThread(pCpuState) != 0)
	{
		return 1;
	}

	return 0;
}

```

`WinVisorDLL/SyscallHook_NtTerminateProcess.cpp`:

```cpp
#include "WinVisorDLL.h"

DWORD GuestProcessExited(DWORD dwExitCode)
{
	WriteLog(LOG_INFO, "** Guest process exited with code: %u **", dwExitCode);
	gdwStopLog = 1;

	return 0;
}

DWORD SyscallHook_NtTerminateProcess(CpuStateStruct *pCpuState, CpuRegisterStateStruct *pCpuRegisterState, SyscallInfoStruct *pSyscallInfo, UINT64 *pqwReturnValue)
{
	HANDLE hProcess = NULL;
	DWORD dwExitCode = 0;

	// get params
	hProcess = (HANDLE)pSyscallInfo->qwParamList[0];
	dwExitCode = (DWORD)pSyscallInfo->qwParamList[1];

	// check if the current process is exiting
	if(hProcess == NULL || hProcess == GetCurrentProcess())
	{
		GuestProcessExited(dwExitCode);
		return 1;
	}

	return 0;
}

```

`WinVisorDLL/SyscallHook_NtTerminateThread.cpp`:

```cpp
#include "WinVisorDLL.h"

DWORD SyscallHook_NtTerminateThread(CpuStateStruct *pCpuState, CpuRegisterStateStruct *pCpuRegisterState, SyscallInfoStruct *pSyscallInfo, UINT64 *pqwReturnValue)
{
	HANDLE hThread = NULL;
	DWORD dwExitCode = 0;

	// get params
	hThread = (HANDLE)pSyscallInfo->qwParamList[0];
	dwExitCode = (DWORD)pSyscallInfo->qwParamList[1];

	// check if the current thread is exiting
	if(hThread == NULL || hThread == GetCurrentThread())
	{
		// current thread is exiting - treat this as a process exit because winvisor currently only supports a single thread
		GuestProcessExited(dwExitCode);
		return 1;
	}

	return 0;
}

```

`WinVisorDLL/SyscallNames.cpp`:

```cpp
#include "WinVisorDLL.h"

SyscallNameEntryStruct *gpNtdllSyscallList = NULL;
DWORD gdwNtdllSyscallCount = 0;

SyscallNameEntryStruct *gpWin32uSyscallList = NULL;
DWORD gdwWin32uSyscallCount = 0;

int GenerateSyscallNameList_Compare(SyscallNameEntryStruct *pEntry1, SyscallNameEntryStruct *pEntry2)
{
	// compare virtual address values
	if(pEntry1->dwVirtualAddress > pEntry2->dwVirtualAddress)
	{
		return 1;
	}
	else if(pEntry1->dwVirtualAddress < pEntry2->dwVirtualAddress)
	{
		return -1;
	}

	return 0;
}

SyscallNameEntryStruct *GenerateSyscallNameList(HMODULE hModule, char *pExportNamePrefix, DWORD *pdwSyscallCount)
{
	IMAGE_NT_HEADERS *pImageNtHeader = NULL;
	IMAGE_DATA_DIRECTORY *pExportDataDirectory = NULL;
	IMAGE_EXPORT_DIRECTORY *pExportHeader = NULL;
	char *pExportName = NULL;
	WORD *pwAddressOfNameOrdinals = NULL;
	DWORD *pdwAddressOfNames = NULL;
	DWORD *pdwAddressOfFunctions = NULL;
	DWORD dwCount = 0;
	SyscallNameEntryStruct *pSyscallNameList = NULL;
	DWORD dwCurrIndex = 0;

	// get NT header for target module
	pImageNtHeader = GetNtHeader(hModule);
	if(pImageNtHeader == NULL)
	{
		return NULL;
	}

	// get export directory
	pExportDataDirectory = &pImageNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];
	if(pExportDataDirectory->VirtualAddress == 0 || pExportDataDirectory->Size == 0)
	{
		return NULL;
	}

	// get export directory
	pExportHeader = (IMAGE_EXPORT_DIRECTORY*)((BYTE*)hModule + pExportDataDirectory->VirtualAddress);
	if(pExportHeader == NULL)
	{
		return NULL;
	}

	// get export header virtual addresses
	pwAddressOfNameOrdinals = (WORD*)((BYTE*)hModule + pExportHeader->AddressOfNameOrdinals);
	pdwAddressOfNames = (DWORD*)((BYTE*)hModule + pExportHeader->AddressOfNames);
	pdwAddressOfFunctions = (DWORD*)((BYTE*)hModule + pExportHeader->AddressOfFunctions);

	// loop through all exports
	for(DWORD i = 0; i < pExportHeader->NumberOfNames; i++)
	{
		// get export name
		pExportName = (char*)((BYTE*)hModule + pdwAddressOfNames[i]);
		if(strncmp(pExportName, pExportNamePrefix, strlen(pExportNamePrefix)) != 0)
		{
			continue;
		}

		// increase count
		dwCount++;
	}

	// allocate list
	pSyscallNameList = (SyscallNameEntryStruct*)VirtualAlloc(NULL, dwCount * sizeof(SyscallNameEntryStruct), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	if(pSyscallNameList == NULL)
	{
		return NULL;
	}

	// copy export names to list
	dwCurrIndex = 0;
	for(DWORD i = 0; i < pExportHeader->NumberOfNames; i++)
	{
		// get export name
		pExportName = (char*)((BYTE*)hModule + pdwAddressOfNames[i]);
		if(strncmp(pExportName, pExportNamePrefix, strlen(pExportNamePrefix)) != 0)
		{
			continue;
		}

		// store syscall name
		memset(&pSyscallNameList[dwCurrIndex], 0, sizeof(SyscallNameEntryStruct));
		strncpy(pSyscallNameList[dwCurrIndex].szName, pExportName, sizeof(pSyscallNameList[dwCurrIndex].szName) - 1);
		pSyscallNameList[dwCurrIndex].dwVirtualAddress = pdwAddressOfFunctions[pwAddressOfNameOrdinals[i]];

		// fix syscall name (Zw - > Nt)
		pSyscallNameList[dwCurrIndex].szName[0] = 'N';
		pSyscallNameList[dwCurrIndex].szName[1] = 't';

		dwCurrIndex++;
	}

	// sort list by virtual address
	qsort(pSyscallNameList, dwCount, sizeof(SyscallNameEntryStruct), (int(*)(const void*,const void*))GenerateSyscallNameList_Compare);

	// store count
	*pdwSyscallCount = dwCount;

	return pSyscallNameList;
}

DWORD CreateSyscallLists()
{
	HMODULE hWin32u = NULL;

	// generate syscall name list for ntdll.dll (use "Zw" prefix to filter out non-syscalls such as NtdllDefWindowProc_A)
	gpNtdllSyscallList = GenerateSyscallNameList(ghNtdllBase, "Zw", &gdwNtdllSyscallCount);
	if(gpNtdllSyscallList == NULL)
	{
		DeleteSyscallLists();
		return 1;
	}

	// temporarily load win32u.dll
	hWin32u = LoadLibraryA("win32u.dll");
	if(hWin32u == NULL)
	{
		DeleteSyscallLists();
		return 1;
	}

	// generate syscall name list for win32u
	gpWin32uSyscallList = GenerateSyscallNameList(hWin32u, "Nt", &gdwWin32uSyscallCount);
	if(gpWin32uSyscallList == NULL)
	{
		FreeLibrary(hWin32u);
		DeleteSyscallLists();
		return 1;
	}

	// unload win32u.dll
	FreeLibrary(hWin32u);

	// attempt to populate param counts via wow64 - don't check for errors here, these param counts are used for display purposes only
	PopulateSyscallParamCounts("ntdll.dll", gpNtdllSyscallList, gdwNtdllSyscallCount);
	PopulateSyscallParamCounts("win32u.dll", gpWin32uSyscallList, gdwWin32uSyscallCount);

	return 0;
}

DWORD DeleteSyscallLists()
{
	if(gpNtdllSyscallList != NULL)
	{
		// free memory
		VirtualFree(gpNtdllSyscallList, 0, MEM_RELEASE);
	}

	if(gpWin32uSyscallList != NULL)
	{
		// free memory
		VirtualFree(gpWin32uSyscallList, 0, MEM_RELEASE);
	}

	return 0;
}

char *GetSyscallName(DWORD dwSyscallIndex, DWORD *pdwParamCount)
{
	DWORD dwTableIndex = 0;
	DWORD dwEntryIndex = 0;
	SyscallNameEntryStruct *pSyscallEntry = NULL;

	// extract table and entry index from syscall number
	dwTableIndex = (dwSyscallIndex >> 12) & 0x3;
	dwEntryIndex = dwSyscallIndex & 0xFFF;

	if(dwTableIndex == 0)
	{
		// ntdll / ntoskrnl
		if(dwEntryIndex >= gdwNtdllSyscallCount)
		{
			return NULL;
		}

		pSyscallEntry = &gpNtdllSyscallList[dwEntryIndex];
	}
	else if(dwTableIndex == 1)
	{
		// win32u / win32k
		if(dwEntryIndex >= gdwWin32uSyscallCount)
		{
			return NULL;
		}

		pSyscallEntry = &gpWin32uSyscallList[dwEntryIndex];
	}
	else
	{
		// invalid table index
		return NULL;
	}

	if(pdwParamCount != NULL)
	{
		// store param count (optional)
		*pdwParamCount = pSyscallEntry->dwParamCount;
	}

	return pSyscallEntry->szName;
}

```

`WinVisorDLL/SyscallParamCount.cpp`:

```cpp
#include "WinVisorDLL.h"

VOID *GetProcAddress_WoW64(VOID *pImageBase, char *pExportName)
{
	IMAGE_NT_HEADERS32 *pImageNtHeader32 = NULL;
	IMAGE_DATA_DIRECTORY *pExportDataDirectory = NULL;
	IMAGE_EXPORT_DIRECTORY *pExportHeader = NULL;
	char *pCurrExportName = NULL;
	WORD *pwAddressOfNameOrdinals = NULL;
	DWORD *pdwAddressOfNames = NULL;
	DWORD *pdwAddressOfFunctions = NULL;

	// get NT32 header
	pImageNtHeader32 = (IMAGE_NT_HEADERS32*)GetNtHeader(pImageBase);
	if(pImageNtHeader32 == NULL)
	{
		return NULL;
	}

	// get export directory
	pExportDataDirectory = &pImageNtHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];
	if(pExportDataDirectory->VirtualAddress == 0 || pExportDataDirectory->Size == 0)
	{
		return NULL;
	}

	// get export directory
	pExportHeader = (IMAGE_EXPORT_DIRECTORY*)((BYTE*)pImageBase + pExportDataDirectory->VirtualAddress);
	if(pExportHeader == NULL)
	{
		return NULL;
	}

	// get export header virtual addresses
	pwAddressOfNameOrdinals = (WORD*)((BYTE*)pImageBase + pExportHeader->AddressOfNameOrdinals);
	pdwAddressOfNames = (DWORD*)((BYTE*)pImageBase + pExportHeader->AddressOfNames);
	pdwAddressOfFunctions = (DWORD*)((BYTE*)pImageBase + pExportHeader->AddressOfFunctions);

	// loop through all exports
	for(DWORD i = 0; i < pExportHeader->NumberOfNames; i++)
	{
		// get export name
		pCurrExportName = (char*)((BYTE*)pImageBase + pdwAddressOfNames[i]);
		if(strcmp(pCurrExportName, pExportName) == 0)
		{
			// found
			return (BYTE*)pImageBase + pdwAddressOfFunctions[pwAddressOfNameOrdinals[i]];
		}
	}

	// not found
	return NULL;
}

DWORD PopulateSyscallParamCounts(char *pModuleName, SyscallNameEntryStruct *pSyscallList, DWORD dwSyscallCount)
{
	char szSysWow64DirectoryPath[512];
	char szFullPath[512];
	BYTE *pEndOfSyscall = NULL;
	DWORD dwFound = 0;
	DWORD dwParamCount = 0;
	HANDLE hFile = NULL;
	HANDLE hSection = NULL;
	VOID *pMappedImage = NULL;
	VOID *pFuncAddr = NULL;

	// set initial values
	for(DWORD i = 0; i < dwSyscallCount; i++)
	{
		pSyscallList[i].dwParamCount = UNKNOWN_SYSCALL_PARAM_COUNT;
	}

	// get syswow64 directory
	memset(szSysWow64DirectoryPath, 0, sizeof(szSysWow64DirectoryPath));
	if(GetSystemWow64DirectoryA(szSysWow64DirectoryPath, sizeof(szSysWow64DirectoryPath) - 1) == 0)
	{
		return 1;
	}

	// open wow64 dll file
	memset(szFullPath, 0, sizeof(szFullPath));
	_snprintf(szFullPath, sizeof(szFullPath) - 1, "%s\\%s", szSysWow64DirectoryPath, pModuleName);
	hFile = CreateFileA(szFullPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
	if(hFile == INVALID_HANDLE_VALUE)
	{
		return 1;
	}

	// create section
	hSection = CreateFileMapping(hFile, NULL, PAGE_READONLY | SEC_IMAGE, 0, 0, NULL);
	if(hSection == NULL)
	{
		CloseHandle(hFile);
		return 1;
	}

	// map section into memory
	pMappedImage = MapViewOfFile(hSection, FILE_MAP_READ, 0, 0, 0);
	if(pMappedImage == NULL)
	{
		CloseHandle(hSection);
		CloseHandle(hFile);
		return 1;
	}

	// populate param counts
	for(DWORD i = 0; i < dwSyscallCount; i++)
	{
		// find current function in wow64 module
		pFuncAddr = GetProcAddress_WoW64(pMappedImage, pSyscallList[i].szName);
		if(pFuncAddr == NULL)
		{
			continue;
		}

		// find end of syscall (ret / ret imm16).
		// the wow64 code uses callee-cleaned functions (stdcall) so we can use this to calculate the param count.
		// in most cases, the wow64 param count will match the native 64-bit functions.
		dwFound = 0;
		for(DWORD ii = 0; ii < 64; ii++)
		{
			pEndOfSyscall = (BYTE*)pFuncAddr + ii;

			// call edx
			if(*pEndOfSyscall == 0xFF && *(pEndOfSyscall + 1) == 0xD2)
			{
				if(*(pEndOfSyscall + 2) == 0xC2 && (*(pEndOfSyscall + 3) % 4) == 0 && *(pEndOfSyscall + 4) == 0)
				{
					// ret imm16
					dwParamCount = *(pEndOfSyscall + 3) / 4;
					dwFound = 1;
					break;
				}
				else if(*(pEndOfSyscall + 2) == 0xC3)
				{
					// ret
					dwParamCount = 0;
					dwFound = 1;
					break;
				}
			}
		}

		if(dwFound == 0)
		{
			// failed to find end of syscall
			continue;
		}

		// store param count
		pSyscallList[i].dwParamCount = dwParamCount;
	}

	// clean up
	UnmapViewOfFile(pMappedImage);
	CloseHandle(hSection);
	CloseHandle(hFile);

	return 0;
}

```

`WinVisorDLL/SyscallProxy.cpp`:

```cpp
#include "WinVisorDLL.h"

DWORD gdwLogImportSyscallsEnabled = 0;

SyscallHookEntryStruct gSyscallHookList[] =
{
	{ "NtTerminateThread", SyscallHook_NtTerminateThread },
	{ "NtTerminateProcess", SyscallHook_NtTerminateProcess },
};

BYTE gbSysRet[] =
{
	// sysret
	0x48, 0x0F, 0x07
};

DWORD ExecuteSyscall(SyscallInfoStruct *pSyscallInfo, UINT64 *pqwReturnValue)
{
	VOID *pCode = NULL;
	UINT64 qwReturnValue = 0;
	BYTE bSyscallCode[] =
	{
		// sub rsp, 0x118
		0x48, 0x81, 0xEC, 0x18, 0x01, 0x00, 0x00,
		// mov rax, <PARAM_32>
		0x48, 0xB8, 0x28, 0x22, 0x22, 0x22, 0x04, 0x00, 0x00, 0x00,
		// mov qword ptr [rsp+0xF8], rax
		0x48, 0x89, 0x84, 0x24, 0xF8, 0x00, 0x00, 0x00,
		// mov rax, <PARAM_31>
		0x48, 0xB8, 0x27, 0x22, 0x22, 0x22, 0x04, 0x00, 0x00, 0x00,
		// mov qword ptr [rsp+0xF0], rax
		0x48, 0x89, 0x84, 0x24, 0xF0, 0x00, 0x00, 0x00,
		// mov rax, <PARAM_30>
		0x48, 0xB8, 0x26, 0x22, 0x22, 0x22, 0x04, 0x00, 0x00, 0x00,
		// mov qword ptr [rsp+0xE8], rax
		0x48, 0x89, 0x84, 0x24, 0xE8, 0x00, 0x00, 0x00,
		// mov rax, <PARAM_29>
		0x48, 0xB8, 0x25, 0x22, 0x22, 0x22, 0x04, 0x00, 0x00, 0x00,
		// mov qword ptr [rsp+0xE0], rax
		0x48, 0x89, 0x84, 0x24, 0xE0, 0x00, 0x00, 0x00,
		// mov rax, <PARAM_28>
		0x48, 0xB8, 0x24, 0x22, 0x22, 0x22, 0x04, 0x00, 0x00, 0x00,
		// mov qword ptr [rsp+0xD8], rax
		0x48, 0x89, 0x84, 0x24, 0xD8, 0x00, 0x00, 0x00,
		// mov rax, <PARAM_27>
		0x48, 0xB8, 0x23, 0x22, 0x22, 0x22, 0x04, 0x00, 0x00, 0x00,
		// mov qword ptr [rsp+0xD0], rax
		0x48, 0x89, 0x84, 0x24, 0xD0, 0x00, 0x00, 0x00,
		// mov rax, <PARAM_26>
		0x48, 0xB8, 0x22, 0x22, 0x22, 0x22, 0x04, 0x00, 0x00, 0x00,
		// mov qword ptr [rsp+0xC8], rax
		0x48, 0x89, 0x84, 0x24, 0xC8, 0x00, 0x00, 0x00,
		// mov rax, <PARAM_25>
		0x48, 0xB8, 0x21, 0x22, 0x22, 0x22, 0x04, 0x00, 0x00, 0x00,
		// mov qword ptr [rsp+0xC0], rax
		0x48, 0x89, 0x84, 0x24, 0xC0, 0x00, 0x00, 0x00,
		// mov rax, <PARAM_24>
		0x48, 0xB8, 0x18, 0x11, 0x11, 0x11, 0x03, 0x00, 0x00, 0x00,
		// mov qword ptr [rsp+0xB8], rax
		0x48, 0x89, 0x84, 0x24, 0xB8, 0x00, 0x00, 0x00,
		// mov rax, <PARAM_23>
		0x48, 0xB8, 0x17, 0x11, 0x11, 0x11, 0x03, 0x00, 0x00, 0x00,
		// mov qword ptr [rsp+0xB0], rax
		0x48, 0x89, 0x84, 0x24, 0xB0, 0x00, 0x00, 0x00,
		// mov rax, <PARAM_22>
		0x48, 0xB8, 0x16, 0x11, 0x11, 0x11, 0x03, 0x00, 0x00, 0x00,
		// mov qword ptr [rsp+0xA8], rax
		0x48, 0x89, 0x84, 0x24, 0xA8, 0x00, 0x00, 0x00,
		// mov rax, <PARAM_21>
		0x48, 0xB8, 0x15, 0x11, 0x11, 0x11, 0x03, 0x00, 0x00, 0x00,
		// mov qword ptr [rsp+0xA0], rax
		0x48, 0x89, 0x84, 0x24, 0xA0, 0x00, 0x00, 0x00,
		// mov rax, <PARAM_20>
		0x48, 0xB8, 0x14, 0x11, 0x11, 0x11, 0x03, 0x00, 0x00, 0x00,
		// mov qword ptr [rsp+0x98], rax
		0x48, 0x89, 0x84, 0x24, 0x98, 0x00, 0x00, 0x00,
		// mov rax, <PARAM_19>
		0x48, 0xB8, 0x13, 0x11, 0x11, 0x11, 0x03, 0x00, 0x00, 0x00,
		// mov qword ptr [rsp+0x90], rax
		0x48, 0x89, 0x84, 0x24, 0x90, 0x00, 0x00, 0x00,
		// mov rax, <PARAM_18>
		0x48, 0xB8, 0x12, 0x11, 0x11, 0x11, 0x03, 0x00, 0x00, 0x00,
		// mov qword ptr [rsp+0x88], rax
		0x48, 0x89, 0x84, 0x24, 0x88, 0x00, 0x00, 0x00,
		// mov rax, <PARAM_17>
		0x48, 0xB8, 0x11, 0x11, 0x11, 0x11, 0x03, 0x00, 0x00, 0x00,
		// mov qword ptr [rsp+0x80], rax
		0x48, 0x89, 0x84, 0x24, 0x80, 0x00, 0x00, 0x00,
		// mov rax, <PARAM_16>
		0x48, 0xB8, 0x28, 0x22, 0x22, 0x22, 0x02, 0x00, 0x00, 0x00,
		// mov qword ptr [rsp+0x78], rax
		0x48, 0x89, 0x44, 0x24, 0x78,
		// mov rax, <PARAM_15>
		0x48, 0xB8, 0x27, 0x22, 0x22, 0x22, 0x02, 0x00, 0x00, 0x00,
		// mov qword ptr [rsp+0x70], rax
		0x48, 0x89, 0x44, 0x24, 0x70,
		// mov rax, <PARAM_14>
		0x48, 0xB8, 0x26, 0x22, 0x22, 0x22, 0x02, 0x00, 0x00, 0x00,
		// mov qword ptr [rsp+0x68], rax
		0x48, 0x89, 0x44, 0x24, 0x68,
		// mov rax, <PARAM_13>
		0x48, 0xB8, 0x25, 0x22, 0x22, 0x22, 0x02, 0x00, 0x00, 0x00,
		// mov qword ptr [rsp+0x60], rax
		0x48, 0x89, 0x44, 0x24, 0x60,
		// mov rax, <PARAM_12>
		0x48, 0xB8, 0x24, 0x22, 0x22, 0x22, 0x02, 0x00, 0x00, 0x00,
		// mov qword ptr [rsp+0x58], rax
		0x48, 0x89, 0x44, 0x24, 0x58,
		// mov rax, <PARAM_11>
		0x48, 0xB8, 0x23, 0x22, 0x22, 0x22, 0x02, 0x00, 0x00, 0x00,
		// mov qword ptr [rsp+0x50], rax
		0x48, 0x89, 0x44, 0x24, 0x50,
		// mov rax, <PARAM_10>
		0x48, 0xB8, 0x22, 0x22, 0x22, 0x22, 0x02, 0x00, 0x00, 0x00,
		// mov qword ptr [rsp+0x48], rax
		0x48, 0x89, 0x44, 0x24, 0x48,
		// mov rax, <PARAM_9>
		0x48, 0xB8, 0x21, 0x22, 0x22, 0x22, 0x02, 0x00, 0x00, 0x00,
		// mov qword ptr [rsp+0x40], rax
		0x48, 0x89, 0x44, 0x24, 0x40,
		// mov rax, <PARAM_8>
		0x48, 0xB8, 0x18, 0x11, 0x11, 0x11, 0x01, 0x00, 0x00, 0x00,
		// mov qword ptr [rsp+0x38], rax
		0x48, 0x89, 0x44, 0x24, 0x38,
		// mov rax, <PARAM_7>
		0x48, 0xB8, 0x17, 0x11, 0x11, 0x11, 0x01, 0x00, 0x00, 0x00,
		// mov qword ptr [rsp+0x30], rax
		0x48, 0x89, 0x44, 0x24, 0x30,
		// mov rax, <PARAM_6>
		0x48, 0xB8, 0x16, 0x11, 0x11, 0x11, 0x01, 0x00, 0x00, 0x00,
		// mov qword ptr [rsp+0x28], rax
		0x48, 0x89, 0x44, 0x24, 0x28,
		// mov rax, <PARAM_5>
		0x48, 0xB8, 0x15, 0x11, 0x11, 0x11, 0x01, 0x00, 0x00, 0x00,
		// mov qword ptr [rsp+0x20], rax
		0x48, 0x89, 0x44, 0x24, 0x20,
		// mov r9, <PARAM_4>
		0x49, 0xB9, 0x14, 0x11, 0x11, 0x11, 0x01, 0x00, 0x00, 0x00,
		// mov r8, <PARAM_3>
		0x49, 0xB8, 0x13, 0x11, 0x11, 0x11, 0x01, 0x00, 0x00, 0x00,
		// mov rdx, <PARAM_2>
		0x48, 0xBA, 0x12, 0x11, 0x11, 0x11, 0x01, 0x00, 0x00, 0x00,
		// mov rcx, <PARAM_1>
		0x48, 0xB9, 0x11, 0x11, 0x11, 0x11, 0x01, 0x00, 0x00, 0x00,
		// call SYSCALL_STUB
		0xE8, 0x08, 0x00, 0x00, 0x00,
		// add rsp, 0x118
		0x48, 0x81, 0xC4, 0x18, 0x01, 0x00, 0x00,
		// ret
		0xC3,
		// SYSCALL_STUB:
		// mov r10, rcx
		0x49, 0x89, 0xCA,
		// mov eax, <SYSCALL_INDEX>
		0xB8, 0xF6, 0x00, 0x00, 0x00,
		// syscall
		0x0F, 0x05,
		// ret
		0xC3
	};

	// set syscall index
	*(DWORD*)&bSyscallCode[532] = pSyscallInfo->dwSyscallIndex;

	// set syscall param values
	*(UINT64*)&bSyscallCode[9] = pSyscallInfo->qwParamList[31];
	*(UINT64*)&bSyscallCode[27] = pSyscallInfo->qwParamList[30];
	*(UINT64*)&bSyscallCode[45] = pSyscallInfo->qwParamList[29];
	*(UINT64*)&bSyscallCode[63] = pSyscallInfo->qwParamList[28];
	*(UINT64*)&bSyscallCode[81] = pSyscallInfo->qwParamList[27];
	*(UINT64*)&bSyscallCode[99] = pSyscallInfo->qwParamList[26];
	*(UINT64*)&bSyscallCode[117] = pSyscallInfo->qwParamList[25];
	*(UINT64*)&bSyscallCode[135] = pSyscallInfo->qwParamList[24];
	*(UINT64*)&bSyscallCode[153] = pSyscallInfo->qwParamList[23];
	*(UINT64*)&bSyscallCode[171] = pSyscallInfo->qwParamList[22];
	*(UINT64*)&bSyscallCode[189] = pSyscallInfo->qwParamList[21];
	*(UINT64*)&bSyscallCode[207] = pSyscallInfo->qwParamList[20];
	*(UINT64*)&bSyscallCode[225] = pSyscallInfo->qwParamList[19];
	*(UINT64*)&bSyscallCode[243] = pSyscallInfo->qwParamList[18];
	*(UINT64*)&bSyscallCode[261] = pSyscallInfo->qwParamList[17];
	*(UINT64*)&bSyscallCode[279] = pSyscallInfo->qwParamList[16];
	*(UINT64*)&bSyscallCode[297] = pSyscallInfo->qwParamList[15];
	*(UINT64*)&bSyscallCode[312] = pSyscallInfo->qwParamList[14];
	*(UINT64*)&bSyscallCode[327] = pSyscallInfo->qwParamList[13];
	*(UINT64*)&bSyscallCode[342] = pSyscallInfo->qwParamList[12];
	*(UINT64*)&bSyscallCode[357] = pSyscallInfo->qwParamList[11];
	*(UINT64*)&bSyscallCode[372] = pSyscallInfo->qwParamList[10];
	*(UINT64*)&bSyscallCode[387] = pSyscallInfo->qwParamList[9];
	*(UINT64*)&bSyscallCode[402] = pSyscallInfo->qwParamList[8];
	*(UINT64*)&bSyscallCode[417] = pSyscallInfo->qwParamList[7];
	*(UINT64*)&bSyscallCode[432] = pSyscallInfo->qwParamList[6];
	*(UINT64*)&bSyscallCode[447] = pSyscallInfo->qwParamList[5];
	*(UINT64*)&bSyscallCode[462] = pSyscallInfo->qwParamList[4];
	*(UINT64*)&bSyscallCode[477] = pSyscallInfo->qwParamList[3];
	*(UINT64*)&bSyscallCode[487] = pSyscallInfo->qwParamList[2];
	*(UINT64*)&bSyscallCode[497] = pSyscallInfo->qwParamList[1];
	*(UINT64*)&bSyscallCode[507] = pSyscallInfo->qwParamList[0];

	// allocate temporary memory for syscall code
	pCode = VirtualAlloc(NULL, sizeof(bSyscallCode), MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if(pCode == NULL)
	{
		return 1;
	}

	// execute syscall
	memcpy(pCode, bSyscallCode, sizeof(bSyscallCode));
	qwReturnValue = ((UINT64(*)())pCode)();

	// free temporary memory
	VirtualFree(pCode, 0, MEM_RELEASE);

	// store return value
	*pqwReturnValue = qwReturnValue;

	return 0;
}

DWORD WINAPI SyscallProxyThread(CpuStateStruct *pCpuState)
{
	// syscall proxy thread ready
	SetEvent(pCpuState->hSyscallProxyReadyEvent);

	for(;;)
	{
		// wait for next syscall request
		WaitForSingleObject(pCpuState->hSyscallWaitingEvent, INFINITE);

		// execute received syscall request
		if(ExecuteSyscall(&pCpuState->SyscallInfo, &pCpuState->qwSyscallReturnValue) != 0)
		{
			WriteLog(LOG_ERROR, "Failed to execute syscall");
			return 1;
		}

		// syscall complete
		SetEvent(pCpuState->hSyscallCompleteEvent);
	}

	return 0;
}

DWORD ForwardSyscallToHost(CpuStateStruct *pCpuState, SyscallInfoStruct *pSyscallInfo, UINT64 *pqwReturnValue)
{
	// request syscall from proxy thread
	memcpy(&pCpuState->SyscallInfo, pSyscallInfo, sizeof(SyscallInfoStruct));
	SetEvent(pCpuState->hSyscallWaitingEvent);

	// wait for syscall to return
	WaitForSingleObject(pCpuState->hSyscallCompleteEvent, INFINITE);
	*pqwReturnValue = pCpuState->qwSyscallReturnValue;

	return 0;
}

DWORD CheckSyscallLoggingEnabled()
{
	if(gdwLogImportSyscallsEnabled == 0)
	{
		// check if the EXE imports have been loaded
		if(gdwLoadedModuleImports == 0)
		{
			// imports not loaded yet - suppress syscall logging
			return 1;
		}
	}

	return 0;
}

DWORD LogSyscallStart(char *pSyscallName, DWORD dwSyscallParamCount, SyscallInfoStruct *pSyscallInfo)
{
	char szSyscallLog[1024];
	char szTemp[512];

	if(CheckSyscallLoggingEnabled() != 0)
	{
		// syscall logging suppressed
		return 1;
	}

	// initialise log string
	memset(szSyscallLog, 0, sizeof(szSyscallLog));

	// append syscall name
	memset(szTemp, 0, sizeof(szTemp));
	_snprintf(szTemp, sizeof(szTemp) - 1, "Caught syscall: %s(", pSyscallName);
	if(AppendString(szSyscallLog, sizeof(szSyscallLog) - 1, szTemp) != 0)
	{
		return 1;
	}

	// append param values
	for(DWORD i = 0; i < dwSyscallParamCount; i++)
	{
		if(i != 0)
		{
			if(AppendString(szSyscallLog, sizeof(szSyscallLog) - 1, ",") != 0)
			{
				return 1;
			}
		}

		// append current param value
		memset(szTemp, 0, sizeof(szTemp));
		_snprintf(szTemp, sizeof(szTemp) - 1, "0x%I64X", pSyscallInfo->qwParamList[i]);
		if(AppendString(szSyscallLog, sizeof(szSyscallLog) - 1, szTemp) != 0)
		{
			return 1;
		}
	}

	// end of param values
	if(AppendString(szSyscallLog, sizeof(szSyscallLog) - 1, ")") != 0)
	{
		return 1;
	}

	// write log entry
	WriteLog(LOG_INFO, "%s", szSyscallLog);

	return 0;
}

DWORD LogSyscallEnd(char *pSyscallName, DWORD dwSyscallParamCount, SyscallInfoStruct *pSyscallInfo, UINT64 qwReturnValue)
{
	if(CheckSyscallLoggingEnabled() != 0)
	{
		// syscall logging suppressed
		return 1;
	}

	// write syscall return value
	WriteLog(LOG_INFO, "                -> returned: 0x%I64X", qwReturnValue);

	return 0;
}

DWORD HandleGuestSyscall(CpuStateStruct *pCpuState, CpuRegisterStateStruct *pCpuRegisterState, VOID *pUserStackPtr)
{
	DWORD dwSyscallIndex = 0;
	UINT64 qwCurrParamValue = 0;
	UINT64 qwReturnValue = 0;
	UINT64 *pqwStackParamPtr = NULL;
	SyscallInfoStruct SyscallInfo;
	char *pSyscallName = NULL;
	DWORD dwSyscallParamCount = 0;
	SyscallHookEntryStruct *pSyscallHookEntry = NULL;

	// get syscall index
	dwSyscallIndex = (DWORD)pCpuRegisterState->RAX;

	// look-up syscall name
	pSyscallName = GetSyscallName(dwSyscallIndex, &dwSyscallParamCount);
	if(pSyscallName == NULL)
	{
		WriteLog(LOG_ERROR, "Invalid syscall: 0x%X", dwSyscallIndex);
		return 1;
	}

	// extract syscall params from guest - copy all values regardless of dwSyscallParamCount value.
	// the dwSyscallParamCount value is calculated via wow64 modules so the results may not be 100% accurate - it is used for display-purposes only.
	memset(&SyscallInfo, 0, sizeof(SyscallInfo));
	SyscallInfo.dwSyscallIndex = dwSyscallIndex;
	for(DWORD i = 0; i < MAX_SYSCALL_PARAM_COUNT; i++)
	{
		// get first 4 param values from registers
		if(i == 0)
		{
			// the syscall instruction overwrites rcx, so windows uses r10 for the first param value instead.
			// the legacy interrupt handler (KiSystemService) also copies r10 back into rcx so it doesn't need to be handled differently.
			qwCurrParamValue = pCpuRegisterState->R10;
		}
		else if(i == 1)
		{
			qwCurrParamValue = pCpuRegisterState->RDX;
		}
		else if(i == 2)
		{
			qwCurrParamValue = pCpuRegisterState->R8;
		}
		else if(i == 3)
		{
			qwCurrParamValue = pCpuRegisterState->R9;
		}
		else
		{
			// get param from stack
			pqwStackParamPtr = (UINT64*)((UINT64)pUserStackPtr + 0x28 + ((i - 4) * 8));
			if(ValidateReadPointer(pqwStackParamPtr, 8) == 0)
			{
				qwCurrParamValue = *pqwStackParamPtr;
			}
			else
			{
				// stack ptr out of range
				qwCurrParamValue = 0;
			}
		}

		// store current param value
		SyscallInfo.qwParamList[i] = qwCurrParamValue;
	}

	if(dwSyscallParamCount == UNKNOWN_SYSCALL_PARAM_COUNT)
	{
		// unknown param count - use default
		dwSyscallParamCount = 4;
	}

	// log syscall start
	LogSyscallStart(pSyscallName, dwSyscallParamCount, &SyscallInfo);

	// check if this syscall is hooked
	for(DWORD i = 0; i < sizeof(gSyscallHookList) / sizeof(gSyscallHookList[0]); i++)
	{
		if(strcmp(pSyscallName, gSyscallHookList[i].pSyscallName) == 0)
		{
			pSyscallHookEntry = &gSyscallHookList[i];
			break;
		}
	}

	if(pSyscallHookEntry != NULL)
	{
		// hooked - pass to handler
		if(pSyscallHookEntry->pHandler(pCpuState, pCpuRegisterState, &SyscallInfo, &qwReturnValue) != 0)
		{
			return 1;
		}
	}
	else
	{
		// not hooked - pass syscall directly to host via proxy thread
		if(ForwardSyscallToHost(pCpuState, &SyscallInfo, &qwReturnValue) != 0)
		{
			return 1;
		}
	}

	// log syscall end
	LogSyscallEnd(pSyscallName, dwSyscallParamCount, &SyscallInfo, qwReturnValue);

	// set return value
	pCpuRegisterState->RAX = qwReturnValue;

	// set RIP to sysret instruction
	pCpuRegisterState->RIP = (UINT64)gbSysRet;
	
	return 0;
}

DWORD HandleSyscallInstruction(CpuStateStruct *pCpuState, CpuRegisterStateStruct *pCpuRegisterState)
{
	// handle fast syscall - rsp still points to user-mode stack
	if(HandleGuestSyscall(pCpuState, pCpuRegisterState, (void*)pCpuRegisterState->RSP) != 0)
	{
		return 1;
	}

	// set RIP to sysret instruction
	pCpuRegisterState->RIP = (UINT64)gbSysRet;

	return 0;
}

```

`WinVisorDLL/WinHvApi.h`:

```h
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    WinHvApiDefs.h

Abstract:

    This module contains the constant, type and structure definitions for
    the Windows Hypervisor User-Mode APIs.

--*/

#if defined(_MSC_VER) && (_MSC_VER >= 1200)
#pragma once
#pragma warning(push)
#pragma warning(disable:4201) /* nonstandard extension used: nameless struct/union */
#pragma warning(disable:4214) /* nonstandard extension used: bit field types other than int */
#endif

//
// Platform capabilities
//
typedef enum WHV_CAPABILITY_CODE
{
    // Capabilities of the API implementation
    WHvCapabilityCodeHypervisorPresent      = 0x00000000,
    WHvCapabilityCodeFeatures               = 0x00000001,
    WHvCapabilityCodeExtendedVmExits        = 0x00000002,
    WHvCapabilityCodeExceptionExitBitmap    = 0x00000003,

    // Capabilities of the system's processor
    WHvCapabilityCodeProcessorVendor        = 0x00001000,
    WHvCapabilityCodeProcessorFeatures      = 0x00001001,
    WHvCapabilityCodeProcessorClFlushSize   = 0x00001002
} WHV_CAPABILITY_CODE;

//
// Return values for WhvCapabilityCodeFeatures
//
typedef union WHV_CAPABILITY_FEATURES
{
    struct
    {
        UINT64 Reserved : 64;
    };

    UINT64 AsUINT64;
} WHV_CAPABILITY_FEATURES;

//
// Return values for WhvCapabilityCodeExtendedVmExits
//
typedef union WHV_EXTENDED_VM_EXITS
{
    struct
    {
        UINT64 X64CpuidExit  : 1; // RunVpExitReasonX64CPUID supported
        UINT64 X64MsrExit    : 1; // RunVpExitX64ReasonMSRAccess supported
        UINT64 ExceptionExit : 1; // RunVpExitReasonException supported
        UINT64 Reserved      : 61;
    };

    UINT64 AsUINT64;
} WHV_EXTENDED_VM_EXITS;

//
// Return values for WhvCapabilityCodeProcessorVendor
//
typedef enum WHV_PROCESSOR_VENDOR
{
    WHvProcessorVendorAmd   = 0x0000,
    WHvProcessorVendorIntel = 0x0001

} WHV_PROCESSOR_VENDOR;

//
// Return values for WhvCapabilityCodeProcessorFeatures
//
typedef union WHV_PROCESSOR_FEATURES
{
    struct
    {
        UINT64 Sse3Support : 1;
        UINT64 LahfSahfSupport : 1;
        UINT64 Ssse3Support : 1;
        UINT64 Sse4_1Support : 1;
        UINT64 Sse4_2Support : 1;
        UINT64 Sse4aSupport : 1;
        UINT64 XopSupport : 1;
        UINT64 PopCntSupport : 1;
        UINT64 Cmpxchg16bSupport : 1;
        UINT64 Altmovcr8Support : 1;
        UINT64 LzcntSupport : 1;
        UINT64 MisAlignSseSupport : 1;
        UINT64 MmxExtSupport : 1;
        UINT64 Amd3DNowSupport : 1;
        UINT64 ExtendedAmd3DNowSupport : 1;
        UINT64 Page1GbSupport : 1;
        UINT64 AesSupport : 1;
        UINT64 PclmulqdqSupport : 1;
        UINT64 PcidSupport : 1;
        UINT64 Fma4Support : 1;
        UINT64 F16CSupport : 1;
        UINT64 RdRandSupport : 1;
        UINT64 RdWrFsGsSupport : 1;
        UINT64 SmepSupport : 1;
        UINT64 EnhancedFastStringSupport : 1;
        UINT64 Bmi1Support : 1;
        UINT64 Bmi2Support : 1;
        UINT64 Reserved1 : 2;
        UINT64 MovbeSupport : 1;
        UINT64 Npiep1Support : 1;
        UINT64 DepX87FPUSaveSupport : 1;
        UINT64 RdSeedSupport : 1;
        UINT64 AdxSupport : 1;
        UINT64 IntelPrefetchSupport : 1;
        UINT64 SmapSupport : 1;
        UINT64 HleSupport : 1;
        UINT64 RtmSupport : 1;
        UINT64 RdtscpSupport : 1;
        UINT64 ClflushoptSupport : 1;
        UINT64 ClwbSupport : 1;
        UINT64 ShaSupport : 1;
        UINT64 X87PointersSavedSupport : 1;
        UINT64 Reserved2 : 21;
    };

    UINT64 AsUINT64;
} WHV_PROCESSOR_FEATURES;

//
// WHvGetCapability output buffer
//
typedef union WHV_CAPABILITY
{
    BOOL HypervisorPresent;
    WHV_CAPABILITY_FEATURES Features;
    WHV_EXTENDED_VM_EXITS ExtendedVmExits;
    WHV_PROCESSOR_VENDOR ProcessorVendor;
    WHV_PROCESSOR_FEATURES ProcessorFeatures;
    UINT8 ProcessorClFlushSize;
    UINT64 ExceptionExitBitmap;
} WHV_CAPABILITY;

//
// Partitions
//

typedef VOID* WHV_PARTITION_HANDLE;

typedef enum WHV_PARTITION_PROPERTY_CODE
{
    WHvPartitionPropertyCodeExtendedVmExits         = 0x00000001,
    WHvPartitionPropertyCodeExceptionExitBitmap     = 0x00000002,

    WHvPartitionPropertyCodeProcessorFeatures       = 0x00001001,
    WHvPartitionPropertyCodeProcessorClFlushSize    = 0x00001002,
    WHvPartitionPropertyCodeCpuidExitList           = 0x00001003,
    WHvPartitionPropertyCodeCpuidResultList         = 0x00001004,

    WHvPartitionPropertyCodeProcessorCount          = 0x00001fff
} WHV_PARTITION_PROPERTY_CODE;

//
// WHvPartitionPropertyCodeCpuidResultList input buffer list element.
//
typedef struct WHV_X64_CPUID_RESULT
{
    UINT32 Function;
    UINT32 Reserved[3];
    UINT32 Eax;
    UINT32 Ebx;
    UINT32 Ecx;
    UINT32 Edx;
} WHV_X64_CPUID_RESULT;

//
// WHvPartitionPropertyCodeExceptionBitmap enumeration values.
//
typedef enum WHV_EXCEPTION_TYPE
{
    WHvX64ExceptionTypeDivideErrorFault = 0x0,
    WHvX64ExceptionTypeDebugTrapOrFault = 0x1,
    WHvX64ExceptionTypeBreakpointTrap = 0x3,
    WHvX64ExceptionTypeOverflowTrap = 0x4,
    WHvX64ExceptionTypeBoundRangeFault = 0x5,
    WHvX64ExceptionTypeInvalidOpcodeFault = 0x6,
    WHvX64ExceptionTypeDeviceNotAvailableFault = 0x7,
    WHvX64ExceptionTypeDoubleFaultAbort = 0x8,
    WHvX64ExceptionTypeInvalidTaskStateSegmentFault = 0x0A,
    WHvX64ExceptionTypeSegmentNotPresentFault = 0x0B,
    WHvX64ExceptionTypeStackFault = 0x0C,
    WHvX64ExceptionTypeGeneralProtectionFault = 0x0D,
    WHvX64ExceptionTypePageFault = 0x0E,
    WHvX64ExceptionTypeFloatingPointErrorFault = 0x10,
    WHvX64ExceptionTypeAlignmentCheckFault = 0x11,
    WHvX64ExceptionTypeMachineCheckAbort = 0x12,
    WHvX64ExceptionTypeSimdFloatingPointFault = 0x13,
} WHV_EXCEPTION_TYPE;

//
// WHvGetPartitionProperty output buffer / WHvSetPartitionProperty input buffer
//
typedef union WHV_PARTITION_PROPERTY
{
    WHV_EXTENDED_VM_EXITS ExtendedVmExits;
    WHV_PROCESSOR_FEATURES ProcessorFeatures;
    UINT8 ProcessorClFlushSize;
    UINT32 ProcessorCount;
    UINT32 CpuidExitList[1];
    WHV_X64_CPUID_RESULT CpuidResultList[1];
    UINT64 ExceptionExitBitmap;
} WHV_PARTITION_PROPERTY;

//
// Memory Management
//

//
// Guest physical or virtual address
//
typedef UINT64 WHV_GUEST_PHYSICAL_ADDRESS;
typedef UINT64 WHV_GUEST_VIRTUAL_ADDRESS;

//
// Flags used by WHvMapGpaRange
//
/*typedef enum WHV_MAP_GPA_RANGE_FLAGS
{
    WHvMapGpaRangeFlagNone    = 0x00000000,
    WHvMapGpaRangeFlagRead    = 0x00000001,
    WHvMapGpaRangeFlagWrite   = 0x00000002,
    WHvMapGpaRangeFlagExecute = 0x00000004,
} WHV_MAP_GPA_RANGE_FLAGS;*/

#define   WHvMapGpaRangeFlagNone     0x00000000
#define    WHvMapGpaRangeFlagRead     0x00000001
#define    WHvMapGpaRangeFlagWrite    0x00000002
#define    WHvMapGpaRangeFlagExecute  0x00000004
#define WHV_MAP_GPA_RANGE_FLAGS DWORD
//DEFINE_ENUM_FLAG_OPERATORS(WHV_MAP_GPA_RANGE_FLAGS);

//
// Flags used by WHvTranslateGva
//
typedef enum WHV_TRANSLATE_GVA_FLAGS
{
    WHvTranslateGvaFlagNone             = 0x00000000,
    WHvTranslateGvaFlagValidateRead     = 0x00000001,
    WHvTranslateGvaFlagValidateWrite    = 0x00000002,
    WHvTranslateGvaFlagValidateExecute  = 0x00000004,
    WHvTranslateGvaFlagPrivilegeExempt  = 0x00000008,
    WHvTranslateGvaFlagSetPageTableBits = 0x00000010
} WHV_TRANSLATE_GVA_FLAGS;

//DEFINE_ENUM_FLAG_OPERATORS(WHV_TRANSLATE_GVA_FLAGS);

//
// Result of an attempt to translate a guest virtual address
//
typedef enum WHV_TRANSLATE_GVA_RESULT_CODE
{
    WHvTranslateGvaResultSuccess                 = 0,

    // Translation failures
    WHvTranslateGvaResultPageNotPresent          = 1,
    WHvTranslateGvaResultPrivilegeViolation      = 2,
    WHvTranslateGvaResultInvalidPageTableFlags   = 3,

    // GPA access failures
    WHvTranslateGvaResultGpaUnmapped             = 4,
    WHvTranslateGvaResultGpaNoReadAccess         = 5,
    WHvTranslateGvaResultGpaNoWriteAccess        = 6,
    WHvTranslateGvaResultGpaIllegalOverlayAccess = 7,
    WHvTranslateGvaResultIntercept               = 8
} WHV_TRANSLATE_GVA_RESULT_CODE;

//
// Output buffer of WHvTranslateGva
//
typedef struct WHV_TRANSLATE_GVA_RESULT
{
    WHV_TRANSLATE_GVA_RESULT_CODE ResultCode;
    UINT32 Reserved;
} WHV_TRANSLATE_GVA_RESULT;

//
// Virtual Processor Register Definitions
//
typedef enum WHV_REGISTER_NAME
{
    // X64 General purpose registers
    WHvX64RegisterRax              = 0x00000000,
    WHvX64RegisterRcx              = 0x00000001,
    WHvX64RegisterRdx              = 0x00000002,
    WHvX64RegisterRbx              = 0x00000003,
    WHvX64RegisterRsp              = 0x00000004,
    WHvX64RegisterRbp              = 0x00000005,
    WHvX64RegisterRsi              = 0x00000006,
    WHvX64RegisterRdi              = 0x00000007,
    WHvX64RegisterR8               = 0x00000008,
    WHvX64RegisterR9               = 0x00000009,
    WHvX64RegisterR10              = 0x0000000A,
    WHvX64RegisterR11              = 0x0000000B,
    WHvX64RegisterR12              = 0x0000000C,
    WHvX64RegisterR13              = 0x0000000D,
    WHvX64RegisterR14              = 0x0000000E,
    WHvX64RegisterR15              = 0x0000000F,
    WHvX64RegisterRip              = 0x00000010,
    WHvX64RegisterRflags           = 0x00000011,

    // X64 Segment registers
    WHvX64RegisterEs               = 0x00000012,
    WHvX64RegisterCs               = 0x00000013,
    WHvX64RegisterSs               = 0x00000014,
    WHvX64RegisterDs               = 0x00000015,
    WHvX64RegisterFs               = 0x00000016,
    WHvX64RegisterGs               = 0x00000017,
    WHvX64RegisterLdtr             = 0x00000018,
    WHvX64RegisterTr               = 0x00000019,

    // X64 Table registers
    WHvX64RegisterIdtr             = 0x0000001A,
    WHvX64RegisterGdtr             = 0x0000001B,

    // X64 Control Registers
    WHvX64RegisterCr0              = 0x0000001C,
    WHvX64RegisterCr2              = 0x0000001D,
    WHvX64RegisterCr3              = 0x0000001E,
    WHvX64RegisterCr4              = 0x0000001F,
    WHvX64RegisterCr8              = 0x00000020,

    // X64 Debug Registers
    WHvX64RegisterDr0              = 0x00000021,
    WHvX64RegisterDr1              = 0x00000022,
    WHvX64RegisterDr2              = 0x00000023,
    WHvX64RegisterDr3              = 0x00000024,
    WHvX64RegisterDr6              = 0x00000025,
    WHvX64RegisterDr7              = 0x00000026,

    // X64 Floating Point and Vector Registers
    WHvX64RegisterXmm0             = 0x00001000,
    WHvX64RegisterXmm1             = 0x00001001,
    WHvX64RegisterXmm2             = 0x00001002,
    WHvX64RegisterXmm3             = 0x00001003,
    WHvX64RegisterXmm4             = 0x00001004,
    WHvX64RegisterXmm5             = 0x00001005,
    WHvX64RegisterXmm6             = 0x00001006,
    WHvX64RegisterXmm7             = 0x00001007,
    WHvX64RegisterXmm8             = 0x00001008,
    WHvX64RegisterXmm9             = 0x00001009,
    WHvX64RegisterXmm10            = 0x0000100A,
    WHvX64RegisterXmm11            = 0x0000100B,
    WHvX64RegisterXmm12            = 0x0000100C,
    WHvX64RegisterXmm13            = 0x0000100D,
    WHvX64RegisterXmm14            = 0x0000100E,
    WHvX64RegisterXmm15            = 0x0000100F,
    WHvX64RegisterFpMmx0           = 0x00001010,
    WHvX64RegisterFpMmx1           = 0x00001011,
    WHvX64RegisterFpMmx2           = 0x00001012,
    WHvX64RegisterFpMmx3           = 0x00001013,
    WHvX64RegisterFpMmx4           = 0x00001014,
    WHvX64RegisterFpMmx5           = 0x00001015,
    WHvX64RegisterFpMmx6           = 0x00001016,
    WHvX64RegisterFpMmx7           = 0x00001017,
    WHvX64RegisterFpControlStatus  = 0x00001018,
    WHvX64RegisterXmmControlStatus = 0x00001019,

    // X64 MSRs
    WHvX64RegisterTsc              = 0x00002000,
    WHvX64RegisterEfer             = 0x00002001,
    WHvX64RegisterKernelGsBase     = 0x00002002,
    WHvX64RegisterApicBase         = 0x00002003,
    WHvX64RegisterPat              = 0x00002004,
    WHvX64RegisterSysenterCs       = 0x00002005,
    WHvX64RegisterSysenterEip      = 0x00002006,
    WHvX64RegisterSysenterEsp      = 0x00002007,
    WHvX64RegisterStar             = 0x00002008,
    WHvX64RegisterLstar            = 0x00002009,
    WHvX64RegisterCstar            = 0x0000200A,
    WHvX64RegisterSfmask           = 0x0000200B,

    WHvX64RegisterMsrMtrrCap         = 0x0000200D,
    WHvX64RegisterMsrMtrrDefType     = 0x0000200E,

    WHvX64RegisterMsrMtrrPhysBase0   = 0x00002010,
    WHvX64RegisterMsrMtrrPhysBase1   = 0x00002011,
    WHvX64RegisterMsrMtrrPhysBase2   = 0x00002012,
    WHvX64RegisterMsrMtrrPhysBase3   = 0x00002013,
    WHvX64RegisterMsrMtrrPhysBase4   = 0x00002014,
    WHvX64RegisterMsrMtrrPhysBase5   = 0x00002015,
    WHvX64RegisterMsrMtrrPhysBase6   = 0x00002016,
    WHvX64RegisterMsrMtrrPhysBase7   = 0x00002017,
    WHvX64RegisterMsrMtrrPhysBase8   = 0x00002018,
    WHvX64RegisterMsrMtrrPhysBase9   = 0x00002019,
    WHvX64RegisterMsrMtrrPhysBaseA   = 0x0000201A,
    WHvX64RegisterMsrMtrrPhysBaseB   = 0x0000201B,
    WHvX64RegisterMsrMtrrPhysBaseC   = 0x0000201C,
    WHvX64RegisterMsrMtrrPhysBaseD   = 0x0000201D,
    WHvX64RegisterMsrMtrrPhysBaseE   = 0x0000201E,
    WHvX64RegisterMsrMtrrPhysBaseF   = 0x0000201F,

    WHvX64RegisterMsrMtrrPhysMask0   = 0x00002040,
    WHvX64RegisterMsrMtrrPhysMask1   = 0x00002041,
    WHvX64RegisterMsrMtrrPhysMask2   = 0x00002042,
    WHvX64RegisterMsrMtrrPhysMask3   = 0x00002043,
    WHvX64RegisterMsrMtrrPhysMask4   = 0x00002044,
    WHvX64RegisterMsrMtrrPhysMask5   = 0x00002045,
    WHvX64RegisterMsrMtrrPhysMask6   = 0x00002046,
    WHvX64RegisterMsrMtrrPhysMask7   = 0x00002047,
    WHvX64RegisterMsrMtrrPhysMask8   = 0x00002048,
    WHvX64RegisterMsrMtrrPhysMask9   = 0x00002049,
    WHvX64RegisterMsrMtrrPhysMaskA   = 0x0000204A,
    WHvX64RegisterMsrMtrrPhysMaskB   = 0x0000204B,
    WHvX64RegisterMsrMtrrPhysMaskC   = 0x0000204C,
    WHvX64RegisterMsrMtrrPhysMaskD   = 0x0000204D,
    WHvX64RegisterMsrMtrrPhysMaskE   = 0x0000204E,
    WHvX64RegisterMsrMtrrPhysMaskF   = 0x0000204F,

    WHvX64RegisterMsrMtrrFix64k00000 = 0x00002070,
    WHvX64RegisterMsrMtrrFix16k80000 = 0x00002071,
    WHvX64RegisterMsrMtrrFix16kA0000 = 0x00002072,
    WHvX64RegisterMsrMtrrFix4kC0000  = 0x00002073,
    WHvX64RegisterMsrMtrrFix4kC8000  = 0x00002074,
    WHvX64RegisterMsrMtrrFix4kD0000  = 0x00002075,
    WHvX64RegisterMsrMtrrFix4kD8000  = 0x00002076,
    WHvX64RegisterMsrMtrrFix4kE0000  = 0x00002077,
    WHvX64RegisterMsrMtrrFix4kE8000  = 0x00002078,
    WHvX64RegisterMsrMtrrFix4kF0000  = 0x00002079,
    WHvX64RegisterMsrMtrrFix4kF8000  = 0x0000207A,

    WHvX64RegisterTscAux           = 0x0000207B,

    // Interrupt / Event Registers
    WHvRegisterPendingInterruption = 0x80000000,
    WHvRegisterInterruptState      = 0x80000001,
    WHvRegisterPendingEvent0       = 0x80000002,
    WHvRegisterPendingEvent1       = 0x80000003,
    WHvX64RegisterDeliverabilityNotifications = 0x80000004,

} WHV_REGISTER_NAME;

typedef union DECLSPEC_ALIGN(16) WHV_UINT128
{
    struct
    {
        UINT64  Low64;
        UINT64  High64;
    };

    UINT32  Dword[4];
} WHV_UINT128;

typedef union WHV_X64_FP_REGISTER
{
    struct
    {
        UINT64 Mantissa;
        UINT64 BiasedExponent:15;
        UINT64 Sign:1;
        UINT64 Reserved:48;
    };

    WHV_UINT128 AsUINT128;
} WHV_X64_FP_REGISTER;

typedef union WHV_X64_FP_CONTROL_STATUS_REGISTER
{
    struct
    {
        UINT16 FpControl;
        UINT16 FpStatus;
        UINT8  FpTag;
        UINT8  Reserved;
        UINT16 LastFpOp;
        union
        {
            // Long Mode
            UINT64 LastFpRip;

            // 32 Bit Mode
            struct
            {
                UINT32 LastFpEip;
                UINT16 LastFpCs;
                UINT16 Reserved2;
            };
        };
    };

    WHV_UINT128 AsUINT128;
} WHV_X64_FP_CONTROL_STATUS_REGISTER;

typedef union WHV_X64_XMM_CONTROL_STATUS_REGISTER
{
    struct
    {
        union
        {
            // Long Mode
            UINT64 LastFpRdp;

            // 32 Bit Mode
            struct
            {
                UINT32 LastFpDp;
                UINT16 LastFpDs;
                UINT16 Reserved;
            };
        };
        UINT32 XmmStatusControl;
        UINT32 XmmStatusControlMask;
    };

    WHV_UINT128 AsUINT128;
} WHV_X64_XMM_CONTROL_STATUS_REGISTER;

typedef struct WHV_X64_SEGMENT_REGISTER
{
    UINT64 Base;
    UINT32 Limit;
    UINT16 Selector;

    union
    {
        struct
        {
            UINT16 SegmentType:4;
            UINT16 NonSystemSegment:1;
            UINT16 DescriptorPrivilegeLevel:2;
            UINT16 Present:1;
            UINT16 Reserved:4;
            UINT16 Available:1;
            UINT16 Long:1;
            UINT16 Default:1;
            UINT16 Granularity:1;
        };

        UINT16 Attributes;
    };
} WHV_X64_SEGMENT_REGISTER;

typedef struct WHV_X64_TABLE_REGISTER
{
    UINT16     Pad[3];
    UINT16     Limit;
    UINT64     Base;
} WHV_X64_TABLE_REGISTER;

typedef union WHV_X64_INTERRUPT_STATE_REGISTER
{
    struct
    {
        UINT64 InterruptShadow:1;
        UINT64 NmiMasked:1;
        UINT64 Reserved:62;
    };

    UINT64 AsUINT64;
} WHV_X64_INTERRUPT_STATE_REGISTER;

typedef union WHV_X64_PENDING_INTERRUPTION_REGISTER
{
    struct
    {
        UINT32 InterruptionPending:1;
        UINT32 InterruptionType:3;  // WHV_X64_PENDING_INTERRUPTION_TYPE
        UINT32 DeliverErrorCode:1;
        UINT32 InstructionLength:4;
        UINT32 NestedEvent:1;
        UINT32 Reserved:6;
        UINT32 InterruptionVector:16;
        UINT32 ErrorCode;
    };

    UINT64 AsUINT64;
} WHV_X64_PENDING_INTERRUPTION_REGISTER;

typedef union WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER
{
    struct
    {
        UINT64 NmiNotification:1;
        UINT64 InterruptNotification:1;
        UINT64 InterruptPriority:4;
        UINT64 Reserved:58;
    };

    UINT64 AsUINT64;
} WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER;

//
// Register values
//
typedef union WHV_REGISTER_VALUE
{
    WHV_UINT128 Reg128;
    UINT64 Reg64;
    UINT32 Reg32;
    UINT16 Reg16;
    UINT8 Reg8;
    WHV_X64_FP_REGISTER Fp;
    WHV_X64_FP_CONTROL_STATUS_REGISTER FpControlStatus;
    WHV_X64_XMM_CONTROL_STATUS_REGISTER XmmControlStatus;
    WHV_X64_SEGMENT_REGISTER Segment;
    WHV_X64_TABLE_REGISTER Table;
    WHV_X64_INTERRUPT_STATE_REGISTER InterruptState;
    WHV_X64_PENDING_INTERRUPTION_REGISTER PendingInterruption;
    WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER DeliverabilityNotifications;
} WHV_REGISTER_VALUE;

//
// Virtual Processor Execution
//

//
// Reason for a VM exit
//
typedef enum WHV_RUN_VP_EXIT_REASON
{
    WHvRunVpExitReasonNone                   = 0x00000000,

    // Standard exits caused by operations of the virtual processor
    WHvRunVpExitReasonMemoryAccess           = 0x00000001,
    WHvRunVpExitReasonX64IoPortAccess        = 0x00000002,
    WHvRunVpExitReasonUnrecoverableException = 0x00000004,
    WHvRunVpExitReasonInvalidVpRegisterValue = 0x00000005,
    WHvRunVpExitReasonUnsupportedFeature     = 0x00000006,
    WHvRunVpExitReasonX64InterruptWindow     = 0x00000007,
    WHvRunVpExitReasonX64Halt                = 0x00000008,

    // Additional exits that can be configured through partition properties
    WHvRunVpExitReasonX64MsrAccess           = 0x00001000,
    WHvRunVpExitReasonX64Cpuid               = 0x00001001,
    WHvRunVpExitReasonException              = 0x00001002,

    // Exits caused by the host
    WHvRunVpExitReasonCanceled               = 0x00002001,
} WHV_RUN_VP_EXIT_REASON;

//
// Execution state of the virtual processor
//
typedef union WHV_X64_VP_EXECUTION_STATE
{
    struct
    {
        UINT16 Cpl : 2;
        UINT16 Cr0Pe : 1;
        UINT16 Cr0Am : 1;
        UINT16 EferLma : 1;
        UINT16 DebugActive : 1;
        UINT16 InterruptionPending : 1;
        UINT16 Reserved0 : 5;
        UINT16 InterruptShadow : 1;
        UINT16 Reserved1 : 3;
    };

    UINT16 AsUINT16;
} WHV_X64_VP_EXECUTION_STATE;

//
// Execution context of a virtual processor at the time of an exit
//
typedef struct WHV_VP_EXIT_CONTEXT
{
    WHV_X64_VP_EXECUTION_STATE ExecutionState;
    UINT8 InstructionLength : 4;
    UINT8 Cr8 : 4;
    UINT8 Reserved;
    UINT32 Reserved2;
    WHV_X64_SEGMENT_REGISTER Cs;
    UINT64 Rip;
    UINT64 Rflags;
} WHV_VP_EXIT_CONTEXT;

//
// Context data for a VM exit caused by a memory access (WHvRunVpExitReasonMemoryAccess)
//
typedef enum WHV_MEMORY_ACCESS_TYPE
{
    WHvMemoryAccessRead    = 0,
    WHvMemoryAccessWrite   = 1,
    WHvMemoryAccessExecute = 2
} WHV_MEMORY_ACCESS_TYPE;

typedef union WHV_MEMORY_ACCESS_INFO
{
    struct {
        UINT32 AccessType  : 2;  // WHV_MEMORY_ACCESS_TYPE
        UINT32 GpaUnmapped : 1;
        UINT32 GvaValid    : 1;
        UINT32 Reserved    : 28;
    };

    UINT32 AsUINT32;
} WHV_MEMORY_ACCESS_INFO;

typedef struct WHV_MEMORY_ACCESS_CONTEXT
{
    // Context of the virtual processor
    UINT8 InstructionByteCount;
    UINT8 Reserved[3];
    UINT8 InstructionBytes[16];

    // Memory access info
    WHV_MEMORY_ACCESS_INFO AccessInfo;
    WHV_GUEST_PHYSICAL_ADDRESS Gpa;
    WHV_GUEST_VIRTUAL_ADDRESS Gva;
} WHV_MEMORY_ACCESS_CONTEXT;

//
// Context data for an exit caused by an I/O port access (WHvRunVpExitReasonX64IOPortAccess)
//
typedef union WHV_X64_IO_PORT_ACCESS_INFO
{
    struct
    {
        UINT32 IsWrite : 1;
        UINT32 AccessSize: 3;
        UINT32 StringOp : 1;
        UINT32 RepPrefix : 1;
        UINT32 Reserved : 26;
    };

    UINT32 AsUINT32;
} WHV_X64_IO_PORT_ACCESS_INFO;

typedef struct WHV_X64_IO_PORT_ACCESS_CONTEXT
{
    // Context of the virtual processor
    UINT8 InstructionByteCount;
    UINT8 Reserved[3];
    UINT8 InstructionBytes[16];

    // I/O port access info
    WHV_X64_IO_PORT_ACCESS_INFO AccessInfo;
    UINT16 PortNumber;
    UINT16 Reserved2[3];
    UINT64 Rax;
    UINT64 Rcx;
    UINT64 Rsi;
    UINT64 Rdi;
    WHV_X64_SEGMENT_REGISTER Ds;
    WHV_X64_SEGMENT_REGISTER Es;
} WHV_X64_IO_PORT_ACCESS_CONTEXT;

//
// Context data for an exit caused by an MSR access (WHvRunVpExitReasonX64MSRAccess)
//
typedef union WHV_X64_MSR_ACCESS_INFO
{
    struct
    {
        UINT32 IsWrite : 1;
        UINT32 Reserved : 31;
    };

    UINT32 AsUINT32;
} WHV_X64_MSR_ACCESS_INFO;

typedef struct WHV_X64_MSR_ACCESS_CONTEXT
{
    // MSR access info
    WHV_X64_MSR_ACCESS_INFO AccessInfo;
    UINT32 MsrNumber;
    UINT64 Rax;
    UINT64 Rdx;
} WHV_X64_MSR_ACCESS_CONTEXT;

//
// Context data for an exit caused by a CPUID call (WHvRunVpExitReasonX64CPUID)
//
typedef struct WHV_X64_CPUID_ACCESS_CONTEXT
{
    // CPUID access info
    UINT64 Rax;
    UINT64 Rcx;
    UINT64 Rdx;
    UINT64 Rbx;
    UINT64 DefaultResultRax;
    UINT64 DefaultResultRcx;
    UINT64 DefaultResultRdx;
    UINT64 DefaultResultRbx;
} WHV_X64_CPUID_ACCESS_CONTEXT;

//
// Context data for an exit caused by an exception generated by the virtual processor
// (WHvRunVpExitReasonException)
//
typedef union WHV_VP_EXCEPTION_INFO
{
    struct
    {
        UINT32 ErrorCodeValid : 1;
        UINT32 SoftwareException : 1;
        UINT32 Reserved : 30;
    };

    UINT32 AsUNIT32;
} WHV_VP_EXCEPTION_INFO;

typedef struct WHV_VP_EXCEPTION_CONTEXT
{
    UINT8 InstructionByteCount;
    UINT8 Reserved[3];
    UINT8 InstructionBytes[16];

    // Exception info
    WHV_VP_EXCEPTION_INFO ExceptionInfo;
    UINT8 ExceptionType; // WHV_EXCEPTION_TYPE
    UINT8 Reserved2[3];
    UINT32 ErrorCode;
    UINT64 ExceptionParameter;
} WHV_VP_EXCEPTION_CONTEXT;

//
// Context data for an exit caused by the use of an unsupported processor feature
// (WHvRunVpExitReasonUnsupportedFeature)
//
typedef enum WHV_X64_UNSUPPORTED_FEATURE_CODE
{
    WHvUnsupportedFeatureIntercept     = 1,
    WHvUnsupportedFeatureTaskSwitchTss = 2
} WHV_X64_UNSUPPORTED_FEATURE_CODE;

typedef struct WHV_X64_UNSUPPORTED_FEATURE_CONTEXT
{
    WHV_X64_UNSUPPORTED_FEATURE_CODE FeatureCode;
    UINT32 Reserved;
    UINT64 FeatureParameter;
} WHV_X64_UNSUPPORTED_FEATURE_CONTEXT;

//
// Context data for an exit caused by a cancellation from the host (WHvRunVpExitReasonCanceled)
//
typedef enum WHV_RUN_VP_CANCEL_REASON
{
    WhvRunVpCancelReasonUser = 0 // Execution canceled by HvCancelRunVirtualProcessor
} WHV_RUN_VP_CANCEL_REASON;

typedef struct WHV_RUN_VP_CANCELED_CONTEXT
{
    WHV_RUN_VP_CANCEL_REASON CancelReason;
} WHV_RUN_VP_CANCELED_CONTEXT;

//
// Context data for an exit caused by an interrupt delivery window cancellation from the host
// (WHvRunVpExitReasonX64InterruptWindow)
//
typedef enum WHV_X64_PENDING_INTERRUPTION_TYPE
{
    WHvX64PendingInterrupt           = 0,
    WHvX64PendingNmi                 = 2,
    WHvX64PendingException           = 3
} WHV_X64_PENDING_INTERRUPTION_TYPE, *PWHV_X64_PENDING_INTERRUPTION_TYPE;

typedef struct WHV_X64_INTERRUPTION_DELIVERABLE_CONTEXT
{
    WHV_X64_PENDING_INTERRUPTION_TYPE DeliverableType;
} WHV_X64_INTERRUPTION_DELIVERABLE_CONTEXT, *PWHV_X64_INTERRUPTION_DELIVERABLE_CONTEXT;


// WHvRunVirtualProcessor output buffer
typedef struct WHV_RUN_VP_EXIT_CONTEXT
{
    WHV_RUN_VP_EXIT_REASON ExitReason;
    UINT32 Reserved;
    WHV_VP_EXIT_CONTEXT VpContext;

    union
    {
        WHV_MEMORY_ACCESS_CONTEXT MemoryAccess;
        WHV_X64_IO_PORT_ACCESS_CONTEXT IoPortAccess;
        WHV_X64_MSR_ACCESS_CONTEXT MsrAccess;
        WHV_X64_CPUID_ACCESS_CONTEXT CpuidAccess;
        WHV_VP_EXCEPTION_CONTEXT VpException;
        WHV_X64_INTERRUPTION_DELIVERABLE_CONTEXT InterruptWindow;
        WHV_X64_UNSUPPORTED_FEATURE_CONTEXT UnsupportedFeature;
        WHV_RUN_VP_CANCELED_CONTEXT CancelReason;
    };
} WHV_RUN_VP_EXIT_CONTEXT;

#if defined(_MSC_VER) && (_MSC_VER >= 1200)
#pragma warning(pop)
#endif


```

`WinVisorDLL/WinVisorDLL.h`:

```h
#define _WIN32_WINNT 0x0600
#define _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_DEPRECATE
#include <stdio.h>
#include <windows.h>
#include "WinHvApi.h"
#include "..\Common\WinVisorCommon.h"

#define ThreadBasicInformation 0

#define PAGE_SIZE 0x1000

#define CR0_PROTECTED_MODE 0x1
#define CR0_COPROCESSOR_MONITORING 0x2
#define CR0_PAGING 0x80000000

#define CR4_PAE 0x20
#define CR4_OSFXSR 0x200
#define CR4_OSXSAVE 0x40000

#define EFER_SYSCALL_ENABLE 0x1
#define EFER_LONG_MODE_ENABLE 0x100
#define EFER_LONG_MODE_ACTIVE 0x400
#define EFER_NX_ENABLE 0x800

#define EFLAGS_RESERVED_ALWAYS_ON 0x2

#define PAGE_PRESENT 0x1
#define PAGE_WRITABLE 0x2
#define PAGE_USER 0x4

#define QWORD UINT64

#define SEGMENT_SELECTOR_CODE_CPL0 0x10
#define SEGMENT_SELECTOR_CODE_CPL3 0x33
#define SEGMENT_SELECTOR_DATA_CPL0 0x18
#define SEGMENT_SELECTOR_DATA_CPL3 0x2B
#define SEGMENT_SELECTOR_TSS 0x40

#define PAGE_TABLE_BASE_PHYSICAL_ADDRESS 0x0

#define SYSCALL_VIRTUAL_ADDRESS 0xFFFF800000000000
#define CPL3_ENTRY_VIRTUAL_ADDRESS 0xFFFF900000000000
#define INTERRUPT_HANDLER_VIRTUAL_ADDRESS 0xFFFFA00000000000

#define CPL3_INITIAL_RFLAGS 0x202

#define MAX_SYSCALL_PARAM_COUNT 32

#define MAX_MAPPED_PAGE_COUNT 256

#define MAX_GDT_ENTRY_COUNT 0xB
#define MAX_IDT_ENTRY_COUNT 0x100
#define TSS_SIZE 0x68

#define GDT_PRESENT 0x800000000000
#define GDT_DPL0 0x0
#define GDT_DPL3 0x600000000000
#define GDT_NON_SYSTEM 0x100000000000
#define GDT_CODE 0x80000000000
#define GDT_DATA 0x0
#define GDT_CODE_READ 0x20000000000
#define GDT_DATA_WRITE 0x20000000000
#define GDT_ACCESSED 0x10000000000
#define GDT_LONG 0x20000000000000
#define GDT_TSS 0x90000000000
#define GDT_DB 0x40000000000000

#define IDT_INTERRUPT_GATE 0xE0000000000
#define IDT_DPL3 0x600000000000
#define IDT_PRESENT 0x800000000000

#define CPL0_STACK_SIZE PAGE_SIZE

#define LOG_INFO 0
#define LOG_ERROR 1
#define LOG_DEBUG 2

#define UNKNOWN_SYSCALL_PARAM_COUNT 0xFFFFFFFF

#define TABLE_REGISTER_LIMIT_SHIFT 48

struct CLIENT_ID
{
	HANDLE UniqueProcess;
	HANDLE UniqueThread;
};

struct THREAD_BASIC_INFORMATION
{
	DWORD ExitStatus;
	PVOID TebBaseAddress;
	CLIENT_ID ClientId;
	ULONG_PTR AffinityMask;
	DWORD Priority;
	LONG BasePriority;
};

struct SyscallNameEntryStruct
{
	char szName[128];
	DWORD dwVirtualAddress;
	DWORD dwParamCount;
};

struct MappedVirtualAddressStruct
{
	DWORD dwInUse;
	QWORD qwCreationIndex;

	UINT64 qwVirtualAddress;
	UINT64 qwPhysicalAddress;
};

struct PageTableStruct
{
	UINT64 qwEntries[512];
};

struct VirtualAddressTableIndexesStruct
{
	WORD wPML4;
	WORD wPDPT;
	WORD wPD;
	WORD wPT;
	WORD wOffset;
};

struct PagingStateStruct
{
	DWORD dwTotalEntryCount;
	DWORD dwNextEntryIndex;
};

struct SyscallInfoStruct
{
	DWORD dwSyscallIndex;
	UINT64 qwParamList[MAX_SYSCALL_PARAM_COUNT];
};

struct CpuRegisterStateStruct
{
	QWORD RAX;
	QWORD RCX;
	QWORD RDX;
	QWORD RBX;
	QWORD RSP;
	QWORD RBP;
	QWORD RSI;
	QWORD RDI;
	QWORD R8;
	QWORD R9;
	QWORD R10;
	QWORD R11;
	QWORD R12;
	QWORD R13;
	QWORD R14;
	QWORD R15;
	QWORD RIP;
	QWORD RFLAGS;
};

struct ImportFunctionStruct
{
	char *pName;
	void **pFunctionPtrAddr;
};

struct UINT128
{
	UINT64 Low;
	UINT64 High;
};

struct CpuStateStruct
{
	UINT64 GDT[MAX_GDT_ENTRY_COUNT];
	BYTE TSS[TSS_SIZE];
	UINT128 IDT[MAX_IDT_ENTRY_COUNT];

	VOID *pCPL0_Stack;
	VOID *pCPL3_Stack;

	HANDLE hHostThread;
	VOID *pHostThreadTEB;

	HANDLE hSyscallProxyReadyEvent;
	HANDLE hSyscallWaitingEvent;
	HANDLE hSyscallCompleteEvent;
	SyscallInfoStruct SyscallInfo;
	UINT64 qwSyscallReturnValue;

	CpuRegisterStateStruct CPL3_InitialCpuRegisterState;
};

struct InterruptHandlerEntryStruct
{
	BYTE bInterruptIndex;
	DWORD (*pHandler)(CpuStateStruct *pCpuState, CpuRegisterStateStruct *pCpuRegisterState);
	DWORD dwHasErrorCode;
};

struct SyscallHookEntryStruct
{
	char *pSyscallName;
	DWORD (*pHandler)(CpuStateStruct *pCpuState, CpuRegisterStateStruct *pCpuRegisterState, SyscallInfoStruct *pSyscallInfo, UINT64 *pqwReturnValue);
};

struct BootloaderParamsStruct
{
	UINT64 qwGDT_Limit;
	UINT64 qwGDT_Base;
	UINT64 qwIDT_Limit;
	UINT64 qwIDT_Base;
	UINT64 qwTSS_Selector;
	UINT64 qwXCR0;
	UINT64 qwCPL3_DataSelector;
	UINT64 qwCPL3_RFLAGS;
	UINT64 qwCPL3_EntryPlaceholderAddress;
};

extern DWORD InitialiseLogServer();
extern DWORD CloseLogServer();
extern DWORD WriteLog(DWORD dwLogType, char *pStringFormat, ...);
extern BYTE *LoadExecutable(char *pExeFilePath);
extern DWORD ExecuteSyscall(SyscallInfoStruct *pSyscallInfo, UINT64 *pqwReturnValue);
extern DWORD HypervisorUtils_Initialise();
extern DWORD HypervisorUtils_GetRegisterValue_U64(WHV_REGISTER_NAME RegisterName, QWORD *pqwRegisterValue);
extern DWORD HypervisorUtils_SetRegisterValue_U64(WHV_REGISTER_NAME RegisterName, QWORD qwRegisterValue);
extern DWORD HypervisorUtils_SetRegisterValue_Segment(WHV_REGISTER_NAME RegisterName, WORD wSelector, DWORD dwCode);
extern DWORD HypervisorUtils_CreateEnvironment();
extern DWORD HypervisorUtils_DeleteEnvironment();
extern DWORD HypervisorUtils_ResumeExecution(WHV_RUN_VP_EXIT_CONTEXT *pVmExitContext);
extern DWORD HypervisorUtils_FlushTLB();
extern DWORD HypervisorUtils_UnmapGuestMemory(void *pGuestPhysicalAddress, DWORD dwSize);
extern DWORD HypervisorUtils_MapGuestMemory(void *pHostVirtualAddress, void *pGuestPhysicalAddress, DWORD dwSize);
extern DWORD PrepareCPL0(CpuStateStruct *pCpuState);
extern DWORD WINAPI SyscallProxyThread(CpuStateStruct *pCpuState);
extern InterruptHandlerEntryStruct *GetInterruptHandler(BYTE bInterruptIndex);
extern DWORD InterruptHandler_Breakpoint(CpuStateStruct *pCpuState, CpuRegisterStateStruct *pCpuRegisterState);
extern DWORD InterruptHandler_SingleStep(CpuStateStruct *pCpuState, CpuRegisterStateStruct *pCpuRegisterState);
extern BYTE *GetInterruptReturn(InterruptHandlerEntryStruct *pInterruptHandlerEntry);
extern DWORD AddPagedVirtualAddress(UINT64 qwVirtualAddress);
extern DWORD CreatePageTables();
extern DWORD CreateSyscallLists();
extern char *GetSyscallName(DWORD dwSyscallIndex, DWORD *pdwParamCount);
extern DWORD HandleVmExit(CpuStateStruct *pCpuState, CpuRegisterStateStruct *pCpuRegisterState, WHV_RUN_VP_EXIT_CONTEXT *pVmExitContext);
extern DWORD HandlePageFault(CpuStateStruct *pCpuState, CpuRegisterStateStruct *pCpuRegisterState, UINT64 qwVirtualAddress);
extern DWORD HandleSyscallInstruction(CpuStateStruct *pCpuState, CpuRegisterStateStruct *pCpuRegisterState);
extern DWORD SyscallHook_NtTerminateThread(CpuStateStruct *pCpuState, CpuRegisterStateStruct *pCpuRegisterState, SyscallInfoStruct *pSyscallInfo, UINT64 *pqwReturnValue);
extern DWORD SyscallHook_NtTerminateProcess(CpuStateStruct *pCpuState, CpuRegisterStateStruct *pCpuRegisterState, SyscallInfoStruct *pSyscallInfo, UINT64 *pqwReturnValue);
extern DWORD ForwardSyscallToHost(CpuStateStruct *pCpuState, SyscallInfoStruct *pSyscallInfo, UINT64 *pqwReturnValue);
extern DWORD InterruptHandler_LegacySyscall(CpuStateStruct *pCpuState, CpuRegisterStateStruct *pCpuRegisterState);
extern DWORD HandleGuestSyscall(CpuStateStruct *pCpuState, CpuRegisterStateStruct *pCpuRegisterState, VOID *pUserStackPtr);
extern IMAGE_NT_HEADERS *GetNtHeader(VOID *pModuleBase);
extern DWORD gdwStopLog;
extern DWORD FixNtdllHypervisorSharedPagePtr();
extern HMODULE ghNtdllBase;
extern DWORD (WINAPI *pNtQueryInformationThread)(HANDLE ThreadHandle, DWORD ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength, PULONG ReturnLength);
extern DWORD (WINAPI *pNtQuerySystemInformation)(DWORD SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);
extern DWORD GuestProcessExited(DWORD dwExitCode);
extern DWORD ValidateReadPointer(VOID *pAddress, SIZE_T dwLength);
extern DWORD gdwDebugLogEnabled;
extern DWORD PopulateSyscallParamCounts(char *pModuleName, SyscallNameEntryStruct *pSyscallList, DWORD dwSyscallCount);
extern DWORD AppendString(char *pString, SIZE_T dwMaxLength, char *pAppend);
extern DWORD HypervisorUtils_GetRegisters(CpuRegisterStateStruct *pCpuRegisterState);
extern DWORD HypervisorUtils_SetRegisters(CpuRegisterStateStruct *pCpuRegisterState);
extern DWORD PrepareCPL3(CpuStateStruct *pCpuState, WinVisorStartDataStruct *pWinVisorStartData);
extern CpuStateStruct *CreateCpuState(WinVisorStartDataStruct *pWinVisorStartData);
extern DWORD DeleteCpuState(CpuStateStruct *pCpuState);
extern DWORD DeleteSyscallLists();
extern DWORD DeletePageTables();
extern DWORD ExecXGETBV(DWORD dwIndex, QWORD *pqwReturnValue);
extern DWORD FixModuleImports(VOID *pModuleBase);
extern DWORD HypervisorEntryPoint(VOID *pExeEntryPoint);
extern HMODULE ghExeBase;
extern DWORD CopyMemoryAndRestoreProtection(VOID *pDestination, VOID *pSource, DWORD dwLength);
extern DWORD gdwLoadedModuleImports;
extern DWORD gdwLogImportSyscallsEnabled;

```

`WinVisorDLL/WinVisorDLL.vcproj`:

```vcproj
<?xml version="1.0" encoding="Windows-1252"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="8.00"
	Name="WinVisorDLL"
	ProjectGUID="{BF705FB8-4B81-4092-8F99-603FE08884FD}"
	RootNamespace="WinVisorDLL"
	Keyword="Win32Proj"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
		<Platform
			Name="x64"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Debug|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="2"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;WINVISORDLL_EXPORTS"
				MinimalRebuild="true"
				BasicRuntimeChecks="3"
				RuntimeLibrary="3"
				UsePrecompiledHeader="0"
				WarningLevel="3"
				Detect64BitPortabilityProblems="true"
				DebugInformationFormat="4"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				LinkIncremental="2"
				GenerateDebugInformation="true"
				SubSystem="2"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Debug|x64"
			OutputDirectory="$(SolutionDir)$(PlatformName)\$(ConfigurationName)"
			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
			ConfigurationType="2"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
				TargetEnvironment="3"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;WINVISORDLL_EXPORTS"
				MinimalRebuild="true"
				BasicRuntimeChecks="3"
				RuntimeLibrary="3"
				UsePrecompiledHeader="0"
				WarningLevel="3"
				Detect64BitPortabilityProblems="true"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				LinkIncremental="2"
				GenerateDebugInformation="true"
				SubSystem="2"
				TargetMachine="17"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="2"
			CharacterSet="1"
			WholeProgramOptimization="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;WINVISORDLL_EXPORTS"
				RuntimeLibrary="2"
				UsePrecompiledHeader="0"
				WarningLevel="3"
				Detect64BitPortabilityProblems="true"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				LinkIncremental="1"
				GenerateDebugInformation="true"
				SubSystem="2"
				OptimizeReferences="2"
				EnableCOMDATFolding="2"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Release|x64"
			OutputDirectory="$(SolutionDir)$(PlatformName)\$(ConfigurationName)"
			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
			ConfigurationType="2"
			CharacterSet="1"
			WholeProgramOptimization="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
				TargetEnvironment="3"
			/>
			<Tool
				Name="VCCLCompilerTool"
				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;WINVISORDLL_EXPORTS"
				RuntimeLibrary="0"
				UsePrecompiledHeader="0"
				WarningLevel="3"
				Detect64BitPortabilityProblems="true"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				LinkIncremental="1"
				GenerateDebugInformation="true"
				SubSystem="2"
				OptimizeReferences="2"
				EnableCOMDATFolding="2"
				TargetMachine="17"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="Source Files"
			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
			>
			<File
				RelativePath=".\CreateCpuState.cpp"
				>
			</File>
			<File
				RelativePath=".\FixModuleImports.cpp"
				>
			</File>
			<File
				RelativePath=".\HandleVmExit.cpp"
				>
			</File>
			<File
				RelativePath=".\HypervisorEntryPoint.cpp"
				>
			</File>
			<File
				RelativePath=".\HypervisorUtils.cpp"
				>
			</File>
			<File
				RelativePath=".\InterruptHandler_Breakpoint.cpp"
				>
			</File>
			<File
				RelativePath=".\InterruptHandler_LegacySyscall.cpp"
				>
			</File>
			<File
				RelativePath=".\InterruptHandler_SingleStep.cpp"
				>
			</File>
			<File
				RelativePath=".\Interrupts.cpp"
				>
			</File>
			<File
				RelativePath=".\LogServer.cpp"
				>
			</File>
			<File
				RelativePath=".\Main.cpp"
				>
			</File>
			<File
				RelativePath=".\Misc.cpp"
				>
			</File>
			<File
				RelativePath=".\PageFault.cpp"
				>
			</File>
			<File
				RelativePath=".\PageTable.cpp"
				>
			</File>
			<File
				RelativePath=".\PrepareCPL0.cpp"
				>
			</File>
			<File
				RelativePath=".\PrepareCPL3.cpp"
				>
			</File>
			<File
				RelativePath=".\SyscallHook_NtTerminateProcess.cpp"
				>
			</File>
			<File
				RelativePath=".\SyscallHook_NtTerminateThread.cpp"
				>
			</File>
			<File
				RelativePath=".\SyscallNames.cpp"
				>
			</File>
			<File
				RelativePath=".\SyscallParamCount.cpp"
				>
			</File>
			<File
				RelativePath=".\SyscallProxy.cpp"
				>
			</File>
		</Filter>
		<Filter
			Name="Header Files"
			Filter="h;hpp;hxx;hm;inl;inc;xsd"
			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
			>
			<File
				RelativePath=".\WinHvApi.h"
				>
			</File>
			<File
				RelativePath="..\Common\WinVisorCommon.h"
				>
			</File>
			<File
				RelativePath=".\WinVisorDLL.h"
				>
			</File>
		</Filter>
		<Filter
			Name="Resource Files"
			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
			>
		</Filter>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>

```