Project Path: arc_gmh5225_mhynot2_extabk3h

Source Tree:

```txt
arc_gmh5225_mhynot2_extabk3h
├── CMakeLists.txt
├── README.md
├── launcher
│   └── launcher.cpp
├── mhynot2-rewritten
│   ├── Backend.h
│   ├── Common.cpp
│   ├── Common.h
│   ├── Config.h
│   ├── EmulatorBackend.cpp
│   ├── EmulatorBackend.h
│   ├── Header.h
│   ├── PacketCrypt.cpp
│   ├── PacketCrypt.h
│   ├── PassthroughBackend.cpp
│   ├── PassthroughBackend.h
│   ├── dllmain.cpp
│   ├── mhynot2-rewritten.vcxproj
│   ├── mhynot2-rewritten.vcxproj.filters
│   ├── mhyprot2.h
│   ├── mt64.cpp
│   └── mt64.h
├── mhynot2-rewritten.sln
└── minhook

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

set (CMAKE_SYSTEM_NAME Windows)

# Injected library

project(mhynot2 VERSION 1.0.0 DESCRIPTION "mhyprot2 user-mode emulator")

add_library(mhynot2 SHARED
    mhynot2-rewritten/Common.cpp
    mhynot2-rewritten/dllmain.cpp
    mhynot2-rewritten/EmulatorBackend.cpp
    mhynot2-rewritten/EmulatorBackend.h
    mhynot2-rewritten/mt64.cpp
    mhynot2-rewritten/PacketCrypt.cpp
    mhynot2-rewritten/PassthroughBackend.cpp
)

target_compile_features(mhynot2 PRIVATE cxx_std_17)

add_subdirectory(minhook)
target_compile_definitions(mhynot2 PRIVATE UNICODE)
target_include_directories(mhynot2 PRIVATE mhynot2-rewritten)
target_link_libraries(mhynot2 minhook shlwapi)

if (MINGW)
    target_link_libraries(mhynot2 winpthread)
    target_link_options(mhynot2 PRIVATE -static-libgcc -static-libstdc++ -static)
endif()

# Launcher executable

project(launcher VERSION 1.0.0 DESCRIPTION "DLL Injector for Genshin")

add_executable(launcher WIN32
    launcher/launcher.cpp
)

target_link_libraries(launcher shlwapi)

```

`README.md`:

```md
# mhynot2
![](https://i.imgur.com/elNjsSM.png)

Cheating is bad, but I think requiring a kernel driver to play a (mostly) single-player game is worse.

mhynot2 is a hook DLL which hooks into various API functions to emulate the functionality of mhyprot2.sys without actually running a driver. Tested on Genshin Impact 2.2, 2.3, 2.4, 2.5 (mhyprot3.sys not used WTF?????????), 2.6 (mhyprot3.sys used for some people?), and 2.7 (THEY WENT BACK TO MHYPROT2!!!!!).

Even though this is a tool to get around cheat prevention measures, this is intended as a tool for research and experimental purposes and isn't specifically designed for cheating.

**This tool has many flaws and will be detected. You will get banned for using this.**

## Usage
Compile and run https://gist.github.com/khang06/56e3c221769648132023daab9fd2bc39

or...

1. Launch the game with x64dbg with ScyllaHide on the VMProtect preset
2. Run to the game's entrypoint
3. Inject the DLL with Cheat Engine
4. Go!

## Linux build
1. Init/update git submodules
1. Go to `minhook` directory and build it with `CROSS_PREFIX=x86_64-w64-mingw32- make -f build/MinGW/Makefile`
1. Run `mkdir build && cd build && cmake .. && make -j256`
1. Grab `mhynot2.dll` and inject it together with `libwinpthread-1.dll`

```

`launcher/launcher.cpp`:

```cpp
#include <windows.h>
#include <shlwapi.h>
#include <stdio.h>

int inject_library(HANDLE hProcess, const char* dll) 
{
    auto loadlibrary = LoadLibraryA; // i actually had no idea that the address of kernel32 is the same between all processes
    auto mem = VirtualAllocEx(hProcess, NULL, strlen(dll) + 1, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    printf("LoadLibraryA %p\n", loadlibrary);
    printf("allocated path addr %p\n", mem);
    if (!mem) {
        printf("VirtualAllocEx epic fail GLE: 0x%x\n", GetLastError());
        return 1;
    }
    WriteProcessMemory(hProcess, mem, dll, strlen(dll) + 1, NULL);

    auto new_thread = CreateRemoteThread(
        hProcess,
        NULL,
        NULL,
        (LPTHREAD_START_ROUTINE)loadlibrary,
        mem,
        NULL,
        NULL
    );
    if (new_thread == NULL) {
        printf("CreateRemoteThread epic fail GLE: 0x%x\n", GetLastError());
        return 1;
    }

    printf("waiting for the dll loading thread to exit\n");
    WaitForSingleObject(new_thread, INFINITE);
    printf("looks like the dll injected properly\n");

    VirtualFreeEx(hProcess, mem, 0, MEM_RELEASE);

    CloseHandle(new_thread);
    return 0;
}

int main(int argc, char* argv[]) {
    if (argc < 3) {
      puts("Too few arguments!");
      printf("Usage: %s Genshin_Base_Directory Dll_To_Inject_1 [Dll_To_Inject_2 ...]\n", argv[0]);
      return 1;
    }

    for (int i = 2; i < argc; i++) {
      if (!PathFileExistsA(argv[i])) {
        printf("DLL provided couldn't be found: %s\n");
        return 1;
      }
    }

    if (!SetCurrentDirectoryA(argv[1])) {
      printf("Failed to set working directory, GLE: %d\n", GetLastError());
      return 1;
    }
    SetEnvironmentVariableW(L"__COMPAT_LAYER", L"RunAsInvoker"); // forcefully run as not admin

    STARTUPINFOW startup_info = {};
    startup_info.cb = sizeof(startup_info);
    PROCESS_INFORMATION process_info = {};

    SECURITY_ATTRIBUTES attrib = {};
    attrib.nLength = sizeof(attrib);
    SECURITY_DESCRIPTOR desc = {};

    BOOL created = CreateProcessW(
        L"GenshinImpact.exe",
        NULL,
        NULL,
        NULL,
        FALSE,
        CREATE_SUSPENDED,
        NULL,
        NULL,
        &startup_info,
        &process_info
    );

    if (created == FALSE) {
        printf("CreateProcessW epic fail GLE 0x%x\n", GetLastError());
        return 1;
    }

    for (int i = 2; i < argc; i++) {
      if (inject_library(process_info.hProcess, argv[i])) {
        printf("Error injecting %s!\n", argv[i]);
        TerminateProcess(process_info.hProcess, 1);
        return 1;
      }
    }

    if (ResumeThread(process_info.hThread) == -1) {
        printf("ResumeThread epic fail GLE: 0x%x\n", GetLastError());
        return 1;
    }

    printf("everything seems to be good, cleaning up!\n");

    CloseHandle(process_info.hProcess);
    CloseHandle(process_info.hThread);
    return 0;
}

```

`mhynot2-rewritten.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.0.31717.71
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "mhynot2-rewritten", "mhynot2-rewritten\mhynot2-rewritten.vcxproj", "{7F520BDD-E9C5-4968-AC36-DCF599065F48}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{7F520BDD-E9C5-4968-AC36-DCF599065F48}.Debug|x64.ActiveCfg = Debug|x64
		{7F520BDD-E9C5-4968-AC36-DCF599065F48}.Debug|x64.Build.0 = Debug|x64
		{7F520BDD-E9C5-4968-AC36-DCF599065F48}.Debug|x86.ActiveCfg = Debug|Win32
		{7F520BDD-E9C5-4968-AC36-DCF599065F48}.Debug|x86.Build.0 = Debug|Win32
		{7F520BDD-E9C5-4968-AC36-DCF599065F48}.Release|x64.ActiveCfg = Release|x64
		{7F520BDD-E9C5-4968-AC36-DCF599065F48}.Release|x64.Build.0 = Release|x64
		{7F520BDD-E9C5-4968-AC36-DCF599065F48}.Release|x86.ActiveCfg = Release|Win32
		{7F520BDD-E9C5-4968-AC36-DCF599065F48}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {BF7BD334-04FC-4B31-8C6A-B1D76A593316}
	EndGlobalSection
EndGlobal

```

`mhynot2-rewritten/Backend.h`:

```h
#pragma once
#include <windows.h>
#include <optional>
#include <vector>
#include <cstdint>

class Backend {
public:
	// service hooks, only passing what's necessary
	virtual std::optional<SC_HANDLE> OpenSCManagerWHook(LPCWSTR lpMachineName, LPCWSTR lpDatabaseName, DWORD dwDesiredAccess) = 0;
	virtual std::optional<SC_HANDLE> CreateServiceWHook(LPCWSTR lpServiceName) = 0;
	virtual std::optional<SC_HANDLE> OpenServiceWHook(LPCWSTR lpServiceName) = 0;
	virtual std::optional<BOOL> StartServiceWHook(SC_HANDLE hService) = 0;
	//virtual bool QueryServiceStatusHook(SC_HANDLE hService) = 0; // doesn't actually get called??
	virtual std::optional<BOOL> ControlServiceHook(SC_HANDLE hService, DWORD dwControl, LPSERVICE_STATUS lpServiceStatus) = 0;
	virtual std::optional<BOOL> DeleteServiceHook(SC_HANDLE hService) = 0;
	virtual std::optional<BOOL> CloseServiceHandleHook(SC_HANDLE hService) = 0;

	// not technically hooks
	virtual std::optional<HANDLE> OpenDriverPipe() = 0;
	virtual std::optional<std::vector<uint8_t>> DriverInit(LPVOID input) = 0;
	virtual std::optional<std::vector<uint8_t>> HandleIOCTLRequest(DWORD control_code, std::vector<uint8_t> input) = 0;
	virtual void HandleIOCTLResponse(DWORD control_code, std::vector<uint8_t> input, std::vector<uint8_t> output) = 0;

	HANDLE driver_pipe = INVALID_HANDLE_VALUE;
};
```

`mhynot2-rewritten/Common.cpp`:

```cpp
#include <windows.h>
#include <tlhelp32.h>
#include <string>
#include "Common.h"

namespace Common {
    __declspec(noreturn) void Panic(const char* msg, ...) {
        va_list args;
        va_start(args, msg);

        char buf[1024] = {};
        vsnprintf(buf, sizeof(buf) - 1, msg, args);

        MessageBoxA(NULL, buf, "PANIC!!!!!!", 0);

        va_end(args);
        exit(1);
    }

    // https://stackoverflow.com/questions/29242/off-the-shelf-c-hex-dump-code
    void Hexdump(void* ptr, size_t buflen) {
        unsigned char* buf = (unsigned char*)ptr;
        size_t i, j;
        for (i = 0; i < buflen; i += 16) {
            printf("%06x: ", i);
            for (j = 0; j < 16; j++)
                if (i + j < buflen)
                    printf("%02x ", buf[i + j]);
                else
                    printf("   ");
            printf(" ");
            for (j = 0; j < 16; j++)
                if (i + j < buflen)
                    printf("%c", isprint(buf[i + j]) ? buf[i + j] : '.');
            printf("\n");
        }
    }

    std::wstring PIDToProcessName(DWORD pid) {
        auto snap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
        std::wstring ret = L"???";

        if (snap) {
            PROCESSENTRY32 pe32;
            pe32.dwSize = sizeof(PROCESSENTRY32);
            if (Process32First(snap, &pe32)) {
                do {
                    if (pe32.th32ProcessID == pid) {
                        ret = pe32.szExeFile;
                        break;
                    }
                } while (Process32Next(snap, &pe32));
            }
            CloseHandle(snap);
        } else {
            Panic("CreateToolhelp32Snapshot failed somehow...");
        }

        return ret;
    }
}

```

`mhynot2-rewritten/Common.h`:

```h
#pragma once

#ifndef NOMINMAX
#define NOMINMAX // We're using std::min here
#endif // NOMINMAX

#include <windows.h>
#include <cstdarg>
#include <cstdio>
#include <string>

#define LODWORD(x)  (*((uint32_t*)&(x)))

#define BLK "\x1b[0;30m"
#define RED "\x1b[0;31m"
#define GRN "\x1b[0;32m"
#define YEL "\x1b[0;33m"
#define BLU "\x1b[0;34m"
#define MAG "\x1b[0;35m"
#define CYN "\x1b[0;36m"
#define WHT "\x1b[0;37m"

EXTERN_C IMAGE_DOS_HEADER __ImageBase;

namespace Common {
	__declspec(noreturn) void Panic(const char* msg, ...);
	void Hexdump(void* ptr, size_t buflen);
	std::wstring PIDToProcessName(DWORD pid);
}

```

`mhynot2-rewritten/Config.h`:

```h
#pragma once

// TODO: this should be configurable at runtime, maybe from an ini or something

namespace Config {
	constexpr bool EmulatorMode = true;
}
```

`mhynot2-rewritten/EmulatorBackend.cpp`:

```cpp
#include <cassert>
#define NOMINMAX // We're using std::min here
#include <windows.h>
#include <psapi.h>
#include <shlwapi.h>

#include "PacketCrypt.h"
#include "EmulatorBackend.h"
#include "mhyprot2.h"

bool heartbeat_thread_started = false;
DWORD WINAPI HeartbeatThread(LPVOID lpParameter) {
    printf("Hello from HeartbeatThread!\n");
    uint64_t iters = 0;
    while (true) {
        Sleep(100);
        iters++;
        if (iters % 30 == 11) {
            // technically this should be KeSetEvent(heartbeat_event, 0, 0)
            // hopefully those are the same thing
            SetEvent(lpParameter);
        }
    }
    return 0;
}

std::optional<SC_HANDLE> EmulatorBackend::OpenSCManagerWHook(LPCWSTR lpMachineName, LPCWSTR lpDatabaseName, DWORD dwDesiredAccess) {
    return MANAGER_DUMMY_HANDLE;
}
std::optional<SC_HANDLE> EmulatorBackend::CreateServiceWHook(LPCWSTR lpServiceName) {
    if (!wcsncmp(lpServiceName, L"mhyprot2", 256)) {
        service_created = true;
        return DUMMY_HANDLE;
    }
    return (SC_HANDLE)NULL;
}
std::optional<SC_HANDLE> EmulatorBackend::OpenServiceWHook(LPCWSTR lpServiceName) {
    if (service_created && !wcsncmp(lpServiceName, L"mhyprot2", 256))
        return DUMMY_HANDLE;
    return (SC_HANDLE)NULL;
}
std::optional<BOOL> EmulatorBackend::StartServiceWHook(SC_HANDLE hService) {
    if (hService == DUMMY_HANDLE)
        return TRUE;
    return FALSE;
}
std::optional<BOOL> EmulatorBackend::ControlServiceHook(SC_HANDLE hService, DWORD dwControl, LPSERVICE_STATUS lpServiceStatus) {
    assert(dwControl == 1);
    assert(hService == DUMMY_HANDLE);

    lpServiceStatus->dwServiceType = SERVICE_KERNEL_DRIVER;
    lpServiceStatus->dwCurrentState = SERVICE_STOP_PENDING; // not sure why it's like this
    lpServiceStatus->dwControlsAccepted = SERVICE_ACCEPT_STOP;
    lpServiceStatus->dwWin32ExitCode = NO_ERROR;
    lpServiceStatus->dwServiceSpecificExitCode = NO_ERROR;
    lpServiceStatus->dwCheckPoint = 0;
    lpServiceStatus->dwWaitHint = 0;

    return TRUE;
}
std::optional<BOOL> EmulatorBackend::DeleteServiceHook(SC_HANDLE hService) {
    assert(hService == DUMMY_HANDLE);
    service_created = false;
    return TRUE;
}
std::optional<BOOL> EmulatorBackend::CloseServiceHandleHook(SC_HANDLE hService) {
    if (hService == DUMMY_HANDLE || hService == MANAGER_DUMMY_HANDLE)
        return TRUE;
    return {};
}

std::optional<HANDLE> EmulatorBackend::OpenDriverPipe() {
    return DUMMY_HANDLE;
}
std::optional<std::vector<uint8_t>> EmulatorBackend::DriverInit(LPVOID input) {
    auto val = PacketCrypt::Init(((uint64_t*)input)[1] ^ 0xEBBAAEF4FFF89042);

    std::vector<uint8_t> ret;
    ret.resize(8);
    memcpy(ret.data(), &val, sizeof(val));
    return ret;
}
std::optional<std::vector<uint8_t>> EmulatorBackend::HandleIOCTLRequest(DWORD control_code, std::vector<uint8_t> input) {
    // TODO: temporary until everything is emulated
    std::optional<std::vector<uint8_t>> output = {};

    // TODO: messy, needs to be refactored...
    switch (control_code) {
    case (DWORD)MhyProt2Ioctl::HeartBeat: {
        auto out = std::vector<uint8_t>();
        out.resize(8);
        *(uint64_t*)out.data() = 0xc8;
        output = out;
        break;
    }
    case (DWORD)MhyProt2Ioctl::HeartBeat2: {
        auto out = std::vector<uint8_t>();
        out.resize(8);
        *(uint64_t*)out.data() = 2;
        output = out;
        break;
    }
    case (DWORD)MhyProt2Ioctl::GetDriverStatus:
    case (DWORD)MhyProt2Ioctl::GetDriverVersion: {
        auto out = std::vector<uint8_t>();
        out.resize(4);
        *(uint32_t*)out.data() = 0;
        output = out;
        break;
    }
    case (DWORD)MhyProt2Ioctl::ListProcessModule: {
        assert(input.size() == sizeof(ListProcessModuleRequest));
        auto* req = (ListProcessModuleRequest*)input.data();
        printf("pid: 0x%x (%ls), max count: %d\n", req->pid, Common::PIDToProcessName(req->pid).c_str(), req->max_count);

        std::vector<ListProcessModuleResponse> modules;

        assert(req->pid == GetCurrentProcessId());
        
        HMODULE hmodules[512];
        DWORD hmodules_size;
        // even if the requested size is too small, this loop still needs to happen in order to give an accurate count
        if (EnumProcessModules(GetCurrentProcess(), hmodules, sizeof(hmodules), &hmodules_size)) {
            for (int i = 0; i < (hmodules_size / sizeof(HMODULE)); i++) {
                auto mod = hmodules[i];
                MODULEINFO mod_info = {};
                GetModuleInformation(GetCurrentProcess(), mod, &mod_info, sizeof(mod_info));

                ListProcessModuleResponse res = {};

                res.base = mod; // HMODULEs are just pointers to the base
                GetModuleFileNameW(mod, res.path, MAX_PATH);
                wcsncpy(res.name, PathFindFileNameW(res.path), sizeof(res.name) / sizeof(wchar_t));
                res.size = mod_info.SizeOfImage;

                // TODO: make this configurable!
                const std::wstring blacklisted_modules[] = {
                    L"HookLibraryx64.dll",    // ScyllaHide
                    L"mhynot2-rewritten.dll", // hmmmmmmmm
                };
                // TODO: case sensitive!
                bool is_blacklisted = false;
                for (auto name : blacklisted_modules) {
                    if (name == res.name) {
                        printf(YEL "Blocked enumeration of blacklisted module %ls\n" WHT, res.name);
                        is_blacklisted = true;
                        break;
                    }
                }
                if (!is_blacklisted)
                    modules.push_back(res);
            }
        } else {
            Common::Panic("EnumProcessModules failed!");
        }

        // TODO: this is messy and probably should be abstracted out
        auto out = std::vector<uint8_t>();
        out.resize(modules.size() * sizeof(ListProcessModuleResponse) + 4);
        *(uint32_t*)out.data() = (uint32_t)modules.size();
        if (modules.size() <= req->max_count)
            memcpy(out.data() + 4, modules.data(), modules.size() * sizeof(ListProcessModuleResponse));
        output = out;

        break;
    }
    case (DWORD)MhyProt2Ioctl::EnumProcessList: {
        assert(input.size() == sizeof(EnumProcessListRequest));
        auto* req = (EnumProcessListRequest*)input.data();
        printf("struct size: 0x%x, max count: %d\n", req->struct_size, req->max_count);

        // TODO: should have some fake processes, just listing own process for now
        EnumProcessListResponse res = {};
        
        // TODO: do i really need all of these fields?
        FILETIME creation_time;
        FILETIME exit_time;
        FILETIME kernel_time;
        FILETIME user_time;
        if (!GetProcessTimes(GetCurrentProcess(), &creation_time, &exit_time, &kernel_time, &user_time))
            Common::Panic("GetProcessTimes failed! GLE: 0x%x", GetLastError());

        memcpy(&res.create_time, &creation_time, sizeof(res.create_time));
        res.eprocess = (void*)0xFFFF8002B86962E0; // just some random kernel pointer
        res.pid = GetCurrentProcessId();
        res.is_64bit = true;
        GetModuleFileNameW(NULL, res.path, MAX_PATH);

        auto out = std::vector<uint8_t>();
        out.resize(sizeof(res) + 4);
        *(uint32_t*)out.data() = 1;
        memcpy(out.data() + 4, &res, sizeof(res));
        output = out;
        break;
    }
    case (DWORD)MhyProt2Ioctl::RWMemory: {
        assert(input.size() == sizeof(RWMemoryRequest));
        auto* req = (RWMemoryRequest*)input.data();
        printf("mode: %s, pid: 0x%x (%ls), to_addr: %p, from_addr: %p, size: 0x%x\n",
            req->mode ? "this -> target" : "target -> this", req->target_pid, Common::PIDToProcessName(req->target_pid).c_str(), req->to_addr, req->from_addr, req->size);

        assert(req->target_pid == GetCurrentProcessId());

        // check if the memory is actually writable
        // yes, the actual driver will return 0 if the memory is not writable
        MEMORY_BASIC_INFORMATION mem_info = {};
        // i really don't care about anything other than the protection of the first page
        if (VirtualQuery(req->to_addr, &mem_info, 0x1000) == 0)
            Common::Panic("VirtualQuery failed!");

        auto out = std::vector<uint8_t>();
        out.resize(4);
        if (mem_info.Protect != PAGE_EXECUTE_READWRITE && mem_info.Protect != PAGE_READWRITE) {
            // memory not writable
            *(uint32_t*)out.data() = 0;
        } else {
            memcpy(req->to_addr, req->from_addr, req->size);

            // TODO: technically still getting detected anyways
            if (req->from_addr == &__ImageBase) {
                printf(RED "Shitty evasive measure running!\n" WHT);
                memset(req->to_addr, 0, req->size);
            }

            *(uint32_t*)out.data() = req->size;
        }
        output = out;
        break;
    }
    case (DWORD)MhyProt2Ioctl::MDL: {
        assert(input.size() == sizeof(MDLRequest));
        auto* req = (MDLRequest*)input.data();
        printf("process_event: %p, image_event: %p, thread_event: %p, heartbeat_event: %p\n",
            req->process_event, req->image_event, req->thread_event, req->heartbeat_event);

        // other events not handled, just heartbeat
        assert(!heartbeat_thread_started);
        heartbeat_thread_started = true;

        CreateThread(NULL, 0, HeartbeatThread, req->heartbeat_event, 0, NULL);

        // since those threads are never signalled, hopefully the client never accesses these
        // if it does, it should be easy to tell which one it tried accessing
        MDLResponse res;
        res.image_shared_mem = (void*)0xCAFEBEBECAFEBEBE;
        res.process_shared_mem = (void*)0xCAFEB0BACAFEB0BA;
        res.thread_shared_mem = (void*)0xCAFED00DCAFED00D;
        res.dummy = nullptr;

        auto out = std::vector<uint8_t>();
        out.resize(sizeof(res));
        memcpy(out.data(), &res, sizeof(res));
        output = out;
        break;
    }
    case (DWORD)MhyProt2Ioctl::FreeSharedMemory: {
        assert(input.size() == sizeof(FreeSharedMemoryRequest));
        auto* req = (FreeSharedMemoryRequest*)input.data();
        printf("shared_mem: %p, pmdl: %p, kernel_mem: %p\n", req->shared_mem, req->pmdl, req->kernel_mem);

        // ignore the kernel addresses
        assert(req->shared_mem != nullptr);
        free(req->shared_mem);

        auto out = std::vector<uint8_t>();
        out.resize(4);
        *(uint32_t*)out.data() = 0;
        output = out;
        break;
    }
    case (DWORD)MhyProt2Ioctl::GetProcessHandles: {
        assert(input.size() == sizeof(GetProcessHandlesRequest));
        auto* req = (GetProcessHandlesRequest*)input.data();
        printf("pid: 0x%xp (%ls)\n", req->pid, Common::PIDToProcessName(req->pid).c_str());

        // just pretend like there are no handles that match what it wants
        GetProcessHandlesResponse res = {};
        res.status = 0xFFFFFFFF;

        auto out = std::vector<uint8_t>();
        out.resize(sizeof(res));
        memcpy(out.data(), &res, sizeof(res));
        output = out;
        break;
    }
    case (DWORD)MhyProt2Ioctl::EnumDrivers: {
        assert(input.size() == sizeof(EnumDriversRequest));
        auto* req = (EnumDriversRequest*)input.data();
        printf("unk1: 0x%x, unk2 0x%x\n", req->unk1, req->unk2);

        assert(req->unk1 == 0 && req->unk2 == 0);

        std::vector<EnumDriversEntry> driver_vec;
        LPVOID drivers[512];
        DWORD drivers_size;
        if (EnumDeviceDrivers(drivers, sizeof(drivers), &drivers_size)) {
            for (int i = 0; i < (drivers_size / sizeof(LPVOID)); i++) {
                auto drv = drivers[i];
               
                // no driver blacklist but i don't think most people would need that
                EnumDriversEntry res = {};
                res.base = drv;
                GetDeviceDriverFileNameW(drv, res.path, sizeof(res.path) / sizeof(wchar_t));
                res.size = 0x420000; // there doesn't appear to be a way to get the driver size from usermode

                driver_vec.push_back(res);
            }
        }
        else {
            Common::Panic("EnumDeviceDrivers failed!");
        }

        // more bogus kernel addresses
        // it's important that FreeSharedMemory is handled too, or else a BSoD might happen
        EnumDriversResponse res = {};
        res.status = 0;
        res.count = driver_vec.size();
        res.kernel_mem = (void*)0xDEAD2BADDEAD2BAD;
        res.pmdl = (void*)0xDEADD00DDEADD00D;
        res.shared_mem = (EnumDriversEntry*)malloc(driver_vec.size() * sizeof(EnumDriversEntry));
        if (res.shared_mem == nullptr)
            Common::Panic("HOW");

        memcpy(res.shared_mem, driver_vec.data(), driver_vec.size() * sizeof(EnumDriversEntry));

        auto out = std::vector<uint8_t>();
        out.resize(sizeof(res));
        memcpy(out.data(), &res, sizeof(res));
        output = out;
        break;
    }
    default: {
        printf("Input:\n");
        Common::Hexdump(input.data(), input.size());
    }
    }

    if (output.has_value())
        return PacketCrypt::Encrypt(output.value().data(), output.value().size());

    Common::Panic("unhandled ioctl 0x%x!", control_code);
    return {};
}
void EmulatorBackend::HandleIOCTLResponse(DWORD control_code, std::vector<uint8_t> input, std::vector<uint8_t> output) {
    switch (control_code) {
    case (DWORD)MhyProt2Ioctl::HeartBeat: // ignore, too spammy
    case (DWORD)MhyProt2Ioctl::HeartBeat2:
        break;
    case (DWORD)MhyProt2Ioctl::MDL: {
        assert(output.size() == sizeof(MDLResponse));
        auto* res = (MDLResponse*)output.data();
        printf("process mdl: %p, image mdl: %p, thread mdl: %p\n",
            res->process_shared_mem, res->image_shared_mem, res->thread_shared_mem);
        break;
    }
    case (DWORD)MhyProt2Ioctl::RWMemory:
    case (DWORD)MhyProt2Ioctl::GetDriverStatus:    // always returns 0
    case (DWORD)MhyProt2Ioctl::GetDriverVersion: { // always returns 0
        assert(output.size() == sizeof(uint32_t));
        auto res = *(uint32_t*)output.data();
        printf("status: %d\n", res);
        break;
    }
    case (DWORD)MhyProt2Ioctl::EnumProcessList: {
        auto count = *(uint32_t*)output.data();
        auto req_count = ((EnumProcessListRequest*)input.data())->max_count;
        auto* res = (EnumProcessListResponse*)(output.data() + sizeof(uint32_t));
        printf("process count: %d\n", count);
        if (count <= req_count) {
            int iter_count = std::min(count, 5u);
            printf("first %d processes:\n", iter_count);
            for (int i = 0; i < iter_count; i++) {
                printf("path: %ls, eprocess: %p, is 64-bit: %s\n", res[i].path, res[i].eprocess, res[i].is_64bit ? "yes" : "no");
            }
        } else {
            printf("returned count is more than requested count (%d), ignoring\n", req_count);
        }
        break;
    }
    case (DWORD)MhyProt2Ioctl::ListProcessModule: {
        auto count = *(uint32_t*)output.data();
        auto req_count = ((ListProcessModuleRequest*)input.data())->max_count;
        auto* res = (ListProcessModuleResponse*)(output.data() + sizeof(uint32_t));
        printf("module count: %d\n", count);
        if (count <= req_count) {
            int iter_count = std::min(count, 5u);
            printf("first %d modules:\n", iter_count);
            for (int i = 0; i < iter_count; i++) {
                printf("path: %ls, base: %p, size: 0x%x\n", res[i].path, res[i].base, res[i].size);
            }
        }
        else {
            printf("returned count is more than requested count (%d), ignoring\n", req_count);
        }
        break;
    }
    case (DWORD)MhyProt2Ioctl::GetProcessHandles: {
        assert(output.size() == sizeof(GetProcessHandlesResponse));
        auto* res = (GetProcessHandlesResponse*)output.data();
        printf("status: %d, count: %d\n", res->status, res->count);
        auto* data = res->shared_mem;
        if (data) {
            for (unsigned i = 0; i < res->count; i++)
                printf("handle: 0x%x, type: %ls, obj body: %p\n", data[i].handle, data[i].type, data[i].obj_body);
        }
        break;
    }
    case (DWORD)MhyProt2Ioctl::EnumDrivers: {
        assert(output.size() == sizeof(EnumDriversResponse));
        auto* res = (EnumDriversResponse*)output.data();
        auto* data = res->shared_mem;
        printf("driver count: %d\n", res->count);
        if (data) {
            for (unsigned i = 0; i < res->count; i++)
                printf("path: %ls, size: 0x%x\n", data[i].path, data[i].size);
        }
    }
    /*
    case (DWORD)MhyProt2Ioctl::FreeSharedMemory: {
        // TODO: sometimes this is 32 bytes large?
        assert(output.size() == sizeof(uint32_t));
        auto res = *(uint32_t*)output.data();
        printf("status: %d\n", res);
        break;
    }
    */
    default: {
        printf("Output:\n");
        Common::Hexdump(output.data(), output.size());
    }
    }
}

```

`mhynot2-rewritten/EmulatorBackend.h`:

```h
#pragma once

#include "Backend.h"

class EmulatorBackend : public Backend {
public:
	const SC_HANDLE DUMMY_HANDLE = (SC_HANDLE)0x0B00B135;
	const SC_HANDLE MANAGER_DUMMY_HANDLE = (SC_HANDLE)0xD0D0CACA;

	std::optional<SC_HANDLE> OpenSCManagerWHook(LPCWSTR lpMachineName, LPCWSTR lpDatabaseName, DWORD dwDesiredAccess);
	std::optional<SC_HANDLE> CreateServiceWHook(LPCWSTR lpServiceName);
	std::optional<SC_HANDLE> OpenServiceWHook(LPCWSTR lpServiceName);
	std::optional<BOOL> StartServiceWHook(SC_HANDLE hService);
	std::optional<BOOL> ControlServiceHook(SC_HANDLE hService, DWORD dwControl, LPSERVICE_STATUS lpServiceStatus);
	std::optional<BOOL> DeleteServiceHook(SC_HANDLE hService);
	std::optional<BOOL> CloseServiceHandleHook(SC_HANDLE hService);

	std::optional<HANDLE> OpenDriverPipe();
	std::optional<std::vector<uint8_t>> DriverInit(LPVOID input);
	std::optional<std::vector<uint8_t>> HandleIOCTLRequest(DWORD control_code, std::vector<uint8_t> input);
	void HandleIOCTLResponse(DWORD control_code, std::vector<uint8_t> input, std::vector<uint8_t> output);

private:
	bool service_created = false;
};

```

`mhynot2-rewritten/Header.h`:

```h
#pragma once
#include <windows.h>

class RequestHandler {
	virtual void HandleIOCTL(DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned) = 0;
};
```

`mhynot2-rewritten/PacketCrypt.cpp`:

```cpp
#include "PacketCrypt.h"
#include <cassert>

mt64 PacketCrypt::mt;
bool PacketCrypt::inited = false;

uint64_t PacketCrypt::Init(uint64_t seed) {
	mt64_init(&mt, seed);
	
    uint64_t ret = 0;
	for (int i = 0; i < 7; i++)
		ret = mt64_update(&mt);

    inited = true;

    return ret;
}

std::vector<uint8_t> PacketCrypt::Decrypt(void* data, size_t size) {
    return Crypt((char*)data + 8, size - 8, *(uint64_t*)data);
}

std::vector<uint8_t> PacketCrypt::Encrypt(void* data, size_t size) {
    uint64_t key = 0xDEADBEEFDEADBEEF; // TODO: should be random
    auto temp = std::vector<uint8_t>(size + 8);
    *(uint64_t*)temp.data() = key;
    auto ret = Crypt(data, size, key);
    memcpy(temp.data() + 8, ret.data(), size);
    return temp;
}

std::vector<uint8_t> PacketCrypt::Crypt(void* data, size_t size, uint64_t key) {
    assert(inited);
    mt.mti = 0;
    auto remainder = size % 8;
    auto ret = std::vector<uint8_t>(size);
    size_t idx = 0;
    auto* data_uint64 = (uint64_t*)data;
    size_t handled = 0;
    for (size_t i = 0; i < size / 8; i++) {
        uint64_t offset_key = key + i * 16;
        ((uint64_t*)ret.data())[i] = offset_key ^ mt64_update(&mt) ^ data_uint64[i];
        mt.mti %= 312;
        handled += 8;
    }
    // the remainder is just copied as-is to the end
    if (remainder > 0)
        memcpy(&ret[handled], &((char*)data)[handled], remainder);
    return ret;
}
```

`mhynot2-rewritten/PacketCrypt.h`:

```h
#pragma once

#include <stdint.h>
#include <vector>

#include "mt64.h"

// handles encryption/decryption of mhyprot2 communication
// sadly has to be static
class PacketCrypt {
public:
	static uint64_t Init(uint64_t seed);
	static std::vector<uint8_t> Decrypt(void* data, size_t size);
	static std::vector<uint8_t> Encrypt(void* data, size_t size);

private:
	static std::vector<uint8_t> Crypt(void* data, size_t size, uint64_t key);

	static mt64 mt;
	static bool inited;
}; 
```

`mhynot2-rewritten/PassthroughBackend.cpp`:

```cpp
#include <cassert>

#include "PacketCrypt.h"
#include "PassthroughBackend.h"
#include "mhyprot2.h"

std::optional<SC_HANDLE> PassthroughBackend::OpenSCManagerWHook(LPCWSTR lpMachineName, LPCWSTR lpDatabaseName, DWORD dwDesiredAccess) {
    return {};
}
std::optional<SC_HANDLE> PassthroughBackend::CreateServiceWHook(LPCWSTR lpServiceName) {
	return {};
}
std::optional<SC_HANDLE> PassthroughBackend::OpenServiceWHook(LPCWSTR lpServiceName) {
	return {};
}
std::optional<BOOL> PassthroughBackend::StartServiceWHook(SC_HANDLE hService) {
	return {};
}
std::optional<BOOL> PassthroughBackend::ControlServiceHook(SC_HANDLE hService, DWORD dwControl, LPSERVICE_STATUS lpServiceStatus) {
	return {};
}
std::optional<BOOL> PassthroughBackend::DeleteServiceHook(SC_HANDLE hService) {
	return {};
}
std::optional<BOOL> PassthroughBackend::CloseServiceHandleHook(SC_HANDLE hService) {
    return {};
}

std::optional<HANDLE> PassthroughBackend::OpenDriverPipe() {
	return {};
}
std::optional<std::vector<uint8_t>> PassthroughBackend::DriverInit(LPVOID input) {
    PacketCrypt::Init(((uint64_t*)input)[1] ^ 0xEBBAAEF4FFF89042);
    return {};
}
std::optional<std::vector<uint8_t>> PassthroughBackend::HandleIOCTLRequest(DWORD control_code, std::vector<uint8_t> input) {
    switch (control_code) {
    case (DWORD)MhyProt2Ioctl::HeartBeat:  // ignore, too spammy
    case (DWORD)MhyProt2Ioctl::HeartBeat2: // ignore, too spammy
    case (DWORD)MhyProt2Ioctl::GetDriverStatus:  // always 0
    case (DWORD)MhyProt2Ioctl::GetDriverVersion: // always 0
        break;
    case (DWORD)MhyProt2Ioctl::ListProcessModule: {
        assert(input.size() == sizeof(ListProcessModuleRequest));
        auto* req = (ListProcessModuleRequest*)input.data();
        printf("pid: 0x%x (%ls), max count: %d\n", req->pid, Common::PIDToProcessName(req->pid).c_str(), req->max_count);
        break;
    }
    case (DWORD)MhyProt2Ioctl::EnumProcessList: {
        assert(input.size() == sizeof(EnumProcessListRequest));
        auto* req = (EnumProcessListRequest*)input.data();
        printf("struct size: 0x%x, max count: %d\n", req->struct_size, req->max_count);
        break;
    }
    case (DWORD)MhyProt2Ioctl::RWMemory: {
        assert(input.size() == sizeof(RWMemoryRequest));
        auto* req = (RWMemoryRequest*)input.data();
        printf("mode: %s, pid: 0x%x (%ls), to_addr: %p, from_addr: %p, size: 0x%x\n",
            req->mode ? "this -> target" : "target -> this", req->target_pid, Common::PIDToProcessName(req->target_pid).c_str(), req->to_addr, req->from_addr, req->size);
        break;
    }
    case (DWORD)MhyProt2Ioctl::MDL: {
        assert(input.size() == sizeof(MDLRequest));
        auto* req = (MDLRequest*)input.data();
        printf("process_event: %p, image_event: %p, thread_event: %p, heartbeat_event: %p\n",
            req->process_event, req->image_event, req->thread_event, req->heartbeat_event);
        break;
    }
    case (DWORD)MhyProt2Ioctl::FreeSharedMemory: {
        assert(input.size() == sizeof(FreeSharedMemoryRequest));
        auto* req = (FreeSharedMemoryRequest*)input.data();
        printf("shared_mem: %p, pmdl: %p, kernel_mem: %p\n", req->shared_mem, req->pmdl, req->kernel_mem);
        break;
    }
    case (DWORD)MhyProt2Ioctl::GetProcessHandles: {
        assert(input.size() == sizeof(GetProcessHandlesRequest));
        auto* req = (GetProcessHandlesRequest*)input.data();
        printf("pid: 0x%xp (%ls)\n", req->pid, Common::PIDToProcessName(req->pid).c_str());
        break;
    }
    case (DWORD)MhyProt2Ioctl::EnumDrivers: {
        assert(input.size() == sizeof(EnumDriversRequest));
        auto* req = (EnumDriversRequest*)input.data();
        printf("unk1: 0x%x, unk2 0x%x\n", req->unk1, req->unk2);
        break;
    }
    default: {
        printf("Input:\n");
        Common::Hexdump(input.data(), input.size());
    }
    }

    return {};
}
void PassthroughBackend::HandleIOCTLResponse(DWORD control_code, std::vector<uint8_t> input, std::vector<uint8_t> output) {
    switch (control_code) {
    case (DWORD)MhyProt2Ioctl::HeartBeat: // ignore, too spammy
    case (DWORD)MhyProt2Ioctl::HeartBeat2:
        break;
    case (DWORD)MhyProt2Ioctl::MDL: {
        assert(output.size() == sizeof(MDLResponse));
        auto* res = (MDLResponse*)output.data();
        printf("process mdl: %p, image mdl: %p, thread mdl: %p\n",
            res->process_shared_mem, res->image_shared_mem, res->thread_shared_mem);
        break;
    }
    case (DWORD)MhyProt2Ioctl::RWMemory:
    case (DWORD)MhyProt2Ioctl::GetDriverStatus:    // always returns 0
    case (DWORD)MhyProt2Ioctl::GetDriverVersion: { // always returns 0
        assert(output.size() == sizeof(uint32_t));
        auto res = *(uint32_t*)output.data();
        printf("status: %d\n", res);
        break;
    }
    case (DWORD)MhyProt2Ioctl::EnumProcessList: {
        auto count = *(uint32_t*)output.data();
        auto req_count = ((EnumProcessListRequest*)input.data())->max_count;
        auto* res = (EnumProcessListResponse*)(output.data() + sizeof(uint32_t));
        printf("process count: %d\n", count);
        if (count <= req_count) {
            int iter_count = std::min(count, 5u);
            printf("first %d processes:\n", iter_count);
            for (int i = 0; i < iter_count; i++) {
                printf("path: %ls, eprocess: %p, is 64-bit: %s\n", res[i].path, res[i].eprocess, res[i].is_64bit ? "yes" : "no");
            }
        } else {
            printf("returned count is more than requested count (%d), ignoring\n", req_count);
        }
        break;
    }
    case (DWORD)MhyProt2Ioctl::ListProcessModule: {
        auto count = *(uint32_t*)output.data();
        auto req_count = ((ListProcessModuleRequest*)input.data())->max_count;
        auto* res = (ListProcessModuleResponse*)(output.data() + sizeof(uint32_t));
        printf("module count: %d\n", count);
        if (count <= req_count) {
            int iter_count = std::min(count, 5u);
            printf("first %d modules:\n", iter_count);
            for (int i = 0; i < iter_count; i++) {
                printf("path: %ls, base: %p, size: 0x%x\n", res[i].path, res[i].base, res[i].size);
            }
        }
        else {
            printf("returned count is more than requested count (%d), ignoring\n", req_count);
        }
        break;
    }
    case (DWORD)MhyProt2Ioctl::GetProcessHandles: {
        assert(output.size() == sizeof(GetProcessHandlesResponse));
        auto* res = (GetProcessHandlesResponse*)output.data();
        printf("status: %d, count: %d\n", res->status, res->count);
        auto* data = res->shared_mem;
        if (data) {
            for (unsigned i = 0; i < res->count; i++)
                printf("handle: 0x%x, type: %ls, obj body: %p\n", data[i].handle, data[i].type, data[i].obj_body);
        }
        break;
    }
    case (DWORD)MhyProt2Ioctl::EnumDrivers: {
        assert(output.size() == sizeof(EnumDriversResponse));
        auto* res = (EnumDriversResponse*)output.data();
        auto* data = res->shared_mem;
        printf("driver count: %d\n", res->count);
        if (data) {
            for (unsigned i = 0; i < res->count; i++)
                printf("path: %ls, size: 0x%x\n", data[i].path, data[i].size);
        }
    }
    /*
    case (DWORD)MhyProt2Ioctl::FreeSharedMemory: {
        // TODO: sometimes this is 32 bytes large?
        assert(output.size() == sizeof(uint32_t));
        auto res = *(uint32_t*)output.data();
        printf("status: %d\n", res);
        break;
    }
    */
    default: {
        printf("Output:\n");
        Common::Hexdump(output.data(), output.size());
    }
    }
}

```

`mhynot2-rewritten/PassthroughBackend.h`:

```h
#pragma once

#include "Backend.h"

class PassthroughBackend : public Backend {
public:
	std::optional<SC_HANDLE> OpenSCManagerWHook(LPCWSTR lpMachineName, LPCWSTR lpDatabaseName, DWORD dwDesiredAccess);
	std::optional<SC_HANDLE> CreateServiceWHook(LPCWSTR lpServiceName);
	std::optional<SC_HANDLE> OpenServiceWHook(LPCWSTR lpServiceName);
	std::optional<BOOL> StartServiceWHook(SC_HANDLE hService);
	std::optional<BOOL> ControlServiceHook(SC_HANDLE hService, DWORD dwControl, LPSERVICE_STATUS lpServiceStatus);
	std::optional<BOOL> DeleteServiceHook(SC_HANDLE hService);
	std::optional<BOOL> CloseServiceHandleHook(SC_HANDLE hService);

	std::optional<HANDLE> OpenDriverPipe();
	std::optional<std::vector<uint8_t>> DriverInit(LPVOID input);
	std::optional<std::vector<uint8_t>> HandleIOCTLRequest(DWORD control_code, std::vector<uint8_t> input);
	void HandleIOCTLResponse(DWORD control_code, std::vector<uint8_t> input, std::vector<uint8_t> output);
};
```

`mhynot2-rewritten/dllmain.cpp`:

```cpp
#define NOMINMAX // We're using std::min here
#include <windows.h>
#include <MinHook.h>
#include <mutex>
#include <cassert>
#include <winternl.h>
#include <psapi.h>

#include "Common.h"
#include "mhyprot2.h"
#include "PacketCrypt.h"
#include "EmulatorBackend.h"
#include "PassthroughBackend.h"
#include "Config.h"

#pragma comment(lib, "minhook.x64d.lib")

#pragma region Hooks
// helpers
template <typename T>
inline MH_STATUS MH_CreateHookEx(LPVOID pTarget, LPVOID pDetour, T** ppOriginal)
{
    return MH_CreateHook(pTarget, pDetour, reinterpret_cast<LPVOID*>(ppOriginal));
}

// why do i even have to make 3 macros for 1???
#define MAKE_HOOK(x) ret = MH_CreateHookEx(reinterpret_cast<LPVOID>(x), reinterpret_cast<LPVOID>(MAKE_HOOK_HIDDEN1(x)), (MAKE_HOOK_HIDDEN2(x))); \
                     if (ret != MH_OK) \
                         Common::Panic("Failed to install "#x" hook (%d)", ret); \
                     ret = MH_EnableHook(reinterpret_cast<LPVOID>(x)); \
                     if (ret != MH_OK) \
                         Common::Panic("Failed to enable "#x" hook (%d)", ret); \
                     printf("Installed hook for "#x"\n");
#define MAKE_HOOK_HIDDEN1(x) &custom_##x
#define MAKE_HOOK_HIDDEN2(x) &orig_##x

// global data
HANDLE driver_pipe = INVALID_HANDLE_VALUE;
Backend* backend = nullptr;

// hooks
auto orig_DeviceIoControl = (BOOL(WINAPI*)(HANDLE, DWORD, LPVOID, DWORD, LPVOID, DWORD, LPDWORD, LPOVERLAPPED))nullptr;
std::mutex ioctl_mtx;
BOOL WINAPI custom_DeviceIoControl(HANDLE hDevice, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize,
    LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped) {
    // TODO: should locking be handled by the backend? might improve performance
    const std::lock_guard<std::mutex> lock(ioctl_mtx);

    bool is_driver = hDevice == driver_pipe;
    std::optional<BOOL> hook_ret = {};
    std::optional<std::vector<uint8_t>> custom_output = {};

    if (is_driver) {
        printf(CYN "IOCTL called (tid 0x%x, code 0x%x, %s)\n" WHT, GetCurrentThreadId(), dwIoControlCode, IoctlToString(dwIoControlCode));
        if (dwIoControlCode == (DWORD)MhyProt2Ioctl::DrvInit) {
            assert(nInBufferSize == 0x10);
            custom_output = backend->DriverInit(lpInBuffer);
            if (custom_output.has_value())
                hook_ret = TRUE;
        } else {
            assert(nInBufferSize >= 8);
            auto input = PacketCrypt::Decrypt(lpInBuffer, nInBufferSize);
            custom_output = backend->HandleIOCTLRequest(dwIoControlCode, input);
            if (custom_output.has_value())
                hook_ret = TRUE;
        }
    }

    auto ret = hook_ret.has_value() ? hook_ret.value() : 
        orig_DeviceIoControl(hDevice, dwIoControlCode, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesReturned, lpOverlapped);

    if (custom_output.has_value()) {
        // this doesn't handle lpOverlapped but who cares lol
        auto output = custom_output.value();
        auto ret_size = std::min((DWORD)output.size(), nOutBufferSize);
        *lpBytesReturned = (DWORD)ret_size;
        memcpy(lpOutBuffer, output.data(), ret_size);
    }

    if (is_driver) {
        if (dwIoControlCode != (DWORD)MhyProt2Ioctl::DrvInit) {
            auto input = PacketCrypt::Decrypt(lpInBuffer, nInBufferSize);
            auto encrypted_output =
                custom_output ? custom_output.value() : std::vector((uint8_t*)lpOutBuffer, (uint8_t*)lpOutBuffer + *lpBytesReturned);
            auto output = PacketCrypt::Decrypt(encrypted_output.data(), encrypted_output.size());
            backend->HandleIOCTLResponse(dwIoControlCode, input, output);
        } else {
            Common::Hexdump(lpOutBuffer, *lpBytesReturned);
        }
    }

    return ret;
}

auto orig_TerminateProcess = (BOOL(WINAPI*)(HANDLE, UINT))nullptr;
BOOL WINAPI custom_TerminateProcess(HANDLE hProcess, UINT uExitCode) {
   //Common::Panic("TerminateProcess called! It's probably trying to kill the debugger!");
    printf("TerminateProcess called! It's probably trying to kill the debugger!\n");
    return FALSE;
}

auto orig_CreateServiceW = (SC_HANDLE(WINAPI*)(SC_HANDLE, LPCWSTR, LPCWSTR, DWORD, DWORD, DWORD, DWORD,
    LPCWSTR, LPCWSTR, LPDWORD, LPCWSTR, LPCWSTR, LPCWSTR))nullptr;
SC_HANDLE WINAPI custom_CreateServiceW(
    SC_HANDLE hSCManager,
    LPCWSTR   lpServiceName,
    LPCWSTR   lpDisplayName,
    DWORD     dwDesiredAccess,
    DWORD     dwServiceType,
    DWORD     dwStartType,
    DWORD     dwErrorControl,
    LPCWSTR   lpBinaryPathName,
    LPCWSTR   lpLoadOrderGroup,
    LPDWORD   lpdwTagId,
    LPCWSTR   lpDependencies,
    LPCWSTR   lpServiceStartName,
    LPCWSTR   lpPassword) {
    auto hook_ret = backend->CreateServiceWHook(lpServiceName);
    auto ret = hook_ret.has_value() ? hook_ret.value() :
        orig_CreateServiceW(hSCManager, lpServiceName, lpDisplayName, dwDesiredAccess, dwServiceType,
            dwStartType, dwErrorControl, lpBinaryPathName, lpLoadOrderGroup, lpdwTagId, lpDependencies,
            lpServiceStartName, lpPassword);
    printf("Creating service %ls (handle %p)\n", lpServiceName, ret);
    return ret;
}

auto orig_OpenServiceW = (SC_HANDLE(WINAPI*)(SC_HANDLE, LPCWSTR, DWORD))nullptr;
SC_HANDLE WINAPI custom_OpenServiceW(SC_HANDLE hSCManager, LPCWSTR lpServiceName, DWORD dwDesiredAccess) {
    auto hook_ret = backend->OpenServiceWHook(lpServiceName);
    auto ret = hook_ret.has_value() ? hook_ret.value() :
        orig_OpenServiceW(hSCManager, lpServiceName, dwDesiredAccess);
    printf("OpenServiceW called (service name %ls, ret %p)\n", lpServiceName, ret);
    return ret;
}

auto orig_StartServiceW = (BOOL(WINAPI*)(SC_HANDLE, DWORD, LPCWSTR*))nullptr;
BOOL WINAPI custom_StartServiceW(SC_HANDLE hService, DWORD dwNumServiceArgs, LPCWSTR* lpServiceArgVectors) {
    auto hook_ret = backend->StartServiceWHook(hService);
    auto ret = hook_ret.has_value() ? hook_ret.value() :
        orig_StartServiceW(hService, dwNumServiceArgs, lpServiceArgVectors);
    printf("StartServiceW (handle %p) called\n", hService);
    return ret;
}

auto orig_QueryServiceStatus = (BOOL(WINAPI*)(SC_HANDLE, LPSERVICE_STATUS))nullptr;
BOOL WINAPI custom_QueryServiceStatus(SC_HANDLE hService, LPSERVICE_STATUS lpServiceStatus) {
    auto ret = orig_QueryServiceStatus(hService, lpServiceStatus);
    printf("QueryServiceStatus (handle %p) called\n", hService);
    return ret;
}

auto orig_ControlService = (BOOL(WINAPI*)(SC_HANDLE, DWORD, LPSERVICE_STATUS))nullptr;
BOOL WINAPI custom_ControlService(SC_HANDLE hService, DWORD dwControl, LPSERVICE_STATUS lpServiceStatus) {
    auto hook_ret = backend->ControlServiceHook(hService, dwControl, lpServiceStatus);
    auto ret = hook_ret.has_value() ? hook_ret.value() :
        orig_ControlService(hService, dwControl, lpServiceStatus);
    printf("ControlService (handle %p, dwControl 0x%x) called\n", hService, dwControl);

    printf("dwServiceType: 0x%x\n", lpServiceStatus->dwServiceType);
    printf("dwCurrentState: 0x%x\n", lpServiceStatus->dwCurrentState);
    printf("dwControlsAccepted: 0x%x\n", lpServiceStatus->dwControlsAccepted);
    printf("dwWin32ExitCode: 0x%x\n", lpServiceStatus->dwWin32ExitCode);
    printf("dwServiceSpecificExitCode: 0x%x\n", lpServiceStatus->dwServiceSpecificExitCode);
    printf("dwCheckPoint: 0x%x\n", lpServiceStatus->dwCheckPoint);
    printf("dwWaitHint: 0x%x\n", lpServiceStatus->dwWaitHint);
    return ret;
}

auto orig_DeleteService = (BOOL(WINAPI*)(SC_HANDLE))nullptr;
BOOL WINAPI custom_DeleteService(SC_HANDLE hService) {
    auto hook_ret = backend->DeleteServiceHook(hService);
    auto ret = hook_ret.has_value() ? hook_ret.value() :
        orig_DeleteService(hService);
    printf("DeleteService (handle %p) called\n", hService);
    return ret;
}

auto orig_CloseServiceHandle = (BOOL(WINAPI*)(SC_HANDLE))nullptr;
BOOL WINAPI custom_CloseServiceHandle(SC_HANDLE hService) {
    auto hook_ret = backend->CloseServiceHandleHook(hService);
    auto ret = hook_ret.has_value() ? hook_ret.value() :
        orig_CloseServiceHandle(hService);
    printf("CloseServiceHandle (handle %p) called\n", hService);
    return ret;
}

auto orig_OpenSCManagerW = (SC_HANDLE(WINAPI*)(LPCWSTR, LPCWSTR, DWORD))nullptr;
SC_HANDLE WINAPI custom_OpenSCManagerW(LPCWSTR lpMachineName, LPCWSTR lpDatabaseName, DWORD dwDesiredAccess) {
    auto hook_ret = backend->OpenSCManagerWHook(lpMachineName, lpDatabaseName, dwDesiredAccess);
    auto ret = hook_ret.has_value() ? hook_ret.value() :
        orig_OpenSCManagerW(lpMachineName, lpDatabaseName, dwDesiredAccess);
    printf("OpenSCManagerW (lpMachineName %ls, lpDatabaseName %ls, dwDesiredAccess 0x%x) called\n",
        lpMachineName != NULL ? lpMachineName : L"NULL", lpDatabaseName != NULL ? lpDatabaseName : L"NULL", dwDesiredAccess);
    return ret;
}

auto orig_CreateFileW = (HANDLE(WINAPI*)(LPCWSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES, DWORD, DWORD, HANDLE))nullptr;
HANDLE WINAPI custom_CreateFileW(
    LPCWSTR               lpFileName,
    DWORD                 dwDesiredAccess,
    DWORD                 dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD                 dwCreationDisposition,
    DWORD                 dwFlagsAndAttributes,
    HANDLE                hTemplateFile) {
    bool is_driver = !wcscmp(lpFileName, L"\\\\.\\mhyprot2");
    std::optional<HANDLE> hook_ret = {};
    if (is_driver)
        hook_ret = backend->OpenDriverPipe();

    auto ret = hook_ret.has_value() ? hook_ret.value() :
        orig_CreateFileW(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes,
            dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);

    if (is_driver) {
        printf("Driver pipe opened\n");
        driver_pipe = ret;
    }
    return ret;
}

void InstallHooks() {
    if (MH_Initialize() != MH_OK)
        Common::Panic("Failed to initialize MinHook");

    // needs to be done because just doing normal TerminateProcess points to a thunk in kernel32 (at least on Windows 11)
    auto kernelbase = GetModuleHandle(L"kernelbase.dll");
    if (!kernelbase)
        Common::Panic("Failed to get kernelbase.dll");
    auto TerminateProcess = GetProcAddress(kernelbase, "TerminateProcess");
    if (!TerminateProcess)
        Common::Panic("Failed to find TerminateProcess' address");

    MH_STATUS ret;
    MAKE_HOOK(DeviceIoControl);
    MAKE_HOOK(TerminateProcess);
    MAKE_HOOK(CreateServiceW);
    MAKE_HOOK(OpenServiceW);
    MAKE_HOOK(StartServiceW);
    MAKE_HOOK(QueryServiceStatus);
    MAKE_HOOK(ControlService);
    MAKE_HOOK(DeleteService);
    MAKE_HOOK(CloseServiceHandle);
    MAKE_HOOK(OpenSCManagerW);
    MAKE_HOOK(CreateFileW);
}
#pragma endregion Helpers, hooked functions, etc

// kill the actual mhyprot2 service
void KillService() {
    auto sc = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (sc == NULL) {
        if (GetLastError() == ERROR_ACCESS_DENIED) {
            printf("OpenSCManager failed because we aren't running as admin! continuing as usual...\n");
            return;
        }
        Common::Panic("OpenSCManager failed (%d)\n", GetLastError());
    }

    auto service = OpenService(sc, L"mhyprot2", DELETE);
    if (service == NULL) {
        auto gle = GetLastError();
        CloseServiceHandle(sc);
        if (gle == ERROR_SERVICE_DOES_NOT_EXIST) {
            printf("mhyprot2 is already deleted, going on as usual...\n");
            return;
        }
        Common::Panic("Couldn't open the mhyprot2 service! (GLE %x)", gle);
    }

    if (!DeleteService(service)) {
        auto gle = GetLastError();
        CloseServiceHandle(service);
        CloseServiceHandle(sc);
        if (gle == ERROR_SERVICE_MARKED_FOR_DELETE) {
            printf("mhyprot2 is already marked for deletion\n");
            return;
        }
        Common::Panic("Got a handle to mhyprot2, but couldn't delete it! (GLE %x)", gle);
    }

    CloseServiceHandle(service);
    CloseServiceHandle(sc);
    printf("Deleted the mhyprot2 service\n");
}

// additional evasive measure since interecepting ListProcessModule isn't enough
// probably the oldest trick in the book for people who actually write this kind of thing on a regular basis
// and i still had to skid it lol!!! https://github.com/StickOfficial/redHook/blob/master/unlinkpeb.h
void UnlinkFromPEB() {
    struct COOLER_PEB_LDR_DATA
    {
        UINT8 _PADDING_[12];
        LIST_ENTRY InLoadOrderModuleList;
        LIST_ENTRY InMemoryOrderModuleList;
        LIST_ENTRY InInitializationOrderModuleList;
    };
    struct COOLER_LDR_DATA_TABLE_ENTRY
    {
        LIST_ENTRY InLoadOrderLinks;
        LIST_ENTRY InMemoryOrderLinks;
        LIST_ENTRY InInitializationOrderLinks;
        VOID* DllBase;
    };

    auto peb = (PPEB)__readgsqword(0x60);
    auto cooler_ldr = (COOLER_PEB_LDR_DATA*)peb->Ldr;

    auto cur_entry = cooler_ldr->InLoadOrderModuleList.Flink;
    COOLER_LDR_DATA_TABLE_ENTRY* cur = nullptr;

    while (cur_entry != &cooler_ldr->InLoadOrderModuleList && cur_entry != nullptr) {
        cur = CONTAINING_RECORD(cur_entry, COOLER_LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
        if (cur->DllBase == &__ImageBase) {
            // no plans on relinking it
            cur->InLoadOrderLinks.Flink->Blink = cur->InLoadOrderLinks.Blink;
            cur->InLoadOrderLinks.Blink->Flink = cur->InLoadOrderLinks.Flink;

            cur->InInitializationOrderLinks.Flink->Blink = cur->InInitializationOrderLinks.Blink;
            cur->InInitializationOrderLinks.Blink->Flink = cur->InInitializationOrderLinks.Flink;

            cur->InMemoryOrderLinks.Flink->Blink = cur->InMemoryOrderLinks.Blink;
            cur->InMemoryOrderLinks.Blink->Flink = cur->InMemoryOrderLinks.Flink;

            printf(GRN "Unlinked from PEB!\n" WHT);

            break;
        }
        cur_entry = cur_entry->Flink;
    }
}

BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                     )
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH: {
        const wchar_t wine_key[] = L"Software\\Wine";
        HKEY hKey;
        bool on_wine = false;
        LONG result = RegOpenKeyEx(HKEY_CURRENT_USER, wine_key, 0, KEY_READ, &hKey);

        on_wine = result == ERROR_SUCCESS;

        if (!on_wine) {
          // Windows
          // make the console
          if (!AllocConsole())
              Common::Panic("Failed to create a console window");
        } else {
          RegCloseKey(hKey);
          puts("Running on Wine, skipping AllocConsole");
        }
        freopen("CONOUT$", "w", stdout);

        // get some fancy console colors!
        HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
        DWORD consoleMode;
        GetConsoleMode(hConsole, &consoleMode);
        consoleMode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
        SetConsoleMode(hConsole, consoleMode);

        printf(GRN "Mode: %s\n" WHT, Config::EmulatorMode ? "Emulator" : "Passthrough");
        backend = Config::EmulatorMode ? (Backend*)new EmulatorBackend() : (Backend*)new PassthroughBackend();

        KillService();
        InstallHooks();
        UnlinkFromPEB();
        break;
    }
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}


```

`mhynot2-rewritten/mhynot2-rewritten.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{7f520bdd-e9c5-4968-ac36-dcf599065f48}</ProjectGuid>
    <RootNamespace>mhynot2rewritten</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;MHYNOT2REWRITTEN_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;MHYNOT2REWRITTEN_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;MHYNOT2REWRITTEN_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <DisableSpecificWarnings>4996</DisableSpecificWarnings>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <AdditionalDependencies>shlwapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;MHYNOT2REWRITTEN_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Common.cpp" />
    <ClCompile Include="dllmain.cpp" />
    <ClCompile Include="EmulatorBackend.cpp" />
    <ClCompile Include="mt64.cpp" />
    <ClCompile Include="PacketCrypt.cpp" />
    <ClCompile Include="PassthroughBackend.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Backend.h" />
    <ClInclude Include="Common.h" />
    <ClInclude Include="Config.h" />
    <ClInclude Include="EmulatorBackend.h" />
    <ClInclude Include="Header.h" />
    <ClInclude Include="mhyprot2.h" />
    <ClInclude Include="mt64.h" />
    <ClInclude Include="PacketCrypt.h" />
    <ClInclude Include="PassthroughBackend.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`mhynot2-rewritten/mhynot2-rewritten.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="PacketCrypt.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="mt64.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Common.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="PassthroughBackend.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="EmulatorBackend.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Header.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Common.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="mhyprot2.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="PacketCrypt.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="mt64.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Backend.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="PassthroughBackend.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="EmulatorBackend.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Config.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`mhynot2-rewritten/mhyprot2.h`:

```h
#pragma once

#include <cstdint>

// https://github.com/kagurazakasanae/Mhyprot2DrvControl/blob/main/Driver/MhyProt2.cs
enum class MhyProt2Ioctl : unsigned {
    DrvInit = 0x80034000,
    MDL = 0x81004000,
    HeartBeat = 0x81014000,
    HeartBeat2 = 0x80024000, // 1.5-dev calls this "ProcessHips"?
    RWMemory = 0x81074000,
    EnumProcessList = 0x83014000,
    ListProcessModule = 0x81054000,
    FreeSharedMemory = 0x82004000,
    EnumDrivers = 0x82024000,
    KillProcess = 0x81034000,
    GetDriverStatus = 0x82114000,
    GetDriverVersion = 0x81084000,
    GetProcessHandles = 0x82034000 // only seems to get "Process" and "DebugHandle" handles
};

struct ListProcessModuleRequest {
    uint32_t pid;
    uint32_t max_count;
};
static_assert(sizeof(ListProcessModuleRequest) == 8, "ListProcessModuleRequest is the wrong size!!!");
struct ListProcessModuleResponse {
    void* base;
    uint32_t size;
    wchar_t name[128];
    wchar_t path[MAX_PATH];
    //uint32_t pad; // probably handled by the compiler anyways
};
static_assert(sizeof(ListProcessModuleResponse) == 0x318, "ListProcessModuleResponse is the wrong size!!!");

struct EnumProcessListRequest {
    uint32_t struct_size; // should always be 0x88?
    uint32_t max_count;
    char pad[0x88 - 0x8];
};
static_assert(sizeof(EnumProcessListRequest) == 0x88, "EnumProcessListRequest is the wrong size!!!");
struct EnumProcessListResponse {
    int pid;
    wchar_t path[MAX_PATH];
    void* eprocess; // yes, this is a kernel-mode address...
    uint64_t create_time;
    int is_64bit;
    char gap224[0x84]; // never seems to get filled in anywhere
};
static_assert(sizeof(EnumProcessListResponse) == 0x2A8, "EnumProcessListResponse is the wrong size!!!");

struct RWMemoryRequest {
    uint64_t mode; // 1 to copy memory from current process to target, 0 for the other way around
    uint32_t target_pid;
    //uint32_t pad; // probably handled by the compiler anyways
    void* to_addr;
    void* from_addr;
    uint32_t size;
};
static_assert(sizeof(RWMemoryRequest) == 0x28, "RWMemoryRequest is the wrong size!!!");
// just returns a u32 for response as a return code

struct MDLRequest {
    HANDLE process_event;
    HANDLE image_event;
    HANDLE thread_event;
    HANDLE heartbeat_event;
};
static_assert(sizeof(MDLRequest) == 0x20, "MDLRequest is the wrong size!!!");
struct MDLResponse {
    void* process_shared_mem;
    void* image_shared_mem;
    void* thread_shared_mem;
    void* dummy; // always 0
};
static_assert(sizeof(MDLResponse) == 0x20, "MDLResponse is the wrong size!!!");

struct GetProcessHandlesRequest {
    uint32_t unknown;
    uint32_t pid;
};
static_assert(sizeof(GetProcessHandlesRequest) == 0x8, "GetProcessHandlesRequest is the wrong size!!!");
struct GetProcessHandlesEntry {
    char gap0[4];
    int handle;
    void* obj_body;
    wchar_t path[259];
    char gap216[6];
    wchar_t type[259];
    //int pad; // probably handled by the compiler
};
static_assert(sizeof(GetProcessHandlesEntry) == 0x428, "GetProcessHandlesEntry is the wrong size!!!");
struct GetProcessHandlesResponse {
    uint32_t status;
    uint32_t count;
    GetProcessHandlesEntry* shared_mem;
    void* pmdl;       // kernel address
    void* kernel_mem; // kernel address
};
static_assert(sizeof(GetProcessHandlesResponse) == 0x20, "GetProcessHandlesResponse is the wrong size!!!");

struct EnumDriversRequest {
    uint32_t unk1;
    uint32_t unk2;
};
static_assert(sizeof(EnumDriversRequest) == 0x8, "EnumDriversRequest is the wrong size!!!");
struct EnumDriversEntry {
    char gap0[8];
    void* base;
    uint32_t size;
    char gap14[256];
    wchar_t path[259];
    char gap31A[262];
};
static_assert(sizeof(EnumDriversEntry) == 0x420, "EnumDriversEntry is the wrong size!!!");
struct EnumDriversResponse {
    uint32_t status;
    uint32_t count;
    EnumDriversEntry* shared_mem;
    void* pmdl;       // kernel address
    void* kernel_mem; // kernel address
};
static_assert(sizeof(EnumDriversResponse) == 0x20, "EnumDriversResponse is the wrong size!!!");

struct FreeSharedMemoryRequest {
    void* shared_mem;
    void* pmdl;       // kernel address
    void* kernel_mem; // kernel address
};
static_assert(sizeof(FreeSharedMemoryRequest) == 0x18, "FreeSharedMemoryRequest is the wrong size!!!");
// response is only a uint32_t

// could be done with macros or something
static const char* IoctlToString(unsigned ioctl) {
    switch (ioctl) {
    case (unsigned)MhyProt2Ioctl::DrvInit:
        return "DrvInit";
    case (unsigned)MhyProt2Ioctl::MDL:
        return "MDL";
    case (unsigned)MhyProt2Ioctl::HeartBeat:
        return "HeartBeat";
    case (unsigned)MhyProt2Ioctl::HeartBeat2:
        return "HeartBeat2";
    case (unsigned)MhyProt2Ioctl::RWMemory:
        return "RWMemory";
    case (unsigned)MhyProt2Ioctl::EnumProcessList:
        return "EnumProcessList";
    case (unsigned)MhyProt2Ioctl::ListProcessModule:
        return "ListProcessModule";
    case (unsigned)MhyProt2Ioctl::FreeSharedMemory:
        return "FreeSharedMemory";
    case (unsigned)MhyProt2Ioctl::EnumDrivers:
        return "EnumDrivers";
    case (unsigned)MhyProt2Ioctl::KillProcess:
        return "KillProcess";
    case (unsigned)MhyProt2Ioctl::GetDriverStatus:
        return "GetDriverStatus";
    case (unsigned)MhyProt2Ioctl::GetDriverVersion:
        return "GetDriverVersion";
    case (unsigned)MhyProt2Ioctl::GetProcessHandles:
        return "GetProcessHandles";
    default:
        return "???";
    }
}
```

`mhynot2-rewritten/mt64.cpp`:

```cpp
#include "mt64.h"

void mt64_init(mt64* mt64, uint64_t seed) {
    if (mt64)
    {
        *(uint64_t*)&mt64->mti = 0;
        mt64->mt = (uint64_t*)malloc(0x9C0);;
        if (mt64->mt == nullptr)
            Common::Panic("wtf, couldn't alloc mt64 data!");

        memset(mt64->mt, 0, 0x9C0);
        *mt64->mt = seed;
        mt64->initialized = 1;
        mt64->mti = 1;
        do
        {
            mt64->mt[mt64->mti] = mt64->mti
                + 0x5851F42D4C957F2D * (mt64->mt[mt64->mti - 1] ^ (mt64->mt[mt64->mti - 1] >> 62));
            ++mt64->mti;
        } while (mt64->mti < 312);
    }
}

uint64_t mt64_update(mt64* a1)
{
    int mti; // er8
    __int64 v2; // rbx
    __int64 v3; // r11
    unsigned __int64 v4; // rdx
    __int64 v5; // rdx

    static unsigned long long mag01[2] = { 0ULL, 0xB5026F5AA96619E9ULL };

    if (!a1 || !a1->initialized)
        return 0;
    mti = a1->mti;
    if (mti >= 312)
    {
        v2 = 0;
        v3 = 156;
        do
        {
            a1->mt[v2] = ((a1->mt[v2] ^ (unsigned __int64)((LODWORD(a1->mt[v2]) ^ LODWORD(a1->mt[v2 + 1])) & 0x7FFFFFFF)) >> 1) ^ a1->mt[v2 + 156] ^ mag01[a1->mt[v2 + 1] & 1];
            ++v2;
        } while (v2 < 156);
        do
        {
            a1->mt[v3] = ((a1->mt[v3] ^ (unsigned __int64)((LODWORD(a1->mt[v3]) ^ LODWORD(a1->mt[v3 + 1])) & 0x7FFFFFFF)) >> 1) ^ a1->mt[v3 - 156] ^ mag01[a1->mt[v3 + 1] & 1];
            ++v3;
        } while (v3 < 311);
        a1->mt[311] = ((a1->mt[311] ^ (unsigned __int64)((*(uint32_t*)a1->mt ^ *((uint32_t*)a1->mt + 622)) & 0x7FFFFFFF)) >> 1) ^ a1->mt[155] ^ mag01[*(uint8_t*)a1->mt & 1];
        a1->mti = 0;
        mti = 0;
    }
    v4 = a1->mt[mti];
    a1->mti = mti + 1;
    v5 = ((((v4 >> 29) & 0x555555555 ^ v4) & 0x38EB3FFFF6D3) << 17) ^ (v4 >> 29) & 0x555555555 ^ v4;
    return ((v5 & 0xFFFFFFFFFFFFBF77u) << 37) ^ v5 ^ ((((v5 & 0xFFFFFFFFFFFFBF77u) << 37) ^ v5) >> 43);
}
```

`mhynot2-rewritten/mt64.h`:

```h
#pragma once

// mihoyo's MT19937-64 implementation
#include <stdint.h>
#include <string.h>
#include <stdlib.h>

#include "Common.h"

struct mt64 {
	uint64_t* mt;
	int mti;
	int initialized;
};

void mt64_init(mt64* mt64, uint64_t seed);
uint64_t mt64_update(mt64* a1);
```