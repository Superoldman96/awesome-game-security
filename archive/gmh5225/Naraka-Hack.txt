Project Path: arc_gmh5225_Naraka-Hack_ng5ix9ez

Source Tree:

```txt
arc_gmh5225_Naraka-Hack_ng5ix9ez
├── Naraka
│   ├── Hack.cpp
│   ├── Hack.h
│   ├── Main.cpp
│   ├── Memory.h
│   ├── Naraka.vcxproj
│   ├── Naraka.vcxproj.filters
│   ├── Naraka.vcxproj.user
│   ├── Nvidia.cpp
│   ├── Nvidia.h
│   ├── Offsets.h
│   ├── SDK.cpp
│   ├── Sdk.h
│   ├── includes.h
│   └── x64
│       └── Release
│           ├── Naraka.Build.CppClean.log
│           ├── Naraka.exe.recipe
│           ├── Naraka.log
│           ├── Naraka.vcxproj.FileListAbsolute.txt
│           └── vcpkg.applocal.log
├── NarakaCheat.sln
├── Pictures
│   └── ScreenShot.jpg
└── README.md

```

`Naraka/Hack.cpp`:

```cpp
#include "Sdk.h"
#include "includes.h"
#include "Hack.h"
#include <vector>

MemoryToolsWrapper* memorytools;
Driver* pdriver;

std::vector<uint64_t> entitylist;


namespace config
{
	bool 人物方框 = true;
	bool 人物昵称 = true;
	bool 自动振刀 = true;
}

void InitializeAddress()
{
	HWND NarakaWindow = NULL;
	DWORD NarakaProcess = NULL;
	while (NarakaWindow == NULL || NarakaProcess == NULL)
	{
		NarakaWindow = FindWindowA("UnityWndClass", "Naraka");
		if (NarakaWindow)
			GetWindowThreadProcessId(NarakaWindow, &NarakaProcess);
		Sleep(2000);
	}
	pdriver = new Driver();
	pdriver->InitializeInterface();
	memorytools = new MemoryToolsWrapper(NarakaProcess, pdriver);
	ULONG64 UnityPlayer = 0;
	ULONG64 GameAssembly = 0;

	while (true)
	{
		UnityPlayer = pdriver->GetModule(NarakaProcess, L"UnityPlayer.dll");
		GameAssembly = pdriver->GetModule(NarakaProcess, L"GameAssembly.dll");
		if (UnityPlayer && GameAssembly)
			break;
	}
	sdk::initialize(UnityPlayer, GameAssembly);

	MessageBoxA(NULL, "Ok", "Done", MB_ICONINFORMATION);
}

void draw_menu(Nvidia* overlay)
{
	static bool open = true;
	if (GetAsyncKeyState(VK_INSERT) & 1) {
		open = !open;
	}
	if (open)
	{
		overlay->draw_text_yellow(10, 50, L"[INS 显示->隐藏]");

		if (config::人物方框)
		{
			overlay->draw_text_yellow(10, 70, L"玩家方框 -> F6");
		}
		if (!config::人物方框)
		{
			overlay->draw_text_white(10, 70, L"玩家方框 -> F6");
		}
		if (config::人物昵称)
		{
			overlay->draw_text_yellow(10, 90, L"玩家名字 -> F7");
		}
		if (!config::人物昵称)
		{
			overlay->draw_text_white(10, 90, L"玩家名字 -> F7");
		}

		if (config::自动振刀)
		{
			overlay->draw_text_yellow(10, 110, L"自动振刀 -> F8");
		}
		if (!config::自动振刀)
		{
			overlay->draw_text_white(10, 110, L"自动振刀 -> F8");
		}
		if (GetAsyncKeyState(VK_F6) & 1)
		{
			config::人物方框 = !config::人物方框;
		}
		if (GetAsyncKeyState(VK_F7) & 1)
		{
			config::人物昵称 = !config::人物昵称;
		}
		if (GetAsyncKeyState(VK_F8) & 1)
		{
			config::自动振刀 = !config::自动振刀;
		}
	}
}

void draw_esp(Nvidia* overlay)
{
	auto getboxrect = [](D2D1_RECT_F& BoxRect, Vector3& Bottom, Vector3& Top) {
		BoxRect.bottom = Bottom.y - Top.y;
		BoxRect.right = BoxRect.bottom / 2;
		BoxRect.left = Top.x - BoxRect.bottom / 4;
		BoxRect.top = Top.y;
	};
	for (auto entity : entitylist)
	{
		Vector3 entitypos = sdk::get_enitypos(entity);
		Vector3 headpos = entitypos;
		headpos.y += 1.8;
		if (sdk::get_view_matrix().ToScreenPos(entitypos, 1920, 1080)
			&&
			sdk::get_view_matrix().ToScreenPos(headpos, 1920, 1080)
			)
		{
			D2D1_RECT_F box;
			getboxrect(box, entitypos, headpos);

			if (config::人物方框)
			{
				overlay->draw_rect(box.left, box.top, box.right, box.bottom, 1.5);
			}
			if (config::人物昵称)
				overlay->draw_text_white(headpos.x, headpos.y + 3, sdk::get_name(entity).c_str());
		}

	}
}

void update()
{
	entitylist.clear();
	uint32_t playercount = sdk::get_playerCount();
	uintptr_t playeritems = sdk::get_playeritems();
	uintptr_t localaddr = sdk::get_local();
	uintptr_t localteamid = sdk::get_team(localaddr);
	for (size_t i = 0; i < playercount; i++)
	{
		uintptr_t entityaddr = sdk::get_entityaddr(playeritems, i);
		uintptr_t entityteamid = sdk::get_team(entityaddr);
		if (localaddr != entityaddr && entityteamid != localteamid)//排除队伍 和 自己
		{
			entitylist.push_back(entityaddr);
		}
	}
}

void entity_loop()
{
	if (!config::自动振刀) return;
	auto local = sdk::get_local();
	for (auto entity : entitylist)
	{
		if (sdk::is_weapon(sdk::get_weapon(entity)) && sdk::is_weapon(sdk::get_weapon(local)))//判断是否手持武器 
		{
			if (sdk::get_endurelevel(local) < 21)//判断当前状态 是否需要去振刀
			{
				Vector3 entitypos = sdk::get_enitypos(local);
				Vector3 localpos = sdk::get_enitypos(entity);
				auto distance = localpos.distTo(entitypos);
				float angle = fabsf(math::AngleDifference(sdk::get_enityangle(entity), math::VectorToRotationYaw(math::FindLookAtVector(entitypos, localpos))));//敌人面向 自己 的 角度

				if (distance > 5.9f)
					continue;

				//蓝霸体攻击?
				if (!sdk::is_attacking(entity))
					continue;

				if (angle > 68)//判断敌人是否面对自己 放出蓄力
					continue;

				//设置G键为振刀热键
				keybd_event('G', MapVirtualKey('G', MAPVK_VK_TO_VSC), 0, 0);
				Sleep(10);
				keybd_event('G', MapVirtualKey('G', MAPVK_VK_TO_VSC), 2, 0);
				Sleep(400);
			}
		}

	}

}

```

`Naraka/Hack.h`:

```h
void InitializeAddress();

void draw_menu(Nvidia* overlay);

void draw_esp(Nvidia* overlay);

void update();

void entity_loop();

```

`Naraka/Main.cpp`:

```cpp
#include "includes.h"
#include "Hack.h"


void _renderer(Nvidia* overlay)
{

	// Initialize the window
	if (!overlay->window_init())
		return;

	// D2D Failed to initialize?
	if (!overlay->init_d2d())
		return;

	while (true)
	{
		overlay->begin_scene();
		overlay->clear_scene();


		draw_menu(overlay);

		draw_esp(overlay);

		update();

		entity_loop();

		overlay->end_scene();
		Sleep(10);
	}
	overlay->d2d_shutdown();
	return;
}

int _init()
{

	std::thread renderer_thread
	(
		[]()
		{
			Nvidia overlay;
			_renderer(&overlay);
		}
	);

	renderer_thread.detach();

	while (true)
	{
		Sleep(10000);
		auto NarakaWindow = FindWindowA("UnityWndClass", "Naraka");
		if (!NarakaWindow)
		{
			ExitProcess(0);
		}
	}

}
int WINAPI WinMain(
	HINSTANCE hInstance,
	HINSTANCE hPrevInstance,
	LPSTR lpCmdLine,
	int nCmdShow
)
{
	InitializeAddress();

	return _init();
}
```

`Naraka/Memory.h`:

```h
#pragma once
#include <Windows.h>
#include <iostream>
#include <Psapi.h>
#include <TlHelp32.h>
enum DRV_CTLCODE
{
	CODE_WRITE_MEMORY_Physical = 1,
	CODE_READ_MEMORY_Physical,
	CODE_WRITE_MEMORY,
	CODE_READ_MEMORY,
	CODE_GET_MODULE,
	CODE_AllocUserMemory,
	CODE_FreeUserMemory,
	CODE_CreateUserThread,
	CODE_GET_VERSION
};

typedef struct _INFO_STRUCT_
{
	ULONG64 ProcessID;
	ULONG64 Address;
	ULONG64 buffer;
	ULONG64 Length;
	_INFO_STRUCT_(ULONG64 pid, ULONG64 addr, ULONG64 buf, ULONG64 len) :ProcessID(pid), Address(addr), buffer(buf), Length(len) {}
}INFO_STRUCT, * PINFO_STRUCT;

typedef struct _MODULE_INFO_ {
	ULONG64 StartBase;
	LPCWSTR Name;
}MODULE_INFO, * PMODULE_INFO;

class Driver
{
public:
	Driver() {}
	~Driver() {}

	bool InitializeInterface() {
		LoadLibraryA("user32.dll");
		LoadLibraryA("win32u.dll");
		auto base = GetModuleHandleA("win32u.dll");
		void* hooked_fn = GetProcAddress(base, "NtQueryCompositionSurfaceStatistics");
		syscall = reinterpret_cast<decltype(syscall)>(hooked_fn);
		return true;
	}

	void ReadRaw(uint64_t ProcessId, uint64_t Address, void* Buffer, size_t len) {
		INFO_STRUCT buffer = INFO_STRUCT(ProcessId, Address, (ULONG64)Buffer, len);
		syscall(&buffer, CODE_READ_MEMORY);
	}

	void WriteRaw(uint64_t ProcessId, uint64_t Address, void* Buffer, size_t len) {
		INFO_STRUCT buffer = INFO_STRUCT(ProcessId, Address, (ULONG64)Buffer, len);
		syscall(&buffer, CODE_WRITE_MEMORY);
	}

	template<typename T>
	T Read(uint64_t ProcessId, uint64_t Address) {
		T ret;
		INFO_STRUCT buffer = INFO_STRUCT(ProcessId, Address, (ULONG64)&ret, sizeof(T));
		syscall(&buffer, CODE_READ_MEMORY_Physical);
		return ret;
	}

	template<typename T>
	void Read(uint64_t ProcessId, uint64_t Address, T* Buffer) {
		INFO_STRUCT buffer = INFO_STRUCT(ProcessId, Address, (ULONG64)Buffer, sizeof(T));
		syscall(&buffer, CODE_READ_MEMORY_Physical);
	}

	template<typename T>
	VOID Write(uint64_t ProcessId, uint64_t Address, T& Value) {
		INFO_STRUCT buffer = INFO_STRUCT(ProcessId, Address, ULONG64(&Value), sizeof(T));
		syscall(&buffer, CODE_WRITE_MEMORY_Physical);
	}

	template<typename T>
	T Read_fast(uint64_t ProcessId, uint64_t Address) {
		T ret;
		INFO_STRUCT buffer = INFO_STRUCT(ProcessId, Address, (ULONG64)&ret, sizeof(T));
		syscall(&buffer, CODE_READ_MEMORY);
		return ret;
	}

	template<typename T>
	VOID Write_fast(uint64_t ProcessId, uint64_t Address, T Value) {
		INFO_STRUCT buffer = INFO_STRUCT(ProcessId, Address, ULONG64(&Value), sizeof(T));
		syscall(&buffer, CODE_WRITE_MEMORY);
	}

	ULONG64 GetModule(int pid, LPCWSTR Name)
	{
		MODULE_INFO module_info;
		module_info.Name = Name;
		INFO_STRUCT buffer = INFO_STRUCT(pid, NULL, (ULONG64)&module_info, NULL);
		syscall(&buffer, CODE_GET_MODULE);
		return (uintptr_t)module_info.StartBase;
	}

private:

	PVOID(NTAPI* syscall)(void*, INT64);
};


class MemoryToolsWrapper {
public:
	MemoryToolsWrapper(ULONG64 PId, Driver* DriverInstance) {
		driver = DriverInstance;
		ProcessId = PId;
	}
	template<typename T>
	inline auto read(uint64_t Address) -> T {
		return driver->Read_fast<T>(ProcessId, Address);
	}

	template<typename T>
	inline auto write(uint64_t Address, T Value) -> void {
		return driver->Write_fast<T>(ProcessId, Address, Value);
	}

	inline void write(uint64_t Address, void* Buffer, size_t size) {
		return driver->WriteRaw(ProcessId, Address, Buffer, size);
	}

	inline void read(uint64_t Address, void* Buffer, size_t size) {
		return driver->ReadRaw(ProcessId, Address, Buffer, size);
	}
private:
	Driver* driver;
	ULONG64 ProcessId;
};


```

`Naraka/Naraka.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{2287caf9-526e-4df0-b2de-6b8ef2b57b99}</ProjectGuid>
    <RootNamespace>Naraka</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Hack.cpp" />
    <ClCompile Include="Main.cpp" />
    <ClCompile Include="Nvidia.cpp" />
    <ClCompile Include="SDK.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Hack.h" />
    <ClInclude Include="includes.h" />
    <ClInclude Include="Memory.h" />
    <ClInclude Include="Offsets.h" />
    <ClInclude Include="Sdk.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Naraka/Naraka.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Main.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="Nvidia.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="Hack.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="SDK.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="includes.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="Memory.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="Sdk.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="Offsets.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="Hack.h">
      <Filter>头文件</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Naraka/Naraka.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`Naraka/Nvidia.cpp`:

```cpp
#include "Nvidia.h"
#include <comdef.h>
#include <corecrt.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#pragma warning(disable : 4996)

static HWND win;

/*
Window functions
*/

auto Nvidia::window_set_style() -> void {
    int i = 0;

    i = (int)GetWindowLong(win, -20);

    SetWindowLongPtr(win, -20, (LONG_PTR)(i | 0x20));
}

auto Nvidia::window_set_transparency() -> void {
    MARGINS margin;
    UINT opacity_flag, color_key_flag, color_key = 0;
    UINT opacity = 0;

    margin.cyBottomHeight = -1;
    margin.cxLeftWidth = -1;
    margin.cxRightWidth = -1;
    margin.cyTopHeight = -1;

    DwmExtendFrameIntoClientArea(win, &margin);

    opacity_flag = 0x02;
    color_key_flag = 0x01;
    color_key = 0x000000;
    opacity = 0xFF;

    SetLayeredWindowAttributes(win, color_key, opacity, opacity_flag);
}

auto Nvidia::window_set_top_most() -> void {
    SetWindowPos(win, HWND_TOPMOST, 0, 0, 0, 0, 0x0002 | 0x0001);
}

auto Nvidia::retrieve_window() -> HWND { return win; }

// Hijacking method down here.

auto Nvidia::window_init() -> BOOL {
    win = FindWindowW(L"CEF-OSC-WIDGET", L"NVIDIA GeForce Overlay");
    if (!win)
        return FALSE;

    Nvidia::window_set_style();
    Nvidia::window_set_transparency();
    Nvidia::window_set_top_most();

    ShowWindow(win, SW_SHOW);

    return TRUE;
}

/*
Overlay functions
*/

ID2D1Factory* d2d_factory;
ID2D1HwndRenderTarget* tar;
IDWriteFactory* write_factory;
ID2D1SolidColorBrush* brush;
ID2D1SolidColorBrush* blue_brush;
ID2D1SolidColorBrush* purple_brush;
ID2D1SolidColorBrush* red_brush;
ID2D1SolidColorBrush* green_brush;
ID2D1SolidColorBrush* yellow_brush;
IDWriteTextFormat* format;

auto Nvidia::d2d_shutdown() -> void {
    // Release
    tar->Release();
    write_factory->Release();
    brush->Release();
    red_brush->Release();
    blue_brush->Release();
    green_brush->Release();
    yellow_brush->Release();
    purple_brush->Release();
    d2d_factory->Release();
}

auto Nvidia::init_d2d() -> BOOL {
    HRESULT ret;
    RECT rc;

    // Initialize D2D here
    ret = D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, &d2d_factory);
    if (FAILED(ret))
        return FALSE;

    ret =
        DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory),
            (IUnknown**)(&write_factory));
    if (FAILED(ret))
        return FALSE;

    write_factory->CreateTextFormat(
        L"Arial", NULL, DWRITE_FONT_WEIGHT_REGULAR, DWRITE_FONT_STYLE_NORMAL,
        DWRITE_FONT_STRETCH_NORMAL, 14.0, L"zh-cn", &format);

    GetClientRect(Nvidia::retrieve_window(), &rc);

    ret = d2d_factory->CreateHwndRenderTarget(
        D2D1::RenderTargetProperties(
            D2D1_RENDER_TARGET_TYPE_DEFAULT,
            D2D1::PixelFormat(DXGI_FORMAT_UNKNOWN,
                D2D1_ALPHA_MODE_PREMULTIPLIED)),
        D2D1::HwndRenderTargetProperties(
            Nvidia::retrieve_window(),
            D2D1::SizeU(rc.right - rc.left, rc.bottom - rc.top)),
        &tar);
    if (FAILED(ret))
        return FALSE;

    tar->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &brush);
    tar->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Red), &red_brush);
    tar->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::LimeGreen), &green_brush);
    tar->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Blue), &blue_brush);
    tar->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Yellow), &yellow_brush);
    tar->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Purple), &purple_brush);

    return TRUE;
}

auto Nvidia::begin_scene() -> void { tar->BeginDraw(); }

auto Nvidia::end_scene() -> void { tar->EndDraw(); }

auto Nvidia::clear_scene() -> void { tar->Clear(); }

auto Nvidia::draw_text_white(int x, int y, const wchar_t* str, ...) -> void {
    int len = 0;
    wchar_t buf[256];

    // if (!draw) // no need for it.
    //	 return;

    va_list arg_list;
    va_start(arg_list, str);
    wvsprintf(buf, str, arg_list);
    va_end(arg_list);
    len = wcslen(buf);

    tar->DrawText(buf, len, format, D2D1::RectF(x, y, 1920, 1080), brush,
        D2D1_DRAW_TEXT_OPTIONS_NONE, DWRITE_MEASURING_MODE_NATURAL);
}

auto Nvidia::draw_text_purple(int x, int y, const wchar_t* str, ...) -> void {
    int len = 0;
    wchar_t buf[256];

    // if (!draw) // no need for it.
    //	 return;

    va_list arg_list;
    va_start(arg_list, str);
    wvsprintf(buf, str, arg_list);
    va_end(arg_list);
    len = wcslen(buf);

    tar->DrawText(buf, len, format, D2D1::RectF(x, y, 1920, 1080), purple_brush,
        D2D1_DRAW_TEXT_OPTIONS_NONE, DWRITE_MEASURING_MODE_NATURAL);
}

auto Nvidia::draw_text_blue(int x, int y, const wchar_t* str, ...) -> void {
    int len = 0;
    wchar_t buf[256];

    // if (!draw) // no need for it.
    //	 return;

    va_list arg_list;
    va_start(arg_list, str);
    wvsprintf(buf, str, arg_list);
    va_end(arg_list);
    len = wcslen(buf);

    tar->DrawText(buf, len, format, D2D1::RectF(x, y, 1920, 1080), blue_brush,
        D2D1_DRAW_TEXT_OPTIONS_NONE, DWRITE_MEASURING_MODE_NATURAL);
}


auto Nvidia::draw_text_red(int x, int y, const wchar_t* str, ...) -> void {
    int len = 0;
    wchar_t buf[256];

    // if (!draw) // no need for it.
    //	 return;

    va_list arg_list;
    va_start(arg_list, str);
    wvsprintf(buf, str, arg_list);
    va_end(arg_list);
    len = wcslen(buf);

    tar->DrawText(buf, len, format, D2D1::RectF(x, y, 1920, 1080), red_brush,
        D2D1_DRAW_TEXT_OPTIONS_NONE, DWRITE_MEASURING_MODE_NATURAL);
}

auto Nvidia::draw_text_green(int x, int y, const wchar_t* str, ...) -> void {
    int len = 0;
    wchar_t buf[256];

    // if (!draw) // no need for it.
    //	 return;

    va_list arg_list;
    va_start(arg_list, str);
    wvsprintf(buf, str, arg_list);
    va_end(arg_list);
    len = wcslen(buf);

    tar->DrawText(buf, len, format, D2D1::RectF(x, y, 1920, 1080), green_brush,
        D2D1_DRAW_TEXT_OPTIONS_NONE, DWRITE_MEASURING_MODE_NATURAL);
}

auto Nvidia::draw_text_yellow(int x, int y, const wchar_t* str, ...) -> void {
    int len = 0;
    wchar_t buf[256];

    // if (!draw) // no need for it.
    //	 return;

    va_list arg_list;
    va_start(arg_list, str);
    wvsprintf(buf, str, arg_list);
    va_end(arg_list);
    len = wcslen(buf);

    tar->DrawText(buf, len, format, D2D1::RectF(x, y, 1920, 1080), yellow_brush,
        D2D1_DRAW_TEXT_OPTIONS_NONE, DWRITE_MEASURING_MODE_NATURAL);
}

auto Nvidia::draw_line(int x, int y, int x2, int y2, float thickness, ...)-> void {
    tar->DrawLine(D2D1::Point2F(x, y), D2D1::Point2F(x2, y2), red_brush, thickness);
}

auto Nvidia::draw_rect(float left, float top, float right, float bottom, float thickness) -> void{
    tar->DrawRectangle(D2D1::RectF(left,top, left + right, top + bottom), red_brush,thickness);
}
 
auto Nvidia::clear_screen() -> void {
    Nvidia::begin_scene();
    Nvidia::clear_scene();
    Nvidia::end_scene();
}
```

`Naraka/Nvidia.h`:

```h
#pragma once
#include <windows.h>
#include <stdio.h>
#include <dwmapi.h> 
#include <d2d1.h>
#include <dwrite.h>
#pragma comment(lib, "Dwrite")

#pragma comment(lib, "Dwmapi.lib") 
#pragma comment(lib, "d2d1.lib")

#define _CRT_SECURE_NO_DEPRECATE
#define _CRT_SECURE_NO_WARNINGS

class Nvidia
{
public:
	auto window_set_style()-> void;
	auto window_set_transparency()-> void;
	auto window_set_top_most()-> void;
	auto retrieve_window()->HWND;
	auto window_init()->BOOL;
	auto d2d_shutdown()-> void;
	auto init_d2d()->BOOL;
	auto begin_scene()-> void;
	auto end_scene()-> void;
	auto clear_scene()-> void;
	auto draw_text_white(int x, int y, const wchar_t* str, ...)-> void;
	auto draw_text_purple(int x, int y, const wchar_t* str, ...) -> void;
	auto draw_text_blue(int x, int y, const wchar_t* str, ...) -> void;
	auto draw_text_red(int x, int y, const wchar_t* str, ...)-> void;
	auto draw_text_green(int x, int y, const wchar_t* str, ...) -> void;
	auto draw_text_yellow(int x, int y, const wchar_t* str, ...) -> void;
	auto draw_line(int x, int y, int x2, int y2, float thickness, ...) -> void;
	auto draw_rect(float left, float top, float right, float bottom, float thickness) ->void;
	auto clear_screen()-> void;
};
```

`Naraka/Offsets.h`:

```h
#pragma once
#include <stdint.h>

constexpr uint64_t CharacterManager = 0x6D7CB80;
constexpr uint64_t GameEntity = 0x6DC9300;
constexpr uint64_t UserData = 0x6D7CF58;

constexpr auto Manager_offset = 0xB8;
constexpr auto ManagerBase_offset = 0x18;
constexpr auto LocalPlayer_offset1 = 0x8;
constexpr auto LocalPlayer_offset2 = 0x18;
constexpr auto AcotrManager_offset = 0x60;
constexpr auto PlayerInfo_offset = 0x250;//propertyData

constexpr auto ObjTeam_offset = 0xE0;
constexpr auto 人物昵称_offset = 0x140;
constexpr auto ObjBot_offset = 0xF8;
constexpr auto ObjAlive_offset = 0x39;//visible
constexpr auto ObjWeapon_offse = 0xF0;
constexpr auto actorkit_offset = 0xB8;

```

`Naraka/SDK.cpp`:

```cpp
#include"sdk.h"

extern MemoryToolsWrapper* memorytools;

namespace memory
{
	template<typename T>
	T read(uintptr_t dst)
	{
		return memorytools->read<T>(dst);
	}
	template<typename T>
	void write(uintptr_t dst, T src)
	{
		return memorytools->write<T>(dst, src);

	}
	void read(uintptr_t dst, void* buffer, size_t len)
	{
		return memorytools->read(dst, buffer, len);
	}
}

namespace sdk
{

	uintptr_t UnityPlayer = 0;
	uintptr_t GameAssembly = 0;
	void initialize(uintptr_t _UnityPlayer, uintptr_t _GameAssembly)
	{
		UnityPlayer = _UnityPlayer;
		GameAssembly = _GameAssembly;
	}
	uint64_t get_uworlds()
	{
		return memory::read<uint64_t>(GameAssembly + CharacterManager);
	}

	uint64_t get_manager()
	{
		return memory::read<uint64_t>(get_uworlds() + Manager_offset);
	}

	uint64_t get_manager_base()
	{
		return memory::read<uint64_t>(get_manager() + ManagerBase_offset);
	}

	uint64_t get_local()
	{
		return memory::read<uint64_t>(memory::read<uint64_t>(get_manager() + LocalPlayer_offset1) + LocalPlayer_offset2);
	}

	uint64_t get_actor_manager()
	{
		return memory::read<uint64_t>(get_manager_base() + AcotrManager_offset);
	}

	uint64_t get_palyer_info(uint64_t obj)
	{
		return memory::read<uint64_t>(obj + PlayerInfo_offset);
	}

	uint32_t get_team(uint64_t obj)
	{
		return memory::read<uint32_t>(get_palyer_info(obj) + ObjTeam_offset);
	}

	//返回的是武器id
	uint32_t get_weapon(uint64_t obj)
	{
		return memory::read<uint32_t>(get_palyer_info(obj) + ObjWeapon_offse);
	}

	bool is_bot_player(uint64_t obj)
	{
		return (memory::read<uint32_t>(get_palyer_info(obj) + ObjBot_offset) > 0);
	}

	std::wstring get_name(uint64_t obj)
	{

		wchar_t name[64]{ 0 };
		memory::read(memory::read<uint64_t>(get_palyer_info(obj) + 人物昵称_offset) + 0x14, name, sizeof(name));
		return std::wstring(name);
	}
	uint32_t get_alive(uint64_t obj)
	{
		return (memory::read<uint32_t>(get_palyer_info(obj) + ObjAlive_offset) == 1);
	}

	Matrix4x4 get_view_matrix()
	{
		auto _ptr = get_manager() + 8;
		_ptr = memory::read<uint64_t>(_ptr) + 0x40;
		_ptr = memory::read<uint64_t>(_ptr) + 0x38;
		_ptr = memory::read<uint64_t>(_ptr) + 0x10;
		_ptr = memory::read<uint64_t>(_ptr) + 0xDC;
		return memory::read<Matrix4x4>(_ptr);
	}


	uint32_t get_playerCount() {//get_manager_base
		return memory::read<uint32_t>(get_manager_base() + 0x18);
	}

	uintptr_t get_playeritems() {

		return memory::read<uintptr_t>(get_manager_base() + 0x10);
	}
	Vector3 get_enitypos(uint64_t obj) {
		uintptr_t v1 = memory::read<uint64_t>(obj + 0x60);//<transform>k__BackingField
		uintptr_t v2 = memory::read<uint64_t>(v1 + 0x10);
		uintptr_t v3 = memory::read<uint64_t>(v2 + 0x30);
		uintptr_t v4 = memory::read<uint64_t>(v3 + 0x30);
		uintptr_t v5 = memory::read<uint64_t>(v4 + 0x8);
		uintptr_t v6 = memory::read<uint64_t>(v5 + 0x38);
		uintptr_t v7 = v6 + 0x90;
		return memory::read<Vector3>(v7);
	}

	//霸体类型 20蓝霸体 21紫霸体 5站着不动 ,30 31 振刀处决状态 
	uint32_t get_endurelevel(uint64_t obj) {
		uintptr_t v1 = memory::read<uint64_t>(obj + 0xB8);//actorkit
		uintptr_t v2 = memory::read<uint64_t>(v1 + 0xC0);//actorKitHitSimulateData
		return memory::read<uint32_t>(v2 + 0x90);
	}

	//2为出刀
	uint32_t get_reactiontype(uint64_t obj) {
		uintptr_t v1 = memory::read<uint64_t>(obj + 0xB8);//actorkit
		uintptr_t v2 = memory::read<uint64_t>(v1 + 0xC0);//actorKitHitSimulateData
		return memory::read<uint32_t>(v2 + 0x48);//ReactionType
	}

	//默认10 出刀12
	uint32_t get_rangereactiontype(uint64_t obj) {
		uintptr_t v1 = memory::read<uint64_t>(obj + 0xB8);//actorkit
		uintptr_t v2 = memory::read<uint64_t>(v1 + 0xC0);//actorKitHitSimulateData
		return memory::read<uint32_t>(v2 + 0x4C);//RangeReactionType
	}

	//是否振刀?  2为震 默认0
	uint32_t get_reaction_extra_check_combo_type(uint64_t obj) {
		uintptr_t v1 = memory::read<uint64_t>(obj + 0xB8);//actorkit
		uintptr_t v2 = memory::read<uint64_t>(v1 + 0xC0);//actorKitHitSimulateData
		return memory::read<uint32_t>(v2 + 0x74);//ReactionExtraCheckComboType
	}

	uintptr_t get_entityaddr(uintptr_t items_, int count) {
		uintptr_t v1 = items_ + 0x20;
		return memory::read<uintptr_t>(v1 + count * 8);
	}

	//大于0.45完成蓄力
	float get_enduretime(uint64_t obj) {
		uintptr_t v1 = memory::read<uint64_t>(obj + 0xB8);//actorkit
		uintptr_t v2 = memory::read<uint64_t>(v1 + 0x38);//<AniParams>k__BackingField
		uintptr_t v3 = memory::read<uint64_t>(v2 + 0x18);
		uintptr_t v4 = memory::read<uint64_t>(v3 + 0x20);
		uintptr_t v5 = memory::read<uint64_t>(v4 + 0x10);
		return memory::read<float>(v5 + 0x54);//ReactionExtraCheckComboType
	}

	//取动画名称
	std::wstring get_animname(uint64_t obj) {
		wchar_t name[64] { 0 };
		uintptr_t v1 = memory::read<uint64_t>(obj + actorkit_offset);//actorkit
		uintptr_t v2 = memory::read<uint64_t>(v1 + 0x1e8);//<AnimPlayableAgent>k__BackingField
		uintptr_t v3 = memory::read<uint64_t>(v2 + 0x68);//playbleTrackDriver
		uintptr_t v4 = memory::read<uint64_t>(v3 + 0x28);//om
		uintptr_t v5 = memory::read<uint64_t>(v4 + 0x30);//EventTracksForLayer
		uintptr_t v6 = memory::read<uint64_t>(v5 + 0x20);//Item[0]
		uintptr_t v7 = memory::read<uint64_t>(v6 + 0x10);//animClipName
		memory::read(v7 + 0x14, name, sizeof(name));
		//printf("Name = %ws\n", name);
		return std::wstring(name);
	}

	//1长剑2太刀3长枪4阔刀5匕首6双截棍7双刀
	uint32_t get_weapon_type(uint32_t weapon_id)
	{
		switch (weapon_id)
		{
		case 3200001:
			return 1;
		case 3200011:
			return 1;
		case 3200021:
			return 1;
		case 3200031:
			return 1;
		case 3200300:
			return 2;
		case 3200310:
			return 2;
		case 3200320:
			return 2;
		case 3200330:
			return 2;
		case 3200200:
			return 3;
		case 3200210:
			return 3;
		case 3200220:
			return 3;
		case 3200230:
			return 3;
		case 3200400:
			return 4;
		case 3200410:
			return 4;
		case 3200420:
			return 4;
		case 3200430:
			return 4;
		case 3200101:
			return 5;
		case 3200111:
			return 5;
		case 3200121:
			return 5;
		case 3200131:
			return 5;
		case 3201540:
			return 6;
		case 3201530:
			return 6;
		case 3201520:
			return 6;
		case 3201510:
			return 6;
		case 3201610://双刀
			return 7;
		case 3201620://双刀
			return 7;
		case 3201630://双刀
			return 7;
		case 3201640://双刀
			return 7;
		default:
			break;
		}
		return 0;
	}

	bool is_weapon(uint32_t weaponid)
	{
		if (weaponid == 3209901)//拳头
		{
			return false;
		}
		return true;
	}

	bool is_attacking(uintptr_t obj)
	{
		if (sdk::get_endurelevel(obj) == 20 && sdk::get_rangereactiontype(obj) == 12)
		{
			return true;
		}
		return false;
	}

	uint64_t get_root_component(uint64_t obj) {
		uintptr_t v1 = memory::read<uint64_t>(obj + 0x60);//<transform>k__BackingField
		uintptr_t v2 = memory::read<uint64_t>(v1 + 0x10);
		uintptr_t v3 = memory::read<uint64_t>(v2 + 0x30);
		uintptr_t v4 = memory::read<uint64_t>(v3 + 0x30);
		uintptr_t v5 = memory::read<uint64_t>(v4 + 0x8);
		uintptr_t v6 = memory::read<uint64_t>(v5 + 0x38);

		return v6;
	}

	float get_enityangle(uint64_t obj) {
		Vector4 quat;
		Vector3 rot;
		uintptr_t v7 = get_root_component(obj) + 0xA0;
		quat = memory::read<Vector4>(v7);
		quat.x = 0;
		quat.z = 0;
		rot = math::QuatToRot(quat);
		rot.x = rot.x * -1.f;
		if (fabsf(quat.y) >= 0.7f)
		{
			rot.x = 180.f - rot.x;
		}
		return math::ConverseAngle(rot.x);
	}
}

```

`Naraka/Sdk.h`:

```h
#pragma once
#include <string>
#include <math.h>
#include "offsets.h"
#include "Memory.h"

struct Vector3
{
	float x, y, z;

	inline Vector3(float _x, float _y, float _z) :x(_x), y(_y), z(_z) {}

	inline Vector3() {}

	Vector3 operator+(const Vector3& pos)
	{
		Vector3 ret;
		ret.x = x + pos.x;
		ret.y = y + pos.y;
		ret.z = z + pos.z;
		return ret;
	}

	Vector3 operator-(const Vector3& pos)
	{
		Vector3 ret;
		ret.x = x - pos.x;
		ret.y = y - pos.y;
		ret.z = z - pos.z;
		return ret;
	}

	bool operator==(const Vector3& pos)
	{
		if (pos.x == x && pos.y == y && pos.z == z)
			return true;
		return false;
	}

	constexpr auto notNull() const noexcept
	{
		return x || y || z;
	}

	inline Vector3& normalize() noexcept
	{
		x = isfinite(x) ? remainder(x, 360.0f) : 0.0f;
		y = isfinite(y) ? remainder(y, 360.0f) : 0.0f;
		z = 0.0f;
		return *this;
	}

	inline float length() const noexcept
	{
		return sqrt(x * x + y * y + z * z);
	}

	inline float length2D() const noexcept
	{
		return sqrt(x * x + y * y);
	}

	auto distTo(const Vector3& v) const noexcept
	{
		return sqrt((v.x - x) * (v.x - x) + (v.y - y) * (v.y - y) + (v.z - z) * (v.z - z));
	}

};
struct Vector4
{
public:
	Vector4() : x(0.f), y(0.f), z(0.f), w(0.f) {}

	Vector4(float _x, float _y, float _z, float _w) : x(_x), y(_y), z(_z), w(_w) {}

	float x;
	float y;
	float z;
	float w;
};
struct Matrix4x4 {

	float matrix[4][4];

	float* operator[](int index)
	{
		return matrix[index];
	}

	bool ToScreenPos(Vector3& InOutPos, float width, float height)
	{
		Vector3 result;
		float _x = matrix[0][0] * InOutPos.x + matrix[1][0] * InOutPos.y + matrix[2][0] * InOutPos.z + matrix[3][0];
		float _y = matrix[0][1] * InOutPos.x + matrix[1][1] * InOutPos.y + matrix[2][1] * InOutPos.z + matrix[3][1];
		float _w = matrix[0][3] * InOutPos.x + matrix[1][3] * InOutPos.y + matrix[2][3] * InOutPos.z + matrix[3][3];
		if (_w < 0.01f)
			return false;
		float inv_w = 1.f / _w;
		_x *= inv_w;
		_y *= inv_w;
		result.x = width * .5f;
		result.y = height * .5f;
		result.x += 0.5f * _x * width + 0.5f;
		result.y -= 0.5f * _y * height + 0.5f;
		result.z = _w;

		if (result.y  < 0.f || result.x  < 0.f || result.x > width || result.y > height)
			return false;

		InOutPos = result;
		return true;
	}

};
namespace math {

	inline Vector3 QuatToRot(Vector4 Quaternion) {
		Vector3 rot;
		float qzsqr = 0;
		float T0 = 0;
		float T1 = 0;
		float t2 = 0;
		float t3 = 0;
		float t4 = 0;

		qzsqr = Quaternion.z * Quaternion.z;
		T0 = -2.f * (qzsqr + Quaternion.w * Quaternion.w) + 1.f;
		T1 = 2.f * (Quaternion.y * Quaternion.z + Quaternion.x * Quaternion.w);
		t2 = -2.f * (Quaternion.y * Quaternion.w - Quaternion.x * Quaternion.z);
		t3 = 2.f * (Quaternion.z * Quaternion.w + Quaternion.x * Quaternion.y);
		t4 = -2.f * (Quaternion.y * Quaternion.y + qzsqr) + 1.f;

		t2 = t2 > 1.f ? 1.f : t2;
		t2 = t2 < -1.f ? -1.f : t2;

		float RADPI = (float)(180 / 3.1415926f);
		float Yaw = (float)atan2f(T1, T0) * RADPI;
		float Roll = (float)atan2f(t3, t4) * RADPI;
		float Pitch = (float)asin(t2) * RADPI;

		return Vector3(Pitch, Yaw, Roll);
	}

	inline Vector3 FindLookAtVector(Vector3 pos1, Vector3 pos2) {
		Vector3 v1 = Vector3(pos2.x, pos2.z, pos2.y) - Vector3(pos1.x, pos1.z, pos1.y);//他妈的 排序是 xzy
		float distance = pos1.distTo(pos2);
		return Vector3(v1.x / distance, v1.y / distance, v1.z / distance);
	}

	inline float VectorToRotationYaw(Vector3 pos) {
		float RADPI = (float)(180 / 3.1415926f);
		float Yaw = (float)atan2f(pos.x, pos.y) * RADPI;
		if (Yaw < 0)
		{
			Yaw += 180;
		}
		if (pos.x < 0)
		{
			Yaw += 180;
		}
		return Yaw;
	}
	inline float ConverseAngle(float x) {
		return (float)(((int)(x + 180.f) % 360 + 180) % 360);
	}

	inline float AngleDifference(float a, float b) {
		int phi = ((int)fabsf((b - a)) % 360);
		int sign = 1;
		if (((a - b) >= 0 && (a - b) <= 180) || ((a - b) <= -180 && (a - b) >= -360))
		{
			sign = -1;
		}

		return ((phi > 180 ? 360 - phi : phi) * sign);
	}
}

enum WeaponId
{
	长剑 = 1,
	太刀 = 2,
	长枪 = 3,
	阔刀 = 4,
	匕首 = 5,
	双截棍 = 6,
	双刀 = 7,
};
namespace sdk
{
	void initialize(uintptr_t _UnityPlayer, uintptr_t _GameAssembly);
	uint64_t get_uworlds();
	uint64_t get_manager();
	uint64_t get_manager_base();
	uint64_t get_local();
	uint64_t get_actor_manager();
	uint64_t get_palyer_info(uint64_t obj);
	uint32_t get_team(uint64_t obj);
	uint32_t get_weapon(uint64_t obj);
	std::wstring get_name(uint64_t obj);
	Matrix4x4 get_view_matrix();
	uint32_t get_endurelevel(uint64_t obj);
	uint32_t get_reactiontype(uint64_t obj);
	uint32_t get_rangereactiontype(uint64_t obj);
	uint32_t get_playerCount();
	uintptr_t get_playeritems();
	Vector3 get_enitypos(uint64_t obj);
	uint32_t get_reaction_extra_check_combo_type(uint64_t obj);
	uintptr_t get_entityaddr(uintptr_t items_, int count);
	float get_enduretime(uint64_t obj);
	std::wstring get_animname(uint64_t obj);
	uint32_t get_weapon_type(uint32_t weapon_id);
	bool is_weapon(uint32_t weaponid);
	bool is_attacking(uintptr_t obj);
	uint64_t get_root_component(uint64_t obj);
	float get_enityangle(uint64_t obj);
	bool is_bot_player(uint64_t obj);
}
```

`Naraka/includes.h`:

```h
#pragma once
#include <Windows.h>
#include <thread>
#include "Nvidia.h"

namespace mouse {
	inline void right(bool down) {

		INPUT Input = { 0 };

		if (down)
		{
			// RIGHT down
			Input.type = INPUT_MOUSE;
			Input.mi.dwFlags = MOUSEEVENTF_RIGHTDOWN;
			SendInput(1, &Input, sizeof(INPUT));
		}
		else {
			// RIGHT up
			ZeroMemory(&Input, sizeof(INPUT));
			Input.type = INPUT_MOUSE;
			Input.mi.dwFlags = MOUSEEVENTF_RIGHTUP;
			SendInput(1, &Input, sizeof(INPUT));
		}
	}
	inline void left(bool down) {
		INPUT Input = { 0 };

		if (down)
		{
			// left down
			Input.type = INPUT_MOUSE;
			Input.mi.dwFlags = MOUSEEVENTF_LEFTDOWN;
			SendInput(1, &Input, sizeof(INPUT));
		}
		else {
			// left up
			ZeroMemory(&Input, sizeof(INPUT));
			Input.type = INPUT_MOUSE;
			Input.mi.dwFlags = MOUSEEVENTF_LEFTUP;
			SendInput(1, &Input, sizeof(INPUT));
		}
	}
}

```

`Naraka/x64/Release/Naraka.Build.CppClean.log`:

```log
c:\users\administrator\source\repos\narakacheat\naraka\x64\release\vc142.pdb
c:\users\administrator\source\repos\narakacheat\naraka\x64\release\sdk.obj
c:\users\administrator\source\repos\narakacheat\naraka\x64\release\nvidia.obj
c:\users\administrator\source\repos\narakacheat\naraka\x64\release\main.obj
c:\users\administrator\source\repos\narakacheat\naraka\x64\release\hack.obj
d:\mydatas\databackup\source\repos\narakacheat\naraka\x64\release\vc143.pdb
d:\mydatas\databackup\source\repos\narakacheat\naraka\x64\release\sdk.obj
d:\mydatas\databackup\source\repos\narakacheat\naraka\x64\release\nvidia.obj
d:\mydatas\databackup\source\repos\narakacheat\naraka\x64\release\main.obj
d:\mydatas\databackup\source\repos\narakacheat\naraka\x64\release\hack.obj
c:\users\administrator\source\repos\narakacheat\x64\release\naraka.exe
c:\users\administrator\source\repos\narakacheat\naraka\x64\release\naraka.ipdb
c:\users\administrator\source\repos\narakacheat\naraka\x64\release\naraka.iobj
c:\users\administrator\source\repos\narakacheat\x64\release\naraka.pdb
d:\mydatas\databackup\source\repos\narakacheat\x64\release\naraka.exe
d:\mydatas\databackup\source\repos\narakacheat\naraka\x64\release\naraka.ipdb
d:\mydatas\databackup\source\repos\narakacheat\x64\release\naraka.pdb
d:\mydatas\databackup\source\repos\narakacheat\naraka\x64\release\naraka.iobj
d:\mydatas\databackup\source\repos\narakacheat\naraka\x64\release\vc142.pdb
d:\mydatas\databackup\source\repos\narakacheat\naraka\x64\release\naraka.tlog\cl.command.1.tlog
d:\mydatas\databackup\source\repos\narakacheat\naraka\x64\release\naraka.tlog\cl.read.1.tlog
d:\mydatas\databackup\source\repos\narakacheat\naraka\x64\release\naraka.tlog\cl.write.1.tlog
d:\mydatas\databackup\source\repos\narakacheat\naraka\x64\release\naraka.tlog\link.command.1.tlog
d:\mydatas\databackup\source\repos\narakacheat\naraka\x64\release\naraka.tlog\link.read.1.tlog
d:\mydatas\databackup\source\repos\narakacheat\naraka\x64\release\naraka.tlog\link.write.1.tlog

```

`Naraka/x64/Release/Naraka.exe.recipe`:

```recipe
<?xml version="1.0" encoding="utf-8"?>
<Project>
  <ProjectOutputs>
    <ProjectOutput>
      <FullPath>D:\MyDatas\DataBackup\source\repos\NarakaCheat\x64\Release\Naraka.exe</FullPath>
    </ProjectOutput>
  </ProjectOutputs>
  <ContentFiles />
  <SatelliteDlls />
  <NonRecipeFileRefs />
</Project>
```

`NarakaCheat.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.3.32929.385
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Naraka", "Naraka\Naraka.vcxproj", "{2287CAF9-526E-4DF0-B2DE-6B8EF2B57B99}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{2287CAF9-526E-4DF0-B2DE-6B8EF2B57B99}.Debug|x64.ActiveCfg = Debug|x64
		{2287CAF9-526E-4DF0-B2DE-6B8EF2B57B99}.Debug|x64.Build.0 = Debug|x64
		{2287CAF9-526E-4DF0-B2DE-6B8EF2B57B99}.Debug|x86.ActiveCfg = Debug|Win32
		{2287CAF9-526E-4DF0-B2DE-6B8EF2B57B99}.Debug|x86.Build.0 = Debug|Win32
		{2287CAF9-526E-4DF0-B2DE-6B8EF2B57B99}.Release|x64.ActiveCfg = Release|x64
		{2287CAF9-526E-4DF0-B2DE-6B8EF2B57B99}.Release|x64.Build.0 = Release|x64
		{2287CAF9-526E-4DF0-B2DE-6B8EF2B57B99}.Release|x86.ActiveCfg = Release|Win32
		{2287CAF9-526E-4DF0-B2DE-6B8EF2B57B99}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {53599B11-3309-48D7-B870-604A780E5FD9}
	EndGlobalSection
EndGlobal

```

`README.md`:

```md
# Naraka-Hack
小孩子不懂事写着玩的

自己更新基址和偏移

![Image text](https://github.com/Rythorndoran/Naraka-Hack/blob/main/Pictures/ScreenShot.jpg)

```