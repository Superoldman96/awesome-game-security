Project Path: arc_gmh5225_eac-leak_m3wgus19

Source Tree:

```txt
arc_gmh5225_eac-leak_m3wgus19
├── README.md
├── eac
│   ├── devtools
│   │   ├── anticheat_integritytool.cfg
│   │   ├── anticheat_integritytool.exe
│   │   ├── anticheat_integritytool64.exe
│   │   ├── base_private.key
│   │   └── base_public.cer
│   ├── dist
│   │   ├── EasyAntiCheat
│   │   │   ├── EasyAntiCheat_EOS_Setup.exe
│   │   │   ├── Licenses
│   │   │   │   ├── Apache-2.0.txt
│   │   │   │   ├── Licenses.txt
│   │   │   │   └── MIT.txt
│   │   │   ├── Localization
│   │   │   │   ├── ar_sa.cfg
│   │   │   │   ├── cs_cz.cfg
│   │   │   │   ├── de_de.cfg
│   │   │   │   ├── en_us.cfg
│   │   │   │   ├── es_ar.cfg
│   │   │   │   ├── es_es.cfg
│   │   │   │   ├── fr_fr.cfg
│   │   │   │   ├── it_it.cfg
│   │   │   │   ├── ja_ja.cfg
│   │   │   │   ├── ko_kr.cfg
│   │   │   │   ├── nl_nl.cfg
│   │   │   │   ├── pl_pl.cfg
│   │   │   │   ├── pt_br.cfg
│   │   │   │   ├── ru_ru.cfg
│   │   │   │   ├── th_th.cfg
│   │   │   │   ├── tr_tr.cfg
│   │   │   │   ├── zh_cn.cfg
│   │   │   │   └── zh_tw.cfg
│   │   │   ├── Settings - voice.json
│   │   │   ├── Settings.json
│   │   │   └── Splash.png
│   │   └── start_protected_game.exe
│   └── sdk
│       ├── Bin
│       │   ├── EOSSDK-Win32-Shipping.dll
│       │   ├── EOSSDK-Win64-Shipping.dll
│       │   ├── libEOSSDK-Linux-Shipping.so
│       │   ├── libEOSSDK-Mac-Shipping.dylib
│       │   ├── x64
│       │   │   └── xaudio2_9redist.dll
│       │   └── x86
│       │       └── xaudio2_9redist.dll
│       ├── Include
│       │   ├── Linux
│       │   │   └── eos_Linux_base.h
│       │   ├── Mac
│       │   │   └── eos_Mac_base.h
│       │   ├── Windows
│       │   │   ├── eos_Windows.h
│       │   │   └── eos_Windows_base.h
│       │   ├── eos_achievements.h
│       │   ├── eos_achievements_types.h
│       │   ├── eos_achievements_types_deprecated.inl
│       │   ├── eos_anticheatclient.h
│       │   ├── eos_anticheatclient_types.h
│       │   ├── eos_anticheatcommon_types.h
│       │   ├── eos_anticheatserver.h
│       │   ├── eos_anticheatserver_types.h
│       │   ├── eos_auth.h
│       │   ├── eos_auth_types.h
│       │   ├── eos_base.h
│       │   ├── eos_common.h
│       │   ├── eos_connect.h
│       │   ├── eos_connect_types.h
│       │   ├── eos_ecom.h
│       │   ├── eos_ecom_types.h
│       │   ├── eos_friends.h
│       │   ├── eos_friends_types.h
│       │   ├── eos_init.h
│       │   ├── eos_kws.h
│       │   ├── eos_kws_types.h
│       │   ├── eos_leaderboards.h
│       │   ├── eos_leaderboards_types.h
│       │   ├── eos_leaderboards_types_deprecated.inl
│       │   ├── eos_lobby.h
│       │   ├── eos_lobby_types.h
│       │   ├── eos_logging.h
│       │   ├── eos_metrics.h
│       │   ├── eos_metrics_types.h
│       │   ├── eos_mods.h
│       │   ├── eos_mods_types.h
│       │   ├── eos_p2p.h
│       │   ├── eos_p2p_types.h
│       │   ├── eos_platform_prereqs.h
│       │   ├── eos_playerdatastorage.h
│       │   ├── eos_playerdatastorage_types.h
│       │   ├── eos_presence.h
│       │   ├── eos_presence_types.h
│       │   ├── eos_progressionsnapshot.h
│       │   ├── eos_progressionsnapshot_types.h
│       │   ├── eos_reports.h
│       │   ├── eos_reports_types.h
│       │   ├── eos_result.h
│       │   ├── eos_rtc.h
│       │   ├── eos_rtc_admin.h
│       │   ├── eos_rtc_admin_types.h
│       │   ├── eos_rtc_audio.h
│       │   ├── eos_rtc_audio_types.h
│       │   ├── eos_rtc_types.h
│       │   ├── eos_sanctions.h
│       │   ├── eos_sanctions_types.h
│       │   ├── eos_sdk.h
│       │   ├── eos_sessions.h
│       │   ├── eos_sessions_types.h
│       │   ├── eos_stats.h
│       │   ├── eos_stats_types.h
│       │   ├── eos_titlestorage.h
│       │   ├── eos_titlestorage_types.h
│       │   ├── eos_types.h
│       │   ├── eos_ui.h
│       │   ├── eos_ui_keys.h
│       │   ├── eos_ui_types.h
│       │   ├── eos_userinfo.h
│       │   ├── eos_userinfo_types.h
│       │   └── eos_version.h
│       └── Lib
│           ├── EOSSDK-Win32-Shipping.lib
│           └── EOSSDK-Win64-Shipping.lib
├── eac-leak.sln
└── server
    ├── eos.cpp
    ├── eos.h
    ├── server.cpp
    ├── server.vcxproj
    ├── server.vcxproj.filters
    ├── stdafx.cpp
    └── stdafx.h

```

`README.md`:

```md
# Notice

Replace IDs from eos.cpp


```

`eac-leak.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31727.386
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "server", "server\server.vcxproj", "{FE4434A9-D001-4DAB-AAE2-39DFC718D235}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{FE4434A9-D001-4DAB-AAE2-39DFC718D235}.Debug|x64.ActiveCfg = Debug|x64
		{FE4434A9-D001-4DAB-AAE2-39DFC718D235}.Debug|x64.Build.0 = Debug|x64
		{FE4434A9-D001-4DAB-AAE2-39DFC718D235}.Debug|x86.ActiveCfg = Debug|Win32
		{FE4434A9-D001-4DAB-AAE2-39DFC718D235}.Debug|x86.Build.0 = Debug|Win32
		{FE4434A9-D001-4DAB-AAE2-39DFC718D235}.Release|x64.ActiveCfg = Release|x64
		{FE4434A9-D001-4DAB-AAE2-39DFC718D235}.Release|x64.Build.0 = Release|x64
		{FE4434A9-D001-4DAB-AAE2-39DFC718D235}.Release|x86.ActiveCfg = Release|Win32
		{FE4434A9-D001-4DAB-AAE2-39DFC718D235}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {D7273B6A-0139-4874-8415-63C3A5265533}
	EndGlobalSection
EndGlobal

```

`eac/devtools/anticheat_integritytool.cfg`:

```cfg
#-------------------------------------------
# Anti-Cheat Integrity Tool Configuration File
#-------------------------------------------
#
config_info:
{
    version = 2;
};
search_options:
{  
	/*
	 * Size threshold for file hashing in megabytes.
	 * Any files bigger than the threshold will be excluded
	 * from the integrity catalog.
	 *
	 * To include all files in the integrity catalog, keep the threshold at zero.
	 */
	exclude_size_threshold = 0;
	
    /*
     * Paths to ignore.
     *
     * Supports both directories and files in simplified UNIX glob style.
     * Single character ('?') and multicharacter ('*') wildcards are supported, but
     * '*' can never match more than one directory level.
     *
     * Any files that could be different for each user, do not
     * affect gameplay, or have their integrity verified separately
     * should be listed here.
     *
     * Unity games: This list must contain your Mono\\etc folder.
     */
    exclude_paths = [
        "EasyAntiCheat\\Certificates",
        "EasyAntiCheat\\Licenses",
        "Mono\\etc",
        "logs",
        "screenshots",
        "updates"
    ];
    
    /*
     * Paths to include.
     *
     * Supports both directories and files in simplified UNIX glob style.
     * Single character ('?') and multicharacter ('*') wildcards are supported, but
     * '*' can never match more than one directory level.
     *
     * If you have only a few files or directories to include this
     * option may be easier than exclude_paths. Only one of 
     * exclude_paths or include_paths is supported, never both.
     *
     * Note that if you list a file here directly or by wildcard it will
     * override exclude_extensions, but files inside listed directories will
     * continue to follow exclude_extensions.
     */
    /*include_paths = [
        "gamedata"
    ];*/
    
    /*
     * Path aliases for remapping.
     *
     * If you need to remap specific paths to suit your build system 
     * put them here. For each ["str_a","str_b"] pair all occurences of "str_a"
     * in paths will be replaced with "str_b" as the very last step of 
     * building the hash catalog. All other options specified in this config 
     * will operate on the actual build time directory structure before any
     * aliases are applied.
     */
    /*alias_paths = (
        ["game\\bin32release", "game\\bin32"]
    );*/
    /*
     * Files to ignore by extension.
     * Modify to suit your needs.
     */
    exclude_extensions = [
        ".bak",
        ".bat",
        ".bmp",
        ".cfg",
        ".db",
        ".ico",
        ".inf",
        ".ini",
        ".jpg",
        ".last",
        ".log",
        ".manifest",
        ".mdb",
        ".pdb",
        ".png",
        ".pubkey",
        ".txt",
        ".vdf",
        ".xml"
    ];
    
    /*
     * Do not set unless really needed.
     */
    ignore_files_without_extension = false;
};
```

`eac/dist/EasyAntiCheat/Licenses/Apache-2.0.txt`:

```txt

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`eac/dist/EasyAntiCheat/Licenses/Licenses.txt`:

```txt
cpp11-on-multicore (zlib License, Altered source version)
	https://github.com/preshing/cpp11-on-multicore/blob/master/LICENSE
	https://github.com/preshing/cpp11-on-multicore

	Copyright (c) 2015 Jeff Preshing

	This software is provided 'as-is', without any express or implied
	warranty. In no event will the authors be held liable for any damages
	arising from the use of this software.

	Permission is granted to anyone to use this software for any purpose,
	including commercial applications, and to alter it and redistribute it
	freely, subject to the following restrictions:

	1. The origin of this software must not be misrepresented; you must not
	   claim that you wrote the original software. If you use this software
	   in a product, an acknowledgement in the product documentation would be
	   appreciated but is not required.
	2. Altered source versions must be plainly marked as such, and must not be
	   misrepresented as being the original software.
	3. This notice may not be removed or altered from any source distribution.

Hacker Disassembler Engine (custom license, attribution & license distribution required)
    https://github.com/kimperator/MologieDetours/blob/master/hde32/LICENSE

	License agreement

	Hacker Disassembler Engine 32 C
	Copyright (c) 2008-2009, Vyacheslav Patkov.
	All rights reserved.

	Redistribution and use in source and binary forms, with or without
	modification, are permitted provided that the following conditions
	are met:

	 1. Redistributions of source code must retain the above copyright
		notice, this list of conditions and the following disclaimer.
	 2. Redistributions in binary form must reproduce the above copyright
		notice, this list of conditions and the following disclaimer in the
		documentation and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
	TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
	PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
	CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
	EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
	PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
	PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
	LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

mbed TLS (Apache 2.0)
    https://www.apache.org/licenses/LICENSE-2.0
	https://github.com/ARMmbed/mbedtls
	
mini-printf (BSD License)
	https://github.com/mludvig/mini-printf

	Copyright (c) 2013,2014 Michal Ludvig <michal@logix.cz>
	All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
	
		* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
		* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
		* Neither the name of the auhor nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	
miniz (Public Domain)
	https://code.google.com/archive/p/miniz/
	
	Copyright 2013-2014 RAD Game Tools and Valve Software
	Copyright 2010-2014 Rich Geldreich and Tenacious Software LLC

	All Rights Reserved.

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE.
	
musl (MIT License)
	https://git.musl-libc.org/cgit/musl/tree/COPYRIGHT
	
	musl as a whole is licensed under the following standard MIT license:
	----------------------------------------------------------------------
	Copyright © 2005-2014 Rich Felker, et al.

	Permission is hereby granted, free of charge, to any person obtaining
	a copy of this software and associated documentation files (the
	"Software"), to deal in the Software without restriction, including
	without limitation the rights to use, copy, modify, merge, publish,
	distribute, sublicense, and/or sell copies of the Software, and to
	permit persons to whom the Software is furnished to do so, subject to
	the following conditions:

	The above copyright notice and this permission notice shall be
	included in all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
	CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
	TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	----------------------------------------------------------------------
	
Roboto Regular, Google Fonts (Apache 2.0)
	https://github.com/google/roboto/blob/master/LICENSE
	https://developers.google.com/fonts/
	
SimpleGlob, SimpleOpt (MIT)
	https://opensource.org/licenses/MIT
	https://github.com/brofield/simpleopt
	
SDL 2.0.12 (zlib3):
	https://www.libsdl.org/license.php
	https://github.com/libsdl-org/SDL

	This software is provided 'as-is', without any express or implied
	warranty.  In no event will the authors be held liable for any damages
	arising from the use of this software.

	Permission is granted to anyone to use this software for any purpose,
	including commercial applications, and to alter it and redistribute it
	freely, subject to the following restrictions:

	1. The origin of this software must not be misrepresented; you must not
	   claim that you wrote the original software. If you use this software
	   in a product, an acknowledgment in the product documentation would be
	   appreciated but is not required.
	2. Altered source versions must be plainly marked as such, and must not be
	   misrepresented as being the original software.
	3. This notice may not be removed or altered from any source distribution.
	SDL 1.2 and older are available under the GNU LGPL license (https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html).

SDL Image 2.0.5 (zlib):
	https://github.com/libsdl-org/SDL_image/blob/main/LICENSE.txt
	https://github.com/libsdl-org/SDL_image

	Copyright (C) 1997-2021 Sam Lantinga <slouken@libsdl.org>

	This software is provided 'as-is', without any express or implied
	warranty.  In no event will the authors be held liable for any damages
	arising from the use of this software.

	Permission is granted to anyone to use this software for any purpose,
	including commercial applications, and to alter it and redistribute it
	freely, subject to the following restrictions:

	1. The origin of this software must not be misrepresented; you must not
	   claim that you wrote the original software. If you use this software
	   in a product, an acknowledgment in the product documentation would be
	   appreciated but is not required.
	2. Altered source versions must be plainly marked as such, and must not be
	   misrepresented as being the original software.
	3. This notice may not be removed or altered from any source distribution.

SDL TTF 2.0.15 (zlib, since 2.0.11):
	https://github.com/SDL-mirror/SDL_ttf/blob/master/COPYING.txt
	https://github.com/SDL-mirror/SDL_ttf

Freetype 2.10.2:
	https://www.freetype.org/license.html
	https://download.savannah.gnu.org/releases/freetype/

libpng 1.6.37:
	https://github.com/glennrp/libpng/blob/libpng16/LICENSE
	https://github.com/glennrp/libpng

zlib 1.2.11:
	https://github.com/madler/zlib/blob/master/README
	https://github.com/madler/zlib
```

`eac/dist/EasyAntiCheat/Licenses/MIT.txt`:

```txt
The MIT License (MIT)
Copyright (c) <year> <copyright holders>

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
```

`eac/dist/EasyAntiCheat/Localization/ar_sa.cfg`:

```cfg
#----------------------------------------------------------
# Easy Anti-Cheat Localization File
#
# This file must use UTF-8 encoding.
#
# Each localization file should be named ll_CC.cfg where
# ll = ISO-639 code for language (e.g. "en")
# CC = ISO-3166 code for country (e.g. "US")
#----------------------------------------------------------

bugreport:
{
	btn_continue = "اتصل بالإنترنت للبحث عن حل وأغلق اللعبة.";
	btn_exit = "أغلق اللعبة.";
	btn_hidedetails = "أخفي التفاصيل";
	btn_showdetails = "أظهر التفاصيل";
	chk_sendreport = "ارسال رمز الخطأ";
	error_code = "رمز الخطأ:";
	lbl_body1 = "نعتذر، لدينا مشكلة في بدء لعبتك";
	lbl_body2 = "يُرجى مساعدتنا بالإبلاغ عن تلك المشكلة.";
	lbl_body3 = "يمكن أن تقوم Easy Anti-Cheat بالبحث عن حل للمشكلة على الإنترنت والمحاولة في المساعدة لحلها.";
	lbl_header = "لا يمكن تشغيل اللعبة";
	title = "خطأ تشغيل";
};
game_error:
{
	error_catalogue_file = "خطأ الوصول لفهرس EAC";
	error_catalogue_not_found = "فهرس EAC غير موجود";
	error_certificate_revoked = "تم إلغاء شهادة فهرس EAC ";
	error_corrupted_memory = "ذاكرة تالفة";
	error_corrupted_network = "تدفق تالف للحزمة";
	error_file_forbidden = "ملف لعبة غير معروف";
	error_file_not_found = "ملف مطلوب مفقود";
	error_file_version = "إصدار ملف غير معروف";
	error_module_forbidden = "نموذج ممنوع";
	error_system_configuration = "تهيئة نظام ممنوعة";
	error_system_version = "ملف نظام غير موثوق";
	error_tool_forbidden = "أداة ممنوعة";
	error_violation = "خطأ مكافحة غش داخلي";
	error_virtual = "لا يمكن التشغيل على جهاز افتراضي";
	peer_client_banned = "تم منع كشف غش النظير.";
	peer_heartbeat_rejected = "تم رفض كشف غش النظير";
	peer_validated = "تم اكتمال التحقق من كشف غش النظير.";
	peer_validation_failed = "فشل التحقق من كشف غش النظير.";
	executable_not_hashed = "تعذر تحديد موقع إدخال الملف القابل للتنفيذ الخاص باللعبة في الفهرس.";
};
launcher:
{
	btn_cancel = "إلغاء";
	btn_exit = "خروج";
	error_cancel = "تم إلغاء التشغيل";
	error_filenotfound = "لم يتم العثور على الملف";
	error_init = "مشكلة في البدء";
	error_install = "خطأ تثبيت";
	error_launch = "خطأ تشغيل";
	error_nolib = "لا يمكن تحميل مكتبة Easy Anti-Cheat";
	loading = "جارِ التحميل";
	wait = "يُرجى الإنتظار";
	initializing = "جارِ التهيئة";
	success_waiting_for_game = "في انتظار تحميل اللعبة";
	success_closing = "تم بنجاح";
	network_error = "خطأ بالشبكة";
	error_no_settings_file = "لم يتم العثور على {0}";
	error_invalid_settings_format = "ليس لدى {0} تنسيق JSON صالح";
	error_missing_required_field = "{0} يفقد الحقل المطلوب ({1})";
	download_progress = "تقدم التنزيل: {0}";
};
launcher_error:
{
	error_already_running = "هناك تطبيق يستخدم Easy Anti-Cheat قيد التشغيل بالفعل!";
	error_application = "اكتشف عميل اللعبة خطأ بالتطبيق.";
	error_bad_exe_format = "يلزم وجود نظام تشغيل من الإصدار 64 بت";
	error_bitset_32 = "برجاء استخدام اصدار 32 بت من اللعبة";
	error_bitset_64 = "برجاء استخدام اصدار 64 بت من اللعبة";
	error_cancelled = "تم إلغاء العملية من قبل العميل";
	error_certificate_validation = "خطأ توثيق شهادة توقيع تعليمات برمجية لـ Easy Anti-Cheat";
	error_client_auth_failed = "فشل مصادقة نظام كشف الغش لدى العميل صاحب اللعبة ويحتمل أنه لم يقم بتنشيط نظام حماية كشف الغش.";
	error_client_banned = "تم حظر حساب اللعبة من كافة خصائص اللعبة على الإنترنت.";
	error_client_disconnected = "لا يقوم العميل صاحب اللعبة بتشغيل نظام كشف الغش.";
	error_client_violation = "فشل العميل صاحب اللعبة في اجراء تحقق سلامة كشف الغش أثناء التشغيل.";
	error_connection = "فشل الاتصال بشبكة توزيع المحتوى!";
	error_debugger = "تم اكتشاف مصحح أخطاء. برجاء إلغاء تحميله وإعادة المحاولة";
	error_disk_space = "لا يوجد مساحة كافية على القرص.";
	error_dns = "فشل حل DNS لشبكة توزيع المحتوى!";
	error_dotlocal = "تم التعرف على إعادة توجيه DotLocal DLL.";
	error_dotlocal_instructions = "يرجى حذف الملف التالي";
	error_file_not_found = "لم يتم العثور على الملف:";
	error_forbidden_tool = "برجاء إغلاق {0} قبل بدء اللعبة";
	error_forbidden_driver = "يُرجى تحميل {0} قبل بدء تشغيل اللعبة";
	error_generic = "خطأ غير متوقع.";
	error_kernel_debug = "لا يمكن تشغيل Easy Anti-Cheat إذا كان Kernel Debugging ممكنًا";
	error_kernel_dse = "لا يمكن تشغيل Easy Anti-Cheat إذا كان Driver Signature Enforcement معطلاً";
	error_kernel_modified = "تم التعرف على تعديل Windows kernel ممنوع";
	error_library_load = "لا يمكن تحميل مكتبة Easy Anti-Cheat";
	error_memory = "ذاكرة غير كافية لبدء اللعبة";
	error_module_load = "فشل تحميل وحدة مكافح الغش";
	error_patched = "تم التعرف على محمل إقلاع Windows معدل";
	error_process = "لا يمكن إنشاء العملية";
	error_process_crash = "تم إنهاء العملية بصورة مفاجئة";
	error_safe_mode = "لا يمكن أن تعمل Easy Anti-Cheat في الوضع الآمن لـ Windows";
	error_socket = "هناك شيء يمنع التطبيق من الوصول للإنترنت!";
	error_ssl = "خطأ إنشاء اتصال SSL مع خدمة CDN!";
	error_start = "فشل بدء اللعبة";
	error_uncpath_forbidden = "لا يمكن تشغيل اللعبة من خلال مشاركة شبكة. (مسار (UNC)";
	error_missing_path = "المسار التنفيذي للعبة مفقود";
	error_invalid_executable = "الملف التنفيذي للعبة غير صالح: ";
	error_connection_failed = "فشل الاتصال: ";
	error_module_not_found = "لم يتم العثور على وحدة Anti-Cheat النمطية";
	error_missing_game_id = "مُعرف اللعبة المفقودة";
	error_dns_resolve_failed = "فشل حل نظام أسماء المجالات (DNS) إلى الوكيل";
	error_dns_connection_failed = "فشل الاتصال بشبكة توزيع المحتوى! رمز Curl: {0}!";
	error_http_response = "رمز استجابة HTTP: {0} رمز Curl: {1}";
	error_driver_handle = "خطأ غير متوقع. (فشل فتح مؤشر برنامج التشغيل)";
	error_incompatible_service = "هناك خدمة Easy Anti-Cheat غير متوافقة قيد التشغيل بالفعل. يُرجى الخروج من الألعاب الأخرى قيد التشغيل أو قم بإعادة التشغيل";
	error_incompatible_driver_version = "هناك إصدار برنامج تشغيل Easy Anti-Cheat غير متوافق قيد التشغيل بالفعل. يُرجى الخروج من الألعاب الأخرى قيد التشغيل أو قم بإعادة التشغيل";
	error_restart_windows = "خطأ غير متوقع. (أعد تشغيل Windows لإكمال تحديث EasyAntiCheat)";
	error_another_launcher = "خطأ غير متوقع. (مُشغل آخر قيد التشغيل بالفعل)";
	error_game_running = "خطأ غير متوقع. (اللعبة قيد التشغيل بالفعل)";
	error_patched_boot_loader = "تم الكشف عن أداة تحميل تمهيد Windows المصححة. (تم تعطيل حماية تصحيح Kernel)";
	error_unknown_process = "عميل لعبة غير معروف. لا يمكن الاستمرار.";
	error_unknown_game = "لعبة غير مكوّنة. تتعذر المتابعة.";
	error_windows_vista_sp = "قم بتثبيت Windows Vista Service Pack 2 لتشغيل Easy Anti-Cheat.";
	error_windows_xp = "يتطلب وجود اصدار Windows XP أو إصدار لاحق.";
	error_windows_xp_64 = "Windows XP 64 بت غير مدعوم.";
	error_windows_xp_sp = "قم بتثبيت Windows XP Service Pack 3 لتشغيل Easy Anti-Cheat.";
	success_initialized = "تم بدء Easy Anti-Cheat بنجاح";
	success_loaded = "تم تحميل Easy Anti-Cheat بنجاح في اللعبة";
};
setup:
{
	btn_finish = "إنهاء";
	btn_install = "قم بالتثبيت الآن";
	btn_repair = "إصلاح الخدمة";
	btn_uninstall = "إلغاء تثبيت";
	epic_link = "© Epic Games, Inc";
	error_prefix = "خطأ:";
	install_progress = "جارِ التثبيت...";
	install_success = "تم التثبيت بنجاح";
	licenses_link = "الترخيصات";
	privacy_link = "الخصوصية";
	repair_progress = "جارِ الإصلاح";
	title = "تنصيب خدمة Easy Anti-Cheat";
	uninstall_progress = "ِ إلغاء التثبيت";
	uninstall_success = "تم إلغاء التثبيت بنجاح";
};
setup_error:
{
	error_cancelled = "تم إلغاء العملية من قبل العميل";
	error_encrypted = "Easy Anti-Cheat تم تشفير مجلد تثبيت";
	error_intro = "فشل تنصيب Easy Anti-Cheat";
	error_not_installed = "لم يتم تثبيت Easy Anti-Cheat";
	error_registry = "الوصول للسجل ممنوع";
	error_rights = "إمتيازات غير كافية";
	error_service = "لا يمكن إلغاء الخدمة";
	error_system = "الوصول لـ System32 ممنوع";
};
```

`eac/dist/EasyAntiCheat/Localization/cs_cz.cfg`:

```cfg
#----------------------------------------------------------
# Easy Anti-Cheat Localization File
#
# This file must use UTF-8 encoding.
#
# Each localization file should be named ll_CC.cfg where
# ll = ISO-639 code for language (e.g. "en")
# CC = ISO-3166 code for country (e.g. "US")
#----------------------------------------------------------

bugreport:
{
	btn_continue = "Vyhledejte řešení online a vypněte hru.";
	btn_exit = "Vypněte hru.";
	btn_hidedetails = "Skrýt podrobnosti";
	btn_showdetails = "Zobrazit podrobnosti";
	chk_sendreport = "Odeslat hlášení o chybě";
	error_code = "Kód chyby:";
	lbl_body1 = "Omlouváme se, nepodařilo se nám spustit vaši hru";
	lbl_body2 = "Pomozte nám prosím nahlášením tohoto problému.";
	lbl_body3 = "Easy Anti-Cheat se může pokusit vyhledat řešení tohoto problému online a pomoci vám s jeho opravou.";
	lbl_header = "Spuštění hry se nezdařilo";
	title = "Chyba při spouštění";
};
game_error:
{
	error_catalogue_file = "Přístup k rejstříku EAC se nezdařil";
	error_catalogue_not_found = "Rejstřík EAC nebyl nalezen";
	error_certificate_revoked = "Certifikát rejstříku EAC byl zrušen";
	error_corrupted_memory = "Poškozená paměť";
	error_corrupted_network = "Poškozený tok packetů";
	error_file_forbidden = "Neznámý herní soubor";
	error_file_not_found = "Chybí požadovaný soubor";
	error_file_version = "Neznámá verze souboru";
	error_module_forbidden = "Zakázaný modul";
	error_system_configuration = "Zakázaná konfigurace systému";
	error_system_version = "Nedůvěryhodný systémový soubor";
	error_tool_forbidden = "Zakázaný nástroj";
	error_violation = "Interní chyba anticheatovací služby";
	error_virtual = "Spuštění na virtuálním zařízení není možné.";
	peer_client_banned = "Párová anticheatovací kontrola byla zakázána.";
	peer_heartbeat_rejected = "Párová anticheatovací kontrola byla odmítnuta.";
	peer_validated = "Párová anticheatovací kontrola byla dokončena.";
	peer_validation_failed = "Párová anticheatovací kontrola se nezdařila.";
	executable_not_hashed = "V katalogu se nepodařilo najít záznam spustitelného souboru hry.";
};
launcher:
{
	btn_cancel = "Zrušit";
	btn_exit = "Odejít";
	error_cancel = "Spouštění bylo zrušeno";
	error_filenotfound = "Soubor nebyl nalezen";
	error_init = "Chyba při inicializaci";
	error_install = "Chyba při instalaci";
	error_launch = "Chyba při spouštění";
	error_nolib = "Načtení knihovny Easy Anti-Cheat se nezdařilo";
	loading = "NAČÍTÁNÍ";
	wait = "Čekejte, prosím";
	initializing = "INICIALIZACE";
	success_waiting_for_game = "ČEKÁM NA HRU";
	success_closing = "Úspěch";
	network_error = "Chyba sítě";
	error_no_settings_file = "{0} nenalezeno";
	error_invalid_settings_format = "{0} nemá platný formát JSON";
	error_missing_required_field = "V {0} chybí povinné pole ({1})";
	download_progress = "Postup stahování: {0}";
};
launcher_error:
{
	error_already_running = "Již je spuštěna jiná aplikace používající Easy Anti-Cheat!";
	error_application = "U herního klienta došlo k chybě aplikace.";
	error_bad_exe_format = "Je vyžadován 64bitový OS";
	error_bitset_32 = "Použijte prosím 32bitovou verzi hry";
	error_bitset_64 = "Použijte prosím 64bitovou verzi hry";
	error_cancelled = "Operace byla zrušena uživatelem";
	error_certificate_validation = "Během ověřování certifikátu Easy Anti-Cheat pro podpis kódu došlo k chybě";
	error_client_auth_failed = "U herního klienta se nepodařilo provést kontrolu anticheatovací ochrany, jeho anticheatovací ochrana možná není aktivní.";
	error_client_banned = "Hernímu účtu byl zakázán přístup ke všem online funkcím hry.";
	error_client_disconnected = "Herní klient nemá spuštěnou anticheatovací ochranu.";
	error_client_violation = "Herní klient nedokázal dokončit runetime kontrolu integrity anticheatovacího systému.";
	error_connection = "Připojení k distribuční síti obsahu se nezdařilo!";
	error_debugger = "Byla zjištěna přítomnost ladicího programu. Vypněte jej prosím a zkuste to znovu.";
	error_disk_space = "Nedostatek místa na disku.";
	error_dns = "Zjištění DNS pro distribuční síť obsahu se nezdařilo!";
	error_dotlocal = "Bylo zjištěno přesměrování DotLocal DLL.";
	error_dotlocal_instructions = "Smažte prosím následující soubor";
	error_file_not_found = "Soubor nebyl nalezen:";
	error_forbidden_tool = "Před spuštěním hry prosím vypněte {0}";
	error_forbidden_driver = "Před spuštěním hry odstraňte z paměti {0}";
	error_generic = "Neočekávaná chyba.";
	error_kernel_debug = "Easy Anti-Cheat nelze spustit, pokud je povoleno ladění jádra";
	error_kernel_dse = "Easy Anti-Cheat nelze spustit, je-li vypnutá služba vynucení podpisu ovladače";
	error_kernel_modified = "Byla zjištěna přítomnost zakázané úpravy jádra Windows";
	error_library_load = "Načtení knihovny Easy Anti-Cheat se nezdařilo";
	error_memory = "Nedostatek paměti pro spuštění hry";
	error_module_load = "Načtení anticheatovacího modulu se nezdařilo";
	error_patched = "Byla zjištěna přítomnost upraveného spouštěcího zavaděče Windows";
	error_process = "Nelze vytvořit proces";
	error_process_crash = "Proces byl nečekaně ukončen";
	error_safe_mode = "Easy Anti-Cheat nelze spustit v nouzovém režimu Windows";
	error_socket = "Něco blokuje přístup aplikace na internet!";
	error_ssl = "Nepodařilo se vytvořit SSL spojení se službou CDN!";
	error_start = "Spuštění hry se nezdařilo";
	error_uncpath_forbidden = "Hru nelze spustit přes sdílení po síti. (Cesta UNC)";
	error_missing_path = "Chybí cesta ke spustitelnému souboru hry";
	error_invalid_executable = "Neplatný spustitelný soubor hry: ";
	error_connection_failed = "Spojení se nezdařilo: ";
	error_module_not_found = "Modul Anti-Cheat nebyl nalezen";
	error_missing_game_id = "Chybějící ID hry";
	error_dns_resolve_failed = "Určení DNS pro proxy se nezdařilo";
	error_dns_connection_failed = "Připojení k síti pro distribuci obsahu se nezdařilo! Kód cURL: {0}!";
	error_http_response = "Kód odpovědi HTTP: {0} kód Curl: {1}";
	error_driver_handle = "Neočekávaná chyba. (Nepodařilo se otevřít spojení ovladače)";
	error_incompatible_service = "Již je spuštěna nekompatibilní služba Easy Anti-Cheat. Ukončete ostatní spuštěné hry nebo proveďte restart.";
	error_incompatible_driver_version = "Již je spuštěna nekompatibilní verze ovladače Easy Anti-Cheat. Ukončete ostatní spuštěné hry nebo proveďte restart.";
	error_restart_windows = "Neočekávaná chyba. (Dokončete aktualizaci EasyAntiCheat restartováním Windows)";
	error_another_launcher = "Neočekávaná chyba. (Již běží jiný spouštěcí program)";
	error_game_running = "Neočekávaná chyba. (Hra je již spuštěna)";
	error_patched_boot_loader = "Zjištěn upravený program pro zavádění Windows. (Funkce Kernel Patch Protection byla deaktivována)";
	error_unknown_process = "Nerozpoznaný herní klient. Nelze pokračovat.";
	error_unknown_game = "Hra nebyla nakonfigurována. Nelze pokračovat.";
	error_windows_vista_sp = "Ke spuštění služby Easy Anti-Cheat je zapotřebí nainstalovat Windows Vista Service Pack 2.";
	error_windows_xp = "Je vyžadován systém Windows XP nebo novější.";
	error_windows_xp_64 = "64bitová verze Windows XP není podporována.";
	error_windows_xp_sp = "Ke spuštění služby Easy Anti-Cheat je zapotřebí nainstalovat Windows XP Service Pack 3.";
	success_initialized = "Inicializace služby Easy Anti-Cheat proběhla úspěšně";
	success_loaded = "Načtení služby Easy Anti-Cheat do hry proběhlo úspěšně";
};
setup:
{
	btn_finish = "Dokončit";
	btn_install = "Nainstalovat";
	btn_repair = "Opravit službu";
	btn_uninstall = "Odinstalovat";
	epic_link = "© Epic Games, Inc";
	error_prefix = "Chyba:";
	install_progress = "Instalování…";
	install_success = "Instalace proběhla úspěšně";
	licenses_link = "Licence";
	privacy_link = "Soukromí";
	repair_progress = "Opravování…";
	title = "Nastavení služby Easy Anti-Cheat";
	uninstall_progress = "Odinstalování…";
	uninstall_success = "Odinstalace proběhla úspěšně";
};
setup_error:
{
	error_cancelled = "Operace byla zrušena uživatelem";
	error_encrypted = "Instalační složka Easy Anti-Cheat byla zašifrována";
	error_intro = "Instalace služby Easy Anti-Cheat se nezdařila";
	error_not_installed = "Služba Easy Anti-Cheat není nainstalovaná.";
	error_registry = "Byl odepřen přístup do registrů";
	error_rights = "Nedostatečná oprávnění";
	error_service = "Nelze vytvořit službu";
	error_system = "Byl odepřen přístup do složky System32";
};
```

`eac/dist/EasyAntiCheat/Localization/de_de.cfg`:

```cfg
#----------------------------------------------------------
# Easy Anti-Cheat Localization File
#
# This file must use UTF-8 encoding.
#
# Each localization file should be named ll_CC.cfg where
# ll = ISO-639 code for language (e.g. "en")
# CC = ISO-3166 code for country (e.g. "US")
#----------------------------------------------------------

bugreport:
{
	btn_continue = "Suche online nach einer Lösung und schließe das Spiel.";
	btn_exit = "Schließe das Spiel.";
	btn_hidedetails = "Details ausblenden";
	btn_showdetails = "Details einblenden";
	chk_sendreport = "Fehlerbericht senden";
	error_code = "Fehlercode:";
	lbl_body1 = "Leider gab es ein Problem beim Starten deines Spiels";
	lbl_body2 = "Bitte hilf uns, indem du dieses Problem meldest.";
	lbl_body3 = "Easy Anti-Cheat kann online nach einer Lösung für dieses Problem suchen und versuchen, es zu beheben.";
	lbl_header = "Spiel konnte nicht gestartet werden";
	title = "Startfehler";
};
game_error:
{
	error_catalogue_file = "Fehler beim Zugriff auf EAC-Index";
	error_catalogue_not_found = "EAC-Index nicht gefunden";
	error_certificate_revoked = "EAC-Indexzertifikat wurde aufgehoben";
	error_corrupted_memory = "Fehlerhafter Speicher";
	error_corrupted_network = "Fehlerhafter Packet Flow";
	error_file_forbidden = "Unbekannte Spieldatei";
	error_file_not_found = "Erforderliche Datei fehlt";
	error_file_version = "Unbekannte Dateiversion";
	error_module_forbidden = "Verbotenes Modul";
	error_system_configuration = "Verbotene Systemkonfiguration";
	error_system_version = "Nicht vertrauenswürdige Systemdatei";
	error_tool_forbidden = "Verbotenes Tool";
	error_violation = "Interner Anti-Cheat-Fehler";
	error_virtual = "Läuft nicht auf virtueller Maschine";
	peer_client_banned = "Anti-Cheat Peer gesperrt.";
	peer_heartbeat_rejected = "Anti-Cheat Peer abgelehnt.";
	peer_validated = "Anti-Cheat Peerüberprüfung abgeschlossen.";
	peer_validation_failed = "Anti-Cheat Peerüberprüfung fehlgeschlagen";
	executable_not_hashed = "Für die ausführbare Spieldatei konnte kein Eintrag im Katalog gefunden werden.";
};
launcher:
{
	btn_cancel = "Abbrechen";
	btn_exit = "Verlassen";
	error_cancel = "Start abgebrochen";
	error_filenotfound = "Datei nicht gefunden";
	error_init = "Initialisierungsfehler";
	error_install = "Installationsfehler";
	error_launch = "Startfehler";
	error_nolib = "Easy Anti-Cheat-Bibliothek konnte nicht geladen werden";
	loading = "LÄDT";
	wait = "Bitte warten";
	initializing = "INITIALISIERT";
	success_waiting_for_game = "WARTET AUF DAS SPIEL";
	success_closing = "Erfolgreich";
	network_error = "Netzwerkfehler";
	error_no_settings_file = "{0} konnte nicht gefunden werden.";
	error_invalid_settings_format = "{0} hat kein gültiges JSON-Format.";
	error_missing_required_field = "In {0} fehlt ein erforderliches Feld ({1}).";
	download_progress = "Download-Fortschritt: {0}";
};
launcher_error:
{
	error_already_running = "Eine Anwendung mit AntiEasyCheat läuft bereits!";
	error_application = "Der Game-Client ist auf einen Anwendungsfehler gestoßen.";
	error_bad_exe_format = "64-Bit-Betriebssystem erforderlich";
	error_bitset_32 = "Bitte verwende die Version 32-bit des Spiels";
	error_bitset_64 = "Bitte verwende die Version 64-bit des Spiels";
	error_cancelled = "Vorgang vom Benutzer abgebrochen";
	error_certificate_validation = "Fehler bei Validierung des Easy Anti-Cheat-Codesignierungs-Zertifikats";
	error_client_auth_failed = "Der Game-Client hat die Anti-Cheat-Authentifizierung nicht bestanden und es kann sein, dass der Anti-Cheat-Schutz nicht aktiviert ist.";
	error_client_banned = "Das Spielekonto wurde von allen Online-Spielefunktionen ausgeschlossen.";
	error_client_disconnected = "Anti-Cheat läuft nicht für den Game-Client.";
	error_client_violation = "Der Game-Client hat den Integritätstest für Anti-Cheat-Runtime nicht bestanden.";
	error_connection = "Verbindung mit dem Content-Verteilernetzwerk fehlgeschlagen!";
	error_debugger = "Ein Debugger wurde entdeckt. Bitte beende ihn und versuche es noch einmal.";
	error_disk_space = "Nicht genug Platz auf der Festplatte.";
	error_dns = "DNS-Auflösung vom Content-Verteilernetzwerk fehlgeschlagen! ";
	error_dotlocal = "DotLocal DLL-Umleitung entdeckt.";
	error_dotlocal_instructions = "Bitte lösche die folgende Datei";
	error_file_not_found = "Datei nicht gefunden:";
	error_forbidden_tool = "Bitte schließe {0}, bevor du das Spiel startest";
	error_forbidden_driver = "Bitte {0} vor dem Start des Spiels entfernen.";
	error_generic = "Unerwarteter Fehler.";
	error_kernel_debug = "Easy Anti-Cheat kann nicht ausgeführt werden, wenn Kernel-Debugging aktiviert ist";
	error_kernel_dse = "Easy Anti-Cheat kann nicht ausgeführt werden, wenn der Driver Signature Enforcement deaktiviert wurde.";
	error_kernel_modified = "Verbotene Windows-Kernel-Veränderung entdeckt";
	error_library_load = "Easy Anti-Cheat-Bibliothek konnte nicht geladen werden";
	error_memory = "Nicht genug Speicher, um das Spiel zu starten";
	error_module_load = "Anti-Cheat-Modul konnte nicht geladen werden";
	error_patched = "Ein gepatchter Windows Boot-Loader wurde entdeckt";
	error_process = "Vorgang kann nicht erstellte werden";
	error_process_crash = "Der Vorgang wurde plötzlich abgebrochen";
	error_safe_mode = "Easy Anti-Cheat kann nicht im Sicheren Modus von Windows ausgeführt werden.";
	error_socket = "Etwas hält die Anwendung davon ab, auf das Internet zuzugreifen!";
	error_ssl = "Fehler beim Herstellen der SSL-Verbindung mit dem CDN-Service!";
	error_start = "Spiel konnte nicht gestartet werden";
	error_uncpath_forbidden = "Das Spiel kann nicht über eine Netzwerkfreigabe ausgeführt werden. (UNC-Pfad)";
	error_missing_path = "Fehlender Pfad zur ausführbaren Spieldatei";
	error_invalid_executable = "Ausführbare Spieldatei ungültig: ";
	error_connection_failed = "Verbindung fehlgeschlagen: ";
	error_module_not_found = "Anti-Cheat-Modul nicht gefunden";
	error_missing_game_id = "Fehlende Spiel-ID";
	error_dns_resolve_failed = "DNS konnte den Proxy-Server-Namen nicht auflösen";
	error_dns_connection_failed = "Verbindung zum Content Distribution Network fehlgeschlagen! Curl-Code: {0}!";
	error_http_response = "HTTP-Antwort-Code: {0} Curl-Code: {1}";
	error_driver_handle = "Unerwarteter Fehler. (Treiber-Handle konnte nicht geöffnet werden)";
	error_incompatible_service = "Eine inkompatibler Easy Anti-Cheat-Dienst wird bereits ausgeführt. Schließe bitte andere Spiele oder starte deinen PC neu.";
	error_incompatible_driver_version = "Eine inkompatible Treiberversion von Easy Anti-Cheat wird bereits ausgeführt. Schließe bitte andere Spiele oder starte deinen PC neu.";
	error_restart_windows = "Unerwarteter Fehler. (Starte Windows neu, um das EasyAntiCheat-Update durchzuführen)";
	error_another_launcher = "Unerwarteter Fehler. (Ein anderer Launcher wird derzeit ausgeführt)";
	error_game_running = "Unerwarteter Fehler. (Spiel wird bereits ausgeführt)";
	error_patched_boot_loader = "Gepatchtes Windows-Startladeprogramm erkannt. (Kernel-Patch-Schutz deaktiviert)";
	error_unknown_process = "Game-Client nicht erkannt Fortfahren nicht möglich.";
	error_unknown_game = "Nicht konfiguriertes Spiel. Fortfahren nicht möglich.";
	error_windows_vista_sp = "Installiere das Windows Vista Servicepaket 2, um Easy Anti-Cheat zu verwenden.";
	error_windows_xp = "Du benötigst Windows XP oder höher.";
	error_windows_xp_64 = "Die Windows XP 64-bit Edition wird nicht unterstützt.";
	error_windows_xp_sp = "Installiere das Windows XP Servicepaket 3, um Easy Anti-Cheat zu verwenden.";
	success_initialized = "Easy Anti-Cheat erfolgreich gestartet";
	success_loaded = "Easy Anti-Cheat erfolgreich im Spiel geladen";
};
setup:
{
	btn_finish = "Beenden";
	btn_install = "Jetzt installieren";
	btn_repair = "Dienst reparieren";
	btn_uninstall = "Deinstallieren";
	epic_link = "© Epic Games, Inc";
	error_prefix = "Fehler:";
	install_progress = "Installiert …";
	install_success = "Erfolgreich installiert";
	licenses_link = "Lizenzen";
	privacy_link = "Datenschutz";
	repair_progress = "Repariert ...";
	title = "Easy Anti-Cheat Service-Einrichtung";
	uninstall_progress = "Deinstalliert …";
	uninstall_success = "Erfolgreich deinstalliert";
};
setup_error:
{
	error_cancelled = "Vorgang vom Benutzer abgebrochen";
	error_encrypted = "Der Easy Anti-Cheat-Installationsordner wurde verschlüsselt";
	error_intro = "Easy Anti-Cheat-Einrichtung fehlgeschlagen";
	error_not_installed = "Easy Anti-Cheat ist nicht installiert.";
	error_registry = "Kopieren der ausführbaren Dienstdatei fehlgeschlagen";
	error_rights = "Rechte nicht ausreichend";
	error_service = "Service kann nicht erstellt werden";
	error_system = "Zugriff auf System32 verweigert";
};
```

`eac/dist/EasyAntiCheat/Localization/en_us.cfg`:

```cfg
#----------------------------------------------------------
# Easy Anti-Cheat Localization File
#
# This file must use UTF-8 encoding.
#
# Each localization file should be named ll_CC.cfg where
# ll = ISO-639 code for language (e.g. "en")
# CC = ISO-3166 code for country (e.g. "US")
#----------------------------------------------------------

bugreport:
{
	btn_continue = "Go online for a solution and close the game.";
	btn_exit = "Close the game.";
	btn_hidedetails = "Hide details";
	btn_showdetails = "Show details";
	chk_sendreport = "Send error report";
	error_code = "Error Code:";
	lbl_body1 = "We're sorry, we had a problem starting your game";
	lbl_body2 = "Please help us by reporting this issue.";
	lbl_body3 = "Easy Anti-Cheat can check online for a solution for the problem and try to help in resolving it.";
	lbl_header = "Couldn't start the game";
	title = "Launch Error";
};
game_error:
{
	error_catalogue_file = "EAC index access error";
	error_catalogue_not_found = "Easy Anti-Cheat Hash Catalogue not found";
	error_certificate_revoked = "EAC index certificate revoked";
	error_corrupted_memory = "Corrupted memory";
	error_corrupted_network = "Corrupted packet flow";
	error_file_forbidden = "Unknown game file";
	error_file_not_found = "Missing required file";
	error_file_version = "Unknown file version";
	error_module_forbidden = "Forbidden module";
	error_system_configuration = "Forbidden system configuration";
	error_system_version = "Untrusted system file";
	error_tool_forbidden = "Forbidden tool";
	error_violation = "Internal anti-cheat error";
	error_virtual = "Cannot run under Virtual Machine.";
	peer_client_banned = "Anti-cheat peer banned.";
	peer_heartbeat_rejected = "Anti-cheat peer rejected.";
	peer_validated = "Anti-cheat peer validation completed.";
	peer_validation_failed = "Anti-cheat peer validation failed.";
	executable_not_hashed = "Could not locate game executable entry in the catalogue.";
};
launcher:
{
	btn_cancel = "Cancel";
	btn_exit = "Exit";
	error_cancel = "Launch Canceled";
	error_filenotfound = "File Not Found";
	error_init = "Initialization Error";
	error_install = "Install Error";
	error_launch = "Launch Error";
	error_nolib = "Could not load Easy Anti-Cheat library";
	loading = "LOADING";
	initializing = "INITIALIZING";
	wait = "Please wait";
	success_waiting_for_game = "WAITING FOR GAME";
	success_closing = "Success";
	network_error = "Network error";
	error_no_settings_file = "{0} not found";
	error_invalid_settings_format = "{0} does not have a valid JSON format";
	error_missing_required_field = "{0} is missing a required field ({1})";
	initializing = "INITIALIZING";
	success_waiting_for_game = "WAITING FOR GAME";
	success_closing = "Success";
	network_error = "Network error";
	error_no_settings_file = "{0} not found";
	download_progress = "Download Progress: {0}";
};
launcher_error:
{
	error_already_running = "An application using Easy Anti-Cheat is already running!";
	error_application = "Game client encountered an application error.";
	error_bad_exe_format = "64-bit OS required";
	error_bitset_32 = "Please use the 32-bit version of the game";
	error_bitset_64 = "Please use the 64-bit version of the game";
	error_cancelled = "Operation cancelled by user";
	error_certificate_validation = "Error validating Easy Anti-Cheat code signing certificate";
	error_client_auth_failed = "The game client has failed the anti-cheat authentication and may not have the anti-cheat protection activated.";
	error_client_banned = "The game account has been banned from all online game features.";
	error_client_disconnected = "The game client is not running the anti-cheat.";
	error_client_violation = "The game client failed an anti-cheat runtime integrity check.";
	error_connection = "Connecting to the Content Distribution Network failed!";
	error_debugger = "Debugger has been detected. Please unload it and try again";
	error_disk_space = "Insufficient disk space.";
	error_dns = "DNS resolve to the Content Distribution Network failed!";
	error_dotlocal = "DotLocal DLL redirection detected.";
	error_dotlocal_instructions = "Please delete the following file";
	error_file_not_found = "File not found:";
	error_forbidden_tool = "Please close {0} before starting the game";
	error_forbidden_driver = "Please unload {0} before starting the game";
	error_generic = "Unexpected error.";
	error_kernel_debug = "Easy Anti-Cheat cannot run if Kernel Debugging is enabled";
	error_kernel_dse = "Easy Anti-Cheat cannot run if Driver Signature Enforcement has been disabled";
	error_kernel_modified = "Forbidden Windows kernel modification detected";
	error_library_load = "Could not load Easy Anti-Cheat library";
	error_memory = "Insufficient memory to start the game";
	error_module_load = "Failed to load the anti-cheat module";
	error_patched = "Patched Windows boot loader detected";
	error_process = "Cannot create process";
	error_process_crash = "The process terminated abruptly";
	error_safe_mode = "Easy Anti-Cheat cannot run under Windows Safe Mode";
	error_socket = "Something is blocking the application from accessing Internet!";
	error_ssl = "Error establishing SSL connection with the CDN service!";
	error_start = "Failed to start the game";
	error_uncpath_forbidden = "Cannot run the game through a network share. (UNC path)";
	error_missing_path = "Missing game executable path.";
	error_incompatible_driver_version = "An incompatible Easy Anti-Cheat driver version is already running. Please exit other running games or reboot";
	error_incompatible_service = "An incompatible Easy Anti-Cheat service is already running. Please exit other running games or reboot";
	error_invalid_executable = "Invalid game executable: ";
	error_connection_failed = "Connection failed: ";
	error_module_not_found = "Anti-Cheat module not found!";
	error_missing_game_id = "Missing game id!";
	error_dns_resolve_failed = "DNS resolve to proxy failed!";
	error_dns_connection_failed = "Connection to the Content Distribution Network failed! Curl Code: {0}!";
	error_http_response = "HTTP Response Code: {0} Curl Code: {1}";
	error_driver_handle = "Unexpected error. (Failed to open driver handle)";
	error_another_launcher = "Unexpected error. (Another launcher is already running)";
	error_game_running = "Unexpected error. (Game already running)";
	error_patched_boot_loader = "Patched Windows boot loader detected. (Kernel Patch Protection disabled)";
	error_disallowed_cdn_path = "Unexpected error. (Incorrect CDN url)";
	error_unknown_process = "Unrecognized game client. Cannot continue.";
	error_unknown_game = "Unconfigured game. Cannot continue.";
	error_windows_vista_sp = "Install Windows Vista Service Pack 2 to run Easy Anti-Cheat.";
	error_windows_xp = "Windows XP or later is required.";
	error_windows_xp_64 = "Windows XP 64-bit Edition is not supported.";
	error_windows_xp_sp = "Install Windows XP Service Pack 3 to run Easy Anti-Cheat.";
	error_x8664_required = "Unsupported OS. 64-bit (x86-64) version of Windows is required.";
	success_initialized = "Easy Anti-Cheat successfully initialized";
	success_loaded = "Easy Anti-Cheat successfully loaded in-game";
	warn_module_download_size = "HTTP Response Size: {0}. Starting in null client mode.";
	warn_win7_update_required = "Please run Windows updates, your system is lacking critical SHA-2 code signing support required by October 2020. See https://support.microsoft.com/help/4474419/sha-2-code-signing-support-update";
	warn_vista_deprecation = "Easy Anti-Cheat must end support for Windows Vista in October 2020 because compatible code signatures can no longer be created. See https://support.microsoft.com/help/4472027/2019-sha-2-code-signing-support-requirement-for-windows-and-wsus";
};
setup:
{
	btn_finish = "Finish";
	btn_install = "Install Easy Anti-Cheat";
	btn_repair = "Repair Service";
	btn_uninstall = "Uninstall";
	epic_link = "© Epic Games, Inc";
	error_prefix = "Error:";
	install_progress = "Installing…";
	install_success = "Installed Successfully";
	licenses_link = "Licenses";
	privacy_link = "Privacy";
	repair_progress = "Repairing…";
	title = "Easy Anti-Cheat Service Setup";
	uninstall_progress = "Uninstalling…";
	uninstall_success = "Uninstalled Successfully";
};
setup_error:
{
	error_cancelled = "Operation cancelled by user";
	error_encrypted = "Easy Anti-Cheat installation folder has been encrypted";
	error_intro = "Easy Anti-Cheat Setup Failed";
	error_not_installed = "Easy Anti-Cheat is not installed.";
	error_registry = "Access to registry denied";
	error_rights = "Insufficient privileges";
	error_service = "Cannot create service";
	error_system = "Access to System32 denied";
};
```

`eac/dist/EasyAntiCheat/Localization/es_ar.cfg`:

```cfg
#----------------------------------------------------------
# Easy Anti-Cheat Localization File
#
# This file must use UTF-8 encoding.
#
# Each localization file should be named ll_CC.cfg where
# ll = ISO-639 code for language (e.g. "en")
# CC = ISO-3166 code for country (e.g. "US")
#----------------------------------------------------------

bugreport:
{
	btn_continue = "Conéctate a Internet para buscar una solución y cierra el juego.";
	btn_exit = "Cerrar el juego.";
	btn_hidedetails = "Ocultar detalles";
	btn_showdetails = "Mostrar detalles";
	chk_sendreport = "Enviar informe de errores";
	error_code = "Código de error:";
	lbl_body1 = "Lo sentimos, se ha producido un problema al iniciar tu juego";
	lbl_body2 = "Ayúdanos enviándonos un informe del problema.";
	lbl_body3 = "Easy Anti-Cheat puede buscar una solución al problema en Internet para intentar resolverlo.";
	lbl_header = "No se puede iniciar el juego";
	title = "Error al iniciar";
};
game_error:
{
	error_catalogue_file = "Error al acceder al índice EAC";
	error_catalogue_not_found = "Índice EAC no encontrado";
	error_certificate_revoked = "Se ha revocado el certificado del catálogo de EAC";
	error_corrupted_memory = "Memoria dañada";
	error_corrupted_network = "Flujo de paquetes dañado";
	error_file_forbidden = "Archivo de juego desconocido";
	error_file_not_found = "Falta un archivo necesario";
	error_file_version = "Versión de archivo desconocida";
	error_module_forbidden = "Módulo prohibido";
	error_system_configuration = "Configuración del sistema prohibida";
	error_system_version = "Archivo de sistema no confiable";
	error_tool_forbidden = "Herramienta prohibida";
	error_violation = "Error interno antitrampas";
	error_virtual = "No puede ejecutarse en máquinas virtuales.";
	peer_client_banned = "Par antitrampas vetado.";
	peer_heartbeat_rejected = "Par antitrampas rechazado.";
	peer_validated = "Validación par antitrampas completada.";
	peer_validation_failed = "Error en la validación par antitrampas.";
	executable_not_hashed = "No se pudo encontrar el ejecutable del juego en el catálogo.";
};
launcher:
{
	btn_cancel = "Cancelar";
	btn_exit = "Salir";
	error_cancel = "Iniciación cancelada";
	error_filenotfound = "Archivo no encontrado";
	error_init = "Error al iniciar";
	error_install = "Error al instalar";
	error_launch = "Error al iniciar";
	error_nolib = "No se pudo cargar la biblioteca de Easy Anti-Cheat";
	loading = "CARGANDO";
	wait = "Espera, por favor";
	initializing = "INICIALIZANDO";
	success_waiting_for_game = "ESPERANDO AL JUEGO";
	success_closing = "¡Listo!";
	network_error = "Error de red";
	error_no_settings_file = "{0} no encontrado";
	error_invalid_settings_format = "{0} no tiene un formato JSON válido";
	error_missing_required_field = "{0} no tiene un campo requerido ({1})";
	download_progress = "Progreso de la descarga: {0}";
};
launcher_error:
{
	error_already_running = "¡Ya está en ejecución una aplicación que usa Easy Anti-Cheat!";
	error_application = "El cliente del juego ha encontrado un error en la aplicación.";
	error_bad_exe_format = "Se requiere un sistema operativo de 64 bits";
	error_bitset_32 = "Por favor, usa la versión 32-bit del juego";
	error_bitset_64 = "Por favor, usa la versión 64-bit del juego";
	error_cancelled = "Operación cancelada por el usuario";
	error_certificate_validation = "Error al validar el certificado de firmas del código de Easy Anti-Cheat";
	error_client_auth_failed = "El cliente del juego no ha superado una autenticación antitrampas y podría no tener protección antitrampas activada.";
	error_client_banned = "La cuenta del juego ha sido vetada de todas las funciones del juego en línea.";
	error_client_disconnected = "El cliente de juego no está ejecutando el antitrampas.";
	error_client_violation = "El cliente del juego no aprobó una verificación de integridad de tiempo de ejecución de antitrampas.";
	error_connection = "¡Ha fallado la conexión a la red de distribución de contenido!";
	error_debugger = "Se ha detectado un programa de depuración. Por favor, desactívalo y vuelve a intentarlo.";
	error_disk_space = "Espacio en disco insuficiente.";
	error_dns = "¡Ha fallado la resolución DNS para la red de distribución de contenidos!";
	error_dotlocal = "Se ha detectado una redirección DotLocal DLL.";
	error_dotlocal_instructions = "Por favor, borra el siguiente archivo";
	error_file_not_found = "Archivo no encontrado:";
	error_forbidden_tool = "Cierra {0} antes de iniciar el juego";
	error_forbidden_driver = "Descarga {0} antes de empezar el juego";
	error_generic = "Error inesperado.";
	error_kernel_debug = "Easy Anti-Cheat no se puede ejecutar si la depuración del kernel está activa";
	error_kernel_dse = "Easy Anti-Cheat no se podrá ejecutar si se ha deshabilitado el uso obligatorio de controladores firmados";
	error_kernel_modified = "Se ha detectado una modificación prohibida del kernel de Windows";
	error_library_load = "No se pudo cargar la biblioteca de Easy Anti-Cheat";
	error_memory = "Memoria insuficiente para iniciar partida";
	error_module_load = "No pudo cargarse el módulo antitrampas";
	error_patched = "Se ha detectado un gestor de arranque de Windows con parches";
	error_process = "No se puede crear el proceso";
	error_process_crash = "El proceso se ha detenido abruptamente";
	error_safe_mode = "Easy Anti-Cheat no se puede ejecutar con el modo seguro de Windows";
	error_socket = "¡Algo está impidiendo que la aplicación acceda a Internet!";
	error_ssl = "¡Se ha producido un error al establecer una conexión SSL con el servicio CDN!";
	error_start = "No se ha podido iniciar el juego";
	error_uncpath_forbidden = "No se puede ejecutar el juego a través de recursos compartidos de red. (ruta UNC).";
	error_missing_path = "No se encuentra la ruta del ejecutable del juego";
	error_invalid_executable = "El ejecutable del juego no es válido: ";
	error_connection_failed = "Hubo un error de conexión: ";
	error_module_not_found = "No se encontró el módulo Anti-Cheat";
	error_missing_game_id = "No se encuentra el id del juego";
	error_dns_resolve_failed = "Hubo un error en la resolución del DNS a través del proxy";
	error_dns_connection_failed = "¡Hubo un problema de conexión a la red de distribución de contenidos! Código curl: {0}!";
	error_http_response = "Código de respuesta HTTP: {0} Código curl: {1}";
	error_driver_handle = "Error inesperado. (Error al abrir el puntero del controlador)";
	error_incompatible_service = "Ya se está ejecutando un servicio incompatible de Easy Anti-Cheat. Cierra los otros juegos que estén en funcionamiento o reinicia el sistema.";
	error_incompatible_driver_version = "Ya se está ejecutando una versión incompatible del controlador Easy Anti-Cheat. Cierra los otros juegos que estén en funcionamiento o reinicia el sistema.";
	error_restart_windows = "Error inesperado. (Reinicia Windows para completar la actualización de EasyAntiCheat)";
	error_another_launcher = "Error inesperado. (Otro iniciador está ejecutándose en este momento)";
	error_game_running = "Error inesperado (El juego está ejecutándose en este momento)";
	error_patched_boot_loader = "Se detectó un gestor de arranque de Windows parchado. (La protección contra revisiones del núcleo está desactivada)";
	error_unknown_process = "Cliente de juego no reconocido. Imposible continuar.";
	error_unknown_game = "Juego no configurado. No se puede continuar.";
	error_windows_vista_sp = "Instala el Service Pack 2 de Windows Vista para ejecutar Easy Anti-Cheat.";
	error_windows_xp = "Es necesario Windows XP o superior.";
	error_windows_xp_64 = "No es compatible con la edición de 64-bit de Windows.";
	error_windows_xp_sp = "Instala el Service Pack 3 de Windows XP para ejecutar Easy Anti-Cheat.";
	success_initialized = "Se ha iniciado con éxito Easy Anti-Cheat";
	success_loaded = "Se ha cargado con éxito Easy Anti-Cheat en el juego";
};
setup:
{
	btn_finish = "Finalizar";
	btn_install = "Instalar ahora";
	btn_repair = "Servicio de reparación";
	btn_uninstall = "Desinstalar";
	epic_link = "© Epic Games, Inc";
	error_prefix = "Error:";
	install_progress = "Instalando...";
	install_success = "Se ha instalado con éxito";
	licenses_link = "Licencias";
	privacy_link = "Privacidad";
	repair_progress = "Reparando...";
	title = "Configuración del servicio Easy Anti-Cheat";
	uninstall_progress = "Desinstalando...";
	uninstall_success = "Se ha desinstalado con éxito";
};
setup_error:
{
	error_cancelled = "Operación cancelada por el usuario";
	error_encrypted = "La carpeta de instalación de Easy Anti-Cheat se ha encriptado";
	error_intro = "Error en la configuración de Easy Anti-Cheat";
	error_not_installed = "Easy Anti-Cheat no está instalado.";
	error_registry = "Acceso denegado al registro";
	error_rights = "Privilegios insuficientes";
	error_service = "No se puede crear el servicio";
	error_system = "Acceso denegado a System32";
};
```

`eac/dist/EasyAntiCheat/Localization/es_es.cfg`:

```cfg
#----------------------------------------------------------
# Easy Anti-Cheat Localization File
#
# This file must use UTF-8 encoding.
#
# Each localization file should be named ll_CC.cfg where
# ll = ISO-639 code for language (e.g. "en")
# CC = ISO-3166 code for country (e.g. "US")
#----------------------------------------------------------

bugreport:
{
	btn_continue = "Conéctate a Internet para buscar una solución y cerrar el juego.";
	btn_exit = "Cerrar el juego.";
	btn_hidedetails = "Ocultar detalles";
	btn_showdetails = "Mostrar detalles";
	chk_sendreport = "Enviar informe de errores";
	error_code = "Código de error:";
	lbl_body1 = "Lo sentimos, se ha producido un problema al iniciar la partida.";
	lbl_body2 = "Ayúdanos enviándonos un informe del problema.";
	lbl_body3 = "Easy Anti-Cheat puede buscar una solución al problema en Internet para intentar resolverlo.";
	lbl_header = "No se puede iniciar la partida";
	title = "Error al iniciar";
};
game_error:
{
	error_catalogue_file = "Error al acceder al catálogo de EAC";
	error_catalogue_not_found = "No se ha encontrado el catálogo de EAC";
	error_certificate_revoked = "Se ha revocado el certificado del catálogo de EAC";
	error_corrupted_memory = "Memoria dañada";
	error_corrupted_network = "Flujo de paquetes dañado";
	error_file_forbidden = "Archivo de juego desconocido";
	error_file_not_found = "Falta un archivo necesario";
	error_file_version = "Versión de archivo desconocida";
	error_module_forbidden = "Módulo prohibido";
	error_system_configuration = "Configuración del sistema prohibida";
	error_system_version = "Archivo de sistema inseguro";
	error_tool_forbidden = "Herramienta prohibida";
	error_violation = "Error interno antitrampas";
	error_virtual = "No se puede ejecutar en máquinas virtuales.";
	peer_client_banned = "La validación antitrampas ha sido bloqueada.";
	peer_heartbeat_rejected = "La validación antitrampas ha sido rechazada.";
	peer_validated = "Se ha completado la validación antitrampas.";
	peer_validation_failed = "La validación antitrampas ha fallado.";
	executable_not_hashed = "No se ha podido localizar la entrada del ejecutable del juego en el catálogo.";
};
launcher:
{
	btn_cancel = "Cancelar";
	btn_exit = "Salir";
	error_cancel = "Se ha cancelado el inicio";
	error_filenotfound = "Archivo no encontrado";
	error_init = "Error al iniciar";
	error_install = "Error al instalar";
	error_launch = "Error al iniciar";
	error_nolib = "No se pudo cargar la biblioteca de Easy Anti-Cheat";
	loading = "CARGANDO";
	wait = "Espera";
	initializing = "INICIALIZANDO";
	success_waiting_for_game = "ESPERANDO AL JUEGO";
	success_closing = "Todo ha ido bien";
	network_error = "Error de red";
	error_no_settings_file = "{0} no se ha encontrado";
	error_invalid_settings_format = "{0} no tiene un formato JSON válido";
	error_missing_required_field = "A {0} le falta un campo obligatorio ({1})";
	download_progress = "Progreso de la descarga: {0}";
};
launcher_error:
{
	error_already_running = "¡Ya está en ejecución una aplicación que usa Easy Anti-Cheat!";
	error_application = "El cliente del juego ha encontrado un error en la aplicación.";
	error_bad_exe_format = "Se necesita sistema operativo de 64 bits";
	error_bitset_32 = "Tienes que usar la versión 32-bit del juego";
	error_bitset_64 = "Tienes que usar la versión 64-bit del juego";
	error_cancelled = "Operación cancelada por el usuario";
	error_certificate_validation = "Error al validar el certificado de firmas del código de Easy Anti-Cheat";
	error_client_auth_failed = "El cliente del juego no ha superado la identificación antitrampas y podría no tener activa la protección antitrampas.";
	error_client_banned = "La cuenta del juego ha sido bloqueada de todas las opciones de juego online.";
	error_client_disconnected = "El cliente del juego no está ejecutando el sistema antitrampas.";
	error_client_violation = "El cliente del juego no ha podido realizar una comprobación de integridad antitrampas.";
	error_connection = "¡Ha fallado la conexión a la red de distribución de contenido!";
	error_debugger = "Se ha detectado un programa de depuración. Desactívalo y vuelve a intentarlo.";
	error_disk_space = "Espacio insuficiente en el disco.";
	error_dns = "¡Ha fallado la resolución DNS para la red de distribución de contenidos!";
	error_dotlocal = "Se ha detectado una redirección DotLocal DLL.";
	error_dotlocal_instructions = "Borra el siguiente archivo";
	error_file_not_found = "Archivo no encontrado:";
	error_forbidden_tool = "Cierra {0} antes de iniciar el juego";
	error_forbidden_driver = "Descarga {0} antes de iniciar el juego";
	error_generic = "Error inesperado.";
	error_kernel_debug = "Easy Anti-Cheat no se puede ejecutar si la depuración del kernel está activa";
	error_kernel_dse = "Easy Anti-Cheat no se podrá ejecutar si se ha deshabilitado el uso obligatorio de controladores firmados";
	error_kernel_modified = "Se ha detectado una modificación prohibida del kernel de Windows";
	error_library_load = "No se pudo cargar la biblioteca de Easy Anti-Cheat";
	error_memory = "Memoria insuficiente para iniciar partida";
	error_module_load = "No se ha podido cargar el módulo antitrampas";
	error_patched = "Se ha detectado un iniciador de Windows parcheado";
	error_process = "No se puede crear el proceso";
	error_process_crash = "El proceso se ha detenido abruptamente";
	error_safe_mode = "Easy Anti-Cheat no se puede ejecutar con el modo seguro de Windows";
	error_socket = "¡Algo está impidiendo que la aplicación acceda a Internet!";
	error_ssl = "¡Se ha producido un error al establecer una conexión SSL con el servicio CDN!";
	error_start = "No se ha podido iniciar la partida";
	error_uncpath_forbidden = "Imposible ejecutar el juego a través de un recurso compartido de red. (ruta de acceso UNC).";
	error_missing_path = "No se encuentra la ruta del ejecutable del juego";
	error_invalid_executable = "El ejecutable del juego no es válido: ";
	error_connection_failed = "Error de conexión: ";
	error_module_not_found = "Módulo Anti-Cheat no encontrado";
	error_missing_game_id = "ID del juego no encontrada";
	error_dns_resolve_failed = "Error en la resolución del DNS a través del proxy";
	error_dns_connection_failed = "¡Error en la conexión a la red de distribución de contenidos! Código Curl: {0}!";
	error_http_response = "Código de respuesta HTTP: {0} Código Curl: {1}";
	error_driver_handle = "Error inesperado. (Error al abrir el administrador de controladores)";
	error_incompatible_service = "Ya se está ejecutando un servicio incompatible de Easy Anti-Cheat. Cierra los otros juegos que estés ejecutando o reinicia el equipo.";
	error_incompatible_driver_version = "Ya se está ejecutando una versión del controlador Easy Anti-Cheat que resulta incompatible. Cierra los otros juegos que estés ejecutando o reinicia el equipo.";
	error_restart_windows = "Error inesperado. (Reinicia Windows para completar la actualización de EasyAntiCheat)";
	error_another_launcher = "Error inesperado. (Se está ejecutando otro iniciador)";
	error_game_running = "Error inesperado. (El juego ya se está ejecutando)";
	error_patched_boot_loader = "Se ha detectado un iniciador de Windows modificado. (Se ha desactivado la protección contra revisiones del núcleo)";
	error_unknown_process = "Cliente de juego no reconocido. No se puede continuar.";
	error_unknown_game = "Juego sin configurar. No se puede continuar.";
	error_windows_vista_sp = "Instala el Service Pack 2 de Windows Vista para ejecutar Easy Anti-Cheat.";
	error_windows_xp = "Se necesita Windows XP o posteriores.";
	error_windows_xp_64 = "No compatible con la versión 64-bit de Windows.";
	error_windows_xp_sp = "Instala el Service Pack 3 de Windows XP para ejecutar Easy Anti-Cheat.";
	success_initialized = "Se ha iniciado con éxito Easy Anti-Cheat";
	success_loaded = "Se ha cargado con éxito Easy Anti-Cheat en el juego";
};
setup:
{
	btn_finish = "Acabar";
	btn_install = "Instalar ahora";
	btn_repair = "Servicio de reparaciones";
	btn_uninstall = "Desinstalar";
	epic_link = "© Epic Games, Inc";
	error_prefix = "Error:";
	install_progress = "Instalando...";
	install_success = "Se ha instalado con éxito";
	licenses_link = "Licencias";
	privacy_link = "Privacidad";
	repair_progress = "Reparando...";
	title = "Instalación del servicio Easy Anti-Cheat";
	uninstall_progress = "Desinstalando...";
	uninstall_success = "Se ha desinstalado con éxito";
};
setup_error:
{
	error_cancelled = "Operación cancelada por el usuario";
	error_encrypted = "Se ha encriptado la carpeta de instalación de Easy Anti-Cheat";
	error_intro = "Ha fallado la configuración de Easy Anti-Cheat";
	error_not_installed = "Easy Anti-Cheat no está instalado.";
	error_registry = "Fallo al copiar el ejecutable del servicio";
	error_rights = "Privilegios insuficientes";
	error_service = "No se puede crear el servicio";
	error_system = "Se ha denegado el acceso a System32";
};
```

`eac/dist/EasyAntiCheat/Localization/fr_fr.cfg`:

```cfg
#----------------------------------------------------------
# Easy Anti-Cheat Localization File
#
# This file must use UTF-8 encoding.
#
# Each localization file should be named ll_CC.cfg where
# ll = ISO-639 code for language (e.g. "en")
# CC = ISO-3166 code for country (e.g. "US")
#----------------------------------------------------------

bugreport:
{
	btn_continue = "Chercher une solution en ligne et quitter le jeu.";
	btn_exit = "Quitter le jeu.";
	btn_hidedetails = "Masquer les détails";
	btn_showdetails = "Afficher les détails";
	chk_sendreport = "Envoyer le rapport d'erreur";
	error_code = "Code d'erreur :";
	lbl_body1 = "Nous sommes désolés, un problème est survenu lors du démarrage de votre partie";
	lbl_body2 = "Veuillez nous aider en signalant ce problème.";
	lbl_body3 = "Easy Anti-Cheat peut chercher une solution au problème en ligne et tenter de vous aider à le résoudre.";
	lbl_header = "Impossible de démarrer la partie";
	title = "Erreur de lancement";
};
game_error:
{
	error_catalogue_file = "Erreur d'accès à l'index EAC";
	error_catalogue_not_found = "Index EAC introuvable";
	error_certificate_revoked = "Certificat de l'index EAC révoqué";
	error_corrupted_memory = "Mémoire corrompue";
	error_corrupted_network = "Flux de paquets corrompu";
	error_file_forbidden = "Fichier de jeu inconnu";
	error_file_not_found = "Fichier requis manquant";
	error_file_version = "Version de fichier inconnue";
	error_module_forbidden = "Module non-autorisé";
	error_system_configuration = "Configuration de système non-autorisée";
	error_system_version = "Fichier système non-fiable";
	error_tool_forbidden = "Outil non-autorisé";
	error_violation = "Erreur anti-triche interne";
	error_virtual = "Exécution impossible sur une machine virtuelle.";
	peer_client_banned = "Joueur bloqué par le processus anti-triche.";
	peer_heartbeat_rejected = "Joueur rejeté par le processus anti-triche.";
	peer_validated = "Validation anti-triche du joueur terminée.";
	peer_validation_failed = "Validation anti-triche du joueur échouée.";
	executable_not_hashed = "Impossible de localiser l'entrée exécutable du jeu dans le catalogue.";
};
launcher:
{
	btn_cancel = "Annuler";
	btn_exit = "Quitter";
	error_cancel = "Lancement annulé";
	error_filenotfound = "Fichier introuvable";
	error_init = "Erreur d'initialisation";
	error_install = "Erreur d'installation";
	error_launch = "Erreur de lancement";
	error_nolib = "Chargement de la bibliothèque Easy Anti-Cheat impossible";
	loading = "CHARGEMENT";
	wait = "Veuillez patienter";
	initializing = "INITIALISATION";
	success_waiting_for_game = "EN ATTENTE DU JEU";
	success_closing = "Opération réussie";
	network_error = "Erreur réseau";
	error_no_settings_file = "{0} introuvable";
	error_invalid_settings_format = "{0} n'a pas de format JSON valide";
	error_missing_required_field = "Champ obligatoire manquant pour {0} ({1})";
	download_progress = "Progression du téléchargement : {0}";
};
launcher_error:
{
	error_already_running = "Une application utilisant Easy Anti-Cheat est déjà en cours d'exécution !";
	error_application = "Une erreur d'application s'est produite dans le client du jeu.";
	error_bad_exe_format = "Système d'exploitation 64 bits requis";
	error_bitset_32 = "Veuillez utiliser la version 32-bit du jeu";
	error_bitset_64 = "Veuillez utiliser la version 64-bit du jeu";
	error_cancelled = "Opération annulée par l'utilisateur";
	error_certificate_validation = "Erreur lors de la validation du certificat de signature de code Easy Anti-Cheat";
	error_client_auth_failed = "Le client du jeu a échoué l'authentification anti-triche et peut ne pas avoir activé la protection anti-triche.";
	error_client_banned = "Le compte a été bloqué pour toutes les fonctionnalités de jeu en ligne.";
	error_client_disconnected = "Le client du jeu n'exécute pas le programme anti-triche.";
	error_client_violation = "Le client du jeu a échoué une vérification anti-triche portant sur l'intégrité de l'exécution.";
	error_connection = "Échec de la connexion au réseau de distribution de contenu !";
	error_debugger = "Un débogueur a été détecté. Veuillez le désinstaller et réessayer.";
	error_disk_space = "Espace disque insuffisant.";
	error_dns = "Échec de résolution de DNS sur le réseau de distribution de contenu !";
	error_dotlocal = "Redirection DotLocal DLL détectée.";
	error_dotlocal_instructions = "Veuillez supprimer le fichier suivant";
	error_file_not_found = "Fichier introuvable :";
	error_forbidden_tool = "Veuillez fermer {0} avant de démarrer le jeu";
	error_forbidden_driver = "Veuillez décharger {0} avant de démarrer le jeu";
	error_generic = "Erreur inattendue.";
	error_kernel_debug = "Easy Anti-Cheat ne peut pas s'exécuter si Kernel Debugging est activé";
	error_kernel_dse = "Easy Anti-Cheat ne peut pas s'exécuter si Driver Signature Enforcement a été désactivé.";
	error_kernel_modified = "Modification Windows Kernel non-autorisée détectée";
	error_library_load = "Chargement de la bibliothèque Easy Anti-Cheat impossible";
	error_memory = "Mémoire insuffisante pour démarrer le jeu";
	error_module_load = "Échec du chargement du module anti-triche";
	error_patched = "Chargeur de démarrage patché détecté";
	error_process = "Création du processus impossible";
	error_process_crash = "Le processus s'est terminé abruptement";
	error_safe_mode = "Easy Anti-Cheat ne peut pas s'exécuter dans le mode sans échec de Windows";
	error_socket = "Quelque chose empêche l'application d'accéder à Internet !";
	error_ssl = "Erreur d'établissement de connexion SSL avec le service CDN !";
	error_start = "Échec du démarrage du jeu";
	error_uncpath_forbidden = "Impossible d'exécuter le jeu via un partage réseau. (chemin d'accès UNC)";
	error_missing_path = "Chemin d'accès de l'exécutable du jeu manquant";
	error_invalid_executable = "Exécutable du jeu non valide: ";
	error_connection_failed = "Échec de la connexion: ";
	error_module_not_found = "Module Anti-Cheat introuvable";
	error_missing_game_id = "L'identifiant du jeu est manquant";
	error_dns_resolve_failed = "La résolution DNS au proxy a échoué";
	error_dns_connection_failed = "La connexion au réseau de distribution du contenu a échoué ! Code cURL : {0} !";
	error_http_response = "Code de réponse HTTP : {0} Code cURL : {1}";
	error_driver_handle = "Erreur inattendue. (L'ouverture de l'identificateur du pilote a échoué)";
	error_incompatible_service = "Une version incompatible du service Easy Anti-Cheat est en cours d'exécution. Quittez les autres jeux en cours ou redémarrez.";
	error_incompatible_driver_version = "Une version incompatible du pilote Easy Anti-Cheat est en cours d'exécution. Quittez les autres jeux en cours ou redémarrez";
	error_restart_windows = "Erreur inattendue. (Redémarrez Windows pour terminer la mise à jour EasyAntiCheat)";
	error_another_launcher = "Erreur inattendue. (Un autre lanceur est déjà en cours d’exécution)";
	error_game_running = "Erreur inattendue. (Un jeu est déjà en cours d’exécution)";
	error_patched_boot_loader = "Chargeur de démarrage Windows corrigé détecté. (La fonctionnalité Kernel Patch Protection est désactivée)";
	error_unknown_process = "Client de jeu non reconnu. Impossible de continuer.";
	error_unknown_game = "Jeu non configuré. Impossible de continuer.";
	error_windows_vista_sp = "Installez Windows Vista Service Pack 2 pour exécuter Easy Anti-Cheat.";
	error_windows_xp = "Windows XP ou SE plus récent requis.";
	error_windows_xp_64 = "Windows XP 64-bit Edition n'est pas pris en charge.";
	error_windows_xp_sp = "Installez Windows XP Service Pack 3 pour exécuter Easy Anti-Cheat.";
	success_initialized = "Easy Anti-Cheat initialisé avec succès";
	success_loaded = "Easy Anti-Cheat chargé dans le jeu avec succès";
};
setup:
{
	btn_finish = "Terminer";
	btn_install = "Installer maintenant";
	btn_repair = "Service de réparation";
	btn_uninstall = "Désinstaller";
	epic_link = "© Epic Games, Inc";
	error_prefix = "Erreur :";
	install_progress = "Installation en cours...";
	install_success = "Installation réussie";
	licenses_link = "Licences";
	privacy_link = "Confidentialité";
	repair_progress = "Réparation en cours...";
	title = "Configuration du service Easy Anti-Cheat";
	uninstall_progress = "Désinstallation en cours...";
	uninstall_success = "Désinstallation réussie";
};
setup_error:
{
	error_cancelled = "Opération annulée par l'utilisateur";
	error_encrypted = "Le dossier d'installation Easy Anti-Cheat a été chiffré";
	error_intro = "Échec de la configuration d'Easy Anti-Cheat";
	error_not_installed = "Easy Anti-Cheat n'est pas installé.";
	error_registry = "Échec de la copie du fichier exécutable du service";
	error_rights = "Privilèges insuffisants";
	error_service = "Création du service impossible";
	error_system = "Accès à System32 refusé";
};
```

`eac/dist/EasyAntiCheat/Localization/it_it.cfg`:

```cfg
#----------------------------------------------------------
# Easy Anti-Cheat Localization File
#
# This file must use UTF-8 encoding.
#
# Each localization file should be named ll_CC.cfg where
# ll = ISO-639 code for language (e.g. "en")
# CC = ISO-3166 code for country (e.g. "US")
#----------------------------------------------------------

bugreport:
{
	btn_continue = "Cerca una soluzione online e chiudi il gioco.";
	btn_exit = "Chiudi il gioco.";
	btn_hidedetails = "Nascondi dettagli";
	btn_showdetails = "Visualizza dettagli";
	chk_sendreport = "Invia segnalazione errore";
	error_code = "Codice errore:";
	lbl_body1 = "Si è verificato un errore nell'avvio del gioco";
	lbl_body2 = "Aiutaci segnalando il problema.";
	lbl_body3 = "Easy Anti-Cheat può cercare una soluzione online e aiutarti a risolvere il problema.";
	lbl_header = "Impossibile avviare il gioco";
	title = "Errore avvio";
};
game_error:
{
	error_catalogue_file = "Errore accesso indice EAC";
	error_catalogue_not_found = "Indice EAC non trovato";
	error_certificate_revoked = "Certificato revocato indice EAC";
	error_corrupted_memory = "Memoria danneggiata";
	error_corrupted_network = "Pacchetto di comunicazione danneggiato";
	error_file_forbidden = "File di gioco sconosciuto";
	error_file_not_found = "File necessario assente";
	error_file_version = "Versione file sconosciuta";
	error_module_forbidden = "Modulo vietato";
	error_system_configuration = "Configurazione di sistema proibita";
	error_system_version = "File di sistema non affidabile";
	error_tool_forbidden = "Strumento vietato";
	error_violation = "Errore anti-cheat interno.";
	error_virtual = "Impossibile eseguire con macchina virtuale.";
	peer_client_banned = "Anti-cheat peer escluso.";
	peer_heartbeat_rejected = "Anti-cheat peer rifiutato.";
	peer_validated = "Verifica anti-cheat peer completata.";
	peer_validation_failed = "Verifica anti-cheat peer non riuscita.";
	executable_not_hashed = "Impossibile trovare l'eseguibile del gioco nel catalogo.";
};
launcher:
{
	btn_cancel = "Annulla";
	btn_exit = "Esci";
	error_cancel = "Avvio annullato";
	error_filenotfound = "File non trovato";
	error_init = "Errore di inizializzazione";
	error_install = "Errore installazione";
	error_launch = "Errore avvio";
	error_nolib = "Impossibile caricare la libreria Easy Anti-Cheat";
	loading = "CARICAMENTO IN CORSO";
	wait = "Attendere";
	initializing = "INIZIALIZZAZIONE IN CORSO";
	success_waiting_for_game = "IN ATTESA DEL GIOCO";
	success_closing = "Successo";
	network_error = "Errore di rete";
	error_no_settings_file = "{0} non trovato";
	error_invalid_settings_format = "{0} non ha un formato JSON valido";
	error_missing_required_field = "Campo obbligatorio ({1}) mancante in {0}";
	download_progress = "Progresso del download: {0}";
};
launcher_error:
{
	error_already_running = "Un'applicazione che usa Easy Anti-Cheat è già in esecuzione!";
	error_application = "Il client del gioco ha rilevato un errore di applicazione.";
	error_bad_exe_format = "Sistema operativo a 64 bit necessario";
	error_bitset_32 = "Usare la versione 32-bit del gioco";
	error_bitset_64 = "Usare la versione 64-bit del gioco";
	error_cancelled = "Operazione annullata dall'utente";
	error_certificate_validation = "Errore di convalida del certificato di firma del codice di Easy Anti-Cheat";
	error_client_auth_failed = "Il client del gioco non ha potuto verificare l'anti-cheat e la protezione anti-cheat potrebbe non essere attivata.";
	error_client_banned = "L'account di gioco è stato sospeso da tutte le funzioni di gioco online.";
	error_client_disconnected = "Nel client del gioco non è attivo l'anti-cheat.";
	error_client_violation = "Il client del gioco non ha potuto verificare l'integrità del tempo di esecuzione dell'anti-cheat.";
	error_connection = "Connessione alla rete di distribuzione contenuti non riuscita!";
	error_debugger = "Debugger individuato. Rimuoverlo e riprovare.";
	error_disk_space = "Spazio insufficiente sul disco fisso.";
	error_dns = "Tentativo di risoluzione DNS per la rete di distribuzione contenuti non riuscito!";
	error_dotlocal = "Reindirizzamento del DLL DotLocal rilevato.";
	error_dotlocal_instructions = "Eliminare il file seguente";
	error_file_not_found = "File non trovato:";
	error_forbidden_tool = "Chiudere {0} prima di avviare il gioco";
	error_forbidden_driver = "Scarica {0} prima di avviare il gioco";
	error_generic = "Errore imprevisto.";
	error_kernel_debug = "Easy Anti-Cheat non può essere avviato se viene attivato il debugging del kernel";
	error_kernel_dse = "Easy Anti-Cheat non può essere eseguito se l'imposizione firma driver è stata disattivata";
	error_kernel_modified = "Modifica kernel di Windows rilevata";
	error_library_load = "Impossibile caricare la libreria Easy Anti-Cheat";
	error_memory = "Memoria non sufficiente per avviare il gioco";
	error_module_load = "Impossibile caricare il modulo anti-cheat";
	error_patched = "Programma di caricamento patch di Windows rilevato";
	error_process = "Impossibile creare la procedura";
	error_process_crash = "Il processo è terminato improvvisamente";
	error_safe_mode = "Easy Anti-Cheat non può essere eseguito nella modalità provvisoria di Windows";
	error_socket = "Qualcosa impedisce all'applicazione di accedere a Internet!";
	error_ssl = "Errore di connessione SSL con il servizio CDN!";
	error_start = "Impossibile avviare il gioco";
	error_uncpath_forbidden = "Impossibile eseguire il gioco attraverso una condivisione di rete. (percorso UNC).";
	error_missing_path = "Percorso del file eseguibile del gioco non trovato";
	error_invalid_executable = "File eseguibile del gioco non valido: ";
	error_connection_failed = "Connessione fallita: ";
	error_module_not_found = "Modulo Anti-Cheat non trovato";
	error_missing_game_id = "ID del gioco non trovato";
	error_dns_resolve_failed = "Risoluzione DNS per proxy non riuscita";
	error_dns_connection_failed = "Connessione alla rete di distribuzione dei contenuti non riuscita! Codice curl: {0}!";
	error_http_response = "Codice di risposta HTTP: {0} Codice curl: {1}";
	error_driver_handle = "Errore inaspettato (impossibile aprire l'handle del driver)";
	error_incompatible_service = "Un servizio di Easy Anti-Cheat non compatibile è già in esecuzione. Chiudi gli altri giochi aperti o esegui il riavvio.";
	error_incompatible_driver_version = "Una versione del driver di Easy Anti-Cheat non compatibile è già in esecuzione. Chiudi gli altri giochi aperti o esegui il riavvio.";
	error_restart_windows = "Errore inaspettato (riavvia Windows per completare l'aggiornamento di EasyAntiCheat)";
	error_another_launcher = "Errore inaspettato (un altro launcher è già in esecuzione)";
	error_game_running = "Errore inaspettato (gioco già in esecuzione)";
	error_patched_boot_loader = "Rilevato caricatore di avvio di Windows con patch (protezione patch kernel disabilitata)";
	error_unknown_process = "Client del gioco non riconosciuto. Impossibile continuare.";
	error_unknown_game = "Gioco non configurato. Impossibile continuare.";
	error_windows_vista_sp = "Installare Windows Vista Service Pack 2 per avviare Easy Anti-Cheat.";
	error_windows_xp = "È necessario Windows XP o successivo.";
	error_windows_xp_64 = "Windows XP 64-bit non supportato.";
	error_windows_xp_sp = "Installare Windows XP Service Pack 3 per avviare Easy Anti-Cheat.";
	success_initialized = "Easy Anti-Cheat inizializzato";
	success_loaded = "Easy Anti-Cheat caricato in gioco";
};
setup:
{
	btn_finish = "Finisci";
	btn_install = "Installa ora";
	btn_repair = "Riparazione";
	btn_uninstall = "Disinstalla";
	epic_link = "© Epic Games, Inc";
	error_prefix = "Errore:";
	install_progress = "Installazione in corso...";
	install_success = "Installato";
	licenses_link = "Licenze";
	privacy_link = "Privacy";
	repair_progress = "Riparazione in corso...";
	title = "Easy Anti-Cheat Service Setup";
	uninstall_progress = "Disinstallazione in corso...";
	uninstall_success = "Disinstallato";
};
setup_error:
{
	error_cancelled = "Operazione annullata dall'utente";
	error_encrypted = "La cartella di installazione di Easy Anti-Cheat è stata crittografata";
	error_intro = "Impostazione Easy Anti-Cheat non riuscita";
	error_not_installed = "Easy Anti-Cheat non installato.";
	error_registry = "Copia dei file eseguibili del servizio non riuscita";
	error_rights = "Privilegi non sufficienti";
	error_service = "Impossibile creare servizio";
	error_system = "Accesso a System32 negato";
};
```

`eac/dist/EasyAntiCheat/Localization/ja_ja.cfg`:

```cfg
#----------------------------------------------------------
# Easy Anti-Cheat Localization File
#
# This file must use UTF-8 encoding.
#
# Each localization file should be named ll_CC.cfg where
# ll = ISO-639 code for language (e.g. "en")
# CC = ISO-3166 code for country (e.g. "US")
#----------------------------------------------------------

bugreport:
{
	btn_continue = "ゲームを終了して、オンラインで解決策を探す";
	btn_exit = "ゲームを終了する";
	btn_hidedetails = "詳細を閉じる";
	btn_showdetails = "詳細を表示";
	chk_sendreport = "エラーレポートを送信する";
	error_code = "エラーコード:";
	lbl_body1 = "申し訳ありません、ゲーム起動時に問題が発生しました";
	lbl_body2 = "お手数ですが、この問題の報告をお願いいたします。";
	lbl_body3 = "Easy Anti-Cheatはオンラインで解決策を検索することができます。問題解決の助けになれば幸いです。";
	lbl_header = "ゲームを起動できません";
	title = "起動時エラー";
};
game_error:
{
	error_catalogue_file = "EAC インデックス アクセスエラー";
	error_catalogue_not_found = "EAC インデックスが見つかりません";
	error_certificate_revoked = "EAC インデックス認証が無効となりました";
	error_corrupted_memory = "メモリが破損しています";
	error_corrupted_network = "パケットフローが破損しています";
	error_file_forbidden = "不明なゲームファイルです";
	error_file_not_found = "必要なファイルが見つかりません";
	error_file_version = "不明なファイルバージョンです";
	error_module_forbidden = "禁止されているモジュールです";
	error_system_configuration = "禁止されているシステム構成です";
	error_system_version = "信頼性の低いシステムファイルです";
	error_tool_forbidden = "禁止されているツールです";
	error_violation = "チート防止内部エラー";
	error_virtual = "仮想マシン上では稼働できません";
	peer_client_banned = "Anti-cheatピアが禁止されています。";
	peer_heartbeat_rejected = "Anti-cheatピアが拒否されました。";
	peer_validated = "Anti-cheatピア認証が完了しました。";
	peer_validation_failed = "Anti-cheatピア認証ができませんでした。";
	executable_not_hashed = "カタログにゲームの実行ファイルのエントリが見つかりません。";
};
launcher:
{
	btn_cancel = "キャンセル";
	btn_exit = "終了";
	error_cancel = "起動がキャンセルされました";
	error_filenotfound = "ファイルが見つかりません";
	error_init = "初期化エラー";
	error_install = "インストールエラー";
	error_launch = "起動時エラー";
	error_nolib = "Easy Anti-Cheatライブラリをロードできません";
	loading = "ロード中";
	wait = "お待ちください";
	initializing = "初期化中";
	success_waiting_for_game = "ゲームを待っています";
	success_closing = "成功";
	network_error = "ネットワークエラー";
	error_no_settings_file = "{0} が見つかりませんでした";
	error_invalid_settings_format = "{0} は有効な JSON 形式ではありません";
	error_missing_required_field = "{0} には必須フィールド ({1}) が不足しています";
	download_progress = "ダウンロードの進行状況： {0}";
};
launcher_error:
{
	error_already_running = "Easy Anti-Cheatを使用したアプリケーションがすでに稼働しています！";
	error_application = "ゲームクライアントがアプリケーションエラーを起こしました";
	error_bad_exe_format = "64ビットOSが必須です";
	error_bitset_32 = "ゲームの32-bitバージョンをご使用ください";
	error_bitset_64 = "ゲームの64-bitバージョンをご使用ください";
	error_cancelled = "実行がユーザーによってキャンセルされました";
	error_certificate_validation = "Easy Anti-Cheatコード署名証明書の認証エラー";
	error_client_auth_failed = "ゲームクライアントがAnti-cheatを認証できません。Anti-cheatの保護機能を稼働させていないのかもしれません。";
	error_client_banned = "ゲームアカウントがすべてのオンラインゲーム機能を禁止しています。";
	error_client_disconnected = "ゲームクライアントがAnti-cheatを実行していません。";
	error_client_violation = "ゲームクライアントがAnti-cheatのランタイム統合性チェックをできませんでした。";
	error_connection = "コンテンツデリバリネットワークへ接続できませんでした！";
	error_debugger = "デバッガーが検知されました。デバッガーをアンロードしてからやり直してください";
	error_disk_space = "ディスクの空き容量不足です。";
	error_dns = "コンテンツデリバリネットワークへのDNSリゾルブができませんでした！";
	error_dotlocal = "DotLocal DLLのリダイレクトが検知されました";
	error_dotlocal_instructions = "以下のファイルを削除してください";
	error_file_not_found = "ファイルが見つかりません:";
	error_forbidden_tool = "{0}を閉じてから、ゲームを開始してください";
	error_forbidden_driver = "ゲームを開始する前に{0}をアンロードしてください";
	error_generic = "不明なエラー";
	error_kernel_debug = "カーネルデバックが有効になっていると、Easy Anti-Cheatは稼働できません";
	error_kernel_dse = "Driver Signature Enforcementが無効になっていると、Easy Anti-Cheatは稼働できません";
	error_kernel_modified = "禁止されているWindowsカーネル変更が検知されました";
	error_library_load = "Easy Anti-Cheatライブラリをロードできません";
	error_memory = "メモリ不足でゲームを起動できません";
	error_module_load = "チート防止モジュールをロードできませんでした";
	error_patched = "パッチされたWindows ブートローダーが検知されました";
	error_process = "プロセスを作成できません";
	error_process_crash = "処理が突然終了しました";
	error_safe_mode = "Easy Anti-CheatはWindowsセーフモードでは実行できません";
	error_socket = "アプリケーションのインターネットへのアクセスを何かが妨げています！";
	error_ssl = "CDNサービスとのSSL接続確立時にエラー！";
	error_start = "ゲームを開始できませんでした";
	error_uncpath_forbidden = "ネットワークシェアを通してゲームを実行できません。（UNCパス）";
	error_missing_path = "ゲームの実行ファイルのパスが見つかりません";
	error_invalid_executable = "ゲームの実行ファイルが無効です: ";
	error_connection_failed = "接続に失敗しました: ";
	error_module_not_found = "Anti-Cheatモジュールが見つかりません";
	error_missing_game_id = "ゲームIDが見つかりません";
	error_dns_resolve_failed = "プロキシへのDNS解決に失敗しました";
	error_dns_connection_failed = "コンテンツ配信ネットワークへの接続に失敗しました！Curl コード： {0}!";
	error_http_response = "HTTPレスポンスコード： {0} Curl コード： {1}";
	error_driver_handle = "予期せぬエラー（ドライバーハンドルを開けませんでした）";
	error_incompatible_service = "互換性のないEasy Anti-Cheatサービスがすでに実行されています。実行中の他のゲームを終了するか再起動してください";
	error_incompatible_driver_version = "互換性のないEasy Anti-Cheatドライバのバージョンがすでに実行されています。実行中の他のゲームを終了するか再起動してください";
	error_restart_windows = "予期せぬエラー（Windowsを再起動してEasyAntiCheatの更新を完了してください）";
	error_another_launcher = "予期せぬエラー（他のランチャーが実行中です）";
	error_game_running = "予期せぬエラー（ゲームはすでに実行されています）";
	error_patched_boot_loader = "パッチが適用されたWindwowsブートローダが検出されました。（Kernel Patch Protectionが無効です）";
	error_unknown_process = "認識できないゲームクライアントです。継続できません";
	error_unknown_game = "未設定のゲームです。継続できません。";
	error_windows_vista_sp = "Easy Anti-Cheatを稼働させるには、Windows Vista Service Pack 2をインストールしてください";
	error_windows_xp = "Windows XP以降が必要です";
	error_windows_xp_64 = "Windows XP 64-bit Editionが非対応です";
	error_windows_xp_sp = "Easy Anti-Cheatを稼働させるには、Windows XP Service Pack 3をインストールしてください";
	success_initialized = "Easy Anti-Cheatが初期化されました";
	success_loaded = "Easy Anti-Cheatのゲームへのロードが完了しました";
};
setup:
{
	btn_finish = "終了";
	btn_install = "今すぐインストール";
	btn_repair = "修復サービス";
	btn_uninstall = "アンインストール";
	epic_link = "© Epic Games, Inc";
	error_prefix = "エラー:";
	install_progress = "インストール中…";
	install_success = "インストールが完了しました";
	licenses_link = "ライセンス";
	privacy_link = "プライバシー";
	repair_progress = "修復中…";
	title = "Easy Anti-Cheat Service Setup";
	uninstall_progress = "アンインストール中…";
	uninstall_success = "アンインストールが完了しました";
};
setup_error:
{
	error_cancelled = "実行がユーザーによってキャンセルされました";
	error_encrypted = "Easy Anti-Cheatインストレーションフォルダが暗号化されています";
	error_intro = "Easy Anti-Cheatのセットアップができませんでした";
	error_not_installed = "Easy Anti-Cheatがインストールされていません";
	error_registry = "実行ファイルのコピーに失敗（32）";
	error_rights = "権限が不足しています";
	error_service = "サービスを作成できません";
	error_system = "System32へのアクセスが拒否されました";
};
```

`eac/dist/EasyAntiCheat/Localization/ko_kr.cfg`:

```cfg
#----------------------------------------------------------
# Easy Anti-Cheat Localization File
#
# This file must use UTF-8 encoding.
#
# Each localization file should be named ll_CC.cfg where
# ll = ISO-639 code for language (e.g. "en")
# CC = ISO-3166 code for country (e.g. "US")
#----------------------------------------------------------

bugreport:
{
	btn_continue = "게임을 종료하고 온라인 검색을 시작합니다.";
	btn_exit = "게임을 종료합니다.";
	btn_hidedetails = "상세 내용 숨기기";
	btn_showdetails = "상세 내용 보기";
	chk_sendreport = "오류 보고 보내기";
	error_code = "오류 코드:";
	lbl_body1 = "죄송합니다. 게임 시작 중에 문제가 발생했습니다.";
	lbl_body2 = "오류 보고를 통해 문제를 해결할 수 있도록 도와주세요.";
	lbl_body3 = "Easy Anti-Cheat가 온라인 검색을 통해 문제 해결 방법을 찾아볼 수 있습니다.";
	lbl_header = "게임을 시작할 수 없습니다.";
	title = "실행 오류";
};
game_error:
{
	error_catalogue_file = "EAC 인덱스 접근 오류";
	error_catalogue_not_found = "EAC 인덱스를 찾을 수 없음";
	error_certificate_revoked = "EAC 인덱스 인증서 폐지";
	error_corrupted_memory = "변형된 메모리";
	error_corrupted_network = "변형된 패킷 플로우";
	error_file_forbidden = "알 수 없는 게임 파일";
	error_file_not_found = "필수 파일 누락";
	error_file_version = "알 수 없는 파일 버전";
	error_module_forbidden = "금지된 모듈";
	error_system_configuration = "금지된 시스템 구성";
	error_system_version = "신뢰할 수 없는 시스템 파일";
	error_tool_forbidden = "금지된 도구";
	error_violation = "내부적 안티 치트 오류";
	error_virtual = "가상 머신에서 구동할 수 없습니다.";
	peer_client_banned = "안티 치트 피어가 금지되었습니다.";
	peer_heartbeat_rejected = "안티 치트 피어가 거부되었습니다.";
	peer_validated = "안티 치트 피어 검증이 완료되었습니다.";
	peer_validation_failed = "안티 치트 피어 검증에 실패했습니다.";
	executable_not_hashed = "카탈로그에서 실행 가능한 게임 항목을 찾을 수 없습니다.";
};
launcher:
{
	btn_cancel = "취소";
	btn_exit = "나가기";
	error_cancel = "실행 취소됨";
	error_filenotfound = "파일을 찾을 수 없습니다.";
	error_init = "초기화 오류";
	error_install = "설치 오류";
	error_launch = "실행 오류";
	error_nolib = "Easy Anti-Cheat 라이브러리를 불러올 수 없습니다.";
	loading = "로딩 중";
	wait = "잠시만 기다려 주세요.";
	initializing = "초기화 중";
	success_waiting_for_game = "게임 실행 대기 중";
	success_closing = "성공";
	network_error = "네트워크 오류";
	error_no_settings_file = "{0} 찾을 수 없음";
	error_invalid_settings_format = "{0}에 유효한 JSON 형식이 없습니다.";
	error_missing_required_field = "{0}에 필수 영역이 누락되어 있습니다. ({1})";
	download_progress = "다운로드 진행 상황: {0}";
};
launcher_error:
{
	error_already_running = "Easy Anti-Cheat를 사용하는 애플리케이션이 이미 실행 중입니다!";
	error_application = "게임 클라이언트에 애플리케이션 오류가 발생했습니다.";
	error_bad_exe_format = "64비트 운영체제 필요";
	error_bitset_32 = "32-bit 버전 게임을 사용해 주세요.";
	error_bitset_64 = "64-bit 버전 게임을 사용해 주세요.";
	error_cancelled = "사용자에 의해 작업이 취소됨";
	error_certificate_validation = "Easy Anti-Cheat 코드 서명 인증서 검증 오류";
	error_client_auth_failed = "게임 클라이언트가 안티 치트 인증에 실패했으며, 안티 치트 보호가 활성화되어있지 않을 수 있습니다.";
	error_client_banned = "모든 온라인 게임 기능에서 해당 계정 이용이 금지되었습니다.";
	error_client_disconnected = "게임 클라이언트가 안티 치트를 실행하고 있지 않습니다.";
	error_client_violation = "게임 클라이언트가 안티 치트 런타임 무결성 검사에 실패했습니다.";
	error_connection = "CDN 연결 실패!";
	error_debugger = "디버거가 감지되었습니다. 디버거를 종료하고 다시 실행해 주십시오.";
	error_disk_space = "디스크 공간이 부족합니다.";
	error_dns = "컨텐츠 전송 네트워크 DNS 리졸브 실패!";
	error_dotlocal = "DotLocal DLL 재전송이 감지되었습니다.";
	error_dotlocal_instructions = "다음 파일을 삭제해 주십시오.";
	error_file_not_found = "파일 확인 불가:";
	error_forbidden_tool = "게임을 시작하기 전에 {0}을/를 종료해 주십시오.";
	error_forbidden_driver = "게임을 시작하기 전에 {0}을(를) 언로드하세요";
	error_generic = "예기치 않은 오류 발생";
	error_kernel_debug = "Easy Anti-Cheat는 커널 디버깅이 활성화된 상태에서 실행할 수 없습니다.";
	error_kernel_dse = "Easy Anti-Cheat는 DSE(Driver Signature Enforcement)가 비활성화된 상태에서 실행할 수 없습니다.";
	error_kernel_modified = "윈도우즈 커널의 금지된 변경사항이 감지되었습니다.";
	error_library_load = "Easy Anti-Cheat 라이브러리를 불러올 수 없습니다.";
	error_memory = "게임 시작에 필요한 메모리가 부족합니다.";
	error_module_load = "안티 치트 모듈 로딩 실패";
	error_patched = "윈도우즈 부트 로더의 패치가 감지되었습니다.";
	error_process = "프로세스 생성 불가";
	error_process_crash = "예상치 못한 문제로 프로세스가 종료되었습니다.";
	error_safe_mode = "Easy Anti-Cheat는 Windows 안전 모드에서는 실행할 수 없습니다.";
	error_socket = "애플리케이션의 인터넷 접근이 차단되어 있습니다!";
	error_ssl = "CDN 서비스와의 SSL 연결 설정 오류!";
	error_start = "게임 시작 실패";
	error_uncpath_forbidden = "네트워크 공유를 통해 게임을 실행할 수 없습니다(UNC 경로)";
	error_missing_path = "실행 가능 게임 경로 누락";
	error_invalid_executable = "올바르지 않은 실행 가능 게임: ";
	error_connection_failed = "연결 실패: ";
	error_module_not_found = "Anti-Cheat 모듈을 찾을 수 없음";
	error_missing_game_id = "게임 ID 누락";
	error_dns_resolve_failed = "DNS 프록시 확인 실패";
	error_dns_connection_failed = "콘텐츠 전송 네트워크(CDN) 연결 실패! Curl 코드: {0}!";
	error_http_response = "HTTP 응답 코드: {0} Curl 모드: {1}";
	error_driver_handle = "예상치 못한 오류. (드라이버 핸들 열기 실패)";
	error_incompatible_service = "호환되지 않는 Easy Anti-Cheat 서비스가 이미 실행 중입니다. 실행 중인 다른 게임을 종료하거나 다시 부팅하세요.";
	error_incompatible_driver_version = "호환되지 않는 Easy Anti-Cheat 드라이버 버전이 이미 실행 중입니다. 실행 중인 다른 게임을 종료하거나 다시 부팅하세요.";
	error_restart_windows = "예상치 못한 오류. (EasyAntiCheat 업데이트를 완료하려면 Windows 재시작)";
	error_another_launcher = "예상치 못한 오류. (다른 런처가 이미 실행 중)";
	error_game_running = "예상치 못한 오류. (게임이 이미 실행 중)";
	error_patched_boot_loader = "패치된 Windows 부트 로더 감지됨. (Kernel 패치 보호 비활성화)";
	error_unknown_process = "확인되지 않은 게임 클라이언트. 클라이언트가 종료됩니다.";
	error_unknown_game = "구성되지 않은 게임. 계속 할 수 없습니다.";
	error_windows_vista_sp = "Easy Anti-Cheat을 실행하려면 Windows Vista 서비스 팩 2를 설치하세요.";
	error_windows_xp = "Windows XP 이상의 최신 버전이 필요합니다. ";
	error_windows_xp_64 = "Windows XP 64-비트 에디션은 지원되지 않습니다.";
	error_windows_xp_sp = "Easy Anti-Cheat을 실행하려면 Windows XP 서비스 팩 3를 설치하세요.";
	success_initialized = "Easy Anti-Cheat가 성공적으로 초기화되었습니다.";
	success_loaded = "Easy Anti-Cheat가 성공적으로 인게임을 로딩했습니다.";
};
setup:
{
	btn_finish = "종료";
	btn_install = "지금 설치하기";
	btn_repair = "서비스 복구하기";
	btn_uninstall = "삭제하기";
	epic_link = "© Epic Games, Inc";
	error_prefix = "오류:";
	install_progress = "설치 중...";
	install_success = "설치 완료";
	licenses_link = "라이선스";
	privacy_link = "개인정보보호";
	repair_progress = "복구 중...";
	title = "Easy Anti-Cheat Service Setup";
	uninstall_progress = "삭제 중...";
	uninstall_success = "삭제 완료";
};
setup_error:
{
	error_cancelled = "사용자에 의해 작업이 취소되었습니다.";
	error_encrypted = "Easy Anti-Cheat 설치 폴더가 암호화되었습니다";
	error_intro = "Easy Anti-Cheat 셋업 실패";
	error_not_installed = "Easy Anti-Cheat가 설치되지 않았습니다.";
	error_registry = "서비스 실행 파일 복사 실패";
	error_rights = "권한 불충분";
	error_service = "서비스 생성 불가";
	error_system = "System32 접근 거부됨";
};
```

`eac/dist/EasyAntiCheat/Localization/nl_nl.cfg`:

```cfg
#----------------------------------------------------------
# Easy Anti-Cheat Localization File
#
# This file must use UTF-8 encoding.
#
# Each localization file should be named ll_CC.cfg where
# ll = ISO-639 code for language (e.g. "en")
# CC = ISO-3166 code for country (e.g. "US")
#----------------------------------------------------------

bugreport:
{
	btn_continue = "Onine gaan om een oplossing te zoeken en het spel afsluiten.";
	btn_exit = "Het spel afsluiten.";
	btn_hidedetails = "Details verbergen";
	btn_showdetails = "Details tonen";
	chk_sendreport = "Foutrapport versturen";
	error_code = "Foutcode:";
	lbl_body1 = "Het spijt ons, we konden je spel niet opstarten";
	lbl_body2 = "Help ons door dit probleem te rapporteren.";
	lbl_body3 = "Easy Anti-Cheat kan online controleren of er een oplossing voor het probleem bestaat en proberen het probleem te verhelpen.";
	lbl_header = "Het spel kon niet worden opgestart";
	title = "Opstartfout";
};
game_error:
{
	error_catalogue_file = "Fout bij toegang tot EAC-index";
	error_catalogue_not_found = "EAC-index niet gevonden";
	error_certificate_revoked = "Certificaat voor EAC-index ingetrokken";
	error_corrupted_memory = "Beschadigd geheugen";
	error_corrupted_network = "Beschadigde pakketstroom";
	error_file_forbidden = "Onbekend spelbestand";
	error_file_not_found = "Vereist bestand ontbreekt";
	error_file_version = "Onbekende bestandsversie";
	error_module_forbidden = "Verboden module";
	error_system_configuration = "Verboden systeemconfiguratie";
	error_system_version = "Niet-vertrouwd spelbestand";
	error_tool_forbidden = "Verboden tool";
	error_violation = "Interne anti-cheatfout";
	error_virtual = "Kan niet worden uitgevoerd op een virtuele machine.";
	peer_client_banned = "Anti-cheatpeer geblokkeerd.";
	peer_heartbeat_rejected = "Anti-cheatpeer afgewezen.";
	peer_validated = "Anti-cheatpeervalidatie voltooid.";
	peer_validation_failed = "Anti-cheatpeervalidatie mislukt.";
	executable_not_hashed = "Het was niet mogelijk om het uitvoerbare bestand voor het spel in de catalogus te vinden.";
};
launcher:
{
	btn_cancel = "Annuleren";
	btn_exit = "Afsluiten";
	error_cancel = "Opstarten geannuleerd";
	error_filenotfound = "Bestand niet gevonden";
	error_init = "Initialisatiefout";
	error_install = "Installatiefout";
	error_launch = "Opstartfout";
	error_nolib = "De Easy Anti-Cheat-bibliotheek kon niet worden geladen";
	loading = "LADEN";
	wait = "Een ogenblik geduld";
	initializing = "OPSTARTEN";
	success_waiting_for_game = "AAN HET WACHTEN OP SPEL";
	success_closing = "Geslaagd";
	network_error = "Netwerkfout";
	error_no_settings_file = "{0} niet gevonden";
	error_invalid_settings_format = "{0} heeft geen geldig JSON-formaat";
	error_missing_required_field = "{0} mist een verplicht veld ({1})";
	download_progress = "Downloadstatus: {0}";
};
launcher_error:
{
	error_already_running = "Er wordt al een applicatie uitgevoerd die Easy Anti-Cheat gebruikt!";
	error_application = "Bij spelclient is een applicatiefout opgetreden.";
	error_bad_exe_format = "64-bits besturingssysteem vereist";
	error_bitset_32 = "Gebruik de 32-bitsversie van het spel";
	error_bitset_64 = "Gebruik de 64-bitsversie van het spel";
	error_cancelled = "Operatie geannuleerd door gebruiker";
	error_certificate_validation = "Fout bij het valideren van het codesigning-certificaat van Easy Anti-Cheat ";
	error_client_auth_failed = "De anti-cheatauthenticatie van de gameclient is mislukt. Mogelijk heeft de gameclient de cheatbescherming niet geactiveerd.";
	error_client_banned = "Bij het gameaccount zijn alle online gamefuncties geblokkeerd.";
	error_client_disconnected = "De gameclient voert het anti-cheatprogramma niet uit.";
	error_client_violation = "Bij de gameclient is een anti-cheat runtime-integriteitscontrole mislukt.";
	error_connection = "Verbinding met het Content Distribution Network mislukt!";
	error_debugger = "Debugger gedetecteerd. Sluit deze af en probeer het opnieuw.";
	error_disk_space = "Onvoldoende schijfruimte.";
	error_dns = "DNS-oplossing van het Content Distribution Network mislukt!";
	error_dotlocal = "DotLocal DLL-verwijzing gedetecteerd.";
	error_dotlocal_instructions = "Verwijder het volgende bestand:";
	error_file_not_found = "Bestand niet gevonden:";
	error_forbidden_tool = "Sluit eerst {0} voordat je het spel start";
	error_forbidden_driver = "Schakel {0} uit voordat je het spel opstart";
	error_generic = "Onverwachte fout.";
	error_kernel_debug = "Easy Anti-Cheat kan niet worden uitgevoerd als Kernel Debugging is ingeschakeld";
	error_kernel_dse = "Easy Anti-Cheat kan niet worden uitgevoerd als Driver Signature Enforcement is uitgeschakeld";
	error_kernel_modified = "Verboden Windows-kernelmodificatie gedetecteerd";
	error_library_load = "De Easy Anti-Cheat-library kon niet worden geladen";
	error_memory = "Niet genoeg geheugen om het spel te starten";
	error_module_load = "Anti-cheatmodule kon niet worden geladen";
	error_patched = "Gepatchte Windows bootloader gedetecteerd";
	error_process = "Kan proces niet aanmaken";
	error_process_crash = "Het proces is plotseling afgebroken";
	error_safe_mode = "Easy Anti-Cheat kan niet worden uitgevoerd in Windows Veilige Modus";
	error_socket = "Iets blokkeert de toegang van de applicatie tot het internet!";
	error_ssl = "Fout bij het maken van een SSL-verbinding met de CDN-service!";
	error_start = "Spel kon niet worden opgestart";
	error_uncpath_forbidden = "Het is niet mogelijk het spel uit te voeren via een netwerkshare. (UNC-pad)";
	error_missing_path = "Het uitvoerbaar gamebestand ontbreekt";
	error_invalid_executable = "Ongeldig uitvoerbaar gamebestand: ";
	error_connection_failed = "Verbinding mislukt: ";
	error_module_not_found = "Anti-Cheatmodule niet gevonden";
	error_missing_game_id = "Game-ID ontbreekt";
	error_dns_resolve_failed = "DNS resolve naar proxy mislukt";
	error_dns_connection_failed = "Verbinding met Inhouddistributienetwerk mislukt! cURL-code: {0}!";
	error_http_response = "HTTP-responscode: {0} cURL-code: {1}";
	error_driver_handle = "Onverwachte fout. (Het was niet mogelijk de driver handle te openen)";
	error_incompatible_service = "Er is al een incompatibele Easy Anti-Cheat-service actief. Verlaat andere actieve spellen of start opnieuw op";
	error_incompatible_driver_version = "Er is al een incompatibele versie van de Easy Anti-Cheat-driver actief. Verlaat andere actieve spellen of start opnieuw op";
	error_restart_windows = "Onverwachte fout. (Start Windows opnieuw op om de EasyAntiCheat-update te voltooien)";
	error_another_launcher = "Onverwachte fout. (Er is al een andere launcher actief.)";
	error_game_running = "Onverwachte fout. (De game is al opgestart)";
	error_patched_boot_loader = "Gepatchte Windows-opstartlader gedetecteerd. (Kernel Patch Protection uitgeschakeld)";
	error_unknown_process = "Spelclient wordt niet herkend. Doorgaan niet mogelijk.";
	error_unknown_game = "Spel niet geconfigureerd. Laden wordt afgebroken.";
	error_windows_vista_sp = "Installeer Vista Service Pack 2 om Easy Anti-Cheat te kunnen uitvoeren.";
	error_windows_xp = "Windows XP of later is vereist.";
	error_windows_xp_64 = "Windows XP 64-bitversie wordt niet ondersteund.";
	error_windows_xp_sp = "Installeer Windows XP Service Pack 3 om Easy Anti-Cheat te kunnen uitvoeren.";
	success_initialized = "Easy Anti-Cheat gestart";
	success_loaded = "Easy Anti-Cheat in het spel geladen";
};
setup:
{
	btn_finish = "Afronden";
	btn_install = "Nu installeren";
	btn_repair = "Service repareren";
	btn_uninstall = "Verwijderen";
	epic_link = "© Epic Games, Inc";
	error_prefix = "Fout:";
	install_progress = "Installeren...";
	install_success = "Installatie geslaagd";
	licenses_link = "Licenties";
	privacy_link = "Privacy";
	repair_progress = "Repareren...";
	title = "Installatie van de Easy Anti-Cheat-service";
	uninstall_progress = "Verwijderen...";
	uninstall_success = "Verwijderen geslaagd";
};
setup_error:
{
	error_cancelled = "Operatie geannuleerd door gebruiker";
	error_encrypted = "De Easy Anti-Cheat-installatiemap is versleuteld";
	error_intro = "Installatie van Easy Anti-Cheat mislukt";
	error_not_installed = "Easy Anti-Cheat is niet geïnstalleerd.";
	error_registry = "Toegang tot register ontzegd";
	error_rights = "Onvoldoende rechten";
	error_service = "Kan service niet aanmaken";
	error_system = "Toegang tot System32 ontzegd";
};
```

`eac/dist/EasyAntiCheat/Localization/pl_pl.cfg`:

```cfg
#----------------------------------------------------------
# Easy Anti-Cheat Localization File
#
# This file must use UTF-8 encoding.
#
# Each localization file should be named ll_CC.cfg where
# ll = ISO-639 code for language (e.g. "en")
# CC = ISO-3166 code for country (e.g. "US")
#----------------------------------------------------------

bugreport:
{
	btn_continue = "Przejdź do zasobów online w celu odnalezienia rozwiązania i opuść grę.";
	btn_exit = "Opuść grę.";
	btn_hidedetails = "Ukryj szczegóły";
	btn_showdetails = "Pokaż szczegóły";
	chk_sendreport = "Wyślij raport o błędzie";
	error_code = "Kod błędu";
	lbl_body1 = "Niestety, nie mogliśmy uruchomić gry.";
	lbl_body2 = "Pomóż nam, zgłaszając ten problem.";
	lbl_body3 = "Usługa Easy Anti-Cheat może sprawdzić zasoby online w poszukiwaniu rozwiązania problemu, a następnie podjąć próbę naprawy błędu.";
	lbl_header = "Nie uruchomiono gry";
	title = "Błąd uruchomienia";
};
game_error:
{
	error_catalogue_file = "Błąd dostępu do indeksu EAC";
	error_catalogue_not_found = "Nie odnaleziono indeksu EAC";
	error_certificate_revoked = "Unieważniono certyfikat indeksu EAC";
	error_corrupted_memory = "Uszkodzona pamięć";
	error_corrupted_network = "Uszkodzony przepływ pakietów";
	error_file_forbidden = "Nieznany plik gry";
	error_file_not_found = "Brak wymaganego pliku";
	error_file_version = "Nieznana wersja pliku";
	error_module_forbidden = "Zabroniony moduł";
	error_system_configuration = "Zabroniona konfiguracja systemu";
	error_system_version = "Nieznany plik systemowy";
	error_tool_forbidden = "Zabronione narzędzie";
	error_violation = "Wewnętrzny błąd systemu zapobiegania oszustwom";
	error_virtual = "Nie można uruchomić z maszyny wirtualnej";
	peer_client_banned = "Nałożono blokadę na hosta równorzędnego w celu ochrony przed oszustwami.";
	peer_heartbeat_rejected = "Odrzucono hosta równorzędnego w celu ochrony przed oszustwami.";
	peer_validated = "Ukończono test poprawności hosta równorzędnego zapobiegający oszustwom.";
	peer_validation_failed = "Test poprawności hosta równorzędnego zapobiegający oszustwom nie powiódł się.";
	executable_not_hashed = "Nie udało się zlokalizować w katalogu wpisu wykonywalnego gry.";
};
launcher:
{
	btn_cancel = "Anuluj";
	btn_exit = "Wyjdź";
	error_cancel = "Anulowano uruchamianie";
	error_filenotfound = "Nie znaleziono pliku";
	error_init = "Błąd inicjalizacji";
	error_install = "Błąd instalacji";
	error_launch = "Błąd uruchomienia";
	error_nolib = "Nie wczytano biblioteki Easy Anti-Cheat";
	loading = "WCZYTYWANIE";
	wait = "Poczekaj";
	initializing = "INICJOWANIE";
	success_waiting_for_game = "OCZEKIWANIE NA GRĘ";
	success_closing = "Sukces";
	network_error = "Błąd sieci";
	error_no_settings_file = "{0} – nie znaleziono";
	error_invalid_settings_format = "{0} nie ma prawidłowego formatu JSON";
	error_missing_required_field = "{0} – nie wypełniono wymaganego pola ({1})";
	download_progress = "Postępy pobierania: {0}";
};
launcher_error:
{
	error_already_running = "aplikacja używająca usługi Easy Anti-Cheat już działa!";
	error_application = "Klient gry napotkał błąd aplikacji.";
	error_bad_exe_format = "Wymagana 64-bitowa wersja systemu operacyjnego";
	error_bitset_32 = "Użyj gry w wersji 32-bit";
	error_bitset_64 = "Użyj gry w wersji 64-bit";
	error_cancelled = "Operacja anulowana przez użytkownika";
	error_certificate_validation = "Błąd sprawdzania poprawności certyfikatu podpisywania kodu usługi Easy Anti-Cheat";
	error_client_auth_failed = "Klient gry nie przeszedł weryfikacji w celu ochrony przed oszustwami, w związku z czym może nie mieć aktywnej ochrony zapobiegającej oszustwom.";
	error_client_banned = "Na koncie w grze zablokowano wszystkie funkcje online.";
	error_client_disconnected = "Klient gry nie uruchomił usługi ochrony przed oszustwami.";
	error_client_violation = "Klient gry nie przeszedł testu integralności środowiska uruchomieniowego zapobiegającego oszustwom.";
	error_connection = "Nie połączono z usługą Content Distribution Network!";
	error_debugger = "Wykryto debuger. Zwolnij go z pamięci i spróbuj ponownie";
	error_disk_space = "Za mało miejsca na dysku.";
	error_dns = "Niepowodzenie identyfikacji adresu DNS w usłudze Content Distribution Network!";
	error_dotlocal = "Wykryto przekierowanie biblioteki DLL DotLocal.";
	error_dotlocal_instructions = "Usuń następujący plik";
	error_file_not_found = "Nie znaleziono pliku:";
	error_forbidden_tool = "Zamknij narzędzie {0}, zanim rozpoczniesz grę";
	error_forbidden_driver = "Przed rozpoczęciem gry rozładuj {0}";
	error_generic = "Nieoczekiwany błąd.";
	error_kernel_debug = "Usługa Easy Anti-Cheat nie może działać, jeżeli jest uruchomione debugowanie jądra";
	error_kernel_dse = "Usługa Easy Anti-Cheat nie może działać, jeżeli wyłączono wymuszanie podpisów sterowników";
	error_kernel_modified = "Wykryto zabronioną modyfikację jądra systemu Windows";
	error_library_load = "Nie wczytano biblioteki Easy Anti-Cheat";
	error_memory = "Nie uruchomiono gry z powodu niewystarczającej pamięci";
	error_module_load = "Nie wczytano modułu zapobiegającego oszustwom";
	error_patched = "Wykryto poprawiony moduł ładujący rozruchu systemu Windows";
	error_process = "Postęp niemożliwy";
	error_process_crash = "Nastąpiło nagłe zakończenie procesu";
	error_safe_mode = "Usługa Easy Anti-Cheat nie może działać w trybie awaryjnym systemu Windows.";
	error_socket = "Coś uniemożliwia aplikacji uzyskanie dostępu do Internetu!";
	error_ssl = "Błąd podczas nawiązywania połączenia SSL z usługą CDN!";
	error_start = "Nie uruchomiono gry";
	error_uncpath_forbidden = "Nie można uruchomić gry przez udostępnianie sieciowe (ścieżka UNC)";
	error_missing_path = "Brakująca ścieżka do pliku wykonywalnego gry";
	error_invalid_executable = "Nieprawidłowy plik wykonywalny gry: ";
	error_connection_failed = "Połączenie nieudane: ";
	error_module_not_found = "Nie znaleziono modułu Anti-Cheat";
	error_missing_game_id = "Brak identyfikatora gry";
	error_dns_resolve_failed = "Zapytanie DNS do serwera proxy nieudane";
	error_dns_connection_failed = "Połączenie z siecią dystrybucji treści (CDN) nie powiodło się! Kod cURL: {0}!";
	error_http_response = "Kod odpowiedzi HTTP: {0} Kod cURL: {1}";
	error_driver_handle = "Nieoczekiwany błąd. (Nie udało się otworzyć identyfikatora sterownika)";
	error_incompatible_service = "Niekompatybilna usługa Easy Anti-Cheat jest już uruchomiona. Wyłącz wszystkie pozostałe uruchomione gry lub zrestartuj komputer.";
	error_incompatible_driver_version = "Niekompatybilna wersja sterownika Easy Anti-Cheat jest już uruchomiona. Wyłącz wszystkie pozostałe uruchomione gry lub zrestartuj komputer.";
	error_restart_windows = "Nieoczekiwany błąd. (Uruchom ponownie system Windows, aby zakończyć aktualizację EasyAntiCheat)";
	error_another_launcher = "Nieoczekiwany błąd. (Włączony jest już inny program uruchamiający)";
	error_game_running = "Nieoczekiwany błąd. (Gra jest już włączona)";
	error_patched_boot_loader = "Wykryto zaktualizowany program rozruchowy Windows. (Ochrona aktualizacji jądra systemu wyłączona)";
	error_unknown_process = "Nie rozpoznano klienta gry. Nie można kontynuować.";
	error_unknown_game = "Nieskonfigurowana gra. Nie można kontynuować.";
	error_windows_vista_sp = "Aby uruchomić usługę Easy Anti-Cheat, zainstaluj dodatek Service Pack 2 dla systemu Windows Vista.";
	error_windows_xp = "Wymagany system Windows XP lub nowszy.";
	error_windows_xp_64 = "System Windows w 64-bitowej wersji nie jest obsługiwany.";
	error_windows_xp_sp = "Aby uruchomić usługę Easy Anti-Cheat, zainstaluj dodatek Service Pack 3 dla systemu Windows XP.";
	success_initialized = "Zainicjowano usługę Easy Anti-Cheat";
	success_loaded = "Wczytano usługę Easy Anti-Cheat w grze";
};
setup:
{
	btn_finish = "Zakończ";
	btn_install = "Zainstaluj teraz";
	btn_repair = "Napraw usługę";
	btn_uninstall = "Odinstaluj";
	epic_link = "© Epic Games, Inc";
	install_progress = "Instalowanie...";
	install_success = "Zainstalowano";
	licenses_link = "Licencje";
	privacy_link = "Prywatność";
	repair_progress = "Naprawianie...";
	title = "Easy Anti-Cheat Service Setup";
	uninstall_progress = "Trwa dezinstalacja...";
	uninstall_success = "Odinstalowano";
};
setup_error:
{
	error_cancelled = "Operacja anulowana przez użytkownika";
	error_encrypted = "Folder instalacyjny Easy Anti-Cheat został zaszyfrowany";
	error_intro = "Niepowodzenie instalacji Easy Anti-Cheat";
	error_not_installed = "Nie zainstalowano Easy Anti-Cheat ";
	error_registry = "Plik wykonywalny usługi: niepowodzenie";
	error_rights = "Niewystarczające przywileje";
	error_service = "Nie można stworzyć usługi";
	error_system = "Odmowa dostępu do katalogu System32";
};
```

`eac/dist/EasyAntiCheat/Localization/pt_br.cfg`:

```cfg
#----------------------------------------------------------
# Easy Anti-Cheat Localization File
#
# This file must use UTF-8 encoding.
#
# Each localization file should be named ll_CC.cfg where
# ll = ISO-639 code for language (e.g. "en")
# CC = ISO-3166 code for country (e.g. "US")
#----------------------------------------------------------

bugreport:
{
	btn_continue = "Acesse a internet para procurar uma solução e feche o jogo.";
	btn_exit = "Fechar o jogo.";
	btn_hidedetails = "Ocultar detalhes";
	btn_showdetails = "Exibir detalhes";
	chk_sendreport = "Enviar relatório de erro";
	error_code = "Código de Erro:";
	lbl_body1 = "Infelizmente tivemos um problema na inicialização do seu jogo";
	lbl_body2 = "Por favor, ajude-nos descrevendo este problema.";
	lbl_body3 = "O Easy Anti-Cheat pode procurar uma solução online para o problema para ajudar em sua resolução.";
	lbl_header = "Não foi possível iniciar o jogo";
	title = "Erro na Execução";
};
game_error:
{
	error_catalogue_file = "Erro de acesso ao índice EAC";
	error_catalogue_not_found = "Índice EAC não encontrado";
	error_certificate_revoked = "Certificado de índice do EAC revogado";
	error_corrupted_memory = "Memória corrompida";
	error_corrupted_network = "Fluxo de pacotes corrompido";
	error_file_forbidden = "Arquivo de jogo desconhecido";
	error_file_not_found = "Arquivo necessário não encontrado";
	error_file_version = "Versão do arquivo desconhecida";
	error_module_forbidden = "Módulo proibido";
	error_system_configuration = "Configuração de sistema proibida";
	error_system_version = "Arquivo de sistema não confiável";
	error_tool_forbidden = "Ferramenta proibida";
	error_violation = "Erro interno de anti-trapaça";
	error_virtual = "Não é possível executar em máquina virtual.";
	peer_client_banned = "Ponto antitrapaças banido.";
	peer_heartbeat_rejected = "Ponto antitrapaças rejeitado.";
	peer_validated = "Validação do ponto antitrapaças concluída.";
	peer_validation_failed = "Falha na validação do ponto antitrapaças.";
	executable_not_hashed = "Não foi possível localizar a entrada executável do jogo no catálogo.";
};
launcher:
{
	btn_cancel = "Cancelar";
	btn_exit = "Sair";
	error_cancel = "Execução Cancelada";
	error_filenotfound = "Arquivo Não Encontrado";
	error_init = "Erro de Inicialização";
	error_install = "Erro na Instalação";
	error_launch = "Erro na Execução";
	error_nolib = "Não foi possível carregar a biblioteca do Easy Anti-Cheat";
	loading = "CARREGANDO";
	wait = "Por favor, aguarde";
	initializing = "INICIALIZANDO";
	success_waiting_for_game = "AGUARDANDO JOGO";
	success_closing = "Sucesso";
	network_error = "Erro de rede";
	error_no_settings_file = "{0} não encontrado";
	error_invalid_settings_format = "{0} não apresenta formato JSON válido";
	error_missing_required_field = "{0} não apresenta um dos campos obrigatórios ({1})";
	download_progress = "Andamento do download: {0}";
};
launcher_error:
{
	error_already_running = "Um aplicativo em execução já está usando o Easy Anti-Cheat!";
	error_application = "O cliente do jogo encontrou um erro no aplicativo.";
	error_bad_exe_format = "SO de 64 bits necessário";
	error_bitset_32 = "Por favor, use a versão 32-bit do jogo";
	error_bitset_64 = "Por favor, use a versão 64-bit do jogo";
	error_cancelled = "Operação cancelada pelo usuário";
	error_certificate_validation = "Erro de validação do código do certificado de assinatura do Easy Anti-Cheat";
	error_client_auth_failed = "O cliente de jogo falhou na autenticação antitrapaças e talvez não tenha ativado a proteção antitrapaças.";
	error_client_banned = "A conta foi banida de todas as funções de jogo online.";
	error_client_disconnected = "O ciente do jogo não está executando o antitrapaças.";
	error_client_violation = "O cliente do jogo falhou em uma verificação de integridade na execução do antitrapaças.";
	error_connection = "Falha na conexão com a Rede de Distribuição de Conteúdo!";
	error_debugger = "Debugger detectado. Por favor, descarregue-o e tente novamente";
	error_disk_space = "Espaço em disco insuficiente.";
	error_dns = "Falha na resolução de DNS para a Rede de Distribuição de Conteúdo!";
	error_dotlocal = "Redirecionamento do DLL DotLocal detectado.";
	error_dotlocal_instructions = "Por favor, exclua o arquivo a seguir";
	error_file_not_found = "Arquivo não encontrado:";
	error_forbidden_tool = "Por favor, feche {0} antes de iniciar o jogo";
	error_forbidden_driver = "Descarregue {0} antes de iniciar o jogo";
	error_generic = "Erro inesperado.";
	error_kernel_debug = "O Easy Anti-Cheat não pode ser executado se o Kernel Debugging estiver ativo";
	error_kernel_dse = "O Easy Anti-Cheat não pode ser executado se Driver Signature Enforcement for desativado";
	error_kernel_modified = "Modificação proibida do kernel do Windows detectada";
	error_library_load = "Não foi possível carregar a biblioteca do Easy Anti-Cheat";
	error_memory = "Memória insuficiente para iniciar o jogo";
	error_module_load = "Falha ao carregar o módulo anti-trapaça";
	error_patched = "Modificação do boot loader do Windows detectada";
	error_process = "Não foi possível criar o processo";
	error_process_crash = "O processo foi encerrado inesperadamente";
	error_safe_mode = "O Easy Anti-Cheat não pode ser executado no Modo de Segurança do Windows";
	error_socket = "Algo está bloqueando o acesso à Internet para o aplicativo!";
	error_ssl = "Erro ao estabelecer conexão SSL com o serviço CDN!";
	error_start = "Falha ao iniciar o jogo";
	error_uncpath_forbidden = "Não é possível rodar o jogo por um compartilhamento de rede. (caminho UNC).";
	error_missing_path = "Caminho do executável do jogo ausente";
	error_invalid_executable = "Executável do jogo inválido: ";
	error_connection_failed = "Falha na conexão: ";
	error_module_not_found = "Módulo Anti-Cheat não encontrado";
	error_missing_game_id = "Id do jogo ausente";
	error_dns_resolve_failed = "Falha na resolução do DNS para proxy";
	error_dns_connection_failed = "Falha na conexão à Rede de Distribuição de Conteúdo! Código Curl: {0}!";
	error_http_response = "Código de Resposta HTTP: {0} Código Curl: {1}";
	error_driver_handle = "Erro inesperado. (Não foi possível abrir o identificador do driver)";
	error_incompatible_service = "Uma versão incompatível do serviço Easy Anti-Cheat já está sendo executada. Saia dos outros jogos em execução ou reinicie.";
	error_incompatible_driver_version = "Uma versão incompatível do driver do Easy Anti-Cheat já está sendo executada. Saia dos outros jogos em execução ou reinicie.";
	error_restart_windows = "Erro inesperado. (Reinicie o Windows para concluir a atualização do EasyAntiCheat)";
	error_another_launcher = "Erro inesperado. (Outro inicializador já está sendo executado)";
	error_game_running = "Erro inesperado. (O jogo já está sendo executado)";
	error_patched_boot_loader = "Carregador de inicialização do Windows corrigido detectado. (Proteção contra Patches do Kernel desativada)";
	error_unknown_process = "Cliente de jogo não reconhecido Não é possível continuar.";
	error_unknown_game = "Jogo não configurado. Não é possível continuar.";
	error_windows_vista_sp = "Instale o Windows Vista Service Pack 2 para executar o Easy Anti-Cheat.";
	error_windows_xp = "Exige Windows XP ou mais atual.";
	error_windows_xp_64 = "Não há suporte para o Windows XP 64-bit Edition.";
	error_windows_xp_sp = "Instale o Windows XP Service Pack 3 para executar o Easy Anti-Cheat.";
	success_initialized = "O Easy Anti-Cheat foi iniciado com sucesso";
	success_loaded = "O Easy Anti-Cheat foi carregado com sucesso no jogo";
};
setup:
{
	btn_finish = "Finalizar";
	btn_install = "Instalar Agora";
	btn_repair = "Serviço de Reparos";
	btn_uninstall = "Desinstalar";
	epic_link = "© Epic Games, Inc";
	error_prefix = "Erro:";
	install_progress = "Instalando...";
	install_success = "Instalação Concluída";
	licenses_link = "Licenças";
	privacy_link = "Privacidade";
	repair_progress = "Reparando...";
	title = "Easy Anti-Cheat Service Setup";
	uninstall_progress = "Desinstalando...";
	uninstall_success = "Desinstalação Concluída";
};
setup_error:
{
	error_cancelled = "Operação cancelada pelo usuário";
	error_encrypted = "A pasta de instalação do Easy Anti-Cheat está criptografada";
	error_intro = "Falha na Configuração do Easy Anti-Cheat";
	error_not_installed = "Easy Anti-Cheat não instalado.";
	error_registry = "Falha na cópia do serviço executável";
	error_rights = "Privilégios insuficientes";
	error_service = "Não foi possível criar o serviço";
	error_system = "Acesso a System32 recusado";
};
```

`eac/dist/EasyAntiCheat/Localization/ru_ru.cfg`:

```cfg
#----------------------------------------------------------
# Easy Anti-Cheat Localization File
#
# This file must use UTF-8 encoding.
#
# Each localization file should be named ll_CC.cfg where
# ll = ISO-639 code for language (e.g. "en")
# CC = ISO-3166 code for country (e.g. "US")
#----------------------------------------------------------

bugreport:
{
	btn_continue = "Выйти в Интернет для поиска решения и закрыть игру.";
	btn_exit = "Закрыть игру.";
	btn_hidedetails = "Скрыть детали";
	btn_showdetails = "Показать детали";
	chk_sendreport = "Отправить сообщение об ошибке";
	error_code = "Код ошибки:";
	lbl_body1 = "К сожалению, с запуском игры возникла проблема";
	lbl_body2 = "Помогите нам, сообщив о ней.";
	lbl_body3 = "Easy Anti-Cheat может поискать решение проблемы в Интернете и постараться помочь.";
	lbl_header = "Не удалось запустить игру";
	title = "Ошибка запуска";
};
game_error:
{
	error_catalogue_file = "Ошибка доступа к каталогу EAC";
	error_catalogue_not_found = "Каталог EAC не найден";
	error_certificate_revoked = "Сертификат каталога EAC аннулирован";
	error_corrupted_memory = "Испорченная память";
	error_corrupted_network = "Нарушение обмена пакетами";
	error_file_forbidden = "Неизвестный игровой файл";
	error_file_not_found = "Нет нужного файла";
	error_file_version = "Неизвестная версия файла";
	error_module_forbidden = "Запрещенный модуль";
	error_system_configuration = "Недопустимая конфигурация системы";
	error_system_version = "Подозрительный системный файл";
	error_tool_forbidden = "Запрещенный инструмент";
	error_violation = "Внутренняя ошибка программы";
	error_virtual = "Не получается запустить на виртуальной машине.";
	peer_client_banned = "Участник заблокирован системой защиты.";
	peer_heartbeat_rejected = "Участник отвергнут системой защиты.";
	peer_validated = "Проверка участников системой защиты пройдена.";
	peer_validation_failed = "Проверка участников системой защиты не пройдена.";
	executable_not_hashed = "Не удаётся найти исполняемую запись игры в каталоге.";
};
launcher:
{
	btn_cancel = "Отмена";
	btn_exit = "Выход";
	error_cancel = "Запуск отменен";
	error_filenotfound = "Файл не найден";
	error_init = "Ошибка инициализации";
	error_install = "Ошибка установки";
	error_launch = "Ошибка запуска";
	error_nolib = "Не удалось загрузить библиотеку Easy Anti-Cheat";
	loading = "ЗАГРУЗКА";
	wait = "Подождите";
	initializing = "ИНИЦИАЛИЗАЦИЯ";
	success_waiting_for_game = "ОЖИДАНИЕ ИГРЫ";
	success_closing = "Успешно выполнено";
	network_error = "Сетевая ошибка";
	error_no_settings_file = "Файл {0} не найден";
	error_invalid_settings_format = "У файла {0} неподходящий формат JSON";
	error_missing_required_field = "В файле {0} нет требуемого поля ({1})";
	download_progress = "Прогресс загрузки: {0}";
};
launcher_error:
{
	error_already_running = "Уже запущено приложение, использующее Easy Anti-Cheat!";
	error_application = "В клиенте игры произошла ошибка приложения.";
	error_bad_exe_format = "Требуется 64-разрядная ОС";
	error_bitset_32 = "Используйте версию игры 32-bit";
	error_bitset_64 = "Используйте версию игры 64-bit";
	error_cancelled = "Действие отменено пользователем";
	error_certificate_validation = "Ошибка при проверке подлинности сертификата подписи программы для Easy Anti-Cheat";
	error_client_auth_failed = "Клиент игры не прошел проверку подлинности со стороны системы защиты и, возможно, не защищен от нечестной игры.";
	error_client_banned = "Эта игровая учетная запись заблокирована для игры по сети в любом виде.";
	error_client_disconnected = "Для клиента игры не запущена система защиты.";
	error_client_violation = "Клиент игры не прошел проверку целостности рабочей среды со стороны системы защиты.";
	error_connection = "Не удалось подключиться к сети доставки контента!";
	error_debugger = "Обнаружен отладчик. Закройте его и попробуйте еще раз";
	error_disk_space = "Не хватает места на диске.";
	error_dns = "Не удалось преобразовать DNS-адрес сети доставки контента!";
	error_dotlocal = "Обнаружено перенаправление DLL через DotLocal";
	error_dotlocal_instructions = "Удалите следующий файл";
	error_file_not_found = "Файл не найден:";
	error_forbidden_tool = "Закройте {0} перед запуском игры";
	error_forbidden_driver = "Выгрузите {0} перед запуском игры.";
	error_generic = "Непредвиденная ошибка.";
	error_kernel_debug = "Easy Anti-Cheat не может быть запущена при включенной отладки ядра";
	error_kernel_dse = "Easy Anti-Cheat не может быть запущена при отключенной обязательной проверке подписи драйверов";
	error_kernel_modified = "Обнаружена запрещенная модификация ядра Windows";
	error_library_load = "Не удалось загрузить библиотеку Easy Anti-Cheat";
	error_memory = "Не хватает памяти для запуска игры";
	error_module_load = "Не удалось загрузить модуль борьбы с программами для нечестной игры";
	error_patched = "Обнаружен измененный загрузчик для Windows";
	error_process = "Не удается создать процесс";
	error_process_crash = "Процесс внезапно прервался";
	error_safe_mode = "Easy Anti-Cheat не получается запустить в Безопасном режиме Windows";
	error_socket = "Что-то не дает приложению выйти в Интернет!";
	error_ssl = "Не удалось создать SSL-подключение к службе сети доставки контента!";
	error_start = "Не удалось запустить игру";
	error_uncpath_forbidden = "Не удаётся запустить игру через общий сетевой ресурс. (UNC-путь).";
	error_missing_path = "Отсутствует путь к исполняемому файлу игры";
	error_invalid_executable = "Неверный исполняемый файл игры: ";
	error_connection_failed = "Ошибка подключения: ";
	error_module_not_found = "Модуль для предотвращения использования читов не найден";
	error_missing_game_id = "Отсутствует идентификатор игры";
	error_dns_resolve_failed = "Не удалось преобразовать DNS для прокси-сервера";
	error_dns_connection_failed = "Не удалось подключиться к сети распространения контента! Curl Code: {0}!";
	error_http_response = "HTTP-код ответа: {0} Curl Code: {1}";
	error_driver_handle = "Непредвиденная ошибка. (Не удалось открыть дескриптор драйвера)";
	error_incompatible_service = "Несовместимая служба Easy Anti-Cheat уже запущена. Пожалуйста, выйдите из других запущенных игр или перезагрузите компьютер";
	error_incompatible_driver_version = "Несовместимая версия драйвера Easy Anti-Cheat уже запущена. Пожалуйста, выйдите из других запущенных игр или перезагрузите компьютер";
	error_restart_windows = "Непредвиденная ошибка. (Перезапустите Windows, чтобы завершить обновление EasyAntiCheat)";
	error_another_launcher = "Непредвиденная ошибка. (Программа запуска уже работает)";
	error_game_running = "Непредвиденная ошибка. (Игра уже запущена)";
	error_patched_boot_loader = "Обнаружен исправленный загрузчик Windows. (Защита от исправлений ядра отключена)";
	error_unknown_process = "Клиент игры не распознан. Продолжение невозможно.";
	error_unknown_game = "Ненастроенная игра. Не удаётся продолжить.";
	error_windows_vista_sp = "Установите Windows Vista Service Pack 2, чтобы запустить Easy Anti-Cheat.";
	error_windows_xp = "Требуется Windows XP или более новая версия.";
	error_windows_xp_64 = "64-разрядная Windows XP не поддерживается.";
	error_windows_xp_sp = "Установите Windows XP Service Pack 3, чтобы запустить Easy Anti-Cheat.";
	success_initialized = "Служба Easy Anti-Cheat запущена";
	success_loaded = "Служба Easy Anti-Cheat загружена в игре";
};
setup:
{
	btn_finish = "Финиш";
	btn_install = "Установить";
	btn_repair = "Помощь в восстановлении";
	btn_uninstall = "Удалить";
	epic_link = "© Epic Games, Inc";
	error_prefix = "Ошибка:";
	install_progress = "Установка...";
	install_success = "Установка выполнена";
	licenses_link = "Лицензии";
	privacy_link = "Конфиденциальность";
	repair_progress = "Восстановление...";
	title = "Установка сервиса Easy Anti-Cheat";
	uninstall_progress = "Удаление...";
	uninstall_success = "Удаление выполнено";
};
setup_error:
{
	error_cancelled = "Действие отменено пользователем";
	error_encrypted = "Папка, куда устанавливалась программа по предотвращению использования читов, зашифрована";
	error_intro = "Настройка Easy Anti-Cheat не удалась";
	error_not_installed = "Служба Easy Anti-Cheat не установлена.";
	error_registry = "Ошибка при копировании исполняемого файла";
	error_rights = "Не хватает привилегий";
	error_service = "Не удается создать службу";
	error_system = "Нет доступа к System32";
};
```

`eac/dist/EasyAntiCheat/Localization/th_th.cfg`:

```cfg
#----------------------------------------------------------
# Easy Anti-Cheat Localization File
#
# This file must use UTF-8 encoding.
#
# Each localization file should be named ll_CC.cfg where
# ll = ISO-639 code for language (e.g. "en")
# CC = ISO-3166 code for country (e.g. "US")
#----------------------------------------------------------

bugreport:
{
	btn_continue = "ปิดตัวเกม และไปที่วิธีการแก้ไขปัญหาแบบออนไลน์";
	btn_exit = "ปิดตัวเกม";
	btn_hidedetails = "ซ่อนรายละเอียด";
	btn_showdetails = "แสดงรายละเอียด";
	chk_sendreport = "ส่งรายงานข้อผิดพลาด";
	error_code = "รหัสข้อผิดพลาด:";
	lbl_body1 = "ขออภัยด้วย มีปัญหาเกิดขึ้นทำให้ไม่สามารถเริ่มต้นเกมได้";
	lbl_body2 = "กรุณาช่วยเรารายงานปัญหานี้";
	lbl_body3 = "Easy Anti-Cheat สามารถดำเนินการตรวจสอบวิธีการแก้ปัญหา เพื่อทำการแก้ปัญหาแบบออนไลน์ได้";
	lbl_header = "ไม่สามารถเริ่มต้นเกมได้";
	title = "การเปิดใช้มีข้อผิดพลาด";
};
game_error:
{
	error_catalogue_file = "เข้าถึงดัชนี EAC ผิดพลาด";
	error_catalogue_not_found = "ไม่พบดัชนี EAC";
	error_certificate_revoked = "ใบรับรองดัชนี EAC ถูกเพิกถอน";
	error_corrupted_memory = "ความจำวิบัติ";
	error_corrupted_network = "แพคเก็จโฟลว์วิบัติ";
	error_file_forbidden = "ไฟล์เกมที่ไม่รู้จัก";
	error_file_not_found = "ไฟล์ที่บังคับหายไป";
	error_file_version = "ไม่ทราบเวอร์ชันไฟล์";
	error_module_forbidden = "โมดูลไม่ได้รับอนุญาต";
	error_system_configuration = "โครงแบบระบบไม่ได้รับอนุญาต";
	error_system_version = "ไฟล์ระบบไม่ถูกเชื่อถือ";
	error_tool_forbidden = "เครื่องมือที่ไม่ได้รับอนุญาต";
	error_violation = "ป้องกันการทุจริตภายในผิดพลาด";
	error_virtual = "ไม่สามารถรันภายใต้เครื่องเสมือนจริง";
	peer_client_banned = "เพียร์การป้องกันการโกงถูกแบน";
	peer_heartbeat_rejected = "เพียร์โป้องกันการโกงถูกปฏิเสธ";
	peer_validated = "การตรวจสอบความถูกต้องของเพียร์การป้องกันการโกงเสร็จสมบูรณ์";
	peer_validation_failed = "การตรวจสอบความถูกต้องของเพียร์การป้องกันการโกงล้มเหลว";
	executable_not_hashed = "ไม่พบรายการเกมที่รันโปรแกรมได้ในแค็ตตาล็อก.";
};
launcher:
{
	btn_cancel = "ยกเลิก";
	btn_exit = "ออก";
	error_cancel = "การเปิดใช้ถูกยกเลิก";
	error_filenotfound = "ไม่พบไฟล์";
	error_init = "การเตรียมใช้งานมีข้อผิดพลาด";
	error_install = "การติดตั้งมีข้อผิดพลาด";
	error_launch = "การเปิดใช้มีข้อผิดพลาด";
	error_nolib = "โปรแกรมถ่ายวีดีโอที่สามารถใช้ร่วมกับ EAC ได้";
	loading = "กำลังโหลด";
	wait = "โปรดรอสักครู่";
	initializing = "กำลังเริ่มต้น";
	success_waiting_for_game = "กำลังรอเกม";
	success_closing = "สำเร็จ";
	network_error = "ข้อผิดพลาดของเครือข่าย";
	error_no_settings_file = "ไม่พบ {0}";
	error_invalid_settings_format = "{0} ไม่มีรูปแบบ JSON ที่ถูกต้อง";
	error_missing_required_field = "{0} ไม่มีช่องที่ต้องระบุ ({1})";
	download_progress = "ความคืบหน้าการดาวน์โหลด: {0}";
};
launcher_error:
{
	error_already_running = "กำลังรันแอปพลิเคชันที่มีการใช้ Easy Anti-Cheat!";
	error_application = "ไคล์เอ็นท์เกมพบข้อผิดพลาดในแอปพลิเคชัน";
	error_bad_exe_format = "ต้องใช้ระบบปฏิบัติการ 64 บิต";
	error_bitset_32 = "กรุณาใช้ 32-bit เวอร์ชันของเกม";
	error_bitset_64 = "กรุณาใช้ 64-bit เวอร์ชันของเกม";
	error_cancelled = "ปฏิบัติการถูกยกเลิกโดยผู้ใช้";
	error_certificate_validation = "การตรวจสอบความถูกต้องรหัสใบรับรองการลงชื่อเข้าระบบ Easy Anti-Cheat ผิดพลาด";
	error_client_auth_failed = "ไคลเอ็นต์เกมรับรองความถูกต้องของโปรแกรมป้องกันการโกงล้มเหลว และอาจไม่มีการป้องกันการโกงเปิดใช้งานอยู่";
	error_client_banned = "บัญชีเกมถูกแบนจากคุณสมบัติเกมออนไลน์ทั้งหมด";
	error_client_disconnected = "ไคลเอ็นต์เกมไม่ได้รันโปรแกรมป้องกันการโกง";
	error_client_violation = "ไคลเอ็นต์เกมตรวจสอบความสมบูรณ์ของรันไทม์ของโปรแกรมป้องกันการโกงล้มเหลว";
	error_connection = "การเชื่อมต่อเครือข่ายการกระจายเนื้อหาล้มเหว!";
	error_debugger = "Debugger ถูกตรวจพบ กรุณาปิดและลองอีกครั้ง";
	error_disk_space = "พื้นที่ว่างบนดิสก์ไม่เพียงพอ";
	error_dns = "DNS แก้ปัญหาเครือข่ายการกระจายเนื้อหา (Content Distribution Network) ล้มเหลว!";
	error_dotlocal = "การนำทางไปที่ DotLocal DLL ถูกตรวจพบ";
	error_dotlocal_instructions = "กรุณาลบไฟล์ต่อไปนี้";
	error_file_not_found = "ไม่พบไฟล์:";
	error_forbidden_tool = "กรุณาปิด {0} ก่อนเริ่มเกม";
	error_forbidden_driver = "โปรดยกเลิกการโหลด {0} ก่อนเริ่มเกม";
	error_generic = "ข้อผิดพลาดที่ไม่ได้คาดการณ์";
	error_kernel_debug = "Easy Anti-Cheat ไม่สามารถใช้งานได้ถ้า Kernel Debugging ถูกเปิดใช้งานอยู่";
	error_kernel_dse = "Easy Anti-Cheat ไม่สามารถทำงานได้ถ้าไดร์เวอร์ของสัญญาอนุญาติถูกปิด";
	error_kernel_modified = "การแก้ไขแกนกลางวินโดว์ถูกตรวจพบ";
	error_library_load = "โปรแกรมถ่ายวีดีโอที่สามารถใช้ร่วมกับ EAC ได้";
	error_memory = "ความจำไม่เพียงพอที่จะเริ่มต้นเกม";
	error_module_load = "โหลดโมดูลการป้องกันการทุจริตล้มเหลว";
	error_patched = "ตัวโหลดบูทแพทวินโดว์ถูกตรวจพบ";
	error_process = "ไม่สามารถสร้างการดำเนินการได้";
	error_process_crash = "กระบวนการยุติลงแบบกระทันหัน";
	error_safe_mode = "Easy Anti-Cheat ไม่สามารถรันใน Windows Safe Mode ได้";
	error_socket = "บางอย่างบล็อคแอปพลิเคชันจากการเข้าถึงอินเทอร์เน็ต!";
	error_ssl = "การเชื่อมต่อ SSL การติดตั้งกับบริการ CDN ผิดพลาด!";
	error_start = "เริ่มต้นเกมล้มเหลว";
	error_uncpath_forbidden = "ไม่สามารถรันเกมผ่านเครือข่ายที่ใช้ร่วมกันได้. (พาธ UNC)";
	error_missing_path = "ไม่พบพาธไฟล์สำหรับเปิดเกม";
	error_invalid_executable = "ไฟล์สำหรับเปิดเกมไม่ถูกต้อง: ";
	error_connection_failed = "การเชื่อมต่อล้มเหลว: ";
	error_module_not_found = "ไม่พบโมดูล Anti-Cheat";
	error_missing_game_id = "ไม่พบ ID เกม";
	error_dns_resolve_failed = "DNS แก้ไขเป็นพร็อกซีล้มเหลว";
	error_dns_connection_failed = "การเชื่อมต่อไปยัง Content Distribution Network ล้มเหลว! รหัส Curl: {0}!";
	error_http_response = "รหัสการตอบสนอง HTTP: {0} รหัส Curl: {1}";
	error_driver_handle = "ข้อผิดพลาดที่ไม่คาดคิด (การเปิดตัวจัดการไดรเวอร์ล้มเหลว)";
	error_incompatible_service = "มีบริการไดรเวอร์ Easy Anti-Cheat ที่เข้ากันไม่ได้กำลังใช้งานอยู่แล้ว โปรดออกจากเกมวิ่งอื่นหรือปิดแล้วเปิดใหม่";
	error_incompatible_driver_version = "มีเวอร์ชันไดรเวอร์ Easy Anti-Cheat ที่เข้ากันไม่ได้กำลังใช้งานอยู่แล้ว โปรดออกจากเกมวิ่งอื่นหรือปิดแล้วเปิดใหม่";
	error_restart_windows = "ข้อผิดพลาดที่ไม่คาดคิด (รีสตาร์ท Windows เพื่ออัปเดต EasyAntiCheat ให้เสร็จ)";
	error_another_launcher = "ข้อผิดพลาดที่ไม่คาดคิด (โปรแกรมเปิดใช้งานอื่นกำลังใช้งานอยู่แล้ว)";
	error_game_running = "ข้อผิดพลาดที่ไม่คาดคิด (เกมเปิดใช้งานอยู่แล้ว)";
	error_patched_boot_loader = "พบตัวโหลดการเริ่มต้นระบบของ Windows ที่แพตช์แล้ว (ปิดใช้งาน Kernel Patch Protection)";
	error_unknown_process = "ไคล์เอ็นเกมที่ไม่รู้จัก ไม่สามารถทำรายการต่อได้".;
	error_unknown_game = "ไม่มีการกำหนดค่าให้เกม จึงไม่สามารถดำเนินการต่อได้.";
	error_windows_vista_sp = "ติดตั้ง Windows Vista Service Pack 2 เพื่อรัน Easy Anti-Cheat.";
	error_windows_xp = "ต้องมี Windows XP หรือใหม่กว่า";
	error_windows_xp_64 = "ไม่รองรับ Windows XP 64-bit Edition ";
	error_windows_xp_sp = "ติดตั้ง Windows XP Service Pack 3 เพื่อรัน Easy Anti-Cheat.";
	success_initialized = "การเริ่มต้น Easy Anti-Cheat เสร็จสมบูรณ์แล้ว";
	success_loaded = "Easy Anti-Cheat ในเกมถูกโหลดเรียบร้อยแล้ว";
};
setup:
{
	btn_finish = "เสร็จ";
	btn_install = "ติดตั้งตอนนี้";
	btn_repair = "บริการซ่อมแซม";
	btn_uninstall = "ถอนการติดตั้ง";
	epic_link = "© Epic Games, Inc";
	error_prefix = "ข้อผิดพลาด:";
	install_progress = "กำลังติดตั้ง…";
	install_success = "ติดตั้งสำเร็จแล้ว";
	licenses_link = "ใบอนุญาต";
	privacy_link = "ความเป็นส่วนตัว";
	repair_progress = "กำลังซ่อมแซม";
	title = "Easy Anti-Cheat Service Setup";
	uninstall_progress = "กำลังถอนการติดตั้ง...";
	uninstall_success = "ถอนการติดตั้งสำเร็จแล้ว";
};
setup_error:
{
	error_cancelled = "ปฏิบัติการถูกยกเลิกโดยผู้ใช้";
	error_encrypted = "โฟลเดอร์ติดตั้ง Easy Anti-Cheat ได้รับการเข้ารหัสแล้ว";
	error_intro = "ติดตั้ง Easy Anti-Cheat ล้มเหลว";
	error_not_installed = "Easy Anti-Cheat ไม่ถูกติดตั้ง";
	error_registry = "บริการคัดลอกล้มเหลวปฏิบัติการ";
	error_rights = "เอกสิทธิ์ไม่เพียงพอ";
	error_service = "ไม่สามารถสร้างบริการได้";
	error_system = "เข้าถึง System32 ถูกปฏิเสธ";
};
```

`eac/dist/EasyAntiCheat/Localization/tr_tr.cfg`:

```cfg
#----------------------------------------------------------
# Easy Anti-Cheat Localization File
#
# This file must use UTF-8 encoding.
#
# Each localization file should be named ll_CC.cfg where
# ll = ISO-639 code for language (e.g. "en")
# CC = ISO-3166 code for country (e.g. "US")
#----------------------------------------------------------

bugreport:
{
	btn_continue = "Çözüm için internete bağlanın ve oyunu kapatın.";
	btn_exit = "Oyunu kapat.";
	btn_hidedetails = "Detayları gizle";
	btn_showdetails = "Detayları göster";
	chk_sendreport = "Hata raporu gönder";
	error_code = "Hata Kodu:";
	lbl_body1 = "Üzgünüz, oyun başlatılırken hata oluştu";
	lbl_body2 = "Bu hatayı raporlayarak çözmemize yardımcı olun.";
	lbl_body3 = "Easy Anti-Cheat çözüm için internete bağlanabilir.";
	lbl_header = "Oyun başlatılamadı";
	title = "Başlatma Hatası";
};
game_error:
{
	error_catalogue_file = "EAC dizinine erişim hatası";
	error_catalogue_not_found = "EAC dizini bulunamadı";
	error_certificate_revoked = "EAC dizini sertifikası geçersiz";
	error_corrupted_memory = "Bozuk hafıza";
	error_corrupted_network = "Bozuk paket akışı";
	error_file_forbidden = "Bilinmeyen oyun dosyası";
	error_file_not_found = "Önemli bir dosya eksik";
	error_file_version = "Bilinmiyen dosya sürümü";
	error_module_forbidden = "Yasak modül";
	error_system_configuration = "Yasaklanmış sistem ayarı";
	error_system_version = "Güvenli olmayan sistem dosyası";
	error_tool_forbidden = "Yasaklanmış araç";
	error_violation = "İçsel anti hile hatası";
	error_virtual = "Sanal makinede çalıştırılamaz.";
	peer_client_banned = "Anti-hile eşdüzey doğrulama yasaklandı.";
	peer_heartbeat_rejected = "Anti-hile eşdüzey doğrulama reddedildi.";
	peer_validated = "Anti-hile eşdüzey doğrulama tamamlandı.";
	peer_validation_failed = "Anti-hile eşdüzey doğrulama başarısız oldu.";
	executable_not_hashed = "Katalogda yürütülebilir oyun girdisi bulunamadı.";
};
launcher:
{
	btn_cancel = "İptal";
	btn_exit = "Çıkış";
	error_cancel = "Başlatma İptal";
	error_filenotfound = "Dosya Bulunamadı";
	error_init = "Başlatma Hatası";
	error_install = "Yükleme Hatası";
	error_launch = "Başlatma Hatası";
	error_nolib = "Easy Anti-Cheat kütüphanesi yüklenemedi";
	loading = "YÜKLENIYOR";
	wait = "Lütfen bekleyin";
	initializing = "BAŞLATILIYOR";
	success_waiting_for_game = "OYUN İÇİN BEKLENİYOR";
	success_closing = "Başarılı";
	network_error = "Ağ hatası";
	error_no_settings_file = "{0} bulunamadı";
	error_invalid_settings_format = "{0} geçerli bir JSON formatına sahip değil";
	error_missing_required_field = "{0} üzerinde gerekli bir alan eksik ({1})";
	download_progress = "İndirme İlerlemesi: {0}";
};
launcher_error:
{
	error_already_running = "Easy Anti-Cheat kullanan başka bir uygulama  çalışıyor!";
	error_application = "Oyun istemcisi bir uygulama hatasıyla karşılaştı.";
	error_bad_exe_format = "64 Bit İşletim Sistemi gereklidir";
	error_bitset_32 = "Oyunun 32-bit sürümünü kullanın";
	error_bitset_64 = "Oyunun 64-bit sürümünü kullanın";
	error_cancelled = "İşlem kullanıcı tarafından iptal edildi";
	error_certificate_validation = "Easy Anti-Cheat kod imza sertifikası doğrulama hatası";
	error_client_auth_failed = "Oyun istemcisi anti-hile yetkilendirmesinde başarısız ve anti-hile koruması etkinleştirilmemiş olabilir.";
	error_client_banned = "Oyun hesabı tüm çevrim içi oyun özelliklerinden yasaklandı.";
	error_client_disconnected = "Oyun istemcisi anti-hileyi çalıştırmıyor.";
	error_client_violation = "Oyun istemcisi, bir anti-hile işleyiş bütünlük kontrolünde başarısız oldu.";
	error_connection = "İçerik Dağıtım Ağı'na bağlanılamadı!";
	error_debugger = "Debugger saptandı. Lütfen onu silip tekrar deneyin";
	error_disk_space = "Yetersiz disk alanı.";
	error_dns = "İçerik Dağıtım Ağı için DNS çözümlemesi başarısız";
	error_dotlocal = "DotLocal DLL yönlendirme saptandı.";
	error_dotlocal_instructions = "Lütfen şu dosyayı silin";
	error_file_not_found = "Dosya bulunamadı:";
	error_forbidden_tool = "Oyunu başlatmadan önce {0} uygulamasını kapatın";
	error_forbidden_driver = "Lütfen oyunu başlatmadan önce {0} değerini kaldır";
	error_generic = "Beklenmeyen hata.";
	error_kernel_debug = "Kernel Debugger açıkken Easy Anti-Cheat çalıştırılamaz";
	error_kernel_dse = "Sürücü İmza Zorunluluğu devre dışıysa Easy Anti-Cheat çalıştırılamaz";
	error_kernel_modified = "Yasaklanmış Windows kernel modifikasyonu saptandı";
	error_library_load = "Easy Anti-Cheat kütüphanesi yüklenemedi";
	error_memory = "Oyunu başlatmak için hafıza yetersiz";
	error_module_load = "Anti hile modülü yüklemesi başarısız";
	error_patched = "Yamalı Windows yükleyici saptandı";
	error_process = "İşlem oluşturulamadı";
	error_process_crash = "İşlem sonlandırıldı";
	error_safe_mode = "Easy Anti-Cheat, Windows Güvenli Kipte çalıştırılamaz";
	error_socket = "Uygulamanın internete erişimini engelleyen bir şeyler var!";
	error_ssl = "CDN hizmetiyle SSL bağlantısı kurulamadı";
	error_start = "Oyunu başlatma başarısız";
	error_uncpath_forbidden = "Oyun ağ paylaşımı aracılığıyla başlatılamaz. (UNC yolu)";
	error_missing_path = "Oyunun çalıştırılabilir dosya yolu eksik";
	error_invalid_executable = "Oyunun çalıştırılabilir dosyası geçersiz: ";
	error_connection_failed = "Bağlantı başarısız: ";
	error_module_not_found = "Anti-Cheat modülü bulunamadı";
	error_missing_game_id = "Oyun kimliği eksik";
	error_dns_resolve_failed = "DNS proxy çözümlemesi başarısız";
	error_dns_connection_failed = "İçerik Dağıtım Ağına bağlantı başarısız! Döngü Kodu: {0}!";
	error_http_response = "HTTP Yanıt Kodu: {0} Döngü Kodu: {1}";
	error_driver_handle = "Beklenmedik hata. (Sürücü tanıtıcısı açılamadı)";
	error_incompatible_service = "Uyumsuz bir Easy Anti-Cheat hizmeti zaten çalışıyor. Lütfen çalışan diğer tüm oyunları kapat veya yeniden başlat";
	error_incompatible_driver_version = "Uyumsuz bir Easy Anti-Cheat sürücü sürümü zaten çalışıyor. Lütfen çalışan diğer tüm oyunları kapat veya yeniden başlat";
	error_restart_windows = "Beklenmedik hata. (EasyAntiCheat güncellemesini tamamlamak için Windows'u yeniden başlat)";
	error_another_launcher = "Beklenmedik hata. (Zaten başka bir başlatıcı çalışıyor)";
	error_game_running = "Beklenmedik hata. (Oyun zaten çalışıyor)";
	error_patched_boot_loader = "Yamalı Windows önyükleme yöneticisi tespit edildi. (Kernel Yama Koruması devre dışı)";
	error_unknown_process = "Tanınmayan oyun istemcisi. Devam edilemiyor.";
	error_unknown_game = "Yapılandırılmamış oyun. Devam edilemiyor.";
	error_windows_vista_sp = "Easy Anti-Cheat'i çalıştırmak için Windows Vista Service Pack 2'yi yükleyin.";
	error_windows_xp = "Windows XP veya daha yeni bir işletim sistemi gerekmektedir.";
	error_windows_xp_64 = "Windows XP 64 bit desteklenmemektedir.";
	error_windows_xp_sp = "Easy Anti-Cheat'i çalıştırmak için Windows XP Service Pack 3'ü yükleyin.";
	success_initialized = "Easy Anti-Cheat başarıyla başlatıldı";
	success_loaded = "Easy Anti-Cheat sisteme başarıyla yüklendi";
};
setup:
{
	btn_finish = "Bitir";
	btn_install = "Hemen Yükle";
	btn_repair = "Onar";
	btn_uninstall = "Yüklemeyi Kaldır";
	epic_link = "© Epic Games, Inc";
	error_prefix = "Hata:";
	install_progress = "Yükleniyor…";
	install_success = "Yükleme Başarılı";
	licenses_link = "Lisanslar";
	privacy_link = "Gizlilik";
	repair_progress = "Onarılıyor…";
	title = "Easy Anti-Cheat Hizmet Kurulumu";
	uninstall_progress = "Yükleme Kaldırılıyor…";
	uninstall_success = "Kaldırma Başarılı";
};
setup_error:
{
	error_cancelled = "İşlem kullanıcı tarafından iptal edildi";
	error_encrypted = "Easy Anti-Cheat yükleme klasörü şifrelendi";
	error_intro = "Easy Anti-Cheat Kurulumu Başarısız";
	error_not_installed = "Easy Anti-Cheat kurulu değil";
	error_registry = "Kayıt defterine erişim engellendi";
	error_rights = "Yetersiz İzinler";
	error_service = "Hizmet oluşturulamıyor";
	error_system = "System32'ye erişim engellendi";
};
```

`eac/dist/EasyAntiCheat/Localization/zh_cn.cfg`:

```cfg
#----------------------------------------------------------
# Easy Anti-Cheat Localization File
#
# This file must use UTF-8 encoding.
#
# Each localization file should be named ll_CC.cfg where
# ll = ISO-639 code for language (e.g. "en")
# CC = ISO-3166 code for country (e.g. "US")
#----------------------------------------------------------

bugreport:
{
	btn_continue = "在线检查解决方案并关闭游戏。";
	btn_exit = "关闭游戏。";
	btn_hidedetails = "隐藏详情";
	btn_showdetails = "显示详情";
	chk_sendreport = "发送错误报告";
	error_code = "错误代码：";
	lbl_body1 = "很抱歉，在启动你的游戏时遇到了问题。";
	lbl_body2 = "请通过报告问题帮助我们解决。";
	lbl_body3 = "Easy Anti-Cheat 可以在线检查有此问题的解决方案，并试着协助解决。";
	lbl_header = "无法启动游戏";
	title = "启动错误";
};
game_error:
{
	error_catalogue_file = "EAC 索引访问错误";
	error_catalogue_not_found = "未找到 EAC 索引";
	error_certificate_revoked = "EAC 索引证书已撤销";
	error_corrupted_memory = "内存损坏";
	error_corrupted_network = "数据包流损坏";
	error_file_forbidden = "未知的游戏文件";
	error_file_not_found = "缺少必需的文件";
	error_file_version = "未知的文件版本";
	error_module_forbidden = "禁止的模块";
	error_system_configuration = "禁止的系统配置";
	error_system_version = "不受信任的系统文件";
	error_tool_forbidden = "禁止的工具";
	error_violation = "内部反作弊错误";
	error_virtual = "无法在虚拟机下运行。";
	peer_client_banned = "反作弊对等程序被禁止。";
	peer_heartbeat_rejected = "反作弊对等程序被拒绝。";
	peer_validated = "反作弊对等验证完成。";
	peer_validation_failed = "反作弊对等验证失败。";
	executable_not_hashed = "无法在目录中找到游戏可执行条目。";
};
launcher:
{
	btn_cancel = "取消";
	btn_exit = "退出";
	error_cancel = "启动取消";
	error_filenotfound = "文件未找到";
	error_init = "初始化错误";
	error_install = "安装错误";
	error_launch = "启动错误";
	error_nolib = "无法加载 Easy Anti-Cheat 库";
	loading = "载入中";
	wait = "请稍候";
	initializing = "正在初始化";
	success_waiting_for_game = "等待游戏窗口";
	success_closing = "等待游戏窗口";
	network_error = "网络";
	error_no_settings_file = "{0} 未找到";
	error_invalid_settings_format = "{0} 没有有效的 JSON 格式";
	error_missing_required_field = "{0} 缺失必要字段（{1}）";
	download_progress = "下载进程： {0}";
};
launcher_error:
{
	error_already_running = "使用 Easy Anti-Cheat 的应用程序已在运行中！";
	error_application = "游戏客户端遇到应用程序错误。";
	error_bad_exe_format = "需要 64 位操作系统";
	error_bitset_32 = "请使用游戏的32位版本";
	error_bitset_64 = "请使用游戏的64位版本";
	error_cancelled = "操作已由用户取消";
	error_certificate_validation = "验证 Easy Anti-Cheat 代码签名证书时出错";
	error_client_auth_failed = "游戏客户端未能通过反作弊验证，并可能未激活反作弊保护。";
	error_client_banned = "游戏帐户已被禁止所有在线游戏功能。";
	error_client_disconnected = "游戏客户端没有运行反作弊程序。";
	error_client_violation = "游戏客户端未能通过反作弊运行完整性检查。";
	error_connection = "连接到内容分发网络失败！";
	error_debugger = "检测到调试程序。请取消载入，然后重试";
	error_disk_space = "磁盘空间不足。";
	error_dns = "DNS 解析到内容分发网络失败！";
	error_dotlocal = "检测到 DotLocal DLL 重定向。";
	error_dotlocal_instructions = "请删除以下文件";
	error_file_not_found = "文件未找到：";
	error_forbidden_tool = "请在开始游戏前关闭{0}";
	error_forbidden_driver = "请在启动游戏前卸载 {0}";
	error_generic = "意外错误。";
	error_kernel_debug = "如果启用了内核调试，Easy Anti-Cheat 将无法运行";
	error_kernel_dse = "如果禁用了驱动程序强制签名，Easy Anti-Cheat 将无法运行";
	error_kernel_modified = "检测到禁止的 Windows 内核修改";
	error_library_load = "无法加载 Easy Anti-Cheat 库";
	error_memory = "内存不足，无法启动游戏";
	error_module_load = "无法加载反作弊模块";
	error_patched = "检测到经过修补的 Windows 启动加载程序";
	error_process = "无法创建进程";
	error_process_crash = "进程突然终止";
	error_safe_mode = "Easy Anti-Cheat 无法在 Windows 安全模式下运行";
	error_socket = "有什么东西阻止应用程序访问互联网！";
	error_ssl = "与 CDN 服务建立 SSL 连接时出错！";
	error_start = "无法启动游戏";
	error_uncpath_forbidden = "无法通过网络共享运行游戏。（UNC 路径）";
	error_missing_path = "缺失游戏可执行文件路径";
	error_invalid_executable = "无效游戏可执行文件: ";
	error_connection_failed = "连接失败: ";
	error_module_not_found = "未找到 Anti-Cheat 反作弊模块";
	error_missing_game_id = "缺失游戏账号";
	error_dns_resolve_failed = "DNS 代理解析失败";
	error_dns_connection_failed = "内容分发网络连接失败！错误代码：{0}!";
	error_http_response = "HTTP 响应代码：{0} 错误代码：{1}";
	error_driver_handle = "意外错误。（无法打开驱动程序句柄）";
	error_incompatible_service = "已有不兼容的 Easy Anti-Cheat 服务在运行中。请退出其他正在运行的游戏，或重新启动";
	error_incompatible_driver_version = "已有不兼容的 Easy Anti-Cheat 驱动程序版本在运行中。请退出其他正在运行的游戏，或重新启动";
	error_restart_windows = "意外错误。（重新启动 Windows 以完成 EasyAntiCheat 反作弊更新）";
	error_another_launcher = "意外错误。（另一个启动器已经在运行）";
	error_game_running = "意外错误。（游戏已经在运行）";
	error_patched_boot_loader = "检测到修复的 Windows 引导加载程序。 （内核补丁保护已禁用）";
	error_unknown_process = "无法识别的游戏客户端。无法继续。";
	error_unknown_game = "游戏未配置。无法继续。";
	error_windows_vista_sp = "安装 Windows Vista Service Pack 2 以运行 Easy Anti-Cheat。";
	error_windows_xp = "需要 Windows XP 或更高版本。";
	error_windows_xp_64 = "不支持 Windows XP 64 位版本。";
	error_windows_xp_sp = "安装 Windows XP Service Pack 3 以运行 Easy Anti-Cheat。";
	success_initialized = "Easy Anti-Cheat 成功初始化";
	success_loaded = "Easy Anti-Cheat 在游戏中成功加载";
};
setup:
{
	btn_finish = "完成";
	btn_install = "立即安装";
	btn_repair = "修复服务";
	btn_uninstall = "卸载";
	epic_link = "© Epic Games, Inc";
	error_prefix = "错误：";
	install_progress = "正在安装……";
	install_success = "成功安装";
	licenses_link = "许可证";
	privacy_link = "隐私";
	repair_progress = "正在修复……";
	title = "Easy Anti-Cheat服务安装";
	uninstall_progress = "正在卸载……";
	uninstall_success = "成功卸载";
};
setup_error:
{
	error_cancelled = "操作已由用户取消";
	error_encrypted = "Easy Anti-Cheat (防作弊）安装文件夹已加密";
	error_intro = "Easy Anti-Cheat 设置失败";
	error_not_installed = "未安装 Easy Anti-Cheat。";
	error_registry = "复制服务可执行文件失败（32）";
	error_rights = "权限不足";
	error_service = "无法创建服务";
	error_system = "访问 System32 被拒绝";
};
```

`eac/dist/EasyAntiCheat/Localization/zh_tw.cfg`:

```cfg
#----------------------------------------------------------
# Easy Anti-Cheat Localization File
#
# This file must use UTF-8 encoding.
#
# Each localization file should be named ll_CC.cfg where
# ll = ISO-639 code for language (e.g. "en")
# CC = ISO-3166 code for country (e.g. "US")
#----------------------------------------------------------

bugreport:
{
	btn_continue = "線上檢查解決方案並關閉遊戲。";
	btn_exit = "關閉遊戲。";
	btn_hidedetails = "隱藏詳情";
	btn_showdetails = "顯示詳情";
	chk_sendreport = "送出錯誤報告";
	error_code = "錯誤代碼：";
	lbl_body1 = "很抱歉，在啟動你的遊戲時遇到了問題。";
	lbl_body2 = "請透過報告問題幫助我們解決。";
	lbl_body3 = "Easy Anti-Cheat 可以線上檢查有此問題的解決方案，並試著協助解決。";
	lbl_header = "無法啟動遊戲";
	title = "啟動錯誤";
};
game_error:
{
	error_catalogue_file = "EAC 索引存取錯誤";
	error_catalogue_not_found = "未找到 EAC 索引";
	error_certificate_revoked = "EAC 索引證書已撤銷";
	error_corrupted_memory = "記憶體損壞";
	error_corrupted_network = "資料包流損壞";
	error_file_forbidden = "未知的遊戲檔";
	error_file_not_found = "缺少必需的文件";
	error_file_version = "未知的檔案版本";
	error_module_forbidden = "禁止的模組";
	error_system_configuration = "禁止的系統組態";
	error_system_version = "不受信任的系統檔";
	error_tool_forbidden = "禁止的工具";
	error_violation = "內部反作弊錯誤";
	error_virtual = "無法在虛擬機器下運行。";
	peer_client_banned = "反作弊同伴已禁止。";
	peer_heartbeat_rejected = "反作弊同伴已拒絕。";
	peer_validated = "反作弊同伴核驗已完成。";
	peer_validation_failed = "反作弊同伴核驗已失敗。";
	executable_not_hashed = "在本目錄中找不到遊戲執行檔。";
};
launcher:
{
	btn_cancel = "取消";
	btn_exit = "退出";
	error_cancel = "啟動取消";
	error_filenotfound = "檔案未找到";
	error_init = "初始化錯誤";
	error_install = "安裝錯誤";
	error_launch = "啟動錯誤";
	error_nolib = "無法載入 Easy Anti-Cheat 庫";
	loading = "載入中";
	wait = "請稍候";
	initializing = "正在初始化";
	success_waiting_for_game = "等待遊戲中";
	success_closing = "成功";
	network_error = "網路錯誤";
	error_no_settings_file = "找不到 {0}";
	error_invalid_settings_format = "{0} 沒有有效的 JSON 格式";
	error_missing_required_field = "必要檔案（{1}）中缺少 {0}";
	download_progress = "下載進度： {0}";
};
launcher_error:
{
	error_already_running = "使用 Easy Anti-Cheat 的應用程式已在運行中！";
	error_application = "遊戲使用者端遇到應用程式錯誤。";
	error_bad_exe_format = "需要 64 位元作業系統";
	error_bitset_32 = "請使用遊戲的32位版本";
	error_bitset_64 = "請使用遊戲的64位版本";
	error_cancelled = "操作已由使用者取消";
	error_certificate_validation = "驗證 Easy Anti-Cheat 代碼簽章憑證時出錯";
	error_client_auth_failed = "遊戲用戶端已經令防作弊認證失敗，可能沒有啟用防作弊保護。";
	error_client_banned = "該遊戲賬戶已被禁所有線上遊戲功能。";
	error_client_disconnected = "遊戲用戶端未運行防作弊軟體。";
	error_client_violation = "遊戲用戶端令反作弊運行時完好性檢查失敗。";
	error_connection = "連線內容分發網路失敗！";
	error_debugger = "檢測到偵錯工具。請取消載入，然後重試";
	error_disk_space = "磁碟空間不足。";
	error_dns = "DNS 解析到內容分發網路失敗！";
	error_dotlocal = "檢測到 DotLocal DLL 重定向。";
	error_dotlocal_instructions = "請刪除以下檔案";
	error_file_not_found = "檔案未找到：";
	error_forbidden_tool = "請在開始遊戲前關閉{0}";
	error_forbidden_driver = "請在啟動遊戲前卸載 {0}";
	error_generic = "意外錯誤。";
	error_kernel_debug = "若啟用了內核調試，Easy Anti-Cheat 將無法運行";
	error_kernel_dse = "若停用了驅動程式強制簽名，Easy Anti-Cheat 將無法運行";
	error_kernel_modified = "檢測到禁止的 Windows 內核修改";
	error_library_load = "無法載入 Easy Anti-Cheat 庫";
	error_memory = "記憶體不足，無法啟動遊戲";
	error_module_load = "無法載入反作弊模組";
	error_patched = "檢測到經過修補的 Windows 開機載入程式";
	error_process = "無法建立進程";
	error_process_crash = "進程突然終止";
	error_safe_mode = "Easy Anti-Cheat 無法在 Windows 安全模式下運行";
	error_socket = "有什麼東西阻止應用程式存取網際網路！";
	error_ssl = "與 CDN 服務建立 SSL 連線時出錯！";
	error_start = "無法啟動遊戲";
	error_uncpath_forbidden = "無法透過網路共享執行遊戲。（UNC 路徑）";
	error_missing_path = "找不到遊戲執行檔路徑";
	error_invalid_executable = "無效的遊戲執行檔: ";
	error_connection_failed = "連線失敗: ";
	error_module_not_found = "找不到 Anti-Cheat 模組";
	error_missing_game_id = "找不到遊戲 id";
	error_dns_resolve_failed = "DNS 解析為代理失敗";
	error_dns_connection_failed = "連結至內容傳遞網路失敗！Curl 碼：{0}!";
	error_http_response = "HTTP 回應碼：{0} Curl 碼：{1}";
	error_driver_handle = "發生非預期的錯誤。（開啟 driver handle 失敗）";
	error_incompatible_service = "有版本不相容的 Easy Anti-Cheat 服務已在執行中，請退出其他正在執行的遊戲或重新啟動。";
	error_incompatible_driver_version = "有版本不相容的 Easy Anti-Cheat 驅動程式已在執行中，請退出其他正在執行的遊戲或重新啟動。";
	error_restart_windows = "發生非預期的錯誤。（重新啟動 Windows 以完成 EasyAntiCheat 更新）";
	error_another_launcher = "發生非預期的錯誤。（另一個啟動器已在執行）";
	error_game_running = "發生非預期的錯誤。（遊戲已在執行）";
	error_patched_boot_loader = "偵測到 Patched Windows 啟動程式。（Kernel Patch Protection 已停用）";
	error_unknown_process = "無法識別的遊戲使用者端。無法繼續。";
	error_unknown_game = "遊戲未設定，無法繼續。";
	error_windows_vista_sp = "安裝 Windows Vista Service Pack 2 以運行 Easy Anti-Cheat。";
	error_windows_xp = "需要 Windows XP 或更高版本。";
	error_windows_xp_64 = "不支援 Windows XP 64 位版本。";
	error_windows_xp_sp = "安裝 Windows XP Service Pack 3 以運行 Easy Anti-Cheat。";
	success_initialized = "Easy Anti-Cheat 成功初始化";
	success_loaded = "Easy Anti-Cheat 在遊戲中成功載入";
};
setup:
{
	btn_finish = "完成";
	btn_install = "立即安裝";
	btn_repair = "修復服務";
	btn_uninstall = "卸載";
	epic_link = "© Epic Games, Inc";
	error_prefix = "錯誤：";
	install_progress = "安裝中……";
	install_success = "成功安裝";
	licenses_link = "授權協議";
	privacy_link = "私隱";
	repair_progress = "修復中……";
	title = "Easy Anti-Cheat服務安裝";
	uninstall_progress = "卸載中……";
	uninstall_success = "成功卸載";
};
setup_error:
{
	error_cancelled = "操作已由使用者取消";
	error_encrypted = "「Easy Anti-Cheat」安裝資料夾遭到鎖碼";
	error_intro = "Easy Anti-Cheat 設定失敗";
	error_not_installed = "未安裝 Easy Anti-Cheat。";
	error_registry = "存取註冊表被拒絕";
	error_rights = "許可權不足";
	error_service = "無法建立服務";
	error_system = "存取 System32 被拒絕";
};
```

`eac/dist/EasyAntiCheat/Settings - voice.json`:

```json
{
	"title"											: "Chat Client",
	"executable"									: "chat-client.exe",
	"productid"										: "68c34eac386842d580e0c6aca47ffc1b",
	"sandboxid"										: "f1f0c6067b5d4b39a564da438f3cfc64",
	"deploymentid"									: "8a51305f324e43d498e255f433ebed1e",
	"requested_splash"								: "EasyAntiCheat\\Splash.png",
	"wait_for_game_process_exit"					: "false"
}

```

`eac/dist/EasyAntiCheat/Settings.json`:

```json
{
	"title"											: "Chat Client",
	"executable"									: "chat-client.exe",
	"productid"										: "5f178ca5fb3148029c3cda7a444c4189",
	"sandboxid"										: "7367853f2d994ef3804c71e3a667d6dc",
	"deploymentid"									: "91fae83fbc3b4264a8d0044a54440ba0",
	"requested_splash"								: "EasyAntiCheat\\Splash.png",
	"wait_for_game_process_exit"					: "false"
}

```

`eac/sdk/Include/Linux/eos_Linux_base.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

/********************************************************************
 * Provided to allow EOS_BUILD_PLATFORM_NAME to be defined even for
 * platforms that do not require it when using eos_platform_prereqs.h
 ********************************************************************/
```

`eac/sdk/Include/Mac/eos_Mac_base.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

/********************************************************************
 * Provided to allow EOS_BUILD_PLATFORM_NAME to be defined even for
 * platforms that do not require it when using eos_platform_prereqs.h
 ********************************************************************/
```

`eac/sdk/Include/Windows/eos_Windows.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_types.h"

#pragma pack(push, 8)
/** The most recent version of the EOS_Windows_RTCOptions structure. */
#define EOS_WINDOWS_RTCOPTIONS_API_LATEST 1

/**
 * Options for initializing rtc functionality required for some platforms.
 */
EOS_STRUCT(EOS_Windows_RTCOptions, (
	/** API Version: Set this to EOS_WINDOWS_RTCOPTIONS_API_LATEST. */
	int32_t ApiVersion;

	/** The absolute path to a `xaudio2_9redist.dll` dependency, including the file name */
	const char* XAudio29DllPath;
));

#pragma pack(pop)

```

`eac/sdk/Include/Windows/eos_Windows_base.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

/********************************************************************
 * Provided to allow EOS_BUILD_PLATFORM_NAME to be defined even for
 * platforms that do not require it when using eos_platform_prereqs.h
 ********************************************************************/
```

`eac/sdk/Include/eos_achievements.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_achievements_types.h"

/**
 * The following EOS_Achievements_* functions allow you to query existing achievement definitions that have been defined for your application.
 * You can also query achievement progress data for users.
 * In addition, you can also unlock one or more achievements directly.
 * You can also receive notifications when achievements are unlocked.
 */

/**
 * Query for a list of definitions for all existing achievements, including localized text, icon IDs and whether an achievement is hidden.
 *
 * @note When the Social Overlay is enabled then this will be called automatically.  The Social Overlay is enabled by default (see EOS_PF_DISABLE_SOCIAL_OVERLAY).
 *
 * @param Options Structure containing information about the application whose achievement definitions we're retrieving.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate This function is called when the query definitions operation completes.
 *
 * @return EOS_Success if the operation completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 */
EOS_DECLARE_FUNC(void) EOS_Achievements_QueryDefinitions(EOS_HAchievements Handle, const EOS_Achievements_QueryDefinitionsOptions* Options, void* ClientData, const EOS_Achievements_OnQueryDefinitionsCompleteCallback CompletionDelegate);

/**
 * Fetch the number of achievement definitions that are cached locally.
 *
 * @param Options The Options associated with retrieving the achievement definition count
 *
 * @see EOS_Achievements_CopyAchievementDefinitionByIndex
 *
 * @return Number of achievement definitions or 0 if there is an error
 */
EOS_DECLARE_FUNC(uint32_t) EOS_Achievements_GetAchievementDefinitionCount(EOS_HAchievements Handle, const EOS_Achievements_GetAchievementDefinitionCountOptions* Options);

/**
 * Fetches an achievement definition from a given index.
 *
 * @param Options Structure containing the index being accessed
 * @param OutDefinition The achievement definition for the given index, if it exists and is valid, use EOS_Achievements_Definition_Release when finished
 *
 * @see EOS_Achievements_DefinitionV2_Release
 *
 * @return EOS_Success if the information is available and passed out in OutDefinition
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the achievement definition is not found
 *         EOS_Invalid_ProductUserID if any of the userid options are incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Achievements_CopyAchievementDefinitionV2ByIndex(EOS_HAchievements Handle, const EOS_Achievements_CopyAchievementDefinitionV2ByIndexOptions* Options, EOS_Achievements_DefinitionV2 ** OutDefinition);

/**
 * Fetches an achievement definition from a given achievement ID.
 *
 * @param Options Structure containing the achievement ID being accessed
 * @param OutDefinition The achievement definition for the given achievement ID, if it exists and is valid, use EOS_Achievements_Definition_Release when finished
 *
 * @see EOS_Achievements_DefinitionV2_Release
 *
 * @return EOS_Success if the information is available and passed out in OutDefinition
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the achievement definition is not found
 *         EOS_Invalid_ProductUserID if any of the userid options are incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Achievements_CopyAchievementDefinitionV2ByAchievementId(EOS_HAchievements Handle, const EOS_Achievements_CopyAchievementDefinitionV2ByAchievementIdOptions* Options, EOS_Achievements_DefinitionV2 ** OutDefinition);

/**
 * Query for a list of achievements for a specific player, including progress towards completion for each achievement.
 *
 * @note When the Social Overlay is enabled then this will be called automatically.  The Social Overlay is enabled by default (see EOS_PF_DISABLE_SOCIAL_OVERLAY).
 *
 * @param Options Structure containing information about the player whose achievements we're retrieving.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate This function is called when the query player achievements operation completes.
 *
 * @return EOS_Success if the operation completes successfully
 *         EOS_Invalid_ProductUserID if any of the userid options are incorrect
 *         EOS_InvalidParameters if any of the other options are incorrect
 */
EOS_DECLARE_FUNC(void) EOS_Achievements_QueryPlayerAchievements(EOS_HAchievements Handle, const EOS_Achievements_QueryPlayerAchievementsOptions* Options, void* ClientData, const EOS_Achievements_OnQueryPlayerAchievementsCompleteCallback CompletionDelegate);

/**
 * Fetch the number of player achievements that are cached locally.
 *
 * @param Options The Options associated with retrieving the player achievement count
 *
 * @see EOS_Achievements_CopyPlayerAchievementByIndex
 *
 * @return Number of player achievements or 0 if there is an error
 */
EOS_DECLARE_FUNC(uint32_t) EOS_Achievements_GetPlayerAchievementCount(EOS_HAchievements Handle, const EOS_Achievements_GetPlayerAchievementCountOptions* Options);

/**
 * Fetches a player achievement from a given index.
 *
 * @param Options Structure containing the Product User ID and index being accessed
 * @param OutAchievement The player achievement data for the given index, if it exists and is valid, use EOS_Achievements_PlayerAchievement_Release when finished
 *
 * @see EOS_Achievements_PlayerAchievement_Release
 *
 * @return EOS_Success if the information is available and passed out in OutAchievement
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the player achievement is not found
 *         EOS_Invalid_ProductUserID if you pass an invalid user ID
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Achievements_CopyPlayerAchievementByIndex(EOS_HAchievements Handle, const EOS_Achievements_CopyPlayerAchievementByIndexOptions* Options, EOS_Achievements_PlayerAchievement ** OutAchievement);

/**
 * Fetches a player achievement from a given achievement ID.
 *
 * @param Options Structure containing the Product User ID and achievement ID being accessed
 * @param OutAchievement The player achievement data for the given achievement ID, if it exists and is valid, use EOS_Achievements_PlayerAchievement_Release when finished
 *
 * @see EOS_Achievements_PlayerAchievement_Release
 *
 * @return EOS_Success if the information is available and passed out in OutAchievement
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the player achievement is not found
 *         EOS_Invalid_ProductUserID if you pass an invalid user ID
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Achievements_CopyPlayerAchievementByAchievementId(EOS_HAchievements Handle, const EOS_Achievements_CopyPlayerAchievementByAchievementIdOptions* Options, EOS_Achievements_PlayerAchievement ** OutAchievement);

/**
 * Unlocks a number of achievements for a specific player.
 *
 * @param Options Structure containing information about the achievements and the player whose achievements we're unlocking.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate This function is called when the unlock achievements operation completes.
 *
 * @return EOS_Success if the operation completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 */
EOS_DECLARE_FUNC(void) EOS_Achievements_UnlockAchievements(EOS_HAchievements Handle, const EOS_Achievements_UnlockAchievementsOptions* Options, void* ClientData, const EOS_Achievements_OnUnlockAchievementsCompleteCallback CompletionDelegate);

/**
 * Register to receive achievement unlocked notifications.
 * @note must call EOS_Achievements_RemoveNotifyAchievementsUnlocked to remove the notification
 *
 * @see EOS_Achievements_RemoveNotifyAchievementsUnlocked
 *
 * @param Options Structure containing information about the achievement unlocked notification
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param NotificationFn A callback that is fired when an achievement unlocked notification for a user has been received
 *
 * @return handle representing the registered callback
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_Achievements_AddNotifyAchievementsUnlockedV2(EOS_HAchievements Handle, const EOS_Achievements_AddNotifyAchievementsUnlockedV2Options* Options, void* ClientData, const EOS_Achievements_OnAchievementsUnlockedCallbackV2 NotificationFn);

/**
 * Unregister from receiving achievement unlocked notifications.
 *
 * @see EOS_Achievements_AddNotifyAchievementsUnlocked
 *
 * @param InId Handle representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_Achievements_RemoveNotifyAchievementsUnlocked(EOS_HAchievements Handle, EOS_NotificationId InId);

/**
 * DEPRECATED! Use EOS_Achievements_CopyAchievementDefinitionV2ByIndex instead.
 *
 * Fetches an achievement definition from a given index.
 *
 * @param Options Structure containing the index being accessed
 * @param OutDefinition The achievement definition for the given index, if it exists and is valid, use EOS_Achievements_Definition_Release when finished
 *
 * @see EOS_Achievements_CopyAchievementDefinitionV2ByIndex
 * @see EOS_Achievements_Definition_Release
 *
 * @return EOS_Success if the information is available and passed out in OutDefinition
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the achievement definition is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Achievements_CopyAchievementDefinitionByIndex(EOS_HAchievements Handle, const EOS_Achievements_CopyAchievementDefinitionByIndexOptions* Options, EOS_Achievements_Definition ** OutDefinition);

/**
 * DEPRECATED! Use EOS_Achievements_CopyAchievementDefinitionV2ByAchievementId instead.
 *
 * Fetches an achievement definition from a given achievement ID.
 *
 * @param Options Structure containing the achievement ID being accessed
 * @param OutDefinition The achievement definition for the given achievement ID, if it exists and is valid, use EOS_Achievements_Definition_Release when finished
 *
 * @see EOS_Achievements_Definition_Release
 * @see EOS_Achievements_CopyAchievementDefinitionV2ByAchievementId
 *
 * @return EOS_Success if the information is available and passed out in OutDefinition
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the achievement definition is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Achievements_CopyAchievementDefinitionByAchievementId(EOS_HAchievements Handle, const EOS_Achievements_CopyAchievementDefinitionByAchievementIdOptions* Options, EOS_Achievements_Definition ** OutDefinition);

/**
 * DEPRECATED! Use EOS_Achievements_GetPlayerAchievementCount, EOS_Achievements_CopyPlayerAchievementByIndex and filter for unlocked instead.
 *
 * Fetch the number of unlocked achievements that are cached locally.
 *
 * @param Options The Options associated with retrieving the unlocked achievement count
 *
 * @see EOS_Achievements_CopyUnlockedAchievementByIndex
 *
 * @return Number of unlocked achievements or 0 if there is an error
 */
EOS_DECLARE_FUNC(uint32_t) EOS_Achievements_GetUnlockedAchievementCount(EOS_HAchievements Handle, const EOS_Achievements_GetUnlockedAchievementCountOptions* Options);

/**
 * DEPRECATED! Use EOS_Achievements_CopyPlayerAchievementByAchievementId instead.
 *
 * Fetches an unlocked achievement from a given index.
 *
 * @param Options Structure containing the Product User ID and index being accessed
 * @param OutAchievement The unlocked achievement data for the given index, if it exists and is valid, use EOS_Achievements_UnlockedAchievement_Release when finished
 *
 * @see EOS_Achievements_UnlockedAchievement_Release
 *
 * @return EOS_Success if the information is available and passed out in OutAchievement
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the unlocked achievement is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Achievements_CopyUnlockedAchievementByIndex(EOS_HAchievements Handle, const EOS_Achievements_CopyUnlockedAchievementByIndexOptions* Options, EOS_Achievements_UnlockedAchievement ** OutAchievement);

/**
 * DEPRECATED! Use EOS_Achievements_CopyPlayerAchievementByAchievementId instead.
 *
 * Fetches an unlocked achievement from a given achievement ID.
 *
 * @param Options Structure containing the Product User ID and achievement ID being accessed
 * @param OutAchievement The unlocked achievement data for the given achievement ID, if it exists and is valid, use EOS_Achievements_UnlockedAchievement_Release when finished
 *
 * @see EOS_Achievements_UnlockedAchievement_Release
 *
 * @return EOS_Success if the information is available and passed out in OutAchievement
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the unlocked achievement is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Achievements_CopyUnlockedAchievementByAchievementId(EOS_HAchievements Handle, const EOS_Achievements_CopyUnlockedAchievementByAchievementIdOptions* Options, EOS_Achievements_UnlockedAchievement ** OutAchievement);

/**
 * DEPRECATED! Use EOS_Achievements_AddNotifyAchievementsUnlockedV2 instead.
 *
 * Register to receive achievement unlocked notifications.
 * @note must call EOS_Achievements_RemoveNotifyAchievementsUnlocked to remove the notification
 *
 * @see EOS_Achievements_RemoveNotifyAchievementsUnlocked
 *
 * @param Options Structure containing information about the achievement unlocked notification
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param NotificationFn A callback that is fired when an achievement unlocked notification for a user has been received
 *
 * @return handle representing the registered callback
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_Achievements_AddNotifyAchievementsUnlocked(EOS_HAchievements Handle, const EOS_Achievements_AddNotifyAchievementsUnlockedOptions* Options, void* ClientData, const EOS_Achievements_OnAchievementsUnlockedCallback NotificationFn);

```

`eac/sdk/Include/eos_achievements_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

EXTERN_C typedef struct EOS_AchievementsHandle* EOS_HAchievements;

/** The most recent version of the EOS_Achievements_QueryDefinitions struct. */
#define EOS_ACHIEVEMENTS_QUERYDEFINITIONS_API_LATEST 3

/**
 * Input parameters for the EOS_Achievements_QueryDefinitions function.
 */
EOS_STRUCT(EOS_Achievements_QueryDefinitionsOptions, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_QUERYDEFINITIONS_API_LATEST. */
	int32_t ApiVersion;
	/**
	 * Product User ID for user who is querying definitions.
	 * The localized text returned will be based on the locale code of the given user if they have a linked Epic Account ID.
	 * The localized text returned can also be overridden using EOS_Platform_SetOverrideLocaleCode to override the locale.
	 * If the locale code is not overridden and LocalUserId is not valid, default text will be returned.
	 */
	EOS_ProductUserId LocalUserId;
	/** Deprecated */
	EOS_EpicAccountId EpicUserId_DEPRECATED;
	/** Deprecated */
	const char** HiddenAchievementIds_DEPRECATED;
	/** Deprecated */
	uint32_t HiddenAchievementsCount_DEPRECATED;
));

/** The most recent version of the EOS_Achievements_StatThresholds struct. */
#define EOS_ACHIEVEMENTS_STATTHRESHOLDS_API_LATEST 1

/** DEPRECATED! Use EOS_ACHIEVEMENTS_STATTHRESHOLDS_API_LATEST instead. */
#define EOS_ACHIEVEMENTS_STATTHRESHOLD_API_LATEST EOS_ACHIEVEMENTS_STATTHRESHOLDS_API_LATEST

/**
 * Contains information about a collection of stat threshold data.
 *
 * The threshold will depend on the stat aggregate type:
 *   LATEST (Tracks the latest value)
 *   MAX (Tracks the maximum value)
 *   MIN (Tracks the minimum value)
 *   SUM (Generates a rolling sum of the value)
 *
 * @see EOS_Achievements_Definition
 */
EOS_STRUCT(EOS_Achievements_StatThresholds, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_STATTHRESHOLDS_API_LATEST. */
	int32_t ApiVersion;
	/** The name of the stat. */
	const char* Name;
	/** The value that the stat must surpass to satisfy the requirement for unlocking an achievement. */
	int32_t Threshold;
));

#define EOS_ACHIEVEMENTS_PLAYERSTATINFO_API_LATEST 1
/**
 * Contains information about a collection of stat info data.
 *
 * @see EOS_Achievements_PlayerAchievement
 */
EOS_STRUCT(EOS_Achievements_PlayerStatInfo, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_PLAYERSTATINFO_API_LATEST. */
	int32_t ApiVersion;
	/** The name of the stat. */
	const char* Name;
	/** The current value of the stat. */
	int32_t CurrentValue;
	/** The threshold value of the stat, used in determining when to unlock an achievement. */
	int32_t ThresholdValue;
));

/** The most recent version of the EOS_Achievements_DefinitionV2 struct. */
#define EOS_ACHIEVEMENTS_DEFINITIONV2_API_LATEST 2

/**
 * Contains information about a single achievement definition with localized text.
 */
EOS_STRUCT(EOS_Achievements_DefinitionV2, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_DEFINITIONV2_API_LATEST. */
	int32_t ApiVersion;
	/** Achievement ID that can be used to uniquely identify the achievement. */
	const char* AchievementId;
	/** Localized display name for the achievement when it has been unlocked. */
	const char* UnlockedDisplayName;
	/** Localized description for the achievement when it has been unlocked. */
	const char* UnlockedDescription;
	/** Localized display name for the achievement when it is locked or hidden. */
	const char* LockedDisplayName;
	/** Localized description for the achievement when it is locked or hidden. */
	const char* LockedDescription;
	/** Localized flavor text that can be used by the game in an arbitrary manner. This may be null if there is no data configured in the dev portal. */
	const char* FlavorText;
	/** URL of an icon to display for the achievement when it is unlocked. This may be null if there is no data configured in the dev portal. */
	const char* UnlockedIconURL;
	/** URL of an icon to display for the achievement when it is locked or hidden. This may be null if there is no data configured in the dev portal. */
	const char* LockedIconURL;
	/** EOS_TRUE if the achievement is hidden; EOS_FALSE otherwise. */
	EOS_Bool bIsHidden;
	/** The number of stat thresholds used to monitor progress towards this achievement. */
	uint32_t StatThresholdsCount;
	/** Array of `EOS_Achievements_StatThresholds` that need to be satisfied to unlock this achievement. Consists of Name and Threshold Value. */
	const EOS_Achievements_StatThresholds* StatThresholds;
));

/**
 * Release the memory associated with EOS_Achievements_DefinitionV2. This must be called on data retrieved from
 * EOS_Achievements_CopyAchievementDefinitionV2ByIndex or EOS_Achievements_CopyAchievementDefinitionV2ByAchievementId.
 *
 * @param AchievementDefinition - The achievement definition to release.
 *
 * @see EOS_Achievements_DefinitionV2
 * @see EOS_Achievements_CopyAchievementDefinitionV2ByIndex
 * @see EOS_Achievements_CopyAchievementDefinitionV2ByAchievementId
 */
EOS_DECLARE_FUNC(void) EOS_Achievements_DefinitionV2_Release(EOS_Achievements_DefinitionV2* AchievementDefinition);


/** The most recent version of the EOS_Achievements_GetAchievementDefinitionCount API. */
#define EOS_ACHIEVEMENTS_GETACHIEVEMENTDEFINITIONCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Achievements_GetAchievementDefinitionCount function.
 */
EOS_STRUCT(EOS_Achievements_GetAchievementDefinitionCountOptions, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_GETACHIEVEMENTDEFINITIONCOUNT_API_LATEST. */
	int32_t ApiVersion;
));

/** The most recent version of the EOS_Achievements_CopyAchievementDefinitionByIndexOptions struct. */
#define EOS_ACHIEVEMENTS_COPYACHIEVEMENTDEFINITIONV2BYINDEX_API_LATEST 2

/** DEPRECATED! Use EOS_ACHIEVEMENTS_COPYACHIEVEMENTDEFINITIONV2BYINDEX_API_LATEST instead. */
#define EOS_ACHIEVEMENTS_COPYDEFINITIONV2BYINDEX_API_LATEST EOS_ACHIEVEMENTS_COPYACHIEVEMENTDEFINITIONV2BYINDEX_API_LATEST

/**
 * Input parameters for the EOS_Achievements_CopyAchievementDefinitionByIndex function.
 */
EOS_STRUCT(EOS_Achievements_CopyAchievementDefinitionV2ByIndexOptions, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_COPYACHIEVEMENTDEFINITIONV2BYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** Index of the achievement definition to retrieve from the cache. */
	uint32_t AchievementIndex;
));

/** The most recent version of the EOS_Achievements_CopyAchievementDefinitionV2ByAchievementIdOptions struct. */
#define EOS_ACHIEVEMENTS_COPYACHIEVEMENTDEFINITIONV2BYACHIEVEMENTID_API_LATEST 2

/** DEPRECATED! Use EOS_ACHIEVEMENTS_COPYACHIEVEMENTDEFINITIONV2BYACHIEVEMENTID_API_LATEST instead. */
#define EOS_ACHIEVEMENTS_COPYDEFINITIONV2BYACHIEVEMENTID_API_LATEST EOS_ACHIEVEMENTS_COPYACHIEVEMENTDEFINITIONV2BYACHIEVEMENTID_API_LATEST

/**
 * Input parameters for the EOS_Achievements_CopyAchievementDefinitionV2ByAchievementId function.
 */
EOS_STRUCT(EOS_Achievements_CopyAchievementDefinitionV2ByAchievementIdOptions, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_COPYACHIEVEMENTDEFINITIONV2BYACHIEVEMENTID_API_LATEST. */
	int32_t ApiVersion;
	/** Achievement ID to look for when copying the definition from the cache. */
	const char* AchievementId;
));

/**
 * Data containing the result information for a query definitions request.
 */
EOS_STRUCT(EOS_Achievements_OnQueryDefinitionsCompleteCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** User-defined context that was passed into EOS_Achievements_QueryDefinitions. */
	void* ClientData;
));

/**
 * Function prototype definition for callbacks passed to EOS_Achievements_QueryDefinitions
 * @param Data An EOS_Achievements_OnQueryDefinitionsCompleteCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Achievements_OnQueryDefinitionsCompleteCallback, const EOS_Achievements_OnQueryDefinitionsCompleteCallbackInfo* Data);


/** The most recent version of the EOS_Achievements_QueryPlayerAchievements struct. */
#define EOS_ACHIEVEMENTS_QUERYPLAYERACHIEVEMENTS_API_LATEST 2

/**
 * Input parameters for the EOS_Achievements_QueryPlayerAchievements function.
 */
EOS_STRUCT(EOS_Achievements_QueryPlayerAchievementsOptions, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_QUERYPLAYERACHIEVEMENTS_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID for the user whose achievements are to be retrieved. */
	EOS_ProductUserId TargetUserId;
	/** The Product User ID for the user who is querying for player achievements. For a Dedicated Server this should be null. */
	EOS_ProductUserId LocalUserId;
));

/** Timestamp value representing an undefined UnlockTime for EOS_Achievements_PlayerAchievement and EOS_Achievements_UnlockedAchievement */
#define EOS_ACHIEVEMENTS_ACHIEVEMENT_UNLOCKTIME_UNDEFINED -1

/** The most recent version of the EOS_Achievements_PlayerAchievement struct. */
#define EOS_ACHIEVEMENTS_PLAYERACHIEVEMENT_API_LATEST 2

/**
 * Contains information about a single player achievement.
 */
EOS_STRUCT(EOS_Achievements_PlayerAchievement, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_PLAYERACHIEVEMENT_API_LATEST. */
	int32_t ApiVersion;
	/** This achievement's unique identifier. */
	const char* AchievementId;
	/** Progress towards completing this achievement (as a percentage). */
	double Progress;
	/** The POSIX timestamp when the achievement was unlocked. If the achievement has not been unlocked, this value will be EOS_ACHIEVEMENTS_ACHIEVEMENT_UNLOCKTIME_UNDEFINED. */
	int64_t UnlockTime;
	/** The number of player stat info entries associated with this achievement. */
	int32_t StatInfoCount;
	/** Array of EOS_Achievements_PlayerStatInfo structures containing information about stat thresholds used to unlock the achievement and the player's current values for those stats. */
	const EOS_Achievements_PlayerStatInfo* StatInfo;
	/** 
	 * Localized display name for the achievement based on this specific player's current progress on the achievement. 
	 * @note The current progress is updated when EOS_Achievements_QueryPlayerAchievements succeeds and when an achievement is unlocked.
	 */
	const char* DisplayName;
	/** 
	 * Localized description for the achievement based on this specific player's current progress on the achievement.
	 * @note The current progress is updated when EOS_Achievements_QueryPlayerAchievements succeeds and when an achievement is unlocked.
	 */
	const char* Description;
	/**
	 * URL of an icon to display for the achievement based on this specific player's current progress on the achievement. This may be null if there is no data configured in the dev portal.
	 * @note The current progress is updated when EOS_Achievements_QueryPlayerAchievements succeeds and when an achievement is unlocked.
	 */
	const char* IconURL;
	/** Localized flavor text that can be used by the game in an arbitrary manner. This may be null if there is no data configured in the dev portal. */
	const char* FlavorText;
));

/** The most recent version of the EOS_Achievements_GetPlayerAchievementCount API. */
#define EOS_ACHIEVEMENTS_GETPLAYERACHIEVEMENTCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Achievements_GetPlayerAchievementCount function.
 */
EOS_STRUCT(EOS_Achievements_GetPlayerAchievementCountOptions, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_GETPLAYERACHIEVEMENTCOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID for the user whose achievement count is being retrieved. */
	EOS_ProductUserId UserId;
));

/** The most recent version of the EOS_Achievements_CopyPlayerAchievementByIndexOptions struct. */
#define EOS_ACHIEVEMENTS_COPYPLAYERACHIEVEMENTBYINDEX_API_LATEST 2

/**
 * Input parameters for the EOS_Achievements_CopyPlayerAchievementByIndex function.
 */
EOS_STRUCT(EOS_Achievements_CopyPlayerAchievementByIndexOptions, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_COPYPLAYERACHIEVEMENTBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID for the user whose achievement is to be retrieved. */
	EOS_ProductUserId TargetUserId;
	/** The index of the player achievement data to retrieve from the cache. */
	uint32_t AchievementIndex;
	/** The Product User ID for the user who is querying for a player achievement. For a Dedicated Server this should be null. */
	EOS_ProductUserId LocalUserId;
));

/** The most recent version of the EOS_Achievements_CopyPlayerAchievementByAchievementIdOptions struct. */
#define EOS_ACHIEVEMENTS_COPYPLAYERACHIEVEMENTBYACHIEVEMENTID_API_LATEST 2

/**
 * Input parameters for the EOS_Achievements_CopyPlayerAchievementByAchievementId function.
 */
EOS_STRUCT(EOS_Achievements_CopyPlayerAchievementByAchievementIdOptions, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_COPYPLAYERACHIEVEMENTBYACHIEVEMENTID_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID for the user whose achievement is to be retrieved. */
	EOS_ProductUserId TargetUserId;
	/** Achievement ID to search for when retrieving player achievement data from the cache. */
	const char* AchievementId;
	/** The Product User ID for the user who is querying for a player achievement. For a Dedicated Server this should be null. */
	EOS_ProductUserId LocalUserId;
));

/**
 * Release the memory associated with a player achievement. This must be called on data retrieved from
 * EOS_Achievements_CopyPlayerAchievementByIndex or EOS_Achievements_CopyPlayerAchievementByAchievementId.
 *
 * @param Achievement - The achievement data to release.
 *
 * @see EOS_Achievements_PlayerAchievement
 * @see EOS_Achievements_CopyPlayerAchievementByIndex
 * @see EOS_Achievements_CopyPlayerAchievementByAchievementId
 */
EOS_DECLARE_FUNC(void) EOS_Achievements_PlayerAchievement_Release(EOS_Achievements_PlayerAchievement* Achievement);

/**
 * Data containing the result information for querying a player's achievements request.
 */
EOS_STRUCT(EOS_Achievements_OnQueryPlayerAchievementsCompleteCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Achievements_QueryPlayerAchievements. */
	void* ClientData;
	/** The Product User ID of the user who initiated this request. */
	EOS_ProductUserId UserId;
));

 /**
  * Function prototype definition for callbacks passed to EOS_Achievements_QueryPlayerAchievements
  *
  * @param Data An EOS_Achievements_OnQueryPlayerAchievementsCompleteCallbackInfo containing the output information and result
  *
  * @see EOS_Achievements_PlayerAchievement_Release
  */
EOS_DECLARE_CALLBACK(EOS_Achievements_OnQueryPlayerAchievementsCompleteCallback, const EOS_Achievements_OnQueryPlayerAchievementsCompleteCallbackInfo* Data);


/** The most recent version of the EOS_Achievements_UnlockAchievements struct. */
#define EOS_ACHIEVEMENTS_UNLOCKACHIEVEMENTS_API_LATEST 1

/**
 * Input parameters for the EOS_Achievements_UnlockAchievements function.
 */
EOS_STRUCT(EOS_Achievements_UnlockAchievementsOptions, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_UNLOCKACHIEVEMENTS_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID for the user whose achievements we want to unlock. */
	EOS_ProductUserId UserId;
	/** An array of Achievement IDs to unlock. */
	const char** AchievementIds;
	/** The number of achievements to unlock. */
	uint32_t AchievementsCount;
));

/**
 * Data containing the result information for unlocking achievements request.
 */
EOS_STRUCT(EOS_Achievements_OnUnlockAchievementsCompleteCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Achievements_UnlockAchievements. */
	void* ClientData;
	/** The Product User ID of the user who initiated this request. */
	EOS_ProductUserId UserId;
	/** The number of achievements that the operation unlocked. */
	uint32_t AchievementsCount;
));

/**
 * Function prototype definition for callbacks passed to EOS_Achievements_UnlockAchievements
 * @param Data An EOS_Achievements_OnUnlockAchievementsCompleteCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Achievements_OnUnlockAchievementsCompleteCallback, const EOS_Achievements_OnUnlockAchievementsCompleteCallbackInfo* Data);

/** The most recent version of the EOS_Achievements_AddNotifyAchievementsUnlockedV2 API. */
#define EOS_ACHIEVEMENTS_ADDNOTIFYACHIEVEMENTSUNLOCKEDV2_API_LATEST 2

/**
 * Input parameters for the EOS_Achievements_AddNotifyAchievementsUnlocked function.
 */
EOS_STRUCT(EOS_Achievements_AddNotifyAchievementsUnlockedV2Options, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_ADDNOTIFYACHIEVEMENTSUNLOCKEDV2_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_Achievements_OnAchievementsUnlockedCallbackV2 Function.
 */
EOS_STRUCT(EOS_Achievements_OnAchievementsUnlockedCallbackV2Info, (
	/** Context that was passed into EOS_Achievements_AddNotifyAchievementsUnlocked */
	void* ClientData;
	/** The Product User ID for the user who received the unlocked achievements notification */
	EOS_ProductUserId UserId;
	/** The Achievement ID for the achievement that was unlocked. Pass this to EOS_Achievements_CopyPlayerAchievementByAchievementId to get the full achievement information. */
	const char* AchievementId;
	/** POSIX timestamp when the achievement was unlocked. */
	int64_t UnlockTime;
));

/**
 * Function prototype definition for notifications that come from EOS_Achievements_AddNotifyAchievementsUnlockedV2
 *
 * @param Data An EOS_Achievements_OnAchievementsUnlockedCallbackV2Info containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Achievements_OnAchievementsUnlockedCallbackV2, const EOS_Achievements_OnAchievementsUnlockedCallbackV2Info* Data);


#pragma pack(pop)

#include "eos_achievements_types_deprecated.inl"

```

`eac/sdk/Include/eos_achievements_types_deprecated.inl`:

```inl
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"

/*
 * This file contains the deprecated types for EOS Achievements. In a future version, these types will be removed.
 */

#pragma pack(push, 8)

 /** The most recent version of the EOS_Achievements_Definition struct. */
#define EOS_ACHIEVEMENTS_DEFINITION_API_LATEST 1

/**
 * Contains information about a single achievement definition with localized text.
 */
EOS_STRUCT(EOS_Achievements_Definition, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_DEFINITION_API_LATEST. */
	int32_t ApiVersion;
	/** Achievement ID that can be used to uniquely identify the achievement. */
	const char* AchievementId;
	/** Text representing the Name to display in-game when achievement has been unlocked. */
	const char* DisplayName;
	/** Text representing the description to display in-game when achievement has been unlocked. */
	const char* Description;
	/** Text representing the name to display in-game when achievement is locked. */
	const char* LockedDisplayName;
	/** Text representing the description of what needs to be done to trigger the unlock of this achievement. */
	const char* LockedDescription;
	/** Text representing the description to display in-game when achievement is hidden. */
	const char* HiddenDescription;
	/** Text representing the description of what happens when the achievement is unlocked. */
	const char* CompletionDescription;
	/** Text representing the icon to display in-game when achievement is unlocked. */
	const char* UnlockedIconId;
	/** Text representing the icon to display in-game when achievement is locked. */
	const char* LockedIconId;
	/** True if achievement is hidden, false otherwise. */
	EOS_Bool bIsHidden;
	/** The number of stat thresholds. */
	int32_t StatThresholdsCount;
	/** Array of stat thresholds that need to be satisfied to unlock the achievement. */
	const EOS_Achievements_StatThresholds* StatThresholds;
));

/**
 * Release the memory associated with achievement definitions. This must be called on data retrieved from
 * EOS_Achievements_CopyAchievementDefinitionByIndex or EOS_Achievements_CopyAchievementDefinitionByAchievementId.
 *
 * @param AchievementDefinition - The achievement definition to release.
 *
 * @see EOS_Achievements_Definition
 * @see EOS_Achievements_CopyAchievementDefinitionByIndex
 * @see EOS_Achievements_CopyAchievementDefinitionByAchievementId
 */
EOS_DECLARE_FUNC(void) EOS_Achievements_Definition_Release(EOS_Achievements_Definition* AchievementDefinition);

/** The most recent version of the EOS_Achievements_CopyAchievementDefinitionByIndexOptions struct. */
#define EOS_ACHIEVEMENTS_COPYDEFINITIONBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_Achievements_CopyAchievementDefinitionByIndex function.
 */
EOS_STRUCT(EOS_Achievements_CopyAchievementDefinitionByIndexOptions, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_COPYDEFINITIONBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** Index of the achievement definition to retrieve from the cache */
	uint32_t AchievementIndex;
));

/** The most recent version of the EOS_Achievements_CopyAchievementDefinitionByAchievementIdOptions struct. */
#define EOS_ACHIEVEMENTS_COPYDEFINITIONBYACHIEVEMENTID_API_LATEST 1

/**
 * Input parameters for the EOS_Achievements_CopyAchievementDefinitionByAchievementId function.
 */
EOS_STRUCT(EOS_Achievements_CopyAchievementDefinitionByAchievementIdOptions, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_COPYDEFINITIONBYACHIEVEMENTID_API_LATEST. */
	int32_t ApiVersion;
	/** Achievement ID to look for when copying definition from the cache */
	const char* AchievementId;
));

/** The most recent version of the EOS_Achievements_UnlockedAchievement struct. */
#define EOS_ACHIEVEMENTS_UNLOCKEDACHIEVEMENT_API_LATEST 1

/**
 * Contains information about a single unlocked achievement.
 */
EOS_STRUCT(EOS_Achievements_UnlockedAchievement, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_UNLOCKEDACHIEVEMENT_API_LATEST. */
	int32_t ApiVersion;
	/** Achievement ID that can be used to uniquely identify the unlocked achievement. */
	const char* AchievementId;
	/** If not EOS_ACHIEVEMENTS_ACHIEVEMENT_UNLOCKTIME_UNDEFINED then this is the POSIX timestamp that the achievement was unlocked. */
	int64_t UnlockTime;
));

/** The most recent version of the EOS_Achievements_GetUnlockedAchievementCount API. */
#define EOS_ACHIEVEMENTS_GETUNLOCKEDACHIEVEMENTCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Achievements_GetUnlockedAchievementCount function.
 */
EOS_STRUCT(EOS_Achievements_GetUnlockedAchievementCountOptions, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_GETUNLOCKEDACHIEVEMENTCOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** Product User ID for which to retrieve the unlocked achievement count */
	EOS_ProductUserId UserId;
));

/** The most recent version of the EOS_Achievements_CopyUnlockedAchievementByIndexOptions struct. */
#define EOS_ACHIEVEMENTS_COPYUNLOCKEDACHIEVEMENTBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_Achievements_CopyUnlockedAchievementByIndex function.
 */
EOS_STRUCT(EOS_Achievements_CopyUnlockedAchievementByIndexOptions, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_COPYUNLOCKEDACHIEVEMENTBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID for the user who is copying the unlocked achievement */
	EOS_ProductUserId UserId;
	/** Index of the unlocked achievement to retrieve from the cache */
	uint32_t AchievementIndex;
));

/** The most recent version of the EOS_Achievements_CopyUnlockedAchievementByAchievementIdOptions struct. */
#define EOS_ACHIEVEMENTS_COPYUNLOCKEDACHIEVEMENTBYACHIEVEMENTID_API_LATEST 1

/**
 * Input parameters for the EOS_Achievements_CopyUnlockedAchievementByAchievementId function.
 */
EOS_STRUCT(EOS_Achievements_CopyUnlockedAchievementByAchievementIdOptions, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_COPYUNLOCKEDACHIEVEMENTBYACHIEVEMENTID_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID for the user who is copying the unlocked achievement */
	EOS_ProductUserId UserId;
	/** AchievementId of the unlocked achievement to retrieve from the cache */
	const char* AchievementId;
));


/** The most recent version of the EOS_Achievements_AddNotifyAchievementsUnlocked API. */
#define EOS_ACHIEVEMENTS_ADDNOTIFYACHIEVEMENTSUNLOCKED_API_LATEST 1

/**
 * Input parameters for the EOS_Achievements_AddNotifyAchievementsUnlocked function.
 */
EOS_STRUCT(EOS_Achievements_AddNotifyAchievementsUnlockedOptions, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_ADDNOTIFYACHIEVEMENTSUNLOCKED_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_Achievements_OnAchievementsUnlockedCallback Function.
 */
EOS_STRUCT(EOS_Achievements_OnAchievementsUnlockedCallbackInfo, (
	/** Context that was passed into EOS_Achievements_AddNotifyAchievementsUnlocked */
	void* ClientData;
	/** The Product User ID for the user who received the unlocked achievements notification */
	EOS_ProductUserId UserId;
	/** The number of achievements. */
	uint32_t AchievementsCount;
	/** This member is not used and will always be set to NULL. */
	const char** AchievementIds;
));

/**
 * Function prototype definition for notifications that come from EOS_Achievements_AddNotifyAchievementsUnlocked
 *
 * @param Data A EOS_Achievements_OnAchievementsUnlockedCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Achievements_OnAchievementsUnlockedCallback, const EOS_Achievements_OnAchievementsUnlockedCallbackInfo* Data);

/**
 * Release the memory associated with an unlocked achievement. This must be called on data retrieved from
 * EOS_Achievements_CopyUnlockedAchievementByIndex or EOS_Achievements_CopyUnlockedAchievementByAchievementId.
 *
 * @param Achievement - The unlocked achievement data to release.
 *
 * @see EOS_Achievements_UnlockedAchievement
 * @see EOS_Achievements_CopyUnlockedAchievementByIndex
 * @see EOS_Achievements_CopyUnlockedAchievementByAchievementId
 */
EOS_DECLARE_FUNC(void) EOS_Achievements_UnlockedAchievement_Release(EOS_Achievements_UnlockedAchievement* Achievement);

#pragma pack(pop)

```

`eac/sdk/Include/eos_anticheatclient.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_anticheatclient_types.h"

/**
 * Add a callback issued when a new message must be dispatched to the game server. The bound function will only be called
 * between a successful call to EOS_AntiCheatClient_BeginSession and the matching EOS_AntiCheatClient_EndSession call in mode EOS_ACCM_ClientServer.
 * Mode: EOS_ACCM_ClientServer.
 *
 * @param Options Structure containing input data
 * @param ClientData This value is returned to the caller when NotificationFn is invoked
 * @param NotificationFn The callback to be fired
 * @return A valid notification ID if successfully bound, or EOS_INVALID_NOTIFICATIONID otherwise
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_AntiCheatClient_AddNotifyMessageToServer(EOS_HAntiCheatClient Handle, const EOS_AntiCheatClient_AddNotifyMessageToServerOptions* Options, void* ClientData, EOS_AntiCheatClient_OnMessageToServerCallback NotificationFn);

/**
 * Remove a previously bound EOS_AntiCheatClient_AddNotifyMessageToServer handler.
 * Mode: Any.
 *
 * @param NotificationId The previously bound notification ID
 */
EOS_DECLARE_FUNC(void) EOS_AntiCheatClient_RemoveNotifyMessageToServer(EOS_HAntiCheatClient Handle, EOS_NotificationId NotificationId);

/**
 * Add a callback issued when a new message must be dispatched to a connected peer. The bound function will only be called
 * between a successful call to EOS_AntiCheatClient_BeginSession and the matching EOS_AntiCheatClient_EndSession call in mode EOS_ACCM_PeerToPeer.
 * Mode: EOS_ACCM_PeerToPeer.
 *
 * @param Options Structure containing input data
 * @param ClientData This value is returned to the caller when NotificationFn is invoked
 * @param NotificationFn The callback to be fired
 * @return A valid notification ID if successfully bound, or EOS_INVALID_NOTIFICATIONID otherwise
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_AntiCheatClient_AddNotifyMessageToPeer(EOS_HAntiCheatClient Handle, const EOS_AntiCheatClient_AddNotifyMessageToPeerOptions* Options, void* ClientData, EOS_AntiCheatClient_OnMessageToPeerCallback NotificationFn);

/**
 * Remove a previously bound EOS_AntiCheatClient_AddNotifyMessageToPeer handler.
 * Mode: Any.
 *
 * @param NotificationId The previously bound notification ID
 */
EOS_DECLARE_FUNC(void) EOS_AntiCheatClient_RemoveNotifyMessageToPeer(EOS_HAntiCheatClient Handle, EOS_NotificationId NotificationId);

/**
 * Add a callback issued when an action must be applied to a connected client. The bound function will only be called
 * between a successful call to EOS_AntiCheatClient_BeginSession and the matching EOS_AntiCheatClient_EndSession call in mode EOS_ACCM_PeerToPeer.
 * Mode: EOS_ACCM_PeerToPeer.
 *
 * @param Options Structure containing input data
 * @param ClientData This value is returned to the caller when NotificationFn is invoked
 * @param NotificationFn The callback to be fired
 * @return A valid notification ID if successfully bound, or EOS_INVALID_NOTIFICATIONID otherwise
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_AntiCheatClient_AddNotifyPeerActionRequired(EOS_HAntiCheatClient Handle, const EOS_AntiCheatClient_AddNotifyPeerActionRequiredOptions* Options, void* ClientData, EOS_AntiCheatClient_OnPeerActionRequiredCallback NotificationFn);

/**
 * Remove a previously bound EOS_AntiCheatClient_AddNotifyPeerActionRequired handler.
 * Mode: Any.
 *
 * @param NotificationId The previously bound notification ID
 */
EOS_DECLARE_FUNC(void) EOS_AntiCheatClient_RemoveNotifyPeerActionRequired(EOS_HAntiCheatClient Handle, EOS_NotificationId NotificationId);

/**
 * Add an optional callback issued when a connected peer's authentication status changes. The bound function will only be called
 * between a successful call to EOS_AntiCheatClient_BeginSession and the matching EOS_AntiCheatClient_EndSession call in mode EOS_ACCM_PeerToPeer.
 * Mode: EOS_ACCM_PeerToPeer.
 *
 * @param Options Structure containing input data
 * @param ClientData This value is returned to the caller when NotificationFn is invoked
 * @param NotificationFn The callback to be fired
 * @return A valid notification ID if successfully bound, or EOS_INVALID_NOTIFICATIONID otherwise
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_AntiCheatClient_AddNotifyPeerAuthStatusChanged(EOS_HAntiCheatClient Handle, const EOS_AntiCheatClient_AddNotifyPeerAuthStatusChangedOptions* Options, void* ClientData, EOS_AntiCheatClient_OnPeerAuthStatusChangedCallback NotificationFn);

/**
 * Remove a previously bound EOS_AntiCheatClient_AddNotifyPeerAuthStatusChanged handler.
 * Mode: Any.
 *
 * @param NotificationId The previously bound notification ID
 */
EOS_DECLARE_FUNC(void) EOS_AntiCheatClient_RemoveNotifyPeerAuthStatusChanged(EOS_HAntiCheatClient Handle, EOS_NotificationId NotificationId);

/**
 * Begins a multiplayer game session. After this call returns successfully, the client is ready to exchange
 * anti-cheat messages with a game server or peer(s). When leaving one game session and connecting to a
 * different one, a new anti-cheat session must be created by calling EOS_AntiCheatClient_EndSession and EOS_AntiCheatClient_BeginSession again.
 * Mode: All
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the session was started successfully
 *         EOS_InvalidParameters - If input data was invalid
 *         EOS_AntiCheat_InvalidMode - If the current mode does not support this function
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatClient_BeginSession(EOS_HAntiCheatClient Handle, const EOS_AntiCheatClient_BeginSessionOptions* Options);

/**
 * Ends a multiplayer game session, either by leaving an ongoing session or shutting it down entirely.
 * Mode: All
 *
 * Must be called when the multiplayer session ends, or when the local user leaves a session in progress.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the session was ended normally
 *         EOS_InvalidParameters - If input data was invalid
 *         EOS_AntiCheat_InvalidMode - If the current mode does not support this function
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatClient_EndSession(EOS_HAntiCheatClient Handle, const EOS_AntiCheatClient_EndSessionOptions* Options);

/**
 * Polls for changes in client integrity status.
 * Mode: All
 *
 * The purpose of this function is to allow the game to display information
 * about anti-cheat integrity problems to the user. These are often the result of a
 * corrupt game installation rather than cheating attempts. This function does not
 * check for violations, it only provides information about violations which have
 * automatically been discovered by the anti-cheat client. Such a violation may occur
 * at any time and afterwards the user will be unable to join any protected multiplayer
 * session until after restarting the game.
 *
 * @param Options Structure containing input data.
 * @param ViolationType On success, receives a code describing the violation that occurred.
 * @param OutMessage On success, receives a string describing the violation which should be displayed to the user.
 *
 * @return EOS_Success - If violation information was returned successfully
 *		   EOS_LimitExceeded - If OutMessage is too small to receive the message string. Call again with a larger OutMessage.
 *         EOS_NotFound - If no violation has occurred since the last call
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatClient_PollStatus(EOS_HAntiCheatClient Handle, const EOS_AntiCheatClient_PollStatusOptions* Options, EOS_EAntiCheatClientViolationType* ViolationType, char* OutMessage);

/**
 * Optional. Adds an integrity catalog and certificate pair from outside the game directory,
 * for example to support mods that load from elsewhere.
 * Mode: All
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the integrity catalog was added successfully
 *         EOS_InvalidParameters - If input data was invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatClient_AddExternalIntegrityCatalog(EOS_HAntiCheatClient Handle, const EOS_AntiCheatClient_AddExternalIntegrityCatalogOptions* Options);

/**
 * Call when an anti-cheat message is received from the game server.
 * Mode: EOS_ACCM_ClientServer.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the message was processed successfully
 *         EOS_InvalidParameters - If input data was invalid
 *         EOS_AntiCheat_InvalidMode - If the current mode does not support this function
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatClient_ReceiveMessageFromServer(EOS_HAntiCheatClient Handle, const EOS_AntiCheatClient_ReceiveMessageFromServerOptions* Options);

/**
 * Optional NetProtect feature for game message encryption.
 * Calculates the required decrypted buffer size for a given input data length.
 * This will not change for a given SDK version, and allows one time allocation of reusable buffers.
 * Mode: EOS_ACCM_ClientServer.
 *
 * @param Options Structure containing input data.
 * @param OutBufferLengthBytes On success, the OutBuffer length in bytes that is required to call ProtectMessage on the given input size.
 *
 * @return EOS_Success - If the output length was calculated successfully
 *         EOS_InvalidParameters - If input data was invalid
 *         EOS_AntiCheat_InvalidMode - If the current mode does not support this function
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatClient_GetProtectMessageOutputLength(EOS_HAntiCheatClient Handle, const EOS_AntiCheatClient_GetProtectMessageOutputLengthOptions* Options, uint32_t* OutBufferSizeBytes);

/**
 * Optional NetProtect feature for game message encryption.
 * Encrypts an arbitrary message that will be sent to the game server and decrypted on the other side.
 * Mode: EOS_ACCM_ClientServer.
 *
 * Options.Data and OutBuffer may refer to the same buffer to encrypt in place.
 *
 * @param Options Structure containing input data.
 * @param OutBuffer On success, buffer where encrypted message data will be written.
 * @param OutBytesWritten On success, the number of bytes that were written to OutBuffer.
 *
 * @return EOS_Success - If the message was protected successfully
 *         EOS_InvalidParameters - If input data was invalid
 *         EOS_AntiCheat_InvalidMode - If the current mode does not support this function
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatClient_ProtectMessage(EOS_HAntiCheatClient Handle, const EOS_AntiCheatClient_ProtectMessageOptions* Options, void* OutBuffer, uint32_t* OutBytesWritten);

/**
 * Optional NetProtect feature for game message encryption.
 * Decrypts an encrypted message received from the game server.
 * Mode: EOS_ACCM_ClientServer.
 *
 * Options.Data and OutBuffer may refer to the same buffer to decrypt in place.
 *
 * @param Options Structure containing input data.
 * @param OutBuffer On success, buffer where encrypted message data will be written.
 * @param OutBytesWritten On success, the number of bytes that were written to OutBuffer.
 *
 * @return EOS_Success - If the message was unprotected successfully
 *         EOS_InvalidParameters - If input data was invalid
 *         EOS_AntiCheat_InvalidMode - If the current mode does not support this function
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatClient_UnprotectMessage(EOS_HAntiCheatClient Handle, const EOS_AntiCheatClient_UnprotectMessageOptions* Options, void* OutBuffer, uint32_t* OutBytesWritten);

/**
 * Registers a connected peer-to-peer client.
 * Mode: EOS_ACCM_PeerToPeer.
 *
 * Must be paired with a call to EOS_AntiCheatClient_UnregisterPeer if this user leaves the session
 * in progress, or EOS_AntiCheatClient_EndSession if the entire session is ending.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the player was registered successfully
 *         EOS_InvalidParameters - If input data was invalid
 *         EOS_AntiCheat_InvalidMode - If the current mode does not support this function
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatClient_RegisterPeer(EOS_HAntiCheatClient Handle, const EOS_AntiCheatClient_RegisterPeerOptions* Options);

/**
 * Unregisters a disconnected peer-to-peer client.
 * Mode: EOS_ACCM_PeerToPeer.
 *
 * Must be called when a user leaves a session in progress.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the player was unregistered successfully
 *         EOS_InvalidParameters - If input data was invalid
 *         EOS_AntiCheat_InvalidMode - If the current mode does not support this function
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatClient_UnregisterPeer(EOS_HAntiCheatClient Handle, const EOS_AntiCheatClient_UnregisterPeerOptions* Options);

/**
 * Call when an anti-cheat message is received from a peer.
 * Mode: EOS_ACCM_PeerToPeer.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the message was processed successfully
 *         EOS_InvalidParameters - If input data was invalid
 *         EOS_AntiCheat_InvalidMode - If the current mode does not support this function
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatClient_ReceiveMessageFromPeer(EOS_HAntiCheatClient Handle, const EOS_AntiCheatClient_ReceiveMessageFromPeerOptions* Options);

```

`eac/sdk/Include/eos_anticheatclient_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"
#include "eos_anticheatcommon_types.h"

#pragma pack(push, 8)

EXTERN_C typedef struct EOS_AntiCheatClientHandle* EOS_HAntiCheatClient;

/** Operating modes */
EOS_ENUM(EOS_EAntiCheatClientMode,
	/** Not used */
	EOS_ACCM_Invalid = 0,
	/** Dedicated or listen server mode */
	EOS_ACCM_ClientServer = 1,
	/** Full mesh peer-to-peer mode */
	EOS_ACCM_PeerToPeer = 2
);

/** Anti-cheat integrity violation types */
EOS_ENUM(EOS_EAntiCheatClientViolationType,
	/** Not used */
	EOS_ACCVT_Invalid = 0,
	/** An anti-cheat asset integrity catalog file could not be found */
	EOS_ACCVT_IntegrityCatalogNotFound = 1,
	/** An anti-cheat asset integrity catalog file is corrupt or invalid */
	EOS_ACCVT_IntegrityCatalogError = 2,
	/** An anti-cheat asset integrity catalog file's certificate has been revoked. */
	EOS_ACCVT_IntegrityCatalogCertificateRevoked = 3,
	/**
	 * The primary anti-cheat asset integrity catalog does not include an entry for the game's
	 * main executable, which is required.
	 */
	EOS_ACCVT_IntegrityCatalogMissingMainExecutable = 4,
	/** A disallowed game file modification was detected */
	EOS_ACCVT_GameFileMismatch = 5,
	/** A disallowed game file removal was detected */
	EOS_ACCVT_RequiredGameFileNotFound = 6,
	/** A disallowed game file addition was detected */
	EOS_ACCVT_UnknownGameFileForbidden = 7,
	/** A system file failed an integrity check */
	EOS_ACCVT_SystemFileUntrusted = 8,
	/** A disallowed code module was loaded into the game process */
	EOS_ACCVT_ForbiddenModuleLoaded = 9,
	/** A disallowed game process memory modification was detected */
	EOS_ACCVT_CorruptedMemory = 10,
	/** A disallowed tool was detected running in the system */
	EOS_ACCVT_ForbiddenToolDetected = 11,
	/** An internal anti-cheat integrity check failed */
	EOS_ACCVT_InternalAntiCheatViolation = 12,
	/** Integrity checks on messages between the game client and game server failed */
	EOS_ACCVT_CorruptedNetworkMessageFlow = 13,
	/** The game is running inside a disallowed virtual machine */
	EOS_ACCVT_VirtualMachineNotAllowed = 14,
	/** A forbidden operating system configuration was detected */
	EOS_ACCVT_ForbiddenSystemConfiguration = 15
);

/**
 * Structure containing details about a new message that must be dispatched to the game server.
 */
EOS_STRUCT(EOS_AntiCheatClient_OnMessageToServerCallbackInfo, (
	/** Caller-specified context data */
	void* ClientData;
	/** The message data that must be sent to the server */
	const void* MessageData;
	/** The size in bytes of MessageData */
	uint32_t MessageDataSizeBytes;
));

/**
 * Callback issued when a new message must be dispatched to the game server.
 *
 * Messages contain opaque binary data of up to 256 bytes and must be transmitted
 * to the game server using the game's own networking layer, then delivered
 * to the server anti-cheat instance using the EOS_AntiCheatServer_ReceiveMessageFromClient function.
 *
 * This callback is always issued from within EOS_Platform_Tick on its calling thread.
 */
EOS_DECLARE_CALLBACK(EOS_AntiCheatClient_OnMessageToServerCallback, const EOS_AntiCheatClient_OnMessageToServerCallbackInfo* Data);

/**
 * Callback issued when a new message must be dispatched to a connected peer.
 *
 * Messages contain opaque binary data of up to 256 bytes and must be transmitted
 * to the correct peer using the game's own networking layer, then delivered
 * to the client anti-cheat instance using the EOS_AntiCheatClient_ReceiveMessageFromPeer function.
 *
 * This callback is always issued from within EOS_Platform_Tick on its calling thread.
 */
EOS_DECLARE_CALLBACK(EOS_AntiCheatClient_OnMessageToPeerCallback, const EOS_AntiCheatCommon_OnMessageToClientCallbackInfo* Data);

/**
 * Callback issued when an action must be applied to a connected peer.
 * This callback is always issued from within EOS_Platform_Tick on its calling thread.
 */
EOS_DECLARE_CALLBACK(EOS_AntiCheatClient_OnPeerActionRequiredCallback, const EOS_AntiCheatCommon_OnClientActionRequiredCallbackInfo* Data);

/**
 * Optional callback issued when a connected peer's authentication status has changed.
 * This callback is always issued from within EOS_Platform_Tick on its calling thread.
 */
EOS_DECLARE_CALLBACK(EOS_AntiCheatClient_OnPeerAuthStatusChangedCallback, const EOS_AntiCheatCommon_OnClientAuthStatusChangedCallbackInfo* Data);

#define EOS_ANTICHEATCLIENT_ADDNOTIFYMESSAGETOSERVER_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatClient_AddNotifyMessageToServerOptions, (
	/** API Version: Set this to EOS_ANTICHEATCLIENT_ADDNOTIFYMESSAGETOSERVER_API_LATEST. */
	int32_t ApiVersion;
));

#define EOS_ANTICHEATCLIENT_ADDNOTIFYMESSAGETOPEER_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatClient_AddNotifyMessageToPeerOptions, (
	/** API Version: Set this to EOS_ANTICHEATCLIENT_ADDNOTIFYMESSAGETOPEER_API_LATEST. */
	int32_t ApiVersion;
));

#define EOS_ANTICHEATCLIENT_ADDNOTIFYPEERACTIONREQUIRED_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatClient_AddNotifyPeerActionRequiredOptions, (
	/** API Version: Set this to EOS_ANTICHEATCLIENT_ADDNOTIFYPEERACTIONREQUIRED_API_LATEST. */
	int32_t ApiVersion;
));

#define EOS_ANTICHEATCLIENT_ADDNOTIFYPEERAUTHSTATUSCHANGED_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatClient_AddNotifyPeerAuthStatusChangedOptions, (
	/** API Version: Set this to EOS_ANTICHEATCLIENT_ADDNOTIFYPEERAUTHSTATUSCHANGED_API_LATEST. */
	int32_t ApiVersion;
));

#define EOS_ANTICHEATCLIENT_BEGINSESSION_API_LATEST 3
EOS_STRUCT(EOS_AntiCheatClient_BeginSessionOptions, (
	/** API Version: Set this to EOS_ANTICHEATCLIENT_BEGINSESSION_API_LATEST. */
	int32_t ApiVersion;
	/** Logged in user identifier from earlier call to EOS_Connect_Login family of functions */
	EOS_ProductUserId LocalUserId;
	/** Operating mode */
	EOS_EAntiCheatClientMode Mode;
));

#define EOS_ANTICHEATCLIENT_ENDSESSION_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatClient_EndSessionOptions, (
	/** API Version: Set this to EOS_ANTICHEATCLIENT_ENDSESSION_API_LATEST. */
	int32_t ApiVersion;
));

#define EOS_ANTICHEATCLIENT_POLLSTATUS_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatClient_PollStatusOptions, (
	/** API Version: Set this to EOS_ANTICHEATCLIENT_POLLSTATUS_API_LATEST. */
	int32_t ApiVersion;
	/** The size of OutMessage in bytes. Recommended size is 256 bytes. */
	uint32_t OutMessageLength;
));

#define EOS_ANTICHEATCLIENT_ADDEXTERNALINTEGRITYCATALOG_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatClient_AddExternalIntegrityCatalogOptions, (
	/** API Version: Set this to EOS_ANTICHEATCLIENT_ADDEXTERNALINTEGRITYCATALOG_API_LATEST. */
	int32_t ApiVersion;
	/** UTF-8 path to the .bin catalog file to add */
	const char* PathToBinFile;
));

#define EOS_ANTICHEATCLIENT_RECEIVEMESSAGEFROMSERVER_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatClient_ReceiveMessageFromServerOptions, (
	/** API Version: Set this to EOS_ANTICHEATCLIENT_RECEIVEMESSAGEFROMSERVER_API_LATEST. */
	int32_t ApiVersion;
	/** The size of the data received */
	uint32_t DataLengthBytes;
	/** The data received */
	const void* Data;
));

#define EOS_ANTICHEATCLIENT_GETPROTECTMESSAGEOUTPUTLENGTH_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatClient_GetProtectMessageOutputLengthOptions, (
	/** API Version: Set this to EOS_ANTICHEATCLIENT_GETPROTECTMESSAGEOUTPUTLENGTH_API_LATEST. */
	int32_t ApiVersion;
	/** Length in bytes of input */
	uint32_t DataLengthBytes;
));

#define EOS_ANTICHEATCLIENT_PROTECTMESSAGE_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatClient_ProtectMessageOptions, (
	/** API Version: Set this to EOS_ANTICHEATCLIENT_PROTECTMESSAGE_API_LATEST. */
	int32_t ApiVersion;
	/** Length in bytes of input */
	uint32_t DataLengthBytes;
	/** The data to encrypt */
	const void* Data;
	/** The size in bytes of OutBuffer */
	uint32_t OutBufferSizeBytes;
));

#define EOS_ANTICHEATCLIENT_UNPROTECTMESSAGE_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatClient_UnprotectMessageOptions, (
	/** API Version: Set this to EOS_ANTICHEATCLIENT_UNPROTECTMESSAGE_API_LATEST. */
	int32_t ApiVersion;
	/** Length in bytes of input */
	uint32_t DataLengthBytes;
	/** The data to decrypt */
	const void* Data;
	/** The size in bytes of OutBuffer */
	uint32_t OutBufferSizeBytes;
));

/**
 * A special peer handle that represents the client itself.
 * It does not need to be registered or unregistered and is
 * used in OnPeerActionRequiredCallback to quickly signal to the user
 * that they will not be able to join online play.
 */
#define EOS_ANTICHEATCLIENT_PEER_SELF (EOS_AntiCheatCommon_ClientHandle)(-1)

#define EOS_ANTICHEATCLIENT_REGISTERPEER_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatClient_RegisterPeerOptions, (
	/** API Version: Set this to EOS_ANTICHEATCLIENT_REGISTERPEER_API_LATEST. */
	int32_t ApiVersion;
	/** Locally unique value describing the remote user (e.g. a player object pointer) */
	EOS_AntiCheatCommon_ClientHandle PeerHandle;
	/** Type of remote user being registered */
	EOS_EAntiCheatCommonClientType ClientType;
	/** Remote user's platform, if known */
	EOS_EAntiCheatCommonClientPlatform ClientPlatform;
	/** 
	 * Identifier for the remote user. This is typically a string representation of an
	 * account ID, but it can be any string which is both unique (two different users will never
	 * have the same string) and consistent (if the same user connects to this game session
	 * twice, the same string will be used) in the scope of a single protected game session.
	 */
	const char* AccountId;
	/** 
	 * Optional IP address for the remote user. May be null if not available.
	 * IPv4 format: "0.0.0.0"
	 * IPv6 format: "0:0:0:0:0:0:0:0"
	 */
	const char* IpAddress;
));

#define EOS_ANTICHEATCLIENT_UNREGISTERPEER_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatClient_UnregisterPeerOptions, (
	/** API Version: Set this to EOS_ANTICHEATCLIENT_UNREGISTERPEER_API_LATEST. */
	int32_t ApiVersion;
	/** Locally unique value describing the remote user, as previously passed to EOS_AntiCheatClient_RegisterPeer */
	EOS_AntiCheatCommon_ClientHandle PeerHandle;
));

#define EOS_ANTICHEATCLIENT_RECEIVEMESSAGEFROMPEER_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatClient_ReceiveMessageFromPeerOptions, (
	/** API Version: Set this to EOS_ANTICHEATCLIENT_RECEIVEMESSAGEFROMPEER_API_LATEST. */
	int32_t ApiVersion;
	/** The handle describing the sender of this message */
	EOS_AntiCheatCommon_ClientHandle PeerHandle;
	/** The size of the data received */
	uint32_t DataLengthBytes;
	/** The data received */
	const void* Data;
));

#pragma pack(pop)

```

`eac/sdk/Include/eos_anticheatcommon_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

/** 
  * Arbitrary data that is a unique local identifier for
  * a single remote client or peer.
  *
  * Typically this is a pointer to an object describing the
  * player, but it can be anything that is locally unique.
  */
EXTERN_C typedef void* EOS_AntiCheatCommon_ClientHandle;

/** Flags describing the type of a remote client */
EOS_ENUM(EOS_EAntiCheatCommonClientType,
	/** An ordinary player that requires anti-cheat client protection to play */
	EOS_ACCCT_ProtectedClient = 0,
	/** The player does not need the anti-cheat client to play because of their platform or other factors */
	EOS_ACCCT_UnprotectedClient = 1,
	/** The client is an AI bot, not an actual human */
	EOS_ACCCT_AIBot = 2
);

/** Flags describing the platform of a remote client, if known */
EOS_ENUM(EOS_EAntiCheatCommonClientPlatform,
	/** Unknown platform */
	EOS_ACCCP_Unknown = 0,
	/** The client is playing on Windows */
	EOS_ACCCP_Windows = 1,
	/** The client is playing on Mac */
	EOS_ACCCP_Mac = 2,
	/** The client is playing on Linux */
	EOS_ACCCP_Linux = 3,
	/** The client is playing on an Xbox device */
	EOS_ACCCP_Xbox = 4,
	/** The client is playing on a PlayStation device */
	EOS_ACCCP_PlayStation = 5,
	/** The client is playing on a Nintendo device */
	EOS_ACCCP_Nintendo = 6,
	/** The client is playing on iOS */
	EOS_ACCCP_iOS = 7,
	/** The client is playing on Android */
	EOS_ACCCP_Android = 8
);

/** Anti-cheat action values. Applicable to both clients and remote peers. */
EOS_ENUM(EOS_EAntiCheatCommonClientAction,
	/** Not used */
	EOS_ACCCA_Invalid = 0,
	/** The client/peer must be removed from the current game session */
	EOS_ACCCA_RemovePlayer = 1
);

/** Anti-cheat action reasons. Applicable to both clients and remote peers. */
EOS_ENUM(EOS_EAntiCheatCommonClientActionReason,
	/** Not used */
	EOS_ACCCAR_Invalid = 0,
	/** An internal error occurred */
	EOS_ACCCAR_InternalError = 1,
	/** An anti-cheat message received from the client/peer was corrupt or invalid */
	EOS_ACCCAR_InvalidMessage = 2,
	/** The client/peer's anti-cheat authentication failed */
	EOS_ACCCAR_AuthenticationFailed = 3,
	/** The client/peer failed to load the anti-cheat module at startup */
	EOS_ACCCAR_NullClient = 4,
	/** The client/peer's anti-cheat heartbeat was not received */
	EOS_ACCCAR_HeartbeatTimeout = 5,
	/** The client/peer failed an anti-cheat client runtime check */
	EOS_ACCCAR_ClientViolation = 6,
	/** The client/peer failed an anti-cheat backend runtime check */
	EOS_ACCCAR_BackendViolation = 7,
	/** The client/peer is temporarily blocked from playing on this game server */
	EOS_ACCCAR_TemporaryCooldown = 8,
	/** The client/peer is temporarily banned */
	EOS_ACCCAR_TemporaryBanned = 9,
	/** The client/peer is permanently banned */
	EOS_ACCCAR_PermanentBanned = 10
);

/** The client/peer's anti-cheat authentication status */
EOS_ENUM(EOS_EAntiCheatCommonClientAuthStatus,
	/** Not used */
	EOS_ACCCAS_Invalid = 0,
	/** The client/peer's anti-cheat functionality has been validated by this game server */
	EOS_ACCCAS_LocalAuthComplete = 1,
	/** The client/peer's anti-cheat functionality has been validated by the anti-cheat backend service */
	EOS_ACCCAS_RemoteAuthComplete = 2
);

/** Flags describing a remote client. These can be updated during a play session */
EOS_ENUM(EOS_EAntiCheatCommonClientFlags,
	/** No particular flags relevant for this client */
	EOS_ACCCF_None = 0,
	/** The client has admin privileges on the game server */
	EOS_ACCCF_Admin = (1 << 0)
);
EOS_ENUM_BOOLEAN_OPERATORS(EOS_EAntiCheatCommonClientFlags);

/** Flags describing the input device used by a remote client, if known. These can be updated during a play session. */
EOS_ENUM(EOS_EAntiCheatCommonClientInput,
	/** Unknown input device */
	EOS_ACCCI_Unknown = 0,
	/** The client is using mouse and keyboard */
	EOS_ACCCI_MouseKeyboard = 1,
	/** The client is using a gamepad or game controller */
	EOS_ACCCI_Gamepad = 2,
	/** The client is using a touch input device (e.g. phone/tablet screen) */
	EOS_ACCCI_TouchInput = 3
);

/**
 * Types supported for custom gameplay behavior events.
 * These have a considerable impact on performance
 */
EOS_ENUM(EOS_EAntiCheatCommonEventType,
	/** Not used */
	EOS_ACCET_Invalid = 0,
	/**
	 * A general game event that is not specific to any individual player.
	 * Low memory use which is constant with respect to the number of players.
	 */
	EOS_ACCET_GameEvent = 1,
	/**
	 * An event that is logically associated with a specific player. Events logged in
	 * this category require a specific ClientHandle to which they will be attached.
	 * Higher memory use which scales according to the number of players.
	 */
	EOS_ACCET_PlayerEvent = 2
);

/** Types supported for custom gameplay behavior event parameters */
EOS_ENUM(EOS_EAntiCheatCommonEventParamType,
	/** Not used */
	EOS_ACCEPT_Invalid = 0,
	/** EOS_AntiCheatCommon_ClientHandle */
	EOS_ACCEPT_ClientHandle = 1,
	/** const char* */
	EOS_ACCEPT_String = 2,
	/** uint32_t */
	EOS_ACCEPT_UInt32 = 3,
	/** int32_t */
	EOS_ACCEPT_Int32 = 4,
	/** uint64_t */
	EOS_ACCEPT_UInt64 = 5,
	/** int64_t */
	EOS_ACCEPT_Int64 = 6,
	/** EOS_AntiCheatCommon_Vec3f */
	EOS_ACCEPT_Vector3f = 7,
	/** EOS_AntiCheatCommon_Quat */
	EOS_ACCEPT_Quat = 8
);

/** Details of a player's movement state */
EOS_ENUM(EOS_EAntiCheatCommonPlayerMovementState,
	/** No particular state applies */
	EOS_ACCPMS_None = 0,
	/** Player is crouching */
	EOS_ACCPMS_Crouching = 1,
	/** Player is prone */
	EOS_ACCPMS_Prone = 2,
	/** Player is mounted in a vehicle or similar */
	EOS_ACCPMS_Mounted = 3,
	/** Player is swimming in a fluid volume */
	EOS_ACCPMS_Swimming = 4,
	/** Player is falling under the effects of gravity, such as when jumping or walking off the edge of a surface */
	EOS_ACCPMS_Falling = 5,
	/** Player is flying, ignoring the effects of gravity */
	EOS_ACCPMS_Flying = 6,
	/** Player is on a ladder */
	EOS_ACCPMS_OnLadder = 7
);

/** The source of a damage event */
EOS_ENUM(EOS_EAntiCheatCommonPlayerTakeDamageSource,
	/** No particular source relevant */
	EOS_ACCPTDS_None = 0,
	/** Damage caused by a player controlled character */
	EOS_ACCPTDS_Player = 1,
	/** Damage caused by a non-player character such as an AI enemy */
	EOS_ACCPTDS_NonPlayerCharacter = 2,
	/** Damage caused by the world (falling off level, into lava, etc) */
	EOS_ACCPTDS_World = 3
);

/** Type of damage applied in a damage event */
EOS_ENUM(EOS_EAntiCheatCommonPlayerTakeDamageType,
	/** No particular type relevant */
	EOS_ACCPTDT_None = 0,
	/** Damage caused by a point source such as a bullet or melee attack */
	EOS_ACCPTDT_PointDamage = 1,
	/** Damage caused by a radial source such as an explosion */
	EOS_ACCPTDT_RadialDamage = 2,
	/** Damage over time such as bleeding, poison, etc */
	EOS_ACCPTDT_DamageOverTime = 3
);

/** The result of a damage event, if any */
EOS_ENUM(EOS_EAntiCheatCommonPlayerTakeDamageResult,
	/** No direct state change consequence for the victim */
	EOS_ACCPTDR_None = 0,
	/** Player character is temporarily incapacitated and requires assistance to recover */
	EOS_ACCPTDR_Downed = 1,
	/** Player character is permanently incapacitated and cannot recover (e.g. dead) */
	EOS_ACCPTDR_Eliminated = 2
);

/** Vector using left-handed coordinate system (as in Unreal Engine) */
EOS_STRUCT(EOS_AntiCheatCommon_Vec3f, (
	/** X axis coordinate - forward direction */
	float x;
	/** Y axis coordinate - right direction */
	float y;
	/** Z axis coordinate - up direction */
	float z;
));

/** Quaternion using left-handed coordinate system (as in Unreal Engine) */
EOS_STRUCT(EOS_AntiCheatCommon_Quat, (
	/** W component - scalar part */
	float w;
	/** X component - forward direction */
	float x;
	/** Y component - right direction */
	float y;
	/** Z component - up direction */
	float z;
));

/**
 * Structure containing details about a new message that must be dispatched to a connected client/peer.
 */
EOS_STRUCT(EOS_AntiCheatCommon_OnMessageToClientCallbackInfo, (
	/** Caller-specified context data */
	void* ClientData;
	/** The identifier of the client/peer that this message must be delivered to. See the RegisterClient and RegisterPeer functions. */
	EOS_AntiCheatCommon_ClientHandle ClientHandle;
	/** The message data that must be sent to the client */
	const void* MessageData;
	/** The size in bytes of MessageData */
	uint32_t MessageDataSizeBytes;
));

/** Structure containing details about a required client/peer action */
EOS_STRUCT(EOS_AntiCheatCommon_OnClientActionRequiredCallbackInfo, (
	/** Caller-specified context data */
	void* ClientData;
	/** The identifier of the client/peer that this action applies to. See the RegisterClient and RegisterPeer functions. */
	EOS_AntiCheatCommon_ClientHandle ClientHandle;
	/** The action that must be applied to the specified client/peer */
	EOS_EAntiCheatCommonClientAction ClientAction;
	/** Code indicating the reason for the action. This can be displayed to the affected player. */
	EOS_EAntiCheatCommonClientActionReason ActionReasonCode;
	/** String containing details about the action reason. This can be displayed to the affected player. */
	const char* ActionReasonDetailsString;
));

/** Structure containing details about a client/peer authentication status change */
EOS_STRUCT(EOS_AntiCheatCommon_OnClientAuthStatusChangedCallbackInfo, (
	/** Caller-specified context data */
	void* ClientData;
	/** The identifier of the client/peer that this status change applies to. See the RegisterClient and RegisterPeer functions. */
	EOS_AntiCheatCommon_ClientHandle ClientHandle;
	/** The client/peer's new authentication status */
	EOS_EAntiCheatCommonClientAuthStatus ClientAuthStatus;
));

#define EOS_ANTICHEATCOMMON_SETCLIENTDETAILS_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatCommon_SetClientDetailsOptions, (
	/** API Version: Set this to EOS_ANTICHEATCOMMON_SETCLIENTDETAILS_API_LATEST. */
	int32_t ApiVersion;
	/** Locally unique value used in RegisterClient/RegisterPeer */
	EOS_AntiCheatCommon_ClientHandle ClientHandle;
	/** General flags associated with this client, if any */
	EOS_EAntiCheatCommonClientFlags ClientFlags;
	/** Input device being used by this client, if known */
	EOS_EAntiCheatCommonClientInput ClientInputMethod;
));

#define EOS_ANTICHEATCOMMON_SETGAMESESSIONID_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatCommon_SetGameSessionIdOptions, (
	/** API Version: Set this to EOS_ANTICHEATCOMMON_SETGAMESESSIONID_API_LATEST. */
	int32_t ApiVersion;
	/** Game session identifier */
	const char* GameSessionId;
));

#define EOS_ANTICHEATCOMMON_REGISTEREVENT_API_LATEST 1
#define EOS_ANTICHEATCOMMON_REGISTEREVENT_CUSTOMEVENTBASE 0x10000000
#define EOS_ANTICHEATCOMMON_REGISTEREVENT_MAX_PARAMDEFSCOUNT 12
EOS_STRUCT(EOS_AntiCheatCommon_RegisterEventParamDef, (
	/** Parameter name. Allowed characters are 0-9, A-Z, a-z, '_', '-' */
	const char* ParamName;
	/** Parameter type */
	EOS_EAntiCheatCommonEventParamType ParamType;
));
EOS_STRUCT(EOS_AntiCheatCommon_RegisterEventOptions, (
	/** API Version: Set this to EOS_ANTICHEATCOMMON_REGISTEREVENT_API_LATEST. */
	int32_t ApiVersion;
	/** Unique event identifier. Must be >= EOS_ANTICHEATCOMMON_REGISTEREVENT_CUSTOMEVENTBASE. */
	uint32_t EventId;
	/** Name of the custom event. Allowed characters are 0-9, A-Z, a-z, '_', '-' */
	const char* EventName;
	/** Type of the custom event */
	EOS_EAntiCheatCommonEventType EventType;
	/** Number of parameters described in ParamDefs. Must be <= EOS_ANTICHEATCOMMON_REGISTEREVENT_MAX_PARAMDEFSCOUNT. */
	uint32_t ParamDefsCount;
	/** Pointer to an array of EOS_AntiCheatCommon_RegisterEventParamDef with ParamDefsCount elements */
	const EOS_AntiCheatCommon_RegisterEventParamDef* ParamDefs;
));

#define EOS_ANTICHEATCOMMON_LOGEVENT_API_LATEST 1
#define EOS_ANTICHEATCOMMON_LOGEVENT_STRING_MAX_LENGTH 39
EOS_STRUCT(EOS_AntiCheatCommon_LogEventParamPair, (
	/** Parameter type */
	EOS_EAntiCheatCommonEventParamType ParamValueType;
	/** Parameter value */
	union
	{
		EOS_AntiCheatCommon_ClientHandle ClientHandle;
		const char* String; // Will be truncated if longer than EOS_ANTICHEATCOMMON_LOGEVENT_STRING_MAX_LENGTH bytes.
		uint32_t UInt32;
		int32_t Int32;
		uint64_t UInt64;
		int64_t Int64;
		EOS_AntiCheatCommon_Vec3f Vec3f;
		EOS_AntiCheatCommon_Quat Quat;
	} ParamValue;
));
EOS_STRUCT(EOS_AntiCheatCommon_LogEventOptions, (
	/** API Version: Set this to EOS_ANTICHEATCOMMON_LOGEVENT_API_LATEST. */
	int32_t ApiVersion;
	/** Optional client who this event is primarily associated with. If not applicable, use 0. */
	EOS_AntiCheatCommon_ClientHandle ClientHandle;
	/** Unique event identifier previously configured in RegisterEvent */
	uint32_t EventId;
	/** Number of parameters described in Params */
	uint32_t ParamsCount;
	/** Set of parameter types previously configured in RegisterEvent, and their values */
	const EOS_AntiCheatCommon_LogEventParamPair* Params;
));

#define EOS_ANTICHEATCOMMON_LOGGAMEROUNDSTART_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatCommon_LogGameRoundStartOptions, (
	/** API Version: Set this to EOS_ANTICHEATCOMMON_LOGGAMEROUNDSTART_API_LATEST. */
	int32_t ApiVersion;
	/** Optional game session or match identifier useful for some backend API integrations */
	const char* SessionIdentifier;
	/** Optional name of the map being played */
	const char* LevelName;
	/** Optional name of the game mode being played */
	const char* ModeName;
	/** Optional length of the game round to be played, in seconds. If none, use 0. */
	uint32_t RoundTimeSeconds;
));

#define EOS_ANTICHEATCOMMON_LOGGAMEROUNDEND_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatCommon_LogGameRoundEndOptions, (
	/** API Version: Set this to EOS_ANTICHEATCOMMON_LOGGAMEROUNDEND_API_LATEST. */
	int32_t ApiVersion;
	/** Optional identifier for the winning team */
	uint32_t WinningTeamId;
));

#define EOS_ANTICHEATCOMMON_LOGPLAYERSPAWN_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatCommon_LogPlayerSpawnOptions, (
	/** API Version: Set this to EOS_ANTICHEATCOMMON_LOGPLAYERSPAWN_API_LATEST. */
	int32_t ApiVersion;
	/** Locally unique value used in RegisterClient/RegisterPeer */
	EOS_AntiCheatCommon_ClientHandle SpawnedPlayerHandle;
	/** Optional identifier for the player's team. If none, use 0. */
	uint32_t TeamId;
	/** Optional identifier for the player's character. If none, use 0. */
	uint32_t CharacterId;
));

#define EOS_ANTICHEATCOMMON_LOGPLAYERDESPAWN_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatCommon_LogPlayerDespawnOptions, (
	/** API Version: Set this to EOS_ANTICHEATCOMMON_LOGPLAYERDESPAWN_API_LATEST. */
	int32_t ApiVersion;
	/** Locally unique value used in RegisterClient/RegisterPeer */
	EOS_AntiCheatCommon_ClientHandle DespawnedPlayerHandle;
));

#define EOS_ANTICHEATCOMMON_LOGPLAYERREVIVE_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatCommon_LogPlayerReviveOptions, (
	/** API Version: Set this to EOS_ANTICHEATCOMMON_LOGPLAYERREVIVE_API_LATEST. */
	int32_t ApiVersion;
	/** Locally unique value used in RegisterClient/RegisterPeer */
	EOS_AntiCheatCommon_ClientHandle RevivedPlayerHandle;
	/** Locally unique value used in RegisterClient/RegisterPeer */
	EOS_AntiCheatCommon_ClientHandle ReviverPlayerHandle;
));

#define EOS_ANTICHEATCOMMON_LOGPLAYERTICK_API_LATEST 2
EOS_STRUCT(EOS_AntiCheatCommon_LogPlayerTickOptions, (
	/** API Version: Set this to EOS_ANTICHEATCOMMON_LOGPLAYERTICK_API_LATEST. */
	int32_t ApiVersion;
	/** Locally unique value used in RegisterClient/RegisterPeer */
	EOS_AntiCheatCommon_ClientHandle PlayerHandle;
	/** Player's current world position as a 3D vector */
	EOS_AntiCheatCommon_Vec3f* PlayerPosition;
	/** Player's view rotation as a quaternion */
	EOS_AntiCheatCommon_Quat* PlayerViewRotation;
	/** True if the player's view is zoomed (e.g. using a sniper rifle), otherwise false */
	EOS_Bool bIsPlayerViewZoomed;
	/** Player's current health value */
	float PlayerHealth;
	/** Any movement state applicable */
	EOS_EAntiCheatCommonPlayerMovementState PlayerMovementState;
));

#define EOS_ANTICHEATCOMMON_LOGPLAYERUSEWEAPON_API_LATEST 2
#define EOS_ANTICHEATCOMMON_LOGPLAYERUSEWEAPON_WEAPONNAME_MAX_LENGTH 16
EOS_STRUCT(EOS_AntiCheatCommon_LogPlayerUseWeaponData, (
	/** Locally unique value used in RegisterClient/RegisterPeer */
	EOS_AntiCheatCommon_ClientHandle PlayerHandle;
	/** Attack origin world position as a 3D vector */
	EOS_AntiCheatCommon_Vec3f* PlayerPosition;
	/** Attack direction as a quaternion */
	EOS_AntiCheatCommon_Quat* PlayerViewRotation;
	/** True if the player's view is zoomed (e.g. using a sniper rifle), otherwise false */
	EOS_Bool bIsPlayerViewZoomed;
	/** Set to true if the player is using a melee attack, otherwise false */
	EOS_Bool bIsMeleeAttack;
	/** Name of the weapon used. Will be truncated to EOS_ANTICHEATCOMMON_LOGPLAYERUSEWEAPON_WEAPONNAME_MAX_LENGTH bytes if longer. */
	const char* WeaponName;
));
EOS_STRUCT(EOS_AntiCheatCommon_LogPlayerUseWeaponOptions, (
	/** API Version: Set this to EOS_ANTICHEATCOMMON_LOGPLAYERUSEWEAPON_API_LATEST. */
	int32_t ApiVersion;
	/** Struct containing detailed information about a weapon use event */
	EOS_AntiCheatCommon_LogPlayerUseWeaponData* UseWeaponData;
));

#define EOS_ANTICHEATCOMMON_LOGPLAYERUSEABILITY_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatCommon_LogPlayerUseAbilityOptions, (
	/** API Version: Set this to EOS_ANTICHEATCOMMON_LOGPLAYERUSEABILITY_API_LATEST. */
	int32_t ApiVersion;
	/** Locally unique value used in RegisterClient/RegisterPeer */
	EOS_AntiCheatCommon_ClientHandle PlayerHandle;
	/** Game defined unique identifier for the ability being used */
	uint32_t AbilityId;
	/** Duration of the ability effect in milliseconds. If not applicable, use 0. */
	uint32_t AbilityDurationMs;
	/** Cooldown until the ability can be used again in milliseconds. If not applicable, use 0. */
	uint32_t AbilityCooldownMs;
));

#define EOS_ANTICHEATCOMMON_LOGPLAYERTAKEDAMAGE_API_LATEST 3
EOS_STRUCT(EOS_AntiCheatCommon_LogPlayerTakeDamageOptions, (
	/** API Version: Set this to EOS_ANTICHEATCOMMON_LOGPLAYERTAKEDAMAGE_API_LATEST. */
	int32_t ApiVersion;
	/** Locally unique value used in RegisterClient/RegisterPeer */
	EOS_AntiCheatCommon_ClientHandle VictimPlayerHandle;
	/** Victim player's current world position as a 3D vector */
	EOS_AntiCheatCommon_Vec3f* VictimPlayerPosition;
	/** Victim player's view rotation as a quaternion */
	EOS_AntiCheatCommon_Quat* VictimPlayerViewRotation;
	/** Locally unique value used in RegisterClient/RegisterPeer */
	EOS_AntiCheatCommon_ClientHandle AttackerPlayerHandle;
	/** Attacker player's current world position as a 3D vector */
	EOS_AntiCheatCommon_Vec3f* AttackerPlayerPosition;
	/** Attacker player's view rotation as a quaternion */
	EOS_AntiCheatCommon_Quat* AttackerPlayerViewRotation;
	/**
	 * True if the damage was applied instantly at the time of attack from the game
	 * simulation's perspective, otherwise false (simulated ballistics, arrow, etc).
	 */
	EOS_Bool bIsHitscanAttack;
	/**
	 * True if there is a visible line of sight between the attacker and the victim at the time
	 * that damage is being applied, false if there is an obstacle like a wall or terrain in
	 * the way. For some situations like melee or hitscan weapons this is trivially
	 * true, for others like projectiles with simulated physics it may not be e.g. a player
	 * could fire a slow moving projectile and then move behind cover before it strikes.
	 */
	EOS_Bool bHasLineOfSight;
	/** True if this was a critical hit that causes extra damage (e.g. headshot) */
	EOS_Bool bIsCriticalHit;
	/** Deprecated - use DamagePosition instead */
	uint32_t HitBoneId_DEPRECATED;
	/** Number of health points that the victim lost due to this damage event */
	float DamageTaken;
	/** Number of health points that the victim has remaining after this damage event */
	float HealthRemaining;
	/** Source of the damage event */
	EOS_EAntiCheatCommonPlayerTakeDamageSource DamageSource;
	/** Type of the damage being applied */
	EOS_EAntiCheatCommonPlayerTakeDamageType DamageType;
	/** Result of the damage for the victim, if any */
	EOS_EAntiCheatCommonPlayerTakeDamageResult DamageResult;
	/** PlayerUseWeaponData associated with this damage event if available, otherwise NULL */
	EOS_AntiCheatCommon_LogPlayerUseWeaponData* PlayerUseWeaponData;
	/** Time in milliseconds since the PlayerUseWeaponData event occurred if available, otherwise 0 */
	uint32_t TimeSincePlayerUseWeaponMs;
	/** World position where damage hit the victim as a 3D vector if available, otherwise NULL */
	EOS_AntiCheatCommon_Vec3f* DamagePosition;
));

#pragma pack(pop)

```

`eac/sdk/Include/eos_anticheatserver.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_anticheatserver_types.h"

/**
 * Add a callback issued when a new message must be dispatched to a connected client. The bound function
 * will only be called between a successful call to EOS_AntiCheatServer_BeginSession and the matching EOS_AntiCheatServer_EndSession call.
 *
 * @param Options Structure containing input data
 * @param ClientData This value is returned to the caller when NotificationFn is invoked
 * @param NotificationFn The callback to be fired
 * @return A valid notification ID if successfully bound, or EOS_INVALID_NOTIFICATIONID otherwise
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_AntiCheatServer_AddNotifyMessageToClient(EOS_HAntiCheatServer Handle, const EOS_AntiCheatServer_AddNotifyMessageToClientOptions* Options, void* ClientData, EOS_AntiCheatServer_OnMessageToClientCallback NotificationFn);

/**
 * Remove a previously bound EOS_AntiCheatServer_AddNotifyMessageToClient handler.
 *
 * @param NotificationId The previously bound notification ID
 */
EOS_DECLARE_FUNC(void) EOS_AntiCheatServer_RemoveNotifyMessageToClient(EOS_HAntiCheatServer Handle, EOS_NotificationId NotificationId);

/**
 * Add a callback issued when an action must be applied to a connected client. The bound function
 * will only be called between a successful call to EOS_AntiCheatServer_BeginSession and the matching EOS_AntiCheatServer_EndSession call.
 *
 * @param Options Structure containing input data
 * @param ClientData This value is returned to the caller when NotificationFn is invoked
 * @param NotificationFn The callback to be fired
 * @return A valid notification ID if successfully bound, or EOS_INVALID_NOTIFICATIONID otherwise
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_AntiCheatServer_AddNotifyClientActionRequired(EOS_HAntiCheatServer Handle, const EOS_AntiCheatServer_AddNotifyClientActionRequiredOptions* Options, void* ClientData, EOS_AntiCheatServer_OnClientActionRequiredCallback NotificationFn);

/**
 * Remove a previously bound EOS_AntiCheatServer_AddNotifyClientActionRequired handler.
 *
 * @param NotificationId The previously bound notification ID
 */
EOS_DECLARE_FUNC(void) EOS_AntiCheatServer_RemoveNotifyClientActionRequired(EOS_HAntiCheatServer Handle, EOS_NotificationId NotificationId);

/**
 * Add an optional callback issued when a connected client's authentication status changes. The bound function
 * will only be called between a successful call to EOS_AntiCheatServer_BeginSession and the matching EOS_AntiCheatServer_EndSession call.
 *
 * @param Options Structure containing input data
 * @param ClientData This value is returned to the caller when NotificationFn is invoked
 * @param NotificationFn The callback to be fired
 * @return A valid notification ID if successfully bound, or EOS_INVALID_NOTIFICATIONID otherwise
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_AntiCheatServer_AddNotifyClientAuthStatusChanged(EOS_HAntiCheatServer Handle, const EOS_AntiCheatServer_AddNotifyClientAuthStatusChangedOptions* Options, void* ClientData, EOS_AntiCheatServer_OnClientAuthStatusChangedCallback NotificationFn);

/**
 * Remove a previously bound EOS_AntiCheatServer_AddNotifyClientAuthStatusChanged handler.
 *
 * @param NotificationId The previously bound notification ID
 */
EOS_DECLARE_FUNC(void) EOS_AntiCheatServer_RemoveNotifyClientAuthStatusChanged(EOS_HAntiCheatServer Handle, EOS_NotificationId NotificationId);

/**
 * Begin the gameplay session. Event callbacks must be configured with EOS_AntiCheatServer_AddNotifyMessageToClient
 * and EOS_AntiCheatServer_AddNotifyClientActionRequired before calling this function.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the initialization succeeded
 *         EOS_InvalidParameters - If input data was invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_BeginSession(EOS_HAntiCheatServer Handle, const EOS_AntiCheatServer_BeginSessionOptions* Options);

/**
 * End the gameplay session. Should be called when the server is shutting down or entering an idle state.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the initialization succeeded
 *         EOS_InvalidParameters - If input data was invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_EndSession(EOS_HAntiCheatServer Handle, const EOS_AntiCheatServer_EndSessionOptions* Options);

/**
 * Register a connected client. Must be paired with a call to UnregisterClient.
 *
 * This function may only be called between a successful call to EOS_AntiCheatServer_BeginSession and
 * the matching EOS_AntiCheatServer_EndSession call.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the player was registered successfully
 *         EOS_InvalidParameters - If input data was invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_RegisterClient(EOS_HAntiCheatServer Handle, const EOS_AntiCheatServer_RegisterClientOptions* Options);

/**
 * Unregister a disconnected client.
 *
 * This function may only be called between a successful call to EOS_AntiCheatServer_BeginSession and
 * the matching EOS_AntiCheatServer_EndSession call.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the player was unregistered successfully
 *         EOS_InvalidParameters - If input data was invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_UnregisterClient(EOS_HAntiCheatServer Handle, const EOS_AntiCheatServer_UnregisterClientOptions* Options);

/**
 * Call when an anti-cheat message is received from a client.
 *
 * This function may only be called between a successful call to EOS_AntiCheatServer_BeginSession and
 * the matching EOS_AntiCheatServer_EndSession call.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the message was processed successfully
 *         EOS_InvalidParameters - If input data was invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_ReceiveMessageFromClient(EOS_HAntiCheatServer Handle, const EOS_AntiCheatServer_ReceiveMessageFromClientOptions* Options);

/**
 * Optional. Sets or updates client details including input device and admin status.
 *
 * This function may only be called between a successful call to EOS_AntiCheatServer_BeginSession and
 * the matching EOS_AntiCheatServer_EndSession call.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the flags were updated successfully
 *         EOS_InvalidParameters - If input data was invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_SetClientDetails(EOS_HAntiCheatServer Handle, const EOS_AntiCheatCommon_SetClientDetailsOptions* Options);

/**
 * Optional. Sets or updates a game session identifier which can be attached to other data for reference.
 * The identifier can be updated at any time for currently and subsequently registered clients.
 *
 * This function may only be called between a successful call to EOS_AntiCheatServer_BeginSession and
 * the matching EOS_AntiCheatServer_EndSession call.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the game session identifier was set successfully
 *         EOS_InvalidParameters - If input data was invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_SetGameSessionId(EOS_HAntiCheatServer Handle, const EOS_AntiCheatCommon_SetGameSessionIdOptions* Options);

/**
 * Optional. Can be used to indicate that a client is legitimately known to be
 * temporarily unable to communicate, for example as a result of loading a new level.
 *
 * The bIsNetworkActive flag must be set back to true when users enter normal
 * gameplay, otherwise anti-cheat enforcement will not work correctly.
 *
 * This function may only be called between a successful call to EOS_AntiCheatServer_BeginSession and
 * the matching EOS_AntiCheatServer_EndSession call.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the network state was updated successfully
 *         EOS_InvalidParameters - If input data was invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_SetClientNetworkState(EOS_HAntiCheatServer Handle, const EOS_AntiCheatServer_SetClientNetworkStateOptions* Options);

/**
 * Optional NetProtect feature for game message encryption.
 * Calculates the required decrypted buffer size for a given input data length.
 * This will not change for a given SDK version, and allows one time allocation of reusable buffers.
 *
 * @param Options Structure containing input data.
 * @param OutBufferLengthBytes On success, the OutBuffer length in bytes that is required to call ProtectMessage on the given input size.
 *
 * @return EOS_Success - If the output length was calculated successfully
 *         EOS_InvalidParameters - If input data was invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_GetProtectMessageOutputLength(EOS_HAntiCheatServer Handle, const EOS_AntiCheatServer_GetProtectMessageOutputLengthOptions* Options, uint32_t* OutBufferSizeBytes);

/**
 * Optional NetProtect feature for game message encryption.
 * Encrypts an arbitrary message that will be sent to a game client and decrypted on the other side.
 *
 * Options.Data and OutBuffer may refer to the same buffer to encrypt in place.
 *
 * @param Options Structure containing input data.
 * @param OutBuffer On success, buffer where encrypted message data will be written.
 * @param OutBytesWritten On success, the number of bytes that were written to OutBuffer.
 *
 * @return EOS_Success - If the message was protected successfully
 *         EOS_InvalidParameters - If input data was invalid
 *         EOS_InvalidUser - If the specified ClientHandle was invalid or not currently registered. See RegisterClient.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_ProtectMessage(EOS_HAntiCheatServer Handle, const EOS_AntiCheatServer_ProtectMessageOptions* Options, void* OutBuffer, uint32_t* OutBytesWritten);

/**
 * Optional NetProtect feature for game message encryption.
 * Decrypts an encrypted message received from a game client.
 *
 * Options.Data and OutBuffer may refer to the same buffer to decrypt in place.
 *
 * @param Options Structure containing input data.
 * @param OutBuffer On success, buffer where encrypted message data will be written.
 * @param OutBytesWritten On success, the number of bytes that were written to OutBuffer.
 *
 * @return EOS_Success - If the message was unprotected successfully
 *         EOS_InvalidParameters - If input data was invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_UnprotectMessage(EOS_HAntiCheatServer Handle, const EOS_AntiCheatServer_UnprotectMessageOptions* Options, void* OutBuffer, uint32_t* OutBytesWritten);

/**
 * Optional Cerberus feature for gameplay data collection.
 * Registers a custom gameplay event.
 *
 * All custom game events must be registered before EOS_AntiCheatServer_BeginSession is called for the first time.
 * After the first call to EOS_AntiCheatServer_BeginSession, this function cannot be called any longer.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the event was registered successfully
 *         EOS_InvalidParameters - If input data was invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_RegisterEvent(EOS_HAntiCheatServer Handle, const EOS_AntiCheatCommon_RegisterEventOptions* Options);

/**
 * Optional Cerberus feature for gameplay data collection.
 * Logs a custom gameplay event.
 *
 * This function may only be called between a successful call to EOS_AntiCheatServer_BeginSession and
 * the matching EOS_AntiCheatServer_EndSession call.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the event was logged successfully
 *         EOS_InvalidParameters - If input data was invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_LogEvent(EOS_HAntiCheatServer Handle, const EOS_AntiCheatCommon_LogEventOptions* Options);

/**
 * Optional Cerberus feature for gameplay data collection.
 * Logs a new game round start.
 *
 * This function may only be called between a successful call to EOS_AntiCheatServer_BeginSession and
 * the matching EOS_AntiCheatServer_EndSession call.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the event was logged successfully
 *         EOS_InvalidParameters - If input data was invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_LogGameRoundStart(EOS_HAntiCheatServer Handle, const EOS_AntiCheatCommon_LogGameRoundStartOptions* Options);

/**
 * Optional Cerberus feature for gameplay data collection.
 * Logs a game round's end and outcome.
 *
 * This function may only be called between a successful call to EOS_AntiCheatServer_BeginSession and
 * the matching EOS_AntiCheatServer_EndSession call.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the event was logged successfully
 *         EOS_InvalidParameters - If input data was invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_LogGameRoundEnd(EOS_HAntiCheatServer Handle, const EOS_AntiCheatCommon_LogGameRoundEndOptions* Options);

/**
 * Optional Cerberus feature for gameplay data collection.
 * Logs a player spawning into the game.
 *
 * This function may only be called between a successful call to EOS_AntiCheatServer_BeginSession and
 * the matching EOS_AntiCheatServer_EndSession call.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the event was logged successfully
 *         EOS_InvalidParameters - If input data was invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_LogPlayerSpawn(EOS_HAntiCheatServer Handle, const EOS_AntiCheatCommon_LogPlayerSpawnOptions* Options);

/**
 * Optional Cerberus feature for gameplay data collection.
 * Logs a player despawning in the game, for example as a result of the character's death,
 * switching to spectator mode, etc.
 *
 * This function may only be called between a successful call to EOS_AntiCheatServer_BeginSession and
 * the matching EOS_AntiCheatServer_EndSession call.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the event was logged successfully
 *         EOS_InvalidParameters - If input data was invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_LogPlayerDespawn(EOS_HAntiCheatServer Handle, const EOS_AntiCheatCommon_LogPlayerDespawnOptions* Options);

/**
 * Optional Cerberus feature for gameplay data collection.
 * Logs a player being revived after being downed (see EOS_AntiCheatServer_LogPlayerTakeDamage options).
 *
 * This function may only be called between a successful call to EOS_AntiCheatServer_BeginSession and
 * the matching EOS_AntiCheatServer_EndSession call.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the event was logged successfully
 *         EOS_InvalidParameters - If input data was invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_LogPlayerRevive(EOS_HAntiCheatServer Handle, const EOS_AntiCheatCommon_LogPlayerReviveOptions* Options);

/**
 * Optional Cerberus feature for gameplay data collection.
 * Logs a player's general state including position and view direction.
 *
 * This function may only be called between a successful call to EOS_AntiCheatServer_BeginSession and
 * the matching EOS_AntiCheatServer_EndSession call.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the event was logged successfully
 *         EOS_InvalidParameters - If input data was invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_LogPlayerTick(EOS_HAntiCheatServer Handle, const EOS_AntiCheatCommon_LogPlayerTickOptions* Options);

/**
 * Optional Cerberus feature for gameplay data collection.
 * Logs that a player has used a weapon, for example firing one bullet or making one melee attack.
 *
 * This function may only be called between a successful call to EOS_AntiCheatServer_BeginSession and
 * the matching EOS_AntiCheatServer_EndSession call.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the event was logged successfully
 *         EOS_InvalidParameters - If input data was invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_LogPlayerUseWeapon(EOS_HAntiCheatServer Handle, const EOS_AntiCheatCommon_LogPlayerUseWeaponOptions* Options);

/**
 * Optional Cerberus feature for gameplay data collection.
 * Logs that a player has used a special ability or item which affects their character's capabilities,
 * for example temporarily increasing their speed or allowing them to see nearby players behind walls.
 *
 * This function may only be called between a successful call to EOS_AntiCheatServer_BeginSession and
 * the matching EOS_AntiCheatServer_EndSession call.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the event was logged successfully
 *         EOS_InvalidParameters - If input data was invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_LogPlayerUseAbility(EOS_HAntiCheatServer Handle, const EOS_AntiCheatCommon_LogPlayerUseAbilityOptions* Options);

/**
 * Optional Cerberus feature for gameplay data collection.
 * Logs that a player has taken damage.
 *
 * This function may only be called between a successful call to EOS_AntiCheatServer_BeginSession and
 * the matching EOS_AntiCheatServer_EndSession call.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the event was logged successfully
 *         EOS_InvalidParameters - If input data was invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_LogPlayerTakeDamage(EOS_HAntiCheatServer Handle, const EOS_AntiCheatCommon_LogPlayerTakeDamageOptions* Options);

```

`eac/sdk/Include/eos_anticheatserver_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"
#include "eos_anticheatcommon_types.h"

#pragma pack(push, 8)

EXTERN_C typedef struct EOS_AntiCheatServerHandle* EOS_HAntiCheatServer;

/**
 * Callback issued when a new message must be dispatched to a connected client.
 *
 * Messages contain opaque binary data of up to 256 bytes and must be transmitted
 * to the correct client using the game's own networking layer, then delivered
 * to the client anti-cheat instance using the EOS_AntiCheatClient_ReceiveMessageFromServer function.
 *
 * This callback is always issued from within EOS_Platform_Tick on its calling thread.
 */
EOS_DECLARE_CALLBACK(EOS_AntiCheatServer_OnMessageToClientCallback, const EOS_AntiCheatCommon_OnMessageToClientCallbackInfo* Data);

/**
 * Callback issued when an action must be applied to a connected client.
 * This callback is always issued from within EOS_Platform_Tick on its calling thread.
 */
EOS_DECLARE_CALLBACK(EOS_AntiCheatServer_OnClientActionRequiredCallback, const EOS_AntiCheatCommon_OnClientActionRequiredCallbackInfo* Data);

/**
 * Optional callback issued when a connected client's authentication status has changed.
 * This callback is always issued from within EOS_Platform_Tick on its calling thread.
 */
EOS_DECLARE_CALLBACK(EOS_AntiCheatServer_OnClientAuthStatusChangedCallback, const EOS_AntiCheatCommon_OnClientAuthStatusChangedCallbackInfo* Data);

#define EOS_ANTICHEATSERVER_ADDNOTIFYMESSAGETOCLIENT_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatServer_AddNotifyMessageToClientOptions, (
	/** API Version: Set this to EOS_ANTICHEATSERVER_ADDNOTIFYMESSAGETOCLIENT_API_LATEST. */
	int32_t ApiVersion;
));

#define EOS_ANTICHEATSERVER_ADDNOTIFYCLIENTACTIONREQUIRED_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatServer_AddNotifyClientActionRequiredOptions, (
	/** API Version: Set this to EOS_ANTICHEATSERVER_ADDNOTIFYCLIENTACTIONREQUIRED_API_LATEST. */
	int32_t ApiVersion;
));

#define EOS_ANTICHEATSERVER_ADDNOTIFYCLIENTAUTHSTATUSCHANGED_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatServer_AddNotifyClientAuthStatusChangedOptions, (
	/** API Version: Set this to EOS_ANTICHEATSERVER_ADDNOTIFYCLIENTAUTHSTATUSCHANGED_API_LATEST. */
	int32_t ApiVersion;
));

/** Limits on RegisterTimeoutSeconds parameter */
#define EOS_ANTICHEATSERVER_BEGINSESSION_MIN_REGISTERTIMEOUT 10
#define EOS_ANTICHEATSERVER_BEGINSESSION_MAX_REGISTERTIMEOUT 120
#define EOS_ANTICHEATSERVER_BEGINSESSION_API_LATEST 3
EOS_STRUCT(EOS_AntiCheatServer_BeginSessionOptions, (
	/** API Version: Set this to EOS_ANTICHEATSERVER_BEGINSESSION_API_LATEST. */
	int32_t ApiVersion;
	/** 
	 * Time in seconds to allow newly registered clients to complete anti-cheat authentication.
	 * Recommended value: 60
	 */
	uint32_t RegisterTimeoutSeconds;
	/** Optional name of this game server */
	const char* ServerName;
	/** 
	 * Gameplay data collection APIs such as LogPlayerTick will be enabled if set to true.
	 * If you do not use these APIs, it is more efficient to set this value to false.
	 */
	EOS_Bool bEnableGameplayData;
	/** The Product User ID of the local user who is associated with this session. Dedicated servers should set this to null. */
	EOS_ProductUserId LocalUserId;
));

#define EOS_ANTICHEATSERVER_ENDSESSION_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatServer_EndSessionOptions, (
	/** API Version: Set this to EOS_ANTICHEATSERVER_ENDSESSION_API_LATEST. */
	int32_t ApiVersion;
));

#define EOS_ANTICHEATSERVER_REGISTERCLIENT_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatServer_RegisterClientOptions, (
	/** API Version: Set this to EOS_ANTICHEATSERVER_REGISTERCLIENT_API_LATEST. */
	int32_t ApiVersion;
	/** Locally unique value describing the remote user (e.g. a player object pointer) */
	EOS_AntiCheatCommon_ClientHandle ClientHandle;
	/** Type of remote user being registered */
	EOS_EAntiCheatCommonClientType ClientType;
	/** Remote user's platform, if known */
	EOS_EAntiCheatCommonClientPlatform ClientPlatform;
	/** 
	 * Identifier for the remote user. This is typically a string representation of an
	 * account ID, but it can be any string which is both unique (two different users will never
	 * have the same string) and consistent (if the same user connects to this game session
	 * twice, the same string will be used) in the scope of a single protected game session.
	 */
	const char* AccountId;
	/** 
	 * Optional IP address for the remote user. May be null if not available.
	 * IPv4 format: "0.0.0.0"
	 * IPv6 format: "0:0:0:0:0:0:0:0"
	 */
	const char* IpAddress;
));

#define EOS_ANTICHEATSERVER_UNREGISTERCLIENT_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatServer_UnregisterClientOptions, (
	/** API Version: Set this to EOS_ANTICHEATSERVER_UNREGISTERCLIENT_API_LATEST. */
	int32_t ApiVersion;
	/** Locally unique value describing the remote user, as previously passed to RegisterClient */
	EOS_AntiCheatCommon_ClientHandle ClientHandle;
));

#define EOS_ANTICHEATSERVER_RECEIVEMESSAGEFROMCLIENT_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatServer_ReceiveMessageFromClientOptions, (
	/** API Version: Set this to EOS_ANTICHEATSERVER_RECEIVEMESSAGEFROMCLIENT_API_LATEST. */
	int32_t ApiVersion;
	/** Optional value, if non-null then only messages addressed to this specific client will be returned */
	EOS_AntiCheatCommon_ClientHandle ClientHandle;
	/** The size of the data received */
	uint32_t DataLengthBytes;
	/** The data received */
	const void* Data;
));

#define EOS_ANTICHEATSERVER_SETCLIENTNETWORKSTATE_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatServer_SetClientNetworkStateOptions, (
	/** API Version: Set this to EOS_ANTICHEATSERVER_SETCLIENTNETWORKSTATE_API_LATEST. */
	int32_t ApiVersion;
	/** Locally unique value describing the remote user (e.g. a player object pointer) */
	EOS_AntiCheatCommon_ClientHandle ClientHandle;
	/** True if the network is functioning normally, false if temporarily interrupted */
	EOS_Bool bIsNetworkActive;
));

#define EOS_ANTICHEATSERVER_GETPROTECTMESSAGEOUTPUTLENGTH_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatServer_GetProtectMessageOutputLengthOptions, (
	/** API Version: Set this to EOS_ANTICHEATSERVER_GETPROTECTMESSAGEOUTPUTLENGTH_API_LATEST. */
	int32_t ApiVersion;
	/** Length in bytes of input */
	uint32_t DataLengthBytes;
));

#define EOS_ANTICHEATSERVER_PROTECTMESSAGE_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatServer_ProtectMessageOptions, (
	/** API Version: Set this to EOS_ANTICHEATSERVER_PROTECTMESSAGE_API_LATEST. */
	int32_t ApiVersion;
	/** Locally unique value describing the remote user to whom the message will be sent */
	EOS_AntiCheatCommon_ClientHandle ClientHandle;
	/** Length in bytes of input */
	uint32_t DataLengthBytes;
	/** The data to encrypt */
	const void* Data;
	/** The size in bytes of OutBuffer */
	uint32_t OutBufferSizeBytes;
));

#define EOS_ANTICHEATSERVER_UNPROTECTMESSAGE_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatServer_UnprotectMessageOptions, (
	/** API Version: Set this to EOS_ANTICHEATSERVER_UNPROTECTMESSAGE_API_LATEST. */
	int32_t ApiVersion;
	/** Locally unique value describing the remote user from whom the message was received */
	EOS_AntiCheatCommon_ClientHandle ClientHandle;
	/** Length in bytes of input */
	uint32_t DataLengthBytes;
	/** The data to decrypt */
	const void* Data;
	/** The size in bytes of OutBuffer */
	uint32_t OutBufferSizeBytes;
));

#pragma pack(pop)

```

`eac/sdk/Include/eos_auth.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_auth_types.h"

/**
 * The Auth Interface is used to manage local user permissions and access to backend services through the verification of various forms of credentials.
 * All Auth Interface calls take a handle of type EOS_HAuth as the first parameter.
 * This handle can be retrieved from an EOS_HPlatform handle by using the EOS_Platform_GetAuthInterface function.
 *
 * @see EOS_Platform_GetAuthInterface
 */

/**
 * Login/Authenticate with user credentials.
 *
 * @param Options structure containing the account credentials to use during the login operation
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the login operation completes, either successfully or in error
 */
EOS_DECLARE_FUNC(void) EOS_Auth_Login(EOS_HAuth Handle, const EOS_Auth_LoginOptions* Options, void* ClientData, const EOS_Auth_OnLoginCallback CompletionDelegate);

/**
 * Signs the player out of the online service.
 *
 * @param Options structure containing information about which account to log out.
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the logout operation completes, either successfully or in error
 */
EOS_DECLARE_FUNC(void) EOS_Auth_Logout(EOS_HAuth Handle, const EOS_Auth_LogoutOptions* Options, void* ClientData, const EOS_Auth_OnLogoutCallback CompletionDelegate);

/**
 * Link external account by continuing previous login attempt with a continuance token.
 *
 * On Desktop and Mobile platforms, the user will be presented the Epic Account Portal to resolve their identity.
 *
 * On Console, the user will login to their Epic Account using an external device, e.g. a mobile device or a desktop PC,
 * by browsing to the presented authentication URL and entering the device code presented by the game on the console.
 *
 * On success, the user will be logged in at the completion of this action.
 * This will commit this external account to the Epic Account and cannot be undone in the SDK.
 *
 * @param Options structure containing the account credentials to use during the link account operation
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the link account operation completes, either successfully or in error
 */
EOS_DECLARE_FUNC(void) EOS_Auth_LinkAccount(EOS_HAuth Handle, const EOS_Auth_LinkAccountOptions* Options, void* ClientData, const EOS_Auth_OnLinkAccountCallback CompletionDelegate);

/**
 * Deletes a previously received and locally stored persistent auth access token for the currently logged in user of the local device.
 *
 * On Desktop and Mobile platforms, the access token is deleted from the keychain of the local user and a backend request is made to revoke the token on the authentication server.
 * On Console platforms, even though the caller is responsible for storing and deleting the access token on the local device,
 * this function should still be called with the access token before its deletion to make the best effort in attempting to also revoke it on the authentication server.
 * If the function would fail on Console, the caller should still proceed as normal to delete the access token locally as intended.
 *
 * @param Options structure containing operation input parameters
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the deletion operation completes, either successfully or in error
 */
EOS_DECLARE_FUNC(void) EOS_Auth_DeletePersistentAuth(EOS_HAuth Handle, const EOS_Auth_DeletePersistentAuthOptions* Options, void* ClientData, const EOS_Auth_OnDeletePersistentAuthCallback CompletionDelegate);

/**
 * Contact the backend service to verify validity of an existing user auth token.
 * This function is intended for server-side use only.
 *
 * @param Options structure containing information about the auth token being verified
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the logout operation completes, either successfully or in error
 *
 * @see EOS_Auth_CopyUserAuthToken
 */
EOS_DECLARE_FUNC(void) EOS_Auth_VerifyUserAuth(EOS_HAuth Handle, const EOS_Auth_VerifyUserAuthOptions* Options, void* ClientData, const EOS_Auth_OnVerifyUserAuthCallback CompletionDelegate);

/**
 * Fetch the number of accounts that are logged in.
 *
 * @return the number of accounts logged in.
 */
EOS_DECLARE_FUNC(int32_t) EOS_Auth_GetLoggedInAccountsCount(EOS_HAuth Handle);

/**
 * Fetch an Epic Account ID that is logged in.
 *
 * @param Index An index into the list of logged in accounts. If the index is out of bounds, the returned Epic Account ID will be invalid.
 *
 * @return The Epic Account ID associated with the index passed
 */
EOS_DECLARE_FUNC(EOS_EpicAccountId) EOS_Auth_GetLoggedInAccountByIndex(EOS_HAuth Handle, int32_t Index);

/**
 * Fetches the login status for an Epic Account ID.
 *
 * @param LocalUserId The Epic Account ID of the user being queried
 *
 * @return The enum value of a user's login status
 */
EOS_DECLARE_FUNC(EOS_ELoginStatus) EOS_Auth_GetLoginStatus(EOS_HAuth Handle, EOS_EpicAccountId LocalUserId);

/**
 * Fetch a user auth token for an Epic Account ID.
 *
 * A user authentication token allows any code with possession (backend/client) to perform certain actions on behalf of the user.
 * Because of this, for the purposes of user identity verification, the EOS_Auth_CopyIdToken API should be used instead.
 *
 * @param Options Structure containing the api version of CopyUserAuthToken to use
 * @param LocalUserId The Epic Account ID of the user being queried
 * @param OutUserAuthToken The auth token for the given user, if it exists and is valid; use EOS_Auth_Token_Release when finished
 *
 * @see EOS_Auth_Token_Release
 *
 * @return EOS_Success if the information is available and passed out in OutUserAuthToken
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the auth token is not found or expired.
 *
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Auth_CopyUserAuthToken(EOS_HAuth Handle, const EOS_Auth_CopyUserAuthTokenOptions* Options, EOS_EpicAccountId LocalUserId, EOS_Auth_Token ** OutUserAuthToken);

/**
 * Fetch an ID token for an Epic Account ID.
 *
 * ID tokens are used to securely verify user identities with online services.
 * The most common use case is using an ID token to authenticate the local user by their selected account ID,
 * which is the account ID that should be used to access any game-scoped data for the current application.
 *
 * An ID token for the selected account ID of a locally authenticated user will always be readily available.
 * To retrieve it for the selected account ID, you can use EOS_Auth_CopyIdToken directly after a successful user login.
 *
 * @param Options Structure containing the account ID for which to copy an ID token.
 * @param OutIdToken An ID token for the given user, if it exists and is valid; use EOS_Auth_IdToken_Release when finished.
 *
 * @see EOS_Auth_IdToken_Release
 *
 * @return EOS_Success if the information is available and passed out in OutUserIdToken
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the Id token is not found or expired.
 *
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Auth_CopyIdToken(EOS_HAuth Handle, const EOS_Auth_CopyIdTokenOptions* Options, EOS_Auth_IdToken ** OutIdToken);

/**
 * Query the backend for an ID token that describes one of the merged account IDs of a local authenticated user.
 *
 * The ID token can be used to impersonate a merged account ID when communicating with online services.
 *
 * An ID token for the selected account ID of a locally authenticated user will always be readily available and does not need to be queried explicitly.
 *
 * @param Options Structure containing the merged account ID for which to query an ID token.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param CompletionDelegate A callback that is fired when the operation completes, either successfully or in error.
 */
EOS_DECLARE_FUNC(void) EOS_Auth_QueryIdToken(EOS_HAuth Handle, const EOS_Auth_QueryIdTokenOptions* Options, void* ClientData, const EOS_Auth_OnQueryIdTokenCallback CompletionDelegate);

/**
 * Verify a given ID token for authenticity and validity.
 * @note Can only be called by dedicated servers.
 *
 * @param Options Structure containing information about the ID token to verify.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the operation completes, either successfully or in error.
 */
EOS_DECLARE_FUNC(void) EOS_Auth_VerifyIdToken(EOS_HAuth Handle, const EOS_Auth_VerifyIdTokenOptions* Options, void* ClientData, const EOS_Auth_OnVerifyIdTokenCallback CompletionDelegate);

/**
 * Fetch the selected account ID to the current application for a local authenticated user.
 *
 * @param LocalUserId The account ID of a currently logged in account.
 * @param OutSelectedAccountId The selected account ID corresponding to the given account ID.
 *
 * @return EOS_Success if the user is logged in and the information is available.
 *         EOS_InvalidParameters if the output parameter is NULL.
 *         EOS_InvalidUser if the input account ID is not locally known.
 *         EOS_InvalidAuth if the input account ID is not locally logged in.
 *         EOS_NotFound otherwise.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Auth_GetSelectedAccountId(EOS_HAuth Handle, const EOS_EpicAccountId LocalUserId, EOS_EpicAccountId* OutSelectedAccountId);

/**
 * Fetch the number of merged accounts for a given logged in account.
 *
 * @param LocalUserId The account ID of a currently logged in account.
 *
 * @return the number of merged accounts for the logged in account.
 */
EOS_DECLARE_FUNC(uint32_t) EOS_Auth_GetMergedAccountsCount(EOS_HAuth Handle, const EOS_EpicAccountId LocalUserId);

/**
 * Fetch one of the merged account IDs for a given logged in account.
 *
 * @param LocalUserId The account ID of a currently logged in account.
 * @param Index An index into the list of merged accounts. If the index is out of bounds, the returned Epic Account ID will be invalid.
 *
 * @return The Epic Account ID associated with the index passed.
 */
EOS_DECLARE_FUNC(EOS_EpicAccountId) EOS_Auth_GetMergedAccountByIndex(EOS_HAuth Handle, const EOS_EpicAccountId LocalUserId, const uint32_t Index);

/**
 * Register to receive login status updates.
 * @note must call RemoveNotifyLoginStatusChanged to remove the notification
 *
 * @param Options structure containing the api version of AddNotifyLoginStatusChanged to use
 * @param ClientData arbitrary data that is passed back to you in the callback
 * @param Notification a callback that is fired when the login status for a user changes
 *
 * @return handle representing the registered callback
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_Auth_AddNotifyLoginStatusChanged(EOS_HAuth Handle, const EOS_Auth_AddNotifyLoginStatusChangedOptions* Options, void* ClientData, const EOS_Auth_OnLoginStatusChangedCallback Notification);

/**
 * Unregister from receiving login status updates.
 *
 * @param InId handle representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_Auth_RemoveNotifyLoginStatusChanged(EOS_HAuth Handle, EOS_NotificationId InId);

```

`eac/sdk/Include/eos_auth_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

EXTERN_C typedef struct EOS_AuthHandle* EOS_HAuth;

/**
 * All possible types of login methods, availability depends on permissions granted to the client.
 *
 * @see EOS_Auth_Login
 * @see EOS_Auth_Credentials
 */
EOS_ENUM(EOS_ELoginCredentialType,
	/**
	 * Login using account email address and password.
	 *
	 * @note Use of this login method is restricted and cannot be used in general.
	 */
	EOS_LCT_Password = 0,
	/**
	 * A short-lived one-time use exchange code to login the local user.
	 *
	 * @details Typically retrieved via command-line parameters provided by a launcher that generated the exchange code for this application.
	 * When started, the application is expected to consume the exchange code by using the EOS_Auth_Login API as soon as possible.
	 * This is needed in order to authenticate the local user before the exchange code would expire.
	 * Attempting to consume an already expired exchange code will return EOS_EResult::AuthExchangeCodeNotFound error by the EOS_Auth_Login API.
	 */
	EOS_LCT_ExchangeCode = 1,
	/**
	 * Desktop and Mobile only; deprecated on Console platforms in favor of EOS_LCT_ExternalAuth login method.
	 *
	 * Long-lived access token that is stored on the local device to allow persisting a user login session over multiple runs of the application.
	 * When using this login type, if an existing access token is not found or it is invalid or otherwise expired, the error result EOS_EResult::EOS_InvalidAuth is returned.
	 *
	 * @note On Desktop and Mobile platforms, the persistent access token is automatically managed by the SDK that stores it in the keychain of the currently logged in user of the local device.
	 * On Console platforms, after a successful login using the EOS_LCT_DeviceCode login type,
	 * the persistent access token is retrieved using the EOS_Auth_CopyUserAuthToken API and
	 * stored by the application for the currently logged in user of the local device.
	 *
	 * @see EOS_LCT_ExternalAuth
	 */
	EOS_LCT_PersistentAuth = 2,
	/**
	 * Deprecated and no longer used. Superseded by the EOS_LCT_ExternalAuth login method.
	 *
	 * Initiates a PIN grant login flow that is used to login a local user to their Epic Account for the first time,
	 * and also whenever their locally persisted login credentials would have expired.
	 *
	 * @details The flow is as following:
	 * 1. Game initiates the user login flow by calling EOS_Auth_Login API with the EOS_LCT_DeviceCode login type.
	 * 2. The SDK internally requests the authentication backend service to begin the login flow, and returns the game
	 * a new randomly generated device code along with authorization URL information needed to complete the flow.
	 * This information is returned via the EOS_Auth_Login API callback. The EOS_Auth_LoginCallbackInfo::ResultCode
	 * will be set to EOS_Auth_PinGrantCode and the EOS_Auth_PinGrantInfo struct will contain the needed information.
	 * 3. Game presents the device code and the authorization URL information on screen to the end-user.
	 * 4. The user will login to their Epic Account using an external device, e.g. a mobile device or a desktop PC,
	 * by browsing to the presented authentication URL and entering the device code presented by the game on the console.
	 * 5. Once the user has successfully logged in on their external device, the SDK will call the EOS_Auth_Login callback
	 * once more with the operation result code. If the user failed to login within the allowed time before the device code
	 * would expire, the result code returned by the callback will contain the appropriate error result.
	 *
	 * @details After logging in a local user for the first time, the game can remember the user login to allow automatically logging
	 * in the same user the next time they start the game. This avoids prompting the same user to go through the login flow
	 * across multiple game sessions over long periods of time.
	 * To do this, after a successful login using the EOS_LCT_DeviceCode login type, the game can call the EOS_Auth_CopyUserAuthToken API
	 * to retrieve a long-lived refresh token that is specifically created for this purpose on Console. The game can store
	 * the long-lived refresh token locally on the device, for the currently logged in local user of the device.
	 * Then, on subsequent game starts the game can call the EOS_Auth_Login API with the previously stored refresh token and
	 * using the EOS_LCT_PersistentAuth login type to automatically login the current local user of the device.
	 *
	 * @see EOS_LCT_ExternalAuth
	 */
	EOS_LCT_DeviceCode = 3,
	/**
	 * Login with named credentials hosted by the EOS SDK Developer Authentication Tool.
	 *
	 * @note Used for development purposes only.
	 */
	EOS_LCT_Developer = 4,
	/**
	 * Refresh token that was retrieved from a previous call to EOS_Auth_Login API in another local process context.
	 * Mainly used in conjunction with custom launcher applications.
	 *
	 * @details Can be used for example when launching the game from Epic Games Launcher and having an intermediate process
	 * in-between that requires authenticating the user before eventually starting the actual game client application.
	 * In such scenario, an intermediate launcher will log in the user by consuming the exchange code it received from the
	 * Epic Games Launcher. To allow the game client to also authenticate the user, it can copy the refresh token using the
	 * EOS_Auth_CopyUserAuthToken API and pass it via launch parameters to the started game client. The game client can then
	 * use the refresh token to log in the user.
	 */
	EOS_LCT_RefreshToken = 5,
	/**
	 * Desktop and Mobile only.
	 *
	 * Initiate a login through the Epic account portal.
	 *
	 * @details Can be used in scenarios where seamless user login via other means is not available,
	 * for example when starting the application through a proprietary ecosystem launcher or otherwise.
	 */
	EOS_LCT_AccountPortal = 6,
	/**
	 * Login using external account provider credentials, such as Steam, PlayStation(TM)Network, Xbox Live, or Nintendo.
	 *
	 * This is the intended login method on Console. On Desktop and Mobile, used when launched through any of the commonly supported platform clients.
	 *
	 * @details The user is seamlessly logged in to their Epic account using an external account access token.
	 * If the local platform account is already linked with the user's Epic account, the login will succeed and EOS_EResult::EOS_Success is returned.
	 * When the local platform account has not been linked with an Epic account yet,
	 * EOS_EResult::EOS_InvalidUser is returned and the EOS_ContinuanceToken will be set in the EOS_Auth_LoginCallbackInfo data.
	 * If EOS_EResult::EOS_InvalidUser is returned,
	 * the application should proceed to call the EOS_Auth_LinkAccount API with the EOS_ContinuanceToken to continue with the external account login
	 * and to link the external account at the end of the login flow.
	 *
	 * @details On Console, login flow when the platform user account has not been linked with an Epic account yet:
	 * 1. Game calls EOS_Auth_Login with the EOS_LCT_ExternalAuth credential type.
	 * 2. EOS_Auth_Login returns EOS_EResult::EOS_InvalidUser with a non-null EOS_ContinuanceToken in the EOS_Auth_LoginCallbackInfo data.
	 * 3. Game calls EOS_Auth_LinkAccount with the EOS_ContinuanceToken to initiate the login flow for linking the platform account with the user's Epic account.
	 *    - During the login process, the user will be able to login to their existing Epic account or create a new account if needed.
	 * 4. EOS_Auth_LinkAccount will make an intermediate callback to provide the caller with EOS_Auth_PinGrantInfo struct set in the EOS_Auth_LoginCallbackInfo data.
	 * 5. Game examines the retrieved EOS_Auth_PinGrantInfo struct for a website URI and user code that the user needs to access off-device via a PC or mobile device.
	 *    - Game visualizes the URI and user code so that the user can proceed with the login flow outside the console.
	 *    - In the meantime, EOS SDK will internally keep polling the backend for a completion status of the login flow.
	 * 6. Once user completes the login, cancels it or if the login flow times out, EOS_Auth_LinkAccount makes the second and final callback to the caller with the operation result status.
	 *    - If the user was logged in successfully, EOS_EResult::EOS_Success is returned in the EOS_Auth_LoginCallbackInfo. Otherwise, an error result code is returned accordingly.
	 *
	 * @details On Desktop and Mobile, login flow when the platform user account has not been linked with an Epic account yet:
	 * 1. Game calls EOS_Auth_Login with the EOS_LCT_ExternalAuth credential type.
	 * 2. EOS_Auth_Login returns EOS_EResult::EOS_InvalidUser with a non-null EOS_ContinuanceToken in the EOS_Auth_LoginCallbackInfo data.
	 * 3. Game calls EOS_Auth_LinkAccount with the EOS_ContinuanceToken to initiate the login flow for linking the platform account with the user's Epic account.
	 * 4. EOS SDK automatically opens the local default web browser and takes the user to the Epic account portal web page.
	 *    - The user is able to login to their existing Epic account or create a new account if needed.
	 *    - In the meantime, EOS SDK will internally keep polling the backend for a completion status of the login flow.
	 * 5. Once user completes the login, cancels it or if the login flow times out, EOS_Auth_LinkAccount invokes the completion callback to the caller.
	 *    - If the user was logged in successfully, EOS_EResult::EOS_Success is returned in the EOS_Auth_LoginCallbackInfo. Otherwise, an error result code is returned accordingly.
	 */
	EOS_LCT_ExternalAuth = 7
);

/** The most recent version of the EOS_Auth_Token struct. */
#define EOS_AUTH_TOKEN_API_LATEST 2

/**
 * Types of auth tokens
 *
 * @see EOS_Auth_CopyUserAuthToken
 * @see EOS_Auth_Token
 */
EOS_ENUM(EOS_EAuthTokenType,
	/** Auth token is for a validated client */
	EOS_ATT_Client = 0,
	/** Auth token is for a validated user */
	EOS_ATT_User = 1
);

/**
 * A structure that contains an auth token.
 * These structures are created by EOS_Auth_CopyUserAuthToken and must be passed to EOS_Auth_Token_Release.
 */
EOS_STRUCT(EOS_Auth_Token, (
	/** API Version: Set this to EOS_AUTH_TOKEN_API_LATEST. */
	int32_t ApiVersion;
	/** Name of the app related to the client ID involved with this token */
	const char* App;
	/** Client ID that requested this token */
	const char* ClientId;
	/** The Epic Account ID associated with this auth token */
	EOS_EpicAccountId AccountId;
	/** Access token for the current user login session */
	const char* AccessToken;
	/** Time before the access token expires, in seconds, relative to the call to EOS_Auth_CopyUserAuthToken */
	double ExpiresIn;
	/** Absolute time in UTC before the access token expires, in ISO 8601 format */
	const char* ExpiresAt;
	/** Type of auth token */
	EOS_EAuthTokenType AuthType;
	/**
	 * Refresh token.
	 *
	 * @see EOS_ELoginCredentialType::EOS_LCT_RefreshToken
	 */
	const char* RefreshToken;
	/** Time before the access token expires, in seconds, relative to the call to EOS_Auth_CopyUserAuthToken */
	double RefreshExpiresIn;
	/** Absolute time in UTC before the refresh token expires, in ISO 8601 format */
	const char* RefreshExpiresAt;
));

/**
 * Release the memory associated with an EOS_Auth_Token structure. This must be called on data retrieved from EOS_Auth_CopyUserAuthToken.
 *
 * @param AuthToken The auth token structure to be released.
 *
 * @see EOS_Auth_Token
 * @see EOS_Auth_CopyUserAuthToken
 */
EOS_DECLARE_FUNC(void) EOS_Auth_Token_Release(EOS_Auth_Token* AuthToken);

/** The most recent version of the EOS_Auth_Credentials struct. */
#define EOS_AUTH_CREDENTIALS_API_LATEST 3

/**
 * A structure that contains login credentials. What is required is dependent on the type of login being initiated.
 * 
 * This is part of the input structure EOS_Auth_LoginOptions and related to device auth.
 *
 * Use of the ID and Token fields differs based on the Type. They should be null, unless specified:
 * EOS_LCT_Password - ID is the email address, and Token is the password.
 * EOS_LCT_ExchangeCode - Token is the exchange code.
 * EOS_LCT_PersistentAuth - If targeting console platforms, Token is the long lived refresh token. Otherwise N/A.
 * EOS_LCT_DeviceCode - N/A.
 * EOS_LCT_Developer - ID is the host (e.g. localhost:6547), and Token is the credential name registered in the EOS Developer Authentication Tool.
 * EOS_LCT_RefreshToken - Token is the refresh token.
 * EOS_LCT_AccountPortal - SystemAuthCredentialsOptions may be required if targeting mobile platforms. Otherwise N/A.
 * EOS_LCT_ExternalAuth - Token is the external auth token specified by ExternalType.
 *
 * @see EOS_ELoginCredentialType
 * @see EOS_Auth_Login
 * @see EOS_Auth_DeletePersistentAuthOptions
 */ 
EOS_STRUCT(EOS_Auth_Credentials, (
	/** API Version: Set this to EOS_AUTH_CREDENTIALS_API_LATEST. */
	int32_t ApiVersion;
	/** ID of the user logging in, based on EOS_ELoginCredentialType */
	const char* Id;
	/** Credentials or token related to the user logging in */
	const char* Token;
	/** Type of login. Needed to identify the auth method to use */
	EOS_ELoginCredentialType Type;
	/** 
	 * This field is for system specific options, if any.
	 *
	 * If provided, the structure will be located in (System)/eos_(system).h.
	 * The structure will be named EOS_(System)_Auth_CredentialsOptions.
	 */
	void* SystemAuthCredentialsOptions;
	/**
	 * Type of external login. Needed to identify the external auth method to use.
	 * Used when login type is set to EOS_LCT_ExternalAuth, ignored for other EOS_ELoginCredentialType methods.
	 */
	EOS_EExternalCredentialType ExternalType;
));

/** The most recent version of the EOS_Auth_PinGrantInfo struct. */
#define EOS_AUTH_PINGRANTINFO_API_LATEST 2

/**
 * Intermediate data needed to complete the EOS_LCT_DeviceCode and EOS_LCT_ExternalAuth login flows, returned by EOS_Auth_LoginCallbackInfo.  
 * The data inside should be exposed to the user for entry on a secondary device.
 * All data must be copied out before the completion of this callback.
 */
EOS_STRUCT(EOS_Auth_PinGrantInfo, (
	/** API Version: Set this to EOS_AUTH_PINGRANTINFO_API_LATEST. */
	int32_t ApiVersion;
	/** Code the user must input on an external device to activate the login */
	const char* UserCode;
	/** The end-user verification URI. Users can be asked to manually type this into their browser. */
	const char* VerificationURI;
	/** Time the user has, in seconds, to complete the process or else timeout */
	int32_t ExpiresIn;
	/** A verification URI that includes the user code. Useful for non-textual transmission. */
	const char* VerificationURIComplete;
));

/** The most recent version of the EOS_Auth_AccountFeatureRestrictedInfo struct. */
#define EOS_AUTH_ACCOUNTFEATURERESTRICTEDINFO_API_LATEST 1

/**
 * Intermediate data needed to complete account restriction verification during login flow, returned by EOS_Auth_LoginCallbackInfo when the ResultCode is EOS_Auth_AccountFeatureRestricted
 * The URI inside should be exposed to the user for entry in a web browser. The URI must be copied out of this struct before completion of the callback.
 */
EOS_STRUCT(EOS_Auth_AccountFeatureRestrictedInfo, (
	/** API Version: Set this to EOS_AUTH_ACCOUNTFEATURERESTRICTEDINFO_API_LATEST. */
	int32_t ApiVersion;
	/** The end-user verification URI. Users must be asked to open the page in a browser to address the restrictions */
	const char* VerificationURI;
));

/* Flags that describe user permissions */
EOS_ENUM(EOS_EAuthScopeFlags,
	EOS_AS_NoFlags = 0x0,
	/** Permissions to see your account ID, display name, language and country */
	EOS_AS_BasicProfile = 0x1,
	/** Permissions to see a list of your friends who use this application */
	EOS_AS_FriendsList = 0x2,
	/** Permissions to set your online presence and see presence of your friends */
	EOS_AS_Presence = 0x4,
	/** Permissions to manage the Epic friends list. This scope is restricted to Epic first party products, and attempting to use it will result in authentication failures. */
	EOS_AS_FriendsManagement = 0x8,
	/** Permissions to see email in the response when fetching information for a user. This scope is restricted to Epic first party products, and attempting to use it will result in authentication failures. */
	EOS_AS_Email = 0x10
);

EOS_ENUM_BOOLEAN_OPERATORS(EOS_EAuthScopeFlags)

/** The most recent version of the EOS_Auth_Login API. */
#define EOS_AUTH_LOGIN_API_LATEST 2

/**
 * Input parameters for the EOS_Auth_Login function.
 */
EOS_STRUCT(EOS_Auth_LoginOptions, (
	/** API Version: Set this to EOS_AUTH_LOGIN_API_LATEST. */
	int32_t ApiVersion;
	/** Credentials specified for a given login method */
	const EOS_Auth_Credentials* Credentials;
	/** Auth scope flags are permissions to request from the user while they are logging in. This is a bitwise-or union of EOS_EAuthScopeFlags flags defined above */
	EOS_EAuthScopeFlags ScopeFlags;
));

/**
 * Output parameters for the EOS_Auth_Login Function.
 */
EOS_STRUCT(EOS_Auth_LoginCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Auth_Login */
	void* ClientData;
	/** The Epic Account ID of the local user who has logged in */
	EOS_EpicAccountId LocalUserId;
	/** Optional data returned in the middle of a EOS_LCT_DeviceCode request */
	const EOS_Auth_PinGrantInfo* PinGrantInfo;
	/** If the user was not found with external auth credentials passed into EOS_Auth_Login, this continuance token can be passed to EOS_Auth_LinkAccount to continue the flow. */
	EOS_ContinuanceToken ContinuanceToken;
	/** If the user trying to login is restricted from doing so, the ResultCode of this structure will be EOS_Auth_AccountFeatureRestricted, and AccountFeatureRestrictedInfo will be populated with the data needed to get past the restriction */
	const EOS_Auth_AccountFeatureRestrictedInfo* AccountFeatureRestrictedInfo;
	/** 
	 * The Epic Account ID that has been previously selected to be used for the current application.
	 * Applications should use this ID to authenticate with online backend services that store game-scoped data for users.
	 *
	 * Note: This ID may be different from LocalUserId if the user has previously merged Epic accounts into the account
	 * represented by LocalUserId, and one of the accounts that got merged had game data associated with it for the application.
	 */
	EOS_EpicAccountId SelectedAccountId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Auth_Login
 * @param Data A EOS_Auth_LoginCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Auth_OnLoginCallback, const EOS_Auth_LoginCallbackInfo* Data);

/** The most recent version of the EOS_Auth_Logout API. */
#define EOS_AUTH_LOGOUT_API_LATEST 1

/**
 * Input parameters for the EOS_Auth_Logout function.
 */
EOS_STRUCT(EOS_Auth_LogoutOptions, (
	/** API Version: Set this to EOS_AUTH_LOGOUT_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user who is being logged out */
	EOS_EpicAccountId LocalUserId;
));

/**
 * Output parameters for the EOS_Auth_Logout Function.
 */
EOS_STRUCT(EOS_Auth_LogoutCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Auth_Login */
	void* ClientData;
	/** The Epic Account ID of the local user requesting the information */
	EOS_EpicAccountId LocalUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Auth_Logout
 * @param Data A EOS_Auth_LogoutCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Auth_OnLogoutCallback, const EOS_Auth_LogoutCallbackInfo* Data);

/**
 * Flags used to describe how the account linking operation is to be performed.
 *
 * @see EOS_Auth_LinkAccount
 */
EOS_ENUM(EOS_ELinkAccountFlags,
	/**
	 * Default flag used for a standard account linking operation.
	 *
	 * This flag is set when using a continuance token received from a previous call to the EOS_Auth_Login API,
	 * when the local user has not yet been successfully logged in to an Epic Account yet.
	 */
	EOS_LA_NoFlags = 0x0,
	/**
	 * Specified when the EOS_ContinuanceToken describes a Nintendo NSA ID account type.
	 * 
	 * This flag is used only with, and must be set, when the continuance token was received from a previous call
	 * to the EOS_Auth_Login API using the EOS_EExternalCredentialType::EOS_ECT_NINTENDO_NSA_ID_TOKEN login type.
	 */
	EOS_LA_NintendoNsaId = 0x1
);

/** The most recent version of the EOS_Auth_LinkAccount API. */
#define EOS_AUTH_LINKACCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Auth_LinkAccount function.
 */
EOS_STRUCT(EOS_Auth_LinkAccountOptions, (
	/** API Version: Set this to EOS_AUTH_LINKACCOUNT_API_LATEST. */
	int32_t ApiVersion;
	/**
	 * Combination of the enumeration flags to specify how the account linking operation will be performed.
	 */
	EOS_ELinkAccountFlags LinkAccountFlags;
	/** 
	 * Continuance token received from a previous call to the EOS_Auth_Login API.
	 *
	 * A continuance token is received in the case when the external account used for login was not found to be linked
	 * against any existing Epic Account. In such case, the application needs to proceed with an account linking operation in which case
	 * the user is first asked to create a new account or login into their existing Epic Account, and then link their external account to it.
	 * Alternatively, the application may suggest the user to login using another external account that they have already linked to their existing Epic Account.
	 * In this flow, the external account is typically the currently logged in local platform user account.
	 * It can also be another external user account that the user is offered to login with.
	 */
	EOS_ContinuanceToken ContinuanceToken;
	/**
	 * The Epic Account ID of the logged in local user whose Epic Account will be linked with the local Nintendo NSA ID Account. By default set to NULL.
	 *
	 * This parameter is only used and required to be set when EOS_ELinkAccountFlags::EOS_LA_NintendoNsaId is specified.
	 * Otherwise, set to NULL, as the standard account linking and login flow using continuance token will handle logging in the user to their Epic Account.
	 */
	EOS_EpicAccountId LocalUserId;
));

/**
 * Output parameters for the EOS_Auth_LinkAccount Function.
 */
EOS_STRUCT(EOS_Auth_LinkAccountCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Auth_LinkAccount */
	void* ClientData;
	/** The Epic Account ID of the local user whose account has been linked during login */
	EOS_EpicAccountId LocalUserId;
	/**
	 * Optional data returned when ResultCode is EOS_Auth_PinGrantCode.
	 *
	 * Once the user has logged in with their Epic Online Services account, the account will be linked with the external account supplied when EOS_Auth_Login was called.
	 * EOS_Auth_OnLinkAccountCallback will be fired again with ResultCode in EOS_Auth_LinkAccountCallbackInfo set to EOS_Success.
	 */
	const EOS_Auth_PinGrantInfo* PinGrantInfo;
	/**
	 * The Epic Account ID that has been previously selected to be used for the current application.
	 * Applications should use this ID to authenticate with online backend services that store game-scoped data for users.
	 *
	 * Note: This ID may be different from LocalUserId if the user has previously merged Epic accounts into the account
	 * represented by LocalUserId, and one of the accounts that got merged had game data associated with it for the application.
	 */
	EOS_EpicAccountId SelectedAccountId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Auth_LinkAccount
 * @param Data A EOS_Auth_LinkAccountCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Auth_OnLinkAccountCallback, const EOS_Auth_LinkAccountCallbackInfo* Data);

/** The most recent version of the EOS_Auth_VerifyUserAuth API. */
#define EOS_AUTH_VERIFYUSERAUTH_API_LATEST 1

/**
 * Input parameters for the EOS_Auth_VerifyUserAuth function.
 * This operation is destructive, the pointer will remain the same but the data pointers inside will update
 */
EOS_STRUCT(EOS_Auth_VerifyUserAuthOptions, (
	/** API Version: Set this to EOS_AUTH_VERIFYUSERAUTH_API_LATEST. */
	int32_t ApiVersion;
	/** Auth token to verify against the backend service */
	const EOS_Auth_Token* AuthToken;
));

/**
 * Output parameters for the EOS_Auth_VerifyUserAuth Function.
 */
EOS_STRUCT(EOS_Auth_VerifyUserAuthCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Auth_Login */
	void* ClientData;
));

/**
 * Function prototype definition for callbacks passed to EOS_Auth_VerifyUserAuth
 * @param Data A EOS_Auth_VerifyUserAuthCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Auth_OnVerifyUserAuthCallback, const EOS_Auth_VerifyUserAuthCallbackInfo* Data);

/** The most recent version of the EOS_Auth_CopyUserAuthToken API. */
#define EOS_AUTH_COPYUSERAUTHTOKEN_API_LATEST 1

/**
 * Input parameters for the EOS_Auth_CopyUserAuthToken function.
 */
EOS_STRUCT(EOS_Auth_CopyUserAuthTokenOptions, (
	/** API Version: Set this to EOS_AUTH_COPYUSERAUTHTOKEN_API_LATEST. */
	int32_t ApiVersion;
));

/** The most recent version of the EOS_Auth_CopyIdToken API. */
#define EOS_AUTH_COPYIDTOKEN_API_LATEST 1

/**
 * Input parameters for the EOS_Auth_CopyIdToken function.
 */
EOS_STRUCT(EOS_Auth_CopyIdTokenOptions, (
	/** API Version: Set this to EOS_AUTH_COPYIDTOKEN_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the user being queried. */
	EOS_EpicAccountId AccountId;
));

/** The most recent version of the EOS_Auth_IdToken struct. */
#define EOS_AUTH_IDTOKEN_API_LATEST 1

/**
 * A structure that contains an ID token.
 * These structures are created by EOS_Auth_CopyIdToken and must be passed to EOS_Auth_IdToken_Release when finished.
 */
EOS_STRUCT(EOS_Auth_IdToken, (
	/** API Version: Set this to EOS_AUTH_IDTOKEN_API_LATEST. */
	int32_t ApiVersion;
	/**
	 * The Epic Account ID described by the ID token.
	 * Use EOS_EpicAccountId_FromString to populate this field when validating a received ID token.
	 */
	EOS_EpicAccountId AccountId;
	/** The ID token as a Json Web Token (JWT) string. */
	const char* JsonWebToken;
));

/**
 * Release the memory associated with an EOS_Auth_IdToken structure. This must be called on data retrieved from EOS_Auth_CopyIdToken.
 *
 * @param IdToken The ID token structure to be released.
 *
 * @see EOS_Auth_IdToken
 * @see EOS_Auth_CopyIdToken
 */
EOS_DECLARE_FUNC(void) EOS_Auth_IdToken_Release(EOS_Auth_IdToken* IdToken);

/** The most recent version of the EOS_Auth_QueryIdToken API. */
#define EOS_AUTH_QUERYIDTOKEN_API_LATEST 1

/**
 * Input parameters for the EOS_Auth_QueryIdToken function.
 */
EOS_STRUCT(EOS_Auth_QueryIdTokenOptions, (
	/** API Version: Set this to EOS_AUTH_QUERYIDTOKEN_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local authenticated user. */
	EOS_EpicAccountId LocalUserId;
	/**
	 * The target Epic Account ID for which to query an ID token.
	 * This account id may be the same as the input LocalUserId or another merged account id associated with the local user's Epic account.
	 *
	 * An ID token for the selected account id of a locally authenticated user will always be readily available.
	 * To retrieve it for the selected account ID, you can use EOS_Auth_CopyIdToken directly after a successful user login.
	 */
	EOS_EpicAccountId TargetAccountId;
));

/**
 * Output parameters for the EOS_Auth_QueryIdToken Function.
 */
EOS_STRUCT(EOS_Auth_QueryIdTokenCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Auth_QueryIdToken */
	void* ClientData;
	/** The Epic Account ID of the local authenticated user. */
	EOS_EpicAccountId LocalUserId;
	/** The target Epic Account ID for which the ID token was retrieved. */
	EOS_EpicAccountId TargetAccountId;
));

EOS_DECLARE_CALLBACK(EOS_Auth_OnQueryIdTokenCallback, const EOS_Auth_QueryIdTokenCallbackInfo* Data);

/** The most recent version of the EOS_Auth_VerifyIdToken API. */
#define EOS_AUTH_VERIFYIDTOKEN_API_LATEST 1

/**
 * Input parameters for the EOS_Auth_VerifyIdToken function.
 */
EOS_STRUCT(EOS_Auth_VerifyIdTokenOptions, (
	/** API Version: Set this to EOS_AUTH_VERIFYIDTOKEN_API_LATEST. */
	int32_t ApiVersion;
	/**
	 * The ID token to verify.
	 * Use EOS_EpicAccountId_FromString to populate the AccountId field of this struct.
	 */
	const EOS_Auth_IdToken* IdToken;
));

/**
 * Output parameters for the EOS_Auth_VerifyIdToken Function.
 */
EOS_STRUCT(EOS_Auth_VerifyIdTokenCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Auth_VerifyIdToken */
	void* ClientData;
));

/**
 * Function prototype definition for callbacks passed into EOS_Auth_VerifyIdToken.
 *
 * @param Data A EOS_Auth_VerifyIdTokenCallbackInfo containing the output information and result.
 */
EOS_DECLARE_CALLBACK(EOS_Auth_OnVerifyIdTokenCallback, const EOS_Auth_VerifyIdTokenCallbackInfo* Data);

/** The most recent version of the EOS_Auth_AddNotifyLoginStatusChanged API. */
#define EOS_AUTH_ADDNOTIFYLOGINSTATUSCHANGED_API_LATEST 1

/**
 * Input parameters for the EOS_Auth_AddNotifyLoginStatusChanged Function.
 */
EOS_STRUCT(EOS_Auth_AddNotifyLoginStatusChangedOptions, (
	/** API Version: Set this to EOS_AUTH_ADDNOTIFYLOGINSTATUSCHANGED_API_LATEST. */
	int32_t ApiVersion;
));

/** The most recent version of the EOS_Auth_DeletePersistentAuth API. */
#define EOS_AUTH_DELETEPERSISTENTAUTH_API_LATEST 2

/**
 * Input parameters for the EOS_Auth_DeletePersistentAuth function.
 */
EOS_STRUCT(EOS_Auth_DeletePersistentAuthOptions, (
	/** API Version: Set this to EOS_AUTH_DELETEPERSISTENTAUTH_API_LATEST. */
	int32_t ApiVersion;
	/**
	 * A long-lived refresh token that is used with the EOS_LCT_PersistentAuth login type and is to be revoked from the authentication server. Only used on Console platforms.
	 * On Desktop and Mobile platforms, set this parameter to NULL.
	 */
	const char* RefreshToken;
));

/**
 * Output parameters for the EOS_Auth_DeletePersistentAuth Function.
 */
EOS_STRUCT(EOS_Auth_DeletePersistentAuthCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Auth_DeletePersistentAuth */
	void* ClientData;
));

/**
 * Function prototype definition for callbacks passed to EOS_Auth_DeletePersistentAuth
 * @param Data A EOS_Auth_DeletePersistentAuthCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Auth_OnDeletePersistentAuthCallback, const EOS_Auth_DeletePersistentAuthCallbackInfo* Data);

/**
 * Output parameters for the EOS_Auth_OnLoginStatusChangedCallback Function.
 */
EOS_STRUCT(EOS_Auth_LoginStatusChangedCallbackInfo, (
	/** Context that was passed into EOS_Auth_AddNotifyLoginStatusChanged */
	void* ClientData;
	/** The Epic Account ID of the local user whose status has changed */
	EOS_EpicAccountId LocalUserId;
	/** The status prior to the change */
	EOS_ELoginStatus PrevStatus;
	/** The status at the time of the notification */
	EOS_ELoginStatus CurrentStatus;
));

/**
 * Function prototype definition for notifications that come from EOS_Auth_AddNotifyLoginStatusChanged
 *
 * @param Data A EOS_Auth_LoginStatusChangedCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Auth_OnLoginStatusChangedCallback, const EOS_Auth_LoginStatusChangedCallbackInfo* Data);

#pragma pack(pop)

```

`eac/sdk/Include/eos_base.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once


#if !defined(EOS_MEMORY_CALL) || !defined(EOS_CALL) || !defined(EOS_USE_DLLEXPORT)
#if !defined(_WIN32) && !defined(_WIN64) && !defined(__ANDROID__) && !defined(__linux__) && !defined(__APPLE__)
#error \
This platform expected a `eos_<platform>_base.h` include before this header. \
Please refer to https://dev.epicgames.com/docs/services or `eos_platform_prereqs.h` for details.
#endif
#endif

#ifndef EOS_USE_DLLEXPORT
#if defined(_WIN32) || defined(__CYGWIN__)
#define EOS_USE_DLLEXPORT 1
#else
#define EOS_USE_DLLEXPORT 0
#endif
#endif

#ifndef EOS_CALL
#if defined(_WIN32) && (defined(__i386) || defined(_M_IX86))
#define EOS_CALL __stdcall
#define EOS_MEMORY_CALL __stdcall
#else
#define EOS_CALL
#define EOS_MEMORY_CALL
#endif
#endif

#if !defined(EOS_MEMORY_CALL) || !defined(EOS_CALL) || !defined(EOS_USE_DLLEXPORT)
#error \
The expected macros EOS_MEMORY_CALL, EOS_CALL, and EOS_USE_DLLEXPORT where not all defined. \
Please refer to https://dev.epicgames.com/docs/services or `eos_platform_prereqs.h` for details.
#endif


#if defined(__cplusplus)
	#if defined(_MSC_VER) && _MSC_VER >= 1800
		/* Visual Studio 2013 or later */
		#include <cstdint>
	#else
		#include <stdint.h>
		#include <stddef.h>
	#endif

	#if __cplusplus >= 201103L
		#define EOS_HAS_ENUM_CLASS
	#elif defined(_MSC_VER) && defined(_MSVC_LANG) && _MSVC_LANG >= 201103L
		#define EOS_HAS_ENUM_CLASS
	#endif
#else
	/* C Compiler */
	#include <stdint.h>
	#include <stddef.h>
#endif


typedef int32_t EOS_Bool;
#define EOS_TRUE 1
#define EOS_FALSE 0


#if defined(EOS_BUILDING_SDK) && EOS_BUILDING_SDK > 0
	#if EOS_USE_DLLEXPORT
		#ifdef __GNUC__
			#define EOS_API __attribute__ ((dllexport))
		#else
			#define EOS_API __declspec(dllexport)
		#endif
	#else
		#if __GNUC__ >= 4
			#define EOS_API __attribute__ ((visibility ("default")))
		#else
			#define EOS_API
		#endif
	#endif

#else

	#if EOS_USE_DLLEXPORT
		#if defined(EOS_MONOLITHIC) && EOS_MONOLITHIC > 0
			#define EOS_API
		#elif defined(EOS_BUILD_DLL) && EOS_BUILD_DLL > 0
			#ifdef __GNUC__
				#define EOS_API __attribute__ ((dllexport))
			#else
				#define EOS_API __declspec(dllexport)
			#endif
		#else
			#ifdef __GNUC__
				#define EOS_API __attribute__ ((dllimport))
			#else
				#define EOS_API __declspec(dllimport)
			#endif
		#endif
	#else
		#if __GNUC__ >= 4
			#define EOS_API __attribute__ ((visibility ("default")))
		#else
			#define EOS_API
		#endif
	#endif
#endif

#ifdef __cplusplus
#define EXTERN_C extern "C"
#else
#define EXTERN_C
#endif

#define EOS_DECLARE_FUNC(return_type) EXTERN_C EOS_API return_type EOS_CALL
#define EOS_DECLARE_CALLBACK(CallbackName, ...) EXTERN_C typedef void (EOS_CALL * CallbackName)(__VA_ARGS__)
#define EOS_DECLARE_CALLBACK_RETVALUE(ReturnType, CallbackName, ...) EXTERN_C typedef ReturnType (EOS_CALL * CallbackName)(__VA_ARGS__)
#define EOS_PASTE(...) __VA_ARGS__
#define EOS_STRUCT(struct_name, struct_def)           \
	EXTERN_C typedef struct _tag ## struct_name {     \
		EOS_PASTE struct_def                          \
	} struct_name


#ifdef EOS_HAS_ENUM_CLASS
#define EOS_ENUM_START(name) enum class name : int32_t {
#define EOS_ENUM_END(name) }
#else
#define EOS_ENUM_START(name) typedef enum name {
#define EOS_ENUM_END(name) , __##name##_PAD_INT32__ = 0x7FFFFFFF } name
#endif
#define EOS_ENUM(name, ...) EOS_ENUM_START(name) __VA_ARGS__ EOS_ENUM_END(name)


#ifdef EOS_HAS_ENUM_CLASS
#define EOS_ENUM_BOOLEAN_OPERATORS(name) \
/** A set of bitwise operators provided when the enum is provided as an `enum class`. */ \
inline constexpr name operator|(name Left, name Right) { return static_cast<name>((__underlying_type(name))Left | (__underlying_type(name))Right); } \
inline constexpr name operator&(name Left, name Right) { return static_cast<name>((__underlying_type(name))Left & (__underlying_type(name))Right); } \
inline constexpr name operator^(name Left, name Right) { return static_cast<name>((__underlying_type(name))Left ^ (__underlying_type(name))Right); } \
inline name& operator|=(name& Left, name Right) { return Left = Left | Right; } \
inline name& operator&=(name& Left, name Right) { return Left = Left & Right; } \
inline name& operator^=(name& Left, name Right) { return Left = Left ^ Right; } \
/**/
#else
#define EOS_ENUM_BOOLEAN_OPERATORS(name)
#endif


#undef EOS_HAS_ENUM_CLASS

```

`eac/sdk/Include/eos_common.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_base.h"

#pragma pack(push, 8)

#undef EOS_RESULT_VALUE
#undef EOS_RESULT_VALUE_LAST
#define EOS_RESULT_VALUE(Name, Value) Name = Value,
#define EOS_RESULT_VALUE_LAST(Name, Value) Name = Value

EOS_ENUM_START(EOS_EResult)
#include "eos_result.h"
EOS_ENUM_END(EOS_EResult);

#undef EOS_RESULT_VALUE
#undef EOS_RESULT_VALUE_LAST

/**
 * Returns a string representation of an EOS_EResult. 
 * The return value is never null.
 * The return value must not be freed.
 *
 * Example: EOS_EResult_ToString(EOS_Success) returns "EOS_Success"
 */
EOS_DECLARE_FUNC(const char*) EOS_EResult_ToString(EOS_EResult Result);

/**
 * Returns whether a result is to be considered the final result, or false if the callback that returned this result
 * will be called again either after some time or from another action.
 *
 * @param Result The result to check against being a final result for an operation
 * @return True if this result means the operation is complete, false otherwise
 */
EOS_DECLARE_FUNC(EOS_Bool) EOS_EResult_IsOperationComplete(EOS_EResult Result);

/**
 * Encode a byte array into hex encoded string
 *
 * @return An EOS_EResult that indicates whether the byte array was converted and copied into the OutBuffer.
 *         EOS_Success if the encoding was successful and passed out in OutBuffer
 *         EOS_InvalidParameters if you pass a null pointer on invalid length for any of the parameters
 *         EOS_LimitExceeded - The OutBuffer is not large enough to receive the encoding. InOutBufferLength contains the required minimum length to perform the operation successfully.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_ByteArray_ToString(const uint8_t* ByteArray, const uint32_t Length, char* OutBuffer, uint32_t* InOutBufferLength);

/**
 * A handle to a user's Epic Account ID
 * This ID is associated with a specific login associated with Epic Account Services
 *
 * @see EOS_Auth_Login
 */
typedef struct EOS_EpicAccountIdDetails* EOS_EpicAccountId;

/** 
 * Check whether or not the given Epic Account ID is considered valid
 * NOTE: This will return true for any EOS_EpicAccountId created with EOS_EpicAccountId_FromString as there is no validation
 * 
 * @param AccountId The Epic Account ID to check for validity
 * @return EOS_TRUE if the EOS_EpicAccountId is valid, otherwise EOS_FALSE
 */
EOS_DECLARE_FUNC(EOS_Bool) EOS_EpicAccountId_IsValid(EOS_EpicAccountId AccountId);

/**
 * Retrieve a null-terminated stringified Epic Account ID from an EOS_EpicAccountId. This is useful for replication of Epic Account IDs in multiplayer games.
 * This string will be no larger than EOS_EPICACCOUNTID_MAX_LENGTH + 1 and will only contain UTF8-encoded printable characters (excluding the null-terminator).
 *
 * @param AccountId The Epic Account ID for which to retrieve the stringified version.
 * @param OutBuffer The buffer into which the character data should be written
 * @param InOutBufferLength The size of the OutBuffer in characters.
 *                          The input buffer should include enough space to be null-terminated.
 *                          When the function returns, this parameter will be filled with the length of the string copied into OutBuffer including the null termination character.
 *
 * @return An EOS_EResult that indicates whether the Epic Account ID string was copied into the OutBuffer.
 *         EOS_Success - The OutBuffer was filled, and InOutBufferLength contains the number of characters copied into OutBuffer including the null terminator.
 *         EOS_InvalidParameters - Either OutBuffer or InOutBufferLength were passed as NULL parameters.
 *         EOS_InvalidUser - The AccountId is invalid and cannot be stringified.
 *         EOS_LimitExceeded - The OutBuffer is not large enough to receive the Epic Account ID string. InOutBufferLength contains the required minimum length to perform the operation successfully.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_EpicAccountId_ToString(EOS_EpicAccountId AccountId, char* OutBuffer, int32_t* InOutBufferLength);

/**
 * Retrieve an EOS_EpicAccountId from a raw string representing an Epic Account ID. The input string must be null-terminated.
 * NOTE: There is no validation on the string format, this should only be used with values serialized from legitimate sources such as EOS_EpicAccountId_ToString
 *
 * @param AccountIdString The stringified account ID for which to retrieve the Epic Account ID
 * @return The EOS_EpicAccountId that corresponds to the AccountIdString
 */
EOS_DECLARE_FUNC(EOS_EpicAccountId) EOS_EpicAccountId_FromString(const char* AccountIdString);

/** 
 * A character buffer of this size is large enough to fit a successful output of EOS_EpicAccountId_ToString. This length does not include the null-terminator.
 * The EpicAccountId data structure is opaque in nature and no assumptions of its structure should be inferred
 */
#define EOS_EPICACCOUNTID_MAX_LENGTH 32

/** 
 * A handle to a user's Product User ID (game services related ecosystem)
 * This ID is associated with any of the external account providers (of which Epic Account Services is one)
 * 
 * @see EOS_Connect_Login
 * @see EOS_EExternalCredentialType 
 */
typedef struct EOS_ProductUserIdDetails* EOS_ProductUserId;

/**
 * Check whether or not the given account unique ID is considered valid
 * NOTE: This will return true for any EOS_ProductUserId created with EOS_ProductUserId_FromString as there is no validation
 *
 * @param AccountId The Product User ID to check for validity
 * @return EOS_TRUE if the EOS_ProductUserId is valid, otherwise EOS_FALSE
 */
EOS_DECLARE_FUNC(EOS_Bool) EOS_ProductUserId_IsValid(EOS_ProductUserId AccountId);

/**
 * Retrieve a null-terminated stringified Product User ID from an EOS_ProductUserId. This is useful for replication of Product User IDs in multiplayer games.
 * This string will be no larger than EOS_PRODUCTUSERID_MAX_LENGTH + 1 and will only contain UTF8-encoded printable characters (excluding the null-terminator).
 *
 * @param AccountId The Product User ID for which to retrieve the stringified version.
 * @param OutBuffer The buffer into which the character data should be written
 * @param InOutBufferLength The size of the OutBuffer in characters.
 *                          The input buffer should include enough space to be null-terminated.
 *                          When the function returns, this parameter will be filled with the length of the string copied into OutBuffer including the null termination character.
 *
 * @return An EOS_EResult that indicates whether the Product User ID string was copied into the OutBuffer.
 *         EOS_Success - The OutBuffer was filled, and InOutBufferLength contains the number of characters copied into OutBuffer including the null terminator.
 *         EOS_InvalidParameters - Either OutBuffer or InOutBufferLength were passed as NULL parameters.
 *         EOS_InvalidUser - The AccountId is invalid and cannot be stringified.
 *         EOS_LimitExceeded - The OutBuffer is not large enough to receive the Product User ID string. InOutBufferLength contains the required minimum length to perform the operation successfully.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_ProductUserId_ToString(EOS_ProductUserId AccountId, char* OutBuffer, int32_t* InOutBufferLength);

/**
 * Retrieve an EOS_ProductUserId from a raw string representing an Epic Online Services Product User ID. The input string must be null-terminated.
 * NOTE: There is no validation on the string format, this should only be used with values serialized from legitimate sources such as EOS_ProductUserId_ToString
 *
 * @param ProductUserIdString The stringified product user ID for which to retrieve the Epic Online Services Product User ID
 * @return The EOS_ProductUserId that corresponds to the ProductUserIdString
 */
EOS_DECLARE_FUNC(EOS_ProductUserId) EOS_ProductUserId_FromString(const char* ProductUserIdString);

/** A character buffer of this size is large enough to fit a successful output of EOS_ProductUserId_ToString. This length does not include the null-terminator. */
#define EOS_PRODUCTUSERID_MAX_LENGTH 32

/** Handle to an existing registered notification (0 is an invalid handle) */
EXTERN_C typedef uint64_t EOS_NotificationId;

/** An invalid notification ID */
#define EOS_INVALID_NOTIFICATIONID ((EOS_NotificationId)0)

/** A handle to a continuance token @see eos_connect.h */
typedef struct EOS_ContinuanceTokenDetails* EOS_ContinuanceToken;

/**
 * Retrieve a null-terminated stringified continuance token from an EOS_ContinuanceToken.
 *
 * To get the required buffer size, call once with OutBuffer set to NULL, InOutBufferLength will contain the buffer size needed.
 * Call again with valid params to get the stringified continuance token which will only contain UTF8-encoded printable characters (excluding the null-terminator).
 *
 * @param ContinuanceToken The continuance token for which to retrieve the stringified version.
 * @param OutBuffer The buffer into which the character data should be written
 * @param InOutBufferLength The size of the OutBuffer in characters.
 *                          The input buffer should include enough space to be null-terminated.
 *                          When the function returns, this parameter will be filled with the length of the string copied into OutBuffer including the null termination character.
 *
 * @return An EOS_EResult that indicates whether the continuance token string was copied into the OutBuffer.
 *         EOS_Success - The OutBuffer was filled, and InOutBufferLength contains the number of characters copied into OutBuffer including the null terminator.
 *         EOS_InvalidParameters - Either OutBuffer or InOutBufferLength were passed as NULL parameters.
 *         EOS_InvalidUser - The AccountId is invalid and cannot be stringified.
 *         EOS_LimitExceeded - The OutBuffer is not large enough to receive the continuance token string. InOutBufferLength contains the required minimum length to perform the operation successfully.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_ContinuanceToken_ToString(EOS_ContinuanceToken ContinuanceToken, char* OutBuffer, int32_t* InOutBufferLength);

/** The most recent version of the EOS_PageQuery structs. */
#define EOS_PAGEQUERY_API_LATEST 1

/** DEPRECATED! Use EOS_PAGEQUERY_API_LATEST instead. */
#define EOS_PAGINATION_API_LATEST EOS_PAGEQUERY_API_LATEST

/** The default MaxCount used for a EOS_PageQuery when the API allows the EOS_PageQuery to be omitted. */
#define EOS_PAGEQUERY_MAXCOUNT_DEFAULT 10

/** The maximum MaxCount used for a EOS_PageQuery. */
#define EOS_PAGEQUERY_MAXCOUNT_MAXIMUM 100

/**
 * A page query is part of query options. It is used to allow pagination of query results.
 */
EOS_STRUCT(EOS_PageQuery, (
	/** API Version: Set this to EOS_PAGEQUERY_API_LATEST. */
	int32_t ApiVersion;
	/** The index into the ordered query results to start the page at. */
	int32_t StartIndex;
	/** The maximum number of results to have in the page. */
	int32_t MaxCount;
));

/**
 * A page result is part of query callback info. It is used to provide pagination details of query results.
 */
EOS_STRUCT(EOS_PageResult, (
	/** The index into the ordered query results to start the page at. */
	int32_t StartIndex;
	/** The number of results in the current page. */
	int32_t Count;
	/** The number of results associated with they original query options. */
	int32_t TotalCount;
));

/**
 * All possible states of a local user
 *
 * @see EOS_Auth_AddNotifyLoginStatusChanged
 * @see EOS_Auth_GetLoginStatus
 * @see EOS_Auth_Login
 * @see EOS_Connect_AddNotifyLoginStatusChanged
 * @see EOS_Connect_GetLoginStatus
 * @see EOS_Connect_Login
 */
EOS_ENUM(EOS_ELoginStatus,
	/** Player has not logged in or chosen a local profile */
	EOS_LS_NotLoggedIn = 0,
	/** Player is using a local profile but is not logged in */
	EOS_LS_UsingLocalProfile = 1,
	/** Player has been validated by the platform specific authentication service */
	EOS_LS_LoggedIn = 2
);

/**
 * Supported types of data that can be stored with inside an attribute (used by sessions/lobbies/etc)
 *
 * @see EOS_LobbySearch_SetParameter
 * @see EOS_SessionSearch_SetParameter
 */
EOS_ENUM(EOS_EAttributeType,
	/** Boolean value (true/false) */
	EOS_AT_BOOLEAN = 0,
	/** 64 bit integers */
	EOS_AT_INT64 = 1,
	/** Double/floating point precision */
	EOS_AT_DOUBLE = 2,
	/** UTF8 Strings */
	EOS_AT_STRING = 3
);

typedef EOS_EAttributeType EOS_ESessionAttributeType;
typedef EOS_EAttributeType EOS_ELobbyAttributeType;

/**
 * All comparison operators associated with parameters in a search query
 *
 * @see EOS_LobbySearch_SetParameter
 * @see EOS_SessionSearch_SetParameter
 */
EOS_ENUM(EOS_EComparisonOp,
	/** Value must equal the one stored on the lobby/session */
	EOS_CO_EQUAL = 0,
	/** Value must not equal the one stored on the lobby/session */
	EOS_CO_NOTEQUAL = 1,
	/** Value must be strictly greater than the one stored on the lobby/session */
	EOS_CO_GREATERTHAN = 2,
	/** Value must be greater than or equal to the one stored on the lobby/session */
	EOS_CO_GREATERTHANOREQUAL = 3,
	/** Value must be strictly less than the one stored on the lobby/session */
	EOS_CO_LESSTHAN = 4,
	/** Value must be less than or equal to the one stored on the lobby/session */
	EOS_CO_LESSTHANOREQUAL = 5,
	/** Prefer values nearest the one specified ie. abs(SearchValue-SessionValue) closest to 0 */
	EOS_CO_DISTANCE = 6,
	/** Value stored on the lobby/session may be any from a specified list */
	EOS_CO_ANYOF = 7,
	/** Value stored on the lobby/session may NOT be any from a specified list */
	EOS_CO_NOTANYOF = 8,
	/** This one value is a part of a collection */
	EOS_CO_ONEOF = 9,
	/** This one value is NOT part of a collection */
	EOS_CO_NOTONEOF = 10,
	/** This value is a CASE SENSITIVE substring of an attribute stored on the lobby/session */
	EOS_CO_CONTAINS = 11
);

typedef EOS_EComparisonOp EOS_EOnlineComparisonOp;

/**
 * All supported external account providers
 *
 * @see EOS_Connect_QueryExternalAccountMappings
 */
EOS_ENUM(EOS_EExternalAccountType,
	/** External account is associated with Epic Games */
	EOS_EAT_EPIC = 0,
	/** External account is associated with Steam */
	EOS_EAT_STEAM = 1,
	/** External account is associated with PlayStation(TM)Network */
	EOS_EAT_PSN = 2,
	/**
	 * External account is associated with Xbox Live
	 *
	 * With EOS Connect API, the associated account type is Partner XUID (PXUID).
	 * With EOS UserInfo API, the associated account type is Xbox Live ID (XUID).
	 */
	EOS_EAT_XBL = 3,
	/** External account is associated with Discord */
	EOS_EAT_DISCORD = 4,
	/** External account is associated with GOG */
	EOS_EAT_GOG = 5,
	/**
	 * External account is associated with Nintendo
	 *
	 * With both EOS Connect and EOS UserInfo APIs, the associated account type is Nintendo Service Account ID.
	 * Local user authentication is possible using Nintendo Account ID, while the account type does not get exposed to the SDK in queries related to linked accounts information.
	 */
	EOS_EAT_NINTENDO = 6,
	/** External account is associated with Uplay */
	EOS_EAT_UPLAY = 7,
	/** External account is associated with an OpenID Provider */
	EOS_EAT_OPENID = 8,
	/** External account is associated with Apple */
	EOS_EAT_APPLE = 9,
	/** External account is associated with Google */
	EOS_EAT_GOOGLE = 10,
	/** External account is associated with Oculus */
	EOS_EAT_OCULUS = 11,
	/** External account is associated with itch.io */
	EOS_EAT_ITCHIO = 12
);

/**
 * List of the supported identity providers to authenticate a user.
 *
 * The type of authentication token is specific to each provider.
 * Tokens in string format should be passed as-is to the function.
 * Tokens retrieved as raw byte arrays should be converted into a hex-encoded UTF-8 string (e.g. "FA87097A..") before being passed to the function.
 * EOS_ByteArray_ToString can be used for this conversion.
 *
 * @see EOS_Auth_Login
 * @see EOS_Connect_Login
 */
EOS_ENUM(EOS_EExternalCredentialType,
	/**
	 * Epic Games User Token
	 *
	 * Acquired using EOS_Auth_CopyUserAuthToken that returns EOS_Auth_Token::AccessToken.
	 *
	 * Supported with EOS_Connect_Login.
	 */
	EOS_ECT_EPIC = 0,
	/**
	 * Steam Encrypted App Ticket
	 *
	 * Generated using the ISteamUser::RequestEncryptedAppTicket API of Steamworks SDK.
	 * For ticket generation parameters, use pDataToInclude(NULL) and cbDataToInclude(0).
	 *
	 * The retrieved App Ticket byte buffer needs to be converted into a hex-encoded UTF-8 string (e.g. "FA87097A..") before passing it to the EOS_Auth_Login or EOS_Connect_Login APIs.
	 * EOS_ByteArray_ToString can be used for this conversion.
	 *
	 * Supported with EOS_Auth_Login, EOS_Connect_Login.
	 */
	EOS_ECT_STEAM_APP_TICKET = 1,
	/**
	 * PlayStation(TM)Network ID Token
	 *
	 * Retrieved from the PlayStation(R) SDK. Please see first-party documentation for additional information.
	 *
	 * Supported with EOS_Auth_Login, EOS_Connect_Login.
	 */
	EOS_ECT_PSN_ID_TOKEN = 2,
	/**
	 * Xbox Live XSTS Token
	 *
	 * Retrieved from the GDK and XDK. Please see first-party documentation for additional information.
	 *
	 * Supported with EOS_Auth_Login, EOS_Connect_Login.
	 */
	EOS_ECT_XBL_XSTS_TOKEN = 3,
	/**
	 * Discord Access Token
	 *
	 * Retrieved using the ApplicationManager::GetOAuth2Token API of Discord SDK.
	 *
	 * Supported with EOS_Connect_Login.
	 */
	EOS_ECT_DISCORD_ACCESS_TOKEN = 4,
	/**
	 * GOG Galaxy Encrypted App Ticket
	 *
	 * Generated using the IUser::RequestEncryptedAppTicket API of GOG Galaxy SDK.
	 * For ticket generation parameters, use data(NULL) and dataSize(0).
	 *
	 * The retrieved App Ticket byte buffer needs to be converted into a hex-encoded UTF-8 string (e.g. "FA87097A..") before passing it to the EOS_Connect_Login API.
	 * For C/C++ API integration, use the EOS_ByteArray_ToString API for the conversion.
	 * For C# integration, you can use <see cref="Helper.ToHexString" /> for the conversion.
	 *
	 * Supported with EOS_Connect_Login.
	 */
	EOS_ECT_GOG_SESSION_TICKET = 5,
	/**
	 * Nintendo Account ID Token
	 *
	 * Identifies a Nintendo user account and is acquired through web flow authentication where the local user logs in using their email address/sign-in ID and password.
	 * This is the common Nintendo account that users login with outside the Nintendo Switch device.
	 *
	 * Supported with EOS_Auth_Login, EOS_Connect_Login.
	 */
	EOS_ECT_NINTENDO_ID_TOKEN = 6,
	/**
	 * Nintendo Service Account ID Token (NSA ID)
	 *
	 * The NSA ID identifies uniquely the local Nintendo Switch device. The authentication token is acquired locally without explicit user credentials.
	 * As such, it is the primary authentication method for seamless login on Nintendo Switch.
	 *
	 * The NSA ID is not exposed directly to the user and does not provide any means for login outside the local device.
	 * Because of this, Nintendo Switch users will need to link their Nintendo Account or another external user account
	 * to their Product User ID in order to share their game progression across other platforms. Otherwise, the user will
	 * not be able to login to their existing Product User ID on another platform due to missing login credentials to use.
	 * It is recommended that the game explicitly communicates this restriction to the user so that they will know to add
	 * the first linked external account on the Nintendo Switch device and then proceed with login on another platform.
	 *
	 * In addition to sharing cross-platform game progression, linking the Nintendo Account or another external account
	 * will allow preserving the game progression permanently. Otherwise, the game progression will be tied only to the
	 * local device. In case the user loses access to their local device, they will not be able to recover the game
	 * progression if it is only associated with this account type.
	 *
	 * Supported with EOS_Auth_Login, EOS_Connect_Login.
	 */
	EOS_ECT_NINTENDO_NSA_ID_TOKEN = 7,
	/**
	 * Uplay Access Token
	 */
	EOS_ECT_UPLAY_ACCESS_TOKEN = 8,
	/**
	 * OpenID Provider Access Token
	 *
	 * Supported with EOS_Connect_Login.
	 */
	EOS_ECT_OPENID_ACCESS_TOKEN = 9,
	/**
	 * Device ID access token that identifies the current locally logged in user profile on the local device.
	 * The local user profile here refers to the operating system user login, for example the user's Windows Account
	 * or on a mobile device the default active user profile.
	 *
	 * This credential type is used to automatically login the local user using the EOS Connect Device ID feature.
	 *
	 * The intended use of the Device ID feature is to allow automatically logging in the user on a mobile device
	 * and to allow playing the game without requiring the user to necessarily login using a real user account at all.
	 * This makes a seamless first-time experience possible and allows linking the local device with a real external
	 * user account at a later time, sharing the same EOS_ProductUserId that is being used with the Device ID feature.
	 *
	 * Supported with EOS_Connect_Login.
	 *
	 * @see EOS_Connect_CreateDeviceId
	 */
	EOS_ECT_DEVICEID_ACCESS_TOKEN = 10,
	/**
	 * Apple ID Token
	 *
	 * Supported with EOS_Connect_Login.
	 */
	EOS_ECT_APPLE_ID_TOKEN = 11,
	/**
	 * Google ID Token
	 *
	 * Supported with EOS_Connect_Login.
	 */
	EOS_ECT_GOOGLE_ID_TOKEN = 12,
	/**
	 * Oculus User ID and Nonce
	 *
	 * Call ovr_User_GetUserProof(), or Platform.User.GetUserProof() if you are using Unity, to retrieve the nonce.
	 * Then pass the local User ID and the Nonce as a "{UserID}|{Nonce}" formatted string for the EOS_Connect_Login Token parameter.
	 *
	 * Note that in order to successfully retrieve a valid non-zero id for the local user using ovr_User_GetUser(),
	 * your Oculus App needs to be configured in the Oculus Developer Dashboard to have the User ID feature enabled.
	 *
	 * Supported with EOS_Connect_Login.
	 */
	EOS_ECT_OCULUS_USERID_NONCE = 13,
	/**
	 * itch.io JWT Access Token
	 *
	 * Use the itch.io app manifest to receive a JWT access token for the local user via the ITCHIO_API_KEY process environment variable.
	 * The itch.io access token is valid for 7 days after which the game needs to be restarted by the user as otherwise EOS Connect
	 * authentication session can no longer be refreshed.
	 *
	 * Supported with EOS_Connect_Login.
	 */
	EOS_ECT_ITCHIO_JWT = 14,
	/**
	 * itch.io Key Access Token
	 *
	 * This access token type is retrieved through the OAuth 2.0 authentication flow for the itch.io application.
	 *
	 * Supported with EOS_Connect_Login.
	 */
	EOS_ECT_ITCHIO_KEY = 15
);

#pragma pack(pop)

```

`eac/sdk/Include/eos_connect.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_connect_types.h"

/**
 * The Connect Interface is used to manage local user permissions and access to backend services through the verification of various forms of credentials.
 * It creates an association between third party providers and an internal mapping that allows Epic Online Services to represent a user agnostically.
 * All Connect Interface calls take a handle of type EOS_HConnect as the first parameter.
 * This handle can be retrieved from a EOS_HPlatform handle by using the EOS_Platform_GetConnectInterface function.
 *
 * @see EOS_Platform_GetConnectInterface
 */

/**
 * Login/Authenticate given a valid set of external auth credentials.
 *
 * @param Options structure containing the external account credentials and type to use during the login operation.
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate.
 * @param CompletionDelegate a callback that is fired when the login operation completes, either successfully or in error.
 */
EOS_DECLARE_FUNC(void) EOS_Connect_Login(EOS_HConnect Handle, const EOS_Connect_LoginOptions* Options, void* ClientData, const EOS_Connect_OnLoginCallback CompletionDelegate);

/**
 * Create an account association with the Epic Online Service as a product user given their external auth credentials.
 *
 * @param Options structure containing a continuance token from a "user not found" response during Login (always try login first).
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate.
 * @param CompletionDelegate a callback that is fired when the create operation completes, either successfully or in error.
 */
EOS_DECLARE_FUNC(void) EOS_Connect_CreateUser(EOS_HConnect Handle, const EOS_Connect_CreateUserOptions* Options, void* ClientData, const EOS_Connect_OnCreateUserCallback CompletionDelegate);

/**
 * Link a set of external auth credentials with an existing product user on the Epic Online Service.
 *
 * @param Options structure containing a continuance token from a "user not found" response during Login (always try login first) and a currently logged in user not already associated with this external auth provider.
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate.
 * @param CompletionDelegate a callback that is fired when the link operation completes, either successfully or in error.
 */
EOS_DECLARE_FUNC(void) EOS_Connect_LinkAccount(EOS_HConnect Handle, const EOS_Connect_LinkAccountOptions* Options, void* ClientData, const EOS_Connect_OnLinkAccountCallback CompletionDelegate);

/**
 * Unlink external auth credentials from the owning keychain of a logged in product user.
 *
 * This function allows recovering the user from scenarios where they have accidentally proceeded to creating
 * a new product user for the local native user account, instead of linking it with an existing keychain that
 * they have previously created by playing the game (or another game owned by the organization) on another platform.
 *
 * In such scenario, after the initial platform login and a new product user creation, the user wishes to re-login
 * using other set of external auth credentials to connect with their existing game progression data. In order to
 * allow automatic login also on the current platform, they will need to unlink the accidentally created new keychain
 * and product user and then use the EOS_Connect_Login and EOS_Connect_LinkAccount APIs to link the local native platform
 * account with that previously created existing product user and its owning keychain.
 *
 * In another scenario, the user may simply want to disassociate the account that they have logged in with from the current
 * keychain that it is linked with, perhaps to link it against another keychain or to separate the game progressions again.
 *
 * In order to protect against account theft, it is only possible to unlink user accounts that have been authenticated
 * and logged in to the product user in the current session. This prevents a malicious actor from gaining access to one
 * of the linked accounts and using it to remove all other accounts linked with the keychain. This also prevents a malicious
 * actor from replacing the unlinked account with their own corresponding account on the same platform, as the unlinking
 * operation will ensure that any existing authentication session cannot be used to re-link and overwrite the entry without
 * authenticating with one of the other linked accounts in the keychain. These restrictions limit the potential attack surface
 * related to account theft scenarios.
 *
 * @param Options structure containing operation input parameters.
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate.
 * @param CompletionDelegate a callback that is fired when the unlink operation completes, either successfully or in error.
 */
EOS_DECLARE_FUNC(void) EOS_Connect_UnlinkAccount(EOS_HConnect Handle, const EOS_Connect_UnlinkAccountOptions* Options, void* ClientData, const EOS_Connect_OnUnlinkAccountCallback CompletionDelegate);

/**
 * Create a new unique pseudo-account that can be used to identify the current user profile on the local device.
 *
 * This function is intended to be used by mobile games and PC games that wish to allow
 * a new user to start playing without requiring to login to the game using any user identity.
 * In addition to this, the Device ID feature is used to automatically login the local user
 * also when they have linked at least one external user account(s) with the local Device ID.
 *
 * It is possible to link many devices with the same user's account keyring using the Device ID feature.
 *
 * Linking a device later or immediately with a real user account will ensure that the player
 * will not lose their progress if they switch devices or lose the device at some point,
 * as they will be always able to login with one of their linked real accounts and also link
 * another new device with the user account associations keychain. Otherwise, without having
 * at least one permanent user account linked to the Device ID, the player would lose all of their
 * game data and progression permanently should something happen to their device or the local
 * user profile on the device.
 *
 * After a successful one-time CreateDeviceId operation, the game can login the local user
 * automatically on subsequent game starts with EOS_Connect_Login using the EOS_ECT_DEVICEID_ACCESS_TOKEN
 * credentials type. If a Device ID already exists for the local user on the device then EOS_DuplicateNotAllowed
 * error result is returned and the caller should proceed to calling EOS_Connect_Login directly.
 *
 * @param Options structure containing operation input parameters.
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate.
 * @param CompletionDelegate a callback that is fired when the create operation completes, either successfully or in error.
 */
EOS_DECLARE_FUNC(void) EOS_Connect_CreateDeviceId(EOS_HConnect Handle, const EOS_Connect_CreateDeviceIdOptions* Options, void* ClientData, const EOS_Connect_OnCreateDeviceIdCallback CompletionDelegate);

/**
 * Delete any existing Device ID access credentials for the current user profile on the local device.
 *
 * The deletion is permanent and it is not possible to recover lost game data and progression
 * if the Device ID had not been linked with at least one real external user account.
 *
 * @param Options structure containing operation input parameters
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the delete operation completes, either successfully or in error
 */
EOS_DECLARE_FUNC(void) EOS_Connect_DeleteDeviceId(EOS_HConnect Handle, const EOS_Connect_DeleteDeviceIdOptions* Options, void* ClientData, const EOS_Connect_OnDeleteDeviceIdCallback CompletionDelegate);

/**
 * Transfer a Device ID pseudo-account and the product user associated with it into another
 * keychain linked with real user accounts (such as Epic Games, PlayStation(TM)Network, Xbox Live, and other).
 *
 * This function allows transferring a product user, i.e. the local user's game progression
 * backend data from a Device ID owned keychain into a keychain with real user accounts
 * linked to it. The transfer of Device ID owned product user into a keychain of real user
 * accounts allows persisting the user's game data on the backend in the event that they
 * would lose access to the local device or otherwise switch to another device or platform.
 *
 * This function is only applicable in the situation of where the local user first plays
 * the game using the anonymous Device ID login, then later logs in using a real user
 * account that they have also already used to play the same game or another game under the
 * same organization within Epic Online Services. In such situation, while normally the login
 * attempt with a real user account would return EOS_InvalidUser and an EOS_ContinuanceToken
 * and allow calling the EOS_Connect_LinkAccount API to link it with the Device ID's keychain,
 * instead the login operation succeeds and finds an existing user because the association
 * already exists. Because the user cannot have two product users simultaneously to play with,
 * the game should prompt the user to choose which profile to keep and which one to discard
 * permanently. Based on the user choice, the game may then proceed to transfer the Device ID
 * login into the keychain that is persistent and backed by real user accounts, and if the user
 * chooses so, move the product user as well into the destination keychain and overwrite the
 * existing previous product user with it. To clarify, moving the product user with the Device ID
 * login in this way into a persisted keychain allows to preserve the so far only locally persisted
 * game progression and thus protect the user against a case where they lose access to the device.
 *
 * On success, the completion callback will return the preserved EOS_ProductUserId that remains
 * logged in while the discarded EOS_ProductUserId has been invalidated and deleted permanently.
 * Consecutive logins using the existing Device ID login type or the external account will
 * connect the user to the same backend data belonging to the preserved EOS_ProductUserId.
 *
 * Example walkthrough: Cross-platform mobile game using the anonymous Device ID login.
 *
 * For onboarding new users, the game will attempt to always automatically login the local user
 * by calling EOS_Connect_Login using the EOS_ECT_DEVICEID_ACCESS_TOKEN login type. If the local
 * Device ID credentials are not found, and the game wants a frictionless entry for the first time
 * user experience, the game will automatically call EOS_Connect_CreateDeviceId to create new
 * Device ID pseudo-account and then login the local user into it. Consecutive game starts will
 * thus automatically login the user to their locally persisted Device ID account.
 *
 * The user starts playing anonymously using the Device ID login type and makes significant game progress.
 * Later, they login using an external account that they have already used previously for the
 * same game perhaps on another platform, or another game owned by the same organization.
 * In such case, EOS_Connect_Login will automatically login the user to their existing account
 * linking keychain and create automatically a new empty product user for this product.
 *
 * In order for the user to use their existing previously created keychain and have the locally
 * created Device ID login reference to that keychain instead, the user's current product user
 * needs to be moved to be under that keychain so that their existing game progression will be
 * preserved. To do so, the game can call EOS_Connect_TransferDeviceIdAccount to transfer the
 * Device ID login and the product user associated with it into the other keychain that has real
 * external user account(s) linked to it. Note that it is important that the game either automatically
 * checks that the other product user does not have any meaningful progression data, or otherwise
 * will prompt the user to make the choice on which game progression to preserve and which can
 * be discarded permanently. The other product user will be discarded permanently and cannot be
 * recovered, so it is very important that the user is guided to make the right choice to avoid
 * accidental loss of all game progression.
 *
 * @see EOS_Connect_Login
 * @see EOS_Connect_CreateDeviceId
 *
 * @param Options structure containing the logged in product users and specifying which one will be preserved.
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate.
 * @param CompletionDelegate a callback that is fired when the transfer operation completes, either successfully or in error.
 */
EOS_DECLARE_FUNC(void) EOS_Connect_TransferDeviceIdAccount(EOS_HConnect Handle, const EOS_Connect_TransferDeviceIdAccountOptions* Options, void* ClientData, const EOS_Connect_OnTransferDeviceIdAccountCallback CompletionDelegate);

/**
 * Retrieve the equivalent Product User IDs from a list of external account IDs from supported account providers.
 * The values will be cached and retrievable through EOS_Connect_GetExternalAccountMapping.
 *
 * @param Options structure containing a list of external account IDs, in string form, to query for the Product User ID representation.
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate.
 * @param CompletionDelegate a callback that is fired when the query operation completes, either successfully or in error.
 */
EOS_DECLARE_FUNC(void) EOS_Connect_QueryExternalAccountMappings(EOS_HConnect Handle, const EOS_Connect_QueryExternalAccountMappingsOptions* Options, void* ClientData, const EOS_Connect_OnQueryExternalAccountMappingsCallback CompletionDelegate);

/**
 * Retrieve the equivalent external account mappings from a list of Product User IDs.
 * This will include data for each external account info found for the linked product IDs.
 *
 * The values will be cached and retrievable via EOS_Connect_GetProductUserIdMapping, EOS_Connect_CopyProductUserExternalAccountByIndex,
 * EOS_Connect_CopyProductUserExternalAccountByAccountType or EOS_Connect_CopyProductUserExternalAccountByAccountId.
 *
 * @see EOS_Connect_ExternalAccountInfo
 * @see EOS_Connect_GetProductUserExternalAccountCount
 * @see EOS_Connect_GetProductUserIdMapping
 * @see EOS_Connect_CopyProductUserExternalAccountByIndex
 * @see EOS_Connect_CopyProductUserExternalAccountByAccountType
 * @see EOS_Connect_CopyProductUserExternalAccountByAccountId
 * @see EOS_Connect_CopyProductUserInfo
 *
 * @param Options structure containing a list of Product User IDs to query for the external account representation.
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate.
 * @param CompletionDelegate a callback that is fired when the query operation completes, either successfully or in error.
 */
EOS_DECLARE_FUNC(void) EOS_Connect_QueryProductUserIdMappings(EOS_HConnect Handle, const EOS_Connect_QueryProductUserIdMappingsOptions* Options, void* ClientData, const EOS_Connect_OnQueryProductUserIdMappingsCallback CompletionDelegate);

/**
 * Fetch a Product User ID that maps to an external account ID cached from a previous query.
 *
 * @param Options structure containing the local user and target external account ID.
 *
 * @return The Product User ID, previously retrieved from the backend service, for the given target external account.
 */
EOS_DECLARE_FUNC(EOS_ProductUserId) EOS_Connect_GetExternalAccountMapping(EOS_HConnect Handle, const EOS_Connect_GetExternalAccountMappingsOptions* Options);

/**
 * Fetch an external account ID, in string form, that maps to a given Product User ID.
 *
 * @param Options structure containing the local user and target Product User ID.
 * @param OutBuffer The buffer into which the external account ID data should be written. The buffer must be long enough to hold a string of EOS_CONNECT_EXTERNAL_ACCOUNT_ID_MAX_LENGTH.
 * @param InOutBufferLength The size of the OutBuffer in characters.
 *                          The input buffer should include enough space to be null-terminated.
 *                          When the function returns, this parameter will be filled with the length of the string copied into OutBuffer.
 *
 * @return An EOS_EResult that indicates the external account ID was copied into the OutBuffer.
 *         EOS_Success if the information is available and passed out in OutUserInfo.
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter.
 *         EOS_NotFound if the mapping doesn't exist or hasn't been queried yet.
 *         EOS_LimitExceeded if the OutBuffer is not large enough to receive the external account ID. InOutBufferLength contains the required minimum length to perform the operation successfully.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Connect_GetProductUserIdMapping(EOS_HConnect Handle, const EOS_Connect_GetProductUserIdMappingOptions* Options, char* OutBuffer, int32_t* InOutBufferLength);

/**
 * Fetch the number of linked external accounts for a Product User ID.
 *
 * @param Options The Options associated with retrieving the external account info count.
 *
 * @see EOS_Connect_CopyProductUserExternalAccountByIndex
 *
 * @return Number of external accounts or 0 otherwise.
 */
EOS_DECLARE_FUNC(uint32_t) EOS_Connect_GetProductUserExternalAccountCount(EOS_HConnect Handle, const EOS_Connect_GetProductUserExternalAccountCountOptions* Options);

/**
 * Fetch information about an external account linked to a Product User ID.
 * On a successful call, the caller must release the returned structure using the EOS_Connect_ExternalAccountInfo_Release API.
 *
 * @param Options Structure containing the target index.
 * @param OutExternalAccountInfo The external account info data for the user with given index.
 *
 * @see EOS_Connect_ExternalAccountInfo_Release
 *
 * @return An EOS_EResult that indicates the external account data was copied into the OutExternalAccountInfo.
 *         EOS_Success if the information is available and passed out in OutExternalAccountInfo.
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter.
 *         EOS_NotFound if the account data doesn't exist or hasn't been queried yet.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Connect_CopyProductUserExternalAccountByIndex(EOS_HConnect Handle, const EOS_Connect_CopyProductUserExternalAccountByIndexOptions* Options, EOS_Connect_ExternalAccountInfo ** OutExternalAccountInfo);

/**
 * Fetch information about an external account of a specific type linked to a Product User ID.
 * On a successful call, the caller must release the returned structure using the EOS_Connect_ExternalAccountInfo_Release API.
 *
 * @param Options Structure containing the target external account type.
 * @param OutExternalAccountInfo The external account info data for the user with given external account type.
 *
 * @see EOS_Connect_ExternalAccountInfo_Release
 *
 * @return An EOS_EResult that indicates the external account data was copied into the OutExternalAccountInfo.
 *         EOS_Success if the information is available and passed out in OutExternalAccountInfo.
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter.
 *         EOS_NotFound if the account data doesn't exist or hasn't been queried yet.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Connect_CopyProductUserExternalAccountByAccountType(EOS_HConnect Handle, const EOS_Connect_CopyProductUserExternalAccountByAccountTypeOptions* Options, EOS_Connect_ExternalAccountInfo ** OutExternalAccountInfo);

/**
 * Fetch information about an external account linked to a Product User ID.
 * On a successful call, the caller must release the returned structure using the EOS_Connect_ExternalAccountInfo_Release API.
 *
 * @param Options Structure containing the target external account ID.
 * @param OutExternalAccountInfo The external account info data for the user with given external account ID.
 *
 * @see EOS_Connect_ExternalAccountInfo_Release
 *
 * @return An EOS_EResult that indicates the external account data was copied into the OutExternalAccountInfo.
 *         EOS_Success if the information is available and passed out in OutExternalAccountInfo.
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter.
 *         EOS_NotFound if the account data doesn't exist or hasn't been queried yet.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Connect_CopyProductUserExternalAccountByAccountId(EOS_HConnect Handle, const EOS_Connect_CopyProductUserExternalAccountByAccountIdOptions* Options, EOS_Connect_ExternalAccountInfo ** OutExternalAccountInfo);

/**
 * Fetch information about a Product User, using the external account that they most recently logged in with as the reference.
 * On a successful call, the caller must release the returned structure using the EOS_Connect_ExternalAccountInfo_Release API.
 *
 * @param Options Structure containing the target external account ID.
 * @param OutExternalAccountInfo The external account info data last logged in for the user.
 *
 * @see EOS_Connect_ExternalAccountInfo_Release
 *
 * @return An EOS_EResult that indicates the external account data was copied into the OutExternalAccountInfo.
 *         EOS_Success if the information is available and passed out in OutExternalAccountInfo.
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter.
 *         EOS_NotFound if the account data doesn't exist or hasn't been queried yet.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Connect_CopyProductUserInfo(EOS_HConnect Handle, const EOS_Connect_CopyProductUserInfoOptions* Options, EOS_Connect_ExternalAccountInfo ** OutExternalAccountInfo);

/**
 * Fetch the number of product users that are logged in.
 *
 * @return the number of product users logged in.
 */
EOS_DECLARE_FUNC(int32_t) EOS_Connect_GetLoggedInUsersCount(EOS_HConnect Handle);

/**
 * Fetch a Product User ID that is logged in. This Product User ID is in the Epic Online Services namespace.
 *
 * @param Index an index into the list of logged in users. If the index is out of bounds, the returned Product User ID will be invalid.
 *
 * @return the Product User ID associated with the index passed.
 */
EOS_DECLARE_FUNC(EOS_ProductUserId) EOS_Connect_GetLoggedInUserByIndex(EOS_HConnect Handle, int32_t Index);

/**
 * Fetches the login status for an Product User ID.  This Product User ID is considered logged in as long as the underlying access token has not expired.
 *
 * @param LocalUserId the Product User ID of the user being queried.
 *
 * @return the enum value of a user's login status.
 */
EOS_DECLARE_FUNC(EOS_ELoginStatus) EOS_Connect_GetLoginStatus(EOS_HConnect Handle, EOS_ProductUserId LocalUserId);

/**
 * Register to receive upcoming authentication expiration notifications.
 * Notification is approximately 10 minutes prior to expiration.
 * Call EOS_Connect_Login again with valid third party credentials to refresh access.
 *
 * @note must call RemoveNotifyAuthExpiration to remove the notification.
 *
 * @param Options structure containing the API version of the callback to use.
 * @param ClientData arbitrary data that is passed back to you in the callback.
 * @param Notification a callback that is fired when the authentication is about to expire.
 *
 * @return handle representing the registered callback.
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_Connect_AddNotifyAuthExpiration(EOS_HConnect Handle, const EOS_Connect_AddNotifyAuthExpirationOptions* Options, void* ClientData, const EOS_Connect_OnAuthExpirationCallback Notification);

/**
 * Unregister from receiving expiration notifications.
 *
 * @param InId handle representing the registered callback.
 */
EOS_DECLARE_FUNC(void) EOS_Connect_RemoveNotifyAuthExpiration(EOS_HConnect Handle, EOS_NotificationId InId);

/**
 * Register to receive user login status updates.
 * @note must call RemoveNotifyLoginStatusChanged to remove the notification.
 *
 * @param Options structure containing the API version of the callback to use.
 * @param ClientData arbitrary data that is passed back to you in the callback.
 * @param Notification a callback that is fired when the login status for a user changes.
 *
 * @return handle representing the registered callback.
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_Connect_AddNotifyLoginStatusChanged(EOS_HConnect Handle, const EOS_Connect_AddNotifyLoginStatusChangedOptions* Options, void* ClientData, const EOS_Connect_OnLoginStatusChangedCallback Notification);

/**
 * Unregister from receiving user login status updates.
 *
 * @param InId handle representing the registered callback.
 */
EOS_DECLARE_FUNC(void) EOS_Connect_RemoveNotifyLoginStatusChanged(EOS_HConnect Handle, EOS_NotificationId InId);

/**
 * Fetches an ID token for a Product User ID.
 *
 * @param Options Structure containing information about the ID token to copy.
 * @param OutIdToken The ID token for the given user, if it exists and is valid; use EOS_Connect_IdToken_Release when finished.
 *
 * @see EOS_Connect_IdToken_Release
 *
 * @return EOS_Success if the information is available and passed out in OutIdToken.
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter.
 *         EOS_NotFound if the ID token is not found or expired.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Connect_CopyIdToken(EOS_HConnect Handle, const EOS_Connect_CopyIdTokenOptions* Options, EOS_Connect_IdToken ** OutIdToken);

/**
 * Verify a given ID token for authenticity and validity.
 * @note Can only be called by dedicated servers.
 *
 * @param Options structure containing information about the ID token to verify.
 * @param ClientData arbitrary data that is passed back to you in the callback.
 * @param CompletionDelegate a callback that is fired when the operation completes, either successfully or in error.
 */
EOS_DECLARE_FUNC(void) EOS_Connect_VerifyIdToken(EOS_HConnect Handle, const EOS_Connect_VerifyIdTokenOptions* Options, void* ClientData, const EOS_Connect_OnVerifyIdTokenCallback CompletionDelegate);

```

`eac/sdk/Include/eos_connect_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

EXTERN_C typedef struct EOS_ConnectHandle* EOS_HConnect;

/** Max length of an external account ID in string form */
#define EOS_CONNECT_EXTERNAL_ACCOUNT_ID_MAX_LENGTH 256

/** The most recent version of the EOS_Connect_Credentials struct. */
#define EOS_CONNECT_CREDENTIALS_API_LATEST 1

/**
 * A structure that contains external login credentials.
 * 
 * This is part of the input structure EOS_Connect_LoginOptions.
 *
 * @see EOS_EExternalCredentialType
 * @see EOS_Connect_Login
 */ 
EOS_STRUCT(EOS_Connect_Credentials, (
	/** API Version: Set this to EOS_CONNECT_CREDENTIALS_API_LATEST. */
	int32_t ApiVersion;
	/** External token associated with the user logging in. */
	const char* Token;
	/** Type of external login; identifies the auth method to use. */
	EOS_EExternalCredentialType Type;
));

/** Max length of a display name, not including the terminating null. */
#define EOS_CONNECT_USERLOGININFO_DISPLAYNAME_MAX_LENGTH 32

/** The most recent version of the EOS_Connect_UserLoginInfo struct. */
#define EOS_CONNECT_USERLOGININFO_API_LATEST 1

/**
 * Additional information about the local user.
 *
 * As the information passed here is client-controlled and not part of the user authentication tokens,
 * it is only treated as non-authoritative informational data to be used by some of the feature services.
 * For example displaying player names in Leaderboards rankings.
 */
EOS_STRUCT(EOS_Connect_UserLoginInfo, (
	/** API Version: Set this to EOS_CONNECT_USERLOGININFO_API_LATEST. */
	int32_t ApiVersion;
	/**
	 * The user's display name on the identity provider systems as UTF-8 encoded null-terminated string.
	 * The length of the name can be at maximum up to EOS_CONNECT_USERLOGININFO_DISPLAYNAME_MAX_LENGTH bytes.
	 */
	const char* DisplayName;
));


/** The most recent version of the EOS_Connect_Login API. */
#define EOS_CONNECT_LOGIN_API_LATEST 2

/**
 * Input parameters for the EOS_Connect_Login function.
 */
EOS_STRUCT(EOS_Connect_LoginOptions, (
	/** API Version: Set this to EOS_CONNECT_LOGIN_API_LATEST. */
	int32_t ApiVersion;
	/** Credentials specified for a given login method */
	const EOS_Connect_Credentials* Credentials;
	/**
	 * Additional non-authoritative information about the local user.
	 *
	 * This field is required to be set and only used when authenticating the user using Apple, Google, Nintendo Account, Nintendo Service Account, Oculus or the Device ID feature login.
	 * When using other identity providers, set to NULL.
	 */
	const EOS_Connect_UserLoginInfo* UserLoginInfo;
));

/**
 * Output parameters for the EOS_Connect_Login function.
 */
EOS_STRUCT(EOS_Connect_LoginCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Connect_Login. */
	void* ClientData;
	/** If login was succesful, this is the Product User ID of the local player that logged in. */
	EOS_ProductUserId LocalUserId;
	/** 
	 * If the user was not found with credentials passed into EOS_Connect_Login, 
	 * this continuance token can be passed to either EOS_Connect_CreateUser 
	 * or EOS_Connect_LinkAccount to continue the flow.
	 */
	EOS_ContinuanceToken ContinuanceToken;
));

/**
 * Function prototype definition for callbacks passed to EOS_Connect_Login.
 *
 * @param Data A EOS_Connect_LoginCallbackInfo containing the output information and result.
 */
EOS_DECLARE_CALLBACK(EOS_Connect_OnLoginCallback, const EOS_Connect_LoginCallbackInfo* Data);

/** The most recent version of the EOS_Connect_CreateUser API. */
#define EOS_CONNECT_CREATEUSER_API_LATEST 1

/**
 * Input parameters for the EOS_Connect_CreateUser function.
 */
EOS_STRUCT(EOS_Connect_CreateUserOptions, (
	/** API Version: Set this to EOS_CONNECT_CREATEUSER_API_LATEST. */
	int32_t ApiVersion;
	/** Continuance token from previous call to EOS_Connect_Login */
	EOS_ContinuanceToken ContinuanceToken;
));

/**
 * Output parameters for the EOS_Connect_CreateUser function.
 */
EOS_STRUCT(EOS_Connect_CreateUserCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Connect_CreateUser. */
	void* ClientData;
	/** If the operation succeeded, this is the Product User ID of the local user who was created. */
	EOS_ProductUserId LocalUserId;
));

EOS_DECLARE_CALLBACK(EOS_Connect_OnCreateUserCallback, const EOS_Connect_CreateUserCallbackInfo* Data);

/** The most recent version of the EOS_Connect_LinkAccount API. */
#define EOS_CONNECT_LINKACCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Connect_LinkAccount function.
 */
EOS_STRUCT(EOS_Connect_LinkAccountOptions, (
	/** API Version: Set this to EOS_CONNECT_LINKACCOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** The existing logged in product user for which to link the external account described by the continuance token. */
	EOS_ProductUserId LocalUserId;
	/** Continuance token from previous call to EOS_Connect_Login. */
	EOS_ContinuanceToken ContinuanceToken;
));

/**
 * Output parameters for the EOS_Connect_LinkAccount function.
 */
EOS_STRUCT(EOS_Connect_LinkAccountCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Connect_LinkAccount. */
	void* ClientData;
	/** The Product User ID of the existing, logged-in user whose account was linked (on success). */
	EOS_ProductUserId LocalUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Connect_LinkAccount.
 *
 * @param Data A EOS_Connect_LinkAccountCallbackInfo containing the output information and result.
 */
EOS_DECLARE_CALLBACK(EOS_Connect_OnLinkAccountCallback, const EOS_Connect_LinkAccountCallbackInfo* Data);

/** The most recent version of the EOS_Connect_UnlinkAccount API. */
#define EOS_CONNECT_UNLINKACCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Connect_UnlinkAccount Function.
 */
EOS_STRUCT(EOS_Connect_UnlinkAccountOptions, (
	/** API Version: Set this to EOS_CONNECT_UNLINKACCOUNT_API_LATEST. */
	int32_t ApiVersion;
	/**
	 * Existing logged in product user that is subject for the unlinking operation.
	 * The external account that was used to login to the product user will be unlinked from the owning keychain.
	 *
	 * On a successful operation, the product user will be logged out as the external account used to authenticate the user was unlinked from the owning keychain.
	 */
	EOS_ProductUserId LocalUserId;
));

/**
 * Output parameters for the EOS_Connect_UnlinkAccount Function.
 */
EOS_STRUCT(EOS_Connect_UnlinkAccountCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Connect_UnlinkAccount. */
	void* ClientData;
	/**
	 * The product user that was subject for the unlinking operation.
	 *
	 * On a successful operation, the local authentication session for the product user will have been invalidated.
	 * As such, the LocalUserId value will no longer be valid in any context unless the user is logged into it again.
	 */
	EOS_ProductUserId LocalUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Connect_UnlinkAccount.
 *
 * @param Data A EOS_Connect_UnlinkAccountCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Connect_OnUnlinkAccountCallback, const EOS_Connect_UnlinkAccountCallbackInfo* Data);

/** The most recent version of the EOS_Connect_CreateDeviceId API. */
#define EOS_CONNECT_CREATEDEVICEID_API_LATEST 1

/** Max length of a device model name, not including the terminating null */
#define EOS_CONNECT_CREATEDEVICEID_DEVICEMODEL_MAX_LENGTH 64

/**
 * Input parameters for the EOS_Connect_CreateDeviceId function.
 */
EOS_STRUCT(EOS_Connect_CreateDeviceIdOptions, (
	/** API Version: Set this to EOS_CONNECT_CREATEDEVICEID_API_LATEST. */
	int32_t ApiVersion;
	/**
	 * A freeform text description identifying the device type and model,
	 * which can be used in account linking management to allow the player
	 * and customer support to identify different devices linked to an EOS
	 * user keychain. For example 'iPhone 6S' or 'PC Windows'.
	 *
	 * The input string must be in UTF-8 character format, with a maximum
	 * length of 64 characters. Longer string will be silently truncated.
	 *
	 * This field is required to be present.
	 */
	const char* DeviceModel;
));

/**
 * Output parameters for the EOS_Connect_CreateDeviceId function.
 */
EOS_STRUCT(EOS_Connect_CreateDeviceIdCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Connect_CreateDeviceId. */
	void* ClientData;
));

EOS_DECLARE_CALLBACK(EOS_Connect_OnCreateDeviceIdCallback, const EOS_Connect_CreateDeviceIdCallbackInfo* Data);

/** The most recent version of the EOS_Connect_DeleteDeviceId API. */
#define EOS_CONNECT_DELETEDEVICEID_API_LATEST 1

/**
 * Input parameters for the EOS_Connect_DeleteDeviceId function.
 */
EOS_STRUCT(EOS_Connect_DeleteDeviceIdOptions, (
	/** API Version: Set this to EOS_CONNECT_DELETEDEVICEID_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_Connect_DeleteDeviceId function.
 */
EOS_STRUCT(EOS_Connect_DeleteDeviceIdCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Connect_DeleteDeviceId */
	void* ClientData;
));

EOS_DECLARE_CALLBACK(EOS_Connect_OnDeleteDeviceIdCallback, const EOS_Connect_DeleteDeviceIdCallbackInfo* Data);

/** The most recent version of the EOS_Connect_TransferDeviceIdAccount API. */
#define EOS_CONNECT_TRANSFERDEVICEIDACCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Connect_TransferDeviceIdAccount Function.
 */
EOS_STRUCT(EOS_Connect_TransferDeviceIdAccountOptions, (
	/** API Version: Set this to EOS_CONNECT_TRANSFERDEVICEIDACCOUNT_API_LATEST. */
	int32_t ApiVersion;
	/**
	 * The primary product user id, currently logged in, that is already associated with a real external user account (such as Epic Games, PlayStation(TM)Network, Xbox Live and other).
	 *
	 * The account linking keychain that owns this product user will be preserved and receive
	 * the Device ID login credentials under it.
	 */
	EOS_ProductUserId PrimaryLocalUserId;
	/**
	 * The product user id, currently logged in, that has been originally created using the anonymous local Device ID login type,
	 * and whose Device ID login will be transferred to the keychain of the PrimaryLocalUserId.
	 */
	EOS_ProductUserId LocalDeviceUserId;
	/**
	 * Specifies which EOS_ProductUserId (i.e. game progression) will be preserved in the operation.
	 *
	 * After a successful transfer operation, subsequent logins using the same external account or
	 * the same local Device ID login will return user session for the ProductUserIdToPreserve.
	 *
	 * Set to either PrimaryLocalUserId or LocalDeviceUserId.
	 */
	EOS_ProductUserId ProductUserIdToPreserve;
));

/**
 * Output parameters for the EOS_Connect_TransferDeviceIdAccount Function.
 */
EOS_STRUCT(EOS_Connect_TransferDeviceIdAccountCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Connect_TransferDeviceIdAccount. */
	void* ClientData;
	/**
	 * The ProductUserIdToPreserve that was passed to the original EOS_Connect_TransferDeviceIdAccount call.
	 *
	 * On successful operation, this EOS_ProductUserId will have a valid authentication session
	 * and the other EOS_ProductUserId value has been discarded and lost forever.
	 *
	 * The application should remove any registered notification callbacks for the discarded EOS_ProductUserId as obsolete.
	 */
	EOS_ProductUserId LocalUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Connect_TransferDeviceIdAccount.
 *
 * @param Data A EOS_Connect_TransferDeviceIdAccountCallbackInfo containing the output information and result.
 */
EOS_DECLARE_CALLBACK(EOS_Connect_OnTransferDeviceIdAccountCallback, const EOS_Connect_TransferDeviceIdAccountCallbackInfo* Data);

/** The most recent version of the EOS_Connect_QueryExternalAccountMappings API. */
#define EOS_CONNECT_QUERYEXTERNALACCOUNTMAPPINGS_API_LATEST 1

/** Maximum number of account IDs that can be queried at once */
#define EOS_CONNECT_QUERYEXTERNALACCOUNTMAPPINGS_MAX_ACCOUNT_IDS 128

/**
 * Input parameters for the EOS_Connect_QueryExternalAccountMappings function.
 */
EOS_STRUCT(EOS_Connect_QueryExternalAccountMappingsOptions, (
	/** API Version: Set this to EOS_CONNECT_QUERYEXTERNALACCOUNTMAPPINGS_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the existing, logged-in user who is querying account mappings. */
	EOS_ProductUserId LocalUserId;
	/** External auth service supplying the account IDs in string form. */
	EOS_EExternalAccountType AccountIdType;
	/** An array of external account IDs to map to the product user ID representation. */
	const char** ExternalAccountIds;
	/** Number of account IDs to query. */
	uint32_t ExternalAccountIdCount;
));

/**
 * Output parameters for the EOS_Connect_QueryExternalAccountMappings function.
 */
EOS_STRUCT(EOS_Connect_QueryExternalAccountMappingsCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Connect_QueryExternalAccountMappings. */
	void* ClientData;
	/** The Product User ID of the existing, logged-in user who made the request. */
	EOS_ProductUserId LocalUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Connect_QueryExternalAccountMappings.
 *
 * @param Data A EOS_Connect_QueryExternalAccountMappingsCallbackInfo containing the output information and result.
 */
EOS_DECLARE_CALLBACK(EOS_Connect_OnQueryExternalAccountMappingsCallback, const EOS_Connect_QueryExternalAccountMappingsCallbackInfo* Data);

/** The most recent version of the EOS_Connect_GetExternalAccountMapping API. */
#define EOS_CONNECT_GETEXTERNALACCOUNTMAPPING_API_LATEST 1

/** DEPRECATED! Use EOS_CONNECT_GETEXTERNALACCOUNTMAPPING_API_LATEST instead. */
#define EOS_CONNECT_GETEXTERNALACCOUNTMAPPINGS_API_LATEST EOS_CONNECT_GETEXTERNALACCOUNTMAPPING_API_LATEST

/**
 * Input parameters for the EOS_Connect_GetExternalAccountMapping function.
 */
EOS_STRUCT(EOS_Connect_GetExternalAccountMappingsOptions, (
	/** API Version: Set this to EOS_CONNECT_GETEXTERNALACCOUNTMAPPING_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the existing, logged-in user who is querying account mappings. */
	EOS_ProductUserId LocalUserId;
	/** External auth service supplying the account IDs in string form. */
	EOS_EExternalAccountType AccountIdType;
	/** Target user to retrieve the mapping for, as an external account ID. */
	const char* TargetExternalUserId;
));

/** The most recent version of the EOS_Connect_QueryProductUserIdMappings API. */
#define EOS_CONNECT_QUERYPRODUCTUSERIDMAPPINGS_API_LATEST 2

/**
 * Input parameters for the EOS_Connect_QueryProductUserIdMappings function.
 */
EOS_STRUCT(EOS_Connect_QueryProductUserIdMappingsOptions, (
	/** API Version: Set this to EOS_CONNECT_QUERYPRODUCTUSERIDMAPPINGS_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the existing, logged-in user who is querying account mappings. */
	EOS_ProductUserId LocalUserId;
	/** Deprecated - all external mappings are included in this call, it is no longer necessary to specify this value. */
	EOS_EExternalAccountType AccountIdType_DEPRECATED;
	/** An array of Product User IDs to query for the given external account representation. */
	EOS_ProductUserId* ProductUserIds;
	/** Number of Product User IDs to query. */
	uint32_t ProductUserIdCount;
));

/**
 * Output parameters for the EOS_Connect_QueryProductUserIdMappings function.
 */
EOS_STRUCT(EOS_Connect_QueryProductUserIdMappingsCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Connect_QueryProductUserIdMappings. */
	void* ClientData;
	/** The Product User ID of the existing, logged-in user who made the request. */
	EOS_ProductUserId LocalUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Connect_QueryProductUserIdMappings.
 *
 * @param Data A EOS_Connect_QueryProductUserIdMappingsCallbackInfo containing the output information and result.
 */
EOS_DECLARE_CALLBACK(EOS_Connect_OnQueryProductUserIdMappingsCallback, const EOS_Connect_QueryProductUserIdMappingsCallbackInfo* Data);

/** The most recent version of the EOS_Connect_GetProductUserIdMapping API. */
#define EOS_CONNECT_GETPRODUCTUSERIDMAPPING_API_LATEST 1

/**
 * Input parameters for the EOS_Connect_GetProductUserIdMapping function.
 */
EOS_STRUCT(EOS_Connect_GetProductUserIdMappingOptions, (
	/** API Version: Set this to EOS_CONNECT_GETPRODUCTUSERIDMAPPING_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the existing, logged-in user that is querying account mappings. */
	EOS_ProductUserId LocalUserId;
	/** External auth service mapping to retrieve. */
	EOS_EExternalAccountType AccountIdType;
	/** The Product User ID of the user whose information is being requested. */
	EOS_ProductUserId TargetProductUserId;
));

/** The most recent version of the EOS_Connect_GetProductUserExternalAccountCount API. */
#define EOS_CONNECT_GETPRODUCTUSEREXTERNALACCOUNTCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Connect_GetProductUserExternalAccountCount function.
 */
EOS_STRUCT(EOS_Connect_GetProductUserExternalAccountCountOptions, (
	/** API Version: Set this to EOS_CONNECT_GETPRODUCTUSEREXTERNALACCOUNTCOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID to look for when getting external account info count from the cache. */
	EOS_ProductUserId TargetUserId;
));

/** The most recent version of the EOS_Connect_CopyProductUserExternalAccountByIndex API. */
#define EOS_CONNECT_COPYPRODUCTUSEREXTERNALACCOUNTBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_Connect_CopyProductUserExternalAccountByIndex function.
 */
EOS_STRUCT(EOS_Connect_CopyProductUserExternalAccountByIndexOptions, (
	/** API Version: Set this to EOS_CONNECT_COPYPRODUCTUSEREXTERNALACCOUNTBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID to look for when copying external account info from the cache. */
	EOS_ProductUserId TargetUserId;
	/** Index of the external account info to retrieve from the cache. */
	uint32_t ExternalAccountInfoIndex;
));

/** The most recent version of the EOS_Connect_CopyProductUserExternalAccountByAccountType API. */
#define EOS_CONNECT_COPYPRODUCTUSEREXTERNALACCOUNTBYACCOUNTTYPE_API_LATEST 1

/**
 * Input parameters for the EOS_Connect_CopyProductUserExternalAccountByAccountType function.
 */
EOS_STRUCT(EOS_Connect_CopyProductUserExternalAccountByAccountTypeOptions, (
	/** API Version: Set this to EOS_CONNECT_COPYPRODUCTUSEREXTERNALACCOUNTBYACCOUNTTYPE_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID to look for when copying external account info from the cache. */
	EOS_ProductUserId TargetUserId;
	/** External auth service account type to look for when copying external account info from the cache. */
	EOS_EExternalAccountType AccountIdType;
));

/** The most recent version of the EOS_Connect_CopyProductUserExternalAccountByAccountId API. */
#define EOS_CONNECT_COPYPRODUCTUSEREXTERNALACCOUNTBYACCOUNTID_API_LATEST 1

/**
 * Input parameters for the EOS_Connect_CopyProductUserExternalAccountByAccountId function.
 */
EOS_STRUCT(EOS_Connect_CopyProductUserExternalAccountByAccountIdOptions, (
	/** API Version: Set this to EOS_CONNECT_COPYPRODUCTUSEREXTERNALACCOUNTBYACCOUNTID_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID to look for when copying external account info from the cache. */
	EOS_ProductUserId TargetUserId;
	/** External auth service account ID to look for when copying external account info from the cache. */
	const char* AccountId;
));

/** The most recent version of the EOS_Connect_CopyProductUserInfo API. */
#define EOS_CONNECT_COPYPRODUCTUSERINFO_API_LATEST 1

/**
 * Input parameters for the EOS_Connect_CopyProductUserInfo function.
 */
EOS_STRUCT(EOS_Connect_CopyProductUserInfoOptions, (
	/** API Version: Set this to EOS_CONNECT_COPYPRODUCTUSERINFO_API_LATEST. */
	int32_t ApiVersion;
	/** Product user ID to look for when copying external account info from the cache. */
	EOS_ProductUserId TargetUserId;
));

/** Timestamp value representing an undefined time for last login time. */
#define EOS_CONNECT_TIME_UNDEFINED -1

/** The most recent version of the EOS_Connect_ExternalAccountInfo struct. */
#define EOS_CONNECT_EXTERNALACCOUNTINFO_API_LATEST 1

/**
 * Contains information about an external account info
 */
EOS_STRUCT(EOS_Connect_ExternalAccountInfo, (
	/** API Version: Set this to EOS_CONNECT_EXTERNALACCOUNTINFO_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the target user. */
	EOS_ProductUserId ProductUserId;
	/** Display name, can be null if not set. */
	const char* DisplayName;
	/** External account ID. */
	const char* AccountId;
	/** The identity provider that owns the external account. */
	EOS_EExternalAccountType AccountIdType;
	/** The POSIX timestamp for the time the user last logged in, or EOS_CONNECT_TIME_UNDEFINED. */
	int64_t LastLoginTime;
));

/**
 * Release the memory associated with an external account info. This must be called on data retrieved from
 * EOS_Connect_CopyProductUserExternalAccountByIndex, EOS_Connect_CopyProductUserExternalAccountByAccountType,
 * EOS_Connect_CopyProductUserExternalAccountByAccountId or EOS_Connect_CopyProductUserInfo.
 *
 * @param ExternalAccountInfo The external account info data to release.
 *
 * @see EOS_Connect_CopyProductUserExternalAccountByIndex
 * @see EOS_Connect_CopyProductUserExternalAccountByAccountType
 * @see EOS_Connect_CopyProductUserExternalAccountByAccountId
 * @see EOS_Connect_CopyProductUserInfo
 */
EOS_DECLARE_FUNC(void) EOS_Connect_ExternalAccountInfo_Release(EOS_Connect_ExternalAccountInfo* ExternalAccountInfo);

/** The most recent version of the EOS_Connect_AddNotifyAuthExpiration API. */
#define EOS_CONNECT_ADDNOTIFYAUTHEXPIRATION_API_LATEST 1
/**
 * Structure containing information for the auth expiration notification callback.
 */
EOS_STRUCT(EOS_Connect_AddNotifyAuthExpirationOptions, (
	/** API Version: Set this to EOS_CONNECT_ADDNOTIFYAUTHEXPIRATION_API_LATEST. */
	int32_t ApiVersion;
));

/** The most recent version of the EOS_Connect_OnAuthExpirationCallback API. */
#define EOS_CONNECT_ONAUTHEXPIRATIONCALLBACK_API_LATEST 1

/**
 * Output parameters for the EOS_Connect_OnAuthExpirationCallback function.
 */
EOS_STRUCT(EOS_Connect_AuthExpirationCallbackInfo, (
	/** Context that was passed into EOS_Connect_AddNotifyAuthExpiration. */
	void* ClientData;
	/** The Product User ID of the local player whose status has changed. */
	EOS_ProductUserId LocalUserId;
));

/**
 * Function prototype definition for notifications that come from EOS_Connect_AddNotifyAuthExpiration.
 *
 * @param Data A EOS_Connect_AuthExpirationCallbackInfo containing the output information and result.
 */
EOS_DECLARE_CALLBACK(EOS_Connect_OnAuthExpirationCallback, const EOS_Connect_AuthExpirationCallbackInfo* Data);


/** The most recent version of the EOS_Connect_AddNotifyLoginStatusChanged API. */
#define EOS_CONNECT_ADDNOTIFYLOGINSTATUSCHANGED_API_LATEST 1
/**
 * Structure containing information or the connect user login status change callback.
 */
EOS_STRUCT(EOS_Connect_AddNotifyLoginStatusChangedOptions, (
	/** API Version: Set this to EOS_CONNECT_ADDNOTIFYLOGINSTATUSCHANGED_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_Connect_OnLoginStatusChangedCallback function.
 */
EOS_STRUCT(EOS_Connect_LoginStatusChangedCallbackInfo, (
	/** Context that was passed into EOS_Connect_AddNotifyLoginStatusChanged. */
	void* ClientData;
	/** The Product User ID of the local player whose status has changed. */
	EOS_ProductUserId LocalUserId;
	/** The status prior to the change. */
	EOS_ELoginStatus PreviousStatus;
	/** The status at the time of the notification. */
	EOS_ELoginStatus CurrentStatus;
));

/**
 * Function prototype definition for notifications that come from EOS_Connect_AddNotifyLoginStatusChanged.
 *
 * @param Data A EOS_Connect_LoginStatusChangedCallbackInfo containing the output information and result.
 */
EOS_DECLARE_CALLBACK(EOS_Connect_OnLoginStatusChangedCallback, const EOS_Connect_LoginStatusChangedCallbackInfo* Data);

/** The most recent version of the EOS_Connect_IdToken struct. */
#define EOS_CONNECT_IDTOKEN_API_LATEST 1

/**
 * A structure that contains an ID token.
 * These structures are created by EOS_Connect_CopyIdToken and must be passed to EOS_Connect_IdToken_Release.
 */
EOS_STRUCT(EOS_Connect_IdToken, (
	/** API Version: Set this to EOS_CONNECT_IDTOKEN_API_LATEST. */
	int32_t ApiVersion;
	/**
	 * The Product User ID described by the ID token.
	 * Use EOS_ProductUserId_FromString to populate this field when validating a received ID token.
	 */
	EOS_ProductUserId ProductUserId;
	/** The ID token as a Json Web Token (JWT) string. */
	const char* JsonWebToken;
));

/**
 * Release the memory associated with an EOS_Connect_IdToken structure. This must be called on data retrieved from EOS_Connect_CopyIdToken.
 *
 * @param IdToken The ID token structure to be released.
 *
 * @see EOS_Connect_IdToken
 * @see EOS_Connect_CopyIdToken
 */
EOS_DECLARE_FUNC(void) EOS_Connect_IdToken_Release(EOS_Connect_IdToken* IdToken);

/** The most recent version of the EOS_Connect_CopyIdToken API. */
#define EOS_CONNECT_COPYIDTOKEN_API_LATEST 1

/**
 * Input parameters for the EOS_Connect_CopyIdToken function.
 */
EOS_STRUCT(EOS_Connect_CopyIdTokenOptions, (
	/** API Version: Set this to EOS_CONNECT_COPYIDTOKEN_API_LATEST. */
	int32_t ApiVersion;
	/** The local Product User ID whose ID token should be copied. */
	EOS_ProductUserId LocalUserId;
));

/** The most recent version of the EOS_Connect_VerifyIdToken API. */
#define EOS_CONNECT_VERIFYIDTOKEN_API_LATEST 1

/**
 * Input parameters for the EOS_Connect_VerifyIdToken function.
 */
EOS_STRUCT(EOS_Connect_VerifyIdTokenOptions, (
	/** API Version: Set this to EOS_CONNECT_VERIFYIDTOKEN_API_LATEST. */
	int32_t ApiVersion;
	/**
	 * The ID token to verify.
	 * Use EOS_ProductUserId_FromString to populate the ProductUserId field of this struct.
	 */
	const EOS_Connect_IdToken* IdToken;
));

/**
 * Output parameters for the EOS_Connect_VerifyIdToken Function.
 */
EOS_STRUCT(EOS_Connect_VerifyIdTokenCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Connect_VerifyIdToken */
	void* ClientData;
));

/**
 * Function prototype definition for callbacks passed into EOS_Connect_VerifyIdToken.
 *
 * @param Data A EOS_Connect_VerifyIdTokenCallbackInfo containing the output information and result.
 */
EOS_DECLARE_CALLBACK(EOS_Connect_OnVerifyIdTokenCallback, const EOS_Connect_VerifyIdTokenCallbackInfo* Data);

#pragma pack(pop)

```

`eac/sdk/Include/eos_ecom.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_ecom_types.h"

/**
 * The Ecom Interface exposes all catalog, purchasing, and ownership entitlement features available with the Epic Games store
 * All Ecom Interface calls take a handle of type EOS_HEcom as the first parameter.
 * This handle can be retrieved from an EOS_HPlatform handle by using the EOS_Platform_GetEcomInterface function.
 *
 * @note At this time, this feature is only available for products that are part of the Epic Games store.
 *
 * @see EOS_Platform_GetEcomInterface
 */

/**
 * Query the ownership status for a given list of catalog item IDs defined with Epic Online Services.
 * This data will be cached for a limited time and retrieved again from the backend when necessary
 *
 * @param Options structure containing the account and catalog item IDs to retrieve
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error
 */
EOS_DECLARE_FUNC(void) EOS_Ecom_QueryOwnership(EOS_HEcom Handle, const EOS_Ecom_QueryOwnershipOptions* Options, void* ClientData, const EOS_Ecom_OnQueryOwnershipCallback CompletionDelegate);

/**
 * Query the ownership status for a given list of catalog item IDs defined with Epic Online Services.
 * The data is return via the callback in the form of a signed JWT that should be verified by an external backend server using a public key for authenticity.
 *
 * @param Options structure containing the account and catalog item IDs to retrieve in token form
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error
 */
EOS_DECLARE_FUNC(void) EOS_Ecom_QueryOwnershipToken(EOS_HEcom Handle, const EOS_Ecom_QueryOwnershipTokenOptions* Options, void* ClientData, const EOS_Ecom_OnQueryOwnershipTokenCallback CompletionDelegate);

/**
 * Query the entitlement information defined with Epic Online Services.
 * A set of entitlement names can be provided to filter the set of entitlements associated with the account.
 * This data will be cached for a limited time and retrieved again from the backend when necessary.
 * Use EOS_Ecom_CopyEntitlementByIndex, EOS_Ecom_CopyEntitlementByNameAndIndex, and EOS_Ecom_CopyEntitlementById to get the entitlement details.
 * Use EOS_Ecom_GetEntitlementsByNameCount to retrieve the number of entitlements with a specific entitlement name.
 *
 * @param Options structure containing the account and entitlement names to retrieve
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error
 */
EOS_DECLARE_FUNC(void) EOS_Ecom_QueryEntitlements(EOS_HEcom Handle, const EOS_Ecom_QueryEntitlementsOptions* Options, void* ClientData, const EOS_Ecom_OnQueryEntitlementsCallback CompletionDelegate);

/**
 * Query for a list of catalog offers defined with Epic Online Services.
 * This data will be cached for a limited time and retrieved again from the backend when necessary.
 *
 * @param Options structure containing filter criteria
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error
 */
EOS_DECLARE_FUNC(void) EOS_Ecom_QueryOffers(EOS_HEcom Handle, const EOS_Ecom_QueryOffersOptions* Options, void* ClientData, const EOS_Ecom_OnQueryOffersCallback CompletionDelegate);

/**
 * Initiates the purchase flow for a set of offers.  The callback is triggered after the purchase flow.
 * On success, the set of entitlements that were unlocked will be cached.
 * On success, a Transaction ID will be returned. The Transaction ID can be used to obtain an
 * EOS_Ecom_HTransaction handle. The handle can then be used to retrieve the entitlements rewarded by the purchase.
 *
 * @see EOS_Ecom_Transaction_Release
 *
 * @param Options structure containing filter criteria
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error
 */
EOS_DECLARE_FUNC(void) EOS_Ecom_Checkout(EOS_HEcom Handle, const EOS_Ecom_CheckoutOptions* Options, void* ClientData, const EOS_Ecom_OnCheckoutCallback CompletionDelegate);

/**
 * Requests that the provided entitlement be marked redeemed.  This will cause that entitlement
 * to no longer be returned from QueryEntitlements unless the include redeemed request flag is set true.
 *
 * @param Options structure containing entitlement to redeem
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error
 */
EOS_DECLARE_FUNC(void) EOS_Ecom_RedeemEntitlements(EOS_HEcom Handle, const EOS_Ecom_RedeemEntitlementsOptions* Options, void* ClientData, const EOS_Ecom_OnRedeemEntitlementsCallback CompletionDelegate);

/**
 * Fetch the number of entitlements that are cached for a given local user.
 *
 * @param Options structure containing the Epic Account ID being accessed
 *
 * @see EOS_Ecom_CopyEntitlementByIndex
 *
 * @return the number of entitlements found.
 */
EOS_DECLARE_FUNC(uint32_t) EOS_Ecom_GetEntitlementsCount(EOS_HEcom Handle, const EOS_Ecom_GetEntitlementsCountOptions* Options);

/**
 * Fetch the number of entitlements with the given Entitlement Name that are cached for a given local user.
 *
 * @param Options structure containing the Epic Account ID and name being accessed
 *
 * @see EOS_Ecom_CopyEntitlementByNameAndIndex
 *
 * @return the number of entitlements found.
 */
EOS_DECLARE_FUNC(uint32_t) EOS_Ecom_GetEntitlementsByNameCount(EOS_HEcom Handle, const EOS_Ecom_GetEntitlementsByNameCountOptions* Options);

/**
 * Fetches an entitlement from a given index.
 *
 * @param Options structure containing the Epic Account ID and index being accessed
 * @param OutEntitlement the entitlement for the given index, if it exists and is valid, use EOS_Ecom_Entitlement_Release when finished
 *
 * @see EOS_Ecom_Entitlement_Release
 *
 * @return EOS_Success if the information is available and passed out in OutEntitlement
 *         EOS_Ecom_EntitlementStale if the entitlement information is stale and passed out in OutEntitlement
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the entitlement is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Ecom_CopyEntitlementByIndex(EOS_HEcom Handle, const EOS_Ecom_CopyEntitlementByIndexOptions* Options, EOS_Ecom_Entitlement ** OutEntitlement);

/**
 * Fetches a single entitlement with a given Entitlement Name.  The Index is used to access individual
 * entitlements among those with the same Entitlement Name.  The Index can be a value from 0 to
 * one less than the result from EOS_Ecom_GetEntitlementsByNameCount.
 *
 * @param Options structure containing the Epic Account ID, entitlement name, and index being accessed
 * @param OutEntitlement the entitlement for the given name index pair, if it exists and is valid, use EOS_Ecom_Entitlement_Release when finished
 *
 * @see EOS_Ecom_Entitlement_Release
 *
 * @return EOS_Success if the information is available and passed out in OutEntitlement
 *         EOS_Ecom_EntitlementStale if the entitlement information is stale and passed out in OutEntitlement
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the entitlement is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Ecom_CopyEntitlementByNameAndIndex(EOS_HEcom Handle, const EOS_Ecom_CopyEntitlementByNameAndIndexOptions* Options, EOS_Ecom_Entitlement ** OutEntitlement);

/**
 * Fetches the entitlement with the given ID.
 *
 * @param Options structure containing the Epic Account ID and entitlement ID being accessed
 * @param OutEntitlement the entitlement for the given ID, if it exists and is valid, use EOS_Ecom_Entitlement_Release when finished
 *
 * @see EOS_Ecom_CopyEntitlementByNameAndIndex
 * @see EOS_Ecom_Entitlement_Release
 *
 * @return EOS_Success if the information is available and passed out in OutEntitlement
 *         EOS_Ecom_EntitlementStale if the entitlement information is stale and passed out in OutEntitlement
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the entitlement is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Ecom_CopyEntitlementById(EOS_HEcom Handle, const EOS_Ecom_CopyEntitlementByIdOptions* Options, EOS_Ecom_Entitlement ** OutEntitlement);

/**
 * Fetch the number of offers that are cached for a given local user.
 *
 * @param Options structure containing the Epic Account ID being accessed
 *
 * @see EOS_Ecom_CopyOfferByIndex
 *
 * @return the number of offers found.
 */
EOS_DECLARE_FUNC(uint32_t) EOS_Ecom_GetOfferCount(EOS_HEcom Handle, const EOS_Ecom_GetOfferCountOptions* Options);

/**
 * Fetches an offer from a given index.  The pricing and text are localized to the provided account.
 *
 * @param Options structure containing the Epic Account ID and index being accessed
 * @param OutOffer the offer for the given index, if it exists and is valid, use EOS_Ecom_CatalogOffer_Release when finished
 *
 * @see EOS_Ecom_CatalogOffer_Release
 * @see EOS_Ecom_GetOfferItemCount
 *
 * @return EOS_Success if the information is available and passed out in OutOffer
 *         EOS_Ecom_CatalogOfferStale if the offer information is stale and passed out in OutOffer
 *         EOS_Ecom_CatalogOfferPriceInvalid if the offer information has an invalid price and passed out in OutOffer
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the offer is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Ecom_CopyOfferByIndex(EOS_HEcom Handle, const EOS_Ecom_CopyOfferByIndexOptions* Options, EOS_Ecom_CatalogOffer ** OutOffer);

/**
 * Fetches an offer with a given ID.  The pricing and text are localized to the provided account.
 *
 * @param Options structure containing the Epic Account ID and offer ID being accessed
 * @param OutOffer the offer for the given index, if it exists and is valid, use EOS_Ecom_CatalogOffer_Release when finished
 *
 * @see EOS_Ecom_CatalogOffer_Release
 * @see EOS_Ecom_GetOfferItemCount
 *
 * @return EOS_Success if the information is available and passed out in OutOffer
 *         EOS_Ecom_CatalogOfferStale if the offer information is stale and passed out in OutOffer
 *         EOS_Ecom_CatalogOfferPriceInvalid if the offer information has an invalid price and passed out in OutOffer
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the offer is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Ecom_CopyOfferById(EOS_HEcom Handle, const EOS_Ecom_CopyOfferByIdOptions* Options, EOS_Ecom_CatalogOffer ** OutOffer);

/**
 * Fetch the number of items that are associated with a given cached offer for a local user.
 *
 * @return the number of items found.
 */
EOS_DECLARE_FUNC(uint32_t) EOS_Ecom_GetOfferItemCount(EOS_HEcom Handle, const EOS_Ecom_GetOfferItemCountOptions* Options);

/**
 * Fetches an item from a given index.
 *
 * @param Options structure containing the Epic Account ID and index being accessed
 * @param OutItem the item for the given index, if it exists and is valid, use EOS_Ecom_CatalogItem_Release when finished
 *
 * @see EOS_Ecom_CatalogItem_Release
 * @see EOS_Ecom_GetItemImageInfoCount
 * @see EOS_Ecom_GetItemReleaseCount
 *
 * @return EOS_Success if the information is available and passed out in OutItem
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_Ecom_CatalogItemStale if the item information is stale
 *         EOS_NotFound if the item is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Ecom_CopyOfferItemByIndex(EOS_HEcom Handle, const EOS_Ecom_CopyOfferItemByIndexOptions* Options, EOS_Ecom_CatalogItem ** OutItem);

/**
 * Fetches an item with a given ID.
 *
 * @param Options structure containing the item ID being accessed
 * @param OutItem the item for the given index, if it exists and is valid, use EOS_Ecom_CatalogItem_Release when finished
 *
 * @see EOS_Ecom_CatalogItem_Release
 * @see EOS_Ecom_GetItemImageInfoCount
 * @see EOS_Ecom_GetItemReleaseCount
 *
 * @return EOS_Success if the information is available and passed out in OutItem
 *         EOS_Ecom_CatalogItemStale if the item information is stale and passed out in OutItem
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the offer is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Ecom_CopyItemById(EOS_HEcom Handle, const EOS_Ecom_CopyItemByIdOptions* Options, EOS_Ecom_CatalogItem ** OutItem);

/**
 * Fetch the number of images that are associated with a given cached offer for a local user.
 *
 * @return the number of images found.
 */
EOS_DECLARE_FUNC(uint32_t) EOS_Ecom_GetOfferImageInfoCount(EOS_HEcom Handle, const EOS_Ecom_GetOfferImageInfoCountOptions* Options);

/**
 * Fetches an image from a given index.
 *
 * @param Options structure containing the offer ID and index being accessed
 * @param OutImageInfo the image for the given index, if it exists and is valid, use EOS_Ecom_KeyImageInfo_Release when finished
 *
 * @see EOS_Ecom_KeyImageInfo_Release
 *
 * @return EOS_Success if the information is available and passed out in OutImageInfo
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_Ecom_CatalogOfferStale if the associated offer information is stale
 *         EOS_NotFound if the image is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Ecom_CopyOfferImageInfoByIndex(EOS_HEcom Handle, const EOS_Ecom_CopyOfferImageInfoByIndexOptions* Options, EOS_Ecom_KeyImageInfo ** OutImageInfo);

/**
 * Fetch the number of images that are associated with a given cached item for a local user.
 *
 * @return the number of images found.
 */
EOS_DECLARE_FUNC(uint32_t) EOS_Ecom_GetItemImageInfoCount(EOS_HEcom Handle, const EOS_Ecom_GetItemImageInfoCountOptions* Options);

/**
 * Fetches an image from a given index.
 *
 * @param Options structure containing the item ID and index being accessed
 * @param OutImageInfo the image for the given index, if it exists and is valid, use EOS_Ecom_KeyImageInfo_Release when finished
 *
 * @see EOS_Ecom_KeyImageInfo_Release
 *
 * @return EOS_Success if the information is available and passed out in OutImageInfo
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_Ecom_CatalogItemStale if the associated item information is stale
 *         EOS_NotFound if the image is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Ecom_CopyItemImageInfoByIndex(EOS_HEcom Handle, const EOS_Ecom_CopyItemImageInfoByIndexOptions* Options, EOS_Ecom_KeyImageInfo ** OutImageInfo);

/**
 * Fetch the number of releases that are associated with a given cached item for a local user.
 *
 * @return the number of releases found.
 */
EOS_DECLARE_FUNC(uint32_t) EOS_Ecom_GetItemReleaseCount(EOS_HEcom Handle, const EOS_Ecom_GetItemReleaseCountOptions* Options);

/**
 * Fetches a release from a given index.
 *
 * @param Options structure containing the item ID and index being accessed
 * @param OutRelease the release for the given index, if it exists and is valid, use EOS_Ecom_CatalogRelease_Release when finished
 *
 * @see EOS_Ecom_CatalogRelease_Release
 *
 * @return EOS_Success if the information is available and passed out in OutRelease
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_Ecom_CatalogItemStale if the associated item information is stale
 *         EOS_NotFound if the release is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Ecom_CopyItemReleaseByIndex(EOS_HEcom Handle, const EOS_Ecom_CopyItemReleaseByIndexOptions* Options, EOS_Ecom_CatalogRelease ** OutRelease);

/**
 * Fetch the number of transactions that are cached for a given local user.
 *
 * @see EOS_Ecom_CheckoutCallbackInfo
 * @see EOS_Ecom_CopyTransactionByIndex
 *
 * @return the number of transactions found.
 */
EOS_DECLARE_FUNC(uint32_t) EOS_Ecom_GetTransactionCount(EOS_HEcom Handle, const EOS_Ecom_GetTransactionCountOptions* Options);

/**
 * Fetches the transaction handle at the given index.
 *
 * @param Options structure containing the Epic Account ID and index being accessed
 *
 * @see EOS_Ecom_CheckoutCallbackInfo
 * @see EOS_Ecom_Transaction_Release
 *
 * @return EOS_Success if the information is available and passed out in OutTransaction
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the transaction is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Ecom_CopyTransactionByIndex(EOS_HEcom Handle, const EOS_Ecom_CopyTransactionByIndexOptions* Options, EOS_Ecom_HTransaction* OutTransaction);

/**
 * Fetches the transaction handle at the given index.
 *
 * @param Options structure containing the Epic Account ID and transaction ID being accessed
 *
 * @see EOS_Ecom_CheckoutCallbackInfo
 * @see EOS_Ecom_Transaction_Release
 *
 * @return EOS_Success if the information is available and passed out in OutTransaction
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the transaction is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Ecom_CopyTransactionById(EOS_HEcom Handle, const EOS_Ecom_CopyTransactionByIdOptions* Options, EOS_Ecom_HTransaction* OutTransaction);

/**
 * The Ecom Transaction Interface exposes getters for accessing information about a completed transaction.
 * All Ecom Transaction Interface calls take a handle of type EOS_Ecom_HTransaction as the first parameter.
 * An EOS_Ecom_HTransaction handle is originally returned as part of the EOS_Ecom_CheckoutCallbackInfo struct.
 * An EOS_Ecom_HTransaction handle can also be retrieved from an EOS_HEcom handle using EOS_Ecom_CopyTransactionByIndex.
 * It is expected that after a transaction that EOS_Ecom_Transaction_Release is called.
 * When EOS_Platform_Release is called any remaining transactions will also be released.
 *
 * @see EOS_Ecom_CheckoutCallbackInfo
 * @see EOS_Ecom_GetTransactionCount
 * @see EOS_Ecom_CopyTransactionByIndex
 */

EOS_DECLARE_FUNC(EOS_EResult) EOS_Ecom_Transaction_GetTransactionId(EOS_Ecom_HTransaction Handle, char* OutBuffer, int32_t* InOutBufferLength);

/**
 * Fetch the number of entitlements that are part of this transaction.
 *
 * @param Options structure containing the Epic Account ID being accessed
 *
 * @see EOS_Ecom_Transaction_CopyEntitlementByIndex
 *
 * @return the number of entitlements found.
 */
EOS_DECLARE_FUNC(uint32_t) EOS_Ecom_Transaction_GetEntitlementsCount(EOS_Ecom_HTransaction Handle, const EOS_Ecom_Transaction_GetEntitlementsCountOptions* Options);

/**
 * Fetches an entitlement from a given index.
 *
 * @param Options structure containing the index being accessed
 * @param OutEntitlement the entitlement for the given index, if it exists and is valid, use EOS_Ecom_Entitlement_Release when finished
 *
 * @see EOS_Ecom_Entitlement_Release
 *
 * @return EOS_Success if the information is available and passed out in OutEntitlement
 *         EOS_Ecom_EntitlementStale if the entitlement information is stale and passed out in OutEntitlement
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the entitlement is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Ecom_Transaction_CopyEntitlementByIndex(EOS_Ecom_HTransaction Handle, const EOS_Ecom_Transaction_CopyEntitlementByIndexOptions* Options, EOS_Ecom_Entitlement ** OutEntitlement);

```

`eac/sdk/Include/eos_ecom_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

EXTERN_C typedef struct EOS_EcomHandle* EOS_HEcom;

/**
 * This handle is copied when EOS_Ecom_CopyTransactionById or EOS_Ecom_CopyTransactionByIndex is called.
 * A EOS_Ecom_CheckoutCallbackInfo provides the ID for the copy.
 * After being copied, EOS_Ecom_Transaction_Release must be called.
 *
 * @see EOS_Ecom_CheckoutCallbackInfo
 * @see EOS_Ecom_CopyTransactionById
 * @see EOS_Ecom_CopyTransactionByIndex
 * @see EOS_Ecom_Transaction_Release
 */
EXTERN_C typedef struct EOS_Ecom_TransactionHandle* EOS_Ecom_HTransaction;

/**
 * A unique identifier for a catalog item defined and stored with the backend catalog service.
 * A catalog item represents a distinct object within the catalog.  When acquired by an account, an
 * entitlement is granted that references a specific catalog item.
 */
EXTERN_C typedef const char* EOS_Ecom_CatalogItemId;

/**
 * A unique identifier for a catalog offer defined and stored with the backend catalog service.
 * A catalog offer is a purchasable collection of 1 or more items, associated with a price (which
 * could be 0).  When an offer is purchased an entitlement is granted for each of the items
 * referenced by the offer.
 */
EXTERN_C typedef const char* EOS_Ecom_CatalogOfferId;

/**
 * An identifier which is defined on a catalog item and stored with the backend catalog service.
 * The entitlement name may not be unique.  A catalog may be configured with multiple items with the
 * same entitlement name in order to define a logical grouping of entitlements.  This is used to
 * retrieve all entitlements granted to an account grouped in this way.
 *
 * @see EOS_Ecom_QueryEntitlements
 */
EXTERN_C typedef const char* EOS_Ecom_EntitlementName;

/**
 * A unique identifier for an entitlement owned by an account.  An entitlement is always associated
 * with a single account.  The entitlement ID is provided to allow redeeming the entitlement as
 * well as identify individual entitlement grants.
 *
 * @see EOS_Ecom_QueryEntitlements
 * @see EOS_Ecom_RedeemEntitlements
 */
EXTERN_C typedef const char* EOS_Ecom_EntitlementId;


/**
 * An enumeration of the different ownership statuses.
 */
EOS_ENUM(EOS_EOwnershipStatus,
	/** The catalog item is not owned by the local user */
	EOS_OS_NotOwned = 0,
	/** The catalog item is owned by the local user */
	EOS_OS_Owned = 1
);

/**
 * An enumeration defining the type of catalog item.  The primary use is to identify how the item is expended.
 */
EOS_ENUM(EOS_EEcomItemType,
	/** This entitlement is intended to persist. */
	EOS_EIT_Durable = 0,
	/**
	 * This entitlement is intended to be transient and redeemed.
	 *
	 * @see EOS_Ecom_RedeemEntitlements
	 */
	EOS_EIT_Consumable = 1,
	/** This entitlement has a type that is not currently intneded for an in-game store. */
	EOS_EIT_Other = 2
);

/** The most recent version of the EOS_Ecom_Entitlement struct. */
#define EOS_ECOM_ENTITLEMENT_API_LATEST 2

/** Timestamp value representing an undefined EndTimestamp for EOS_Ecom_Entitlement */
#define EOS_ECOM_ENTITLEMENT_ENDTIMESTAMP_UNDEFINED -1

/**
 * Contains information about a single entitlement associated with an account. Instances of this structure are
 * created by EOS_Ecom_CopyEntitlementByIndex, EOS_Ecom_CopyEntitlementByNameAndIndex, or EOS_Ecom_CopyEntitlementById.
 * They must be passed to EOS_Ecom_Entitlement_Release.
 */
EOS_STRUCT(EOS_Ecom_Entitlement, (
	/** API Version: Set this to EOS_ECOM_ENTITLEMENT_API_LATEST. */
	int32_t ApiVersion;
	/** Name of the entitlement */
	EOS_Ecom_EntitlementName EntitlementName;
	/** ID of the entitlement owned by an account */
	EOS_Ecom_EntitlementId EntitlementId;
	/** ID of the item associated with the offer which granted this entitlement */
	EOS_Ecom_CatalogItemId CatalogItemId;
	/**
	 * If queried using pagination then ServerIndex represents the index of the entitlement as it
	 * exists on the server.  If not queried using pagination then ServerIndex will be -1.
	 */
	int32_t ServerIndex;
	/** If true then the catalog has this entitlement marked as redeemed */
	EOS_Bool bRedeemed;
	/** If not -1 then this is a POSIX timestamp that this entitlement will end */
	int64_t EndTimestamp;
));

/**
 * Release the memory associated with an EOS_Ecom_Entitlement structure. This must be called on data
 * retrieved from EOS_Ecom_CopyEntitlementByIndex and EOS_Ecom_CopyEntitlementById.
 *
 * @param Entitlement - The entitlement structure to be released
 *
 * @see EOS_Ecom_Entitlement
 * @see EOS_Ecom_CopyEntitlementByIndex
 * @see EOS_Ecom_CopyEntitlementById
 */
EOS_DECLARE_FUNC(void) EOS_Ecom_Entitlement_Release(EOS_Ecom_Entitlement* Entitlement);

/** The most recent version of the EOS_Ecom_ItemOwnership struct. */
#define EOS_ECOM_ITEMOWNERSHIP_API_LATEST 1

/**
 * Contains information about a single item ownership associated with an account. This structure is
 * returned as part of the EOS_Ecom_QueryOwnershipCallbackInfo structure.
 */
EOS_STRUCT(EOS_Ecom_ItemOwnership, (
	/** API Version: Set this to EOS_ECOM_ITEMOWNERSHIP_API_LATEST. */
	int32_t ApiVersion;
	/** ID of the catalog item */
	EOS_Ecom_CatalogItemId Id;
	/** Is this catalog item owned by the local user */
	EOS_EOwnershipStatus OwnershipStatus;
));

/** The most recent version of the EOS_Ecom_CatalogItem struct. */
#define EOS_ECOM_CATALOGITEM_API_LATEST 1

/** Timestamp value representing an undefined EntitlementEndTimestamp for EOS_Ecom_CatalogItem */
#define EOS_ECOM_CATALOGITEM_ENTITLEMENTENDTIMESTAMP_UNDEFINED -1

/**
 * Contains information about a single item within the catalog. Instances of this structure are created
 * by EOS_Ecom_CopyOfferItemByIndex. They must be passed to EOS_Ecom_CatalogItem_Release.
 */
EOS_STRUCT(EOS_Ecom_CatalogItem, (
	/** API Version: Set this to EOS_ECOM_CATALOGITEM_API_LATEST. */
	int32_t ApiVersion;
	/** Product namespace in which this item exists */
	const char* CatalogNamespace;
	/** The ID of this item */
	EOS_Ecom_CatalogItemId Id;
	/** The entitlement name associated with this item */
	EOS_Ecom_EntitlementName EntitlementName;
	/** Localized UTF-8 title of this item */
	const char* TitleText;
	/** Localized UTF-8 description of this item */
	const char* DescriptionText;
	/** Localized UTF-8 long description of this item */
	const char* LongDescriptionText;
	/** Localized UTF-8 technical details of this item */
	const char* TechnicalDetailsText;
	/** Localized UTF-8 developer of this item */
	const char* DeveloperText;
	/** The type of item as defined in the catalog */
	EOS_EEcomItemType ItemType;
	/** If not -1 then this is the POSIX timestamp that the entitlement will end */
	int64_t EntitlementEndTimestamp;
));

/**
 * Release the memory associated with an EOS_Ecom_CatalogItem structure. This must be called on data
 * retrieved from EOS_Ecom_CopyOfferItemByIndex.
 *
 * @param CatalogItem - The catalog item structure to be released
 *
 * @see EOS_Ecom_CatalogItem
 * @see EOS_Ecom_CopyOfferItemByIndex
 */
EOS_DECLARE_FUNC(void) EOS_Ecom_CatalogItem_Release(EOS_Ecom_CatalogItem* CatalogItem);

/** The most recent version of the EOS_Ecom_CatalogOffer struct. */
#define EOS_ECOM_CATALOGOFFER_API_LATEST 4

/** Timestamp value representing an undefined ExpirationTimestamp for EOS_Ecom_CatalogOffer */
#define EOS_ECOM_CATALOGOFFER_EXPIRATIONTIMESTAMP_UNDEFINED -1

/**
 * Contains information about a single offer within the catalog. Instances of this structure are
 * created by EOS_Ecom_CopyOfferByIndex. They must be passed to EOS_Ecom_CatalogOffer_Release.
 * Prices are stored in the lowest denomination for the associated currency.  If CurrencyCode is
 * "USD" then a price of 299 represents "$2.99".
 */
EOS_STRUCT(EOS_Ecom_CatalogOffer, (
	/** API Version: Set this to EOS_ECOM_CATALOGOFFER_API_LATEST. */
	int32_t ApiVersion;
	/**
	 * The index of this offer as it exists on the server.
	 * This is useful for understanding pagination data.
	 */
	int32_t ServerIndex;
	/** Product namespace in which this offer exists */
	const char* CatalogNamespace;
	/** The ID of this offer */
	EOS_Ecom_CatalogOfferId Id;
	/** Localized UTF-8 title of this offer */
	const char* TitleText;
	/** Localized UTF-8 description of this offer */
	const char* DescriptionText;
	/** Localized UTF-8 long description of this offer */
	const char* LongDescriptionText;
	/**
	 * Deprecated.
	 * EOS_Ecom_CatalogOffer::TechnicalDetailsText has been deprecated.
	 * EOS_Ecom_CatalogItem::TechnicalDetailsText is still valid.
	 */
	const char* TechnicalDetailsText_DEPRECATED;
	/** The Currency Code for this offer */
	const char* CurrencyCode;
	/**
	 * If this value is EOS_Success then OriginalPrice, CurrentPrice, and DiscountPercentage contain valid data.
	 * Otherwise this value represents the error that occurred on the price query.
	 */
	EOS_EResult PriceResult;
	/** The original price of this offer as a 32-bit number is deprecated. */
	uint32_t OriginalPrice_DEPRECATED;
	/** The current price including discounts of this offer as a 32-bit number is deprecated.. */
	uint32_t CurrentPrice_DEPRECATED;
	/** A value from 0 to 100 define the percentage of the OrignalPrice that the CurrentPrice represents */
	uint8_t DiscountPercentage;
	/** Contains the POSIX timestamp that the offer expires or -1 if it does not expire */
	int64_t ExpirationTimestamp;
	/** The number of times that the requesting account has purchased this offer. */
	uint32_t PurchasedCount;
	/**
	 * The maximum number of times that the offer can be purchased.
	 * A negative value implies there is no limit.
	 */
	int32_t PurchaseLimit;
	/** True if the user can purchase this offer. */
	EOS_Bool bAvailableForPurchase;
	/** The original price of this offer as a 64-bit number. */
	uint64_t OriginalPrice64;
	/** The current price including discounts of this offer as a 64-bit number. */
	uint64_t CurrentPrice64;
	/** The decimal point for the provided price.  For example, DecimalPoint '2' and CurrentPrice64 '12345' would be '123.45'. */
	uint32_t DecimalPoint;
));

/**
 * Release the memory associated with an EOS_Ecom_CatalogOffer structure. This must be called on data
 * retrieved from EOS_Ecom_CopyOfferByIndex.
 *
 * @param CatalogOffer - The catalog offer structure to be released
 *
 * @see EOS_Ecom_CatalogOffer
 * @see EOS_Ecom_CopyOfferByIndex
 */
EOS_DECLARE_FUNC(void) EOS_Ecom_CatalogOffer_Release(EOS_Ecom_CatalogOffer* CatalogOffer);

/** The most recent version of the EOS_Ecom_KeyImageInfo struct. */
#define EOS_ECOM_KEYIMAGEINFO_API_LATEST 1

/**
 * Contains information about a key image used by the catalog.  Instances of this structure are
 * created by EOS_Ecom_CopyItemImageInfoByIndex.  They must be passed to EOS_Ecom_KeyImageInfo_Release.
 * A Key Image is defined within Dev Portal and is associated with a Catalog Item.  A Key Image is
 * intended to be used to provide imagery for an in-game store.
 *
 * @see EOS_Ecom_CopyItemImageInfoByIndex
 * @see EOS_Ecom_KeyImageInfo_Release
 */
EOS_STRUCT(EOS_Ecom_KeyImageInfo, (
	/** API Version: Set this to EOS_ECOM_KEYIMAGEINFO_API_LATEST. */
	int32_t ApiVersion;
	/** Describes the usage of the image (ex: home_thumbnail) */
	const char* Type;
	/** The URL of the image */
	const char* Url;
	/** The expected width in pixels of the image */
	uint32_t Width;
	/** The expected height in pixels of the image */
	uint32_t Height;
));

/**
 * Release the memory associated with an EOS_Ecom_KeyImageInfo structure. This must be called on data
 * retrieved from EOS_Ecom_CopyItemImageInfoByIndex.
 *
 * @param KeyImageInfo - The key image info structure to be released
 *
 * @see EOS_Ecom_KeyImageInfo
 * @see EOS_Ecom_CopyItemImageInfoByIndex
 */
EOS_DECLARE_FUNC(void) EOS_Ecom_KeyImageInfo_Release(EOS_Ecom_KeyImageInfo* KeyImageInfo);

/** The most recent version of the EOS_Ecom_CatalogRelease struct. */
#define EOS_ECOM_CATALOGRELEASE_API_LATEST 1

/**
 * Contains information about a single release within the catalog. Instances of this structure are
 * created by EOS_Ecom_CopyItemReleaseByIndex. They must be passed to EOS_Ecom_CatalogRelease_Release.
 */
EOS_STRUCT(EOS_Ecom_CatalogRelease, (
	/** API Version: Set this to EOS_ECOM_CATALOGRELEASE_API_LATEST. */
	int32_t ApiVersion;
	/** The number of APP IDs */
	uint32_t CompatibleAppIdCount;
	/** A list of compatible APP IDs */
	const char** CompatibleAppIds;
	/** The number of platforms */
	uint32_t CompatiblePlatformCount;
	/** A list of compatible Platforms */
	const char** CompatiblePlatforms;
	/** Release note for compatible versions */
	const char* ReleaseNote;
));

/**
 * Release the memory associated with an EOS_Ecom_CatalogRelease structure. This must be called on
 * data retrieved from EOS_Ecom_CopyItemReleaseByIndex.
 *
 * @param CatalogRelease - The catalog release structure to be released
 *
 * @see EOS_Ecom_CatalogRelease
 * @see EOS_Ecom_CopyItemReleaseByIndex
 */
EOS_DECLARE_FUNC(void) EOS_Ecom_CatalogRelease_Release(EOS_Ecom_CatalogRelease* CatalogRelease);

/** The most recent version of the EOS_Ecom_CheckoutEntry struct. */
#define EOS_ECOM_CHECKOUTENTRY_API_LATEST 1

/**
 * Contains information about a request to purchase a single offer.  This structure is set as part
 * of the EOS_Ecom_CheckoutOptions structure.
 */
EOS_STRUCT(EOS_Ecom_CheckoutEntry, (
	/** API Version: Set this to EOS_ECOM_CHECKOUTENTRY_API_LATEST. */
	int32_t ApiVersion;
	/** The ID of the offer to purchase */
	EOS_Ecom_CatalogOfferId OfferId;
));

/** The most recent version of the EOS_Ecom_QueryOwnership API. */
#define EOS_ECOM_QUERYOWNERSHIP_API_LATEST 2

/**
 * The maximum number of catalog items that may be queried in a single pass
 */
#define EOS_ECOM_QUERYOWNERSHIP_MAX_CATALOG_IDS 32

/**
 * Input parameters for the EOS_Ecom_QueryOwnership function.
 */
EOS_STRUCT(EOS_Ecom_QueryOwnershipOptions, (
	/** API Version: Set this to EOS_ECOM_QUERYOWNERSHIP_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user whose ownership to query */
	EOS_EpicAccountId LocalUserId;
	/** The array of Catalog Item IDs to check for ownership */
	EOS_Ecom_CatalogItemId* CatalogItemIds;
	/** The number of Catalog Item IDs to in the array */
	uint32_t CatalogItemIdCount;
	/** Optional product namespace, if not the one specified during initialization */
	const char* CatalogNamespace;
));

/**
 * Output parameters for the EOS_Ecom_QueryOwnership Function.
 */
EOS_STRUCT(EOS_Ecom_QueryOwnershipCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Ecom_QueryOwnership */
	void* ClientData;
	/** The Epic Account ID of the local user whose ownership was queried */
	EOS_EpicAccountId LocalUserId;
	/** List of catalog items and their ownership status */
	const EOS_Ecom_ItemOwnership* ItemOwnership;
	/** Number of ownership results are included in this callback */
	uint32_t ItemOwnershipCount;
));

/**
 * Function prototype definition for callbacks passed to EOS_Ecom_QueryOwnership
 * @param Data A EOS_Ecom_QueryOwnershipCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Ecom_OnQueryOwnershipCallback, const EOS_Ecom_QueryOwnershipCallbackInfo* Data);

/** The most recent version of the EOS_Ecom_QueryOwnershipToken API. */
#define EOS_ECOM_QUERYOWNERSHIPTOKEN_API_LATEST 2

/**
 * The maximum number of catalog items that may be queried in a single pass
 */
#define EOS_ECOM_QUERYOWNERSHIPTOKEN_MAX_CATALOGITEM_IDS 32

/**
 * Input parameters for the EOS_Ecom_QueryOwnershipToken function.
 */
EOS_STRUCT(EOS_Ecom_QueryOwnershipTokenOptions, (
	/** API Version: Set this to EOS_ECOM_QUERYOWNERSHIPTOKEN_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user whose ownership token you want to query */
	EOS_EpicAccountId LocalUserId;
	/** The array of Catalog Item IDs to check for ownership, matching in number to the CatalogItemIdCount */
	EOS_Ecom_CatalogItemId* CatalogItemIds;
	/** The number of catalog item IDs to query */
	uint32_t CatalogItemIdCount;
	/** Optional product namespace, if not the one specified during initialization */
	const char* CatalogNamespace;
));

/**
 * Output parameters for the EOS_Ecom_QueryOwnershipToken Function.
 */
EOS_STRUCT(EOS_Ecom_QueryOwnershipTokenCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Ecom_QueryOwnershipToken */
	void* ClientData;
	/** The Epic Account ID of the local user whose ownership token was queried */
	EOS_EpicAccountId LocalUserId;
	/** Ownership token containing details about the catalog items queried */
	const char* OwnershipToken;
));

/**
 * Function prototype definition for callbacks passed to EOS_Ecom_QueryOwnershipToken
 * @param Data A EOS_Ecom_QueryOwnershipTokenCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Ecom_OnQueryOwnershipTokenCallback, const EOS_Ecom_QueryOwnershipTokenCallbackInfo* Data);

/** The most recent version of the EOS_Ecom_QueryEntitlements API. */
#define EOS_ECOM_QUERYENTITLEMENTS_API_LATEST 2

/**
 * The maximum number of entitlements that may be queried in a single pass
 */
#define EOS_ECOM_QUERYENTITLEMENTS_MAX_ENTITLEMENT_IDS 32

/**
 * Input parameters for the EOS_Ecom_QueryEntitlements function.
 */
EOS_STRUCT(EOS_Ecom_QueryEntitlementsOptions, (
	/** API Version: Set this to EOS_ECOM_QUERYENTITLEMENTS_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user whose Entitlements you want to retrieve */
	EOS_EpicAccountId LocalUserId;
	/** An array of Entitlement Names that you want to check */
	EOS_Ecom_EntitlementName* EntitlementNames;
	/** The number of Entitlement Names included in the array, up to EOS_ECOM_QUERYENTITLEMENTS_MAX_ENTITLEMENT_IDS; use zero to request all Entitlements associated with the user's Epic Online Services account. */
	uint32_t EntitlementNameCount;
	/** If true, Entitlements that have been redeemed will be included in the results. */
	EOS_Bool bIncludeRedeemed;
));

/**
 * Output parameters for the EOS_Ecom_QueryEntitlements Function.
 */
EOS_STRUCT(EOS_Ecom_QueryEntitlementsCallbackInfo, (
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Ecom_QueryEntitlements */
	void* ClientData;
	/** The Epic Account ID of the local user whose entitlement was queried */
	EOS_EpicAccountId LocalUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Ecom_QueryOwnershipToken
 * @param Data A EOS_Ecom_QueryEntitlementsCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Ecom_OnQueryEntitlementsCallback, const EOS_Ecom_QueryEntitlementsCallbackInfo* Data);


/** The most recent version of the EOS_Ecom_QueryOffers API. */
#define EOS_ECOM_QUERYOFFERS_API_LATEST 1

/**
 * Input parameters for the EOS_Ecom_QueryOffers function.
 */
EOS_STRUCT(EOS_Ecom_QueryOffersOptions, (
	/** API Version: Set this to EOS_ECOM_QUERYOFFERS_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user whose offer to query */
	EOS_EpicAccountId LocalUserId;
	/** If not provided then the SandboxId is used as the catalog namespace */
	const char* OverrideCatalogNamespace;
));

/**
 * Output parameters for the EOS_Ecom_QueryOffers Function.
 */
EOS_STRUCT(EOS_Ecom_QueryOffersCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Ecom_QueryOffers */
	void* ClientData;
	/** The Epic Account ID of the local user whose offer was queried; needed for localization of Catalog Item (Item) description text and pricing information */
	EOS_EpicAccountId LocalUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Ecom_QueryOffers
 * @param Data A EOS_Ecom_QueryOffersCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Ecom_OnQueryOffersCallback, const EOS_Ecom_QueryOffersCallbackInfo* Data);


/** The most recent version of the EOS_Ecom_Checkout API. */
#define EOS_ECOM_CHECKOUT_API_LATEST 1

/** The maximum number of entries in a single checkout. */
#define EOS_ECOM_CHECKOUT_MAX_ENTRIES 10

/** The maximum length of a transaction ID. */
#define EOS_ECOM_TRANSACTIONID_MAXIMUM_LENGTH 64
/**
 * Input parameters for the EOS_Ecom_Checkout function.
 */
EOS_STRUCT(EOS_Ecom_CheckoutOptions, (
	/** API Version: Set this to EOS_ECOM_CHECKOUT_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user who is making the purchase */
	EOS_EpicAccountId LocalUserId;
	/** The catalog namespace will be the current Sandbox ID (in EOS_Platform_Options) unless overridden by this field */
	const char* OverrideCatalogNamespace;
	/** The number of EOS_Ecom_CheckoutEntry elements contained in Entries */
	uint32_t EntryCount;
	/** An array of EOS_Ecom_CheckoutEntry elements, each containing the details of a single offer */
	const EOS_Ecom_CheckoutEntry* Entries;
));

/**
 * Output parameters for the EOS_Ecom_Checkout Function.
 */
EOS_STRUCT(EOS_Ecom_CheckoutCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned for a successful request, otherwise one of the error codes is returned. See eos_common.h */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Ecom_Checkout */
	void* ClientData;
	/** The Epic Account ID of the user who initiated the purchase */
	EOS_EpicAccountId LocalUserId;
	/** The transaction ID which can be used to obtain an EOS_Ecom_HTransaction using EOS_Ecom_CopyTransactionById. */
	const char* TransactionId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Ecom_Checkout
 * @param Data A EOS_Ecom_CheckoutCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Ecom_OnCheckoutCallback, const EOS_Ecom_CheckoutCallbackInfo* Data);


/** The most recent version of the EOS_Ecom_RedeemEntitlements API. */
#define EOS_ECOM_REDEEMENTITLEMENTS_API_LATEST 1

/**
 * The maximum number of entitlement IDs that may be redeemed in a single pass
 */
#define EOS_ECOM_REDEEMENTITLEMENTS_MAX_IDS 32

/**
 * Input parameters for the EOS_Ecom_RedeemEntitlements function.
 */
EOS_STRUCT(EOS_Ecom_RedeemEntitlementsOptions, (
	/** API Version: Set this to EOS_ECOM_REDEEMENTITLEMENTS_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the user who is redeeming Entitlements */
	EOS_EpicAccountId LocalUserId;
	/** The number of Entitlements to redeem */
	uint32_t EntitlementIdCount;
	/** The array of Entitlements to redeem */
	EOS_Ecom_EntitlementId* EntitlementIds;
));

/**
 * Output parameters for the EOS_Ecom_RedeemEntitlements Function.
 */
EOS_STRUCT(EOS_Ecom_RedeemEntitlementsCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned for a successful request, otherwise one of the error codes is returned. See eos_common.h */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Ecom_RedeemEntitlements */
	void* ClientData;
	/** The Epic Account ID of the user who has redeemed entitlements */
	EOS_EpicAccountId LocalUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Ecom_RedeemEntitlements
 * @param Data A EOS_Ecom_RedeemEntitlementsCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Ecom_OnRedeemEntitlementsCallback, const EOS_Ecom_RedeemEntitlementsCallbackInfo* Data);


/** The most recent version of the EOS_Ecom_GetEntitlementsCount API. */
#define EOS_ECOM_GETENTITLEMENTSCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Ecom_GetEntitlementsCount function.
 */
EOS_STRUCT(EOS_Ecom_GetEntitlementsCountOptions, (
	/** API Version: Set this to EOS_ECOM_GETENTITLEMENTSCOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user for which to retrieve the entitlement count */
	EOS_EpicAccountId LocalUserId;
));

/** The most recent version of the EOS_Ecom_GetEntitlementsByNameCount API. */
#define EOS_ECOM_GETENTITLEMENTSBYNAMECOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Ecom_GetEntitlementsByNameCount function.
 */
EOS_STRUCT(EOS_Ecom_GetEntitlementsByNameCountOptions, (
	/** API Version: Set this to EOS_ECOM_GETENTITLEMENTSBYNAMECOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user for which to retrieve the entitlement count */
	EOS_EpicAccountId LocalUserId;
	/** Name of the entitlement to count in the cache */
	EOS_Ecom_EntitlementName EntitlementName;
));

/** The most recent version of the EOS_Ecom_CopyEntitlementByIndex API. */
#define EOS_ECOM_COPYENTITLEMENTBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_Ecom_CopyEntitlementByIndex function.
 */
EOS_STRUCT(EOS_Ecom_CopyEntitlementByIndexOptions, (
	/** API Version: Set this to EOS_ECOM_COPYENTITLEMENTBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user whose entitlement is being copied */
	EOS_EpicAccountId LocalUserId;
	/** Index of the entitlement to retrieve from the cache */
	uint32_t EntitlementIndex;
));

/** The most recent version of the EOS_Ecom_CopyEntitlementByNameAndIndex API. */
#define EOS_ECOM_COPYENTITLEMENTBYNAMEANDINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_Ecom_CopyEntitlementByNameAndIndex function.
 */
EOS_STRUCT(EOS_Ecom_CopyEntitlementByNameAndIndexOptions, (
	/** API Version: Set this to EOS_ECOM_COPYENTITLEMENTBYNAMEANDINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user whose entitlement is being copied */
	EOS_EpicAccountId LocalUserId;
	/** Name of the entitlement to retrieve from the cache */
	EOS_Ecom_EntitlementName EntitlementName;
	/** Index of the entitlement within the named set to retrieve from the cache. */
	uint32_t Index;
));

/** The most recent version of the EOS_Ecom_CopyEntitlementById API. */
#define EOS_ECOM_COPYENTITLEMENTBYID_API_LATEST 2

/**
 * Input parameters for the EOS_Ecom_CopyEntitlementById function.
 */
EOS_STRUCT(EOS_Ecom_CopyEntitlementByIdOptions, (
	/** API Version: Set this to EOS_ECOM_COPYENTITLEMENTBYID_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user whose entitlement is being copied */
	EOS_EpicAccountId LocalUserId;
	/** ID of the entitlement to retrieve from the cache */
	EOS_Ecom_EntitlementId EntitlementId;
));

/** The most recent version of the EOS_Ecom_GetOfferCount API. */
#define EOS_ECOM_GETOFFERCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Ecom_GetOfferCount function.
 */
EOS_STRUCT(EOS_Ecom_GetOfferCountOptions, (
	/** API Version: Set this to EOS_ECOM_GETOFFERCOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user whose offers are being accessed */
	EOS_EpicAccountId LocalUserId;
));

/** The most recent version of the EOS_Ecom_CopyOfferByIndex API. */
#define EOS_ECOM_COPYOFFERBYINDEX_API_LATEST 2

/**
 * Input parameters for the EOS_Ecom_CopyOfferByIndex function.
 */
EOS_STRUCT(EOS_Ecom_CopyOfferByIndexOptions, (
	/** API Version: Set this to EOS_ECOM_COPYOFFERBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user whose offer is being copied */
	EOS_EpicAccountId LocalUserId;
	/** The index of the offer to get. */
	uint32_t OfferIndex;
));

/** The most recent version of the EOS_Ecom_CopyOfferById API. */
#define EOS_ECOM_COPYOFFERBYID_API_LATEST 2

/**
 * Input parameters for the EOS_Ecom_CopyOfferById function.
 */
EOS_STRUCT(EOS_Ecom_CopyOfferByIdOptions, (
	/** API Version: Set this to EOS_ECOM_COPYOFFERBYID_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user whose offer is being copied */
	EOS_EpicAccountId LocalUserId;
	/** The ID of the offer to get. */
	EOS_Ecom_CatalogOfferId OfferId;
));

/** The most recent version of the EOS_Ecom_GetOfferItemCount API. */
#define EOS_ECOM_GETOFFERITEMCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Ecom_GetOfferItemCount function.
 */
EOS_STRUCT(EOS_Ecom_GetOfferItemCountOptions, (
	/** API Version: Set this to EOS_ECOM_GETOFFERITEMCOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user who made the initial request for the Catalog Offer through EOS_Ecom_QueryOffers */
	EOS_EpicAccountId LocalUserId;
	/** An ID that corresponds to a cached Catalog Offer (retrieved by EOS_Ecom_CopyOfferByIndex) */
	EOS_Ecom_CatalogOfferId OfferId;
));

/** The most recent version of the EOS_Ecom_CopyOfferItemByIndex API. */
#define EOS_ECOM_COPYOFFERITEMBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_Ecom_CopyOfferItemByIndex function.
 */
EOS_STRUCT(EOS_Ecom_CopyOfferItemByIndexOptions, (
	/** API Version: Set this to EOS_ECOM_COPYOFFERITEMBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user whose item is being copied */
	EOS_EpicAccountId LocalUserId;
	/** The ID of the offer to get the items for. */
	EOS_Ecom_CatalogOfferId OfferId;
	/** The index of the item to get. */
	uint32_t ItemIndex;
));

/** The most recent version of the EOS_Ecom_CopyItemById API. */
#define EOS_ECOM_COPYITEMBYID_API_LATEST 1

/**
 * Input parameters for the EOS_Ecom_CopyItemById function.
 */
EOS_STRUCT(EOS_Ecom_CopyItemByIdOptions, (
	/** API Version: Set this to EOS_ECOM_COPYITEMBYID_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user whose item is being copied */
	EOS_EpicAccountId LocalUserId;
	/** The ID of the item to get. */
	EOS_Ecom_CatalogItemId ItemId;
));

/** The most recent version of the EOS_Ecom_GetOfferImageInfoCount API. */
#define EOS_ECOM_GETOFFERIMAGEINFOCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Ecom_GetOfferImageInfoCount function.
 */
EOS_STRUCT(EOS_Ecom_GetOfferImageInfoCountOptions, (
	/** API Version: Set this to EOS_ECOM_GETOFFERIMAGEINFOCOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user whose offer image is being accessed. */
	EOS_EpicAccountId LocalUserId;
	/** The ID of the offer to get the images for. */
	EOS_Ecom_CatalogOfferId OfferId;
));

/** The most recent version of the EOS_Ecom_CopyOfferImageInfoByIndex API. */
#define EOS_ECOM_COPYOFFERIMAGEINFOBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_Ecom_CopyOfferImageInfoByIndex function.
 */
EOS_STRUCT(EOS_Ecom_CopyOfferImageInfoByIndexOptions, (
	/** API Version: Set this to EOS_ECOM_COPYOFFERIMAGEINFOBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user whose offer image is being copied. */
	EOS_EpicAccountId LocalUserId;
	/** The ID of the offer to get the images for. */
	EOS_Ecom_CatalogOfferId OfferId;
	/** The index of the image to get. */
	uint32_t ImageInfoIndex;
));

/** The most recent version of the EOS_Ecom_GetItemImageInfoCount API. */
#define EOS_ECOM_GETITEMIMAGEINFOCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Ecom_GetItemImageInfoCount function.
 */
EOS_STRUCT(EOS_Ecom_GetItemImageInfoCountOptions, (
	/** API Version: Set this to EOS_ECOM_GETITEMIMAGEINFOCOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user whose item image is being accessed */
	EOS_EpicAccountId LocalUserId;
	/** The ID of the item to get the images for. */
	EOS_Ecom_CatalogItemId ItemId;
));

/** The most recent version of the EOS_Ecom_CopyItemImageInfoByIndex API. */
#define EOS_ECOM_COPYITEMIMAGEINFOBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_Ecom_CopyItemImageInfoByIndex function.
 */
EOS_STRUCT(EOS_Ecom_CopyItemImageInfoByIndexOptions, (
	/** API Version: Set this to EOS_ECOM_COPYITEMIMAGEINFOBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user whose item image is being copied */
	EOS_EpicAccountId LocalUserId;
	/** The ID of the item to get the images for. */
	EOS_Ecom_CatalogItemId ItemId;
	/** The index of the image to get. */
	uint32_t ImageInfoIndex;
));

/** The most recent version of the EOS_Ecom_GetItemReleaseCount API. */
#define EOS_ECOM_GETITEMRELEASECOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Ecom_GetItemReleaseCount function.
 */
EOS_STRUCT(EOS_Ecom_GetItemReleaseCountOptions, (
	/** API Version: Set this to EOS_ECOM_GETITEMRELEASECOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user whose item release is being accessed */
	EOS_EpicAccountId LocalUserId;
	/** The ID of the item to get the releases for. */
	EOS_Ecom_CatalogItemId ItemId;
));

/** The most recent version of the EOS_Ecom_CopyItemReleaseByIndex API. */
#define EOS_ECOM_COPYITEMRELEASEBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_Ecom_CopyItemReleaseByIndex function.
 */
EOS_STRUCT(EOS_Ecom_CopyItemReleaseByIndexOptions, (
	/** API Version: Set this to EOS_ECOM_COPYITEMRELEASEBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user whose item release is being copied */
	EOS_EpicAccountId LocalUserId;
	/** The ID of the item to get the releases for. */
	EOS_Ecom_CatalogItemId ItemId;
	/** The index of the release to get. */
	uint32_t ReleaseIndex;
));

/** The most recent version of the EOS_Ecom_GetTransactionCount Function. */
#define EOS_ECOM_GETTRANSACTIONCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Ecom_GetTransactionCount function.
 */
EOS_STRUCT(EOS_Ecom_GetTransactionCountOptions, (
	/** API Version: Set this to EOS_ECOM_GETTRANSACTIONCOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user whose transaction count to get */
	EOS_EpicAccountId LocalUserId;
));

/** The most recent version of the EOS_Ecom_CopyTransactionByIndex Function. */
#define EOS_ECOM_COPYTRANSACTIONBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_Ecom_CopyTransactionByIndex function.
 */
EOS_STRUCT(EOS_Ecom_CopyTransactionByIndexOptions, (
	/** API Version: Set this to EOS_ECOM_COPYTRANSACTIONBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user who is associated with the transaction */
	EOS_EpicAccountId LocalUserId;
	/** The index of the transaction to get */
	uint32_t TransactionIndex;
));

/** The most recent version of the EOS_Ecom_CopyTransactionById Function. */
#define EOS_ECOM_COPYTRANSACTIONBYID_API_LATEST 1
/**
 * Input parameters for the EOS_Ecom_CopyTransactionById function.
 */
EOS_STRUCT(EOS_Ecom_CopyTransactionByIdOptions, (
	/** API Version: Set this to EOS_ECOM_COPYTRANSACTIONBYID_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user who is associated with the transaction */
	EOS_EpicAccountId LocalUserId;
	/** The ID of the transaction to get */
	const char* TransactionId;
));

/** The most recent version of the EOS_Ecom_Transaction_GetEntitlementsCount Function. */
#define EOS_ECOM_TRANSACTION_GETENTITLEMENTSCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Ecom_Transaction_GetEntitlementsCount function.
 */
EOS_STRUCT(EOS_Ecom_Transaction_GetEntitlementsCountOptions, (
	/** API Version: Set this to EOS_ECOM_TRANSACTION_GETENTITLEMENTSCOUNT_API_LATEST. */
	int32_t ApiVersion;
));

/** The most recent version of the EOS_Ecom_Transaction_CopyEntitlementByIndex Function. */
#define EOS_ECOM_TRANSACTION_COPYENTITLEMENTBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_Ecom_Transaction_CopyEntitlementByIndex function.
 */
EOS_STRUCT(EOS_Ecom_Transaction_CopyEntitlementByIndexOptions, (
	/** API Version: Set this to EOS_ECOM_TRANSACTION_COPYENTITLEMENTBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** The index of the entitlement to get */
	uint32_t EntitlementIndex;
));

/**
 * Release the memory associated with an EOS_Ecom_HTransaction.  Is is expected to be called after
 * being received from a EOS_Ecom_CheckoutCallbackInfo.
 *
 * @param Transaction A handle to a transaction.
 *
 * @see EOS_Ecom_CheckoutCallbackInfo
 * @see EOS_Ecom_GetTransactionCount
 * @see EOS_Ecom_CopyTransactionByIndex
 */
EOS_DECLARE_FUNC(void) EOS_Ecom_Transaction_Release(EOS_Ecom_HTransaction Transaction);

#pragma pack(pop)

```

`eac/sdk/Include/eos_friends.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_friends_types.h"

/**
 * The Friends Interface is used to manage a user's friends list, by interacting with the backend services, and to retrieve the cached list of friends and pending invitations.
 * All Friends Interface calls take a handle of type EOS_HFriends as the first parameter.
 * This handle can be retrieved from a EOS_HPlatform handle by using the EOS_Platform_GetFriendsInterface function.
 *
 * @see EOS_Platform_GetFriendsInterface
 */

/**
 * Starts an asynchronous task that reads the user's friends list from the backend service, caching it for future use.
 *
 * @note When the Social Overlay is enabled then this will be called automatically.  The Social Overlay is enabled by default (see EOS_PF_DISABLE_SOCIAL_OVERLAY).
 *
 * @param Options structure containing the account for which to retrieve the friends list
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error
 */
EOS_DECLARE_FUNC(void) EOS_Friends_QueryFriends(EOS_HFriends Handle, const EOS_Friends_QueryFriendsOptions* Options, void* ClientData, const EOS_Friends_OnQueryFriendsCallback CompletionDelegate);

/**
 * Starts an asynchronous task that sends a friend invitation to another user. The completion delegate is executed after the backend response has been received.
 * It does not indicate that the target user has responded to the friend invitation.
 *
 * @param Options structure containing the account to send the invite from and the account to send the invite to
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error
 */
EOS_DECLARE_FUNC(void) EOS_Friends_SendInvite(EOS_HFriends Handle, const EOS_Friends_SendInviteOptions* Options, void* ClientData, const EOS_Friends_OnSendInviteCallback CompletionDelegate);

/**
 * Starts an asynchronous task that accepts a friend invitation from another user. The completion delegate is executed after the backend response has been received.
 *
 * @param Options structure containing the logged in account and the inviting account
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error
 */
EOS_DECLARE_FUNC(void) EOS_Friends_AcceptInvite(EOS_HFriends Handle, const EOS_Friends_AcceptInviteOptions* Options, void* ClientData, const EOS_Friends_OnAcceptInviteCallback CompletionDelegate);

/**
 * Starts an asynchronous task that rejects a friend invitation from another user. The completion delegate is executed after the backend response has been received.
 *
 * @param Options structure containing the logged in account and the inviting account
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error
 */
EOS_DECLARE_FUNC(void) EOS_Friends_RejectInvite(EOS_HFriends Handle, const EOS_Friends_RejectInviteOptions* Options, void* ClientData, const EOS_Friends_OnRejectInviteCallback CompletionDelegate);

/**
 * Retrieves the number of friends on the friends list that has already been retrieved by the EOS_Friends_QueryFriends API.
 *
 * @param Options structure containing the Epic Account ID of user who owns the friends list
 * @return the number of friends on the list
 *
 * @see EOS_Friends_GetFriendAtIndex
 */
EOS_DECLARE_FUNC(int32_t) EOS_Friends_GetFriendsCount(EOS_HFriends Handle, const EOS_Friends_GetFriendsCountOptions* Options);

/**
 * Retrieves the Epic Account ID of an entry from the friends list that has already been retrieved by the EOS_Friends_QueryFriends API.
 * The Epic Account ID returned by this function may belong to an account that has been invited to be a friend or that has invited the local user to be a friend.
 * To determine if the Epic Account ID returned by this function is a friend or a pending friend invitation, use the EOS_Friends_GetStatus function.
 *
 * @param Options structure containing the Epic Account ID of the owner of the friends list and the index into the list
 * @return the Epic Account ID of the friend. Note that if the index provided is out of bounds, the returned Epic Account ID will be a "null" account ID.
 *
 * @see EOS_Friends_GetFriendsCount
 * @see EOS_Friends_GetStatus
 */
EOS_DECLARE_FUNC(EOS_EpicAccountId) EOS_Friends_GetFriendAtIndex(EOS_HFriends Handle, const EOS_Friends_GetFriendAtIndexOptions* Options);

/**
 * Retrieve the friendship status between the local user and another user.
 *
 * @param Options structure containing the Epic Account ID of the friend list to check and the account of the user to test friendship status
 * @return A value indicating whether the two accounts have a friendship, pending invites in either direction, or no relationship
 *         EOS_FS_Friends is returned for two users that have confirmed friendship
 *         EOS_FS_InviteSent is returned when the local user has sent a friend invitation but the other user has not accepted or rejected it
 *         EOS_FS_InviteReceived is returned when the other user has sent a friend invitation to the local user
 *         EOS_FS_NotFriends is returned when there is no known relationship
 *
 * @see EOS_EFriendsStatus
 */
EOS_DECLARE_FUNC(EOS_EFriendsStatus) EOS_Friends_GetStatus(EOS_HFriends Handle, const EOS_Friends_GetStatusOptions* Options);

/**
 * Listen for changes to friends for a particular account.
 *
 * @param Options Information about who would like notifications.
 * @param ClientData This value is returned to the caller when FriendsUpdateHandler is invoked.
 * @param FriendsUpdateHandler The callback to be invoked when a change to any friend status changes.
 * @return A valid notification ID if successfully bound, or EOS_INVALID_NOTIFICATIONID otherwise
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_Friends_AddNotifyFriendsUpdate(EOS_HFriends Handle, const EOS_Friends_AddNotifyFriendsUpdateOptions* Options, void* ClientData, const EOS_Friends_OnFriendsUpdateCallback FriendsUpdateHandler);

/**
 * Stop listening for friends changes on a previously bound handler.
 *
 * @param NotificationId The previously bound notification ID.
 */
EOS_DECLARE_FUNC(void) EOS_Friends_RemoveNotifyFriendsUpdate(EOS_HFriends Handle, EOS_NotificationId NotificationId);

```

`eac/sdk/Include/eos_friends_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

EXTERN_C typedef struct EOS_FriendsHandle* EOS_HFriends;

/**
 * EOS_Friends_QueryFriends is used to start an asynchronous query to retrieve friends and pending outbound/inbound friends list invitations for a user account.
 * The following types are used to work with the API.
 */


/** The most recent version of the EOS_Friends_QueryFriends API. */
#define EOS_FRIENDS_QUERYFRIENDS_API_LATEST 1

/**
 * Input parameters for the EOS_Friends_QueryFriends function.
 */
EOS_STRUCT(EOS_Friends_QueryFriendsOptions, (
	/** API Version: Set this to EOS_FRIENDS_QUERYFRIENDS_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local, logged-in user whose friends list you want to retrieve */
	EOS_EpicAccountId LocalUserId;
));

/**
 * Output parameters for the EOS_Friends_QueryFriends Function. These parameters are received through the callback provided to EOS_Friends_QueryFriends
 */
EOS_STRUCT(EOS_Friends_QueryFriendsCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Friends_QueryFriends */
	void* ClientData;
	/** The Epic Account ID of the user whose friends were queried */
	EOS_EpicAccountId LocalUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Friends_QueryFriends
 * @param Data A EOS_Friends_QueryFriendsCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Friends_OnQueryFriendsCallback, const EOS_Friends_QueryFriendsCallbackInfo* Data);



/**
 * EOS_Friends_SendInvite is used to start an asynchronous operation to send a friends list invitation from a local user to a target user.
 * The following types are used to work with the API.
 */

 /** The most recent version of the EOS_Friends_SendInvite API. */
#define EOS_FRIENDS_SENDINVITE_API_LATEST 1

/**
 * Input parameters for the EOS_Friends_SendInvite function.
 */
EOS_STRUCT(EOS_Friends_SendInviteOptions, (
	/** API Version: Set this to EOS_FRIENDS_SENDINVITE_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local, logged-in user who is sending the friends list invitation */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the user who is receiving the friends list invitation */
	EOS_EpicAccountId TargetUserId;
));

/**
 * Output parameters for the EOS_Friends_SendInvite API.
 */
EOS_STRUCT(EOS_Friends_SendInviteCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned if the invitation was sent, otherwise one of the error codes is returned. See eos_common.h */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Friends_SendInvite */
	void* ClientData;
	/** The Epic Account ID of the user who sent the friends list invitation */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the user to whom the friends list invitation was sent */
	EOS_EpicAccountId TargetUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Friends_SendInvite
 * @param Data A EOS_Friends_SendInviteCallbackInfo containing the output information and result.
 */
EOS_DECLARE_CALLBACK(EOS_Friends_OnSendInviteCallback, const EOS_Friends_SendInviteCallbackInfo* Data);



/**
 * EOS_Friends_AcceptInvite is used to start an asynchronous operation to accept a friends list invitation from another user.
 * The following types are used to work with the API.
 */

/** The most recent version of the EOS_Friends_AcceptInvite API. */
#define EOS_FRIENDS_ACCEPTINVITE_API_LATEST 1

/**
 * Input parameters for the EOS_Friends_AcceptInvite function.
 */
EOS_STRUCT(EOS_Friends_AcceptInviteOptions, (
	/** API Version: Set this to EOS_FRIENDS_ACCEPTINVITE_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local, logged-in user who is accepting the friends list invitation */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the user who sent the friends list invitation */
	EOS_EpicAccountId TargetUserId;
));

/**
 * Output parameters for the EOS_Friends_AcceptInvite Function.
 */
EOS_STRUCT(EOS_Friends_AcceptInviteCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned if an invite was accepted, otherwise one of the error codes is returned. See eos_common.h */
	EOS_EResult ResultCode;
	/** Context that is passed into EOS_Friends_AcceptInvite */
	void* ClientData;
	/** The Epic Account ID of the user who is accepting the friends list invitation */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the user who sent the local user a friends list invitation */
	EOS_EpicAccountId TargetUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Friends_AcceptInvite
 * @param Data A EOS_Friends_AcceptInviteCallbackInfo containing the output information and result.
 */
EOS_DECLARE_CALLBACK(EOS_Friends_OnAcceptInviteCallback, const EOS_Friends_AcceptInviteCallbackInfo* Data);



/**
 * EOS_Friends_RejectInvite is used to start an asynchronous operation to reject a friends list invitation from another user.
 * The following types are used to work with the API.
 */

/** The most recent version of the EOS_Friends_RejectInvite API. */
#define EOS_FRIENDS_REJECTINVITE_API_LATEST 1

/**
 * Input parameters for the EOS_Friends_RejectInvite function.
 */
EOS_STRUCT(EOS_Friends_RejectInviteOptions, (
	/** API Version: Set this to EOS_FRIENDS_REJECTINVITE_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local, logged-in user who is rejecting a friends list invitation */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the user who sent the friends list invitation */
	EOS_EpicAccountId TargetUserId;
));

/**
 * Output parameters for the EOS_Friends_RejectInvite Function.
 */
EOS_STRUCT(EOS_Friends_RejectInviteCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned if an invite was accepted, otherwise one of the error codes is returned. See eos_common.h */
	EOS_EResult ResultCode;
	/** Context that is passed into EOS_Friends_RejectInvite */
	void* ClientData;
	/** The Epic Account ID of the user who is rejecting the friends list invitation */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the user who sent the friends list invitation */
	EOS_EpicAccountId TargetUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Friends_RejectInvite
 * @param Data A EOS_Friends_RejectInviteCallbackInfo containing output information and the result.
 */
EOS_DECLARE_CALLBACK(EOS_Friends_OnRejectInviteCallback, const EOS_Friends_RejectInviteCallbackInfo* Data);



/**
 * EOS_Friends_DeleteFriend is used to start an asynchronous operation to delete a friend from the friend list.
 * The following types are used to work with the API.
 */

 /** The most recent version of the EOS_Friends_DeleteFriend API. */
#define EOS_FRIENDS_DELETEFRIEND_API_LATEST 1

/**
 * Input parameters for the EOS_Friends_DeleteFriend function.
 */
EOS_STRUCT(EOS_Friends_DeleteFriendOptions, (
	/** API Version: Set this to EOS_FRIENDS_DELETEFRIEND_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local, logged-in user who is deleting a friend. */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the user to remove from the friends list. */
	EOS_EpicAccountId TargetUserId;
));

/**
 * Output parameters for the EOS_Friends_DeleteFriend Function.
 */
EOS_STRUCT(EOS_Friends_DeleteFriendCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned if an invite was accepted, otherwise one of the error codes is returned. See eos_common.h */
	EOS_EResult ResultCode;
	/** Context that is passed into EOS_Friends_DeleteFriend */
	void* ClientData;
	/** The Epic Account ID of the user who is removing a user from their friends list. */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the user who is being removed from the friends list. */
	EOS_EpicAccountId TargetUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Friends_DeleteFriend
 * @param Data A EOS_Friends_DeleteFriendCallbackInfo containing output information and the result.
 */
EOS_DECLARE_CALLBACK(EOS_Friends_OnDeleteFriendCallback, const EOS_Friends_DeleteFriendCallbackInfo* Data);



/**
 * EOS_Friends_GetFriendsCount is used to immediately retrieve the number of cached friendships. 
 * The following types are used to work with the API.
 */

 /** The most recent version of the EOS_Friends_GetFriendsCount API. */
#define EOS_FRIENDS_GETFRIENDSCOUNT_API_LATEST 1


/**
 * Input parameters for the EOS_Friends_GetFriendsCount function.
 */
EOS_STRUCT(EOS_Friends_GetFriendsCountOptions, (
	/** API Version: Set this to EOS_FRIENDS_GETFRIENDSCOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the user whose friends should be counted */
	EOS_EpicAccountId LocalUserId;
));


/**
 * EOS_Friends_GetFriendAtIndex is used to immediately retrieve the account ID of another user who has a friendship (or pending friendship).
 * The following types are used to work with the API.
 */

 /** The most recent version of the EOS_Friends_GetFriendAtIndex API. */
#define EOS_FRIENDS_GETFRIENDATINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_Friends_GetFriendAtIndex function.
 */
EOS_STRUCT(EOS_Friends_GetFriendAtIndexOptions, (
	/** API Version: Set this to EOS_FRIENDS_GETFRIENDATINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the user whose friend list is being queried */
	EOS_EpicAccountId LocalUserId;
	/** Index into the friend list. This value must be between 0 and EOS_Friends_GetFriendsCount-1 inclusively. */
	int32_t Index;
));



/**
 * EOS_Friends_GetStatus is used to immediately retrieve the friendship status between two users.
 * The following types are used to work with the API.
 */

 /** The most recent version of the EOS_Friends_GetStatus API. */
#define EOS_FRIENDS_GETSTATUS_API_LATEST 1

/**
 * An enumeration of the different friendship statuses.
 */
EOS_ENUM(EOS_EFriendsStatus,
	/** The two accounts have no friendship status */
	EOS_FS_NotFriends = 0,
	/** The local account has sent a friend invite to the other account */
	EOS_FS_InviteSent = 1,
	/** The other account has sent a friend invite to the local account */
	EOS_FS_InviteReceived = 2,
	/** The accounts have accepted friendship */
	EOS_FS_Friends = 3
);

/**
 * Input parameters for the EOS_Friends_GetStatus function.
 */
EOS_STRUCT(EOS_Friends_GetStatusOptions, (
	/** API Version: Set this to EOS_FRIENDS_GETSTATUS_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local, logged in user */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the user whose friendship status with the local user is being queried */
	EOS_EpicAccountId TargetUserId;
));



/**
 * EOS_Friends_AddNotifyFriendsUpdate is used to setup notification to receive any friend status updates.
 * The following types are used to work with the API.
 */

/** The most recent version of the EOS_Friends_AddNotifyFriendsUpdate API. */
#define EOS_FRIENDS_ADDNOTIFYFRIENDSUPDATE_API_LATEST 1

/** Input parameters for the EOS_Friends_AddNotifyFriendsUpdate function.  */
EOS_STRUCT(EOS_Friends_AddNotifyFriendsUpdateOptions, (
	/** API Version: Set this to EOS_FRIENDS_ADDNOTIFYFRIENDSUPDATE_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Structure containing information about a friend status update.
 */
EOS_STRUCT(EOS_Friends_OnFriendsUpdateInfo, (
	/** Client-specified data passed into EOS_Friends_AddNotifyFriendsUpdate */
	void* ClientData;
	/** The Epic Account ID of the local user who is receiving the update */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the user whose status is being updated. */
	EOS_EpicAccountId TargetUserId;
	/** The previous status of the user. */
	EOS_EFriendsStatus PreviousStatus;
	/** The current status of the user. */
	EOS_EFriendsStatus CurrentStatus;
));

/**
 * Callback for information related to a friend status update.
 */
EOS_DECLARE_CALLBACK(EOS_Friends_OnFriendsUpdateCallback, const EOS_Friends_OnFriendsUpdateInfo* Data);


#pragma pack(pop)

```

`eac/sdk/Include/eos_init.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_types.h"

#pragma pack(push, 8)

/**
 * Function prototype type definition for functions that allocate memory.
 *
 * Functions passed to EOS_Initialize to serve as memory allocators should return a pointer to the allocated memory.
 *
 * The returned pointer should have at least SizeInBytes available capacity and the memory address should be a multiple of Alignment.
 * The SDK will always call the provided function with an Alignment that is a power of 2.
 * Allocation failures should return a null pointer.
 */
EXTERN_C typedef void* (EOS_MEMORY_CALL * EOS_AllocateMemoryFunc)(size_t SizeInBytes, size_t Alignment);

/**
 * Function prototype type definition for functions that reallocate memory.
 *
 * Functions passed to EOS_Initialize to serve as memory reallocators should return a pointer to the reallocated memory.
 * The returned pointer should have at least SizeInBytes available capacity and the memory address should be a multiple of alignment.
 * The SDK will always call the provided function with an Alignment that is a power of 2.
 * Reallocation failures should return a null pointer.
 */
EXTERN_C typedef void* (EOS_MEMORY_CALL * EOS_ReallocateMemoryFunc)(void* Pointer, size_t SizeInBytes, size_t Alignment);

/**
 * Function prototype type definition for functions that release memory.
 *
 * When the SDK is done with memory that has been allocated by a custom allocator passed to EOS_Initialize, it will call the corresponding memory release function.
 */
EXTERN_C typedef void (EOS_MEMORY_CALL * EOS_ReleaseMemoryFunc)(void* Pointer);

/** The most recent version of the EOS_Initialize_ThreadAffinity API. */
#define EOS_INITIALIZE_THREADAFFINITY_API_LATEST 1

/**
 * Options for initializing defining thread affinity for use by Epic Online Services SDK.
 * Set the affinity to 0 to allow EOS SDK to use a platform specific default value.
 */
EOS_STRUCT(EOS_Initialize_ThreadAffinity, (
	/** API Version: Set this to EOS_INITIALIZE_THREADAFFINITY_API_LATEST. */
	int32_t ApiVersion;
	/** Any thread related to network management that is not IO. */
	uint64_t NetworkWork;
	/** Any thread that will interact with a storage device. */
	uint64_t StorageIo;
	/** Any thread that will generate web socket IO. */
	uint64_t WebSocketIo;
	/** Any thread that will generate IO related to P2P traffic and mangement. */
	uint64_t P2PIo;
	/** Any thread that will generate http request IO. */
	uint64_t HttpRequestIo;
));

/** The most recent version of the EOS_Initialize API. */
#define EOS_INITIALIZE_API_LATEST 4

/**
 * Options for initializing the Epic Online Services SDK.
 */
EOS_STRUCT(EOS_InitializeOptions, (
	/** API Version: Set this to EOS_INITIALIZE_API_LATEST. */
	int32_t ApiVersion;
	/** A custom memory allocator, if desired. */
	EOS_AllocateMemoryFunc AllocateMemoryFunction;
	/** A corresponding memory reallocator. If the AllocateMemoryFunction is nulled, then this field must also be nulled. */
	EOS_ReallocateMemoryFunc ReallocateMemoryFunction;
	/** A corresponding memory releaser. If the AllocateMemoryFunction is nulled, then this field must also be nulled. */
	EOS_ReleaseMemoryFunc ReleaseMemoryFunction;
	/**
	 * The name of the product using the Epic Online Services SDK.
	 *
	 * The name string is required to be non-empty and at maximum of 64 characters long.
	 * The string buffer can consist of the following characters:
	 * A-Z, a-z, 0-9, dot, underscore, space, exclamation mark, question mark, and sign, hyphen, parenthesis, plus, minus, colon.
	 */
	const char* ProductName;
	/**
	 * Product version of the running application.
	 *
	 * The name string has same requirements as the ProductName string.
	 */
	const char* ProductVersion;
	/** A reserved field that should always be nulled. */
	void* Reserved;
	/** 
	 * This field is for system specific initialization if any.
	 *
	 * If provided then the structure will be located in <System>/eos_<system>.h.
	 * The structure will be named EOS_<System>_InitializeOptions.
	 */
	void* SystemInitializeOptions;
	/** The thread affinity override values for each category of thread. */
	EOS_Initialize_ThreadAffinity* OverrideThreadAffinity;
));

/**
 * Initialize the Epic Online Services SDK.
 *
 * Before calling any other function in the SDK, clients must call this function.
 *
 * This function must only be called one time and must have a corresponding EOS_Shutdown call.
 *
 * @param Options - The initialization options to use for the SDK.
 * @return An EOS_EResult is returned to indicate success or an error. 
 *
 * EOS_Success is returned if the SDK successfully initializes.
 * EOS_AlreadyConfigured is returned if the function has already been called.
 * EOS_InvalidParameters is returned if the provided options are invalid.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Initialize(const EOS_InitializeOptions* Options);

/**
 * Tear down the Epic Online Services SDK.
 *
 * Once this function has been called, no more SDK calls are permitted; calling anything after EOS_Shutdown will result in undefined behavior.
 * @return An EOS_EResult is returned to indicate success or an error.
 * EOS_Success is returned if the SDK is successfully torn down.
 * EOS_NotConfigured is returned if a successful call to EOS_Initialize has not been made.
 * EOS_UnexpectedError is returned if EOS_Shutdown has already been called.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Shutdown();

/**
 * Create a single Epic Online Services Platform Instance.
 *
 * The platform instance is used to gain access to the various Epic Online Services.
 *
 * This function returns an opaque handle to the platform instance, and that handle must be passed to EOS_Platform_Release to release the instance.
 *
 * @return An opaque handle to the platform instance.
 */
EOS_DECLARE_FUNC(EOS_HPlatform) EOS_Platform_Create(const EOS_Platform_Options* Options);

/**
 * Release an Epic Online Services platform instance previously returned from EOS_Platform_Create.
 *
 * This function should only be called once per instance returned by EOS_Platform_Create. Undefined behavior will result in calling it with a single instance more than once.
 * Typically only a single platform instance needs to be created during the lifetime of a game.
 * You should release each platform instance before calling the EOS_Shutdown function.
 */
EOS_DECLARE_FUNC(void) EOS_Platform_Release(EOS_HPlatform Handle);

#pragma pack(pop)

```

`eac/sdk/Include/eos_kws.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_kws_types.h"

/**
 * This interface is not available for general access at this time.
 *
 * The KWS Interface exists as an integration for age gating functionality provided by Kids Web Services from SuperAwesome, using the EOS Connect interface.
 * 
 * All KWS Interface calls take a handle of type EOS_HKWS as the first parameter.
 * This handle can be retrieved from a EOS_HPlatform handle by using the EOS_Platform_GetKWSInterface function.
 *
 * @see EOS_Platform_GetKWSInterface
 */

/**
 * This interface is not available for general access at this time.
 *
 * Query the client's country and age permissions for client side reasoning about the possible need enforce age based restrictions
 *
 * @param Options options required for interacting with the age gate system
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the operation completes, either successfully or in error
 *
 * @return EOS_Success if the query completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_TooManyRequests if the number of allowed queries is exceeded
 */
EOS_DECLARE_FUNC(void) EOS_KWS_QueryAgeGate(EOS_HKWS Handle, const EOS_KWS_QueryAgeGateOptions* Options, void* ClientData, const EOS_KWS_OnQueryAgeGateCallback CompletionDelegate);

/**
 * This interface is not available for general access at this time.
 *
 * Create an account with Kids Web Services and associate it with the local Product User ID
 *
 * @param Options options required for creating an account such as the local users Product User ID, their data of birth, and parental contact information
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the operation completes, either successfully or in error
 *
 * @return EOS_Success if account creation completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_TooManyRequests if the number of allowed requests is exceeded
 */
EOS_DECLARE_FUNC(void) EOS_KWS_CreateUser(EOS_HKWS Handle, const EOS_KWS_CreateUserOptions* Options, void* ClientData, const EOS_KWS_OnCreateUserCallback CompletionDelegate);

/**
 * This interface is not available for general access at this time.
 *
 * Query the current state of permissions for a given local Product User ID
 *
 * @param Options options required for querying permissions such as the local users Product User ID
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the operation completes, either successfully or in error
 *
 * @return EOS_Success if the account query completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_TooManyRequests if the number of allowed requests is exceeded
 */
EOS_DECLARE_FUNC(void) EOS_KWS_QueryPermissions(EOS_HKWS Handle, const EOS_KWS_QueryPermissionsOptions* Options, void* ClientData, const EOS_KWS_OnQueryPermissionsCallback CompletionDelegate);

/**
 * This interface is not available for general access at this time.
 *
 * Update the parent contact information for a given local Product User ID
 *
 * @param Options options required for updating the contact information such as the new email address
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the operation completes, either successfully or in error
 *
 * @return EOS_Success if contact information update completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_TooManyRequests if the number of allowed requests is exceeded
 */
EOS_DECLARE_FUNC(void) EOS_KWS_UpdateParentEmail(EOS_HKWS Handle, const EOS_KWS_UpdateParentEmailOptions* Options, void* ClientData, const EOS_KWS_OnUpdateParentEmailCallback CompletionDelegate);

/**
 * This interface is not available for general access at this time.
 *
 * Request new permissions for a given local Product User ID
 *
 * @param Options options required for updating permissions such as the new list of permissions
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the operation completes, either successfully or in error
 *
 * @return EOS_Success if contact information update completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_TooManyRequests if the number of allowed requests is exceeded
 *         EOS_KWS_ParentEmailMissing if the account requesting permissions has no parent email associated with it
 *         EOS_LimitExceeded if the number of permissions exceeds EOS_KWS_MAX_PERMISSIONS, or if any permission name exceeds EOS_KWS_MAX_PERMISSION_LENGTH
 */
EOS_DECLARE_FUNC(void) EOS_KWS_RequestPermissions(EOS_HKWS Handle, const EOS_KWS_RequestPermissionsOptions* Options, void* ClientData, const EOS_KWS_OnRequestPermissionsCallback CompletionDelegate);

/**
 * This interface is not available for general access at this time.
 *
 * Fetch the number of permissions found for a given local user
 *
 * @param Options Structure containing the input parameters
 *
 * @return the number of permissions associated with the given user
 */
EOS_DECLARE_FUNC(int32_t) EOS_KWS_GetPermissionsCount(EOS_HKWS Handle, const EOS_KWS_GetPermissionsCountOptions* Options);

/**
 * This interface is not available for general access at this time.
 *
 * Fetch a permission for a given by index for a given local user
 *
 * @param Options Structure containing the input parameters
 * @param OutPermission the permission for the given index, if it exists and is valid, use EOS_KWS_PermissionStatus_Release when finished
 *
 * @see EOS_KWS_CreateUser
 * @see EOS_KWS_QueryPermissions
 * @see EOS_KWS_RequestPermissions
 * @see EOS_KWS_PermissionStatus_Release
 *
 * @return EOS_Success if the permission state is known for the given user and index
 *         EOS_NotFound if the user is not found or the index is invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_KWS_CopyPermissionByIndex(EOS_HKWS Handle, const EOS_KWS_CopyPermissionByIndexOptions* Options, EOS_KWS_PermissionStatus ** OutPermission);

/**
 * This interface is not available for general access at this time.
 *
 * Fetch the state of a given permission that are cached for a given local user.
 *
 * @param Options Structure containing the input parameters
 * @param OutPermission the permission for the given key, if it exists and is valid
 *
 * @see EOS_KWS_CreateUser
 * @see EOS_KWS_QueryPermissions
 * @see EOS_KWS_RequestPermissions
 *
 * @return EOS_Success if the permission state is known for the given user and key
 *         EOS_NotFound if the user or the permission is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_KWS_GetPermissionByKey(EOS_HKWS Handle, const EOS_KWS_GetPermissionByKeyOptions* Options, EOS_EKWSPermissionStatus* OutPermission);

/**
 * This interface is not available for general access at this time.
 *
 * Register to receive notifications about KWS permissions changes for any logged in local users
 * @note must call EOS_KWS_RemoveNotifyPermissionsUpdateReceived to remove the notification
 *
 * @param Options Structure containing information about the request.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param NotificationFn A callback that is fired when a notification is received.
 *
 * @return handle representing the registered callback
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_KWS_AddNotifyPermissionsUpdateReceived(EOS_HKWS Handle, const EOS_KWS_AddNotifyPermissionsUpdateReceivedOptions* Options, void* ClientData, const EOS_KWS_OnPermissionsUpdateReceivedCallback NotificationFn);

/**
 * This interface is not available for general access at this time.
 *
 * Unregister from receiving notifications about KWS permissions related to logged in users
 *
 * @param InId Handle representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_KWS_RemoveNotifyPermissionsUpdateReceived(EOS_HKWS Handle, EOS_NotificationId InId);

```

`eac/sdk/Include/eos_kws_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

EXTERN_C typedef struct EOS_KWSHandle* EOS_HKWS;

/** Maximum number of permissions that may be requested */
#define EOS_KWS_MAX_PERMISSIONS 16

/** Maximum size of the name for the permission */
#define EOS_KWS_MAX_PERMISSION_LENGTH 32

/**
 * An enumeration of the different permission statuses.
 */
EOS_ENUM(EOS_EKWSPermissionStatus,
	/** Permission has been granted */
	EOS_KPS_GRANTED = 0,
	/** Permission has been rejected */
	EOS_KPS_REJECTED = 1,
	/** Permission is still pending approval */
	EOS_KPS_PENDING = 2
);

/** The most recent version of the EOS_KWS_PermissionStatus API. */
#define EOS_KWS_PERMISSIONSTATUS_API_LATEST 1

EOS_STRUCT(EOS_KWS_PermissionStatus, (
	/** API Version: Set this to EOS_KWS_PERMISSIONSTATUS_API_LATEST. */
	int32_t ApiVersion;
	/** Name of the permission */
	const char* Name;
	/** Status of the permission */
	EOS_EKWSPermissionStatus Status;
));

EOS_DECLARE_FUNC(void) EOS_KWS_PermissionStatus_Release(EOS_KWS_PermissionStatus* PermissionStatus);

 /** The most recent version of the EOS_KWS_QueryAgeGate API. */
#define EOS_KWS_QUERYAGEGATE_API_LATEST 1

/**
 * Input parameters for the EOS_KWS_QueryAgeGate function.
 */
EOS_STRUCT(EOS_KWS_QueryAgeGateOptions, (
	/** API Version: Set this to EOS_KWS_QUERYAGEGATE_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_KWS_QueryAgeGate Function. These parameters are received through the callback provided to EOS_KWS_QueryAgeGate
 */
EOS_STRUCT(EOS_KWS_QueryAgeGateCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_KWS_QueryAgeGate */
	void* ClientData;
	/** Country code determined for this request based on the local client's ip address that the backend resolves */
	const char* CountryCode;
	/** Age of consent in the given country */
	uint32_t AgeOfConsent;
));

/**
 * Function prototype definition for callbacks passed to EOS_KWS_QueryAgeGate
 * @param Data A EOS_KWS_QueryAgeGateCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_KWS_OnQueryAgeGateCallback, const EOS_KWS_QueryAgeGateCallbackInfo* Data);

/** The most recent version of the EOS_KWS_CreateUser API. */
#define EOS_KWS_CREATEUSER_API_LATEST 1

/**
 * Input parameters for the EOS_KWS_CreateUser function.
 */
EOS_STRUCT(EOS_KWS_CreateUserOptions, (
	/** API Version: Set this to EOS_KWS_CREATEUSER_API_LATEST. */
	int32_t ApiVersion;
	/** Local user creating a KWS entry */
	EOS_ProductUserId LocalUserId;
	/** Date of birth in ISO8601 form (YYYY-MM-DD) */
	const char* DateOfBirth;
	/** Parent email */
	const char* ParentEmail;
));

/**
 * Output parameters for the EOS_KWS_CreateUserOptions Function. These parameters are received through the callback provided to EOS_KWS_CreateUser
 */
EOS_STRUCT(EOS_KWS_CreateUserCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_KWS_CreateUser */
	void* ClientData;
	/** Local user that created a KWS entry */
	EOS_ProductUserId LocalUserId;
	/** KWS UserId created */
	const char* KWSUserId;
	/** Is this user a minor */
	EOS_Bool bIsMinor;
));


/**
 * Function prototype definition for callbacks passed to EOS_KWS_CreateUser
 * @param Data A EOS_KWS_CreateUserCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_KWS_OnCreateUserCallback, const EOS_KWS_CreateUserCallbackInfo* Data);

 /** The most recent version of the EOS_KWS_QueryPermissions API. */
#define EOS_KWS_QUERYPERMISSIONS_API_LATEST 1

/**
 * Input parameters for the EOS_KWS_QueryPermissions function.
 */
EOS_STRUCT(EOS_KWS_QueryPermissionsOptions, (
	/** API Version: Set this to EOS_KWS_QUERYPERMISSIONS_API_LATEST. */
	int32_t ApiVersion;
	/** Local user querying their permisssions */
	EOS_ProductUserId LocalUserId;
));

/**
 * Output parameters for the EOS_KWS_QueryPermissionsOptions Function. These parameters are received through the callback provided to EOS_KWS_QueryPermissions
 */
EOS_STRUCT(EOS_KWS_QueryPermissionsCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_KWS_QueryPermissions */
	void* ClientData;
	/** Local user querying their permisssions */
	EOS_ProductUserId LocalUserId;
	/** KWS UserId created */
	const char* KWSUserId;
	/** Date of birth in ISO8601 form (YYYY-MM-DD) */
	const char* DateOfBirth;
	/** Is this user a minor */
	EOS_Bool bIsMinor;
));

/**
 * Function prototype definition for callbacks passed to EOS_KWS_QueryPermissions
 * @param Data A EOS_KWS_QueryPermissionsCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_KWS_OnQueryPermissionsCallback, const EOS_KWS_QueryPermissionsCallbackInfo* Data);

 /** The most recent version of the EOS_KWS_UpdateParentEmail API. */
#define EOS_KWS_UPDATEPARENTEMAIL_API_LATEST 1

/**
 * Input parameters for the EOS_KWS_UpdateParentEmail function.
 */
EOS_STRUCT(EOS_KWS_UpdateParentEmailOptions, (
	/** API Version: Set this to EOS_KWS_UPDATEPARENTEMAIL_API_LATEST. */
	int32_t ApiVersion;
	/** Local user updating parental information */
	EOS_ProductUserId LocalUserId;
	/** New parent email */
	const char* ParentEmail;
));

/**
 * Output parameters for the EOS_KWS_UpdateParentEmailOptions Function. These parameters are received through the callback provided to EOS_KWS_UpdateParentEmail
 */
EOS_STRUCT(EOS_KWS_UpdateParentEmailCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_KWS_UpdateParentEmail */
	void* ClientData;
	/** Local user updating their parental email */
	EOS_ProductUserId LocalUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_KWS_UpdateParentEmail
 * @param Data A EOS_KWS_UpdateParentEmailCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_KWS_OnUpdateParentEmailCallback, const EOS_KWS_UpdateParentEmailCallbackInfo* Data);

 /** The most recent version of the EOS_KWS_RequestPermissions API. */
#define EOS_KWS_REQUESTPERMISSIONS_API_LATEST 1

/**
 * Input parameters for the EOS_KWS_RequestPermissions function.
 */
EOS_STRUCT(EOS_KWS_RequestPermissionsOptions, (
	/** API Version: Set this to EOS_KWS_REQUESTPERMISSIONS_API_LATEST. */
	int32_t ApiVersion;
	/** Local user requesting new permisssions */
	EOS_ProductUserId LocalUserId;
	/** The number of permissions to request, may not exceed EOS_KWS_MAX_PERMISSIONS. Only new permissions need be included. */
	uint32_t PermissionKeyCount;
	/** Names of the permissions to request (Setup with KWS) */
	const char** PermissionKeys;
));

/**
 * Output parameters for the EOS_KWS_RequestPermissionsOptions Function. These parameters are received through the callback provided to EOS_KWS_RequestPermissions
 */
EOS_STRUCT(EOS_KWS_RequestPermissionsCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_KWS_RequestPermissions */
	void* ClientData;
	/** Local user requesting new permisssions */
	EOS_ProductUserId LocalUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_KWS_RequestPermissions
 * @param Data A EOS_KWS_RequestPermissionsCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_KWS_OnRequestPermissionsCallback, const EOS_KWS_RequestPermissionsCallbackInfo* Data);


#define EOS_KWS_GETPERMISSIONSCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_KWS_GetPermissionsCount function.
 */
EOS_STRUCT(EOS_KWS_GetPermissionsCountOptions, (
	/** API Version: Set this to EOS_KWS_GETPERMISSIONSCOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user whose permissions are being accessed */
	EOS_ProductUserId LocalUserId;
));

/** The most recent version of the EOS_KWS_CopyPermissionByIndex API. */
#define EOS_KWS_COPYPERMISSIONBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_KWS_CopyPermissionByIndex function.
 */
EOS_STRUCT(EOS_KWS_CopyPermissionByIndexOptions, (
	/** API Version: Set this to EOS_KWS_COPYPERMISSIONBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user whose permissions are being accessed */
	EOS_ProductUserId LocalUserId;
	/** The index of the permission to get. */
	uint32_t Index;
));

/** The most recent version of the EOS_KWS_CreateUser API. */
#define EOS_KWS_GETPERMISSIONBYKEY_API_LATEST 1

/**
 * Input parameters for the EOS_KWS_GetPermissionByKey function.
 */
EOS_STRUCT(EOS_KWS_GetPermissionByKeyOptions, (
	/** API Version: Set this to EOS_KWS_GETPERMISSIONBYKEY_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user getting permissions */
	EOS_ProductUserId LocalUserId;
	/** Permission name to query */
	const char* Key;
));

/** The most recent version of the EOS_KWS_AddNotifyPermissionsUpdateReceived API. */
#define EOS_KWS_ADDNOTIFYPERMISSIONSUPDATERECEIVED_API_LATEST 1

EOS_STRUCT(EOS_KWS_AddNotifyPermissionsUpdateReceivedOptions, (
	/** API Version: Set this to EOS_KWS_ADDNOTIFYPERMISSIONSUPDATERECEIVED_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_KWS_OnPermissionsUpdateReceivedCallback Function.
 */
EOS_STRUCT(EOS_KWS_PermissionsUpdateReceivedCallbackInfo, (
	/** Context that was passed into EOS_KWS_AddNotifyPermissionsUpdateReceived */
	void* ClientData;
	/** Recipient Local user id */
	EOS_ProductUserId LocalUserId;
));

/**
 * Function prototype definition for notifications that comes from EOS_KWS_AddNotifyPermissionsUpdateReceived
 *
 * @param Data A EOS_KWS_PermissionsUpdateReceivedCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_KWS_OnPermissionsUpdateReceivedCallback, const EOS_KWS_PermissionsUpdateReceivedCallbackInfo* Data);

#pragma pack(pop)

```

`eac/sdk/Include/eos_leaderboards.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_leaderboards_types.h"

/**
 * The following EOS_Leaderboards_* functions allow you to query existing leaderboard definitions that have been defined for your application.
 * You can retrieve a list of scores for the top users for each Leaderboard.
 * You can also query scores for one or more users.
 */

/**
 * Query for a list of existing leaderboards definitions including their attributes.
 *
 * @param Options Structure containing information about the application whose leaderboard definitions we're retrieving.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param CompletionDelegate This function is called when the query operation completes.
 *
 * @return EOS_Success if the operation completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 */
EOS_DECLARE_FUNC(void) EOS_Leaderboards_QueryLeaderboardDefinitions(EOS_HLeaderboards Handle, const EOS_Leaderboards_QueryLeaderboardDefinitionsOptions* Options, void* ClientData, const EOS_Leaderboards_OnQueryLeaderboardDefinitionsCompleteCallback CompletionDelegate);

/**
 * Fetch the number of leaderboards definitions that are cached locally.
 *
 * @param Options The Options associated with retrieving the leaderboard count.
 *
 * @see EOS_Leaderboards_CopyLeaderboardDefinitionByIndex
 * @see EOS_Leaderboards_CopyLeaderboardDefinitionByLeaderboardId
 *
 * @return Number of leaderboards or 0 if there is an error
 */
EOS_DECLARE_FUNC(uint32_t) EOS_Leaderboards_GetLeaderboardDefinitionCount(EOS_HLeaderboards Handle, const EOS_Leaderboards_GetLeaderboardDefinitionCountOptions* Options);

/**
 * Fetches a leaderboard definition from the cache using an index.
 *
 * @param Options Structure containing the index being accessed.
 * @param OutLeaderboardDefinition The leaderboard data for the given index, if it exists and is valid, use EOS_Leaderboards_Definition_Release when finished.
 *
 * @see EOS_Leaderboards_Definition_Release
 *
 * @return EOS_Success if the information is available and passed out in OutLeaderboardDefinition
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the leaderboard is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Leaderboards_CopyLeaderboardDefinitionByIndex(EOS_HLeaderboards Handle, const EOS_Leaderboards_CopyLeaderboardDefinitionByIndexOptions* Options, EOS_Leaderboards_Definition ** OutLeaderboardDefinition);

/**
 * Fetches a leaderboard definition from the cache using a leaderboard ID.
 *
 * @param Options Structure containing the leaderboard ID being accessed.
 * @param OutLeaderboardDefinition The leaderboard definition for the given leaderboard ID, if it exists and is valid, use EOS_Leaderboards_Definition_Release when finished.
 *
 * @see EOS_Leaderboards_Definition_Release
 *
 * @return EOS_Success if the information is available and passed out in OutLeaderboardDefinition
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the leaderboard data is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Leaderboards_CopyLeaderboardDefinitionByLeaderboardId(EOS_HLeaderboards Handle, const EOS_Leaderboards_CopyLeaderboardDefinitionByLeaderboardIdOptions* Options, EOS_Leaderboards_Definition ** OutLeaderboardDefinition);

/**
 * Retrieves top leaderboard records by rank in the leaderboard matching the given leaderboard ID.
 *
 * @param Options Structure containing information about the leaderboard records we're retrieving.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param CompletionDelegate This function is called when the query operation completes.
 *
 * @return EOS_Success if the operation completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 */
EOS_DECLARE_FUNC(void) EOS_Leaderboards_QueryLeaderboardRanks(EOS_HLeaderboards Handle, const EOS_Leaderboards_QueryLeaderboardRanksOptions* Options, void* ClientData, const EOS_Leaderboards_OnQueryLeaderboardRanksCompleteCallback CompletionDelegate);

/**
 * Fetch the number of leaderboard records that are cached locally.
 *
 * @param Options The Options associated with retrieving the leaderboard record count.
 *
 * @see EOS_Leaderboards_CopyLeaderboardRecordByIndex
 * @see EOS_Leaderboards_CopyLeaderboardRecordByUserId
 *
 * @return Number of leaderboard records or 0 if there is an error
 */
EOS_DECLARE_FUNC(uint32_t) EOS_Leaderboards_GetLeaderboardRecordCount(EOS_HLeaderboards Handle, const EOS_Leaderboards_GetLeaderboardRecordCountOptions* Options);

/**
 * Fetches a leaderboard record from a given index.
 *
 * @param Options Structure containing the index being accessed.
 * @param OutLeaderboardRecord The leaderboard record for the given index, if it exists and is valid, use EOS_Leaderboards_LeaderboardRecord_Release when finished.
 *
 * @see EOS_Leaderboards_LeaderboardRecord_Release
 *
 * @return EOS_Success if the leaderboard record is available and passed out in OutLeaderboardRecord
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the leaderboard is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Leaderboards_CopyLeaderboardRecordByIndex(EOS_HLeaderboards Handle, const EOS_Leaderboards_CopyLeaderboardRecordByIndexOptions* Options, EOS_Leaderboards_LeaderboardRecord ** OutLeaderboardRecord);

/**
 * Fetches a leaderboard record from a given user ID.
 *
 * @param Options Structure containing the user ID being accessed.
 * @param OutLeaderboardRecord The leaderboard record for the given user ID, if it exists and is valid, use EOS_Leaderboards_LeaderboardRecord_Release when finished.
 *
 * @see EOS_Leaderboards_LeaderboardRecord_Release
 *
 * @return EOS_Success if the leaderboard record is available and passed out in OutLeaderboardRecord
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the leaderboard data is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Leaderboards_CopyLeaderboardRecordByUserId(EOS_HLeaderboards Handle, const EOS_Leaderboards_CopyLeaderboardRecordByUserIdOptions* Options, EOS_Leaderboards_LeaderboardRecord ** OutLeaderboardRecord);

/**
 * Query for a list of scores for a given list of users.
 *
 * @param Options Structure containing information about the users whose scores we're retrieving.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param CompletionDelegate This function is called when the query operation completes.
 *
 * @return EOS_Success if the operation completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 */
EOS_DECLARE_FUNC(void) EOS_Leaderboards_QueryLeaderboardUserScores(EOS_HLeaderboards Handle, const EOS_Leaderboards_QueryLeaderboardUserScoresOptions* Options, void* ClientData, const EOS_Leaderboards_OnQueryLeaderboardUserScoresCompleteCallback CompletionDelegate);

/**
 * Fetch the number of leaderboard user scores that are cached locally.
 *
 * @param Options The Options associated with retrieving the leaderboard user scores count.
 *
 * @see EOS_Leaderboards_CopyLeaderboardUserScoreByIndex
 * @see EOS_Leaderboards_CopyLeaderboardUserScoreByUserId
 *
 * @return Number of leaderboard records or 0 if there is an error
 */
EOS_DECLARE_FUNC(uint32_t) EOS_Leaderboards_GetLeaderboardUserScoreCount(EOS_HLeaderboards Handle, const EOS_Leaderboards_GetLeaderboardUserScoreCountOptions* Options);

/**
 * Fetches leaderboard user score from a given index.
 *
 * @param Options Structure containing the index being accessed.
 * @param OutLeaderboardUserScore The leaderboard user score for the given index, if it exists and is valid, use EOS_Leaderboards_LeaderboardUserScore_Release when finished.
 *
 * @see EOS_Leaderboards_LeaderboardUserScore_Release
 *
 * @return EOS_Success if the leaderboard scores are available and passed out in OutLeaderboardUserScore
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the leaderboard user scores are not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Leaderboards_CopyLeaderboardUserScoreByIndex(EOS_HLeaderboards Handle, const EOS_Leaderboards_CopyLeaderboardUserScoreByIndexOptions* Options, EOS_Leaderboards_LeaderboardUserScore ** OutLeaderboardUserScore);

/**
 * Fetches leaderboard user score from a given user ID.
 *
 * @param Options Structure containing the user ID being accessed.
 * @param OutLeaderboardUserScore The leaderboard user score for the given user ID, if it exists and is valid, use EOS_Leaderboards_LeaderboardUserScore_Release when finished.
 *
 * @see EOS_Leaderboards_LeaderboardUserScore_Release
 *
 * @return EOS_Success if the leaderboard scores are available and passed out in OutLeaderboardUserScore
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the leaderboard user scores are not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Leaderboards_CopyLeaderboardUserScoreByUserId(EOS_HLeaderboards Handle, const EOS_Leaderboards_CopyLeaderboardUserScoreByUserIdOptions* Options, EOS_Leaderboards_LeaderboardUserScore ** OutLeaderboardUserScore);

```

`eac/sdk/Include/eos_leaderboards_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

EXTERN_C typedef struct EOS_LeaderboardsHandle* EOS_HLeaderboards;

/** Timestamp value representing an undefined time for EOS_HLeaderboards. */
#define EOS_LEADERBOARDS_TIME_UNDEFINED -1

/** The most recent version of the EOS_Leaderboards_QueryLeaderboardDefinitions struct. */
#define EOS_LEADERBOARDS_QUERYLEADERBOARDDEFINITIONS_API_LATEST 2

/**
 * Input parameters for the EOS_Leaderboards_QueryLeaderboardDefinitions function.
 * StartTime and EndTime are optional parameters, they can be used to limit the list of definitions
 * to overlap the time window specified.
 */
EOS_STRUCT(EOS_Leaderboards_QueryLeaderboardDefinitionsOptions, (
	/** API Version: Set this to EOS_LEADERBOARDS_QUERYLEADERBOARDDEFINITIONS_API_LATEST. */
	int32_t ApiVersion;
	/** An optional POSIX timestamp for the leaderboard's start time, or EOS_LEADERBOARDS_TIME_UNDEFINED */
	int64_t StartTime;
	/** An optional POSIX timestamp for the leaderboard's end time, or EOS_LEADERBOARDS_TIME_UNDEFINED */
	int64_t EndTime;
	/**
	 * Product User ID for user who is querying definitions.
	 * Must be set when using a client policy that requires a valid logged in user.
	 * Not used for Dedicated Server where no user is available.
	 */
	EOS_ProductUserId LocalUserId;
));

/**
 * An enumeration of the different leaderboard aggregation types.
 */
EOS_ENUM(EOS_ELeaderboardAggregation,
	/** Minimum */
	EOS_LA_Min = 0,
	/** Maximum */
	EOS_LA_Max = 1,
	/** Sum */
	EOS_LA_Sum = 2,
	/** Latest */
	EOS_LA_Latest = 3
);

/** The most recent version of the EOS_Leaderboards_Definition struct. */
#define EOS_LEADERBOARDS_DEFINITION_API_LATEST 1

/**
 * Contains information about a single leaderboard definition
 */
EOS_STRUCT(EOS_Leaderboards_Definition, (
	/** API Version: Set this to EOS_LEADERBOARDS_DEFINITION_API_LATEST. */
	int32_t ApiVersion;
	/** Unique ID to identify leaderboard. */
	const char* LeaderboardId;
	/** Name of stat used to rank leaderboard. */
	const char* StatName;
	/** Aggregation used to sort leaderboard. */
	EOS_ELeaderboardAggregation Aggregation;
	/** The POSIX timestamp for the start time, or EOS_LEADERBOARDS_TIME_UNDEFINED. */
	int64_t StartTime;
	/** The POSIX timestamp for the end time, or EOS_LEADERBOARDS_TIME_UNDEFINED. */
	int64_t EndTime;
));

/** The most recent version of the EOS_Leaderboards_GetLeaderboardDefinitionCount API. */
#define EOS_LEADERBOARDS_GETLEADERBOARDDEFINITIONCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Leaderboards_GetLeaderboardDefinitionCount function.
 */
EOS_STRUCT(EOS_Leaderboards_GetLeaderboardDefinitionCountOptions, (
	/** API Version: Set this to EOS_LEADERBOARDS_GETLEADERBOARDDEFINITIONCOUNT_API_LATEST. */
	int32_t ApiVersion;
));

/** The most recent version of the EOS_Leaderboards_CopyLeaderboardDefinitionByIndexOptions struct. */
#define EOS_LEADERBOARDS_COPYLEADERBOARDDEFINITIONBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_Leaderboards_CopyLeaderboardDefinitionByIndex function.
 */
EOS_STRUCT(EOS_Leaderboards_CopyLeaderboardDefinitionByIndexOptions, (
	/** API Version: Set this to EOS_LEADERBOARDS_COPYLEADERBOARDDEFINITIONBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** Index of the leaderboard definition to retrieve from the cache */
	uint32_t LeaderboardIndex;
));

/** The most recent version of the EOS_Leaderboards_CopyLeaderboardDefinitionByLeaderboardIdOptions struct. */
#define EOS_LEADERBOARDS_COPYLEADERBOARDDEFINITIONBYLEADERBOARDID_API_LATEST 1

/**
 * Input parameters for the EOS_Leaderboards_CopyLeaderboardDefinitionByLeaderboardId function.
 */
EOS_STRUCT(EOS_Leaderboards_CopyLeaderboardDefinitionByLeaderboardIdOptions, (
	/** API Version: Set this to EOS_LEADERBOARDS_COPYLEADERBOARDDEFINITIONBYLEADERBOARDID_API_LATEST. */
	int32_t ApiVersion;
	/** The ID of the leaderboard whose definition you want to copy from the cache */
	const char* LeaderboardId;
));

/**
 * Release the memory associated with a leaderboard definition. This must be called on data retrieved from
 * EOS_Leaderboards_CopyLeaderboardDefinitionByIndex or EOS_Leaderboards_CopyLeaderboardDefinitionByLeaderboardId.
 *
 * @param LeaderboardDefinition - The Leaderboard definition to release.
 *
 * @see EOS_Leaderboards_Definition
 * @see EOS_Leaderboards_CopyLeaderboardDefinitionByIndex
 * @see EOS_Leaderboards_CopyLeaderboardDefinitionByLeaderboardId
 */
EOS_DECLARE_FUNC(void) EOS_Leaderboards_Definition_Release(EOS_Leaderboards_Definition* LeaderboardDefinition);

/**
 * Data containing the result information for a query leaderboard definitions request.
 */
EOS_STRUCT(EOS_Leaderboards_OnQueryLeaderboardDefinitionsCompleteCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Leaderboards_QueryLeaderboardDefinitions. */
	void* ClientData;
));

/**
 * Function prototype definition for callbacks passed to EOS_Leaderboards_QueryLeaderboardDefinitions
 * @param Data A EOS_Leaderboards_OnQueryLeaderboardDefinitionsCompleteCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Leaderboards_OnQueryLeaderboardDefinitionsCompleteCallback, const EOS_Leaderboards_OnQueryLeaderboardDefinitionsCompleteCallbackInfo* Data);


/** The most recent version of the EOS_Leaderboards_UserScoresQueryStatInfo struct. */
#define EOS_LEADERBOARDS_USERSCORESQUERYSTATINFO_API_LATEST 1

/**
 * Contains information about a single stat to query with user scores.
 */
EOS_STRUCT(EOS_Leaderboards_UserScoresQueryStatInfo, (
	/** API Version: Set this to EOS_LEADERBOARDS_USERSCORESQUERYSTATINFO_API_LATEST. */
	int32_t ApiVersion;
	/** The name of the stat to query. */
	const char* StatName;
	/** Aggregation used to sort the cached user scores. */
	EOS_ELeaderboardAggregation Aggregation;
));

/** The most recent version of the EOS_Leaderboards_QueryLeaderboardUserScores struct. */
#define EOS_LEADERBOARDS_QUERYLEADERBOARDUSERSCORES_API_LATEST 2

/**
 * Input parameters for the EOS_Leaderboards_QueryLeaderboardUserScores function.
 */
EOS_STRUCT(EOS_Leaderboards_QueryLeaderboardUserScoresOptions, (
	/** API Version: Set this to EOS_LEADERBOARDS_QUERYLEADERBOARDUSERSCORES_API_LATEST. */
	int32_t ApiVersion;
	/** An array of Product User IDs indicating the users whose scores you want to retrieve */
	const EOS_ProductUserId* UserIds;
	/** The number of users included in query */
	uint32_t UserIdsCount;
	/** The stats to be collected, along with the sorting method to use when determining rank order for each stat */
	const EOS_Leaderboards_UserScoresQueryStatInfo* StatInfo;
	/** The number of stats to query */
	uint32_t StatInfoCount;
	/** An optional POSIX timestamp, or EOS_LEADERBOARDS_TIME_UNDEFINED; results will only include scores made after this time */
	int64_t StartTime;
	/** An optional POSIX timestamp, or EOS_LEADERBOARDS_TIME_UNDEFINED; results will only include scores made before this time */
	int64_t EndTime;
	/**
	 * Product User ID for user who is querying user scores.
	 * Must be set when using a client policy that requires a valid logged in user.
	 * Not used for Dedicated Server where no user is available.
	 */
	EOS_ProductUserId LocalUserId;
));

/** The most recent version of the EOS_Leaderboards_LeaderboardUserScore struct. */
#define EOS_LEADERBOARDS_LEADERBOARDUSERSCORE_API_LATEST 1

/**
 * Contains information about a single leaderboard user score
 */
EOS_STRUCT(EOS_Leaderboards_LeaderboardUserScore, (
	/** API Version: Set this to EOS_LEADERBOARDS_LEADERBOARDUSERSCORE_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user who got this score */
	EOS_ProductUserId UserId;
	/** Leaderboard score */
	int32_t Score;
));

/** The most recent version of the EOS_Leaderboards_GetLeaderboardUserScoreCount API. */
#define EOS_LEADERBOARDS_GETLEADERBOARDUSERSCORECOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Leaderboards_GetLeaderboardUserScoreCount function.
 */
EOS_STRUCT(EOS_Leaderboards_GetLeaderboardUserScoreCountOptions, (
	/** API Version: Set this to EOS_LEADERBOARDS_GETLEADERBOARDUSERSCORECOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** Name of stat used to rank leaderboard. */
	const char* StatName;
));

/** The most recent version of the EOS_Leaderboards_CopyLeaderboardUserScoreByIndexOptions struct. */
#define EOS_LEADERBOARDS_COPYLEADERBOARDUSERSCOREBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_Leaderboards_CopyLeaderboardUserScoreByIndex function.
 */
EOS_STRUCT(EOS_Leaderboards_CopyLeaderboardUserScoreByIndexOptions, (
	/** API Version: Set this to EOS_LEADERBOARDS_COPYLEADERBOARDUSERSCOREBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** Index of the sorted leaderboard user score to retrieve from the cache. */
	uint32_t LeaderboardUserScoreIndex;
	/** Name of the stat used to rank the leaderboard. */
	const char* StatName;
));

/** The most recent version of the EOS_Leaderboards_CopyLeaderboardUserScoreByUserIdOptions struct. */
#define EOS_LEADERBOARDS_COPYLEADERBOARDUSERSCOREBYUSERID_API_LATEST 1

/**
 * Input parameters for the EOS_Leaderboards_CopyLeaderboardUserScoreByUserId function.
 */
EOS_STRUCT(EOS_Leaderboards_CopyLeaderboardUserScoreByUserIdOptions, (
	/** API Version: Set this to EOS_LEADERBOARDS_COPYLEADERBOARDUSERSCOREBYUSERID_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID to look for when copying leaderboard score data from the cache */
	EOS_ProductUserId UserId;
	/** The name of the stat that is used to rank this leaderboard */
	const char* StatName;
));

/**
 * Release the memory associated with leaderboard user score. This must be called on data retrieved from
 * EOS_Leaderboards_CopyLeaderboardUserScoreByIndex or EOS_Leaderboards_CopyLeaderboardUserScoreByUserId.
 *
 * @param LeaderboardUserScore - The Leaderboard user score to release.
 *
 * @see EOS_Leaderboards_LeaderboardUserScore
 * @see EOS_Leaderboards_CopyLeaderboardUserScoreByIndex
 * @see EOS_Leaderboards_CopyLeaderboardUserScoreByUserId
 */
EOS_DECLARE_FUNC(void) EOS_Leaderboards_LeaderboardUserScore_Release(EOS_Leaderboards_LeaderboardUserScore* LeaderboardUserScore);

/**
 * Data containing the result information for a query leaderboard user scores request.
 */
EOS_STRUCT(EOS_Leaderboards_OnQueryLeaderboardUserScoresCompleteCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Leaderboards_QueryLeaderboardUserScores. */
	void* ClientData;
));

/**
 * Function prototype definition for callbacks passed to EOS_Leaderboards_QueryLeaderboardUserScores
 * @param Data A EOS_Leaderboards_OnQueryLeaderboardUserScoresCompleteCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Leaderboards_OnQueryLeaderboardUserScoresCompleteCallback, const EOS_Leaderboards_OnQueryLeaderboardUserScoresCompleteCallbackInfo* Data);


/** The most recent version of the EOS_Leaderboards_QueryLeaderboardRanks struct. */
#define EOS_LEADERBOARDS_QUERYLEADERBOARDRANKS_API_LATEST 2

/**
 * Input parameters for the EOS_Leaderboards_QueryLeaderboardRanks function.
 *
 * @see EOS_Leaderboards_Definition
 */
EOS_STRUCT(EOS_Leaderboards_QueryLeaderboardRanksOptions, (
	/** API Version: Set this to EOS_LEADERBOARDS_QUERYLEADERBOARDRANKS_API_LATEST. */
	int32_t ApiVersion;
	/** The ID of the leaderboard whose information you want to retrieve. */
	const char* LeaderboardId;
	/**
	 * Product User ID for user who is querying ranks.
	 * Must be set when using a client policy that requires a valid logged in user.
	 * Not used for Dedicated Server where no user is available.
	 */
	EOS_ProductUserId LocalUserId;
));

/** The most recent version of the EOS_Leaderboards_LeaderboardRecord struct. */
#define EOS_LEADERBOARDS_LEADERBOARDRECORD_API_LATEST 2

/**
 * Contains information about a single leaderboard record
 */
EOS_STRUCT(EOS_Leaderboards_LeaderboardRecord, (
	/** API Version: Set this to EOS_LEADERBOARDS_LEADERBOARDRECORD_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID assoicated with this record */
	EOS_ProductUserId UserId;
	/** Sorted position on leaderboard */
	uint32_t Rank;
	/** Leaderboard score */
	int32_t Score;
	/** The latest display name seen for the user since they last time logged in. This is empty if the user does not have a display name set. */
	const char* UserDisplayName;
));

/** The most recent version of the EOS_Leaderboards_GetLeaderboardRecordCount API. */
#define EOS_LEADERBOARDS_GETLEADERBOARDRECORDCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Leaderboards_GetLeaderboardRecordCount function.
 */
EOS_STRUCT(EOS_Leaderboards_GetLeaderboardRecordCountOptions, (
	/** API Version: Set this to EOS_LEADERBOARDS_GETLEADERBOARDRECORDCOUNT_API_LATEST. */
	int32_t ApiVersion;
));

/** The most recent version of the EOS_Leaderboards_CopyLeaderboardRecordByIndexOptions struct. */
#define EOS_LEADERBOARDS_COPYLEADERBOARDRECORDBYINDEX_API_LATEST 2

/**
 * Input parameters for the EOS_Leaderboards_CopyLeaderboardRecordByIndex function.
 */
EOS_STRUCT(EOS_Leaderboards_CopyLeaderboardRecordByIndexOptions, (
	/** API Version: Set this to EOS_LEADERBOARDS_COPYLEADERBOARDRECORDBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** Index of the leaderboard record to retrieve from the cache */
	uint32_t LeaderboardRecordIndex;
));

/** The most recent version of the EOS_Leaderboards_CopyLeaderboardRecordByUserIdOptions struct. */
#define EOS_LEADERBOARDS_COPYLEADERBOARDRECORDBYUSERID_API_LATEST 2

/**
 * Input parameters for the EOS_Leaderboards_CopyLeaderboardRecordByUserId function.
 */
EOS_STRUCT(EOS_Leaderboards_CopyLeaderboardRecordByUserIdOptions, (
	/** API Version: Set this to EOS_LEADERBOARDS_COPYLEADERBOARDRECORDBYUSERID_API_LATEST. */
	int32_t ApiVersion;
	/** Leaderboard data will be copied from the cache if it relates to the user matching this Product User ID */
	EOS_ProductUserId UserId;
));

/**
 * Release the memory associated with leaderboard record. This must be called on data retrieved from
 * EOS_Leaderboards_CopyLeaderboardRecordByIndex or EOS_Leaderboards_CopyLeaderboardRecordByUserId.
 *
 * @param LeaderboardRecord - The Leaderboard record to release.
 *
 * @see EOS_Leaderboards_LeaderboardRecord
 * @see EOS_Leaderboards_CopyLeaderboardRecordByIndex
 * @see EOS_Leaderboards_CopyLeaderboardRecordByUserId
 */
EOS_DECLARE_FUNC(void) EOS_Leaderboards_LeaderboardRecord_Release(EOS_Leaderboards_LeaderboardRecord* LeaderboardRecord);

/**
 * Data containing the result information for a query leaderboard ranks request.
 */
EOS_STRUCT(EOS_Leaderboards_OnQueryLeaderboardRanksCompleteCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Leaderboards_QueryLeaderboardRanks. */
	void* ClientData;
));

/**
 * Function prototype definition for callbacks passed to EOS_Leaderboards_QueryLeaderboardRanks
 * @param Data A EOS_Leaderboards_OnQueryLeaderboardRanksCompleteCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Leaderboards_OnQueryLeaderboardRanksCompleteCallback, const EOS_Leaderboards_OnQueryLeaderboardRanksCompleteCallbackInfo* Data);

#pragma pack(pop)

#include "eos_leaderboards_types_deprecated.inl"
```

`eac/sdk/Include/eos_leaderboards_types_deprecated.inl`:

```inl
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"

/*
 * This file contains the deprecated types for EOS Leaderboards. In a future version, these types will be removed.
 */

#pragma pack(push, 8)

/* Do not use. Alias to the previous API name for backwards compatibility in compilation. */
EOS_DECLARE_FUNC(void) EOS_Leaderboards_LeaderboardDefinition_Release(EOS_Leaderboards_Definition* LeaderboardDefinition);

#pragma pack(pop)

```

`eac/sdk/Include/eos_lobby.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_lobby_types.h"

/**
 * The Lobby Interface is used to manage lobbies that provide a persistent connection between users and 
 * notifications of data sharing/updates.  Lobbies may also be found by advertising and searching with the backend service.
 * All Lobby Interface calls take a handle of type EOS_HLobby as the first parameter.
 * This handle can be retrieved from an EOS_HPlatform handle by using the EOS_Platform_GetLobbyInterface function.
 *
 * @see EOS_Platform_GetLobbyInterface
 */

/**
 * Creates a lobby and adds the user to the lobby membership.  There is no data associated with the lobby at the start and can be added vis EOS_Lobby_UpdateLobbyModification
 *
 * If the lobby is successfully created with an RTC Room enabled, the lobby system will automatically join and maintain the connection to the RTC room as long as the
 * local user remains in the lobby. Applications can use the EOS_Lobby_GetRTCRoomName to get the name of the RTC Room associated with a lobby, which may be used with
 * many of the EOS_RTC_* suite of functions. This can be useful to: register for notifications for talking status; to mute or unmute the local user's audio output;
 * to block or unblock room participants; to set local audio device settings; and more.
 *
 * @param Options Required fields for the creation of a lobby such as a user count and its starting advertised state
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the create operation completes, either successfully or in error
 *
 * @return EOS_Success if the creation completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_LimitExceeded if the number of allowed lobbies is exceeded
 */
EOS_DECLARE_FUNC(void) EOS_Lobby_CreateLobby(EOS_HLobby Handle, const EOS_Lobby_CreateLobbyOptions* Options, void* ClientData, const EOS_Lobby_OnCreateLobbyCallback CompletionDelegate);

/**
 * Destroy a lobby given a lobby ID
 *
 * @param Options Structure containing information about the lobby to be destroyed
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the destroy operation completes, either successfully or in error
 *
 * @return EOS_Success if the destroy completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_AlreadyPending if the lobby is already marked for destroy
 *         EOS_NotFound if the lobby to be destroyed does not exist
 */
EOS_DECLARE_FUNC(void) EOS_Lobby_DestroyLobby(EOS_HLobby Handle, const EOS_Lobby_DestroyLobbyOptions* Options, void* ClientData, const EOS_Lobby_OnDestroyLobbyCallback CompletionDelegate);

/**
 * Join a lobby, creating a local instance under a given lobby ID.  Backend will validate various conditions to make sure it is possible to join the lobby.
 *
 * If the lobby is successfully join has an RTC Room enabled, the lobby system will automatically join and maintain the connection to the RTC room as long as the
 * local user remains in the lobby. Applications can use the EOS_Lobby_GetRTCRoomName to get the name of the RTC Room associated with a lobby, which may be used with
 * many of the EOS_RTC_* suite of functions. This can be useful to: register for notifications for talking status; to mute or unmute the local user's audio output;
 * to block or unblock room participants; to set local audio device settings; and more.
 *
 * @param Options Structure containing information about the lobby to be joined
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the join operation completes, either successfully or in error
 *
 * @return EOS_Success if the destroy completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 */
EOS_DECLARE_FUNC(void) EOS_Lobby_JoinLobby(EOS_HLobby Handle, const EOS_Lobby_JoinLobbyOptions* Options, void* ClientData, const EOS_Lobby_OnJoinLobbyCallback CompletionDelegate);

/**
 * Leave a lobby given a lobby ID
 *
 * If the lobby you are leaving had an RTC Room enabled, leaving the lobby will also automatically leave the RTC room.
 *
 * @param Options Structure containing information about the lobby to be left
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the leave operation completes, either successfully or in error
 *
 * @return EOS_Success if the leave completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_AlreadyPending if the lobby is already marked for leave
 *         EOS_NotFound if a lobby to be left does not exist
 */
EOS_DECLARE_FUNC(void) EOS_Lobby_LeaveLobby(EOS_HLobby Handle, const EOS_Lobby_LeaveLobbyOptions* Options, void* ClientData, const EOS_Lobby_OnLeaveLobbyCallback CompletionDelegate);

/**
 * Creates a lobby modification handle (EOS_HLobbyModification). The lobby modification handle is used to modify an existing lobby and can be applied with EOS_Lobby_UpdateLobby.
 * The EOS_HLobbyModification must be released by calling EOS_LobbyModification_Release once it is no longer needed.
 *
 * @param Options Required fields such as lobby ID
 * @param OutLobbyModificationHandle Pointer to a Lobby Modification Handle only set if successful
 * @return EOS_Success if we successfully created the Lobby Modification Handle pointed at in OutLobbyModificationHandle, or an error result if the input data was invalid
 *		   EOS_InvalidParameters if any of the options are incorrect
 *
 * @see EOS_LobbyModification_Release
 * @see EOS_Lobby_UpdateLobby
 * @see EOS_HLobbyModification
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Lobby_UpdateLobbyModification(EOS_HLobby Handle, const EOS_Lobby_UpdateLobbyModificationOptions* Options, EOS_HLobbyModification* OutLobbyModificationHandle);

/**
 * Update a lobby given a lobby modification handle created by EOS_Lobby_UpdateLobbyModification
 *
 * @param Options Structure containing information about the lobby to be updated
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the update operation completes, either successfully or in error
 *
 * @return EOS_Success if the update completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_Lobby_NotOwner if the lobby modification contains modifications that are only allowed by the owner
 *         EOS_NotFound if the lobby to update does not exist
 */
EOS_DECLARE_FUNC(void) EOS_Lobby_UpdateLobby(EOS_HLobby Handle, const EOS_Lobby_UpdateLobbyOptions* Options, void* ClientData, const EOS_Lobby_OnUpdateLobbyCallback CompletionDelegate);

/**
 * Promote an existing member of the lobby to owner, allowing them to make lobby data modifications
 *
 * @param Options Structure containing information about the lobby and member to be promoted
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the promotion operation completes, either successfully or in error
 *
 * @return EOS_Success if the promote completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_Lobby_NotOwner if the calling user is not the owner of the lobby
 *         EOS_NotFound if the lobby of interest does not exist
 */
EOS_DECLARE_FUNC(void) EOS_Lobby_PromoteMember(EOS_HLobby Handle, const EOS_Lobby_PromoteMemberOptions* Options, void* ClientData, const EOS_Lobby_OnPromoteMemberCallback CompletionDelegate);

/**
 * Kick an existing member from the lobby
 *
 * @param Options Structure containing information about the lobby and member to be kicked
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the kick operation completes, either successfully or in error
 *
 * @return EOS_Success if the kick completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_Lobby_NotOwner if the calling user is not the owner of the lobby
 *         EOS_NotFound if a lobby of interest does not exist
 */
EOS_DECLARE_FUNC(void) EOS_Lobby_KickMember(EOS_HLobby Handle, const EOS_Lobby_KickMemberOptions* Options, void* ClientData, const EOS_Lobby_OnKickMemberCallback CompletionDelegate);

/**
 * Register to receive notifications when a lobby owner updates the attributes associated with the lobby.
 * @note must call RemoveNotifyLobbyUpdateReceived to remove the notification
 *
 * @param Options Structure containing information about the request.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param NotificationFn A callback that is fired when a a notification is received.
 *
 * @return handle representing the registered callback
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_Lobby_AddNotifyLobbyUpdateReceived(EOS_HLobby Handle, const EOS_Lobby_AddNotifyLobbyUpdateReceivedOptions* Options, void* ClientData, const EOS_Lobby_OnLobbyUpdateReceivedCallback NotificationFn);

/**
 * Unregister from receiving notifications when a lobby changes its data.
 *
 * @param InId Handle representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_Lobby_RemoveNotifyLobbyUpdateReceived(EOS_HLobby Handle, EOS_NotificationId InId);

/**
 * Register to receive notifications when a lobby member updates the attributes associated with themselves inside the lobby.
 * @note must call RemoveNotifyLobbyMemberUpdateReceived to remove the notification
 *
 * @param Options Structure containing information about the request.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param NotificationFn A callback that is fired when a a notification is received.
 *
 * @return handle representing the registered callback
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_Lobby_AddNotifyLobbyMemberUpdateReceived(EOS_HLobby Handle, const EOS_Lobby_AddNotifyLobbyMemberUpdateReceivedOptions* Options, void* ClientData, const EOS_Lobby_OnLobbyMemberUpdateReceivedCallback NotificationFn);

/**
 * Unregister from receiving notifications when lobby members change their data.
 *
 * @param InId Handle representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_Lobby_RemoveNotifyLobbyMemberUpdateReceived(EOS_HLobby Handle, EOS_NotificationId InId);

/**
 * Register to receive notifications about the changing status of lobby members.
 * @note must call RemoveNotifyLobbyMemberStatusReceived to remove the notification
 *
 * @param Options Structure containing information about the request.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param NotificationFn A callback that is fired when a a notification is received.
 *
 * @return handle representing the registered callback
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_Lobby_AddNotifyLobbyMemberStatusReceived(EOS_HLobby Handle, const EOS_Lobby_AddNotifyLobbyMemberStatusReceivedOptions* Options, void* ClientData, const EOS_Lobby_OnLobbyMemberStatusReceivedCallback NotificationFn);

/**
 * Unregister from receiving notifications when lobby members status change.
 *
 * @param InId Handle representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_Lobby_RemoveNotifyLobbyMemberStatusReceived(EOS_HLobby Handle, EOS_NotificationId InId);

/**
 * Send an invite to another user.  User must be a member of the lobby or else the call will fail
 *
 * @param Options Structure containing information about the lobby and user to invite
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the send invite operation completes, either successfully or in error
 *
 * @return EOS_Success if the send invite completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_NotFound if the lobby to send the invite from does not exist
 */
EOS_DECLARE_FUNC(void) EOS_Lobby_SendInvite(EOS_HLobby Handle, const EOS_Lobby_SendInviteOptions* Options, void* ClientData, const EOS_Lobby_OnSendInviteCallback CompletionDelegate);

/**
 * Reject an invite from another user.
 *
 * @param Options Structure containing information about the invite to reject
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the reject invite operation completes, either successfully or in error
 *
 * @return EOS_Success if the invite rejection completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_NotFound if the invite does not exist
 */
EOS_DECLARE_FUNC(void) EOS_Lobby_RejectInvite(EOS_HLobby Handle, const EOS_Lobby_RejectInviteOptions* Options, void* ClientData, const EOS_Lobby_OnRejectInviteCallback CompletionDelegate);

/**
 * Retrieve all existing invites for a single user
 *
 * @param Options Structure containing information about the invites to query
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the query invites operation completes, either successfully or in error
 *
 */
EOS_DECLARE_FUNC(void) EOS_Lobby_QueryInvites(EOS_HLobby Handle, const EOS_Lobby_QueryInvitesOptions* Options, void* ClientData, const EOS_Lobby_OnQueryInvitesCallback CompletionDelegate);

/**
 * Get the number of known invites for a given user
 *
 * @param Options the Options associated with retrieving the current invite count
 *
 * @return number of known invites for a given user or 0 if there is an error
 */
EOS_DECLARE_FUNC(uint32_t) EOS_Lobby_GetInviteCount(EOS_HLobby Handle, const EOS_Lobby_GetInviteCountOptions* Options);

/**
 * Retrieve an invite ID from a list of active invites for a given user
 *
 * @param Options Structure containing the input parameters
 *
 * @return EOS_Success if the input is valid and an invite ID was returned
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_NotFound if the invite doesn't exist
 *
 * @see EOS_Lobby_GetInviteCount
 * @see EOS_Lobby_CopyLobbyDetailsHandleByInviteId
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Lobby_GetInviteIdByIndex(EOS_HLobby Handle, const EOS_Lobby_GetInviteIdByIndexOptions* Options, char* OutBuffer, int32_t* InOutBufferLength);

/**
 * Create a lobby search handle.  This handle may be modified to include various search parameters.
 * Searching is possible in three methods, all mutually exclusive
 * - set the lobby ID to find a specific lobby
 * - set the target user ID to find a specific user
 * - set lobby parameters to find an array of lobbies that match the search criteria (not available yet)
 *
 * @param Options Structure containing required parameters such as the maximum number of search results
 * @param OutLobbySearchHandle The new search handle or null if there was an error creating the search handle
 *
 * @return EOS_Success if the search creation completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Lobby_CreateLobbySearch(EOS_HLobby Handle, const EOS_Lobby_CreateLobbySearchOptions* Options, EOS_HLobbySearch* OutLobbySearchHandle);

/**
 * Register to receive notifications about lobby invites sent to local users.
 * @note must call RemoveNotifyLobbyInviteReceived to remove the notification
 *
 * @param Options Structure containing information about the request.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param NotificationFn A callback that is fired when a a notification is received.
 *
 * @return handle representing the registered callback
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_Lobby_AddNotifyLobbyInviteReceived(EOS_HLobby Handle, const EOS_Lobby_AddNotifyLobbyInviteReceivedOptions* Options, void* ClientData, const EOS_Lobby_OnLobbyInviteReceivedCallback NotificationFn);

/**
 * Unregister from receiving notifications when a user receives a lobby invitation.
 *
 * @param InId Handle representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_Lobby_RemoveNotifyLobbyInviteReceived(EOS_HLobby Handle, EOS_NotificationId InId);

/**
 * Register to receive notifications about lobby invites accepted by local user via the overlay.
 * @note must call RemoveNotifyLobbyInviteAccepted to remove the notification
 *
 * @param Options Structure containing information about the request.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param NotificationFn A callback that is fired when a a notification is received.
 *
 * @return handle representing the registered callback
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_Lobby_AddNotifyLobbyInviteAccepted(EOS_HLobby Handle, const EOS_Lobby_AddNotifyLobbyInviteAcceptedOptions* Options, void* ClientData, const EOS_Lobby_OnLobbyInviteAcceptedCallback NotificationFn);

/**
 * Unregister from receiving notifications when a user accepts a lobby invitation via the overlay.
 *
 * @param InId Handle representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_Lobby_RemoveNotifyLobbyInviteAccepted(EOS_HLobby Handle, EOS_NotificationId InId);

/**
 * Register to receive notifications about lobby join game accepted by local user via the overlay.
 * @note must call EOS_Lobby_RemoveNotifyJoinLobbyAccepted to remove the notification
 *
 * @param Options Structure containing information about the request.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param NotificationFn A callback that is fired when a notification is received.
 *
 * @return handle representing the registered callback
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_Lobby_AddNotifyJoinLobbyAccepted(EOS_HLobby Handle, const EOS_Lobby_AddNotifyJoinLobbyAcceptedOptions* Options, void* ClientData, const EOS_Lobby_OnJoinLobbyAcceptedCallback NotificationFn);

/**
 * Unregister from receiving notifications when a user accepts a lobby invitation via the overlay.
 *
 * @param InId Handle representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_Lobby_RemoveNotifyJoinLobbyAccepted(EOS_HLobby Handle, EOS_NotificationId InId);

/**
 * EOS_Lobby_CopyLobbyDetailsHandleByInviteId is used to immediately retrieve a handle to the lobby information from after notification of an invite
 * If the call returns an EOS_Success result, the out parameter, OutLobbyDetailsHandle, must be passed to EOS_LobbyDetails_Release to release the memory associated with it.
 *
 * @param Options Structure containing the input parameters
 * @param OutLobbyDetailsHandle out parameter used to receive the lobby handle
 *
 * @return EOS_Success if the information is available and passed out in OutLobbyDetailsHandle
 *         EOS_InvalidParameters if you pass an invalid invite ID or a null pointer for the out parameter
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *         EOS_NotFound If the invite ID cannot be found
 *
 * @see EOS_Lobby_CopyLobbyDetailsHandleByInviteIdOptions
 * @see EOS_LobbyDetails_Release
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Lobby_CopyLobbyDetailsHandleByInviteId(EOS_HLobby Handle, const EOS_Lobby_CopyLobbyDetailsHandleByInviteIdOptions* Options, EOS_HLobbyDetails* OutLobbyDetailsHandle);

/**
 * EOS_Lobby_CopyLobbyDetailsHandleByUiEventId is used to immediately retrieve a handle to the lobby information from after notification of an join game
 * If the call returns an EOS_Success result, the out parameter, OutLobbyDetailsHandle, must be passed to EOS_LobbyDetails_Release to release the memory associated with it.
 *
 * @param Options Structure containing the input parameters
 * @param OutLobbyDetailsHandle out parameter used to receive the lobby handle
 *
 * @return EOS_Success if the information is available and passed out in OutLobbyDetailsHandle
 *         EOS_InvalidParameters if you pass an invalid ui event ID
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *         EOS_NotFound If the invite ID cannot be found
 *
 * @see EOS_Lobby_CopyLobbyDetailsHandleByUiEventIdOptions
 * @see EOS_LobbyDetails_Release
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Lobby_CopyLobbyDetailsHandleByUiEventId(EOS_HLobby Handle, const EOS_Lobby_CopyLobbyDetailsHandleByUiEventIdOptions* Options, EOS_HLobbyDetails* OutLobbyDetailsHandle);

/**
 * Create a handle to an existing lobby.
 * If the call returns an EOS_Success result, the out parameter, OutLobbyDetailsHandle, must be passed to EOS_LobbyDetails_Release to release the memory associated with it.
 *
 * @param Options Structure containing information about the lobby to retrieve
 * @param OutLobbyDetailsHandle The new active lobby handle or null if there was an error
 *
 * @return EOS_Success if the lobby handle was created successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *         EOS_NotFound if the lobby doesn't exist
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Lobby_CopyLobbyDetailsHandle(EOS_HLobby Handle, const EOS_Lobby_CopyLobbyDetailsHandleOptions* Options, EOS_HLobbyDetails* OutLobbyDetailsHandle);

/**
 * Get the name of the RTC room associated with a specific lobby a local user belongs to.
 *
 * This value can be used whenever you need a RoomName value in the RTC_* suite of functions. RTC Room Names must not be used with
 * EOS_RTC_JoinRoom, EOS_RTC_LeaveRoom, or EOS_RTC_AddNotifyDisconnected. Doing so will return EOS_AccessDenied or
 * EOS_INVALID_NOTIFICATIONID if used with those functions.
 *
 * This function will only succeed when called on a lobby the local user is currently a member of.
 *
 * @param Options Structure containing information about the RTC room name to retrieve
 * @param OutBuffer The buffer to store the null-terminated room name string within
 * @param InOutBufferLength In: The maximum amount of writable chars in OutBuffer, Out: The minimum amount of chars needed in OutBuffer to store the RTC room name (including the null-terminator)
 *
 * @return EOS_Success if a room exists for the specified lobby, there was enough space in OutBuffer, and the name was written successfully
 *         EOS_NotFound if the lobby does not exist
 *         EOS_Disabled if the lobby exists, but did not have the RTC Room feature enabled when created
 *         EOS_InvalidParameters if you pass a null pointer on invalid length for any of the parameters
 *         EOS_LimitExceeded The OutBuffer is not large enough to receive the room name. InOutBufferLength contains the required minimum length to perform the operation successfully.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Lobby_GetRTCRoomName(EOS_HLobby Handle, const EOS_Lobby_GetRTCRoomNameOptions* Options, char* OutBuffer, uint32_t* InOutBufferLength);

/**
 * Get the current connection status of the RTC Room for a lobby.
 *
 * The RTC Room connection status is independent of the lobby connection status, however the lobby system will attempt to keep
 * them consistent, automatically connecting to the RTC room after joining a lobby which has an associated RTC room and disconnecting
 * from the RTC room when a lobby is left or disconnected.
 *
 * This function will only succeed when called on a lobby the local user is currently a member of.
 *
 * @param Options Structure containing information about the lobby to query the RTC Room connection status for
 * @param bOutIsConnected If the result is EOS_Success, this will be set to EOS_TRUE if we are connected, or EOS_FALSE if we are not yet connected.
 *
 * @return EOS_Success if we are connected to the specified lobby, the input options and parameters were valid and we were able to write to bOutIsConnected successfully.
 *         EOS_NotFound if the lobby doesn't exist
 *         EOS_Disabled if the lobby exists, but did not have the RTC Room feature enabled when created
 *         EOS_InvalidParameters if bOutIsConnected is NULL, or any other parameters are NULL or invalid
 *
 * @see EOS_Lobby_AddNotifyRTCRoomConnectionChanged
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Lobby_IsRTCRoomConnected(EOS_HLobby Handle, const EOS_Lobby_IsRTCRoomConnectedOptions* Options, EOS_Bool* bOutIsConnected);

/**
 * Register to receive notifications of when the RTC Room for a particular lobby has a connection status change.
 *
 * The RTC Room connection status is independent of the lobby connection status, however the lobby system will attempt to keep
 * them consistent, automatically connecting to the RTC room after joining a lobby which has an associated RTC room and disconnecting
 * from the RTC room when a lobby is left or disconnected.
 *
 * This notification is entirely informational and requires no action in response by the application. If the connected status is offline
 * (bIsConnected is EOS_FALSE), the connection will automatically attempt to reconnect. The purpose of this notification is to allow
 * applications to show the current connection status of the RTC room when the connection is not established.
 *
 * Unlike EOS_RTC_AddNotifyDisconnected, EOS_RTC_LeaveRoom should not be called when the RTC room is disconnected.
 *
 * This function will only succeed when called on a lobby the local user is currently a member of.
 *
 * @param Options Structure containing information about the lobby to receive updates about
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param NotificationFn The function to call if the RTC Room's connection status changes
 *
 * @return A valid notification ID if the NotificationFn was successfully registered, or EOS_INVALID_NOTIFICATIONID if the input was invalid, the lobby did not exist, or the lobby did not have an RTC room.
 *
 * @see EOS_Lobby_RemoveNotifyRTCRoomConnectionChanged
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_Lobby_AddNotifyRTCRoomConnectionChanged(EOS_HLobby Handle, const EOS_Lobby_AddNotifyRTCRoomConnectionChangedOptions* Options, void* ClientData, const EOS_Lobby_OnRTCRoomConnectionChangedCallback NotificationFn);

/**
 * Unregister from receiving notifications when an RTC Room's connection status changes.
 *
 * This should be called when the local user is leaving a lobby.
 *
 * @param InId Handle representing the registered callback
 *
 * @see EOS_Lobby_AddNotifyRTCRoomConnectionChanged
 */
EOS_DECLARE_FUNC(void) EOS_Lobby_RemoveNotifyRTCRoomConnectionChanged(EOS_HLobby Handle, EOS_NotificationId InId);

/**
 * To modify lobbies or the lobby member data, you must call EOS_Lobby_UpdateLobbyModification to create a Lobby Modification handle. To modify that handle, call
 * EOS_HLobbyModification methods. Once you are finished, call EOS_Lobby_UpdateLobby with your handle. You must then release your Lobby Modification
 * handle by calling EOS_LobbyModification_Release.
 */

/**
 * Set the bucket ID associated with this lobby.
 * Values such as region, game mode, etc can be combined here depending on game need.
 * Setting this is strongly recommended to improve search performance.
 *
 * @param Options Options associated with the bucket ID of the lobby
 *
 * @return EOS_Success if setting this parameter was successful
 *         EOS_InvalidParameters if the bucket ID is invalid or null
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_LobbyModification_SetBucketId(EOS_HLobbyModification Handle, const EOS_LobbyModification_SetBucketIdOptions* Options);

/**
 * Set the permissions associated with this lobby.
 * The permissions range from "public" to "invite only" and are described by EOS_ELobbyPermissionLevel
 *
 * @param Options Options associated with the permission level of the lobby
 *
 * @return EOS_Success if setting this parameter was successful
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_LobbyModification_SetPermissionLevel(EOS_HLobbyModification Handle, const EOS_LobbyModification_SetPermissionLevelOptions* Options);

/**
 * Set the maximum number of members allowed in this lobby.
 * When updating the lobby, it is not possible to reduce this number below the current number of existing members
 *
 * @param Options Options associated with max number of members in this lobby
 *
 * @return EOS_Success if setting this parameter was successful
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_LobbyModification_SetMaxMembers(EOS_HLobbyModification Handle, const EOS_LobbyModification_SetMaxMembersOptions* Options);

/**
 * Allows enabling or disabling invites for this lobby.
 * The lobby will also need to have `bPresenceEnabled` true.
 *
 * @param Options Options associated with invites allowed flag for this lobby.
 *
 * @return EOS_Success if setting this parameter was successful
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_LobbyModification_SetInvitesAllowed(EOS_HLobbyModification Handle, const EOS_LobbyModification_SetInvitesAllowedOptions* Options);

/**
 * Associate an attribute with this lobby
 * An attribute is something may be public or private with the lobby.
 * If public, it can be queried for in a search, otherwise the data remains known only to lobby members
 *
 * @param Options Options to set the attribute and its visibility state
 *
 * @return EOS_Success if setting this parameter was successful
 *		   EOS_InvalidParameters if the attribute is missing information or otherwise invalid
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_LobbyModification_AddAttribute(EOS_HLobbyModification Handle, const EOS_LobbyModification_AddAttributeOptions* Options);

/**
 * Remove an attribute associated with the lobby
 *
 * @param Options Specify the key of the attribute to remove
 *
 * @return EOS_Success if removing this parameter was successful
 *		   EOS_InvalidParameters if the key is null or empty
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_LobbyModification_RemoveAttribute(EOS_HLobbyModification Handle, const EOS_LobbyModification_RemoveAttributeOptions* Options);

/**
 * Associate an attribute with a member of the lobby
 * Lobby member data is always private to the lobby
 *
 * @param Options Options to set the attribute and its visibility state
 *
 * @return EOS_Success if setting this parameter was successful
 *		   EOS_InvalidParameters if the attribute is missing information or otherwise invalid
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_LobbyModification_AddMemberAttribute(EOS_HLobbyModification Handle, const EOS_LobbyModification_AddMemberAttributeOptions* Options);

/**
 * Remove an attribute associated with of member of the lobby
 *
 * @param Options Specify the key of the member attribute to remove
 *
 * @return EOS_Success if removing this parameter was successful
 *		   EOS_InvalidParameters if the key is null or empty
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_LobbyModification_RemoveMemberAttribute(EOS_HLobbyModification Handle, const EOS_LobbyModification_RemoveMemberAttributeOptions* Options);

#include "eos_lobby_types.h"

/**
 * A "read only" representation of an existing lobby that games interact with externally.
 * Both the lobby and lobby search interfaces interface use this common class for lobby management and search results
 */

/**
 * Get the product user ID of the current owner for a given lobby
 *
 * @param Options Structure containing the input parameters
 *
 * @return the product user ID for the lobby owner or null if the input parameters are invalid
 */
EOS_DECLARE_FUNC(EOS_ProductUserId) EOS_LobbyDetails_GetLobbyOwner(EOS_HLobbyDetails Handle, const EOS_LobbyDetails_GetLobbyOwnerOptions* Options);

/**
 * EOS_LobbyDetails_CopyInfo is used to immediately retrieve a copy of lobby information from a given source such as a existing lobby or a search result.
 * If the call returns an EOS_Success result, the out parameter, OutLobbyDetailsInfo, must be passed to EOS_LobbyDetails_Info_Release to release the memory associated with it.
 *
 * @param Options Structure containing the input parameters
 * @param OutLobbyDetailsInfo Out parameter used to receive the EOS_LobbyDetails_Info structure.
 *
 * @return EOS_Success if the information is available and passed out in OutLobbyDetailsInfo
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *
 * @see EOS_LobbyDetails_Info
 * @see EOS_LobbyDetails_CopyInfoOptions
 * @see EOS_LobbyDetails_Info_Release
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_LobbyDetails_CopyInfo(EOS_HLobbyDetails Handle, const EOS_LobbyDetails_CopyInfoOptions* Options, EOS_LobbyDetails_Info ** OutLobbyDetailsInfo);

/**
 * Get the number of attributes associated with this lobby
 *
 * @param Options the Options associated with retrieving the attribute count
 *
 * @return number of attributes on the lobby or 0 if there is an error
 */
EOS_DECLARE_FUNC(uint32_t) EOS_LobbyDetails_GetAttributeCount(EOS_HLobbyDetails Handle, const EOS_LobbyDetails_GetAttributeCountOptions* Options);

/**
 * EOS_LobbyDetails_CopyAttributeByIndex is used to immediately retrieve a copy of a lobby attribute from a given source such as a existing lobby or a search result.
 * If the call returns an EOS_Success result, the out parameter, OutAttribute, must be passed to EOS_Lobby_Attribute_Release to release the memory associated with it.
 *
 * @param Options Structure containing the input parameters
 * @param OutAttribute Out parameter used to receive the EOS_Lobby_Attribute structure.
 *
 * @return EOS_Success if the information is available and passed out in OutAttribute
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *
 * @see EOS_Lobby_Attribute
 * @see EOS_LobbyDetails_CopyAttributeByIndexOptions
 * @see EOS_Lobby_Attribute_Release
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_LobbyDetails_CopyAttributeByIndex(EOS_HLobbyDetails Handle, const EOS_LobbyDetails_CopyAttributeByIndexOptions* Options, EOS_Lobby_Attribute ** OutAttribute);

/**
 * EOS_LobbyDetails_CopyAttributeByKey is used to immediately retrieve a copy of a lobby attribute from a given source such as a existing lobby or a search result.
 * If the call returns an EOS_Success result, the out parameter, OutAttribute, must be passed to EOS_Lobby_Attribute_Release to release the memory associated with it.
 *
 * @param Options Structure containing the input parameters
 * @param OutAttribute Out parameter used to receive the EOS_Lobby_Attribute structure.
 *
 * @return EOS_Success if the information is available and passed out in OutAttribute
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *
 * @see EOS_Lobby_Attribute
 * @see EOS_LobbyDetails_CopyAttributeByKeyOptions
 * @see EOS_Lobby_Attribute_Release
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_LobbyDetails_CopyAttributeByKey(EOS_HLobbyDetails Handle, const EOS_LobbyDetails_CopyAttributeByKeyOptions* Options, EOS_Lobby_Attribute ** OutAttribute);

/**
 * Get the number of members associated with this lobby
 *
 * @param Options the Options associated with retrieving the member count
 *
 * @return number of members in the existing lobby or 0 if there is an error
 */
EOS_DECLARE_FUNC(uint32_t) EOS_LobbyDetails_GetMemberCount(EOS_HLobbyDetails Handle, const EOS_LobbyDetails_GetMemberCountOptions* Options);

/**
 * EOS_LobbyDetails_GetMemberByIndex is used to immediately retrieve individual members registered with a lobby.
 *
 * @param Options Structure containing the input parameters
 *
 * @return the product user ID for the registered member at a given index or null if that index is invalid
 *
 * @see EOS_LobbyDetails_GetMemberCount
 * @see EOS_LobbyDetails_GetMemberByIndexOptions
 */
EOS_DECLARE_FUNC(EOS_ProductUserId) EOS_LobbyDetails_GetMemberByIndex(EOS_HLobbyDetails Handle, const EOS_LobbyDetails_GetMemberByIndexOptions* Options);

/**
 * EOS_LobbyDetails_GetMemberAttributeCount is used to immediately retrieve the attribute count for members in a lobby.
 *
 * @param Options Structure containing the input parameters
 *
 * @return the number of attributes associated with a given lobby member or 0 if that member is invalid
 *
 * @see EOS_LobbyDetails_GetMemberCount
 * @see EOS_LobbyDetails_GetMemberAttributeCountOptions
 */
EOS_DECLARE_FUNC(uint32_t) EOS_LobbyDetails_GetMemberAttributeCount(EOS_HLobbyDetails Handle, const EOS_LobbyDetails_GetMemberAttributeCountOptions* Options);

/**
 * EOS_LobbyDetails_CopyMemberAttributeByIndex is used to immediately retrieve a copy of a lobby member attribute from an existing lobby.
 * If the call returns an EOS_Success result, the out parameter, OutAttribute, must be passed to EOS_Lobby_Attribute_Release to release the memory associated with it.
 *
 * @param Options Structure containing the input parameters
 * @param OutAttribute Out parameter used to receive the EOS_Lobby_Attribute structure.
 *
 * @return EOS_Success if the information is available and passed out in OutAttribute
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *
 * @see EOS_Lobby_Attribute
 * @see EOS_LobbyDetails_CopyMemberAttributeByIndexOptions
 * @see EOS_Lobby_Attribute_Release
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_LobbyDetails_CopyMemberAttributeByIndex(EOS_HLobbyDetails Handle, const EOS_LobbyDetails_CopyMemberAttributeByIndexOptions* Options, EOS_Lobby_Attribute ** OutAttribute);

/**
 * EOS_LobbyDetails_CopyMemberAttributeByKey is used to immediately retrieve a copy of a lobby member attribute from an existing lobby.
 * If the call returns an EOS_Success result, the out parameter, OutAttribute, must be passed to EOS_Lobby_Attribute_Release to release the memory associated with it.
 *
 * @param Options Structure containing the input parameters
 * @param OutAttribute Out parameter used to receive the EOS_Lobby_Attribute structure.
 *
 * @return EOS_Success if the information is available and passed out in OutAttribute
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *
 * @see EOS_Lobby_Attribute
 * @see EOS_LobbyDetails_CopyMemberAttributeByKeyOptions
 * @see EOS_Lobby_Attribute_Release
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_LobbyDetails_CopyMemberAttributeByKey(EOS_HLobbyDetails Handle, const EOS_LobbyDetails_CopyMemberAttributeByKeyOptions* Options, EOS_Lobby_Attribute ** OutAttribute);

#include "eos_lobby_types.h"

/**
 * Class responsible for the creation, setup, and execution of a search query.
 * Search parameters are defined, the query is executed and the search results are returned within this object
 */

/**
 * Find lobbies matching the search criteria setup via this lobby search handle.
 * When the operation completes, this handle will have the search results that can be parsed
 *
 * @param Options Structure containing information about the search criteria to use
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the search operation completes, either successfully or in error
 *
 * @return EOS_Success if the find operation completes successfully
 *         EOS_NotFound if searching for an individual lobby by lobby ID or target user ID returns no results
 *         EOS_InvalidParameters if any of the options are incorrect
 */
EOS_DECLARE_FUNC(void) EOS_LobbySearch_Find(EOS_HLobbySearch Handle, const EOS_LobbySearch_FindOptions* Options, void* ClientData, const EOS_LobbySearch_OnFindCallback CompletionDelegate);

/**
 * Set a lobby ID to find and will return at most one search result.  Setting TargetUserId or SearchParameters will result in EOS_LobbySearch_Find failing
 *
 * @param Options A specific lobby ID for which to search
 *
 * @return EOS_Success if setting this lobby ID was successful
 *         EOS_InvalidParameters if the lobby ID is invalid or null
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_LobbySearch_SetLobbyId(EOS_HLobbySearch Handle, const EOS_LobbySearch_SetLobbyIdOptions* Options);

/**
 * Set a target user ID to find.  Setting LobbyId or SearchParameters will result in EOS_LobbySearch_Find failing
 * @note a search result will only be found if this user is in a public lobby
 *
 * @param Options a specific target user ID to find
 *
 * @return EOS_Success if setting this target user ID was successful
 *         EOS_InvalidParameters if the target user ID is invalid or null
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_LobbySearch_SetTargetUserId(EOS_HLobbySearch Handle, const EOS_LobbySearch_SetTargetUserIdOptions* Options);

/**
 * Add a parameter to an array of search criteria combined via an implicit AND operator.  Setting LobbyId or TargetUserId will result in EOS_LobbySearch_Find failing
 *
 * @param Options a search parameter and its comparison op
 *
 * @return EOS_Success if setting this search parameter was successful
 *         EOS_InvalidParameters if the search criteria is invalid or null
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *
 * @see EOS_Lobby_AttributeData
 * @see EOS_EComparisonOp
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_LobbySearch_SetParameter(EOS_HLobbySearch Handle, const EOS_LobbySearch_SetParameterOptions* Options);

/**
 * Remove a parameter from the array of search criteria.
 *
 * @params Options a search parameter key name to remove
 *
 * @return EOS_Success if removing this search parameter was successful
 *         EOS_InvalidParameters if the search key is invalid or null
 *		   EOS_NotFound if the parameter was not a part of the search criteria
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_LobbySearch_RemoveParameter(EOS_HLobbySearch Handle, const EOS_LobbySearch_RemoveParameterOptions* Options);

/**
 * Set the maximum number of search results to return in the query, can't be more than EOS_LOBBY_MAX_SEARCH_RESULTS
 *
 * @param Options maximum number of search results to return in the query
 *
 * @return EOS_Success if setting the max results was successful
 *         EOS_InvalidParameters if the number of results requested is invalid
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_LobbySearch_SetMaxResults(EOS_HLobbySearch Handle, const EOS_LobbySearch_SetMaxResultsOptions* Options);

/**
 * Get the number of search results found by the search parameters in this search
 *
 * @param Options Options associated with the search count
 *
 * @return return the number of search results found by the query or 0 if search is not complete
 */
EOS_DECLARE_FUNC(uint32_t) EOS_LobbySearch_GetSearchResultCount(EOS_HLobbySearch Handle, const EOS_LobbySearch_GetSearchResultCountOptions* Options);

/**
 * EOS_LobbySearch_CopySearchResultByIndex is used to immediately retrieve a handle to the lobby information from a given search result.
 * If the call returns an EOS_Success result, the out parameter, OutLobbyDetailsHandle, must be passed to EOS_LobbyDetails_Release to release the memory associated with it.
 *
 * @param Options Structure containing the input parameters
 * @param OutLobbyDetailsHandle out parameter used to receive the lobby details handle
 *
 * @return EOS_Success if the information is available and passed out in OutLobbyDetailsHandle
 *         EOS_InvalidParameters if you pass an invalid index or a null pointer for the out parameter
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *
 * @see EOS_LobbySearch_CopySearchResultByIndexOptions
 * @see EOS_LobbyDetails_Release
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_LobbySearch_CopySearchResultByIndex(EOS_HLobbySearch Handle, const EOS_LobbySearch_CopySearchResultByIndexOptions* Options, EOS_HLobbyDetails* OutLobbyDetailsHandle);

```

`eac/sdk/Include/eos_lobby_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_common.h"
#include "eos_ui_types.h"

#pragma pack(push, 8)

/** Handle to the lobby interface */
EXTERN_C typedef struct EOS_LobbyHandle* EOS_HLobby;
/** Handle to a lobby modification object */
EXTERN_C typedef struct EOS_LobbyModificationHandle* EOS_HLobbyModification;
/** Handle to a single lobby */
EXTERN_C typedef struct EOS_LobbyDetailsHandle* EOS_HLobbyDetails;
/** Handle to the calls responsible for creating a search object */
EXTERN_C typedef struct EOS_LobbySearchHandle* EOS_HLobbySearch;

EOS_DECLARE_FUNC(void) EOS_LobbyModification_Release(EOS_HLobbyModification LobbyModificationHandle);

/**
 * Release the memory associated with a single lobby. This must be called on data retrieved from EOS_LobbySearch_CopySearchResultByIndex.
 *
 * @param LobbyHandle - The lobby handle to release
 *
 * @see EOS_LobbySearch_CopySearchResultByIndex
 */
EOS_DECLARE_FUNC(void) EOS_LobbyDetails_Release(EOS_HLobbyDetails LobbyHandle);

/**
 * Release the memory associated with a lobby search. This must be called on data retrieved from EOS_Lobby_CreateLobbySearch.
 *
 * @param LobbySearchHandle - The lobby search handle to release
 *
 * @see EOS_Lobby_CreateLobbySearch
 */
EOS_DECLARE_FUNC(void) EOS_LobbySearch_Release(EOS_HLobbySearch LobbySearchHandle);

/** All lobbies are referenced by a unique lobby ID */
EXTERN_C typedef const char* EOS_LobbyId;

#define EOS_LOBBY_MAX_LOBBIES 16
#define EOS_LOBBY_MAX_LOBBY_MEMBERS 64
#define EOS_LOBBY_MAX_SEARCH_RESULTS 200

/** Minimum number of characters allowed in the lobby id override */
#define EOS_LOBBY_MIN_LOBBYIDOVERRIDE_LENGTH 4
/** Maximum number of characters allowed in the lobby id override */
#define EOS_LOBBY_MAX_LOBBYIDOVERRIDE_LENGTH 60

/** Maximum number of attributes allowed on the lobby */
#define EOS_LOBBYMODIFICATION_MAX_ATTRIBUTES 64
/** Maximum length of the name of the attribute associated with the lobby */
#define EOS_LOBBYMODIFICATION_MAX_ATTRIBUTE_LENGTH 64

/** Permission level gets more restrictive further down */
EOS_ENUM(EOS_ELobbyPermissionLevel,
	/** Anyone can find this lobby as long as it isn't full */
	EOS_LPL_PUBLICADVERTISED = 0,
	/** Players who have access to presence can see this lobby */
	EOS_LPL_JOINVIAPRESENCE = 1,
	/** Only players with invites registered can see this lobby */
	EOS_LPL_INVITEONLY = 2
);

/** Advertisement properties for a single attribute associated with a lobby */
EOS_ENUM(EOS_ELobbyAttributeVisibility,
	/** Data is visible outside the lobby */
	EOS_LAT_PUBLIC = 0,
	/** Only members in the lobby can see this data */
	EOS_LAT_PRIVATE = 1
);

/** Various types of lobby member updates */
EOS_ENUM(EOS_ELobbyMemberStatus,
	/** The user has joined the lobby */
	EOS_LMS_JOINED = 0,
	/** The user has explicitly left the lobby */
	EOS_LMS_LEFT = 1,
	/** The user has unexpectedly left the lobby */
	EOS_LMS_DISCONNECTED = 2,
	/** The user has been kicked from the lobby */
	EOS_LMS_KICKED = 3,
	/** The user has been promoted to lobby owner */
	EOS_LMS_PROMOTED = 4,
	/** The lobby has been closed and user has been removed */
	EOS_LMS_CLOSED = 5
);

#define EOS_LOBBYDETAILS_INFO_API_LATEST 1

EOS_STRUCT(EOS_LobbyDetails_Info, (
	/** API Version: Set this to EOS_LOBBYDETAILS_INFO_API_LATEST. */
	int32_t ApiVersion;
	/** Lobby ID */
	EOS_LobbyId LobbyId;
	/** The Product User ID of the current owner of the lobby */
	EOS_ProductUserId LobbyOwnerUserId;
	/** Permission level of the lobby */
	EOS_ELobbyPermissionLevel PermissionLevel;
	/** Current available space */
	uint32_t AvailableSlots;
	/** Max allowed members in the lobby */
	uint32_t MaxMembers;
	/** If true, users can invite others to this lobby */
	EOS_Bool bAllowInvites;
	/** The main indexed parameter for this lobby, can be any string (ie "Region:GameMode") */
	const char* BucketId;
	/** Is host migration allowed */
	EOS_Bool bAllowHostMigration;
	/** Was a Real-Time Communication (RTC) room enabled at lobby creation? */
	EOS_Bool bRTCRoomEnabled;
));

EOS_DECLARE_FUNC(void) EOS_LobbyDetails_Info_Release(EOS_LobbyDetails_Info* LobbyDetailsInfo);

/** The most recent version of the EOS_Lobby_LocalRTCOptions structure. */
#define EOS_LOBBY_LOCALRTCOPTIONS_API_LATEST 1

/**
 * Input parameters to use with Lobby RTC Rooms.
 */
EOS_STRUCT(EOS_Lobby_LocalRTCOptions, (
	/** API Version: Set this to EOS_LOBBY_LOCALRTCOPTIONS_API_LATEST. */
	int32_t ApiVersion;
	/** Flags for the local user in this room. The default is 0 if this struct is not specified. @see EOS_RTC_JoinRoomOptions::Flags */
	uint32_t Flags;
	/**
	 * Set to EOS_TRUE to enable Manual Audio Input. If manual audio input is enabled, audio recording is not started and the audio buffers
	 * must be passed manually using EOS_RTCAudio_SendAudio. The default is EOS_FALSE if this struct is not specified.
	 */
	EOS_Bool bUseManualAudioInput;
	/**
	 * Set to EOS_TRUE to enable Manual Audio Output. If manual audio output is enabled, audio rendering is not started and the audio buffers
	 * must be received with EOS_RTCAudio_AddNotifyAudioBeforeRender and rendered manually. The default is EOS_FALSE if this struct is not
	 * specified.
	 */
	EOS_Bool bUseManualAudioOutput;
	/**
	 * Set to EOS_TRUE to start the audio input device's stream as muted when first connecting to the RTC room.
	 *
	 * It must be manually unmuted with a call to EOS_RTCAudio_UpdateSending. If manual audio output is enabled, this value is ignored.
	 * The default value is EOS_FALSE if this struct is not specified.
	 */
	EOS_Bool bLocalAudioDeviceInputStartsMuted;
));

/** The most recent version of the EOS_Lobby_CreateLobby API. */
#define EOS_LOBBY_CREATELOBBY_API_LATEST 7

/**
 * Input parameters for the EOS_Lobby_CreateLobby function.
 */
EOS_STRUCT(EOS_Lobby_CreateLobbyOptions, (
	/** API Version: Set this to EOS_LOBBY_CREATELOBBY_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user creating the lobby; this user will automatically join the lobby as its owner */
	EOS_ProductUserId LocalUserId;
	/** The maximum number of users who can be in the lobby at a time */
	uint32_t MaxLobbyMembers;
	/** The initial permission level of the lobby */
	EOS_ELobbyPermissionLevel PermissionLevel;
	/** If true, this lobby will be associated with presence information. A user's presence can only be associated with one lobby at a time.
	 * This affects the ability of the Social Overlay to show game related actions to take in the user's social graph.
	 *
	 * @note The Social Overlay can handle only one of the following three options at a time:
	 * * using the bPresenceEnabled flags within the Sessions interface
	 * * using the bPresenceEnabled flags within the Lobby interface
	 * * using EOS_PresenceModification_SetJoinInfo
	 *
	 * @see EOS_PresenceModification_SetJoinInfoOptions
	 * @see EOS_Lobby_JoinLobbyOptions
	 * @see EOS_Sessions_CreateSessionModificationOptions
	 * @see EOS_Sessions_JoinSessionOptions
	 */
	EOS_Bool bPresenceEnabled;
	/** Are members of the lobby allowed to invite others */
	EOS_Bool bAllowInvites;
	/** Bucket ID associated with the lobby */
	const char* BucketId;
	/** 
	 * Is host migration allowed (will the lobby stay open if the original host leaves?) 
	 * NOTE: EOS_Lobby_PromoteMember is still allowed regardless of this setting 
	 */
	EOS_Bool bDisableHostMigration;
	/**
	 * Creates a real-time communication (RTC) room for all members of this lobby. All members of the lobby will automatically join the RTC
	 * room when they connect to the lobby and they will automatically leave the RTC room when they leave or are removed from the lobby.
	 * While the joining and leaving of the RTC room is automatic, applications will still need to use the EOS RTC interfaces to handle all
	 * other functionality for the room.
	 *
	 * @see EOS_Lobby_GetRTCRoomName
	 * @see EOS_Lobby_AddNotifyRTCRoomConnectionChanged
	 */
	EOS_Bool bEnableRTCRoom;
	/**
	 * (Optional) Allows the local application to set local audio options for the RTC Room if it is enabled. Set this to NULL if the RTC
	 * RTC room is disabled or you would like to use the defaults.
	 */
	const EOS_Lobby_LocalRTCOptions* LocalRTCOptions;
	/**
	 * (Optional) Set to a globally unique value to override the backend assignment
	 * If not specified the backend service will assign one to the lobby.  Do not mix and match override and non override settings.
	 * This value can be of size [EOS_LOBBY_MIN_LOBBYIDOVERRIDE_LENGTH, EOS_LOBBY_MAX_LOBBYIDOVERRIDE_LENGTH]
	 */
	const char* LobbyId;
));

/**
 * Output parameters for the EOS_Lobby_CreateLobby function.
 */
EOS_STRUCT(EOS_Lobby_CreateLobbyCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Lobby_CreateLobby */
	void* ClientData;
	/** The new lobby's ID */
	EOS_LobbyId LobbyId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Lobby_CreateLobby
 * @param Data A EOS_Lobby_CreateLobby CallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Lobby_OnCreateLobbyCallback, const EOS_Lobby_CreateLobbyCallbackInfo* Data);

/** The most recent version of the EOS_Lobby_DestroyLobby API. */
#define EOS_LOBBY_DESTROYLOBBY_API_LATEST 1

/**
 * Input parameters for the EOS_Lobby_DestroyLobby function.
 */
EOS_STRUCT(EOS_Lobby_DestroyLobbyOptions, (
	/** API Version: Set this to EOS_LOBBY_DESTROYLOBBY_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user requesting destruction of the lobby; this user must currently own the lobby */
	EOS_ProductUserId LocalUserId;
	/** The ID of the lobby to destroy */
	EOS_LobbyId LobbyId;
));

/**
 * Output parameters for the EOS_Lobby_DestroyLobby function.
 */
EOS_STRUCT(EOS_Lobby_DestroyLobbyCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Lobby_DestroyLobby */
	void* ClientData;
	/** The destroyed lobby's ID */
	EOS_LobbyId LobbyId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Lobby_DestroyLobby
 * @param Data A EOS_Lobby_DestroyLobby CallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Lobby_OnDestroyLobbyCallback, const EOS_Lobby_DestroyLobbyCallbackInfo* Data);


/** The most recent version of the EOS_Lobby_JoinLobby API. */
#define EOS_LOBBY_JOINLOBBY_API_LATEST 3

/**
 * Input parameters for the EOS_Lobby_JoinLobby function.
 */
EOS_STRUCT(EOS_Lobby_JoinLobbyOptions, (
	/** API Version: Set this to EOS_LOBBY_JOINLOBBY_API_LATEST. */
	int32_t ApiVersion;
	/** The handle of the lobby to join */
	EOS_HLobbyDetails LobbyDetailsHandle;
	/** The Product User ID of the local user joining the lobby */
	EOS_ProductUserId LocalUserId;
	/** If true, this lobby will be associated with the user's presence information. A user can only associate one lobby at a time with their presence information.
	 * This affects the ability of the Social Overlay to show game related actions to take in the user's social graph.
	 *
	 * @note The Social Overlay can handle only one of the following three options at a time:
	 * * using the bPresenceEnabled flags within the Sessions interface
	 * * using the bPresenceEnabled flags within the Lobby interface
	 * * using EOS_PresenceModification_SetJoinInfo
	 *
	 * @see EOS_PresenceModification_SetJoinInfoOptions
	 * @see EOS_Lobby_CreateLobbyOptions
	 * @see EOS_Lobby_JoinLobbyOptions
	 * @see EOS_Sessions_CreateSessionModificationOptions
	 * @see EOS_Sessions_JoinSessionOptions
	 */
	EOS_Bool bPresenceEnabled;
	/**
	 * (Optional) Set this value to override the default local options for the RTC Room, if it is enabled for this lobby. Set this to NULL if
	 * your application does not use the Lobby RTC Rooms feature, or if you would like to use the default settings. This option is ignored if
	 * the specified lobby does not have an RTC Room enabled and will not cause errors.
	 */
	const EOS_Lobby_LocalRTCOptions* LocalRTCOptions;
));

/**
 * Output parameters for the EOS_Lobby_JoinLobby function.
 */
EOS_STRUCT(EOS_Lobby_JoinLobbyCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Lobby_JoinLobby */
	void* ClientData;
	/** The ID of the lobby */
	EOS_LobbyId LobbyId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Lobby_JoinLobby
 * @param Data A EOS_Lobby_JoinLobby CallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Lobby_OnJoinLobbyCallback, const EOS_Lobby_JoinLobbyCallbackInfo* Data);

/** The most recent version of the EOS_Lobby_LeaveLobby API. */
#define EOS_LOBBY_LEAVELOBBY_API_LATEST 1

/**
 * Input parameters for the EOS_Lobby_LeaveLobby function.
 */
EOS_STRUCT(EOS_Lobby_LeaveLobbyOptions, (
	/** API Version: Set this to EOS_LOBBY_LEAVELOBBY_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user leaving the lobby */
	EOS_ProductUserId LocalUserId;
	/** The ID of the lobby */
	EOS_LobbyId LobbyId;
));

/**
 * Output parameters for the EOS_Lobby_LeaveLobby function.
 */
EOS_STRUCT(EOS_Lobby_LeaveLobbyCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Lobby_LeaveLobby */
	void* ClientData;
	/** The ID of the lobby */
	EOS_LobbyId LobbyId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Lobby_LeaveLobby
 * @param Data A EOS_Lobby_LeaveLobby CallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Lobby_OnLeaveLobbyCallback, const EOS_Lobby_LeaveLobbyCallbackInfo* Data);

/** The most recent version of the EOS_Lobby_UpdateLobbyModification API. */
#define EOS_LOBBY_UPDATELOBBYMODIFICATION_API_LATEST 1

/**
 * Input parameters for the EOS_Lobby_UpdateLobbyModification function.
 */
EOS_STRUCT(EOS_Lobby_UpdateLobbyModificationOptions, (
	/** API Version: Set this to EOS_LOBBY_UPDATELOBBYMODIFICATION_API_LATEST. */
	int32_t ApiVersion;
	/** The ID of the local user making modifications. Must be the owner to modify lobby data, but any lobby member can modify their own attributes. */
	EOS_ProductUserId LocalUserId;
	/** The ID of the lobby */
	EOS_LobbyId LobbyId;
));

/** The most recent version of the EOS_Lobby_UpdateLobby API. */
#define EOS_LOBBY_UPDATELOBBY_API_LATEST 1

/**
 * Input parameters for the EOS_Lobby_UpdateLobby function.
 */
EOS_STRUCT(EOS_Lobby_UpdateLobbyOptions, (
	/** API Version: Set this to EOS_LOBBY_UPDATELOBBY_API_LATEST. */
	int32_t ApiVersion;
	/** Builder handle */
	EOS_HLobbyModification LobbyModificationHandle;
));

/**
 * Output parameters for the EOS_Lobby_UpdateLobby function.
 */
EOS_STRUCT(EOS_Lobby_UpdateLobbyCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Lobby_UpdateLobby */
	void* ClientData;
	/** The ID of the lobby */
	EOS_LobbyId LobbyId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Lobby_UpdateLobby
 * @param Data A EOS_Lobby_UpdateLobby CallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Lobby_OnUpdateLobbyCallback, const EOS_Lobby_UpdateLobbyCallbackInfo* Data);

/** The most recent version of the EOS_Lobby_PromoteMember API. */
#define EOS_LOBBY_PROMOTEMEMBER_API_LATEST 1

/**
 * Input parameters for the EOS_Lobby_PromoteMember function.
 */
EOS_STRUCT(EOS_Lobby_PromoteMemberOptions, (
	/** API Version: Set this to EOS_LOBBY_PROMOTEMEMBER_API_LATEST. */
	int32_t ApiVersion;
	/** The ID of the lobby */
	EOS_LobbyId LobbyId;
	/** The Product User ID of the local user making the request */
	EOS_ProductUserId LocalUserId;
	/** The Product User ID of the member to promote to owner of the lobby */
	EOS_ProductUserId TargetUserId;
));

/**
 * Output parameters for the EOS_Lobby_PromoteMember function.
 */
EOS_STRUCT(EOS_Lobby_PromoteMemberCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Lobby_PromoteMember */
	void* ClientData;
	/** The ID of the lobby where the user was promoted */
	EOS_LobbyId LobbyId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Lobby_PromoteMember
 * @param Data A EOS_Lobby_PromoteMember CallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Lobby_OnPromoteMemberCallback, const EOS_Lobby_PromoteMemberCallbackInfo* Data);


/** The most recent version of the EOS_Lobby_KickMember API. */
#define EOS_LOBBY_KICKMEMBER_API_LATEST 1

/**
 * Input parameters for the EOS_Lobby_KickMember function.
 */
EOS_STRUCT(EOS_Lobby_KickMemberOptions, (
	/** API Version: Set this to EOS_LOBBY_KICKMEMBER_API_LATEST. */
	int32_t ApiVersion;
	/** The ID of the lobby */
	EOS_LobbyId LobbyId;
	/** The Product User ID of the local user requesting the removal; this user must be the lobby owner */
	EOS_ProductUserId LocalUserId;
	/** The Product User ID of the lobby member to remove */
	EOS_ProductUserId TargetUserId;
));

/**
 * Output parameters for the EOS_Lobby_KickMember function.
 */
EOS_STRUCT(EOS_Lobby_KickMemberCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Lobby_KickMember */
	void* ClientData;
	/** The ID of the lobby */
	EOS_LobbyId LobbyId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Lobby_KickMember
 * @param Data A EOS_Lobby_KickMember CallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Lobby_OnKickMemberCallback, const EOS_Lobby_KickMemberCallbackInfo* Data);

/** The most recent version of the EOS_Lobby_AddNotifyLobbyUpdateReceived API. */
#define EOS_LOBBY_ADDNOTIFYLOBBYUPDATERECEIVED_API_LATEST 1

EOS_STRUCT(EOS_Lobby_AddNotifyLobbyUpdateReceivedOptions, (
	/** API Version: Set this to EOS_LOBBY_ADDNOTIFYLOBBYUPDATERECEIVED_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_Lobby_OnLobbyUpdateReceivedCallback Function.
 */
EOS_STRUCT(EOS_Lobby_LobbyUpdateReceivedCallbackInfo, (
	/** Context that was passed into EOS_Lobby_AddNotifyLobbyUpdateReceived */
	void* ClientData;
	/** The ID of the lobby */
	EOS_LobbyId LobbyId;
));

/**
 * Function prototype definition for notifications that comes from EOS_Lobby_AddNotifyLobbyUpdateReceived
 *
 * @param Data A EOS_Lobby_LobbyUpdateReceivedCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Lobby_OnLobbyUpdateReceivedCallback, const EOS_Lobby_LobbyUpdateReceivedCallbackInfo* Data);

/** The most recent version of the EOS_Lobby_AddNotifyLobbyMemberUpdateReceived API. */
#define EOS_LOBBY_ADDNOTIFYLOBBYMEMBERUPDATERECEIVED_API_LATEST 1

EOS_STRUCT(EOS_Lobby_AddNotifyLobbyMemberUpdateReceivedOptions, (
	/** API Version: Set this to EOS_LOBBY_ADDNOTIFYLOBBYMEMBERUPDATERECEIVED_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_Lobby_OnLobbyMemberUpdateReceivedCallback Function.
 */
EOS_STRUCT(EOS_Lobby_LobbyMemberUpdateReceivedCallbackInfo, (
	/** Context that was passed into EOS_Lobby_AddNotifyLobbyMemberUpdateReceived */
	void* ClientData;
	/** The ID of the lobby */
	EOS_LobbyId LobbyId;
	/** The Product User ID of the lobby member */
	EOS_ProductUserId TargetUserId;
));

/**
 * Function prototype definition for notifications that comes from EOS_Lobby_AddNotifyLobbyMemberUpdateReceived
 *
 * @param Data A EOS_Lobby_LobbyMemberUpdateReceivedCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Lobby_OnLobbyMemberUpdateReceivedCallback, const EOS_Lobby_LobbyMemberUpdateReceivedCallbackInfo* Data);

/** The most recent version of the EOS_Lobby_AddNotifyLobbyMemberStatusReceived API. */
#define EOS_LOBBY_ADDNOTIFYLOBBYMEMBERSTATUSRECEIVED_API_LATEST 1

/**
 * Input parameters for the EOS_Lobby_AddNotifyLobbyMemberStatusReceived function.
 */
EOS_STRUCT(EOS_Lobby_AddNotifyLobbyMemberStatusReceivedOptions, (
	/** API Version: Set this to EOS_LOBBY_ADDNOTIFYLOBBYMEMBERSTATUSRECEIVED_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_Lobby_AddNotifyLobbyMemberStatusReceived function.
 */
EOS_STRUCT(EOS_Lobby_LobbyMemberStatusReceivedCallbackInfo, (
	/** Context that was passed into EOS_Lobby_AddNotifyLobbyMemberStatusReceived */
	void* ClientData;
	/** The ID of the lobby */
	EOS_LobbyId LobbyId;
	/** The Product User ID of the lobby member */
	EOS_ProductUserId TargetUserId;
	/** Latest status of the user */
	EOS_ELobbyMemberStatus CurrentStatus;
));

/**
 * Function prototype definition for callbacks passed to EOS_Lobby_AddNotifyLobbyMemberStatusReceived
 * @param Data A EOS_Lobby_LobbyMemberStatusReceivedCallbackInfo CallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Lobby_OnLobbyMemberStatusReceivedCallback, const EOS_Lobby_LobbyMemberStatusReceivedCallbackInfo* Data);

/** Max length of an invite ID */
#define EOS_LOBBY_INVITEID_MAX_LENGTH 64

/** The most recent version of the EOS_Lobby_AddNotifyLobbyInviteReceived API. */
#define EOS_LOBBY_ADDNOTIFYLOBBYINVITERECEIVED_API_LATEST 1

EOS_STRUCT(EOS_Lobby_AddNotifyLobbyInviteReceivedOptions, (
	/** API Version: Set this to EOS_LOBBY_ADDNOTIFYLOBBYINVITERECEIVED_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_Lobby_OnLobbyInviteReceivedCallback Function.
 */
EOS_STRUCT(EOS_Lobby_LobbyInviteReceivedCallbackInfo, (
	/** Context that was passed into EOS_Lobby_AddNotifyLobbyInviteReceived */
	void* ClientData;
	/** The ID of the invitation */
	const char* InviteId;
	/** The Product User ID of the local user who received the invitation */
	EOS_ProductUserId LocalUserId;
	/** The Product User ID of the user who sent the invitation */
	EOS_ProductUserId TargetUserId;
));

/**
 * Function prototype definition for notifications that comes from EOS_Lobby_AddNotifyLobbyInviteReceived
 *
 * @param Data A EOS_Lobby_LobbyInviteReceivedCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Lobby_OnLobbyInviteReceivedCallback, const EOS_Lobby_LobbyInviteReceivedCallbackInfo* Data);

/** The most recent version of the EOS_Lobby_AddNotifyLobbyInviteAccepted API. */
#define EOS_LOBBY_ADDNOTIFYLOBBYINVITEACCEPTED_API_LATEST 1

EOS_STRUCT(EOS_Lobby_AddNotifyLobbyInviteAcceptedOptions, (
	/** API Version: Set this to EOS_LOBBY_ADDNOTIFYLOBBYINVITEACCEPTED_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_Lobby_OnLobbyInviteAcceptedCallback Function.
 */
EOS_STRUCT(EOS_Lobby_LobbyInviteAcceptedCallbackInfo, (
	/** Context that was passed into EOS_Lobby_AddNotifyLobbyInviteAccepted */
	void* ClientData;
	/** The invite ID */
	const char* InviteId;
	/** The Product User ID of the local user who received the invitation */
	EOS_ProductUserId LocalUserId;
	/** The Product User ID of the user who sent the invitation */
	EOS_ProductUserId TargetUserId;
	/** Lobby ID that the user has been invited to */
	const char* LobbyId;
));

/**
 * Function prototype definition for notifications that comes from EOS_Lobby_AddNotifyLobbyInviteAccepted
 *
 * @param Data A EOS_Lobby_LobbyInviteAcceptedCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Lobby_OnLobbyInviteAcceptedCallback, const EOS_Lobby_LobbyInviteAcceptedCallbackInfo* Data);

/** The most recent version of the EOS_Lobby_AddNotifyJoinLobbyAccepted API. */
#define EOS_LOBBY_ADDNOTIFYJOINLOBBYACCEPTED_API_LATEST 1

EOS_STRUCT(EOS_Lobby_AddNotifyJoinLobbyAcceptedOptions, (
	/** API Version: Set this to EOS_LOBBY_ADDNOTIFYJOINLOBBYACCEPTED_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_Lobby_OnJoinLobbyAcceptedCallback Function.
 */
EOS_STRUCT(EOS_Lobby_JoinLobbyAcceptedCallbackInfo, (
	/** Context that was passed into EOS_Lobby_AddNotifyJoinLobbyAccepted */
	void* ClientData;
	/** The Product User ID of the local user who is joining */
	EOS_ProductUserId LocalUserId;
	/** 
	 * The UI Event associated with this Join Game event.
	 * This should be used with EOS_Lobby_CopyLobbyDetailsHandleByUiEventId to get a handle to be used
	 * when calling EOS_Lobby_JoinLobby.
	 */
	EOS_UI_EventId UiEventId;
));

/**
 * Function prototype definition for notifications that comes from EOS_Lobby_AddNotifyJoinLobbyAccepted
 *
 * @param Data A EOS_Lobby_JoinLobbyAcceptedCallbackInfo containing the output information and result
 *
 * @note The lobby for the join game must be joined.
 *
 * @see EOS_Lobby_CopyLobbyDetailsHandleByUiEventId
 * @see EOS_Lobby_JoinLobby
 */
EOS_DECLARE_CALLBACK(EOS_Lobby_OnJoinLobbyAcceptedCallback, const EOS_Lobby_JoinLobbyAcceptedCallbackInfo* Data);


/** The most recent version of the EOS_Lobby_CopyLobbyDetailsHandleByInviteId API. */
#define EOS_LOBBY_COPYLOBBYDETAILSHANDLEBYINVITEID_API_LATEST 1

/**
 * Input parameters for the EOS_Lobby_CopyLobbyDetailsHandleByInviteId function.
 */
EOS_STRUCT(EOS_Lobby_CopyLobbyDetailsHandleByInviteIdOptions, (
	/** API Version: Set this to EOS_LOBBY_COPYLOBBYDETAILSHANDLEBYINVITEID_API_LATEST. */
	int32_t ApiVersion;
	/** The ID of an invitation to join the lobby */
	const char* InviteId;
));

/** The most recent version of the EOS_Lobby_CopyLobbyDetailsHandleByUiEventId API. */
#define EOS_LOBBY_COPYLOBBYDETAILSHANDLEBYUIEVENTID_API_LATEST 1

/**
 * Input parameters for the EOS_Lobby_CopyLobbyDetailsHandleByUiEventId function.
 */
EOS_STRUCT(EOS_Lobby_CopyLobbyDetailsHandleByUiEventIdOptions, (
	/** API Version: Set this to EOS_LOBBY_COPYLOBBYDETAILSHANDLEBYUIEVENTID_API_LATEST. */
	int32_t ApiVersion;
	/** UI Event associated with the lobby */
	EOS_UI_EventId UiEventId;
));

/** The most recent version of the EOS_Lobby_CreateLobbySearch API. */
#define EOS_LOBBY_CREATELOBBYSEARCH_API_LATEST 1

/**
 * Input parameters for the EOS_Lobby_CreateLobbySearch function.
 */
EOS_STRUCT(EOS_Lobby_CreateLobbySearchOptions, (
	/** API Version: Set this to EOS_LOBBY_CREATELOBBYSEARCH_API_LATEST. */
	int32_t ApiVersion;
	/** Maximum number of results allowed from the search */
	uint32_t MaxResults;
));

/** The most recent version of the EOS_Lobby_SendInvite API. */
#define EOS_LOBBY_SENDINVITE_API_LATEST 1

/**
 * Input parameters for the EOS_Lobby_SendInvite function.
 */
EOS_STRUCT(EOS_Lobby_SendInviteOptions, (
	/** API Version: Set this to EOS_LOBBY_SENDINVITE_API_LATEST. */
	int32_t ApiVersion;
	/** The ID of the lobby associated with the invitation */
	EOS_LobbyId LobbyId;
	/** The Product User ID of the local user sending the invitation */
	EOS_ProductUserId LocalUserId;
	/** The Product User ID of the user receiving the invitation */
	EOS_ProductUserId TargetUserId;
));

/**
 * Output parameters for the EOS_Lobby_SendInvite function.
 */
EOS_STRUCT(EOS_Lobby_SendInviteCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Lobby_SendInvite */
	void* ClientData;
	/** The ID of the lobby */
	EOS_LobbyId LobbyId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Lobby_SendInvite
 * @param Data A EOS_Lobby_SendInvite CallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Lobby_OnSendInviteCallback, const EOS_Lobby_SendInviteCallbackInfo* Data);

/** The most recent version of the EOS_Lobby_RejectInvite API. */
#define EOS_LOBBY_REJECTINVITE_API_LATEST 1

/**
 * Input parameters for the EOS_Lobby_RejectInvite function.
 */
EOS_STRUCT(EOS_Lobby_RejectInviteOptions, (
	/** API Version: Set this to EOS_LOBBY_REJECTINVITE_API_LATEST. */
	int32_t ApiVersion;
	/** The ID of the lobby associated with the invitation */
	const char* InviteId;
	/** The Product User ID of the local user who is rejecting the invitation */
	EOS_ProductUserId LocalUserId;
));

/**
 * Output parameters for the EOS_Lobby_RejectInvite function.
 */
EOS_STRUCT(EOS_Lobby_RejectInviteCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Lobby_RejectInvite */
	void* ClientData;
	/** The ID of the invitation being rejected */
	const char* InviteId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Lobby_RejectInvite
 * @param Data A EOS_Lobby_RejectInvite CallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Lobby_OnRejectInviteCallback, const EOS_Lobby_RejectInviteCallbackInfo* Data);

/** The most recent version of the EOS_Lobby_QueryInvites API. */
#define EOS_LOBBY_QUERYINVITES_API_LATEST 1

/**
 * Input parameters for the EOS_Lobby_QueryInvites function.
 */
EOS_STRUCT(EOS_Lobby_QueryInvitesOptions, (
	/** API Version: Set this to EOS_LOBBY_QUERYINVITES_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user whose invitations you want to retrieve */
	EOS_ProductUserId LocalUserId;
));

/**
 * Output parameters for the EOS_Lobby_QueryInvites function.
 */
EOS_STRUCT(EOS_Lobby_QueryInvitesCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Lobby_QueryInvites */
	void* ClientData;
	/** The Product User ID of the local user that made the request */
	EOS_ProductUserId LocalUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Lobby_QueryInvites
 * @param Data A EOS_Lobby_QueryInvites CallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Lobby_OnQueryInvitesCallback, const EOS_Lobby_QueryInvitesCallbackInfo* Data);


/** The most recent version of the EOS_Lobby_GetInviteCount API. */
#define EOS_LOBBY_GETINVITECOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Lobby_GetInviteCount function.
 */
EOS_STRUCT(EOS_Lobby_GetInviteCountOptions, (
	/** API Version: Set this to EOS_LOBBY_GETINVITECOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user whose cached lobby invitations you want to count */
	EOS_ProductUserId LocalUserId;
));

/** The most recent version of the EOS_Lobby_GetInviteIdByIndex API. */
#define EOS_LOBBY_GETINVITEIDBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_Lobby_GetInviteIdByIndex function.
 */
EOS_STRUCT(EOS_Lobby_GetInviteIdByIndexOptions, (
	/** API Version: Set this to EOS_LOBBY_GETINVITEIDBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user who received the cached invitation */
	EOS_ProductUserId LocalUserId;
	/** The index of the invitation ID to retrieve */
	uint32_t Index;
));

/** The most recent version of the EOS_Lobby_CopyLobbyDetailsHandle API. */
#define EOS_LOBBY_COPYLOBBYDETAILSHANDLE_API_LATEST 1

/**
 * Input parameters for the EOS_Lobby_CopyLobbyDetailsHandle function.
 */
EOS_STRUCT(EOS_Lobby_CopyLobbyDetailsHandleOptions, (
	/** API Version: Set this to EOS_LOBBY_COPYLOBBYDETAILSHANDLE_API_LATEST. */
	int32_t ApiVersion;
	/** The ID of the lobby */
	EOS_LobbyId LobbyId;
	/** The Product User ID of the local user making the request */
	EOS_ProductUserId LocalUserId;
));


/** The most recent version of the EOS_Lobby_GetRTCRoomName API. */
#define EOS_LOBBY_GETRTCROOMNAME_API_LATEST 1

/**
 * Input parameters for the EOS_Lobby_GetRTCRoomName function.
 */
EOS_STRUCT(EOS_Lobby_GetRTCRoomNameOptions, (
	/** API Version: Set this to EOS_LOBBY_GETRTCROOMNAME_API_LATEST */
	int32_t ApiVersion;
	/** The ID of the lobby to get the RTC Room name for */
	EOS_LobbyId LobbyId;
	/** The Product User ID of the local user in the lobby */
	EOS_ProductUserId LocalUserId;
));


/** The most recent version of the EOS_Lobby_IsRTCRoomConnected API. */
#define EOS_LOBBY_ISRTCROOMCONNECTED_API_LATEST 1

EOS_STRUCT(EOS_Lobby_IsRTCRoomConnectedOptions, (
	/** API Version: Set this to EOS_LOBBY_ISRTCROOMCONNECTED_API_LATEST */
	int32_t ApiVersion;
	/** The ID of the lobby to get the RTC Room name for */
	EOS_LobbyId LobbyId;
	/** The Product User ID of the local user in the lobby */
	EOS_ProductUserId LocalUserId;
));


/** The most recent version of the EOS_Lobby_AddNotifyRTCRoomConnectionChanged API. */
#define EOS_LOBBY_ADDNOTIFYRTCROOMCONNECTIONCHANGED_API_LATEST 1

/**
 * Input parameters for the EOS_Lobby_AddNotifyRTCRoomConnectionChanged function.
 */
EOS_STRUCT(EOS_Lobby_AddNotifyRTCRoomConnectionChangedOptions, (
	/** API Version: Set this to EOS_LOBBY_ADDNOTIFYRTCROOMCONNECTIONCHANGED_API_LATEST */
	int32_t ApiVersion;
	/** The ID of the lobby to receive RTC Room connection change notifications for */
	EOS_LobbyId LobbyId;
	/** The Product User ID of the local user in the lobby */
	EOS_ProductUserId LocalUserId;
));

EOS_STRUCT(EOS_Lobby_RTCRoomConnectionChangedCallbackInfo, (
	/** Context that was passed into EOS_Lobby_AddNotifyRTCRoomConnectionChanged */
	void* ClientData;
	/** The ID of the lobby which had a RTC Room connection state change */
	EOS_LobbyId LobbyId;
	/** The Product User ID of the local user who is in the lobby and registered for notifications */
	EOS_ProductUserId LocalUserId;
	/** The new connection state of the room */
	EOS_Bool bIsConnected;
	/**
	 If bIsConnected is EOS_FALSE, this result will be the reason we were disconnected.
	 * EOS_Success: The room was left locally. This may be because: the associated lobby was Left or Destroyed, the connection to the lobby was interrupted, or because the SDK is being shutdown. If the lobby connection returns (lobby did not permanently go away), we will reconnect.
	 * EOS_NoConnection: There was a network issue connecting to the server. We will attempt to reconnect soon.
	 * EOS_RTC_UserKicked: The user has been kicked by the server. We will not reconnect.
	 * EOS_RTC_UserBanned: The user has been banned by the server. We will not reconnect.
	 * EOS_ServiceFailure: A known error occurred during interaction with the server. We will attempt to reconnect soon.
	 * EOS_UnexpectedError: Unexpected error. We will attempt to reconnect soon.
	 */
	EOS_EResult DisconnectReason;
));

/**
 * Function prototype definition for notifications that comes from EOS_Lobby_AddNotifyRTCRoomConnectionChanged
 *
 * @param Data containing the connection state of the RTC Room for a lobby
 *
 * @see EOS_Lobby_IsRTCRoomConnected
 */
EOS_DECLARE_CALLBACK(EOS_Lobby_OnRTCRoomConnectionChangedCallback, const EOS_Lobby_RTCRoomConnectionChangedCallbackInfo* Data);


/** Search for a matching bucket ID (value is string) */
#define EOS_LOBBY_SEARCH_BUCKET_ID "bucket"
/** Search for lobbies that contain at least this number of members (value is int)  */
#define EOS_LOBBY_SEARCH_MINCURRENTMEMBERS "mincurrentmembers"
/** Search for a match with min free space (value is int) */
#define EOS_LOBBY_SEARCH_MINSLOTSAVAILABLE "minslotsavailable"

/** The most recent version of the EOS_Lobby_AttributeData struct. */
#define EOS_LOBBY_ATTRIBUTEDATA_API_LATEST 1

/**
 * Contains information about lobby and lobby member data
 */
EOS_STRUCT(EOS_Lobby_AttributeData, (
	/** API Version: Set this to EOS_LOBBY_ATTRIBUTEDATA_API_LATEST. */
	int32_t ApiVersion;
	/** Name of the lobby attribute */
	const char* Key;
	union
	{
		/** Stored as an 8 byte integer */
		int64_t AsInt64;
		/** Stored as a double precision floating point */
		double AsDouble;
		/** Stored as a boolean */
		EOS_Bool AsBool;
		/** Stored as a null terminated UTF8 string */
		const char* AsUtf8;
	} Value;

	/** Type of value stored in the union */
	EOS_ELobbyAttributeType ValueType;
));

/** The most recent version of the EOS_Lobby_Attribute struct. */
#define EOS_LOBBY_ATTRIBUTE_API_LATEST 1

/**
 *  An attribute and its visibility setting stored with a lobby.
 *  Used to store both lobby and lobby member data
 */
EOS_STRUCT(EOS_Lobby_Attribute, (
	/** API Version: Set this to EOS_LOBBY_ATTRIBUTE_API_LATEST. */
	int32_t ApiVersion;
	/** Key/Value pair describing the attribute */
	EOS_Lobby_AttributeData* Data;
	/** Is this attribute public or private to the lobby and its members */
	EOS_ELobbyAttributeVisibility Visibility;
));

EOS_DECLARE_FUNC(void) EOS_Lobby_Attribute_Release(EOS_Lobby_Attribute* LobbyAttribute);

/** The most recent version of the EOS_LobbyModification_SetBucketId API. */
#define EOS_LOBBYMODIFICATION_SETBUCKETID_API_LATEST 1

/**
 * Input parameters for the EOS_LobbyModification_SetBucketId function.
 */
EOS_STRUCT(EOS_LobbyModification_SetBucketIdOptions, (
	/** API Version: Set this to EOS_LOBBYMODIFICATION_SETBUCKETID_API_LATEST. */
	int32_t ApiVersion;
	/** The new bucket id associated with the lobby */
	const char* BucketId;
));

/** The most recent version of the EOS_LobbyModification_SetPermissionLevel API. */
#define EOS_LOBBYMODIFICATION_SETPERMISSIONLEVEL_API_LATEST 1

/**
 * Input parameters for the EOS_LobbyModification_SetPermissionLevel function.
 */
EOS_STRUCT(EOS_LobbyModification_SetPermissionLevelOptions, (
	/** API Version: Set this to EOS_LOBBYMODIFICATION_SETPERMISSIONLEVEL_API_LATEST. */
	int32_t ApiVersion;
	/** Permission level of the lobby */
	EOS_ELobbyPermissionLevel PermissionLevel;
));

/** The most recent version of the EOS_LobbyModification_SetMaxMembers API. */
#define EOS_LOBBYMODIFICATION_SETMAXMEMBERS_API_LATEST 1

/**
 * Input parameters for the EOS_LobbyModification_SetMaxMembers function.
 */
EOS_STRUCT(EOS_LobbyModification_SetMaxMembersOptions, (
	/** API Version: Set this to EOS_LOBBYMODIFICATION_SETMAXMEMBERS_API_LATEST. */
	int32_t ApiVersion;
	/** New maximum number of lobby members */
	uint32_t MaxMembers;
));

/** The most recent version of the EOS_LobbyModification_SetInvitesAllowed API. */
#define EOS_LOBBYMODIFICATION_SETINVITESALLOWED_API_LATEST 1

/**
 * Input parameters for the EOS_LobbyModification_SetInvitesAllowed Function.
 */
EOS_STRUCT(EOS_LobbyModification_SetInvitesAllowedOptions, (
	/** API Version: Set this to EOS_LOBBYMODIFICATION_SETINVITESALLOWED_API_LATEST. */
	int32_t ApiVersion;
	/** If true then invites can currently be sent for the associated lobby */
	EOS_Bool bInvitesAllowed;
));

/** The most recent version of the EOS_LobbyModification_AddAttribute API. */
#define EOS_LOBBYMODIFICATION_ADDATTRIBUTE_API_LATEST 1

/**
 * Input parameters for the EOS_LobbyModification_AddAttribute function.
 */
EOS_STRUCT(EOS_LobbyModification_AddAttributeOptions, (
	/** API Version: Set this to EOS_LOBBYMODIFICATION_ADDATTRIBUTE_API_LATEST. */
	int32_t ApiVersion;
	/** Key/Value pair describing the attribute to add to the lobby */
	const EOS_Lobby_AttributeData* Attribute;
	/** Is this attribute public or private to the lobby and its members */
	EOS_ELobbyAttributeVisibility Visibility;
));


/** The most recent version of the EOS_LobbyModification_RemoveAttribute API. */
#define EOS_LOBBYMODIFICATION_REMOVEATTRIBUTE_API_LATEST 1

/**
 * Input parameters for the EOS_LobbyModification_RemoveAttribute function.
 */
EOS_STRUCT(EOS_LobbyModification_RemoveAttributeOptions, (
	/** API Version: Set this to EOS_LOBBYMODIFICATION_REMOVEATTRIBUTE_API_LATEST. */
	int32_t ApiVersion;
	/** Name of the key */
	const char* Key;
));

/** The most recent version of the EOS_LobbyModification_AddMemberAttribute API. */
#define EOS_LOBBYMODIFICATION_ADDMEMBERATTRIBUTE_API_LATEST 1

/**
 * Input parameters for the EOS_LobbyModification_AddMemberAttribute function.
 */
EOS_STRUCT(EOS_LobbyModification_AddMemberAttributeOptions, (
	/** API Version: Set this to EOS_LOBBYMODIFICATION_ADDMEMBERATTRIBUTE_API_LATEST. */
	int32_t ApiVersion;
	/** Key/Value pair describing the attribute to add to the lobby member */
	const EOS_Lobby_AttributeData* Attribute;
	/** Is this attribute public or private to the rest of the lobby members */
	EOS_ELobbyAttributeVisibility Visibility;
));

/** The most recent version of the EOS_LobbyModification_RemoveMemberAttribute API. */
#define EOS_LOBBYMODIFICATION_REMOVEMEMBERATTRIBUTE_API_LATEST 1

/**
 * Input parameters for the EOS_LobbyModification_RemoveMemberAttribute function.
 */
EOS_STRUCT(EOS_LobbyModification_RemoveMemberAttributeOptions, (
	/** API Version: Set this to EOS_LOBBYMODIFICATION_REMOVEMEMBERATTRIBUTE_API_LATEST. */
	int32_t ApiVersion;
	/** Name of the key */
	const char* Key;
));

/** The most recent version of the EOS_LobbyDetails_GetLobbyOwner API. */
#define EOS_LOBBYDETAILS_GETLOBBYOWNER_API_LATEST 1

/**
 * Input parameters for the EOS_LobbyDetails_GetLobbyOwner function.
 */
EOS_STRUCT(EOS_LobbyDetails_GetLobbyOwnerOptions, (
	/** API Version: Set this to EOS_LOBBYDETAILS_GETLOBBYOWNER_API_LATEST. */
	int32_t ApiVersion;
));

/** The most recent version of the EOS_LobbyDetails_CopyInfo API. */
#define EOS_LOBBYDETAILS_COPYINFO_API_LATEST 1

/**
 * Input parameters for the EOS_LobbyDetails_CopyInfo function.
 */
EOS_STRUCT(EOS_LobbyDetails_CopyInfoOptions, (
	/** API Version: Set this to EOS_LOBBYDETAILS_COPYINFO_API_LATEST. */
	int32_t ApiVersion;
));


/** The most recent version of the EOS_LobbyDetails_GetAttributeCount API. */
#define EOS_LOBBYDETAILS_GETATTRIBUTECOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_LobbyDetails_GetAttributeCount function.
 */
EOS_STRUCT(EOS_LobbyDetails_GetAttributeCountOptions, (
	/** API Version: Set this to EOS_LOBBYDETAILS_GETATTRIBUTECOUNT_API_LATEST. */
	int32_t ApiVersion;
));


/** The most recent version of the EOS_LobbyDetails_CopyAttributeByIndex API. */
#define EOS_LOBBYDETAILS_COPYATTRIBUTEBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_LobbyDetails_CopyAttributeByIndex function.
 */
EOS_STRUCT(EOS_LobbyDetails_CopyAttributeByIndexOptions, (
	/** API Version: Set this to EOS_LOBBYDETAILS_COPYATTRIBUTEBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/**
	 * The index of the attribute to retrieve
	 * @see EOS_LobbyDetails_GetAttributeCount
	 */
	uint32_t AttrIndex;
));


/** The most recent version of the EOS_LobbyDetails_CopyAttributeByKey API. */
#define EOS_LOBBYDETAILS_COPYATTRIBUTEBYKEY_API_LATEST 1

/**
 * Input parameters for the EOS_LobbyDetails_CopyAttributeByKey function.
 */
EOS_STRUCT(EOS_LobbyDetails_CopyAttributeByKeyOptions, (
	/** API Version: Set this to EOS_LOBBYDETAILS_COPYATTRIBUTEBYKEY_API_LATEST. */
	int32_t ApiVersion;
	/** Name of the attribute */
	const char* AttrKey;
));

/** The most recent version of the EOS_LobbyDetails_GetMemberAttributeCount API. */
#define EOS_LOBBYDETAILS_GETMEMBERATTRIBUTECOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_LobbyDetails_GetMemberAttributeCount function.
 */
EOS_STRUCT(EOS_LobbyDetails_GetMemberAttributeCountOptions, (
	/** API Version: Set this to EOS_LOBBYDETAILS_GETMEMBERATTRIBUTECOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the lobby member */
	EOS_ProductUserId TargetUserId;
));

/** The most recent version of the EOS_LobbyDetails_CopyMemberAttributeByIndex API. */
#define EOS_LOBBYDETAILS_COPYMEMBERATTRIBUTEBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_LobbyDetails_CopyMemberAttributeByIndex function.
 */
EOS_STRUCT(EOS_LobbyDetails_CopyMemberAttributeByIndexOptions, (
	/** API Version: Set this to EOS_LOBBYDETAILS_COPYMEMBERATTRIBUTEBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the lobby member */
	EOS_ProductUserId TargetUserId;
	/** The index of the attribute to copy */
	uint32_t AttrIndex;
));

/** The most recent version of the EOS_LobbyDetails_CopyMemberAttributeByKey API. */
#define EOS_LOBBYDETAILS_COPYMEMBERATTRIBUTEBYKEY_API_LATEST 1

/**
 * Input parameters for the EOS_LobbyDetails_CopyMemberAttributeByKey function.
 */
EOS_STRUCT(EOS_LobbyDetails_CopyMemberAttributeByKeyOptions, (
	/** API Version: Set this to EOS_LOBBYDETAILS_COPYMEMBERATTRIBUTEBYKEY_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the lobby member */
	EOS_ProductUserId TargetUserId;
	/** Name of the attribute to copy */
	const char* AttrKey;
));

/** The most recent version of the EOS_LobbyDetails_GetMemberCount API. */
#define EOS_LOBBYDETAILS_GETMEMBERCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_LobbyDetails_GetMemberCount function.
 */
EOS_STRUCT(EOS_LobbyDetails_GetMemberCountOptions, (
	/** API Version: Set this to EOS_LOBBYDETAILS_GETMEMBERCOUNT_API_LATEST. */
	int32_t ApiVersion;
));

/** The most recent version of the EOS_LobbyDetails_GetMemberByIndex API. */
#define EOS_LOBBYDETAILS_GETMEMBERBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_LobbyDetails_GetMemberByIndex function.
 */
EOS_STRUCT(EOS_LobbyDetails_GetMemberByIndexOptions, (
	/** API Version: Set this to EOS_LOBBYDETAILS_GETMEMBERBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** Index of the member to retrieve */
	uint32_t MemberIndex;
));

/** The most recent version of the EOS_LobbySearch_Find API. */
#define EOS_LOBBYSEARCH_FIND_API_LATEST 1

/**
 * Input parameters for the EOS_LobbySearch_Find function.
 */
EOS_STRUCT(EOS_LobbySearch_FindOptions, (
	/** API Version: Set this to EOS_LOBBYSEARCH_FIND_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user making the search request */
	EOS_ProductUserId LocalUserId;
));

/**
 * Output parameters for the EOS_LobbySearch_Find function.
 */
EOS_STRUCT(EOS_LobbySearch_FindCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_LobbySearch_Find */
	void* ClientData;
));

/**
 * Function prototype definition for callbacks passed to EOS_LobbySearch_Find
 * @param Data A EOS_LobbySearch_Find CallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_LobbySearch_OnFindCallback, const EOS_LobbySearch_FindCallbackInfo* Data);

/** The most recent version of the EOS_LobbySearch_SetLobbyId API. */
#define EOS_LOBBYSEARCH_SETLOBBYID_API_LATEST 1

/**
 * Input parameters for the EOS_LobbySearch_SetLobbyId function.
 */
EOS_STRUCT(EOS_LobbySearch_SetLobbyIdOptions, (
	/** API Version: Set this to EOS_LOBBYSEARCH_SETLOBBYID_API_LATEST. */
	int32_t ApiVersion;
	/** The ID of the lobby to find */
	EOS_LobbyId LobbyId;
));

/** The most recent version of the EOS_LobbySearch_SetTargetUserId API. */
#define EOS_LOBBYSEARCH_SETTARGETUSERID_API_LATEST 1

/**
 * Input parameters for the EOS_LobbySearch_SetTargetUserId function.
 */
EOS_STRUCT(EOS_LobbySearch_SetTargetUserIdOptions, (
	/** API Version: Set this to EOS_LOBBYSEARCH_SETTARGETUSERID_API_LATEST. */
	int32_t ApiVersion;
	/** Search lobbies for given user by Product User ID, returning any lobbies where this user is currently registered */
	EOS_ProductUserId TargetUserId;
));

/** The most recent version of the EOS_LobbySearch_SetParameter API. */
#define EOS_LOBBYSEARCH_SETPARAMETER_API_LATEST 1

/**
 * Input parameters for the EOS_LobbySearch_SetParameter function.
 */
EOS_STRUCT(EOS_LobbySearch_SetParameterOptions, (
	/** API Version: Set this to EOS_LOBBYSEARCH_SETPARAMETER_API_LATEST. */
	int32_t ApiVersion;
	/** Search parameter describing a key and a value to compare */
	const EOS_Lobby_AttributeData* Parameter;
	/** The type of comparison to make against the search parameter */
	EOS_EComparisonOp ComparisonOp;
));

/** The most recent version of the EOS_LobbySearch_RemoveParameter API. */
#define EOS_LOBBYSEARCH_REMOVEPARAMETER_API_LATEST 1

/**
 * Input parameters for the EOS_LobbySearch_RemoveParameter function.
 */
EOS_STRUCT(EOS_LobbySearch_RemoveParameterOptions, (
	/** API Version: Set this to EOS_LOBBYSEARCH_REMOVEPARAMETER_API_LATEST. */
	int32_t ApiVersion;
	/** Search parameter key to remove from the search */
	const char* Key;
	/** Search comparison operation associated with the key to remove */
	EOS_EComparisonOp ComparisonOp;
));

/** The most recent version of the EOS_LobbySearch_SetMaxResults API. */
#define EOS_LOBBYSEARCH_SETMAXRESULTS_API_LATEST 1

/**
 * Input parameters for the EOS_LobbySearch_SetMaxResults function.
 */
EOS_STRUCT(EOS_LobbySearch_SetMaxResultsOptions, (
	/** API Version: Set this to EOS_LOBBYSEARCH_SETMAXRESULTS_API_LATEST. */
	int32_t ApiVersion;
	/** Maximum number of search results to return from the query */
	uint32_t MaxResults;
));

/** The most recent version of the EOS_LobbySearch_GetSearchResultCount API. */
#define EOS_LOBBYSEARCH_GETSEARCHRESULTCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_LobbySearch_GetSearchResultCount function.
 */
EOS_STRUCT(EOS_LobbySearch_GetSearchResultCountOptions, (
	/** API Version: Set this to EOS_LOBBYSEARCH_GETSEARCHRESULTCOUNT_API_LATEST. */
	int32_t ApiVersion;
));

/** The most recent version of the EOS_LobbySearch_CopySearchResultByIndex API. */
#define EOS_LOBBYSEARCH_COPYSEARCHRESULTBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_LobbySearch_CopySearchResultByIndex function.
 */
EOS_STRUCT(EOS_LobbySearch_CopySearchResultByIndexOptions, (
	/** API Version: Set this to EOS_LOBBYSEARCH_COPYSEARCHRESULTBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/**
	 * The index of the lobby to retrieve within the completed search query
	 * @see EOS_LobbySearch_GetSearchResultCount
	 */
	uint32_t LobbyIndex;
));

#pragma pack(pop)

```

`eac/sdk/Include/eos_logging.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_common.h"

/**
 * The Logging Interface grants access to log output coming from the SDK at various levels of detail.
 * Unlike other interfaces, the Logging Interface does not require a handle from the Platform Interface,
 * as it functions entirely on the local system.
 */

#pragma pack(push, 8)

/**
 * Logging levels. When a log message is output, it has an associated log level.
 * Messages will only be sent to the callback function if the message's associated log level is less than or equal to the configured log level for that category.
 *
 * @see EOS_Logging_SetCallback
 * @see EOS_Logging_SetLogLevel
 */
EOS_ENUM(EOS_ELogLevel,
	EOS_LOG_Off = 0,
	EOS_LOG_Fatal = 100,
	EOS_LOG_Error = 200,
	EOS_LOG_Warning = 300,
	EOS_LOG_Info = 400,
	EOS_LOG_Verbose = 500,
	EOS_LOG_VeryVerbose = 600
);

/**
 * Logging Categories
 */
EOS_ENUM(EOS_ELogCategory,
	/** Low level logs unrelated to specific services */
	EOS_LC_Core = 0,
	/** Logs related to the Auth service */
	EOS_LC_Auth = 1,
	/** Logs related to the Friends service */
	EOS_LC_Friends = 2,
	/** Logs related to the Presence service */
	EOS_LC_Presence = 3,
	/** Logs related to the UserInfo service */
	EOS_LC_UserInfo = 4,
	/** Logs related to HTTP serialization */
	EOS_LC_HttpSerialization = 5,
	/** Logs related to the Ecommerce service */
	EOS_LC_Ecom = 6,
	/** Logs related to the P2P service */
	EOS_LC_P2P = 7,
	/** Logs related to the Sessions service */
	EOS_LC_Sessions = 8,
	/** Logs related to rate limiting */
	EOS_LC_RateLimiter = 9,
	/** Logs related to the PlayerDataStorage service */
	EOS_LC_PlayerDataStorage = 10,
	/** Logs related to sdk analytics */
	EOS_LC_Analytics = 11,
	/** Logs related to the messaging service */
	EOS_LC_Messaging = 12,
	/** Logs related to the Connect service */
	EOS_LC_Connect = 13,
	/** Logs related to the Overlay */
	EOS_LC_Overlay = 14,
	/** Logs related to the Achievements service */
	EOS_LC_Achievements = 15,
	/** Logs related to the Stats service */
	EOS_LC_Stats = 16,
	/** Logs related to the UI service */
	EOS_LC_UI = 17,
	/** Logs related to the lobby service */
	EOS_LC_Lobby = 18,
	/** Logs related to the Leaderboards service */
	EOS_LC_Leaderboards = 19,
	/** Logs related to an internal Keychain feature that the authentication interfaces use */
	EOS_LC_Keychain = 20,
	/** Logs related to external identity providers */
	EOS_LC_IdentityProvider = 21,
	/** Logs related to Title Storage */
	EOS_LC_TitleStorage = 22,
	/** Logs related to the Mods service */
	EOS_LC_Mods = 23,
	/** Logs related to the Anti-Cheat service */
	EOS_LC_AntiCheat = 24,
	/** Logs related to reports client. */
	EOS_LC_Reports = 25,
	/** Logs related to the Sanctions service */
	EOS_LC_Sanctions = 26,
	/** Logs related to the Progression Snapshot service */
	EOS_LC_ProgressionSnapshots = 27,
	/** Logs related to the Kids Web Services integration */
	EOS_LC_KWS = 28,
	/** Logs related to the RTC API */
	EOS_LC_RTC = 29,
	/** Logs related to the RTC Admin API */
	EOS_LC_RTCAdmin = 30,
	/** Logs related to the Inventory service */
	EOS_LC_Inventory = 31,
	/** Logs related to the Receipt Validator API */
	EOS_LC_ReceiptValidator = 32,

	/** Not a real log category. Used by EOS_Logging_SetLogLevel to set the log level for all categories at the same time */
	EOS_LC_ALL_CATEGORIES = 0x7fffffff
);

/** A structure representing a log message */
EOS_STRUCT(EOS_LogMessage, (
	/** A string representation of the log message category, encoded in UTF-8. Only valid during the life of the callback, so copy the string if you need it later. */
	const char* Category;
	/** The log message, encoded in UTF-8. Only valid during the life of the callback, so copy the string if you need it later. */
	const char* Message;
	/** The log level associated with the message */
	EOS_ELogLevel Level;
));

/**
 * Function prototype definition for functions that receive log messages.
 *
 * @param Message A EOS_LogMessage containing the log category, log level, and message.
 * @see EOS_LogMessage
 */
EXTERN_C typedef void (EOS_CALL * EOS_LogMessageFunc)(const EOS_LogMessage* Message);

/**
 * Set the callback function to use for SDK log messages. Any previously set callback will no longer be called.
 *
 * @param Callback the function to call when the SDK logs messages
 * @return EOS_Success is returned if the callback will be used for future log messages.
 *         EOS_NotConfigured is returned if the SDK has not yet been initialized, or if it has been shut down
 *
 * @see EOS_Initialize
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Logging_SetCallback(EOS_LogMessageFunc Callback);

/**
 * Set the logging level for the specified logging category. By default all log categories will callback for Warnings, Errors, and Fatals.
 *
 * @param LogCategory the specific log category to configure. Use EOS_LC_ALL_CATEGORIES to configure all categories simultaneously to the same log level.
 * @param LogLevel the log level to use for the log category
 *
 * @return EOS_Success is returned if the log levels are now in use.
 *         EOS_NotConfigured is returned if the SDK has not yet been initialized, or if it has been shut down.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Logging_SetLogLevel(EOS_ELogCategory LogCategory, EOS_ELogLevel LogLevel);

#pragma pack(pop)

```

`eac/sdk/Include/eos_metrics.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_metrics_types.h"

/**
 * The Metrics Interface tracks your application's usage and populates the Game Analytics dashboard in the Developer Portal.
 * This data includes active, online instances of the game's client and server, and past sessions played by local players.
 * All Metrics Interface calls take a handle of type EOS_HMetrics as the first parameter.
 * This handle can be retrieved from an EOS_HPlatform handle by using the EOS_Platform_GetMetricsInterface function.
 * 
 * @see EOS_Platform_GetMetricsInterface
 */

/**
 * Logs the start of a new game session for a local player.
 *
 * The game client should call this function whenever it joins into a new multiplayer, peer-to-peer or single player game session.
 * Each call to BeginPlayerSession must be matched with a corresponding call to EndPlayerSession.
 *
 * @param Options Structure containing the local player's game account and the game session information.
 *
 * @return Returns EOS_Success on success, or an error code if the input parameters are invalid or an active session for the player already exists.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Metrics_BeginPlayerSession(EOS_HMetrics Handle, const EOS_Metrics_BeginPlayerSessionOptions* Options);

/**
 * Logs the end of a game session for a local player.
 *
 * Call once when the game client leaves the active game session.
 * Each call to BeginPlayerSession must be matched with a corresponding call to EndPlayerSession.
 *
 * @param Options Structure containing the account id of the player whose session to end.
 *
 * @return Returns EOS_Success on success, or an error code if the input parameters are invalid or there was no active session for the player.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Metrics_EndPlayerSession(EOS_HMetrics Handle, const EOS_Metrics_EndPlayerSessionOptions* Options);

```

`eac/sdk/Include/eos_metrics_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

EXTERN_C typedef struct EOS_MetricsHandle* EOS_HMetrics;

/** User game controller types. */
EOS_ENUM(EOS_EUserControllerType,
	/** The game controller type is unknown. */
	EOS_UCT_Unknown = 0,
	/** Mouse and keyboard controller. */
	EOS_UCT_MouseKeyboard = 1,
	/** Gamepad controller. */
	EOS_UCT_GamepadControl = 2,
	/** Touch controller. */
	EOS_UCT_TouchControl = 3
);

/** Account ID type for EOS_Metrics_BeginPlayerSession and EOS_Metrics_EndPlayerSession. */
EOS_ENUM(EOS_EMetricsAccountIdType,
	/** An Epic Account ID. */
	EOS_MAIT_Epic = 0,
	/** An external service Account ID. */
	EOS_MAIT_External = 1
);

/** The most recent version of the EOS_Metrics_BeginPlayerSessionOptions struct. */
#define EOS_METRICS_BEGINPLAYERSESSION_API_LATEST 1

/** BeginPlayerSession. */
EOS_STRUCT(EOS_Metrics_BeginPlayerSessionOptions, (
	/** API Version: Set this to EOS_METRICS_BEGINPLAYERSESSION_API_LATEST. */
	int32_t ApiVersion;
	/** Account ID type that is set in the union. */
	EOS_EMetricsAccountIdType AccountIdType;
	/** The Account ID for the player whose session is beginning. */
	union
	{
		/** An Epic Account ID. Set this field when AccountIdType is set to EOS_MAIT_Epic. */
		EOS_EpicAccountId Epic;
		/** An Account ID for another service. Set this field when AccountIdType is set to EOS_MAIT_External. */
		const char* External;
	} AccountId;
	/** The in-game display name for the user as UTF-8 string. */
	const char* DisplayName;
	/** The user's game controller type. */
	EOS_EUserControllerType ControllerType;
	/**
	 * IP address of the game server hosting the game session. For a localhost session, set to NULL.
	 *
	 * @details Must be in either one of the following IPv4 or IPv6 string formats:
	 * * "127.0.0.1".
	 * * "1200:0000:AB00:1234:0000:2552:7777:1313".
	 * If both IPv4 and IPv6 addresses are available, use the IPv6 address.
	 */
	const char* ServerIp;
	/**
	 * Optional, application-defined custom match session identifier. If the identifier is not used, set to NULL.
	 *
	 * @details The game can tag each game session with a custom session match identifier,
	 * which will be shown in the Played Sessions listing at the user profile dashboard.
	 */
	const char* GameSessionId;
));

/** The most recent version of the EOS_Metrics_EndPlayerSessionOptions struct. */
#define EOS_METRICS_ENDPLAYERSESSION_API_LATEST 1

/** EndPlayerSession. */
EOS_STRUCT(EOS_Metrics_EndPlayerSessionOptions, (
	/** API Version: Set this to EOS_METRICS_ENDPLAYERSESSION_API_LATEST. */
	int32_t ApiVersion;
	/** The Account ID type that is set in the union. */
	EOS_EMetricsAccountIdType AccountIdType;
	/** The Account ID for the player whose session is ending. */
	union
	{
		/** An Epic Account ID. Set this field when AccountIdType is set to EOS_MAIT_Epic. */
		EOS_EpicAccountId Epic;
		/** An Account ID for another service. Set this field when AccountIdType is set to EOS_MAIT_External. */
		const char* External;
	} AccountId;
));

#pragma pack(pop)

```

`eac/sdk/Include/eos_mods.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_mods_types.h"

/**
 * The Mods Interface is used to manage a user's mods. Allowing a user to install/uninstall/enumerate mods.
 * All Mods Interface calls take a handle of type EOS_HMods as the first parameter.
 * This handle can be retrieved from a EOS_HPlatform handle by using the EOS_Platform_GetModsInterface function.
 *
 * NOTE: At this time, this feature is only available for desktop platforms and for products that are part of the Epic Games store.
 *
 * @see EOS_Platform_GetModsInterface
 */

/**
 * Starts an asynchronous task that makes a request to install the specified mod.
 *
 * @param Options structure containing the game and mod identifiers
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error
 *
 * @see the section related to mods in eos_result.h for more details.
 */
EOS_DECLARE_FUNC(void) EOS_Mods_InstallMod(EOS_HMods Handle, const EOS_Mods_InstallModOptions* Options, void* ClientData, const EOS_Mods_OnInstallModCallback CompletionDelegate);

/**
 * Starts an asynchronous task that makes a request to uninstall the specified mod.
 *
 * @param Options structure containing the game and mod identifiers
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error
 *
 * @see the section related to mods in eos_result.h for more details.
 */
EOS_DECLARE_FUNC(void) EOS_Mods_UninstallMod(EOS_HMods Handle, const EOS_Mods_UninstallModOptions* Options, void* ClientData, const EOS_Mods_OnUninstallModCallback CompletionDelegate);

/**
 * Starts an asynchronous task that makes a request to enumerate mods for the specified game.
 * Types of the mods to enumerate can be specified through EOS_Mods_EnumerateModsOptions
 *
 * @param Options structure containing the game identifiers
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error
 *
 * @see the section related to mods in eos_result.h for more details.
 */
EOS_DECLARE_FUNC(void) EOS_Mods_EnumerateMods(EOS_HMods Handle, const EOS_Mods_EnumerateModsOptions* Options, void* ClientData, const EOS_Mods_OnEnumerateModsCallback CompletionDelegate);

/**
 * Get cached enumerated mods object. If successful, this data must be released by calling EOS_Mods_ModInfo_Release
 * Types of the cached enumerated mods can be specified through EOS_Mods_CopyModInfoOptions
 *
 * @param Options structure containing the game identifier for which requesting enumerated mods
 * @param OutEnumeratedMods Enumerated mods Info. If the returned result is success, this will be set to data that must be later released, otherwise this will be set to NULL
 * @return Success if we have cached data, or an error result if the request was invalid or we do not have cached data.
 *
 * @see EOS_Mods_ModInfo_Release
 *
 * This request may fail with an EOS_NotFound code if an enumeration of a certain type was not performed before this call.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Mods_CopyModInfo(EOS_HMods Handle, const EOS_Mods_CopyModInfoOptions* Options, EOS_Mods_ModInfo ** OutEnumeratedMods);

/**
 * Starts an asynchronous task that makes a request to update the specified mod to the latest version.
 *
 * @param Options structure containing the game and mod identifiers
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error. If the mod is up to date then the operation will complete with success.
 *
 * @see the section related to mods in eos_result.h for more details.
 */
EOS_DECLARE_FUNC(void) EOS_Mods_UpdateMod(EOS_HMods Handle, const EOS_Mods_UpdateModOptions* Options, void* ClientData, const EOS_Mods_OnUpdateModCallback CompletionDelegate);

```

`eac/sdk/Include/eos_mods_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

EXTERN_C typedef struct EOS_ModsHandle* EOS_HMods;

/** The most recent version of the EOS_Mod_Identifier struct. */
#define EOS_MOD_IDENTIFIER_API_LATEST 1

/**
 * EOS_Mod_Identifier is used to identify a mod.
 */
EOS_STRUCT(EOS_Mod_Identifier, (
	/** API Version: Set this to EOS_MOD_IDENTIFIER_API_LATEST. */
	int32_t ApiVersion;
	/** Product namespace id in which this mod item exists */
	const char* NamespaceId;
	/* Item id of the Mod */
	const char* ItemId;
	/* Artifact id of the Mod */
	const char* ArtifactId;
	/** Represent mod item title. */
	const char* Title;
	/** Represent mod item version. */
	const char* Version;
));


/**
 * EOS_Mods_InstallMod is used to start an asynchronous request to make a mod install request for a game.
 * The following types are used to work with the API.
 */


/** The most recent version of the EOS_Mods_InstallMod API. */
#define EOS_MODS_INSTALLMOD_API_LATEST 1

/**
 * Input parameters for the EOS_Mods_InstallMod Function.
 */
EOS_STRUCT(EOS_Mods_InstallModOptions, (
	/** API Version: Set this to EOS_MODS_INSTALLMOD_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the user for which the mod should be installed */
	EOS_EpicAccountId LocalUserId;
	/** The mod to install */
	const EOS_Mod_Identifier* Mod;
	/** Indicates whether the mod should be uninstalled after exiting the game or not. */
	EOS_Bool bRemoveAfterExit;
));

/**
 * Output parameters for the EOS_Mods_InstallMod Function. These parameters are received through the callback provided to EOS_Mods_InstallMod
 */
EOS_STRUCT(EOS_Mods_InstallModCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned if the installation was successfull, otherwise one of the error codes is returned. */
	EOS_EResult ResultCode;
	/** The Epic Account ID of the user for which mod installation was requested */
	EOS_EpicAccountId LocalUserId;
	/** Context that is passed into EOS_Mods_InstallMod */
	void* ClientData;
	/** Mod for which installation was requested */
	const EOS_Mod_Identifier* Mod;
));

/**
 * Function prototype definition for callbacks passed to EOS_Mods_InstallMod
 * @param Data A EOS_Mods_InstallModCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Mods_OnInstallModCallback, const EOS_Mods_InstallModCallbackInfo* Data);


/**
 * EOS_Mods_UninstallMod is used to start an asynchronous request to make a mod uninstall request for a game.
 * The following types are used to work with the API.
 */


/** The most recent version of the EOS_Mods_UninstallModOptions API. */
#define EOS_MODS_UNINSTALLMOD_API_LATEST 1

/**
 * Input parameters for the EOS_Mods_UninstallMod Function.
 */
EOS_STRUCT(EOS_Mods_UninstallModOptions, (
	/** API Version: Set this to EOS_MODS_UNINSTALLMOD_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the user for which the mod should be uninstalled */
	EOS_EpicAccountId LocalUserId;
	/** The mod to uninstall */
	const EOS_Mod_Identifier* Mod;
));

/**
 * Output parameters for the EOS_Mods_UninstallMod Function. These parameters are received through the callback provided to EOS_Mods_UninstallMod
 */
EOS_STRUCT(EOS_Mods_UninstallModCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned if the uninstallation was successfull, otherwise one of the error codes is returned. */
	EOS_EResult ResultCode;
	/** The Epic Account ID of the user for which mod uninstallation was requested */
	EOS_EpicAccountId LocalUserId;
	/** Context that is passed into EOS_Mods_UninstallMod */
	void* ClientData;
	/** Mod for which uninstallation was requested */
	const EOS_Mod_Identifier* Mod;
));

/**
 * Function prototype definition for callbacks passed to EOS_Mods_UninstallMod
 * @param Data A EOS_Mods_UninstallModCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Mods_OnUninstallModCallback, const EOS_Mods_UninstallModCallbackInfo* Data);


/**
 * EOS_Mods_EnumerateMods is used to start an asynchronous request to enumerate mods for a game.
 * The following types are used to work with the API.
 */


/** The type of mod enumeration. */
EOS_ENUM(EOS_EModEnumerationType,
	/** Installed mods */
	EOS_MET_INSTALLED = 0,
	/** All available mods*/
	EOS_MET_ALL_AVAILABLE
);

 /** The most recent version of the EOS_Mods_EnumerateModsOptions API. */
#define EOS_MODS_ENUMERATEMODS_API_LATEST 1

/**
 * Input parameters for the EOS_Mods_EnumerateMods Function.
 */
EOS_STRUCT(EOS_Mods_EnumerateModsOptions, (
	/** API Version: Set this to EOS_MODS_ENUMERATEMODS_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the user for which the mod should be enumerated */
	EOS_EpicAccountId LocalUserId;
	/** Type of the mods to enumerate */
	EOS_EModEnumerationType Type;
));

/**
 * Output parameters for the EOS_Mods_EnumerateMods Function. These parameters are received through the callback provided to EOS_Mods_EnumerateMods
 */
EOS_STRUCT(EOS_Mods_EnumerateModsCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned if the enumeration was successfull, otherwise one of the error codes is returned. */
	EOS_EResult ResultCode;
	/** The Epic Account ID of the user for which mod enumeration was requested */
	EOS_EpicAccountId LocalUserId;
	/** Context that is passed into EOS_Mods_EnumerateMods */
	void* ClientData;
	/** Type of the enumerated mods */
	EOS_EModEnumerationType Type;
));

/**
 * Function prototype definition for callbacks passed to EOS_Mods_EnumerateMods
 * @param Data A EOS_Mods_EnumerateModsCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Mods_OnEnumerateModsCallback, const EOS_Mods_EnumerateModsCallbackInfo* Data);

/** The most recent version of the EOS_Mods_CopyModInfoOptions API. */
#define EOS_MODS_COPYMODINFO_API_LATEST 1

/**
 * Data for the EOS_Mods_CopyModInfo function.
 */
EOS_STRUCT(EOS_Mods_CopyModInfoOptions, (
	/** API Version: Set this to EOS_MODS_COPYMODINFO_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the user for which mods should be copied */
	EOS_EpicAccountId LocalUserId;
	/** Type of the enumerated mod to copy */
	EOS_EModEnumerationType Type;
));

/** The most recent version of the EOS_Mods_ModInfo struct. */
#define EOS_MODS_MODINFO_API_LATEST 1

/**
 * Data for the EOS_Mods_CopyModInfo function.
 *
 * @see EOS_Mods_CopyModInfo
 * @see EOS_Mods_ModInfo_Release
 */
EOS_STRUCT(EOS_Mods_ModInfo, (
	/** API Version: Set this to EOS_MODS_MODINFO_API_LATEST. */
	int32_t ApiVersion;
	/** The count of enumerated mods */
	int32_t ModsCount;
	/** The array of enumerated mods or NULL if no such type of mods were enumerated */
	EOS_Mod_Identifier* Mods;
	/** Type of the mods */
	EOS_EModEnumerationType Type;
));

/**
 * Release the memory associated with an EOS_Mods_ModInfo structure and its sub-objects. This must be called on data retrieved from EOS_Mods_CopyModInfo.
 *
 * @param ModInfo the info structure to be release
 *
 * @see EOS_Mods_ModInfo
 * @see EOS_Mods_CopyModInfo
 */
EOS_DECLARE_FUNC(void) EOS_Mods_ModInfo_Release(EOS_Mods_ModInfo* ModInfo);

/** The most recent version of the EOS_Mods_UpdateModOptions API. */
#define EOS_MODS_UPDATEMOD_API_LATEST 1

/**
 * Input parameters for the EOS_Mods_UpdateMod Function.
 */
EOS_STRUCT(EOS_Mods_UpdateModOptions, (
	/** API Version: Set this to EOS_MODS_UPDATEMOD_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the user for which the mod should be updated */
	EOS_EpicAccountId LocalUserId;
	/** The mod to update */
	const EOS_Mod_Identifier* Mod;
));

/**
 * Output parameters for the EOS_Mods_UpdateMod Function. These parameters are received through the callback provided to EOS_Mods_UpdateMod
 */
EOS_STRUCT(EOS_Mods_UpdateModCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned if the request to update was successfull, otherwise one of the error codes is returned. */
	EOS_EResult ResultCode;
	/** The Epic Account ID of the user for which mod update was requested */
	EOS_EpicAccountId LocalUserId;
	/** Context that is passed into EOS_Mods_UpdateMod */
	void* ClientData;
	/** Mod for which update was requested */
	const EOS_Mod_Identifier* Mod;
));

/**
 * Function prototype definition for callbacks passed to EOS_Mods_UpdateMod
 * @param Data A EOS_Mods_UpdateModCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Mods_OnUpdateModCallback, const EOS_Mods_UpdateModCallbackInfo* Data);

#pragma pack(pop)
```

`eac/sdk/Include/eos_p2p.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_p2p_types.h"

/**
 * P2P functions to help manage sending and receiving of messages to peers.
 *
 * These functions will attempt to punch through NATs, but will fallback to using Epic relay servers if a direct connection cannot be established.
 */

/**
 * Send a packet to a peer at the specified address. If there is already an open connection to this peer, it will be
 * sent immediately. If there is no open connection, an attempt to connect to the peer will be made. An EOS_Success
 * result only means the data was accepted to be sent, not that it has been successfully delivered to the peer.
 *
 * @param Options Information about the data being sent, by who, to who
 * @return EOS_EResult::EOS_Success           - If packet was queued to be sent successfully
 *         EOS_EResult::EOS_InvalidParameters - If input was invalid
 *         EOS_EResult::EOS_LimitExceeded     - If amount of data being sent is too large, or the outgoing packet queue was full
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_P2P_SendPacket(EOS_HP2P Handle, const EOS_P2P_SendPacketOptions* Options);

/**
 * Gets the size of the packet that will be returned by ReceivePacket for a particular user, if there is any available
 * packets to be retrieved.
 *
 * @param Options Information about who is requesting the size of their next packet
 * @param OutPacketSizeBytes The amount of bytes required to store the data of the next packet for the requested user
 * @return EOS_EResult::EOS_Success - If OutPacketSizeBytes was successfully set and there is data to be received
 *         EOS_EResult::EOS_InvalidParameters - If input was invalid
 *         EOS_EResult::EOS_NotFound  - If there are no packets available for the requesting user
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_P2P_GetNextReceivedPacketSize(EOS_HP2P Handle, const EOS_P2P_GetNextReceivedPacketSizeOptions* Options, uint32_t* OutPacketSizeBytes);

/**
 * Receive the next packet for the local user, and information associated with this packet, if it exists.
 *
 * @param Options Information about who is requesting the size of their next packet, and how much data can be stored safely
 * @param OutPeerId The Remote User who sent data. Only set if there was a packet to receive.
 * @param OutSocketId The Socket ID of the data that was sent. Only set if there was a packet to receive.
 * @param OutChannel The channel the data was sent on. Only set if there was a packet to receive.
 * @param OutData Buffer to store the data being received. Must be at least EOS_P2P_GetNextReceivedPacketSize in length or data will be truncated
 * @param OutBytesWritten The amount of bytes written to OutData. Only set if there was a packet to receive.
 * @return EOS_EResult::EOS_Success - If the packet was received successfully
 *         EOS_EResult::EOS_InvalidParameters - If input was invalid
 *         EOS_EResult::EOS_NotFound - If there are no packets available for the requesting user
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_P2P_ReceivePacket(EOS_HP2P Handle, const EOS_P2P_ReceivePacketOptions* Options, EOS_ProductUserId* OutPeerId, EOS_P2P_SocketId* OutSocketId, uint8_t* OutChannel, void* OutData, uint32_t* OutBytesWritten);

/**
 * Listen for incoming connection requests on a particular Socket ID, or optionally all Socket IDs. The bound function
 * will only be called if the connection has not already been accepted.
 *
 * @param Options Information about who would like notifications, and (optionally) only for a specific socket
 * @param ClientData This value is returned to the caller when ConnectionRequestHandler is invoked
 * @param ConnectionRequestHandler The callback to be fired when we receive a connection request
 * @return A valid notification ID if successfully bound, or EOS_INVALID_NOTIFICATIONID otherwise
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_P2P_AddNotifyPeerConnectionRequest(EOS_HP2P Handle, const EOS_P2P_AddNotifyPeerConnectionRequestOptions* Options, void* ClientData, EOS_P2P_OnIncomingConnectionRequestCallback ConnectionRequestHandler);

/**
 * Stop listening for connection requests on a previously bound handler.
 *
 * @param NotificationId The previously bound notification ID
 */
EOS_DECLARE_FUNC(void) EOS_P2P_RemoveNotifyPeerConnectionRequest(EOS_HP2P Handle, EOS_NotificationId NotificationId);

/**
 * Listen for when a previously opened connection is closed.
 *
 * @param Options Information about who would like notifications about closed connections, and for which socket
 * @param ClientData This value is returned to the caller when ConnectionClosedHandler is invoked
 * @param ConnectionClosedHandler The callback to be fired when an open connection has been closed
 * @return A valid notification ID if successfully bound, or EOS_INVALID_NOTIFICATIONID otherwise
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_P2P_AddNotifyPeerConnectionClosed(EOS_HP2P Handle, const EOS_P2P_AddNotifyPeerConnectionClosedOptions* Options, void* ClientData, EOS_P2P_OnRemoteConnectionClosedCallback ConnectionClosedHandler);

/**
 * Stop notifications for connections being closed on a previously bound handler.
 *
 * @param NotificationId The previously bound notification ID
 */
EOS_DECLARE_FUNC(void) EOS_P2P_RemoveNotifyPeerConnectionClosed(EOS_HP2P Handle, EOS_NotificationId NotificationId);

/**
 * Listen for when a connection is established.
 *
 * @param Options Information about who would like notifications about established connections, and for which socket
 * @param ClientData This value is returned to the caller when ConnectionEstablishedHandler is invoked
 * @param ConnectionEstablishedHandler The callback to be fired when a connection has been established
 * @return A valid notification ID if successfully bound, or EOS_INVALID_NOTIFICATIONID otherwise
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_P2P_AddNotifyPeerConnectionEstablished(EOS_HP2P Handle, const EOS_P2P_AddNotifyPeerConnectionEstablishedOptions* Options, void* ClientData, EOS_P2P_OnPeerConnectionEstablishedCallback ConnectionEstablishedHandler);

/**
 * Stop notifications for connections being established on a previously bound handler.
 *
 * @param NotificationId The previously bound notification ID
 */
EOS_DECLARE_FUNC(void) EOS_P2P_RemoveNotifyPeerConnectionEstablished(EOS_HP2P Handle, EOS_NotificationId NotificationId);

/**
 * Accept connections from a specific peer. If this peer has not attempted to connect yet, when they do, they will automatically be accepted.
 *
 * @param Options Information about who would like to accept a connection, and which connection
 * @return EOS_EResult::EOS_Success - if the provided data is valid
 *         EOS_EResult::EOS_InvalidParameters - if the provided data is invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_P2P_AcceptConnection(EOS_HP2P Handle, const EOS_P2P_AcceptConnectionOptions* Options);

/**
 * Stop accepting new connections from a specific peer and close any open connections.
 *
 * @param Options Information about who would like to close a connection, and which connection.
 * @return EOS_EResult::EOS_Success - if the provided data is valid
 *         EOS_EResult::EOS_InvalidParameters - if the provided data is invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_P2P_CloseConnection(EOS_HP2P Handle, const EOS_P2P_CloseConnectionOptions* Options);

/**
 * Close any open Connections for a specific Peer Connection ID.
 *
 * @param Options Information about who would like to close connections, and by what socket ID
 * @return EOS_EResult::EOS_Success - if the provided data is valid
 *         EOS_EResult::EOS_InvalidParameters - if the provided data is invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_P2P_CloseConnections(EOS_HP2P Handle, const EOS_P2P_CloseConnectionsOptions* Options);

/**
 * Query the current NAT-type of our connection.
 *
 * @param Options Information about what version of the EOS_P2P_QueryNATType API is supported
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate The callback to be fired when we finish querying our NAT type
 */
EOS_DECLARE_FUNC(void) EOS_P2P_QueryNATType(EOS_HP2P Handle, const EOS_P2P_QueryNATTypeOptions* Options, void* ClientData, const EOS_P2P_OnQueryNATTypeCompleteCallback CompletionDelegate);

/**
 * Get our last-queried NAT-type, if it has been successfully queried.
 *
 * @param Options Information about what version of the EOS_P2P_GetNATType API is supported
 * @param OutNATType The queried NAT Type, or unknown if unknown
 * @return EOS_EResult::EOS_Success - if we have cached data
 *         EOS_EResult::EOS_NotFound - If we do not have queried data cached
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_P2P_GetNATType(EOS_HP2P Handle, const EOS_P2P_GetNATTypeOptions* Options, EOS_ENATType* OutNATType);

/**
 * Set how relay servers are to be used. This setting does not immediately apply to existing connections, but may apply to existing
 * connections if the connection requires renegotiation.
 *
 * @param Options Information about relay server config options
 * @return EOS_EResult::EOS_Success - if the options were set successfully
 *         EOS_EResult::EOS_InvalidParameters - if the options are invalid in some way
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_P2P_SetRelayControl(EOS_HP2P Handle, const EOS_P2P_SetRelayControlOptions* Options);

/**
 * Get the current relay control setting.
 *
 * @param Options Information about what version of the EOS_P2P_GetRelayControl API is supported
 * @param OutRelayControl The relay control setting currently configured
 * @return EOS_EResult::EOS_Success - if the input was valid
 *         EOS_EResult::EOS_InvalidParameters - if the input was invalid in some way
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_P2P_GetRelayControl(EOS_HP2P Handle, const EOS_P2P_GetRelayControlOptions* Options, EOS_ERelayControl* OutRelayControl);

/**
 * Set configuration options related to network ports.
 *
 * @param Options Information about network ports config options
 * @return EOS_EResult::EOS_Success - if the options were set successfully
 *         EOS_EResult::EOS_InvalidParameters - if the options are invalid in some way
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_P2P_SetPortRange(EOS_HP2P Handle, const EOS_P2P_SetPortRangeOptions* Options);

/**
 * Get the current chosen port and the amount of other ports to try above the chosen port if the chosen port is unavailable.
 *
 * @param Options Information about what version of the EOS_P2P_GetPortRange API is supported
 * @param OutPort The port that will be tried first
 * @param OutNumAdditionalPortsToTry The amount of ports to try above the value in OutPort, if OutPort is unavailable
 * @return EOS_EResult::EOS_Success - if the input options were valid
 *         EOS_EResult::EOS_InvalidParameters - if the input was invalid in some way
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_P2P_GetPortRange(EOS_HP2P Handle, const EOS_P2P_GetPortRangeOptions* Options, uint16_t* OutPort, uint16_t* OutNumAdditionalPortsToTry);

/**
 * Sets the maximum packet queue sizes that packets waiting to be sent or received can use. If the packet queue
 * size is made smaller than the current queue size while there are packets in the queue that would push this
 * packet size over, existing packets are kept but new packets may not be added to the full queue until enough
 * packets are sent or received.
 *
 * @param Options Information about packet queue size
 * @return EOS_EResult::EOS_Success - if the input options were valid
 *         EOS_EResult::EOS_InvalidParameters - if the input was invalid in some way
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_P2P_SetPacketQueueSize(EOS_HP2P Handle, const EOS_P2P_SetPacketQueueSizeOptions* Options);

/**
 * Gets the current cached information related to the incoming and outgoing packet queues.
 *
 * @param Options Information about what version of the EOS_P2P_GetPacketQueueInfo API is supported
 * @param OutPacketQueueInfo The current information of the incoming and outgoing packet queues
 * @return EOS_EResult::EOS_Success - if the input options were valid
 *         EOS_EResult::EOS_InvalidParameters - if the input was invalid in some way
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_P2P_GetPacketQueueInfo(EOS_HP2P Handle, const EOS_P2P_GetPacketQueueInfoOptions* Options, EOS_P2P_PacketQueueInfo* OutPacketQueueInfo);

/**
 * Listen for when our packet queue has become full. This event gives an opportunity to read packets to make
 * room for new incoming packets. If this event fires and no packets are read by calling EOS_P2P_ReceivePacket
 * or the packet queue size is not increased by EOS_P2P_SetPacketQueueSize, any packets that are received after
 * this event are discarded until there is room again in the queue.
 *
 * @param Options Information about what version of the EOS_P2P_AddNotifyIncomingPacketQueueFull API is supported
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param IncomingPacketQueueFullHandler The callback to be fired when the incoming packet queue is full
 * @return A valid notification ID if successfully bound, or EOS_INVALID_NOTIFICATIONID otherwise
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_P2P_AddNotifyIncomingPacketQueueFull(EOS_HP2P Handle, const EOS_P2P_AddNotifyIncomingPacketQueueFullOptions* Options, void* ClientData, EOS_P2P_OnIncomingPacketQueueFullCallback IncomingPacketQueueFullHandler);

/**
 * Stop listening for full incoming packet queue events on a previously bound handler.
 *
 * @param NotificationId The previously bound notification ID
 */
EOS_DECLARE_FUNC(void) EOS_P2P_RemoveNotifyIncomingPacketQueueFull(EOS_HP2P Handle, EOS_NotificationId NotificationId);

/**
 * Clear queued incoming and outgoing packets.
 *
 * @param Options Information about which queues should be cleared
 * @return EOS_EResult::EOS_Success - if the input options were valid (even if queues were empty and no packets where cleared)
 *         EOS_EResult::EOS_IncompatibleVersion - if wrong API version
 *         EOS_EResult::EOS_InvalidUser - if wrong local and/or remote user
 *         EOS_EResult::EOS_InvalidParameters - if input was invalid in other way
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_P2P_ClearPacketQueue(EOS_HP2P Handle, const EOS_P2P_ClearPacketQueueOptions* Options);

```

`eac/sdk/Include/eos_p2p_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

EXTERN_C typedef struct EOS_P2PHandle* EOS_HP2P;

/**
 * A packet's maximum size in bytes
 */
#define EOS_P2P_MAX_PACKET_SIZE 1170

/**
 * The maximum amount of unique Socket ID connections that can be opened with each remote user. As this limit is only per remote user, you may have more
 * than this number of Socket IDs across multiple remote users.
 */
#define EOS_P2P_MAX_CONNECTIONS 32

/**
 * Categories of NAT strictness.
 */
EOS_ENUM(EOS_ENATType,
	/** NAT type either unknown (remote) or we are unable to determine it (local) */
	EOS_NAT_Unknown = 0,
	/** All peers can directly-connect to you */
	EOS_NAT_Open = 1,
	/** You can directly-connect to other Moderate and Open peers */
	EOS_NAT_Moderate = 2,
	/** You can only directly-connect to Open peers */
	EOS_NAT_Strict = 3
);

/** The most recent version of the EOS_P2P_SocketId structure. */
#define EOS_P2P_SOCKETID_API_LATEST 1

/**
 * P2P Socket ID
 *
 * The Socket ID contains an application-defined name for the connection between a local person and another peer.
 *
 * When a remote user receives a connection request from you, they will receive this information.  It can be important
 * to only accept connections with a known socket-name and/or from a known user, to prevent leaking of private
 * information, such as a user's IP address. Using the socket name as a secret key can help prevent such leaks. Shared
 * private data, like a private match's Session ID are good candidates for a socket name.
 */
EOS_STRUCT(EOS_P2P_SocketId, (
	/** API Version: Set this to EOS_P2P_SOCKETID_API_LATEST. */
	int32_t ApiVersion;
	/** A name for the connection. Must be a NULL-terminated string of between 1-32 alpha-numeric characters (A-Z, a-z, 0-9) */
	char SocketName[33];
));

/**
 * Types of packet reliability.
 *
 * Ordered packets will only be ordered relative to other ordered packets. Reliable/unreliable and ordered/unordered communication
 * can be sent on the same Socket ID and Channel.
 */
EOS_ENUM(EOS_EPacketReliability,
	/** Packets will only be sent once and may be received out of order */
	EOS_PR_UnreliableUnordered = 0,
	/** Packets may be sent multiple times and may be received out of order */
	EOS_PR_ReliableUnordered = 1,
	/** Packets may be sent multiple times and will be received in order */
	EOS_PR_ReliableOrdered = 2
);

/** The most recent version of the EOS_P2P_SendPacket API. */
#define EOS_P2P_SENDPACKET_API_LATEST 2

/**
 * Structure containing information about the data being sent and to which player
 */
EOS_STRUCT(EOS_P2P_SendPacketOptions, (
	/** API Version: Set this to EOS_P2P_SENDPACKET_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user who is sending this packet */
	EOS_ProductUserId LocalUserId;
	/** The Product User ID of the Peer you would like to send a packet to */
	EOS_ProductUserId RemoteUserId;
	/** The socket ID for data you are sending in this packet */
	const EOS_P2P_SocketId* SocketId;
	/** Channel associated with this data */
	uint8_t Channel;
	/** The size of the data to be sent to the RemoteUser */
	uint32_t DataLengthBytes;
	/** The data to be sent to the RemoteUser */
	const void* Data;
	/** If false and we do not already have an established connection to the peer, this data will be dropped */
	EOS_Bool bAllowDelayedDelivery;
	/** Setting to control the delivery reliability of this packet */
	EOS_EPacketReliability Reliability;
));

/** The most recent version of the EOS_P2P_GetNextReceivedPacketSize API. */
#define EOS_P2P_GETNEXTRECEIVEDPACKETSIZE_API_LATEST 2

/**
 * Structure containing information about who would like to receive a packet.
 */
EOS_STRUCT(EOS_P2P_GetNextReceivedPacketSizeOptions, (
	/** API Version: Set this to EOS_P2P_GETNEXTRECEIVEDPACKETSIZE_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user who is receiving the packet */
	EOS_ProductUserId LocalUserId;
	/** An optional channel to request the data for. If NULL, we're retrieving the size of the next packet on any channel. */
	const uint8_t* RequestedChannel;

));

/** The most recent version of the EOS_P2P_ReceivePacket API. */
#define EOS_P2P_RECEIVEPACKET_API_LATEST 2

/**
 * Structure containing information about who would like to receive a packet, and how much data can be stored safely.
 */
EOS_STRUCT(EOS_P2P_ReceivePacketOptions, (
	/** API Version: Set this to EOS_P2P_RECEIVEPACKET_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user who is receiving the packet */
	EOS_ProductUserId LocalUserId;
	/** The maximum amount of data in bytes that can be safely copied to OutData in the function call */
	uint32_t MaxDataSizeBytes;
	/** An optional channel to request the data for. If NULL, we're retrieving the next packet on any channel */
	const uint8_t* RequestedChannel;
));

/** The most recent version of the EOS_P2P_AddNotifyPeerConnectionRequest API. */
#define EOS_P2P_ADDNOTIFYPEERCONNECTIONREQUEST_API_LATEST 1

/**
 * Structure containing information about who would like connection notifications, and about which socket.
 */
EOS_STRUCT(EOS_P2P_AddNotifyPeerConnectionRequestOptions, (
	/** API Version: Set this to EOS_P2P_ADDNOTIFYPEERCONNECTIONREQUEST_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user who is listening for incoming connection requests */
	EOS_ProductUserId LocalUserId;
	/** The optional socket ID to listen for, used as a filter for incoming connection requests; If NULL, incoming connection requests will not be filtered */
	const EOS_P2P_SocketId* SocketId;
));

/**
 * Structure containing information about an incoming connection request.
 */
EOS_STRUCT(EOS_P2P_OnIncomingConnectionRequestInfo, (
	/** Client-specified data passed into EOS_Presence_AddNotifyOnPresenceChanged */
	void* ClientData;
	/** The Product User ID of the local user who is being requested to open a P2P session with RemoteUserId */
	EOS_ProductUserId LocalUserId;
	/** The Product User ID of the remote user who requested a peer connection with the local user */
	EOS_ProductUserId RemoteUserId;
	/** The ID of the socket the Remote User wishes to communicate on */
	const EOS_P2P_SocketId* SocketId;
));

/**
 * Callback for information related to incoming connection requests.
 */
EOS_DECLARE_CALLBACK(EOS_P2P_OnIncomingConnectionRequestCallback, const EOS_P2P_OnIncomingConnectionRequestInfo* Data);

/** The most recent version of the EOS_P2P_AddNotifyPeerConnectionClosed API. */
#define EOS_P2P_ADDNOTIFYPEERCONNECTIONCLOSED_API_LATEST 1

/**
 * Structure containing information about who would like notifications about closed connections, and for which socket.
 */
EOS_STRUCT(EOS_P2P_AddNotifyPeerConnectionClosedOptions, (
	/** API Version: Set this to EOS_P2P_ADDNOTIFYPEERCONNECTIONCLOSED_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user who would like notifications */
	EOS_ProductUserId LocalUserId;
	/** The optional socket ID to listen for to be closed. If NULL, this handler will be called for all closed connections */
	const EOS_P2P_SocketId* SocketId;
));

/**
 * Reasons why a P2P connection was closed
 */
EOS_ENUM(EOS_EConnectionClosedReason,
	/** The connection was closed for unknown reasons */
	EOS_CCR_Unknown = 0,
	/** The connection was gracefully closed by the local user */
	EOS_CCR_ClosedByLocalUser = 1,
	/** The connection was gracefully closed by the remote user */
	EOS_CCR_ClosedByPeer = 2,
	/** The connection timed out */
	EOS_CCR_TimedOut = 3,
	/** The connection could not be created due to too many other connections */
	EOS_CCR_TooManyConnections = 4,
	/** The remote user sent an invalid message */
	EOS_CCR_InvalidMessage = 5,
	/** The remote user sent us invalid data */
	EOS_CCR_InvalidData = 6,
	/** We failed to establish a connection with the remote user */
	EOS_CCR_ConnectionFailed = 7,
	/** The connection was unexpectedly closed */
	EOS_CCR_ConnectionClosed = 8,
	/** We failed to negotiate a connection with the remote user */
	EOS_CCR_NegotiationFailed = 9,
	/** There was an unexpected error and the connection cannot continue */
	EOS_CCR_UnexpectedError = 10
);

/**
 * Structure containing information about an connection request that is being closed.
 */
EOS_STRUCT(EOS_P2P_OnRemoteConnectionClosedInfo, (
	/** Client-specified data passed into EOS_Presence_AddNotifyOnPresenceChanged */
	void* ClientData;
	/** The local user who is being notified of a connection being closed */
	EOS_ProductUserId LocalUserId;
	/** The Product User ID of the remote user who this connection was with */
	EOS_ProductUserId RemoteUserId;
	/** The socket ID of the connection being closed */
	const EOS_P2P_SocketId* SocketId;
	/** The reason the connection was closed (if known) */
	EOS_EConnectionClosedReason Reason;
));

/**
 * Callback for information related to open connections being closed.
 */
EOS_DECLARE_CALLBACK(EOS_P2P_OnRemoteConnectionClosedCallback, const EOS_P2P_OnRemoteConnectionClosedInfo* Data);

/** The most recent version of the EOS_P2P_AddNotifyPeerConnectionEstablished API. */
#define EOS_P2P_ADDNOTIFYPEERCONNECTIONESTABLISHED_API_LATEST 1

/**
 * Structure containing information about which connections should be notified
 */
EOS_STRUCT(EOS_P2P_AddNotifyPeerConnectionEstablishedOptions, (
	/** API Version: Set this to EOS_P2P_ADDNOTIFYPEERCONNECTIONESTABLISHED_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user who would like to receive notifications */
	EOS_ProductUserId LocalUserId;
	/** The optional socket ID, used as a filter for established connections. If NULL, this handler will be called for all sockets */
	const EOS_P2P_SocketId* SocketId;
));

/**
 * Type of established connection
 */
EOS_ENUM(EOS_EConnectionEstablishedType,
	/** The connection is brand new */
	EOS_CET_NewConnection = 0,
	/** The connection is reestablished (reconnection) */
	EOS_CET_Reconnection = 1
);

/**
 * Structure containing information about a connection being established
 */
EOS_STRUCT(EOS_P2P_OnPeerConnectionEstablishedInfo, (
	/** Client-specified data passed into EOS_P2P_AddNotifyPeerConnectionEstablishedInfo */
	void* ClientData;
	/** The Product User ID of the local user who is being notified of a connection being established */
	EOS_ProductUserId LocalUserId;
	/** The Product User ID of the remote user who this connection was with */
	EOS_ProductUserId RemoteUserId;
	/** The socket ID of the connection being established */
	const EOS_P2P_SocketId* SocketId;
	/** Information if this is a new connection or reconnection */
	EOS_EConnectionEstablishedType ConnectionType;
));

/**
 * Callback for information related to new connections being established
 */
EOS_DECLARE_CALLBACK(EOS_P2P_OnPeerConnectionEstablishedCallback, const EOS_P2P_OnPeerConnectionEstablishedInfo* Data);

/** The most recent version of the EOS_P2P_AcceptConnection API. */
#define EOS_P2P_ACCEPTCONNECTION_API_LATEST 1

/**
 * Structure containing information about who would like to accept a connection, and which connection.
 */
EOS_STRUCT(EOS_P2P_AcceptConnectionOptions, (
	/** API Version: Set this to EOS_P2P_ACCEPTCONNECTION_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user who is accepting any pending or future connections with RemoteUserId */
	EOS_ProductUserId LocalUserId;
	/** The Product User ID of the remote user who has either sent a connection request or is expected to in the future */
	EOS_ProductUserId RemoteUserId;
	/** The socket ID of the connection to accept on */
	const EOS_P2P_SocketId* SocketId;
));

/** The most recent version of the EOS_P2P_CloseConnection API. */
#define EOS_P2P_CLOSECONNECTION_API_LATEST 1

/**
 * Structure containing information about who would like to close a connection, and which connection.
 */
EOS_STRUCT(EOS_P2P_CloseConnectionOptions, (
	/** API Version: Set this to EOS_P2P_CLOSECONNECTION_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user who would like to close a previously accepted connection (or decline a pending invite) */
	EOS_ProductUserId LocalUserId;
	/** The Product User ID of the remote user to disconnect from (or to reject a pending invite from) */
	EOS_ProductUserId RemoteUserId;
	/** The socket ID of the connection to close (or optionally NULL to not accept any connection requests from the Remote User) */
	const EOS_P2P_SocketId* SocketId;
));

/** The most recent version of the EOS_P2P_CloseConnections API. */
#define EOS_P2P_CLOSECONNECTIONS_API_LATEST 1

/**
 * Structure containing information about who would like to close connections, and by what socket ID
 */
EOS_STRUCT(EOS_P2P_CloseConnectionsOptions, (
	/** API Version: Set this to EOS_P2P_CLOSECONNECTIONS_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user who would like to close all connections that use a particular socket ID */
	EOS_ProductUserId LocalUserId;
	/** The socket ID of the connections to close */
	const EOS_P2P_SocketId* SocketId;
));

/** The most recent version of the EOS_P2P_QueryNATType API. */
#define EOS_P2P_QUERYNATTYPE_API_LATEST 1

/**
 * Structure containing information needed to query NAT-types
 */
EOS_STRUCT(EOS_P2P_QueryNATTypeOptions, (
	/** API Version: Set this to EOS_P2P_QUERYNATTYPE_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Structure containing information about the local network NAT type
 */
EOS_STRUCT(EOS_P2P_OnQueryNATTypeCompleteInfo, (
	/** Result code for the operation. EOS_Success is returned for a successful query, other codes indicate an error */
	EOS_EResult ResultCode;
	/** Client-specified data passed into EOS_P2P_QueryNATType */
	void* ClientData;
	/** The queried NAT type */
	EOS_ENATType NATType;
));

/**
 * Callback for information related to our NAT type query completing.
 */
EOS_DECLARE_CALLBACK(EOS_P2P_OnQueryNATTypeCompleteCallback, const EOS_P2P_OnQueryNATTypeCompleteInfo* Data);

/** The most recent version of the EOS_P2P_GetNATType API. */
#define EOS_P2P_GETNATTYPE_API_LATEST 1

/**
 * Structure containing information needed to get perviously queried NAT-types
 */
EOS_STRUCT(EOS_P2P_GetNATTypeOptions, (
	/** API Version: Set this to EOS_P2P_GETNATTYPE_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Setting for controlling whether relay servers are used
 */
EOS_ENUM(EOS_ERelayControl,
	/** Peer connections will never attempt to use relay servers. Clients with restrictive NATs may not be able to connect to peers. */
	EOS_RC_NoRelays = 0,
	/** Peer connections will attempt to use relay servers, but only after direct connection attempts fail. This is the default value if not changed. */
	EOS_RC_AllowRelays = 1,
	/** Peer connections will only ever use relay servers. This will add latency to all connections, but will hide IP Addresses from peers. */
	EOS_RC_ForceRelays = 2
);

/** The most recent version of the EOS_P2P_SetRelayControl API. */
#define EOS_P2P_SETRELAYCONTROL_API_LATEST 1

/**
 * Structure containing information about new relay configurations.
 */
EOS_STRUCT(EOS_P2P_SetRelayControlOptions, (
	/** API Version: Set this to EOS_P2P_SETRELAYCONTROL_API_LATEST. */
	int32_t ApiVersion;
	/**
	 * The requested level of relay servers for P2P connections. This setting is only applied to new P2P connections, or when existing P2P connections
	 * reconnect during a temporary connectivity outage. Peers with an incompatible setting to the local setting will not be able to connnect.
	 */
	EOS_ERelayControl RelayControl;
));

/** The most recent version of the EOS_P2P_GetRelayControl API. */
#define EOS_P2P_GETRELAYCONTROL_API_LATEST 1

/**
 * Structure containing information about getting the relay control setting.
 */
EOS_STRUCT(EOS_P2P_GetRelayControlOptions, (
	/** API Version: Set this to EOS_P2P_GETRELAYCONTROL_API_LATEST. */
	int32_t ApiVersion;
));

/** The most recent version of the EOS_P2P_SetPortRange API. */
#define EOS_P2P_SETPORTRANGE_API_LATEST 1

/**
 * Structure containing information about new port range settings.
 */
EOS_STRUCT(EOS_P2P_SetPortRangeOptions, (
	/** API Version: Set this to EOS_P2P_SETPORTRANGE_API_LATEST. */
	int32_t ApiVersion;
	/** The ideal port to use for P2P traffic. The default value is 7777. If set to 0, the OS will choose a port. If set to 0, MaxAdditionalPortsToTry must be set to 0. */
	uint16_t Port;
	/**
	 * The maximum amount of additional ports to try if Port is unavailable. Ports will be tried from Port to Port + MaxAdditionalPortsToTry
	 * inclusive, until one is available or we run out of ports. If no ports are available, P2P connections will fail. The default value is 99.
	 */
	uint16_t MaxAdditionalPortsToTry;
));

/** The most recent version of the EOS_P2P_GetPortRange API. */
#define EOS_P2P_GETPORTRANGE_API_LATEST 1

/**
 * Structure containing information about getting the configured port range settings.
 */
EOS_STRUCT(EOS_P2P_GetPortRangeOptions, (
	/** API Version: Set this to EOS_P2P_GETPORTRANGE_API_LATEST. */
	int32_t ApiVersion;
));

/** Helper constant to signify that the packet queue is allowed to grow indefinitely */
#define EOS_P2P_MAX_QUEUE_SIZE_UNLIMITED 0

/** The most recent version of the EOS_P2P_SetPacketQueueSize API. */
#define EOS_P2P_SETPACKETQUEUESIZE_API_LATEST 1

/**
 * Structure containing information about new packet queue size settings.
 */
EOS_STRUCT(EOS_P2P_SetPacketQueueSizeOptions, (
	/** API Version: Set this to EOS_P2P_SETPACKETQUEUESIZE_API_LATEST. */
	int32_t ApiVersion;
	/** The ideal maximum amount of bytes the Incoming packet queue can consume */
	uint64_t IncomingPacketQueueMaxSizeBytes;
	/** The ideal maximum amount of bytes the Outgoing packet queue can consume */
	uint64_t OutgoingPacketQueueMaxSizeBytes;
));

/** The most recent version of the EOS_P2P_GetPacketQueueInfo API. */
#define EOS_P2P_GETPACKETQUEUEINFO_API_LATEST 1

/**
 * Structure containing information needed to get the current packet queue information.
 */
EOS_STRUCT(EOS_P2P_GetPacketQueueInfoOptions, (
	/** API Version: Set this to EOS_P2P_GETPACKETQUEUEINFO_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Information related to the current state of the packet queues. It is possible for the current size
 * to be larger than the maximum size if the maximum size changes or if the maximum queue size is
 * set to EOS_P2P_MAX_QUEUE_SIZE_UNLIMITED.
 */
EOS_STRUCT(EOS_P2P_PacketQueueInfo, (
	/** The maximum size in bytes of the incoming packet queue */
	uint64_t IncomingPacketQueueMaxSizeBytes;
	/** The current size in bytes of the incoming packet queue */
	uint64_t IncomingPacketQueueCurrentSizeBytes;
	/** The current number of queued packets in the incoming packet queue */
	uint64_t IncomingPacketQueueCurrentPacketCount;
	/** The maximum size in bytes of the outgoing packet queue */
	uint64_t OutgoingPacketQueueMaxSizeBytes;
	/** The current size in bytes of the outgoing packet queue */
	uint64_t OutgoingPacketQueueCurrentSizeBytes;
	/** The current amount of queued packets in the outgoing packet queue */
	uint64_t OutgoingPacketQueueCurrentPacketCount;
));

/** The most recent version of the EOS_P2P_AddNotifyIncomingPacketQueueFull API. */
#define EOS_P2P_ADDNOTIFYINCOMINGPACKETQUEUEFULL_API_LATEST 1

/**
 * Structure containing information about what version of the EOS_P2P_AddNotifyIncomingPacketQueueFull function is supported.
 */
EOS_STRUCT(EOS_P2P_AddNotifyIncomingPacketQueueFullOptions, (
	/** API Version: Set this to EOS_P2P_ADDNOTIFYINCOMINGPACKETQUEUEFULL_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Structure containing information about the packet queue's state and the incoming packet that would overflow the queue
 */
EOS_STRUCT(EOS_P2P_OnIncomingPacketQueueFullInfo, (
	/** Client-specified data passed into AddNotifyIncomingPacketQueueFull */
	void* ClientData;
	/** The maximum size in bytes the incoming packet queue is allowed to use */
	uint64_t PacketQueueMaxSizeBytes;
	/** The current size in bytes the incoming packet queue is currently using */
	uint64_t PacketQueueCurrentSizeBytes;
	/** The Product User ID of the local user who is receiving the packet that would overflow the queue */
	EOS_ProductUserId OverflowPacketLocalUserId;
	/** The channel the incoming packet is for */
	uint8_t OverflowPacketChannel;
	/** The size in bytes of the incoming packet (and related metadata) that would overflow the queue */
	uint32_t OverflowPacketSizeBytes;
));

/**
 * Callback for information related to incoming connection requests.
 */
EOS_DECLARE_CALLBACK(EOS_P2P_OnIncomingPacketQueueFullCallback, const EOS_P2P_OnIncomingPacketQueueFullInfo* Data);

/** The most recent version of the EOS_P2P_ClearPacketQueue API. */
#define EOS_P2P_CLEARPACKETQUEUE_API_LATEST 1

/**
 * Structure containing information about the packet queue to be cleared
 */
EOS_STRUCT(EOS_P2P_ClearPacketQueueOptions, (
	/** API Version: Set this to EOS_P2P_CLEARPACKETQUEUE_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user for whom we want to clear the queued packets */
	EOS_ProductUserId LocalUserId;
	/** The Product User ID to who (outgoing) or from who (incoming) packets are queued */
	EOS_ProductUserId RemoteUserId;
	/** The socket used for packets to be cleared */
	const EOS_P2P_SocketId* SocketId;
));

#pragma pack(pop)

```

`eac/sdk/Include/eos_platform_prereqs.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

/******************************************************************************
 *
 * Please refer to https://dev.epicgames.com/docs/services for more details
 * on platform specific development.
 *
 * Some platforms need additional setup before `eos_base.h` is called.
 * The `eos_base.h` header is included by all EOS SDK headers.  This header
 * file provides one way of allowing cross platform development with minimal
 * setup.
 *
 * To use this add the EOS_BUILD_PLATFORM_NAME define when building platforms
 * which need to include a `<Platform>/eos_<Platform>_base.h`. The value of
 * EOS_BUILD_PLATFORM_NAME will be placed in the `<Platform>` spot.  Not all
 * platforms need one of these base header files. Blank files are sitll provided
 * for the platforms that do not require it.
 *
 * Alternatives to this header are to have the necessary file explicitly
 * included.  This is a good solution if only a single platform is needed.
 * For example:
 *   #include "ThePlatform/eos_ThePlatform_base.h"
 *   #include "eos_sdk.h"
 *   #include "eos_friends_types.h"
 *
 * Another option is to use the macros provided by the custom compiler to
 * determine which include to use.
 * For example:
 *   #if defined(__THECOMPILER__)
 *   #include "ThePlatform/eos_ThePlatform_base.h"
 *   #elif defined(__SOMECOMPILER__)
 *   #include "SomePlatform/eos_SomePlatform_base.h"
 *   #endif
 *   #include "eos_sdk.h"
 *   #include "eos_friends_types.h"
 *
 ******************************************************************************/

#if defined(EOS_BUILD_PLATFORM_NAME)

#if defined(EOS_USE_DLLEXPORT) || defined(USE_CALL) || defined(EOS_MEMORY_CALL)
#error \
The macros EOS_MEMORY_CALL, EOS_CALL, and EOS_USE_DLLEXPORT where unexpectedly partially defined. \
This can occur if `eos_platform_prereqs.h` is included after `eos_base.h` is included. \
Please refer to https://dev.epicgames.com/docs/services for more details.
#endif

#define EOS_PREPROCESSOR_TO_STRING(x) EOS_PREPROCESSOR_TO_STRING_INNER(x)
#define EOS_PREPROCESSOR_TO_STRING_INNER(x) #x
#define EOS_PREPROCESSOR_JOIN(x,y) EOS_PREPROCESSOR_JOIN_INNER(x,y)
#define EOS_PREPROCESSOR_JOIN_INNER(x,y) x##y
#define EOS_BUILD_PLATFORM_HEADER_BASE EOS_PREPROCESSOR_TO_STRING(EOS_PREPROCESSOR_JOIN(EOS_BUILD_PLATFORM_NAME/eos_,EOS_PREPROCESSOR_JOIN(EOS_BUILD_PLATFORM_NAME,_base.h)))

#include EOS_BUILD_PLATFORM_HEADER_BASE

#endif


```

`eac/sdk/Include/eos_playerdatastorage.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_playerdatastorage_types.h"

/**
 * The following EOS_PlayerDataStorage_* functions allow you to query file metadata; create/upload files; and duplicate, read, and delete existing files
 */

/**
 * Query a specific file's metadata, such as file names, size, and a MD5 hash of the data. This is not required before a file may be opened, saved, copied, or deleted. Once a file has
 * been queried, its metadata will be available by the EOS_PlayerDataStorage_CopyFileMetadataAtIndex and EOS_PlayerDataStorage_CopyFileMetadataByFilename functions.
 *
 * @param QueryFileOptions Object containing properties related to which user is querying files, and what file is being queried
 * @param ClientData Optional pointer to help clients track this request, that is returned in the completion callback
 * @param CompletionCallback This function is called when the query operation completes
 *
 * @see EOS_PlayerDataStorage_GetFileMetadataCount
 * @see EOS_PlayerDataStorage_CopyFileMetadataAtIndex
 * @see EOS_PlayerDataStorage_CopyFileMetadataByFilename
 */
EOS_DECLARE_FUNC(void) EOS_PlayerDataStorage_QueryFile(EOS_HPlayerDataStorage Handle, const EOS_PlayerDataStorage_QueryFileOptions* QueryFileOptions, void* ClientData, const EOS_PlayerDataStorage_OnQueryFileCompleteCallback CompletionCallback);

/**
 * Query the file metadata, such as file names, size, and a MD5 hash of the data, for all files owned by this user for this application. This is not required before a file may be opened,
 * saved, copied, or deleted.
 *
 * @param QueryFileListOptions Object containing properties related to which user is querying files
 * @param ClientData Optional pointer to help clients track this request, that is returned in the completion callback
 * @param CompletionCallback This function is called when the query operation completes
 *
 * @see EOS_PlayerDataStorage_GetFileMetadataCount
 * @see EOS_PlayerDataStorage_CopyFileMetadataAtIndex
 * @see EOS_PlayerDataStorage_CopyFileMetadataByFilename
 */
EOS_DECLARE_FUNC(void) EOS_PlayerDataStorage_QueryFileList(EOS_HPlayerDataStorage Handle, const EOS_PlayerDataStorage_QueryFileListOptions* QueryFileListOptions, void* ClientData, const EOS_PlayerDataStorage_OnQueryFileListCompleteCallback CompletionCallback);

/**
 * Create the cached copy of a file's metadata by filename. The metadata will be for the last retrieved or successfully saved version, and will not include any changes that have not
 * completed writing. The returned pointer must be released by the user when no longer needed.
 *
 * @param CopyFileMetadataOptions Object containing properties related to which user is requesting metadata, and for which filename
 * @param OutMetadata A copy of the FileMetadata structure will be set if successful.  This data must be released by calling EOS_PlayerDataStorage_FileMetadata_Release.
 * @return EOS_EResult::EOS_Success if the metadata is currently cached, otherwise an error result explaining what went wrong
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_PlayerDataStorage_CopyFileMetadataByFilename(EOS_HPlayerDataStorage Handle, const EOS_PlayerDataStorage_CopyFileMetadataByFilenameOptions* CopyFileMetadataOptions, EOS_PlayerDataStorage_FileMetadata ** OutMetadata);

/**
 * Get the count of files we have previously queried information for and files we have previously read from / written to.
 *
 * @param GetFileMetadataCountOptions Object containing properties related to which user is requesting the metadata count
 * @param OutFileMetadataCount If successful, the count of metadata currently cached
 * @return EOS_EResult::EOS_Success if the input was valid, otherwise an error result explaining what went wrong
 *
 * @see EOS_PlayerDataStorage_CopyFileMetadataAtIndex
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_PlayerDataStorage_GetFileMetadataCount(EOS_HPlayerDataStorage Handle, const EOS_PlayerDataStorage_GetFileMetadataCountOptions* GetFileMetadataCountOptions, int32_t* OutFileMetadataCount);

/**
 * Get the cached copy of a file's metadata by index. The metadata will be for the last retrieved or successfully saved version, and will not include any local changes that have not been
 * committed by calling SaveFile. The returned pointer must be released by the user when no longer needed.
 *
 * @param CopyFileMetadataOptions Object containing properties related to which user is requesting metadata, and at what index
 * @param OutMetadata A copy of the FileMetadata structure will be set if successful.  This data must be released by calling EOS_PlayerDataStorage_FileMetadata_Release.
 * @return EOS_EResult::EOS_Success if the requested metadata is currently cached, otherwise an error result explaining what went wrong
 *
 * @see EOS_PlayerDataStorage_GetFileMetadataCount
 * @see EOS_PlayerDataStorage_FileMetadata_Release
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_PlayerDataStorage_CopyFileMetadataAtIndex(EOS_HPlayerDataStorage Handle, const EOS_PlayerDataStorage_CopyFileMetadataAtIndexOptions* CopyFileMetadataOptions, EOS_PlayerDataStorage_FileMetadata ** OutMetadata);

/**
 * Copies the data of an existing file to a new filename. This action happens entirely on the server and will not upload the contents of the source destination file from the host. This
 * function paired with a subsequent EOS_PlayerDataStorage_DeleteFile can be used to rename a file. If successful, the destination file's metadata will be updated in our local cache.
 *
 * @param DuplicateOptions Object containing properties related to which user is duplicating the file, and what the source and destination file names are
 * @param ClientData Optional pointer to help clients track this request, that is returned in the completion callback
 * @param CompletionCallback This function is called when the duplicate operation completes
 *
 */
EOS_DECLARE_FUNC(void) EOS_PlayerDataStorage_DuplicateFile(EOS_HPlayerDataStorage Handle, const EOS_PlayerDataStorage_DuplicateFileOptions* DuplicateOptions, void* ClientData, const EOS_PlayerDataStorage_OnDuplicateFileCompleteCallback CompletionCallback);

/**
 * Deletes an existing file in the cloud. If successful, the file's data will be removed from our local cache.
 *
 * @param DeleteOptions Object containing properties related to which user is deleting the file, and what file name is
 * @param ClientData Optional pointer to help clients track this request, that is returned in the completion callback
 * @param CompletionCallback This function is called when the delete operation completes
 */
EOS_DECLARE_FUNC(void) EOS_PlayerDataStorage_DeleteFile(EOS_HPlayerDataStorage Handle, const EOS_PlayerDataStorage_DeleteFileOptions* DeleteOptions, void* ClientData, const EOS_PlayerDataStorage_OnDeleteFileCompleteCallback CompletionCallback);

/**
 * Retrieve the contents of a specific file, potentially downloading the contents if we do not have a local copy, from the cloud. This request will occur asynchronously, potentially over
 * multiple frames. All callbacks for this function will come from the same thread that the SDK is ticked from. If specified, the FileTransferProgressCallback will always be called at
 * least once if the request is started successfully.
 *
 * @param ReadOptions Object containing properties related to which user is opening the file, what the file's name is, and related mechanisms for copying the data
 * @param ClientData Optional pointer to help clients track this request, that is returned in associated callbacks
 * @param CompletionCallback This function is called when the read operation completes
 * @return A valid Player Data Storage File Request handle if successful, or NULL otherwise. Data contained in the completion callback will have more detailed information about issues with the request in failure cases. This handle must be released when it is no longer needed
 *
 * @see EOS_PlayerDataStorageFileTransferRequest_Release
 */
EOS_DECLARE_FUNC(EOS_HPlayerDataStorageFileTransferRequest) EOS_PlayerDataStorage_ReadFile(EOS_HPlayerDataStorage Handle, const EOS_PlayerDataStorage_ReadFileOptions* ReadOptions, void* ClientData, const EOS_PlayerDataStorage_OnReadFileCompleteCallback CompletionCallback);

/**
 * Write new data to a specific file, potentially overwriting any existing file by the same name, to the cloud. This request will occur asynchronously, potentially over multiple frames.
 * All callbacks for this function will come from the same thread that the SDK is ticked from. If specified, the FileTransferProgressCallback will always be called at least once if the
 * request is started successfully.
 *
 * @param WriteOptions Object containing properties related to which user is writing the file, what the file's name is, and related mechanisms for writing the data
 * @param ClientData Optional pointer to help clients track this request, that is returned in associated callbacks
 * @param CompletionCallback This function is called when the write operation completes
 * @return A valid Player Data Storage File Request handle if successful, or NULL otherwise. Data contained in the completion callback will have more detailed information about issues with the request in failure cases. This handle must be released when it is no longer needed
 *
 * @see EOS_PlayerDataStorageFileTransferRequest_Release
 */
EOS_DECLARE_FUNC(EOS_HPlayerDataStorageFileTransferRequest) EOS_PlayerDataStorage_WriteFile(EOS_HPlayerDataStorage Handle, const EOS_PlayerDataStorage_WriteFileOptions* WriteOptions, void* ClientData, const EOS_PlayerDataStorage_OnWriteFileCompleteCallback CompletionCallback);

/**
 * Clear previously cached file data. This operation will be done asynchronously. All cached files except those corresponding to the transfers in progress will be removed.
 * Warning: Use this with care. Cache system generally tries to clear old and unused cached files from time to time. Unnecessarily clearing cache can degrade performance as SDK will have to re-download data.
 *
 * @param Options Object containing properties related to which user is deleting cache
 * @param ClientData Optional pointer to help clients track this request, that is returned in associated callbacks
 * @param CompletionCallback This function is called when the delete cache operation completes
 * @return EOS_Success if the operation was started correctly, otherwise an error result explaining what went wrong
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_PlayerDataStorage_DeleteCache(EOS_HPlayerDataStorage Handle, const EOS_PlayerDataStorage_DeleteCacheOptions* Options, void* ClientData, const EOS_PlayerDataStorage_OnDeleteCacheCompleteCallback CompletionCallback);

/**
 * Below are helper functions to retrieve information about a file request handle, or to attempt to cancel a request in progress.
 */

/**
 * Get the current state of a file request.
 *
 * @return EOS_Success if complete and successful, EOS_PlayerDataStorage_RequestInProgress if the request is still in progress, or another state for failure.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_PlayerDataStorageFileTransferRequest_GetFileRequestState(EOS_HPlayerDataStorageFileTransferRequest Handle);

/**
 * Get the file name of the file this request is for. OutStringLength will always be set to the string length of the file name if it is not NULL.
 *
 * @param FilenameStringBufferSizeBytes The maximum number of bytes that can be written to OutStringBuffer
 * @param OutStringBuffer The buffer to write the NULL-terminated utf8 file name into, if successful
 * @param OutStringLength How long the file name is (not including null terminator)
 * @return EOS_Success if the file name was successfully written to OutFilenameBuffer, a failure result otherwise
 *
 * @see EOS_PLAYERDATASTORAGE_FILENAME_MAX_LENGTH_BYTES
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_PlayerDataStorageFileTransferRequest_GetFilename(EOS_HPlayerDataStorageFileTransferRequest Handle, uint32_t FilenameStringBufferSizeBytes, char* OutStringBuffer, int32_t* OutStringLength);

/**
 * Attempt to cancel this file request in progress. This is a best-effort command and is not guaranteed to be successful if the request has completed before this function is called.
 *
 * @return EOS_Success if cancel is successful, EOS_NoChange if request had already completed (can't be canceled), EOS_AlreadyPending if it's already been canceled before (this is a final state for canceled request and won't change over time).
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_PlayerDataStorageFileTransferRequest_CancelRequest(EOS_HPlayerDataStorageFileTransferRequest Handle);

```

`eac/sdk/Include/eos_playerdatastorage_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

/** Maximum File Name Length in bytes */
#define EOS_PLAYERDATASTORAGE_FILENAME_MAX_LENGTH_BYTES 64

/** Maximum File size in bytes*/
#define EOS_PLAYERDATASTORAGE_FILE_MAX_SIZE_BYTES (64 * 1024 * 1024)

EXTERN_C typedef struct EOS_PlayerDataStorageHandle* EOS_HPlayerDataStorage;

#define EOS_PLAYERDATASTORAGE_FILEMETADATA_API_LATEST 3

/**
 * Metadata information for a specific file
 */
EOS_STRUCT(EOS_PlayerDataStorage_FileMetadata, (
	/** API Version: Set this to EOS_PLAYERDATASTORAGE_FILEMETADATA_API_LATEST. */
	int32_t ApiVersion;
	/** The total size of the file in bytes (Includes file header in addition to file contents) */
	uint32_t FileSizeBytes;
	/** The MD5 Hash of the entire file (including additional file header), in hex digits */
	const char* MD5Hash;
	/** The file's name */
	const char* Filename;
	/** The POSIX timestamp when the file was saved last time. */
	int64_t LastModifiedTime;
	/** The size of data (payload) in file in unencrypted (original) form.  */
	uint32_t UnencryptedDataSizeBytes;
));

/**
 * Free the memory used by the file metadata
 */
EOS_DECLARE_FUNC(void) EOS_PlayerDataStorage_FileMetadata_Release(EOS_PlayerDataStorage_FileMetadata* FileMetadata);


#define EOS_PLAYERDATASTORAGE_QUERYFILEOPTIONS_API_LATEST 1

/**
 * Input data for the EOS_PlayerDataStorage_QueryFile function
 */
EOS_STRUCT(EOS_PlayerDataStorage_QueryFileOptions, (
	/** API Version: Set this to EOS_PLAYERDATASTORAGE_QUERYFILEOPTIONS_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user requesting file metadata */
	EOS_ProductUserId LocalUserId;
	/** The name of the file being queried */
	const char* Filename;
));

/**
 * Data containing information about a query file request
 */
EOS_STRUCT(EOS_PlayerDataStorage_QueryFileCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned for a successful request, other codes indicate an error */
	EOS_EResult ResultCode;
	/** Client-specified data passed into the file query request */
	void* ClientData;
	/** The Product User ID of the local user who initiated this request */
	EOS_ProductUserId LocalUserId;
));
/**
 * Callback for when EOS_PlayerDataStorage_QueryFile completes
 */
EOS_DECLARE_CALLBACK(EOS_PlayerDataStorage_OnQueryFileCompleteCallback, const EOS_PlayerDataStorage_QueryFileCallbackInfo* Data);


#define EOS_PLAYERDATASTORAGE_QUERYFILELISTOPTIONS_API_LATEST 1

/**
 * Input data for the EOS_PlayerDataStorage_QueryFileList function
 */
EOS_STRUCT(EOS_PlayerDataStorage_QueryFileListOptions, (
	/** API Version: Set this to EOS_PLAYERDATASTORAGE_QUERYFILELISTOPTIONS_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user who requested file metadata */
	EOS_ProductUserId LocalUserId;
));

/**
 * Data containing information about a query file list request
 */
EOS_STRUCT(EOS_PlayerDataStorage_QueryFileListCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned for a successful request, other codes indicate an error */
	EOS_EResult ResultCode;
	/** Client-specified data passed into the file query request */
	void* ClientData;
	/** The Product User ID of the local user who initiated this request */
	EOS_ProductUserId LocalUserId;
	/** A count of files that were found, if successful */
	uint32_t FileCount;
));
/**
 * Callback for when EOS_PlayerDataStorage_QueryFileList completes
 */
EOS_DECLARE_CALLBACK(EOS_PlayerDataStorage_OnQueryFileListCompleteCallback, const EOS_PlayerDataStorage_QueryFileListCallbackInfo* Data);


#define EOS_PLAYERDATASTORAGE_GETFILEMETADATACOUNTOPTIONS_API_LATEST 1

/**
 * Input data for the EOS_PlayerDataStorage_GetFileMetadataCount function
 */
EOS_STRUCT(EOS_PlayerDataStorage_GetFileMetadataCountOptions, (
	/** API Version: Set this to EOS_PLAYERDATASTORAGE_GETFILEMETADATACOUNTOPTIONS_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user who is requesting file metadata */
	EOS_ProductUserId LocalUserId;
));


#define EOS_PLAYERDATASTORAGE_COPYFILEMETADATAATINDEXOPTIONS_API_LATEST 1

/**
 * Input data for the CopyFileMetadataAtIndex function
 */
EOS_STRUCT(EOS_PlayerDataStorage_CopyFileMetadataAtIndexOptions, (
	/** API Version: Set this to EOS_PLAYERDATASTORAGE_COPYFILEMETADATAATINDEXOPTIONS_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user who is requesting file metadata */
	EOS_ProductUserId LocalUserId;
	/** The index to get data for */
	uint32_t Index;
));


#define EOS_PLAYERDATASTORAGE_COPYFILEMETADATABYFILENAMEOPTIONS_API_LATEST 1

/**
 * Input data for the CopyFileMetadataByFilename function
 */
EOS_STRUCT(EOS_PlayerDataStorage_CopyFileMetadataByFilenameOptions, (
	/** API Version: Set this to EOS_PLAYERDATASTORAGE_COPYFILEMETADATABYFILENAMEOPTIONS_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user who is requesting file metadata */
	EOS_ProductUserId LocalUserId;
	/** The file's name to get data for */
	const char* Filename;
));


#define EOS_PLAYERDATASTORAGE_DUPLICATEFILEOPTIONS_API_LATEST 1

/**
 * Input data for the EOS_PlayerDataStorage_DuplicateFile function
 */
EOS_STRUCT(EOS_PlayerDataStorage_DuplicateFileOptions, (
	/** API Version: Set this to EOS_PLAYERDATASTORAGE_DUPLICATEFILEOPTIONS_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user who authorized the duplication of the requested file; must be the original file's owner */
	EOS_ProductUserId LocalUserId;
	/** The name of the existing file to duplicate */
	const char* SourceFilename;
	/** The name of the new file */
	const char* DestinationFilename;
));

/**
 * Data containing the result information for a duplicate file request
 */
EOS_STRUCT(EOS_PlayerDataStorage_DuplicateFileCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned for a successful request, other codes indicate an error */
	EOS_EResult ResultCode;
	/** Client-specified data passed into the file duplicate request */
	void* ClientData;
	/** The Product User ID of the local user who initiated this request */
	EOS_ProductUserId LocalUserId;
));

/**
 * Callback for when EOS_PlayerDataStorage_DuplicateFile completes
 */
EOS_DECLARE_CALLBACK(EOS_PlayerDataStorage_OnDuplicateFileCompleteCallback, const EOS_PlayerDataStorage_DuplicateFileCallbackInfo* Data);


#define EOS_PLAYERDATASTORAGE_DELETEFILEOPTIONS_API_LATEST 1

/**
 * Input data for the EOS_PlayerDataStorage_DeleteFile function
 */
EOS_STRUCT(EOS_PlayerDataStorage_DeleteFileOptions, (
	/** API Version: Set this to EOS_PLAYERDATASTORAGE_DELETEFILEOPTIONS_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user who authorizes deletion of the file; must be the file's owner */
	EOS_ProductUserId LocalUserId;
	/** The name of the file to delete */
	const char* Filename;
));

/**
 * Data containing the result information for a delete file request
 */
EOS_STRUCT(EOS_PlayerDataStorage_DeleteFileCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned for a successful request, other codes indicate an error */
	EOS_EResult ResultCode;
	/** Client-specified data passed into the file deletion request */
	void* ClientData;
	/** The Product User ID of the local user who initiated this request */
	EOS_ProductUserId LocalUserId;
));

/**
 * Callback for when EOS_PlayerDataStorage_DeleteFile completes
 */
EOS_DECLARE_CALLBACK(EOS_PlayerDataStorage_OnDeleteFileCompleteCallback, const EOS_PlayerDataStorage_DeleteFileCallbackInfo* Data);

/**
 * Handle type to a File Request
 */
EXTERN_C typedef struct EOS_PlayerDataStorageFileTransferRequestHandle* EOS_HPlayerDataStorageFileTransferRequest;

/**
 * Free the memory used by a cloud-storage file request handle. This will not cancel a request in progress.
 */
EOS_DECLARE_FUNC(void) EOS_PlayerDataStorageFileTransferRequest_Release(EOS_HPlayerDataStorageFileTransferRequest PlayerDataStorageFileTransferHandle);


/**
 * Data containing the information about a file transfer in progress (or one that has completed)
 */
EOS_STRUCT(EOS_PlayerDataStorage_FileTransferProgressCallbackInfo, (
	/** Client-specified data passed into the file request */
	void* ClientData;
	/** The Product User ID of the local user who initiated this request */
	EOS_ProductUserId LocalUserId;
	/** The file name of the file being transferred */
	const char* Filename;
	/** Amount of bytes transferred so far in this request, out of TotalFileSizeBytes */
	uint32_t BytesTransferred;
	/** The total size of the file being transferred (Includes file header in addition to file contents, can be slightly more than expected) */
	uint32_t TotalFileSizeBytes;
));

/**
 * Callback for when there is a progress update for a file transfer in progress
 */
EOS_DECLARE_CALLBACK(EOS_PlayerDataStorage_OnFileTransferProgressCallback, const EOS_PlayerDataStorage_FileTransferProgressCallbackInfo* Data);


/**
 * Return results for EOS_PlayerDataStorage_OnReadFileDataCallback callbacks to return
 */
EOS_ENUM(EOS_PlayerDataStorage_EReadResult,
	/** Signifies the data was read successfully, and we should continue to the next chunk if possible */
	EOS_RR_ContinueReading = 1,
	/** Signifies there was a failure reading the data, and the request should end */
	EOS_RR_FailRequest = 2,
	/** Signifies the request should be cancelled, but not due to an error */
	EOS_RR_CancelRequest = 3
);

/**
 * Data containing data for a chunk of a file being read
 */
EOS_STRUCT(EOS_PlayerDataStorage_ReadFileDataCallbackInfo, (
	/** Client-specified data passed into the file request */
	void* ClientData;
	/** The Product User ID of the local user who initiated this request */
	EOS_ProductUserId LocalUserId;
	/** The file name being read */
	const char* Filename;
	/** The total file size of the file being read */
	uint32_t TotalFileSizeBytes;
	/** Is this chunk the last chunk of data? */
	EOS_Bool bIsLastChunk;
	/** The length of DataChunk in bytes that can be safely read */
	uint32_t DataChunkLengthBytes;
	/** Pointer to the start of data to be read */
	const void* DataChunk;
));

/**
 * Callback for when we have data ready to be read from the requested file. It is undefined how often this will be called during a single tick.
 *
 * @param Data Struct containing a chunk of data to read, as well as some metadata for the file being read
 * @return The result of the read operation. If this value is not EOS_RR_ContinueReading, this callback will not be called again for the same request
 */
EOS_DECLARE_CALLBACK_RETVALUE(EOS_PlayerDataStorage_EReadResult, EOS_PlayerDataStorage_OnReadFileDataCallback, const EOS_PlayerDataStorage_ReadFileDataCallbackInfo* Data);

#define EOS_PLAYERDATASTORAGE_READFILEOPTIONS_API_LATEST 1

/**
 * Input data for the EOS_PlayerDataStorage_ReadFile function
 */
EOS_STRUCT(EOS_PlayerDataStorage_ReadFileOptions, (
	/** API Version: Set this to EOS_PLAYERDATASTORAGE_READFILEOPTIONS_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user who is reading the requested file */
	EOS_ProductUserId LocalUserId;
	/** The file name to read; this file must already exist */
	const char* Filename;
	/** The maximum amount of data in bytes should be available to read in a single EOS_PlayerDataStorage_OnReadFileDataCallback call */
	uint32_t ReadChunkLengthBytes;
	/** Callback function that handles data as it comes in, and can stop the transfer early */
	EOS_PlayerDataStorage_OnReadFileDataCallback ReadFileDataCallback;
	/** Optional callback function to be informed of download progress, if the file is not already locally cached; if provided, this will be called at least once before completion if the request is successfully started */
	EOS_PlayerDataStorage_OnFileTransferProgressCallback FileTransferProgressCallback;
));


/**
 * Data containing the result of a read file request
 */
EOS_STRUCT(EOS_PlayerDataStorage_ReadFileCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned for a successful request, other codes indicate an error */
	EOS_EResult ResultCode;
	/** Client-specified data passed into the file read request */
	void* ClientData;
	/** The Product User ID of the local user who initiated this request */
	EOS_ProductUserId LocalUserId;
	/** The filename of the file that has been finished reading */
	const char* Filename;
));

/**
 * Callback for when EOS_PlayerDataStorage_ReadFile completes
 */
EOS_DECLARE_CALLBACK(EOS_PlayerDataStorage_OnReadFileCompleteCallback, const EOS_PlayerDataStorage_ReadFileCallbackInfo* Data);


/**
 * Return results for EOS_PlayerDataStorage_OnWriteFileDataCallback callbacks to return
 */
EOS_ENUM(EOS_PlayerDataStorage_EWriteResult,
	/** Signifies the data was written successfully, and we should write the data the file */
	EOS_WR_ContinueWriting = 1,
	/** Signifies all data has now been written successfully, and we should upload the data to the cloud */
	EOS_WR_CompleteRequest = 2,
	/** Signifies there was a failure writing the data, and the request should end */
	EOS_WR_FailRequest = 3,
	/** Signifies the request should be cancelled, but not due to an error */
	EOS_WR_CancelRequest = 4
);

/**
 * Data containing data for a chunk of a file being written
 */
EOS_STRUCT(EOS_PlayerDataStorage_WriteFileDataCallbackInfo, (
	/** Client-specified data passed into the file write request */
	void* ClientData;
	/** The Product User ID of the local user who initiated this request */
	EOS_ProductUserId LocalUserId;
	/** The file name that is being written to */
	const char* Filename;
	/** The maximum amount of data in bytes that can be written safely to DataBuffer */
	uint32_t DataBufferLengthBytes;
));

/**
 * Callback for when we are ready to get more data to be written into the requested file. It is undefined how often this will be called during a single tick.
 *
 * @param Data Struct containing metadata for the file being written to, as well as the max length in bytes that can be safely written to DataBuffer
 * @param OutDataBuffer A buffer to write data into, to be appended to the end of the file that is being written to. The maximum length of this value is provided in the Info parameter. The number of bytes written to this buffer should be set in OutDataWritten.
 * @param OutDataWritten The length of the data written to OutDataBuffer. This must be less than or equal than the DataBufferLengthBytes provided in the Info parameter
 * @return The result of the write operation. If this value is not EOS_WR_ContinueWriting, this callback will not be called again for the same request. If this is set to EOS_WR_FailRequest or EOS_WR_CancelRequest, all data written during the request will not be saved
 */
EOS_DECLARE_CALLBACK_RETVALUE(EOS_PlayerDataStorage_EWriteResult, EOS_PlayerDataStorage_OnWriteFileDataCallback, const EOS_PlayerDataStorage_WriteFileDataCallbackInfo* Data, void* OutDataBuffer, uint32_t* OutDataWritten);

#define EOS_PLAYERDATASTORAGE_WRITEFILEOPTIONS_API_LATEST 1

/**
 * Input data for the EOS_PlayerDataStorage_WriteFile function
 */
EOS_STRUCT(EOS_PlayerDataStorage_WriteFileOptions, (
	/** API Version: Set this to EOS_PLAYERDATASTORAGE_WRITEFILEOPTIONS_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user who is writing the requested file to the cloud */
	EOS_ProductUserId LocalUserId;
	/** The name of the file to write; if this file already exists, the contents will be replaced if the write request completes successfully */
	const char* Filename;
	/** Requested maximum amount of data (in bytes) that can be written to the file per tick */
	uint32_t ChunkLengthBytes;
	/** Callback function that provides chunks of data to be written into the requested file */
	EOS_PlayerDataStorage_OnWriteFileDataCallback WriteFileDataCallback;
	/** Optional callback function to inform the application of upload progress; will be called at least once if set */
	EOS_PlayerDataStorage_OnFileTransferProgressCallback FileTransferProgressCallback;
));

/**
 * The result information for a request to write data to a file
 */
EOS_STRUCT(EOS_PlayerDataStorage_WriteFileCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned for a successful request, other codes indicate an error */
	EOS_EResult ResultCode;
	/** Client-specified data passed into the file write request */
	void* ClientData;
	/** The Product User ID of the local user who initiated this request */
	EOS_ProductUserId LocalUserId;
	/** The file name that is being written to */
	const char* Filename;
));

/**
 * Callback for when EOS_PlayerDataStorage_WriteFile completes
 */
EOS_DECLARE_CALLBACK(EOS_PlayerDataStorage_OnWriteFileCompleteCallback, const EOS_PlayerDataStorage_WriteFileCallbackInfo* Data);

/** The most recent version of the EOS_PlayerDataStorage_DeleteCacheOptions API. */
#define EOS_PLAYERDATASTORAGE_DELETECACHEOPTIONS_API_LATEST 1
/**
 * Input data for the EOS_TitleStorage_DeleteCache function
 */
EOS_STRUCT(EOS_PlayerDataStorage_DeleteCacheOptions, (
	/** API Version: Set this to EOS_PLAYERDATASTORAGE_DELETECACHEOPTIONS_API_LATEST. */
	int32_t ApiVersion;
	/** Product User ID of the local user who is deleting his cache */
	EOS_ProductUserId LocalUserId;
));
/**
 * Structure containing the result of a delete cache operation
 */
EOS_STRUCT(EOS_PlayerDataStorage_DeleteCacheCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned for a successful request, other codes indicate an error */
	EOS_EResult ResultCode;
	/** Client-specified data passed into the delete cache request */
	void* ClientData;
	/** Product User ID of the local user who initiated this request */
	EOS_ProductUserId LocalUserId;
));
/**
 * Callback for when EOS_PlayerDataStorage_DeleteCache completes
 */
EOS_DECLARE_CALLBACK(EOS_PlayerDataStorage_OnDeleteCacheCompleteCallback, const EOS_PlayerDataStorage_DeleteCacheCallbackInfo* Data);


#pragma pack(pop)
```

`eac/sdk/Include/eos_presence.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_presence_types.h"

/**
 * The Presence methods enable you to query and read other player's presence information, or modify your own.
 *
 * QueryPresence must be called once per login, per remote user, before data will be available. It is currently only possible to query presence for
 * users that are on your friends list, all other queries will return no results.
 *
 * @see EOS_Platform_GetPresenceInterface
 */

/**
 * Query a user's presence. This must complete successfully before CopyPresence will have valid results. If HasPresence returns true for a remote
 * user, this does not need to be called.
 *
 * @param Options Object containing properties related to who is querying presence and for what user
 * @param ClientData Optional pointer to help track this request, that is returned in the completion callback
 * @param CompletionDelegate Pointer to a function that handles receiving the completion information
 */
EOS_DECLARE_FUNC(void) EOS_Presence_QueryPresence(EOS_HPresence Handle, const EOS_Presence_QueryPresenceOptions* Options, void* ClientData, const EOS_Presence_OnQueryPresenceCompleteCallback CompletionDelegate);

/**
 * Check if we already have presence for a user
 *
 * @param Options Object containing properties related to who is requesting presence and for what user
 * @return EOS_TRUE if we have presence for the requested user, or EOS_FALSE if the request was invalid or we do not have cached data
 */
EOS_DECLARE_FUNC(EOS_Bool) EOS_Presence_HasPresence(EOS_HPresence Handle, const EOS_Presence_HasPresenceOptions* Options);

/**
 * Get a user's cached presence object. If successful, this data must be released by calling EOS_Presence_Info_Release
 *
 * @param Options Object containing properties related to who is requesting presence and for what user
 * @param OutPresence A pointer to a pointer of Presence Info. If the returned result is success, this will be set to data that must be later released, otherwise this will be set to NULL
 * @return Success if we have cached data, or an error result if the request was invalid or we do not have cached data.
 *
 * @see EOS_Presence_Info_Release
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Presence_CopyPresence(EOS_HPresence Handle, const EOS_Presence_CopyPresenceOptions* Options, EOS_Presence_Info ** OutPresence);

/**
 * Creates a presence modification handle. This handle can used to add multiple changes to your presence that can be applied with EOS_Presence_SetPresence.
 * The resulting handle must be released by calling EOS_PresenceModification_Release once it has been passed to EOS_Presence_SetPresence.
 *
 * @param Options Object containing properties related to the user modifying their presence
 * @param OutPresenceModificationHandle Pointer to a Presence Modification Handle to be set if successful
 * @return Success if we successfully created the Presence Modification Handle pointed at in OutPresenceModificationHandle, or an error result if the input data was invalid
 *
 * @see EOS_PresenceModification_Release
 * @see EOS_Presence_SetPresence
 * @see EOS_PresenceModification_SetStatus
 * @see EOS_PresenceModification_SetRawRichText
 * @see EOS_PresenceModification_SetData
 * @see EOS_PresenceModification_DeleteData
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Presence_CreatePresenceModification(EOS_HPresence Handle, const EOS_Presence_CreatePresenceModificationOptions* Options, EOS_HPresenceModification* OutPresenceModificationHandle);

/**
 * Sets your new presence with the data applied to a PresenceModificationHandle. The PresenceModificationHandle can be released safely after calling this function.
 *
 * @param Options Object containing a PresenceModificationHandle and associated user data
 * @param ClientData Optional pointer to help track this request, that is returned in the completion callback
 * @param CompletionDelegate Pointer to a function that handles receiving the completion information
 *
 * @see EOS_Presence_CreatePresenceModification
 * @see EOS_PresenceModification_Release
 */
EOS_DECLARE_FUNC(void) EOS_Presence_SetPresence(EOS_HPresence Handle, const EOS_Presence_SetPresenceOptions* Options, void* ClientData, const EOS_Presence_SetPresenceCompleteCallback CompletionDelegate);

/**
 * Register to receive notifications when presence changes. If the returned NotificationId is valid, you must call RemoveNotifyOnPresenceChanged when you no longer wish to
 * have your NotificationHandler called
 *
 * @param ClientData Data the is returned to when NotificationHandler is invoked
 * @param NotificationHandler The callback to be fired when a presence change occurs
 * @return Notification ID representing the registered callback if successful, an invalid NotificationId if not
 *
 * @see EOS_INVALID_NOTIFICATIONID
 * @see EOS_Presence_RemoveNotifyOnPresenceChanged
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_Presence_AddNotifyOnPresenceChanged(EOS_HPresence Handle, const EOS_Presence_AddNotifyOnPresenceChangedOptions* Options, void* ClientData, const EOS_Presence_OnPresenceChangedCallback NotificationHandler);

/**
 * Unregister a previously bound notification handler from receiving presence update notifications
 *
 * @param NotificationId The Notification ID representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_Presence_RemoveNotifyOnPresenceChanged(EOS_HPresence Handle, EOS_NotificationId NotificationId);

/**
 * Register to receive notifications when a user accepts a join game option via the social overlay.
 * @note must call RemoveNotifyJoinGameAccepted to remove the notification
 *
 * @param Options Structure containing information about the request.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param NotificationFn A callback that is fired when a a notification is received.
 *
 * @return handle representing the registered callback
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_Presence_AddNotifyJoinGameAccepted(EOS_HPresence Handle, const EOS_Presence_AddNotifyJoinGameAcceptedOptions* Options, void* ClientData, const EOS_Presence_OnJoinGameAcceptedCallback NotificationFn);

/**
 * Unregister from receiving notifications when a user accepts a join game option via the social overlay.
 *
 * @param InId Handle representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_Presence_RemoveNotifyJoinGameAccepted(EOS_HPresence Handle, EOS_NotificationId InId);

/**
 * Gets a join info custom game-data string for a specific user. This is a helper function for reading the presence data related to how a user can be joined.
 * Its meaning is entirely application dependent.
 *
 * This value will be valid only after a QueryPresence call has successfully completed.
 *
 * @param Options Object containing an associated user
 * @param OutBuffer The buffer into which the character data should be written.  The buffer must be long enough to hold a string of EOS_PRESENCEMODIFICATION_JOININFO_MAX_LENGTH.
 * @param InOutBufferLength Used as an input to define the OutBuffer length.
 *                          The input buffer should include enough space to be null-terminated.
 *                          When the function returns, this parameter will be filled with the length of the string copied into OutBuffer.
 *
 * @return An EOS_EResult that indicates whether the location string was copied into the OutBuffer.
 *         EOS_Success if the information is available and passed out in OutBuffer
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if there is user or the location string was not found.
 *         EOS_LimitExceeded - The OutBuffer is not large enough to receive the location string. InOutBufferLength contains the required minimum length to perform the operation successfully.
 *
 * @see EOS_PRESENCEMODIFICATION_JOININFO_MAX_LENGTH
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Presence_GetJoinInfo(EOS_HPresence Handle, const EOS_Presence_GetJoinInfoOptions* Options, char* OutBuffer, int32_t* InOutBufferLength);

/**
 * To modify your own presence, you must call EOS_Presence_CreatePresenceModification to create a Presence Modification handle. To modify that handle, call
 * EOS_PresenceModification_* methods. Once you are finished, call EOS_Presence_SetPresence with your handle. You must then release your Presence Modification
 * handle by calling EOS_PresenceModification_Release.
 */

/**
 * Modifies a user's online status to be the new state.
 *
 * @param Options Object containing properties related to setting a user's Status
 * @return Success if modification was added successfully, otherwise an error code related to the problem
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_PresenceModification_SetStatus(EOS_HPresenceModification Handle, const EOS_PresenceModification_SetStatusOptions* Options);

/**
 * Modifies a user's Rich Presence string to a new state. This is the exact value other users will see
 * when they query the local user's presence.
 *
 * @param Options Object containing properties related to setting a user's RichText string
 * @return Success if modification was added successfully, otherwise an error code related to the problem
 *
 * @see EOS_PRESENCE_RICH_TEXT_MAX_VALUE_LENGTH
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_PresenceModification_SetRawRichText(EOS_HPresenceModification Handle, const EOS_PresenceModification_SetRawRichTextOptions* Options);

/**
 * Modifies one or more rows of user-defined presence data for a local user. At least one InfoData object
 * must be specified.
 *
 * @param Options Object containing an array of new presence data.
 * @return Success if modification was added successfully, otherwise an error code related to the problem
 *
 * @see EOS_PRESENCE_DATA_MAX_KEYS
 * @see EOS_PRESENCE_DATA_MAX_KEY_LENGTH
 * @see EOS_PRESENCE_DATA_MAX_VALUE_LENGTH
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_PresenceModification_SetData(EOS_HPresenceModification Handle, const EOS_PresenceModification_SetDataOptions* Options);

/**
 * Removes one or more rows of user-defined presence data for a local user. At least one DeleteDataInfo object
 * must be specified.
 *
 * @param Options Object containing an array of new presence data.
 * @return Success if modification was added successfully, otherwise an error code related to the problem
 *
 * @see EOS_PRESENCE_DATA_MAX_KEYS
 * @see EOS_PRESENCE_DATA_MAX_KEY_LENGTH
 * @see EOS_PRESENCE_DATA_MAX_VALUE_LENGTH
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_PresenceModification_DeleteData(EOS_HPresenceModification Handle, const EOS_PresenceModification_DeleteDataOptions* Options);

/**
 * Sets your new join info custom game-data string. This is a helper function for reading the presence data related to how a user can be joined.
 * Its meaning is entirely application dependent.
 *
 * @param Options Object containing a join info string and associated user data
 * @return Success if modification was added successfully, otherwise an error code related to the problem
 *
 * @see EOS_PRESENCEMODIFICATION_JOININFO_MAX_LENGTH
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_PresenceModification_SetJoinInfo(EOS_HPresenceModification Handle, const EOS_PresenceModification_SetJoinInfoOptions* Options);

```

`eac/sdk/Include/eos_presence_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"
#include "eos_ui_types.h"

#pragma pack(push, 8)

EXTERN_C typedef struct EOS_PresenceHandle* EOS_HPresence;
EXTERN_C typedef struct EOS_PresenceModificationHandle* EOS_HPresenceModification;

/**
 * Presence Status states of a user
 *
 * @see EOS_Presence_CopyPresence
 * @see EOS_PresenceModification_SetStatus
 */
EOS_ENUM(EOS_Presence_EStatus,
	/** The status of the account is offline or not known */
	EOS_PS_Offline = 0,
	/** The status of the account is online */
	EOS_PS_Online = 1,
	/** The status of the account is away */
	EOS_PS_Away = 2,
	/** The status of the account is away, and has been away for a while */
	EOS_PS_ExtendedAway = 3,
	/** The status of the account is do-not-disturb */
	EOS_PS_DoNotDisturb = 4
);


#define EOS_PRESENCE_DATARECORD_API_LATEST 1

/**
 * An individual presence data record that belongs to a EOS_Presence_Info object. This object is released when its parent EOS_Presence_Info object is released.
 *
 * @see EOS_Presence_Info
 */
EOS_STRUCT(EOS_Presence_DataRecord, (
	/** API Version: Set this to EOS_PRESENCE_DATARECORD_API_LATEST. */
	int32_t ApiVersion;
	/** The name of this data */
	const char* Key;
	/** The value of this data */
	const char* Value;
));


#define EOS_PRESENCE_INFO_API_LATEST 2

/**
 * All the known presence information for a specific user. This object must be released by calling EOS_Presence_Info_Release.
 *
 * @see EOS_Presence_CopyPresence
 * @see EOS_Presence_Info_Release
 */
EOS_STRUCT(EOS_Presence_Info, (
	/** API Version: Set this to EOS_PRESENCE_INFO_API_LATEST. */
	int32_t ApiVersion;
	/** The status of the user */
	EOS_Presence_EStatus Status;
	/** The Epic Account ID of the user */
	EOS_EpicAccountId UserId;
	/** The product ID that the user is logged in from */
	const char* ProductId;
	/** The version of the product the user is logged in from */
	const char* ProductVersion;
	/** The platform of that the user is logged in from */
	const char* Platform;
	/** The rich-text of the user */
	const char* RichText;
	/** The count of records available */
	int32_t RecordsCount;
	/** The first data record, or NULL if RecordsCount is not at least 1 */
	const EOS_Presence_DataRecord* Records;
	/** The user-facing name for the product the user is logged in from */
	const char* ProductName;
));


#define EOS_PRESENCE_QUERYPRESENCE_API_LATEST 1

/**
 * Data for the EOS_Presence_QueryPresence function
 */
EOS_STRUCT(EOS_Presence_QueryPresenceOptions, (
	/** API Version: Set this to EOS_PRESENCE_QUERYPRESENCE_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local, logged-in user making the request */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the user whose presence data you want to retrieve; this value must be either the user making the request, or a friend of that user */
	EOS_EpicAccountId TargetUserId;
));

/**
 * The result meta-data for a presence query.
 */
EOS_STRUCT(EOS_Presence_QueryPresenceCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned for a successful query, other codes indicate an error */
	EOS_EResult ResultCode;
	/** Client-specified data passed into EOS_Presence_QueryPresence */
	void* ClientData;
	/** The Epic Account ID of the local user who made this request */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the user whose presence was potentially queried */
	EOS_EpicAccountId TargetUserId;
));

/**
 * Callback for information related to EOS_Presence_QueryPresence finishing.
 */
EOS_DECLARE_CALLBACK(EOS_Presence_OnQueryPresenceCompleteCallback, const EOS_Presence_QueryPresenceCallbackInfo* Data);


#define EOS_PRESENCE_HASPRESENCE_API_LATEST 1

/**
 * Data for the EOS_Presence_HasPresence function.
 */
EOS_STRUCT(EOS_Presence_HasPresenceOptions, (
	/** API Version: Set this to EOS_PRESENCE_HASPRESENCE_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local, logged-in user making the request */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the user whose cached presence data you want to locate */
	EOS_EpicAccountId TargetUserId;
));


#define EOS_PRESENCE_COPYPRESENCE_API_LATEST 2
/**
 * Data for the EOS_Presence_CopyPresence function.
 */
EOS_STRUCT(EOS_Presence_CopyPresenceOptions, (
	/** API Version: Set this to EOS_PRESENCE_COPYPRESENCE_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local, logged-in user making the request */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the user whose cached presence data you want to copy from the cache */
	EOS_EpicAccountId TargetUserId;
));


/**
 * Release the memory associated with an EOS_Presence_Info structure and its sub-objects. This must be called on data retrieved from EOS_Presence_CopyPresence.
 * This can be safely called on a NULL presence info object.
 *
 * @param PresenceInfo The presence info structure to be release
 */
EOS_DECLARE_FUNC(void) EOS_Presence_Info_Release(EOS_Presence_Info* PresenceInfo);


#define EOS_PRESENCE_CREATEPRESENCEMODIFICATION_API_LATEST 1
/**
 * Data for the EOS_Presence_CreatePresenceModification function.
 */
EOS_STRUCT(EOS_Presence_CreatePresenceModificationOptions, (
	/** API Version: Set this to EOS_PRESENCE_CREATEPRESENCEMODIFICATION_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local, logged-in user making the request */
	EOS_EpicAccountId LocalUserId;
));


/**
 * Release the memory associated with an EOS_HPresenceModification handle. This must be called on Handles retrieved from EOS_Presence_CreatePresenceModification.
 * This can be safely called on a NULL presence modification handle. This also may be safely called while a call to SetPresence is still pending.
 *
 * @param PresenceModificationHandle The presence modification handle to release
 *
 * @see EOS_Presence_CreatePresenceModification
 */
EOS_DECLARE_FUNC(void) EOS_PresenceModification_Release(EOS_HPresenceModification PresenceModificationHandle);


#define EOS_PRESENCE_SETPRESENCE_API_LATEST 1
/**
 * Data for the EOS_Presence_SetPresence function.
 */
EOS_STRUCT(EOS_Presence_SetPresenceOptions, (
	/** API Version: Set this to EOS_PRESENCE_SETPRESENCE_API_LATEST. */
	int32_t ApiVersion;
/** The Epic Account ID of the local, logged-in user making the request */
	EOS_EpicAccountId LocalUserId;
	/** The handle to the presence update */
	EOS_HPresenceModification PresenceModificationHandle;
));

/**
 * The result meta-data from setting a user's presence.
 */
EOS_STRUCT(EOS_Presence_SetPresenceCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned if presence was successfully set, other codes indicate an error */
	EOS_EResult ResultCode;
	/** Client-specified data passed into EOS_Presence_SetPresence */
	void* ClientData;
	/** The Epic Account ID of the local user that had their presence set */
	EOS_EpicAccountId LocalUserId;
));

/**
 * Callback for information related to EOS_Presence_SetPresence finishing.
 */
EOS_DECLARE_CALLBACK(EOS_Presence_SetPresenceCompleteCallback, const EOS_Presence_SetPresenceCallbackInfo* Data);


#define EOS_PRESENCE_ADDNOTIFYONPRESENCECHANGED_API_LATEST 1
/**
 * Data for the EOS_Presence_AddNotifyOnPresenceChanged function.
 */
EOS_STRUCT(EOS_Presence_AddNotifyOnPresenceChangedOptions, (
	/** API Version: Set this to EOS_PRESENCE_ADDNOTIFYONPRESENCECHANGED_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Data containing which users presence has changed
 */
EOS_STRUCT(EOS_Presence_PresenceChangedCallbackInfo, (
	/** Client-specified data passed into EOS_Presence_AddNotifyOnPresenceChanged */
	void* ClientData;
	/** The Epic Account ID of the local user who is being informed for PresenceUserId's presence change */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the user who had their presence changed */
	EOS_EpicAccountId PresenceUserId;
));

/** The most recent version of the EOS_Presence_AddNotifyJoinGameAccepted API. */
#define EOS_PRESENCE_ADDNOTIFYJOINGAMEACCEPTED_API_LATEST 2

EOS_STRUCT(EOS_Presence_AddNotifyJoinGameAcceptedOptions, (
	/** API Version: Set this to EOS_PRESENCE_ADDNOTIFYJOINGAMEACCEPTED_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_Presence_OnJoinGameAcceptedCallback Function.
 */
EOS_STRUCT(EOS_Presence_JoinGameAcceptedCallbackInfo, (
	/** Context that was passed into EOS_Presence_AddNotifyJoinGameAccepted */
	void* ClientData;
	/** 
	 * The Join Info custom game-data string to use to join the target user.
	 * Set to a null pointer to delete the value.
	 */
	const char* JoinInfo;
	/** The Epic Account ID of the user who accepted the invitation */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the user who sent the invitation */
	EOS_EpicAccountId TargetUserId;
	/** 
	 * If the value is not EOS_UI_EVENTID_INVALID then it must be passed back to the SDK using EOS_UI_AcknowledgeEventId.
	 * This should be done after attempting to join the game and either succeeding or failing to connect.
	 * This is necessary to allow the Social Overlay UI to manage the `Join` button.
	 */
	EOS_UI_EventId UiEventId;
));

/**
 * Function prototype definition for notifications that come from EOS_Presence_AddNotifyJoinGameAccepted
 *
 * @param Data A EOS_Presence_JoinGameAcceptedCallbackInfo containing the output information and result
 * 
 * @note EOS_UI_AcknowledgeEventId must be called with any valid UiEventId passed via the data.
 */
EOS_DECLARE_CALLBACK(EOS_Presence_OnJoinGameAcceptedCallback, const EOS_Presence_JoinGameAcceptedCallbackInfo* Data);

/**
 * Callback for information related to notifications from EOS_Presence_AddNotifyOnPresenceChanged triggering.
 */
EOS_DECLARE_CALLBACK(EOS_Presence_OnPresenceChangedCallback, const EOS_Presence_PresenceChangedCallbackInfo* Data);

#define EOS_PRESENCE_GETJOININFO_API_LATEST 1
/**
 * Data for the EOS_Presence_GetJoinInfo function.
 */
EOS_STRUCT(EOS_Presence_GetJoinInfoOptions, (
	/** API Version: Set this to EOS_PRESENCE_GETJOININFO_API_LATEST. */
	int32_t ApiVersion;
	/** The local user's Epic Account ID */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID to query for join info; this value must either be a logged-in local user, or a friend of that user */
	EOS_EpicAccountId TargetUserId;
));

#define EOS_PRESENCEMODIFICATION_JOININFO_MAX_LENGTH EOS_PRESENCE_DATA_MAX_VALUE_LENGTH

#define EOS_PRESENCEMODIFICATION_SETJOININFO_API_LATEST 1
/**
 * Data for the EOS_PresenceModification_SetJoinInfo function.
 */
EOS_STRUCT(EOS_PresenceModification_SetJoinInfoOptions, (
	/** API Version: Set this to EOS_PRESENCEMODIFICATION_SETJOININFO_API_LATEST. */
	int32_t ApiVersion;
	/** 
	 * The string which will be advertised as this player's join info.
	 * An application is expected to freely define the meaning of this string to use for connecting to an active game session.
	 * The string should not exceed EOS_PRESENCEMODIFICATION_JOININFO_MAX_LENGTH in length.
	 * This affects the ability of the Social Overlay to show game related actions to take in the player's social graph.
	 *
	 * @note The Social Overlay can handle only one of the following three options at a time:
	 * * using the bPresenceEnabled flags within the Sessions interface
	 * * using the bPresenceEnabled flags within the Lobby interface
	 * * using EOS_PresenceModification_SetJoinInfo
	 *
	 * @see EOS_Lobby_CreateLobbyOptions
	 * @see EOS_Lobby_JoinLobbyOptions
	 * @see EOS_Sessions_CreateSessionModificationOptions
	 * @see EOS_Sessions_JoinSessionOptions
	 */
	const char* JoinInfo;
));


/**
 * The maximum of allowed individual pieces of data a user may have. This value is subject to change and data structures should be designed to allow for greater
 * numbers than this.
 */
#define EOS_PRESENCE_DATA_MAX_KEYS 32

/**
 * The maximum allowed length a data's key may be. This value is subject to change and data structures should be designed to allow for greater numbers than this.
 */
#define EOS_PRESENCE_DATA_MAX_KEY_LENGTH 64

/**
 * The maximum allowed length a data's value may be. This value is subject to change and data structures should be designed to allow for greater numbers than this.
 */
#define EOS_PRESENCE_DATA_MAX_VALUE_LENGTH 255

/**
 * The maximum allowed length a user's rich text string may be. This value is subject to change and data structures should be designed to allow for greater numbers
 * than this.
 */
#define EOS_PRESENCE_RICH_TEXT_MAX_VALUE_LENGTH 255

/** The most recent version of the EOS_PresenceModification_SetStatus API. */
#define EOS_PRESENCEMODIFICATION_SETSTATUS_API_LATEST 1

/** DEPRECATED! Use EOS_PRESENCEMODIFICATION_SETSTATUS_API_LATEST instead. */
#define EOS_PRESENCE_SETSTATUS_API_LATEST EOS_PRESENCEMODIFICATION_SETSTATUS_API_LATEST

/**
 * Data for the EOS_PresenceModification_SetStatus function.
 */
EOS_STRUCT(EOS_PresenceModification_SetStatusOptions, (
	/** API Version: Set this to EOS_PRESENCEMODIFICATION_SETSTATUS_API_LATEST. */
	int32_t ApiVersion;
	/** The status of the user */
	EOS_Presence_EStatus Status;
));

/** The most recent version of the EOS_PresenceModification_SetRawRichText function. */
#define EOS_PRESENCEMODIFICATION_SETRAWRICHTEXT_API_LATEST 1

/** DEPRECATED! Use EOS_PRESENCEMODIFICATION_SETRAWRICHTEXT_API_LATEST instead. */
#define EOS_PRESENCE_SETRAWRICHTEXT_API_LATEST EOS_PRESENCEMODIFICATION_SETRAWRICHTEXT_API_LATEST

/**
 * Data for the EOS_PresenceModification_SetRawRichText API.
 */
EOS_STRUCT(EOS_PresenceModification_SetRawRichTextOptions, (
	/** API Version: Set this to EOS_PRESENCEMODIFICATION_SETRAWRICHTEXT_API_LATEST. */
	int32_t ApiVersion;
	/** The status of the user */
	const char* RichText;
));

/** The most recent version of the EOS_PresenceModification_SetData API. */
#define EOS_PRESENCEMODIFICATION_SETDATA_API_LATEST 1

/** DEPRECATED! Use EOS_PRESENCEMODIFICATION_SETDATA_API_LATEST instead. */
#define EOS_PRESENCE_SETDATA_API_LATEST EOS_PRESENCEMODIFICATION_SETDATA_API_LATEST

/**
 * Data for the EOS_PresenceModification_SetData function.
 */
EOS_STRUCT(EOS_PresenceModification_SetDataOptions, (
	/** API Version: Set this to EOS_PRESENCEMODIFICATION_SETDATA_API_LATEST. */
	int32_t ApiVersion;
	/** The count of records to set */
	int32_t RecordsCount;
	/** The pointer to start of a sequential array of Presence DataRecords */
	const EOS_Presence_DataRecord* Records;
));

#define EOS_PRESENCEMODIFICATION_DATARECORDID_API_LATEST 1

/**
 * Data for identifying which data records should be deleted.
 */
EOS_STRUCT(EOS_PresenceModification_DataRecordId, (
	/** API Version: Set this to EOS_PRESENCEMODIFICATION_DATARECORDID_API_LATEST. */
	int32_t ApiVersion;
	/** The key to be deleted from the data record */
	const char* Key;
));

/** Most recent version of the EOS_PresenceModification_DeleteData API. */
#define EOS_PRESENCEMODIFICATION_DELETEDATA_API_LATEST 1

/** DEPRECATED! Use EOS_PRESENCEMODIFICATION_DELETEDATA_API_LATEST instead. */
#define EOS_PRESENCE_DELETEDATA_API_LATEST EOS_PRESENCEMODIFICATION_DELETEDATA_API_LATEST

/**
 * Data for the EOS_PresenceModification_DeleteData function.
 */
EOS_STRUCT(EOS_PresenceModification_DeleteDataOptions, (
	/** API Version: Set this to EOS_PRESENCEMODIFICATION_DELETEDATA_API_LATEST. */
	int32_t ApiVersion;
	/** The count of data keys to delete */
	int32_t RecordsCount;
	/** The pointer to start of a sequential array */
	const EOS_PresenceModification_DataRecordId* Records;
));

#pragma pack(pop)

```

`eac/sdk/Include/eos_progressionsnapshot.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_progressionsnapshot_types.h"

/**
 * Progression Snapshots allow you to store player specific game state.
 *
 * BeginSnapshot must be called to obtain a handle for a given player.
 * AddProgression allows you to add Key/Value pairs that represent some state for that player in the game.
 * SubmitSnapshot sends all the progression data you have added (via AddProgression) to the service.
 * EndSnapshot cleans up internal resources allocated for that snapshot.
 * DeleteSnapshot wipes out all data associated with a particular player.
 *
 * @see EOS_Platform_GetProgressionSnapshotInterface
 */

/**
 * Creates a new progression-snapshot resource for a given user.
 *
 * @param Options Object containing properties that identifies the PUID this Snapshot will belong to.
 * @param OutSnapshotId A progression-snapshot identifier output parameter. Use that identifier to reference the snapshot in the other APIs.
 *
 * @return EOS_Success when successful.
 *          EOS_ProgressionSnapshot_SnapshotIdUnavailable when no IDs are available. This is irrecoverable state.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_ProgressionSnapshot_BeginSnapshot(EOS_HProgressionSnapshot Handle, const EOS_ProgressionSnapshot_BeginSnapshotOptions* Options, uint32_t* OutSnapshotId);

/**
 * Stores a Key/Value pair in memory for a given snapshot.
 * If multiple calls happen with the same key, the last invocation wins, overwriting the previous value for that
 * given key.
 *
 * The order in which the Key/Value pairs are added is stored as is for later retrieval/display.
 * Ideally, you would make multiple calls to AddProgression() followed by a single call to SubmitSnapshot().
 *
 * @return EOS_Success when successful; otherwise, EOS_NotFound
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_ProgressionSnapshot_AddProgression(EOS_HProgressionSnapshot Handle, const EOS_ProgressionSnapshot_AddProgressionOptions* Options);

/**
 * Saves the previously added Key/Value pairs of a given Snapshot to the service.
 *
 * Note: This will overwrite any prior progression data stored with the service that's associated with the user.
 **/
EOS_DECLARE_FUNC(void) EOS_ProgressionSnapshot_SubmitSnapshot(EOS_HProgressionSnapshot Handle, const EOS_ProgressionSnapshot_SubmitSnapshotOptions* Options, void* ClientData, const EOS_ProgressionSnapshot_OnSubmitSnapshotCallback CompletionDelegate);

/**
 * Cleans up and releases resources associated with the given progression snapshot identifier.
 *
 * @return EOS_Success when successful; otherwise, EOS_NotFound
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_ProgressionSnapshot_EndSnapshot(EOS_HProgressionSnapshot Handle, const EOS_ProgressionSnapshot_EndSnapshotOptions* Options);

/**
 * Wipes out all progression data for the given user from the service. However, any previous progression data that haven't
 * been submitted yet are retained.
 */
EOS_DECLARE_FUNC(void) EOS_ProgressionSnapshot_DeleteSnapshot(EOS_HProgressionSnapshot Handle, const EOS_ProgressionSnapshot_DeleteSnapshotOptions* Options, void* ClientData, const EOS_ProgressionSnapshot_OnDeleteSnapshotCallback CompletionDelegate);

```

`eac/sdk/Include/eos_progressionsnapshot_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

/** Handle to the ProgressionSnapshot interface */
EXTERN_C typedef struct EOS_ProgressionSnapshotHandle* EOS_HProgressionSnapshot;

#define EOS_INVALID_PROGRESSIONSNAPSHOTID  0

#define EOS_PROGRESSIONSNAPSHOT_BEGINSNAPSHOT_API_LATEST 1
EOS_STRUCT(EOS_ProgressionSnapshot_BeginSnapshotOptions, (
	/** API Version: Set this to EOS_PROGRESSIONSNAPSHOT_BEGINSNAPSHOT_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user to whom the key/value pair belong */
	EOS_ProductUserId LocalUserId;
));

#define EOS_PROGRESSIONSNAPSHOT_ADDPROGRESSION_API_LATEST  1
EOS_STRUCT(EOS_ProgressionSnapshot_AddProgressionOptions, (
	/** API Version: Set this to EOS_PROGRESSIONSNAPSHOT_ADDPROGRESSION_API_LATEST. */
	int32_t ApiVersion;
	/** The Snapshot Id received via a EOS_ProgressionSnapshot_BeginSnapshot function. */
	uint32_t SnapshotId;
	/** The key in a key/value pair of progression entry */
	const char* Key;
	/** The value in a key/value pair of progression entry */
	const char* Value;
));

#define EOS_PROGRESSIONSNAPSHOT_SUBMITSNAPSHOT_API_LATEST   1
EOS_STRUCT(EOS_ProgressionSnapshot_SubmitSnapshotOptions, (
	/** API Version: Set this to EOS_PROGRESSIONSNAPSHOT_SUBMITSNAPSHOT_API_LATEST. */
	int32_t ApiVersion;
	/** The Snapshot Id received via a EOS_ProgressionSnapshot_BeginSnapshot function. */
	uint32_t SnapshotId;
));

#define EOS_PROGRESSIONSNAPSHOT_ENDSNAPSHOT_API_LATEST    1
EOS_STRUCT(EOS_ProgressionSnapshot_EndSnapshotOptions, (
	/** API Version: Set this to EOS_PROGRESSIONSNAPSHOT_ENDSNAPSHOT_API_LATEST. */
	int32_t ApiVersion;
	/** The Snapshot Id received via a EOS_ProgressionSnapshot_BeginSnapshot function. */
	uint32_t SnapshotId;
));

EOS_STRUCT(EOS_ProgressionSnapshot_SubmitSnapshotCallbackInfo, (
	/* The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** The Snapshot Id used in the Submit function. */
	uint32_t SnapshotId;
	/** Context that was passed into EOS_ProgressionSnapshot_SubmitSnapshot. */
	void* ClientData;
));

EOS_DECLARE_CALLBACK(EOS_ProgressionSnapshot_OnSubmitSnapshotCallback, const EOS_ProgressionSnapshot_SubmitSnapshotCallbackInfo* Data);

#define EOS_PROGRESSIONSNAPSHOT_DELETESNAPSHOT_API_LATEST   1
EOS_STRUCT(EOS_ProgressionSnapshot_DeleteSnapshotOptions, (
	/** API Version: Set this to EOS_PROGRESSIONSNAPSHOT_DELETESNAPSHOT_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user to whom the key/value pair belong */
	EOS_ProductUserId LocalUserId;
));

EOS_STRUCT(EOS_ProgressionSnapshot_DeleteSnapshotCallbackInfo, (
	/* The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** The Product User ID of the local user to whom the key/value pair belong */
	EOS_ProductUserId LocalUserId;
	/** Context that was passed into EOS_ProgressionSnapshot_SubmitSnapshot. */
	void* ClientData;
));
EOS_DECLARE_CALLBACK(EOS_ProgressionSnapshot_OnDeleteSnapshotCallback, const EOS_ProgressionSnapshot_DeleteSnapshotCallbackInfo* Data);

#pragma pack(pop)

```

`eac/sdk/Include/eos_reports.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_reports_types.h"

/**
 * The following EOS_Reports_* functions allow you to send reports directly from the players
 * to the back-end services without having to route these through a game server.
 */

/**
 * Sends the provided report directly to the Epic Online Services back-end.
 *
 * @param Options Structure containing the player report information.
 * @param ClientData Optional client data provided by the user of the SDK.
 * @param CompletionDelegate This function is called when the send operation completes.
 */
EOS_DECLARE_FUNC(void) EOS_Reports_SendPlayerBehaviorReport(EOS_HReports Handle, const EOS_Reports_SendPlayerBehaviorReportOptions* Options, void* ClientData, const EOS_Reports_OnSendPlayerBehaviorReportCompleteCallback CompletionDelegate);

```

`eac/sdk/Include/eos_reports_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

EXTERN_C typedef struct EOS_ReportsHandle* EOS_HReports;

/**
 * An enumeration of the different player behavior categories that can be reported.
 */
EOS_ENUM(EOS_EPlayerReportsCategory,
	/** Not used */
	EOS_PRC_Invalid = 0,
	/** The reported player is cheating */
	EOS_PRC_Cheating = 1,
	/** The reported player is exploiting the game */
	EOS_PRC_Exploiting = 2,
	/** The reported player has an offensive profile, name, etc */
	EOS_PRC_OffensiveProfile = 3,
	/** The reported player is being abusive in chat */
	EOS_PRC_VerbalAbuse = 4,
	/** The reported player is scamming other players */
	EOS_PRC_Scamming = 5,
	/** The reported player is spamming chat */
	EOS_PRC_Spamming = 6,
	/** The player is being reported for something else */
	EOS_PRC_Other = 7
);

/** Max length of a report message text, not including the null terminator. */
#define EOS_REPORTS_REPORTMESSAGE_MAX_LENGTH 512

/** Max length of a report context JSON payload, not including the null terminator. */
#define EOS_REPORTS_REPORTCONTEXT_MAX_LENGTH 4096

/** The most recent version of the EOS_Reports_SendPlayerBehaviorReport API. */
#define EOS_REPORTS_SENDPLAYERBEHAVIORREPORT_API_LATEST 2

/**
 * Input parameters for the EOS_Reports_SendPlayerBehaviorReport function.
 */
EOS_STRUCT(EOS_Reports_SendPlayerBehaviorReportOptions, (
	/** API Version: Set this to EOS_REPORTS_SENDPLAYERBEHAVIORREPORT_API_LATEST. */
	int32_t ApiVersion;
	/** Product User ID of the reporting player */
	EOS_ProductUserId ReporterUserId;
	/** Product User ID of the reported player. */
	EOS_ProductUserId ReportedUserId;
	/** Category for the player report. */
	EOS_EPlayerReportsCategory Category;
	/**
	 * Optional plain text string associated with the report as UTF-8 encoded null-terminated string.
	 *
	 * The length of the message can be at maximum up to EOS_REPORTS_REPORTMESSAGE_MAX_LENGTH bytes
	 * and any excess characters will be truncated upon sending the report.
	 */
	const char* Message;
	/**
	 * Optional JSON string associated with the report as UTF-8 encoded null-terminated string.
	 * This is intended as a way to associate arbitrary structured context information with a report.
	 *
	 * This string needs to be valid JSON, report will fail otherwise.
	 * The length of the context can be at maximum up to EOS_REPORTS_REPORTCONTEXT_MAX_LENGTH bytes, not including the null terminator, report will fail otherwise.
	 */
	const char* Context;
));

/**
 * Output parameters for the EOS_Reports_SendPlayerBehaviorReport function.
 */
EOS_STRUCT(EOS_Reports_SendPlayerBehaviorReportCompleteCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Reports_SendPlayerBehaviorReport. */
	void* ClientData;
));

/**
 * Function prototype definition for callbacks passed to EOS_Reports_SendPlayerBehaviorReport.
 * @param Data A EOS_Reports_SendPlayerBehaviorReportCompleteCallbackInfo containing the output information and result.
 */
EOS_DECLARE_CALLBACK(EOS_Reports_OnSendPlayerBehaviorReportCompleteCallback, const EOS_Reports_SendPlayerBehaviorReportCompleteCallbackInfo* Data);

#pragma pack(pop)

```

`eac/sdk/Include/eos_result.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

// This file is not intended to be included directly. Include eos_common.h instead.

/** Successful result. no further error processing needed */
EOS_RESULT_VALUE(EOS_Success, 0)

/** Failed due to no connection */
EOS_RESULT_VALUE(EOS_NoConnection, 1)
/** Failed login due to invalid credentials */
EOS_RESULT_VALUE(EOS_InvalidCredentials, 2)
/** Failed due to invalid or missing user */
EOS_RESULT_VALUE(EOS_InvalidUser, 3)
/** Failed due to invalid or missing authentication token for user (e.g. not logged in) */
EOS_RESULT_VALUE(EOS_InvalidAuth, 4)
/** Failed due to invalid access */
EOS_RESULT_VALUE(EOS_AccessDenied, 5)
/** If the client does not possess the permission required */
EOS_RESULT_VALUE(EOS_MissingPermissions, 6)
/** If the token provided does not represent an account */
EOS_RESULT_VALUE(EOS_Token_Not_Account, 7)
/** Throttled due to too many requests */
EOS_RESULT_VALUE(EOS_TooManyRequests, 8)
/** Async request was already pending */
EOS_RESULT_VALUE(EOS_AlreadyPending, 9)
/** Invalid parameters specified for request */
EOS_RESULT_VALUE(EOS_InvalidParameters, 10)
/** Invalid request */
EOS_RESULT_VALUE(EOS_InvalidRequest, 11)
/** Failed due to unable to parse or recognize a backend response */
EOS_RESULT_VALUE(EOS_UnrecognizedResponse, 12)
/** Incompatible client for backend version */
EOS_RESULT_VALUE(EOS_IncompatibleVersion, 13)
/** Not configured correctly for use */
EOS_RESULT_VALUE(EOS_NotConfigured, 14)
/** Already configured for use. */
EOS_RESULT_VALUE(EOS_AlreadyConfigured, 15)
/** Feature not available on this implementation */
EOS_RESULT_VALUE(EOS_NotImplemented, 16)
/** Operation was canceled (likely by user) */
EOS_RESULT_VALUE(EOS_Canceled, 17)
/** The requested information was not found */
EOS_RESULT_VALUE(EOS_NotFound, 18)
/** An error occurred during an asynchronous operation, and it will be retried. Callbacks receiving this result will be called again in the future. */
EOS_RESULT_VALUE(EOS_OperationWillRetry, 19)
/** The request had no effect */
EOS_RESULT_VALUE(EOS_NoChange, 20)
/** The request attempted to use multiple or inconsistent API versions */
EOS_RESULT_VALUE(EOS_VersionMismatch, 21)
/** A maximum limit was exceeded on the client, different from EOS_TooManyRequests */
EOS_RESULT_VALUE(EOS_LimitExceeded, 22)
/** Feature or client ID performing the operation has been disabled. */
EOS_RESULT_VALUE(EOS_Disabled, 23)
/** Duplicate entry not allowed */
EOS_RESULT_VALUE(EOS_DuplicateNotAllowed, 24)
/** Required parameters are missing. DEPRECATED: This error is no longer used. */
EOS_RESULT_VALUE(EOS_MissingParameters_DEPRECATED, 25)
/** Sandbox ID is invalid */
EOS_RESULT_VALUE(EOS_InvalidSandboxId, 26)
/** Request timed out */
EOS_RESULT_VALUE(EOS_TimedOut, 27)
/** A query returned some but not all of the requested results.  */
EOS_RESULT_VALUE(EOS_PartialResult, 28)
/** Client is missing the whitelisted role */
EOS_RESULT_VALUE(EOS_Missing_Role, 29)
/** Client is missing the whitelisted feature */
EOS_RESULT_VALUE(EOS_Missing_Feature, 30)
/** The sandbox given to the backend is invalid */
EOS_RESULT_VALUE(EOS_Invalid_Sandbox, 31)
/** The deployment given to the backend is invalid */
EOS_RESULT_VALUE(EOS_Invalid_Deployment, 32)
/** The product ID specified to the backend is invalid */
EOS_RESULT_VALUE(EOS_Invalid_Product, 33)
/** The product user ID specified to the backend is invalid */
EOS_RESULT_VALUE(EOS_Invalid_ProductUserID, 34)
/** There was a failure with the backend service */
EOS_RESULT_VALUE(EOS_ServiceFailure, 35)
/** Cache directory is not set in platform options. */
EOS_RESULT_VALUE(EOS_CacheDirectoryMissing, 36)
/** Cache directory is not accessible. */
EOS_RESULT_VALUE(EOS_CacheDirectoryInvalid, 37)
/** The request failed because resource was in an invalid state */
EOS_RESULT_VALUE(EOS_InvalidState, 38)
/** Request is in progress */
EOS_RESULT_VALUE(EOS_RequestInProgress, 39)

/** Account locked due to login failures */
EOS_RESULT_VALUE(EOS_Auth_AccountLocked, 1001)
/** Account locked by update operation. */
EOS_RESULT_VALUE(EOS_Auth_AccountLockedForUpdate, 1002)
/** Refresh token used was invalid */
EOS_RESULT_VALUE(EOS_Auth_InvalidRefreshToken, 1003)
/** Invalid access token, typically when switching between backend environments */
EOS_RESULT_VALUE(EOS_Auth_InvalidToken, 1004)
/** Invalid bearer token */
EOS_RESULT_VALUE(EOS_Auth_AuthenticationFailure, 1005)
/** Invalid platform token */
EOS_RESULT_VALUE(EOS_Auth_InvalidPlatformToken, 1006)
/** Auth parameters are not associated with this account */
EOS_RESULT_VALUE(EOS_Auth_WrongAccount, 1007)
/** Auth parameters are not associated with this client */
EOS_RESULT_VALUE(EOS_Auth_WrongClient, 1008)
/** Full account is required */
EOS_RESULT_VALUE(EOS_Auth_FullAccountRequired, 1009)
/** Headless account is required */
EOS_RESULT_VALUE(EOS_Auth_HeadlessAccountRequired, 1010)
/** Password reset is required */
EOS_RESULT_VALUE(EOS_Auth_PasswordResetRequired, 1011)
/** Password was previously used and cannot be reused */
EOS_RESULT_VALUE(EOS_Auth_PasswordCannotBeReused, 1012)
/** Authorization code/exchange code has expired */
EOS_RESULT_VALUE(EOS_Auth_Expired, 1013)
/** Consent has not been given by the user */
EOS_RESULT_VALUE(EOS_Auth_ScopeConsentRequired, 1014)
/** The application has no profile on the backend */
EOS_RESULT_VALUE(EOS_Auth_ApplicationNotFound, 1015)
/** The requested consent wasn't found on the backend */
EOS_RESULT_VALUE(EOS_Auth_ScopeNotFound, 1016)
/** This account has been denied access to login */
EOS_RESULT_VALUE(EOS_Auth_AccountFeatureRestricted, 1017)

/** Pin grant code initiated */
EOS_RESULT_VALUE(EOS_Auth_PinGrantCode, 1020)
/** Pin grant code attempt expired */
EOS_RESULT_VALUE(EOS_Auth_PinGrantExpired, 1021)
/** Pin grant code attempt pending */
EOS_RESULT_VALUE(EOS_Auth_PinGrantPending, 1022)

/** External auth source did not yield an account */
EOS_RESULT_VALUE(EOS_Auth_ExternalAuthNotLinked, 1030)
/** External auth access revoked */
EOS_RESULT_VALUE(EOS_Auth_ExternalAuthRevoked, 1032)
/** External auth token cannot be interpreted */
EOS_RESULT_VALUE(EOS_Auth_ExternalAuthInvalid, 1033)
/** External auth cannot be linked to his account due to restrictions */
EOS_RESULT_VALUE(EOS_Auth_ExternalAuthRestricted, 1034)
/** External auth cannot be used for login */
EOS_RESULT_VALUE(EOS_Auth_ExternalAuthCannotLogin, 1035)
/** External auth is expired */
EOS_RESULT_VALUE(EOS_Auth_ExternalAuthExpired, 1036)
/** External auth cannot be removed since it's the last possible way to login */
EOS_RESULT_VALUE(EOS_Auth_ExternalAuthIsLastLoginType, 1037)

/** Exchange code not found */
EOS_RESULT_VALUE(EOS_Auth_ExchangeCodeNotFound, 1040)
/** Originating exchange code session has expired */
EOS_RESULT_VALUE(EOS_Auth_OriginatingExchangeCodeSessionExpired, 1041)

/** The account has been disabled and cannot be used for authentication */
EOS_RESULT_VALUE(EOS_Auth_PersistentAuth_AccountNotActive, 1050)

/** MFA challenge required */
EOS_RESULT_VALUE(EOS_Auth_MFARequired, 1060)

/** Parental locks are in place */
EOS_RESULT_VALUE(EOS_Auth_ParentalControls, 1070)

/** Korea real ID association required but missing */
EOS_RESULT_VALUE(EOS_Auth_NoRealId, 1080)

/** An outgoing friend invitation is awaiting acceptance; sending another invite to the same user is erroneous */
EOS_RESULT_VALUE(EOS_Friends_InviteAwaitingAcceptance, 2000)
/** There is no friend invitation to accept/reject */
EOS_RESULT_VALUE(EOS_Friends_NoInvitation, 2001)
/** Users are already friends, so sending another invite is erroneous */
EOS_RESULT_VALUE(EOS_Friends_AlreadyFriends, 2003)
/** Users are not friends, so deleting the friend is erroneous */
EOS_RESULT_VALUE(EOS_Friends_NotFriends, 2004)
/** Remote user has too many invites to receive new invites */
EOS_RESULT_VALUE(EOS_Friends_TargetUserTooManyInvites, 2005)
/** Local user has too many invites to send new invites */
EOS_RESULT_VALUE(EOS_Friends_LocalUserTooManyInvites, 2006)
/** Remote user has too many friends to make a new friendship */
EOS_RESULT_VALUE(EOS_Friends_TargetUserFriendLimitExceeded, 2007)
/** Local user has too many friends to make a new friendship */
EOS_RESULT_VALUE(EOS_Friends_LocalUserFriendLimitExceeded, 2008)

/** Request data was null or invalid */
EOS_RESULT_VALUE(EOS_Presence_DataInvalid, 3000)
/** Request contained too many or too few unique data items, or the request would overflow the maximum amount of data allowed */
EOS_RESULT_VALUE(EOS_Presence_DataLengthInvalid, 3001)
/** Request contained data with an invalid key */
EOS_RESULT_VALUE(EOS_Presence_DataKeyInvalid, 3002)
/** Request contained data with a key too long or too short */
EOS_RESULT_VALUE(EOS_Presence_DataKeyLengthInvalid, 3003)
/** Request contained data with an invalid value */
EOS_RESULT_VALUE(EOS_Presence_DataValueInvalid, 3004)
/** Request contained data with a value too long */
EOS_RESULT_VALUE(EOS_Presence_DataValueLengthInvalid, 3005)
/** Request contained an invalid rich text string */
EOS_RESULT_VALUE(EOS_Presence_RichTextInvalid, 3006)
/** Request contained a rich text string that was too long */
EOS_RESULT_VALUE(EOS_Presence_RichTextLengthInvalid, 3007)
/** Request contained an invalid status state */
EOS_RESULT_VALUE(EOS_Presence_StatusInvalid, 3008)

/** The entitlement retrieved is stale, requery for updated information */
EOS_RESULT_VALUE(EOS_Ecom_EntitlementStale, 4000)
/** The offer retrieved is stale, requery for updated information */
EOS_RESULT_VALUE(EOS_Ecom_CatalogOfferStale, 4001)
/** The item or associated structure retrieved is stale, requery for updated information */
EOS_RESULT_VALUE(EOS_Ecom_CatalogItemStale, 4002)
/** The one or more offers has an invalid price. This may be caused by the price setup. */
EOS_RESULT_VALUE(EOS_Ecom_CatalogOfferPriceInvalid, 4003)
/** The checkout page failed to load */
EOS_RESULT_VALUE(EOS_Ecom_CheckoutLoadError, 4004)

/** Session is already in progress */
EOS_RESULT_VALUE(EOS_Sessions_SessionInProgress, 5000)
/** Too many players to register with this session */
EOS_RESULT_VALUE(EOS_Sessions_TooManyPlayers, 5001)
/** Client has no permissions to access this session */
EOS_RESULT_VALUE(EOS_Sessions_NoPermission, 5002)
/** Session already exists in the system */
EOS_RESULT_VALUE(EOS_Sessions_SessionAlreadyExists, 5003)
/** Session lock required for operation */
EOS_RESULT_VALUE(EOS_Sessions_InvalidLock, 5004)
/** Invalid session reference */
EOS_RESULT_VALUE(EOS_Sessions_InvalidSession, 5005)
/** Sandbox ID associated with auth didn't match */
EOS_RESULT_VALUE(EOS_Sessions_SandboxNotAllowed, 5006)
/** Invite failed to send */
EOS_RESULT_VALUE(EOS_Sessions_InviteFailed, 5007)
/** Invite was not found with the service */
EOS_RESULT_VALUE(EOS_Sessions_InviteNotFound, 5008)
/** This client may not modify the session */
EOS_RESULT_VALUE(EOS_Sessions_UpsertNotAllowed, 5009)
/** Backend nodes unavailable to process request */
EOS_RESULT_VALUE(EOS_Sessions_AggregationFailed, 5010)
/** Individual backend node is as capacity */
EOS_RESULT_VALUE(EOS_Sessions_HostAtCapacity, 5011)
/** Sandbox on node is at capacity */
EOS_RESULT_VALUE(EOS_Sessions_SandboxAtCapacity, 5012)
/** An anonymous operation was attempted on a non anonymous session */
EOS_RESULT_VALUE(EOS_Sessions_SessionNotAnonymous, 5013)
/** Session is currently out of sync with the backend, data is saved locally but needs to sync with backend */
EOS_RESULT_VALUE(EOS_Sessions_OutOfSync, 5014)
/** User has received too many invites */
EOS_RESULT_VALUE(EOS_Sessions_TooManyInvites, 5015)
/** Presence session already exists for the client */
EOS_RESULT_VALUE(EOS_Sessions_PresenceSessionExists, 5016)
/** Deployment on node is at capacity */
EOS_RESULT_VALUE(EOS_Sessions_DeploymentAtCapacity, 5017)
/** Session operation not allowed */
EOS_RESULT_VALUE(EOS_Sessions_NotAllowed, 5018)

/** Request filename was invalid */
EOS_RESULT_VALUE(EOS_PlayerDataStorage_FilenameInvalid, 6000)
/** Request filename was too long */
EOS_RESULT_VALUE(EOS_PlayerDataStorage_FilenameLengthInvalid, 6001)
/** Request filename contained invalid characters */
EOS_RESULT_VALUE(EOS_PlayerDataStorage_FilenameInvalidChars, 6002)
/** Request operation would grow file too large */
EOS_RESULT_VALUE(EOS_PlayerDataStorage_FileSizeTooLarge, 6003)
/** Request file length is not valid */
EOS_RESULT_VALUE(EOS_PlayerDataStorage_FileSizeInvalid, 6004)
/** Request file handle is not valid */
EOS_RESULT_VALUE(EOS_PlayerDataStorage_FileHandleInvalid, 6005)
/** Request data is invalid */
EOS_RESULT_VALUE(EOS_PlayerDataStorage_DataInvalid, 6006)
/** Request data length was invalid */
EOS_RESULT_VALUE(EOS_PlayerDataStorage_DataLengthInvalid, 6007)
/** Request start index was invalid */
EOS_RESULT_VALUE(EOS_PlayerDataStorage_StartIndexInvalid, 6008)
/** Request is in progress */
EOS_RESULT_VALUE(EOS_PlayerDataStorage_RequestInProgress, 6009)
/** User is marked as throttled which means he can't perform some operations because limits are exceeded.  */
EOS_RESULT_VALUE(EOS_PlayerDataStorage_UserThrottled, 6010)
/** Encryption key is not set during SDK init.  */
EOS_RESULT_VALUE(EOS_PlayerDataStorage_EncryptionKeyNotSet, 6011)
/** User data callback returned error (EOS_PlayerDataStorage_EWriteResult::EOS_WR_FailRequest or EOS_PlayerDataStorage_EReadResult::EOS_RR_FailRequest) */
EOS_RESULT_VALUE(EOS_PlayerDataStorage_UserErrorFromDataCallback, 6012)
/** User is trying to read file that has header from newer version of SDK. Game/SDK needs to be updated. */
EOS_RESULT_VALUE(EOS_PlayerDataStorage_FileHeaderHasNewerVersion, 6013)
/** The file is corrupted. In some cases retry can fix the issue. */
EOS_RESULT_VALUE(EOS_PlayerDataStorage_FileCorrupted, 6014)

/** EOS Auth service deemed the external token invalid */
EOS_RESULT_VALUE(EOS_Connect_ExternalTokenValidationFailed, 7000)
/** EOS Auth user already exists */
EOS_RESULT_VALUE(EOS_Connect_UserAlreadyExists, 7001)
/** EOS Auth expired */
EOS_RESULT_VALUE(EOS_Connect_AuthExpired, 7002)
/** EOS Auth invalid token */
EOS_RESULT_VALUE(EOS_Connect_InvalidToken, 7003)
/** EOS Auth doesn't support this token type */
EOS_RESULT_VALUE(EOS_Connect_UnsupportedTokenType, 7004)
/** EOS Auth Account link failure */
EOS_RESULT_VALUE(EOS_Connect_LinkAccountFailed, 7005)
/** EOS Auth External service for validation was unavailable */
EOS_RESULT_VALUE(EOS_Connect_ExternalServiceUnavailable, 7006)
/** EOS Auth External Service configuration failure with Dev Portal */
EOS_RESULT_VALUE(EOS_Connect_ExternalServiceConfigurationFailure, 7007)
/** EOS Auth Account link failure. Tried to link Nintendo Network Service Account without first linking Nintendo Account. DEPRECATED: The requirement has been removed and this error is no longer used. */
EOS_RESULT_VALUE(EOS_Connect_LinkAccountFailedMissingNintendoIdAccount_DEPRECATED, 7008)

/** The social overlay page failed to load */
EOS_RESULT_VALUE(EOS_UI_SocialOverlayLoadError, 8000)

/** Client has no permissions to modify this lobby */
EOS_RESULT_VALUE(EOS_Lobby_NotOwner, 9000)
/** Lobby lock required for operation */
EOS_RESULT_VALUE(EOS_Lobby_InvalidLock, 9001)
/** Lobby already exists in the system */
EOS_RESULT_VALUE(EOS_Lobby_LobbyAlreadyExists, 9002)
/** Lobby is already in progress */
EOS_RESULT_VALUE(EOS_Lobby_SessionInProgress, 9003)
/** Too many players to register with this lobby */
EOS_RESULT_VALUE(EOS_Lobby_TooManyPlayers, 9004)
/** Client has no permissions to access this lobby */
EOS_RESULT_VALUE(EOS_Lobby_NoPermission, 9005)
/** Invalid lobby session reference */
EOS_RESULT_VALUE(EOS_Lobby_InvalidSession, 9006)
/** Sandbox ID associated with auth didn't match */
EOS_RESULT_VALUE(EOS_Lobby_SandboxNotAllowed, 9007)
/** Invite failed to send */
EOS_RESULT_VALUE(EOS_Lobby_InviteFailed, 9008)
/** Invite was not found with the service */
EOS_RESULT_VALUE(EOS_Lobby_InviteNotFound, 9009)
/** This client may not modify the lobby */
EOS_RESULT_VALUE(EOS_Lobby_UpsertNotAllowed, 9010)
/** Backend nodes unavailable to process request */
EOS_RESULT_VALUE(EOS_Lobby_AggregationFailed, 9011)
/** Individual backend node is as capacity */
EOS_RESULT_VALUE(EOS_Lobby_HostAtCapacity, 9012)
/** Sandbox on node is at capacity */
EOS_RESULT_VALUE(EOS_Lobby_SandboxAtCapacity, 9013)
/** User has received too many invites */
EOS_RESULT_VALUE(EOS_Lobby_TooManyInvites, 9014)
/** Deployment on node is at capacity */
EOS_RESULT_VALUE(EOS_Lobby_DeploymentAtCapacity, 9015)
/** Lobby operation not allowed */
EOS_RESULT_VALUE(EOS_Lobby_NotAllowed, 9016)
/** While restoring a lost connection lobby ownership changed and only local member data was updated */
EOS_RESULT_VALUE(EOS_Lobby_MemberUpdateOnly, 9017)
/** Presence lobby already exists for the client */
EOS_RESULT_VALUE(EOS_Lobby_PresenceLobbyExists, 9018)

/** User callback that receives data from storage returned error. */
EOS_RESULT_VALUE(EOS_TitleStorage_UserErrorFromDataCallback, 10000)
/** User forgot to set Encryption key during platform init. Title Storage can't work without it. */
EOS_RESULT_VALUE(EOS_TitleStorage_EncryptionKeyNotSet, 10001)
/** Downloaded file is corrupted. */
EOS_RESULT_VALUE(EOS_TitleStorage_FileCorrupted, 10002)
/** Downloaded file's format is newer than client SDK version. */
EOS_RESULT_VALUE(EOS_TitleStorage_FileHeaderHasNewerVersion, 10003)

/** ModSdk process is already running. This error comes from the EOSSDK. */
EOS_RESULT_VALUE(EOS_Mods_ModSdkProcessIsAlreadyRunning, 11000)
/** ModSdk command is empty. Either the ModSdk configuration file is missing or the manifest location is empty. */
EOS_RESULT_VALUE(EOS_Mods_ModSdkCommandIsEmpty, 11001)
/** Creation of the ModSdk process failed. This error comes from the SDK. */
EOS_RESULT_VALUE(EOS_Mods_ModSdkProcessCreationFailed, 11002)
/** A critical error occurred in the external ModSdk process that we were unable to resolve. */
EOS_RESULT_VALUE(EOS_Mods_CriticalError, 11003)
/** A internal error occurred in the external ModSdk process that we were unable to resolve. */
EOS_RESULT_VALUE(EOS_Mods_ToolInternalError, 11004)
/** A IPC failure occurred in the external ModSdk process. */
EOS_RESULT_VALUE(EOS_Mods_IPCFailure, 11005)
/** A invalid IPC response received in the external ModSdk process. */
EOS_RESULT_VALUE(EOS_Mods_InvalidIPCResponse, 11006)
/** A URI Launch failure occurred in the external ModSdk process. */
EOS_RESULT_VALUE(EOS_Mods_URILaunchFailure, 11007)
/** Attempting to perform an action with a mod that is not installed. This error comes from the external ModSdk process. */
EOS_RESULT_VALUE(EOS_Mods_ModIsNotInstalled, 11008)
/** Attempting to perform an action on a game that the user doesn't own. This error comes from the external ModSdk process. */
EOS_RESULT_VALUE(EOS_Mods_UserDoesNotOwnTheGame, 11009)
/** Invalid result of the request to get the offer for the mod. This error comes from the external ModSdk process. */
EOS_RESULT_VALUE(EOS_Mods_OfferRequestByIdInvalidResult, 11010)
/** Could not find the offer for the mod. This error comes from the external ModSdk process. */
EOS_RESULT_VALUE(EOS_Mods_CouldNotFindOffer, 11011)
/** Request to get the offer for the mod failed. This error comes from the external ModSdk process. */
EOS_RESULT_VALUE(EOS_Mods_OfferRequestByIdFailure, 11012)
/** Request to purchase the mod failed. This error comes from the external ModSdk process. */
EOS_RESULT_VALUE(EOS_Mods_PurchaseFailure, 11013)
/** Attempting to perform an action on a game that is not installed or is partially installed. This error comes from the external ModSdk process. */
EOS_RESULT_VALUE(EOS_Mods_InvalidGameInstallInfo, 11014)
/** Failed to get manifest location. Either the ModSdk configuration file is missing or the manifest location is empty */
EOS_RESULT_VALUE(EOS_Mods_CannotGetManifestLocation, 11015)
/** Attempting to perform an action with a mod that does not support the current operating system. */
EOS_RESULT_VALUE(EOS_Mods_UnsupportedOS, 11016)

/** The anti-cheat client protection is not available. Check that the game was started using the anti-cheat bootstrapper. */
EOS_RESULT_VALUE(EOS_AntiCheat_ClientProtectionNotAvailable, 12000)
/** The current anti-cheat mode is incorrect for using this API */
EOS_RESULT_VALUE(EOS_AntiCheat_InvalidMode, 12001)
/** The ProductId provided to the anti-cheat client helper executable does not match what was used to initialize the EOS SDK */
EOS_RESULT_VALUE(EOS_AntiCheat_ClientProductIdMismatch, 12002)
/** The SandboxId provided to the anti-cheat client helper executable does not match what was used to initialize the EOS SDK */
EOS_RESULT_VALUE(EOS_AntiCheat_ClientSandboxIdMismatch, 12003)
/** (ProtectMessage/UnprotectMessage) No session key is available, but it is required to complete this operation */
EOS_RESULT_VALUE(EOS_AntiCheat_ProtectMessageSessionKeyRequired, 12004)
/** (ProtectMessage/UnprotectMessage) Message integrity is invalid */
EOS_RESULT_VALUE(EOS_AntiCheat_ProtectMessageValidationFailed, 12005)
/** (ProtectMessage/UnprotectMessage) Initialization failed */
EOS_RESULT_VALUE(EOS_AntiCheat_ProtectMessageInitializationFailed, 12006)
/** (RegisterPeer) Peer is already registered */
EOS_RESULT_VALUE(EOS_AntiCheat_PeerAlreadyRegistered, 12007)
/** (UnregisterPeer) Peer does not exist */
EOS_RESULT_VALUE(EOS_AntiCheat_PeerNotFound, 12008)
/** (ReceiveMessageFromPeer) Invalid call: Peer is not protected */
EOS_RESULT_VALUE(EOS_AntiCheat_PeerNotProtected, 12009)
/** The DeploymentId provided to the anti-cheat client helper executable does not match what was used to initialize the EOS SDK */
EOS_RESULT_VALUE(EOS_AntiCheat_ClientDeploymentIdMismatch, 12010)
/** EOS Connect DeviceID auth method is not supported for anti-cheat */
EOS_RESULT_VALUE(EOS_AntiCheat_DeviceIdAuthIsNotSupported, 12011)

/** EOS RTC room cannot accept more participants */
EOS_RESULT_VALUE(EOS_RTC_TooManyParticipants, 13000)
/** EOS RTC room already exists*/
EOS_RESULT_VALUE(EOS_RTC_RoomAlreadyExists, 13001)
/** The user kicked out from the room */
EOS_RESULT_VALUE(EOS_RTC_UserKicked, 13002)
/** The user is banned */
EOS_RESULT_VALUE(EOS_RTC_UserBanned, 13003)
/** EOS RTC room was left successfully */
EOS_RESULT_VALUE(EOS_RTC_RoomWasLeft, 13004)
/** Connection dropped due to long timeout */
EOS_RESULT_VALUE(EOS_RTC_ReconnectionTimegateExpired, 13005)

/** The number of available Snapshot IDs have all been exhausted. */
EOS_RESULT_VALUE(EOS_ProgressionSnapshot_SnapshotIdUnavailable, 14000)

/** The KWS user does not have a parental email associated with the account.  The parent account was unlinked or deleted */
EOS_RESULT_VALUE(EOS_KWS_ParentEmailMissing, 15000)
/** The KWS user is no longer a minor and trying to update the parent email */
EOS_RESULT_VALUE(EOS_KWS_UserGraduated, 15001)

/** EOS Android VM not stored */
EOS_RESULT_VALUE(EOS_Android_JavaVMNotStored, 17000)

/** An unexpected error that we cannot identify has occurred. */
EOS_RESULT_VALUE_LAST(EOS_UnexpectedError, 0x7FFFFFFF)

```

`eac/sdk/Include/eos_rtc.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_rtc_types.h"
#include "eos_rtc_audio_types.h"

/**
 * The RTC Interface is used to manage joining and leaving rooms.
 *
 * @see EOS_Platform_GetRTCInterface
 */

/**
 * Get a handle to the Audio interface
 * @return EOS_HRTCAudio handle
 *
 * @see eos_rtc_audio.h
 * @see eos_rtc_audio_types.h
 */
EOS_DECLARE_FUNC(EOS_HRTCAudio) EOS_RTC_GetAudioInterface(EOS_HRTC Handle);

/**
 * Use this function to join a room.
 *
 * This function does not need to called for the Lobby RTC Room system; doing so will return EOS_AccessDenied. The lobby system will
 * automatically join and leave RTC Rooms for all lobbies that have RTC rooms enabled.
 *
 * @param Options structure containing the parameters for the operation.
 * @param ClientData Arbitrary data that is passed back in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error
 */
EOS_DECLARE_FUNC(void) EOS_RTC_JoinRoom(EOS_HRTC Handle, const EOS_RTC_JoinRoomOptions* Options, void* ClientData, const EOS_RTC_OnJoinRoomCallback CompletionDelegate);

/**
 * Use this function to leave a room and clean up all the resources associated with it. This function has to always be called when the
 * room is abandoned even if the user is already disconnected for other reasons.
 *
 * This function does not need to called for the Lobby RTC Room system; doing so will return EOS_AccessDenied. The lobby system will
 * automatically join and leave RTC Rooms for all lobbies that have RTC rooms enabled.
 *
 * @param Options structure containing the parameters for the operation.
 * @param ClientData Arbitrary data that is passed back in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error
 * @return EOS_Success if the operation succeeded
 *         EOS_InvalidParameters if any of the parameters are incorrect
 *         EOS_NotFound if not in the specified room
 */
EOS_DECLARE_FUNC(void) EOS_RTC_LeaveRoom(EOS_HRTC Handle, const EOS_RTC_LeaveRoomOptions* Options, void* ClientData, const EOS_RTC_OnLeaveRoomCallback CompletionDelegate);

/**
 * Use this function to block a participant already connected to the room. After blocking them no media will be sent or received between
 * that user and the local user. This method can be used after receiving the OnParticipantStatusChanged notification.
 *
 * @param Options structure containing the parameters for the operation.
 * @param ClientData Arbitrary data that is passed back in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error
 * @return EOS_Success if the operation succeeded
 *         EOS_InvalidParameters if any of the parameters are incorrect
 *         EOS_NotFound if either the local user or specified participant are not in the specified room
 */
EOS_DECLARE_FUNC(void) EOS_RTC_BlockParticipant(EOS_HRTC Handle, EOS_RTC_BlockParticipantOptions* Options, void* ClientData, const EOS_RTC_OnBlockParticipantCallback CompletionDelegate);

/**
 * Register to receive notifications when disconnected from the room. If the returned NotificationId is valid, you must call
 * EOS_RTC_RemoveNotifyDisconnected when you no longer wish to have your CompletionDelegate called.
 *
 * This function will always return EOS_INVALID_NOTIFICATIONID when used with lobby RTC room. To be notified of the connection
 * status of a Lobby-managed RTC room, use the EOS_Lobby_AddNotifyRTCRoomConnectionChanged function instead.
 *
 * @param ClientData Arbitrary data that is passed back in the CompletionDelegate
 * @param CompletionDelegate The callback to be fired when a presence change occurs
 * @return Notification ID representing the registered callback if successful, an invalid NotificationId if not
 *
 * @see EOS_INVALID_NOTIFICATIONID
 * @see EOS_RTC_RemoveNotifyDisconnected
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_RTC_AddNotifyDisconnected(EOS_HRTC Handle, EOS_RTC_AddNotifyDisconnectedOptions* Options, void* ClientData, const EOS_RTC_OnDisconnectedCallback CompletionDelegate);

/**
 * Unregister a previously bound notification handler from receiving room disconnection notifications
 *
 * @param NotificationId The Notification ID representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_RTC_RemoveNotifyDisconnected(EOS_HRTC Handle, EOS_NotificationId NotificationId);

/**
 * Register to receive notifications when a participant's status changes (e.g: join or leave the room). If the returned NotificationId is valid, you must call
 * EOS_RTC_RemoveNotifyParticipantStatusChanged when you no longer wish to have your CompletionDelegate called.
 *
 * If you register to this notification before joining a room, you will receive a notification for every member already in the room when you join said room.
 * This allows you to know who is already in the room when you join.
 *
 * To be used effectively with a Lobby-managed RTC room, this should be registered during the EOS_Lobby_CreateLobby or EOS_Lobby_JoinLobby completion
 * callbacks when the ResultCode is EOS_Success. If this notification is registered after that point, it is possible to miss notifications for
 * already-existing room participants.
 *
 * @param ClientData Arbitrary data that is passed back in the CompletionDelegate
 * @param CompletionDelegate The callback to be fired when a presence change occurs
 * @return Notification ID representing the registered callback if successful, an invalid NotificationId if not
 *
 * @note This notification is also raised when the local user joins the room, but NOT when the local user leaves the room.
 *
 * @see EOS_INVALID_NOTIFICATIONID
 * @see EOS_RTC_RemoveNotifyParticipantStatusChanged
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_RTC_AddNotifyParticipantStatusChanged(EOS_HRTC Handle, EOS_RTC_AddNotifyParticipantStatusChangedOptions* Options, void* ClientData, const EOS_RTC_OnParticipantStatusChangedCallback CompletionDelegate);

/**
 * Unregister a previously bound notification handler from receiving participant status change notifications
 *
 * @param NotificationId The Notification ID representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_RTC_RemoveNotifyParticipantStatusChanged(EOS_HRTC Handle, EOS_NotificationId NotificationId);

/**
 * Use this function to control settings.
 *
 * The available settings are documented as part of EOS_RTC_SetSettingOptions.
 *
 * @param Options structure containing the parameters for the operation
 * @return EOS_Success when the setting is successfully set, EOS_NotFound when the setting is unknown, EOS_InvalidParameters when the value is invalid.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_RTC_SetSetting(EOS_HRTC Handle, const EOS_RTC_SetSettingOptions* Options);

/**
 * Use this function to control settings for the specific room.
 *
 * The available settings are documented as part of EOS_RTC_SetRoomSettingOptions.
 *
 * @param Options structure containing the parameters for the operation
 * @return EOS_Success when the setting is successfully set, EOS_NotFound when the setting is unknown, EOS_InvalidParameters when the value is invalid.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_RTC_SetRoomSetting(EOS_HRTC Handle, const EOS_RTC_SetRoomSettingOptions* Options);

```

`eac/sdk/Include/eos_rtc_admin.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_rtc_admin_types.h"

/**
* The RTC Admin interface.
*
* This is used to manage admin-specific RTC features, such as requesting join tokens, kick users, etc.
*
* @see EOS_Platform_GetRTCAdminInterface
*/

/**
 * Query for a list of user tokens for joining a room.
 *
 * Each query generates a query id ( see EOS_RTCAdmin_QueryJoinRoomTokenCompleteCallbackInfo ) which should be used
 * to retrieve the tokens from inside the callback.
 *
 *This query id and query result itself are only valid for the duration of the callback.
 *
 * @param Options Structure containing information about the application whose user tokens we're retrieving.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate This function is called when the query join room token operation completes.
 *
 * @return EOS_Success if the operation completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 */
EOS_DECLARE_FUNC(void) EOS_RTCAdmin_QueryJoinRoomToken(EOS_HRTCAdmin Handle, const EOS_RTCAdmin_QueryJoinRoomTokenOptions* Options, void* ClientData, const EOS_RTCAdmin_OnQueryJoinRoomTokenCompleteCallback CompletionDelegate);

/**
 * Fetches a user token when called inside of the OnQueryJoinRoomTokenComplete callback.
 *
 * @param Options Structure containing the index being accessed
 * @param OutUserToken The user token for the given index, if it exists and is valid. Use EOS_RTCAdmin_UserToken_Release when finished
 *
 * @note The order of the tokens doesn't necessarily match the order of the EOS_ProductUserId array specified in the EOS_RTCAdmin_QueryJoinRoomTokenOptions when
 * initiating the query.
 *
 * @see EOS_RTCAdmin_UserToken_Release
 *
 * @return EOS_Success if the information is available and passed out in OutUserToken
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the user token is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_RTCAdmin_CopyUserTokenByIndex(EOS_HRTCAdmin Handle, const EOS_RTCAdmin_CopyUserTokenByIndexOptions* Options, EOS_RTCAdmin_UserToken ** OutUserToken);

/**
 * Fetches a user token for a given user ID when called inside of the OnQueryJoinRoomTokenComplete callback.
 *
 * @param Options Structure containing the user ID being accessed
 * @param OutUserToken The user token for the given user ID, if it exists and is valid. Use EOS_RTCAdmin_UserToken_Release when finished
 *
 * @see EOS_RTCAdmin_UserToken_Release
 *
 * @return EOS_Success if the information is available and passed out in OutUserToken
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the user token is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_RTCAdmin_CopyUserTokenByUserId(EOS_HRTCAdmin Handle, const EOS_RTCAdmin_CopyUserTokenByUserIdOptions* Options, EOS_RTCAdmin_UserToken ** OutUserToken);

/**
 * Starts an asynchronous task that removes a participant from a room and revokes their token.
 *
 * @param Options structure containing the room and user to revoke the token from.
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error
 *
 */
EOS_DECLARE_FUNC(void) EOS_RTCAdmin_Kick(EOS_HRTCAdmin Handle, const EOS_RTCAdmin_KickOptions* Options, void* ClientData, const EOS_RTCAdmin_OnKickCompleteCallback CompletionDelegate);

/**
 * Starts an asynchronous task remotely mutes/unmutes a room participant.
 *
 * This remotely mutes the specified participant, so no audio is sent from that participant to any other participant in the room.
 *
 * @param Options structure containing the room and user to mute.
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error
 */
EOS_DECLARE_FUNC(void) EOS_RTCAdmin_SetParticipantHardMute(EOS_HRTCAdmin Handle, const EOS_RTCAdmin_SetParticipantHardMuteOptions* Options, void* ClientData, const EOS_RTCAdmin_OnSetParticipantHardMuteCompleteCallback CompletionDelegate);

```

`eac/sdk/Include/eos_rtc_admin_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

EXTERN_C typedef struct EOS_RTCAdminHandle* EOS_HRTCAdmin;

/** The most recent version of the EOS_RTCAdmin_QueryJoinRoomToken API */
#define EOS_RTCADMIN_QUERYJOINROOMTOKEN_API_LATEST 2

/**
 * Input parameters for the EOS_RTCAdmin_QueryJoinRoomToken function.
 */
EOS_STRUCT(EOS_RTCAdmin_QueryJoinRoomTokenOptions, (
	/** API Version: Set this to EOS_RTCADMIN_QUERYJOINROOMTOKEN_API_LATEST. */
	int32_t ApiVersion;
	/** Product User ID for local user who is querying join room tokens. */
	EOS_ProductUserId LocalUserId;
	/** Room name to request a token for. */
	const char* RoomName;
	/** An array of Product User IDs indicating the users to retrieve a token for. */
	EOS_ProductUserId* TargetUserIds;
	/** The number of users included in the query. */
	uint32_t TargetUserIdsCount;
	/**
	 * Array of IP Addresses, one for each of the users we're querying tokens for.
	 * There should be TargetUserIdsCount Ip Addresses, you can set an entry to NULL if not known.
	 * If TargetUserIpAddresses is set to NULL IP Addresses will be ignored.
	 * IPv4 format: "0.0.0.0"
	 * IPv6 format: "0:0:0:0:0:0:0:0"
	 */
	const char** TargetUserIpAddresses;
));

/**
 * Data containing the result information for a query join room token request.
 */
EOS_STRUCT(EOS_RTCAdmin_QueryJoinRoomTokenCompleteCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_RTCAdmin_QueryJoinRoomToken. */
	void* ClientData;
	/** Room the request was made for. */
	const char* RoomName;
	/** URL passed to backend to join room. */
	const char* ClientBaseUrl;
	/** If the query completed successfully, this contains an identifier that should be used to retrieve the tokens.
	 * This identifier is only valid for the duration of the callback. 
	 *
	 * @see EOS_RTCAdmin_CopyUserTokenByIndex
	 * @see EOS_RTCAdmin_CopyUserTokenByUserId
	 */
	uint32_t QueryId;
	/** How many token received as result of the query */
	uint32_t TokenCount;
));

/**
 * Function prototype definition for callbacks passed to EOS_RTCAdmin_QueryJoinRoomToken
 * @param Data An EOS_RTCAdmin_QueryJoinRoomTokenCompleteCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_RTCAdmin_OnQueryJoinRoomTokenCompleteCallback, const EOS_RTCAdmin_QueryJoinRoomTokenCompleteCallbackInfo* Data);

/** The most recent version of the EOS_RTCAdmin_UserToken struct. */
#define EOS_RTCADMIN_USERTOKEN_API_LATEST 1

/**
 * Contains information about a collection of user tokens for joining a room.
 */
EOS_STRUCT(EOS_RTCAdmin_UserToken, (
	/** API Version: Set this to EOS_RTCADMIN_USERTOKEN_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID for the user who owns this user token. */
	EOS_ProductUserId ProductUserId;
	/** Access token to enable a user to join a room */
	const char* Token;
));

/** The most recent version of the EOS_RTCAdmin_CopyUserTokenByIndexOptions struct. */
#define EOS_RTCADMIN_COPYUSERTOKENBYINDEX_API_LATEST 2

/**
 * Input parameters for the EOS_RTCAdmin_CopyUserTokenByIndex function.
 */
EOS_STRUCT(EOS_RTCAdmin_CopyUserTokenByIndexOptions, (
	/** API Version: Set this to EOS_RTCADMIN_COPYUSERTOKENBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** Index of the user token to retrieve from the cache. */
	uint32_t UserTokenIndex;
	/** Query identifier received as part of a previous query.
	 * @see EOS_RTCAdmin_QueryJoinRoomTokenCompleteCallbackInfo
	 */
	uint32_t QueryId;
));

/** The most recent version of the EOS_RTCAdmin_CopyUserTokenByUserIdOptions struct. */
#define EOS_RTCADMIN_COPYUSERTOKENBYUSERID_API_LATEST 2

/**
 * Input parameters for the EOS_RTCAdmin_CopyUserTokenByUserId function.
 */
EOS_STRUCT(EOS_RTCAdmin_CopyUserTokenByUserIdOptions, (
	/** API Version: Set this to EOS_RTCADMIN_COPYUSERTOKENBYUSERID_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID for the user whose user token we're copying. */
	EOS_ProductUserId TargetUserId;
	/** Query identifier received as part of a previous query.
	 * @see EOS_RTCAdmin_QueryJoinRoomTokenCompleteCallbackInfo
	 */
	uint32_t QueryId;
));

/**
 * Release the memory associated with EOS_RTCAdmin_UserToken. This must be called on data retrieved from
 * EOS_RTCAdmin_CopyUserTokenByIndex or EOS_RTCAdmin_CopyUserTokenByUserId.
 *
 * @param UserToken - The user token to release.
 *
 * @see EOS_RTCAdmin_UserToken
 * @see EOS_RTCAdmin_CopyUserTokenByIndex
 * @see EOS_RTCAdmin_CopyUserTokenByUserId
 */
EOS_DECLARE_FUNC(void) EOS_RTCAdmin_UserToken_Release(EOS_RTCAdmin_UserToken* UserToken);

/** The most recent version of the EOS_RTCAdmin_Kick API */
#define EOS_RTCADMIN_KICK_API_LATEST 1

/**
 * Input parameters for the EOS_RTCAdmin_Kick function.
 */
EOS_STRUCT(EOS_RTCAdmin_KickOptions, (
	/** API Version: Set this to EOS_RTCADMIN_KICK_API_LATEST. */
	int32_t ApiVersion;
	/** Room name to kick the participant from */
	const char* RoomName;
	/** Product User ID of the participant to kick from the room */
	EOS_ProductUserId TargetUserId;
));

/**
 * Data containing the result information for a kick participant request.
 */
EOS_STRUCT(EOS_RTCAdmin_KickCompleteCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Client-specified data passed into the kick request */
	void* ClientData;
));

/**
 * Function prototype definition for callbacks passed to EOS_RTCAdmin_Kick
 * @param Data An EOS_RTCAdmin_KickCompleteCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_RTCAdmin_OnKickCompleteCallback, const EOS_RTCAdmin_KickCompleteCallbackInfo* Data);

/** The most recent version of the EOS_RTCAdmin_SetParticipantHardMuteOptions struct. */
#define EOS_RTCADMIN_SETPARTICIPANTHARDMUTE_API_LATEST 1

/**
 * Input parameters for the EOS_RTCAdmin_SetParticipantHardMute function.
 */
EOS_STRUCT(EOS_RTCAdmin_SetParticipantHardMuteOptions, (
	/** API Version: Set this to EOS_RTCADMIN_SETPARTICIPANTHARDMUTE_API_LATEST. */
	int32_t ApiVersion;
	/** Room to kick the participant from */
	const char* RoomName;
	/** Product User ID of the participant to hard mute for every participant in the room. */
	EOS_ProductUserId TargetUserId;
	/** Hard mute status (Mute on or off) */
	EOS_Bool bMute;
));

/**
 * Data containing the result information for a hard mute request.
 */
EOS_STRUCT(EOS_RTCAdmin_SetParticipantHardMuteCompleteCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Client-specified data passed into the hard mute request */
	void* ClientData;
));

EOS_DECLARE_CALLBACK(EOS_RTCAdmin_OnSetParticipantHardMuteCompleteCallback, const EOS_RTCAdmin_SetParticipantHardMuteCompleteCallbackInfo* Data);

#pragma pack(pop)


```

`eac/sdk/Include/eos_rtc_audio.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_rtc_audio_types.h"

/**
 * The RTC Audio Interface. This is used to manage Audio specific RTC features
 *
 * @see EOS_RTC_GetVoiceInterface
 */

/**
 * Use this function to inform the audio system of a user.
 *
 * This function is only necessary for some platforms.
 *
 * @param Options structure containing the parameters for the operation.
 * @return EOS_Success if the user was successfully registered, EOS_UnexpectedError otherwise.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_RTCAudio_RegisterPlatformAudioUser(EOS_HRTCAudio Handle, const EOS_RTCAudio_RegisterPlatformAudioUserOptions* Options);

/**
 * Use this function to remove a user that was added with EOS_RTCAudio_RegisterPlatformAudioUser.
 *
 * @param Options structure containing the parameters for the operation.
 * @return EOS_Success if the user was successfully unregistered, EOS_UnexpectedError otherwise.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_RTCAudio_UnregisterPlatformAudioUser(EOS_HRTCAudio Handle, const EOS_RTCAudio_UnregisterPlatformAudioUserOptions* Options);

/**
 * Returns the number of audio input devices available in the system.
 *
 * The returned value should not be cached and should instead be used immediately with the EOS_RTCAudio_GetAudioInputDeviceByIndex
 * function.
 *
 * @param Options structure containing the parameters for the operation
 * @return The number of audio input devices
 * @see EOS_RTCAudio_GetAudioInputDeviceByIndex
 * @see EOS_RTCAudio_AddNotifyAudioDevicesChanged
 */
EOS_DECLARE_FUNC(uint32_t) EOS_RTCAudio_GetAudioInputDevicesCount(EOS_HRTCAudio Handle, const EOS_RTCAudio_GetAudioInputDevicesCountOptions* Options);

/**
 * Fetches an audio input device's info from then given index. The returned value should not be cached and important
 * information should be copied off of the result object immediately.
 *
 * @param Options structure containing the index being accessed
 * @return A pointer to the device information, or NULL on error. You should NOT keep hold of this pointer.
 * @see EOS_RTCAudio_GetAudioInputDevicesCount
 * @see EOS_RTCAudio_AddNotifyAudioDevicesChanged
 */
EOS_DECLARE_FUNC(const EOS_RTCAudio_AudioInputDeviceInfo *) EOS_RTCAudio_GetAudioInputDeviceByIndex(EOS_HRTCAudio Handle, const EOS_RTCAudio_GetAudioInputDeviceByIndexOptions* Options);

/**
 * Returns the number of audio output devices available in the system.
 *
 * The returned value should not be cached and should instead be used immediately with the EOS_RTCAudio_GetAudioOutputDeviceByIndex
 * function.
 *
 * @param Options structure containing the parameters for the operation
 * @return The number of audio output devices
 * @see EOS_RTCAudio_GetAudioOutputDeviceByIndex
 * @see EOS_RTCAudio_AddNotifyAudioDevicesChanged
 */
EOS_DECLARE_FUNC(uint32_t) EOS_RTCAudio_GetAudioOutputDevicesCount(EOS_HRTCAudio Handle, const EOS_RTCAudio_GetAudioOutputDevicesCountOptions* Options);

/**
 * Fetches an audio output device's info from then given index.
 *
 * The returned value should not be cached and important information should be copied off of the result object immediately.
 *
 * @param Options structure containing the index being accessed
 * @return A pointer to the device information, or NULL on error. You should NOT keep hold of this pointer.
 * @see EOS_RTCAudio_GetAudioOutputDevicesCount
 * @see EOS_RTCAudio_AddNotifyAudioDevicesChanged
 */
EOS_DECLARE_FUNC(const EOS_RTCAudio_AudioOutputDeviceInfo *) EOS_RTCAudio_GetAudioOutputDeviceByIndex(EOS_HRTCAudio Handle, const EOS_RTCAudio_GetAudioOutputDeviceByIndexOptions* Options);

/**
 * Use this function to set audio input settings, such as the active input device, volume, or platform AEC.
 *
 * @param Options structure containing the parameters for the operation.
 * @return EOS_Success if the setting was successful
 *         EOS_InvalidParameters if any of the parameters are incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_RTCAudio_SetAudioInputSettings(EOS_HRTCAudio Handle, const EOS_RTCAudio_SetAudioInputSettingsOptions* Options);

/**
 * Use this function to set audio output settings, such as the active output device or volume.
 *
 * @param Options structure containing the parameters for the operation.
 * @return EOS_Success if the setting was successful
 *         EOS_InvalidParameters if any of the parameters are incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_RTCAudio_SetAudioOutputSettings(EOS_HRTCAudio Handle, const EOS_RTCAudio_SetAudioOutputSettingsOptions* Options);

/**
 * Use this function to push a new audio buffer to be sent to the participants of a room.
 *
 * This should only be used if Manual Audio Input was enabled locally for the specified room.
 *
 * @param Options structure containing the parameters for the operation.
 * @return EOS_Success if the buffer was successfully queued for sending
 *         EOS_InvalidParameters if any of the parameters are incorrect
 *         EOS_NotFound if the specified room was not found
 *         EOS_InvalidState if manual recording was not enabled when joining the room.
 * @see EOS_RTC_JoinRoomOptions
 * @see EOS_Lobby_LocalRTCOptions
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_RTCAudio_SendAudio(EOS_HRTCAudio Handle, const EOS_RTCAudio_SendAudioOptions* Options);

/**
 * Use this function to tweak outgoing audio options per room.
 *
 * @note Due to internal implementation details, this function requires that you first register to any notification for room
 *
 * @param Options structure containing the parameters for the operation.
 * @param ClientData Arbitrary data that is passed back in the CompletionDelegate
 * @param CompletionDelegate The callback to be fired when the operation completes, either successfully or in error
 * @return EOS_Success if the operation succeeded
 *         EOS_InvalidParameters if any of the parameters are incorrect
 *         EOS_NotFound if the local user is not in the room
 */
EOS_DECLARE_FUNC(void) EOS_RTCAudio_UpdateSending(EOS_HRTCAudio Handle, const EOS_RTCAudio_UpdateSendingOptions* Options, void* ClientData, const EOS_RTCAudio_OnUpdateSendingCallback CompletionDelegate);

/**
 * Use this function to tweak incoming audio options per room.
 *
 * @note Due to internal implementation details, this function requires that you first register to any notification for room
 *
 * @param Options structure containing the parameters for the operation.
 * @param ClientData Arbitrary data that is passed back in the CompletionDelegate
 * @param CompletionDelegate The callback to be fired when the operation completes, either successfully or in error
 * @return EOS_Success if the operation succeeded
 *         EOS_InvalidParameters if any of the parameters are incorrect
 *         EOS_NotFound if either the local user or specified participant are not in the room
 */
EOS_DECLARE_FUNC(void) EOS_RTCAudio_UpdateReceiving(EOS_HRTCAudio Handle, const EOS_RTCAudio_UpdateReceivingOptions* Options, void* ClientData, const EOS_RTCAudio_OnUpdateReceivingCallback CompletionDelegate);

/**
 * Register to receive notifications when a room participant audio status is updated (f.e when speaking flag changes).
 *
 * If the returned NotificationId is valid, you must call EOS_RTCAudio_RemoveNotifyParticipantUpdated when you no longer wish
 * to have your CompletionDelegate called.
 *
 * @param ClientData Arbitrary data that is passed back in the CompletionDelegate
 * @param CompletionDelegate The callback to be fired when a presence change occurs
 * @return Notification ID representing the registered callback if successful, an invalid NotificationId if not
 *
 * @see EOS_INVALID_NOTIFICATIONID
 * @see EOS_RTCAudio_RemoveNotifyParticipantUpdated
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_RTCAudio_AddNotifyParticipantUpdated(EOS_HRTCAudio Handle, EOS_RTCAudio_AddNotifyParticipantUpdatedOptions* Options, void* ClientData, const EOS_RTCAudio_OnParticipantUpdatedCallback CompletionDelegate);

/**
 * Unregister a previously bound notification handler from receiving participant updated notifications
 *
 * @param NotificationId The Notification ID representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_RTCAudio_RemoveNotifyParticipantUpdated(EOS_HRTCAudio Handle, EOS_NotificationId NotificationId);

/**
 * Register to receive notifications when an audio device is added or removed to the system.
 *
 * If the returned NotificationId is valid, you must call EOS_RTCAudio_RemoveNotifyAudioDevicesChanged when you no longer wish
 * to have your CompletionDelegate called.
 *
 * @param ClientData Arbitrary data that is passed back in the CompletionDelegate
 * @param CompletionDelegate The callback to be fired when an audio device change occurs
 * @return Notification ID representing the registered callback if successful, an invalid NotificationId if not
 *
 * @see EOS_INVALID_NOTIFICATIONID
 * @see EOS_RTCAudio_RemoveNotifyAudioDevicesChanged
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_RTCAudio_AddNotifyAudioDevicesChanged(EOS_HRTCAudio Handle, EOS_RTCAudio_AddNotifyAudioDevicesChangedOptions* Options, void* ClientData, const EOS_RTCAudio_OnAudioDevicesChangedCallback CompletionDelegate);

/**
 * Unregister a previously bound notification handler from receiving audio devices notifications
 *
 * @param NotificationId The Notification ID representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_RTCAudio_RemoveNotifyAudioDevicesChanged(EOS_HRTCAudio Handle, EOS_NotificationId NotificationId);

/**
 * Register to receive notifications when audio input state changed.
 *
 * If the returned NotificationId is valid, you must call EOS_RTCAudio_RemoveNotifyAudioInputState when you no longer wish to
 * have your CompletionDelegate called.
 *
 * @param ClientData Arbitrary data that is passed back in the CompletionDelegate
 * @param CompletionDelegate The callback to be fired when audio input state changes
 * @return Notification ID representing the registered callback if successful, an invalid NotificationId if not
 *
 * @see EOS_INVALID_NOTIFICATIONID
 * @see EOS_RTCAudio_RemoveNotifyAudioInputState
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_RTCAudio_AddNotifyAudioInputState(EOS_HRTCAudio Handle, EOS_RTCAudio_AddNotifyAudioInputStateOptions* Options, void* ClientData, const EOS_RTCAudio_OnAudioInputStateCallback CompletionDelegate);

/**
 * Unregister a previously bound notification handler from receiving notifications on audio input state changed.
 *
 * @param NotificationId The Notification ID representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_RTCAudio_RemoveNotifyAudioInputState(EOS_HRTCAudio Handle, EOS_NotificationId NotificationId);

/**
 * Register to receive notifications when audio output state changed.
 *
 * If the returned NotificationId is valid, you must call EOS_RTCAudio_RemoveNotifyAudioOutputState when you no longer wish to
 * have your CompletionDelegate called.
 *
 * @param ClientData Arbitrary data that is passed back in the CompletionDelegate
 * @param CompletionDelegate The callback to be fired when audio output state changes
 * @return Notification ID representing the registered callback if successful, an invalid NotificationId if not
 *
 * @see EOS_INVALID_NOTIFICATIONID
 * @see EOS_RTCAudio_RemoveNotifyAudioOutputState
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_RTCAudio_AddNotifyAudioOutputState(EOS_HRTCAudio Handle, EOS_RTCAudio_AddNotifyAudioOutputStateOptions* Options, void* ClientData, const EOS_RTCAudio_OnAudioOutputStateCallback CompletionDelegate);

/**
 * Unregister a previously bound notification handler from receiving notifications on audio output state changed.
 *
 * @param NotificationId The Notification ID representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_RTCAudio_RemoveNotifyAudioOutputState(EOS_HRTCAudio Handle, EOS_NotificationId NotificationId);

/**
 * Register to receive notifications when local audio buffers are about to be encoded and sent.
 *
 * This gives you access to the audio data about to be sent, allowing for example the implementation of custom filters/effects.
 *
 * If the returned NotificationId is valid, you must call EOS_RTCAudio_RemoveNotifyAudioBeforeSend when you no longer wish to
 * have your CompletionDelegate called.
 *
 * @param ClientData Arbitrary data that is passed back in the CompletionDelegate
 * @param CompletionDelegate The callback to be fired when a presence change occurs
 * @return Notification ID representing the registered callback if successful, an invalid NotificationId if not
 *
 * @see EOS_INVALID_NOTIFICATIONID
 * @see EOS_RTCAudio_RemoveNotifyAudioBeforeSend
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_RTCAudio_AddNotifyAudioBeforeSend(EOS_HRTCAudio Handle, EOS_RTCAudio_AddNotifyAudioBeforeSendOptions* Options, void* ClientData, const EOS_RTCAudio_OnAudioBeforeSendCallback CompletionDelegate);

/**
 * Unregister a previously bound notification handler from receiving local audio buffers before they are encoded and sent.
 *
 * @param NotificationId The Notification ID representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_RTCAudio_RemoveNotifyAudioBeforeSend(EOS_HRTCAudio Handle, EOS_NotificationId NotificationId);

/**
 * Register to receive notifications with remote audio buffers before they are rendered.
 *
 * This gives you access to the audio data received, allowing for example the implementation of custom filters/effects.
 *
 * If the returned NotificationId is valid, you must call EOS_RTCAudio_RemoveNotifyAudioBeforeRender when you no longer wish to
 * have your CompletionDelegate called.
 *
 * @param ClientData Arbitrary data that is passed back in the CompletionDelegate
 * @param CompletionDelegate The callback to be fired when a presence change occurs
 * @return Notification ID representing the registered callback if successful, an invalid NotificationId if not
 *
 * @see EOS_INVALID_NOTIFICATIONID
 * @see EOS_RTCAudio_RemoveNotifyAudioBeforeRender
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_RTCAudio_AddNotifyAudioBeforeRender(EOS_HRTCAudio Handle, EOS_RTCAudio_AddNotifyAudioBeforeRenderOptions* Options, void* ClientData, const EOS_RTCAudio_OnAudioBeforeRenderCallback CompletionDelegate);

/**
 * Unregister a previously bound notification handler from receiving remote audio buffers before they are rendered.
 *
 * @param NotificationId The Notification ID representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_RTCAudio_RemoveNotifyAudioBeforeRender(EOS_HRTCAudio Handle, EOS_NotificationId NotificationId);

```

`eac/sdk/Include/eos_rtc_audio_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

EXTERN_C typedef struct EOS_RTCAudioHandle* EOS_HRTCAudio;

/**
 * An enumeration of the different audio channel statuses.
 */
EOS_ENUM(EOS_ERTCAudioStatus,
	/** Audio unsupported by the source (no devices) */
	EOS_RTCAS_Unsupported = 0,
	/** Audio enabled */
	EOS_RTCAS_Enabled = 1,
	/** Audio disabled */
	EOS_RTCAS_Disabled = 2,
	/** Audio disabled by the administrator */
	EOS_RTCAS_AdminDisabled = 3,
	/** Audio channel is disabled temporarily for both sending and receiving */
	EOS_RTCAS_NotListeningDisabled = 4
);

/** The most recent version of the EOS_RTCAudio_RegisterPlatformAudioUser API. */
#define EOS_RTCAUDIO_REGISTERPLATFORMAUDIOUSER_API_LATEST 1

/**
 * This struct is used to inform the audio system of a user.
 */
EOS_STRUCT(EOS_RTCAudio_RegisterPlatformAudioUserOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_REGISTERPLATFORMAUDIOUSER_API_LATEST. */
	int32_t ApiVersion;
	/** Platform dependent user id. */
	const char* UserId;
));

/** The most recent version of the EOS_RTCAudio_UnregisterPlatformAudioUser API. */
#define EOS_RTCAUDIO_UNREGISTERPLATFORMAUDIOUSER_API_LATEST 1

/**
 * This struct is used to remove a user from the audio system.
 */
EOS_STRUCT(EOS_RTCAudio_UnregisterPlatformAudioUserOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_UNREGISTERPLATFORMAUDIOUSER_API_LATEST. */
	int32_t ApiVersion;
	/** The account of a user associated with this event. */
	const char* UserId;
));

/** The most recent version of the EOS_RTCAudio_AddNotifyParticipantUpdated API. */
#define EOS_RTCAUDIO_ADDNOTIFYPARTICIPANTUPDATED_API_LATEST 1

/**
 * This struct is used to call EOS_RTCAudio_AddNotifyParticipantUpdated.
 */
EOS_STRUCT(EOS_RTCAudio_AddNotifyParticipantUpdatedOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_ADDNOTIFYPARTICIPANTUPDATED_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user trying to request this operation. */
	EOS_ProductUserId LocalUserId;
	/** The  room this event is registered on. */
	const char* RoomName;
));

/**
 * This struct is passed in with a call to EOS_RTCAudio_AddNotifyParticipantUpdated registered event.
 */
EOS_STRUCT(EOS_RTCAudio_ParticipantUpdatedCallbackInfo, (
	/** Client-specified data passed into EOS_RTCAudio_AddNotifyParticipantUpdated. */
	void* ClientData;
	/** The Product User ID of the user who initiated this request. */
	EOS_ProductUserId LocalUserId;
	/** The room associated with this event. */
	const char* RoomName;
	/** The participant updated. */
	EOS_ProductUserId ParticipantId;
	/** The participant speaking / non-speaking status. */
	EOS_Bool bSpeaking;
	/** The participant audio status (enabled, disabled). */
	EOS_ERTCAudioStatus AudioStatus;
));

EOS_DECLARE_CALLBACK(EOS_RTCAudio_OnParticipantUpdatedCallback, const EOS_RTCAudio_ParticipantUpdatedCallbackInfo* Data);

/** The most recent version of the EOS_RTCAudio_AddNotifyAudioDevicesChanged API. */
#define EOS_RTCAUDIO_ADDNOTIFYAUDIODEVICESCHANGED_API_LATEST 1

/**
 * This struct is used to call EOS_RTCAudio_AddNotifyAudioDevicesChanged.
 */
EOS_STRUCT(EOS_RTCAudio_AddNotifyAudioDevicesChangedOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_ADDNOTIFYAUDIODEVICESCHANGED_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * This struct is passed in with a call to EOS_RTCAudio_AddNotifyAudioDevicesChanged registered event.
*/
EOS_STRUCT(EOS_RTCAudio_AudioDevicesChangedCallbackInfo, (
	/** Client-specified data passed into EOS_RTCAudio_AddNotifyAudioDevicesChanged. */
	void* ClientData;
));

EOS_DECLARE_CALLBACK(EOS_RTCAudio_OnAudioDevicesChangedCallback, const EOS_RTCAudio_AudioDevicesChangedCallbackInfo* Data);

/** The most recent version of the EOS_RTCAudio_GetAudioInputDevicesCount API. */
#define EOS_RTCAUDIO_GETAUDIOINPUTDEVICESCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_RTCAudio_GetAudioInputDevicesCount function.
 */
EOS_STRUCT(EOS_RTCAudio_GetAudioInputDevicesCountOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_GETAUDIOINPUTDEVICESCOUNT_API_LATEST. */
	int32_t ApiVersion;
));

/** The most recent version of the EOS_RTCAudio_GetAudioInputDeviceByIndex API. */
#define EOS_RTCAUDIO_GETAUDIOINPUTDEVICEBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_RTCAudio_GetAudioInputDeviceByIndex function.
 */
EOS_STRUCT(EOS_RTCAudio_GetAudioInputDeviceByIndexOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_GETAUDIOINPUTDEVICEBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** Index of the device info to retrieve. */
	uint32_t DeviceInfoIndex;
));

/** The most recent version of the EOS_RTCAudio_AudioInputDeviceInfo struct. */
#define EOS_RTCAUDIO_AUDIOINPUTDEVICEINFO_API_LATEST 1

/**
 * This struct is used to get information about a specific input device.
 */
EOS_STRUCT(EOS_RTCAudio_AudioInputDeviceInfo, (
	/** API Version: Set this to EOS_RTCAUDIO_AUDIOINPUTDEVICEINFO_API_LATEST. */
	int32_t ApiVersion;
	/** True if this is the default audio input device in the system. */
	EOS_Bool bDefaultDevice;
	/** 
	 *  The persistent unique id of the device.
	 */
	const char* DeviceId;
	/**
	 * The name of the device
	 */
	const char* DeviceName;
));

/** The most recent version of the EOS_RTCAudio_GetAudioOutputDevicesCount API. */
#define EOS_RTCAUDIO_GETAUDIOOUTPUTDEVICESCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_RTCAudio_GetAudioOutputDevicesCount function.
 */
EOS_STRUCT(EOS_RTCAudio_GetAudioOutputDevicesCountOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_GETAUDIOOUTPUTDEVICESCOUNT_API_LATEST. */
	int32_t ApiVersion;
));

/** The most recent version of the EOS_RTCAudio_GetAudioOutputDeviceByIndex API. */
#define EOS_RTCAUDIO_GETAUDIOOUTPUTDEVICEBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_RTCAudio_GetAudioOutputDeviceByIndex function.
 */
EOS_STRUCT(EOS_RTCAudio_GetAudioOutputDeviceByIndexOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_GETAUDIOOUTPUTDEVICEBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** Index of the device info to retrieve. */
	uint32_t DeviceInfoIndex;
));

/** The most recent version of the EOS_RTCAudio_AudioOutputDeviceInfo struct. */
#define EOS_RTCAUDIO_AUDIOOUTPUTDEVICEINFO_API_LATEST 1

/**
 * This struct is used to get information about a specific output device.
 */
EOS_STRUCT(EOS_RTCAudio_AudioOutputDeviceInfo, (
	/** API Version: Set this to EOS_RTCAUDIO_AUDIOOUTPUTDEVICEINFO_API_LATEST. */
	int32_t ApiVersion;
	/** True if this is the default audio output device in the system. */
	EOS_Bool bDefaultDevice;
	/** 
	 *  The persistent unique id of the device.
	 */
	const char* DeviceId;
	/**
	 * The name of the device
	 */
	const char* DeviceName;
));

/** The most recent version of the EOS_RTCAudio_SetAudioInputSettings API. */
#define EOS_RTCAUDIO_SETAUDIOINPUTSETTINGS_API_LATEST 1

/**
 * This struct is used to call EOS_RTCAudio_SetAudioInputSettings.
 */
EOS_STRUCT(EOS_RTCAudio_SetAudioInputSettingsOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_SETAUDIOINPUTSETTINGS_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user trying to request this operation. */
	EOS_ProductUserId LocalUserId;
	/** The device Id to be used for this user. Pass NULL or empty string to use default input device. */
	const char* DeviceId;
	/** The volume to be configured for this device (range 0.0 to 100.0).
	 * At the moment, the only value that produce any effect is 0.0 (silence). Any other value is ignored and causes no change to the volume.
	 */
	float Volume;
	/** Enable or disable Platform AEC (Acoustic Echo Cancellation) if available. */
	EOS_Bool bPlatformAEC;
));

/** The most recent version of the EOS_RTCAudio_SetAudioOutputSettings API. */
#define EOS_RTCAUDIO_SETAUDIOOUTPUTSETTINGS_API_LATEST 1

/**
 * This struct is used to call EOS_RTCAudio_SetAudioOutputSettings.
 */
EOS_STRUCT(EOS_RTCAudio_SetAudioOutputSettingsOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_SETAUDIOOUTPUTSETTINGS_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user who initiated this request. */
	EOS_ProductUserId LocalUserId;
	/** The device Id to be used for this user. Pass NULL or empty string to use default output device. */
	const char* DeviceId;
	/** The volume to be configured for this device (range 0.0 to 100.0). Volume 50 means that the audio volume is not modified
	 * and stays in its source value.
	 */
	float Volume;
));

/**
 * An enumeration of the different audio input device statuses.
 */
EOS_ENUM(EOS_ERTCAudioInputStatus,
	/** The device is not in used right now (e.g: you are alone in the room). In such cases, the hardware resources are not allocated. */
	EOS_RTCAIS_Idle = 0,
	/** The device is being used and capturing audio */
	EOS_RTCAIS_Recording = 1,
	/**
	 * The SDK is in a recording state, but actually capturing silence because the device is exclusively being used by the platform at the moment.
	 * This only applies to certain platforms.
	 */
	EOS_RTCAIS_RecordingSilent = 2,
	/**
	 * The SDK is in a recording state, but actually capturing silence because the device is disconnected (e.g: the microphone is not plugged in).
	 * This only applies to certain platforms.
	 */
	EOS_RTCAIS_RecordingDisconnected = 3,
	/** Something failed while trying to use the device */
	EOS_RTCAIS_Failed = 4
);

/** The most recent version of the EOS_RTCAudio_AddNotifyAudioInputState API. */
#define EOS_RTCAUDIO_ADDNOTIFYAUDIOINPUTSTATE_API_LATEST 1

/**
 * This struct is used to call EOS_RTCAudio_AddNotifyAudioInputState.
 */
EOS_STRUCT(EOS_RTCAudio_AddNotifyAudioInputStateOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_ADDNOTIFYAUDIOINPUTSTATE_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user trying to request this operation. */
	EOS_ProductUserId LocalUserId;
	/** The room this event is registered on. */
	const char* RoomName;
));

/**
 * This struct is passed in with a call to EOS_RTCAudio_AddNotifyAudioInputState registered event.
 */
EOS_STRUCT(EOS_RTCAudio_AudioInputStateCallbackInfo, (
	/** Client-specified data passed into EOS_RTCAudio_AddNotifyAudioInputState. */
	void* ClientData;
	/** The Product User ID of the user who initiated this request. */
	EOS_ProductUserId LocalUserId;
	/** The room associated with this event. */
	const char* RoomName;
	/** The status of the audio input. */
	EOS_ERTCAudioInputStatus Status;
));

EOS_DECLARE_CALLBACK(EOS_RTCAudio_OnAudioInputStateCallback, const EOS_RTCAudio_AudioInputStateCallbackInfo* Data);

/**
 * An enumeration of the different audio output device statuses.
 */
EOS_ENUM(EOS_ERTCAudioOutputStatus,
	/** The device is not in used right now (e.g: you are alone in the room). In such cases, the hardware resources are not allocated. */
	EOS_RTCAOS_Idle = 0,
	/** Device is in use */
	EOS_RTCAOS_Playing = 1,
	/** Something failed while trying to use the device */
	EOS_RTCAOS_Failed = 2
);

/** The most recent version of the EOS_RTCAudio_AddNotifyAudioOutputState API. */
#define EOS_RTCAUDIO_ADDNOTIFYAUDIOOUTPUTSTATE_API_LATEST 1

/**
 * This struct is used to call EOS_RTCAudio_AddNotifyAudioOutputState.
 */
EOS_STRUCT(EOS_RTCAudio_AddNotifyAudioOutputStateOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_ADDNOTIFYAUDIOOUTPUTSTATE_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user trying to request this operation. */
	EOS_ProductUserId LocalUserId;
	/** The  room this event is registered on. */
	const char* RoomName;
));

/**
 * This struct is passed in with a call to EOS_RTCAudio_AddNotifyAudioOutputState registered event.
 */
EOS_STRUCT(EOS_RTCAudio_AudioOutputStateCallbackInfo, (
	/** Client-specified data passed into EOS_RTCAudio_AddNotifyAudioOutputState. */
	void* ClientData;
	/** The Product User ID of the user who initiated this request. */
	EOS_ProductUserId LocalUserId;
	/** The room associated with this event. */
	const char* RoomName;
	/** The status of the audio output. */
	EOS_ERTCAudioOutputStatus Status;
));

EOS_DECLARE_CALLBACK(EOS_RTCAudio_OnAudioOutputStateCallback, const EOS_RTCAudio_AudioOutputStateCallbackInfo* Data);

/** The most recent version of the EOS_RTCAudio_AddNotifyAudioBeforeSend API. */
#define EOS_RTCAUDIO_ADDNOTIFYAUDIOBEFORESEND_API_LATEST 1

/**
 * This struct is used to call EOS_RTCAudio_AddNotifyAudioBeforeSend.
 */
EOS_STRUCT(EOS_RTCAudio_AddNotifyAudioBeforeSendOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_ADDNOTIFYAUDIOBEFORESEND_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user trying to request this operation. */
	EOS_ProductUserId LocalUserId;
	/** The  room this event is registered on. */
	const char* RoomName;
));


/** The most recent version of the EOS_RTCAudio_AudioBuffer API */
#define EOS_RTCAUDIO_AUDIOBUFFER_API_LATEST 1

/**
 * This struct is used to represent an audio buffer received in callbacks from EOS_RTCAudio_AddNotifyAudioBeforeSend and EOS_RTCAudio_AddNotifyAudioBeforeRender.
 */
EOS_STRUCT(EOS_RTCAudio_AudioBuffer, (
	/** API Version: Set this to EOS_RTCAUDIO_AUDIOBUFFER_API_LATEST. */
	int32_t ApiVersion;
	/** Pointer to the data with the interleaved audio frames in signed 16 bits format. */
	int16_t* Frames;
	/**
	 * Number of frames available in the Frames buffer.
	 * @note This is the number of frames in a channel, not the total number of frames in the buffer.
	 */
	uint32_t FramesCount;
	/** Sample rate for the samples in the Frames buffer. */
	uint32_t SampleRate;
	/** Number of channels for the samples in the Frames buffer. */
	uint32_t Channels;
));

/**
 * This struct is passed in with a call to EOS_RTCAudio_AddNotifyAudioBeforeSend registered event.
 */
EOS_STRUCT(EOS_RTCAudio_AudioBeforeSendCallbackInfo, (
	/** Client-specified data passed into EOS_RTCAudio_AddNotifyAudioBeforeSend. */
	void* ClientData;
	/** The Product User ID of the user who initiated this request. */
	EOS_ProductUserId LocalUserId;
	/** The room associated with this event. */
	const char* RoomName;
	/** Audio buffer. */
	EOS_RTCAudio_AudioBuffer* Buffer;
));

EOS_DECLARE_CALLBACK(EOS_RTCAudio_OnAudioBeforeSendCallback, const EOS_RTCAudio_AudioBeforeSendCallbackInfo* Data);

/** The most recent version of the EOS_RTCAudio_AddNotifyAudioBeforeRender API. */
#define EOS_RTCAUDIO_ADDNOTIFYAUDIOBEFORERENDER_API_LATEST 1

/**
* This struct is used to call EOS_RTCAudio_AddNotifyAudioBeforeRender.
*/
EOS_STRUCT(EOS_RTCAudio_AddNotifyAudioBeforeRenderOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_ADDNOTIFYAUDIOBEFORERENDER_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user trying to request this operation. */
	EOS_ProductUserId LocalUserId;
	/** The  room this event is registered on. */
	const char* RoomName;
	/**
	 * Mixed audio or unmixed audio.
	 */
	EOS_Bool bUnmixedAudio;
));


/**
 * This struct is passed in with a call to EOS_RTCAudio_AddNotifyAudioBeforeRender registered event.
 */
EOS_STRUCT(EOS_RTCAudio_AudioBeforeRenderCallbackInfo, (
	/** Client-specified data passed into EOS_RTCAudio_AddNotifyAudioBeforeRender. */
	void* ClientData;
	/** The Product User ID of the user who initiated this request. */
	EOS_ProductUserId LocalUserId;
	/** The room associated with this event. */
	const char* RoomName;
	/**
	 * Audio buffer.
	 */
	EOS_RTCAudio_AudioBuffer* Buffer;
	/**
	 * The Product User ID of the participant if bUnmixedAudio was set to true when setting the notifications, or empty if
	 * bUnmixedAudio was set to false and thus the buffer is the mixed audio of all participants
	 */
	EOS_ProductUserId ParticipantId;
));

EOS_DECLARE_CALLBACK(EOS_RTCAudio_OnAudioBeforeRenderCallback, const EOS_RTCAudio_AudioBeforeRenderCallbackInfo* Data);


/** The most recent version of the EOS_RTCAudio_SendAudio API. */
#define EOS_RTCAUDIO_SENDAUDIO_API_LATEST 1

/**
 * This struct is used to call EOS_RTCAudio_SendAudio.
 */
EOS_STRUCT(EOS_RTCAudio_SendAudioOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_SENDAUDIO_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user trying to request this operation. */
	EOS_ProductUserId LocalUserId;
	/** The  room this event is registered on. */
	const char* RoomName;
	/**
	 * Audio buffer, which must have a duration of 10 ms.
	 * @note The SDK makes a copy of buffer. There is no need to keep the buffer around after calling EOS_RTCAudio_SendAudio
	 */
	EOS_RTCAudio_AudioBuffer* Buffer;
));

/** The most recent version of the EOS_RTCAudio_UpdateSending API. */
#define EOS_RTCAUDIO_UPDATESENDING_API_LATEST 1

/**
 * This struct is passed in with a call to EOS_RTCAudio_UpdateSending
 */
EOS_STRUCT(EOS_RTCAudio_UpdateSendingOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_UPDATESENDING_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user trying to request this operation. */
	EOS_ProductUserId LocalUserId;
	/** The room this settings should be applied on. */
	const char* RoomName;
	/** Muted or unmuted audio track status */
	EOS_ERTCAudioStatus AudioStatus;
));

/**
 * This struct is passed in with a call to EOS_RTCAudio_OnUpdateSendingCallback.
 */
EOS_STRUCT(EOS_RTCAudio_UpdateSendingCallbackInfo, (
	/** This returns:
	 * EOS_Success if the channel was successfully blocked.
	 * EOS_UnexpectedError otherwise.
	 */
	EOS_EResult ResultCode;
	/** Client-specified data passed into EOS_RTCAudio_UpdateSending. */
	void* ClientData;
	/** The Product User ID of the user who initiated this request. */
	EOS_ProductUserId LocalUserId;
	/** The room this settings should be applied on. */
	const char* RoomName;
	/** Muted or unmuted audio track status */
	EOS_ERTCAudioStatus AudioStatus;
));

/**
 * Callback for completion of update sending request.
 */
EOS_DECLARE_CALLBACK(EOS_RTCAudio_OnUpdateSendingCallback, const EOS_RTCAudio_UpdateSendingCallbackInfo* Data);

/** The most recent version of the EOS_RTCAudio_UpdateReceiving API. */
#define EOS_RTCAUDIO_UPDATERECEIVING_API_LATEST 1

/**
 * This struct is passed in with a call to EOS_RTCAudio_UpdateReceiving.
 */
EOS_STRUCT(EOS_RTCAudio_UpdateReceivingOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_UPDATERECEIVING_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user trying to request this operation. */
	EOS_ProductUserId LocalUserId;
	/** The room this settings should be applied on. */
	const char* RoomName;
	/** The participant to modify or null to update the global configuration */
	EOS_ProductUserId ParticipantId;
	/** Mute or unmute audio track */
	EOS_Bool bAudioEnabled;
));

/**
 * This struct is passed in with a call to EOS_RTCAudio_OnUpdateReceivingCallback.
 */
EOS_STRUCT(EOS_RTCAudio_UpdateReceivingCallbackInfo, (
	/** This returns:
	 * EOS_Success if the users were successfully unblocked.
	 * EOS_UnexpectedError otherwise.
	 */
	EOS_EResult ResultCode;
	/** Client-specified data passed into EOS_RTCAudio_UpdateReceiving. */
	void* ClientData;
	/** The Product User ID of the user who initiated this request. */
	EOS_ProductUserId LocalUserId;
	/** The room this settings should be applied on. */
	const char* RoomName;
	/** The participant to modify or null to update the global configuration */
	EOS_ProductUserId ParticipantId;
	/** Muted or unmuted audio track */
	EOS_Bool bAudioEnabled;
));

/**
 * Callback for completion of update receiving request
 */
EOS_DECLARE_CALLBACK(EOS_RTCAudio_OnUpdateReceivingCallback, const EOS_RTCAudio_UpdateReceivingCallbackInfo* Data);

#pragma pack(pop)

```

`eac/sdk/Include/eos_rtc_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

EXTERN_C typedef struct EOS_RTCHandle* EOS_HRTC;

/** Participant RTC's status change */
EOS_ENUM(EOS_ERTCParticipantStatus,
	/** Participant joined the room */
	EOS_RTCPS_Joined = 0,
	/** Participant left the room */
	EOS_RTCPS_Left = 1
);

/** The most recent version of the EOS_RTC_JoinRoom API. */
#define EOS_RTC_JOINROOM_API_LATEST 1

/**
 * Enables echo mode.
 * This can be used during development to have the server send your voice back to you so you don't need 2 clients to test
 * if voice is being sent and received.
 *
 * @see EOS_RTC_JoinRoomOptions::Flags
 */
#define EOS_RTC_JOINROOMFLAGS_ENABLE_ECHO 0x01

/**
 * This struct is used to call EOS_RTC_JoinRoom.
 */
EOS_STRUCT(EOS_RTC_JoinRoomOptions, (
	/** API Version: Set this to EOS_RTC_JOINROOM_API_LATEST. */
	int32_t ApiVersion;
	/** The product user id of the user trying to request this operation. */
	EOS_ProductUserId LocalUserId;
	/** The room the user would like to join. */
	const char* RoomName;
	/** The room the user would like to join. */
	const char* ClientBaseUrl;
	/** Authorization credential token to join the room. */
	const char* ParticipantToken;
	/** The participant id used to join the room. If set to NULL the LocalUserId will be used instead. */
	EOS_ProductUserId ParticipantId;

	/** Join room flags, e.g. EOS_RTC_JOINROOMFLAGS_ENABLE_ECHO. This is a bitwise-or union of the defined flags. */
	uint32_t Flags;
	/** Enable or disable Manual Audio Input. If manual audio input is enabled audio recording is not started and the audio
	 * buffers must be passed manually using EOS_RTCAudio_SendAudio.
	 */
	EOS_Bool bManualAudioInputEnabled;
	/** Enable or disable Manual Audio Output. If manual audio output is enabled audio rendering is not started and the audio
	 * buffers must be received with EOS_RTCAudio_AddNotifyAudioBeforeRender and rendered manually.
	 */
	EOS_Bool bManualAudioOutputEnabled;
));

/**
 * This struct is passed in with a call to EOS_RTC_OnJoinRoomCallback.
 */
EOS_STRUCT(EOS_RTC_JoinRoomCallbackInfo, (
	/** This returns:
	 * EOS_Success if the channel was successfully joined.
	 * EOS_NoConnection: unable to connect to RTC servers (retryable).
	 * EOS_InvalidAuth: if the token is invalid (not retryable).
	 * EOS_RTC_TooManyParticipants: if the room cannot accept more participants (not retryable).
	 * EOS_AccessDenied: if the room name belongs to the Lobby voice system (not retryable).
	 * EOS_UnexpectedError otherwise (retryable).
	 */
	EOS_EResult ResultCode;
	/** Client-specified data passed into EOS_RTC_JoinRoom. */
	void* ClientData;
	/** The Product User ID of the user who initiated this request. */
	EOS_ProductUserId LocalUserId;
	/** The room the user was trying to join. */
	const char* RoomName;
));

/**
 * Callback for completion of room join request.
 */
EOS_DECLARE_CALLBACK(EOS_RTC_OnJoinRoomCallback, const EOS_RTC_JoinRoomCallbackInfo* Data);

/** The most recent version of the EOS_RTC_LeaveRoom API. */
#define EOS_RTC_LEAVEROOM_API_LATEST 1

/**
 * This struct is used to call EOS_RTC_LeaveRoom.
 */
EOS_STRUCT(EOS_RTC_LeaveRoomOptions, (
	/** API Version: Set this to EOS_RTC_LEAVEROOM_API_LATEST. */
	int32_t ApiVersion;
	/** Product User ID of the user requesting to leave the room */
	EOS_ProductUserId LocalUserId;
	/** The room to leave. */
	const char* RoomName;
));

/**
 * This struct is passed in with a call to EOS_RTC_OnLeaveRoomCallback.
 */
EOS_STRUCT(EOS_RTC_LeaveRoomCallbackInfo, (
	/** This returns:
	 * EOS_Success if the channel was successfully left.
	 * EOS_AccessDenied if the room name belongs to the Lobby voice system.
	 * EOS_UnexpectedError otherwise.
	 */
	EOS_EResult ResultCode;
	/** Client-specified data passed into EOS_RTC_LeaveRoomOptions. */
	void* ClientData;
	/** The Product User ID of the user who initiated this request. */
	EOS_ProductUserId LocalUserId;
	/** The room the user was trying to leave. */
	const char* RoomName;
));

/**
 * Callback for completion of room leave request.
 */
EOS_DECLARE_CALLBACK(EOS_RTC_OnLeaveRoomCallback, const EOS_RTC_LeaveRoomCallbackInfo* Data);

/** The most recent version of the EOS_RTC_BlockParticipant API. */
#define EOS_RTC_BLOCKPARTICIPANT_API_LATEST 1

/**
 * This struct is passed in with a call to EOS_RTC_BlockParticipant.
 */
EOS_STRUCT(EOS_RTC_BlockParticipantOptions, (
	/** API Version: Set this to EOS_RTC_BLOCKPARTICIPANT_API_LATEST. */
	int32_t ApiVersion;
	/** Product User ID of the user trying to request this operation. */
	EOS_ProductUserId LocalUserId;
	/** The room the users should be blocked on. */
	const char* RoomName;
	/** Product User ID of the participant to block */
	EOS_ProductUserId ParticipantId;
	/** Block or unblock the participant */
	EOS_Bool bBlocked;
));

/**
 * This struct is passed in with a call to EOS_RTC_OnBlockParticipantCallback.
 */
EOS_STRUCT(EOS_RTC_BlockParticipantCallbackInfo, (
	/** This returns:
	 * EOS_Success if the channel was successfully blocked.
	 * EOS_UnexpectedError otherwise.
	 */
	EOS_EResult ResultCode;
	/** Client-specified data passed into EOS_RTC_BlockParticipant. */
	void* ClientData;
	/** The Product User ID of the user who initiated this request. */
	EOS_ProductUserId LocalUserId;
	/** The room the users should be blocked on. */
	const char* RoomName;
	/** The Product User ID of the participant being blocked */
	EOS_ProductUserId ParticipantId;
	/** The block state that should have been set */
	EOS_Bool bBlocked;
));

/**
 * Callback for completion of block participants request.
 */
EOS_DECLARE_CALLBACK(EOS_RTC_OnBlockParticipantCallback, const EOS_RTC_BlockParticipantCallbackInfo* Data);

/** The most recent version of the EOS_RTC_AddNotifyDisconnected API. */
#define EOS_RTC_ADDNOTIFYDISCONNECTED_API_LATEST 1

/**
 * This struct is used to call EOS_RTC_AddNotifyDisconnected.
 */
EOS_STRUCT(EOS_RTC_AddNotifyDisconnectedOptions, (
	/** API Version: Set this to EOS_RTC_ADDNOTIFYDISCONNECTED_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user trying to request this operation. */
	EOS_ProductUserId LocalUserId;
	/** The room this event is registered on. */
	const char* RoomName;
));

/**
 * This struct is passed in with a call to EOS_RTC_AddNotifyDisconnected registered event.
*/
EOS_STRUCT(EOS_RTC_DisconnectedCallbackInfo, (
	/** This returns:
	 * EOS_Success The room was left cleanly.
	 * EOS_NoConnection: There was a network issue connecting to the server (retryable).
	 * EOS_RTC_UserKicked: The user has been kicked by the server (retryable).
	 * EOS_ServiceFailure: A known error occurred during interaction with the server (retryable).
	 * EOS_UnexpectedError Unexpected error (retryable).
	 */
	EOS_EResult ResultCode;
	/** Client-specified data passed into EOS_RTC_AddNotifyDisconnected. */
	void* ClientData;
	/** The Product User ID of the user who initiated this request. */
	EOS_ProductUserId LocalUserId;
	/** The room associated with this event. */
	const char* RoomName;
));

EOS_DECLARE_CALLBACK(EOS_RTC_OnDisconnectedCallback, const EOS_RTC_DisconnectedCallbackInfo* Data);

#define EOS_RTC_PARTICIPANTMETADATA_KEY_MAXCHARCOUNT 256
#define EOS_RTC_PARTICIPANTMETADATA_VALUE_MAXCHARCOUNT 256

/** The most recent version of the EOS_RTC_ParticipantMetadata struct. */
#define EOS_RTC_PARTICIPANTMETADATA_API_LATEST 1

/**
 * This struct is used to get information about a specific participant metadata item.
 */
EOS_STRUCT(EOS_RTC_ParticipantMetadata, (
	/** API Version: Set this to EOS_RTC_PARTICIPANTMETADATA_API_LATEST. */
	int32_t ApiVersion;
	/** The unique key of this metadata item. The max size of the string is EOS_RTC_PARTICIPANTMETADATA_KEY_MAXCHARCOUNT. */
	const char* Key;
	/** The value of this metadata item. The max size of the string is EOS_RTC_PARTICIPANTMETADATA_VALUE_MAXCHARCOUNT. */
	const char* Value;
));

/** The most recent version of the EOS_RTC_AddNotifyParticipantStatusChanged API. */
#define EOS_RTC_ADDNOTIFYPARTICIPANTSTATUSCHANGED_API_LATEST 1

/**
 * This struct is used to call EOS_RTC_AddNotifyParticipantStatusChanged.
 */
EOS_STRUCT(EOS_RTC_AddNotifyParticipantStatusChangedOptions, (
	/** API Version: Set this to EOS_RTC_ADDNOTIFYPARTICIPANTSTATUSCHANGED_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user trying to request this operation. */
	EOS_ProductUserId LocalUserId;
	/** The room this event is registered on. */
	const char* RoomName;
));

/**
 * This struct is passed in with a call to EOS_RTC_AddNotifyParticipantStatusChanged registered event.
 */
EOS_STRUCT(EOS_RTC_ParticipantStatusChangedCallbackInfo, (
	/** Client-specified data passed into EOS_RTC_AddNotifyParticipantStatusChanged. */
	void* ClientData;
	/** The Product User ID of the user who initiated this request. */
	EOS_ProductUserId LocalUserId;
	/** The room associated with this event. */
	const char* RoomName;
	/** The participant whose status changed. */
	EOS_ProductUserId ParticipantId;
	/** What status change occurred */
	EOS_ERTCParticipantStatus ParticipantStatus;
	/** The participant metadata items count.
	 * This is only set if ParticipantStatus is EOS_RTCPS_Joined
	 */
	uint32_t ParticipantMetadataCount;
	/** The participant metadata items.
	 * This is only set if ParticipantStatus is EOS_RTCPS_Joined
	 */
	const EOS_RTC_ParticipantMetadata* ParticipantMetadata;
));

EOS_DECLARE_CALLBACK(EOS_RTC_OnParticipantStatusChangedCallback, const EOS_RTC_ParticipantStatusChangedCallbackInfo* Data);



/**
* RTC SetSettings API
*/

/** The most recent version of the EOS_RTC_SetSetting API. */
#define EOS_RTC_SETSETTING_API_LATEST 1

/**
 * This struct is used to call EOS_RTC_SetSetting
 *
 * Available values of SettingName:
 * - DisableEchoCancelation: Disables the use of echo cancellation for the audio channel. Default "False".
 * - DisableNoiseSupression: Disables the use of noise suppression for the audio channel. Default "False".
 * - DisableAutoGainControl: Disables the use of auto gain control for the audio channel. Default "False".
 * - DisableDtx: Allows to disable the use of DTX.  Default "False".
 */
EOS_STRUCT(EOS_RTC_SetSettingOptions, (
	/** API Version: Set this to EOS_RTC_SETSETTING_API_LATEST. */
	int32_t ApiVersion;
	/** Setting that should be set. */
	const char* SettingName;
	/** Value to set the setting to. */
	const char* SettingValue;
));

/** The most recent version of the EOS_RTC_SetRoomSetting API. */
#define EOS_RTC_SETROOMSETTING_API_LATEST 1

/**
 * This struct is used to call EOS_RTC_SetRoomSetting
 *
 * Available values of SettingName:
 * - DisableEchoCancelation: Disables the use of echo cancellation for the audio channel. Default "False".
 * - DisableNoiseSupression: Disables the use of noise suppression for the audio channel. Default "False".
 * - DisableAutoGainControl: Disables the use of auto gain control for the audio channel. Default "False".
 * - DisableDtx: Allows to disable the use of DTX.  Default "False".
 */
EOS_STRUCT(EOS_RTC_SetRoomSettingOptions, (
	/** API Version: Set this to EOS_RTC_SETROOMSETTING_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user trying to request this operation. */
	EOS_ProductUserId LocalUserId;
	/** The room the setting will be applied to. */
	const char* RoomName;
	/** Setting that should be set. */
	const char* SettingName;
	/** Value to set the setting to. */
	const char* SettingValue;
));

#pragma pack(pop)

```

`eac/sdk/Include/eos_sanctions.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_sanctions_types.h"

/**
 * Start an asynchronous query to retrieve any active sanctions for a specified user.
 * Call EOS_Sanctions_GetPlayerSanctionCount and EOS_Sanctions_CopyPlayerSanctionByIndex to retrieve the data.
 *
 * @param Options Structure containing the input parameters
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the async operation completes, either successfully or in error
 *
 * @see EOS_Sanctions_GetPlayerSanctionCount
 * @see EOS_Sanctions_CopyPlayerSanctionByIndex
 */
EOS_DECLARE_FUNC(void) EOS_Sanctions_QueryActivePlayerSanctions(EOS_HSanctions Handle, const EOS_Sanctions_QueryActivePlayerSanctionsOptions* Options, void* ClientData, const EOS_Sanctions_OnQueryActivePlayerSanctionsCallback CompletionDelegate);

/**
 * Fetch the number of player sanctions that have been retrieved for a given player.
 * You must call QueryActivePlayerSanctions first to retrieve the data from the service backend.
 *
 * @param Options Structure containing the input parameters
 *
 * @see EOS_Sanctions_QueryActivePlayerSanctions
 * @see EOS_Sanctions_CopyPlayerSanctionByIndex
 *
 * @return Number of available sanctions for this player.
 */
EOS_DECLARE_FUNC(uint32_t) EOS_Sanctions_GetPlayerSanctionCount(EOS_HSanctions Handle, const EOS_Sanctions_GetPlayerSanctionCountOptions* Options);

/**
 * Copies an active player sanction.
 * You must call QueryActivePlayerSanctions first to retrieve the data from the service backend.
 * On success, EOS_Sanctions_PlayerSanction_Release must be called on OutSanction to free memory.
 *
 * @param Options Structure containing the input parameters
 * @param OutSanction The player sanction data for the given index, if it exists and is valid
 *
 * @see EOS_Sanctions_QueryActivePlayerSanctions
 * @see EOS_Sanctions_PlayerSanction_Release
 *
 * @return EOS_Success if the information is available and passed out in OutSanction
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the player achievement is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Sanctions_CopyPlayerSanctionByIndex(EOS_HSanctions Handle, const EOS_Sanctions_CopyPlayerSanctionByIndexOptions* Options, EOS_Sanctions_PlayerSanction ** OutSanction);

```

`eac/sdk/Include/eos_sanctions_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

EXTERN_C typedef struct EOS_SanctionsHandle* EOS_HSanctions;

/** The most recent version of the EOS_Sanctions_PlayerSanction struct. */
#define EOS_SANCTIONS_PLAYERSANCTION_API_LATEST 2

/**
 * Contains information about a single player sanction.
 */
EOS_STRUCT(EOS_Sanctions_PlayerSanction, (
	/** API Version: This will be set to EOS_SANCTIONS_PLAYERSANCTION_API_LATEST. */
	int32_t ApiVersion;
	/** The POSIX timestamp when the sanction was placed */
	int64_t TimePlaced;
	/** The action associated with this sanction */
	const char* Action;
	/** The POSIX timestamp when the sanction will expire. If the sanction is permanent, this will be 0. */
	int64_t TimeExpires;
	/** A unique identifier for this specific sanction */
	const char* ReferenceId;
));

/** The most recent version of the EOS_Sanctions_QueryActivePlayerSanctions API. */
#define EOS_SANCTIONS_QUERYACTIVEPLAYERSANCTIONS_API_LATEST 2

/**
 * Input parameters for the EOS_Sanctions_QueryActivePlayerSanctions API.
 */
EOS_STRUCT(EOS_Sanctions_QueryActivePlayerSanctionsOptions, (
	/** API Version: Set this to EOS_SANCTIONS_QUERYACTIVEPLAYERSANCTIONS_API_LATEST. */
	int32_t ApiVersion;
	/** Product User ID of the user whose active sanctions are to be retrieved. */
	EOS_ProductUserId TargetUserId;
	/** The Product User ID of the local user who initiated this request. Dedicated servers should set this to null. */
	EOS_ProductUserId LocalUserId;
));

/**
 * Output parameters for the EOS_Sanctions_QueryActivePlayerSanctions function.
 */
EOS_STRUCT(EOS_Sanctions_QueryActivePlayerSanctionsCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Sanctions_QueryActivePlayerSanctions. */
	void* ClientData;
	/** Target Product User ID that was passed to EOS_Sanctions_QueryActivePlayerSanctions. */
	EOS_ProductUserId TargetUserId;
	/** The Product User ID of the local user who initiated this request, if applicable. */
	EOS_ProductUserId LocalUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Sanctions_QueryActivePlayerSanctions
 * @param Data A EOS_Sanctions_QueryActivePlayerSanctionsCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Sanctions_OnQueryActivePlayerSanctionsCallback, const EOS_Sanctions_QueryActivePlayerSanctionsCallbackInfo* Data);

/** The most recent version of the EOS_Sanctions_GetPlayerSanctionCount API. */
#define EOS_SANCTIONS_GETPLAYERSANCTIONCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Sanctions_GetPlayerSanctionCount function.
 */
EOS_STRUCT(EOS_Sanctions_GetPlayerSanctionCountOptions, (
	/** API Version: Set this to EOS_SANCTIONS_GETPLAYERSANCTIONCOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** Product User ID of the user whose sanction count should be returned */
	EOS_ProductUserId TargetUserId;
));

/** The most recent version of the EOS_Sanctions_CopyPlayerSanctionByIndex API. */
#define EOS_SANCTIONS_COPYPLAYERSANCTIONBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_Sanctions_CopyPlayerSanctionByIndex function
 */
EOS_STRUCT(EOS_Sanctions_CopyPlayerSanctionByIndexOptions, (
	/** API Version: Set this to EOS_SANCTIONS_COPYPLAYERSANCTIONBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** Product User ID of the user whose active sanctions are to be copied */
	EOS_ProductUserId TargetUserId;
	/** Index of the sanction to retrieve from the cache */
	uint32_t SanctionIndex;
));

/**
 * Release the memory associated with a player sanction.
 * This must be called on data retrieved from EOS_Sanctions_CopyPlayerSanctionByIndex.
 *
 * @param Sanction - The sanction data to release.
 *
 * @see EOS_Sanctions_PlayerSanction
 * @see EOS_Sanctions_CopyPlayerSanctionByIndex
 */
EOS_DECLARE_FUNC(void) EOS_Sanctions_PlayerSanction_Release(EOS_Sanctions_PlayerSanction* Sanction);

#pragma pack(pop)

```

`eac/sdk/Include/eos_sdk.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_init.h"
#include "eos_metrics_types.h"
#include "eos_auth_types.h"
#include "eos_ecom_types.h"
#include "eos_ui_types.h"
#include "eos_friends_types.h"
#include "eos_presence_types.h"
#include "eos_p2p_types.h"
#include "eos_sessions_types.h"
#include "eos_lobby_types.h"
#include "eos_userinfo_types.h"
#include "eos_playerdatastorage_types.h"
#include "eos_titlestorage_types.h"
#include "eos_connect.h"
#include "eos_achievements_types.h"
#include "eos_stats_types.h"
#include "eos_leaderboards_types.h"
#include "eos_mods_types.h"
#include "eos_anticheatclient_types.h"
#include "eos_anticheatserver_types.h"
#include "eos_reports_types.h"
#include "eos_sanctions_types.h"
#include "eos_kws_types.h"
#include "eos_rtc_types.h"
#include "eos_rtc_admin_types.h"
#include "eos_progressionsnapshot_types.h"

/**
 * The Platform Instance is used to gain access to all other Epic Online Service interfaces and to drive internal operations through the Tick.
 * All Platform Instance calls take a handle of type EOS_HPlatform as the first parameter.
 * EOS_HPlatform handles are created by calling EOS_Platform_Create and subsequently released by calling EOS_Platform_Release.
 *
 * @see eos_init.h
 * @see EOS_Initialize
 * @see EOS_Platform_Create
 * @see EOS_Platform_Release
 * @see EOS_Shutdown
 */

/**
 * Notify the platform instance to do work. This function must be called frequently in order for the services provided by the SDK to properly
 * function. For tick-based applications, it is usually desireable to call this once per-tick.
 */
EOS_DECLARE_FUNC(void) EOS_Platform_Tick(EOS_HPlatform Handle);

/**
 * Get a handle to the Metrics Interface.
 * @return EOS_HMetrics handle
 *
 * @see eos_metrics.h
 * @see eos_metrics_types.h
 */
EOS_DECLARE_FUNC(EOS_HMetrics) EOS_Platform_GetMetricsInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the Auth Interface.
 * @return EOS_HAuth handle
 *
 * @see eos_auth.h
 * @see eos_auth_types.h
 */
EOS_DECLARE_FUNC(EOS_HAuth) EOS_Platform_GetAuthInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the Connect Interface.
 * @return EOS_HConnect handle
 *
 * @see eos_connect.h
 * @see eos_connect_types.h
 */
EOS_DECLARE_FUNC(EOS_HConnect) EOS_Platform_GetConnectInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the Ecom Interface.
 * @return EOS_HEcom handle
 *
 * @see eos_ecom.h
 * @see eos_ecom_types.h
 */
EOS_DECLARE_FUNC(EOS_HEcom) EOS_Platform_GetEcomInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the UI Interface.
 * @return EOS_HUI handle
 *
 * @see eos_ui.h
 * @see eos_ui_types.h
 */
EOS_DECLARE_FUNC(EOS_HUI) EOS_Platform_GetUIInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the Friends Interface.
 * @return EOS_HFriends handle
 *
 * @see eos_friends.h
 * @see eos_friends_types.h
 */
EOS_DECLARE_FUNC(EOS_HFriends) EOS_Platform_GetFriendsInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the Presence Interface.
 * @return EOS_HPresence handle
 *
 * @see eos_presence.h
 * @see eos_presence_types.h
 */
EOS_DECLARE_FUNC(EOS_HPresence) EOS_Platform_GetPresenceInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the Sessions Interface.
 * @return EOS_HSessions handle
 *
 * @see eos_sessions.h
 * @see eos_sessions_types.h
 */
EOS_DECLARE_FUNC(EOS_HSessions) EOS_Platform_GetSessionsInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the Lobby Interface.
 * @return EOS_HLobby handle
 *
 * @see eos_lobby.h
 * @see eos_lobby_types.h
 */
EOS_DECLARE_FUNC(EOS_HLobby) EOS_Platform_GetLobbyInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the UserInfo Interface.
 * @return EOS_HUserInfo handle
 *
 * @see eos_userinfo.h
 * @see eos_userinfo_types.h
 */
EOS_DECLARE_FUNC(EOS_HUserInfo) EOS_Platform_GetUserInfoInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the Peer-to-Peer Networking Interface.
 * @return EOS_HP2P handle
 *
 * @see eos_p2p.h
 * @see eos_p2p_types.h
 */
EOS_DECLARE_FUNC(EOS_HP2P) EOS_Platform_GetP2PInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the Real Time Communications Interface (RTC).
 * From the RTC interface you can retrieve the handle to the audio interface (RTCAudio), which is a component of RTC.
 * @return EOS_HRTC handle
 *
 * @see EOS_RTC_GetAudioInterface
 * @see eos_rtc.h
 * @see eos_rtc_types.h
 */
EOS_DECLARE_FUNC(EOS_HRTC) EOS_Platform_GetRTCInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the RTC Admin interface
 * @return EOS_HRTCAdmin handle
 *
 * @see eos_rtc_admin.h
 * @see eos_admin_types.h
 */
EOS_DECLARE_FUNC(EOS_HRTCAdmin) EOS_Platform_GetRTCAdminInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the PlayerDataStorage Interface.
 * @return EOS_HPlayerDataStorage handle
 *
 * @see eos_playerdatastorage.h
 * @see eos_playerdatastorage_types.h
 */
EOS_DECLARE_FUNC(EOS_HPlayerDataStorage) EOS_Platform_GetPlayerDataStorageInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the TitleStorage Interface.
 * @return EOS_HTitleStorage handle
 *
 * @see eos_titlestorage.h
 * @see eos_titlestorage_types.h
 */
EOS_DECLARE_FUNC(EOS_HTitleStorage) EOS_Platform_GetTitleStorageInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the Achievements Interface.
 * @return EOS_HAchievements handle
 *
 * @see eos_achievements.h
 * @see eos_achievements_types.h
 */
EOS_DECLARE_FUNC(EOS_HAchievements) EOS_Platform_GetAchievementsInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the Stats Interface.
 * @return EOS_HStats handle
 *
 * @see eos_stats.h
 * @see eos_stats_types.h
 */
EOS_DECLARE_FUNC(EOS_HStats) EOS_Platform_GetStatsInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the Leaderboards Interface.
 * @return EOS_HLeaderboards handle
 *
 * @see eos_leaderboards.h
 * @see eos_leaderboards_types.h
 */
EOS_DECLARE_FUNC(EOS_HLeaderboards) EOS_Platform_GetLeaderboardsInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the Mods Interface.
 * @return EOS_HMods handle
 *
 * @see eos_mods.h
 * @see eos_mods_types.h
 */
EOS_DECLARE_FUNC(EOS_HMods) EOS_Platform_GetModsInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the Anti-Cheat Client Interface.
 * @return EOS_HAntiCheatClient handle
 *
 * @see eos_anticheatclient.h
 * @see eos_anticheatclient_types.h
 */
EOS_DECLARE_FUNC(EOS_HAntiCheatClient) EOS_Platform_GetAntiCheatClientInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the Anti-Cheat Server Interface.
 * @return EOS_HAntiCheatServer handle
 *
 * @see eos_anticheatserver.h
 * @see eos_anticheatserver_types.h
 */
EOS_DECLARE_FUNC(EOS_HAntiCheatServer) EOS_Platform_GetAntiCheatServerInterface(EOS_HPlatform Handle);

/**
 * Get the active country code that the SDK will send to services which require it.
 * This returns the override value otherwise it will use the country code of the given user.
 * This is currently used for determining pricing.
 * Get a handle to the ProgressionSnapshot Interface.
 * @return EOS_HProgressionSnapshot handle
 *
 * @see eos_progressionsnapshot.h
 * @see eos_progressionsnapshot_types.h
 */
EOS_DECLARE_FUNC(EOS_HProgressionSnapshot) EOS_Platform_GetProgressionSnapshotInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the Reports Interface.
 * @return EOS_HReports handle
 *
 * @see eos_reports.h
 * @see eos_reports_types.h
 */
EOS_DECLARE_FUNC(EOS_HReports) EOS_Platform_GetReportsInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the Sanctions Interface.
 * @return EOS_HSanctions handle
 *
 * @see eos_sanctions.h
 * @see eos_sanctions_types.h
 */
EOS_DECLARE_FUNC(EOS_HSanctions) EOS_Platform_GetSanctionsInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the Kids Web Service Interface.
 * @return EOS_HKWS handle
 *
 * @see eos_kws.h
 * @see eos_kws_types.h
 */
EOS_DECLARE_FUNC(EOS_HKWS) EOS_Platform_GetKWSInterface(EOS_HPlatform Handle);

/**
 * This only will return the value set as the override otherwise EOS_NotFound is returned.
 * This is not currently used for anything internally.
 *
 * @param LocalUserId The account to use for lookup if no override exists.
 * @param OutBuffer The buffer into which the character data should be written.  The buffer must be long enough to hold a string of EOS_COUNTRYCODE_MAX_LENGTH.
 * @param InOutBufferLength The size of the OutBuffer in characters.
 *                          The input buffer should include enough space to be null-terminated.
 *                          When the function returns, this parameter will be filled with the length of the string copied into OutBuffer.
 *
 * @return An EOS_EResult that indicates whether the active country code string was copied into the OutBuffer.
 *         EOS_Success if the information is available and passed out in OutBuffer
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if there is not an override country code for the user.
 *         EOS_LimitExceeded - The OutBuffer is not large enough to receive the country code string. InOutBufferLength contains the required minimum length to perform the operation successfully.
 *
 * @see eos_ecom.h
 * @see EOS_COUNTRYCODE_MAX_LENGTH
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Platform_GetActiveCountryCode(EOS_HPlatform Handle, EOS_EpicAccountId LocalUserId, char* OutBuffer, int32_t* InOutBufferLength);

/**
 * Get the active locale code that the SDK will send to services which require it.
 * This returns the override value otherwise it will use the locale code of the given user.
 * This is used for localization. This follows ISO 639.
 *
 * @param LocalUserId The account to use for lookup if no override exists.
 * @param OutBuffer The buffer into which the character data should be written.  The buffer must be long enough to hold a string of EOS_LOCALECODE_MAX_LENGTH.
 * @param InOutBufferLength The size of the OutBuffer in characters.
 *                          The input buffer should include enough space to be null-terminated.
 *                          When the function returns, this parameter will be filled with the length of the string copied into OutBuffer.
 *
 * @return An EOS_EResult that indicates whether the active locale code string was copied into the OutBuffer.
 *         EOS_Success if the information is available and passed out in OutBuffer
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if there is neither an override nor an available locale code for the user.
 *         EOS_LimitExceeded - The OutBuffer is not large enough to receive the locale code string. InOutBufferLength contains the required minimum length to perform the operation successfully.
 *
 * @see eos_ecom.h
 * @see EOS_LOCALECODE_MAX_LENGTH
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Platform_GetActiveLocaleCode(EOS_HPlatform Handle, EOS_EpicAccountId LocalUserId, char* OutBuffer, int32_t* InOutBufferLength);

/**
 * Get the override country code that the SDK will send to services which require it.
 * This is not currently used for anything internally.
 *
 * @param OutBuffer The buffer into which the character data should be written.  The buffer must be long enough to hold a string of EOS_COUNTRYCODE_MAX_LENGTH.
 * @param InOutBufferLength The size of the OutBuffer in characters.
 *                          The input buffer should include enough space to be null-terminated.
 *                          When the function returns, this parameter will be filled with the length of the string copied into OutBuffer.
 *
 * @return An EOS_EResult that indicates whether the override country code string was copied into the OutBuffer.
 *         EOS_Success if the information is available and passed out in OutBuffer
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_LimitExceeded - The OutBuffer is not large enough to receive the country code string. InOutBufferLength contains the required minimum length to perform the operation successfully.
 *
 * @see eos_ecom.h
 * @see EOS_COUNTRYCODE_MAX_LENGTH
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Platform_GetOverrideCountryCode(EOS_HPlatform Handle, char* OutBuffer, int32_t* InOutBufferLength);

/**
 * Get the override locale code that the SDK will send to services which require it.
 * This is used for localization. This follows ISO 639.
 *
 * @param OutBuffer The buffer into which the character data should be written.  The buffer must be long enough to hold a string of EOS_LOCALECODE_MAX_LENGTH.
 * @param InOutBufferLength The size of the OutBuffer in characters.
 *                          The input buffer should include enough space to be null-terminated.
 *                          When the function returns, this parameter will be filled with the length of the string copied into OutBuffer.
 *
 * @return An EOS_EResult that indicates whether the override locale code string was copied into the OutBuffer.
 *         EOS_Success if the information is available and passed out in OutBuffer
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_LimitExceeded - The OutBuffer is not large enough to receive the locale code string. InOutBufferLength contains the required minimum length to perform the operation successfully.
 *
 * @see eos_ecom.h
 * @see EOS_LOCALECODE_MAX_LENGTH
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Platform_GetOverrideLocaleCode(EOS_HPlatform Handle, char* OutBuffer, int32_t* InOutBufferLength);

/**
 * Set the override country code that the SDK will send to services which require it.
 * This is not currently used for anything internally.
 *
 * @return An EOS_EResult that indicates whether the override country code string was saved.
 *         EOS_Success if the country code was overridden
 *         EOS_InvalidParameters if you pass an invalid country code
 *
 * @see eos_ecom.h
 * @see EOS_COUNTRYCODE_MAX_LENGTH
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Platform_SetOverrideCountryCode(EOS_HPlatform Handle, const char* NewCountryCode);

/**
 * Set the override locale code that the SDK will send to services which require it.
 * This is used for localization. This follows ISO 639.
 *
 * @return An EOS_EResult that indicates whether the override locale code string was saved.
 *         EOS_Success if the locale code was overridden
 *         EOS_InvalidParameters if you pass an invalid locale code
 *
 * @see eos_ecom.h
 * @see EOS_LOCALECODE_MAX_LENGTH
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Platform_SetOverrideLocaleCode(EOS_HPlatform Handle, const char* NewLocaleCode);

/**
 * Checks if the app was launched through the Epic Launcher, and relaunches it through the Epic Launcher if it wasn't.
 *
 * @return An EOS_EResult is returned to indicate success or an error.
 *
 * EOS_Success is returned if the app is being restarted. You should quit your process as soon as possible.
 * EOS_NoChange is returned if the app was already launched through the Epic Launcher, and no action needs to be taken.
 * EOS_UnexpectedError is returned if the LauncherCheck module failed to initialize, or the module tried and failed to restart the app.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Platform_CheckForLauncherAndRestart(EOS_HPlatform Handle);

```

`eac/sdk/Include/eos_sessions.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_sessions_types.h"

/**
 * The Session Interface is used to manage sessions that can be advertised with the backend service
 * All Session Interface calls take a handle of type EOS_HSessions as the first parameter.
 * This handle can be retrieved from an EOS_HPlatform handle by using the EOS_Platform_GetSessionsInterface function.
 *
 * @see EOS_Platform_GetSessionsInterface
 */

/**
 * Creates a session modification handle (EOS_HSessionModification).  The session modification handle is used to build a new session and can be applied with EOS_Sessions_UpdateSession
 * The EOS_HSessionModification must be released by calling EOS_SessionModification_Release once it no longer needed.
 *
 * @param Options Required fields for the creation of a session such as a name, bucketid, and max players
 * @param OutSessionModificationHandle Pointer to a Session Modification Handle only set if successful
 * @return EOS_Success if we successfully created the Session Modification Handle pointed at in OutSessionModificationHandle, or an error result if the input data was invalid
 *
 * @see EOS_SessionModification_Release
 * @see EOS_Sessions_UpdateSession
 * @see EOS_HSessionModification
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Sessions_CreateSessionModification(EOS_HSessions Handle, const EOS_Sessions_CreateSessionModificationOptions* Options, EOS_HSessionModification* OutSessionModificationHandle);

/**
 * Creates a session modification handle (EOS_HSessionModification). The session modification handle is used to modify an existing session and can be applied with EOS_Sessions_UpdateSession.
 * The EOS_HSessionModification must be released by calling EOS_SessionModification_Release once it is no longer needed.
 *
 * @param Options Required fields such as session name
 * @param OutSessionModificationHandle Pointer to a Session Modification Handle only set if successful
 * @return EOS_Success if we successfully created the Session Modification Handle pointed at in OutSessionModificationHandle, or an error result if the input data was invalid
 *
 * @see EOS_SessionModification_Release
 * @see EOS_Sessions_UpdateSession
 * @see EOS_HSessionModification
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Sessions_UpdateSessionModification(EOS_HSessions Handle, const EOS_Sessions_UpdateSessionModificationOptions* Options, EOS_HSessionModification* OutSessionModificationHandle);

/**
 * Update a session given a session modification handle created by EOS_Sessions_CreateSessionModification or EOS_Sessions_UpdateSessionModification
 *
 * @param Options Structure containing information about the session to be updated
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the update operation completes, either successfully or in error
 *
 * @return EOS_Success if the update completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_Sessions_OutOfSync if the session is out of sync and will be updated on the next connection with the backend
 *         EOS_NotFound if a session to be updated does not exist
 */
EOS_DECLARE_FUNC(void) EOS_Sessions_UpdateSession(EOS_HSessions Handle, const EOS_Sessions_UpdateSessionOptions* Options, void* ClientData, const EOS_Sessions_OnUpdateSessionCallback CompletionDelegate);

/**
 * Destroy a session given a session name
 *
 * @param Options Structure containing information about the session to be destroyed
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the destroy operation completes, either successfully or in error
 *
 * @return EOS_Success if the destroy completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_AlreadyPending if the session is already marked for destroy
 *         EOS_NotFound if a session to be destroyed does not exist
 */
EOS_DECLARE_FUNC(void) EOS_Sessions_DestroySession(EOS_HSessions Handle, const EOS_Sessions_DestroySessionOptions* Options, void* ClientData, const EOS_Sessions_OnDestroySessionCallback CompletionDelegate);

/**
 * Join a session, creating a local session under a given session name.  Backend will validate various conditions to make sure it is possible to join the session.
 *
 * @param Options Structure containing information about the session to be joined
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the join operation completes, either successfully or in error
 *
 * @return EOS_Success if the join completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_Sessions_SessionAlreadyExists if the session is already exists or is in the process of being joined
 */
EOS_DECLARE_FUNC(void) EOS_Sessions_JoinSession(EOS_HSessions Handle, const EOS_Sessions_JoinSessionOptions* Options, void* ClientData, const EOS_Sessions_OnJoinSessionCallback CompletionDelegate);

/**
 * Mark a session as started, making it unable to find if session properties indicate "join in progress" is not available
 *
 * @param Options Structure containing information about the session to be started
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the start operation completes, either successfully or in error
 *
 * @return EOS_Success if the start completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_Sessions_OutOfSync if the session is out of sync and will be updated on the next connection with the backend
 *         EOS_NotFound if a session to be started does not exist
 */
EOS_DECLARE_FUNC(void) EOS_Sessions_StartSession(EOS_HSessions Handle, const EOS_Sessions_StartSessionOptions* Options, void* ClientData, const EOS_Sessions_OnStartSessionCallback CompletionDelegate);

/**
 * Mark a session as ended, making it available to find if "join in progress" was disabled.  The session may be started again if desired
 *
 * @param Options Structure containing information about the session to be ended
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the end operation completes, either successfully or in error
 *
 * @return EOS_Success if the end completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_Sessions_OutOfSync if the session is out of sync and will be updated on the next connection with the backend
 *         EOS_NotFound if a session to be ended does not exist
 */
EOS_DECLARE_FUNC(void) EOS_Sessions_EndSession(EOS_HSessions Handle, const EOS_Sessions_EndSessionOptions* Options, void* ClientData, const EOS_Sessions_OnEndSessionCallback CompletionDelegate);

/**
 * Register a group of players with the session, allowing them to invite others or otherwise indicate they are part of the session for determining a full session
 *
 * @param Options Structure containing information about the session and players to be registered
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the registration operation completes, either successfully or in error
 *
 * @return EOS_Success if the register completes successfully
 *         EOS_NoChange if the players to register registered previously
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_Sessions_OutOfSync if the session is out of sync and will be updated on the next connection with the backend
 *         EOS_NotFound if a session to register players does not exist
 */
EOS_DECLARE_FUNC(void) EOS_Sessions_RegisterPlayers(EOS_HSessions Handle, const EOS_Sessions_RegisterPlayersOptions* Options, void* ClientData, const EOS_Sessions_OnRegisterPlayersCallback CompletionDelegate);

/**
 * Unregister a group of players with the session, freeing up space for others to join
 *
 * @param Options Structure containing information about the session and players to be unregistered
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the unregistration operation completes, either successfully or in error
 *
 * @return EOS_Success if the unregister completes successfully
 *         EOS_NoChange if the players to unregister were not found
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_Sessions_OutOfSync if the session is out of sync and will be updated on the next connection with the backend
 *         EOS_NotFound if a session to be unregister players does not exist
 */
EOS_DECLARE_FUNC(void) EOS_Sessions_UnregisterPlayers(EOS_HSessions Handle, const EOS_Sessions_UnregisterPlayersOptions* Options, void* ClientData, const EOS_Sessions_OnUnregisterPlayersCallback CompletionDelegate);

/**
 * Send an invite to another player.  User must have created the session or be registered in the session or else the call will fail
 *
 * @param Options Structure containing information about the session and player to invite
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the send invite operation completes, either successfully or in error
 *
 * @return EOS_Success if the send invite completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_NotFound if the session to send the invite from does not exist
 */
EOS_DECLARE_FUNC(void) EOS_Sessions_SendInvite(EOS_HSessions Handle, const EOS_Sessions_SendInviteOptions* Options, void* ClientData, const EOS_Sessions_OnSendInviteCallback CompletionDelegate);

/**
 * Reject an invite from another player.
 *
 * @param Options Structure containing information about the invite to reject
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the reject invite operation completes, either successfully or in error
 *
 * @return EOS_Success if the invite rejection completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_NotFound if the invite does not exist
 */
EOS_DECLARE_FUNC(void) EOS_Sessions_RejectInvite(EOS_HSessions Handle, const EOS_Sessions_RejectInviteOptions* Options, void* ClientData, const EOS_Sessions_OnRejectInviteCallback CompletionDelegate);

/**
 * Retrieve all existing invites for a single user
 *
 * @param Options Structure containing information about the invites to query
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the query invites operation completes, either successfully or in error
 *
 */
EOS_DECLARE_FUNC(void) EOS_Sessions_QueryInvites(EOS_HSessions Handle, const EOS_Sessions_QueryInvitesOptions* Options, void* ClientData, const EOS_Sessions_OnQueryInvitesCallback CompletionDelegate);

/**
 * Get the number of known invites for a given user
 *
 * @param Options the Options associated with retrieving the current invite count
 *
 * @return number of known invites for a given user or 0 if there is an error
 */
EOS_DECLARE_FUNC(uint32_t) EOS_Sessions_GetInviteCount(EOS_HSessions Handle, const EOS_Sessions_GetInviteCountOptions* Options);

/**
 * Retrieve an invite ID from a list of active invites for a given user
 *
 * @param Options Structure containing the input parameters
 *
 * @return EOS_Success if the input is valid and an invite ID was returned
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_NotFound if the invite doesn't exist
 *
 * @see EOS_Sessions_GetInviteCount
 * @see EOS_Sessions_CopySessionHandleByInviteId
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Sessions_GetInviteIdByIndex(EOS_HSessions Handle, const EOS_Sessions_GetInviteIdByIndexOptions* Options, char* OutBuffer, int32_t* InOutBufferLength);

/**
 * Create a session search handle.  This handle may be modified to include various search parameters.
 * Searching is possible in three methods, all mutually exclusive
 * - set the session ID to find a specific session
 * - set the target user ID to find a specific user
 * - set session parameters to find an array of sessions that match the search criteria
 *
 * @param Options Structure containing required parameters such as the maximum number of search results
 * @param OutSessionSearchHandle The new search handle or null if there was an error creating the search handle
 *
 * @return EOS_Success if the search creation completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Sessions_CreateSessionSearch(EOS_HSessions Handle, const EOS_Sessions_CreateSessionSearchOptions* Options, EOS_HSessionSearch* OutSessionSearchHandle);

/**
 * Create a handle to an existing active session.
 *
 * @param Options Structure containing information about the active session to retrieve
 * @param OutSessionHandle The new active session handle or null if there was an error
 *
 * @return EOS_Success if the session handle was created successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *         EOS_NotFound if the active session doesn't exist
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Sessions_CopyActiveSessionHandle(EOS_HSessions Handle, const EOS_Sessions_CopyActiveSessionHandleOptions* Options, EOS_HActiveSession* OutSessionHandle);

/**
 * Register to receive session invites.
 * @note must call RemoveNotifySessionInviteReceived to remove the notification
 *
 * @param Options Structure containing information about the session invite notification
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param NotificationFn A callback that is fired when a session invite for a user has been received
 *
 * @return handle representing the registered callback
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_Sessions_AddNotifySessionInviteReceived(EOS_HSessions Handle, const EOS_Sessions_AddNotifySessionInviteReceivedOptions* Options, void* ClientData, const EOS_Sessions_OnSessionInviteReceivedCallback NotificationFn);

/**
 * Unregister from receiving session invites.
 *
 * @param InId Handle representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_Sessions_RemoveNotifySessionInviteReceived(EOS_HSessions Handle, EOS_NotificationId InId);

/**
 * Register to receive notifications when a user accepts a session invite via the social overlay.
 * @note must call RemoveNotifySessionInviteAccepted to remove the notification
 *
 * @param Options Structure containing information about the request.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param NotificationFn A callback that is fired when a a notification is received.
 *
 * @return handle representing the registered callback
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_Sessions_AddNotifySessionInviteAccepted(EOS_HSessions Handle, const EOS_Sessions_AddNotifySessionInviteAcceptedOptions* Options, void* ClientData, const EOS_Sessions_OnSessionInviteAcceptedCallback NotificationFn);

/**
 * Unregister from receiving notifications when a user accepts a session invite via the social overlay.
 *
 * @param InId Handle representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_Sessions_RemoveNotifySessionInviteAccepted(EOS_HSessions Handle, EOS_NotificationId InId);

/**
 * Register to receive notifications when a user accepts a session join game via the social overlay.
 * @note must call RemoveNotifyJoinSessionAccepted to remove the notification
 *
 * @param Options Structure containing information about the request.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param NotificationFn A callback that is fired when a a notification is received.
 *
 * @return handle representing the registered callback
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_Sessions_AddNotifyJoinSessionAccepted(EOS_HSessions Handle, const EOS_Sessions_AddNotifyJoinSessionAcceptedOptions* Options, void* ClientData, const EOS_Sessions_OnJoinSessionAcceptedCallback NotificationFn);

/**
 * Unregister from receiving notifications when a user accepts a session join game via the social overlay.
 *
 * @param InId Handle representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_Sessions_RemoveNotifyJoinSessionAccepted(EOS_HSessions Handle, EOS_NotificationId InId);

/**
 * EOS_Sessions_CopySessionHandleByInviteId is used to immediately retrieve a handle to the session information from after notification of an invite
 * If the call returns an EOS_Success result, the out parameter, OutSessionHandle, must be passed to EOS_SessionDetails_Release to release the memory associated with it.
 *
 * @param Options Structure containing the input parameters
 * @param OutSessionHandle out parameter used to receive the session handle
 *
 * @return EOS_Success if the information is available and passed out in OutSessionHandle
 *         EOS_InvalidParameters if you pass an invalid invite ID or a null pointer for the out parameter
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *         EOS_NotFound if the invite ID cannot be found
 *
 * @see EOS_Sessions_CopySessionHandleByInviteIdOptions
 * @see EOS_SessionDetails_Release
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Sessions_CopySessionHandleByInviteId(EOS_HSessions Handle, const EOS_Sessions_CopySessionHandleByInviteIdOptions* Options, EOS_HSessionDetails* OutSessionHandle);

/**
 * EOS_Sessions_CopySessionHandleByUiEventId is used to immediately retrieve a handle to the session information from after notification of a join game event.
 * If the call returns an EOS_Success result, the out parameter, OutSessionHandle, must be passed to EOS_SessionDetails_Release to release the memory associated with it.
 *
 * @param Options Structure containing the input parameters
 * @param OutSessionHandle out parameter used to receive the session handle
 *
 * @return EOS_Success if the information is available and passed out in OutSessionHandle
 *         EOS_InvalidParameters if you pass an invalid invite ID or a null pointer for the out parameter
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *         EOS_NotFound if the invite ID cannot be found
 *
 * @see EOS_Sessions_CopySessionHandleByUiEventIdOptions
 * @see EOS_SessionDetails_Release
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Sessions_CopySessionHandleByUiEventId(EOS_HSessions Handle, const EOS_Sessions_CopySessionHandleByUiEventIdOptions* Options, EOS_HSessionDetails* OutSessionHandle);

/**
 * EOS_Sessions_CopySessionHandleForPresence is used to immediately retrieve a handle to the session information which was marked with bPresenceEnabled on create or join.
 * If the call returns an EOS_Success result, the out parameter, OutSessionHandle, must be passed to EOS_SessionDetails_Release to release the memory associated with it.
 *
 * @param Options Structure containing the input parameters
 * @param OutSessionHandle out parameter used to receive the session handle
 *
 * @return EOS_Success if the information is available and passed out in OutSessionHandle
 *         EOS_InvalidParameters if you pass an invalid invite ID or a null pointer for the out parameter
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *         EOS_NotFound if there is no session with bPresenceEnabled
 *
 * @see EOS_Sessions_CopySessionHandleForPresenceOptions
 * @see EOS_SessionDetails_Release
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Sessions_CopySessionHandleForPresence(EOS_HSessions Handle, const EOS_Sessions_CopySessionHandleForPresenceOptions* Options, EOS_HSessionDetails* OutSessionHandle);

/**
 * EOS_Sessions_IsUserInSession returns whether or not a given user can be found in a specified session
 *
 * @param Options Structure containing the input parameters
 *
 * @return EOS_Success if the user is found in the specified session
 *		   EOS_NotFound if the user is not found in the specified session
 *		   EOS_InvalidParameters if you pass an invalid invite ID or a null pointer for the out parameter
 *		   EOS_IncompatibleVersion if the API version passed in is incorrect
 *		   EOS_Invalid_ProductUserID if an invalid target user is specified
 *		   EOS_Sessions_InvalidSession if the session specified is invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Sessions_IsUserInSession(EOS_HSessions Handle, const EOS_Sessions_IsUserInSessionOptions* Options);

/**
 * Dump the contents of active sessions that exist locally to the log output, purely for debug purposes
 *
 * @param Options Options related to dumping session state such as the session name
 *
 * @return EOS_Success if the output operation completes successfully
 *         EOS_NotFound if the session specified does not exist
 *         EOS_InvalidParameters if any of the options are incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Sessions_DumpSessionState(EOS_HSessions Handle, const EOS_Sessions_DumpSessionStateOptions* Options);

/**
 * To modify sessions, you must call EOS_Sessions_CreateSessionModification to create a Session Modification handle. To modify that handle, call
 * EOS_HSessionModification methods. Once you are finished, call EOS_Sessions_UpdateSession with your handle. You must then release your Session Modification
 * handle by calling EOS_SessionModification_Release.
 */

/**
 * Set the bucket ID associated with this session.
 * Values such as region, game mode, etc can be combined here depending on game need.
 * Setting this is strongly recommended to improve search performance.
 *
 * @param Options Options associated with the bucket ID of the session
 *
 * @return EOS_Success if setting this parameter was successful
 *         EOS_InvalidParameters if the bucket ID is invalid or null
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_SessionModification_SetBucketId(EOS_HSessionModification Handle, const EOS_SessionModification_SetBucketIdOptions* Options);

/**
 * Set the host address associated with this session
 * Setting this is optional, if the value is not set the SDK will fill the value in from the service.
 * It is useful to set if other addressing mechanisms are desired or if LAN addresses are preferred during development
 *
 * @note No validation of this value occurs to allow for flexibility in addressing methods
 *
 * @param Options Options associated with the host address of the session
 *
 * @return EOS_Success if setting this parameter was successful
 *         EOS_InvalidParameters if the host ID is an empty string
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_SessionModification_SetHostAddress(EOS_HSessionModification Handle, const EOS_SessionModification_SetHostAddressOptions* Options);

/**
 * Set the session permissions associated with this session.
 * The permissions range from "public" to "invite only" and are described by EOS_EOnlineSessionPermissionLevel
 *
 * @param Options Options associated with the permission level of the session
 *
 * @return EOS_Success if setting this parameter was successful
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_SessionModification_SetPermissionLevel(EOS_HSessionModification Handle, const EOS_SessionModification_SetPermissionLevelOptions* Options);

/**
 * Set whether or not join in progress is allowed
 * Once a session is started, it will no longer be visible to search queries unless this flag is set or the session returns to the pending or ended state
 *
 * @param Options Options associated with setting the join in progress state the session
 *
 * @return EOS_Success if setting this parameter was successful
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_SessionModification_SetJoinInProgressAllowed(EOS_HSessionModification Handle, const EOS_SessionModification_SetJoinInProgressAllowedOptions* Options);

/**
 * Set the maximum number of players allowed in this session.
 * When updating the session, it is not possible to reduce this number below the current number of existing players
 *
 * @param Options Options associated with max number of players in this session
 *
 * @return EOS_Success if setting this parameter was successful
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_SessionModification_SetMaxPlayers(EOS_HSessionModification Handle, const EOS_SessionModification_SetMaxPlayersOptions* Options);

/**
 * Allows enabling or disabling invites for this session.
 * The session will also need to have `bPresenceEnabled` true.
 *
 * @param Options Options associated with invites allowed flag for this session.
 *
 * @return EOS_Success if setting this parameter was successful
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_SessionModification_SetInvitesAllowed(EOS_HSessionModification Handle, const EOS_SessionModification_SetInvitesAllowedOptions* Options);

/**
 * Associate an attribute with this session
 * An attribute is something that may or may not be advertised with the session.
 * If advertised, it can be queried for in a search, otherwise the data remains local to the client
 *
 * @param Options Options to set the attribute and its advertised state
 *
 * @return EOS_Success if setting this parameter was successful
 *		   EOS_InvalidParameters if the attribution is missing information or otherwise invalid
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_SessionModification_AddAttribute(EOS_HSessionModification Handle, const EOS_SessionModification_AddAttributeOptions* Options);

/**
 * Remove an attribute from this session
 *
 * @param Options Specify the key of the attribute to remove
 *
 * @return EOS_Success if removing this parameter was successful
 *		   EOS_InvalidParameters if the key is null or empty
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_SessionModification_RemoveAttribute(EOS_HSessionModification Handle, const EOS_SessionModification_RemoveAttributeOptions* Options);

/**
 * Representation of an existing session some local players are actively involved in (via Create/Join)
 */

/**
 * EOS_ActiveSession_CopyInfo is used to immediately retrieve a copy of active session information
 * If the call returns an EOS_Success result, the out parameter, OutActiveSessionInfo, must be passed to EOS_ActiveSession_Info_Release to release the memory associated with it.
 *
 * @param Options Structure containing the input parameters
 * @param OutActiveSessionInfo Out parameter used to receive the EOS_ActiveSession_Info structure.
 *
 * @return EOS_Success if the information is available and passed out in OutActiveSessionInfo
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *
 * @see EOS_ActiveSession_Info
 * @see EOS_ActiveSession_CopyInfoOptions
 * @see EOS_ActiveSession_Info_Release
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_ActiveSession_CopyInfo(EOS_HActiveSession Handle, const EOS_ActiveSession_CopyInfoOptions* Options, EOS_ActiveSession_Info ** OutActiveSessionInfo);

/**
 * Get the number of registered players associated with this active session
 *
 * @param Options the Options associated with retrieving the registered player count
 *
 * @return number of registered players in the active session or 0 if there is an error
 */
EOS_DECLARE_FUNC(uint32_t) EOS_ActiveSession_GetRegisteredPlayerCount(EOS_HActiveSession Handle, const EOS_ActiveSession_GetRegisteredPlayerCountOptions* Options);

/**
 * EOS_ActiveSession_GetRegisteredPlayerByIndex is used to immediately retrieve individual players registered with the active session.
 *
 * @param Options Structure containing the input parameters
 *
 * @return the product user ID for the registered player at a given index or null if that index is invalid
 *
 * @see EOS_ActiveSession_GetRegisteredPlayerCount
 * @see EOS_ActiveSession_GetRegisteredPlayerByIndexOptions
 */
EOS_DECLARE_FUNC(EOS_ProductUserId) EOS_ActiveSession_GetRegisteredPlayerByIndex(EOS_HActiveSession Handle, const EOS_ActiveSession_GetRegisteredPlayerByIndexOptions* Options);

/**
 * This class represents the details of a session, including its session properties and the attribution associated with it
 * Locally created or joined active sessions will contain this information as will search results.   
 * A handle to a session is required to join a session via search or invite
 */

/**
 * EOS_SessionDetails_CopyInfo is used to immediately retrieve a copy of session information from a given source such as a active session or a search result.
 * If the call returns an EOS_Success result, the out parameter, OutSessionInfo, must be passed to EOS_SessionDetails_Info_Release to release the memory associated with it.
 *
 * @param Options Structure containing the input parameters
 * @param OutSessionInfo Out parameter used to receive the EOS_SessionDetails_Info structure.
 *
 * @return EOS_Success if the information is available and passed out in OutSessionInfo
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *
 * @see EOS_SessionDetails_Info
 * @see EOS_SessionDetails_CopyInfoOptions
 * @see EOS_SessionDetails_Info_Release
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_SessionDetails_CopyInfo(EOS_HSessionDetails Handle, const EOS_SessionDetails_CopyInfoOptions* Options, EOS_SessionDetails_Info ** OutSessionInfo);

/**
 * Get the number of attributes associated with this session
 *
 * @param Options the Options associated with retrieving the attribute count
 *
 * @return number of attributes on the session or 0 if there is an error
 */
EOS_DECLARE_FUNC(uint32_t) EOS_SessionDetails_GetSessionAttributeCount(EOS_HSessionDetails Handle, const EOS_SessionDetails_GetSessionAttributeCountOptions* Options);

/**
 * EOS_SessionDetails_CopySessionAttributeByIndex is used to immediately retrieve a copy of session attribution from a given source such as a active session or a search result.
 * If the call returns an EOS_Success result, the out parameter, OutSessionAttribute, must be passed to EOS_SessionDetails_Attribute_Release to release the memory associated with it.
 *
 * @param Options Structure containing the input parameters
 * @param OutSessionAttribute Out parameter used to receive the EOS_SessionDetails_Attribute structure.
 *
 * @return EOS_Success if the information is available and passed out in OutSessionAttribute
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *
 * @see EOS_SessionDetails_Attribute
 * @see EOS_SessionDetails_CopySessionAttributeByIndexOptions
 * @see EOS_SessionDetails_Attribute_Release
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_SessionDetails_CopySessionAttributeByIndex(EOS_HSessionDetails Handle, const EOS_SessionDetails_CopySessionAttributeByIndexOptions* Options, EOS_SessionDetails_Attribute ** OutSessionAttribute);

/**
 * EOS_SessionDetails_CopySessionAttributeByKey is used to immediately retrieve a copy of session attribution from a given source such as a active session or a search result.
 * If the call returns an EOS_Success result, the out parameter, OutSessionAttribute, must be passed to EOS_SessionDetails_Attribute_Release to release the memory associated with it.
 *
 * @param Options Structure containing the input parameters
 * @param OutSessionAttribute Out parameter used to receive the EOS_SessionDetails_Attribute structure.
 *
 * @return EOS_Success if the information is available and passed out in OutSessionAttribute
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *
 * @see EOS_SessionDetails_Attribute
 * @see EOS_SessionDetails_CopySessionAttributeByKeyOptions
 * @see EOS_SessionDetails_Attribute_Release
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_SessionDetails_CopySessionAttributeByKey(EOS_HSessionDetails Handle, const EOS_SessionDetails_CopySessionAttributeByKeyOptions* Options, EOS_SessionDetails_Attribute ** OutSessionAttribute);

/**
 * Class responsible for the creation, setup, and execution of a search query.
 * Search parameters are defined, the query is executed and the search results are returned within this object
 */

/**
 * Set a session ID to find and will return at most one search result.  Setting TargetUserId or SearchParameters will result in EOS_SessionSearch_Find failing
 *
 * @param Options A specific session ID for which to search
 *
 * @return EOS_Success if setting this session ID was successful
 *         EOS_InvalidParameters if the session ID is invalid or null
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_SessionSearch_SetSessionId(EOS_HSessionSearch Handle, const EOS_SessionSearch_SetSessionIdOptions* Options);

/**
 * Set a target user ID to find and will return at most one search result.  Setting SessionId or SearchParameters will result in EOS_SessionSearch_Find failing
 * @note a search result will only be found if this user is in a public session
 *
 * @param Options a specific target user ID to find
 *
 * @return EOS_Success if setting this target user ID was successful
 *         EOS_InvalidParameters if the target user ID is invalid or null
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_SessionSearch_SetTargetUserId(EOS_HSessionSearch Handle, const EOS_SessionSearch_SetTargetUserIdOptions* Options);

/**
 * Add a parameter to an array of search criteria combined via an implicit AND operator.  Setting SessionId or TargetUserId will result in EOS_SessionSearch_Find failing
 *
 * @param Options a search parameter and its comparison op
 *
 * @return EOS_Success if setting this search parameter was successful
 *         EOS_InvalidParameters if the search criteria is invalid or null
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *
 * @see EOS_Sessions_AttributeData
 * @see EOS_EComparisonOp
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_SessionSearch_SetParameter(EOS_HSessionSearch Handle, const EOS_SessionSearch_SetParameterOptions* Options);

/**
 * Remove a parameter from the array of search criteria.
 *
 * @params Options a search parameter key name to remove
 *
 * @return EOS_Success if removing this search parameter was successful
 *         EOS_InvalidParameters if the search key is invalid or null
 *		   EOS_NotFound if the parameter was not a part of the search criteria
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_SessionSearch_RemoveParameter(EOS_HSessionSearch Handle, const EOS_SessionSearch_RemoveParameterOptions* Options);

/**
 * Set the maximum number of search results to return in the query, can't be more than EOS_SESSIONS_MAX_SEARCH_RESULTS
 *
 * @param Options maximum number of search results to return in the query
 *
 * @return EOS_Success if setting the max results was successful
 *         EOS_InvalidParameters if the number of results requested is invalid
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_SessionSearch_SetMaxResults(EOS_HSessionSearch Handle, const EOS_SessionSearch_SetMaxResultsOptions* Options);

/**
 * Find sessions matching the search criteria setup via this session search handle.
 * When the operation completes, this handle will have the search results that can be parsed
 *
 * @param Options Structure containing information about the search criteria to use
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the search operation completes, either successfully or in error
 *
 * @return EOS_Success if the find operation completes successfully
 *         EOS_NotFound if searching for an individual session by sessionid or targetuserid returns no results
 *         EOS_InvalidParameters if any of the options are incorrect
 */
EOS_DECLARE_FUNC(void) EOS_SessionSearch_Find(EOS_HSessionSearch Handle, const EOS_SessionSearch_FindOptions* Options, void* ClientData, const EOS_SessionSearch_OnFindCallback CompletionDelegate);

/**
 * Get the number of search results found by the search parameters in this search
 *
 * @param Options Options associated with the search count
 *
 * @return return the number of search results found by the query or 0 if search is not complete
 */
EOS_DECLARE_FUNC(uint32_t) EOS_SessionSearch_GetSearchResultCount(EOS_HSessionSearch Handle, const EOS_SessionSearch_GetSearchResultCountOptions* Options);

/**
 * EOS_SessionSearch_CopySearchResultByIndex is used to immediately retrieve a handle to the session information from a given search result.
 * If the call returns an EOS_Success result, the out parameter, OutSessionHandle, must be passed to EOS_SessionDetails_Release to release the memory associated with it.
 *
 * @param Options Structure containing the input parameters
 * @param OutSessionHandle out parameter used to receive the session handle
 *
 * @return EOS_Success if the information is available and passed out in OutSessionHandle
 *         EOS_InvalidParameters if you pass an invalid index or a null pointer for the out parameter
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *
 * @see EOS_SessionSearch_CopySearchResultByIndexOptions
 * @see EOS_SessionDetails_Release
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_SessionSearch_CopySearchResultByIndex(EOS_HSessionSearch Handle, const EOS_SessionSearch_CopySearchResultByIndexOptions* Options, EOS_HSessionDetails* OutSessionHandle);

```

`eac/sdk/Include/eos_sessions_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"
#include "eos_ui_types.h"

#pragma pack(push, 8)

/** Handle to the sessions interface */
EXTERN_C typedef struct EOS_SessionsHandle* EOS_HSessions;
/** Handle to the calls responsible for creating/updating sessions */
EXTERN_C typedef struct EOS_SessionModificationHandle* EOS_HSessionModification;
/** Handle to a single named session that exists locally */
EXTERN_C typedef struct EOS_ActiveSessionHandle* EOS_HActiveSession;
/** Handle to a single session that may be part of a named session, search result, or invite */
EXTERN_C typedef struct EOS_SessionDetailsHandle* EOS_HSessionDetails;
/** Handle to the calls responsible for creating a search object */
EXTERN_C typedef struct EOS_SessionSearchHandle* EOS_HSessionSearch;

/**
 * Release the memory associated with session modification. 
 * This must be called on data retrieved from EOS_Sessions_CreateSessionModification or EOS_Sessions_UpdateSessionModification
 *
 * @param SessionModificationHandle - The session modification handle to release
 *
 * @see EOS_Sessions_CreateSessionModification
 * @see EOS_Sessions_UpdateSessionModification
 */
EOS_DECLARE_FUNC(void) EOS_SessionModification_Release(EOS_HSessionModification SessionModificationHandle);

/**
 * Release the memory associated with an active session.
 * This must be called on data retrieved from EOS_Sessions_CopyActiveSessionHandle
 *
 * @param ActiveSessionHandle - The active session handle to release
 *
 * @see EOS_Sessions_CopyActiveSessionHandle
 */
EOS_DECLARE_FUNC(void) EOS_ActiveSession_Release(EOS_HActiveSession ActiveSessionHandle);

/**
 * Release the memory associated with a single session. This must be called on data retrieved from EOS_SessionSearch_CopySearchResultByIndex.
 *
 * @param SessionHandle - The session handle to release
 *
 * @see EOS_SessionSearch_CopySearchResultByIndex
 */
EOS_DECLARE_FUNC(void) EOS_SessionDetails_Release(EOS_HSessionDetails SessionHandle);

/**
 * Release the memory associated with a session search. This must be called on data retrieved from EOS_Sessions_CreateSessionSearch.
 *
 * @param SessionSearchHandle - The session search handle to release
 *
 * @see EOS_Sessions_CreateSessionSearch
 */
EOS_DECLARE_FUNC(void) EOS_SessionSearch_Release(EOS_HSessionSearch SessionSearchHandle);


/** All possible states of an existing named session */
EOS_ENUM(EOS_EOnlineSessionState,
	/** An online session has not been created yet */
	EOS_OSS_NoSession = 0,
	/** An online session is in the process of being created */
	EOS_OSS_Creating = 1,
	/** Session has been created but the session hasn't started (pre match lobby) */
	EOS_OSS_Pending = 2,
	/** Session has been asked to start (may take time due to communication with backend) */
	EOS_OSS_Starting = 3,
	/** The current session has started. Sessions with join in progress disabled are no longer joinable */
	EOS_OSS_InProgress = 4,
	/** The session is still valid, but the session is no longer being played (post match lobby) */
	EOS_OSS_Ending = 5,
	/** The session is closed and any stats committed */
	EOS_OSS_Ended = 6,
	/** The session is being destroyed */
	EOS_OSS_Destroying = 7
);

/** Advertisement properties for a single attribute associated with a session */
EOS_ENUM(EOS_ESessionAttributeAdvertisementType,
	/** Don't advertise via the online service */
	EOS_SAAT_DontAdvertise = 0,
	/** Advertise via the online service only */
	EOS_SAAT_Advertise = 1
);

/** Deprecated 1.4 types, do not use */
#define EOS_SAT_Boolean EOS_AT_BOOLEAN
#define EOS_SAT_Int64	EOS_AT_INT64
#define EOS_SAT_Double	EOS_AT_DOUBLE
#define EOS_SAT_String	EOS_AT_STRING

/** Deprecated 1.4 types, do not use */
#define EOS_OCO_EQUAL				EOS_CO_EQUAL
#define EOS_OCO_NOTEQUAL			EOS_CO_NOTEQUAL
#define EOS_OCO_GREATERTHAN			EOS_CO_GREATERTHAN
#define EOS_OCO_GREATERTHANOREQUAL	EOS_CO_GREATERTHANOREQUAL
#define EOS_OCO_LESSTHAN			EOS_CO_LESSTHAN
#define EOS_OCO_LESSTHANOREQUAL		EOS_CO_LESSTHANOREQUAL
#define EOS_OCO_DISTANCE			EOS_CO_DISTANCE
#define EOS_OCO_ANYOF				EOS_CO_ANYOF
#define EOS_OCO_NOTANYOF			EOS_CO_NOTANYOF


/** Maximum number of attributes allowed on the session */
#define EOS_SESSIONMODIFICATION_MAX_SESSION_ATTRIBUTES 64
/** Maximum length of the name of the attribute associated with the session */
#define EOS_SESSIONMODIFICATION_MAX_SESSION_ATTRIBUTE_LENGTH 64

/** Minimum number of characters allowed in the session id override */
#define EOS_SESSIONMODIFICATION_MIN_SESSIONIDOVERRIDE_LENGTH 16
/** Maximum number of characters allowed in the session id override */
#define EOS_SESSIONMODIFICATION_MAX_SESSIONIDOVERRIDE_LENGTH 64

/** The most recent version of the EOS_Sessions_CreateSessionModification API. */
#define EOS_SESSIONS_CREATESESSIONMODIFICATION_API_LATEST 3

/**
 * Input parameters for the EOS_Sessions_CreateSessionModification function.
 */
EOS_STRUCT(EOS_Sessions_CreateSessionModificationOptions, (
	/** API Version: Set this to EOS_SESSIONS_CREATESESSIONMODIFICATION_API_LATEST. */
	int32_t ApiVersion;
	/** Name of the session to create */
	const char* SessionName;
	/** Bucket ID associated with the session */
	const char* BucketId;
	/** Maximum number of players allowed in the session */
	uint32_t MaxPlayers;
	/** The Product User ID of the local user associated with the session */
	EOS_ProductUserId LocalUserId;
	/** 
	 * If true, this session will be associated with presence. Only one session at a time can have this flag true.
	 * This affects the ability of the Social Overlay to show game related actions to take in the user's social graph.
	 * 
	 * @note The Social Overlay can handle only one of the following three options at a time:
	 * * using the bPresenceEnabled flags within the Sessions interface
	 * * using the bPresenceEnabled flags within the Lobby interface
	 * * using EOS_PresenceModification_SetJoinInfo
	 *
	 * @see EOS_PresenceModification_SetJoinInfoOptions
	 * @see EOS_Lobby_CreateLobbyOptions
	 * @see EOS_Lobby_JoinLobbyOptions
	 * @see EOS_Sessions_JoinSessionOptions
	 */
	EOS_Bool bPresenceEnabled;
	/**
	 * Optional session id - set to a globally unique value to override the backend assignment
	 * If not specified the backend service will assign one to the session.  Do not mix and match.
	 * This value can be of size [EOS_SESSIONMODIFICATION_MIN_SESSIONIDOVERRIDE_LENGTH, EOS_SESSIONMODIFICATION_MAX_SESSIONIDOVERRIDE_LENGTH]
	 */
	const char* SessionId;
));

/** The most recent version of the EOS_Sessions_UpdateSessionModification API. */
#define EOS_SESSIONS_UPDATESESSIONMODIFICATION_API_LATEST 1

/**
 * Input parameters for the EOS_Sessions_UpdateSessionModification function.
 */
EOS_STRUCT(EOS_Sessions_UpdateSessionModificationOptions, (
	/** API Version: Set this to EOS_SESSIONS_UPDATESESSIONMODIFICATION_API_LATEST. */
	int32_t ApiVersion;
	/** Name of the session to update */
	const char* SessionName;
));

/** Max length of an invite ID */
#define EOS_SESSIONS_INVITEID_MAX_LENGTH 64

/** The most recent version of the EOS_Sessions_SendInvite API. */
#define EOS_SESSIONS_SENDINVITE_API_LATEST 1

/**
 * Input parameters for the EOS_Sessions_SendInvite function.
 */
EOS_STRUCT(EOS_Sessions_SendInviteOptions, (
	/** API Version: Set this to EOS_SESSIONS_SENDINVITE_API_LATEST. */
	int32_t ApiVersion;
	/** Name of the session associated with the invite */
	const char* SessionName;
	/** The Product User ID of the local user sending the invitation */
	EOS_ProductUserId LocalUserId;
	/** The Product User of the remote user receiving the invitation */
	EOS_ProductUserId TargetUserId;
));

/**
 * Output parameters for the EOS_Sessions_SendInvite function.
 */
EOS_STRUCT(EOS_Sessions_SendInviteCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Sessions_SendInvite */
	void* ClientData;
));

/**
 * Function prototype definition for callbacks passed to EOS_Sessions_SendInvite
 * @param Data A EOS_Sessions_SendInviteCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Sessions_OnSendInviteCallback, const EOS_Sessions_SendInviteCallbackInfo* Data);

/** The most recent version of the EOS_Sessions_RejectInvite API. */
#define EOS_SESSIONS_REJECTINVITE_API_LATEST 1

/**
 * Input parameters for the EOS_Sessions_RejectInvite function.
 */
EOS_STRUCT(EOS_Sessions_RejectInviteOptions, (
	/** API Version: Set this to EOS_SESSIONS_REJECTINVITE_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user rejecting the invitation */
	EOS_ProductUserId LocalUserId;
	/** The invite ID to reject */
	const char* InviteId;
));

/**
 * Output parameters for the EOS_Sessions_RejectInvite function.
 */
EOS_STRUCT(EOS_Sessions_RejectInviteCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Sessions_RejectInvite */
	void* ClientData;
));

/**
 * Function prototype definition for callbacks passed to EOS_Sessions_RejectInvite
 * @param Data A EOS_Sessions_RejectInviteCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Sessions_OnRejectInviteCallback, const EOS_Sessions_RejectInviteCallbackInfo* Data);

/** The most recent version of the EOS_Sessions_QueryInvites API. */
#define EOS_SESSIONS_QUERYINVITES_API_LATEST 1

/**
 * Input parameters for the EOS_Sessions_QueryInvites function.
 */
EOS_STRUCT(EOS_Sessions_QueryInvitesOptions, (
	/** API Version: Set this to EOS_SESSIONS_QUERYINVITES_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID to query for invitations */
	EOS_ProductUserId LocalUserId;
));

/**
 * Output parameters for the EOS_Sessions_QueryInvites function.
 */
EOS_STRUCT(EOS_Sessions_QueryInvitesCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Sessions_QueryInvites */
	void* ClientData;
	/** The Product User of the local user who made the request */
	EOS_ProductUserId LocalUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Sessions_QueryInvites
 * @param Data A EOS_Sessions_QueryInvites CallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Sessions_OnQueryInvitesCallback, const EOS_Sessions_QueryInvitesCallbackInfo* Data);

/** The most recent version of the EOS_Sessions_GetInviteCount API. */
#define EOS_SESSIONS_GETINVITECOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Sessions_GetInviteCount function.
 */
EOS_STRUCT(EOS_Sessions_GetInviteCountOptions, (
	/** API Version: Set this to EOS_SESSIONS_GETINVITECOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user who has one or more invitations in the cache */
	EOS_ProductUserId LocalUserId;
));

/** The most recent version of the EOS_Sessions_GetInviteIdByIndex API. */
#define EOS_SESSIONS_GETINVITEIDBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_Sessions_GetInviteIdByIndex function.
 */
EOS_STRUCT(EOS_Sessions_GetInviteIdByIndexOptions, (
	/** API Version: Set this to EOS_SESSIONS_GETINVITEIDBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user who has an invitation in the cache */
	EOS_ProductUserId LocalUserId;
	/** Index of the invite ID to retrieve */
	uint32_t Index;
));

/** The most recent version of the EOS_Sessions_CreateSessionSearch API. */
#define EOS_SESSIONS_CREATESESSIONSEARCH_API_LATEST 1

/**
 * Input parameters for the EOS_Sessions_CreateSessionSearch function.
 */
EOS_STRUCT(EOS_Sessions_CreateSessionSearchOptions, (
	/** API Version: Set this to EOS_SESSIONS_CREATESESSIONSEARCH_API_LATEST. */
	int32_t ApiVersion;
	/** Max number of results to return */
	uint32_t MaxSearchResults;
));

/** The most recent version of the EOS_Sessions_UpdateSession API. */
#define EOS_SESSIONS_UPDATESESSION_API_LATEST 1
EOS_STRUCT(EOS_Sessions_UpdateSessionOptions, (
	/** API Version: Set this to EOS_SESSIONS_UPDATESESSION_API_LATEST. */
	int32_t ApiVersion;
	/** Builder handle */
	EOS_HSessionModification SessionModificationHandle;
));

/**
 * Output parameters for the EOS_Sessions_UpdateSession function.
 */
EOS_STRUCT(EOS_Sessions_UpdateSessionCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Sessions_UpdateSession */
	void* ClientData;
	/** Name of the session that was created/modified */
	const char* SessionName;
	/** ID of the session that was created/modified */
	const char* SessionId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Sessions_UpdateSession
 * @param Data A EOS_Sessions_UpdateSessionCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Sessions_OnUpdateSessionCallback, const EOS_Sessions_UpdateSessionCallbackInfo* Data);

/** The most recent version of the EOS_Sessions_DestroySession API. */
#define EOS_SESSIONS_DESTROYSESSION_API_LATEST 1

/**
 * Input parameters for the EOS_Sessions_DestroySession function.
 */
EOS_STRUCT(EOS_Sessions_DestroySessionOptions, (
	/** API Version: Set this to EOS_SESSIONS_DESTROYSESSION_API_LATEST. */
	int32_t ApiVersion;
	/** Name of the session to destroy */
	const char* SessionName;
));

/**
 * Output parameters for the EOS_Sessions_DestroySession function.
 */
EOS_STRUCT(EOS_Sessions_DestroySessionCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Sessions_DestroySession */
	void* ClientData;
));

/**
 * Function prototype definition for callbacks passed to EOS_Sessions_DestroySession
 * @param Data A EOS_Sessions_DestroySessionCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Sessions_OnDestroySessionCallback, const EOS_Sessions_DestroySessionCallbackInfo* Data);

/** The most recent version of the EOS_Sessions_JoinSession API. */
#define EOS_SESSIONS_JOINSESSION_API_LATEST 2

/**
 * Input parameters for the EOS_Sessions_JoinSession function.
 */
EOS_STRUCT(EOS_Sessions_JoinSessionOptions, (
	/** API Version: Set this to EOS_SESSIONS_JOINSESSION_API_LATEST. */
	int32_t ApiVersion;
	/** Name of the session to create after joining session */
	const char* SessionName;
	/** Session handle to join */
	EOS_HSessionDetails SessionHandle;
	/** The Product User ID of the local user who is joining the session */
	EOS_ProductUserId LocalUserId;
	/** 
	 * If true, this session will be associated with presence. Only one session at a time can have this flag true.
	 * This affects the ability of the Social Overlay to show game related actions to take in the user's social graph.
	 *
	 * @note The Social Overlay can handle only one of the following three options at a time:
	 * * using the bPresenceEnabled flags within the Sessions interface
	 * * using the bPresenceEnabled flags within the Lobby interface
	 * * using EOS_PresenceModification_SetJoinInfo
	 *
	 * @see EOS_PresenceModification_SetJoinInfoOptions
	 * @see EOS_Lobby_CreateLobbyOptions
	 * @see EOS_Lobby_JoinLobbyOptions
	 * @see EOS_Sessions_CreateSessionModificationOptions
	 */
	EOS_Bool bPresenceEnabled;
));

/**
 * Output parameters for the EOS_Sessions_JoinSession function.
 */
EOS_STRUCT(EOS_Sessions_JoinSessionCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Sessions_JoinSession */
	void* ClientData;
));

/**
 * Function prototype definition for callbacks passed to EOS_Sessions_JoinSession
 * @param Data A EOS_Sessions_JoinSessionCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Sessions_OnJoinSessionCallback, const EOS_Sessions_JoinSessionCallbackInfo* Data);

/** The most recent version of the EOS_Sessions_StartSession API. */
#define EOS_SESSIONS_STARTSESSION_API_LATEST 1

/**
 * Input parameters for the EOS_Sessions_StartSession function.
 */
EOS_STRUCT(EOS_Sessions_StartSessionOptions, (
	/** API Version: Set this to EOS_SESSIONS_STARTSESSION_API_LATEST. */
	int32_t ApiVersion;
	/** Name of the session to set in progress */
	const char* SessionName;
));

EOS_STRUCT(EOS_Sessions_StartSessionCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Sessions_StartSession */
	void* ClientData;
));

/**
 * Function prototype definition for callbacks passed to EOS_Sessions_StartSession
 * @param Data A EOS_Sessions_StartSessionCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Sessions_OnStartSessionCallback, const EOS_Sessions_StartSessionCallbackInfo* Data);

/** The most recent version of the EOS_Sessions_EndSession API. */
#define EOS_SESSIONS_ENDSESSION_API_LATEST 1

/**
 * Input parameters for the EOS_Sessions_EndSession function.
 */
EOS_STRUCT(EOS_Sessions_EndSessionOptions, (
	/** API Version: Set this to EOS_SESSIONS_ENDSESSION_API_LATEST. */
	int32_t ApiVersion;
	/** Name of the session to set as no long in progress */
	const char* SessionName;
));

EOS_STRUCT(EOS_Sessions_EndSessionCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Sessions_EndSession */
	void* ClientData;
));

/**
 * Function prototype definition for callbacks passed to EOS_Sessions_EndSession
 * @param Data A EOS_Sessions_EndSessionCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Sessions_OnEndSessionCallback, const EOS_Sessions_EndSessionCallbackInfo* Data);

/** The most recent version of the EOS_Sessions_RegisterPlayers API. */
#define EOS_SESSIONS_REGISTERPLAYERS_API_LATEST 1

/**
 * Input parameters for the EOS_Sessions_RegisterPlayers function.
 */
EOS_STRUCT(EOS_Sessions_RegisterPlayersOptions, (
	/** API Version: Set this to EOS_SESSIONS_REGISTERPLAYERS_API_LATEST. */
	int32_t ApiVersion;
	/** Name of the session for which to register players */
	const char* SessionName;
	/** Array of players to register with the session */
	EOS_ProductUserId* PlayersToRegister;
	/** Number of players in the array */
	uint32_t PlayersToRegisterCount;
));

EOS_STRUCT(EOS_Sessions_RegisterPlayersCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Sessions_RegisterPlayers */
	void* ClientData;
));

/**
 * Function prototype definition for callbacks passed to EOS_Sessions_RegisterPlayers
 * @param Data A EOS_Sessions_RegisterPlayersCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Sessions_OnRegisterPlayersCallback, const EOS_Sessions_RegisterPlayersCallbackInfo* Data);

/** The most recent version of the EOS_Sessions_UnregisterPlayers API. */
#define EOS_SESSIONS_UNREGISTERPLAYERS_API_LATEST 1

/**
 * Input parameters for the EOS_Sessions_UnregisterPlayers function.
 */
EOS_STRUCT(EOS_Sessions_UnregisterPlayersOptions, (
	/** API Version: Set this to EOS_SESSIONS_UNREGISTERPLAYERS_API_LATEST. */
	int32_t ApiVersion;
	/** Name of the session for which to unregister players */
	const char* SessionName;
	/** Array of players to unregister from the session */
	EOS_ProductUserId* PlayersToUnregister;
	/** Number of players in the array */
	uint32_t PlayersToUnregisterCount;
));

EOS_STRUCT(EOS_Sessions_UnregisterPlayersCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Sessions_UnregisterPlayers */
	void* ClientData;
));

/**
 * Function prototype definition for callbacks passed to EOS_Sessions_UnregisterPlayers
 * @param Data A EOS_Sessions_UnregisterPlayersCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Sessions_OnUnregisterPlayersCallback, const EOS_Sessions_UnregisterPlayersCallbackInfo* Data);

/** The most recent version of the EOS_SessionModification_SetBucketId API. */
#define EOS_SESSIONMODIFICATION_SETBUCKETID_API_LATEST 1

/**
 * Input parameters for the EOS_SessionModification_SetBucketId function.
 */
EOS_STRUCT(EOS_SessionModification_SetBucketIdOptions, (
	/** API Version: Set this to EOS_SESSIONMODIFICATION_SETBUCKETID_API_LATEST. */
	int32_t ApiVersion;
	/** The new bucket id associated with the session */
	const char* BucketId;
));

/** The most recent version of the EOS_SessionModification_SetHostAddress API. */
#define EOS_SESSIONMODIFICATION_SETHOSTADDRESS_API_LATEST 1

/**
 * Input parameters for the EOS_SessionModification_SetHostAddress function.
 */
EOS_STRUCT(EOS_SessionModification_SetHostAddressOptions, (
	/** API Version: Set this to EOS_SESSIONMODIFICATION_SETHOSTADDRESS_API_LATEST. */
	int32_t ApiVersion;
	/** A string representing the host address for the session, its meaning is up to the application */
	const char* HostAddress;
));

/** Permission level gets more restrictive further down */
EOS_ENUM(EOS_EOnlineSessionPermissionLevel,
	/** Anyone can find this session as long as it isn't full */
	EOS_OSPF_PublicAdvertised = 0,
	/** Players who have access to presence can see this session */
	EOS_OSPF_JoinViaPresence = 1,
	/** Only players with invites registered can see this session */
	EOS_OSPF_InviteOnly = 2
);

/** The most recent version of the EOS_SessionModification_SetPermissionLevel API. */
#define EOS_SESSIONMODIFICATION_SETPERMISSIONLEVEL_API_LATEST 1

/**
 * Input parameters for the EOS_SessionModification_SetPermissionLevel function.
 */
EOS_STRUCT(EOS_SessionModification_SetPermissionLevelOptions, (
	/** API Version: Set this to EOS_SESSIONMODIFICATION_SETPERMISSIONLEVEL_API_LATEST. */
	int32_t ApiVersion;
	/** Permission level to set on the sesion */
	EOS_EOnlineSessionPermissionLevel PermissionLevel;
));

/** The most recent version of the EOS_SessionModification_SetJoinInProgressAllowed API. */
#define EOS_SESSIONMODIFICATION_SETJOININPROGRESSALLOWED_API_LATEST 1

/**
 * Input parameters for the EOS_SessionModification_SetJoinInProgressAllowed function.
 */
EOS_STRUCT(EOS_SessionModification_SetJoinInProgressAllowedOptions, (
	/** API Version: Set this to EOS_SESSIONMODIFICATION_SETJOININPROGRESSALLOWED_API_LATEST. */
	int32_t ApiVersion;
	/** Does the session allow join in progress */
	EOS_Bool bAllowJoinInProgress;
));

/** Maximum number of players allowed in a single session */
#define EOS_SESSIONS_MAXREGISTEREDPLAYERS 1000

/** The most recent version of the EOS_SessionModification_SetMaxPlayers API. */
#define EOS_SESSIONMODIFICATION_SETMAXPLAYERS_API_LATEST 1

/**
 * Input parameters for the EOS_SessionModification_SetMaxPlayers function.
 */
EOS_STRUCT(EOS_SessionModification_SetMaxPlayersOptions, (
	/** API Version: Set this to EOS_SESSIONMODIFICATION_SETMAXPLAYERS_API_LATEST. */
	int32_t ApiVersion;
	/** Max number of players to allow in the session */
	uint32_t MaxPlayers;
));

/** The most recent version of the EOS_SessionModification_SetInvitesAllowed API. */
#define EOS_SESSIONMODIFICATION_SETINVITESALLOWED_API_LATEST 1

/**
 * Input parameters for the EOS_SessionModification_SetInvitesAllowed function.
 */
EOS_STRUCT(EOS_SessionModification_SetInvitesAllowedOptions, (
	/** API Version: Set this to EOS_SESSIONMODIFICATION_SETINVITESALLOWED_API_LATEST. */
	int32_t ApiVersion;
	/** If true then invites can currently be sent for the associated session */
	EOS_Bool bInvitesAllowed;
));


/** Search for a matching bucket ID (value is string) */
#define EOS_SESSIONS_SEARCH_BUCKET_ID "bucket"
/** Search for empty servers only (value is true/false) */
#define EOS_SESSIONS_SEARCH_EMPTY_SERVERS_ONLY "emptyonly"
/** Search for non empty servers only (value is true/false) */
#define EOS_SESSIONS_SEARCH_NONEMPTY_SERVERS_ONLY "nonemptyonly"
/** Search for a match with min free space (value is int) */
#define EOS_SESSIONS_SEARCH_MINSLOTSAVAILABLE "minslotsavailable"

/** The most recent version of the EOS_Sessions_AttributeData struct. */
#define EOS_SESSIONS_ATTRIBUTEDATA_API_LATEST 1

/** DEPRECATED! Use EOS_SESSIONS_ATTRIBUTEDATA_API_LATEST instead. */
#define EOS_SESSIONS_SESSIONATTRIBUTEDATA_API_LATEST EOS_SESSIONS_ATTRIBUTEDATA_API_LATEST

/**
 * Contains information about both session and search parameter attribution
 */
EOS_STRUCT(EOS_Sessions_AttributeData, (
	/** API Version: Set this to EOS_SESSIONS_ATTRIBUTEDATA_API_LATEST. */
	int32_t ApiVersion;
	/** Name of the session attribute */
	const char* Key;
	union
	{
		/** Stored as an 8 byte integer */
		int64_t AsInt64;
		/** Stored as a double precision floating point */
		double AsDouble;
		/** Stored as a boolean */
		EOS_Bool AsBool;
		/** Stored as a null terminated UTF8 string */
		const char* AsUtf8;
	} Value;

	/** Type of value stored in the union */
	EOS_ESessionAttributeType ValueType;
));

/** The most recent version of the EOS_ActiveSession_CopyInfo function. */
#define EOS_ACTIVESESSION_COPYINFO_API_LATEST 1

/**
 * Input parameters for the EOS_ActiveSession_CopyInfo function.
 */
EOS_STRUCT(EOS_ActiveSession_CopyInfoOptions, (
	/** API Version: Set this to EOS_ACTIVESESSION_COPYINFO_API_LATEST. */
	int32_t ApiVersion;
));

/** The most recent version of the EOS_ActiveSession_GetRegisteredPlayerCount function. */
#define EOS_ACTIVESESSION_GETREGISTEREDPLAYERCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_ActiveSession_GetRegisteredPlayerCount function.
 */
EOS_STRUCT(EOS_ActiveSession_GetRegisteredPlayerCountOptions, (
	/** API Version: Set this to EOS_ACTIVESESSION_GETREGISTEREDPLAYERCOUNT_API_LATEST. */
	int32_t ApiVersion;
));

/** The most recent version of the EOS_ActiveSession_GetRegisteredPlayerByIndex function. */
#define EOS_ACTIVESESSION_GETREGISTEREDPLAYERBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_ActiveSession_GetRegisteredPlayerByIndex function.
 */
EOS_STRUCT(EOS_ActiveSession_GetRegisteredPlayerByIndexOptions, (
	/** API Version: Set this to EOS_ACTIVESESSION_GETREGISTEREDPLAYERBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** Index of the registered player to retrieve */
	uint32_t PlayerIndex;
));

/** The most recent version of the EOS_SessionDetails_Attribute struct. */
#define EOS_SESSIONDETAILS_ATTRIBUTE_API_LATEST 1

/** DEPRECATED! Use EOS_SESSIONDETAILS_ATTRIBUTE_API_LATEST instead. */
#define EOS_SESSIONS_SESSIONATTRIBUTE_API_LATEST EOS_SESSIONDETAILS_ATTRIBUTE_API_LATEST

/**
 *  An attribution value and its advertisement setting stored with a session.  
 */
EOS_STRUCT(EOS_SessionDetails_Attribute, (
	/** API Version: Set this to EOS_SESSIONDETAILS_ATTRIBUTE_API_LATEST. */
	int32_t ApiVersion;
	/** Key/Value pair describing the attribute */
	EOS_Sessions_AttributeData* Data;
	/** Is this attribution advertised with the backend or simply stored locally */
	EOS_ESessionAttributeAdvertisementType AdvertisementType;
));

/**
 * Release the memory associated with a session attribute. This must be called on data retrieved from EOS_SessionDetails_CopySessionAttributeByIndex.
 *
 * @param SessionAttribute - The session attribute to release
 *
 * @see EOS_SessionDetails_CopySessionAttributeByIndex
 */
EOS_DECLARE_FUNC(void) EOS_SessionDetails_Attribute_Release(EOS_SessionDetails_Attribute* SessionAttribute);


/** The most recent version of the EOS_SessionModification_AddAttribute API. */
#define EOS_SESSIONMODIFICATION_ADDATTRIBUTE_API_LATEST 1

/**
 * Input parameters for the EOS_SessionModification_AddAttribute function.
 */
EOS_STRUCT(EOS_SessionModification_AddAttributeOptions, (
	/** API Version: Set this to EOS_SESSIONMODIFICATION_ADDATTRIBUTE_API_LATEST. */
	int32_t ApiVersion;
	/** Key/Value pair describing the attribute to add to the session */
	const EOS_Sessions_AttributeData* SessionAttribute;
	/** Is this attribution advertised with the backend or simply stored locally */
	EOS_ESessionAttributeAdvertisementType AdvertisementType;
));

/** The most recent version of the EOS_SessionModification_RemoveAttribute API. */
#define EOS_SESSIONMODIFICATION_REMOVEATTRIBUTE_API_LATEST 1

/**
 * Input parameters for the EOS_SessionModification_RemoveAttribute function.
 */
EOS_STRUCT(EOS_SessionModification_RemoveAttributeOptions, (
	/** API Version: Set this to EOS_SESSIONDETAILS_SETTINGS_API_LATEST. */
	int32_t ApiVersion;
	/** Session attribute to remove from the session */
	const char* Key;
));

/** Maximum number of search results allowed with a given query */
#define EOS_SESSIONS_MAX_SEARCH_RESULTS 200

/** The most recent version of the EOS_SessionSearch_SetMaxResults API. */
#define EOS_SESSIONSEARCH_SETMAXSEARCHRESULTS_API_LATEST 1

/**
 * Input parameters for the EOS_SessionSearch_SetMaxResults function.
 */
EOS_STRUCT(EOS_SessionSearch_SetMaxResultsOptions, (
	/** API Version: Set this to EOS_SESSIONSEARCH_SETMAXSEARCHRESULTS_API_LATEST. */
	int32_t ApiVersion;
	/** Maximum number of search results returned with this query, may not exceed EOS_SESSIONS_MAX_SEARCH_RESULTS */
	uint32_t MaxSearchResults;
));

/** The most recent version of the EOS_SessionSearch_Find API. */
#define EOS_SESSIONSEARCH_FIND_API_LATEST 2

/**
 * Input parameters for the EOS_SessionSearch_Find function.
 */
EOS_STRUCT(EOS_SessionSearch_FindOptions, (
	/** API Version: Set this to EOS_SESSIONDETAILS_SETTINGS_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user who is searching */
	EOS_ProductUserId LocalUserId;
));

EOS_STRUCT(EOS_SessionSearch_FindCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_SessionSearch_Find */
	void* ClientData;
));

/**
 * Function prototype definition for callbacks passed to EOS_SessionSearch_Find
 * @param Data A EOS_SessionSearch_FindCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_SessionSearch_OnFindCallback, const EOS_SessionSearch_FindCallbackInfo* Data);

/** The most recent version of the EOS_SessionSearch_GetSearchResultCount API. */
#define EOS_SESSIONSEARCH_GETSEARCHRESULTCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_SessionSearch_GetSearchResultCount function.
 */
EOS_STRUCT(EOS_SessionSearch_GetSearchResultCountOptions, (
	/** API Version: Set this to EOS_SESSIONDETAILS_SETTINGS_API_LATEST. */
	int32_t ApiVersion;
));
		
/** The most recent version of the EOS_SessionSearch_CopySearchResultByIndex API. */
#define EOS_SESSIONSEARCH_COPYSEARCHRESULTBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_SessionSearch_CopySearchResultByIndex function.
 */
EOS_STRUCT(EOS_SessionSearch_CopySearchResultByIndexOptions, (
	/** API Version: Set this to EOS_SESSIONDETAILS_SETTINGS_API_LATEST. */
	int32_t ApiVersion;
	/** 
	 * The index of the session to retrieve within the completed search query
	 * @see EOS_SessionSearch_GetSearchResultCount
	 */
	uint32_t SessionIndex;
));

/** The most recent version of the EOS_SessionSearch_SetSessionId API. */
#define EOS_SESSIONSEARCH_SETSESSIONID_API_LATEST 1

/**
 * Input parameters for the EOS_SessionSearch_SetSessionId function.
 */
EOS_STRUCT(EOS_SessionSearch_SetSessionIdOptions, (
	/** API Version: Set this to EOS_SESSIONDETAILS_SETTINGS_API_LATEST. */
	int32_t ApiVersion;
	/** Search sessions for a specific session ID, returning at most one session */
	const char* SessionId;
));

/** The most recent version of the EOS_SessionSearch_SetTargetUserId API. */
#define EOS_SESSIONSEARCH_SETTARGETUSERID_API_LATEST 1

/**
 * Input parameters for the EOS_SessionSearch_SetTargetUserId function.
 */
EOS_STRUCT(EOS_SessionSearch_SetTargetUserIdOptions, (
	/** API Version: Set this to EOS_SESSIONDETAILS_SETTINGS_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID to find; return any sessions where the user matching this ID is currently registered */
	EOS_ProductUserId TargetUserId;
));

/** The most recent version of the EOS_SessionSearch_SetParameter API. */
#define EOS_SESSIONSEARCH_SETPARAMETER_API_LATEST 1

/**
 * Input parameters for the EOS_SessionSearch_SetParameter function.
 *
 * A search key may be set more than once to make multiple comparisons
 * The two comparisons are AND'd together
 * (ie, Key GREATER_THAN 5, Key NOT_EQUALS 10)
 */
EOS_STRUCT(EOS_SessionSearch_SetParameterOptions, (
	/** API Version: Set this to EOS_SESSIONDETAILS_SETTINGS_API_LATEST. */
	int32_t ApiVersion;
	/** Search parameter describing a key and a value to compare */
	const EOS_Sessions_AttributeData* Parameter;
	/** The type of comparison to make against the search parameter */
	EOS_EOnlineComparisonOp ComparisonOp;
));

/** The most recent version of the EOS_SessionSearch_RemoveParameter API. */
#define EOS_SESSIONSEARCH_REMOVEPARAMETER_API_LATEST 1

/**
 * Input parameters for the EOS_SessionSearch_RemoveParameter function.
 *
 * Removal requires both the key and its comparator in order to remove as the same key can be used in more than one operation
 */
EOS_STRUCT(EOS_SessionSearch_RemoveParameterOptions, (
	/** API Version: Set this to EOS_SESSIONDETAILS_SETTINGS_API_LATEST. */
	int32_t ApiVersion;
	/** Search parameter key to remove from the search */
	const char* Key;
	/** Search comparison operation associated with the key to remove */
	EOS_EOnlineComparisonOp ComparisonOp;
));

/** The most recent version of the EOS_SessionDetails_Settings struct. */
#define EOS_SESSIONDETAILS_SETTINGS_API_LATEST 2

/** Common settings associated with a single session */
EOS_STRUCT(EOS_SessionDetails_Settings, (
	/** API Version: Set this to EOS_SESSIONDETAILS_SETTINGS_API_LATEST. */
	int32_t ApiVersion;
	/** The main indexed parameter for this session, can be any string (ie "Region:GameMode") */
	const char* BucketId;
	/** Number of total players allowed in the session */
	uint32_t NumPublicConnections;
	/** Are players allowed to join the session while it is in the "in progress" state */
	EOS_Bool bAllowJoinInProgress;
	/** Permission level describing allowed access to the session when joining or searching for the session */
	EOS_EOnlineSessionPermissionLevel PermissionLevel;
	/** Are players allowed to send invites for the session */
	EOS_Bool bInvitesAllowed;
));

/** The most recent version of the EOS_SessionDetails_Info struct. */
#define EOS_SESSIONDETAILS_INFO_API_LATEST 1

/** Internal details about a session, found on both active sessions and within search results */
EOS_STRUCT(EOS_SessionDetails_Info, (
	/** API Version: Set this to EOS_SESSIONDETAILS_INFO_API_LATEST. */
	int32_t ApiVersion;
	/** Session ID assigned by the backend service */
	const char* SessionId;
	/** IP address of this session as visible by the backend service */
	const char* HostAddress;
	/** Number of remaining open spaces on the session (NumPublicConnections - RegisteredPlayers */
	uint32_t NumOpenPublicConnections;
	/** Reference to the additional settings associated with this session */
	const EOS_SessionDetails_Settings* Settings;
));

EOS_DECLARE_FUNC(void) EOS_SessionDetails_Info_Release(EOS_SessionDetails_Info* SessionInfo);

/** The most recent version of the EOS_SessionDetails_CopyInfo API. */
#define EOS_SESSIONDETAILS_COPYINFO_API_LATEST 1

/**
 * Input parameters for the EOS_SessionDetails_CopyInfo function.
 */
EOS_STRUCT(EOS_SessionDetails_CopyInfoOptions, (
	/** API Version: Set this to EOS_SESSIONDETAILS_COPYINFO_API_LATEST. */
	int32_t ApiVersion;
));

/** The most recent version of the EOS_SessionDetails_GetSessionAttributeCount API. */
#define EOS_SESSIONDETAILS_GETSESSIONATTRIBUTECOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_SessionDetails_GetSessionAttributeCount function.
 */
EOS_STRUCT(EOS_SessionDetails_GetSessionAttributeCountOptions, (
	/** API Version: Set this to EOS_SESSIONDETAILS_GETSESSIONATTRIBUTECOUNT_API_LATEST. */
	int32_t ApiVersion;
));

/** The most recent version of the EOS_SessionDetails_CopySessionAttributeByIndex API. */
#define EOS_SESSIONDETAILS_COPYSESSIONATTRIBUTEBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_SessionDetails_CopySessionAttributeByIndex function.
 */
EOS_STRUCT(EOS_SessionDetails_CopySessionAttributeByIndexOptions, (
	/** API Version: Set this to EOS_SESSIONDETAILS_COPYSESSIONATTRIBUTEBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** 
	 * The index of the attribute to retrieve
	 * @see EOS_SessionDetails_GetSessionAttributeCount
	 */
	uint32_t AttrIndex;
));

/** The most recent version of the EOS_SessionDetails_CopySessionAttributeByKey API. */
#define EOS_SESSIONDETAILS_COPYSESSIONATTRIBUTEBYKEY_API_LATEST 1

/**
 * Input parameters for the EOS_SessionDetails_CopySessionAttributeByKey function.
 */
EOS_STRUCT(EOS_SessionDetails_CopySessionAttributeByKeyOptions, (
	/** API Version: Set this to EOS_SESSIONDETAILS_COPYSESSIONATTRIBUTEBYKEY_API_LATEST. */
	int32_t ApiVersion;
	/** The name of the key to get the session attribution for 
	 * @see EOS_SessionModification_AddAttribute
	 */
	const char* AttrKey;
));

/** The most recent version of the EOS_ActiveSession_Info struct. */
#define EOS_ACTIVESESSION_INFO_API_LATEST 1

/**
 * Top level details about an active session
 */
EOS_STRUCT(EOS_ActiveSession_Info, (
	/** API Version: Set this to EOS_ACTIVESESSION_INFO_API_LATEST. */
	int32_t ApiVersion;
	/** Name of the session */
	const char* SessionName;
	/** The Product User ID of the local user who created or joined the session */
	EOS_ProductUserId LocalUserId;
	/** Current state of the session */
	EOS_EOnlineSessionState State;
	/** Session details */
	const EOS_SessionDetails_Info* SessionDetails;
));

/**
 * Release the memory associated with an EOS_ActiveSession_Info structure. This must be called on data retrieved from EOS_ActiveSession_CopyInfo.
 *
 * @param ActiveSessionInfo - The active session structure to be released
 *
 * @see EOS_ActiveSession_Info
 * @see EOS_ActiveSession_CopyInfo
 */
EOS_DECLARE_FUNC(void) EOS_ActiveSession_Info_Release(EOS_ActiveSession_Info* ActiveSessionInfo);

/** The most recent version of the EOS_Sessions_CopyActiveSessionHandle API. */
#define EOS_SESSIONS_COPYACTIVESESSIONHANDLE_API_LATEST 1

/**
 * Input parameters for the EOS_Sessions_CopyActiveSessionHandle function.
 */
EOS_STRUCT(EOS_Sessions_CopyActiveSessionHandleOptions, (
	/** API Version: Set this to EOS_SESSIONS_COPYACTIVESESSIONHANDLE_API_LATEST. */
	int32_t ApiVersion;
	/** Name of the session for which to retrieve a session handle */
	const char* SessionName;
));

/** The most recent version of the EOS_Sessions_AddNotifySessionInviteReceived API. */
#define EOS_SESSIONS_ADDNOTIFYSESSIONINVITERECEIVED_API_LATEST 1

/**
 * Input parameters for the EOS_Sessions_AddNotifySessionInviteReceived function.
 */
EOS_STRUCT(EOS_Sessions_AddNotifySessionInviteReceivedOptions, (
	/** API Version: Set this to EOS_SESSIONS_ADDNOTIFYSESSIONINVITERECEIVED_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_Sessions_OnSessionInviteReceivedCallback function.
 */
EOS_STRUCT(EOS_Sessions_SessionInviteReceivedCallbackInfo, (
	/** Context that was passed into EOS_Sessions_AddNotifySessionInviteReceived */
	void* ClientData;
	/** The Product User ID of the user who received the invite */
	EOS_ProductUserId LocalUserId;
	/** The Product User ID of the user who sent the invitation */
	EOS_ProductUserId TargetUserId;
	/** Invite ID used to retrieve the actual session details */
	const char* InviteId;
));

/**
 * Function prototype definition for notifications that come from EOS_Sessions_AddNotifySessionInviteReceived
 *
 * @param Data A EOS_Sessions_SessionInviteReceivedCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Sessions_OnSessionInviteReceivedCallback, const EOS_Sessions_SessionInviteReceivedCallbackInfo* Data);

/** The most recent version of the EOS_Sessions_AddNotifySessionInviteAccepted API. */
#define EOS_SESSIONS_ADDNOTIFYSESSIONINVITEACCEPTED_API_LATEST 1

/**
 * Input parameters for the EOS_Sessions_AddNotifySessionInviteAccepted function.
 */
EOS_STRUCT(EOS_Sessions_AddNotifySessionInviteAcceptedOptions, (
	/** API Version: Set this to EOS_SESSIONS_ADDNOTIFYSESSIONINVITEACCEPTED_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_Sessions_OnSessionInviteAcceptedCallback function.
 */
EOS_STRUCT(EOS_Sessions_SessionInviteAcceptedCallbackInfo, (
	/** Context that was passed into EOS_Sessions_AddNotifySessionInviteAccepted */
	void* ClientData;
	/** Session ID that should be used for joining */
	const char* SessionId;
	/** The Product User ID of the user who accepted the invitation */
	EOS_ProductUserId LocalUserId;
	/** The Product User ID of the user who sent the invitation */
	EOS_ProductUserId TargetUserId;
	/** Invite ID that was accepted */
	const char* InviteId;
));

/**
 * Function prototype definition for notifications that come from EOS_Sessions_AddNotifySessionInviteAccepted
 *
 * @param Data A EOS_Sessions_SessionInviteAcceptedCallbackInfo containing the output information and result
 *
 * @note The session for the invite must be joined.
 *
 * @see EOS_Sessions_CopySessionHandleByInviteId
 * @see EOS_Sessions_JoinSession
 */
EOS_DECLARE_CALLBACK(EOS_Sessions_OnSessionInviteAcceptedCallback, const EOS_Sessions_SessionInviteAcceptedCallbackInfo* Data);

/** The most recent version of the EOS_Sessions_AddNotifyJoinSessionAccepted API. */
#define EOS_SESSIONS_ADDNOTIFYJOINSESSIONACCEPTED_API_LATEST 1

/**
 * Input parameters for the EOS_Sessions_AddNotifyJoinSessionAccepted function.
 */
EOS_STRUCT(EOS_Sessions_AddNotifyJoinSessionAcceptedOptions, (
	/** API Version: Set this to EOS_SESSIONS_ADDNOTIFYJOINSESSIONACCEPTED_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_Sessions_OnJoinSessionAcceptedCallback function.
 */
EOS_STRUCT(EOS_Sessions_JoinSessionAcceptedCallbackInfo, (
	/** Context that was passed into EOS_Sessions_AddNotifyJoinSessionAccepted */
	void* ClientData;
	/** The Product User ID for the user who initialized the game */
	EOS_ProductUserId LocalUserId;
	/** 
	 * The UI Event associated with this Join Game event.
	 * This should be used with EOS_Sessions_CopySessionHandleByUiEventId to get a handle to be used
	 * when calling EOS_Sessions_JoinSession.
	 */
	EOS_UI_EventId UiEventId;
));

/**
 * Function prototype definition for notifications that come from EOS_Sessions_AddNotifyJoinSessionAccepted
 *
 * @param Data A EOS_Sessions_JoinSessionAcceptedCallbackInfo containing the output information and result
 *
 * @note The session for the join game must be joined.
 *
 * @see EOS_Sessions_CopySessionHandleByUiEventId
 * @see EOS_Sessions_JoinSession
 */
EOS_DECLARE_CALLBACK(EOS_Sessions_OnJoinSessionAcceptedCallback, const EOS_Sessions_JoinSessionAcceptedCallbackInfo* Data);


/** The most recent version of the EOS_Sessions_CopySessionHandleByInviteId API. */
#define EOS_SESSIONS_COPYSESSIONHANDLEBYINVITEID_API_LATEST 1

/**
 * Input parameters for the EOS_Sessions_CopySessionHandleByInviteId function.
 */
EOS_STRUCT(EOS_Sessions_CopySessionHandleByInviteIdOptions, (
	/** API Version: Set this to EOS_SESSIONS_COPYSESSIONHANDLEBYINVITEID_API_LATEST. */
	int32_t ApiVersion;
	/** Invite ID for which to retrieve a session handle */
	const char* InviteId;
));

/** The most recent version of the EOS_Sessions_CopySessionHandleByUiEventId API. */
#define EOS_SESSIONS_COPYSESSIONHANDLEBYUIEVENTID_API_LATEST 1

/**
 * Input parameters for the EOS_Sessions_CopySessionHandleByUiEventId function.
 */
EOS_STRUCT(EOS_Sessions_CopySessionHandleByUiEventIdOptions, (
	/** API Version: Set this to EOS_SESSIONS_COPYSESSIONHANDLEBYUIEVENTID_API_LATEST. */
	int32_t ApiVersion;
	/** UI Event associated with the session */
	EOS_UI_EventId UiEventId;
));

/** The most recent version of the EOS_Sessions_CopySessionHandleForPresence API. */
#define EOS_SESSIONS_COPYSESSIONHANDLEFORPRESENCE_API_LATEST 1

/**
 * Input parameters for the EOS_Sessions_CopySessionHandleForPresence function.
 */
EOS_STRUCT(EOS_Sessions_CopySessionHandleForPresenceOptions, (
	/** API Version: Set this to EOS_SESSIONS_COPYSESSIONHANDLEFORPRESENCE_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user associated with the session */
	EOS_ProductUserId LocalUserId;
));

/** The most recent version of the EOS_Sessions_IsUserInSession API. */
#define EOS_SESSIONS_ISUSERINSESSION_API_LATEST 1

/**
 * Input parameters for the EOS_Sessions_IsUserInSession function.
 */
EOS_STRUCT(EOS_Sessions_IsUserInSessionOptions, (
	/** API Version: Set this to EOS_SESSIONS_ISUSERINSESSION_API_LATEST. */
	int32_t ApiVersion;
	/** Active session name to search within */
	const char* SessionName;
	/** Product User ID to search for in the session */
	EOS_ProductUserId TargetUserId;
));

/** The most recent version of the EOS_Sessions_DumpSessionState API. */
#define EOS_SESSIONS_DUMPSESSIONSTATE_API_LATEST 1

/**
 * Input parameters for the EOS_Sessions_DumpSessionState function.
 */
EOS_STRUCT(EOS_Sessions_DumpSessionStateOptions, (
	/** API Version: Set this to EOS_SESSIONS_DUMPSESSIONSTATE_API_LATEST. */
	int32_t ApiVersion;
	/** Name of the session */
	const char* SessionName;
));

#pragma pack(pop)

```

`eac/sdk/Include/eos_stats.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_stats_types.h"

/**
 * The Stats Interface manages user stats like number of items collected, fastest completion time for a level, number of wins/losses, number of times that a user has performed a certain action, and so on.
 * You can use stats to determine when to unlock achievements and how to use rank users in leaderboards.
 * All Stats Interface calls take a handle of type EOS_HStats as the first parameter.
 * This handle can be retrieved from an EOS_HPlatform handle by using the EOS_Platform_GetStatsInterface function.
 * 
 * @see EOS_Platform_GetStatsInterface
 */

/**
 * Ingest a stat by the amount specified in Options.
 * When the operation is complete and the delegate is triggered the stat will be uploaded to the backend to be processed.
 * The stat may not be updated immediately and an achievement using the stat may take a while to be unlocked once the stat has been uploaded.
 *
 * @param Options Structure containing information about the stat we're ingesting.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param CompletionDelegate This function is called when the ingest stat operation completes.
 *
 * @return EOS_Success if the operation completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_InvalidUser if target user ID is missing or incorrect
 */
EOS_DECLARE_FUNC(void) EOS_Stats_IngestStat(EOS_HStats Handle, const EOS_Stats_IngestStatOptions* Options, void* ClientData, const EOS_Stats_OnIngestStatCompleteCallback CompletionDelegate);

/**
 * Query for a list of stats for a specific player.
 *
 * @param Options Structure containing information about the player whose stats we're retrieving.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate This function is called when the query player stats operation completes.
 *
 * @return EOS_Success if the operation completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_InvalidUser if target user ID is missing or incorrect
 */
EOS_DECLARE_FUNC(void) EOS_Stats_QueryStats(EOS_HStats Handle, const EOS_Stats_QueryStatsOptions* Options, void* ClientData, const EOS_Stats_OnQueryStatsCompleteCallback CompletionDelegate);

/**
 * Fetch the number of stats that are cached locally.
 *
 * @param Options The Options associated with retrieving the stat count
 *
 * @see EOS_Stats_CopyStatByIndex
 *
 * @return Number of stats or 0 if there is an error
 */
EOS_DECLARE_FUNC(uint32_t) EOS_Stats_GetStatsCount(EOS_HStats Handle, const EOS_Stats_GetStatCountOptions* Options);

/**
 * Fetches a stat from a given index. Use EOS_Stats_Stat_Release when finished with the data.
 *
 * @param Options Structure containing the Product User ID and index being accessed
 * @param OutStat The stat data for the given index, if it exists and is valid
 *
 * @see EOS_Stats_Stat_Release
 *
 * @return EOS_Success if the information is available and passed out in OutStat
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the stat is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Stats_CopyStatByIndex(EOS_HStats Handle, const EOS_Stats_CopyStatByIndexOptions* Options, EOS_Stats_Stat ** OutStat);

/**
 * Fetches a stat from cached stats by name. Use EOS_Stats_Stat_Release when finished with the data.
 *
 * @param Options Structure containing the Product User ID and name being accessed
 * @param OutStat The stat data for the given name, if it exists and is valid
 *
 * @see EOS_Stats_Stat_Release
 *
 * @return EOS_Success if the information is available and passed out in OutStat
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the stat is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Stats_CopyStatByName(EOS_HStats Handle, const EOS_Stats_CopyStatByNameOptions* Options, EOS_Stats_Stat ** OutStat);

```

`eac/sdk/Include/eos_stats_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

EXTERN_C typedef struct EOS_StatsHandle* EOS_HStats;

/** The most recent version of the EOS_Stats_IngestData struct. */
#define EOS_STATS_INGESTDATA_API_LATEST 1

/**
 * Contains information about a single stat to ingest.
 */
EOS_STRUCT(EOS_Stats_IngestData, (
	/** API Version: Set this to EOS_STATS_INGESTDATA_API_LATEST. */
	int32_t ApiVersion;
	/** The name of the stat to ingest. */
	const char* StatName;
	/** The amount to ingest the stat. */
	int32_t IngestAmount;
));

/** Maximum number of stats that can be ingested in a single EOS_Stats_IngestStat operation. */
#define EOS_STATS_MAX_INGEST_STATS 3000

/** The most recent version of the EOS_Stats_IngestStat struct. */
#define EOS_STATS_INGESTSTAT_API_LATEST 3

/**
 * Input parameters for the EOS_Stats_IngestStat function.
 */
EOS_STRUCT(EOS_Stats_IngestStatOptions, (
	/** API Version: Set this to EOS_STATS_INGESTSTAT_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user requesting the ingest.  Set to null for dedicated server. */
	EOS_ProductUserId LocalUserId;
	/** Stats to ingest. */
	const EOS_Stats_IngestData* Stats;
	/** The number of stats to ingest, may not exceed EOS_STATS_MAX_INGEST_STATS. */
	uint32_t StatsCount;
	/** The Product User ID for the user whose stat is being ingested. */
	EOS_ProductUserId TargetUserId;
));

/**
 * Data containing the result information for an ingest stat request.
 */
EOS_STRUCT(EOS_Stats_IngestStatCompleteCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned for a successful request, other codes indicate an error. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Stats_IngestStat. */
	void* ClientData;
	/** The Product User ID for the user requesting the ingest */
	EOS_ProductUserId LocalUserId;
	/** The Product User ID for the user whose stat is being ingested */
	EOS_ProductUserId TargetUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Stats_IngestStat
 * @param Data A EOS_Stats_IngestStatCompleteCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Stats_OnIngestStatCompleteCallback, const EOS_Stats_IngestStatCompleteCallbackInfo* Data);


/** Maximum number of stats that can be queried in a single EOS_Stats_QueryStats operation. */
#define EOS_STATS_MAX_QUERY_STATS 1000

/** The most recent version of the EOS_Stats_QueryStats struct. */
#define EOS_STATS_QUERYSTATS_API_LATEST 3

/**
 * Input parameters for the EOS_Stats_QueryStats function.
 */
EOS_STRUCT(EOS_Stats_QueryStatsOptions, (
	/** API Version: Set this to EOS_STATS_QUERYSTATS_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user requesting the stats. Set to null for dedicated server. */
	EOS_ProductUserId LocalUserId;
	/** If not EOS_STATS_TIME_UNDEFINED then this is the POSIX timestamp for start time (Optional). */
	int64_t StartTime;
	/** If not EOS_STATS_TIME_UNDEFINED then this is the POSIX timestamp for end time (Optional). */
	int64_t EndTime;
	/** An array of stat names to query for (Optional). */
	const char** StatNames;
	/** The number of stat names included in query (Optional), may not exceed EOS_STATS_MAX_QUERY_STATS. */
	uint32_t StatNamesCount;
	/** The Product User ID for the user whose stats are being retrieved */
	EOS_ProductUserId TargetUserId;
));

/** Timestamp value representing an undefined StartTime or EndTime for EOS_Stats_Stat */
#define EOS_STATS_TIME_UNDEFINED -1

/** The most recent version of the EOS_Stats_Stat struct. */
#define EOS_STATS_STAT_API_LATEST 1

/**
 * Contains information about a single player stat.
 */
EOS_STRUCT(EOS_Stats_Stat, (
	/** API Version: Set this to EOS_STATS_STAT_API_LATEST. */
	int32_t ApiVersion;
	/** Name of the stat. */
	const char* Name;
	/** If not EOS_STATS_TIME_UNDEFINED then this is the POSIX timestamp for start time. */
	int64_t StartTime;
	/** If not EOS_STATS_TIME_UNDEFINED then this is the POSIX timestamp for end time. */
	int64_t EndTime;
	/** Current value for the stat. */
	int32_t Value;
));

/** The most recent version of the EOS_Stats_GetStatsCount API. */
#define EOS_STATS_GETSTATSCOUNT_API_LATEST 1

/** DEPRECATED! Use EOS_STATS_GETSTATSCOUNT_API_LATEST instead. */
#define EOS_STATS_GETSTATCOUNT_API_LATEST EOS_STATS_GETSTATSCOUNT_API_LATEST

/**
 * Input parameters for the EOS_Stats_GetStatsCount function.
 */
EOS_STRUCT(EOS_Stats_GetStatCountOptions, (
	/** API Version: Set this to EOS_STATS_GETSTATSCOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID for the user whose stats are being counted */
	EOS_ProductUserId TargetUserId;
));

/** The most recent version of the EOS_Stats_CopyStatByIndexOptions struct. */
#define EOS_STATS_COPYSTATBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_Stats_CopyStatByIndex function.
 */
EOS_STRUCT(EOS_Stats_CopyStatByIndexOptions, (
	/** API Version: Set this to EOS_STATS_COPYSTATBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user who owns the stat */
	EOS_ProductUserId TargetUserId;
	/** Index of the stat to retrieve from the cache */
	uint32_t StatIndex;
));

/** The most recent version of the EOS_Stats_CopyStatByNameOptions struct. */
#define EOS_STATS_COPYSTATBYNAME_API_LATEST 1

/**
 * Input parameters for the EOS_Stats_CopyStatByName function.
 */
EOS_STRUCT(EOS_Stats_CopyStatByNameOptions, (
	/** API Version: Set this to EOS_STATS_COPYSTATBYNAME_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user who owns the stat */
	EOS_ProductUserId TargetUserId;
	/** Name of the stat to retrieve from the cache */
	const char* Name;
));

/**
 * Release the memory associated with a stat. This must be called on data retrieved from EOS_Stats_CopyStatByIndex or EOS_Stats_CopyStatByName.
 *
 * @param Stat - The stat data to release.
 *
 * @see EOS_Stats_Stat
 * @see EOS_Stats_CopyStatByIndex
 * @see EOS_Stats_CopyStatByName
 */
EOS_DECLARE_FUNC(void) EOS_Stats_Stat_Release(EOS_Stats_Stat* Stat);

/**
 * Data containing the result information for querying a player's stats request.
 */
EOS_STRUCT(EOS_Stats_OnQueryStatsCompleteCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Stats_QueryStats */
	void* ClientData;
	/** The Product User ID of the user who initiated this request */
	EOS_ProductUserId LocalUserId;
	/** The Product User ID whose stats which were retrieved */
	EOS_ProductUserId TargetUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Stats_QueryStats
 *
 * @param Data A EOS_Stats_OnQueryStatsCompleteCallbackInfo containing the output information and result
 *
 * @see EOS_Stats_Stat_Release
 */
EOS_DECLARE_CALLBACK(EOS_Stats_OnQueryStatsCompleteCallback, const EOS_Stats_OnQueryStatsCompleteCallbackInfo* Data);

#pragma pack(pop)

```

`eac/sdk/Include/eos_titlestorage.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_titlestorage_types.h"

/**
 * The following EOS_TitleStorage_* functions allow you to query metadata for available files from title storage as well as download and read their contents.
 */

/**
 * Query a specific file's metadata, such as file names, size, and a MD5 hash of the data. This is not required before a file may be opened. Once a file has
 * been queried, its metadata will be available by the EOS_TitleStorage_CopyFileMetadataAtIndex and EOS_TitleStorage_CopyFileMetadataByFilename functions.
 *
 * @param Options Object containing properties related to which user is querying files, and what file is being queried
 * @param ClientData Optional pointer to help clients track this request, that is returned in the completion callback
 * @param CompletionCallback This function is called when the query operation completes
 *
 * @see EOS_TitleStorage_GetFileMetadataCount
 * @see EOS_TitleStorage_CopyFileMetadataAtIndex
 * @see EOS_TitleStorage_CopyFileMetadataByFilename
 */
EOS_DECLARE_FUNC(void) EOS_TitleStorage_QueryFile(EOS_HTitleStorage Handle, const EOS_TitleStorage_QueryFileOptions* Options, void* ClientData, const EOS_TitleStorage_OnQueryFileCompleteCallback CompletionCallback);

/**
 * Query the file metadata, such as file names, size, and a MD5 hash of the data, for all files available for current user based on their settings (such as game role) and tags provided.
 * This is not required before a file can be downloaded by name.
 *
 * @param Options Object containing properties related to which user is querying files and the list of tags
 * @param ClientData Optional pointer to help clients track this request, that is returned in the completion callback
 * @param CompletionCallback This function is called when the query operation completes
 *
 */
EOS_DECLARE_FUNC(void) EOS_TitleStorage_QueryFileList(EOS_HTitleStorage Handle, const EOS_TitleStorage_QueryFileListOptions* Options, void* ClientData, const EOS_TitleStorage_OnQueryFileListCompleteCallback CompletionCallback);

/**
 * Create a cached copy of a file's metadata by filename. The metadata will be for the last retrieved or successfully saved version, and will not include any changes that have not
 * completed writing. The returned pointer must be released by the user when no longer needed.
 *
 * @param Options Object containing properties related to which user is requesting metadata, and for which filename
 * @param OutMetadata A copy of the FileMetadata structure will be set if successful.  This data must be released by calling EOS_TitleStorage_FileMetadata_Release.
 * @return EOS_Success if the metadata is currently cached, otherwise an error result explaining what went wrong
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_TitleStorage_CopyFileMetadataByFilename(EOS_HTitleStorage Handle, const EOS_TitleStorage_CopyFileMetadataByFilenameOptions* Options, EOS_TitleStorage_FileMetadata ** OutMetadata);

/**
 * Get the count of files we have previously queried information for and files we have previously read from / written to.
 *
 * @param Options Object containing properties related to which user is requesting the metadata count
 * @return If successful, the count of metadata currently cached. Returns 0 on failure.
 *
 * @see EOS_TitleStorage_CopyFileMetadataAtIndex
 */
EOS_DECLARE_FUNC(uint32_t) EOS_TitleStorage_GetFileMetadataCount(EOS_HTitleStorage Handle, const EOS_TitleStorage_GetFileMetadataCountOptions* Options);

/**
 * Get the cached copy of a file's metadata by index. The metadata will be for the last retrieved version. The returned pointer must be released by the user when no longer needed.
 *
 * @param Options Object containing properties related to which user is requesting metadata, and at what index
 * @param OutMetadata A copy of the FileMetadata structure will be set if successful.  This data must be released by calling EOS_TitleStorage_FileMetadata_Release.
 * @return EOS_Success if the requested metadata is currently cached, otherwise an error result explaining what went wrong.
 *
 * @see EOS_TitleStorage_GetFileMetadataCount
 * @see EOS_TitleStorage_FileMetadata_Release
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_TitleStorage_CopyFileMetadataAtIndex(EOS_HTitleStorage Handle, const EOS_TitleStorage_CopyFileMetadataAtIndexOptions* Options, EOS_TitleStorage_FileMetadata ** OutMetadata);

/**
 * Retrieve the contents of a specific file, potentially downloading the contents if we do not have a local copy, from the cloud. This request will occur asynchronously, potentially over
 * multiple frames. All callbacks for this function will come from the same thread that the SDK is ticked from. If specified, the FileTransferProgressCallback will always be called at
 * least once if the request is started successfully.
 *
 * @param Options Object containing properties related to which user is opening the file, what the file's name is, and related mechanisms for copying the data
 * @param ClientData Optional pointer to help clients track this request, that is returned in associated callbacks
 * @param CompletionCallback This function is called when the read operation completes
 * @return A valid Title Storage File Request handle if successful, or NULL otherwise. Data contained in the completion callback will have more detailed information about issues with the request in failure cases. This handle must be released when it is no longer needed
 *
 * @see EOS_TitleStorageFileTransferRequest_Release
 */
EOS_DECLARE_FUNC(EOS_HTitleStorageFileTransferRequest) EOS_TitleStorage_ReadFile(EOS_HTitleStorage Handle, const EOS_TitleStorage_ReadFileOptions* Options, void* ClientData, const EOS_TitleStorage_OnReadFileCompleteCallback CompletionCallback);

/**
 * Clear previously cached file data. This operation will be done asynchronously. All cached files except those corresponding to the transfers in progress will be removed.
 * Warning: Use this with care. Cache system generally tries to clear old and unused cached files from time to time. Unnecessarily clearing cache can degrade performance as SDK will have to re-download data.
 *
 * @param Options Object containing properties related to which user is deleting cache
 * @param ClientData Optional pointer to help clients track this request, that is returned in associated callbacks
 * @param CompletionCallback This function is called when the delete cache operation completes
 * @return EOS_Success if the operation was started correctly, otherwise an error result explaining what went wrong
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_TitleStorage_DeleteCache(EOS_HTitleStorage Handle, const EOS_TitleStorage_DeleteCacheOptions* Options, void* ClientData, const EOS_TitleStorage_OnDeleteCacheCompleteCallback CompletionCallback);

/**
 * Below are helper functions to retrieve information about a file request handle, or to attempt to cancel a request in progress.
 */

/**
 * Get the current state of a file request.
 *
 * @return EOS_Success if complete and successful, EOS_RequestInProgress if the request is still in progress, or another state for failure.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_TitleStorageFileTransferRequest_GetFileRequestState(EOS_HTitleStorageFileTransferRequest Handle);

/**
 * Get the file name of the file this request is for. OutStringLength will always be set to the string length of the file name if it is not NULL.
 *
 * @param FilenameStringBufferSizeBytes The maximum number of bytes that can be written to OutStringBuffer
 * @param OutStringBuffer The buffer to write the NULL-terminated utf8 file name into, if successful
 * @param OutStringLength How long the file name is (not including null terminator)
 * @return EOS_Success if the file name was successfully written to OutFilenameBuffer, a failure result otherwise
 *
 * @see EOS_TITLESTORAGE_FILENAME_MAX_LENGTH_BYTES
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_TitleStorageFileTransferRequest_GetFilename(EOS_HTitleStorageFileTransferRequest Handle, uint32_t FilenameStringBufferSizeBytes, char* OutStringBuffer, int32_t* OutStringLength);

/**
 * Attempt to cancel this file request in progress. This is a best-effort command and is not guaranteed to be successful if the request has completed before this function is called.
 *
 * @return EOS_Success if cancel is successful, EOS_NoChange if request had already completed (can't be canceled), EOS_AlreadyPending if it's already been canceled before (this is a final state for canceled request and won't change over time).
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_TitleStorageFileTransferRequest_CancelRequest(EOS_HTitleStorageFileTransferRequest Handle);

```

`eac/sdk/Include/eos_titlestorage_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

/** Maximum File Name Length in bytes */
#define EOS_TITLESTORAGE_FILENAME_MAX_LENGTH_BYTES 64

EXTERN_C typedef struct EOS_TitleStorageHandle* EOS_HTitleStorage;

/** The most recent version of the EOS_TitleStorage_FileMetadata API. */
#define EOS_TITLESTORAGE_FILEMETADATA_API_LATEST 2

/**
 * Metadata information for a specific file
 */
EOS_STRUCT(EOS_TitleStorage_FileMetadata, (
	/** API Version: Set this to EOS_TITLESTORAGE_FILEMETADATA_API_LATEST. */
	int32_t ApiVersion;
	/** The total size of the file in bytes (Includes file header in addition to file contents). */
	uint32_t FileSizeBytes;
	/** The MD5 Hash of the entire file (including additional file header), in hex digits */
	const char* MD5Hash;
	/** The file's name */
	const char* Filename;
	/** The size of data (payload) in file in unencrypted (original) form.  */
	uint32_t UnencryptedDataSizeBytes;
));

/**
 * Free the memory used by the file metadata
 */
EOS_DECLARE_FUNC(void) EOS_TitleStorage_FileMetadata_Release(EOS_TitleStorage_FileMetadata* FileMetadata);

/** The most recent version of the EOS_TitleStorage_QueryFileOptions API. */
#define EOS_TITLESTORAGE_QUERYFILEOPTIONS_API_LATEST 1

/**
 * Input data for the EOS_TitleStorage_QueryFile function
 */
EOS_STRUCT(EOS_TitleStorage_QueryFileOptions, (
	/** API Version: Set this to EOS_TITLESTORAGE_QUERYFILEOPTIONS_API_LATEST. */
	int32_t ApiVersion;
	/** Product User ID of the local user requesting file metadata (optional) */
	EOS_ProductUserId LocalUserId;
	/** The requested file's name */
	const char* Filename;
));

/**
 * Structure containing information about a query file request
 */
EOS_STRUCT(EOS_TitleStorage_QueryFileCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned for a successful request, other codes indicate an error */
	EOS_EResult ResultCode;
	/** Client-specified data passed into the file query request */
	void* ClientData;
	/** Product User ID of the local user who initiated this request (optional, will only be present in case it was provided during operation start) */
	EOS_ProductUserId LocalUserId;
));

/**
 * Callback for when EOS_TitleStorage_QueryFile completes
 */
EOS_DECLARE_CALLBACK(EOS_TitleStorage_OnQueryFileCompleteCallback, const EOS_TitleStorage_QueryFileCallbackInfo* Data);

/** The most recent version of the EOS_TitleStorage_QueryFileListOptions API. */
#define EOS_TITLESTORAGE_QUERYFILELISTOPTIONS_API_LATEST 1

/**
 * Input data for the EOS_TitleStorage_QueryFileList function
 */
EOS_STRUCT(EOS_TitleStorage_QueryFileListOptions, (
	/** API Version: Set this to EOS_TITLESTORAGE_QUERYFILELISTOPTIONS_API_LATEST. */
	int32_t ApiVersion;
	/** Product User ID of the local user who requested file metadata (optional) */
	EOS_ProductUserId LocalUserId;
	/** List of tags to use for lookup. */
	const char* const* ListOfTags;
	/** Number of tags specified in ListOfTags */
	uint32_t ListOfTagsCount;
));

/**
 * Structure containing information about a query file list request
 */
EOS_STRUCT(EOS_TitleStorage_QueryFileListCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned for a successful request, other codes indicate an error */
	EOS_EResult ResultCode;
	/** Client-specified data passed into the file query request */
	void* ClientData;
	/** Product User ID of the local user who initiated this request (optional, will only be present in case it was provided during operation start) */
	EOS_ProductUserId LocalUserId;
	/** A count of files that were found, if successful */
	uint32_t FileCount;
));

/**
 * Callback for when EOS_TitleStorage_QueryFileList completes
 */
EOS_DECLARE_CALLBACK(EOS_TitleStorage_OnQueryFileListCompleteCallback, const EOS_TitleStorage_QueryFileListCallbackInfo* Data);

/** The most recent version of the EOS_TitleStorage_GetFileMetadataCountOptions API. */
#define EOS_TITLESTORAGE_GETFILEMETADATACOUNTOPTIONS_API_LATEST 1

/**
 * Input data for the EOS_TitleStorage_GetFileMetadataCount function
 */
EOS_STRUCT(EOS_TitleStorage_GetFileMetadataCountOptions, (
	/** API Version: Set this to EOS_TITLESTORAGE_GETFILEMETADATACOUNTOPTIONS_API_LATEST. */
	int32_t ApiVersion;
	/** Product User ID of the local user who is requesting file metadata (optional) */
	EOS_ProductUserId LocalUserId;
));

/** The most recent version of the EOS_TitleStorage_CopyFileMetadataAtIndexOptions API. */
#define EOS_TITLESTORAGE_COPYFILEMETADATAATINDEXOPTIONS_API_LATEST 1

/**
 * Input data for the CopyFileMetadataAtIndex function
 */
EOS_STRUCT(EOS_TitleStorage_CopyFileMetadataAtIndexOptions, (
	/** API Version: Set this to EOS_TITLESTORAGE_COPYFILEMETADATAATINDEXOPTIONS_API_LATEST. */
	int32_t ApiVersion;
	/** Product User ID of the local user who is requesting file metadata (optional) */
	EOS_ProductUserId LocalUserId;
	/** The index to get data for */
	uint32_t Index;
));

/** The most recent version of the EOS_TitleStorage_CopyFileMetadataByFilenameOptions API. */
#define EOS_TITLESTORAGE_COPYFILEMETADATABYFILENAMEOPTIONS_API_LATEST 1

/**
 * Input data for the CopyFileMetadataByFilename function
 */
EOS_STRUCT(EOS_TitleStorage_CopyFileMetadataByFilenameOptions, (
	/** API Version: Set this to EOS_TITLESTORAGE_COPYFILEMETADATABYFILENAMEOPTIONS_API_LATEST. */
	int32_t ApiVersion;
	/** Product User ID of the local user who is requesting file metadata (optional) */
	EOS_ProductUserId LocalUserId;
	/** The file's name to get data for */
	const char* Filename;
));

/**
 * Handle type to a File Request
 */
EXTERN_C typedef struct EOS_TitleStorageFileTransferRequestHandle* EOS_HTitleStorageFileTransferRequest;

/**
 * Free the memory used by a cloud-storage file request handle. This will not cancel a request in progress.
 */
EOS_DECLARE_FUNC(void) EOS_TitleStorageFileTransferRequest_Release(EOS_HTitleStorageFileTransferRequest TitleStorageFileTransferHandle);

/**
 * Structure containing the information about a file transfer in progress (or one that has completed)
 */
EOS_STRUCT(EOS_TitleStorage_FileTransferProgressCallbackInfo, (
	/** Client-specified data passed into the file request */
	void* ClientData;
	/** Product User ID of the local user who initiated this request (optional, will only be present in case it was provided during operation start) */
	EOS_ProductUserId LocalUserId;
	/** The file name of the file being transferred */
	const char* Filename;
	/** Amount of bytes transferred so far in this request, out of TotalFileSizeBytes */
	uint32_t BytesTransferred;
	/** The total size of the file being transferred (Includes file header in addition to file contents, can be slightly more than expected) */
	uint32_t TotalFileSizeBytes;
));

/**
 * Callback for when there is a progress update for a file transfer in progress
 */
EOS_DECLARE_CALLBACK(EOS_TitleStorage_OnFileTransferProgressCallback, const EOS_TitleStorage_FileTransferProgressCallbackInfo* Data);

/**
 * Return results for EOS_TitleStorage_OnReadFileDataCallback callbacks
 */
EOS_ENUM(EOS_TitleStorage_EReadResult,
	/** Signifies the data was read successfully, and we should continue to the next chunk if possible */
	EOS_TS_RR_ContinueReading = 1,
	/** Signifies there was a failure reading the data, and the request should end */
	EOS_TS_RR_FailRequest = 2,
	/** Signifies the request should be cancelled, but not due to an error */
	EOS_TS_RR_CancelRequest = 3
);

/**
 * Structure containing data for a chunk of a file being read
 */
EOS_STRUCT(EOS_TitleStorage_ReadFileDataCallbackInfo, (
	/** Client-specified data passed into the file request */
	void* ClientData;
	/** Product User ID of the local user who initiated this request (optional, will only be present in case it was provided during operation start) */
	EOS_ProductUserId LocalUserId;
	/** The file name being read */
	const char* Filename;
	/** The total file size of the file being read */
	uint32_t TotalFileSizeBytes;
	/** Is this chunk the last chunk of data? */
	EOS_Bool bIsLastChunk;
	/** The length of DataChunk in bytes that can be safely read */
	uint32_t DataChunkLengthBytes;
	/** Pointer to the start of data to be read */
	const void* DataChunk;
));

/**
 * Callback for when we have data ready to be read from the requested file. It is undefined how often this will be called during a single tick.
 *
 * @param Data Struct containing a chunk of data to read, as well as some metadata for the file being read
 * @return The result of the read operation. If this value is not EOS_TS_RR_ContinueReading, this callback will not be called again for the same request
 */
EOS_DECLARE_CALLBACK_RETVALUE(EOS_TitleStorage_EReadResult, EOS_TitleStorage_OnReadFileDataCallback, const EOS_TitleStorage_ReadFileDataCallbackInfo* Data);

/** The most recent version of the EOS_TitleStorage_ReadFileOptions API. */
#define EOS_TITLESTORAGE_READFILEOPTIONS_API_LATEST 1

/**
 * Input data for the EOS_TitleStorage_ReadFile function
 */
EOS_STRUCT(EOS_TitleStorage_ReadFileOptions, (
	/** API Version: Set this to EOS_TITLESTORAGE_READFILEOPTIONS_API_LATEST. */
	int32_t ApiVersion;
	/** Product User ID of the local user who is reading the requested file (optional) */
	EOS_ProductUserId LocalUserId;
	/** The file name to read; this file must already exist */
	const char* Filename;
	/** The maximum amount of data in bytes should be available to read in a single EOS_TitleStorage_OnReadFileDataCallback call */
	uint32_t ReadChunkLengthBytes;
	/** Callback function to handle copying read data */
	EOS_TitleStorage_OnReadFileDataCallback ReadFileDataCallback;
	/** Optional callback function to be informed of download progress, if the file is not already locally cached. If set, this will be called at least once before completion if the request is successfully started */
	EOS_TitleStorage_OnFileTransferProgressCallback FileTransferProgressCallback;
));

/**
 * Structure containing the result of a read file request
 */
EOS_STRUCT(EOS_TitleStorage_ReadFileCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned for a successful request, other codes indicate an error */
	EOS_EResult ResultCode;
	/** Client-specified data passed into the file read request */
	void* ClientData;
	/** Product User ID of the local user who initiated this request (optional, will only be present in case it was provided during operation start) */
	EOS_ProductUserId LocalUserId;
	/** The filename of the file that has been finished reading */
	const char* Filename;
));

/**
 * Callback for when EOS_TitleStorage_ReadFile completes
 */
EOS_DECLARE_CALLBACK(EOS_TitleStorage_OnReadFileCompleteCallback, const EOS_TitleStorage_ReadFileCallbackInfo* Data);

/** The most recent version of the EOS_TitleStorage_DeleteCacheOptions API. */
#define EOS_TITLESTORAGE_DELETECACHEOPTIONS_API_LATEST 1

/**
 * Input data for the EOS_TitleStorage_DeleteCache function
 */
EOS_STRUCT(EOS_TitleStorage_DeleteCacheOptions, (
	/** API Version: Set this to EOS_TITLESTORAGE_DELETECACHEOPTIONS_API_LATEST. */
	int32_t ApiVersion;
	/** Product User ID of the local user who is deleting his cache (optional) */
	EOS_ProductUserId LocalUserId;
));

/**
 * Structure containing the result of a delete cache operation
 */
EOS_STRUCT(EOS_TitleStorage_DeleteCacheCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned for a successful request, other codes indicate an error */
	EOS_EResult ResultCode;
	/** Client-specified data passed into the delete cache request */
	void* ClientData;
	/** Product User ID of the local user who initiated this request (optional, will only be present in case it was provided during operation start) */
	EOS_ProductUserId LocalUserId;
));

/** 
 * Callback for when EOS_TitleStorage_DeleteCache completes
 */
EOS_DECLARE_CALLBACK(EOS_TitleStorage_OnDeleteCacheCompleteCallback, const EOS_TitleStorage_DeleteCacheCallbackInfo* Data);

#pragma pack(pop)
```

`eac/sdk/Include/eos_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

EXTERN_C typedef struct EOS_PlatformHandle* EOS_HPlatform;

/** Client credentials. */
EOS_STRUCT(EOS_Platform_ClientCredentials, (
	/** Client ID of the service permissions entry. Set to NULL if no service permissions are used. */
	const char* ClientId;
	/** Client secret for accessing the set of permissions. Set to NULL if no service permissions are used. */
	const char* ClientSecret;
));

/** The most recent version of the EOS_Platform_RTCOptions API. */
#define EOS_PLATFORM_RTCOPTIONS_API_LATEST 1

/** Platform RTC options. */
EOS_STRUCT(EOS_Platform_RTCOptions, (
	/** API Version: Set this to EOS_PLATFORM_RTCOPTIONS_API_LATEST. */
	int32_t ApiVersion;
	/**
	 * This field is for platform specific initialization if any.
	 *
	 * If provided then the structure will be located in <System>/eos_<System>.h.
	 * The structure will be named EOS_<System>_RTCOptions.
	 */
	void* PlatformSpecificOptions;
));


#define EOS_COUNTRYCODE_MAX_LENGTH 4
#define EOS_COUNTRYCODE_MAX_BUFFER_LEN (EOS_COUNTRYCODE_MAX_LENGTH + 1)
#define EOS_LOCALECODE_MAX_LENGTH 9
#define EOS_LOCALECODE_MAX_BUFFER_LEN (EOS_LOCALECODE_MAX_LENGTH + 1)

#define EOS_PLATFORM_OPTIONS_API_LATEST 11

/* Platform Creation Flags used in EOS_Platform_Create */

/** A bit that indicates the SDK is being loaded in a game editor, like Unity or UE4 Play-in-Editor */
#define EOS_PF_LOADING_IN_EDITOR				0x00001
/** A bit that indicates the SDK should skip initialization of the overlay, which is used by the in-app purchase flow and social overlay. This bit is implied by EOS_PF_LOADING_IN_EDITOR */
#define EOS_PF_DISABLE_OVERLAY					0x00002
/** A bit that indicates the SDK should skip initialization of the social overlay, which provides an overlay UI for social features. This bit is implied by EOS_PF_LOADING_IN_EDITOR or EOS_PF_DISABLE_OVERLAY */
#define EOS_PF_DISABLE_SOCIAL_OVERLAY			0x00004
/** A reserved bit */
#define EOS_PF_RESERVED1						0x00008
/** A bit that indicates your game would like to opt-in to experimental Direct3D 9 support for the overlay. This flag is only relevant on Windows */
#define EOS_PF_WINDOWS_ENABLE_OVERLAY_D3D9		0x00010
/** A bit that indicates your game would like to opt-in to experimental Direct3D 10 support for the overlay. This flag is only relevant on Windows */
#define EOS_PF_WINDOWS_ENABLE_OVERLAY_D3D10		0x00020
/** A bit that indicates your game would like to opt-in to experimental OpenGL support for the overlay. This flag is only relevant on Windows */
#define EOS_PF_WINDOWS_ENABLE_OVERLAY_OPENGL	0x00040

/** Platform options for EOS_Platform_Create. */
EOS_STRUCT(EOS_Platform_Options, (
	/** API Version: Set this to EOS_PLATFORM_OPTIONS_API_LATEST. */
	int32_t ApiVersion;
	/** A reserved field that should always be nulled. */
	void* Reserved;
	/** The product ID for the running application, found on the dev portal */
	const char* ProductId;
	/** The sandbox ID for the running application, found on the dev portal */
	const char* SandboxId;
	/** Set of service permissions associated with the running application */
	EOS_Platform_ClientCredentials ClientCredentials;
	/** Set this to EOS_FALSE if the application is running as a client with a local user, otherwise set to EOS_TRUE (e.g. for a dedicated game server) */
	EOS_Bool bIsServer;
	/** Used by Player Data Storage and Title Storage. Must be null initialized if unused. 256-bit Encryption Key for file encryption in hexadecimal format (64 hex chars)*/
	const char* EncryptionKey;
	/** The override country code to use for the logged in user. (EOS_COUNTRYCODE_MAX_LENGTH)*/
	const char* OverrideCountryCode;
	/** The override locale code to use for the logged in user. This follows ISO 639. (EOS_LOCALECODE_MAX_LENGTH)*/
	const char* OverrideLocaleCode;
	/** The deployment ID for the running application, found on the dev portal */
	const char* DeploymentId;
	/** Platform creation flags, e.g. EOS_PF_LOADING_IN_EDITOR. This is a bitwise-or union of the defined flags. */
	uint64_t Flags;
	/** Used by Player Data Storage and Title Storage. Must be null initialized if unused. Cache directory path. Absolute path to the folder that is going to be used for caching temporary data. The path is created if it's missing. */
	const char* CacheDirectory;
	/** 
	 * A budget, measured in milliseconds, for EOS_Platform_Tick to do its work. When the budget is met or exceeded (or if no work is available), EOS_Platform_Tick will return.
	 * This allows your game to amortize the cost of SDK work across multiple frames in the event that a lot of work is queued for processing.
	 * Zero is interpreted as "perform all available work".
	 */
	uint32_t TickBudgetInMilliseconds;
	/** RTC options. Setting to NULL will disable RTC features (e.g. voice) */
	const EOS_Platform_RTCOptions* RTCOptions;
));

#pragma pack(pop)

```

`eac/sdk/Include/eos_ui.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_ui_types.h"

/**
 * The UI Interface is used to access the Social Overlay UI.  Each UI component will have a function for
 * opening it.  All UI Interface calls take a handle of type EOS_HUI as the first parameter.
 * This handle can be retrieved from an EOS_HPlatform handle by using the EOS_Platform_GetUIInterface function.
 *
 * @see EOS_Platform_GetUIInterface
 */

/**
 * Opens the Social Overlay with a request to show the friends list.
 *
 * @param Options Structure containing the Epic Account ID of the friends list to show.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param CompletionDelegate A callback that is fired when the request to show the friends list has been sent to the Social Overlay, or on an error.
 *
 * @return EOS_Success If the Social Overlay has been notified about the request.
 *         EOS_InvalidParameters If any of the options are incorrect.
 *         EOS_NotConfigured If the Social Overlay is not properly configured.
 *         EOS_NoChange If the Social Overlay is already visible.
 */
EOS_DECLARE_FUNC(void) EOS_UI_ShowFriends(EOS_HUI Handle, const EOS_UI_ShowFriendsOptions* Options, void* ClientData, const EOS_UI_OnShowFriendsCallback CompletionDelegate);

/**
 * Hides the active Social Overlay.
 *
 * @param Options Structure containing the Epic Account ID of the browser to close.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param CompletionDelegate A callback that is fired when the request to hide the friends list has been processed, or on an error.
 *
 * @return EOS_Success If the Social Overlay has been notified about the request.
 *         EOS_InvalidParameters If any of the options are incorrect.
 *         EOS_NotConfigured If the Social Overlay is not properly configured.
 *         EOS_NoChange If the Social Overlay is already hidden.
 */
EOS_DECLARE_FUNC(void) EOS_UI_HideFriends(EOS_HUI Handle, const EOS_UI_HideFriendsOptions* Options, void* ClientData, const EOS_UI_OnHideFriendsCallback CompletionDelegate);

/**
 * Gets the friends overlay visibility.
 *
 * @param Options Structure containing the Epic Account ID of the friends Social Overlay owner.
 *
 * @return EOS_TRUE If the overlay is visible.
 */
EOS_DECLARE_FUNC(EOS_Bool) EOS_UI_GetFriendsVisible(EOS_HUI Handle, const EOS_UI_GetFriendsVisibleOptions* Options);

/**
 * Register to receive notifications when the overlay display settings are updated.
 * Newly registered handlers will always be called the next tick with the current state.
 * @note must call RemoveNotifyDisplaySettingsUpdated to remove the notification.
 *
 * @param Options Structure containing information about the request.
 * @param ClientData Arbitrary data that is passed back to you in the NotificationFn.
 * @param NotificationFn A callback that is fired when the overlay display settings are updated.
 *
 * @return handle representing the registered callback
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_UI_AddNotifyDisplaySettingsUpdated(EOS_HUI Handle, const EOS_UI_AddNotifyDisplaySettingsUpdatedOptions* Options, void* ClientData, const EOS_UI_OnDisplaySettingsUpdatedCallback NotificationFn);

/**
 * Unregister from receiving notifications when the overlay display settings are updated.
 *
 * @param Id Handle representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_UI_RemoveNotifyDisplaySettingsUpdated(EOS_HUI Handle, EOS_NotificationId Id);

/**
 * Updates the current Toggle Friends Key.  This key can be used by the user to toggle the friends
 * overlay when available. The default value represents `Shift + F3` as `((int32_t)EOS_UIK_Shift | (int32_t)EOS_UIK_F3)`.
 * The provided key should satisfy EOS_UI_IsValidKeyCombination. The value EOS_UIK_None is specially handled
 * by resetting the key binding to the system default.
 *
 * @param Options Structure containing the key combination to use.
 *
 * @return EOS_Success If the overlay has been notified about the request.
 *         EOS_InvalidParameters If any of the options are incorrect.
 *         EOS_NotConfigured If the overlay is not properly configured.
 *         EOS_NoChange If the key combination did not change.
 *
 * @see EOS_UI_IsValidKeyCombination
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_UI_SetToggleFriendsKey(EOS_HUI Handle, const EOS_UI_SetToggleFriendsKeyOptions* Options);

/**
 * Returns the current Toggle Friends Key.  This key can be used by the user to toggle the friends
 * overlay when available. The default value represents `Shift + F3` as `((int32_t)EOS_UIK_Shift | (int32_t)EOS_UIK_F3)`.
 *
 * @param Options Structure containing any options that are needed to retrieve the key.
 * @return A valid key combination which represent a single key with zero or more modifier keys.
 *         EOS_UIK_None will be returned if any error occurs.
 */
EOS_DECLARE_FUNC(EOS_UI_EKeyCombination) EOS_UI_GetToggleFriendsKey(EOS_HUI Handle, const EOS_UI_GetToggleFriendsKeyOptions* Options);

/**
 * Determine if a key combination is valid. A key combinations must have a single key and at least one modifier.
 * The single key must be one of the following: F1 through F12, Space, Backspace, Escape, or Tab.
 * The modifier key must be one or more of the following: Shift, Control, or Alt.
 *
 * @param KeyCombination The key to test.
 * @return  EOS_TRUE if the provided key combination is valid.
 */
EOS_DECLARE_FUNC(EOS_Bool) EOS_UI_IsValidKeyCombination(EOS_HUI Handle, EOS_UI_EKeyCombination KeyCombination);

/**
 * Define any preferences for any display settings.
 *
 * @param Options Structure containing any options that are needed to set
 * @return EOS_Success If the overlay has been notified about the request.
 *         EOS_InvalidParameters If any of the options are incorrect.
 *         EOS_NotConfigured If the overlay is not properly configured.
 *         EOS_NoChange If the preferences did not change.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_UI_SetDisplayPreference(EOS_HUI Handle, const EOS_UI_SetDisplayPreferenceOptions* Options);

/**
 * Returns the current notification location display preference.
 * @return The current notification location display preference.
 */
EOS_DECLARE_FUNC(EOS_UI_ENotificationLocation) EOS_UI_GetNotificationLocationPreference(EOS_HUI Handle);

/**
 * Lets the SDK know that the given UI event ID has been acknowledged and should be released.
 *
 * @return An EOS_EResult is returned to indicate success or an error.
 *
 * EOS_Success is returned if the UI event ID has been acknowledged.
 * EOS_NotFound is returned if the UI event ID does not exist.
 *
 * @see EOS_Presence_JoinGameAcceptedCallbackInfo
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_UI_AcknowledgeEventId(EOS_HUI Handle, const EOS_UI_AcknowledgeEventIdOptions* Options);

```

`eac/sdk/Include/eos_ui_keys.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

// This file is not intended to be included directly. Include eos_ui_types.h instead.

/** Number of bits to shift the modifiers into the integer. */
EOS_UI_KEY_CONSTANT(EOS_UIK_, ModifierShift, 16)
/** A mask to isolate the single key. */
EOS_UI_KEY_CONSTANT(EOS_UIK_, KeyTypeMask, (1 << EOS_UIK_ModifierShift) - 1)
/** A mask to isolate the modifier keys. */
EOS_UI_KEY_CONSTANT(EOS_UIK_, ModifierMask, ~EOS_UIK_KeyTypeMask)

/** The Shift key */
EOS_UI_KEY_MODIFIER(EOS_UIK_, Shift, (1 << EOS_UIK_ModifierShift))
/** The Control key */
EOS_UI_KEY_MODIFIER(EOS_UIK_, Control, (2 << EOS_UIK_ModifierShift))
/** The Alt key */
EOS_UI_KEY_MODIFIER(EOS_UIK_, Alt, (4 << EOS_UIK_ModifierShift))
/** The Windows key on a Windows keyboard or the Command key on a Mac keyboard */
EOS_UI_KEY_MODIFIER(EOS_UIK_, Meta, (8 << EOS_UIK_ModifierShift))
EOS_UI_KEY_CONSTANT(EOS_UIK_, ValidModifierMask, (EOS_UIK_Shift | EOS_UIK_Control | EOS_UIK_Alt | EOS_UIK_Meta))

EOS_UI_KEY_ENTRY_FIRST(EOS_UIK_, None, 0)
EOS_UI_KEY_ENTRY(EOS_UIK_, Space)
EOS_UI_KEY_ENTRY(EOS_UIK_, Backspace)
EOS_UI_KEY_ENTRY(EOS_UIK_, Tab)
EOS_UI_KEY_ENTRY(EOS_UIK_, Escape)

EOS_UI_KEY_ENTRY(EOS_UIK_, PageUp)
EOS_UI_KEY_ENTRY(EOS_UIK_, PageDown)
EOS_UI_KEY_ENTRY(EOS_UIK_, End)
EOS_UI_KEY_ENTRY(EOS_UIK_, Home)
EOS_UI_KEY_ENTRY(EOS_UIK_, Insert)
EOS_UI_KEY_ENTRY(EOS_UIK_, Delete)

EOS_UI_KEY_ENTRY(EOS_UIK_, Left)
EOS_UI_KEY_ENTRY(EOS_UIK_, Up)
EOS_UI_KEY_ENTRY(EOS_UIK_, Right)
EOS_UI_KEY_ENTRY(EOS_UIK_, Down)

EOS_UI_KEY_ENTRY(EOS_UIK_, Key0)
EOS_UI_KEY_ENTRY(EOS_UIK_, Key1)
EOS_UI_KEY_ENTRY(EOS_UIK_, Key2)
EOS_UI_KEY_ENTRY(EOS_UIK_, Key3)
EOS_UI_KEY_ENTRY(EOS_UIK_, Key4)
EOS_UI_KEY_ENTRY(EOS_UIK_, Key5)
EOS_UI_KEY_ENTRY(EOS_UIK_, Key6)
EOS_UI_KEY_ENTRY(EOS_UIK_, Key7)
EOS_UI_KEY_ENTRY(EOS_UIK_, Key8)
EOS_UI_KEY_ENTRY(EOS_UIK_, Key9)

EOS_UI_KEY_ENTRY(EOS_UIK_, KeyA)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyB)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyC)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyD)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyE)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyF)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyG)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyH)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyI)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyJ)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyK)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyL)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyM)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyN)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyO)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyP)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyQ)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyR)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyS)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyT)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyU)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyV)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyW)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyX)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyY)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyZ)

EOS_UI_KEY_ENTRY(EOS_UIK_, Numpad0)
EOS_UI_KEY_ENTRY(EOS_UIK_, Numpad1)
EOS_UI_KEY_ENTRY(EOS_UIK_, Numpad2)
EOS_UI_KEY_ENTRY(EOS_UIK_, Numpad3)
EOS_UI_KEY_ENTRY(EOS_UIK_, Numpad4)
EOS_UI_KEY_ENTRY(EOS_UIK_, Numpad5)
EOS_UI_KEY_ENTRY(EOS_UIK_, Numpad6)
EOS_UI_KEY_ENTRY(EOS_UIK_, Numpad7)
EOS_UI_KEY_ENTRY(EOS_UIK_, Numpad8)
EOS_UI_KEY_ENTRY(EOS_UIK_, Numpad9)
EOS_UI_KEY_ENTRY(EOS_UIK_, NumpadAsterisk)
EOS_UI_KEY_ENTRY(EOS_UIK_, NumpadPlus)
EOS_UI_KEY_ENTRY(EOS_UIK_, NumpadMinus)
EOS_UI_KEY_ENTRY(EOS_UIK_, NumpadPeriod)
EOS_UI_KEY_ENTRY(EOS_UIK_, NumpadDivide)

EOS_UI_KEY_ENTRY(EOS_UIK_, F1)
EOS_UI_KEY_ENTRY(EOS_UIK_, F2)
EOS_UI_KEY_ENTRY(EOS_UIK_, F3)
EOS_UI_KEY_ENTRY(EOS_UIK_, F4)
EOS_UI_KEY_ENTRY(EOS_UIK_, F5)
EOS_UI_KEY_ENTRY(EOS_UIK_, F6)
EOS_UI_KEY_ENTRY(EOS_UIK_, F7)
EOS_UI_KEY_ENTRY(EOS_UIK_, F8)
EOS_UI_KEY_ENTRY(EOS_UIK_, F9)
EOS_UI_KEY_ENTRY(EOS_UIK_, F10)
EOS_UI_KEY_ENTRY(EOS_UIK_, F11)
EOS_UI_KEY_ENTRY(EOS_UIK_, F12)
EOS_UI_KEY_ENTRY(EOS_UIK_, F13)
EOS_UI_KEY_ENTRY(EOS_UIK_, F14)
EOS_UI_KEY_ENTRY(EOS_UIK_, F15)
EOS_UI_KEY_ENTRY(EOS_UIK_, F16)
EOS_UI_KEY_ENTRY(EOS_UIK_, F17)
EOS_UI_KEY_ENTRY(EOS_UIK_, F18)
EOS_UI_KEY_ENTRY(EOS_UIK_, F19)
EOS_UI_KEY_ENTRY(EOS_UIK_, F20)
EOS_UI_KEY_ENTRY(EOS_UIK_, F21)
EOS_UI_KEY_ENTRY(EOS_UIK_, F22)
EOS_UI_KEY_ENTRY(EOS_UIK_, F23)
EOS_UI_KEY_ENTRY(EOS_UIK_, F24)

EOS_UI_KEY_ENTRY(EOS_UIK_, OemPlus)
EOS_UI_KEY_ENTRY(EOS_UIK_, OemComma)
EOS_UI_KEY_ENTRY(EOS_UIK_, OemMinus)
EOS_UI_KEY_ENTRY(EOS_UIK_, OemPeriod)
/** ';' for US layout, others vary */
EOS_UI_KEY_ENTRY(EOS_UIK_, Oem1)
/** '/' for US layout, others vary */
EOS_UI_KEY_ENTRY(EOS_UIK_, Oem2)
/** '~' for US layout, others vary */
EOS_UI_KEY_ENTRY(EOS_UIK_, Oem3)
/** '[' for US layout, others vary */
EOS_UI_KEY_ENTRY(EOS_UIK_, Oem4)
/** '\' for US layout, others vary */
EOS_UI_KEY_ENTRY(EOS_UIK_, Oem5)
/** ']' for US layout, others vary */
EOS_UI_KEY_ENTRY(EOS_UIK_, Oem6)
/** '"' for US layout, others vary */
EOS_UI_KEY_ENTRY(EOS_UIK_, Oem7)
/** varies on all layouts */
EOS_UI_KEY_ENTRY(EOS_UIK_, Oem8)

/** Maximum key enumeration value. */
EOS_UI_KEY_CONSTANT_LAST(EOS_UIK_, MaxKeyType)

```

`eac/sdk/Include/eos_ui_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

/** Handle to the UI interface */
EXTERN_C typedef struct EOS_UIHandle* EOS_HUI;

/** ID representing a specific UI event. */
EXTERN_C typedef uint64_t EOS_UI_EventId;
#define EOS_UI_EVENTID_INVALID 0

/** The most recent version of the EOS_UI_ShowFriends API. */
#define EOS_UI_SHOWFRIENDS_API_LATEST 1

/**
 * Input parameters for the EOS_UI_ShowFriends function.
 */
EOS_STRUCT(EOS_UI_ShowFriendsOptions, (
	/** API Version: Set this to EOS_UI_SHOWFRIENDS_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the user whose friend list is being shown. */
	EOS_EpicAccountId LocalUserId;
));

/**
 * Output parameters for the EOS_UI_ShowFriends function.
 */
EOS_STRUCT(EOS_UI_ShowFriendsCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_UI_ShowFriends */
	void* ClientData;
	/** The Epic Account ID of the user whose friend list is being shown. */
	EOS_EpicAccountId LocalUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_UI_ShowFriends
 * @param Data A EOS_UI_ShowFriendsCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_UI_OnShowFriendsCallback, const EOS_UI_ShowFriendsCallbackInfo* Data);

/** The most recent version of the EOS_UI_HideFriends API. */
#define EOS_UI_HIDEFRIENDS_API_LATEST 1

/**
 * Input parameters for the EOS_UI_HideFriends function.
 */
EOS_STRUCT(EOS_UI_HideFriendsOptions, (
	/** API Version: Set this to EOS_UI_HIDEFRIENDS_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the user whose friend list is being shown. */
	EOS_EpicAccountId LocalUserId;
));

/**
 * Output parameters for the EOS_UI_HideFriends function.
 */
EOS_STRUCT(EOS_UI_HideFriendsCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_UI_HideFriends */
	void* ClientData;
	/** The Epic Account ID of the user whose friend list is being shown. */
	EOS_EpicAccountId LocalUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_UI_HideFriends
 * @param Data A EOS_UI_HideFriendsCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_UI_OnHideFriendsCallback, const EOS_UI_HideFriendsCallbackInfo* Data);

/** The most recent version of the EOS_UI_GetFriendsVisible API. */
#define EOS_UI_GETFRIENDSVISIBLE_API_LATEST 1

/**
 * Input parameters for the EOS_UI_GetFriendsVisible function.
 */
EOS_STRUCT(EOS_UI_GetFriendsVisibleOptions, (
	/** API Version: Set this to EOS_UI_GETFRIENDSVISIBLE_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the user whose overlay is being updated. */
	EOS_EpicAccountId LocalUserId;
));

/** The most recent version of the EOS_UI_AddNotifyDisplaySettingsUpdated API. */
#define EOS_UI_ADDNOTIFYDISPLAYSETTINGSUPDATED_API_LATEST 1

/**
 * Input parameters for the EOS_UI_AddNotifyDisplaySettingsUpdated function.
 */
EOS_STRUCT(EOS_UI_AddNotifyDisplaySettingsUpdatedOptions, (
	/** API Version: Set this to EOS_UI_ADDNOTIFYDISPLAYSETTINGSUPDATED_API_LATEST. */
	int32_t ApiVersion;
));

EOS_STRUCT(EOS_UI_OnDisplaySettingsUpdatedCallbackInfo, (
	/** Context that was passed into EOS_UI_AddNotifyDisplaySettingsUpdated */
	void* ClientData;
	/** True when any portion of the overlay is visible. */
	EOS_Bool bIsVisible;
	/** 
	 * True when the overlay has switched to exclusive input mode. 
	 * While in exclusive input mode, no keyboard or mouse input will be sent to the game.
	 */
	EOS_Bool bIsExclusiveInput;
));

/**
 * Function prototype definition for callbacks passed to EOS_UI_AddNotifyDisplaySettingsUpdated 
 * @param Data A EOS_UI_OnDisplaySettingsUpdatedCallbackInfo containing the current display state.
 */
EOS_DECLARE_CALLBACK(EOS_UI_OnDisplaySettingsUpdatedCallback, const EOS_UI_OnDisplaySettingsUpdatedCallbackInfo* Data);

/** 
 * Enum flags for storing a key combination. The low 16 bits are the key type, and modifiers are 
 * stored in the next significant bits 
 */
#define EOS_UI_KEY_CONSTANT(Prefix, Name, Value) Prefix ## Name = Value,
#define EOS_UI_KEY_MODIFIER(Prefix, Name, Value) Prefix ## Name = Value,
#define EOS_UI_KEY_ENTRY_FIRST(Prefix, Name, Value) Prefix ## Name = Value,
#define EOS_UI_KEY_ENTRY(Prefix, Name) Prefix ## Name,
#define EOS_UI_KEY_CONSTANT_LAST(Prefix, Name) Prefix ## Name 
EOS_ENUM_START(EOS_UI_EKeyCombination)
#include "eos_ui_keys.h"
EOS_ENUM_END(EOS_UI_EKeyCombination);
#undef EOS_UI_KEY_CONSTANT
#undef EOS_UI_KEY_MODIFIER
#undef EOS_UI_KEY_ENTRY_FIRST
#undef EOS_UI_KEY_ENTRY
#undef EOS_UI_KEY_CONSTANT_LAST

EOS_ENUM_BOOLEAN_OPERATORS(EOS_UI_EKeyCombination)

/** The most recent version of the EOS_UI_SetToggleFriendsKey API. */
#define EOS_UI_SETTOGGLEFRIENDSKEY_API_LATEST 1

/**
 * Input parameters for the EOS_UI_SetToggleFriendsKey function.
 */
EOS_STRUCT(EOS_UI_SetToggleFriendsKeyOptions, (
	/** API Version: Set this to EOS_UI_SETTOGGLEFRIENDSKEY_API_LATEST. */
	int32_t ApiVersion;
	/** 
	 * The new key combination which will be used to toggle the friends overlay.
	 * The combination can be any set of modifiers and one key.
	 * A value of EOS_UIK_None will cause the key to revert to the default.
	 */
	EOS_UI_EKeyCombination KeyCombination;
));

/** The most recent version of the EOS_UI_GetToggleFriendsKey API. */
#define EOS_UI_GETTOGGLEFRIENDSKEY_API_LATEST 1

/**
 * Input parameters for the EOS_UI_GetToggleFriendsKey function.
 */
EOS_STRUCT(EOS_UI_GetToggleFriendsKeyOptions, (
	/** API Version: Set this to EOS_UI_GETTOGGLEFRIENDSKEY_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Notification locations to be used to set the preference
 * for pop-up.
 *
 * @see EOS_UI_SetDisplayPreference
 */
EOS_ENUM(EOS_UI_ENotificationLocation,
	EOS_UNL_TopLeft,
	EOS_UNL_TopRight,
	EOS_UNL_BottomLeft,
	EOS_UNL_BottomRight
);

/** The most recent version of the EOS_UI_SetDisplayPreference API. */
#define EOS_UI_SETDISPLAYPREFERENCE_API_LATEST 1

/**
 * Input parameters for the EOS_UI_SetDisplayPreference function.
 */
EOS_STRUCT(EOS_UI_SetDisplayPreferenceOptions, (
	/** API Version: Set this to EOS_UI_SETDISPLAYPREFERENCE_API_LATEST. */
	int32_t ApiVersion;
	/** Preference for notification pop-up locations. */
	EOS_UI_ENotificationLocation NotificationLocation;
));


/** The most recent version of the EOS_UI_AcknowledgeEventId API. */
#define EOS_UI_ACKNOWLEDGEEVENTID_API_LATEST 1

/** DEPRECATED! Use EOS_UI_ACKNOWLEDGEEVENTID_API_LATEST instead. */
#define EOS_UI_ACKNOWLEDGECORRELATIONID_API_LATEST EOS_UI_ACKNOWLEDGEEVENTID_API_LATEST

/**
 * Input parameters for the EOS_UI_AcknowledgeEventId.
 */
EOS_STRUCT(EOS_UI_AcknowledgeEventIdOptions, (
	/** API Version: Set this to EOS_UI_ACKNOWLEDGEEVENTID_API_LATEST. */
	int32_t ApiVersion;
	/** The ID being acknowledged. */
	EOS_UI_EventId UiEventId;
	/** 
	 * The result to use for the acknowledgment. 
	 * When acknowledging EOS_Presence_JoinGameAcceptedCallbackInfo this should be the 
	 * result code from the JoinSession call.
	 */
	EOS_EResult Result;
));

/** The most recent version of the EOS_UI_ReportKeyEvent API. */
#define EOS_UI_REPORTKEYEVENT_API_LATEST 1

/**
 * Input parameters for the EOS_UI_ReportKeyEvent function.
 */
EOS_STRUCT(EOS_UI_ReportKeyEventOptions, (
	/** API Version: Set this to EOS_UI_REPORTKEYEVENT_API_LATEST. */
	int32_t ApiVersion;
	/** The input data pushed to the SDK. */
	const void* PlatformSpecificInputData;
));

/** The most recent version of the EOS_UI_PrePresent API. */
#define EOS_UI_PREPRESENT_API_LATEST 1

/**
 * Parameters for the EOS_UI_PrePresent function.
 */
EOS_STRUCT(EOS_UI_PrePresentOptions, (
	/** API Version: Set this to EOS_UI_PREPRESENT_API_LATEST. */
	int32_t ApiVersion;
	/** Platform specific data. */
	const void* PlatformSpecificData;
));

#pragma pack(pop)

```

`eac/sdk/Include/eos_userinfo.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_userinfo_types.h"

/**
 * The UserInfo Interface is used to receive user information for Epic Account IDs from the backend services and to retrieve that information once it is cached.
 * All UserInfo Interface calls take a handle of type EOS_HUserInfo as the first parameter.
 * This handle can be retrieved from a EOS_HPlatform handle by using the EOS_Platform_GetUserInfoInterface function.
 *
 * @see EOS_Platform_GetUserInfoInterface
 */

/**
 * EOS_UserInfo_QueryUserInfo is used to start an asynchronous query to retrieve information, such as display name, about another account.
 * Once the callback has been fired with a successful ResultCode, it is possible to call EOS_UserInfo_CopyUserInfo to receive an EOS_UserInfo containing the available information.
 *
 * @param Options structure containing the input parameters
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error
 *
 * @see EOS_UserInfo
 * @see EOS_UserInfo_CopyUserInfo
 * @see EOS_UserInfo_QueryUserInfoOptions
 * @see EOS_UserInfo_OnQueryUserInfoCallback
 */
EOS_DECLARE_FUNC(void) EOS_UserInfo_QueryUserInfo(EOS_HUserInfo Handle, const EOS_UserInfo_QueryUserInfoOptions* Options, void* ClientData, const EOS_UserInfo_OnQueryUserInfoCallback CompletionDelegate);

/**
 * EOS_UserInfo_QueryUserInfoByDisplayName is used to start an asynchronous query to retrieve user information by display name. This can be useful for getting the EOS_EpicAccountId for a display name.
 * Once the callback has been fired with a successful ResultCode, it is possible to call EOS_UserInfo_CopyUserInfo to receive an EOS_UserInfo containing the available information.
 *
 * @param Options structure containing the input parameters
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error
 *
 * @see EOS_UserInfo
 * @see EOS_UserInfo_CopyUserInfo
 * @see EOS_UserInfo_QueryUserInfoByDisplayNameOptions
 * @see EOS_UserInfo_OnQueryUserInfoByDisplayNameCallback
 */
EOS_DECLARE_FUNC(void) EOS_UserInfo_QueryUserInfoByDisplayName(EOS_HUserInfo Handle, const EOS_UserInfo_QueryUserInfoByDisplayNameOptions* Options, void* ClientData, const EOS_UserInfo_OnQueryUserInfoByDisplayNameCallback CompletionDelegate);

/**
 * EOS_UserInfo_QueryUserInfoByExternalAccount is used to start an asynchronous query to retrieve user information by external accounts.
 * This can be useful for getting the EOS_EpicAccountId for external accounts.
 * Once the callback has been fired with a successful ResultCode, it is possible to call CopyUserInfo to receive an EOS_UserInfo containing the available information.
 *
 * @param Options structure containing the input parameters
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error
 *
 * @see EOS_UserInfo
 * @see EOS_UserInfo_QueryUserInfoByExternalAccountOptions
 * @see EOS_UserInfo_OnQueryUserInfoByExternalAccountCallback
 */
EOS_DECLARE_FUNC(void) EOS_UserInfo_QueryUserInfoByExternalAccount(EOS_HUserInfo Handle, const EOS_UserInfo_QueryUserInfoByExternalAccountOptions* Options, void* ClientData, const EOS_UserInfo_OnQueryUserInfoByExternalAccountCallback CompletionDelegate);

/**
 * EOS_UserInfo_CopyUserInfo is used to immediately retrieve a copy of user information based on an Epic Account ID, cached by a previous call to EOS_UserInfo_QueryUserInfo.
 * If the call returns an EOS_Success result, the out parameter, OutUserInfo, must be passed to EOS_UserInfo_Release to release the memory associated with it.
 *
 * @param Options structure containing the input parameters
 * @param OutUserInfo out parameter used to receive the EOS_UserInfo structure.
 *
 * @return EOS_Success if the information is available and passed out in OutUserInfo
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *         EOS_NotFound if the user info is not locally cached. The information must have been previously cached by a call to EOS_UserInfo_QueryUserInfo
 *
 * @see EOS_UserInfo
 * @see EOS_UserInfo_CopyUserInfoOptions
 * @see EOS_UserInfo_Release
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_UserInfo_CopyUserInfo(EOS_HUserInfo Handle, const EOS_UserInfo_CopyUserInfoOptions* Options, EOS_UserInfo ** OutUserInfo);

/**
 * Fetch the number of external user infos that are cached locally.
 *
 * @param Options The options associated with retrieving the external user info count
 *
 * @see EOS_UserInfo_CopyExternalUserInfoByIndex
 *
 * @return The number of external user infos, or 0 if there is an error
 */
EOS_DECLARE_FUNC(uint32_t) EOS_UserInfo_GetExternalUserInfoCount(EOS_HUserInfo Handle, const EOS_UserInfo_GetExternalUserInfoCountOptions* Options);

/**
 * Fetches an external user info from a given index.
 *
 * @param Options Structure containing the index being accessed
 * @param OutExternalUserInfo The external user info. If it exists and is valid, use EOS_UserInfo_ExternalUserInfo_Release when finished
 *
 * @see EOS_UserInfo_ExternalUserInfo_Release
 *
 * @return EOS_Success if the information is available and passed out in OutExternalUserInfo
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the external user info is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_UserInfo_CopyExternalUserInfoByIndex(EOS_HUserInfo Handle, const EOS_UserInfo_CopyExternalUserInfoByIndexOptions* Options, EOS_UserInfo_ExternalUserInfo ** OutExternalUserInfo);

/**
 * Fetches an external user info for a given external account type.
 *
 * @param Options Structure containing the account type being accessed
 * @param OutExternalUserInfo The external user info. If it exists and is valid, use EOS_UserInfo_ExternalUserInfo_Release when finished
 *
 * @see EOS_UserInfo_ExternalUserInfo_Release
 *
 * @return EOS_Success if the information is available and passed out in OutExternalUserInfo
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the external user info is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_UserInfo_CopyExternalUserInfoByAccountType(EOS_HUserInfo Handle, const EOS_UserInfo_CopyExternalUserInfoByAccountTypeOptions* Options, EOS_UserInfo_ExternalUserInfo ** OutExternalUserInfo);

/**
 * Fetches an external user info for a given external account ID.
 *
 * @param Options Structure containing the account ID being accessed
 * @param OutExternalUserInfo The external user info. If it exists and is valid, use EOS_UserInfo_ExternalUserInfo_Release when finished
 *
 * @see EOS_UserInfo_ExternalUserInfo_Release
 *
 * @return EOS_Success if the information is available and passed out in OutExternalUserInfo
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the external user info is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_UserInfo_CopyExternalUserInfoByAccountId(EOS_HUserInfo Handle, const EOS_UserInfo_CopyExternalUserInfoByAccountIdOptions* Options, EOS_UserInfo_ExternalUserInfo ** OutExternalUserInfo);

```

`eac/sdk/Include/eos_userinfo_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

EXTERN_C typedef struct EOS_UserInfoHandle* EOS_HUserInfo;

/**
 * EOS_UserInfo_QueryUserInfo is used to start an asynchronous query to retrieve information, such as display name, about another account.
 * The following types are used to work with the API.
 */

 /** The most recent version of the EOS_UserInfo_QueryUserInfo API. */
#define EOS_USERINFO_QUERYUSERINFO_API_LATEST 1

/**
 * Input parameters for the EOS_UserInfo_QueryUserInfo function.
 */
EOS_STRUCT(EOS_UserInfo_QueryUserInfoOptions, (
	/** API Version: Set this to EOS_USERINFO_QUERYUSERINFO_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local player requesting the information */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the player whose information is being retrieved */
	EOS_EpicAccountId TargetUserId;
));

/**
 * Output parameters for the EOS_UserInfo_QueryUserInfo Function.
 */
EOS_STRUCT(EOS_UserInfo_QueryUserInfoCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_UserInfo_QueryUserInfo */
	void* ClientData;
	/** The Epic Account ID of the local player requesting the information */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the player whose information is being retrieved */
	EOS_EpicAccountId TargetUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_UserInfo_QueryUserInfo
 * @param Data A EOS_UserInfo_QueryUserInfoCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_UserInfo_OnQueryUserInfoCallback, const EOS_UserInfo_QueryUserInfoCallbackInfo* Data);


/**
 * EOS_UserInfo_QueryUserInfoByDisplayName is used to start an asynchronous query to retrieve user information by display name. This can be useful for getting the EOS_EpicAccountId for a display name.
 * The following types are used to work with the API.
 */

 /** The most recent version of the EOS_UserInfo_QueryUserInfoByDisplayName API. */
#define EOS_USERINFO_QUERYUSERINFOBYDISPLAYNAME_API_LATEST 1

/**
 * Input parameters for the EOS_UserInfo_QueryUserInfoByDisplayName function.
 */
EOS_STRUCT(EOS_UserInfo_QueryUserInfoByDisplayNameOptions, (
	/** API Version: Set this to EOS_USERINFO_QUERYUSERINFOBYDISPLAYNAME_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local player requesting the information */
	EOS_EpicAccountId LocalUserId;
	/** Display name of the player being queried */
	const char* DisplayName;
));

/**
 * Output parameters for the EOS_UserInfo_QueryUserInfoByDisplayName Function.
 */
EOS_STRUCT(EOS_UserInfo_QueryUserInfoByDisplayNameCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_UserInfo_QueryUserInfoByDisplayName */
	void* ClientData;
	/** The Epic Account ID of the local player requesting the information */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the player whose information is being retrieved */
	EOS_EpicAccountId TargetUserId;
	/** Display name of the player being queried. This memory is only valid during the scope of the callback. */
	const char* DisplayName;
));

/**
 * Function prototype definition for callbacks passed to EOS_UserInfo_QueryUserInfo
 * @param Data A EOS_UserInfo_QueryUserInfoByDisplayNameCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_UserInfo_OnQueryUserInfoByDisplayNameCallback, const EOS_UserInfo_QueryUserInfoByDisplayNameCallbackInfo* Data);


/**
 * EOS_UserInfo_QueryUserInfoByExternalAccount is used to start an asynchronous query to retrieve user information by external account type.
 * This can be useful for getting the EOS_EpicAccountId for an external account.
 * The following types are used to work with the API.
 */

 /** The most recent version of the EOS_UserInfo_QueryUserInfoByExternalAccount API. */
#define EOS_USERINFO_QUERYUSERINFOBYEXTERNALACCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_UserInfo_QueryUserInfoByExternalAccount function.
 */
EOS_STRUCT(EOS_UserInfo_QueryUserInfoByExternalAccountOptions, (
	/** API Version: Set this to EOS_USERINFO_QUERYUSERINFOBYEXTERNALACCOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local player requesting the information */
	EOS_EpicAccountId LocalUserId;
	/** External account ID of the user whose information is being retrieved */
	const char* ExternalAccountId;
	/** Account type of the external user info to query */
	EOS_EExternalAccountType AccountType;
));

/**
 * Output parameters for the EOS_UserInfo_QueryUserInfoByExternalAccount Function.
 */
EOS_STRUCT(EOS_UserInfo_QueryUserInfoByExternalAccountCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_UserInfo_QueryUserInfoByExternalAccount */
	void* ClientData;
	/** The Epic Account ID of the local player who requested the information */
	EOS_EpicAccountId LocalUserId;
	/** External account id of the user whose information has been retrieved */
	const char* ExternalAccountId;
	/** Account type of the external account id */
	EOS_EExternalAccountType AccountType;
	/** Account ID of the player whose information has been retrieved */
	EOS_EpicAccountId TargetUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_UserInfo_QueryUserInfo
 * @param Data A EOS_UserInfo_QueryUserInfoByExternalAccountCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_UserInfo_OnQueryUserInfoByExternalAccountCallback, const EOS_UserInfo_QueryUserInfoByExternalAccountCallbackInfo* Data);


/**
 * EOS_UserInfo_CopyUserInfo is used to immediately retrieve user information for an account ID, cached by a previous call to EOS_UserInfo_QueryUserInfo.
 * The following types are used to work with the API.
 */

/** The maximum length of display names, in displayable characters */
#define EOS_USERINFO_MAX_DISPLAYNAME_CHARACTERS 16

/** The maximum length of display names when encoded as UTF-8 as returned by EOS_UserInfo_CopyUserInfo. This length does not include the null terminator. */
#define EOS_USERINFO_MAX_DISPLAYNAME_UTF8_LENGTH 64

 /** The most recent version of the EOS_UserInfo_CopyUserInfo API. */
#define EOS_USERINFO_COPYUSERINFO_API_LATEST 2

/** A structure that contains the user information. These structures are created by EOS_UserInfo_CopyUserInfo and must be passed to EOS_UserInfo_Release. */
EOS_STRUCT(EOS_UserInfo, (
	/** API Version: Set this to EOS_USERINFO_COPYUSERINFO_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the user */
	EOS_EpicAccountId UserId;
	/** The name of the owner's country. This may be null */
	const char* Country;
	/** The display name. This may be null */
	const char* DisplayName;
	/** The ISO 639 language code for the user's preferred language. This may be null */
	const char* PreferredLanguage;
	/** A nickname/alias for the target user assigned by the local user. This may be null */
	const char* Nickname;
));

/**
 * Input parameters for the EOS_UserInfo_CopyUserInfo function.
 */
EOS_STRUCT(EOS_UserInfo_CopyUserInfoOptions, (
	/** API Version: Set this to EOS_USERINFO_COPYUSERINFO_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local player requesting the information */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the player whose information is being retrieved */
	EOS_EpicAccountId TargetUserId;
));

/**
 *
 * @param UserInfo - The user info structure to release
 *
 * @see EOS_UserInfo
 * @see EOS_UserInfo_CopyUserInfo
 */
EOS_DECLARE_FUNC(void) EOS_UserInfo_Release(EOS_UserInfo* UserInfo);

/** The most recent version of the EOS_UserInfo_ExternalUserInfo struct. */
#define EOS_USERINFO_EXTERNALUSERINFO_API_LATEST 1

/**
 * Contains information about a single external user info.
 */
EOS_STRUCT(EOS_UserInfo_ExternalUserInfo, (
	/** API Version: Set this to EOS_USERINFO_EXTERNALUSERINFO_API_LATEST. */
	int32_t ApiVersion;
	/** The type of the external account */
	EOS_EExternalAccountType AccountType;
	/** The ID of the external account. Can be null */
	const char* AccountId;
	/** The display name of the external account. Can be null */
	const char* DisplayName;
));

/** The most recent version of the EOS_Achievements_GetAchievementDefinitionCount API. */
#define EOS_USERINFO_GETEXTERNALUSERINFOCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_UserInfo_GetExternalUserInfoCount function.
 */
EOS_STRUCT(EOS_UserInfo_GetExternalUserInfoCountOptions, (
	/** API Version: Set this to EOS_USERINFO_GETEXTERNALUSERINFOCOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local player requesting the information */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the player whose information is being retrieved */
	EOS_EpicAccountId TargetUserId;
));

/** The most recent version of the EOS_UserInfo_CopyExternalUserInfoByIndexOptions struct. */
#define EOS_USERINFO_COPYEXTERNALUSERINFOBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_UserInfo_CopyExternalUserInfoByIndex function.
 */
EOS_STRUCT(EOS_UserInfo_CopyExternalUserInfoByIndexOptions, (
	/** API Version: Set this to EOS_USERINFO_COPYEXTERNALUSERINFOBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local player requesting the information */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the player whose information is being retrieved */
	EOS_EpicAccountId TargetUserId;
	/** Index of the external user info to retrieve from the cache */
	uint32_t Index;
));

/** The most recent version of the EOS_UserInfo_CopyExternalUserInfoByIndexOptions struct. */
#define EOS_USERINFO_COPYEXTERNALUSERINFOBYACCOUNTTYPE_API_LATEST 1

/**
 * Input parameters for the EOS_UserInfo_CopyExternalUserInfoByAccountType function.
 */
EOS_STRUCT(EOS_UserInfo_CopyExternalUserInfoByAccountTypeOptions, (
	/** API Version: Set this to EOS_USERINFO_COPYEXTERNALUSERINFOBYACCOUNTTYPE_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local player requesting the information */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the player whose information is being retrieved */
	EOS_EpicAccountId TargetUserId;
	/** Account type of the external user info to retrieve from the cache */
	EOS_EExternalAccountType AccountType;
));

/** The most recent version of the EOS_UserInfo_CopyExternalUserInfoByAccountIdOptions struct. */
#define EOS_USERINFO_COPYEXTERNALUSERINFOBYACCOUNTID_API_LATEST 1

/**
 * Input parameters for the EOS_UserInfo_CopyExternalUserInfoByAccountId function.
 */
EOS_STRUCT(EOS_UserInfo_CopyExternalUserInfoByAccountIdOptions, (
	/** API Version: Set this to EOS_USERINFO_COPYEXTERNALUSERINFOBYACCOUNTID_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local player requesting the information */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the player whose information is being retrieved */
	EOS_EpicAccountId TargetUserId;
	/** The external account ID associated with the (external) user info to retrieve from the cache; cannot be null */
	const char* AccountId;
));

/**
 * Release the memory associated with external user info. This must be called on data retrieved from
 * EOS_UserInfo_CopyExternalUserInfoByIndexOptions.
 *
 * @param ExternalUserInfo The external user info to release.
 *
 * @see EOS_UserInfo_ExternalUserInfo
 * @see EOS_UserInfo_CopyExternalUserInfoByIndex
 */
EOS_DECLARE_FUNC(void) EOS_UserInfo_ExternalUserInfo_Release(EOS_UserInfo_ExternalUserInfo* ExternalUserInfo);

#pragma pack(pop)

```

`eac/sdk/Include/eos_version.h`:

```h

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

// These numbers define the banner SDK version, and are the most significant numbers when ordering two engine versions (that is, a 4.12.* version is always 
// newer than a 4.11.* version, regardless of the changelist that it was built with)
#define EOS_MAJOR_VERSION	1
#define EOS_MINOR_VERSION	14
#define EOS_PATCH_VERSION	0

// Macros for encoding strings
#define EOS_VERSION_STRINGIFY_2(x) #x
#define EOS_VERSION_STRINGIFY(x) EOS_VERSION_STRINGIFY_2(x)

// Various strings used for engine resources
#define EOS_COMPANY_NAME  "Epic Games, Inc."
#define EOS_COPYRIGHT_STRING "Copyright Epic Games, Inc. All Rights Reserved."
#define EOS_PRODUCT_NAME "Epic Online Services SDK"
#define EOS_PRODUCT_IDENTIFIER "Epic Online Services SDK"

#if defined(BUILT_FROM_CHANGELIST)
#define EOS_VERSION_STRING                       \
	EOS_VERSION_STRINGIFY(EOS_MAJOR_VERSION) "." \
	EOS_VERSION_STRINGIFY(EOS_MINOR_VERSION) "." \
	EOS_VERSION_STRINGIFY(EOS_PATCH_VERSION) "-" \
	EOS_VERSION_STRINGIFY(BUILT_FROM_CHANGELIST)
#else
#define EOS_VERSION_STRING                       \
	EOS_VERSION_STRINGIFY(EOS_MAJOR_VERSION) "." \
	EOS_VERSION_STRINGIFY(EOS_MINOR_VERSION) "." \
	EOS_VERSION_STRINGIFY(EOS_PATCH_VERSION)
#endif

#ifndef RC_INVOKED

#include "eos_base.h"

/** Get the version of the EOSSDK binary */
EOS_DECLARE_FUNC(const char*) EOS_GetVersion(void);

#endif /* #ifndef RC_INVOKED */

```

`server/eos.cpp`:

```cpp
#include "stdafx.h"
#include "eos.h"

/****************** replace with your ids ***********************/

#define GAMENAME "leak-server"
#define PRODUCTID "xxx"
#define SANDBOXID "xxx"
#define DEPLOYMENTID "xxx"
#define CLIENTID "xxx"
#define CLIENTSECRET "xxx"

/****************** replace with your ids ***********************/

struct EosQueueItem
{
	std::function<bool()> func;
	std::promise<bool> ret;
};

template <typename F>
bool Eos::QueueWork(F func)
{
	auto pItem = new EosQueueItem();
	pItem->func = func;
	std::future<bool> ret = pItem->ret.get_future();

	mutex.lock();
	queue.push(std::shared_ptr<EosQueueItem>(pItem));
	mutex.unlock();
	cv.notify_one();

	ret.wait();
	return ret.get();
}

bool Eos::Init()
{
	apiThread = std::thread(std::bind(&Eos::ApiThreadProc, this));

	return QueueWork([this]() {
			// Init EOS SDK
			EOS_InitializeOptions SDKOptions = {};
			SDKOptions.ApiVersion = EOS_INITIALIZE_API_LATEST;
			SDKOptions.AllocateMemoryFunction = nullptr;
			SDKOptions.ReallocateMemoryFunction = nullptr;
			SDKOptions.ReleaseMemoryFunction = nullptr;
			SDKOptions.ProductName = GAMENAME;
			SDKOptions.ProductVersion = "1.0";
			SDKOptions.Reserved = nullptr;
			SDKOptions.SystemInitializeOptions = nullptr;
			SDKOptions.OverrideThreadAffinity = nullptr;

			EOS_EResult InitResult = EOS_Initialize(&SDKOptions);
			if (InitResult != EOS_EResult::EOS_Success)
			{
				printf("[EOS] Init failed: %d\n", (int)InitResult);
				return false;
			}

			printf("[EOS] Initialized. Setting Logging Callback ...\n");

			EOS_EResult SetLogCallbackResult = EOS_Logging_SetCallback([](const EOS_LogMessage* InMsg) {
				if (InMsg != nullptr && InMsg->Level != EOS_ELogLevel::EOS_LOG_Off)
				{
					if (InMsg->Level == EOS_ELogLevel::EOS_LOG_Error || InMsg->Level == EOS_ELogLevel::EOS_LOG_Fatal)
					{
						printf("[EOS] ERROR %s: %s\n", InMsg->Category, InMsg->Message);
					}
					else if (InMsg->Level == EOS_ELogLevel::EOS_LOG_Warning)
					{
						printf("[EOS] WARNING %s: %s\n", InMsg->Category, InMsg->Message);
					}
					else
					{
						printf("[EOS] %s: %s\n", InMsg->Category, InMsg->Message);
					}
					fflush(stdout);
				}
				});

			if (SetLogCallbackResult != EOS_EResult::EOS_Success)
			{
				printf("[EOS] Set Logging Callback Failed: %d\n", (int)SetLogCallbackResult);
			}
			else
			{
				printf("[EOS] Logging Callback Set\n");
				EOS_Logging_SetLogLevel(EOS_ELogCategory::EOS_LC_ALL_CATEGORIES, EOS_ELogLevel::EOS_LOG_Verbose);
			}

			// Create platform instance
			EOS_Platform_Options PlatformOptions = {};
			PlatformOptions.ApiVersion = EOS_PLATFORM_OPTIONS_API_LATEST;
			PlatformOptions.bIsServer = EOS_TRUE;
			PlatformOptions.EncryptionKey = nullptr;
			PlatformOptions.OverrideCountryCode = nullptr;
			PlatformOptions.OverrideLocaleCode = nullptr;
			PlatformOptions.Flags = EOS_PF_DISABLE_OVERLAY; // no overlay needed for the server app
			PlatformOptions.CacheDirectory = nullptr;
			PlatformOptions.ProductId = PRODUCTID;
			PlatformOptions.SandboxId = SANDBOXID;
			PlatformOptions.DeploymentId = DEPLOYMENTID;
			PlatformOptions.ClientCredentials.ClientId = CLIENTID;
			PlatformOptions.ClientCredentials.ClientSecret = CLIENTSECRET;
			PlatformOptions.RTCOptions = nullptr;

			PlatformOptions.Reserved = NULL;

			PlatformHandle = EOS_Platform_Create(&PlatformOptions);
			if (PlatformHandle == nullptr)
			{
				printf("[EOS] Unable to create platform handle!\n");
				return false;
			}

			AntiCheatHandle = EOS_Platform_GetAntiCheatServerInterface(PlatformHandle);

		tickThread = std::thread(std::bind(&Eos::TickThreadProc, this));

		return true;
		});
}

bool Eos::Shutdown()
{
	bool ret = QueueWork([this]() {
		EOS_EResult ShutdownResult = EOS_Shutdown();
		if (ShutdownResult != EOS_EResult::EOS_Success)
		{
			printf("[EOS] shutdown failed: %d\n", (int)ShutdownResult);
			return false;
		}
		return true;
		});

	QueueWork([this]() { shutdowned = true; return true; });
	if (apiThread.joinable())
		apiThread.join();
	if (tickThread.joinable())
		tickThread.join();

	return ret;
}

void __stdcall carCallback(const EOS_AntiCheatCommon_OnClientActionRequiredCallbackInfo* Data)
{
	int id = (int)Data->ClientHandle;

	switch (Data->ClientAction)
	{
	case EOS_EAntiCheatCommonClientAction::EOS_ACCCA_RemovePlayer:
		printf("kick client %d (%s).\n", id, Data->ActionReasonDetailsString);
		break;
	default:
		printf("client %d action required callback: %d, %s\n", id, (int)Data->ClientAction, Data->ActionReasonDetailsString);
		break;
	}
}

void __stdcall mtcCallback(const EOS_AntiCheatCommon_OnMessageToClientCallbackInfo* Data)
{
	int id = (int)Data->ClientHandle;
	printf("client %d message to client callback.\n", id);
}

bool Eos::RegisterCallbacks()
{
	return QueueWork([this]() {

		{
			EOS_AntiCheatServer_AddNotifyClientActionRequiredOptions options;
			options.ApiVersion = EOS_ANTICHEATSERVER_ADDNOTIFYCLIENTAUTHSTATUSCHANGED_API_LATEST;

			carnid = EOS_AntiCheatServer_AddNotifyClientActionRequired(AntiCheatHandle, &options, nullptr, &carCallback);
			if (carnid == EOS_INVALID_NOTIFICATIONID)
				return false;
		}

		{
			EOS_AntiCheatServer_AddNotifyMessageToClientOptions options;
			options.ApiVersion = EOS_ANTICHEATSERVER_ADDNOTIFYMESSAGETOCLIENT_API_LATEST;

			mtcnid = EOS_AntiCheatServer_AddNotifyMessageToClient(AntiCheatHandle, &options, nullptr, &mtcCallback);
			if (mtcnid == EOS_INVALID_NOTIFICATIONID)
				return false;
		}

		return true;
		});
}

bool Eos::UnregisterCallbacks()
{
	return QueueWork([this]() {
		if (carnid != EOS_INVALID_NOTIFICATIONID)
		{
			EOS_AntiCheatServer_RemoveNotifyClientActionRequired(AntiCheatHandle, carnid);
			carnid = EOS_INVALID_NOTIFICATIONID;
		}

		if (mtcnid != EOS_INVALID_NOTIFICATIONID)
		{
			EOS_AntiCheatServer_RemoveNotifyMessageToClient(AntiCheatHandle, mtcnid);
			mtcnid = EOS_INVALID_NOTIFICATIONID;
		}

		return true;
		});
}

bool Eos::BeginSession()
{
	return QueueWork([this]() {
		EOS_AntiCheatServer_BeginSessionOptions options;
		options.ApiVersion = EOS_ANTICHEATSERVER_BEGINSESSION_API_LATEST;
		options.RegisterTimeoutSeconds = 10;
		options.ServerName = "server";
		options.bEnableGameplayData = false;
		options.LocalUserId = nullptr;

		return EOS_AntiCheatServer_BeginSession(AntiCheatHandle, &options) == EOS_EResult::EOS_Success;
		});
}

bool Eos::EndSession()
{
	return QueueWork([this]() {
		EOS_AntiCheatServer_EndSessionOptions options;
		options.ApiVersion = EOS_ANTICHEATSERVER_ENDSESSION_API_LATEST;

		return EOS_AntiCheatServer_EndSession(AntiCheatHandle, &options) == EOS_EResult::EOS_Success;
		});
}

bool Eos::RegisterClient(int id, const char* ip)
{
	return QueueWork([this, id, ip]() {
		std::string accountId = std::to_string(id);

		EOS_AntiCheatServer_RegisterClientOptions options;
		options.ApiVersion = EOS_ANTICHEATSERVER_REGISTERCLIENT_API_LATEST;
		options.ClientHandle = (void*) id;
		options.ClientType = EOS_EAntiCheatCommonClientType::EOS_ACCCT_ProtectedClient;
		options.ClientPlatform = EOS_EAntiCheatCommonClientPlatform::EOS_ACCCP_Windows;
		options.AccountId = accountId.c_str();
		options.IpAddress = ip;

		return EOS_AntiCheatServer_RegisterClient(AntiCheatHandle, &options) == EOS_EResult::EOS_Success;
		});
}

bool Eos::UnregisterClient(int id)
{
	return QueueWork([this, id]() {
		EOS_AntiCheatServer_UnregisterClientOptions options;
		options.ApiVersion = EOS_ANTICHEATSERVER_UNREGISTERCLIENT_API_LATEST;
		options.ClientHandle = (void*) id;

		return EOS_AntiCheatServer_UnregisterClient(AntiCheatHandle, &options) == EOS_EResult::EOS_Success;
		});
}

bool Eos::ReceiveMessageFromClient(int id, const char* data, int size)
{
	return QueueWork([this, id, data, size]() {
		EOS_AntiCheatServer_ReceiveMessageFromClientOptions options;
		options.ApiVersion = EOS_ANTICHEATSERVER_RECEIVEMESSAGEFROMCLIENT_API_LATEST;
		options.ClientHandle = (void*) id;
		options.Data = data;
		options.DataLengthBytes = size;

		return EOS_AntiCheatServer_ReceiveMessageFromClient(AntiCheatHandle, &options) == EOS_EResult::EOS_Success;
		});
}

void Eos::ApiThreadProc()
{
	std::unique_lock<std::mutex> lock(mutex);
	while (!shutdowned && !queue.empty())
	{
		while (!queue.empty())
		{
			auto item = queue.front();
			queue.pop();
			item->ret.set_value(item->func());
		}

		if (shutdowned)
			break;

		cv.wait(lock);
	}
	printf("Eos::ThreadProc() done.\n");
}

void Eos::TickThreadProc()
{
	while (!shutdowned)
	{
		EOS_Platform_Tick(PlatformHandle);
		std::this_thread::sleep_for(std::chrono::milliseconds(10));
	}
}

```

`server/eos.h`:

```h
#pragma once

struct EosQueueItem;

class Eos
{
public:
	bool Init();
	bool Shutdown();

	bool RegisterCallbacks();
	bool UnregisterCallbacks();
	bool BeginSession();
	bool EndSession();
	bool RegisterClient(int id, const char* ip = nullptr);
	bool UnregisterClient(int id);

	bool ReceiveMessageFromClient(int id, const char* data, int size);

protected:
	template <typename F>
	bool QueueWork(F func);

	void ApiThreadProc();
	void TickThreadProc();

private:
	EOS_HPlatform PlatformHandle = 0;
	EOS_HAntiCheatServer AntiCheatHandle = 0;

	volatile bool shutdowned = false;

	std::condition_variable cv;
	std::mutex mutex;
	std::queue<std::shared_ptr<EosQueueItem>> queue;
	std::thread apiThread;
	std::thread tickThread;

	EOS_NotificationId carnid = EOS_INVALID_NOTIFICATIONID;
	EOS_NotificationId mtcnid = EOS_INVALID_NOTIFICATIONID;
};
```

`server/server.cpp`:

```cpp
#include "stdafx.h"
#include "eos.h"

#pragma comment (lib, "Ws2_32.lib")

BOOL WINAPI CtrlHandler(DWORD fdwCtrlType)
{
    return TRUE;
}

SIZE_T CurrentMemorySize()
{
    HANDLE hProcess = GetCurrentProcess();

    PROCESS_MEMORY_COUNTERS_EX counters;
    ZeroMemory(&counters, sizeof(counters));

    if (GetProcessMemoryInfo(hProcess, (PROCESS_MEMORY_COUNTERS*) &counters, sizeof(counters)))
    {
        CloseHandle(hProcess);
        return counters.PrivateUsage / 1024;
    }

    CloseHandle(hProcess);
    return 0;
}

int main()
{
    Eos eos;
    if (!eos.Init())
    {
        return 1;
    }
    if (!eos.RegisterCallbacks())
    {
        return 2;
    }
    if (!eos.BeginSession())
    {
        return 3;
    }

    SIZE_T beforeMemory = CurrentMemorySize();

    //Initialize Winsock
    std::cout << "Intializing Winsock..." << std::endl;
    WSADATA wsaData;
    int result = WSAStartup(MAKEWORD(2, 2), &wsaData);
    if (result != 0)
    {
        std::cout << "WSAStartup() failed: " << result << std::endl;
        return 4;
    }

    SetConsoleCtrlHandler(CtrlHandler, TRUE);

    for (int i = 1; i < 5000; i++)
    {
        eos.RegisterClient(i);
        Sleep(50);
        eos.UnregisterClient(i);
    }

    SIZE_T afterMemory = CurrentMemorySize();
    std::cout << "press enter..." << std::endl;
    fgetc(stdin);
    std::cout << "====== Memory: " << beforeMemory << "kb -> " << afterMemory << "kb ======" << std::endl;

    //Clean up Winsock
    WSACleanup();
    eos.EndSession();
    eos.UnregisterCallbacks();
    eos.Shutdown();
    std::cout << "Program has ended successfully" << std::endl;

    return 0;
}

```

`server/server.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="server.cpp" />
    <ClCompile Include="eos.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="eos.h" />
    <ClInclude Include="stdafx.h" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{fe4434a9-d001-4dab-aae2-39dfc718d235}</ProjectGuid>
    <RootNamespace>chatserver</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)$(Configuration)\server\</OutDir>
    <LibraryPath>$(SolutionDir)eac\sdk\Lib;$(LibraryPath)</LibraryPath>
    <ExternalIncludePath>$(SolutionDir)eac\sdk\Include;$(ExternalIncludePath)</ExternalIncludePath>
    <IncludePath>$(SolutionDir)shared;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)$(Configuration)\server\</OutDir>
    <LibraryPath>$(SolutionDir)eac\sdk\Lib;$(LibraryPath)</LibraryPath>
    <ExternalIncludePath>$(SolutionDir)eac\sdk\Include;$(ExternalIncludePath)</ExternalIncludePath>
    <IncludePath>$(SolutionDir)shared;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\server\</OutDir>
    <LibraryPath>$(SolutionDir)eac\sdk\Lib;$(LibraryPath)</LibraryPath>
    <ExternalIncludePath>$(SolutionDir)eac\sdk\Include;$(ExternalIncludePath)</ExternalIncludePath>
    <IncludePath>$(SolutionDir)shared;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\server\</OutDir>
    <LibraryPath>$(SolutionDir)eac\sdk\Lib;$(LibraryPath)</LibraryPath>
    <ExternalIncludePath>$(SolutionDir)eac\sdk\Include;$(ExternalIncludePath)</ExternalIncludePath>
    <IncludePath>$(SolutionDir)shared;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <PostBuildEvent>
      <Command>xcopy /D /Y /R /Q $(SolutionDir)eac\sdk\bin\EOSSDK-Win32-Shipping.dll $(OutDir)
xcopy /D /Y /R /Q $(SolutionDir)eac\sdk\bin\x86\xaudio2_9redist.dll $(OutDir)
</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <PostBuildEvent>
      <Command>xcopy /D /Y /R /Q $(SolutionDir)eac\sdk\bin\EOSSDK-Win32-Shipping.dll $(OutDir)
xcopy /D /Y /R /Q $(SolutionDir)eac\sdk\bin\x86\xaudio2_9redist.dll $(OutDir)
</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <PostBuildEvent>
      <Command>xcopy /D /Y /R /Q $(SolutionDir)eac\sdk\bin\EOSSDK-Win64-Shipping.dll $(OutDir)
xcopy /D /Y /R /Q $(SolutionDir)eac\sdk\bin\x64\xaudio2_9redist.dll $(OutDir)
</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <PostBuildEvent>
      <Command>xcopy /D /Y /R /Q $(SolutionDir)eac\sdk\bin\EOSSDK-Win64-Shipping.dll $(OutDir)
xcopy /D /Y /R /Q $(SolutionDir)eac\sdk\bin\x64\xaudio2_9redist.dll $(OutDir)
</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`server/server.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="소스 파일">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="헤더 파일">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="리소스 파일">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="server.cpp">
      <Filter>소스 파일</Filter>
    </ClCompile>
    <ClCompile Include="eos.cpp">
      <Filter>소스 파일</Filter>
    </ClCompile>
    <ClCompile Include="stdafx.cpp">
      <Filter>소스 파일</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="eos.h">
      <Filter>헤더 파일</Filter>
    </ClInclude>
    <ClInclude Include="stdafx.h">
      <Filter>헤더 파일</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`server/stdafx.cpp`:

```cpp
#include "stdafx.h"
```

`server/stdafx.h`:

```h
#pragma once

#include <iostream>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <tchar.h>
#include <Psapi.h>
#include <string>
#include <thread>
#include <vector>
#include <mutex>
#include <memory>
#include <condition_variable>
#include <queue>
#include <functional>
#include <future>

#include <eos_sdk.h>
#include <eos_logging.h>
#include <eos_anticheatserver.h>

```