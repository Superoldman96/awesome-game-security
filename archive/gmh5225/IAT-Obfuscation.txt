Project Path: arc_gmh5225_IAT-Obfuscation_i1af9at3

Source Tree:

```txt
arc_gmh5225_IAT-Obfuscation_i1af9at3
├── IAT-Obfuscation
│   ├── IAT-Obfuscation
│   │   ├── IAT-Obfuscation.cpp
│   │   ├── IAT-Obfuscation.vcxproj
│   │   └── IAT-Obfuscation.vcxproj.filters
│   └── IAT-Obfuscation.sln
├── LICENSE
├── README.md
├── TLS.h
└── images
    ├── IAT-Obfuscation.PNG
    ├── ObfuscatedInjection.PNG
    └── UnObfuscatedInjection.PNG

```

`IAT-Obfuscation/IAT-Obfuscation.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31515.178
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "IAT-Obfuscation", "IAT-Obfuscation\IAT-Obfuscation.vcxproj", "{55C0A098-4E6B-4E96-B07A-157E0BD5B866}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{55C0A098-4E6B-4E96-B07A-157E0BD5B866}.Debug|x64.ActiveCfg = Debug|x64
		{55C0A098-4E6B-4E96-B07A-157E0BD5B866}.Debug|x64.Build.0 = Debug|x64
		{55C0A098-4E6B-4E96-B07A-157E0BD5B866}.Debug|x86.ActiveCfg = Debug|Win32
		{55C0A098-4E6B-4E96-B07A-157E0BD5B866}.Debug|x86.Build.0 = Debug|Win32
		{55C0A098-4E6B-4E96-B07A-157E0BD5B866}.Release|x64.ActiveCfg = Release|x64
		{55C0A098-4E6B-4E96-B07A-157E0BD5B866}.Release|x64.Build.0 = Release|x64
		{55C0A098-4E6B-4E96-B07A-157E0BD5B866}.Release|x86.ActiveCfg = Release|Win32
		{55C0A098-4E6B-4E96-B07A-157E0BD5B866}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {98A32D8C-D590-4BAD-9752-82156F351744}
	EndGlobalSection
EndGlobal

```

`IAT-Obfuscation/IAT-Obfuscation/IAT-Obfuscation.cpp`:

```cpp
#include <stdio.h>
#include <Windows.h>

#if _WIN64			
#define DWORD64 unsigned long long
#else
#define DWORD64 unsigned long
#endif



void PrintUsage() {
	printf("IAT-Obfuscation.exe <Executable to protect> <Output File Name>\n");
	return;
}

int main(int argc, CHAR* argv[]){

	HANDLE hFile = NULL;
	DWORD FileSize = NULL;
	DWORD bytesRead = NULL;
	LPVOID FileData = NULL;
	PIMAGE_DOS_HEADER dosHeader = {};
	PIMAGE_NT_HEADERS imageNTHeaders = {};
	PIMAGE_SECTION_HEADER sectionHeader = {};
	PIMAGE_SECTION_HEADER importSection = {};
	IMAGE_IMPORT_DESCRIPTOR* importDescriptor = {};
	PIMAGE_THUNK_DATA ThunkData = {};
	DWORD64 thunk = NULL;
	DWORD64 IATRawOffset = NULL;
	BOOL Status;

	if (argc < 2) {
		PrintUsage();
		return 0;
	}

	CHAR* OutputFileName;

	if (argc == 3) {
		OutputFileName = argv[2];
	}
	else {
		OutputFileName = argv[1];
	}

	hFile = CreateFileA(argv[1], GENERIC_ALL, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile == INVALID_HANDLE_VALUE) {
		printf("Failed To Opne File %s For Read Error Code %x\n", argv[1],GetLastError());
		return -1;
	}

	FileSize = GetFileSize(hFile, NULL);
	FileData = HeapAlloc(GetProcessHeap(), 0, FileSize);
	Status = ReadFile(hFile, FileData, FileSize, &bytesRead, NULL);
	if (!Status) {
		printf("Failed To Read Data From File %s Error Code %x\n", argv[1], GetLastError());
		return -1;
	}
	dosHeader = (PIMAGE_DOS_HEADER)FileData;

	imageNTHeaders = (PIMAGE_NT_HEADERS)((DWORD64)FileData + dosHeader->e_lfanew);

	DWORD64 sectionLocation = (DWORD64)imageNTHeaders + sizeof(DWORD) + (DWORD)(sizeof(IMAGE_FILE_HEADER)) + (DWORD)imageNTHeaders->FileHeader.SizeOfOptionalHeader;
	DWORD64 sectionSize = (DWORD)sizeof(IMAGE_SECTION_HEADER);

	DWORD64 importDirectoryRVA = imageNTHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;

	for (int i = 0; i < imageNTHeaders->FileHeader.NumberOfSections; i++) {
		sectionHeader = (PIMAGE_SECTION_HEADER)sectionLocation;

		if (importDirectoryRVA >= sectionHeader->VirtualAddress && importDirectoryRVA < sectionHeader->VirtualAddress + sectionHeader->Misc.VirtualSize) {
			importSection = sectionHeader;
		}
		sectionLocation += sectionSize;
	}

	printf("Changing the IAT\n");

	//DWORD64 RVAtoOffsetConversion = (DWORD64)importSection->PointerToRawData - (DWORD64)importSection->VirtualAddress;
	DWORD64 StartIATOffset = (DWORD64)importDirectoryRVA - (DWORD64)importSection->VirtualAddress + (DWORD64)importSection->PointerToRawData;

	IATRawOffset = (DWORD64)FileData + importSection->PointerToRawData;
	importDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)(IATRawOffset + (imageNTHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress - importSection->VirtualAddress));

	IMAGE_IMPORT_DESCRIPTOR* MYIAT = (IMAGE_IMPORT_DESCRIPTOR*)(StartIATOffset + (DWORD64)FileData);
	int index = 0;
	DWORD64 PrevValue;
	DWORD64* PrevLocation = NULL;
	DWORD64 CurrentValue;
	DWORD64* CurrentLocation = NULL;
	for (; MYIAT->Name != 0; MYIAT++) {
		thunk = MYIAT->OriginalFirstThunk == 0 ? MYIAT->FirstThunk : MYIAT->OriginalFirstThunk;
		ThunkData = (PIMAGE_THUNK_DATA)(IATRawOffset + (thunk - importSection->VirtualAddress));
		index = 0;
		for (; ThunkData->u1.AddressOfData != 0; ThunkData++) {

			if (ThunkData->u1.AddressOfData > 0x80000000) {
			}
			else {
				CHAR* functionOrdinal = (CHAR*)((DWORD64)IATRawOffset + (ThunkData->u1.AddressOfData - importSection->VirtualAddress + 2));
				if (index % 2 == 1) {
					CurrentValue = ThunkData->u1.AddressOfData;
					CurrentLocation = (DWORD64*)&ThunkData->u1.AddressOfData;;
					
					*(DWORD64*)CurrentLocation = PrevValue;
					*(DWORD64*)PrevLocation = CurrentValue;
				}
				else {
					PrevValue = ThunkData->u1.AddressOfData;
					PrevLocation = (DWORD64*)&ThunkData->u1.AddressOfData;
				}
				index++;
				 
			}
		}
	}
	CloseHandle(hFile);


	printf("Writting Obfuscated File To disck\n");

	HANDLE hOutputFile = CreateFileA(OutputFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

	if (hOutputFile == INVALID_HANDLE_VALUE) {
		printf("Faile TO open file %s for write Error Code %x\n", OutputFileName,GetLastError());
		return 0;
	}

	DWORD dwBytesWritten;
	BOOL bErrorFlag = WriteFile(hOutputFile, FileData, FileSize, &dwBytesWritten, NULL);

	if (FALSE == bErrorFlag) {
		printf("Terminal failure: Unable to write to file.\n");
	}

	printf("Finished\n");

    
    return 0;
}

```

`IAT-Obfuscation/IAT-Obfuscation/IAT-Obfuscation.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{55c0a098-4e6b-4e96-b07a-157e0bd5b866}</ProjectGuid>
    <RootNamespace>IATObfuscation</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="IAT-Obfuscation.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`IAT-Obfuscation/IAT-Obfuscation/IAT-Obfuscation.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="IAT-Obfuscation.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`LICENSE`:

```
MIT License

Copyright (c) 2021 MahmoudZohdy

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# IAT-Obfuscation

This Project is for IAT Obfuscation to make static analysis of a program harder, and to make it harder for recognize and extract the sequence of API for malicious activity staticly.

# How To Use:
```
1- Include the TLS.h header file in your project then compile it (this will add TLS section in the executable that will fix IAT before your main function)
2- execute IAT-Obfuscation.exe <Executable from step 1> <Output File Name>
```

# How it work
this obfuscation technique work by replacing every two api in the same DLL with each other 

![](https://github.com/MahmoudZohdy/IAT-Obfuscation/blob/main/images/IAT-Obfuscation.PNG)

# Demo 

this is the output of simple injection technique to Load Dll in Remote Process (OpenProcess, VirtualAllocEx, WriteProcessMemory, CreateRemoteThread)

UnObfuscated Version
![Clean](https://github.com/MahmoudZohdy/IAT-Obfuscation/blob/main/images/UnObfuscatedInjection.PNG)

Obfuscated Version
![Obfuscated](https://github.com/MahmoudZohdy/IAT-Obfuscation/blob/main/images/ObfuscatedInjection.PNG)

```

`TLS.h`:

```h
#pragma once
#include <intrin.h>
#include <winternl.h>

#if _WIN64			
#define DWORD64 unsigned long long
#else
#define DWORD64 unsigned long
#endif

#ifndef TO_LOWERCASE
#define TO_LOWERCASE(out, c1) (out = (c1 <= 'Z' && c1 >= 'A') ? c1 = (c1 - 'A') + 'a': c1)
#endif




bool TLSflag = 0;
typedef struct _PEB_LDR_DATA_Mine
{
    ULONG Length;
    BOOLEAN Initialized;
    HANDLE SsHandle;
    LIST_ENTRY InLoadOrderModuleList;
    LIST_ENTRY InMemoryOrderModuleList;
    LIST_ENTRY InInitializationOrderModuleList;
    PVOID      EntryInProgress;

} PEB_LDR_DATA_Mine, * PPEB_LDR_DATA_Mine;


typedef struct _LDR_DATA_TABLE_ENTRY_Mine {
    LIST_ENTRY  InLoadOrderModuleList;
    LIST_ENTRY  InMemoryOrderModuleList;
    LIST_ENTRY  InInitializationOrderModuleList;
    void* BaseAddress;
    void* EntryPoint;
    ULONG   SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    ULONG   Flags;
    SHORT   LoadCount;
    SHORT   TlsIndex;
    HANDLE  SectionHandle;
    ULONG   CheckSum;
    ULONG   TimeDateStamp;
} LDR_DATA_TABLE_ENTRY_Mine, * PLDR_DATA_TABLE_ENTRY_Mine;

LPVOID GetModuleBaseByName(WCHAR* ModuleName)
{
    PPEB peb = NULL;
#if defined(_WIN64)
    peb = (PPEB)__readgsqword(0x60);
#else
    peb = (PPEB)__readfsdword(0x30);
#endif
    PPEB_LDR_DATA_Mine ldr = (PPEB_LDR_DATA_Mine)peb->Ldr;
    LIST_ENTRY list = ldr->InLoadOrderModuleList;

    PLDR_DATA_TABLE_ENTRY_Mine Flink = *((PLDR_DATA_TABLE_ENTRY_Mine*)(&list));
    PLDR_DATA_TABLE_ENTRY_Mine CurrentModule = Flink;

    while (CurrentModule != NULL && CurrentModule->BaseAddress != NULL) {
        if (CurrentModule->BaseDllName.Buffer == NULL) continue;
        WCHAR* CurrentModuleName = CurrentModule->BaseDllName.Buffer;

        size_t i = 0;
        for (i = 0; ModuleName[i] != 0 && CurrentModuleName[i] != 0; i++) {
            WCHAR c1, c2;
            TO_LOWERCASE(c1, ModuleName[i]);
            TO_LOWERCASE(c2, CurrentModuleName[i]);
            if (c1 != c2) break;
        }
        if (ModuleName[i] == 0 && CurrentModuleName[i] == 0) {
            //found
            return CurrentModule->BaseAddress;
        }
        // not found, try next:
        CurrentModule = (PLDR_DATA_TABLE_ENTRY_Mine)CurrentModule->InLoadOrderModuleList.Flink;
    }
    return NULL;
}

LPVOID GetFunctionAddressByName(LPVOID ModuleBase, char* FunctionName)
{
    IMAGE_DOS_HEADER* idh = (IMAGE_DOS_HEADER*)ModuleBase;
    if (idh->e_magic != IMAGE_DOS_SIGNATURE) {
        return NULL;
    }
    IMAGE_NT_HEADERS* nt_headers = (IMAGE_NT_HEADERS*)((BYTE*)ModuleBase + idh->e_lfanew);
    IMAGE_DATA_DIRECTORY* exportsDir = &(nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]);
    if (exportsDir->VirtualAddress == NULL) {
        return NULL;
    }

    DWORD expAddr = exportsDir->VirtualAddress;
    IMAGE_EXPORT_DIRECTORY* exp = (IMAGE_EXPORT_DIRECTORY*)(expAddr + (ULONG_PTR)ModuleBase);
    SIZE_T namesCount = exp->NumberOfNames;

    DWORD funcsListRVA = exp->AddressOfFunctions;
    DWORD funcNamesListRVA = exp->AddressOfNames;
    DWORD namesOrdsListRVA = exp->AddressOfNameOrdinals;

    //go through names:
    for (SIZE_T i = 0; i < namesCount; i++) {
        DWORD* nameRVA = (DWORD*)(funcNamesListRVA + (BYTE*)ModuleBase + i * sizeof(DWORD));
        WORD* nameIndex = (WORD*)(namesOrdsListRVA + (BYTE*)ModuleBase + i * sizeof(WORD));
        DWORD* funcRVA = (DWORD*)(funcsListRVA + (BYTE*)ModuleBase + (*nameIndex) * sizeof(DWORD));

        LPSTR CurrentAPIName = (LPSTR)(*nameRVA + (BYTE*)ModuleBase);
        size_t k = 0;
        for (k = 0; FunctionName[k] != 0 && CurrentAPIName[k] != 0; k++) {
            if (FunctionName[k] != CurrentAPIName[k]) break;
        }
        if (FunctionName[k] == 0 && CurrentAPIName[k] == 0) {
            //found
            return (BYTE*)ModuleBase + (*funcRVA);
        }
    }
    return NULL;
}



void NTAPI __stdcall TLSCallbacks(PVOID DllHandle, DWORD dwReason, PVOID Reserved);
//linker spec
#ifdef _M_IX86
#pragma comment (linker, "/INCLUDE:__tls_used")
#pragma comment (linker, "/INCLUDE:__tls_callback")
#else
#pragma comment (linker, "/INCLUDE:_tls_used")
#pragma comment (linker, "/INCLUDE:_tls_callback")
#endif
EXTERN_C
#ifdef _M_X64
#pragma const_seg (".CRT$XLB")
const
#else
#pragma data_seg (".CRT$XLB")
#endif
//end linker

//tls import
PIMAGE_TLS_CALLBACK _tls_callback = TLSCallbacks;
#pragma data_seg ()
#pragma const_seg ()
//end 
// tls declaration
void NTAPI __stdcall TLSCallbacks(PVOID DllHandle, DWORD dwReason, PVOID Reserved)
{
    if (TLSflag == TRUE) {
        return;
    }
    // so that the TLS CallBack will not run more that once and corrupt the IAT
    TLSflag = TRUE;

    typedef HMODULE(WINAPI* _LoadLibraryA)(
        LPCSTR lpLibFileName
        );

    typedef FARPROC(WINAPI* _GetProcAddress)(
        HMODULE hModule,
        LPCSTR  lpProcName
        );

    typedef BOOL(WINAPI* _VirtualProtect)(
        LPVOID lpAddress,
        SIZE_T dwSize,
        DWORD  flNewProtect,
        PDWORD lpflOldProtect
        );

    typedef HMODULE(WINAPI* _GetModuleHandleA)(
        LPCSTR lpModuleName
        );


    WCHAR kernel32[] = L"kernel32.dll";
    CHAR loadlibrary[] = "LoadLibraryA";
    CHAR GetModuleHandleName[] = "GetModuleHandleA";
    CHAR getprocaddress[] = "GetProcAddress";
    CHAR VirtualProtect[] = "VirtualProtect";
    LPVOID kernel32Base;
    LPVOID MainModuleBase;
    _LoadLibraryA loadlibraryAddr;
    _GetProcAddress getprocaddressAddr;
    _VirtualProtect VirtualProtectAddr;
    _GetModuleHandleA GetModuleHandleAAddr;

    kernel32Base = GetModuleBaseByName(kernel32);
    loadlibraryAddr = (_LoadLibraryA)GetFunctionAddressByName(kernel32Base, loadlibrary);
    getprocaddressAddr = (_GetProcAddress)GetFunctionAddressByName(kernel32Base, getprocaddress);
    VirtualProtectAddr = (_VirtualProtect)GetFunctionAddressByName(kernel32Base, VirtualProtect);
    GetModuleHandleAAddr = (_GetModuleHandleA)GetFunctionAddressByName(kernel32Base, GetModuleHandleName);
   
    MainModuleBase = GetModuleHandleAAddr(NULL);

    PIMAGE_NT_HEADERS pSourceHeaders = (PIMAGE_NT_HEADERS)((DWORD64)MainModuleBase + ((PIMAGE_DOS_HEADER)MainModuleBase)->e_lfanew);

    DWORD CommitSize;
    if (!VirtualProtectAddr(MainModuleBase, pSourceHeaders->OptionalHeader.SizeOfImage, PAGE_EXECUTE_READWRITE, &CommitSize)) {
        return;
    }

    PIMAGE_IMPORT_DESCRIPTOR importDescriptor = NULL;

    IMAGE_DATA_DIRECTORY importsDirectory = pSourceHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];

    importDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)((importsDirectory.VirtualAddress + (DWORD_PTR)MainModuleBase));

    LPCSTR libraryName = "";
    HMODULE library = NULL;

    CHAR* OldAPI = NULL;
    DWORD64* OldThunck = NULL;
    DWORD64 OldFun = NULL;
    int index = 0;

    PIMAGE_THUNK_DATA thunk = NULL;
    PIMAGE_THUNK_DATA OriginalThunk = NULL;
    while (importDescriptor->Name != NULL)
    {

        libraryName = (LPCSTR)importDescriptor->Name + (DWORD_PTR)MainModuleBase;
        library = loadlibraryAddr(libraryName);
        index = 0;
        if (library)
        {
            OriginalThunk = (PIMAGE_THUNK_DATA)((DWORD_PTR)MainModuleBase + importDescriptor->OriginalFirstThunk);
            thunk = (PIMAGE_THUNK_DATA)((DWORD_PTR)MainModuleBase + importDescriptor->FirstThunk);

            while (OriginalThunk->u1.AddressOfData != NULL)
            {

                if (IMAGE_SNAP_BY_ORDINAL(thunk->u1.Ordinal)) {

                }
                else {
                    if (index % 2 == 1) {
                        CHAR* functionName = (char*)((DWORD_PTR)MainModuleBase + OriginalThunk->u1.AddressOfData + 2);

                        thunk->u1.Function = (DWORD64)OldFun;
                        *OldThunck = (DWORD64)getprocaddressAddr(library, functionName);
                    }
                    else {
                        OldAPI = (CHAR*)((DWORD64)MainModuleBase + OriginalThunk->u1.AddressOfData + 2);
                        OldThunck = (DWORD64*)&thunk->u1.Function;
                        OldFun = thunk->u1.Function;
                    }
                    index++;
                }

                ++thunk;
                ++OriginalThunk;
            }
        }

        importDescriptor++;
    }


    return;
}
```