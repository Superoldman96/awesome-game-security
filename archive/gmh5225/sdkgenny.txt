Project Path: arc_gmh5225_sdkgenny_qzjw4j3b

Source Tree:

```txt
arc_gmh5225_sdkgenny_qzjw4j3b
├── CMakeLists.txt
├── LICENSE
├── README.md
├── cmake.toml
├── cmkr.cmake
├── examples
│   ├── BadName.cpp
│   ├── BitField.cpp
│   ├── Car.cpp
│   ├── ChildStruct.cpp
│   ├── Constants.cpp
│   ├── DummyData.cpp
│   ├── GenericType.cpp
│   ├── MultipleInheritance.cpp
│   ├── NestedStruct.cpp
│   ├── Parser.cpp
│   ├── Sdk.cpp
│   ├── Typename.cpp
│   └── Usage.cpp
├── format.ps1
├── include
│   ├── Genny.hpp
│   ├── GennyIda.hpp
│   └── GennyParser.hpp
└── vcpkg.json

```

`CMakeLists.txt`:

```txt
# This file is automatically generated from cmake.toml - DO NOT EDIT
# See https://github.com/build-cpp/cmkr for more information

cmake_minimum_required(VERSION 3.15)

if(CMAKE_SOURCE_DIR STREQUAL CMAKE_BINARY_DIR)
	message(FATAL_ERROR "In-tree builds are not supported. Run CMake from a separate directory: cmake -B build")
endif()

# Regenerate CMakeLists.txt automatically in the root project
set(CMKR_ROOT_PROJECT OFF)
if(CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_SOURCE_DIR)
	set(CMKR_ROOT_PROJECT ON)

	# Bootstrap cmkr
	include(cmkr.cmake OPTIONAL RESULT_VARIABLE CMKR_INCLUDE_RESULT)
	if(CMKR_INCLUDE_RESULT)
		cmkr()
	endif()

	# Enable folder support
	set_property(GLOBAL PROPERTY USE_FOLDERS ON)
endif()

# Create a configure-time dependency on cmake.toml to improve IDE support
if(CMKR_ROOT_PROJECT)
	configure_file(cmake.toml cmake.toml COPYONLY)
endif()

# Options
option(SDKGENNY_BUILD_EXAMPLES "" OFF)

project(sdkgenny)

if(CMKR_ROOT_PROJECT AND NOT CMKR_DISABLE_VCPKG)
	include(FetchContent)
	message(STATUS "Fetching vcpkg (2022.05.10)...")
	FetchContent_Declare(vcpkg URL "https://github.com/microsoft/vcpkg/archive/refs/tags/2022.05.10.tar.gz")
	FetchContent_GetProperties(vcpkg)
	if(NOT vcpkg_POPULATED)
		FetchContent_Populate(vcpkg)
		include("${vcpkg_SOURCE_DIR}/scripts/buildsystems/vcpkg.cmake")
	endif()
endif()

# Packages
find_package(pegtl)

# Target sdkgenny
set(CMKR_TARGET sdkgenny)
set(sdkgenny_SOURCES "")

set(CMKR_SOURCES ${sdkgenny_SOURCES})
add_library(sdkgenny INTERFACE)

if(sdkgenny_SOURCES)
	target_sources(sdkgenny INTERFACE ${sdkgenny_SOURCES})
endif()

add_library(sdkgenny::sdkgenny ALIAS sdkgenny)
target_compile_features(sdkgenny INTERFACE
	cxx_std_17
)

target_include_directories(sdkgenny INTERFACE
	"include/"
)

unset(CMKR_TARGET)
unset(CMKR_SOURCES)

# Target example_car
if(SDKGENNY_BUILD_EXAMPLES) # build-examples
	set(CMKR_TARGET example_car)
	set(example_car_SOURCES "")

	list(APPEND example_car_SOURCES
		"examples/Car.cpp"
	)

	list(APPEND example_car_SOURCES
		cmake.toml
	)

	set(CMKR_SOURCES ${example_car_SOURCES})
	add_executable(example_car)

	if(example_car_SOURCES)
		target_sources(example_car PRIVATE ${example_car_SOURCES})
	endif()

	get_directory_property(CMKR_VS_STARTUP_PROJECT DIRECTORY ${PROJECT_SOURCE_DIR} DEFINITION VS_STARTUP_PROJECT)
	if(NOT CMKR_VS_STARTUP_PROJECT)
		set_property(DIRECTORY ${PROJECT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT example_car)
	endif()

	source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${example_car_SOURCES})

	target_link_libraries(example_car PRIVATE
		sdkgenny
	)

	unset(CMKR_TARGET)
	unset(CMKR_SOURCES)
endif()

# Target example_bitfield
if(SDKGENNY_BUILD_EXAMPLES) # build-examples
	set(CMKR_TARGET example_bitfield)
	set(example_bitfield_SOURCES "")

	list(APPEND example_bitfield_SOURCES
		"examples/Bitfield.cpp"
	)

	list(APPEND example_bitfield_SOURCES
		cmake.toml
	)

	set(CMKR_SOURCES ${example_bitfield_SOURCES})
	add_executable(example_bitfield)

	if(example_bitfield_SOURCES)
		target_sources(example_bitfield PRIVATE ${example_bitfield_SOURCES})
	endif()

	get_directory_property(CMKR_VS_STARTUP_PROJECT DIRECTORY ${PROJECT_SOURCE_DIR} DEFINITION VS_STARTUP_PROJECT)
	if(NOT CMKR_VS_STARTUP_PROJECT)
		set_property(DIRECTORY ${PROJECT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT example_bitfield)
	endif()

	source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${example_bitfield_SOURCES})

	target_link_libraries(example_bitfield PRIVATE
		sdkgenny
	)

	unset(CMKR_TARGET)
	unset(CMKR_SOURCES)
endif()

# Target example_typename
if(SDKGENNY_BUILD_EXAMPLES) # build-examples
	set(CMKR_TARGET example_typename)
	set(example_typename_SOURCES "")

	list(APPEND example_typename_SOURCES
		"examples/Typename.cpp"
	)

	list(APPEND example_typename_SOURCES
		cmake.toml
	)

	set(CMKR_SOURCES ${example_typename_SOURCES})
	add_executable(example_typename)

	if(example_typename_SOURCES)
		target_sources(example_typename PRIVATE ${example_typename_SOURCES})
	endif()

	get_directory_property(CMKR_VS_STARTUP_PROJECT DIRECTORY ${PROJECT_SOURCE_DIR} DEFINITION VS_STARTUP_PROJECT)
	if(NOT CMKR_VS_STARTUP_PROJECT)
		set_property(DIRECTORY ${PROJECT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT example_typename)
	endif()

	source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${example_typename_SOURCES})

	target_link_libraries(example_typename PRIVATE
		sdkgenny
	)

	unset(CMKR_TARGET)
	unset(CMKR_SOURCES)
endif()

# Target example_usage
if(SDKGENNY_BUILD_EXAMPLES) # build-examples
	set(CMKR_TARGET example_usage)
	set(example_usage_SOURCES "")

	list(APPEND example_usage_SOURCES
		"examples/Usage.cpp"
	)

	list(APPEND example_usage_SOURCES
		cmake.toml
	)

	set(CMKR_SOURCES ${example_usage_SOURCES})
	add_executable(example_usage)

	if(example_usage_SOURCES)
		target_sources(example_usage PRIVATE ${example_usage_SOURCES})
	endif()

	get_directory_property(CMKR_VS_STARTUP_PROJECT DIRECTORY ${PROJECT_SOURCE_DIR} DEFINITION VS_STARTUP_PROJECT)
	if(NOT CMKR_VS_STARTUP_PROJECT)
		set_property(DIRECTORY ${PROJECT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT example_usage)
	endif()

	source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${example_usage_SOURCES})

	target_link_libraries(example_usage PRIVATE
		sdkgenny
	)

	unset(CMKR_TARGET)
	unset(CMKR_SOURCES)
endif()

# Target example_sdk
if(SDKGENNY_BUILD_EXAMPLES) # build-examples
	set(CMKR_TARGET example_sdk)
	set(example_sdk_SOURCES "")

	list(APPEND example_sdk_SOURCES
		"examples/Sdk.cpp"
	)

	list(APPEND example_sdk_SOURCES
		cmake.toml
	)

	set(CMKR_SOURCES ${example_sdk_SOURCES})
	add_executable(example_sdk)

	if(example_sdk_SOURCES)
		target_sources(example_sdk PRIVATE ${example_sdk_SOURCES})
	endif()

	get_directory_property(CMKR_VS_STARTUP_PROJECT DIRECTORY ${PROJECT_SOURCE_DIR} DEFINITION VS_STARTUP_PROJECT)
	if(NOT CMKR_VS_STARTUP_PROJECT)
		set_property(DIRECTORY ${PROJECT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT example_sdk)
	endif()

	source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${example_sdk_SOURCES})

	target_link_libraries(example_sdk PRIVATE
		sdkgenny
	)

	unset(CMKR_TARGET)
	unset(CMKR_SOURCES)
endif()

# Target example_dummydata
if(SDKGENNY_BUILD_EXAMPLES) # build-examples
	set(CMKR_TARGET example_dummydata)
	set(example_dummydata_SOURCES "")

	list(APPEND example_dummydata_SOURCES
		"examples/DummyData.cpp"
	)

	list(APPEND example_dummydata_SOURCES
		cmake.toml
	)

	set(CMKR_SOURCES ${example_dummydata_SOURCES})
	add_executable(example_dummydata)

	if(example_dummydata_SOURCES)
		target_sources(example_dummydata PRIVATE ${example_dummydata_SOURCES})
	endif()

	get_directory_property(CMKR_VS_STARTUP_PROJECT DIRECTORY ${PROJECT_SOURCE_DIR} DEFINITION VS_STARTUP_PROJECT)
	if(NOT CMKR_VS_STARTUP_PROJECT)
		set_property(DIRECTORY ${PROJECT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT example_dummydata)
	endif()

	source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${example_dummydata_SOURCES})

	target_link_libraries(example_dummydata PRIVATE
		sdkgenny
	)

	unset(CMKR_TARGET)
	unset(CMKR_SOURCES)
endif()

# Target example_badname
if(SDKGENNY_BUILD_EXAMPLES) # build-examples
	set(CMKR_TARGET example_badname)
	set(example_badname_SOURCES "")

	list(APPEND example_badname_SOURCES
		"examples/BadName.cpp"
	)

	list(APPEND example_badname_SOURCES
		cmake.toml
	)

	set(CMKR_SOURCES ${example_badname_SOURCES})
	add_executable(example_badname)

	if(example_badname_SOURCES)
		target_sources(example_badname PRIVATE ${example_badname_SOURCES})
	endif()

	get_directory_property(CMKR_VS_STARTUP_PROJECT DIRECTORY ${PROJECT_SOURCE_DIR} DEFINITION VS_STARTUP_PROJECT)
	if(NOT CMKR_VS_STARTUP_PROJECT)
		set_property(DIRECTORY ${PROJECT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT example_badname)
	endif()

	source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${example_badname_SOURCES})

	target_link_libraries(example_badname PRIVATE
		sdkgenny
	)

	unset(CMKR_TARGET)
	unset(CMKR_SOURCES)
endif()

# Target example_constants
if(SDKGENNY_BUILD_EXAMPLES) # build-examples
	set(CMKR_TARGET example_constants)
	set(example_constants_SOURCES "")

	list(APPEND example_constants_SOURCES
		"examples/Constants.cpp"
	)

	list(APPEND example_constants_SOURCES
		cmake.toml
	)

	set(CMKR_SOURCES ${example_constants_SOURCES})
	add_executable(example_constants)

	if(example_constants_SOURCES)
		target_sources(example_constants PRIVATE ${example_constants_SOURCES})
	endif()

	get_directory_property(CMKR_VS_STARTUP_PROJECT DIRECTORY ${PROJECT_SOURCE_DIR} DEFINITION VS_STARTUP_PROJECT)
	if(NOT CMKR_VS_STARTUP_PROJECT)
		set_property(DIRECTORY ${PROJECT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT example_constants)
	endif()

	source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${example_constants_SOURCES})

	target_link_libraries(example_constants PRIVATE
		sdkgenny
	)

	unset(CMKR_TARGET)
	unset(CMKR_SOURCES)
endif()

# Target example_multiple_inheritance
if(SDKGENNY_BUILD_EXAMPLES) # build-examples
	set(CMKR_TARGET example_multiple_inheritance)
	set(example_multiple_inheritance_SOURCES "")

	list(APPEND example_multiple_inheritance_SOURCES
		"examples/MultipleInheritance.cpp"
	)

	list(APPEND example_multiple_inheritance_SOURCES
		cmake.toml
	)

	set(CMKR_SOURCES ${example_multiple_inheritance_SOURCES})
	add_executable(example_multiple_inheritance)

	if(example_multiple_inheritance_SOURCES)
		target_sources(example_multiple_inheritance PRIVATE ${example_multiple_inheritance_SOURCES})
	endif()

	get_directory_property(CMKR_VS_STARTUP_PROJECT DIRECTORY ${PROJECT_SOURCE_DIR} DEFINITION VS_STARTUP_PROJECT)
	if(NOT CMKR_VS_STARTUP_PROJECT)
		set_property(DIRECTORY ${PROJECT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT example_multiple_inheritance)
	endif()

	source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${example_multiple_inheritance_SOURCES})

	target_link_libraries(example_multiple_inheritance PRIVATE
		sdkgenny
	)

	unset(CMKR_TARGET)
	unset(CMKR_SOURCES)
endif()

# Target example_parser
if(SDKGENNY_BUILD_EXAMPLES) # build-examples
	set(CMKR_TARGET example_parser)
	set(example_parser_SOURCES "")

	list(APPEND example_parser_SOURCES
		"examples/Parser.cpp"
	)

	list(APPEND example_parser_SOURCES
		cmake.toml
	)

	set(CMKR_SOURCES ${example_parser_SOURCES})
	add_executable(example_parser)

	if(example_parser_SOURCES)
		target_sources(example_parser PRIVATE ${example_parser_SOURCES})
	endif()

	get_directory_property(CMKR_VS_STARTUP_PROJECT DIRECTORY ${PROJECT_SOURCE_DIR} DEFINITION VS_STARTUP_PROJECT)
	if(NOT CMKR_VS_STARTUP_PROJECT)
		set_property(DIRECTORY ${PROJECT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT example_parser)
	endif()

	source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${example_parser_SOURCES})

	target_link_libraries(example_parser PRIVATE
		sdkgenny
		taocpp::pegtl
	)

	unset(CMKR_TARGET)
	unset(CMKR_SOURCES)
endif()

# Target example_generictype
if(SDKGENNY_BUILD_EXAMPLES) # build-examples
	set(CMKR_TARGET example_generictype)
	set(example_generictype_SOURCES "")

	list(APPEND example_generictype_SOURCES
		"examples/GenericType.cpp"
	)

	list(APPEND example_generictype_SOURCES
		cmake.toml
	)

	set(CMKR_SOURCES ${example_generictype_SOURCES})
	add_executable(example_generictype)

	if(example_generictype_SOURCES)
		target_sources(example_generictype PRIVATE ${example_generictype_SOURCES})
	endif()

	get_directory_property(CMKR_VS_STARTUP_PROJECT DIRECTORY ${PROJECT_SOURCE_DIR} DEFINITION VS_STARTUP_PROJECT)
	if(NOT CMKR_VS_STARTUP_PROJECT)
		set_property(DIRECTORY ${PROJECT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT example_generictype)
	endif()

	source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${example_generictype_SOURCES})

	target_link_libraries(example_generictype PRIVATE
		sdkgenny
	)

	unset(CMKR_TARGET)
	unset(CMKR_SOURCES)
endif()

# Target example_childstruct
if(SDKGENNY_BUILD_EXAMPLES) # build-examples
	set(CMKR_TARGET example_childstruct)
	set(example_childstruct_SOURCES "")

	list(APPEND example_childstruct_SOURCES
		"examples/ChildStruct.cpp"
	)

	list(APPEND example_childstruct_SOURCES
		cmake.toml
	)

	set(CMKR_SOURCES ${example_childstruct_SOURCES})
	add_executable(example_childstruct)

	if(example_childstruct_SOURCES)
		target_sources(example_childstruct PRIVATE ${example_childstruct_SOURCES})
	endif()

	get_directory_property(CMKR_VS_STARTUP_PROJECT DIRECTORY ${PROJECT_SOURCE_DIR} DEFINITION VS_STARTUP_PROJECT)
	if(NOT CMKR_VS_STARTUP_PROJECT)
		set_property(DIRECTORY ${PROJECT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT example_childstruct)
	endif()

	source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${example_childstruct_SOURCES})

	target_link_libraries(example_childstruct PRIVATE
		sdkgenny
	)

	unset(CMKR_TARGET)
	unset(CMKR_SOURCES)
endif()

# Target example_nestedstruct
if(SDKGENNY_BUILD_EXAMPLES) # build-examples
	set(CMKR_TARGET example_nestedstruct)
	set(example_nestedstruct_SOURCES "")

	list(APPEND example_nestedstruct_SOURCES
		"examples/NestedStruct.cpp"
	)

	list(APPEND example_nestedstruct_SOURCES
		cmake.toml
	)

	set(CMKR_SOURCES ${example_nestedstruct_SOURCES})
	add_executable(example_nestedstruct)

	if(example_nestedstruct_SOURCES)
		target_sources(example_nestedstruct PRIVATE ${example_nestedstruct_SOURCES})
	endif()

	get_directory_property(CMKR_VS_STARTUP_PROJECT DIRECTORY ${PROJECT_SOURCE_DIR} DEFINITION VS_STARTUP_PROJECT)
	if(NOT CMKR_VS_STARTUP_PROJECT)
		set_property(DIRECTORY ${PROJECT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT example_nestedstruct)
	endif()

	source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${example_nestedstruct_SOURCES})

	target_link_libraries(example_nestedstruct PRIVATE
		sdkgenny
		taocpp::pegtl
	)

	unset(CMKR_TARGET)
	unset(CMKR_SOURCES)
endif()


```

`LICENSE`:

```
MIT License

Copyright (c) 2021 cursey

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# SdkGenny

SdkGenny is a header-only framework for generating C++ compatible SDKs for third party applications.

## Installation

Copy `Genny.hpp` from the `include/` directory into your project and `#include` it when you want to use it.

## Usage
Here is a short example of how to use SdkGenny. This does not showcase every feature. For more examples check the `examples/` directory.
```C++
// Make an SDK generator.
genny::Sdk sdk{};

// Get the global namespace for the SDK.
auto g = sdk.global_ns();

// Add some basic types to the global namespace.
g->type("int")->size(4);
g->type("float")->size(4);

// Make an actual namespace.
auto ns = g->namespace_("foobar");

// Make a class in the namespace.
auto foo = ns->class_("Foo");

// Add some members.
foo->variable("a")->type("int")->offset(0);
foo->variable("b")->type("float")->append();

// Make a subclass.
auto bar = ns->class_("Bar")->parent(foo);

// Add a member after 'b'.
bar->variable("c")->type("int")->append();

// Generate the SDK to the "usage_sdk" folder.
sdk.generate(std::filesystem::current_path() / "usage_sdk");
```
Will produce the following 2 files

### `foobar/Foo.hpp`
```C++
#pragma once
namespace foobar {
#pragma pack(push, 1)
class Foo {
public:
    int a; // 0x0
    float b; // 0x4
}; // Size: 0x8
#pragma pack(pop)
}
```

### `foobar/Bar.hpp`
```C++
#pragma once
#include ".\Foo.hpp"
namespace foobar {
#pragma pack(push, 1)
class Bar : public Foo {
public:
    int c; // 0x8
}; // Size: 0xc
#pragma pack(pop)
}
```

## Projects
* [REFramework](https://github.com/praydog/REFramework) by [@praydog](https://github.com/praydog) - A mod framework for Resident-Evil 2
* [GlacierGenny](https://github.com/praydog/GlacierGenny) by [@praydog](https://github.com/praydog) - An SDK generator for HITMAN3
* [UE4Genny](https://github.com/cursey/ue4genny) - An SDK generator for Unreal Engine 4 games

## License
[MIT](https://choosealicense.com/licenses/mit/)

```

`cmake.toml`:

```toml
# Reference: https://build-cpp.github.io/cmkr/cmake-toml
[project]
name = "sdkgenny"

[options]
SDKGENNY_BUILD_EXAMPLES = false

[conditions]
build-examples = "SDKGENNY_BUILD_EXAMPLES"

[vcpkg]
version = "2022.05.10"
packages = ["pegtl"]

[find-package]
pegtl = { required = false }

[target.sdkgenny]
type = "interface"
include-directories = ["include/"]
compile-features = ["cxx_std_17"]
alias = "sdkgenny::sdkgenny"

[target.example_car]
condition = "build-examples"
type = "executable"
sources = ["examples/Car.cpp"]
link-libraries = ["sdkgenny"]

[target.example_bitfield]
condition = "build-examples"
type = "executable"
sources = ["examples/Bitfield.cpp"]
link-libraries = ["sdkgenny"]

[target.example_typename]
condition = "build-examples"
type = "executable"
sources = ["examples/Typename.cpp"]
link-libraries = ["sdkgenny"]

[target.example_usage]
condition = "build-examples"
type = "executable"
sources = ["examples/Usage.cpp"]
link-libraries = ["sdkgenny"]

[target.example_sdk]
condition = "build-examples"
type = "executable"
sources = ["examples/Sdk.cpp"]
link-libraries = ["sdkgenny"]

[target.example_dummydata]
condition = "build-examples"
type = "executable"
sources = ["examples/DummyData.cpp"]
link-libraries = ["sdkgenny"]

[target.example_badname]
condition = "build-examples"
type = "executable"
sources = ["examples/BadName.cpp"]
link-libraries = ["sdkgenny"]

[target.example_constants]
condition = "build-examples"
type = "executable"
sources = ["examples/Constants.cpp"]
link-libraries = ["sdkgenny"]

[target.example_multiple_inheritance]
condition = "build-examples"
type = "executable"
sources = ["examples/MultipleInheritance.cpp"]
link-libraries = ["sdkgenny"]

[target.example_parser]
condition = "build-examples"
type = "executable"
sources = ["examples/Parser.cpp"]
link-libraries = ["sdkgenny", "taocpp::pegtl"]

[target.example_generictype]
condition = "build-examples"
type = "executable"
sources = ["examples/GenericType.cpp"]
link-libraries = ["sdkgenny"]

[target.example_childstruct]
condition = "build-examples"
type = "executable"
sources = ["examples/ChildStruct.cpp"]
link-libraries = ["sdkgenny"]

[target.example_nestedstruct]
condition = "build-examples"
type = "executable"
sources = ["examples/NestedStruct.cpp"]
link-libraries = ["sdkgenny", "taocpp::pegtl"]

```

`cmkr.cmake`:

```cmake
include_guard()

# Change these defaults to point to your infrastructure if desired
set(CMKR_REPO "https://github.com/build-cpp/cmkr" CACHE STRING "cmkr git repository" FORCE)
set(CMKR_TAG "v0.2.13" CACHE STRING "cmkr git tag (this needs to be available forever)" FORCE)
set(CMKR_COMMIT_HASH "" CACHE STRING "cmkr git commit hash (optional)" FORCE)

# To bootstrap/generate a cmkr project: cmake -P cmkr.cmake
if(CMAKE_SCRIPT_MODE_FILE)
    set(CMAKE_BINARY_DIR "${CMAKE_BINARY_DIR}/build")
    set(CMAKE_CURRENT_BINARY_DIR "${CMAKE_BINARY_DIR}")
    file(MAKE_DIRECTORY "${CMAKE_BINARY_DIR}")
endif()

# Set these from the command line to customize for development/debugging purposes
set(CMKR_EXECUTABLE "" CACHE FILEPATH "cmkr executable")
set(CMKR_SKIP_GENERATION OFF CACHE BOOL "skip automatic cmkr generation")
set(CMKR_BUILD_TYPE "Debug" CACHE STRING "cmkr build configuration")
mark_as_advanced(CMKR_REPO CMKR_TAG CMKR_COMMIT_HASH CMKR_EXECUTABLE CMKR_SKIP_GENERATION CMKR_BUILD_TYPE)

# Disable cmkr if generation is disabled
if(DEFINED ENV{CI} OR CMKR_SKIP_GENERATION OR CMKR_BUILD_SKIP_GENERATION)
    message(STATUS "[cmkr] Skipping automatic cmkr generation")
    unset(CMKR_BUILD_SKIP_GENERATION CACHE)
    macro(cmkr)
    endmacro()
    return()
endif()

# Disable cmkr if no cmake.toml file is found
if(NOT CMAKE_SCRIPT_MODE_FILE AND NOT EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/cmake.toml")
    message(AUTHOR_WARNING "[cmkr] Not found: ${CMAKE_CURRENT_SOURCE_DIR}/cmake.toml")
    macro(cmkr)
    endmacro()
    return()
endif()

# Convert a Windows native path to CMake path
if(CMKR_EXECUTABLE MATCHES "\\\\")
    string(REPLACE "\\" "/" CMKR_EXECUTABLE_CMAKE "${CMKR_EXECUTABLE}")
    set(CMKR_EXECUTABLE "${CMKR_EXECUTABLE_CMAKE}" CACHE FILEPATH "" FORCE)
    unset(CMKR_EXECUTABLE_CMAKE)
endif()

# Helper macro to execute a process (COMMAND_ERROR_IS_FATAL ANY is 3.19 and higher)
function(cmkr_exec)
    execute_process(COMMAND ${ARGV} RESULT_VARIABLE CMKR_EXEC_RESULT)
    if(NOT CMKR_EXEC_RESULT EQUAL 0)
        message(FATAL_ERROR "cmkr_exec(${ARGV}) failed (exit code ${CMKR_EXEC_RESULT})")
    endif()
endfunction()

# Windows-specific hack (CMAKE_EXECUTABLE_PREFIX is not set at the moment)
if(WIN32)
    set(CMKR_EXECUTABLE_NAME "cmkr.exe")
else()
    set(CMKR_EXECUTABLE_NAME "cmkr")
endif()

# Use cached cmkr if found
if(DEFINED ENV{CMKR_CACHE} AND EXISTS "$ENV{CMKR_CACHE}")
    set(CMKR_DIRECTORY_PREFIX "$ENV{CMKR_CACHE}")
    string(REPLACE "\\" "/" CMKR_DIRECTORY_PREFIX "${CMKR_DIRECTORY_PREFIX}")
    if(NOT CMKR_DIRECTORY_PREFIX MATCHES "\\/$")
        set(CMKR_DIRECTORY_PREFIX "${CMKR_DIRECTORY_PREFIX}/")
    endif()
    # Build in release mode for the cache
    set(CMKR_BUILD_TYPE "Release")
else()
    set(CMKR_DIRECTORY_PREFIX "${CMAKE_CURRENT_BINARY_DIR}/_cmkr_")
endif()
set(CMKR_DIRECTORY "${CMKR_DIRECTORY_PREFIX}${CMKR_TAG}")
set(CMKR_CACHED_EXECUTABLE "${CMKR_DIRECTORY}/bin/${CMKR_EXECUTABLE_NAME}")

# Handle upgrading logic
if(CMKR_EXECUTABLE AND NOT CMKR_CACHED_EXECUTABLE STREQUAL CMKR_EXECUTABLE)
    if(CMKR_EXECUTABLE MATCHES "^${CMAKE_CURRENT_BINARY_DIR}/_cmkr")
        if(DEFINED ENV{CMKR_CACHE} AND EXISTS "$ENV{CMKR_CACHE}")
            message(AUTHOR_WARNING "[cmkr] Switching to cached cmkr: '${CMKR_CACHED_EXECUTABLE}'")
            if(EXISTS "${CMKR_CACHED_EXECUTABLE}")
                set(CMKR_EXECUTABLE "${CMKR_CACHED_EXECUTABLE}" CACHE FILEPATH "Full path to cmkr executable" FORCE)
            else()
                unset(CMKR_EXECUTABLE CACHE)
            endif()
        else()
            message(AUTHOR_WARNING "[cmkr] Upgrading '${CMKR_EXECUTABLE}' to '${CMKR_CACHED_EXECUTABLE}'")
            unset(CMKR_EXECUTABLE CACHE)
        endif()
    elseif(DEFINED ENV{CMKR_CACHE} AND EXISTS "$ENV{CMKR_CACHE}" AND CMKR_EXECUTABLE MATCHES "^${CMKR_DIRECTORY_PREFIX}")
        message(AUTHOR_WARNING "[cmkr] Upgrading cached '${CMKR_EXECUTABLE}' to '${CMKR_CACHED_EXECUTABLE}'")
        unset(CMKR_EXECUTABLE CACHE)
    endif()
endif()

if(CMKR_EXECUTABLE AND EXISTS "${CMKR_EXECUTABLE}")
    message(VERBOSE "[cmkr] Found cmkr: '${CMKR_EXECUTABLE}'")
elseif(CMKR_EXECUTABLE AND NOT CMKR_EXECUTABLE STREQUAL CMKR_CACHED_EXECUTABLE)
    message(FATAL_ERROR "[cmkr] '${CMKR_EXECUTABLE}' not found")
elseif(NOT CMKR_EXECUTABLE AND EXISTS "${CMKR_CACHED_EXECUTABLE}")
    set(CMKR_EXECUTABLE "${CMKR_CACHED_EXECUTABLE}" CACHE FILEPATH "Full path to cmkr executable" FORCE)
    message(STATUS "[cmkr] Found cached cmkr: '${CMKR_EXECUTABLE}'")
else()
    set(CMKR_EXECUTABLE "${CMKR_CACHED_EXECUTABLE}" CACHE FILEPATH "Full path to cmkr executable" FORCE)
    message(VERBOSE "[cmkr] Bootstrapping '${CMKR_EXECUTABLE}'")

    message(STATUS "[cmkr] Fetching cmkr...")
    if(EXISTS "${CMKR_DIRECTORY}")
        cmkr_exec("${CMAKE_COMMAND}" -E rm -rf "${CMKR_DIRECTORY}")
    endif()
    find_package(Git QUIET REQUIRED)
    cmkr_exec("${GIT_EXECUTABLE}"
        clone
        --config advice.detachedHead=false
        --branch ${CMKR_TAG}
        --depth 1
        ${CMKR_REPO}
        "${CMKR_DIRECTORY}"
    )
    if(CMKR_COMMIT_HASH)
        execute_process(
            COMMAND "${GIT_EXECUTABLE}" checkout -q "${CMKR_COMMIT_HASH}"
            RESULT_VARIABLE CMKR_EXEC_RESULT
            WORKING_DIRECTORY "${CMKR_DIRECTORY}"
        )
        if(NOT CMKR_EXEC_RESULT EQUAL 0)
            message(FATAL_ERROR "Tag '${CMKR_TAG}' hash is not '${CMKR_COMMIT_HASH}'")
        endif()
    endif()
    message(STATUS "[cmkr] Building cmkr (using system compiler)...")
    cmkr_exec("${CMAKE_COMMAND}"
        --no-warn-unused-cli
        "${CMKR_DIRECTORY}"
        "-B${CMKR_DIRECTORY}/build"
        "-DCMAKE_BUILD_TYPE=${CMKR_BUILD_TYPE}"
        "-DCMAKE_UNITY_BUILD=ON"
        "-DCMAKE_INSTALL_PREFIX=${CMKR_DIRECTORY}"
        "-DCMKR_GENERATE_DOCUMENTATION=OFF"
    )
    cmkr_exec("${CMAKE_COMMAND}"
        --build "${CMKR_DIRECTORY}/build"
        --config "${CMKR_BUILD_TYPE}"
        --parallel
    )
    cmkr_exec("${CMAKE_COMMAND}"
        --install "${CMKR_DIRECTORY}/build"
        --config "${CMKR_BUILD_TYPE}"
        --prefix "${CMKR_DIRECTORY}"
        --component cmkr
    )
    if(NOT EXISTS ${CMKR_EXECUTABLE})
        message(FATAL_ERROR "[cmkr] Failed to bootstrap '${CMKR_EXECUTABLE}'")
    endif()
    cmkr_exec("${CMKR_EXECUTABLE}" version)
    message(STATUS "[cmkr] Bootstrapped ${CMKR_EXECUTABLE}")
endif()
execute_process(COMMAND "${CMKR_EXECUTABLE}" version
    RESULT_VARIABLE CMKR_EXEC_RESULT
)
if(NOT CMKR_EXEC_RESULT EQUAL 0)
    message(FATAL_ERROR "[cmkr] Failed to get version, try clearing the cache and rebuilding")
endif()

# Use cmkr.cmake as a script
if(CMAKE_SCRIPT_MODE_FILE)
    if(NOT EXISTS "${CMAKE_SOURCE_DIR}/cmake.toml")
        execute_process(COMMAND "${CMKR_EXECUTABLE}" init
            RESULT_VARIABLE CMKR_EXEC_RESULT
        )
        if(NOT CMKR_EXEC_RESULT EQUAL 0)
            message(FATAL_ERROR "[cmkr] Failed to bootstrap cmkr project. Please report an issue: https://github.com/build-cpp/cmkr/issues/new")
        else()
            message(STATUS "[cmkr] Modify cmake.toml and then configure using: cmake -B build")
        endif()
    else()
        execute_process(COMMAND "${CMKR_EXECUTABLE}" gen
            RESULT_VARIABLE CMKR_EXEC_RESULT
        )
        if(NOT CMKR_EXEC_RESULT EQUAL 0)
            message(FATAL_ERROR "[cmkr] Failed to generate project.")
        else()
            message(STATUS "[cmkr] Configure using: cmake -B build")
        endif()
    endif()
endif()

# This is the macro that contains black magic
macro(cmkr)
    # When this macro is called from the generated file, fake some internal CMake variables
    get_source_file_property(CMKR_CURRENT_LIST_FILE "${CMAKE_CURRENT_LIST_FILE}" CMKR_CURRENT_LIST_FILE)
    if(CMKR_CURRENT_LIST_FILE)
        set(CMAKE_CURRENT_LIST_FILE "${CMKR_CURRENT_LIST_FILE}")
        get_filename_component(CMAKE_CURRENT_LIST_DIR "${CMAKE_CURRENT_LIST_FILE}" DIRECTORY)
    endif()

    # File-based include guard (include_guard is not documented to work)
    get_source_file_property(CMKR_INCLUDE_GUARD "${CMAKE_CURRENT_LIST_FILE}" CMKR_INCLUDE_GUARD)
    if(NOT CMKR_INCLUDE_GUARD)
        set_source_files_properties("${CMAKE_CURRENT_LIST_FILE}" PROPERTIES CMKR_INCLUDE_GUARD TRUE)

        file(SHA256 "${CMAKE_CURRENT_LIST_FILE}" CMKR_LIST_FILE_SHA256_PRE)

        # Generate CMakeLists.txt
        cmkr_exec("${CMKR_EXECUTABLE}" gen
            WORKING_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}"
        )

        file(SHA256 "${CMAKE_CURRENT_LIST_FILE}" CMKR_LIST_FILE_SHA256_POST)

        # Delete the temporary file if it was left for some reason
        set(CMKR_TEMP_FILE "${CMAKE_CURRENT_SOURCE_DIR}/CMakerLists.txt")
        if(EXISTS "${CMKR_TEMP_FILE}")
            file(REMOVE "${CMKR_TEMP_FILE}")
        endif()

        if(NOT CMKR_LIST_FILE_SHA256_PRE STREQUAL CMKR_LIST_FILE_SHA256_POST)
            # Copy the now-generated CMakeLists.txt to CMakerLists.txt
            # This is done because you cannot include() a file you are currently in
            configure_file(CMakeLists.txt "${CMKR_TEMP_FILE}" COPYONLY)

            # Add the macro required for the hack at the start of the cmkr macro
            set_source_files_properties("${CMKR_TEMP_FILE}" PROPERTIES
                CMKR_CURRENT_LIST_FILE "${CMAKE_CURRENT_LIST_FILE}"
            )

            # 'Execute' the newly-generated CMakeLists.txt
            include("${CMKR_TEMP_FILE}")

            # Delete the generated file
            file(REMOVE "${CMKR_TEMP_FILE}")

            # Do not execute the rest of the original CMakeLists.txt
            return()
        endif()
        # Resume executing the unmodified CMakeLists.txt
    endif()
endmacro()

```

`examples/BadName.cpp`:

```cpp
#include <Genny.hpp>

int main(int argc, char* argv[]) {
    genny::Sdk sdk{};

    auto g = sdk.global_ns();
    auto bad_type = g->type("Bad name type")->size(8);
    auto bad_class = g->class_("Bad class");

    bad_class->variable("123 bad variable")->type(bad_type)->offset(0);
    bad_class->variable("shorthand bad variable")->type("Bad name type")->offset(8);

    sdk.generate(std::filesystem::current_path() / "bad_name_sdk");

    return 0;
}
```

`examples/BitField.cpp`:

```cpp
#include "Genny.hpp"

int main(int argc, char* argv[]) {
    genny::Sdk sdk{};
    auto g = sdk.global_ns();

    auto ushort = g->type("unsigned short")->size(2);

    // Generate the Date struct described @ https://docs.microsoft.com/en-us/cpp/cpp/cpp-bit-fields
    auto date = g->struct_("Date");

    date->variable("nWeekDay")->type(ushort)->bit_size(3)->append()->bit_append();
    date->variable("nMonthDay")->type(ushort)->bit_size(6)->append()->bit_append();
    date->variable("nMonth")->type(ushort)->bit_size(5)->append()->bit_append();
    date->variable("nYear")->type(ushort)->bit_size(8)->append()->bit_append();

    sdk.generate(std::filesystem::current_path() / "bitfield_sdk");

    return 0;
}
```

`examples/Car.cpp`:

```cpp
#include <cassert>

#include <Genny.hpp>

constexpr auto PREAMBLE =
    R"(MIT License

Copyright (c) 2021 cursey

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.)";

int main(int argc, char* argv[]) {
    genny::Sdk sdk{};
    auto g = sdk.global_ns();

    sdk.preamble(PREAMBLE)->postamble("End of file");
    sdk.include("cstdint")->include_local("Types.hpp");

    g->type("bool")->size(1);
    g->type("char")->size(1);
    g->type("short")->size(2);
    g->type("int")->size(4);
    g->type("long")->size(4);
    g->type("long long")->size(8);
    g->type("float")->size(4);
    g->type("double")->size(8);

    g->enum_("CarTypes")->value("TWO_DOOR", 0)->value("FOUR_DOOR", 1)->value("TRUCK", 2)->value("VAN", 3);

    auto vec3 = g->struct_("Vec3")->size(16);

    vec3->variable("x")->type(g->type("float"))->offset(0);
    vec3->variable("y")->type(g->type("float"))->offset(4);
    vec3->variable("z")->type(g->type("float"))->offset(8);

    auto car = g->class_("Car")->parent(g->class_("ModeOfTransportation"));

    car->variable("weight")->type(g->type("int"))->offset(8);
    car->variable("value")->type(g->type("float"))->offset(12);

    auto wheel = car->class_("Wheel");
    auto color = car->enum_("Color")->value("RED", 0)->value("BLACK", 1);
    auto door = car->struct_("Door");

    wheel->variable("size")->type(g->type("int"))->offset(0);
    door->variable("color")->type(color)->offset(0);
    car->variable("wheels")->type(wheel->array_(4))->offset(16);
    car->variable("doors")->type(door->array_(4))->offset(16 + 4 * 4);
    car->variable("pos")->type(g->type("Vec3"))->offset(car->variable("doors")->end());
    car->variable("pos_history")->type(g->type("Vec3")->ptr())->offset(car->variable("pos")->end());

    auto drive = car->function("drive");

    drive->returns(g->type("float"));
    drive->param("speed")->type(g->type("float"));
    drive->param("distance")->type(g->type("float"));
    drive->procedure(R"(std::cout << "Oh my god guys I'm driving!"; return 5.0f;)");

    auto open_door = car->virtual_function("open_door");

    open_door->param("where")->type(g->type("Vec3")->ptr());

    car->enum_class("Title")->value("SALVAGE", 0)->value("CLEAN", 1)->type(g->type("long long"));

    auto two_door = g->class_("TwoDoorCar")->parent(g->class_("Car"));

    // Name collision will occur. Will have a number appended in the output.
    two_door->variable("weight")->type(g->type("long"))->offset(120);
    assert(two_door->owner<genny::Namespace>() == g);

    sdk.generate(std::filesystem::current_path() / "car_sdk");

    return 0;
}

```

`examples/ChildStruct.cpp`:

```cpp
// This example originally showcased an error in dependency resolving for structs declared within other structs.
#include "Genny.hpp"

int main(int argc, char* argv[]) {
    genny::Sdk sdk{};
    auto g = sdk.global_ns();

    auto i32 = g->type("int")->size(4);
    auto foo = g->struct_("Foo");

    foo->variable("a")->type(i32)->append();

    auto bar = foo->struct_("Bar");

    bar->variable("b")->type(i32)->append();

    auto baz = foo->struct_("Baz");

    baz->variable("c")->type(i32)->append();

    auto qux = g->struct_("Qux");

    // qux->variable("d")->type(bar)->append();
    qux->variable("e")->type(baz->ptr())->append();

    sdk.generate(std::filesystem::current_path() / "child_struct_sdk");

    return 0;
}

```

`examples/Constants.cpp`:

```cpp
#include "Genny.hpp"

int main(int argc, char* argv[]) {
    genny::Sdk sdk{};
    auto g = sdk.global_ns();

    auto i32 = g->type("int")->size(4);
    auto f32 = g->type("float")->size(4);
    auto char8 = g->type("char")->size(1);

    auto s = g->struct_("StructWithConstants");

    s->constant("SOME_INT")->integer(42)->type(i32);
    s->constant("SOME_OTHER_INT")->integer(777)->type(i32);
    s->constant("SOME_FLOAT")->real(123.456f)->type(f32);
    s->constant("SOME_STR")->string("Hello, world!")->type(char8->ptr());

    sdk.generate(std::filesystem::current_path() / "constants_sdk");

    return 0;
}

```

`examples/DummyData.cpp`:

```cpp
// This example originally highlighted an issue with include path resolution that
// has since been fixed.
#include "Genny.hpp"

int main() {
    genny::Sdk sdk{};
    auto g = sdk.global_ns();

    sdk.include("REFramework.hpp");
    sdk.include("sdk/ReClass.hpp");
    sdk.include("cstdint");

    g->type("int8_t")->size(1);
    g->type("int16_t")->size(2);
    g->type("int32_t")->size(4);
    g->type("int64_t")->size(8);
    g->type("uint8_t")->size(1);
    g->type("uint16_t")->size(2);
    g->type("uint32_t")->size(4);
    g->type("uint64_t")->size(8);
    g->type("float")->size(4);
    g->type("double")->size(8);
    g->type("bool")->size(1);
    g->type("char")->size(1);
    g->type("int")->size(4);
    g->type("void")->size(0);
    g->type("void*")->size(8);

    auto dummy_type = g->namespace_("sdk")->struct_("DummyData")->size(0x100);

    auto c = g->namespace_("not-sdk")->class_("SomeClass");
    c->function("SomeFunc")->returns(dummy_type);

    sdk.generate("sdk");

    return 0;
}

```

`examples/GenericType.cpp`:

```cpp
#include <iostream>
#include <Genny.hpp>

int main(int argc, char* argv[]) {
    genny::Sdk sdk{};

    auto g = sdk.global_ns();
    g->type("int")->size(4);
    g->type("float")->size(4);

    auto foo = g->class_("Foo");
    foo->variable("a")->type("int")->append();
    foo->variable("b")->type("float")->append();

    auto bar = g->class_("Bar");
    bar->variable("c")->type("int")->append();

    auto baz = g->generic_type("Baz<Foo, Bar*>")->template_type(foo)->template_type(bar->ptr())->size(42);

    auto qux = g->class_("Qux");
    qux->variable("baz")->type(baz)->append();

    auto quux = g->class_("Quux");
    quux->function("hello")->param("name")->type(baz->ref());

    sdk.generate(std::filesystem::current_path() / "generic_type_sdk");

    return 0;
}
```

`examples/MultipleInheritance.cpp`:

```cpp
#include <Genny.hpp>

int main(int argc, char* argv[]) {
    genny::Sdk sdk{};

    auto g = sdk.global_ns();
    g->type("int")->size(4);
    g->type("float")->size(4);

    auto person = g->class_("Person");
    person->variable("age")->type("int")->offset(0);

    auto student = g->class_("Student")->parent(person);
    student->variable("gpa")->type("float")->offset(person->size());

    auto faculty = g->class_("Faculty")->parent(person);
    faculty->variable("wage")->type("int")->offset(person->size());

    auto ta = g->class_("TA")->parent(student)->parent(faculty);
    ta->variable("hours")->type("int")->offset(student->size() + faculty->size());

    sdk.generate(std::filesystem::current_path() / "multiple_inheritance_sdk");

    return 0;
}
```

`examples/NestedStruct.cpp`:

```cpp
// This example originally showcased an error in nested struct generation.
#include <iostream>

#include <GennyParser.hpp>

int main(int argc, char* argv[]) {
    genny::Sdk sdk{};
    genny::parser::State s{};
    s.parents.push_back(sdk.global_ns());

    tao::pegtl::string_input in{
        /*R"(
            namespace foo {
                struct bar {
                    struct baz {}
                }
            }
        )"*/
        R"(
            struct foo {
                struct bar* bar
            }

        )"
        , ""};

    try {
        tao::pegtl::parse<genny::parser::Grammar, genny::parser::Action>(in, s);
    } catch (const tao::pegtl::parse_error& e) {
        std::cerr << e.what() << std::endl;
        return 1;
    }

    auto sdk_path = std::filesystem::current_path() / "nested_struct_sdk";
    std::filesystem::remove_all(sdk_path);
    sdk.generate(sdk_path);

    return 0;
}

```

`examples/Parser.cpp`:

```cpp
#include <cstdlib>
#include <iostream>
#include <optional>

#include <GennyParser.hpp>

#include <tao/pegtl/contrib/analyze.hpp>

constexpr auto g_example_str = R"(
type float 4
type double 8

struct vec3
    float x @ 0 // omg thats @ 0
    float y // This will follow the x variable and land @ 4
    float z // This will follow y and land @ 8

// The total size will be... 12!
)";

constexpr auto g_usage_str = R"(
// Add some basic types to the global namespace.
type char 1 [[i8 ]];
type int 4 [[ i32]]
type float 4 [[f32]]

// Make an actual namespace.
namespace foo.bar {

// Make a class in the namespace.
struct Foo 0x10 {
    // Add some members.
    int a @ 0 [[u32]]
    float b
};

// Make a subclass.
struct Bar : Foo 0x20 {
    // Add a member after 'b'.
    int c
}

// Make a subclass with multiple parents.
struct Baz : Foo, Bar {
    float d 
}
}

namespace baz {


/* this is a cool struct
 * and this is a long comment
 * how neat. */
struct Qux  { 
    foo.bar.Baz baz
    char* str
    char* str_array[10];
    int add(int a, /* bad place for a comment but w/e */ int b)   
    int sub(int a, int b, int* c)
}

}

struct Vec3 {
    float x;
    float y;
    float z;
    float length    ( );
    Vec3 add( Vec3 other );
    static Vec3 zero();
};

struct OtherVec3 {
    float xyz[3]
    float* xyz_ptr
    int** xyz_ptr_ptr // woah
}

struct Mat4x3 {
    float m[4][3]
    float[4] n[3]; // Very strange.
    float[4][3] o
}

enum Color {
    RED = 1,
    BLUE = 2,
    GREEN = 0x3
}

namespace enums {
    
enum Size : char {
    SMALL = 0,
    MEDIUM = 1,
    LARGE = 2,
    XLARGE = 3,
    XXLARGE = 4,
}

enum class Speed : int {
    SLOW = 25,
    MEDIUM = 40,
    FAST = 65
};
}

type uint16_t 2 [[u16]]

struct Date {
    uint16_t nWeekDay : 3
    uint16_t nMonthDay : 6
    uint16_t nMonth : 5
    uint16_t nYear : 8
    Vec3 v
}

struct Nested {
    enum Enum {
        HELLO = 0,
        WORLD = 1,
    }

    struct Struct {
        int a
        int b +4
        int c +8
    }

    Enum enum_
    Struct struct_
}

class CoolClass {
    Nested nest @ 8
    virtual int say_hi(char* name)
    virtual void say_hello_world() @ 1
    virtual void say_goodbye() @ 10
}
)";

constexpr auto g_ns_bug = R"(
type int 4

namespace qux
struct foo
    int a

namespace bar
    struct baz : qux.foo
        int b

namespace   
    struct quux
        int c
)";

constexpr auto g_new = R"(
type int 4
type char 1

namespace enums {
enum Size : char {
    SMALL = 0,
    MEDIUM = 1,
    LARGE = 2,
    XLARGE = 3,
    XXLARGE = 4
}

namespace this_enum.is.nested.deep {

    enum class Speed : int {
        SLOW = 25,
        MEDIUM = 40,    
        FAST = 65
    }

}
}

namespace structs {
struct Vec3i {
    int x
    int y
    int z
}
}
)";

constexpr auto g_include = R"(
#include "types.genny"

struct Vec3f {
    float x
    float y
    float z
}

struct Vec3i {
    int x
    int y
    int z
}

struct Baz : foobar.Bar {
    int c
}
)";

constexpr auto g_fwd_decl_members = R"(
class Foo {
    struct Bar* bar
}

struct Bar {
    class Foo* foo
    enum class Baz* baz
}

enum class Baz {
    A = 0, 
    B = 1, 
    C = 2
}
)";

constexpr auto g_reclass = R"(
type char 1

// Created with ReClass.NET 1.2 by KN4CK3R

class Foo
{
public:
	char pad_0000[128]; //0x0000
}; //Size: 0x0080
static_assert(sizeof(Foo) == 0x80);

class Bar
{
public:
	char pad_0000[128]; //0x0000
}; //Size: 0x0080
static_assert(sizeof(Bar) == 0x80);

class Baz
{
public:
	class Foo *foo; //0x0000
	class Bar *bar; //0x0008
	char pad_0010[112]; //0x0010
}; //Size: 0x0080
static_assert(sizeof(Baz) == 0x80);

class Qux : public Baz
{
public:
	char pad_0080[120]; //0x0080
}; //Size: 0x00F8
static_assert(sizeof(Qux) == 0xF8);
)";

constexpr auto g_multiple_inheritance = R"(
type int 4
type float 4

struct Person {
    int age
}

struct Student : Person {
    float gpa
}

struct Faculty : Person {
    int wage
}

struct TA : Student, Faculty {
    int hours
}
)";

namespace pegtl = tao::pegtl;

int main(int argc, char* argv[]) {
    auto _ = tao::pegtl::analyze<genny::parser::Grammar>(1);

    genny::Sdk sdk{};

    sdk.header_extension(".hxx");
    sdk.source_extension(".cxx");

    genny::parser::State s{};
    // s.global_ns = s.cur_ns = sdk.global_ns();
    s.parents.push_back(sdk.global_ns());

    // pegtl::string_input in{"float type 4", "example_string"};
    // pegtl::string_input in{g_example_str, "example_string"};
    pegtl::string_input in{g_usage_str, "usage_str"};
    // pegtl::string_input in{g_ns_bug, "ns_bug_str"};
    // pegtl::string_input in{g_new, "new_str"};
    // pegtl::string_input in{g_include, "include_str"};
    // pegtl::string_input in{g_fwd_decl_members, "fwd_decl_members"};
    // pegtl::string_input in{g_reclass, "reclass"};
    // pegtl::string_input in{g_multiple_inheritance, "multiple_inheritance"};

    try {
        auto r = pegtl::parse<genny::parser::Grammar, genny::parser::Action>(in, s);
        std::cout << r << std::endl;
    } catch (const pegtl::parse_error& e) {
        std::cerr << e.what() << std::endl;
        return 1;
    }

    auto sdk_path = std::filesystem::current_path() / "parser_sdk";
    std::filesystem::remove_all(sdk_path);
    sdk.generate(sdk_path);

    std::cout << sdk_path.string() << std::endl;

    return 0;
}
```

`examples/Sdk.cpp`:

```cpp
#include <Genny.hpp>

void car(genny::Namespace* g) {
    g->type("bool")->size(1);
    g->type("char")->size(1);
    g->type("short")->size(2);
    g->type("int")->size(4);
    g->type("long")->size(4);
    g->type("int64_t")->size(8);
    g->type("float")->size(4);
    g->type("double")->size(8);

    g->enum_("CarTypes")->value("TWO_DOOR", 0)->value("FOUR_DOOR", 1)->value("TRUCK", 2)->value("VAN", 3);

    auto vec3 = g->owner<genny::Namespace>()->struct_("Vec3")->size(16);

    vec3->variable("x")->type(g->type("float"))->offset(0);
    vec3->variable("y")->type(g->type("float"))->offset(4);
    vec3->variable("z")->type(g->type("float"))->offset(8);

    auto car = g->class_("Car")->parent(g->class_("ModeOfTransportation"));

    car->variable("weight")->type(g->type("int"))->offset(8);
    car->variable("value")->type(g->type("float"))->offset(12);

    auto wheel = car->class_("Wheel");
    auto color = car->enum_("Color")->value("RED", 0)->value("BLACK", 1);
    auto door = car->struct_("Door");

    wheel->variable("size")->type(g->type("int"))->offset(0);
    door->variable("color")->type(color)->offset(0);
    car->variable("wheels")->type(wheel->array_(4))->offset(16);
    car->variable("doors")->type(door->array_(4))->offset(16 + 4 * 4);
    car->variable("pos")->type(g->type("Vec3"))->offset(car->variable("doors")->end());
    car->variable("pos_history")->type(g->type("Vec3")->ptr())->offset(car->variable("pos")->end());

    auto drive = car->function("drive");

    drive->returns(g->type("float"));
    drive->param("speed")->type(g->type("float"));
    drive->param("distance")->type(g->type("float"));
    drive->procedure(R"(std::cout << "Oh my god guys I'm driving!"; return 5.0f;)");

    auto open_door = car->virtual_function("open_door");

    open_door->param("where")->type(g->type("Vec3")->ptr());

    car->enum_class("Title")->value("SALVAGE", 0)->value("CLEAN", 1)->type(g->type("int64_t"));

    auto two_door = g->class_("TwoDoorCar")->parent(g->class_("Car"));

    // Name collision will occur. Will have a number appended in the output.
    two_door->variable("weight")->type(g->type("long"))->offset(120);
}

void usage(genny::Namespace* sdk) {
    // Add some basic types to the global namespace.
    sdk->type("int")->size(4);
    sdk->type("float")->size(4);

    // Make an actual namespace.
    auto ns = sdk->namespace_("foobar");

    // Make a class in the namespace.
    auto foo = ns->class_("Foo");

    // Add some members.
    foo->variable("a")->type("int")->offset(0);
    foo->variable("b")->type("float")->append();

    // Make a subclass.
    auto bar = ns->class_("Bar")->parent(foo);

    // Add a member after 'b'.
    bar->variable("c")->type("int")->append();
}

void multiple_inheritance(genny::Namespace* ns) {
    auto foo = ns->namespace_("foo")->class_("Foo");
    foo->variable("a")->offset(8)->type("int");

    auto bar = ns->namespace_("bar")->class_("Bar");
    bar->variable("b")->offset(16)->type("float");

    auto baz = ns->namespace_("baz")->class_("Baz")->parent(foo)->parent(bar);
    auto c = baz->variable("c")->offset(foo->size() + bar->size() + 4)->type("long");
    baz->variable("a")->offset(c->end())->type("double");
}

void nested_type_inclusion(genny::Namespace* ns) {
    auto foo = ns->class_("Foo");
    auto foo_bar = foo->enum_("Bar");
    auto baz = ns->class_("Baz");
    baz->variable("bar")->type(foo_bar);
}

int main(int argc, char* argv[]) {
    genny::Sdk sdk{};
    auto g = sdk.global_ns();

    // sdk.include("cstdint")->include("vector");

    g->type("bool")->size(1);
    g->type("char")->size(1);
    g->type("short")->size(2);
    g->type("int")->size(4);
    g->type("long")->size(4);
    g->type("int64_t")->size(8);
    g->type("float")->size(4);
    g->type("double")->size(8);

    auto SdkEnum = g->enum_("SdkEnum")->value("A", 1)->value("B", 2)->value("C", 3);
    auto a = g->namespace_("a");
    auto AEnum = a->enum_("AEnum")->value("A", 1)->value("B", 2)->value("C", 3);
    auto b = g->namespace_("b");
    auto ba = b->namespace_("ba");
    auto BAClass = ba->class_("BAClass");
    BAClass->variable("a_enum")->offset(8)->type(AEnum->ptr());
    auto c = g->namespace_("c");
    auto CClass = c->class_("CClass");
    CClass->variable("ba_class")->type(BAClass->ptr());
    CClass->variable("a_enum")->offset(CClass->variable("ba_class")->end())->type(AEnum);
    CClass->variable("ba_class_2")->offset(CClass->variable("a_enum")->end())->type(BAClass->ptr()->ptr()->ptr());

    car(g->namespace_("car"));
    usage(g->namespace_("usage"));
    multiple_inheritance(g->namespace_("multi"));
    nested_type_inclusion(g->namespace_("nested_type"));

    auto say_hi = CClass->static_function("say_hi");
    say_hi->returns(g->type("int"));
    say_hi->procedure("std::cout << \"hi\\n\";\nreturn 1;");

    auto drive = BAClass->virtual_function("car_at_pos")->vtable_index(5);
    drive->returns(g->namespace_("car")->class_("Car")->ptr());
    drive->param("pos")->type(g->struct_("Vec3")->ref());

    auto cclasses = g->generic_type("std::vector<c::CClass*>");
    cclasses->template_type(CClass->ptr());
    cclasses->size(sizeof(std::vector<void*>));

    drive->param("cclasses")->type(cclasses->ptr());

    auto nested = CClass->class_("Nested");
    nested->function("aloha")->procedure("std::cout << \"aloha\\n\";");

    g->class_("EmptyClass");

    auto sdk_path = std::filesystem::current_path() / "example_sdk";
    std::filesystem::remove_all(sdk_path);
    sdk.generate(sdk_path);

    return 0;
}
```

`examples/Typename.cpp`:

```cpp
#include <Genny.hpp>

int main(int argc, char* argv[]) {
    genny::Sdk sdk{};
    auto g = sdk.global_ns();

    auto foo = g->namespace_("foo")->namespace_("baz")->class_("Foo");
    foo->variable("bar")->type(g->namespace_("bar")->class_("Bar")->ptr());

    auto bar = g->namespace_("bar")->class_("Bar");
    bar->variable("foo")->type(foo->ptr());

    for (int i = 0; i < 100; ++i) {
        g->namespace_("bs_ns_" + std::to_string(i));
    }

    sdk.generate(std::filesystem::current_path() / "typename_sdk");

    return 0;
}
```

`examples/Usage.cpp`:

```cpp
#include <Genny.hpp>

int main(int argc, char* argv[]) {
    // Make an SDK generator.
    genny::Sdk sdk{};

    // Get the global namespace for the SDK.
    auto g = sdk.global_ns();

    // Add some basic types to the global namespace.
    g->type("int")->size(4);
    g->type("float")->size(4);

    // Make an actual namespace.
    auto ns = g->namespace_("foobar");

    // Make a class in the namespace.
    auto foo = ns->class_("Foo");

    // Add some members.
    foo->variable("a")->type("int")->offset(0);
    foo->variable("b")->type("float")->append();

    // Make a subclass.
    auto bar = ns->class_("Bar")->parent(foo);

    // Add a member after 'b'.
    bar->variable("c")->type("int")->append();

    // Generate the SDK to the "usage_sdk" folder.
    sdk.generate(std::filesystem::current_path() / "usage_sdk");

    return 0;
}
```

`format.ps1`:

```ps1
Get-ChildItem -Path .\include,.\examples -Include *.hpp, *.cpp -Recurse | 
ForEach-Object {
    Write-Output $_.FullName
    &clang-format -i -style=file $_.FullName
}

```

`include/Genny.hpp`:

```hpp
// SdkGenny - Genny.hpp - A single file header framework for generating C++ compatible SDKs
// https://github.com/cursey/sdkgenny

#pragma once

#include <algorithm>
#include <cassert>
#include <climits>
#include <cstring>
#include <filesystem>
#include <fstream>
#include <functional>
#include <map>
#include <memory>
#include <ostream>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <string_view>
#include <type_traits>
#include <unordered_map>
#include <unordered_set>
#include <vector>

namespace genny {

class Type;
class Reference;
class Pointer;
class Array;
class Struct;
class Class;
class Enum;
class Variable;
class Function;
class Namespace;

class Indent : public std::streambuf {
public:
    explicit Indent(std::streambuf* dest, int indent = 4) : m_dest{dest}, m_indent(indent, ' ') {}
    explicit Indent(std::ostream& dest, int indent = 4) : m_dest{dest.rdbuf()}, m_indent(indent, ' '), m_owner{&dest} {
        m_owner->rdbuf(this);
    }
    ~Indent() override {
        if (m_owner != nullptr) {
            m_owner->rdbuf(m_dest);
        }
    }

protected:
    int overflow(int ch) override {
        if (m_is_at_start_of_line && ch != '\n') {
            m_dest->sputn(m_indent.data(), m_indent.size());
        }
        m_is_at_start_of_line = ch == '\n';
        return m_dest->sputc(ch);
    }

private:
    std::streambuf* m_dest{};
    bool m_is_at_start_of_line{true};
    std::string m_indent{};
    std::ostream* m_owner{};
};

class Object {
public:
    Object() = delete;
    explicit Object(std::string_view name) : m_name{name} {}
    virtual ~Object() = default;

    const auto& name() const { return m_name; }
    auto name(std::string name) {
        m_name = std::move(name);
        return this;
    }

    const auto& metadata() const { return m_metadata; }
    auto& metadata() { return m_metadata; }

    virtual void generate_metadata(std::ostream& os) const {
        if (m_metadata.empty()) {
            return;
        }

        os << "// Metadata: ";

        for (auto&& md : m_metadata) {
            os << md;
            if (&md != &*m_metadata.rbegin()) {
                os << md << ", ";
            }
        }

        os << "\n";
    }

    template <typename T> bool is_a() const { return dynamic_cast<const T*>(this) != nullptr; }

    // Searches for an owner of the correct type.
    template <typename T> const T* owner() const {
        for (auto owner = m_owner; owner != nullptr; owner = owner->m_owner) {
            if (owner->is_a<T>()) {
                return (const T*)owner;
            }
        }

        return nullptr;
    }

    template <typename T> T* owner() { return (T*)((const Object*)this)->owner<T>(); }

    template <typename T> const T* topmost_owner() const {
        const T* topmost{};

        for (auto owner = m_owner; owner != nullptr; owner = owner->m_owner) {
            if (owner->is_a<T>()) {
                topmost = (const T*)owner;
            }
        }

        return topmost;
    }

    template <typename T> T* topmost_owner() { return (T*)((const Object*)this)->topmost_owner<T>(); }

    auto direct_owner() const { return m_owner; }

    template <typename T> std::vector<T*> owners() const {
        std::vector<T*> owners{};

        for (auto owner = m_owner; owner != nullptr; owner = owner->m_owner) {
            if (owner->is_a<T>()) {
                owners.emplace_back((T*)owner);
            }
        }

        return owners;
    }

    template <typename T> std::vector<T*> get_all() const {
        std::vector<T*> children{};

        for (auto&& child : m_children) {
            if (child->is_a<T>()) {
                children.emplace_back((T*)child.get());
            }
        }

        return children;
    }

    template <typename T> void get_all_in_children(std::unordered_set<T*>& objects) const {
        if (is_a<T>()) {
            objects.emplace((T*)this);
        }

        for (auto&& child : m_children) {
            child->get_all_in_children(objects);
        }
    }

    template <typename T> bool has_any() const {
        return std::any_of(m_children.cbegin(), m_children.cend(), [](const auto& child) { return child->template is_a<T>(); });
    }

    template <typename T> bool has_any_in_children() const {
        return std::any_of(m_children.cbegin(), m_children.cend(),
            [](const auto& child) { return child->template is_a<T>() || child->template has_any_in_children<T>(); });
    }

    template <typename T> bool is_child_of(T* obj) const {
        const auto o = owners<T>();
        return std::any_of(o.cbegin(), o.cend(), [obj](const auto& owner) { return owner == obj; });
    }

    bool is_direct_child_of(Object* obj) const { return m_owner == obj; }

    template <typename T> T* add(std::unique_ptr<T> object) {
        object->m_owner = this;
        return (T*)m_children.emplace_back(std::move(object)).get();
    }

    template <typename T> T* find(std::string_view name) const {
        for (auto&& child : m_children) {
            if (child->is_a<T>() && child->m_name == name) {
                return (T*)child.get();
            }
        }

        return nullptr;
    }

    template <typename T> T* find_in_owners(std::string_view name, bool include_self) const {
        auto owner = (include_self) ? this : m_owner;

        for (; owner != nullptr; owner = owner->m_owner) {
            if (auto search = owner->find<T>(name)) {
                return search;
            }
        }

        return nullptr;
    }

    template <typename T, typename... TArgs> T* find_or_add(std::string_view name, TArgs... args) {
        if (auto search = find<T>(name)) {
            return search;
        }

        return add(std::make_unique<T>(name, args...));
    }

    template <typename T, typename... TArgs> T* find_in_owners_or_add(std::string_view name, TArgs... args) {
        if (auto search = find_in_owners<T>(name, true)) {
            return search;
        }

        return add(std::make_unique<T>(name, args...));
    }

    // Returns the unique_ptr to the removed object.
    std::unique_ptr<Object> remove(Object* obj) {
        obj->m_owner = nullptr;

        if (auto search =
                std::find_if(m_children.begin(), m_children.end(), [obj](auto&& c) { return c.get() == obj; });
            search != m_children.end()) {
            auto p = std::move(*search);
            m_children.erase(search);
            return p;
        }
        /* m_children.erase(
            std::remove_if(m_children.begin(), m_children.end(), [obj](auto&& c) { return c.get() == obj; }));*/
        return nullptr;
    }

    template <typename T> void remove_all() {
        for (auto&& child : get_all<T>()) {
            remove(child);
        }
    }

    // Will fix up a desired name so that it's usable as a C++ identifier. Things like spaces get converted to
    // underscores, and we make sure it doesn't begin with a number. More checks could be done here in the future if
    // necessary.
    std::function<std::string()> usable_name = [this] {
        std::string name{};
        constexpr auto allowed_chars = "*&[]:";

        for (auto&& c : m_name) {
            if (!std::isalnum(c) && std::strchr(allowed_chars, c) == nullptr) {
                name += '_';
            } else {
                name += c;
            }
        }

        if (!name.empty() && isdigit(name[0])) {
            name = "_" + name;
        }

        return name;
    };

    // The name used when declaring the object (only for types).
    std::function<std::string()> usable_name_decl = usable_name;

    std::filesystem::path path() {
        if (m_owner == nullptr) {
            return usable_name();
        }

        std::filesystem::path p{};
        auto os = owners<Object>();

        std::reverse(os.begin(), os.end());

        for (auto&& o : os) {
            if (o->template is_a<Namespace>()) {
                p /= o->usable_name();
            } else if (o->is_a<Struct>()) {
                p /= o->usable_name();
                break;
            }
        }

        if (m_owner->template is_a<Namespace>()) {
            p /= usable_name();
        }

        return p;
    }

    auto skip_generation(bool g) {
        m_skip_generation = g;
        return this;
    }
    auto skip_generation() { return m_skip_generation; }

protected:
    friend class Type;
    friend class Pointer;
    friend class Namespace;
    friend class Sdk;

    Object* m_owner{};

    std::string m_name{};
    std::vector<std::unique_ptr<Object>> m_children{};
    std::vector<std::string> m_metadata{};

    bool m_skip_generation{};
};

template <typename T> T* cast(const Object* object) {
    if (object->is_a<T>()) {
        return (T*)object;
    }

    return nullptr;
}

class Typename : public Object {
public:
    explicit Typename(std::string_view name) : Object{name} {}

    virtual void generate_typename_for(std::ostream& os, const Object* obj) const {
        if (m_simple_typename_generation) {
            os << usable_name();
            return;
        }

        if (auto owner_type = owner<Typename>()) {
            if (obj == nullptr || owner_type != obj->owner<Typename>()) {
                auto&& name = owner_type->name();

                if (!name.empty()) {
                    owner_type->generate_typename_for(os, obj);
                    os << "::";
                }
            }
        }

        os << usable_name();
    }

    auto simple_typename_generation() const { return m_simple_typename_generation; }
    auto simple_typename_generation(bool simple_generation) {
        m_simple_typename_generation = simple_generation;
        return this;
    }

protected:
    bool m_simple_typename_generation{};
};

class Type : public Typename {
public:
    explicit Type(std::string_view name) : Typename{name} {}

    virtual void generate_variable_postamble(std::ostream& os) const {}

    virtual size_t size() const { return m_size; }
    auto size(int size) {
        m_size = size;
        return this;
    }

    Reference* ref();
    Pointer* ptr();
    Array* array_(size_t count = 0);

protected:
    size_t m_size{};
};

class Reference : public Type {
public:
    explicit Reference(std::string_view name) : Type{name} {}

    auto to() const { return m_to; }
    auto to(Type* to) {
        m_to = to;
        return this;
    }

    size_t size() const override { return sizeof(uintptr_t); }

    void generate_typename_for(std::ostream& os, const Object* obj) const override {
        m_to->generate_typename_for(os, obj);
        os << "&";
    }

protected:
    Type* m_to{};
};

inline Reference* Type::ref() {
    return m_owner->find_or_add<Reference>(name() + '&')->to(this);
}

class Pointer : public Reference {
public:
    explicit Pointer(std::string_view name) : Reference{name} {}

    auto ptr() { return m_owner->find_or_add<Pointer>(m_name + '*')->to(this); }

    void generate_typename_for(std::ostream& os, const Object* obj) const override {
        m_to->generate_typename_for(os, obj);
        os << "*";
    }
};

inline Pointer* Type::ptr() {
    return (Pointer*)m_owner->find_or_add<Pointer>(name() + '*')->to(this);
}

class Array : public Type {
public:
    explicit Array(std::string_view name) : Type{name} {}

    auto of() const { return m_of; }
    auto of(Type* of) {
        m_of = of;
        return this;
    }

    auto count() const { return m_count; }
    auto count(size_t count) {
        // Fix the name of this array type.
        if (m_of != nullptr && count != m_count) {
            const auto& base = m_of->name();
            auto first_brace = base.find_first_of('[');
            auto head = base.substr(0, first_brace);
            std::string tail{};

            if (first_brace != std::string::npos) {
                tail = base.substr(first_brace);
            }

            m_name = head + '[' + std::to_string(count) + ']' + tail;
        }

        m_count = count;

        return this;
    }

    size_t size() const override {
        if (m_of == nullptr) {
            return 0;
        }

        return m_of->size() * m_count;
    }

    void generate_typename_for(std::ostream& os, const Object* obj) const override {
        m_of->generate_typename_for(os, obj);
    }

    void generate_variable_postamble(std::ostream& os) const override {
        os << "[" << std::dec << m_count << "]";
        m_of->generate_variable_postamble(os);
    }

protected:
    Type* m_of{};
    size_t m_count{};
};

inline Array* Type::array_(size_t count) {
    return (Array*)m_owner->find_or_add<Array>(name() + "[0]")->of(this)->count(count);
}

class GenericType : public Type {
public:
    explicit GenericType(std::string_view name) : Type{name} {
        usable_name = [this] {
            std::string name{};
            constexpr auto allowed_chars = "*&[]:<>, ";

            for (auto&& c : m_name) {
                if (!std::isalnum(c) && std::strchr(allowed_chars, c) == nullptr) {
                    name += '_';
                } else {
                    name += c;
                }
            }

            if (!name.empty() && isdigit(name[0])) {
                name = "_" + name;
            }

            return name;
        };
    }

    auto template_types() const { return m_template_types; }
    auto template_type(Type* type) {
        m_template_types.emplace(type);
        return this;
    }

protected:
    std::unordered_set<Type*> m_template_types{};
};

class Variable : public Object {
public:
    explicit Variable(std::string_view name) : Object{name} {}

    auto type() const { return m_type; }
    auto type(Type* type) {
        m_type = type;
        return this;
    }

    // Helper that recurses though owners to find the correct type.
    auto type(std::string_view name) {
        m_type = find_in_owners_or_add<Type>(name);
        return this;
    }

    auto offset() const { return m_offset; }
    auto offset(uintptr_t offset) {
        m_offset = offset;
        return this;
    }

    // Sets the offset to be after the last variable in the struct.
    Variable* append();

    virtual size_t size() const {
        if (m_type == nullptr) {
            return 0;
        }

        return m_type->size();
    }

    auto end() const { return offset() + size(); }

    auto bit_size(size_t size) {
        // assert(size <= m_type->size() * CHAR_BIT);
        m_bit_size = size;
        return this;
    }
    auto bit_size() const { return m_bit_size; }

    auto bit_offset(uintptr_t offset) {
        // assert(offset < m_type->size() * CHAR_BIT);
        m_bit_offset = offset;
        return this;
    }
    auto bit_offset() const { return m_bit_offset; }

    auto is_bitfield() const { return m_bit_size != 0; }

    // Call this after append() or offset()
    Variable* bit_append();

    virtual void generate(std::ostream& os) const {
        generate_metadata(os);
        m_type->generate_typename_for(os, this);
        os << " " << usable_name();
        m_type->generate_variable_postamble(os);

        if (m_bit_size != 0) {
            os << " : " << std::dec << m_bit_size;
        }

        os << "; // 0x" << std::hex << m_offset << "\n";
    }

protected:
    Type* m_type{};
    uintptr_t m_offset{};
    size_t m_bit_size{};
    uintptr_t m_bit_offset{};
};

class Constant : public Object {
public:
    explicit Constant(std::string_view name) : Object{name} {}

    auto type() const { return m_type; }
    auto type(Type* type) {
        m_type = type;
        return this;
    }

    // Helper that recurses though owners to find the correct type.
    auto type(std::string_view name) {
        m_type = find_in_owners_or_add<Type>(name);
        return this;
    }

    const auto& value() const { return m_value; }
    auto value(std::string_view value) {
        m_value = std::move(value);
        return this;
    }

    template <typename T, std::enable_if_t<std::is_floating_point_v<T>, bool> = true> auto real(T value) {
        m_value = std::to_string(value);
        return this;
    }

    template <typename T, std::enable_if_t<std::is_integral_v<T>, bool> = true> auto integer(T value) {
        m_value = std::to_string(value);
        return this;
    }

    auto string(const std::string& value) {
        m_value = "\"" + value + "\"";
        return this;
    }

    virtual void generate(std::ostream& os) const {
        os << "static constexpr ";
        generate_metadata(os);
        m_type->generate_typename_for(os, this);
        os << " " << usable_name();
        m_type->generate_variable_postamble(os);
        os << " = " << m_value << ";";
    }

protected:
    Type* m_type{};
    std::string m_value{};
};

class Parameter : public Object {
public:
    explicit Parameter(std::string_view name) : Object{name} {}

    auto type() const { return m_type; }
    auto type(Type* type) {
        m_type = type;
        return this;
    }

    virtual void generate(std::ostream& os) const {
        m_type->generate_typename_for(os, this);
        os << " " << usable_name();
    }

protected:
    Type* m_type{};
};

class Function : public Object {
public:
    explicit Function(std::string_view name) : Object{name} {}

    auto param(std::string_view name) { return find_or_add<Parameter>(name); }

    auto returns() const { return m_return_value; }
    auto returns(Type* return_value) {
        m_return_value = return_value;
        return this;
    }

    auto&& procedure() const { return m_procedure; }
    auto procedure(std::string_view procedure) {
        m_procedure = procedure;
        return this;
    }

    auto&& dependencies() const { return m_dependencies; }
    auto depends_on(Type* type) {
        m_dependencies.emplace(type);
        return this;
    }

    auto&& defined() const { return m_is_defined; }
    auto defined(bool is_defined) {
        m_is_defined = is_defined;
        return this;
    }

    virtual void generate(std::ostream& os) const {
        generate_prototype(os);
        os << ";\n";
    }

    virtual void generate_source(std::ostream& os) const {
        if (m_is_defined) {
            generate_procedure(os);
        }
    }

protected:
    Type* m_return_value{};
    std::string m_procedure{};
    std::unordered_set<Type*> m_dependencies{};
    bool m_is_defined{true};

    void generate_prototype(std::ostream& os) const {
        if (m_return_value == nullptr) {
            os << "void";
        } else {
            m_return_value->generate_typename_for(os, this);
        }

        os << " ";
        generate_prototype_internal(os);
    }

    void generate_prototype_internal(std::ostream& os) const {
        os << usable_name() << "(";

        auto is_first_param = true;

        for (auto&& param : get_all<Parameter>()) {
            if (is_first_param) {
                is_first_param = false;
            } else {
                os << ", ";
            }

            param->generate(os);
        }

        os << ")";
    }

    void generate_procedure(std::ostream& os) const {
        if (m_return_value == nullptr) {
            os << "void";
        } else {
            m_return_value->generate_typename_for(os, nullptr);
        }

        os << " ";

        std::vector<const Object*> owners{};

        for (auto o = owner<Object>(); o != nullptr; o = o->owner<Object>()) {
            owners.emplace_back(o);
        }

        std::reverse(owners.begin(), owners.end());

        for (auto&& o : owners) {
            if (o->usable_name().empty()) {
                continue;
            }

            os << o->usable_name() << "::";
        }

        generate_prototype_internal(os);

        if (m_procedure.empty()) {
            os << " {}\n";
        } else {
            os << " {\n";
            {
                Indent _{os};
                os << m_procedure;
            }
            if (m_procedure.back() != '\n') {
                os << "\n";
            }
            os << "}\n";
        }
    }
};

class VirtualFunction : public Function {
public:
    explicit VirtualFunction(std::string_view name) : Function{name} {}

    auto vtable_index() const { return m_vtable_index; }
    auto vtable_index(uint32_t vtable_index) {
        m_vtable_index = vtable_index;
        return this;
    }

    void generate(std::ostream& os) const override {
        os << "virtual ";
        generate_prototype(os);

        if (m_procedure.empty()) {
            os << " = 0;\n";
        } else {
            os << ";\n";
        }
    }

protected:
    uint32_t m_vtable_index{};
};

class StaticFunction : public Function {
public:
    explicit StaticFunction(std::string_view name) : Function{name} {}

    void generate(std::ostream& os) const override {
        os << "static ";
        generate_prototype(os);
        os << ";\n";
    }
};

class Enum : public Type {
public:
    explicit Enum(std::string_view name) : Type{name} {}

    auto value(std::string_view name, uint64_t value) {
        for (auto&& [val_name, val_val] : m_values) {
            if (val_name == name) {
                val_val = value;
                return this;
            }
        }

        m_values.emplace_back(name, value);
        return this;
    }

    auto type() const { return m_type; }
    auto type(Type* type) {
        m_type = type;
        return this;
    }

    auto&& values() const { return m_values; }
    auto&& values() { return m_values; }

    size_t size() const override {
        if (m_type == nullptr) {
            return sizeof(int);
        } else {
            return m_type->size();
        }
    }

    virtual void generate_forward_decl(std::ostream& os) const { os << "enum " << usable_name_decl() << ";\n"; }

    virtual void generate(std::ostream& os) const {
        os << "enum " << usable_name_decl();
        generate_type(os);
        os << " {\n";
        generate_enums(os);
        os << "};\n";
    }

protected:
    std::vector<std::tuple<std::string, uint64_t>> m_values{};
    Type* m_type{};

    void generate_type(std::ostream& os) const {
        if (m_type != nullptr) {
            os << " : ";
            m_type->generate_typename_for(os, this);
        }
    }

    void generate_enums(std::ostream& os) const {
        Indent _{os};

        for (auto&& [name, value] : m_values) {
            if (!m_type || 1ull << (m_type->size() * 8) > value)
                os << name << " = " << value << ",\n";
        }
    }
};

class EnumClass : public Enum {
public:
    explicit EnumClass(std::string_view name) : Enum{name} {}

    void generate_forward_decl(std::ostream& os) const override { os << "enum class " << usable_name_decl() << ";\n"; }
    void generate(std::ostream& os) const override {
        os << "enum class " << usable_name_decl();
        generate_type(os);
        os << " {\n";
        generate_enums(os);
        os << "};\n";
    }
};

class Struct : public Type {
public:
    explicit Struct(std::string_view name) : Type{name} {}

    auto variable(std::string_view name) { return find_or_add_unique<Variable>(name); }
    auto constant(std::string_view name) { return find_or_add_unique<Constant>(name); }

    // Returns a map of bit_offset, bitfield_variable at a given offset. Optionally, it will ignore a given variable
    // while constructing the map.
    auto bitfield(uintptr_t offset, Variable* ignore = nullptr) const {
        std::map<uintptr_t, Variable*> vars{};

        for (auto&& child : m_children) {
            if (auto var = dynamic_cast<Variable*>(child.get()); var != nullptr && var != ignore) {
                if (var->offset() == offset) {
                    vars[var->bit_offset()] = var;
                }
            }
        }

        return vars;
    }

    auto struct_(std::string_view name) { return find_or_add_unique<Struct>(name); }
    auto class_(std::string_view name) { return find_or_add_unique<Class>(name); }
    auto enum_(std::string_view name) { return find_or_add_unique<Enum>(name); }
    auto enum_class(std::string_view name) { return find_or_add_unique<EnumClass>(name); }
    auto function(std::string_view name) { return find_or_add_unique<Function>(name); }
    auto virtual_function(std::string_view name) { return find_or_add_unique<VirtualFunction>(name); }
    auto static_function(std::string_view name) { return find_or_add<StaticFunction>(name); }

    auto&& parents() const { return m_parents; }
    auto parent(Struct* parent) {
        if (std::find(m_parents.begin(), m_parents.end(), parent) == m_parents.end()) {
            m_parents.emplace_back(parent);
        }

        return this;
    }

    size_t size() const override {
        size_t size = 0;

        for (auto&& parent : m_parents) {
            size += parent->size();
        }

        for (auto&& var : get_all<Variable>()) {
            auto var_end = var->end();

            if (var_end > size) {
                size = var_end;
            }
        }

        if (size == 0 && has_any<VirtualFunction>()) {
            size += sizeof(uintptr_t);
        }

        return std::max<size_t>(size, m_size);
    }
    auto size(int size) {
        m_size = size;
        return this;
    }

    virtual void generate_forward_decl(std::ostream& os) const { os << "struct " << usable_name_decl() << ";\n"; }

    virtual void generate(std::ostream& os) const {
        generate_metadata(os);
        os << "struct " << usable_name_decl();
        generate_inheritance(os);
        os << " {\n";
        generate_internal(os);
        os << "}; // Size: 0x" << std::hex << size() << "\n";
    }

    struct Dependencies {
        std::unordered_set<Type*> hard{};
        std::unordered_set<Type*> soft{};
    };

    Dependencies dependencies() {
        Dependencies deps{};

        std::function<void(Object*)> add_dep{};
        std::function<void(Object*)> add_hard_dep = [&](Object* obj) {
            if (obj == nullptr || obj == this || obj->is_child_of(this)) {
                return;
            }

            if (auto parent = obj->direct_owner(); parent != nullptr && parent->is_a<Struct>()) {
                // Structs declared within structs need their parent struct to be a hard dependency.
                add_hard_dep(parent);
            } else if (obj->is_a<Struct>() || obj->is_a<Enum>()) {
                deps.hard.emplace(dynamic_cast<Type*>(obj));
            }
        };
        std::function<void(Object*)> add_soft_dep = [&](Object* obj) {
            if (obj == nullptr || obj == this || obj->is_child_of(this)) {
                return;
            }

            if (auto ref = dynamic_cast<Reference*>(obj)) {
                add_soft_dep(ref->to());
            } else if (obj->is_a<Struct>() || obj->is_a<Enum>() || obj->is_a<GenericType>()) {
                if (obj->is_a<Enum>()) {
                    // Enums are always hard dependencies.
                    add_hard_dep(obj);
                } else if (obj->is_a<GenericType>()) {
                    // GenericTypes may have hard or soft dependencies as template types.
                    add_dep(obj);
                } else if (auto parent = obj->direct_owner(); parent != nullptr && parent->is_a<Struct>()) {
                    // Structs declared within structs need their parent struct to be a hard dependency.
                    add_hard_dep(parent);
                } else {
                    deps.soft.emplace(dynamic_cast<Type*>(obj));
                }
            }
        };
        add_dep = [&](Object* obj) {
            if (auto arr = dynamic_cast<Array*>(obj)) {
                add_dep(arr->of());
            } else if (auto gt = dynamic_cast<GenericType*>(obj)) {
                for (auto&& type : gt->template_types()) {
                    add_dep(type);
                }
            } else if (auto ref = dynamic_cast<Reference*>(obj)) {
                add_soft_dep(ref->to());
            } else {
                add_hard_dep(obj);
            }
        };

        for (auto&& parent : parents()) {
            add_hard_dep(parent);
        }

        for (auto&& var : get_all<Variable>()) {
            add_dep(var->type());
        }

        for (auto&& var : get_all<Constant>()) {
            add_dep(var->type());
        }

        for (auto&& fn : get_all<Function>()) {
            for (auto&& param : fn->get_all<Parameter>()) {
                add_dep(param->type());
            }

            add_dep(fn->returns());
        }

        for (auto&& s : get_all<Struct>()) {
            auto s_deps = s->dependencies();

            for (auto&& dep : s_deps.hard) {
                add_hard_dep(dep);
            }

            for (auto&& dep : s_deps.soft) {
                add_soft_dep(dep);
            }
        }

        // If a type is both a hard and soft dependency, remove it from the soft dependencies.
        for (auto&& dep : deps.hard) {
            if (deps.soft.find(dep) != deps.soft.end()) {
                deps.soft.erase(dep);
            }
        }

        return deps;
    }

protected:
    std::vector<Struct*> m_parents{};

    int vtable_size() const {
        auto max_index = -1;

        if (!m_parents.empty()) {
            max_index = 0;

            for (auto&& parent : m_parents) {
                if (auto parent_vtable_size = parent->vtable_size(); parent_vtable_size != -1) {
                    max_index += parent_vtable_size;
                }
            }

            if (max_index == 0) {
                max_index = -1;
            }
        }

        for (auto&& child : get_all<VirtualFunction>()) {
            max_index = std::max<int>(max_index, child->vtable_index());
        }

        return max_index + 1;
    }

    template <typename T> T* find_in_parents(std::string_view name) {
        for (auto&& parent : m_parents) {
            if (auto obj = parent->find<T>(name)) {
                return obj;
            }
        }

        return nullptr;
    }

    template <typename T, typename... TArgs> T* find_or_add_unique(std::string_view name, TArgs... args) {
        if (auto search = find<T>(name); search != nullptr) {
            return search;
        }

        std::string fixed_name{};
        auto num_collisions = 0;
        auto has_collision = false;

        do {
            has_collision = false;

            if (find_in_parents<Object>(fixed_name.empty() ? name : fixed_name) != nullptr) {
                fixed_name = name;
                fixed_name += std::to_string(num_collisions);
                ++num_collisions;
                has_collision = true;
            }
        } while (has_collision);

        if (num_collisions == 0) {
            return add(std::make_unique<T>(name, args...));
        }

        return add(std::make_unique<T>(fixed_name, args...));
    }

    void generate_inheritance(std::ostream& os) const {
        if (m_parents.empty()) {
            return;
        }

        os << " : ";

        bool is_first = true;

        for (auto&& parent : m_parents) {
            if (is_first) {
                is_first = false;
            } else {
                os << ", ";
            }

            os << "public ";
            parent->generate_typename_for(os, this);
        }
    }

    void generate_bitfield(std::ostream& os, uintptr_t offset) const {
        auto last_bit = 0;
        Type* bitfield_type{};

        for (auto&& [bit_offset, var] : bitfield(offset)) {
            if (bit_offset - last_bit > 0) {
                var->type()->generate_typename_for(os, var);
                os << " pad_bitfield_" << std::hex << offset << "_" << std::hex << last_bit << " : " << std::dec
                   << bit_offset - last_bit << ";\n";
            }

            var->generate(os);
            last_bit = bit_offset + var->bit_size();
            bitfield_type = var->type();
        }

        // Fill out the remaining space in the bitfield if necessary.
        auto num_bits = bitfield_type->size() * CHAR_BIT;

        if (last_bit != num_bits) {
            auto bit_offset = num_bits;

            bitfield_type->generate_typename_for(os, nullptr);
            os << " pad_bitfield_" << std::hex << offset << "_" << std::hex << last_bit << " : " << std::dec
               << bit_offset - last_bit << ";\n";
        }
    }

    void generate_internal(std::ostream& os) const {
        Indent _{os};

        for (auto&& child : get_all<Enum>()) {
            child->generate(os);
            os << "\n";
        }

        for (auto&& child : get_all<Struct>()) {
            child->generate(os);
            os << "\n";
        }

        for (auto&& child : get_all<Constant>()) {
            child->generate(os);
            os << "\n";
        }

        std::unordered_map<std::uintptr_t, Variable*> var_map{};

        for (auto&& var : get_all<Variable>()) {
            var_map[var->offset()] = var;
        }

        auto max_offset = size();
        size_t offset = 0;

        // Skip over the vtable.
        if (has_any<VirtualFunction>()) {
            offset = sizeof(uintptr_t);
        }

        // Start off where the parent ends.
        if (!m_parents.empty()) {
            offset = 0;

            for (auto&& parent : m_parents) {
                offset += parent->size();
            }
        }

        auto last_offset = offset;

        while (offset < max_offset) {
            if (auto search = var_map.find(offset); search != var_map.end()) {
                auto var = search->second;

                // Skip variables where the user has not given us a valid size (forgot to set a type or the type is
                // unfinished).
                if (var->size() == 0) {
                    ++offset;
                    continue;
                }

                if (offset - last_offset > 0) {
                    os << "char pad_" << std::hex << last_offset << "[0x" << std::hex << offset - last_offset << "];\n";
                }

                if (var->is_bitfield()) {
                    generate_bitfield(os, offset);
                } else {
                    var->generate(os);
                }

                offset += var->size();
                last_offset = offset;
            } else {
                ++offset;
            }
        }

        if (offset - last_offset > 0) {
            os << "char pad_" << std::hex << last_offset << "[0x" << std::hex << offset - last_offset << "];\n";
        }

        if (has_any<Function>()) {
            // Generate normal functions normally.
            for (auto&& child : get_all<Function>()) {
                if (!child->is_a<VirtualFunction>()) {
                    child->generate(os);
                }
            }
        }

        if (has_any<VirtualFunction>()) {
            std::unordered_map<int, VirtualFunction*> vtable{};

            for (auto&& child : get_all<VirtualFunction>()) {
                auto vtable_index = child->vtable_index();

                vtable[vtable_index] = child;
            }

            auto vtable_index = 0;
            auto vtbl_size = vtable_size();

            for (; vtable_index < vtbl_size; ++vtable_index) {
                if (auto search = vtable.find(vtable_index); search != vtable.end()) {
                    search->second->generate(os);
                } else {
                    // Generate a default destructor to force addition of the vtable ptr.
                    if (vtable_index == 0) {
                        os << "virtual ~" << usable_name() << "() = default;\n";
                    } else {
                        os << "virtual void virtual_function_" << std::dec << vtable_index << "() = 0;\n";
                    }
                }
            }
        }
    }
};

inline Variable* Variable::append() {
    auto struct_ = owner<Struct>();
    uintptr_t highest_offset{};
    Variable* highest_var{};

    for (auto&& var : struct_->get_all<Variable>()) {
        if (var->offset() >= highest_offset && var != this) {
            highest_offset = var->offset();
            highest_var = var;
        }
    }

    if (highest_var != nullptr) {
        // Both bitfields of the same type.
        if (is_bitfield() && highest_var->is_bitfield() && m_type == highest_var->type()) {
            auto highest_bit = 0;
            auto bf = struct_->bitfield(highest_var->offset(), this);

            for (auto&& [bit_offset, bit_var] : bf) {
                if (bit_offset >= highest_bit && bit_var != this) {
                    highest_bit = bit_offset;
                    highest_var = bit_var;
                }
            }

            auto end_bit = highest_var->bit_offset() + highest_var->bit_size();

            if (end_bit + m_bit_size <= m_type->size() * CHAR_BIT) {
                // Squeeze into the remainign bits.
                m_offset = highest_var->offset();
            } else {
                // Not enough room, so start where the previous bitfield ended.
                m_offset = highest_var->end();
            }
        } else {
            m_offset = highest_var->end();
        }
    } else if (auto parents = struct_->parents(); !parents.empty()) {
        size_t size{};

        for (auto&& parent : parents) {
            size += parent->size();
        }

        m_offset = size;
    } else {
        m_offset = 0;
    }

    return this;
}

inline Variable* Variable::bit_append() {
    auto struct_ = owner<Struct>();
    uintptr_t highest_bit{};
    Variable* highest_var{};
    auto bf = struct_->bitfield(m_offset, this);

    for (auto&& [bit_offset, bit_var] : bf) {
        if (bit_offset >= highest_bit && bit_var != this) {
            highest_bit = bit_offset;
            highest_var = bit_var;
        }
    }

    if (highest_var != nullptr) {
        auto end_bit = highest_var->bit_offset() + highest_var->bit_size();

        m_bit_offset = end_bit;
    } else {
        m_bit_offset = 0;
    }

    return this;
}

class Class : public Struct {
public:
    explicit Class(std::string_view name) : Struct{name} {}

    void generate_forward_decl(std::ostream& os) const override { os << "class " << usable_name_decl() << ";\n"; }

    void generate(std::ostream& os) const override {
        os << "class " << usable_name_decl();
        generate_inheritance(os);
        os << " {\n";

        if (!m_children.empty()) {
            os << "public:\n";
        }

        generate_internal(os);

        os << "}; // Size: 0x" << std::hex << size() << "\n";
    }
};

class Namespace : public Typename {
public:
    explicit Namespace(std::string_view name) : Typename{name} {}

    auto type(std::string_view name) { return find_in_owners_or_add<Type>(name); }
    auto generic_type(std::string_view name) { return find_in_owners_or_add<GenericType>(name); }
    auto struct_(std::string_view name) { return find_or_add<Struct>(name); }
    auto class_(std::string_view name) { return find_or_add<Class>(name); }
    auto enum_(std::string_view name) { return find_or_add<Enum>(name); }
    auto enum_class(std::string_view name) { return find_or_add<EnumClass>(name); }
    auto namespace_(std::string_view name) { return find_or_add<Namespace>(name); }
};

class Sdk {
public:
    Sdk() = default;
    virtual ~Sdk() = default;

    auto global_ns() const { return m_global_ns.get(); }

    auto preamble(std::string_view preamble) {
        m_preamble = preamble;
        return this;
    }
    auto postamble(std::string_view postamble) {
        m_postamble = postamble;
        return this;
    }

    auto include(std::string_view header) {
        m_includes.emplace(header);
        return this;
    }
    auto include_local(std::string_view header) {
        m_local_includes.emplace(header);
        return this;
    }

    void generate(const std::filesystem::path& sdk_path) const {
        // erase the file_list.txt
        std::filesystem::remove(sdk_path / "file_list.txt");

        generate_namespace(sdk_path, m_global_ns.get());
    }

    const auto& header_extension() const { return m_header_extension; }
    auto header_extension(std::string_view ext) {
        m_header_extension = ext;
        return this;
    }

    const auto& source_extension() const { return m_source_extension; }
    auto source_extension(std::string_view ext) {
        m_source_extension = ext;
        return this;
    }

    const auto& generate_namespaces() { return m_generate_namespaces; }
    auto generate_namespaces(bool gen_ns) {
        m_generate_namespaces = gen_ns;
        return this;
    }

protected:
    std::unique_ptr<Namespace> m_global_ns{std::make_unique<Namespace>("")};
    std::string m_preamble{};
    std::string m_postamble{};
    std::set<std::string> m_includes{};
    std::set<std::string> m_local_includes{};
    std::string m_header_extension{".hpp"};
    std::string m_source_extension{".cpp"};
    bool m_generate_namespaces{true};

    template <typename T> void generate_header(const std::filesystem::path& sdk_path, T* obj) const {
        if (obj->skip_generation()) {
            return;
        }

        auto obj_inc_path = sdk_path / (obj->path() += m_header_extension);
        std::ofstream file_list{sdk_path / "file_list.txt", std::ios::app};
        file_list << "\"" << obj_inc_path.string() << "\" \\\n";
        std::filesystem::create_directories(obj_inc_path.parent_path());
        std::ofstream os{obj_inc_path};

        if (!m_preamble.empty()) {
            std::istringstream sstream{m_preamble};
            std::string line{};

            while (std::getline(sstream, line)) {
                os << "// " << line << "\n";
            }
        }

        os << "#pragma once\n";

        for (auto&& include : m_includes) {
            os << "#include <" << include << ">\n";
        }

        for (auto&& include : m_local_includes) {
            os << "#include \"" << include << "\"\n";
        }

        std::unordered_set<Type*> types_to_include{};
        std::unordered_set<Type*> types_to_forward_decl{};
        std::set<std::filesystem::path> includes{};

        if (auto s = dynamic_cast<Struct*>(obj)) {
            auto deps = s->dependencies();
            types_to_include = deps.hard;
            types_to_forward_decl = deps.soft;
        }

        for (auto&& ty : types_to_include) {
            includes.emplace(ty->path() += m_header_extension);
        }

        for (auto&& inc : includes) {
            os << "#include \"" << std::filesystem::relative(inc, obj->path().parent_path()).string() << "\"\n";
        }

        for (auto&& type : types_to_forward_decl) {
            auto owners = type->owners<Namespace>();

            if (owners.size() > 1 && m_generate_namespaces) {
                std::reverse(owners.begin(), owners.end());

                os << "namespace ";

                for (auto&& owner : owners) {
                    if (owner->usable_name().empty()) {
                        continue;
                    }

                    os << owner->usable_name();

                    if (owner != owners.back()) {
                        os << "::";
                    }
                }

                os << " {\n";
            }

            if (auto s = dynamic_cast<Struct*>(type)) {
                s->generate_forward_decl(os);
            } else if (auto e = dynamic_cast<Enum*>(type)) {
                e->generate_forward_decl(os);
            }

            if (owners.size() > 1 && m_generate_namespaces) {
                os << "}\n";
            }
        }

        auto owners = obj->template owners<Namespace>();

        if (owners.size() > 1 && m_generate_namespaces) {
            std::reverse(owners.begin(), owners.end());

            os << "namespace ";

            for (auto&& owner : owners) {
                if (owner->usable_name().empty()) {
                    continue;
                }

                os << owner->usable_name();

                if (owner != owners.back()) {
                    os << "::";
                }
            }

            os << " {\n";
        }

        os << "#pragma pack(push, 1)\n";
        obj->generate(os);
        os << "#pragma pack(pop)\n";

        if (owners.size() > 1 && m_generate_namespaces) {
            os << "}\n";
        }

        if (!m_postamble.empty()) {
            std::istringstream sstream{m_postamble};
            std::string line{};

            while (std::getline(sstream, line)) {
                os << "// " << line << "\n";
            }
        }
    }

    template <typename T> void generate_source(const std::filesystem::path& sdk_path, T* obj) const {
        if (obj->skip_generation()) {
            return;
        }

        // Skip generating a source file for an object with no functions.
        if (!obj->template has_any<Function>()) {
            return;
        }

        // Skip generating a source file for an object if all the functions it does have lack a procedure.
        std::unordered_set<Function*> functions{};
        obj->template get_all_in_children<Function>(functions);

        auto any_procedure = false;

        for (auto&& fn : functions) {
            if (!fn->procedure().empty()) {
                any_procedure = true;
                break;
            }
        }

        if (!any_procedure) {
            return;
        }

        auto obj_src_path = sdk_path / (obj->path() += m_source_extension);
        std::ofstream file_list{sdk_path / "file_list.txt", std::ios::app};
        file_list << "\"" << obj_src_path.string() << "\" \\\n";

        std::filesystem::create_directories(obj_src_path.parent_path());
        std::ofstream os{obj_src_path};

        if (!m_preamble.empty()) {
            std::istringstream sstream{m_preamble};
            std::string line{};

            while (std::getline(sstream, line)) {
                os << "// " << line << "\n";
            }
        }

        std::unordered_set<Type*> types_to_include{};

        if (auto s = dynamic_cast<Struct*>(obj)) {
            auto deps = s->dependencies();
            types_to_include = deps.hard;
            types_to_include.merge(deps.soft);
            types_to_include.emplace(s);
        }

        for (auto&& fn : functions) {
            auto deps = fn->dependencies();
            types_to_include.merge(deps);
        }

        std::set<std::filesystem::path> includes{};

        for (auto&& ty : types_to_include) {
            includes.emplace(ty->path() += m_header_extension);
        }

        for (auto&& inc : includes) {
            os << "#include \"" << std::filesystem::relative(inc, obj->path().parent_path()).string() << "\"\n";
        }

        for (auto&& fn : functions) {
            // Skip pure virtual functions.
            if (fn->is_a<VirtualFunction>() && fn->procedure().empty()) {
                continue;
            }

            fn->generate_source(os);
        }

        if (!m_postamble.empty()) {
            std::istringstream sstream{m_postamble};
            std::string line{};

            while (std::getline(sstream, line)) {
                os << "// " << line << "\n";
            }
        }
    }

    template <typename T> void generate(const std::filesystem::path& sdk_path, Namespace* ns) const {
        for (auto&& obj : ns->get_all<T>()) {
            generate_header(sdk_path, obj);
            generate_source(sdk_path, obj);
        }
    }

    void generate_namespace(const std::filesystem::path& sdk_path, Namespace* ns) const {
        generate<Enum>(sdk_path, ns);
        generate<Struct>(sdk_path, ns);

        for (auto&& child : ns->get_all<Namespace>()) {
            generate_namespace(sdk_path, child);
        }
    }
};
} // namespace genny

```

`include/GennyIda.hpp`:

```hpp
// SdkGenny - Genny.hpp - A single file header framework for generating C++ compatible SDKs
// https://github.com/cursey/sdkgenny
// GennyIda.hpp is an optional extra for SdkGenny that generates output intended to be consumed by IDA.

#pragma once

#include "Genny.hpp"

namespace genny::ida {
// Does a destructive transformation to the Sdk to make it's output parsable by IDA.
inline void transform(Sdk& sdk) {
    auto g = sdk.global_ns();
    std::unordered_set<EnumClass*> enum_classes{};

    // Make plain enum types for all enum classes.
    g->get_all_in_children<EnumClass>(enum_classes);

    // We have to remove the enum class from it's owner before we can add a normal enum with the same name to it.
    // Variables may still reference the enum class however so we must keep them alive until all variables have had
    // their types changed to the normal enum versions.
    std::vector<std::unique_ptr<Object>> enumclass_keepalive{};

    for (auto& e : enum_classes) {
        Enum* new_enum{};
        auto owner = e->direct_owner();

        if (auto ns_owner = dynamic_cast<Namespace*>(owner)) {
            enumclass_keepalive.emplace_back(ns_owner->remove(e));
            new_enum = ns_owner->enum_(e->name());
        } else if (auto owner_struct = dynamic_cast<Struct*>(owner)) {
            enumclass_keepalive.emplace_back(owner_struct->remove(e));
            new_enum = owner_struct->enum_(e->name());
        } else {
            continue;
        }

        for (auto&& [name, value] : e->values()) {
            new_enum->value(name, value);
        }

        new_enum->type(e->type());
    }

    std::unordered_set<Type*> types{};
    std::unordered_map<Type*, std::string> new_names{};

    g->get_all_in_children<Type>(types);

    // Go through all the types making new names for them (but not setting them yet) and removing things like their
    // functions/constants and fixing their enum class types etc.
    for (auto&& t : types) {
        if (!t->is_a<Struct>() && !t->is_a<Enum>()) {
            continue;
        }

        auto owners = t->owners<Object>();
        auto new_name = t->usable_name();

        for (auto&& owner : owners) {
            if (!owner->usable_name().empty()) {
                new_name = owner->usable_name() + "::" + new_name;
            }
        }

        new_names.emplace(t, std::move(new_name));

        t->simple_typename_generation(true);
        t->remove_all<Function>();
        t->remove_all<Constant>();

        // Convert all enum classes to normal enums
        for (auto&& v : t->get_all<Variable>()) {
            auto v_t = v->type();

            if (!v_t->is_a<EnumClass>()) {
                continue;
            }

            auto owner = v_t->direct_owner();

            if (auto owner_ns = dynamic_cast<Namespace*>(owner)) {
                v->type(owner_ns->enum_(v_t->name()));
            } else if (auto owner_struct = dynamic_cast<Struct*>(owner)) {
                v->type(owner_struct->enum_(v_t->name()));
            }
        }
    }

    // Now that all the new names have been built we can set them.
    for (auto&& [t, name] : new_names) {
        t->usable_name = [new_name = std::move(name)] { return new_name; };

        if (!t->direct_owner()->is_a<Struct>()) {
            t->usable_name_decl = t->usable_name;
        }
    }

    sdk.generate_namespaces(false);
}

} // namespace genny::ida

```

`include/GennyParser.hpp`:

```hpp
// SdkGenny - Genny.hpp - A single file header framework for generating C++ compatible SDKs
// https://github.com/cursey/sdkgenny
// GennyParser.hpp is an optional extra for SdkGenny that parses .genny formatted files into a usable genny::Sdk.

#pragma once

#include <cstdlib>
#include <optional>

#include <tao/pegtl.hpp>

#include "Genny.hpp"

namespace genny::parser {
using namespace tao::pegtl;

struct ShortComment : disable<two<'/'>, until<eolf>> {};
struct LongComment : disable<one<'/'>, one<'*'>, until<seq<one<'*'>, one<'/'>>>> {};
struct Comment : sor<ShortComment, LongComment> {};
struct Sep : sor<space, Comment> {};
struct Seps : star<Sep> {};

struct Endl : star<one<';'>> {};

struct HexNum : seq<one<'0'>, one<'x'>, plus<xdigit>> {};
struct DecNum : plus<digit> {};
struct Num : sor<HexNum, DecNum> {};

struct Metadata : plus<not_one<',', ']'>> {};
struct MetadataDecl : if_must<two<'['>, Seps, list<Metadata, one<','>, Sep>, Seps, two<']'>> {};

struct IncludeId : TAO_PEGTL_STRING("#include") {};
struct IncludePath : plus<not_one<'"'>> {};
struct IncludeDecl : if_must<IncludeId, Seps, one<'"'>, IncludePath, one<'"'>> {};

struct NsId : TAO_PEGTL_STRING("namespace") {};
struct NsName : identifier {};
struct NsNameList : list_must<NsName, one<'.'>, Sep> {};
struct NsDecl : if_must<NsId, Seps, opt<NsNameList>> {};
struct NsExpr;
struct EnumExpr;
struct StructExpr;
struct NsExprs : list<sor<Sep, NsExpr, EnumExpr, StructExpr>, Seps> {};
struct NsExpr : if_must<NsDecl, Seps, one<'{'>, Seps, opt<NsExprs>, Seps, one<'}'>, Endl> {};

struct TypeId : TAO_PEGTL_STRING("type") {};
struct TypeName : identifier {};
struct TypeSize : Num {};
struct TypeDecl : if_must<TypeId, Seps, TypeName, Seps, TypeSize, Seps, opt<MetadataDecl>, Endl> {};

struct EnumVal : Num {};
struct EnumValName : identifier {};
struct EnumValDecl : seq<EnumValName, Seps, one<'='>, Seps, EnumVal> {};
struct EnumVals : seq<list<EnumValDecl, one<','>, Sep>, opt<one<','>>> {};
struct EnumId : TAO_PEGTL_STRING("enum") {};
struct EnumClassId : TAO_PEGTL_STRING("class") {};
struct EnumName : identifier {};
struct EnumType : identifier {};
struct EnumDecl : seq<EnumId, Seps, opt<EnumClassId>, Seps, EnumName, Seps, opt<one<':'>, Seps, EnumType>, Seps, one<'{'>> {};
struct EnumExpr : if_must<EnumDecl, Seps, EnumVals, Seps, one<'}'>, Endl> {};

struct StructPrivacyId : sor<TAO_PEGTL_STRING("public"), TAO_PEGTL_STRING("private"), TAO_PEGTL_STRING("protected")> {};
struct StructId : sor<TAO_PEGTL_STRING("struct"), TAO_PEGTL_STRING("class")> {};
struct StructName : identifier {};
struct StructParentPart : identifier {};
struct StructParent : seq<opt<disable<StructPrivacyId>>, Seps, list_must<StructParentPart, one<'.'>>> {};
struct StructParentList : list<StructParent, one<','>, Sep> {};
struct StructParentListDecl : seq<one<':'>, Seps, StructParentList> {};
struct StructSize : Num {};
struct StructDecl : seq<StructId, Seps, StructName, Seps, opt<StructParentListDecl>, Seps, opt<StructSize>, Seps, one<'{'>> {};
struct StructPrivacyDecl : disable<StructPrivacyId, Seps, one<':'>> {};
struct StructExpr;
struct FnDecl;
struct VarDecl;
struct StructExprs : list<sor<StructPrivacyDecl, EnumExpr, StructExpr, FnDecl, VarDecl>, Seps> {};
struct StructExpr : if_must<StructDecl, Seps, opt<StructExprs>, Seps, one<'}'>, Endl> {};

struct VarTypeNamePart : identifier {};
struct VarTypeName : list_must<VarTypeNamePart, one<'.'>> {};
struct VarTypePtr : one<'*'> {};
struct VarTypeArrayCount : Num {};
struct VarTypeArray : if_must<one<'['>, VarTypeArrayCount, one<']'>> {};
struct VarTypeHintId : sor<TAO_PEGTL_STRING("struct"), TAO_PEGTL_STRING("class"), TAO_PEGTL_STRING("enum class"),
                           TAO_PEGTL_STRING("enum")> {};
struct VarType : seq<opt<VarTypeHintId>, Seps, VarTypeName, Seps, star<VarTypePtr>, star<VarTypeArray>> {};
struct VarName : identifier {};
struct VarOffset : Num {};
struct VarOffsetDecl : if_must<one<'@'>, Seps, VarOffset> {};
struct VarDelta : Num {};
struct VarDeltaDecl : if_must<one<'+'>, Seps, VarDelta> {};
struct VarOffsetDeltaDecl : sor<VarOffsetDecl, VarDeltaDecl> {};
struct VarBitSize : Num {};
struct VarBitSizeDecl : seq<one<':'>, Seps, VarBitSize> {};
struct VarDecl : seq<VarType, Seps, VarName, star<VarTypeArray>, Seps, opt<VarBitSizeDecl>, Seps,
                     opt<VarOffsetDeltaDecl>, Seps, opt<MetadataDecl>, Endl> {};

struct FnVoidId : TAO_PEGTL_STRING("void") {};
struct FnRetType : VarType {};
struct FnRet : sor<FnVoidId, FnRetType> {};
struct FnName : identifier {};
struct FnParamType : VarType {};
struct FnParamName : identifier {};
struct FnParam : seq<FnParamType, Seps, FnParamName> {};
struct FnParamList : list_must<FnParam, one<','>, Sep> {};
struct FnParams : if_must<one<'('>, Seps, opt<FnParamList>, Seps, one<')'>> {};
struct FnStaticId : TAO_PEGTL_STRING("static") {};
struct FnVirtualId : TAO_PEGTL_STRING("virtual") {};
struct FnPrefix : sor<FnStaticId, FnVirtualId> {};
struct FnVirtualIndex : Num {};
struct FnDecl : seq<opt<FnPrefix>, Seps, FnRet, Seps, FnName, Seps, FnParams, Seps,
                    opt_must<one<'@'>, Seps, FnVirtualIndex>, Endl> {};

struct StaticAssert : disable<TAO_PEGTL_STRING("static_assert"), until<one<';'>>> {};

struct Decl : sor<IncludeDecl, TypeDecl, NsExpr, EnumExpr, StructExpr, StaticAssert> {};
struct Grammar : until<eof, sor<eol, Sep, Decl>> {};

struct State {
    std::filesystem::path filepath{std::filesystem::current_path()};
    std::vector<Object*> parents{};
    std::stack<int> namespace_depth{};

    std::vector<std::string> metadata_parts{};
    std::vector<std::string> metadata{};

    std::string include_path{};

    std::vector<std::string> ns_parts{};
    std::vector<std::string> ns{};

    std::string type_name{};
    int type_size{};

    std::string enum_name{};
    std::string enum_type{};
    bool enum_class{};
    std::string enum_val_name{};
    uint32_t enum_val{};
    std::vector<std::tuple<std::string, uint64_t>> enum_vals{};

    std::string struct_name{};
    std::vector<std::string> struct_parent{};
    std::vector<genny::Struct*> struct_parents{};
    std::optional<size_t> struct_size{};
    bool struct_is_class{};

    genny::Type* cur_type{};
    std::string var_type_hint{};
    std::vector<std::string> var_type{};
    std::optional<size_t> var_type_array_count{};
    std::vector<size_t> var_type_array_counts{};
    std::string var_name{};
    std::optional<uintptr_t> var_offset{};
    std::optional<uintptr_t> var_delta{};
    std::optional<uintptr_t> var_bit_offset{};
    std::optional<size_t> var_bit_size{};

    genny::Type* fn_ret_type{};
    std::string fn_name{};
    bool fn_is_static{};
    bool fn_is_virtual{};
    std::optional<uint32_t> fn_virtual_index{};

    struct Param {
        genny::Type* type{};
        std::string name{};
    };

    Param cur_param{};
    std::vector<Param> fn_params{};

    // Searches for the type identified by a vector of names.
    template <typename T> T* lookup(const std::vector<std::string>& names) {
        std::function<T*(Object*, int)> search = [&](Object* parent, int i) -> T* {
            if (names.empty()) {
                return dynamic_cast<T*>(parents.front());
            } else if (i >= names.size()) {
                return nullptr;
            }

            const auto& name = names[i];

            // Search for the name.
            auto child = parent->find<Object>(name);

            if (child == nullptr) {
                return nullptr;
            }

            // We found the name. Is this the type we were looking for?
            if (i == names.size() - 1) {
                return dynamic_cast<T*>(child);
            }

            return search(child, ++i);
        };

        for (auto it = parents.rbegin(); it != parents.rend(); ++it) {
            if (auto type = search(*it, 0)) {
                return type;
            }
        }

        return nullptr;
    }
};

template <typename Rule> struct Action : nothing<Rule> {};

template <> struct Action<Metadata> {
    template <typename Input> static void apply(const Input& in, State& s) {
        s.metadata_parts.emplace_back(in.string_view());
    }
};

template <> struct Action<MetadataDecl> {
    template <typename Input> static void apply(const Input& in, State& s) { s.metadata = std::move(s.metadata_parts); }
};

template <> struct Action<IncludePath> {
    template <typename Input> static void apply(const Input& in, State& s) { s.include_path = in.string_view(); }
};

template <> struct Action<IncludeDecl> {
    template <typename Input> static void apply(const Input& in, State& s) {
        auto backup_filepath = s.filepath;

        try {
            auto newstate = std::make_unique<State>();
            auto include_path = std::move(s.include_path);
            newstate->filepath = (s.filepath.has_extension() ? s.filepath.parent_path() : s.filepath) / include_path;
            newstate->parents.push_back(s.parents.front());
            file_input f{newstate->filepath};

            if (!parse<genny::parser::Grammar, genny::parser::Action>(f, *newstate)) {
                throw parse_error{"Failed to parse file '" + include_path + "'", in};
            }
        } catch (const parse_error& e) {
            throw e;
        } catch (const std::exception& e) {
            throw parse_error{std::string{"Failed to include file: "} + e.what(), in};
        }

        s.filepath = backup_filepath;
    }
};

template <> struct Action<NsName> {
    template <typename Input> static void apply(const Input& in, State& s) {
        s.ns_parts.emplace_back(in.string_view());
    }
};

template <> struct Action<NsNameList> {
    template <typename Input> static void apply(const Input& in, State& s) { s.ns = std::move(s.ns_parts); }
};

template <> struct Action<NsDecl> {
    template <typename Input> static void apply(const Input& in, State& s) {
        if (auto cur_ns = dynamic_cast<Namespace*>(s.parents.back())) {
            auto depth = 0;

            for (auto&& ns : s.ns) {
                cur_ns = cur_ns->namespace_(ns);
                s.parents.push_back(cur_ns);
                ++depth;
            }

            s.namespace_depth.push(depth);
            s.ns.clear();
        } else {
            throw parse_error{"Can only declare a namespace within the context of another namespace", in};
        }
    }
};

template <> struct Action<NsExpr> {
    template <typename Input> static void apply(const Input& in, State& s) {
        auto depth = s.namespace_depth.top();

        s.namespace_depth.pop();

        for (auto i = 0; i < depth; ++i) {
            s.parents.pop_back();
        }
    }
};

template <> struct Action<TypeSize> {
    template <typename Input> static void apply(const Input& in, State& s) {
        s.type_size = std::stoi(in.string(), nullptr, 0);
    }
};

template <> struct Action<TypeName> {
    template <typename Input> static void apply(const Input& in, State& s) { s.type_name = in.string_view(); }
};

template <> struct Action<TypeDecl> {
    template <typename Input> static void apply(const Input& in, State& s) {
        if (auto ns = dynamic_cast<Namespace*>(s.parents.back())) {
            auto type = ns->type(s.type_name);

            type->size(s.type_size);

            if (!s.metadata.empty()) {
                type->metadata() = std::move(s.metadata);
            }

            s.type_name.clear();
            s.type_size = -1;
        } else {
            throw parse_error{"Can only declare a type within the context of a namespace", in};
        }
    }
};

template <> struct Action<EnumName> {
    template <typename Input> static void apply(const Input& in, State& s) { s.enum_name = in.string_view(); }
};

template <> struct Action<EnumType> {
    template <typename Input> static void apply(const Input& in, State& s) { s.enum_type = in.string_view(); }
};

template <> struct Action<EnumClassId> {
    template <typename Input> static void apply(const Input& in, State& s) { s.enum_class = true; }
};

template <> struct Action<EnumExpr> {
    template <typename Input> static void apply(const Input& in, State& s) {
        Enum* enum_{};

        if (auto p = dynamic_cast<Namespace*>(s.parents.back())) {
            if (s.enum_class) {
                enum_ = p->enum_class(s.enum_name);
            } else {
                enum_ = p->enum_(s.enum_name);
            }
        } else if (auto p = dynamic_cast<Struct*>(s.parents.back())) {
            if (s.enum_class) {
                enum_ = p->enum_class(s.enum_name);
            } else {
                enum_ = p->enum_(s.enum_name);
            }
        } else {
            throw parse_error{"Cannot create an enum here. Parent must be a namespace or a struct.", in};
        }

        for (auto&& [name, val] : s.enum_vals) {
            enum_->value(name, val);
        }

        s.enum_vals.clear();
        s.enum_name.clear();
        s.enum_type.clear();
        s.enum_class = false;
    }
};

template <> struct Action<EnumVal> {
    template <typename Input> static void apply(const Input& in, State& s) {
        s.enum_val = std::stoul(in.string(), nullptr, 0);
    }
};

template <> struct Action<EnumValName> {
    template <typename Input> static void apply(const Input& in, State& s) { s.enum_val_name = in.string_view(); }
};

template <> struct Action<EnumValDecl> {
    template <typename Input> static void apply(const Input& in, State& s) {
        s.enum_vals.emplace_back(s.enum_val_name, s.enum_val);
    }
};

template <> struct Action<StructId> {
    template <typename Input> static void apply(const Input& in, State& s) {
        s.struct_is_class = in.string_view() == "class";
    }
};

template <> struct Action<StructName> {
    template <typename Input> static void apply(const Input& in, State& s) { s.struct_name = in.string_view(); }
};

template <> struct Action<StructParentPart> {
    template <typename Input> static void apply(const Input& in, State& s) {
        s.struct_parent.emplace_back(in.string_view());
    }
};

template <> struct Action<StructParent> {
    template <typename Input> static void apply(const Input& in, State& s) {
        auto parent = s.lookup<genny::Struct>(s.struct_parent);

        if (parent == nullptr) {
            throw parse_error{"Can't find parent struct type with name '" + s.struct_parent.back() + "'", in};
        }

        s.struct_parents.emplace_back(parent);
        s.struct_parent.clear();
    }
};

template <> struct Action<StructSize> {
    template <typename Input> static void apply(const Input& in, State& s) {
        s.struct_size = std::stoull(in.string(), nullptr, 0);
    }
};

template <> struct Action<StructDecl> {
    template <typename Input> static void apply(const Input& in, State& s) {
        Struct* struct_{};

        if (auto p = dynamic_cast<Namespace*>(s.parents.back())) {
            if (s.struct_is_class) {
                struct_ = p->class_(s.struct_name);
            } else {
                struct_ = p->struct_(s.struct_name);
            }
        } else if (auto p = dynamic_cast<Struct*>(s.parents.back())) {
            if (s.struct_is_class) {
                struct_ = p->class_(s.struct_name);
            } else {
                struct_ = p->struct_(s.struct_name);
            }
        } else {
            throw parse_error{"Structs can only be declared within the context of a namespace or another struct", in};
        }

        for (auto&& parent : s.struct_parents) {
            struct_->parent(parent);
        }

        if (s.struct_size) {
            struct_->size(*s.struct_size);
        }

        s.parents.push_back(struct_);
        s.struct_name.clear();
        s.struct_parents.clear();
        s.struct_size = std::nullopt;
        s.struct_is_class = false;
    }
};

template <> struct Action<StructExpr> {
    template <typename Input> static void apply(const Input& in, State& s) { s.parents.pop_back(); }
};

template <> struct Action<VarTypeHintId> {
    template <typename Input> static void apply(const Input& in, State& s) { s.var_type_hint = in.string_view(); }
};

template <> struct Action<VarTypeNamePart> {
    template <typename Input> static void apply(const Input& in, State& s) {
        s.var_type.emplace_back(in.string_view());
    }
};

template <> struct Action<VarTypeName> {
    template <typename Input> static void apply(const Input& in, State& s) {
        s.cur_type = s.lookup<Type>(s.var_type);

        if (s.cur_type == nullptr && !s.var_type_hint.empty()) {
            auto owner_type = s.var_type;
            owner_type.pop_back();
            auto owner = s.lookup<Namespace>(owner_type);

            if (owner != nullptr) {
                if (s.var_type_hint == "struct") {
                    s.cur_type = owner->struct_(s.var_type.back());
                } else if (s.var_type_hint == "class") {
                    s.cur_type = owner->class_(s.var_type.back());
                } else if (s.var_type_hint == "enum") {
                    s.cur_type = owner->enum_(s.var_type.back());
                } else if (s.var_type_hint == "enum class") {
                    s.cur_type = owner->enum_class(s.var_type.back());
                }
            }
        }

        if (s.cur_type == nullptr) {
            throw parse_error{"Can't find type with name '" + s.var_type.back() + "'", in};
        }

        s.var_type.clear();
        s.var_type_array_counts.clear();
    }
};

template <> struct Action<VarTypePtr> {
    template <typename Input> static void apply(const Input& in, State& s) {
        if (s.cur_type == nullptr) {
            throw parse_error{"The current type is null", in};
        }

        s.cur_type = s.cur_type->ptr();
    }
};

template <> struct Action<VarTypeArrayCount> {
    template <typename Input> static void apply(const Input& in, State& s) {
        s.var_type_array_count = std::stoull(in.string(), nullptr, 0);
    }
};

template <> struct Action<VarTypeArray> {
    template <typename Input> static void apply(const Input& in, State& s) {
        if (!s.var_type_array_count) {
            throw parse_error{"The array count is invalid", in};
        }

        s.var_type_array_counts.emplace_back(*s.var_type_array_count);
        s.var_type_array_count = std::nullopt;
    }
};

template <> struct Action<VarName> {
    template <typename Input> static void apply(const Input& in, State& s) { s.var_name = in.string_view(); }
};

template <> struct Action<VarOffset> {
    template <typename Input> static void apply(const Input& in, State& s) {
        s.var_offset = std::stoull(in.string(), nullptr, 0);
    }
};

template <> struct Action<VarDelta> {
    template <typename Input> static void apply(const Input& in, State& s) {
        s.var_delta = std::stoull(in.string(), nullptr, 0);
    }
};

template <> struct Action<VarBitSize> {
    template <typename Input> static void apply(const Input& in, State& s) {
        s.var_bit_size = std::stoull(in.string(), nullptr, 0);
    }
};

template <> struct Action<VarDecl> {
    template <typename Input> static void apply(const Input& in, State& s) {
        if (s.cur_type == nullptr) {
            throw parse_error{"The current type is null", in};
        }

        // Reverse the order because we want to adhear to how multi-dimensional arrays are declared in C/C++.
        std::reverse(s.var_type_array_counts.begin(), s.var_type_array_counts.end());

        for (auto&& count : s.var_type_array_counts) {
            s.cur_type = s.cur_type->array_(count);
        }

        s.var_type_array_counts.clear();

        if (auto struct_ = dynamic_cast<Struct*>(s.parents.back())) {
            auto var = struct_->variable(s.var_name);

            var->type(s.cur_type);

            if (s.var_bit_size) {
                var->bit_size(*s.var_bit_size);
            }

            if (s.var_offset) {
                var->offset(*s.var_offset);
            } else {
                var->append();

                if (s.var_delta) {
                    var->offset(var->offset() + *s.var_delta);
                }
            }

            if (var->is_bitfield()) {
                var->bit_append();
            }

            if (!s.metadata.empty()) {
                var->metadata() = std::move(s.metadata);
            }

            s.var_name.clear();
            s.cur_type = nullptr;
            s.var_offset = std::nullopt;
            s.var_delta = std::nullopt;
            s.var_bit_size = std::nullopt;
            s.var_bit_offset = std::nullopt;
            s.var_type_hint.clear();
        } else {
            throw parse_error{"Can't declare a variable outside of a struct", in};
        }
    }
};

template <> struct Action<FnRetType> {
    template <typename Input> static void apply(const Input& in, State& s) { s.fn_ret_type = s.cur_type; }
};

template <> struct Action<FnName> {
    template <typename Input> static void apply(const Input& in, State& s) { s.fn_name = in.string_view(); }
};

template <> struct Action<FnParamType> {
    template <typename Input> static void apply(const Input& in, State& s) { s.cur_param.type = s.cur_type; }
};

template <> struct Action<FnParamName> {
    template <typename Input> static void apply(const Input& in, State& s) { s.cur_param.name = in.string_view(); }
};

template <> struct Action<FnParam> {
    template <typename Input> static void apply(const Input& in, State& s) {
        s.fn_params.emplace_back(std::move(s.cur_param));
    }
};

template <> struct Action<FnStaticId> {
    template <typename Input> static void apply(const Input& in, State& s) { s.fn_is_static = true; }
};

template <> struct Action<FnVirtualId> {
    template <typename Input> static void apply(const Input& in, State& s) { s.fn_is_virtual = true; }
};

template <> struct Action<FnVirtualIndex> {
    template <typename Input> static void apply(const Input& in, State& s) {
        if (!s.fn_is_virtual) {
            throw parse_error{"Only virtual methods can specify a virtual index", in};
        }

        s.fn_virtual_index = std::stoul(in.string(), nullptr, 0);
    }
};

template <> struct Action<FnDecl> {
    template <typename Input> static void apply(const Input& in, State& s) {
        if (auto struct_ = dynamic_cast<Struct*>(s.parents.back())) {
            Function* fn{};

            if (s.fn_is_static) {
                fn = struct_->static_function(s.fn_name);
            } else if (s.fn_is_virtual) {
                fn = struct_->virtual_function(s.fn_name);

                if (s.fn_virtual_index) {
                    dynamic_cast<VirtualFunction*>(fn)->vtable_index(*s.fn_virtual_index);
                }
            } else {
                fn = struct_->function(s.fn_name);
            }

            if (s.fn_ret_type) {
                fn->returns(s.fn_ret_type);
            }

            fn->defined(false);

            for (auto&& param : s.fn_params) {
                fn->param(param.name)->type(param.type);
            }

            s.fn_name.clear();
            s.fn_ret_type = nullptr;
            s.fn_params.clear();
            s.fn_is_static = false;
            s.fn_is_virtual = false;
            s.fn_virtual_index = std::nullopt;
        } else {
            throw parse_error{"Can't declare a function outside of a struct", in};
        }
    }
};
} // namespace genny::parser

```

`vcpkg.json`:

```json
{
  "$cmkr": "This file is automatically generated from cmake.toml - DO NOT EDIT",
  "$cmkr-url": "https://github.com/build-cpp/cmkr",
  "$schema": "https://raw.githubusercontent.com/microsoft/vcpkg/master/scripts/vcpkg.schema.json",
  "dependencies": [
    "pegtl"
  ],
  "description": "",
  "name": "sdkgenny",
  "version-string": ""
}

```