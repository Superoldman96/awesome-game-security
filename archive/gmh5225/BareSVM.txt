Project Path: arc_gmh5225_BareSVM_t5guj7bk

Source Tree:

```txt
arc_gmh5225_BareSVM_t5guj7bk
├── Cargo.lock
├── Cargo.toml
├── README.md
├── build.rs
└── src
    ├── hv.rs
    ├── lib.rs
    ├── segments.rs
    ├── structs.rs
    ├── utils.rs
    ├── vmcb.rs
    ├── vmexit.rs
    ├── vmlaunch.asm
    └── vmmcall.rs

```

`Cargo.lock`:

```lock
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "aho-corasick"
version = "1.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e60d3430d3a69478ad0993f19238d2df97c507009a52b3c10addcd7f6bcb916"
dependencies = [
 "memchr",
]

[[package]]
name = "anstream"
version = "0.6.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "301af1932e46185686725e0fad2f8f2aa7da69dd70bf6ecc44d6b703844a3933"
dependencies = [
 "anstyle",
 "anstyle-parse",
 "anstyle-query",
 "anstyle-wincon",
 "colorchoice",
 "is_terminal_polyfill",
 "utf8parse",
]

[[package]]
name = "anstyle"
version = "1.0.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "862ed96ca487e809f1c8e5a8447f6ee2cf102f846893800b20cebdf541fc6bbd"

[[package]]
name = "anstyle-parse"
version = "0.2.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4e7644824f0aa2c7b9384579234ef10eb7efb6a0deb83f9630a49594dd9c15c2"
dependencies = [
 "utf8parse",
]

[[package]]
name = "anstyle-query"
version = "1.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6c8bdeb6047d8983be085bab0ba1472e6dc604e7041dbf6fcd5e71523014fae9"
dependencies = [
 "windows-sys 0.59.0",
]

[[package]]
name = "anstyle-wincon"
version = "3.0.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "403f75924867bb1033c59fbf0797484329750cfbe3c4325cd33127941fabc882"
dependencies = [
 "anstyle",
 "once_cell_polyfill",
 "windows-sys 0.59.0",
]

[[package]]
name = "anyhow"
version = "1.0.98"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e16d2d3311acee920a9eb8d33b8cbc1787ce4a264e85f964c2404b969bdcd487"

[[package]]
name = "bindgen"
version = "0.69.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "271383c67ccabffb7381723dea0672a673f292304fcb45c01cc648c7a8d58088"
dependencies = [
 "bitflags 2.9.1",
 "cexpr",
 "clang-sys",
 "itertools 0.12.1",
 "lazy_static",
 "lazycell",
 "log",
 "prettyplease",
 "proc-macro2",
 "quote",
 "regex",
 "rustc-hash",
 "shlex",
 "syn",
 "which",
]

[[package]]
name = "bit_field"
version = "0.10.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc827186963e592360843fb5ba4b973e145841266c1357f7180c43526f2e5b61"

[[package]]
name = "bitfield"
version = "0.19.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "db1bcd90f88eabbf0cadbfb87a45bceeaebcd3b4bc9e43da379cd2ef0162590d"
dependencies = [
 "bitfield-macros",
]

[[package]]
name = "bitfield-macros"
version = "0.19.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3787a07661997bfc05dd3431e379c0188573f78857080cf682e1393ab8e4d64c"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "bitflags"
version = "1.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"

[[package]]
name = "bitflags"
version = "2.9.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1b8e56985ec62d17e9c1001dc89c88ecd7dc08e47eba5ec7c29c7b5eeecde967"

[[package]]
name = "camino"
version = "1.1.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0da45bc31171d8d6960122e222a67740df867c1dd53b4d51caa297084c185cab"
dependencies = [
 "serde",
]

[[package]]
name = "cargo-platform"
version = "0.1.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e35af189006b9c0f00a064685c727031e3ed2d8020f7ba284d78cc2671bd36ea"
dependencies = [
 "serde",
]

[[package]]
name = "cargo_metadata"
version = "0.18.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2d886547e41f740c616ae73108f6eb70afe6d940c7bc697cb30f13daec073037"
dependencies = [
 "camino",
 "cargo-platform",
 "semver",
 "serde",
 "serde_json",
 "thiserror",
]

[[package]]
name = "cc"
version = "1.2.29"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c1599538de2394445747c8cf7935946e3cc27e9625f889d979bfb2aaf569362"
dependencies = [
 "shlex",
]

[[package]]
name = "cexpr"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6fac387a98bb7c37292057cffc56d62ecb629900026402633ae9160df93a8766"
dependencies = [
 "nom",
]

[[package]]
name = "cfg-if"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9555578bc9e57714c812a1f84e4fc5b4d21fcb063490c624de019f7464c91268"

[[package]]
name = "clang-sys"
version = "1.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b023947811758c97c59bf9d1c188fd619ad4718dcaa767947df1cadb14f39f4"
dependencies = [
 "glob",
 "libc",
 "libloading",
]

[[package]]
name = "clap"
version = "4.5.41"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "be92d32e80243a54711e5d7ce823c35c41c9d929dc4ab58e1276f625841aadf9"
dependencies = [
 "clap_builder",
 "clap_derive",
]

[[package]]
name = "clap-cargo"
version = "0.14.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "23b2ea69cefa96b848b73ad516ad1d59a195cdf9263087d977f648a818c8b43e"
dependencies = [
 "anstyle",
 "clap",
]

[[package]]
name = "clap_builder"
version = "4.5.41"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "707eab41e9622f9139419d573eca0900137718000c517d47da73045f54331c3d"
dependencies = [
 "anstream",
 "anstyle",
 "clap_lex",
 "strsim",
]

[[package]]
name = "clap_derive"
version = "4.5.41"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ef4f52386a59ca4c860f7393bcf8abd8dfd91ecccc0f774635ff68e92eeef491"
dependencies = [
 "heck",
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "clap_lex"
version = "0.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b94f61472cee1439c0b966b47e3aca9ae07e45d070759512cd390ea2bebc6675"

[[package]]
name = "colorchoice"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b05b61dc5112cbb17e4b6cd61790d9845d13888356391624cbe7e41efeac1e75"

[[package]]
name = "either"
version = "1.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "48c757948c5ede0e46177b7add2e67155f70e33c07fea8284df6576da70b3719"

[[package]]
name = "errno"
version = "0.3.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "778e2ac28f6c47af28e4907f13ffd1e1ddbd400980a9abd7c8df189bf578a5ad"
dependencies = [
 "libc",
 "windows-sys 0.60.2",
]

[[package]]
name = "glob"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a8d1add55171497b4705a648c6b583acafb01d58050a51727785f0b2c8e0a2b2"

[[package]]
name = "heck"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2304e00983f87ffb38b55b444b5e3b60a884b5d30c0fca7d82fe33449bbe55ea"

[[package]]
name = "home"
version = "0.5.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589533453244b0995c858700322199b2becb13b627df2851f64a2775d024abcf"
dependencies = [
 "windows-sys 0.59.0",
]

[[package]]
name = "hv"
version = "0.1.0"
dependencies = [
 "bitfield",
 "static_assertions",
 "wdk",
 "wdk-alloc",
 "wdk-build",
 "wdk-macros",
 "wdk-panic",
 "wdk-sys",
 "x86",
 "x86_64",
]

[[package]]
name = "is_terminal_polyfill"
version = "1.70.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7943c866cc5cd64cbc25b2e01621d07fa8eb2a1a23160ee81ce38704e97b8ecf"

[[package]]
name = "itertools"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ba291022dbbd398a455acf126c1e341954079855bc60dfdda641363bd6922569"
dependencies = [
 "either",
]

[[package]]
name = "itertools"
version = "0.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "413ee7dfc52ee1a4949ceeb7dbc8a33f2d6c088194d9f922fb8318faf1f01186"
dependencies = [
 "either",
]

[[package]]
name = "itoa"
version = "1.0.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4a5f13b858c8d314ee3e8f639011f7ccefe71f97f96e50151fb991f267928e2c"

[[package]]
name = "lazy_static"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
dependencies = [
 "spin",
]

[[package]]
name = "lazycell"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "830d08ce1d1d941e6b30645f1a0eb5643013d835ce3779a5fc208261dbe10f55"

[[package]]
name = "libc"
version = "0.2.174"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1171693293099992e19cddea4e8b849964e9846f4acee11b3948bcc337be8776"

[[package]]
name = "libloading"
version = "0.8.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "07033963ba89ebaf1584d767badaa2e8fcec21aedea6b8c0346d487d49c28667"
dependencies = [
 "cfg-if",
 "windows-targets 0.53.2",
]

[[package]]
name = "linux-raw-sys"
version = "0.4.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d26c52dbd32dccf2d10cac7725f8eae5296885fb5703b261f7d0a0739ec807ab"

[[package]]
name = "log"
version = "0.4.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "13dc2df351e3202783a1fe0d44375f7295ffb4049267b0f3018346dc122a1d94"

[[package]]
name = "matchers"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8263075bb86c5a1b1427b5ae862e8889656f126e9f77c484496e8b47cf5c5558"
dependencies = [
 "regex-automata 0.1.10",
]

[[package]]
name = "memchr"
version = "2.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a282da65faaf38286cf3be983213fcf1d2e2a58700e808f83f4ea9a4804bc0"

[[package]]
name = "minimal-lexical"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "68354c5c6bd36d73ff3feceb05efa59b6acb7626617f4962be322a825e61f79a"

[[package]]
name = "nom"
version = "7.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d273983c5a657a70a3e8f2a01329822f3b8c8172b73826411a55751e404a0a4a"
dependencies = [
 "memchr",
 "minimal-lexical",
]

[[package]]
name = "nu-ansi-term"
version = "0.46.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77a8165726e8236064dbb45459242600304b42a5ea24ee2948e18e023bf7ba84"
dependencies = [
 "overload",
 "winapi",
]

[[package]]
name = "once_cell"
version = "1.21.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"

[[package]]
name = "once_cell_polyfill"
version = "1.70.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a4895175b425cb1f87721b59f0f286c2092bd4af812243672510e1ac53e2e0ad"

[[package]]
name = "overload"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b15813163c1d831bf4a13c3610c05c0d03b39feb07f7e09fa234dac9b15aaf39"

[[package]]
name = "paste"
version = "1.0.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "57c0d7b74b563b49d38dae00a0c37d4d6de9b432382b2892f0574ddcae73fd0a"

[[package]]
name = "pin-project-lite"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b3cff922bd51709b605d9ead9aa71031d81447142d828eb4a6eba76fe619f9b"

[[package]]
name = "prettyplease"
version = "0.2.35"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "061c1221631e079b26479d25bbf2275bfe5917ae8419cd7e34f13bfc2aa7539a"
dependencies = [
 "proc-macro2",
 "syn",
]

[[package]]
name = "proc-macro2"
version = "1.0.95"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "02b3e5e68a3a1a02aad3ec490a98007cbc13c37cbe84a3cd7b8e406d76e7f778"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "quote"
version = "1.0.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1885c039570dc00dcb4ff087a89e185fd56bae234ddc7f056a945bf36467248d"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "raw-cpuid"
version = "10.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6c297679cb867470fa8c9f67dbba74a78d78e3e98d7cf2b08d6d71540f797332"
dependencies = [
 "bitflags 1.3.2",
]

[[package]]
name = "regex"
version = "1.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b544ef1b4eac5dc2db33ea63606ae9ffcfac26c1416a2806ae0bf5f56b201191"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-automata 0.4.9",
 "regex-syntax 0.8.5",
]

[[package]]
name = "regex-automata"
version = "0.1.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6c230d73fb8d8c1b9c0b3135c5142a8acee3a0558fb8db5cf1cb65f8d7862132"
dependencies = [
 "regex-syntax 0.6.29",
]

[[package]]
name = "regex-automata"
version = "0.4.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "809e8dc61f6de73b46c85f4c96486310fe304c434cfa43669d7b40f711150908"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-syntax 0.8.5",
]

[[package]]
name = "regex-syntax"
version = "0.6.29"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f162c6dd7b008981e4d40210aca20b4bd0f9b60ca9271061b07f78537722f2e1"

[[package]]
name = "regex-syntax"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2b15c43186be67a4fd63bee50d0303afffcef381492ebe2c5d87f324e1b8815c"

[[package]]
name = "rustc-hash"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2"

[[package]]
name = "rustix"
version = "0.38.44"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fdb5bc1ae2baa591800df16c9ca78619bf65c0488b41b96ccec5d11220d8c154"
dependencies = [
 "bitflags 2.9.1",
 "errno",
 "libc",
 "linux-raw-sys",
 "windows-sys 0.59.0",
]

[[package]]
name = "rustversion"
version = "1.0.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8a0d197bd2c9dc6e53b84da9556a69ba4cdfab8619eb41a8bd1cc2027a0f6b1d"

[[package]]
name = "ryu"
version = "1.0.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "28d3b2b1366ec20994f1fd18c3c594f05c5dd4bc44d8bb0c1c632c8d6829481f"

[[package]]
name = "semver"
version = "1.0.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56e6fa9c48d24d85fb3de5ad847117517440f6beceb7798af16b4a87d616b8d0"
dependencies = [
 "serde",
]

[[package]]
name = "serde"
version = "1.0.219"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5f0e2c6ed6606019b4e29e69dbaba95b11854410e5347d525002456dbbb786b6"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde_derive"
version = "1.0.219"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b0276cf7f2c73365f7157c8123c21cd9a50fbbd844757af28ca1f5925fc2a00"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "serde_json"
version = "1.0.140"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "20068b6e96dc6c9bd23e01df8827e6c7e1f2fddd43c21810382803c136b99373"
dependencies = [
 "itoa",
 "memchr",
 "ryu",
 "serde",
]

[[package]]
name = "sharded-slab"
version = "0.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f40ca3c46823713e0d4209592e8d6e826aa57e928f09752619fc696c499637f6"
dependencies = [
 "lazy_static",
]

[[package]]
name = "shlex"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64"

[[package]]
name = "smallvec"
version = "1.15.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "67b1b7a3b5fe4f1376887184045fcf45c69e92af734b7aaddc05fb777b6fbd03"

[[package]]
name = "spin"
version = "0.9.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6980e8d7511241f8acf4aebddbb1ff938df5eebe98691418c4468d0b72a96a67"

[[package]]
name = "static_assertions"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a2eb9349b6444b326872e140eb1cf5e7c522154d69e7a0ffb0fb81c06b37543f"

[[package]]
name = "strsim"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7da8b5736845d9f2fcb837ea5d9e2628564b3b043a70948a3f0b778838c5fb4f"

[[package]]
name = "syn"
version = "2.0.104"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "17b6f705963418cdb9927482fa304bc562ece2fdd4f616084c50b7023b435a40"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "thiserror"
version = "1.0.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b6aaf5339b578ea85b50e080feb250a3e8ae8cfcdff9a461c9ec2904bc923f52"
dependencies = [
 "thiserror-impl",
]

[[package]]
name = "thiserror-impl"
version = "1.0.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4fee6c4efc90059e10f81e6d42c60a18f76588c3d74cb83a0b242a2b6c7504c1"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "thread_local"
version = "1.1.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f60246a4944f24f6e018aa17cdeffb7818b76356965d03b07d6a9886e8962185"
dependencies = [
 "cfg-if",
]

[[package]]
name = "tracing"
version = "0.1.41"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "784e0ac535deb450455cbfa28a6f0df145ea1bb7ae51b821cf5e7927fdcfbdd0"
dependencies = [
 "pin-project-lite",
 "tracing-attributes",
 "tracing-core",
]

[[package]]
name = "tracing-attributes"
version = "0.1.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "81383ab64e72a7a8b8e13130c49e3dab29def6d0c7d76a03087b3cf71c5c6903"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "tracing-core"
version = "0.1.34"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b9d12581f227e93f094d3af2ae690a574abb8a2b9b7a96e7cfe9647b2b617678"
dependencies = [
 "once_cell",
 "valuable",
]

[[package]]
name = "tracing-log"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ee855f1f400bd0e5c02d150ae5de3840039a3f54b025156404e34c23c03f47c3"
dependencies = [
 "log",
 "once_cell",
 "tracing-core",
]

[[package]]
name = "tracing-subscriber"
version = "0.3.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e8189decb5ac0fa7bc8b96b7cb9b2701d60d48805aca84a238004d665fcc4008"
dependencies = [
 "matchers",
 "nu-ansi-term",
 "once_cell",
 "regex",
 "sharded-slab",
 "smallvec",
 "thread_local",
 "tracing",
 "tracing-core",
 "tracing-log",
]

[[package]]
name = "unicode-ident"
version = "1.0.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a5f39404a5da50712a4c1eecf25e90dd62b613502b7e925fd4e4d19b5c96512"

[[package]]
name = "utf8parse"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06abde3611657adf66d383f00b093d7faecc7fa57071cce2578660c9f1010821"

[[package]]
name = "valuable"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ba73ea9cf16a25df0c8caa16c51acb937d5712a8429db78a3ee29d5dcacd3a65"

[[package]]
name = "volatile"
version = "0.4.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "442887c63f2c839b346c192d047a7c87e73d0689c9157b00b53dcc27dd5ea793"

[[package]]
name = "wdk"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c80cc00b5c587d3a43f489350a797a258eefca5ab0bb5d0d5b56d4ce09ab42f2"
dependencies = [
 "tracing",
 "tracing-subscriber",
 "wdk-build",
 "wdk-sys",
]

[[package]]
name = "wdk-alloc"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5dd1c139c6b9c05475bc7e8b356d4fbc252954d685691d70cfaec8b42c41b72d"
dependencies = [
 "tracing",
 "tracing-subscriber",
 "wdk-build",
 "wdk-sys",
]

[[package]]
name = "wdk-build"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4b276786d848e5ab00e021968e89cfdc591938b69741a3733e7e3d91b23f547f"
dependencies = [
 "anyhow",
 "bindgen",
 "camino",
 "cargo_metadata",
 "cfg-if",
 "clap",
 "clap-cargo",
 "lazy_static",
 "paste",
 "rustversion",
 "serde",
 "serde_json",
 "thiserror",
 "tracing",
 "windows",
]

[[package]]
name = "wdk-macros"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56f069b2e89e5a3327e84bc2f672f7f35d94059da590666d7d605f33f2ae2fa3"
dependencies = [
 "itertools 0.13.0",
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "wdk-panic"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9e2b724a14f327229f37923f5edaacf83aab295762b94b6a391fa14cd9eac550"

[[package]]
name = "wdk-sys"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "10f974829a3b0b362723d55f0d05d8f1715bb7a88297558c4127f69d85bbff7e"
dependencies = [
 "anyhow",
 "bindgen",
 "cargo_metadata",
 "cc",
 "lazy_static",
 "rustversion",
 "serde_json",
 "thiserror",
 "tracing",
 "tracing-subscriber",
 "wdk-build",
 "wdk-macros",
]

[[package]]
name = "which"
version = "4.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "87ba24419a2078cd2b0f2ede2691b6c66d8e47836da3b6db8265ebad47afbfc7"
dependencies = [
 "either",
 "home",
 "once_cell",
 "rustix",
]

[[package]]
name = "winapi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
dependencies = [
 "winapi-i686-pc-windows-gnu",
 "winapi-x86_64-pc-windows-gnu",
]

[[package]]
name = "winapi-i686-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"

[[package]]
name = "winapi-x86_64-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"

[[package]]
name = "windows"
version = "0.58.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dd04d41d93c4992d421894c18c8b43496aa748dd4c081bac0dc93eb0489272b6"
dependencies = [
 "windows-core",
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-core"
version = "0.58.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6ba6d44ec8c2591c134257ce647b7ea6b20335bf6379a27dac5f1641fcf59f99"
dependencies = [
 "windows-implement",
 "windows-interface",
 "windows-result",
 "windows-strings",
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-implement"
version = "0.58.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2bbd5b46c938e506ecbce286b6628a02171d56153ba733b6c741fc627ec9579b"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "windows-interface"
version = "0.58.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "053c4c462dc91d3b1504c6fe5a726dd15e216ba718e84a0e46a88fbe5ded3515"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "windows-result"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1d1043d8214f791817bab27572aaa8af63732e11bf84aa21a45a78d6c317ae0e"
dependencies = [
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-strings"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4cd9b125c486025df0eabcb585e62173c6c9eddcec5d117d3b6e8c30e2ee4d10"
dependencies = [
 "windows-result",
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-sys"
version = "0.59.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e38bc4d79ed67fd075bcc251a1c39b32a1776bbe92e5bef1f0bf1f8c531853b"
dependencies = [
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-sys"
version = "0.60.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f2f500e4d28234f72040990ec9d39e3a6b950f9f22d3dba18416c35882612bcb"
dependencies = [
 "windows-targets 0.53.2",
]

[[package]]
name = "windows-targets"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
dependencies = [
 "windows_aarch64_gnullvm 0.52.6",
 "windows_aarch64_msvc 0.52.6",
 "windows_i686_gnu 0.52.6",
 "windows_i686_gnullvm 0.52.6",
 "windows_i686_msvc 0.52.6",
 "windows_x86_64_gnu 0.52.6",
 "windows_x86_64_gnullvm 0.52.6",
 "windows_x86_64_msvc 0.52.6",
]

[[package]]
name = "windows-targets"
version = "0.53.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c66f69fcc9ce11da9966ddb31a40968cad001c5bedeb5c2b82ede4253ab48aef"
dependencies = [
 "windows_aarch64_gnullvm 0.53.0",
 "windows_aarch64_msvc 0.53.0",
 "windows_i686_gnu 0.53.0",
 "windows_i686_gnullvm 0.53.0",
 "windows_i686_msvc 0.53.0",
 "windows_x86_64_gnu 0.53.0",
 "windows_x86_64_gnullvm 0.53.0",
 "windows_x86_64_msvc 0.53.0",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "86b8d5f90ddd19cb4a147a5fa63ca848db3df085e25fee3cc10b39b6eebae764"

[[package]]
name = "windows_aarch64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"

[[package]]
name = "windows_aarch64_msvc"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c7651a1f62a11b8cbd5e0d42526e55f2c99886c77e007179efff86c2b137e66c"

[[package]]
name = "windows_i686_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"

[[package]]
name = "windows_i686_gnu"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c1dc67659d35f387f5f6c479dc4e28f1d4bb90ddd1a5d3da2e5d97b42d6272c3"

[[package]]
name = "windows_i686_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"

[[package]]
name = "windows_i686_gnullvm"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ce6ccbdedbf6d6354471319e781c0dfef054c81fbc7cf83f338a4296c0cae11"

[[package]]
name = "windows_i686_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"

[[package]]
name = "windows_i686_msvc"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "581fee95406bb13382d2f65cd4a908ca7b1e4c2f1917f143ba16efe98a589b5d"

[[package]]
name = "windows_x86_64_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"

[[package]]
name = "windows_x86_64_gnu"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2e55b5ac9ea33f2fc1716d1742db15574fd6fc8dadc51caab1c16a3d3b4190ba"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0a6e035dd0599267ce1ee132e51c27dd29437f63325753051e71dd9e42406c57"

[[package]]
name = "windows_x86_64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"

[[package]]
name = "windows_x86_64_msvc"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "271414315aff87387382ec3d271b52d7ae78726f5d44ac98b4f4030c91880486"

[[package]]
name = "x86"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2781db97787217ad2a2845c396a5efe286f87467a5810836db6d74926e94a385"
dependencies = [
 "bit_field",
 "bitflags 1.3.2",
 "raw-cpuid",
]

[[package]]
name = "x86_64"
version = "0.15.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0f042214de98141e9c8706e8192b73f56494087cc55ebec28ce10f26c5c364ae"
dependencies = [
 "bit_field",
 "bitflags 2.9.1",
 "rustversion",
 "volatile",
]

```

`Cargo.toml`:

```toml
[package]
name = "hv"
version = "0.1.0"
edition = "2024"

[package.metadata.wdk.driver-model]
driver-type = "WDM"

[lib]
crate-type = ["cdylib"]
test = false

[build-dependencies]
wdk-build = "0.3.0"

[dependencies]
wdk = "0.3.0"       
wdk-macros = "0.3.0"
wdk-alloc = "0.3.0" 
wdk-panic = "0.3.0" 
wdk-sys = "0.3.0"   
x86 = "0.52.0"
static_assertions = "1.1.0"
x86_64 = { version = "0.15.2", default-features = false, features = ["instructions"] }
bitfield = "0.19.1"

[features]
default = []
nightly = ["wdk/nightly", "wdk-sys/nightly"]

[profile.dev]
panic = "abort"

[profile.release]
panic = "abort"

```

`README.md`:

```md
# BareSVM

## AMD Hypervisor written in Rust

Written for learning purposes, very bare and minimal to act as a base to build upon

Sample program to do a hypercall from usermode

```rust
#[unsafe(naked)]
unsafe extern "win64" fn hypercall() -> u64 {
    core::arch::naked_asm!(
        "
        mov rcx, 1
        vmmcall
        ret
        "
    );
}

fn main() {
    println!("hypercall response: {}",unsafe {hypercall() as u64});
}
```
When the hypervisor is running it will return 4919/0x1337 as response

```

`build.rs`:

```rs
fn main() -> Result<(), wdk_build::ConfigError> {
    unsafe { std::env::set_var("CARGO_CFG_TARGET_FEATURE", "crt-static") };
    wdk_build::configure_wdk_binary_build()
}

```

`src/hv.rs`:

```rs
use crate::segments::*;
use crate::structs::*;
use crate::utils::*;
use crate::vmcb::*;
use core::arch::asm;
use core::arch::global_asm;
use core::ffi::c_void;
use core::ptr::null;
use core::ptr::null_mut;
use core::ptr::{NonNull, addr_of};
use core::sync::atomic::{AtomicU64, Ordering};
use static_assertions::*;
use wdk::{dbg_break, println};
use wdk_sys::{
    CONTEXT,
    ntddk::{KeQueryActiveProcessorCount, RtlCaptureContext},
};
use x86::bits64::paging::{BASE_PAGE_SIZE, PAddr};
use x86::controlregs::*;
use x86::msr::{IA32_EFER, IA32_PAT, rdmsr, wrmsr};
use x86_64::instructions::tables::{sgdt, sidt};

#[unsafe(no_mangle)]
unsafe extern "win64" {
    unsafe fn launch_vm(guest_vmcb_pa: *mut u64);
}
global_asm!(include_str!("vmlaunch.asm"));

// use this to store which cpu is virtualized
static VIRTUALIZED_BITSET: AtomicU64 = AtomicU64::new(0);
static mut vcpu_pool: *mut vcpu = null_mut();

fn is_virtualized(idx: u32) -> bool {
    let bit = 1 << idx;
    VIRTUALIZED_BITSET.load(Ordering::Relaxed) & bit != 0
}

fn set_virtualized(idx: u32) {
    let bit = 1 << idx;
    VIRTUALIZED_BITSET.fetch_or(bit, Ordering::Relaxed);
}

#[repr(C, align(4096))]
pub struct host_stack_layout {
    pub stack_contents: [u8; STACK_CONTENTS_SIZE],
    pub trap_frame: KTRAP_FRAME,
    pub guest_vmcb_pa: u64,
    pub host_vmcb_pa: u64,
    pub self_data: *mut u64, // self reference that will point to a vcpu struct
    pub shared_data: *mut u64, // shared_data will be used for msr bitmap in future
    pub padding_1: u64,
    pub reserved_1: u64,
}
const_assert_eq!(core::mem::size_of::<host_stack_layout>(), KERNEL_STACK_SIZE);

#[repr(C, align(4096))]
pub struct vcpu {
    pub host_stack_layout: host_stack_layout,
    pub guest_vmcb: vmcb,
    pub host_vmcb: vmcb,
    pub host_state_area: [u8; BASE_PAGE_SIZE],
    pub prev_vmexit: u64,
    pub unload: bool,
}

const_assert_eq!(
    core::mem::size_of::<vcpu>(),
    KERNEL_STACK_SIZE + 4 * BASE_PAGE_SIZE
);

impl vcpu {
    pub fn setup_vcpu(&mut self, context: &mut CONTEXT) {
        let gdtr = sgdt();
        let idtr = sidt();

        self.unload = false;
        self.host_stack_layout.guest_vmcb_pa = pa(addr_of!(self.guest_vmcb) as _);
        self.host_stack_layout.host_vmcb_pa = pa(addr_of!(self.host_vmcb) as _);
        self.host_stack_layout.self_data = self as *mut vcpu as *mut u64;

        println!("guest_vmcb_pa: {}", self.host_stack_layout.guest_vmcb_pa);
        println!("host_area_pa: {}", self.host_stack_layout.host_vmcb_pa);

        //self.guest_vmcb.control_area.intercept_misc1 |= SVM_INTERCEPT_MISC1_CPUID;
        self.guest_vmcb.control_area.intercept_misc2 |= SVM_INTERCEPT_MISC2_VMRUN;
        self.guest_vmcb.control_area.intercept_misc2 |= SVM_INTERCEPT_MISC2_VMMCALL; //intercept vmmcall here

        self.guest_vmcb.control_area.guest_asid = 1;

        self.guest_vmcb.state_save_area.gdtr_base = gdtr.base.as_u64();
        self.guest_vmcb.state_save_area.gdtr_limit = gdtr.limit as _;
        self.guest_vmcb.state_save_area.idtr_base = idtr.base.as_u64();
        self.guest_vmcb.state_save_area.idtr_limit = idtr.limit as _;

        self.guest_vmcb.state_save_area.cs_limit = segment_limit(context.SegCs);
        self.guest_vmcb.state_save_area.ds_limit = segment_limit(context.SegDs);
        self.guest_vmcb.state_save_area.es_limit = segment_limit(context.SegEs);
        self.guest_vmcb.state_save_area.ss_limit = segment_limit(context.SegSs);

        self.guest_vmcb.state_save_area.cs_selector = context.SegCs;
        self.guest_vmcb.state_save_area.ds_selector = context.SegDs;
        self.guest_vmcb.state_save_area.es_selector = context.SegEs;
        self.guest_vmcb.state_save_area.ss_selector = context.SegSs;

        self.guest_vmcb.state_save_area.cs_attrib =
            segment_access_right(context.SegCs, gdtr.base.as_u64());
        self.guest_vmcb.state_save_area.ds_attrib =
            segment_access_right(context.SegDs, gdtr.base.as_u64());
        self.guest_vmcb.state_save_area.es_attrib =
            segment_access_right(context.SegEs, gdtr.base.as_u64());
        self.guest_vmcb.state_save_area.ss_attrib =
            segment_access_right(context.SegSs, gdtr.base.as_u64());

        unsafe {
            self.guest_vmcb.state_save_area.efer = rdmsr(IA32_EFER);
            self.guest_vmcb.state_save_area.gpat = rdmsr(IA32_PAT);
            self.guest_vmcb.state_save_area.cr0 = readcr0();
            self.guest_vmcb.state_save_area.cr2 = cr2() as _;
            self.guest_vmcb.state_save_area.cr3 = cr3() as _;
            self.guest_vmcb.state_save_area.cr4 = readcr4();
        }

        self.guest_vmcb.state_save_area.rflags = context.EFlags as u64;
        self.guest_vmcb.state_save_area.rsp = context.Rsp;
        self.guest_vmcb.state_save_area.rip = context.Rip;

        unsafe { asm!("vmsave rax", in("rax") self.host_stack_layout.guest_vmcb_pa) };

        let host_state_area_pa = pa(self.host_state_area.as_ptr() as *const _);
        unsafe { wrmsr(SVM_MSR_VM_HSAVE_PA, host_state_area_pa) };

        unsafe { asm!("vmsave rax", in("rax") self.host_stack_layout.host_vmcb_pa) };
    }
}

pub fn virtualize_cpu(idx: u32) {
    // capture context here, when the guest begins execution the guest_rip
    // will point here and the is_virtualized() will return true.

    let mut context = CONTEXT::default();
    unsafe {
        RtlCaptureContext(&mut context as *mut CONTEXT);
    }

    let mut vcpu_ptr = unsafe { vcpu_pool.add(idx as usize) };

    if vcpu_ptr.is_null() {
        println!("#cpu: {} data not found!", idx);
    }

    if !is_virtualized(idx) {
        unsafe {
            wrmsr(IA32_EFER, rdmsr(IA32_EFER) | EFER_SVME);
        }

        let mut vcpu = unsafe { &mut *vcpu_ptr };
        vcpu.setup_vcpu(&mut context);
        set_virtualized(idx);

        let host_rsp = &vcpu.host_stack_layout.guest_vmcb_pa as *const u64 as *mut u64;

        unsafe {
            launch_vm(host_rsp);
            println!("this should never print!");
            dbg_break();
        }
    }
    println!("virtualized #cpu: {}", idx)
}

pub fn devirtualize_cpu(vcpu_ctx: &mut vcpu, guest_regs: &mut guest_regs) -> u8 {
    guest_regs.rax = vcpu_ctx as *mut _ as u32 as u64;
    guest_regs.rdx = vcpu_ctx as *mut _ as u64 >> 32;

    guest_regs.rbx = vcpu_ctx.guest_vmcb.control_area.n_rip;
    guest_regs.rcx = vcpu_ctx.guest_vmcb.state_save_area.rsp;

    let guest_vmcb_pa = pa(addr_of!(vcpu_ctx.guest_vmcb) as _);

    unsafe {
        asm!("vmload rax", in("rax") guest_vmcb_pa);

        asm!("cli");
        asm!("stgi");

        // Disable svm.
        let msr = rdmsr(IA32_EFER) & !EFER_SVME;
        wrmsr(IA32_EFER, msr);

        // Restore guest eflags.
        asm!("push {}; popfq", in(reg) (*vcpu_ctx).guest_vmcb.state_save_area.rflags);
    }
    return 1;
}

pub fn virtualize() {
    if setup_resources() == true {
        run_on_all_cpus(virtualize_cpu)
    } else {
        println!("resources allocation failed!")
    }
}

pub fn devirtualize() {
    run_on_all_cpus(|idx| {
        println!("devirtualizing #cpu {}", idx);
        unsafe {
            asm!("mov rcx, 0x10");
            asm!("vmmcall");
        }
    });
    println!("done!");
    unsafe { deallocate(vcpu_pool as *mut c_void) };
}

fn setup_resources() -> bool {
    let cpu_count = unsafe { KeQueryActiveProcessorCount(null_mut()) };
    println!("#cpus: {}", cpu_count);

    unsafe {
        vcpu_pool = allocate(core::mem::size_of::<vcpu>() * cpu_count as usize) as *mut vcpu;
        if vcpu_pool.is_null() {
            println!("vcpu_pool is empty!");
            return false;
        }
    };
    println!("allocated vcpu_pool");
    true
}

```

`src/lib.rs`:

```rs
#![no_std]
#![no_main]
#![allow(dead_code, unused)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]

use core::panic::PanicInfo;
use wdk::println;
use wdk_alloc::WdkAllocator;
use wdk_sys::{DRIVER_OBJECT, NTSTATUS, PUNICODE_STRING, STATUS_SUCCESS};
extern crate wdk_panic;

mod hv;
mod segments;
mod structs;
mod utils;
mod vmcb;
mod vmexit;
mod vmmcall;

#[global_allocator]
static GLOBAL_ALLOCATOR: WdkAllocator = WdkAllocator;

#[unsafe(export_name = "DriverEntry")]
pub unsafe extern "system" fn driver_entry(
    driver: &mut DRIVER_OBJECT,
    registry_path: PUNICODE_STRING,
) -> NTSTATUS {
    println!("DriverEntry from Rust!");
    if utils::is_svm_supported() == true {
        hv::virtualize();
    }
    driver.DriverUnload = Some(driver_unload);
    STATUS_SUCCESS
}

unsafe extern "C" fn driver_unload(driver: *mut DRIVER_OBJECT) {
    hv::devirtualize();
    println!("bye bye from driver!");
}

```

`src/segments.rs`:

```rs
// credits to https://github.com/not-matthias/amd_hypervisor
use bitfield::bitfield;
use core::arch::asm;

bitfield! {
    pub struct SegmentDescriptor(u64);
    impl Debug;
    pub get_limit_low, set_limit_low: 15, 0;            // [0-15]
    pub get_base_low, set_base_low: 31, 16;             // [16-31]
    pub get_base_middle, set_base_middle: 39, 32;       // [32-39]
    pub get_type, set_type: 43, 40;                     // [40-43]
    pub get_system, set_system: 44, 44;                 // [44]
    pub get_dpl, set_dpl: 46, 45;                       // [45-46]
    pub get_present, set_present: 47, 47;               // [47]
    pub get_limit_high, set_limit_high: 51, 48;         // [48-51]
    pub get_avl, set_avl: 52, 52;                       // [52]
    pub get_long_mode, set_long_mode: 53, 53;           // [53]
    pub get_default_bit, set_default_bit: 54, 54;       // [54]
    pub get_granularity, set_granularity: 55, 55;       // [55]
    pub get_base_high, set_base_high: 63, 56;           // [56-63]
}

bitfield! {
    pub struct SegmentAttribute(u16);
    impl Debug;
    pub get_type, set_type: 3, 0;                       // [0-4]
    pub get_system, set_system: 4, 4;                   // [4]
    pub get_dpl, set_dpl: 6, 5;                         // [5-6]
    pub get_present, set_present: 7, 7;                 // [7]
    pub get_avl, set_avl: 8, 8;                         // [8]
    pub get_long_mode, set_long_mode: 9, 9;             // [9]
    pub get_default_bit, set_default_bit: 10, 10;       // [10]
    pub get_grunularity, set_granularity: 11, 11;       // [11]
    // reserved                                     // [12-15]
}

pub fn segment_access_right(segment_selector: u16, gdt_base: u64) -> u16 {
    const RPL_MASK: u16 = 3;
    let descriptor = gdt_base + (segment_selector & !RPL_MASK) as u64;

    let descriptor = descriptor as *mut u64 as *mut SegmentDescriptor;
    let descriptor = unsafe { descriptor.read_volatile() };

    let mut attribute = SegmentAttribute(0);
    attribute.set_type(descriptor.get_type() as u16);
    attribute.set_system(descriptor.get_system() as u16);
    attribute.set_dpl(descriptor.get_dpl() as u16);
    attribute.set_present(descriptor.get_present() as u16);
    attribute.set_avl(descriptor.get_avl() as u16);
    attribute.set_long_mode(descriptor.get_long_mode() as u16);
    attribute.set_default_bit(descriptor.get_default_bit() as u16);
    attribute.set_granularity(descriptor.get_granularity() as u16);

    attribute.0
}

pub fn segment_limit(selector: u16) -> u32 {
    let limit: u32;
    unsafe {
        asm!("lsl {0:e}, {1:x}", out(reg) limit, in(reg) selector, options(nostack, nomem));
    }
    limit
}

```

`src/structs.rs`:

```rs
use static_assertions::*;
use wdk::*;
use wdk_sys::{ntddk::*, *};

#[derive(Clone, Copy, Debug, Default)]
#[repr(C)]
pub struct guest_regs {
    pub r15: u64,
    pub r14: u64,
    pub r13: u64,
    pub r12: u64,
    pub r11: u64,
    pub r10: u64,
    pub r9: u64,
    pub r8: u64,
    pub rdi: u64,
    pub rsi: u64,
    pub rbp: u64,
    pub rsp: u64,
    pub rbx: u64,
    pub rdx: u64,
    pub rcx: u64,
    pub rax: u64,
}
const_assert_eq!(core::mem::size_of::<guest_regs>(), 0x80 /* 16 * 0x8 */);

// credits to https://github.com/not-matthias/amd_hypervisor
#[repr(C)]
pub struct KTRAP_FRAME {
    /*
     * Home address for the parameter registers.
     */
    pub p1_home: u64,
    pub p2_home: u64,
    pub p3_home: u64,
    pub p4_home: u64,
    pub p5: u64,
    /*
     * Previous processor mode (system services only) and previous IRQL
     * (interrupts only).
     */
    pub previous_mode: KPROCESSOR_MODE,
    pub previous_irql: KIRQL,
    /*
     * Page fault load/store indicator.
     */
    pub fault_indicator: u8,
    /*
     * Exception active indicator.
     *
     *    0 - interrupt frame.
     *    1 - exception frame.
     *    2 - service frame.
     */
    pub exception_active: u8,
    /*
     * Floating point state.
     */
    pub mx_csr: u32,
    /*
     *  Volatile registers.
     *
     * N.B. These registers are only saved on exceptions and interrupts. They
     *      are not saved for system calls.
     */
    pub rax: u64,
    pub rcx: u64,
    pub rdx: u64,
    pub r8: u64,
    pub r9: u64,
    pub r10: u64,
    pub r11: u64,
    /*
     * Gsbase is only used if the previous mode was kernel.
     *
     * GsSwap is only used if the previous mode was user.
     *
     * Note: This was originally an union (GsSwap).
     */
    pub gs_base: u64,
    /*
     * Volatile floating registers.
     *
     * N.B. These registers are only saved on exceptions and interrupts. They
     *      are not saved for system calls.
     */
    pub xmm0: u128,
    pub xmm1: u128,
    pub xmm2: u128,
    pub xmm3: u128,
    pub xmm4: u128,
    pub xmm5: u128,
    /*
     * First parameter, page fault address, context record address if user APC
     * bypass.
     *
     * Note: This was originally an union (ContextRecord).
     */
    pub fault_address: u64,
    /*
     *  Debug registers.
     */
    pub dr0: u64,
    pub dr1: u64,
    pub dr2: u64,
    pub dr3: u64,
    pub dr6: u64,
    pub dr7: u64,
    /*
     * Special debug registers.
     *
     * Note: This was originally in its own structure.
     */
    pub debug_control: u64,
    pub last_branch_to_rip: u64,
    pub last_branch_from_rip: u64,
    pub last_exception_to_rip: u64,
    pub last_exception_from_rip: u64,
    /*
     *  Segment registers
     */
    pub seg_ds: u16,
    pub seg_es: u16,
    pub seg_fs: u16,
    pub seg_gs: u16,
    /*
     * Previous trap frame address.
     */
    pub trap_frame: u64,
    /*
     * Saved nonvolatile registers RBX, RDI and RSI. These registers are only
     * saved in system service trap frames.
     */
    pub rbx: u64,
    pub rdi: u64,
    pub rsi: u64,
    /*
     * Saved nonvolatile register RBP. This register is used as a frame
     * pointer during trap processing and is saved in all trap frames.
     */
    pub rbp: u64,
    /*
     * Information pushed by hardware.
     *
     * N.B. The error code is not always pushed by hardware. For those cases
     *      where it is not pushed by hardware a dummy error code is allocated
     *      on the stack.
     *
     * Note: This was originally an union (ExceptionFrame).
     */
    pub error_code: u64,
    pub rip: u64,
    pub seg_cs: u16,
    pub fill_0: u8,
    pub logging: u8,
    pub fill_1: [u16; 2],
    pub e_flags: u32,
    pub fill_2: u32,
    pub rsp: u64,
    pub seg_ss: u16,
    pub fill_3: u16,
    pub fill_4: u32,
}

pub const KERNEL_STACK_SIZE: usize = 0x6000;
pub const STACK_CONTENTS_SIZE: usize = KERNEL_STACK_SIZE
    - (core::mem::size_of::<*mut u64>() * 6)
    - core::mem::size_of::<KTRAP_FRAME>();

```

`src/utils.rs`:

```rs
use core::arch::asm;
use core::ffi::c_void;
use core::sync::atomic::{AtomicU64, Ordering};
use wdk::*;
use wdk_sys::ntddk::*;
use wdk_sys::{PAGE_SIZE, POOL_FLAG_NON_PAGED};
use x86::{cpuid::CpuId, msr::rdmsr};

pub fn is_svm_supported() -> bool {
    // Check `CPUID Fn8000_0001_ECX[SVM] == 0`
    //
    let Some(result) = CpuId::new().get_extended_processor_and_feature_identifiers() else {
        return false;
    };
    if !result.has_svm() {
        println!("Processor does not support SVM");
        return false;
    }
    // Check `VM_CR.SVMDIS == 0`
    //
    // See in the AMD Manual '15.30.1  VM_CR MSR (C001_0114h)'
    //
    const SVM_MSR_VM_CR: u32 = 0xC001_0114;
    const SVM_VM_CR_SVMDIS: u64 = 1 << 4;

    let vm_cr = unsafe { rdmsr(SVM_MSR_VM_CR) };
    if (vm_cr & SVM_VM_CR_SVMDIS) == 0 {
        return true;
    }

    // Check `CPUID Fn8000_000A_EDX[SVML]==0`
    //
    if CpuId::new()
        .get_svm_info()
        .map(|svm_info| svm_info.has_svm_lock())
        .unwrap_or_default()
    {
        println!("the user must change a platform firmware setting to enable SVM");
    } else {
        println!("SVMLock may be unlockable; consult platform firmware or TPM to obtain the key.");
    }

    false
}

pub fn allocate(size: usize) -> *mut c_void {
    if (size <= PAGE_SIZE as usize) {
        println!("alloc called with size <= PAGE_SIZE");
    }
    let addr = unsafe { ExAllocatePool2(POOL_FLAG_NON_PAGED, size as u64, 0x64657246) }; // 0x64657246 = derF
    return addr;
}

pub fn deallocate(p: *mut c_void) {
    unsafe { ExFreePool(p) };
}

pub fn pa(va: *const core::ffi::c_void) -> u64 {
    #[allow(clippy::cast_sign_loss)]
    unsafe {
        MmGetPhysicalAddress(va.cast_mut()).QuadPart as u64
    }
}

pub fn readcr0() -> u64 {
    let ret: usize;
    unsafe { asm!("mov %cr0, {0}", out(reg) ret, options(att_syntax)) }
    ret as u64
}

pub fn readcr4() -> u64 {
    let ret: usize;
    unsafe { asm!("mov %cr4, {0}", out(reg) ret, options(att_syntax)) };
    ret as u64
}

use wdk_sys::{
    ALL_PROCESSOR_GROUPS, APC_LEVEL, GROUP_AFFINITY, NT_SUCCESS, PAGED_CODE, PROCESSOR_NUMBER,
    ntddk::{
        KeGetCurrentIrql, KeGetProcessorNumberFromIndex, KeQueryActiveProcessorCountEx,
        KeRevertToUserGroupAffinityThread, KeSetSystemGroupAffinityThread, MmGetPhysicalAddress,
    },
};

pub fn run_on_all_cpus(callback: fn(u32)) {
    fn processor_count() -> u32 {
        unsafe { KeQueryActiveProcessorCountEx(u16::try_from(ALL_PROCESSOR_GROUPS).unwrap()) }
    }

    PAGED_CODE!();

    for index in 0..processor_count() {
        let mut processor_number = PROCESSOR_NUMBER::default();
        let status = unsafe { KeGetProcessorNumberFromIndex(index, &mut processor_number) };
        assert!(NT_SUCCESS(status));

        let mut old_affinity = GROUP_AFFINITY::default();
        let mut affinity = GROUP_AFFINITY {
            Group: processor_number.Group,
            Mask: 1 << processor_number.Number,
            Reserved: [0, 0, 0],
        };
        unsafe { KeSetSystemGroupAffinityThread(&mut affinity, &mut old_affinity) };

        callback(index);

        unsafe { KeRevertToUserGroupAffinityThread(&mut old_affinity) };
    }
}

```

`src/vmcb.rs`:

```rs
use static_assertions::const_assert_eq;

pub const SVM_INTERCEPT_MISC2_VMRUN: u32 = 1 << 0;
pub const SVM_INTERCEPT_MISC2_VMMCALL: u32 = 1 << 1;
pub const SVM_INTERCEPT_MISC1_CPUID: u32 = 1 << 18;
pub const SVM_MSR_VM_HSAVE_PA: u32 = 0xc001_0117;
pub const EFER_SVME: u64 = 1 << 12;
pub const VMEXIT_VMMCALL: u64 = 0x81;
pub const VMEXIT_CPUID: u64 = 0x0072;
pub const VMEXIT_VMRUN: u64 = 0x0080;

#[repr(C)]
pub struct control_area {
    pub intercept_cr_read: u16,              // +0x000
    pub intercept_cr_write: u16,             // +0x002
    pub intercept_dr_read: u16,              // +0x004
    pub intercept_dr_write: u16,             // +0x006
    pub intercept_exception: u32,            // +0x008
    pub intercept_misc1: u32,                // +0x00c
    pub intercept_misc2: u32,                // +0x010
    pub reserved1: [u8; 0x03c - 0x014],      // +0x014
    pub pause_filter_threshold: u16,         // +0x03c
    pub pause_filter_count: u16,             // +0x03e
    pub iopm_base_pa: u64,                   // +0x040
    pub msrpm_base_pa: u64,                  // +0x048
    pub tsc_offset: u64,                     // +0x050
    pub guest_asid: u32,                     // +0x058
    pub tlb_control: u32,                    // +0x05c
    pub vintr: u64,                          // +0x060
    pub interrupt_shadow: u64,               // +0x068
    pub exit_code: u64,                      // +0x070
    pub exit_info1: u64,                     // +0x078
    pub exit_info2: u64,                     // +0x080
    pub exit_int_info: u64,                  // +0x088
    pub np_enable: u64,                      // +0x090
    pub avic_apic_bar: u64,                  // +0x098
    pub guest_pa_of_ghcb: u64,               // +0x0a0
    pub event_inj: u64,                      // +0x0a8
    pub n_cr3: u64,                          // +0x0b0
    pub lbr_virtualization_enable: u64,      // +0x0b8
    pub vmcb_clean: u64,                     // +0x0c0
    pub n_rip: u64,                          // +0x0c8
    pub num_of_bytes_fetched: u8,            // +0x0d0
    pub guest_instruction_bytes: [u8; 15],   // +0x0d1
    pub avic_apic_backing_page_pointer: u64, // +0x0e0
    pub reserved2: u64,                      // +0x0e8
    pub avic_logical_table_pointer: u64,     // +0x0f0
    pub avic_physical_table_pointer: u64,    // +0x0f8
    pub reserved3: u64,                      // +0x100
    pub vmcb_save_state_pointer: u64,        // +0x108
    pub reserved4: [u8; 0x400 - 0x110],      // +0x110
}
const_assert_eq!(core::mem::size_of::<control_area>(), 0x400);

#[repr(C)]
pub struct state_save {
    pub es_selector: u16,
    pub es_attrib: u16,
    pub es_limit: u32,
    pub es_base: u64,
    pub cs_selector: u16,
    pub cs_attrib: u16,
    pub cs_limit: u32,
    pub cs_base: u64,
    pub ss_selector: u16,
    pub ss_attrib: u16,
    pub ss_limit: u32,
    pub ss_base: u64,
    pub ds_selector: u16,
    pub ds_attrib: u16,
    pub ds_limit: u32,
    pub ds_base: u64,
    pub fs_selector: u16,
    pub fs_attrib: u16,
    pub fs_limit: u32,
    pub fs_base: u64,
    pub gs_selector: u16,
    pub gs_attrib: u16,
    pub gs_limit: u32,
    pub gs_base: u64,
    pub gdtr_selector: u16,
    pub gdtr_attrib: u16,
    pub gdtr_limit: u32,
    pub gdtr_base: u64,
    pub ldtr_selector: u16,
    pub ldtr_attrib: u16,
    pub ldtr_limit: u32,
    pub ldtr_base: u64,
    pub idtr_selector: u16,
    pub idtr_attrib: u16,
    pub idtr_limit: u32,
    pub idtr_base: u64,
    pub tr_selector: u16,
    pub tr_attrib: u16,
    pub tr_limit: u32,
    pub tr_base: u64,
    pub reserved1: [u8; 43],
    pub cpl: u8,
    pub reserved2: u32,
    pub efer: u64,
    pub reserved3: [u8; 112],
    pub cr4: u64,
    pub cr3: u64,
    pub cr0: u64,
    pub dr7: u64,
    pub dr6: u64,
    pub rflags: u64,
    pub rip: u64,
    pub reserved4: [u8; 88],
    pub rsp: u64,
    pub reserved5: [u8; 24],
    pub rax: u64,
    pub star: u64,
    pub lstar: u64,
    pub cstar: u64,
    pub sf_mask: u64,
    pub kernel_gs_base: u64,
    pub sysenter_cs: u64,
    pub sysenter_esp: u64,
    pub sysenter_eip: u64,
    pub cr2: u64,
    pub reserved6: [u8; 32usize],
    pub gpat: u64,
    pub dbg_ctl: u64,
    pub br_from: u64,
    pub br_to: u64,
    pub last_excep_from: u64,
    pub last_excep_to: u64,
}
const_assert_eq!(core::mem::size_of::<state_save>(), 0x298);

#[repr(C, align(4096))]
pub struct vmcb {
    pub control_area: control_area,
    pub state_save_area: state_save,
}
const_assert_eq!(core::mem::size_of::<vmcb>(), 0x1000);

```

`src/vmexit.rs`:

```rs
use crate::hv::*;
use crate::structs::*;
use crate::vmcb::*;
use crate::vmmcall::*;
use core::arch::asm;
use core::ptr::NonNull;
use wdk::*;

#[unsafe(no_mangle)]
unsafe extern "win64" fn vmexit_handler(
    mut vcpu: NonNull<vcpu>,
    mut guest_regs: NonNull<guest_regs>,
) -> u8 {
    let vcpu_ctx = unsafe { vcpu.as_mut() };
    let guest_regs = unsafe { guest_regs.as_mut() };

    unsafe { asm!("vmload rax", in("rax") vcpu_ctx.host_stack_layout.host_vmcb_pa) };

    guest_regs.rax = vcpu_ctx.guest_vmcb.state_save_area.rax;

    vcpu_ctx.host_stack_layout.trap_frame.rsp = vcpu_ctx.guest_vmcb.state_save_area.rsp;
    vcpu_ctx.host_stack_layout.trap_frame.rip = vcpu_ctx.guest_vmcb.control_area.n_rip;

    match vcpu_ctx.guest_vmcb.control_area.exit_code {
        VMEXIT_VMRUN => vmrun_handler(vcpu_ctx),
        VMEXIT_VMMCALL => {
            vmmcall_handler(vcpu_ctx, guest_regs);
        }
        _ => {
            println!("if this prints, its over");
            dbg_break();
        }
    }

    if vcpu_ctx.unload {
        return devirtualize_cpu(vcpu_ctx, guest_regs);
    }
    // reflect changed regs to guest
    vcpu_ctx.guest_vmcb.state_save_area.rax = guest_regs.rax;
    vcpu_ctx.guest_vmcb.state_save_area.rip = vcpu_ctx.guest_vmcb.control_area.n_rip;

    return 0;
}

fn vmrun_handler(vcpu_ctx: &mut vcpu) {
    vcpu_ctx.guest_vmcb.control_area.event_inj = 2147486477;
}

```

`src/vmlaunch.asm`:

```asm
.global launch_vm

.equ KTRAP_FRAME_SIZE, 0x190
.equ GUEST_REGS_SIZE, 0x80

.macro pushaq
    push    rax
    push    rcx
    push    rdx
    push    rbx
    push    -1      // Dummy for rsp.
    push    rbp
    push    rsi
    push    rdi
    push    r8
    push    r9
    push    r10
    push    r11
    push    r12
    push    r13
    push    r14
    push    r15
.endmacro

.macro popaq
    pop     r15
    pop     r14
    pop     r13
    pop     r12
    pop     r11
    pop     r10
    pop     r9
    pop     r8
    pop     rdi
    pop     rsi
    pop     rbp
    pop     rbx    // Dummy for rsp (this value is destroyed by the next pop).
    pop     rbx
    pop     rdx
    pop     rcx
    pop     rax
.endmacro

launch_vm:
    // rsp = host_rsp
    //
    mov rsp, rcx

guest_loop:

    mov rax, [rsp]          // rax = vcpu.host_stack_layout.guest_vmcb_pa

    vmload rax              // load previous saved guest state from vmcb

    vmrun rax               // switch to guest until #VMEXIT

    vmsave rax              // save current guest state to vmcb

    sub rsp, KTRAP_FRAME_SIZE

    pushaq

    mov rdx, rsp                                                // rdx = guest_registers
    mov rcx, [rsp + GUEST_REGS_SIZE + KTRAP_FRAME_SIZE + 16]    // rcx = vcpu_ctx

    sub rsp, 0x20 + 0x60
    movaps [rsp + 0x20], xmm0
    movaps [rsp + 0x20 + 0x10], xmm1
    movaps [rsp + 0x20 + 0x20], xmm2
    movaps [rsp + 0x20 + 0x30], xmm3
    movaps [rsp + 0x20 + 0x40], xmm4
    movaps [rsp + 0x20 + 0x50], xmm5

    call vmexit_handler

    movaps [rsp + 0x20 + 0x50], xmm5
    movaps [rsp + 0x20 + 0x40], xmm4
    movaps [rsp + 0x20 + 0x30], xmm3
    movaps [rsp + 0x20 + 0x20], xmm2
    movaps [rsp + 0x20 + 0x10], xmm1
    movaps [rsp + 0x20], xmm0
    add rsp, 0x20 + 0x60

    test al, al

    popaq

    jnz exit_loop               
    add rsp, KTRAP_FRAME_SIZE   
    jmp guest_loop              

exit_loop:
    mov rsp, rcx        // rsp = host_rsp
    mov ecx, 0xCAFEBABE
    jmp rbx
```

`src/vmmcall.rs`:

```rs
use crate::hv::vcpu;
use crate::{structs::*, utils::*, vmcb::*, vmmcall};
use core::{arch::asm, ptr::addr_of};
use wdk::*;
use x86::msr::*;

const VMMCALL_UNLOAD: u64 = 0x10;
const VMMCALL_MAGIC: u64 = 1;

pub fn vmmcall_handler(vcpu_ctx: &mut vcpu, guest_regs: &mut guest_regs) {
    println!("in vmmcall handler");
    println!("vmmcall called with rcx: {}", guest_regs.rcx);

    match guest_regs.rcx {
        VMMCALL_MAGIC => {
            guest_regs.rax = 0x1337;
        }
        VMMCALL_UNLOAD => {
            vcpu_ctx.unload = true;
        }
        _ => {
            println!("invalid vmmcall_code");
            dbg_break();
        }
    }
}

```