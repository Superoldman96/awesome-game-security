Project Path: arc_gmh5225_xbox360-emu_firf3dnb

Source Tree:

```txt
arc_gmh5225_xbox360-emu_firf3dnb
├── docs
│   └── kernel
│       ├── ordinals
│       │   ├── connectx.ord
│       │   ├── createprofile.ord
│       │   ├── dump_ordinals.idc
│       │   ├── syscall.ord
│       │   ├── vk.ord
│       │   ├── xam.ord
│       │   ├── xbdm.ord
│       │   └── xboxkrnl.ord
│       └── structures.txt
├── exbox360.sln
├── lib
│   └── prslib
├── make
│   └── vs2013
│       ├── src
│       │   ├── common
│       │   │   ├── common.vcxproj
│       │   │   └── common.vcxproj.filters
│       │   ├── exbox360.vcxproj
│       │   ├── exbox360.vcxproj.filters
│       │   ├── kernel
│       │   │   ├── connectx
│       │   │   │   ├── connectx.vcxproj
│       │   │   │   └── connectx.vcxproj.filters
│       │   │   ├── createprofile
│       │   │   │   ├── createprofile.vcxproj
│       │   │   │   └── createprofile.vcxproj.filters
│       │   │   ├── vk
│       │   │   │   ├── vk.vcxproj
│       │   │   │   └── vk.vcxproj.filters
│       │   │   ├── xam
│       │   │   │   ├── xam.vcxproj
│       │   │   │   └── xam.vcxproj.filters
│       │   │   ├── xapi
│       │   │   │   ├── xapi.vcxproj
│       │   │   │   └── xapi.vcxproj.filters
│       │   │   ├── xbdm
│       │   │   │   ├── xbdm.vcxproj
│       │   │   │   └── xbdm.vcxproj.filters
│       │   │   └── xboxkrnl
│       │   │       ├── object.cpp
│       │   │       ├── xboxkrnl.vcxproj
│       │   │       └── xboxkrnl.vcxproj.filters
│       │   └── powerpc
│       │       ├── disassembler
│       │       │   ├── disassembler.vcxproj
│       │       │   └── disassembler.vcxproj.filters
│       │       ├── interpreter
│       │       │   ├── interpreter.vcxproj
│       │       │   └── interpreter.vcxproj.filters
│       │       ├── powerpc.vcxproj
│       │       ├── powerpc.vcxproj.filters
│       │       └── translator
│       │           ├── translator.vcxproj
│       │           └── translator.vcxproj.filters
│       └── tools
│           ├── emugen
│           │   ├── emugen.vcxproj
│           │   └── emugen.vcxproj.filters
│           └── ex360tester
│               ├── ex360tester.vcxproj
│               └── ex360tester.vcxproj.filters
├── src
│   ├── analyse.cpp
│   ├── common
│   │   ├── bigendian.h
│   │   ├── bit_array.h
│   │   ├── bit_cast.h
│   │   ├── bit_field.h
│   │   ├── bit_mask.h
│   │   ├── bit_scan.h
│   │   ├── bit_swap.h
│   │   ├── byte_swap.h
│   │   ├── emugen_types.h
│   │   ├── endian.h
│   │   ├── flags.h
│   │   ├── log.cpp
│   │   ├── log.h
│   │   ├── memory.cpp
│   │   ├── memory.h
│   │   ├── ptr32.h
│   │   └── structmacros.h
│   ├── kernel
│   │   ├── connectx
│   │   │   ├── connectx.cpp
│   │   │   └── connectx.h
│   │   ├── createprofile
│   │   │   ├── createprofile.cpp
│   │   │   └── createprofile.h
│   │   ├── kernel.h
│   │   ├── module.h
│   │   ├── vk
│   │   │   ├── vk.cpp
│   │   │   └── vk.h
│   │   ├── xam
│   │   │   ├── xam.cpp
│   │   │   └── xam.h
│   │   ├── xapi
│   │   │   ├── xapi.cpp
│   │   │   └── xapi.h
│   │   ├── xbdm
│   │   │   ├── xbdm.cpp
│   │   │   └── xbdm.h
│   │   └── xboxkrnl
│   │       ├── criticalsection.cpp
│   │       ├── criticalsection.h
│   │       ├── debug.cpp
│   │       ├── debug.h
│   │       ├── event.h
│   │       ├── exports.h
│   │       ├── hardware.cpp
│   │       ├── hardware.h
│   │       ├── ntstructs.h
│   │       ├── object.h
│   │       ├── process.cpp
│   │       ├── process.h
│   │       ├── spinlock.cpp
│   │       ├── spinlock.h
│   │       ├── thread.cpp
│   │       ├── thread.h
│   │       ├── tls.cpp
│   │       ├── tls.h
│   │       ├── version.cpp
│   │       ├── version.h
│   │       ├── virtualmemory.cpp
│   │       ├── virtualmemory.h
│   │       ├── xboxkrnl.cpp
│   │       ├── xboxkrnl.h
│   │       ├── xex.cpp
│   │       └── xex.h
│   ├── kernel.cpp
│   ├── main.cpp
│   ├── powerpc
│   │   ├── cpu.h
│   │   ├── decoder.cpp
│   │   ├── decoder.h
│   │   ├── disassembler
│   │   │   ├── disassembler.cpp
│   │   │   └── disassembler.h
│   │   ├── emugen.txt
│   │   ├── emugen_cpu_info.h
│   │   ├── emugen_decoder.h
│   │   ├── emugen_instructionid.h
│   │   ├── emugen_instructions.h
│   │   ├── emugen_stubs.cpp
│   │   ├── emugen_stubs.h
│   │   ├── emugen_table.h
│   │   ├── instructions.cpp
│   │   ├── instructions.h
│   │   ├── interpreter
│   │   │   ├── alu.cpp
│   │   │   ├── cpu.cpp
│   │   │   ├── flow.cpp
│   │   │   ├── fpu.cpp
│   │   │   ├── fpu.h
│   │   │   ├── interpreter.cpp
│   │   │   ├── interpreter.h
│   │   │   ├── kernel.cpp
│   │   │   ├── load.cpp
│   │   │   ├── mmu.cpp
│   │   │   ├── regs.h
│   │   │   └── store.cpp
│   │   └── translator
│   │       ├── alu.cpp
│   │       ├── stubs.cpp
│   │       ├── translator.cpp
│   │       └── translator.h
│   ├── system.cpp
│   ├── system.h
│   └── xex
│       ├── aes.h
│       ├── biginputstream.h
│       ├── loader.cpp
│       ├── optionalheaders.h
│       ├── rijndael-alf-fst.cpp
│       ├── rijndael-alg-fst.h
│       └── xex.h
├── tests
│   └── ppc
│       ├── alu
│       │   ├── add.s
│       │   ├── add_overflow.s
│       │   ├── add_record_negative.s
│       │   ├── add_record_overflow.s
│       │   ├── add_record_positive.s
│       │   ├── add_record_zero.s
│       │   ├── addc.s
│       │   ├── adde.s
│       │   ├── addi.s
│       │   ├── addic.s
│       │   ├── addis.s
│       │   ├── addme.s
│       │   ├── addze.s
│       │   ├── alu_todo.txt
│       │   ├── and.s
│       │   ├── and_record.s
│       │   ├── andc.s
│       │   ├── andc_record.s
│       │   ├── andi.s
│       │   ├── andis.s
│       │   ├── cntlzw.s
│       │   ├── divd.s
│       │   ├── divdu.s
│       │   ├── divw.s
│       │   ├── divwu.s
│       │   ├── eqv.s
│       │   ├── extsb.s
│       │   ├── extsh.s
│       │   ├── extsw.s
│       │   ├── rlwimi.s
│       │   ├── rlwimi_record.s
│       │   ├── rlwinm.s
│       │   ├── rlwinm_record.s
│       │   ├── rlwnm.s
│       │   └── rlwnm_record.s
│       ├── flow
│       │   ├── b.s
│       │   ├── ba.s
│       │   ├── bc_equal.s
│       │   ├── bc_greater_than.s
│       │   ├── bc_less_than.s
│       │   ├── bc_not_equal.s
│       │   ├── bl.s
│       │   ├── bla.s
│       │   ├── cmp_equal.s
│       │   ├── cmp_greater.s
│       │   ├── cmp_less.s
│       │   ├── crand.s
│       │   ├── crandc.s
│       │   ├── creqv.s
│       │   ├── crnand.s
│       │   ├── crnor.s
│       │   ├── cror.s
│       │   ├── crorc.s
│       │   └── crxor.s
│       ├── fpu
│       │   ├── fabs.s
│       │   └── fadd.s
│       ├── load
│       │   ├── lbz.s
│       │   ├── lbzu.s
│       │   ├── lbzux.s
│       │   ├── lbzx.s
│       │   ├── ld.s
│       │   ├── ldu.s
│       │   ├── ldux.s
│       │   ├── ldx.s
│       │   └── load_todo.txt
│       └── mmu
│           └── mmu_todo.txt
└── tools
    ├── emugen
    │   ├── ast.h
    │   ├── emugen.cpp
    │   ├── emugen.h
    │   ├── main.cpp
    │   └── parser.cpp
    └── ex360tester
        ├── elf.h
        ├── main.cpp
        ├── parser.cpp
        ├── parser.h
        ├── test.cpp
        ├── test.h
        ├── tester.cpp
        ├── tester.h
        ├── xenon.cpp
        └── xenon.h

```

`docs/kernel/ordinals/connectx.ord`:

```ord
0 : connectx.dll
1 : CxGetVersion
2 : NbtNetbios
3 : SmbCloseHandle
4 : SmbCreateDirectoryW
5 : SmbCreateFileW
6 : SmbDeleteFileW
7 : SmbFindClose
8 : SmbFindFirstFileW
9 : SmbFindNextFile
10 : SmbFlushFileBuffers
11 : SmbGetDiskFreeSpaceW
12 : SmbGetFileAttributesW
13 : SmbGetFileInformationByHandle
14 : SmbGetFileSize
15 : SmbGetFileTime
16 : SmbMoveFileW
17 : SmbReadFile
18 : SmbRemoveDirectoryW
19 : SmbSetEndOfFile
20 : SmbSetFileAttributesW
21 : SmbSetFilePointer
22 : SmbSetFileTime
23 : SmbStartup
24 : SmbWriteFile

```

`docs/kernel/ordinals/createprofile.ord`:

```ord
0 : CreateProfile.dll
1 : CreateProfile_Register
2 : CreateProfile_Unregister

```

`docs/kernel/ordinals/dump_ordinals.idc`:

```idc
#include <idc.idc>

static main() {
   auto entryPoints, i, ord, addr, name, purged, file, fd;
   
   file = AskFile(1, "*.ord", "Select Ordinal save file");
   
   fd = fopen(file, "w");
   entryPoints = GetEntryPointQty();
   
   fprintf(fd, "0 : %s\n", GetInputFile());
   
   for (i = 0; i < entryPoints; i++) {
      ord = GetEntryOrdinal(i);
      if (ord == 0) {
		continue;
	  }
	  
      addr = GetEntryPoint(ord);
	  
      if (ord == addr) {
         continue;
      }
	  
      name = Name(addr);
      fprintf(fd, "%d : %s\n", ord, name);
   }
}

```

`docs/kernel/ordinals/syscall.ord`:

```ord
0 : syscall
0 : HvxGetVersions
1 : HvxStartupProcessors
2 : HvxQuiesceProcessor
3 : HvxFlushEntireTb
4 : HvxFlushSingleTb
5 : HvxRelocateAndFlush
6 : HvxGetSpecialPurposeRegister
7 : HvxSetSpecialPurposeRegister
8 : HvxGetSocRegister
9 : HvxSetSocRegister
10 : HvxSetTimeBaseToZero
11 : HvxZeroPage
12 : HvxFlushDcacheRange
13 : HvxPostOutput
14 : HvxEnablePPUPerformanceMonitor
15 : HvxGetImagePageTableEntry
16 : HvxSetImagePageTableEntry
17 : HvxCreateImageMapping
18 : HvxMapImagePage
19 : HvxCompleteImageMapping
20 : HvxLoadImageData
21 : HvxFinishImageDataLoad
22 : HvxStartResolveImports
23 : HvxResolveImports
24 : HvxFinishImageLoad
25 : HvxAbandonImageLoad
26 : HvxUnmapImagePages
27 : HvxUnmapImage
28 : HvxUnmapImageRange
29 : HvxCreateUserMode
30 : HvxDeleteUserMode
31 : HvxFlushUserModeTb
32 : HvxSetPowerMode
33 : HvxShadowBoot
34 : HvxBlowFuses
35 : HvxFsbInterrupt
36 : HvxLockL2
37 : HvxDvdAuthBuildNVPage
38 : HvxDvdAuthVerifyNVPage
39 : HvxDvdAuthRecordAuthenticationPage
40 : HvxDvdAuthRecordXControl
41 : HvxDvdAuthGetAuthPage
42 : HvxDvdAuthVerifyAuthPage
43 : HvxDvdAuthGetNextLBAIndex
44 : HvxDvdAuthVerifyLBA
45 : HvxDvdAuthClearDiscAuthInfo
46 : HvxKeysInitialize
47 : HvxKeysGetKeyProperties
48 : HvxKeysGetStatus
49 : HvxKeysGenerateRandomKey
50 : HvxKeysGetFactoryChallenge
51 : HvxKeysSetFactoryResponse
52 : HvxKeysSaveBootLoader
53 : HvxKeysSaveKeyVault
54 : HvxKeysSetKey
55 : HvxKeysGetKey
56 : HvxKeysGetDigest
57 : HvxKeysRsaPrvCrypt
58 : HvxKeysHmacSha
59 : HvxKeysAesCbc
60 : HvxKeysDes2Cbc
61 : HvxKeysDesCbc
62 : HvxKeysObscureKey
63 : HvxKeysSaveSystemUpdate
64 : HvxKeysExecute
65 : HvxDvdAuthTestMode
66 : HvxEnableTimebase
67 : HvxHdcpCalculateMi
68 : HvxHdcpCalculateAKsvSignature
69 : HvxHdcpCalculateBKsvSignature
70 : HvxSetRevocationList
71 : HvxEncryptedReserveAllocation
72 : HvxEncryptedReleaseAllocation
73 : HvxEncryptedEncryptAllocation
74 : HvxEncryptedSweepAddressRange
75 : HvxKeysExCreateKeyVault
76 : HvxKeysExLoadKeyVault
77 : HvxKeysExSaveKeyVault
78 : HvxKeysExSetKey
79 : HvxKeysExGetKey
80 : HvxGetUpdateSequence
81 : HvxSecurityInitialize
82 : HvxSecurityLoadSettings
83 : HvxSecuritySaveSettings
84 : HvxSecuritySetDetected
85 : HvxSecurityGetDetected
86 : HvxSecuritySetActivated
87 : HvxSecurityGetActivated
88 : HvxSecuritySetStat
89 : HvxGetProtectedFlags
90 : HvxSetProtectedFlag
91 : HvxDvdAuthGetAuthResults
92 : HvxDvdAuthSetDriveAuthResult
93 : HvxDvdAuthSetDiscAuthResult
94 : HvxImageTransformImageKey
95 : HvxImageXexHeader
96 : HvxRevokeLoad
97 : HvxRevokeSave
98 : HvxRevokeUpdate
99 : HvxDvdAuthGetMediaId
100 : HvxKeysLoadKeyVault
101 : HvxXexActivationGetNonce
102 : HvxXexActivationSetLicense
103 : HvxXexActivationVerifyOwnership
104 : HvxIptvSetBoundaryKey
105 : HvxIptvSetSessionKey
106 : HvxIptvVerifyOmac1Signature
107 : HvxIptvGetAesCtrTransform
108 : HvxIptvGetSessionKeyHash
109 : HvxImageDvdEmulationMode
110 : HvxImageUserMode
111 : HvxImageShim
112 : HvxExpansionInstall
113 : HvxExpansionCall
114 : HvxDvdAuthFwcr
115 : HvxDvdAuthFcrt
116 : HvxDvdAuthEx
117 : HvxTest
```

`docs/kernel/ordinals/vk.ord`:

```ord
0 : vk.dll
1 : _RegisterXuiClasses_CVKApp__EAAJXZ
2 : _VK_UnInit__YAXXZ
3 : _VK_CreateScene__YAJPAU_XVIRTUALKBDUI_PARAMS__PAPAU_XUIOBJ___Z
4 : _VK_GetUserCancelled__YAHPAU_XUIOBJ___Z

```

`docs/kernel/ordinals/xam.ord`:

```ord
0 : xamd.dll
1 : NetDll_WSAStartup
2 : NetDll_WSACleanup
3 : NetDll_socket
4 : NetDll_closesocket
5 : NetDll_shutdown
6 : NetDll_ioctlsocket
7 : NetDll_setsockopt
8 : NetDll_getsockopt
9 : NetDll_getsockname
10 : NetDll_getpeername
11 : NetDll_bind
12 : NetDll_connect
13 : NetDll_listen
14 : NetDll_accept
15 : NetDll_select
16 : NetDll_WSAGetOverlappedResult
17 : NetDll_WSACancelOverlappedIO
18 : NetDll_recv
19 : NetDll_WSARecv
20 : NetDll_recvfrom
21 : NetDll_WSARecvFrom
22 : NetDll_send
23 : NetDll_WSASend
24 : NetDll_sendto
25 : NetDll_WSASendTo
26 : NetDll_inet_addr
27 : NetDll_WSAGetLastError
28 : NetDll_WSASetLastError
29 : NetDll_WSACreateEvent
30 : NetDll_WSACloseEvent
31 : NetDll_WSASetEvent
32 : NetDll_WSAResetEvent
33 : NetDll_WSAWaitForMultipleEvents
34 : NetDll___WSAFDIsSet
35 : NetDll_WSAEventSelect
36 : NetDll_WSAStartupEx
51 : NetDll_XNetStartup
52 : NetDll_XNetCleanup
53 : NetDll_XNetRandom
54 : NetDll_XNetCreateKey
55 : NetDll_XNetRegisterKey
56 : NetDll_XNetUnregisterKey
57 : NetDll_XNetXnAddrToInAddr
58 : NetDll_XNetServerToInAddr
59 : NetDll_XNetTsAddrToInAddr
60 : NetDll_XNetInAddrToXnAddr
61 : NetDll_XNetInAddrToServer
62 : NetDll_XNetInAddrToString
63 : NetDll_XNetUnregisterInAddr
64 : NetDll_XNetXnAddrToMachineId
65 : NetDll_XNetConnect
66 : NetDll_XNetGetConnectStatus
67 : NetDll_XNetDnsLookup
68 : NetDll_XNetDnsRelease
69 : NetDll_XNetQosListen
70 : NetDll_XNetQosLookup
71 : NetDll_XNetQosServiceLookup
72 : NetDll_XNetQosRelease
73 : NetDll_XNetGetTitleXnAddr
74 : NetDll_XNetGetDebugXnAddr
75 : NetDll_XNetGetEthernetLinkStatus
76 : NetDll_XNetGetBroadcastVersionStatus
77 : NetDll_XNetQosGetListenStats
78 : NetDll_XNetGetOpt
79 : NetDll_XNetSetOpt
80 : NetDll_XNetStartupEx
81 : NetDll_XNetReplaceKey
82 : NetDll_XNetGetXnAddrPlatform
83 : NetDll_XNetGetSystemLinkPort
84 : NetDll_XNetSetSystemLinkPort
85 : NetDll_XNetDnsReverseLookup
86 : NetDll_XNetDnsReverseRelease
101 : NetDll_XnpLoadConfigParams
102 : NetDll_XnpSaveConfigParams
103 : NetDll_XnpConfigUPnP
104 : NetDll_XnpConfig
105 : NetDll_XnpGetConfigStatus
106 : NetDll_XnpLoadMachineAccount
107 : NetDll_XnpSaveMachineAccount
108 : NetDll_XnpCapture
109 : NetDll_XnpEthernetInterceptSetCallbacks
110 : NetDll_XnpEthernetInterceptXmit
111 : NetDll_XnpEthernetInterceptRecv
112 : NetDll_XnpLogonGetStatus
113 : NetDll_XnpLogonGetQFlags
114 : NetDll_XnpLogonSetQFlags
115 : NetDll_XnpLogonSetQEvent
116 : NetDll_XnpLogonClearQEvent
117 : NetDll_XnpLogonGetQVals
118 : NetDll_XnpLogonSetQVals
119 : NetDll_XnpLogonSetPState
120 : NetDll_XnpGetVlanXboxName
121 : NetDll_XnpSetVlanXboxName
122 : NetDll_XnpGetActiveSocketList
123 : NetDll_XnpNoteSystemTime
124 : NetDll_XnpRegisterKeyForCallerType
125 : NetDll_XnpUnregisterKeyForCallerType
126 : NetDll_XnpLogonGetChallenge
127 : NetDll_XnpLogonClearChallenge
128 : NetDll_XnpLogonSetChallengeResponse
129 : NetDll_XnpGetSecAssocList
130 : NetDll_XnpGetKeyList
131 : NetDll_XnpGetQosLookupList
132 : NetDll_XnpPersistTitleState
133 : NetDll_XnpReplaceKeyForCallerType
134 : NetDll_XnpEthernetInterceptSetExtendedReceiveCallback
135 : NetDll_XnpQosHistoryLoad
136 : NetDll_XnpQosHistorySaveMeasurements
137 : NetDll_XnpQosHistoryGetEntries
138 : NetDll_XnpQosHistoryGetAggregateMeasurement
139 : NetDll_XnpToolSetCallbacks
140 : NetDll_XnpToolIpProxyInject
141 : NetDll_XnpUpdateConfigParams
142 : NetDll_XnpEthernetInterceptXmitAsIp
151 : NetDll_XmlDownloadStart
152 : NetDll_XmlDownloadContinue
153 : NetDll_XmlDownloadStop
154 : NetDll_XmlDownloadGetParseTime
155 : NetDll_XmlDownloadGetReceivedDataSize
198 : XnpGetXwppMemoryLogSnapshot
199 : XnpGetXwppRuntimeFilter
201 : NetDll_XHttpStartup
202 : NetDll_XHttpShutdown
203 : NetDll_XHttpOpen
204 : NetDll_XHttpCloseHandle
205 : NetDll_XHttpConnect
206 : NetDll_XHttpSetStatusCallback
207 : NetDll_XHttpOpenRequest
208 : NetDll_XHttpOpenRequestUsingMemory
209 : NetDll_XHttpSendRequest
210 : NetDll_XHttpReceiveResponse
211 : NetDll_XHttpQueryHeaders
212 : NetDll_XHttpReadData
213 : NetDll_XHttpWriteData
214 : NetDll_XHttpQueryOption
215 : NetDll_XHttpSetOption
216 : NetDll_XHttpDoWork
217 : NetDll_XHttpSetCredentials
218 : NetDll_XHttpQueryAuthSchemes
219 : NetDll_XHttpCrackUrlW
220 : NetDll_XHttpCrackUrl
221 : NetDll_XHttpCreateUrl
222 : NetDll_XHttpCreateUrlW
251 : NetDll_UpnpStartup
252 : NetDll_UpnpCleanup
253 : NetDll_UpnpSearchCreate
254 : NetDll_UpnpSearchGetDevices
255 : NetDll_UpnpDescribeCreate
256 : NetDll_UpnpDescribeGetResults
257 : NetDll_UpnpActionCalculateWorkBufferSize
258 : NetDll_UpnpActionCreate
259 : NetDll_UpnpActionGetResults
260 : NetDll_UpnpEventCreate
261 : NetDll_UpnpEventGetCurrentState
262 : NetDll_UpnpEventUnsubscribe
263 : NetDll_UpnpDoWork
264 : NetDll_UpnpCloseHandle
301 : XNetLogonGetLoggedOnUsers
302 : XNetLogonGetNatType
303 : XNetLogonTaskStart
304 : XNetLogonTaskClose
305 : XNetLogonTaskContinue
306 : XNetLogonGetServiceInfo
307 : XNetLogonGetUserPrivileges
308 : XNetLogonSetConsoleCertificate
309 : XNetLogonGetMachineID
310 : XNetLogonGetTitleID
311 : XNetLogonGetTitleVersion
312 : XNetLogonGetServiceNetworkID
313 : XNetLogonGetDnsString
314 : XNetLogonSetTitleID
315 : XNetLogonGetExtendedStatus
316 : XNetLogonClearTicketCaches
317 : XNetLogonInitOverrideInfo
318 : XNetLogonGetLastUPnPStatus
319 : XNetLogonGetFlowToken
320 : XNetLogonGetTicketOpt
321 : XNetLogonSetTicketOpt
322 : XNetLogonGetState
400 : XamInputGetCapabilities
401 : XamInputGetState
402 : XamInputSetState
403 : XamInputGetKeystroke
404 : XamInputEnableAutobind
405 : _XamInputRawState__YAKKKHPAU_XINPUT_RAW___Z
406 : XamEnableSystemAppInput
407 : XamInputGetDeviceStats
408 : XamInputGetKeystrokeEx
409 : XamInputGetKeystrokeHud
410 : XamInputSetLayoutKeyboard
411 : XamInputToggleKeyLocks
412 : XamInputResetLayoutKeyboard
413 : XamInputGetKeystrokeHudEx
414 : XamInputSetKeyboardTranslationHud
415 : XamSetInactivityTime
416 : XamEnableInactivityProcessing
417 : XamResetInactivity
418 : XamSetInactivityTimeFromConfig
419 : _XamLoaderGetMediaInfo__YAXPAK0_Z
420 : _XamLoaderLaunchTitle__YAXPBDK_Z
421 : _XamLoaderLaunchTitleEx__YAXPBD00K_Z
422 : _XamLoaderSetLaunchData__YAKPAXK_Z
423 : _XamLoaderGetLaunchDataSize__YAKPAK_Z
424 : _XamLoaderGetLaunchData__YAKPAXK_Z
425 : _XamLoaderTerminateTitle__YAXXZ
426 : _XamLoaderGetDvdTrayState__YAKXZ
427 : _XamLoaderGetGameInfo__YAJPA_WKPAPAEPA_K_Z
428 : _XamLoaderLaunchTitleOnDvd__YAJK_Z
429 : _XamLoaderSetSpindleSpeed__YAJKH_Z
430 : XamTaskCreateQueue
431 : XamTaskSchedule
432 : XamTaskReschedule
433 : XamTaskCloseHandle
434 : XamTaskCancel
435 : XamTaskShouldExit
436 : XamTaskWaitOnCompletion
437 : XamTaskModify
438 : XamTaskGetCurrentTask
439 : XamTaskGetAttributes
440 : XamExecutingOnBehalfOfTitle
441 : XamInputSendStayAliveRequest
442 : _XamInputGetUserVibrationLevel__YAKKPAK_Z
443 : XamIsSystemTitleId
444 : _XamLoaderIsTitleTerminatePending__YAKXZ
445 : XamInputSetTextMessengerIndicator
446 : _XamLoaderGetPriorTitleId__YAKXZ
447 : XamIsXbox1TitleId
448 : XamInputSetKeyLocks
449 : XamInputGetKeyLocks
450 : XamTaskGetStatus
451 : XamGetRootObj
452 : _XamDevAuthSetFault__YAJQAUDevAuthFault__K_Z
453 : XamGetDefaultSystemImage
454 : XamGetWCNConfigFile
455 : XamSetPowerMode
456 : XamExecuteChallenge
457 : XamGetDefaultImage
458 : XamMuteSound
459 : XamGetOnlineSchema
460 : XamSetDashContext
461 : XamGetDashContext
462 : XamIsCurrentTitleDash
463 : XamGetCurrentTitleId
464 : XamSetCurrentTitleDash
465 : _XamAllocHeapFreeSpace__YAKW4XAMALLOC_HEAP_ID___Z
466 : XamSetDashContextEx
467 : XamGetDashContextEx
468 : XamSetHudContext
469 : XamGetHudContext
471 : _Refresh_CGamerCardWorker__MAAJXZ
472 : XCustomSetAction
473 : XCustomGetLastActionPress
474 : XCustomSetDynamicActions
475 : XCustomBroadcastActionEvent
476 : XCustomGetLastActionPressEx
477 : XCustomRegisterDynamicActions
478 : XCustomUnregisterDynamicActions
479 : XCustomGetCurrentGamercard
480 : XamDbgPrint
481 : XamDbgSetOutputLevel
482 : XamDbgSetBreakLevel
483 : _XamLoaderGetMediaInfoEx__YAXPAK00_Z
484 : XamLoaderSetGameInfo
485 : XamFormatMessage
486 : XamUniSortCmpString
487 : XamFormatTimeString
488 : XamFormatDateString
489 : XamGetLocaleDateFormat
490 : XamAlloc
491 : XamAllocEx
492 : XamFree
493 : XamAllocSize
494 : _ProcessRemoteInput_XAMAuditionHost__UAAJPBU_XINPUT_KEYSTROKE___Z
495 : _ProcessRemoteInput_XAMAuditionHost__UAAJPBU_XINPUT_KEYSTROKE___Z
496 : XamAllocFreeIPTVHeap
497 : XamDeviceRemap
498 : XamLoaderGetClearCache
499 : XamLoaderSetClearCache
500 : XMsgInProcessCall
501 : XMsgCompleteIORequest
502 : XMsgSystemProcessCall
503 : XMsgStartIORequest
504 : XMsgCancelIORequest
505 : XMsgAcquireAsyncMessageFromOverlapped
506 : XMsgReleaseAsyncMessageToOverlapped
507 : XamGetOverlappedResult
508 : XMsgStartIORequestEx
509 : XamAppAllocateInterappWorkspace
510 : XamAppGetInterappWorkspace
511 : XamAppFreeInterappWorkspace
512 : XamFeatureEnabled
513 : XamFeatureEnforceImageBudget
514 : XamFeatureSetMask
515 : XamFeatureEnableDisable
516 : XuiControlSetItemAssociation
517 : XamGetTitleGlobalStorageValue
518 : XamSetTitleGlobalStorageValue
519 : XamUserValidateAvatarMetadata
520 : XamUserGetDeviceContext
521 : XamUserLookupDevice
522 : XamUserGetXUID
523 : XamUserLogon
524 : XamUserGetGamerTag
525 : XamUserGetUserIndexMask
526 : XamUserGetName
527 : XamLookupCommonStringByIndex
528 : XamUserGetSigninState
529 : XamUserGetIndexFromXUID
530 : XamUserCheckPrivilege
531 : XamUserAreUsersFriends
532 : XamSetUserPresetPresenceState
533 : XamGetUserPresetPresenceState
534 : XamUserGetUserFlagsFromXUID
535 : XamUserGetMembershipTypeFromXUID
536 : XamUserGetOnlineCountryFromXUID
537 : XamUserReadProfileSettings
538 : XamUserWriteProfileSettings
539 : XamUserGetMembershipType
540 : XamUserGetUserFlags
541 : XamUserGetRequestedUserIndexMask
542 : XamUserIsGuest
543 : XamUserProfileSync
544 : XamUserFlushLogonQueue
545 : XamUserIsOnlineEnabled
546 : XamUserGetCachedUserFlags
547 : XamAreMixedAccountsSignedIn
548 : XamUserLogonEx
549 : XamSetUserShowMessengerFriends
550 : XamGetUserShowMessengerFriends
551 : XamUserGetSigninInfo
552 : XamUserIsPartial
553 : XamUserGetOnlineLanguageFromXUID
554 : XamUserReadProfileSettingsEx
555 : XamSystemUpdaterLogon
556 : XamUserGetUsersMissingAvatars
557 : XamIsChildAccountSignedIn
558 : XamUserPrefetchProfileSettings
559 : XamUserInvalidateProfileSetting
560 : XamProfileCreate
561 : XamProfileCreateEnumerator
562 : XamProfileEnumerate
563 : XamProfileDelete
564 : XamProfileGetCreationStatus
565 : XamProfileFindAccount
566 : XamProfileRenameAccount
567 : XamProfileOpen
568 : XamProfileClose
569 : XamProfileSaveAccountInfo
570 : XamProfileLoadAccountInfo
571 : XamProfileRecoverTitle
572 : XamProfileSaveWindowsLiveCredentials
573 : XamProfileLoadWindowsLiveCredentials
574 : XamProfileIsSaveWindowsLiveCredsEnabled
575 : XamProfileSetSaveWindowsLiveCredsEnabled
576 : XamSetProfileReadTestHook
577 : XamProfileGetLastSync
578 : XamAccountRecoveryRecoverTitle
579 : XamProfileControlXgi
580 : XamAppLoad
581 : XamAppUnloadSelf
582 : XamAppUnloadStack
583 : XamSendMessageToLoadedApps
584 : XamAppRequestLoad
585 : XamAppUnrequestLoad
586 : XamNavigate
587 : XamRegisterSysApp
588 : XamUnregisterSysApp
590 : XamCreateEnumeratorHandle
591 : XamGetPrivateEnumStructureFromHandle
592 : XamEnumerate
593 : XamLoadSysApp
594 : XamUnloadSysApp
595 : XamReloadSysApp
596 : XamAppLoadPass2SysApps
597 : XamProfileGetLiveLegalLocale
598 : XamUserIsParentalControlled
599 : XamContentLaunchImageFromFileInternal
600 : XamContentCreate
601 : XamContentCreateEx
602 : XamContentClose
603 : XamContentDelete
604 : XamContentCreateEnumerator
605 : XamContentCreateDeviceEnumerator
606 : XamContentGetDeviceData
607 : XamContentGetDeviceName
608 : XamContentSetThumbnail
609 : XamContentGetThumbnail
610 : XamContentGetCreator
611 : XamContentLaunchImage
612 : XamContentGetAttributes
613 : XamContentGetDeviceState
614 : XamContentGetLicenseMask
615 : XamContentFlush
616 : XamContentResolve
617 : XamContentOpenFile
618 : XamContentInstall
619 : XamContentLockUnlockPackageHeaders
620 : XamContentCopyInternal
621 : XamContentMoveInternal
622 : XamContentGetMetaDataInternal
623 : XamContentCreateEnumeratorInternal
624 : XamContentDeleteInternal
625 : XamContentCreateInternal
626 : XamContentSetThumbnailInternal
627 : XamContentLaunchImageInternal
628 : XamContentWritePackageHeader
629 : XamContentDismountAndClosePackage
630 : XamContentResolveInternal
631 : XamContentGetAttributesInternal
632 : XamContentOpenFileInternal
633 : XamContentAggregateCreateEnumerator
634 : XamContentCreateAndMountPackage
635 : XamContentOpenPackageFile
636 : XamContentMountPackage
637 : XamContentFlushPackage
638 : XamContentClosePackageFile
639 : XamContentDuplicateFileHandle
640 : XamGetExecutionId
641 : XamGetGameRatings
642 : XamGetSystemVersion
643 : XamContentGetLocalizedString
644 : XamContentGetDefaultDevice
645 : XamContentInstallInternal
646 : XamContentSetMediaMetaDataInternal
647 : XamContentGetDeviceSerialNumber
648 : XamContentGetMountedPackageByRootName
649 : XamContentRegisterChangeCallback
650 : XamNotifyCreateListener
651 : XNotifyGetNext
652 : XNotifyPositionUI
653 : XNotifyDelayUI
654 : XNotifyBroadcast
655 : XNotifyRegisterArea
656 : XNotifyQueueUI
657 : XamNotifyCreateListenerInternal
658 : XNotifyUISetOptions
659 : XNotifyUIGetOptions
660 : XamContentLaunchImageInternalEx
661 : XamShutdown
662 : XamAllocDevkitHeapAvailable
663 : XamNotifyCreateListenerRangeInternal
664 : XNotifyQueueUIEx
665 : XamAppRequestLoadEx
666 : XuiPNGTextureLoader
667 : XuiRenderGetXuiDevice
668 : XuiDefault_False
669 : XamUserGetReportingInfo
670 : XamUpdateStart
671 : XamUpdateGetProgress
673 : XamUpdateFinish
674 : XamUpdateAttachExtenderInstance
678 : XamUpdateGetBaseSystemVersion
679 : XamUpdateGetCurrentSystemVersion
683 : XamUpdateChainPass3FromPass2
685 : XamInputGetCapabilitiesEx
686 : XamUserIsUnsafeProgrammingAllowed
687 : _XamDevAuthSetFaultEx__YAJQAUDevAuthFault__KHH_Z
688 : _XamUpdateGetData__YAJPAXKPAEPAK_Z
689 : _XamCacheIntegrityCheck__YAXXZ
690 : XamCacheStoreFile
691 : XamCacheFetchFile
692 : XamCacheOpenFile
693 : XamCacheCloseFile
694 : XamGetCachedTitleName
695 : XamCacheReset
696 : XamGetCachedGamerTag
697 : XamGetCachedGamerTagW
698 : XamCacheDeleteFile
699 : XamCacheRenameFile
700 : XamShowSigninUI
701 : XamShowSigninUIEx
702 : XamShowSigninUIp
703 : XamShowFriendsUI
704 : XamShowMessagesUI
705 : XamShowKeyboardUI
706 : XamShowQuickChatUI
707 : XamShowVoiceMailUI
708 : XamShowGamerCardUI
709 : XamShowAchievementsUI
710 : XamShowPlayerReviewUI
711 : XamShowMarketplaceUI
712 : XamShowPlayersUI
713 : XamShowUpdaterUI
714 : XamShowMessageBoxUI
715 : XamShowDeviceSelectorUI
716 : XamShowMessageComposeUI
717 : XamShowGameInviteUI
718 : XamShowFriendRequestUI
719 : XamShowCreateProfileUI
720 : XamShowGamesUI
721 : XamShowLiveSignupUI
722 : XamShowFriendsUIp
723 : XamShowComplaintUI
724 : XamShowReputationUI
725 : XamShowGamerCardUIForXUID
726 : XamShowForcedNameChangeUI
727 : XamShowLiveUpsellUI
728 : XamShowPasscodeVerifyUI
729 : XamShowDirtyDiscErrorUI
730 : XamShowSignupCreditCardUI
731 : XamShowPrivateChatInviteUI
732 : XamShowMessageBoxUIEx
733 : XamShowRecentMessageUI
734 : XamShowRecentMessageUIEx
735 : XamShowMessagesUIEx
736 : XamShowAchievementDetailsUI
737 : XamShowPersonalizationUI
738 : XamShowChangeGamerTileUI
739 : XamShowVoiceSettingsUI
740 : XamShowVideoChatInviteUI
741 : XamShowCustomMessageComposeUI
742 : _XamShowCustomPlayerListUI__YAKKKPB_W0PBEKPBUXPLAYERLIST_USER__GPBUXPLAYERLIST_BUTTON__3PAUXPLAYERLIST_RESULT__PAU_XOVERLAPPED___Z
743 : XamShowMarketplaceDownloadItemsUI
744 : XamShowMarketplaceUIEx
745 : XamShowMessageBox
746 : XamIsSysUiInvokedByXenonButton
747 : XamIsSysUiInvokedByTitle
748 : XamIsUIActive
749 : XamSysUiDisableAutoClose
750 : XamUserCreateAchievementEnumerator
751 : XamReadTile
752 : XamWriteGamerTile
753 : XamWriteTile
754 : _XamReadImage__YAJW4XTILETYPE__KK_KPAPAU_XUIBRUSH___Z
755 : XamUserCreateTitlesPlayedEnumerator
756 : XamDecompressPNGToTexture
757 : XamReadTileToTexture
758 : XamReadString
759 : XamUserCreateStatsEnumerator
760 : XamPrepareGamerTiles
761 : XamClearTitle
762 : XamReadStrings
763 : XamWriteGamerTileEx
764 : XamReadTileEx
765 : XamReadTileToTextureEx
766 : XamShowMessengerUI
767 : XamShowKeyboardUIMessenger
768 : XamShowLiveUpsellUIEx
769 : XamShowJoinSessionInProgressUI
770 : XamShowGraduateUserUI
771 : XamShowGamerCardUIForXUIDp
772 : XamShowGuideUI
773 : XamShowPartyUI
774 : XamShowPartyInviteUI
775 : XamUserAddRecentPlayer
776 : XamUserUpdateRecentPlayer
777 : XamUserCreatePlayerEnumerator
778 : XamParseGamerTileKey
779 : XamShowCommunitySessionsUI
780 : XamVoiceCreate
781 : XamVoiceHeadsetPresent
782 : XamVoiceSubmitPacket
783 : XamVoiceClose
784 : XamVoiceGetBatteryStatus
785 : _Refresh_CGamerCardWorker__MAAJXZ
786 : _Refresh_CGamerCardWorker__MAAJXZ
787 : XamShowJoinSessionByIdInProgressUI
788 : XamShowPartyJoinInProgressUI
789 : XamBuildSharedSystemResourceLocator
790 : XamSessionCreateHandle
791 : XamSessionRefObjByHandle
792 : XamVoiceGetMicArrayStatus
793 : XamVoiceSetAudioCaptureRoutine
794 : XamVoiceGetDirectionalData
795 : XamBuildResourceLocator
796 : _XamBuildLegacySystemResourceLocator__YAJPB_WPA_WK_Z
797 : XamBuildGamercardResourceLocator
798 : XamBuildDynamicResourceLocator
799 : XamBuildXamResourceLocator
800 : XuiAnimRun
801 : XuiApplyLocale
802 : XuiBubbleMessage
803 : XuiControlIsBackButton
804 : XuiControlIsNavButton
805 : XuiCreateObject
806 : XuiDestroyObject
807 : XuiDynamicCast
808 : XuiElementAddChild
809 : XuiElementFindNamedFrame
810 : XuiElementGetChildById
811 : XuiElementGetFirstChild
812 : XuiElementGetFocus
813 : XuiElementGetFocusUser
814 : XuiElementGetId
815 : XuiElementGetLastChild
816 : XuiElementGetNext
817 : XuiElementGetParent
818 : XuiElementGetUserFocus
819 : XuiElementInitFocus
820 : XuiElementInitUserFocus
821 : XuiElementPlayTimeline
822 : XuiElementSetBounds
823 : XuiElementSetFocus
824 : XuiElementSetUserFocus
825 : XuiElementTreeGetFocus
826 : XuiFindClass
827 : XuiFreeStringTable
828 : XuiGetBaseObject
829 : XuiGetClass
830 : XuiGetObjectClass
831 : XuiGetOuter
832 : XuiInit
833 : XuiLoadFromBinary
834 : XuiLoadStringTableFromFile
835 : XuiVisualGetBasePath
836 : XuiLookupStringTable
837 : XuiNavButtonGetPressPath
838 : XuiObjectFromHandle
839 : XuiObjectGetProperty
840 : XuiObjectGetPropertyId
841 : XuiProcessInput
842 : XuiRegisterClass
843 : XuiRenderBegin
844 : XuiRenderCreateDC
845 : XuiRenderDCDeviceChanged
846 : XuiRenderDestroyDC
847 : XuiRenderEnd
848 : XuiRenderGetBackBufferSize
849 : XuiRenderInit
850 : XuiRenderInitShared
851 : XuiRenderPresent
852 : XuiRenderSetViewTransform
853 : XuiRenderUninit
854 : XamShowNuiGuideUI
855 : XuiSceneCreate
856 : XuiSceneNavigateBack
857 : XuiSceneNavigateFirst
858 : XuiSceneNavigateForward
859 : XuiScenePlayBackFromTransition
860 : XuiScenePlayBackToTransition
861 : XuiScenePlayFromTransition
862 : XuiScenePlayToTransition
863 : XuiSendMessage
864 : XuiSetLocale
865 : XuiUninit
866 : XuiUnregisterClass
867 : XuiTextElementSetText
868 : XuiSetTimer
869 : XuiTimersRun
870 : XuiTextElementGetText
871 : XuiVisualSetBasePath
872 : XuiHandleIsValid
873 : XuiAlloc
874 : XuiFree
875 : XuiDefault_True
876 : XuiDefault_EmptyString
877 : XuiDefault_IntegerZero
878 : XuiCopyString
879 : XuiRealloc
880 : XuiControlPlayOptionalVisual
881 : XuiKillTimer
882 : XuiElementEnableInput
883 : XuiElementInputEnabled
884 : XuiIsInstanceOf
885 : XuiResourceComposeLocator
886 : XuiResourceLocatorIsAbsolute
887 : XuiBroadcastMessage
888 : XuiElementDisallowRecursiveTimelineControl
889 : XUIElementPropVal_Construct
890 : XUIElementPropVal_Destruct
891 : XUIElementPropVal_SetString
892 : XuiObjectSetProperty
893 : XuiElementGetOpacity
894 : XuiElementSetOpacity
895 : XuiEditSetTextLimit
896 : XuiEditGetTextLimit
897 : XuiSliderSetValue
898 : XuiSliderGetValue
899 : XuiSliderSetRange
900 : XuiElementUnlink
901 : XuiElementInsertChild
902 : XuiSceneNavigateBackToFirst
903 : XuiProgressBarSetRange
904 : XuiProgressBarSetValue
905 : XuiProgressBarGetValue
906 : XuiControlAttachVisual
907 : XuiCreateTextureBrush
908 : XuiDestroyBrush
909 : XUIElementPropVal_SetColorFromUint
910 : XuiFigureSetFill
911 : XuiSliderGetRange
912 : XuiFigureSetTexture
913 : XuiControlGetItemAssociation
914 : XuiResourceLoadAll
915 : XuiImageElementSetImagePath
916 : XuiImageElementGetImagePath
917 : XuiControlGetVisual
918 : XuiControlGetNavigation
919 : XuiLookupStringTableByIndex
920 : XUIElementPropVal_SetBool
921 : XuiElementHasFocus
922 : XUIElementPropVal_SetUint
923 : XUIElementPropVal_Clear
924 : XuiEditSetTextFormatInfo
925 : XuiCreateSolidBrush
926 : XuiSceneInterruptTransitions
927 : XuiResourceOpen
928 : XuiResourceRead
929 : XuiResourceClose
930 : XuiVisualCreateInstance
931 : XuiElementGetTimeline
932 : _GetCodecVersion_CCalMediaInfo__UBAKXZ
933 : XuiElementIsDescendant
934 : XuiSetMessageFilter
935 : XuiAttachTextureBrush
936 : XuiElementBeginRender
937 : XuiElementEndRender
938 : XuiDrawShape
939 : XuiSelectBrushEx
940 : XuiFigureGetShape
941 : XuiFillRect
942 : _XuiVec2TransformCoord__YAPAUD3DXVECTOR2__PAU1_PBU1_PBUD3DXMATRIX___Z
943 : _XuiMatrixMultiply__YAPAUD3DXMATRIX__PAU1_PBU1_1_Z
944 : XuiElementGetXForm
945 : XuiElementSetPosition
946 : XuiSelectBrush
947 : XuiElementRenderChildren
948 : XuiFreeUnusedTextures
949 : XuiListEnableItemOverride
950 : XuiListGetDefaultItemSize
951 : XuiResourceSeek
952 : XuiElementDiscardResources
953 : XuiTabSceneGoto
954 : XuiTabSceneGetCurrentTab
955 : XamShowWhatsOnUI
956 : XamShowEditProfileUI
957 : XamShowStorePickerUI
958 : XamShowTermsOfUseUI
959 : XamShowJoinPartyUI
960 : XamShowWordRegisterUI
961 : XamOverrideHudOpenType
962 : XamShowAchievementsUIEx
963 : XamUserGetUserTenure
964 : XamUserGetSubscriptionType
965 : XamShowGameVoiceChannelUI
966 : XamShowAvatarAwardsUI
967 : XamShowAvatarAwardGamesUI
968 : XamShowVideoRichPresenceUI
969 : XamHudGetUserIndex
970 : XGetAudioFlags
971 : XGetAVPack
972 : XGetGameRegion
973 : XGetLanguage
974 : XapipGetLocale
975 : _XGetVideoFlags__YAKXZ
976 : XGetVideoStandard
977 : XGetVideoMode
978 : XamGetLanguage
979 : XUITimeline_Run
980 : XamSetAutomation
981 : XAutomationpBindController
982 : XAutomationpUnbindController
983 : XAutomationpInputXenonButton
984 : XAutomationpInputPress
985 : XAutomationpInputSetState
986 : XamEnableOverdraw
987 : g_XuiAutomation
988 : XamVoiceGetMicArrayAudio
989 : XampSystemInput
990 : _XamInputControl__YAKKKPAU_XINPUT_CONTROL_REQUEST___Z
991 : XuiElementGetPosition
992 : XamIsMessageBoxActive
993 : XamIsBackgroundSceneInTransition
994 : XuiElementTreeHasFocus
995 : XuiFigureClose
996 : GamerCardStartup
997 : GamerCardCleanup
998 : GamerCardRegisterControls
999 : GamerCardUnregisterControls
1000 : RtlFindFirstFile
1001 : RtlFindNextFile
1002 : RtlGetModuleFileName
1003 : RtlOutputDebugString
1004 : RtlRemoveDirectory
1005 : RtlSleep
1006 : RtlGetLastError
1007 : RtlSetLastError
1008 : RtlSetLastNTError
1009 : RtlDebugPrint
1010 : RtlDebugError
1011 : XDebugWarning
1012 : RtlDebugTrace
1013 : RtlDebugEntry
1014 : RtlDebugExit
1015 : RtlGetAttributesOnHeapAlloc
1016 : RtlSetAttributesOnHeapAlloc
1017 : XuiFigureSetShape
1018 : RtlCreateHeap
1019 : RtlDestroyHeap
1020 : RtlAllocateHeap
1021 : RtlAllocateHeapSlowly
1022 : RtlReAllocateHeap
1023 : RtlFreeHeap
1024 : RtlFreeHeapSlowly
1025 : RtlSizeHeap
1026 : RtlZeroHeap
1027 : RtlDebugWalkHeap
1028 : RtlWalkHeap
1029 : RtlLockHeap
1030 : RtlUnlockHeap
1031 : RtlValidateHeap
1032 : RtlDebugCompactHeap
1033 : RtlCompactHeap
1034 : XamAppSetTestOption
1035 : XamAppReportError
1036 : XamIsNuiUIActive
1037 : XamVerifyPasscode
1038 : OutputDebugStringA
1039 : DebugBreak
1040 : GetCurrentThreadId
1041 : XDebugError
1042 : XDebugWarning
1043 : RtlDebugSetLevel
1044 : CloseHandle
1045 : GetTickCount
1046 : GetLastError
1047 : SetFilePointer
1048 : SetFilePointerEx
1049 : SetLastError
1050 : MultiByteToWideChar
1051 : WideCharToMultiByte
1052 : ReadFile
1053 : FlushFileBuffers
1054 : WriteFile
1055 : OutputDebugStringW
1056 : SetEvent
1057 : XapiFormatTimeOut
1058 : CreateMutexA
1059 : OpenMutexA
1060 : ReleaseMutex
1061 : WaitForSingleObject
1062 : WaitForSingleObjectEx
1063 : GetFileSize
1064 : GetFileSizeEx
1065 : XapiDirectoryInformationToFindData
1066 : XapiFormatObjectAttributes
1067 : ResetEvent
1068 : wsprintfA
1069 : wsprintfW
1070 : GetOverlappedResult
1071 : QueryPerformanceCounter
1072 : QueryPerformanceFrequency
1073 : LocalAlloc
1074 : LocalFree
1075 : RaiseException
1076 : RtlUniform
1077 : RtlRandom
1078 : Sleep
1079 : SleepEx
1080 : XMemSet
1081 : XRegisterThreadNotifyRoutine
1082 : XGetOverlappedExtendedError
1083 : XGetOverlappedResult
1084 : CreateThread
1085 : ResumeThread
1086 : ExitThread
1087 : GetTimeZoneInformation
1088 : GetSystemTimeAsFileTime
1089 : SystemTimeToFileTime
1090 : FileTimeToSystemTime
1091 : GetSystemTime
1092 : GetLocalTime
1093 : CreateDirectoryA
1094 : CreateEventA
1095 : CreateFileA
1096 : DeleteFileA
1097 : FindFirstFileA
1098 : FindNextFileA
1099 : GetFileAttributesA
1100 : XamLoaderGetCurrentTitleD3DVersion
1101 : GetFileAttributesExA
1102 : GetModuleHandleA
1103 : GetDiskFreeSpaceExA
1104 : CopyFileA
1105 : SetEndOfFile
1106 : XamFamilyAddParentalExemptionToList
1107 : XamFamilyIsParentalValidationRequired
1108 : _Refresh_CGamerCardWorker__MAAJXZ
1109 : _Refresh_CGamerCardWorker__MAAJXZ
1110 : PIXAddCounter
1111 : _Refresh_CGamerCardWorker__MAAJXZ
1112 : SetWaitableTimer
1113 : CancelWaitableTimer
1114 : CreateWaitableTimerA
1115 : DuplicateHandle
1116 : XapipCreateThread
1117 : lstrcpyA
1118 : lstrcpyW
1119 : lstrcpynA
1120 : lstrcpynW
1121 : lstrcatA
1122 : lstrcatW
1123 : lstrlenA
1124 : lstrlenW
1125 : IsBadReadPtr
1126 : IsBadWritePtr
1127 : FileTimeToLocalFileTime
1128 : XMemCpy
1129 : XMemCpyStreaming
1130 : XamHudSetUserIndex
1131 : XamShowNuiTroubleshooterUI
1132 : XamTestShowNuiTroubleshooterUI
1133 : XamShowPasscodeVerifyUIEx
1134 : XamShowNuiAchievementsUI
1135 : XamShowNuiCommunitySessionsUI
1136 : XamShowNuiDeviceSelectorUI
1137 : XamShowNuiDirtyDiscErrorUI
1138 : XamShowNuiFriendsUI
1139 : XamShowNuiGameInviteUI
1140 : XamShowNuiGamerCardUIForXUID
1141 : XamShowNuiMarketplaceDownloadItemsUI
1142 : XamShowNuiMarketplaceUI
1143 : XamShowNuiMessageBoxUI
1144 : XamShowNuiPartyUI
1145 : XamShowNuiFriendRequestUI
1146 : XamShowNuiSigninUI
1147 : XamShowNuiControllerRequiredUI
1148 : XamShowNuiGamesUI
1149 : XamShowNuiHardwareRequiredUI
1150 : XamCacheStoreFileByString
1151 : XamCacheFetchFileByString
1152 : XamCacheDeleteFileByString
1153 : XamGetCachedTitleNameEx
1154 : XamXlfsInitializeUploadQueue
1155 : XamXlfsUninitializeUploadQueue
1156 : XamXlfsMountUploadQueueInstance
1157 : XamXlfsUnmountUploadQueueInstance
1158 : _XamVoiceRecordUserPrivileges__YAXK_Z
1159 : XamXlfsInitializeUploadQueueWithTestHooks
1160 : XamXlfsNotifyContentDeletion
1161 : XMemAlloc
1162 : XMemFree
1163 : XMemSize
1164 : XamVoiceSetMicArrayIdleUsers
1165 : XamVoiceMuteMicArray
1166 : XamVoiceGetMicArrayUnderrunStatus
1167 : XuiSceneEnableTransitionDependency
1168 : XamVoiceGetMicArrayAudioEx
1169 : XamShowLeaveFamilyUI
1170 : XamUserGetDeviceId
1171 : XamUpdateEtxLogUpdateTaskStart
1172 : XamUpdateEtxLogUpdateTaskSuccess
1173 : XamUpdateEtxLogUpdateTaskFailure
1174 : _XamEtxFlushLogs__YAXH_Z
1175 : XamVoiceIsActiveProcess
1176 : XamInactivityGetInactivityInterruptTime
1177 : XamInactivitySetInactivityInterruptTime
1178 : XamInactivityGetLastActivityTime
1179 : XamInactivitySetDetectionTaskPeriod
1180 : XamInactivityEnablePowerDown
1181 : XamUpdateGetChainMarker
1182 : XGetVideoCapabilities
1183 : XMsgProcessRequest
1184 : XGetDisplaySize
1185 : XamInputNonControllerGetRaw
1186 : XamInputNonControllerSetRaw
1187 : _XamVoiceSetMicArrayBeamAngle__YAJM_Z
1188 : XamUserGetAge
1189 : XamUserGetAgeGroup
1190 : XamVoiceGetMicArrayFilenameDesc
1191 : XamLoaderGetState
1192 : XamTaskQueryProperty
1193 : XamGetLocale
1194 : XamQueryTimeZoneInformation
1195 : XamSetTimeZoneInformation
1196 : XamLaunchURI
1199 : XamShowNuiMessagesUI
1200 : XMPRegisterCodec
1201 : XamNavigateBack
1202 : XamPushBackURI
1203 : _XamUserOverrideDeviceBindings__YAXPAU_XAM_USER_DEVICE_BINDING__K_Z
1204 : _XamUserOverrideBindingCallbacks__YAXPAP6AXPAU_XAM_USER_DEVICE_BINDING__K_ZK_Z
1205 : _XamUserOverrideUserInfo__YAXPAUUSERINFO__K_Z
1206 : XamUserContentRestrictionGetFlags
1207 : XamUserContentRestrictionGetRating
1208 : XamUserContentRestrictionCheckAccess
1209 : XamShowFitnessBodyProfileUI
1210 : XamFitnessAddBodyProfileRecord
1211 : XamFamilyGetMembers
1212 : XampXAuthStartup
1213 : XampXAuthShutdown
1214 : XamGetToken
1215 : XamFreeToken
1216 : XamGetAppliesTo
1217 : XamFitnessClearBodyProfileRecords
1218 : XamFitnessGetCurrentBodyProfileRecord
1219 : XamFitnessGetAllBodyProfileRecords
1220 : XamFitnessGetAllTitleSummaries
1221 : XamFitnessGetOverallSummary
1222 : XamFitnessAddFitnessEvent
1223 : XamLrcGetInput
1224 : XamLrcGetInputWithSeek
1225 : XamLrcSetMediaState
1226 : XamPixSetDirtyCounters
1227 : XamFitnessCreateFitnessEventEnumerator
1228 : XamFitnessInitialize
1229 : XamRequestToken
1230 : XamResolveURI
1231 : XamContentGetOnlineCreator
1232 : XamShowBrandedKeyboardUI
1233 : XamBackgroundDownloadNetworkStorageEnable
1234 : XamBackgroundDownloadNetworkStorageIsEnabled
1235 : XamShowNuiJoinSessionInProgressUI
1236 : XamBase64Decode
1237 : XamCertDecode
1238 : XamCertDecodeRsaPublicKey
1239 : XamCertValidateStruct
1240 : XamFitnessConvertByteMetToFloatMet
1241 : XamXgiBlobTrackerSetMockInfo
1242 : XamFitnessMsgTimeToSystemTime
1243 : XamFitnessSystemTimeToMsgTime
1244 : XamShowFitnessWarnAboutPrivacyUI
1245 : XamShowFitnessWarnAboutTimeUI
1246 : XamFitnessUnInitialize
1247 : XamBackgroundDownloadNetworkStorageOnContentChange
1248 : XamLiveBaseConfigureInMemoryMockResponse
1249 : InjectConnectionServerNotification
1250 : XamFitnessConvertFloatMetToByteMet
1251 : XamGetGamerTileKeyFromGamertag
1252 : XamBackgroundDownloadNetworkStorageRegisterChangeCallback
1253 : _XamFindOrCreateInternalPassportAccount__YAJEU_FILETIME__PA_WPAU_PASSPORT_SESSION_TOKEN___Z
1254 : XOnlinepFriendsRequest
1255 : XOnlinepFriendsAcceptRequest
1256 : XOnlinepFriendsRejectRequest
1257 : XOnlinepFriendsRemove
1258 : XFriendsCreateEnumerator
1259 : XamBackgroundDownloadNetworkStorageIsRunning
1260 : XamCertGetSerialNumber
1261 : XamShowOptionsUI
1262 : XampXAuthGetTitleBuffer
1263 : XamGetSTSTokenCache
1264 : XamUserGetOnlineXUIDFromOfflineXUID
1265 : XamIsConsoleUsingMetricSystem
1266 : XamShowNuiVideoRichPresenceUI
1267 : XamAppAllocateInterappWorkspaceEx
1268 : XamFitnessClearFitnessEvents
1269 : XamNetworkStatusGetInformation
1270 : XamNetworkStatusAddAddress
1300 : XamIsCurrentTitleIptv
1301 : XamIsIptvEnabled
1302 : XamIsDvrRecording
1303 : XamIptvUninstall
1304 : XamGetDvrStorage
1305 : XamSetDvrStorage
1306 : XamIptvGetServiceName
1307 : XamNuiHudGetEngagedEnrollmentIndex
1400 : XamReminderGetItems
1401 : XamReminderClearItems
1402 : XamReminderItemAdd
1403 : XamReminderItemRemove
1404 : XamReminderGetNextItem
1405 : XamReminderGetModifiedTime
1406 : XamReminderClearCache
1500 : XamAvatarInitialize
1501 : XamAvatarShutdown
1502 : XamAvatarGetMetadataLocalUser
1503 : XamAvatarGetMetadataByXuid
1504 : XamAvatarGetAssetsResultSize
1505 : XamAvatarGetAssets
1506 : XamAvatarGenerateMipMaps
1507 : XamAvatarSetCustomAsset
1508 : XamAvatarSetMetadata
1509 : _EnumerateMediaObjects_CFsMediaSource__QAAJPADPAUFsEnumContext__PAUMSAL_MEDIAOBJECTINFO__KPAK_Z
1510 : _EnumerateMediaObjects_CFsMediaSource__QAAJPADPAUFsEnumContext__PAUMSAL_MEDIAOBJECTINFO__KPAK_Z
1511 : XamAvatarLoadAnimation
1512 : XamAvatarBeginEnumAssets
1513 : XamAvatarEndEnumAssets
1514 : XamAvatarEnumAssets
1515 : XamAvatarGetMetadataRandom
1516 : _EnumerateMediaObjects_CFsMediaSource__QAAJPADPAUFsEnumContext__PAUMSAL_MEDIAOBJECTINFO__KPAK_Z
1517 : _EnumerateMediaObjects_CFsMediaSource__QAAJPADPAUFsEnumContext__PAUMSAL_MEDIAOBJECTINFO__KPAK_Z
1518 : XamAvatarGetMetadataSignedOutProfileCount
1519 : XamAvatarGetMetadataSignedOutProfile
1520 : _EnumerateMediaObjects_CFsMediaSource__QAAJPADPAUFsEnumContext__PAUMSAL_MEDIAOBJECTINFO__KPAK_Z
1521 : XamAvatarMetadataGetBodyType
1522 : XamAvatarGetInstrumentation
1523 : XamAvatarGetAssetIcon
1524 : XamAvatarWearNow
1525 : XamAvatarGetAssetBinary
1526 : XamLoaderGetSuspendedTitleInfo
1527 : XamAvatarGetInstalledAssetPackageDescription
1528 : XamAvatarSetAdapters
1550 : XamContentMountInstalledGame
1551 : XamContentIsGameInstalledToHDD
1552 : XamContentQueryLicenseInternal
1553 : XamContentGetDeviceVolumePath
1554 : XamContentDeviceCheckUpdates
1555 : XamContentGetHeaderInternal
1556 : XamNetworkStorageGetNetworkDevice
1557 : XamNetworkStorageDeviceHasCacheFile
1558 : XamNetworkStorageCreateCacheOnDevice
1559 : XamNetworkStorageDeleteCacheOnDevice
1560 : XamNetworkStorageGetStatus
1561 : XamNetworkStorageIsSupportedContentType
1562 : XamNetworkStorageSetTestMock
1563 : XamNetworkStorageGetLastSyncTime
1564 : XamShowNetworkStorageSyncUI
1565 : XamUserIsLogonPreviewModeEnabled
1566 : XamUserLockLogonPreviewMode
1567 : XamUserUnlockLogonPreviewMode
1568 : XamNetworkStorageIsUserInSync
1569 : XamNetworkStorageSetUserInSync
1570 : XamNetworkStorageOnSigninChanged
1571 : XamNetworkStorageSignInTestMock
1572 : XamShowFofUI
1573 : CompareFileTime
1574 : SetFileTime
1575 : XamNetworkStorageGetTitleProperties
1576 : XamNetworkStorageLockFile
1577 : XamNetworkStorageUserHasPrivilege
1578 : XamNetworkStorageIsTitleExempt
1579 : XamContentExistsOnDeviceInternal
1580 : XamNetworkStorageGetBackingDevice
1581 : XamNetworkStorageIsEnabledInLiveHive
1582 : XamNetworkStorageIsCheckingSyncStates
1583 : XamNetworkStorageUserNeedsToSync
1584 : XamNetworkStorageGetUserNetworkSyncTime
1585 : XamNetworkStorageGetUserProperties
1586 : XamNetworkStorageAppLauncherLaunchIfRunning
1587 : XamNetworkStorageSetTitleProperties
1588 : XamNetworkStorageGetUserLastError
1589 : XamNetworkStorageCheckOutTitle
1590 : XamNetworkStorageShouldHideFromTitle
1600 : XamPackageManagerFindPackageContainingIndexedXEX
1601 : XamPackageManagerReinitialize
1602 : XamPackageManagerGetAuthoritativeManifestRevision
1603 : XamGetCurrentSystemOnlineManifestRevision
1604 : XamPackageManagerDeleteExtendedPartition
1605 : XamPackageManagerHasExtendedPartition
1606 : XamPackageManagerGetExperienceMode
1607 : XamPackageManagerGetFeatureRequiresUpdateStrings
1608 : XamPackageManagerGetFileSize
1609 : XampDemandUpdateGetAttributes
1610 : XampDemandUpdateGetExtendedAttributes
1611 : XampDemandUpdateGetInstance
1612 : XampDemandUpdateSetRefreshTestFlags
1613 : XampDemandUpdateIsRefreshTestFlagSet
1614 : XampDemandUpdateGetManifestLocalPath
1615 : XampDemandUpdateRefreshManifest
1616 : XdfInitialize
1617 : XdfShutdown
1618 : XdfGetExpectedDownloadSize
1619 : XdfGetItem
1620 : XdfCacheItem
1621 : XdfLoadXexFromCache
1622 : XdfLoadXex
1623 : XdfCancelRequest
1624 : XdfResumeDelayedItem
1625 : XdfLaunchNewImageFromCache
1626 : XampDemandUpdateRefreshManifestDuringLogon
1627 : XampDemandUpdateCheckOnlineManifestChanged
1628 : XampDemandUpdateRunCacheCleaner
1670 : XamXStudioRequest
1671 : XamNotifyDelayUIInternal
1700 : XamShowAvatarMiniCreatorUI
1701 : XamShowGoldUpgradeUI
1702 : XamResumeUpdaterUI
1703 : XamShowDirectAcquireUI
1704 : XamShowPaymentOptionsUI
1800 : XamGetLiveHiveValueA
1801 : XamGetLiveHiveValueW
1802 : XamGetLiveHiveValueDuringLogonAttemptA
1803 : XamSetUserPresetWindowsLiveCreds
1902 : XamSetStagingMode
1903 : XamGetStagingMode
1904 : XamAppGetSessionId
1905 : XamAccountRecoveryRecoverAllProfileData
2000 : XamDoesOmniNeedConfiguration
2002 : GetProcessHeap
2003 : UnhandledExceptionFilter
2004 : SetUnhandledExceptionFilter
2005 : XamIsOptionalMediaUpdateInstalled
2006 : XamShowOptionalMediaUpdateRequiredUI
2007 : XamShowOptionalMediaUpdateRequiredUIEx
2009 : XamTaskCreateQueueEx
2010 : _XamSetTextureLoaderHook__YAP6AJPAUIXuiDevice__PB_WPAUXUIImageInfo__PAPAUD3DTexture___ZP6AJ0123_Z_Z
2011 : XamLaunchAvatarEditor
2012 : XamLoadExtraAVCodecs
2013 : XamUnloadExtraAVCodecs
2014 : _XamSetLastActiveUserData__YAHPAU_LASTACTIVEUSER_DATA___Z
2015 : _XamGetLastActiveUserData__YAHPAU_LASTACTIVEUSER_DATA___Z
2016 : XamSetActiveDashAppInfo
2017 : XamGetActiveDashAppInfo
2050 : XamUserCreateAvatarAssetEnumerator
2051 : XamInitializeGameTileCache
2052 : XamDestroyGameTileCache
2053 : _XamReadGameTileImage__YAJPAXW4XTILETYPE__KK_KPAPAU_XUIBRUSH___Z
2054 : _XamShouldThrottleAccountInfoCall__YAHXZ
2055 : XuiClassDerivesFrom
2056 : XuiFreeVisuals
2057 : XuiGetBaseClass
2058 : XuiLoadVisualFromBinary
2059 : XuiResourceGetBuffer
2060 : XuiResourceGetTotalSize
2061 : XuiElementGetUserData
2062 : XuiElementSetUserData
2063 : XuiTabSceneGetCount
2064 : XuiSliderGetStep
2065 : XuiSliderSetStep
2066 : XuiProgressBarGetRange
2067 : XuiElementSetHittable
2068 : XuiElementPlayNamedFrames
2069 : XuiElementGetPivot
2070 : XuiElementGetPrev
2071 : XuiElementGetScale
2072 : XuiElementSetPivot
2073 : XuiElementSetRotation
2074 : XuiElementSetScale
2075 : XuiControlWantsUnfocusedInput
2076 : XuiResourceOpenNoLoc
2077 : XuiResourceReleasePackage
2078 : XuiResourceGetPackageEntryInfo
2079 : XuiResourceGetPackageEntryCount
2080 : XuiResourceOpenPackage
2081 : XamCodeCoverageFileOpen
2082 : XamCodeCoverageFileClose
2083 : XamCodeCoverageFileLseek
2084 : XamCodeCoverageFileRead
2085 : XamCodeCoverageFileWrite
2086 : _Refresh_CGamerCardWorker__MAAJXZ
2087 : XampHeapGetInfo
2088 : XampHeapGetCount
2089 : XamShowPamUI
2090 : XuiElementLayoutTree
2091 : XamInactivityResetAllState
2092 : XUIElementPropVal_SetInt
2093 : XUIElementPropVal_SetFloat
2094 : XuiObjectGetPropertyDef
2095 : XuiRenderGetDevice
2096 : XuiRenderRestoreState
2097 : XuiElementGetFullXForm
2098 : XuiRenderGetViewTransform
2099 : XuiRenderGetColorSpace
2100 : XamPngEncode
2101 : XamPngDecode
2102 : XamPngEncodeEx
2103 : XuiTextElementMeasureText
2104 : XamLoaderShouldConfirmReboot
2105 : XamLoaderRebootToDash
2106 : XamNuiHudGetEngagedTrackingID
2107 : XamLoaderLaunchTitleForReason
2108 : XamNuiHudSetEngagedTrackingID
2109 : XuiBrushGetTexture
2110 : XuiBrushGetDims
2111 : XuiElementGetDescendantById
2120 : XamAccountRecoveryGetSetTitleSyncTime
2121 : XamReadBiometricData
2122 : XamWriteBiometricData
2123 : XamD3DResourceDescriptorCreate
2124 : XamD3DResourceDescriptorAddRef
2125 : XamD3DResourceDescriptorRelease
2126 : XamD3DResourceAddRef
2127 : XamD3DResourceSet
2128 : XamD3DResourceIsBusy
2129 : XamD3DResourceRelease
2130 : ControlPackGetCursorPosition
2131 : ControlPackShouldShowCursor
2136 : XamFlushAgraTemperatureReport
2137 : _XamNatalDeviceAudioCalibrate__YAJXZ
2138 : XamNuiIdentityGetEnrollmentInfo
2139 : XamNuiIdentityUnenroll
2140 : XamNuiIdentityGetColorTexture
2141 : XamReportKinectSettingsChangedEvent
2142 : XamNuiEnableChatMic
2143 : XamNuiIsChatMicEnabled
2144 : XamNuiGetDepthCalibration
2145 : XamNuiStoreDepthCalibration
2146 : XamUserNuiIsBiometricEnabled
2147 : XamUserNuiEnableBiometric
2148 : XamNuiCameraSetFlags
2149 : XamNuiCameraRememberFloor
2150 : XamUserNuiGetUserIndexForBind
2151 : XamUserNuiGetUserIndexForSignin
2152 : XamUserNuiBind
2153 : XamUserNuiGetUserIndex
2154 : XamUserNuiGetEnrollmentIndex
2155 : XamUserNuiUnbind
2156 : XamNuiUseTemporaryDepthCalibration
2157 : XamNuiCameraTiltSetCallback
2158 : XamNuiHudIsEnabled
2159 : XamNuiCameraGetTiltControllerType
2160 : XamNuiCameraTiltGetStatus
2161 : XamNuiIdentityGetQualityFlags
2162 : XamNuiIdentityEnrollForSignIn
2163 : XamNuiIdentityGetSessionId
2164 : XamNuiIdentityIdentifyWithBiometric
2165 : ControlPackGetHandleManager
2166 : XamEnableNuiAutomation
2167 : XamNuiGetSystemGestureControl
2168 : XamGetPasscodeKeyFromVirtualKey
2169 : XamEnableNatalPlayback
2170 : XamIsNuiAutomationEnabled
2171 : XamIsNatalPlaybackEnabled
2172 : XamNuiHudInterpretFrame
2173 : XamNuiHudEnableInputFilter
2174 : XamUserNuiIsBiometricAugmentRecommended
2175 : XamNuiHudGetInitializeFlags
2176 : XamNuiCameraElevationSetAngle
2177 : XamNuiCameraElevationGetAngle
2178 : XamNuiCameraElevationAutoTilt
2179 : XamNuiCameraElevationStopMovement
2180 : XamNuiCameraElevationSetCallback
2181 : XamNuiGetDeviceStatus
2182 : XamNuiNatalCameraUpdateStarting
2183 : XamNuiNatalCameraUpdateComplete
2184 : XamNuiHudGetVersions
2185 : XamGetHUDElementByPath
2186 : XamGetHUDElementByAutoId
2187 : XuiElementGetScreenPositionCenter
2188 : XamNuiCameraElevationReverseAutoTilt
2189 : ControlPackSimpleCursorGetRayFromScreenPosition
2190 : ControlPackSideNavControlGetNuiHandle
2191 : _XamFindHUDElementByXuiId__YAJPB_WPAPAU_XUIOBJ___Z
2192 : XamNuiIsDeviceReady
2193 : XamNuiSetForceDeviceOff
2194 : XamNuiPlayerEngagementUpdate
2195 : XamNuiSkeletonGetBestSkeletonIndex
2196 : XamNuiSkeletonScoreUpdate
2197 : XamNuiCameraTiltReportStatus
2198 : XamNuiCameraAdjustTilt
2199 : XamNuiIdentityAbort
2200 : D3DDevice_CreateVertexShader
2201 : D3DDevice_CreatePixelShader
2202 : D3DDevice_CreateTexture
2203 : D3DDevice_CreateVertexBuffer
2204 : D3DDevice_CreateIndexBuffer
2205 : D3DDevice_CreateVertexDeclaration
2206 : D3DVertexBuffer_Unlock
2207 : D3DVertexBuffer_Lock
2208 : D3DIndexBuffer_Unlock
2209 : D3DIndexBuffer_Lock
2210 : D3DTexture_UnlockRect
2211 : D3DTexture_LockRect
2212 : D3DDevice_Clear
2213 : D3DDevice_SetViewport
2214 : D3DDevice_GetViewport
2215 : D3DDevice_SetRenderState_SrcBlend
2216 : D3DDevice_SetRenderState_DestBlend
2218 : D3DResource_Release
2219 : D3DDevice_Release
2220 : D3DDevice_SetVertexShader
2221 : D3DDevice_SetPixelShader
2222 : D3DDevice_SetTexture
2223 : D3DDevice_SetVertexDeclaration
2224 : D3DDevice_SetIndices
2225 : D3DDevice_SetStreamSource
2226 : D3DDevice_DrawVertices
2227 : D3DDevice_DrawVerticesUP
2228 : D3DDevice_DrawIndexedVertices
2229 : D3DDevice_DrawIndexedVerticesUP
2230 : D3DDevice_SetVertexShaderConstantF_ParameterCheck
2231 : D3DDevice_SetPixelShaderConstantF_ParameterCheck
2232 : D3DDevice_SetSamplerState_ParameterCheck
2233 : D3DDevice_SetRenderState_ParameterCheck
2234 : D3DDevice_GetRenderState_ParameterCheck
2235 : D3DDevice_SetVertexShaderConstantFN
2236 : D3DDevice_SetPixelShaderConstantFN
2237 : D3DDevice_GetRenderState_ZEnable
2238 : D3DDevice_GetRenderState_CullMode
2239 : D3DDevice_GetRenderState_AlphaBlendEnable
2240 : D3DDevice_GetRenderState_SrcBlendAlpha
2241 : D3DDevice_GetRenderState_DestBlendAlpha
2242 : D3DDevice_GetRenderState_BlendOp
2243 : D3DDevice_GetRenderState_ViewportEnable
2244 : D3DDevice_SetRenderState_ZEnable
2245 : D3DDevice_SetRenderState_CullMode
2246 : D3DDevice_SetRenderState_AlphaBlendEnable
2247 : D3DDevice_SetRenderState_SrcBlendAlpha
2248 : D3DDevice_SetRenderState_DestBlendAlpha
2249 : D3DDevice_SetRenderState_BlendOp
2250 : D3DDevice_SetRenderState_ViewportEnable
2251 : D3DDevice_SetSamplerState_MagFilter
2252 : D3DDevice_SetSamplerState_MinFilter
2253 : D3DDevice_SetSamplerState_AddressU
2254 : D3DDevice_SetSamplerState_AddressV
2255 : XGSetTextureHeader
2256 : XGGetTextureDesc
2257 : XGOffsetResourceAddress
2258 : D3DResource_AddRef
2262 : XGSetTextureHeaderEx
2263 : D3DDevice_GetRenderTarget
2264 : D3DDevice_SetRenderTarget
2265 : D3DDevice_GetDepthStencilSurface
2266 : D3DDevice_SetDepthStencilSurface
2267 : D3DDevice_Resolve
2268 : D3DDevice_SetPixelShaderConstantB
2269 : XamNuiGetDeviceSerialNumber
2270 : XamNuiGetLoadedDepthCalibration
2271 : XamNuiGetTrueColorInfo
2272 : XamNuiGetCameraIntrinsics
2273 : XamNuiGetFanRate
2274 : XamNuiGetSupportString
2275 : XamKinectGetHardwareType
2300 : XamXtwManagerGetVariableCount
2301 : XamXtwManagerGetId
2302 : XamXtwManagerGetValue
2303 : XamXtwManagerSetValue
2304 : XamXtwManagerIncrement
2305 : XamXtwManagerDecrement
2306 : XamXtwManagerResetValue
2307 : XamXtwManagerResetAll
2308 : XamXtwManagerGetDataFilePath
2309 : XamXtwManagerDeleteDataFile
2310 : XamXtwManagerSave
2311 : XamXtwManagerLoad
2312 : XamGetXTweakManager
2491 : XamMediaVerificationCreate
2492 : XamMediaVerificationClose
2493 : XamMediaVerificationVerify
2494 : XamMediaVerificationFailedBlocks
2495 : XamMediaVerificationInject
2496 : XamShowBadDiscErrorUI
2500 : XamBackgroundDownloadSetMode
2501 : XamBackgroundDownloadIsEnabled
2502 : XamBackgroundDownloadGetActiveItem
2503 : XamBackgroundDownloadGetItems
2504 : XamBackgroundDownloadClearItems
2505 : XamBackgroundDownloadItemAdd
2506 : XamBackgroundDownloadItemRemove
2507 : XamBackgroundDownloadItemMakeFirst
2508 : XamBackgroundDownloadSetForegroundPriority
2509 : XamBackgroundDownloadGetForegroundPriority
2510 : XamBackgroundDownloadItemToContentData
2511 : XamBackgroundDownloadItemGetStatus
2512 : XamBackgroundDownloadHistoryGetItem
2513 : XamBackgroundDownloadItemGetHistoryStatus
2514 : XamBackgroundDownloadItemSetHistoryStatus
2515 : XamBackgroundDownloadItemGetStatusAsync
2516 : XamBackgroundDownloadItemGetStatusEx
2517 : XamBackgroundDownloadItemGetHistoryStatusEx
2518 : XamBackgroundDownloadBindItems
2519 : XamBackgroundDownloadSetPollingActive
2520 : XamBackgroundDownloadGetPollingActive
2521 : XamBackgroundDownloadGetMode
2522 : XamBackgroundDownloadGetUnexpectedChangeCount
2523 : XamBackgroundDownloadIsItemForThisConsole
2524 : XamBackgroundDownloadSelectDevice
2525 : XamBackgroundDownloadItemModify
2526 : XamBackgroundDownloadCacheLegacyMappingInfo
2527 : XamBackgroundDownloadGetLegacyMappingInfo
2528 : XamBackgroundDownloadGetLegacyId
2529 : XamBackgroundDownloadDoFail
2600 : XamSwapDisc
2601 : XamSwapDiscPatchAddress
2602 : XamSwapCancel
2610 : XamRamDriveCreate
2611 : XamRamDriveDestroy
2650 : XamPlayTimerGetData
2651 : XamPlayTimerSetData
2652 : XamPlayTimerResume
2653 : XamPlayTimerSuspend
2654 : XamPlayTimerIsRunning
2655 : XamPlayTimerIsEnabled
2656 : XamPlayTimerGetNextResetDate
2657 : XamPlayTimerFormatDurationString
2658 : XamPlayTimerGetTimeRemaining
2659 : XamPlayTimerUpdateTimeRemaining
2660 : XamPlayTimerForceNotification
2661 : XamPlayTimerRefreshResetDate
2670 : UpnpAVServerSearchInitialize
2671 : UpnpAVServerSearchDestroy
2672 : UpnpAVServerSearchStart
2673 : _Destroy_CUpnpAVServerSearch__QAAXXZ
2674 : UpnpAVServerSearchDoWork
2675 : UpnpAVServerSearchGetNextServer
2700 : XCustomBroadcastGamercardEvent
2701 : XamCustomGetCurrentActions
2720 : XamInstrumentationLogEvent
2721 : XamRegisterSMCNotification
2730 : XamInstrumentationLogEventEx
2731 : XamInstrumentationGetSourceConfig
2732 : XamInstrumentationDebugConfig
2780 : CurlCreateCacheEntry
2781 : CurlOpenCacheEntry
2782 : CurlSetCacheEntryExpireTime
2783 : CurlReadCacheEntryHeaders
2784 : CurlReadCacheEntryContent
2785 : CurlWriteCacheEntryContent
2786 : CurlCloseCacheEntry
2787 : CurlEnumerateCacheEntry
2789 : CurlWipeBackingFiles
2791 : CurlOpenTitleBackingFile
2800 : XamSetSecurityViolationDetected
2801 : XamIsSecurityViolationDetected
2802 : XamIsAnySecurityViolationDetected
2803 : XamGetSecurityViolationsDetected
2804 : XamActivateCounterMeasure
2805 : XamDeactivateCounterMeasure
2806 : XamIsCounterMeasureActivated
2807 : XamGetActiveCounterMeasures
2808 : XamPmdIdentify
2809 : XamPmdSendCommand
2810 : XamPmdReadReport
2812 : XamPartyCreate
2813 : XamPartyLeave
2814 : _XamPartySendInviteDeprecated__YAKKPB_KIPB_W_Z
2815 : XamPartyGetUserList
2816 : XamPartySendGameInvites
2817 : XamPartyJoin
2818 : XamPartyKickUser
2819 : XamPartyAddLocalUsers
2820 : XamConvertEmoticons
2821 : XamGetLocaleTimeFormat
2822 : XamPartyRemoveLocalUsers
2823 : XamPartyGetUserListInternal
2824 : XamPartySetJoinable
2825 : XamPartyGetJoinable
2826 : XamPartyGetInfo
2827 : XamPartySetCustomData
2828 : XamPartySetConnectivityGraph
2829 : XamPartyGetRoutingTable
2830 : XamPartyAutomationInprocCall
2831 : XamPartyGetState
2832 : XamPartyGetBandwidth
2833 : XamPartyGetNetworkCounters
2834 : XamShowQuickLaunchUI
2835 : XamPartyIsCoordinator
2836 : XamPartyGetFormation
2837 : XamPartySendInvite
2838 : XamPartySetTestDelay
2839 : XamPartyOverrideNatType
2840 : XamPartyGetAccessLevel
2841 : XamPartySetTestFlags
2842 : XamIsSystemExperienceTitleId
2850 : XamTaskSetCancelSubTasks
2851 : XamTaskGetCompletionStatus
2852 : XamTaskCancelWaitAndCloseWaitTask
2860 : XamWebInstrumentationCreateReport
2861 : XamWebInstrumentationSetUserVar
2862 : XamWebInstrumentationSetUserVarNoEscape
2863 : XamWebInstrumentationGetURL
2864 : XamWebInstrumentationSendReport
2865 : XamWebInstrumentationDestroyReport
2866 : XamWebInstrumentationCreateSampledReport
2867 : XampSetSamplingRandomValue
2868 : XampWebInstrumentationSetProfileCounts
2869 : XamWebInstrumentationGetURLEx
2870 : XampSetOmnitureCallbackFunction
2871 : XamShowQuickChatUIp
2872 : XamShowSocialPostUI
2873 : XamShowBeaconsUI
2874 : XamShowMarketplacePurchaseOrderUI
2875 : XamShowMarketplaceGetOrderReceipts
2876 : XamShowGenericOnlineAppUI
2877 : XamUserAllowedToPostToSocialNetwork
2890 : XamVerifyXSignerSignature

```

`docs/kernel/ordinals/xbdm.ord`:

```ord
0 : xbdm.dll
1 : DmAllocatePool
2 : DmAllocatePoolWithTag
3 : DmCloseCounters
4 : DmCloseModuleSections
5 : DmCloseModuleSections
6 : DmCloseNotificationSession
7 : DmClosePerformanceCounter
8 : DmContinueThread
9 : DmFreePool
10 : DmGetMemory
11 : DmGetModuleLongName
12 : DmGetProcAddress
13 : DmGetThreadContext
15 : DmGetThreadList
16 : DmGetXbeInfo
17 : DmGetXboxName
19 : DmGo
20 : DmHaltThread
21 : DmIsDebuggerPresent
22 : DmIsThreadStopped
24 : DmNotify
25 : DmOpenNotificationSession
26 : DmOpenPerformanceCounter
27 : DmQueryPerformanceCounterHandle
28 : DmReboot
30 : DmRegisterCommandProcessor
32 : DmRegisterNotificationProcessor
33 : DmRegisterPerformanceCounter
34 : DmRemoveBreakpoint
35 : DmResumeThread
36 : DmSendNotificationString
37 : DmSetBreakpoint
38 : DmSetDataBreakpoint
39 : DmSetInitialBreakpoint
40 : DmSetMemory
41 : DmSetThreadContext
42 : DmSetTitle
43 : DmSetXboxName
45 : DmStop
46 : DmStopOn
48 : DmSuspendThread
49 : DmThreadUserData
51 : DmWalkLoadedModules
52 : DmWalkModuleSections
53 : DmWalkPerformanceCounters
55 : DmCloseCounters
56 : DmIsBreakpoint
57 : DmCloseCounters
58 : DmSetUserAccess
59 : DmGetUserAccess
60 : DmWalkUserList
61 : DmAddUser
62 : DmEnableSecurity
63 : DmIsSecurityEnabled
64 : DmRemoveUser
65 : __CAP_Start_Profiling
66 : __CAP_End_Profiling
70 : __CAP_Enter_Function
71 : __CAP_Exit_Function
72 : DmRegisterCommandProcessorEx
73 : DmStartProfiling
74 : DmStopProfiling
75 : DmQueryMemoryStatistics
76 : DmEnableStackTrace
77 : DmQueryAllocationTypeName
78 : DmRegisterAllocationType
79 : DmInsertAllocationEntry
80 : DmRemoveAllocationEntry
81 : DmSetTitleEx
82 : DmCaptureStackBackTrace
83 : DmCrashDump
84 : DmIsFastCAPEnabled
85 : DmGetFileAccessCount
88 : DmGetUtilityDriveInfo
89 : DmGetThreadInfoEx
90 : DmSetProfilingOptions
91 : DmQuerySystemSettings
92 : DmSaveSystemSettings
106 : DmpGetPgoModuleHandleForBaseAddress
107 : DmpOnPgoModuleLoad
108 : DmPgoStartDataCollection
109 : DmPgoStopDataCollection
110 : DmPgoSaveSnapshot
111 : IrtClientAbort
112 : IrtPogoInit
113 : IrtSetStaticInfo
114 : IrtAutoSweepW
115 : IrtAutoSweepA
117 : DmGetDumpMode
118 : DmSetDumpMode
119 : DmGetDumpSettings
120 : DmSetDumpSettings
121 : DmGetEventDeferFlags
122 : DmSetEventDeferFlags
123 : DmWalkCommittedMemory
124 : DmCloseCounters
125 : DmRebootEx
130 : DmMountFdfxVolume
131 : DmCapGetFileHeader
132 : DmCapFreeFileHeader
133 : DmTraceStartRecording
134 : DmTraceStartRecordingFunction
135 : DmTraceSetBufferSize
136 : DmTraceStopRecording
137 : DmTraceSaveBuffer
140 : DmGetConsoleType
141 : DmMapDevkitDrive
142 : DmWalkLoadedModulesEx
143 : DmGetXexHeaderField
144 : DmGetMouseChanges
145 : DmFindPdbSignature
146 : DmGetProfilingStatus
147 : DmOpticalDiscLogStart
148 : DmOpticalDiscLogStop
149 : DmStartSamplingProfiler
150 : DmStopSamplingProfiler
151 : DmGetSamplingProfilerInfo
152 : DmStartFileEventCapture
153 : DmStopFileEventCapture
154 : DmSetFileEventMarker
155 : DmMarkPseudoCreateBegin
156 : DmMarkPseudoCreateEnd
157 : DmMarkPseudoEventBegin
158 : DmMarkPseudoEventEnd
159 : DmMarkFileEventWorkerThreadBegin
160 : DmMarkFileEventWorkerThreadEnd
161 : DmGetSystemInfo
162 : DmAbortProfiling
163 : DmNetCaptureStart
164 : DmNetCaptureStop
165 : DmQueryTitleMemoryStatistics
166 : DmAutomationGetInputProcess
167 : DmAutomationBindController
168 : DmAutomationUnbindController
169 : DmAutomationConnectController
170 : DmAutomationDisconnectController
171 : DmAutomationSetGamepadState
172 : DmAutomationQueueGamepadState
173 : DmAutomationClearGamepadQueue
174 : DmAutomationQueryGamepadQueue
175 : DmAutomationGetUserDefaultProfile
176 : DmAutomationSetUserDefaultProfile
177 : DmTraceIsRecording
178 : DmLoadDebuggerExtension
179 : DmUnloadDebuggerExtension
180 : DmCreateSystemThread
181 : _PEPLELookup__YIPAUEPLE__PAUPGCHDR__PAUEPLH__K_Z
182 : _PEPLELookupCompact__YIXPAUPGCHDR__PAUEPLH__KPAUMDSProbeState___Z
183 : _PVPLELookup__YIXPAUPGCHDR__PAUVPLHStandard___K_Z
184 : _PVPLELookupCompact__YIXPAUPGCHDR__PAUVPLHCompact___K_Z
185 : _PVPLELookupCompactMDS__YIXPAUPGCHDR__PAUVPLHCompact___KPAUMDSProbeState___Z
186 : _PVPLEFilteredLookup__YIXPAUPGCHDR__PAUVPLHStandard___K_Z
187 : _PVPLEFilteredLookupCompact__YIXPAUPGCHDR__PAUVPLHCompact___K_Z
188 : _PVPLEFilteredLookupCompactMDS__YIXPAUPGCHDR__PAUVPLHCompact___KPAUMDSProbeState___Z
189 : _PVPLETemplatedLookup__YIXPAUPGCHDR__PAUVPLHStandard___KPAUtagPOGOVALUETEMPLATE___Z
190 : _PVPLETemplatedLookupCompact__YIXPAUPGCHDR__PAUVPLHCompact___KPAUtagPOGOVALUETEMPLATE___Z
191 : _PVPLETemplatedLookupCompactMDS__YIXPAUPGCHDR__PAUVPLHCompact___KPAUtagPOGOVALUETEMPLATE__PAUMDSProbeState___Z
192 : DmpPgoCounterOverflow
193 : _UpdateMDSProbeState__YA_NPAUMDSProbeState___Z
194 : DmGetHttpRegistration
195 : DmTraceSetIOThread
196 : DmPMCInstallAndStart
197 : DmPMCStopAndReport
198 : DmPMCInstallSetup
199 : DmPMCUnInstallSetup
200 : DmPMCResetCounters
201 : DmPMCSetTriggerProcessor
202 : DmPMCStart
203 : DmPMCStop
204 : DmPMCGetCounter
205 : DmPMCGetCounters
206 : DmPMCGetCounterName
207 : DmPMCDumpCounters
208 : DmPMCDumpCountersVerbose
209 : DmPMCGetCounterCostEstimate
210 : DmPMCGetCounterSource
211 : DmPMCComputeFrequency
212 : DmGetAdditionalTitleMemorySetting
213 : DmGetDebugMemorySize
214 : DmGetConsoleDebugMemoryStatus
215 : DmNetSimSetLinkStatusHidden
216 : DmNetSimInsertQueue
217 : DmNetSimRemoveQueue
218 : DmNetSimRemoveAllQueues
219 : DmNetSimModifyQueueSettings
220 : DmGetConsoleFeatures
221 : DmNetSimGetQueueStats
222 : DmNetSimGetQueueSettings
223 : DmNetSimGetNumQueues
224 : DmNetSimInsertIpv4Redirect
225 : DmNetSimRemoveIpv4Redirect
226 : DmNetSimGetNumIpv4Redirects
300 : XLFAllocate
301 : XLFFree
302 : XLFQueueAdd
303 : XLFQueueAllocated
304 : XLFQueueCreate
305 : XLFQueueDestroy
306 : XLFQueueGetEntryCount
307 : XLFQueueIsEmpty
308 : XLFQueueRemove
309 : XLFQueueUnsafeDump
310 : XLFStackAllocated
311 : XLFStackCreate
312 : XLFStackDestroy
313 : XLFStackGetEntryCount
314 : XLFStackIsEmpty
315 : XLFStackPop
316 : XLFStackPush
317 : XLFStackUnsafeDump
320 : XLFPriorityQueueAdd
321 : XLFPriorityQueueAllocated
322 : XLFPriorityQueueCreate
323 : XLFPriorityQueueDestroy
324 : XLFPriorityQueueGetEntryCount
325 : XLFPriorityQueueIsEmpty
326 : XLFPriorityQueueRemoveFirst
327 : XLFPriorityQueueRemove
328 : XLFPriorityQueueUnsafeDump
330 : XLFHashTableAdd
331 : XLFHashTableAllocated
332 : XLFHashTableCreate
333 : XLFHashTableDestroy
334 : XLFHashTableGetEntryCount
335 : XLFHashTableIsEmpty
336 : XLFHashTableRemoveFirst
337 : XLFHashTableRemove
338 : XLFHashTableUnsafeDump
340 : XLFPoolAcquireLock
341 : XLFPoolAllocated
342 : XLFPoolCreate
343 : XLFPoolCreateLock
344 : XLFPoolDestroy
345 : XLFPoolDestroyLock
346 : XLFPoolIncreaseEvents
347 : XLFPoolIncreaseLocks
348 : XLFPoolInitializeLock
349 : XLFPoolNumberOfEvents
350 : XLFPoolNumberOfLocks
351 : XLFPoolReleaseLock
355 : XLFStartLog
356 : XLFStartUserLog
357 : _XLFInitializeLog__YAJHPBDHHHPAU_XLOCKFREE_CREATE__PAK_Z
358 : _XLFInitializeUserLog__YAJHPAXP6AJ0PAEK_ZHHHPAU_XLOCKFREE_CREATE__PAK_Z
360 : XLFEndLog
361 : XLFLogPrint
362 : XLFLogPrintV
363 : XLFLogBuffer
364 : XLFLogMessageStats
370 : XLockFreeGetErrorHandler
371 : XLockFreeSetErrorHandler

```

`docs/kernel/ordinals/xboxkrnl.ord`:

```ord
0 : xboxkrnld.exe
1 : DbgBreakPoint
2 : DbgBreakPointWithStatus
3 : DbgPrint
4 : DbgPrompt
5 : DumpGetRawDumpInfo
6 : DumpWriteDump
7 : ExAcquireReadWriteLockExclusive
8 : ExAcquireReadWriteLockShared
9 : ExAllocatePool
10 : ExAllocatePoolWithTag
11 : ExAllocatePoolTypeWithTag
12 : ExConsoleGameRegion
13 : ExCreateThread
14 : ExEventObjectType
15 : ExFreePool
16 : ExGetXConfigSetting
17 : ExInitializeReadWriteLock
18 : ExMutantObjectType
19 : ExQueryPoolBlockSize
20 : ExRegisterThreadNotification
21 : ExRegisterTitleTerminateNotification
22 : ExReleaseReadWriteLock
23 : ExSemaphoreObjectType
24 : ExSetXConfigSetting
25 : ExTerminateThread
26 : ExTerminateTitleProcess
27 : ExThreadObjectType
28 : ExTimerObjectType
29 : MmDoubleMapMemory
30 : MmUnmapMemory
31 : XeKeysGetConsoleCertificate
32 : FscGetCacheElementCount
33 : FscSetCacheElementCount
34 : HalGetCurrentAVPack
35 : HalGpioControl
36 : HalOpenCloseODDTray
37 : HalReadWritePCISpace
38 : HalRegisterPowerDownNotification
39 : HalRegisterSMCNotification
40 : HalReturnToFirmware
41 : HalSendSMCMessage
42 : HalSetAudioEnable
43 : InterlockedFlushSList
44 : InterlockedPopEntrySList
45 : InterlockedPushEntrySList
46 : IoAcquireDeviceObjectLock
47 : IoAllocateIrp
48 : IoBuildAsynchronousFsdRequest
49 : IoBuildDeviceIoControlRequest
50 : IoBuildSynchronousFsdRequest
51 : IoCallDriver
52 : IoCheckShareAccess
53 : IoCompleteRequest
54 : IoCompletionObjectType
55 : IoCreateDevice
56 : IoCreateFile
57 : IoDeleteDevice
58 : IoDeviceObjectType
59 : IoDismountVolume
60 : IoDismountVolumeByFileHandle
61 : IoDismountVolumeByName
62 : IoFileObjectType
63 : IoFreeIrp
64 : IoInitializeIrp
65 : IoInvalidDeviceRequest
66 : ExSetBetaFeaturesEnabled
67 : IoQueueThreadIrp
68 : IoReleaseDeviceObjectLock
69 : IoRemoveShareAccess
70 : IoSetIoCompletion
71 : IoSetShareAccess
72 : IoStartNextPacket
73 : IoStartNextPacketByKey
74 : IoStartPacket
75 : IoSynchronousDeviceIoControlRequest
76 : IoSynchronousFsdRequest
77 : KeAcquireSpinLockAtRaisedIrql
78 : KeAlertResumeThread
79 : KeAlertThread
80 : KeBlowFuses
81 : KeBoostPriorityThread
82 : KeBugCheck
83 : KeBugCheckEx
84 : KeCancelTimer
85 : KeConnectInterrupt
86 : KeContextFromKframes
87 : KeContextToKframes
88 : KeCreateUserMode
89 : KeDebugMonitorData
90 : KeDelayExecutionThread
91 : KeDeleteUserMode
92 : KeDisconnectInterrupt
93 : KeEnableFpuExceptions
94 : KeEnablePPUPerformanceMonitor
95 : KeEnterCriticalRegion
96 : KeEnterUserMode
97 : KeFlushCacheRange
98 : KeFlushCurrentEntireTb
99 : KeFlushEntireTb
100 : KeFlushUserModeCurrentTb
101 : KeFlushUserModeTb
102 : KeGetCurrentProcessType
103 : KeGetPMWRegister
104 : KeGetPRVRegister
105 : KeGetSocRegister
106 : KeGetSpecialPurposeRegister
107 : KeLockL2
108 : KeUnlockL2
109 : KeInitializeApc
110 : KeInitializeDeviceQueue
111 : KeInitializeDpc
112 : KeInitializeEvent
113 : KeInitializeInterrupt
114 : KeInitializeMutant
115 : KeInitializeQueue
116 : KeInitializeSemaphore
117 : KeInitializeTimerEx
118 : KeInsertByKeyDeviceQueue
119 : KeInsertDeviceQueue
120 : KeInsertHeadQueue
121 : KeInsertQueue
122 : KeInsertQueueApc
123 : KeInsertQueueDpc
124 : KeIpiGenericCall
125 : KeLeaveCriticalRegion
126 : KeLeaveUserMode
127 : KePulseEvent
128 : KeQueryBackgroundProcessors
129 : KeQueryBasePriorityThread
130 : KeQueryInterruptTime
131 : KeQueryPerformanceFrequency
132 : KeQuerySystemTime
133 : KeRaiseIrqlToDpcLevel
134 : KeRegisterDriverNotification
135 : KeReleaseMutant
136 : KeReleaseSemaphore
137 : KeReleaseSpinLockFromRaisedIrql
138 : KeRemoveByKeyDeviceQueue
139 : KeRemoveDeviceQueue
140 : KeRemoveEntryDeviceQueue
141 : KeRemoveQueue
142 : KeRemoveQueueDpc
143 : KeResetEvent
144 : KeRestoreFloatingPointState
145 : KeRestoreVectorUnitState
146 : KeResumeThread
147 : KeRetireDpcList
148 : KeRundownQueue
149 : KeSaveFloatingPointState
150 : KeSaveVectorUnitState
151 : KeSetAffinityThread
152 : KeSetBackgroundProcessors
153 : KeSetBasePriorityThread
154 : KeSetCurrentProcessType
155 : KeSetCurrentStackPointers
156 : KeSetDisableBoostThread
157 : KeSetEvent
158 : KeSetEventBoostPriority
159 : KeSetPMWRegister
160 : KeSetPowerMode
161 : KeSetPRVRegister
162 : KeSetPriorityClassThread
163 : KeSetPriorityThread
164 : KeSetSocRegister
165 : KeSetSpecialPurposeRegister
166 : KeSetTimer
167 : KeSetTimerEx
168 : KeStallExecutionProcessor
169 : KeSuspendThread
170 : KeSweepDcacheRange
171 : KeSweepIcacheRange
172 : KeTestAlertThread
173 : KeTimeStampBundle
174 : KeTryToAcquireSpinLockAtRaisedIrql
175 : KeWaitForMultipleObjects
176 : KeWaitForSingleObject
177 : KfAcquireSpinLock
178 : KfRaiseIrql
179 : KfLowerIrql
180 : KfReleaseSpinLock
181 : KiBugCheckData
182 : LDICreateDecompression
183 : LDIDecompress
184 : LDIDestroyDecompression
185 : MmAllocatePhysicalMemory
186 : MmAllocatePhysicalMemoryEx
187 : MmCreateKernelStack
188 : MmDeleteKernelStack
189 : MmFreePhysicalMemory
190 : MmGetPhysicalAddress
191 : MmIsAddressValid
192 : MmLockAndMapSegmentArray
193 : MmLockUnlockBufferPages
194 : MmMapIoSpace
195 : MmPersistPhysicalMemoryAllocation
196 : MmQueryAddressProtect
197 : MmQueryAllocationSize
198 : MmQueryStatistics
199 : MmSetAddressProtect
200 : MmSplitPhysicalMemoryAllocation
201 : MmUnlockAndUnmapSegmentArray
202 : MmUnmapIoSpace
203 : Nls844UnicodeCaseTable
204 : NtAllocateVirtualMemory
205 : NtCancelTimer
206 : NtClearEvent
207 : NtClose
208 : NtCreateDirectoryObject
209 : NtCreateEvent
210 : NtCreateFile
211 : NtCreateIoCompletion
212 : NtCreateMutant
213 : NtCreateSemaphore
214 : NtCreateSymbolicLinkObject
215 : NtCreateTimer
216 : NtDeleteFile
217 : NtDeviceIoControlFile
218 : NtDuplicateObject
219 : NtFlushBuffersFile
220 : NtFreeVirtualMemory
221 : NtMakeTemporaryObject
222 : NtOpenDirectoryObject
223 : NtOpenFile
224 : NtOpenSymbolicLinkObject
225 : NtProtectVirtualMemory
226 : NtPulseEvent
227 : NtQueueApcThread
228 : NtQueryDirectoryFile
229 : NtQueryDirectoryObject
230 : NtQueryEvent
231 : NtQueryFullAttributesFile
232 : NtQueryInformationFile
233 : NtQueryIoCompletion
234 : NtQueryMutant
235 : NtQuerySemaphore
236 : NtQuerySymbolicLinkObject
237 : NtQueryTimer
238 : NtQueryVirtualMemory
239 : NtQueryVolumeInformationFile
240 : NtReadFile
241 : NtReadFileScatter
242 : NtReleaseMutant
243 : NtReleaseSemaphore
244 : NtRemoveIoCompletion
245 : NtResumeThread
246 : NtSetEvent
247 : NtSetInformationFile
248 : NtSetIoCompletion
249 : NtSetSystemTime
250 : NtSetTimerEx
251 : NtSignalAndWaitForSingleObjectEx
252 : NtSuspendThread
253 : NtWaitForSingleObjectEx
254 : NtWaitForMultipleObjectsEx
255 : NtWriteFile
256 : NtWriteFileGather
257 : NtYieldExecution
258 : ObCreateObject
259 : ObCreateSymbolicLink
260 : ObDeleteSymbolicLink
261 : ObDereferenceObject
262 : ObDirectoryObjectType
263 : ObGetWaitableObject
264 : ObInsertObject
265 : ObIsTitleObject
266 : ObLookupAnyThreadByThreadId
267 : ObLookupThreadByThreadId
268 : ObMakeTemporaryObject
269 : ObOpenObjectByName
270 : ObOpenObjectByPointer
271 : ObReferenceObject
272 : ObReferenceObjectByHandle
273 : ObReferenceObjectByName
274 : ObSymbolicLinkObjectType
275 : ObTranslateSymbolicLink
276 : RtlAnsiStringToUnicodeString
277 : RtlAppendStringToString
278 : RtlAppendUnicodeStringToString
279 : RtlAppendUnicodeToString
280 : RtlAssert
281 : RtlCaptureContext
282 : RtlCompareMemory
283 : RtlCompareMemoryUlong
284 : RtlCompareString
285 : RtlCompareStringN
286 : RtlCompareUnicodeString
287 : RtlCompareUnicodeStringN
288 : RtlCompareUtf8ToUnicode
289 : RtlCopyString
290 : RtlCopyUnicodeString
291 : RtlCreateUnicodeString
292 : RtlDowncaseUnicodeChar
293 : RtlEnterCriticalSection
294 : RtlFillMemoryUlong
295 : RtlFreeAnsiString
296 : RtlFreeAnsiString
297 : RtlGetCallersAddress
298 : RtlGetStackLimits
299 : RtlImageXexHeaderField
300 : RtlInitAnsiString
301 : RtlInitUnicodeString
302 : RtlInitializeCriticalSection
303 : RtlInitializeCriticalSectionAndSpinCount
304 : RtlLeaveCriticalSection
305 : RtlLookupFunctionEntry
306 : RtlLowerChar
307 : RtlMultiByteToUnicodeN
308 : RtlMultiByteToUnicodeSize
309 : RtlNtStatusToDosError
310 : RtlRaiseException
311 : RtlRaiseStatus
312 : RtlRip
313 : _scprintf
314 : _snprintf
315 : sprintf
316 : _scwprintf
317 : _snwprintf
318 : _swprintf
319 : RtlTimeFieldsToTime
320 : RtlTimeToTimeFields
321 : RtlTryEnterCriticalSection
322 : RtlUnicodeStringToAnsiString
323 : RtlUnicodeToMultiByteN
324 : RtlUnicodeToMultiByteSize
325 : RtlUnicodeToUtf8
326 : RtlUnicodeToUtf8Size
327 : RtlUnwind
328 : RtlUnwind2
329 : RtlUpcaseUnicodeChar
330 : RtlUpperChar
331 : RtlVirtualUnwind
332 : _vscprintf
333 : _vsnprintf
334 : vsprintf
335 : _vscwprintf
336 : _vsnwprintf
337 : _vswprintf
338 : KeTlsAlloc
339 : KeTlsFree
340 : KeTlsGetValue
341 : KeTlsSetValue
342 : XboxHardwareInfo
343 : XboxKrnlBaseVersion
344 : XboxKrnlVersion
345 : XeCryptAesKey
346 : XeCryptAesEcb
347 : XeCryptAesCbc
348 : XeCryptBnDwLeDhEqualBase
349 : XeCryptBnDwLeDhInvalBase
350 : XeCryptBnDwLeDhModExp
351 : XeCryptBnDw_Copy
352 : XeCryptBnDw_SwapLeBe
353 : XeCryptBnDw_Zero
354 : XeCryptBnDwLePkcs1Format
355 : XeCryptBnDwLePkcs1Verify
356 : XeCryptBnQwBeSigCreate
357 : XeCryptBnQwBeSigFormat
358 : XeCryptBnQwBeSigVerify
359 : XeCryptBnQwNeModExp
360 : XeCryptBnQwNeModExpRoot
361 : XeCryptBnQwNeModInv
362 : XeCryptBnQwNeModMul
363 : XeCryptBnQwNeRsaKeyGen
364 : XeCryptBnQwNeRsaPrvCrypt
365 : XeCryptBnQwNeRsaPubCrypt
366 : XeCryptBnQw_Copy
367 : XeCryptBnQw_SwapDwQw
368 : XeCryptBnQw_SwapDwQwLeBe
369 : XeCryptBnQw_SwapLeBe
370 : XeCryptBnQw_Zero
371 : XeCryptChainAndSumMac
372 : XeCryptDesParity
373 : XeCryptDesKey
374 : XeCryptDesEcb
375 : XeCryptDesCbc
376 : XeCryptDes3Key
377 : XeCryptDes3Ecb
378 : XeCryptDes3Cbc
379 : XeCryptHmacMd5Init
380 : XeCryptHmacMd5Update
381 : XeCryptHmacMd5Final
382 : XeCryptHmacMd5
383 : XeCryptHmacShaInit
384 : XeCryptHmacShaUpdate
385 : XeCryptHmacShaFinal
386 : XeCryptHmacSha
387 : XeCryptHmacShaVerify
388 : XeCryptMd5Init
389 : XeCryptMd5Update
390 : XeCryptMd5Final
391 : XeCryptMd5
392 : XeCryptParveEcb
393 : XeCryptParveCbcMac
394 : XeCryptRandom
395 : XeCryptRc4Key
396 : XeCryptRc4Ecb
397 : XeCryptRc4
398 : XeCryptRotSumSha
399 : XeCryptShaInit
400 : XeCryptShaUpdate
401 : XeCryptShaFinal
402 : XeCryptSha
403 : XexExecutableModuleHandle
404 : XexCheckExecutablePrivilege
405 : XexGetModuleHandle
406 : XexGetModuleSection
407 : XexGetProcedureAddress
408 : XexLoadExecutable
409 : XexLoadImage
410 : XexLoadImageFromMemory
411 : XexLoadImageHeaders
412 : XexPcToFileHeader
413 : KiApcNormalRoutineNop
414 : XexRegisterPatchDescriptor
415 : XexSendDeferredNotifications
416 : XexStartExecutable
417 : XexUnloadImage
418 : XexUnloadImageAndExitThread
419 : XexUnloadTitleModules
420 : XexVerifyImageHeaders
421 : __C_specific_handler
422 : DbgLoadImageSymbols
423 : DbgUnLoadImageSymbols
424 : RtlImageDirectoryEntryToData
425 : RtlImageNtHeader
426 : ExDebugMonitorService
427 : MmDbgReadCheck
428 : MmDbgReleaseAddress
429 : MmDbgWriteCheck
430 : ExLoadedCommandLine
431 : ExLoadedImageName
432 : VdBlockUntilGUIIdle
433 : VdCallGraphicsNotificationRoutines
434 : VdDisplayFatalError
435 : VdEnableClosedCaption
436 : VdEnableDisableClockGating
437 : VdEnableDisablePowerSavingMode
438 : VdEnableRingBufferRPtrWriteBack
439 : VdGenerateGPUCSCCoefficients
440 : VdGetClosedCaptionReadyStatus
441 : VdGetCurrentDisplayGamma
442 : VdGetCurrentDisplayInformation
443 : VdGetDisplayModeOverride
444 : VdGetGraphicsAsicID
445 : VdGetSystemCommandBuffer
446 : VdGlobalDevice
447 : VdGlobalXamDevice
448 : VdGpuClockInMHz
449 : VdHSIOCalibrationLock
450 : VdInitializeEngines
451 : VdInitializeRingBuffer
452 : VdInitializeScaler
453 : VdInitializeScalerCommandBuffer
454 : VdIsHSIOTrainingSucceeded
455 : VdPersistDisplay
456 : VdQuerySystemCommandBuffer
457 : VdQueryVideoFlags
458 : VdQueryVideoMode
459 : VdReadDVERegisterUlong
460 : VdReadWriteHSIOCalibrationFlag
461 : VdRegisterGraphicsNotification
462 : VdRegisterXamGraphicsNotification
463 : VdSendClosedCaptionData
464 : VdSetCGMSOption
465 : VdSetColorProfileAdjustment
466 : VdSetCscMatricesOverride
467 : VdSetDisplayMode
468 : VdSetDisplayModeOverride
469 : VdSetGraphicsInterruptCallback
470 : _VdSetHDCPOption__YAKK_Z
471 : VdSetMacrovisionOption
472 : VdSetSystemCommandBuffer
473 : VdSetSystemCommandBufferGpuIdentifierAddress
474 : VdSetWSSData
475 : VdSetWSSOption
476 : VdShutdownEngines
477 : VdTurnDisplayOff
478 : VdTurnDisplayOn
479 : KiApcNormalRoutineNop
480 : VdWriteDVERegisterUlong
481 : XVoicedHeadsetPresent
482 : XVoicedSubmitPacket
483 : XVoicedClose
484 : XVoicedActivate
485 : XInputdGetCapabilities
486 : XInputdReadState
487 : XInputdWriteState
488 : XInputdNotify
489 : XInputdRawState
490 : HidGetCapabilities
491 : HidReadKeys
492 : XInputdGetDeviceStats
493 : XInputdResetDevice
494 : XInputdSetRingOfLight
495 : XInputdSetRFPowerMode
496 : XInputdSetRadioFrequency
497 : HidGetLastInputTime
498 : XAudioRenderDriverInitialize
499 : XAudioRegisterRenderDriverClient
500 : XAudioUnregisterRenderDriverClient
501 : XAudioSubmitRenderDriverFrame
502 : XAudioRenderDriverLock
503 : XAudioGetVoiceCategoryVolumeChangeMask
504 : XAudioGetVoiceCategoryVolume
505 : XAudioSetVoiceCategoryVolume
506 : XAudioBeginDigitalBypassMode
507 : XAudioEndDigitalBypassMode
508 : XAudioSubmitDigitalPacket
509 : XAudioQueryDriverPerformance
510 : XAudioGetRenderDriverThread
511 : XAudioGetSpeakerConfig
512 : XAudioSetSpeakerConfig
513 : NicSetUnicastAddress
514 : NicAttach
515 : NicDetach
516 : NicXmit
517 : NicUpdateMcastMembership
518 : NicFlushXmitQueue
519 : NicShutdown
520 : NicGetLinkState
521 : NicGetStats
522 : NicGetOpt
523 : NicSetOpt
524 : DrvSetSysReqCallback
525 : DrvSetUserBindingCallback
526 : DrvSetContentStorageCallback
527 : DrvSetAutobind
528 : DrvGetContentStorageNotification
529 : MtpdBeginTransaction
530 : MtpdCancelTransaction
531 : MtpdEndTransaction
532 : MtpdGetCurrentDevices
533 : MtpdReadData
534 : MtpdReadEvent
535 : MtpdResetDevice
536 : MtpdSendData
537 : MtpdVerifyProximity
538 : XUsbcamSetCaptureMode
539 : XUsbcamGetConfig
540 : XUsbcamSetConfig
541 : XUsbcamGetState
542 : XUsbcamReadFrame
543 : XUsbcamSnapshot
544 : XUsbcamSetView
545 : XUsbcamGetView
546 : XUsbcamCreate
547 : XUsbcamDestroy
548 : XMACreateContext
549 : XMAInitializeContext
550 : XMAReleaseContext
551 : XMAEnableContext
552 : XMADisableContext
553 : XMAGetOutputBufferWriteOffset
554 : XMASetOutputBufferReadOffset
555 : XMAGetOutputBufferReadOffset
556 : XMASetOutputBufferValid
557 : XMAIsOutputBufferValid
558 : XMASetInputBuffer0Valid
559 : XMAIsInputBuffer0Valid
560 : XMASetInputBuffer1Valid
561 : XMAIsInputBuffer1Valid
562 : XMASetInputBuffer0
563 : XMASetInputBuffer1
564 : XMAGetPacketMetadata
565 : XMABlockWhileInUse
566 : XMASetLoopData
567 : XMASetInputBufferReadOffset
568 : XMAGetInputBufferReadOffset
569 : ExIsBetaFeatureEnabled
570 : XeKeysGetFactoryChallenge
571 : XeKeysSetFactoryResponse
572 : XeKeysInitializeFuses
573 : XeKeysSaveBootLoader
574 : XeKeysSaveKeyVault
575 : XeKeysGetStatus
576 : XeKeysGeneratePrivateKey
577 : XeKeysGetKeyProperties
578 : XeKeysSetKey
579 : XeKeysGenerateRandomKey
580 : XeKeysGetKey
581 : XeKeysGetDigest
582 : XeKeysGetConsoleID
583 : XeKeysGetConsoleType
584 : XeKeysQwNeRsaPrvCrypt
585 : XeKeysHmacSha
586 : XInputdPassThroughRFCommand
587 : XeKeysAesCbc
588 : XeKeysDes2Cbc
589 : XeKeysDesCbc
590 : XeKeysObscureKey
591 : XeKeysHmacShaUsingKey
592 : XeKeysSaveBootLoaderEx
593 : XeKeysAesCbcUsingKey
594 : XeKeysDes2CbcUsingKey
595 : XeKeysDesCbcUsingKey
596 : XeKeysObfuscate
597 : XeKeysUnObfuscate
598 : XeKeysConsolePrivateKeySign
599 : XeKeysConsoleSignatureVerification
600 : XeKeysVerifyRSASignature
601 : StfsCreateDevice
602 : StfsControlDevice
603 : VdSwap
604 : HalFsbInterruptCount
605 : XeKeysSaveSystemUpdate
606 : XeKeysLockSystemUpdate
607 : XeKeysExecute
608 : XeKeysGetVersions
609 : XInputdPowerDownDevice
610 : AniBlockOnAnimation
611 : AniTerminateAnimation
612 : XUsbcamReset
613 : AniSetLogo
614 : KeCertMonitorData
615 : HalIsExecutingPowerDownDpc
616 : VdInitializeEDRAM
617 : VdRetrainEDRAM
618 : VdRetrainEDRAMWorker
619 : VdHSIOTrainCount
620 : HalGetPowerUpCause
621 : VdHSIOTrainingStatus
622 : RgcBindInfo
623 : VdReadEEDIDBlock
624 : VdEnumerateVideoModes
625 : VdEnableHDCP
626 : VdRegisterHDCPNotification
627 : HidReadMouseChanges
628 : DumpSetCollectionFacility
629 : XexTransformImageKey
630 : XAudioOverrideSpeakerConfig
631 : XInputdReadTextKeystroke
632 : DrvXenonButtonPressed
633 : DrvBindToUser
634 : XexGetModuleImportVersions
635 : RtlComputeCrc32
636 : XeKeysSetRevocationList
637 : HalRegisterPowerDownCallback
638 : VdGetDisplayDiscoveryData
639 : XInputdSendStayAliveRequest
640 : XVoicedSendVPort
641 : XVoicedGetBatteryStatus
642 : XInputdFFGetDeviceInfo
643 : XInputdFFSetEffect
644 : XInputdFFUpdateEffect
645 : XInputdFFEffectOperation
646 : XInputdFFDeviceControl
647 : XInputdFFSetDeviceGain
648 : XInputdFFCancelIo
649 : XInputdFFSetRumble
650 : NtAllocateEncryptedMemory
651 : NtFreeEncryptedMemory
652 : XeKeysExSaveKeyVault
653 : XeKeysExSetKey
654 : XeKeysExGetKey
655 : DrvSetDeviceConfigChangeCallback
656 : DrvDeviceConfigChange
657 : HalRegisterHdDvdRomNotification
658 : XeKeysSecurityInitialize
659 : XeKeysSecurityLoadSettings
660 : XeKeysSecuritySaveSettings
661 : XeKeysSecuritySetDetected
662 : XeKeysSecurityGetDetected
663 : XeKeysSecuritySetActivated
664 : XeKeysSecurityGetActivated
665 : XeKeysReserved665
666 : XeKeysReserved666
667 : XeKeysGetProtectedFlag
668 : XeKeysSetProtectedFlag
669 : KeEnablePFMInterrupt
670 : KeDisablePFMInterrupt
671 : KeSetProfilerISR
672 : VdStartDisplayDiscovery
673 : VdSetHDCPRevocationList
674 : XeKeysGetUpdateSequence
675 : XeKeysDvdAuthExActivate
676 : KeGetImagePageTableEntry
677 : HalRegisterBackgroundModeTransitionCallback
678 : AniStartBootAnimation
679 : HalClampUnclampOutputDACs
680 : HalPowerDownToBackgroundMode
681 : HalNotifyAddRemoveBackgroundTask
682 : HalCallBackgroundModeNotificationRoutines
683 : HalFsbResetCount
684 : HalGetMemoryInformation
685 : XInputdGetLastTextInputTime
686 : VdEnableWMAProOverHDMI
687 : XeKeysRevokeSaveSettings
688 : XInputdSetTextMessengerIndicator
689 : MicDeviceRequest
690 : XeKeysGetMediaID
691 : XeKeysReserved665
692 : KeGetVidInfo
693 : HalNotifyBackgroundModeTransitionComplete
694 : IoAcquireCancelSpinLock
695 : IoReleaseCancelSpinLock
696 : NtCancelIoFile
697 : NtCancelIoFileEx
698 : HalFinalizePowerLossRecovery
699 : HalSetPowerLossRecovery
700 : ExReadModifyWriteXConfigSettingUlong
701 : HalRegisterXamPowerDownCallback
702 : ExCancelAlarm
703 : ExInitializeAlarm
704 : ExSetAlarm
705 : XexActivationGetNonce
706 : XexActivationSetLicense
707 : IptvSetBoundaryKey
708 : IptvSetSessionKey
709 : IptvVerifyOmac1Signature
710 : IptvGetAesCtrTransform
711 : SataCdRomRecordReset
712 : XInputdSetTextDeviceKeyLocks
713 : XInputdGetTextDeviceKeyLocks
714 : XexActivationVerifyOwnership
715 : XexDisableVerboseDbgPrint
716 : SvodCreateDevice
717 : RtlCaptureStackBackTrace
718 : XeKeysRevokeUpdateDynamic
719 : XexImportTraceEnable
720 : ExRegisterXConfigNotification
721 : XeKeysSecuritySetStat
722 : VdQueryRealVideoMode
723 : XexSetExecutablePrivilege
724 : XAudioSuspendRenderDriverClients
725 : IptvGetSessionKeyHash
726 : VdSetCGMSState
727 : VdSetSCMSState
728 : KeFlushMultipleTb
729 : VdGetOption
730 : VdSetOption
731 : UsbdBootEnumerationDoneEvent
732 : StfsDeviceErrorEvent
733 : ExTryToAcquireReadWriteLockExclusive
734 : ExTryToAcquireReadWriteLockShared
735 : XexSetLastKdcTime
736 : XInputdControl
737 : RmcDeviceRequest
738 : LDIResetDecompression
739 : NicRegisterDevice
740 : UsbdAddDeviceComplete
741 : UsbdCancelAsyncTransfer
742 : UsbdGetDeviceSpeed
743 : UsbdGetDeviceTopology
744 : UsbdGetEndpointDescriptor
745 : UsbdIsDeviceAuthenticated
746 : UsbdOpenDefaultEndpoint
747 : UsbdOpenEndpoint
748 : UsbdQueueAsyncTransfer
749 : UsbdQueueCloseDefaultEndpoint
750 : UsbdQueueCloseEndpoint
751 : UsbdRemoveDeviceComplete
752 : KeRemoveQueueApc
753 : UsbdDriverLoadRequiredEvent
754 : UsbdGetRequiredDrivers
755 : UsbdRegisterDriverObject
756 : UsbdUnregisterDriverObject
758 : UsbdResetDevice
759 : UsbdGetDeviceDescriptor
760 : NomnilGetExtension
761 : NomnilStartCloseDevice
762 : WifiBeginAuthentication
763 : WifiCheckCounterMeasures
764 : WifiChooseAuthenCipherSetFromBSSID
765 : WifiCompleteAuthentication
766 : WifiGetAssociationIE
767 : WifiOnMICError
768 : WifiPrepareAuthenticationContext
769 : WifiRecvEAPOLPacket
770 : WifiDeduceNetworkType
771 : NicUnregisterDevice
772 : DumpXitThread
773 : XInputdSetWifiChannel
774 : NomnilSetLed
775 : WifiCalculateRegulatoryDomain
776 : WifiSelectAdHocChannel
777 : WifiChannelToFrequency
778 : MmGetPoolPagesType
779 : ExExpansionInstall
780 : ExExpansionCall
781 : PsCamDeviceRequest
782 : McaDeviceRequest
783 : DetroitDeviceRequest
784 : XeCryptSha256Init
785 : XeCryptSha256Update
786 : XeCryptSha256Final
787 : XeCryptSha256
788 : XeCryptSha384Init
789 : XeCryptSha384Update
790 : XInputdGetDevicePid
791 : HalGetNotedArgonErrors
792 : XeCryptSha384Final
793 : HalReadArgonEeprom
794 : HalWriteArgonEeprom
795 : XeKeysFcrtLoad
796 : XeKeysFcrtSave
797 : XeKeysFcrtSet
798 : XeCryptSha384
799 : XeCryptSha512Init
800 : XAudioRegisterRenderDriverMECClient
801 : XAudioUnregisterRenderDriverMECClient
802 : XAudioCaptureRenderDriverFrame
803 : XeCryptSha512Update
804 : XeCryptSha512Final
805 : XeCryptSha512
806 : XeCryptBnQwNeCompare
807 : XVoicedGetDirectionalData
808 : DrvSetMicArrayStartCallback
809 : DevAuthGetStatistics
810 : NullCableRequest
811 : XeKeysRevokeIsDeviceRevoked
812 : DumpUpdateDumpSettings
813 : EtxConsumerDisableEventType
814 : EtxConsumerEnableEventType
815 : EtxConsumerProcessLogs
816 : EtxConsumerRegister
817 : EtxConsumerUnregister
818 : EtxProducerLog
819 : EtxProducerLogV
820 : EtxProducerRegister
821 : EtxProducerUnregister
822 : EtxConsumerFlushBuffers
823 : EtxProducerLogXwpp
824 : EtxProducerLogXwppV
825 : UsbdEnableDisableRootHubPort
826 : EtxBufferRegister
827 : EtxBufferUnregister
828 : DumpRegisterDedicatedDataBlock
829 : XeKeysDvdAuthExSave
830 : XeKeysDvdAuthExInstall
831 : XexShimDisable
832 : XexShimEnable
833 : XexShimEntryDisable
834 : XexShimEntryEnable
835 : XexShimEntryRegister
836 : XexShimLock
837 : XboxKrnlVersion4Digit
838 : XeKeysObfuscateEx
839 : XeKeysUnObfuscateEx
840 : XexTitleHash
841 : XexTitleHashClose
842 : XexTitleHashContinue
843 : XexTitleHashOpen
844 : XAudioGetRenderDriverTic
845 : XAudioEnableDucker
846 : XAudioSetDuckerLevel
847 : XAudioIsDuckerEnabled
848 : XAudioGetDuckerLevel
849 : XAudioGetDuckerThreshold
850 : XAudioSetDuckerThreshold
851 : XAudioGetDuckerAttackTime
852 : XAudioSetDuckerAttackTime
853 : XAudioGetDuckerReleaseTime
854 : XAudioSetDuckerReleaseTime
855 : XAudioGetDuckerHoldTime
856 : XAudioSetDuckerHoldTime
857 : DevAuthShouldAlwaysEnforce
858 : XAudioGetUnderrunCount
859 : DrvSetAudioLatencyCallback
860 : XVoicedIsActiveProcess
861 : KeExecuteOnProtectedStack
862 : XeKeysVerifyPIRSSignature
863 : XeCryptAesCtr
864 : XeCryptAesCbcMac
865 : XeCryptAesDmMac
866 : EmaExecute
867 : XeKeysGetTruncatedSecondaryConsoleId
868 : ExFreeDebugPool
869 : VdQueryVideoCapabilities
870 : UsbdGetDeviceRootPortType
871 : VdGet3dVideoFormat
872 : VdGetWSS2Data
873 : VdSet3dVideoFormat
874 : VdSetWSS2Data
875 : XexReserveCodeBuffer
876 : XexCommitCodeBuffer
877 : RtlSetVectoredExceptionHandler
878 : RtlClearVectoredExceptionHandler
879 : XAudioSetProcessFrameCallback
880 : UsbdGetRootHubDeviceNode
881 : UsbdGetPortDeviceNode
882 : UsbdGetNatalHub
883 : UsbdGetNatalHardwareVersion
884 : UsbdNatalHubRegisterNotificationCallback
885 : KeCallAndBlockOnDpcRoutine
886 : KeCallAndWaitForDpcRoutine
887 : TidDeviceRequest

```

`docs/kernel/structures.txt`:

```txt
LIST_ENTRY : 0x8
	0x00 : LIST_ENTRY *flink
	0x04 : LIST_ENTRY *blink

DISPATCHER_HEADER : 0x10
	0x00 : UCHAR Type
	0x01 : UCHAR Absolute
	0x02 : UCHAR Absolute
	0x03 : UCHAR Absolute
	0x04 : LONG SignalState
	0x08 : LIST_ENTRY WaitListHead

KMUTANT : 0x1c
	0x00 : DISPATCHER_HEADER Header
	0x10 : LIST_ENTRY MutantListEntry
	0x18 : KTHREAD *OwnerThread
	0x1C : BOOLEAN Abandoned
	
KDPC : 0x1c
	0x00 : short Type
	0x02 : BYTE InsertedNumber
	0x03 : BYTE TargetNumber
	0x04 : LIST_ENTRY DpcListEntry
	0x0C : void *DeferredRoutine
	0x10 : void *DeferredCintext
	0x14 : void *SystemArgument1
	0x18 : void *SystemArgument2
	
KTIMER : 0x28
	0x00 : DISPATCHER_HEADER Header
	0x10 : ULARGE_INTEGER DueTime
	0x18 : LIST_ENTRY TimerListEntry
	0x20 : KDPC *Dpc
	0x24 : LONG Period

KWAIT_BLOCK : 0x18
	0x00 : LIST_ENTRY WaitListEntry
	0x08 : KTHREAD *Thread
	0x0C : PVOID Object
	0x10 : KWAIT_BLOCK *NextWaitBlock
	0x14 : USHORT WaitKey
	0x16 : USHORT WaitType

KSEMAPHORE : 0x14
	0x00 : DISPATCHER_HEADER Header
	0x10 : LONG Limit

KAPC_STATE : 0x17
	0x00 : LIST_ENTRY ApcListHead[2]
	0x10 : KPROCESS *Process
	0x14 : BOOLEAN KernelApcInProgress
	0x15 : BOOLEAN KernelApcPending
	0x16 : BOOLEAN UserApcPending
	
KAPC : 0x28
	0x00 : CSHORT Type;
	0x02 : KPROCESSOR_MODE ApcMode
	0x03 : UCHAR ???
	0x04 : KTHREAD *Thread
	0x08 : LIST_ENTRY ApcListEntry
	0x10 : PKKERNEL_ROUTINE KernelRoutine
	0x14 : PKRUNDOWN_ROUTINE RundownRoutine
	0x18 : PKNORMAL_ROUTINE NormalRoutine
	0x1C : PVOID NormalContext
	0x20 : PVOID SystemArgument1
	0x24 : PVOID SystemArgument2

KSEMAPHORE : 0x14
	0x00 : DISPATCHER_HEADER Header
	0x10 : LONG Limit

KSPIN_LOCK : 0x4
	0x00 : ULONG_PTR

KTHREAD : ?
	0x00 : DISPATCHER_HEADER Header
	0x10 : LIST_ENTRY MutantListHead
	0x18 : KTIMER Timer
	0x40 : KWAIT_BLOCK TimerWaitBlock
	0x58 : DWORD KernelTime
	0x5C : PVOID InitialStack
	0x60 : PVOID StackLimit
	0x64 : PVOID KernelStack
	0x68 : PVOID TlsData
	0x6C : UCHAR State
	0x6D : BOOLEAN Alerted[2]
	0x6F : BOOLEAN Alertable
	0x70 : SCHAR Priority
	0x71 : UCHAR FpuExceptionEnable
	0x72 : UCHAR CreateProcessType
	0x73 : UCHAR CurrentProcessType
	0x74 : KAPC_STATE ApcState
	0x8B : BOOLEAN ApcQueueable
	0x8C : KSPIN_LOCK ApcQueueLock
	0x90 : ULONG ContextSwitches
	0x94 : LIST_ENTRY ReadyListEntry
	0x9C : ULONG MsrEnableMask
	0xA0 : LONG_PTR WaitStatus
	0xA4 : KIRQL WaitIrql
	0xA5 : KPROCESSOR_MODE WaitMode
	0xA6 : BOOLEAN WaitNext
	0xA7 : UCHAR WaitReason
	0xA8 : KWaitBlock * WaitBlockList
	0xAC : ?
	0xB0 : DWORD KernelApcDisable
	0xB4 : DWORD Quantum
	0xB8 : CHAR Saturation
	0xB9 : SCHAR BasePriority
	0xBA : SCHAR PriorityDecrement
	0xBB : UCHAR DisableBoost
	0xBC : CCHAR SuspendCount
	0xBD : BOOLEAN Preempted
	0xBE : UCHAR HasTerminated
	0xBF : UCHAR CurrentProcessor
	0xC0 : KPRCB *CurrentPrcb
	0xC4 : KPRCB *AffinityPrcb
	0xC8 : UCHAR IdlePriorityClass
	0xC9 : UCHAR NormalPriorityClass
	0xCA : UCHAR TimeCriticalPriorityClass
	0xCB : UCHAR HasAsyncTerminated
	0xCC : DWORD ActiveTimerListLock
	0xD0 : PVOID StackAllocatedBase
	0xD4 : KACP SuspendApc
	0xFC : KSEMAPHORE SuspendSemaphore
	0x110 : LIST_ENTRY ThreadListEntry
	0x118 : PRKQUEUE Queue
	0x11C : LIST_ENTRY QueueListEntry
	0x124 : PVOID UserModeDispatcher
	0x128 : PKTRAPFRAME UserModeTrapFrame
	0x12c : ?
	0x130 : int64_t CreateTime
	0x138 : int64_t ExitTime
	0x140 : int32_t ExitStatus
	0x144 : LIST_ENTRY ActiveTimerListHead
	0x14C : DWORD ThreadId
	0x150 : PVOID StartAddress
	0x154 : LIST_ENTRY IrpList
	0x15C : PDEBUG_MONITOR_PTRS DebugMonitorData
	0x160 : DWORD LastWin32ErrorCode
	0x164 : PVOID Win32CurrentFiber
	0x168 : ?
	0x16C : DWORD CreateOptions
	... ?

KPROCESS : ?
	0x00 : DWORD ThreadListLock
	0x04 : LIST_ENTRY ThreadListHead
	0x0C : long ThreadQuantum
	0x10 : DWORD DirectoryTableBase
	0x14 : DWORD ThreadCount
	0x18 : BYTE IdlePriorityClass
	0x19 : BYTE NormalPriorityClass
	0x1a : BYTE TimeCriticalPriorityClass
	0x1b : BYTE DisableQuantum
	0x1c : DWORD DefaultKernelStackSize
	0x20 : void * TlsStaticDataImage
	0x24 : DWORD SizeOfTlsStaticData
	0x28 : DWORD SizeOfTlsStaticDataImage
	0x2c : USHORT SizeOfTlsSlots
	0x2e : BYTE Terminating
	0x2f : BYTE ProcessType
	0x30 : DWORD TlsSlotBitmap[8]
	0x50 : DWORD FileObjectListLock
	0x54 : LIST_ENTRY FileObjectListHead
	0x5C : void * Win32DefaultHeapHandle
	... ?

KPCRB : 0x1a8
	0x00 : PKTHREAD CurrentThread
	0x04 : PKTHREAD NextThread
	0x08 : PKTHREAD IdleThread
	0x0C : BYTE Number
	0x10 : DWORD SetMember
	0x14 : DWORD DpcTime
	0x18 : DWORD InterruptTime
	0x1C : DWORD InterruptCount
	0x20 : DWORD IpiFrozen
	0x24 : PVOID CurrentPacket[3]
	0x30 : DWORD TargetSet
	0x34 : PVOID WorkerRoutine
	0x38 : KPRCB *SignalDone
	0x3C : DWORD RequestSummary
	0x40 : DWORD DpcInterruptRequested
	0x44 : DWORD DpcLock
	0x48 : LIST_ENTRY DpcListHead
	0x50 : DWORD DpcRoutineActive
	0x54 : DWORD ReadyListLock
	0x58 : DWORD IdleThreadActive
	0x5C : PVOID DeferredReadyListHead
	0x60 : DWORD ReadySummary
	0x64 : DWORD ReadSummaryMask
	0x68 : LIST_ENTRY DispatcherReadyListHead[32]
	0x168 : KDPC ThreadReaperDpc
	0x184 : LIST_ENTRY ThreadReaperListHead
	0x18c : KDPC SwitchProcessorThreadDpc
	
KPCR : ?
	0x00 : PVOID TlsData
	0x04 : DWORD MsrEnableMask
	0x08 : USHORT SoftwareInterrupt
	0x0a : USHORT DpcFpuVpuStateSaved
	0x0c : BYTE DpcCurrentProcessType
	0x0d : BYTE QuantumEnd
	0x0e : BYTE TimerRequest
	0x0f : BYTE HvCr0Save
	0x10 : PKTHREAD FpuOwnerThread
	0x14 : PKTHREAD VpuOwnerThread
	0x18 : BYTE CurrentIrql
	0x19 : BYTE BackgroundSchedulingActive
	0x1a : USHORT StartStopBackgroundScheduling
	0x1c : DWORD TimerHand
	0x20 : ULONGLONG LrIarSave
	0x28 : ULONGLONG CrMsrSave
	0x30 : ULONGLONG Gpr13Save
	0x38 : ULONGLONG HvGpr1Save
	0x40 : ULONGLONG HvGpr3Save
	0x48 : ULONGLONG HvGpr4Save
	0x50 : ULONGLONG HvGpr5Save
	0x58 : DWORD UserModeControl
	0x5c : void * PanicStack
	0x60 : DWORD DarSave
	0x64 : DWORD DsisrSave
	0x68 : void * DbgLastDpcRoutine
	0x6c : DWORD OnInterruptStack
	0x70 : void * StackBase
	0x74 : void * StackLimit
	0x78 : void * InterruptStackBase
	0x7c : void * InterruptStackLimit
	0x80 : void * InterruptRoutine[32]
	0x100 : KPCRB PrcbData
	0x2a8 : KPCRB *Prcb
	0x2ac : DWORD ?
	0x2b0 : DWORD *PixCurrent
	0x2b4 : DWORD *PixLimit
	0x2b8 : DWORD *ProfilerCurrent
	0x2bc : DWORD *ProfilerLimit
	0x2c0 : DWORD ProfilerFlags
	0x2c4 : DWORD ?
	0x2c8 : ULONGLONG Contention
	0x2d0 : DWORD * MonitorProfileData

```

`exbox360.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 2013
VisualStudioVersion = 12.0.30219.0
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "exbox360", "make\vs2013\src\exbox360.vcxproj", "{A57B6801-E068-4060-B872-EC06346A62FA}"
	ProjectSection(ProjectDependencies) = postProject
		{A16AAD07-A24D-49A6-9BAC-454FD04DEAD2} = {A16AAD07-A24D-49A6-9BAC-454FD04DEAD2}
		{7DB6DC91-5FBA-45AB-BCB3-F29CEBC4B4B1} = {7DB6DC91-5FBA-45AB-BCB3-F29CEBC4B4B1}
		{385FECCD-F019-4BB9-9705-B8AFAD195C1F} = {385FECCD-F019-4BB9-9705-B8AFAD195C1F}
		{5B33A9EA-9AE8-46DC-9868-727919D6134C} = {5B33A9EA-9AE8-46DC-9868-727919D6134C}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "common", "make\vs2013\src\common\common.vcxproj", "{7DB6DC91-5FBA-45AB-BCB3-F29CEBC4B4B1}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "powerpc", "make\vs2013\src\powerpc\powerpc.vcxproj", "{A16AAD07-A24D-49A6-9BAC-454FD04DEAD2}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "interpreter", "make\vs2013\src\powerpc\interpreter\interpreter.vcxproj", "{385FECCD-F019-4BB9-9705-B8AFAD195C1F}"
	ProjectSection(ProjectDependencies) = postProject
		{A16AAD07-A24D-49A6-9BAC-454FD04DEAD2} = {A16AAD07-A24D-49A6-9BAC-454FD04DEAD2}
		{7DB6DC91-5FBA-45AB-BCB3-F29CEBC4B4B1} = {7DB6DC91-5FBA-45AB-BCB3-F29CEBC4B4B1}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "disassembler", "make\vs2013\src\powerpc\disassembler\disassembler.vcxproj", "{5B33A9EA-9AE8-46DC-9868-727919D6134C}"
	ProjectSection(ProjectDependencies) = postProject
		{A16AAD07-A24D-49A6-9BAC-454FD04DEAD2} = {A16AAD07-A24D-49A6-9BAC-454FD04DEAD2}
		{7DB6DC91-5FBA-45AB-BCB3-F29CEBC4B4B1} = {7DB6DC91-5FBA-45AB-BCB3-F29CEBC4B4B1}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "translator", "make\vs2013\src\powerpc\translator\translator.vcxproj", "{FE64B709-2678-4EA0-98A0-F2E519023888}"
	ProjectSection(ProjectDependencies) = postProject
		{A16AAD07-A24D-49A6-9BAC-454FD04DEAD2} = {A16AAD07-A24D-49A6-9BAC-454FD04DEAD2}
		{7DB6DC91-5FBA-45AB-BCB3-F29CEBC4B4B1} = {7DB6DC91-5FBA-45AB-BCB3-F29CEBC4B4B1}
	EndProjectSection
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "tools", "tools", "{8F6E99CF-AD15-4BAC-B1E9-4E36AD2AA216}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "emugen", "make\vs2013\tools\emugen\emugen.vcxproj", "{98BB0F3D-20E7-4CFA-9328-C60BEE0DC805}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ex360tester", "make\vs2013\tools\ex360tester\ex360tester.vcxproj", "{E4217B0F-FED9-4FD9-9182-5EA0ED31854C}"
	ProjectSection(ProjectDependencies) = postProject
		{A16AAD07-A24D-49A6-9BAC-454FD04DEAD2} = {A16AAD07-A24D-49A6-9BAC-454FD04DEAD2}
		{7DB6DC91-5FBA-45AB-BCB3-F29CEBC4B4B1} = {7DB6DC91-5FBA-45AB-BCB3-F29CEBC4B4B1}
		{385FECCD-F019-4BB9-9705-B8AFAD195C1F} = {385FECCD-F019-4BB9-9705-B8AFAD195C1F}
		{5B33A9EA-9AE8-46DC-9868-727919D6134C} = {5B33A9EA-9AE8-46DC-9868-727919D6134C}
	EndProjectSection
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "kernel", "kernel", "{68FE6F45-18B9-4FFE-8DDB-26B84DB760BC}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "connectx", "make\vs2013\src\kernel\connectx\connectx.vcxproj", "{28895C0F-B2A9-471D-AD4D-9A4D34629FA6}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "createprofile", "make\vs2013\src\kernel\createprofile\createprofile.vcxproj", "{FE3F8B78-1651-4AF0-B696-1BEE01740EB7}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "vk", "make\vs2013\src\kernel\vk\vk.vcxproj", "{606BE718-85E8-45C9-A81B-87F13266FDB0}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "xam", "make\vs2013\src\kernel\xam\xam.vcxproj", "{DF1556DD-5357-45DA-8E1D-6DFED8F3C45C}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "xapi", "make\vs2013\src\kernel\xapi\xapi.vcxproj", "{8CE3EFDE-F280-47B9-88B6-478147665588}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "xbdm", "make\vs2013\src\kernel\xbdm\xbdm.vcxproj", "{B7890D48-359E-40C6-A2FD-3B582DFCFFC2}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "xboxkrnl", "make\vs2013\src\kernel\xboxkrnl\xboxkrnl.vcxproj", "{D5D32B8C-2CA8-46FB-9493-63D77F8B4E44}"
	ProjectSection(ProjectDependencies) = postProject
		{7DB6DC91-5FBA-45AB-BCB3-F29CEBC4B4B1} = {7DB6DC91-5FBA-45AB-BCB3-F29CEBC4B4B1}
	EndProjectSection
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Mixed Platforms = Debug|Mixed Platforms
		Debug|Win32 = Debug|Win32
		Debug|x64 = Debug|x64
		Release|Mixed Platforms = Release|Mixed Platforms
		Release|Win32 = Release|Win32
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{A57B6801-E068-4060-B872-EC06346A62FA}.Debug|Mixed Platforms.ActiveCfg = Debug|x64
		{A57B6801-E068-4060-B872-EC06346A62FA}.Debug|Mixed Platforms.Build.0 = Debug|x64
		{A57B6801-E068-4060-B872-EC06346A62FA}.Debug|Win32.ActiveCfg = Debug|x64
		{A57B6801-E068-4060-B872-EC06346A62FA}.Debug|x64.ActiveCfg = Debug|x64
		{A57B6801-E068-4060-B872-EC06346A62FA}.Debug|x64.Build.0 = Debug|x64
		{A57B6801-E068-4060-B872-EC06346A62FA}.Release|Mixed Platforms.ActiveCfg = Release|x64
		{A57B6801-E068-4060-B872-EC06346A62FA}.Release|Mixed Platforms.Build.0 = Release|x64
		{A57B6801-E068-4060-B872-EC06346A62FA}.Release|Win32.ActiveCfg = Release|x64
		{A57B6801-E068-4060-B872-EC06346A62FA}.Release|x64.ActiveCfg = Release|x64
		{A57B6801-E068-4060-B872-EC06346A62FA}.Release|x64.Build.0 = Release|x64
		{7DB6DC91-5FBA-45AB-BCB3-F29CEBC4B4B1}.Debug|Mixed Platforms.ActiveCfg = Debug|Win32
		{7DB6DC91-5FBA-45AB-BCB3-F29CEBC4B4B1}.Debug|Mixed Platforms.Build.0 = Debug|Win32
		{7DB6DC91-5FBA-45AB-BCB3-F29CEBC4B4B1}.Debug|Win32.ActiveCfg = Debug|Win32
		{7DB6DC91-5FBA-45AB-BCB3-F29CEBC4B4B1}.Debug|Win32.Build.0 = Debug|Win32
		{7DB6DC91-5FBA-45AB-BCB3-F29CEBC4B4B1}.Debug|x64.ActiveCfg = Debug|x64
		{7DB6DC91-5FBA-45AB-BCB3-F29CEBC4B4B1}.Debug|x64.Build.0 = Debug|x64
		{7DB6DC91-5FBA-45AB-BCB3-F29CEBC4B4B1}.Release|Mixed Platforms.ActiveCfg = Release|Win32
		{7DB6DC91-5FBA-45AB-BCB3-F29CEBC4B4B1}.Release|Mixed Platforms.Build.0 = Release|Win32
		{7DB6DC91-5FBA-45AB-BCB3-F29CEBC4B4B1}.Release|Win32.ActiveCfg = Release|Win32
		{7DB6DC91-5FBA-45AB-BCB3-F29CEBC4B4B1}.Release|Win32.Build.0 = Release|Win32
		{7DB6DC91-5FBA-45AB-BCB3-F29CEBC4B4B1}.Release|x64.ActiveCfg = Release|x64
		{7DB6DC91-5FBA-45AB-BCB3-F29CEBC4B4B1}.Release|x64.Build.0 = Release|x64
		{A16AAD07-A24D-49A6-9BAC-454FD04DEAD2}.Debug|Mixed Platforms.ActiveCfg = Debug|x64
		{A16AAD07-A24D-49A6-9BAC-454FD04DEAD2}.Debug|Mixed Platforms.Build.0 = Debug|x64
		{A16AAD07-A24D-49A6-9BAC-454FD04DEAD2}.Debug|Win32.ActiveCfg = Debug|x64
		{A16AAD07-A24D-49A6-9BAC-454FD04DEAD2}.Debug|x64.ActiveCfg = Debug|x64
		{A16AAD07-A24D-49A6-9BAC-454FD04DEAD2}.Debug|x64.Build.0 = Debug|x64
		{A16AAD07-A24D-49A6-9BAC-454FD04DEAD2}.Release|Mixed Platforms.ActiveCfg = Release|x64
		{A16AAD07-A24D-49A6-9BAC-454FD04DEAD2}.Release|Mixed Platforms.Build.0 = Release|x64
		{A16AAD07-A24D-49A6-9BAC-454FD04DEAD2}.Release|Win32.ActiveCfg = Release|x64
		{A16AAD07-A24D-49A6-9BAC-454FD04DEAD2}.Release|x64.ActiveCfg = Release|x64
		{A16AAD07-A24D-49A6-9BAC-454FD04DEAD2}.Release|x64.Build.0 = Release|x64
		{385FECCD-F019-4BB9-9705-B8AFAD195C1F}.Debug|Mixed Platforms.ActiveCfg = Debug|Win32
		{385FECCD-F019-4BB9-9705-B8AFAD195C1F}.Debug|Mixed Platforms.Build.0 = Debug|Win32
		{385FECCD-F019-4BB9-9705-B8AFAD195C1F}.Debug|Win32.ActiveCfg = Debug|Win32
		{385FECCD-F019-4BB9-9705-B8AFAD195C1F}.Debug|Win32.Build.0 = Debug|Win32
		{385FECCD-F019-4BB9-9705-B8AFAD195C1F}.Debug|x64.ActiveCfg = Debug|x64
		{385FECCD-F019-4BB9-9705-B8AFAD195C1F}.Debug|x64.Build.0 = Debug|x64
		{385FECCD-F019-4BB9-9705-B8AFAD195C1F}.Release|Mixed Platforms.ActiveCfg = Release|Win32
		{385FECCD-F019-4BB9-9705-B8AFAD195C1F}.Release|Mixed Platforms.Build.0 = Release|Win32
		{385FECCD-F019-4BB9-9705-B8AFAD195C1F}.Release|Win32.ActiveCfg = Release|Win32
		{385FECCD-F019-4BB9-9705-B8AFAD195C1F}.Release|Win32.Build.0 = Release|Win32
		{385FECCD-F019-4BB9-9705-B8AFAD195C1F}.Release|x64.ActiveCfg = Release|x64
		{385FECCD-F019-4BB9-9705-B8AFAD195C1F}.Release|x64.Build.0 = Release|x64
		{5B33A9EA-9AE8-46DC-9868-727919D6134C}.Debug|Mixed Platforms.ActiveCfg = Debug|Win32
		{5B33A9EA-9AE8-46DC-9868-727919D6134C}.Debug|Mixed Platforms.Build.0 = Debug|Win32
		{5B33A9EA-9AE8-46DC-9868-727919D6134C}.Debug|Win32.ActiveCfg = Debug|Win32
		{5B33A9EA-9AE8-46DC-9868-727919D6134C}.Debug|Win32.Build.0 = Debug|Win32
		{5B33A9EA-9AE8-46DC-9868-727919D6134C}.Debug|x64.ActiveCfg = Debug|x64
		{5B33A9EA-9AE8-46DC-9868-727919D6134C}.Debug|x64.Build.0 = Debug|x64
		{5B33A9EA-9AE8-46DC-9868-727919D6134C}.Release|Mixed Platforms.ActiveCfg = Release|Win32
		{5B33A9EA-9AE8-46DC-9868-727919D6134C}.Release|Mixed Platforms.Build.0 = Release|Win32
		{5B33A9EA-9AE8-46DC-9868-727919D6134C}.Release|Win32.ActiveCfg = Release|Win32
		{5B33A9EA-9AE8-46DC-9868-727919D6134C}.Release|Win32.Build.0 = Release|Win32
		{5B33A9EA-9AE8-46DC-9868-727919D6134C}.Release|x64.ActiveCfg = Release|x64
		{5B33A9EA-9AE8-46DC-9868-727919D6134C}.Release|x64.Build.0 = Release|x64
		{FE64B709-2678-4EA0-98A0-F2E519023888}.Debug|Mixed Platforms.ActiveCfg = Debug|Win32
		{FE64B709-2678-4EA0-98A0-F2E519023888}.Debug|Mixed Platforms.Build.0 = Debug|Win32
		{FE64B709-2678-4EA0-98A0-F2E519023888}.Debug|Win32.ActiveCfg = Debug|Win32
		{FE64B709-2678-4EA0-98A0-F2E519023888}.Debug|Win32.Build.0 = Debug|Win32
		{FE64B709-2678-4EA0-98A0-F2E519023888}.Debug|x64.ActiveCfg = Debug|x64
		{FE64B709-2678-4EA0-98A0-F2E519023888}.Release|Mixed Platforms.ActiveCfg = Release|Win32
		{FE64B709-2678-4EA0-98A0-F2E519023888}.Release|Mixed Platforms.Build.0 = Release|Win32
		{FE64B709-2678-4EA0-98A0-F2E519023888}.Release|Win32.ActiveCfg = Release|Win32
		{FE64B709-2678-4EA0-98A0-F2E519023888}.Release|Win32.Build.0 = Release|Win32
		{FE64B709-2678-4EA0-98A0-F2E519023888}.Release|x64.ActiveCfg = Release|x64
		{98BB0F3D-20E7-4CFA-9328-C60BEE0DC805}.Debug|Mixed Platforms.ActiveCfg = Debug|x64
		{98BB0F3D-20E7-4CFA-9328-C60BEE0DC805}.Debug|Mixed Platforms.Build.0 = Debug|x64
		{98BB0F3D-20E7-4CFA-9328-C60BEE0DC805}.Debug|Win32.ActiveCfg = Debug|x64
		{98BB0F3D-20E7-4CFA-9328-C60BEE0DC805}.Debug|x64.ActiveCfg = Debug|x64
		{98BB0F3D-20E7-4CFA-9328-C60BEE0DC805}.Debug|x64.Build.0 = Debug|x64
		{98BB0F3D-20E7-4CFA-9328-C60BEE0DC805}.Release|Mixed Platforms.ActiveCfg = Release|x64
		{98BB0F3D-20E7-4CFA-9328-C60BEE0DC805}.Release|Mixed Platforms.Build.0 = Release|x64
		{98BB0F3D-20E7-4CFA-9328-C60BEE0DC805}.Release|Win32.ActiveCfg = Release|x64
		{98BB0F3D-20E7-4CFA-9328-C60BEE0DC805}.Release|x64.ActiveCfg = Release|x64
		{98BB0F3D-20E7-4CFA-9328-C60BEE0DC805}.Release|x64.Build.0 = Release|x64
		{E4217B0F-FED9-4FD9-9182-5EA0ED31854C}.Debug|Mixed Platforms.ActiveCfg = Debug|x64
		{E4217B0F-FED9-4FD9-9182-5EA0ED31854C}.Debug|Mixed Platforms.Build.0 = Debug|x64
		{E4217B0F-FED9-4FD9-9182-5EA0ED31854C}.Debug|Win32.ActiveCfg = Debug|x64
		{E4217B0F-FED9-4FD9-9182-5EA0ED31854C}.Debug|x64.ActiveCfg = Debug|x64
		{E4217B0F-FED9-4FD9-9182-5EA0ED31854C}.Debug|x64.Build.0 = Debug|x64
		{E4217B0F-FED9-4FD9-9182-5EA0ED31854C}.Release|Mixed Platforms.ActiveCfg = Release|x64
		{E4217B0F-FED9-4FD9-9182-5EA0ED31854C}.Release|Mixed Platforms.Build.0 = Release|x64
		{E4217B0F-FED9-4FD9-9182-5EA0ED31854C}.Release|Win32.ActiveCfg = Release|x64
		{E4217B0F-FED9-4FD9-9182-5EA0ED31854C}.Release|x64.ActiveCfg = Release|x64
		{E4217B0F-FED9-4FD9-9182-5EA0ED31854C}.Release|x64.Build.0 = Release|x64
		{28895C0F-B2A9-471D-AD4D-9A4D34629FA6}.Debug|Mixed Platforms.ActiveCfg = Debug|x64
		{28895C0F-B2A9-471D-AD4D-9A4D34629FA6}.Debug|Mixed Platforms.Build.0 = Debug|x64
		{28895C0F-B2A9-471D-AD4D-9A4D34629FA6}.Debug|Win32.ActiveCfg = Debug|x64
		{28895C0F-B2A9-471D-AD4D-9A4D34629FA6}.Debug|x64.ActiveCfg = Debug|x64
		{28895C0F-B2A9-471D-AD4D-9A4D34629FA6}.Debug|x64.Build.0 = Debug|x64
		{28895C0F-B2A9-471D-AD4D-9A4D34629FA6}.Release|Mixed Platforms.ActiveCfg = Release|x64
		{28895C0F-B2A9-471D-AD4D-9A4D34629FA6}.Release|Mixed Platforms.Build.0 = Release|x64
		{28895C0F-B2A9-471D-AD4D-9A4D34629FA6}.Release|Win32.ActiveCfg = Release|x64
		{28895C0F-B2A9-471D-AD4D-9A4D34629FA6}.Release|x64.ActiveCfg = Release|x64
		{28895C0F-B2A9-471D-AD4D-9A4D34629FA6}.Release|x64.Build.0 = Release|x64
		{FE3F8B78-1651-4AF0-B696-1BEE01740EB7}.Debug|Mixed Platforms.ActiveCfg = Debug|x64
		{FE3F8B78-1651-4AF0-B696-1BEE01740EB7}.Debug|Mixed Platforms.Build.0 = Debug|x64
		{FE3F8B78-1651-4AF0-B696-1BEE01740EB7}.Debug|Win32.ActiveCfg = Debug|x64
		{FE3F8B78-1651-4AF0-B696-1BEE01740EB7}.Debug|x64.ActiveCfg = Debug|x64
		{FE3F8B78-1651-4AF0-B696-1BEE01740EB7}.Debug|x64.Build.0 = Debug|x64
		{FE3F8B78-1651-4AF0-B696-1BEE01740EB7}.Release|Mixed Platforms.ActiveCfg = Release|x64
		{FE3F8B78-1651-4AF0-B696-1BEE01740EB7}.Release|Mixed Platforms.Build.0 = Release|x64
		{FE3F8B78-1651-4AF0-B696-1BEE01740EB7}.Release|Win32.ActiveCfg = Release|x64
		{FE3F8B78-1651-4AF0-B696-1BEE01740EB7}.Release|x64.ActiveCfg = Release|x64
		{FE3F8B78-1651-4AF0-B696-1BEE01740EB7}.Release|x64.Build.0 = Release|x64
		{606BE718-85E8-45C9-A81B-87F13266FDB0}.Debug|Mixed Platforms.ActiveCfg = Debug|x64
		{606BE718-85E8-45C9-A81B-87F13266FDB0}.Debug|Mixed Platforms.Build.0 = Debug|x64
		{606BE718-85E8-45C9-A81B-87F13266FDB0}.Debug|Win32.ActiveCfg = Debug|x64
		{606BE718-85E8-45C9-A81B-87F13266FDB0}.Debug|x64.ActiveCfg = Debug|x64
		{606BE718-85E8-45C9-A81B-87F13266FDB0}.Debug|x64.Build.0 = Debug|x64
		{606BE718-85E8-45C9-A81B-87F13266FDB0}.Release|Mixed Platforms.ActiveCfg = Release|x64
		{606BE718-85E8-45C9-A81B-87F13266FDB0}.Release|Mixed Platforms.Build.0 = Release|x64
		{606BE718-85E8-45C9-A81B-87F13266FDB0}.Release|Win32.ActiveCfg = Release|x64
		{606BE718-85E8-45C9-A81B-87F13266FDB0}.Release|x64.ActiveCfg = Release|x64
		{606BE718-85E8-45C9-A81B-87F13266FDB0}.Release|x64.Build.0 = Release|x64
		{DF1556DD-5357-45DA-8E1D-6DFED8F3C45C}.Debug|Mixed Platforms.ActiveCfg = Debug|x64
		{DF1556DD-5357-45DA-8E1D-6DFED8F3C45C}.Debug|Mixed Platforms.Build.0 = Debug|x64
		{DF1556DD-5357-45DA-8E1D-6DFED8F3C45C}.Debug|Win32.ActiveCfg = Debug|x64
		{DF1556DD-5357-45DA-8E1D-6DFED8F3C45C}.Debug|x64.ActiveCfg = Debug|x64
		{DF1556DD-5357-45DA-8E1D-6DFED8F3C45C}.Debug|x64.Build.0 = Debug|x64
		{DF1556DD-5357-45DA-8E1D-6DFED8F3C45C}.Release|Mixed Platforms.ActiveCfg = Release|x64
		{DF1556DD-5357-45DA-8E1D-6DFED8F3C45C}.Release|Mixed Platforms.Build.0 = Release|x64
		{DF1556DD-5357-45DA-8E1D-6DFED8F3C45C}.Release|Win32.ActiveCfg = Release|x64
		{DF1556DD-5357-45DA-8E1D-6DFED8F3C45C}.Release|x64.ActiveCfg = Release|x64
		{DF1556DD-5357-45DA-8E1D-6DFED8F3C45C}.Release|x64.Build.0 = Release|x64
		{8CE3EFDE-F280-47B9-88B6-478147665588}.Debug|Mixed Platforms.ActiveCfg = Debug|x64
		{8CE3EFDE-F280-47B9-88B6-478147665588}.Debug|Mixed Platforms.Build.0 = Debug|x64
		{8CE3EFDE-F280-47B9-88B6-478147665588}.Debug|Win32.ActiveCfg = Debug|x64
		{8CE3EFDE-F280-47B9-88B6-478147665588}.Debug|x64.ActiveCfg = Debug|x64
		{8CE3EFDE-F280-47B9-88B6-478147665588}.Debug|x64.Build.0 = Debug|x64
		{8CE3EFDE-F280-47B9-88B6-478147665588}.Release|Mixed Platforms.ActiveCfg = Release|x64
		{8CE3EFDE-F280-47B9-88B6-478147665588}.Release|Mixed Platforms.Build.0 = Release|x64
		{8CE3EFDE-F280-47B9-88B6-478147665588}.Release|Win32.ActiveCfg = Release|x64
		{8CE3EFDE-F280-47B9-88B6-478147665588}.Release|x64.ActiveCfg = Release|x64
		{8CE3EFDE-F280-47B9-88B6-478147665588}.Release|x64.Build.0 = Release|x64
		{B7890D48-359E-40C6-A2FD-3B582DFCFFC2}.Debug|Mixed Platforms.ActiveCfg = Debug|x64
		{B7890D48-359E-40C6-A2FD-3B582DFCFFC2}.Debug|Mixed Platforms.Build.0 = Debug|x64
		{B7890D48-359E-40C6-A2FD-3B582DFCFFC2}.Debug|Win32.ActiveCfg = Debug|x64
		{B7890D48-359E-40C6-A2FD-3B582DFCFFC2}.Debug|x64.ActiveCfg = Debug|x64
		{B7890D48-359E-40C6-A2FD-3B582DFCFFC2}.Debug|x64.Build.0 = Debug|x64
		{B7890D48-359E-40C6-A2FD-3B582DFCFFC2}.Release|Mixed Platforms.ActiveCfg = Release|x64
		{B7890D48-359E-40C6-A2FD-3B582DFCFFC2}.Release|Mixed Platforms.Build.0 = Release|x64
		{B7890D48-359E-40C6-A2FD-3B582DFCFFC2}.Release|Win32.ActiveCfg = Release|x64
		{B7890D48-359E-40C6-A2FD-3B582DFCFFC2}.Release|x64.ActiveCfg = Release|x64
		{B7890D48-359E-40C6-A2FD-3B582DFCFFC2}.Release|x64.Build.0 = Release|x64
		{D5D32B8C-2CA8-46FB-9493-63D77F8B4E44}.Debug|Mixed Platforms.ActiveCfg = Debug|x64
		{D5D32B8C-2CA8-46FB-9493-63D77F8B4E44}.Debug|Mixed Platforms.Build.0 = Debug|x64
		{D5D32B8C-2CA8-46FB-9493-63D77F8B4E44}.Debug|Win32.ActiveCfg = Debug|x64
		{D5D32B8C-2CA8-46FB-9493-63D77F8B4E44}.Debug|x64.ActiveCfg = Debug|x64
		{D5D32B8C-2CA8-46FB-9493-63D77F8B4E44}.Debug|x64.Build.0 = Debug|x64
		{D5D32B8C-2CA8-46FB-9493-63D77F8B4E44}.Release|Mixed Platforms.ActiveCfg = Release|x64
		{D5D32B8C-2CA8-46FB-9493-63D77F8B4E44}.Release|Mixed Platforms.Build.0 = Release|x64
		{D5D32B8C-2CA8-46FB-9493-63D77F8B4E44}.Release|Win32.ActiveCfg = Release|x64
		{D5D32B8C-2CA8-46FB-9493-63D77F8B4E44}.Release|x64.ActiveCfg = Release|x64
		{D5D32B8C-2CA8-46FB-9493-63D77F8B4E44}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(NestedProjects) = preSolution
		{98BB0F3D-20E7-4CFA-9328-C60BEE0DC805} = {8F6E99CF-AD15-4BAC-B1E9-4E36AD2AA216}
		{E4217B0F-FED9-4FD9-9182-5EA0ED31854C} = {8F6E99CF-AD15-4BAC-B1E9-4E36AD2AA216}
		{28895C0F-B2A9-471D-AD4D-9A4D34629FA6} = {68FE6F45-18B9-4FFE-8DDB-26B84DB760BC}
		{FE3F8B78-1651-4AF0-B696-1BEE01740EB7} = {68FE6F45-18B9-4FFE-8DDB-26B84DB760BC}
		{606BE718-85E8-45C9-A81B-87F13266FDB0} = {68FE6F45-18B9-4FFE-8DDB-26B84DB760BC}
		{DF1556DD-5357-45DA-8E1D-6DFED8F3C45C} = {68FE6F45-18B9-4FFE-8DDB-26B84DB760BC}
		{8CE3EFDE-F280-47B9-88B6-478147665588} = {68FE6F45-18B9-4FFE-8DDB-26B84DB760BC}
		{B7890D48-359E-40C6-A2FD-3B582DFCFFC2} = {68FE6F45-18B9-4FFE-8DDB-26B84DB760BC}
		{D5D32B8C-2CA8-46FB-9493-63D77F8B4E44} = {68FE6F45-18B9-4FFE-8DDB-26B84DB760BC}
	EndGlobalSection
EndGlobal

```

`make/vs2013/src/common/common.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\..\..\src\common\bigendian.h" />
    <ClInclude Include="..\..\..\..\src\common\bit_array.h" />
    <ClInclude Include="..\..\..\..\src\common\bit_cast.h" />
    <ClInclude Include="..\..\..\..\src\common\bit_field.h" />
    <ClInclude Include="..\..\..\..\src\common\bit_mask.h" />
    <ClInclude Include="..\..\..\..\src\common\bit_scan.h" />
    <ClInclude Include="..\..\..\..\src\common\bit_swap.h" />
    <ClInclude Include="..\..\..\..\src\common\byte_swap.h" />
    <ClInclude Include="..\..\..\..\src\common\emugen_types.h" />
    <ClInclude Include="..\..\..\..\src\common\endian.h" />
    <ClInclude Include="..\..\..\..\src\common\flags.h" />
    <ClInclude Include="..\..\..\..\src\common\log.h" />
    <ClInclude Include="..\..\..\..\src\common\memory.h" />
    <ClInclude Include="..\..\..\..\src\common\ptr32.h" />
    <ClInclude Include="..\..\..\..\src\common\structmacros.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\..\..\..\src\common\log.cpp" />
    <ClCompile Include="..\..\..\..\src\common\memory.cpp" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{7DB6DC91-5FBA-45AB-BCB3-F29CEBC4B4B1}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>common</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <CallingConvention>FastCall</CallingConvention>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`make/vs2013/src/common/common.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\..\..\src\common\emugen_types.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\src\common\flags.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\src\common\log.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\src\common\memory.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\src\common\structmacros.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\src\common\endian.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\src\common\ptr32.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\src\common\bigendian.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\src\common\bit_cast.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\src\common\bit_field.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\src\common\bit_mask.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\src\common\bit_swap.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\src\common\byte_swap.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\src\common\bit_array.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\src\common\bit_scan.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\..\..\..\src\common\log.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\..\src\common\memory.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`make/vs2013/src/exbox360.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\..\..\src\analyse.cpp" />
    <ClCompile Include="..\..\..\src\kernel.cpp" />
    <ClCompile Include="..\..\..\src\main.cpp" />
    <ClCompile Include="..\..\..\src\system.cpp" />
    <ClCompile Include="..\..\..\src\xex\loader.cpp" />
    <ClCompile Include="..\..\..\src\xex\rijndael-alf-fst.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\..\src\kernel\kernel.h" />
    <ClInclude Include="..\..\..\src\kernel\module.h" />
    <ClInclude Include="..\..\..\src\system.h" />
    <ClInclude Include="..\..\..\src\xex\aes.h" />
    <ClInclude Include="..\..\..\src\xex\biginputstream.h" />
    <ClInclude Include="..\..\..\src\xex\optionalheaders.h" />
    <ClInclude Include="..\..\..\src\xex\rijndael-alg-fst.h" />
    <ClInclude Include="..\..\..\src\xex\xex.h" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{A57B6801-E068-4060-B872-EC06346A62FA}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>exbox360</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(SolutionDir)\src;$(SolutionDir)\lib\prslib;$(IncludePath)</IncludePath>
    <LibraryPath>$(OutDir);$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <CallingConvention>FastCall</CallingConvention>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>common.lib;powerpc.lib;disassembler.lib;interpreter.lib;connectx.lib;createprofile.lib;vk.lib;xam.lib;xapi.lib;xbdm.lib;xboxkrnl.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <FixedBaseAddress>
      </FixedBaseAddress>
      <BaseAddress>0x1000000</BaseAddress>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`make/vs2013/src/exbox360.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Source Files">
      <UniqueIdentifier>{7ffc2926-5d5c-45a6-9153-56dee6270eaf}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\xex">
      <UniqueIdentifier>{6992b13a-0c87-4329-9d66-858d404de78a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\xex">
      <UniqueIdentifier>{7b7cce54-c4e7-4cb9-af54-812ec236691b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\kernel">
      <UniqueIdentifier>{1f597280-ae65-45f8-8390-80825b2c3395}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\..\..\src\analyse.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\src\kernel.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\src\main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\src\system.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\src\xex\loader.cpp">
      <Filter>Source Files\xex</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\src\xex\rijndael-alf-fst.cpp">
      <Filter>Source Files\xex</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\..\src\system.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\src\xex\aes.h">
      <Filter>Header Files\xex</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\src\xex\biginputstream.h">
      <Filter>Header Files\xex</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\src\xex\optionalheaders.h">
      <Filter>Header Files\xex</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\src\xex\rijndael-alg-fst.h">
      <Filter>Header Files\xex</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\src\xex\xex.h">
      <Filter>Header Files\xex</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\src\kernel\kernel.h">
      <Filter>Header Files\kernel</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\src\kernel\module.h">
      <Filter>Header Files\kernel</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`make/vs2013/src/kernel/connectx/connectx.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{28895C0F-B2A9-471D-AD4D-9A4D34629FA6}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>connectx</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(SolutionDir)\src;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;CONNECTX_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <CallingConvention>FastCall</CallingConvention>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;CONNECTX_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="..\..\..\..\..\src\kernel\connectx\connectx.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\..\..\..\..\src\kernel\connectx\connectx.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`make/vs2013/src/kernel/connectx/connectx.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\..\..\..\src\kernel\connectx\connectx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\..\..\..\..\src\kernel\connectx\connectx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`make/vs2013/src/kernel/createprofile/createprofile.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{FE3F8B78-1651-4AF0-B696-1BEE01740EB7}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>createprofile</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(SolutionDir)\src;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;CREATEPROFILE_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <CallingConvention>FastCall</CallingConvention>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;CREATEPROFILE_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="..\..\..\..\..\src\kernel\createprofile\createprofile.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\..\..\..\..\src\kernel\createprofile\createprofile.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`make/vs2013/src/kernel/createprofile/createprofile.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\..\..\..\src\kernel\createprofile\createprofile.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\..\..\..\..\src\kernel\createprofile\createprofile.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`make/vs2013/src/kernel/vk/vk.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{606BE718-85E8-45C9-A81B-87F13266FDB0}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>vk</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(SolutionDir)\src;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;VK_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <CallingConvention>FastCall</CallingConvention>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;VK_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="..\..\..\..\..\src\kernel\vk\vk.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\..\..\..\..\src\kernel\vk\vk.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`make/vs2013/src/kernel/vk/vk.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\..\..\..\src\kernel\vk\vk.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\..\..\..\..\src\kernel\vk\vk.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`make/vs2013/src/kernel/xam/xam.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{DF1556DD-5357-45DA-8E1D-6DFED8F3C45C}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>xam</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(SolutionDir)\src;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;XAM_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <CallingConvention>FastCall</CallingConvention>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ModuleDefinitionFile>$(SolutionDir)\src\kernel\xam\xam.def</ModuleDefinitionFile>
      <BaseAddress>0x50000000</BaseAddress>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;XAM_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <None Include="..\..\..\..\..\src\kernel\xam\xam.def" />
    <None Include="..\..\..\..\..\src\kernel\xam\xam.krn" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\..\..\..\src\kernel\xam\xam.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\..\..\..\..\src\kernel\xam\xam.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`make/vs2013/src/kernel/xam/xam.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <None Include="..\..\..\..\..\src\kernel\xam\xam.def">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="..\..\..\..\..\src\kernel\xam\xam.krn">
      <Filter>Resource Files</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\..\..\..\src\kernel\xam\xam.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\..\..\..\..\src\kernel\xam\xam.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`make/vs2013/src/kernel/xapi/xapi.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{8CE3EFDE-F280-47B9-88B6-478147665588}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>xapi</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(SolutionDir)\src;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;XAPI_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <CallingConvention>FastCall</CallingConvention>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;XAPI_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="..\..\..\..\..\src\kernel\xapi\xapi.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\..\..\..\..\src\kernel\xapi\xapi.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`make/vs2013/src/kernel/xapi/xapi.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\..\..\..\src\kernel\xapi\xapi.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\..\..\..\..\src\kernel\xapi\xapi.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`make/vs2013/src/kernel/xbdm/xbdm.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{B7890D48-359E-40C6-A2FD-3B582DFCFFC2}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>xbdm</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(SolutionDir)\src;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;XBDM_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <CallingConvention>FastCall</CallingConvention>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;XBDM_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="..\..\..\..\..\src\kernel\xbdm\xbdm.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\..\..\..\..\src\kernel\xbdm\xbdm.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`make/vs2013/src/kernel/xbdm/xbdm.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\..\..\..\src\kernel\xbdm\xbdm.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\..\..\..\..\src\kernel\xbdm\xbdm.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`make/vs2013/src/kernel/xboxkrnl/object.cpp`:

```cpp
#include "kernel/xboxkrnl/object.h"
#include "kernel/xboxkrnl/event.h"

Object *
InitializeObject(KDispatcherHeader *header)
{
   switch (header->Type) {
   case EventNotificationObject:
      return new Event(Event::ManualReset, !!header->SignalState);
   case EventSynchronizationObject:
      return new Event(Event::AutoReset, !!header->SignalState);
   default:
      assert(0);
      return nullptr;
   }
}

Object *
GetKernelObject(void *object)
{
   KDispatcherHeader *header = reinterpret_cast<KDispatcherHeader*>(object);

   if (header->WaitList.object == nullptr) {
      return InitializeObject(header);
   } else {
      return header->WaitList.object;
   }
}

KBOOL
KeSetEvent(ptr32_t<KEvent> event,
           uint32_t increment,
           uint32_t wait)
{
   auto object = GetKernelObject(event.getPointer());

   assert(object->getType() == Object::Event);

   return reinterpret_cast<Event*>(object)->set();
}

KSTATUS
KeWaitForSingleObject(ptr32_t<void> Object,
                      uint32_t WaitReason,
                      uint32_t WaitMode,
                      uint32_t Alertable,
                      ptr32_t<uint64_t> Timeout)
{
   uint64_t timeoutTicks = 0;

   if (Timeout) {
      timeoutTicks = *Timeout;
   }

   assert(timeoutTicks == 0);

   auto kernelObject = GetKernelObject(Object.getPointer());
   auto waitable = kernelObject->getWaitable();
   auto status = waitable->wait(0);

   switch (status) {
   case Waitable::Timeout:
      return KSTATUS_TIMEOUT;
   case Waitable::Failure:
      return KSTATUS_ABANDONED_WAIT;
   default:
      return KSTATUS_SUCCESS;
   }
}

```

`make/vs2013/src/kernel/xboxkrnl/xboxkrnl.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{D5D32B8C-2CA8-46FB-9493-63D77F8B4E44}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>xboxkrnl</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(SolutionDir)\src;$(IncludePath)</IncludePath>
    <LibraryPath>$(OutDir);$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;XBOXKRNL_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <CallingConvention>FastCall</CallingConvention>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>common.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ModuleDefinitionFile>$(SolutionDir)\src\kernel\xboxkrnl\xboxkrnl.def</ModuleDefinitionFile>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <FixedBaseAddress>
      </FixedBaseAddress>
      <BaseAddress>0x60000000</BaseAddress>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;XBOXKRNL_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\..\..\..\..\src\kernel\xboxkrnl\debug.cpp" />
    <ClCompile Include="..\..\..\..\..\src\kernel\xboxkrnl\version.cpp" />
    <ClCompile Include="..\..\..\..\..\src\kernel\xboxkrnl\virtualmemory.cpp" />
    <ClCompile Include="..\..\..\..\..\src\kernel\xboxkrnl\criticalsection.cpp" />
    <ClCompile Include="..\..\..\..\..\src\kernel\xboxkrnl\process.cpp" />
    <ClCompile Include="..\..\..\..\..\src\kernel\xboxkrnl\spinlock.cpp" />
    <ClCompile Include="..\..\..\..\..\src\kernel\xboxkrnl\thread.cpp" />
    <ClCompile Include="..\..\..\..\..\src\kernel\xboxkrnl\tls.cpp" />
    <ClCompile Include="..\..\..\..\..\src\kernel\xboxkrnl\hardware.cpp" />
    <ClCompile Include="..\..\..\..\..\src\kernel\xboxkrnl\xboxkrnl.cpp" />
    <ClCompile Include="..\..\..\..\..\src\kernel\xboxkrnl\xex.cpp" />
    <ClCompile Include="object.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\..\..\..\src\kernel\xboxkrnl\debug.h" />
    <ClInclude Include="..\..\..\..\..\src\kernel\xboxkrnl\event.h" />
    <ClInclude Include="..\..\..\..\..\src\kernel\xboxkrnl\ntstructs.h" />
    <ClInclude Include="..\..\..\..\..\src\kernel\xboxkrnl\object.h" />
    <ClInclude Include="..\..\..\..\..\src\kernel\xboxkrnl\version.h" />
    <ClInclude Include="..\..\..\..\..\src\kernel\xboxkrnl\virtualmemory.h" />
    <ClInclude Include="..\..\..\..\..\src\kernel\xboxkrnl\criticalsection.h" />
    <ClInclude Include="..\..\..\..\..\src\kernel\xboxkrnl\process.h" />
    <ClInclude Include="..\..\..\..\..\src\kernel\xboxkrnl\spinlock.h" />
    <ClInclude Include="..\..\..\..\..\src\kernel\xboxkrnl\thread.h" />
    <ClInclude Include="..\..\..\..\..\src\kernel\xboxkrnl\tls.h" />
    <ClInclude Include="..\..\..\..\..\src\kernel\xboxkrnl\hardware.h" />
    <ClInclude Include="..\..\..\..\..\src\kernel\xboxkrnl\xboxkrnl.h" />
    <ClInclude Include="..\..\..\..\..\src\kernel\xboxkrnl\xex.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`make/vs2013/src/kernel/xboxkrnl/xboxkrnl.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\..\..\..\..\src\kernel\xboxkrnl\thread.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\..\..\src\kernel\xboxkrnl\xboxkrnl.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\..\..\src\kernel\xboxkrnl\xex.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\..\..\src\kernel\xboxkrnl\spinlock.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\..\..\src\kernel\xboxkrnl\tls.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\..\..\src\kernel\xboxkrnl\criticalsection.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\..\..\src\kernel\xboxkrnl\process.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\..\..\src\kernel\xboxkrnl\debug.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\..\..\src\kernel\xboxkrnl\virtualmemory.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\..\..\src\kernel\xboxkrnl\version.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\..\..\src\kernel\xboxkrnl\hardware.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="object.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\..\..\..\src\kernel\xboxkrnl\thread.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\..\src\kernel\xboxkrnl\xboxkrnl.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\..\src\kernel\xboxkrnl\xex.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\..\src\kernel\xboxkrnl\spinlock.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\..\src\kernel\xboxkrnl\tls.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\..\src\kernel\xboxkrnl\criticalsection.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\..\src\kernel\xboxkrnl\process.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\..\src\kernel\xboxkrnl\debug.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\..\src\kernel\xboxkrnl\virtualmemory.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\..\src\kernel\xboxkrnl\version.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\..\src\kernel\xboxkrnl\hardware.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\..\src\kernel\xboxkrnl\ntstructs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\..\src\kernel\xboxkrnl\object.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\..\src\kernel\xboxkrnl\event.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`make/vs2013/src/powerpc/disassembler/disassembler.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\..\..\..\..\src\powerpc\disassembler\disassembler.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\..\..\..\src\powerpc\disassembler\disassembler.h" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{5B33A9EA-9AE8-46DC-9868-727919D6134C}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>disassembler</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <IncludePath>$(SolutionDir)\src;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <CallingConvention>FastCall</CallingConvention>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`make/vs2013/src/powerpc/disassembler/disassembler.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\..\..\..\..\src\powerpc\disassembler\disassembler.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\..\..\..\src\powerpc\disassembler\disassembler.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`make/vs2013/src/powerpc/interpreter/interpreter.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\..\..\..\..\src\powerpc\interpreter\alu.cpp" />
    <ClCompile Include="..\..\..\..\..\src\powerpc\interpreter\cpu.cpp" />
    <ClCompile Include="..\..\..\..\..\src\powerpc\interpreter\flow.cpp" />
    <ClCompile Include="..\..\..\..\..\src\powerpc\interpreter\fpu.cpp" />
    <ClCompile Include="..\..\..\..\..\src\powerpc\interpreter\interpreter.cpp" />
    <ClCompile Include="..\..\..\..\..\src\powerpc\interpreter\kernel.cpp" />
    <ClCompile Include="..\..\..\..\..\src\powerpc\interpreter\load.cpp" />
    <ClCompile Include="..\..\..\..\..\src\powerpc\interpreter\mmu.cpp" />
    <ClCompile Include="..\..\..\..\..\src\powerpc\interpreter\store.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\..\..\..\src\powerpc\interpreter\regs.h" />
    <ClInclude Include="..\..\..\..\..\src\powerpc\interpreter\fpu.h" />
    <ClInclude Include="..\..\..\..\..\src\powerpc\interpreter\interpreter.h" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{385FECCD-F019-4BB9-9705-B8AFAD195C1F}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>interpreter</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <IncludePath>$(SolutionDir)\src;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <CallingConvention>FastCall</CallingConvention>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`make/vs2013/src/powerpc/interpreter/interpreter.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\..\..\..\..\src\powerpc\interpreter\alu.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\..\..\src\powerpc\interpreter\cpu.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\..\..\src\powerpc\interpreter\flow.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\..\..\src\powerpc\interpreter\fpu.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\..\..\src\powerpc\interpreter\interpreter.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\..\..\src\powerpc\interpreter\kernel.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\..\..\src\powerpc\interpreter\load.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\..\..\src\powerpc\interpreter\mmu.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\..\..\src\powerpc\interpreter\store.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\..\..\..\src\powerpc\interpreter\fpu.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\..\src\powerpc\interpreter\interpreter.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\..\src\powerpc\interpreter\regs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`make/vs2013/src/powerpc/powerpc.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\..\..\src\powerpc\cpu.h" />
    <ClInclude Include="..\..\..\..\src\powerpc\decoder.h" />
    <ClInclude Include="..\..\..\..\src\powerpc\emugen_cpu_info.h" />
    <ClInclude Include="..\..\..\..\src\powerpc\emugen_decoder.h" />
    <ClInclude Include="..\..\..\..\src\powerpc\emugen_instructionid.h" />
    <ClInclude Include="..\..\..\..\src\powerpc\emugen_instructions.h" />
    <ClInclude Include="..\..\..\..\src\powerpc\emugen_stubs.h" />
    <ClInclude Include="..\..\..\..\src\powerpc\emugen_table.h" />
    <ClInclude Include="..\..\..\..\src\powerpc\instructions.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\..\..\..\src\powerpc\decoder.cpp" />
    <ClCompile Include="..\..\..\..\src\powerpc\instructions.cpp" />
  </ItemGroup>
  <ItemGroup>
    <Text Include="..\..\..\..\src\powerpc\emugen.txt" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{A16AAD07-A24D-49A6-9BAC-454FD04DEAD2}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>powerpc</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <IncludePath>$(SolutionDir)\src;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <CallingConvention>FastCall</CallingConvention>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`make/vs2013/src/powerpc/powerpc.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Generated Files">
      <UniqueIdentifier>{0779ce0c-452c-4ff9-b829-af636d8828f0}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\..\..\src\powerpc\cpu.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\src\powerpc\decoder.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\src\powerpc\instructions.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\src\powerpc\emugen_cpu_info.h">
      <Filter>Generated Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\src\powerpc\emugen_decoder.h">
      <Filter>Generated Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\src\powerpc\emugen_instructionid.h">
      <Filter>Generated Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\src\powerpc\emugen_instructions.h">
      <Filter>Generated Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\src\powerpc\emugen_stubs.h">
      <Filter>Generated Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\src\powerpc\emugen_table.h">
      <Filter>Generated Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\..\..\..\src\powerpc\decoder.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\..\src\powerpc\instructions.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <Text Include="..\..\..\..\src\powerpc\emugen.txt">
      <Filter>Resource Files</Filter>
    </Text>
  </ItemGroup>
</Project>
```

`make/vs2013/src/powerpc/translator/translator.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\..\..\..\..\src\powerpc\translator\alu.cpp" />
    <ClCompile Include="..\..\..\..\..\src\powerpc\translator\stubs.cpp" />
    <ClCompile Include="..\..\..\..\..\src\powerpc\translator\translator.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\..\..\..\src\powerpc\translator\translator.h" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{FE64B709-2678-4EA0-98A0-F2E519023888}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>translator</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <IncludePath>$(SolutionDir)\src;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <CallingConvention>FastCall</CallingConvention>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`make/vs2013/src/powerpc/translator/translator.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\..\..\..\..\src\powerpc\translator\alu.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\..\..\src\powerpc\translator\stubs.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\..\..\src\powerpc\translator\translator.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\..\..\..\src\powerpc\translator\translator.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`make/vs2013/tools/emugen/emugen.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{98BB0F3D-20E7-4CFA-9328-C60BEE0DC805}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>emugen</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(SolutionDir)\lib\prslib;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <CallingConvention>Cdecl</CallingConvention>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="..\..\..\..\tools\emugen\ast.h" />
    <ClInclude Include="..\..\..\..\tools\emugen\emugen.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\..\..\..\tools\emugen\emugen.cpp" />
    <ClCompile Include="..\..\..\..\tools\emugen\main.cpp" />
    <ClCompile Include="..\..\..\..\tools\emugen\parser.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`make/vs2013/tools/emugen/emugen.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\..\..\tools\emugen\ast.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\tools\emugen\emugen.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\..\..\..\tools\emugen\emugen.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\..\tools\emugen\main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\..\tools\emugen\parser.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`make/vs2013/tools/ex360tester/ex360tester.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{E4217B0F-FED9-4FD9-9182-5EA0ED31854C}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>ex360tester</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(SolutionDir)\src;$(SolutionDir)\lib\prslib;$(IncludePath)</IncludePath>
    <LibraryPath>$(OutDir);$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <CallingConvention>FastCall</CallingConvention>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>common.lib;powerpc.lib;disassembler.lib;interpreter.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="..\..\..\..\tools\ex360tester\elf.h" />
    <ClInclude Include="..\..\..\..\tools\ex360tester\parser.h" />
    <ClInclude Include="..\..\..\..\tools\ex360tester\test.h" />
    <ClInclude Include="..\..\..\..\tools\ex360tester\tester.h" />
    <ClInclude Include="..\..\..\..\tools\ex360tester\xenon.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\..\..\..\tools\ex360tester\main.cpp" />
    <ClCompile Include="..\..\..\..\tools\ex360tester\parser.cpp" />
    <ClCompile Include="..\..\..\..\tools\ex360tester\test.cpp" />
    <ClCompile Include="..\..\..\..\tools\ex360tester\tester.cpp" />
    <ClCompile Include="..\..\..\..\tools\ex360tester\xenon.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`make/vs2013/tools/ex360tester/ex360tester.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\..\..\tools\ex360tester\elf.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\tools\ex360tester\parser.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\tools\ex360tester\test.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\tools\ex360tester\tester.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\..\tools\ex360tester\xenon.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\..\..\..\tools\ex360tester\main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\..\tools\ex360tester\parser.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\..\tools\ex360tester\test.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\..\tools\ex360tester\tester.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\..\tools\ex360tester\xenon.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`src/analyse.cpp`:

```cpp
#include "system.h"

#include "common/memory.h"
#include "common/endian.h"
#include "common/log.h"

#include "powerpc/cpu.h"
#include "powerpc/instructions.h"
#include "powerpc/disassembler/disassembler.h"

#include <set>
#include <fstream>
#include <algorithm>

/* Returns true if instruction is a BasicBlock terminator */
bool isTerminator(ppc::Instruction instr)
{
   return
      instr.lk == 0 &&
      (
         ppc::isa<ppc::InstructionID::b>(instr) ||
         ppc::isa<ppc::InstructionID::bc>(instr) ||
         ppc::isa<ppc::InstructionID::bcctr>(instr) ||
         ppc::isa<ppc::InstructionID::bclr>(instr)
      );
}

/* Returns true if instruction is a conditional branch */
bool isConditionalBranch(ppc::Instruction instr)
{
   bool cond_ok = (instr.bo & (1 << 4)) != 0;
   bool ctr_ok  = (instr.bo & (1 << 2)) != 0;

   if (ppc::isa<ppc::InstructionID::bc>(instr)) {
      return !cond_ok || !ctr_ok;
   }

   if (ppc::isa<ppc::InstructionID::bcctr>(instr)) {
      return !cond_ok;
   }

   if (ppc::isa<ppc::InstructionID::bclr>(instr)) {
      return !cond_ok || !ctr_ok;
   }

   return false;
}

/* Return the branch target address */
uint64_t getBranchAddress(uint64_t cia, ppc::Instruction instr)
{
   if (ppc::isa<ppc::InstructionID::b>(instr)) {
      if (instr.aa) {
         return le_bit_accessor::signExtend<26>(static_cast<uint64_t>(instr.li) << 2);
      } else {
         return cia + le_bit_accessor::signExtend<26>(static_cast<uint64_t>(instr.li) << 2);
      }
   }

   if (ppc::isa<ppc::InstructionID::bc>(instr)) {
      if (instr.aa) {
         return le_bit_accessor::signExtend<16>(static_cast<uint64_t>(instr.bd) << 2);
      } else {
         return cia + le_bit_accessor::signExtend<16>(static_cast<uint64_t>(instr.bd) << 2);
      }
   }

   if (ppc::isa<ppc::InstructionID::bcctr>(instr)) {
      /* UNKNOWN */
   }

   if (ppc::isa<ppc::InstructionID::bclr>(instr)) {
      /* UNKNOWN */
   }

   return 0;
}

struct BasicBlock
{
   uint64_t start;
   uint64_t end;
   std::vector<uint64_t> successors;
};

BasicBlock getBasicBlock(uint64_t start, uint64_t end = 0)
{
   BasicBlock bb;
   uint64_t pos, target;

   pos = start;
   bb.start = start;

   while (true) {
      ppc::Instruction instr;

      instr.value = Memory::read<uint32_t>(pos);

      if (isTerminator(instr) || pos == end) {
         bb.end = pos;

         if (target = getBranchAddress(pos, instr)) {
            bb.successors.push_back(target);
         }

         if (isConditionalBranch(instr)) {
            bb.successors.push_back(pos + 4);
         }
         
         if (pos == end) {
            bb.successors.push_back(pos + 4);
         }

         if (isConditionalBranch(instr) && bb.successors.size() == 1) {
            //fuck this hype
            bb.successors.clear();
         } else {
            break;
         }
      }

      pos += 4;
   }

   return bb;
}

struct Function
{
   uint64_t start;
   uint64_t end;
   std::vector<BasicBlock> blocks;
};

bool System::analyse(uint64_t start)
{
   std::vector<uint64_t> visited;
   std::set<uint64_t> targets;
   Function func;

   func.start = start;
   func.end = start;

   targets.insert(func.start);

   while (targets.size()) {
      auto target = *targets.begin();

      if (target > func.end + 4) {
         //FUK U?
      }

      targets.erase(targets.begin());
      
      if (std::find(visited.begin(), visited.end(), target) != visited.end()) {
         continue;
      }

      BasicBlock bb = getBasicBlock(target);

      if (bb.end > func.end) {
         func.end = bb.end;
      }
      
      for (auto succ : bb.successors) {
         /* If before function then its a call */
         if (succ < start) {
            continue;
         }

         /* If after function ... how do we find end? */
         /* If there is a gap in the code! */
         /* Unfortunately we cannot do that until we have "discovered" ALL basic blocks */
         /* Also dynamic switches might fuck it up? */

         targets.insert(succ);
      }

      visited.push_back(target);
      func.blocks.push_back(bb);
   }

   for (auto &block : func.blocks) {
      for (auto &other : func.blocks) {
         if (&block == &other) {
            continue;
         }

         if (block.start >= other.start && block.start <= other.end) {
            other.end = block.start - 4;
            other.successors.clear();
            other.successors.push_back(block.start);
         }
      }
   }

   xDebug() << "FUNCTION " << Log::hex(func.start);
   
   for (auto &block : func.blocks) {
      xDebug() << "BLOCK START " << Log::hex(block.start);

      for (auto cia = block.start; cia <= block.end; cia += 4) {
         ppc::Disassembler::State dis;
         dis.cia = cia;
         ppc::Disassembler::decode(&dis, { Memory::read<uint32_t>(cia) });
         xDebug() << "  " << dis.result.disasm;
      }

      xDebug() << "BLOCK END " << Log::hex(block.end);
   }

   std::fstream out;

   out.open("test.dot", std::fstream::out);

   if (!out.is_open()) {
      std::cout << "Could not open dot graph for writing" << std::endl;
      return false;
   }

   for (auto &block : func.blocks) {
      out << '"';

      if (block.start == func.start) {
         out << "sub_";
      } else {
         out << "loc_";
      }

      out << std::hex << block.start;
      out << '"';

      out << " [ ";
      out << "label = \"";

      for (auto cia = block.start; cia <= block.end; cia += 4) {
         ppc::Disassembler::State dis;
         dis.cia = cia;
         ppc::Disassembler::decode(&dis, { Memory::read<uint32_t>(cia) });

         if (cia != block.start) {
            out << "\\n";
         }

         out << dis.result.disasm;
      }

      out << "\"";
      out << " ];" << std::endl;
   }

   for (auto &block : func.blocks) {
      for (auto &succ : block.successors) {
         if (std::find_if(func.blocks.begin(), func.blocks.end(), [&succ](BasicBlock &bb){ return bb.start == succ; }) == func.blocks.end()) {
            continue;
         }

         out << '"';
         if (block.start == func.start) {
            out << "sub_";
         } else {
            out << "loc_";
         }

         out << std::hex << block.start;
         out << '"';

         out << " -> ";

         out << '"';
         if (succ == func.start) {
            out << "sub_";
         } else {
            out << "loc_";
         }

         out << std::hex << succ;
         out << "\";" << std::endl;
      }
   }

   out.close();

   return true;
}

```

`src/common/bigendian.h`:

```h
#ifndef BIG_ENDIAN_H
#define BIG_ENDIAN_H

#include <stdint.h>

#include "ptr32.h"
#include "byte_swap.h"

// Type which is stored in big endian, but accessed in little endian
template<typename Type>
class be_t
{
public:
   be_t()
   {
   }

   be_t(Type value)
   {
      setValue(value);
   }

   Type getValue() const
   {
      return byte_swap(mValue);
   }

   void setValue(Type value)
   {
      mValue = byte_swap(value);
   }

   operator Type() const
   {
      return getValue();
   }

   be_t<Type> &operator =(Type value)
   {
      setValue(value);
      return *this;
   }

   be_t<Type> &operator ++()
   {
      setValue(getValue() + 1);
      return *this;
   }

private:
   Type mValue;
};

// Some common BigEndian types
using be_int8_t = be_t<int8_t>;
using be_int16_t = be_t<int16_t>;
using be_int32_t = be_t<int32_t>;
using be_int64_t = be_t<int64_t>;

using be_uint8_t = be_t<uint8_t>;
using be_uint16_t = be_t<uint16_t>;
using be_uint32_t = be_t<uint32_t>;
using be_uint64_t = be_t<uint64_t>;

// A BigEndian pointer to Type
template<typename Type>
using be_ptr32_t = ptr32_t<Type, be_t<uint32_t>>;

#endif // BIG_ENDIAN_H

```

`src/common/bit_array.h`:

```h
#ifndef BIT_ARRAY_H
#define BIT_ARRAY_H

#include "bit_field.h"
#include "endian.h"

template<typename Type, unsigned FieldWidth, unsigned Endian = LittleEndian>
class bit_array_t
{
public:
   bit_array_t()
   {
   }

   bit_array_t(Type value) :
      mValue(value)
   {
   }

   unsigned getFieldStart(unsigned index) const
   {
      return index * FieldWidth;
   }

   unsigned getFieldEnd(unsigned index) const
   {
      return (index * FieldWidth) + FieldWidth - 1;
   }

   unsigned getFieldWidth() const
   {
      return FieldWidth;
   }

   dyn_bit_field_t<Type> getField(unsigned index)
   {
      return bit_accessor_t<Endian>::make_bit_field(mValue,
                                                    getFieldStart(index),
                                                    getFieldEnd(index));
   }

   dyn_bit_field_t<Type> operator[](unsigned index)
   {
      return getField(index);
   }

private:
   Type mValue;
};

#endif // BIT_ARRAY_H

```

`src/common/bit_cast.h`:

```h
#ifndef BIT_CAST_H
#define BIT_CAST_H

// reinterpret_cast for value types
template<typename SrcType, typename DstType>
static inline DstType
bit_cast(SrcType src)
{
   union
   {
      SrcType src;
      DstType dst;
   } type_caster;

   static_assert(sizeof(SrcType) == sizeof(DstType),
                 "bit_cast must be between same sized types");

   type_caster.src = src;
   return type_caster.dst;
}

#endif // BIT_CAST_H

```

`src/common/bit_field.h`:

```h
#ifndef BIT_FIELD_H
#define BIT_FIELD_H

#include "bit_mask.h"

// Bit Field with compile time First and Last values
template<typename Type, unsigned First, unsigned Last>
class bit_field_t
{
   static const int Size = Last - First + 1;

public:
   bit_field_t(Type &src) :
      mBitField(src)
   {
   }

   unsigned getFirst() const
   {
      return First;
   }

   unsigned getSize() const
   {
      return Size;
   }

   unsigned getLast() const
   {
      return Last;
   }

   Type getValue() const
   {
      return (mBitField >> First)
         & bit_mask_t<Type, Size>::value;
   }

   void setValue(Type value)
   {
      const Type mask = bit_mask_t<Type, Size>::value;
      mBitField &= ~(mask << First);
      mBitField |= (value & mask) << First;
   }

   operator Type() const
   {
      return getValue();
   }

   bit_field_t<Type, First, Last> operator =(Type value)
   {
      setValue(value);
      return *this;
   }

private:
   Type &mBitField;
};

// Bit Field with run time First and Last values
template<typename Type>
class bit_field_t<Type, -1, -1>
{
public:
   bit_field_t(Type &src, unsigned first, unsigned last) :
      mBitField(src),
      mFirst(first),
      mLast(last)
   {
   }

   unsigned getFirst() const
   {
      return mFirst;
   }

   unsigned getSize() const
   {
      return mLast - mFirst + 1;
   }

   unsigned getLast() const
   {
      return mLast;
   }

   Type getValue() const
   {
      return (mBitField >> mFirst) & bit_mask<Type>(getSize());
   }

   void setValue(Type value)
   {
      const Type mask = bit_mask<Type>(getSize());
      mBitField &= ~(mask << mFirst);
      mBitField |= (value & mask) << mFirst;
   }

   operator Type() const
   {
      return getValue();
   }

   bit_field_t<Type, -1, -1> operator =(Type value)
   {
      setValue(value);
      return *this;
   }

private:
   Type &mBitField;
   unsigned mFirst;
   unsigned mLast;
};


template<typename Type>
using dyn_bit_field_t = bit_field_t<Type, -1, -1>;

#endif // BITFIELD_H

```

`src/common/bit_mask.h`:

```h
#ifndef BIT_MASK_H
#define BIT_MASK_H

// Compile-time bitmask
template<typename Type, unsigned Size, unsigned Offset = 0>
struct bit_mask_t
{
   // Computes correct value even if Size == sizeof(Type) * 8
   static const Type value = ((((static_cast<Type>(1) << (Size - 1)) - 1) << 1) | 1) << Offset;
};

// Run-time bit mask
template<typename Type>
Type bit_mask(unsigned size, unsigned offset = 0)
{
   return ((static_cast<Type>(1) << size) - 1) << offset;
}

#endif // BIT_MASK_H

```

`src/common/bit_scan.h`:

```h
#ifndef BIT_SCAN_H
#define BIT_SCAN_H

#include <stdint.h>
#include <intrin.h>

template<typename Type>
static inline unsigned bitScanReverse(Type value);

template<typename Type>
static inline unsigned bitScanForward(Type value);

template<>
static inline unsigned bitScanReverse<uint32_t>(uint32_t value)
{
   unsigned long index;

   if (!_BitScanReverse(&index, value)) {
      return 32;
   } else {
      return index;
   }
}

template<>
static inline unsigned bitScanReverse<uint64_t>(uint64_t value)
{
   unsigned long index;

   if (!_BitScanReverse64(&index, value)) {
      return 64;
   } else {
      return index;
   }
}

template<>
static inline unsigned bitScanForward<uint32_t>(uint32_t value)
{
   unsigned long index;

   if (!_BitScanForward(&index, value)) {
      return 32;
   } else {
      return index;
   }
}

template<>
static inline unsigned bitScanForward<uint64_t>(uint64_t value)
{
   unsigned long index;

   if (!_BitScanForward64(&index, value)) {
      return 64;
   } else {
      return index;
   }
}

#endif

```

`src/common/bit_swap.h`:

```h
#ifndef BIT_SWAP_H
#define BIT_SWAP_H

#include <stdint.h>

// Compile-time get bit position in opposite endian
// e.g. for uint32_t 31 <=> 0 and 15 <=> 16
template<typename Type, unsigned Bit>
struct bit_swap_t
{
   static const int value = sizeof(Type) * 8 - Bit - 1;
};

static_assert(bit_swap_t<uint32_t, 31>::value == 0,
              "bit_swapper<uint32_t, 31> != 0");

static_assert(bit_swap_t<uint32_t, 15>::value == 16,
              "bit_swapper<uint32_t, 15> != 16");

// Get bit position in opposite endian
template<typename Type>
unsigned bit_swap(unsigned bit)
{
   return sizeof(Type) * 8 - bit - 1;
}

#endif // BIT_SWAP_H

```

`src/common/byte_swap.h`:

```h
#ifndef BYTE_SWAP_H
#define BYTE_SWAP_H

#include <stdint.h>
#include "bit_cast.h"

// Utility class to swap endian for types of size 1, 2, 4, 8
// other type sizes are not supported
template<typename Type, unsigned Size = sizeof(Type)>
struct byte_swap_t;

template<typename Type>
struct byte_swap_t<Type, 1>
{
   static Type swap(Type src)
   {
      return src;
   }
};

template<typename Type>
struct byte_swap_t<Type, 2>
{
   static Type swap(Type src)
   {
      return bit_cast<uint16_t, Type>(_byteswap_ushort(bit_cast<Type, uint16_t>(src)));
   }
};

template<typename Type>
struct byte_swap_t<Type, 4>
{
   static Type swap(Type src)
   {
      return bit_cast<uint32_t, Type>(_byteswap_ulong(bit_cast<Type, uint32_t>(src)));
   }
};

template<typename Type>
struct byte_swap_t<Type, 8>
{
   static Type swap(Type src)
   {
      return bit_cast<uint64_t, Type>(_byteswap_uint64(bit_cast<Type, uint64_t>(src)));
   }
};

// Swaps endian of src
template<typename Type>
Type byte_swap(Type src)
{
   return byte_swap_t<Type>::swap(src);
}

#endif // BYTE_SWAP_H

```

`src/common/emugen_types.h`:

```h
#ifndef EMUGEN_TYPES_H
#define EMUGEN_TYPES_H

#include <vector>

namespace emugen
{

struct InstrEntry
{
   struct Opcode
   {
      Field field;
      unsigned value;
   };

   const char *name;
   std::vector<Opcode> opcodes;
   std::vector<Field> outputs;
   std::vector<Field> inputs;
   std::vector<Field> mods;
   const char *fullname;
};

struct DecodeEntry
{
   using fptr_t = InstructionID(*)(Instruction instr);

   DecodeEntry &operator=(fptr_t decoder)
   {
      value = reinterpret_cast<std::size_t>(decoder);
      return *this;
   }

   DecodeEntry &operator=(InstructionID instr)
   {
      value = static_cast<std::size_t>(instr);
      return *this;
   }

   bool isTable()
   {
      return value > static_cast<std::size_t>(InstructionID::InstructionMax);
   }

   InstructionID table(Instruction instr)
   {
      return reinterpret_cast<fptr_t>(value)(instr);
   }

   InstructionID instr()
   {
      return static_cast<InstructionID>(value);
   }

   std::size_t value;
};

}; // namespace emugen

#endif // ifndef EMUGEN_TYPES_H

```

`src/common/endian.h`:

```h
#ifndef ENDIAN_H
#define ENDIAN_H

#include <stdint.h>

#include "ptr32.h"
#include "bit_field.h"
#include "bit_swap.h"
#include "bit_mask.h"
#include "bit_scan.h"

enum Endian
{
   LittleEndian,
   BigEndian
};

// Common bit functions specialised for LittleEndian or BigEndian
template<int Endian>
class bit_accessor_t;

template<>
class bit_accessor_t<LittleEndian>
{
public:
   template<typename Type, unsigned Size>
   static inline Type
   make_bit_mask()
   {
      if (width<Type>() == Size) {
         return -1;
      } else {
         return (static_cast<Type>(1) << Size) - 1;
      }
   }

   template<typename Type>
   static inline Type
   make_bit_mask(unsigned size)
   {
      assert(size <= width<Type>());

      if (width<Type>() == size) {
         return -1;
      } else {
         return (static_cast<Type>(1) << size) - 1;
      }
   }

   template<typename Type>
   static inline Type
   make_bit_mask(unsigned first, unsigned last)
   {
      assert(first <= last);
      return make_bit_mask<Type>((last - first) + 1) << first;
   }

   template<unsigned First, unsigned Last, typename Type>
   static inline auto
   make_bit_field(Type &src)
      -> bit_field_t<Type, First, Last>
   {
      static_assert(First <= Last, "make_bit_field<First, Last> ensure First <= Last");
      return bit_field_t<Type, First, Last> { src };
   }

   template<typename Type>
   static inline auto
   make_bit_field(Type &src, unsigned first, unsigned last)
      -> dyn_bit_field_t<Type>
   {
      assert(first <= last);
      return dyn_bit_field_t<Type> { src, first, last };
   }

   template<typename Type>
   static inline unsigned width()
   {
      return sizeof(Type) * 8;
   }

   template<unsigned Bit, typename Type>
   static inline Type get_bit(Type src)
   {
      return (src >> (Bit)) & 1;
   }

   template<typename Type>
   static inline Type get_bit(Type src, unsigned bit)
   {
      assert(bit < width<Type>());
      return (src >> bit) & 1;
   }

   template<unsigned Bit, typename Type>
   static inline Type set_bit(Type src)
   {
      return src | (1 << Bit);
   }

   template<typename Type>
   static inline Type set_bit(Type src, unsigned bit)
   {
      assert(bit < width<Type>());
      return src | (1 << bit);
   }

   template<unsigned Bit, typename Type>
   static inline Type clear_bit(Type src)
   {
      return src & ~(1 << Bit);
   }

   template<typename Type>
   static inline Type clear_bit(Type src, unsigned bit)
   {
      assert(bit < width<Type>());
      return src & ~(1 << bit);
   }

   template<unsigned Bit, typename Type>
   static inline void copy_bit(Type &src, Type &dst)
   {
      copy_bits<Bit, Bit>(src, dst);
   }

   template<unsigned First, unsigned Last, typename Type>
   static inline void copy_bits(Type &src, Type &dst)
   {
      make_bit_field<First, Last>(dst) = make_bit_field<First, Last>(src);
   }

   template<unsigned Size, typename Type = uint64_t>
   static inline Type signExtend(Type v)
   {
      return get_bit<Size - 1>(v) == 0 ? v : (v | ~bit_mask_t<Type, Size>::value);
   }

   template<unsigned Size, typename Type>
   static inline Type zeroExtend(Type v)
   {
      return v & ((static_cast<Type>(1) << Size) - 1);
   }

   template<typename Type>
   static inline unsigned countLeadingZeros(Type value)
   {
      return bitScanReverse(value);
   }
};

template<>
class bit_accessor_t<BigEndian>
{
public:
   template<typename Type>
   static inline Type
   make_bit_mask(unsigned first, unsigned last)
   {
      return little_endian::make_bit_mask<Type>(bit_swap<Type>(last),
                                                bit_swap<Type>(first));
   }
};

using be_bit_accessor = bit_accessor_t<BigEndian>;
using le_bit_accessor = bit_accessor_t<LittleEndian>;

using big_endian      = be_bit_accessor;
using little_endian   = le_bit_accessor;

#endif // ENDIAN_H

```

`src/common/flags.h`:

```h
#ifndef FLAGS_H
#define FLAGS_H

template<typename Enum>
class Flags
{
private:
   int m_value;

public:
   Flags() :
      m_value(0)
   {
   }

   Flags(Enum f) :
      m_value(static_cast<int>(f))
   {
   }

   Flags & operator&=(Flags f)
   {
      m_value &= f.m_value;
      return *this;
   }

   Flags & operator|=(Flags f)
   {
      m_value |= f.m_value;
      return *this;
   }

   Flags & operator^=(Flags f)
   {
      m_value ^= f.m_value;
      return *this;
   }

   Flags & operator&=(Enum f)
   {
      m_value &= static_cast<int>(f);
      return *this;
   }

   Flags & operator|=(Enum f)
   {
      m_value |= static_cast<int>(f);
      return *this;
   }

   Flags & operator^=(Enum f)
   {
      m_value ^= static_cast<int>(f);
      return *this;
   }
 
   inline bool operator!() const
   {
      return !m_value;
   }

   inline operator int() const
   {
      return m_value;
   }
 
   inline Flags operator~ () const
   {
      return Flags(Enum(~m_value));
   }

   inline Flags operator|(Flags f) const
   {
      return Flags(Enum(m_value | f.m_value));
   }

   inline Flags operator^(Flags f) const
   {
      return Flags(Enum(m_value ^ f.m_value));
   }

   inline Flags operator&(Flags f) const
   {
      return Flags(Enum(m_value & f.m_value));
   }

   inline Flags operator|(Enum f) const
   {
      return Flags(Enum(m_value | static_cast<int>(f)));
   }

   inline Flags operator^(Enum f) const
   {
      return Flags(Enum(m_value ^ static_cast<int>(f)));
   }

   inline Flags operator&(Enum f) const
   {
      return Flags(Enum(m_value & static_cast<int>(f)));
   }
};

#endif

```

`src/common/log.cpp`:

```cpp
#include "log.h"

Log g_log;

```

`src/common/log.h`:

```h
#ifndef UTIL_LOG_H
#define UTIL_LOG_H

#include <stdint.h>
#include <iostream>
#include <iomanip>
#include <string>

class Log 
{
public:
   struct hex {
      hex(uint64_t number, unsigned pad = 0) :
         number(number), pad(pad)
      {
      }

      uint64_t number;
      unsigned pad;
   };

   struct bin {
      bin(uint32_t number, unsigned pad = 0) : 
         number(number), pad(pad)
      {
      }

      uint32_t number;
      unsigned pad;
   };

private:
   class Output
   {
   public:
      Output(const std::string &pre, bool newLine = true)
      {
         if (newLine) {
            std::cout << std::endl << pre << " ";
         }
      }

      template<typename T>
      Output& operator << (const T &val)
      {
         std::cout << val;
         return *this;
      }

      template<>
      Output& operator << (const Log::hex &val)
      {
         if (val.pad) {
            std::cout << std::hex << std::setfill('0') << std::setw(val.pad) << val.number;
         } else {
            std::cout << std::hex << val.number;
         }

         std::cout << std::dec;
         return *this;
      }

      template<>
      Output& operator << (const Log::bin &val)
      {
         for (unsigned i = 0; i < val.pad; ++i) {
            std::cout << ((val.number >> i) & 1);
         }

         return *this;
      }

   private:
   };

public:
   Output custom(const std::string &pre, bool newLine = true)
   {
      return Output(pre, newLine);
   }

   Output debug(bool newLine = true)
   {
      return Output("[DEBUG]", newLine);
   }

   Output warning(bool newLine = true)
   {
      return Output("[WARNING]", newLine);
   }

   Output error(bool newLine = true)
   {
      return Output("[ERROR]", newLine);
   }

private:
};

extern Log g_log;

#define xDebug() g_log.debug()
#define xWarning() g_log.warning()
#define xError() g_log.error()

#define xDebugInline() g_log.debug(false)
#define xWarningInline() g_log.warning(false)
#define xErrorInline() g_log.error(false)

#endif // UTIL_LOG_H

```

`src/common/memory.cpp`:

```cpp
#include "memory.h"
#include <windows.h>

uint8_t* Memory::allocate(uint64_t address, unsigned size)
{
   return reinterpret_cast<uint8_t*>(VirtualAlloc(reinterpret_cast<LPVOID>(address), size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE));
}

void Memory::free(uint64_t address, unsigned size)
{
   VirtualFree(reinterpret_cast<LPVOID>(address), size, MEM_RELEASE);
   VirtualFree(reinterpret_cast<LPVOID>(address), size, MEM_DECOMMIT);
}

```

`src/common/memory.h`:

```h
#ifndef BIG_ENDIAN_MEMORY_H
#define BIG_ENDIAN_MEMORY_H

#include <stdint.h>
#include <string.h>

#include "byte_swap.h"
#include "ptr32.h"

class Memory
{
public:
   static uint8_t* allocate(uint64_t address, unsigned size);
   static void free(uint64_t address, unsigned size);

   static inline void set(uint64_t address, uint8_t value, uint64_t size)
   {
      memset(reinterpret_cast<void*>(address), value, size);
   }

   static inline void zero(uint64_t address, uint64_t size)
   {
      memset(reinterpret_cast<void*>(address), 0, size);
   }

   template<typename Type>
   static inline Type translate(Type address)
   {
      return (Type)(((uint64_t)address) & 0xFFFFFFFF);
   }

   template<typename T>
   static inline T read(uint64_t address)
   {
      return byte_swap(*reinterpret_cast<T*>(translate(address)));
   }

   template<typename Type, typename StorageType>
   static inline Type read(ptr32_t<Type, StorageType> ptr)
   {
      return byte_swap(*ptr);
   }

   template<typename PointedType>
   static inline PointedType read(PointedType *address)
   {
      return read<PointedType>(reinterpret_cast<uint64_t>(address));
   }

   template<typename T>
   static inline void write(uint64_t address, const T &value)
   {
      *reinterpret_cast<T*>(translate(address)) = byte_swap(value);
   }

   template<typename Type , typename StorageType>
   static inline void write(ptr32_t<Type, StorageType> ptr, const Type &value)
   {
      *ptr = byte_swap(value);
   }

   template<typename PointedType>
   static inline void write(PointedType * address, const PointedType &value)
   {
      return write<PointedType>(reinterpret_cast<uint64_t>(address), value);
   }
   
private:
};

#endif //BIG_ENDIAN_MEMORY_H

```

`src/common/ptr32.h`:

```h
#ifndef COMMON_ptr32_t_H
#define COMMON_ptr32_t_H

#include <stdint.h>
#include <assert.h>
#include <type_traits>
#include "bit_cast.h"

#pragma pack(push, 1)

template<typename Type, typename StorageType = uint32_t>
class ptr32_t
{
public:
   ptr32_t()
   {
   }

   ptr32_t(Type *pointer)
   {
      setPointer(pointer);
   }

   template<typename OtherType, typename OtherStorage>
   explicit ptr32_t(ptr32_t<OtherType, OtherStorage> &other)
   {
      setPointer(reinterpret_cast<Type *>(other.getPointer()));
   }

   ptr32_t<Type, StorageType> & operator =(Type *pointer)
   {
      setPointer(pointer);
      return *this;
   }

   template<typename OtherType>
   ptr32_t<Type, StorageType> & operator =(const ptr32_t<Type, OtherType> &pointer)
   {
      setPointer(pointer.getPointer());
      return *this;
   }

   void setPointer(Type *pointer)
   {
      uint64_t address = reinterpret_cast<uint64_t>(pointer);
      assert(address < 0xffffffff);

      #pragma warning(suppress : 4244)
      mPointer = static_cast<StorageType>(address);
   }

   Type *getPointer() const
   {
      uint64_t address = mPointer;
      return reinterpret_cast<Type *>(address);
   }

   StorageType getRawPointer() const
   {
      return mPointer;
   }

   Type &operator *() const
   {
      return *getPointer();
   }

   Type *operator ->() const
   {
      return getPointer();
   }

   operator Type *() const
   {
      return getPointer();
   }

   ptr32_t<Type, StorageType> & operator++()
   {
      mPointer += sizeof(Type);
      return *this;
   }

   ptr32_t<Type, StorageType> operator++(int)
   {
      ptr32_t<Type, StorageType> old { *this };
      mPointer += sizeof(Type);
      return old;
   }

private:
   StorageType mPointer;
};

// We shouldn't need to specialise here, but msvc seems to crash when
// we use std::enable_if<!std::is_void> on operator* and operator->
template<typename StorageType>
class ptr32_t<void, StorageType>
{
public:
   ptr32_t()
   {
   }

   ptr32_t(void *pointer)
   {
      setPointer(pointer);
   }

   void setPointer(void *pointer)
   {
      uint64_t address = reinterpret_cast<uint64_t>(pointer);
      assert(address < 0xffffffff);

      #pragma warning(suppress : 4244)
      mPointer = static_cast<StorageType>(address);
   }

   void *getPointer() const
   {
      uint64_t address = mPointer;
      return reinterpret_cast<void *>(address);
   }

   StorageType getRawPointer() const
   {
      return mPointer;
   }

   ptr32_t<void, StorageType> & operator =(void *pointer)
   {
      setPointer(pointer);
      return *this;
   }

   template<typename OtherType>
   ptr32_t<void, StorageType> & operator =(const ptr32_t<void, OtherType> &pointer)
   {
      setPointer(pointer.getPointer());
      return *this;
   }

   operator void *() const
   {
      return getPointer();
   }

private:
   StorageType mPointer;
};

// Check size of specialised ptr32_t<void> and generic ptr<T>
static_assert(sizeof(ptr32_t<void>) == 4, "ptr32_t<void> must be 4 bytes");
static_assert(sizeof(ptr32_t<uint64_t>) == 4, "ptr32_t<uint64_t> must be 4 bytes");

#pragma pack(pop)

#endif // COMMON_ptr32_t_H

```

`src/common/structmacros.h`:

```h
#ifndef STRUCT_MACROS_H
#define STRUCT_MACROS_H

// Ensure our structs are correct size & offsets to match Xbox360
#define CHECK_SIZE(Type, Size) \
   static_assert(sizeof(Type) == Size, \
                 #Type " must be " #Size " bytes");

#define CHECK_OFFSET(Type, Offset, Field) \
   static_assert((unsigned long long)&((Type*)0)->Field == Offset, \
                 #Type "::" #Field " must be at offset " #Offset);

// Workaround weird macro concat ## behaviour
#define PP_CAT(a, b) PP_CAT_I(a, b)
#define PP_CAT_I(a, b) PP_CAT_II(~, a ## b)
#define PP_CAT_II(p, res) res

// Allow us to easily add UNKNOWN / PADDING bytes into our structs,
// generates unique variable names using __COUNTER__
#define UNKNOWN(Size) char PP_CAT(__unk, __COUNTER__) [Size];
#define PADDING(Size) UNKNOWN(Size)

#endif // STRUCT_MACROS_H

```

`src/kernel.cpp`:

```cpp
#include "system.h"

#include "kernel/xboxkrnl/process.h"
#include "powerpc/instructions.h"
#include "kernel/module.h"
#include "common/memory.h"

#include "kernel/connectx/connectx.h"
#include "kernel/createprofile/createprofile.h"
#include "kernel/vk/vk.h"
#include "kernel/xam/xam.h"
#include "kernel/xapi/xapi.h"
#include "kernel/xbdm/xbdm.h"
#include "kernel/xboxkrnl/xboxkrnl.h"

bool System::initKernel()
{
   // Initialize process
   KeInitializeProcess();

   // Init each kernel module
   addModule(new connectx);
   addModule(new createprofile);
   addModule(new vk);
   addModule(new xam);
   addModule(new xapi);
   addModule(new xbdm);
   addModule(new xboxkrnl);

   // Linkup all imports to kernel exports
   if (!resolveImports(mBinary.header.importLibraries)) {
      xDebug() << "Could not resolve imports";
      return false;
   }
   
   return true;
}

void System::addModule(Module *module)
{
   mModules.emplace(module->getName(), module);
}

Module *System::getModule(std::string name)
{
   auto itr = mModules.find(name);

   if (itr == mModules.end()) {
      return nullptr;
   } else {
      return itr->second;
   }
}

// Link xex imports to module exports
bool System::resolveImports(xex::ImportLibraries &imports)
{
   for (auto &library : imports.libraries) {
      auto module = getModule(library.name);

      if (!module) {
         continue;
      }

      for (auto &import : library.imports) {
         auto export_ = module->getExport(import.ordinal);

         if (export_) {
            if (import.thunk) {
               // Write kernel call instruction at import.thunk
               auto instr = ppc::createInstruction(ppc::InstructionID::krncall);
               instr.uimm = export_->ordinal;
               instr.rA = export_->args;
               instr.rD = 1;

               Memory::write<uint32_t>(import.thunk,
                                       instr.value);

               Memory::write<uint64_t>(import.thunk + 4,
                                       reinterpret_cast<uint64_t>(export_));
            } else {
               // Write pointer to exported variable at import.address
               Memory::write<uint32_t>(import.address,
                                       reinterpret_cast<uint32_t>(export_->ptr));
            }
         } else {
            if (import.thunk) {
               // Write debug "missing import" kernel call
               auto instr = ppc::createInstruction(ppc::InstructionID::krncall);
               instr.uimm = import.ordinal;
               instr.rA = instr.rD = 0;

               Memory::write<uint32_t>(import.thunk, instr.value);

               Memory::write<uint64_t>(import.thunk + 4,
                                       reinterpret_cast<uint64_t>(&library));

               xDebug() << "Missing function import "
                        << library.name
                        << "[" << import.ordinal << "]";
            } else {
               // Write ordinal as pointer, will cause a crash at reading the ordinal number
               Memory::write<uint32_t>(import.address,
                                       import.ordinal);

               xDebug() << "Missing variable import "
                        << library.name
                        << "[" << import.ordinal << "]";
            }
         }
      }
   }

   return true;
}

```

`src/kernel/connectx/connectx.cpp`:

```cpp
#include "kernel/connectx/connectx.h"

connectx::connectx() :
   Module("connectx.xex")
{
}

```

`src/kernel/connectx/connectx.h`:

```h
#ifndef CONNECTX_H
#define CONNECTX_H

#include "kernel/module.h"

class connectx : public Module
{
public:
   connectx();
};

#endif // CONNECTX_H

```

`src/kernel/createprofile/createprofile.cpp`:

```cpp
#include "kernel/createprofile/createprofile.h"

createprofile::createprofile() :
   Module("createprofile.xex")
{
}

```

`src/kernel/createprofile/createprofile.h`:

```h
#ifndef CREATEPROFILE_H
#define CREATEPROFILE_H

#include "kernel/module.h"

class createprofile : public Module
{
public:
   createprofile();
};

#endif // CREATEPROFILE_H

```

`src/kernel/kernel.h`:

```h
#ifndef KERNEL_H
#define KERNEL_H

#include <stdint.h>
#include <assert.h>
#include <thread>
#include <type_traits>
#include "common/ptr32.h"

namespace xex
{
   struct Binary;
};

#endif

```

`src/kernel/module.h`:

```h
#ifndef KERNEL_MODULE_H
#define KERNEL_MODULE_H

#include <map>
#include <stdint.h>

class Module
{
public:
   //TODO: replace with index_sequence, C++14
   template<unsigned ...I>
   struct sequence { };

   template<unsigned N>
   struct make_sequence;
   template<> struct make_sequence<0u> { using type = sequence<>; };
   template<> struct make_sequence<1u> { using type = sequence<3>; };
   template<> struct make_sequence<2u> { using type = sequence<3, 4>; };
   template<> struct make_sequence<3u> { using type = sequence<3, 4, 5>; };
   template<> struct make_sequence<4u> { using type = sequence<3, 4, 5, 6>; };
   template<> struct make_sequence<5u> { using type = sequence<3, 4, 5, 6, 7>; };
   template<> struct make_sequence<6u> { using type = sequence<3, 4, 5, 6, 7, 8>; };
   template<> struct make_sequence<7u> { using type = sequence<3, 4, 5, 6, 7, 8, 9>; };
   template<> struct make_sequence<8u> { using type = sequence<3, 4, 5, 6, 7, 8, 9, 10>; };

   // TODO: Revisit if non-gpr are used for function calls!
   struct BoundFunction
   {
      virtual void call(uint64_t gpr[32]) = 0;
   };

   template<typename Ret, typename... Args>
   struct FunctionWrapper : public BoundFunction
   {
      FunctionWrapper(Ret(*func)(Args...)) :
         mWrappedFunction(func)
      {
      }

      Ret(*mWrappedFunction)(Args...);

      template<std::size_t... I>
      Ret dispatch(uint64_t gpr[32], sequence<I...>)
      {
         return mWrappedFunction(*reinterpret_cast<Args*>(&gpr[I])...);
      }

      void call(uint64_t gpr[32]) override
      {
         *reinterpret_cast<Ret*>(&gpr[3]) = dispatch(gpr, make_sequence<sizeof...(Args)>::type {});
      }
   };

   struct Export
   {
      std::string name;
      int ordinal;
      int args;
      void *ptr;
   };

   Module()
   {
   }

   Module(std::string name) :
      mName(name)
   {
   }

   std::string getName() const
   {
      return mName;
   }

   const Export *getExport(int ordinal) const
   {
      auto itr = mExports.find(ordinal);

      if (itr == mExports.end()) {
         return nullptr;
      } else {
         return &itr->second;
      }
   }

protected:
   void addExport(std::string name, int ordinal, int args, void *ptr)
   {
      mExports.emplace(ordinal, Export { name, ordinal, args, ptr });
   }

   void addExport(std::string name, int ordinal, void *ptr)
   {
      mExports.emplace(ordinal, Export { name, ordinal, -1, ptr });
   }

private:
   std::string mName;
   std::map<int, Export> mExports;
};

template<typename Type>
struct argument_count
{
   static const std::size_t value = 0;
};

template<typename ReturnType, typename ...Args>
struct argument_count<ReturnType (Args...)>
{
   static const std::size_t value = sizeof...(Args);
};

template<typename ReturnType, typename... Args>
static inline 
Module::FunctionWrapper<ReturnType, Args...>* make_function(ReturnType(*func)(Args...))
{
   return new Module::FunctionWrapper<ReturnType, Args...> { func };
}

#define exportFunction(ordinal, function) \
   addExport(#function, ordinal, argument_count<decltype(function)>::value, make_function(&function));

#define exportVariable(ordinal, variable) \
   addExport(#variable, ordinal, (void*)&variable);

#endif // KERNEL_LIBRARY_H

```

`src/kernel/vk/vk.cpp`:

```cpp
#include "kernel/vk/vk.h"

vk::vk() :
   Module("vk.xex")
{
}

```

`src/kernel/vk/vk.h`:

```h
#ifndef VK_H
#define VK_H

#include "kernel/module.h"

class vk : public Module
{
public:
   vk();
};

#endif // VK_H

```

`src/kernel/xam/xam.cpp`:

```cpp
#include "kernel/xam/xam.h"

xam::xam() :
   Module("xam.xex")
{
}
```

`src/kernel/xam/xam.h`:

```h
#ifndef XAM_H
#define XAM_H

#include "kernel/module.h"

class xam : public Module
{
public:
   xam();
};

#endif // XAM_H

```

`src/kernel/xapi/xapi.cpp`:

```cpp
#include "kernel/xapi/xapi.h"

xapi::xapi() :
   Module("xapi.xex")
{
}

```

`src/kernel/xapi/xapi.h`:

```h
#ifndef XAPI_H
#define XAPI_H

#include "kernel/module.h"

class xapi : public Module
{
public:
   xapi();
};

#endif // XAPI_H

```

`src/kernel/xbdm/xbdm.cpp`:

```cpp
#include "kernel/xbdm/xbdm.h"

xbdm::xbdm() :
   Module("xbdm.xex")
{
}

```

`src/kernel/xbdm/xbdm.h`:

```h
#ifndef XBDM_H
#define XBDM_H

#include "kernel/module.h"

class xbdm : public Module
{
public:
   xbdm();
};

#endif // XBDM_H

```

`src/kernel/xboxkrnl/criticalsection.cpp`:

```cpp
#include "kernel/xboxkrnl/criticalsection.h"
#include "kernel/xboxkrnl/thread.h"
#include "kernel/xboxkrnl/object.h"
#include "common/memory.h"

#include <algorithm>

static_assert(sizeof(std::atomic_uint32_t) == 4, "Atomic 4");

KSTATUS
RtlInitializeCriticalSection(ptr32_t<KCriticalSection> cs)
{
   return RtlInitializeCriticalSectionAndSpinCount(cs, 0);
}

KSTATUS
RtlInitializeCriticalSectionAndSpinCount(ptr32_t<KCriticalSection> cs,
                                         uint32_t spin)
{
   cs->Header.Type = EventSynchronizationObject;
   cs->Header.SignalState = 0;
   cs->LockCount = -1;
   cs->RecursionCount = 0;
   cs->OwningThread = nullptr;
   cs->Header.Absolute = std::max((spin + 0xff) >> 8, 0xffu);

   return KSTATUS_SUCCESS;
}

KBOOL
RtlTryEnterCriticalSection(ptr32_t<KCriticalSection> cs)
{
   int32_t unlockedValue = -1;
   auto thread = GetCurrentThread()->getPcr()->PrcbData.CurrentThread;

   bool acquired = std::atomic_compare_exchange_strong(&cs->LockCount,
                                                       &unlockedValue,
                                                       0);

   if (acquired) {
      cs->OwningThread = thread;
      cs->RecursionCount = 1;
      return KTRUE;
   } else if (cs->OwningThread == thread) {
      cs->LockCount.fetch_add(1);
      cs->RecursionCount++;
      return KTRUE;
   }

   return KFALSE;
}

void
RtlpWaitCriticalSection(ptr32_t<KCriticalSection> cs)
{
   KeWaitForSingleObject(static_cast<ptr32_t<void>>(cs), 8, 0, 0, 0);
   cs->OwningThread = GetCurrentThread()->getPcr()->PrcbData.CurrentThread;
   cs->RecursionCount = 1;
}

void
RtlpUnWaitCriticalSection(ptr32_t<KCriticalSection> cs)
{
   KeSetEvent(static_cast<ptr32_t<KEvent>>(cs), 1, 0);
}

KSTATUS
RtlEnterCriticalSection(ptr32_t<KCriticalSection> cs)
{
   auto currentThread = GetCurrentThread()->getPcr()->PrcbData.CurrentThread;
   auto spinCount = static_cast<uint64_t>(cs->Header.Absolute) << 8;

spin:
   if (cs->LockCount.fetch_add(1) != -1) {
      if (cs->OwningThread == currentThread) {
         cs->RecursionCount++;
         return KSTATUS_SUCCESS;
      }

      cs->LockCount.fetch_sub(1);

      if (spinCount) {
         --spinCount;
         goto spin;
      }

      // Out of spins, do a wait
      RtlpWaitCriticalSection(cs);
   }

   // Own it
   cs->OwningThread = currentThread;
   cs->RecursionCount = 1;
   return KSTATUS_SUCCESS;
}

KSTATUS
RtlLeaveCriticalSection(ptr32_t<KCriticalSection> cs)
{
   cs->RecursionCount--;

   if (cs->RecursionCount) {
      cs->LockCount.fetch_sub(1);
      return KSTATUS_SUCCESS;
   }

   cs->OwningThread = nullptr;

   // If lock count != -1 then there is a waiter
   if (cs->LockCount.fetch_sub(1) != 0) {
      RtlpUnWaitCriticalSection(cs);
   }

   return KSTATUS_SUCCESS;
}

```

`src/kernel/xboxkrnl/criticalsection.h`:

```h
#ifndef XBOXKRNL_CRITICAL_SECTION_H
#define XBOXKRNL_CRITICAL_SECTION_H

#include "kernel/xboxkrnl/xboxkrnl.h"
#include "kernel/xboxkrnl/ntstructs.h"

KSTATUS
RtlInitializeCriticalSection(ptr32_t<KCriticalSection> cs);

KSTATUS
RtlInitializeCriticalSectionAndSpinCount(ptr32_t<KCriticalSection> cs,
                                         uint32_t spin);

KBOOL
RtlTryEnterCriticalSection(ptr32_t<KCriticalSection> cs);

KSTATUS
RtlEnterCriticalSection(ptr32_t<KCriticalSection> cs);

KSTATUS
RtlLeaveCriticalSection(ptr32_t<KCriticalSection> cs);

#endif // ifndef XBOXKRNL_CRITICAL_SECTION_H

```

`src/kernel/xboxkrnl/debug.cpp`:

```cpp
#include "kernel/xboxkrnl/debug.h"

uint32_t KeDebugMonitorData = 0;


```

`src/kernel/xboxkrnl/debug.h`:

```h
#ifndef XBOXKRNL_DEBUG_H
#define XBOXKRNL_DEBUG_H

#include "kernel/xboxkrnl/xboxkrnl.h"

extern uint32_t KeDebugMonitorData;

#endif // XBXKRNL_DEBUG_H

```

`src/kernel/xboxkrnl/event.h`:

```h
#ifndef XBOXKRNL_EVENT_H
#define XBOXKRNL_EVENT_H

#include "object.h"
#include <condition_variable>

class Event : public Object, public Waitable
{
public:
   enum ResetType
   {
      AutoReset,
      ManualReset
   };

public:
   Event(ResetType resetType, bool initialState) :
      Object(Object::Event),
      mResetType(resetType)
   {
      mEvent.store(initialState);
   }

   bool set()
   {
      bool previous = mEvent.exchange(true);

      // Auto-reset should only wake one thread and then immediately reset event
      if (mResetType == AutoReset) {
         mConVar.notify_one();
      } else {
         mConVar.notify_all();
      }

      return previous;
   }

   void reset()
   {
      mEvent.store(false);
   }

   Waitable *getWaitable() override
   {
      return this;
   }

   Waitable::WaitStatus wait(uint32_t milliseconds) override
   {
      bool status = true;

      // Immediately return if event is already set
      if (mEvent.load()) {
         return Waitable::Success;
      }

      // Wait for event to be set
      std::unique_lock<std::mutex> lock { mMutex };

      if (!milliseconds) {
         mConVar.wait(lock, [this]{ return mEvent.load(); });
      } else {
         status = mConVar.wait_for(lock,
                                   std::chrono::milliseconds { milliseconds },
                                   [this]{ return mEvent.load(); });
      }

      // Reset if needed
      if (status && mResetType == AutoReset) {
         reset();
      }

      return status ? Waitable::Success : Waitable::Timeout;
   }

private:
   ResetType mResetType;
   std::mutex mMutex;
   std::atomic_bool mEvent;
   std::condition_variable mConVar;
};

#endif

```

`src/kernel/xboxkrnl/hardware.cpp`:

```cpp
#include "kernel/xboxkrnl/hardware.h"
#include "common/memory.h"

HardwareInfo XboxHardwareInfo;

void xboxkrnlHardwareInit()
{
   memset(&XboxHardwareInfo, 0, sizeof(HardwareInfo));
   XboxHardwareInfo.Flags = 0x813;
}

```

`src/kernel/xboxkrnl/hardware.h`:

```h
#ifndef XBOXKRNL_HARDWARE_H
#define XBOXKRNL_HARDWARE_H

#include "kernel/xboxkrnl/xboxkrnl.h"
#include "common/bigendian.h"

#pragma pack(push, 1)

struct HardwareInfo
{
   be_uint32_t Flags;
   be_uint8_t NumberOfProcessors;
   be_uint8_t PCIBridgeRevisionID;
   be_uint8_t Reserved[6];
   be_uint16_t BldrMagic;
   be_uint16_t BldrFlags;
};

CHECK_SIZE(HardwareInfo, 0x10);

#pragma pack(pop)

extern HardwareInfo
XboxHardwareInfo;

void xboxkrnlHardwareInit();

#endif // ifndef XBOXKRNL_HARDWARE_H

```

`src/kernel/xboxkrnl/ntstructs.h`:

```h
#ifndef XBOXKRNL_NTSTRUCTS_H
#define XBOXKRNL_NTSTRUCTS_H

#include "kernel/xboxkrnl/xboxkrnl.h"
#include "common/bigendian.h"

#include <atomic>

class Object;

#pragma pack(push, 1)

// Forward declare all NT structs
struct KListEntry;
struct KDispatcherHeader;
struct KEvent;
struct KCriticalSection;
struct KMutant;
struct KSemaphore;
struct KSpinLock;
struct KQueue;
struct KDpc;
struct KTimer;
struct KWaitBlock;
struct KApcState;
struct KApc;
struct KThread;
struct KProcess;
struct KPrcb;
struct KPcr;
struct KAnsiString;
struct KUnicodeString;
struct KLdrDataTableEntry;

// KPROCESSOR_MODE
using KProcessorMode = uint8_t;
CHECK_SIZE(KProcessorMode, 0x1);

// KIRQL
using KIrql = uint8_t;
CHECK_SIZE(KIrql, 0x1);

// LIST_ENTRY
struct KListEntry
{
   union {
      struct
      {
         be_ptr32_t<KListEntry> Front;
         be_ptr32_t<KListEntry> Back;
      };

      Object *object;
   };
};

CHECK_OFFSET(KListEntry, 0x0, Front);
CHECK_OFFSET(KListEntry, 0x4, Back);
CHECK_SIZE(KListEntry, 0x8);

// DISPATCHER_HEADER
struct KDispatcherHeader
{
   be_uint8_t Type;
   be_uint8_t Absolute;
   be_uint8_t NpxIrql;
   be_uint8_t Signalling;
   be_int32_t SignalState;
   KListEntry WaitList;
};

CHECK_OFFSET(KDispatcherHeader, 0x0, Type);
CHECK_OFFSET(KDispatcherHeader, 0x1, Absolute);
CHECK_OFFSET(KDispatcherHeader, 0x2, NpxIrql);
CHECK_OFFSET(KDispatcherHeader, 0x3, Signalling);
CHECK_OFFSET(KDispatcherHeader, 0x4, SignalState);
CHECK_OFFSET(KDispatcherHeader, 0x8, WaitList);
CHECK_SIZE(KDispatcherHeader, 0x10);

// KEVENT
struct KEvent
{
   KDispatcherHeader Header;
};

CHECK_OFFSET(KEvent, 0x0, Header);
CHECK_SIZE(KEvent, 0x10);

// CRITICAL_SECTION
struct KCriticalSection
{
   KDispatcherHeader Header;
   // using SpinCount = Header.Absolute;
   // using EntryCount = Header.SignalState;

   std::atomic_int32_t LockCount;
   volatile uint32_t RecursionCount;
   be_ptr32_t<KThread> OwningThread;
};

CHECK_OFFSET(KCriticalSection, 0x0, Header);
CHECK_OFFSET(KCriticalSection, 0x10, LockCount);
CHECK_OFFSET(KCriticalSection, 0x14, RecursionCount);
CHECK_OFFSET(KCriticalSection, 0x18, OwningThread);
CHECK_SIZE(KCriticalSection, 0x1c);

// KMUTANT
struct KMutant
{
   KDispatcherHeader Header;
   KListEntry MutantListEntry;
   be_ptr32_t<KThread> OwnerThread;
};

CHECK_OFFSET(KMutant, 0x0, Header);
CHECK_OFFSET(KMutant, 0x10, MutantListEntry);
CHECK_OFFSET(KMutant, 0x18, OwnerThread);
CHECK_SIZE(KMutant, 0x1c);

// KSEMAPHORE
struct KSemaphore
{
   KDispatcherHeader Header;
   be_int32_t Limit;
};

CHECK_OFFSET(KSemaphore, 0x0, Header);
CHECK_OFFSET(KSemaphore, 0x10, Limit);
CHECK_SIZE(KSemaphore, 0x14);

// KSPIN_LOCK
struct KSpinLock
{
   be_ptr32_t<be_uint32_t> Lock;
};

CHECK_OFFSET(KSpinLock, 0x0, Lock);
CHECK_SIZE(KSpinLock, 0x4);

// KQUEUE
struct KQueue
{
   KDispatcherHeader Header;
   KListEntry EntryListHead;
   be_uint32_t CurrentCount;
   be_uint32_t MaximumCount;
   KListEntry ThreadListHead;
};

CHECK_OFFSET(KQueue, 0x0, Header);
CHECK_OFFSET(KQueue, 0x10, EntryListHead);
CHECK_OFFSET(KQueue, 0x18, CurrentCount);
CHECK_OFFSET(KQueue, 0x1C, MaximumCount);
CHECK_OFFSET(KQueue, 0x20, ThreadListHead);
CHECK_SIZE(KQueue, 0x28);

// KDPC
struct KDpc
{
   be_uint16_t Type;
   be_uint8_t InsertedNumber;
   be_uint8_t TargetNumber;
   KListEntry DpcListEntry;
   be_ptr32_t<void> DeferredRoutine;
   be_ptr32_t<void> DeferredCintext;
   be_ptr32_t<void> SystemArgument1;
   be_ptr32_t<void> SystemArgument2;
};

CHECK_OFFSET(KDpc, 0x00, Type);
CHECK_OFFSET(KDpc, 0x02, InsertedNumber);
CHECK_OFFSET(KDpc, 0x03, TargetNumber);
CHECK_OFFSET(KDpc, 0x04, DpcListEntry);
CHECK_OFFSET(KDpc, 0x0C, DeferredRoutine);
CHECK_OFFSET(KDpc, 0x10, DeferredCintext);
CHECK_OFFSET(KDpc, 0x14, SystemArgument1);
CHECK_OFFSET(KDpc, 0x18, SystemArgument2);
CHECK_SIZE(KDpc, 0x1c);

// KTIMER
struct KTimer
{
   KDispatcherHeader Header;
   be_int64_t DueTime;
   KListEntry TimerListEntry;
   be_ptr32_t<KDpc> Dpc;
   be_int32_t Period;
};

CHECK_OFFSET(KTimer, 0x0, Header);
CHECK_OFFSET(KTimer, 0x10, DueTime);
CHECK_OFFSET(KTimer, 0x18, TimerListEntry);
CHECK_OFFSET(KTimer, 0x20, Dpc);
CHECK_OFFSET(KTimer, 0x24, Period);
CHECK_SIZE(KTimer, 0x28);

// KWAIT_BLOCK
struct KWaitBlock
{
   KListEntry WaitListEntry;
   be_ptr32_t<KThread> Thread;
   be_ptr32_t<void> Object;
   be_ptr32_t<KWaitBlock> NextWaitBlock;
   be_int16_t WaitKey;
   be_int16_t WaitType;
};

CHECK_OFFSET(KWaitBlock, 0x0, WaitListEntry);
CHECK_OFFSET(KWaitBlock, 0x8, Thread);
CHECK_OFFSET(KWaitBlock, 0xc, Object);
CHECK_OFFSET(KWaitBlock, 0x10, NextWaitBlock);
CHECK_OFFSET(KWaitBlock, 0x14, WaitKey);
CHECK_OFFSET(KWaitBlock, 0x16, WaitType);
CHECK_SIZE(KWaitBlock, 0x18);

// KAPC_STATE
struct KApcState
{
   KListEntry ApcListHead[2];
   be_ptr32_t<KProcess> Process;
   be_uint8_t KernelApcInProgress;
   be_uint8_t KernelApcPending;
   be_uint8_t UserApcPending;
};

CHECK_OFFSET(KApcState, 0x0, ApcListHead);
CHECK_OFFSET(KApcState, 0x10, Process);
CHECK_OFFSET(KApcState, 0x14, KernelApcInProgress);
CHECK_OFFSET(KApcState, 0x15, KernelApcPending);
CHECK_OFFSET(KApcState, 0x16, UserApcPending);
CHECK_SIZE(KApcState, 0x17);

// KAPC
struct KApc
{
   be_uint16_t Type;
   KProcessorMode ApcMode;
   UNKNOWN(0x1);
   be_ptr32_t<KThread> Thread;
   KListEntry ApcListEntry;
   be_ptr32_t<void> KernelRoutine;
   be_ptr32_t<void> RundownRoutine;
   be_ptr32_t<void> NormalRoutine;
   be_ptr32_t<void> NormalContext;
   be_ptr32_t<void> SystemArgument1;
   be_ptr32_t<void> SystemArgument2;
};

CHECK_OFFSET(KApc, 0x0, Type);
CHECK_OFFSET(KApc, 0x2, ApcMode);
CHECK_OFFSET(KApc, 0x4, Thread);
CHECK_OFFSET(KApc, 0x8, ApcListEntry);
CHECK_OFFSET(KApc, 0x10, KernelRoutine);
CHECK_OFFSET(KApc, 0x14, RundownRoutine);
CHECK_OFFSET(KApc, 0x18, NormalRoutine);
CHECK_OFFSET(KApc, 0x1c, NormalContext);
CHECK_OFFSET(KApc, 0x20, SystemArgument1);
CHECK_OFFSET(KApc, 0x24, SystemArgument2);
CHECK_SIZE(KApc, 0x28);

// KTHREAD
struct KThread
{
   KDispatcherHeader Header;
   KListEntry MutantListHead;
   KTimer Timer;
   KWaitBlock TimerWaitBlock;
   be_uint32_t KernelTime;
   be_ptr32_t<void> InitialStack;
   be_ptr32_t<void> StackLimit;
   be_ptr32_t<void> KernelStack;
   be_ptr32_t<void> TlsData;
   be_uint8_t State;
   be_uint8_t Alerted[2];
   be_uint8_t Alertable;
   be_uint8_t Priority;
   be_uint8_t FpuExceptionEnable;
   be_uint8_t CreateProcessType;
   be_uint8_t CurrentProcessType;
   KApcState ApcState;
   be_uint8_t ApcQueueable;
   KSpinLock ApcQueueLock;
   be_uint32_t ContextSwitches;
   KListEntry ReadyListEntry;
   be_uint32_t MsrEnableMask;
   be_ptr32_t<be_int32_t> WaitStatus;
   KIrql WaitIrql;
   KProcessorMode WaitMode;
   be_uint8_t WaitNext;
   be_uint8_t WaitReason;
   be_ptr32_t<KWaitBlock> WaitBlockList;
   UNKNOWN(0x4);
   be_uint32_t KernelApcDisable;
   be_uint32_t Quantum;
   be_int8_t Saturation;
   be_uint8_t BasePriority;
   be_uint8_t PriorityDecrement;
   be_uint8_t DisableBoost;
   be_int8_t SuspendCount;
   be_uint8_t Preempted;
   be_uint8_t HasTerminated;
   be_uint8_t CurrentProcessor;
   be_ptr32_t<KPrcb> CurrentPrcb;
   be_ptr32_t<KPrcb> AffinityPrcb;
   be_uint8_t IdlePriorityClass;
   be_uint8_t NormalPriorityClass;
   be_uint8_t TimeCriticalPriorityClass;
   be_uint8_t HasAsyncTerminated;
   KSpinLock ActiveTimerListLock;
   be_ptr32_t<void> StackAllocatedBase;
   KApc SuspendApc;
   KSemaphore SuspendSemaphore;
   KListEntry ThreadListEntry;
   be_ptr32_t<KQueue> Queue;
   KListEntry QueueListEntry;
   be_ptr32_t<void> UserModeDispatcher;
   be_ptr32_t<struct KTrapFrame> UserModeTrapFrame; // Unknown struct KTRAP_FRAME
   PADDING(0x4);
   be_uint64_t CreateTime;
   be_uint64_t ExitTime;
   be_uint32_t ExitStatus;
   KListEntry ActiveTimerListHead;
   be_uint32_t ThreadId;
   be_ptr32_t<void> StartAddress;
   KListEntry IrpList;
   be_ptr32_t<void> DebugMonitorData;
   be_uint32_t LastWin32ErrorCode;
   be_ptr32_t<void> Win32CurrentFiber;
   UNKNOWN(0x4);
   be_uint32_t CreateOptions;
   UNKNOWN(0x100); // Unknown max size
};

CHECK_OFFSET(KThread, 0x00, Header);
CHECK_OFFSET(KThread, 0x10, MutantListHead);
CHECK_OFFSET(KThread, 0x18, Timer);
CHECK_OFFSET(KThread, 0x40, TimerWaitBlock);
CHECK_OFFSET(KThread, 0x58, KernelTime);
CHECK_OFFSET(KThread, 0x5c, InitialStack);
CHECK_OFFSET(KThread, 0x60, StackLimit);
CHECK_OFFSET(KThread, 0x64, KernelStack);
CHECK_OFFSET(KThread, 0x68, TlsData);
CHECK_OFFSET(KThread, 0x6c, State);
CHECK_OFFSET(KThread, 0x6d, Alerted);
CHECK_OFFSET(KThread, 0x6f, Alertable);
CHECK_OFFSET(KThread, 0x70, Priority);
CHECK_OFFSET(KThread, 0x71, FpuExceptionEnable);
CHECK_OFFSET(KThread, 0x72, CreateProcessType);
CHECK_OFFSET(KThread, 0x73, CurrentProcessType);
CHECK_OFFSET(KThread, 0x74, ApcState);
CHECK_OFFSET(KThread, 0x8b, ApcQueueable);
CHECK_OFFSET(KThread, 0x8c, ApcQueueLock);
CHECK_OFFSET(KThread, 0x90, ContextSwitches);
CHECK_OFFSET(KThread, 0x94, ReadyListEntry);
CHECK_OFFSET(KThread, 0x9c, MsrEnableMask);
CHECK_OFFSET(KThread, 0xa0, WaitStatus);
CHECK_OFFSET(KThread, 0xa4, WaitIrql);
CHECK_OFFSET(KThread, 0xa5, WaitMode);
CHECK_OFFSET(KThread, 0xa6, WaitNext);
CHECK_OFFSET(KThread, 0xa7, WaitReason);
CHECK_OFFSET(KThread, 0xa8, WaitBlockList);
CHECK_OFFSET(KThread, 0xb0, KernelApcDisable);
CHECK_OFFSET(KThread, 0xb4, Quantum);
CHECK_OFFSET(KThread, 0xb8, Saturation);
CHECK_OFFSET(KThread, 0xb9, BasePriority);
CHECK_OFFSET(KThread, 0xba, PriorityDecrement);
CHECK_OFFSET(KThread, 0xbb, DisableBoost);
CHECK_OFFSET(KThread, 0xbc, SuspendCount);
CHECK_OFFSET(KThread, 0xbd, Preempted);
CHECK_OFFSET(KThread, 0xbe, HasTerminated);
CHECK_OFFSET(KThread, 0xbf, CurrentProcessor);
CHECK_OFFSET(KThread, 0xc0, CurrentPrcb);
CHECK_OFFSET(KThread, 0xc4, AffinityPrcb);
CHECK_OFFSET(KThread, 0xc8, IdlePriorityClass);
CHECK_OFFSET(KThread, 0xc9, NormalPriorityClass);
CHECK_OFFSET(KThread, 0xca, TimeCriticalPriorityClass);
CHECK_OFFSET(KThread, 0xcb, HasAsyncTerminated);
CHECK_OFFSET(KThread, 0xcc, ActiveTimerListLock);
CHECK_OFFSET(KThread, 0xd0, StackAllocatedBase);
CHECK_OFFSET(KThread, 0xd4, SuspendApc);
CHECK_OFFSET(KThread, 0xfc, SuspendSemaphore);
CHECK_OFFSET(KThread, 0x110, ThreadListEntry);
CHECK_OFFSET(KThread, 0x118, Queue);
CHECK_OFFSET(KThread, 0x11c, QueueListEntry);
CHECK_OFFSET(KThread, 0x124, UserModeDispatcher);
CHECK_OFFSET(KThread, 0x128, UserModeTrapFrame);
CHECK_OFFSET(KThread, 0x130, CreateTime);
CHECK_OFFSET(KThread, 0x138, ExitTime);
CHECK_OFFSET(KThread, 0x140, ExitStatus);
CHECK_OFFSET(KThread, 0x144, ActiveTimerListHead);
CHECK_OFFSET(KThread, 0x14c, ThreadId);
CHECK_OFFSET(KThread, 0x150, StartAddress);
CHECK_OFFSET(KThread, 0x154, IrpList);
CHECK_OFFSET(KThread, 0x15c, DebugMonitorData);
CHECK_OFFSET(KThread, 0x160, LastWin32ErrorCode);
CHECK_OFFSET(KThread, 0x164, Win32CurrentFiber);
CHECK_OFFSET(KThread, 0x16c, CreateOptions);

// KPROCESS
struct KProcess
{
   KSpinLock ThreadListLock;
   KListEntry ThreadListHead;
   be_int32_t ThreadQuantum;
   be_uint32_t DirectoryTableBase;
   be_uint32_t ThreadCount;
   be_uint8_t IdlePriorityClass;
   be_uint8_t NormalPriorityClass;
   be_uint8_t TimeCriticalPriorityClass;
   be_uint8_t DisableQuantum;
   be_uint32_t DefaultKernelStackSize;
   be_ptr32_t<void> TlsStaticDataImage;
   be_uint32_t SizeOfTlsStaticData;
   be_uint32_t SizeOfTlsStaticDataImage;
   be_uint16_t SizeOfTlsSlots;
   be_uint8_t Terminating;
   be_uint8_t ProcessType;
   be_uint32_t TlsSlotBitmap[8];
   KSpinLock FileObjectListLock;
   KListEntry FileObjectListHead;
   be_ptr32_t<void> Win32DefaultHeapHandle;
   UNKNOWN(0x100); // Unknown max size
};

CHECK_OFFSET(KProcess, 0x00, ThreadListLock);
CHECK_OFFSET(KProcess, 0x04, ThreadListHead);
CHECK_OFFSET(KProcess, 0x0C, ThreadQuantum);
CHECK_OFFSET(KProcess, 0x10, DirectoryTableBase);
CHECK_OFFSET(KProcess, 0x14, ThreadCount);
CHECK_OFFSET(KProcess, 0x18, IdlePriorityClass);
CHECK_OFFSET(KProcess, 0x19, NormalPriorityClass);
CHECK_OFFSET(KProcess, 0x1a, TimeCriticalPriorityClass);
CHECK_OFFSET(KProcess, 0x1b, DisableQuantum);
CHECK_OFFSET(KProcess, 0x1c, DefaultKernelStackSize);
CHECK_OFFSET(KProcess, 0x20, TlsStaticDataImage);
CHECK_OFFSET(KProcess, 0x24, SizeOfTlsStaticData);
CHECK_OFFSET(KProcess, 0x28, SizeOfTlsStaticDataImage);
CHECK_OFFSET(KProcess, 0x2c, SizeOfTlsSlots);
CHECK_OFFSET(KProcess, 0x2e, Terminating);
CHECK_OFFSET(KProcess, 0x2f, ProcessType);
CHECK_OFFSET(KProcess, 0x30, TlsSlotBitmap);
CHECK_OFFSET(KProcess, 0x50, FileObjectListLock);
CHECK_OFFSET(KProcess, 0x54, FileObjectListHead);
CHECK_OFFSET(KProcess, 0x5C, Win32DefaultHeapHandle);

// KPRCB
struct KPrcb
{
   be_ptr32_t<KThread> CurrentThread;
   be_ptr32_t<KThread> NextThread;
   be_ptr32_t<KThread> IdleThread;
   be_uint8_t Number;
   PADDING(0x3);
   be_uint32_t SetMember;
   be_uint32_t DpcTime;
   be_uint32_t InterruptTime;
   be_uint32_t InterruptCount;
   be_uint32_t IpiFrozen;
   be_ptr32_t<void> CurrentPacket[3];
   be_uint32_t TargetSet;
   be_ptr32_t<void> WorkerRoutine;
   be_ptr32_t<KPrcb> SignalDone;
   be_uint32_t RequestSummary;
   be_uint32_t DpcInterruptRequested;
   KSpinLock DpcLock;
   KListEntry DpcListHead;
   be_uint32_t DpcRoutineActive;
   KSpinLock ReadyListLock;
   be_uint32_t IdleThreadActive;
   be_ptr32_t<void> DeferredReadyListHead;
   be_uint32_t ReadySummary;
   be_uint32_t ReadSummaryMask;
   KListEntry DispatcherReadyListHead[32];
   KDpc ThreadReaperDpc;
   KListEntry ThreadReaperListHead;
   KDpc SwitchProcessorThreadDpc;
};

CHECK_OFFSET(KPrcb, 0x00, CurrentThread);
CHECK_OFFSET(KPrcb, 0x04, NextThread);
CHECK_OFFSET(KPrcb, 0x08, IdleThread);
CHECK_OFFSET(KPrcb, 0x0C, Number);
CHECK_OFFSET(KPrcb, 0x10, SetMember);
CHECK_OFFSET(KPrcb, 0x14, DpcTime);
CHECK_OFFSET(KPrcb, 0x18, InterruptTime);
CHECK_OFFSET(KPrcb, 0x1C, InterruptCount);
CHECK_OFFSET(KPrcb, 0x20, IpiFrozen);
CHECK_OFFSET(KPrcb, 0x24, CurrentPacket);
CHECK_OFFSET(KPrcb, 0x30, TargetSet);
CHECK_OFFSET(KPrcb, 0x34, WorkerRoutine);
CHECK_OFFSET(KPrcb, 0x38, SignalDone);
CHECK_OFFSET(KPrcb, 0x3C, RequestSummary);
CHECK_OFFSET(KPrcb, 0x40, DpcInterruptRequested);
CHECK_OFFSET(KPrcb, 0x44, DpcLock);
CHECK_OFFSET(KPrcb, 0x48, DpcListHead);
CHECK_OFFSET(KPrcb, 0x50, DpcRoutineActive);
CHECK_OFFSET(KPrcb, 0x54, ReadyListLock);
CHECK_OFFSET(KPrcb, 0x58, IdleThreadActive);
CHECK_OFFSET(KPrcb, 0x5C, DeferredReadyListHead);
CHECK_OFFSET(KPrcb, 0x60, ReadySummary);
CHECK_OFFSET(KPrcb, 0x64, ReadSummaryMask);
CHECK_OFFSET(KPrcb, 0x68, DispatcherReadyListHead);
CHECK_OFFSET(KPrcb, 0x168, ThreadReaperDpc);
CHECK_OFFSET(KPrcb, 0x184, ThreadReaperListHead);
CHECK_OFFSET(KPrcb, 0x18c, SwitchProcessorThreadDpc);
CHECK_SIZE(KPrcb, 0x1a8);

// KPCR, per thread structure living on r13
struct KPcr
{
   be_ptr32_t<void> TlsData;
   be_uint32_t MsrEnableMask;
   be_uint16_t SoftwareInterrupt;
   be_uint16_t DpcFpuVpuStateSaved;
   be_uint8_t DpcCurrentProcessType;
   be_uint8_t QuantumEnd;
   be_uint8_t TimerRequest;
   be_uint8_t HvCr0Save;
   be_ptr32_t<KThread> FpuOwnerThread;
   be_ptr32_t<KThread> VpuOwnerThread;
   be_uint8_t CurrentIrql;
   be_uint8_t BackgroundSchedulingActive;
   be_uint16_t StartStopBackgroundScheduling;
   be_uint32_t TimerHand;
   be_uint64_t LrIarSave;
   be_uint64_t CrMsrSave;
   be_uint64_t Gpr13Save;
   be_uint64_t HvGpr1Save;
   be_uint64_t HvGpr3Save;
   be_uint64_t HvGpr4Save;
   be_uint64_t HvGpr5Save;
   be_uint32_t UserModeControl;
   be_ptr32_t<void> PanicStack;
   be_uint32_t DarSave;
   be_uint32_t DsisrSave;
   be_ptr32_t<void> DbgLastDpcRoutine;
   be_uint32_t OnInterruptStack;
   be_ptr32_t<void> StackBase;
   be_ptr32_t<void> StackLimit;
   be_ptr32_t<void> InterruptStackBase;
   be_ptr32_t<void> InterruptStackLimit;
   be_ptr32_t<void> InterruptRoutine[32];
   KPrcb PrcbData;
   be_ptr32_t<KPrcb> Prcb;
   UNKNOWN(0x4);
   be_ptr32_t<be_uint32_t> PixCurrent;
   be_ptr32_t<be_uint32_t> PixLimit;
   be_ptr32_t<be_uint32_t> ProfilerCurrent;
   be_ptr32_t<be_uint32_t> ProfilerLimit;
   be_uint32_t ProfilerFlags;
   PADDING(0x4);
   be_uint64_t Contention;
   be_ptr32_t<be_uint32_t> MonitorProfileData;
   UNKNOWN(0x100); // Unknown max size
};

CHECK_OFFSET(KPcr, 0x00, TlsData);
CHECK_OFFSET(KPcr, 0x04, MsrEnableMask);
CHECK_OFFSET(KPcr, 0x08, SoftwareInterrupt);
CHECK_OFFSET(KPcr, 0x0a, DpcFpuVpuStateSaved);
CHECK_OFFSET(KPcr, 0x0c, DpcCurrentProcessType);
CHECK_OFFSET(KPcr, 0x0d, QuantumEnd);
CHECK_OFFSET(KPcr, 0x0e, TimerRequest);
CHECK_OFFSET(KPcr, 0x0f, HvCr0Save);
CHECK_OFFSET(KPcr, 0x10, FpuOwnerThread);
CHECK_OFFSET(KPcr, 0x14, VpuOwnerThread);
CHECK_OFFSET(KPcr, 0x18, CurrentIrql);
CHECK_OFFSET(KPcr, 0x19, BackgroundSchedulingActive);
CHECK_OFFSET(KPcr, 0x1a, StartStopBackgroundScheduling);
CHECK_OFFSET(KPcr, 0x1c, TimerHand);
CHECK_OFFSET(KPcr, 0x20, LrIarSave);
CHECK_OFFSET(KPcr, 0x28, CrMsrSave);
CHECK_OFFSET(KPcr, 0x30, Gpr13Save);
CHECK_OFFSET(KPcr, 0x38, HvGpr1Save);
CHECK_OFFSET(KPcr, 0x40, HvGpr3Save);
CHECK_OFFSET(KPcr, 0x48, HvGpr4Save);
CHECK_OFFSET(KPcr, 0x50, HvGpr5Save);
CHECK_OFFSET(KPcr, 0x58, UserModeControl);
CHECK_OFFSET(KPcr, 0x5c, PanicStack);
CHECK_OFFSET(KPcr, 0x60, DarSave);
CHECK_OFFSET(KPcr, 0x64, DsisrSave);
CHECK_OFFSET(KPcr, 0x68, DbgLastDpcRoutine);
CHECK_OFFSET(KPcr, 0x6c, OnInterruptStack);
CHECK_OFFSET(KPcr, 0x70, StackBase);
CHECK_OFFSET(KPcr, 0x74, StackLimit);
CHECK_OFFSET(KPcr, 0x78, InterruptStackBase);
CHECK_OFFSET(KPcr, 0x7c, InterruptStackLimit);
CHECK_OFFSET(KPcr, 0x80, InterruptRoutine);
CHECK_OFFSET(KPcr, 0x100, PrcbData);
CHECK_OFFSET(KPcr, 0x2a8, Prcb);
CHECK_OFFSET(KPcr, 0x2b0, PixCurrent);
CHECK_OFFSET(KPcr, 0x2b4, PixLimit);
CHECK_OFFSET(KPcr, 0x2b8, ProfilerCurrent);
CHECK_OFFSET(KPcr, 0x2bc, ProfilerLimit);
CHECK_OFFSET(KPcr, 0x2c0, ProfilerFlags);
CHECK_OFFSET(KPcr, 0x2c8, Contention);
CHECK_OFFSET(KPcr, 0x2d0, MonitorProfileData);

// ANSI_STRING
struct KAnsiString
{
   be_uint16_t Length;
   be_uint16_t MaximumLength;
   be_ptr32_t<be_int8_t> Buffer;
};

CHECK_OFFSET(KAnsiString, 0x0, Length);
CHECK_OFFSET(KAnsiString, 0x2, MaximumLength);
CHECK_OFFSET(KAnsiString, 0x4, Buffer);
CHECK_SIZE(KAnsiString, 0x8);

// UNICODE_STRING
struct KUnicodeString
{
   be_uint16_t Length;
   be_uint16_t MaximumLength;
   be_ptr32_t<be_int16_t> Buffer;
};

CHECK_OFFSET(KUnicodeString, 0x0, Length);
CHECK_OFFSET(KUnicodeString, 0x2, MaximumLength);
CHECK_OFFSET(KUnicodeString, 0x4, Buffer);
CHECK_SIZE(KUnicodeString, 0x8);

// LDR_DATA_TABLE_ENTRY
struct KLdrDataTableEntry
{
   KListEntry InLoadOrderLinks;
   KListEntry InClosureOrderLinks;
   KListEntry InInitializationOrderLinks;
   be_ptr32_t<void> NtHeadersBase;
   be_ptr32_t<void> ImageBase;
   be_uint32_t SizeOfNtImage;
   KUnicodeString FullDllName;
   KUnicodeString BaseDllName;
   be_uint32_t Flags;
   be_uint32_t SizeOfFullImage;
   be_ptr32_t<void> EntryPoint;
   be_uint16_t LoadCount;
   be_uint16_t ModuleIndex;
   be_ptr32_t<void> DllBaseOriginal;
   be_uint32_t CheckSum;
   be_uint32_t ModuleLoadFlags;
   be_uint32_t TimeDateStamp;
   be_ptr32_t<void> LoadedImports;
   be_ptr32_t<void> XexHeaderBase;

   struct
   {
      be_ptr32_t<KLdrDataTableEntry> ClosureRoot;
      be_ptr32_t<KLdrDataTableEntry> TraversalParent;
   } asEntry;
};

CHECK_OFFSET(KLdrDataTableEntry, 0x0, InLoadOrderLinks);
CHECK_OFFSET(KLdrDataTableEntry, 0x8, InClosureOrderLinks);
CHECK_OFFSET(KLdrDataTableEntry, 0x10, InInitializationOrderLinks);
CHECK_OFFSET(KLdrDataTableEntry, 0x18, NtHeadersBase);
CHECK_OFFSET(KLdrDataTableEntry, 0x1c, ImageBase);
CHECK_OFFSET(KLdrDataTableEntry, 0x20, SizeOfNtImage);
CHECK_OFFSET(KLdrDataTableEntry, 0x24, FullDllName);
CHECK_OFFSET(KLdrDataTableEntry, 0x2c, BaseDllName);
CHECK_OFFSET(KLdrDataTableEntry, 0x34, Flags);
CHECK_OFFSET(KLdrDataTableEntry, 0x38, SizeOfFullImage);
CHECK_OFFSET(KLdrDataTableEntry, 0x3c, EntryPoint);
CHECK_OFFSET(KLdrDataTableEntry, 0x40, LoadCount);
CHECK_OFFSET(KLdrDataTableEntry, 0x42, ModuleIndex);
CHECK_OFFSET(KLdrDataTableEntry, 0x44, DllBaseOriginal);
CHECK_OFFSET(KLdrDataTableEntry, 0x48, CheckSum);
CHECK_OFFSET(KLdrDataTableEntry, 0x4c, ModuleLoadFlags);
CHECK_OFFSET(KLdrDataTableEntry, 0x50, TimeDateStamp);
CHECK_OFFSET(KLdrDataTableEntry, 0x54, LoadedImports);
CHECK_OFFSET(KLdrDataTableEntry, 0x58, XexHeaderBase);
CHECK_OFFSET(KLdrDataTableEntry, 0x5c, asEntry.ClosureRoot);
CHECK_OFFSET(KLdrDataTableEntry, 0x60, asEntry.TraversalParent);
CHECK_SIZE(KLdrDataTableEntry, 0x64);

using KSTATUS = uint64_t; // NTSTATUS
using KBOOL = uint64_t; // BOOL

#define KTRUE 1
#define KFALSE 0

#define KSTATUS_SUCCESS          static_cast<KSTATUS>(0x00000000)
#define KSTATUS_ABANDONED_WAIT   static_cast<KSTATUS>(0x00000080)
#define KSTATUS_TIMEOUT          static_cast<KSTATUS>(0x00000102)
#define KSTATUS_NO_MEMORY        static_cast<KSTATUS>(0xC0000017)

// KOBJECTS
enum KObjects
{
   EventNotificationObject = 0,
   EventSynchronizationObject = 1,
   MutantObject = 2,
   ProcessObject = 3,
   QueueObject = 4,
   SemaphoreObject = 5,
   ThreadObject = 6,
   GateObject = 7,
   TimerNotificationObject = 8,
   TimerSynchronizationObject = 9,
   Spare2Object = 10,
   Spare3Object = 11,
   Spare4Object = 12,
   Spare5Object = 13,
   Spare6Object = 14,
   Spare7Object = 15,
   Spare8Object = 16,
   Spare9Object = 17,
   ApcObject = 18,
   DpcObject = 19,
   DeviceQueueObject = 20,
   EventPairObject = 21,
   InterruptObject = 22,
   ProfileObject = 23,
   ThreadedDpcObject = 24,
   MaximumKernelObject = 25
};

#pragma pack(pop)

#endif // XBOXKRNL_NTSTRUCTS_H

```

`src/kernel/xboxkrnl/object.h`:

```h
#ifndef XBOXKRNL_OBJECT_H
#define XBOXKRNL_OBJECT_H

#include "kernel/xboxkrnl/xboxkrnl.h"
#include "kernel/xboxkrnl/ntstructs.h"

class Waitable
{
public:
   enum WaitStatus
   {
      Success,
      Timeout,
      Failure
   };

   virtual WaitStatus wait(uint32_t timeoutMS) = 0;
};

class Object
{
public:
   enum Type
   {
      Event
   };

protected:
   Object(Type type) :
      mType(type)
   {
   }

public:
   Type getType()
   {
      return mType;
   }

   virtual Waitable *getWaitable()
   {
      return nullptr;
   }

private:
   Type mType;
};

Object *
GetKernelObject(KDispatcherHeader *object);

uint64_t
KeSetEvent(ptr32_t<KEvent> object,
           uint32_t increment,
           uint32_t wait);

KSTATUS
KeWaitForSingleObject(ptr32_t<void> Object,
                      uint32_t WaitReason,
                      uint32_t WaitMode,
                      uint32_t Alertable,
                      ptr32_t<uint64_t> Timeout);

#endif // ifndef XBOXKRNL_OBJECT_H

```

`src/kernel/xboxkrnl/process.cpp`:

```cpp
#include "kernel/xboxkrnl/process.h"
#include "common/memory.h"
#include "xex/xex.h"
#include "system.h"
#include <memory>

std::unique_ptr<KProcess> gProcess;

uint8_t
KeGetCurrentProcessType()
{
   return static_cast<uint8_t>(ProcessType::User);
}

KProcess *
KeGetCurrentProcess()
{
   return gProcess.get();
}

KProcess *
KeInitializeProcess()
{
   gProcess = std::unique_ptr<KProcess> { new KProcess() };

   // Initialize TLS bitmap
   auto binary = gSystem.getBinary();
   auto slotSize = binary->header.tlsInfo.dataSize * binary->header.tlsInfo.slotCount;

   gProcess->SizeOfTlsSlots = slotSize;
   memset(gProcess->TlsSlotBitmap, 0xff, 8 * 4);

   return gProcess.get();
}

```

`src/kernel/xboxkrnl/process.h`:

```h
#ifndef XBOXKRNL_PROCESS_H
#define XBOXKRNL_PROCESS_H

#include "kernel/xboxkrnl/xboxkrnl.h"
#include "kernel/xboxkrnl/ntstructs.h"

enum class ProcessType
{
   Idle = 0,
   User = 1,
   System = 2
};

uint8_t
KeGetCurrentProcessType();

KProcess *
KeGetCurrentProcess();

KProcess *
KeInitializeProcess();

#endif // XBOXKRNL_PROCESS_H

```

`src/kernel/xboxkrnl/spinlock.cpp`:

```cpp
#include "kernel/xboxkrnl/spinlock.h"

uint64_t
KfAcquireSpinLock(KSpinLock lock)
{
   // Raise Irql to 2
   // Spin on lock
   return 0;
}

```

`src/kernel/xboxkrnl/spinlock.h`:

```h
#ifndef XBOXKRNL_SPINLOCK_H
#define XBOXKRNL_SPINLOCK_H

#include "kernel/xboxkrnl/xboxkrnl.h"
#include "kernel/xboxkrnl/ntstructs.h"

uint64_t
KfAcquireSpinLock(KSpinLock lock);

#endif

```

`src/kernel/xboxkrnl/thread.cpp`:

```cpp
#include "kernel/xboxkrnl/thread.h"
#include "kernel/xboxkrnl/process.h"

#include "common/memory.h"

#include "system.h"

#include <atomic>
#include <thread>

std::atomic_uint32_t gThreadIdCounter = 0;
_declspec(thread) Thread *gCurrentThread;


Thread::Thread(uint32_t stackSize,
               ptr32_t<void> apiThreadStartup,
               ptr32_t<void> startAddress,
               ptr32_t<void> startParameter,
               uint32_t flags) :
   mStackSize(stackSize),
   mApiThreadStartup(apiThreadStartup),
   mStartAddress(startAddress),
   mStartParameter(startParameter),
   mCreationFlags(flags),
   mID(++gThreadIdCounter),
   mState(nullptr)
{
   mThread = std::thread(&Thread::entry, this);
}

void *Thread::getState()
{
   return mState;
}

void Thread::setState(void *state)
{
   mState = state;
}

uint32_t Thread::getId()
{
   return mID;
}

uint32_t Thread::getHandle()
{
   assert(reinterpret_cast<uint64_t>(this) < 0xffffffff);
   return reinterpret_cast<uint32_t>(this);
}

ptr32_t<void> Thread::getStackBase()
{
   return reinterpret_cast<void *>(mStack.data() + mStackSize);
}

ptr32_t<void> Thread::getStartAddress()
{
   return mStartAddress;
}

ptr32_t<void> Thread::getStartParameter()
{
   return mStartParameter;
}

ptr32_t<KPcr> Thread::getPcr()
{
   return &mPCR;
}

void Thread::join()
{
   mThread.join();
}

// Entry point to thread
void Thread::entry()
{
   auto process = KeGetCurrentProcess();

   gCurrentThread = this;

   // Allocate stack
   mStack.resize(mStackSize);

   // Allocate TLS
   mTLS.resize(process->SizeOfTlsSlots);

   // Set up kpcr
   mPCR.PrcbData.CurrentThread = &mKThread;
   mPCR.TlsData = mTLS.data() + process->SizeOfTlsSlots;
   
   // Setup kthread
   mKThread.ThreadId = mID;
   mKThread.ApcState.Process = process;

   // Execute thread on CPU
   gSystem.resumeThread(this);
}

KSTATUS
ExCreateThread(ptr32_t<be_uint32_t> pHandle,
               uint32_t dwStackSize,
               ptr32_t<be_uint32_t> lpThreadId,
               ptr32_t<void> apiThreadStartup,
               ptr32_t<void> lpStartAddress,
               ptr32_t<void> lpParameter,
               uint32_t dwCreationFlagsMod)
{
   Thread *thread = new Thread {
      dwStackSize,
      apiThreadStartup,
      lpStartAddress,
      lpParameter,
      dwCreationFlagsMod
   };

   if (pHandle) {
      *pHandle = thread->getHandle();
   }

   if (lpThreadId) {
      *lpThreadId = thread->getId();
   }

   return KSTATUS_SUCCESS;
}

Thread *GetCurrentThread()
{
   return gCurrentThread;
}

```

`src/kernel/xboxkrnl/thread.h`:

```h
#ifndef XBOXKRNL_THREAD_H
#define XBOXKRNL_THREAD_H

#include "kernel/xboxkrnl/xboxkrnl.h"
#include "kernel/xboxkrnl/ntstructs.h"

#include <vector>
#include <thread>

class Thread
{
public:
   Thread(uint32_t stackSize,
          ptr32_t<void> apiThreadStartup,
          ptr32_t<void> startAddress,
          ptr32_t<void> startParameter,
          uint32_t flags);

   uint32_t getId();
   uint32_t getHandle();

   void *getState();
   void setState(void *state);

   ptr32_t<void> getStackBase();
   ptr32_t<void> getStartAddress();
   ptr32_t<void> getStartParameter();

   ptr32_t<KPcr> getPcr();

   void join();

private:
   void entry();

private:
   uint32_t mID;

   uint32_t mStackSize;
   uint32_t mCreationFlags;
   ptr32_t<void> mApiThreadStartup;
   ptr32_t<void> mStartAddress;
   ptr32_t<void> mStartParameter;
   std::thread mThread;

   void *mState; // State used by CPU interpreter
   KPcr mPCR;    // Structure in r13
   KThread mKThread;
   std::vector<uint8_t> mStack;
   std::vector<uint8_t> mTLS;
};

KSTATUS
ExCreateThread(ptr32_t<be_uint32_t> pHandle,
               uint32_t dwStackSize,
               ptr32_t<be_uint32_t> lpThreadId,
               ptr32_t<void> apiThreadStartup,
               ptr32_t<void> lpStartAddress,
               ptr32_t<void> lpParameter,
               uint32_t dwCreationFlagsMod);

Thread *GetCurrentThread();

#endif // ifndef XBOXKRNL_THREAD_H

```

`src/kernel/xboxkrnl/tls.cpp`:

```cpp
#include "kernel/xboxkrnl/tls.h"

//TODO: Un-windows-ify
#include <Windows.h>

KSpinLock KiTlsSlotBitmapLock;

uint64_t
KeTlsAlloc()
{
   return TlsAlloc();
}

KBOOL
KeTlsFree(uint32_t index)
{
   return TlsFree(index);
}

ptr32_t<void>
KeTlsGetValue(uint32_t index)
{
   return TlsGetValue(index);
}

KBOOL
KeTlsSetValue(uint32_t index, ptr32_t<void> value)
{
   return TlsSetValue(index, value);
}

```

`src/kernel/xboxkrnl/tls.h`:

```h
#ifndef XBOXKRNL_TLS_H
#define XBOXKRNL_TLS_H

#include "kernel/xboxkrnl/xboxkrnl.h"
#include "kernel/xboxkrnl/ntstructs.h"

extern KSpinLock
KiTlsSlotBitmapLock;

uint64_t
KeTlsAlloc();

KBOOL
KeTlsFree(uint32_t index);

ptr32_t<void>
KeTlsGetValue(uint32_t index);

KBOOL
KeTlsSetValue(uint32_t index, ptr32_t<void> value);

#endif // XBXKRNL_TLS_H

```

`src/kernel/xboxkrnl/version.cpp`:

```cpp
#include "kernel/xboxkrnl/version.h"
#include "common/memory.h"

KernelVersion XboxKrnlVersion;
KernelVersion XboxKrnlBaseVersion;

void xboxkrnlVersionInit()
{
   memset(&XboxKrnlVersion, 0, sizeof(KernelVersion));
   XboxKrnlVersion.Major = 2;
   XboxKrnlVersion.Minor = 0;
   XboxKrnlVersion.Build = 14448;
   XboxKrnlVersion.ApprovalType = 0x80;
   XboxKrnlVersion.QFE = 0;

   memset(&XboxKrnlBaseVersion, 0, sizeof(KernelVersion));
   XboxKrnlBaseVersion.Major = 2;
   XboxKrnlBaseVersion.Minor = 0;
   XboxKrnlBaseVersion.Build = 14448;
   XboxKrnlBaseVersion.ApprovalType = 0x80;
   XboxKrnlBaseVersion.QFE = 0;
}

```

`src/kernel/xboxkrnl/version.h`:

```h
#ifndef XBOXKRNL_VERSION_H
#define XBOXKRNL_VERSION_H

#include "kernel/xboxkrnl/xboxkrnl.h"
#include "common/bigendian.h"

#pragma pack(push, 1)

struct KernelVersion
{
   be_uint16_t Major;
   be_uint16_t Minor;
   be_uint16_t Build;
   be_uint8_t ApprovalType;
   be_uint8_t QFE;
};

CHECK_SIZE(KernelVersion, 0x8);

#pragma pack(pop)

extern KernelVersion
XboxKrnlVersion;

extern KernelVersion
XboxKrnlBaseVersion;

void xboxkrnlVersionInit();

#endif // ifndef XBOXKRNL_VERSION_H

```

`src/kernel/xboxkrnl/virtualmemory.cpp`:

```cpp
#include "kernel/xboxkrnl/virtualmemory.h"

#include "common/log.h"
#include "common/memory.h"

#include <Windows.h>

KSTATUS
NtAllocateVirtualMemory(ptr32_t<be_uint32_t> lpBaseAddress,
                        ptr32_t<be_uint32_t> lpRegionSize,
                        uint32_t dwAllocationType,
                        uint32_t dwProtect,
                        uint32_t dwFlags)
{
   uint32_t RegionSize = 0;
   uint32_t BaseAddress = 0;
   uint64_t result;

   if (lpBaseAddress) {
      BaseAddress = *lpBaseAddress;
   }

   if (lpRegionSize) {
      RegionSize = *lpRegionSize;
   }
   
   xDebug()
      << "NtAllocateVirtualMemory("
      << Log::hex(BaseAddress) << ", "
      << Log::hex(RegionSize) << ", "
      << Log::hex(dwAllocationType) << ", "
      << Log::hex(dwProtect) << ", "
      << Log::hex(dwFlags) << ")";

   result = reinterpret_cast<uint32_t>(VirtualAlloc(reinterpret_cast<LPVOID>(BaseAddress),
                                                    RegionSize,
                                                    dwAllocationType & 0xFFFF,
                                                    dwProtect));

   assert(result < 0xFFFFFFFFull);

   if (lpBaseAddress) {
      *lpBaseAddress = static_cast<uint32_t>(result);
   }

   return (result != 0) ? KSTATUS_SUCCESS : KSTATUS_NO_MEMORY;
}

```

`src/kernel/xboxkrnl/virtualmemory.h`:

```h
#ifndef XBOXKRNL_VIRTUAL_MEMORY_H
#define XBOXKRNL_VIRTUAL_MEMORY_H

#include "kernel/xboxkrnl/xboxkrnl.h"
#include "kernel/xboxkrnl/ntstructs.h"

KSTATUS
NtAllocateVirtualMemory(ptr32_t<be_uint32_t> lpBaseAddress,
                        ptr32_t<be_uint32_t> lpRegionSize,
                        uint32_t dwAllocationType,
                        uint32_t dwProtect,
                        uint32_t dwFlags);

#endif // ifndef XBOXKRNL_VIRTUAL_MEMORY_H

```

`src/kernel/xboxkrnl/xboxkrnl.cpp`:

```cpp
#include "kernel/xboxkrnl/xboxkrnl.h"

#include "kernel/xboxkrnl/criticalsection.h"
#include "kernel/xboxkrnl/debug.h"
#include "kernel/xboxkrnl/hardware.h"
#include "kernel/xboxkrnl/process.h"
#include "kernel/xboxkrnl/spinlock.h"
#include "kernel/xboxkrnl/thread.h"
#include "kernel/xboxkrnl/tls.h"
#include "kernel/xboxkrnl/version.h"
#include "kernel/xboxkrnl/virtualmemory.h"
#include "kernel/xboxkrnl/object.h"
#include "kernel/xboxkrnl/xex.h"

#include "kernel/module.h"
#include "system.h"

xboxkrnl::xboxkrnl() :
   Module("xboxkrnl.exe")
{
   // Register exports
   addExports();

   // Init any required submodules
   xboxkrnlXexInit();
   xboxkrnlVersionInit();
   xboxkrnlHardwareInit();
}

// Export ordinals
void xboxkrnl::addExports()
{
   exportFunction(13, ExCreateThread);
   //exportVariable(14, ExEventObjectType);

   //exportVariable(27, ExThreadObjectType);

   exportVariable(89, KeDebugMonitorData);

   exportFunction(102, KeGetCurrentProcessType);

   //exportVariable(173, KeTimeStampBundle);

   exportFunction(157, KeSetEvent);

   exportFunction(176, KeWaitForSingleObject);
   exportFunction(177, KfAcquireSpinLock);

   exportFunction(204, NtAllocateVirtualMemory);

   exportFunction(338, KeTlsAlloc);
   exportFunction(339, KeTlsFree);
   exportFunction(340, KeTlsGetValue);
   exportFunction(341, KeTlsSetValue);

   exportVariable(342, XboxHardwareInfo);
   exportVariable(343, XboxKrnlBaseVersion);
   exportVariable(344, XboxKrnlVersion);

   exportFunction(293, RtlEnterCriticalSection);

   exportFunction(299, RtlImageXexHeaderField);

   exportFunction(302, RtlInitializeCriticalSection);
   exportFunction(303, RtlInitializeCriticalSectionAndSpinCount);
   exportFunction(304, RtlLeaveCriticalSection);

   exportFunction(321, RtlTryEnterCriticalSection);

   exportVariable(403, XexExecutableModuleHandle);
   exportFunction(404, XexCheckExecutablePrivilege);
   exportFunction(405, XexGetModuleHandle);

   //exportVariable(430, ExLoadedCommandLine);

   //exportVariable(446, VdGlobalDevice);
   //exportVariable(447, VdGlobalXamDevice);
   //exportVariable(448, VdGpuClockInMHz);
   //exportVariable(449, VdHSIOCalibrationLock);

   //exportVariable(614, KeCertMonitorData);
}

```

`src/kernel/xboxkrnl/xboxkrnl.h`:

```h
#ifndef XBOXKRNL_H
#define XBOXKRNL_H

#include <stdint.h>
#include "common/structmacros.h"
#include "kernel/module.h"

class xboxkrnl : public Module
{
public:
   xboxkrnl();

private:
   void addExports();
};

#endif // XBOXKRNL_H

```

`src/kernel/xboxkrnl/xex.cpp`:

```cpp
#include "kernel/xboxkrnl/xex.h"
#include "kernel/xboxkrnl/xboxkrnl.h"
#include "kernel/xboxkrnl/process.h"
#include "common/memory.h"
#include "xex/xex.h"
#include "system.h"

be_ptr32_t<KLdrDataTableEntry> XexExecutableModuleHandle = nullptr;

uint32_t
XexGetModuleHandle(ptr32_t<char> lpModuleName,
                   ptr32_t<uint32_t> lpHandle)
{
   return -1;
}

uint64_t
XexCheckExecutablePrivilege(uint32_t priviledge)
{
   auto flags = gSystem.getBinary()->header.systemFlags.flags;
   return (flags >> priviledge) & 1;
}

ptr32_t<void>
RtlImageXexHeaderField(ptr32_t<xex::Binary> binary,
                       uint32_t key)
{
   for (auto &raw : binary->header.optionalRaw) {
      if (raw.key == key) {
         return raw.data.data();
      }
   }

   return 0;
}

void xboxkrnlXexInit()
{
   if (XexExecutableModuleHandle) {
      delete XexExecutableModuleHandle;
   }

   auto module = new KLdrDataTableEntry();
   module->XexHeaderBase = gSystem.getBinary();
   XexExecutableModuleHandle = module;
}

```

`src/kernel/xboxkrnl/xex.h`:

```h
#ifndef XBOXKRNL_XEX_H
#define XBOXKRNL_XEX_H

#include "kernel/xboxkrnl/xboxkrnl.h"
#include "kernel/xboxkrnl/ntstructs.h"

namespace xex
{
   struct Binary;
};

void xboxkrnlXexInit();

extern be_ptr32_t<KLdrDataTableEntry>
XexExecutableModuleHandle;

uint32_t
XexGetModuleHandle(ptr32_t<char> lpModuleName,
                   ptr32_t<uint32_t> lpHandle);
uint64_t
XexCheckExecutablePrivilege(uint32_t priviledge);

ptr32_t<void>
RtlImageXexHeaderField(ptr32_t<xex::Binary> binary,
                       uint32_t key);

#endif // ifndef XBOXKRNL_XEX_H

```

`src/main.cpp`:

```cpp
#include "system.h"
#include "common/log.h"

System gSystem;

int __cdecl main(int argc, char** argv)
{
   if (argc < 2) {
      xDebug() << "Usage: " << argv[0] << " <.xex file>";
      return -1;
   }

   /* Totally legal copy of the game. */
   if (!gSystem.load(argv[1])) {
      return 0;
   }

   gSystem.start();

   return 0;
}
```

`src/powerpc/cpu.h`:

```h
#ifndef PPC_CPU_H
#define PPC_CPU_H

#include "common/flags.h"
#include "common/bit_array.h"

#include <stdint.h>
#include <vector>

/* Registers are in Little Endian, Memory is in Big Endian */

namespace ppc
{

using reg_t  = uint64_t;
using ureg_t = uint64_t;
using sreg_t = int64_t;
using freg_t = double;

enum class Exceptions {
   SystemReset                  = 0x100,
   MachineCheck                 = 0x200,
   DSI                          = 0x300, /* Data Storage Interrupt */
   DataSegment                  = 0x380,
   ISI                          = 0x400, /* Instruction Storage Interrupt */
   InstructionSegment           = 0x480,
   ExternalInterrupt            = 0x500,
   Alignment                    = 0x600,
   Program                      = 0x700,
   ProgramFloatingPointEnabled  = 0x701,
   ProgramIllegalInstruction    = 0x702,
   ProgramPrivilegedInstruction = 0x704,
   ProgramTrap                  = 0x708,
   FpuUnavailable               = 0x800,
   Decrementer                  = 0x900,
   SystemCall                   = 0xC00,
   Trace                        = 0xD00,
   PerformanceMonitor           = 0xF00,
};

/* Floating-point Status and Control Register */
union Fpscr
{
   /* Floating-Point result flags
   C  <  >  =  ?
   1  0  0  0  1   Quiet NaN
   0  1  0  0  1  -Infinity
   0  1  0  0  0  -Normalised Number
   1  1  0  0  0  -Denormalised Number
   1  0  0  1  0  -Zero
   0  0  0  1  0  +Zero
   1  0  1  0  0  +Denormalized Number
   0  0  1  0  0  +Normalized Number
   0  0  1  0  1  +Infinity
   */

   enum FloatingPointResultFlags
   {
      ClassDescriptor   = 1 << 0, // C
      Negative          = 1 << 1, // <
      Positive          = 1 << 2, // >
      Equal             = 1 << 3, // =
      Unordered         = 1 << 4, // ?
   };

   uint32_t value;

   struct
   {
      uint32_t cr1 : 4;
      uint32_t : 28;
   };

   struct
   {
      bit_array_t<uint32_t, 4> crn;
   };

   struct
   {
      uint32_t fx : 1;        /* FP Exception: Any FP Exception has happened */
      uint32_t fex : 1;       /* FP Exception: Any enabled FP Exception has happened */
      uint32_t vx : 1;        /* FP Exception: Invalid Operation */
      uint32_t ox : 1;        /* FP Exception: Overflow */
      uint32_t ux : 1;        /* FP Exception: Underflow */
      uint32_t zx : 1;        /* FP Exception: Zero Divide */
      uint32_t xx : 1;        /* FP Exception: Inexact */
      uint32_t vxsnan : 1;    /* FP Exception: Invalid Operation for SNaN */
      uint32_t vxisi : 1;     /* FP Exception: Invalid Operation for [Inf - Inf] */
      uint32_t vxidi : 1;     /* FP Exception: Invalid Operation for [Inf / Inf] */
      uint32_t vxzdz : 1;     /* FP Exception: Invalid Operation for [Zero / Zero] */
      uint32_t vximz : 1;     /* FP Exception: Invalid Operation for [Inf * Zero] */
      uint32_t vxvc : 1;      /* FP Exception: Invalid Operation for Compare */
      uint32_t fr : 1;        /* FP State: Fraction Rounded */
      uint32_t fi : 1;        /* FP State: Inexact Fraction */
      uint32_t fprf : 5;      /* Floating-Point result flags */
      uint32_t _reserved : 1;
      uint32_t vxsoft : 1;    /* Enable FP Exception: Invalid Operation for Software Request */
      uint32_t vxsqrt : 1;    /* Enable FP Exception: Invalid Operation for Square Root */
      uint32_t vxcvi : 1;     /* Enable FP Exception: Invalid Operation for Integer Convert */
      uint32_t ve : 1;        /* Enable FP Exception: Invalid Operation */
      uint32_t oe : 1;        /* Enable FP Exception: Overflow */
      uint32_t ue : 1;        /* Enable FP Exception: Underflow */
      uint32_t ze : 1;        /* Enable FP Exception: Zero Divide */
      uint32_t xe : 1;        /* Enable FP Exception: Inexact */
      uint32_t ni : 1;        /* Non-IEEE mode */
      uint32_t rn : 2;        /* 00 nearest, 01 zero, 10 +inf, 11 -inf */
   };
};

/* Condition Register */
union Cr
{
   enum Cr0Flags
   {
      Negative        = 1 << 0,
      Positive        = 1 << 1,
      Zero            = 1 << 2,
      SummaryOverflow = 1 << 3,
   };

   enum Cr1Flags
   {
      FloatingPointException        = 1 << 0,
      FloatingPointEnabledException = 1 << 1,
      FloatingPointInvalidOperation = 1 << 2,
      FloatingPointOverflow         = 1 << 3,
   };

   enum CrNFlags
   {
      Less      = 1 << 0,
      Greater   = 1 << 1,
      Equal     = 1 << 2,
      Unordered = 1 << 3,
   };

   uint32_t value;

   struct
   {
      uint32_t cr0 : 4;
      uint32_t cr1 : 4;
      uint32_t cr2 : 4;
      uint32_t cr3 : 4;
      uint32_t cr4 : 4;
      uint32_t cr5 : 4;
      uint32_t cr6 : 4;
      uint32_t cr7 : 4;
   };

   struct
   {
      bit_array_t<uint32_t, 4> crn;
   };

   struct
   {
      bit_array_t<uint32_t, 1> crb;
   };
};

/* XER Register */
union Xer
{
   uint64_t value;

   struct {
      uint64_t : 32;
      uint64_t so : 1;        /* Sticky OV */
      uint64_t ov : 1;        /* Overflow */
      uint64_t ca : 1;        /* Carry */
      uint64_t : 22;
      uint64_t byteCount : 7; /* For lmwx, stmwx */
   };
};

/* Machine State Register */
union Msr
{
   uint64_t value;

   struct
   {
      uint64_t sf : 1;  /* 64 bit mode */
      uint64_t : 44;
      uint64_t pow : 1; /* Power Management Enabled */
      uint64_t : 1;
      uint64_t ile : 1; /* Little Endian Mode, copied to le on interrupt */
      uint64_t ee : 1;  /* External Interrupt Enabled */
      uint64_t pr : 1;  /* Privilege Level */
      uint64_t fp : 1;  /* Floating-point Available */
      uint64_t me : 1;  /* Machine Check Enabled */
      uint64_t fe0 : 1; /* Floating-point Exception Mode 0 */
      uint64_t se : 1;  /* Single-step Trace Enabled */
      uint64_t be : 1;  /* Branch Trace Enable */
      uint64_t fe1 : 1; /* Floating-point Exception Mode 1 */
      uint64_t : 2;
      uint64_t ir : 1;  /* Instruction Address Translation Enabled */
      uint64_t dr : 1;  /* Data Address Translation Enabled */
      uint64_t : 1;
      uint64_t pmm : 1; /* Performance Monitor Mark */
      uint64_t ri : 1;  /* Recoverable Exception */
      uint64_t le : 1;  /* Little Endian Mode */
   };
};

/* Processor Version Register */
union Pvr
{
   uint32_t value;

   struct
   {
      uint32_t version : 16;
      uint32_t revision : 16;
   };
};

/* SDR1 Register */
union SDR1
{
   uint64_t value;

   struct
   {
      uint64_t htaborg : 46;
      uint64_t : 13;
      uint64_t htabsize : 5;
   };
};

/* Segment Lookaside Buffer (7.4.2.1) */
struct SlbEntry
{
   int valid : 1;      /* Entry Valid */
   uint64_t esid : 36; /* Effective Segment ID */
   uint64_t vsid : 52; /* Virtual Segment ID */
   int Ks : 1;         /* Supervisor State Storage Key */
   int Kp : 1;         /* User (Problem) State Storage Key */
   int N : 1;          /* No Execute Segment */
   int L : 1;          /* Large Virtual Pages */
   int C : 1;          /* Class */
};

struct Registers
{
   /* User Model UISA */
   reg_t gpr[32];    /* 32 General Purpose Registers */
   freg_t fpr[32];   /* 32 Floating Point Registers */
   Cr cr;            /* Condition Register 8x 4bit cr0-cr7 */
   Fpscr fpscr;      /* Floating Point Status & Control Register */
   Xer xer;          /* Fixed-Point Exception Register */
   uint64_t lr;      /* Link Register */
   uint64_t ctr;     /* Count Register */

   /* User Model VEA */
   uint32_t tbu;     /* Time Base Upper */
   uint32_t tbl;     /* Time Base Lower */

   /* Configuration Registers */
   Msr msr;          /* Machine State Register */
   uint32_t pvr;     /* Processor Version Register */

   /* Memory Management Registers */
   uint64_t sdr1;
   uint64_t asr;     /* Address Space Register */
   std::vector<SlbEntry> slb; /* Segment Lookaside Buffer */

   /* Exception Handling Registers */
   Flags<Exceptions> exception;
   uint64_t dar;     /* Data Address Register */
   uint32_t dsisr;
   uint64_t srr0;    /* Save and Restore Registers */
   uint64_t srr1;
   uint64_t sprg0;   /* Software use SPRs */
   uint64_t sprg1;
   uint64_t sprg2;
   uint64_t sprg3;
   uint64_t fpecr;   /* Floating-Point Exception Cause Register */

   /* Misc. Registers */
   uint32_t dec;     /* Decrementer Register */
   uint64_t dabr;    /* Data Address Breakpoint Register */
   uint64_t pir;     /* Processor Identification Register */
   uint32_t ear;     /* External Access Register */
   uint64_t ctrl;    /* Control Register */
   uint64_t iabr;    /* Instruction Address Breakpoint Register */

   /* Reserve load/store */
   uint32_t reserve;
   uint64_t reserveAddress;
   
   /* ID mappings for spr */
   enum spr {   
      XER      = 1,
      LR       = 8,
      CTR      = 9,

      DSISR    = 18,
      DAR      = 19,

      DEC      = 22,
      SDR1     = 25,
      SRR0     = 26,
      SRR1     = 27,

      SPRG0    = 272,
      SPRG1    = 273,
      SPRG2    = 274,
      SPRG3    = 275,

      ASR      = 280,
      EAR      = 282,
      TBU      = 284,
      TBL      = 285,

      DABR     = 1013,

      /* Not used in mtspr/mfspr */
      FPECR,
      FPSCR,
      CR,
      MSR,
      PVR,
      PIR,
      CTRL,
      IABR
   };

   uint64_t getSpr(uint32_t id)
   {
      switch (id) {
      case Registers::XER:
         return xer.value;
      case Registers::LR:
         return lr;
      case Registers::CTR:
         return ctr;
      case Registers::DSISR:
         return dsisr;
      case Registers::DAR:
         return dar;
      case Registers::DEC:
         return dec;
      case Registers::SDR1:
         return sdr1;
      case Registers::SRR0:
         return srr0;
      case Registers::SRR1:
         return srr1;
      case Registers::SPRG0:
         return sprg0;
      case Registers::SPRG1:
         return sprg1;
      case Registers::SPRG2:
         return sprg2;
      case Registers::SPRG3:
         return sprg3;
      case Registers::ASR:
         return asr;
      case Registers::EAR:
         return ear;
      case Registers::TBU:
         return tbu;
      case Registers::TBL:
         return tbl;
      case Registers::DABR:
         return dabr;
      case Registers::FPECR:
         return fpecr;
      case Registers::FPSCR:
         return fpscr.value;
      case Registers::CR:
         return cr.value;
      case Registers::MSR:
         return msr.value;
      case Registers::PVR:
         return pvr;
      case Registers::PIR:
         return pir;
      case Registers::CTRL:
         return ctrl;
      case Registers::IABR:
         return iabr;
      default:
         return 0;
      }
   }
   
   void setSpr(uint32_t id, uint64_t value)
   {
      switch (id) {
      case Registers::XER:
         xer.value = value;
         break;
      case Registers::LR:
         lr = value;
         break;
      case Registers::CTR:
         ctr = value;
         break;
      case Registers::DSISR:
         dsisr = static_cast<uint32_t>(value);
         break;
      case Registers::DAR:
         dar = value;
         break;
      case Registers::DEC:
         dec = static_cast<uint32_t>(value);
         break;
      case Registers::SDR1:
         sdr1 = value;
         break;
      case Registers::SRR0:
         srr0 = value;
         break;
      case Registers::SRR1:
         srr1 = value;
         break;
      case Registers::SPRG0:
         sprg0 = value;
         break;
      case Registers::SPRG1:
         sprg1 = value;
         break;
      case Registers::SPRG2:
         sprg2 = value;
         break;
      case Registers::SPRG3:
         sprg3 = value;
         break;
      case Registers::ASR:
         asr = value;
         break;
      case Registers::EAR:
         ear = static_cast<uint32_t>(value);
         break;
      case Registers::TBU:
         tbu = static_cast<uint32_t>(value);
         break;
      case Registers::TBL:
         tbl = static_cast<uint32_t>(value);
         break;
      case Registers::DABR:
         dabr = value;
         break;
      case Registers::FPECR:
         fpecr = value;
         break;
      case Registers::FPSCR:
         fpscr.value = static_cast<uint32_t>(value);
         break;
      case Registers::CR:
         cr.value = static_cast<uint32_t>(value);
         break;
      case Registers::MSR:
         msr.value = value;
         break;
      case Registers::PVR:
         pvr = static_cast<uint32_t>(value);
         break;
      case Registers::PIR:
         pir = value;
         break;
      case Registers::CTRL:
         ctrl = value;
         break;
      case Registers::IABR:
         iabr = value;
         break;
      }
   }
};
#if 0
/* Instructions are loaded from memory and thus are in Big Endian format*/
struct Instruction
{
   Instruction(){}
   Instruction(uint32_t v){ value = v; }
   operator uint32_t() { return value; }

   union {
      uint32_t value;

      struct {
         uint32_t rc : 1;     /* Record Bit */
         uint32_t subop10 : 10;
         uint32_t rB : 5;
         uint32_t rA : 5;
         uint32_t rD : 5;     /* GPRs*/
         uint32_t opcode : 6;
      };

      struct {
         uint32_t : 1; 
         uint32_t subop9_oe : 9;
         uint32_t oe : 1;     /* Setting OV/SO in XER */
         uint32_t : 21;
      };

      struct {
         uint32_t : 11;
         uint32_t spr : 10;
         uint32_t : 11;
      };

      struct
      {
         uint32_t: 11;
         uint32_t tbr : 10;
         uint32_t: 11;
      };

      struct {
         uint32_t lk : 1;
         uint32_t aa : 1;
         uint32_t li : 24;
         uint32_t : 5;
      };

      struct {
         uint32_t : 2;
         uint32_t ds : 14;
         uint32_t : 5;
         uint32_t rS : 5;
         uint32_t : 6;
      };

      struct {
         uint32_t d : 16;
         uint32_t : 16;
      };

      struct {
         uint32_t uimm : 16;
         uint32_t : 16;
      };

      struct {
         uint32_t simm : 16;
         uint32_t : 16;
      };

      struct
      {
         uint32_t : 12;
         uint32_t imm : 4;
         uint32_t : 16;
      };

      struct {
         uint32_t : 11;
         uint32_t bh : 2;
         uint32_t : 3;
         uint32_t bi : 5;
         uint32_t bo : 5;
         uint32_t : 6;
      };

      struct {
         uint32_t : 2;
         uint32_t bd : 14;
         uint32_t : 16;
      };

      struct {
         uint32_t: 18;
         uint32_t crfS : 3;
         uint32_t l : 1;
         uint32_t : 1;
         uint32_t crfD : 3;
         uint32_t : 6;
      };

      struct {
         uint32_t : 21;
         uint32_t syncl : 2;
         uint32_t : 9;
      };

      struct {
         uint32_t  : 11;
         uint32_t crbB : 5;
         uint32_t crbA : 5;
         uint32_t crbD : 5;
         uint32_t  : 6;
      };

      struct {
         uint32_t : 21;
         uint32_t th : 2;
         uint32_t : 9;
      };

      struct {
         uint32_t : 1;
         uint32_t subop5 : 5;
         uint32_t frC : 5;
         uint32_t frB : 5;
         uint32_t frA : 5;
         uint32_t frD : 5;
         uint32_t : 6;
      };

      struct {
         uint32_t : 21;
         uint32_t frS : 5;
         uint32_t : 6;
      };

      struct
      {
         uint32_t : 12;
         uint32_t crm : 8;
         uint32_t : 12;
      };

      struct
      {
         uint32_t : 16;
         uint32_t sr : 4;
         uint32_t : 12;
      };

      struct
      {
         uint32_t: 17;
         uint32_t fm : 8;
         uint32_t: 7;
      };

      struct
      {
         uint32_t : 16;
         uint32_t l15 : 1;
         uint32_t : 15;
      };

      struct
      {
         uint32_t : 1;
         uint32_t shd5 : 1;  /* shd[5] */
         uint32_t : 3;
         uint32_t mbd : 6;
         uint32_t shd04 : 5; /* shd[0-4] */
         uint32_t : 16;
      };

      struct
      {
         uint32_t : 5;
         uint32_t med : 6;
         uint32_t : 21;
      };

      struct
      {
         uint32_t: 1;
         uint32_t me : 5;
         uint32_t mb : 5;
         uint32_t sh : 5;
         uint32_t: 16;
      };

      struct
      {
         uint32_t : 21;
         uint32_t to : 5;
         uint32_t : 6;
      };
      
      struct
      {
         uint32_t : 11;
         uint32_t nb : 5;
         uint32_t : 16;
      };
      
      struct
      {
         uint32_t : 21;
         uint32_t tlbl : 1;
         uint32_t : 10;
      };
   };
};
#endif

#include "emugen_cpu_info.h"

} // namespace ppc

#endif // PPC_CPU_H

```

`src/powerpc/decoder.cpp`:

```cpp
#include "cpu.h"
#include "decoder.h"
#include "instructions.h"

using namespace ppc;

#include "../common/emugen_types.h"

using emugen::DecodeEntry;

namespace ppc
{
#include "emugen_decoder.h"
};

struct InitOnLoad
{
   InitOnLoad()
   {
      ppc::init();
   }
};

InitOnLoad g_initOnLoad;

```

`src/powerpc/decoder.h`:

```h
#ifndef PPC_DECODER_H
#define PPC_DECODER_H

#include "cpu.h"
#include "instructions.h"

namespace ppc
{
   InstructionID decode(Instruction instr);
};

#endif

```

`src/powerpc/disassembler/disassembler.cpp`:

```cpp
#include "disassembler.h"

#include "powerpc/instructions.h"
#include "powerpc/decoder.h"
#include "powerpc/cpu.h"

#include "common/log.h"

#include <sstream>
#include <iomanip>
#include <map>
#include <assert.h>

std::map<unsigned, std::string> g_sprNames {
   { ppc::Registers::XER,   "XER" },
   { ppc::Registers::LR,    "LR" },
   { ppc::Registers::CTR,   "CTR" },
   { ppc::Registers::DSISR, "DSISR" },
   { ppc::Registers::DAR,   "DAR" },
   { ppc::Registers::DEC,   "DEC" },
   { ppc::Registers::SDR1,  "SDR1" },
   { ppc::Registers::SRR0,  "SRR0" },
   { ppc::Registers::SRR1,  "SRR1" },
   { ppc::Registers::SPRG0, "SPRG0" },
   { ppc::Registers::SPRG1, "SPRG1" },
   { ppc::Registers::SPRG2, "SPRG2" },
   { ppc::Registers::SPRG3, "SPRG3" },
   { ppc::Registers::ASR,   "ASR" },
   { ppc::Registers::EAR,   "EAR" },
   { ppc::Registers::TBU,   "TBU" },
   { ppc::Registers::TBL,   "TBL" },
   { ppc::Registers::DABR,  "DABR" },
};

namespace ppc
{

namespace Disassembler
{

std::string getSPRName(unsigned id)
{
   auto itr = g_sprNames.find(id);

   if (itr == g_sprNames.end()) {
      return "spr" + std::to_string(id);
   } else {
      return itr->second;
   }
}

Result::Arg disField(State *state, Instruction instr, ppc::Field field)
{
   Result::Arg arg;
   arg.type = Result::Invalid;

   switch (field) {
   case Fields::bd:
      arg.type = Result::Address;

      if (instr.aa) {
         arg.address = little_endian::signExtend<16>(static_cast<uint64_t>(instr.bd) << 2);
      } else {
         arg.address = state->cia + little_endian::signExtend<16>(static_cast<uint64_t>(instr.bd) << 2);
      }
      break;
   case Fields::crfD:
      arg.type = Result::Register;
      arg.text = "cr" + std::to_string(instr.crfD);
      break;
   case Fields::crfS:
      arg.type = Result::Register;
      arg.text = "cr" + std::to_string(instr.crfS);
      break;
   case Fields::d:
      arg.type = Result::ConstantSigned;
      arg.constantSigned = little_endian::signExtend<16, int64_t>(instr.d);
      break;
   case Fields::ds:
      arg.type = Result::ConstantSigned;
      arg.constantSigned = little_endian::signExtend<16>(static_cast<int64_t>(instr.ds) << 2);
      break;
   case Fields::l:
      arg.type = Result::Constant;
      arg.constant = instr.l;
      break;
   case Fields::frA:
      arg.type = Result::Register;
      arg.text = "f" + std::to_string(instr.frA);
      break;
   case Fields::frB:
      arg.type = Result::Register;
      arg.text = "f" + std::to_string(instr.frB);
      break;
   case Fields::frC:
      arg.type = Result::Register;
      arg.text = "f" + std::to_string(instr.frC);
      break;;
   case Fields::frD:
      arg.type = Result::Register;
      arg.text = "f" + std::to_string(instr.frD);
      break;
   case Fields::frS:
      arg.type = Result::Register;
      arg.text = "f" + std::to_string(instr.frS);
      break;
   case Fields::li:
      arg.type = Result::Address;

      if (instr.aa) {
         arg.address = little_endian::signExtend<26>(static_cast<uint64_t>(instr.li) << 2);
      } else {
         arg.address = state->cia + little_endian::signExtend<26>(static_cast<uint64_t>(instr.li) << 2);
      }
      break;
   case Fields::simm:
      arg.type = Result::ConstantSigned;
      arg.constantSigned = little_endian::signExtend<16, int64_t>(instr.simm);
      break;
   case Fields::rA:
      arg.type = Result::Register;
      arg.text = "r" + std::to_string(instr.rA);
      break;
   case Fields::rB:
      arg.type = Result::Register;
      arg.text = "r" + std::to_string(instr.rB);
      break;
   case Fields::rD:
      arg.type = Result::Register;
      arg.text = "r" + std::to_string(instr.rD);
      break;
   case Fields::rS:
      arg.type = Result::Register;
      arg.text = "r" + std::to_string(instr.rS);
      break;
   case Fields::spr:
      arg.type = Result::Register;
      arg.text = g_sprNames[(instr.spr >> 5) & 0x1f | (instr.spr & 0x1f)];
      break;
   case Fields::xo1:
   case Fields::xo2:
   case Fields::xo3:
   case Fields::xo4:
   case Fields::xo5:
   case Fields::xo6:
   case Fields::xo7:
   case Fields::xo8:
   case Fields::bi:
   case Fields::bo:
   case Fields::bh:
   case Fields::crbA:
   case Fields::crbB:
   case Fields::crbD:
   case Fields::crm:
   case Fields::uimm:
   case Fields::th:
   case Fields::sr:
   case Fields::tbr:
   case Fields::fm:
   case Fields::nb:
   case Fields::l15:
   case Fields::syncl:
   case Fields::tlbl:
   case Fields::sh:
   case Fields::shd04:
   case Fields::shd5:
   case Fields::mb:
   case Fields::mbd:
   case Fields::me:
   case Fields::med:
   case Fields::to:
   case Fields::aa:
   case Fields::lk:
   case Fields::oe:
   case Fields::rc:
      arg.type = Result::Constant;
      arg.constant = instr.get(field);
      break;
   default:
      assert(0 && "Unknown field in disField");
   }

   return arg;
}

std::string resArgToText(Result::Arg &arg)
{
   std::stringstream ss;

   switch (arg.type) {
   case Result::Address:
      ss << std::hex << "0x" << arg.address;
      return ss.str();
   case Result::Register:
      return arg.text;
   case Result::Constant:
      return std::to_string(arg.constant);
   case Result::ConstantSigned:
      return std::to_string(arg.constantSigned);
   }

   return std::string();
}

enum BO
{
   CtrValue = 1 << 1,
   NoCheckCtr = 1 << 2,
   CondValue = 1 << 3,
   NoCheckCond = 1 << 4
};

bool disBranchConditional(State *state, Instruction instr)
{
   auto bo = instr.bo;
   auto bi = instr.bi;

   auto ctrValue      = bo & (1 << 1);
   auto noDecrement   = bo & (1 << 2);
   auto condTrue      = bo & (1 << 3);
   auto unconditional = bo & (1 << 4);

   auto crf = bi >> 2;
   auto crb = bi & 0x3;

   auto a = 0;
   auto t = 0;

   std::string result = "b";

   if (!unconditional && noDecrement) {
      a = bo & 2;
      t = bo & 1;

      if (condTrue) {
         switch (crb) {
         case 0:
            result += "lt";
            break;
         case 1:
            result += "gt";
            break;
         case 2:
            result += "eq";
            break;
         case 3:
            result += "so";
            break;
         }
      } else {
         switch (crb) {
         case 0:
            result += "ge";
            break;
         case 1:
            result += "le";
            break;
         case 2:
            result += "neq";
            break;
         case 3:
            result += "ns";
            break;
         }
      }
   } else {
      if (noDecrement == 0) {
         result += "d";

         if (ctrValue == 0) {
            result += "nz";
         } else {
            result += "z";
         }
      }

      if (!unconditional) {
         if (condTrue) {
            result += "t";
         } else {
            result += "f";
         }
      }

      if (unconditional && noDecrement == 0) {
         a = bo & 8;
         t = bo & 1;
      }
   }

   if (ppc::isa<ppc::InstructionID::bclr>(instr)) {
      result += "lr";
   } else if (ppc::isa<ppc::InstructionID::bcctr>(instr)) {
      result += "ctr";
   }

   if (instr.lk) {
      result += "l";
   }

   if (ppc::isa<ppc::InstructionID::bc>(instr)) {
      if (instr.aa) {
         result += "a";
      }
   }

   if (a && !t) {
      result += "-";
   } else if (a && t) {
      result += "+";
   }

   state->result.name = result;
   return true;
}

bool decode(State *state, Instruction instr)
{
   auto id = ppc::decode(instr);

   if (id == InstructionID::Unknown) {
      return false;
   }

   auto &data = ppc::getInstruction(id);

   state->result.name = data.name;
   state->result.fullname = data.fullname;

   for (auto &out : data.outputs) {
      state->result.args.push_back(disField(state, instr, out));
   }

   for (auto &in : data.inputs) {
      state->result.args.push_back(disField(state, instr, in));
   }

   for (auto &mod : data.mods) {
      switch (mod) {
      case Fields::aa:
         if (instr.aa) {
            state->result.name += 'a';
         }
         break;
      case Fields::oe:
         if (instr.oe) {
            state->result.name += 'o';
         }
         break;
      case Fields::rc:
         if (instr.rc) {
            state->result.name += '.';
         }
         break;
      }
   }

   if (ppc::isa<ppc::InstructionID::bc>(instr) || ppc::isa<ppc::InstructionID::bclr>(instr) || ppc::isa<ppc::InstructionID::bcctr>(instr)) {
      disBranchConditional(state, instr);
   }

   state->result.disasm = state->result.name;

   for (auto &arg : state->result.args) {
      if (&arg == &state->result.args[0]) {
         state->result.disasm += " ";
      } else {
         state->result.disasm += ", ";
      }

      state->result.disasm += resArgToText(arg);
   }

   return true;
}

} // namespace Disassembler

} //namespace ppc

```

`src/powerpc/disassembler/disassembler.h`:

```h
#ifndef PPC_DISASSEMBLER_H
#define PPC_DISASSEMBLER_H

#include "powerpc/cpu.h"

#include <string>

namespace ppc
{

namespace Disassembler
{

struct Result
{
   enum Type
   {
      Invalid,
      Register,
      Constant,
      ConstantSigned,
      Address
   };

   struct Arg
   {
      Type type;
      std::string text;

      union
      {
         uint64_t address;
         uint64_t constant;
         int64_t constantSigned;
      };
   };

   std::string name;
   std::string fullname;
   std::string disasm;
   std::vector<Arg> args;
};

struct State
{
   uint64_t cia;
   Result result;
};

bool decode(State *state, Instruction instr);

} // namespace Disassembler

} // namespace ppc

#endif // PPC_DISASSEMBLER_H

```

`src/powerpc/emugen.txt`:

```txt
[Architecture]
Endian = BigEndian

[Registers]
// User Model UISA
gpr = uint64[32]                       // 32 General Purpose Registers
fpr = double[32]                       // 32 Floating Point Registers
cr = uint32 {                          // Condition Registers
   cr0 = 0...3
   cr1 = 4...7
   cr2 = 8...11
   cr3 = 12...15
   cr4 = 16...19
   cr5 = 20...23
   cr6 = 24...27
   cr7 = 28...32
}
fpscr = uint32 {
   fx = 0
   fex = 1
   vx = 2
   ox = 3
   ux = 4
   zx = 5
   xx = 6
   vxsnan = 7
   vxisi = 8
   vxidi = 9
   vxzdz = 10
   vximz = 11
   vxvc = 12
   fr = 13
   fi = 14
   fprf = 15...19
   vxsoft = 21
   vxsqrt = 22
   vxcvi = 23
   ve = 24
   oe = 25
   ue = 26
   ze = 27
   xe = 28
   ni = 29
   rn = 30...31                        // Rounding mode
}
xer = uint64 {
   so = 32                             // Summary Overflow
   ov = 33                             // Overflow
   ca = 34                             // Carry
   bt = 57...63                        // Bytes transferred in lswx/stswx
}
lr  = uint64                           // Link Register
ctr = uint64                           // Count Register

// User Model VEA
tbu = uint32                           // Time Base Upper
tbl = uint32                           // Time Base Lower

// Configuration Registers
msr = uint64                           // Machine State Register
pvr = uint32                           // Processor Version Register

// Memory Management Registers
sdr1 = uint64
asr  = uint64                          // Address Space Register

// Exception Handling Registers
dar   = uint64                         // Data Address Register
dsisr = uint32
srr0  = uint64                         // Save and Restore Registers
srr1  = uint64
sprg0 = uint64                         // Software use SPRs
sprg1 = uint64
sprg2 = uint64
sprg3 = uint64
fpecr = uint64                         // Floating-Point Exception Cause Register

// Misc. Registers
dec  = uint32                          // Decrementer Register
dabr = uint64                          // Data Address Breakpoint Register
pir  = uint64                          // Processor Identification Register
ear  = uint32                          // External Access Register
ctrl = uint64                          // Control Register
iabr = uint64                          // Instruction Address Breakpoint Register

[Instruction Format]
// Opcodes
xo1 = 0...5
xo2 = 21...30
xo3 = 22...30
xo4 = 26...30
xo5 = 30...31
xo6 = 11
xo7 = 27...30
xo8 = 27...29

// Instruction data
bd    = 16...29
bi    = 11...15
bo    =  6...10
bh    = 19...20
crbA  = 11...15
crbB  = 16...20
crbD  =  6...10
crfD  =  6...8
crfS  = 11...13
d     = 16...31
ds    = 16...29
frA   = 11...15 : map = "fpr"
frB   = 16...20 : map = "fpr"
frC   = 21...25 : map = "fpr"
frD   =  6...10 : map = "fpr"
frS   =  6...10 : map = "fpr"
uimm  = 16...31
simm  = 16...31
l     =  9...10
li    =  6...29
rA    = 11...15 : map = "gpr"
rB    = 16...20 : map = "gpr"
rD    =  6...10 : map = "gpr"
rS    =  6...10 : map = "gpr"
spr   = 11...20
th    =  9...10
sr    = 12...15
tbr   = 11...20
crm   = 12...19
fm    =  7...14
nb    = 16...20
l15   = 15
syncl =  9...10
tlbl  = 10
sh    = 16...20
shd04 = 16...20
shd5  = 30
mb    = 21...25
mbd   = 21...26
me    = 26...30
med   = 21...26
to    = 6...10

// aa and lk effects branch instruction names
aa = 30 : name = "name + 'a'"
lk = 31 : name = "name + 'l'"

// oe and rc effects arith instruction names
oe = 21 : name = "name + '.'"
rc = 31 : name = "name + 'o'"

[xo1]
  14 : addi    +rD, rA, simm                   : fullname = "Add Immediate"
  12 : addic   +rD, rA, simm                   : fullname = "Add Immediate Carrying"
  13 : addic.  +rD, rA, simm                   : fullname = "Add Immediate Carrying and Record"
  15 : addis   +rD, rA, simm                   : fullname = "Add Immediate Shifted"
  28 : andi.   +rA, rS, uimm                   : fullname = "AND Immediate"
  29 : andis.  +rA, rS, uimm                   : fullname = "AND Immediate Shifted"
  18 : b       li                              : fullname = "Branch", lk, aa
  16 : bc      bo, bi, bd                      : fullname = "Branch Conditional", lk, aa
  11 : cmpi    crfD, l, rA, simm               : fullname = "Compare Immediate"
  10 : cmpli   crfD, l, rA, uimm               : fullname = "Compare Logical Immediate"
  34 : lbz     +rD, d(rA)                      : fullname = "Load Byte and Zero"
  35 : lbzu    +rD, d(rA)                      : fullname = "Load Byte and Zero with Update"
  50 : lfd     +frD, d(rA)                     : fullname = "Load Floating-Point Double"
  51 : lfdu    +frD, d(rA)                     : fullname = "Load Floating-Point Double with Update"
  48 : lfs     +frD, d(rA)                     : fullname = "Load Floating-Point Single"
  49 : lfsu    +frD, d(rA)                     : fullname = "Load Floating-Point Single with Update"
  42 : lha     +rD, d(rA)                      : fullname = "Load Halfword Algebraic"
  43 : lhau    +rD, d(rA)                      : fullname = "Load Halfword Algebraic with Update"
  40 : lhz     +rD, d(rA)                      : fullname = "Load Halfword and Zero"
  41 : lhzu    +rD, d(rA)                      : fullname = "Load Halfword and Zero with Update"
  46 : lmw     +rD, d(rA)                      : fullname = "Load Multiple Word"
  32 : lwz     +rD, d(rA)                      : fullname = "Load Word and Zero"
  33 : lwzu    +rD, d(rA)                      : fullname = "Load Word and Zero with Update"
   7 : mulli   +rD, rA, simm                   : fullname = "Multiply Low Immediate"
  24 : ori     +rA, rS, uimm                   : fullname = "OR Immediate"
  25 : oris    +rA, rS, uimm                   : fullname = "OR Immediate Shifted"
  20 : rlwimi  +rA, rS, sh, mb, me             : fullname = "Rotate Left Word Immediate then Mask Insert", rc
  21 : rlwinm  +rA, rS, sh, mb, me             : fullname = "Rotate Left Word Immediate then AND with Mask", rc
  23 : rlwnm   +rA, rS, rB, mb, me             : fullname = "Rotate Left Word then AND with Mask", rc
  17 : sc                                      : fullname = "System Call"
  38 : stb     rS, d(rA)                       : fullname = "Store Byte"
  39 : stbu    rS, d(rA)                       : fullname = "Store Byte with Update"
  54 : stfd    frS, d(rA)                      : fullname = "Store Floating-Point Double"
  55 : stfdu   frS, d(rA)                      : fullname = "Store Floating-Point Double with Update"
  52 : stfs    frS, d(rA)                      : fullname = "Store Floating-Point Single"
  53 : stfsu   frS, d(rA)                      : fullname = "Store Floating-Point Single with Update"
  44 : sth     rS, d(rA)                       : fullname = "Store Halfword"
  45 : sthu    rS, d(rA)                       : fullname = "Store Halfword with Update"
  36 : stw     rS, d(rA)                       : fullname = "Store Word"
  37 : stwu    rS, d(rA)                       : fullname = "Store Word with Update"
  47 : stmw    rS, d(rA)                       : fullname = "Store Multiple Word"
   8 : subfic  +rD, rA, simm                   : fullname = "Subtract From Immediate Carrying"
   2 : tdi     to, rA, simm                    : fullname = "Trap Doubleword Immediate"
   3 : twi     to, rA, simm                    : fullname = "Trap Word Immediate"
  26 : xori    +rA, rS, uimm                   : fullname = "XOR Immediate"
  27 : xoris   +rA, rS, uimm                   : fullname = "XOR Immediate Shifted"
   5 : krncall uimm                            : fullname = "Kernel Function Call"

[xo1 = 58, xo5]
   0 : ld      +rD, ds(rA)                     : fullname = "Load Doubleword"
   1 : ldu     +rD, ds(rA)                     : fullname = "Load Doubleword with Update"
   2 : lwa     +rD, ds(rA)                     : fullname = "Load Word Algebraic"

[xo1 = 62, xo5]
   0 : std     rS, ds(rA)                      : fullname = "Store Doubleword"
   1 : stdu    rS, ds(rA)                      : fullname = "Store Doubleword with Update"

[xo1 = 19, xo2]
 528 : bcctr   bo, bi, bh                      : fullname = "Branch Conditional to Count Register", lk
  16 : bclr    bo, bi, bh                      : fullname = "Branch Conditional to Link Register", lk
 257 : crand   +crbD, crbA, crbB               : fullname = "Condition Register AND"
 129 : crandc  +crbD, crbA, crbB               : fullname = "Condition Register AND with Complement"
 289 : creqv   +crbD, crbA, crbB               : fullname = "Condition Register Equivalent"
 225 : crnand  +crbD, crbA, crbB               : fullname = "Condition Register NAND"
  33 : crnor   +crbD, crbA, crbB               : fullname = "Condition Register NOR"
 449 : cror    +crbD, crbA, crbB               : fullname = "Condition Register OR"
 417 : crorc   +crbD, crbA, crbB               : fullname = "Condition Register OR with Complement"
 193 : crxor   +crbD, crbA, crbB               : fullname = "Condition Register XOR"
 150 : isync   rA, rB                          : fullname = "Instruction Synchronize"
   0 : mcrf    +crfD, crfS                     : fullname = "Move Condition Register Field"
  18 : rfid                                    : fullname = "Return from Interrupt Doubleword"

[xo1 = 30, xo7]
   8 : rldcl   +rA, rS, rB, mb                 : fullname = "Rotate Left Doubleword then Clear Left", rc
   9 : rldcr   +rA, rS, rB, mb                 : fullname = "Rotate Left Doubleword then Clear Right", rc
   
[xo1 = 30, xo8]
   2 : rldic   +rA, rS, sh, mb                 : fullname = "Rotate Left Doubleword Immediate then Clear", rc
   0 : rldicl  +rA, rS, sh, mb                 : fullname = "Rotate Left Doubleword Immediate then Clear Left", rc
   1 : rldicr  +rA, rS, sh, mb                 : fullname = "Rotate Left Doubleword Immediate then Clear Right", rc
   3 : rldimi  +rA, rS, sh, mb                 : fullname = "Rotate Left Doubleword Immediate then Mask Insert", rc
   
[xo1 = 31, xo2]
  28 : and     +rA, rS, rB                     : fullname = "AND", rc
  60 : andc    +rA, rS, rB                     : fullname = "AND with Complement", rc
   0 : cmp     +crfD, l, rA, rB                : fullname = "Compare"
  32 : cmpl    +crfD, l, rA, rB                : fullname = "Compare Logical"
  58 : cntlzd  +rA, rS                         : fullname = "Count Leading Zeros Doubleword"
  26 : cntlzw  +rA, rS                         : fullname = "Count Leading Zeros Word"
  86 : dcbf    rA, rB                          : fullname = "Data Cache Block Flush"
  54 : dcbst   rA, rB                          : fullname = "Data Cache Block Store"
 278 : dcbt    rA, rB, th                      : fullname = "Data Cache Block Touch"
 246 : dcbtst  rA, rB                          : fullname = "Data Cache Block Touch for Store"
1014 : dcbz    rA, rB                          : fullname = "Data Cache Clear to Zero"
 310 : eciwx   +rD, rA, rB                     : fullname = "External Control In Word Indexed"
 438 : ecowx   rS, rA, rB                      : fullname = "External Control Out Word Indexed"
 854 : eieio                                   : fullname = "Enforce In-Order Execution of I/O"
 954 : extsb   +rA, rS                         : fullname = "Extend Sign Byte", rc
 922 : extsh   +rA, rS                         : fullname = "Extend Sign Halfword", rc
 986 : extsw   +rA, rS                         : fullname = "Extend Sign Word", rc
 982 : icbi    rA, rB                          : fullname = "Instruction Cache Block Invalidate"
 119 : lbzux   +rD, rA, rB                     : fullname = "Load Byte and Zero with Update Indexed"
  87 : lbzx    +rD, rA, rB                     : fullname = "Load Byte and Zero Indexed"
  84 : ldarx   +rD, rA, rB                     : fullname = "Load Doubleword and Reserve Indexed"
  53 : ldux    +rD, rA, rB                     : fullname = "Load Doubleword with Update Indexed"
  21 : ldx     +rD, rA, rB                     : fullname = "Load Doubleword Indexed"
 631 : lfdux   +frD, rA, rB                    : fullname = "Load Floating-Point Double with Update Indexed"
 599 : lfdx    +frD, rA, rB                    : fullname = "Load Floating-Point Double Indexed"
 567 : lfsux   +frD, rA, rB                    : fullname = "Load Floating-Point Single with Update Indexed"
 535 : lfsx    +frD, rA, rB                    : fullname = "Load Floating-Point Single Indexed"
 375 : lhaux   +rD, rA, rB                     : fullname = "Load Halfword Algebraic with Update Indexed"
 343 : lhax    +rD, rA, rB                     : fullname = "Load Halfword Algebraic Indexed"
 790 : lhbrx   +rD, rA, rB                     : fullname = "Load Halfword Byte-Reverse Indexed"
 311 : lhzux   +rD, rA, rB                     : fullname = "Load Halfword and Zero with Update Indexed"
 279 : lhzx    +rD, rA, rB                     : fullname = "Load Halfword and Zero Indexed"
 597 : lswi    +rD, rA, nb                     : fullname = "Load String Word Immediate"
 533 : lswx    +rD, rA, rB                     : fullname = "Load String Word Indexed"
  20 : lwarx   +rD, rA, rB                     : fullname = "Load Word and Reserve Indexed"
 373 : lwaux   +rD, rA, rB                     : fullname = "Load Word Algebraic with Update Indexed"
 341 : lwax    +rD, rA, rB                     : fullname = "Load Word Algebraic Indexed"
 534 : lwbrx   +rD, rA, rB                     : fullname = "Load Word Byte-Reverse Indexed"
  55 : lwzux   +rD, rA, rB                     : fullname = "Load Word and Zero with Update Indexed"
  23 : lwzx    +rD, rA, rB                     : fullname = "Load Word and Zero Indexed"
  83 : mfmsr   +rD                             : fullname = "Move from Machine State Register"
 339 : mfspr   +rD, spr                        : fullname = "Move from Special-Purpose Register"
 595 : mfsr    +rD, sr                         : fullname = "Move from Segment Register"
 659 : mfsrin  +rD, rB                         : fullname = "Move from Segment Register Indirect"
 371 : mftb    +rD, tbr                        : fullname = "Move from Time Base"
 146 : mtmsr   rS, l15                         : fullname = "Move to Machine State Register"
 178 : mtmsrd  rS, l15                         : fullname = "Move to Machine State Register Doubleword"
 467 : mtspr   spr, rS                         : fullname = "Move to Special-Purpose Register"
 210 : mtsr    sr, rS                          : fullname = "Move to Segment Register"
 242 : mtsrin  rS, rB                          : fullname = "Move to Segment Register Indirect"
 476 : nand    +rA, rS, rB                     : fullname = "NAND", rc
 124 : nor     +rA, rS, rB                     : fullname = "NOR", rc
 444 : or      +rA, rS, rB                     : fullname = "OR", rc
 412 : orc     +rA, rS, rB                     : fullname = "OR with Complement", rc
 498 : slbia                                   : fullname = "SLB Invalidate All"
 434 : slbie   rB                              : fullname = "SLB Invalidate Entry"
 915 : slbmfee +rD, rB                         : fullname = "SLB Move From Entry ESID"
 851 : slbmfev +rD, rB                         : fullname = "SLB Move From Entry VSID"
 402 : slbmte  rS, rB                          : fullname = "SLB Move To Entry"
  27 : sld     +rA, rS, rB                     : fullname = "Shift Left Doubleword", rc
  24 : slw     +rA, rS, rB                     : fullname = "Shift Left Word", rc
 794 : srad    +rA, rS, rB                     : fullname = "Shift Right Algebraic Doubleword", rc
 826 : sradi   +rA, rS, sh                     : fullname = "Shift Right Algebraic Doubleword Immediate", rc
 827 : sradi   +rA, rS, sh                     : fullname = "Shift Right Algebraic Doubleword Immediate", rc
 792 : sraw    +rA, rS, rB                     : fullname = "Shift Right Algebraic Word", rc
 824 : srawi   +rA, rS, sh                     : fullname = "Shift Right Algebraic Word Immediate", rc
 539 : srd     +rA, rS, rB                     : fullname = "Shift Right Doubleword", rc
 536 : srw     +rA, rS, rB                     : fullname = "Shift Right Word", rc
 214 : stdcx   rS, rA, rB                      : fullname = "Store Doubleword Conditional Indexed", rc
 181 : stdux   rS, rA, rB                      : fullname = "Store Doubleword with Update Indexed"
 149 : stdx    rS, rA, rB                      : fullname = "Store Doubleword Indexed"
 759 : stfdux  frS, rA, rB                     : fullname = "Store Floating-Point Double with Update Indexed"
 727 : stfdx   frS, rA, rB                     : fullname = "Store Floating-Point Double Indexed"
 983 : stfiwx  frS, rA, rB                     : fullname = "Store Floating-Point as Integer Word Indexed"
 795 : stfsux  frS, rA, rB                     : fullname = "Store Floating-Point Single with Update Indexed"
 663 : stfsx   frS, rA, rB                     : fullname = "Store Floating-Point Single Indexed"
 918 : sthbrx  rS, rA, rB                      : fullname = "Store Halfword Byte-Reverse Indexed"
 439 : sthux   rS, rA, rB                      : fullname = "Store Halfword with Update Indexed"
 407 : sthx    rS, rA, rB                      : fullname = "Store Halfword Indexed"
 725 : stswi   rS, rA, nb                      : fullname = "Store String Word Immediate"
 661 : stswx   rS, rA, rB                      : fullname = "Store String Word Indexed"
 662 : stwbrx  rS, rA, rB                      : fullname = "Store Word Byte-Reverse Indexed"
 150 : stwcx   rS, rA, rB                      : fullname = "Store Word Conditional Indexed", rc
 183 : stwux   rS, rA, rB                      : fullname = "Store Word with Update Indexed"
 151 : stwx    rS, rA, rB                      : fullname = "Store Word Indexed"
 598 : sync    syncl                           : fullname = "Synchronize"
  31 : td      to, rA, rB                      : fullname = "Trap Doubleword"
 370 : tlbia                                   : fullname = "Translation Lookaside Buffer Invalidate All"
 306 : tlbie   rB, tlbl                        : fullname = "Translation Lookaside Buffer Invalidate Entry"
 274 : tlbiel  rB, tlbl                        : fullname = "Translation Lookaside Buffer Invalidate Entry Local"
 566 : tlbsync                                 : fullname = "Translation Lookaside Buffer Synchronize"
   4 : tw      to, rA, rB                      : fullname = "Trap Word"
 316 : xor     +rA, rS, rB                     : fullname = "XOR", rc

[xo1 = 31, xo2 = 19, xo6]
   0 : mfcr    +rD                             : fullname = "Move from Condition Register"
   1 : mfocrf  +rD, crm                        : fullname = "Move from One Condition Register Field"

[xo1 = 31, xo2 = 144, xo6]
   0 : mtcrf   crm, rS                         : fullname = "Move to Condition Register Fields"
   1 : mtocrf  crm, rS                         : fullname = "Move to One Condition Register Field"
 
[xo1 = 31, xo3]
 266 : add     +rD, rA, rB                     : fullname = "Add", oe, rc
  10 : addc    +rD, rA, rB                     : fullname = "Add Carrying", oe, rc
 138 : adde    +rD, rA, rB                     : fullname = "Add Extended", oe, rc
 234 : addme   +rD, rA                         : fullname = "Add to Minus One Extended", oe, rc
 202 : addze   +rD, rA                         : fullname = "Add to Zero Extended", oe, rc
 489 : divd    +rD, rA, rB                     : fullname = "Divide Doubleword", oe, rc
 457 : divdu   +rD, rA, rB                     : fullname = "Divide Doubleword Unsigned", oe, rc
 491 : divw    +rD, rA, rB                     : fullname = "Divide Word", oe, rc
 459 : divwu   +rD, rA, rB                     : fullname = "Divide Word Unsigned", oe, rc
 284 : eqv     +rA, rS, rB                     : fullname = "Equivalent", rc
  73 : mulhd   +rD, rA, rB                     : fullname = "Multiply High Doubleword", rc
   9 : mulhdu  +rD, rA, rB                     : fullname = "Multiply High Doubleword Unsigned", rc
  75 : mulhw   +rD, rA, rB                     : fullname = "Multiply High Word", rc
  11 : mulhwu  +rD, rA, rB                     : fullname = "Multiply High Word Unsigned", rc
 233 : mulld   +rD, rA, rB                     : fullname = "Multiply Low Doubleword", oe, rc
 235 : mullw   +rD, rA, rB                     : fullname = "Multiply Low Word", oe, rc
  31 : neg     +rD, rA                         : fullname = "Negate", oe, rc
 247 : stbux   rS, rA, rB                      : fullname = "Store Byte with Update Indexed"
 215 : stbx    rS, rA, rB                      : fullname = "Store Byte Indexed"
  40 : subf    +rD, rA, rB                     : fullname = "Subtract From", oe, rc
   8 : subfc   +rD, rA, rB                     : fullname = "Subtract From Carrying", oe, rc
 136 : subfe   +rD, rA, rB                     : fullname = "Subtract From Extended", oe, rc
 232 : subfme  +rD, rA                         : fullname = "Subtract From Minus One Extended", oe, rc
 200 : subfze  +rD, rA                         : fullname = "Subtract From Zero Extended", oe, rc

[xo1 = 59, xo2]
  21 : fadds   +frD, frA, frB                  : fullname = "Floating Add Single", rc
  18 : fdivs   +frD, frA, frB                  : fullname = "Floating Divide Single", rc
  22 : fsqrts  +frD, frB                       : fullname = "Floating Square Root Single", rc
  20 : fsubs   +frD, frA, frB                  : fullname = "Floating Subtract Single", rc

[xo1 = 59, xo4]
  29 : fmadds  +frD, frA, frC, frB             : fullname = "Floating Multiply-Add Single", rc
  28 : fmsubs  +frD, frA, frC, frB             : fullname = "Floating Multiply-Subtract Single", rc
  25 : fmuls   +frD, frA, frC                  : fullname = "Floating Multiply Single", rc
  31 : fnmadds +frD, frA, frC, frB             : fullname = "Floating Negative Multiply-Add Single", rc
  30 : fnmsubs +frD, frA, frC, frB             : fullname = "Floating Negative Multiply-Subtract Single", rc
  24 : fres    +frD, frB                       : fullname = "Floating Reciprocal Estimate Single", rc

[xo1 = 63, xo2]
 264 : fabs    +frD, frA                       : fullname = "Floating Absolute Value", rc
  21 : fadd    +frD, frA, frB                  : fullname = "Floating Add (Double-Precision)", rc
 846 : fcfid   +frD, frB                       : fullname = "Floating Convert from Integer Doubleword", rc
  32 : fcmpo   +crfD, frA, frB                 : fullname = "Floating Compare Ordered", rc
   0 : fcmpu   +crfD, frA, frB                 : fullname = "Floating Compare Unordered", rc
 814 : fctid   +frD, frB                       : fullname = "Floating Convert to Integer Doubleword", rc
 815 : fctidz  +frD, frB                       : fullname = "Floating Convert to Integer Doubleword with round toward Zero", rc
  14 : fctiw   +frD, frB                       : fullname = "Floating Convert to Integer Word", rc
  15 : fctiwz  +frD, frB                       : fullname = "Floating Convert to Integer Word with round toward Zero", rc
  18 : fdiv    +frD, frA, frB                  : fullname = "Floating Divide (Double-Precision)", rc
  72 : fmr     +frD, frB                       : fullname = "Floating Move Register (Double-Precision)", rc
 136 : fnabs   +frD, frB                       : fullname = "Floating Negative Absolute Value", rc
  40 : fneg    +frD, frB                       : fullname = "Floating Negate", rc
  12 : frsp    +frD, frB                       : fullname = "Floating Round to Single", rc
  22 : fsqrt   +frD, frB                       : fullname = "Floating Square Root (Double-Precision)", rc
  20 : fsub    +frD, frA, frB                  : fullname = "Floating Subtract (Double-Precision)", rc
  64 : mcrfs   +crfD, crfS                     : fullname = "Move to Condition Register from FPSCR"
 583 : mffs    +frD                            : fullname = "Move from FPSCR", rc
  70 : mtfsb0  +crbD                           : fullname = "Move to FPSCR Bit 0", rc
  38 : mtfsb1  +crbD                           : fullname = "Move to FPSCR Bit 1", rc
 711 : mtfsf   fm, frB                         : fullname = "Move to FPSCR Fields", rc
 134 : mtfsfi  crfD, uimm                      : fullname = "Move to FPSCR Field Immediate", rc

[xo1 = 63, xo4]
  29 : fmadd   +frD, frA, frC, frB             : fullname = "Floating Multiply-Add (Double-Precision)", rc
  28 : fmsub   +frD, frA, frC, frB             : fullname = "Floating Multiply-Subtract (Double-Precision)", rc
  25 : fmul    +frD, frA, frC                  : fullname = "Floating Multiply (Double-Precision)", rc
  31 : fnmadd  +frD, frA, frC, frB             : fullname = "Floating Negative Multiply-Add (Double-Precision)", rc
  30 : fnmsub  +frD, frA, frC, frB             : fullname = "Floating Negative Multiply-Subtract (Double-Precision)", rc
  26 : frsqrte +frD, frB                       : fullname = "Floating Reciprocal Square Root Estimate", rc
  23 : fsel    +frD, frA, frC, frB             : fullname = "Floating Select", rc

//[Aliases]
//cmpwi   rA, simm           : cmpi    0, 0, rA, simm 
//cmpw    rA, rB             : cmp     0, 0, rA, rB
//cmplwi  rA, uimm           : cmpli   0, 0, rA, uimm 
//cmplw   rA, rB             : cmpl    0, 0, rA, rB
//cmpwi   crfD, rA, simm     : cmpi    crfD, 0, rA, simm 
//cmpw    crfD, rA, rB       : cmp     crfD, 0, rA, rB
//cmplwi  crfD, rA, uimm     : cmpli   crfD, 0, rA, uimm 
//cmplw   crfD, rA, rB       : cmpl    crfD, 0, rA, rB
//cmpdi   rA, simm           : cmpi    0, 1, rA, simm 
//cmpd    rA, rB             : cmp     0, 1, rA, rB
//cmpldi  rA, uimm           : cmpli   0, 1, rA, uimm 
//cmpld   rA, rB             : cmpl    0, 1, rA, rB
//cmpdi   crfD, rA, simm     : cmpi    crfD, 1, rA, simm 
//cmpd    crfD, rA, rB       : cmp     crfD, 1, rA, rB
//cmpldi  crfD, rA, uimm     : cmpli   crfD, 1, rA, uimm 
//cmpld   crfD, rA, rB       : cmpl    crfD, 1, rA, rB

```

`src/powerpc/emugen_cpu_info.h`:

```h
struct Registers_ {
   uint64_t gpr[32];
   double fpr[32];
   union {
      uint32_t value;
      struct {
         uint32_t cr0 : 4;
         uint32_t cr1 : 4;
         uint32_t cr2 : 4;
         uint32_t cr3 : 4;
         uint32_t cr4 : 4;
         uint32_t cr5 : 4;
         uint32_t cr6 : 4;
         uint32_t cr7 : 5;
      };
   } cr;
   union {
      uint32_t value;
      struct {
         uint32_t fx : 1;
         uint32_t fex : 1;
         uint32_t vx : 1;
         uint32_t ox : 1;
         uint32_t ux : 1;
         uint32_t zx : 1;
         uint32_t xx : 1;
         uint32_t vxsnan : 1;
         uint32_t vxisi : 1;
         uint32_t vxidi : 1;
         uint32_t vxzdz : 1;
         uint32_t vximz : 1;
         uint32_t vxvc : 1;
         uint32_t fr : 1;
         uint32_t fi : 1;
         uint32_t fprf : 5;
         uint32_t : 1;
         uint32_t vxsoft : 1;
         uint32_t vxsqrt : 1;
         uint32_t vxcvi : 1;
         uint32_t ve : 1;
         uint32_t oe : 1;
         uint32_t ue : 1;
         uint32_t ze : 1;
         uint32_t xe : 1;
         uint32_t ni : 1;
         uint32_t rn : 2;
      };
   } fpscr;
   union {
      uint64_t value;
      struct {
         uint64_t : 32;
         uint64_t so : 1;
         uint64_t ov : 1;
         uint64_t ca : 1;
         uint64_t : 22;
         uint64_t bt : 7;
      };
   } xer;
   uint64_t lr;
   uint64_t ctr;
   uint32_t tbu;
   uint32_t tbl;
   uint64_t msr;
   uint32_t pvr;
   uint64_t sdr1;
   uint64_t asr;
   uint64_t dar;
   uint32_t dsisr;
   uint64_t srr0;
   uint64_t srr1;
   uint64_t sprg0;
   uint64_t sprg1;
   uint64_t sprg2;
   uint64_t sprg3;
   uint64_t fpecr;
   uint32_t dec;
   uint64_t dabr;
   uint64_t pir;
   uint32_t ear;
   uint64_t ctrl;
   uint64_t iabr;
};

namespace Fields {
enum Field {
   xo1,
   xo2,
   xo3,
   xo4,
   xo5,
   xo6,
   xo7,
   xo8,
   bd,
   bi,
   bo,
   bh,
   crbA,
   crbB,
   crbD,
   crfD,
   crfS,
   d,
   ds,
   frA,
   frB,
   frC,
   frD,
   frS,
   uimm,
   simm,
   l,
   li,
   rA,
   rB,
   rD,
   rS,
   spr,
   th,
   sr,
   tbr,
   crm,
   fm,
   nb,
   l15,
   syncl,
   tlbl,
   sh,
   shd04,
   shd5,
   mb,
   mbd,
   me,
   med,
   to,
   aa,
   lk,
   oe,
   rc,
};
};

typedef unsigned Field;

union Instruction {
   uint32_t value;

   unsigned get(Field field) const;
   void set(Field field, unsigned value);


   struct {
      uint32_t : 26;
      uint32_t xo1 : 6;
   };

   struct {
      uint32_t : 1;
      uint32_t xo2 : 10;
      uint32_t : 21;
   };

   struct {
      uint32_t : 1;
      uint32_t xo3 : 9;
      uint32_t : 22;
   };

   struct {
      uint32_t : 1;
      uint32_t xo4 : 5;
      uint32_t : 26;
   };

   struct {
      uint32_t xo5 : 2;
      uint32_t : 30;
   };

   struct {
      uint32_t : 20;
      uint32_t xo6 : 1;
      uint32_t : 11;
   };

   struct {
      uint32_t : 1;
      uint32_t xo7 : 4;
      uint32_t : 27;
   };

   struct {
      uint32_t : 2;
      uint32_t xo8 : 3;
      uint32_t : 27;
   };

   struct {
      uint32_t : 2;
      uint32_t bd : 14;
      uint32_t : 16;
   };

   struct {
      uint32_t : 16;
      uint32_t bi : 5;
      uint32_t : 11;
   };

   struct {
      uint32_t : 21;
      uint32_t bo : 5;
      uint32_t : 6;
   };

   struct {
      uint32_t : 11;
      uint32_t bh : 2;
      uint32_t : 19;
   };

   struct {
      uint32_t : 16;
      uint32_t crbA : 5;
      uint32_t : 11;
   };

   struct {
      uint32_t : 11;
      uint32_t crbB : 5;
      uint32_t : 16;
   };

   struct {
      uint32_t : 21;
      uint32_t crbD : 5;
      uint32_t : 6;
   };

   struct {
      uint32_t : 23;
      uint32_t crfD : 3;
      uint32_t : 6;
   };

   struct {
      uint32_t : 18;
      uint32_t crfS : 3;
      uint32_t : 11;
   };

   struct {
      uint32_t d : 16;
      uint32_t : 16;
   };

   struct {
      uint32_t : 2;
      uint32_t ds : 14;
      uint32_t : 16;
   };

   struct {
      uint32_t : 16;
      uint32_t frA : 5;
      uint32_t : 11;
   };

   struct {
      uint32_t : 11;
      uint32_t frB : 5;
      uint32_t : 16;
   };

   struct {
      uint32_t : 6;
      uint32_t frC : 5;
      uint32_t : 21;
   };

   struct {
      uint32_t : 21;
      uint32_t frD : 5;
      uint32_t : 6;
   };

   struct {
      uint32_t : 21;
      uint32_t frS : 5;
      uint32_t : 6;
   };

   struct {
      uint32_t uimm : 16;
      uint32_t : 16;
   };

   struct {
      uint32_t simm : 16;
      uint32_t : 16;
   };

   struct {
      uint32_t : 21;
      uint32_t l : 2;
      uint32_t : 9;
   };

   struct {
      uint32_t : 2;
      uint32_t li : 24;
      uint32_t : 6;
   };

   struct {
      uint32_t : 16;
      uint32_t rA : 5;
      uint32_t : 11;
   };

   struct {
      uint32_t : 11;
      uint32_t rB : 5;
      uint32_t : 16;
   };

   struct {
      uint32_t : 21;
      uint32_t rD : 5;
      uint32_t : 6;
   };

   struct {
      uint32_t : 21;
      uint32_t rS : 5;
      uint32_t : 6;
   };

   struct {
      uint32_t : 11;
      uint32_t spr : 10;
      uint32_t : 11;
   };

   struct {
      uint32_t : 21;
      uint32_t th : 2;
      uint32_t : 9;
   };

   struct {
      uint32_t : 16;
      uint32_t sr : 4;
      uint32_t : 12;
   };

   struct {
      uint32_t : 11;
      uint32_t tbr : 10;
      uint32_t : 11;
   };

   struct {
      uint32_t : 12;
      uint32_t crm : 8;
      uint32_t : 12;
   };

   struct {
      uint32_t : 17;
      uint32_t fm : 8;
      uint32_t : 7;
   };

   struct {
      uint32_t : 11;
      uint32_t nb : 5;
      uint32_t : 16;
   };

   struct {
      uint32_t : 16;
      uint32_t l15 : 1;
      uint32_t : 15;
   };

   struct {
      uint32_t : 21;
      uint32_t syncl : 2;
      uint32_t : 9;
   };

   struct {
      uint32_t : 21;
      uint32_t tlbl : 1;
      uint32_t : 10;
   };

   struct {
      uint32_t : 11;
      uint32_t sh : 5;
      uint32_t : 16;
   };

   struct {
      uint32_t : 11;
      uint32_t shd04 : 5;
      uint32_t : 16;
   };

   struct {
      uint32_t : 1;
      uint32_t shd5 : 1;
      uint32_t : 30;
   };

   struct {
      uint32_t : 6;
      uint32_t mb : 5;
      uint32_t : 21;
   };

   struct {
      uint32_t : 5;
      uint32_t mbd : 6;
      uint32_t : 21;
   };

   struct {
      uint32_t : 1;
      uint32_t me : 5;
      uint32_t : 26;
   };

   struct {
      uint32_t : 5;
      uint32_t med : 6;
      uint32_t : 21;
   };

   struct {
      uint32_t : 21;
      uint32_t to : 5;
      uint32_t : 6;
   };

   struct {
      uint32_t : 1;
      uint32_t aa : 1;
      uint32_t : 30;
   };

   struct {
      uint32_t lk : 1;
      uint32_t : 31;
   };

   struct {
      uint32_t : 10;
      uint32_t oe : 1;
      uint32_t : 21;
   };

   struct {
      uint32_t rc : 1;
      uint32_t : 31;
   };
};


```

`src/powerpc/emugen_decoder.h`:

```h
DecodeEntry table_xo1[64];
DecodeEntry table_xo1_19_xo2[1024];
DecodeEntry table_xo1_30_xo7[16];
DecodeEntry *table_xo1_30_xo8 = table_xo1_30_xo7;
DecodeEntry table_xo1_31_xo2[1024];
DecodeEntry *table_xo1_31_xo3 = table_xo1_31_xo2;
DecodeEntry table_xo1_31_xo2_19_xo6[2];
DecodeEntry table_xo1_31_xo2_144_xo6[2];
DecodeEntry table_xo1_58_xo5[4];
DecodeEntry table_xo1_59_xo2[1024];
DecodeEntry *table_xo1_59_xo4 = table_xo1_59_xo2;
DecodeEntry table_xo1_62_xo5[4];
DecodeEntry table_xo1_63_xo2[1024];
DecodeEntry *table_xo1_63_xo4 = table_xo1_63_xo2;

InstructionID decode(Instruction instr) {
   DecodeEntry entry;

   entry = table_xo1[instr.xo1];
   if (entry.value) {
      if (entry.isTable()) {
         return entry.table(instr);
      } else {
         return entry.instr();
      }
   }

   return InstructionID::Unknown;
}

InstructionID decode_xo1_19(Instruction instr) {
   DecodeEntry entry;

   entry = table_xo1_19_xo2[instr.xo2];
   if (entry.value) {
      if (entry.isTable()) {
         return entry.table(instr);
      } else {
         return entry.instr();
      }
   }

   return InstructionID::Unknown;
}

InstructionID decode_xo1_30(Instruction instr) {
   DecodeEntry entry;

   entry = table_xo1_30_xo7[instr.xo7];
   if (entry.value) {
      if (entry.isTable()) {
         return entry.table(instr);
      } else {
         return entry.instr();
      }
   }

   entry = table_xo1_30_xo8[instr.xo8];
   if (entry.value) {
      if (entry.isTable()) {
         return entry.table(instr);
      } else {
         return entry.instr();
      }
   }

   return InstructionID::Unknown;
}

InstructionID decode_xo1_31(Instruction instr) {
   DecodeEntry entry;

   entry = table_xo1_31_xo2[instr.xo2];
   if (entry.value) {
      if (entry.isTable()) {
         return entry.table(instr);
      } else {
         return entry.instr();
      }
   }

   entry = table_xo1_31_xo3[instr.xo3];
   if (entry.value) {
      if (entry.isTable()) {
         return entry.table(instr);
      } else {
         return entry.instr();
      }
   }

   return InstructionID::Unknown;
}

InstructionID decode_xo1_31_xo2_19(Instruction instr) {
   DecodeEntry entry;

   entry = table_xo1_31_xo2_19_xo6[instr.xo6];
   if (entry.value) {
      if (entry.isTable()) {
         return entry.table(instr);
      } else {
         return entry.instr();
      }
   }

   return InstructionID::Unknown;
}

InstructionID decode_xo1_31_xo2_144(Instruction instr) {
   DecodeEntry entry;

   entry = table_xo1_31_xo2_144_xo6[instr.xo6];
   if (entry.value) {
      if (entry.isTable()) {
         return entry.table(instr);
      } else {
         return entry.instr();
      }
   }

   return InstructionID::Unknown;
}

InstructionID decode_xo1_58(Instruction instr) {
   DecodeEntry entry;

   entry = table_xo1_58_xo5[instr.xo5];
   if (entry.value) {
      if (entry.isTable()) {
         return entry.table(instr);
      } else {
         return entry.instr();
      }
   }

   return InstructionID::Unknown;
}

InstructionID decode_xo1_59(Instruction instr) {
   DecodeEntry entry;

   entry = table_xo1_59_xo2[instr.xo2];
   if (entry.value) {
      if (entry.isTable()) {
         return entry.table(instr);
      } else {
         return entry.instr();
      }
   }

   entry = table_xo1_59_xo4[instr.xo4];
   if (entry.value) {
      if (entry.isTable()) {
         return entry.table(instr);
      } else {
         return entry.instr();
      }
   }

   return InstructionID::Unknown;
}

InstructionID decode_xo1_62(Instruction instr) {
   DecodeEntry entry;

   entry = table_xo1_62_xo5[instr.xo5];
   if (entry.value) {
      if (entry.isTable()) {
         return entry.table(instr);
      } else {
         return entry.instr();
      }
   }

   return InstructionID::Unknown;
}

InstructionID decode_xo1_63(Instruction instr) {
   DecodeEntry entry;

   entry = table_xo1_63_xo2[instr.xo2];
   if (entry.value) {
      if (entry.isTable()) {
         return entry.table(instr);
      } else {
         return entry.instr();
      }
   }

   entry = table_xo1_63_xo4[instr.xo4];
   if (entry.value) {
      if (entry.isTable()) {
         return entry.table(instr);
      } else {
         return entry.instr();
      }
   }

   return InstructionID::Unknown;
}


bool init()
{
   table_xo1[2] = InstructionID::tdi;
   table_xo1[3] = InstructionID::twi;
   table_xo1[5] = InstructionID::krncall;
   table_xo1[7] = InstructionID::mulli;
   table_xo1[8] = InstructionID::subfic;
   table_xo1[10] = InstructionID::cmpli;
   table_xo1[11] = InstructionID::cmpi;
   table_xo1[12] = InstructionID::addic;
   table_xo1[13] = InstructionID::addico;
   table_xo1[14] = InstructionID::addi;
   table_xo1[15] = InstructionID::addis;
   table_xo1[16] = InstructionID::bc;
   table_xo1[17] = InstructionID::sc;
   table_xo1[18] = InstructionID::b;
   table_xo1[19] = decode_xo1_19;
   table_xo1[20] = InstructionID::rlwimi;
   table_xo1[21] = InstructionID::rlwinm;
   table_xo1[23] = InstructionID::rlwnm;
   table_xo1[24] = InstructionID::ori;
   table_xo1[25] = InstructionID::oris;
   table_xo1[26] = InstructionID::xori;
   table_xo1[27] = InstructionID::xoris;
   table_xo1[28] = InstructionID::andio;
   table_xo1[29] = InstructionID::andiso;
   table_xo1[30] = decode_xo1_30;
   table_xo1[31] = decode_xo1_31;
   table_xo1[32] = InstructionID::lwz;
   table_xo1[33] = InstructionID::lwzu;
   table_xo1[34] = InstructionID::lbz;
   table_xo1[35] = InstructionID::lbzu;
   table_xo1[36] = InstructionID::stw;
   table_xo1[37] = InstructionID::stwu;
   table_xo1[38] = InstructionID::stb;
   table_xo1[39] = InstructionID::stbu;
   table_xo1[40] = InstructionID::lhz;
   table_xo1[41] = InstructionID::lhzu;
   table_xo1[42] = InstructionID::lha;
   table_xo1[43] = InstructionID::lhau;
   table_xo1[44] = InstructionID::sth;
   table_xo1[45] = InstructionID::sthu;
   table_xo1[46] = InstructionID::lmw;
   table_xo1[47] = InstructionID::stmw;
   table_xo1[48] = InstructionID::lfs;
   table_xo1[49] = InstructionID::lfsu;
   table_xo1[50] = InstructionID::lfd;
   table_xo1[51] = InstructionID::lfdu;
   table_xo1[52] = InstructionID::stfs;
   table_xo1[53] = InstructionID::stfsu;
   table_xo1[54] = InstructionID::stfd;
   table_xo1[55] = InstructionID::stfdu;
   table_xo1[58] = decode_xo1_58;
   table_xo1[59] = decode_xo1_59;
   table_xo1[62] = decode_xo1_62;
   table_xo1[63] = decode_xo1_63;
   table_xo1_19_xo2[0] = InstructionID::mcrf;
   table_xo1_19_xo2[16] = InstructionID::bclr;
   table_xo1_19_xo2[18] = InstructionID::rfid;
   table_xo1_19_xo2[33] = InstructionID::crnor;
   table_xo1_19_xo2[129] = InstructionID::crandc;
   table_xo1_19_xo2[150] = InstructionID::isync;
   table_xo1_19_xo2[193] = InstructionID::crxor;
   table_xo1_19_xo2[225] = InstructionID::crnand;
   table_xo1_19_xo2[257] = InstructionID::crand;
   table_xo1_19_xo2[289] = InstructionID::creqv;
   table_xo1_19_xo2[417] = InstructionID::crorc;
   table_xo1_19_xo2[449] = InstructionID::cror;
   table_xo1_19_xo2[528] = InstructionID::bcctr;
   table_xo1_30_xo7[8] = InstructionID::rldcl;
   table_xo1_30_xo7[9] = InstructionID::rldcr;
   table_xo1_30_xo8[0] = InstructionID::rldicl;
   table_xo1_30_xo8[1] = InstructionID::rldicr;
   table_xo1_30_xo8[2] = InstructionID::rldic;
   table_xo1_30_xo8[3] = InstructionID::rldimi;
   table_xo1_31_xo2[0] = InstructionID::cmp;
   table_xo1_31_xo2[4] = InstructionID::tw;
   table_xo1_31_xo2[19] = decode_xo1_31_xo2_19;
   table_xo1_31_xo2[20] = InstructionID::lwarx;
   table_xo1_31_xo2[21] = InstructionID::ldx;
   table_xo1_31_xo2[23] = InstructionID::lwzx;
   table_xo1_31_xo2[24] = InstructionID::slw;
   table_xo1_31_xo2[26] = InstructionID::cntlzw;
   table_xo1_31_xo2[27] = InstructionID::sld;
   table_xo1_31_xo2[28] = InstructionID::and;
   table_xo1_31_xo2[31] = InstructionID::td;
   table_xo1_31_xo2[32] = InstructionID::cmpl;
   table_xo1_31_xo2[53] = InstructionID::ldux;
   table_xo1_31_xo2[54] = InstructionID::dcbst;
   table_xo1_31_xo2[55] = InstructionID::lwzux;
   table_xo1_31_xo2[58] = InstructionID::cntlzd;
   table_xo1_31_xo2[60] = InstructionID::andc;
   table_xo1_31_xo2[83] = InstructionID::mfmsr;
   table_xo1_31_xo2[84] = InstructionID::ldarx;
   table_xo1_31_xo2[86] = InstructionID::dcbf;
   table_xo1_31_xo2[87] = InstructionID::lbzx;
   table_xo1_31_xo2[119] = InstructionID::lbzux;
   table_xo1_31_xo2[124] = InstructionID::nor;
   table_xo1_31_xo2[144] = decode_xo1_31_xo2_144;
   table_xo1_31_xo2[146] = InstructionID::mtmsr;
   table_xo1_31_xo2[149] = InstructionID::stdx;
   table_xo1_31_xo2[150] = InstructionID::stwcx;
   table_xo1_31_xo2[151] = InstructionID::stwx;
   table_xo1_31_xo2[178] = InstructionID::mtmsrd;
   table_xo1_31_xo2[181] = InstructionID::stdux;
   table_xo1_31_xo2[183] = InstructionID::stwux;
   table_xo1_31_xo2[210] = InstructionID::mtsr;
   table_xo1_31_xo2[214] = InstructionID::stdcx;
   table_xo1_31_xo2[242] = InstructionID::mtsrin;
   table_xo1_31_xo2[246] = InstructionID::dcbtst;
   table_xo1_31_xo2[274] = InstructionID::tlbiel;
   table_xo1_31_xo2[278] = InstructionID::dcbt;
   table_xo1_31_xo2[279] = InstructionID::lhzx;
   table_xo1_31_xo2[306] = InstructionID::tlbie;
   table_xo1_31_xo2[310] = InstructionID::eciwx;
   table_xo1_31_xo2[311] = InstructionID::lhzux;
   table_xo1_31_xo2[316] = InstructionID::xor;
   table_xo1_31_xo2[339] = InstructionID::mfspr;
   table_xo1_31_xo2[341] = InstructionID::lwax;
   table_xo1_31_xo2[343] = InstructionID::lhax;
   table_xo1_31_xo2[370] = InstructionID::tlbia;
   table_xo1_31_xo2[371] = InstructionID::mftb;
   table_xo1_31_xo2[373] = InstructionID::lwaux;
   table_xo1_31_xo2[375] = InstructionID::lhaux;
   table_xo1_31_xo2[402] = InstructionID::slbmte;
   table_xo1_31_xo2[407] = InstructionID::sthx;
   table_xo1_31_xo2[412] = InstructionID::orc;
   table_xo1_31_xo2[434] = InstructionID::slbie;
   table_xo1_31_xo2[438] = InstructionID::ecowx;
   table_xo1_31_xo2[439] = InstructionID::sthux;
   table_xo1_31_xo2[444] = InstructionID::or;
   table_xo1_31_xo2[467] = InstructionID::mtspr;
   table_xo1_31_xo2[476] = InstructionID::nand;
   table_xo1_31_xo2[498] = InstructionID::slbia;
   table_xo1_31_xo2[533] = InstructionID::lswx;
   table_xo1_31_xo2[534] = InstructionID::lwbrx;
   table_xo1_31_xo2[535] = InstructionID::lfsx;
   table_xo1_31_xo2[536] = InstructionID::srw;
   table_xo1_31_xo2[539] = InstructionID::srd;
   table_xo1_31_xo2[566] = InstructionID::tlbsync;
   table_xo1_31_xo2[567] = InstructionID::lfsux;
   table_xo1_31_xo2[595] = InstructionID::mfsr;
   table_xo1_31_xo2[597] = InstructionID::lswi;
   table_xo1_31_xo2[598] = InstructionID::sync;
   table_xo1_31_xo2[599] = InstructionID::lfdx;
   table_xo1_31_xo2[631] = InstructionID::lfdux;
   table_xo1_31_xo2[659] = InstructionID::mfsrin;
   table_xo1_31_xo2[661] = InstructionID::stswx;
   table_xo1_31_xo2[662] = InstructionID::stwbrx;
   table_xo1_31_xo2[663] = InstructionID::stfsx;
   table_xo1_31_xo2[725] = InstructionID::stswi;
   table_xo1_31_xo2[727] = InstructionID::stfdx;
   table_xo1_31_xo2[759] = InstructionID::stfdux;
   table_xo1_31_xo2[790] = InstructionID::lhbrx;
   table_xo1_31_xo2[792] = InstructionID::sraw;
   table_xo1_31_xo2[794] = InstructionID::srad;
   table_xo1_31_xo2[795] = InstructionID::stfsux;
   table_xo1_31_xo2[824] = InstructionID::srawi;
   table_xo1_31_xo2[827] = InstructionID::sradi;
   table_xo1_31_xo2[851] = InstructionID::slbmfev;
   table_xo1_31_xo2[854] = InstructionID::eieio;
   table_xo1_31_xo2[915] = InstructionID::slbmfee;
   table_xo1_31_xo2[918] = InstructionID::sthbrx;
   table_xo1_31_xo2[922] = InstructionID::extsh;
   table_xo1_31_xo2[954] = InstructionID::extsb;
   table_xo1_31_xo2[982] = InstructionID::icbi;
   table_xo1_31_xo2[983] = InstructionID::stfiwx;
   table_xo1_31_xo2[986] = InstructionID::extsw;
   table_xo1_31_xo2[1014] = InstructionID::dcbz;
   table_xo1_31_xo3[8] = InstructionID::subfc;
   table_xo1_31_xo3[9] = InstructionID::mulhdu;
   table_xo1_31_xo3[10] = InstructionID::addc;
   table_xo1_31_xo3[11] = InstructionID::mulhwu;
   table_xo1_31_xo3[31] = InstructionID::neg;
   table_xo1_31_xo3[40] = InstructionID::subf;
   table_xo1_31_xo3[73] = InstructionID::mulhd;
   table_xo1_31_xo3[75] = InstructionID::mulhw;
   table_xo1_31_xo3[136] = InstructionID::subfe;
   table_xo1_31_xo3[138] = InstructionID::adde;
   table_xo1_31_xo3[200] = InstructionID::subfze;
   table_xo1_31_xo3[202] = InstructionID::addze;
   table_xo1_31_xo3[215] = InstructionID::stbx;
   table_xo1_31_xo3[232] = InstructionID::subfme;
   table_xo1_31_xo3[233] = InstructionID::mulld;
   table_xo1_31_xo3[234] = InstructionID::addme;
   table_xo1_31_xo3[235] = InstructionID::mullw;
   table_xo1_31_xo3[247] = InstructionID::stbux;
   table_xo1_31_xo3[266] = InstructionID::add;
   table_xo1_31_xo3[284] = InstructionID::eqv;
   table_xo1_31_xo3[457] = InstructionID::divdu;
   table_xo1_31_xo3[459] = InstructionID::divwu;
   table_xo1_31_xo3[489] = InstructionID::divd;
   table_xo1_31_xo3[491] = InstructionID::divw;
   table_xo1_31_xo2_19_xo6[0] = InstructionID::mfcr;
   table_xo1_31_xo2_19_xo6[1] = InstructionID::mfocrf;
   table_xo1_31_xo2_144_xo6[0] = InstructionID::mtcrf;
   table_xo1_31_xo2_144_xo6[1] = InstructionID::mtocrf;
   table_xo1_58_xo5[0] = InstructionID::ld;
   table_xo1_58_xo5[1] = InstructionID::ldu;
   table_xo1_58_xo5[2] = InstructionID::lwa;
   table_xo1_59_xo2[18] = InstructionID::fdivs;
   table_xo1_59_xo2[20] = InstructionID::fsubs;
   table_xo1_59_xo2[21] = InstructionID::fadds;
   table_xo1_59_xo2[22] = InstructionID::fsqrts;
   table_xo1_59_xo4[24] = InstructionID::fres;
   table_xo1_59_xo4[25] = InstructionID::fmuls;
   table_xo1_59_xo4[28] = InstructionID::fmsubs;
   table_xo1_59_xo4[29] = InstructionID::fmadds;
   table_xo1_59_xo4[30] = InstructionID::fnmsubs;
   table_xo1_59_xo4[31] = InstructionID::fnmadds;
   table_xo1_62_xo5[0] = InstructionID::std;
   table_xo1_62_xo5[1] = InstructionID::stdu;
   table_xo1_63_xo2[0] = InstructionID::fcmpu;
   table_xo1_63_xo2[12] = InstructionID::frsp;
   table_xo1_63_xo2[14] = InstructionID::fctiw;
   table_xo1_63_xo2[15] = InstructionID::fctiwz;
   table_xo1_63_xo2[18] = InstructionID::fdiv;
   table_xo1_63_xo2[20] = InstructionID::fsub;
   table_xo1_63_xo2[21] = InstructionID::fadd;
   table_xo1_63_xo2[22] = InstructionID::fsqrt;
   table_xo1_63_xo2[32] = InstructionID::fcmpo;
   table_xo1_63_xo2[38] = InstructionID::mtfsb1;
   table_xo1_63_xo2[40] = InstructionID::fneg;
   table_xo1_63_xo2[64] = InstructionID::mcrfs;
   table_xo1_63_xo2[70] = InstructionID::mtfsb0;
   table_xo1_63_xo2[72] = InstructionID::fmr;
   table_xo1_63_xo2[134] = InstructionID::mtfsfi;
   table_xo1_63_xo2[136] = InstructionID::fnabs;
   table_xo1_63_xo2[264] = InstructionID::fabs;
   table_xo1_63_xo2[583] = InstructionID::mffs;
   table_xo1_63_xo2[711] = InstructionID::mtfsf;
   table_xo1_63_xo2[814] = InstructionID::fctid;
   table_xo1_63_xo2[815] = InstructionID::fctidz;
   table_xo1_63_xo2[846] = InstructionID::fcfid;
   table_xo1_63_xo4[23] = InstructionID::fsel;
   table_xo1_63_xo4[25] = InstructionID::fmul;
   table_xo1_63_xo4[26] = InstructionID::frsqrte;
   table_xo1_63_xo4[28] = InstructionID::fmsub;
   table_xo1_63_xo4[29] = InstructionID::fmadd;
   table_xo1_63_xo4[30] = InstructionID::fnmsub;
   table_xo1_63_xo4[31] = InstructionID::fnmadd;
   return true;
}

```

`src/powerpc/emugen_instructionid.h`:

```h
enum class InstructionID {
   Unknown,
   add,
   addc,
   adde,
   addi,
   addic,
   addico,
   addis,
   addme,
   addze,
   and,
   andc,
   andio,
   andiso,
   b,
   bc,
   bcctr,
   bclr,
   cmp,
   cmpi,
   cmpl,
   cmpli,
   cntlzd,
   cntlzw,
   crand,
   crandc,
   creqv,
   crnand,
   crnor,
   cror,
   crorc,
   crxor,
   dcbf,
   dcbst,
   dcbt,
   dcbtst,
   dcbz,
   divd,
   divdu,
   divw,
   divwu,
   eciwx,
   ecowx,
   eieio,
   eqv,
   extsb,
   extsh,
   extsw,
   fabs,
   fadd,
   fadds,
   fcfid,
   fcmpo,
   fcmpu,
   fctid,
   fctidz,
   fctiw,
   fctiwz,
   fdiv,
   fdivs,
   fmadd,
   fmadds,
   fmr,
   fmsub,
   fmsubs,
   fmul,
   fmuls,
   fnabs,
   fneg,
   fnmadd,
   fnmadds,
   fnmsub,
   fnmsubs,
   fres,
   frsp,
   frsqrte,
   fsel,
   fsqrt,
   fsqrts,
   fsub,
   fsubs,
   icbi,
   isync,
   krncall,
   lbz,
   lbzu,
   lbzux,
   lbzx,
   ld,
   ldarx,
   ldu,
   ldux,
   ldx,
   lfd,
   lfdu,
   lfdux,
   lfdx,
   lfs,
   lfsu,
   lfsux,
   lfsx,
   lha,
   lhau,
   lhaux,
   lhax,
   lhbrx,
   lhz,
   lhzu,
   lhzux,
   lhzx,
   lmw,
   lswi,
   lswx,
   lwa,
   lwarx,
   lwaux,
   lwax,
   lwbrx,
   lwz,
   lwzu,
   lwzux,
   lwzx,
   mcrf,
   mcrfs,
   mfcr,
   mffs,
   mfmsr,
   mfocrf,
   mfspr,
   mfsr,
   mfsrin,
   mftb,
   mtcrf,
   mtfsb0,
   mtfsb1,
   mtfsf,
   mtfsfi,
   mtmsr,
   mtmsrd,
   mtocrf,
   mtspr,
   mtsr,
   mtsrin,
   mulhd,
   mulhdu,
   mulhw,
   mulhwu,
   mulld,
   mulli,
   mullw,
   nand,
   neg,
   nor,
   or,
   orc,
   ori,
   oris,
   rfid,
   rldcl,
   rldcr,
   rldic,
   rldicl,
   rldicr,
   rldimi,
   rlwimi,
   rlwinm,
   rlwnm,
   sc,
   slbia,
   slbie,
   slbmfee,
   slbmfev,
   slbmte,
   sld,
   slw,
   srad,
   sradi,
   sraw,
   srawi,
   srd,
   srw,
   stb,
   stbu,
   stbux,
   stbx,
   std,
   stdcx,
   stdu,
   stdux,
   stdx,
   stfd,
   stfdu,
   stfdux,
   stfdx,
   stfiwx,
   stfs,
   stfsu,
   stfsux,
   stfsx,
   sth,
   sthbrx,
   sthu,
   sthux,
   sthx,
   stmw,
   stswi,
   stswx,
   stw,
   stwbrx,
   stwcx,
   stwu,
   stwux,
   stwx,
   subf,
   subfc,
   subfe,
   subfic,
   subfme,
   subfze,
   sync,
   td,
   tdi,
   tlbia,
   tlbie,
   tlbiel,
   tlbsync,
   tw,
   twi,
   xor,
   xori,
   xoris,
   InstructionMax,
};

```

`src/powerpc/emugen_instructions.h`:

```h
InstrEntry Instructions[] = {
   { },
   { "add",     { { xo1, 31 }, { xo3,  266 }             }, { rD }, { rA, rB }, { oe, rc },     "Add" },
   { "addc",    { { xo1, 31 }, { xo3,   10 }             }, { rD }, { rA, rB }, { oe, rc },     "Add Carrying" },
   { "adde",    { { xo1, 31 }, { xo3,  138 }             }, { rD }, { rA, rB }, { oe, rc },     "Add Extended" },
   { "addi",    { { xo1, 14 }                            }, { rD }, { rA, simm }, { },          "Add Immediate" },
   { "addic",   { { xo1, 12 }                            }, { rD }, { rA, simm }, { },          "Add Immediate Carrying" },
   { "addico",  { { xo1, 13 }                            }, { rD }, { rA, simm }, { },          "Add Immediate Carrying and Record" },
   { "addis",   { { xo1, 15 }                            }, { rD }, { rA, simm }, { },          "Add Immediate Shifted" },
   { "addme",   { { xo1, 31 }, { xo3,  234 }             }, { rD }, { rA }, { oe, rc },         "Add to Minus One Extended" },
   { "addze",   { { xo1, 31 }, { xo3,  202 }             }, { rD }, { rA }, { oe, rc },         "Add to Zero Extended" },
   { "and",     { { xo1, 31 }, { xo2,   28 }             }, { rA }, { rS, rB }, { rc },         "AND" },
   { "andc",    { { xo1, 31 }, { xo2,   60 }             }, { rA }, { rS, rB }, { rc },         "AND with Complement" },
   { "andio",   { { xo1, 28 }                            }, { rA }, { rS, uimm }, { },          "AND Immediate" },
   { "andiso",  { { xo1, 29 }                            }, { rA }, { rS, uimm }, { },          "AND Immediate Shifted" },
   { "b",       { { xo1, 18 }                            }, { }, { li }, { aa, lk },            "Branch" },
   { "bc",      { { xo1, 16 }                            }, { }, { bo, bi, bd }, { aa, lk },    "Branch Conditional" },
   { "bcctr",   { { xo1, 19 }, { xo2,  528 }             }, { }, { bo, bi, bh }, { lk },        "Branch Conditional to Count Register" },
   { "bclr",    { { xo1, 19 }, { xo2,   16 }             }, { }, { bo, bi, bh }, { lk },        "Branch Conditional to Link Register" },
   { "cmp",     { { xo1, 31 }, { xo2,    0 }             }, { crfD }, { l, rA, rB }, { },       "Compare" },
   { "cmpi",    { { xo1, 11 }                            }, { }, { crfD, l, rA, simm }, { },    "Compare Immediate" },
   { "cmpl",    { { xo1, 31 }, { xo2,   32 }             }, { crfD }, { l, rA, rB }, { },       "Compare Logical" },
   { "cmpli",   { { xo1, 10 }                            }, { }, { crfD, l, rA, uimm }, { },    "Compare Logical Immediate" },
   { "cntlzd",  { { xo1, 31 }, { xo2,   58 }             }, { rA }, { rS }, { },                "Count Leading Zeros Doubleword" },
   { "cntlzw",  { { xo1, 31 }, { xo2,   26 }             }, { rA }, { rS }, { },                "Count Leading Zeros Word" },
   { "crand",   { { xo1, 19 }, { xo2,  257 }             }, { crbD }, { crbA, crbB }, { },      "Condition Register AND" },
   { "crandc",  { { xo1, 19 }, { xo2,  129 }             }, { crbD }, { crbA, crbB }, { },      "Condition Register AND with Complement" },
   { "creqv",   { { xo1, 19 }, { xo2,  289 }             }, { crbD }, { crbA, crbB }, { },      "Condition Register Equivalent" },
   { "crnand",  { { xo1, 19 }, { xo2,  225 }             }, { crbD }, { crbA, crbB }, { },      "Condition Register NAND" },
   { "crnor",   { { xo1, 19 }, { xo2,   33 }             }, { crbD }, { crbA, crbB }, { },      "Condition Register NOR" },
   { "cror",    { { xo1, 19 }, { xo2,  449 }             }, { crbD }, { crbA, crbB }, { },      "Condition Register OR" },
   { "crorc",   { { xo1, 19 }, { xo2,  417 }             }, { crbD }, { crbA, crbB }, { },      "Condition Register OR with Complement" },
   { "crxor",   { { xo1, 19 }, { xo2,  193 }             }, { crbD }, { crbA, crbB }, { },      "Condition Register XOR" },
   { "dcbf",    { { xo1, 31 }, { xo2,   86 }             }, { }, { rA, rB }, { },               "Data Cache Block Flush" },
   { "dcbst",   { { xo1, 31 }, { xo2,   54 }             }, { }, { rA, rB }, { },               "Data Cache Block Store" },
   { "dcbt",    { { xo1, 31 }, { xo2,  278 }             }, { }, { rA, rB, th }, { },           "Data Cache Block Touch" },
   { "dcbtst",  { { xo1, 31 }, { xo2,  246 }             }, { }, { rA, rB }, { },               "Data Cache Block Touch for Store" },
   { "dcbz",    { { xo1, 31 }, { xo2, 1014 }             }, { }, { rA, rB }, { },               "Data Cache Clear to Zero" },
   { "divd",    { { xo1, 31 }, { xo3,  489 }             }, { rD }, { rA, rB }, { oe, rc },     "Divide Doubleword" },
   { "divdu",   { { xo1, 31 }, { xo3,  457 }             }, { rD }, { rA, rB }, { oe, rc },     "Divide Doubleword Unsigned" },
   { "divw",    { { xo1, 31 }, { xo3,  491 }             }, { rD }, { rA, rB }, { oe, rc },     "Divide Word" },
   { "divwu",   { { xo1, 31 }, { xo3,  459 }             }, { rD }, { rA, rB }, { oe, rc },     "Divide Word Unsigned" },
   { "eciwx",   { { xo1, 31 }, { xo2,  310 }             }, { rD }, { rA, rB }, { },            "External Control In Word Indexed" },
   { "ecowx",   { { xo1, 31 }, { xo2,  438 }             }, { }, { rS, rA, rB }, { },           "External Control Out Word Indexed" },
   { "eieio",   { { xo1, 31 }, { xo2,  854 }             }, { }, { }, { },                      "Enforce In-Order Execution of I/O" },
   { "eqv",     { { xo1, 31 }, { xo3,  284 }             }, { rA }, { rS, rB }, { rc },         "Equivalent" },
   { "extsb",   { { xo1, 31 }, { xo2,  954 }             }, { rA }, { rS }, { rc },             "Extend Sign Byte" },
   { "extsh",   { { xo1, 31 }, { xo2,  922 }             }, { rA }, { rS }, { rc },             "Extend Sign Halfword" },
   { "extsw",   { { xo1, 31 }, { xo2,  986 }             }, { rA }, { rS }, { rc },             "Extend Sign Word" },
   { "fabs",    { { xo1, 63 }, { xo2,  264 }             }, { frD }, { frA }, { rc },           "Floating Absolute Value" },
   { "fadd",    { { xo1, 63 }, { xo2,   21 }             }, { frD }, { frA, frB }, { rc },      "Floating Add (Double-Precision)" },
   { "fadds",   { { xo1, 59 }, { xo2,   21 }             }, { frD }, { frA, frB }, { rc },      "Floating Add Single" },
   { "fcfid",   { { xo1, 63 }, { xo2,  846 }             }, { frD }, { frB }, { rc },           "Floating Convert from Integer Doubleword" },
   { "fcmpo",   { { xo1, 63 }, { xo2,   32 }             }, { crfD }, { frA, frB }, { rc },     "Floating Compare Ordered" },
   { "fcmpu",   { { xo1, 63 }, { xo2,    0 }             }, { crfD }, { frA, frB }, { rc },     "Floating Compare Unordered" },
   { "fctid",   { { xo1, 63 }, { xo2,  814 }             }, { frD }, { frB }, { rc },           "Floating Convert to Integer Doubleword" },
   { "fctidz",  { { xo1, 63 }, { xo2,  815 }             }, { frD }, { frB }, { rc },           "Floating Convert to Integer Doubleword with round toward Zero" },
   { "fctiw",   { { xo1, 63 }, { xo2,   14 }             }, { frD }, { frB }, { rc },           "Floating Convert to Integer Word" },
   { "fctiwz",  { { xo1, 63 }, { xo2,   15 }             }, { frD }, { frB }, { rc },           "Floating Convert to Integer Word with round toward Zero" },
   { "fdiv",    { { xo1, 63 }, { xo2,   18 }             }, { frD }, { frA, frB }, { rc },      "Floating Divide (Double-Precision)" },
   { "fdivs",   { { xo1, 59 }, { xo2,   18 }             }, { frD }, { frA, frB }, { rc },      "Floating Divide Single" },
   { "fmadd",   { { xo1, 63 }, { xo4,   29 }             }, { frD }, { frA, frC, frB }, { rc }, "Floating Multiply-Add (Double-Precision)" },
   { "fmadds",  { { xo1, 59 }, { xo4,   29 }             }, { frD }, { frA, frC, frB }, { rc }, "Floating Multiply-Add Single" },
   { "fmr",     { { xo1, 63 }, { xo2,   72 }             }, { frD }, { frB }, { rc },           "Floating Move Register (Double-Precision)" },
   { "fmsub",   { { xo1, 63 }, { xo4,   28 }             }, { frD }, { frA, frC, frB }, { rc }, "Floating Multiply-Subtract (Double-Precision)" },
   { "fmsubs",  { { xo1, 59 }, { xo4,   28 }             }, { frD }, { frA, frC, frB }, { rc }, "Floating Multiply-Subtract Single" },
   { "fmul",    { { xo1, 63 }, { xo4,   25 }             }, { frD }, { frA, frC }, { rc },      "Floating Multiply (Double-Precision)" },
   { "fmuls",   { { xo1, 59 }, { xo4,   25 }             }, { frD }, { frA, frC }, { rc },      "Floating Multiply Single" },
   { "fnabs",   { { xo1, 63 }, { xo2,  136 }             }, { frD }, { frB }, { rc },           "Floating Negative Absolute Value" },
   { "fneg",    { { xo1, 63 }, { xo2,   40 }             }, { frD }, { frB }, { rc },           "Floating Negate" },
   { "fnmadd",  { { xo1, 63 }, { xo4,   31 }             }, { frD }, { frA, frC, frB }, { rc }, "Floating Negative Multiply-Add (Double-Precision)" },
   { "fnmadds", { { xo1, 59 }, { xo4,   31 }             }, { frD }, { frA, frC, frB }, { rc }, "Floating Negative Multiply-Add Single" },
   { "fnmsub",  { { xo1, 63 }, { xo4,   30 }             }, { frD }, { frA, frC, frB }, { rc }, "Floating Negative Multiply-Subtract (Double-Precision)" },
   { "fnmsubs", { { xo1, 59 }, { xo4,   30 }             }, { frD }, { frA, frC, frB }, { rc }, "Floating Negative Multiply-Subtract Single" },
   { "fres",    { { xo1, 59 }, { xo4,   24 }             }, { frD }, { frB }, { rc },           "Floating Reciprocal Estimate Single" },
   { "frsp",    { { xo1, 63 }, { xo2,   12 }             }, { frD }, { frB }, { rc },           "Floating Round to Single" },
   { "frsqrte", { { xo1, 63 }, { xo4,   26 }             }, { frD }, { frB }, { rc },           "Floating Reciprocal Square Root Estimate" },
   { "fsel",    { { xo1, 63 }, { xo4,   23 }             }, { frD }, { frA, frC, frB }, { rc }, "Floating Select" },
   { "fsqrt",   { { xo1, 63 }, { xo2,   22 }             }, { frD }, { frB }, { rc },           "Floating Square Root (Double-Precision)" },
   { "fsqrts",  { { xo1, 59 }, { xo2,   22 }             }, { frD }, { frB }, { rc },           "Floating Square Root Single" },
   { "fsub",    { { xo1, 63 }, { xo2,   20 }             }, { frD }, { frA, frB }, { rc },      "Floating Subtract (Double-Precision)" },
   { "fsubs",   { { xo1, 59 }, { xo2,   20 }             }, { frD }, { frA, frB }, { rc },      "Floating Subtract Single" },
   { "icbi",    { { xo1, 31 }, { xo2,  982 }             }, { }, { rA, rB }, { },               "Instruction Cache Block Invalidate" },
   { "isync",   { { xo1, 19 }, { xo2,  150 }             }, { }, { rA, rB }, { },               "Instruction Synchronize" },
   { "krncall", { { xo1,  5 }                            }, { }, { uimm }, { },                 "Kernel Function Call" },
   { "lbz",     { { xo1, 34 }                            }, { rD }, { d, rA }, { },             "Load Byte and Zero" },
   { "lbzu",    { { xo1, 35 }                            }, { rD }, { d, rA }, { },             "Load Byte and Zero with Update" },
   { "lbzux",   { { xo1, 31 }, { xo2,  119 }             }, { rD }, { rA, rB }, { },            "Load Byte and Zero with Update Indexed" },
   { "lbzx",    { { xo1, 31 }, { xo2,   87 }             }, { rD }, { rA, rB }, { },            "Load Byte and Zero Indexed" },
   { "ld",      { { xo1, 58 }, { xo5,    0 }             }, { rD }, { ds, rA }, { },            "Load Doubleword" },
   { "ldarx",   { { xo1, 31 }, { xo2,   84 }             }, { rD }, { rA, rB }, { },            "Load Doubleword and Reserve Indexed" },
   { "ldu",     { { xo1, 58 }, { xo5,    1 }             }, { rD }, { ds, rA }, { },            "Load Doubleword with Update" },
   { "ldux",    { { xo1, 31 }, { xo2,   53 }             }, { rD }, { rA, rB }, { },            "Load Doubleword with Update Indexed" },
   { "ldx",     { { xo1, 31 }, { xo2,   21 }             }, { rD }, { rA, rB }, { },            "Load Doubleword Indexed" },
   { "lfd",     { { xo1, 50 }                            }, { frD }, { d, rA }, { },            "Load Floating-Point Double" },
   { "lfdu",    { { xo1, 51 }                            }, { frD }, { d, rA }, { },            "Load Floating-Point Double with Update" },
   { "lfdux",   { { xo1, 31 }, { xo2,  631 }             }, { frD }, { rA, rB }, { },           "Load Floating-Point Double with Update Indexed" },
   { "lfdx",    { { xo1, 31 }, { xo2,  599 }             }, { frD }, { rA, rB }, { },           "Load Floating-Point Double Indexed" },
   { "lfs",     { { xo1, 48 }                            }, { frD }, { d, rA }, { },            "Load Floating-Point Single" },
   { "lfsu",    { { xo1, 49 }                            }, { frD }, { d, rA }, { },            "Load Floating-Point Single with Update" },
   { "lfsux",   { { xo1, 31 }, { xo2,  567 }             }, { frD }, { rA, rB }, { },           "Load Floating-Point Single with Update Indexed" },
   { "lfsx",    { { xo1, 31 }, { xo2,  535 }             }, { frD }, { rA, rB }, { },           "Load Floating-Point Single Indexed" },
   { "lha",     { { xo1, 42 }                            }, { rD }, { d, rA }, { },             "Load Halfword Algebraic" },
   { "lhau",    { { xo1, 43 }                            }, { rD }, { d, rA }, { },             "Load Halfword Algebraic with Update" },
   { "lhaux",   { { xo1, 31 }, { xo2,  375 }             }, { rD }, { rA, rB }, { },            "Load Halfword Algebraic with Update Indexed" },
   { "lhax",    { { xo1, 31 }, { xo2,  343 }             }, { rD }, { rA, rB }, { },            "Load Halfword Algebraic Indexed" },
   { "lhbrx",   { { xo1, 31 }, { xo2,  790 }             }, { rD }, { rA, rB }, { },            "Load Halfword Byte-Reverse Indexed" },
   { "lhz",     { { xo1, 40 }                            }, { rD }, { d, rA }, { },             "Load Halfword and Zero" },
   { "lhzu",    { { xo1, 41 }                            }, { rD }, { d, rA }, { },             "Load Halfword and Zero with Update" },
   { "lhzux",   { { xo1, 31 }, { xo2,  311 }             }, { rD }, { rA, rB }, { },            "Load Halfword and Zero with Update Indexed" },
   { "lhzx",    { { xo1, 31 }, { xo2,  279 }             }, { rD }, { rA, rB }, { },            "Load Halfword and Zero Indexed" },
   { "lmw",     { { xo1, 46 }                            }, { rD }, { d, rA }, { },             "Load Multiple Word" },
   { "lswi",    { { xo1, 31 }, { xo2,  597 }             }, { rD }, { rA, nb }, { },            "Load String Word Immediate" },
   { "lswx",    { { xo1, 31 }, { xo2,  533 }             }, { rD }, { rA, rB }, { },            "Load String Word Indexed" },
   { "lwa",     { { xo1, 58 }, { xo5,    2 }             }, { rD }, { ds, rA }, { },            "Load Word Algebraic" },
   { "lwarx",   { { xo1, 31 }, { xo2,   20 }             }, { rD }, { rA, rB }, { },            "Load Word and Reserve Indexed" },
   { "lwaux",   { { xo1, 31 }, { xo2,  373 }             }, { rD }, { rA, rB }, { },            "Load Word Algebraic with Update Indexed" },
   { "lwax",    { { xo1, 31 }, { xo2,  341 }             }, { rD }, { rA, rB }, { },            "Load Word Algebraic Indexed" },
   { "lwbrx",   { { xo1, 31 }, { xo2,  534 }             }, { rD }, { rA, rB }, { },            "Load Word Byte-Reverse Indexed" },
   { "lwz",     { { xo1, 32 }                            }, { rD }, { d, rA }, { },             "Load Word and Zero" },
   { "lwzu",    { { xo1, 33 }                            }, { rD }, { d, rA }, { },             "Load Word and Zero with Update" },
   { "lwzux",   { { xo1, 31 }, { xo2,   55 }             }, { rD }, { rA, rB }, { },            "Load Word and Zero with Update Indexed" },
   { "lwzx",    { { xo1, 31 }, { xo2,   23 }             }, { rD }, { rA, rB }, { },            "Load Word and Zero Indexed" },
   { "mcrf",    { { xo1, 19 }, { xo2,    0 }             }, { crfD }, { crfS }, { },            "Move Condition Register Field" },
   { "mcrfs",   { { xo1, 63 }, { xo2,   64 }             }, { crfD }, { crfS }, { },            "Move to Condition Register from FPSCR" },
   { "mfcr",    { { xo1, 31 }, { xo2,   19 }, { xo6, 0 } }, { rD }, { }, { },                   "Move from Condition Register" },
   { "mffs",    { { xo1, 63 }, { xo2,  583 }             }, { frD }, { }, { rc },               "Move from FPSCR" },
   { "mfmsr",   { { xo1, 31 }, { xo2,   83 }             }, { rD }, { }, { },                   "Move from Machine State Register" },
   { "mfocrf",  { { xo1, 31 }, { xo2,   19 }, { xo6, 1 } }, { rD }, { crm }, { },               "Move from One Condition Register Field" },
   { "mfspr",   { { xo1, 31 }, { xo2,  339 }             }, { rD }, { spr }, { },               "Move from Special-Purpose Register" },
   { "mfsr",    { { xo1, 31 }, { xo2,  595 }             }, { rD }, { sr }, { },                "Move from Segment Register" },
   { "mfsrin",  { { xo1, 31 }, { xo2,  659 }             }, { rD }, { rB }, { },                "Move from Segment Register Indirect" },
   { "mftb",    { { xo1, 31 }, { xo2,  371 }             }, { rD }, { tbr }, { },               "Move from Time Base" },
   { "mtcrf",   { { xo1, 31 }, { xo2,  144 }, { xo6, 0 } }, { }, { crm, rS }, { },              "Move to Condition Register Fields" },
   { "mtfsb0",  { { xo1, 63 }, { xo2,   70 }             }, { crbD }, { }, { rc },              "Move to FPSCR Bit 0" },
   { "mtfsb1",  { { xo1, 63 }, { xo2,   38 }             }, { crbD }, { }, { rc },              "Move to FPSCR Bit 1" },
   { "mtfsf",   { { xo1, 63 }, { xo2,  711 }             }, { }, { fm, frB }, { rc },           "Move to FPSCR Fields" },
   { "mtfsfi",  { { xo1, 63 }, { xo2,  134 }             }, { }, { crfD, uimm }, { rc },        "Move to FPSCR Field Immediate" },
   { "mtmsr",   { { xo1, 31 }, { xo2,  146 }             }, { }, { rS, l15 }, { },              "Move to Machine State Register" },
   { "mtmsrd",  { { xo1, 31 }, { xo2,  178 }             }, { }, { rS, l15 }, { },              "Move to Machine State Register Doubleword" },
   { "mtocrf",  { { xo1, 31 }, { xo2,  144 }, { xo6, 1 } }, { }, { crm, rS }, { },              "Move to One Condition Register Field" },
   { "mtspr",   { { xo1, 31 }, { xo2,  467 }             }, { }, { spr, rS }, { },              "Move to Special-Purpose Register" },
   { "mtsr",    { { xo1, 31 }, { xo2,  210 }             }, { }, { sr, rS }, { },               "Move to Segment Register" },
   { "mtsrin",  { { xo1, 31 }, { xo2,  242 }             }, { }, { rS, rB }, { },               "Move to Segment Register Indirect" },
   { "mulhd",   { { xo1, 31 }, { xo3,   73 }             }, { rD }, { rA, rB }, { rc },         "Multiply High Doubleword" },
   { "mulhdu",  { { xo1, 31 }, { xo3,    9 }             }, { rD }, { rA, rB }, { rc },         "Multiply High Doubleword Unsigned" },
   { "mulhw",   { { xo1, 31 }, { xo3,   75 }             }, { rD }, { rA, rB }, { rc },         "Multiply High Word" },
   { "mulhwu",  { { xo1, 31 }, { xo3,   11 }             }, { rD }, { rA, rB }, { rc },         "Multiply High Word Unsigned" },
   { "mulld",   { { xo1, 31 }, { xo3,  233 }             }, { rD }, { rA, rB }, { oe, rc },     "Multiply Low Doubleword" },
   { "mulli",   { { xo1,  7 }                            }, { rD }, { rA, simm }, { },          "Multiply Low Immediate" },
   { "mullw",   { { xo1, 31 }, { xo3,  235 }             }, { rD }, { rA, rB }, { oe, rc },     "Multiply Low Word" },
   { "nand",    { { xo1, 31 }, { xo2,  476 }             }, { rA }, { rS, rB }, { rc },         "NAND" },
   { "neg",     { { xo1, 31 }, { xo3,   31 }             }, { rD }, { rA }, { oe, rc },         "Negate" },
   { "nor",     { { xo1, 31 }, { xo2,  124 }             }, { rA }, { rS, rB }, { rc },         "NOR" },
   { "or",      { { xo1, 31 }, { xo2,  444 }             }, { rA }, { rS, rB }, { rc },         "OR" },
   { "orc",     { { xo1, 31 }, { xo2,  412 }             }, { rA }, { rS, rB }, { rc },         "OR with Complement" },
   { "ori",     { { xo1, 24 }                            }, { rA }, { rS, uimm }, { },          "OR Immediate" },
   { "oris",    { { xo1, 25 }                            }, { rA }, { rS, uimm }, { },          "OR Immediate Shifted" },
   { "rfid",    { { xo1, 19 }, { xo2,   18 }             }, { }, { }, { },                      "Return from Interrupt Doubleword" },
   { "rldcl",   { { xo1, 30 }, { xo7,    8 }             }, { rA }, { rS, rB, mb }, { rc },     "Rotate Left Doubleword then Clear Left" },
   { "rldcr",   { { xo1, 30 }, { xo7,    9 }             }, { rA }, { rS, rB, mb }, { rc },     "Rotate Left Doubleword then Clear Right" },
   { "rldic",   { { xo1, 30 }, { xo8,    2 }             }, { rA }, { rS, sh, mb }, { rc },     "Rotate Left Doubleword Immediate then Clear" },
   { "rldicl",  { { xo1, 30 }, { xo8,    0 }             }, { rA }, { rS, sh, mb }, { rc },     "Rotate Left Doubleword Immediate then Clear Left" },
   { "rldicr",  { { xo1, 30 }, { xo8,    1 }             }, { rA }, { rS, sh, mb }, { rc },     "Rotate Left Doubleword Immediate then Clear Right" },
   { "rldimi",  { { xo1, 30 }, { xo8,    3 }             }, { rA }, { rS, sh, mb }, { rc },     "Rotate Left Doubleword Immediate then Mask Insert" },
   { "rlwimi",  { { xo1, 20 }                            }, { rA }, { rS, sh, mb, me }, { rc }, "Rotate Left Word Immediate then Mask Insert" },
   { "rlwinm",  { { xo1, 21 }                            }, { rA }, { rS, sh, mb, me }, { rc }, "Rotate Left Word Immediate then AND with Mask" },
   { "rlwnm",   { { xo1, 23 }                            }, { rA }, { rS, rB, mb, me }, { rc }, "Rotate Left Word then AND with Mask" },
   { "sc",      { { xo1, 17 }                            }, { }, { }, { },                      "System Call" },
   { "slbia",   { { xo1, 31 }, { xo2,  498 }             }, { }, { }, { },                      "SLB Invalidate All" },
   { "slbie",   { { xo1, 31 }, { xo2,  434 }             }, { }, { rB }, { },                   "SLB Invalidate Entry" },
   { "slbmfee", { { xo1, 31 }, { xo2,  915 }             }, { rD }, { rB }, { },                "SLB Move From Entry ESID" },
   { "slbmfev", { { xo1, 31 }, { xo2,  851 }             }, { rD }, { rB }, { },                "SLB Move From Entry VSID" },
   { "slbmte",  { { xo1, 31 }, { xo2,  402 }             }, { }, { rS, rB }, { },               "SLB Move To Entry" },
   { "sld",     { { xo1, 31 }, { xo2,   27 }             }, { rA }, { rS, rB }, { rc },         "Shift Left Doubleword" },
   { "slw",     { { xo1, 31 }, { xo2,   24 }             }, { rA }, { rS, rB }, { rc },         "Shift Left Word" },
   { "srad",    { { xo1, 31 }, { xo2,  794 }             }, { rA }, { rS, rB }, { rc },         "Shift Right Algebraic Doubleword" },
   { "sradi",   { { xo1, 31 }, { xo2,  827 }             }, { rA }, { rS, sh }, { rc },         "Shift Right Algebraic Doubleword Immediate" },
   { "sraw",    { { xo1, 31 }, { xo2,  792 }             }, { rA }, { rS, rB }, { rc },         "Shift Right Algebraic Word" },
   { "srawi",   { { xo1, 31 }, { xo2,  824 }             }, { rA }, { rS, sh }, { rc },         "Shift Right Algebraic Word Immediate" },
   { "srd",     { { xo1, 31 }, { xo2,  539 }             }, { rA }, { rS, rB }, { rc },         "Shift Right Doubleword" },
   { "srw",     { { xo1, 31 }, { xo2,  536 }             }, { rA }, { rS, rB }, { rc },         "Shift Right Word" },
   { "stb",     { { xo1, 38 }                            }, { }, { rS, d, rA }, { },            "Store Byte" },
   { "stbu",    { { xo1, 39 }                            }, { }, { rS, d, rA }, { },            "Store Byte with Update" },
   { "stbux",   { { xo1, 31 }, { xo3,  247 }             }, { }, { rS, rA, rB }, { },           "Store Byte with Update Indexed" },
   { "stbx",    { { xo1, 31 }, { xo3,  215 }             }, { }, { rS, rA, rB }, { },           "Store Byte Indexed" },
   { "std",     { { xo1, 62 }, { xo5,    0 }             }, { }, { rS, ds, rA }, { },           "Store Doubleword" },
   { "stdcx",   { { xo1, 31 }, { xo2,  214 }             }, { }, { rS, rA, rB }, { rc },        "Store Doubleword Conditional Indexed" },
   { "stdu",    { { xo1, 62 }, { xo5,    1 }             }, { }, { rS, ds, rA }, { },           "Store Doubleword with Update" },
   { "stdux",   { { xo1, 31 }, { xo2,  181 }             }, { }, { rS, rA, rB }, { },           "Store Doubleword with Update Indexed" },
   { "stdx",    { { xo1, 31 }, { xo2,  149 }             }, { }, { rS, rA, rB }, { },           "Store Doubleword Indexed" },
   { "stfd",    { { xo1, 54 }                            }, { }, { frS, d, rA }, { },           "Store Floating-Point Double" },
   { "stfdu",   { { xo1, 55 }                            }, { }, { frS, d, rA }, { },           "Store Floating-Point Double with Update" },
   { "stfdux",  { { xo1, 31 }, { xo2,  759 }             }, { }, { frS, rA, rB }, { },          "Store Floating-Point Double with Update Indexed" },
   { "stfdx",   { { xo1, 31 }, { xo2,  727 }             }, { }, { frS, rA, rB }, { },          "Store Floating-Point Double Indexed" },
   { "stfiwx",  { { xo1, 31 }, { xo2,  983 }             }, { }, { frS, rA, rB }, { },          "Store Floating-Point as Integer Word Indexed" },
   { "stfs",    { { xo1, 52 }                            }, { }, { frS, d, rA }, { },           "Store Floating-Point Single" },
   { "stfsu",   { { xo1, 53 }                            }, { }, { frS, d, rA }, { },           "Store Floating-Point Single with Update" },
   { "stfsux",  { { xo1, 31 }, { xo2,  795 }             }, { }, { frS, rA, rB }, { },          "Store Floating-Point Single with Update Indexed" },
   { "stfsx",   { { xo1, 31 }, { xo2,  663 }             }, { }, { frS, rA, rB }, { },          "Store Floating-Point Single Indexed" },
   { "sth",     { { xo1, 44 }                            }, { }, { rS, d, rA }, { },            "Store Halfword" },
   { "sthbrx",  { { xo1, 31 }, { xo2,  918 }             }, { }, { rS, rA, rB }, { },           "Store Halfword Byte-Reverse Indexed" },
   { "sthu",    { { xo1, 45 }                            }, { }, { rS, d, rA }, { },            "Store Halfword with Update" },
   { "sthux",   { { xo1, 31 }, { xo2,  439 }             }, { }, { rS, rA, rB }, { },           "Store Halfword with Update Indexed" },
   { "sthx",    { { xo1, 31 }, { xo2,  407 }             }, { }, { rS, rA, rB }, { },           "Store Halfword Indexed" },
   { "stmw",    { { xo1, 47 }                            }, { }, { rS, d, rA }, { },            "Store Multiple Word" },
   { "stswi",   { { xo1, 31 }, { xo2,  725 }             }, { }, { rS, rA, nb }, { },           "Store String Word Immediate" },
   { "stswx",   { { xo1, 31 }, { xo2,  661 }             }, { }, { rS, rA, rB }, { },           "Store String Word Indexed" },
   { "stw",     { { xo1, 36 }                            }, { }, { rS, d, rA }, { },            "Store Word" },
   { "stwbrx",  { { xo1, 31 }, { xo2,  662 }             }, { }, { rS, rA, rB }, { },           "Store Word Byte-Reverse Indexed" },
   { "stwcx",   { { xo1, 31 }, { xo2,  150 }             }, { }, { rS, rA, rB }, { rc },        "Store Word Conditional Indexed" },
   { "stwu",    { { xo1, 37 }                            }, { }, { rS, d, rA }, { },            "Store Word with Update" },
   { "stwux",   { { xo1, 31 }, { xo2,  183 }             }, { }, { rS, rA, rB }, { },           "Store Word with Update Indexed" },
   { "stwx",    { { xo1, 31 }, { xo2,  151 }             }, { }, { rS, rA, rB }, { },           "Store Word Indexed" },
   { "subf",    { { xo1, 31 }, { xo3,   40 }             }, { rD }, { rA, rB }, { oe, rc },     "Subtract From" },
   { "subfc",   { { xo1, 31 }, { xo3,    8 }             }, { rD }, { rA, rB }, { oe, rc },     "Subtract From Carrying" },
   { "subfe",   { { xo1, 31 }, { xo3,  136 }             }, { rD }, { rA, rB }, { oe, rc },     "Subtract From Extended" },
   { "subfic",  { { xo1,  8 }                            }, { rD }, { rA, simm }, { },          "Subtract From Immediate Carrying" },
   { "subfme",  { { xo1, 31 }, { xo3,  232 }             }, { rD }, { rA }, { oe, rc },         "Subtract From Minus One Extended" },
   { "subfze",  { { xo1, 31 }, { xo3,  200 }             }, { rD }, { rA }, { oe, rc },         "Subtract From Zero Extended" },
   { "sync",    { { xo1, 31 }, { xo2,  598 }             }, { }, { syncl }, { },                "Synchronize" },
   { "td",      { { xo1, 31 }, { xo2,   31 }             }, { }, { to, rA, rB }, { },           "Trap Doubleword" },
   { "tdi",     { { xo1,  2 }                            }, { }, { to, rA, simm }, { },         "Trap Doubleword Immediate" },
   { "tlbia",   { { xo1, 31 }, { xo2,  370 }             }, { }, { }, { },                      "Translation Lookaside Buffer Invalidate All" },
   { "tlbie",   { { xo1, 31 }, { xo2,  306 }             }, { }, { rB, tlbl }, { },             "Translation Lookaside Buffer Invalidate Entry" },
   { "tlbiel",  { { xo1, 31 }, { xo2,  274 }             }, { }, { rB, tlbl }, { },             "Translation Lookaside Buffer Invalidate Entry Local" },
   { "tlbsync", { { xo1, 31 }, { xo2,  566 }             }, { }, { }, { },                      "Translation Lookaside Buffer Synchronize" },
   { "tw",      { { xo1, 31 }, { xo2,    4 }             }, { }, { to, rA, rB }, { },           "Trap Word" },
   { "twi",     { { xo1,  3 }                            }, { }, { to, rA, simm }, { },         "Trap Word Immediate" },
   { "xor",     { { xo1, 31 }, { xo2,  316 }             }, { rA }, { rS, rB }, { rc },         "XOR" },
   { "xori",    { { xo1, 26 }                            }, { rA }, { rS, uimm }, { },          "XOR Immediate" },
   { "xoris",   { { xo1, 27 }                            }, { rA }, { rS, uimm }, { },          "XOR Immediate Shifted" },
};

```

`src/powerpc/emugen_stubs.cpp`:

```cpp
/* Add */
bool add(State *state, Instruction instr)
{
   return false;
}

/* Add Carrying */
bool addc(State *state, Instruction instr)
{
   return false;
}

/* Add Extended */
bool adde(State *state, Instruction instr)
{
   return false;
}

/* Add Immediate */
bool addi(State *state, Instruction instr)
{
   return false;
}

/* Add Immediate Carrying */
bool addic(State *state, Instruction instr)
{
   return false;
}

/* Add Immediate Carrying and Record */
bool addico(State *state, Instruction instr)
{
   return false;
}

/* Add Immediate Shifted */
bool addis(State *state, Instruction instr)
{
   return false;
}

/* Add to Minus One Extended */
bool addme(State *state, Instruction instr)
{
   return false;
}

/* Add to Zero Extended */
bool addze(State *state, Instruction instr)
{
   return false;
}

/* AND */
bool and(State *state, Instruction instr)
{
   return false;
}

/* AND with Complement */
bool andc(State *state, Instruction instr)
{
   return false;
}

/* AND Immediate */
bool andio(State *state, Instruction instr)
{
   return false;
}

/* AND Immediate Shifted */
bool andiso(State *state, Instruction instr)
{
   return false;
}

/* Branch */
bool b(State *state, Instruction instr)
{
   return false;
}

/* Branch Conditional */
bool bc(State *state, Instruction instr)
{
   return false;
}

/* Branch Conditional to Count Register */
bool bcctr(State *state, Instruction instr)
{
   return false;
}

/* Branch Conditional to Link Register */
bool bclr(State *state, Instruction instr)
{
   return false;
}

/* Compare */
bool cmp(State *state, Instruction instr)
{
   return false;
}

/* Compare Immediate */
bool cmpi(State *state, Instruction instr)
{
   return false;
}

/* Compare Logical */
bool cmpl(State *state, Instruction instr)
{
   return false;
}

/* Compare Logical Immediate */
bool cmpli(State *state, Instruction instr)
{
   return false;
}

/* Count Leading Zeros Doubleword */
bool cntlzd(State *state, Instruction instr)
{
   return false;
}

/* Count Leading Zeros Word */
bool cntlzw(State *state, Instruction instr)
{
   return false;
}

/* Condition Register AND */
bool crand(State *state, Instruction instr)
{
   return false;
}

/* Condition Register AND with Complement */
bool crandc(State *state, Instruction instr)
{
   return false;
}

/* Condition Register Equivalent */
bool creqv(State *state, Instruction instr)
{
   return false;
}

/* Condition Register NAND */
bool crnand(State *state, Instruction instr)
{
   return false;
}

/* Condition Register NOR */
bool crnor(State *state, Instruction instr)
{
   return false;
}

/* Condition Register OR */
bool cror(State *state, Instruction instr)
{
   return false;
}

/* Condition Register OR with Complement */
bool crorc(State *state, Instruction instr)
{
   return false;
}

/* Condition Register XOR */
bool crxor(State *state, Instruction instr)
{
   return false;
}

/* Data Cache Block Flush */
bool dcbf(State *state, Instruction instr)
{
   return false;
}

/* Data Cache Block Store */
bool dcbst(State *state, Instruction instr)
{
   return false;
}

/* Data Cache Block Touch */
bool dcbt(State *state, Instruction instr)
{
   return false;
}

/* Data Cache Block Touch for Store */
bool dcbtst(State *state, Instruction instr)
{
   return false;
}

/* Data Cache Clear to Zero */
bool dcbz(State *state, Instruction instr)
{
   return false;
}

/* Divide Doubleword */
bool divd(State *state, Instruction instr)
{
   return false;
}

/* Divide Doubleword Unsigned */
bool divdu(State *state, Instruction instr)
{
   return false;
}

/* Divide Word */
bool divw(State *state, Instruction instr)
{
   return false;
}

/* Divide Word Unsigned */
bool divwu(State *state, Instruction instr)
{
   return false;
}

/* External Control In Word Indexed */
bool eciwx(State *state, Instruction instr)
{
   return false;
}

/* External Control Out Word Indexed */
bool ecowx(State *state, Instruction instr)
{
   return false;
}

/* Enforce In-Order Execution of I/O */
bool eieio(State *state, Instruction instr)
{
   return false;
}

/* Equivalent */
bool eqv(State *state, Instruction instr)
{
   return false;
}

/* Extend Sign Byte */
bool extsb(State *state, Instruction instr)
{
   return false;
}

/* Extend Sign Halfword */
bool extsh(State *state, Instruction instr)
{
   return false;
}

/* Extend Sign Word */
bool extsw(State *state, Instruction instr)
{
   return false;
}

/* Floating Absolute Value */
bool fabs(State *state, Instruction instr)
{
   return false;
}

/* Floating Add (Double-Precision) */
bool fadd(State *state, Instruction instr)
{
   return false;
}

/* Floating Add Single */
bool fadds(State *state, Instruction instr)
{
   return false;
}

/* Floating Convert from Integer Doubleword */
bool fcfid(State *state, Instruction instr)
{
   return false;
}

/* Floating Compare Ordered */
bool fcmpo(State *state, Instruction instr)
{
   return false;
}

/* Floating Compare Unordered */
bool fcmpu(State *state, Instruction instr)
{
   return false;
}

/* Floating Convert to Integer Doubleword */
bool fctid(State *state, Instruction instr)
{
   return false;
}

/* Floating Convert to Integer Doubleword with round toward Zero */
bool fctidz(State *state, Instruction instr)
{
   return false;
}

/* Floating Convert to Integer Word */
bool fctiw(State *state, Instruction instr)
{
   return false;
}

/* Floating Convert to Integer Word with round toward Zero */
bool fctiwz(State *state, Instruction instr)
{
   return false;
}

/* Floating Divide (Double-Precision) */
bool fdiv(State *state, Instruction instr)
{
   return false;
}

/* Floating Divide Single */
bool fdivs(State *state, Instruction instr)
{
   return false;
}

/* Floating Multiply-Add (Double-Precision) */
bool fmadd(State *state, Instruction instr)
{
   return false;
}

/* Floating Multiply-Add Single */
bool fmadds(State *state, Instruction instr)
{
   return false;
}

/* Floating Move Register (Double-Precision) */
bool fmr(State *state, Instruction instr)
{
   return false;
}

/* Floating Multiply-Subtract (Double-Precision) */
bool fmsub(State *state, Instruction instr)
{
   return false;
}

/* Floating Multiply-Subtract Single */
bool fmsubs(State *state, Instruction instr)
{
   return false;
}

/* Floating Multiply (Double-Precision) */
bool fmul(State *state, Instruction instr)
{
   return false;
}

/* Floating Multiply Single */
bool fmuls(State *state, Instruction instr)
{
   return false;
}

/* Floating Negative Absolute Value */
bool fnabs(State *state, Instruction instr)
{
   return false;
}

/* Floating Negate */
bool fneg(State *state, Instruction instr)
{
   return false;
}

/* Floating Negative Multiply-Add (Double-Precision) */
bool fnmadd(State *state, Instruction instr)
{
   return false;
}

/* Floating Negative Multiply-Add Single */
bool fnmadds(State *state, Instruction instr)
{
   return false;
}

/* Floating Negative Multiply-Subtract (Double-Precision) */
bool fnmsub(State *state, Instruction instr)
{
   return false;
}

/* Floating Negative Multiply-Subtract Single */
bool fnmsubs(State *state, Instruction instr)
{
   return false;
}

/* Floating Reciprocal Estimate Single */
bool fres(State *state, Instruction instr)
{
   return false;
}

/* Floating Round to Single */
bool frsp(State *state, Instruction instr)
{
   return false;
}

/* Floating Reciprocal Square Root Estimate */
bool frsqrte(State *state, Instruction instr)
{
   return false;
}

/* Floating Select */
bool fsel(State *state, Instruction instr)
{
   return false;
}

/* Floating Square Root (Double-Precision) */
bool fsqrt(State *state, Instruction instr)
{
   return false;
}

/* Floating Square Root Single */
bool fsqrts(State *state, Instruction instr)
{
   return false;
}

/* Floating Subtract (Double-Precision) */
bool fsub(State *state, Instruction instr)
{
   return false;
}

/* Floating Subtract Single */
bool fsubs(State *state, Instruction instr)
{
   return false;
}

/* Instruction Cache Block Invalidate */
bool icbi(State *state, Instruction instr)
{
   return false;
}

/* Instruction Synchronize */
bool isync(State *state, Instruction instr)
{
   return false;
}

/* Kernel Function Call */
bool krncall(State *state, Instruction instr)
{
   return false;
}

/* Load Byte and Zero */
bool lbz(State *state, Instruction instr)
{
   return false;
}

/* Load Byte and Zero with Update */
bool lbzu(State *state, Instruction instr)
{
   return false;
}

/* Load Byte and Zero with Update Indexed */
bool lbzux(State *state, Instruction instr)
{
   return false;
}

/* Load Byte and Zero Indexed */
bool lbzx(State *state, Instruction instr)
{
   return false;
}

/* Load Doubleword */
bool ld(State *state, Instruction instr)
{
   return false;
}

/* Load Doubleword and Reserve Indexed */
bool ldarx(State *state, Instruction instr)
{
   return false;
}

/* Load Doubleword with Update */
bool ldu(State *state, Instruction instr)
{
   return false;
}

/* Load Doubleword with Update Indexed */
bool ldux(State *state, Instruction instr)
{
   return false;
}

/* Load Doubleword Indexed */
bool ldx(State *state, Instruction instr)
{
   return false;
}

/* Load Floating-Point Double */
bool lfd(State *state, Instruction instr)
{
   return false;
}

/* Load Floating-Point Double with Update */
bool lfdu(State *state, Instruction instr)
{
   return false;
}

/* Load Floating-Point Double with Update Indexed */
bool lfdux(State *state, Instruction instr)
{
   return false;
}

/* Load Floating-Point Double Indexed */
bool lfdx(State *state, Instruction instr)
{
   return false;
}

/* Load Floating-Point Single */
bool lfs(State *state, Instruction instr)
{
   return false;
}

/* Load Floating-Point Single with Update */
bool lfsu(State *state, Instruction instr)
{
   return false;
}

/* Load Floating-Point Single with Update Indexed */
bool lfsux(State *state, Instruction instr)
{
   return false;
}

/* Load Floating-Point Single Indexed */
bool lfsx(State *state, Instruction instr)
{
   return false;
}

/* Load Halfword Algebraic */
bool lha(State *state, Instruction instr)
{
   return false;
}

/* Load Halfword Algebraic with Update */
bool lhau(State *state, Instruction instr)
{
   return false;
}

/* Load Halfword Algebraic with Update Indexed */
bool lhaux(State *state, Instruction instr)
{
   return false;
}

/* Load Halfword Algebraic Indexed */
bool lhax(State *state, Instruction instr)
{
   return false;
}

/* Load Halfword Byte-Reverse Indexed */
bool lhbrx(State *state, Instruction instr)
{
   return false;
}

/* Load Halfword and Zero */
bool lhz(State *state, Instruction instr)
{
   return false;
}

/* Load Halfword and Zero with Update */
bool lhzu(State *state, Instruction instr)
{
   return false;
}

/* Load Halfword and Zero with Update Indexed */
bool lhzux(State *state, Instruction instr)
{
   return false;
}

/* Load Halfword and Zero Indexed */
bool lhzx(State *state, Instruction instr)
{
   return false;
}

/* Load Multiple Word */
bool lmw(State *state, Instruction instr)
{
   return false;
}

/* Load String Word Immediate */
bool lswi(State *state, Instruction instr)
{
   return false;
}

/* Load String Word Indexed */
bool lswx(State *state, Instruction instr)
{
   return false;
}

/* Load Word Algebraic */
bool lwa(State *state, Instruction instr)
{
   return false;
}

/* Load Word and Reserve Indexed */
bool lwarx(State *state, Instruction instr)
{
   return false;
}

/* Load Word Algebraic with Update Indexed */
bool lwaux(State *state, Instruction instr)
{
   return false;
}

/* Load Word Algebraic Indexed */
bool lwax(State *state, Instruction instr)
{
   return false;
}

/* Load Word Byte-Reverse Indexed */
bool lwbrx(State *state, Instruction instr)
{
   return false;
}

/* Load Word and Zero */
bool lwz(State *state, Instruction instr)
{
   return false;
}

/* Load Word and Zero with Update */
bool lwzu(State *state, Instruction instr)
{
   return false;
}

/* Load Word and Zero with Update Indexed */
bool lwzux(State *state, Instruction instr)
{
   return false;
}

/* Load Word and Zero Indexed */
bool lwzx(State *state, Instruction instr)
{
   return false;
}

/* Move Condition Register Field */
bool mcrf(State *state, Instruction instr)
{
   return false;
}

/* Move to Condition Register from FPSCR */
bool mcrfs(State *state, Instruction instr)
{
   return false;
}

/* Move from Condition Register */
bool mfcr(State *state, Instruction instr)
{
   return false;
}

/* Move from FPSCR */
bool mffs(State *state, Instruction instr)
{
   return false;
}

/* Move from Machine State Register */
bool mfmsr(State *state, Instruction instr)
{
   return false;
}

/* Move from One Condition Register Field */
bool mfocrf(State *state, Instruction instr)
{
   return false;
}

/* Move from Special-Purpose Register */
bool mfspr(State *state, Instruction instr)
{
   return false;
}

/* Move from Segment Register */
bool mfsr(State *state, Instruction instr)
{
   return false;
}

/* Move from Segment Register Indirect */
bool mfsrin(State *state, Instruction instr)
{
   return false;
}

/* Move from Time Base */
bool mftb(State *state, Instruction instr)
{
   return false;
}

/* Move to Condition Register Fields */
bool mtcrf(State *state, Instruction instr)
{
   return false;
}

/* Move to FPSCR Bit 0 */
bool mtfsb0(State *state, Instruction instr)
{
   return false;
}

/* Move to FPSCR Bit 1 */
bool mtfsb1(State *state, Instruction instr)
{
   return false;
}

/* Move to FPSCR Fields */
bool mtfsf(State *state, Instruction instr)
{
   return false;
}

/* Move to FPSCR Field Immediate */
bool mtfsfi(State *state, Instruction instr)
{
   return false;
}

/* Move to Machine State Register */
bool mtmsr(State *state, Instruction instr)
{
   return false;
}

/* Move to Machine State Register Doubleword */
bool mtmsrd(State *state, Instruction instr)
{
   return false;
}

/* Move to One Condition Register Field */
bool mtocrf(State *state, Instruction instr)
{
   return false;
}

/* Move to Special-Purpose Register */
bool mtspr(State *state, Instruction instr)
{
   return false;
}

/* Move to Segment Register */
bool mtsr(State *state, Instruction instr)
{
   return false;
}

/* Move to Segment Register Indirect */
bool mtsrin(State *state, Instruction instr)
{
   return false;
}

/* Multiply High Doubleword */
bool mulhd(State *state, Instruction instr)
{
   return false;
}

/* Multiply High Doubleword Unsigned */
bool mulhdu(State *state, Instruction instr)
{
   return false;
}

/* Multiply High Word */
bool mulhw(State *state, Instruction instr)
{
   return false;
}

/* Multiply High Word Unsigned */
bool mulhwu(State *state, Instruction instr)
{
   return false;
}

/* Multiply Low Doubleword */
bool mulld(State *state, Instruction instr)
{
   return false;
}

/* Multiply Low Immediate */
bool mulli(State *state, Instruction instr)
{
   return false;
}

/* Multiply Low Word */
bool mullw(State *state, Instruction instr)
{
   return false;
}

/* NAND */
bool nand(State *state, Instruction instr)
{
   return false;
}

/* Negate */
bool neg(State *state, Instruction instr)
{
   return false;
}

/* NOR */
bool nor(State *state, Instruction instr)
{
   return false;
}

/* OR */
bool or(State *state, Instruction instr)
{
   return false;
}

/* OR with Complement */
bool orc(State *state, Instruction instr)
{
   return false;
}

/* OR Immediate */
bool ori(State *state, Instruction instr)
{
   return false;
}

/* OR Immediate Shifted */
bool oris(State *state, Instruction instr)
{
   return false;
}

/* Return from Interrupt Doubleword */
bool rfid(State *state, Instruction instr)
{
   return false;
}

/* Rotate Left Doubleword then Clear Left */
bool rldcl(State *state, Instruction instr)
{
   return false;
}

/* Rotate Left Doubleword then Clear Right */
bool rldcr(State *state, Instruction instr)
{
   return false;
}

/* Rotate Left Doubleword Immediate then Clear */
bool rldic(State *state, Instruction instr)
{
   return false;
}

/* Rotate Left Doubleword Immediate then Clear Left */
bool rldicl(State *state, Instruction instr)
{
   return false;
}

/* Rotate Left Doubleword Immediate then Clear Right */
bool rldicr(State *state, Instruction instr)
{
   return false;
}

/* Rotate Left Doubleword Immediate then Mask Insert */
bool rldimi(State *state, Instruction instr)
{
   return false;
}

/* Rotate Left Word Immediate then Mask Insert */
bool rlwimi(State *state, Instruction instr)
{
   return false;
}

/* Rotate Left Word Immediate then AND with Mask */
bool rlwinm(State *state, Instruction instr)
{
   return false;
}

/* Rotate Left Word then AND with Mask */
bool rlwnm(State *state, Instruction instr)
{
   return false;
}

/* System Call */
bool sc(State *state, Instruction instr)
{
   return false;
}

/* SLB Invalidate All */
bool slbia(State *state, Instruction instr)
{
   return false;
}

/* SLB Invalidate Entry */
bool slbie(State *state, Instruction instr)
{
   return false;
}

/* SLB Move From Entry ESID */
bool slbmfee(State *state, Instruction instr)
{
   return false;
}

/* SLB Move From Entry VSID */
bool slbmfev(State *state, Instruction instr)
{
   return false;
}

/* SLB Move To Entry */
bool slbmte(State *state, Instruction instr)
{
   return false;
}

/* Shift Left Doubleword */
bool sld(State *state, Instruction instr)
{
   return false;
}

/* Shift Left Word */
bool slw(State *state, Instruction instr)
{
   return false;
}

/* Shift Right Algebraic Doubleword */
bool srad(State *state, Instruction instr)
{
   return false;
}

/* Shift Right Algebraic Doubleword Immediate */
bool sradi(State *state, Instruction instr)
{
   return false;
}

/* Shift Right Algebraic Word */
bool sraw(State *state, Instruction instr)
{
   return false;
}

/* Shift Right Algebraic Word Immediate */
bool srawi(State *state, Instruction instr)
{
   return false;
}

/* Shift Right Doubleword */
bool srd(State *state, Instruction instr)
{
   return false;
}

/* Shift Right Word */
bool srw(State *state, Instruction instr)
{
   return false;
}

/* Store Byte */
bool stb(State *state, Instruction instr)
{
   return false;
}

/* Store Byte with Update */
bool stbu(State *state, Instruction instr)
{
   return false;
}

/* Store Byte with Update Indexed */
bool stbux(State *state, Instruction instr)
{
   return false;
}

/* Store Byte Indexed */
bool stbx(State *state, Instruction instr)
{
   return false;
}

/* Store Doubleword */
bool std(State *state, Instruction instr)
{
   return false;
}

/* Store Doubleword Conditional Indexed */
bool stdcx(State *state, Instruction instr)
{
   return false;
}

/* Store Doubleword with Update */
bool stdu(State *state, Instruction instr)
{
   return false;
}

/* Store Doubleword with Update Indexed */
bool stdux(State *state, Instruction instr)
{
   return false;
}

/* Store Doubleword Indexed */
bool stdx(State *state, Instruction instr)
{
   return false;
}

/* Store Floating-Point Double */
bool stfd(State *state, Instruction instr)
{
   return false;
}

/* Store Floating-Point Double with Update */
bool stfdu(State *state, Instruction instr)
{
   return false;
}

/* Store Floating-Point Double with Update Indexed */
bool stfdux(State *state, Instruction instr)
{
   return false;
}

/* Store Floating-Point Double Indexed */
bool stfdx(State *state, Instruction instr)
{
   return false;
}

/* Store Floating-Point as Integer Word Indexed */
bool stfiwx(State *state, Instruction instr)
{
   return false;
}

/* Store Floating-Point Single */
bool stfs(State *state, Instruction instr)
{
   return false;
}

/* Store Floating-Point Single with Update */
bool stfsu(State *state, Instruction instr)
{
   return false;
}

/* Store Floating-Point Single with Update Indexed */
bool stfsux(State *state, Instruction instr)
{
   return false;
}

/* Store Floating-Point Single Indexed */
bool stfsx(State *state, Instruction instr)
{
   return false;
}

/* Store Halfword */
bool sth(State *state, Instruction instr)
{
   return false;
}

/* Store Halfword Byte-Reverse Indexed */
bool sthbrx(State *state, Instruction instr)
{
   return false;
}

/* Store Halfword with Update */
bool sthu(State *state, Instruction instr)
{
   return false;
}

/* Store Halfword with Update Indexed */
bool sthux(State *state, Instruction instr)
{
   return false;
}

/* Store Halfword Indexed */
bool sthx(State *state, Instruction instr)
{
   return false;
}

/* Store Multiple Word */
bool stmw(State *state, Instruction instr)
{
   return false;
}

/* Store String Word Immediate */
bool stswi(State *state, Instruction instr)
{
   return false;
}

/* Store String Word Indexed */
bool stswx(State *state, Instruction instr)
{
   return false;
}

/* Store Word */
bool stw(State *state, Instruction instr)
{
   return false;
}

/* Store Word Byte-Reverse Indexed */
bool stwbrx(State *state, Instruction instr)
{
   return false;
}

/* Store Word Conditional Indexed */
bool stwcx(State *state, Instruction instr)
{
   return false;
}

/* Store Word with Update */
bool stwu(State *state, Instruction instr)
{
   return false;
}

/* Store Word with Update Indexed */
bool stwux(State *state, Instruction instr)
{
   return false;
}

/* Store Word Indexed */
bool stwx(State *state, Instruction instr)
{
   return false;
}

/* Subtract From */
bool subf(State *state, Instruction instr)
{
   return false;
}

/* Subtract From Carrying */
bool subfc(State *state, Instruction instr)
{
   return false;
}

/* Subtract From Extended */
bool subfe(State *state, Instruction instr)
{
   return false;
}

/* Subtract From Immediate Carrying */
bool subfic(State *state, Instruction instr)
{
   return false;
}

/* Subtract From Minus One Extended */
bool subfme(State *state, Instruction instr)
{
   return false;
}

/* Subtract From Zero Extended */
bool subfze(State *state, Instruction instr)
{
   return false;
}

/* Synchronize */
bool sync(State *state, Instruction instr)
{
   return false;
}

/* Trap Doubleword */
bool td(State *state, Instruction instr)
{
   return false;
}

/* Trap Doubleword Immediate */
bool tdi(State *state, Instruction instr)
{
   return false;
}

/* Translation Lookaside Buffer Invalidate All */
bool tlbia(State *state, Instruction instr)
{
   return false;
}

/* Translation Lookaside Buffer Invalidate Entry */
bool tlbie(State *state, Instruction instr)
{
   return false;
}

/* Translation Lookaside Buffer Invalidate Entry Local */
bool tlbiel(State *state, Instruction instr)
{
   return false;
}

/* Translation Lookaside Buffer Synchronize */
bool tlbsync(State *state, Instruction instr)
{
   return false;
}

/* Trap Word */
bool tw(State *state, Instruction instr)
{
   return false;
}

/* Trap Word Immediate */
bool twi(State *state, Instruction instr)
{
   return false;
}

/* XOR */
bool xor(State *state, Instruction instr)
{
   return false;
}

/* XOR Immediate */
bool xori(State *state, Instruction instr)
{
   return false;
}

/* XOR Immediate Shifted */
bool xoris(State *state, Instruction instr)
{
   return false;
}


```

`src/powerpc/emugen_stubs.h`:

```h

bool add(State *state, Instruction instr);
bool addc(State *state, Instruction instr);
bool adde(State *state, Instruction instr);
bool addi(State *state, Instruction instr);
bool addic(State *state, Instruction instr);
bool addico(State *state, Instruction instr);
bool addis(State *state, Instruction instr);
bool addme(State *state, Instruction instr);
bool addze(State *state, Instruction instr);
bool and(State *state, Instruction instr);
bool andc(State *state, Instruction instr);
bool andio(State *state, Instruction instr);
bool andiso(State *state, Instruction instr);
bool b(State *state, Instruction instr);
bool bc(State *state, Instruction instr);
bool bcctr(State *state, Instruction instr);
bool bclr(State *state, Instruction instr);
bool cmp(State *state, Instruction instr);
bool cmpi(State *state, Instruction instr);
bool cmpl(State *state, Instruction instr);
bool cmpli(State *state, Instruction instr);
bool cntlzd(State *state, Instruction instr);
bool cntlzw(State *state, Instruction instr);
bool crand(State *state, Instruction instr);
bool crandc(State *state, Instruction instr);
bool creqv(State *state, Instruction instr);
bool crnand(State *state, Instruction instr);
bool crnor(State *state, Instruction instr);
bool cror(State *state, Instruction instr);
bool crorc(State *state, Instruction instr);
bool crxor(State *state, Instruction instr);
bool dcbf(State *state, Instruction instr);
bool dcbst(State *state, Instruction instr);
bool dcbt(State *state, Instruction instr);
bool dcbtst(State *state, Instruction instr);
bool dcbz(State *state, Instruction instr);
bool divd(State *state, Instruction instr);
bool divdu(State *state, Instruction instr);
bool divw(State *state, Instruction instr);
bool divwu(State *state, Instruction instr);
bool eciwx(State *state, Instruction instr);
bool ecowx(State *state, Instruction instr);
bool eieio(State *state, Instruction instr);
bool eqv(State *state, Instruction instr);
bool extsb(State *state, Instruction instr);
bool extsh(State *state, Instruction instr);
bool extsw(State *state, Instruction instr);
bool fabs(State *state, Instruction instr);
bool fadd(State *state, Instruction instr);
bool fadds(State *state, Instruction instr);
bool fcfid(State *state, Instruction instr);
bool fcmpo(State *state, Instruction instr);
bool fcmpu(State *state, Instruction instr);
bool fctid(State *state, Instruction instr);
bool fctidz(State *state, Instruction instr);
bool fctiw(State *state, Instruction instr);
bool fctiwz(State *state, Instruction instr);
bool fdiv(State *state, Instruction instr);
bool fdivs(State *state, Instruction instr);
bool fmadd(State *state, Instruction instr);
bool fmadds(State *state, Instruction instr);
bool fmr(State *state, Instruction instr);
bool fmsub(State *state, Instruction instr);
bool fmsubs(State *state, Instruction instr);
bool fmul(State *state, Instruction instr);
bool fmuls(State *state, Instruction instr);
bool fnabs(State *state, Instruction instr);
bool fneg(State *state, Instruction instr);
bool fnmadd(State *state, Instruction instr);
bool fnmadds(State *state, Instruction instr);
bool fnmsub(State *state, Instruction instr);
bool fnmsubs(State *state, Instruction instr);
bool fres(State *state, Instruction instr);
bool frsp(State *state, Instruction instr);
bool frsqrte(State *state, Instruction instr);
bool fsel(State *state, Instruction instr);
bool fsqrt(State *state, Instruction instr);
bool fsqrts(State *state, Instruction instr);
bool fsub(State *state, Instruction instr);
bool fsubs(State *state, Instruction instr);
bool icbi(State *state, Instruction instr);
bool isync(State *state, Instruction instr);
bool krncall(State *state, Instruction instr);
bool lbz(State *state, Instruction instr);
bool lbzu(State *state, Instruction instr);
bool lbzux(State *state, Instruction instr);
bool lbzx(State *state, Instruction instr);
bool ld(State *state, Instruction instr);
bool ldarx(State *state, Instruction instr);
bool ldu(State *state, Instruction instr);
bool ldux(State *state, Instruction instr);
bool ldx(State *state, Instruction instr);
bool lfd(State *state, Instruction instr);
bool lfdu(State *state, Instruction instr);
bool lfdux(State *state, Instruction instr);
bool lfdx(State *state, Instruction instr);
bool lfs(State *state, Instruction instr);
bool lfsu(State *state, Instruction instr);
bool lfsux(State *state, Instruction instr);
bool lfsx(State *state, Instruction instr);
bool lha(State *state, Instruction instr);
bool lhau(State *state, Instruction instr);
bool lhaux(State *state, Instruction instr);
bool lhax(State *state, Instruction instr);
bool lhbrx(State *state, Instruction instr);
bool lhz(State *state, Instruction instr);
bool lhzu(State *state, Instruction instr);
bool lhzux(State *state, Instruction instr);
bool lhzx(State *state, Instruction instr);
bool lmw(State *state, Instruction instr);
bool lswi(State *state, Instruction instr);
bool lswx(State *state, Instruction instr);
bool lwa(State *state, Instruction instr);
bool lwarx(State *state, Instruction instr);
bool lwaux(State *state, Instruction instr);
bool lwax(State *state, Instruction instr);
bool lwbrx(State *state, Instruction instr);
bool lwz(State *state, Instruction instr);
bool lwzu(State *state, Instruction instr);
bool lwzux(State *state, Instruction instr);
bool lwzx(State *state, Instruction instr);
bool mcrf(State *state, Instruction instr);
bool mcrfs(State *state, Instruction instr);
bool mfcr(State *state, Instruction instr);
bool mffs(State *state, Instruction instr);
bool mfmsr(State *state, Instruction instr);
bool mfocrf(State *state, Instruction instr);
bool mfspr(State *state, Instruction instr);
bool mfsr(State *state, Instruction instr);
bool mfsrin(State *state, Instruction instr);
bool mftb(State *state, Instruction instr);
bool mtcrf(State *state, Instruction instr);
bool mtfsb0(State *state, Instruction instr);
bool mtfsb1(State *state, Instruction instr);
bool mtfsf(State *state, Instruction instr);
bool mtfsfi(State *state, Instruction instr);
bool mtmsr(State *state, Instruction instr);
bool mtmsrd(State *state, Instruction instr);
bool mtocrf(State *state, Instruction instr);
bool mtspr(State *state, Instruction instr);
bool mtsr(State *state, Instruction instr);
bool mtsrin(State *state, Instruction instr);
bool mulhd(State *state, Instruction instr);
bool mulhdu(State *state, Instruction instr);
bool mulhw(State *state, Instruction instr);
bool mulhwu(State *state, Instruction instr);
bool mulld(State *state, Instruction instr);
bool mulli(State *state, Instruction instr);
bool mullw(State *state, Instruction instr);
bool nand(State *state, Instruction instr);
bool neg(State *state, Instruction instr);
bool nor(State *state, Instruction instr);
bool or(State *state, Instruction instr);
bool orc(State *state, Instruction instr);
bool ori(State *state, Instruction instr);
bool oris(State *state, Instruction instr);
bool rfid(State *state, Instruction instr);
bool rldcl(State *state, Instruction instr);
bool rldcr(State *state, Instruction instr);
bool rldic(State *state, Instruction instr);
bool rldicl(State *state, Instruction instr);
bool rldicr(State *state, Instruction instr);
bool rldimi(State *state, Instruction instr);
bool rlwimi(State *state, Instruction instr);
bool rlwinm(State *state, Instruction instr);
bool rlwnm(State *state, Instruction instr);
bool sc(State *state, Instruction instr);
bool slbia(State *state, Instruction instr);
bool slbie(State *state, Instruction instr);
bool slbmfee(State *state, Instruction instr);
bool slbmfev(State *state, Instruction instr);
bool slbmte(State *state, Instruction instr);
bool sld(State *state, Instruction instr);
bool slw(State *state, Instruction instr);
bool srad(State *state, Instruction instr);
bool sradi(State *state, Instruction instr);
bool sraw(State *state, Instruction instr);
bool srawi(State *state, Instruction instr);
bool srd(State *state, Instruction instr);
bool srw(State *state, Instruction instr);
bool stb(State *state, Instruction instr);
bool stbu(State *state, Instruction instr);
bool stbux(State *state, Instruction instr);
bool stbx(State *state, Instruction instr);
bool std(State *state, Instruction instr);
bool stdcx(State *state, Instruction instr);
bool stdu(State *state, Instruction instr);
bool stdux(State *state, Instruction instr);
bool stdx(State *state, Instruction instr);
bool stfd(State *state, Instruction instr);
bool stfdu(State *state, Instruction instr);
bool stfdux(State *state, Instruction instr);
bool stfdx(State *state, Instruction instr);
bool stfiwx(State *state, Instruction instr);
bool stfs(State *state, Instruction instr);
bool stfsu(State *state, Instruction instr);
bool stfsux(State *state, Instruction instr);
bool stfsx(State *state, Instruction instr);
bool sth(State *state, Instruction instr);
bool sthbrx(State *state, Instruction instr);
bool sthu(State *state, Instruction instr);
bool sthux(State *state, Instruction instr);
bool sthx(State *state, Instruction instr);
bool stmw(State *state, Instruction instr);
bool stswi(State *state, Instruction instr);
bool stswx(State *state, Instruction instr);
bool stw(State *state, Instruction instr);
bool stwbrx(State *state, Instruction instr);
bool stwcx(State *state, Instruction instr);
bool stwu(State *state, Instruction instr);
bool stwux(State *state, Instruction instr);
bool stwx(State *state, Instruction instr);
bool subf(State *state, Instruction instr);
bool subfc(State *state, Instruction instr);
bool subfe(State *state, Instruction instr);
bool subfic(State *state, Instruction instr);
bool subfme(State *state, Instruction instr);
bool subfze(State *state, Instruction instr);
bool sync(State *state, Instruction instr);
bool td(State *state, Instruction instr);
bool tdi(State *state, Instruction instr);
bool tlbia(State *state, Instruction instr);
bool tlbie(State *state, Instruction instr);
bool tlbiel(State *state, Instruction instr);
bool tlbsync(State *state, Instruction instr);
bool tw(State *state, Instruction instr);
bool twi(State *state, Instruction instr);
bool xor(State *state, Instruction instr);
bool xori(State *state, Instruction instr);
bool xoris(State *state, Instruction instr);

```

`src/powerpc/emugen_table.h`:

```h
fptr_t _emugenTable[] = {
   nullptr,
   add,
   addc,
   adde,
   addi,
   addic,
   addico,
   addis,
   addme,
   addze,
   and,
   andc,
   andio,
   andiso,
   b,
   bc,
   bcctr,
   bclr,
   cmp,
   cmpi,
   cmpl,
   cmpli,
   cntlzd,
   cntlzw,
   crand,
   crandc,
   creqv,
   crnand,
   crnor,
   cror,
   crorc,
   crxor,
   dcbf,
   dcbst,
   dcbt,
   dcbtst,
   dcbz,
   divd,
   divdu,
   divw,
   divwu,
   eciwx,
   ecowx,
   eieio,
   eqv,
   extsb,
   extsh,
   extsw,
   fabs,
   fadd,
   fadds,
   fcfid,
   fcmpo,
   fcmpu,
   fctid,
   fctidz,
   fctiw,
   fctiwz,
   fdiv,
   fdivs,
   fmadd,
   fmadds,
   fmr,
   fmsub,
   fmsubs,
   fmul,
   fmuls,
   fnabs,
   fneg,
   fnmadd,
   fnmadds,
   fnmsub,
   fnmsubs,
   fres,
   frsp,
   frsqrte,
   fsel,
   fsqrt,
   fsqrts,
   fsub,
   fsubs,
   icbi,
   isync,
   krncall,
   lbz,
   lbzu,
   lbzux,
   lbzx,
   ld,
   ldarx,
   ldu,
   ldux,
   ldx,
   lfd,
   lfdu,
   lfdux,
   lfdx,
   lfs,
   lfsu,
   lfsux,
   lfsx,
   lha,
   lhau,
   lhaux,
   lhax,
   lhbrx,
   lhz,
   lhzu,
   lhzux,
   lhzx,
   lmw,
   lswi,
   lswx,
   lwa,
   lwarx,
   lwaux,
   lwax,
   lwbrx,
   lwz,
   lwzu,
   lwzux,
   lwzx,
   mcrf,
   mcrfs,
   mfcr,
   mffs,
   mfmsr,
   mfocrf,
   mfspr,
   mfsr,
   mfsrin,
   mftb,
   mtcrf,
   mtfsb0,
   mtfsb1,
   mtfsf,
   mtfsfi,
   mtmsr,
   mtmsrd,
   mtocrf,
   mtspr,
   mtsr,
   mtsrin,
   mulhd,
   mulhdu,
   mulhw,
   mulhwu,
   mulld,
   mulli,
   mullw,
   nand,
   neg,
   nor,
   or,
   orc,
   ori,
   oris,
   rfid,
   rldcl,
   rldcr,
   rldic,
   rldicl,
   rldicr,
   rldimi,
   rlwimi,
   rlwinm,
   rlwnm,
   sc,
   slbia,
   slbie,
   slbmfee,
   slbmfev,
   slbmte,
   sld,
   slw,
   srad,
   sradi,
   sraw,
   srawi,
   srd,
   srw,
   stb,
   stbu,
   stbux,
   stbx,
   std,
   stdcx,
   stdu,
   stdux,
   stdx,
   stfd,
   stfdu,
   stfdux,
   stfdx,
   stfiwx,
   stfs,
   stfsu,
   stfsux,
   stfsx,
   sth,
   sthbrx,
   sthu,
   sthux,
   sthx,
   stmw,
   stswi,
   stswx,
   stw,
   stwbrx,
   stwcx,
   stwu,
   stwux,
   stwx,
   subf,
   subfc,
   subfe,
   subfic,
   subfme,
   subfze,
   sync,
   td,
   tdi,
   tlbia,
   tlbie,
   tlbiel,
   tlbsync,
   tw,
   twi,
   xor,
   xori,
   xoris,
};

```

`src/powerpc/instructions.cpp`:

```cpp
#include "instructions.h"
#include <assert.h>

using ppc::emugen::InstrEntry;
using namespace ppc::Fields;

namespace ppc
{
#include "emugen_instructions.h"

Instruction createInstruction(InstructionID id)
{
   Instruction instr { 0 };

   for (auto &op : ppc::Instructions[static_cast<unsigned>(id)].opcodes) {
      instr.set(op.field, op.value);
   }

   return instr;
}

const ppc::emugen::InstrEntry &getInstruction(InstructionID id)
{
   return Instructions[static_cast<unsigned>(id)];
}

unsigned Instruction::get(Field field) const
{
   switch (field) {
   case Fields::xo1:
      return xo1;
   case Fields::xo2:
      return xo2;
   case Fields::xo3:
      return xo3;
   case Fields::xo4:
      return xo4;
   case Fields::xo5:
      return xo5;
   case Fields::xo6:
      return xo6;
   case Fields::xo7:
      return xo7;
   case Fields::xo8:
      return xo8;
   case Fields::bd:
      return bd;
   case Fields::bi:
      return bi;
   case Fields::bo:
      return bo;
   case Fields::bh:
      return bh;
   case Fields::crbA:
      return crbA;
   case Fields::crbB:
      return crbB;
   case Fields::crbD:
      return crbD;
   case Fields::crfD:
      return crfD;
   case Fields::crfS:
      return crfS;
   case Fields::d:
      return d;
   case Fields::ds:
      return ds;
   case Fields::frA:
      return frA;
   case Fields::frB:
      return frB;
   case Fields::frC:
      return frC;
   case Fields::frD:
      return frD;
   case Fields::frS:
      return frS;
   case Fields::uimm:
      return uimm;
   case Fields::simm:
      return simm;
   case Fields::l:
      return l;
   case Fields::li:
      return li;
   case Fields::rA:
      return rA;
   case Fields::rB:
      return rB;
   case Fields::rD:
      return rD;
   case Fields::rS:
      return rS;
   case Fields::spr:
      return spr;
   case Fields::th:
      return th;
   case Fields::sr:
      return sr;
   case Fields::tbr:
      return tbr;
   case Fields::crm:
      return crm;
   case Fields::fm:
      return fm;
   case Fields::nb:
      return nb;
   case Fields::l15:
      return l15;
   case Fields::syncl:
      return syncl;
   case Fields::tlbl:
      return tlbl;
   case Fields::sh:
      return sh;
   case Fields::shd04:
      return shd04;
   case Fields::shd5:
      return shd5;
   case Fields::mb:
      return mb;
   case Fields::mbd:
      return mbd;
   case Fields::me:
      return me;
   case Fields::med:
      return med;
   case Fields::to:
      return to;
   case Fields::aa:
      return aa;
   case Fields::lk:
      return lk;
   case Fields::oe:
      return oe;
   case Fields::rc:
      return rc;
   default:
      assert(0 && "Unknown field in getField");
      return 0;
   }
}

void Instruction::set(Field field, unsigned value)
{
   switch (field) {
   case Fields::xo1:
      xo1 = value;
      break;
   case Fields::xo2:
      xo2 = value;
      break;
   case Fields::xo3:
      xo3 = value;
      break;
   case Fields::xo4:
      xo4 = value;
      break;
   case Fields::xo5:
      xo5 = value;
      break;
   case Fields::xo6:
      xo6 = value;
      break;
   case Fields::xo7:
      xo7 = value;
      break;
   case Fields::xo8:
      xo8 = value;
      break;
   case Fields::bd:
      bd = value;
      break;
   case Fields::bi:
      bi = value;
      break;
   case Fields::bo:
      bo = value;
      break;
   case Fields::bh:
      bh = value;
      break;
   case Fields::crbA:
      crbA = value;
      break;
   case Fields::crbB:
      crbB = value;
      break;
   case Fields::crbD:
      crbD = value;
      break;
   case Fields::crfD:
      crfD = value;
      break;
   case Fields::crfS:
      crfS = value;
      break;
   case Fields::d:
      d = value;
      break;
   case Fields::ds:
      ds = value;
      break;
   case Fields::frA:
      frA = value;
      break;
   case Fields::frB:
      frB = value;
      break;
   case Fields::frC:
      frC = value;
      break;
   case Fields::frD:
      frD = value;
      break;
   case Fields::frS:
      frS = value;
      break;
   case Fields::uimm:
      uimm = value;
      break;
   case Fields::simm:
      simm = value;
      break;
   case Fields::l:
      l = value;
      break;
   case Fields::li:
      li = value;
      break;
   case Fields::rA:
      rA = value;
      break;
   case Fields::rB:
      rB = value;
      break;
   case Fields::rD:
      rD = value;
      break;
   case Fields::rS:
      rS = value;
      break;
   case Fields::spr:
      spr = value;
      break;
   case Fields::th:
      th = value;
      break;
   case Fields::sr:
      sr = value;
      break;
   case Fields::tbr:
      tbr = value;
      break;
   case Fields::crm:
      crm = value;
      break;
   case Fields::fm:
      fm = value;
      break;
   case Fields::nb:
      nb = value;
      break;
   case Fields::l15:
      l15 = value;
      break;
   case Fields::syncl:
      syncl = value;
      break;
   case Fields::tlbl:
      tlbl = value;
      break;
   case Fields::sh:
      sh = value;
      break;
   case Fields::shd04:
      shd04 = value;
      break;
   case Fields::shd5:
      shd5 = value;
      break;
   case Fields::mb:
      mb = value;
      break;
   case Fields::mbd:
      mbd = value;
      break;
   case Fields::me:
      me = value;
      break;
   case Fields::med:
      med = value;
      break;
   case Fields::to:
      to = value;
      break;
   case Fields::aa:
      aa = value;
      break;
   case Fields::lk:
      lk = value;
      break;
   case Fields::oe:
      oe = value;
      break;
   case Fields::rc:
      rc = value;
      break;
   default:
      assert(0 && "Unknown field in setField");
   }
}
};


```

`src/powerpc/instructions.h`:

```h
#ifndef PPC_INSTRUCTIONS_H
#define PPC_INSTRUCTIONS_H

#include "cpu.h"

namespace ppc
{

#include "emugen_instructionid.h"
#include "../common/emugen_types.h"

extern emugen::InstrEntry Instructions[];

Instruction createInstruction(InstructionID id);
const ppc::emugen::InstrEntry &getInstruction(InstructionID id);

template<InstructionID id>
bool isa(Instruction instr)
{
   static_assert(id < InstructionID::InstructionMax, "Invalid instruction ID");

   for (auto &op : ppc::Instructions[static_cast<unsigned>(id)].opcodes) {
      if (instr.get(op.field) != op.value) {
         return false;
      }
   }

   return true;
}

} // namespace ppc

#endif // PPC_INSTRUCTIONS_H

```

`src/powerpc/interpreter/alu.cpp`:

```cpp
#include "interpreter.h"
#include "regs.h"

#include "common/bit_cast.h"

namespace ppc 
{

namespace Interpreter
{

template<typename Type>
static inline void updateCr0(State *state, Type value)
{
   auto flags = 0;

   if (value == 0) {
      flags |= ppc::Cr::Zero;
   } else if (little_endian::get_bit(value, little_endian::width<Type>() - 1)) {
      flags |= ppc::Cr::Negative;
   } else {
      flags |= ppc::Cr::Positive;
   }

   if (state->reg.xer.so) {
      flags |= ppc::Cr::SummaryOverflow;
   }

   state->reg.cr.cr0 = flags;
}

static inline void updateXerOverflow(State *state, bool overflow)
{
   state->reg.xer.ov = overflow;
   state->reg.xer.so |= overflow;
}

/* Add x */
enum AddFlags 
{
   AddDefault    =      0,
   AddCarry      = 1 << 0,
   AddExtend     = 1 << 1,
   AddImmediate  = 1 << 2,
   AddShift      = 1 << 3,
   AddRecord     = 1 << 4,
   AddToZero     = 1 << 5,
   AddToMinusOne = 1 << 6,
};

template<int Flags>
bool addx(State *state, Instruction instr)
{
   uint64_t a, b, d;
   
   if (instr.rA == 0 && (Flags & AddImmediate) && (Flags & AddCarry) == 0) {
      a = 0;
   } else {
      a = gpr(instr.rA);
   }

   if (Flags & AddImmediate) {
      b = little_endian::signExtend<16, uint64_t>(instr.simm);
   } else if (Flags & AddToZero) {
      b = 0;
   } else if (Flags & AddToMinusOne) {
      b = -1;
   } else {
      b = gpr(instr.rB);
   }

   if (Flags & AddShift) {
      b <<= 16;
   }

   d = a + b;

   if (Flags & AddExtend) {
      d += state->reg.xer.ca;
   }

   gpr(instr.rD) = d;

   if ((Flags & AddImmediate) == 0) {
      if (instr.oe) {
         updateXerOverflow(state, little_endian::get_bit((a ^ d) & (b ^ d), 63) != 0);
      }
   }

   if ((Flags & AddImmediate) == 0 || (Flags & AddRecord)) {
      if (instr.rc) {
         updateCr0(state, gpr(instr.rD));
      }
   }

   if (Flags & AddCarry || Flags & AddExtend) {
      state->reg.xer.ca = gpr(instr.rD) < gpr(instr.rA) ? 1 : 0;
   }

   return true;
}

/* Add */
bool add(State *state, Instruction instr)
{
   return addx<AddDefault>(state, instr);
}

/* Add Carrying */
bool addc(State *state, Instruction instr)
{
   return addx<AddCarry>(state, instr);
}

/* Add Extended */
bool adde(State *state, Instruction instr)
{
   return addx<AddExtend>(state, instr);
}

/* Add Immediate */
bool addi(State *state, Instruction instr)
{
   return addx<AddImmediate>(state, instr);
}

/* Add Immediate Carrying */
bool addic(State *state, Instruction instr)
{
   return addx<AddImmediate | AddCarry>(state, instr);
}

/* Add Immediate Carrying (record) */
bool addico(State *state, Instruction instr)
{
   return addx<AddImmediate | AddCarry | AddRecord>(state, instr);
}

/* Add Immediate Shifted */
bool addis(State *state, Instruction instr)
{
   return addx<AddImmediate | AddShift>(state, instr);
}

/* Add Minus One Extend */
bool addme(State *state, Instruction instr)
{
   return addx<AddToMinusOne | AddExtend>(state, instr);
}

/* Add Zero Extended */
bool addze(State *state, Instruction instr)
{
   return addx<AddToZero | AddExtend>(state, instr);
}

/* AND */
bool and(State *state, Instruction instr)
{
   gpr(instr.rA) = gpr(instr.rS) & gpr(instr.rB);

   if (instr.rc) {
      updateCr0(state, gpr(instr.rA));
   }

   return true;
}

/* AND with Complement */
bool andc(State *state, Instruction instr)
{
   gpr(instr.rA) = gpr(instr.rS) & ~gpr(instr.rB);

   if (instr.rc) {
      updateCr0(state, gpr(instr.rA));
   }

   return true;
}

/* And Immediate */
bool andio(State *state, Instruction instr)
{
   gpr(instr.rA) = gpr(instr.rS) & instr.uimm;
   updateCr0(state, gpr(instr.rA));
   return true;
}

/* And Immediate Shifted */
bool andiso(State *state, Instruction instr)
{
   gpr(instr.rA) = gpr(instr.rS) & (static_cast<uint64_t>(instr.uimm) << 16);
   updateCr0(state, gpr(instr.rA));
   return true;
}

/* Count Leading Zeroes Doubleword */
bool cntlzd(State *state, Instruction instr)
{
   auto bit = little_endian::countLeadingZeros(gpr(instr.rS));
   gpr(instr.rA) = bit < 64 ? 63 - bit : 64;

   if (instr.rc) {
      updateCr0(state, gpr(instr.rA));
   }

   return true;
}

/* Count Leading Zeroes Word */
bool cntlzw(State *state, Instruction instr)
{
   auto bit = little_endian::countLeadingZeros(gprw(instr.rS));
   gpr(instr.rA) = bit < 32 ? 31 - bit : 32;

   if (instr.rc) {
      updateCr0(state, gpr(instr.rA));
   }

   return true;
}

/* Divide */
template<typename Type>
bool divxx(State *state, Instruction instr)
{
   Type a = reinterpret<Type>(gpr(instr.rA));
   Type b = reinterpret<Type>(gpr(instr.rB));

   bool overflow = b == 0;

   if (std::numeric_limits<Type>::is_signed) {
      if (b == -1 && a == (static_cast<Type>(1) << (little_endian::width<Type>() - 1))) {
         overflow = true;
      }
   }

   if (!overflow) {
      Type r = a / b;
      reinterpret<Type>(gpr(instr.rD)) = r;

      if (instr.rc) {
         updateCr0(state, r);
      }
   }

   if (instr.oe) {
      updateXerOverflow(state, overflow);
   }

   return true;
}

/* Divide Doubleword (signed) */
bool divd(State *state, Instruction instr)
{
   return divxx<int64_t>(state, instr);
}

/* Divide Doubleword Unsigned */
bool divdu(State *state, Instruction instr)
{
   return divxx<uint64_t>(state, instr);
}

/* Divide Word (signed) */
bool divw(State *state, Instruction instr)
{
   return divxx<int32_t>(state, instr);
}

/* Divide Word Unsigned */
bool divwu(State *state, Instruction instr)
{
   return divxx<uint32_t>(state, instr);
}

/* Equivalent */
bool eqv(State *state, Instruction instr)
{
   gpr(instr.rA) = ~(gpr(instr.rS) ^ gpr(instr.rB));

   if (instr.rc) {
      updateCr0(state, gpr(instr.rA));
   }

   return true;
}

/* Extend Sign */
template<int SrcBits>
bool extsx(State *state, Instruction instr)
{
   gpr(instr.rA) = little_endian::signExtend<SrcBits>(gpr(instr.rS));

   if (instr.rc) {
      updateCr0(state, gpr(instr.rA));
   }

   return true;
}

/* Extend Sign Byte */
bool extsb(State *state, Instruction instr)
{
   return extsx<8>(state, instr);
}

/* Extend Sign Halfword */
bool extsh(State *state, Instruction instr)
{
   return extsx<16>(state, instr);
}

/* Extend Sign Word */
bool extsw(State *state, Instruction instr)
{
   return extsx<32>(state, instr);
}

/* Multiply High Doubleword (signed) */
bool mulhd(State *state, Instruction instr)
{
   gprs(instr.rD) = __mulh(gprs(instr.rA), gprs(instr.rB));

   if (instr.rc) {
      updateCr0(state, gpr(instr.rD));
   }

   return true;
}

/* Multiply High Doubleword Unsigned */
bool mulhdu(State *state, Instruction instr)
{
   gpr(instr.rD) = __umulh(gpr(instr.rA), gpr(instr.rB));

   if (instr.rc) {
      updateCr0(state, gpr(instr.rD));
   }

   return true;
}

/* Multiply High Word (signed) */
bool mulhw(State *state, Instruction instr)
{
   auto a = gprsw(instr.rA);
   auto b = gprsw(instr.rB);
   auto r = static_cast<int64_t>(a * b) >> 32;

   gprsw(instr.rD) = static_cast<int32_t>(r);

   if (instr.rc) {
      updateCr0(state, gprw(instr.rD));
   }

   return true;
}

/* Multiply High Word Unsigned */
bool mulhwu(State *state, Instruction instr)
{
   auto a = gprw(instr.rA);
   auto b = gprw(instr.rB);
   auto r = static_cast<uint64_t>(a * b) >> 32;

   gprw(instr.rD) = static_cast<uint32_t>(r);

   if (instr.rc) {
      updateCr0(state, gprw(instr.rD));
   }

   return true;
}

/* Multiply Low Doubleword (signed) */
bool mulld(State *state, Instruction instr)
{
   auto a = gprs(instr.rA);
   auto b = gprs(instr.rB);
   auto r = a * b;

   gprs(instr.rD) = r;

   if (instr.rc) {
      updateCr0(state, gpr(instr.rD));
   }

   if (instr.oe) {
      updateXerOverflow(state, a != 0 && (r / a) != b);
   }

   return true;
}

/* Multiply Low Immediate (signed) */
bool mulli(State *state, Instruction instr)
{
   auto a = gprs(instr.rA);
   auto b = little_endian::signExtend<16, ppc::sreg_t>(instr.simm);

   gprs(instr.rD) = a * b;

   return true;
}

/* Multiply Low Word (signed) */
bool mullw(State *state, Instruction instr)
{
   auto a = gprsw(instr.rA);
   auto b = gprsw(instr.rB);
   auto r = a * b;

   gprsw(instr.rD) = r;

   if (instr.rc) {
      updateCr0(state, gprw(instr.rD));
   }

   if (instr.oe) {
      updateXerOverflow(state, a != 0 && (r / a) != b);
   }

   return true;
}

/* NOT And */
bool nand(State *state, Instruction instr)
{
   gpr(instr.rA) = ~(gpr(instr.rS) & gpr(instr.rB));

   if (instr.rc) {
      updateCr0(state, gpr(instr.rA));
   }

   return true;
}

/* Negate */
bool neg(State *state, Instruction instr)
{
   if (gpr(instr.rA) == std::numeric_limits<int64_t>::max()) {
      gpr(instr.rD) = std::numeric_limits<int64_t>::min();

      if (instr.oe) {
         updateXerOverflow(state, true);
      }
   } else {
      gpr(instr.rD) = ~(gpr(instr.rA) + 1);
   }

   if (instr.rc) {
      updateCr0(state, gpr(instr.rA));
   }

   return true;
}

/* NOR */
bool nor(State *state, Instruction instr)
{
   gpr(instr.rA) = ~(gpr(instr.rS) | gpr(instr.rB));

   if (instr.rc) {
      updateCr0(state, gpr(instr.rA));
   }

   return true;
}

/* OR */
bool or(State *state, Instruction instr)
{
   gpr(instr.rA) = gpr(instr.rS) | gpr(instr.rB);

   if (instr.rc) {
      updateCr0(state, gpr(instr.rA));
   }

   return true;
}

/* OR with Complement */
bool orc(State *state, Instruction instr)
{
   gpr(instr.rA) = gpr(instr.rS) | ~gpr(instr.rB);

   if (instr.rc) {
      updateCr0(state, gpr(instr.rA));
   }

   return true;
}

/* OR Immediate */
bool ori(State *state, Instruction instr)
{
   gpr(instr.rA) = gpr(instr.rS) | instr.uimm;
   return true;
}

/* OR Immediate Shifted */
bool oris(State *state, Instruction instr)
{
   gpr(instr.rA) = gpr(instr.rS) | (static_cast<uint64_t>(instr.uimm) << 16);
   return true;
}

/* Rotate Left Doubleword x */
enum RldxxFlags
{
   RldDefault        =      0,
   RldClearLeft      = 1 << 0,
   RldClear          = 1 << 1,
   RldClearRight     = 1 << 2,
   RldImmediate      = 1 << 3,
   RldMaskInsert     = 1 << 4,
};

template<int Flags>
bool rldxx(State *state, Instruction instr)
{
   uint64_t r, m;
   int32_t n;

   if (Flags & RldImmediate) {
      n = instr.shd04 | (instr.shd5 << 4);
   } else {
      n = gprw(instr.rB) & 0x3f;
   }

   r = _rotl64(gpr(instr.rS), n);

   // TODO: Check this logic!!
   if (Flags & RldClearLeft) {
      m = big_endian::make_bit_mask<uint64_t>(instr.mbd, 63);
   } else if (Flags & RldClearRight) {
      m = big_endian::make_bit_mask<uint64_t>(0, instr.med);
   } else if (Flags & RldClear) {
      m = big_endian::make_bit_mask<uint64_t>(instr.mbd, n);
   }

   if (Flags & RldMaskInsert) {
      gpr(instr.rA) = (r & m) | (gpr(instr.rA) & ~m);
   } else {
      gpr(instr.rA) = r & m;
   }

   if (instr.rc) {
      updateCr0(state, gpr(instr.rA));
   }

   return true;
}

/* Rotate Left Doubleword then Clear Left */
bool rldcl(State *state, Instruction instr)
{
   return rldxx<RldClearLeft>(state, instr);
}

/* Rotate Left Doubleword then Clear Right */
bool rldcr(State *state, Instruction instr)
{
   return rldxx<RldClearRight>(state, instr);
}

/* Rotate Left Doubleword Immediate then Clear */
bool rldic(State *state, Instruction instr)
{
   return rldxx<RldImmediate | RldClear>(state, instr);
}

/* Rotate Left Doubleword Immediate then Clear Left */
bool rldicl(State *state, Instruction instr)
{
   return rldxx<RldImmediate | RldClearLeft>(state, instr);
}

/* Rotate Left Doubleword Immediate then Clear Right */
bool rldicr(State *state, Instruction instr)
{
   return rldxx<RldImmediate | RldClearRight>(state, instr);
}

/* Rotate Left Doubleword Immediate then Mask Insert */
bool rldimi(State *state, Instruction instr)
{
   return rldxx<RldImmediate | RldClear | RldMaskInsert>(state, instr);
}

/* Rotate Left Word x */
enum RlwxxFlags
{
   RlwDefault    =      0,
   RlwImmediate  = 1 << 0,
   RlwMaskInsert = 1 << 1,
};

template<int Flags>
bool rlwxx(State *state, Instruction instr)
{
   uint32_t n, r, m, a;

   if (Flags & RlwImmediate) {
      n = instr.sh;
   } else {
      n = gpr(instr.rB) & 0x1f;
   }
   
   r = _rotl(gprw(instr.rS), n);

   m = big_endian::make_bit_mask<uint32_t>(instr.mb, instr.me);

   if (Flags & RlwMaskInsert) {
      a = (r & m) | (gpr(instr.rA) & ~m);
   } else {
      a = r & m;
   }

   gpr(instr.rA) = a;

   if (instr.rc) {
      updateCr0(state, a);
   }

   return true;
}

/* Rotate Left Word Immediate then Mask Insert */
bool rlwimi(State *state, Instruction instr)
{
   return rlwxx<RlwImmediate | RlwMaskInsert>(state, instr);
}

/* Rotate Left Word Immediate then AND with Mask */
bool rlwinm(State *state, Instruction instr)
{
   return rlwxx<RlwImmediate>(state, instr);
}

/* Rotate Left Word then AND with Mask */
bool rlwnm(State *state, Instruction instr)
{
   return rlwxx<RlwDefault>(state, instr);
}

/* Shift x */
enum
{
   ShiftDefault = 0,
   ShiftLeft = 1 << 0,
   ShiftRight = 1 << 1,
   ShiftImmediate = 1 << 2,
   ShiftAlgebraic = 1 << 3,
};

template<typename Type, int Flags>
bool sxx(State *state, Instruction instr)
{
   Type a, n;

   n = gpr(instr.rB) & (little_endian::width<Type>() - 1);

   if (gpr(instr.rB) & little_endian::width<Type>()) {
      a = 0;
   } else if (Flags & ShiftRight) {
      a = reinterpret<Type>(gpr(instr.rS)) >> n;
   } else if (Flags & ShiftLeft) {
      a = reinterpret<Type>(gpr(instr.rS)) << n;
   }

   gpr(instr.rA) = a;

   if (instr.rc) {
      updateCr0(state, a);
   }

   return true;
}

/* Shift Left Doubleword */
bool sld(State *state, Instruction instr)
{
   return sxx<uint64_t, ShiftLeft>(state, instr);
}

/* Shift Left Word */
bool slw(State *state, Instruction instr)
{
   return sxx<uint32_t, ShiftLeft>(state, instr);
}

/* Shift Right Doubleword */
bool srd(State *state, Instruction instr)
{
   return sxx<uint64_t, ShiftRight>(state, instr);
}

/* Shift Right Word */
bool srw(State *state, Instruction instr)
{
   return sxx<uint32_t, ShiftRight>(state, instr);
}

/* Shift Right Algebraic x */
enum SraxFlags
{
   SraxDefault   =      0,
   SraxImmediate = 1 << 0,
};

template<typename Type, int Flags>
bool sraxx(State *state, Instruction instr)
{
   uint32_t n;
   int msb = little_endian::width<Type>() - 1;
   
   if (Flags & SraxImmediate) {
      if (little_endian::width<Type>() == 64) {
         n = instr.shd04 | (instr.shd5 << 4);
      } else {
         n = instr.sh;
      }
   } else {
      n = gpr(instr.rB) & msb;
   }

   gprs(instr.rA) = reinterpret<Type>(gpr(instr.rS)) >> n;

   if (instr.rc) {
      updateCr0(state, gpr(instr.rA));
   }

   state->reg.xer.ca = (little_endian::get_bit(gpr(instr.rS), msb)
                     && little_endian::get_bit(gpr(instr.rA), msb)) ? 1 : 0;

   return true;
}

/* Shift Right Algebraic Doubleword */
bool srad(State *state, Instruction instr)
{
   return sraxx<int64_t, SraxDefault>(state, instr);
}

/* Shift Right Algebraic Doubleword Immediate */
bool sradi(State *state, Instruction instr)
{
   return sraxx<int64_t, SraxImmediate>(state, instr);
}

/* Shift Right Algebraic Word */
bool sraw(State *state, Instruction instr)
{
   return sraxx<int32_t, SraxDefault>(state, instr);
}

/* Shift Right Algebraic Word Immediate */
bool srawi(State *state, Instruction instr)
{
   return sraxx<int64_t, SraxImmediate>(state, instr);
}

/* Subtract from x */
enum SubfFlags
{
   SubDefault      =      0,
   SubCarry        = 1 << 0,
   SubExtend       = 1 << 1,
   SubImmediate    = 1 << 2,
   SubFromZero     = 1 << 3,
   SubFromMinusOne = 1 << 4,
};

template<int Flags>
bool subfx(State *state, Instruction instr)
{
   uint64_t a, b, d;

   a = ~gpr(instr.rA);

   if (Flags & SubImmediate) {
      b = little_endian::signExtend<16, uint64_t>(instr.simm);
   } else if (Flags & SubFromZero) {
      b = 0;
   } else if (Flags & SubFromMinusOne) {
      b = -1;
   } else {
      b = gpr(instr.rB);
   }
   
   d = a + b;

   if (Flags & SubExtend) {
      d += state->reg.xer.ca;
   } else {
      d += 1;
   }

   gpr(instr.rD) = d;

   if ((Flags & SubImmediate) == 0) {
      if (instr.oe) {
         updateXerOverflow(state, little_endian::get_bit((a ^ d) & (b ^ d), 63) != 0);
      }

      if (instr.rc) {
         updateCr0(state, gpr(instr.rD));
      }
   }
   
   if (Flags & SubCarry || Flags & SubExtend) {
      state->reg.xer.ca = gpr(instr.rD) < gpr(instr.rA) ? 1 : 0;
   }

   return true;
}

/* Subtract from */
bool subf(State *state, Instruction instr)
{
   return subfx<SubDefault>(state, instr);
}

/* Subtract from Carrying */
bool subfc(State *state, Instruction instr)
{
   return subfx<SubCarry>(state, instr);
}

/* Subtract from Extended */
bool subfe(State *state, Instruction instr)
{
   return subfx<SubExtend>(state, instr);
}

/* Subtract from Immediate Carrying */
bool subfic(State *state, Instruction instr)
{
   return subfx<SubImmediate | SubCarry>(state, instr);
}

/* Subtract from Minus One Extended */
bool subfme(State *state, Instruction instr)
{
   return subfx<SubFromMinusOne | SubExtend>(state, instr);
}

/* Subtract from Zero Extended */
bool subfze(State *state, Instruction instr)
{
   return subfx<SubFromZero | SubExtend>(state, instr);
}

/* XOR */
bool xor(State *state, Instruction instr)
{
   gpr(instr.rA) = gpr(instr.rS) ^ gpr(instr.rB);

   if (instr.rc) {
      updateCr0(state, gpr(instr.rA));
   }

   return true;
}

/* XOR Immediate */
bool xori(State *state, Instruction instr)
{
   gpr(instr.rA) = gpr(instr.rS) ^ instr.uimm;
   return true;
}

/* XOR Immediate Shifted */
bool xoris(State *state, Instruction instr)
{
   gpr(instr.rA) = gpr(instr.rS) ^ (static_cast<uint64_t>(instr.uimm) << 16);
   return true;
}

} // namespace Interpreter

} // namespace ppc

```

`src/powerpc/interpreter/cpu.cpp`:

```cpp
#include "interpreter.h"
#include "regs.h"

#include "common/endian.h"

namespace ppc 
{

namespace Interpreter
{

bool handleExceptions(State *state)
{
   auto es1 = little_endian::make_bit_field<33, 36>(state->reg.srr1);
   auto es2 = little_endian::make_bit_field<42, 47>(state->reg.srr1);

   little_endian::copy_bit<0>(state->reg.srr1, state->reg.msr.value);
   little_endian::copy_bits<48, 55>(state->reg.srr1, state->reg.msr.value);
   little_endian::copy_bits<57, 59>(state->reg.srr1, state->reg.msr.value);
   little_endian::copy_bits<62, 63>(state->reg.srr1, state->reg.msr.value);

   state->reg.msr.sf = 1;
   state->reg.msr.pow = 0;
   state->reg.msr.ee = 0;
   state->reg.msr.pr = 0;
   state->reg.msr.fp = 0;
   state->reg.msr.fe0 = 0;
   state->reg.msr.se = 0;
   state->reg.msr.be = 0;
   state->reg.msr.fe1 = 0;
   state->reg.msr.pmm = 0;
   state->reg.msr.ir = 0;
   state->reg.msr.dr = 0;
   state->reg.msr.ri = 0;
   state->reg.msr.le = state->reg.msr.ile;

   state->reg.srr0 = state->nia;

   /* Nonmaskable, asynchronous */
   if (state->reg.exception & ppc::Exceptions::SystemReset) {
      es1 = 0;
      es2 = 0;
      state->nia = 0x100;
   } else if (state->reg.exception & ppc::Exceptions::MachineCheck) {
      if (state->reg.msr.me == 1) {
         state->reg.msr.me = 0;
         state->nia = 0x200;
      } else {
         /* Full hardware break / dump */
      }
   } else

   /* Synchronous, precise */
   if (state->reg.exception & ppc::Exceptions::SystemCall) {
      state->nia = 0xC00;
   } else if (state->reg.exception & ppc::Exceptions::FpuUnavailable) {
      state->nia = 0x800;
   } else if (state->reg.exception & ppc::Exceptions::Program) {
      /* TODO: Program set bits 43, 44, 45, 46, 47 */
      state->nia = 0x700;
   } else if (state->reg.exception & ppc::Exceptions::DSI) {
      /* TODO: DSI set dsisr, dar */
      state->nia = 0x300;
   } else if (state->reg.exception & ppc::Exceptions::DataSegment) {
      /* TODO: DataSegment set dar */
      state->nia = 0x380;
   } else if (state->reg.exception & ppc::Exceptions::Alignment) {
      /* TODO: Alignment set dsisr, dar */
      state->nia = 0x600;
   } else if (state->reg.exception & ppc::Exceptions::Trace) {
      state->nia = 0xd00;
   } else if (state->reg.exception & ppc::Exceptions::ISI) {
      /* TODO: ISI set bits 33, 35, 36 */
      state->nia = 0x400;
   } else if (state->reg.exception & ppc::Exceptions::InstructionSegment) {
      state->nia = 0x480;
   } else

   /* Imprecise */
   if (false) {
      /* TODO: Imprecise exception */
   } else

   /* Maskable, asynchronous */
   if (state->reg.exception & ppc::Exceptions::ExternalInterrupt) {
      state->nia = 0x500;
   } else if (state->reg.exception & ppc::Exceptions::Decrementer) {
      state->nia = 0x900;
   } else

   /* Unknown Priority */
   if (state->reg.exception & ppc::Exceptions::PerformanceMonitor) {
      state->nia = 0xf00;
   }
   
   return true;
}

bool raise(State *state, ppc::Exceptions exception)
{
   state->reg.exception |= exception;
   return true;
}

/* Move Condition Register Field */
bool mcrf(State *state, Instruction instr)
{
   crf(instr.crfD) = crf(instr.crfS);
   return true;
}

/* Move from Condition Register */
bool mfcr(State *state, Instruction instr)
{
   gpr(instr.rD) = state->reg.cr.value;
   return true;
}

/* Move from One Condition Register Field */
bool mfocrf(State *state, Instruction instr)
{
   auto crN = -1;

   for (int i = 0; i < 8 && crN == 0; ++i) {
      if (instr.crm & (1 << i)) {
         crN = i;
      }
   }

   if (crN > 0 && crN < 8) {
      auto mask = 0xf << (crN * 4);
      gpr(instr.rD) &= ~mask;
      gpr(instr.rD) |= state->reg.cr.value & mask;
   }

   return true;
}

/* Move from Machine State Register */
bool mfmsr(State *state, Instruction instr)
{
   gpr(instr.rD) = state->reg.msr.value;
   return true;
}

/* Move from Special-Purpose Register */
bool mfspr(State *state, Instruction instr)
{
   auto spr = (instr.spr >> 5) & 0x1f | (instr.spr & 0x1f);
   gpr(instr.rD) = state->reg.getSpr(spr);
   return true;
}

/* Move from Time Base */
bool mftb(State *state, Instruction instr)
{
   auto tbr = (instr.tbr >> 5) & 0x1f | (instr.tbr & 0x1f);
   
   switch (tbr) {
   case 268:
      gpr(instr.rD) = state->reg.tbl;
      break;
   case 269:
      gpr(instr.rD) = state->reg.tbu;
      break;
   }

   return true;
}

/* Move to Condition Register Field */
bool mtcrf(State *state, Instruction instr)
{
   uint32_t mask = 0;

   for (int i = 0; i < 8; ++i) {
      if (instr.crm & (1 << i)) {
         mask |= 0xf << i;
      }
   }

   state->reg.cr.value &= ~mask;
   state->reg.cr.value |= gpr(instr.rD) & mask;
   return true;
}

/* Move to Machine State Register */
bool mtmsr(State *state, Instruction instr)
{
   auto s = gpr(instr.rS);

   if (instr.l15 == 0) {
      state->reg.msr.ir = little_endian::get_bit<58>(s)
                        | little_endian::get_bit<49>(s);

      state->reg.msr.dr = little_endian::get_bit<59>(s)
                        | little_endian::get_bit<49>(s);

      little_endian::copy_bits<32, 47>(state->reg.msr.value, s);
      little_endian::copy_bits<49, 50>(state->reg.msr.value, s);
      little_endian::copy_bits<52, 57>(state->reg.msr.value, s);
      little_endian::copy_bits<60, 63>(state->reg.msr.value, s);
   } else {
      little_endian::copy_bits<48, 62>(state->reg.msr.value, s);
   }

   return true;
}

/* Move to Machine State Register Doubleword */
bool mtmsrd(State *state, Instruction instr)
{
   auto s = gpr(instr.rS);

   if (instr.l15 == 0) {
      state->reg.msr.sf = little_endian::get_bit<0>(s)
                        | little_endian::get_bit<1>(s);

      state->reg.msr.dr = little_endian::get_bit<59>(s)
                        | little_endian::get_bit<49>(s);

      little_endian::copy_bits<1, 2>(state->reg.msr.value, s);
      little_endian::copy_bits<4, 47>(state->reg.msr.value, s);
      little_endian::copy_bits<49, 50>(state->reg.msr.value, s);
      little_endian::copy_bits<52, 57>(state->reg.msr.value, s);
      little_endian::copy_bits<60, 63>(state->reg.msr.value, s);
   } else {
      little_endian::copy_bits<48, 62>(state->reg.msr.value, s);
   }

   return true;
}

/* Move to One Condition Register Field */
bool mtocrf(State *state, Instruction instr)
{
   auto crN = -1;

   for (int i = 0; i < 8 && crN == 0; ++i) {
      if (instr.crm & (1 << i)) {
         crN = i;
      }
   }

   if (crN > 0 && crN < 8) {
      auto mask = 0xf << (crN * 4);
      state->reg.cr.value &= ~mask;
      state->reg.cr.value |= gpr(instr.rD) & mask;
   }

   return true;
}

/* Move to Special-Purpose Register */
bool mtspr(State *state, Instruction instr)
{
   auto spr = (instr.spr >> 5) & 0x1f | (instr.spr & 0x1f);
   state->reg.setSpr(spr, gpr(instr.rS));
   return true;
}

/* Return from Interrupt Doubleword */
bool rfid(State *state, Instruction instr)
{
   
   state->reg.msr.sf = little_endian::get_bit(state->reg.srr1, 0)
                     | little_endian::get_bit(state->reg.srr1, 1);

   state->reg.msr.ir = little_endian::get_bit(state->reg.srr1, 58)
                     | little_endian::get_bit(state->reg.srr1, 49);

   state->reg.msr.dr = little_endian::get_bit(state->reg.srr1, 59)
                     | little_endian::get_bit(state->reg.srr1, 49);

   little_endian::copy_bits< 1, 2>(state->reg.msr.value, state->reg.srr1);
   little_endian::copy_bits< 4, 32>(state->reg.msr.value, state->reg.srr1);
   little_endian::copy_bits<37, 41>(state->reg.msr.value, state->reg.srr1);
   little_endian::copy_bits<52, 58>(state->reg.msr.value, state->reg.srr1);
   little_endian::copy_bits<60, 63>(state->reg.msr.value, state->reg.srr1);
   
   return true;
}

/* System Call */
bool sc(State *state, Instruction instr)
{
   raise(state, ppc::Exceptions::SystemCall);
   return true;
}

/* Trap x */
enum TrapFlags
{
   TrapUnsignedGreater = 1 << 0,
   TrapUnsignedLess    = 1 << 1,
   TrapEqual           = 1 << 2,
   TrapSignedGreater   = 1 << 3,
   TrapSignedLess      = 1 << 4
};

bool tx(State *state, Instruction instr, uint64_t a, uint64_t b)
{
   auto to = instr.to;
   bool e = false;

   e |= (to & TrapSignedLess)
        && (static_cast<int64_t>(a) < static_cast<int64_t>(b));

   e |= (to & TrapSignedGreater)
        && (static_cast<int64_t>(a) > static_cast<int64_t>(b));

   e |= (to & TrapEqual) && (a == b);
   e |= (to & TrapUnsignedLess) && (a < b);
   e |= (to & TrapUnsignedGreater) && (a > b);

   if (e) {
      raise(state, ppc::Exceptions::ProgramTrap);
   }

   return true;
}

/* Trap Doubleword */
bool td(State *state, Instruction instr)
{
   return tx(state,
             instr,
             gpr(instr.rA),
             gpr(instr.rB));
}

/* Trap Doubleword Immediate */
bool tdi(State *state, Instruction instr)
{
   return tx(state,
             instr,
             gpr(instr.rA),
             little_endian::signExtend<16, uint64_t>(instr.simm));
}

/* Trap Word */
bool tw(State *state, Instruction instr)
{
   return tx(state,
             instr,
             little_endian::signExtend<32, uint64_t>(gprw(instr.rA)),
             little_endian::signExtend<32, uint64_t>(gprw(instr.rB)));
}

/* Trap Word Immediate */
bool twi(State *state, Instruction instr)
{
   return tx(state,
             instr,
             little_endian::signExtend<32, uint64_t>(gprw(instr.rA)),
             little_endian::signExtend<16, uint64_t>(instr.simm));
}

} // namespace Interpreter

} // namespace ppc

```

`src/powerpc/interpreter/flow.cpp`:

```cpp
#include "interpreter.h"
#include "regs.h"

#include "common/endian.h"

namespace ppc 
{

namespace Interpreter
{

/* Branch */
bool b(State *state, Instruction instr)
{
   if (instr.aa) {
      state->nia = little_endian::signExtend<26>(static_cast<uint64_t>(instr.li) << 2);
   } else {
      state->nia = state->cia + little_endian::signExtend<26>(static_cast<uint64_t>(instr.li) << 2);
   }

   if (instr.lk) {
      state->reg.lr = state->cia + 4;
   }

   return true;
}

/* Branch Conditional x */
enum BO
{
   CtrValue    = 1 << 1,
   NoCheckCtr  = 1 << 2,
   CondValue   = 1 << 3,
   NoCheckCond = 1 << 4
};

enum BcxFlags
{
   BcxDefault    =      0,
   BcxNoCheckCtr = 1 << 0,
   BcxBranchCtr  = 1 << 1,
   BcxBranchLr   = 1 << 2,
};

template<int Flags>
bool bcx(State *state, Instruction instr)
{
   bool ctr_ok = true;
   bool cond_ok = true;

   if ((Flags & BcxNoCheckCtr) == 0 && (instr.bo & NoCheckCtr) == 0) {
      state->reg.ctr -= 1;
      ctr_ok = ((state->reg.ctr != 0) ^ (instr.bo & CtrValue)) != 0;
   }

   if ((instr.bo & NoCheckCond) == 0) {
      if (instr.bo & CondValue) {
         cond_ok = (state->reg.cr.value & (1 << instr.bi)) != 0;
      } else {
         cond_ok = (state->reg.cr.value & (1 << instr.bi)) == 0;
      }
   }

   if (ctr_ok && cond_ok) {
      if (Flags & BcxBranchCtr) {
         state->nia = state->reg.ctr & ~0x3;
      } else if (Flags & BcxBranchLr) {
         state->nia = state->reg.lr & 0xFFFFFFFC;
      } else {
         if (instr.aa) {
            state->nia = little_endian::signExtend<16>(static_cast<uint64_t>(instr.bd) << 2);
         } else {
            state->nia = state->cia + little_endian::signExtend<16>(static_cast<uint64_t>(instr.bd) << 2);
         }
      }

      if (instr.lk) {
         state->reg.lr = state->cia + 4;
      }
   }

   return true;
}

/* Branch Conditional */
bool bc(State *state, Instruction instr)
{
   return bcx<BcxDefault>(state, instr);
}

/* Branch Conditional to Count Register */
bool bcctr(State *state, Instruction instr)
{
   return bcx<BcxBranchCtr | BcxNoCheckCtr>(state, instr);
}

/* Branch Conditional to Link Register */
bool bclr(State *state, Instruction instr)
{
   return bcx<BcxBranchLr>(state, instr);
}

/* Compare x */
enum CmpxFlags
{
   CmpxDefault    =      0,
   CmpxImmediate  = 1 << 0
};

template<typename Type, int Flags>
bool cmpx(State *state, Instruction instr)
{
   auto flags = 0;
   Type a, b;

   if (instr.l == 0) {
      if (std::numeric_limits<Type>::is_signed) {
         a = little_endian::signExtend<32, Type>(gpr(instr.rA));
      } else {
         a = little_endian::zeroExtend<32, Type>(gpr(instr.rA));
      }
   } else {
      a = static_cast<Type>(gpr(instr.rA));
   }

   if (Flags & CmpxImmediate) {
      if (std::numeric_limits<Type>::is_signed) {
         b = little_endian::signExtend<16, Type>(instr.simm);
      } else {
         b = instr.uimm;
      }
   } else if (instr.l == 0) {
      if (std::numeric_limits<Type>::is_signed) {
         b = little_endian::signExtend<32, Type>(gpr(instr.rB));
      } else {
         b = little_endian::zeroExtend<32, Type>(gpr(instr.rB));
      }
   } else {
      b = static_cast<Type>(gpr(instr.rB));
   }

   if (a < b) {
      flags |= ppc::Cr::Negative;
   } else if (a > b) {
      flags |= ppc::Cr::Positive;
   } else {
      flags |= ppc::Cr::Zero;
   }

   flags |= state->reg.xer.so;
   crf(instr.crfD) = flags;

   return true;
}

/* Compare */
bool cmp(State *state, Instruction instr)
{
   return cmpx<ppc::sreg_t, CmpxDefault>(state, instr);
}

/* Compare Immediate */
bool cmpi(State *state, Instruction instr)
{
   return cmpx<ppc::sreg_t, CmpxImmediate>(state, instr);
}

/* Compare Logical */
bool cmpl(State *state, Instruction instr)
{
   return cmpx<ppc::ureg_t, CmpxDefault>(state, instr);
}

/* Compare Logical Immediate */
bool cmpli(State *state, Instruction instr)
{
   return cmpx<ppc::ureg_t, CmpxImmediate>(state, instr);
}

/* Condition Register AND */
bool crand(State *state, Instruction instr)
{
   auto a = crb(instr.crbA);
   auto b = crb(instr.crbB);
   crb(instr.crbD) = a & b;
   return true;
}

/* Condition Register AND with Complement */
bool crandc(State *state, Instruction instr)
{
   auto a = crb(instr.crbA);
   auto b = crb(instr.crbB);
   crb(instr.crbD) = a & ~b;
   return true;
}

/* Condition Register Equivalent */
bool creqv(State *state, Instruction instr)
{
   auto a = crb(instr.crbA);
   auto b = crb(instr.crbB);
   crb(instr.crbD) = ~(a ^ b);
   return true;
}

/* Condition Register NAND */
bool crnand(State *state, Instruction instr)
{
   auto a = crb(instr.crbA);
   auto b = crb(instr.crbB);
   crb(instr.crbD) = ~(a & b);
   return true;
}

/* Condition Register NOR */
bool crnor(State *state, Instruction instr)
{
   auto a = crb(instr.crbA);
   auto b = crb(instr.crbB);
   crb(instr.crbD) = ~(a | b);
   return true;
}

/* Condition Register OR */
bool cror(State *state, Instruction instr)
{
   auto a = crb(instr.crbA);
   auto b = crb(instr.crbB);
   crb(instr.crbD) = a | b;
   return true;
}

/* Condition Register OR with Complement */
bool crorc(State *state, Instruction instr)
{
   auto a = crb(instr.crbA);
   auto b = crb(instr.crbB);
   crb(instr.crbD) = a | ~b;
   return true;
}

/* Condition Register XOR */
bool crxor(State *state, Instruction instr)
{
   auto a = crb(instr.crbA);
   auto b = crb(instr.crbB);
   crb(instr.crbD) = a ^ b;
   return true;
}

} // namespace Interpreter

} // namespace ppc

```

`src/powerpc/interpreter/fpu.cpp`:

```cpp
#include "interpreter.h"
#include "fpu.h"
#include "regs.h"

#include <limits>
#include <float.h>
#include <cmath>

namespace ppc 
{

namespace Interpreter
{
   
static inline void updateVx(State *state)
{
   Fpscr fpscr = state->reg.fpscr;
   fpscr.vx = fpscr.vxsnan | fpscr.vxisi | fpscr.vxidi | fpscr.vxzdz | fpscr.vximz | fpscr.vxvc | fpscr.vxsqrt | fpscr.vxsoft | fpscr.vxcvi;
   state->reg.fpscr = fpscr;
}

static inline void updateFexVx(State *state)
{
   Fpscr fpscr = state->reg.fpscr;
   fpscr.vx = fpscr.vxsnan | fpscr.vxisi | fpscr.vxidi | fpscr.vxzdz | fpscr.vximz | fpscr.vxvc | fpscr.vxsqrt | fpscr.vxsoft | fpscr.vxcvi;
   fpscr.fex = (fpscr.vx & fpscr.ve) | (fpscr.ox & fpscr.oe) | (fpscr.ux & fpscr.ue) | (fpscr.zx & fpscr.ze) | (fpscr.xx & fpscr.xe);
   state->reg.fpscr = fpscr;
}

static inline void updateFpscr(State *state)
{
   /* TODO: */
   //uint32_t vxvc : 1;      /* FP Exception: Invalid Operation for Compare */
   //uint32_t fr : 1;        /* FP State: Fraction Rounded */
      
   /* _SW_INVALID, _SW_DENORMAL, _SW_UNEMULATED, _SW_STACKOVERFLOW, _SW_STACKUNDERFLOW */

   auto flags = _statusfp();
   Fpscr fpscr = state->reg.fpscr;
   fpscr.fi = (flags & _SW_INEXACT) != 0;
   fpscr.xx |= fpscr.fi;
   fpscr.ux |= (flags & _SW_UNDERFLOW) != 0;
   fpscr.ox |= (flags & _SW_OVERFLOW) != 0;
   fpscr.zx |= (flags & _SW_ZERODIVIDE) != 0;
   fpscr.vxsqrt |= (flags & _SW_SQRTNEG) != 0;
   fpscr.vx = fpscr.vxsnan | fpscr.vxisi | fpscr.vxidi | fpscr.vxzdz | fpscr.vximz | fpscr.vxvc | fpscr.vxsqrt | fpscr.vxsoft | fpscr.vxcvi;
   fpscr.fex = (fpscr.vx & fpscr.ve) | (fpscr.ox & fpscr.oe) | (fpscr.ux & fpscr.ue) | (fpscr.zx & fpscr.ze) | (fpscr.xx & fpscr.xe);
   fpscr.fx |= fpscr.vx | fpscr.ox | fpscr.ux | fpscr.zx | fpscr.xx;
   state->reg.fpscr = fpscr;
}

static inline void updateFprfCompare(State *state, double value)
{
   auto flags = 0;

   if (value == 0.0 || value == -0.0) {
      flags |= ppc::Fpscr::Equal;
   } else if (value < 0.0) {
      flags |= ppc::Fpscr::Negative;
   } else if (value > 0.0) {
      flags |= ppc::Fpscr::Positive;
   } else {
      flags |= ppc::Fpscr::Unordered;
   }

   state->reg.fpscr.fprf = flags;
}

static inline void updateFprf(State *state, double value)
{
   auto fpcls = _fpclass(value);
   auto flags = 0;

   if (fpcls & _FPCLASS_QNAN) {
      /* 1  0  0  0  1   Quiet NaN */
      flags |= ppc::Fpscr::ClassDescriptor;
      flags |= ppc::Fpscr::Unordered;
   } else if (fpcls & _FPCLASS_NINF) {
      /* 0  1  0  0  1  -Infinity */
      flags |= ppc::Fpscr::Negative;
      flags |= ppc::Fpscr::Unordered;
   } else if (fpcls & _FPCLASS_NN) {
      /* 0  1  0  0  0  -Normalised Number */
      flags |= ppc::Fpscr::Negative;
   } else if (fpcls & _FPCLASS_ND) {
      /* 1  1  0  0  0  -Denormalised Number */
      flags |= ppc::Fpscr::ClassDescriptor;
      flags |= ppc::Fpscr::Negative;
   } else if (fpcls & _FPCLASS_NZ) {
      /* 1  0  0  1  0  -Zero */
      flags |= ppc::Fpscr::ClassDescriptor;
      flags |= ppc::Fpscr::Equal;
   } else if (fpcls & _FPCLASS_PZ) {
      /* 0  0  0  1  0  +Zero */
      flags |= ppc::Fpscr::Equal;
   } else if (fpcls & _FPCLASS_PD) {
      /* 1  0  1  0  0  +Denormalized Number */
      flags |= ppc::Fpscr::ClassDescriptor;
      flags |= ppc::Fpscr::Positive;
   } else if (fpcls & _FPCLASS_PN) {
      /* 0  0  1  0  0  +Normalized Number */
      flags |= ppc::Fpscr::Positive;
   } else if (fpcls & _FPCLASS_PINF) {
      /* 0  0  1  0  1  +Infinity */
      flags |= ppc::Fpscr::Positive;
      flags |= ppc::Fpscr::Unordered;
   }

   state->reg.fpscr.fprf = flags;
}

static inline void updateCr1(State *state)
{
   state->reg.cr.cr1 = state->reg.fpscr.cr1;
}

/* Floating Absolute Value */
bool fabs(State *state, Instruction instr)
{
   fpr(instr.frD) = std::fabs(fpr(instr.frB));

   if (instr.rc) {
      updateCr1(state);
   }

   return true;
}

/* Floating Add x */
template<typename Type>
bool faddx(State *state, Instruction instr)
{
   auto a = fpr(instr.frA);
   auto b = fpr(instr.frB);

   state->reg.fpscr.vxsnan |= fpu::isSignalingNaN(a) || fpu::isSignalingNaN(b);
   state->reg.fpscr.vxisi  |= fpu::isInfinity(a) && fpu::isInfinity(b);

   auto r = a + b;
   updateFpscr(state);
   updateFprf(state, r);
   fpr(instr.frD) = r;

   if (instr.rc) {
      updateCr1(state);
   }

   return true;
}

/* Floating Add */
bool fadd(State *state, Instruction instr)
{
   return faddx<double>(state, instr);
}

/* Floating Add Single */
bool fadds(State *state, Instruction instr)
{
   return faddx<float>(state, instr);
}

/* Floating Convert from Integer Doubleword  */
bool fcfid(State *state, Instruction instr)
{
   fpu::Double dbl = fpr(instr.frB);

   fpr(instr.frD) = static_cast<double>(dbl.uv);
   updateFpscr(state);
   updateFprf(state, fpr(instr.frD));

   if (instr.rc) {
      updateCr1(state);
   }

   return true;
}

/* Floating Compare x */
enum Order {
   Unordered = 0,
   Ordered = 1
};

template<int Order>
bool fcmp(State *state, Instruction instr)
{
   auto a = fpr(instr.frA);
   auto b = fpr(instr.frB);
   auto flags = 0;

   if (fpu::isNaN(a) || fpu::isNaN(b)) {
      flags = ppc::Fpscr::Unordered;
   } else if (a < b) {
      flags = ppc::Fpscr::Negative;
   } else if (a > b) {
      flags = ppc::Fpscr::Positive;
   } else {
      flags = ppc::Fpscr::Equal;
   }

   state->reg.fpscr.fprf = flags;
   crf(instr.crfD) = flags;
   
   if (fpu::isSignalingNaN(a) || fpu::isSignalingNaN(b)) {
      state->reg.fpscr.vxsnan = 1;

      if (Order == Ordered && !state->reg.fpscr.ve) {
         state->reg.fpscr.vxvc = 1;
      }

      state->reg.fpscr.fx = 1;
   } else if (Order == Ordered && (fpu::isQuietNaN(a) || fpu::isQuietNaN(b))) {
      state->reg.fpscr.vxvc = 1;
      state->reg.fpscr.fx = 1;
   }
   
   return true;
}

/* Floating Compare */
bool fcmpo(State *state, Instruction instr)
{
   return fcmp<Ordered>(state, instr);
}

/* Floating Compare Unordered */
bool fcmpu(State *state, Instruction instr)
{
   return fcmp<Unordered>(state, instr);
}

/* Floating Convert to Integer x */
enum FctiRounding {
   RoundDefault = 0,
   RoundToZero = 1
};

template<typename DstType, int Rounding>
bool fctixx(State *state, Instruction instr)
{
   DstType value;

   if (fpr(instr.frB) > std::numeric_limits<DstType>::max()) {
      value = std::numeric_limits<DstType>::max();
   } else if (fpr(instr.frB) < std::numeric_limits<DstType>::min()) {
      value = std::numeric_limits<DstType>::min();
   } else if (Rounding == RoundToZero) {
      value = static_cast<DstType>(std::trunc(fpr(instr.frB)));
   } else {
      /* TODO: use rounding mode in FPSCR[RN] */
      value = static_cast<DstType>(fpr(instr.frB));
   }

   updateFpscr(state);

   /* TODO: is this always done? */
   if (static_cast<double>(value) > instr.frB) {
      state->reg.fpscr.fr = 1;
   }

   reinterpret<DstType>(fpr(instr.frB)) = value;

   if (instr.rc) {
      updateCr1(state);
   }

   return true;
}

/* Floating Convert to Integer Doubleword */
bool fctid(State *state, Instruction instr)
{
   return fctixx<int64_t, RoundDefault>(state, instr);
}

/* Floating Convert to Integer Doubleword with Round to Zero */
bool fctidz(State *state, Instruction instr)
{
   return fctixx<int64_t, RoundToZero>(state, instr);
}

/* Floating Convert to Integer Word */
bool fctiw(State *state, Instruction instr)
{
   return fctixx<int32_t, RoundDefault>(state, instr);
}

/* Floating Convert to Integer Word with Round to Zero */
bool fctiwz(State *state, Instruction instr)
{
   return fctixx<int32_t, RoundToZero>(state, instr);
}

/* Floating Divide x */
template<typename Type>
bool fdivx(State *state, Instruction instr)
{
   auto a = fpr(instr.frA);
   auto b = fpr(instr.frB);

   state->reg.fpscr.vxzdz  |= fpu::isZero(a) && fpu::isZero(b);
   state->reg.fpscr.vxsnan |= fpu::isSignalingNaN(a) || fpu::isSignalingNaN(b);
   state->reg.fpscr.vxidi  |= fpu::isInfinity(a) && fpu::isInfinity(b);

   auto r = a / b;
   updateFpscr(state);
   updateFprf(state, r);
   fpr(instr.frD) = r;

   if (instr.rc) {
      updateCr1(state);
   }

   return true;
}

/* Floating Divide */
bool fdiv(State *state, Instruction instr)
{
   return fdivx<double>(state, instr);
}

/* Floating Divide Single */
bool fdivs(State *state, Instruction instr)
{
   return fdivx<float>(state, instr);
}

/* Floating Multiply-Add x */
template<typename Type>
bool fmaddx(State *state, Instruction instr)
{
   auto a = fpr(instr.frA);
   auto b = fpr(instr.frB);
   auto c = fpr(instr.frC);

   state->reg.fpscr.vximz  |= fpu::isInfinity(a) && fpu::isZero(c);
   state->reg.fpscr.vxsnan |= fpu::isSignalingNaN(a) || fpu::isSignalingNaN(b) || fpu::isSignalingNaN(c);
   state->reg.fpscr.vxisi  |= (fpu::isInfinity(a) || fpu::isInfinity(c)) && fpu::isInfinity(b);

   auto r = (a * c) + b;
   updateFpscr(state);
   updateFprf(state, r);
   fpr(instr.frD) = r;

   if (instr.rc) {
      updateCr1(state);
   }

   return true;
}

/* Floating Multiply-Add */
bool fmadd(State *state, Instruction instr)
{
   return fmaddx<double>(state, instr);
}

/* Floating Multiply-Add Single */
bool fmadds(State *state, Instruction instr)
{
   return fmaddx<float>(state, instr);
}

/* Floating Move Register */
bool fmr(State *state, Instruction instr)
{
   fpr(instr.frD) = fpr(instr.frB);

   if (instr.rc) {
      updateCr1(state);
   }

   return true;
}

/* Floating Multiply-Subtract x */
template<typename Type>
bool fmsubx(State *state, Instruction instr)
{
   auto a = fpr(instr.frA);
   auto b = fpr(instr.frB);
   auto c = fpr(instr.frC);

   state->reg.fpscr.vximz  |= fpu::isInfinity(a) && fpu::isZero(c);
   state->reg.fpscr.vxsnan |= fpu::isSignalingNaN(a) || fpu::isSignalingNaN(b) || fpu::isSignalingNaN(c);
   state->reg.fpscr.vxisi  |= (fpu::isInfinity(a) || fpu::isInfinity(c)) && fpu::isInfinity(b);

   auto r = (a * c) - b;
   updateFpscr(state);
   updateFprf(state, r);
   fpr(instr.frD) = r;

   if (instr.rc) {
      updateCr1(state);
   }

   return true;
}

/* Floating Multiply-Subtract */
bool fmsub(State *state, Instruction instr)
{
   return fmsubx<double>(state, instr);
}

/* Floating Multiply-Subtract Single */
bool fmsubs(State *state, Instruction instr)
{
   return fmsubx<float>(state, instr);
}

/* Floating Multiply x */
template<typename Type>
bool fmulx(State *state, Instruction instr)
{
   auto a = fpr(instr.frA);
   auto c = fpr(instr.frC);

   state->reg.fpscr.vximz  |= fpu::isInfinity(a) && fpu::isZero(c);
   state->reg.fpscr.vxsnan |= fpu::isSignalingNaN(a) || fpu::isSignalingNaN(c);

   auto r = a * c;
   updateFpscr(state);
   updateFprf(state, r);
   fpr(instr.frD) = r;

   if (instr.rc) {
      updateCr1(state);
   }

   return true;
}

/* Floating Multiply */
bool fmul(State *state, Instruction instr)
{
   return fmulx<double>(state, instr);
}

/* Floating Multiply Single */
bool fmuls(State *state, Instruction instr)
{
   return fmulx<float>(state, instr);
}

/* Floating Negative Absolute Value */
bool fnabs(State *state, Instruction instr)
{
   fpr(instr.frD) = fpu::makeNegative(std::fabs(fpr(instr.frB)));

   if (instr.rc) {
      updateCr1(state);
   }

   return true;
}

/* Floating Negate */
bool fneg(State *state, Instruction instr)
{
   fpr(instr.frD) = fpu::makeNegative(fpr(instr.frB));

   if (instr.rc) {
      updateCr1(state);
   }

   return true;
}

/* Floating Negative Multiply-Add x */
template<typename Type>
bool fnmaddx(State *state, Instruction instr)
{
   auto a = fpr(instr.frA);
   auto b = fpr(instr.frB);
   auto c = fpr(instr.frC);

   state->reg.fpscr.vximz  |= fpu::isInfinity(a) && fpu::isZero(c);
   state->reg.fpscr.vxsnan |= fpu::isSignalingNaN(a) || fpu::isSignalingNaN(b) || fpu::isSignalingNaN(c);
   state->reg.fpscr.vxisi  |= (fpu::isInfinity(a) || fpu::isInfinity(c)) && fpu::isInfinity(b);

   auto r = -((a * c) + b);
   updateFpscr(state);
   updateFprf(state, r);
   fpr(instr.frD) = r;

   if (instr.rc) {
      updateCr1(state);
   }

   return true;
}


/* Floating Negative Multiply-Add */
bool fnmadd(State *state, Instruction instr)
{
   return fnmaddx<double>(state, instr);
}

/* Floating Negative Multiply-Add Single */
bool fnmadds(State *state, Instruction instr)
{
   return fnmaddx<float>(state, instr);
}

/* Floating Negative Multiply-Subtract x */
template<typename Type>
bool fnmsubx(State *state, Instruction instr)
{
   auto a = fpr(instr.frA);
   auto b = fpr(instr.frB);
   auto c = fpr(instr.frC);

   state->reg.fpscr.vximz  |= fpu::isInfinity(a) && fpu::isZero(c);
   state->reg.fpscr.vxsnan |= fpu::isSignalingNaN(a) || fpu::isSignalingNaN(b) || fpu::isSignalingNaN(c);
   state->reg.fpscr.vxisi  |= (fpu::isInfinity(a) || fpu::isInfinity(c)) && fpu::isInfinity(b);

   auto r = -((a * c) - b);
   updateFpscr(state);
   updateFprf(state, r);
   fpr(instr.frD) = r;

   if (instr.rc) {
      updateCr1(state);
   }

   return true;
}

/* Floating Negative Multiply-Subtract */
bool fnmsub(State *state, Instruction instr)
{
   return fnmsubx<double>(state, instr);
}

/* Floating Negative Multiply-Subtract Single */
bool fnmsubs(State *state, Instruction instr)
{
   return fnmsubx<float>(state, instr);
}

/* Floating Reciprocal Estimate Single */
bool fres(State *state, Instruction instr)
{
   auto b = fpr(instr.frB);

   state->reg.fpscr.vxsnan |= fpu::isSignalingNaN(b);

   auto r = 1.0f / b;
   updateFpscr(state);
   updateFprf(state, r);
   fpr(instr.frD) = r;

   if (instr.rc) {
      updateCr1(state);
   }

   return true;
}

/* Floating Round to Single */
bool frsp(State *state, Instruction instr)
{
   auto b = fpr(instr.frB);

   state->reg.fpscr.vxsnan |= fpu::isSignalingNaN(b);

   /* TODO: use rounding mode in FPSCR[RN] */
   auto r = static_cast<double>(static_cast<float>(b));
   updateFpscr(state);
   updateFprf(state, r);
   fpr(instr.frD) = r;

   if (instr.rc) {
      updateCr1(state);
   }

   return true;
}

/* Floating Reciprocal Square Root Estimate */
bool frsqrte(State *state, Instruction instr)
{
   double b = fpr(instr.frB);
   double r;

   state->reg.fpscr.vxsnan |= fpu::isSignalingNaN(b);
   state->reg.fpscr.vxsqrt |= fpu::isNegativeInfinity(b) | fpu::isSignalingNaN(b) | fpu::isNegative(b);

   if (fpu::isNegativeZero(b)) {
      r = fpu::negativeInfinity();
   } if (fpu::isPositiveZero(b)) {
      r = fpu::positiveInfinity();
   } else if (fpu::isPositiveInfinity(b)) {
      r = fpu::positiveZero();
   } else if (fpu::isNegativeInfinity(b) || fpu::isSignalingNaN(b) || fpu::isQuietNaN(b) || fpu::isNegative(b)) {
      r = fpu::quietNaN();
   } else {
      /* TODO: frsqrte as estimate, not exact */
      r = 1.0 / std::sqrt(b);
   }

   updateFpscr(state);
   updateFprf(state, r);
   fpr(instr.frD) = r;

   if (instr.rc) {
      updateCr1(state);
   }

   return true;
}

/* Floating Select */
bool fsel(State *state, Instruction instr)
{
   fpr(instr.frD) = fpr(instr.frA) > 0.0 ? fpr(instr.frC) : fpr(instr.frB);

   if (instr.rc) {
      updateCr1(state);
   }

   return true;
}

/* Floating Square Root x */
template<typename Type>
bool fsqrtx(State *state, Instruction instr)
{
   double b = fpr(instr.frB);
   double r;

   state->reg.fpscr.vxsnan |= fpu::isSignalingNaN(b);
   state->reg.fpscr.vxsqrt |= fpu::isNegativeInfinity(b) | fpu::isSignalingNaN(b) | fpu::isNegative(b);

   if (fpu::isNegativeZero(b)) {
      r = fpu::negativeZero();
   } else if (fpu::isPositiveInfinity(b)) {
      r = fpu::positiveInfinity();
   } else if (fpu::isNegativeInfinity(b) || fpu::isSignalingNaN(b) || fpu::isQuietNaN(b) || fpu::isNegative(b)) {
      r = fpu::quietNaN();
   } else {
      r = std::sqrt(b);
   }

   updateFpscr(state);
   updateFprf(state, fpr(instr.frD));
   fpr(instr.frD) = r;

   if (instr.rc) {
      updateCr1(state);
   }

   return true;
}

/* Floating Square Root */
bool fsqrt(State *state, Instruction instr)
{
   return fsqrtx<double>(state, instr);
}

/* Floating Square Root Single */
bool fsqrts(State *state, Instruction instr)
{
   return fsqrtx<float>(state, instr);
}

/* Floating Subtracet x */
template<typename Type>
bool fsubx(State *state, Instruction instr)
{
   auto a = fpr(instr.frA);
   auto b = fpr(instr.frB);

   state->reg.fpscr.vxsnan |= fpu::isSignalingNaN(a) || fpu::isSignalingNaN(b);
   state->reg.fpscr.vxisi  |= fpu::isInfinity(a) && fpu::isInfinity(b);

   auto r = a - b;
   updateFpscr(state);
   updateFprf(state, fpr(instr.frD));
   fpr(instr.frD) = r;

   if (instr.rc) {
      updateCr1(state);
   }

   return true;
}

/* Floating Subtracet */
bool fsub(State *state, Instruction instr)
{
   return fsubx<double>(state, instr);
}

/* Floating Subtracet Single */
bool fsubs(State *state, Instruction instr)
{
   return fsubx<float>(state, instr);
}

/* Move to Condition Register from FPSCR */
bool mcrfs(State *state, Instruction instr)
{
   fpscr(instr.crfD) = fpscr(instr.crfS);

   switch (instr.crfS) {
   case 0:
      state->reg.fpscr.fx = 0;
      state->reg.fpscr.ox = 0;
      break;
   case 1:
      state->reg.fpscr.ux = 0;
      state->reg.fpscr.zx = 0;
      state->reg.fpscr.xx = 0;
      state->reg.fpscr.vxsnan = 0;
      break;
   case 2:
      state->reg.fpscr.vxisi = 0;
      state->reg.fpscr.vxidi = 0;
      state->reg.fpscr.vxzdz = 0;
      state->reg.fpscr.vximz = 0;
      break;
   case 3:
      state->reg.fpscr.vxvc = 0;
      break;
   case 5:
      state->reg.fpscr.vxsoft = 0;
      state->reg.fpscr.vxsqrt = 0;
      state->reg.fpscr.vxcvi = 0;
      break;
   }

   return true;
}

/* Move from FPSCR */
bool mffs(State *state, Instruction instr)
{
   reinterpret<uint64_t>(fpr(instr.frB)) = state->reg.fpscr.value;

   if (instr.rc) {
      updateCr1(state);
   }

   return true;
}

/* Move to FPSCR Bit 0 */
bool mtfsb0(State *state, Instruction instr)
{
   state->reg.fpscr.value = little_endian::clear_bit(state->reg.fpscr.value, instr.crbD);

   if (instr.rc) {
      updateCr1(state);
   }

   return true;
}

/* Move to FPSCR Bit 1 */
bool mtfsb1(State *state, Instruction instr)
{
   state->reg.fpscr.value = little_endian::set_bit(state->reg.fpscr.value, instr.crbD);

   if (instr.rc) {
      updateCr1(state);
   }

   return true;
}

/* Move to FPSCR Fields */
bool mtfsf(State *state, Instruction instr)
{
   uint32_t mask = 0;

   for (int i = 0; i < 8; ++i) {
      if (instr.fm & (1 << i)) {
         if (i == 0) {
            mask |= 0x9;
         } else {
            mask |= 0xf << i;
         }
      }
   }

   state->reg.fpscr.value &= ~mask;
   state->reg.fpscr.value |= reinterpret<uint32_t>(fpr(instr.frB)) & mask;

   if (instr.fm & 1) {
      updateFexVx(state);
   } else {
      updateVx(state);
   }

   if (instr.rc) {
      updateCr1(state);
   }

   return true;
}

/* Move to FPSCR Field Immediate */
bool mtfsfi(State *state, Instruction instr)
{
   if (instr.crfD == 0) {
      fpscr(instr.crfD) = instr.uimm & 0x9;
   } else {
      fpscr(instr.crfD) = instr.uimm;
   }

   updateFexVx(state);

   if (instr.rc) {
      updateCr1(state);
   }

   return true;
}

} // namespace Interpreter

} // namespace ppc

```

`src/powerpc/interpreter/fpu.h`:

```h
#ifndef PPC_FPU_H
#define PPC_FPU_H

#include <stdint.h>

namespace ppc
{
   
namespace fpu
{

union Single
{
   Single(){}
   Single(float v) : v(v) {}
   Single(uint32_t uv) : uv(uv) {}

   float v;
   uint32_t uv;

   struct {
      uint32_t mantissa : 23;
      uint32_t exponent : 8;
      uint32_t sign : 1;
   };
};

union Double
{
   Double(){}
   Double(double v) : v(v) {}
   Double(uint64_t uv) : uv(uv) {}

   double v;
   uint64_t uv;

   struct {
      uint64_t mantissa : 52;
      uint64_t exponent : 11;
      uint64_t sign : 1;
   };
};

static const uint64_t exponent_min = 0;
static const uint64_t exponent_max = (1 << 11) - 1;

uint64_t exponent(double v)
{
   Double d = v;
   return d.exponent;
}

uint64_t mantissa(double v)
{
   Double d = v;
   return d.mantissa;
}

uint64_t sign(double v)
{
   Double d = v;
   return d.sign;
}

double makeNegative(double v)
{
   Double d = v;
   d.sign = 1;
   return d.v;
}

double makePositive(double v)
{
   Double d = v;
   d.sign = 0;
   return d.v;
}

double positiveZero()
{
   Double d;
   d.sign = 0;
   d.exponent = 0;
   d.mantissa = 0;
   return d.v;
}

double negativeZero()
{
   Double d;
   d.sign = 1;
   d.exponent = 0;
   d.mantissa = 0;
   return d.v;
}

double positiveInfinity()
{
   Double d;
   d.sign = 0;
   d.mantissa = 0;
   d.exponent = exponent_max;
   return d.v;
}

double negativeInfinity()
{
   Double d;
   d.sign = 1;
   d.mantissa = 0;
   d.exponent = exponent_max;
   return d.v;
}

double quietNaN()
{
   Double d;
   d.mantissa = 1ull << 51;
   d.exponent = exponent_max;
   return d.v;
}

double signalingNaN()
{
   Double d;
   d.mantissa = 1ull << 50;
   d.exponent = exponent_max;
   return d.v;
}

bool isPositive(double v)
{
   Double d = v;
   return d.sign == 0;
}

bool isNegative(double v)
{
   Double d = v;
   return d.sign == 1;
}

bool isZero(double v)
{
   Double d = v;
   return d.exponent == 0
       && d.mantissa == 0;
}

bool isPositiveZero(double v)
{
   Double d = v;
   return d.sign == 0
       && d.exponent == 0
       && d.mantissa == 0;
}

bool isNegativeZero(double v)
{
   Double d = v;
   return d.sign == 1
       && d.exponent == 0
       && d.mantissa == 0;
}

bool isNormal(double v)
{
   Double d = v;
   return d.exponent > exponent_min
       && d.exponent < exponent_max;
}

bool isDenormal(double v)
{
   Double d = v;
   return d.exponent == 0;
}

bool isInfinity(double v)
{
   Double d = v;
   return d.exponent == exponent_max
       && d.mantissa == 0;
}

bool isPositiveInfinity(double v)
{
   Double d = v;
   return d.sign == 0
       && d.exponent == exponent_max
       && d.mantissa == 0;
}

bool isNegativeInfinity(double v)
{
   Double d = v;
   return d.sign == 1
       && d.exponent == exponent_max
       && d.mantissa == 0;
}

bool isNaN(double v)
{
   Double d = v;
   return d.exponent == exponent_max
       && d.mantissa != 0;
}

bool isQuietNaN(double v)
{
   Double d = v;
   return d.exponent == exponent_max
       && d.mantissa != 0
       && (d.mantissa & (1ull << 51)) != 0;
}

bool isSignalingNaN(double v)
{
   Double d = v;
   return d.exponent == exponent_max
       && d.mantissa != 0
       && (d.mantissa & (1ull << 51)) == 0;
}

} // namespace fpu

} // namespace ppc

#endif // ifndef PPC_FPU_H

```

`src/powerpc/interpreter/interpreter.cpp`:

```cpp
#include "interpreter.h"

#include "powerpc/instructions.h"
#include "powerpc/decoder.h"

namespace ppc 
{

namespace Interpreter
{

typedef bool (*fptr_t)(State *, Instruction);

#include "powerpc/emugen_table.h"

bool decode(State *state, Instruction instr)
{
   InstructionID id = ppc::decode(instr);

   if (id == InstructionID::Unknown) {
      return false;
   } else {
      return _emugenTable[static_cast<unsigned>(id)](state, instr);
   }
}

} // namespace Interpreter

} // namespace ppc

```

`src/powerpc/interpreter/interpreter.h`:

```h
#ifndef PPC_INTERPRETER_H
#define PPC_INTERPRETER_H

#include "../cpu.h"

namespace ppc
{

namespace Interpreter
{

struct State {
   uint64_t cia;
   uint64_t nia;
   Registers reg;
};

bool decode(State *state, Instruction instr);

bool raise(State *state, ppc::Exceptions exception);

#include "../emugen_stubs.h"

} // namespace Interpreter

} // namespace ppc

#endif // PPC_INTERPRETER_H

```

`src/powerpc/interpreter/kernel.cpp`:

```cpp
#include "interpreter.h"
#include "regs.h"

#include "powerpc/instructions.h"

#include "common/log.h"
#include "common/memory.h"

#include "kernel/module.h"

#include "xex/xex.h"

#include <functional>

namespace ppc 
{

namespace Interpreter
{

/* Kernel Function Call */
bool krncall(State *state, Instruction instr)
{
   auto ptr  = Memory::read<uint64_t>(state->cia + 4);
   auto valid = instr.rD;
   auto args  = instr.rA;

   if (!valid) {
      xex::ImportLibrary *library = reinterpret_cast<xex::ImportLibrary*>(ptr);
      xex::ImportLibrary::Import *import = nullptr;
      auto ordinal = instr.uimm;

      for (auto &imp : library->imports) {
         if (imp.ordinal == ordinal) {
            import = &imp;
         }
      }

      if (import) {
         xDebug() << "Kernel call to unresolved import " << library->name << "(" << ordinal << ") " << import->name;
      } else {
         xDebug() << "Kernel call to unresolved import " << library->name << "(" << ordinal << ")";
      }

      assert(0);
      return false;
   }

   // TODO: Revisit if need fpr or vpr instead of gpr
   auto exprt = reinterpret_cast<Module::Export*>(ptr);
   auto func = reinterpret_cast<Module::BoundFunction*>(exprt->ptr);
   func->call(state->reg.gpr);

   state->nia = state->reg.lr;
   return true;
}

} // namespace Interpreter

} // namespace ppc

```

`src/powerpc/interpreter/load.cpp`:

```cpp
#include "interpreter.h"
#include "regs.h"

#include "powerpc/instructions.h"

#include "common/log.h"
#include "common/memory.h"

#include <limits>

namespace ppc 
{

namespace Interpreter
{
   
/* Load x */
enum LoadFlags {
   LoadDefault    = 0,
   LoadIndexed    = 1 << 0,
   LoadUpdate     = 1 << 1,
   LoadDS         = 1 << 2,
   LoadZeroExtend = 1 << 3,
   LoadSignExtend = 1 << 4,
   LoadFpu        = 1 << 5,
   LoadReversed   = 1 << 6,
};

template<typename SrcType, int Flags>
bool lxx(State *state, Instruction instr)
{
   ppc::reg_t ea;
   SrcType value;

   if (Flags & LoadIndexed) {
      ea = gpr(instr.rB);
   } else if (Flags & LoadDS) {
      ea = little_endian::signExtend<16>(static_cast<uint64_t>(instr.ds) << 2);
   } else {
      ea = little_endian::signExtend<16, uint64_t>(instr.d);
   }

   if (Flags & LoadUpdate) {
      ea += gpr(instr.rA);
      gpr(instr.rA) = ea;
   } else {
      ea += gpr0(instr.rA);
   }

   #pragma warning(suppress: 4244)
   value = Memory::read<SrcType>(ea);

   if (Flags & LoadReversed) {
      value = byte_swap(value);
   }

   if (Flags & LoadFpu) {
      fpr(instr.frD) = static_cast<ppc::freg_t>(value);
   } else {
      if (Flags & LoadSignExtend) {
         gpr(instr.rD) = little_endian::signExtend<sizeof(SrcType)* 8, ppc::reg_t>(value);
      } else {
         gpr(instr.rD) = value;
      }
   }

   return true;
}

/* Load Byte Zero Extend */
bool lbz(State *state, Instruction instr)
{
   return lxx<uint8_t, LoadZeroExtend>(state, instr);
}

/* Load Byte Zero Extend with Update */
bool lbzu(State *state, Instruction instr)
{
   return lxx<uint8_t, LoadZeroExtend | LoadUpdate>(state, instr);
}

/* Load Byte Zero Extend with Update Indexed */
bool lbzux(State *state, Instruction instr)
{
   return lxx<uint8_t, LoadZeroExtend | LoadUpdate | LoadIndexed>(state, instr);
}

/* Load Byte Zero Extend Indexed */
bool lbzx(State *state, Instruction instr)
{
   return lxx<uint8_t, LoadZeroExtend | LoadIndexed>(state, instr);
}

/* Load Doubleword */
bool ld(State *state, Instruction instr)
{
   return lxx<uint64_t, LoadDS>(state, instr);
}

/* Load Doubleword and Reserve Indexed */
bool ldarx(State *state, Instruction instr)
{
   auto ea = gpr0(instr.rA) + gpr(instr.rB);
   state->reg.reserve = 1;
   state->reg.reserveAddress = ea;

   if (ea & 0x7) {
      return raise(state, ppc::Exceptions::Alignment);
   }

   return lxx<uint64_t, LoadZeroExtend | LoadIndexed>(state, instr);
}

/* Load Double with Update */
bool ldu(State *state, Instruction instr)
{
   return lxx<uint64_t, LoadDS | LoadUpdate>(state, instr);
}

/* Load Double with Update Indexed */
bool ldux(State *state, Instruction instr)
{
   return lxx<uint64_t, LoadUpdate | LoadIndexed>(state, instr);
}

/* Load Double Indexed */
bool ldx(State *state, Instruction instr)
{
   return lxx<uint64_t, LoadIndexed>(state, instr);
}

/* Load Floating-Point Double */
bool lfd(State *state, Instruction instr)
{
   return lxx<double, LoadFpu>(state, instr);
}

/* Load Floating-Point Double with Update */
bool lfdu(State *state, Instruction instr)
{
   return lxx<double, LoadFpu | LoadUpdate>(state, instr);
}

/* Load Floating-Point Double with Update Indexed */
bool lfdux(State *state, Instruction instr)
{
   return lxx<double, LoadFpu | LoadUpdate | LoadIndexed>(state, instr);
}

/* Load Floating-Point Double Indexed */
bool lfdx(State *state, Instruction instr)
{
   return lxx<double, LoadFpu | LoadIndexed>(state, instr);
}

/* Load Floating-Point Single */
bool lfs(State *state, Instruction instr)
{
   return lxx<float, LoadFpu>(state, instr);
}

/* Load Floating-Point Single with Update */
bool lfsu(State *state, Instruction instr)
{
   return lxx<float, LoadFpu | LoadUpdate>(state, instr);
}

/* Load Floating-Point Single with Update Indexed */
bool lfsux(State *state, Instruction instr)
{
   return lxx<float, LoadFpu | LoadUpdate | LoadIndexed>(state, instr);
}

/* Load Floating-Point Single Indexed */
bool lfsx(State *state, Instruction instr)
{
   return lxx<float, LoadFpu | LoadIndexed>(state, instr);
}

/* Load Halfword Algebraic */
bool lha(State *state, Instruction instr)
{
   return lxx<uint16_t, LoadSignExtend>(state, instr);
}

/* Load Halfword Algebraic with Update */
bool lhau(State *state, Instruction instr)
{
   return lxx<uint16_t, LoadSignExtend | LoadUpdate>(state, instr);
}

/* Load Halfword Algebraic with Update Indexed */
bool lhaux(State *state, Instruction instr)
{
   return lxx<uint16_t, LoadSignExtend | LoadUpdate | LoadIndexed>(state, instr);
}

/* Load Halfword Algebraic Indexed */
bool lhax(State *state, Instruction instr)
{
   return lxx<uint16_t, LoadSignExtend | LoadIndexed>(state, instr);
}

/* Load Halfword Byte-Reverse indexed */
bool lhbrx(State *state, Instruction instr)
{
   return lxx<uint16_t, LoadZeroExtend | LoadReversed | LoadIndexed>(state, instr);
}

/* Load Halfword Zero Extend */
bool lhz(State *state, Instruction instr)
{
   return lxx<uint16_t, LoadZeroExtend>(state, instr);
}

/* Load Halfword Zero Extend with Update */
bool lhzu(State *state, Instruction instr)
{
   return lxx<uint16_t, LoadZeroExtend | LoadUpdate>(state, instr);
}

/* Load Halfword Zero Extend with Update Indexed */
bool lhzux(State *state, Instruction instr)
{
   return lxx<uint16_t, LoadZeroExtend | LoadUpdate | LoadIndexed>(state, instr);
}

/* Load Halfword Zero Extend Indexed */
bool lhzx(State *state, Instruction instr)
{
   return lxx<uint16_t, LoadZeroExtend | LoadIndexed>(state, instr);
}

/* Load Multiple Word */
bool lmw(State *state, Instruction instr)
{
   auto ea = gpr0(instr.rA) + little_endian::signExtend<16, uint64_t>(instr.d);

   if (ea & 0x3) {
      raise(state, ppc::Exceptions::Alignment);
      return true;
   }

   for (auto i = instr.rD; i <= 31; ++i) {
      gpr(i) = Memory::read<uint32_t>(ea);
      ea += 4;
   }

   return true;
}

/* Load String Word x */
bool lsw(State *state, Instruction instr, uint64_t ea, uint64_t n)
{
   auto r = instr.rD - 1;
   auto i = 32;

   while (n > 0) {
      if (i == 32) {
         r = (r + 1) % 32;
         gpr(r) = 0;
      }

      gpr(r) |= Memory::read<uint8_t>(ea) << (24 - i);
      i += 8;

      if (i == 64) {
         i = 32;
      }

      ea++;
      n--;
   }

   return true;
}

/* Load String Word Immediate */
bool lswi(State *state, Instruction instr)
{
   return lsw(state,
              instr,
              gpr0(instr.rA),
              instr.nb == 0 ? 32 : instr.nb);
}

/* Load String Word Indexed */
bool lswx(State *state, Instruction instr)
{
   return lsw(state,
              instr,
              gpr0(instr.rA) + gpr(instr.rB),
              state->reg.xer.byteCount);
}

/* Load Word Algebraic */
bool lwa(State *state, Instruction instr)
{
   return lxx<uint32_t, LoadSignExtend>(state, instr);
}

/* Load Word and Reserve Indexed */
bool lwarx(State *state, Instruction instr)
{
   auto ea = gpr0(instr.rA) + gpr(instr.rB);
   state->reg.reserve = 1;
   state->reg.reserveAddress = ea;

   return lxx<uint32_t, LoadZeroExtend | LoadIndexed>(state, instr);
}

/* Load Word Algebraic with Update */
bool lwau(State *state, Instruction instr)
{
   return lxx<uint32_t, LoadSignExtend | LoadUpdate>(state, instr);
}

/* Load Word Algebraic with Update Indexed */
bool lwaux(State *state, Instruction instr)
{
   return lxx<uint32_t, LoadSignExtend | LoadUpdate | LoadIndexed>(state, instr);
}

/* Load Word Algebraic Indexed */
bool lwax(State *state, Instruction instr)
{
   return lxx<uint32_t, LoadSignExtend | LoadIndexed>(state, instr);
}

/* Load Word Byte-Reverse Indexed */
bool lwbrx(State *state, Instruction instr)
{
   return lxx<uint32_t, LoadZeroExtend | LoadReversed | LoadIndexed>(state, instr);
}

/* Load Word Zero Extend */
bool lwz(State *state, Instruction instr)
{
   return lxx<uint32_t, LoadZeroExtend>(state, instr);
}

/* Load Word Zero Extend with Update */
bool lwzu(State *state, Instruction instr)
{
   return lxx<uint32_t, LoadZeroExtend | LoadUpdate>(state, instr);
}

/* Load Word Zero Extend with Update Indexed */
bool lwzux(State *state, Instruction instr)
{
   return lxx<uint32_t, LoadZeroExtend | LoadUpdate | LoadIndexed>(state, instr);
}

/* Load Word Zero Extend Indexed */
bool lwzx(State *state, Instruction instr)
{
   return lxx<uint32_t, LoadZeroExtend | LoadIndexed>(state, instr);
}

} // namespace Interpreter

} // namespace ppc

```

`src/powerpc/interpreter/mmu.cpp`:

```cpp
#include "interpreter.h"
#include "regs.h"

#include "powerpc/instructions.h"

#include "common/log.h"
#include "common/memory.h"

#include <limits>

namespace ppc
{

namespace Interpreter
{

/* Data Cache Block Flush */
bool dcbf(State *state, Instruction instr)
{
   auto ea = gpr0(instr.rA) + gpr(instr.rB);
   /* TODO: dcbf Data Cache Block Flush */
   return false;
}

/* Data Cache Block Store */
bool dcbst(State *state, Instruction instr)
{
   auto ea = gpr0(instr.rA) + gpr(instr.rB);
   /* TODO: dcbst Data Cache Block Store */
   return false;
}

/* Data Cache Block Touch */
bool dcbt(State *state, Instruction instr)
{
   auto ea = gpr0(instr.rA) + gpr(instr.rB);
   /* TODO: dcbt Data Cache Block Touch */
   return false;
}

/* Data Cache Block Touch for Store */
bool dcbtst(State *state, Instruction instr)
{
   auto ea = gpr0(instr.rA) + gpr(instr.rB);
   /* TODO: dcbtst Data Cache Block Touch for Store */
   return false;
}

/* Data Cache Block Zero */
bool dcbz(State *state, Instruction instr)
{
   auto ea = gpr0(instr.rA) + gpr(instr.rB);
   auto n = 32; /* TODO: dcbz block size */
   Memory::zero(ea & ~(n -1), n);
   return false;
}

/* External Control In Word Indexed */
bool eciwx(State *state, Instruction instr)
{
   auto ea = gpr0(instr.rA) + gpr(instr.rB);

   /* TODO: eciwx Load from physical address ea of device EAR[RID] */

   if ((state->reg.ear & 0x80000000) == 0) {
      raise(state, ppc::Exceptions::DSI);
   }

   if (ea & 0x3) {
      raise(state, ppc::Exceptions::Alignment);
   }

   return false;
}

/* External Control Out Word Indexed */
bool ecowx(State *state, Instruction instr)
{
   auto ea = gpr0(instr.rA) + gpr(instr.rB);

   /* TODO: ecowx Store to physical address ea of device EAR[RID] */

   if ((state->reg.ear & 0x80000000) == 0) {
      raise(state, ppc::Exceptions::DSI);
   }

   if (ea & 0x3) {
      raise(state, ppc::Exceptions::Alignment);
   }

   return true;
}

/* Enforice In-Order Execution of I/O */
bool eieio(State *state, Instruction instr)
{
   _mm_mfence();
   return true;
}

/* Instruction Cache Block Invalidate */
bool icbi(State *state, Instruction instr)
{
   /* Invalidates instruction cache
    * not needed for interpreter, only for JIT
    */
   auto ea = gpr0(instr.rA) + gpr(instr.rB);
   return true;
}

/* Instruction Synchronize */
bool isync(State *state, Instruction instr)
{
   /* Should be an instruction execution fence, not memory fence */
   _mm_mfence();
   return true;
}

/* Segment Register bitfield */
union RegSr
{
   ppc::reg_t value;

   struct
   {
      ppc::reg_t : 33;
      ppc::reg_t Ks : 1;
      ppc::reg_t Kp : 1;
      ppc::reg_t N : 1;
      ppc::reg_t L : 1;
      ppc::reg_t vsid_up : 27;
   };
};

/* Move from Segment Register x */
bool mfsrx(State *state, Instruction instr, int index)
{
   if (index > state->reg.slb.size()) {
      raise(state, ppc::Exceptions::ProgramIllegalInstruction);
      return true;
   }

   RegSr sr = { 0 };
   auto &entry = state->reg.slb[index];

   sr.vsid_up = static_cast<uint64_t>(entry.vsid) >> 25;
   sr.Ks = entry.Ks;
   sr.Kp = entry.Kp;
   sr.N = entry.N;
   sr.L = entry.L;
   gpr(instr.rD) = sr.value;

   return true;
}

/* Move from Segment Register */
bool mfsr(State *state, Instruction instr)
{
   return mfsrx(state, instr, instr.sr);
}

/* Move from Segment Register Indirect */
bool mfsrin(State *state, Instruction instr)
{
   return mfsrx(state, instr, (gpr(instr.rB) >> 32) & 0xf);
}

/* Move to Segment Register x */
bool mtsrx(State *state, Instruction instr, int index)
{
   if (index > state->reg.slb.size()) {
      raise(state, ppc::Exceptions::ProgramIllegalInstruction);
      return true;
   }

   RegSr sr = { gpr(instr.rS) };
   auto &entry = state->reg.slb[index];

   entry.valid = 1;
   entry.esid = static_cast<uint64_t>(index) << 32;
   entry.vsid = static_cast<uint64_t>(sr.vsid_up) << 25;
   entry.Ks = sr.Ks;
   entry.Kp = sr.Kp;
   entry.N = sr.N;
   entry.L = sr.L;
   entry.C = 0;

   return true;
}

/* Move to Segment Register */
bool mtsr(State *state, Instruction instr)
{
   return mtsrx(state, instr, instr.sr);
}

/* Move to Segment Register Indirect */
bool mtsrin(State *state, Instruction instr)
{
   return mtsrx(state, instr, (gpr(instr.rB) >> 32) & 0xf);
}

/* SLB VSID Register bitfield */
union RegVsid
{
   ppc::reg_t value;

   struct
   {
      ppc::reg_t vsid : 52;
      ppc::reg_t Ks : 1;
      ppc::reg_t Kp : 1;
      ppc::reg_t N : 1;
      ppc::reg_t L : 1;
      ppc::reg_t C : 1;
      ppc::reg_t : 7;
   };
};

/* SLB ESID Register bitfield */
union RegEsid
{
   ppc::reg_t value;

   struct
   {
      ppc::reg_t esid : 36;
      ppc::reg_t valid : 1;
      ppc::reg_t : 15;
      ppc::reg_t index : 12;
   };
};

/* SLB Invalidate All */
bool slbia(State *state, Instruction instr)
{
   for (auto &entry : state->reg.slb) {
      entry.valid = 0;
   }

   return true;
}

/* SLB Invalidate Entry */
bool slbie(State *state, Instruction instr)
{
   auto esid = (gpr(instr.rA) >> 28) & little_endian::make_bit_mask<ppc::reg_t, 36>();
   auto cls = (gpr(instr.rA) >> 27) & 1;

   for (auto &entry : state->reg.slb) {
      if (entry.valid && entry.esid == esid && entry.C == cls) {
         entry.valid = 0;
      }
   }

   return true;
}

/* SLB Move From Entry ESID */
bool slbmfee(State *state, Instruction instr)
{
   auto idx = gpr(instr.rB) & little_endian::make_bit_mask<ppc::reg_t, 12>();

   if (idx > state->reg.slb.size()) {
      raise(state, ppc::Exceptions::ProgramIllegalInstruction);
      return true;
   }

   auto &entry = state->reg.slb[idx];
   RegEsid d = { 0 };

   d.valid = entry.valid;
   d.esid = entry.esid;

   gpr(instr.rD) = d.value;

   return true;
}

/* SLB Move From Entry VSID */
bool slbmfev(State *state, Instruction instr)
{
   auto idx = gpr(instr.rB) & little_endian::make_bit_mask<ppc::reg_t, 12>();

   if (idx > state->reg.slb.size()) {
      raise(state, ppc::Exceptions::ProgramIllegalInstruction);
      return true;
   }

   auto &entry = state->reg.slb[idx];
   RegVsid d = { 0 };

   d.vsid = entry.vsid;
   d.Ks = entry.Ks;
   d.Kp = entry.Kp;
   d.N = entry.N;
   d.L = entry.L;
   d.C = entry.C;

   gpr(instr.rD) = d.value;

   return true;
}

/* SLB Move to Entry */
bool slbmte(State *state, Instruction instr)
{
   RegEsid b = { gpr(instr.rB) };
   RegVsid d = { gpr(instr.rD) };

   if (b.index > state->reg.slb.size()) {
      raise(state, ppc::Exceptions::ProgramIllegalInstruction);
      return true;
   }

   auto &entry = state->reg.slb[b.index];

   entry.valid = b.valid;
   entry.esid = b.esid;
   entry.vsid = d.vsid;
   entry.Ks = d.Ks;
   entry.Kp = d.Kp;
   entry.N = d.N;
   entry.L = d.L;
   entry.C = d.C;

   gpr(instr.rD) = d.value;

   return true;
}

/* Synchronize */
bool sync(State *state, Instruction instr)
{
   switch (instr.syncl) {
   case 0: /* Heavyweight Sync */
      break;
   case 1: /* Lightweight Sync */
      break;
   case 2: /* ptesync */
      break;
   case 3: /* reserved */
      break;
   }

   _mm_mfence();
   return true;
}

UNIMPLEMENTED(tlbia);    /* Translation Lookaside Buffer Invalidate All */
UNIMPLEMENTED(tlbie);    /* Translation Lookaside Buffer Invalidate Entry */
UNIMPLEMENTED(tlbiel);   /* Translation Lookaside Buffer Invalidate Entry Local */
UNIMPLEMENTED(tlbsync);  /* Translation Lookaside Buffer Synchronize */

} // namespace Interpreter

} // namespace ppc

```

`src/powerpc/interpreter/regs.h`:

```h
#ifndef REGS_H
#define REGS_H

namespace ppc 
{

namespace Interpreter
{

#define UNIMPLEMENTED(insName) \
   bool insName(State *state, Instruction) { \
      xDebug() << "Unimplemented interpreter instruction "#insName; \
      return false; \
   }

#define gpr(r) state->reg.gpr[r]
#define gpr0(r) (r == 0 ? 0 : state->reg.gpr[r])
#define gprs(r) reinterpret<int64_t>(state->reg.gpr[r])
#define gprw(r) reinterpret<uint32_t>(state->reg.gpr[r])
#define gprsw(r) reinterpret<int32_t>(state->reg.gpr[r])

#define fpr(r) state->reg.fpr[r]
#define fpscr(n) state->reg.fpscr.crn[n]

#define crf(n) state->reg.cr.crn[n]
#define crb(n) state->reg.cr.crb[n]

template<typename DstType, typename SrcType>
static inline DstType& reinterpret(SrcType& value)
{
   return *reinterpret_cast<DstType*>(&value);
}

} // namespace Interpreter

} // namespace ppc 

#endif // REGS_H

```

`src/powerpc/interpreter/store.cpp`:

```cpp
#include "interpreter.h"
#include "regs.h"

#include "powerpc/instructions.h"

#include "common/log.h"
#include "common/memory.h"
#include "common/byte_swap.h"

#include <limits>

namespace ppc 
{

namespace Interpreter
{

/* Store x */
enum StoreFlags {
   StoreDefault     = 0,
   StoreIndexed     = 1 << 0,
   StoreUpdate      = 1 << 1,
   StoreDS          = 1 << 2,
   StoreDirect      = 1 << 3,
   StoreReversed    = 1 << 4,
   StoreConditional = 1 << 5,
};

template<typename DstType, int Flags>
bool stxx(State *state, Instruction instr)
{
   ppc::reg_t ea;
   DstType value;

   if (Flags & StoreDS) {
      ea = little_endian::signExtend<16>(static_cast<uint64_t>(instr.ds) << 2);
   } else if (Flags & StoreIndexed) {
      ea = gpr(instr.rB);
   } else {
      ea = little_endian::signExtend<16, uint64_t>(instr.d);
   }

   if (Flags & StoreUpdate) {
      ea += gpr(instr.rA);
   } else {
      ea += gpr0(instr.rA);
   }

   if (Flags & StoreConditional) {
      state->reg.cr.cr0 = 0;

      if (state->reg.reserve && state->reg.reserveAddress == ea) {
         state->reg.cr.cr0 = ppc::Cr::Zero;
         state->reg.reserve = 0;
      }

      if (state->reg.xer.so) {
         state->reg.cr.cr0 |= ppc::Cr::SummaryOverflow;
      }
      
      if ((state->reg.cr.cr0 & ppc::Cr::Zero) == 0) {
         /* Reservation does not exist */
         return true;
      }
   }

   if (std::numeric_limits<DstType>::is_integer) {
      value = reinterpret<DstType>(gpr(instr.rS));
   } else {
      value = static_cast<DstType>(fpr(instr.frS));
   }

   if (Flags & StoreReversed) {
      value = byte_swap(value);
   }

   Memory::write<DstType>(ea, value);

   if (Flags & StoreUpdate) {
      gpr(instr.rA) = ea;
   }

   return true;
}

/* Store Byte */
bool stb(State *state, Instruction instr)
{
   return stxx<uint8_t, StoreDefault>(state, instr);
}

/* Store Byte with Update */
bool stbu(State *state, Instruction instr)
{
   return stxx<uint8_t, StoreUpdate>(state, instr);
}

/* Store Byte with Update Indexed */
bool stbux(State *state, Instruction instr)
{
   return stxx<uint8_t, StoreUpdate | StoreIndexed>(state, instr);
}

/* Store Byte Indexed */
bool stbx(State *state, Instruction instr)
{
   return stxx<uint8_t, StoreIndexed>(state, instr);
}

/* Store Doubleword */
bool std(State *state, Instruction instr)
{
   return stxx<uint64_t, StoreDS>(state, instr);
}

/* Store Doubleword Conditional Indexed */
bool stdcx(State *state, Instruction instr)
{
   return stxx<uint64_t, StoreConditional | StoreIndexed>(state, instr);
}

/* Store Doubleword with Update */
bool stdu(State *state, Instruction instr)
{
   return stxx<uint64_t, StoreDS | StoreUpdate>(state, instr);
}

/* Store Doubleword with Update Indexed */
bool stdux(State *state, Instruction instr)
{
   return stxx<uint64_t, StoreIndexed | StoreUpdate>(state, instr);
}

/* Store Doubleword Indexed */
bool stdx(State *state, Instruction instr)
{
   return stxx<uint64_t, StoreIndexed>(state, instr);
}

/* Store Floating-Point Double */
bool stfd(State *state, Instruction instr)
{
   return stxx<double, StoreDefault>(state, instr);
}

/* Store Floating-Point Double with Update */
bool stfdu(State *state, Instruction instr)
{
   return stxx<double, StoreUpdate>(state, instr);
}

/* Store Floating-Point Double with Update Indexed */
bool stfdux(State *state, Instruction instr)
{
   return stxx<double, StoreUpdate | StoreIndexed>(state, instr);
}

/* Store Floating-Point Double Indexed */
bool stfdx(State *state, Instruction instr)
{
   return stxx<double, StoreIndexed>(state, instr);
}

/* Store Floating-Point as Integer Word Single */
bool stfiwx(State *state, Instruction instr)
{
   return stxx<float, StoreIndexed | StoreDirect>(state, instr);
}

/* Store Floating-Point Single */
bool stfs(State *state, Instruction instr)
{
   return stxx<float, StoreDefault>(state, instr);
}

/* Store Floating-Point Single with Update */
bool stfsu(State *state, Instruction instr)
{
   return stxx<float, StoreUpdate>(state, instr);
}

/* Store Floating-Point Single with Update Indexed */
bool stfsux(State *state, Instruction instr)
{
   return stxx<float, StoreUpdate | StoreIndexed>(state, instr);
}

/* Store Floating-Point Single Indexed */
bool stfsx(State *state, Instruction instr)
{
   return stxx<float, StoreIndexed>(state, instr);
}

/* Store Halfword */
bool sth(State *state, Instruction instr)
{
   return stxx<uint16_t, StoreDefault>(state, instr);
}

/* Store Halfword Byte-Reverse Indexed */
bool sthbrx(State *state, Instruction instr)
{
   return stxx<uint16_t, StoreReversed | StoreIndexed>(state, instr);
}

/* Store Halfword with Update */
bool sthu(State *state, Instruction instr)
{
   return stxx<uint16_t, StoreUpdate>(state, instr);
}

/* Store Halfword with Update Indexed */
bool sthux(State *state, Instruction instr)
{
   return stxx<uint16_t, StoreUpdate | StoreIndexed>(state, instr);
}

/* Store Halfword Indexed */
bool sthx(State *state, Instruction instr)
{
   return stxx<uint16_t, StoreIndexed>(state, instr);
}

/* Store Multiple Word */
bool stmw(State *state, Instruction instr)
{
   auto ea = gpr0(instr.rA) + little_endian::signExtend<16, uint64_t>(instr.d);
   auto r = instr.rS;

   while (r <= 31) {
      Memory::write(ea, gprw(r));
      r  += 1;
      ea += 4;
   }

   return true;
}

/* Store String Word x */
bool stsw(State *state, Instruction instr, ptr32_t<uint8_t> ea, uint64_t n)
{
   auto r = instr.rS - 1;
   auto i = 32;

   while (n > 0) {
      if (i == 32) {
         r = (r + 1) % 32;
      }

      *ea = (gpr(r) >> (24 - i)) & 0xFF;

      i += 8;

      if (i == 64) {
         i = 32;
      }

      ea++;
      n--;
   }

   return true;
}

/* Store String Word Immediate */
bool stswi(State *state, Instruction instr)
{
   return stsw(state,
               instr,
               reinterpret_cast<uint8_t*>(gpr0(instr.rA)),
               instr.nb == 0 ? 32 : instr.nb);
}

/* Store String Word Indexed */
bool stswx(State *state, Instruction instr)
{
   return stsw(state,
               instr,
               reinterpret_cast<uint8_t*>(gpr0(instr.rA) + gpr(instr.rB)),
               state->reg.xer.byteCount);
}

/* Store Word */
bool stw(State *state, Instruction instr)
{
   return stxx<uint32_t, StoreDefault>(state, instr);
}

/* Store Word Byte-Reverse Indexed */
bool stwbrx(State *state, Instruction instr)
{
   return stxx<uint32_t, StoreReversed | StoreIndexed>(state, instr);
}

/* Store Word Conditional Indexed */
bool stwcx(State *state, Instruction instr)
{
   return stxx<uint32_t, StoreConditional | StoreIndexed>(state, instr);
}

/* Store Word with Update */
bool stwu(State *state, Instruction instr)
{
   return stxx<uint32_t, StoreUpdate>(state, instr);
}

/* Store Word with Update Indexed */
bool stwux(State *state, Instruction instr)
{
   return stxx<uint32_t, StoreUpdate | StoreIndexed>(state, instr);
}

/* Store Word Indexed */
bool stwx(State *state, Instruction instr)
{
   return stxx<uint32_t, StoreIndexed>(state, instr);
}

} // namespace Interpreter

} // namespace ppc

```

`src/powerpc/translator/alu.cpp`:

```cpp
#include "translator.h"

namespace ppc
{

namespace Translator
{

bool setConditionRegister0(State *state, exjit::Value *value)
{
}

/* Add */
bool add(State *state, Instruction instr)
{
   auto lhs = state->gpr(instr.rA);
   auto rhs = state->gpr(instr.rB);

   auto res = state->builder.createAdd(lhs, rhs);

   state->setGpr(instr.rD, res);

   if (instr.rc) {
      setConditionRegister0(state, res);
   }

   return true;
}

} // namespace Interpreter

} // namespace ppc

```

`src/powerpc/translator/stubs.cpp`:

```cpp
#include "translator.h"

namespace ppc
{

namespace Translator
{

/* Add Carrying */
bool addc(State *state, Instruction instr)
{
   return false;
}

/* Add Extended */
bool adde(State *state, Instruction instr)
{
   return false;
}

/* Add Immediate */
bool addi(State *state, Instruction instr)
{
   return false;
}

/* Add Immediate Carrying */
bool addic(State *state, Instruction instr)
{
   return false;
}

/* Add Immediate Carrying and Record */
bool addico(State *state, Instruction instr)
{
   return false;
}

/* Add Immediate Shifted */
bool addis(State *state, Instruction instr)
{
   return false;
}

/* Add to Minus One Extended */
bool addme(State *state, Instruction instr)
{
   return false;
}

/* Add to Zero Extended */
bool addze(State *state, Instruction instr)
{
   return false;
}

/* AND */
bool and(State *state, Instruction instr)
{
   return false;
}

/* AND with Complement */
bool andc(State *state, Instruction instr)
{
   return false;
}

/* AND Immediate */
bool andio(State *state, Instruction instr)
{
   return false;
}

/* AND Immediate Shifted */
bool andiso(State *state, Instruction instr)
{
   return false;
}

/* Branch */
bool b(State *state, Instruction instr)
{
   return false;
}

/* Branch Conditional */
bool bc(State *state, Instruction instr)
{
   return false;
}

/* Branch Conditional to Count Register */
bool bcctr(State *state, Instruction instr)
{
   return false;
}

/* Branch Conditional to Link Register */
bool bclr(State *state, Instruction instr)
{
   return false;
}

/* Compare */
bool cmp(State *state, Instruction instr)
{
   return false;
}

/* Compare Immediate */
bool cmpi(State *state, Instruction instr)
{
   return false;
}

/* Compare Logical */
bool cmpl(State *state, Instruction instr)
{
   return false;
}

/* Compare Logical Immediate */
bool cmpli(State *state, Instruction instr)
{
   return false;
}

/* Count Leading Zeros Doubleword */
bool cntlzd(State *state, Instruction instr)
{
   return false;
}

/* Count Leading Zeros Word */
bool cntlzw(State *state, Instruction instr)
{
   return false;
}

/* Condition Register AND */
bool crand(State *state, Instruction instr)
{
   return false;
}

/* Condition Register AND with Complement */
bool crandc(State *state, Instruction instr)
{
   return false;
}

/* Condition Register Equivalent */
bool creqv(State *state, Instruction instr)
{
   return false;
}

/* Condition Register NAND */
bool crnand(State *state, Instruction instr)
{
   return false;
}

/* Condition Register NOR */
bool crnor(State *state, Instruction instr)
{
   return false;
}

/* Condition Register OR */
bool cror(State *state, Instruction instr)
{
   return false;
}

/* Condition Register OR with Complement */
bool crorc(State *state, Instruction instr)
{
   return false;
}

/* Condition Register XOR */
bool crxor(State *state, Instruction instr)
{
   return false;
}

/* Data Cache Block Flush */
bool dcbf(State *state, Instruction instr)
{
   return false;
}

/* Data Cache Block Store */
bool dcbst(State *state, Instruction instr)
{
   return false;
}

/* Data Cache Block Touch */
bool dcbt(State *state, Instruction instr)
{
   return false;
}

/* Data Cache Block Touch for Store */
bool dcbtst(State *state, Instruction instr)
{
   return false;
}

/* Data Cache Clear to Zero */
bool dcbz(State *state, Instruction instr)
{
   return false;
}

/* Divide Doubleword */
bool divd(State *state, Instruction instr)
{
   return false;
}

/* Divide Doubleword Unsigned */
bool divdu(State *state, Instruction instr)
{
   return false;
}

/* Divide Word */
bool divw(State *state, Instruction instr)
{
   return false;
}

/* Divide Word Unsigned */
bool divwu(State *state, Instruction instr)
{
   return false;
}

/* External Control In Word Indexed */
bool eciwx(State *state, Instruction instr)
{
   return false;
}

/* External Control Out Word Indexed */
bool ecowx(State *state, Instruction instr)
{
   return false;
}

/* Enforce In-Order Execution of I/O */
bool eieio(State *state, Instruction instr)
{
   return false;
}

/* Equivalent */
bool eqv(State *state, Instruction instr)
{
   return false;
}

/* Extend Sign Byte */
bool extsb(State *state, Instruction instr)
{
   return false;
}

/* Extend Sign Halfword */
bool extsh(State *state, Instruction instr)
{
   return false;
}

/* Extend Sign Word */
bool extsw(State *state, Instruction instr)
{
   return false;
}

/* Floating Absolute Value */
bool fabs(State *state, Instruction instr)
{
   return false;
}

/* Floating Add (Double-Precision) */
bool fadd(State *state, Instruction instr)
{
   return false;
}

/* Floating Add Single */
bool fadds(State *state, Instruction instr)
{
   return false;
}

/* Floating Convert from Integer Doubleword */
bool fcfid(State *state, Instruction instr)
{
   return false;
}

/* Floating Compare Ordered */
bool fcmpo(State *state, Instruction instr)
{
   return false;
}

/* Floating Compare Unordered */
bool fcmpu(State *state, Instruction instr)
{
   return false;
}

/* Floating Convert to Integer Doubleword */
bool fctid(State *state, Instruction instr)
{
   return false;
}

/* Floating Convert to Integer Doubleword with round toward Zero */
bool fctidz(State *state, Instruction instr)
{
   return false;
}

/* Floating Convert to Integer Word */
bool fctiw(State *state, Instruction instr)
{
   return false;
}

/* Floating Convert to Integer Word with round toward Zero */
bool fctiwz(State *state, Instruction instr)
{
   return false;
}

/* Floating Divide (Double-Precision) */
bool fdiv(State *state, Instruction instr)
{
   return false;
}

/* Floating Divide Single */
bool fdivs(State *state, Instruction instr)
{
   return false;
}

/* Floating Multiply-Add (Double-Precision) */
bool fmadd(State *state, Instruction instr)
{
   return false;
}

/* Floating Multiply-Add Single */
bool fmadds(State *state, Instruction instr)
{
   return false;
}

/* Floating Move Register (Double-Precision) */
bool fmr(State *state, Instruction instr)
{
   return false;
}

/* Floating Multiply-Subtract (Double-Precision) */
bool fmsub(State *state, Instruction instr)
{
   return false;
}

/* Floating Multiply-Subtract Single */
bool fmsubs(State *state, Instruction instr)
{
   return false;
}

/* Floating Multiply (Double-Precision) */
bool fmul(State *state, Instruction instr)
{
   return false;
}

/* Floating Multiply Single */
bool fmuls(State *state, Instruction instr)
{
   return false;
}

/* Floating Negative Absolute Value */
bool fnabs(State *state, Instruction instr)
{
   return false;
}

/* Floating Negate */
bool fneg(State *state, Instruction instr)
{
   return false;
}

/* Floating Negative Multiply-Add (Double-Precision) */
bool fnmadd(State *state, Instruction instr)
{
   return false;
}

/* Floating Negative Multiply-Add Single */
bool fnmadds(State *state, Instruction instr)
{
   return false;
}

/* Floating Negative Multiply-Subtract (Double-Precision) */
bool fnmsub(State *state, Instruction instr)
{
   return false;
}

/* Floating Negative Multiply-Subtract Single */
bool fnmsubs(State *state, Instruction instr)
{
   return false;
}

/* Floating Reciprocal Estimate Single */
bool fres(State *state, Instruction instr)
{
   return false;
}

/* Floating Round to Single */
bool frsp(State *state, Instruction instr)
{
   return false;
}

/* Floating Reciprocal Square Root Estimate */
bool frsqrte(State *state, Instruction instr)
{
   return false;
}

/* Floating Select */
bool fsel(State *state, Instruction instr)
{
   return false;
}

/* Floating Square Root (Double-Precision) */
bool fsqrt(State *state, Instruction instr)
{
   return false;
}

/* Floating Square Root Single */
bool fsqrts(State *state, Instruction instr)
{
   return false;
}

/* Floating Subtract (Double-Precision) */
bool fsub(State *state, Instruction instr)
{
   return false;
}

/* Floating Subtract Single */
bool fsubs(State *state, Instruction instr)
{
   return false;
}

/* Instruction Cache Block Invalidate */
bool icbi(State *state, Instruction instr)
{
   return false;
}

/* Instruction Synchronize */
bool isync(State *state, Instruction instr)
{
   return false;
}

/* Kernel Function Call */
bool krncall(State *state, Instruction instr)
{
   return false;
}

/* Load Byte and Zero */
bool lbz(State *state, Instruction instr)
{
   return false;
}

/* Load Byte and Zero with Update */
bool lbzu(State *state, Instruction instr)
{
   return false;
}

/* Load Byte and Zero with Update Indexed */
bool lbzux(State *state, Instruction instr)
{
   return false;
}

/* Load Byte and Zero Indexed */
bool lbzx(State *state, Instruction instr)
{
   return false;
}

/* Load Doubleword */
bool ld(State *state, Instruction instr)
{
   return false;
}

/* Load Doubleword and Reserve Indexed */
bool ldarx(State *state, Instruction instr)
{
   return false;
}

/* Load Doubleword with Update */
bool ldu(State *state, Instruction instr)
{
   return false;
}

/* Load Doubleword with Update Indexed */
bool ldux(State *state, Instruction instr)
{
   return false;
}

/* Load Doubleword Indexed */
bool ldx(State *state, Instruction instr)
{
   return false;
}

/* Load Floating-Point Double */
bool lfd(State *state, Instruction instr)
{
   return false;
}

/* Load Floating-Point Double with Update */
bool lfdu(State *state, Instruction instr)
{
   return false;
}

/* Load Floating-Point Double with Update Indexed */
bool lfdux(State *state, Instruction instr)
{
   return false;
}

/* Load Floating-Point Double Indexed */
bool lfdx(State *state, Instruction instr)
{
   return false;
}

/* Load Floating-Point Single */
bool lfs(State *state, Instruction instr)
{
   return false;
}

/* Load Floating-Point Single with Update */
bool lfsu(State *state, Instruction instr)
{
   return false;
}

/* Load Floating-Point Single with Update Indexed */
bool lfsux(State *state, Instruction instr)
{
   return false;
}

/* Load Floating-Point Single Indexed */
bool lfsx(State *state, Instruction instr)
{
   return false;
}

/* Load Halfword Algebraic */
bool lha(State *state, Instruction instr)
{
   return false;
}

/* Load Halfword Algebraic with Update */
bool lhau(State *state, Instruction instr)
{
   return false;
}

/* Load Halfword Algebraic with Update Indexed */
bool lhaux(State *state, Instruction instr)
{
   return false;
}

/* Load Halfword Algebraic Indexed */
bool lhax(State *state, Instruction instr)
{
   return false;
}

/* Load Halfword Byte-Reverse Indexed */
bool lhbrx(State *state, Instruction instr)
{
   return false;
}

/* Load Halfword and Zero */
bool lhz(State *state, Instruction instr)
{
   return false;
}

/* Load Halfword and Zero with Update */
bool lhzu(State *state, Instruction instr)
{
   return false;
}

/* Load Halfword and Zero with Update Indexed */
bool lhzux(State *state, Instruction instr)
{
   return false;
}

/* Load Halfword and Zero Indexed */
bool lhzx(State *state, Instruction instr)
{
   return false;
}

/* Load Multiple Word */
bool lmw(State *state, Instruction instr)
{
   return false;
}

/* Load String Word Immediate */
bool lswi(State *state, Instruction instr)
{
   return false;
}

/* Load String Word Indexed */
bool lswx(State *state, Instruction instr)
{
   return false;
}

/* Load Word Algebraic */
bool lwa(State *state, Instruction instr)
{
   return false;
}

/* Load Word and Reserve Indexed */
bool lwarx(State *state, Instruction instr)
{
   return false;
}

/* Load Word Algebraic with Update Indexed */
bool lwaux(State *state, Instruction instr)
{
   return false;
}

/* Load Word Algebraic Indexed */
bool lwax(State *state, Instruction instr)
{
   return false;
}

/* Load Word Byte-Reverse Indexed */
bool lwbrx(State *state, Instruction instr)
{
   return false;
}

/* Load Word and Zero */
bool lwz(State *state, Instruction instr)
{
   return false;
}

/* Load Word and Zero with Update */
bool lwzu(State *state, Instruction instr)
{
   return false;
}

/* Load Word and Zero with Update Indexed */
bool lwzux(State *state, Instruction instr)
{
   return false;
}

/* Load Word and Zero Indexed */
bool lwzx(State *state, Instruction instr)
{
   return false;
}

/* Move Condition Register Field */
bool mcrf(State *state, Instruction instr)
{
   return false;
}

/* Move to Condition Register from FPSCR */
bool mcrfs(State *state, Instruction instr)
{
   return false;
}

/* Move from Condition Register */
bool mfcr(State *state, Instruction instr)
{
   return false;
}

/* Move from FPSCR */
bool mffs(State *state, Instruction instr)
{
   return false;
}

/* Move from Machine State Register */
bool mfmsr(State *state, Instruction instr)
{
   return false;
}

/* Move from One Condition Register Field */
bool mfocrf(State *state, Instruction instr)
{
   return false;
}

/* Move from Special-Purpose Register */
bool mfspr(State *state, Instruction instr)
{
   return false;
}

/* Move from Segment Register */
bool mfsr(State *state, Instruction instr)
{
   return false;
}

/* Move from Segment Register Indirect */
bool mfsrin(State *state, Instruction instr)
{
   return false;
}

/* Move from Time Base */
bool mftb(State *state, Instruction instr)
{
   return false;
}

/* Move to Condition Register Fields */
bool mtcrf(State *state, Instruction instr)
{
   return false;
}

/* Move to FPSCR Bit 0 */
bool mtfsb0(State *state, Instruction instr)
{
   return false;
}

/* Move to FPSCR Bit 1 */
bool mtfsb1(State *state, Instruction instr)
{
   return false;
}

/* Move to FPSCR Fields */
bool mtfsf(State *state, Instruction instr)
{
   return false;
}

/* Move to FPSCR Field Immediate */
bool mtfsfi(State *state, Instruction instr)
{
   return false;
}

/* Move to Machine State Register */
bool mtmsr(State *state, Instruction instr)
{
   return false;
}

/* Move to Machine State Register Doubleword */
bool mtmsrd(State *state, Instruction instr)
{
   return false;
}

/* Move to One Condition Register Field */
bool mtocrf(State *state, Instruction instr)
{
   return false;
}

/* Move to Special-Purpose Register */
bool mtspr(State *state, Instruction instr)
{
   return false;
}

/* Move to Segment Register */
bool mtsr(State *state, Instruction instr)
{
   return false;
}

/* Move to Segment Register Indirect */
bool mtsrin(State *state, Instruction instr)
{
   return false;
}

/* Multiply High Doubleword */
bool mulhd(State *state, Instruction instr)
{
   return false;
}

/* Multiply High Doubleword Unsigned */
bool mulhdu(State *state, Instruction instr)
{
   return false;
}

/* Multiply High Word */
bool mulhw(State *state, Instruction instr)
{
   return false;
}

/* Multiply High Word Unsigned */
bool mulhwu(State *state, Instruction instr)
{
   return false;
}

/* Multiply Low Doubleword */
bool mulld(State *state, Instruction instr)
{
   return false;
}

/* Multiply Low Immediate */
bool mulli(State *state, Instruction instr)
{
   return false;
}

/* Multiply Low Word */
bool mullw(State *state, Instruction instr)
{
   return false;
}

/* NAND */
bool nand(State *state, Instruction instr)
{
   return false;
}

/* Negate */
bool neg(State *state, Instruction instr)
{
   return false;
}

/* NOR */
bool nor(State *state, Instruction instr)
{
   return false;
}

/* OR */
bool or(State *state, Instruction instr)
{
   return false;
}

/* OR with Complement */
bool orc(State *state, Instruction instr)
{
   return false;
}

/* OR Immediate */
bool ori(State *state, Instruction instr)
{
   return false;
}

/* OR Immediate Shifted */
bool oris(State *state, Instruction instr)
{
   return false;
}

/* Return from Interrupt Doubleword */
bool rfid(State *state, Instruction instr)
{
   return false;
}

/* Rotate Left Doubleword then Clear Left */
bool rldcl(State *state, Instruction instr)
{
   return false;
}

/* Rotate Left Doubleword then Clear Right */
bool rldcr(State *state, Instruction instr)
{
   return false;
}

/* Rotate Left Doubleword Immediate then Clear */
bool rldic(State *state, Instruction instr)
{
   return false;
}

/* Rotate Left Doubleword Immediate then Clear Left */
bool rldicl(State *state, Instruction instr)
{
   return false;
}

/* Rotate Left Doubleword Immediate then Clear Right */
bool rldicr(State *state, Instruction instr)
{
   return false;
}

/* Rotate Left Word Immediate then Mask Insert */
bool rlwimi(State *state, Instruction instr)
{
   return false;
}

/* Rotate Left Word Immediate then AND with Mask */
bool rlwinm(State *state, Instruction instr)
{
   return false;
}

/* Rotate Left Word then AND with Mask */
bool rlwnm(State *state, Instruction instr)
{
   return false;
}

/* System Call */
bool sc(State *state, Instruction instr)
{
   return false;
}

/* SLB Invalidate All */
bool slbia(State *state, Instruction instr)
{
   return false;
}

/* SLB Invalidate Entry */
bool slbie(State *state, Instruction instr)
{
   return false;
}

/* SLB Move From Entry ESID */
bool slbmfee(State *state, Instruction instr)
{
   return false;
}

/* SLB Move From Entry VSID */
bool slbmfev(State *state, Instruction instr)
{
   return false;
}

/* SLB Move To Entry */
bool slbmte(State *state, Instruction instr)
{
   return false;
}

/* Shift Left Doubleword */
bool sld(State *state, Instruction instr)
{
   return false;
}

/* Shift Left Word */
bool slw(State *state, Instruction instr)
{
   return false;
}

/* Shift Right Algebraic Doubleword */
bool srad(State *state, Instruction instr)
{
   return false;
}

/* Shift Right Algebraic Doubleword Immediate */
bool sradi(State *state, Instruction instr)
{
   return false;
}

/* Shift Right Algebraic Word */
bool sraw(State *state, Instruction instr)
{
   return false;
}

/* Shift Right Algebraic Word Immediate */
bool srawi(State *state, Instruction instr)
{
   return false;
}

/* Shift Right Doubleword */
bool srd(State *state, Instruction instr)
{
   return false;
}

/* Shift Right Word */
bool srw(State *state, Instruction instr)
{
   return false;
}

/* Store Byte */
bool stb(State *state, Instruction instr)
{
   return false;
}

/* Store Byte with Update */
bool stbu(State *state, Instruction instr)
{
   return false;
}

/* Store Byte with Update Indexed */
bool stbux(State *state, Instruction instr)
{
   return false;
}

/* Store Byte Indexed */
bool stbx(State *state, Instruction instr)
{
   return false;
}

/* Store Doubleword */
bool std(State *state, Instruction instr)
{
   return false;
}

/* Store Doubleword Conditional Indexed */
bool stdcx(State *state, Instruction instr)
{
   return false;
}

/* Store Doubleword with Update */
bool stdu(State *state, Instruction instr)
{
   return false;
}

/* Store Doubleword with Update Indexed */
bool stdux(State *state, Instruction instr)
{
   return false;
}

/* Store Doubleword Indexed */
bool stdx(State *state, Instruction instr)
{
   return false;
}

/* Store Floating-Point Double */
bool stfd(State *state, Instruction instr)
{
   return false;
}

/* Store Floating-Point Double with Update */
bool stfdu(State *state, Instruction instr)
{
   return false;
}

/* Store Floating-Point Double with Update Indexed */
bool stfdux(State *state, Instruction instr)
{
   return false;
}

/* Store Floating-Point Double Indexed */
bool stfdx(State *state, Instruction instr)
{
   return false;
}

/* Store Floating-Point as Integer Word Indexed */
bool stfiwx(State *state, Instruction instr)
{
   return false;
}

/* Store Floating-Point Single */
bool stfs(State *state, Instruction instr)
{
   return false;
}

/* Store Floating-Point Single with Update */
bool stfsu(State *state, Instruction instr)
{
   return false;
}

/* Store Floating-Point Single with Update Indexed */
bool stfsux(State *state, Instruction instr)
{
   return false;
}

/* Store Floating-Point Single Indexed */
bool stfsx(State *state, Instruction instr)
{
   return false;
}

/* Store Halfword */
bool sth(State *state, Instruction instr)
{
   return false;
}

/* Store Halfword Byte-Reverse Indexed */
bool sthbrx(State *state, Instruction instr)
{
   return false;
}

/* Store Halfword with Update */
bool sthu(State *state, Instruction instr)
{
   return false;
}

/* Store Halfword with Update Indexed */
bool sthux(State *state, Instruction instr)
{
   return false;
}

/* Store Halfword Indexed */
bool sthx(State *state, Instruction instr)
{
   return false;
}

/* Store Multiple Word */
bool stmw(State *state, Instruction instr)
{
   return false;
}

/* Store String Word Immediate */
bool stswi(State *state, Instruction instr)
{
   return false;
}

/* Store String Word Indexed */
bool stswx(State *state, Instruction instr)
{
   return false;
}

/* Store Word */
bool stw(State *state, Instruction instr)
{
   return false;
}

/* Store Word Byte-Reverse Indexed */
bool stwbrx(State *state, Instruction instr)
{
   return false;
}

/* Store Word Conditional Indexed */
bool stwcx(State *state, Instruction instr)
{
   return false;
}

/* Store Word with Update */
bool stwu(State *state, Instruction instr)
{
   return false;
}

/* Store Word with Update Indexed */
bool stwux(State *state, Instruction instr)
{
   return false;
}

/* Store Word Indexed */
bool stwx(State *state, Instruction instr)
{
   return false;
}

/* Subtract From */
bool subf(State *state, Instruction instr)
{
   return false;
}

/* Subtract From Carrying */
bool subfc(State *state, Instruction instr)
{
   return false;
}

/* Subtract From Extended */
bool subfe(State *state, Instruction instr)
{
   return false;
}

/* Subtract From Immediate Carrying */
bool subfic(State *state, Instruction instr)
{
   return false;
}

/* Subtract From Minus One Extended */
bool subfme(State *state, Instruction instr)
{
   return false;
}

/* Subtract From Zero Extended */
bool subfze(State *state, Instruction instr)
{
   return false;
}

/* Synchronize */
bool sync(State *state, Instruction instr)
{
   return false;
}

/* Trap Doubleword */
bool td(State *state, Instruction instr)
{
   return false;
}

/* Trap Doubleword Immediate */
bool tdi(State *state, Instruction instr)
{
   return false;
}

/* Translation Lookaside Buffer Invalidate All */
bool tlbia(State *state, Instruction instr)
{
   return false;
}

/* Translation Lookaside Buffer Invalidate Entry */
bool tlbie(State *state, Instruction instr)
{
   return false;
}

/* Translation Lookaside Buffer Invalidate Entry Local */
bool tlbiel(State *state, Instruction instr)
{
   return false;
}

/* Translation Lookaside Buffer Synchronize */
bool tlbsync(State *state, Instruction instr)
{
   return false;
}

/* Trap Word */
bool tw(State *state, Instruction instr)
{
   return false;
}

/* Trap Word Immediate */
bool twi(State *state, Instruction instr)
{
   return false;
}

/* XOR */
bool xor(State *state, Instruction instr)
{
   return false;
}

/* XOR Immediate */
bool xori(State *state, Instruction instr)
{
   return false;
}

/* XOR Immediate Shifted */
bool xoris(State *state, Instruction instr)
{
   return false;
}

};

};

```

`src/powerpc/translator/translator.cpp`:

```cpp
#include "translator.h"

namespace ppc 
{

namespace Translator
{

#include "powerpc/emugen_instr_table.cpp"

} // namespace Interpreter

} // namespace ppc

```

`src/powerpc/translator/translator.h`:

```h
#ifndef PPC_TRANSLATOR_H
#define PPC_TRANSLATOR_H

#include "powerpc/cpu.h"
#include "exjit/irbuilder.h"

namespace ppc
{

namespace Translator
{

struct State
{
   State(exjit::Context *context) :
      context(context),
      builder(context)
   {
   }

   exjit::Value *gpr(unsigned i)
   {
      return _gpr[i];
   }

   void setGpr(unsigned i, exjit::Value *value)
   {
      _gpr[i] = value;
   }

   exjit::Value *_gpr[32];
   exjit::Context *context;
   exjit::IRBuilder builder;
};

#include "powerpc/emugen_stubs.h"

} // namespace Translator

} // namespace ppc

#endif // PPC_TRANSLATOR_H

```

`src/system.cpp`:

```cpp
#include "system.h"

#include "powerpc/cpu.h"
#include "powerpc/interpreter/interpreter.h"
#include "powerpc/disassembler/disassembler.h"

#include "common/log.h"
#include "common/memory.h"

#include "kernel/xboxkrnl/thread.h"

#include "kernel/xboxkrnl/thread.h"
#include "kernel/xboxkrnl/process.h"

#include <fstream>

System::System()
{
}

xex::Binary *System::getBinary()
{
   return &mBinary;
}

bool System::load(const std::string &path)
{
   xex::Loader test;
   std::ifstream file;

   file.open(path, std::ifstream::in | std::ifstream::binary);

   if (!file.is_open()) {
      xDebug() << "Could not open " << path << " for reading";
      return false;
   }

   test.load(file, mBinary);
   file.close();

   return true;
}

bool System::start()
{
   be_ptr32_t<Thread> thread;

   // Initialize kernel
   initKernel();

   // Create main thread
   ExCreateThread(reinterpret_cast<be_uint32_t*>(&thread),
                  mBinary.header.defaultStackSize.size,
                  nullptr,
                  nullptr,
                  reinterpret_cast<void*>(mBinary.header.entryPoint.address),
                  nullptr,
                  0);

   // Swap pointer back to little endian memory...
   thread->join();

   return true;
}

void System::resumeThread(Thread *thread)
{
   ppc::Instruction ins;
   auto state = reinterpret_cast<ppc::Interpreter::State*>(thread->getState());

   if (!state) {
      // Create a new interpreter state for this thread
      state = new ppc::Interpreter::State();
      thread->setState(state);

      // Zero it first pls..
      memset(state, 0, sizeof(ppc::Interpreter::State));

      // Set the entry point
      state->cia = thread->getStartAddress().getRawPointer();
      state->nia = state->cia + 4;

      // Initial register values
      state->reg.gpr[1] = thread->getStackBase().getRawPointer();
      state->reg.gpr[3] = thread->getStartParameter().getRawPointer();
      state->reg.gpr[13] = thread->getPcr().getRawPointer();
   }

   // XXX: Debug
   analyse(0x82F088D0);

   for (unsigned i = 0; i < 99999; ++i) {
      ppc::Disassembler::State dis;

      dis.cia = state->cia;
      ins.value = Memory::read<uint32_t>(state->cia);

      ppc::Disassembler::decode(&dis, ins);

      xDebug()
         << Log::hex(static_cast<uint32_t>(state->cia))
         << " " << dis.result.disasm;

      ppc::Interpreter::decode(state, ins);

      if (state->nia != state->cia + 4) {
         xDebug() << "BRANCH";
      }

      state->cia = state->nia;
      state->nia = state->cia + 4;
   }
}

```

`src/system.h`:

```h
#ifndef SYSTEM_H
#define SYSTEM_H

#include "xex/xex.h"
#include "kernel/kernel.h"

#include <map>

class Thread;
class Module;

class System
{
public:
   System();

   bool load(const std::string &path);

   bool start();

   bool analyse(uint64_t start);
   void resumeThread(Thread *thread);

   void addModule(Module *module);
   Module *getModule(std::string name);

   xex::Binary *getBinary();

private:
   bool initKernel();
   bool resolveImports(xex::ImportLibraries &imports);

private:
   xex::Binary mBinary;
   std::map<std::string, Module*> mModules;
};

extern System gSystem;

#endif // System

```

`src/xex/aes.h`:

```h
#ifndef AES_H
#define AES_H

#include "rijndael-alg-fst.h"
#include <string.h>
#include <stdint.h>

/* Rijndael / AES in CBC mode */
class Rijndael
{
public:
   Rijndael()
   {
   }

   Rijndael(const uint8_t key[16])
   {
      init(key);
   }

   void init(const uint8_t key[16])
   {
      memcpy(mKey, key, 16);
      memset(mIv, 0, 16);
      mRounds = rijndaelKeySetupDec(mRoundKey, mKey, 128);
   }

   void decrypt(const uint8_t in[16], uint8_t out[16])
   {
      rijndaelDecrypt(mRoundKey, mRounds, in, out);

      for (auto i = 0; i < 16; i++) {
         out[i] ^= mIv[i];
      }

      memcpy(mIv, in, 16);
   }

private:
   uint8_t mKey[16];
   uint8_t mIv[16];
   uint32_t mRounds;
   uint32_t mRoundKey[4 * (MAXNR + 1)];
};

#endif // AES_H

```

`src/xex/biginputstream.h`:

```h
#ifndef BIG_ENDIAN_INPUT_STREAM_H
#define BIG_ENDIAN_INPUT_STREAM_H

#include <string>
#include <assert.h>
#include <stdint.h>

#include "common/byte_swap.h"

struct NullPadString
{
   NullPadString(std::string &str) : str(str)
   {
   }
   std::string &str;
};

struct FixedWidthString
{
   FixedWidthString(std::string &str, int width) : str(str), width(width)
   {
   }
   std::string &str;
   int width;
};

class BigInputStream
{
public:
   BigInputStream(std::istream& stream) :
      mStream(stream)
   {
   }

   template<typename Type>
   BigInputStream & operator>>(Type& val)
   {
      mStream.read(reinterpret_cast<char*>(&val), sizeof(Type));
      val = byte_swap(val);
      return *this;
   }

   template<>
   BigInputStream & operator>>(NullPadString& val)
   {
      unsigned __int8 c;
      int i = 0;

      for (int i = 0; i < 256; ++i) {
         (*this) >> c;

         if (c) {
            val.str.push_back(c);
         } else if (((i + 1) % 4) == 0) {
            break;
         }
      }

      return *this;
   }

   template<>
   BigInputStream & operator>>(FixedWidthString& val)
   {
      char buf[256];
      assert(val.width + 1 < sizeof(buf));
      mStream.read(buf, val.width);
      buf[val.width] = 0;
      val.str = buf;
      return *this;
   }

   template<int N>
   BigInputStream & operator>>(uint8_t(&val)[N])
   {
      mStream.read(reinterpret_cast<char*>(val), N);
      return *this;
   }

   void read(uint8_t *buf, unsigned int size)
   {
      mStream.read(reinterpret_cast<char*>(buf), size);
   }

   void seek(unsigned int pos)
   {
      mStream.seekg(pos, mStream.beg);
   }

   void skip(int pos)
   {
      mStream.seekg(pos, mStream.cur);
   }

   unsigned int tell()
   {
      return (unsigned int)mStream.tellg();
   }

   unsigned int size()
   {
      std::streampos start, pos, end;
      pos = mStream.tellg();

      mStream.seekg(0, mStream.end);
      end = mStream.tellg();

      mStream.seekg(0, mStream.beg);
      start = mStream.tellg();

      mStream.seekg(pos, mStream.beg);
      return (unsigned int)(end - start);
   }

private:
   std::istream& mStream;
};

#endif // ifdef BIG_ENDIAN_INPUT_STREAM_H

```

`src/xex/loader.cpp`:

```cpp
#include "xex.h"
#include "aes.h"
#include "biginputstream.h"

#include "common/log.h"
#include "common/memory.h"

#include <windows.h>

#include <map>
#include <string>
#include <algorithm>
#include <fstream>

namespace xex
{

bool Loader::load(std::istream &istr, xex::Binary &binary)
{
   BigInputStream in { istr };
   xex::Header &header = binary.header;

   in >> header.magic
      >> header.moduleFlags.flags
      >> header.peDataOffset
      >> header.reserved
      >> header.securityInfoOffset
      >> header.optHeaderCount;

   for (uint32_t i = 0; i < header.optHeaderCount; ++i) {
      uint32_t key, dataOffset, length;
      uint32_t pos, read, start, end;
         
      in
         >> key
         >> dataOffset;

      pos = in.tell();

      /* Get header length */
      length = key & 0xFF;

      if (length == 0 || length == 1) {
         in.skip(-4);
         length = 4;
      } else if (length == 0xFF) {
         in.seek(dataOffset);
         in >> length;
         length -= 4;
      } else {
         in.seek(dataOffset);
         length = length * 4;
      }

      start = in.tell();
                  
      /* Read raw data for RtlImageXexHeaderField */
      OptionalRawHeader raw;
      raw.key = key;
      raw.data.resize(length);
      in.read(raw.data.data(), length);
      in.seek(start);
      header.optionalRaw.emplace_back(raw);

      /* Parse header data */
      switch (static_cast<Headers>(key >> 8)) {
      case xex::Headers::ResourceInfo:
         readHeader(in, length, header.resourceInfo);
         break;
      case xex::Headers::BaseFileFormat:
         readHeader(in, length, header.baseFileFormat);
         break;
      case xex::Headers::BaseReference:
         readHeader(in, length, header.baseReference);
         break;
      case xex::Headers::DeltaPatchDescriptor:
         readHeader(in, length, header.deltaPatchDescriptor);
         break;
      case xex::Headers::BoundingPath:
         readHeader(in, length, header.boundingPath);
         break;
      case xex::Headers::DeviceId:
         readHeader(in, length, header.deviceId);
         break;
      case xex::Headers::OriginalBaseAddress:
         readHeader(in, length, header.originalBaseAddress);
         break;
      case xex::Headers::EntryPoint:
         readHeader(in, length, header.entryPoint);
         break;
      case xex::Headers::ImageBaseAddress:
         readHeader(in, length, header.imageBaseAddress);
         break;
      case xex::Headers::ImportLibraries:
         readHeader(in, length, header.importLibraries);
         break;
      case xex::Headers::ChecksumTimestamp:
         readHeader(in, length, header.checksumTimestamp);
         break;
      case xex::Headers::EnabledForCallcap:
         readHeader(in, length, header.enabledForCallcap);
         break;
      case xex::Headers::EnabledForFastcap:
         readHeader(in, length, header.enabledForFastcap);
         break;
      case xex::Headers::OriginalPeName:
         readHeader(in, length, header.originalPeName);
         break;
      case xex::Headers::StaticLibraries:
         readHeader(in, length, header.staticLibraries);
         break;
      case xex::Headers::TlsInfo:
         readHeader(in, length, header.tlsInfo);
         break;
      case xex::Headers::DefaultStackSize:
         readHeader(in, length, header.defaultStackSize);
         break;
      case xex::Headers::DefaultFilesystemCacheSize:
         readHeader(in, length, header.defaultFilesystemCacheSize);
         break;
      case xex::Headers::DefaultHeapSize:
         readHeader(in, length, header.defaultHeapSize);
         break;
      case xex::Headers::PageHeapSizeandFlags:
         readHeader(in, length, header.pageHeapSizeandFlags);
         break;
      case xex::Headers::SystemFlags:
         readHeader(in, length, header.systemFlags);
         break;
      case xex::Headers::ExecutionInfo:
         readHeader(in, length, header.executionInfo);
         break;
      case xex::Headers::ServiceIdList:
         readHeader(in, length, header.serviceIdList);
         break;
      case xex::Headers::TitleWorkspaceSize:
         readHeader(in, length, header.titleWorkspaceSize);
         break;
      case xex::Headers::GameRatings:
         readHeader(in, length, header.gameRatings);
         break;
      case xex::Headers::LanKey:
         readHeader(in, length, header.lanKey);
         break;
      case xex::Headers::Xbox360Logo:
         readHeader(in, length, header.xbox360Logo);
         break;
      case xex::Headers::MultidiscMediaIds:
         readHeader(in, length, header.multidiscMediaIds);
         break;
      case xex::Headers::AlternateTitleIds:
         readHeader(in, length, header.alternateTitleIds);
         break;
      case xex::Headers::AdditionalTitleMemory:
         readHeader(in, length, header.additionalTitleMemory);
         break;
      case xex::Headers::ExportsByName:
         readHeader(in, length, header.exportsByName);
         break;
      default:
         xDebug() << "Unknown header found 0x" << Log::hex(key, 8);
      }

      end = in.tell();
      read = end - start;
      xDebug() << "Header 0x" << Log::hex(key, 8) << " read " << read << " / " << length << " bytes";

      in.seek(pos);
   }

   in.seek(header.securityInfoOffset);
   readHeader(in, 0, header.loaderInfo);

   uint32_t sectionCount;
   in >> sectionCount;

   for (uint32_t i = 0; i < sectionCount; ++i) {
      xex::Section section;

      in >> section._typePageCount
         >> section.digest;

      header.sections.push_back(section);
   }

   /* Decrypt Header Key */
   const static uint8_t xex2_retail_key[16] = {
      0x20, 0xB1, 0x85, 0xA5, 0x9D, 0x28, 0xFD, 0xC3,
      0x40, 0x58, 0x3F, 0xBB, 0x08, 0x96, 0xBF, 0x91
   };

   const static uint8_t xex2_devkit_key[16] = {
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
   };

   Rijndael { xex2_retail_key }.decrypt(header.loaderInfo.fileKey, header.sessionKey);

   /* Read Image */
   readImage(in, header);

   /* Load windows PE from memory */
   loadPe(binary, header.imageBaseAddress.address);
   loadImportLibraries(header.importLibraries);

   return true;
}

bool Loader::readImage(BigInputStream &in, xex::Header &header)
{
   switch (header.baseFileFormat.compression.type) {
   case xex::BaseFileFormat::Compression::None:
      return readImageUncompressed(in, header);
   case xex::BaseFileFormat::Compression::Basic:
      return readImageBasicCompression(in, header);
   case xex::BaseFileFormat::Compression::Normal:
      return readImageNormalCompression(in, header);
   default:
      xDebug() << "Unimplemented readImage compression type " << header.baseFileFormat.compression.type;
   }

   return false;
}

bool Loader::readImageUncompressed(BigInputStream &in, xex::Header &header)
{
   return false;
}

bool Loader::readImageNormalCompression(BigInputStream &in, xex::Header &header)
{
   switch (header.baseFileFormat.encryption.type) {
   case xex::BaseFileFormat::Encryption::Encrypted:
   {
      break;
   }
   default:
      xDebug() << "Unimplemented readImageNormalCompression encryption type " << header.baseFileFormat.encryption.type;
   }
/*
  const size_t exe_length = xex_length - header->exe_offset;
  const uint8_t *exe_buffer = (const uint8_t*)xex_addr + header->exe_offset;

  // src -> dest:
  // - decrypt (if encrypted)
  // - de-block:
  //    4b total size of next block in uint8_ts
  //   20b hash of entire next block (including size/hash)
  //    Nb block uint8_ts
  // - decompress block contents

  int result_code = 1;

  uint8_t *compress_buffer = NULL;
  const uint8_t *p = NULL;
  uint8_t *d = NULL;
  uint8_t *deblock_buffer = NULL;
  size_t block_size = 0;
  size_t uncompressed_size = 0;
  struct mspack_system *sys = NULL;
  mspack_memory_file *lzxsrc = NULL;
  mspack_memory_file *lzxdst = NULL;
  struct lzxd_stream *lzxd = NULL;

  // Decrypt (if needed).
  bool free_input = false;
  const uint8_t *input_buffer = exe_buffer;
  const size_t input_size = exe_length;
  switch (header->file_format_info.encryption_type) {
  case XEX_ENCRYPTION_NONE:
    // No-op.
    break;
  case XEX_ENCRYPTION_NORMAL:
    // TODO: a way to do without a copy/alloc?
    free_input = true;
    input_buffer = (const uint8_t*)xe_calloc(input_size);
    XEEXPECTNOTNULL(input_buffer);
    xe_xex2_decrypt_buffer(header->session_key, exe_buffer, exe_length,
                           (uint8_t*)input_buffer, input_size);
    break;
  default:
    XEASSERTALWAYS();
    return false;
  }

  compress_buffer = (uint8_t*)xe_calloc(exe_length);
  XEEXPECTNOTNULL(compress_buffer);

  p = input_buffer;
  d = compress_buffer;

  // De-block.
  deblock_buffer = (uint8_t*)xe_calloc(input_size);
  XEEXPECTNOTNULL(deblock_buffer);
  block_size = header->file_format_info.compression_info.normal.block_size;
  while (block_size) {
    const uint8_t *pnext = p + block_size;
    const size_t next_size = XEGETINT32BE(p);
    p += 4;
    p += 20; // skip 20b hash

    while(true) {
      const size_t chunk_size = (p[0] << 8) | p[1];
      p += 2;
      if (!chunk_size) {
        break;
      }
      xe_copy_memory(d, exe_length - (d - compress_buffer), p, chunk_size);
      p += chunk_size;
      d += chunk_size;

      uncompressed_size += 0x8000;
    }

    p = pnext;
    block_size = next_size;
  }

  // Allocate in-place the XEX memory.
  uint32_t alloc_result = (uint32_t)memory->HeapAlloc(
      header->exe_address, uncompressed_size,
      MEMORY_FLAG_ZERO);
  if (!alloc_result) {
    XELOGE("Unable to allocate XEX memory at %.8X-%.8X.",
           header->exe_address, uncompressed_size);
    result_code = 2;
    XEFAIL();
  }
  uint8_t *buffer = memory->Translate(header->exe_address);

  // Setup decompressor and decompress.
  sys = mspack_memory_sys_create();
  XEEXPECTNOTNULL(sys);
  lzxsrc = mspack_memory_open(sys, (void*)compress_buffer, d - compress_buffer);
  XEEXPECTNOTNULL(lzxsrc);
  lzxdst = mspack_memory_open(sys, buffer, uncompressed_size);
  XEEXPECTNOTNULL(lzxdst);
  lzxd = lzxd_init(
      sys,
      (struct mspack_file *)lzxsrc,
      (struct mspack_file *)lzxdst,
      header->file_format_info.compression_info.normal.window_bits,
      0,
      32768,
      (off_t)header->loader_info.image_size);
  XEEXPECTNOTNULL(lzxd);
  XEEXPECTZERO(lzxd_decompress(lzxd, (off_t)header->loader_info.image_size));

  result_code = 0;

XECLEANUP:
  if (lzxd) {
    lzxd_free(lzxd);
    lzxd = NULL;
  }
  if (lzxsrc) {
    mspack_memory_close(lzxsrc);
    lzxsrc = NULL;
  }
  if (lzxdst) {
    mspack_memory_close(lzxdst);
    lzxdst = NULL;
  }
  if (sys) {
    mspack_memory_sys_destroy(sys);
    sys = NULL;
  }
  xe_free(compress_buffer);
  xe_free(deblock_buffer);
  if (free_input) {
    xe_free((void*)input_buffer);
  }
  return result_code;
*/
   return false;
}

bool Loader::readImageBasicCompression(BigInputStream &in, xex::Header &header)
{
   unsigned uncompressedSize;

   in.seek(header.peDataOffset);

   /* Calculate uncompressed size */
   uncompressedSize = 0;

   for (auto block : header.baseFileFormat.compression.basic.blocks) {
      uncompressedSize += block.dataSize + block.zeroSize;
   }

   /* Allocate virtual memory */
   uint8_t *pExecutable = Memory::allocate(header.imageBaseAddress.address, uncompressedSize);

   if (!pExecutable) {
      xDebug() << "Could not allocate memory at 0x" << Log::hex(header.imageBaseAddress.address, 8) << " with size " << uncompressedSize;
      return false;
   }

   switch(header.baseFileFormat.encryption.type) {
   case xex::BaseFileFormat::Encryption::Encrypted:
   {
      Rijndael crypt;
      uint8_t buffer[16];
      uint8_t *pMemory;

      crypt.init(header.sessionKey);
      pMemory = pExecutable;

      for (auto block : header.baseFileFormat.compression.basic.blocks) {
         for (size_t n = 0; n < block.dataSize; n += 16) {
            in >> buffer;
            crypt.decrypt(buffer, pMemory + n);
         }

         pMemory += block.dataSize + block.zeroSize;
      }
      break;
   }
   default:
      xDebug() << "Unimplemented readImageBasicCompression encryption type " << header.baseFileFormat.encryption.type;
   }

   return true;
}

bool Loader::loadPe(xex::Binary &binary, uint32_t exeAddress)
{
   /* Verify DOS Header */
   const PIMAGE_DOS_HEADER dosHeader = reinterpret_cast<PIMAGE_DOS_HEADER>(exeAddress);

   if (dosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
      xDebug() << "IMAGE_DOS_HEADER.e_magic != IMAGE_DOS_SIGNATURE";
      return false;
   }

   /* Verify NT32 Header */
   const PIMAGE_NT_HEADERS32 ntHeader = reinterpret_cast<PIMAGE_NT_HEADERS32>(exeAddress + dosHeader->e_lfanew);
      
   if (ntHeader->Signature != IMAGE_NT_SIGNATURE) {
      xDebug() << "IMAGE_NT_HEADERS32.Signature != IMAGE_NT_SIGNATURE";
      return false;
   }

   /* Verify File Header */
   const PIMAGE_FILE_HEADER fileHeader = &ntHeader->FileHeader;

   if (fileHeader->Machine != IMAGE_FILE_MACHINE_POWERPCBE) {
      xDebug() << "IMAGE_FILE_HEADER.Machine != IMAGE_FILE_MACHINE_POWERPCBE";
      return false;
   }
      
   if (!(fileHeader->Characteristics & IMAGE_FILE_32BIT_MACHINE)) {
      xDebug() << "IMAGE_FILE_HEADER.Characteristics & IMAGE_FILE_32BIT_MACHINE == 0";
      return false;
   }

   if (fileHeader->SizeOfOptionalHeader != IMAGE_SIZEOF_NT_OPTIONAL_HEADER) {
      xDebug() << "IMAGE_FILE_HEADER.SizeOfOptionalHeader != IMAGE_SIZEOF_NT_OPTIONAL_HEADER";
      return false;
   }

   /* Verify Optional Header */
   const PIMAGE_OPTIONAL_HEADER32 optHeader = &ntHeader->OptionalHeader;

   if (optHeader->Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
      xDebug() << "IMAGE_OPTIONAL_HEADER32.Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC";
      return false;
   }

   if (optHeader->Subsystem != IMAGE_SUBSYSTEM_XBOX) {
      xDebug() << "IMAGE_OPTIONAL_HEADER32.Subsystem != IMAGE_SUBSYSTEM_XBOX";
      return false;
   }

   /* Read Section Headers */
   PIMAGE_SECTION_HEADER secHeader = IMAGE_FIRST_SECTION(ntHeader);

   for (WORD i = 0; i < fileHeader->NumberOfSections; ++i, ++secHeader) {
      PeSection section;
      section.name = std::string { reinterpret_cast<const char*>(secHeader->Name), 8 };
      section.rawAddress = secHeader->PointerToRawData;
      section.rawSize = secHeader->SizeOfRawData;
      section.address = exeAddress + secHeader->VirtualAddress;
      section.size = secHeader->Misc.VirtualSize;
      section.flags = secHeader->Characteristics;
      binary.sections.push_back(section);
   }

   return true;
}

void Loader::loadImportLibraries(xex::ImportLibraries &importLibraries)
{
   for (auto &library : importLibraries.libraries) {
      for (auto &record : library.records) {
         auto value = Memory::read<uint32_t>(record.address);
         auto ordinal = value & 0xFFFF;
         auto type = value >> 24;

         switch (type) {
         case xex::ImportLibraries::ImportOrdinal:
         {
            xex::ImportLibrary::Import import;
            import.address = record.address;
            import.ordinal = ordinal;
            import.thunk   = 0;
            import.args    = 0;
            library.imports.push_back(import);
            break;
         }
         case xex::ImportLibraries::ImportThunk:
         {
            xex::ImportLibrary::Import &import = library.imports.back();
            import.thunk = record.address;
            assert(import.ordinal == ordinal);
            break;
         }
         default:
            xDebug() << "Unknown ImportLibraries record type " << type;
         }
      }
   }
}

void Loader::readHeader(BigInputStream &in, unsigned length, xex::ResourceInfo &resourceInfo)
{
   in >> resourceInfo.titleId
      >> resourceInfo.address
      >> resourceInfo.size;
}
   
void Loader::readHeader(BigInputStream &in, unsigned length, xex::BaseFileFormat &baseFileFormat)
{
   in >> baseFileFormat.encryption.type
      >> baseFileFormat.compression.type;

   switch (baseFileFormat.compression.type) {
   case xex::BaseFileFormat::Compression::Basic:
      {
         unsigned blocks = (length - 4) / 8;

         for (unsigned i = 0; i < blocks; ++i) {
            xex::BaseFileFormat::BasicCompression::Block block;

            in >> block.dataSize
               >> block.zeroSize;

            baseFileFormat.compression.basic.blocks.push_back(block);
         }
         break;
      }
   case xex::BaseFileFormat::Compression::Normal:
      in >> baseFileFormat.compression.normal.windowSize
         >> baseFileFormat.compression.normal.blockSize
         >> baseFileFormat.compression.normal.blockHash;
      break;
   case xex::BaseFileFormat::Compression::None:
   case xex::BaseFileFormat::Compression::Delta:
      xDebug() << "Unimplemented BaseFileFormat.compressionType " << baseFileFormat.compression.type;
      break;
   default:
      xDebug() << "Unknown BaseFileFormat.compressionType " << baseFileFormat.compression.type;
   }
}

void Loader::readHeader(BigInputStream &in, unsigned length, xex::EntryPoint &entryPoint)
{
   in >> entryPoint.address;
}

void Loader::readHeader(BigInputStream &in, unsigned length, xex::ImageBaseAddress &imageBaseAddress)
{
   in >> imageBaseAddress.address;
}

void Loader::readStringTable(BigInputStream &in, unsigned length, std::vector<std::string> &stringTable)
{
   std::string curString;

   for (unsigned i = 0; i < length; ++i) {
      uint8_t c;
      in >> c;

      if (c) {
         curString.push_back(c);
      } else if (curString.length() || (i + 1) == length) {
         stringTable.push_back(curString);
         curString.clear();
      }
   }
}

void Loader::readHeader(BigInputStream &in, unsigned length, xex::ImportLibraries &importLibraries)
{
   std::vector<std::string> stringTable;
   uint32_t stringTableSize;
   uint32_t libraryCount;

   in >> stringTableSize
      >> libraryCount;

   readStringTable(in, stringTableSize, stringTable);

   for (unsigned i = 0; i < libraryCount; ++i) {
      xex::ImportLibrary library;
      uint16_t nameIndex;
      uint16_t importCount;

      in >> library.unknown
         >> library.digest
         >> library.importId
         >> library.curVersion.value
         >> library.minVersion.value
         >> nameIndex
         >> importCount;

      library.name = stringTable.at(nameIndex);
         
      for (uint16_t j = 0; j < importCount; ++j) {
         xex::ImportLibrary::Record record;
         in >> record.address;
         library.records.push_back(record);
      }

      importLibraries.libraries.push_back(library);
   }
}

void Loader::readHeader(BigInputStream &in, unsigned length, xex::ChecksumTimestamp &checksumTimestamp)
{
   in >> checksumTimestamp.checksum
      >> checksumTimestamp.timestamp;
}
   
void Loader::readHeader(BigInputStream &in, unsigned length, xex::OriginalPeName &originalPeName)
{
   in >> NullPadString(originalPeName.name);
}

void Loader::readHeader(BigInputStream &in, unsigned length, xex::StaticLibraries &staticLibraries)
{
   unsigned count = length / 16;

   for (unsigned i = 0; i < count; ++i) {
      xex::StaticLibrary library;

      in >> FixedWidthString(library.name, 8)
         >> library.version.major
         >> library.version.minor
         >> library.version.build
         >> library.version._qfeApproved;

      staticLibraries.libraries.push_back(library);
   }
}

void Loader::readHeader(BigInputStream &in, unsigned length, xex::TlsInfo &tlsInfo)
{
   in >> tlsInfo.slotCount
      >> tlsInfo.rawDataAddress
      >> tlsInfo.dataSize
      >> tlsInfo.rawDataSize;
}

void Loader::readHeader(BigInputStream &in, unsigned length, xex::DefaultStackSize &defaultStackSize)
{
   in >> defaultStackSize.size;
}

void Loader::readHeader(BigInputStream &in, unsigned length, xex::DefaultHeapSize &defaultHeapSize)
{
   in >> defaultHeapSize.size;
}

void Loader::readHeader(BigInputStream &in, unsigned length, xex::SystemFlags &systemFlags)
{
   in >> systemFlags.flags;
}

void Loader::readHeader(BigInputStream &in, unsigned length, xex::ExecutionInfo &executionInfo)
{
   in >> executionInfo.mediaId
      >> executionInfo.curVersion.value
      >> executionInfo.baseVersion.value
      >> executionInfo.titleId
      >> executionInfo.platform
      >> executionInfo.executableTable
      >> executionInfo.discNumber
      >> executionInfo.discCount
      >> executionInfo.saveGameId;
}

void Loader::readHeader(BigInputStream &in, unsigned length, xex::GameRatings &gameRatings)
{
   in >> gameRatings.esrb
      >> gameRatings.pegi
      >> gameRatings.pegifi
      >> gameRatings.pegipt
      >> gameRatings.bbfc
      >> gameRatings.cero
      >> gameRatings.usk
      >> gameRatings.oflcau
      >> gameRatings.oflcnz
      >> gameRatings.kmrb
      >> gameRatings.brazil
      >> gameRatings.fpb;
}

void Loader::readHeader(BigInputStream &in, unsigned length, xex::LanKey &lanKey)
{
   in >> lanKey.key;
}

void Loader::readHeader(BigInputStream &in, unsigned length, xex::AlternateTitleIds &alternateTitleIds)
{
   unsigned count = length / 4;

   for (unsigned i = 0; i < count; ++i) {
      uint32_t id;
      in >> id;
      alternateTitleIds.ids.push_back(id);
   }
}

void Loader::readHeader(BigInputStream &in, unsigned length, xex::LoaderInfo &loaderInfo)
{
   in >> loaderInfo.headerSize
      >> loaderInfo.imageSize
      >> loaderInfo.rsaSignature
      >> loaderInfo._unknown1
      >> loaderInfo.imageFlags._flags
      >> loaderInfo.loadAddress
      >> loaderInfo.sectionDigest
      >> loaderInfo.importTableCount
      >> loaderInfo.importTableDigest
      >> loaderInfo.mediaId
      >> loaderInfo.fileKey
      >> loaderInfo.exportTable
      >> loaderInfo.headerDigest
      >> loaderInfo.gameRegions
      >> loaderInfo.mediaFlags._flags;
}

} //namespace xex

```

`src/xex/optionalheaders.h`:

```h
#ifndef XEX_OPTIONAL_HEADERS_H
#define XEX_OPTIONAL_HEADERS_H

#include <stdint.h>
#include <string>
#include <vector>

namespace xex
{

enum class Headers
{
   ResourceInfo               =    0x2,
   BaseFileFormat             =    0x3,
   BaseReference              =    0x4,
   DeltaPatchDescriptor       =    0x5,
   BoundingPath               =   0x80,
   DeviceId                   =   0x81,
   OriginalBaseAddress        =  0x100,
   EntryPoint                 =  0x101,
   ImageBaseAddress           =  0x102,
   ImportLibraries            =  0x103,
   ChecksumTimestamp          =  0x180,
   EnabledForCallcap          =  0x181,
   EnabledForFastcap          =  0x182,
   OriginalPeName             =  0x183,
   StaticLibraries            =  0x200,
   TlsInfo                    =  0x201,
   DefaultStackSize           =  0x202,
   DefaultFilesystemCacheSize =  0x203,
   DefaultHeapSize            =  0x204,
   PageHeapSizeandFlags       =  0x280,
   SystemFlags                =  0x300,
   ExecutionInfo              =  0x400,
   ServiceIdList              =  0x401,
   TitleWorkspaceSize         =  0x402,
   GameRatings                =  0x403,
   LanKey                     =  0x404,
   Xbox360Logo                =  0x405,
   MultidiscMediaIds          =  0x406,
   AlternateTitleIds          =  0x407,
   AdditionalTitleMemory      =  0x408,
   ExportsByName              = 0xE104,
};

#pragma pack(push, 1)

struct OptionalRawHeader
{
   uint32_t key;
   std::vector<uint8_t> data;
};

struct OptionalHeader {
   OptionalHeader() : _read(false) {}
   bool _read;
};

union Version
{
   uint32_t value;

   struct {
      uint32_t qfe : 8;
      uint32_t build : 16;
      uint32_t minor : 4;
      uint32_t major : 4;
   };
};

union TitleId
{
   uint32_t value;

   struct {
      uint8_t letters[2];
      uint16_t numbers;
   };
};

struct ResourceInfo : public OptionalHeader
{
   static const Headers id = Headers::ResourceInfo;

   uint8_t titleId[8];
   uint32_t address;
   uint32_t size;
};

struct BaseFileFormat : public OptionalHeader
{
   static const Headers id = Headers::BaseFileFormat;

   struct BasicCompression {
      struct Block {
         uint32_t dataSize;
         uint32_t zeroSize;
      };

      std::vector<Block> blocks;
   };

   struct NormalCompression {
      uint32_t windowSize;
      uint32_t blockSize;
      uint8_t blockHash[20];
   };

   struct Compression {
      enum {
         None   = 0x00,
         Basic  = 0x01,
         Normal = 0x02,
         Delta  = 0x03
      };

      uint16_t type;
      BasicCompression basic;
      NormalCompression normal;
   };

   struct Encryption {
      enum {
         Unencrypted = 0x00,
         Encrypted   = 0x01
      };

      uint16_t type;
   };

   Encryption encryption;
   Compression compression;
};

struct BaseReference : public OptionalHeader
{
   static const Headers id = Headers::BaseReference;
};

struct DeltaPatchDescriptor : public OptionalHeader
{
   static const Headers id = Headers::DeltaPatchDescriptor;
};

struct BoundingPath : public OptionalHeader
{
   static const Headers id = Headers::BoundingPath;
};

struct DeviceId : public OptionalHeader
{
   static const Headers id = Headers::DeviceId;
};

struct OriginalBaseAddress : public OptionalHeader
{
   static const Headers id = Headers::OriginalBaseAddress;
};

struct EntryPoint : public OptionalHeader
{
   static const Headers id = Headers::EntryPoint;

   uint32_t address;
};

struct ImageBaseAddress : public OptionalHeader
{
   static const Headers id = Headers::ImageBaseAddress;

   uint32_t address;
};

struct ImportLibrary : public OptionalHeader
{
   struct Record {
      uint32_t address;
   };

   struct Import {
      uint32_t address;
      uint32_t ordinal;
      uint32_t thunk;
      uint32_t args;
      std::string name;
   };

   uint32_t unknown;
   uint8_t digest[20];
   uint32_t importId;
   Version curVersion;
   Version minVersion;
   std::string name;
   std::vector<Record> records;
   std::vector<Import> imports;
};

struct ImportLibraries : public OptionalHeader
{
   enum
   {
      ImportOrdinal = 0,
      ImportThunk = 1,
   };

   static const Headers id = Headers::ImportLibraries;

   std::vector<ImportLibrary> libraries;
};

struct ChecksumTimestamp : public OptionalHeader
{
   static const Headers id = Headers::ChecksumTimestamp;

   uint32_t checksum;
   uint32_t timestamp;
};

struct EnabledForCallcap : public OptionalHeader
{
   static const Headers id = Headers::EnabledForCallcap;
};

struct EnabledForFastcap : public OptionalHeader
{
   static const Headers id = Headers::EnabledForFastcap;
};

struct OriginalPeName : public OptionalHeader
{
   static const Headers id = Headers::OriginalPeName;

   std::string name;
};

struct StaticLibrary : public OptionalHeader
{
   std::string name;

   struct {
      uint16_t major;
      uint16_t minor;
      uint16_t build;

      union {
         uint16_t _qfeApproved;

         struct {
            uint16_t qfe : 15;
            uint16_t approved : 1;
         };
      };
   } version;
};

struct StaticLibraries : public OptionalHeader
{
   static const Headers id = Headers::StaticLibraries;

   std::vector<StaticLibrary> libraries;
};

struct TlsInfo : public OptionalHeader
{
   static const Headers id = Headers::TlsInfo;

   uint32_t slotCount;
   uint32_t rawDataAddress;
   uint32_t dataSize;
   uint32_t rawDataSize;
};

struct DefaultStackSize : public OptionalHeader
{
   static const Headers id = Headers::DefaultStackSize;

   uint32_t size;
};

struct DefaultFilesystemCacheSize : public OptionalHeader
{
   static const Headers id = Headers::DefaultFilesystemCacheSize;
};

struct DefaultHeapSize : public OptionalHeader
{
   static const Headers id = Headers::DefaultHeapSize;

   uint32_t size;
};

struct PageHeapSizeandFlags : public OptionalHeader
{
   static const Headers id = Headers::PageHeapSizeandFlags;
};

struct SystemFlags : public OptionalHeader
{
   static const Headers id = Headers::SystemFlags;

   union {
      uint32_t flags;

      struct {
         uint32_t noForcedReboot : 1;
         uint32_t foregroundTasks : 1;
         uint32_t noOddMapping : 1;
         uint32_t handlesMceInputs : 1;
         uint32_t restrictedHudFeatures : 1;
         uint32_t handlesGamepadDisconnect : 1;
         uint32_t hasSecureSockets : 1;
         uint32_t xbox1Interop : 1;
         uint32_t dashContext : 1;
         uint32_t usesGameVoiceChannel : 1;
         uint32_t pal50Incompatible : 1;
         uint32_t insecureUtilityDriveSupport : 1;
         uint32_t xamHooks : 1;
         uint32_t accessesPii : 1;
         uint32_t crossPlatformSystemLink : 1;
         uint32_t multidiscSwap : 1;
         uint32_t supportsInsecureMultidiscMedia : 1;
         uint32_t antipiracy25Media : 1;
         uint32_t noConfirmExit : 1;
         uint32_t allowBackgroundDownloading : 1;
         uint32_t createPersistentRamDrive : 1;
         uint32_t inheritPersistentRamDrive : 1;
         uint32_t allowHudVibration : 1;
         uint32_t allowBothUtilityPartitionAccess : 1;
         uint32_t handleIptvInput : 1;
         uint32_t preferBigButtonInput : 1;
         uint32_t allowExtendedSystemReservation : 1;
         uint32_t multidiscCrossTitle : 1;
         uint32_t titleInstallIncompatible : 1;
         uint32_t allowAvatarGetMetadataByXuid : 1;
         uint32_t allowControllerSwapping : 1;
         uint32_t dashExtensibilityModule : 1;
      };
   };
};

struct ExecutionInfo : public OptionalHeader
{
   static const Headers id = Headers::ExecutionInfo;

   uint32_t mediaId;
   Version curVersion;
   Version baseVersion;
   uint32_t titleId;
   uint8_t platform;
   uint8_t executableTable;
   uint8_t discNumber;
   uint8_t discCount;
   uint32_t saveGameId;
};

struct ServiceIdList : public OptionalHeader
{
   static const Headers id = Headers::ServiceIdList;
};

struct TitleWorkspaceSize : public OptionalHeader
{
   static const Headers id = Headers::TitleWorkspaceSize;
};

struct GameRatings : public OptionalHeader
{
   static const Headers id = Headers::GameRatings;

   uint8_t esrb;
   uint8_t pegi;
   uint8_t pegifi;
   uint8_t pegipt;
   uint8_t bbfc;
   uint8_t cero;
   uint8_t usk;
   uint8_t oflcau;
   uint8_t oflcnz;
   uint8_t kmrb;
   uint8_t brazil;
   uint8_t fpb;
};

struct LanKey : public OptionalHeader
{
   static const Headers id = Headers::LanKey;

   uint8_t key[16];
};

struct Xbox360Logo : public OptionalHeader
{
   static const Headers id = Headers::Xbox360Logo;
};

struct MultidiscMediaIds : public OptionalHeader
{
   static const Headers id = Headers::MultidiscMediaIds;
};

struct AlternateTitleIds : public OptionalHeader
{
   static const Headers id = Headers::AlternateTitleIds;

   std::vector<uint32_t> ids;
};

struct AdditionalTitleMemory : public OptionalHeader {
   static const Headers id = Headers::AdditionalTitleMemory;
};

struct ExportsByName : public OptionalHeader {
   static const Headers id = Headers::ExportsByName;
};

#pragma pack(pop)

} // namespace xex

#endif // XEX_OPTIONAL_HEADERS_H

```

`src/xex/rijndael-alf-fst.cpp`:

```cpp
/**
 * rijndael-alg-fst.c
 *
 * @version 3.0 (December 2000)
 *
 * Optimised ANSI C code for the Rijndael cipher (now AES)
 *
 * @author Vincent Rijmen <vincent.rijmen@esat.kuleuven.ac.be>
 * @author Antoon Bosselaers <antoon.bosselaers@esat.kuleuven.ac.be>
 * @author Paulo Barreto <paulo.barreto@terra.com.br>
 *
 * This code is hereby placed in the public domain.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ''AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include <assert.h>
#include <stdlib.h>

#include "rijndael-alg-fst.h"

/*
Te0[x] = S [x].[02, 01, 01, 03];
Te1[x] = S [x].[03, 02, 01, 01];
Te2[x] = S [x].[01, 03, 02, 01];
Te3[x] = S [x].[01, 01, 03, 02];
Te4[x] = S [x].[01, 01, 01, 01];

Td0[x] = Si[x].[0e, 09, 0d, 0b];
Td1[x] = Si[x].[0b, 0e, 09, 0d];
Td2[x] = Si[x].[0d, 0b, 0e, 09];
Td3[x] = Si[x].[09, 0d, 0b, 0e];
Td4[x] = Si[x].[01, 01, 01, 01];
*/

static const u32 Te0[256] = {
    0xc66363a5U, 0xf87c7c84U, 0xee777799U, 0xf67b7b8dU,
    0xfff2f20dU, 0xd66b6bbdU, 0xde6f6fb1U, 0x91c5c554U,
    0x60303050U, 0x02010103U, 0xce6767a9U, 0x562b2b7dU,
    0xe7fefe19U, 0xb5d7d762U, 0x4dababe6U, 0xec76769aU,
    0x8fcaca45U, 0x1f82829dU, 0x89c9c940U, 0xfa7d7d87U,
    0xeffafa15U, 0xb25959ebU, 0x8e4747c9U, 0xfbf0f00bU,
    0x41adadecU, 0xb3d4d467U, 0x5fa2a2fdU, 0x45afafeaU,
    0x239c9cbfU, 0x53a4a4f7U, 0xe4727296U, 0x9bc0c05bU,
    0x75b7b7c2U, 0xe1fdfd1cU, 0x3d9393aeU, 0x4c26266aU,
    0x6c36365aU, 0x7e3f3f41U, 0xf5f7f702U, 0x83cccc4fU,
    0x6834345cU, 0x51a5a5f4U, 0xd1e5e534U, 0xf9f1f108U,
    0xe2717193U, 0xabd8d873U, 0x62313153U, 0x2a15153fU,
    0x0804040cU, 0x95c7c752U, 0x46232365U, 0x9dc3c35eU,
    0x30181828U, 0x379696a1U, 0x0a05050fU, 0x2f9a9ab5U,
    0x0e070709U, 0x24121236U, 0x1b80809bU, 0xdfe2e23dU,
    0xcdebeb26U, 0x4e272769U, 0x7fb2b2cdU, 0xea75759fU,
    0x1209091bU, 0x1d83839eU, 0x582c2c74U, 0x341a1a2eU,
    0x361b1b2dU, 0xdc6e6eb2U, 0xb45a5aeeU, 0x5ba0a0fbU,
    0xa45252f6U, 0x763b3b4dU, 0xb7d6d661U, 0x7db3b3ceU,
    0x5229297bU, 0xdde3e33eU, 0x5e2f2f71U, 0x13848497U,
    0xa65353f5U, 0xb9d1d168U, 0x00000000U, 0xc1eded2cU,
    0x40202060U, 0xe3fcfc1fU, 0x79b1b1c8U, 0xb65b5bedU,
    0xd46a6abeU, 0x8dcbcb46U, 0x67bebed9U, 0x7239394bU,
    0x944a4adeU, 0x984c4cd4U, 0xb05858e8U, 0x85cfcf4aU,
    0xbbd0d06bU, 0xc5efef2aU, 0x4faaaae5U, 0xedfbfb16U,
    0x864343c5U, 0x9a4d4dd7U, 0x66333355U, 0x11858594U,
    0x8a4545cfU, 0xe9f9f910U, 0x04020206U, 0xfe7f7f81U,
    0xa05050f0U, 0x783c3c44U, 0x259f9fbaU, 0x4ba8a8e3U,
    0xa25151f3U, 0x5da3a3feU, 0x804040c0U, 0x058f8f8aU,
    0x3f9292adU, 0x219d9dbcU, 0x70383848U, 0xf1f5f504U,
    0x63bcbcdfU, 0x77b6b6c1U, 0xafdada75U, 0x42212163U,
    0x20101030U, 0xe5ffff1aU, 0xfdf3f30eU, 0xbfd2d26dU,
    0x81cdcd4cU, 0x180c0c14U, 0x26131335U, 0xc3ecec2fU,
    0xbe5f5fe1U, 0x359797a2U, 0x884444ccU, 0x2e171739U,
    0x93c4c457U, 0x55a7a7f2U, 0xfc7e7e82U, 0x7a3d3d47U,
    0xc86464acU, 0xba5d5de7U, 0x3219192bU, 0xe6737395U,
    0xc06060a0U, 0x19818198U, 0x9e4f4fd1U, 0xa3dcdc7fU,
    0x44222266U, 0x542a2a7eU, 0x3b9090abU, 0x0b888883U,
    0x8c4646caU, 0xc7eeee29U, 0x6bb8b8d3U, 0x2814143cU,
    0xa7dede79U, 0xbc5e5ee2U, 0x160b0b1dU, 0xaddbdb76U,
    0xdbe0e03bU, 0x64323256U, 0x743a3a4eU, 0x140a0a1eU,
    0x924949dbU, 0x0c06060aU, 0x4824246cU, 0xb85c5ce4U,
    0x9fc2c25dU, 0xbdd3d36eU, 0x43acacefU, 0xc46262a6U,
    0x399191a8U, 0x319595a4U, 0xd3e4e437U, 0xf279798bU,
    0xd5e7e732U, 0x8bc8c843U, 0x6e373759U, 0xda6d6db7U,
    0x018d8d8cU, 0xb1d5d564U, 0x9c4e4ed2U, 0x49a9a9e0U,
    0xd86c6cb4U, 0xac5656faU, 0xf3f4f407U, 0xcfeaea25U,
    0xca6565afU, 0xf47a7a8eU, 0x47aeaee9U, 0x10080818U,
    0x6fbabad5U, 0xf0787888U, 0x4a25256fU, 0x5c2e2e72U,
    0x381c1c24U, 0x57a6a6f1U, 0x73b4b4c7U, 0x97c6c651U,
    0xcbe8e823U, 0xa1dddd7cU, 0xe874749cU, 0x3e1f1f21U,
    0x964b4bddU, 0x61bdbddcU, 0x0d8b8b86U, 0x0f8a8a85U,
    0xe0707090U, 0x7c3e3e42U, 0x71b5b5c4U, 0xcc6666aaU,
    0x904848d8U, 0x06030305U, 0xf7f6f601U, 0x1c0e0e12U,
    0xc26161a3U, 0x6a35355fU, 0xae5757f9U, 0x69b9b9d0U,
    0x17868691U, 0x99c1c158U, 0x3a1d1d27U, 0x279e9eb9U,
    0xd9e1e138U, 0xebf8f813U, 0x2b9898b3U, 0x22111133U,
    0xd26969bbU, 0xa9d9d970U, 0x078e8e89U, 0x339494a7U,
    0x2d9b9bb6U, 0x3c1e1e22U, 0x15878792U, 0xc9e9e920U,
    0x87cece49U, 0xaa5555ffU, 0x50282878U, 0xa5dfdf7aU,
    0x038c8c8fU, 0x59a1a1f8U, 0x09898980U, 0x1a0d0d17U,
    0x65bfbfdaU, 0xd7e6e631U, 0x844242c6U, 0xd06868b8U,
    0x824141c3U, 0x299999b0U, 0x5a2d2d77U, 0x1e0f0f11U,
    0x7bb0b0cbU, 0xa85454fcU, 0x6dbbbbd6U, 0x2c16163aU,
};
static const u32 Te1[256] = {
    0xa5c66363U, 0x84f87c7cU, 0x99ee7777U, 0x8df67b7bU,
    0x0dfff2f2U, 0xbdd66b6bU, 0xb1de6f6fU, 0x5491c5c5U,
    0x50603030U, 0x03020101U, 0xa9ce6767U, 0x7d562b2bU,
    0x19e7fefeU, 0x62b5d7d7U, 0xe64dababU, 0x9aec7676U,
    0x458fcacaU, 0x9d1f8282U, 0x4089c9c9U, 0x87fa7d7dU,
    0x15effafaU, 0xebb25959U, 0xc98e4747U, 0x0bfbf0f0U,
    0xec41adadU, 0x67b3d4d4U, 0xfd5fa2a2U, 0xea45afafU,
    0xbf239c9cU, 0xf753a4a4U, 0x96e47272U, 0x5b9bc0c0U,
    0xc275b7b7U, 0x1ce1fdfdU, 0xae3d9393U, 0x6a4c2626U,
    0x5a6c3636U, 0x417e3f3fU, 0x02f5f7f7U, 0x4f83ccccU,
    0x5c683434U, 0xf451a5a5U, 0x34d1e5e5U, 0x08f9f1f1U,
    0x93e27171U, 0x73abd8d8U, 0x53623131U, 0x3f2a1515U,
    0x0c080404U, 0x5295c7c7U, 0x65462323U, 0x5e9dc3c3U,
    0x28301818U, 0xa1379696U, 0x0f0a0505U, 0xb52f9a9aU,
    0x090e0707U, 0x36241212U, 0x9b1b8080U, 0x3ddfe2e2U,
    0x26cdebebU, 0x694e2727U, 0xcd7fb2b2U, 0x9fea7575U,
    0x1b120909U, 0x9e1d8383U, 0x74582c2cU, 0x2e341a1aU,
    0x2d361b1bU, 0xb2dc6e6eU, 0xeeb45a5aU, 0xfb5ba0a0U,
    0xf6a45252U, 0x4d763b3bU, 0x61b7d6d6U, 0xce7db3b3U,
    0x7b522929U, 0x3edde3e3U, 0x715e2f2fU, 0x97138484U,
    0xf5a65353U, 0x68b9d1d1U, 0x00000000U, 0x2cc1ededU,
    0x60402020U, 0x1fe3fcfcU, 0xc879b1b1U, 0xedb65b5bU,
    0xbed46a6aU, 0x468dcbcbU, 0xd967bebeU, 0x4b723939U,
    0xde944a4aU, 0xd4984c4cU, 0xe8b05858U, 0x4a85cfcfU,
    0x6bbbd0d0U, 0x2ac5efefU, 0xe54faaaaU, 0x16edfbfbU,
    0xc5864343U, 0xd79a4d4dU, 0x55663333U, 0x94118585U,
    0xcf8a4545U, 0x10e9f9f9U, 0x06040202U, 0x81fe7f7fU,
    0xf0a05050U, 0x44783c3cU, 0xba259f9fU, 0xe34ba8a8U,
    0xf3a25151U, 0xfe5da3a3U, 0xc0804040U, 0x8a058f8fU,
    0xad3f9292U, 0xbc219d9dU, 0x48703838U, 0x04f1f5f5U,
    0xdf63bcbcU, 0xc177b6b6U, 0x75afdadaU, 0x63422121U,
    0x30201010U, 0x1ae5ffffU, 0x0efdf3f3U, 0x6dbfd2d2U,
    0x4c81cdcdU, 0x14180c0cU, 0x35261313U, 0x2fc3ececU,
    0xe1be5f5fU, 0xa2359797U, 0xcc884444U, 0x392e1717U,
    0x5793c4c4U, 0xf255a7a7U, 0x82fc7e7eU, 0x477a3d3dU,
    0xacc86464U, 0xe7ba5d5dU, 0x2b321919U, 0x95e67373U,
    0xa0c06060U, 0x98198181U, 0xd19e4f4fU, 0x7fa3dcdcU,
    0x66442222U, 0x7e542a2aU, 0xab3b9090U, 0x830b8888U,
    0xca8c4646U, 0x29c7eeeeU, 0xd36bb8b8U, 0x3c281414U,
    0x79a7dedeU, 0xe2bc5e5eU, 0x1d160b0bU, 0x76addbdbU,
    0x3bdbe0e0U, 0x56643232U, 0x4e743a3aU, 0x1e140a0aU,
    0xdb924949U, 0x0a0c0606U, 0x6c482424U, 0xe4b85c5cU,
    0x5d9fc2c2U, 0x6ebdd3d3U, 0xef43acacU, 0xa6c46262U,
    0xa8399191U, 0xa4319595U, 0x37d3e4e4U, 0x8bf27979U,
    0x32d5e7e7U, 0x438bc8c8U, 0x596e3737U, 0xb7da6d6dU,
    0x8c018d8dU, 0x64b1d5d5U, 0xd29c4e4eU, 0xe049a9a9U,
    0xb4d86c6cU, 0xfaac5656U, 0x07f3f4f4U, 0x25cfeaeaU,
    0xafca6565U, 0x8ef47a7aU, 0xe947aeaeU, 0x18100808U,
    0xd56fbabaU, 0x88f07878U, 0x6f4a2525U, 0x725c2e2eU,
    0x24381c1cU, 0xf157a6a6U, 0xc773b4b4U, 0x5197c6c6U,
    0x23cbe8e8U, 0x7ca1ddddU, 0x9ce87474U, 0x213e1f1fU,
    0xdd964b4bU, 0xdc61bdbdU, 0x860d8b8bU, 0x850f8a8aU,
    0x90e07070U, 0x427c3e3eU, 0xc471b5b5U, 0xaacc6666U,
    0xd8904848U, 0x05060303U, 0x01f7f6f6U, 0x121c0e0eU,
    0xa3c26161U, 0x5f6a3535U, 0xf9ae5757U, 0xd069b9b9U,
    0x91178686U, 0x5899c1c1U, 0x273a1d1dU, 0xb9279e9eU,
    0x38d9e1e1U, 0x13ebf8f8U, 0xb32b9898U, 0x33221111U,
    0xbbd26969U, 0x70a9d9d9U, 0x89078e8eU, 0xa7339494U,
    0xb62d9b9bU, 0x223c1e1eU, 0x92158787U, 0x20c9e9e9U,
    0x4987ceceU, 0xffaa5555U, 0x78502828U, 0x7aa5dfdfU,
    0x8f038c8cU, 0xf859a1a1U, 0x80098989U, 0x171a0d0dU,
    0xda65bfbfU, 0x31d7e6e6U, 0xc6844242U, 0xb8d06868U,
    0xc3824141U, 0xb0299999U, 0x775a2d2dU, 0x111e0f0fU,
    0xcb7bb0b0U, 0xfca85454U, 0xd66dbbbbU, 0x3a2c1616U,
};
static const u32 Te2[256] = {
    0x63a5c663U, 0x7c84f87cU, 0x7799ee77U, 0x7b8df67bU,
    0xf20dfff2U, 0x6bbdd66bU, 0x6fb1de6fU, 0xc55491c5U,
    0x30506030U, 0x01030201U, 0x67a9ce67U, 0x2b7d562bU,
    0xfe19e7feU, 0xd762b5d7U, 0xabe64dabU, 0x769aec76U,
    0xca458fcaU, 0x829d1f82U, 0xc94089c9U, 0x7d87fa7dU,
    0xfa15effaU, 0x59ebb259U, 0x47c98e47U, 0xf00bfbf0U,
    0xadec41adU, 0xd467b3d4U, 0xa2fd5fa2U, 0xafea45afU,
    0x9cbf239cU, 0xa4f753a4U, 0x7296e472U, 0xc05b9bc0U,
    0xb7c275b7U, 0xfd1ce1fdU, 0x93ae3d93U, 0x266a4c26U,
    0x365a6c36U, 0x3f417e3fU, 0xf702f5f7U, 0xcc4f83ccU,
    0x345c6834U, 0xa5f451a5U, 0xe534d1e5U, 0xf108f9f1U,
    0x7193e271U, 0xd873abd8U, 0x31536231U, 0x153f2a15U,
    0x040c0804U, 0xc75295c7U, 0x23654623U, 0xc35e9dc3U,
    0x18283018U, 0x96a13796U, 0x050f0a05U, 0x9ab52f9aU,
    0x07090e07U, 0x12362412U, 0x809b1b80U, 0xe23ddfe2U,
    0xeb26cdebU, 0x27694e27U, 0xb2cd7fb2U, 0x759fea75U,
    0x091b1209U, 0x839e1d83U, 0x2c74582cU, 0x1a2e341aU,
    0x1b2d361bU, 0x6eb2dc6eU, 0x5aeeb45aU, 0xa0fb5ba0U,
    0x52f6a452U, 0x3b4d763bU, 0xd661b7d6U, 0xb3ce7db3U,
    0x297b5229U, 0xe33edde3U, 0x2f715e2fU, 0x84971384U,
    0x53f5a653U, 0xd168b9d1U, 0x00000000U, 0xed2cc1edU,
    0x20604020U, 0xfc1fe3fcU, 0xb1c879b1U, 0x5bedb65bU,
    0x6abed46aU, 0xcb468dcbU, 0xbed967beU, 0x394b7239U,
    0x4ade944aU, 0x4cd4984cU, 0x58e8b058U, 0xcf4a85cfU,
    0xd06bbbd0U, 0xef2ac5efU, 0xaae54faaU, 0xfb16edfbU,
    0x43c58643U, 0x4dd79a4dU, 0x33556633U, 0x85941185U,
    0x45cf8a45U, 0xf910e9f9U, 0x02060402U, 0x7f81fe7fU,
    0x50f0a050U, 0x3c44783cU, 0x9fba259fU, 0xa8e34ba8U,
    0x51f3a251U, 0xa3fe5da3U, 0x40c08040U, 0x8f8a058fU,
    0x92ad3f92U, 0x9dbc219dU, 0x38487038U, 0xf504f1f5U,
    0xbcdf63bcU, 0xb6c177b6U, 0xda75afdaU, 0x21634221U,
    0x10302010U, 0xff1ae5ffU, 0xf30efdf3U, 0xd26dbfd2U,
    0xcd4c81cdU, 0x0c14180cU, 0x13352613U, 0xec2fc3ecU,
    0x5fe1be5fU, 0x97a23597U, 0x44cc8844U, 0x17392e17U,
    0xc45793c4U, 0xa7f255a7U, 0x7e82fc7eU, 0x3d477a3dU,
    0x64acc864U, 0x5de7ba5dU, 0x192b3219U, 0x7395e673U,
    0x60a0c060U, 0x81981981U, 0x4fd19e4fU, 0xdc7fa3dcU,
    0x22664422U, 0x2a7e542aU, 0x90ab3b90U, 0x88830b88U,
    0x46ca8c46U, 0xee29c7eeU, 0xb8d36bb8U, 0x143c2814U,
    0xde79a7deU, 0x5ee2bc5eU, 0x0b1d160bU, 0xdb76addbU,
    0xe03bdbe0U, 0x32566432U, 0x3a4e743aU, 0x0a1e140aU,
    0x49db9249U, 0x060a0c06U, 0x246c4824U, 0x5ce4b85cU,
    0xc25d9fc2U, 0xd36ebdd3U, 0xacef43acU, 0x62a6c462U,
    0x91a83991U, 0x95a43195U, 0xe437d3e4U, 0x798bf279U,
    0xe732d5e7U, 0xc8438bc8U, 0x37596e37U, 0x6db7da6dU,
    0x8d8c018dU, 0xd564b1d5U, 0x4ed29c4eU, 0xa9e049a9U,
    0x6cb4d86cU, 0x56faac56U, 0xf407f3f4U, 0xea25cfeaU,
    0x65afca65U, 0x7a8ef47aU, 0xaee947aeU, 0x08181008U,
    0xbad56fbaU, 0x7888f078U, 0x256f4a25U, 0x2e725c2eU,
    0x1c24381cU, 0xa6f157a6U, 0xb4c773b4U, 0xc65197c6U,
    0xe823cbe8U, 0xdd7ca1ddU, 0x749ce874U, 0x1f213e1fU,
    0x4bdd964bU, 0xbddc61bdU, 0x8b860d8bU, 0x8a850f8aU,
    0x7090e070U, 0x3e427c3eU, 0xb5c471b5U, 0x66aacc66U,
    0x48d89048U, 0x03050603U, 0xf601f7f6U, 0x0e121c0eU,
    0x61a3c261U, 0x355f6a35U, 0x57f9ae57U, 0xb9d069b9U,
    0x86911786U, 0xc15899c1U, 0x1d273a1dU, 0x9eb9279eU,
    0xe138d9e1U, 0xf813ebf8U, 0x98b32b98U, 0x11332211U,
    0x69bbd269U, 0xd970a9d9U, 0x8e89078eU, 0x94a73394U,
    0x9bb62d9bU, 0x1e223c1eU, 0x87921587U, 0xe920c9e9U,
    0xce4987ceU, 0x55ffaa55U, 0x28785028U, 0xdf7aa5dfU,
    0x8c8f038cU, 0xa1f859a1U, 0x89800989U, 0x0d171a0dU,
    0xbfda65bfU, 0xe631d7e6U, 0x42c68442U, 0x68b8d068U,
    0x41c38241U, 0x99b02999U, 0x2d775a2dU, 0x0f111e0fU,
    0xb0cb7bb0U, 0x54fca854U, 0xbbd66dbbU, 0x163a2c16U,
};
static const u32 Te3[256] = {

    0x6363a5c6U, 0x7c7c84f8U, 0x777799eeU, 0x7b7b8df6U,
    0xf2f20dffU, 0x6b6bbdd6U, 0x6f6fb1deU, 0xc5c55491U,
    0x30305060U, 0x01010302U, 0x6767a9ceU, 0x2b2b7d56U,
    0xfefe19e7U, 0xd7d762b5U, 0xababe64dU, 0x76769aecU,
    0xcaca458fU, 0x82829d1fU, 0xc9c94089U, 0x7d7d87faU,
    0xfafa15efU, 0x5959ebb2U, 0x4747c98eU, 0xf0f00bfbU,
    0xadadec41U, 0xd4d467b3U, 0xa2a2fd5fU, 0xafafea45U,
    0x9c9cbf23U, 0xa4a4f753U, 0x727296e4U, 0xc0c05b9bU,
    0xb7b7c275U, 0xfdfd1ce1U, 0x9393ae3dU, 0x26266a4cU,
    0x36365a6cU, 0x3f3f417eU, 0xf7f702f5U, 0xcccc4f83U,
    0x34345c68U, 0xa5a5f451U, 0xe5e534d1U, 0xf1f108f9U,
    0x717193e2U, 0xd8d873abU, 0x31315362U, 0x15153f2aU,
    0x04040c08U, 0xc7c75295U, 0x23236546U, 0xc3c35e9dU,
    0x18182830U, 0x9696a137U, 0x05050f0aU, 0x9a9ab52fU,
    0x0707090eU, 0x12123624U, 0x80809b1bU, 0xe2e23ddfU,
    0xebeb26cdU, 0x2727694eU, 0xb2b2cd7fU, 0x75759feaU,
    0x09091b12U, 0x83839e1dU, 0x2c2c7458U, 0x1a1a2e34U,
    0x1b1b2d36U, 0x6e6eb2dcU, 0x5a5aeeb4U, 0xa0a0fb5bU,
    0x5252f6a4U, 0x3b3b4d76U, 0xd6d661b7U, 0xb3b3ce7dU,
    0x29297b52U, 0xe3e33eddU, 0x2f2f715eU, 0x84849713U,
    0x5353f5a6U, 0xd1d168b9U, 0x00000000U, 0xeded2cc1U,
    0x20206040U, 0xfcfc1fe3U, 0xb1b1c879U, 0x5b5bedb6U,
    0x6a6abed4U, 0xcbcb468dU, 0xbebed967U, 0x39394b72U,
    0x4a4ade94U, 0x4c4cd498U, 0x5858e8b0U, 0xcfcf4a85U,
    0xd0d06bbbU, 0xefef2ac5U, 0xaaaae54fU, 0xfbfb16edU,
    0x4343c586U, 0x4d4dd79aU, 0x33335566U, 0x85859411U,
    0x4545cf8aU, 0xf9f910e9U, 0x02020604U, 0x7f7f81feU,
    0x5050f0a0U, 0x3c3c4478U, 0x9f9fba25U, 0xa8a8e34bU,
    0x5151f3a2U, 0xa3a3fe5dU, 0x4040c080U, 0x8f8f8a05U,
    0x9292ad3fU, 0x9d9dbc21U, 0x38384870U, 0xf5f504f1U,
    0xbcbcdf63U, 0xb6b6c177U, 0xdada75afU, 0x21216342U,
    0x10103020U, 0xffff1ae5U, 0xf3f30efdU, 0xd2d26dbfU,
    0xcdcd4c81U, 0x0c0c1418U, 0x13133526U, 0xecec2fc3U,
    0x5f5fe1beU, 0x9797a235U, 0x4444cc88U, 0x1717392eU,
    0xc4c45793U, 0xa7a7f255U, 0x7e7e82fcU, 0x3d3d477aU,
    0x6464acc8U, 0x5d5de7baU, 0x19192b32U, 0x737395e6U,
    0x6060a0c0U, 0x81819819U, 0x4f4fd19eU, 0xdcdc7fa3U,
    0x22226644U, 0x2a2a7e54U, 0x9090ab3bU, 0x8888830bU,
    0x4646ca8cU, 0xeeee29c7U, 0xb8b8d36bU, 0x14143c28U,
    0xdede79a7U, 0x5e5ee2bcU, 0x0b0b1d16U, 0xdbdb76adU,
    0xe0e03bdbU, 0x32325664U, 0x3a3a4e74U, 0x0a0a1e14U,
    0x4949db92U, 0x06060a0cU, 0x24246c48U, 0x5c5ce4b8U,
    0xc2c25d9fU, 0xd3d36ebdU, 0xacacef43U, 0x6262a6c4U,
    0x9191a839U, 0x9595a431U, 0xe4e437d3U, 0x79798bf2U,
    0xe7e732d5U, 0xc8c8438bU, 0x3737596eU, 0x6d6db7daU,
    0x8d8d8c01U, 0xd5d564b1U, 0x4e4ed29cU, 0xa9a9e049U,
    0x6c6cb4d8U, 0x5656faacU, 0xf4f407f3U, 0xeaea25cfU,
    0x6565afcaU, 0x7a7a8ef4U, 0xaeaee947U, 0x08081810U,
    0xbabad56fU, 0x787888f0U, 0x25256f4aU, 0x2e2e725cU,
    0x1c1c2438U, 0xa6a6f157U, 0xb4b4c773U, 0xc6c65197U,
    0xe8e823cbU, 0xdddd7ca1U, 0x74749ce8U, 0x1f1f213eU,
    0x4b4bdd96U, 0xbdbddc61U, 0x8b8b860dU, 0x8a8a850fU,
    0x707090e0U, 0x3e3e427cU, 0xb5b5c471U, 0x6666aaccU,
    0x4848d890U, 0x03030506U, 0xf6f601f7U, 0x0e0e121cU,
    0x6161a3c2U, 0x35355f6aU, 0x5757f9aeU, 0xb9b9d069U,
    0x86869117U, 0xc1c15899U, 0x1d1d273aU, 0x9e9eb927U,
    0xe1e138d9U, 0xf8f813ebU, 0x9898b32bU, 0x11113322U,
    0x6969bbd2U, 0xd9d970a9U, 0x8e8e8907U, 0x9494a733U,
    0x9b9bb62dU, 0x1e1e223cU, 0x87879215U, 0xe9e920c9U,
    0xcece4987U, 0x5555ffaaU, 0x28287850U, 0xdfdf7aa5U,
    0x8c8c8f03U, 0xa1a1f859U, 0x89898009U, 0x0d0d171aU,
    0xbfbfda65U, 0xe6e631d7U, 0x4242c684U, 0x6868b8d0U,
    0x4141c382U, 0x9999b029U, 0x2d2d775aU, 0x0f0f111eU,
    0xb0b0cb7bU, 0x5454fca8U, 0xbbbbd66dU, 0x16163a2cU,
};
static const u32 Te4[256] = {
    0x63636363U, 0x7c7c7c7cU, 0x77777777U, 0x7b7b7b7bU,
    0xf2f2f2f2U, 0x6b6b6b6bU, 0x6f6f6f6fU, 0xc5c5c5c5U,
    0x30303030U, 0x01010101U, 0x67676767U, 0x2b2b2b2bU,
    0xfefefefeU, 0xd7d7d7d7U, 0xababababU, 0x76767676U,
    0xcacacacaU, 0x82828282U, 0xc9c9c9c9U, 0x7d7d7d7dU,
    0xfafafafaU, 0x59595959U, 0x47474747U, 0xf0f0f0f0U,
    0xadadadadU, 0xd4d4d4d4U, 0xa2a2a2a2U, 0xafafafafU,
    0x9c9c9c9cU, 0xa4a4a4a4U, 0x72727272U, 0xc0c0c0c0U,
    0xb7b7b7b7U, 0xfdfdfdfdU, 0x93939393U, 0x26262626U,
    0x36363636U, 0x3f3f3f3fU, 0xf7f7f7f7U, 0xccccccccU,
    0x34343434U, 0xa5a5a5a5U, 0xe5e5e5e5U, 0xf1f1f1f1U,
    0x71717171U, 0xd8d8d8d8U, 0x31313131U, 0x15151515U,
    0x04040404U, 0xc7c7c7c7U, 0x23232323U, 0xc3c3c3c3U,
    0x18181818U, 0x96969696U, 0x05050505U, 0x9a9a9a9aU,
    0x07070707U, 0x12121212U, 0x80808080U, 0xe2e2e2e2U,
    0xebebebebU, 0x27272727U, 0xb2b2b2b2U, 0x75757575U,
    0x09090909U, 0x83838383U, 0x2c2c2c2cU, 0x1a1a1a1aU,
    0x1b1b1b1bU, 0x6e6e6e6eU, 0x5a5a5a5aU, 0xa0a0a0a0U,
    0x52525252U, 0x3b3b3b3bU, 0xd6d6d6d6U, 0xb3b3b3b3U,
    0x29292929U, 0xe3e3e3e3U, 0x2f2f2f2fU, 0x84848484U,
    0x53535353U, 0xd1d1d1d1U, 0x00000000U, 0xededededU,
    0x20202020U, 0xfcfcfcfcU, 0xb1b1b1b1U, 0x5b5b5b5bU,
    0x6a6a6a6aU, 0xcbcbcbcbU, 0xbebebebeU, 0x39393939U,
    0x4a4a4a4aU, 0x4c4c4c4cU, 0x58585858U, 0xcfcfcfcfU,
    0xd0d0d0d0U, 0xefefefefU, 0xaaaaaaaaU, 0xfbfbfbfbU,
    0x43434343U, 0x4d4d4d4dU, 0x33333333U, 0x85858585U,
    0x45454545U, 0xf9f9f9f9U, 0x02020202U, 0x7f7f7f7fU,
    0x50505050U, 0x3c3c3c3cU, 0x9f9f9f9fU, 0xa8a8a8a8U,
    0x51515151U, 0xa3a3a3a3U, 0x40404040U, 0x8f8f8f8fU,
    0x92929292U, 0x9d9d9d9dU, 0x38383838U, 0xf5f5f5f5U,
    0xbcbcbcbcU, 0xb6b6b6b6U, 0xdadadadaU, 0x21212121U,
    0x10101010U, 0xffffffffU, 0xf3f3f3f3U, 0xd2d2d2d2U,
    0xcdcdcdcdU, 0x0c0c0c0cU, 0x13131313U, 0xececececU,
    0x5f5f5f5fU, 0x97979797U, 0x44444444U, 0x17171717U,
    0xc4c4c4c4U, 0xa7a7a7a7U, 0x7e7e7e7eU, 0x3d3d3d3dU,
    0x64646464U, 0x5d5d5d5dU, 0x19191919U, 0x73737373U,
    0x60606060U, 0x81818181U, 0x4f4f4f4fU, 0xdcdcdcdcU,
    0x22222222U, 0x2a2a2a2aU, 0x90909090U, 0x88888888U,
    0x46464646U, 0xeeeeeeeeU, 0xb8b8b8b8U, 0x14141414U,
    0xdedededeU, 0x5e5e5e5eU, 0x0b0b0b0bU, 0xdbdbdbdbU,
    0xe0e0e0e0U, 0x32323232U, 0x3a3a3a3aU, 0x0a0a0a0aU,
    0x49494949U, 0x06060606U, 0x24242424U, 0x5c5c5c5cU,
    0xc2c2c2c2U, 0xd3d3d3d3U, 0xacacacacU, 0x62626262U,
    0x91919191U, 0x95959595U, 0xe4e4e4e4U, 0x79797979U,
    0xe7e7e7e7U, 0xc8c8c8c8U, 0x37373737U, 0x6d6d6d6dU,
    0x8d8d8d8dU, 0xd5d5d5d5U, 0x4e4e4e4eU, 0xa9a9a9a9U,
    0x6c6c6c6cU, 0x56565656U, 0xf4f4f4f4U, 0xeaeaeaeaU,
    0x65656565U, 0x7a7a7a7aU, 0xaeaeaeaeU, 0x08080808U,
    0xbabababaU, 0x78787878U, 0x25252525U, 0x2e2e2e2eU,
    0x1c1c1c1cU, 0xa6a6a6a6U, 0xb4b4b4b4U, 0xc6c6c6c6U,
    0xe8e8e8e8U, 0xddddddddU, 0x74747474U, 0x1f1f1f1fU,
    0x4b4b4b4bU, 0xbdbdbdbdU, 0x8b8b8b8bU, 0x8a8a8a8aU,
    0x70707070U, 0x3e3e3e3eU, 0xb5b5b5b5U, 0x66666666U,
    0x48484848U, 0x03030303U, 0xf6f6f6f6U, 0x0e0e0e0eU,
    0x61616161U, 0x35353535U, 0x57575757U, 0xb9b9b9b9U,
    0x86868686U, 0xc1c1c1c1U, 0x1d1d1d1dU, 0x9e9e9e9eU,
    0xe1e1e1e1U, 0xf8f8f8f8U, 0x98989898U, 0x11111111U,
    0x69696969U, 0xd9d9d9d9U, 0x8e8e8e8eU, 0x94949494U,
    0x9b9b9b9bU, 0x1e1e1e1eU, 0x87878787U, 0xe9e9e9e9U,
    0xcecececeU, 0x55555555U, 0x28282828U, 0xdfdfdfdfU,
    0x8c8c8c8cU, 0xa1a1a1a1U, 0x89898989U, 0x0d0d0d0dU,
    0xbfbfbfbfU, 0xe6e6e6e6U, 0x42424242U, 0x68686868U,
    0x41414141U, 0x99999999U, 0x2d2d2d2dU, 0x0f0f0f0fU,
    0xb0b0b0b0U, 0x54545454U, 0xbbbbbbbbU, 0x16161616U,
};
static const u32 Td0[256] = {
    0x51f4a750U, 0x7e416553U, 0x1a17a4c3U, 0x3a275e96U,
    0x3bab6bcbU, 0x1f9d45f1U, 0xacfa58abU, 0x4be30393U,
    0x2030fa55U, 0xad766df6U, 0x88cc7691U, 0xf5024c25U,
    0x4fe5d7fcU, 0xc52acbd7U, 0x26354480U, 0xb562a38fU,
    0xdeb15a49U, 0x25ba1b67U, 0x45ea0e98U, 0x5dfec0e1U,
    0xc32f7502U, 0x814cf012U, 0x8d4697a3U, 0x6bd3f9c6U,
    0x038f5fe7U, 0x15929c95U, 0xbf6d7aebU, 0x955259daU,
    0xd4be832dU, 0x587421d3U, 0x49e06929U, 0x8ec9c844U,
    0x75c2896aU, 0xf48e7978U, 0x99583e6bU, 0x27b971ddU,
    0xbee14fb6U, 0xf088ad17U, 0xc920ac66U, 0x7dce3ab4U,
    0x63df4a18U, 0xe51a3182U, 0x97513360U, 0x62537f45U,
    0xb16477e0U, 0xbb6bae84U, 0xfe81a01cU, 0xf9082b94U,
    0x70486858U, 0x8f45fd19U, 0x94de6c87U, 0x527bf8b7U,
    0xab73d323U, 0x724b02e2U, 0xe31f8f57U, 0x6655ab2aU,
    0xb2eb2807U, 0x2fb5c203U, 0x86c57b9aU, 0xd33708a5U,
    0x302887f2U, 0x23bfa5b2U, 0x02036abaU, 0xed16825cU,
    0x8acf1c2bU, 0xa779b492U, 0xf307f2f0U, 0x4e69e2a1U,
    0x65daf4cdU, 0x0605bed5U, 0xd134621fU, 0xc4a6fe8aU,
    0x342e539dU, 0xa2f355a0U, 0x058ae132U, 0xa4f6eb75U,
    0x0b83ec39U, 0x4060efaaU, 0x5e719f06U, 0xbd6e1051U,
    0x3e218af9U, 0x96dd063dU, 0xdd3e05aeU, 0x4de6bd46U,
    0x91548db5U, 0x71c45d05U, 0x0406d46fU, 0x605015ffU,
    0x1998fb24U, 0xd6bde997U, 0x894043ccU, 0x67d99e77U,
    0xb0e842bdU, 0x07898b88U, 0xe7195b38U, 0x79c8eedbU,
    0xa17c0a47U, 0x7c420fe9U, 0xf8841ec9U, 0x00000000U,
    0x09808683U, 0x322bed48U, 0x1e1170acU, 0x6c5a724eU,
    0xfd0efffbU, 0x0f853856U, 0x3daed51eU, 0x362d3927U,
    0x0a0fd964U, 0x685ca621U, 0x9b5b54d1U, 0x24362e3aU,
    0x0c0a67b1U, 0x9357e70fU, 0xb4ee96d2U, 0x1b9b919eU,
    0x80c0c54fU, 0x61dc20a2U, 0x5a774b69U, 0x1c121a16U,
    0xe293ba0aU, 0xc0a02ae5U, 0x3c22e043U, 0x121b171dU,
    0x0e090d0bU, 0xf28bc7adU, 0x2db6a8b9U, 0x141ea9c8U,
    0x57f11985U, 0xaf75074cU, 0xee99ddbbU, 0xa37f60fdU,
    0xf701269fU, 0x5c72f5bcU, 0x44663bc5U, 0x5bfb7e34U,
    0x8b432976U, 0xcb23c6dcU, 0xb6edfc68U, 0xb8e4f163U,
    0xd731dccaU, 0x42638510U, 0x13972240U, 0x84c61120U,
    0x854a247dU, 0xd2bb3df8U, 0xaef93211U, 0xc729a16dU,
    0x1d9e2f4bU, 0xdcb230f3U, 0x0d8652ecU, 0x77c1e3d0U,
    0x2bb3166cU, 0xa970b999U, 0x119448faU, 0x47e96422U,
    0xa8fc8cc4U, 0xa0f03f1aU, 0x567d2cd8U, 0x223390efU,
    0x87494ec7U, 0xd938d1c1U, 0x8ccaa2feU, 0x98d40b36U,
    0xa6f581cfU, 0xa57ade28U, 0xdab78e26U, 0x3fadbfa4U,
    0x2c3a9de4U, 0x5078920dU, 0x6a5fcc9bU, 0x547e4662U,
    0xf68d13c2U, 0x90d8b8e8U, 0x2e39f75eU, 0x82c3aff5U,
    0x9f5d80beU, 0x69d0937cU, 0x6fd52da9U, 0xcf2512b3U,
    0xc8ac993bU, 0x10187da7U, 0xe89c636eU, 0xdb3bbb7bU,
    0xcd267809U, 0x6e5918f4U, 0xec9ab701U, 0x834f9aa8U,
    0xe6956e65U, 0xaaffe67eU, 0x21bccf08U, 0xef15e8e6U,
    0xbae79bd9U, 0x4a6f36ceU, 0xea9f09d4U, 0x29b07cd6U,
    0x31a4b2afU, 0x2a3f2331U, 0xc6a59430U, 0x35a266c0U,
    0x744ebc37U, 0xfc82caa6U, 0xe090d0b0U, 0x33a7d815U,
    0xf104984aU, 0x41ecdaf7U, 0x7fcd500eU, 0x1791f62fU,
    0x764dd68dU, 0x43efb04dU, 0xccaa4d54U, 0xe49604dfU,
    0x9ed1b5e3U, 0x4c6a881bU, 0xc12c1fb8U, 0x4665517fU,
    0x9d5eea04U, 0x018c355dU, 0xfa877473U, 0xfb0b412eU,
    0xb3671d5aU, 0x92dbd252U, 0xe9105633U, 0x6dd64713U,
    0x9ad7618cU, 0x37a10c7aU, 0x59f8148eU, 0xeb133c89U,
    0xcea927eeU, 0xb761c935U, 0xe11ce5edU, 0x7a47b13cU,
    0x9cd2df59U, 0x55f2733fU, 0x1814ce79U, 0x73c737bfU,
    0x53f7cdeaU, 0x5ffdaa5bU, 0xdf3d6f14U, 0x7844db86U,
    0xcaaff381U, 0xb968c43eU, 0x3824342cU, 0xc2a3405fU,
    0x161dc372U, 0xbce2250cU, 0x283c498bU, 0xff0d9541U,
    0x39a80171U, 0x080cb3deU, 0xd8b4e49cU, 0x6456c190U,
    0x7bcb8461U, 0xd532b670U, 0x486c5c74U, 0xd0b85742U,
};
static const u32 Td1[256] = {
    0x5051f4a7U, 0x537e4165U, 0xc31a17a4U, 0x963a275eU,
    0xcb3bab6bU, 0xf11f9d45U, 0xabacfa58U, 0x934be303U,
    0x552030faU, 0xf6ad766dU, 0x9188cc76U, 0x25f5024cU,
    0xfc4fe5d7U, 0xd7c52acbU, 0x80263544U, 0x8fb562a3U,
    0x49deb15aU, 0x6725ba1bU, 0x9845ea0eU, 0xe15dfec0U,
    0x02c32f75U, 0x12814cf0U, 0xa38d4697U, 0xc66bd3f9U,
    0xe7038f5fU, 0x9515929cU, 0xebbf6d7aU, 0xda955259U,
    0x2dd4be83U, 0xd3587421U, 0x2949e069U, 0x448ec9c8U,
    0x6a75c289U, 0x78f48e79U, 0x6b99583eU, 0xdd27b971U,
    0xb6bee14fU, 0x17f088adU, 0x66c920acU, 0xb47dce3aU,
    0x1863df4aU, 0x82e51a31U, 0x60975133U, 0x4562537fU,
    0xe0b16477U, 0x84bb6baeU, 0x1cfe81a0U, 0x94f9082bU,
    0x58704868U, 0x198f45fdU, 0x8794de6cU, 0xb7527bf8U,
    0x23ab73d3U, 0xe2724b02U, 0x57e31f8fU, 0x2a6655abU,
    0x07b2eb28U, 0x032fb5c2U, 0x9a86c57bU, 0xa5d33708U,
    0xf2302887U, 0xb223bfa5U, 0xba02036aU, 0x5ced1682U,
    0x2b8acf1cU, 0x92a779b4U, 0xf0f307f2U, 0xa14e69e2U,
    0xcd65daf4U, 0xd50605beU, 0x1fd13462U, 0x8ac4a6feU,
    0x9d342e53U, 0xa0a2f355U, 0x32058ae1U, 0x75a4f6ebU,
    0x390b83ecU, 0xaa4060efU, 0x065e719fU, 0x51bd6e10U,
    0xf93e218aU, 0x3d96dd06U, 0xaedd3e05U, 0x464de6bdU,
    0xb591548dU, 0x0571c45dU, 0x6f0406d4U, 0xff605015U,
    0x241998fbU, 0x97d6bde9U, 0xcc894043U, 0x7767d99eU,
    0xbdb0e842U, 0x8807898bU, 0x38e7195bU, 0xdb79c8eeU,
    0x47a17c0aU, 0xe97c420fU, 0xc9f8841eU, 0x00000000U,
    0x83098086U, 0x48322bedU, 0xac1e1170U, 0x4e6c5a72U,
    0xfbfd0effU, 0x560f8538U, 0x1e3daed5U, 0x27362d39U,
    0x640a0fd9U, 0x21685ca6U, 0xd19b5b54U, 0x3a24362eU,
    0xb10c0a67U, 0x0f9357e7U, 0xd2b4ee96U, 0x9e1b9b91U,
    0x4f80c0c5U, 0xa261dc20U, 0x695a774bU, 0x161c121aU,
    0x0ae293baU, 0xe5c0a02aU, 0x433c22e0U, 0x1d121b17U,
    0x0b0e090dU, 0xadf28bc7U, 0xb92db6a8U, 0xc8141ea9U,
    0x8557f119U, 0x4caf7507U, 0xbbee99ddU, 0xfda37f60U,
    0x9ff70126U, 0xbc5c72f5U, 0xc544663bU, 0x345bfb7eU,
    0x768b4329U, 0xdccb23c6U, 0x68b6edfcU, 0x63b8e4f1U,
    0xcad731dcU, 0x10426385U, 0x40139722U, 0x2084c611U,
    0x7d854a24U, 0xf8d2bb3dU, 0x11aef932U, 0x6dc729a1U,
    0x4b1d9e2fU, 0xf3dcb230U, 0xec0d8652U, 0xd077c1e3U,
    0x6c2bb316U, 0x99a970b9U, 0xfa119448U, 0x2247e964U,
    0xc4a8fc8cU, 0x1aa0f03fU, 0xd8567d2cU, 0xef223390U,
    0xc787494eU, 0xc1d938d1U, 0xfe8ccaa2U, 0x3698d40bU,
    0xcfa6f581U, 0x28a57adeU, 0x26dab78eU, 0xa43fadbfU,
    0xe42c3a9dU, 0x0d507892U, 0x9b6a5fccU, 0x62547e46U,
    0xc2f68d13U, 0xe890d8b8U, 0x5e2e39f7U, 0xf582c3afU,
    0xbe9f5d80U, 0x7c69d093U, 0xa96fd52dU, 0xb3cf2512U,
    0x3bc8ac99U, 0xa710187dU, 0x6ee89c63U, 0x7bdb3bbbU,
    0x09cd2678U, 0xf46e5918U, 0x01ec9ab7U, 0xa8834f9aU,
    0x65e6956eU, 0x7eaaffe6U, 0x0821bccfU, 0xe6ef15e8U,
    0xd9bae79bU, 0xce4a6f36U, 0xd4ea9f09U, 0xd629b07cU,
    0xaf31a4b2U, 0x312a3f23U, 0x30c6a594U, 0xc035a266U,
    0x37744ebcU, 0xa6fc82caU, 0xb0e090d0U, 0x1533a7d8U,
    0x4af10498U, 0xf741ecdaU, 0x0e7fcd50U, 0x2f1791f6U,
    0x8d764dd6U, 0x4d43efb0U, 0x54ccaa4dU, 0xdfe49604U,
    0xe39ed1b5U, 0x1b4c6a88U, 0xb8c12c1fU, 0x7f466551U,
    0x049d5eeaU, 0x5d018c35U, 0x73fa8774U, 0x2efb0b41U,
    0x5ab3671dU, 0x5292dbd2U, 0x33e91056U, 0x136dd647U,
    0x8c9ad761U, 0x7a37a10cU, 0x8e59f814U, 0x89eb133cU,
    0xeecea927U, 0x35b761c9U, 0xede11ce5U, 0x3c7a47b1U,
    0x599cd2dfU, 0x3f55f273U, 0x791814ceU, 0xbf73c737U,
    0xea53f7cdU, 0x5b5ffdaaU, 0x14df3d6fU, 0x867844dbU,
    0x81caaff3U, 0x3eb968c4U, 0x2c382434U, 0x5fc2a340U,
    0x72161dc3U, 0x0cbce225U, 0x8b283c49U, 0x41ff0d95U,
    0x7139a801U, 0xde080cb3U, 0x9cd8b4e4U, 0x906456c1U,
    0x617bcb84U, 0x70d532b6U, 0x74486c5cU, 0x42d0b857U,
};
static const u32 Td2[256] = {
    0xa75051f4U, 0x65537e41U, 0xa4c31a17U, 0x5e963a27U,
    0x6bcb3babU, 0x45f11f9dU, 0x58abacfaU, 0x03934be3U,
    0xfa552030U, 0x6df6ad76U, 0x769188ccU, 0x4c25f502U,
    0xd7fc4fe5U, 0xcbd7c52aU, 0x44802635U, 0xa38fb562U,
    0x5a49deb1U, 0x1b6725baU, 0x0e9845eaU, 0xc0e15dfeU,
    0x7502c32fU, 0xf012814cU, 0x97a38d46U, 0xf9c66bd3U,
    0x5fe7038fU, 0x9c951592U, 0x7aebbf6dU, 0x59da9552U,
    0x832dd4beU, 0x21d35874U, 0x692949e0U, 0xc8448ec9U,
    0x896a75c2U, 0x7978f48eU, 0x3e6b9958U, 0x71dd27b9U,
    0x4fb6bee1U, 0xad17f088U, 0xac66c920U, 0x3ab47dceU,
    0x4a1863dfU, 0x3182e51aU, 0x33609751U, 0x7f456253U,
    0x77e0b164U, 0xae84bb6bU, 0xa01cfe81U, 0x2b94f908U,
    0x68587048U, 0xfd198f45U, 0x6c8794deU, 0xf8b7527bU,
    0xd323ab73U, 0x02e2724bU, 0x8f57e31fU, 0xab2a6655U,
    0x2807b2ebU, 0xc2032fb5U, 0x7b9a86c5U, 0x08a5d337U,
    0x87f23028U, 0xa5b223bfU, 0x6aba0203U, 0x825ced16U,
    0x1c2b8acfU, 0xb492a779U, 0xf2f0f307U, 0xe2a14e69U,
    0xf4cd65daU, 0xbed50605U, 0x621fd134U, 0xfe8ac4a6U,
    0x539d342eU, 0x55a0a2f3U, 0xe132058aU, 0xeb75a4f6U,
    0xec390b83U, 0xefaa4060U, 0x9f065e71U, 0x1051bd6eU,

    0x8af93e21U, 0x063d96ddU, 0x05aedd3eU, 0xbd464de6U,
    0x8db59154U, 0x5d0571c4U, 0xd46f0406U, 0x15ff6050U,
    0xfb241998U, 0xe997d6bdU, 0x43cc8940U, 0x9e7767d9U,
    0x42bdb0e8U, 0x8b880789U, 0x5b38e719U, 0xeedb79c8U,
    0x0a47a17cU, 0x0fe97c42U, 0x1ec9f884U, 0x00000000U,
    0x86830980U, 0xed48322bU, 0x70ac1e11U, 0x724e6c5aU,
    0xfffbfd0eU, 0x38560f85U, 0xd51e3daeU, 0x3927362dU,
    0xd9640a0fU, 0xa621685cU, 0x54d19b5bU, 0x2e3a2436U,
    0x67b10c0aU, 0xe70f9357U, 0x96d2b4eeU, 0x919e1b9bU,
    0xc54f80c0U, 0x20a261dcU, 0x4b695a77U, 0x1a161c12U,
    0xba0ae293U, 0x2ae5c0a0U, 0xe0433c22U, 0x171d121bU,
    0x0d0b0e09U, 0xc7adf28bU, 0xa8b92db6U, 0xa9c8141eU,
    0x198557f1U, 0x074caf75U, 0xddbbee99U, 0x60fda37fU,
    0x269ff701U, 0xf5bc5c72U, 0x3bc54466U, 0x7e345bfbU,
    0x29768b43U, 0xc6dccb23U, 0xfc68b6edU, 0xf163b8e4U,
    0xdccad731U, 0x85104263U, 0x22401397U, 0x112084c6U,
    0x247d854aU, 0x3df8d2bbU, 0x3211aef9U, 0xa16dc729U,
    0x2f4b1d9eU, 0x30f3dcb2U, 0x52ec0d86U, 0xe3d077c1U,
    0x166c2bb3U, 0xb999a970U, 0x48fa1194U, 0x642247e9U,
    0x8cc4a8fcU, 0x3f1aa0f0U, 0x2cd8567dU, 0x90ef2233U,
    0x4ec78749U, 0xd1c1d938U, 0xa2fe8ccaU, 0x0b3698d4U,
    0x81cfa6f5U, 0xde28a57aU, 0x8e26dab7U, 0xbfa43fadU,
    0x9de42c3aU, 0x920d5078U, 0xcc9b6a5fU, 0x4662547eU,
    0x13c2f68dU, 0xb8e890d8U, 0xf75e2e39U, 0xaff582c3U,
    0x80be9f5dU, 0x937c69d0U, 0x2da96fd5U, 0x12b3cf25U,
    0x993bc8acU, 0x7da71018U, 0x636ee89cU, 0xbb7bdb3bU,
    0x7809cd26U, 0x18f46e59U, 0xb701ec9aU, 0x9aa8834fU,
    0x6e65e695U, 0xe67eaaffU, 0xcf0821bcU, 0xe8e6ef15U,
    0x9bd9bae7U, 0x36ce4a6fU, 0x09d4ea9fU, 0x7cd629b0U,
    0xb2af31a4U, 0x23312a3fU, 0x9430c6a5U, 0x66c035a2U,
    0xbc37744eU, 0xcaa6fc82U, 0xd0b0e090U, 0xd81533a7U,
    0x984af104U, 0xdaf741ecU, 0x500e7fcdU, 0xf62f1791U,
    0xd68d764dU, 0xb04d43efU, 0x4d54ccaaU, 0x04dfe496U,
    0xb5e39ed1U, 0x881b4c6aU, 0x1fb8c12cU, 0x517f4665U,
    0xea049d5eU, 0x355d018cU, 0x7473fa87U, 0x412efb0bU,
    0x1d5ab367U, 0xd25292dbU, 0x5633e910U, 0x47136dd6U,
    0x618c9ad7U, 0x0c7a37a1U, 0x148e59f8U, 0x3c89eb13U,
    0x27eecea9U, 0xc935b761U, 0xe5ede11cU, 0xb13c7a47U,
    0xdf599cd2U, 0x733f55f2U, 0xce791814U, 0x37bf73c7U,
    0xcdea53f7U, 0xaa5b5ffdU, 0x6f14df3dU, 0xdb867844U,
    0xf381caafU, 0xc43eb968U, 0x342c3824U, 0x405fc2a3U,
    0xc372161dU, 0x250cbce2U, 0x498b283cU, 0x9541ff0dU,
    0x017139a8U, 0xb3de080cU, 0xe49cd8b4U, 0xc1906456U,
    0x84617bcbU, 0xb670d532U, 0x5c74486cU, 0x5742d0b8U,
};
static const u32 Td3[256] = {
    0xf4a75051U, 0x4165537eU, 0x17a4c31aU, 0x275e963aU,
    0xab6bcb3bU, 0x9d45f11fU, 0xfa58abacU, 0xe303934bU,
    0x30fa5520U, 0x766df6adU, 0xcc769188U, 0x024c25f5U,
    0xe5d7fc4fU, 0x2acbd7c5U, 0x35448026U, 0x62a38fb5U,
    0xb15a49deU, 0xba1b6725U, 0xea0e9845U, 0xfec0e15dU,
    0x2f7502c3U, 0x4cf01281U, 0x4697a38dU, 0xd3f9c66bU,
    0x8f5fe703U, 0x929c9515U, 0x6d7aebbfU, 0x5259da95U,
    0xbe832dd4U, 0x7421d358U, 0xe0692949U, 0xc9c8448eU,
    0xc2896a75U, 0x8e7978f4U, 0x583e6b99U, 0xb971dd27U,
    0xe14fb6beU, 0x88ad17f0U, 0x20ac66c9U, 0xce3ab47dU,
    0xdf4a1863U, 0x1a3182e5U, 0x51336097U, 0x537f4562U,
    0x6477e0b1U, 0x6bae84bbU, 0x81a01cfeU, 0x082b94f9U,
    0x48685870U, 0x45fd198fU, 0xde6c8794U, 0x7bf8b752U,
    0x73d323abU, 0x4b02e272U, 0x1f8f57e3U, 0x55ab2a66U,
    0xeb2807b2U, 0xb5c2032fU, 0xc57b9a86U, 0x3708a5d3U,
    0x2887f230U, 0xbfa5b223U, 0x036aba02U, 0x16825cedU,
    0xcf1c2b8aU, 0x79b492a7U, 0x07f2f0f3U, 0x69e2a14eU,
    0xdaf4cd65U, 0x05bed506U, 0x34621fd1U, 0xa6fe8ac4U,
    0x2e539d34U, 0xf355a0a2U, 0x8ae13205U, 0xf6eb75a4U,
    0x83ec390bU, 0x60efaa40U, 0x719f065eU, 0x6e1051bdU,
    0x218af93eU, 0xdd063d96U, 0x3e05aeddU, 0xe6bd464dU,
    0x548db591U, 0xc45d0571U, 0x06d46f04U, 0x5015ff60U,
    0x98fb2419U, 0xbde997d6U, 0x4043cc89U, 0xd99e7767U,
    0xe842bdb0U, 0x898b8807U, 0x195b38e7U, 0xc8eedb79U,
    0x7c0a47a1U, 0x420fe97cU, 0x841ec9f8U, 0x00000000U,
    0x80868309U, 0x2bed4832U, 0x1170ac1eU, 0x5a724e6cU,
    0x0efffbfdU, 0x8538560fU, 0xaed51e3dU, 0x2d392736U,
    0x0fd9640aU, 0x5ca62168U, 0x5b54d19bU, 0x362e3a24U,
    0x0a67b10cU, 0x57e70f93U, 0xee96d2b4U, 0x9b919e1bU,
    0xc0c54f80U, 0xdc20a261U, 0x774b695aU, 0x121a161cU,
    0x93ba0ae2U, 0xa02ae5c0U, 0x22e0433cU, 0x1b171d12U,
    0x090d0b0eU, 0x8bc7adf2U, 0xb6a8b92dU, 0x1ea9c814U,
    0xf1198557U, 0x75074cafU, 0x99ddbbeeU, 0x7f60fda3U,
    0x01269ff7U, 0x72f5bc5cU, 0x663bc544U, 0xfb7e345bU,
    0x4329768bU, 0x23c6dccbU, 0xedfc68b6U, 0xe4f163b8U,
    0x31dccad7U, 0x63851042U, 0x97224013U, 0xc6112084U,
    0x4a247d85U, 0xbb3df8d2U, 0xf93211aeU, 0x29a16dc7U,
    0x9e2f4b1dU, 0xb230f3dcU, 0x8652ec0dU, 0xc1e3d077U,
    0xb3166c2bU, 0x70b999a9U, 0x9448fa11U, 0xe9642247U,
    0xfc8cc4a8U, 0xf03f1aa0U, 0x7d2cd856U, 0x3390ef22U,
    0x494ec787U, 0x38d1c1d9U, 0xcaa2fe8cU, 0xd40b3698U,
    0xf581cfa6U, 0x7ade28a5U, 0xb78e26daU, 0xadbfa43fU,
    0x3a9de42cU, 0x78920d50U, 0x5fcc9b6aU, 0x7e466254U,
    0x8d13c2f6U, 0xd8b8e890U, 0x39f75e2eU, 0xc3aff582U,
    0x5d80be9fU, 0xd0937c69U, 0xd52da96fU, 0x2512b3cfU,
    0xac993bc8U, 0x187da710U, 0x9c636ee8U, 0x3bbb7bdbU,
    0x267809cdU, 0x5918f46eU, 0x9ab701ecU, 0x4f9aa883U,
    0x956e65e6U, 0xffe67eaaU, 0xbccf0821U, 0x15e8e6efU,
    0xe79bd9baU, 0x6f36ce4aU, 0x9f09d4eaU, 0xb07cd629U,
    0xa4b2af31U, 0x3f23312aU, 0xa59430c6U, 0xa266c035U,
    0x4ebc3774U, 0x82caa6fcU, 0x90d0b0e0U, 0xa7d81533U,
    0x04984af1U, 0xecdaf741U, 0xcd500e7fU, 0x91f62f17U,
    0x4dd68d76U, 0xefb04d43U, 0xaa4d54ccU, 0x9604dfe4U,
    0xd1b5e39eU, 0x6a881b4cU, 0x2c1fb8c1U, 0x65517f46U,
    0x5eea049dU, 0x8c355d01U, 0x877473faU, 0x0b412efbU,
    0x671d5ab3U, 0xdbd25292U, 0x105633e9U, 0xd647136dU,
    0xd7618c9aU, 0xa10c7a37U, 0xf8148e59U, 0x133c89ebU,
    0xa927eeceU, 0x61c935b7U, 0x1ce5ede1U, 0x47b13c7aU,
    0xd2df599cU, 0xf2733f55U, 0x14ce7918U, 0xc737bf73U,
    0xf7cdea53U, 0xfdaa5b5fU, 0x3d6f14dfU, 0x44db8678U,
    0xaff381caU, 0x68c43eb9U, 0x24342c38U, 0xa3405fc2U,
    0x1dc37216U, 0xe2250cbcU, 0x3c498b28U, 0x0d9541ffU,
    0xa8017139U, 0x0cb3de08U, 0xb4e49cd8U, 0x56c19064U,
    0xcb84617bU, 0x32b670d5U, 0x6c5c7448U, 0xb85742d0U,
};
static const u32 Td4[256] = {
    0x52525252U, 0x09090909U, 0x6a6a6a6aU, 0xd5d5d5d5U,
    0x30303030U, 0x36363636U, 0xa5a5a5a5U, 0x38383838U,
    0xbfbfbfbfU, 0x40404040U, 0xa3a3a3a3U, 0x9e9e9e9eU,
    0x81818181U, 0xf3f3f3f3U, 0xd7d7d7d7U, 0xfbfbfbfbU,
    0x7c7c7c7cU, 0xe3e3e3e3U, 0x39393939U, 0x82828282U,
    0x9b9b9b9bU, 0x2f2f2f2fU, 0xffffffffU, 0x87878787U,
    0x34343434U, 0x8e8e8e8eU, 0x43434343U, 0x44444444U,
    0xc4c4c4c4U, 0xdedededeU, 0xe9e9e9e9U, 0xcbcbcbcbU,
    0x54545454U, 0x7b7b7b7bU, 0x94949494U, 0x32323232U,
    0xa6a6a6a6U, 0xc2c2c2c2U, 0x23232323U, 0x3d3d3d3dU,
    0xeeeeeeeeU, 0x4c4c4c4cU, 0x95959595U, 0x0b0b0b0bU,
    0x42424242U, 0xfafafafaU, 0xc3c3c3c3U, 0x4e4e4e4eU,
    0x08080808U, 0x2e2e2e2eU, 0xa1a1a1a1U, 0x66666666U,
    0x28282828U, 0xd9d9d9d9U, 0x24242424U, 0xb2b2b2b2U,
    0x76767676U, 0x5b5b5b5bU, 0xa2a2a2a2U, 0x49494949U,
    0x6d6d6d6dU, 0x8b8b8b8bU, 0xd1d1d1d1U, 0x25252525U,
    0x72727272U, 0xf8f8f8f8U, 0xf6f6f6f6U, 0x64646464U,
    0x86868686U, 0x68686868U, 0x98989898U, 0x16161616U,
    0xd4d4d4d4U, 0xa4a4a4a4U, 0x5c5c5c5cU, 0xccccccccU,
    0x5d5d5d5dU, 0x65656565U, 0xb6b6b6b6U, 0x92929292U,
    0x6c6c6c6cU, 0x70707070U, 0x48484848U, 0x50505050U,
    0xfdfdfdfdU, 0xededededU, 0xb9b9b9b9U, 0xdadadadaU,
    0x5e5e5e5eU, 0x15151515U, 0x46464646U, 0x57575757U,
    0xa7a7a7a7U, 0x8d8d8d8dU, 0x9d9d9d9dU, 0x84848484U,
    0x90909090U, 0xd8d8d8d8U, 0xababababU, 0x00000000U,
    0x8c8c8c8cU, 0xbcbcbcbcU, 0xd3d3d3d3U, 0x0a0a0a0aU,
    0xf7f7f7f7U, 0xe4e4e4e4U, 0x58585858U, 0x05050505U,
    0xb8b8b8b8U, 0xb3b3b3b3U, 0x45454545U, 0x06060606U,
    0xd0d0d0d0U, 0x2c2c2c2cU, 0x1e1e1e1eU, 0x8f8f8f8fU,
    0xcacacacaU, 0x3f3f3f3fU, 0x0f0f0f0fU, 0x02020202U,
    0xc1c1c1c1U, 0xafafafafU, 0xbdbdbdbdU, 0x03030303U,
    0x01010101U, 0x13131313U, 0x8a8a8a8aU, 0x6b6b6b6bU,
    0x3a3a3a3aU, 0x91919191U, 0x11111111U, 0x41414141U,
    0x4f4f4f4fU, 0x67676767U, 0xdcdcdcdcU, 0xeaeaeaeaU,
    0x97979797U, 0xf2f2f2f2U, 0xcfcfcfcfU, 0xcecececeU,
    0xf0f0f0f0U, 0xb4b4b4b4U, 0xe6e6e6e6U, 0x73737373U,
    0x96969696U, 0xacacacacU, 0x74747474U, 0x22222222U,
    0xe7e7e7e7U, 0xadadadadU, 0x35353535U, 0x85858585U,
    0xe2e2e2e2U, 0xf9f9f9f9U, 0x37373737U, 0xe8e8e8e8U,
    0x1c1c1c1cU, 0x75757575U, 0xdfdfdfdfU, 0x6e6e6e6eU,
    0x47474747U, 0xf1f1f1f1U, 0x1a1a1a1aU, 0x71717171U,
    0x1d1d1d1dU, 0x29292929U, 0xc5c5c5c5U, 0x89898989U,
    0x6f6f6f6fU, 0xb7b7b7b7U, 0x62626262U, 0x0e0e0e0eU,
    0xaaaaaaaaU, 0x18181818U, 0xbebebebeU, 0x1b1b1b1bU,
    0xfcfcfcfcU, 0x56565656U, 0x3e3e3e3eU, 0x4b4b4b4bU,
    0xc6c6c6c6U, 0xd2d2d2d2U, 0x79797979U, 0x20202020U,
    0x9a9a9a9aU, 0xdbdbdbdbU, 0xc0c0c0c0U, 0xfefefefeU,
    0x78787878U, 0xcdcdcdcdU, 0x5a5a5a5aU, 0xf4f4f4f4U,
    0x1f1f1f1fU, 0xddddddddU, 0xa8a8a8a8U, 0x33333333U,
    0x88888888U, 0x07070707U, 0xc7c7c7c7U, 0x31313131U,
    0xb1b1b1b1U, 0x12121212U, 0x10101010U, 0x59595959U,
    0x27272727U, 0x80808080U, 0xececececU, 0x5f5f5f5fU,
    0x60606060U, 0x51515151U, 0x7f7f7f7fU, 0xa9a9a9a9U,
    0x19191919U, 0xb5b5b5b5U, 0x4a4a4a4aU, 0x0d0d0d0dU,
    0x2d2d2d2dU, 0xe5e5e5e5U, 0x7a7a7a7aU, 0x9f9f9f9fU,
    0x93939393U, 0xc9c9c9c9U, 0x9c9c9c9cU, 0xefefefefU,
    0xa0a0a0a0U, 0xe0e0e0e0U, 0x3b3b3b3bU, 0x4d4d4d4dU,
    0xaeaeaeaeU, 0x2a2a2a2aU, 0xf5f5f5f5U, 0xb0b0b0b0U,
    0xc8c8c8c8U, 0xebebebebU, 0xbbbbbbbbU, 0x3c3c3c3cU,
    0x83838383U, 0x53535353U, 0x99999999U, 0x61616161U,
    0x17171717U, 0x2b2b2b2bU, 0x04040404U, 0x7e7e7e7eU,
    0xbabababaU, 0x77777777U, 0xd6d6d6d6U, 0x26262626U,
    0xe1e1e1e1U, 0x69696969U, 0x14141414U, 0x63636363U,
    0x55555555U, 0x21212121U, 0x0c0c0c0cU, 0x7d7d7d7dU,
};
static const u32 rcon[] = {
	0x01000000, 0x02000000, 0x04000000, 0x08000000,
	0x10000000, 0x20000000, 0x40000000, 0x80000000,
	0x1B000000, 0x36000000, /* for 128-bit blocks, Rijndael never uses more than 10 rcon values */
};

#define SWAP(x) (_lrotl(x, 8) & 0x00ff00ff | _lrotr(x, 8) & 0xff00ff00)

#ifdef _MSC_VER
#define GETU32(p) SWAP(*((u32 *)(p)))
#define PUTU32(ct, st) { *((u32 *)(ct)) = SWAP((st)); }
#else
#define GETU32(pt) (((u32)(pt)[0] << 24) ^ ((u32)(pt)[1] << 16) ^ ((u32)(pt)[2] <<  8) ^ ((u32)(pt)[3]))
#define PUTU32(ct, st) { (ct)[0] = (u8)((st) >> 24); (ct)[1] = (u8)((st) >> 16); (ct)[2] = (u8)((st) >>  8); (ct)[3] = (u8)(st); }
#endif

/**
 * Expand the cipher key into the encryption key schedule.
 *
 * @return	the number of rounds for the given cipher key size.
 */
int rijndaelKeySetupEnc(u32 rk[/*4*(Nr + 1)*/], const u8 cipherKey[], int keyBits) {
   	int i = 0;
	u32 temp;

	rk[0] = GETU32(cipherKey     );
	rk[1] = GETU32(cipherKey +  4);
	rk[2] = GETU32(cipherKey +  8);
	rk[3] = GETU32(cipherKey + 12);
	if (keyBits == 128) {
		for (;;) {
			temp  = rk[3];
			rk[4] = rk[0] ^
				(Te4[(temp >> 16) & 0xff] & 0xff000000) ^
				(Te4[(temp >>  8) & 0xff] & 0x00ff0000) ^
				(Te4[(temp      ) & 0xff] & 0x0000ff00) ^
				(Te4[(temp >> 24)       ] & 0x000000ff) ^
				rcon[i];
			rk[5] = rk[1] ^ rk[4];
			rk[6] = rk[2] ^ rk[5];
			rk[7] = rk[3] ^ rk[6];
			if (++i == 10) {
				return 10;
			}
			rk += 4;
		}
	}
	rk[4] = GETU32(cipherKey + 16);
	rk[5] = GETU32(cipherKey + 20);
	if (keyBits == 192) {
		for (;;) {
			temp = rk[ 5];
			rk[ 6] = rk[ 0] ^
				(Te4[(temp >> 16) & 0xff] & 0xff000000) ^
				(Te4[(temp >>  8) & 0xff] & 0x00ff0000) ^
				(Te4[(temp      ) & 0xff] & 0x0000ff00) ^
				(Te4[(temp >> 24)       ] & 0x000000ff) ^
				rcon[i];
			rk[ 7] = rk[ 1] ^ rk[ 6];
			rk[ 8] = rk[ 2] ^ rk[ 7];
			rk[ 9] = rk[ 3] ^ rk[ 8];
			if (++i == 8) {
				return 12;
			}
			rk[10] = rk[ 4] ^ rk[ 9];
			rk[11] = rk[ 5] ^ rk[10];
			rk += 6;
		}
	}
	rk[6] = GETU32(cipherKey + 24);
	rk[7] = GETU32(cipherKey + 28);
	if (keyBits == 256) {
        for (;;) {
        	temp = rk[ 7];
        	rk[ 8] = rk[ 0] ^
        		(Te4[(temp >> 16) & 0xff] & 0xff000000) ^
        		(Te4[(temp >>  8) & 0xff] & 0x00ff0000) ^
        		(Te4[(temp      ) & 0xff] & 0x0000ff00) ^
        		(Te4[(temp >> 24)       ] & 0x000000ff) ^
        		rcon[i];
        	rk[ 9] = rk[ 1] ^ rk[ 8];
        	rk[10] = rk[ 2] ^ rk[ 9];
        	rk[11] = rk[ 3] ^ rk[10];
			if (++i == 7) {
				return 14;
			}
        	temp = rk[11];
        	rk[12] = rk[ 4] ^
        		(Te4[(temp >> 24)       ] & 0xff000000) ^
        		(Te4[(temp >> 16) & 0xff] & 0x00ff0000) ^
        		(Te4[(temp >>  8) & 0xff] & 0x0000ff00) ^
        		(Te4[(temp      ) & 0xff] & 0x000000ff);
        	rk[13] = rk[ 5] ^ rk[12];
        	rk[14] = rk[ 6] ^ rk[13];
        	rk[15] = rk[ 7] ^ rk[14];

			rk += 8;
        }
	}
	return 0;
}

/**
 * Expand the cipher key into the decryption key schedule.
 *
 * @return	the number of rounds for the given cipher key size.
 */
int rijndaelKeySetupDec(u32 rk[/*4*(Nr + 1)*/], const u8 cipherKey[], int keyBits) {
	int Nr, i, j;
	u32 temp;

	/* expand the cipher key: */
	Nr = rijndaelKeySetupEnc(rk, cipherKey, keyBits);
	/* invert the order of the round keys: */
	for (i = 0, j = 4*Nr; i < j; i += 4, j -= 4) {
		temp = rk[i    ]; rk[i    ] = rk[j    ]; rk[j    ] = temp;
		temp = rk[i + 1]; rk[i + 1] = rk[j + 1]; rk[j + 1] = temp;
		temp = rk[i + 2]; rk[i + 2] = rk[j + 2]; rk[j + 2] = temp;
		temp = rk[i + 3]; rk[i + 3] = rk[j + 3]; rk[j + 3] = temp;
	}
	/* apply the inverse MixColumn transform to all round keys but the first and the last: */
	for (i = 1; i < Nr; i++) {
		rk += 4;
		rk[0] =
			Td0[Te4[(rk[0] >> 24)       ] & 0xff] ^
			Td1[Te4[(rk[0] >> 16) & 0xff] & 0xff] ^
			Td2[Te4[(rk[0] >>  8) & 0xff] & 0xff] ^
			Td3[Te4[(rk[0]      ) & 0xff] & 0xff];
		rk[1] =
			Td0[Te4[(rk[1] >> 24)       ] & 0xff] ^
			Td1[Te4[(rk[1] >> 16) & 0xff] & 0xff] ^
			Td2[Te4[(rk[1] >>  8) & 0xff] & 0xff] ^
			Td3[Te4[(rk[1]      ) & 0xff] & 0xff];
		rk[2] =
			Td0[Te4[(rk[2] >> 24)       ] & 0xff] ^
			Td1[Te4[(rk[2] >> 16) & 0xff] & 0xff] ^
			Td2[Te4[(rk[2] >>  8) & 0xff] & 0xff] ^
			Td3[Te4[(rk[2]      ) & 0xff] & 0xff];
		rk[3] =
			Td0[Te4[(rk[3] >> 24)       ] & 0xff] ^
			Td1[Te4[(rk[3] >> 16) & 0xff] & 0xff] ^
			Td2[Te4[(rk[3] >>  8) & 0xff] & 0xff] ^
			Td3[Te4[(rk[3]      ) & 0xff] & 0xff];
	}
	return Nr;
}

void rijndaelEncrypt(const u32 rk[/*4*(Nr + 1)*/], int Nr, const u8 pt[16], u8 ct[16]) {
	u32 s0, s1, s2, s3, t0, t1, t2, t3;
#ifndef FULL_UNROLL
    int r;
#endif /* ?FULL_UNROLL */

    /*
	 * map byte array block to cipher state
	 * and add initial round key:
	 */
	s0 = GETU32(pt     ) ^ rk[0];
	s1 = GETU32(pt +  4) ^ rk[1];
	s2 = GETU32(pt +  8) ^ rk[2];
	s3 = GETU32(pt + 12) ^ rk[3];
#ifdef FULL_UNROLL
    /* round 1: */
   	t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[ 4];
   	t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[ 5];
   	t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[ 6];
   	t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[ 7];
   	/* round 2: */
   	s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[ 8];
   	s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[ 9];
   	s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[10];
   	s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[11];
    /* round 3: */
   	t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[12];
   	t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[13];
   	t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[14];
   	t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[15];
   	/* round 4: */
   	s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[16];
   	s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[17];
   	s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[18];
   	s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[19];
    /* round 5: */
   	t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[20];
   	t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[21];
   	t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[22];
   	t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[23];
   	/* round 6: */
   	s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[24];
   	s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[25];
   	s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[26];
   	s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[27];
    /* round 7: */
   	t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[28];
   	t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[29];
   	t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[30];
   	t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[31];
   	/* round 8: */
   	s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[32];
   	s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[33];
   	s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[34];
   	s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[35];
    /* round 9: */
   	t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[36];
   	t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[37];
   	t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[38];
   	t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[39];
    if (Nr > 10) {
        /* round 10: */
        s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[40];
        s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[41];
        s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[42];
        s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[43];
        /* round 11: */
        t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[44];
        t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[45];
        t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[46];
        t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[47];
        if (Nr > 12) {
            /* round 12: */
            s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[48];
            s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[49];
            s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[50];
            s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[51];
            /* round 13: */
            t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[52];
            t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[53];
            t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[54];
            t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[55];
        }
    }
    rk += Nr << 2;
#else  /* !FULL_UNROLL */
    /*
	 * Nr - 1 full rounds:
	 */
    r = Nr >> 1;
    for (;;) {
        t0 =
            Te0[(s0 >> 24)       ] ^
            Te1[(s1 >> 16) & 0xff] ^
            Te2[(s2 >>  8) & 0xff] ^
            Te3[(s3      ) & 0xff] ^
            rk[4];
        t1 =
            Te0[(s1 >> 24)       ] ^
            Te1[(s2 >> 16) & 0xff] ^
            Te2[(s3 >>  8) & 0xff] ^
            Te3[(s0      ) & 0xff] ^
            rk[5];
        t2 =
            Te0[(s2 >> 24)       ] ^
            Te1[(s3 >> 16) & 0xff] ^
            Te2[(s0 >>  8) & 0xff] ^
            Te3[(s1      ) & 0xff] ^
            rk[6];
        t3 =
            Te0[(s3 >> 24)       ] ^
            Te1[(s0 >> 16) & 0xff] ^
            Te2[(s1 >>  8) & 0xff] ^
            Te3[(s2      ) & 0xff] ^
            rk[7];

        rk += 8;
        if (--r == 0) {
            break;
        }

        s0 =
            Te0[(t0 >> 24)       ] ^
            Te1[(t1 >> 16) & 0xff] ^
            Te2[(t2 >>  8) & 0xff] ^
            Te3[(t3      ) & 0xff] ^
            rk[0];
        s1 =
            Te0[(t1 >> 24)       ] ^
            Te1[(t2 >> 16) & 0xff] ^
            Te2[(t3 >>  8) & 0xff] ^
            Te3[(t0      ) & 0xff] ^
            rk[1];
        s2 =
            Te0[(t2 >> 24)       ] ^
            Te1[(t3 >> 16) & 0xff] ^
            Te2[(t0 >>  8) & 0xff] ^
            Te3[(t1      ) & 0xff] ^
            rk[2];
        s3 =
            Te0[(t3 >> 24)       ] ^
            Te1[(t0 >> 16) & 0xff] ^
            Te2[(t1 >>  8) & 0xff] ^
            Te3[(t2      ) & 0xff] ^
            rk[3];
    }
#endif /* ?FULL_UNROLL */
    /*
	 * apply last round and
	 * map cipher state to byte array block:
	 */
	s0 =
		(Te4[(t0 >> 24)       ] & 0xff000000) ^
		(Te4[(t1 >> 16) & 0xff] & 0x00ff0000) ^
		(Te4[(t2 >>  8) & 0xff] & 0x0000ff00) ^
		(Te4[(t3      ) & 0xff] & 0x000000ff) ^
		rk[0];
	PUTU32(ct     , s0);
	s1 =
		(Te4[(t1 >> 24)       ] & 0xff000000) ^
		(Te4[(t2 >> 16) & 0xff] & 0x00ff0000) ^
		(Te4[(t3 >>  8) & 0xff] & 0x0000ff00) ^
		(Te4[(t0      ) & 0xff] & 0x000000ff) ^
		rk[1];
	PUTU32(ct +  4, s1);
	s2 =
		(Te4[(t2 >> 24)       ] & 0xff000000) ^
		(Te4[(t3 >> 16) & 0xff] & 0x00ff0000) ^
		(Te4[(t0 >>  8) & 0xff] & 0x0000ff00) ^
		(Te4[(t1      ) & 0xff] & 0x000000ff) ^
		rk[2];
	PUTU32(ct +  8, s2);
	s3 =
		(Te4[(t3 >> 24)       ] & 0xff000000) ^
		(Te4[(t0 >> 16) & 0xff] & 0x00ff0000) ^
		(Te4[(t1 >>  8) & 0xff] & 0x0000ff00) ^
		(Te4[(t2      ) & 0xff] & 0x000000ff) ^
		rk[3];
	PUTU32(ct + 12, s3);
}

void rijndaelDecrypt(const u32 rk[/*4*(Nr + 1)*/], int Nr, const u8 ct[16], u8 pt[16]) {
	u32 s0, s1, s2, s3, t0, t1, t2, t3;
#ifndef FULL_UNROLL
    int r;
#endif /* ?FULL_UNROLL */

    /*
	 * map byte array block to cipher state
	 * and add initial round key:
	 */
    s0 = GETU32(ct     ) ^ rk[0];
    s1 = GETU32(ct +  4) ^ rk[1];
    s2 = GETU32(ct +  8) ^ rk[2];
    s3 = GETU32(ct + 12) ^ rk[3];
#ifdef FULL_UNROLL
    /* round 1: */
    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[ 4];
    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[ 5];
    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[ 6];
    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[ 7];
    /* round 2: */
    s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[ 8];
    s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[ 9];
    s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[10];
    s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[11];
    /* round 3: */
    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[12];
    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[13];
    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[14];
    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[15];
    /* round 4: */
    s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[16];
    s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[17];
    s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[18];
    s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[19];
    /* round 5: */
    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[20];
    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[21];
    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[22];
    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[23];
    /* round 6: */
    s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[24];
    s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[25];
    s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[26];
    s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[27];
    /* round 7: */
    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[28];
    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[29];
    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[30];
    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[31];
    /* round 8: */
    s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[32];
    s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[33];
    s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[34];
    s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[35];
    /* round 9: */
    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[36];
    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[37];
    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[38];
    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[39];
    if (Nr > 10) {
        /* round 10: */
        s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[40];
        s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[41];
        s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[42];
        s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[43];
        /* round 11: */
        t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[44];
        t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[45];
        t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[46];
        t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[47];
        if (Nr > 12) {
            /* round 12: */
            s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[48];
            s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[49];
            s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[50];
            s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[51];
            /* round 13: */
            t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[52];
            t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[53];
            t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[54];
            t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[55];
        }
    }
	rk += Nr << 2;
#else  /* !FULL_UNROLL */
    /*
     * Nr - 1 full rounds:
     */
    r = Nr >> 1;
    for (;;) {
        t0 =
            Td0[(s0 >> 24)       ] ^
            Td1[(s3 >> 16) & 0xff] ^
            Td2[(s2 >>  8) & 0xff] ^
            Td3[(s1      ) & 0xff] ^
            rk[4];
        t1 =
            Td0[(s1 >> 24)       ] ^
            Td1[(s0 >> 16) & 0xff] ^
            Td2[(s3 >>  8) & 0xff] ^
            Td3[(s2      ) & 0xff] ^
            rk[5];
        t2 =
            Td0[(s2 >> 24)       ] ^
            Td1[(s1 >> 16) & 0xff] ^
            Td2[(s0 >>  8) & 0xff] ^
            Td3[(s3      ) & 0xff] ^
            rk[6];
        t3 =
            Td0[(s3 >> 24)       ] ^
            Td1[(s2 >> 16) & 0xff] ^
            Td2[(s1 >>  8) & 0xff] ^
            Td3[(s0      ) & 0xff] ^
            rk[7];

        rk += 8;
        if (--r == 0) {
            break;
        }

        s0 =
            Td0[(t0 >> 24)       ] ^
            Td1[(t3 >> 16) & 0xff] ^
            Td2[(t2 >>  8) & 0xff] ^
            Td3[(t1      ) & 0xff] ^
            rk[0];
        s1 =
            Td0[(t1 >> 24)       ] ^
            Td1[(t0 >> 16) & 0xff] ^
            Td2[(t3 >>  8) & 0xff] ^
            Td3[(t2      ) & 0xff] ^
            rk[1];
        s2 =
            Td0[(t2 >> 24)       ] ^
            Td1[(t1 >> 16) & 0xff] ^
            Td2[(t0 >>  8) & 0xff] ^
            Td3[(t3      ) & 0xff] ^
            rk[2];
        s3 =
            Td0[(t3 >> 24)       ] ^
            Td1[(t2 >> 16) & 0xff] ^
            Td2[(t1 >>  8) & 0xff] ^
            Td3[(t0      ) & 0xff] ^
            rk[3];
    }
#endif /* ?FULL_UNROLL */
    /*
	 * apply last round and
	 * map cipher state to byte array block:
	 */
   	s0 =
   		(Td4[(t0 >> 24)       ] & 0xff000000) ^
   		(Td4[(t3 >> 16) & 0xff] & 0x00ff0000) ^
   		(Td4[(t2 >>  8) & 0xff] & 0x0000ff00) ^
   		(Td4[(t1      ) & 0xff] & 0x000000ff) ^
   		rk[0];
	PUTU32(pt     , s0);
   	s1 =
   		(Td4[(t1 >> 24)       ] & 0xff000000) ^
   		(Td4[(t0 >> 16) & 0xff] & 0x00ff0000) ^
   		(Td4[(t3 >>  8) & 0xff] & 0x0000ff00) ^
   		(Td4[(t2      ) & 0xff] & 0x000000ff) ^
   		rk[1];
	PUTU32(pt +  4, s1);
   	s2 =
   		(Td4[(t2 >> 24)       ] & 0xff000000) ^
   		(Td4[(t1 >> 16) & 0xff] & 0x00ff0000) ^
   		(Td4[(t0 >>  8) & 0xff] & 0x0000ff00) ^
   		(Td4[(t3      ) & 0xff] & 0x000000ff) ^
   		rk[2];
	PUTU32(pt +  8, s2);
   	s3 =
   		(Td4[(t3 >> 24)       ] & 0xff000000) ^
   		(Td4[(t2 >> 16) & 0xff] & 0x00ff0000) ^
   		(Td4[(t1 >>  8) & 0xff] & 0x0000ff00) ^
   		(Td4[(t0      ) & 0xff] & 0x000000ff) ^
   		rk[3];
	PUTU32(pt + 12, s3);
}

#ifdef INTERMEDIATE_VALUE_KAT

void rijndaelEncryptRound(const u32 rk[/*4*(Nr + 1)*/], int Nr, u8 block[16], int rounds) {
	int r;
	u32 s0, s1, s2, s3, t0, t1, t2, t3;

    /*
	 * map byte array block to cipher state
	 * and add initial round key:
	 */
	s0 = GETU32(block     ) ^ rk[0];
	s1 = GETU32(block +  4) ^ rk[1];
	s2 = GETU32(block +  8) ^ rk[2];
	s3 = GETU32(block + 12) ^ rk[3];
    rk += 4;

    /*
	 * Nr - 1 full rounds:
	 */
	for (r = (rounds < Nr ? rounds : Nr - 1); r > 0; r--) {
		t0 =
			Te0[(s0 >> 24)       ] ^
			Te1[(s1 >> 16) & 0xff] ^
			Te2[(s2 >>  8) & 0xff] ^
			Te3[(s3      ) & 0xff] ^
			rk[0];
		t1 =
			Te0[(s1 >> 24)       ] ^
			Te1[(s2 >> 16) & 0xff] ^
			Te2[(s3 >>  8) & 0xff] ^
			Te3[(s0      ) & 0xff] ^
			rk[1];
		t2 =
			Te0[(s2 >> 24)       ] ^
			Te1[(s3 >> 16) & 0xff] ^
			Te2[(s0 >>  8) & 0xff] ^
			Te3[(s1      ) & 0xff] ^
			rk[2];
		t3 =
			Te0[(s3 >> 24)       ] ^
			Te1[(s0 >> 16) & 0xff] ^
			Te2[(s1 >>  8) & 0xff] ^
			Te3[(s2      ) & 0xff] ^
			rk[3];

		s0 = t0;
		s1 = t1;
		s2 = t2;
		s3 = t3;
		rk += 4;

    }

    /*
	 * apply last round and
	 * map cipher state to byte array block:
	 */
	if (rounds == Nr) {
    	t0 =
    		(Te4[(s0 >> 24)       ] & 0xff000000) ^
    		(Te4[(s1 >> 16) & 0xff] & 0x00ff0000) ^
    		(Te4[(s2 >>  8) & 0xff] & 0x0000ff00) ^
    		(Te4[(s3      ) & 0xff] & 0x000000ff) ^
    		rk[0];
    	t1 =
    		(Te4[(s1 >> 24)       ] & 0xff000000) ^
    		(Te4[(s2 >> 16) & 0xff] & 0x00ff0000) ^
    		(Te4[(s3 >>  8) & 0xff] & 0x0000ff00) ^
    		(Te4[(s0      ) & 0xff] & 0x000000ff) ^
    		rk[1];
    	t2 =
    		(Te4[(s2 >> 24)       ] & 0xff000000) ^
    		(Te4[(s3 >> 16) & 0xff] & 0x00ff0000) ^
    		(Te4[(s0 >>  8) & 0xff] & 0x0000ff00) ^
    		(Te4[(s1      ) & 0xff] & 0x000000ff) ^
    		rk[2];
    	t3 =
    		(Te4[(s3 >> 24)       ] & 0xff000000) ^
    		(Te4[(s0 >> 16) & 0xff] & 0x00ff0000) ^
    		(Te4[(s1 >>  8) & 0xff] & 0x0000ff00) ^
    		(Te4[(s2      ) & 0xff] & 0x000000ff) ^
    		rk[3];
		
		s0 = t0;
		s1 = t1;
		s2 = t2;
		s3 = t3;
	}

	PUTU32(block     , s0);
	PUTU32(block +  4, s1);
	PUTU32(block +  8, s2);
	PUTU32(block + 12, s3);
}

void rijndaelDecryptRound(const u32 rk[/*4*(Nr + 1)*/], int Nr, u8 block[16], int rounds) {
	int r;
	u32 s0, s1, s2, s3, t0, t1, t2, t3;

    /*
	 * map byte array block to cipher state
	 * and add initial round key:
	 */
	s0 = GETU32(block     ) ^ rk[0];
	s1 = GETU32(block +  4) ^ rk[1];
	s2 = GETU32(block +  8) ^ rk[2];
	s3 = GETU32(block + 12) ^ rk[3];
    rk += 4;

    /*
	 * Nr - 1 full rounds:
	 */
	for (r = (rounds < Nr ? rounds : Nr) - 1; r > 0; r--) {
		t0 =
			Td0[(s0 >> 24)       ] ^
			Td1[(s3 >> 16) & 0xff] ^
			Td2[(s2 >>  8) & 0xff] ^
			Td3[(s1      ) & 0xff] ^
			rk[0];
		t1 =
			Td0[(s1 >> 24)       ] ^
			Td1[(s0 >> 16) & 0xff] ^
			Td2[(s3 >>  8) & 0xff] ^
			Td3[(s2      ) & 0xff] ^
			rk[1];
		t2 =
			Td0[(s2 >> 24)       ] ^
			Td1[(s1 >> 16) & 0xff] ^
			Td2[(s0 >>  8) & 0xff] ^
			Td3[(s3      ) & 0xff] ^
			rk[2];
		t3 =
			Td0[(s3 >> 24)       ] ^
			Td1[(s2 >> 16) & 0xff] ^
			Td2[(s1 >>  8) & 0xff] ^
			Td3[(s0      ) & 0xff] ^
			rk[3];

		s0 = t0;
		s1 = t1;
		s2 = t2;
		s3 = t3;
		rk += 4;

    }

    /*
	 * complete the last round and
	 * map cipher state to byte array block:
	 */
	t0 =
		(Td4[(s0 >> 24)       ] & 0xff000000) ^
		(Td4[(s3 >> 16) & 0xff] & 0x00ff0000) ^
		(Td4[(s2 >>  8) & 0xff] & 0x0000ff00) ^
		(Td4[(s1      ) & 0xff] & 0x000000ff);
	t1 =
		(Td4[(s1 >> 24)       ] & 0xff000000) ^
		(Td4[(s0 >> 16) & 0xff] & 0x00ff0000) ^
		(Td4[(s3 >>  8) & 0xff] & 0x0000ff00) ^
		(Td4[(s2      ) & 0xff] & 0x000000ff);
	t2 =
		(Td4[(s2 >> 24)       ] & 0xff000000) ^
		(Td4[(s1 >> 16) & 0xff] & 0x00ff0000) ^
		(Td4[(s0 >>  8) & 0xff] & 0x0000ff00) ^
		(Td4[(s3      ) & 0xff] & 0x000000ff);
	t3 =
		(Td4[(s3 >> 24)       ] & 0xff000000) ^
		(Td4[(s2 >> 16) & 0xff] & 0x00ff0000) ^
		(Td4[(s1 >>  8) & 0xff] & 0x0000ff00) ^
		(Td4[(s0      ) & 0xff] & 0x000000ff);

	if (rounds == Nr) {
	    t0 ^= rk[0];
	    t1 ^= rk[1];
	    t2 ^= rk[2];
	    t3 ^= rk[3];
	}

	PUTU32(block     , t0);
	PUTU32(block +  4, t1);
	PUTU32(block +  8, t2);
	PUTU32(block + 12, t3);
}

#endif /* INTERMEDIATE_VALUE_KAT */

```

`src/xex/rijndael-alg-fst.h`:

```h
/**
 * rijndael-alg-fst.h
 *
 * @version 3.0 (December 2000)
 *
 * Optimised ANSI C code for the Rijndael cipher (now AES)
 *
 * @author Vincent Rijmen <vincent.rijmen@esat.kuleuven.ac.be>
 * @author Antoon Bosselaers <antoon.bosselaers@esat.kuleuven.ac.be>
 * @author Paulo Barreto <paulo.barreto@terra.com.br>
 *
 * This code is hereby placed in the public domain.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ''AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#ifndef __RIJNDAEL_ALG_FST_H
#define __RIJNDAEL_ALG_FST_H

#define MAXKC	(256/32)
#define MAXKB	(256/8)
#define MAXNR	14

typedef unsigned char	u8;	
typedef unsigned short	u16;	
typedef unsigned int	u32;

int rijndaelKeySetupEnc(u32 rk[/*4*(Nr + 1)*/], const u8 cipherKey[], int keyBits);
int rijndaelKeySetupDec(u32 rk[/*4*(Nr + 1)*/], const u8 cipherKey[], int keyBits);
void rijndaelEncrypt(const u32 rk[/*4*(Nr + 1)*/], int Nr, const u8 pt[16], u8 ct[16]);
void rijndaelDecrypt(const u32 rk[/*4*(Nr + 1)*/], int Nr, const u8 ct[16], u8 pt[16]);

#ifdef INTERMEDIATE_VALUE_KAT
void rijndaelEncryptRound(const u32 rk[/*4*(Nr + 1)*/], int Nr, u8 block[16], int rounds);
void rijndaelDecryptRound(const u32 rk[/*4*(Nr + 1)*/], int Nr, u8 block[16], int rounds);
#endif /* INTERMEDIATE_VALUE_KAT */

#endif /* __RIJNDAEL_ALG_FST_H */

```

`src/xex/xex.h`:

```h
#ifndef XEXLOADER_XEX_H
#define XEXLOADER_XEX_H

#include <stdint.h>
#include <istream>
#include <string>
#include <vector>

#include "common/log.h"

#include "biginputstream.h"
#include "optionalheaders.h"

#define IMAGE_SIZEOF_NT_OPTIONAL_HEADER   224
#define IMAGE_FILE_MACHINE_POWERPCBE      0x01F2

// https://github.com/nateleroux/xbdm/blob/master/xbdm/imp/xex.h
// https://github.com/nateleroux/xbdm/blob/master/xbdm/imp/xexhv.h

namespace xex
{
   
#pragma pack(push, 1)

union ImageFlags
{
   uint32_t _flags;

   struct {
      uint32_t _unknown_00000001 : 1;
      uint32_t manufacturingUtility : 1;
      uint32_t manufacturingSupportTools : 1;
      uint32_t xgd2MediaOnly : 1;
      uint32_t _unknown_00000010 : 1;
      uint32_t _unknown_00000020 : 1;
      uint32_t _unknown_00000040 : 1;
      uint32_t _unknown_00000080 : 1;
      uint32_t cardeaKey : 1;
      uint32_t xeikaKey : 1;
      uint32_t userModeTitle : 1;
      uint32_t userModeSystem : 1;
      uint32_t orange0 : 1;
      uint32_t orange1 : 1;
      uint32_t orange2 : 1;
      uint32_t _unknown_00008000 : 1;
      uint32_t iptvSignupApplication : 1;
      uint32_t iptvTitleApplication : 1;
      uint32_t _unknown_00040000 : 1;
      uint32_t _unknown_00080000 : 1;
      uint32_t _unknown_00100000 : 1;
      uint32_t _unknown_00200000 : 1;
      uint32_t _unknown_00400000 : 1;
      uint32_t _unknown_00800000 : 1;
      uint32_t _unknown_01000000 : 1;
      uint32_t _unknown_02000000 : 1;
      uint32_t keyvaultPrivilegesRequired : 1;
      uint32_t onlineActivationRequired : 1;
      uint32_t pageSize4KB : 1;
      uint32_t regionFree : 1;
      uint32_t revocationCheckOptional : 1;
      uint32_t revocationCheckRequired : 1;
   };
};

union MediaFlags
{
   uint32_t _flags;

   struct {
      uint32_t hardDisk : 1;
      uint32_t dvdX2 : 1;
      uint32_t dvdCd : 1;
      uint32_t dvd5 : 1;
      uint32_t dvd9 : 1;
      uint32_t systemFlash : 1;
      uint32_t _unknown_00000040 : 1;
      uint32_t memoryUnit : 1;
      uint32_t usbMassStorageDevice : 1;
      uint32_t network : 1;
      uint32_t directFromMemory : 1;
      uint32_t ramDrive : 1;
      uint32_t svod : 1;
      uint32_t _unknown_00002000 : 1;
      uint32_t _unknown_00004000 : 1;
      uint32_t _unknown_00008000 : 1;
      uint32_t _unknown_00010000 : 1;
      uint32_t _unknown_00020000 : 1;
      uint32_t _unknown_00040000 : 1;
      uint32_t _unknown_00080000 : 1;
      uint32_t _unknown_00100000 : 1;
      uint32_t _unknown_00200000 : 1;
      uint32_t _unknown_00400000 : 1;
      uint32_t _unknown_00800000 : 1;
      uint32_t insecurePackage : 1;
      uint32_t saveGamePackage : 1;
      uint32_t locallySignedPackage : 1;
      uint32_t liveSignedPackage : 1;
      uint32_t xboxPackage : 1;
      uint32_t _unknown_20000000 : 1;
      uint32_t _unknown_40000000 : 1;
      uint32_t _unknown_80000000 : 1;
   };
};

struct LoaderInfo
{
   uint32_t headerSize;
   uint32_t imageSize;
   uint8_t rsaSignature[256];
   uint32_t _unknown1;
   ImageFlags imageFlags;
   uint32_t loadAddress;
   uint8_t sectionDigest[20];
   uint32_t importTableCount;
   uint8_t importTableDigest[20];
   uint8_t mediaId[16];
   uint8_t fileKey[16];
   uint32_t exportTable;
   uint8_t headerDigest[20];
   uint32_t gameRegions;
   MediaFlags mediaFlags;
};

struct Section
{
   enum Type {
      Code         = 0x01,
      Data         = 0x02,
      ReadOnlyData = 0x03
   };

   union {
      uint32_t _typePageCount;

      struct {
         uint32_t type : 4;
         uint32_t pageCount : 28;
      };
   };

   uint8_t digest[20];
};

struct ModuleFlags 
{
   union {
      uint32_t flags;

      struct {
         uint32_t title : 1;
         uint32_t exportsToTitle : 1;
         uint32_t systemDebugger : 1;
         uint32_t dllModule : 1;
         uint32_t modulePatch : 1;
         uint32_t patchFull : 1;
         uint32_t patchDelta : 1;
         uint32_t userMode : 1;
         uint32_t unused : 24;
      };
   };
};

struct Header
{
   /* Actual Header */
   uint8_t magic[4];
   ModuleFlags moduleFlags;
   uint32_t peDataOffset;
   uint32_t reserved;
   uint32_t securityInfoOffset;
   uint32_t optHeaderCount;

   /* Security Info */ 
   xex::LoaderInfo loaderInfo;
   std::vector<xex::Section> sections;
   uint8_t sessionKey[16];

   /* Optional Headers */
   std::vector<OptionalRawHeader> optionalRaw;
   ResourceInfo resourceInfo;
   BaseFileFormat baseFileFormat;
   BaseReference baseReference;
   DeltaPatchDescriptor deltaPatchDescriptor;
   BoundingPath boundingPath;
   DeviceId deviceId;
   OriginalBaseAddress originalBaseAddress;
   EntryPoint entryPoint;
   ImageBaseAddress imageBaseAddress;
   ImportLibraries importLibraries;
   ChecksumTimestamp checksumTimestamp;
   EnabledForCallcap enabledForCallcap;
   EnabledForFastcap enabledForFastcap;
   OriginalPeName originalPeName;
   StaticLibraries staticLibraries;
   TlsInfo tlsInfo;
   DefaultStackSize defaultStackSize;
   DefaultFilesystemCacheSize defaultFilesystemCacheSize;
   DefaultHeapSize defaultHeapSize;
   PageHeapSizeandFlags pageHeapSizeandFlags;
   SystemFlags systemFlags;
   ExecutionInfo executionInfo;
   ServiceIdList serviceIdList;
   TitleWorkspaceSize titleWorkspaceSize;
   GameRatings gameRatings;
   LanKey lanKey;
   Xbox360Logo xbox360Logo;
   MultidiscMediaIds multidiscMediaIds;
   AlternateTitleIds alternateTitleIds;
   AdditionalTitleMemory additionalTitleMemory;
   ExportsByName exportsByName;
};

struct PeSection
{
   std::string name;

   uint32_t rawAddress;
   uint32_t rawSize;
   uint32_t address;
   uint32_t size;
   uint32_t flags;
};

#pragma pack(pop)

struct Binary
{
   Header header;
   std::vector<xex::PeSection> sections;
};

class Loader
{
public:
   bool load(std::istream &istr, xex::Binary &binary);

protected:
   bool loadPe(xex::Binary &binary, uint32_t exeAddress);

   void loadImportLibraries(xex::ImportLibraries &importLibraries);

   bool readImage(BigInputStream &in, xex::Header &header);
   bool readImageUncompressed(BigInputStream &in, xex::Header &header);
   bool readImageNormalCompression(BigInputStream &in, xex::Header &header);
   bool readImageBasicCompression(BigInputStream &in, xex::Header &header);

   void readHeader(BigInputStream &in, unsigned length, xex::ResourceInfo &out);
   void readHeader(BigInputStream &in, unsigned length, xex::BaseFileFormat &out);
   void readHeader(BigInputStream &in, unsigned length, xex::EntryPoint &out);
   void readHeader(BigInputStream &in, unsigned length, xex::ImageBaseAddress &out);
   void readHeader(BigInputStream &in, unsigned length, xex::ImportLibraries &out);
   void readHeader(BigInputStream &in, unsigned length, xex::ChecksumTimestamp &out);
   void readHeader(BigInputStream &in, unsigned length, xex::OriginalPeName &out);
   void readHeader(BigInputStream &in, unsigned length, xex::StaticLibraries &out);
   void readHeader(BigInputStream &in, unsigned length, xex::TlsInfo &out);
   void readHeader(BigInputStream &in, unsigned length, xex::DefaultStackSize &out);
   void readHeader(BigInputStream &in, unsigned length, xex::DefaultHeapSize &out);
   void readHeader(BigInputStream &in, unsigned length, xex::SystemFlags &out);
   void readHeader(BigInputStream &in, unsigned length, xex::ExecutionInfo &out);
   void readHeader(BigInputStream &in, unsigned length, xex::GameRatings &out);
   void readHeader(BigInputStream &in, unsigned length, xex::LanKey &out);
   void readHeader(BigInputStream &in, unsigned length, xex::AlternateTitleIds &out);
   void readHeader(BigInputStream &in, unsigned length, xex::LoaderInfo &out);
   void readStringTable(BigInputStream &in,
                        unsigned length,
                        std::vector<std::string> &out);

   template<typename T>
   void readHeader(BigInputStream &bes, unsigned length, T &header)
   {
      xDebug()
         << "Unimplemented header found 0x"
         << Log::hex(static_cast<unsigned>(T::id))
         << " length " << length;

      std::cout << std::endl;
      
      for (unsigned i = 0; i < length; ++i) {
         uint8_t c;
         bes >> c;
         xDebugInline() << Log::hex(c, 2);
      }
   }

private:
};

} // namespace xex

#endif // XEX_H

```

`tests/ppc/alu/add.s`:

```s
# pre: %r1 = 1
# pre: %r2 = 2

# post: %r3 == 3
# post: %crf0 == 0

add %r3, %r1, %r2

```

`tests/ppc/alu/add_overflow.s`:

```s
# pre: %r1 = 0x7fffffffffffffff
# pre: %r2 = 1

# post: %r3 == 0x8000000000000000
# post: %xer[ov] == 1
# post: %crf0 == 0

addo %r3, %r1, %r2

```

`tests/ppc/alu/add_record_negative.s`:

```s
# pre: %r1 = -1
# pre: %r2 = 0

# post: %r3 == -1
# post: %crf0 == 1

add. %r3, %r1, %r2

```

`tests/ppc/alu/add_record_overflow.s`:

```s
# pre: %r1 = 0x7fffffffffffffff
# pre: %r2 = 1

# post: %r3 == 0x8000000000000000
# post: %xer[ov] == 1
# post: %crf0 == 9

addo. %r3, %r1, %r2

```

`tests/ppc/alu/add_record_positive.s`:

```s
# pre: %r1 = 1
# pre: %r2 = 0

# post: %r3 == 1
# post: %crf0 == 2

add. %r3, %r1, %r2

```

`tests/ppc/alu/add_record_zero.s`:

```s
# pre: %r1 = -1
# pre: %r2 = 1

# post: %r3 == 0
# post: %crf0 == 4

add. %r3, %r1, %r2

```

`tests/ppc/alu/addc.s`:

```s
# pre: %r1 = -1
# pre: %r2 = 2

# post: %r3 == 1
# post: %xer[ca] == 1
# post: %crf0 == 0

addc %r3, %r1, %r2

```

`tests/ppc/alu/adde.s`:

```s
# pre: %r1 = 1
# pre: %r2 = 2
# pre: %xer[ca] = 1

# post: %r3 == 4
# post: %crf0 == 0

adde %r3, %r1, %r2

```

`tests/ppc/alu/addi.s`:

```s
# pre: %r1 = 2

# post: %r2 == 1
# post: %crf0 == 0

addi %r2, %r1, -1

```

`tests/ppc/alu/addic.s`:

```s
# pre: %r1 = -1

# post: %r2 == 1
# post: %xer[ca] == 1
# post: %crf0 == 0

addic %r2, %r1, 2

```

`tests/ppc/alu/addis.s`:

```s
# pre: %r1 = 1

# post: %r2 == 0x10001
# post: %crf0 == 0

addis %r2, %r1, 1

```

`tests/ppc/alu/addme.s`:

```s
# pre: %r1 = 3
# pre: %xer[ca] = 1

# post: %r2 == 3
# post: %crf0 == 0

addme %r2, %r1

```

`tests/ppc/alu/addze.s`:

```s
# pre: %r1 = 3
# pre: %xer[ca] = 1

# post: %r2 == 4
# post: %crf0 == 0

addze %r2, %r1

```

`tests/ppc/alu/alu_todo.txt`:

```txt
cntlzd
cntlzw
```

`tests/ppc/alu/and.s`:

```s
# pre: %r1 = 1
# pre: %r2 = 1
# post: %r3 == 1

# pre: %r4 = 0
# pre: %r5 = 1
# post: %r6 == 0

# pre: %r7 = 1
# pre: %r8 = 0
# post: %r9 == 0

# pre: %r10 = 0
# pre: %r11 = 0
# post: %r12 == 0

# post: %crf0 == 0

and %r3, %r1, %r2
and %r6, %r4, %r5
and %r9, %r7, %r8
and %r12, %r10, %r11

```

`tests/ppc/alu/and_record.s`:

```s
# pre: %r1 = 0xf0f0
# pre: %r2 = 0x4444

# post: %r3 == 0x4040
# post: %crf0 == 2

and. %r3, %r1, %r2

```

`tests/ppc/alu/andc.s`:

```s
# pre: %r1 = 0xf0f0
# pre: %r2 = 0x4444

# post: %r3 == 0xb0b0
# post: %crf0 == 0

andc %r3, %r1, %r2

```

`tests/ppc/alu/andc_record.s`:

```s
# pre: %r1 = 0xf0f0
# pre: %r2 = 0x4444

# post: %r3 == 0xb0b0
# post: %crf0 == 2

andc. %r3, %r1, %r2

```

`tests/ppc/alu/andi.s`:

```s
# pre: %r1 = 0xf0f0

# post: %r3 == 0x4040
# post: %crf0 == 2

andi. %r3, %r1, 0x4444

```

`tests/ppc/alu/andis.s`:

```s
# pre: %r1 = 0xf0f00000

# post: %r3 == 0x40400000
# post: %crf0 == 2

andis. %r3, %r1, 0x4444

```

`tests/ppc/alu/cntlzw.s`:

```s
# pre: %r3 = 0x00619920
# post: %r3 == 9

cntlzw %r3, %r3

```

`tests/ppc/alu/divd.s`:

```s
# pre: %r1 = 10
# pre: %r2 = 2

# post: %r3 == 5

divd %r3, %r1, %r2

```

`tests/ppc/alu/divdu.s`:

```s
# pre: %r1 = 10
# pre: %r2 = 2

# post: %r3 == 5

divdu %r3, %r1, %r2

```

`tests/ppc/alu/divw.s`:

```s
# pre: %r1 = 10
# pre: %r2 = 2

# post: %r3 == 5

divw %r3, %r1, %r2

```

`tests/ppc/alu/divwu.s`:

```s
# pre: %r1 = 10
# pre: %r2 = 2

# post: %r3 == 5

divwu %r3, %r1, %r2

```

`tests/ppc/alu/eqv.s`:

```s
# pre: %r1 = 1
# pre: %r2 = 1
# post: %r3 == 0xffffffffffffffff

# pre: %r4 = 0
# pre: %r5 = 1
# post: %r6 == 0xfffffffffffffffe

# pre: %r7 = 1
# pre: %r8 = 0
# post: %r9 == 0xfffffffffffffffe

# pre: %r10 = 0
# pre: %r11 = 0
# post: %r12 == 0xffffffffffffffff

eqv %r3, %r1, %r2
eqv %r6, %r4, %r5
eqv %r9, %r7, %r8
eqv %r12, %r10, %r11

```

`tests/ppc/alu/extsb.s`:

```s
# pre: %r1 = 0x80
# post: %r2 == 0xFFFFFFFFFFFFFF80

extsb %r2, %r1

```

`tests/ppc/alu/extsh.s`:

```s
# pre: %r1 = 0x8000
# post: %r2 == 0xFFFFFFFFFFFF8000

extsh %r2, %r1

```

`tests/ppc/alu/extsw.s`:

```s
# pre: %r1 = 0x80000000
# post: %r2 == 0xFFFFFFFF80000000

extsw %r2, %r1

```

`tests/ppc/alu/rlwimi.s`:

```s
# pre: %r1 = 0x90003000
# pre: %r2 = 0x00000003
# post: %r2 == 0x4000C003

rlwimi %r2, %r1, 2, 0, 0x1D


```

`tests/ppc/alu/rlwimi_record.s`:

```s
# pre: %r1 = 0x789A789B
# pre: %r2 = 0x30000003
# post: %r2 == 0xE269E263
# post: %crf0 == 8

rlwimi. %r2, %r1, 2, 0, 0x1A

```

`tests/ppc/alu/rlwinm.s`:

```s
# pre: %r1 = 0x90003000
# pre: %r2 = 0xFFFFFFFF
# post: %r2 == 0x4000C000

rlwinm %r2, %r1, 2, 0, 0x1D


```

`tests/ppc/alu/rlwinm_record.s`:

```s
# pre: %r1 = 0xB0043000
# pre: %r2 = 0xFFFFFFFF
# post: %r2 == 0xC010C000
# post: %crf0 == 8

rlwinm. %r2, %r1, 2, 0, 0x1D

```

`tests/ppc/alu/rlwnm.s`:

```s
# pre: %r1 = 0x90003000
# pre: %r2 = 0x00000002
# pre: %r3 = 0xFFFFFFFF
# post: %r3 == 0x4000C000

rlwnm %r3, %r1, %r2, 0, 0x1D


```

`tests/ppc/alu/rlwnm_record.s`:

```s
# pre: %r1 = 0xB0043000
# pre: %r2 = 0x00000002
# pre: %r3 = 0xFFFFFFFF
# post: %r3 == 0xC010C000
# post: %crf0 == 8

rlwnm. %r2, %r1, %r2, 0, 0x1D

```

`tests/ppc/flow/b.s`:

```s
# post: %r1 == 1
# post: %r2 == 0

nop
b 8
li %r2, 1
li %r1, 1

```

`tests/ppc/flow/ba.s`:

```s
# post: %r1 == 1
# post: %r2 == 1

nop
ba 8
li %r2, 1
li %r1, 1

```

`tests/ppc/flow/bc_equal.s`:

```s
# pre: %r1 = 1
# pre: %r2 = 1

# post: %r3 == 0

cmp 0, 0, %r1, %r2
bc 12, 2, 8
li %r3, 1
nop

```

`tests/ppc/flow/bc_greater_than.s`:

```s
# pre: %r1 = 2
# pre: %r2 = 1

# post: %r3 == 0

cmp 0, 0, %r1, %r2
bc 12, 1, 8
li %r3, 1
nop

```

`tests/ppc/flow/bc_less_than.s`:

```s
# pre: %r1 = 1
# pre: %r2 = 2

# post: %r3 == 0

cmp 0, 0, %r1, %r2
bc 12, 0, 8
li %r3, 1
nop

```

`tests/ppc/flow/bc_not_equal.s`:

```s
# pre: %r1 = 1
# pre: %r2 = 2

# post: %r3 == 0

cmp 0, 0, %r1, %r2
bc 4, 2, 8
li %r3, 1
nop

```

`tests/ppc/flow/bl.s`:

```s
# post: %r1 == 1
# post: %r2 == 0
# post: %lr == 8

nop
bl 8
li %r1, 2
li %r1, 1

```

`tests/ppc/flow/bla.s`:

```s
# post: %r1 == 1
# post: %r2 == 1
# post: %lr == 8

nop
bla 8
li %r2, 1
li %r1, 1

```

`tests/ppc/flow/cmp_equal.s`:

```s
# pre: %r1 = 2
# pre: %r2 = 2
# post: %crf1 == 4

cmp 1, 0, %r1, %r2

```

`tests/ppc/flow/cmp_greater.s`:

```s
# pre: %r1 = 2
# pre: %r2 = 1
# post: %crf1 == 2

cmp 1, 0, %r1, %r2
```

`tests/ppc/flow/cmp_less.s`:

```s
# pre: %r1 = 1
# pre: %r2 = 2
# post: %crf1 == 1

cmp 1, 0, %r1, %r2
```

`tests/ppc/flow/crand.s`:

```s
# pre: %crb0 = 1
# pre: %crb1 = 1
# post: %crb2 == 1

# pre: %crb3 = 0
# pre: %crb4 = 1
# post: %crb5 == 0

# pre: %crb6 = 1
# pre: %crb7 = 0
# post: %crb8 == 0

# pre: %crb9 = 0
# pre: %crb10 = 0
# post: %crb11 == 0

crand 2, 0, 1
crand 5, 3, 4
crand 8, 6, 7
crand 11, 9, 10

```

`tests/ppc/flow/crandc.s`:

```s
# pre: %crb0 = 1
# pre: %crb1 = 1
# post: %crb2 == 0

# pre: %crb3 = 0
# pre: %crb4 = 1
# post: %crb5 == 0

# pre: %crb6 = 1
# pre: %crb7 = 0
# post: %crb8 == 1

# pre: %crb9 = 0
# pre: %crb10 = 0
# post: %crb11 == 0

crandc 2, 0, 1
crandc 5, 3, 4
crandc 8, 6, 7
crandc 11, 9, 10

```

`tests/ppc/flow/creqv.s`:

```s
# pre: %crb0 = 1
# pre: %crb1 = 1
# post: %crb2 == 1

# pre: %crb3 = 0
# pre: %crb4 = 1
# post: %crb5 == 0

# pre: %crb6 = 1
# pre: %crb7 = 0
# post: %crb8 == 0

# pre: %crb9 = 0
# pre: %crb10 = 0
# post: %crb11 == 1

creqv 2, 0, 1
creqv 5, 3, 4
creqv 8, 6, 7
creqv 11, 9, 10

```

`tests/ppc/flow/crnand.s`:

```s
# pre: %crb0 = 1
# pre: %crb1 = 1
# post: %crb2 == 0

# pre: %crb3 = 0
# pre: %crb4 = 1
# post: %crb5 == 1

# pre: %crb6 = 1
# pre: %crb7 = 0
# post: %crb8 == 1

# pre: %crb9 = 0
# pre: %crb10 = 0
# post: %crb11 == 1

crnand 2, 0, 1
crnand 5, 3, 4
crnand 8, 6, 7
crnand 11, 9, 10

```

`tests/ppc/flow/crnor.s`:

```s
# pre: %crb0 = 1
# pre: %crb1 = 1
# post: %crb2 == 0

# pre: %crb3 = 0
# pre: %crb4 = 1
# post: %crb5 == 0

# pre: %crb6 = 1
# pre: %crb7 = 0
# post: %crb8 == 0

# pre: %crb9 = 0
# pre: %crb10 = 0
# post: %crb11 == 1

crnor 2, 0, 1
crnor 5, 3, 4
crnor 8, 6, 7
crnor 11, 9, 10

```

`tests/ppc/flow/cror.s`:

```s
# pre: %crb0 = 1
# pre: %crb1 = 1
# post: %crb2 == 1

# pre: %crb3 = 0
# pre: %crb4 = 1
# post: %crb5 == 1

# pre: %crb6 = 1
# pre: %crb7 = 0
# post: %crb8 == 1

# pre: %crb9 = 0
# pre: %crb10 = 0
# post: %crb11 == 0

cror 2, 0, 1
cror 5, 3, 4
cror 8, 6, 7
cror 11, 9, 10

```

`tests/ppc/flow/crorc.s`:

```s
# pre: %crb0 = 1
# pre: %crb1 = 1
# post: %crb2 == 1

# pre: %crb3 = 0
# pre: %crb4 = 1
# post: %crb5 == 0

# pre: %crb6 = 1
# pre: %crb7 = 0
# post: %crb8 == 1

# pre: %crb9 = 0
# pre: %crb10 = 0
# post: %crb11 == 1

crorc 2, 0, 1
crorc 5, 3, 4
crorc 8, 6, 7
crorc 11, 9, 10

```

`tests/ppc/flow/crxor.s`:

```s
# pre: %crb0 = 1
# pre: %crb1 = 1
# post: %crb2 == 0

# pre: %crb3 = 0
# pre: %crb4 = 1
# post: %crb5 == 1

# pre: %crb6 = 1
# pre: %crb7 = 0
# post: %crb8 == 1

# pre: %crb9 = 0
# pre: %crb10 = 0
# post: %crb11 == 0

crxor 2, 0, 1
crxor 5, 3, 4
crxor 8, 6, 7
crxor 11, 9, 10

```

`tests/ppc/fpu/fabs.s`:

```s
# pre: %f1 = -10
# post: %f2 == 10

fabs %f2, %f1

```

`tests/ppc/fpu/fadd.s`:

```s
# pre: %f1 = 1
# pre: %f2 = 2
# post: %f3 == 3

fadd %f3, %f1, %f2

```

`tests/ppc/load/lbz.s`:

```s
# pre: [0x1000] = 0x123456789ABCDEF0
# pre: %r1 = [0x1000]
# post: %r1 == [0x1000]
# post: %r2 == 0x12

lbz %r2, 0(%r1)

```

`tests/ppc/load/lbzu.s`:

```s
# pre: [0x1000] = 0x123456789ABCDEF0
# pre: %r1 = [0x1000]
# post: %r1 == [0x1001]
# post: %r2 == 0x34

lbzu %r2, 1(%r1)

```

`tests/ppc/load/lbzux.s`:

```s
# pre: [0x1000] = 0x123456789ABCDEF0
# pre: %r1 = [0x1000]
# pre: %r2 = 1
# post: %r1 == [0x1001]
# post: %r2 == 0x34

lbzux %r2, %r1, %r2

```

`tests/ppc/load/lbzx.s`:

```s
# pre: [0x1000] = 0x123456789ABCDEF0
# pre: %r1 = [0x1000]
# pre: %r2 = 1
# post: %r1 == [0x1000]
# post: %r2 == 0x34

lbzx %r2, %r1, %r2

```

`tests/ppc/load/ld.s`:

```s
# pre: [0x1000] = 0x123456789ABCDEF0
# pre: %r1 = [0xFF0]
# post: %r1 == [0xFF0]
# post: %r2 == 0x123456789ABCDEF0

ld %r2, 0x10(%r1)

```

`tests/ppc/load/ldu.s`:

```s
# pre: [0x1000] = 0x123456789ABCDEF0
# pre: %r1 = [0xFF0]
# post: %r1 == [0x1000]
# post: %r2 == 0x123456789ABCDEF0

ldu %r2, 0x10(%r1)

```

`tests/ppc/load/ldux.s`:

```s
# pre: [0x1000] = 0x123456789ABCDEF0
# pre: %r1 = [0xFFF]
# pre: %r2 = 1
# post: %r1 == [0x1000]
# post: %r2 == 0x123456789ABCDEF0

ldux %r2, %r1, %r2

```

`tests/ppc/load/ldx.s`:

```s
# pre: [0x1000] = 0x123456789ABCDEF0
# pre: %r1 = [0xFFF]
# pre: %r2 = 1
# post: %r1 == [0xFFF]
# post: %r2 == 0x123456789ABCDEF0

ldx %r2, %r1, %r2

```

`tests/ppc/load/load_todo.txt`:

```txt
ldarx
lfd
lfdu
lfdux
lfdx
lfs
lfsu
lfsux
lfsx
lha
lhau
lhaux
lhax
lhbrx
lhz
lhzu
lhzux
lhzx
lmw
lmswi
lswx
lwa
lwarx
lwaux
lwax
lwbrx
lwz
lwzu
lwzux
lwzx
```

`tests/ppc/mmu/mmu_todo.txt`:

```txt
dcbf
dcbst
dcbt
dcbtst
dcbz
eciwx
ecowx
eieio
icbi
isync
```

`tools/emugen/ast.h`:

```h
#ifndef AST_H
#define AST_H

#include <string>
#include <vector>
#include <map>
#include <utility>
#include <prs/optional.h>

struct ast_symbol
{
   std::string value;

   template<typename Result>
   void construct(Result &&result)
   {
      value = ast_to_string<decltype(value)>(result);
   }
};

struct ast_string
{
   std::string value;

   template<typename Result>
   void construct(Result &&result)
   {
      value = ast_to_string<decltype(value)>(std::get<1>(result));
   }
};

struct ast_number
{
   int value;

   template<typename Result>
   void construct(Result &&result)
   {
      value = std::stoi(ast_to_string<std::string>(result));
   }
};

struct ast_char
{
   int value;

   template<typename Result>
   void construct(Result &&result)
   {
      value = std::get<1>(result);
   }
};

struct ast_bitrange
{
   ast_bitrange() : end(-1)
   {
   }

   int start;
   int end;

   int size()
   {
      return 1 + end - start;
   }

   template<typename Result>
   void construct(Result &&result)
   {
      start = std::get<0>(result).value;

      if (std::get<1>(result)) {
         end = std::get<1>(*std::get<1>(result)).value;
      } else {
         end = start;
      }
   }
};

struct ast_cat_opcd
{
   std::string primary;
   std::vector<std::pair<int, std::string>> secondary;

   template<typename Result>
   void construct(Result &&result)
   {
      primary = std::get<1>(result).value;

      for (auto &sub : std::get<2>(result)) {
         secondary.push_back(std::make_pair(std::get<1>(sub).value, std::get<3>(sub).value));
      }
   }
};

struct ast_arch_endian
{
   std::string endian;

   template<typename Sequence>
   void construct(Sequence &&xs)
   {
      endian = std::get<2>(xs);
   }
};

struct ast_bitfield
{
   std::vector<std::pair<std::string, ast_bitrange>> bitfield;

   template<typename Result>
   void construct(Result &&result)
   {
      for (auto &fields : std::get<1>(result)) {
         bitfield.push_back(std::make_pair(std::get<0>(fields).value, std::get<2>(fields)));
      }
   }
};

struct ast_array
{
   int size;

   template<typename Result>
   void construct(Result &&result)
   {
      size = std::get<1>(result).value;
   }
};

struct ast_reg_type
{
   std::string type;
   prs::optional<ast_array> array;
   prs::optional<ast_bitfield> bitfield;

   template<typename Result>
   void construct(Result &&result)
   {
      type = std::get<0>(result).value;

      if (type.find("int") != std::string::npos) {
         type.append("_t");
      }

      auto &extra = std::get<1>(result);

      if (extra) {
         if (extra->which == 0) {
            array = std::get<0>(*extra);
         }

         if (extra->which == 1) {
            bitfield = std::get<1>(*extra);
         }
      }
   }
};

struct ast_reg_define
{
   std::string name;
   ast_reg_type type;

   template<typename Result>
   void construct(Result &&result)
   {
      name = std::get<0>(result).value;
      type = std::get<2>(result);
   }
};

struct ast_insf_extra
{
   std::string name;
   prs::optional<int> number;
   prs::optional<std::string> string;
   prs::optional<char> chr;

   template<typename Result>
   void construct(Result &&result)
   {
      name = std::get<0>(result).value;

      auto &value = std::get<2>(result);

      switch (value.which) {
      case 0:
         number = std::get<0>(value)->value;
         break;
      case 1:
         string = std::get<1>(value)->value;
         break;
      case 2:
         chr = std::get<2>(value)->value;
         break;
      }
   }
};

struct ast_insf_field
{
   std::string name;
   ast_bitrange bitrange;
   std::map<std::string, ast_insf_extra> extras;

   template<typename Result>
   void construct(Result &&result)
   {
      name = std::get<0>(result).value;
      bitrange = std::get<2>(result);

      if (std::get<3>(result)) {
         auto &extra = *std::get<3>(result);

         extras[std::get<1>(extra).name] = std::get<1>(extra);

         for (auto &ext : std::get<2>(extra)) {
            extras[std::get<1>(ext).name] = std::get<1>(ext);
         }
      }
   }
};

struct ast_opcd_disasm_reg
{
   char prefix;
   std::string name;

   template<typename Result>
   void construct(Result &&result)
   {
      if (std::get<0>(result)) {
         prefix = *std::get<0>(result);
      } else {
         prefix = 0;
      }

      name = std::get<1>(result).value;
   }
};

struct ast_opcd_disasm
{
   std::string name;
   std::vector<ast_opcd_disasm_reg> operands;

   template<typename Result>
   void construct(Result &&result)
   {
      name = std::get<0>(result).value;

      if (std::get<1>(result)) {
         auto &regs = *std::get<1>(result);

         operands.push_back(std::get<0>(regs));

         for (auto &reg : std::get<1>(regs)) {
            if (std::get<0>(reg) == '(') {
               std::get<1>(reg).prefix = '(';
            }

            operands.push_back(std::get<1>(reg));
         }
      }
   }
};

struct ast_opcd_extra
{
   std::string name;
   prs::optional<int> number;
   prs::optional<std::string> string;
   prs::optional<char> chr;

   template<typename Result>
   void construct(Result &&result)
   {
      name = std::get<0>(result).value;

      auto &extra = std::get<1>(result);

      if (extra) {
         auto &value = std::get<1>(*extra);

         switch (value.which) {
         case 0:
            number = std::get<0>(value)->value;
            break;
         case 1:
            string = std::get<1>(value)->value;
            break;
         case 2:
            chr = std::get<2>(value)->value;
            break;
         }
      }
   }
};

struct ast_opcd_def
{
   ast_cat_opcd *category;

   int id;
   ast_opcd_disasm disasm;
   std::map<std::string, ast_opcd_extra> extras;

   std::size_t fieldsLen;

   template<typename Result>
   void construct(Result &&result)
   {
      category = nullptr;

      id = std::get<0>(result).value;
      disasm = std::get<2>(result);

      if (std::get<3>(result)) {
         auto &ext = *std::get<3>(result);

         extras[std::get<1>(ext).name] = std::get<1>(ext);

         for (auto &ex : std::get<2>(ext)) {
            extras[std::get<1>(ex).name] = std::get<1>(ex);
         }
      }
   }
};

struct ast_arch
{
   enum Endian
   {
      Invalid,
      BigEndian,
      LittleEndian
   };

   Endian endian;

   template<typename Result>
   void construct(Result &&result)
   {
      if (result.endian.compare("BigEndian") == 0) {
         endian = BigEndian;
      } else if (result.endian.compare("LittleEndian") == 0) {
         endian = LittleEndian;
      } else {
         endian = Invalid;
      }
   }
};

struct ast_reg
{
   std::vector<ast_reg_define> registers;

   template<typename Result>
   void construct(Result &&result)
   {
      registers = result;
   }
};

struct ast_insf
{
   std::vector<ast_insf_field> fields;

   template<typename Result>
   void construct(Result &&result)
   {
      fields = result;
   }
};

struct ast_opcd
{
   ast_cat_opcd declaration;
   std::vector<ast_opcd_def> opcodes;

   template<typename Result>
   void construct(Result &&result)
   {
      declaration = std::get<0>(result);
      opcodes = std::get<1>(result);
   }
};

struct ast_root
{
   ast_arch arch;
   ast_reg reg;
   ast_insf insf;
   std::vector<ast_opcd> opcodes;

   template<typename Result>
   void construct(Result &&result)
   {
      for (auto &value : result) {
         switch (value.which) {
         case 0:
            arch = std::get<1>(*std::get<0>(value));
            break;
         case 1:
            reg = std::get<1>(*std::get<1>(value));
            break;
         case 2:
            insf = std::get<1>(*std::get<2>(value));
            break;
         case 3:
            opcodes.push_back(*std::get<3>(value));
            break;
         };
      }
   }
};

#endif // ifdef AST_H

```

`tools/emugen/emugen.cpp`:

```cpp
#include "emugen.h"

#include <map>
#include <iostream>
#include <fstream>
#include <sstream>
#include <assert.h>
#include <algorithm>
#include <functional>

EmuGen::EmuGen()
{
}

EmuGen::~EmuGen()
{
}

bool EmuGen::run(const std::string &definition, const std::string &outDirectory)
{
   if (!parseFile(definition)) {
      return false;
   }

   /* Create List */
   for (auto &group : m_ast.opcodes) {
      for (auto &instr : group.opcodes) {
         instr.category = &group.declaration;
         m_instructionList[instr.disasm.name] = &instr;
      }
   }

   /* Create Tree */
   for (auto &instr : m_instructionList) {
      std::string xo1 = instr.second->category->primary;
      auto *table = &m_rootTable.table[xo1];

      for (auto &cat : instr.second->category->secondary) {
         auto next = table->find(cat.first);
         DecodeTable *nextTable;

         if (next == table->end()) {
            nextTable = new DecodeTable();
            table->insert(std::make_pair(cat.first, nextTable));
         } else {
            assert(next->second->type == DecodeNode::Table);
            nextTable = reinterpret_cast<DecodeTable*>(next->second);
         }

         table = &nextTable->table[cat.second];
      }

      assert(table->find(instr.second->id) == table->end());

      DecodeInstr *decodeInstr = new DecodeInstr();
      decodeInstr->op = instr.second;
      table->insert(std::make_pair(instr.second->id, decodeInstr));
   }

   createCpuInfo(outDirectory + "/emugen_cpu_info.h");

   createInstructionList(outDirectory + "/emugen_instructionid.h");
   createInstructionTableSource(outDirectory + "/emugen_table.h");

   createStubs(outDirectory + "/emugen_stubs.cpp");
   createStubsHeader(outDirectory + "/emugen_stubs.h");

   createInstructionTable(outDirectory + "/emugen_instructions.h");
   createDecoder(outDirectory + "/emugen_decoder.h");

   return true;
}

template <class T>
int numDigits(T number)
{
   int digits = 0;

   while (number) {
      number /= 10;
      digits++;
   }

   return digits;
}

bool EmuGen::createDecoder(const std::string &path)
{
   std::fstream out;
   std::vector<std::string> tables;

   out.open(path, std::ifstream::out);

   if (!out.is_open()) {
      std::cout << "Could not open " << path << " for writing" << std::endl;
      return false;
   }
   
   std::function<void(DecodeTable*, std::string name)> printDecodeTables =
      [&](DecodeTable* table, std::string name) {
         std::string first;

         for (auto &entry : table->table) {
            std::stringstream tableName;
            tableName << name << "_" << entry.first;

            auto field = findInstructionField(entry.first);

            if (first.length()) {
               out << "DecodeEntry *";
            } else {
               out << "DecodeEntry ";
            }

            out << "table" << tableName.str();

            if (first.length()) {
               out << " = table" << first << ";";
            } else {
               out << "[" << (1 << field->bitrange.size()) << "];";
            }

            out << std::endl;
            first = tableName.str();
         }

         for (auto &entry : table->table) {
            for (auto &child : entry.second) {
               if (child.second->type == DecodeNode::Table) {
                  std::stringstream tableName;
                  tableName << name << "_" << entry.first << "_" << child.first;
                  printDecodeTables(reinterpret_cast<DecodeTable*>(child.second), tableName.str());
               }
            }
         }
      };

   printDecodeTables(&m_rootTable, "");
   out << std::endl;

   std::function<void(DecodeTable*, std::string name)> printDecodeFunction =
      [&out, &printDecodeFunction](DecodeTable* table, std::string name) {
         out << "InstructionID decode" << name << "(Instruction instr) {" << std::endl;
         out << "   " << "DecodeEntry entry;" << std::endl;
         out << std::endl;

         for (auto &entry : table->table) {
            std::stringstream tableName;
            tableName << name << "_" << entry.first;

            out << "   " << "entry = table" << tableName.str() << "[instr." << entry.first << "];" << std::endl;
            out << "   " << "if (entry.value) {" << std::endl;
            out << "   " << "   " << "if (entry.isTable()) {" << std::endl;
            out << "   " << "   " << "   " << "return entry.table(instr);" << std::endl;
            out << "   " << "   " << "} else {" << std::endl;
            out << "   " << "   " << "   " << "return entry.instr();" << std::endl;
            out << "   " << "   " << "}" << std::endl;
            out << "   " << "}" << std::endl;
            out << std::endl;
         }

         out << "   " << "return InstructionID::Unknown;" << std::endl;
         out << "}" << std::endl;
         out << std::endl;

         for (auto &entry : table->table) {
            for (auto &child : entry.second) {
               if (child.second->type == DecodeNode::Table) {
                  std::stringstream tableName;
                  tableName << name << "_" << entry.first << "_" << child.first;
                  printDecodeFunction(reinterpret_cast<DecodeTable*>(child.second), tableName.str());
               }
            }
         }
      };

   printDecodeFunction(&m_rootTable, "");
   out << std::endl;

   std::function<void(DecodeTable*, std::string name)> printDecodeInit =
      [&out, &printDecodeInit](DecodeTable* table, std::string name) {
         for (auto &entry : table->table) {
            std::stringstream tableName;
            tableName << name << "_" << entry.first;

            for (auto &child : entry.second) {
               out << "   " << "table" << tableName.str();
               out << "[" << child.first << "] = ";

               if (child.second->type == DecodeNode::Instruction) {
                  DecodeInstr *instr = reinterpret_cast<DecodeInstr*>(child.second);
                  out << "InstructionID::" << getSafeFunctionName(instr->op->disasm.name);
               } else if (child.second->type == DecodeNode::Table) {
                  out << "decode" << tableName.str() << "_" << child.first;
               }

               out << ";" << std::endl;
            }
         }

         for (auto &entry : table->table) {
            for (auto &child : entry.second) {
               if (child.second->type == DecodeNode::Table) {
                  std::stringstream tableName;
                  tableName << name << "_" << entry.first << "_" << child.first;
                  printDecodeInit(reinterpret_cast<DecodeTable*>(child.second), tableName.str());
               }
            }
         }
      };

   out << "bool init()" << std::endl;
   out << "{" << std::endl;
   printDecodeInit(&m_rootTable, "");
   out << "   " << "return true;" << std::endl;
   out << "}" << std::endl;
   
   out.close();
   std::cout << "EmuGen: " << path << std::endl;
   return true;
}

bool EmuGen::createInstructionTable(const std::string &path)
{
   std::fstream out;
   out.open(path, std::ifstream::out);

   if (!out.is_open()) {
      std::cout << "Could not open " << path << " for writing" << std::endl;
      return false;
   }

   std::size_t nameLen = 0;
   std::size_t opcdLen = 0;
   std::size_t fieldsLen = 0;
   std::vector<std::size_t> opnumLens;
   opnumLens.push_back(0);

   /* Get some lengths for formatting stuff */
   for (auto &instr : m_instructionList) {
      nameLen = std::max(nameLen, getSafeFunctionName(instr.first).length());
      opcdLen = std::max(opcdLen, 1 + instr.second->category->secondary.size());

      for (auto i = opnumLens.size(); i < opcdLen; ++i) {
         opnumLens.push_back(0);
      }

      std::size_t i = 0;

      for (; i < instr.second->category->secondary.size(); ++i) {
         std::size_t digits = numDigits(instr.second->category->secondary[i].first);
         opnumLens[i] = std::max(opnumLens[i], digits);
      }

      opnumLens[i] = std::max(opnumLens[i], static_cast<std::size_t>(numDigits(instr.second->id)));

      std::size_t readCount = 0, writeCount = 0, modCount = 0;
      std::size_t readLen = 0, writeLen = 0, modLen = 0;

      for (auto &opr : instr.second->disasm.operands) {
         if (opr.prefix == '+') {
            writeCount++;
            writeLen += opr.name.length();
         } else {
            readCount++;
            readLen += opr.name.length();
         }
      }

      for (auto &extra : instr.second->extras) {
         auto found = std::find_if(m_ast.insf.fields.begin(), m_ast.insf.fields.end(),
                                   [&extra](ast_insf_field& field) {
            return field.name.compare(extra.first) == 0;
         });

         if (found == m_ast.insf.fields.end()) {
            continue;
         }

         modCount++;
         modLen += extra.first.length();
      }

      if (readCount) {
         readLen += 1 + (readCount - 1) * 2;
      }

      if (writeCount) {
         writeLen += 1 + (writeCount - 1) * 2;
      }

      if (modCount) {
         modLen += 1 + (modCount - 1) * 2;
      }

      instr.second->fieldsLen = readLen + writeLen + modLen;
      fieldsLen = std::max(fieldsLen, instr.second->fieldsLen);
   }

   out.fill(' ');

   /* Enum is 1 index based */
   out << "InstrEntry Instructions[] = {" << std::endl;
   out << "   { }," << std::endl;

   for (auto &instr : m_instructionList) {
      std::string name = getSafeFunctionName(instr.first);

      out << "   { ";

      /* Instruction Name */
      out << '"' << name << '"' << ", ";

      for (std::size_t i = name.length(); i < nameLen; ++i) {
         out << ' ';
      }

      /* Opcode List { xo, 31 }, { xo2, 28 } */
      {
         std::size_t opnum = 0;

         out << "{ ";

         out << "{ " << instr.second->category->primary;

         for (auto &cat : instr.second->category->secondary) {
            out << ", ";

            out.setf(std::ios::adjustfield, std::ios::right);
            out.width(opnumLens[opnum++]);

            out << cat.first;

            out.width(0);
            out.unsetf(std::ios::adjustfield);

            out << " }, { " << cat.second;
         }

         out << ", ";

         out.setf(std::ios::adjustfield, std::ios::right);
         out.width(opnumLens[opnum]);

         out << instr.second->id;

         out.width(0);
         out.unsetf(std::ios::adjustfield);

         out << " }";

         for (std::size_t i = 1 + instr.second->category->secondary.size(); i < opcdLen; ++i) {
            for (std::size_t j = 0; j < 11 + opnumLens[i]; ++j) {
               out << ' ';
            }
         }

         out << " }, ";
      }

      /* Output Fields */
      {
         int count = 0;

         out << "{ ";

         for (auto &opr : instr.second->disasm.operands) {
            if (opr.prefix != '+') {
               continue;
            }

            if (count != 0) {
               out << ", ";
            }

            out << opr.name;
            ++count;
         }

         if (count > 0) {
            out << ' ';
         }

         out << "}, ";
      }

      /* Input Fields */
      {
         int count = 0;

         out << "{ ";

         for (auto &opr : instr.second->disasm.operands) {
            if (opr.prefix == '+') {
               continue;
            }

            if (count != 0) {
               out << ", ";
            }

            out << opr.name;
            ++count;
         }

         if (count > 0) {
            out << ' ';
         }

         out << "}, ";
      }

      /* Modifiers */
      {
         int count = 0;

         out << "{ ";

         for (auto &extra : instr.second->extras) {
            auto found = std::find_if(m_ast.insf.fields.begin(), m_ast.insf.fields.end(),
                                   [&extra](ast_insf_field& field) {
                                      return field.name.compare(extra.first) == 0;
                                   });

            if (found == m_ast.insf.fields.end()) {
               continue;
            }

            if (count != 0) {
               out << ", ";
            }

            out << extra.first;
            ++count;
         }

         if (count > 0) {
            out << ' ';
         }

         out << "}, ";
      }

      for (auto i = instr.second->fieldsLen; i < fieldsLen; ++i) {
         out << ' ';
      }

      /* Fullname */
      {
         out << '"' << *instr.second->extras["fullname"].string << '"';
      }

      out << " }," << std::endl;
   }
   out << "};" << std::endl;

   out.close();
   std::cout << "EmuGen: " << path << std::endl;
   return true;
}

bool EmuGen::createCpuInfo(const std::string &path)
{
   std::fstream out;
   out.open(path, std::ifstream::out);

   if (!out.is_open()) {
      std::cout << "Could not open " << path << " for writing" << std::endl;
      return false;
   }

   out << "struct Registers_ {" << std::endl;

   for (auto &reg : m_ast.reg.registers) {
      if (reg.type.bitfield) {
         int pos = 0;

         out << "   union {" << std::endl;
         out << "      " << reg.type.type << " value;" << std::endl;
         out << "      struct {" << std::endl;

         for (auto &field : reg.type.bitfield->bitfield) {
            int bits = 1 + field.second.end - field.second.start;

            if (pos != field.second.start) {
               out << "         " << reg.type.type << " : " << (field.second.start - pos) << ";" << std::endl;
               pos = field.second.start;
            }

            pos += bits;
            out << "         " << reg.type.type << " " << field.first << " : " << bits << ";" << std::endl;
         }

         out << "      };" << std::endl;
         out << "   } " << reg.name << ";" << std::endl;
      } else {
         out << "   " << reg.type.type << " " << reg.name;

         if (reg.type.array) {
            out << "[" << reg.type.array->size << "]";
         }

         out << ";" << std::endl;
      }
   }

   out << "};" << std::endl;
   out << std::endl;

   out << "namespace Fields {" << std::endl;
   out << "enum Field {" << std::endl;

   for (auto &field : m_ast.insf.fields) {
      out << "   " << field.name << "," << std::endl;
   }

   out << "};" << std::endl;
   out << "};" << std::endl;
   out << std::endl;
   out << "typedef unsigned Field;" << std::endl;
   out << std::endl;


   out << "union Instruction {" << std::endl;
   out << "   uint32_t value;" << std::endl;
   out << std::endl;

   out << "   unsigned get(Field field) const;" << std::endl;
   out << "   void set(Field field, unsigned value);" << std::endl;
   out << std::endl;

   for (auto &field : m_ast.insf.fields) {
      int start = field.bitrange.start;
      int end = field.bitrange.end;

      if (m_ast.arch.endian == ast_arch::BigEndian) {
         start = 31 - start;
         end   = 31 - end;
         std::swap(start, end);
      }
      
      out << std::endl;

      out << "   struct {" << std::endl;

      if (start != 0) {
         out << "      uint32_t : " << start << ";" << std::endl;
      }

      out << "      uint32_t " << field.name << " : " << (1 + end - start) << ";" << std::endl;

      if (end != 31) {
         out << "      uint32_t : " << (31 - end) << ";" << std::endl;
      }

      out << "   };" << std::endl;
   }

   out << "};" << std::endl;
   out << std::endl;

   out.close();
   std::cout << "EmuGen: " << path << std::endl;
   return true;
}

bool EmuGen::createStubs(const std::string &path)
{
   std::fstream out;
   out.open(path, std::ifstream::out);

   if (!out.is_open()) {
      std::cout << "Could not open " << path << " for writing" << std::endl;
      return false;
   }
   
   for (auto &instr : m_instructionList) {
      auto &fullname = *instr.second->extras["fullname"].string;

      out << "/* " << fullname << " */" << std::endl;
      out << "bool " << getSafeFunctionName(instr.first) << "(State *state, Instruction instr)" << std::endl;
      out << "{" << std::endl;
      out << "   return false;" << std::endl;
      out << "}" << std::endl << std::endl;
   }

   out.close();
   std::cout << "EmuGen: " << path << std::endl;
   return true;
}

bool EmuGen::createInstructionList(const std::string &path)
{
   std::fstream out;
   out.open(path, std::ifstream::out);
   
   if (!out.is_open()) {
      std::cout << "Could not open " << path << " for writing" << std::endl;
      return false;
   }

   out << "enum class InstructionID {" << std::endl;

   out << "   Unknown," << std::endl;

   for (auto &instr : m_instructionList) {
      out << "   " << getSafeFunctionName(instr.first) << "," << std::endl;
   }

   out << "   InstructionMax," << std::endl;

   out << "};" << std::endl;

   out.close();
   std::cout << "EmuGen: " << path << std::endl;
   return true;
}

bool EmuGen::createStubsHeader(const std::string &path)
{
   std::fstream out;
   out.open(path, std::ifstream::out);

   if (!out.is_open()) {
      std::cout << "Could not open " << path << " for writing" << std::endl;
      return false;
   }

   out << std::endl;

   for (auto &instr : m_instructionList) {
      out << "bool " << getSafeFunctionName(instr.first) << "(State *state, Instruction instr);" << std::endl;
   }

   out.close();
   std::cout << "EmuGen: " << path << std::endl;
   return true;
}

bool EmuGen::createInstructionTableSource(const std::string &path)
{
   std::fstream out;
   out.open(path, std::ifstream::out);

   if (!out.is_open()) {
      std::cout << "Could not open " << path << " for writing" << std::endl;
      return false;
   }


   out << "fptr_t _emugenTable[] = {" << std::endl;
   out << "   nullptr," << std::endl;

   for (auto &instr : m_instructionList) {
      out << "   " << getSafeFunctionName(instr.first) << "," << std::endl;
   }

   out << "};" << std::endl;

   out.close();
   std::cout << "EmuGen: " << path << std::endl;
   return true;
}

std::string EmuGen::getSafeFunctionName(const std::string &name)
{
   std::string result = name;
   std::replace(result.begin(), result.end(), '.', 'o');
   return result;
}

ast_insf_field *EmuGen::findInstructionField(std::string name)
{
   if (name[0] == '(') {
      name.erase(name.begin());
      name.erase(name.end() - 1);
   }

   for (auto &field : m_ast.insf.fields) {
      if (name.compare(field.name) == 0) {
         return &field;
      }
   }

   return nullptr;
}

```

`tools/emugen/emugen.h`:

```h
#ifndef EMUGEN_H
#define EMUGEN_H

#include "ast.h"

#include <string>
#include <map>

struct DecodeNode
{
   enum Type
   {
      Invalid,
      Instruction,
      Table
   };

   DecodeNode(Type type) : type(type)
   {
   }

   Type type;
};

struct DecodeTable : public DecodeNode
{
   DecodeTable() : DecodeNode(DecodeNode::Table)
   {
   }

   std::map<std::string, std::map<int, DecodeNode*>> table;
};

struct DecodeInstr : public DecodeNode
{
   DecodeInstr() : DecodeNode(DecodeNode::Instruction)
   {
   }

   ast_opcd_def *op;
};

class EmuGen
{
public:
   EmuGen();
   ~EmuGen();

   bool run(const std::string &definition, const std::string &outDirectory);

protected:
   bool parseFile(const std::string &path);

   bool createStubs(const std::string &path);
   bool createStubsHeader(const std::string &path);

   bool createCpuInfo(const std::string &path);
   bool createInstructionTable(const std::string &path);
   bool createDecoder(const std::string &path);

   bool createInstructionList(const std::string &path);
   bool createInstructionTableSource(const std::string &path);

   ast_insf_field *findInstructionField(std::string name);
   static std::string getSafeFunctionName(const std::string &name);

private:
   ast_root m_ast;
   std::map<std::string, ast_opcd_def *> m_instructionList;
   DecodeTable m_rootTable;
};

#endif // ifdef EMUGEN_H

```

`tools/emugen/main.cpp`:

```cpp
#include "emugen.h"
#include <iostream>

int main(int argc, char **argv)
{
   if (argc < 3) {
      std::cout << "Usage: " << argv[0] << " <definition file> <output directory>" << std::endl;
      return 0;
   }

   EmuGen app;
   app.run(argv[1], argv[2]);
   return 0;
}

```

`tools/emugen/parser.cpp`:

```cpp
#include <prs/parser.h>
#include "emugen.h"
#include "ast.h"

#include <fstream>
#include <iostream>

ast_cat_opcd *g_curCategory = nullptr;

using namespace prs;

/* Character Types */
auto whitespace    = atomic(*(char_(' ') | char_('\t') | char_('\n') | char_('\r')));
auto letter        = char_range('a', 'z') | char_range('A', 'Z');
auto digit         = char_range('0', '9');

/* Data Types */
auto number        = ast<ast_number>()   >> atomic(+digit);
auto bitrange      = ast<ast_bitrange>() >> atomic(number >> -(string_("...") >> number));
auto chr           = ast<ast_char>()     >> atomic(char_('\'') >> char_any() >> char_('\''));
auto str           = ast<ast_string>()   >> atomic(char_('"') >> +(!char_('"') >> char_any()) >> char_('"'));
auto symbol        = ast<ast_symbol>()   >> atomic((letter | char_('_')) >> *(letter | digit | char_('_')));
auto name          = ast<ast_symbol>()   >> atomic((letter | char_('_')) >> *(letter | digit | char_('_') | char_('.')));

/* Register Types */
auto type_intb     = ast<ast_symbol>()      >> atomic(-char_('u') >> string_("int") >> +digit);
auto type_double   = ast<ast_symbol>()      >> string_("double");
auto type_array    = ast<ast_array>()       >> (char_('[') >> number >> char_(']'));
auto type_bitfield = ast<ast_bitfield>()    >> (char_('{') >> +(symbol >> char_('=') >> bitrange) >> char_('}'));

/* Architecture Specification */
auto cat_arch      = string_("[Architecture]");
auto arch_endian   = ast<ast_arch_endian>() >> (string_("Endian") >> char_('=') >> (string_("BigEndian") | string_("LittleEndian")));
auto arch_root     = ast<ast_arch>()        >> arch_endian;

/* Register Specification */
auto cat_reg       = string_("[Registers]");
auto reg_type      = ast<ast_reg_type>()    >> ((type_intb | type_double) >> -(type_array | type_bitfield));
auto reg_define    = ast<ast_reg_define>()  >> (symbol >> char_('=') >> reg_type);
auto reg_root      = ast<ast_reg>()         >> *reg_define;

/* Instruction Format */
auto cat_insf      = string_("[Instruction Format]");
auto insf_extra    = ast<ast_insf_extra>()  >> (symbol >> char_('=') >> (number | str | chr));
auto insf_field    = ast<ast_insf_field>()  >> (symbol >> char_('=') >> bitrange >> -(char_(':') >> insf_extra >> *(char_(',') >> insf_extra)));
auto insf_root     = ast<ast_insf>()        >> *insf_field;

/* Opcode Definition */
auto cat_opcd      = ast<ast_cat_opcd>()    >> (char_('[') >> symbol >> *(char_('=') >> number >> char_(',') >> symbol) >> char_(']'));
auto opcd_extra    = ast<ast_opcd_extra>()  >> (symbol >> -(char_('=') >> (number | str | chr)));
auto opcd_disasm_reg = ast<ast_opcd_disasm_reg>() >> (-char_('+') >> symbol);
auto opcd_disasm   = ast<ast_opcd_disasm>() >> (name >> -(opcd_disasm_reg >> *((char_(',') | char_('(')) >> opcd_disasm_reg >> -char_(')'))));
auto opcd_def      = ast<ast_opcd_def>()    >> (number >> char_(':') >> opcd_disasm >> -(char_(':') >> opcd_extra >> *(char_(',') >> opcd_extra)));
auto opcd_root     = ast<ast_opcd>()        >> (cat_opcd >> *opcd_def);

/* The root parser rule */
auto parser_root   = ast<ast_root>() >> +((cat_arch >> arch_root) | (cat_reg >> reg_root) | (cat_insf >> insf_root) | opcd_root);

bool EmuGen::parseFile(const std::string &path)
{
   std::fstream in;
   std::string file;

   in.open(path, std::ifstream::in);

   if (!in.is_open()) {
      std::cout << "Could not open " << path << " for reading" << std::endl;
      return false;
   }

   /* Read file and remove all comments */
   for (std::string line; std::getline(in, line); ) {
      auto p = line.rfind("//");

      if (p != std::string::npos) {
         file.append(line.begin(), line.begin() + p);
      } else {
         file.append(line.begin(), line.end());
      }

      file += '\n';
   }

   in.close();

   /* Parse file */
   struct ParseContext {
      decltype(whitespace) whitespace_parser;
   } ctx = { whitespace };

   auto pos = file.begin();

   if (!parser_root.parse(pos, file.end(), ctx, m_ast) || pos != file.end()) {
      decltype(pos) lineStart, lineEnd;
      auto error = pos;

      for (lineStart = pos; lineStart != file.begin() && *lineStart != '\n'; --lineStart);
      for (lineEnd = pos; lineEnd != file.end() && *lineEnd != '\n'; ++lineEnd);

      std::cout << "Syntax Error" << std::endl;
      std::cout << std::string(lineStart, lineEnd) << std::endl;
      std::cout << std::string((size_t)(pos - lineStart), ' ') << '^' << std::endl;

      return false;
   }

   return true;
}

template<typename Iterator>
static inline std::pair<Iterator, Iterator> getLine(Iterator begin, Iterator pos, Iterator end)
{
   typename Iterator lineStart, lineEnd;

   for (lineStart = pos; lineStart != begin && *lineStart != '\n'; --lineStart);
   for (lineEnd = pos; lineEnd != end && *lineEnd != '\n'; ++lineEnd);

   return std::make_pair(++lineStart, lineEnd);
}

```

`tools/ex360tester/elf.h`:

```h
#ifndef ELF_H
#define ELF_H

#include <stdint.h>
#include <fstream>
#include <string>

#include "common/byte_swap.h"

namespace elf
{

struct Elf64_Ehdr
{
   unsigned char e_ident[16];
   uint16_t e_type;
   uint16_t e_machine;
   uint32_t e_version;
   uint64_t e_entry;
   uint64_t e_phoff;
   uint64_t e_shoff;
   uint32_t e_flags;
   uint16_t e_ehsize;
   uint16_t e_phentsize;
   uint16_t e_phnum;
   uint16_t e_shentsize;
   uint16_t e_shnum;
   uint16_t e_shstrndx;
};

struct Elf64_Shdr
{
   uint32_t sh_name;
   uint32_t sh_type;
   uint64_t sh_flags;
   uint64_t sh_addr;
   uint64_t sh_offset;
   uint64_t sh_size;
   uint32_t sh_link;
   uint32_t sh_info;
   uint64_t sh_addralign;
   uint64_t sh_entsize;
};

bool load(const std::string &path, uint64_t *sizeOut, uint8_t **codeOut)
{
   std::ifstream in;
   Elf64_Ehdr hdr;
   Elf64_Shdr txt;
   uint8_t *code;

   in.open(path, std::ifstream::in | std::ifstream::binary);

   if (!in.is_open()) {
      return false;
   }

   /* Read Big Endian Header */
   in.read(reinterpret_cast<char*>(&hdr), sizeof(Elf64_Ehdr));
   hdr.e_shoff = byte_swap(hdr.e_shoff);

   /* Read code section[1] */
   in.seekg(hdr.e_shoff + sizeof(Elf64_Shdr), in.beg);
   in.read(reinterpret_cast<char*>(&txt), sizeof(Elf64_Shdr));

   txt.sh_size = byte_swap(txt.sh_size);
   txt.sh_offset = byte_swap(txt.sh_offset);

   /* Read Code*/
   code = new uint8_t[txt.sh_size];
   in.seekg(txt.sh_offset, in.beg);
   in.read(reinterpret_cast<char*>(code), txt.sh_size);

   in.close();

   *sizeOut = txt.sh_size;
   *codeOut = code;
   return true;
}

} // namespace elf

#endif // ifndef ELF_H

```

`tools/ex360tester/main.cpp`:

```cpp
#include "tester.h"
#include "xenon.h"

#include <iostream>

int main(int argc, char** argv)
{
   if (argc < 3) {
      std::cout << argv[0] << "<xenon\bin> <in dir>" << std::endl;
      return -1;
   }

   xenon::setPath(argv[1]);
   g_tester.run(argv[2]);

   return 0;
}

```

`tools/ex360tester/parser.cpp`:

```cpp
#include "parser.h"
#include "common/log.h"

#include <fstream>
#include <prs/parser.h>

using namespace prs;

auto whitespace  = atomic(*(char_(' ') | char_('\t') | char_('\n') | char_('\r')));
auto letter      = char_range('a', 'z') | char_range('A', 'Z');
auto digit       = char_range('0', '9');

auto number      = ast<ast_number>() >> atomic(-char_('-') >> *digit);
auto hex         = ast<ast_number>() >> atomic(-char_('-') >> string_("0x") >> +(digit | char_range('a', 'f') | char_range('A', 'F')));

auto reg_name    = ast<ast_string>() >> atomic(char_('%') >> +(letter | digit | char_('[') | char_(']')));
auto reg_value   = hex | number;

auto mem_address = ast<ast_mem_address>() >> (char_('[') >> hex >> char_(']'));

auto reg_set     = ast<ast_reg_set>() >> (reg_name >> char_('=') >> (mem_address | reg_value));
auto reg_check   = ast<ast_reg_check>() >> (reg_name >> string_("==") >> (mem_address | reg_value));

auto mem_set     = ast<ast_mem_set>() >> (mem_address >> char_('=') >> reg_value);

auto pre_condition  = ast<ast_precondition>() >> (char_('#') >> string_("pre") >> char_(':') >> (reg_set | mem_set));
auto post_condition = ast<ast_postcondition>() >> (char_('#') >> string_("post") >> char_(':') >> reg_check);

auto test_parser    = ast<ast_test>() >> +(pre_condition | post_condition);

bool parseTest(const std::string &path, ast_test &result)
{
   std::fstream in;
   std::string file;

   in.open(path, std::ifstream::in);

   if (!in.is_open()) {
      xDebug() << "Could not open " << path << " for reading";
      return false;
   }

   /* Read only lines beginning with # */
   for (std::string line; std::getline(in, line);) {
      if (line.size() && line.at(0) == '#') {
         file.append(line.begin(), line.end());
         file += '\n';
      }
   }

   in.close();

   /* Parse file */
   struct ParseContext
   {
      decltype(whitespace) whitespace_parser;
   } ctx = { whitespace };

   auto pos = file.begin();

   if (!test_parser.parse(pos, file.end(), ctx, result) || pos != file.end()) {
      decltype(pos) lineStart, lineEnd;
      auto error = pos;

      for (lineStart = pos; lineStart != file.begin() && *lineStart != '\n'; --lineStart);
      for (lineEnd = pos; lineEnd != file.end() && *lineEnd != '\n'; ++lineEnd);

      xDebug() << "Syntax Error";
      std::cout << std::endl;
      std::cout << std::string(lineStart, lineEnd) << std::endl;
      std::cout << std::string((size_t)(pos - lineStart), ' ') << '^' << std::endl;

      return false;
   }

   return true;
}

```

`tools/ex360tester/parser.h`:

```h
#ifndef TEST_PARSER_H
#define TEST_PARSER_H

#include <stdint.h>
#include <string>
#include <vector>
#include <prs/optional.h>

struct ast_string
{
   std::string value;

   template<typename Result>
   void construct(Result &&result)
   {
      value = ast_to_string<std::string>(result);
   }
};

struct ast_number
{
   int64_t value;

   template<typename Result>
   void construct(Result &&result)
   {
      auto str_value = ast_to_string<std::string>(result);

      if (str_value.size() >= 18) {
         value = std::stoull(str_value, 0, 0);
      } else if (str_value.size() > 0) {
         value = std::stoll(str_value, 0, 0);
      } else {
         value = 0;
      }
   }
};

struct ast_mem_address
{
   int64_t value;

   template<typename Result>
   void construct(Result &&result)
   {
      value = std::get<1>(result).value;
   }
};

struct ast_reg_set
{
   std::string reg_name;
   prs::optional<int64_t> reg_value;
   prs::optional<int64_t> mem_addr;

   template<typename Result>
   void construct(Result &&result)
   {
      reg_name = std::get<0>(result).value;

      auto &value = std::get<2>(result);

      switch (value.which) {
      case 0:
         mem_addr = std::get<0>(value)->value;
         break;
      case 1:
         reg_value = std::get<1>(value)->value;
         break;
      }
   }
};

struct ast_mem_set
{
   int64_t mem_addr;
   int64_t mem_value;

   template<typename Result>
   void construct(Result &&result)
   {
      mem_addr = std::get<0>(result).value;
      mem_value = std::get<2>(result).value;
   }
};

struct ast_reg_check
{
   std::string reg_name;
   prs::optional<int64_t> reg_value;
   prs::optional<int64_t> mem_addr;

   template<typename Result>
   void construct(Result &&result)
   {
      reg_name = std::get<0>(result).value;

      auto &value = std::get<2>(result);

      switch(value.which)
      {
      case 0:
         mem_addr = std::get<0>(value)->value;
         break;
      case 1:
         reg_value = std::get<1>(value)->value;
         break;
      }
   }
};

struct ast_precondition
{
   prs::optional<ast_reg_set> reg_set;
   prs::optional<ast_mem_set> mem_set;

   template<typename Result>
   void construct(Result &&result)
   {
      auto &value = std::get<3>(result);

      switch (value.which) {
      case 0:
         reg_set = std::get<0>(value);
         break;
      case 1:
         mem_set = std::get<1>(value);
         break;
      }
   }
};

struct ast_postcondition
{
   prs::optional<ast_reg_check> reg_check;

   template<typename Result>
   void construct(Result &&result)
   {
      reg_check = std::get<3>(result);
   }
};

struct ast_test
{
   std::vector<ast_precondition> pre;
   std::vector<ast_postcondition> post;

   template<typename Result>
   void construct(Result &&result)
   {
      for (auto &value : result) {
         switch (value.which) {
         case 0:
            pre.push_back(*std::get<0>(value));
            break;
         case 1:
            post.push_back(*std::get<1>(value));
            break;
         }
      }
   }
};

bool parseTest(const std::string &path, ast_test &result);

#endif // ifndef TEST_PARSER_H

```

`tools/ex360tester/test.cpp`:

```cpp
#include "test.h"

#include "elf.h"
#include "xenon.h"
#include "parser.h"
#include "tester.h"

#include "powerpc/interpreter/interpreter.h"
#include "common/memory.h"
#include <regex>

Test::Test() :
   m_code(nullptr), m_codeSize(0)
{
}

Test::~Test()
{
   delete[] m_code;
}

/* Load test from file */
bool Test::load(const std::string &path)
{
   ast_test astTest;
   std::string tmpElf;

   tmpElf = g_tester.getTestRoot() + "\\tmp.elf";

   /* Assemble test to elf */
   if (!xenon::assemble(path, tmpElf)) {
      return false;
   }

   /* Load code from elf for execution */
   if (!elf::load(tmpElf, &m_codeSize, &m_code)) {
      return false;
   }

   /* Parse test file for pre&post conditions */
   if (!parseTest(path, astTest)) {
      return false;
   }

   /* Parse Pre-Conditions */
   for (auto &astPre : astTest.pre) {
      Condition cond;

      if (astPre.reg_set) {
         cond.type = ConditionType::SetRegister;

         cond.target.type = ValueType::Register;
         cond.target.name = astPre.reg_set->reg_name;

         if (astPre.reg_set->mem_addr) {
            cond.value.type = ValueType::Address;
            cond.value.value = *astPre.reg_set->mem_addr;
         } else if (astPre.reg_set->reg_value) {
            cond.value.type = ValueType::Immediate;
            cond.value.value = *astPre.reg_set->reg_value;
         }
      } else if (astPre.mem_set) {
         cond.type = ConditionType::SetMemory;

         cond.target.type = ValueType::Address;
         cond.target.value = astPre.mem_set->mem_addr;

         cond.value.type = ValueType::Immediate;
         cond.value.value = astPre.mem_set->mem_value;
      }

      m_preconditions.push_back(cond);
   }

   /* Parse Post-Conditions */
   for (auto &astPost : astTest.post) {
      Condition cond;

      if (astPost.reg_check) {
         cond.type = ConditionType::CheckRegister;

         cond.target.type = ValueType::Register;
         cond.target.name = astPost.reg_check->reg_name;

         if (astPost.reg_check->mem_addr) {
            cond.value.type = ValueType::Address;
            cond.value.value = *astPost.reg_check->mem_addr;
         } else if (astPost.reg_check->reg_value) {
            cond.value.type = ValueType::Immediate;
            cond.value.value = *astPost.reg_check->reg_value;
         }
      }

      m_postconditions.push_back(cond);
   }

   return true;
}

/* Run interpreter on a test */
bool Test::run()
{
   ppc::Interpreter::State state;
   memset(&state, 0, sizeof(state));

   state.cia = 0;
   state.nia = state.cia + 4;
   state.reg.lr = m_codeSize;

   if (!checkConditions(state, m_preconditions)) {
      return false;
   }
   
   while (state.cia < m_codeSize) {
      ppc::Instruction instr;

      instr.value = Memory::read<uint32_t>(reinterpret_cast<uint64_t>(m_code + state.cia));
      ppc::Interpreter::decode(&state, instr);

      state.cia = state.nia;
      state.nia = state.cia + 4;
   }

   if (!checkConditions(state, m_postconditions)) {
      return false;
   }

   return true;
}

/* Translate address */
uint64_t Test::translateAddress(uint64_t addr)
{
   auto base = g_tester.getTestMemoryAddress();

   if (addr >= base && addr < base + 0x100) {
      return addr - base + 0x1000;
   } else {
      return addr + base - 0x1000;
   }
}

/* Get value */
bool Test::getValue(Test::Value &in, int64_t &out)
{
   switch (in.type) {
   case Test::ValueType::Immediate:
      out = in.value;
      return true;
   case Test::ValueType::Address:
      out = translateAddress(in.value);
      return true;
   }

   return false;
}

/* Get register by name */
Test::Register Test::getRegister(ppc::Interpreter::State &state, const std::string &name)
{
   std::smatch smatch;

   /* General Purpose Register */
   std::regex gpr("%r([0-9]+)");

   if (std::regex_match(name, smatch, gpr) && smatch.size() == 2) {
      auto reg = std::stol(smatch[1].str());

      if (reg >= 0 && reg <= 31) {
         return Register(RegisterType::Integer64, &state.reg.gpr[reg]);
      }
   }

   /* FPU Register */
   std::regex fpr("%f([0-9]+)");

   if (std::regex_match(name, smatch, fpr) && smatch.size() == 2) {
      auto reg = std::stol(smatch[1].str());

      if (reg >= 0 && reg <= 31) {
         return Register(RegisterType::Double64, &state.reg.fpr[reg]);
      }
   }

   /* XER Link Register */
   if (name.compare("%lr") == 0) {
      return Register(RegisterType::Integer64, &state.reg.lr);
   }

   /* XER Carry */
   if (name.compare("%xer[ca]") == 0) {
      return Register(RegisterType::BitField64, little_endian::make_bit_field(state.reg.xer.value, 34, 35));
   }

   /* XER Overflow */
   if (name.compare("%xer[ov]") == 0) {
      return Register(RegisterType::BitField64, little_endian::make_bit_field(state.reg.xer.value, 33, 34));
   }

   /* Condition Register Field */
   std::regex crf("%crf([0-9]+)");

   if (std::regex_match(name, smatch, crf) && smatch.size() == 2) {
      auto field = std::stol(smatch[1].str());

      if (field >= 0 && field <= 8) {
         return Register(RegisterType::BitField32, state.reg.cr.crn[field]);
      }
   }

   /* Condition Register Bit */
   std::regex crb("%crb([0-9]+)");

   if (std::regex_match(name, smatch, crb) && smatch.size() == 2) {
      auto bit = std::stol(smatch[1].str());

      if (bit >= 0 && bit <= 31) {
         return Register(RegisterType::BitField32, little_endian::make_bit_field(state.reg.cr.value, bit, bit));
      }
   }

   return Register();
}

/* Set register to value */
bool Test::setRegister(ppc::Interpreter::State &state, const std::string &name, Test::Value &val)
{
   int64_t value;
   Register reg;

   if (!getValue(val, value)) {
      return false;
   }

   reg = getRegister(state, name);

   switch (reg.type) {
   case RegisterType::Integer32:
      *reinterpret_cast<uint32_t*>(reg.ptr) = static_cast<uint32_t>(value);
      break;
   case RegisterType::Integer64:
      *reinterpret_cast<uint64_t*>(reg.ptr) = static_cast<uint64_t>(value);
      break;
   case RegisterType::Float32:
      *reinterpret_cast<float*>(reg.ptr) = static_cast<float>(value);
      break;
   case RegisterType::Double64:
      *reinterpret_cast<double*>(reg.ptr) = static_cast<double>(value);
      break;
   case RegisterType::BitField32:
      *reinterpret_cast<dyn_bit_field_t<uint32_t>*>(reg.buf) = static_cast<uint32_t>(value);
      break;
   case RegisterType::BitField64:
      *reinterpret_cast<dyn_bit_field_t<uint64_t>*>(reg.buf) = static_cast<uint64_t>(value);
      break;
   default:
      return false;
   }

   return true;
}

/* Check register for value */
bool Test::checkRegister(ppc::Interpreter::State &state, const std::string &name, Test::Value &val)
{
   int64_t value;
   Register reg;

   if (!getValue(val, value)) {
      return false;
   }

   reg = getRegister(state, name);

   switch (reg.type) {
   case RegisterType::Integer32:
      return *reinterpret_cast<uint32_t*>(reg.ptr) == static_cast<uint32_t>(value);

   case RegisterType::Integer64:
      return *reinterpret_cast<uint64_t*>(reg.ptr) == static_cast<uint64_t>(value);

   case RegisterType::Float32:
      return *reinterpret_cast<float*>(reg.ptr) == static_cast<float>(value);

   case RegisterType::Double64:
      return *reinterpret_cast<double*>(reg.ptr) == static_cast<double>(value);

   case RegisterType::BitField32:
      return *reinterpret_cast<dyn_bit_field_t<uint32_t>*>(reg.buf) == static_cast<uint32_t>(value);

   case RegisterType::BitField64:
      return *reinterpret_cast<dyn_bit_field_t<uint64_t>*>(reg.buf) == static_cast<uint64_t>(value);
   }

   return false;
}

/* Set memory to value */
bool Test::setMemory(ppc::Interpreter::State &state, uint64_t dst, Test::Value &val)
{
   int64_t value;
   auto addr = translateAddress(dst);

   if (!addr || !getValue(val, value)) {
      return false;
   }

   Memory::write(addr, value);
   return true;
}

/* Check memory for value */
bool Test::checkMemory(ppc::Interpreter::State &state, uint64_t src, Test::Value &val)
{
   int64_t value;
   auto addr = translateAddress(src);

   if (!addr || !getValue(val, value)) {
      return false;
   }

   return value == Memory::read<uint64_t>(addr);
}

/* Ensure a Condition is met */
bool Test::checkConditions(ppc::Interpreter::State &state, std::vector<Test::Condition> &conds)
{
   for (auto &cond : conds) {
      switch (cond.type) {
      case ConditionType::SetRegister:
         if (cond.target.type != ValueType::Register) {
            return false;
         }

         if (!setRegister(state, cond.target.name, cond.value)) {
            throw new TestError(state, "Could not set register %s", cond.target.name.c_str());
         }

         break;

      case ConditionType::CheckRegister:
         if (cond.target.type != ValueType::Register) {
            return false;
         }

         if (!checkRegister(state, cond.target.name, cond.value)) {
            throw new TestError(state, "Incorrect value in register %s", cond.target.name.c_str());
         }

         break;

      case ConditionType::SetMemory:
         if (cond.target.type != ValueType::Address) {
            return false;
         }

         if (!setMemory(state, cond.target.value, cond.value)) {
            throw new TestError(state, "Could not set memory at 0x%X", translateAddress(cond.target.value));
         }

         break;

      case ConditionType::CheckMemory:
         if (cond.target.type != ValueType::Address) {
            return false;
         }

         if (!checkMemory(state, cond.target.value, cond.value)) {
            throw new TestError(state, "Incorrect value at memory location 0x%X", translateAddress(cond.target.value));
         }

         break;
      }
   }

   return true;
}

```

`tools/ex360tester/test.h`:

```h
#ifndef TEST_H
#define TEST_H

#include <string>
#include <vector>
#include <stdint.h>
#include <stdexcept>
#include <stdarg.h>
#include <sstream>

#include "powerpc/interpreter/interpreter.h"
#include "common/bit_field.h"

class TestError
{
public:
   TestError(ppc::Interpreter::State &state, const char * msg, ...)
   {
      va_list args;

      m_message.resize(256);

      va_start(args, msg);
      vsprintf_s(const_cast<char*>(m_message.data()), 256, msg, args);
      va_end(args);

      memcpy(&m_state, &state, sizeof(state));
   }

   const char* what() const
   {
      return m_message.c_str();
   }

   std::string dumpState() const
   {
      std::stringstream out;

      for (int i = 0; i < 32; ++i) {
         out << "gpr[" << i << "] = 0x" << std::hex << m_state.reg.gpr[i];

         if (i < 31) {
            out << ", ";
         }
      }

      out << std::endl;

      for (int i = 0; i < 32; ++i) {
         out << "fpr[" << i << "] = " << std::dec << m_state.reg.fpr[i];

         if (i < 31) {
            out << ", ";
         }
      }

      out << std::endl;

      return out.str();
   }

private:
   std::string m_message;
   ppc::Interpreter::State m_state;
};

class Test
{
public:
   enum class ConditionType
   {
      SetRegister,
      SetMemory,
      CheckRegister,
      CheckMemory
   };

   enum class ValueType
   {
      Register,
      Immediate,
      Address
   };

   struct Value
   {
      ValueType type;
      std::string name;
      uint64_t value;
   };

   struct Condition
   {
      ConditionType type;
      Value target;
      Value value;
   };

   enum class RegisterType
   {
      Unknown,
      Integer32,
      Integer64,
      Float32,
      Double64,
      BitField32,
      BitField64,
   };

   struct Register
   {
      Register() :
      type(RegisterType::Unknown)
      {
      }

      template<typename PtrType>
      Register(RegisterType type, PtrType *ptr) :
         type(type), ptr(ptr)
      {
      }

      template<typename ValType>
      Register(RegisterType type, dyn_bit_field_t<ValType> &val) :
         type(type)
      {
         new (buf) dyn_bit_field_t<ValType>(val);
      }

      RegisterType type;
      void *ptr;
      char buf[32];
   };

public:
   Test();
   ~Test();

   bool load(const std::string &path);
   bool run();

private:
   bool checkConditions(ppc::Interpreter::State &state, std::vector<Condition> &conds);

   bool setRegister(ppc::Interpreter::State &state, const std::string &name, Value &value);
   bool checkRegister(ppc::Interpreter::State &state, const std::string &name, Value &value);

   bool setMemory(ppc::Interpreter::State &state, uint64_t addr, Value &value);
   bool checkMemory(ppc::Interpreter::State &state, uint64_t addr, Value &value);

   uint64_t translateAddress(uint64_t addr);
   bool getValue(Test::Value &in, int64_t &out);
   Register getRegister(ppc::Interpreter::State &state, const std::string &name);

private:
   uint8_t *m_code;
   uint64_t m_codeSize;

   std::vector<Condition> m_preconditions;
   std::vector<Condition> m_postconditions;
};

#endif

```

`tools/ex360tester/tester.cpp`:

```cpp
#include "tester.h"

#include "test.h"

#include <iostream>
#include <filesystem>
#include "powerpc/interpreter/interpreter.h"

Tester g_tester;

Tester::Tester()
{
   m_testMemory = new uint8_t[0x100];
}

Tester::~Tester()
{
   delete[] m_testMemory;
}

bool Tester::run(const std::string &root)
{
   m_testRoot = root;

   for (auto itr = std::tr2::sys::recursive_directory_iterator(root); itr != std::tr2::sys::recursive_directory_iterator(); ++itr) {
      if (std::tr2::sys::is_regular_file(itr->status()) && itr->path().extension().compare(".s") == 0) {
         try {
            if (runTest(itr->path())) {
               std::cout << "[PASS] " << itr->path().filename() << std::endl;
            } else {
               std::cout << "[FAIL] Unknown error in " << itr->path().filename() << std::endl;
            }
         } catch (TestError *error) {
            std::cout << "[FAIL] " << itr->path().filename() << std::endl;
            std::cout << error->what() << std::endl;
            std::cout << error->dumpState() << std::endl;
            delete error;
         }
      }
   }

   return true;
}

bool Tester::runTest(const std::string &path)
{
   Test test;

   if (!test.load(path)) {
      return false;
   }

   return test.run();
}

std::string Tester::getTestRoot()
{
   return m_testRoot;
}

uint64_t Tester::getTestMemoryAddress()
{
   return reinterpret_cast<uint64_t>(m_testMemory);
}

```

`tools/ex360tester/tester.h`:

```h
#ifndef TESTER_H
#define TESTER_H

#include <string>
#include <stdint.h>

class Tester
{
public:
   Tester();
   ~Tester();

   bool run(const std::string &root);

   std::string getTestRoot();
   uint64_t getTestMemoryAddress();

private:
   bool runTest(const std::string &test);

private:
   std::string m_testRoot;
   uint8_t *m_testMemory;
};

extern Tester g_tester;

#endif // ifndef TESTER_H

```

`tools/ex360tester/xenon.cpp`:

```cpp
#include "xenon.h"
#include "tester.h"

#include <Windows.h>
#include <iostream>

std::pair<DWORD, std::string> execute(const std::string& path, const std::string& args, const std::string &workDir)
{
   HANDLE hReadOut, hWriteOut;
   SECURITY_ATTRIBUTES sa;
   PROCESS_INFORMATION pi;
   STARTUPINFOA si;
   BOOL success;
   CHAR buf[512];
   DWORD exitCode = -1;
   std::string output;
   DWORD dwRead;

   memcpy(buf, path.c_str(), path.length());
   buf[path.length()] = ' ';
   memcpy(buf + path.length() + 1, args.c_str(), args.length());
   buf[path.length() + 1 + args.length()] = 0;

   sa.nLength = sizeof(SECURITY_ATTRIBUTES);
   sa.bInheritHandle = TRUE;
   sa.lpSecurityDescriptor = NULL;

   if (!CreatePipe(&hReadOut, &hWriteOut, &sa, 0)) {
      output = "Could not create pipe";
      return std::make_pair(exitCode, output);
   }

   ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));
   ZeroMemory(&si, sizeof(STARTUPINFOA));

   si.cb = sizeof(STARTUPINFOA);
   si.hStdError = hWriteOut;
   si.hStdOutput = hWriteOut;
   si.hStdInput = NULL;
   si.dwFlags |= STARTF_USESTDHANDLES;

   success = CreateProcessA(NULL, buf, NULL, NULL, TRUE, 0, NULL, workDir.c_str(), &si, &pi);

   if (!success) {
      output = "CreateProcessA failed";
      return std::make_pair(exitCode, output);
   }

   CloseHandle(hWriteOut);

   for (;;) {
      success = ReadFile(hReadOut, buf, 512, &dwRead, NULL);

      if (!success || dwRead == 0) {
         break;
      }

      output.append(buf, dwRead);
   }

   WaitForSingleObject(pi.hProcess, INFINITE);
   GetExitCodeProcess(pi.hProcess, &exitCode);
   CloseHandle(pi.hProcess);
   CloseHandle(pi.hThread);
   CloseHandle(hReadOut);

   return std::make_pair(exitCode, output);
}


namespace xenon
{

std::string xenonPath;

void setPath(const std::string &path)
{
   xenonPath = path;
}

bool assemble(const std::string &in, const std::string &out)
{
   std::string args = in + " -o \"" + out + "\"";
   std::string wd = g_tester.getTestRoot();

   auto result = execute(xenonPath + "\\xenon-as.exe", args, wd);

   if (result.first != 0) {
      std::cout << result.second << std::endl;
   }

   return result.first == 0;
}

};

```

`tools/ex360tester/xenon.h`:

```h
#ifndef XENON_H
#define XENON_H

#include <string>

namespace xenon
{
   void setPath(const std::string &path);

   bool assemble(const std::string &in, const std::string &out);
};

#endif

```