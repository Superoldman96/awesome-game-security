Project Path: arc_gmh5225_vm_str.hpp_bj9h6ww6

Source Tree:

```txt
arc_gmh5225_vm_str.hpp_bj9h6ww6
├── LICENSE
├── README.md
└── vm_str.hpp

```

`LICENSE`:

```
MIT License

Copyright (c) 2025 Monokuma

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# vm_str.hpp
vm_str.hpp is a header only C++20 compile time string obfuscator.

# About
I got this idea floating in my head about trying to do something like xorstr, but with random constexpr-chosen operations instead of just xor. 

At compile time (constexpr), the library generates bytecode representing the obfuscation schema. Then, at runtime, a stack-based VM interprets this bytecode to reconstruct the original string.

The string is constructed on the stack at runtime and does not appear anywhere in the executable prior to execution. 

<img width="1365" height="589" alt="Captura de tela 2025-08-06 190129" src="https://github.com/user-attachments/assets/dc40ab72-ae15-4fa4-9b52-424a35104c51" />

*How the string construction appears on IDA decompiler.*

# Use
- `VM_CSTR(...)` to get a pointer to a c-like string.
- `VM_STR(...)` to get a std c++ string.

- `VM_W_CSTR(...)` to get a pointer to a c-like wide string.
- `VM_W_STR(...)` to get a std c++ wide string.

```cpp
#include "vm_str.hpp"

int main() {
   const char *c_like_string = VM_CSTR("Hello, ");
   std::string cpp_std_string = VM_STR("World!");
   std::cout << c_like_string << cpp_std_string << std::endl;

   const wchar_t *cw_like_string = VM_W_CSTR(L"Hello, ");
   std::wstring cpp_std_wstring = VM_W_STR(L"World!");
   std::wcout << cw_like_string << cpp_std_wstring << std::endl;
}
```

# Features
- Generates different obfuscation schema for every build, making general deobfuscators like [that](https://github.com/yubie-re/ida-jm-xorstr-decrypt-plugin) harder to develop.
- String is constructed on the stack at runtime and does not appear in the `.data` section.
- The string's runtime decryption is purposefully convoluted, making static analysis harder.

# Data types supported
- [x] char*
- [x] std::string
- [x] wchar_t*
- [x] std::wstring

See [Limitations](#Limitations)

# Supported compilers
- [x] msvc

See [Limitations](#Limitations)

# Limitations
- We currently support UTF-8 and UTF-16 strings; other encodings are not supported.  
- No compiler other than MSVC will be supported.
- Builds with C++ standards earlier than C++20 will fail.
- Build time is highly affected by `vm_str.hpp` since it makes extensive use of `constexpr` evaluations to generate the bytecode. Based on anecdotal data, even a single character can increase build time by ~1 second. Runtime performance does not seem to be significantly affected, though.

```

`vm_str.hpp`:

```hpp
#pragma once

#include <array>
#include <cassert>
#include <cstdint>
#include <limits>
#include <string>

namespace VmStr {

#define VMSTR_INLINE __forceinline

#define BYTECODE_MAX_SIZE 1000
#define STACK_MAX_SIZE 200

namespace Util {
constexpr int digit_to_int(char c) { return c - '0'; }

template <typename T>
inline void _memcpy(volatile void *dst, const volatile void *src,
                    std::size_t size) {
  auto *d = static_cast<volatile T *>(dst);
  auto *s = static_cast<const volatile T *>(src);
  for (std::size_t i = 0; i < size / sizeof(T); ++i)
    d[i] = s[i];
}

constexpr uint32_t rand_int(uint32_t seed) {
  uint32_t val = seed;
  val = (1103515245u * val + 12345u) & 0x7FFFFFFFu;
  return val;
}
} // namespace Util

namespace Global {

constexpr char _time[] = __TIME__;

constexpr int seed =
    Util::digit_to_int(_time[7]) + Util::digit_to_int(_time[6]) * 10 +
    Util::digit_to_int(_time[4]) * 60 + Util::digit_to_int(_time[3]) * 600 +
    Util::digit_to_int(_time[1]) * 3600 + Util::digit_to_int(_time[0]) * 36000;

consteval std::array<uint8_t, BYTECODE_MAX_SIZE> ET1(uint8_t key) {
  std::array<uint8_t, BYTECODE_MAX_SIZE> ret{};
  for (size_t i = 0; i < BYTECODE_MAX_SIZE - 1; ++i) {
    uint8_t val = Util::rand_int(Global::seed + i) % 255;
    ret[i] = val ^ key;
  }
  return ret;
}

consteval std::array<uint8_t, BYTECODE_MAX_SIZE> ET2() {
  std::array<uint8_t, BYTECODE_MAX_SIZE> ret{};
  for (size_t i = 0; i < BYTECODE_MAX_SIZE - 1; ++i) {
    uint8_t val = Util::rand_int(Global::seed + i) % 255;
    ret[i] = val;
  }
  return ret;
}

constexpr uint8_t GK = Util::rand_int(Global::seed + 0xdeadbeef);

static std::array<uint8_t, BYTECODE_MAX_SIZE> _ET1 = ET1(GK);
constexpr std::array<uint8_t, BYTECODE_MAX_SIZE> _ET2 = ET2();

std::array<uint8_t, BYTECODE_MAX_SIZE> _ET3{};

} // namespace Global

namespace Expression {

#define DEFINE_EXPR(name, body)                                                \
  template <typename T>                                                        \
  constexpr T cexpr_##name(T n, [[maybe_unused]] T d) body                     \
                                                                               \
      template <typename T>                                                    \
      VMSTR_INLINE T name(T n, [[maybe_unused]] T d) body

DEFINE_EXPR(_xor, { return n ^ d; })
DEFINE_EXPR(_not, { return ~n; })

DEFINE_EXPR(rotl, {
  constexpr T INT_BITS = std::numeric_limits<T>::digits;
  d %= INT_BITS;
  return (n << d) | (n >> (INT_BITS - d));
})

DEFINE_EXPR(rotr, {
  constexpr T INT_BITS = std::numeric_limits<T>::digits;
  d %= INT_BITS;
  return (n >> d) | (n << (INT_BITS - d));
})

template <typename T> VMSTR_INLINE T alt_xor(T a, T b) {
  return ((((((~a | ~b) ^ -~a) + (2 * ((~a | ~b) & -~a))) & b) +
           ((((~a | ~b) ^ -~a) + (2 * ((~a | ~b) & -~a))) | b)) -
          ((((~a & ~b) & b) + ((~a & ~b) | b)) - ~a));
}

template <typename T> VMSTR_INLINE T alt_not(T a, T b) {
  return (((~~a | ((((~a | b) - ~a) + ((a & ~b) + b)) -
                   (((~a | b) - ~a) + ((a & ~b) + b)))) -
           ~~a) +
          (~a | ((((~a | b) - ~a) + ((a & ~b) + b)) -
                 (((~a | b) - ~a) + ((a & ~b) + b)))));
}

} // namespace Expression

namespace Vm {

enum OP : uint8_t {
  PUSH,
  XOR,
  NOT,
  ROTR,
  ROTL,

  ALT_XOR,
  ALT_NOT,

  END,

  TERMINATOR,
};

#define INSERT(val)                                                            \
  ret[vip] = static_cast<T>(val);                                              \
  vip++;

#define K static_cast<T>(table[vip])

template <typename ST, typename T, size_t N>
constexpr auto gen_bytecode(const ST (&str)[N]) {
  std::array<T, BYTECODE_MAX_SIZE> ret{};
  auto table = Global::_ET2;

  int vip = 0;
  for (size_t i = 0; i < N - 1; ++i) {
    OP op = static_cast<OP>(Util::rand_int(Global::seed + i) %
                            (static_cast<uint8_t>(OP::END)));
    if (op == OP::XOR) {
      T key = static_cast<T>(Util::rand_int(Global::seed + i) %
                             std::numeric_limits<T>::max());
      T val = Expression::cexpr__xor<T>(str[i], key);
      INSERT(OP::PUSH);
      INSERT(val ^ K);
      INSERT(OP::PUSH);
      INSERT(static_cast<T>(key) ^ K);
      INSERT(OP::XOR);
      continue;
    } else if (op == OP::NOT) {
      T val = Expression::cexpr__not<T>(str[i], 0);
      INSERT(OP::PUSH);
      INSERT(val ^ K);
      INSERT(OP::NOT);
      continue;
    } else if (op == OP::ROTR) {
      T key = static_cast<T>(Util::rand_int(Global::seed + i) %
                             std::numeric_limits<T>::max());
      T val = Expression::cexpr_rotr<T>(str[i], key);
      INSERT(OP::PUSH);
      INSERT(val ^ K);
      INSERT(OP::PUSH);
      INSERT(static_cast<T>(key) ^ K);
      INSERT(OP::ROTL);
      continue;
    } else if (op == OP::ROTL) {
      T key = static_cast<T>(Util::rand_int(Global::seed + i) %
                             std::numeric_limits<T>::max());
      T val = Expression::cexpr_rotl<T>(str[i], key);
      INSERT(OP::PUSH);
      INSERT(val ^ K);
      INSERT(OP::PUSH);
      INSERT(static_cast<T>(key) ^ K);
      INSERT(OP::ROTR);
      continue;
    } else if (op == OP::ALT_XOR) {
      T key = static_cast<T>(Util::rand_int(Global::seed + i) %
                             std::numeric_limits<T>::max());
      T val = Expression::cexpr__xor<T>(str[i], key);
      INSERT(OP::PUSH);
      INSERT(val ^ K);
      INSERT(OP::PUSH);
      INSERT(static_cast<T>(key) ^ K);
      INSERT(OP::ALT_XOR);
      continue;
    } else if (op == OP::ALT_NOT) {
      auto val = Expression::cexpr__not<T>(str[i], 0);
      INSERT(OP::PUSH);
      INSERT(val ^ K);
      INSERT(OP::ALT_NOT);
      continue;
    }

    INSERT(OP::PUSH);
    INSERT(str[i] ^ K);
  }

  ret[vip] = OP::TERMINATOR;

  return ret;
}

#define CHAIN(offset) run<T, vip + offset, bytecode>(vsp, stack)
#define VSP(x) x + opaque_var

template <typename T, size_t vip, std::array bytecode>
VMSTR_INLINE void run(volatile size_t &vsp, volatile T *stack) {
  volatile uint8_t opaque_var = Expression::alt_xor<uint8_t>(
      Global::_ET1[vip + 1], Global::_ET1[vip + 1]);
  constexpr OP op = static_cast<OP>(bytecode[vip]);
  if constexpr (op == OP::PUSH) {
    Global::_ET3[vip + 1] = Global::_ET1[vip + 1];
    Global::_ET3[vip + 1] =
        Expression::alt_xor<uint8_t>(Global::_ET3[vip + 1], Global::GK);
    volatile uint8_t _key = Global::_ET3[vip + 1];
    T imm = bytecode[vip + 1] ^ static_cast<T>(_key);
    Util::_memcpy<T>(stack + vsp, &imm, sizeof(T));
    vsp += VSP(1);
    CHAIN(2);
  } else if constexpr (op == OP::XOR) {
    volatile T imm = stack[vsp - 2];
    volatile T key = stack[vsp - 1];
    vsp -= VSP(2);
    T xor_val = Expression::_xor<T>(imm, (key + opaque_var));
    Util::_memcpy<T>(stack + vsp, &xor_val, sizeof(T));
    vsp += VSP(1);
    CHAIN(1);
  } else if constexpr (op == OP::NOT) {
    volatile T imm = stack[vsp - 1];
    vsp -= VSP(1);
    volatile T not_val = Expression::_not<T>(imm + opaque_var, 0);
    Util::_memcpy<T>(stack + vsp, &not_val, sizeof(T));
    vsp += VSP(1);
    CHAIN(1);
  } else if constexpr (op == OP::ROTR) {
    volatile T imm = stack[vsp - 2];
    volatile T key = stack[vsp - 1];
    vsp -= VSP(2);
    volatile T rotr_val = Expression::rotr<T>(imm, key + opaque_var);
    Util::_memcpy<T>(stack + vsp, &rotr_val, sizeof(T));
    vsp += VSP(1);
    CHAIN(1);
  } else if constexpr (op == OP::ROTL) {
    volatile T imm = stack[vsp - 2];
    volatile T key = stack[vsp - 1];
    vsp -= VSP(2);
    volatile T rotl_val = Expression::rotl<T>(imm, key + opaque_var);
    Util::_memcpy<T>(stack + vsp, &rotl_val, sizeof(T));
    vsp += VSP(1);
    CHAIN(1);
  } else if constexpr (op == OP::ALT_XOR) {
    volatile T imm = stack[vsp - 2];
    volatile T key = stack[vsp - 1];
    vsp -= VSP(2);
    volatile T mbaxor_val = Expression::alt_xor<T>(imm, key + opaque_var);
    Util::_memcpy<T>(stack + vsp, &mbaxor_val, sizeof(T));
    vsp += VSP(1);
    CHAIN(1);
  } else if constexpr (op == OP::ALT_NOT) {
    volatile T imm = stack[vsp - 1];
    vsp -= VSP(1);
    volatile T not_val = Expression::alt_not<T>(imm + opaque_var, imm);
    Util::_memcpy<T>(stack + vsp, &not_val, sizeof(T));
    vsp += VSP(1);
    CHAIN(1);
  } else if constexpr (op == OP::TERMINATOR) {
    T terminator = 0x0;
    Util::_memcpy<T>(stack + vsp, &terminator, sizeof(T));
    return;
  } else {
    assert(false && "Invalid opcode");
  }
}

template <std::array bytecode> VMSTR_INLINE std::string exec_str() {
  volatile size_t vsp = 0;
  volatile uint8_t stack[STACK_MAX_SIZE];
  run<uint8_t, 0, bytecode>(vsp, stack);

  uint8_t const *t = const_cast<uint8_t *>(stack);
  const char *t2 = reinterpret_cast<const char *>(t);
  auto str = std::string(t2);

  return str;
}

template <std::array bytecode> VMSTR_INLINE const char *exec_cstr() {
  volatile size_t vsp = 0;
  static volatile uint8_t stack[STACK_MAX_SIZE];
  run<uint8_t, 0, bytecode>(vsp, stack);

  uint8_t const *t = const_cast<uint8_t *>(stack);
  const char *t2 = reinterpret_cast<const char *>(t);

  return t2;
}

template <std::array bytecode> VMSTR_INLINE std::wstring exec_wstr() {
  volatile size_t vsp = 0;
  volatile uint16_t stack[STACK_MAX_SIZE];
  run<uint16_t, 0, bytecode>(vsp, stack);

  uint16_t const *t = const_cast<uint16_t *>(stack);
  const wchar_t *t2 = reinterpret_cast<const wchar_t *>(t);
  auto str = std::wstring(t2);

  return str;
}

template <std::array bytecode> VMSTR_INLINE const wchar_t *exec_cwstr() {
  volatile size_t vsp = 0;
  static volatile uint16_t stack[STACK_MAX_SIZE];
  run<uint16_t, 0, bytecode>(vsp, stack);

  uint16_t const *t = const_cast<uint16_t *>(stack);
  const wchar_t *t2 = reinterpret_cast<const wchar_t *>(t);

  return t2;
}

} // namespace Vm
} // namespace VmStr

#define VM_STR(str)                                                            \
  VmStr::Vm::exec_str<VmStr::Vm::gen_bytecode<char, uint8_t>(str)>()
#define VM_CSTR(str)                                                           \
  VmStr::Vm::exec_cstr<VmStr::Vm::gen_bytecode<char, uint8_t>(str)>()

#define VM_W_STR(wstr)                                                         \
  VmStr::Vm::exec_wstr<VmStr::Vm::gen_bytecode<wchar_t, uint16_t>(wstr)>()
#define VM_W_CSTR(wstr)                                                        \
  VmStr::Vm::exec_cwstr<VmStr::Vm::gen_bytecode<wchar_t, uint16_t>(wstr)>()

```