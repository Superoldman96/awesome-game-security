Project Path: arc_gmh5225_UltimateAntiCheat_owus907c

Source Tree:

```txt
arc_gmh5225_UltimateAntiCheat_owus907c
├── AntiCheat.hpp
├── AntiDebugger.cpp
├── AntiDebugger.hpp
├── Integrity.cpp
├── Integrity.hpp
├── NetClient.cpp
├── NetClient.hpp
├── Process.cpp
├── Process.hpp
├── README.md
├── SHA256.cpp
├── SHA256.hpp
├── Shellcodes.asm
├── UltimateAntiCheat.cpp
├── Utility.cpp
└── Utility.hpp

```

`AntiCheat.hpp`:

```hpp
#pragma once
#include "Process/Process.hpp"
#include "AntiDebug/AntiDebugger.hpp"
#include "AntiTamper/Integrity.hpp"

extern "C" __forceinline bool MisleadingFunction(); 
extern "C" void inline_test(); //using macros within masm file

class AntiCheat //main class of the program, or 'hub'. contains all the detection methods
{
public:

	Process* GetProcessObject() { return this->_Proc; }
	Debugger::AntiDebug* GetAntiDebugger() { return this->_AntiDebugger; }

	typedef void (*FunctionTypePtr)();

	inline void ShellcodeTests() { 
			
		byte* buffer = (byte*)"\x53\x47\x82\xEB\x07\x47\x8A\x43\x23\x0F\xFE\xDF";

		DWORD dOldProt = 0;
		VirtualProtect((LPVOID)buffer, 13, PAGE_EXECUTE_READWRITE, &dOldProt);

		for (int i = 0; i < 13; i++) //basic transform of bytes
			buffer[i] = buffer[i] + 1;

		void (*foo)();
		foo = (void(*)())(buffer);
		foo(); //shellcode call

		///Part 2: virtualalloc + shellcode func call

		LPVOID p = VirtualAlloc(NULL, 13, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
				
		if (p != 0)
		{
			printf("&P: %llX\n", &p);
			printf("P: %llX\n", p);

			memcpy(p, buffer, 13);

			foo = (void(*)())(p);
			foo(); //shellcode call
			printf("Called p!\n");

			//...just to check how compilers treat each of these calls
			FunctionTypePtr* foo2 = (void(**)())&p; 
			(*foo2)();  //actually works
			printf("Called foo2: %llX!\n", *foo2);
			
			
			VirtualFree(p, 0, MEM_RELEASE);	 //memory begone
		}
	}


	inline Integrity* GetIntegrityChecker() { return this->integrityChecker; }

protected:

private:
	
	Process* _Proc = new Process();
	Debugger::AntiDebug* _AntiDebugger = new Debugger::AntiDebug();

	Integrity* integrityChecker = new Integrity();
};

```

`AntiDebugger.cpp`:

```cpp
#include "AntiDebugger.hpp"

void Debugger::AntiDebug::StartAntiDebugThread()
{
	HANDLE thread = this->GetDetectionThread();
	thread = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)Debugger::AntiDebug::CheckForDebugger, (LPVOID)this, 0, 0);
}

inline bool Debugger::AntiDebug::_IsDebuggerPresent()
{
	if (IsDebuggerPresent()) //winapi
	{
		DebuggerMethodsDetected = DebuggerMethodsDetected | WINAPI_DEBUGGER;
		return true;
	}
	else
	{
		return false;
	}
}



bool Debugger::AntiDebug::_IsHardwareDebuggerPresent()
{
	DWORD ProcessId = GetCurrentProcessId(); //this can be replaced later, or a process that is not us

	//first we must iterate on all threads in process
	HANDLE hThreadSnap = INVALID_HANDLE_VALUE;
	THREADENTRY32 te32;

	// Take a snapshot of all running threads  
	hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
	if (hThreadSnap == INVALID_HANDLE_VALUE)
		return(FALSE);

	// Fill in the size of the structure before using it. 
	te32.dwSize = sizeof(THREADENTRY32);

	// Retrieve information about the first thread,
	// and exit if unsuccessful
	if (!Thread32First(hThreadSnap, &te32))
	{
		CloseHandle(hThreadSnap);     // Must clean up the snapshot object!
		return(FALSE);
	}
	
	//WOW64: The handle must also have THREAD_QUERY_INFORMATION access.
	// Now walk the thread list of the system,
	// and display information about each thread
	// associated with the specified process
	do
	{
		if (te32.th32OwnerProcessID == ProcessId)
		{
			printf(("\n     THREAD ID      = 0x%08X"), te32.th32ThreadID);

			CONTEXT lpContext;
			memset(&lpContext, 0, sizeof(CONTEXT));
			lpContext.ContextFlags = CONTEXT_FULL;

			HANDLE _tThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te32.th32ThreadID);

			if (_tThread)
			{
				if (GetThreadContext(_tThread, &lpContext))
				{
					if (lpContext.Dr0 || lpContext.Dr1 || lpContext.Dr2 || lpContext.Dr3 )
					{
						printf("Found a debug register enabled!\n");
						CloseHandle(hThreadSnap);
						CloseHandle(_tThread);
						return true;
					}
				}
				else
				{
					printf("GetThreadContext failed with: %d\n", GetLastError());
                                        CloseHandle(_tThread);
					continue;
				}
			}
			else
			{
				printf("Could not call openthread! %d\n", GetLastError());
				continue;
			}
		}
	} while (Thread32Next(hThreadSnap, &te32));

	printf(("\n"));

	//  Don't forget to clean up the snapshot object.
	CloseHandle(hThreadSnap);
	return false;
}


bool Debugger::AntiDebug::_IsKernelDebuggerPresent()
{
	typedef long NTSTATUS;
	HANDLE hProcess = GetCurrentProcess();

	typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION { bool DebuggerEnabled; bool DebuggerNotPresent; } SYSTEM_KERNEL_DEBUGGER_INFORMATION, * PSYSTEM_KERNEL_DEBUGGER_INFORMATION;

	enum SYSTEM_INFORMATION_CLASS { SystemKernelDebuggerInformation = 35 };
	typedef NTSTATUS(__stdcall* ZW_QUERY_SYSTEM_INFORMATION)(IN SYSTEM_INFORMATION_CLASS SystemInformationClass, IN OUT PVOID SystemInformation, IN ULONG SystemInformationLength, OUT PULONG ReturnLength);
	ZW_QUERY_SYSTEM_INFORMATION ZwQuerySystemInformation;
	SYSTEM_KERNEL_DEBUGGER_INFORMATION Info;

	HMODULE hModule = LoadLibraryA("ntdll.dll");
	ZwQuerySystemInformation = (ZW_QUERY_SYSTEM_INFORMATION)GetProcAddress(hModule, "ZwQuerySystemInformation");
	if (ZwQuerySystemInformation == NULL)
		return false;

	if (!ZwQuerySystemInformation(SystemKernelDebuggerInformation, &Info, sizeof(Info), NULL)) {
		if (Info.DebuggerEnabled && !Info.DebuggerNotPresent)
			return true; 
		else
			return false;
	}

	return false;
}

bool Debugger::AntiDebug::_IsDebuggerPresentHeapFlags()
{
	DWORD_PTR pPeb64 = (DWORD_PTR)pPEB::GetPEB();

	if (pPeb64)
	{
		PVOID ptrHeap = (PVOID)*(PDWORD_PTR)((PBYTE)pPeb64 + 0x30);
		PDWORD heapForceFlagsPtr = (PDWORD)((PBYTE)ptrHeap + 0x74);

		if (*heapForceFlagsPtr == 0x40000060)
			return true;
	}

	return false;
}


```

`AntiDebugger.hpp`:

```hpp
#pragma once
#include <Winternl.h>
#include <Windows.h>
#include <stdio.h> //for printing info
#include <tlhelp32.h> //process watching
#include <Psapi.h> //process watching
#include "../Process/PEB.hpp"


#define MAX_DLLS 128 
#define MAX_FILE_PATH_LENGTH 256

namespace Debugger
{
    //Todo: Get all methods from scyllahide
    //see bottom of file for list of windows structures related to debugging
    enum Detections
    {
        WINAPI_DEBUGGER,
        PEB_FLAG,
        HARDWARE_REGISTERS,
        HEAP,
        INTC,
        INT2C,
        DEBUG_EVENT, 
        DEBUG_OBJECT,
        KNOWN_DEBUGGER, //for commonly used tools such as IDA, olly, etc
        VEH_DEBUGGER, //https://github.com/cheat-engine/cheat-engine/blob/66d2ad3ba7f4de6726f61437300b24fa00c425f5/Cheat%20Engine/VEHDebugger.pas -> calls CreateFileMapping, MapViewOfFile, CreateEvent, DuplicateHandle, then injects a DLL (vehdebug_x86/64.dll) -> calls "vehdebug.InitializeVEH' export, thus we can likely detect this by a simple module enum

        ALL = -1
    };

    class AntiDebug
    {
    public:
        
        AntiDebug()
        {
            this->DebuggerMethodsDetected = 0;
            this->DebuggerDetectionMethods = WINAPI_DEBUGGER;
        }
        
        inline int GetDebuggerMethodsDetected() { return DebuggerMethodsDetected; }
    
        inline HANDLE GetDetectionThread() { return this->DetectionThread; }

        inline bool _IsDebuggerPresent();
        inline bool _IsDebuggerPresentHeapFlags();
        inline bool _IsKernelDebuggerPresent();
        inline bool _IsHardwareDebuggerPresent();

       // bool CheckForDebugger();
        static void CheckForDebugger(LPVOID AD);
        void StartAntiDebugThread();

    private:
        
        int DebuggerMethodsDetected = 0;
        int DebuggerDetectionMethods = 0;
    
        HANDLE DetectionThread;
    };
}

//The following structures are used with debugging :
//
//CONTEXT
//CREATE_PROCESS_DEBUG_INFO
//CREATE_THREAD_DEBUG_INFO
//DEBUG_EVENT
//EXCEPTION_DEBUG_INFO
//EXIT_PROCESS_DEBUG_INFO
//EXIT_THREAD_DEBUG_INFO
//LDT_ENTRY
//LOAD_DLL_DEBUG_INFO
//OUTPUT_DEBUG_STRING_INFO
//RIP_INFO
//UNLOAD_DLL_DEBUG_INFO
//WOW64_CONTEXT
//WOW64_FLOATING_SAVE_AREA
//WOW64_LDT_ENTRY
//

```

`Integrity.cpp`:

```cpp
#include "Integrity.hpp"
#include <stdio.h>

bool Integrity::Check(uint64_t Address, int nBytes, byte* originalBytes)
{
	bool memorySpoiled = false;

	for (int i = 0; i < nBytes; i++)
	{
		byte x = Utility<byte>::DereferenceSafe(Address + i);

		if (originalBytes[i] != x)
		{
			printf("Memory mismatch!\n");
			memorySpoiled = true;
		}
	}

	return true;
}

//we can build an array here at some memory location with nBytes, then SHA256 it to get some hash that will only change if memory is modified
//each byte in the digest is multiplied by the previous byte in the digest and added to some sum, which is returned as the hash
uint8_t* Integrity::GetHash(uint64_t Address, int nBytes)
{
	byte* arr = new byte[nBytes];
	memcpy(&arr[0], (void*)&Address, nBytes);

	SHA256 sha;
	sha.update(arr);
	uint8_t* digest = sha.digest();

	//printf("%s\n", SHA256::toString(digest).c_str());
	printf("%llx\n", SHA256::GetStackedMultiple(digest));

	return digest;
}

```

`Integrity.hpp`:

```hpp
#pragma once
#include "Utility.hpp"
#include "Process.hpp"
#include "SHA256.hpp"

class Integrity
{
public:

	bool Check(uint64_t Address, int nBytes, byte* originalBytes);
	uint8_t* GetHash(uint64_t Address, int nBytes);

private:

	uint64_t _Checksum = 0;
	uint64_t _SectionHashes[255];


	Process* _Proc = new Process(); //get memory sections, etc, make hash of each section
};

```

`NetClient.cpp`:

```cpp
#include "NetClient.hpp"

uint32_t NetClient::SendData(string _data)
{
	return 0;
}

uint32_t NetClient::SendData(byte* _data)
{
	return 0;
}
```

`NetClient.hpp`:

```hpp
#pragma once
#include <winsock2.h>
#include <stdint.h>
#include <string>
#include <time.h>

#pragma comment(lib, "ws2_32")

using namespace std;

namespace NetworkOpcodes
{
	enum CS //client2server
	{
		CS_HELLO = 1,
		CS_GOODBYE,
		CS_CLIENTHASH,
		CS_HEARTBEAT,
		CS_INFOLOGGING
	};

	enum SC //server2client
	{
		SC_HELLO = 1,
		SC_GOODBYE,
		SC_CLIENTHASH,
		SC_HEARTBEAT,
		SC_INFOLOGGING
	};
}

class NetClient
{
public:

	bool Initialize(string ip, uint16_t port); //connects, sends CS_HELLO, verifies the response of a version number from server
	bool EndConnection();
	bool SendProcessHash(LPBYTE hash, uint32_t nBytes);

	void ProcessRequests(LPVOID Param);

	SOCKET GetClientSocket() { return this->s; }
	string GetConnectedIP() { return this->_ConnectedIP; }
	uint16_t GetConnectedPort() { return this->_Port; }

	uint32_t SendData(byte* _Data);
	uint32_t SendData(string _Data);

private:

	SOCKET s;

	string _ConnectedIP;
	uint16_t _Port;

	time_t _tConnectedDuration;
	time_t _tConnectedAt;
};
```

`Process.cpp`:

```cpp
#include "Process/Process.hpp"

uint32_t Process::GetThisProcessId()
{
	this->_ProcessId = GetCurrentProcessId();
	return this->_ProcessId;
}

uint64_t Process::GetBaseAddress()
{
    TCHAR szProcessName[MAX_PATH] = TEXT("UltimateAnticheat.exe");
    wstring processName = L"UltimateAnticheat.exe";
    DWORD ProcessId = GetCurrentProcessId();

    HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION |
        PROCESS_VM_READ,
        FALSE, ProcessId);

    if (NULL != hProcess)
    {
        HMODULE hMod;
        DWORD cbNeeded;

        if (EnumProcessModulesEx(hProcess, &hMod, sizeof(hMod),
            &cbNeeded, LIST_MODULES_32BIT | LIST_MODULES_64BIT))
        {
            GetModuleBaseName(hProcess, hMod, szProcessName,
                sizeof(szProcessName) / sizeof(TCHAR));
            if (!_tcsicmp(processName.c_str(), szProcessName)) {
                wprintf(L"Base address of %s: %llx\n", processName.c_str(), hMod);
                CloseHandle(hProcess);
                return (uint64_t)hMod;
            }
        }
    }

    if(hProcess != NULL)
        CloseHandle(hProcess);

    return 0; //unfound case/error
}

uint32_t Process::GetMemorySize() //returns uint32_t value of combined byte size of all mem regions of the process on disk
{
    DWORD dOldProt = 0;
    HANDLE hModuleSnap = INVALID_HANDLE_VALUE;
    MODULEENTRY32 moduleEntry;

    // Take a snapshot of all modules in the specified process
    hModuleSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, GetCurrentProcessId());
    if (hModuleSnap == INVALID_HANDLE_VALUE)
        return false;

    // Set the size of the structure before using it
    moduleEntry.dwSize = sizeof(MODULEENTRY32);

    // Retrieve information about the first module (current process)
    if (!Module32First(hModuleSnap, &moduleEntry))
    {
        CloseHandle(hModuleSnap);
        return false;
    }

    UINT_PTR ulBaseAddress = reinterpret_cast<UINT_PTR>(moduleEntry.modBaseAddr);
    UINT_PTR ulBaseSize = moduleEntry.modBaseSize;

    return (uint32_t)ulBaseSize;
}


/*
Routine to prevent DLL injection and possibly memory writing
..One way of doing this is hooking/patching loadlibrary and other module related routines, this is easily worked around though
*/
bool Process::ProtectProcess()
{
    if (this->GetBaseAddress())
    {
        uint32_t size = this->GetMemorySize();
    }
    else
    {
        printf("Could not protect the process at run time!\n");
        return false;
    }

    return true;
}


```

`Process.hpp`:

```hpp
#pragma once
#include "PEB.hpp"
#include <stdint.h>
#include <string>
#include <Psapi.h>
#include <tchar.h>
#include <TlHelp32.h>
#include <list>

using namespace std;

#define MAX_DLLS_LOADED 128
#define MAX_FILE_PATH_LENGTH 256

namespace Module
{
	struct MODULE_DATA
	{
		char fileName[MAX_FILE_PATH_LENGTH];
		MODULEINFO dllInfo;
		HMODULE module;
	};
}


class Process
{
public:

	uint32_t GetThisProcessId();

	uint64_t GetBaseAddress();
	uint32_t GetMemorySize();

	bool ProtectProcess();

	pPEB::_MYPEB* GetPEB() { return this->_PEB; }

private:

	//all aspects of a process should be here, preferrably in some order

	pPEB::_MYPEB* _PEB = new pPEB::_MYPEB();
	//Memory* Sections; //todo: some class to represent sections in memory if we can (.text, .data, etc)
	
	uint32_t _ProcessId;
	HANDLE _Mutant;

	string _ProcessName;
	string _WindowClassName;
	string _WindowTitle;

	list<Module::MODULE_DATA*> ModuleList;
};

```

`README.md`:

```md
# UltimateAntiCheat
Research project: make some elaborate anti-cheat to detect: memory editing, debugging, certificates (and spoofing), injected modules, multi-boxing, OS spoofing

Additionally, provide features such as:
Routines which could obfuscate the assembly of a pre-compiled module (on disk)

This project is on-going and worked on in whatever spare time I have, and is not intended to be commercial software. If you want to use any examples in your commercial software please contact me beforehand. If this gets far enough in development then a commercial 'plug and play' version will be made and possibly sold (or released as freeware) to be implemented in a/your game. 

If you have any design suggestions feel free to raise an 'issue', thanks!

```

`SHA256.cpp`:

```cpp
#include "SHA256.hpp"
#include <cstring>
#include <sstream>
#include <iomanip>

SHA256::SHA256() : m_blocklen(0), m_bitlen(0) {
	m_state[0] = 0x6a09e667;
	m_state[1] = 0xbb67ae85;
	m_state[2] = 0x3c6ef372;
	m_state[3] = 0xa54ff53a;
	m_state[4] = 0x510e527f;
	m_state[5] = 0x9b05688c;
	m_state[6] = 0x1f83d9ab;
	m_state[7] = 0x5be0cd19;
}

void SHA256::update(const uint8_t* data, size_t length) {
	for (size_t i = 0; i < length; i++) {
		m_data[m_blocklen++] = data[i];
		if (m_blocklen == 64) {
			transform();

			// End of the block
			m_bitlen += 512;
			m_blocklen = 0;
		}
	}
}

void SHA256::update(const std::string& data) {
	update(reinterpret_cast<const uint8_t*> (data.c_str()), data.size());
}

void SHA256::update(unsigned char* data) {
	update(reinterpret_cast<const uint8_t*> (data), 4); //dont hardcode 4
}

uint8_t* SHA256::digest() {
	
	uint8_t* hash = new uint8_t[32];

	pad();
	revert(hash);

	return hash;
}

uint32_t SHA256::rotr(uint32_t x, uint32_t n) {
	return (x >> n) | (x << (32 - n));
}

uint32_t SHA256::choose(uint32_t e, uint32_t f, uint32_t g) {
	return (e & f) ^ (~e & g);
}

uint32_t SHA256::majority(uint32_t a, uint32_t b, uint32_t c) {
	return (a & (b | c)) | (b & c);
}

uint32_t SHA256::sig0(uint32_t x) {
	return SHA256::rotr(x, 7) ^ SHA256::rotr(x, 18) ^ (x >> 3);
}

uint32_t SHA256::sig1(uint32_t x) {
	return SHA256::rotr(x, 17) ^ SHA256::rotr(x, 19) ^ (x >> 10);
}

void SHA256::transform() {
	uint32_t maj, xorA, ch, xorE, sum, newA, newE, m[64];
	uint32_t state[8];

	for (uint8_t i = 0, j = 0; i < 16; i++, j += 4) { // Split data in 32 bit blocks for the 16 first words
		m[i] = (m_data[j] << 24) | (m_data[j + 1] << 16) | (m_data[j + 2] << 8) | (m_data[j + 3]);
	}

	for (uint8_t k = 16; k < 64; k++) { // Remaining 48 blocks
		m[k] = SHA256::sig1(m[k - 2]) + m[k - 7] + SHA256::sig0(m[k - 15]) + m[k - 16];
	}

	for (uint8_t i = 0; i < 8; i++) {
		state[i] = m_state[i];
	}

	for (uint8_t i = 0; i < 64; i++) {
		maj = SHA256::majority(state[0], state[1], state[2]);
		xorA = SHA256::rotr(state[0], 2) ^ SHA256::rotr(state[0], 13) ^ SHA256::rotr(state[0], 22);

		ch = choose(state[4], state[5], state[6]);

		xorE = SHA256::rotr(state[4], 6) ^ SHA256::rotr(state[4], 11) ^ SHA256::rotr(state[4], 25);

		sum = m[i] + K[i] + state[7] + ch + xorE;
		newA = xorA + maj + sum;
		newE = state[3] + sum;

		state[7] = state[6];
		state[6] = state[5];
		state[5] = state[4];
		state[4] = newE;
		state[3] = state[2];
		state[2] = state[1];
		state[1] = state[0];
		state[0] = newA;
	}

	for (uint8_t i = 0; i < 8; i++) {
		m_state[i] += state[i];
	}
}

void SHA256::pad() {

	uint64_t i = m_blocklen;
	uint8_t end = m_blocklen < 56 ? 56 : 64;

	m_data[i++] = 0x80; // Append a bit 1
	while (i < end) {
		m_data[i++] = 0x00; // Pad with zeros
	}

	if (m_blocklen >= 56) {
		transform();
		memset(m_data, 0, 56);
	}

	// Append to the padding the total message's length in bits and transform.
	m_bitlen += m_blocklen * 8;
	m_data[63] = m_bitlen;
	m_data[62] = m_bitlen >> 8;
	m_data[61] = m_bitlen >> 16;
	m_data[60] = m_bitlen >> 24;
	m_data[59] = m_bitlen >> 32;
	m_data[58] = m_bitlen >> 40;
	m_data[57] = m_bitlen >> 48;
	m_data[56] = m_bitlen >> 56;
	transform();
}

void SHA256::revert(uint8_t* hash) {
	// SHA uses big endian byte ordering
	// Revert all bytes
	for (uint8_t i = 0; i < 4; i++) {
		for (uint8_t j = 0; j < 8; j++) {
			hash[i + (j * 4)] = (m_state[j] >> (24 - i * 8)) & 0x000000ff;
		}
	}
}

std::string SHA256::toString(const uint8_t* digest) {
	
	std::stringstream s;
	s << std::setfill('0') << std::hex;

	for (uint8_t i = 0; i < 32; i++) {
		s << std::setw(2) << (unsigned int)digest[i];
	}

	return s.str();
}

uint64_t SHA256::GetStackedMultiple(const uint8_t* digest) {

	uint64_t stackedMultiple = 0;

	memcpy(&stackedMultiple, (void*)&digest[0], sizeof(uint8_t) * 4);
	printf("first: %llX\n", stackedMultiple);

	for (uint8_t i = 0; i < 32; i++) {
		stackedMultiple = stackedMultiple * digest[i];
		
	}

	printf("%llX\n", stackedMultiple);
	return stackedMultiple;
}
```

`SHA256.hpp`:

```hpp
#ifndef SHA256_H
#define SHA256_H

#include <string>
#include <array>

class SHA256 {

public:
	SHA256();
	void update(const uint8_t* data, size_t length);
	void update(const std::string& data);
	void update(unsigned char* data);
	uint8_t* digest();

	static std::string toString(const uint8_t* digest);
	static uint64_t GetStackedMultiple(const uint8_t* digest);

private:
	uint8_t  m_data[64];
	uint32_t m_blocklen;
	uint64_t m_bitlen;
	uint32_t m_state[8]; //A, B, C, D, E, F, G, H

	static constexpr std::array<uint32_t, 64> K = {
		0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,
		0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,
		0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,
		0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,
		0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,
		0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,
		0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,
		0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,
		0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,
		0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,
		0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,
		0xd192e819,0xd6990624,0xf40e3585,0x106aa070,
		0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,
		0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,
		0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,
		0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2
	};

	static uint32_t rotr(uint32_t x, uint32_t n);
	static uint32_t choose(uint32_t e, uint32_t f, uint32_t g);
	static uint32_t majority(uint32_t a, uint32_t b, uint32_t c);
	static uint32_t sig0(uint32_t x);
	static uint32_t sig1(uint32_t x);
	void transform();
	void pad();
	void revert(uint8_t* hash);
};

#endif
```

`Shellcodes.asm`:

```asm
.data



.code

;we want to somehow get this function to be inline with native C++ code despite documentation stating it shouldnt be possible.. x86 is of course no problem
;basic design to trick decompilers into thinking the function is something which it isnt. For example, the below will cause 'IDA Free' software to assume it has one argument, and returns the first argument as the only statement. The 'arg_0' will point to undefined/error memory.
InlineMeTest PROC

	push rsp ;push return addr
  sub rsp, 8 ;keep the stack from moving
  
  ;other logic goes here, perhaps call some other function
  
	mov rsp, rsp //junk instruction
	mov rax, [rsp+10h] //jumps back to return address, thus 'returns' the return address and not the 'first argument'.
	jmp rax

InlineMeTest ENDP
;it would be ideal to create some 'function prototype' which includes a templated return value and decompilation corruption

END

```

`UltimateAntiCheat.cpp`:

```cpp
// UltimateAnticheat.cpp : This file contains the 'main' function. Program execution begins and ends there.
// an 'in-development' anti-tamper + anti-debug + anti-load for x86, x64
// !not for commercial use! please contact the author if you wish to use examples from this in your commercial project.

#include <iostream>
#include "AntiCheat.hpp"

using namespace std;

void GetUserInput()
{
    bool readingCmd = true;

    while (readingCmd)
    {
        cout << "Select your poison.\n";

        cout << "[1] Start anti-tamper.\n";
        cout << "[2] Start anti-debug.\n";
        cout << "[3] Activate process hiding\n";
        cout << "[4] Reject new modules + scan current modules for proxies.\n";
        cout << "[5] Start all detections\n";

        wchar_t userIn[20];
        wscanf_s(L"%s", userIn, 20);

        switch (userIn[0])
        {
            case L'1':
                cout << "Selected 1.";
                break;

            case L'2':
                cout << "Selected 2.";
                break;

            case L'3':
                cout << "Selected 3.";
                break;

            case L'4':
                cout << "Selected 4.";
                break;

            case L'5':
                cout << "Selected 5.";
                break;

            case L'0':
                cout << "Done!.";
                return;

            default:
                cout << "Input not recognized as an option. Try again.";
                break;
        }

    }


}

int main()
{
    AntiCheat* AC = new AntiCheat();
    
    AC->GetAntiDebugger()->StartAntiDebugThread(); //some quick tests
    
    if(AC->GetIntegrityChecker()->Check((uint64_t)GetModuleHandleA(NULL), 5, "\xFF\xFF\xFF\xFF\xFF"))
    {
        printf("Hash of memory: %X\n", AC->GetIntegrityChecker()->GetHash((uint64_t)GetModuleHandleA(NULL), 5));
    }

    GetUserInput();
}

```

`Utility.cpp`:

```cpp
#include "Common/Utility.hpp"
#include <tlhelp32.h>
#include <stdio.h>

//thanks to https://stackoverflow.com/questions/2705927/get-specific-process-memory-space, however need to test this thoroughly to make sure it works as intended
bool Utility::IsVTableHijacked(void* pClass) //checks some class ptr's vtable to see if any functions jump outside of this module. sort of neat but unlikely anyone would be hooking here, and if they are it means theyre already leaving other fingerprints
{
    DWORD dOldProt = 0;
    HANDLE hModuleSnap = INVALID_HANDLE_VALUE;
    MODULEENTRY32 moduleEntry;

    // Take a snapshot of all modules in the specified process
    hModuleSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, GetCurrentProcessId());
    if (hModuleSnap == INVALID_HANDLE_VALUE)
        return false;

    // Set the size of the structure before using it
    moduleEntry.dwSize = sizeof(MODULEENTRY32);

    // Retrieve information about the first module (current process)
    if (!Module32First(hModuleSnap, &moduleEntry))
    {
        CloseHandle(hModuleSnap);
        return false;
    }

    // Grab the base address and size of our module (the address range where
    // the VTable can validly point to)
    UINT_PTR ulBaseAddress = reinterpret_cast<UINT_PTR>(moduleEntry.modBaseAddr);
    UINT_PTR ulBaseSize = moduleEntry.modBaseSize;

    // Get the VTable array and VTable member count
    int nMethods;
    void** ppVTable = GetVTableArray(pClass, &nMethods);

    VirtualProtect(ppVTable, nMethods * sizeof(UINT_PTR), PAGE_EXECUTE, &dOldProt);

    // Clean up the snapshot object
    CloseHandle(hModuleSnap);

    // Ensure all VTable pointers are in our current module's address range
    for (int i = 0; i < nMethods; ++i)
    {
        // Get address of the method this VTable pointer points to
        UINT_PTR ulFuncAddress = reinterpret_cast<UINT_PTR>(ppVTable[i]);
        printf("vTable member points to address: %llX\n", ulFuncAddress);
        // Check the address is within our current module range
        if (ulFuncAddress < ulBaseAddress || ulFuncAddress > ulBaseAddress + ulBaseSize)
            return false;
    }

    return true;
}

```

`Utility.hpp`:

```hpp
#pragma once
#include <stdint.h>
#include <Windows.h>

class Utility
{
public:
	
	template<class T>
	static T ReadPointer(uint64_t ulBase, uint64_t ulOffset)
	{
		__try
		{
			return *(T*)(*(uint64_t*)ulBase + ulOffset);
		}
		__except (1) { return (T)NULL; }
	}

	template<class T>
	static bool WritePointer(uint64_t ulBase, uint64_t ulOffset, T iValue)
	{
		__try { *(T*)(*(uint64_t*)ulBase + ulOffset) = iValue; return true; }
		__except (1) { return false; }
	}

	template<class T>
	static T DereferenceSafe(uint64_t ulAddress)
	{
		__try
		{
			return *(T*)ulAddress;
		}
		__except (1) { return (T)NULL; }
	}

	template<class T>
	static inline void** GetVTableArray(T* pClass, int* pSize) //thanks to  https://stackoverflow.com/questions/2705927/get-specific-process-memory-space
	{
		void** ppVTable = *(void***)pClass;

		if (pSize)
		{
			*pSize = 0;

			while (!IsBadReadPtr(ppVTable[*pSize], sizeof(unsigned __int64)))
				(*pSize)++;
		}

		return ppVTable;
	}

	static bool IsVTableHijacked(void* pClass);
};

```