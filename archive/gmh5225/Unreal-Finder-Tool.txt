Project Path: arc_gmh5225_Unreal-Finder-Tool_janb5yry

Source Tree:

```txt
arc_gmh5225_Unreal-Finder-Tool_janb5yry
├── DebugSymbols
│   ├── UnrealFinderTool-x32.pdb
│   └── UnrealFinderTool-x64.pdb
├── LICENSE
├── README.md
├── Resources
│   └── win.ico
├── UnrealFinderTool
│   ├── BypaPH.h
│   ├── ClassFinder.cpp
│   ├── ClassFinder.h
│   ├── Config
│   │   ├── EngineCore
│   │   │   ├── 4.14.1.json
│   │   │   ├── DeadByDayLight.json
│   │   │   ├── EngineBase.json
│   │   │   ├── InsurgencySandstorm.json
│   │   │   └── Remnant.json
│   │   └── Settings.json
│   ├── Debug.cpp
│   ├── Debug.h
│   ├── Driver.cpp
│   ├── Driver.h
│   ├── Fonts
│   │   ├── fa-regular-400.ttf
│   │   └── fa-solid-900.ttf
│   ├── GObjectsFinder.cpp
│   ├── GObjectsFinder.h
│   ├── GnamesFinder.cpp
│   ├── GnamesFinder.h
│   ├── HttpWorker.cpp
│   ├── HttpWorker.h
│   ├── IconsFontAwesome.h
│   ├── ImControl.h
│   ├── ImGUI
│   │   ├── imconfig.h
│   │   ├── imgui.cpp
│   │   ├── imgui.h
│   │   ├── imgui_demo.cpp
│   │   ├── imgui_draw.cpp
│   │   ├── imgui_impl_dx11.cpp
│   │   ├── imgui_impl_dx11.h
│   │   ├── imgui_impl_win32.cpp
│   │   ├── imgui_impl_win32.h
│   │   ├── imgui_internal.h
│   │   ├── imgui_widgets.cpp
│   │   ├── imstb_rectpack.h
│   │   ├── imstb_textedit.h
│   │   └── imstb_truetype.h
│   ├── InstanceLogger.cpp
│   ├── InstanceLogger.h
│   ├── JsonReflector.cpp
│   ├── JsonReflector.h
│   ├── KProcessHacker.h
│   ├── Logger.cpp
│   ├── Logger.h
│   ├── Memory.cpp
│   ├── Memory.h
│   ├── MemoryEditor.h
│   ├── Midi
│   │   ├── MIDI.cpp
│   │   ├── MIDI.h
│   │   └── MIDI_Resource.h
│   ├── ParallelWorker.h
│   ├── PatternScan.cpp
│   ├── PatternScan.h
│   ├── Scanner.cpp
│   ├── Scanner.h
│   ├── SdkGen
│   │   ├── Engine
│   │   │   ├── IGenerator.h
│   │   │   ├── NameValidator.cpp
│   │   │   ├── NameValidator.h
│   │   │   ├── NamesStore.cpp
│   │   │   ├── NamesStore.h
│   │   │   ├── ObjectsStore.cpp
│   │   │   ├── ObjectsStore.h
│   │   │   ├── Package.cpp
│   │   │   ├── Package.h
│   │   │   ├── PrintHelper.cpp
│   │   │   ├── PrintHelper.h
│   │   │   ├── UE4
│   │   │   │   ├── FunctionFlags.cpp
│   │   │   │   ├── FunctionFlags.h
│   │   │   │   ├── GenericTypes.cpp
│   │   │   │   ├── GenericTypes.h
│   │   │   │   ├── PackageCore.cpp
│   │   │   │   ├── PropertyFlags.cpp
│   │   │   │   └── PropertyFlags.h
│   │   │   ├── cpplinq.hpp
│   │   │   └── tinyformat.h
│   │   ├── EngineClasses.h
│   │   ├── MainGenerator.cpp
│   │   └── MainGenericTypes.cpp
│   ├── SdkGenerator.cpp
│   ├── SdkGenerator.h
│   ├── Tools.cpp
│   ├── Tools.h
│   ├── UiWindow.cpp
│   ├── UiWindow.h
│   ├── UnrealFinderTool.cpp
│   ├── UnrealFinderTool.rc
│   ├── UnrealFinderTool.vcxproj
│   ├── UnsortedMap.h
│   ├── Utils.cpp
│   ├── Utils.h
│   ├── json.hpp
│   ├── packages.config
│   ├── pch.cpp
│   ├── pch.h
│   └── resource.h
├── UnrealFinderTool.sln
├── docs
│   ├── ReadMe.md
│   └── _config.yml
└── images
    ├── cfg_1.png
    ├── download.gif
    ├── ui_1.png
    ├── ui_2.png
    ├── ui_3.png
    └── youtube_thumbnail.png

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

```

`README.md`:

```md
## Deprecated

**This version is deprecated use version 4 for more fixes and featuer**
[CheatGear](https://github.com/CorrM/cg)  
Cheat Gear is not associated in anyway with the old UFT tool(v3) and has been completely rewritten.  
The old tool(v3) will not be updated but will remain open source for anyone wanting to learn.

# Unreal Finder Tool
Useful tool to help you fetch and dump Unreal Engine 4 Games information.

## Support And Goals
- I already spent a good count of my time to make this tool and improve it, and will give it more time with your support.
- There are some goals we would like to achieve on patreon.

Website | Link
------- | ----
PayPal  | [![PayPal](https://www.paypalobjects.com/en_US/i/btn/btn_donate_LG.gif)](http://paypal.me/IslamNofl)
Patron  | [![patron_button](https://c5.patreon.com/external/logo/become_a_patron_button.png)](https://www.patreon.com/bePatron?u=16013498)

## Features
| Feature           | Description |
| ----------------- | ----------- |
| Nice and Easy UI  | i use [ImGUI](https://github.com/ocornut/imgui) for easy and beautifully UI |
| Find GNames       | Find GNames array |
| Find GObjects     | Find GObjects array |
| Instance Logger   | Dump GNames and GObjects into file |
| Sdk Generator     | Generate CPP SDK |
| Read/Write Kernel | Read/Write Process memory with Kernel |

## Compatibility

| Platform      | Game Compatibility |
| ------------- | ------------------ |
| Windows 64bit | x32 & x64          |
| Windows 32bit | x32                |

## How to use
This video tell you how to use the tool and dump sdk for ue4 game.
- Some changes before watch the video.
  - Now you don't need to do any thing about GNames address since now you just need to click `use` button.

[Youtube Video](https://www.youtube.com/watch?v=3CjsrnvKtGs)

## Screen Shots
![ui_1](/images/ui_1.png)
![ui_2](/images/ui_2.png)
![ui_3](/images/ui_3.png)

## Download
[![Last Version](/images/download.gif)](https://github.com/CorrM/Unreal-Finder-Tool/releases/latest)

## Credits
Name | Reason
---- | ------
[@CorrM](https://github.com/CorrM) | Build This Tool :v:
[@WheresMyRide](https://github.com/WheresMyRide) | Bug Haunter :joy:
@KN4CK3R | Base SDK Generator
[@harakirinox](https://www.unknowncheats.me/forum/members/1692305.html) | BypassPH (Read/Write Kernal)

## Change Log
##### 25-06-2019 - 3.1.0
- Support `ProcessEvent`.
- Add colors for GObjects input field.
- Add some useful items on `Menu Button`.
- Add `Donate` Popup.
- Some Improves for `GObjects Finder`.
- Add example `JsonEngine` file `DeadByDayLight.json`.
- Some Bugs fixed.

##### 18-06-2019 - Atomic edition
- Improves for `SDK-Generator`:
  - Now it's `super super fast` And Generate a `Full Dump`.
    - A lot of fixes.
    - Some core changes.
    - Fix bug that's case a `non-full SDK`.
  - Fix bugs when your target is x32 and the tool is x64.
- Improves for `Generated SDK`:
  - Now it's ready to use direclty.
    - Support for `Gobjects Chunks`.
    - Add `InitSdk` Function.
    - Add `FindObjects` Function.
    - Solve bug, Some time `Generator` genrate a cpp keyword as param or bad char on variable names.
- Some `UI` changes and bugs solved.

##### 09-06-2019
- `JsonEngine` is system that's use josn files as container for main ue4 structs.
  - Since UE4 have different versions, some time `ue4 structs` changes.
  - That's make fix specific games problems is easy, since the most of problems because of UE4 Version structs changes.
  - So `JsonEngine` give me the ability to just create an other json file that's have the changed structs to override default structs to support any other UE4 version.
- `SDK generator ReWork` is hard changes for `sdk generator`.
  - That's make the tool now faster than before significantly.
  - Easy to add and improve feature In the future.
- `Tool Debugging`, it's to help fetching why tool crashed and generate file that's help to solve the problem.
- New UI that give me some space to add new `Features`.
- `Address Veiwer` is a hex viwer to dump memory arround to address pulled form the tool.
  - That's give you ability to check if your address is valid to use or not.
- Add some UI labels.
  - Unreal Version: That's fetch which UE that game development with.
  - Win Title: Get window title of target game.
- `GObjects/GName Finder` Improved.
  - Let `GNames address` that's pulled from the finder to be used directly without need to dereference it.
  - `GObjects Finder` now get GObjects chunks address.
- `SDK Generator` Improved.
  - Fix some bugs that's case `some problem` or `missed offsets`.
  - Fix some code form that's slow the generating progress.
- Performance improves.
  - `GObjects/GName Finder` now really faster and more stability.
  - `Instance Logger` now really faster and more stability.
  - `SDK Generator` now really faster and more stability.
- `BUGS`.
  - Fix some `UI` bugs.
  - Fix some `Finder` bugs.

##### 04-06-2019
- Add Settings button.
- Start using [Font Awesome](https://fontawesome.com/)

##### 03-06-2019
- Improve `Sdk Generator`.
  - `Sdk Generator` now significantly faster
  - Some organization for `Sdk Generator` code.
- Improve `Class Finder`.
  - Now can search for `class name` of address.
    - Put `instance address` and the tool will give you instance `class name`
  - When you search for `class name` you will get also instance thats `derived` from `class name`.
    - it's useful to find your target fast, you will get the name of `derived` next to instance address.
    - In example you search for `PlayerBase` you will get `PlayerBase`, `PlayerExtarBase` and `GamePlayer`.
  - Now significantly faster.

##### 01-06-2019
- Support `GObjects Chunks`.
  - Some games use `GObject's chunks` as same as `GNames`, so i just support it.
  - You still can set the addres of `first UObject` in GObject list or `first chunk` address.
  - Auto detect it's first `UObject` or first `chunk` address.
  
##### 31-05-2019
- Add `Class Finder`.
  - Search for instance with his `class name`.
  - Useful to find some `hard adrress`, for ex: to make a `sig` to scan.

##### 30-05-2019
- Add new settings.
- Sdk Generator +10% faster.
- Add `Game Name`, `Game Version` to `Sdk Generator`.
- Add `Sdk Type` to `Sdk Generator`.
  - **Internal**: Usually used when your target is inject dll into game process.
    - It's generate functions and funtction params. without `ReadAsMe`/`WriteAsMe` function.
    - You can directly cast/write block of memory as your class/struct.
  - **External**: Usually used when your target is write or read game process memory from your process.
    - Support read as object (class/struct) with `ReadAsMe` function in **every** class/struct.
    - Support write as object (class/struct) with `WriteAsMe` function in **every** class/struct.
    - It's useful to read/write block of memory as class/struct.
    - No functions generaterd for external for now. maybe later i will support call function from external.
    - To support `ReadAsMe`/`WriteAsMe` in your project, you need to edit **settings** file.
    - Good example for `read` function [here](https://github.com/CorrM/Unreal-Finder-Tool/blob/ebc7abfd28b2a5a3df19baffc485770f982d102d/UnrealFinderTool/Memory.h#L24), for write function same as `read` but `WriteProcessMemory`.
- Some Optimization.

##### 28-05-2019
- Add UI.
- Some changes to `SDK Generator` and `Instance Logger`.
- Let GObject address getted form `GObject Finder` be valid to use directly.
  - You can now just set the address you get from `GObjects finder` in the `GObject input field`.

##### 25-05-2019
- Add `SDK Generator`.
- Add Settings file.
- Improve `Instance Logger`.

##### 09-05-2019
- Add `JSON reflctor`.
- Convert `Instance Logger` to `JSON reflector`.

##### 06-05-2019
- Add `Instance Logger`.

##### 02-05-2019
- First version released

```

`UnrealFinderTool.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28307.572
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "UnrealFinderTool", "UnrealFinderTool\UnrealFinderTool.vcxproj", "{FE73D2A7-562C-4B4D-B740-162D1DDDFFAB}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{FE73D2A7-562C-4B4D-B740-162D1DDDFFAB}.Debug|x64.ActiveCfg = Debug|x64
		{FE73D2A7-562C-4B4D-B740-162D1DDDFFAB}.Debug|x64.Build.0 = Debug|x64
		{FE73D2A7-562C-4B4D-B740-162D1DDDFFAB}.Debug|x86.ActiveCfg = Debug|Win32
		{FE73D2A7-562C-4B4D-B740-162D1DDDFFAB}.Debug|x86.Build.0 = Debug|Win32
		{FE73D2A7-562C-4B4D-B740-162D1DDDFFAB}.Release|x64.ActiveCfg = Release|x64
		{FE73D2A7-562C-4B4D-B740-162D1DDDFFAB}.Release|x64.Build.0 = Release|x64
		{FE73D2A7-562C-4B4D-B740-162D1DDDFFAB}.Release|x86.ActiveCfg = Release|Win32
		{FE73D2A7-562C-4B4D-B740-162D1DDDFFAB}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {F5CC3DE6-FF60-4B40-87CF-8222AAA1C202}
	EndGlobalSection
EndGlobal

```

`UnrealFinderTool/BypaPH.h`:

```h
#pragma once
#pragma warning(disable: 4005)
#include <string>
#include <winioctl.h>
#include <ntstatus.h>

#include "Driver.h"
#include "KProcessHacker.h"
#include "Tools.h"

#define KPH_DEVICE_TYPE 0x9999
#define KPH_CTL_CODE(x) CTL_CODE(KPH_DEVICE_TYPE, 0x800 + x, METHOD_NEITHER, FILE_ANY_ACCESS)
#define KPH_READVIRTUALMEMORYUNSAFE KPH_CTL_CODE(58)
#define KPH_READVIRTUALMEMORY KPH_CTL_CODE(56)
#define KPH_WRITEVIRTUALMEMORY KPH_CTL_CODE(57)

#define PHACKER_DRIVER_FILE  "kprocesshacker.sys"
#define PHACKER_SERVICE_NAME "KProcessHacker2"
#define PHACKER_DEVICE_NAME  "\\Device\\KProcessHacker2"

class BypaPH
{
public:
	HANDLE m_hTarget = nullptr;
	DWORD pID = 0;

	BypaPH(DWORD dwTargetPid = NULL)
	{
		pID = dwTargetPid;
		CustomSetPrivilege(SE_DEBUG_NAME, TRUE);

		SYSTEM_INFO si;
		GetNativeSystemInfo(&si);

		if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64)
			m_drv = new Driver(PHACKER_DRIVER_FILE, PHACKER_DEVICE_NAME, PHACKER_SERVICE_NAME, KProcessHacker_2_38_x64, KProcessHacker_2_38_x64_size);
		else
			m_drv = new Driver(PHACKER_DRIVER_FILE, PHACKER_DEVICE_NAME, PHACKER_SERVICE_NAME, KProcessHacker_2_38_x86, KProcessHacker_2_38_x86_size);

		if (dwTargetPid)
			Attach(dwTargetPid);
	}

	~BypaPH()
	{
		delete m_drv;
		if (m_hTarget)
			CloseHandle(m_hTarget);
		CustomSetPrivilege(SE_DEBUG_NAME, FALSE);
	}

	NTSTATUS RWVM(HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesReadOrWritten = nullptr, bool read = true, bool unsafe = false)
	{
		// If status == 0xC0000004 (STATUS_INFO_LENGTH_MISMATCH) you are most likely using the x64 driver from an x86 process.
		// ProcessHandle may be NULL if reading kernel memory >= 0x8*
		if (!m_drv->GetHandle())
			return STATUS_ABANDONED;

		struct
		{
			HANDLE ProcessHandle;
			PVOID BaseAddress;
			PVOID Buffer;
			SIZE_T BufferSize;
			PSIZE_T NumberOfBytesRead;
		} input = { ProcessHandle, BaseAddress, Buffer, BufferSize, NumberOfBytesReadOrWritten };

		IO_STATUS_BLOCK isb;

		ULONG ioctrlCode = 0;
		if (!read && unsafe) // There is no write unsafe
			return STATUS_ABANDONED;
		if (read && unsafe)
			ioctrlCode = KPH_READVIRTUALMEMORYUNSAFE;
		if (read && !unsafe)
			ioctrlCode = KPH_READVIRTUALMEMORY;
		if (!read && !unsafe)
			ioctrlCode = KPH_WRITEVIRTUALMEMORY;

		return NtDeviceIoControlFile(m_drv->GetHandle(), nullptr, nullptr, nullptr, &isb, ioctrlCode, &input, sizeof(input), nullptr, 0);
		// If status == 0xC0000004 (STATUS_INFO_LENGTH_MISMATCH) you are most likely using the x64 driver from an x86 process.
		// We could have it working by having the struct at the right size though.
	}

	template <class T> T RVMu(HANDLE ProcessHandle, PVOID BaseAddress, PSIZE_T NumberOfBytesRead = nullptr)
	{
		T response = {};
		RWVM(ProcessHandle, BaseAddress, &response, sizeof(T), NumberOfBytesRead, true, true);
		return response;
	}

	template <class T> T qRVMu(PVOID BaseAddress, PSIZE_T NumberOfBytesRead = nullptr)
	{
		if (!m_hTarget)
		{
			*NumberOfBytesRead = 0;
			return T{};
		}
		return RVMu<T>(m_hTarget, BaseAddress, NumberOfBytesRead);
	}

	template <class T> T RVM(HANDLE ProcessHandle, PVOID BaseAddress, PSIZE_T NumberOfBytesRead = nullptr)
	{
		T response = {};
		RWVM(ProcessHandle, BaseAddress, &response, sizeof(T), NumberOfBytesRead, true, false);
		return response;
	}

	template <class T> T qRVM(PVOID BaseAddress, PSIZE_T NumberOfBytesRead = nullptr)
	{
		if (!m_hTarget)
		{
			*NumberOfBytesRead = 0;
			return T{};
		}
		return RVM<T>(m_hTarget, BaseAddress, NumberOfBytesRead);
	}

	std::string qRVM_String(PVOID BaseAddress, SIZE_T ReadSize, PSIZE_T NumberOfBytesRead = nullptr)
	{
		if (!m_hTarget)
		{
			*NumberOfBytesRead = 0;
			return "";
		}

		auto* buf = new char[ReadSize];
		ZeroMemory(buf, sizeof(char) * ReadSize);
		RWVM(m_hTarget, BaseAddress, buf, ReadSize, NumberOfBytesRead);
		std::string ret(buf);

		delete[] buf;
		return ret;
	}

	std::wstring qRVM_WString(PVOID BaseAddress, SIZE_T ReadSize, PSIZE_T NumberOfBytesRead = nullptr)
	{
		if (!m_hTarget)
		{
			*NumberOfBytesRead = 0;
			return L"";
		}

		auto* buf = new wchar_t[ReadSize];
		ZeroMemory(buf, sizeof(wchar_t) * ReadSize);
		RWVM(m_hTarget, BaseAddress, buf, ReadSize, NumberOfBytesRead);
		std::wstring ret(buf);

		delete[] buf;
		return ret;
	}

	NTSTATUS WVM(HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesWritten = nullptr)
	{
		return RWVM(ProcessHandle, BaseAddress, Buffer, BufferSize, NumberOfBytesWritten, false, false);
	}

	NTSTATUS qWVM(PVOID BaseAddress, PVOID Buffer, SIZE_T BufferSize, PSIZE_T NumberOfBytesWritten = nullptr)
	{
		if (!m_hTarget)
		{
			*NumberOfBytesWritten = 0;
			return STATUS_ABANDONED;
		}
		return WVM(m_hTarget, BaseAddress, Buffer, BufferSize, NumberOfBytesWritten);
	}

	bool Attach(DWORD dwPid)
	{
		if (m_hTarget)
			if (!CloseHandle(m_hTarget))
				return false;
		m_hTarget = OpenProcess(SYNCHRONIZE, FALSE, dwPid); // Read will work whatever the handle permission.
		return m_hTarget != nullptr;
	}

	bool Detach(DWORD dwPid)
	{
		if (m_hTarget)
			if (!CloseHandle(m_hTarget))
				return false;
		m_hTarget = nullptr;
		return true;
	}

private:
	Driver* m_drv = nullptr;
};

```

`UnrealFinderTool/ClassFinder.cpp`:

```cpp
#include "pch.h"
#include "NamesStore.h"
#include "ClassFinder.h"
#include <sstream>

std::vector<std::string> ClassFinder::Find(const uintptr_t gObjAddress, const uintptr_t gNamesAddress, const std::string& objectType)
{
	std::vector<std::string> ret;

	// Dump GNames
	NamesStore::Initialize(gNamesAddress, false);

	// Dump GObjects
	ObjectsStore::Initialize(gObjAddress, false);

	std::string formattedStr = objectType;

	if (formattedStr._Starts_with("0x"))
		formattedStr.erase(0, 2);

	if (Utils::IsHexNumber(formattedStr))
	{
		auto matches = FindThatObjectByAddress(formattedStr, false);
		std::for_each(matches.begin(), matches.end(), [&ret](const UEObject& obj)
		{
			ret.push_back(obj.GetInstanceClassName());
		});
	}
	else
	{
		auto matches = FindThatObject(formattedStr, false);
		std::stringstream ss;
		std::for_each(matches.begin(), matches.end(), [&](const UEObject& obj)
		{
			// Get address, convert to hex string, change chars to upper
			ss << std::hex << obj.GetAddress();
			std::string tmpUpper = ss.str();
			std::transform(tmpUpper.begin(), tmpUpper.end(), tmpUpper.begin(), toupper);
			tmpUpper = "0x" + tmpUpper + " [ " + obj.GetInstanceClassName() + " ]";

			// Clear
			ss.str("");
			ss.clear();

			ret.push_back(tmpUpper);
		});
	}

	return ret;
}

std::vector<UEObject> ClassFinder::FindThatObject(const std::string& typeName, const bool firstOnly)
{
	std::vector<UEObject> ret;

	for (size_t i = 0; i < ObjectsStore().GetObjectsNum(); ++i)
	{
		const UEObject* object = ObjectsStore().GetByIndex(i);

		if (object->IsA(typeName))
		{
			ret.push_back(*object);
			if (firstOnly) break;
		}
	}
	return ret;
}

std::vector<UEObject> ClassFinder::FindThatObjectByAddress(const std::string& typeName, const bool firstOnly)
{
	std::vector<UEObject> ret;
	uintptr_t instanceAddress = Utils::CharArrayToUintptr(typeName);

	for (size_t i = 0; i < ObjectsStore().GetObjectsNum(); ++i)
	{
		const UEObject* object = ObjectsStore().GetByIndex(i);

		if (object->GetAddress() == instanceAddress)
		{
			ret.push_back(*object);
			if (firstOnly) break;
		}
	}
	return ret;
}

```

`UnrealFinderTool/ClassFinder.h`:

```h
#pragma once
#include "ObjectsStore.h"

class ClassFinder
{
public:
	std::vector<std::string> Find(uintptr_t gObjAddress, uintptr_t gNamesAddress, const std::string& objectType);

private:
	static std::vector<UEObject> FindThatObject(const std::string& typeName, bool firstOnly = false);
	static std::vector<UEObject> FindThatObjectByAddress(const std::string& typeName, bool firstOnly);
};

```

`UnrealFinderTool/Config/EngineCore/4.14.1.json`:

```json
{
  "engine version": "4.14.1",
  "structs": [
    {
      "name": "UProperty",
      "super": "UField",
      "vars": [
        { "ArrayDim": "int" },
        { "ElementSize": "int" },
        { "PropertyFlags": "FQWord" },
        { "RepIndex": "uint16" },
        { "BlueprintReplicationCondition": "uint8" },
        { "pad_1": "uint8" },
        { "Offset": "int" },
        { "RepNotifyFunc": "FName" },
        { "PropertyLinkNext": "*" },
        { "NextRef": "*" },
        { "DestructorLinkNext": "*" },
        { "PostConstructLinkNext": "*" },
		{ "pad_2": "*" }
      ],
      "note": ""
    }
  ]
}
```

`UnrealFinderTool/Config/EngineCore/DeadByDayLight.json`:

```json
{
  "engine version": "4.21.2",
  "structs": [
    {
      "name": "UObject",
      "super": "",
      "vars": [
        { "VfTable": "FPointer" },
        { "Flags": "int" },
        { "InternalIndex": "int" },
        { "Class": "UClass*" },
        { "Name": "FName" },
        { "pad_01": "*" },
        { "Outer": "UObject*" }
      ],
      "note": ""
    },
    {
      "name": "UProperty",
      "super": "UField",
      "vars": [
        { "ArrayDim": "int" },
        { "ElementSize": "int" },
        { "PropertyFlags": "FQWord" },
        { "RepIndex": "uint16" },
        { "BlueprintReplicationCondition": "uint8" },
        { "pad_01": "uint8" },
        { "Offset": "int" },
        { "RepNotifyFunc": "FName" },
        { "PropertyLinkNext": "*" },
        { "NextRef": "*" },
        { "DestructorLinkNext": "*" },
        { "PostConstructLinkNext": "*" },
        { "pad_02": "*" }
      ],
      "note": ""
    }
  ]
}
```

`UnrealFinderTool/Config/EngineCore/EngineBase.json`:

```json
{
  "engine version": "4.22.2",
  "structs": [
    {
      "name": "FNameEntity",
      "super": "",
      "vars": [
        { "Index": "int" },
        { "AnsiName": "string" }
      ],
      "note": "That's for GNames"
    },
    {
      "name": "FName",
      "super": "",
      "vars": [
        { "Index": "int" },
        { "Number": "int" }
      ],
      "note": "That's for GObjects"
    },
    {
      "name": "FUObjectItem",
      "super": "",
      "vars": [
        { "Object": "UObject*" },
        { "Flags": "int" },
        { "ClusterIndex": "int" },
        { "SerialNumber": "int" },
        { "Unknown_00": "4" }
      ],
      "note": ""
    },
    {
      "name": "FPointer",
      "super": "",
      "vars": [
        { "Dummy": "*" }
      ],
      "note": "* mean it's pointer"
    },
    {
      "name": "TArray",
      "super": "",
      "vars": [
        { "Data": "*" },
        { "Count": "int" },
        { "Max": "int" }
      ],
      "note": ""
    },
    {
      "name": "FQWord",
      "super": "",
      "vars": [
        { "A": "int" },
        { "B": "int" }
      ],
      "note": ""
    },
    {
      "name": "FName",
      "super": "",
      "vars": [
        { "ComparisonIndex": "int" },
        { "Number": "int" }
      ],
      "note": ""
    },
    {
      "name": "FString",
      "super": "",
      "vars": [
        { "data": "*" },
        { "count": "int" },
        { "max": "int" }
      ],
      "note": ""
    },
    {
      "name": "FScriptInterface",
      "super": "",
      "vars": [
        { "ObjectPointer": "UObject*" },
        { "InterfacePointer": "*" }
      ],
      "note": ""
    },
    {
      "name": "UObject",
      "super": "",
      "vars": [
        { "VfTable": "FPointer" },
        { "Flags": "int" },
        { "InternalIndex": "int" },
        { "Class": "UClass*" },
        { "Name": "FName" },
        { "Outer": "UObject*" }
      ],
      "note": ""
    },
    {
      "name": "UField",
      "super": "UObject",
      "vars": [
        { "Next": "UField*" }
      ],
      "note": ""
    },
    {
      "name": "UEnum",
      "super": "UField",
      "vars": [
        { "CppType": "FString" },
        { "Names": "TArray" },
        { "CppForm": "int64" }
      ],
      "note": ""
    },
    {
      "name": "UStruct",
      "super": "UField",
      "vars": [
        { "SuperField": "UStruct*" },
        { "Children": "UField*" },
        { "PropertySize": "int" },
        { "MinAlignment": "int" },
        { "pad_1": "64" }
      ],
      "note": ""
    },
    {
      "name": "UScriptStruct",
      "super": "UStruct",
      "vars": [
        { "StructFlags": "int32" },
        { "PrepareCppStructOpsCompleted": "bool" },
        { "CppStructOps": "ICppStructOps*" }
      ],
      "note": ""
    },
    {
      "name": "UFunction",
      "super": "UStruct",
      "vars": [
        { "FunctionFlags": "int32" },
        { "RepOffset": "int16" },
        { "NumParms": "int8" },
        { "pad_1": "1" },
        { "ParmsSize": "int16" },
        { "ReturnValueOffset": "uint16" },
        { "RPCId": "uint16" },
        { "RPCResponseId": "uint16" },
        { "FirstPropertyToInit": "UProperty*" },
        { "EventGraphFunction": "UFunction*" },
        { "EventGraphCallOffset": "int" },
        { "pad_2": "4" },
        { "Func": "*" }
      ],
      "note": ""
    },
    {
      "name": "UClass",
      "super": "UStruct",
      "vars": [
        { "pad_1": "408" }
      ],
      "note": ""
    },
    {
      "name": "UProperty",
      "super": "UField",
      "vars": [
        { "ArrayDim": "int" },
        { "ElementSize": "int" },
        { "PropertyFlags": "FQWord" },
        { "RepIndex": "uint16" },
        { "BlueprintReplicationCondition": "uint8" },
        { "pad_1": "uint8" },
        { "Offset": "int" },
        { "RepNotifyFunc": "FName" },
        { "PropertyLinkNext": "*" },
        { "NextRef": "*" },
        { "DestructorLinkNext": "*" },
        { "PostConstructLinkNext": "*" }
      ],
      "note": ""
    },
    {
      "name": "UNumericProperty",
      "super": "UProperty",
      "vars": [
      ],
      "note": ""
    },
    {
      "name": "UByteProperty",
      "super": "UNumericProperty",
      "vars": [
        { "Enum": "UEnum*" }
      ],
      "note": ""
    },
    {
      "name": "UBoolProperty",
      "super": "UProperty",
      "vars": [
        { "FieldSize": "uint8" },
        { "ByteOffset": "uint8" },
        { "ByteMask": "uint8" },
        { "FieldMask": "uint8" }
      ],
      "note": ""
    },
    {
      "name": "UObjectPropertyBase",
      "super": "UProperty",
      "vars": [
        { "PropertyClass": "UClass*" }
      ],
      "note": ""
    },
    {
      "name": "UObjectProperty",
      "super": "UObjectPropertyBase",
      "vars": [
      ],
      "note": ""
    },
    {
      "name": "UClassProperty",
      "super": "UObjectProperty",
      "vars": [
        { "MetaClass": "UClass*" }
      ],
      "note": ""
    },
    {
      "name": "UInterfaceProperty",
      "super": "UProperty",
      "vars": [
        { "InterfaceClass": "UClass*" }
      ],
      "note": ""
    },
    {
      "name": "UAssetObjectProperty",
      "super": "UObjectPropertyBase",
      "vars": [
      ],
      "note": ""
    },
    {
      "name": "UAssetClassProperty",
      "super": "UAssetObjectProperty",
      "vars": [
        { "MetaClass": "UClass*" }
      ],
      "note": ""
    },
    {
      "name": "UStructProperty",
      "super": "UProperty",
      "vars": [
        { "Struct": "UScriptStruct*" }
      ],
      "note": ""
    },
    {
      "name": "UArrayProperty",
      "super": "UProperty",
      "vars": [
        { "Inner": "UProperty*" }
      ],
      "note": ""
    },
    {
      "name": "UMapProperty",
      "super": "UProperty",
      "vars": [
        { "KeyProp": "UProperty*" },
        { "ValueProp": "UProperty*" },
        { "MapLayout": "24" }
      ],
      "note": ""
    },
    {
      "name": "UDelegateProperty",
      "super": "UProperty",
      "vars": [
        { "SignatureFunction": "UFunction*" }
      ],
      "note": ""
    },
    {
      "name": "UEnumProperty",
      "super": "UProperty",
      "vars": [
        { "UnderlyingProp": "UNumericProperty*" },
        { "Enum": "UEnum*" }
      ],
      "note": ""
    }
  ]
}

```

`UnrealFinderTool/Config/EngineCore/InsurgencySandstorm.json`:

```json
{
  "engine version": "4.22.1",
  "structs": [
    {
      "name": "UStruct",
      "super": "UField",
      "vars": [
        { "pad_0": "16"},
        { "SuperField": "UStruct*" },
        { "Children": "UField*" },
        { "PropertySize": "int" },
        { "MinAlignment": "int" },
        { "pad_1": "64" }
      ],
      "note": ""
    },
    {
      "name": "UClass",
      "super": "UStruct",
      "vars": [
        { "pad_1": "512" }
      ],
      "note": ""
    },
    {
      "name": "UScriptStruct",
      "super": "UStruct",
      "vars": [
        { "StructFlags": "int32" },
        { "PrepareCppStructOpsCompleted": "bool" },
        { "CppStructOps": "ICppStructOps*" },
        { "pad_0": "3"}
      ],
      "note": ""
    }
  ]
}

```

`UnrealFinderTool/Config/EngineCore/Remnant.json`:

```json
{
    "engine version": "4.22.3",
    "structs": [
        {
            "name": "UStruct",
            "super": "UField",
            "vars": [
                {"Pad0": "int64"},
                {"Pad1": "int64"},
              { "SuperField": "UStruct*" },
              { "Children": "UField*" },
              { "PropertySize": "int" },
              { "MinAlignment": "int" },
              { "pad_1": "64" }
            ],
            "note": ""
          },
          {
            "name": "UFunction",
            "super": "UStruct",
            "vars": [
              { "FunctionFlags": "int32" },
              { "NumParms": "int16" },
              { "ParmsSize": "int8" },
              { "pad_1": "int8" },
              { "iNative": "uint16" },
              { "pad_2": "30" },
              { "Func": "*" }
            ],
            "note": ""
          },
          {
            "name": "UClass",
            "super": "UStruct",
            "vars": [
              { "pad_1": "416‬" }
            ],
            "note": ""
          },
          {
            "name": "UProperty",
            "super": "UField",
            "vars": [
              { "ArrayDim": "int" },
              { "ElementSize": "int" },
              { "PropertyFlags": "FQWord" },
              { "unknown": "int" },
              { "Offset": "int" },
              { "FirstChild": "UProperty" },
              { "NextChild": "UField" }
            ],
            "note": "no PropertySize"
          }
    ]
  }
```

`UnrealFinderTool/Config/Settings.json`:

```json
{
  "sdkGenerator": {
    "core Name": "CoreUObject",
    "memory header": "../Utils.h",
    "memory read": "Utils::MemoryObj->Read",
    "memory write": "Utils::MemoryObj->Write",
    "memory write type": "int",
    "threads": 6,
    "dump Objects": true,
    "dump Names": true,
    "logger ShowSkip": true,
    "logger ShowClassSaveFileName": true,
    "logger ShowStructSaveFileName": true,
    "logger SpaceCount": 85
  } 
}

```

`UnrealFinderTool/Debug.cpp`:

```cpp
#include "pch.h"
#include "Debug.h"

#include <DbgHelp.h>
#include <tchar.h>
#include <sstream>

#pragma warning(disable: 4996)
#pragma comment(lib, "dbghelp")

void Debugging::EnterDebugMode(const bool bConsole)
{
	if (bConsole)
	{
		AllocConsole();
		freopen("CONOUT$", "w", stdout);

		bConsoleEnabled = true;
	}

	isX64 = Utils::ProgramIs64();
	expHandle = AddVectoredExceptionHandler(1UL, ExceptionHandler);
}

LONG WINAPI Debugging::ExceptionHandler(EXCEPTION_POINTERS* e)
{
	//UNREFERENCED_PARAMETER(e);
	if (e->ExceptionRecord->ExceptionCode == EXCEPTION_ACCESS_VIOLATION && CreateMiniDump(e))
	{
		MessageBox(HWND_DESKTOP,
			"Program encountered an issue and was terminated. Dump information is located in Dumps folder in program directory.",
			"Error",
			MB_ICONERROR | MB_OK);
	}

	return EXCEPTION_NONCONTINUABLE_EXCEPTION;
}

BOOL Debugging::CreateMiniDump(EXCEPTION_POINTERS* e)
{
	SYSTEMTIME st;
	MINIDUMP_EXCEPTION_INFORMATION md;
	TCHAR szPath[MAX_PATH] = { 0 };

	GetLocalTime(&st);
	CreateDirectory(_T("Dumps"), nullptr);

	sprintf_s(szPath, MAX_PATH, "Dumps\\%04d%02d%02d-%02d%02d%02d-%ld-%ld.mdmp",
	        st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond,
	        GetCurrentProcessId(), GetCurrentThreadId());

	HANDLE hDump = CreateFile(szPath, GENERIC_WRITE | GENERIC_READ, FILE_SHARE_WRITE | FILE_SHARE_WRITE,
							 nullptr,
	                         CREATE_ALWAYS,
							 0,
	                         nullptr);

	md.ThreadId = GetCurrentThreadId();
	md.ExceptionPointers = e;
	md.ClientPointers = TRUE;

	BOOL bSuccess = MiniDumpWriteDump(GetCurrentProcess(), GetCurrentProcessId(), hDump, MiniDumpWithDataSegs, &md, nullptr, nullptr);
	return bSuccess;
}

void Debugging::Log(const char* format, ...)
{
	if (!bConsoleEnabled)
		return;

	va_list arg;
	va_start(arg, format);

	vprintf(format, arg);
	va_end(arg);
}

void Debugging::LogFile(const char* format, ...)
{
	if (!fp)
	{
		CreateLogFile();
		return;
	}
		

	va_list arg;
	va_start(arg, format);

	vfprintf(fp, format, arg);
	va_end(arg);
}

void Debugging::CreateLogFile()
{
	const char logfile[] = "Dumps\\Debug.log";

	if (!fp)
		fp = fopen(logfile, "w");

	return;
}

Debugging::~Debugging()
{
	if (expHandle)
		RemoveVectoredExceptionHandler(expHandle);
}

```

`UnrealFinderTool/Debug.h`:

```h
#pragma once

class Debugging
{
	bool bConsoleEnabled = false;
	bool isX64 = false;
	FILE* fp = nullptr;
	PVOID expHandle = nullptr;

public:
	void EnterDebugMode(bool bConsole = false);
	void Log(const char *format, ...);
	void LogFile(const char *format, ...);

	~Debugging();
private:
	void CreateLogFile();
	static BOOL CreateMiniDump( EXCEPTION_POINTERS* e);
	static LONG WINAPI ExceptionHandler(EXCEPTION_POINTERS* e);
};
```

`UnrealFinderTool/Driver.cpp`:

```cpp
#include "pch.h"
#include <Windows.h>

#include "Tools.h"
#include "Driver.h"

Driver::Driver(const std::string& strDriverFile,
	const std::string& strDeviceName,
	const std::string& strDriverName,
	const unsigned char* pRawDriver,
	const size_t szRawDriver)
{
	// Using either absolute path or getting relative path
	mStrDriverFile = strDriverFile;
	if (strDriverFile.find_first_of(':') == std::string::npos)
	{
		char currentPath[MAX_PATH];
		GetCurrentDirectoryA(MAX_PATH, currentPath);
		std::string strCurrentPath = currentPath;
		strCurrentPath += "\\";
		mStrDriverFile = strCurrentPath + strDriverFile;
	}

	mStrDeviceName = strDeviceName;
	mStrDriverName = strDriverName;
	mPRawDriver = pRawDriver;
	mSzRawDriver = szRawDriver;

	Load();
}

Driver::~Driver() { Unload(); }

bool Driver::Connect()
{
	// Attempts to connect (get a handle) to the driver, first with the classic way
	const auto hDevice = CreateFileA(mStrDeviceName.c_str(), GENERIC_READ | GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);
	if (hDevice != INVALID_HANDLE_VALUE)
	{
		mHDriver = hDevice;
		return true;
	}

	// If that failed, trying to get a handle directly with NtOpenFile like Process Hacker does (see their source, in kph.c)
	// Thank to sen66 @ UnknownCheats.me for this code snippet
	UNICODE_STRING objectName;
	OBJECT_ATTRIBUTES objectAttributes;
	IO_STATUS_BLOCK isb;
	HANDLE hNtDriver;
	const auto strObjectName = str2wstr(mStrDeviceName);

	RtlInitUnicodeString(&objectName, strObjectName.c_str());
	InitializeObjectAttributes(&objectAttributes, &objectName, FILE_NON_DIRECTORY_FILE, NULL, NULL);
	const auto status = NtOpenFile(&hNtDriver, FILE_GENERIC_READ | FILE_GENERIC_WRITE, &objectAttributes, &isb, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_NON_DIRECTORY_FILE);
	if (NT_SUCCESS(status))
	{
		mHDriver = hNtDriver;
		return true;
	}
	return false;
}

bool Driver::Load()
{
	// Try to get a handle on the driver (if already loaded)
	if (Connect())
	{
		mWasRunning = true;
		return true;
	}
	mWasRunning = false;

	// Getting ready to interact with the service
	const auto hScm = OpenSCManagerA(nullptr, nullptr, SC_MANAGER_CREATE_SERVICE);
	if (!hScm)
		return false;

	// Trying to get a handle on the service if it exist, otherwise we create it
	auto hSc = OpenServiceA(hScm, mStrDriverName.c_str(), SERVICE_START);
	if (!hSc)
	{
		// If driver file doesn't exist on disk and we have an embedded driver, we write it on disk
		if (WriteDataToFile(mPRawDriver, mSzRawDriver, mStrDriverFile))
			mFileWasCreated = true;
		else
			mFileWasCreated = false;

		hSc = CreateServiceA(hScm, mStrDriverName.c_str(), "", SERVICE_START, SERVICE_KERNEL_DRIVER, SERVICE_DEMAND_START, SERVICE_ERROR_IGNORE, mStrDriverFile.c_str(), nullptr, nullptr, nullptr, nullptr, nullptr);
		if (!hSc)
		{
			// Service doesn't exist and can't create it, aborting
			CloseServiceHandle(hScm);
			return false;
		}
		mWasInstalled = false;
	}
	else
		mWasInstalled = true; // The service was already installed

	// Starting service
	auto bStartService = StartServiceA(hSc, NULL, nullptr);
	if (!bStartService && GetLastError() == ERROR_SERVICE_DISABLED)
	{
		// Couldn't start service because it is disabled, upgrading handle to modify servcie configuration and starting it
		CloseServiceHandle(hSc);
		hSc = OpenServiceA(hScm, mStrDriverName.c_str(), SERVICE_START | SERVICE_CHANGE_CONFIG);
		const auto bChangeServiceConfig = ChangeServiceConfigA(hSc, SERVICE_NO_CHANGE, SERVICE_DEMAND_START, SERVICE_NO_CHANGE, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr);
		std::cout << "GLE = " << std::dec << GetLastError() << std::endl;
		if (bChangeServiceConfig)
		{
			bStartService = StartServiceA(hSc, NULL, nullptr);
			if (bStartService)
				mWasDisabled = true;
			else
				mWasDisabled = false;
		}
	}
	CloseServiceHandle(hSc);
	CloseServiceHandle(hScm);

	// Getting handle
	return Connect();
}

bool Driver::Unload()
{
	// Closing handle
	CloseHandle(mHDriver);
	mHDriver = nullptr;

	// If we want to forcibly stop the driver's service and uninstall it, we ignore if it was running and installed
	if (RemoveAllOnExit)
	{
		mWasRunning = false;
		mWasInstalled = false;
	}

	// If the service was running we just leave it be just as it was
	if (mWasRunning && !RemoveAllOnExit)
		return true;

	// Getting ready to interact with the service to stop, disable, and/or delete it
	SERVICE_STATUS scStatus;
	const auto hScm = OpenSCManagerA(nullptr, nullptr, SC_MANAGER_CONNECT);
	if (!hScm)
		return false;
	DWORD dwServicePermission = SERVICE_STOP;
	if (!mWasInstalled)
		dwServicePermission |= DELETE;
	if (mWasDisabled)
		dwServicePermission |= SERVICE_CHANGE_CONFIG;
	const auto hSc = OpenServiceA(hScm, mStrDriverName.c_str(), dwServicePermission);
	if (!hSc)
	{
		CloseServiceHandle(hScm);
		return false;
	}

	// If the service was not running we stop it
	if (!ControlService(hSc, SERVICE_CONTROL_STOP, &scStatus))
	{
		CloseServiceHandle(hSc);
		CloseServiceHandle(hScm);
		return false;
	}

	// If the service was disabled we re-disable it
	if (mWasDisabled)
		if (!ChangeServiceConfigA(hSc, SERVICE_NO_CHANGE, SERVICE_DISABLED, SERVICE_NO_CHANGE, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr))
		{
			CloseServiceHandle(hSc);
			CloseServiceHandle(hScm);
			return false;
		}

	// If the service was installed we stop here
	if (mWasInstalled && !RemoveAllOnExit)
	{
		CloseServiceHandle(hSc);
		CloseServiceHandle(hScm);
		return true;
	}

	// If the service was not installed, we uninstall it
	const auto bDeleteService = DeleteService(hSc);
	CloseServiceHandle(hSc);
	CloseServiceHandle(hScm);

	// If we should delete the file we delete it
	if (mFileWasCreated && RemoveAllOnExit)
		return DeleteFileA(mStrDriverFile.c_str());

	return bDeleteService;
}
```

`UnrealFinderTool/Driver.h`:

```h
#pragma once
#include <string>
#include <iostream>
#include <winternl.h>

#pragma comment (lib, "ntdll.lib")

class Driver
{
public:
	Driver(const std::string& strDriverFile,
		const std::string& strDeviceName,
		const std::string& strDriverName,
		const unsigned char* pRawDriver = nullptr,
		size_t szRawDriver = 0);

	~Driver();

	HANDLE GetHandle() const { return mHDriver; }
	bool RemoveAllOnExit = false;

private:
	bool Connect();
	bool Load();
	bool Unload();

	std::string mStrDriverFile = "";
	std::string mStrDeviceName = "";
	std::string mStrDriverName = "";

	const unsigned char* mPRawDriver = nullptr;
	size_t mSzRawDriver = 0;

	bool mWasRunning = false;
	bool mWasInstalled = false;
	bool mWasDisabled = false;
	bool mFileWasCreated = false;

	HANDLE mHDriver = nullptr;
};


```

`UnrealFinderTool/GObjectsFinder.cpp`:

```cpp
#include "pch.h"
#include "Memory.h"
#include "GObjectsFinder.h"
#include "Scanner.h"
#include "ParallelWorker.h"

/*
 * #NOTES
 * Some GObject use this syntax every 4byte/8byte (pointer) there is UObject
 */

GObjectsFinder::GObjectsFinder(const bool easyMethod) : easyMethod(easyMethod)
{
	dwStart = 0;
	dwEnd = 0;
	ptrSize = !Utils::MemoryObj->Is64Bit ? 0x4 : 0x8;
}

std::vector<uintptr_t> GObjectsFinder::Find()
{
	std::vector<uintptr_t> ret;
	// dwStart = !_memory->Is64Bit ? 0x100000 : static_cast<uintptr_t>(0x7FF00000);
	dwEnd = !Utils::MemoryObj->Is64Bit ? 0x7FEFFFFF : uintptr_t(0x7fffffffffff);

	// Start scan for TArrays
	SYSTEM_INFO si = { 0 };
	GetSystemInfo(&si);

	if (dwStart < reinterpret_cast<uintptr_t>(si.lpMinimumApplicationAddress))
		dwStart = reinterpret_cast<uintptr_t>(si.lpMinimumApplicationAddress);

	if (dwEnd > reinterpret_cast<uintptr_t>(si.lpMaximumApplicationAddress))
		dwEnd = reinterpret_cast<uintptr_t>(si.lpMaximumApplicationAddress);

	MEMORY_BASIC_INFORMATION info = { 0 };
	std::vector<uintptr_t> mem_block;

	// Cycle through memory based on RegionSize
	{
		uintptr_t currentAddress = dwStart;
		bool exitLoop = false;

		do
		{
			exitLoop = !(VirtualQueryEx(Utils::MemoryObj->ProcessHandle, reinterpret_cast<LPVOID>(currentAddress), &info, sizeof info) == sizeof info && currentAddress < dwEnd);

			// Size will used to alloc and read memory
			const size_t allocSize = dwEnd - dwStart >= (easyMethod ? info.RegionSize : si.dwPageSize) ? (easyMethod ? info.RegionSize : si.dwPageSize) : dwEnd - dwStart;

			// Bad Memory
			if (info.Protect & PAGE_NOACCESS)
			{
				// Get next address
				currentAddress += allocSize;
				continue;
			}

			// Get next address
			currentAddress += allocSize;
			mem_block.push_back(currentAddress);

		} while (!exitLoop);

		ParallelQueue<std::vector<uintptr_t>, uintptr_t> worker2(mem_block, 0, Utils::Settings.SdkGen.Threads, [&ret](uintptr_t& address, ParallelOptions& options)
		{
			// Insert region information on Regions Holder
			if (Utils::IsValidGObjectsAddress(address))
			{
				std::lock_guard lock(options.Locker);
				ret.push_back(address);
			}
		});
		worker2.Start();
		worker2.WaitAll();
	}

	// Check if there a GObjects Chunks
	{
		using namespace Hyperscan;
		std::vector<uintptr_t> search_result;
		for (size_t index = 0; index < ret.size(); ++index)
		{
			auto address_holder = HYPERSCAN_SCANNER::Scan(Utils::MemoryObj->ProcessId, ret[index],
				Utils::MemoryObj->Is64Bit ? HyperscanAllignment8Bytes : HyperscanAllignment4Bytes, HyperscanTypeExact);

			if (address_holder.empty())
			{
				ret.erase(index == 0 ? ret.begin() : ret.begin() + index);
				continue;
			}

			for (uintptr_t address_ptr : address_holder)
			{
				bool isChunks;
				if (Utils::IsValidGObjectsAddress(address_ptr, &isChunks) && isChunks && !Utils::MemoryObj->IsStaticAddress(address_ptr))
					search_result.push_back(address_ptr);
			}
		}
		ret.insert(ret.end(), search_result.begin(), search_result.end());
	}

	return ret;
}

```

`UnrealFinderTool/GObjectsFinder.h`:

```h
#pragma once

#define OBJECT_ERROR 1
#define VFTABLE_ERROR 2
#define INDEX_ERROR 3
#include <vector>

class GObjectsFinder
{
	bool easyMethod = false;
	int ptrSize = 0x0;
	uintptr_t dwStart, dwEnd;

public:
	explicit GObjectsFinder(bool easyMethod);
	std::vector<uintptr_t> Find();
};

```

`UnrealFinderTool/GnamesFinder.cpp`:

```cpp
#include "pch.h"
#include "GnamesFinder.h"
#include "Scanner.h"
#include "Memory.h"

Pattern GNamesFinder::noneSig = PatternScan::Parse("None", 0, "4E 6F 6E 65 00", 0xFF);
Pattern GNamesFinder::byteSig = PatternScan::Parse("Byte", 0, "42 79 74 65 50 72 6F 70 65 72 74 79 00", 0xFF);
Pattern GNamesFinder::intSig = PatternScan::Parse("Int", 0, "49 6E 74 50 72 6F 70 65 72 74 79 00", 0xFF);
Pattern GNamesFinder::multicastSig = PatternScan::Parse("MulticastDelegate", 0, "4D 75 6C 74 69 63 61 73 74 44 65 6C 65 67 61 74 65 50 72 6F 70 65 72 74 79", 0xFF);

GNamesFinder::GNamesFinder() : dwStart(0), dwEnd(0)
{
}

std::vector<uintptr_t> GNamesFinder::Find()
{
	std::vector<uintptr_t> ret;
	// dwStart = !_memory->Is64Bit ? 0x300000 : static_cast<uintptr_t>(0x7FF00000);
	dwEnd = !Utils::MemoryObj->Is64Bit ? 0x7FEFFFFF : static_cast<uintptr_t>(0x7fffffffffff);

	// Scan
	std::vector<Pattern> inputs = { noneSig, byteSig, intSig, multicastSig };
	const auto searcher = PatternScan::FindPattern(Utils::MemoryObj, dwStart, dwEnd, inputs, false, true);

	if (searcher.find(noneSig.Name) == searcher.end())
		return ret;

	const auto none_r = searcher.find(noneSig.Name)->second;
	const auto byte_r = searcher.find(byteSig.Name)->second;
	const auto int_r = searcher.find(intSig.Name)->second;
	const auto multicast_r = searcher.find(multicastSig.Name)->second;

	// Get smallest address
	const auto cmp1 = GetNearNumbers(none_r, byte_r, 0x150);
	const auto cmp2 = GetNearNumbers(cmp1, int_r, 0x150);
	const auto cmp3 = GetNearNumbers(cmp2, multicast_r, 0x400);

	size_t nameOffset = Utils::MemoryObj->Is64Bit ? 0x10 : 0x8;
	uintptr_t byteAddress = 0;

	// Calc Name Offset
	if (!cmp3.empty())
	{
		// None == 0
		auto byte = PatternScan::Parse("Byte", 0, "42 79 74 65 50 72 6F 70 65 72 74 79 00", 0xFF);
		auto result = PatternScan::FindPattern(Utils::MemoryObj, cmp3[0], cmp3[0] + 0x200, { byte }, true);
		auto it = result.find("Byte");
		if (it != result.end() && !it->second.empty())
		{
			byteAddress = it->second.front();
			auto byte_index = PatternScan::Parse("ByteIndex", 0, "02 00 00 00", 0xFF);
			result = PatternScan::FindPattern(Utils::MemoryObj, byteAddress - 0x20, byteAddress, { byte_index }, true);
			it = result.find("ByteIndex");
			if (it != result.end() && !it->second.empty())
				nameOffset = byteAddress - it->second.front();
		}
	}

	for (uintptr_t i : cmp3)
	{
		i = i - nameOffset;
		ret.push_back(GetChunksAddress(i));
	}

	return ret;
}

uintptr_t GNamesFinder::GetChunksAddress(const uintptr_t fname_address)
{
	using namespace Hyperscan;
	uintptr_t ret = fname_address;

	// Get GName array address
	auto address_holder = HYPERSCAN_SCANNER::Scan(Utils::MemoryObj->ProcessId, fname_address,
		Utils::MemoryObj->Is64Bit ? HyperscanAllignment8Bytes : HyperscanAllignment4Bytes, HyperscanTypeExact);

	// Nothing returned quit
	if (!address_holder.empty())
	{
		for (uintptr_t i : address_holder)
		{
			// Any address larger than this is usually garbage
			if (i > uintptr_t(0x7ff000000000))
				continue;

			// Scan for Gnames chunks address
			auto gname_array_address = HYPERSCAN_SCANNER::Scan(Utils::MemoryObj->ProcessId, i,
				Utils::MemoryObj->Is64Bit ? HyperscanAllignment8Bytes : HyperscanAllignment4Bytes, HyperscanTypeExact);
			for (uintptr_t chunk_address : gname_array_address)
			{
				if (Utils::IsValidGNamesAddress(chunk_address))
				{
					ret = chunk_address;
					break;
				}
			}
		}
	}

	return ret;
}

std::vector<uintptr_t> GNamesFinder::GetNearNumbers(const std::vector<uintptr_t>& list1, const std::vector<uintptr_t>& list2, const int maxValue)
{
	std::vector<uintptr_t> ret;
	for (long long i : list1)
		for (long long i2 : list2)
			if (abs(i - i2) <= maxValue)
				ret.push_back(i);
	return ret;
}
```

`UnrealFinderTool/GnamesFinder.h`:

```h
#pragma once
#include "PatternScan.h"

class GNamesFinder
{
	uintptr_t dwStart, dwEnd;
	static Pattern noneSig, byteSig, intSig, multicastSig;
	static std::vector<uintptr_t> GetNearNumbers(const std::vector<uintptr_t>& list1, const std::vector<uintptr_t>& list2, int maxValue);
	static uintptr_t GetChunksAddress(uintptr_t fname_address);
public:
	GNamesFinder();
	std::vector<uintptr_t> Find();
};


```

`UnrealFinderTool/HttpWorker.cpp`:

```cpp
#include "pch.h"
#include <winhttp.h>
#include "HttpWorker.h"

pplx::task<http_response> HttpWorker::Get(const std::wstring& url)
{
	http_client_config config;
	config.set_nativehandle_options([](const native_handle handle)
	{
		// Disable auto redirects
		DWORD dwOptionValue = WINHTTP_DISABLE_REDIRECTS;
		WinHttpSetOption(handle, WINHTTP_OPTION_DISABLE_FEATURE, &dwOptionValue, sizeof dwOptionValue);
	});

	http_client client(url, config);
	pplx::task<http_response> resp = client.request(methods::GET);

	return resp;
}

```

`UnrealFinderTool/HttpWorker.h`:

```h
#pragma once
#include <string>
#include <cpprest/http_client.h>
#include <cpprest/filestream.h>

using namespace utility;                    // Common utilities like string conversions
using namespace web;                        // Common features like URIs.
using namespace web::http;                  // Common HTTP functionality
using namespace web::http::client;          // HTTP client features
using namespace concurrency::streams;       // Asynchronous streams

class HttpWorker
{
public:
	static pplx::task<http_response> Get(const std::wstring& url);
};

```

`UnrealFinderTool/IconsFontAwesome.h`:

```h
// Generated by https://github.com/juliettef/IconFontCppHeaders script GenerateIconFontCppHeaders.py for language C++11
// from https://raw.githubusercontent.com/FortAwesome/Font-Awesome/master/metadata/icons.yml
// for use with https://github.com/FortAwesome/Font-Awesome/blob/master/webfonts/fa-solid-900.ttf, https://github.com/FortAwesome/Font-Awesome/blob/master/webfonts/fa-regular-400.ttf, 
#pragma once

#define FONT_ICON_FILE_NAME_FAR "Fonts\\fa-regular-400.ttf"
#define FONT_ICON_FILE_NAME_FAS "Fonts\\fa-solid-900.ttf"

#define ICON_MIN_FA 0xf000
#define ICON_MAX_FA 0xf83e
#define ICON_FA_NOTES_MEDICAL u8"\uf481"
#define ICON_FA_CLOUD_SHOWERS_HEAVY u8"\uf740"
#define ICON_FA_SMS u8"\uf7cd"
#define ICON_FA_COPY u8"\uf0c5"
#define ICON_FA_CHEVRON_CIRCLE_RIGHT u8"\uf138"
#define ICON_FA_CROSSHAIRS u8"\uf05b"
#define ICON_FA_BROADCAST_TOWER u8"\uf519"
#define ICON_FA_EXTERNAL_LINK_SQUARE_ALT u8"\uf360"
#define ICON_FA_SMOKING u8"\uf48d"
#define ICON_FA_KISS_BEAM u8"\uf597"
#define ICON_FA_CHESS_BISHOP u8"\uf43a"
#define ICON_FA_TV u8"\uf26c"
#define ICON_FA_CROP_ALT u8"\uf565"
#define ICON_FA_TH u8"\uf00a"
#define ICON_FA_RECYCLE u8"\uf1b8"
#define ICON_FA_SMILE u8"\uf118"
#define ICON_FA_FAX u8"\uf1ac"
#define ICON_FA_DRAFTING_COMPASS u8"\uf568"
#define ICON_FA_USER_INJURED u8"\uf728"
#define ICON_FA_SCREWDRIVER u8"\uf54a"
#define ICON_FA_DHARMACHAKRA u8"\uf655"
#define ICON_FA_PRINT u8"\uf02f"
#define ICON_FA_BABY_CARRIAGE u8"\uf77d"
#define ICON_FA_CARET_UP u8"\uf0d8"
#define ICON_FA_SCHOOL u8"\uf549"
#define ICON_FA_SORT_NUMERIC_UP u8"\uf163"
#define ICON_FA_TRUCK_LOADING u8"\uf4de"
#define ICON_FA_LIST u8"\uf03a"
#define ICON_FA_UPLOAD u8"\uf093"
#define ICON_FA_LAPTOP_MEDICAL u8"\uf812"
#define ICON_FA_EXPAND_ARROWS_ALT u8"\uf31e"
#define ICON_FA_ADJUST u8"\uf042"
#define ICON_FA_VENUS u8"\uf221"
#define ICON_FA_HEADING u8"\uf1dc"
#define ICON_FA_ARROW_DOWN u8"\uf063"
#define ICON_FA_BICYCLE u8"\uf206"
#define ICON_FA_TIRED u8"\uf5c8"
#define ICON_FA_AIR_FRESHENER u8"\uf5d0"
#define ICON_FA_BACON u8"\uf7e5"
#define ICON_FA_SYNC u8"\uf021"
#define ICON_FA_PAPER_PLANE u8"\uf1d8"
#define ICON_FA_VOLLEYBALL_BALL u8"\uf45f"
#define ICON_FA_RIBBON u8"\uf4d6"
#define ICON_FA_HAND_LIZARD u8"\uf258"
#define ICON_FA_CLOCK u8"\uf017"
#define ICON_FA_SUN u8"\uf185"
#define ICON_FA_FILE_POWERPOINT u8"\uf1c4"
#define ICON_FA_MICROCHIP u8"\uf2db"
#define ICON_FA_TRASH_RESTORE_ALT u8"\uf82a"
#define ICON_FA_GRADUATION_CAP u8"\uf19d"
#define ICON_FA_ANGLE_DOUBLE_DOWN u8"\uf103"
#define ICON_FA_INFO_CIRCLE u8"\uf05a"
#define ICON_FA_TAGS u8"\uf02c"
#define ICON_FA_FILE_ALT u8"\uf15c"
#define ICON_FA_EQUALS u8"\uf52c"
#define ICON_FA_DIRECTIONS u8"\uf5eb"
#define ICON_FA_FILE_INVOICE u8"\uf570"
#define ICON_FA_SEARCH u8"\uf002"
#define ICON_FA_BIBLE u8"\uf647"
#define ICON_FA_FLASK u8"\uf0c3"
#define ICON_FA_CALENDAR_TIMES u8"\uf273"
#define ICON_FA_GREATER_THAN_EQUAL u8"\uf532"
#define ICON_FA_SLIDERS_H u8"\uf1de"
#define ICON_FA_EYE_SLASH u8"\uf070"
#define ICON_FA_BIRTHDAY_CAKE u8"\uf1fd"
#define ICON_FA_FEATHER_ALT u8"\uf56b"
#define ICON_FA_DNA u8"\uf471"
#define ICON_FA_BASEBALL_BALL u8"\uf433"
#define ICON_FA_HOSPITAL u8"\uf0f8"
#define ICON_FA_COINS u8"\uf51e"
#define ICON_FA_HRYVNIA u8"\uf6f2"
#define ICON_FA_TEMPERATURE_HIGH u8"\uf769"
#define ICON_FA_FONT_AWESOME_LOGO_FULL u8"\uf4e6"
#define ICON_FA_PASSPORT u8"\uf5ab"
#define ICON_FA_TAG u8"\uf02b"
#define ICON_FA_SHOPPING_CART u8"\uf07a"
#define ICON_FA_AWARD u8"\uf559"
#define ICON_FA_WINDOW_RESTORE u8"\uf2d2"
#define ICON_FA_PHONE u8"\uf095"
#define ICON_FA_FLAG u8"\uf024"
#define ICON_FA_STETHOSCOPE u8"\uf0f1"
#define ICON_FA_DICE_D6 u8"\uf6d1"
#define ICON_FA_OUTDENT u8"\uf03b"
#define ICON_FA_LONG_ARROW_ALT_RIGHT u8"\uf30b"
#define ICON_FA_PIZZA_SLICE u8"\uf818"
#define ICON_FA_ADDRESS_CARD u8"\uf2bb"
#define ICON_FA_PARAGRAPH u8"\uf1dd"
#define ICON_FA_MALE u8"\uf183"
#define ICON_FA_HISTORY u8"\uf1da"
#define ICON_FA_HAMBURGER u8"\uf805"
#define ICON_FA_SEARCH_PLUS u8"\uf00e"
#define ICON_FA_FIRE_ALT u8"\uf7e4"
#define ICON_FA_LIFE_RING u8"\uf1cd"
#define ICON_FA_SHARE u8"\uf064"
#define ICON_FA_ALIGN_JUSTIFY u8"\uf039"
#define ICON_FA_BATTERY_THREE_QUARTERS u8"\uf241"
#define ICON_FA_OBJECT_UNGROUP u8"\uf248"
#define ICON_FA_BRIEFCASE u8"\uf0b1"
#define ICON_FA_OIL_CAN u8"\uf613"
#define ICON_FA_THERMOMETER_FULL u8"\uf2c7"
#define ICON_FA_PLANE u8"\uf072"
#define ICON_FA_HEARTBEAT u8"\uf21e"
#define ICON_FA_UNLINK u8"\uf127"
#define ICON_FA_WINDOW_MAXIMIZE u8"\uf2d0"
#define ICON_FA_HEADPHONES u8"\uf025"
#define ICON_FA_STEP_BACKWARD u8"\uf048"
#define ICON_FA_DRAGON u8"\uf6d5"
#define ICON_FA_MICROPHONE_SLASH u8"\uf131"
#define ICON_FA_USER_PLUS u8"\uf234"
#define ICON_FA_WRENCH u8"\uf0ad"
#define ICON_FA_AMBULANCE u8"\uf0f9"
#define ICON_FA_ETHERNET u8"\uf796"
#define ICON_FA_EGG u8"\uf7fb"
#define ICON_FA_WIND u8"\uf72e"
#define ICON_FA_UNIVERSAL_ACCESS u8"\uf29a"
#define ICON_FA_BURN u8"\uf46a"
#define ICON_FA_HAND_HOLDING_HEART u8"\uf4be"
#define ICON_FA_DICE_ONE u8"\uf525"
#define ICON_FA_KEYBOARD u8"\uf11c"
#define ICON_FA_CHECK_DOUBLE u8"\uf560"
#define ICON_FA_HEADPHONES_ALT u8"\uf58f"
#define ICON_FA_BATTERY_HALF u8"\uf242"
#define ICON_FA_PROJECT_DIAGRAM u8"\uf542"
#define ICON_FA_PRAY u8"\uf683"
#define ICON_FA_GOPURAM u8"\uf664"
#define ICON_FA_GRIN_TEARS u8"\uf588"
#define ICON_FA_SORT_AMOUNT_UP u8"\uf161"
#define ICON_FA_COFFEE u8"\uf0f4"
#define ICON_FA_TABLET_ALT u8"\uf3fa"
#define ICON_FA_GRIN_BEAM_SWEAT u8"\uf583"
#define ICON_FA_HAND_POINT_RIGHT u8"\uf0a4"
#define ICON_FA_MAGIC u8"\uf0d0"
#define ICON_FA_CHARGING_STATION u8"\uf5e7"
#define ICON_FA_GRIN_TONGUE u8"\uf589"
#define ICON_FA_VOLUME_OFF u8"\uf026"
#define ICON_FA_SAD_TEAR u8"\uf5b4"
#define ICON_FA_CARET_RIGHT u8"\uf0da"
#define ICON_FA_BONG u8"\uf55c"
#define ICON_FA_BONE u8"\uf5d7"
#define ICON_FA_ELLIPSIS_V u8"\uf142"
#define ICON_FA_BALANCE_SCALE u8"\uf24e"
#define ICON_FA_FISH u8"\uf578"
#define ICON_FA_SPIDER u8"\uf717"
#define ICON_FA_CAMPGROUND u8"\uf6bb"
#define ICON_FA_CARET_SQUARE_UP u8"\uf151"
#define ICON_FA_RUPEE_SIGN u8"\uf156"
#define ICON_FA_ASSISTIVE_LISTENING_SYSTEMS u8"\uf2a2"
#define ICON_FA_POUND_SIGN u8"\uf154"
#define ICON_FA_ANKH u8"\uf644"
#define ICON_FA_BATTERY_QUARTER u8"\uf243"
#define ICON_FA_HAND_PEACE u8"\uf25b"
#define ICON_FA_SURPRISE u8"\uf5c2"
#define ICON_FA_FILE_PDF u8"\uf1c1"
#define ICON_FA_VIDEO_SLASH u8"\uf4e2"
#define ICON_FA_SUBWAY u8"\uf239"
#define ICON_FA_HORSE u8"\uf6f0"
#define ICON_FA_WINE_BOTTLE u8"\uf72f"
#define ICON_FA_BOOK_READER u8"\uf5da"
#define ICON_FA_COOKIE u8"\uf563"
#define ICON_FA_MONEY_BILL u8"\uf0d6"
#define ICON_FA_CHEVRON_DOWN u8"\uf078"
#define ICON_FA_CAR_SIDE u8"\uf5e4"
#define ICON_FA_FILTER u8"\uf0b0"
#define ICON_FA_FOLDER_OPEN u8"\uf07c"
#define ICON_FA_SIGNATURE u8"\uf5b7"
#define ICON_FA_SNOWBOARDING u8"\uf7ce"
#define ICON_FA_THUMBTACK u8"\uf08d"
#define ICON_FA_DICE_TWO u8"\uf528"
#define ICON_FA_LAUGH_WINK u8"\uf59c"
#define ICON_FA_BREAD_SLICE u8"\uf7ec"
#define ICON_FA_TEXT_HEIGHT u8"\uf034"
#define ICON_FA_VOLUME_MUTE u8"\uf6a9"
#define ICON_FA_VOTE_YEA u8"\uf772"
#define ICON_FA_QRCODE u8"\uf029"
#define ICON_FA_MERCURY u8"\uf223"
#define ICON_FA_USER_ASTRONAUT u8"\uf4fb"
#define ICON_FA_SORT_AMOUNT_DOWN u8"\uf160"
#define ICON_FA_SORT_DOWN u8"\uf0dd"
#define ICON_FA_COMPACT_DISC u8"\uf51f"
#define ICON_FA_PERCENTAGE u8"\uf541"
#define ICON_FA_COMMENT_MEDICAL u8"\uf7f5"
#define ICON_FA_STORE u8"\uf54e"
#define ICON_FA_COMMENT_DOTS u8"\uf4ad"
#define ICON_FA_SMILE_WINK u8"\uf4da"
#define ICON_FA_HOTEL u8"\uf594"
#define ICON_FA_PEPPER_HOT u8"\uf816"
#define ICON_FA_USER_EDIT u8"\uf4ff"
#define ICON_FA_DUMPSTER_FIRE u8"\uf794"
#define ICON_FA_CLOUD_SUN_RAIN u8"\uf743"
#define ICON_FA_GLOBE_ASIA u8"\uf57e"
#define ICON_FA_VIAL u8"\uf492"
#define ICON_FA_STROOPWAFEL u8"\uf551"
#define ICON_FA_DATABASE u8"\uf1c0"
#define ICON_FA_TREE u8"\uf1bb"
#define ICON_FA_SHOWER u8"\uf2cc"
#define ICON_FA_DRUM_STEELPAN u8"\uf56a"
#define ICON_FA_FILE_UPLOAD u8"\uf574"
#define ICON_FA_MEDKIT u8"\uf0fa"
#define ICON_FA_MINUS u8"\uf068"
#define ICON_FA_SHEKEL_SIGN u8"\uf20b"
#define ICON_FA_BELL_SLASH u8"\uf1f6"
#define ICON_FA_MAIL_BULK u8"\uf674"
#define ICON_FA_MOUNTAIN u8"\uf6fc"
#define ICON_FA_COUCH u8"\uf4b8"
#define ICON_FA_CHESS u8"\uf439"
#define ICON_FA_FILE_EXPORT u8"\uf56e"
#define ICON_FA_SIGN_LANGUAGE u8"\uf2a7"
#define ICON_FA_SNOWFLAKE u8"\uf2dc"
#define ICON_FA_PLAY u8"\uf04b"
#define ICON_FA_HEADSET u8"\uf590"
#define ICON_FA_SQUARE_ROOT_ALT u8"\uf698"
#define ICON_FA_CHART_BAR u8"\uf080"
#define ICON_FA_WAVE_SQUARE u8"\uf83e"
#define ICON_FA_CHART_AREA u8"\uf1fe"
#define ICON_FA_EURO_SIGN u8"\uf153"
#define ICON_FA_CHESS_KING u8"\uf43f"
#define ICON_FA_MOBILE u8"\uf10b"
#define ICON_FA_BOX_OPEN u8"\uf49e"
#define ICON_FA_DOG u8"\uf6d3"
#define ICON_FA_FUTBOL u8"\uf1e3"
#define ICON_FA_LIRA_SIGN u8"\uf195"
#define ICON_FA_LIGHTBULB u8"\uf0eb"
#define ICON_FA_BOMB u8"\uf1e2"
#define ICON_FA_MITTEN u8"\uf7b5"
#define ICON_FA_TRUCK_MONSTER u8"\uf63b"
#define ICON_FA_ARROWS_ALT_H u8"\uf337"
#define ICON_FA_CHESS_ROOK u8"\uf447"
#define ICON_FA_FIRE_EXTINGUISHER u8"\uf134"
#define ICON_FA_BOOKMARK u8"\uf02e"
#define ICON_FA_ARROWS_ALT_V u8"\uf338"
#define ICON_FA_ICICLES u8"\uf7ad"
#define ICON_FA_FONT u8"\uf031"
#define ICON_FA_CAMERA_RETRO u8"\uf083"
#define ICON_FA_BLENDER u8"\uf517"
#define ICON_FA_THUMBS_DOWN u8"\uf165"
#define ICON_FA_GAMEPAD u8"\uf11b"
#define ICON_FA_COPYRIGHT u8"\uf1f9"
#define ICON_FA_JEDI u8"\uf669"
#define ICON_FA_HOCKEY_PUCK u8"\uf453"
#define ICON_FA_STOP_CIRCLE u8"\uf28d"
#define ICON_FA_BEZIER_CURVE u8"\uf55b"
#define ICON_FA_FOLDER u8"\uf07b"
#define ICON_FA_RSS u8"\uf09e"
#define ICON_FA_COLUMNS u8"\uf0db"
#define ICON_FA_GLASS_CHEERS u8"\uf79f"
#define ICON_FA_GRIN_WINK u8"\uf58c"
#define ICON_FA_STOP u8"\uf04d"
#define ICON_FA_MONEY_CHECK_ALT u8"\uf53d"
#define ICON_FA_COMPASS u8"\uf14e"
#define ICON_FA_TOOLBOX u8"\uf552"
#define ICON_FA_LIST_OL u8"\uf0cb"
#define ICON_FA_WINE_GLASS u8"\uf4e3"
#define ICON_FA_HORSE_HEAD u8"\uf7ab"
#define ICON_FA_USER_ALT_SLASH u8"\uf4fa"
#define ICON_FA_USER_TAG u8"\uf507"
#define ICON_FA_MICROSCOPE u8"\uf610"
#define ICON_FA_BRUSH u8"\uf55d"
#define ICON_FA_BAN u8"\uf05e"
#define ICON_FA_BARS u8"\uf0c9"
#define ICON_FA_CAR_CRASH u8"\uf5e1"
#define ICON_FA_ARROW_ALT_CIRCLE_DOWN u8"\uf358"
#define ICON_FA_MONEY_BILL_ALT u8"\uf3d1"
#define ICON_FA_JOURNAL_WHILLS u8"\uf66a"
#define ICON_FA_CHALKBOARD_TEACHER u8"\uf51c"
#define ICON_FA_PORTRAIT u8"\uf3e0"
#define ICON_FA_HAMMER u8"\uf6e3"
#define ICON_FA_RETWEET u8"\uf079"
#define ICON_FA_HOURGLASS u8"\uf254"
#define ICON_FA_HAND_PAPER u8"\uf256"
#define ICON_FA_SUBSCRIPT u8"\uf12c"
#define ICON_FA_DONATE u8"\uf4b9"
#define ICON_FA_GLASS_MARTINI_ALT u8"\uf57b"
#define ICON_FA_CODE_BRANCH u8"\uf126"
#define ICON_FA_NOT_EQUAL u8"\uf53e"
#define ICON_FA_MEH u8"\uf11a"
#define ICON_FA_LIST_ALT u8"\uf022"
#define ICON_FA_USER_COG u8"\uf4fe"
#define ICON_FA_PRESCRIPTION u8"\uf5b1"
#define ICON_FA_TABLET u8"\uf10a"
#define ICON_FA_PENCIL_RULER u8"\uf5ae"
#define ICON_FA_CREDIT_CARD u8"\uf09d"
#define ICON_FA_ARCHWAY u8"\uf557"
#define ICON_FA_HARD_HAT u8"\uf807"
#define ICON_FA_MAP_MARKER_ALT u8"\uf3c5"
#define ICON_FA_COG u8"\uf013"
#define ICON_FA_HANUKIAH u8"\uf6e6"
#define ICON_FA_SHUTTLE_VAN u8"\uf5b6"
#define ICON_FA_MONEY_CHECK u8"\uf53c"
#define ICON_FA_BELL u8"\uf0f3"
#define ICON_FA_CALENDAR_DAY u8"\uf783"
#define ICON_FA_TINT_SLASH u8"\uf5c7"
#define ICON_FA_PLANE_DEPARTURE u8"\uf5b0"
#define ICON_FA_USER_CHECK u8"\uf4fc"
#define ICON_FA_CHURCH u8"\uf51d"
#define ICON_FA_SEARCH_MINUS u8"\uf010"
#define ICON_FA_PALLET u8"\uf482"
#define ICON_FA_TINT u8"\uf043"
#define ICON_FA_STAMP u8"\uf5bf"
#define ICON_FA_KAABA u8"\uf66b"
#define ICON_FA_ALIGN_RIGHT u8"\uf038"
#define ICON_FA_QUOTE_RIGHT u8"\uf10e"
#define ICON_FA_BEER u8"\uf0fc"
#define ICON_FA_GRIN_ALT u8"\uf581"
#define ICON_FA_SORT_NUMERIC_DOWN u8"\uf162"
#define ICON_FA_FIRE u8"\uf06d"
#define ICON_FA_FAST_FORWARD u8"\uf050"
#define ICON_FA_MAP_MARKED_ALT u8"\uf5a0"
#define ICON_FA_PENCIL_ALT u8"\uf303"
#define ICON_FA_USERS_COG u8"\uf509"
#define ICON_FA_CARET_SQUARE_DOWN u8"\uf150"
#define ICON_FA_CRUTCH u8"\uf7f7"
#define ICON_FA_OBJECT_GROUP u8"\uf247"
#define ICON_FA_ANCHOR u8"\uf13d"
#define ICON_FA_HAND_POINT_LEFT u8"\uf0a5"
#define ICON_FA_USER_TIMES u8"\uf235"
#define ICON_FA_CALCULATOR u8"\uf1ec"
#define ICON_FA_DIZZY u8"\uf567"
#define ICON_FA_KISS_WINK_HEART u8"\uf598"
#define ICON_FA_FILE_MEDICAL u8"\uf477"
#define ICON_FA_SWIMMING_POOL u8"\uf5c5"
#define ICON_FA_WEIGHT_HANGING u8"\uf5cd"
#define ICON_FA_VR_CARDBOARD u8"\uf729"
#define ICON_FA_FAST_BACKWARD u8"\uf049"
#define ICON_FA_SATELLITE u8"\uf7bf"
#define ICON_FA_USER u8"\uf007"
#define ICON_FA_MINUS_CIRCLE u8"\uf056"
#define ICON_FA_CHESS_PAWN u8"\uf443"
#define ICON_FA_CALENDAR_MINUS u8"\uf272"
#define ICON_FA_CHESS_BOARD u8"\uf43c"
#define ICON_FA_LANDMARK u8"\uf66f"
#define ICON_FA_SWATCHBOOK u8"\uf5c3"
#define ICON_FA_HOTDOG u8"\uf80f"
#define ICON_FA_SNOWMAN u8"\uf7d0"
#define ICON_FA_LAPTOP u8"\uf109"
#define ICON_FA_TORAH u8"\uf6a0"
#define ICON_FA_FROWN_OPEN u8"\uf57a"
#define ICON_FA_USER_LOCK u8"\uf502"
#define ICON_FA_AD u8"\uf641"
#define ICON_FA_USER_CIRCLE u8"\uf2bd"
#define ICON_FA_DIVIDE u8"\uf529"
#define ICON_FA_HANDSHAKE u8"\uf2b5"
#define ICON_FA_CUT u8"\uf0c4"
#define ICON_FA_HIKING u8"\uf6ec"
#define ICON_FA_STREET_VIEW u8"\uf21d"
#define ICON_FA_GREATER_THAN u8"\uf531"
#define ICON_FA_PASTAFARIANISM u8"\uf67b"
#define ICON_FA_MINUS_SQUARE u8"\uf146"
#define ICON_FA_SAVE u8"\uf0c7"
#define ICON_FA_COMMENT_DOLLAR u8"\uf651"
#define ICON_FA_TRASH_ALT u8"\uf2ed"
#define ICON_FA_PUZZLE_PIECE u8"\uf12e"
#define ICON_FA_MENORAH u8"\uf676"
#define ICON_FA_CLOUD_SUN u8"\uf6c4"
#define ICON_FA_USER_FRIENDS u8"\uf500"
#define ICON_FA_FILE_MEDICAL_ALT u8"\uf478"
#define ICON_FA_ARROW_LEFT u8"\uf060"
#define ICON_FA_BOXES u8"\uf468"
#define ICON_FA_THERMOMETER_EMPTY u8"\uf2cb"
#define ICON_FA_EXCLAMATION_TRIANGLE u8"\uf071"
#define ICON_FA_GIFT u8"\uf06b"
#define ICON_FA_COGS u8"\uf085"
#define ICON_FA_SIGNAL u8"\uf012"
#define ICON_FA_SHAPES u8"\uf61f"
#define ICON_FA_CLOUD_RAIN u8"\uf73d"
#define ICON_FA_ELLIPSIS_H u8"\uf141"
#define ICON_FA_LESS_THAN_EQUAL u8"\uf537"
#define ICON_FA_CHEVRON_CIRCLE_LEFT u8"\uf137"
#define ICON_FA_MORTAR_PESTLE u8"\uf5a7"
#define ICON_FA_SITEMAP u8"\uf0e8"
#define ICON_FA_BUS_ALT u8"\uf55e"
#define ICON_FA_ID_BADGE u8"\uf2c1"
#define ICON_FA_FIST_RAISED u8"\uf6de"
#define ICON_FA_BATTERY_FULL u8"\uf240"
#define ICON_FA_CROWN u8"\uf521"
#define ICON_FA_EXCHANGE_ALT u8"\uf362"
#define ICON_FA_SOCKS u8"\uf696"
#define ICON_FA_CASH_REGISTER u8"\uf788"
#define ICON_FA_REDO u8"\uf01e"
#define ICON_FA_EXCLAMATION_CIRCLE u8"\uf06a"
#define ICON_FA_COMMENTS u8"\uf086"
#define ICON_FA_BRIEFCASE_MEDICAL u8"\uf469"
#define ICON_FA_CARET_SQUARE_RIGHT u8"\uf152"
#define ICON_FA_PEN u8"\uf304"
#define ICON_FA_BACKSPACE u8"\uf55a"
#define ICON_FA_SLASH u8"\uf715"
#define ICON_FA_HOT_TUB u8"\uf593"
#define ICON_FA_SUITCASE_ROLLING u8"\uf5c1"
#define ICON_FA_BATTERY_EMPTY u8"\uf244"
#define ICON_FA_GLOBE_AFRICA u8"\uf57c"
#define ICON_FA_SLEIGH u8"\uf7cc"
#define ICON_FA_BOLT u8"\uf0e7"
#define ICON_FA_THERMOMETER_QUARTER u8"\uf2ca"
#define ICON_FA_EYE u8"\uf06e"
#define ICON_FA_TROPHY u8"\uf091"
#define ICON_FA_BRAILLE u8"\uf2a1"
#define ICON_FA_PLUS u8"\uf067"
#define ICON_FA_LIST_UL u8"\uf0ca"
#define ICON_FA_SMOKING_BAN u8"\uf54d"
#define ICON_FA_BATH u8"\uf2cd"
#define ICON_FA_VOLUME_DOWN u8"\uf027"
#define ICON_FA_QUESTION_CIRCLE u8"\uf059"
#define ICON_FA_FILE_CODE u8"\uf1c9"
#define ICON_FA_GAVEL u8"\uf0e3"
#define ICON_FA_CANDY_CANE u8"\uf786"
#define ICON_FA_NETWORK_WIRED u8"\uf6ff"
#define ICON_FA_CARET_SQUARE_LEFT u8"\uf191"
#define ICON_FA_PLANE_ARRIVAL u8"\uf5af"
#define ICON_FA_SHARE_SQUARE u8"\uf14d"
#define ICON_FA_MEDAL u8"\uf5a2"
#define ICON_FA_THERMOMETER_HALF u8"\uf2c9"
#define ICON_FA_QUESTION u8"\uf128"
#define ICON_FA_CAR_BATTERY u8"\uf5df"
#define ICON_FA_DOOR_CLOSED u8"\uf52a"
#define ICON_FA_LEAF u8"\uf06c"
#define ICON_FA_USER_MINUS u8"\uf503"
#define ICON_FA_MUSIC u8"\uf001"
#define ICON_FA_GLOBE_EUROPE u8"\uf7a2"
#define ICON_FA_HOUSE_DAMAGE u8"\uf6f1"
#define ICON_FA_CHEVRON_RIGHT u8"\uf054"
#define ICON_FA_GRIP_HORIZONTAL u8"\uf58d"
#define ICON_FA_DICE_FOUR u8"\uf524"
#define ICON_FA_DEAF u8"\uf2a4"
#define ICON_FA_REGISTERED u8"\uf25d"
#define ICON_FA_WINDOW_CLOSE u8"\uf410"
#define ICON_FA_LINK u8"\uf0c1"
#define ICON_FA_YEN_SIGN u8"\uf157"
#define ICON_FA_ATOM u8"\uf5d2"
#define ICON_FA_LESS_THAN u8"\uf536"
#define ICON_FA_OTTER u8"\uf700"
#define ICON_FA_INFO u8"\uf129"
#define ICON_FA_MARS_DOUBLE u8"\uf227"
#define ICON_FA_CLIPBOARD_CHECK u8"\uf46c"
#define ICON_FA_SKULL u8"\uf54c"
#define ICON_FA_GRIP_LINES u8"\uf7a4"
#define ICON_FA_HOSPITAL_SYMBOL u8"\uf47e"
#define ICON_FA_X_RAY u8"\uf497"
#define ICON_FA_ARROW_UP u8"\uf062"
#define ICON_FA_MONEY_BILL_WAVE u8"\uf53a"
#define ICON_FA_DOT_CIRCLE u8"\uf192"
#define ICON_FA_PAUSE_CIRCLE u8"\uf28b"
#define ICON_FA_IMAGES u8"\uf302"
#define ICON_FA_STAR_HALF u8"\uf089"
#define ICON_FA_SPLOTCH u8"\uf5bc"
#define ICON_FA_STAR_HALF_ALT u8"\uf5c0"
#define ICON_FA_SHIP u8"\uf21a"
#define ICON_FA_BOOK_DEAD u8"\uf6b7"
#define ICON_FA_CHECK u8"\uf00c"
#define ICON_FA_RAINBOW u8"\uf75b"
#define ICON_FA_POWER_OFF u8"\uf011"
#define ICON_FA_LEMON u8"\uf094"
#define ICON_FA_GLOBE_AMERICAS u8"\uf57d"
#define ICON_FA_PEACE u8"\uf67c"
#define ICON_FA_THERMOMETER_THREE_QUARTERS u8"\uf2c8"
#define ICON_FA_WAREHOUSE u8"\uf494"
#define ICON_FA_TRANSGENDER u8"\uf224"
#define ICON_FA_PLUS_SQUARE u8"\uf0fe"
#define ICON_FA_BULLSEYE u8"\uf140"
#define ICON_FA_COOKIE_BITE u8"\uf564"
#define ICON_FA_USERS u8"\uf0c0"
#define ICON_FA_TRANSGENDER_ALT u8"\uf225"
#define ICON_FA_ASTERISK u8"\uf069"
#define ICON_FA_STAR_OF_DAVID u8"\uf69a"
#define ICON_FA_PLUS_CIRCLE u8"\uf055"
#define ICON_FA_CART_ARROW_DOWN u8"\uf218"
#define ICON_FA_FLUSHED u8"\uf579"
#define ICON_FA_STORE_ALT u8"\uf54f"
#define ICON_FA_PEOPLE_CARRY u8"\uf4ce"
#define ICON_FA_LONG_ARROW_ALT_DOWN u8"\uf309"
#define ICON_FA_SAD_CRY u8"\uf5b3"
#define ICON_FA_DIGITAL_TACHOGRAPH u8"\uf566"
#define ICON_FA_FILE_EXCEL u8"\uf1c3"
#define ICON_FA_TEETH u8"\uf62e"
#define ICON_FA_HAND_SCISSORS u8"\uf257"
#define ICON_FA_FILE_INVOICE_DOLLAR u8"\uf571"
#define ICON_FA_STEP_FORWARD u8"\uf051"
#define ICON_FA_BACKWARD u8"\uf04a"
#define ICON_FA_SCROLL u8"\uf70e"
#define ICON_FA_IGLOO u8"\uf7ae"
#define ICON_FA_CODE u8"\uf121"
#define ICON_FA_TRAM u8"\uf7da"
#define ICON_FA_TORII_GATE u8"\uf6a1"
#define ICON_FA_SKIING u8"\uf7c9"
#define ICON_FA_CHAIR u8"\uf6c0"
#define ICON_FA_DUMBBELL u8"\uf44b"
#define ICON_FA_ANGLE_DOUBLE_UP u8"\uf102"
#define ICON_FA_ANGLE_DOUBLE_LEFT u8"\uf100"
#define ICON_FA_MOSQUE u8"\uf678"
#define ICON_FA_COMMENTS_DOLLAR u8"\uf653"
#define ICON_FA_FILE_PRESCRIPTION u8"\uf572"
#define ICON_FA_ANGLE_LEFT u8"\uf104"
#define ICON_FA_ATLAS u8"\uf558"
#define ICON_FA_PIGGY_BANK u8"\uf4d3"
#define ICON_FA_DOLLY_FLATBED u8"\uf474"
#define ICON_FA_RANDOM u8"\uf074"
#define ICON_FA_PEN_ALT u8"\uf305"
#define ICON_FA_PRAYING_HANDS u8"\uf684"
#define ICON_FA_VOLUME_UP u8"\uf028"
#define ICON_FA_CLIPBOARD_LIST u8"\uf46d"
#define ICON_FA_GRIN_STARS u8"\uf587"
#define ICON_FA_FOLDER_MINUS u8"\uf65d"
#define ICON_FA_DEMOCRAT u8"\uf747"
#define ICON_FA_MAGNET u8"\uf076"
#define ICON_FA_VIHARA u8"\uf6a7"
#define ICON_FA_GRIMACE u8"\uf57f"
#define ICON_FA_CHECK_CIRCLE u8"\uf058"
#define ICON_FA_SEARCH_DOLLAR u8"\uf688"
#define ICON_FA_LONG_ARROW_ALT_LEFT u8"\uf30a"
#define ICON_FA_CROW u8"\uf520"
#define ICON_FA_EYE_DROPPER u8"\uf1fb"
#define ICON_FA_CROP u8"\uf125"
#define ICON_FA_SIGN u8"\uf4d9"
#define ICON_FA_ARROW_CIRCLE_DOWN u8"\uf0ab"
#define ICON_FA_VIDEO u8"\uf03d"
#define ICON_FA_DOWNLOAD u8"\uf019"
#define ICON_FA_BOLD u8"\uf032"
#define ICON_FA_CARET_DOWN u8"\uf0d7"
#define ICON_FA_CHEVRON_LEFT u8"\uf053"
#define ICON_FA_HAMSA u8"\uf665"
#define ICON_FA_CART_PLUS u8"\uf217"
#define ICON_FA_CLIPBOARD u8"\uf328"
#define ICON_FA_SHOE_PRINTS u8"\uf54b"
#define ICON_FA_PHONE_SLASH u8"\uf3dd"
#define ICON_FA_REPLY u8"\uf3e5"
#define ICON_FA_HOURGLASS_HALF u8"\uf252"
#define ICON_FA_LONG_ARROW_ALT_UP u8"\uf30c"
#define ICON_FA_CHESS_KNIGHT u8"\uf441"
#define ICON_FA_BARCODE u8"\uf02a"
#define ICON_FA_DRAW_POLYGON u8"\uf5ee"
#define ICON_FA_WATER u8"\uf773"
#define ICON_FA_PAUSE u8"\uf04c"
#define ICON_FA_WINE_GLASS_ALT u8"\uf5ce"
#define ICON_FA_GLASS_WHISKEY u8"\uf7a0"
#define ICON_FA_BOX u8"\uf466"
#define ICON_FA_DIAGNOSES u8"\uf470"
#define ICON_FA_FILE_IMAGE u8"\uf1c5"
#define ICON_FA_ARROW_CIRCLE_RIGHT u8"\uf0a9"
#define ICON_FA_TASKS u8"\uf0ae"
#define ICON_FA_VECTOR_SQUARE u8"\uf5cb"
#define ICON_FA_QUOTE_LEFT u8"\uf10d"
#define ICON_FA_MOBILE_ALT u8"\uf3cd"
#define ICON_FA_USER_SHIELD u8"\uf505"
#define ICON_FA_BLOG u8"\uf781"
#define ICON_FA_MARKER u8"\uf5a1"
#define ICON_FA_USER_TIE u8"\uf508"
#define ICON_FA_TOOLS u8"\uf7d9"
#define ICON_FA_CLOUD u8"\uf0c2"
#define ICON_FA_HAND_HOLDING_USD u8"\uf4c0"
#define ICON_FA_CERTIFICATE u8"\uf0a3"
#define ICON_FA_CLOUD_DOWNLOAD_ALT u8"\uf381"
#define ICON_FA_ANGRY u8"\uf556"
#define ICON_FA_FROG u8"\uf52e"
#define ICON_FA_CAMERA u8"\uf030"
#define ICON_FA_DICE_THREE u8"\uf527"
#define ICON_FA_MEMORY u8"\uf538"
#define ICON_FA_PEN_SQUARE u8"\uf14b"
#define ICON_FA_SORT u8"\uf0dc"
#define ICON_FA_PLUG u8"\uf1e6"
#define ICON_FA_MOUSE_POINTER u8"\uf245"
#define ICON_FA_ENVELOPE u8"\uf0e0"
#define ICON_FA_LAYER_GROUP u8"\uf5fd"
#define ICON_FA_TRAIN u8"\uf238"
#define ICON_FA_BULLHORN u8"\uf0a1"
#define ICON_FA_BABY u8"\uf77c"
#define ICON_FA_CONCIERGE_BELL u8"\uf562"
#define ICON_FA_CIRCLE u8"\uf111"
#define ICON_FA_I_CURSOR u8"\uf246"
#define ICON_FA_CAR u8"\uf1b9"
#define ICON_FA_CAT u8"\uf6be"
#define ICON_FA_WALLET u8"\uf555"
#define ICON_FA_BOOK_MEDICAL u8"\uf7e6"
#define ICON_FA_H_SQUARE u8"\uf0fd"
#define ICON_FA_HEART u8"\uf004"
#define ICON_FA_LOCK_OPEN u8"\uf3c1"
#define ICON_FA_STREAM u8"\uf550"
#define ICON_FA_LOCK u8"\uf023"
#define ICON_FA_CARROT u8"\uf787"
#define ICON_FA_SMILE_BEAM u8"\uf5b8"
#define ICON_FA_USER_NURSE u8"\uf82f"
#define ICON_FA_MICROPHONE_ALT u8"\uf3c9"
#define ICON_FA_SPA u8"\uf5bb"
#define ICON_FA_CHEVRON_CIRCLE_DOWN u8"\uf13a"
#define ICON_FA_FOLDER_PLUS u8"\uf65e"
#define ICON_FA_CLOUD_MEATBALL u8"\uf73b"
#define ICON_FA_BOOK_OPEN u8"\uf518"
#define ICON_FA_MAP u8"\uf279"
#define ICON_FA_COCKTAIL u8"\uf561"
#define ICON_FA_CLONE u8"\uf24d"
#define ICON_FA_ID_CARD_ALT u8"\uf47f"
#define ICON_FA_CHECK_SQUARE u8"\uf14a"
#define ICON_FA_CHART_LINE u8"\uf201"
#define ICON_FA_FILE_ARCHIVE u8"\uf1c6"
#define ICON_FA_DOVE u8"\uf4ba"
#define ICON_FA_MARS_STROKE u8"\uf229"
#define ICON_FA_ENVELOPE_OPEN u8"\uf2b6"
#define ICON_FA_WHEELCHAIR u8"\uf193"
#define ICON_FA_ROBOT u8"\uf544"
#define ICON_FA_UNDO_ALT u8"\uf2ea"
#define ICON_FA_TICKET_ALT u8"\uf3ff"
#define ICON_FA_TRUCK u8"\uf0d1"
#define ICON_FA_WON_SIGN u8"\uf159"
#define ICON_FA_SUPERSCRIPT u8"\uf12b"
#define ICON_FA_TTY u8"\uf1e4"
#define ICON_FA_USER_MD u8"\uf0f0"
#define ICON_FA_ALIGN_LEFT u8"\uf036"
#define ICON_FA_TABLETS u8"\uf490"
#define ICON_FA_MOTORCYCLE u8"\uf21c"
#define ICON_FA_ANGLE_UP u8"\uf106"
#define ICON_FA_BROOM u8"\uf51a"
#define ICON_FA_TOILET_PAPER u8"\uf71e"
#define ICON_FA_DICE_D20 u8"\uf6cf"
#define ICON_FA_LEVEL_DOWN_ALT u8"\uf3be"
#define ICON_FA_PAPERCLIP u8"\uf0c6"
#define ICON_FA_USER_CLOCK u8"\uf4fd"
#define ICON_FA_SORT_ALPHA_UP u8"\uf15e"
#define ICON_FA_AUDIO_DESCRIPTION u8"\uf29e"
#define ICON_FA_FILE_CSV u8"\uf6dd"
#define ICON_FA_FILE_DOWNLOAD u8"\uf56d"
#define ICON_FA_SYNC_ALT u8"\uf2f1"
#define ICON_FA_KISS u8"\uf596"
#define ICON_FA_HANDS u8"\uf4c2"
#define ICON_FA_REPUBLICAN u8"\uf75e"
#define ICON_FA_EDIT u8"\uf044"
#define ICON_FA_UNIVERSITY u8"\uf19c"
#define ICON_FA_KHANDA u8"\uf66d"
#define ICON_FA_GLASSES u8"\uf530"
#define ICON_FA_SQUARE u8"\uf0c8"
#define ICON_FA_GRIN_SQUINT u8"\uf585"
#define ICON_FA_GLOBE u8"\uf0ac"
#define ICON_FA_RECEIPT u8"\uf543"
#define ICON_FA_STRIKETHROUGH u8"\uf0cc"
#define ICON_FA_UNLOCK u8"\uf09c"
#define ICON_FA_DICE_SIX u8"\uf526"
#define ICON_FA_GRIP_VERTICAL u8"\uf58e"
#define ICON_FA_PILLS u8"\uf484"
#define ICON_FA_EXCLAMATION u8"\uf12a"
#define ICON_FA_PERSON_BOOTH u8"\uf756"
#define ICON_FA_CALENDAR_PLUS u8"\uf271"
#define ICON_FA_SMOG u8"\uf75f"
#define ICON_FA_LOCATION_ARROW u8"\uf124"
#define ICON_FA_UMBRELLA u8"\uf0e9"
#define ICON_FA_QURAN u8"\uf687"
#define ICON_FA_UNDO u8"\uf0e2"
#define ICON_FA_DUMPSTER u8"\uf793"
#define ICON_FA_FUNNEL_DOLLAR u8"\uf662"
#define ICON_FA_INDENT u8"\uf03c"
#define ICON_FA_LANGUAGE u8"\uf1ab"
#define ICON_FA_ARROW_ALT_CIRCLE_UP u8"\uf35b"
#define ICON_FA_ROUTE u8"\uf4d7"
#define ICON_FA_USER_ALT u8"\uf406"
#define ICON_FA_TIMES u8"\uf00d"
#define ICON_FA_CLINIC_MEDICAL u8"\uf7f2"
#define ICON_FA_LEVEL_UP_ALT u8"\uf3bf"
#define ICON_FA_BLIND u8"\uf29d"
#define ICON_FA_CHEESE u8"\uf7ef"
#define ICON_FA_PHONE_SQUARE u8"\uf098"
#define ICON_FA_SHOPPING_BASKET u8"\uf291"
#define ICON_FA_ICE_CREAM u8"\uf810"
#define ICON_FA_RING u8"\uf70b"
#define ICON_FA_CITY u8"\uf64f"
#define ICON_FA_TEXT_WIDTH u8"\uf035"
#define ICON_FA_RSS_SQUARE u8"\uf143"
#define ICON_FA_PAINT_BRUSH u8"\uf1fc"
#define ICON_FA_PARACHUTE_BOX u8"\uf4cd"
#define ICON_FA_SIM_CARD u8"\uf7c4"
#define ICON_FA_CLOUD_UPLOAD_ALT u8"\uf382"
#define ICON_FA_SORT_UP u8"\uf0de"
#define ICON_FA_SIGN_OUT_ALT u8"\uf2f5"
#define ICON_FA_USER_NINJA u8"\uf504"
#define ICON_FA_SIGN_IN_ALT u8"\uf2f6"
#define ICON_FA_MUG_HOT u8"\uf7b6"
#define ICON_FA_SHARE_ALT u8"\uf1e0"
#define ICON_FA_CALENDAR_CHECK u8"\uf274"
#define ICON_FA_PEN_FANCY u8"\uf5ac"
#define ICON_FA_BIOHAZARD u8"\uf780"
#define ICON_FA_BED u8"\uf236"
#define ICON_FA_FILE_SIGNATURE u8"\uf573"
#define ICON_FA_TOGGLE_OFF u8"\uf204"
#define ICON_FA_TRAFFIC_LIGHT u8"\uf637"
#define ICON_FA_TRACTOR u8"\uf722"
#define ICON_FA_MEH_ROLLING_EYES u8"\uf5a5"
#define ICON_FA_COMMENT_ALT u8"\uf27a"
#define ICON_FA_RULER_HORIZONTAL u8"\uf547"
#define ICON_FA_PAINT_ROLLER u8"\uf5aa"
#define ICON_FA_HAT_WIZARD u8"\uf6e8"
#define ICON_FA_CALENDAR u8"\uf133"
#define ICON_FA_MICROPHONE u8"\uf130"
#define ICON_FA_FOOTBALL_BALL u8"\uf44e"
#define ICON_FA_ALLERGIES u8"\uf461"
#define ICON_FA_ID_CARD u8"\uf2c2"
#define ICON_FA_REDO_ALT u8"\uf2f9"
#define ICON_FA_PLAY_CIRCLE u8"\uf144"
#define ICON_FA_THERMOMETER u8"\uf491"
#define ICON_FA_DOLLAR_SIGN u8"\uf155"
#define ICON_FA_DUNGEON u8"\uf6d9"
#define ICON_FA_COMPRESS u8"\uf066"
#define ICON_FA_SEARCH_LOCATION u8"\uf689"
#define ICON_FA_BLENDER_PHONE u8"\uf6b6"
#define ICON_FA_ANGLE_RIGHT u8"\uf105"
#define ICON_FA_CHESS_QUEEN u8"\uf445"
#define ICON_FA_PAGER u8"\uf815"
#define ICON_FA_MEH_BLANK u8"\uf5a4"
#define ICON_FA_EJECT u8"\uf052"
#define ICON_FA_HOURGLASS_END u8"\uf253"
#define ICON_FA_TOOTH u8"\uf5c9"
#define ICON_FA_BUSINESS_TIME u8"\uf64a"
#define ICON_FA_PLACE_OF_WORSHIP u8"\uf67f"
#define ICON_FA_MOON u8"\uf186"
#define ICON_FA_GRIN_TONGUE_SQUINT u8"\uf58a"
#define ICON_FA_WALKING u8"\uf554"
#define ICON_FA_SHIPPING_FAST u8"\uf48b"
#define ICON_FA_CARET_LEFT u8"\uf0d9"
#define ICON_FA_DICE u8"\uf522"
#define ICON_FA_RUBLE_SIGN u8"\uf158"
#define ICON_FA_RULER_VERTICAL u8"\uf548"
#define ICON_FA_HAND_POINTER u8"\uf25a"
#define ICON_FA_TAPE u8"\uf4db"
#define ICON_FA_SHOPPING_BAG u8"\uf290"
#define ICON_FA_SKIING_NORDIC u8"\uf7ca"
#define ICON_FA_HIPPO u8"\uf6ed"
#define ICON_FA_CUBE u8"\uf1b2"
#define ICON_FA_CAPSULES u8"\uf46b"
#define ICON_FA_KIWI_BIRD u8"\uf535"
#define ICON_FA_CHEVRON_CIRCLE_UP u8"\uf139"
#define ICON_FA_MARS_STROKE_V u8"\uf22a"
#define ICON_FA_POO_STORM u8"\uf75a"
#define ICON_FA_JOINT u8"\uf595"
#define ICON_FA_MARS_STROKE_H u8"\uf22b"
#define ICON_FA_ADDRESS_BOOK u8"\uf2b9"
#define ICON_FA_PROCEDURES u8"\uf487"
#define ICON_FA_GEM u8"\uf3a5"
#define ICON_FA_RULER_COMBINED u8"\uf546"
#define ICON_FA_BRAIN u8"\uf5dc"
#define ICON_FA_STAR_AND_CRESCENT u8"\uf699"
#define ICON_FA_FIGHTER_JET u8"\uf0fb"
#define ICON_FA_SPACE_SHUTTLE u8"\uf197"
#define ICON_FA_MAP_PIN u8"\uf276"
#define ICON_FA_ALIGN_CENTER u8"\uf037"
#define ICON_FA_SORT_ALPHA_DOWN u8"\uf15d"
#define ICON_FA_PARKING u8"\uf540"
#define ICON_FA_MAP_SIGNS u8"\uf277"
#define ICON_FA_PALETTE u8"\uf53f"
#define ICON_FA_GLASS_MARTINI u8"\uf000"
#define ICON_FA_TIMES_CIRCLE u8"\uf057"
#define ICON_FA_MONUMENT u8"\uf5a6"
#define ICON_FA_GUITAR u8"\uf7a6"
#define ICON_FA_GRIN_BEAM u8"\uf582"
#define ICON_FA_KEY u8"\uf084"
#define ICON_FA_TH_LIST u8"\uf00b"
#define ICON_FA_SHARE_ALT_SQUARE u8"\uf1e1"
#define ICON_FA_DRUM u8"\uf569"
#define ICON_FA_FILE_CONTRACT u8"\uf56c"
#define ICON_FA_RESTROOM u8"\uf7bd"
#define ICON_FA_UNLOCK_ALT u8"\uf13e"
#define ICON_FA_MICROPHONE_ALT_SLASH u8"\uf539"
#define ICON_FA_USER_SECRET u8"\uf21b"
#define ICON_FA_ARROW_RIGHT u8"\uf061"
#define ICON_FA_FILE_VIDEO u8"\uf1c8"
#define ICON_FA_ARROW_ALT_CIRCLE_RIGHT u8"\uf35a"
#define ICON_FA_COMMENT u8"\uf075"
#define ICON_FA_CALENDAR_WEEK u8"\uf784"
#define ICON_FA_USER_GRADUATE u8"\uf501"
#define ICON_FA_HAND_MIDDLE_FINGER u8"\uf806"
#define ICON_FA_POO u8"\uf2fe"
#define ICON_FA_GRIP_LINES_VERTICAL u8"\uf7a5"
#define ICON_FA_TABLE u8"\uf0ce"
#define ICON_FA_POLL u8"\uf681"
#define ICON_FA_CAR_ALT u8"\uf5de"
#define ICON_FA_THUMBS_UP u8"\uf164"
#define ICON_FA_TRADEMARK u8"\uf25c"
#define ICON_FA_CLOUD_MOON u8"\uf6c3"
#define ICON_FA_VIALS u8"\uf493"
#define ICON_FA_FIRST_AID u8"\uf479"
#define ICON_FA_ERASER u8"\uf12d"
#define ICON_FA_MARS u8"\uf222"
#define ICON_FA_STAR_OF_LIFE u8"\uf621"
#define ICON_FA_FEATHER u8"\uf52d"
#define ICON_FA_SQUARE_FULL u8"\uf45c"
#define ICON_FA_DOLLY u8"\uf472"
#define ICON_FA_HOURGLASS_START u8"\uf251"
#define ICON_FA_GRIN_HEARTS u8"\uf584"
#define ICON_FA_CUBES u8"\uf1b3"
#define ICON_FA_HASHTAG u8"\uf292"
#define ICON_FA_SEEDLING u8"\uf4d8"
#define ICON_FA_HAYKAL u8"\uf666"
#define ICON_FA_TSHIRT u8"\uf553"
#define ICON_FA_LAUGH_SQUINT u8"\uf59b"
#define ICON_FA_HDD u8"\uf0a0"
#define ICON_FA_NEWSPAPER u8"\uf1ea"
#define ICON_FA_HOSPITAL_ALT u8"\uf47d"
#define ICON_FA_USER_SLASH u8"\uf506"
#define ICON_FA_FILE_WORD u8"\uf1c2"
#define ICON_FA_ENVELOPE_SQUARE u8"\uf199"
#define ICON_FA_GENDERLESS u8"\uf22d"
#define ICON_FA_DICE_FIVE u8"\uf523"
#define ICON_FA_SYNAGOGUE u8"\uf69b"
#define ICON_FA_PAW u8"\uf1b0"
#define ICON_FA_RADIATION u8"\uf7b9"
#define ICON_FA_CROSS u8"\uf654"
#define ICON_FA_ARCHIVE u8"\uf187"
#define ICON_FA_PHONE_VOLUME u8"\uf2a0"
#define ICON_FA_SOLAR_PANEL u8"\uf5ba"
#define ICON_FA_INFINITY u8"\uf534"
#define ICON_FA_HAND_POINT_DOWN u8"\uf0a7"
#define ICON_FA_MAP_MARKER u8"\uf041"
#define ICON_FA_CALENDAR_ALT u8"\uf073"
#define ICON_FA_AMERICAN_SIGN_LANGUAGE_INTERPRETING u8"\uf2a3"
#define ICON_FA_BINOCULARS u8"\uf1e5"
#define ICON_FA_STICKY_NOTE u8"\uf249"
#define ICON_FA_RUNNING u8"\uf70c"
#define ICON_FA_PEN_NIB u8"\uf5ad"
#define ICON_FA_MAP_MARKED u8"\uf59f"
#define ICON_FA_EXPAND u8"\uf065"
#define ICON_FA_TRUCK_PICKUP u8"\uf63c"
#define ICON_FA_HOLLY_BERRY u8"\uf7aa"
#define ICON_FA_PRESCRIPTION_BOTTLE u8"\uf485"
#define ICON_FA_LAPTOP_CODE u8"\uf5fc"
#define ICON_FA_GOLF_BALL u8"\uf450"
#define ICON_FA_SKULL_CROSSBONES u8"\uf714"
#define ICON_FA_TAXI u8"\uf1ba"
#define ICON_FA_ROCKET u8"\uf135"
#define ICON_FA_YIN_YANG u8"\uf6ad"
#define ICON_FA_FINGERPRINT u8"\uf577"
#define ICON_FA_ARROWS_ALT u8"\uf0b2"
#define ICON_FA_UNDERLINE u8"\uf0cd"
#define ICON_FA_ARROW_CIRCLE_UP u8"\uf0aa"
#define ICON_FA_BASKETBALL_BALL u8"\uf434"
#define ICON_FA_DESKTOP u8"\uf108"
#define ICON_FA_SPINNER u8"\uf110"
#define ICON_FA_TOGGLE_ON u8"\uf205"
#define ICON_FA_STOPWATCH u8"\uf2f2"
#define ICON_FA_ARROW_ALT_CIRCLE_LEFT u8"\uf359"
#define ICON_FA_GAS_PUMP u8"\uf52f"
#define ICON_FA_EXTERNAL_LINK_ALT u8"\uf35d"
#define ICON_FA_FROWN u8"\uf119"
#define ICON_FA_RULER u8"\uf545"
#define ICON_FA_FLAG_USA u8"\uf74d"
#define ICON_FA_GRIN u8"\uf580"
#define ICON_FA_THEATER_MASKS u8"\uf630"
#define ICON_FA_ARROW_CIRCLE_LEFT u8"\uf0a8"
#define ICON_FA_HIGHLIGHTER u8"\uf591"
#define ICON_FA_POLL_H u8"\uf682"
#define ICON_FA_SERVER u8"\uf233"
#define ICON_FA_TRASH_RESTORE u8"\uf829"
#define ICON_FA_SPRAY_CAN u8"\uf5bd"
#define ICON_FA_BOWLING_BALL u8"\uf436"
#define ICON_FA_LAUGH u8"\uf599"
#define ICON_FA_TERMINAL u8"\uf120"
#define ICON_FA_WINDOW_MINIMIZE u8"\uf2d1"
#define ICON_FA_HOME u8"\uf015"
#define ICON_FA_UTENSIL_SPOON u8"\uf2e5"
#define ICON_FA_QUIDDITCH u8"\uf458"
#define ICON_FA_APPLE_ALT u8"\uf5d1"
#define ICON_FA_UMBRELLA_BEACH u8"\uf5ca"
#define ICON_FA_CANNABIS u8"\uf55f"
#define ICON_FA_LAUGH_BEAM u8"\uf59a"
#define ICON_FA_TEETH_OPEN u8"\uf62f"
#define ICON_FA_DRUMSTICK_BITE u8"\uf6d7"
#define ICON_FA_CHART_PIE u8"\uf200"
#define ICON_FA_SD_CARD u8"\uf7c2"
#define ICON_FA_HANDS_HELPING u8"\uf4c4"
#define ICON_FA_PASTE u8"\uf0ea"
#define ICON_FA_OM u8"\uf679"
#define ICON_FA_LUGGAGE_CART u8"\uf59d"
#define ICON_FA_INDUSTRY u8"\uf275"
#define ICON_FA_SWIMMER u8"\uf5c4"
#define ICON_FA_RADIATION_ALT u8"\uf7ba"
#define ICON_FA_COMPRESS_ARROWS_ALT u8"\uf78c"
#define ICON_FA_ROAD u8"\uf018"
#define ICON_FA_IMAGE u8"\uf03e"
#define ICON_FA_CHILD u8"\uf1ae"
#define ICON_FA_ANGLE_DOUBLE_RIGHT u8"\uf101"
#define ICON_FA_CLOUD_MOON_RAIN u8"\uf73c"
#define ICON_FA_DOOR_OPEN u8"\uf52b"
#define ICON_FA_GRIN_TONGUE_WINK u8"\uf58b"
#define ICON_FA_REPLY_ALL u8"\uf122"
#define ICON_FA_TEMPERATURE_LOW u8"\uf76b"
#define ICON_FA_INBOX u8"\uf01c"
#define ICON_FA_FEMALE u8"\uf182"
#define ICON_FA_SYRINGE u8"\uf48e"
#define ICON_FA_CIRCLE_NOTCH u8"\uf1ce"
#define ICON_FA_WEIGHT u8"\uf496"
#define ICON_FA_SNOWPLOW u8"\uf7d2"
#define ICON_FA_TABLE_TENNIS u8"\uf45d"
#define ICON_FA_LOW_VISION u8"\uf2a8"
#define ICON_FA_FILE_IMPORT u8"\uf56f"
#define ICON_FA_ITALIC u8"\uf033"
#define ICON_FA_CLOSED_CAPTIONING u8"\uf20a"
#define ICON_FA_CHALKBOARD u8"\uf51b"
#define ICON_FA_BUILDING u8"\uf1ad"
#define ICON_FA_TACHOMETER_ALT u8"\uf3fd"
#define ICON_FA_BUS u8"\uf207"
#define ICON_FA_ANGLE_DOWN u8"\uf107"
#define ICON_FA_HAND_ROCK u8"\uf255"
#define ICON_FA_FORWARD u8"\uf04e"
#define ICON_FA_HELICOPTER u8"\uf533"
#define ICON_FA_PODCAST u8"\uf2ce"
#define ICON_FA_TRUCK_MOVING u8"\uf4df"
#define ICON_FA_BUG u8"\uf188"
#define ICON_FA_SHIELD_ALT u8"\uf3ed"
#define ICON_FA_FILL_DRIP u8"\uf576"
#define ICON_FA_COMMENT_SLASH u8"\uf4b3"
#define ICON_FA_SUITCASE u8"\uf0f2"
#define ICON_FA_SKATING u8"\uf7c5"
#define ICON_FA_TOILET u8"\uf7d8"
#define ICON_FA_ENVELOPE_OPEN_TEXT u8"\uf658"
#define ICON_FA_HAND_HOLDING u8"\uf4bd"
#define ICON_FA_VENUS_MARS u8"\uf228"
#define ICON_FA_HEART_BROKEN u8"\uf7a9"
#define ICON_FA_UTENSILS u8"\uf2e7"
#define ICON_FA_TH_LARGE u8"\uf009"
#define ICON_FA_AT u8"\uf1fa"
#define ICON_FA_FILE u8"\uf15b"
#define ICON_FA_TENGE u8"\uf7d7"
#define ICON_FA_FLAG_CHECKERED u8"\uf11e"
#define ICON_FA_FILM u8"\uf008"
#define ICON_FA_FILL u8"\uf575"
#define ICON_FA_GRIN_SQUINT_TEARS u8"\uf586"
#define ICON_FA_PERCENT u8"\uf295"
#define ICON_FA_BOOK u8"\uf02d"
#define ICON_FA_METEOR u8"\uf753"
#define ICON_FA_TRASH u8"\uf1f8"
#define ICON_FA_FILE_AUDIO u8"\uf1c7"
#define ICON_FA_SATELLITE_DISH u8"\uf7c0"
#define ICON_FA_POOP u8"\uf619"
#define ICON_FA_STAR u8"\uf005"
#define ICON_FA_GIFTS u8"\uf79c"
#define ICON_FA_GHOST u8"\uf6e2"
#define ICON_FA_PRESCRIPTION_BOTTLE_ALT u8"\uf486"
#define ICON_FA_MONEY_BILL_WAVE_ALT u8"\uf53b"
#define ICON_FA_NEUTER u8"\uf22c"
#define ICON_FA_BAND_AID u8"\uf462"
#define ICON_FA_WIFI u8"\uf1eb"
#define ICON_FA_MASK u8"\uf6fa"
#define ICON_FA_VENUS_DOUBLE u8"\uf226"
#define ICON_FA_CHEVRON_UP u8"\uf077"
#define ICON_FA_HAND_SPOCK u8"\uf259"
#define ICON_FA_HAND_POINT_UP u8"\uf0a6"
```

`UnrealFinderTool/ImControl.h`:

```h
#pragma once
#include "ImGUI/imgui.h"
#include <vector>

#define TOOL_VERSION "3.1.0"
#define TOOL_VERSION_TITLE "Atomic edition"

#define IM_COL4(R, G, B, A) ImVec4((float)R / 255.f, (float)G / 255.f, (float)B / 255.f, (float)A / 255.f)

#define ENABLE_DISABLE_WIDGET(uiCode, disabledBool) { static bool disCheck = false; if (disabledBool) { disCheck = true; ui::PushItemFlag(ImGuiItemFlags_Disabled, true); ui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.5f); } uiCode; if (disCheck && disabledBool) { ImGui::PopItemFlag(); ImGui::PopStyleVar(); disCheck = false; } }
#define ENABLE_DISABLE_WIDGET_IF(uiCode, disabledBool, body) { static bool disCheck = false; if (disabledBool) { disCheck = true; ui::PushItemFlag(ImGuiItemFlags_Disabled, true); ui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.5f);} if(uiCode) body if (disCheck && disabledBool) { ImGui::PopItemFlag(); ImGui::PopStyleVar(); disCheck = false; } }

// => Main Options Section
inline bool process_id_disabled = false;
inline bool process_detector_disabled = false;
inline int process_id;
inline bool process_controller_toggles[] = { false };

inline bool use_kernal_disabled = false;
inline bool use_kernal;

inline bool g_objects_disabled = false;
inline bool g_names_disabled = false;

inline bool game_ue_disabled = false;
inline std::string game_ue_version = "0.0.0";
inline size_t ue_selected_version;
inline std::vector<std::string> unreal_versions;
inline std::string window_title;
// => Main Options Section

// => Popup
inline bool popup_not_valid_process = false;
inline bool popup_not_valid_gnames = false;
inline bool popup_not_valid_gobjects = false;
// => Popup

// => Tabs
inline int cur_tap_id = 0;
// => Tabs

// => GObjects, GNames, Class
inline bool g_objects_find_disabled = false;
inline uintptr_t g_objects_address;
inline char g_objects_buf[18] = { 0 };
inline std::vector<std::string> g_obj_listbox_items;
inline int g_obj_listbox_item_current = 0;

inline bool g_names_find_disabled = false;
inline uintptr_t g_names_address;
inline char g_names_buf[18] = { 0 };
inline std::vector<std::string> g_names_listbox_items;
inline int g_names_listbox_item_current = 0;

inline bool class_find_disabled = false;
inline bool class_find_input_disabled = false;
inline char class_find_buf[90] = { 0 };
inline std::vector<std::string> class_listbox_items;
inline int class_listbox_item_current = 0;
// => GObjects, GNames, Class

// => Instance Logger
inline bool il_start_disabled = false;
inline size_t il_objects_count = 0;
inline size_t il_names_count = 0;
inline std::string il_state = "Ready ..!!";
// => Instance Logger

// => Sdk Generator
inline bool sg_start_disabled = false;
inline bool sg_finished = false;
inline std::tm sg_finished_time;

inline size_t sg_objects_count = 0;
inline size_t sg_names_count = 0;
inline size_t sg_packages_count = 0;
inline size_t sg_packages_done_count = 0;

inline bool sg_type_disabled = false;
inline std::vector<std::string> sg_type_items = { "Internal", "External" };
inline int sg_type_item_current = 0;

inline bool sg_game_name_disabled = false;
inline char sg_game_name_buf[30] = { 0 };

inline bool sg_game_version_disabled = false;
inline int sg_game_version[3] = { 1, 0, 0 };

inline std::string sg_state = "Ready ..!!";

inline std::vector<std::string> sg_packages_items;
inline int sg_packages_item_current = 0;
// => Sdk Generator

// => Help Functions
static void DisabledAll()
{
	process_id_disabled = true;
	process_detector_disabled = true;
	use_kernal_disabled = true;

	g_objects_disabled = true;
	g_names_disabled = true;
	class_find_disabled = true;
	class_find_input_disabled = true;

	il_start_disabled = true;
	sg_start_disabled = true;
	sg_type_disabled = true;
	sg_game_name_disabled = true;
	sg_game_version_disabled = true;
}

static void EnabledAll()
{
	g_objects_find_disabled = false;
	g_names_find_disabled = false;
	class_find_disabled = false;
	class_find_input_disabled = false;

	il_start_disabled = false;
	sg_start_disabled = false;

	sg_type_disabled = false;
	sg_game_name_disabled = false;
	sg_game_version_disabled = false;
}

static bool VectorGetter(void* vec, const int idx, const char** out_text)
{
	auto& vector = *static_cast<std::vector<std::string>*>(vec);
	if (idx < 0 || idx >= static_cast<int>(vector.size())) { return false; }
	*out_text = vector.at(idx).c_str();
	return true;
};

static void HelpMarker(const char* desc)
{
	ui::TextDisabled("(?)");
	if (ui::IsItemHovered())
	{
		ui::BeginTooltip();
		ui::PushTextWrapPos(ui::GetFontSize() * 35.0f);
		ui::TextUnformatted(desc);
		ui::PopTextWrapPos();
		ui::EndTooltip();
	}
}

static void WarningPopup(const std::string& title, const std::string& message, bool& opener, const std::function<void()> okCallBack = nullptr)
{
	std::string id = title + "##" + message;

	if (opener)
		ui::OpenPopup(id.c_str());

	if (ui::BeginPopupModal(id.c_str(), nullptr, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoMove))
	{
		ui::Text("%s", message.c_str());
		ui::Separator();

		if (ui::Button("Ok", ImVec2(200, 0)))
		{
			if (okCallBack)
				okCallBack();
			ui::CloseCurrentPopup();
			opener = false;
		}
		ui::SetItemDefaultFocus();
		ui::EndPopup();

	}
}

#pragma region Custoum Controls
namespace ImGui
{
	inline bool ListBoxA(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, const int items_count, const int height_in_items, const bool auto_scroll)
	{
		if (!ListBoxHeader(label, items_count, height_in_items))
			return false;

		if (auto_scroll)
		{
			SetScrollY(99999999.f);
		}

		// Assume all items have even height (= 1 line of text). If you need items of different or variable sizes you can create a custom version of ListBox() in your code without using the clipper.
		ImGuiContext& g = *GImGui;
		bool value_changed = false;
		ImGuiListClipper clipper(items_count, GetTextLineHeightWithSpacing()); // We know exactly our line height here so we pass it as a minor optimization, but generally you don't need to.
		while (clipper.Step())
			for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)
			{
				const bool item_selected = (i == *current_item);
				const char* item_text;
				if (!items_getter(data, i, &item_text))
					item_text = "*Unknown item*";

				PushID(i);
				if (Selectable(item_text, item_selected))
				{
					*current_item = i;
					value_changed = true;
				}
				if (item_selected)
					SetItemDefaultFocus();
				PopID();
			}
		ListBoxFooter();
		if (value_changed)
			MarkItemEdited(g.CurrentWindow->DC.LastItemId);

		return value_changed;
	}
}

#pragma endregion

```

`UnrealFinderTool/ImGUI/imconfig.h`:

```h
//-----------------------------------------------------------------------------
// COMPILE-TIME OPTIONS FOR DEAR IMGUI
// Runtime options (clipboard callbacks, enabling various features, etc.) can generally be set via the ImGuiIO structure.
// You can use ImGui::SetAllocatorFunctions() before calling ImGui::CreateContext() to rewire memory allocation functions.
//-----------------------------------------------------------------------------
// A) You may edit imconfig.h (and not overwrite it when updating imgui, or maintain a patch/branch with your modifications to imconfig.h)
// B) or add configuration directives in your own file and compile with #define IMGUI_USER_CONFIG "myfilename.h"
// If you do so you need to make sure that configuration settings are defined consistently _everywhere_ dear imgui is used, which include
// the imgui*.cpp files but also _any_ of your code that uses imgui. This is because some compile-time options have an affect on data structures.
// Defining those options in imconfig.h will ensure every compilation unit gets to see the same data structure layouts.
// Call IMGUI_CHECKVERSION() from your .cpp files to verify that the data structures your files are using are matching the ones imgui.cpp is using.
//-----------------------------------------------------------------------------

#pragma once

//---- Define assertion handler. Defaults to calling assert().
//#define IM_ASSERT(_EXPR)  MyAssert(_EXPR)
//#define IM_ASSERT(_EXPR)  ((void)(_EXPR))     // Disable asserts

//---- Define attributes of all API symbols declarations, e.g. for DLL under Windows.
//#define IMGUI_API __declspec( dllexport )
//#define IMGUI_API __declspec( dllimport )

//---- Don't define obsolete functions/enums names. Consider enabling from time to time after updating to avoid using soon-to-be obsolete function/names.
//#define IMGUI_DISABLE_OBSOLETE_FUNCTIONS

//---- Don't implement demo windows functionality (ShowDemoWindow()/ShowStyleEditor()/ShowUserGuide() methods will be empty)
//---- It is very strongly recommended to NOT disable the demo windows during development. Please read the comments in imgui_demo.cpp.
//#define IMGUI_DISABLE_DEMO_WINDOWS

//---- Don't implement some functions to reduce linkage requirements.
//#define IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS   // [Win32] Don't implement default clipboard handler. Won't use and link with OpenClipboard/GetClipboardData/CloseClipboard etc.
//#define IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS         // [Win32] Don't implement default IME handler. Won't use and link with ImmGetContext/ImmSetCompositionWindow.
//#define IMGUI_DISABLE_WIN32_FUNCTIONS                     // [Win32] Won't use and link with any Win32 function.
//#define IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS             // Don't implement ImFormatString/ImFormatStringV so you can implement them yourself if you don't want to link with vsnprintf.
//#define IMGUI_DISABLE_MATH_FUNCTIONS                      // Don't implement ImFabs/ImSqrt/ImPow/ImFmod/ImCos/ImSin/ImAcos/ImAtan2 wrapper so you can implement them yourself. Declare your prototypes in imconfig.h.
//#define IMGUI_DISABLE_DEFAULT_ALLOCATORS                  // Don't implement default allocators calling malloc()/free() to avoid linking with them. You will need to call ImGui::SetAllocatorFunctions().

//---- Include imgui_user.h at the end of imgui.h as a convenience
//#define IMGUI_INCLUDE_IMGUI_USER_H

//---- Pack colors to BGRA8 instead of RGBA8 (to avoid converting from one to another)
//#define IMGUI_USE_BGRA_PACKED_COLOR

//---- Avoid multiple STB libraries implementations, or redefine path/filenames to prioritize another version
// By default the embedded implementations are declared static and not available outside of imgui cpp files.
//#define IMGUI_STB_TRUETYPE_FILENAME   "my_folder/stb_truetype.h"
//#define IMGUI_STB_RECT_PACK_FILENAME  "my_folder/stb_rect_pack.h"
//#define IMGUI_DISABLE_STB_TRUETYPE_IMPLEMENTATION
//#define IMGUI_DISABLE_STB_RECT_PACK_IMPLEMENTATION

//---- Define constructor and implicit cast operators to convert back<>forth between your math types and ImVec2/ImVec4.
// This will be inlined as part of ImVec2 and ImVec4 class declarations.
/*
#define IM_VEC2_CLASS_EXTRA                                                 \
        ImVec2(const MyVec2& f) { x = f.x; y = f.y; }                       \
        operator MyVec2() const { return MyVec2(x,y); }

#define IM_VEC4_CLASS_EXTRA                                                 \
        ImVec4(const MyVec4& f) { x = f.x; y = f.y; z = f.z; w = f.w; }     \
        operator MyVec4() const { return MyVec4(x,y,z,w); }
*/

//---- Use 32-bit vertex indices (default is 16-bit) to allow meshes with more than 64K vertices. Render function needs to support it.
//#define ImDrawIdx unsigned int

//---- Tip: You can add extra functions within the ImGui:: namespace, here or in your own headers files.
/*
namespace ImGui
{
    void MyFunction(const char* name, const MyMatrix44& v);
}
*/

```

`UnrealFinderTool/ImGUI/imgui.cpp`:

```cpp
// dear imgui, v1.70
// (main code and documentation)

// Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp for demo code.
// Newcomers, read 'Programmer guide' below for notes on how to setup Dear ImGui in your codebase.
// Get latest version at https://github.com/ocornut/imgui
// Releases change-log at https://github.com/ocornut/imgui/releases
// Technical Support for Getting Started https://discourse.dearimgui.org/c/getting-started
// Gallery (please post your screenshots/video there!): https://github.com/ocornut/imgui/issues/1269

// Developed by Omar Cornut and every direct or indirect contributors to the GitHub.
// See LICENSE.txt for copyright and licensing details (standard MIT License).
// This library is free but I need your support to sustain development and maintenance.
// Businesses: you can support continued maintenance and development via support contracts or sponsoring, see docs/README.
// Individuals: you can support continued maintenance and development via donations or Patreon https://www.patreon.com/imgui.

// It is recommended that you don't modify imgui.cpp! It will become difficult for you to update the library.
// Note that 'ImGui::' being a namespace, you can add functions into the namespace from your own source files, without
// modifying imgui.h or imgui.cpp. You may include imgui_internal.h to access internal data structures, but it doesn't
// come with any guarantee of forward compatibility. Discussing your changes on the GitHub Issue Tracker may lead you
// to a better solution or official support for them.

/*

Index of this file:

DOCUMENTATION

- MISSION STATEMENT
- END-USER GUIDE
- PROGRAMMER GUIDE (read me!)
  - Read first.
  - How to update to a newer version of Dear ImGui.
  - Getting started with integrating Dear ImGui in your code/engine.
  - This is how a simple application may look like (2 variations).
  - This is how a simple rendering function may look like.
  - Using gamepad/keyboard navigation controls.
- API BREAKING CHANGES (read me when you update!)
- FREQUENTLY ASKED QUESTIONS (FAQ), TIPS
  - Where is the documentation?
  - Which version should I get?
  - Who uses Dear ImGui?
  - Why the odd dual naming, "Dear ImGui" vs "ImGui"?
  - How can I tell whether to dispatch mouse/keyboard to imgui or to my application?
  - How can I display an image? What is ImTextureID, how does it works?
  - Why are multiple widgets reacting when I interact with a single one? How can I have
    multiple widgets with the same label or with an empty label? A primer on labels and the ID Stack...
  - How can I use my own math types instead of ImVec2/ImVec4?
  - How can I load a different font than the default?
  - How can I easily use icons in my application?
  - How can I load multiple fonts?
  - How can I display and input non-latin characters such as Chinese, Japanese, Korean, Cyrillic?
  - How can I interact with standard C++ types (such as std::string and std::vector)?
  - How can I use the drawing facilities without an ImGui window? (using ImDrawList API)
  - How can I use Dear ImGui on a platform that doesn't have a mouse or a keyboard? (input share, remoting, gamepad)
  - I integrated Dear ImGui in my engine and the text or lines are blurry..
  - I integrated Dear ImGui in my engine and some elements are clipping or disappearing when I move windows around..
  - How can I help?

CODE
(search for "[SECTION]" in the code to find them)

// [SECTION] FORWARD DECLARATIONS
// [SECTION] CONTEXT AND MEMORY ALLOCATORS
// [SECTION] MAIN USER FACING STRUCTURES (ImGuiStyle, ImGuiIO)
// [SECTION] MISC HELPERS/UTILITIES (Maths, String, Format, Hash, File functions)
// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)
// [SECTION] MISC HELPERS/UTILITIES (Color functions)
// [SECTION] ImGuiStorage
// [SECTION] ImGuiTextFilter
// [SECTION] ImGuiTextBuffer
// [SECTION] ImGuiListClipper
// [SECTION] RENDER HELPERS
// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)
// [SECTION] TOOLTIPS
// [SECTION] POPUPS
// [SECTION] KEYBOARD/GAMEPAD NAVIGATION
// [SECTION] COLUMNS
// [SECTION] DRAG AND DROP
// [SECTION] LOGGING/CAPTURING
// [SECTION] SETTINGS
// [SECTION] PLATFORM DEPENDENT HELPERS
// [SECTION] METRICS/DEBUG WINDOW

*/

//-----------------------------------------------------------------------------
// DOCUMENTATION
//-----------------------------------------------------------------------------

/*

 MISSION STATEMENT
 =================

 - Easy to use to create code-driven and data-driven tools.
 - Easy to use to create ad hoc short-lived tools and long-lived, more elaborate tools.
 - Easy to hack and improve.
 - Minimize screen real-estate usage.
 - Minimize setup and maintenance.
 - Minimize state storage on user side.
 - Portable, minimize dependencies, run on target (consoles, phones, etc.).
 - Efficient runtime and memory consumption (NB- we do allocate when "growing" content e.g. creating a window,.
   opening a tree node for the first time, etc. but a typical frame should not allocate anything).

 Designed for developers and content-creators, not the typical end-user! Some of the weaknesses includes:
 - Doesn't look fancy, doesn't animate.
 - Limited layout features, intricate layouts are typically crafted in code.


 END-USER GUIDE
 ==============

 - Double-click on title bar to collapse window.
 - Click upper right corner to close a window, available when 'bool* p_open' is passed to ImGui::Begin().
 - Click and drag on lower right corner to resize window (double-click to auto fit window to its contents).
 - Click and drag on any empty space to move window.
 - TAB/SHIFT+TAB to cycle through keyboard editable fields.
 - CTRL+Click on a slider or drag box to input value as text.
 - Use mouse wheel to scroll.
 - Text editor:
   - Hold SHIFT or use mouse to select text.
   - CTRL+Left/Right to word jump.
   - CTRL+Shift+Left/Right to select words.
   - CTRL+A our Double-Click to select all.
   - CTRL+X,CTRL+C,CTRL+V to use OS clipboard/
   - CTRL+Z,CTRL+Y to undo/redo.
   - ESCAPE to revert text to its original value.
   - You can apply arithmetic operators +,*,/ on numerical values. Use +- to subtract (because - would set a negative value!)
   - Controls are automatically adjusted for OSX to match standard OSX text editing operations.
 - General Keyboard controls: enable with ImGuiConfigFlags_NavEnableKeyboard.
 - General Gamepad controls: enable with ImGuiConfigFlags_NavEnableGamepad. See suggested mappings in imgui.h ImGuiNavInput_ + download PNG/PSD at http://goo.gl/9LgVZW


 PROGRAMMER GUIDE
 ================

 READ FIRST:

 - Read the FAQ below this section!
 - Your code creates the UI, if your code doesn't run the UI is gone! The UI can be highly dynamic, there are no construction
   or destruction steps, less superfluous data retention on your side, less state duplication, less state synchronization, less bugs.
 - Call and read ImGui::ShowDemoWindow() for demo code demonstrating most features.
 - The library is designed to be built from sources. Avoid pre-compiled binaries and packaged versions. See imconfig.h to configure your build.
 - Dear ImGui is an implementation of the IMGUI paradigm (immediate-mode graphical user interface, a term coined by Casey Muratori).
   You can learn about IMGUI principles at http://www.johno.se/book/imgui.html, http://mollyrocket.com/861 & more links docs/README.md.
 - Dear ImGui is a "single pass" rasterizing implementation of the IMGUI paradigm, aimed at ease of use and high-performances.
   For every application frame your UI code will be called only once. This is in contrast to e.g. Unity's own implementation of an IMGUI,
   where the UI code is called multiple times ("multiple passes") from a single entry point. There are pros and cons to both approaches.
 - Our origin are on the top-left. In axis aligned bounding boxes, Min = top-left, Max = bottom-right.
 - This codebase is also optimized to yield decent performances with typical "Debug" builds settings.
 - Please make sure you have asserts enabled (IM_ASSERT redirects to assert() by default, but can be redirected).
   If you get an assert, read the messages and comments around the assert.
 - C++: this is a very C-ish codebase: we don't rely on C++11, we don't include any C++ headers, and ImGui:: is a namespace.
 - C++: ImVec2/ImVec4 do not expose math operators by default, because it is expected that you use your own math types.
   See FAQ "How can I use my own math types instead of ImVec2/ImVec4?" for details about setting up imconfig.h for that.
   However, imgui_internal.h can optionally export math operators for ImVec2/ImVec4, which we use in this codebase.
 - C++: pay attention that ImVector<> manipulates plain-old-data and does not honor construction/destruction (avoid using it in your code!).

 HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI:

 - Overwrite all the sources files except for imconfig.h (if you have made modification to your copy of imconfig.h)
 - Or maintain your own branch where you have imconfig.h modified.
 - Read the "API BREAKING CHANGES" section (below). This is where we list occasional API breaking changes.
   If a function/type has been renamed / or marked obsolete, try to fix the name in your code before it is permanently removed
   from the public API. If you have a problem with a missing function/symbols, search for its name in the code, there will
   likely be a comment about it. Please report any issue to the GitHub page!
 - Try to keep your copy of dear imgui reasonably up to date.

 GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE:

 - Run and study the examples and demo in imgui_demo.cpp to get acquainted with the library.
 - Add the Dear ImGui source files to your projects or using your preferred build system.
   It is recommended you build and statically link the .cpp files as part of your project and not as shared library (DLL).
 - You can later customize the imconfig.h file to tweak some compile-time behavior, such as integrating imgui types with your own maths types.
 - When using Dear ImGui, your programming IDE is your friend: follow the declaration of variables, functions and types to find comments about them.
 - Dear ImGui never touches or knows about your GPU state. The only function that knows about GPU is the draw function that you provide.
   Effectively it means you can create widgets at any time in your code, regardless of considerations of being in "update" vs "render"
   phases of your own application. All rendering informatioe are stored into command-lists that you will retrieve after calling ImGui::Render().
 - Refer to the bindings and demo applications in the examples/ folder for instruction on how to setup your code.
 - If you are running over a standard OS with a common graphics API, you should be able to use unmodified imgui_impl_*** files from the examples/ folder.

 HOW A SIMPLE APPLICATION MAY LOOK LIKE:
 EXHIBIT 1: USING THE EXAMPLE BINDINGS (imgui_impl_XXX.cpp files from the examples/ folder).

     // Application init: create a dear imgui context, setup some options, load fonts
     ImGui::CreateContext();
     ImGuiIO& io = ImGui::GetIO();
     // TODO: Set optional io.ConfigFlags values, e.g. 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard' to enable keyboard controls.
     // TODO: Fill optional fields of the io structure later.
     // TODO: Load TTF/OTF fonts if you don't want to use the default font.

     // Initialize helper Platform and Renderer bindings (here we are using imgui_impl_win32 and imgui_impl_dx11)
     ImGui_ImplWin32_Init(hwnd);
     ImGui_ImplDX11_Init(g_pd3dDevice, g_pd3dDeviceContext);

     // Application main loop
     while (true)
     {
         // Feed inputs to dear imgui, start new frame
         ImGui_ImplDX11_NewFrame();
         ImGui_ImplWin32_NewFrame();
         ImGui::NewFrame();

         // Any application code here
         ImGui::Text("Hello, world!");

         // Render dear imgui into screen
         ImGui::Render();
         ImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData());
         g_pSwapChain->Present(1, 0);
     }

     // Shutdown
     ImGui_ImplDX11_Shutdown();
     ImGui_ImplWin32_Shutdown();
     ImGui::DestroyContext();

 HOW A SIMPLE APPLICATION MAY LOOK LIKE:
 EXHIBIT 2: IMPLEMENTING CUSTOM BINDING / CUSTOM ENGINE.

     // Application init: create a dear imgui context, setup some options, load fonts
     ImGui::CreateContext();
     ImGuiIO& io = ImGui::GetIO();
     // TODO: Set optional io.ConfigFlags values, e.g. 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard' to enable keyboard controls.
     // TODO: Fill optional fields of the io structure later.
     // TODO: Load TTF/OTF fonts if you don't want to use the default font.

     // Build and load the texture atlas into a texture
     // (In the examples/ app this is usually done within the ImGui_ImplXXX_Init() function from one of the demo Renderer)
     int width, height;
     unsigned char* pixels = NULL;
     io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);

     // At this point you've got the texture data and you need to upload that your your graphic system:
     // After we have created the texture, store its pointer/identifier (_in whichever format your engine uses_) in 'io.Fonts->TexID'.
     // This will be passed back to your via the renderer. Basically ImTextureID == void*. Read FAQ below for details about ImTextureID.
     MyTexture* texture = MyEngine::CreateTextureFromMemoryPixels(pixels, width, height, TEXTURE_TYPE_RGBA32)
     io.Fonts->TexID = (void*)texture;

     // Application main loop
     while (true)
     {
        // Setup low-level inputs, e.g. on Win32: calling GetKeyboardState(), or write to those fields from your Windows message handlers, etc.
        // (In the examples/ app this is usually done within the ImGui_ImplXXX_NewFrame() function from one of the demo Platform bindings)
        io.DeltaTime = 1.0f/60.0f;              // set the time elapsed since the previous frame (in seconds)
        io.DisplaySize.x = 1920.0f;             // set the current display width
        io.DisplaySize.y = 1280.0f;             // set the current display height here
        io.MousePos = my_mouse_pos;             // set the mouse position
        io.MouseDown[0] = my_mouse_buttons[0];  // set the mouse button states
        io.MouseDown[1] = my_mouse_buttons[1];

        // Call NewFrame(), after this point you can use ImGui::* functions anytime
        // (So you want to try calling NewFrame() as early as you can in your mainloop to be able to use imgui everywhere)
        ImGui::NewFrame();

        // Most of your application code here
        ImGui::Text("Hello, world!");
        MyGameUpdate(); // may use any ImGui functions, e.g. ImGui::Begin("My window"); ImGui::Text("Hello, world!"); ImGui::End();
        MyGameRender(); // may use any ImGui functions as well!

        // Render imgui, swap buffers
        // (You want to try calling EndFrame/Render as late as you can, to be able to use imgui in your own game rendering code)
        ImGui::EndFrame();
        ImGui::Render();
        ImDrawData* draw_data = ImGui::GetDrawData();
        MyImGuiRenderFunction(draw_data);
        SwapBuffers();
     }

     // Shutdown
     ImGui::DestroyContext();

 HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE:

    void void MyImGuiRenderFunction(ImDrawData* draw_data)
    {
       // TODO: Setup render state: alpha-blending enabled, no face culling, no depth testing, scissor enabled
       // TODO: Setup viewport covering draw_data->DisplayPos to draw_data->DisplayPos + draw_data->DisplaySize
       // TODO: Setup orthographic projection matrix cover draw_data->DisplayPos to draw_data->DisplayPos + draw_data->DisplaySize
       // TODO: Setup shader: vertex { float2 pos, float2 uv, u32 color }, fragment shader sample color from 1 texture, multiply by vertex color.
       for (int n = 0; n < draw_data->CmdListsCount; n++)
       {
          const ImDrawList* cmd_list = draw_data->CmdLists[n];
          const ImDrawVert* vtx_buffer = cmd_list->VtxBuffer.Data;  // vertex buffer generated by ImGui
          const ImDrawIdx* idx_buffer = cmd_list->IdxBuffer.Data;   // index buffer generated by ImGui
          for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)
          {
             const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];
             if (pcmd->UserCallback)
             {
                 pcmd->UserCallback(cmd_list, pcmd);
             }
             else
             {
                 // The texture for the draw call is specified by pcmd->TextureId.
                 // The vast majority of draw calls will use the imgui texture atlas, which value you have set yourself during initialization.
                 MyEngineBindTexture((MyTexture*)pcmd->TextureId);

                 // We are using scissoring to clip some objects. All low-level graphics API should supports it.
                 // - If your engine doesn't support scissoring yet, you may ignore this at first. You will get some small glitches
                 //   (some elements visible outside their bounds) but you can fix that once everything else works!
                 // - Clipping coordinates are provided in imgui coordinates space (from draw_data->DisplayPos to draw_data->DisplayPos + draw_data->DisplaySize)
                 //   In a single viewport application, draw_data->DisplayPos will always be (0,0) and draw_data->DisplaySize will always be == io.DisplaySize.
                 //   However, in the interest of supporting multi-viewport applications in the future (see 'viewport' branch on github),
                 //   always subtract draw_data->DisplayPos from clipping bounds to convert them to your viewport space.
                 // - Note that pcmd->ClipRect contains Min+Max bounds. Some graphics API may use Min+Max, other may use Min+Size (size being Max-Min)
                 ImVec2 pos = draw_data->DisplayPos;
                 MyEngineScissor((int)(pcmd->ClipRect.x - pos.x), (int)(pcmd->ClipRect.y - pos.y), (int)(pcmd->ClipRect.z - pos.x), (int)(pcmd->ClipRect.w - pos.y));

                 // Render 'pcmd->ElemCount/3' indexed triangles.
                 // By default the indices ImDrawIdx are 16-bits, you can change them to 32-bits in imconfig.h if your engine doesn't support 16-bits indices.
                 MyEngineDrawIndexedTriangles(pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer, vtx_buffer);
             }
             idx_buffer += pcmd->ElemCount;
          }
       }
    }

 - The examples/ folders contains many actual implementation of the pseudo-codes above.
 - When calling NewFrame(), the 'io.WantCaptureMouse', 'io.WantCaptureKeyboard' and 'io.WantTextInput' flags are updated.
   They tell you if Dear ImGui intends to use your inputs. When a flag is set you want to hide the corresponding inputs
   from the rest of your application. In every cases you need to pass on the inputs to imgui. Refer to the FAQ for more information.
 - Please read the FAQ below!. Amusingly, it is called a FAQ because people frequently run into the same issues!

 USING GAMEPAD/KEYBOARD NAVIGATION CONTROLS

 - The gamepad/keyboard navigation is fairly functional and keeps being improved.
 - Gamepad support is particularly useful to use dear imgui on a console system (e.g. PS4, Switch, XB1) without a mouse!
 - You can ask questions and report issues at https://github.com/ocornut/imgui/issues/787
 - The initial focus was to support game controllers, but keyboard is becoming increasingly and decently usable.
 - Gamepad:
    - Set io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad to enable.
    - Backend: Set io.BackendFlags |= ImGuiBackendFlags_HasGamepad + fill the io.NavInputs[] fields before calling NewFrame().
      Note that io.NavInputs[] is cleared by EndFrame().
    - See 'enum ImGuiNavInput_' in imgui.h for a description of inputs. For each entry of io.NavInputs[], set the following values:
         0.0f= not held. 1.0f= fully held. Pass intermediate 0.0f..1.0f values for analog triggers/sticks.
    - We uses a simple >0.0f test for activation testing, and won't attempt to test for a dead-zone.
      Your code will probably need to transform your raw inputs (such as e.g. remapping your 0.2..0.9 raw input range to 0.0..1.0 imgui range, etc.).
    - You can download PNG/PSD files depicting the gamepad controls for common controllers at: http://goo.gl/9LgVZW.
    - If you need to share inputs between your game and the imgui parts, the easiest approach is to go all-or-nothing, with a buttons combo
      to toggle the target. Please reach out if you think the game vs navigation input sharing could be improved.
 - Keyboard:
    - Set io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard to enable.
      NewFrame() will automatically fill io.NavInputs[] based on your io.KeysDown[] + io.KeyMap[] arrays.
    - When keyboard navigation is active (io.NavActive + ImGuiConfigFlags_NavEnableKeyboard), the io.WantCaptureKeyboard flag
      will be set. For more advanced uses, you may want to read from:
       - io.NavActive: true when a window is focused and it doesn't have the ImGuiWindowFlags_NoNavInputs flag set.
       - io.NavVisible: true when the navigation cursor is visible (and usually goes false when mouse is used).
       - or query focus information with e.g. IsWindowFocused(ImGuiFocusedFlags_AnyWindow), IsItemFocused() etc. functions.
      Please reach out if you think the game vs navigation input sharing could be improved.
 - Mouse:
    - PS4 users: Consider emulating a mouse cursor with DualShock4 touch pad or a spare analog stick as a mouse-emulation fallback.
    - Consoles/Tablet/Phone users: Consider using a Synergy 1.x server (on your PC) + uSynergy.c (on your console/tablet/phone app) to share your PC mouse/keyboard.
    - On a TV/console system where readability may be lower or mouse inputs may be awkward, you may want to set the ImGuiConfigFlags_NavEnableSetMousePos flag.
      Enabling ImGuiConfigFlags_NavEnableSetMousePos + ImGuiBackendFlags_HasSetMousePos instructs dear imgui to move your mouse cursor along with navigation movements.
      When enabled, the NewFrame() function may alter 'io.MousePos' and set 'io.WantSetMousePos' to notify you that it wants the mouse cursor to be moved.
      When that happens your back-end NEEDS to move the OS or underlying mouse cursor on the next frame. Some of the binding in examples/ do that.
      (If you set the NavEnableSetMousePos flag but don't honor 'io.WantSetMousePos' properly, imgui will misbehave as it will see your mouse as moving back and forth!)
      (In a setup when you may not have easy control over the mouse cursor, e.g. uSynergy.c doesn't expose moving remote mouse cursor, you may want
       to set a boolean to ignore your other external mouse positions until the external source is moved again.)


 API BREAKING CHANGES
 ====================

 Occasionally introducing changes that are breaking the API. We try to make the breakage minor and easy to fix.
 Below is a change-log of API breaking changes only. If you are using one of the functions listed, expect to have to fix some code.
 When you are not sure about a old symbol or function name, try using the Search/Find function of your IDE to look for comments or references in all imgui files.
 You can read releases logs https://github.com/ocornut/imgui/releases for more details.

 - 2019/04/29 (1.70) - improved ImDrawList thick strokes (>1.0f) preserving correct thickness up to 90 degrees angles (e.g. rectangles). If you have custom rendering using thick lines, they will appear thicker now.
 - 2019/04/29 (1.70) - removed GetContentRegionAvailWidth(), use GetContentRegionAvail().x instead. Kept inline redirection function (will obsolete).
 - 2019/03/04 (1.69) - renamed GetOverlayDrawList() to GetForegroundDrawList(). Kept redirection function (will obsolete).
 - 2019/02/26 (1.69) - renamed ImGuiColorEditFlags_RGB/ImGuiColorEditFlags_HSV/ImGuiColorEditFlags_HEX to ImGuiColorEditFlags_DisplayRGB/ImGuiColorEditFlags_DisplayHSV/ImGuiColorEditFlags_DisplayHex. Kept redirection enums (will obsolete).
 - 2019/02/14 (1.68) - made it illegal/assert when io.DisplayTime == 0.0f (with an exception for the first frame). If for some reason your time step calculation gives you a zero value, replace it with a dummy small value!
 - 2019/02/01 (1.68) - removed io.DisplayVisibleMin/DisplayVisibleMax (which were marked obsolete and removed from viewport/docking branch already).
 - 2019/01/06 (1.67) - renamed io.InputCharacters[], marked internal as was always intended. Please don't access directly, and use AddInputCharacter() instead!
 - 2019/01/06 (1.67) - renamed ImFontAtlas::GlyphRangesBuilder to ImFontGlyphRangesBuilder. Keep redirection typedef (will obsolete).
 - 2018/12/20 (1.67) - made it illegal to call Begin("") with an empty string. This somehow half-worked before but had various undesirable side-effects.
 - 2018/12/10 (1.67) - renamed io.ConfigResizeWindowsFromEdges to io.ConfigWindowsResizeFromEdges as we are doing a large pass on configuration flags.
 - 2018/10/12 (1.66) - renamed misc/stl/imgui_stl.* to misc/cpp/imgui_stdlib.* in prevision for other C++ helper files.
 - 2018/09/28 (1.66) - renamed SetScrollHere() to SetScrollHereY(). Kept redirection function (will obsolete).
 - 2018/09/06 (1.65) - renamed stb_truetype.h to imstb_truetype.h, stb_textedit.h to imstb_textedit.h, and stb_rect_pack.h to imstb_rectpack.h.
                       If you were conveniently using the imgui copy of those STB headers in your project you will have to update your include paths.
 - 2018/09/05 (1.65) - renamed io.OptCursorBlink/io.ConfigCursorBlink to io.ConfigInputTextCursorBlink. (#1427)
 - 2018/08/31 (1.64) - added imgui_widgets.cpp file, extracted and moved widgets code out of imgui.cpp into imgui_widgets.cpp. Re-ordered some of the code remaining in imgui.cpp.
                       NONE OF THE FUNCTIONS HAVE CHANGED. THE CODE IS SEMANTICALLY 100% IDENTICAL, BUT _EVERY_ FUNCTION HAS BEEN MOVED.
                       Because of this, any local modifications to imgui.cpp will likely conflict when you update. Read docs/CHANGELOG.txt for suggestions.
 - 2018/08/22 (1.63) - renamed IsItemDeactivatedAfterChange() to IsItemDeactivatedAfterEdit() for consistency with new IsItemEdited() API. Kept redirection function (will obsolete soonish as IsItemDeactivatedAfterChange() is very recent).
 - 2018/08/21 (1.63) - renamed ImGuiTextEditCallback to ImGuiInputTextCallback, ImGuiTextEditCallbackData to ImGuiInputTextCallbackData for consistency. Kept redirection types (will obsolete).
 - 2018/08/21 (1.63) - removed ImGuiInputTextCallbackData::ReadOnly since it is a duplication of (ImGuiInputTextCallbackData::Flags & ImGuiInputTextFlags_ReadOnly).
 - 2018/08/01 (1.63) - removed per-window ImGuiWindowFlags_ResizeFromAnySide beta flag in favor of a global io.ConfigResizeWindowsFromEdges [update 1.67 renamed to ConfigWindowsResizeFromEdges] to enable the feature.
 - 2018/08/01 (1.63) - renamed io.OptCursorBlink to io.ConfigCursorBlink [-> io.ConfigInputTextCursorBlink in 1.65], io.OptMacOSXBehaviors to ConfigMacOSXBehaviors for consistency.
 - 2018/07/22 (1.63) - changed ImGui::GetTime() return value from float to double to avoid accumulating floating point imprecisions over time.
 - 2018/07/08 (1.63) - style: renamed ImGuiCol_ModalWindowDarkening to ImGuiCol_ModalWindowDimBg for consistency with other features. Kept redirection enum (will obsolete).
 - 2018/06/08 (1.62) - examples: the imgui_impl_xxx files have been split to separate platform (Win32, Glfw, SDL2, etc.) from renderer (DX11, OpenGL, Vulkan,  etc.).
                       old bindings will still work as is, however prefer using the separated bindings as they will be updated to support multi-viewports.
                       when adopting new bindings follow the main.cpp code of your preferred examples/ folder to know which functions to call.
                       in particular, note that old bindings called ImGui::NewFrame() at the end of their ImGui_ImplXXXX_NewFrame() function.
 - 2018/06/06 (1.62) - renamed GetGlyphRangesChinese() to GetGlyphRangesChineseFull() to distinguish other variants and discourage using the full set.
 - 2018/06/06 (1.62) - TreeNodeEx()/TreeNodeBehavior(): the ImGuiTreeNodeFlags_CollapsingHeader helper now include the ImGuiTreeNodeFlags_NoTreePushOnOpen flag. See Changelog for details.
 - 2018/05/03 (1.61) - DragInt(): the default compile-time format string has been changed from "%.0f" to "%d", as we are not using integers internally any more.
                       If you used DragInt() with custom format strings, make sure you change them to use %d or an integer-compatible format.
                       To honor backward-compatibility, the DragInt() code will currently parse and modify format strings to replace %*f with %d, giving time to users to upgrade their code.
                       If you have IMGUI_DISABLE_OBSOLETE_FUNCTIONS enabled, the code will instead assert! You may run a reg-exp search on your codebase for e.g. "DragInt.*%f" to help you find them.
 - 2018/04/28 (1.61) - obsoleted InputFloat() functions taking an optional "int decimal_precision" in favor of an equivalent and more flexible "const char* format",
                       consistent with other functions. Kept redirection functions (will obsolete).
 - 2018/04/09 (1.61) - IM_DELETE() helper function added in 1.60 doesn't clear the input _pointer_ reference, more consistent with expectation and allows passing r-value.
 - 2018/03/20 (1.60) - renamed io.WantMoveMouse to io.WantSetMousePos for consistency and ease of understanding (was added in 1.52, _not_ used by core and only honored by some binding ahead of merging the Nav branch).
 - 2018/03/12 (1.60) - removed ImGuiCol_CloseButton, ImGuiCol_CloseButtonActive, ImGuiCol_CloseButtonHovered as the closing cross uses regular button colors now.
 - 2018/03/08 (1.60) - changed ImFont::DisplayOffset.y to default to 0 instead of +1. Fixed rounding of Ascent/Descent to match TrueType renderer. If you were adding or subtracting to ImFont::DisplayOffset check if your fonts are correctly aligned vertically.
 - 2018/03/03 (1.60) - renamed ImGuiStyleVar_Count_ to ImGuiStyleVar_COUNT and ImGuiMouseCursor_Count_ to ImGuiMouseCursor_COUNT for consistency with other public enums.
 - 2018/02/18 (1.60) - BeginDragDropSource(): temporarily removed the optional mouse_button=0 parameter because it is not really usable in many situations at the moment.
 - 2018/02/16 (1.60) - obsoleted the io.RenderDrawListsFn callback, you can call your graphics engine render function after ImGui::Render(). Use ImGui::GetDrawData() to retrieve the ImDrawData* to display.
 - 2018/02/07 (1.60) - reorganized context handling to be more explicit,
                       - YOU NOW NEED TO CALL ImGui::CreateContext() AT THE BEGINNING OF YOUR APP, AND CALL ImGui::DestroyContext() AT THE END.
                       - removed Shutdown() function, as DestroyContext() serve this purpose.
                       - you may pass a ImFontAtlas* pointer to CreateContext() to share a font atlas between contexts. Otherwise CreateContext() will create its own font atlas instance.
                       - removed allocator parameters from CreateContext(), they are now setup with SetAllocatorFunctions(), and shared by all contexts.
                       - removed the default global context and font atlas instance, which were confusing for users of DLL reloading and users of multiple contexts.
 - 2018/01/31 (1.60) - moved sample TTF files from extra_fonts/ to misc/fonts/. If you loaded files directly from the imgui repo you may need to update your paths.
 - 2018/01/11 (1.60) - obsoleted IsAnyWindowHovered() in favor of IsWindowHovered(ImGuiHoveredFlags_AnyWindow). Kept redirection function (will obsolete).
 - 2018/01/11 (1.60) - obsoleted IsAnyWindowFocused() in favor of IsWindowFocused(ImGuiFocusedFlags_AnyWindow). Kept redirection function (will obsolete).
 - 2018/01/03 (1.60) - renamed ImGuiSizeConstraintCallback to ImGuiSizeCallback, ImGuiSizeConstraintCallbackData to ImGuiSizeCallbackData.
 - 2017/12/29 (1.60) - removed CalcItemRectClosestPoint() which was weird and not really used by anyone except demo code. If you need it it's easy to replicate on your side.
 - 2017/12/24 (1.53) - renamed the emblematic ShowTestWindow() function to ShowDemoWindow(). Kept redirection function (will obsolete).
 - 2017/12/21 (1.53) - ImDrawList: renamed style.AntiAliasedShapes to style.AntiAliasedFill for consistency and as a way to explicitly break code that manipulate those flag at runtime. You can now manipulate ImDrawList::Flags
 - 2017/12/21 (1.53) - ImDrawList: removed 'bool anti_aliased = true' final parameter of ImDrawList::AddPolyline() and ImDrawList::AddConvexPolyFilled(). Prefer manipulating ImDrawList::Flags if you need to toggle them during the frame.
 - 2017/12/14 (1.53) - using the ImGuiWindowFlags_NoScrollWithMouse flag on a child window forwards the mouse wheel event to the parent window, unless either ImGuiWindowFlags_NoInputs or ImGuiWindowFlags_NoScrollbar are also set.
 - 2017/12/13 (1.53) - renamed GetItemsLineHeightWithSpacing() to GetFrameHeightWithSpacing(). Kept redirection function (will obsolete).
 - 2017/12/13 (1.53) - obsoleted IsRootWindowFocused() in favor of using IsWindowFocused(ImGuiFocusedFlags_RootWindow). Kept redirection function (will obsolete).
                     - obsoleted IsRootWindowOrAnyChildFocused() in favor of using IsWindowFocused(ImGuiFocusedFlags_RootAndChildWindows). Kept redirection function (will obsolete).
 - 2017/12/12 (1.53) - renamed ImGuiTreeNodeFlags_AllowOverlapMode to ImGuiTreeNodeFlags_AllowItemOverlap. Kept redirection enum (will obsolete).
 - 2017/12/10 (1.53) - removed SetNextWindowContentWidth(), prefer using SetNextWindowContentSize(). Kept redirection function (will obsolete).
 - 2017/11/27 (1.53) - renamed ImGuiTextBuffer::append() helper to appendf(), appendv() to appendfv(). If you copied the 'Log' demo in your code, it uses appendv() so that needs to be renamed.
 - 2017/11/18 (1.53) - Style, Begin: removed ImGuiWindowFlags_ShowBorders window flag. Borders are now fully set up in the ImGuiStyle structure (see e.g. style.FrameBorderSize, style.WindowBorderSize). Use ImGui::ShowStyleEditor() to look them up.
                       Please note that the style system will keep evolving (hopefully stabilizing in Q1 2018), and so custom styles will probably subtly break over time. It is recommended you use the StyleColorsClassic(), StyleColorsDark(), StyleColorsLight() functions.
 - 2017/11/18 (1.53) - Style: removed ImGuiCol_ComboBg in favor of combo boxes using ImGuiCol_PopupBg for consistency.
 - 2017/11/18 (1.53) - Style: renamed ImGuiCol_ChildWindowBg to ImGuiCol_ChildBg.
 - 2017/11/18 (1.53) - Style: renamed style.ChildWindowRounding to style.ChildRounding, ImGuiStyleVar_ChildWindowRounding to ImGuiStyleVar_ChildRounding.
 - 2017/11/02 (1.53) - obsoleted IsRootWindowOrAnyChildHovered() in favor of using IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows);
 - 2017/10/24 (1.52) - renamed IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCS/IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCS to IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS/IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS for consistency.
 - 2017/10/20 (1.52) - changed IsWindowHovered() default parameters behavior to return false if an item is active in another window (e.g. click-dragging item from another window to this window). You can use the newly introduced IsWindowHovered() flags to requests this specific behavior if you need it.
 - 2017/10/20 (1.52) - marked IsItemHoveredRect()/IsMouseHoveringWindow() as obsolete, in favor of using the newly introduced flags for IsItemHovered() and IsWindowHovered(). See https://github.com/ocornut/imgui/issues/1382 for details.
                       removed the IsItemRectHovered()/IsWindowRectHovered() names introduced in 1.51 since they were merely more consistent names for the two functions we are now obsoleting.
 - 2017/10/17 (1.52) - marked the old 5-parameters version of Begin() as obsolete (still available). Use SetNextWindowSize()+Begin() instead!
 - 2017/10/11 (1.52) - renamed AlignFirstTextHeightToWidgets() to AlignTextToFramePadding(). Kept inline redirection function (will obsolete).
 - 2017/09/26 (1.52) - renamed ImFont::Glyph to ImFontGlyph. Keep redirection typedef (will obsolete).
 - 2017/09/25 (1.52) - removed SetNextWindowPosCenter() because SetNextWindowPos() now has the optional pivot information to do the same and more. Kept redirection function (will obsolete).
 - 2017/08/25 (1.52) - io.MousePos needs to be set to ImVec2(-FLT_MAX,-FLT_MAX) when mouse is unavailable/missing. Previously ImVec2(-1,-1) was enough but we now accept negative mouse coordinates. In your binding if you need to support unavailable mouse, make sure to replace "io.MousePos = ImVec2(-1,-1)" with "io.MousePos = ImVec2(-FLT_MAX,-FLT_MAX)".
 - 2017/08/22 (1.51) - renamed IsItemHoveredRect() to IsItemRectHovered(). Kept inline redirection function (will obsolete). -> (1.52) use IsItemHovered(ImGuiHoveredFlags_RectOnly)!
                     - renamed IsMouseHoveringAnyWindow() to IsAnyWindowHovered() for consistency. Kept inline redirection function (will obsolete).
                     - renamed IsMouseHoveringWindow() to IsWindowRectHovered() for consistency. Kept inline redirection function (will obsolete).
 - 2017/08/20 (1.51) - renamed GetStyleColName() to GetStyleColorName() for consistency.
 - 2017/08/20 (1.51) - added PushStyleColor(ImGuiCol idx, ImU32 col) overload, which _might_ cause an "ambiguous call" compilation error if you are using ImColor() with implicit cast. Cast to ImU32 or ImVec4 explicily to fix.
 - 2017/08/15 (1.51) - marked the weird IMGUI_ONCE_UPON_A_FRAME helper macro as obsolete. prefer using the more explicit ImGuiOnceUponAFrame.
 - 2017/08/15 (1.51) - changed parameter order for BeginPopupContextWindow() from (const char*,int buttons,bool also_over_items) to (const char*,int buttons,bool also_over_items). Note that most calls relied on default parameters completely.
 - 2017/08/13 (1.51) - renamed ImGuiCol_Columns*** to ImGuiCol_Separator***. Kept redirection enums (will obsolete).
 - 2017/08/11 (1.51) - renamed ImGuiSetCond_*** types and flags to ImGuiCond_***. Kept redirection enums (will obsolete).
 - 2017/08/09 (1.51) - removed ValueColor() helpers, they are equivalent to calling Text(label) + SameLine() + ColorButton().
 - 2017/08/08 (1.51) - removed ColorEditMode() and ImGuiColorEditMode in favor of ImGuiColorEditFlags and parameters to the various Color*() functions. The SetColorEditOptions() allows to initialize default but the user can still change them with right-click context menu.
                     - changed prototype of 'ColorEdit4(const char* label, float col[4], bool show_alpha = true)' to 'ColorEdit4(const char* label, float col[4], ImGuiColorEditFlags flags = 0)', where passing flags = 0x01 is a safe no-op (hello dodgy backward compatibility!). - check and run the demo window, under "Color/Picker Widgets", to understand the various new options.
                     - changed prototype of rarely used 'ColorButton(ImVec4 col, bool small_height = false, bool outline_border = true)' to 'ColorButton(const char* desc_id, ImVec4 col, ImGuiColorEditFlags flags = 0, ImVec2 size = ImVec2(0,0))'
 - 2017/07/20 (1.51) - removed IsPosHoveringAnyWindow(ImVec2), which was partly broken and misleading. ASSERT + redirect user to io.WantCaptureMouse
 - 2017/05/26 (1.50) - removed ImFontConfig::MergeGlyphCenterV in favor of a more multipurpose ImFontConfig::GlyphOffset.
 - 2017/05/01 (1.50) - renamed ImDrawList::PathFill() (rarely used directly) to ImDrawList::PathFillConvex() for clarity.
 - 2016/11/06 (1.50) - BeginChild(const char*) now applies the stack id to the provided label, consistently with other functions as it should always have been. It shouldn't affect you unless (extremely unlikely) you were appending multiple times to a same child from different locations of the stack id. If that's the case, generate an id with GetId() and use it instead of passing string to BeginChild().
 - 2016/10/15 (1.50) - avoid 'void* user_data' parameter to io.SetClipboardTextFn/io.GetClipboardTextFn pointers. We pass io.ClipboardUserData to it.
 - 2016/09/25 (1.50) - style.WindowTitleAlign is now a ImVec2 (ImGuiAlign enum was removed). set to (0.5f,0.5f) for horizontal+vertical centering, (0.0f,0.0f) for upper-left, etc.
 - 2016/07/30 (1.50) - SameLine(x) with x>0.0f is now relative to left of column/group if any, and not always to left of window. This was sort of always the intent and hopefully breakage should be minimal.
 - 2016/05/12 (1.49) - title bar (using ImGuiCol_TitleBg/ImGuiCol_TitleBgActive colors) isn't rendered over a window background (ImGuiCol_WindowBg color) anymore.
                       If your TitleBg/TitleBgActive alpha was 1.0f or you are using the default theme it will not affect you.
                       If your TitleBg/TitleBgActive alpha was <1.0f you need to tweak your custom theme to readjust for the fact that we don't draw a WindowBg background behind the title bar.
                       This helper function will convert an old TitleBg/TitleBgActive color into a new one with the same visual output, given the OLD color and the OLD WindowBg color.
                           ImVec4 ConvertTitleBgCol(const ImVec4& win_bg_col, const ImVec4& title_bg_col)
                           {
                               float new_a = 1.0f - ((1.0f - win_bg_col.w) * (1.0f - title_bg_col.w)), k = title_bg_col.w / new_a;
                               return ImVec4((win_bg_col.x * win_bg_col.w + title_bg_col.x) * k, (win_bg_col.y * win_bg_col.w + title_bg_col.y) * k, (win_bg_col.z * win_bg_col.w + title_bg_col.z) * k, new_a);
                           }
                       If this is confusing, pick the RGB value from title bar from an old screenshot and apply this as TitleBg/TitleBgActive. Or you may just create TitleBgActive from a tweaked TitleBg color.
 - 2016/05/07 (1.49) - removed confusing set of GetInternalState(), GetInternalStateSize(), SetInternalState() functions. Now using CreateContext(), DestroyContext(), GetCurrentContext(), SetCurrentContext().
 - 2016/05/02 (1.49) - renamed SetNextTreeNodeOpened() to SetNextTreeNodeOpen(), no redirection.
 - 2016/05/01 (1.49) - obsoleted old signature of CollapsingHeader(const char* label, const char* str_id = NULL, bool display_frame = true, bool default_open = false) as extra parameters were badly designed and rarely used. You can replace the "default_open = true" flag in new API with CollapsingHeader(label, ImGuiTreeNodeFlags_DefaultOpen).
 - 2016/04/26 (1.49) - changed ImDrawList::PushClipRect(ImVec4 rect) to ImDrawList::PushClipRect(Imvec2 min,ImVec2 max,bool intersect_with_current_clip_rect=false). Note that higher-level ImGui::PushClipRect() is preferable because it will clip at logic/widget level, whereas ImDrawList::PushClipRect() only affect your renderer.
 - 2016/04/03 (1.48) - removed style.WindowFillAlphaDefault setting which was redundant. Bake default BG alpha inside style.Colors[ImGuiCol_WindowBg] and all other Bg color values. (ref github issue #337).
 - 2016/04/03 (1.48) - renamed ImGuiCol_TooltipBg to ImGuiCol_PopupBg, used by popups/menus and tooltips. popups/menus were previously using ImGuiCol_WindowBg. (ref github issue #337)
 - 2016/03/21 (1.48) - renamed GetWindowFont() to GetFont(), GetWindowFontSize() to GetFontSize(). Kept inline redirection function (will obsolete).
 - 2016/03/02 (1.48) - InputText() completion/history/always callbacks: if you modify the text buffer manually (without using DeleteChars()/InsertChars() helper) you need to maintain the BufTextLen field. added an assert.
 - 2016/01/23 (1.48) - fixed not honoring exact width passed to PushItemWidth(), previously it would add extra FramePadding.x*2 over that width. if you had manual pixel-perfect alignment in place it might affect you.
 - 2015/12/27 (1.48) - fixed ImDrawList::AddRect() which used to render a rectangle 1 px too large on each axis.
 - 2015/12/04 (1.47) - renamed Color() helpers to ValueColor() - dangerously named, rarely used and probably to be made obsolete.
 - 2015/08/29 (1.45) - with the addition of horizontal scrollbar we made various fixes to inconsistencies with dealing with cursor position.
                       GetCursorPos()/SetCursorPos() functions now include the scrolled amount. It shouldn't affect the majority of users, but take note that SetCursorPosX(100.0f) puts you at +100 from the starting x position which may include scrolling, not at +100 from the window left side.
                       GetContentRegionMax()/GetWindowContentRegionMin()/GetWindowContentRegionMax() functions allow include the scrolled amount. Typically those were used in cases where no scrolling would happen so it may not be a problem, but watch out!
 - 2015/08/29 (1.45) - renamed style.ScrollbarWidth to style.ScrollbarSize
 - 2015/08/05 (1.44) - split imgui.cpp into extra files: imgui_demo.cpp imgui_draw.cpp imgui_internal.h that you need to add to your project.
 - 2015/07/18 (1.44) - fixed angles in ImDrawList::PathArcTo(), PathArcToFast() (introduced in 1.43) being off by an extra PI for no justifiable reason
 - 2015/07/14 (1.43) - add new ImFontAtlas::AddFont() API. For the old AddFont***, moved the 'font_no' parameter of ImFontAtlas::AddFont** functions to the ImFontConfig structure.
                       you need to render your textured triangles with bilinear filtering to benefit from sub-pixel positioning of text.
 - 2015/07/08 (1.43) - switched rendering data to use indexed rendering. this is saving a fair amount of CPU/GPU and enables us to get anti-aliasing for a marginal cost.
                       this necessary change will break your rendering function! the fix should be very easy. sorry for that :(
                     - if you are using a vanilla copy of one of the imgui_impl_XXXX.cpp provided in the example, you just need to update your copy and you can ignore the rest.
                     - the signature of the io.RenderDrawListsFn handler has changed!
                       old: ImGui_XXXX_RenderDrawLists(ImDrawList** const cmd_lists, int cmd_lists_count)
                       new: ImGui_XXXX_RenderDrawLists(ImDrawData* draw_data).
                         parameters: 'cmd_lists' becomes 'draw_data->CmdLists', 'cmd_lists_count' becomes 'draw_data->CmdListsCount'
                         ImDrawList: 'commands' becomes 'CmdBuffer', 'vtx_buffer' becomes 'VtxBuffer', 'IdxBuffer' is new.
                         ImDrawCmd:  'vtx_count' becomes 'ElemCount', 'clip_rect' becomes 'ClipRect', 'user_callback' becomes 'UserCallback', 'texture_id' becomes 'TextureId'.
                     - each ImDrawList now contains both a vertex buffer and an index buffer. For each command, render ElemCount/3 triangles using indices from the index buffer.
                     - if you REALLY cannot render indexed primitives, you can call the draw_data->DeIndexAllBuffers() method to de-index the buffers. This is slow and a waste of CPU/GPU. Prefer using indexed rendering!
                     - refer to code in the examples/ folder or ask on the GitHub if you are unsure of how to upgrade. please upgrade!
 - 2015/07/10 (1.43) - changed SameLine() parameters from int to float.
 - 2015/07/02 (1.42) - renamed SetScrollPosHere() to SetScrollFromCursorPos(). Kept inline redirection function (will obsolete).
 - 2015/07/02 (1.42) - renamed GetScrollPosY() to GetScrollY(). Necessary to reduce confusion along with other scrolling functions, because positions (e.g. cursor position) are not equivalent to scrolling amount.
 - 2015/06/14 (1.41) - changed ImageButton() default bg_col parameter from (0,0,0,1) (black) to (0,0,0,0) (transparent) - makes a difference when texture have transparence
 - 2015/06/14 (1.41) - changed Selectable() API from (label, selected, size) to (label, selected, flags, size). Size override should have been rarely be used. Sorry!
 - 2015/05/31 (1.40) - renamed GetWindowCollapsed() to IsWindowCollapsed() for consistency. Kept inline redirection function (will obsolete).
 - 2015/05/31 (1.40) - renamed IsRectClipped() to IsRectVisible() for consistency. Note that return value is opposite! Kept inline redirection function (will obsolete).
 - 2015/05/27 (1.40) - removed the third 'repeat_if_held' parameter from Button() - sorry! it was rarely used and inconsistent. Use PushButtonRepeat(true) / PopButtonRepeat() to enable repeat on desired buttons.
 - 2015/05/11 (1.40) - changed BeginPopup() API, takes a string identifier instead of a bool. ImGui needs to manage the open/closed state of popups. Call OpenPopup() to actually set the "open" state of a popup. BeginPopup() returns true if the popup is opened.
 - 2015/05/03 (1.40) - removed style.AutoFitPadding, using style.WindowPadding makes more sense (the default values were already the same).
 - 2015/04/13 (1.38) - renamed IsClipped() to IsRectClipped(). Kept inline redirection function until 1.50.
 - 2015/04/09 (1.38) - renamed ImDrawList::AddArc() to ImDrawList::AddArcFast() for compatibility with future API
 - 2015/04/03 (1.38) - removed ImGuiCol_CheckHovered, ImGuiCol_CheckActive, replaced with the more general ImGuiCol_FrameBgHovered, ImGuiCol_FrameBgActive.
 - 2014/04/03 (1.38) - removed support for passing -FLT_MAX..+FLT_MAX as the range for a SliderFloat(). Use DragFloat() or Inputfloat() instead.
 - 2015/03/17 (1.36) - renamed GetItemBoxMin()/GetItemBoxMax()/IsMouseHoveringBox() to GetItemRectMin()/GetItemRectMax()/IsMouseHoveringRect(). Kept inline redirection function until 1.50.
 - 2015/03/15 (1.36) - renamed style.TreeNodeSpacing to style.IndentSpacing, ImGuiStyleVar_TreeNodeSpacing to ImGuiStyleVar_IndentSpacing
 - 2015/03/13 (1.36) - renamed GetWindowIsFocused() to IsWindowFocused(). Kept inline redirection function until 1.50.
 - 2015/03/08 (1.35) - renamed style.ScrollBarWidth to style.ScrollbarWidth (casing)
 - 2015/02/27 (1.34) - renamed OpenNextNode(bool) to SetNextTreeNodeOpened(bool, ImGuiSetCond). Kept inline redirection function until 1.50.
 - 2015/02/27 (1.34) - renamed ImGuiSetCondition_*** to ImGuiSetCond_***, and _FirstUseThisSession becomes _Once.
 - 2015/02/11 (1.32) - changed text input callback ImGuiTextEditCallback return type from void-->int. reserved for future use, return 0 for now.
 - 2015/02/10 (1.32) - renamed GetItemWidth() to CalcItemWidth() to clarify its evolving behavior
 - 2015/02/08 (1.31) - renamed GetTextLineSpacing() to GetTextLineHeightWithSpacing()
 - 2015/02/01 (1.31) - removed IO.MemReallocFn (unused)
 - 2015/01/19 (1.30) - renamed ImGuiStorage::GetIntPtr()/GetFloatPtr() to GetIntRef()/GetIntRef() because Ptr was conflicting with actual pointer storage functions.
 - 2015/01/11 (1.30) - big font/image API change! now loads TTF file. allow for multiple fonts. no need for a PNG loader.
              (1.30) - removed GetDefaultFontData(). uses io.Fonts->GetTextureData*() API to retrieve uncompressed pixels.
                       font init:  { const void* png_data; unsigned int png_size; ImGui::GetDefaultFontData(NULL, NULL, &png_data, &png_size); <..Upload texture to GPU..>; }
                       became:     { unsigned char* pixels; int width, height; io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height); <..Upload texture to GPU>; io.Fonts->TexId = YourTextureIdentifier; }
                       you now have more flexibility to load multiple TTF fonts and manage the texture buffer for internal needs.
                       it is now recommended that you sample the font texture with bilinear interpolation.
              (1.30) - added texture identifier in ImDrawCmd passed to your render function (we can now render images). make sure to set io.Fonts->TexID.
              (1.30) - removed IO.PixelCenterOffset (unnecessary, can be handled in user projection matrix)
              (1.30) - removed ImGui::IsItemFocused() in favor of ImGui::IsItemActive() which handles all widgets
 - 2014/12/10 (1.18) - removed SetNewWindowDefaultPos() in favor of new generic API SetNextWindowPos(pos, ImGuiSetCondition_FirstUseEver)
 - 2014/11/28 (1.17) - moved IO.Font*** options to inside the IO.Font-> structure (FontYOffset, FontTexUvForWhite, FontBaseScale, FontFallbackGlyph)
 - 2014/11/26 (1.17) - reworked syntax of IMGUI_ONCE_UPON_A_FRAME helper macro to increase compiler compatibility
 - 2014/11/07 (1.15) - renamed IsHovered() to IsItemHovered()
 - 2014/10/02 (1.14) - renamed IMGUI_INCLUDE_IMGUI_USER_CPP to IMGUI_INCLUDE_IMGUI_USER_INL and imgui_user.cpp to imgui_user.inl (more IDE friendly)
 - 2014/09/25 (1.13) - removed 'text_end' parameter from IO.SetClipboardTextFn (the string is now always zero-terminated for simplicity)
 - 2014/09/24 (1.12) - renamed SetFontScale() to SetWindowFontScale()
 - 2014/09/24 (1.12) - moved IM_MALLOC/IM_REALLOC/IM_FREE preprocessor defines to IO.MemAllocFn/IO.MemReallocFn/IO.MemFreeFn
 - 2014/08/30 (1.09) - removed IO.FontHeight (now computed automatically)
 - 2014/08/30 (1.09) - moved IMGUI_FONT_TEX_UV_FOR_WHITE preprocessor define to IO.FontTexUvForWhite
 - 2014/08/28 (1.09) - changed the behavior of IO.PixelCenterOffset following various rendering fixes


 FREQUENTLY ASKED QUESTIONS (FAQ), TIPS
 ======================================

 Q: Where is the documentation?
 A: This library is poorly documented at the moment and expects of the user to be acquainted with C/C++.
    - Run the examples/ and explore them.
    - See demo code in imgui_demo.cpp and particularly the ImGui::ShowDemoWindow() function. 
    - The demo covers most features of Dear ImGui, so you can read the code and see its output. 
    - See documentation and comments at the top of imgui.cpp + effectively imgui.h.
    - Dozens of standalone example applications using e.g. OpenGL/DirectX are provided in the examples/ 
      folder to explain how to integrate Dear ImGui with your own engine/application.
    - Your programming IDE is your friend, find the type or function declaration to find comments 
      associated to it.

 Q: Which version should I get?
 A: I occasionally tag Releases (https://github.com/ocornut/imgui/releases) but it is generally safe 
    and recommended to sync to master/latest. The library is fairly stable and regressions tend to be 
    fixed fast when reported. You may also peak at the 'docking' branch which includes:
    - Docking/Merging features (https://github.com/ocornut/imgui/issues/2109)
    - Multi-viewport features (https://github.com/ocornut/imgui/issues/1542)
    Many projects are using this branch and it is kept in sync with master regularly.

 Q: Who uses Dear ImGui?
 A: See "Quotes" (https://github.com/ocornut/imgui/wiki/Quotes) and
    "Software using Dear ImGui" (https://github.com/ocornut/imgui/wiki/Software-using-dear-imgui) Wiki pages
    for a list of games/software which are publicly known to use dear imgui. Please add yours if you can!

 Q: Why the odd dual naming, "Dear ImGui" vs "ImGui"?
 A: The library started its life as "ImGui" due to the fact that I didn't give it a proper name when 
    when I released 1.0, and had no particular expectation that it would take off. However, the term IMGUI 
    (immediate-mode graphical user interface) was coined before and is being used in variety of other 
    situations (e.g. Unity uses it own implementation of the IMGUI paradigm). 
    To reduce the ambiguity without affecting existing code bases, I have decided on an alternate, 
    longer name "Dear ImGui" that people can use to refer to this specific library.
    Please try to refer to this library as "Dear ImGui".

 Q: How can I tell whether to dispatch mouse/keyboard to imgui or to my application?
 A: You can read the 'io.WantCaptureMouse', 'io.WantCaptureKeyboard' and 'io.WantTextInput' flags from the ImGuiIO structure (e.g. if (ImGui::GetIO().WantCaptureMouse) { ... } )
    - When 'io.WantCaptureMouse' is set, imgui wants to use your mouse state, and you may want to discard/hide the inputs from the rest of your application.
    - When 'io.WantCaptureKeyboard' is set, imgui wants to use your keyboard state, and you may want to discard/hide the inputs from the rest of your application.
    - When 'io.WantTextInput' is set to may want to notify your OS to popup an on-screen keyboard, if available (e.g. on a mobile phone, or console OS).
    Note: you should always pass your mouse/keyboard inputs to imgui, even when the io.WantCaptureXXX flag are set false.
     This is because imgui needs to detect that you clicked in the void to unfocus its own windows.
    Note: The 'io.WantCaptureMouse' is more accurate that any attempt to "check if the mouse is hovering a window" (don't do that!).
     It handle mouse dragging correctly (both dragging that started over your application or over an imgui window) and handle e.g. modal windows blocking inputs.
     Those flags are updated by ImGui::NewFrame(). Preferably read the flags after calling NewFrame() if you can afford it, but reading them before is also
     perfectly fine, as the bool toggle fairly rarely. If you have on a touch device, you might find use for an early call to UpdateHoveredWindowAndCaptureFlags().
    Note: Text input widget releases focus on "Return KeyDown", so the subsequent "Return KeyUp" event that your application receive will typically
     have 'io.WantCaptureKeyboard=false'. Depending on your application logic it may or not be inconvenient. You might want to track which key-downs
     were targeted for Dear ImGui, e.g. with an array of bool, and filter out the corresponding key-ups.)

 Q: How can I display an image? What is ImTextureID, how does it works?
 A: Short explanation:
    - You may use functions such as ImGui::Image(), ImGui::ImageButton() or lower-level ImDrawList::AddImage() to emit draw calls that will use your own textures.
    - Actual textures are identified in a way that is up to the user/engine. Those identifiers are stored and passed as ImTextureID (void*) value.
    - Loading image files from the disk and turning them into a texture is not within the scope of Dear ImGui (for a good reason).
      Please read documentations or tutorials on your graphics API to understand how to display textures on the screen before moving onward.

    Long explanation:
    - Dear ImGui's job is to create "meshes", defined in a renderer-agnostic format made of draw commands and vertices.
      At the end of the frame those meshes (ImDrawList) will be displayed by your rendering function. They are made up of textured polygons and the code
      to render them is generally fairly short (a few dozen lines). In the examples/ folder we provide functions for popular graphics API (OpenGL, DirectX, etc.).
    - Each rendering function decides on a data type to represent "textures". The concept of what is a "texture" is entirely tied to your underlying engine/graphics API.
      We carry the information to identify a "texture" in the ImTextureID type.
      ImTextureID is nothing more that a void*, aka 4/8 bytes worth of data: just enough to store 1 pointer or 1 integer of your choice.
      Dear ImGui doesn't know or understand what you are storing in ImTextureID, it merely pass ImTextureID values until they reach your rendering function.
    - In the examples/ bindings, for each graphics API binding we decided on a type that is likely to be a good representation for specifying
      an image from the end-user perspective. This is what the _examples_ rendering functions are using:

         OpenGL:     ImTextureID = GLuint                       (see ImGui_ImplGlfwGL3_RenderDrawData() function in imgui_impl_glfw_gl3.cpp)
         DirectX9:   ImTextureID = LPDIRECT3DTEXTURE9           (see ImGui_ImplDX9_RenderDrawData()     function in imgui_impl_dx9.cpp)
         DirectX11:  ImTextureID = ID3D11ShaderResourceView*    (see ImGui_ImplDX11_RenderDrawData()    function in imgui_impl_dx11.cpp)
         DirectX12:  ImTextureID = D3D12_GPU_DESCRIPTOR_HANDLE  (see ImGui_ImplDX12_RenderDrawData()    function in imgui_impl_dx12.cpp)

      For example, in the OpenGL example binding we store raw OpenGL texture identifier (GLuint) inside ImTextureID.
      Whereas in the DirectX11 example binding we store a pointer to ID3D11ShaderResourceView inside ImTextureID, which is a higher-level structure
      tying together both the texture and information about its format and how to read it.
    - If you have a custom engine built over e.g. OpenGL, instead of passing GLuint around you may decide to use a high-level data type to carry information about
      the texture as well as how to display it (shaders, etc.). The decision of what to use as ImTextureID can always be made better knowing how your codebase
      is designed. If your engine has high-level data types for "textures" and "material" then you may want to use them.
      If you are starting with OpenGL or DirectX or Vulkan and haven't built much of a rendering engine over them, keeping the default ImTextureID
      representation suggested by the example bindings is probably the best choice.
      (Advanced users may also decide to keep a low-level type in ImTextureID, and use ImDrawList callback and pass information to their renderer)

    User code may do:

        // Cast our texture type to ImTextureID / void*
        MyTexture* texture = g_CoffeeTableTexture;
        ImGui::Image((void*)texture, ImVec2(texture->Width, texture->Height));

    The renderer function called after ImGui::Render() will receive that same value that the user code passed:

        // Cast ImTextureID / void* stored in the draw command as our texture type
        MyTexture* texture = (MyTexture*)pcmd->TextureId;
        MyEngineBindTexture2D(texture);

    Once you understand this design you will understand that loading image files and turning them into displayable textures is not within the scope of Dear ImGui.
    This is by design and is actually a good thing, because it means your code has full control over your data types and how you display them.
    If you want to display an image file (e.g. PNG file) into the screen, please refer to documentation and tutorials for the graphics API you are using.

    Here's a simplified OpenGL example using stb_image.h:

        // Use stb_image.h to load a PNG from disk and turn it into raw RGBA pixel data:
        #define STB_IMAGE_IMPLEMENTATION
        #include <stb_image.h>
        [...]
        int my_image_width, my_image_height;
        unsigned char* my_image_data = stbi_load("my_image.png", &my_image_width, &my_image_height, NULL, 4);

        // Turn the RGBA pixel data into an OpenGL texture:
        GLuint my_opengl_texture;
        glGenTextures(1, &my_opengl_texture);
        glBindTexture(GL_TEXTURE_2D, my_opengl_texture);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, image_width, image_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, image_data);

        // Now that we have an OpenGL texture, assuming our imgui rendering function (imgui_impl_xxx.cpp file) takes GLuint as ImTextureID, we can display it:
        ImGui::Image((void*)(intptr_t)my_opengl_texture, ImVec2(my_image_width, my_image_height));

    C/C++ tip: a void* is pointer-sized storage. You may safely store any pointer or integer into it by casting your value to ImTextureID / void*, and vice-versa.
    Because both end-points (user code and rendering function) are under your control, you know exactly what is stored inside the ImTextureID / void*.
    Examples:

        GLuint my_tex = XXX;
        void* my_void_ptr;
        my_void_ptr = (void*)(intptr_t)my_tex;                  // cast a GLuint into a void* (we don't take its address! we literally store the value inside the pointer)
        my_tex = (GLuint)(intptr_t)my_void_ptr;                 // cast a void* into a GLuint

        ID3D11ShaderResourceView* my_dx11_srv = XXX;
        void* my_void_ptr;
        my_void_ptr = (void*)my_dx11_srv;                       // cast a ID3D11ShaderResourceView* into an opaque void*
        my_dx11_srv = (ID3D11ShaderResourceView*)my_void_ptr;   // cast a void* into a ID3D11ShaderResourceView*

    Finally, you may call ImGui::ShowMetricsWindow() to explore/visualize/understand how the ImDrawList are generated.

 Q: Why are multiple widgets reacting when I interact with a single one?
 Q: How can I have multiple widgets with the same label or with an empty label?
 A: A primer on labels and the ID Stack...

    Dear ImGui internally need to uniquely identify UI elements.
    Elements that are typically not clickable (such as calls to the Text functions) don't need an ID.
    Interactive widgets (such as calls to Button buttons) need a unique ID.
    Unique ID are used internally to track active widgets and occasionally associate state to widgets.
    Unique ID are implicitly built from the hash of multiple elements that identify the "path" to the UI element.

   - Unique ID are often derived from a string label:

       Button("OK");          // Label = "OK",     ID = hash of (..., "OK")
       Button("Cancel");      // Label = "Cancel", ID = hash of (..., "Cancel")

   - ID are uniquely scoped within windows, tree nodes, etc. which all pushes to the ID stack. Having
     two buttons labeled "OK" in different windows or different tree locations is fine.
     We used "..." above to signify whatever was already pushed to the ID stack previously:

       Begin("MyWindow");
       Button("OK");          // Label = "OK",     ID = hash of ("MyWindow", "OK")
       End();
       Begin("MyOtherWindow");
       Button("OK");          // Label = "OK",     ID = hash of ("MyOtherWindow", "OK")
       End();

   - If you have a same ID twice in the same location, you'll have a conflict:

       Button("OK");
       Button("OK");          // ID collision! Interacting with either button will trigger the first one.

     Fear not! this is easy to solve and there are many ways to solve it!

   - Solving ID conflict in a simple/local context:
     When passing a label you can optionally specify extra ID information within string itself.
     Use "##" to pass a complement to the ID that won't be visible to the end-user.
     This helps solving the simple collision cases when you know e.g. at compilation time which items
     are going to be created:

       Begin("MyWindow");
       Button("Play");        // Label = "Play",   ID = hash of ("MyWindow", "Play")
       Button("Play##foo1");  // Label = "Play",   ID = hash of ("MyWindow", "Play##foo1")  // Different from above
       Button("Play##foo2");  // Label = "Play",   ID = hash of ("MyWindow", "Play##foo2")  // Different from above
       End();

   - If you want to completely hide the label, but still need an ID:

       Checkbox("##On", &b);  // Label = "",       ID = hash of (..., "##On")   // No visible label, just a checkbox!

   - Occasionally/rarely you might want change a label while preserving a constant ID. This allows
     you to animate labels. For example you may want to include varying information in a window title bar,
     but windows are uniquely identified by their ID. Use "###" to pass a label that isn't part of ID:

       Button("Hello###ID");  // Label = "Hello",  ID = hash of (..., "###ID")
       Button("World###ID");  // Label = "World",  ID = hash of (..., "###ID")  // Same as above, even though the label looks different

       sprintf(buf, "My game (%f FPS)###MyGame", fps);
       Begin(buf);            // Variable title,   ID = hash of "MyGame"

   - Solving ID conflict in a more general manner:
     Use PushID() / PopID() to create scopes and manipulate the ID stack, as to avoid ID conflicts
     within the same window. This is the most convenient way of distinguishing ID when iterating and
     creating many UI elements programmatically.
     You can push a pointer, a string or an integer value into the ID stack.
     Remember that ID are formed from the concatenation of _everything_ pushed into the ID stack.
     At each level of the stack we store the seed used for items at this level of the ID stack.

     Begin("Window");
       for (int i = 0; i < 100; i++)
       {
         PushID(i);           // Push i to the id tack
         Button("Click");     // Label = "Click",  ID = hash of ("Window", i, "Click")
         PopID();
       }
       for (int i = 0; i < 100; i++)
       {
         MyObject* obj = Objects[i];
         PushID(obj);
         Button("Click");     // Label = "Click",  ID = hash of ("Window", obj pointer, "Click")
         PopID();
       }
       for (int i = 0; i < 100; i++)
       {
         MyObject* obj = Objects[i];
         PushID(obj->Name);
         Button("Click");     // Label = "Click",  ID = hash of ("Window", obj->Name, "Click")
         PopID();
       }
       End();

   - You can stack multiple prefixes into the ID stack:

       Button("Click");       // Label = "Click",  ID = hash of (..., "Click")
       PushID("node");
       Button("Click");       // Label = "Click",  ID = hash of (..., "node", "Click")
         PushID(my_ptr);
           Button("Click");   // Label = "Click",  ID = hash of (..., "node", my_ptr, "Click")
         PopID();
       PopID();

   - Tree nodes implicitly creates a scope for you by calling PushID().

       Button("Click");       // Label = "Click",  ID = hash of (..., "Click")
       if (TreeNode("node"))  // <-- this function call will do a PushID() for you (unless instructed not to, with a special flag)
       {
         Button("Click");     // Label = "Click",  ID = hash of (..., "node", "Click")
         TreePop();
       }

   - When working with trees, ID are used to preserve the open/close state of each tree node.
     Depending on your use cases you may want to use strings, indices or pointers as ID.
      e.g. when following a single pointer that may change over time, using a static string as ID
       will preserve your node open/closed state when the targeted object change.
      e.g. when displaying a list of objects, using indices or pointers as ID will preserve the
       node open/closed state differently. See what makes more sense in your situation!

 Q: How can I use my own math types instead of ImVec2/ImVec4?
 A: You can edit imconfig.h and setup the IM_VEC2_CLASS_EXTRA/IM_VEC4_CLASS_EXTRA macros to add implicit type conversions.
    This way you'll be able to use your own types everywhere, e.g. passing glm::vec2 to ImGui functions instead of ImVec2.

 Q: How can I load a different font than the default?
 A: Use the font atlas to load the TTF/OTF file you want:
      ImGuiIO& io = ImGui::GetIO();
      io.Fonts->AddFontFromFileTTF("myfontfile.ttf", size_in_pixels);
      io.Fonts->GetTexDataAsRGBA32() or GetTexDataAsAlpha8()
    Default is ProggyClean.ttf, monospace, rendered at size 13, embedded in dear imgui's source code.
    (Tip: monospace fonts are convenient because they allow to facilitate horizontal alignment directly at the string level.)
    (Read the 'misc/fonts/README.txt' file for more details about font loading.)

    New programmers: remember that in C/C++ and most programming languages if you want to use a
    backslash \ within a string literal, you need to write it double backslash "\\":
      io.Fonts->AddFontFromFileTTF("MyDataFolder\MyFontFile.ttf", size_in_pixels);   // WRONG (you are escape the M here!)
      io.Fonts->AddFontFromFileTTF("MyDataFolder\\MyFontFile.ttf", size_in_pixels);  // CORRECT
      io.Fonts->AddFontFromFileTTF("MyDataFolder/MyFontFile.ttf", size_in_pixels);   // ALSO CORRECT

 Q: How can I easily use icons in my application?
 A: The most convenient and practical way is to merge an icon font such as FontAwesome inside you
    main font. Then you can refer to icons within your strings.
    You may want to see ImFontConfig::GlyphMinAdvanceX to make your icon look monospace to facilitate alignment.
    (Read the 'misc/fonts/README.txt' file for more details about icons font loading.)

 Q: How can I load multiple fonts?
 A: Use the font atlas to pack them into a single texture:
    (Read the 'misc/fonts/README.txt' file and the code in ImFontAtlas for more details.)

      ImGuiIO& io = ImGui::GetIO();
      ImFont* font0 = io.Fonts->AddFontDefault();
      ImFont* font1 = io.Fonts->AddFontFromFileTTF("myfontfile.ttf", size_in_pixels);
      ImFont* font2 = io.Fonts->AddFontFromFileTTF("myfontfile2.ttf", size_in_pixels);
      io.Fonts->GetTexDataAsRGBA32() or GetTexDataAsAlpha8()
      // the first loaded font gets used by default
      // use ImGui::PushFont()/ImGui::PopFont() to change the font at runtime

      // Options
      ImFontConfig config;
      config.OversampleH = 2;
      config.OversampleV = 1;
      config.GlyphOffset.y -= 1.0f;      // Move everything by 1 pixels up
      config.GlyphExtraSpacing.x = 1.0f; // Increase spacing between characters
      io.Fonts->AddFontFromFileTTF("myfontfile.ttf", size_pixels, &config);

      // Combine multiple fonts into one (e.g. for icon fonts)
      static ImWchar ranges[] = { 0xf000, 0xf3ff, 0 };
      ImFontConfig config;
      config.MergeMode = true;
      io.Fonts->AddFontDefault();
      io.Fonts->AddFontFromFileTTF("fontawesome-webfont.ttf", 16.0f, &config, ranges); // Merge icon font
      io.Fonts->AddFontFromFileTTF("myfontfile.ttf", size_pixels, NULL, &config, io.Fonts->GetGlyphRangesJapanese()); // Merge japanese glyphs

 Q: How can I display and input non-Latin characters such as Chinese, Japanese, Korean, Cyrillic?
 A: When loading a font, pass custom Unicode ranges to specify the glyphs to load.

      // Add default Japanese ranges
      io.Fonts->AddFontFromFileTTF("myfontfile.ttf", size_in_pixels, NULL, io.Fonts->GetGlyphRangesJapanese());

      // Or create your own custom ranges (e.g. for a game you can feed your entire game script and only build the characters the game need)
      ImVector<ImWchar> ranges;
      ImFontGlyphRangesBuilder builder;
      builder.AddText("Hello world");                        // Add a string (here "Hello world" contains 7 unique characters)
      builder.AddChar(0x7262);                               // Add a specific character
      builder.AddRanges(io.Fonts->GetGlyphRangesJapanese()); // Add one of the default ranges
      builder.BuildRanges(&ranges);                          // Build the final result (ordered ranges with all the unique characters submitted)
      io.Fonts->AddFontFromFileTTF("myfontfile.ttf", size_in_pixels, NULL, ranges.Data);

    All your strings needs to use UTF-8 encoding. In C++11 you can encode a string literal in UTF-8
    by using the u8"hello" syntax. Specifying literal in your source code using a local code page
    (such as CP-923 for Japanese or CP-1251 for Cyrillic) will NOT work!
    Otherwise you can convert yourself to UTF-8 or load text data from file already saved as UTF-8.

    Text input: it is up to your application to pass the right character code by calling io.AddInputCharacter().
    The applications in examples/ are doing that.
    Windows: you can use the WM_CHAR or WM_UNICHAR or WM_IME_CHAR message (depending if your app is built using Unicode or MultiByte mode).
    You may also use MultiByteToWideChar() or ToUnicode() to retrieve Unicode codepoints from MultiByte characters or keyboard state.
    Windows: if your language is relying on an Input Method Editor (IME), you copy the HWND of your window to io.ImeWindowHandle in order for
    the default implementation of io.ImeSetInputScreenPosFn() to set your Microsoft IME position correctly.

 Q: How can I interact with standard C++ types (such as std::string and std::vector)?
 A: - Being highly portable (bindings for several languages, frameworks, programming style, obscure or older platforms/compilers),
      and aiming for compatibility & performance suitable for every modern real-time game engines, dear imgui does not use
      any of std C++ types. We use raw types (e.g. char* instead of std::string) because they adapt to more use cases.
    - To use ImGui::InputText() with a std::string or any resizable string class, see misc/cpp/imgui_stdlib.h.
    - To use combo boxes and list boxes with std::vector or any other data structure: the BeginCombo()/EndCombo() API
      lets you iterate and submit items yourself, so does the ListBoxHeader()/ListBoxFooter() API.
      Prefer using them over the old and awkward Combo()/ListBox() api.
    - Generally for most high-level types you should be able to access the underlying data type.
      You may write your own one-liner wrappers to facilitate user code (tip: add new functions in ImGui:: namespace from your code).
    - Dear ImGui applications often need to make intensive use of strings. It is expected that many of the strings you will pass
      to the API are raw literals (free in C/C++) or allocated in a manner that won't incur a large cost on your application.
      Please bear in mind that using std::string on applications with large amount of UI may incur unsatisfactory performances.
      Modern implementations of std::string often include small-string optimization (which is often a local buffer) but those
      are not configurable and not the same across implementations.
    - If you are finding your UI traversal cost to be too large, make sure your string usage is not leading to excessive amount
      of heap allocations. Consider using literals, statically sized buffers and your own helper functions. A common pattern
      is that you will need to build lots of strings on the fly, and their maximum length can be easily be scoped ahead.
      One possible implementation of a helper to facilitate printf-style building of strings: https://github.com/ocornut/Str
      This is a small helper where you can instance strings with configurable local buffers length. Many game engines will
      provide similar or better string helpers.

 Q: How can I use the drawing facilities without an ImGui window? (using ImDrawList API)
 A: - You can create a dummy window. Call Begin() with the NoBackground | NoDecoration | NoSavedSettings | NoInputs flags.
      (The ImGuiWindowFlags_NoDecoration flag itself is a shortcut for NoTitleBar | NoResize | NoScrollbar | NoCollapse)
      Then you can retrieve the ImDrawList* via GetWindowDrawList() and draw to it in any way you like.
    - You can call ImGui::GetBackgroundDrawList() or ImGui::GetForegroundDrawList() and use those draw list to display
      contents behind or over every other imgui windows (one bg/fg drawlist per viewport).
    - You can create your own ImDrawList instance. You'll need to initialize them ImGui::GetDrawListSharedData(), or create
      your own ImDrawListSharedData, and then call your rendered code with your own ImDrawList or ImDrawData data.

 Q: How can I use this without a mouse, without a keyboard or without a screen? (gamepad, input share, remote display)
 A: - You can control Dear ImGui with a gamepad. Read about navigation in "Using gamepad/keyboard navigation controls".
      (short version: map gamepad inputs into the io.NavInputs[] array + set io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad)
    - You can share your computer mouse seamlessly with your console/tablet/phone using Synergy (https://symless.com/synergy)
      This is the preferred solution for developer productivity.
      In particular, the "micro-synergy-client" repository (https://github.com/symless/micro-synergy-client) has simple
      and portable source code (uSynergy.c/.h) for a small embeddable client that you can use on any platform to connect
      to your host computer, based on the Synergy 1.x protocol. Make sure you download the Synergy 1 server on your computer.
      Console SDK also sometimes provide equivalent tooling or wrapper for Synergy-like protocols.
    - You may also use a third party solution such as Remote ImGui (https://github.com/JordiRos/remoteimgui) which sends
      the vertices to render over the local network, allowing you to use Dear ImGui even on a screen-less machine.
    - For touch inputs, you can increase the hit box of widgets (via the style.TouchPadding setting) to accommodate
      for the lack of precision of touch inputs, but it is recommended you use a mouse or gamepad to allow optimizing
      for screen real-estate and precision.

 Q: I integrated Dear ImGui in my engine and the text or lines are blurry..
 A: In your Render function, try translating your projection matrix by (0.5f,0.5f) or (0.375f,0.375f).
    Also make sure your orthographic projection matrix and io.DisplaySize matches your actual framebuffer dimension.

 Q: I integrated Dear ImGui in my engine and some elements are clipping or disappearing when I move windows around..
 A: You are probably mishandling the clipping rectangles in your render function.
    Rectangles provided by ImGui are defined as (x1=left,y1=top,x2=right,y2=bottom) and NOT as (x1,y1,width,height).

 Q: How can I help?
 A: - If you are experienced with Dear ImGui and C++, look at the github issues, look at the Wiki, read docs/TODO.txt
      and see how you want to help and can help!
    - Businesses: convince your company to fund development via support contracts/sponsoring! This is among the most useful thing you can do for dear imgui.
    - Individuals: you can also become a Patron (http://www.patreon.com/imgui) or donate on PayPal! See README.
    - Disclose your usage of dear imgui via a dev blog post, a tweet, a screenshot, a mention somewhere etc.
      You may post screenshot or links in the gallery threads (github.com/ocornut/imgui/issues/1902). Visuals are ideal as they inspire other programmers.
      But even without visuals, disclosing your use of dear imgui help the library grow credibility, and help other teams and programmers with taking decisions.
    - If you have issues or if you need to hack into the library, even if you don't expect any support it is useful that you share your issues (on github or privately).

 - tip: you can call Begin() multiple times with the same name during the same frame, it will keep appending to the same window.
        this is also useful to set yourself in the context of another window (to get/set other settings)
 - tip: you can create widgets without a Begin()/End() block, they will go in an implicit window called "Debug".
 - tip: the ImGuiOnceUponAFrame helper will allow run the block of code only once a frame. You can use it to quickly add custom UI in the middle
        of a deep nested inner loop in your code.
 - tip: you can call Render() multiple times (e.g for VR renders).
 - tip: call and read the ShowDemoWindow() code in imgui_demo.cpp for more example of how to use ImGui!

*/

#include "pch.h"
#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS
#endif

#include "imgui.h"
#ifndef IMGUI_DEFINE_MATH_OPERATORS
#define IMGUI_DEFINE_MATH_OPERATORS
#endif
#include "imgui_internal.h"

#include <ctype.h>      // toupper
#include <stdio.h>      // vsnprintf, sscanf, printf
#if defined(_MSC_VER) && _MSC_VER <= 1500 // MSVC 2008 or earlier
#include <stddef.h>     // intptr_t
#else
#include <stdint.h>     // intptr_t
#endif

// Debug options
#define IMGUI_DEBUG_NAV_SCORING     0   // Display navigation scoring preview when hovering items. Display last moving direction matches when holding CTRL
#define IMGUI_DEBUG_NAV_RECTS       0   // Display the reference navigation rectangle for each window

// Visual Studio warnings
#ifdef _MSC_VER
#pragma warning (disable: 4127)     // condition expression is constant
#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen
#endif

// Clang/GCC warnings with -Weverything
#ifdef __clang__
#pragma clang diagnostic ignored "-Wunknown-pragmas"        // warning : unknown warning group '-Wformat-pedantic *'        // not all warnings are known by all clang versions.. so ignoring warnings triggers new warnings on some configuration. great!
#pragma clang diagnostic ignored "-Wold-style-cast"         // warning : use of old-style cast                              // yes, they are more terse.
#pragma clang diagnostic ignored "-Wfloat-equal"            // warning : comparing floating point with == or != is unsafe   // storing and comparing against same constants (typically 0.0f) is ok.
#pragma clang diagnostic ignored "-Wformat-nonliteral"      // warning : format string is not a string literal              // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.
#pragma clang diagnostic ignored "-Wexit-time-destructors"  // warning : declaration requires an exit-time destructor       // exit-time destruction order is undefined. if MemFree() leads to users code that has been disabled before exit it might cause problems. ImGui coding style welcomes static/globals.
#pragma clang diagnostic ignored "-Wglobal-constructors"    // warning : declaration requires a global destructor           // similar to above, not sure what the exact difference is.
#pragma clang diagnostic ignored "-Wsign-conversion"        // warning : implicit conversion changes signedness             //
#pragma clang diagnostic ignored "-Wformat-pedantic"        // warning : format specifies type 'void *' but the argument has type 'xxxx *' // unreasonable, would lead to casting every %p arg to void*. probably enabled by -pedantic.
#pragma clang diagnostic ignored "-Wint-to-void-pointer-cast"       // warning : cast to 'void *' from smaller integer type 'int'
#if __has_warning("-Wzero-as-null-pointer-constant")
#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"  // warning : zero as null pointer constant              // some standard header variations use #define NULL 0
#endif
#if __has_warning("-Wdouble-promotion")
#pragma clang diagnostic ignored "-Wdouble-promotion"       // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.
#endif
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wunused-function"          // warning: 'xxxx' defined but not used
#pragma GCC diagnostic ignored "-Wint-to-pointer-cast"      // warning: cast to pointer from integer of different size
#pragma GCC diagnostic ignored "-Wformat"                   // warning: format '%p' expects argument of type 'void*', but argument 6 has type 'ImGuiWindow*'
#pragma GCC diagnostic ignored "-Wdouble-promotion"         // warning: implicit conversion from 'float' to 'double' when passing argument to function
#pragma GCC diagnostic ignored "-Wconversion"               // warning: conversion to 'xxxx' from 'xxxx' may alter its value
#pragma GCC diagnostic ignored "-Wformat-nonliteral"        // warning: format not a string literal, format string not checked
#pragma GCC diagnostic ignored "-Wstrict-overflow"          // warning: assuming signed overflow does not occur when assuming that (X - c) > X is always false
#if __GNUC__ >= 8
#pragma GCC diagnostic ignored "-Wclass-memaccess"          // warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead
#endif
#endif

// When using CTRL+TAB (or Gamepad Square+L/R) we delay the visual a little in order to reduce visual noise doing a fast switch.
static const float NAV_WINDOWING_HIGHLIGHT_DELAY            = 0.20f;    // Time before the highlight and screen dimming starts fading in
static const float NAV_WINDOWING_LIST_APPEAR_DELAY          = 0.15f;    // Time before the window list starts to appear

// Window resizing from edges (when io.ConfigWindowsResizeFromEdges = true and ImGuiBackendFlags_HasMouseCursors is set in io.BackendFlags by back-end)
static const float WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS = 4.0f;     // Extend outside and inside windows. Affect FindHoveredWindow().
static const float WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER = 0.04f;    // Reduce visual noise by only highlighting the border after a certain time.

//-------------------------------------------------------------------------
// [SECTION] FORWARD DECLARATIONS
//-------------------------------------------------------------------------

static void             SetCurrentWindow(ImGuiWindow* window);
static void             FindHoveredWindow();
static ImGuiWindow*     CreateNewWindow(const char* name, ImVec2 size, ImGuiWindowFlags flags);
static void             CheckStacksSize(ImGuiWindow* window, bool write);
static ImVec2           CalcNextScrollFromScrollTargetAndClamp(ImGuiWindow* window, bool snap_on_edges);

static void             AddDrawListToDrawData(ImVector<ImDrawList*>* out_list, ImDrawList* draw_list);
static void             AddWindowToSortBuffer(ImVector<ImGuiWindow*>* out_sorted_windows, ImGuiWindow* window);

static ImRect           GetViewportRect();

// Settings
static void*            SettingsHandlerWindow_ReadOpen(ImGuiContext*, ImGuiSettingsHandler*, const char* name);
static void             SettingsHandlerWindow_ReadLine(ImGuiContext*, ImGuiSettingsHandler*, void* entry, const char* line);
static void             SettingsHandlerWindow_WriteAll(ImGuiContext* imgui_ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* buf);

// Platform Dependents default implementation for IO functions
static const char*      GetClipboardTextFn_DefaultImpl(void* user_data);
static void             SetClipboardTextFn_DefaultImpl(void* user_data, const char* text);
static void             ImeSetInputScreenPosFn_DefaultImpl(int x, int y);

namespace ImGui
{
static bool             BeginChildEx(const char* name, ImGuiID id, const ImVec2& size_arg, bool border, ImGuiWindowFlags flags);

// Navigation
static void             NavUpdate();
static void             NavUpdateWindowing();
static void             NavUpdateWindowingList();
static void             NavUpdateMoveResult();
static float            NavUpdatePageUpPageDown(int allowed_dir_flags);
static inline void      NavUpdateAnyRequestFlag();
static void             NavProcessItem(ImGuiWindow* window, const ImRect& nav_bb, ImGuiID id);
static ImVec2           NavCalcPreferredRefPos();
static void             NavSaveLastChildNavWindowIntoParent(ImGuiWindow* nav_window);
static ImGuiWindow*     NavRestoreLastChildNavWindow(ImGuiWindow* window);
static int              FindWindowFocusIndex(ImGuiWindow* window);

// Misc
static void             UpdateMouseInputs();
static void             UpdateMouseWheel();
static void             UpdateManualResize(ImGuiWindow* window, const ImVec2& size_auto_fit, int* border_held, int resize_grip_count, ImU32 resize_grip_col[4]);
static void             RenderOuterBorders(ImGuiWindow* window);

}

//-----------------------------------------------------------------------------
// [SECTION] CONTEXT AND MEMORY ALLOCATORS
//-----------------------------------------------------------------------------

// Current context pointer. Implicitly used by all Dear ImGui functions. Always assumed to be != NULL.
// ImGui::CreateContext() will automatically set this pointer if it is NULL. Change to a different context by calling ImGui::SetCurrentContext().
// 1) Important: globals are not shared across DLL boundaries! If you use DLLs or any form of hot-reloading: you will need to call
//    SetCurrentContext() (with the pointer you got from CreateContext) from each unique static/DLL boundary, and after each hot-reloading.
//    In your debugger, add GImGui to your watch window and notice how its value changes depending on which location you are currently stepping into.
// 2) Important: Dear ImGui functions are not thread-safe because of this pointer.
//    If you want thread-safety to allow N threads to access N different contexts, you can:
//    - Change this variable to use thread local storage so each thread can refer to a different context, in imconfig.h:
//          struct ImGuiContext;
//          extern thread_local ImGuiContext* MyImGuiTLS;
//          #define GImGui MyImGuiTLS
//      And then define MyImGuiTLS in one of your cpp file. Note that thread_local is a C++11 keyword, earlier C++ uses compiler-specific keyword.
//    - Future development aim to make this context pointer explicit to all calls. Also read https://github.com/ocornut/imgui/issues/586
//    - If you need a finite number of contexts, you may compile and use multiple instances of the ImGui code from different namespace.
#ifndef GImGui
ImGuiContext*   GImGui = NULL;
#endif

// Memory Allocator functions. Use SetAllocatorFunctions() to change them.
// If you use DLL hotreloading you might need to call SetAllocatorFunctions() after reloading code from this file.
// Otherwise, you probably don't want to modify them mid-program, and if you use global/static e.g. ImVector<> instances you may need to keep them accessible during program destruction.
#ifndef IMGUI_DISABLE_DEFAULT_ALLOCATORS
static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }
static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }
#else
static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); IM_UNUSED(size); IM_ASSERT(0); return NULL; }
static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); IM_UNUSED(ptr); IM_ASSERT(0); }
#endif

static void*  (*GImAllocatorAllocFunc)(size_t size, void* user_data) = MallocWrapper;
static void   (*GImAllocatorFreeFunc)(void* ptr, void* user_data) = FreeWrapper;
static void*    GImAllocatorUserData = NULL;

//-----------------------------------------------------------------------------
// [SECTION] MAIN USER FACING STRUCTURES (ImGuiStyle, ImGuiIO)
//-----------------------------------------------------------------------------

ImGuiStyle::ImGuiStyle()
{
    Alpha                   = 1.0f;             // Global alpha applies to everything in ImGui
    WindowPadding           = ImVec2(8,8);      // Padding within a window
    WindowRounding          = 7.0f;             // Radius of window corners rounding. Set to 0.0f to have rectangular windows
    WindowBorderSize        = 1.0f;             // Thickness of border around windows. Generally set to 0.0f or 1.0f. Other values not well tested.
    WindowMinSize           = ImVec2(32,32);    // Minimum window size
    WindowTitleAlign        = ImVec2(0.0f,0.5f);// Alignment for title bar text
    ChildRounding           = 0.0f;             // Radius of child window corners rounding. Set to 0.0f to have rectangular child windows
    ChildBorderSize         = 1.0f;             // Thickness of border around child windows. Generally set to 0.0f or 1.0f. Other values not well tested.
    PopupRounding           = 0.0f;             // Radius of popup window corners rounding. Set to 0.0f to have rectangular child windows
    PopupBorderSize         = 1.0f;             // Thickness of border around popup or tooltip windows. Generally set to 0.0f or 1.0f. Other values not well tested.
    FramePadding            = ImVec2(4,3);      // Padding within a framed rectangle (used by most widgets)
    FrameRounding           = 0.0f;             // Radius of frame corners rounding. Set to 0.0f to have rectangular frames (used by most widgets).
    FrameBorderSize         = 0.0f;             // Thickness of border around frames. Generally set to 0.0f or 1.0f. Other values not well tested.
    ItemSpacing             = ImVec2(8,4);      // Horizontal and vertical spacing between widgets/lines
    ItemInnerSpacing        = ImVec2(4,4);      // Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label)
    TouchExtraPadding       = ImVec2(0,0);      // Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!
    IndentSpacing           = 21.0f;            // Horizontal spacing when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).
    ColumnsMinSpacing       = 6.0f;             // Minimum horizontal spacing between two columns
    ScrollbarSize           = 16.0f;            // Width of the vertical scrollbar, Height of the horizontal scrollbar
    ScrollbarRounding       = 9.0f;             // Radius of grab corners rounding for scrollbar
    GrabMinSize             = 10.0f;            // Minimum width/height of a grab box for slider/scrollbar
    GrabRounding            = 0.0f;             // Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.
    TabRounding             = 4.0f;             // Radius of upper corners of a tab. Set to 0.0f to have rectangular tabs.
    TabBorderSize           = 0.0f;             // Thickness of border around tabs.
    ButtonTextAlign         = ImVec2(0.5f,0.5f);// Alignment of button text when button is larger than text.
    SelectableTextAlign     = ImVec2(0.0f,0.0f);// Alignment of selectable text when button is larger than text.
    DisplayWindowPadding    = ImVec2(19,19);    // Window position are clamped to be visible within the display area by at least this amount. Only applies to regular windows.
    DisplaySafeAreaPadding  = ImVec2(3,3);      // If you cannot see the edge of your screen (e.g. on a TV) increase the safe area padding. Covers popups/tooltips as well regular windows.
    MouseCursorScale        = 1.0f;             // Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). May be removed later.
    AntiAliasedLines        = true;             // Enable anti-aliasing on lines/borders. Disable if you are really short on CPU/GPU.
    AntiAliasedFill         = true;             // Enable anti-aliasing on filled shapes (rounded rectangles, circles, etc.)
    CurveTessellationTol    = 1.25f;            // Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.

    // Default theme
    ImGui::StyleColorsDark(this);
}

// To scale your entire UI (e.g. if you want your app to use High DPI or generally be DPI aware) you may use this helper function. Scaling the fonts is done separately and is up to you.
// Important: This operation is lossy because we round all sizes to integer. If you need to change your scale multiples, call this over a freshly initialized ImGuiStyle structure rather than scaling multiple times.
void ImGuiStyle::ScaleAllSizes(float scale_factor)
{
    WindowPadding = ImFloor(WindowPadding * scale_factor);
    WindowRounding = ImFloor(WindowRounding * scale_factor);
    WindowMinSize = ImFloor(WindowMinSize * scale_factor);
    ChildRounding = ImFloor(ChildRounding * scale_factor);
    PopupRounding = ImFloor(PopupRounding * scale_factor);
    FramePadding = ImFloor(FramePadding * scale_factor);
    FrameRounding = ImFloor(FrameRounding * scale_factor);
    ItemSpacing = ImFloor(ItemSpacing * scale_factor);
    ItemInnerSpacing = ImFloor(ItemInnerSpacing * scale_factor);
    TouchExtraPadding = ImFloor(TouchExtraPadding * scale_factor);
    IndentSpacing = ImFloor(IndentSpacing * scale_factor);
    ColumnsMinSpacing = ImFloor(ColumnsMinSpacing * scale_factor);
    ScrollbarSize = ImFloor(ScrollbarSize * scale_factor);
    ScrollbarRounding = ImFloor(ScrollbarRounding * scale_factor);
    GrabMinSize = ImFloor(GrabMinSize * scale_factor);
    GrabRounding = ImFloor(GrabRounding * scale_factor);
    TabRounding = ImFloor(TabRounding * scale_factor);
    DisplayWindowPadding = ImFloor(DisplayWindowPadding * scale_factor);
    DisplaySafeAreaPadding = ImFloor(DisplaySafeAreaPadding * scale_factor);
    MouseCursorScale = ImFloor(MouseCursorScale * scale_factor);
}

ImGuiIO::ImGuiIO()
{
    // Most fields are initialized with zero
    memset(this, 0, sizeof(*this));

    // Settings
    ConfigFlags = ImGuiConfigFlags_None;
    BackendFlags = ImGuiBackendFlags_None;
    DisplaySize = ImVec2(-1.0f, -1.0f);
    DeltaTime = 1.0f/60.0f;
    IniSavingRate = 5.0f;
    IniFilename = "imgui.ini";
    LogFilename = "imgui_log.txt";
    MouseDoubleClickTime = 0.30f;
    MouseDoubleClickMaxDist = 6.0f;
    for (int i = 0; i < ImGuiKey_COUNT; i++)
        KeyMap[i] = -1;
    KeyRepeatDelay = 0.250f;
    KeyRepeatRate = 0.050f;
    UserData = NULL;

    Fonts = NULL;
    FontGlobalScale = 1.0f;
    FontDefault = NULL;
    FontAllowUserScaling = false;
    DisplayFramebufferScale = ImVec2(1.0f, 1.0f);

    // Miscellaneous options
    MouseDrawCursor = false;
#ifdef __APPLE__
    ConfigMacOSXBehaviors = true;  // Set Mac OS X style defaults based on __APPLE__ compile time flag
#else
    ConfigMacOSXBehaviors = false;
#endif
    ConfigInputTextCursorBlink = true;
    ConfigWindowsResizeFromEdges = true;
    ConfigWindowsMoveFromTitleBarOnly = false;

    // Platform Functions
    BackendPlatformName = BackendRendererName = NULL;
    BackendPlatformUserData = BackendRendererUserData = BackendLanguageUserData = NULL;
    GetClipboardTextFn = GetClipboardTextFn_DefaultImpl;   // Platform dependent default implementations
    SetClipboardTextFn = SetClipboardTextFn_DefaultImpl;
    ClipboardUserData = NULL;
    ImeSetInputScreenPosFn = ImeSetInputScreenPosFn_DefaultImpl;
    ImeWindowHandle = NULL;

#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    RenderDrawListsFn = NULL;
#endif

    // Input (NB: we already have memset zero the entire structure!)
    MousePos = ImVec2(-FLT_MAX, -FLT_MAX);
    MousePosPrev = ImVec2(-FLT_MAX, -FLT_MAX);
    MouseDragThreshold = 6.0f;
    for (int i = 0; i < IM_ARRAYSIZE(MouseDownDuration); i++) MouseDownDuration[i] = MouseDownDurationPrev[i] = -1.0f;
    for (int i = 0; i < IM_ARRAYSIZE(KeysDownDuration); i++) KeysDownDuration[i]  = KeysDownDurationPrev[i] = -1.0f;
    for (int i = 0; i < IM_ARRAYSIZE(NavInputsDownDuration); i++) NavInputsDownDuration[i] = -1.0f;
}

// Pass in translated ASCII characters for text input.
// - with glfw you can get those from the callback set in glfwSetCharCallback()
// - on Windows you can get those using ToAscii+keyboard state, or via the WM_CHAR message
void ImGuiIO::AddInputCharacter(ImWchar c)
{
    InputQueueCharacters.push_back(c);
}

void ImGuiIO::AddInputCharactersUTF8(const char* utf8_chars)
{
    while (*utf8_chars != 0)
    {
        unsigned int c = 0;
        utf8_chars += ImTextCharFromUtf8(&c, utf8_chars, NULL);
        if (c > 0 && c <= 0xFFFF)
            InputQueueCharacters.push_back((ImWchar)c);
    }
}

void ImGuiIO::ClearInputCharacters()
{
    InputQueueCharacters.resize(0);
}

//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILITIES (Maths, String, Format, Hash, File functions)
//-----------------------------------------------------------------------------

ImVec2 ImLineClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& p)
{
    ImVec2 ap = p - a;
    ImVec2 ab_dir = b - a;
    float dot = ap.x * ab_dir.x + ap.y * ab_dir.y;
    if (dot < 0.0f)
        return a;
    float ab_len_sqr = ab_dir.x * ab_dir.x + ab_dir.y * ab_dir.y;
    if (dot > ab_len_sqr)
        return b;
    return a + ab_dir * dot / ab_len_sqr;
}

bool ImTriangleContainsPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p)
{
    bool b1 = ((p.x - b.x) * (a.y - b.y) - (p.y - b.y) * (a.x - b.x)) < 0.0f;
    bool b2 = ((p.x - c.x) * (b.y - c.y) - (p.y - c.y) * (b.x - c.x)) < 0.0f;
    bool b3 = ((p.x - a.x) * (c.y - a.y) - (p.y - a.y) * (c.x - a.x)) < 0.0f;
    return ((b1 == b2) && (b2 == b3));
}

void ImTriangleBarycentricCoords(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p, float& out_u, float& out_v, float& out_w)
{
    ImVec2 v0 = b - a;
    ImVec2 v1 = c - a;
    ImVec2 v2 = p - a;
    const float denom = v0.x * v1.y - v1.x * v0.y;
    out_v = (v2.x * v1.y - v1.x * v2.y) / denom;
    out_w = (v0.x * v2.y - v2.x * v0.y) / denom;
    out_u = 1.0f - out_v - out_w;
}

ImVec2 ImTriangleClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p)
{
    ImVec2 proj_ab = ImLineClosestPoint(a, b, p);
    ImVec2 proj_bc = ImLineClosestPoint(b, c, p);
    ImVec2 proj_ca = ImLineClosestPoint(c, a, p);
    float dist2_ab = ImLengthSqr(p - proj_ab);
    float dist2_bc = ImLengthSqr(p - proj_bc);
    float dist2_ca = ImLengthSqr(p - proj_ca);
    float m = ImMin(dist2_ab, ImMin(dist2_bc, dist2_ca));
    if (m == dist2_ab)
        return proj_ab;
    if (m == dist2_bc)
        return proj_bc;
    return proj_ca;
}

// Consider using _stricmp/_strnicmp under Windows or strcasecmp/strncasecmp. We don't actually use either ImStricmp/ImStrnicmp in the codebase any more.
int ImStricmp(const char* str1, const char* str2)
{
    int d;
    while ((d = toupper(*str2) - toupper(*str1)) == 0 && *str1) { str1++; str2++; }
    return d;
}

int ImStrnicmp(const char* str1, const char* str2, size_t count)
{
    int d = 0;
    while (count > 0 && (d = toupper(*str2) - toupper(*str1)) == 0 && *str1) { str1++; str2++; count--; }
    return d;
}

void ImStrncpy(char* dst, const char* src, size_t count)
{
    if (count < 1)
        return;
    if (count > 1)
        strncpy(dst, src, count - 1);
    dst[count - 1] = 0;
}

char* ImStrdup(const char* str)
{
    size_t len = strlen(str);
    void* buf = IM_ALLOC(len + 1);
    return (char*)memcpy(buf, (const void*)str, len + 1);
}

char* ImStrdupcpy(char* dst, size_t* p_dst_size, const char* src)
{
    size_t dst_buf_size = p_dst_size ? *p_dst_size : strlen(dst) + 1;
    size_t src_size = strlen(src) + 1;
    if (dst_buf_size < src_size)
    {
        IM_FREE(dst);
        dst = (char*)IM_ALLOC(src_size);
        if (p_dst_size)
            *p_dst_size = src_size;
    }
    return (char*)memcpy(dst, (const void*)src, src_size);
}

const char* ImStrchrRange(const char* str, const char* str_end, char c)
{
    const char* p = (const char*)memchr(str, (int)c, str_end - str);
    return p;
}

int ImStrlenW(const ImWchar* str)
{
    //return (int)wcslen((const wchar_t*)str);  // FIXME-OPT: Could use this when wchar_t are 16-bits
    int n = 0;
    while (*str++) n++;
    return n;
}

// Find end-of-line. Return pointer will point to either first \n, either str_end.
const char* ImStreolRange(const char* str, const char* str_end)
{
    const char* p = (const char*)memchr(str, '\n', str_end - str);
    return p ? p : str_end;
}

const ImWchar* ImStrbolW(const ImWchar* buf_mid_line, const ImWchar* buf_begin) // find beginning-of-line
{
    while (buf_mid_line > buf_begin && buf_mid_line[-1] != '\n')
        buf_mid_line--;
    return buf_mid_line;
}

const char* ImStristr(const char* haystack, const char* haystack_end, const char* needle, const char* needle_end)
{
    if (!needle_end)
        needle_end = needle + strlen(needle);

    const char un0 = (char)toupper(*needle);
    while ((!haystack_end && *haystack) || (haystack_end && haystack < haystack_end))
    {
        if (toupper(*haystack) == un0)
        {
            const char* b = needle + 1;
            for (const char* a = haystack + 1; b < needle_end; a++, b++)
                if (toupper(*a) != toupper(*b))
                    break;
            if (b == needle_end)
                return haystack;
        }
        haystack++;
    }
    return NULL;
}

// Trim str by offsetting contents when there's leading data + writing a \0 at the trailing position. We use this in situation where the cost is negligible.
void ImStrTrimBlanks(char* buf)
{
    char* p = buf;
    while (p[0] == ' ' || p[0] == '\t')     // Leading blanks
        p++;
    char* p_start = p;
    while (*p != 0)                         // Find end of string
        p++;
    while (p > p_start && (p[-1] == ' ' || p[-1] == '\t'))  // Trailing blanks
        p--;
    if (p_start != buf)                     // Copy memory if we had leading blanks
        memmove(buf, p_start, p - p_start);
    buf[p - p_start] = 0;                   // Zero terminate
}

// A) MSVC version appears to return -1 on overflow, whereas glibc appears to return total count (which may be >= buf_size).
// Ideally we would test for only one of those limits at runtime depending on the behavior the vsnprintf(), but trying to deduct it at compile time sounds like a pandora can of worm.
// B) When buf==NULL vsnprintf() will return the output size.
#ifndef IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS

//#define IMGUI_USE_STB_SPRINTF
#ifdef IMGUI_USE_STB_SPRINTF
#define STB_SPRINTF_IMPLEMENTATION
#include "imstb_sprintf.h"
#endif

#if defined(_MSC_VER) && !defined(vsnprintf)
#define vsnprintf _vsnprintf
#endif

int ImFormatString(char* buf, size_t buf_size, const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
#ifdef IMGUI_USE_STB_SPRINTF
    int w = stbsp_vsnprintf(buf, (int)buf_size, fmt, args);
#else
    int w = vsnprintf(buf, buf_size, fmt, args);
#endif
    va_end(args);
    if (buf == NULL)
        return w;
    if (w == -1 || w >= (int)buf_size)
        w = (int)buf_size - 1;
    buf[w] = 0;
    return w;
}

int ImFormatStringV(char* buf, size_t buf_size, const char* fmt, va_list args)
{
#ifdef IMGUI_USE_STB_SPRINTF
    int w = stbsp_vsnprintf(buf, (int)buf_size, fmt, args);
#else
    int w = vsnprintf(buf, buf_size, fmt, args);
#endif
    if (buf == NULL)
        return w;
    if (w == -1 || w >= (int)buf_size)
        w = (int)buf_size - 1;
    buf[w] = 0;
    return w;
}
#endif // #ifdef IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS

// CRC32 needs a 1KB lookup table (not cache friendly)
// Although the code to generate the table is simple and shorter than the table itself, using a const table allows us to easily:
// - avoid an unnecessary branch/memory tap, - keep the ImHashXXX functions usable by static constructors, - make it thread-safe.
static const ImU32 GCrc32LookupTable[256] =
{
    0x00000000,0x77073096,0xEE0E612C,0x990951BA,0x076DC419,0x706AF48F,0xE963A535,0x9E6495A3,0x0EDB8832,0x79DCB8A4,0xE0D5E91E,0x97D2D988,0x09B64C2B,0x7EB17CBD,0xE7B82D07,0x90BF1D91,
    0x1DB71064,0x6AB020F2,0xF3B97148,0x84BE41DE,0x1ADAD47D,0x6DDDE4EB,0xF4D4B551,0x83D385C7,0x136C9856,0x646BA8C0,0xFD62F97A,0x8A65C9EC,0x14015C4F,0x63066CD9,0xFA0F3D63,0x8D080DF5,
    0x3B6E20C8,0x4C69105E,0xD56041E4,0xA2677172,0x3C03E4D1,0x4B04D447,0xD20D85FD,0xA50AB56B,0x35B5A8FA,0x42B2986C,0xDBBBC9D6,0xACBCF940,0x32D86CE3,0x45DF5C75,0xDCD60DCF,0xABD13D59,
    0x26D930AC,0x51DE003A,0xC8D75180,0xBFD06116,0x21B4F4B5,0x56B3C423,0xCFBA9599,0xB8BDA50F,0x2802B89E,0x5F058808,0xC60CD9B2,0xB10BE924,0x2F6F7C87,0x58684C11,0xC1611DAB,0xB6662D3D,
    0x76DC4190,0x01DB7106,0x98D220BC,0xEFD5102A,0x71B18589,0x06B6B51F,0x9FBFE4A5,0xE8B8D433,0x7807C9A2,0x0F00F934,0x9609A88E,0xE10E9818,0x7F6A0DBB,0x086D3D2D,0x91646C97,0xE6635C01,
    0x6B6B51F4,0x1C6C6162,0x856530D8,0xF262004E,0x6C0695ED,0x1B01A57B,0x8208F4C1,0xF50FC457,0x65B0D9C6,0x12B7E950,0x8BBEB8EA,0xFCB9887C,0x62DD1DDF,0x15DA2D49,0x8CD37CF3,0xFBD44C65,
    0x4DB26158,0x3AB551CE,0xA3BC0074,0xD4BB30E2,0x4ADFA541,0x3DD895D7,0xA4D1C46D,0xD3D6F4FB,0x4369E96A,0x346ED9FC,0xAD678846,0xDA60B8D0,0x44042D73,0x33031DE5,0xAA0A4C5F,0xDD0D7CC9,
    0x5005713C,0x270241AA,0xBE0B1010,0xC90C2086,0x5768B525,0x206F85B3,0xB966D409,0xCE61E49F,0x5EDEF90E,0x29D9C998,0xB0D09822,0xC7D7A8B4,0x59B33D17,0x2EB40D81,0xB7BD5C3B,0xC0BA6CAD,
    0xEDB88320,0x9ABFB3B6,0x03B6E20C,0x74B1D29A,0xEAD54739,0x9DD277AF,0x04DB2615,0x73DC1683,0xE3630B12,0x94643B84,0x0D6D6A3E,0x7A6A5AA8,0xE40ECF0B,0x9309FF9D,0x0A00AE27,0x7D079EB1,
    0xF00F9344,0x8708A3D2,0x1E01F268,0x6906C2FE,0xF762575D,0x806567CB,0x196C3671,0x6E6B06E7,0xFED41B76,0x89D32BE0,0x10DA7A5A,0x67DD4ACC,0xF9B9DF6F,0x8EBEEFF9,0x17B7BE43,0x60B08ED5,
    0xD6D6A3E8,0xA1D1937E,0x38D8C2C4,0x4FDFF252,0xD1BB67F1,0xA6BC5767,0x3FB506DD,0x48B2364B,0xD80D2BDA,0xAF0A1B4C,0x36034AF6,0x41047A60,0xDF60EFC3,0xA867DF55,0x316E8EEF,0x4669BE79,
    0xCB61B38C,0xBC66831A,0x256FD2A0,0x5268E236,0xCC0C7795,0xBB0B4703,0x220216B9,0x5505262F,0xC5BA3BBE,0xB2BD0B28,0x2BB45A92,0x5CB36A04,0xC2D7FFA7,0xB5D0CF31,0x2CD99E8B,0x5BDEAE1D,
    0x9B64C2B0,0xEC63F226,0x756AA39C,0x026D930A,0x9C0906A9,0xEB0E363F,0x72076785,0x05005713,0x95BF4A82,0xE2B87A14,0x7BB12BAE,0x0CB61B38,0x92D28E9B,0xE5D5BE0D,0x7CDCEFB7,0x0BDBDF21,
    0x86D3D2D4,0xF1D4E242,0x68DDB3F8,0x1FDA836E,0x81BE16CD,0xF6B9265B,0x6FB077E1,0x18B74777,0x88085AE6,0xFF0F6A70,0x66063BCA,0x11010B5C,0x8F659EFF,0xF862AE69,0x616BFFD3,0x166CCF45,
    0xA00AE278,0xD70DD2EE,0x4E048354,0x3903B3C2,0xA7672661,0xD06016F7,0x4969474D,0x3E6E77DB,0xAED16A4A,0xD9D65ADC,0x40DF0B66,0x37D83BF0,0xA9BCAE53,0xDEBB9EC5,0x47B2CF7F,0x30B5FFE9,
    0xBDBDF21C,0xCABAC28A,0x53B39330,0x24B4A3A6,0xBAD03605,0xCDD70693,0x54DE5729,0x23D967BF,0xB3667A2E,0xC4614AB8,0x5D681B02,0x2A6F2B94,0xB40BBE37,0xC30C8EA1,0x5A05DF1B,0x2D02EF8D,
};

// Known size hash
// It is ok to call ImHashData on a string with known length but the ### operator won't be supported.
// FIXME-OPT: Replace with e.g. FNV1a hash? CRC32 pretty much randomly access 1KB. Need to do proper measurements.
ImU32 ImHashData(const void* data_p, size_t data_size, ImU32 seed)
{
    ImU32 crc = ~seed;
    const unsigned char* data = (const unsigned char*)data_p;
    const ImU32* crc32_lut = GCrc32LookupTable;
    while (data_size-- != 0)
        crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ *data++];
    return ~crc;
}

// Zero-terminated string hash, with support for ### to reset back to seed value
// We support a syntax of "label###id" where only "###id" is included in the hash, and only "label" gets displayed.
// Because this syntax is rarely used we are optimizing for the common case.
// - If we reach ### in the string we discard the hash so far and reset to the seed.
// - We don't do 'current += 2; continue;' after handling ### to keep the code smaller/faster (measured ~10% diff in Debug build)
// FIXME-OPT: Replace with e.g. FNV1a hash? CRC32 pretty much randomly access 1KB. Need to do proper measurements.
ImU32 ImHashStr(const char* data_p, size_t data_size, ImU32 seed)
{
    seed = ~seed;
    ImU32 crc = seed;
    const unsigned char* data = (const unsigned char*)data_p;
    const ImU32* crc32_lut = GCrc32LookupTable;
    if (data_size != 0)
    {
        while (data_size-- != 0)
        {
            unsigned char c = *data++;
            if (c == '#' && data_size >= 2 && data[0] == '#' && data[1] == '#')
                crc = seed;
            crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];
        }
    }
    else
    {
        while (unsigned char c = *data++)
        {
            if (c == '#' && data[0] == '#' && data[1] == '#')
                crc = seed;
            crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];
        }
    }
    return ~crc;
}

FILE* ImFileOpen(const char* filename, const char* mode)
{
#if defined(_WIN32) && !defined(__CYGWIN__) && !defined(__GNUC__)
    // We need a fopen() wrapper because MSVC/Windows fopen doesn't handle UTF-8 filenames. Converting both strings from UTF-8 to wchar format (using a single allocation, because we can)
    const int filename_wsize = ImTextCountCharsFromUtf8(filename, NULL) + 1;
    const int mode_wsize = ImTextCountCharsFromUtf8(mode, NULL) + 1;
    ImVector<ImWchar> buf;
    buf.resize(filename_wsize + mode_wsize);
    ImTextStrFromUtf8(&buf[0], filename_wsize, filename, NULL);
    ImTextStrFromUtf8(&buf[filename_wsize], mode_wsize, mode, NULL);
    return _wfopen((wchar_t*)&buf[0], (wchar_t*)&buf[filename_wsize]);
#else
    return fopen(filename, mode);
#endif
}

// Load file content into memory
// Memory allocated with IM_ALLOC(), must be freed by user using IM_FREE() == ImGui::MemFree()
void* ImFileLoadToMemory(const char* filename, const char* file_open_mode, size_t* out_file_size, int padding_bytes)
{
    IM_ASSERT(filename && file_open_mode);
    if (out_file_size)
        *out_file_size = 0;

    FILE* f;
    if ((f = ImFileOpen(filename, file_open_mode)) == NULL)
        return NULL;

    long file_size_signed;
    if (fseek(f, 0, SEEK_END) || (file_size_signed = ftell(f)) == -1 || fseek(f, 0, SEEK_SET))
    {
        fclose(f);
        return NULL;
    }

    size_t file_size = (size_t)file_size_signed;
    void* file_data = IM_ALLOC(file_size + padding_bytes);
    if (file_data == NULL)
    {
        fclose(f);
        return NULL;
    }
    if (fread(file_data, 1, file_size, f) != file_size)
    {
        fclose(f);
        IM_FREE(file_data);
        return NULL;
    }
    if (padding_bytes > 0)
        memset((void*)(((char*)file_data) + file_size), 0, (size_t)padding_bytes);

    fclose(f);
    if (out_file_size)
        *out_file_size = file_size;

    return file_data;
}

//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)
//-----------------------------------------------------------------------------

// Convert UTF-8 to 32-bits character, process single character input.
// Based on stb_from_utf8() from github.com/nothings/stb/
// We handle UTF-8 decoding error by skipping forward.
int ImTextCharFromUtf8(unsigned int* out_char, const char* in_text, const char* in_text_end)
{
    unsigned int c = (unsigned int)-1;
    const unsigned char* str = (const unsigned char*)in_text;
    if (!(*str & 0x80))
    {
        c = (unsigned int)(*str++);
        *out_char = c;
        return 1;
    }
    if ((*str & 0xe0) == 0xc0)
    {
        *out_char = 0xFFFD; // will be invalid but not end of string
        if (in_text_end && in_text_end - (const char*)str < 2) return 1;
        if (*str < 0xc2) return 2;
        c = (unsigned int)((*str++ & 0x1f) << 6);
        if ((*str & 0xc0) != 0x80) return 2;
        c += (*str++ & 0x3f);
        *out_char = c;
        return 2;
    }
    if ((*str & 0xf0) == 0xe0)
    {
        *out_char = 0xFFFD; // will be invalid but not end of string
        if (in_text_end && in_text_end - (const char*)str < 3) return 1;
        if (*str == 0xe0 && (str[1] < 0xa0 || str[1] > 0xbf)) return 3;
        if (*str == 0xed && str[1] > 0x9f) return 3; // str[1] < 0x80 is checked below
        c = (unsigned int)((*str++ & 0x0f) << 12);
        if ((*str & 0xc0) != 0x80) return 3;
        c += (unsigned int)((*str++ & 0x3f) << 6);
        if ((*str & 0xc0) != 0x80) return 3;
        c += (*str++ & 0x3f);
        *out_char = c;
        return 3;
    }
    if ((*str & 0xf8) == 0xf0)
    {
        *out_char = 0xFFFD; // will be invalid but not end of string
        if (in_text_end && in_text_end - (const char*)str < 4) return 1;
        if (*str > 0xf4) return 4;
        if (*str == 0xf0 && (str[1] < 0x90 || str[1] > 0xbf)) return 4;
        if (*str == 0xf4 && str[1] > 0x8f) return 4; // str[1] < 0x80 is checked below
        c = (unsigned int)((*str++ & 0x07) << 18);
        if ((*str & 0xc0) != 0x80) return 4;
        c += (unsigned int)((*str++ & 0x3f) << 12);
        if ((*str & 0xc0) != 0x80) return 4;
        c += (unsigned int)((*str++ & 0x3f) << 6);
        if ((*str & 0xc0) != 0x80) return 4;
        c += (*str++ & 0x3f);
        // utf-8 encodings of values used in surrogate pairs are invalid
        if ((c & 0xFFFFF800) == 0xD800) return 4;
        *out_char = c;
        return 4;
    }
    *out_char = 0;
    return 0;
}

int ImTextStrFromUtf8(ImWchar* buf, int buf_size, const char* in_text, const char* in_text_end, const char** in_text_remaining)
{
    ImWchar* buf_out = buf;
    ImWchar* buf_end = buf + buf_size;
    while (buf_out < buf_end-1 && (!in_text_end || in_text < in_text_end) && *in_text)
    {
        unsigned int c;
        in_text += ImTextCharFromUtf8(&c, in_text, in_text_end);
        if (c == 0)
            break;
        if (c < 0x10000)    // FIXME: Losing characters that don't fit in 2 bytes
            *buf_out++ = (ImWchar)c;
    }
    *buf_out = 0;
    if (in_text_remaining)
        *in_text_remaining = in_text;
    return (int)(buf_out - buf);
}

int ImTextCountCharsFromUtf8(const char* in_text, const char* in_text_end)
{
    int char_count = 0;
    while ((!in_text_end || in_text < in_text_end) && *in_text)
    {
        unsigned int c;
        in_text += ImTextCharFromUtf8(&c, in_text, in_text_end);
        if (c == 0)
            break;
        if (c < 0x10000)
            char_count++;
    }
    return char_count;
}

// Based on stb_to_utf8() from github.com/nothings/stb/
static inline int ImTextCharToUtf8(char* buf, int buf_size, unsigned int c)
{
    if (c < 0x80)
    {
        buf[0] = (char)c;
        return 1;
    }
    if (c < 0x800)
    {
        if (buf_size < 2) return 0;
        buf[0] = (char)(0xc0 + (c >> 6));
        buf[1] = (char)(0x80 + (c & 0x3f));
        return 2;
    }
    if (c >= 0xdc00 && c < 0xe000)
    {
        return 0;
    }
    if (c >= 0xd800 && c < 0xdc00)
    {
        if (buf_size < 4) return 0;
        buf[0] = (char)(0xf0 + (c >> 18));
        buf[1] = (char)(0x80 + ((c >> 12) & 0x3f));
        buf[2] = (char)(0x80 + ((c >> 6) & 0x3f));
        buf[3] = (char)(0x80 + ((c ) & 0x3f));
        return 4;
    }
    //else if (c < 0x10000)
    {
        if (buf_size < 3) return 0;
        buf[0] = (char)(0xe0 + (c >> 12));
        buf[1] = (char)(0x80 + ((c>> 6) & 0x3f));
        buf[2] = (char)(0x80 + ((c ) & 0x3f));
        return 3;
    }
}

// Not optimal but we very rarely use this function.
int ImTextCountUtf8BytesFromChar(const char* in_text, const char* in_text_end)
{
    unsigned int dummy = 0;
    return ImTextCharFromUtf8(&dummy, in_text, in_text_end);
}

static inline int ImTextCountUtf8BytesFromChar(unsigned int c)
{
    if (c < 0x80) return 1;
    if (c < 0x800) return 2;
    if (c >= 0xdc00 && c < 0xe000) return 0;
    if (c >= 0xd800 && c < 0xdc00) return 4;
    return 3;
}

int ImTextStrToUtf8(char* buf, int buf_size, const ImWchar* in_text, const ImWchar* in_text_end)
{
    char* buf_out = buf;
    const char* buf_end = buf + buf_size;
    while (buf_out < buf_end-1 && (!in_text_end || in_text < in_text_end) && *in_text)
    {
        unsigned int c = (unsigned int)(*in_text++);
        if (c < 0x80)
            *buf_out++ = (char)c;
        else
            buf_out += ImTextCharToUtf8(buf_out, (int)(buf_end-buf_out-1), c);
    }
    *buf_out = 0;
    return (int)(buf_out - buf);
}

int ImTextCountUtf8BytesFromStr(const ImWchar* in_text, const ImWchar* in_text_end)
{
    int bytes_count = 0;
    while ((!in_text_end || in_text < in_text_end) && *in_text)
    {
        unsigned int c = (unsigned int)(*in_text++);
        if (c < 0x80)
            bytes_count++;
        else
            bytes_count += ImTextCountUtf8BytesFromChar(c);
    }
    return bytes_count;
}

//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILTIES (Color functions)
// Note: The Convert functions are early design which are not consistent with other API.
//-----------------------------------------------------------------------------

ImVec4 ImGui::ColorConvertU32ToFloat4(ImU32 in)
{
    float s = 1.0f/255.0f;
    return ImVec4(
        ((in >> IM_COL32_R_SHIFT) & 0xFF) * s,
        ((in >> IM_COL32_G_SHIFT) & 0xFF) * s,
        ((in >> IM_COL32_B_SHIFT) & 0xFF) * s,
        ((in >> IM_COL32_A_SHIFT) & 0xFF) * s);
}

ImU32 ImGui::ColorConvertFloat4ToU32(const ImVec4& in)
{
    ImU32 out;
    out  = ((ImU32)IM_F32_TO_INT8_SAT(in.x)) << IM_COL32_R_SHIFT;
    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.y)) << IM_COL32_G_SHIFT;
    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.z)) << IM_COL32_B_SHIFT;
    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.w)) << IM_COL32_A_SHIFT;
    return out;
}

// Convert rgb floats ([0-1],[0-1],[0-1]) to hsv floats ([0-1],[0-1],[0-1]), from Foley & van Dam p592
// Optimized http://lolengine.net/blog/2013/01/13/fast-rgb-to-hsv
void ImGui::ColorConvertRGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v)
{
    float K = 0.f;
    if (g < b)
    {
        ImSwap(g, b);
        K = -1.f;
    }
    if (r < g)
    {
        ImSwap(r, g);
        K = -2.f / 6.f - K;
    }

    const float chroma = r - (g < b ? g : b);
    out_h = ImFabs(K + (g - b) / (6.f * chroma + 1e-20f));
    out_s = chroma / (r + 1e-20f);
    out_v = r;
}

// Convert hsv floats ([0-1],[0-1],[0-1]) to rgb floats ([0-1],[0-1],[0-1]), from Foley & van Dam p593
// also http://en.wikipedia.org/wiki/HSL_and_HSV
void ImGui::ColorConvertHSVtoRGB(float h, float s, float v, float& out_r, float& out_g, float& out_b)
{
    if (s == 0.0f)
    {
        // gray
        out_r = out_g = out_b = v;
        return;
    }

    h = ImFmod(h, 1.0f) / (60.0f/360.0f);
    int   i = (int)h;
    float f = h - (float)i;
    float p = v * (1.0f - s);
    float q = v * (1.0f - s * f);
    float t = v * (1.0f - s * (1.0f - f));

    switch (i)
    {
    case 0: out_r = v; out_g = t; out_b = p; break;
    case 1: out_r = q; out_g = v; out_b = p; break;
    case 2: out_r = p; out_g = v; out_b = t; break;
    case 3: out_r = p; out_g = q; out_b = v; break;
    case 4: out_r = t; out_g = p; out_b = v; break;
    case 5: default: out_r = v; out_g = p; out_b = q; break;
    }
}

ImU32 ImGui::GetColorU32(ImGuiCol idx, float alpha_mul)
{
    ImGuiStyle& style = GImGui->Style;
    ImVec4 c = style.Colors[idx];
    c.w *= style.Alpha * alpha_mul;
    return ColorConvertFloat4ToU32(c);
}

ImU32 ImGui::GetColorU32(const ImVec4& col)
{
    ImGuiStyle& style = GImGui->Style;
    ImVec4 c = col;
    c.w *= style.Alpha;
    return ColorConvertFloat4ToU32(c);
}

const ImVec4& ImGui::GetStyleColorVec4(ImGuiCol idx)
{
    ImGuiStyle& style = GImGui->Style;
    return style.Colors[idx];
}

ImU32 ImGui::GetColorU32(ImU32 col)
{
    float style_alpha = GImGui->Style.Alpha;
    if (style_alpha >= 1.0f)
        return col;
    ImU32 a = (col & IM_COL32_A_MASK) >> IM_COL32_A_SHIFT;
    a = (ImU32)(a * style_alpha); // We don't need to clamp 0..255 because Style.Alpha is in 0..1 range.
    return (col & ~IM_COL32_A_MASK) | (a << IM_COL32_A_SHIFT);
}

//-----------------------------------------------------------------------------
// [SECTION] ImGuiStorage
// Helper: Key->value storage
//-----------------------------------------------------------------------------

// std::lower_bound but without the bullshit
static ImGuiStorage::Pair* LowerBound(ImVector<ImGuiStorage::Pair>& data, ImGuiID key)
{
    ImGuiStorage::Pair* first = data.Data;
    ImGuiStorage::Pair* last = data.Data + data.Size;
    size_t count = (size_t)(last - first);
    while (count > 0)
    {
        size_t count2 = count >> 1;
        ImGuiStorage::Pair* mid = first + count2;
        if (mid->key < key)
        {
            first = ++mid;
            count -= count2 + 1;
        }
        else
        {
            count = count2;
        }
    }
    return first;
}

// For quicker full rebuild of a storage (instead of an incremental one), you may add all your contents and then sort once.
void ImGuiStorage::BuildSortByKey()
{
    struct StaticFunc
    {
        static int IMGUI_CDECL PairCompareByID(const void* lhs, const void* rhs)
        {
            // We can't just do a subtraction because qsort uses signed integers and subtracting our ID doesn't play well with that.
            if (((const Pair*)lhs)->key > ((const Pair*)rhs)->key) return +1;
            if (((const Pair*)lhs)->key < ((const Pair*)rhs)->key) return -1;
            return 0;
        }
    };
    if (Data.Size > 1)
        ImQsort(Data.Data, (size_t)Data.Size, sizeof(Pair), StaticFunc::PairCompareByID);
}

int ImGuiStorage::GetInt(ImGuiID key, int default_val) const
{
    ImGuiStorage::Pair* it = LowerBound(const_cast<ImVector<ImGuiStorage::Pair>&>(Data), key);
    if (it == Data.end() || it->key != key)
        return default_val;
    return it->val_i;
}

bool ImGuiStorage::GetBool(ImGuiID key, bool default_val) const
{
    return GetInt(key, default_val ? 1 : 0) != 0;
}

float ImGuiStorage::GetFloat(ImGuiID key, float default_val) const
{
    ImGuiStorage::Pair* it = LowerBound(const_cast<ImVector<ImGuiStorage::Pair>&>(Data), key);
    if (it == Data.end() || it->key != key)
        return default_val;
    return it->val_f;
}

void* ImGuiStorage::GetVoidPtr(ImGuiID key) const
{
    ImGuiStorage::Pair* it = LowerBound(const_cast<ImVector<ImGuiStorage::Pair>&>(Data), key);
    if (it == Data.end() || it->key != key)
        return NULL;
    return it->val_p;
}

// References are only valid until a new value is added to the storage. Calling a Set***() function or a Get***Ref() function invalidates the pointer.
int* ImGuiStorage::GetIntRef(ImGuiID key, int default_val)
{
    ImGuiStorage::Pair* it = LowerBound(Data, key);
    if (it == Data.end() || it->key != key)
        it = Data.insert(it, Pair(key, default_val));
    return &it->val_i;
}

bool* ImGuiStorage::GetBoolRef(ImGuiID key, bool default_val)
{
    return (bool*)GetIntRef(key, default_val ? 1 : 0);
}

float* ImGuiStorage::GetFloatRef(ImGuiID key, float default_val)
{
    ImGuiStorage::Pair* it = LowerBound(Data, key);
    if (it == Data.end() || it->key != key)
        it = Data.insert(it, Pair(key, default_val));
    return &it->val_f;
}

void** ImGuiStorage::GetVoidPtrRef(ImGuiID key, void* default_val)
{
    ImGuiStorage::Pair* it = LowerBound(Data, key);
    if (it == Data.end() || it->key != key)
        it = Data.insert(it, Pair(key, default_val));
    return &it->val_p;
}

// FIXME-OPT: Need a way to reuse the result of lower_bound when doing GetInt()/SetInt() - not too bad because it only happens on explicit interaction (maximum one a frame)
void ImGuiStorage::SetInt(ImGuiID key, int val)
{
    ImGuiStorage::Pair* it = LowerBound(Data, key);
    if (it == Data.end() || it->key != key)
    {
        Data.insert(it, Pair(key, val));
        return;
    }
    it->val_i = val;
}

void ImGuiStorage::SetBool(ImGuiID key, bool val)
{
    SetInt(key, val ? 1 : 0);
}

void ImGuiStorage::SetFloat(ImGuiID key, float val)
{
    ImGuiStorage::Pair* it = LowerBound(Data, key);
    if (it == Data.end() || it->key != key)
    {
        Data.insert(it, Pair(key, val));
        return;
    }
    it->val_f = val;
}

void ImGuiStorage::SetVoidPtr(ImGuiID key, void* val)
{
    ImGuiStorage::Pair* it = LowerBound(Data, key);
    if (it == Data.end() || it->key != key)
    {
        Data.insert(it, Pair(key, val));
        return;
    }
    it->val_p = val;
}

void ImGuiStorage::SetAllInt(int v)
{
    for (int i = 0; i < Data.Size; i++)
        Data[i].val_i = v;
}

//-----------------------------------------------------------------------------
// [SECTION] ImGuiTextFilter
//-----------------------------------------------------------------------------

// Helper: Parse and apply text filters. In format "aaaaa[,bbbb][,ccccc]"
ImGuiTextFilter::ImGuiTextFilter(const char* default_filter)
{
    if (default_filter)
    {
        ImStrncpy(InputBuf, default_filter, IM_ARRAYSIZE(InputBuf));
        Build();
    }
    else
    {
        InputBuf[0] = 0;
        CountGrep = 0;
    }
}

bool ImGuiTextFilter::Draw(const char* label, float width)
{
    if (width != 0.0f)
        ImGui::SetNextItemWidth(width);
    bool value_changed = ImGui::InputText(label, InputBuf, IM_ARRAYSIZE(InputBuf));
    if (value_changed)
        Build();
    return value_changed;
}

void ImGuiTextFilter::TextRange::split(char separator, ImVector<TextRange>* out) const
{
    out->resize(0);
    const char* wb = b;
    const char* we = wb;
    while (we < e)
    {
        if (*we == separator)
        {
            out->push_back(TextRange(wb, we));
            wb = we + 1;
        }
        we++;
    }
    if (wb != we)
        out->push_back(TextRange(wb, we));
}

void ImGuiTextFilter::Build()
{
    Filters.resize(0);
    TextRange input_range(InputBuf, InputBuf+strlen(InputBuf));
    input_range.split(',', &Filters);

    CountGrep = 0;
    for (int i = 0; i != Filters.Size; i++)
    {
        TextRange& f = Filters[i];
        while (f.b < f.e && ImCharIsBlankA(f.b[0]))
            f.b++;
        while (f.e > f.b && ImCharIsBlankA(f.e[-1]))
            f.e--;
        if (f.empty())
            continue;
        if (Filters[i].b[0] != '-')
            CountGrep += 1;
    }
}

bool ImGuiTextFilter::PassFilter(const char* text, const char* text_end) const
{
    if (Filters.empty())
        return true;

    if (text == NULL)
        text = "";

    for (int i = 0; i != Filters.Size; i++)
    {
        const TextRange& f = Filters[i];
        if (f.empty())
            continue;
        if (f.b[0] == '-')
        {
            // Subtract
            if (ImStristr(text, text_end, f.begin()+1, f.end()) != NULL)
                return false;
        }
        else
        {
            // Grep
            if (ImStristr(text, text_end, f.begin(), f.end()) != NULL)
                return true;
        }
    }

    // Implicit * grep
    if (CountGrep == 0)
        return true;

    return false;
}

//-----------------------------------------------------------------------------
// [SECTION] ImGuiTextBuffer
//-----------------------------------------------------------------------------

// On some platform vsnprintf() takes va_list by reference and modifies it.
// va_copy is the 'correct' way to copy a va_list but Visual Studio prior to 2013 doesn't have it.
#ifndef va_copy
#if defined(__GNUC__) || defined(__clang__)
#define va_copy(dest, src) __builtin_va_copy(dest, src)
#else
#define va_copy(dest, src) (dest = src)
#endif
#endif

char ImGuiTextBuffer::EmptyString[1] = { 0 };

void ImGuiTextBuffer::append(const char* str, const char* str_end)
{
    int len = str_end ? (int)(str_end - str) : (int)strlen(str);

    // Add zero-terminator the first time
    const int write_off = (Buf.Size != 0) ? Buf.Size : 1;
    const int needed_sz = write_off + len;
    if (write_off + len >= Buf.Capacity)
    {
        int new_capacity = Buf.Capacity * 2;
        Buf.reserve(needed_sz > new_capacity ? needed_sz : new_capacity);
    }

    Buf.resize(needed_sz);
    memcpy(&Buf[write_off - 1], str, (size_t)len);
    Buf[write_off - 1 + len] = 0;
}

void ImGuiTextBuffer::appendf(const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    appendfv(fmt, args);
    va_end(args);
}

// Helper: Text buffer for logging/accumulating text
void ImGuiTextBuffer::appendfv(const char* fmt, va_list args)
{
    va_list args_copy;
    va_copy(args_copy, args);

    int len = ImFormatStringV(NULL, 0, fmt, args);         // FIXME-OPT: could do a first pass write attempt, likely successful on first pass.
    if (len <= 0)
    {
        va_end(args_copy);
        return;
    }

    // Add zero-terminator the first time
    const int write_off = (Buf.Size != 0) ? Buf.Size : 1;
    const int needed_sz = write_off + len;
    if (write_off + len >= Buf.Capacity)
    {
        int new_capacity = Buf.Capacity * 2;
        Buf.reserve(needed_sz > new_capacity ? needed_sz : new_capacity);
    }

    Buf.resize(needed_sz);
    ImFormatStringV(&Buf[write_off - 1], (size_t)len + 1, fmt, args_copy);
    va_end(args_copy);
}

//-----------------------------------------------------------------------------
// [SECTION] ImGuiListClipper
// This is currently not as flexible/powerful as it should be, needs some rework (see TODO)
//-----------------------------------------------------------------------------

static void SetCursorPosYAndSetupDummyPrevLine(float pos_y, float line_height)
{
    // Set cursor position and a few other things so that SetScrollHereY() and Columns() can work when seeking cursor.
    // FIXME: It is problematic that we have to do that here, because custom/equivalent end-user code would stumble on the same issue.
    // The clipper should probably have a 4th step to display the last item in a regular manner.
    ImGui::SetCursorPosY(pos_y);
    ImGuiWindow* window = ImGui::GetCurrentWindow();
    window->DC.CursorPosPrevLine.y = window->DC.CursorPos.y - line_height;      // Setting those fields so that SetScrollHereY() can properly function after the end of our clipper usage.
    window->DC.PrevLineSize.y = (line_height - GImGui->Style.ItemSpacing.y);    // If we end up needing more accurate data (to e.g. use SameLine) we may as well make the clipper have a fourth step to let user process and display the last item in their list.
    if (window->DC.CurrentColumns)
        window->DC.CurrentColumns->LineMinY = window->DC.CursorPos.y;           // Setting this so that cell Y position are set properly
}

// Use case A: Begin() called from constructor with items_height<0, then called again from Sync() in StepNo 1
// Use case B: Begin() called from constructor with items_height>0
// FIXME-LEGACY: Ideally we should remove the Begin/End functions but they are part of the legacy API we still support. This is why some of the code in Step() calling Begin() and reassign some fields, spaghetti style.
void ImGuiListClipper::Begin(int count, float items_height)
{
    StartPosY = ImGui::GetCursorPosY();
    ItemsHeight = items_height;
    ItemsCount = count;
    StepNo = 0;
    DisplayEnd = DisplayStart = -1;
    if (ItemsHeight > 0.0f)
    {
        ImGui::CalcListClipping(ItemsCount, ItemsHeight, &DisplayStart, &DisplayEnd); // calculate how many to clip/display
        if (DisplayStart > 0)
            SetCursorPosYAndSetupDummyPrevLine(StartPosY + DisplayStart * ItemsHeight, ItemsHeight); // advance cursor
        StepNo = 2;
    }
}

void ImGuiListClipper::End()
{
    if (ItemsCount < 0)
        return;
    // In theory here we should assert that ImGui::GetCursorPosY() == StartPosY + DisplayEnd * ItemsHeight, but it feels saner to just seek at the end and not assert/crash the user.
    if (ItemsCount < INT_MAX)
        SetCursorPosYAndSetupDummyPrevLine(StartPosY + ItemsCount * ItemsHeight, ItemsHeight); // advance cursor
    ItemsCount = -1;
    StepNo = 3;
}

bool ImGuiListClipper::Step()
{
    if (ItemsCount == 0 || ImGui::GetCurrentWindowRead()->SkipItems)
    {
        ItemsCount = -1;
        return false;
    }
    if (StepNo == 0) // Step 0: the clipper let you process the first element, regardless of it being visible or not, so we can measure the element height.
    {
        DisplayStart = 0;
        DisplayEnd = 1;
        StartPosY = ImGui::GetCursorPosY();
        StepNo = 1;
        return true;
    }
    if (StepNo == 1) // Step 1: the clipper infer height from first element, calculate the actual range of elements to display, and position the cursor before the first element.
    {
        if (ItemsCount == 1) { ItemsCount = -1; return false; }
        float items_height = ImGui::GetCursorPosY() - StartPosY;
        IM_ASSERT(items_height > 0.0f);   // If this triggers, it means Item 0 hasn't moved the cursor vertically
        Begin(ItemsCount-1, items_height);
        DisplayStart++;
        DisplayEnd++;
        StepNo = 3;
        return true;
    }
    if (StepNo == 2) // Step 2: dummy step only required if an explicit items_height was passed to constructor or Begin() and user still call Step(). Does nothing and switch to Step 3.
    {
        IM_ASSERT(DisplayStart >= 0 && DisplayEnd >= 0);
        StepNo = 3;
        return true;
    }
    if (StepNo == 3) // Step 3: the clipper validate that we have reached the expected Y position (corresponding to element DisplayEnd), advance the cursor to the end of the list and then returns 'false' to end the loop.
        End();
    return false;
}

//-----------------------------------------------------------------------------
// [SECTION] RENDER HELPERS
// Those (internal) functions are currently quite a legacy mess - their signature and behavior will change.
// Also see imgui_draw.cpp for some more which have been reworked to not rely on ImGui:: state.
//-----------------------------------------------------------------------------

const char* ImGui::FindRenderedTextEnd(const char* text, const char* text_end)
{
    const char* text_display_end = text;
    if (!text_end)
        text_end = (const char*)-1;

    while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))
        text_display_end++;
    return text_display_end;
}

// Internal ImGui functions to render text
// RenderText***() functions calls ImDrawList::AddText() calls ImBitmapFont::RenderText()
void ImGui::RenderText(ImVec2 pos, const char* text, const char* text_end, bool hide_text_after_hash)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    // Hide anything after a '##' string
    const char* text_display_end;
    if (hide_text_after_hash)
    {
        text_display_end = FindRenderedTextEnd(text, text_end);
    }
    else
    {
        if (!text_end)
            text_end = text + strlen(text); // FIXME-OPT
        text_display_end = text_end;
    }

    if (text != text_display_end)
    {
        window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_display_end);
        if (g.LogEnabled)
            LogRenderedText(&pos, text, text_display_end);
    }
}

void ImGui::RenderTextWrapped(ImVec2 pos, const char* text, const char* text_end, float wrap_width)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    if (!text_end)
        text_end = text + strlen(text); // FIXME-OPT

    if (text != text_end)
    {
        window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_end, wrap_width);
        if (g.LogEnabled)
            LogRenderedText(&pos, text, text_end);
    }
}

// Default clip_rect uses (pos_min,pos_max)
// Handle clipping on CPU immediately (vs typically let the GPU clip the triangles that are overlapping the clipping rectangle edges)
void ImGui::RenderTextClippedEx(ImDrawList* draw_list, const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_display_end, const ImVec2* text_size_if_known, const ImVec2& align, const ImRect* clip_rect)
{
    // Perform CPU side clipping for single clipped element to avoid using scissor state
    ImVec2 pos = pos_min;
    const ImVec2 text_size = text_size_if_known ? *text_size_if_known : CalcTextSize(text, text_display_end, false, 0.0f);

    const ImVec2* clip_min = clip_rect ? &clip_rect->Min : &pos_min;
    const ImVec2* clip_max = clip_rect ? &clip_rect->Max : &pos_max;
    bool need_clipping = (pos.x + text_size.x >= clip_max->x) || (pos.y + text_size.y >= clip_max->y);
    if (clip_rect) // If we had no explicit clipping rectangle then pos==clip_min
        need_clipping |= (pos.x < clip_min->x) || (pos.y < clip_min->y);

    // Align whole block. We should defer that to the better rendering function when we'll have support for individual line alignment.
    if (align.x > 0.0f) pos.x = ImMax(pos.x, pos.x + (pos_max.x - pos.x - text_size.x) * align.x);
    if (align.y > 0.0f) pos.y = ImMax(pos.y, pos.y + (pos_max.y - pos.y - text_size.y) * align.y);

    // Render
    if (need_clipping)
    {
        ImVec4 fine_clip_rect(clip_min->x, clip_min->y, clip_max->x, clip_max->y);
        draw_list->AddText(NULL, 0.0f, pos, GetColorU32(ImGuiCol_Text), text, text_display_end, 0.0f, &fine_clip_rect);
    }
    else
    {
        draw_list->AddText(NULL, 0.0f, pos, GetColorU32(ImGuiCol_Text), text, text_display_end, 0.0f, NULL);
    }
}

void ImGui::RenderTextClipped(const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align, const ImRect* clip_rect)
{
    // Hide anything after a '##' string
    const char* text_display_end = FindRenderedTextEnd(text, text_end);
    const int text_len = (int)(text_display_end - text);
    if (text_len == 0)
        return;

    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    RenderTextClippedEx(window->DrawList, pos_min, pos_max, text, text_display_end, text_size_if_known, align, clip_rect);
    if (g.LogEnabled)
        LogRenderedText(&pos_min, text, text_display_end);
}

// Render a rectangle shaped with optional rounding and borders
void ImGui::RenderFrame(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border, float rounding)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    window->DrawList->AddRectFilled(p_min, p_max, fill_col, rounding);
    const float border_size = g.Style.FrameBorderSize;
    if (border && border_size > 0.0f)
    {
        window->DrawList->AddRect(p_min+ImVec2(1,1), p_max+ImVec2(1,1), GetColorU32(ImGuiCol_BorderShadow), rounding, ImDrawCornerFlags_All, border_size);
        window->DrawList->AddRect(p_min, p_max, GetColorU32(ImGuiCol_Border), rounding, ImDrawCornerFlags_All, border_size);
    }
}

void ImGui::RenderFrameBorder(ImVec2 p_min, ImVec2 p_max, float rounding)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    const float border_size = g.Style.FrameBorderSize;
    if (border_size > 0.0f)
    {
        window->DrawList->AddRect(p_min+ImVec2(1,1), p_max+ImVec2(1,1), GetColorU32(ImGuiCol_BorderShadow), rounding, ImDrawCornerFlags_All, border_size);
        window->DrawList->AddRect(p_min, p_max, GetColorU32(ImGuiCol_Border), rounding, ImDrawCornerFlags_All, border_size);
    }
}

// Render an arrow aimed to be aligned with text (p_min is a position in the same space text would be positioned). To e.g. denote expanded/collapsed state
void ImGui::RenderArrow(ImVec2 p_min, ImGuiDir dir, float scale)
{
    ImGuiContext& g = *GImGui;

    const float h = g.FontSize * 1.00f;
    float r = h * 0.40f * scale;
    ImVec2 center = p_min + ImVec2(h * 0.50f, h * 0.50f * scale);

    ImVec2 a, b, c;
    switch (dir)
    {
    case ImGuiDir_Up:
    case ImGuiDir_Down:
        if (dir == ImGuiDir_Up) r = -r;
        a = ImVec2(+0.000f,+0.750f) * r;
        b = ImVec2(-0.866f,-0.750f) * r;
        c = ImVec2(+0.866f,-0.750f) * r;
        break;
    case ImGuiDir_Left:
    case ImGuiDir_Right:
        if (dir == ImGuiDir_Left) r = -r;
        a = ImVec2(+0.750f,+0.000f) * r;
        b = ImVec2(-0.750f,+0.866f) * r;
        c = ImVec2(-0.750f,-0.866f) * r;
        break;
    case ImGuiDir_None:
    case ImGuiDir_COUNT:
        IM_ASSERT(0);
        break;
    }

    g.CurrentWindow->DrawList->AddTriangleFilled(center + a, center + b, center + c, GetColorU32(ImGuiCol_Text));
}

void ImGui::RenderBullet(ImVec2 pos)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    window->DrawList->AddCircleFilled(pos, g.FontSize*0.20f, GetColorU32(ImGuiCol_Text), 8);
}

void ImGui::RenderCheckMark(ImVec2 pos, ImU32 col, float sz)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    float thickness = ImMax(sz / 5.0f, 1.0f);
    sz -= thickness*0.5f;
    pos += ImVec2(thickness*0.25f, thickness*0.25f);

    float third = sz / 3.0f;
    float bx = pos.x + third;
    float by = pos.y + sz - third*0.5f;
    window->DrawList->PathLineTo(ImVec2(bx - third, by - third));
    window->DrawList->PathLineTo(ImVec2(bx, by));
    window->DrawList->PathLineTo(ImVec2(bx + third*2, by - third*2));
    window->DrawList->PathStroke(col, false, thickness);
}

void ImGui::RenderNavHighlight(const ImRect& bb, ImGuiID id, ImGuiNavHighlightFlags flags)
{
    ImGuiContext& g = *GImGui;
    if (id != g.NavId)
        return;
    if (g.NavDisableHighlight && !(flags & ImGuiNavHighlightFlags_AlwaysDraw))
        return;
    ImGuiWindow* window = g.CurrentWindow;
    if (window->DC.NavHideHighlightOneFrame)
        return;

    float rounding = (flags & ImGuiNavHighlightFlags_NoRounding) ? 0.0f : g.Style.FrameRounding;
    ImRect display_rect = bb;
    display_rect.ClipWith(window->ClipRect);
    if (flags & ImGuiNavHighlightFlags_TypeDefault)
    {
        const float THICKNESS = 2.0f;
        const float DISTANCE = 3.0f + THICKNESS * 0.5f;
        display_rect.Expand(ImVec2(DISTANCE,DISTANCE));
        bool fully_visible = window->ClipRect.Contains(display_rect);
        if (!fully_visible)
            window->DrawList->PushClipRect(display_rect.Min, display_rect.Max);
        window->DrawList->AddRect(display_rect.Min + ImVec2(THICKNESS*0.5f,THICKNESS*0.5f), display_rect.Max - ImVec2(THICKNESS*0.5f,THICKNESS*0.5f), GetColorU32(ImGuiCol_NavHighlight), rounding, ImDrawCornerFlags_All, THICKNESS);
        if (!fully_visible)
            window->DrawList->PopClipRect();
    }
    if (flags & ImGuiNavHighlightFlags_TypeThin)
    {
        window->DrawList->AddRect(display_rect.Min, display_rect.Max, GetColorU32(ImGuiCol_NavHighlight), rounding, ~0, 1.0f);
    }
}

//-----------------------------------------------------------------------------
// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)
//-----------------------------------------------------------------------------

// ImGuiWindow is mostly a dumb struct. It merely has a constructor and a few helper methods
ImGuiWindow::ImGuiWindow(ImGuiContext* context, const char* name)
    : DrawListInst(&context->DrawListSharedData)
{
    Name = ImStrdup(name);
    ID = ImHashStr(name);
    IDStack.push_back(ID);
    Flags = ImGuiWindowFlags_None;
    Pos = ImVec2(0.0f, 0.0f);
    Size = SizeFull = ImVec2(0.0f, 0.0f);
    SizeContents = SizeContentsExplicit = ImVec2(0.0f, 0.0f);
    WindowPadding = ImVec2(0.0f, 0.0f);
    WindowRounding = 0.0f;
    WindowBorderSize = 0.0f;
    NameBufLen = (int)strlen(name) + 1;
    MoveId = GetID("#MOVE");
    ChildId = 0;
    Scroll = ImVec2(0.0f, 0.0f);
    ScrollTarget = ImVec2(FLT_MAX, FLT_MAX);
    ScrollTargetCenterRatio = ImVec2(0.5f, 0.5f);
    ScrollbarSizes = ImVec2(0.0f, 0.0f);
    ScrollbarX = ScrollbarY = false;
    Active = WasActive = false;
    WriteAccessed = false;
    Collapsed = false;
    WantCollapseToggle = false;
    SkipItems = false;
    Appearing = false;
    Hidden = false;
    HasCloseButton = false;
    ResizeBorderHeld = -1;
    BeginCount = 0;
    BeginOrderWithinParent = -1;
    BeginOrderWithinContext = -1;
    PopupId = 0;
    AutoFitFramesX = AutoFitFramesY = -1;
    AutoFitOnlyGrows = false;
    AutoFitChildAxises = 0x00;
    AutoPosLastDirection = ImGuiDir_None;
    HiddenFramesCanSkipItems = HiddenFramesCannotSkipItems = 0;
    SetWindowPosAllowFlags = SetWindowSizeAllowFlags = SetWindowCollapsedAllowFlags = ImGuiCond_Always | ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing;
    SetWindowPosVal = SetWindowPosPivot = ImVec2(FLT_MAX, FLT_MAX);

    LastFrameActive = -1;
    ItemWidthDefault = 0.0f;
    FontWindowScale = 1.0f;
    SettingsIdx = -1;

    DrawList = &DrawListInst;
    DrawList->_OwnerName = Name;
    ParentWindow = NULL;
    RootWindow = NULL;
    RootWindowForTitleBarHighlight = NULL;
    RootWindowForNav = NULL;

    NavLastIds[0] = NavLastIds[1] = 0;
    NavRectRel[0] = NavRectRel[1] = ImRect();
    NavLastChildNavWindow = NULL;
}

ImGuiWindow::~ImGuiWindow()
{
    IM_ASSERT(DrawList == &DrawListInst);
    IM_DELETE(Name);
    for (int i = 0; i != ColumnsStorage.Size; i++)
        ColumnsStorage[i].~ImGuiColumns();
}

ImGuiID ImGuiWindow::GetID(const char* str, const char* str_end)
{
    ImGuiID seed = IDStack.back();
    ImGuiID id = ImHashStr(str, str_end ? (str_end - str) : 0, seed);
    ImGui::KeepAliveID(id);
    return id;
}

ImGuiID ImGuiWindow::GetID(const void* ptr)
{
    ImGuiID seed = IDStack.back();
    ImGuiID id = ImHashData(&ptr, sizeof(void*), seed);
    ImGui::KeepAliveID(id);
    return id;
}

ImGuiID ImGuiWindow::GetIDNoKeepAlive(const char* str, const char* str_end)
{
    ImGuiID seed = IDStack.back();
    return ImHashStr(str, str_end ? (str_end - str) : 0, seed);
}

ImGuiID ImGuiWindow::GetIDNoKeepAlive(const void* ptr)
{
    ImGuiID seed = IDStack.back();
    return ImHashData(&ptr, sizeof(void*), seed);
}

// This is only used in rare/specific situations to manufacture an ID out of nowhere.
ImGuiID ImGuiWindow::GetIDFromRectangle(const ImRect& r_abs)
{
    ImGuiID seed = IDStack.back();
    const int r_rel[4] = { (int)(r_abs.Min.x - Pos.x), (int)(r_abs.Min.y - Pos.y), (int)(r_abs.Max.x - Pos.x), (int)(r_abs.Max.y - Pos.y) };
    ImGuiID id = ImHashData(&r_rel, sizeof(r_rel), seed);
    ImGui::KeepAliveID(id);
    return id;
}

static void SetCurrentWindow(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    g.CurrentWindow = window;
    if (window)
        g.FontSize = g.DrawListSharedData.FontSize = window->CalcFontSize();
}

void ImGui::SetNavID(ImGuiID id, int nav_layer)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.NavWindow);
    IM_ASSERT(nav_layer == 0 || nav_layer == 1);
    g.NavId = id;
    g.NavWindow->NavLastIds[nav_layer] = id;
}

void ImGui::SetNavIDWithRectRel(ImGuiID id, int nav_layer, const ImRect& rect_rel)
{
    ImGuiContext& g = *GImGui;
    SetNavID(id, nav_layer);
    g.NavWindow->NavRectRel[nav_layer] = rect_rel;
    g.NavMousePosDirty = true;
    g.NavDisableHighlight = false;
    g.NavDisableMouseHover = true;
}

void ImGui::SetActiveID(ImGuiID id, ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    g.ActiveIdIsJustActivated = (g.ActiveId != id);
    if (g.ActiveIdIsJustActivated)
    {
        g.ActiveIdTimer = 0.0f;
        g.ActiveIdHasBeenPressed = false;
        g.ActiveIdHasBeenEdited = false;
        if (id != 0)
        {
            g.LastActiveId = id;
            g.LastActiveIdTimer = 0.0f;
        }
    }
    g.ActiveId = id;
    g.ActiveIdAllowNavDirFlags = 0;
    g.ActiveIdBlockNavInputFlags = 0;
    g.ActiveIdAllowOverlap = false;
    g.ActiveIdWindow = window;
    if (id)
    {
        g.ActiveIdIsAlive = id;
        g.ActiveIdSource = (g.NavActivateId == id || g.NavInputId == id || g.NavJustTabbedId == id || g.NavJustMovedToId == id) ? ImGuiInputSource_Nav : ImGuiInputSource_Mouse;
    }
}

// FIXME-NAV: The existence of SetNavID/SetNavIDWithRectRel/SetFocusID is incredibly messy and confusing and needs some explanation or refactoring.
void ImGui::SetFocusID(ImGuiID id, ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(id != 0);

    // Assume that SetFocusID() is called in the context where its NavLayer is the current layer, which is the case everywhere we call it.
    const ImGuiNavLayer nav_layer = window->DC.NavLayerCurrent;
    if (g.NavWindow != window)
        g.NavInitRequest = false;
    g.NavId = id;
    g.NavWindow = window;
    g.NavLayer = nav_layer;
    window->NavLastIds[nav_layer] = id;
    if (window->DC.LastItemId == id)
        window->NavRectRel[nav_layer] = ImRect(window->DC.LastItemRect.Min - window->Pos, window->DC.LastItemRect.Max - window->Pos);

    if (g.ActiveIdSource == ImGuiInputSource_Nav)
        g.NavDisableMouseHover = true;
    else
        g.NavDisableHighlight = true;
}

void ImGui::ClearActiveID()
{
    SetActiveID(0, NULL);
}

void ImGui::SetHoveredID(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    g.HoveredId = id;
    g.HoveredIdAllowOverlap = false;
    if (id != 0 && g.HoveredIdPreviousFrame != id)
        g.HoveredIdTimer = g.HoveredIdNotActiveTimer = 0.0f;
}

ImGuiID ImGui::GetHoveredID()
{
    ImGuiContext& g = *GImGui;
    return g.HoveredId ? g.HoveredId : g.HoveredIdPreviousFrame;
}

void ImGui::KeepAliveID(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    if (g.ActiveId == id)
        g.ActiveIdIsAlive = id;
    if (g.ActiveIdPreviousFrame == id)
        g.ActiveIdPreviousFrameIsAlive = true;
}

void ImGui::MarkItemEdited(ImGuiID id)
{
    // This marking is solely to be able to provide info for IsItemDeactivatedAfterEdit().
    // ActiveId might have been released by the time we call this (as in the typical press/release button behavior) but still need need to fill the data.
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.ActiveId == id || g.ActiveId == 0 || g.DragDropActive);
    IM_UNUSED(id); // Avoid unused variable warnings when asserts are compiled out.
    //IM_ASSERT(g.CurrentWindow->DC.LastItemId == id);
    g.ActiveIdHasBeenEdited = true;
    g.CurrentWindow->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_Edited;
}

static inline bool IsWindowContentHoverable(ImGuiWindow* window, ImGuiHoveredFlags flags)
{
    // An active popup disable hovering on other windows (apart from its own children)
    // FIXME-OPT: This could be cached/stored within the window.
    ImGuiContext& g = *GImGui;
    if (g.NavWindow)
        if (ImGuiWindow* focused_root_window = g.NavWindow->RootWindow)
            if (focused_root_window->WasActive && focused_root_window != window->RootWindow)
            {
                // For the purpose of those flags we differentiate "standard popup" from "modal popup"
                // NB: The order of those two tests is important because Modal windows are also Popups.
                if (focused_root_window->Flags & ImGuiWindowFlags_Modal)
                    return false;
                if ((focused_root_window->Flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiHoveredFlags_AllowWhenBlockedByPopup))
                    return false;
            }

    return true;
}

// Advance cursor given item size for layout.
void ImGui::ItemSize(const ImVec2& size, float text_offset_y)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (window->SkipItems)
        return;

    // Always align ourselves on pixel boundaries
    const float line_height = ImMax(window->DC.CurrentLineSize.y, size.y);
    const float text_base_offset = ImMax(window->DC.CurrentLineTextBaseOffset, text_offset_y);
    //if (g.IO.KeyAlt) window->DrawList->AddRect(window->DC.CursorPos, window->DC.CursorPos + ImVec2(size.x, line_height), IM_COL32(255,0,0,200)); // [DEBUG]
    window->DC.CursorPosPrevLine = ImVec2(window->DC.CursorPos.x + size.x, window->DC.CursorPos.y);
    window->DC.CursorPos.x = (float)(int)(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);
    window->DC.CursorPos.y = (float)(int)(window->DC.CursorPos.y + line_height + g.Style.ItemSpacing.y);
    window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPosPrevLine.x);
    window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, window->DC.CursorPos.y - g.Style.ItemSpacing.y);
    //if (g.IO.KeyAlt) window->DrawList->AddCircle(window->DC.CursorMaxPos, 3.0f, IM_COL32(255,0,0,255), 4); // [DEBUG]

    window->DC.PrevLineSize.y = line_height;
    window->DC.PrevLineTextBaseOffset = text_base_offset;
    window->DC.CurrentLineSize.y = window->DC.CurrentLineTextBaseOffset = 0.0f;

    // Horizontal layout mode
    if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)
        SameLine();
}

void ImGui::ItemSize(const ImRect& bb, float text_offset_y)
{
    ItemSize(bb.GetSize(), text_offset_y);
}

// Declare item bounding box for clipping and interaction.
// Note that the size can be different than the one provided to ItemSize(). Typically, widgets that spread over available surface
// declare their minimum size requirement to ItemSize() and then use a larger region for drawing/interaction, which is passed to ItemAdd().
bool ImGui::ItemAdd(const ImRect& bb, ImGuiID id, const ImRect* nav_bb_arg)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    if (id != 0)
    {
        // Navigation processing runs prior to clipping early-out
        //  (a) So that NavInitRequest can be honored, for newly opened windows to select a default widget
        //  (b) So that we can scroll up/down past clipped items. This adds a small O(N) cost to regular navigation requests unfortunately, but it is still limited to one window.
        //      it may not scale very well for windows with ten of thousands of item, but at least NavMoveRequest is only set on user interaction, aka maximum once a frame.
        //      We could early out with "if (is_clipped && !g.NavInitRequest) return false;" but when we wouldn't be able to reach unclipped widgets. This would work if user had explicit scrolling control (e.g. mapped on a stick)
        window->DC.NavLayerActiveMaskNext |= window->DC.NavLayerCurrentMask;
        if (g.NavId == id || g.NavAnyRequest)
            if (g.NavWindow->RootWindowForNav == window->RootWindowForNav)
                if (window == g.NavWindow || ((window->Flags | g.NavWindow->Flags) & ImGuiWindowFlags_NavFlattened))
                    NavProcessItem(window, nav_bb_arg ? *nav_bb_arg : bb, id);
    }

    window->DC.LastItemId = id;
    window->DC.LastItemRect = bb;
    window->DC.LastItemStatusFlags = ImGuiItemStatusFlags_None;

#ifdef IMGUI_ENABLE_TEST_ENGINE
    if (id != 0)
        IMGUI_TEST_ENGINE_ITEM_ADD(nav_bb_arg ? *nav_bb_arg : bb, id);
#endif

    // Clipping test
    const bool is_clipped = IsClippedEx(bb, id, false);
    if (is_clipped)
        return false;
    //if (g.IO.KeyAlt) window->DrawList->AddRect(bb.Min, bb.Max, IM_COL32(255,255,0,120)); // [DEBUG]

    // We need to calculate this now to take account of the current clipping rectangle (as items like Selectable may change them)
    if (IsMouseHoveringRect(bb.Min, bb.Max))
        window->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_HoveredRect;
    return true;
}

// This is roughly matching the behavior of internal-facing ItemHoverable()
// - we allow hovering to be true when ActiveId==window->MoveID, so that clicking on non-interactive items such as a Text() item still returns true with IsItemHovered()
// - this should work even for non-interactive items that have no ID, so we cannot use LastItemId
bool ImGui::IsItemHovered(ImGuiHoveredFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (g.NavDisableMouseHover && !g.NavDisableHighlight)
        return IsItemFocused();

    // Test for bounding box overlap, as updated as ItemAdd()
    if (!(window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HoveredRect))
        return false;
    IM_ASSERT((flags & (ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows)) == 0);   // Flags not supported by this function

    // Test if we are hovering the right window (our window could be behind another window)
    // [2017/10/16] Reverted commit 344d48be3 and testing RootWindow instead. I believe it is correct to NOT test for RootWindow but this leaves us unable to use IsItemHovered() after EndChild() itself.
    // Until a solution is found I believe reverting to the test from 2017/09/27 is safe since this was the test that has been running for a long while.
    //if (g.HoveredWindow != window)
    //    return false;
    if (g.HoveredRootWindow != window->RootWindow && !(flags & ImGuiHoveredFlags_AllowWhenOverlapped))
        return false;

    // Test if another item is active (e.g. being dragged)
    if (!(flags & ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))
        if (g.ActiveId != 0 && g.ActiveId != window->DC.LastItemId && !g.ActiveIdAllowOverlap && g.ActiveId != window->MoveId)
            return false;

    // Test if interactions on this window are blocked by an active popup or modal.
    // The ImGuiHoveredFlags_AllowWhenBlockedByPopup flag will be tested here.
    if (!IsWindowContentHoverable(window, flags))
        return false;

    // Test if the item is disabled
    if ((window->DC.ItemFlags & ImGuiItemFlags_Disabled) && !(flags & ImGuiHoveredFlags_AllowWhenDisabled))
        return false;

    // Special handling for the dummy item after Begin() which represent the title bar or tab.
    // When the window is collapsed (SkipItems==true) that last item will never be overwritten so we need to detect the case.
    if (window->DC.LastItemId == window->MoveId && window->WriteAccessed)
        return false;
    return true;
}

// Internal facing ItemHoverable() used when submitting widgets. Differs slightly from IsItemHovered().
bool ImGui::ItemHoverable(const ImRect& bb, ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    if (g.HoveredId != 0 && g.HoveredId != id && !g.HoveredIdAllowOverlap)
        return false;

    ImGuiWindow* window = g.CurrentWindow;
    if (g.HoveredWindow != window)
        return false;
    if (g.ActiveId != 0 && g.ActiveId != id && !g.ActiveIdAllowOverlap)
        return false;
    if (!IsMouseHoveringRect(bb.Min, bb.Max))
        return false;
    if (g.NavDisableMouseHover || !IsWindowContentHoverable(window, ImGuiHoveredFlags_None))
        return false;
    if (window->DC.ItemFlags & ImGuiItemFlags_Disabled)
        return false;

    SetHoveredID(id);
    return true;
}

bool ImGui::IsClippedEx(const ImRect& bb, ImGuiID id, bool clip_even_when_logged)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (!bb.Overlaps(window->ClipRect))
        if (id == 0 || id != g.ActiveId)
            if (clip_even_when_logged || !g.LogEnabled)
                return true;
    return false;
}

// Process TAB/Shift+TAB. Be mindful that this function may _clear_ the ActiveID when tabbing out.
bool ImGui::FocusableItemRegister(ImGuiWindow* window, ImGuiID id)
{
    ImGuiContext& g = *GImGui;

    // Increment counters
    const bool is_tab_stop = (window->DC.ItemFlags & (ImGuiItemFlags_NoTabStop | ImGuiItemFlags_Disabled)) == 0;
    window->DC.FocusCounterAll++;
    if (is_tab_stop)
        window->DC.FocusCounterTab++;

    // Process TAB/Shift-TAB to tab *OUT* of the currently focused item.
    // (Note that we can always TAB out of a widget that doesn't allow tabbing in)
    if (g.ActiveId == id && g.FocusTabPressed && !(g.ActiveIdBlockNavInputFlags & (1 << ImGuiNavInput_KeyTab_)) && g.FocusRequestNextWindow == NULL)
    {
        g.FocusRequestNextWindow = window;
        g.FocusRequestNextCounterTab = window->DC.FocusCounterTab + (g.IO.KeyShift ? (is_tab_stop ? -1 : 0) : +1); // Modulo on index will be applied at the end of frame once we've got the total counter of items.
    }

    // Handle focus requests
    if (g.FocusRequestCurrWindow == window)
    {
        if (window->DC.FocusCounterAll == g.FocusRequestCurrCounterAll)
            return true;
        if (is_tab_stop && window->DC.FocusCounterTab == g.FocusRequestCurrCounterTab)
        {
            g.NavJustTabbedId = id;
            return true;
        }

        // If another item is about to be focused, we clear our own active id
        if (g.ActiveId == id)
            ClearActiveID();
    }

    return false;
}

void ImGui::FocusableItemUnregister(ImGuiWindow* window)
{
    window->DC.FocusCounterAll--;
    window->DC.FocusCounterTab--;
}

float ImGui::CalcWrapWidthForPos(const ImVec2& pos, float wrap_pos_x)
{
    if (wrap_pos_x < 0.0f)
        return 0.0f;

    ImGuiWindow* window = GImGui->CurrentWindow;
    if (wrap_pos_x == 0.0f)
        wrap_pos_x = GetWorkRectMax().x;
    else if (wrap_pos_x > 0.0f)
        wrap_pos_x += window->Pos.x - window->Scroll.x; // wrap_pos_x is provided is window local space

    return ImMax(wrap_pos_x - pos.x, 1.0f);
}

// IM_ALLOC() == ImGui::MemAlloc()
void* ImGui::MemAlloc(size_t size)
{
    if (ImGuiContext* ctx = GImGui)
        ctx->IO.MetricsActiveAllocations++;
    return GImAllocatorAllocFunc(size, GImAllocatorUserData);
}

// IM_FREE() == ImGui::MemFree()
void ImGui::MemFree(void* ptr)
{
    if (ptr)
        if (ImGuiContext* ctx = GImGui)
            ctx->IO.MetricsActiveAllocations--;
    return GImAllocatorFreeFunc(ptr, GImAllocatorUserData);
}

const char* ImGui::GetClipboardText()
{
    return GImGui->IO.GetClipboardTextFn ? GImGui->IO.GetClipboardTextFn(GImGui->IO.ClipboardUserData) : "";
}

void ImGui::SetClipboardText(const char* text)
{
    if (GImGui->IO.SetClipboardTextFn)
        GImGui->IO.SetClipboardTextFn(GImGui->IO.ClipboardUserData, text);
}

const char* ImGui::GetVersion()
{
    return IMGUI_VERSION;
}

// Internal state access - if you want to share ImGui state between modules (e.g. DLL) or allocate it yourself
// Note that we still point to some static data and members (such as GFontAtlas), so the state instance you end up using will point to the static data within its module
ImGuiContext* ImGui::GetCurrentContext()
{
    return GImGui;
}

void ImGui::SetCurrentContext(ImGuiContext* ctx)
{
#ifdef IMGUI_SET_CURRENT_CONTEXT_FUNC
    IMGUI_SET_CURRENT_CONTEXT_FUNC(ctx); // For custom thread-based hackery you may want to have control over this.
#else
    GImGui = ctx;
#endif
}

// Helper function to verify ABI compatibility between caller code and compiled version of Dear ImGui.
// Verify that the type sizes are matching between the calling file's compilation unit and imgui.cpp's compilation unit
// If the user has inconsistent compilation settings, imgui configuration #define, packing pragma, etc. your user code
// may see different structures thanwhat imgui.cpp sees, which is problematic.
// We usually require settings to be in imconfig.h to make sure that they are accessible to all compilation units involved with Dear ImGui.
bool ImGui::DebugCheckVersionAndDataLayout(const char* version, size_t sz_io, size_t sz_style, size_t sz_vec2, size_t sz_vec4, size_t sz_vert, size_t sz_idx)
{
    bool error = false;
    if (strcmp(version, IMGUI_VERSION)!=0) { error = true; IM_ASSERT(strcmp(version,IMGUI_VERSION)==0 && "Mismatched version string!");  }
    if (sz_io    != sizeof(ImGuiIO))       { error = true; IM_ASSERT(sz_io    == sizeof(ImGuiIO)      && "Mismatched struct layout!"); }
    if (sz_style != sizeof(ImGuiStyle))    { error = true; IM_ASSERT(sz_style == sizeof(ImGuiStyle)   && "Mismatched struct layout!"); }
    if (sz_vec2  != sizeof(ImVec2))        { error = true; IM_ASSERT(sz_vec2  == sizeof(ImVec2)       && "Mismatched struct layout!"); }
    if (sz_vec4  != sizeof(ImVec4))        { error = true; IM_ASSERT(sz_vec4  == sizeof(ImVec4)       && "Mismatched struct layout!"); }
    if (sz_vert  != sizeof(ImDrawVert))    { error = true; IM_ASSERT(sz_vert  == sizeof(ImDrawVert)   && "Mismatched struct layout!"); }
    if (sz_idx   != sizeof(ImDrawIdx))     { error = true; IM_ASSERT(sz_idx   == sizeof(ImDrawIdx)    && "Mismatched struct layout!"); }
    return !error;
}

void ImGui::SetAllocatorFunctions(void* (*alloc_func)(size_t sz, void* user_data), void (*free_func)(void* ptr, void* user_data), void* user_data)
{
    GImAllocatorAllocFunc = alloc_func;
    GImAllocatorFreeFunc = free_func;
    GImAllocatorUserData = user_data;
}

ImGuiContext* ImGui::CreateContext(ImFontAtlas* shared_font_atlas)
{
    ImGuiContext* ctx = IM_NEW(ImGuiContext)(shared_font_atlas);
    if (GImGui == NULL)
        SetCurrentContext(ctx);
    Initialize(ctx);
    return ctx;
}

void ImGui::DestroyContext(ImGuiContext* ctx)
{
    if (ctx == NULL)
        ctx = GImGui;
    Shutdown(ctx);
    if (GImGui == ctx)
        SetCurrentContext(NULL);
    IM_DELETE(ctx);
}

ImGuiIO& ImGui::GetIO()
{
    IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?");
    return GImGui->IO;
}

ImGuiStyle& ImGui::GetStyle()
{
    IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?");
    return GImGui->Style;
}

// Same value as passed to the old io.RenderDrawListsFn function. Valid after Render() and until the next call to NewFrame()
ImDrawData* ImGui::GetDrawData()
{
    ImGuiContext& g = *GImGui;
    return g.DrawData.Valid ? &g.DrawData : NULL;
}

double ImGui::GetTime()
{
    return GImGui->Time;
}

int ImGui::GetFrameCount()
{
    return GImGui->FrameCount;
}

ImDrawList* ImGui::GetBackgroundDrawList()
{
    return &GImGui->BackgroundDrawList;
}

static ImDrawList* GetForegroundDrawList(ImGuiWindow*)
{
    // This seemingly unnecessary wrapper simplifies compatibility between the 'master' and 'docking' branches.
    return &GImGui->ForegroundDrawList;
}

ImDrawList* ImGui::GetForegroundDrawList()
{
    return &GImGui->ForegroundDrawList;
}

ImDrawListSharedData* ImGui::GetDrawListSharedData()
{
    return &GImGui->DrawListSharedData;
}

void ImGui::StartMouseMovingWindow(ImGuiWindow* window)
{
    // Set ActiveId even if the _NoMove flag is set. Without it, dragging away from a window with _NoMove would activate hover on other windows.
    // We _also_ call this when clicking in a window empty space when io.ConfigWindowsMoveFromTitleBarOnly is set, but clear g.MovingWindow afterward.
    // This is because we want ActiveId to be set even when the window is not permitted to move.
    ImGuiContext& g = *GImGui;
    FocusWindow(window);
    SetActiveID(window->MoveId, window);
    g.NavDisableHighlight = true;
    g.ActiveIdClickOffset = g.IO.MousePos - window->RootWindow->Pos;

    bool can_move_window = true;
    if ((window->Flags & ImGuiWindowFlags_NoMove) || (window->RootWindow->Flags & ImGuiWindowFlags_NoMove))
        can_move_window = false;
    if (can_move_window)
        g.MovingWindow = window;
}

// Handle mouse moving window
// Note: moving window with the navigation keys (Square + d-pad / CTRL+TAB + Arrows) are processed in NavUpdateWindowing()
void ImGui::UpdateMouseMovingWindowNewFrame()
{
    ImGuiContext& g = *GImGui;
    if (g.MovingWindow != NULL)
    {
        // We actually want to move the root window. g.MovingWindow == window we clicked on (could be a child window).
        // We track it to preserve Focus and so that generally ActiveIdWindow == MovingWindow and ActiveId == MovingWindow->MoveId for consistency.
        KeepAliveID(g.ActiveId);
        IM_ASSERT(g.MovingWindow && g.MovingWindow->RootWindow);
        ImGuiWindow* moving_window = g.MovingWindow->RootWindow;
        if (g.IO.MouseDown[0] && IsMousePosValid(&g.IO.MousePos))
        {
            ImVec2 pos = g.IO.MousePos - g.ActiveIdClickOffset;
            if (moving_window->Pos.x != pos.x || moving_window->Pos.y != pos.y)
            {
                MarkIniSettingsDirty(moving_window);
                SetWindowPos(moving_window, pos, ImGuiCond_Always);
            }
            FocusWindow(g.MovingWindow);
        }
        else
        {
            ClearActiveID();
            g.MovingWindow = NULL;
        }
    }
    else
    {
        // When clicking/dragging from a window that has the _NoMove flag, we still set the ActiveId in order to prevent hovering others.
        if (g.ActiveIdWindow && g.ActiveIdWindow->MoveId == g.ActiveId)
        {
            KeepAliveID(g.ActiveId);
            if (!g.IO.MouseDown[0])
                ClearActiveID();
        }
    }
}

// Initiate moving window, handle left-click and right-click focus
void ImGui::UpdateMouseMovingWindowEndFrame()
{
    // Initiate moving window
    ImGuiContext& g = *GImGui;
    if (g.ActiveId != 0 || g.HoveredId != 0)
        return;

    // Unless we just made a window/popup appear
    if (g.NavWindow && g.NavWindow->Appearing)
        return;

    // Click to focus window and start moving (after we're done with all our widgets)
    if (g.IO.MouseClicked[0])
    {
        if (g.HoveredRootWindow != NULL)
        {
            StartMouseMovingWindow(g.HoveredWindow);
            if (g.IO.ConfigWindowsMoveFromTitleBarOnly && !(g.HoveredRootWindow->Flags & ImGuiWindowFlags_NoTitleBar))
                if (!g.HoveredRootWindow->TitleBarRect().Contains(g.IO.MouseClickedPos[0]))
                    g.MovingWindow = NULL;
        }
        else if (g.NavWindow != NULL && GetFrontMostPopupModal() == NULL)
        {
            // Clicking on void disable focus
            FocusWindow(NULL);
        }
    }

    // With right mouse button we close popups without changing focus based on where the mouse is aimed
    // Instead, focus will be restored to the window under the bottom-most closed popup.
    // (The left mouse button path calls FocusWindow on the hovered window, which will lead NewFrame->ClosePopupsOverWindow to trigger)
    if (g.IO.MouseClicked[1])
    {
        // Find the top-most window between HoveredWindow and the front most Modal Window.
        // This is where we can trim the popup stack.
        ImGuiWindow* modal = GetFrontMostPopupModal();
        bool hovered_window_above_modal = false;
        if (modal == NULL)
            hovered_window_above_modal = true;
        for (int i = g.Windows.Size - 1; i >= 0 && hovered_window_above_modal == false; i--)
        {
            ImGuiWindow* window = g.Windows[i];
            if (window == modal)
                break;
            if (window == g.HoveredWindow)
                hovered_window_above_modal = true;
        }
        ClosePopupsOverWindow(hovered_window_above_modal ? g.HoveredWindow : modal, true);
    }
}

static bool IsWindowActiveAndVisible(ImGuiWindow* window)
{
    return (window->Active) && (!window->Hidden);
}

static void ImGui::UpdateMouseInputs()
{
    ImGuiContext& g = *GImGui;

    // Round mouse position to avoid spreading non-rounded position (e.g. UpdateManualResize doesn't support them well)
    if (IsMousePosValid(&g.IO.MousePos))
        g.IO.MousePos = g.LastValidMousePos = ImFloor(g.IO.MousePos);

    // If mouse just appeared or disappeared (usually denoted by -FLT_MAX components) we cancel out movement in MouseDelta
    if (IsMousePosValid(&g.IO.MousePos) && IsMousePosValid(&g.IO.MousePosPrev))
        g.IO.MouseDelta = g.IO.MousePos - g.IO.MousePosPrev;
    else
        g.IO.MouseDelta = ImVec2(0.0f, 0.0f);
    if (g.IO.MouseDelta.x != 0.0f || g.IO.MouseDelta.y != 0.0f)
        g.NavDisableMouseHover = false;

    g.IO.MousePosPrev = g.IO.MousePos;
    for (int i = 0; i < IM_ARRAYSIZE(g.IO.MouseDown); i++)
    {
        g.IO.MouseClicked[i] = g.IO.MouseDown[i] && g.IO.MouseDownDuration[i] < 0.0f;
        g.IO.MouseReleased[i] = !g.IO.MouseDown[i] && g.IO.MouseDownDuration[i] >= 0.0f;
        g.IO.MouseDownDurationPrev[i] = g.IO.MouseDownDuration[i];
        g.IO.MouseDownDuration[i] = g.IO.MouseDown[i] ? (g.IO.MouseDownDuration[i] < 0.0f ? 0.0f : g.IO.MouseDownDuration[i] + g.IO.DeltaTime) : -1.0f;
        g.IO.MouseDoubleClicked[i] = false;
        if (g.IO.MouseClicked[i])
        {
            if ((float)(g.Time - g.IO.MouseClickedTime[i]) < g.IO.MouseDoubleClickTime)
            {
                ImVec2 delta_from_click_pos = IsMousePosValid(&g.IO.MousePos) ? (g.IO.MousePos - g.IO.MouseClickedPos[i]) : ImVec2(0.0f, 0.0f);
                if (ImLengthSqr(delta_from_click_pos) < g.IO.MouseDoubleClickMaxDist * g.IO.MouseDoubleClickMaxDist)
                    g.IO.MouseDoubleClicked[i] = true;
                g.IO.MouseClickedTime[i] = -FLT_MAX;    // so the third click isn't turned into a double-click
            }
            else
            {
                g.IO.MouseClickedTime[i] = g.Time;
            }
            g.IO.MouseClickedPos[i] = g.IO.MousePos;
            g.IO.MouseDownWasDoubleClick[i] = g.IO.MouseDoubleClicked[i];
            g.IO.MouseDragMaxDistanceAbs[i] = ImVec2(0.0f, 0.0f);
            g.IO.MouseDragMaxDistanceSqr[i] = 0.0f;
        }
        else if (g.IO.MouseDown[i])
        {
            // Maintain the maximum distance we reaching from the initial click position, which is used with dragging threshold
            ImVec2 delta_from_click_pos = IsMousePosValid(&g.IO.MousePos) ? (g.IO.MousePos - g.IO.MouseClickedPos[i]) : ImVec2(0.0f, 0.0f);
            g.IO.MouseDragMaxDistanceSqr[i] = ImMax(g.IO.MouseDragMaxDistanceSqr[i], ImLengthSqr(delta_from_click_pos));
            g.IO.MouseDragMaxDistanceAbs[i].x = ImMax(g.IO.MouseDragMaxDistanceAbs[i].x, delta_from_click_pos.x < 0.0f ? -delta_from_click_pos.x : delta_from_click_pos.x);
            g.IO.MouseDragMaxDistanceAbs[i].y = ImMax(g.IO.MouseDragMaxDistanceAbs[i].y, delta_from_click_pos.y < 0.0f ? -delta_from_click_pos.y : delta_from_click_pos.y);
        }
        if (!g.IO.MouseDown[i] && !g.IO.MouseReleased[i])
            g.IO.MouseDownWasDoubleClick[i] = false;
        if (g.IO.MouseClicked[i]) // Clicking any mouse button reactivate mouse hovering which may have been deactivated by gamepad/keyboard navigation
            g.NavDisableMouseHover = false;
    }
}

void ImGui::UpdateMouseWheel()
{
    ImGuiContext& g = *GImGui;
    if (!g.HoveredWindow || g.HoveredWindow->Collapsed)
        return;
    if (g.IO.MouseWheel == 0.0f && g.IO.MouseWheelH == 0.0f)
        return;
    ImGuiWindow* window = g.HoveredWindow;

    // Zoom / Scale window
    // FIXME-OBSOLETE: This is an old feature, it still works but pretty much nobody is using it and may be best redesigned.
    if (g.IO.MouseWheel != 0.0f && g.IO.KeyCtrl && g.IO.FontAllowUserScaling)
    {
        const float new_font_scale = ImClamp(window->FontWindowScale + g.IO.MouseWheel * 0.10f, 0.50f, 2.50f);
        const float scale = new_font_scale / window->FontWindowScale;
        window->FontWindowScale = new_font_scale;
        if (!(window->Flags & ImGuiWindowFlags_ChildWindow))
        {
            const ImVec2 offset = window->Size * (1.0f - scale) * (g.IO.MousePos - window->Pos) / window->Size;
            window->Pos = ImFloor(window->Pos + offset);
            window->Size = ImFloor(window->Size * scale);
            window->SizeFull = ImFloor(window->SizeFull * scale);
        }
        return;
    }

    // Mouse wheel scrolling
    // If a child window has the ImGuiWindowFlags_NoScrollWithMouse flag, we give a chance to scroll its parent (unless either ImGuiWindowFlags_NoInputs or ImGuiWindowFlags_NoScrollbar are also set).
    while ((window->Flags & ImGuiWindowFlags_ChildWindow) && (window->Flags & ImGuiWindowFlags_NoScrollWithMouse) && !(window->Flags & ImGuiWindowFlags_NoScrollbar) && !(window->Flags & ImGuiWindowFlags_NoMouseInputs) && window->ParentWindow)
        window = window->ParentWindow;
    const bool scroll_allowed = !(window->Flags & ImGuiWindowFlags_NoScrollWithMouse) && !(window->Flags & ImGuiWindowFlags_NoMouseInputs);
    if (scroll_allowed && (g.IO.MouseWheel != 0.0f || g.IO.MouseWheelH != 0.0f) && !g.IO.KeyCtrl)
    {
        ImVec2 max_step = (window->ContentsRegionRect.GetSize() + window->WindowPadding * 2.0f) * 0.67f;

        // Vertical Mouse Wheel Scrolling (hold Shift to scroll horizontally)
        if (g.IO.MouseWheel != 0.0f && !g.IO.KeyShift)
        {
            float scroll_step = ImFloor(ImMin(5 * window->CalcFontSize(), max_step.y));
            SetWindowScrollY(window, window->Scroll.y - g.IO.MouseWheel * scroll_step);
        }
        else if (g.IO.MouseWheel != 0.0f && g.IO.KeyShift)
        {
            float scroll_step = ImFloor(ImMin(2 * window->CalcFontSize(), max_step.x));
            SetWindowScrollX(window, window->Scroll.x - g.IO.MouseWheel * scroll_step);
        }

        // Horizontal Mouse Wheel Scrolling (for hardware that supports it)
        if (g.IO.MouseWheelH != 0.0f && !g.IO.KeyShift)
        {
            float scroll_step = ImFloor(ImMin(2 * window->CalcFontSize(), max_step.x));
            SetWindowScrollX(window, window->Scroll.x - g.IO.MouseWheelH * scroll_step);
        }
    }
}

// The reason this is exposed in imgui_internal.h is: on touch-based system that don't have hovering, we want to dispatch inputs to the right target (imgui vs imgui+app)
void ImGui::UpdateHoveredWindowAndCaptureFlags()
{
    ImGuiContext& g = *GImGui;

    // Find the window hovered by mouse:
    // - Child windows can extend beyond the limit of their parent so we need to derive HoveredRootWindow from HoveredWindow.
    // - When moving a window we can skip the search, which also conveniently bypasses the fact that window->WindowRectClipped is lagging as this point of the frame.
    // - We also support the moved window toggling the NoInputs flag after moving has started in order to be able to detect windows below it, which is useful for e.g. docking mechanisms.
    FindHoveredWindow();

    // Modal windows prevents cursor from hovering behind them.
    ImGuiWindow* modal_window = GetFrontMostPopupModal();
    if (modal_window)
        if (g.HoveredRootWindow && !IsWindowChildOf(g.HoveredRootWindow, modal_window))
            g.HoveredRootWindow = g.HoveredWindow = NULL;

    // Disabled mouse?
    if (g.IO.ConfigFlags & ImGuiConfigFlags_NoMouse)
        g.HoveredWindow = g.HoveredRootWindow = NULL;

    // We track click ownership. When clicked outside of a window the click is owned by the application and won't report hovering nor request capture even while dragging over our windows afterward.
    int mouse_earliest_button_down = -1;
    bool mouse_any_down = false;
    for (int i = 0; i < IM_ARRAYSIZE(g.IO.MouseDown); i++)
    {
        if (g.IO.MouseClicked[i])
            g.IO.MouseDownOwned[i] = (g.HoveredWindow != NULL) || (!g.OpenPopupStack.empty());
        mouse_any_down |= g.IO.MouseDown[i];
        if (g.IO.MouseDown[i])
            if (mouse_earliest_button_down == -1 || g.IO.MouseClickedTime[i] < g.IO.MouseClickedTime[mouse_earliest_button_down])
                mouse_earliest_button_down = i;
    }
    const bool mouse_avail_to_imgui = (mouse_earliest_button_down == -1) || g.IO.MouseDownOwned[mouse_earliest_button_down];

    // If mouse was first clicked outside of ImGui bounds we also cancel out hovering.
    // FIXME: For patterns of drag and drop across OS windows, we may need to rework/remove this test (first committed 311c0ca9 on 2015/02)
    const bool mouse_dragging_extern_payload = g.DragDropActive && (g.DragDropSourceFlags & ImGuiDragDropFlags_SourceExtern) != 0;
    if (!mouse_avail_to_imgui && !mouse_dragging_extern_payload)
        g.HoveredWindow = g.HoveredRootWindow = NULL;

    // Update io.WantCaptureMouse for the user application (true = dispatch mouse info to imgui, false = dispatch mouse info to imgui + app)
    if (g.WantCaptureMouseNextFrame != -1)
        g.IO.WantCaptureMouse = (g.WantCaptureMouseNextFrame != 0);
    else
        g.IO.WantCaptureMouse = (mouse_avail_to_imgui && (g.HoveredWindow != NULL || mouse_any_down)) || (!g.OpenPopupStack.empty());

    // Update io.WantCaptureKeyboard for the user application (true = dispatch keyboard info to imgui, false = dispatch keyboard info to imgui + app)
    if (g.WantCaptureKeyboardNextFrame != -1)
        g.IO.WantCaptureKeyboard = (g.WantCaptureKeyboardNextFrame != 0);
    else
        g.IO.WantCaptureKeyboard = (g.ActiveId != 0) || (modal_window != NULL);
    if (g.IO.NavActive && (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) && !(g.IO.ConfigFlags & ImGuiConfigFlags_NavNoCaptureKeyboard))
        g.IO.WantCaptureKeyboard = true;

    // Update io.WantTextInput flag, this is to allow systems without a keyboard (e.g. mobile, hand-held) to show a software keyboard if possible
    g.IO.WantTextInput = (g.WantTextInputNextFrame != -1) ? (g.WantTextInputNextFrame != 0) : false;
}

void ImGui::NewFrame()
{
    IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?");
    ImGuiContext& g = *GImGui;

#ifdef IMGUI_ENABLE_TEST_ENGINE
    ImGuiTestEngineHook_PreNewFrame(&g);
#endif

    // Check user data
    // (We pass an error message in the assert expression to make it visible to programmers who are not using a debugger, as most assert handlers display their argument)
    IM_ASSERT(g.Initialized);
    IM_ASSERT((g.IO.DeltaTime > 0.0f || g.FrameCount == 0)              && "Need a positive DeltaTime!");
    IM_ASSERT((g.FrameCount == 0 || g.FrameCountEnded == g.FrameCount)  && "Forgot to call Render() or EndFrame() at the end of the previous frame?");
    IM_ASSERT(g.IO.DisplaySize.x >= 0.0f && g.IO.DisplaySize.y >= 0.0f  && "Invalid DisplaySize value!");
    IM_ASSERT(g.IO.Fonts->Fonts.Size > 0                                && "Font Atlas not built. Did you call io.Fonts->GetTexDataAsRGBA32() / GetTexDataAsAlpha8() ?");
    IM_ASSERT(g.IO.Fonts->Fonts[0]->IsLoaded()                          && "Font Atlas not built. Did you call io.Fonts->GetTexDataAsRGBA32() / GetTexDataAsAlpha8() ?");
    IM_ASSERT(g.Style.CurveTessellationTol > 0.0f                       && "Invalid style setting!");
    IM_ASSERT(g.Style.Alpha >= 0.0f && g.Style.Alpha <= 1.0f            && "Invalid style setting. Alpha cannot be negative (allows us to avoid a few clamps in color computations)!");
    IM_ASSERT(g.Style.WindowMinSize.x >= 1.0f && g.Style.WindowMinSize.y >= 1.0f && "Invalid style setting.");
    for (int n = 0; n < ImGuiKey_COUNT; n++)
        IM_ASSERT(g.IO.KeyMap[n] >= -1 && g.IO.KeyMap[n] < IM_ARRAYSIZE(g.IO.KeysDown) && "io.KeyMap[] contains an out of bound value (need to be 0..512, or -1 for unmapped key)");

    // Perform simple check: required key mapping (we intentionally do NOT check all keys to not pressure user into setting up everything, but Space is required and was only recently added in 1.60 WIP)
    if (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard)
        IM_ASSERT(g.IO.KeyMap[ImGuiKey_Space] != -1 && "ImGuiKey_Space is not mapped, required for keyboard navigation.");

    // Perform simple check: the beta io.ConfigWindowsResizeFromEdges option requires back-end to honor mouse cursor changes and set the ImGuiBackendFlags_HasMouseCursors flag accordingly.
    if (g.IO.ConfigWindowsResizeFromEdges && !(g.IO.BackendFlags & ImGuiBackendFlags_HasMouseCursors))
        g.IO.ConfigWindowsResizeFromEdges = false;

    // Load settings on first frame (if not explicitly loaded manually before)
    if (!g.SettingsLoaded)
    {
        IM_ASSERT(g.SettingsWindows.empty());
        if (g.IO.IniFilename)
            LoadIniSettingsFromDisk(g.IO.IniFilename);
        g.SettingsLoaded = true;
    }

    // Save settings (with a delay after the last modification, so we don't spam disk too much)
    if (g.SettingsDirtyTimer > 0.0f)
    {
        g.SettingsDirtyTimer -= g.IO.DeltaTime;
        if (g.SettingsDirtyTimer <= 0.0f)
        {
            if (g.IO.IniFilename != NULL)
                SaveIniSettingsToDisk(g.IO.IniFilename);
            else
                g.IO.WantSaveIniSettings = true;  // Let user know they can call SaveIniSettingsToMemory(). user will need to clear io.WantSaveIniSettings themselves.
            g.SettingsDirtyTimer = 0.0f;
        }
    }

    g.Time += g.IO.DeltaTime;
    g.FrameScopeActive = true;
    g.FrameCount += 1;
    g.TooltipOverrideCount = 0;
    g.WindowsActiveCount = 0;

    // Setup current font and draw list shared data
    g.IO.Fonts->Locked = true;
    SetCurrentFont(GetDefaultFont());
    IM_ASSERT(g.Font->IsLoaded());
    g.DrawListSharedData.ClipRectFullscreen = ImVec4(0.0f, 0.0f, g.IO.DisplaySize.x, g.IO.DisplaySize.y);
    g.DrawListSharedData.CurveTessellationTol = g.Style.CurveTessellationTol;

    g.BackgroundDrawList.Clear();
    g.BackgroundDrawList.PushTextureID(g.IO.Fonts->TexID);
    g.BackgroundDrawList.PushClipRectFullScreen();
    g.BackgroundDrawList.Flags = (g.Style.AntiAliasedLines ? ImDrawListFlags_AntiAliasedLines : 0) | (g.Style.AntiAliasedFill ? ImDrawListFlags_AntiAliasedFill : 0);

    g.ForegroundDrawList.Clear();
    g.ForegroundDrawList.PushTextureID(g.IO.Fonts->TexID);
    g.ForegroundDrawList.PushClipRectFullScreen();
    g.ForegroundDrawList.Flags = (g.Style.AntiAliasedLines ? ImDrawListFlags_AntiAliasedLines : 0) | (g.Style.AntiAliasedFill ? ImDrawListFlags_AntiAliasedFill : 0);

    // Mark rendering data as invalid to prevent user who may have a handle on it to use it.
    g.DrawData.Clear();

    // Drag and drop keep the source ID alive so even if the source disappear our state is consistent
    if (g.DragDropActive && g.DragDropPayload.SourceId == g.ActiveId)
        KeepAliveID(g.DragDropPayload.SourceId);

    // Clear reference to active widget if the widget isn't alive anymore
    if (!g.HoveredIdPreviousFrame)
        g.HoveredIdTimer = 0.0f;
    if (!g.HoveredIdPreviousFrame || (g.HoveredId && g.ActiveId == g.HoveredId))
        g.HoveredIdNotActiveTimer = 0.0f;
    if (g.HoveredId)
        g.HoveredIdTimer += g.IO.DeltaTime;
    if (g.HoveredId && g.ActiveId != g.HoveredId)
        g.HoveredIdNotActiveTimer += g.IO.DeltaTime;
    g.HoveredIdPreviousFrame = g.HoveredId;
    g.HoveredId = 0;
    g.HoveredIdAllowOverlap = false;
    if (g.ActiveIdIsAlive != g.ActiveId && g.ActiveIdPreviousFrame == g.ActiveId && g.ActiveId != 0)
        ClearActiveID();
    if (g.ActiveId)
        g.ActiveIdTimer += g.IO.DeltaTime;
    g.LastActiveIdTimer += g.IO.DeltaTime;
    g.ActiveIdPreviousFrame = g.ActiveId;
    g.ActiveIdPreviousFrameWindow = g.ActiveIdWindow;
    g.ActiveIdPreviousFrameHasBeenEdited = g.ActiveIdHasBeenEdited;
    g.ActiveIdIsAlive = 0;
    g.ActiveIdPreviousFrameIsAlive = false;
    g.ActiveIdIsJustActivated = false;
    if (g.TempInputTextId != 0 && g.ActiveId != g.TempInputTextId)
        g.TempInputTextId = 0;

    // Drag and drop
    g.DragDropAcceptIdPrev = g.DragDropAcceptIdCurr;
    g.DragDropAcceptIdCurr = 0;
    g.DragDropAcceptIdCurrRectSurface = FLT_MAX;
    g.DragDropWithinSourceOrTarget = false;

    // Update keyboard input state
    memcpy(g.IO.KeysDownDurationPrev, g.IO.KeysDownDuration, sizeof(g.IO.KeysDownDuration));
    for (int i = 0; i < IM_ARRAYSIZE(g.IO.KeysDown); i++)
        g.IO.KeysDownDuration[i] = g.IO.KeysDown[i] ? (g.IO.KeysDownDuration[i] < 0.0f ? 0.0f : g.IO.KeysDownDuration[i] + g.IO.DeltaTime) : -1.0f;

    // Update gamepad/keyboard directional navigation
    NavUpdate();

    // Update mouse input state
    UpdateMouseInputs();

    // Calculate frame-rate for the user, as a purely luxurious feature
    g.FramerateSecPerFrameAccum += g.IO.DeltaTime - g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx];
    g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx] = g.IO.DeltaTime;
    g.FramerateSecPerFrameIdx = (g.FramerateSecPerFrameIdx + 1) % IM_ARRAYSIZE(g.FramerateSecPerFrame);
    g.IO.Framerate = (g.FramerateSecPerFrameAccum > 0.0f) ? (1.0f / (g.FramerateSecPerFrameAccum / (float)IM_ARRAYSIZE(g.FramerateSecPerFrame))) : FLT_MAX;

    // Handle user moving window with mouse (at the beginning of the frame to avoid input lag or sheering)
    UpdateMouseMovingWindowNewFrame();
    UpdateHoveredWindowAndCaptureFlags();

    // Background darkening/whitening
    if (GetFrontMostPopupModal() != NULL || (g.NavWindowingTarget != NULL && g.NavWindowingHighlightAlpha > 0.0f))
        g.DimBgRatio = ImMin(g.DimBgRatio + g.IO.DeltaTime * 6.0f, 1.0f);
    else
        g.DimBgRatio = ImMax(g.DimBgRatio - g.IO.DeltaTime * 10.0f, 0.0f);

    g.MouseCursor = ImGuiMouseCursor_Arrow;
    g.WantCaptureMouseNextFrame = g.WantCaptureKeyboardNextFrame = g.WantTextInputNextFrame = -1;
    g.PlatformImePos = ImVec2(1.0f, 1.0f); // OS Input Method Editor showing on top-left of our window by default

    // Mouse wheel scrolling, scale
    UpdateMouseWheel();

    // Pressing TAB activate widget focus
    g.FocusTabPressed = (g.NavWindow && g.NavWindow->Active && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs) && !g.IO.KeyCtrl && IsKeyPressedMap(ImGuiKey_Tab));
    if (g.ActiveId == 0 && g.FocusTabPressed)
    {
        // Note that SetKeyboardFocusHere() sets the Next fields mid-frame. To be consistent we also
        // manipulate the Next fields even, even though they will be turned into Curr fields by the code below.
        g.FocusRequestNextWindow = g.NavWindow;
        g.FocusRequestNextCounterAll = INT_MAX;
        if (g.NavId != 0 && g.NavIdTabCounter != INT_MAX)
            g.FocusRequestNextCounterTab = g.NavIdTabCounter + 1 + (g.IO.KeyShift ? -1 : 1);
        else
            g.FocusRequestNextCounterTab = g.IO.KeyShift ? -1 : 0;
    }

    // Turn queued focus request into current one
    g.FocusRequestCurrWindow = NULL;
    g.FocusRequestCurrCounterAll = g.FocusRequestCurrCounterTab = INT_MAX;
    if (g.FocusRequestNextWindow != NULL)
    {
        ImGuiWindow* window = g.FocusRequestNextWindow;
        g.FocusRequestCurrWindow = window;
        if (g.FocusRequestNextCounterAll != INT_MAX && window->DC.FocusCounterAll != -1)
            g.FocusRequestCurrCounterAll = ImModPositive(g.FocusRequestNextCounterAll, window->DC.FocusCounterAll + 1);
        if (g.FocusRequestNextCounterTab != INT_MAX && window->DC.FocusCounterTab != -1)
            g.FocusRequestCurrCounterTab = ImModPositive(g.FocusRequestNextCounterTab, window->DC.FocusCounterTab + 1);
        g.FocusRequestNextWindow = NULL;
        g.FocusRequestNextCounterAll = g.FocusRequestNextCounterTab = INT_MAX;
    }

    g.NavIdTabCounter = INT_MAX;

    // Mark all windows as not visible
    IM_ASSERT(g.WindowsFocusOrder.Size == g.Windows.Size);
    for (int i = 0; i != g.Windows.Size; i++)
    {
        ImGuiWindow* window = g.Windows[i];
        window->WasActive = window->Active;
        window->BeginCount = 0;
        window->Active = false;
        window->WriteAccessed = false;
    }

    // Closing the focused window restore focus to the first active root window in descending z-order
    if (g.NavWindow && !g.NavWindow->WasActive)
        FocusTopMostWindowUnderOne(NULL, NULL);

    // No window should be open at the beginning of the frame.
    // But in order to allow the user to call NewFrame() multiple times without calling Render(), we are doing an explicit clear.
    g.CurrentWindowStack.resize(0);
    g.BeginPopupStack.resize(0);
    ClosePopupsOverWindow(g.NavWindow, false);

    // Create implicit/fallback window - which we will only render it if the user has added something to it.
    // We don't use "Debug" to avoid colliding with user trying to create a "Debug" window with custom flags.
    // This fallback is particularly important as it avoid ImGui:: calls from crashing.
    SetNextWindowSize(ImVec2(400,400), ImGuiCond_FirstUseEver);
    Begin("Debug##Default");
    g.FrameScopePushedImplicitWindow = true;

#ifdef IMGUI_ENABLE_TEST_ENGINE
    ImGuiTestEngineHook_PostNewFrame(&g);
#endif
}

void ImGui::Initialize(ImGuiContext* context)
{
    ImGuiContext& g = *context;
    IM_ASSERT(!g.Initialized && !g.SettingsLoaded);

    // Add .ini handle for ImGuiWindow type
    ImGuiSettingsHandler ini_handler;
    ini_handler.TypeName = "Window";
    ini_handler.TypeHash = ImHashStr("Window");
    ini_handler.ReadOpenFn = SettingsHandlerWindow_ReadOpen;
    ini_handler.ReadLineFn = SettingsHandlerWindow_ReadLine;
    ini_handler.WriteAllFn = SettingsHandlerWindow_WriteAll;
    g.SettingsHandlers.push_back(ini_handler);

    g.Initialized = true;
}

// This function is merely here to free heap allocations.
void ImGui::Shutdown(ImGuiContext* context)
{
    // The fonts atlas can be used prior to calling NewFrame(), so we clear it even if g.Initialized is FALSE (which would happen if we never called NewFrame)
    ImGuiContext& g = *context;
    if (g.IO.Fonts && g.FontAtlasOwnedByContext)
    {
        g.IO.Fonts->Locked = false;
        IM_DELETE(g.IO.Fonts);
    }
    g.IO.Fonts = NULL;

    // Cleanup of other data are conditional on actually having initialized ImGui.
    if (!g.Initialized)
        return;

    // Save settings (unless we haven't attempted to load them: CreateContext/DestroyContext without a call to NewFrame shouldn't save an empty file)
    if (g.SettingsLoaded && g.IO.IniFilename != NULL)
    {
        ImGuiContext* backup_context = GImGui;
        SetCurrentContext(context);
        SaveIniSettingsToDisk(g.IO.IniFilename);
        SetCurrentContext(backup_context);
    }

    // Clear everything else
    for (int i = 0; i < g.Windows.Size; i++)
        IM_DELETE(g.Windows[i]);
    g.Windows.clear();
    g.WindowsFocusOrder.clear();
    g.WindowsSortBuffer.clear();
    g.CurrentWindow = NULL;
    g.CurrentWindowStack.clear();
    g.WindowsById.Clear();
    g.NavWindow = NULL;
    g.HoveredWindow = g.HoveredRootWindow = NULL;
    g.ActiveIdWindow = g.ActiveIdPreviousFrameWindow = NULL;
    g.MovingWindow = NULL;
    g.ColorModifiers.clear();
    g.StyleModifiers.clear();
    g.FontStack.clear();
    g.OpenPopupStack.clear();
    g.BeginPopupStack.clear();
    g.DrawDataBuilder.ClearFreeMemory();
    g.BackgroundDrawList.ClearFreeMemory();
    g.ForegroundDrawList.ClearFreeMemory();
    g.PrivateClipboard.clear();
    g.InputTextState.ClearFreeMemory();

    for (int i = 0; i < g.SettingsWindows.Size; i++)
        IM_DELETE(g.SettingsWindows[i].Name);
    g.SettingsWindows.clear();
    g.SettingsHandlers.clear();

    if (g.LogFile && g.LogFile != stdout)
    {
        fclose(g.LogFile);
        g.LogFile = NULL;
    }
    g.LogBuffer.clear();

    g.Initialized = false;
}

// FIXME: Add a more explicit sort order in the window structure.
static int IMGUI_CDECL ChildWindowComparer(const void* lhs, const void* rhs)
{
    const ImGuiWindow* const a = *(const ImGuiWindow* const *)lhs;
    const ImGuiWindow* const b = *(const ImGuiWindow* const *)rhs;
    if (int d = (a->Flags & ImGuiWindowFlags_Popup) - (b->Flags & ImGuiWindowFlags_Popup))
        return d;
    if (int d = (a->Flags & ImGuiWindowFlags_Tooltip) - (b->Flags & ImGuiWindowFlags_Tooltip))
        return d;
    return (a->BeginOrderWithinParent - b->BeginOrderWithinParent);
}

static void AddWindowToSortBuffer(ImVector<ImGuiWindow*>* out_sorted_windows, ImGuiWindow* window)
{
    out_sorted_windows->push_back(window);
    if (window->Active)
    {
        int count = window->DC.ChildWindows.Size;
        if (count > 1)
            ImQsort(window->DC.ChildWindows.begin(), (size_t)count, sizeof(ImGuiWindow*), ChildWindowComparer);
        for (int i = 0; i < count; i++)
        {
            ImGuiWindow* child = window->DC.ChildWindows[i];
            if (child->Active)
                AddWindowToSortBuffer(out_sorted_windows, child);
        }
    }
}

static void AddDrawListToDrawData(ImVector<ImDrawList*>* out_list, ImDrawList* draw_list)
{
    if (draw_list->CmdBuffer.empty())
        return;

    // Remove trailing command if unused
    ImDrawCmd& last_cmd = draw_list->CmdBuffer.back();
    if (last_cmd.ElemCount == 0 && last_cmd.UserCallback == NULL)
    {
        draw_list->CmdBuffer.pop_back();
        if (draw_list->CmdBuffer.empty())
            return;
    }

    // Draw list sanity check. Detect mismatch between PrimReserve() calls and incrementing _VtxCurrentIdx, _VtxWritePtr etc. May trigger for you if you are using PrimXXX functions incorrectly.
    IM_ASSERT(draw_list->VtxBuffer.Size == 0 || draw_list->_VtxWritePtr == draw_list->VtxBuffer.Data + draw_list->VtxBuffer.Size);
    IM_ASSERT(draw_list->IdxBuffer.Size == 0 || draw_list->_IdxWritePtr == draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size);
    IM_ASSERT((int)draw_list->_VtxCurrentIdx == draw_list->VtxBuffer.Size);

    // Check that draw_list doesn't use more vertices than indexable (default ImDrawIdx = unsigned short = 2 bytes = 64K vertices per ImDrawList = per window)
    // If this assert triggers because you are drawing lots of stuff manually:
    // A) Make sure you are coarse clipping, because ImDrawList let all your vertices pass. You can use the Metrics window to inspect draw list contents.
    // B) If you need/want meshes with more than 64K vertices, uncomment the '#define ImDrawIdx unsigned int' line in imconfig.h to set the index size to 4 bytes.
    //    You'll need to handle the 4-bytes indices to your renderer. For example, the OpenGL example code detect index size at compile-time by doing:
    //      glDrawElements(GL_TRIANGLES, (GLsizei)pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer_offset);
    //    Your own engine or render API may use different parameters or function calls to specify index sizes. 2 and 4 bytes indices are generally supported by most API.
    // C) If for some reason you cannot use 4 bytes indices or don't want to, a workaround is to call BeginChild()/EndChild() before reaching the 64K limit to split your draw commands in multiple draw lists.
    if (sizeof(ImDrawIdx) == 2)
        IM_ASSERT(draw_list->_VtxCurrentIdx < (1 << 16) && "Too many vertices in ImDrawList using 16-bit indices. Read comment above");

    out_list->push_back(draw_list);
}

static void AddWindowToDrawData(ImVector<ImDrawList*>* out_render_list, ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    g.IO.MetricsRenderWindows++;
    AddDrawListToDrawData(out_render_list, window->DrawList);
    for (int i = 0; i < window->DC.ChildWindows.Size; i++)
    {
        ImGuiWindow* child = window->DC.ChildWindows[i];
        if (IsWindowActiveAndVisible(child)) // clipped children may have been marked not active
            AddWindowToDrawData(out_render_list, child);
    }
}

// Layer is locked for the root window, however child windows may use a different viewport (e.g. extruding menu)
static void AddRootWindowToDrawData(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    if (window->Flags & ImGuiWindowFlags_Tooltip)
        AddWindowToDrawData(&g.DrawDataBuilder.Layers[1], window);
    else
        AddWindowToDrawData(&g.DrawDataBuilder.Layers[0], window);
}

void ImDrawDataBuilder::FlattenIntoSingleLayer()
{
    int n = Layers[0].Size;
    int size = n;
    for (int i = 1; i < IM_ARRAYSIZE(Layers); i++)
        size += Layers[i].Size;
    Layers[0].resize(size);
    for (int layer_n = 1; layer_n < IM_ARRAYSIZE(Layers); layer_n++)
    {
        ImVector<ImDrawList*>& layer = Layers[layer_n];
        if (layer.empty())
            continue;
        memcpy(&Layers[0][n], &layer[0], layer.Size * sizeof(ImDrawList*));
        n += layer.Size;
        layer.resize(0);
    }
}

static void SetupDrawData(ImVector<ImDrawList*>* draw_lists, ImDrawData* draw_data)
{
    ImGuiIO& io = ImGui::GetIO();
    draw_data->Valid = true;
    draw_data->CmdLists = (draw_lists->Size > 0) ? draw_lists->Data : NULL;
    draw_data->CmdListsCount = draw_lists->Size;
    draw_data->TotalVtxCount = draw_data->TotalIdxCount = 0;
    draw_data->DisplayPos = ImVec2(0.0f, 0.0f);
    draw_data->DisplaySize = io.DisplaySize;
    draw_data->FramebufferScale = io.DisplayFramebufferScale;
    for (int n = 0; n < draw_lists->Size; n++)
    {
        draw_data->TotalVtxCount += draw_lists->Data[n]->VtxBuffer.Size;
        draw_data->TotalIdxCount += draw_lists->Data[n]->IdxBuffer.Size;
    }
}

// When using this function it is sane to ensure that float are perfectly rounded to integer values, to that e.g. (int)(max.x-min.x) in user's render produce correct result.
void ImGui::PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DrawList->PushClipRect(clip_rect_min, clip_rect_max, intersect_with_current_clip_rect);
    window->ClipRect = window->DrawList->_ClipRectStack.back();
}

void ImGui::PopClipRect()
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DrawList->PopClipRect();
    window->ClipRect = window->DrawList->_ClipRectStack.back();
}

// This is normally called by Render(). You may want to call it directly if you want to avoid calling Render() but the gain will be very minimal.
void ImGui::EndFrame()
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.Initialized);
    if (g.FrameCountEnded == g.FrameCount)          // Don't process EndFrame() multiple times.
        return;
    IM_ASSERT(g.FrameScopeActive && "Forgot to call ImGui::NewFrame()?");

    // Notify OS when our Input Method Editor cursor has moved (e.g. CJK inputs using Microsoft IME)
    if (g.IO.ImeSetInputScreenPosFn && (g.PlatformImeLastPos.x == FLT_MAX || ImLengthSqr(g.PlatformImeLastPos - g.PlatformImePos) > 0.0001f))
    {
        g.IO.ImeSetInputScreenPosFn((int)g.PlatformImePos.x, (int)g.PlatformImePos.y);
        g.PlatformImeLastPos = g.PlatformImePos;
    }

    // Report when there is a mismatch of Begin/BeginChild vs End/EndChild calls. Important: Remember that the Begin/BeginChild API requires you
    // to always call End/EndChild even if Begin/BeginChild returns false! (this is unfortunately inconsistent with most other Begin* API).
    if (g.CurrentWindowStack.Size != 1)
    {
        if (g.CurrentWindowStack.Size > 1)
        {
            IM_ASSERT(g.CurrentWindowStack.Size == 1 && "Mismatched Begin/BeginChild vs End/EndChild calls: did you forget to call End/EndChild?");
            while (g.CurrentWindowStack.Size > 1) // FIXME-ERRORHANDLING
                End();
        }
        else
        {
            IM_ASSERT(g.CurrentWindowStack.Size == 1 && "Mismatched Begin/BeginChild vs End/EndChild calls: did you call End/EndChild too much?");
        }
    }

    // Hide implicit/fallback "Debug" window if it hasn't been used
    g.FrameScopePushedImplicitWindow = false;
    if (g.CurrentWindow && !g.CurrentWindow->WriteAccessed)
        g.CurrentWindow->Active = false;
    End();

    // Show CTRL+TAB list window
    if (g.NavWindowingTarget)
        NavUpdateWindowingList();

    // Drag and Drop: Elapse payload (if delivered, or if source stops being submitted)
    if (g.DragDropActive)
    {
        bool is_delivered = g.DragDropPayload.Delivery;
        bool is_elapsed = (g.DragDropPayload.DataFrameCount + 1 < g.FrameCount) && ((g.DragDropSourceFlags & ImGuiDragDropFlags_SourceAutoExpirePayload) || !IsMouseDown(g.DragDropMouseButton));
        if (is_delivered || is_elapsed)
            ClearDragDrop();
    }

    // Drag and Drop: Fallback for source tooltip. This is not ideal but better than nothing.
    if (g.DragDropActive && g.DragDropSourceFrameCount < g.FrameCount)
    {
        g.DragDropWithinSourceOrTarget = true;
        SetTooltip("...");
        g.DragDropWithinSourceOrTarget = false;
    }

    // End frame
    g.FrameScopeActive = false;
    g.FrameCountEnded = g.FrameCount;

    // Initiate moving window + handle left-click and right-click focus
    UpdateMouseMovingWindowEndFrame();

    // Sort the window list so that all child windows are after their parent
    // We cannot do that on FocusWindow() because childs may not exist yet
    g.WindowsSortBuffer.resize(0);
    g.WindowsSortBuffer.reserve(g.Windows.Size);
    for (int i = 0; i != g.Windows.Size; i++)
    {
        ImGuiWindow* window = g.Windows[i];
        if (window->Active && (window->Flags & ImGuiWindowFlags_ChildWindow))       // if a child is active its parent will add it
            continue;
        AddWindowToSortBuffer(&g.WindowsSortBuffer, window);
    }

    // This usually assert if there is a mismatch between the ImGuiWindowFlags_ChildWindow / ParentWindow values and DC.ChildWindows[] in parents, aka we've done something wrong.
    IM_ASSERT(g.Windows.Size == g.WindowsSortBuffer.Size);
    g.Windows.swap(g.WindowsSortBuffer);
    g.IO.MetricsActiveWindows = g.WindowsActiveCount;

    // Unlock font atlas
    g.IO.Fonts->Locked = false;

    // Clear Input data for next frame
    g.IO.MouseWheel = g.IO.MouseWheelH = 0.0f;
    g.IO.InputQueueCharacters.resize(0);
    memset(g.IO.NavInputs, 0, sizeof(g.IO.NavInputs));
}

void ImGui::Render()
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.Initialized);

    if (g.FrameCountEnded != g.FrameCount)
        EndFrame();
    g.FrameCountRendered = g.FrameCount;

    // Gather ImDrawList to render (for each active window)
    g.IO.MetricsRenderVertices = g.IO.MetricsRenderIndices = g.IO.MetricsRenderWindows = 0;
    g.DrawDataBuilder.Clear();
    if (!g.BackgroundDrawList.VtxBuffer.empty())
        AddDrawListToDrawData(&g.DrawDataBuilder.Layers[0], &g.BackgroundDrawList);

    ImGuiWindow* windows_to_render_front_most[2];
    windows_to_render_front_most[0] = (g.NavWindowingTarget && !(g.NavWindowingTarget->Flags & ImGuiWindowFlags_NoBringToFrontOnFocus)) ? g.NavWindowingTarget->RootWindow : NULL;
    windows_to_render_front_most[1] = g.NavWindowingTarget ? g.NavWindowingList : NULL;
    for (int n = 0; n != g.Windows.Size; n++)
    {
        ImGuiWindow* window = g.Windows[n];
        if (IsWindowActiveAndVisible(window) && (window->Flags & ImGuiWindowFlags_ChildWindow) == 0 && window != windows_to_render_front_most[0] && window != windows_to_render_front_most[1])
            AddRootWindowToDrawData(window);
    }
    for (int n = 0; n < IM_ARRAYSIZE(windows_to_render_front_most); n++)
        if (windows_to_render_front_most[n] && IsWindowActiveAndVisible(windows_to_render_front_most[n])) // NavWindowingTarget is always temporarily displayed as the front-most window
            AddRootWindowToDrawData(windows_to_render_front_most[n]);
    g.DrawDataBuilder.FlattenIntoSingleLayer();

    // Draw software mouse cursor if requested
    if (g.IO.MouseDrawCursor)
        RenderMouseCursor(&g.ForegroundDrawList, g.IO.MousePos, g.Style.MouseCursorScale, g.MouseCursor);

    if (!g.ForegroundDrawList.VtxBuffer.empty())
        AddDrawListToDrawData(&g.DrawDataBuilder.Layers[0], &g.ForegroundDrawList);

    // Setup ImDrawData structure for end-user
    SetupDrawData(&g.DrawDataBuilder.Layers[0], &g.DrawData);
    g.IO.MetricsRenderVertices = g.DrawData.TotalVtxCount;
    g.IO.MetricsRenderIndices = g.DrawData.TotalIdxCount;

    // (Legacy) Call the Render callback function. The current prefer way is to let the user retrieve GetDrawData() and call the render function themselves.
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    if (g.DrawData.CmdListsCount > 0 && g.IO.RenderDrawListsFn != NULL)
        g.IO.RenderDrawListsFn(&g.DrawData);
#endif
}

// Calculate text size. Text can be multi-line. Optionally ignore text after a ## marker.
// CalcTextSize("") should return ImVec2(0.0f, GImGui->FontSize)
ImVec2 ImGui::CalcTextSize(const char* text, const char* text_end, bool hide_text_after_double_hash, float wrap_width)
{
    ImGuiContext& g = *GImGui;

    const char* text_display_end;
    if (hide_text_after_double_hash)
        text_display_end = FindRenderedTextEnd(text, text_end);      // Hide anything after a '##' string
    else
        text_display_end = text_end;

    ImFont* font = g.Font;
    const float font_size = g.FontSize;
    if (text == text_display_end)
        return ImVec2(0.0f, font_size);
    ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

    // Round
    text_size.x = (float)(int)(text_size.x + 0.95f);

    return text_size;
}

// Helper to calculate coarse clipping of large list of evenly sized items.
// NB: Prefer using the ImGuiListClipper higher-level helper if you can! Read comments and instructions there on how those use this sort of pattern.
// NB: 'items_count' is only used to clamp the result, if you don't know your count you can use INT_MAX
void ImGui::CalcListClipping(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (g.LogEnabled)
    {
        // If logging is active, do not perform any clipping
        *out_items_display_start = 0;
        *out_items_display_end = items_count;
        return;
    }
    if (window->SkipItems)
    {
        *out_items_display_start = *out_items_display_end = 0;
        return;
    }

    // We create the union of the ClipRect and the NavScoringRect which at worst should be 1 page away from ClipRect
    ImRect unclipped_rect = window->ClipRect;
    if (g.NavMoveRequest)
        unclipped_rect.Add(g.NavScoringRectScreen);

    const ImVec2 pos = window->DC.CursorPos;
    int start = (int)((unclipped_rect.Min.y - pos.y) / items_height);
    int end = (int)((unclipped_rect.Max.y - pos.y) / items_height);

    // When performing a navigation request, ensure we have one item extra in the direction we are moving to
    if (g.NavMoveRequest && g.NavMoveClipDir == ImGuiDir_Up)
        start--;
    if (g.NavMoveRequest && g.NavMoveClipDir == ImGuiDir_Down)
        end++;

    start = ImClamp(start, 0, items_count);
    end = ImClamp(end + 1, start, items_count);
    *out_items_display_start = start;
    *out_items_display_end = end;
}

// Find window given position, search front-to-back
// FIXME: Note that we have an inconsequential lag here: OuterRectClipped is updated in Begin(), so windows moved programatically
// with SetWindowPos() and not SetNextWindowPos() will have that rectangle lagging by a frame at the time FindHoveredWindow() is
// called, aka before the next Begin(). Moving window isn't affected.
static void FindHoveredWindow()
{
    ImGuiContext& g = *GImGui;

    ImGuiWindow* hovered_window = NULL;
    if (g.MovingWindow && !(g.MovingWindow->Flags & ImGuiWindowFlags_NoMouseInputs))
        hovered_window = g.MovingWindow;

    ImVec2 padding_regular = g.Style.TouchExtraPadding;
    ImVec2 padding_for_resize_from_edges = g.IO.ConfigWindowsResizeFromEdges ? ImMax(g.Style.TouchExtraPadding, ImVec2(WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS, WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS)) : padding_regular;
    for (int i = g.Windows.Size - 1; i >= 0; i--)
    {
        ImGuiWindow* window = g.Windows[i];
        if (!window->Active || window->Hidden)
            continue;
        if (window->Flags & ImGuiWindowFlags_NoMouseInputs)
            continue;

        // Using the clipped AABB, a child window will typically be clipped by its parent (not always)
        ImRect bb(window->OuterRectClipped);
        if (window->Flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_AlwaysAutoResize))
            bb.Expand(padding_regular);
        else
            bb.Expand(padding_for_resize_from_edges);
        if (!bb.Contains(g.IO.MousePos))
            continue;

        // Those seemingly unnecessary extra tests are because the code here is a little different in viewport/docking branches.
        if (hovered_window == NULL)
            hovered_window = window;
        if (hovered_window)
            break;
    }

    g.HoveredWindow = hovered_window;
    g.HoveredRootWindow = g.HoveredWindow ? g.HoveredWindow->RootWindow : NULL;

}

// Test if mouse cursor is hovering given rectangle
// NB- Rectangle is clipped by our current clip setting
// NB- Expand the rectangle to be generous on imprecise inputs systems (g.Style.TouchExtraPadding)
bool ImGui::IsMouseHoveringRect(const ImVec2& r_min, const ImVec2& r_max, bool clip)
{
    ImGuiContext& g = *GImGui;

    // Clip
    ImRect rect_clipped(r_min, r_max);
    if (clip)
        rect_clipped.ClipWith(g.CurrentWindow->ClipRect);

    // Expand for touch input
    const ImRect rect_for_touch(rect_clipped.Min - g.Style.TouchExtraPadding, rect_clipped.Max + g.Style.TouchExtraPadding);
    if (!rect_for_touch.Contains(g.IO.MousePos))
        return false;
    return true;
}

int ImGui::GetKeyIndex(ImGuiKey imgui_key)
{
    IM_ASSERT(imgui_key >= 0 && imgui_key < ImGuiKey_COUNT);
    return GImGui->IO.KeyMap[imgui_key];
}

// Note that imgui doesn't know the semantic of each entry of io.KeysDown[]. Use your own indices/enums according to how your back-end/engine stored them into io.KeysDown[]!
bool ImGui::IsKeyDown(int user_key_index)
{
    if (user_key_index < 0) return false;
    IM_ASSERT(user_key_index >= 0 && user_key_index < IM_ARRAYSIZE(GImGui->IO.KeysDown));
    return GImGui->IO.KeysDown[user_key_index];
}

int ImGui::CalcTypematicPressedRepeatAmount(float t, float t_prev, float repeat_delay, float repeat_rate)
{
    if (t == 0.0f)
        return 1;
    if (t <= repeat_delay || repeat_rate <= 0.0f)
        return 0;
    const int count = (int)((t - repeat_delay) / repeat_rate) - (int)((t_prev - repeat_delay) / repeat_rate);
    return (count > 0) ? count : 0;
}

int ImGui::GetKeyPressedAmount(int key_index, float repeat_delay, float repeat_rate)
{
    ImGuiContext& g = *GImGui;
    if (key_index < 0)
        return 0;
    IM_ASSERT(key_index >= 0 && key_index < IM_ARRAYSIZE(g.IO.KeysDown));
    const float t = g.IO.KeysDownDuration[key_index];
    return CalcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime, repeat_delay, repeat_rate);
}

bool ImGui::IsKeyPressed(int user_key_index, bool repeat)
{
    ImGuiContext& g = *GImGui;
    if (user_key_index < 0)
        return false;
    IM_ASSERT(user_key_index >= 0 && user_key_index < IM_ARRAYSIZE(g.IO.KeysDown));
    const float t = g.IO.KeysDownDuration[user_key_index];
    if (t == 0.0f)
        return true;
    if (repeat && t > g.IO.KeyRepeatDelay)
        return GetKeyPressedAmount(user_key_index, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate) > 0;
    return false;
}

bool ImGui::IsKeyReleased(int user_key_index)
{
    ImGuiContext& g = *GImGui;
    if (user_key_index < 0) return false;
    IM_ASSERT(user_key_index >= 0 && user_key_index < IM_ARRAYSIZE(g.IO.KeysDown));
    return g.IO.KeysDownDurationPrev[user_key_index] >= 0.0f && !g.IO.KeysDown[user_key_index];
}

bool ImGui::IsMouseDown(int button)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    return g.IO.MouseDown[button];
}

bool ImGui::IsAnyMouseDown()
{
    ImGuiContext& g = *GImGui;
    for (int n = 0; n < IM_ARRAYSIZE(g.IO.MouseDown); n++)
        if (g.IO.MouseDown[n])
            return true;
    return false;
}

bool ImGui::IsMouseClicked(int button, bool repeat)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    const float t = g.IO.MouseDownDuration[button];
    if (t == 0.0f)
        return true;

    if (repeat && t > g.IO.KeyRepeatDelay)
    {
        // FIXME: 2019/05/03: Our old repeat code was wrong here and led to doubling the repeat rate, which made it an ok rate for repeat on mouse hold.
        int amount = CalcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate * 0.5f);
        if (amount > 0)
            return true;
    }

    return false;
}

bool ImGui::IsMouseReleased(int button)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    return g.IO.MouseReleased[button];
}

bool ImGui::IsMouseDoubleClicked(int button)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    return g.IO.MouseDoubleClicked[button];
}

bool ImGui::IsMouseDragging(int button, float lock_threshold)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    if (!g.IO.MouseDown[button])
        return false;
    if (lock_threshold < 0.0f)
        lock_threshold = g.IO.MouseDragThreshold;
    return g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold;
}

ImVec2 ImGui::GetMousePos()
{
    return GImGui->IO.MousePos;
}

// NB: prefer to call right after BeginPopup(). At the time Selectable/MenuItem is activated, the popup is already closed!
ImVec2 ImGui::GetMousePosOnOpeningCurrentPopup()
{
    ImGuiContext& g = *GImGui;
    if (g.BeginPopupStack.Size > 0)
        return g.OpenPopupStack[g.BeginPopupStack.Size-1].OpenMousePos;
    return g.IO.MousePos;
}

// We typically use ImVec2(-FLT_MAX,-FLT_MAX) to denote an invalid mouse position.
bool ImGui::IsMousePosValid(const ImVec2* mouse_pos)
{
    // The assert is only to silence a false-positive in XCode Static Analysis.
    // Because GImGui is not dereferenced in every code path, the static analyzer assume that it may be NULL (which it doesn't for other functions).
    IM_ASSERT(GImGui != NULL);
    const float MOUSE_INVALID = -256000.0f;
    ImVec2 p = mouse_pos ? *mouse_pos : GImGui->IO.MousePos;
    return p.x >= MOUSE_INVALID && p.y >= MOUSE_INVALID;
}

// Return the delta from the initial clicking position while the mouse button is clicked or was just released.
// This is locked and return 0.0f until the mouse moves past a distance threshold at least once.
// NB: This is only valid if IsMousePosValid(). Back-ends in theory should always keep mouse position valid when dragging even outside the client window.
ImVec2 ImGui::GetMouseDragDelta(int button, float lock_threshold)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    if (lock_threshold < 0.0f)
        lock_threshold = g.IO.MouseDragThreshold;
    if (g.IO.MouseDown[button] || g.IO.MouseReleased[button])
        if (g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold)
            if (IsMousePosValid(&g.IO.MousePos) && IsMousePosValid(&g.IO.MouseClickedPos[button]))
                return g.IO.MousePos - g.IO.MouseClickedPos[button];
    return ImVec2(0.0f, 0.0f);
}

void ImGui::ResetMouseDragDelta(int button)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    // NB: We don't need to reset g.IO.MouseDragMaxDistanceSqr
    g.IO.MouseClickedPos[button] = g.IO.MousePos;
}

ImGuiMouseCursor ImGui::GetMouseCursor()
{
    return GImGui->MouseCursor;
}

void ImGui::SetMouseCursor(ImGuiMouseCursor cursor_type)
{
    GImGui->MouseCursor = cursor_type;
}

void ImGui::CaptureKeyboardFromApp(bool capture)
{
    GImGui->WantCaptureKeyboardNextFrame = capture ? 1 : 0;
}

void ImGui::CaptureMouseFromApp(bool capture)
{
    GImGui->WantCaptureMouseNextFrame = capture ? 1 : 0;
}

bool ImGui::IsItemActive()
{
    ImGuiContext& g = *GImGui;
    if (g.ActiveId)
    {
        ImGuiWindow* window = g.CurrentWindow;
        return g.ActiveId == window->DC.LastItemId;
    }
    return false;
}

bool ImGui::IsItemActivated()
{
    ImGuiContext& g = *GImGui;
    if (g.ActiveId)
    {
        ImGuiWindow* window = g.CurrentWindow;
        if (g.ActiveId == window->DC.LastItemId && g.ActiveIdPreviousFrame != window->DC.LastItemId)
            return true;
    }
    return false;
}

bool ImGui::IsItemDeactivated()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    return (g.ActiveIdPreviousFrame == window->DC.LastItemId && g.ActiveIdPreviousFrame != 0 && g.ActiveId != window->DC.LastItemId);
}

bool ImGui::IsItemDeactivatedAfterEdit()
{
    ImGuiContext& g = *GImGui;
    return IsItemDeactivated() && (g.ActiveIdPreviousFrameHasBeenEdited || (g.ActiveId == 0 && g.ActiveIdHasBeenEdited));
}

bool ImGui::IsItemFocused()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    if (g.NavId == 0 || g.NavDisableHighlight || g.NavId != window->DC.LastItemId)
        return false;
    return true;
}

bool ImGui::IsItemClicked(int mouse_button)
{
    return IsMouseClicked(mouse_button) && IsItemHovered(ImGuiHoveredFlags_None);
}

bool ImGui::IsItemToggledSelection()
{
    ImGuiContext& g = *GImGui;
    return (g.CurrentWindow->DC.LastItemStatusFlags & ImGuiItemStatusFlags_ToggledSelection) ? true : false;
}

bool ImGui::IsAnyItemHovered()
{
    ImGuiContext& g = *GImGui;
    return g.HoveredId != 0 || g.HoveredIdPreviousFrame != 0;
}

bool ImGui::IsAnyItemActive()
{
    ImGuiContext& g = *GImGui;
    return g.ActiveId != 0;
}

bool ImGui::IsAnyItemFocused()
{
    ImGuiContext& g = *GImGui;
    return g.NavId != 0 && !g.NavDisableHighlight;
}

bool ImGui::IsItemVisible()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->ClipRect.Overlaps(window->DC.LastItemRect);
}

bool ImGui::IsItemEdited()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return (window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_Edited) != 0;
}

// Allow last item to be overlapped by a subsequent item. Both may be activated during the same frame before the later one takes priority.
void ImGui::SetItemAllowOverlap()
{
    ImGuiContext& g = *GImGui;
    if (g.HoveredId == g.CurrentWindow->DC.LastItemId)
        g.HoveredIdAllowOverlap = true;
    if (g.ActiveId == g.CurrentWindow->DC.LastItemId)
        g.ActiveIdAllowOverlap = true;
}

ImVec2 ImGui::GetItemRectMin()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.LastItemRect.Min;
}

ImVec2 ImGui::GetItemRectMax()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.LastItemRect.Max;
}

ImVec2 ImGui::GetItemRectSize()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.LastItemRect.GetSize();
}

static ImRect GetViewportRect()
{
    ImGuiContext& g = *GImGui;
    return ImRect(0.0f, 0.0f, g.IO.DisplaySize.x, g.IO.DisplaySize.y);
}

static bool ImGui::BeginChildEx(const char* name, ImGuiID id, const ImVec2& size_arg, bool border, ImGuiWindowFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* parent_window = g.CurrentWindow;

    flags |= ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoResize|ImGuiWindowFlags_NoSavedSettings|ImGuiWindowFlags_ChildWindow;
    flags |= (parent_window->Flags & ImGuiWindowFlags_NoMove);  // Inherit the NoMove flag

    // Size
    const ImVec2 content_avail = GetContentRegionAvail();
    ImVec2 size = ImFloor(size_arg);
    const int auto_fit_axises = ((size.x == 0.0f) ? (1 << ImGuiAxis_X) : 0x00) | ((size.y == 0.0f) ? (1 << ImGuiAxis_Y) : 0x00);
    if (size.x <= 0.0f)
        size.x = ImMax(content_avail.x + size.x, 4.0f); // Arbitrary minimum child size (0.0f causing too much issues)
    if (size.y <= 0.0f)
        size.y = ImMax(content_avail.y + size.y, 4.0f);
    SetNextWindowSize(size);

    // Build up name. If you need to append to a same child from multiple location in the ID stack, use BeginChild(ImGuiID id) with a stable value.
    char title[256];
    if (name)
        ImFormatString(title, IM_ARRAYSIZE(title), "%s/%s_%08X", parent_window->Name, name, id);
    else
        ImFormatString(title, IM_ARRAYSIZE(title), "%s/%08X", parent_window->Name, id);

    const float backup_border_size = g.Style.ChildBorderSize;
    if (!border)
        g.Style.ChildBorderSize = 0.0f;
    bool ret = Begin(title, NULL, flags);
    g.Style.ChildBorderSize = backup_border_size;

    ImGuiWindow* child_window = g.CurrentWindow;
    child_window->ChildId = id;
    child_window->AutoFitChildAxises = auto_fit_axises;

    // Set the cursor to handle case where the user called SetNextWindowPos()+BeginChild() manually.
    // While this is not really documented/defined, it seems that the expected thing to do.
    if (child_window->BeginCount == 1)
        parent_window->DC.CursorPos = child_window->Pos;

    // Process navigation-in immediately so NavInit can run on first frame
    if (g.NavActivateId == id && !(flags & ImGuiWindowFlags_NavFlattened) && (child_window->DC.NavLayerActiveMask != 0 || child_window->DC.NavHasScroll))
    {
        FocusWindow(child_window);
        NavInitWindow(child_window, false);
        SetActiveID(id+1, child_window); // Steal ActiveId with a dummy id so that key-press won't activate child item
        g.ActiveIdSource = ImGuiInputSource_Nav;
    }
    return ret;
}

bool ImGui::BeginChild(const char* str_id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags)
{
    ImGuiWindow* window = GetCurrentWindow();
    return BeginChildEx(str_id, window->GetID(str_id), size_arg, border, extra_flags);
}

bool ImGui::BeginChild(ImGuiID id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags)
{
    IM_ASSERT(id != 0);
    return BeginChildEx(NULL, id, size_arg, border, extra_flags);
}

void ImGui::EndChild()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    IM_ASSERT(window->Flags & ImGuiWindowFlags_ChildWindow);   // Mismatched BeginChild()/EndChild() callss
    if (window->BeginCount > 1)
    {
        End();
    }
    else
    {
        ImVec2 sz = window->Size;
        if (window->AutoFitChildAxises & (1 << ImGuiAxis_X)) // Arbitrary minimum zero-ish child size of 4.0f causes less trouble than a 0.0f
            sz.x = ImMax(4.0f, sz.x);
        if (window->AutoFitChildAxises & (1 << ImGuiAxis_Y))
            sz.y = ImMax(4.0f, sz.y);
        End();

        ImGuiWindow* parent_window = g.CurrentWindow;
        ImRect bb(parent_window->DC.CursorPos, parent_window->DC.CursorPos + sz);
        ItemSize(sz);
        if ((window->DC.NavLayerActiveMask != 0 || window->DC.NavHasScroll) && !(window->Flags & ImGuiWindowFlags_NavFlattened))
        {
            ItemAdd(bb, window->ChildId);
            RenderNavHighlight(bb, window->ChildId);

            // When browsing a window that has no activable items (scroll only) we keep a highlight on the child
            if (window->DC.NavLayerActiveMask == 0 && window == g.NavWindow)
                RenderNavHighlight(ImRect(bb.Min - ImVec2(2,2), bb.Max + ImVec2(2,2)), g.NavId, ImGuiNavHighlightFlags_TypeThin);
        }
        else
        {
            // Not navigable into
            ItemAdd(bb, 0);
        }
    }
}

// Helper to create a child window / scrolling region that looks like a normal widget frame.
bool ImGui::BeginChildFrame(ImGuiID id, const ImVec2& size, ImGuiWindowFlags extra_flags)
{
    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    PushStyleColor(ImGuiCol_ChildBg, style.Colors[ImGuiCol_FrameBg]);
    PushStyleVar(ImGuiStyleVar_ChildRounding, style.FrameRounding);
    PushStyleVar(ImGuiStyleVar_ChildBorderSize, style.FrameBorderSize);
    PushStyleVar(ImGuiStyleVar_WindowPadding, style.FramePadding);
    bool ret = BeginChild(id, size, true, ImGuiWindowFlags_NoMove | ImGuiWindowFlags_AlwaysUseWindowPadding | extra_flags);
    PopStyleVar(3);
    PopStyleColor();
    return ret;
}

void ImGui::EndChildFrame()
{
    EndChild();
}

// Save and compare stack sizes on Begin()/End() to detect usage errors
static void CheckStacksSize(ImGuiWindow* window, bool write)
{
    // NOT checking: DC.ItemWidth, DC.AllowKeyboardFocus, DC.ButtonRepeat, DC.TextWrapPos (per window) to allow user to conveniently push once and not pop (they are cleared on Begin)
    ImGuiContext& g = *GImGui;
    short* p_backup = &window->DC.StackSizesBackup[0];
    { int current = window->IDStack.Size;       if (write) *p_backup = (short)current; else IM_ASSERT(*p_backup == current && "PushID/PopID or TreeNode/TreePop Mismatch!");   p_backup++; }    // Too few or too many PopID()/TreePop()
    { int current = window->DC.GroupStack.Size; if (write) *p_backup = (short)current; else IM_ASSERT(*p_backup == current && "BeginGroup/EndGroup Mismatch!");                p_backup++; }    // Too few or too many EndGroup()
    { int current = g.BeginPopupStack.Size;     if (write) *p_backup = (short)current; else IM_ASSERT(*p_backup == current && "BeginMenu/EndMenu or BeginPopup/EndPopup Mismatch"); p_backup++;}// Too few or too many EndMenu()/EndPopup()
    // For color, style and font stacks there is an incentive to use Push/Begin/Pop/.../End patterns, so we relax our checks a little to allow them.
    { int current = g.ColorModifiers.Size;      if (write) *p_backup = (short)current; else IM_ASSERT(*p_backup >= current && "PushStyleColor/PopStyleColor Mismatch!");       p_backup++; }    // Too few or too many PopStyleColor()
    { int current = g.StyleModifiers.Size;      if (write) *p_backup = (short)current; else IM_ASSERT(*p_backup >= current && "PushStyleVar/PopStyleVar Mismatch!");           p_backup++; }    // Too few or too many PopStyleVar()
    { int current = g.FontStack.Size;           if (write) *p_backup = (short)current; else IM_ASSERT(*p_backup >= current && "PushFont/PopFont Mismatch!");                   p_backup++; }    // Too few or too many PopFont()
    IM_ASSERT(p_backup == window->DC.StackSizesBackup + IM_ARRAYSIZE(window->DC.StackSizesBackup));
}

static void SetWindowConditionAllowFlags(ImGuiWindow* window, ImGuiCond flags, bool enabled)
{
    window->SetWindowPosAllowFlags       = enabled ? (window->SetWindowPosAllowFlags       | flags) : (window->SetWindowPosAllowFlags       & ~flags);
    window->SetWindowSizeAllowFlags      = enabled ? (window->SetWindowSizeAllowFlags      | flags) : (window->SetWindowSizeAllowFlags      & ~flags);
    window->SetWindowCollapsedAllowFlags = enabled ? (window->SetWindowCollapsedAllowFlags | flags) : (window->SetWindowCollapsedAllowFlags & ~flags);
}

ImGuiWindow* ImGui::FindWindowByID(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    return (ImGuiWindow*)g.WindowsById.GetVoidPtr(id);
}

ImGuiWindow* ImGui::FindWindowByName(const char* name)
{
    ImGuiID id = ImHashStr(name);
    return FindWindowByID(id);
}

static ImGuiWindow* CreateNewWindow(const char* name, ImVec2 size, ImGuiWindowFlags flags)
{
    ImGuiContext& g = *GImGui;

    // Create window the first time
    ImGuiWindow* window = IM_NEW(ImGuiWindow)(&g, name);
    window->Flags = flags;
    g.WindowsById.SetVoidPtr(window->ID, window);

    // Default/arbitrary window position. Use SetNextWindowPos() with the appropriate condition flag to change the initial position of a window.
    window->Pos = ImVec2(60, 60);

    // User can disable loading and saving of settings. Tooltip and child windows also don't store settings.
    if (!(flags & ImGuiWindowFlags_NoSavedSettings))
        if (ImGuiWindowSettings* settings = ImGui::FindWindowSettings(window->ID))
        {
            // Retrieve settings from .ini file
            window->SettingsIdx = g.SettingsWindows.index_from_ptr(settings);
            SetWindowConditionAllowFlags(window, ImGuiCond_FirstUseEver, false);
            window->Pos = ImFloor(settings->Pos);
            window->Collapsed = settings->Collapsed;
            if (ImLengthSqr(settings->Size) > 0.00001f)
                size = ImFloor(settings->Size);
        }
    window->Size = window->SizeFull = window->SizeFullAtLastBegin = ImFloor(size);
    window->DC.CursorMaxPos = window->Pos; // So first call to CalcSizeContents() doesn't return crazy values

    if ((flags & ImGuiWindowFlags_AlwaysAutoResize) != 0)
    {
        window->AutoFitFramesX = window->AutoFitFramesY = 2;
        window->AutoFitOnlyGrows = false;
    }
    else
    {
        if (window->Size.x <= 0.0f)
            window->AutoFitFramesX = 2;
        if (window->Size.y <= 0.0f)
            window->AutoFitFramesY = 2;
        window->AutoFitOnlyGrows = (window->AutoFitFramesX > 0) || (window->AutoFitFramesY > 0);
    }

    g.WindowsFocusOrder.push_back(window);
    if (flags & ImGuiWindowFlags_NoBringToFrontOnFocus)
        g.Windows.push_front(window); // Quite slow but rare and only once
    else
        g.Windows.push_back(window);
    return window;
}

static ImVec2 CalcSizeAfterConstraint(ImGuiWindow* window, ImVec2 new_size)
{
    ImGuiContext& g = *GImGui;
    if (g.NextWindowData.SizeConstraintCond != 0)
    {
        // Using -1,-1 on either X/Y axis to preserve the current size.
        ImRect cr = g.NextWindowData.SizeConstraintRect;
        new_size.x = (cr.Min.x >= 0 && cr.Max.x >= 0) ? ImClamp(new_size.x, cr.Min.x, cr.Max.x) : window->SizeFull.x;
        new_size.y = (cr.Min.y >= 0 && cr.Max.y >= 0) ? ImClamp(new_size.y, cr.Min.y, cr.Max.y) : window->SizeFull.y;
        if (g.NextWindowData.SizeCallback)
        {
            ImGuiSizeCallbackData data;
            data.UserData = g.NextWindowData.SizeCallbackUserData;
            data.Pos = window->Pos;
            data.CurrentSize = window->SizeFull;
            data.DesiredSize = new_size;
            g.NextWindowData.SizeCallback(&data);
            new_size = data.DesiredSize;
        }
        new_size.x = ImFloor(new_size.x);
        new_size.y = ImFloor(new_size.y);
    }

    // Minimum size
    if (!(window->Flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_AlwaysAutoResize)))
    {
        new_size = ImMax(new_size, g.Style.WindowMinSize);
        new_size.y = ImMax(new_size.y, window->TitleBarHeight() + window->MenuBarHeight() + ImMax(0.0f, g.Style.WindowRounding - 1.0f)); // Reduce artifacts with very small windows
    }
    return new_size;
}

static ImVec2 CalcSizeContents(ImGuiWindow* window)
{
    if (window->Collapsed)
        if (window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)
            return window->SizeContents;
    if (window->Hidden && window->HiddenFramesCannotSkipItems == 0 && window->HiddenFramesCanSkipItems > 0)
        return window->SizeContents;

    ImVec2 sz;
    sz.x = (float)(int)((window->SizeContentsExplicit.x != 0.0f) ? window->SizeContentsExplicit.x : (window->DC.CursorMaxPos.x - window->Pos.x + window->Scroll.x));
    sz.y = (float)(int)((window->SizeContentsExplicit.y != 0.0f) ? window->SizeContentsExplicit.y : (window->DC.CursorMaxPos.y - window->Pos.y + window->Scroll.y));
    return sz + window->WindowPadding;
}

static ImVec2 CalcSizeAutoFit(ImGuiWindow* window, const ImVec2& size_contents)
{
    ImGuiContext& g = *GImGui;
    ImGuiStyle& style = g.Style;
    if (window->Flags & ImGuiWindowFlags_Tooltip)
    {
        // Tooltip always resize
        return size_contents;
    }
    else
    {
        // Maximum window size is determined by the display size
        const bool is_popup = (window->Flags & ImGuiWindowFlags_Popup) != 0;
        const bool is_menu = (window->Flags & ImGuiWindowFlags_ChildMenu) != 0;
        ImVec2 size_min = style.WindowMinSize;
        if (is_popup || is_menu) // Popups and menus bypass style.WindowMinSize by default, but we give then a non-zero minimum size to facilitate understanding problematic cases (e.g. empty popups)
            size_min = ImMin(size_min, ImVec2(4.0f, 4.0f));
        ImVec2 size_auto_fit = ImClamp(size_contents, size_min, ImMax(size_min, g.IO.DisplaySize - style.DisplaySafeAreaPadding * 2.0f));

        // When the window cannot fit all contents (either because of constraints, either because screen is too small),
        // we are growing the size on the other axis to compensate for expected scrollbar. FIXME: Might turn bigger than ViewportSize-WindowPadding.
        ImVec2 size_auto_fit_after_constraint = CalcSizeAfterConstraint(window, size_auto_fit);
        if (size_auto_fit_after_constraint.x < size_contents.x && !(window->Flags & ImGuiWindowFlags_NoScrollbar) && (window->Flags & ImGuiWindowFlags_HorizontalScrollbar))
            size_auto_fit.y += style.ScrollbarSize;
        if (size_auto_fit_after_constraint.y < size_contents.y && !(window->Flags & ImGuiWindowFlags_NoScrollbar))
            size_auto_fit.x += style.ScrollbarSize;
        return size_auto_fit;
    }
}

ImVec2 ImGui::CalcWindowExpectedSize(ImGuiWindow* window)
{
    ImVec2 size_contents = CalcSizeContents(window);
    return CalcSizeAfterConstraint(window, CalcSizeAutoFit(window, size_contents));
}

float ImGui::GetWindowScrollMaxX(ImGuiWindow* window)
{
    return ImMax(0.0f, window->SizeContents.x - (window->SizeFull.x - window->ScrollbarSizes.x));
}

float ImGui::GetWindowScrollMaxY(ImGuiWindow* window)
{
    return ImMax(0.0f, window->SizeContents.y - (window->SizeFull.y - window->ScrollbarSizes.y));
}

static ImVec2 CalcNextScrollFromScrollTargetAndClamp(ImGuiWindow* window, bool snap_on_edges)
{
    ImGuiContext& g = *GImGui;
    ImVec2 scroll = window->Scroll;
    if (window->ScrollTarget.x < FLT_MAX)
    {
        float cr_x = window->ScrollTargetCenterRatio.x;
        scroll.x = window->ScrollTarget.x - cr_x * (window->SizeFull.x - window->ScrollbarSizes.x);
    }
    if (window->ScrollTarget.y < FLT_MAX)
    {
        // 'snap_on_edges' allows for a discontinuity at the edge of scrolling limits to take account of WindowPadding so that scrolling to make the last item visible scroll far enough to see the padding.
        float cr_y = window->ScrollTargetCenterRatio.y;
        float target_y = window->ScrollTarget.y;
        if (snap_on_edges && cr_y <= 0.0f && target_y <= window->WindowPadding.y)
            target_y = 0.0f;
        if (snap_on_edges && cr_y >= 1.0f && target_y >= window->SizeContents.y - window->WindowPadding.y + g.Style.ItemSpacing.y)
            target_y = window->SizeContents.y;
        scroll.y = target_y - (1.0f - cr_y) * (window->TitleBarHeight() + window->MenuBarHeight()) - cr_y * (window->SizeFull.y - window->ScrollbarSizes.y);
    }
    scroll = ImMax(scroll, ImVec2(0.0f, 0.0f));
    if (!window->Collapsed && !window->SkipItems)
    {
        scroll.x = ImMin(scroll.x, ImGui::GetWindowScrollMaxX(window));
        scroll.y = ImMin(scroll.y, ImGui::GetWindowScrollMaxY(window));
    }
    return scroll;
}

static ImGuiCol GetWindowBgColorIdxFromFlags(ImGuiWindowFlags flags)
{
    if (flags & (ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_Popup))
        return ImGuiCol_PopupBg;
    if (flags & ImGuiWindowFlags_ChildWindow)
        return ImGuiCol_ChildBg;
    return ImGuiCol_WindowBg;
}

static void CalcResizePosSizeFromAnyCorner(ImGuiWindow* window, const ImVec2& corner_target, const ImVec2& corner_norm, ImVec2* out_pos, ImVec2* out_size)
{
    ImVec2 pos_min = ImLerp(corner_target, window->Pos, corner_norm);                // Expected window upper-left
    ImVec2 pos_max = ImLerp(window->Pos + window->Size, corner_target, corner_norm); // Expected window lower-right
    ImVec2 size_expected = pos_max - pos_min;
    ImVec2 size_constrained = CalcSizeAfterConstraint(window, size_expected);
    *out_pos = pos_min;
    if (corner_norm.x == 0.0f)
        out_pos->x -= (size_constrained.x - size_expected.x);
    if (corner_norm.y == 0.0f)
        out_pos->y -= (size_constrained.y - size_expected.y);
    *out_size = size_constrained;
}

struct ImGuiResizeGripDef
{
    ImVec2  CornerPosN;
    ImVec2  InnerDir;
    int     AngleMin12, AngleMax12;
};

static const ImGuiResizeGripDef resize_grip_def[4] =
{
    { ImVec2(1,1), ImVec2(-1,-1), 0, 3 }, // Lower right
    { ImVec2(0,1), ImVec2(+1,-1), 3, 6 }, // Lower left
    { ImVec2(0,0), ImVec2(+1,+1), 6, 9 }, // Upper left
    { ImVec2(1,0), ImVec2(-1,+1), 9,12 }, // Upper right
};

static ImRect GetResizeBorderRect(ImGuiWindow* window, int border_n, float perp_padding, float thickness)
{
    ImRect rect = window->Rect();
    if (thickness == 0.0f) rect.Max -= ImVec2(1,1);
    if (border_n == 0) return ImRect(rect.Min.x + perp_padding, rect.Min.y - thickness,    rect.Max.x - perp_padding, rect.Min.y + thickness);      // Top
    if (border_n == 1) return ImRect(rect.Max.x - thickness,    rect.Min.y + perp_padding, rect.Max.x + thickness,    rect.Max.y - perp_padding);   // Right
    if (border_n == 2) return ImRect(rect.Min.x + perp_padding, rect.Max.y - thickness,    rect.Max.x - perp_padding, rect.Max.y + thickness);      // Bottom
    if (border_n == 3) return ImRect(rect.Min.x - thickness,    rect.Min.y + perp_padding, rect.Min.x + thickness,    rect.Max.y - perp_padding);   // Left
    IM_ASSERT(0);
    return ImRect();
}

// Handle resize for: Resize Grips, Borders, Gamepad
static void ImGui::UpdateManualResize(ImGuiWindow* window, const ImVec2& size_auto_fit, int* border_held, int resize_grip_count, ImU32 resize_grip_col[4])
{
    ImGuiContext& g = *GImGui;
    ImGuiWindowFlags flags = window->Flags;
    if ((flags & ImGuiWindowFlags_NoResize) || (flags & ImGuiWindowFlags_AlwaysAutoResize) || window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
        return;
    if (window->WasActive == false) // Early out to avoid running this code for e.g. an hidden implicit/fallback Debug window.
        return;

    const int resize_border_count = g.IO.ConfigWindowsResizeFromEdges ? 4 : 0;
    const float grip_draw_size = (float)(int)ImMax(g.FontSize * 1.35f, window->WindowRounding + 1.0f + g.FontSize * 0.2f);
    const float grip_hover_inner_size = (float)(int)(grip_draw_size * 0.75f);
    const float grip_hover_outer_size = g.IO.ConfigWindowsResizeFromEdges ? WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS : 0.0f;

    ImVec2 pos_target(FLT_MAX, FLT_MAX);
    ImVec2 size_target(FLT_MAX, FLT_MAX);

    // Resize grips and borders are on layer 1
    window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;
    window->DC.NavLayerCurrentMask = (1 << ImGuiNavLayer_Menu);

    // Manual resize grips
    PushID("#RESIZE");
    for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)
    {
        const ImGuiResizeGripDef& grip = resize_grip_def[resize_grip_n];
        const ImVec2 corner = ImLerp(window->Pos, window->Pos + window->Size, grip.CornerPosN);

        // Using the FlattenChilds button flag we make the resize button accessible even if we are hovering over a child window
        ImRect resize_rect(corner - grip.InnerDir * grip_hover_outer_size, corner + grip.InnerDir * grip_hover_inner_size);
        if (resize_rect.Min.x > resize_rect.Max.x) ImSwap(resize_rect.Min.x, resize_rect.Max.x);
        if (resize_rect.Min.y > resize_rect.Max.y) ImSwap(resize_rect.Min.y, resize_rect.Max.y);
        bool hovered, held;
        ButtonBehavior(resize_rect, window->GetID((void*)(intptr_t)resize_grip_n), &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_NoNavFocus);
        //GetForegroundDrawList(window)->AddRect(resize_rect.Min, resize_rect.Max, IM_COL32(255, 255, 0, 255));
        if (hovered || held)
            g.MouseCursor = (resize_grip_n & 1) ? ImGuiMouseCursor_ResizeNESW : ImGuiMouseCursor_ResizeNWSE;

        if (held && g.IO.MouseDoubleClicked[0] && resize_grip_n == 0)
        {
            // Manual auto-fit when double-clicking
            size_target = CalcSizeAfterConstraint(window, size_auto_fit);
            ClearActiveID();
        }
        else if (held)
        {
            // Resize from any of the four corners
            // We don't use an incremental MouseDelta but rather compute an absolute target size based on mouse position
            ImVec2 corner_target = g.IO.MousePos - g.ActiveIdClickOffset + ImLerp(grip.InnerDir * grip_hover_outer_size, grip.InnerDir * -grip_hover_inner_size, grip.CornerPosN); // Corner of the window corresponding to our corner grip
            CalcResizePosSizeFromAnyCorner(window, corner_target, grip.CornerPosN, &pos_target, &size_target);
        }
        if (resize_grip_n == 0 || held || hovered)
            resize_grip_col[resize_grip_n] = GetColorU32(held ? ImGuiCol_ResizeGripActive : hovered ? ImGuiCol_ResizeGripHovered : ImGuiCol_ResizeGrip);
    }
    for (int border_n = 0; border_n < resize_border_count; border_n++)
    {
        bool hovered, held;
        ImRect border_rect = GetResizeBorderRect(window, border_n, grip_hover_inner_size, WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS);
        ButtonBehavior(border_rect, window->GetID((void*)(intptr_t)(border_n + 4)), &hovered, &held, ImGuiButtonFlags_FlattenChildren);
        //GetForegroundDrawLists(window)->AddRect(border_rect.Min, border_rect.Max, IM_COL32(255, 255, 0, 255));
        if ((hovered && g.HoveredIdTimer > WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER) || held)
        {
            g.MouseCursor = (border_n & 1) ? ImGuiMouseCursor_ResizeEW : ImGuiMouseCursor_ResizeNS;
            if (held)
                *border_held = border_n;
        }
        if (held)
        {
            ImVec2 border_target = window->Pos;
            ImVec2 border_posn;
            if (border_n == 0) { border_posn = ImVec2(0, 0); border_target.y = (g.IO.MousePos.y - g.ActiveIdClickOffset.y + WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS); } // Top
            if (border_n == 1) { border_posn = ImVec2(1, 0); border_target.x = (g.IO.MousePos.x - g.ActiveIdClickOffset.x + WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS); } // Right
            if (border_n == 2) { border_posn = ImVec2(0, 1); border_target.y = (g.IO.MousePos.y - g.ActiveIdClickOffset.y + WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS); } // Bottom
            if (border_n == 3) { border_posn = ImVec2(0, 0); border_target.x = (g.IO.MousePos.x - g.ActiveIdClickOffset.x + WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS); } // Left
            CalcResizePosSizeFromAnyCorner(window, border_target, border_posn, &pos_target, &size_target);
        }
    }
    PopID();

    // Navigation resize (keyboard/gamepad)
    if (g.NavWindowingTarget && g.NavWindowingTarget->RootWindow == window)
    {
        ImVec2 nav_resize_delta;
        if (g.NavInputSource == ImGuiInputSource_NavKeyboard && g.IO.KeyShift)
            nav_resize_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard, ImGuiInputReadMode_Down);
        if (g.NavInputSource == ImGuiInputSource_NavGamepad)
            nav_resize_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_Down);
        if (nav_resize_delta.x != 0.0f || nav_resize_delta.y != 0.0f)
        {
            const float NAV_RESIZE_SPEED = 600.0f;
            nav_resize_delta *= ImFloor(NAV_RESIZE_SPEED * g.IO.DeltaTime * ImMin(g.IO.DisplayFramebufferScale.x, g.IO.DisplayFramebufferScale.y));
            g.NavWindowingToggleLayer = false;
            g.NavDisableMouseHover = true;
            resize_grip_col[0] = GetColorU32(ImGuiCol_ResizeGripActive);
            // FIXME-NAV: Should store and accumulate into a separate size buffer to handle sizing constraints properly, right now a constraint will make us stuck.
            size_target = CalcSizeAfterConstraint(window, window->SizeFull + nav_resize_delta);
        }
    }

    // Apply back modified position/size to window
    if (size_target.x != FLT_MAX)
    {
        window->SizeFull = size_target;
        MarkIniSettingsDirty(window);
    }
    if (pos_target.x != FLT_MAX)
    {
        window->Pos = ImFloor(pos_target);
        MarkIniSettingsDirty(window);
    }

    // Resize nav layer
    window->DC.NavLayerCurrent = ImGuiNavLayer_Main;
    window->DC.NavLayerCurrentMask = (1 << ImGuiNavLayer_Main);

    window->Size = window->SizeFull;
}

static inline void ClampWindowRect(ImGuiWindow* window, const ImRect& rect, const ImVec2& padding)
{
    ImGuiContext& g = *GImGui;
    ImVec2 size_for_clamping = (g.IO.ConfigWindowsMoveFromTitleBarOnly && !(window->Flags & ImGuiWindowFlags_NoTitleBar)) ? ImVec2(window->Size.x, window->TitleBarHeight()) : window->Size;
    window->Pos = ImMin(rect.Max - padding, ImMax(window->Pos + size_for_clamping, rect.Min + padding) - size_for_clamping);
}

static void ImGui::RenderOuterBorders(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    float rounding = window->WindowRounding;
    float border_size = window->WindowBorderSize;
    if (border_size > 0.0f && !(window->Flags & ImGuiWindowFlags_NoBackground))
        window->DrawList->AddRect(window->Pos, window->Pos + window->Size, GetColorU32(ImGuiCol_Border), rounding, ImDrawCornerFlags_All, border_size);

    int border_held = window->ResizeBorderHeld;
    if (border_held != -1)
    {
        struct ImGuiResizeBorderDef
        {
            ImVec2 InnerDir;
            ImVec2 CornerPosN1, CornerPosN2;
            float  OuterAngle;
        };
        static const ImGuiResizeBorderDef resize_border_def[4] =
        {
            { ImVec2(0,+1), ImVec2(0,0), ImVec2(1,0), IM_PI*1.50f }, // Top
            { ImVec2(-1,0), ImVec2(1,0), ImVec2(1,1), IM_PI*0.00f }, // Right
            { ImVec2(0,-1), ImVec2(1,1), ImVec2(0,1), IM_PI*0.50f }, // Bottom
            { ImVec2(+1,0), ImVec2(0,1), ImVec2(0,0), IM_PI*1.00f }  // Left
        };
        const ImGuiResizeBorderDef& def = resize_border_def[border_held];
        ImRect border_r = GetResizeBorderRect(window, border_held, rounding, 0.0f);
        window->DrawList->PathArcTo(ImLerp(border_r.Min, border_r.Max, def.CornerPosN1) + ImVec2(0.5f, 0.5f) + def.InnerDir * rounding, rounding, def.OuterAngle - IM_PI*0.25f, def.OuterAngle);
        window->DrawList->PathArcTo(ImLerp(border_r.Min, border_r.Max, def.CornerPosN2) + ImVec2(0.5f, 0.5f) + def.InnerDir * rounding, rounding, def.OuterAngle, def.OuterAngle + IM_PI*0.25f);
        window->DrawList->PathStroke(GetColorU32(ImGuiCol_SeparatorActive), false, ImMax(2.0f, border_size)); // Thicker than usual
    }
    if (g.Style.FrameBorderSize > 0 && !(window->Flags & ImGuiWindowFlags_NoTitleBar))
    {
        float y = window->Pos.y + window->TitleBarHeight() - 1;
        window->DrawList->AddLine(ImVec2(window->Pos.x + border_size, y), ImVec2(window->Pos.x + window->Size.x - border_size, y), GetColorU32(ImGuiCol_Border), g.Style.FrameBorderSize);
    }
}

void ImGui::UpdateWindowParentAndRootLinks(ImGuiWindow* window, ImGuiWindowFlags flags, ImGuiWindow* parent_window)
{
    window->ParentWindow = parent_window;
    window->RootWindow = window->RootWindowForTitleBarHighlight = window->RootWindowForNav = window;
    if (parent_window && (flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Tooltip))
        window->RootWindow = parent_window->RootWindow;
    if (parent_window && !(flags & ImGuiWindowFlags_Modal) && (flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup)))
        window->RootWindowForTitleBarHighlight = parent_window->RootWindowForTitleBarHighlight;
    while (window->RootWindowForNav->Flags & ImGuiWindowFlags_NavFlattened)
    {
        IM_ASSERT(window->RootWindowForNav->ParentWindow != NULL);
        window->RootWindowForNav = window->RootWindowForNav->ParentWindow;
    }
}

// Push a new ImGui window to add widgets to.
// - A default window called "Debug" is automatically stacked at the beginning of every frame so you can use widgets without explicitly calling a Begin/End pair.
// - Begin/End can be called multiple times during the frame with the same window name to append content.
// - The window name is used as a unique identifier to preserve window information across frames (and save rudimentary information to the .ini file).
//   You can use the "##" or "###" markers to use the same label with different id, or same id with different label. See documentation at the top of this file.
// - Return false when window is collapsed, so you can early out in your code. You always need to call ImGui::End() even if false is returned.
// - Passing 'bool* p_open' displays a Close button on the upper-right corner of the window, the pointed value will be set to false when the button is pressed.
bool ImGui::Begin(const char* name, bool* p_open, ImGuiWindowFlags flags)
{
    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    IM_ASSERT(name != NULL && name[0] != '\0');     // Window name required
    IM_ASSERT(g.FrameScopeActive);                  // Forgot to call ImGui::NewFrame()
    IM_ASSERT(g.FrameCountEnded != g.FrameCount);   // Called ImGui::Render() or ImGui::EndFrame() and haven't called ImGui::NewFrame() again yet

    // Find or create
    ImGuiWindow* window = FindWindowByName(name);
    const bool window_just_created = (window == NULL);
    if (window_just_created)
    {
        ImVec2 size_on_first_use = (g.NextWindowData.SizeCond != 0) ? g.NextWindowData.SizeVal : ImVec2(0.0f, 0.0f); // Any condition flag will do since we are creating a new window here.
        window = CreateNewWindow(name, size_on_first_use, flags);
    }

    // Automatically disable manual moving/resizing when NoInputs is set
    if ((flags & ImGuiWindowFlags_NoInputs) == ImGuiWindowFlags_NoInputs)
        flags |= ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize;

    if (flags & ImGuiWindowFlags_NavFlattened)
        IM_ASSERT(flags & ImGuiWindowFlags_ChildWindow);

    const int current_frame = g.FrameCount;
    const bool first_begin_of_the_frame = (window->LastFrameActive != current_frame);

    // Update the Appearing flag
    bool window_just_activated_by_user = (window->LastFrameActive < current_frame - 1);   // Not using !WasActive because the implicit "Debug" window would always toggle off->on
    const bool window_just_appearing_after_hidden_for_resize = (window->HiddenFramesCannotSkipItems > 0);
    if (flags & ImGuiWindowFlags_Popup)
    {
        ImGuiPopupData& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
        window_just_activated_by_user |= (window->PopupId != popup_ref.PopupId); // We recycle popups so treat window as activated if popup id changed
        window_just_activated_by_user |= (window != popup_ref.Window);
    }
    window->Appearing = (window_just_activated_by_user || window_just_appearing_after_hidden_for_resize);
    if (window->Appearing)
        SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, true);

    // Update Flags, LastFrameActive, BeginOrderXXX fields
    if (first_begin_of_the_frame)
    {
        window->Flags = (ImGuiWindowFlags)flags;
        window->LastFrameActive = current_frame;
        window->BeginOrderWithinParent = 0;
        window->BeginOrderWithinContext = (short)(g.WindowsActiveCount++);
    }
    else
    {
        flags = window->Flags;
    }

    // Parent window is latched only on the first call to Begin() of the frame, so further append-calls can be done from a different window stack
    ImGuiWindow* parent_window_in_stack = g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back();
    ImGuiWindow* parent_window = first_begin_of_the_frame ? ((flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup)) ? parent_window_in_stack : NULL) : window->ParentWindow;
    IM_ASSERT(parent_window != NULL || !(flags & ImGuiWindowFlags_ChildWindow));

    // Add to stack
    // We intentionally set g.CurrentWindow to NULL to prevent usage until when the viewport is set, then will call SetCurrentWindow()
    g.CurrentWindowStack.push_back(window);
    g.CurrentWindow = NULL;
    CheckStacksSize(window, true);
    if (flags & ImGuiWindowFlags_Popup)
    {
        ImGuiPopupData& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
        popup_ref.Window = window;
        g.BeginPopupStack.push_back(popup_ref);
        window->PopupId = popup_ref.PopupId;
    }

    if (window_just_appearing_after_hidden_for_resize && !(flags & ImGuiWindowFlags_ChildWindow))
        window->NavLastIds[0] = 0;

    // Process SetNextWindow***() calls
    bool window_pos_set_by_api = false;
    bool window_size_x_set_by_api = false, window_size_y_set_by_api = false;
    if (g.NextWindowData.PosCond)
    {
        window_pos_set_by_api = (window->SetWindowPosAllowFlags & g.NextWindowData.PosCond) != 0;
        if (window_pos_set_by_api && ImLengthSqr(g.NextWindowData.PosPivotVal) > 0.00001f)
        {
            // May be processed on the next frame if this is our first frame and we are measuring size
            // FIXME: Look into removing the branch so everything can go through this same code path for consistency.
            window->SetWindowPosVal = g.NextWindowData.PosVal;
            window->SetWindowPosPivot = g.NextWindowData.PosPivotVal;
            window->SetWindowPosAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);
        }
        else
        {
            SetWindowPos(window, g.NextWindowData.PosVal, g.NextWindowData.PosCond);
        }
    }
    if (g.NextWindowData.SizeCond)
    {
        window_size_x_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.x > 0.0f);
        window_size_y_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.y > 0.0f);
        SetWindowSize(window, g.NextWindowData.SizeVal, g.NextWindowData.SizeCond);
    }
    if (g.NextWindowData.ContentSizeCond)
    {
        // Adjust passed "client size" to become a "window size"
        window->SizeContentsExplicit = g.NextWindowData.ContentSizeVal;
        if (window->SizeContentsExplicit.y != 0.0f)
            window->SizeContentsExplicit.y += window->TitleBarHeight() + window->MenuBarHeight();
    }
    else if (first_begin_of_the_frame)
    {
        window->SizeContentsExplicit = ImVec2(0.0f, 0.0f);
    }
    if (g.NextWindowData.CollapsedCond)
        SetWindowCollapsed(window, g.NextWindowData.CollapsedVal, g.NextWindowData.CollapsedCond);
    if (g.NextWindowData.FocusCond)
        FocusWindow(window);
    if (window->Appearing)
        SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, false);

    // When reusing window again multiple times a frame, just append content (don't need to setup again)
    if (first_begin_of_the_frame)
    {
        // Initialize
        const bool window_is_child_tooltip = (flags & ImGuiWindowFlags_ChildWindow) && (flags & ImGuiWindowFlags_Tooltip); // FIXME-WIP: Undocumented behavior of Child+Tooltip for pinned tooltip (#1345)
        UpdateWindowParentAndRootLinks(window, flags, parent_window);

        window->Active = true;
        window->HasCloseButton = (p_open != NULL);
        window->ClipRect = ImVec4(-FLT_MAX,-FLT_MAX,+FLT_MAX,+FLT_MAX);
        window->IDStack.resize(1);

        // Update stored window name when it changes (which can _only_ happen with the "###" operator, so the ID would stay unchanged).
        // The title bar always display the 'name' parameter, so we only update the string storage if it needs to be visible to the end-user elsewhere.
        bool window_title_visible_elsewhere = false;
        if (g.NavWindowingList != NULL && (window->Flags & ImGuiWindowFlags_NoNavFocus) == 0)   // Window titles visible when using CTRL+TAB
            window_title_visible_elsewhere = true;
        if (window_title_visible_elsewhere && !window_just_created && strcmp(name, window->Name) != 0)
        {
            size_t buf_len = (size_t)window->NameBufLen;
            window->Name = ImStrdupcpy(window->Name, &buf_len, name);
            window->NameBufLen = (int)buf_len;
        }

        // UPDATE CONTENTS SIZE, UPDATE HIDDEN STATUS

        // Update contents size from last frame for auto-fitting (or use explicit size)
        window->SizeContents = CalcSizeContents(window);
        if (window->HiddenFramesCanSkipItems > 0)
            window->HiddenFramesCanSkipItems--;
        if (window->HiddenFramesCannotSkipItems > 0)
            window->HiddenFramesCannotSkipItems--;

        // Hide new windows for one frame until they calculate their size
        if (window_just_created && (!window_size_x_set_by_api || !window_size_y_set_by_api))
            window->HiddenFramesCannotSkipItems = 1;

        // Hide popup/tooltip window when re-opening while we measure size (because we recycle the windows)
        // We reset Size/SizeContents for reappearing popups/tooltips early in this function, so further code won't be tempted to use the old size.
        if (window_just_activated_by_user && (flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) != 0)
        {
            window->HiddenFramesCannotSkipItems = 1;
            if (flags & ImGuiWindowFlags_AlwaysAutoResize)
            {
                if (!window_size_x_set_by_api)
                    window->Size.x = window->SizeFull.x = 0.f;
                if (!window_size_y_set_by_api)
                    window->Size.y = window->SizeFull.y = 0.f;
                window->SizeContents = ImVec2(0.f, 0.f);
            }
        }

        SetCurrentWindow(window);

        // Lock border size and padding for the frame (so that altering them doesn't cause inconsistencies)
        if (flags & ImGuiWindowFlags_ChildWindow)
            window->WindowBorderSize = style.ChildBorderSize;
        else
            window->WindowBorderSize = ((flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) && !(flags & ImGuiWindowFlags_Modal)) ? style.PopupBorderSize : style.WindowBorderSize;
        window->WindowPadding = style.WindowPadding;
        if ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & (ImGuiWindowFlags_AlwaysUseWindowPadding | ImGuiWindowFlags_Popup)) && window->WindowBorderSize == 0.0f)
            window->WindowPadding = ImVec2(0.0f, (flags & ImGuiWindowFlags_MenuBar) ? style.WindowPadding.y : 0.0f);
        window->DC.MenuBarOffset.x = ImMax(ImMax(window->WindowPadding.x, style.ItemSpacing.x), g.NextWindowData.MenuBarOffsetMinVal.x);
        window->DC.MenuBarOffset.y = g.NextWindowData.MenuBarOffsetMinVal.y;

        // Collapse window by double-clicking on title bar
        // At this point we don't have a clipping rectangle setup yet, so we can use the title bar area for hit detection and drawing
        if (!(flags & ImGuiWindowFlags_NoTitleBar) && !(flags & ImGuiWindowFlags_NoCollapse))
        {
            // We don't use a regular button+id to test for double-click on title bar (mostly due to legacy reason, could be fixed), so verify that we don't have items over the title bar.
            ImRect title_bar_rect = window->TitleBarRect();
            if (g.HoveredWindow == window && g.HoveredId == 0 && g.HoveredIdPreviousFrame == 0 && IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max) && g.IO.MouseDoubleClicked[0])
                window->WantCollapseToggle = true;
            if (window->WantCollapseToggle)
            {
                window->Collapsed = !window->Collapsed;
                MarkIniSettingsDirty(window);
                FocusWindow(window);
            }
        }
        else
        {
            window->Collapsed = false;
        }
        window->WantCollapseToggle = false;

        // SIZE

        // Calculate auto-fit size, handle automatic resize
        const ImVec2 size_auto_fit = CalcSizeAutoFit(window, window->SizeContents);
        ImVec2 size_full_modified(FLT_MAX, FLT_MAX);
        if ((flags & ImGuiWindowFlags_AlwaysAutoResize) && !window->Collapsed)
        {
            // Using SetNextWindowSize() overrides ImGuiWindowFlags_AlwaysAutoResize, so it can be used on tooltips/popups, etc.
            if (!window_size_x_set_by_api)
                window->SizeFull.x = size_full_modified.x = size_auto_fit.x;
            if (!window_size_y_set_by_api)
                window->SizeFull.y = size_full_modified.y = size_auto_fit.y;
        }
        else if (window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
        {
            // Auto-fit may only grow window during the first few frames
            // We still process initial auto-fit on collapsed windows to get a window width, but otherwise don't honor ImGuiWindowFlags_AlwaysAutoResize when collapsed.
            if (!window_size_x_set_by_api && window->AutoFitFramesX > 0)
                window->SizeFull.x = size_full_modified.x = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.x, size_auto_fit.x) : size_auto_fit.x;
            if (!window_size_y_set_by_api && window->AutoFitFramesY > 0)
                window->SizeFull.y = size_full_modified.y = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.y, size_auto_fit.y) : size_auto_fit.y;
            if (!window->Collapsed)
                MarkIniSettingsDirty(window);
        }

        // Apply minimum/maximum window size constraints and final size
        window->SizeFull = CalcSizeAfterConstraint(window, window->SizeFull);
        window->Size = window->Collapsed && !(flags & ImGuiWindowFlags_ChildWindow) ? window->TitleBarRect().GetSize() : window->SizeFull;

        // SCROLLBAR STATUS

        // Update scrollbar status (based on the Size that was effective during last frame or the auto-resized Size).
        if (!window->Collapsed)
        {
            // When reading the current size we need to read it after size constraints have been applied
            float size_x_for_scrollbars = size_full_modified.x != FLT_MAX ? window->SizeFull.x : window->SizeFullAtLastBegin.x;
            float size_y_for_scrollbars = size_full_modified.y != FLT_MAX ? window->SizeFull.y : window->SizeFullAtLastBegin.y;
            window->ScrollbarY = (flags & ImGuiWindowFlags_AlwaysVerticalScrollbar) || ((window->SizeContents.y > size_y_for_scrollbars) && !(flags & ImGuiWindowFlags_NoScrollbar));
            window->ScrollbarX = (flags & ImGuiWindowFlags_AlwaysHorizontalScrollbar) || ((window->SizeContents.x > size_x_for_scrollbars - (window->ScrollbarY ? style.ScrollbarSize : 0.0f)) && !(flags & ImGuiWindowFlags_NoScrollbar) && (flags & ImGuiWindowFlags_HorizontalScrollbar));
            if (window->ScrollbarX && !window->ScrollbarY)
                window->ScrollbarY = (window->SizeContents.y > size_y_for_scrollbars - style.ScrollbarSize) && !(flags & ImGuiWindowFlags_NoScrollbar);
            window->ScrollbarSizes = ImVec2(window->ScrollbarY ? style.ScrollbarSize : 0.0f, window->ScrollbarX ? style.ScrollbarSize : 0.0f);
        }

        // POSITION

        // Popup latch its initial position, will position itself when it appears next frame
        if (window_just_activated_by_user)
        {
            window->AutoPosLastDirection = ImGuiDir_None;
            if ((flags & ImGuiWindowFlags_Popup) != 0 && !window_pos_set_by_api)
                window->Pos = g.BeginPopupStack.back().OpenPopupPos;
        }

        // Position child window
        if (flags & ImGuiWindowFlags_ChildWindow)
        {
            IM_ASSERT(parent_window && parent_window->Active);
            window->BeginOrderWithinParent = (short)parent_window->DC.ChildWindows.Size;
            parent_window->DC.ChildWindows.push_back(window);
            if (!(flags & ImGuiWindowFlags_Popup) && !window_pos_set_by_api && !window_is_child_tooltip)
                window->Pos = parent_window->DC.CursorPos;
        }

        const bool window_pos_with_pivot = (window->SetWindowPosVal.x != FLT_MAX && window->HiddenFramesCannotSkipItems == 0);
        if (window_pos_with_pivot)
            SetWindowPos(window, ImMax(style.DisplaySafeAreaPadding, window->SetWindowPosVal - window->SizeFull * window->SetWindowPosPivot), 0); // Position given a pivot (e.g. for centering)
        else if ((flags & ImGuiWindowFlags_ChildMenu) != 0)
            window->Pos = FindBestWindowPosForPopup(window);
        else if ((flags & ImGuiWindowFlags_Popup) != 0 && !window_pos_set_by_api && window_just_appearing_after_hidden_for_resize)
            window->Pos = FindBestWindowPosForPopup(window);
        else if ((flags & ImGuiWindowFlags_Tooltip) != 0 && !window_pos_set_by_api && !window_is_child_tooltip)
            window->Pos = FindBestWindowPosForPopup(window);

        // Clamp position so it stays visible
        // Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.
        ImRect viewport_rect(GetViewportRect());
        if (!window_pos_set_by_api && !(flags & ImGuiWindowFlags_ChildWindow) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)
        {
            if (g.IO.DisplaySize.x > 0.0f && g.IO.DisplaySize.y > 0.0f) // Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.
            {
                ImVec2 clamp_padding = ImMax(style.DisplayWindowPadding, style.DisplaySafeAreaPadding);
                ClampWindowRect(window, viewport_rect, clamp_padding);
            }
        }
        window->Pos = ImFloor(window->Pos);

        // Lock window rounding for the frame (so that altering them doesn't cause inconsistencies)
        window->WindowRounding = (flags & ImGuiWindowFlags_ChildWindow) ? style.ChildRounding : ((flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiWindowFlags_Modal)) ? style.PopupRounding : style.WindowRounding;

        // Apply scrolling
        window->Scroll = CalcNextScrollFromScrollTargetAndClamp(window, true);
        window->ScrollTarget = ImVec2(FLT_MAX, FLT_MAX);

        // Apply window focus (new and reactivated windows are moved to front)
        bool want_focus = false;
        if (window_just_activated_by_user && !(flags & ImGuiWindowFlags_NoFocusOnAppearing))
        {
            if (flags & ImGuiWindowFlags_Popup)
                want_focus = true;
            else if ((flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Tooltip)) == 0)
                want_focus = true;
        }

        // Handle manual resize: Resize Grips, Borders, Gamepad
        int border_held = -1;
        ImU32 resize_grip_col[4] = { 0 };
        const int resize_grip_count = g.IO.ConfigWindowsResizeFromEdges ? 2 : 1; // 4
        const float grip_draw_size = (float)(int)ImMax(g.FontSize * 1.35f, window->WindowRounding + 1.0f + g.FontSize * 0.2f);
        if (!window->Collapsed)
            UpdateManualResize(window, size_auto_fit, &border_held, resize_grip_count, &resize_grip_col[0]);
        window->ResizeBorderHeld = (signed char)border_held;

        // Default item width. Make it proportional to window size if window manually resizes
        if (window->Size.x > 0.0f && !(flags & ImGuiWindowFlags_Tooltip) && !(flags & ImGuiWindowFlags_AlwaysAutoResize))
            window->ItemWidthDefault = (float)(int)(window->Size.x * 0.65f);
        else
            window->ItemWidthDefault = (float)(int)(g.FontSize * 16.0f);

        // DRAWING

        // Setup draw list and outer clipping rectangle
        window->DrawList->Clear();
        window->DrawList->Flags = (g.Style.AntiAliasedLines ? ImDrawListFlags_AntiAliasedLines : 0) | (g.Style.AntiAliasedFill ? ImDrawListFlags_AntiAliasedFill : 0);
        window->DrawList->PushTextureID(g.Font->ContainerAtlas->TexID);
        if ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup) && !window_is_child_tooltip)
            PushClipRect(parent_window->ClipRect.Min, parent_window->ClipRect.Max, true);
        else
            PushClipRect(viewport_rect.Min, viewport_rect.Max, true);

        // Draw modal window background (darkens what is behind them, all viewports)
        const bool dim_bg_for_modal = (flags & ImGuiWindowFlags_Modal) && window == GetFrontMostPopupModal() && window->HiddenFramesCannotSkipItems <= 0;
        const bool dim_bg_for_window_list = g.NavWindowingTargetAnim && (window == g.NavWindowingTargetAnim->RootWindow);
        if (dim_bg_for_modal || dim_bg_for_window_list)
        {
            const ImU32 dim_bg_col = GetColorU32(dim_bg_for_modal ? ImGuiCol_ModalWindowDimBg : ImGuiCol_NavWindowingDimBg, g.DimBgRatio);
            window->DrawList->AddRectFilled(viewport_rect.Min, viewport_rect.Max, dim_bg_col);
        }

        // Draw navigation selection/windowing rectangle background
        if (dim_bg_for_window_list && window == g.NavWindowingTargetAnim)
        {
            ImRect bb = window->Rect();
            bb.Expand(g.FontSize);
            if (!bb.Contains(viewport_rect)) // Avoid drawing if the window covers all the viewport anyway
                window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(ImGuiCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha * 0.25f), g.Style.WindowRounding);
        }

        // Draw window + handle manual resize
        // As we highlight the title bar when want_focus is set, multiple reappearing windows will have have their title bar highlighted on their reappearing frame.
        const float window_rounding = window->WindowRounding;
        const float window_border_size = window->WindowBorderSize;
        const ImGuiWindow* window_to_highlight = g.NavWindowingTarget ? g.NavWindowingTarget : g.NavWindow;
        const bool title_bar_is_highlight = want_focus || (window_to_highlight && window->RootWindowForTitleBarHighlight == window_to_highlight->RootWindowForTitleBarHighlight);
        const ImRect title_bar_rect = window->TitleBarRect();
        if (window->Collapsed)
        {
            // Title bar only
            float backup_border_size = style.FrameBorderSize;
            g.Style.FrameBorderSize = window->WindowBorderSize;
            ImU32 title_bar_col = GetColorU32((title_bar_is_highlight && !g.NavDisableHighlight) ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBgCollapsed);
            RenderFrame(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, true, window_rounding);
            g.Style.FrameBorderSize = backup_border_size;
        }
        else
        {
            // Window background
            if (!(flags & ImGuiWindowFlags_NoBackground))
            {
                ImU32 bg_col = GetColorU32(GetWindowBgColorIdxFromFlags(flags));
                float alpha = 1.0f;
                if (g.NextWindowData.BgAlphaCond != 0)
                    alpha = g.NextWindowData.BgAlphaVal;
                if (alpha != 1.0f)
                    bg_col = (bg_col & ~IM_COL32_A_MASK) | (IM_F32_TO_INT8_SAT(alpha) << IM_COL32_A_SHIFT);
                window->DrawList->AddRectFilled(window->Pos + ImVec2(0, window->TitleBarHeight()), window->Pos + window->Size, bg_col, window_rounding, (flags & ImGuiWindowFlags_NoTitleBar) ? ImDrawCornerFlags_All : ImDrawCornerFlags_Bot);
            }
            g.NextWindowData.BgAlphaCond = 0;

            // Title bar
            if (!(flags & ImGuiWindowFlags_NoTitleBar))
            {
                ImU32 title_bar_col = GetColorU32(title_bar_is_highlight ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBg);
                window->DrawList->AddRectFilled(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, window_rounding, ImDrawCornerFlags_Top);
            }

            // Menu bar
            if (flags & ImGuiWindowFlags_MenuBar)
            {
                ImRect menu_bar_rect = window->MenuBarRect();
                menu_bar_rect.ClipWith(window->Rect());  // Soft clipping, in particular child window don't have minimum size covering the menu bar so this is useful for them.
                window->DrawList->AddRectFilled(menu_bar_rect.Min+ImVec2(window_border_size,0), menu_bar_rect.Max-ImVec2(window_border_size,0), GetColorU32(ImGuiCol_MenuBarBg), (flags & ImGuiWindowFlags_NoTitleBar) ? window_rounding : 0.0f, ImDrawCornerFlags_Top);
                if (style.FrameBorderSize > 0.0f && menu_bar_rect.Max.y < window->Pos.y + window->Size.y)
                    window->DrawList->AddLine(menu_bar_rect.GetBL(), menu_bar_rect.GetBR(), GetColorU32(ImGuiCol_Border), style.FrameBorderSize);
            }

            // Scrollbars
            if (window->ScrollbarX)
                Scrollbar(ImGuiAxis_X);
            if (window->ScrollbarY)
                Scrollbar(ImGuiAxis_Y);

            // Render resize grips (after their input handling so we don't have a frame of latency)
            if (!(flags & ImGuiWindowFlags_NoResize))
            {
                for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)
                {
                    const ImGuiResizeGripDef& grip = resize_grip_def[resize_grip_n];
                    const ImVec2 corner = ImLerp(window->Pos, window->Pos + window->Size, grip.CornerPosN);
                    window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2(window_border_size, grip_draw_size) : ImVec2(grip_draw_size, window_border_size)));
                    window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2(grip_draw_size, window_border_size) : ImVec2(window_border_size, grip_draw_size)));
                    window->DrawList->PathArcToFast(ImVec2(corner.x + grip.InnerDir.x * (window_rounding + window_border_size), corner.y + grip.InnerDir.y * (window_rounding + window_border_size)), window_rounding, grip.AngleMin12, grip.AngleMax12);
                    window->DrawList->PathFillConvex(resize_grip_col[resize_grip_n]);
                }
            }

            // Borders
            RenderOuterBorders(window);
        }

        // Draw navigation selection/windowing rectangle border
        if (g.NavWindowingTargetAnim == window)
        {
            float rounding = ImMax(window->WindowRounding, g.Style.WindowRounding);
            ImRect bb = window->Rect();
            bb.Expand(g.FontSize);
            if (bb.Contains(viewport_rect)) // If a window fits the entire viewport, adjust its highlight inward
            {
                bb.Expand(-g.FontSize - 1.0f);
                rounding = window->WindowRounding;
            }
            window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(ImGuiCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha), rounding, ~0, 3.0f);
        }

        // Store a backup of SizeFull which we will use next frame to decide if we need scrollbars.
        window->SizeFullAtLastBegin = window->SizeFull;

        // Update various regions. Variables they depends on are set above in this function.
        // FIXME: window->ContentsRegionRect.Max is currently very misleading / partly faulty, but some BeginChild() patterns relies on it.
        // NB: WindowBorderSize is included in WindowPadding _and_ ScrollbarSizes so we need to cancel one out.
        window->ContentsRegionRect.Min.x = window->Pos.x - window->Scroll.x + window->WindowPadding.x;
        window->ContentsRegionRect.Min.y = window->Pos.y - window->Scroll.y + window->WindowPadding.y + window->TitleBarHeight() + window->MenuBarHeight();
        window->ContentsRegionRect.Max.x = window->Pos.x - window->Scroll.x - window->WindowPadding.x + (window->SizeContentsExplicit.x != 0.0f ? window->SizeContentsExplicit.x : (window->Size.x - window->ScrollbarSizes.x + ImMin(window->ScrollbarSizes.x, window->WindowBorderSize)));
        window->ContentsRegionRect.Max.y = window->Pos.y - window->Scroll.y - window->WindowPadding.y + (window->SizeContentsExplicit.y != 0.0f ? window->SizeContentsExplicit.y : (window->Size.y - window->ScrollbarSizes.y + ImMin(window->ScrollbarSizes.y, window->WindowBorderSize)));

        // Save clipped aabb so we can access it in constant-time in FindHoveredWindow()
        window->OuterRectClipped = window->Rect();
        window->OuterRectClipped.ClipWith(window->ClipRect);

        // Inner rectangle
        // We set this up after processing the resize grip so that our clip rectangle doesn't lag by a frame
        // Note that if our window is collapsed we will end up with an inverted (~null) clipping rectangle which is the correct behavior.
        window->InnerMainRect.Min.x = title_bar_rect.Min.x + window->WindowBorderSize;
        window->InnerMainRect.Min.y = title_bar_rect.Max.y + window->MenuBarHeight() + (((flags & ImGuiWindowFlags_MenuBar) || !(flags & ImGuiWindowFlags_NoTitleBar)) ? style.FrameBorderSize : window->WindowBorderSize);
        window->InnerMainRect.Max.x = window->Pos.x + window->Size.x - ImMax(window->ScrollbarSizes.x, window->WindowBorderSize);
        window->InnerMainRect.Max.y = window->Pos.y + window->Size.y - ImMax(window->ScrollbarSizes.y, window->WindowBorderSize);

        // Inner clipping rectangle
        // Force round operator last to ensure that e.g. (int)(max.x-min.x) in user's render code produce correct result.
        window->InnerClipRect.Min.x = ImFloor(0.5f + window->InnerMainRect.Min.x + ImMax(0.0f, ImFloor(window->WindowPadding.x * 0.5f - window->WindowBorderSize)));
        window->InnerClipRect.Min.y = ImFloor(0.5f + window->InnerMainRect.Min.y);
        window->InnerClipRect.Max.x = ImFloor(0.5f + window->InnerMainRect.Max.x - ImMax(0.0f, ImFloor(window->WindowPadding.x * 0.5f - window->WindowBorderSize)));
        window->InnerClipRect.Max.y = ImFloor(0.5f + window->InnerMainRect.Max.y);
        // Setup drawing context
        // (NB: That term "drawing context / DC" lost its meaning a long time ago. Initially was meant to hold transient data only. Nowadays difference between window-> and window->DC-> is dubious.)
        window->DC.Indent.x = 0.0f + window->WindowPadding.x - window->Scroll.x;
        window->DC.GroupOffset.x = 0.0f;
        window->DC.ColumnsOffset.x = 0.0f;
        window->DC.CursorStartPos = window->Pos + ImVec2(window->DC.Indent.x + window->DC.ColumnsOffset.x, window->TitleBarHeight() + window->MenuBarHeight() + window->WindowPadding.y - window->Scroll.y);
        window->DC.CursorPos = window->DC.CursorStartPos;
        window->DC.CursorPosPrevLine = window->DC.CursorPos;
        window->DC.CursorMaxPos = window->DC.CursorStartPos;
        window->DC.CurrentLineSize = window->DC.PrevLineSize = ImVec2(0.0f, 0.0f);
        window->DC.CurrentLineTextBaseOffset = window->DC.PrevLineTextBaseOffset = 0.0f;
        window->DC.NavHideHighlightOneFrame = false;
        window->DC.NavHasScroll = (GetWindowScrollMaxY(window) > 0.0f);
        window->DC.NavLayerActiveMask = window->DC.NavLayerActiveMaskNext;
        window->DC.NavLayerActiveMaskNext = 0x00;
        window->DC.MenuBarAppending = false;
        window->DC.ChildWindows.resize(0);
        window->DC.LayoutType = ImGuiLayoutType_Vertical;
        window->DC.ParentLayoutType = parent_window ? parent_window->DC.LayoutType : ImGuiLayoutType_Vertical;
        window->DC.FocusCounterAll = window->DC.FocusCounterTab = -1;
        window->DC.ItemFlags = parent_window ? parent_window->DC.ItemFlags : ImGuiItemFlags_Default_;
        window->DC.ItemWidth = window->ItemWidthDefault;
        window->DC.TextWrapPos = -1.0f; // disabled
        window->DC.ItemFlagsStack.resize(0);
        window->DC.ItemWidthStack.resize(0);
        window->DC.TextWrapPosStack.resize(0);
        window->DC.CurrentColumns = NULL;
        window->DC.TreeDepth = 0;
        window->DC.TreeStoreMayJumpToParentOnPop = 0x00;
        window->DC.StateStorage = &window->StateStorage;
        window->DC.GroupStack.resize(0);
        window->MenuColumns.Update(3, style.ItemSpacing.x, window_just_activated_by_user);

        if ((flags & ImGuiWindowFlags_ChildWindow) && (window->DC.ItemFlags != parent_window->DC.ItemFlags))
        {
            window->DC.ItemFlags = parent_window->DC.ItemFlags;
            window->DC.ItemFlagsStack.push_back(window->DC.ItemFlags);
        }

        if (window->AutoFitFramesX > 0)
            window->AutoFitFramesX--;
        if (window->AutoFitFramesY > 0)
            window->AutoFitFramesY--;

        // Apply focus (we need to call FocusWindow() AFTER setting DC.CursorStartPos so our initial navigation reference rectangle can start around there)
        if (want_focus)
        {
            FocusWindow(window);
            NavInitWindow(window, false);
        }

        // Title bar
        if (!(flags & ImGuiWindowFlags_NoTitleBar))
        {
            // Close & collapse button are on layer 1 (same as menus) and don't default focus
            const ImGuiItemFlags item_flags_backup = window->DC.ItemFlags;
            window->DC.ItemFlags |= ImGuiItemFlags_NoNavDefaultFocus;
            window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;
            window->DC.NavLayerCurrentMask = (1 << ImGuiNavLayer_Menu);

            // Collapse button
            if (!(flags & ImGuiWindowFlags_NoCollapse))
                if (CollapseButton(window->GetID("#COLLAPSE"), window->Pos))
                    window->WantCollapseToggle = true; // Defer collapsing to next frame as we are too far in the Begin() function

            // Close button
            if (p_open != NULL)
            {
                const float rad = g.FontSize * 0.5f;
                if (CloseButton(window->GetID("#CLOSE"), ImVec2(window->Pos.x + window->Size.x - style.FramePadding.x - rad, window->Pos.y + style.FramePadding.y + rad), rad + 1))
                    *p_open = false;
            }

            window->DC.NavLayerCurrent = ImGuiNavLayer_Main;
            window->DC.NavLayerCurrentMask = (1 << ImGuiNavLayer_Main);
            window->DC.ItemFlags = item_flags_backup;

            // Title bar text (with: horizontal alignment, avoiding collapse/close button, optional "unsaved document" marker)
            // FIXME: Refactor text alignment facilities along with RenderText helpers, this is too much code..
            const char* UNSAVED_DOCUMENT_MARKER = "*";
            float marker_size_x = (flags & ImGuiWindowFlags_UnsavedDocument) ? CalcTextSize(UNSAVED_DOCUMENT_MARKER, NULL, false).x : 0.0f;
            ImVec2 text_size = CalcTextSize(name, NULL, true) + ImVec2(marker_size_x, 0.0f);
            ImRect text_r = title_bar_rect;
            float pad_left = (flags & ImGuiWindowFlags_NoCollapse) ? style.FramePadding.x : (style.FramePadding.x + g.FontSize + style.ItemInnerSpacing.x);
            float pad_right = (p_open == NULL)                     ? style.FramePadding.x : (style.FramePadding.x + g.FontSize + style.ItemInnerSpacing.x);
            if (style.WindowTitleAlign.x > 0.0f)
                pad_right = ImLerp(pad_right, pad_left, style.WindowTitleAlign.x);
            text_r.Min.x += pad_left;
            text_r.Max.x -= pad_right;
            ImRect clip_rect = text_r;
            clip_rect.Max.x = window->Pos.x + window->Size.x - (p_open ? title_bar_rect.GetHeight() - 3 : style.FramePadding.x); // Match the size of CloseButton()
            RenderTextClipped(text_r.Min, text_r.Max, name, NULL, &text_size, style.WindowTitleAlign, &clip_rect);
            if (flags & ImGuiWindowFlags_UnsavedDocument)
            {
                ImVec2 marker_pos = ImVec2(ImMax(text_r.Min.x, text_r.Min.x + (text_r.GetWidth() - text_size.x) * style.WindowTitleAlign.x) + text_size.x, text_r.Min.y) + ImVec2(2 - marker_size_x, 0.0f);
                ImVec2 off = ImVec2(0.0f, (float)(int)(-g.FontSize * 0.25f));
                RenderTextClipped(marker_pos + off, text_r.Max + off, UNSAVED_DOCUMENT_MARKER, NULL, NULL, ImVec2(0, style.WindowTitleAlign.y), &clip_rect);
            }
        }

        // Pressing CTRL+C while holding on a window copy its content to the clipboard
        // This works but 1. doesn't handle multiple Begin/End pairs, 2. recursing into another Begin/End pair - so we need to work that out and add better logging scope.
        // Maybe we can support CTRL+C on every element?
        /*
        if (g.ActiveId == move_id)
            if (g.IO.KeyCtrl && IsKeyPressedMap(ImGuiKey_C))
                LogToClipboard();
        */

        // We fill last item data based on Title Bar/Tab, in order for IsItemHovered() and IsItemActive() to be usable after Begin().
        // This is useful to allow creating context menus on title bar only, etc.
        window->DC.LastItemId = window->MoveId;
        window->DC.LastItemStatusFlags = IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max, false) ? ImGuiItemStatusFlags_HoveredRect : 0;
        window->DC.LastItemRect = title_bar_rect;
#ifdef IMGUI_ENABLE_TEST_ENGINE
        if (!(window->Flags & ImGuiWindowFlags_NoTitleBar))
            IMGUI_TEST_ENGINE_ITEM_ADD(window->DC.LastItemRect, window->DC.LastItemId);
#endif
    }
    else
    {
        // Append
        SetCurrentWindow(window);
    }

    PushClipRect(window->InnerClipRect.Min, window->InnerClipRect.Max, true);

    // Clear 'accessed' flag last thing (After PushClipRect which will set the flag. We want the flag to stay false when the default "Debug" window is unused)
    if (first_begin_of_the_frame)
        window->WriteAccessed = false;

    window->BeginCount++;
    g.NextWindowData.Clear();

    if (flags & ImGuiWindowFlags_ChildWindow)
    {
        // Child window can be out of sight and have "negative" clip windows.
        // Mark them as collapsed so commands are skipped earlier (we can't manually collapse them because they have no title bar).
        IM_ASSERT((flags & ImGuiWindowFlags_NoTitleBar) != 0);
        if (!(flags & ImGuiWindowFlags_AlwaysAutoResize) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)
            if (window->OuterRectClipped.Min.x >= window->OuterRectClipped.Max.x || window->OuterRectClipped.Min.y >= window->OuterRectClipped.Max.y)
                window->HiddenFramesCanSkipItems = 1;

        // Completely hide along with parent or if parent is collapsed
        if (parent_window && (parent_window->Collapsed || parent_window->Hidden))
            window->HiddenFramesCanSkipItems = 1;
    }

    // Don't render if style alpha is 0.0 at the time of Begin(). This is arbitrary and inconsistent but has been there for a long while (may remove at some point)
    if (style.Alpha <= 0.0f)
        window->HiddenFramesCanSkipItems = 1;

    // Update the Hidden flag
    window->Hidden = (window->HiddenFramesCanSkipItems > 0) || (window->HiddenFramesCannotSkipItems > 0);

    // Update the SkipItems flag, used to early out of all items functions (no layout required)
    bool skip_items = false;
    if (window->Collapsed || !window->Active || window->Hidden)
        if (window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0 && window->HiddenFramesCannotSkipItems <= 0)
            skip_items = true;
    window->SkipItems = skip_items;

    return !skip_items;
}

// Old Begin() API with 5 parameters, avoid calling this version directly! Use SetNextWindowSize()/SetNextWindowBgAlpha() + Begin() instead.
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
bool ImGui::Begin(const char* name, bool* p_open, const ImVec2& size_first_use, float bg_alpha_override, ImGuiWindowFlags flags)
{
    // Old API feature: we could pass the initial window size as a parameter. This was misleading because it only had an effect if the window didn't have data in the .ini file.
    if (size_first_use.x != 0.0f || size_first_use.y != 0.0f)
        SetNextWindowSize(size_first_use, ImGuiCond_FirstUseEver);

    // Old API feature: override the window background alpha with a parameter.
    if (bg_alpha_override >= 0.0f)
        SetNextWindowBgAlpha(bg_alpha_override);

    return Begin(name, p_open, flags);
}
#endif // IMGUI_DISABLE_OBSOLETE_FUNCTIONS

void ImGui::End()
{
    ImGuiContext& g = *GImGui;

    if (g.CurrentWindowStack.Size <= 1 && g.FrameScopePushedImplicitWindow)
    {
        IM_ASSERT(g.CurrentWindowStack.Size > 1 && "Calling End() too many times!");
        return; // FIXME-ERRORHANDLING
    }
    IM_ASSERT(g.CurrentWindowStack.Size > 0);

    ImGuiWindow* window = g.CurrentWindow;

    if (window->DC.CurrentColumns != NULL)
        EndColumns();
    PopClipRect();   // Inner window clip rectangle

    // Stop logging
    if (!(window->Flags & ImGuiWindowFlags_ChildWindow))    // FIXME: add more options for scope of logging
        LogFinish();

    // Pop from window stack
    g.CurrentWindowStack.pop_back();
    if (window->Flags & ImGuiWindowFlags_Popup)
        g.BeginPopupStack.pop_back();
    CheckStacksSize(window, false);
    SetCurrentWindow(g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back());
}

void ImGui::BringWindowToFocusFront(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    if (g.WindowsFocusOrder.back() == window)
        return;
    for (int i = g.WindowsFocusOrder.Size - 2; i >= 0; i--) // We can ignore the front most window
        if (g.WindowsFocusOrder[i] == window)
        {
            memmove(&g.WindowsFocusOrder[i], &g.WindowsFocusOrder[i + 1], (size_t)(g.WindowsFocusOrder.Size - i - 1) * sizeof(ImGuiWindow*));
            g.WindowsFocusOrder[g.WindowsFocusOrder.Size - 1] = window;
            break;
        }
}

void ImGui::BringWindowToDisplayFront(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* current_front_window = g.Windows.back();
    if (current_front_window == window || current_front_window->RootWindow == window)
        return;
    for (int i = g.Windows.Size - 2; i >= 0; i--) // We can ignore the front most window
        if (g.Windows[i] == window)
        {
            memmove(&g.Windows[i], &g.Windows[i + 1], (size_t)(g.Windows.Size - i - 1) * sizeof(ImGuiWindow*));
            g.Windows[g.Windows.Size - 1] = window;
            break;
        }
}

void ImGui::BringWindowToDisplayBack(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    if (g.Windows[0] == window)
        return;
    for (int i = 0; i < g.Windows.Size; i++)
        if (g.Windows[i] == window)
        {
            memmove(&g.Windows[1], &g.Windows[0], (size_t)i * sizeof(ImGuiWindow*));
            g.Windows[0] = window;
            break;
        }
}

// Moving window to front of display and set focus (which happens to be back of our sorted list)
void ImGui::FocusWindow(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;

    if (g.NavWindow != window)
    {
        g.NavWindow = window;
        if (window && g.NavDisableMouseHover)
            g.NavMousePosDirty = true;
        g.NavInitRequest = false;
        g.NavId = window ? window->NavLastIds[0] : 0; // Restore NavId
        g.NavIdIsAlive = false;
        g.NavLayer = ImGuiNavLayer_Main;
        //IMGUI_DEBUG_LOG("FocusWindow(\"%s\")\n", window ? window->Name : NULL);
    }

    // Close popups if any
    ClosePopupsOverWindow(window, false);

    // Passing NULL allow to disable keyboard focus
    if (!window)
        return;

    // Move the root window to the top of the pile
    if (window->RootWindow)
        window = window->RootWindow;

    // Steal focus on active widgets
    if (window->Flags & ImGuiWindowFlags_Popup) // FIXME: This statement should be unnecessary. Need further testing before removing it..
        if (g.ActiveId != 0 && g.ActiveIdWindow && g.ActiveIdWindow->RootWindow != window)
            ClearActiveID();

    // Bring to front
    BringWindowToFocusFront(window);
    if (!(window->Flags & ImGuiWindowFlags_NoBringToFrontOnFocus))
        BringWindowToDisplayFront(window);
}

void ImGui::FocusTopMostWindowUnderOne(ImGuiWindow* under_this_window, ImGuiWindow* ignore_window)
{
    ImGuiContext& g = *GImGui;

    int start_idx = g.WindowsFocusOrder.Size - 1;
    if (under_this_window != NULL)
    {
        int under_this_window_idx = FindWindowFocusIndex(under_this_window);
        if (under_this_window_idx != -1)
            start_idx = under_this_window_idx - 1;
    }
    for (int i = start_idx; i >= 0; i--)
    {
        // We may later decide to test for different NoXXXInputs based on the active navigation input (mouse vs nav) but that may feel more confusing to the user.
        ImGuiWindow* window = g.WindowsFocusOrder[i];
        if (window != ignore_window && window->WasActive && !(window->Flags & ImGuiWindowFlags_ChildWindow))
            if ((window->Flags & (ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs)) != (ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs))
            {
                ImGuiWindow* focus_window = NavRestoreLastChildNavWindow(window);
                FocusWindow(focus_window);
                return;
            }
    }
    FocusWindow(NULL);
}

void ImGui::SetNextItemWidth(float item_width)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.NextItemWidth = item_width;
}

void ImGui::PushItemWidth(float item_width)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.ItemWidth = (item_width == 0.0f ? window->ItemWidthDefault : item_width);
    window->DC.ItemWidthStack.push_back(window->DC.ItemWidth);
}

void ImGui::PushMultiItemsWidths(int components, float w_full)
{
    ImGuiWindow* window = GetCurrentWindow();
    const ImGuiStyle& style = GImGui->Style;
    const float w_item_one  = ImMax(1.0f, (float)(int)((w_full - (style.ItemInnerSpacing.x) * (components-1)) / (float)components));
    const float w_item_last = ImMax(1.0f, (float)(int)(w_full - (w_item_one + style.ItemInnerSpacing.x) * (components-1)));
    window->DC.ItemWidthStack.push_back(w_item_last);
    for (int i = 0; i < components-1; i++)
        window->DC.ItemWidthStack.push_back(w_item_one);
    window->DC.ItemWidth = window->DC.ItemWidthStack.back();
}

void ImGui::PopItemWidth()
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.ItemWidthStack.pop_back();
    window->DC.ItemWidth = window->DC.ItemWidthStack.empty() ? window->ItemWidthDefault : window->DC.ItemWidthStack.back();
}

// Calculate default item width given value passed to PushItemWidth() or SetNextItemWidth(),
// Then consume the 
float ImGui::GetNextItemWidth()
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    float w;
    if (window->DC.NextItemWidth != FLT_MAX)
    {
        w = window->DC.NextItemWidth;
        window->DC.NextItemWidth = FLT_MAX;
    }
    else
    {
        w = window->DC.ItemWidth;
    }
    if (w < 0.0f)
    {
        float region_max_x = GetWorkRectMax().x;
        w = ImMax(1.0f, region_max_x - window->DC.CursorPos.x + w);
    }
    w = (float)(int)w;
    return w;
}

// Calculate item width *without* popping/consuming NextItemWidth if it was set.
// (rarely used, which is why we avoid calling this from GetNextItemWidth() and instead do a backup/restore here)
float ImGui::CalcItemWidth()
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    float backup_next_item_width = window->DC.NextItemWidth;
    float w = GetNextItemWidth();
    window->DC.NextItemWidth = backup_next_item_width;
    return w;
}

// [Internal] Calculate full item size given user provided 'size' parameter and default width/height. Default width is often == GetNextItemWidth().
// Those two functions CalcItemWidth vs CalcItemSize are awkwardly named because they are not fully symmetrical.
// Note that only CalcItemWidth() is publicly exposed.
// The 4.0f here may be changed to match GetNextItemWidth() and/or BeginChild() (right now we have a mismatch which is harmless but undesirable)
ImVec2 ImGui::CalcItemSize(ImVec2 size, float default_w, float default_h)
{
    ImGuiWindow* window = GImGui->CurrentWindow;

    ImVec2 region_max;
    if (size.x < 0.0f || size.y < 0.0f)
        region_max = GetWorkRectMax();

    if (size.x == 0.0f)
        size.x = default_w;
    else if (size.x < 0.0f)
        size.x = ImMax(4.0f, region_max.x - window->DC.CursorPos.x + size.x);

    if (size.y == 0.0f)
        size.y = default_h;
    else if (size.y < 0.0f)
        size.y = ImMax(4.0f, region_max.y - window->DC.CursorPos.y + size.y);

    return size;
}

void ImGui::SetCurrentFont(ImFont* font)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(font && font->IsLoaded());    // Font Atlas not created. Did you call io.Fonts->GetTexDataAsRGBA32 / GetTexDataAsAlpha8 ?
    IM_ASSERT(font->Scale > 0.0f);
    g.Font = font;
    g.FontBaseSize = ImMax(1.0f, g.IO.FontGlobalScale * g.Font->FontSize * g.Font->Scale);
    g.FontSize = g.CurrentWindow ? g.CurrentWindow->CalcFontSize() : 0.0f;

    ImFontAtlas* atlas = g.Font->ContainerAtlas;
    g.DrawListSharedData.TexUvWhitePixel = atlas->TexUvWhitePixel;
    g.DrawListSharedData.Font = g.Font;
    g.DrawListSharedData.FontSize = g.FontSize;
}

void ImGui::PushFont(ImFont* font)
{
    ImGuiContext& g = *GImGui;
    if (!font)
        font = GetDefaultFont();
    SetCurrentFont(font);
    g.FontStack.push_back(font);
    g.CurrentWindow->DrawList->PushTextureID(font->ContainerAtlas->TexID);
}

void  ImGui::PopFont()
{
    ImGuiContext& g = *GImGui;
    g.CurrentWindow->DrawList->PopTextureID();
    g.FontStack.pop_back();
    SetCurrentFont(g.FontStack.empty() ? GetDefaultFont() : g.FontStack.back());
}

void ImGui::PushItemFlag(ImGuiItemFlags option, bool enabled)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (enabled)
        window->DC.ItemFlags |= option;
    else
        window->DC.ItemFlags &= ~option;
    window->DC.ItemFlagsStack.push_back(window->DC.ItemFlags);
}

void ImGui::PopItemFlag()
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.ItemFlagsStack.pop_back();
    window->DC.ItemFlags = window->DC.ItemFlagsStack.empty() ? ImGuiItemFlags_Default_ : window->DC.ItemFlagsStack.back();
}

// FIXME: Look into renaming this once we have settled the new Focus/Activation/TabStop system.
void ImGui::PushAllowKeyboardFocus(bool allow_keyboard_focus)
{
    PushItemFlag(ImGuiItemFlags_NoTabStop, !allow_keyboard_focus);
}

void ImGui::PopAllowKeyboardFocus()
{
    PopItemFlag();
}

void ImGui::PushButtonRepeat(bool repeat)
{
    PushItemFlag(ImGuiItemFlags_ButtonRepeat, repeat);
}

void ImGui::PopButtonRepeat()
{
    PopItemFlag();
}

void ImGui::PushTextWrapPos(float wrap_pos_x)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.TextWrapPos = wrap_pos_x;
    window->DC.TextWrapPosStack.push_back(wrap_pos_x);
}

void ImGui::PopTextWrapPos()
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.TextWrapPosStack.pop_back();
    window->DC.TextWrapPos = window->DC.TextWrapPosStack.empty() ? -1.0f : window->DC.TextWrapPosStack.back();
}

// FIXME: This may incur a round-trip (if the end user got their data from a float4) but eventually we aim to store the in-flight colors as ImU32
void ImGui::PushStyleColor(ImGuiCol idx, ImU32 col)
{
    ImGuiContext& g = *GImGui;
    ImGuiColorMod backup;
    backup.Col = idx;
    backup.BackupValue = g.Style.Colors[idx];
    g.ColorModifiers.push_back(backup);
    g.Style.Colors[idx] = ColorConvertU32ToFloat4(col);
}

void ImGui::PushStyleColor(ImGuiCol idx, const ImVec4& col)
{
    ImGuiContext& g = *GImGui;
    ImGuiColorMod backup;
    backup.Col = idx;
    backup.BackupValue = g.Style.Colors[idx];
    g.ColorModifiers.push_back(backup);
    g.Style.Colors[idx] = col;
}

void ImGui::PopStyleColor(int count)
{
    ImGuiContext& g = *GImGui;
    while (count > 0)
    {
        ImGuiColorMod& backup = g.ColorModifiers.back();
        g.Style.Colors[backup.Col] = backup.BackupValue;
        g.ColorModifiers.pop_back();
        count--;
    }
}

struct ImGuiStyleVarInfo
{
    ImGuiDataType   Type;
    ImU32           Count;
    ImU32           Offset;
    void*           GetVarPtr(ImGuiStyle* style) const { return (void*)((unsigned char*)style + Offset); }
};

static const ImGuiStyleVarInfo GStyleVarInfo[] =
{
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, Alpha) },               // ImGuiStyleVar_Alpha
    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, WindowPadding) },       // ImGuiStyleVar_WindowPadding
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, WindowRounding) },      // ImGuiStyleVar_WindowRounding
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, WindowBorderSize) },    // ImGuiStyleVar_WindowBorderSize
    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, WindowMinSize) },       // ImGuiStyleVar_WindowMinSize
    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, WindowTitleAlign) },    // ImGuiStyleVar_WindowTitleAlign
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, ChildRounding) },       // ImGuiStyleVar_ChildRounding
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, ChildBorderSize) },     // ImGuiStyleVar_ChildBorderSize
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, PopupRounding) },       // ImGuiStyleVar_PopupRounding
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, PopupBorderSize) },     // ImGuiStyleVar_PopupBorderSize
    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, FramePadding) },        // ImGuiStyleVar_FramePadding
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, FrameRounding) },       // ImGuiStyleVar_FrameRounding
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, FrameBorderSize) },     // ImGuiStyleVar_FrameBorderSize
    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, ItemSpacing) },         // ImGuiStyleVar_ItemSpacing
    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, ItemInnerSpacing) },    // ImGuiStyleVar_ItemInnerSpacing
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, IndentSpacing) },       // ImGuiStyleVar_IndentSpacing
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, ScrollbarSize) },       // ImGuiStyleVar_ScrollbarSize
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, ScrollbarRounding) },   // ImGuiStyleVar_ScrollbarRounding
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, GrabMinSize) },         // ImGuiStyleVar_GrabMinSize
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, GrabRounding) },        // ImGuiStyleVar_GrabRounding
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, TabRounding) },         // ImGuiStyleVar_TabRounding
    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, ButtonTextAlign) },     // ImGuiStyleVar_ButtonTextAlign
    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, SelectableTextAlign) }, // ImGuiStyleVar_SelectableTextAlign
};

static const ImGuiStyleVarInfo* GetStyleVarInfo(ImGuiStyleVar idx)
{
    IM_ASSERT(idx >= 0 && idx < ImGuiStyleVar_COUNT);
    IM_ASSERT(IM_ARRAYSIZE(GStyleVarInfo) == ImGuiStyleVar_COUNT);
    return &GStyleVarInfo[idx];
}

void ImGui::PushStyleVar(ImGuiStyleVar idx, float val)
{
    const ImGuiStyleVarInfo* var_info = GetStyleVarInfo(idx);
    if (var_info->Type == ImGuiDataType_Float && var_info->Count == 1)
    {
        ImGuiContext& g = *GImGui;
        float* pvar = (float*)var_info->GetVarPtr(&g.Style);
        g.StyleModifiers.push_back(ImGuiStyleMod(idx, *pvar));
        *pvar = val;
        return;
    }
    IM_ASSERT(0 && "Called PushStyleVar() float variant but variable is not a float!");
}

void ImGui::PushStyleVar(ImGuiStyleVar idx, const ImVec2& val)
{
    const ImGuiStyleVarInfo* var_info = GetStyleVarInfo(idx);
    if (var_info->Type == ImGuiDataType_Float && var_info->Count == 2)
    {
        ImGuiContext& g = *GImGui;
        ImVec2* pvar = (ImVec2*)var_info->GetVarPtr(&g.Style);
        g.StyleModifiers.push_back(ImGuiStyleMod(idx, *pvar));
        *pvar = val;
        return;
    }
    IM_ASSERT(0 && "Called PushStyleVar() ImVec2 variant but variable is not a ImVec2!");
}

void ImGui::PopStyleVar(int count)
{
    ImGuiContext& g = *GImGui;
    while (count > 0)
    {
        // We avoid a generic memcpy(data, &backup.Backup.., GDataTypeSize[info->Type] * info->Count), the overhead in Debug is not worth it.
        ImGuiStyleMod& backup = g.StyleModifiers.back();
        const ImGuiStyleVarInfo* info = GetStyleVarInfo(backup.VarIdx);
        void* data = info->GetVarPtr(&g.Style);
        if (info->Type == ImGuiDataType_Float && info->Count == 1)      { ((float*)data)[0] = backup.BackupFloat[0]; }
        else if (info->Type == ImGuiDataType_Float && info->Count == 2) { ((float*)data)[0] = backup.BackupFloat[0]; ((float*)data)[1] = backup.BackupFloat[1]; }
        g.StyleModifiers.pop_back();
        count--;
    }
}

const char* ImGui::GetStyleColorName(ImGuiCol idx)
{
    // Create switch-case from enum with regexp: ImGuiCol_{.*}, --> case ImGuiCol_\1: return "\1";
    switch (idx)
    {
    case ImGuiCol_Text: return "Text";
    case ImGuiCol_TextDisabled: return "TextDisabled";
    case ImGuiCol_WindowBg: return "WindowBg";
    case ImGuiCol_ChildBg: return "ChildBg";
    case ImGuiCol_PopupBg: return "PopupBg";
    case ImGuiCol_Border: return "Border";
    case ImGuiCol_BorderShadow: return "BorderShadow";
    case ImGuiCol_FrameBg: return "FrameBg";
    case ImGuiCol_FrameBgHovered: return "FrameBgHovered";
    case ImGuiCol_FrameBgActive: return "FrameBgActive";
    case ImGuiCol_TitleBg: return "TitleBg";
    case ImGuiCol_TitleBgActive: return "TitleBgActive";
    case ImGuiCol_TitleBgCollapsed: return "TitleBgCollapsed";
    case ImGuiCol_MenuBarBg: return "MenuBarBg";
    case ImGuiCol_ScrollbarBg: return "ScrollbarBg";
    case ImGuiCol_ScrollbarGrab: return "ScrollbarGrab";
    case ImGuiCol_ScrollbarGrabHovered: return "ScrollbarGrabHovered";
    case ImGuiCol_ScrollbarGrabActive: return "ScrollbarGrabActive";
    case ImGuiCol_CheckMark: return "CheckMark";
    case ImGuiCol_SliderGrab: return "SliderGrab";
    case ImGuiCol_SliderGrabActive: return "SliderGrabActive";
    case ImGuiCol_Button: return "Button";
    case ImGuiCol_ButtonHovered: return "ButtonHovered";
    case ImGuiCol_ButtonActive: return "ButtonActive";
    case ImGuiCol_Header: return "Header";
    case ImGuiCol_HeaderHovered: return "HeaderHovered";
    case ImGuiCol_HeaderActive: return "HeaderActive";
    case ImGuiCol_Separator: return "Separator";
    case ImGuiCol_SeparatorHovered: return "SeparatorHovered";
    case ImGuiCol_SeparatorActive: return "SeparatorActive";
    case ImGuiCol_ResizeGrip: return "ResizeGrip";
    case ImGuiCol_ResizeGripHovered: return "ResizeGripHovered";
    case ImGuiCol_ResizeGripActive: return "ResizeGripActive";
    case ImGuiCol_Tab: return "Tab";
    case ImGuiCol_TabHovered: return "TabHovered";
    case ImGuiCol_TabActive: return "TabActive";
    case ImGuiCol_TabUnfocused: return "TabUnfocused";
    case ImGuiCol_TabUnfocusedActive: return "TabUnfocusedActive";
    case ImGuiCol_PlotLines: return "PlotLines";
    case ImGuiCol_PlotLinesHovered: return "PlotLinesHovered";
    case ImGuiCol_PlotHistogram: return "PlotHistogram";
    case ImGuiCol_PlotHistogramHovered: return "PlotHistogramHovered";
    case ImGuiCol_TextSelectedBg: return "TextSelectedBg";
    case ImGuiCol_DragDropTarget: return "DragDropTarget";
    case ImGuiCol_NavHighlight: return "NavHighlight";
    case ImGuiCol_NavWindowingHighlight: return "NavWindowingHighlight";
    case ImGuiCol_NavWindowingDimBg: return "NavWindowingDimBg";
    case ImGuiCol_ModalWindowDimBg: return "ModalWindowDimBg";
    }
    IM_ASSERT(0);
    return "Unknown";
}

bool ImGui::IsWindowChildOf(ImGuiWindow* window, ImGuiWindow* potential_parent)
{
    if (window->RootWindow == potential_parent)
        return true;
    while (window != NULL)
    {
        if (window == potential_parent)
            return true;
        window = window->ParentWindow;
    }
    return false;
}

bool ImGui::IsWindowHovered(ImGuiHoveredFlags flags)
{
    IM_ASSERT((flags & ImGuiHoveredFlags_AllowWhenOverlapped) == 0);   // Flags not supported by this function
    ImGuiContext& g = *GImGui;

    if (flags & ImGuiHoveredFlags_AnyWindow)
    {
        if (g.HoveredWindow == NULL)
            return false;
    }
    else
    {
        switch (flags & (ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows))
        {
        case ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows:
            if (g.HoveredRootWindow != g.CurrentWindow->RootWindow)
                return false;
            break;
        case ImGuiHoveredFlags_RootWindow:
            if (g.HoveredWindow != g.CurrentWindow->RootWindow)
                return false;
            break;
        case ImGuiHoveredFlags_ChildWindows:
            if (g.HoveredWindow == NULL || !IsWindowChildOf(g.HoveredWindow, g.CurrentWindow))
                return false;
            break;
        default:
            if (g.HoveredWindow != g.CurrentWindow)
                return false;
            break;
        }
    }

    if (!IsWindowContentHoverable(g.HoveredWindow, flags))
        return false;
    if (!(flags & ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))
        if (g.ActiveId != 0 && !g.ActiveIdAllowOverlap && g.ActiveId != g.HoveredWindow->MoveId)
            return false;
    return true;
}

bool ImGui::IsWindowFocused(ImGuiFocusedFlags flags)
{
    ImGuiContext& g = *GImGui;

    if (flags & ImGuiFocusedFlags_AnyWindow)
        return g.NavWindow != NULL;

    IM_ASSERT(g.CurrentWindow);     // Not inside a Begin()/End()
    switch (flags & (ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_ChildWindows))
    {
    case ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_ChildWindows:
        return g.NavWindow && g.NavWindow->RootWindow == g.CurrentWindow->RootWindow;
    case ImGuiFocusedFlags_RootWindow:
        return g.NavWindow == g.CurrentWindow->RootWindow;
    case ImGuiFocusedFlags_ChildWindows:
        return g.NavWindow && IsWindowChildOf(g.NavWindow, g.CurrentWindow);
    default:
        return g.NavWindow == g.CurrentWindow;
    }
}

// Can we focus this window with CTRL+TAB (or PadMenu + PadFocusPrev/PadFocusNext)
// Note that NoNavFocus makes the window not reachable with CTRL+TAB but it can still be focused with mouse or programmaticaly.
// If you want a window to never be focused, you may use the e.g. NoInputs flag.
bool ImGui::IsWindowNavFocusable(ImGuiWindow* window)
{
    return window->Active && window == window->RootWindow && !(window->Flags & ImGuiWindowFlags_NoNavFocus);
}

float ImGui::GetWindowWidth()
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->Size.x;
}

float ImGui::GetWindowHeight()
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->Size.y;
}

ImVec2 ImGui::GetWindowPos()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    return window->Pos;
}

void ImGui::SetWindowScrollX(ImGuiWindow* window, float new_scroll_x)
{
    window->DC.CursorMaxPos.x += window->Scroll.x; // SizeContents is generally computed based on CursorMaxPos which is affected by scroll position, so we need to apply our change to it.
    window->Scroll.x = new_scroll_x;
    window->DC.CursorMaxPos.x -= window->Scroll.x;
}

void ImGui::SetWindowScrollY(ImGuiWindow* window, float new_scroll_y)
{
    window->DC.CursorMaxPos.y += window->Scroll.y; // SizeContents is generally computed based on CursorMaxPos which is affected by scroll position, so we need to apply our change to it.
    window->Scroll.y = new_scroll_y;
    window->DC.CursorMaxPos.y -= window->Scroll.y;
}

void ImGui::SetWindowPos(ImGuiWindow* window, const ImVec2& pos, ImGuiCond cond)
{
    // Test condition (NB: bit 0 is always true) and clear flags for next time
    if (cond && (window->SetWindowPosAllowFlags & cond) == 0)
        return;

    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    window->SetWindowPosAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);
    window->SetWindowPosVal = ImVec2(FLT_MAX, FLT_MAX);

    // Set
    const ImVec2 old_pos = window->Pos;
    window->Pos = ImFloor(pos);
    window->DC.CursorPos += (window->Pos - old_pos);    // As we happen to move the window while it is being appended to (which is a bad idea - will smear) let's at least offset the cursor
    window->DC.CursorMaxPos += (window->Pos - old_pos); // And more importantly we need to adjust this so size calculation doesn't get affected.
}

void ImGui::SetWindowPos(const ImVec2& pos, ImGuiCond cond)
{
    ImGuiWindow* window = GetCurrentWindowRead();
    SetWindowPos(window, pos, cond);
}

void ImGui::SetWindowPos(const char* name, const ImVec2& pos, ImGuiCond cond)
{
    if (ImGuiWindow* window = FindWindowByName(name))
        SetWindowPos(window, pos, cond);
}

ImVec2 ImGui::GetWindowSize()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->Size;
}

void ImGui::SetWindowSize(ImGuiWindow* window, const ImVec2& size, ImGuiCond cond)
{
    // Test condition (NB: bit 0 is always true) and clear flags for next time
    if (cond && (window->SetWindowSizeAllowFlags & cond) == 0)
        return;

    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    window->SetWindowSizeAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);

    // Set
    if (size.x > 0.0f)
    {
        window->AutoFitFramesX = 0;
        window->SizeFull.x = ImFloor(size.x);
    }
    else
    {
        window->AutoFitFramesX = 2;
        window->AutoFitOnlyGrows = false;
    }
    if (size.y > 0.0f)
    {
        window->AutoFitFramesY = 0;
        window->SizeFull.y = ImFloor(size.y);
    }
    else
    {
        window->AutoFitFramesY = 2;
        window->AutoFitOnlyGrows = false;
    }
}

void ImGui::SetWindowSize(const ImVec2& size, ImGuiCond cond)
{
    SetWindowSize(GImGui->CurrentWindow, size, cond);
}

void ImGui::SetWindowSize(const char* name, const ImVec2& size, ImGuiCond cond)
{
    if (ImGuiWindow* window = FindWindowByName(name))
        SetWindowSize(window, size, cond);
}

void ImGui::SetWindowCollapsed(ImGuiWindow* window, bool collapsed, ImGuiCond cond)
{
    // Test condition (NB: bit 0 is always true) and clear flags for next time
    if (cond && (window->SetWindowCollapsedAllowFlags & cond) == 0)
        return;
    window->SetWindowCollapsedAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);

    // Set
    window->Collapsed = collapsed;
}

void ImGui::SetWindowCollapsed(bool collapsed, ImGuiCond cond)
{
    SetWindowCollapsed(GImGui->CurrentWindow, collapsed, cond);
}

bool ImGui::IsWindowCollapsed()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->Collapsed;
}

bool ImGui::IsWindowAppearing()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->Appearing;
}

void ImGui::SetWindowCollapsed(const char* name, bool collapsed, ImGuiCond cond)
{
    if (ImGuiWindow* window = FindWindowByName(name))
        SetWindowCollapsed(window, collapsed, cond);
}

void ImGui::SetWindowFocus()
{
    FocusWindow(GImGui->CurrentWindow);
}

void ImGui::SetWindowFocus(const char* name)
{
    if (name)
    {
        if (ImGuiWindow* window = FindWindowByName(name))
            FocusWindow(window);
    }
    else
    {
        FocusWindow(NULL);
    }
}

void ImGui::SetNextWindowPos(const ImVec2& pos, ImGuiCond cond, const ImVec2& pivot)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    g.NextWindowData.PosVal = pos;
    g.NextWindowData.PosPivotVal = pivot;
    g.NextWindowData.PosCond = cond ? cond : ImGuiCond_Always;
}

void ImGui::SetNextWindowSize(const ImVec2& size, ImGuiCond cond)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    g.NextWindowData.SizeVal = size;
    g.NextWindowData.SizeCond = cond ? cond : ImGuiCond_Always;
}

void ImGui::SetNextWindowSizeConstraints(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeCallback custom_callback, void* custom_callback_user_data)
{
    ImGuiContext& g = *GImGui;
    g.NextWindowData.SizeConstraintCond = ImGuiCond_Always;
    g.NextWindowData.SizeConstraintRect = ImRect(size_min, size_max);
    g.NextWindowData.SizeCallback = custom_callback;
    g.NextWindowData.SizeCallbackUserData = custom_callback_user_data;
}

void ImGui::SetNextWindowContentSize(const ImVec2& size)
{
    ImGuiContext& g = *GImGui;
    g.NextWindowData.ContentSizeVal = size;  // In Begin() we will add the size of window decorations (title bar, menu etc.) to that to form a SizeContents value.
    g.NextWindowData.ContentSizeCond = ImGuiCond_Always;
}

void ImGui::SetNextWindowCollapsed(bool collapsed, ImGuiCond cond)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    g.NextWindowData.CollapsedVal = collapsed;
    g.NextWindowData.CollapsedCond = cond ? cond : ImGuiCond_Always;
}

void ImGui::SetNextWindowFocus()
{
    ImGuiContext& g = *GImGui;
    g.NextWindowData.FocusCond = ImGuiCond_Always;   // Using a Cond member for consistency (may transition all of them to single flag set for fast Clear() op)
}

void ImGui::SetNextWindowBgAlpha(float alpha)
{
    ImGuiContext& g = *GImGui;
    g.NextWindowData.BgAlphaVal = alpha;
    g.NextWindowData.BgAlphaCond = ImGuiCond_Always; // Using a Cond member for consistency (may transition all of them to single flag set for fast Clear() op)
}

// FIXME: This is in window space (not screen space!). We should try to obsolete all those functions.
ImVec2 ImGui::GetContentRegionMax()
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    ImVec2 mx = window->ContentsRegionRect.Max - window->Pos;
    if (window->DC.CurrentColumns)
        mx.x = GetColumnOffset(window->DC.CurrentColumns->Current + 1) - window->WindowPadding.x;
    return mx;
}

// [Internal] Absolute coordinate. Saner. This is not exposed until we finishing refactoring work rect features.
ImVec2 ImGui::GetWorkRectMax()
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    ImVec2 mx = window->ContentsRegionRect.Max;
    if (window->DC.CurrentColumns)
        mx.x = window->Pos.x + GetColumnOffset(window->DC.CurrentColumns->Current + 1) - window->WindowPadding.x;
    return mx;
}

ImVec2 ImGui::GetContentRegionAvail()
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return GetWorkRectMax() - window->DC.CursorPos;
}

// In window space (not screen space!)
ImVec2 ImGui::GetWindowContentRegionMin()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->ContentsRegionRect.Min - window->Pos;
}

ImVec2 ImGui::GetWindowContentRegionMax()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->ContentsRegionRect.Max - window->Pos;
}

float ImGui::GetWindowContentRegionWidth()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->ContentsRegionRect.GetWidth();
}

float ImGui::GetTextLineHeight()
{
    ImGuiContext& g = *GImGui;
    return g.FontSize;
}

float ImGui::GetTextLineHeightWithSpacing()
{
    ImGuiContext& g = *GImGui;
    return g.FontSize + g.Style.ItemSpacing.y;
}

float ImGui::GetFrameHeight()
{
    ImGuiContext& g = *GImGui;
    return g.FontSize + g.Style.FramePadding.y * 2.0f;
}

float ImGui::GetFrameHeightWithSpacing()
{
    ImGuiContext& g = *GImGui;
    return g.FontSize + g.Style.FramePadding.y * 2.0f + g.Style.ItemSpacing.y;
}

ImDrawList* ImGui::GetWindowDrawList()
{
    ImGuiWindow* window = GetCurrentWindow();
    return window->DrawList;
}

ImFont* ImGui::GetFont()
{
    return GImGui->Font;
}

float ImGui::GetFontSize()
{
    return GImGui->FontSize;
}

ImVec2 ImGui::GetFontTexUvWhitePixel()
{
    return GImGui->DrawListSharedData.TexUvWhitePixel;
}

void ImGui::SetWindowFontScale(float scale)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();
    window->FontWindowScale = scale;
    g.FontSize = g.DrawListSharedData.FontSize = window->CalcFontSize();
}

// User generally sees positions in window coordinates. Internally we store CursorPos in absolute screen coordinates because it is more convenient.
// Conversion happens as we pass the value to user, but it makes our naming convention confusing because GetCursorPos() == (DC.CursorPos - window.Pos). May want to rename 'DC.CursorPos'.
ImVec2 ImGui::GetCursorPos()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.CursorPos - window->Pos + window->Scroll;
}

float ImGui::GetCursorPosX()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.CursorPos.x - window->Pos.x + window->Scroll.x;
}

float ImGui::GetCursorPosY()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.CursorPos.y - window->Pos.y + window->Scroll.y;
}

void ImGui::SetCursorPos(const ImVec2& local_pos)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.CursorPos = window->Pos - window->Scroll + local_pos;
    window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, window->DC.CursorPos);
}

void ImGui::SetCursorPosX(float x)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + x;
    window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPos.x);
}

void ImGui::SetCursorPosY(float y)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.CursorPos.y = window->Pos.y - window->Scroll.y + y;
    window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, window->DC.CursorPos.y);
}

ImVec2 ImGui::GetCursorStartPos()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.CursorStartPos - window->Pos;
}

ImVec2 ImGui::GetCursorScreenPos()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.CursorPos;
}

void ImGui::SetCursorScreenPos(const ImVec2& pos)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.CursorPos = pos;
    window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, window->DC.CursorPos);
}

float ImGui::GetScrollX()
{
    return GImGui->CurrentWindow->Scroll.x;
}

float ImGui::GetScrollY()
{
    return GImGui->CurrentWindow->Scroll.y;
}

float ImGui::GetScrollMaxX()
{
    return GetWindowScrollMaxX(GImGui->CurrentWindow);
}

float ImGui::GetScrollMaxY()
{
    return GetWindowScrollMaxY(GImGui->CurrentWindow);
}

void ImGui::SetScrollX(float scroll_x)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->ScrollTarget.x = scroll_x;
    window->ScrollTargetCenterRatio.x = 0.0f;
}

void ImGui::SetScrollY(float scroll_y)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->ScrollTarget.y = scroll_y + window->TitleBarHeight() + window->MenuBarHeight(); // title bar height canceled out when using ScrollTargetRelY
    window->ScrollTargetCenterRatio.y = 0.0f;
}

void ImGui::SetScrollFromPosY(float local_y, float center_y_ratio)
{
    // We store a target position so centering can occur on the next frame when we are guaranteed to have a known window size
    ImGuiWindow* window = GetCurrentWindow();
    IM_ASSERT(center_y_ratio >= 0.0f && center_y_ratio <= 1.0f);
    window->ScrollTarget.y = (float)(int)(local_y + window->Scroll.y);
    window->ScrollTargetCenterRatio.y = center_y_ratio;
}

// center_y_ratio: 0.0f top of last item, 0.5f vertical center of last item, 1.0f bottom of last item.
void ImGui::SetScrollHereY(float center_y_ratio)
{
    ImGuiWindow* window = GetCurrentWindow();
    float target_y = window->DC.CursorPosPrevLine.y - window->Pos.y; // Top of last item, in window space
    target_y += (window->DC.PrevLineSize.y * center_y_ratio) + (GImGui->Style.ItemSpacing.y * (center_y_ratio - 0.5f) * 2.0f); // Precisely aim above, in the middle or below the last line.
    SetScrollFromPosY(target_y, center_y_ratio);
}

void ImGui::ActivateItem(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    g.NavNextActivateId = id;
}

void ImGui::SetKeyboardFocusHere(int offset)
{
    IM_ASSERT(offset >= -1);    // -1 is allowed but not below
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    g.FocusRequestNextWindow = window;
    g.FocusRequestNextCounterAll = window->DC.FocusCounterAll + 1 + offset;
    g.FocusRequestNextCounterTab = INT_MAX;
}

void ImGui::SetItemDefaultFocus()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (!window->Appearing)
        return;
    if (g.NavWindow == window->RootWindowForNav && (g.NavInitRequest || g.NavInitResultId != 0) && g.NavLayer == g.NavWindow->DC.NavLayerCurrent)
    {
        g.NavInitRequest = false;
        g.NavInitResultId = g.NavWindow->DC.LastItemId;
        g.NavInitResultRectRel = ImRect(g.NavWindow->DC.LastItemRect.Min - g.NavWindow->Pos, g.NavWindow->DC.LastItemRect.Max - g.NavWindow->Pos);
        NavUpdateAnyRequestFlag();
        if (!IsItemVisible())
            SetScrollHereY();
    }
}

void ImGui::SetStateStorage(ImGuiStorage* tree)
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    window->DC.StateStorage = tree ? tree : &window->StateStorage;
}

ImGuiStorage* ImGui::GetStateStorage()
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->DC.StateStorage;
}

void ImGui::PushID(const char* str_id)
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    window->IDStack.push_back(window->GetIDNoKeepAlive(str_id));
}

void ImGui::PushID(const char* str_id_begin, const char* str_id_end)
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    window->IDStack.push_back(window->GetIDNoKeepAlive(str_id_begin, str_id_end));
}

void ImGui::PushID(const void* ptr_id)
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    window->IDStack.push_back(window->GetIDNoKeepAlive(ptr_id));
}

void ImGui::PushID(int int_id)
{
    const void* ptr_id = (void*)(intptr_t)int_id;
    ImGuiWindow* window = GImGui->CurrentWindow;
    window->IDStack.push_back(window->GetIDNoKeepAlive(ptr_id));
}

// Push a given id value ignoring the ID stack as a seed.
void ImGui::PushOverrideID(ImGuiID id)
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    window->IDStack.push_back(id);
}

void ImGui::PopID()
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    window->IDStack.pop_back();
}

ImGuiID ImGui::GetID(const char* str_id)
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->GetID(str_id);
}

ImGuiID ImGui::GetID(const char* str_id_begin, const char* str_id_end)
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->GetID(str_id_begin, str_id_end);
}

ImGuiID ImGui::GetID(const void* ptr_id)
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->GetID(ptr_id);
}

bool ImGui::IsRectVisible(const ImVec2& size)
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->ClipRect.Overlaps(ImRect(window->DC.CursorPos, window->DC.CursorPos + size));
}

bool ImGui::IsRectVisible(const ImVec2& rect_min, const ImVec2& rect_max)
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->ClipRect.Overlaps(ImRect(rect_min, rect_max));
}

// Lock horizontal starting position + capture group bounding box into one "item" (so you can use IsItemHovered() or layout primitives such as SameLine() on whole group, etc.)
void ImGui::BeginGroup()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();

    window->DC.GroupStack.resize(window->DC.GroupStack.Size + 1);
    ImGuiGroupData& group_data = window->DC.GroupStack.back();
    group_data.BackupCursorPos = window->DC.CursorPos;
    group_data.BackupCursorMaxPos = window->DC.CursorMaxPos;
    group_data.BackupIndent = window->DC.Indent;
    group_data.BackupGroupOffset = window->DC.GroupOffset;
    group_data.BackupCurrentLineSize = window->DC.CurrentLineSize;
    group_data.BackupCurrentLineTextBaseOffset = window->DC.CurrentLineTextBaseOffset;
    group_data.BackupActiveIdIsAlive = g.ActiveIdIsAlive;
    group_data.BackupActiveIdPreviousFrameIsAlive = g.ActiveIdPreviousFrameIsAlive;
    group_data.AdvanceCursor = true;

    window->DC.GroupOffset.x = window->DC.CursorPos.x - window->Pos.x - window->DC.ColumnsOffset.x;
    window->DC.Indent = window->DC.GroupOffset;
    window->DC.CursorMaxPos = window->DC.CursorPos;
    window->DC.CurrentLineSize = ImVec2(0.0f, 0.0f);
    if (g.LogEnabled)
        g.LogLinePosY = -FLT_MAX; // To enforce Log carriage return
}

void ImGui::EndGroup()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();
    IM_ASSERT(!window->DC.GroupStack.empty());  // Mismatched BeginGroup()/EndGroup() calls

    ImGuiGroupData& group_data = window->DC.GroupStack.back();

    ImRect group_bb(group_data.BackupCursorPos, window->DC.CursorMaxPos);
    group_bb.Max = ImMax(group_bb.Min, group_bb.Max);

    window->DC.CursorPos = group_data.BackupCursorPos;
    window->DC.CursorMaxPos = ImMax(group_data.BackupCursorMaxPos, window->DC.CursorMaxPos);
    window->DC.Indent = group_data.BackupIndent;
    window->DC.GroupOffset = group_data.BackupGroupOffset;
    window->DC.CurrentLineSize = group_data.BackupCurrentLineSize;
    window->DC.CurrentLineTextBaseOffset = group_data.BackupCurrentLineTextBaseOffset;
    if (g.LogEnabled)
        g.LogLinePosY = -FLT_MAX; // To enforce Log carriage return

    if (group_data.AdvanceCursor)
    {
        window->DC.CurrentLineTextBaseOffset = ImMax(window->DC.PrevLineTextBaseOffset, group_data.BackupCurrentLineTextBaseOffset);      // FIXME: Incorrect, we should grab the base offset from the *first line* of the group but it is hard to obtain now.
        ItemSize(group_bb.GetSize(), 0.0f);
        ItemAdd(group_bb, 0);
    }

    // If the current ActiveId was declared within the boundary of our group, we copy it to LastItemId so IsItemActive(), IsItemDeactivated() etc. will be functional on the entire group.
    // It would be be neater if we replaced window.DC.LastItemId by e.g. 'bool LastItemIsActive', but would put a little more burden on individual widgets.
    // (and if you grep for LastItemId you'll notice it is only used in that context.
    if ((group_data.BackupActiveIdIsAlive != g.ActiveId) && (g.ActiveIdIsAlive == g.ActiveId) && g.ActiveId) // && g.ActiveIdWindow->RootWindow == window->RootWindow)
        window->DC.LastItemId = g.ActiveId;
    else if (!group_data.BackupActiveIdPreviousFrameIsAlive && g.ActiveIdPreviousFrameIsAlive) // && g.ActiveIdPreviousFrameWindow->RootWindow == window->RootWindow)
        window->DC.LastItemId = g.ActiveIdPreviousFrame;
    window->DC.LastItemRect = group_bb;

    window->DC.GroupStack.pop_back();

    //window->DrawList->AddRect(group_bb.Min, group_bb.Max, IM_COL32(255,0,255,255));   // [Debug]
}

// Gets back to previous line and continue with horizontal layout
//      offset_from_start_x == 0 : follow right after previous item
//      offset_from_start_x != 0 : align to specified x position (relative to window/group left)
//      spacing_w < 0            : use default spacing if pos_x == 0, no spacing if pos_x != 0
//      spacing_w >= 0           : enforce spacing amount
void ImGui::SameLine(float offset_from_start_x, float spacing_w)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImGuiContext& g = *GImGui;
    if (offset_from_start_x != 0.0f)
    {
        if (spacing_w < 0.0f) spacing_w = 0.0f;
        window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + offset_from_start_x + spacing_w + window->DC.GroupOffset.x + window->DC.ColumnsOffset.x;
        window->DC.CursorPos.y = window->DC.CursorPosPrevLine.y;
    }
    else
    {
        if (spacing_w < 0.0f) spacing_w = g.Style.ItemSpacing.x;
        window->DC.CursorPos.x = window->DC.CursorPosPrevLine.x + spacing_w;
        window->DC.CursorPos.y = window->DC.CursorPosPrevLine.y;
    }
    window->DC.CurrentLineSize = window->DC.PrevLineSize;
    window->DC.CurrentLineTextBaseOffset = window->DC.PrevLineTextBaseOffset;
}

void ImGui::Indent(float indent_w)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.Indent.x += (indent_w != 0.0f) ? indent_w : g.Style.IndentSpacing;
    window->DC.CursorPos.x = window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x;
}

void ImGui::Unindent(float indent_w)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.Indent.x -= (indent_w != 0.0f) ? indent_w : g.Style.IndentSpacing;
    window->DC.CursorPos.x = window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x;
}

//-----------------------------------------------------------------------------
// [SECTION] TOOLTIPS
//-----------------------------------------------------------------------------

void ImGui::BeginTooltip()
{
    ImGuiContext& g = *GImGui;
    if (g.DragDropWithinSourceOrTarget)
    {
        // The default tooltip position is a little offset to give space to see the context menu (it's also clamped within the current viewport/monitor)
        // In the context of a dragging tooltip we try to reduce that offset and we enforce following the cursor.
        // Whatever we do we want to call SetNextWindowPos() to enforce a tooltip position and disable clipping the tooltip without our display area, like regular tooltip do.
        //ImVec2 tooltip_pos = g.IO.MousePos - g.ActiveIdClickOffset - g.Style.WindowPadding;
        ImVec2 tooltip_pos = g.IO.MousePos + ImVec2(16 * g.Style.MouseCursorScale, 8 * g.Style.MouseCursorScale);
        SetNextWindowPos(tooltip_pos);
        SetNextWindowBgAlpha(g.Style.Colors[ImGuiCol_PopupBg].w * 0.60f);
        //PushStyleVar(ImGuiStyleVar_Alpha, g.Style.Alpha * 0.60f); // This would be nice but e.g ColorButton with checkboard has issue with transparent colors :(
        BeginTooltipEx(0, true);
    }
    else
    {
        BeginTooltipEx(0, false);
    }
}

// Not exposed publicly as BeginTooltip() because bool parameters are evil. Let's see if other needs arise first.
void ImGui::BeginTooltipEx(ImGuiWindowFlags extra_flags, bool override_previous_tooltip)
{
    ImGuiContext& g = *GImGui;
    char window_name[16];
    ImFormatString(window_name, IM_ARRAYSIZE(window_name), "##Tooltip_%02d", g.TooltipOverrideCount);
    if (override_previous_tooltip)
        if (ImGuiWindow* window = FindWindowByName(window_name))
            if (window->Active)
            {
                // Hide previous tooltip from being displayed. We can't easily "reset" the content of a window so we create a new one.
                window->Hidden = true;
                window->HiddenFramesCanSkipItems = 1;
                ImFormatString(window_name, IM_ARRAYSIZE(window_name), "##Tooltip_%02d", ++g.TooltipOverrideCount);
            }
    ImGuiWindowFlags flags = ImGuiWindowFlags_Tooltip|ImGuiWindowFlags_NoInputs|ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoMove|ImGuiWindowFlags_NoResize|ImGuiWindowFlags_NoSavedSettings|ImGuiWindowFlags_AlwaysAutoResize;
    Begin(window_name, NULL, flags | extra_flags);
}

void ImGui::EndTooltip()
{
    IM_ASSERT(GetCurrentWindowRead()->Flags & ImGuiWindowFlags_Tooltip);   // Mismatched BeginTooltip()/EndTooltip() calls
    End();
}

void ImGui::SetTooltipV(const char* fmt, va_list args)
{
    ImGuiContext& g = *GImGui;
    if (g.DragDropWithinSourceOrTarget)
        BeginTooltip();
    else
        BeginTooltipEx(0, true);
    TextV(fmt, args);
    EndTooltip();
}

void ImGui::SetTooltip(const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    SetTooltipV(fmt, args);
    va_end(args);
}

//-----------------------------------------------------------------------------
// [SECTION] POPUPS
//-----------------------------------------------------------------------------

bool ImGui::IsPopupOpen(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    return g.OpenPopupStack.Size > g.BeginPopupStack.Size && g.OpenPopupStack[g.BeginPopupStack.Size].PopupId == id;
}

bool ImGui::IsPopupOpen(const char* str_id)
{
    ImGuiContext& g = *GImGui;
    return g.OpenPopupStack.Size > g.BeginPopupStack.Size && g.OpenPopupStack[g.BeginPopupStack.Size].PopupId == g.CurrentWindow->GetID(str_id);
}

ImGuiWindow* ImGui::GetFrontMostPopupModal()
{
    ImGuiContext& g = *GImGui;
    for (int n = g.OpenPopupStack.Size-1; n >= 0; n--)
        if (ImGuiWindow* popup = g.OpenPopupStack.Data[n].Window)
            if (popup->Flags & ImGuiWindowFlags_Modal)
                return popup;
    return NULL;
}

void ImGui::OpenPopup(const char* str_id)
{
    ImGuiContext& g = *GImGui;
    OpenPopupEx(g.CurrentWindow->GetID(str_id));
}

// Mark popup as open (toggle toward open state).
// Popups are closed when user click outside, or activate a pressable item, or CloseCurrentPopup() is called within a BeginPopup()/EndPopup() block.
// Popup identifiers are relative to the current ID-stack (so OpenPopup and BeginPopup needs to be at the same level).
// One open popup per level of the popup hierarchy (NB: when assigning we reset the Window member of ImGuiPopupRef to NULL)
void ImGui::OpenPopupEx(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* parent_window = g.CurrentWindow;
    int current_stack_size = g.BeginPopupStack.Size;
    ImGuiPopupData popup_ref; // Tagged as new ref as Window will be set back to NULL if we write this into OpenPopupStack.
    popup_ref.PopupId = id;
    popup_ref.Window = NULL;
    popup_ref.SourceWindow = g.NavWindow;
    popup_ref.OpenFrameCount = g.FrameCount;
    popup_ref.OpenParentId = parent_window->IDStack.back();
    popup_ref.OpenPopupPos = NavCalcPreferredRefPos();
    popup_ref.OpenMousePos = IsMousePosValid(&g.IO.MousePos) ? g.IO.MousePos : popup_ref.OpenPopupPos;

    //IMGUI_DEBUG_LOG("OpenPopupEx(0x%08X)\n", g.FrameCount, id);
    if (g.OpenPopupStack.Size < current_stack_size + 1)
    {
        g.OpenPopupStack.push_back(popup_ref);
    }
    else
    {
        // Gently handle the user mistakenly calling OpenPopup() every frame. It is a programming mistake! However, if we were to run the regular code path, the ui
        // would become completely unusable because the popup will always be in hidden-while-calculating-size state _while_ claiming focus. Which would be a very confusing
        // situation for the programmer. Instead, we silently allow the popup to proceed, it will keep reappearing and the programming error will be more obvious to understand.
        if (g.OpenPopupStack[current_stack_size].PopupId == id && g.OpenPopupStack[current_stack_size].OpenFrameCount == g.FrameCount - 1)
        {
            g.OpenPopupStack[current_stack_size].OpenFrameCount = popup_ref.OpenFrameCount;
        }
        else
        {
            // Close child popups if any, then flag popup for open/reopen
            g.OpenPopupStack.resize(current_stack_size + 1);
            g.OpenPopupStack[current_stack_size] = popup_ref;
        }

        // When reopening a popup we first refocus its parent, otherwise if its parent is itself a popup it would get closed by ClosePopupsOverWindow().
        // This is equivalent to what ClosePopupToLevel() does.
        //if (g.OpenPopupStack[current_stack_size].PopupId == id)
        //    FocusWindow(parent_window);
    }
}

bool ImGui::OpenPopupOnItemClick(const char* str_id, int mouse_button)
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    if (IsMouseReleased(mouse_button) && IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))
    {
        ImGuiID id = str_id ? window->GetID(str_id) : window->DC.LastItemId; // If user hasn't passed an ID, we can use the LastItemID. Using LastItemID as a Popup ID won't conflict!
        IM_ASSERT(id != 0);                                                  // You cannot pass a NULL str_id if the last item has no identifier (e.g. a Text() item)
        OpenPopupEx(id);
        return true;
    }
    return false;
}

void ImGui::ClosePopupsOverWindow(ImGuiWindow* ref_window, bool restore_focus_to_window_under_popup)
{
    ImGuiContext& g = *GImGui;
    if (g.OpenPopupStack.empty())
        return;

    // When popups are stacked, clicking on a lower level popups puts focus back to it and close popups above it.
    // Don't close our own child popup windows.
    int popup_count_to_keep = 0;
    if (ref_window)
    {
        // Find the highest popup which is a descendant of the reference window (generally reference window = NavWindow)
        for (; popup_count_to_keep < g.OpenPopupStack.Size; popup_count_to_keep++)
        {
            ImGuiPopupData& popup = g.OpenPopupStack[popup_count_to_keep];
            if (!popup.Window)
                continue;
            IM_ASSERT((popup.Window->Flags & ImGuiWindowFlags_Popup) != 0);
            if (popup.Window->Flags & ImGuiWindowFlags_ChildWindow)
                continue;

            // Trim the stack when popups are not direct descendant of the reference window (the reference window is often the NavWindow)
            bool popup_or_descendent_is_ref_window = false;
            for (int m = popup_count_to_keep; m < g.OpenPopupStack.Size && !popup_or_descendent_is_ref_window; m++)
                if (ImGuiWindow* popup_window = g.OpenPopupStack[m].Window)
                    if (popup_window->RootWindow == ref_window->RootWindow)
                        popup_or_descendent_is_ref_window = true;
            if (!popup_or_descendent_is_ref_window)
                break;
        }
    }
    if (popup_count_to_keep < g.OpenPopupStack.Size) // This test is not required but it allows to set a convenient breakpoint on the statement below
    {
        //IMGUI_DEBUG_LOG("ClosePopupsOverWindow(%s) -> ClosePopupToLevel(%d)\n", ref_window->Name, popup_count_to_keep);
        ClosePopupToLevel(popup_count_to_keep, restore_focus_to_window_under_popup);
    }
}

void ImGui::ClosePopupToLevel(int remaining, bool restore_focus_to_window_under_popup)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(remaining >= 0 && remaining < g.OpenPopupStack.Size);
    ImGuiWindow* focus_window = g.OpenPopupStack[remaining].SourceWindow;
    ImGuiWindow* popup_window = g.OpenPopupStack[remaining].Window;
    g.OpenPopupStack.resize(remaining);

    if (restore_focus_to_window_under_popup)
    {
        if (focus_window && !focus_window->WasActive && popup_window)
        {
            // Fallback
            FocusTopMostWindowUnderOne(popup_window, NULL);
        }
        else
        {
            if (g.NavLayer == 0 && focus_window)
                focus_window = NavRestoreLastChildNavWindow(focus_window);
            FocusWindow(focus_window);
        }
    }
}

// Close the popup we have begin-ed into.
void ImGui::CloseCurrentPopup()
{
    ImGuiContext& g = *GImGui;
    int popup_idx = g.BeginPopupStack.Size - 1;
    if (popup_idx < 0 || popup_idx >= g.OpenPopupStack.Size || g.BeginPopupStack[popup_idx].PopupId != g.OpenPopupStack[popup_idx].PopupId)
        return;

    // Closing a menu closes its top-most parent popup (unless a modal)
    while (popup_idx > 0)
    {
        ImGuiWindow* popup_window = g.OpenPopupStack[popup_idx].Window;
        ImGuiWindow* parent_popup_window = g.OpenPopupStack[popup_idx - 1].Window;
        bool close_parent = false;
        if (popup_window && (popup_window->Flags & ImGuiWindowFlags_ChildMenu))
            if (parent_popup_window == NULL || !(parent_popup_window->Flags & ImGuiWindowFlags_Modal))
                close_parent = true;
        if (!close_parent)
            break;
        popup_idx--;
    }
    //IMGUI_DEBUG_LOG("CloseCurrentPopup %d -> %d\n", g.BeginPopupStack.Size - 1, popup_idx);
    ClosePopupToLevel(popup_idx, true);

    // A common pattern is to close a popup when selecting a menu item/selectable that will open another window.
    // To improve this usage pattern, we avoid nav highlight for a single frame in the parent window.
    // Similarly, we could avoid mouse hover highlight in this window but it is less visually problematic.
    if (ImGuiWindow* window = g.NavWindow)
        window->DC.NavHideHighlightOneFrame = true;
}

bool ImGui::BeginPopupEx(ImGuiID id, ImGuiWindowFlags extra_flags)
{
    ImGuiContext& g = *GImGui;
    if (!IsPopupOpen(id))
    {
        g.NextWindowData.Clear(); // We behave like Begin() and need to consume those values
        return false;
    }

    char name[20];
    if (extra_flags & ImGuiWindowFlags_ChildMenu)
        ImFormatString(name, IM_ARRAYSIZE(name), "##Menu_%02d", g.BeginPopupStack.Size); // Recycle windows based on depth
    else
        ImFormatString(name, IM_ARRAYSIZE(name), "##Popup_%08x", id); // Not recycling, so we can close/open during the same frame

    bool is_open = Begin(name, NULL, extra_flags | ImGuiWindowFlags_Popup);
    if (!is_open) // NB: Begin can return false when the popup is completely clipped (e.g. zero size display)
        EndPopup();

    return is_open;
}

bool ImGui::BeginPopup(const char* str_id, ImGuiWindowFlags flags)
{
    ImGuiContext& g = *GImGui;
    if (g.OpenPopupStack.Size <= g.BeginPopupStack.Size) // Early out for performance
    {
        g.NextWindowData.Clear(); // We behave like Begin() and need to consume those values
        return false;
    }
    flags |= ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings;
    return BeginPopupEx(g.CurrentWindow->GetID(str_id), flags);
}

// If 'p_open' is specified for a modal popup window, the popup will have a regular close button which will close the popup.
// Note that popup visibility status is owned by imgui (and manipulated with e.g. OpenPopup) so the actual value of *p_open is meaningless here.
bool ImGui::BeginPopupModal(const char* name, bool* p_open, ImGuiWindowFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    const ImGuiID id = window->GetID(name);
    if (!IsPopupOpen(id))
    {
        g.NextWindowData.Clear(); // We behave like Begin() and need to consume those values
        return false;
    }

    // Center modal windows by default
    // FIXME: Should test for (PosCond & window->SetWindowPosAllowFlags) with the upcoming window.
    if (g.NextWindowData.PosCond == 0)
        SetNextWindowPos(g.IO.DisplaySize * 0.5f, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));

    flags |= ImGuiWindowFlags_Popup | ImGuiWindowFlags_Modal | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoSavedSettings;
    const bool is_open = Begin(name, p_open, flags);
    if (!is_open || (p_open && !*p_open)) // NB: is_open can be 'false' when the popup is completely clipped (e.g. zero size display)
    {
        EndPopup();
        if (is_open)
            ClosePopupToLevel(g.BeginPopupStack.Size, true);
        return false;
    }
    return is_open;
}

void ImGui::EndPopup()
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.CurrentWindow->Flags & ImGuiWindowFlags_Popup);  // Mismatched BeginPopup()/EndPopup() calls
    IM_ASSERT(g.BeginPopupStack.Size > 0);

    // Make all menus and popups wrap around for now, may need to expose that policy.
    NavMoveRequestTryWrapping(g.CurrentWindow, ImGuiNavMoveFlags_LoopY);

    End();
}

// This is a helper to handle the simplest case of associating one named popup to one given widget.
// You may want to handle this on user side if you have specific needs (e.g. tweaking IsItemHovered() parameters).
// You can pass a NULL str_id to use the identifier of the last item.
bool ImGui::BeginPopupContextItem(const char* str_id, int mouse_button)
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    ImGuiID id = str_id ? window->GetID(str_id) : window->DC.LastItemId; // If user hasn't passed an ID, we can use the LastItemID. Using LastItemID as a Popup ID won't conflict!
    IM_ASSERT(id != 0);                                                  // You cannot pass a NULL str_id if the last item has no identifier (e.g. a Text() item)
    if (IsMouseReleased(mouse_button) && IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))
        OpenPopupEx(id);
    return BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize|ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoSavedSettings);
}

bool ImGui::BeginPopupContextWindow(const char* str_id, int mouse_button, bool also_over_items)
{
    if (!str_id)
        str_id = "window_context";
    ImGuiID id = GImGui->CurrentWindow->GetID(str_id);
    if (IsMouseReleased(mouse_button) && IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))
        if (also_over_items || !IsAnyItemHovered())
            OpenPopupEx(id);
    return BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize|ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoSavedSettings);
}

bool ImGui::BeginPopupContextVoid(const char* str_id, int mouse_button)
{
    if (!str_id)
        str_id = "void_context";
    ImGuiID id = GImGui->CurrentWindow->GetID(str_id);
    if (IsMouseReleased(mouse_button) && !IsWindowHovered(ImGuiHoveredFlags_AnyWindow))
        OpenPopupEx(id);
    return BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize|ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoSavedSettings);
}

// r_avoid = the rectangle to avoid (e.g. for tooltip it is a rectangle around the mouse cursor which we want to avoid. for popups it's a small point around the cursor.)
// r_outer = the visible area rectangle, minus safe area padding. If our popup size won't fit because of safe area padding we ignore it.
ImVec2 ImGui::FindBestWindowPosForPopupEx(const ImVec2& ref_pos, const ImVec2& size, ImGuiDir* last_dir, const ImRect& r_outer, const ImRect& r_avoid, ImGuiPopupPositionPolicy policy)
{
    ImVec2 base_pos_clamped = ImClamp(ref_pos, r_outer.Min, r_outer.Max - size);
    //GetForegroundDrawList()->AddRect(r_avoid.Min, r_avoid.Max, IM_COL32(255,0,0,255));
    //GetForegroundDrawList()->AddRect(r_outer.Min, r_outer.Max, IM_COL32(0,255,0,255));

    // Combo Box policy (we want a connecting edge)
    if (policy == ImGuiPopupPositionPolicy_ComboBox)
    {
        const ImGuiDir dir_prefered_order[ImGuiDir_COUNT] = { ImGuiDir_Down, ImGuiDir_Right, ImGuiDir_Left, ImGuiDir_Up };
        for (int n = (*last_dir != ImGuiDir_None) ? -1 : 0; n < ImGuiDir_COUNT; n++)
        {
            const ImGuiDir dir = (n == -1) ? *last_dir : dir_prefered_order[n];
            if (n != -1 && dir == *last_dir) // Already tried this direction?
                continue;
            ImVec2 pos;
            if (dir == ImGuiDir_Down)  pos = ImVec2(r_avoid.Min.x, r_avoid.Max.y);          // Below, Toward Right (default)
            if (dir == ImGuiDir_Right) pos = ImVec2(r_avoid.Min.x, r_avoid.Min.y - size.y); // Above, Toward Right
            if (dir == ImGuiDir_Left)  pos = ImVec2(r_avoid.Max.x - size.x, r_avoid.Max.y); // Below, Toward Left
            if (dir == ImGuiDir_Up)    pos = ImVec2(r_avoid.Max.x - size.x, r_avoid.Min.y - size.y); // Above, Toward Left
            if (!r_outer.Contains(ImRect(pos, pos + size)))
                continue;
            *last_dir = dir;
            return pos;
        }
    }

    // Default popup policy
    const ImGuiDir dir_prefered_order[ImGuiDir_COUNT] = { ImGuiDir_Right, ImGuiDir_Down, ImGuiDir_Up, ImGuiDir_Left };
    for (int n = (*last_dir != ImGuiDir_None) ? -1 : 0; n < ImGuiDir_COUNT; n++)
    {
        const ImGuiDir dir = (n == -1) ? *last_dir : dir_prefered_order[n];
        if (n != -1 && dir == *last_dir) // Already tried this direction?
            continue;
        float avail_w = (dir == ImGuiDir_Left ? r_avoid.Min.x : r_outer.Max.x) - (dir == ImGuiDir_Right ? r_avoid.Max.x : r_outer.Min.x);
        float avail_h = (dir == ImGuiDir_Up ? r_avoid.Min.y : r_outer.Max.y) - (dir == ImGuiDir_Down ? r_avoid.Max.y : r_outer.Min.y);
        if (avail_w < size.x || avail_h < size.y)
            continue;
        ImVec2 pos;
        pos.x = (dir == ImGuiDir_Left) ? r_avoid.Min.x - size.x : (dir == ImGuiDir_Right) ? r_avoid.Max.x : base_pos_clamped.x;
        pos.y = (dir == ImGuiDir_Up)   ? r_avoid.Min.y - size.y : (dir == ImGuiDir_Down)  ? r_avoid.Max.y : base_pos_clamped.y;
        *last_dir = dir;
        return pos;
    }

    // Fallback, try to keep within display
    *last_dir = ImGuiDir_None;
    ImVec2 pos = ref_pos;
    pos.x = ImMax(ImMin(pos.x + size.x, r_outer.Max.x) - size.x, r_outer.Min.x);
    pos.y = ImMax(ImMin(pos.y + size.y, r_outer.Max.y) - size.y, r_outer.Min.y);
    return pos;
}

ImRect ImGui::GetWindowAllowedExtentRect(ImGuiWindow* window)
{
    IM_UNUSED(window);
    ImVec2 padding = GImGui->Style.DisplaySafeAreaPadding;
    ImRect r_screen = GetViewportRect();
    r_screen.Expand(ImVec2((r_screen.GetWidth() > padding.x * 2) ? -padding.x : 0.0f, (r_screen.GetHeight() > padding.y * 2) ? -padding.y : 0.0f));
    return r_screen;
}

ImVec2 ImGui::FindBestWindowPosForPopup(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;

    ImRect r_outer = GetWindowAllowedExtentRect(window);
    if (window->Flags & ImGuiWindowFlags_ChildMenu)
    {
        // Child menus typically request _any_ position within the parent menu item, and then we move the new menu outside the parent bounds.
        // This is how we end up with child menus appearing (most-commonly) on the right of the parent menu.
        IM_ASSERT(g.CurrentWindow == window);
        ImGuiWindow* parent_window = g.CurrentWindowStack[g.CurrentWindowStack.Size - 2];
        float horizontal_overlap = g.Style.ItemInnerSpacing.x; // We want some overlap to convey the relative depth of each menu (currently the amount of overlap is hard-coded to style.ItemSpacing.x).
        ImRect r_avoid;
        if (parent_window->DC.MenuBarAppending)
            r_avoid = ImRect(-FLT_MAX, parent_window->Pos.y + parent_window->TitleBarHeight(), FLT_MAX, parent_window->Pos.y + parent_window->TitleBarHeight() + parent_window->MenuBarHeight());
        else
            r_avoid = ImRect(parent_window->Pos.x + horizontal_overlap, -FLT_MAX, parent_window->Pos.x + parent_window->Size.x - horizontal_overlap - parent_window->ScrollbarSizes.x, FLT_MAX);
        return FindBestWindowPosForPopupEx(window->Pos, window->Size, &window->AutoPosLastDirection, r_outer, r_avoid);
    }
    if (window->Flags & ImGuiWindowFlags_Popup)
    {
        ImRect r_avoid = ImRect(window->Pos.x - 1, window->Pos.y - 1, window->Pos.x + 1, window->Pos.y + 1);
        return FindBestWindowPosForPopupEx(window->Pos, window->Size, &window->AutoPosLastDirection, r_outer, r_avoid);
    }
    if (window->Flags & ImGuiWindowFlags_Tooltip)
    {
        // Position tooltip (always follows mouse)
        float sc = g.Style.MouseCursorScale;
        ImVec2 ref_pos = NavCalcPreferredRefPos();
        ImRect r_avoid;
        if (!g.NavDisableHighlight && g.NavDisableMouseHover && !(g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos))
            r_avoid = ImRect(ref_pos.x - 16, ref_pos.y - 8, ref_pos.x + 16, ref_pos.y + 8);
        else
            r_avoid = ImRect(ref_pos.x - 16, ref_pos.y - 8, ref_pos.x + 24 * sc, ref_pos.y + 24 * sc); // FIXME: Hard-coded based on mouse cursor shape expectation. Exact dimension not very important.
        ImVec2 pos = FindBestWindowPosForPopupEx(ref_pos, window->Size, &window->AutoPosLastDirection, r_outer, r_avoid);
        if (window->AutoPosLastDirection == ImGuiDir_None)
            pos = ref_pos + ImVec2(2, 2); // If there's not enough room, for tooltip we prefer avoiding the cursor at all cost even if it means that part of the tooltip won't be visible.
        return pos;
    }
    IM_ASSERT(0);
    return window->Pos;
}


//-----------------------------------------------------------------------------
// [SECTION] KEYBOARD/GAMEPAD NAVIGATION
//-----------------------------------------------------------------------------

ImGuiDir ImGetDirQuadrantFromDelta(float dx, float dy)
{
    if (ImFabs(dx) > ImFabs(dy))
        return (dx > 0.0f) ? ImGuiDir_Right : ImGuiDir_Left;
    return (dy > 0.0f) ? ImGuiDir_Down : ImGuiDir_Up;
}

static float inline NavScoreItemDistInterval(float a0, float a1, float b0, float b1)
{
    if (a1 < b0)
        return a1 - b0;
    if (b1 < a0)
        return a0 - b1;
    return 0.0f;
}

static void inline NavClampRectToVisibleAreaForMoveDir(ImGuiDir move_dir, ImRect& r, const ImRect& clip_rect)
{
    if (move_dir == ImGuiDir_Left || move_dir == ImGuiDir_Right)
    {
        r.Min.y = ImClamp(r.Min.y, clip_rect.Min.y, clip_rect.Max.y);
        r.Max.y = ImClamp(r.Max.y, clip_rect.Min.y, clip_rect.Max.y);
    }
    else
    {
        r.Min.x = ImClamp(r.Min.x, clip_rect.Min.x, clip_rect.Max.x);
        r.Max.x = ImClamp(r.Max.x, clip_rect.Min.x, clip_rect.Max.x);
    }
}

// Scoring function for directional navigation. Based on https://gist.github.com/rygorous/6981057
static bool NavScoreItem(ImGuiNavMoveResult* result, ImRect cand)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (g.NavLayer != window->DC.NavLayerCurrent)
        return false;

    const ImRect& curr = g.NavScoringRectScreen; // Current modified source rect (NB: we've applied Max.x = Min.x in NavUpdate() to inhibit the effect of having varied item width)
    g.NavScoringCount++;

    // When entering through a NavFlattened border, we consider child window items as fully clipped for scoring
    if (window->ParentWindow == g.NavWindow)
    {
        IM_ASSERT((window->Flags | g.NavWindow->Flags) & ImGuiWindowFlags_NavFlattened);
        if (!window->ClipRect.Contains(cand))
            return false;
        cand.ClipWithFull(window->ClipRect); // This allows the scored item to not overlap other candidates in the parent window
    }

    // We perform scoring on items bounding box clipped by the current clipping rectangle on the other axis (clipping on our movement axis would give us equal scores for all clipped items)
    // For example, this ensure that items in one column are not reached when moving vertically from items in another column.
    NavClampRectToVisibleAreaForMoveDir(g.NavMoveClipDir, cand, window->ClipRect);

    // Compute distance between boxes
    // FIXME-NAV: Introducing biases for vertical navigation, needs to be removed.
    float dbx = NavScoreItemDistInterval(cand.Min.x, cand.Max.x, curr.Min.x, curr.Max.x);
    float dby = NavScoreItemDistInterval(ImLerp(cand.Min.y, cand.Max.y, 0.2f), ImLerp(cand.Min.y, cand.Max.y, 0.8f), ImLerp(curr.Min.y, curr.Max.y, 0.2f), ImLerp(curr.Min.y, curr.Max.y, 0.8f)); // Scale down on Y to keep using box-distance for vertically touching items
    if (dby != 0.0f && dbx != 0.0f)
       dbx = (dbx/1000.0f) + ((dbx > 0.0f) ? +1.0f : -1.0f);
    float dist_box = ImFabs(dbx) + ImFabs(dby);

    // Compute distance between centers (this is off by a factor of 2, but we only compare center distances with each other so it doesn't matter)
    float dcx = (cand.Min.x + cand.Max.x) - (curr.Min.x + curr.Max.x);
    float dcy = (cand.Min.y + cand.Max.y) - (curr.Min.y + curr.Max.y);
    float dist_center = ImFabs(dcx) + ImFabs(dcy); // L1 metric (need this for our connectedness guarantee)

    // Determine which quadrant of 'curr' our candidate item 'cand' lies in based on distance
    ImGuiDir quadrant;
    float dax = 0.0f, day = 0.0f, dist_axial = 0.0f;
    if (dbx != 0.0f || dby != 0.0f)
    {
        // For non-overlapping boxes, use distance between boxes
        dax = dbx;
        day = dby;
        dist_axial = dist_box;
        quadrant = ImGetDirQuadrantFromDelta(dbx, dby);
    }
    else if (dcx != 0.0f || dcy != 0.0f)
    {
        // For overlapping boxes with different centers, use distance between centers
        dax = dcx;
        day = dcy;
        dist_axial = dist_center;
        quadrant = ImGetDirQuadrantFromDelta(dcx, dcy);
    }
    else
    {
        // Degenerate case: two overlapping buttons with same center, break ties arbitrarily (note that LastItemId here is really the _previous_ item order, but it doesn't matter)
        quadrant = (window->DC.LastItemId < g.NavId) ? ImGuiDir_Left : ImGuiDir_Right;
    }

#if IMGUI_DEBUG_NAV_SCORING
    char buf[128];
    if (ImGui::IsMouseHoveringRect(cand.Min, cand.Max))
    {
        ImFormatString(buf, IM_ARRAYSIZE(buf), "dbox (%.2f,%.2f->%.4f)\ndcen (%.2f,%.2f->%.4f)\nd (%.2f,%.2f->%.4f)\nnav %c, quadrant %c", dbx, dby, dist_box, dcx, dcy, dist_center, dax, day, dist_axial, "WENS"[g.NavMoveDir], "WENS"[quadrant]);
        ImDrawList* draw_list = ImGui::GetForegroundDrawList(window);
        draw_list->AddRect(curr.Min, curr.Max, IM_COL32(255,200,0,100));
        draw_list->AddRect(cand.Min, cand.Max, IM_COL32(255,255,0,200));
        draw_list->AddRectFilled(cand.Max-ImVec2(4,4), cand.Max+ImGui::CalcTextSize(buf)+ImVec2(4,4), IM_COL32(40,0,0,150));
        draw_list->AddText(g.IO.FontDefault, 13.0f, cand.Max, ~0U, buf);
    }
    else if (g.IO.KeyCtrl) // Hold to preview score in matching quadrant. Press C to rotate.
    {
        if (ImGui::IsKeyPressedMap(ImGuiKey_C)) { g.NavMoveDirLast = (ImGuiDir)((g.NavMoveDirLast + 1) & 3); g.IO.KeysDownDuration[g.IO.KeyMap[ImGuiKey_C]] = 0.01f; }
        if (quadrant == g.NavMoveDir)
        {
            ImFormatString(buf, IM_ARRAYSIZE(buf), "%.0f/%.0f", dist_box, dist_center);
            ImDrawList* draw_list = ImGui::GetForegroundDrawList(window);
            draw_list->AddRectFilled(cand.Min, cand.Max, IM_COL32(255, 0, 0, 200));
            draw_list->AddText(g.IO.FontDefault, 13.0f, cand.Min, IM_COL32(255, 255, 255, 255), buf);
        }
    }
 #endif

    // Is it in the quadrant we're interesting in moving to?
    bool new_best = false;
    if (quadrant == g.NavMoveDir)
    {
        // Does it beat the current best candidate?
        if (dist_box < result->DistBox)
        {
            result->DistBox = dist_box;
            result->DistCenter = dist_center;
            return true;
        }
        if (dist_box == result->DistBox)
        {
            // Try using distance between center points to break ties
            if (dist_center < result->DistCenter)
            {
                result->DistCenter = dist_center;
                new_best = true;
            }
            else if (dist_center == result->DistCenter)
            {
                // Still tied! we need to be extra-careful to make sure everything gets linked properly. We consistently break ties by symbolically moving "later" items
                // (with higher index) to the right/downwards by an infinitesimal amount since we the current "best" button already (so it must have a lower index),
                // this is fairly easy. This rule ensures that all buttons with dx==dy==0 will end up being linked in order of appearance along the x axis.
                if (((g.NavMoveDir == ImGuiDir_Up || g.NavMoveDir == ImGuiDir_Down) ? dby : dbx) < 0.0f) // moving bj to the right/down decreases distance
                    new_best = true;
            }
        }
    }

    // Axial check: if 'curr' has no link at all in some direction and 'cand' lies roughly in that direction, add a tentative link. This will only be kept if no "real" matches
    // are found, so it only augments the graph produced by the above method using extra links. (important, since it doesn't guarantee strong connectedness)
    // This is just to avoid buttons having no links in a particular direction when there's a suitable neighbor. you get good graphs without this too.
    // 2017/09/29: FIXME: This now currently only enabled inside menu bars, ideally we'd disable it everywhere. Menus in particular need to catch failure. For general navigation it feels awkward.
    // Disabling it may lead to disconnected graphs when nodes are very spaced out on different axis. Perhaps consider offering this as an option?
    if (result->DistBox == FLT_MAX && dist_axial < result->DistAxial)  // Check axial match
        if (g.NavLayer == 1 && !(g.NavWindow->Flags & ImGuiWindowFlags_ChildMenu))
            if ((g.NavMoveDir == ImGuiDir_Left && dax < 0.0f) || (g.NavMoveDir == ImGuiDir_Right && dax > 0.0f) || (g.NavMoveDir == ImGuiDir_Up && day < 0.0f) || (g.NavMoveDir == ImGuiDir_Down && day > 0.0f))
            {
                result->DistAxial = dist_axial;
                new_best = true;
            }

    return new_best;
}

// We get there when either NavId == id, or when g.NavAnyRequest is set (which is updated by NavUpdateAnyRequestFlag above)
static void ImGui::NavProcessItem(ImGuiWindow* window, const ImRect& nav_bb, const ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    //if (!g.IO.NavActive)  // [2017/10/06] Removed this possibly redundant test but I am not sure of all the side-effects yet. Some of the feature here will need to work regardless of using a _NoNavInputs flag.
    //    return;

    const ImGuiItemFlags item_flags = window->DC.ItemFlags;
    const ImRect nav_bb_rel(nav_bb.Min - window->Pos, nav_bb.Max - window->Pos);

    // Process Init Request
    if (g.NavInitRequest && g.NavLayer == window->DC.NavLayerCurrent)
    {
        // Even if 'ImGuiItemFlags_NoNavDefaultFocus' is on (typically collapse/close button) we record the first ResultId so they can be used as a fallback
        if (!(item_flags & ImGuiItemFlags_NoNavDefaultFocus) || g.NavInitResultId == 0)
        {
            g.NavInitResultId = id;
            g.NavInitResultRectRel = nav_bb_rel;
        }
        if (!(item_flags & ImGuiItemFlags_NoNavDefaultFocus))
        {
            g.NavInitRequest = false; // Found a match, clear request
            NavUpdateAnyRequestFlag();
        }
    }

    // Process Move Request (scoring for navigation)
    // FIXME-NAV: Consider policy for double scoring (scoring from NavScoringRectScreen + scoring from a rect wrapped according to current wrapping policy)
    if ((g.NavId != id || (g.NavMoveRequestFlags & ImGuiNavMoveFlags_AllowCurrentNavId)) && !(item_flags & (ImGuiItemFlags_Disabled|ImGuiItemFlags_NoNav)))
    {
        ImGuiNavMoveResult* result = (window == g.NavWindow) ? &g.NavMoveResultLocal : &g.NavMoveResultOther;
#if IMGUI_DEBUG_NAV_SCORING
        // [DEBUG] Score all items in NavWindow at all times
        if (!g.NavMoveRequest)
            g.NavMoveDir = g.NavMoveDirLast;
        bool new_best = NavScoreItem(result, nav_bb) && g.NavMoveRequest;
#else
        bool new_best = g.NavMoveRequest && NavScoreItem(result, nav_bb);
#endif
        if (new_best)
        {
            result->ID = id;
            result->SelectScopeId = g.MultiSelectScopeId;
            result->Window = window;
            result->RectRel = nav_bb_rel;
        }

        const float VISIBLE_RATIO = 0.70f;
        if ((g.NavMoveRequestFlags & ImGuiNavMoveFlags_AlsoScoreVisibleSet) && window->ClipRect.Overlaps(nav_bb))
            if (ImClamp(nav_bb.Max.y, window->ClipRect.Min.y, window->ClipRect.Max.y) - ImClamp(nav_bb.Min.y, window->ClipRect.Min.y, window->ClipRect.Max.y) >= (nav_bb.Max.y - nav_bb.Min.y) * VISIBLE_RATIO)
                if (NavScoreItem(&g.NavMoveResultLocalVisibleSet, nav_bb))
                {
                    result = &g.NavMoveResultLocalVisibleSet;
                    result->ID = id;
                    result->SelectScopeId = g.MultiSelectScopeId;
                    result->Window = window;
                    result->RectRel = nav_bb_rel;
                }
    }

    // Update window-relative bounding box of navigated item
    if (g.NavId == id)
    {
        g.NavWindow = window;                                           // Always refresh g.NavWindow, because some operations such as FocusItem() don't have a window.
        g.NavLayer = window->DC.NavLayerCurrent;
        g.NavIdIsAlive = true;
        g.NavIdTabCounter = window->DC.FocusCounterTab;
        window->NavRectRel[window->DC.NavLayerCurrent] = nav_bb_rel;    // Store item bounding box (relative to window position)
    }
}

bool ImGui::NavMoveRequestButNoResultYet()
{
    ImGuiContext& g = *GImGui;
    return g.NavMoveRequest && g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0;
}

void ImGui::NavMoveRequestCancel()
{
    ImGuiContext& g = *GImGui;
    g.NavMoveRequest = false;
    NavUpdateAnyRequestFlag();
}

void ImGui::NavMoveRequestForward(ImGuiDir move_dir, ImGuiDir clip_dir, const ImRect& bb_rel, ImGuiNavMoveFlags move_flags)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.NavMoveRequestForward == ImGuiNavForward_None);
    ImGui::NavMoveRequestCancel();
    g.NavMoveDir = move_dir;
    g.NavMoveClipDir = clip_dir;
    g.NavMoveRequestForward = ImGuiNavForward_ForwardQueued;
    g.NavMoveRequestFlags = move_flags;
    g.NavWindow->NavRectRel[g.NavLayer] = bb_rel;
}

void ImGui::NavMoveRequestTryWrapping(ImGuiWindow* window, ImGuiNavMoveFlags move_flags)
{
    ImGuiContext& g = *GImGui;
    if (g.NavWindow != window || !NavMoveRequestButNoResultYet() || g.NavMoveRequestForward != ImGuiNavForward_None || g.NavLayer != 0)
        return;
    IM_ASSERT(move_flags != 0); // No points calling this with no wrapping
    ImRect bb_rel = window->NavRectRel[0];

    ImGuiDir clip_dir = g.NavMoveDir;
    if (g.NavMoveDir == ImGuiDir_Left && (move_flags & (ImGuiNavMoveFlags_WrapX | ImGuiNavMoveFlags_LoopX)))
    {
        bb_rel.Min.x = bb_rel.Max.x = ImMax(window->SizeFull.x, window->SizeContents.x) - window->Scroll.x;
        if (move_flags & ImGuiNavMoveFlags_WrapX) { bb_rel.TranslateY(-bb_rel.GetHeight()); clip_dir = ImGuiDir_Up; }
        NavMoveRequestForward(g.NavMoveDir, clip_dir, bb_rel, move_flags);
    }
    if (g.NavMoveDir == ImGuiDir_Right && (move_flags & (ImGuiNavMoveFlags_WrapX | ImGuiNavMoveFlags_LoopX)))
    {
        bb_rel.Min.x = bb_rel.Max.x = -window->Scroll.x;
        if (move_flags & ImGuiNavMoveFlags_WrapX) { bb_rel.TranslateY(+bb_rel.GetHeight()); clip_dir = ImGuiDir_Down; }
        NavMoveRequestForward(g.NavMoveDir, clip_dir, bb_rel, move_flags);
    }
    if (g.NavMoveDir == ImGuiDir_Up && (move_flags & (ImGuiNavMoveFlags_WrapY | ImGuiNavMoveFlags_LoopY)))
    {
        bb_rel.Min.y = bb_rel.Max.y = ImMax(window->SizeFull.y, window->SizeContents.y) - window->Scroll.y;
        if (move_flags & ImGuiNavMoveFlags_WrapY) { bb_rel.TranslateX(-bb_rel.GetWidth()); clip_dir = ImGuiDir_Left; }
        NavMoveRequestForward(g.NavMoveDir, clip_dir, bb_rel, move_flags);
    }
    if (g.NavMoveDir == ImGuiDir_Down && (move_flags & (ImGuiNavMoveFlags_WrapY | ImGuiNavMoveFlags_LoopY)))
    {
        bb_rel.Min.y = bb_rel.Max.y = -window->Scroll.y;
        if (move_flags & ImGuiNavMoveFlags_WrapY) { bb_rel.TranslateX(+bb_rel.GetWidth()); clip_dir = ImGuiDir_Right; }
        NavMoveRequestForward(g.NavMoveDir, clip_dir, bb_rel, move_flags);
    }
}

// FIXME: This could be replaced by updating a frame number in each window when (window == NavWindow) and (NavLayer == 0).
// This way we could find the last focused window among our children. It would be much less confusing this way?
static void ImGui::NavSaveLastChildNavWindowIntoParent(ImGuiWindow* nav_window)
{
    ImGuiWindow* parent_window = nav_window;
    while (parent_window && (parent_window->Flags & ImGuiWindowFlags_ChildWindow) != 0 && (parent_window->Flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_ChildMenu)) == 0)
        parent_window = parent_window->ParentWindow;
    if (parent_window && parent_window != nav_window)
        parent_window->NavLastChildNavWindow = nav_window;
}

// Restore the last focused child.
// Call when we are expected to land on the Main Layer (0) after FocusWindow()
static ImGuiWindow* ImGui::NavRestoreLastChildNavWindow(ImGuiWindow* window)
{
    return window->NavLastChildNavWindow ? window->NavLastChildNavWindow : window;
}

static void NavRestoreLayer(ImGuiNavLayer layer)
{
    ImGuiContext& g = *GImGui;
    g.NavLayer = layer;
    if (layer == 0)
        g.NavWindow = ImGui::NavRestoreLastChildNavWindow(g.NavWindow);
    if (layer == 0 && g.NavWindow->NavLastIds[0] != 0)
        ImGui::SetNavIDWithRectRel(g.NavWindow->NavLastIds[0], layer, g.NavWindow->NavRectRel[0]);
    else
        ImGui::NavInitWindow(g.NavWindow, true);
}

static inline void ImGui::NavUpdateAnyRequestFlag()
{
    ImGuiContext& g = *GImGui;
    g.NavAnyRequest = g.NavMoveRequest || g.NavInitRequest || (IMGUI_DEBUG_NAV_SCORING && g.NavWindow != NULL);
    if (g.NavAnyRequest)
        IM_ASSERT(g.NavWindow != NULL);
}

// This needs to be called before we submit any widget (aka in or before Begin)
void ImGui::NavInitWindow(ImGuiWindow* window, bool force_reinit)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(window == g.NavWindow);
    bool init_for_nav = false;
    if (!(window->Flags & ImGuiWindowFlags_NoNavInputs))
        if (!(window->Flags & ImGuiWindowFlags_ChildWindow) || (window->Flags & ImGuiWindowFlags_Popup) || (window->NavLastIds[0] == 0) || force_reinit)
            init_for_nav = true;
    if (init_for_nav)
    {
        SetNavID(0, g.NavLayer);
        g.NavInitRequest = true;
        g.NavInitRequestFromMove = false;
        g.NavInitResultId = 0;
        g.NavInitResultRectRel = ImRect();
        NavUpdateAnyRequestFlag();
    }
    else
    {
        g.NavId = window->NavLastIds[0];
    }
}

static ImVec2 ImGui::NavCalcPreferredRefPos()
{
    ImGuiContext& g = *GImGui;
    if (g.NavDisableHighlight || !g.NavDisableMouseHover || !g.NavWindow)
    {
        // Mouse (we need a fallback in case the mouse becomes invalid after being used)
        if (IsMousePosValid(&g.IO.MousePos))
            return g.IO.MousePos;
        return g.LastValidMousePos;
    }
    else
    {
        // When navigation is active and mouse is disabled, decide on an arbitrary position around the bottom left of the currently navigated item.
        const ImRect& rect_rel = g.NavWindow->NavRectRel[g.NavLayer];
        ImVec2 pos = g.NavWindow->Pos + ImVec2(rect_rel.Min.x + ImMin(g.Style.FramePadding.x * 4, rect_rel.GetWidth()), rect_rel.Max.y - ImMin(g.Style.FramePadding.y, rect_rel.GetHeight()));
        ImRect visible_rect = GetViewportRect();
        return ImFloor(ImClamp(pos, visible_rect.Min, visible_rect.Max));   // ImFloor() is important because non-integer mouse position application in back-end might be lossy and result in undesirable non-zero delta.
    }
}

float ImGui::GetNavInputAmount(ImGuiNavInput n, ImGuiInputReadMode mode)
{
    ImGuiContext& g = *GImGui;
    if (mode == ImGuiInputReadMode_Down)
        return g.IO.NavInputs[n];                         // Instant, read analog input (0.0f..1.0f, as provided by user)

    const float t = g.IO.NavInputsDownDuration[n];
    if (t < 0.0f && mode == ImGuiInputReadMode_Released)  // Return 1.0f when just released, no repeat, ignore analog input.
        return (g.IO.NavInputsDownDurationPrev[n] >= 0.0f ? 1.0f : 0.0f);
    if (t < 0.0f)
        return 0.0f;
    if (mode == ImGuiInputReadMode_Pressed)               // Return 1.0f when just pressed, no repeat, ignore analog input.
        return (t == 0.0f) ? 1.0f : 0.0f;
    if (mode == ImGuiInputReadMode_Repeat)
        return (float)CalcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime, g.IO.KeyRepeatDelay * 0.80f, g.IO.KeyRepeatRate * 0.80f);
    if (mode == ImGuiInputReadMode_RepeatSlow)
        return (float)CalcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime, g.IO.KeyRepeatDelay * 1.00f, g.IO.KeyRepeatRate * 2.00f);
    if (mode == ImGuiInputReadMode_RepeatFast)
        return (float)CalcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime, g.IO.KeyRepeatDelay * 0.80f, g.IO.KeyRepeatRate * 0.30f);
    return 0.0f;
}

ImVec2 ImGui::GetNavInputAmount2d(ImGuiNavDirSourceFlags dir_sources, ImGuiInputReadMode mode, float slow_factor, float fast_factor)
{
    ImVec2 delta(0.0f, 0.0f);
    if (dir_sources & ImGuiNavDirSourceFlags_Keyboard)
        delta += ImVec2(GetNavInputAmount(ImGuiNavInput_KeyRight_, mode)   - GetNavInputAmount(ImGuiNavInput_KeyLeft_,   mode), GetNavInputAmount(ImGuiNavInput_KeyDown_,   mode) - GetNavInputAmount(ImGuiNavInput_KeyUp_,   mode));
    if (dir_sources & ImGuiNavDirSourceFlags_PadDPad)
        delta += ImVec2(GetNavInputAmount(ImGuiNavInput_DpadRight, mode)   - GetNavInputAmount(ImGuiNavInput_DpadLeft,   mode), GetNavInputAmount(ImGuiNavInput_DpadDown,   mode) - GetNavInputAmount(ImGuiNavInput_DpadUp,   mode));
    if (dir_sources & ImGuiNavDirSourceFlags_PadLStick)
        delta += ImVec2(GetNavInputAmount(ImGuiNavInput_LStickRight, mode) - GetNavInputAmount(ImGuiNavInput_LStickLeft, mode), GetNavInputAmount(ImGuiNavInput_LStickDown, mode) - GetNavInputAmount(ImGuiNavInput_LStickUp, mode));
    if (slow_factor != 0.0f && IsNavInputDown(ImGuiNavInput_TweakSlow))
        delta *= slow_factor;
    if (fast_factor != 0.0f && IsNavInputDown(ImGuiNavInput_TweakFast))
        delta *= fast_factor;
    return delta;
}

// Scroll to keep newly navigated item fully into view
// NB: We modify rect_rel by the amount we scrolled for, so it is immediately updated.
static void NavScrollToBringItemIntoView(ImGuiWindow* window, const ImRect& item_rect)
{
    ImRect window_rect(window->InnerMainRect.Min - ImVec2(1, 1), window->InnerMainRect.Max + ImVec2(1, 1));
    //GetForegroundDrawList(window)->AddRect(window_rect.Min, window_rect.Max, IM_COL32_WHITE); // [DEBUG]
    if (window_rect.Contains(item_rect))
        return;

    ImGuiContext& g = *GImGui;
    if (window->ScrollbarX && item_rect.Min.x < window_rect.Min.x)
    {
        window->ScrollTarget.x = item_rect.Min.x - window->Pos.x + window->Scroll.x - g.Style.ItemSpacing.x;
        window->ScrollTargetCenterRatio.x = 0.0f;
    }
    else if (window->ScrollbarX && item_rect.Max.x >= window_rect.Max.x)
    {
        window->ScrollTarget.x = item_rect.Max.x - window->Pos.x + window->Scroll.x + g.Style.ItemSpacing.x;
        window->ScrollTargetCenterRatio.x = 1.0f;
    }
    if (item_rect.Min.y < window_rect.Min.y)
    {
        window->ScrollTarget.y = item_rect.Min.y - window->Pos.y + window->Scroll.y - g.Style.ItemSpacing.y;
        window->ScrollTargetCenterRatio.y = 0.0f;
    }
    else if (item_rect.Max.y >= window_rect.Max.y)
    {
        window->ScrollTarget.y = item_rect.Max.y - window->Pos.y + window->Scroll.y + g.Style.ItemSpacing.y;
        window->ScrollTargetCenterRatio.y = 1.0f;
    }
}

static void ImGui::NavUpdate()
{
    ImGuiContext& g = *GImGui;
    g.IO.WantSetMousePos = false;
#if 0
    if (g.NavScoringCount > 0) IMGUI_DEBUG_LOG("NavScoringCount %d for '%s' layer %d (Init:%d, Move:%d)\n", g.FrameCount, g.NavScoringCount, g.NavWindow ? g.NavWindow->Name : "NULL", g.NavLayer, g.NavInitRequest || g.NavInitResultId != 0, g.NavMoveRequest);
#endif

    // Set input source as Gamepad when buttons are pressed before we map Keyboard (some features differs when used with Gamepad vs Keyboard)
    bool nav_keyboard_active = (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
    bool nav_gamepad_active = (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (g.IO.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
    if (nav_gamepad_active)
        if (g.IO.NavInputs[ImGuiNavInput_Activate] > 0.0f || g.IO.NavInputs[ImGuiNavInput_Input] > 0.0f || g.IO.NavInputs[ImGuiNavInput_Cancel] > 0.0f || g.IO.NavInputs[ImGuiNavInput_Menu] > 0.0f)
            g.NavInputSource = ImGuiInputSource_NavGamepad;

    // Update Keyboard->Nav inputs mapping
    if (nav_keyboard_active)
    {
        #define NAV_MAP_KEY(_KEY, _NAV_INPUT) if (IsKeyDown(g.IO.KeyMap[_KEY])) { g.IO.NavInputs[_NAV_INPUT] = 1.0f; g.NavInputSource = ImGuiInputSource_NavKeyboard; }
        NAV_MAP_KEY(ImGuiKey_Space,     ImGuiNavInput_Activate );
        NAV_MAP_KEY(ImGuiKey_Enter,     ImGuiNavInput_Input    );
        NAV_MAP_KEY(ImGuiKey_Escape,    ImGuiNavInput_Cancel   );
        NAV_MAP_KEY(ImGuiKey_LeftArrow, ImGuiNavInput_KeyLeft_ );
        NAV_MAP_KEY(ImGuiKey_RightArrow,ImGuiNavInput_KeyRight_);
        NAV_MAP_KEY(ImGuiKey_UpArrow,   ImGuiNavInput_KeyUp_   );
        NAV_MAP_KEY(ImGuiKey_DownArrow, ImGuiNavInput_KeyDown_ );
        NAV_MAP_KEY(ImGuiKey_Tab,       ImGuiNavInput_KeyTab_  );
        if (g.IO.KeyCtrl)
            g.IO.NavInputs[ImGuiNavInput_TweakSlow] = 1.0f;
        if (g.IO.KeyShift)
            g.IO.NavInputs[ImGuiNavInput_TweakFast] = 1.0f;
        if (g.IO.KeyAlt && !g.IO.KeyCtrl) // AltGR is Alt+Ctrl, also even on keyboards without AltGR we don't want Alt+Ctrl to open menu.
            g.IO.NavInputs[ImGuiNavInput_KeyMenu_]  = 1.0f;
        #undef NAV_MAP_KEY
    }
    memcpy(g.IO.NavInputsDownDurationPrev, g.IO.NavInputsDownDuration, sizeof(g.IO.NavInputsDownDuration));
    for (int i = 0; i < IM_ARRAYSIZE(g.IO.NavInputs); i++)
        g.IO.NavInputsDownDuration[i] = (g.IO.NavInputs[i] > 0.0f) ? (g.IO.NavInputsDownDuration[i] < 0.0f ? 0.0f : g.IO.NavInputsDownDuration[i] + g.IO.DeltaTime) : -1.0f;

    // Process navigation init request (select first/default focus)
    if (g.NavInitResultId != 0 && (!g.NavDisableHighlight || g.NavInitRequestFromMove))
    {
        // Apply result from previous navigation init request (will typically select the first item, unless SetItemDefaultFocus() has been called)
        IM_ASSERT(g.NavWindow);
        if (g.NavInitRequestFromMove)
            SetNavIDWithRectRel(g.NavInitResultId, g.NavLayer, g.NavInitResultRectRel);
        else
            SetNavID(g.NavInitResultId, g.NavLayer);
        g.NavWindow->NavRectRel[g.NavLayer] = g.NavInitResultRectRel;
    }
    g.NavInitRequest = false;
    g.NavInitRequestFromMove = false;
    g.NavInitResultId = 0;
    g.NavJustMovedToId = 0;

    // Process navigation move request
    if (g.NavMoveRequest)
        NavUpdateMoveResult();

    // When a forwarded move request failed, we restore the highlight that we disabled during the forward frame
    if (g.NavMoveRequestForward == ImGuiNavForward_ForwardActive)
    {
        IM_ASSERT(g.NavMoveRequest);
        if (g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0)
            g.NavDisableHighlight = false;
        g.NavMoveRequestForward = ImGuiNavForward_None;
    }

    // Apply application mouse position movement, after we had a chance to process move request result.
    if (g.NavMousePosDirty && g.NavIdIsAlive)
    {
        // Set mouse position given our knowledge of the navigated item position from last frame
        if ((g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos) && (g.IO.BackendFlags & ImGuiBackendFlags_HasSetMousePos))
        {
            if (!g.NavDisableHighlight && g.NavDisableMouseHover && g.NavWindow)
            {
                g.IO.MousePos = g.IO.MousePosPrev = NavCalcPreferredRefPos();
                g.IO.WantSetMousePos = true;
            }
        }
        g.NavMousePosDirty = false;
    }
    g.NavIdIsAlive = false;
    g.NavJustTabbedId = 0;
    IM_ASSERT(g.NavLayer == 0 || g.NavLayer == 1);

    // Store our return window (for returning from Layer 1 to Layer 0) and clear it as soon as we step back in our own Layer 0
    if (g.NavWindow)
        NavSaveLastChildNavWindowIntoParent(g.NavWindow);
    if (g.NavWindow && g.NavWindow->NavLastChildNavWindow != NULL && g.NavLayer == 0)
        g.NavWindow->NavLastChildNavWindow = NULL;

    // Update CTRL+TAB and Windowing features (hold Square to move/resize/etc.)
    NavUpdateWindowing();

    // Set output flags for user application
    g.IO.NavActive = (nav_keyboard_active || nav_gamepad_active) && g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs);
    g.IO.NavVisible = (g.IO.NavActive && g.NavId != 0 && !g.NavDisableHighlight) || (g.NavWindowingTarget != NULL);

    // Process NavCancel input (to close a popup, get back to parent, clear focus)
    if (IsNavInputPressed(ImGuiNavInput_Cancel, ImGuiInputReadMode_Pressed))
    {
        if (g.ActiveId != 0)
        {
            if (!(g.ActiveIdBlockNavInputFlags & (1 << ImGuiNavInput_Cancel)))
                ClearActiveID();
        }
        else if (g.NavWindow && (g.NavWindow->Flags & ImGuiWindowFlags_ChildWindow) && !(g.NavWindow->Flags & ImGuiWindowFlags_Popup) && g.NavWindow->ParentWindow)
        {
            // Exit child window
            ImGuiWindow* child_window = g.NavWindow;
            ImGuiWindow* parent_window = g.NavWindow->ParentWindow;
            IM_ASSERT(child_window->ChildId != 0);
            FocusWindow(parent_window);
            SetNavID(child_window->ChildId, 0);
            g.NavIdIsAlive = false;
            if (g.NavDisableMouseHover)
                g.NavMousePosDirty = true;
        }
        else if (g.OpenPopupStack.Size > 0)
        {
            // Close open popup/menu
            if (!(g.OpenPopupStack.back().Window->Flags & ImGuiWindowFlags_Modal))
                ClosePopupToLevel(g.OpenPopupStack.Size - 1, true);
        }
        else if (g.NavLayer != 0)
        {
            // Leave the "menu" layer
            NavRestoreLayer(ImGuiNavLayer_Main);
        }
        else
        {
            // Clear NavLastId for popups but keep it for regular child window so we can leave one and come back where we were
            if (g.NavWindow && ((g.NavWindow->Flags & ImGuiWindowFlags_Popup) || !(g.NavWindow->Flags & ImGuiWindowFlags_ChildWindow)))
                g.NavWindow->NavLastIds[0] = 0;
            g.NavId = 0;
        }
    }

    // Process manual activation request
    g.NavActivateId = g.NavActivateDownId = g.NavActivatePressedId = g.NavInputId = 0;
    if (g.NavId != 0 && !g.NavDisableHighlight && !g.NavWindowingTarget && g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))
    {
        bool activate_down = IsNavInputDown(ImGuiNavInput_Activate);
        bool activate_pressed = activate_down && IsNavInputPressed(ImGuiNavInput_Activate, ImGuiInputReadMode_Pressed);
        if (g.ActiveId == 0 && activate_pressed)
            g.NavActivateId = g.NavId;
        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && activate_down)
            g.NavActivateDownId = g.NavId;
        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && activate_pressed)
            g.NavActivatePressedId = g.NavId;
        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && IsNavInputPressed(ImGuiNavInput_Input, ImGuiInputReadMode_Pressed))
            g.NavInputId = g.NavId;
    }
    if (g.NavWindow && (g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))
        g.NavDisableHighlight = true;
    if (g.NavActivateId != 0)
        IM_ASSERT(g.NavActivateDownId == g.NavActivateId);
    g.NavMoveRequest = false;

    // Process programmatic activation request
    if (g.NavNextActivateId != 0)
        g.NavActivateId = g.NavActivateDownId = g.NavActivatePressedId = g.NavInputId = g.NavNextActivateId;
    g.NavNextActivateId = 0;

    // Initiate directional inputs request
    const int allowed_dir_flags = (g.ActiveId == 0) ? ~0 : g.ActiveIdAllowNavDirFlags;
    if (g.NavMoveRequestForward == ImGuiNavForward_None)
    {
        g.NavMoveDir = ImGuiDir_None;
        g.NavMoveRequestFlags = ImGuiNavMoveFlags_None;
        if (g.NavWindow && !g.NavWindowingTarget && allowed_dir_flags && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))
        {
            if ((allowed_dir_flags & (1<<ImGuiDir_Left))  && IsNavInputPressedAnyOfTwo(ImGuiNavInput_DpadLeft, ImGuiNavInput_KeyLeft_, ImGuiInputReadMode_Repeat)) g.NavMoveDir = ImGuiDir_Left;
            if ((allowed_dir_flags & (1<<ImGuiDir_Right)) && IsNavInputPressedAnyOfTwo(ImGuiNavInput_DpadRight,ImGuiNavInput_KeyRight_,ImGuiInputReadMode_Repeat)) g.NavMoveDir = ImGuiDir_Right;
            if ((allowed_dir_flags & (1<<ImGuiDir_Up))    && IsNavInputPressedAnyOfTwo(ImGuiNavInput_DpadUp,   ImGuiNavInput_KeyUp_,   ImGuiInputReadMode_Repeat)) g.NavMoveDir = ImGuiDir_Up;
            if ((allowed_dir_flags & (1<<ImGuiDir_Down))  && IsNavInputPressedAnyOfTwo(ImGuiNavInput_DpadDown, ImGuiNavInput_KeyDown_, ImGuiInputReadMode_Repeat)) g.NavMoveDir = ImGuiDir_Down;
        }
        g.NavMoveClipDir = g.NavMoveDir;
    }
    else
    {
        // Forwarding previous request (which has been modified, e.g. wrap around menus rewrite the requests with a starting rectangle at the other side of the window)
        // (Preserve g.NavMoveRequestFlags, g.NavMoveClipDir which were set by the NavMoveRequestForward() function)
        IM_ASSERT(g.NavMoveDir != ImGuiDir_None && g.NavMoveClipDir != ImGuiDir_None);
        IM_ASSERT(g.NavMoveRequestForward == ImGuiNavForward_ForwardQueued);
        g.NavMoveRequestForward = ImGuiNavForward_ForwardActive;
    }

    // Update PageUp/PageDown scroll
    float nav_scoring_rect_offset_y = 0.0f;
    if (nav_keyboard_active)
        nav_scoring_rect_offset_y = NavUpdatePageUpPageDown(allowed_dir_flags);

    // If we initiate a movement request and have no current NavId, we initiate a InitDefautRequest that will be used as a fallback if the direction fails to find a match
    if (g.NavMoveDir != ImGuiDir_None)
    {
        g.NavMoveRequest = true;
        g.NavMoveDirLast = g.NavMoveDir;
    }
    if (g.NavMoveRequest && g.NavId == 0)
    {
        g.NavInitRequest = g.NavInitRequestFromMove = true;
        g.NavInitResultId = 0;
        g.NavDisableHighlight = false;
    }
    NavUpdateAnyRequestFlag();

    // Scrolling
    if (g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs) && !g.NavWindowingTarget)
    {
        // *Fallback* manual-scroll with Nav directional keys when window has no navigable item
        ImGuiWindow* window = g.NavWindow;
        const float scroll_speed = ImFloor(window->CalcFontSize() * 100 * g.IO.DeltaTime + 0.5f); // We need round the scrolling speed because sub-pixel scroll isn't reliably supported.
        if (window->DC.NavLayerActiveMask == 0x00 && window->DC.NavHasScroll && g.NavMoveRequest)
        {
            if (g.NavMoveDir == ImGuiDir_Left || g.NavMoveDir == ImGuiDir_Right)
                SetWindowScrollX(window, ImFloor(window->Scroll.x + ((g.NavMoveDir == ImGuiDir_Left) ? -1.0f : +1.0f) * scroll_speed));
            if (g.NavMoveDir == ImGuiDir_Up || g.NavMoveDir == ImGuiDir_Down)
                SetWindowScrollY(window, ImFloor(window->Scroll.y + ((g.NavMoveDir == ImGuiDir_Up) ? -1.0f : +1.0f) * scroll_speed));
        }

        // *Normal* Manual scroll with NavScrollXXX keys
        // Next movement request will clamp the NavId reference rectangle to the visible area, so navigation will resume within those bounds.
        ImVec2 scroll_dir = GetNavInputAmount2d(ImGuiNavDirSourceFlags_PadLStick, ImGuiInputReadMode_Down, 1.0f/10.0f, 10.0f);
        if (scroll_dir.x != 0.0f && window->ScrollbarX)
        {
            SetWindowScrollX(window, ImFloor(window->Scroll.x + scroll_dir.x * scroll_speed));
            g.NavMoveFromClampedRefRect = true;
        }
        if (scroll_dir.y != 0.0f)
        {
            SetWindowScrollY(window, ImFloor(window->Scroll.y + scroll_dir.y * scroll_speed));
            g.NavMoveFromClampedRefRect = true;
        }
    }

    // Reset search results
    g.NavMoveResultLocal.Clear();
    g.NavMoveResultLocalVisibleSet.Clear();
    g.NavMoveResultOther.Clear();

    // When we have manually scrolled (without using navigation) and NavId becomes out of bounds, we project its bounding box to the visible area to restart navigation within visible items
    if (g.NavMoveRequest && g.NavMoveFromClampedRefRect && g.NavLayer == 0)
    {
        ImGuiWindow* window = g.NavWindow;
        ImRect window_rect_rel(window->InnerMainRect.Min - window->Pos - ImVec2(1,1), window->InnerMainRect.Max - window->Pos + ImVec2(1,1));
        if (!window_rect_rel.Contains(window->NavRectRel[g.NavLayer]))
        {
            float pad = window->CalcFontSize() * 0.5f;
            window_rect_rel.Expand(ImVec2(-ImMin(window_rect_rel.GetWidth(), pad), -ImMin(window_rect_rel.GetHeight(), pad))); // Terrible approximation for the intent of starting navigation from first fully visible item
            window->NavRectRel[g.NavLayer].ClipWith(window_rect_rel);
            g.NavId = 0;
        }
        g.NavMoveFromClampedRefRect = false;
    }

    // For scoring we use a single segment on the left side our current item bounding box (not touching the edge to avoid box overlap with zero-spaced items)
    ImRect nav_rect_rel = (g.NavWindow && !g.NavWindow->NavRectRel[g.NavLayer].IsInverted()) ? g.NavWindow->NavRectRel[g.NavLayer] : ImRect(0,0,0,0);
    g.NavScoringRectScreen = g.NavWindow ? ImRect(g.NavWindow->Pos + nav_rect_rel.Min, g.NavWindow->Pos + nav_rect_rel.Max) : GetViewportRect();
    g.NavScoringRectScreen.TranslateY(nav_scoring_rect_offset_y);
    g.NavScoringRectScreen.Min.x = ImMin(g.NavScoringRectScreen.Min.x + 1.0f, g.NavScoringRectScreen.Max.x);
    g.NavScoringRectScreen.Max.x = g.NavScoringRectScreen.Min.x;
    IM_ASSERT(!g.NavScoringRectScreen.IsInverted()); // Ensure if we have a finite, non-inverted bounding box here will allows us to remove extraneous ImFabs() calls in NavScoreItem().
    //GetForegroundDrawList()->AddRect(g.NavScoringRectScreen.Min, g.NavScoringRectScreen.Max, IM_COL32(255,200,0,255)); // [DEBUG]
    g.NavScoringCount = 0;
#if IMGUI_DEBUG_NAV_RECTS
    if (g.NavWindow)
    {
        ImDrawList* draw_list = GetForegroundDrawList(g.NavWindow);
        if (1) { for (int layer = 0; layer < 2; layer++) draw_list->AddRect(g.NavWindow->Pos + g.NavWindow->NavRectRel[layer].Min, g.NavWindow->Pos + g.NavWindow->NavRectRel[layer].Max, IM_COL32(255,200,0,255)); } // [DEBUG]
        if (1) { ImU32 col = (!g.NavWindow->Hidden) ? IM_COL32(255,0,255,255) : IM_COL32(255,0,0,255); ImVec2 p = NavCalcPreferredRefPos(); char buf[32]; ImFormatString(buf, 32, "%d", g.NavLayer); draw_list->AddCircleFilled(p, 3.0f, col); draw_list->AddText(NULL, 13.0f, p + ImVec2(8,-4), col, buf); }
    }
#endif
}

// Apply result from previous frame navigation directional move request
static void ImGui::NavUpdateMoveResult()
{
    ImGuiContext& g = *GImGui;
    if (g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0)
    {
        // In a situation when there is no results but NavId != 0, re-enable the Navigation highlight (because g.NavId is not considered as a possible result)
        if (g.NavId != 0)
        {
            g.NavDisableHighlight = false;
            g.NavDisableMouseHover = true;
        }
        return;
    }

    // Select which result to use
    ImGuiNavMoveResult* result = (g.NavMoveResultLocal.ID != 0) ? &g.NavMoveResultLocal : &g.NavMoveResultOther;

    // PageUp/PageDown behavior first jumps to the bottom/top mostly visible item, _otherwise_ use the result from the previous/next page.
    if (g.NavMoveRequestFlags & ImGuiNavMoveFlags_AlsoScoreVisibleSet)
        if (g.NavMoveResultLocalVisibleSet.ID != 0 && g.NavMoveResultLocalVisibleSet.ID != g.NavId)
            result = &g.NavMoveResultLocalVisibleSet;

    // Maybe entering a flattened child from the outside? In this case solve the tie using the regular scoring rules.
    if (result != &g.NavMoveResultOther && g.NavMoveResultOther.ID != 0 && g.NavMoveResultOther.Window->ParentWindow == g.NavWindow)
        if ((g.NavMoveResultOther.DistBox < result->DistBox) || (g.NavMoveResultOther.DistBox == result->DistBox && g.NavMoveResultOther.DistCenter < result->DistCenter))
            result = &g.NavMoveResultOther;
    IM_ASSERT(g.NavWindow && result->Window);

    // Scroll to keep newly navigated item fully into view.
    if (g.NavLayer == 0)
    {
        ImRect rect_abs = ImRect(result->RectRel.Min + result->Window->Pos, result->RectRel.Max + result->Window->Pos);
        NavScrollToBringItemIntoView(result->Window, rect_abs);

        // Estimate upcoming scroll so we can offset our result position so mouse position can be applied immediately after in NavUpdate()
        ImVec2 next_scroll = CalcNextScrollFromScrollTargetAndClamp(result->Window, false);
        ImVec2 delta_scroll = result->Window->Scroll - next_scroll;
        result->RectRel.Translate(delta_scroll);

        // Also scroll parent window to keep us into view if necessary (we could/should technically recurse back the whole the parent hierarchy).
        if (result->Window->Flags & ImGuiWindowFlags_ChildWindow)
            NavScrollToBringItemIntoView(result->Window->ParentWindow, ImRect(rect_abs.Min + delta_scroll, rect_abs.Max + delta_scroll));
    }

    ClearActiveID();
    g.NavWindow = result->Window;
    if (g.NavId != result->ID)
    {
        // Don't set NavJustMovedToId if just landed on the same spot (which may happen with ImGuiNavMoveFlags_AllowCurrentNavId)
        g.NavJustMovedToId = result->ID;
        g.NavJustMovedToMultiSelectScopeId = result->SelectScopeId;
    }
    SetNavIDWithRectRel(result->ID, g.NavLayer, result->RectRel);
    g.NavMoveFromClampedRefRect = false;
}

static float ImGui::NavUpdatePageUpPageDown(int allowed_dir_flags)
{
    ImGuiContext& g = *GImGui;
    if (g.NavMoveDir == ImGuiDir_None && g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs) && !g.NavWindowingTarget && g.NavLayer == 0)
    {
        ImGuiWindow* window = g.NavWindow;
        bool page_up_held = IsKeyDown(g.IO.KeyMap[ImGuiKey_PageUp]) && (allowed_dir_flags & (1 << ImGuiDir_Up));
        bool page_down_held = IsKeyDown(g.IO.KeyMap[ImGuiKey_PageDown]) && (allowed_dir_flags & (1 << ImGuiDir_Down));
        if (page_up_held != page_down_held) // If either (not both) are pressed
        {
            if (window->DC.NavLayerActiveMask == 0x00 && window->DC.NavHasScroll)
            {
                // Fallback manual-scroll when window has no navigable item
                if (IsKeyPressed(g.IO.KeyMap[ImGuiKey_PageUp], true))
                    SetWindowScrollY(window, window->Scroll.y - window->InnerMainRect.GetHeight());
                else if (IsKeyPressed(g.IO.KeyMap[ImGuiKey_PageDown], true))
                    SetWindowScrollY(window, window->Scroll.y + window->InnerMainRect.GetHeight());
            }
            else
            {
                const ImRect& nav_rect_rel = window->NavRectRel[g.NavLayer];
                const float page_offset_y = ImMax(0.0f, window->InnerMainRect.GetHeight() - window->CalcFontSize() * 1.0f + nav_rect_rel.GetHeight());
                float nav_scoring_rect_offset_y = 0.0f;
                if (IsKeyPressed(g.IO.KeyMap[ImGuiKey_PageUp], true))
                {
                    nav_scoring_rect_offset_y = -page_offset_y;
                    g.NavMoveDir = ImGuiDir_Down; // Because our scoring rect is offset, we intentionally request the opposite direction (so we can always land on the last item)
                    g.NavMoveClipDir = ImGuiDir_Up;
                    g.NavMoveRequestFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_AlsoScoreVisibleSet;
                }
                else if (IsKeyPressed(g.IO.KeyMap[ImGuiKey_PageDown], true))
                {
                    nav_scoring_rect_offset_y = +page_offset_y;
                    g.NavMoveDir = ImGuiDir_Up; // Because our scoring rect is offset, we intentionally request the opposite direction (so we can always land on the last item)
                    g.NavMoveClipDir = ImGuiDir_Down;
                    g.NavMoveRequestFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_AlsoScoreVisibleSet;
                }
                return nav_scoring_rect_offset_y;
            }
        }
    }
    return 0.0f;
}

static int ImGui::FindWindowFocusIndex(ImGuiWindow* window) // FIXME-OPT O(N)
{
    ImGuiContext& g = *GImGui;
    for (int i = g.WindowsFocusOrder.Size-1; i >= 0; i--)
        if (g.WindowsFocusOrder[i] == window)
            return i;
    return -1;
}

static ImGuiWindow* FindWindowNavFocusable(int i_start, int i_stop, int dir) // FIXME-OPT O(N)
{
    ImGuiContext& g = *GImGui;
    for (int i = i_start; i >= 0 && i < g.WindowsFocusOrder.Size && i != i_stop; i += dir)
        if (ImGui::IsWindowNavFocusable(g.WindowsFocusOrder[i]))
            return g.WindowsFocusOrder[i];
    return NULL;
}

static void NavUpdateWindowingHighlightWindow(int focus_change_dir)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.NavWindowingTarget);
    if (g.NavWindowingTarget->Flags & ImGuiWindowFlags_Modal)
        return;

    const int i_current = ImGui::FindWindowFocusIndex(g.NavWindowingTarget);
    ImGuiWindow* window_target = FindWindowNavFocusable(i_current + focus_change_dir, -INT_MAX, focus_change_dir);
    if (!window_target)
        window_target = FindWindowNavFocusable((focus_change_dir < 0) ? (g.WindowsFocusOrder.Size - 1) : 0, i_current, focus_change_dir);
    if (window_target) // Don't reset windowing target if there's a single window in the list
        g.NavWindowingTarget = g.NavWindowingTargetAnim = window_target;
    g.NavWindowingToggleLayer = false;
}

// Windowing management mode
// Keyboard: CTRL+Tab (change focus/move/resize), Alt (toggle menu layer)
// Gamepad:  Hold Menu/Square (change focus/move/resize), Tap Menu/Square (toggle menu layer)
static void ImGui::NavUpdateWindowing()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* apply_focus_window = NULL;
    bool apply_toggle_layer = false;

    ImGuiWindow* modal_window = GetFrontMostPopupModal();
    if (modal_window != NULL)
    {
        g.NavWindowingTarget = NULL;
        return;
    }

    // Fade out
    if (g.NavWindowingTargetAnim && g.NavWindowingTarget == NULL)
    {
        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha - g.IO.DeltaTime * 10.0f, 0.0f);
        if (g.DimBgRatio <= 0.0f && g.NavWindowingHighlightAlpha <= 0.0f)
            g.NavWindowingTargetAnim = NULL;
    }

    // Start CTRL-TAB or Square+L/R window selection
    bool start_windowing_with_gamepad = !g.NavWindowingTarget && IsNavInputPressed(ImGuiNavInput_Menu, ImGuiInputReadMode_Pressed);
    bool start_windowing_with_keyboard = !g.NavWindowingTarget && g.IO.KeyCtrl && IsKeyPressedMap(ImGuiKey_Tab) && (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard);
    if (start_windowing_with_gamepad || start_windowing_with_keyboard)
        if (ImGuiWindow* window = g.NavWindow ? g.NavWindow : FindWindowNavFocusable(g.WindowsFocusOrder.Size - 1, -INT_MAX, -1))
        {
            g.NavWindowingTarget = g.NavWindowingTargetAnim = window;
            g.NavWindowingTimer = g.NavWindowingHighlightAlpha = 0.0f;
            g.NavWindowingToggleLayer = start_windowing_with_keyboard ? false : true;
            g.NavInputSource = start_windowing_with_keyboard ? ImGuiInputSource_NavKeyboard : ImGuiInputSource_NavGamepad;
        }

    // Gamepad update
    g.NavWindowingTimer += g.IO.DeltaTime;
    if (g.NavWindowingTarget && g.NavInputSource == ImGuiInputSource_NavGamepad)
    {
        // Highlight only appears after a brief time holding the button, so that a fast tap on PadMenu (to toggle NavLayer) doesn't add visual noise
        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha, ImSaturate((g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY) / 0.05f));

        // Select window to focus
        const int focus_change_dir = (int)IsNavInputPressed(ImGuiNavInput_FocusPrev, ImGuiInputReadMode_RepeatSlow) - (int)IsNavInputPressed(ImGuiNavInput_FocusNext, ImGuiInputReadMode_RepeatSlow);
        if (focus_change_dir != 0)
        {
            NavUpdateWindowingHighlightWindow(focus_change_dir);
            g.NavWindowingHighlightAlpha = 1.0f;
        }

        // Single press toggles NavLayer, long press with L/R apply actual focus on release (until then the window was merely rendered front-most)
        if (!IsNavInputDown(ImGuiNavInput_Menu))
        {
            g.NavWindowingToggleLayer &= (g.NavWindowingHighlightAlpha < 1.0f); // Once button was held long enough we don't consider it a tap-to-toggle-layer press anymore.
            if (g.NavWindowingToggleLayer && g.NavWindow)
                apply_toggle_layer = true;
            else if (!g.NavWindowingToggleLayer)
                apply_focus_window = g.NavWindowingTarget;
            g.NavWindowingTarget = NULL;
        }
    }

    // Keyboard: Focus
    if (g.NavWindowingTarget && g.NavInputSource == ImGuiInputSource_NavKeyboard)
    {
        // Visuals only appears after a brief time after pressing TAB the first time, so that a fast CTRL+TAB doesn't add visual noise
        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha, ImSaturate((g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY) / 0.05f)); // 1.0f
        if (IsKeyPressedMap(ImGuiKey_Tab, true))
            NavUpdateWindowingHighlightWindow(g.IO.KeyShift ? +1 : -1);
        if (!g.IO.KeyCtrl)
            apply_focus_window = g.NavWindowingTarget;
    }

    // Keyboard: Press and Release ALT to toggle menu layer
    // FIXME: We lack an explicit IO variable for "is the imgui window focused", so compare mouse validity to detect the common case of back-end clearing releases all keys on ALT-TAB
    if (IsNavInputPressed(ImGuiNavInput_KeyMenu_, ImGuiInputReadMode_Pressed))
        g.NavWindowingToggleLayer = true;
    if ((g.ActiveId == 0 || g.ActiveIdAllowOverlap) && g.NavWindowingToggleLayer && IsNavInputPressed(ImGuiNavInput_KeyMenu_, ImGuiInputReadMode_Released))
        if (IsMousePosValid(&g.IO.MousePos) == IsMousePosValid(&g.IO.MousePosPrev))
            apply_toggle_layer = true;

    // Move window
    if (g.NavWindowingTarget && !(g.NavWindowingTarget->Flags & ImGuiWindowFlags_NoMove))
    {
        ImVec2 move_delta;
        if (g.NavInputSource == ImGuiInputSource_NavKeyboard && !g.IO.KeyShift)
            move_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard, ImGuiInputReadMode_Down);
        if (g.NavInputSource == ImGuiInputSource_NavGamepad)
            move_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_PadLStick, ImGuiInputReadMode_Down);
        if (move_delta.x != 0.0f || move_delta.y != 0.0f)
        {
            const float NAV_MOVE_SPEED = 800.0f;
            const float move_speed = ImFloor(NAV_MOVE_SPEED * g.IO.DeltaTime * ImMin(g.IO.DisplayFramebufferScale.x, g.IO.DisplayFramebufferScale.y)); // FIXME: Doesn't code variable framerate very well
            g.NavWindowingTarget->RootWindow->Pos += move_delta * move_speed;
            g.NavDisableMouseHover = true;
            MarkIniSettingsDirty(g.NavWindowingTarget);
        }
    }

    // Apply final focus
    if (apply_focus_window && (g.NavWindow == NULL || apply_focus_window != g.NavWindow->RootWindow))
    {
        ClearActiveID();
        g.NavDisableHighlight = false;
        g.NavDisableMouseHover = true;
        apply_focus_window = NavRestoreLastChildNavWindow(apply_focus_window);
        ClosePopupsOverWindow(apply_focus_window, false);
        FocusWindow(apply_focus_window);
        if (apply_focus_window->NavLastIds[0] == 0)
            NavInitWindow(apply_focus_window, false);

        // If the window only has a menu layer, select it directly
        if (apply_focus_window->DC.NavLayerActiveMask == (1 << ImGuiNavLayer_Menu))
            g.NavLayer = ImGuiNavLayer_Menu;
    }
    if (apply_focus_window)
        g.NavWindowingTarget = NULL;

    // Apply menu/layer toggle
    if (apply_toggle_layer && g.NavWindow)
    {
        // Move to parent menu if necessary
        ImGuiWindow* new_nav_window = g.NavWindow;
        while (new_nav_window->ParentWindow
            && (new_nav_window->DC.NavLayerActiveMask & (1 << ImGuiNavLayer_Menu)) == 0
            && (new_nav_window->Flags & ImGuiWindowFlags_ChildWindow) != 0
            && (new_nav_window->Flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_ChildMenu)) == 0)
            new_nav_window = new_nav_window->ParentWindow;
        if (new_nav_window != g.NavWindow)
        {
            ImGuiWindow* old_nav_window = g.NavWindow;
            FocusWindow(new_nav_window);
            new_nav_window->NavLastChildNavWindow = old_nav_window;
        }
        g.NavDisableHighlight = false;
        g.NavDisableMouseHover = true;

        // When entering a regular menu bar with the Alt key, we always reinitialize the navigation ID.
        const ImGuiNavLayer new_nav_layer = (g.NavWindow->DC.NavLayerActiveMask & (1 << ImGuiNavLayer_Menu)) ? (ImGuiNavLayer)((int)g.NavLayer ^ 1) : ImGuiNavLayer_Main;
        NavRestoreLayer(new_nav_layer);
    }
}

// Window has already passed the IsWindowNavFocusable()
static const char* GetFallbackWindowNameForWindowingList(ImGuiWindow* window)
{
    if (window->Flags & ImGuiWindowFlags_Popup)
        return "(Popup)";
    if ((window->Flags & ImGuiWindowFlags_MenuBar) && strcmp(window->Name, "##MainMenuBar") == 0)
        return "(Main menu bar)";
    return "(Untitled)";
}

// Overlay displayed when using CTRL+TAB. Called by EndFrame().
void ImGui::NavUpdateWindowingList()
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.NavWindowingTarget != NULL);

    if (g.NavWindowingTimer < NAV_WINDOWING_LIST_APPEAR_DELAY)
        return;

    if (g.NavWindowingList == NULL)
        g.NavWindowingList = FindWindowByName("###NavWindowingList");
    SetNextWindowSizeConstraints(ImVec2(g.IO.DisplaySize.x * 0.20f, g.IO.DisplaySize.y * 0.20f), ImVec2(FLT_MAX, FLT_MAX));
    SetNextWindowPos(g.IO.DisplaySize * 0.5f, ImGuiCond_Always, ImVec2(0.5f, 0.5f));
    PushStyleVar(ImGuiStyleVar_WindowPadding, g.Style.WindowPadding * 2.0f);
    Begin("###NavWindowingList", NULL, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings);
    for (int n = g.WindowsFocusOrder.Size - 1; n >= 0; n--)
    {
        ImGuiWindow* window = g.WindowsFocusOrder[n];
        if (!IsWindowNavFocusable(window))
            continue;
        const char* label = window->Name;
        if (label == FindRenderedTextEnd(label))
            label = GetFallbackWindowNameForWindowingList(window);
        Selectable(label, g.NavWindowingTarget == window);
    }
    End();
    PopStyleVar();
}

//-----------------------------------------------------------------------------
// [SECTION] COLUMNS
// In the current version, Columns are very weak. Needs to be replaced with a more full-featured system.
//-----------------------------------------------------------------------------

void ImGui::NextColumn()
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems || window->DC.CurrentColumns == NULL)
        return;

    ImGuiContext& g = *GImGui;
    ImGuiColumns* columns = window->DC.CurrentColumns;

    if (columns->Count == 1)
    {
        window->DC.CursorPos.x = (float)(int)(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);
        IM_ASSERT(columns->Current == 0);
        return;
    }

    PopItemWidth();
    PopClipRect();

    columns->LineMaxY = ImMax(columns->LineMaxY, window->DC.CursorPos.y);
    if (++columns->Current < columns->Count)
    {
        // New column (columns 1+ cancels out IndentX)
        window->DC.ColumnsOffset.x = GetColumnOffset(columns->Current) - window->DC.Indent.x + g.Style.ItemSpacing.x;
        window->DrawList->ChannelsSetCurrent(columns->Current);
    }
    else
    {
        // New row/line
        window->DC.ColumnsOffset.x = 0.0f;
        window->DrawList->ChannelsSetCurrent(0);
        columns->Current = 0;
        columns->LineMinY = columns->LineMaxY;
    }
    window->DC.CursorPos.x = (float)(int)(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);
    window->DC.CursorPos.y = columns->LineMinY;
    window->DC.CurrentLineSize = ImVec2(0.0f, 0.0f);
    window->DC.CurrentLineTextBaseOffset = 0.0f;

    PushColumnClipRect();
    PushItemWidth(GetColumnWidth() * 0.65f);  // FIXME-COLUMNS: Move on columns setup
}

int ImGui::GetColumnIndex()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.CurrentColumns ? window->DC.CurrentColumns->Current : 0;
}

int ImGui::GetColumnsCount()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.CurrentColumns ? window->DC.CurrentColumns->Count : 1;
}

static float OffsetNormToPixels(const ImGuiColumns* columns, float offset_norm)
{
    return offset_norm * (columns->MaxX - columns->MinX);
}

static float PixelsToOffsetNorm(const ImGuiColumns* columns, float offset)
{
    return offset / (columns->MaxX - columns->MinX);
}

static const float COLUMNS_HIT_RECT_HALF_WIDTH = 4.0f;

static float GetDraggedColumnOffset(ImGuiColumns* columns, int column_index)
{
    // Active (dragged) column always follow mouse. The reason we need this is that dragging a column to the right edge of an auto-resizing
    // window creates a feedback loop because we store normalized positions. So while dragging we enforce absolute positioning.
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    IM_ASSERT(column_index > 0); // We are not supposed to drag column 0.
    IM_ASSERT(g.ActiveId == columns->ID + ImGuiID(column_index));

    float x = g.IO.MousePos.x - g.ActiveIdClickOffset.x + COLUMNS_HIT_RECT_HALF_WIDTH - window->Pos.x;
    x = ImMax(x, ImGui::GetColumnOffset(column_index - 1) + g.Style.ColumnsMinSpacing);
    if ((columns->Flags & ImGuiColumnsFlags_NoPreserveWidths))
        x = ImMin(x, ImGui::GetColumnOffset(column_index + 1) - g.Style.ColumnsMinSpacing);

    return x;
}

float ImGui::GetColumnOffset(int column_index)
{
    ImGuiWindow* window = GetCurrentWindowRead();
    ImGuiColumns* columns = window->DC.CurrentColumns;
    IM_ASSERT(columns != NULL);

    if (column_index < 0)
        column_index = columns->Current;
    IM_ASSERT(column_index < columns->Columns.Size);

    const float t = columns->Columns[column_index].OffsetNorm;
    const float x_offset = ImLerp(columns->MinX, columns->MaxX, t);
    return x_offset;
}

static float GetColumnWidthEx(ImGuiColumns* columns, int column_index, bool before_resize = false)
{
    if (column_index < 0)
        column_index = columns->Current;

    float offset_norm;
    if (before_resize)
        offset_norm = columns->Columns[column_index + 1].OffsetNormBeforeResize - columns->Columns[column_index].OffsetNormBeforeResize;
    else
        offset_norm = columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm;
    return OffsetNormToPixels(columns, offset_norm);
}

float ImGui::GetColumnWidth(int column_index)
{
    ImGuiWindow* window = GetCurrentWindowRead();
    ImGuiColumns* columns = window->DC.CurrentColumns;
    IM_ASSERT(columns != NULL);

    if (column_index < 0)
        column_index = columns->Current;
    return OffsetNormToPixels(columns, columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm);
}

void ImGui::SetColumnOffset(int column_index, float offset)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImGuiColumns* columns = window->DC.CurrentColumns;
    IM_ASSERT(columns != NULL);

    if (column_index < 0)
        column_index = columns->Current;
    IM_ASSERT(column_index < columns->Columns.Size);

    const bool preserve_width = !(columns->Flags & ImGuiColumnsFlags_NoPreserveWidths) && (column_index < columns->Count-1);
    const float width = preserve_width ? GetColumnWidthEx(columns, column_index, columns->IsBeingResized) : 0.0f;

    if (!(columns->Flags & ImGuiColumnsFlags_NoForceWithinWindow))
        offset = ImMin(offset, columns->MaxX - g.Style.ColumnsMinSpacing * (columns->Count - column_index));
    columns->Columns[column_index].OffsetNorm = PixelsToOffsetNorm(columns, offset - columns->MinX);

    if (preserve_width)
        SetColumnOffset(column_index + 1, offset + ImMax(g.Style.ColumnsMinSpacing, width));
}

void ImGui::SetColumnWidth(int column_index, float width)
{
    ImGuiWindow* window = GetCurrentWindowRead();
    ImGuiColumns* columns = window->DC.CurrentColumns;
    IM_ASSERT(columns != NULL);

    if (column_index < 0)
        column_index = columns->Current;
    SetColumnOffset(column_index + 1, GetColumnOffset(column_index) + width);
}

void ImGui::PushColumnClipRect(int column_index)
{
    ImGuiWindow* window = GetCurrentWindowRead();
    ImGuiColumns* columns = window->DC.CurrentColumns;
    if (column_index < 0)
        column_index = columns->Current;

    ImGuiColumnData* column = &columns->Columns[column_index];
    PushClipRect(column->ClipRect.Min, column->ClipRect.Max, false);
}

ImGuiColumns* ImGui::FindOrCreateColumns(ImGuiWindow* window, ImGuiID id)
{
    // We have few columns per window so for now we don't need bother much with turning this into a faster lookup.
    for (int n = 0; n < window->ColumnsStorage.Size; n++)
        if (window->ColumnsStorage[n].ID == id)
            return &window->ColumnsStorage[n];

    window->ColumnsStorage.push_back(ImGuiColumns());
    ImGuiColumns* columns = &window->ColumnsStorage.back();
    columns->ID = id;
    return columns;
}

ImGuiID ImGui::GetColumnsID(const char* str_id, int columns_count)
{
    ImGuiWindow* window = GetCurrentWindow();

    // Differentiate column ID with an arbitrary prefix for cases where users name their columns set the same as another widget.
    // In addition, when an identifier isn't explicitly provided we include the number of columns in the hash to make it uniquer.
    PushID(0x11223347 + (str_id ? 0 : columns_count));
    ImGuiID id = window->GetID(str_id ? str_id : "columns");
    PopID();

    return id;
}

void ImGui::BeginColumns(const char* str_id, int columns_count, ImGuiColumnsFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();

    IM_ASSERT(columns_count >= 1);
    IM_ASSERT(window->DC.CurrentColumns == NULL); // Nested columns are currently not supported

    ImGuiID id = GetColumnsID(str_id, columns_count);

    // Acquire storage for the columns set
    ImGuiColumns* columns = FindOrCreateColumns(window, id);
    IM_ASSERT(columns->ID == id);
    columns->Current = 0;
    columns->Count = columns_count;
    columns->Flags = flags;
    window->DC.CurrentColumns = columns;

    // Set state for first column
    const float content_region_width = (window->SizeContentsExplicit.x != 0.0f) ? (window->SizeContentsExplicit.x) : (window->InnerClipRect.Max.x - window->Pos.x);
    columns->MinX = window->DC.Indent.x - g.Style.ItemSpacing.x; // Lock our horizontal range
    columns->MaxX = ImMax(content_region_width - window->Scroll.x, columns->MinX + 1.0f);
    columns->BackupCursorPosY = window->DC.CursorPos.y;
    columns->BackupCursorMaxPosX = window->DC.CursorMaxPos.x;
    columns->LineMinY = columns->LineMaxY = window->DC.CursorPos.y;
    window->DC.ColumnsOffset.x = 0.0f;
    window->DC.CursorPos.x = (float)(int)(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);

    // Clear data if columns count changed
    if (columns->Columns.Size != 0 && columns->Columns.Size != columns_count + 1)
        columns->Columns.resize(0);

    // Initialize defaults
    columns->IsFirstFrame = (columns->Columns.Size == 0);
    if (columns->Columns.Size == 0)
    {
        columns->Columns.reserve(columns_count + 1);
        for (int n = 0; n < columns_count + 1; n++)
        {
            ImGuiColumnData column;
            column.OffsetNorm = n / (float)columns_count;
            columns->Columns.push_back(column);
        }
    }

    for (int n = 0; n < columns_count; n++)
    {
        // Compute clipping rectangle
        ImGuiColumnData* column = &columns->Columns[n];
        float clip_x1 = ImFloor(0.5f + window->Pos.x + GetColumnOffset(n));
        float clip_x2 = ImFloor(0.5f + window->Pos.x + GetColumnOffset(n + 1) - 1.0f);
        column->ClipRect = ImRect(clip_x1, -FLT_MAX, clip_x2, +FLT_MAX);
        column->ClipRect.ClipWith(window->ClipRect);
    }

    if (columns->Count > 1)
    {
        window->DrawList->ChannelsSplit(columns->Count);
        PushColumnClipRect();
    }
    PushItemWidth(GetColumnWidth() * 0.65f);
}

void ImGui::EndColumns()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();
    ImGuiColumns* columns = window->DC.CurrentColumns;
    IM_ASSERT(columns != NULL);

    PopItemWidth();
    if (columns->Count > 1)
    {
        PopClipRect();
        window->DrawList->ChannelsMerge();
    }

    columns->LineMaxY = ImMax(columns->LineMaxY, window->DC.CursorPos.y);
    window->DC.CursorPos.y = columns->LineMaxY;
    if (!(columns->Flags & ImGuiColumnsFlags_GrowParentContentsSize))
        window->DC.CursorMaxPos.x = columns->BackupCursorMaxPosX;  // Restore cursor max pos, as columns don't grow parent

    // Draw columns borders and handle resize
    bool is_being_resized = false;
    if (!(columns->Flags & ImGuiColumnsFlags_NoBorder) && !window->SkipItems)
    {
        // We clip Y boundaries CPU side because very long triangles are mishandled by some GPU drivers.
        const float y1 = ImMax(columns->BackupCursorPosY, window->ClipRect.Min.y);
        const float y2 = ImMin(window->DC.CursorPos.y, window->ClipRect.Max.y);
        int dragging_column = -1;
        for (int n = 1; n < columns->Count; n++)
        {
            ImGuiColumnData* column = &columns->Columns[n];
            float x = window->Pos.x + GetColumnOffset(n);
            const ImGuiID column_id = columns->ID + ImGuiID(n);
            const float column_hit_hw = COLUMNS_HIT_RECT_HALF_WIDTH;
            const ImRect column_hit_rect(ImVec2(x - column_hit_hw, y1), ImVec2(x + column_hit_hw, y2));
            KeepAliveID(column_id);
            if (IsClippedEx(column_hit_rect, column_id, false))
                continue;

            bool hovered = false, held = false;
            if (!(columns->Flags & ImGuiColumnsFlags_NoResize))
            {
                ButtonBehavior(column_hit_rect, column_id, &hovered, &held);
                if (hovered || held)
                    g.MouseCursor = ImGuiMouseCursor_ResizeEW;
                if (held && !(column->Flags & ImGuiColumnsFlags_NoResize))
                    dragging_column = n;
            }

            // Draw column
            const ImU32 col = GetColorU32(held ? ImGuiCol_SeparatorActive : hovered ? ImGuiCol_SeparatorHovered : ImGuiCol_Separator);
            const float xi = (float)(int)x;
            window->DrawList->AddLine(ImVec2(xi, y1 + 1.0f), ImVec2(xi, y2), col);
        }

        // Apply dragging after drawing the column lines, so our rendered lines are in sync with how items were displayed during the frame.
        if (dragging_column != -1)
        {
            if (!columns->IsBeingResized)
                for (int n = 0; n < columns->Count + 1; n++)
                    columns->Columns[n].OffsetNormBeforeResize = columns->Columns[n].OffsetNorm;
            columns->IsBeingResized = is_being_resized = true;
            float x = GetDraggedColumnOffset(columns, dragging_column);
            SetColumnOffset(dragging_column, x);
        }
    }
    columns->IsBeingResized = is_being_resized;

    window->DC.CurrentColumns = NULL;
    window->DC.ColumnsOffset.x = 0.0f;
    window->DC.CursorPos.x = (float)(int)(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);
}

// [2018-03: This is currently the only public API, while we are working on making BeginColumns/EndColumns user-facing]
void ImGui::Columns(int columns_count, const char* id, bool border)
{
    ImGuiWindow* window = GetCurrentWindow();
    IM_ASSERT(columns_count >= 1);

    ImGuiColumnsFlags flags = (border ? 0 : ImGuiColumnsFlags_NoBorder);
    //flags |= ImGuiColumnsFlags_NoPreserveWidths; // NB: Legacy behavior
    ImGuiColumns* columns = window->DC.CurrentColumns;
    if (columns != NULL && columns->Count == columns_count && columns->Flags == flags)
        return;

    if (columns != NULL)
        EndColumns();

    if (columns_count != 1)
        BeginColumns(id, columns_count, flags);
}

//-----------------------------------------------------------------------------
// [SECTION] DRAG AND DROP
//-----------------------------------------------------------------------------

void ImGui::ClearDragDrop()
{
    ImGuiContext& g = *GImGui;
    g.DragDropActive = false;
    g.DragDropPayload.Clear();
    g.DragDropAcceptFlags = ImGuiDragDropFlags_None;
    g.DragDropAcceptIdCurr = g.DragDropAcceptIdPrev = 0;
    g.DragDropAcceptIdCurrRectSurface = FLT_MAX;
    g.DragDropAcceptFrameCount = -1;

    g.DragDropPayloadBufHeap.clear();
    memset(&g.DragDropPayloadBufLocal, 0, sizeof(g.DragDropPayloadBufLocal));
}

// Call when current ID is active.
// When this returns true you need to: a) call SetDragDropPayload() exactly once, b) you may render the payload visual/description, c) call EndDragDropSource()
bool ImGui::BeginDragDropSource(ImGuiDragDropFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    bool source_drag_active = false;
    ImGuiID source_id = 0;
    ImGuiID source_parent_id = 0;
    int mouse_button = 0;
    if (!(flags & ImGuiDragDropFlags_SourceExtern))
    {
        source_id = window->DC.LastItemId;
        if (source_id != 0 && g.ActiveId != source_id) // Early out for most common case
            return false;
        if (g.IO.MouseDown[mouse_button] == false)
            return false;

        if (source_id == 0)
        {
            // If you want to use BeginDragDropSource() on an item with no unique identifier for interaction, such as Text() or Image(), you need to:
            // A) Read the explanation below, B) Use the ImGuiDragDropFlags_SourceAllowNullID flag, C) Swallow your programmer pride.
            if (!(flags & ImGuiDragDropFlags_SourceAllowNullID))
            {
                IM_ASSERT(0);
                return false;
            }

            // Early out
            if ((window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HoveredRect) == 0 && (g.ActiveId == 0 || g.ActiveIdWindow != window))
                return false;

            // Magic fallback (=somehow reprehensible) to handle items with no assigned ID, e.g. Text(), Image()
            // We build a throwaway ID based on current ID stack + relative AABB of items in window.
            // THE IDENTIFIER WON'T SURVIVE ANY REPOSITIONING OF THE WIDGET, so if your widget moves your dragging operation will be canceled.
            // We don't need to maintain/call ClearActiveID() as releasing the button will early out this function and trigger !ActiveIdIsAlive.
            source_id = window->DC.LastItemId = window->GetIDFromRectangle(window->DC.LastItemRect);
            bool is_hovered = ItemHoverable(window->DC.LastItemRect, source_id);
            if (is_hovered && g.IO.MouseClicked[mouse_button])
            {
                SetActiveID(source_id, window);
                FocusWindow(window);
            }
            if (g.ActiveId == source_id) // Allow the underlying widget to display/return hovered during the mouse release frame, else we would get a flicker.
                g.ActiveIdAllowOverlap = is_hovered;
        }
        else
        {
            g.ActiveIdAllowOverlap = false;
        }
        if (g.ActiveId != source_id)
            return false;
        source_parent_id = window->IDStack.back();
        source_drag_active = IsMouseDragging(mouse_button);
    }
    else
    {
        window = NULL;
        source_id = ImHashStr("#SourceExtern");
        source_drag_active = true;
    }

    if (source_drag_active)
    {
        if (!g.DragDropActive)
        {
            IM_ASSERT(source_id != 0);
            ClearDragDrop();
            ImGuiPayload& payload = g.DragDropPayload;
            payload.SourceId = source_id;
            payload.SourceParentId = source_parent_id;
            g.DragDropActive = true;
            g.DragDropSourceFlags = flags;
            g.DragDropMouseButton = mouse_button;
        }
        g.DragDropSourceFrameCount = g.FrameCount;
        g.DragDropWithinSourceOrTarget = true;

        if (!(flags & ImGuiDragDropFlags_SourceNoPreviewTooltip))
        {
            // Target can request the Source to not display its tooltip (we use a dedicated flag to make this request explicit)
            // We unfortunately can't just modify the source flags and skip the call to BeginTooltip, as caller may be emitting contents.
            BeginTooltip();
            if (g.DragDropAcceptIdPrev && (g.DragDropAcceptFlags & ImGuiDragDropFlags_AcceptNoPreviewTooltip))
            {
                ImGuiWindow* tooltip_window = g.CurrentWindow;
                tooltip_window->SkipItems = true;
                tooltip_window->HiddenFramesCanSkipItems = 1;
            }
        }

        if (!(flags & ImGuiDragDropFlags_SourceNoDisableHover) && !(flags & ImGuiDragDropFlags_SourceExtern))
            window->DC.LastItemStatusFlags &= ~ImGuiItemStatusFlags_HoveredRect;

        return true;
    }
    return false;
}

void ImGui::EndDragDropSource()
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.DragDropActive);
    IM_ASSERT(g.DragDropWithinSourceOrTarget && "Not after a BeginDragDropSource()?");

    if (!(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoPreviewTooltip))
        EndTooltip();

    // Discard the drag if have not called SetDragDropPayload()
    if (g.DragDropPayload.DataFrameCount == -1)
        ClearDragDrop();
    g.DragDropWithinSourceOrTarget = false;
}

// Use 'cond' to choose to submit payload on drag start or every frame
bool ImGui::SetDragDropPayload(const char* type, const void* data, size_t data_size, ImGuiCond cond)
{
    ImGuiContext& g = *GImGui;
    ImGuiPayload& payload = g.DragDropPayload;
    if (cond == 0)
        cond = ImGuiCond_Always;

    IM_ASSERT(type != NULL);
    IM_ASSERT(strlen(type) < IM_ARRAYSIZE(payload.DataType) && "Payload type can be at most 32 characters long");
    IM_ASSERT((data != NULL && data_size > 0) || (data == NULL && data_size == 0));
    IM_ASSERT(cond == ImGuiCond_Always || cond == ImGuiCond_Once);
    IM_ASSERT(payload.SourceId != 0);                               // Not called between BeginDragDropSource() and EndDragDropSource()

    if (cond == ImGuiCond_Always || payload.DataFrameCount == -1)
    {
        // Copy payload
        ImStrncpy(payload.DataType, type, IM_ARRAYSIZE(payload.DataType));
        g.DragDropPayloadBufHeap.resize(0);
        if (data_size > sizeof(g.DragDropPayloadBufLocal))
        {
            // Store in heap
            g.DragDropPayloadBufHeap.resize((int)data_size);
            payload.Data = g.DragDropPayloadBufHeap.Data;
            memcpy(payload.Data, data, data_size);
        }
        else if (data_size > 0)
        {
            // Store locally
            memset(&g.DragDropPayloadBufLocal, 0, sizeof(g.DragDropPayloadBufLocal));
            payload.Data = g.DragDropPayloadBufLocal;
            memcpy(payload.Data, data, data_size);
        }
        else
        {
            payload.Data = NULL;
        }
        payload.DataSize = (int)data_size;
    }
    payload.DataFrameCount = g.FrameCount;

    return (g.DragDropAcceptFrameCount == g.FrameCount) || (g.DragDropAcceptFrameCount == g.FrameCount - 1);
}

bool ImGui::BeginDragDropTargetCustom(const ImRect& bb, ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    if (!g.DragDropActive)
        return false;

    ImGuiWindow* window = g.CurrentWindow;
    if (g.HoveredWindow == NULL || window->RootWindow != g.HoveredWindow->RootWindow)
        return false;
    IM_ASSERT(id != 0);
    if (!IsMouseHoveringRect(bb.Min, bb.Max) || (id == g.DragDropPayload.SourceId))
        return false;
    if (window->SkipItems)
        return false;

    IM_ASSERT(g.DragDropWithinSourceOrTarget == false);
    g.DragDropTargetRect = bb;
    g.DragDropTargetId = id;
    g.DragDropWithinSourceOrTarget = true;
    return true;
}

// We don't use BeginDragDropTargetCustom() and duplicate its code because:
// 1) we use LastItemRectHoveredRect which handles items that pushes a temporarily clip rectangle in their code. Calling BeginDragDropTargetCustom(LastItemRect) would not handle them.
// 2) and it's faster. as this code may be very frequently called, we want to early out as fast as we can.
// Also note how the HoveredWindow test is positioned differently in both functions (in both functions we optimize for the cheapest early out case)
bool ImGui::BeginDragDropTarget()
{
    ImGuiContext& g = *GImGui;
    if (!g.DragDropActive)
        return false;

    ImGuiWindow* window = g.CurrentWindow;
    if (!(window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HoveredRect))
        return false;
    if (g.HoveredWindow == NULL || window->RootWindow != g.HoveredWindow->RootWindow)
        return false;

    const ImRect& display_rect = (window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HasDisplayRect) ? window->DC.LastItemDisplayRect : window->DC.LastItemRect;
    ImGuiID id = window->DC.LastItemId;
    if (id == 0)
        id = window->GetIDFromRectangle(display_rect);
    if (g.DragDropPayload.SourceId == id)
        return false;

    IM_ASSERT(g.DragDropWithinSourceOrTarget == false);
    g.DragDropTargetRect = display_rect;
    g.DragDropTargetId = id;
    g.DragDropWithinSourceOrTarget = true;
    return true;
}

bool ImGui::IsDragDropPayloadBeingAccepted()
{
    ImGuiContext& g = *GImGui;
    return g.DragDropActive && g.DragDropAcceptIdPrev != 0;
}

const ImGuiPayload* ImGui::AcceptDragDropPayload(const char* type, ImGuiDragDropFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImGuiPayload& payload = g.DragDropPayload;
    IM_ASSERT(g.DragDropActive);                        // Not called between BeginDragDropTarget() and EndDragDropTarget() ?
    IM_ASSERT(payload.DataFrameCount != -1);            // Forgot to call EndDragDropTarget() ?
    if (type != NULL && !payload.IsDataType(type))
        return NULL;

    // Accept smallest drag target bounding box, this allows us to nest drag targets conveniently without ordering constraints.
    // NB: We currently accept NULL id as target. However, overlapping targets requires a unique ID to function!
    const bool was_accepted_previously = (g.DragDropAcceptIdPrev == g.DragDropTargetId);
    ImRect r = g.DragDropTargetRect;
    float r_surface = r.GetWidth() * r.GetHeight();
    if (r_surface < g.DragDropAcceptIdCurrRectSurface)
    {
        g.DragDropAcceptFlags = flags;
        g.DragDropAcceptIdCurr = g.DragDropTargetId;
        g.DragDropAcceptIdCurrRectSurface = r_surface;
    }

    // Render default drop visuals
    payload.Preview = was_accepted_previously;
    flags |= (g.DragDropSourceFlags & ImGuiDragDropFlags_AcceptNoDrawDefaultRect); // Source can also inhibit the preview (useful for external sources that lives for 1 frame)
    if (!(flags & ImGuiDragDropFlags_AcceptNoDrawDefaultRect) && payload.Preview)
    {
        // FIXME-DRAG: Settle on a proper default visuals for drop target.
        r.Expand(3.5f);
        bool push_clip_rect = !window->ClipRect.Contains(r);
        if (push_clip_rect) window->DrawList->PushClipRect(r.Min-ImVec2(1,1), r.Max+ImVec2(1,1));
        window->DrawList->AddRect(r.Min, r.Max, GetColorU32(ImGuiCol_DragDropTarget), 0.0f, ~0, 2.0f);
        if (push_clip_rect) window->DrawList->PopClipRect();
    }

    g.DragDropAcceptFrameCount = g.FrameCount;
    payload.Delivery = was_accepted_previously && !IsMouseDown(g.DragDropMouseButton); // For extern drag sources affecting os window focus, it's easier to just test !IsMouseDown() instead of IsMouseReleased()
    if (!payload.Delivery && !(flags & ImGuiDragDropFlags_AcceptBeforeDelivery))
        return NULL;

    return &payload;
}

const ImGuiPayload* ImGui::GetDragDropPayload()
{
    ImGuiContext& g = *GImGui;
    return g.DragDropActive ? &g.DragDropPayload : NULL;
}

// We don't really use/need this now, but added it for the sake of consistency and because we might need it later.
void ImGui::EndDragDropTarget()
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.DragDropActive);
    IM_ASSERT(g.DragDropWithinSourceOrTarget);
    g.DragDropWithinSourceOrTarget = false;
}


//-----------------------------------------------------------------------------
// [SECTION] LOGGING/CAPTURING
//-----------------------------------------------------------------------------
// All text output from the interface can be captured into tty/file/clipboard.
// By default, tree nodes are automatically opened during logging.
//-----------------------------------------------------------------------------

// Pass text data straight to log (without being displayed)
void ImGui::LogText(const char* fmt, ...)
{
    ImGuiContext& g = *GImGui;
    if (!g.LogEnabled)
        return;

    va_list args;
    va_start(args, fmt);
    if (g.LogFile)
        vfprintf(g.LogFile, fmt, args);
    else
        g.LogBuffer.appendfv(fmt, args);
    va_end(args);
}

// Internal version that takes a position to decide on newline placement and pad items according to their depth.
// We split text into individual lines to add current tree level padding
void ImGui::LogRenderedText(const ImVec2* ref_pos, const char* text, const char* text_end)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    if (!text_end)
        text_end = FindRenderedTextEnd(text, text_end);

    const bool log_new_line = ref_pos && (ref_pos->y > g.LogLinePosY + 1);
    if (ref_pos)
        g.LogLinePosY = ref_pos->y;
    if (log_new_line)
        g.LogLineFirstItem = true;

    const char* text_remaining = text;
    if (g.LogDepthRef > window->DC.TreeDepth)  // Re-adjust padding if we have popped out of our starting depth
        g.LogDepthRef = window->DC.TreeDepth;
    const int tree_depth = (window->DC.TreeDepth - g.LogDepthRef);
    for (;;)
    {
        // Split the string. Each new line (after a '\n') is followed by spacing corresponding to the current depth of our log entry.
        // We don't add a trailing \n to allow a subsequent item on the same line to be captured.
        const char* line_start = text_remaining;
        const char* line_end = ImStreolRange(line_start, text_end);
        const bool is_first_line = (line_start == text);
        const bool is_last_line = (line_end == text_end);
        if (!is_last_line || (line_start != line_end))
        {
            const int char_count = (int)(line_end - line_start);
            if (log_new_line || !is_first_line)
                LogText(IM_NEWLINE "%*s%.*s", tree_depth * 4, "", char_count, line_start);
            else if (g.LogLineFirstItem)
                LogText("%*s%.*s", tree_depth * 4, "", char_count, line_start);
            else
                LogText(" %.*s", char_count, line_start);
            g.LogLineFirstItem = false;
        }
        else if (log_new_line)
        {
            // An empty "" string at a different Y position should output a carriage return.
            LogText(IM_NEWLINE);
            break;
        }

        if (is_last_line)
            break;
        text_remaining = line_end + 1;
    }
}

// Start logging/capturing text output
void ImGui::LogBegin(ImGuiLogType type, int auto_open_depth)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    IM_ASSERT(g.LogEnabled == false);
    IM_ASSERT(g.LogFile == NULL);
    IM_ASSERT(g.LogBuffer.empty());
    g.LogEnabled = true;
    g.LogType = type;
    g.LogDepthRef = window->DC.TreeDepth;
    g.LogDepthToExpand = ((auto_open_depth >= 0) ? auto_open_depth : g.LogDepthToExpandDefault);
    g.LogLinePosY = FLT_MAX;
    g.LogLineFirstItem = true;
}

void ImGui::LogToTTY(int auto_open_depth)
{
    ImGuiContext& g = *GImGui;
    if (g.LogEnabled)
        return;
    LogBegin(ImGuiLogType_TTY, auto_open_depth);
    g.LogFile = stdout;
}

// Start logging/capturing text output to given file
void ImGui::LogToFile(int auto_open_depth, const char* filename)
{
    ImGuiContext& g = *GImGui;
    if (g.LogEnabled)
        return;

    // FIXME: We could probably open the file in text mode "at", however note that clipboard/buffer logging will still
    // be subject to outputting OS-incompatible carriage return if within strings the user doesn't use IM_NEWLINE.
    // By opening the file in binary mode "ab" we have consistent output everywhere.
    if (!filename)
        filename = g.IO.LogFilename;
    if (!filename || !filename[0])
        return;
    FILE* f = ImFileOpen(filename, "ab");
    if (f == NULL)
    {
        IM_ASSERT(0);
        return;
    }

    LogBegin(ImGuiLogType_File, auto_open_depth);
    g.LogFile = f;
}

// Start logging/capturing text output to clipboard
void ImGui::LogToClipboard(int auto_open_depth)
{
    ImGuiContext& g = *GImGui;
    if (g.LogEnabled)
        return;
    LogBegin(ImGuiLogType_Clipboard, auto_open_depth);
}

void ImGui::LogToBuffer(int auto_open_depth)
{
    ImGuiContext& g = *GImGui;
    if (g.LogEnabled)
        return;
    LogBegin(ImGuiLogType_Buffer, auto_open_depth);
}

void ImGui::LogFinish()
{
    ImGuiContext& g = *GImGui;
    if (!g.LogEnabled)
        return;

    LogText(IM_NEWLINE);
    switch (g.LogType)
    {
    case ImGuiLogType_TTY:
        fflush(g.LogFile);
        break;
    case ImGuiLogType_File:
        fclose(g.LogFile);
        break;
    case ImGuiLogType_Buffer:
        break;
    case ImGuiLogType_Clipboard:
        if (!g.LogBuffer.empty())
            SetClipboardText(g.LogBuffer.begin());
        break;
    case ImGuiLogType_None:
        IM_ASSERT(0);
        break;
    }

    g.LogEnabled = false;
    g.LogType = ImGuiLogType_None;
    g.LogFile = NULL;
    g.LogBuffer.clear();
}

// Helper to display logging buttons
// FIXME-OBSOLETE: We should probably obsolete this and let the user have their own helper (this is one of the oldest function alive!)
void ImGui::LogButtons()
{
    ImGuiContext& g = *GImGui;

    PushID("LogButtons");
    const bool log_to_tty = Button("Log To TTY"); SameLine();
    const bool log_to_file = Button("Log To File"); SameLine();
    const bool log_to_clipboard = Button("Log To Clipboard"); SameLine();
    PushAllowKeyboardFocus(false);
    SetNextItemWidth(80.0f);
    SliderInt("Default Depth", &g.LogDepthToExpandDefault, 0, 9, NULL);
    PopAllowKeyboardFocus();
    PopID();

    // Start logging at the end of the function so that the buttons don't appear in the log
    if (log_to_tty)
        LogToTTY();
    if (log_to_file)
        LogToFile();
    if (log_to_clipboard)
        LogToClipboard();
}

//-----------------------------------------------------------------------------
// [SECTION] SETTINGS
//-----------------------------------------------------------------------------

void ImGui::MarkIniSettingsDirty()
{
    ImGuiContext& g = *GImGui;
    if (g.SettingsDirtyTimer <= 0.0f)
        g.SettingsDirtyTimer = g.IO.IniSavingRate;
}

void ImGui::MarkIniSettingsDirty(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    if (!(window->Flags & ImGuiWindowFlags_NoSavedSettings))
        if (g.SettingsDirtyTimer <= 0.0f)
            g.SettingsDirtyTimer = g.IO.IniSavingRate;
}

ImGuiWindowSettings* ImGui::CreateNewWindowSettings(const char* name)
{
    ImGuiContext& g = *GImGui;
    g.SettingsWindows.push_back(ImGuiWindowSettings());
    ImGuiWindowSettings* settings = &g.SettingsWindows.back();
    settings->Name = ImStrdup(name);
    settings->ID = ImHashStr(name);
    return settings;
}

ImGuiWindowSettings* ImGui::FindWindowSettings(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    for (int i = 0; i != g.SettingsWindows.Size; i++)
        if (g.SettingsWindows[i].ID == id)
            return &g.SettingsWindows[i];
    return NULL;
}

ImGuiWindowSettings* ImGui::FindOrCreateWindowSettings(const char* name)
{
    if (ImGuiWindowSettings* settings = FindWindowSettings(ImHashStr(name)))
        return settings;
    return CreateNewWindowSettings(name);
}

void ImGui::LoadIniSettingsFromDisk(const char* ini_filename)
{
    size_t file_data_size = 0;
    char* file_data = (char*)ImFileLoadToMemory(ini_filename, "rb", &file_data_size);
    if (!file_data)
        return;
    LoadIniSettingsFromMemory(file_data, (size_t)file_data_size);
    IM_FREE(file_data);
}

ImGuiSettingsHandler* ImGui::FindSettingsHandler(const char* type_name)
{
    ImGuiContext& g = *GImGui;
    const ImGuiID type_hash = ImHashStr(type_name);
    for (int handler_n = 0; handler_n < g.SettingsHandlers.Size; handler_n++)
        if (g.SettingsHandlers[handler_n].TypeHash == type_hash)
            return &g.SettingsHandlers[handler_n];
    return NULL;
}

// Zero-tolerance, no error reporting, cheap .ini parsing
void ImGui::LoadIniSettingsFromMemory(const char* ini_data, size_t ini_size)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.Initialized);
    IM_ASSERT(g.SettingsLoaded == false && g.FrameCount == 0);

    // For user convenience, we allow passing a non zero-terminated string (hence the ini_size parameter).
    // For our convenience and to make the code simpler, we'll also write zero-terminators within the buffer. So let's create a writable copy..
    if (ini_size == 0)
        ini_size = strlen(ini_data);
    char* buf = (char*)IM_ALLOC(ini_size + 1);
    char* buf_end = buf + ini_size;
    memcpy(buf, ini_data, ini_size);
    buf[ini_size] = 0;

    void* entry_data = NULL;
    ImGuiSettingsHandler* entry_handler = NULL;

    char* line_end = NULL;
    for (char* line = buf; line < buf_end; line = line_end + 1)
    {
        // Skip new lines markers, then find end of the line
        while (*line == '\n' || *line == '\r')
            line++;
        line_end = line;
        while (line_end < buf_end && *line_end != '\n' && *line_end != '\r')
            line_end++;
        line_end[0] = 0;
        if (line[0] == ';')
            continue;
        if (line[0] == '[' && line_end > line && line_end[-1] == ']')
        {
            // Parse "[Type][Name]". Note that 'Name' can itself contains [] characters, which is acceptable with the current format and parsing code.
            line_end[-1] = 0;
            const char* name_end = line_end - 1;
            const char* type_start = line + 1;
            char* type_end = (char*)(intptr_t)ImStrchrRange(type_start, name_end, ']');
            const char* name_start = type_end ? ImStrchrRange(type_end + 1, name_end, '[') : NULL;
            if (!type_end || !name_start)
            {
                name_start = type_start; // Import legacy entries that have no type
                type_start = "Window";
            }
            else
            {
                *type_end = 0; // Overwrite first ']'
                name_start++;  // Skip second '['
            }
            entry_handler = FindSettingsHandler(type_start);
            entry_data = entry_handler ? entry_handler->ReadOpenFn(&g, entry_handler, name_start) : NULL;
        }
        else if (entry_handler != NULL && entry_data != NULL)
        {
            // Let type handler parse the line
            entry_handler->ReadLineFn(&g, entry_handler, entry_data, line);
        }
    }
    IM_FREE(buf);
    g.SettingsLoaded = true;
}

void ImGui::SaveIniSettingsToDisk(const char* ini_filename)
{
    ImGuiContext& g = *GImGui;
    g.SettingsDirtyTimer = 0.0f;
    if (!ini_filename)
        return;

    size_t ini_data_size = 0;
    const char* ini_data = SaveIniSettingsToMemory(&ini_data_size);
    FILE* f = ImFileOpen(ini_filename, "wt");
    if (!f)
        return;
    fwrite(ini_data, sizeof(char), ini_data_size, f);
    fclose(f);
}

// Call registered handlers (e.g. SettingsHandlerWindow_WriteAll() + custom handlers) to write their stuff into a text buffer
const char* ImGui::SaveIniSettingsToMemory(size_t* out_size)
{
    ImGuiContext& g = *GImGui;
    g.SettingsDirtyTimer = 0.0f;
    g.SettingsIniData.Buf.resize(0);
    g.SettingsIniData.Buf.push_back(0);
    for (int handler_n = 0; handler_n < g.SettingsHandlers.Size; handler_n++)
    {
        ImGuiSettingsHandler* handler = &g.SettingsHandlers[handler_n];
        handler->WriteAllFn(&g, handler, &g.SettingsIniData);
    }
    if (out_size)
        *out_size = (size_t)g.SettingsIniData.size();
    return g.SettingsIniData.c_str();
}

static void* SettingsHandlerWindow_ReadOpen(ImGuiContext*, ImGuiSettingsHandler*, const char* name)
{
    ImGuiWindowSettings* settings = ImGui::FindWindowSettings(ImHashStr(name));
    if (!settings)
        settings = ImGui::CreateNewWindowSettings(name);
    return (void*)settings;
}

static void SettingsHandlerWindow_ReadLine(ImGuiContext* ctx, ImGuiSettingsHandler*, void* entry, const char* line)
{
    ImGuiContext& g = *ctx;
    ImGuiWindowSettings* settings = (ImGuiWindowSettings*)entry;
    float x, y;
    int i;
    if (sscanf(line, "Pos=%f,%f", &x, &y) == 2)         settings->Pos = ImVec2(x, y);
    else if (sscanf(line, "Size=%f,%f", &x, &y) == 2)   settings->Size = ImMax(ImVec2(x, y), g.Style.WindowMinSize);
    else if (sscanf(line, "Collapsed=%d", &i) == 1)     settings->Collapsed = (i != 0);
}

static void SettingsHandlerWindow_WriteAll(ImGuiContext* ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* buf)
{
    // Gather data from windows that were active during this session
    // (if a window wasn't opened in this session we preserve its settings)
    ImGuiContext& g = *ctx;
    for (int i = 0; i != g.Windows.Size; i++)
    {
        ImGuiWindow* window = g.Windows[i];
        if (window->Flags & ImGuiWindowFlags_NoSavedSettings)
            continue;

        ImGuiWindowSettings* settings = (window->SettingsIdx != -1) ? &g.SettingsWindows[window->SettingsIdx] : ImGui::FindWindowSettings(window->ID);
        if (!settings)
        {
            settings = ImGui::CreateNewWindowSettings(window->Name);
            window->SettingsIdx = g.SettingsWindows.index_from_ptr(settings);
        }
        IM_ASSERT(settings->ID == window->ID);
        settings->Pos = window->Pos;
        settings->Size = window->SizeFull;
        settings->Collapsed = window->Collapsed;
    }

    // Write to text buffer
    buf->reserve(buf->size() + g.SettingsWindows.Size * 96); // ballpark reserve
    for (int i = 0; i != g.SettingsWindows.Size; i++)
    {
        const ImGuiWindowSettings* settings = &g.SettingsWindows[i];
        if (settings->Pos.x == FLT_MAX)
            continue;
        const char* name = settings->Name;
        if (const char* p = strstr(name, "###"))  // Skip to the "###" marker if any. We don't skip past to match the behavior of GetID()
            name = p;
        buf->appendf("[%s][%s]\n", handler->TypeName, name);
        buf->appendf("Pos=%d,%d\n", (int)settings->Pos.x, (int)settings->Pos.y);
        buf->appendf("Size=%d,%d\n", (int)settings->Size.x, (int)settings->Size.y);
        buf->appendf("Collapsed=%d\n", settings->Collapsed);
        buf->appendf("\n");
    }
}


//-----------------------------------------------------------------------------
// [SECTION] VIEWPORTS, PLATFORM WINDOWS
//-----------------------------------------------------------------------------

// (this section is filled in the 'docking' branch)


//-----------------------------------------------------------------------------
// [SECTION] DOCKING
//-----------------------------------------------------------------------------

// (this section is filled in the 'docking' branch)


//-----------------------------------------------------------------------------
// [SECTION] PLATFORM DEPENDENT HELPERS
//-----------------------------------------------------------------------------

#if defined(_WIN32) && !defined(_WINDOWS_) && !defined(IMGUI_DISABLE_WIN32_FUNCTIONS) && (!defined(IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS) || !defined(IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS))
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#ifndef __MINGW32__
#include <Windows.h>
#else
#include <windows.h>
#endif
#endif

// Win32 API clipboard implementation
#if defined(_WIN32) && !defined(IMGUI_DISABLE_WIN32_FUNCTIONS) && !defined(IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS)

#ifdef _MSC_VER
#pragma comment(lib, "user32")
#endif

static const char* GetClipboardTextFn_DefaultImpl(void*)
{
    static ImVector<char> buf_local;
    buf_local.clear();
    if (!::OpenClipboard(NULL))
        return NULL;
    HANDLE wbuf_handle = ::GetClipboardData(CF_UNICODETEXT);
    if (wbuf_handle == NULL)
    {
        ::CloseClipboard();
        return NULL;
    }
    if (ImWchar* wbuf_global = (ImWchar*)::GlobalLock(wbuf_handle))
    {
        int buf_len = ImTextCountUtf8BytesFromStr(wbuf_global, NULL) + 1;
        buf_local.resize(buf_len);
        ImTextStrToUtf8(buf_local.Data, buf_len, wbuf_global, NULL);
    }
    ::GlobalUnlock(wbuf_handle);
    ::CloseClipboard();
    return buf_local.Data;
}

static void SetClipboardTextFn_DefaultImpl(void*, const char* text)
{
    if (!::OpenClipboard(NULL))
        return;
    const int wbuf_length = ImTextCountCharsFromUtf8(text, NULL) + 1;
    HGLOBAL wbuf_handle = ::GlobalAlloc(GMEM_MOVEABLE, (SIZE_T)wbuf_length * sizeof(ImWchar));
    if (wbuf_handle == NULL)
    {
        ::CloseClipboard();
        return;
    }
    ImWchar* wbuf_global = (ImWchar*)::GlobalLock(wbuf_handle);
    ImTextStrFromUtf8(wbuf_global, wbuf_length, text, NULL);
    ::GlobalUnlock(wbuf_handle);
    ::EmptyClipboard();
    if (::SetClipboardData(CF_UNICODETEXT, wbuf_handle) == NULL)
        ::GlobalFree(wbuf_handle);
    ::CloseClipboard();
}

#else

// Local ImGui-only clipboard implementation, if user hasn't defined better clipboard handlers
static const char* GetClipboardTextFn_DefaultImpl(void*)
{
    ImGuiContext& g = *GImGui;
    return g.PrivateClipboard.empty() ? NULL : g.PrivateClipboard.begin();
}

// Local ImGui-only clipboard implementation, if user hasn't defined better clipboard handlers
static void SetClipboardTextFn_DefaultImpl(void*, const char* text)
{
    ImGuiContext& g = *GImGui;
    g.PrivateClipboard.clear();
    const char* text_end = text + strlen(text);
    g.PrivateClipboard.resize((int)(text_end - text) + 1);
    memcpy(&g.PrivateClipboard[0], text, (size_t)(text_end - text));
    g.PrivateClipboard[(int)(text_end - text)] = 0;
}

#endif

// Win32 API IME support (for Asian languages, etc.)
#if defined(_WIN32) && !defined(__GNUC__) && !defined(IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS)

#include <imm.h>
#ifdef _MSC_VER
#pragma comment(lib, "imm32")
#endif

static void ImeSetInputScreenPosFn_DefaultImpl(int x, int y)
{
    // Notify OS Input Method Editor of text input position
    if (HWND hwnd = (HWND)GImGui->IO.ImeWindowHandle)
        if (HIMC himc = ::ImmGetContext(hwnd))
        {
            COMPOSITIONFORM cf;
            cf.ptCurrentPos.x = x;
            cf.ptCurrentPos.y = y;
            cf.dwStyle = CFS_FORCE_POSITION;
            ::ImmSetCompositionWindow(himc, &cf);
            ::ImmReleaseContext(hwnd, himc);
        }
}

#else

static void ImeSetInputScreenPosFn_DefaultImpl(int, int) {}

#endif

//-----------------------------------------------------------------------------
// [SECTION] METRICS/DEBUG WINDOW
//-----------------------------------------------------------------------------

void ImGui::ShowMetricsWindow(bool* p_open)
{
    if (!ImGui::Begin("ImGui Metrics", p_open))
    {
        ImGui::End();
        return;
    }

    enum { RT_OuterRect, RT_OuterRectClipped, RT_InnerMainRect, RT_InnerClipRect, RT_ContentsRegionRect, RT_ContentsFullRect };
    static bool show_windows_begin_order = false;
    static bool show_windows_rects = false;
    static int  show_windows_rect_type = RT_ContentsRegionRect;
    static bool show_drawcmd_clip_rects = true;

    ImGuiIO& io = ImGui::GetIO();
    ImGui::Text("Dear ImGui %s", ImGui::GetVersion());
    ImGui::Text("Application average %.3f ms/frame (%.1f FPS)", 1000.0f / io.Framerate, io.Framerate);
    ImGui::Text("%d vertices, %d indices (%d triangles)", io.MetricsRenderVertices, io.MetricsRenderIndices, io.MetricsRenderIndices / 3);
    ImGui::Text("%d active windows (%d visible)", io.MetricsActiveWindows, io.MetricsRenderWindows);
    ImGui::Text("%d active allocations", io.MetricsActiveAllocations);
    ImGui::Separator();

    struct Funcs
    {
        static void NodeDrawList(ImGuiWindow* window, ImDrawList* draw_list, const char* label)
        {
            bool node_open = ImGui::TreeNode(draw_list, "%s: '%s' %d vtx, %d indices, %d cmds", label, draw_list->_OwnerName ? draw_list->_OwnerName : "", draw_list->VtxBuffer.Size, draw_list->IdxBuffer.Size, draw_list->CmdBuffer.Size);
            if (draw_list == ImGui::GetWindowDrawList())
            {
                ImGui::SameLine();
                ImGui::TextColored(ImVec4(1.0f,0.4f,0.4f,1.0f), "CURRENTLY APPENDING"); // Can't display stats for active draw list! (we don't have the data double-buffered)
                if (node_open) ImGui::TreePop();
                return;
            }

            ImDrawList* fg_draw_list = GetForegroundDrawList(window); // Render additional visuals into the top-most draw list
            if (window && IsItemHovered())
                fg_draw_list->AddRect(window->Pos, window->Pos + window->Size, IM_COL32(255, 255, 0, 255));
            if (!node_open)
                return;

            int elem_offset = 0;
            for (const ImDrawCmd* pcmd = draw_list->CmdBuffer.begin(); pcmd < draw_list->CmdBuffer.end(); elem_offset += pcmd->ElemCount, pcmd++)
            {
                if (pcmd->UserCallback == NULL && pcmd->ElemCount == 0)
                    continue;
                if (pcmd->UserCallback)
                {
                    ImGui::BulletText("Callback %p, user_data %p", pcmd->UserCallback, pcmd->UserCallbackData);
                    continue;
                }
                ImDrawIdx* idx_buffer = (draw_list->IdxBuffer.Size > 0) ? draw_list->IdxBuffer.Data : NULL;
                bool pcmd_node_open = ImGui::TreeNode((void*)(pcmd - draw_list->CmdBuffer.begin()), "Draw %4d %s vtx, tex 0x%p, clip_rect (%4.0f,%4.0f)-(%4.0f,%4.0f)", pcmd->ElemCount, draw_list->IdxBuffer.Size > 0 ? "indexed" : "non-indexed", pcmd->TextureId, pcmd->ClipRect.x, pcmd->ClipRect.y, pcmd->ClipRect.z, pcmd->ClipRect.w);
                if (show_drawcmd_clip_rects && fg_draw_list && ImGui::IsItemHovered())
                {
                    ImRect clip_rect = pcmd->ClipRect;
                    ImRect vtxs_rect;
                    for (int i = elem_offset; i < elem_offset + (int)pcmd->ElemCount; i++)
                        vtxs_rect.Add(draw_list->VtxBuffer[idx_buffer ? idx_buffer[i] : i].pos);
                    clip_rect.Floor(); fg_draw_list->AddRect(clip_rect.Min, clip_rect.Max, IM_COL32(255,255,0,255));
                    vtxs_rect.Floor(); fg_draw_list->AddRect(vtxs_rect.Min, vtxs_rect.Max, IM_COL32(255,0,255,255));
                }
                if (!pcmd_node_open)
                    continue;

                // Display individual triangles/vertices. Hover on to get the corresponding triangle highlighted.
                ImGuiListClipper clipper(pcmd->ElemCount/3); // Manually coarse clip our print out of individual vertices to save CPU, only items that may be visible.
                while (clipper.Step())
                    for (int prim = clipper.DisplayStart, idx_i = elem_offset + clipper.DisplayStart*3; prim < clipper.DisplayEnd; prim++)
                    {
                        char buf[300];
                        char *buf_p = buf, *buf_end = buf + IM_ARRAYSIZE(buf);
                        ImVec2 triangles_pos[3];
                        for (int n = 0; n < 3; n++, idx_i++)
                        {
                            int vtx_i = idx_buffer ? idx_buffer[idx_i] : idx_i;
                            ImDrawVert& v = draw_list->VtxBuffer[vtx_i];
                            triangles_pos[n] = v.pos;
                            buf_p += ImFormatString(buf_p, buf_end - buf_p, "%s %04d: pos (%8.2f,%8.2f), uv (%.6f,%.6f), col %08X\n",
                                (n == 0) ? "idx" : "   ", idx_i, v.pos.x, v.pos.y, v.uv.x, v.uv.y, v.col);
                        }
                        ImGui::Selectable(buf, false);
                        if (fg_draw_list && ImGui::IsItemHovered())
                        {
                            ImDrawListFlags backup_flags = fg_draw_list->Flags;
                            fg_draw_list->Flags &= ~ImDrawListFlags_AntiAliasedLines; // Disable AA on triangle outlines at is more readable for very large and thin triangles.
                            fg_draw_list->AddPolyline(triangles_pos, 3, IM_COL32(255,255,0,255), true, 1.0f);
                            fg_draw_list->Flags = backup_flags;
                        }
                    }
                ImGui::TreePop();
            }
            ImGui::TreePop();
        }

        static void NodeColumns(const ImGuiColumns* columns)
        {
            if (!ImGui::TreeNode((void*)(uintptr_t)columns->ID, "Columns Id: 0x%08X, Count: %d, Flags: 0x%04X", columns->ID, columns->Count, columns->Flags))
                return;
            ImGui::BulletText("Width: %.1f (MinX: %.1f, MaxX: %.1f)", columns->MaxX - columns->MinX, columns->MinX, columns->MaxX);
            for (int column_n = 0; column_n < columns->Columns.Size; column_n++)
                ImGui::BulletText("Column %02d: OffsetNorm %.3f (= %.1f px)", column_n, columns->Columns[column_n].OffsetNorm, OffsetNormToPixels(columns, columns->Columns[column_n].OffsetNorm));
            ImGui::TreePop();
        }

        static void NodeWindows(ImVector<ImGuiWindow*>& windows, const char* label)
        {
            if (!ImGui::TreeNode(label, "%s (%d)", label, windows.Size))
                return;
            for (int i = 0; i < windows.Size; i++)
                Funcs::NodeWindow(windows[i], "Window");
            ImGui::TreePop();
        }

        static void NodeWindow(ImGuiWindow* window, const char* label)
        {
            if (!ImGui::TreeNode(window, "%s '%s', %d @ 0x%p", label, window->Name, window->Active || window->WasActive, window))
                return;
            ImGuiWindowFlags flags = window->Flags;
            NodeDrawList(window, window->DrawList, "DrawList");
            ImGui::BulletText("Pos: (%.1f,%.1f), Size: (%.1f,%.1f), SizeContents (%.1f,%.1f)", window->Pos.x, window->Pos.y, window->Size.x, window->Size.y, window->SizeContents.x, window->SizeContents.y);
            ImGui::BulletText("Flags: 0x%08X (%s%s%s%s%s%s%s%s%s..)", flags,
                (flags & ImGuiWindowFlags_ChildWindow)  ? "Child " : "",      (flags & ImGuiWindowFlags_Tooltip)     ? "Tooltip "   : "",  (flags & ImGuiWindowFlags_Popup) ? "Popup " : "",
                (flags & ImGuiWindowFlags_Modal)        ? "Modal " : "",      (flags & ImGuiWindowFlags_ChildMenu)   ? "ChildMenu " : "",  (flags & ImGuiWindowFlags_NoSavedSettings) ? "NoSavedSettings " : "",
                (flags & ImGuiWindowFlags_NoMouseInputs)? "NoMouseInputs":"", (flags & ImGuiWindowFlags_NoNavInputs) ? "NoNavInputs" : "", (flags & ImGuiWindowFlags_AlwaysAutoResize) ? "AlwaysAutoResize" : "");
            ImGui::BulletText("Scroll: (%.2f/%.2f,%.2f/%.2f)", window->Scroll.x, GetWindowScrollMaxX(window), window->Scroll.y, GetWindowScrollMaxY(window));
            ImGui::BulletText("Active: %d/%d, WriteAccessed: %d, BeginOrderWithinContext: %d", window->Active, window->WasActive, window->WriteAccessed, (window->Active || window->WasActive) ? window->BeginOrderWithinContext : -1);
            ImGui::BulletText("Appearing: %d, Hidden: %d (CanSkip %d Cannot %d), SkipItems: %d", window->Appearing, window->Hidden, window->HiddenFramesCanSkipItems, window->HiddenFramesCannotSkipItems, window->SkipItems);
            ImGui::BulletText("NavLastIds: 0x%08X,0x%08X, NavLayerActiveMask: %X", window->NavLastIds[0], window->NavLastIds[1], window->DC.NavLayerActiveMask);
            ImGui::BulletText("NavLastChildNavWindow: %s", window->NavLastChildNavWindow ? window->NavLastChildNavWindow->Name : "NULL");
            if (!window->NavRectRel[0].IsInverted())
                ImGui::BulletText("NavRectRel[0]: (%.1f,%.1f)(%.1f,%.1f)", window->NavRectRel[0].Min.x, window->NavRectRel[0].Min.y, window->NavRectRel[0].Max.x, window->NavRectRel[0].Max.y);
            else
                ImGui::BulletText("NavRectRel[0]: <None>");
            if (window->RootWindow != window) NodeWindow(window->RootWindow, "RootWindow");
            if (window->ParentWindow != NULL) NodeWindow(window->ParentWindow, "ParentWindow");
            if (window->DC.ChildWindows.Size > 0) NodeWindows(window->DC.ChildWindows, "ChildWindows");
            if (window->ColumnsStorage.Size > 0 && ImGui::TreeNode("Columns", "Columns sets (%d)", window->ColumnsStorage.Size))
            {
                for (int n = 0; n < window->ColumnsStorage.Size; n++)
                    NodeColumns(&window->ColumnsStorage[n]);
                ImGui::TreePop();
            }
            ImGui::BulletText("Storage: %d bytes", window->StateStorage.Data.Size * (int)sizeof(ImGuiStorage::Pair));
            ImGui::TreePop();
        }

        static void NodeTabBar(ImGuiTabBar* tab_bar)
        {
            // Standalone tab bars (not associated to docking/windows functionality) currently hold no discernible strings.
            char buf[256];
            char* p = buf;
            const char* buf_end = buf + IM_ARRAYSIZE(buf);
            ImFormatString(p, buf_end - p, "TabBar (%d tabs)%s", tab_bar->Tabs.Size, (tab_bar->PrevFrameVisible < ImGui::GetFrameCount() - 2) ? " *Inactive*" : "");
            if (ImGui::TreeNode(tab_bar, "%s", buf))
            {
                for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)
                {
                    const ImGuiTabItem* tab = &tab_bar->Tabs[tab_n];
                    ImGui::PushID(tab);
                    if (ImGui::SmallButton("<")) { TabBarQueueChangeTabOrder(tab_bar, tab, -1); } ImGui::SameLine(0, 2);
                    if (ImGui::SmallButton(">")) { TabBarQueueChangeTabOrder(tab_bar, tab, +1); } ImGui::SameLine();
                    ImGui::Text("%02d%c Tab 0x%08X", tab_n, (tab->ID == tab_bar->SelectedTabId) ? '*' : ' ', tab->ID);
                    ImGui::PopID();
                }
                ImGui::TreePop();
            }
        }
    };

    // Access private state, we are going to display the draw lists from last frame
    ImGuiContext& g = *GImGui;
    Funcs::NodeWindows(g.Windows, "Windows");
    if (ImGui::TreeNode("DrawList", "Active DrawLists (%d)", g.DrawDataBuilder.Layers[0].Size))
    {
        for (int i = 0; i < g.DrawDataBuilder.Layers[0].Size; i++)
            Funcs::NodeDrawList(NULL, g.DrawDataBuilder.Layers[0][i], "DrawList");
        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Popups", "Popups (%d)", g.OpenPopupStack.Size))
    {
        for (int i = 0; i < g.OpenPopupStack.Size; i++)
        {
            ImGuiWindow* window = g.OpenPopupStack[i].Window;
            ImGui::BulletText("PopupID: %08x, Window: '%s'%s%s", g.OpenPopupStack[i].PopupId, window ? window->Name : "NULL", window && (window->Flags & ImGuiWindowFlags_ChildWindow) ? " ChildWindow" : "", window && (window->Flags & ImGuiWindowFlags_ChildMenu) ? " ChildMenu" : "");
        }
        ImGui::TreePop();
    }

    if (ImGui::TreeNode("TabBars", "Tab Bars (%d)", g.TabBars.Data.Size))
    {
        for (int n = 0; n < g.TabBars.Data.Size; n++)
            Funcs::NodeTabBar(g.TabBars.GetByIndex(n));
        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Internal state"))
    {
        const char* input_source_names[] = { "None", "Mouse", "Nav", "NavKeyboard", "NavGamepad" }; IM_ASSERT(IM_ARRAYSIZE(input_source_names) == ImGuiInputSource_COUNT);
        ImGui::Text("HoveredWindow: '%s'", g.HoveredWindow ? g.HoveredWindow->Name : "NULL");
        ImGui::Text("HoveredRootWindow: '%s'", g.HoveredRootWindow ? g.HoveredRootWindow->Name : "NULL");
        ImGui::Text("HoveredId: 0x%08X/0x%08X (%.2f sec), AllowOverlap: %d", g.HoveredId, g.HoveredIdPreviousFrame, g.HoveredIdTimer, g.HoveredIdAllowOverlap); // Data is "in-flight" so depending on when the Metrics window is called we may see current frame information or not
        ImGui::Text("ActiveId: 0x%08X/0x%08X (%.2f sec), AllowOverlap: %d, Source: %s", g.ActiveId, g.ActiveIdPreviousFrame, g.ActiveIdTimer, g.ActiveIdAllowOverlap, input_source_names[g.ActiveIdSource]);
        ImGui::Text("ActiveIdWindow: '%s'", g.ActiveIdWindow ? g.ActiveIdWindow->Name : "NULL");
        ImGui::Text("MovingWindow: '%s'", g.MovingWindow ? g.MovingWindow->Name : "NULL");
        ImGui::Text("NavWindow: '%s'", g.NavWindow ? g.NavWindow->Name : "NULL");
        ImGui::Text("NavId: 0x%08X, NavLayer: %d", g.NavId, g.NavLayer);
        ImGui::Text("NavInputSource: %s", input_source_names[g.NavInputSource]);
        ImGui::Text("NavActive: %d, NavVisible: %d", g.IO.NavActive, g.IO.NavVisible);
        ImGui::Text("NavActivateId: 0x%08X, NavInputId: 0x%08X", g.NavActivateId, g.NavInputId);
        ImGui::Text("NavDisableHighlight: %d, NavDisableMouseHover: %d", g.NavDisableHighlight, g.NavDisableMouseHover);
        ImGui::Text("NavWindowingTarget: '%s'", g.NavWindowingTarget ? g.NavWindowingTarget->Name : "NULL");
        ImGui::Text("DragDrop: %d, SourceId = 0x%08X, Payload \"%s\" (%d bytes)", g.DragDropActive, g.DragDropPayload.SourceId, g.DragDropPayload.DataType, g.DragDropPayload.DataSize);
        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Tools"))
    {
        ImGui::Checkbox("Show windows begin order", &show_windows_begin_order);
        ImGui::Checkbox("Show windows rectangles", &show_windows_rects);
        ImGui::SameLine();
        ImGui::SetNextItemWidth(ImGui::GetFontSize() * 12);
        show_windows_rects |= ImGui::Combo("##rects_type", &show_windows_rect_type, "OuterRect\0" "OuterRectClipped\0" "InnerMainRect\0" "InnerClipRect\0" "ContentsRegionRect\0");
        ImGui::Checkbox("Show clipping rectangle when hovering ImDrawCmd node", &show_drawcmd_clip_rects);
        ImGui::TreePop();
    }

    if (show_windows_rects || show_windows_begin_order)
    {
        for (int n = 0; n < g.Windows.Size; n++)
        {
            ImGuiWindow* window = g.Windows[n];
            if (!window->WasActive)
                continue;
            ImDrawList* draw_list = GetForegroundDrawList(window);
            if (show_windows_rects)
            {
                ImRect r;
                if (show_windows_rect_type == RT_OuterRect)                 { r = window->Rect(); }
                else if (show_windows_rect_type == RT_OuterRectClipped)     { r = window->OuterRectClipped; }
                else if (show_windows_rect_type == RT_InnerMainRect)        { r = window->InnerMainRect; }
                else if (show_windows_rect_type == RT_InnerClipRect)        { r = window->InnerClipRect; }
                else if (show_windows_rect_type == RT_ContentsRegionRect)   { r = window->ContentsRegionRect; }
                draw_list->AddRect(r.Min, r.Max, IM_COL32(255, 0, 128, 255));
            }
            if (show_windows_begin_order && !(window->Flags & ImGuiWindowFlags_ChildWindow))
            {
                char buf[32];
                ImFormatString(buf, IM_ARRAYSIZE(buf), "%d", window->BeginOrderWithinContext);
                float font_size = ImGui::GetFontSize();
                draw_list->AddRectFilled(window->Pos, window->Pos + ImVec2(font_size, font_size), IM_COL32(200, 100, 100, 255));
                draw_list->AddText(window->Pos, IM_COL32(255, 255, 255, 255), buf);
            }
        }
    }
    ImGui::End();
}

//-----------------------------------------------------------------------------

// Include imgui_user.inl at the end of imgui.cpp to access private data/functions that aren't exposed.
// Prefer just including imgui_internal.h from your code rather than using this define. If a declaration is missing from imgui_internal.h add it or request it on the github.
#ifdef IMGUI_INCLUDE_IMGUI_USER_INL
#include "imgui_user.inl"
#endif

//-----------------------------------------------------------------------------

```

`UnrealFinderTool/ImGUI/imgui.h`:

```h
// dear imgui, v1.70
// (headers)

// See imgui.cpp file for documentation.
// Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp for demo code.
// Newcomers, read 'Programmer guide' in imgui.cpp for notes on how to setup Dear ImGui in your codebase.
// Get latest version at https://github.com/ocornut/imgui

/*

Index of this file:
// Header mess
// Forward declarations and basic types
// ImGui API (Dear ImGui end-user API)
// Flags & Enumerations
// Memory allocations macros
// ImVector<>
// ImGuiStyle
// ImGuiIO
// Misc data structures (ImGuiInputTextCallbackData, ImGuiSizeCallbackData, ImGuiPayload)
// Obsolete functions
// Helpers (ImGuiOnceUponAFrame, ImGuiTextFilter, ImGuiTextBuffer, ImGuiStorage, ImGuiListClipper, ImColor)
// Draw List API (ImDrawCallback, ImDrawCmd, ImDrawIdx, ImDrawVert, ImDrawChannel, ImDrawListFlags, ImDrawList, ImDrawData)
// Font API (ImFontConfig, ImFontGlyph, ImFontGlyphRangesBuilder, ImFontAtlasFlags, ImFontAtlas, ImFont)

*/

#pragma once

// Configuration file with compile-time options (edit imconfig.h or define IMGUI_USER_CONFIG to your own filename)
#ifdef IMGUI_USER_CONFIG
#include IMGUI_USER_CONFIG
#endif
#if !defined(IMGUI_DISABLE_INCLUDE_IMCONFIG_H) || defined(IMGUI_INCLUDE_IMCONFIG_H)
#include "imconfig.h"
#endif

//-----------------------------------------------------------------------------
// Header mess
//-----------------------------------------------------------------------------

#include <cfloat>                  // FLT_MAX
#include <stdarg.h>                 // va_list
#include <stddef.h>                 // ptrdiff_t, NULL
#include <cstring>                 // memset, memmove, memcpy, strlen, strchr, strcpy, strcmp

// Version
// (Integer encoded as XYYZZ for use in #if preprocessor conditionals. Work in progress versions typically starts at XYY99 then bounce up to XYY00, XYY01 etc. when release tagging happens)
#define IMGUI_VERSION               "1.70"
#define IMGUI_VERSION_NUM           17000
#define IMGUI_CHECKVERSION()        ImGui::DebugCheckVersionAndDataLayout(IMGUI_VERSION, sizeof(ImGuiIO), sizeof(ImGuiStyle), sizeof(ImVec2), sizeof(ImVec4), sizeof(ImDrawVert), sizeof(ImDrawIdx))

// Define attributes of all API symbols declarations (e.g. for DLL under Windows)
// IMGUI_API is used for core imgui functions, IMGUI_IMPL_API is used for the default bindings files (imgui_impl_xxx.h)
#ifndef IMGUI_API
#define IMGUI_API
#endif
#ifndef IMGUI_IMPL_API
#define IMGUI_IMPL_API              IMGUI_API
#endif

// Helper Macros
#ifndef IM_ASSERT
#include <assert.h>
#define IM_ASSERT(_EXPR)            assert(_EXPR)                               // You can override the default assert handler by editing imconfig.h
#endif
#if defined(__clang__) || defined(__GNUC__)
#define IM_FMTARGS(FMT)             __attribute__((format(printf, FMT, FMT+1))) // Apply printf-style warnings to user functions.
#define IM_FMTLIST(FMT)             __attribute__((format(printf, FMT, 0)))
#else
#define IM_FMTARGS(FMT)
#define IM_FMTLIST(FMT)
#endif
#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR)/sizeof(*_ARR)))         // Size of a static C-style array. Don't use on pointers!
#define IM_OFFSETOF(_TYPE,_MEMBER)  ((size_t)&(((_TYPE*)0)->_MEMBER))           // Offset of _MEMBER within _TYPE. Standardized as offsetof() in modern C++.
#define IM_UNUSED(_VAR)             ((void)_VAR)                                // Used to silence "unused variable warnings". Often useful as asserts may be stripped out from final builds.

// Warnings
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wold-style-cast"
#if __has_warning("-Wzero-as-null-pointer-constant")
#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"
#endif
#elif defined(__GNUC__) && __GNUC__ >= 8
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wclass-memaccess"
#endif

//-----------------------------------------------------------------------------
// Forward declarations and basic types
//-----------------------------------------------------------------------------

struct ImDrawChannel;               // Temporary storage for ImDrawList ot output draw commands out of order, used by ImDrawList::ChannelsSplit()
struct ImDrawCmd;                   // A single draw command within a parent ImDrawList (generally maps to 1 GPU draw call, unless it is a callback)
struct ImDrawData;                  // All draw command lists required to render the frame + pos/size coordinates to use for the projection matrix.
struct ImDrawList;                  // A single draw command list (generally one per window, conceptually you may see this as a dynamic "mesh" builder)
struct ImDrawListSharedData;        // Data shared among multiple draw lists (typically owned by parent ImGui context, but you may create one yourself)
struct ImDrawVert;                  // A single vertex (pos + uv + col = 20 bytes by default. Override layout with IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT)
struct ImFont;                      // Runtime data for a single font within a parent ImFontAtlas
struct ImFontAtlas;                 // Runtime data for multiple fonts, bake multiple fonts into a single texture, TTF/OTF font loader
struct ImFontConfig;                // Configuration data when adding a font or merging fonts
struct ImFontGlyph;                 // A single font glyph (code point + coordinates within in ImFontAtlas + offset)
struct ImFontGlyphRangesBuilder;    // Helper to build glyph ranges from text/string data
struct ImColor;                     // Helper functions to create a color that can be converted to either u32 or float4 (*OBSOLETE* please avoid using)
struct ImGuiContext;                // Dear ImGui context (opaque structure, unless including imgui_internal.h)
struct ImGuiIO;                     // Main configuration and I/O between your application and ImGui
struct ImGuiInputTextCallbackData;  // Shared state of InputText() when using custom ImGuiInputTextCallback (rare/advanced use)
struct ImGuiListClipper;            // Helper to manually clip large list of items
struct ImGuiOnceUponAFrame;         // Helper for running a block of code not more than once a frame, used by IMGUI_ONCE_UPON_A_FRAME macro
struct ImGuiPayload;                // User data payload for drag and drop operations
struct ImGuiSizeCallbackData;       // Callback data when using SetNextWindowSizeConstraints() (rare/advanced use)
struct ImGuiStorage;                // Helper for key->value storage
struct ImGuiStyle;                  // Runtime data for styling/colors
struct ImGuiTextBuffer;             // Helper to hold and append into a text buffer (~string builder)
struct ImGuiTextFilter;             // Helper to parse and apply text filters (e.g. "aaaaa[,bbbb][,ccccc]")

// Typedefs and Enums/Flags (declared as int for compatibility with old C++, to allow using as flags and to not pollute the top of this file)
// Use your programming IDE "Go to definition" facility on the names of the center columns to find the actual flags/enum lists.
#ifndef ImTextureID
typedef void* ImTextureID;          // User data to identify a texture (this is whatever to you want it to be! read the FAQ about ImTextureID in imgui.cpp)
#endif
typedef unsigned int ImGuiID;       // Unique ID used by widgets (typically hashed from a stack of string)
typedef unsigned short ImWchar;     // A single U16 character for keyboard input/display. We encode them as multi bytes UTF-8 when used in strings.
typedef int ImGuiCol;               // -> enum ImGuiCol_             // Enum: A color identifier for styling
typedef int ImGuiCond;              // -> enum ImGuiCond_            // Enum: A condition for Set*()
typedef int ImGuiDataType;          // -> enum ImGuiDataType_        // Enum: A primary data type
typedef int ImGuiDir;               // -> enum ImGuiDir_             // Enum: A cardinal direction
typedef int ImGuiKey;               // -> enum ImGuiKey_             // Enum: A key identifier (ImGui-side enum)
typedef int ImGuiNavInput;          // -> enum ImGuiNavInput_        // Enum: An input identifier for navigation
typedef int ImGuiMouseCursor;       // -> enum ImGuiMouseCursor_     // Enum: A mouse cursor identifier
typedef int ImGuiStyleVar;          // -> enum ImGuiStyleVar_        // Enum: A variable identifier for styling
typedef int ImDrawCornerFlags;      // -> enum ImDrawCornerFlags_    // Flags: for ImDrawList::AddRect*() etc.
typedef int ImDrawListFlags;        // -> enum ImDrawListFlags_      // Flags: for ImDrawList
typedef int ImFontAtlasFlags;       // -> enum ImFontAtlasFlags_     // Flags: for ImFontAtlas
typedef int ImGuiBackendFlags;      // -> enum ImGuiBackendFlags_    // Flags: for io.BackendFlags
typedef int ImGuiColorEditFlags;    // -> enum ImGuiColorEditFlags_  // Flags: for ColorEdit*(), ColorPicker*()
typedef int ImGuiColumnsFlags;      // -> enum ImGuiColumnsFlags_    // Flags: for Columns(), BeginColumns()
typedef int ImGuiConfigFlags;       // -> enum ImGuiConfigFlags_     // Flags: for io.ConfigFlags
typedef int ImGuiComboFlags;        // -> enum ImGuiComboFlags_      // Flags: for BeginCombo()
typedef int ImGuiDragDropFlags;     // -> enum ImGuiDragDropFlags_   // Flags: for *DragDrop*()
typedef int ImGuiFocusedFlags;      // -> enum ImGuiFocusedFlags_    // Flags: for IsWindowFocused()
typedef int ImGuiHoveredFlags;      // -> enum ImGuiHoveredFlags_    // Flags: for IsItemHovered(), IsWindowHovered() etc.
typedef int ImGuiInputTextFlags;    // -> enum ImGuiInputTextFlags_  // Flags: for InputText*()
typedef int ImGuiSelectableFlags;   // -> enum ImGuiSelectableFlags_ // Flags: for Selectable()
typedef int ImGuiTabBarFlags;       // -> enum ImGuiTabBarFlags_     // Flags: for BeginTabBar()
typedef int ImGuiTabItemFlags;      // -> enum ImGuiTabItemFlags_    // Flags: for BeginTabItem()
typedef int ImGuiTreeNodeFlags;     // -> enum ImGuiTreeNodeFlags_   // Flags: for TreeNode*(),CollapsingHeader()
typedef int ImGuiWindowFlags;       // -> enum ImGuiWindowFlags_     // Flags: for Begin*()
typedef int (*ImGuiInputTextCallback)(ImGuiInputTextCallbackData *data);
typedef void (*ImGuiSizeCallback)(ImGuiSizeCallbackData* data);

// Scalar data types
typedef signed char         ImS8;   // 8-bit signed integer == char
typedef unsigned char       ImU8;   // 8-bit unsigned integer
typedef signed short        ImS16;  // 16-bit signed integer
typedef unsigned short      ImU16;  // 16-bit unsigned integer
typedef signed int          ImS32;  // 32-bit signed integer == int
typedef unsigned int        ImU32;  // 32-bit unsigned integer (often used to store packed colors)
#if defined(_MSC_VER) && !defined(__clang__)
typedef signed   __int64    ImS64;  // 64-bit signed integer (pre and post C++11 with Visual Studio)
typedef unsigned __int64    ImU64;  // 64-bit unsigned integer (pre and post C++11 with Visual Studio)
#elif (defined(__clang__) || defined(__GNUC__)) && (__cplusplus < 201100)
#include <stdint.h>
typedef int64_t             ImS64;  // 64-bit signed integer (pre C++11)
typedef uint64_t            ImU64;  // 64-bit unsigned integer (pre C++11)
#else
typedef signed   long long  ImS64;  // 64-bit signed integer (post C++11)
typedef unsigned long long  ImU64;  // 64-bit unsigned integer (post C++11)
#endif

// 2D vector (often used to store positions, sizes, etc.)
struct ImVec2
{
    float     x, y;
    ImVec2()  { x = y = 0.0f; }
    ImVec2(float _x, float _y) { x = _x; y = _y; }
    float  operator[] (size_t idx) const { IM_ASSERT(idx <= 1); return (&x)[idx]; }    // We very rarely use this [] operator, the assert overhead is fine.
    float& operator[] (size_t idx)       { IM_ASSERT(idx <= 1); return (&x)[idx]; }    // We very rarely use this [] operator, the assert overhead is fine.
#ifdef IM_VEC2_CLASS_EXTRA
    IM_VEC2_CLASS_EXTRA     // Define additional constructors and implicit cast operators in imconfig.h to convert back and forth between your math types and ImVec2.
#endif
};

// 4D vector (often used to store floating-point colors)
struct ImVec4
{
    float     x, y, z, w;
    ImVec4()  { x = y = z = w = 0.0f; }
    ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }
#ifdef IM_VEC4_CLASS_EXTRA
    IM_VEC4_CLASS_EXTRA     // Define additional constructors and implicit cast operators in imconfig.h to convert back and forth between your math types and ImVec4.
#endif
};

//-----------------------------------------------------------------------------
// ImGui: Dear ImGui end-user API
// (Inside a namespace so you can add extra functions in your own separate file. Please don't modify imgui.cpp/.h!)
//-----------------------------------------------------------------------------

namespace ImGui
{
    // Context creation and access
    // Each context create its own ImFontAtlas by default. You may instance one yourself and pass it to CreateContext() to share a font atlas between imgui contexts.
    // All those functions are not reliant on the current context.
    IMGUI_API ImGuiContext* CreateContext(ImFontAtlas* shared_font_atlas = NULL);
    IMGUI_API void          DestroyContext(ImGuiContext* ctx = NULL);   // NULL = destroy current context
    IMGUI_API ImGuiContext* GetCurrentContext();
    IMGUI_API void          SetCurrentContext(ImGuiContext* ctx);
    IMGUI_API bool          DebugCheckVersionAndDataLayout(const char* version_str, size_t sz_io, size_t sz_style, size_t sz_vec2, size_t sz_vec4, size_t sz_drawvert, size_t sz_drawidx);

    // Main
    IMGUI_API ImGuiIO&      GetIO();                                    // access the IO structure (mouse/keyboard/gamepad inputs, time, various configuration options/flags)
    IMGUI_API ImGuiStyle&   GetStyle();                                 // access the Style structure (colors, sizes). Always use PushStyleCol(), PushStyleVar() to modify style mid-frame.
    IMGUI_API void          NewFrame();                                 // start a new Dear ImGui frame, you can submit any command from this point until Render()/EndFrame().
    IMGUI_API void          EndFrame();                                 // ends the Dear ImGui frame. automatically called by Render(), you likely don't need to call that yourself directly. If you don't need to render data (skipping rendering) you may call EndFrame() but you'll have wasted CPU already! If you don't need to render, better to not create any imgui windows and not call NewFrame() at all!
    IMGUI_API void          Render();                                   // ends the Dear ImGui frame, finalize the draw data. You can get call GetDrawData() to obtain it and run your rendering function. (Obsolete: this used to call io.RenderDrawListsFn(). Nowadays, we allow and prefer calling your render function yourself.)
    IMGUI_API ImDrawData*   GetDrawData();                              // valid after Render() and until the next call to NewFrame(). this is what you have to render.

    // Demo, Debug, Information
    IMGUI_API void          ShowDemoWindow(bool* p_open = NULL);        // create demo/test window (previously called ShowTestWindow). demonstrate most ImGui features. call this to learn about the library! try to make it always available in your application!
    IMGUI_API void          ShowAboutWindow(bool* p_open = NULL);       // create about window. display Dear ImGui version, credits and build/system information.
    IMGUI_API void          ShowMetricsWindow(bool* p_open = NULL);     // create metrics/debug window. display Dear ImGui internals: draw commands (with individual draw calls and vertices), window list, basic internal state, etc.
    IMGUI_API void          ShowStyleEditor(ImGuiStyle* ref = NULL);    // add style editor block (not a window). you can pass in a reference ImGuiStyle structure to compare to, revert to and save to (else it uses the default style)
    IMGUI_API bool          ShowStyleSelector(const char* label);       // add style selector block (not a window), essentially a combo listing the default styles.
    IMGUI_API void          ShowFontSelector(const char* label);        // add font selector block (not a window), essentially a combo listing the loaded fonts.
    IMGUI_API void          ShowUserGuide();                            // add basic help/info block (not a window): how to manipulate ImGui as a end-user (mouse/keyboard controls).
    IMGUI_API const char*   GetVersion();                               // get the compiled version string e.g. "1.23" (essentially the compiled value for IMGUI_VERSION)

    // Styles
    IMGUI_API void          StyleColorsDark(ImGuiStyle* dst = NULL);    // new, recommended style (default)
    IMGUI_API void          StyleColorsClassic(ImGuiStyle* dst = NULL); // classic imgui style
    IMGUI_API void          StyleColorsLight(ImGuiStyle* dst = NULL);   // best used with borders and a custom, thicker font

    // Windows
    // - Begin() = push window to the stack and start appending to it. End() = pop window from the stack.
    // - You may append multiple times to the same window during the same frame.
    // - Passing 'bool* p_open != NULL' shows a window-closing widget in the upper-right corner of the window,
    //   which clicking will set the boolean to false when clicked.
    // - Begin() return false to indicate the window is collapsed or fully clipped, so you may early out and omit submitting
    //   anything to the window. Always call a matching End() for each Begin() call, regardless of its return value!
    //   [this is due to legacy reason and is inconsistent with most other functions such as BeginMenu/EndMenu, BeginPopup/EndPopup, etc.
    //    where the EndXXX call should only be called if the corresponding BeginXXX function returned true.]
    // - Note that the bottom of window stack always contains a window called "Debug".
    IMGUI_API bool          Begin(const char* name, bool* p_open = NULL, ImGuiWindowFlags flags = 0);
    IMGUI_API void          End();

    // Child Windows
    // - Use child windows to begin into a self-contained independent scrolling/clipping regions within a host window. Child windows can embed their own child.
    // - For each independent axis of 'size': ==0.0f: use remaining host window size / >0.0f: fixed size / <0.0f: use remaining window size minus abs(size) / Each axis can use a different mode, e.g. ImVec2(0,400).
    // - BeginChild() returns false to indicate the window is collapsed or fully clipped, so you may early out and omit submitting anything to the window.
    //   Always call a matching EndChild() for each BeginChild() call, regardless of its return value [this is due to legacy reason and is inconsistent with most other functions such as BeginMenu/EndMenu, BeginPopup/EndPopup, etc. where the EndXXX call should only be called if the corresponding BeginXXX function returned true.]
    IMGUI_API bool          BeginChild(const char* str_id, const ImVec2& size = ImVec2(0,0), bool border = false, ImGuiWindowFlags flags = 0);
    IMGUI_API bool          BeginChild(ImGuiID id, const ImVec2& size = ImVec2(0,0), bool border = false, ImGuiWindowFlags flags = 0);
    IMGUI_API void          EndChild();

    // Windows Utilities
    // - "current window" = the window we are appending into while inside a Begin()/End() block. "next window" = next window we will Begin() into.
    IMGUI_API bool          IsWindowAppearing();
    IMGUI_API bool          IsWindowCollapsed();
    IMGUI_API bool          IsWindowFocused(ImGuiFocusedFlags flags=0); // is current window focused? or its root/child, depending on flags. see flags for options.
    IMGUI_API bool          IsWindowHovered(ImGuiHoveredFlags flags=0); // is current window hovered (and typically: not blocked by a popup/modal)? see flags for options. NB: If you are trying to check whether your mouse should be dispatched to imgui or to your app, you should use the 'io.WantCaptureMouse' boolean for that! Please read the FAQ!
    IMGUI_API ImDrawList*   GetWindowDrawList();                        // get draw list associated to the current window, to append your own drawing primitives
    IMGUI_API ImVec2        GetWindowPos();                             // get current window position in screen space (useful if you want to do your own drawing via the DrawList API)
    IMGUI_API ImVec2        GetWindowSize();                            // get current window size
    IMGUI_API float         GetWindowWidth();                           // get current window width (shortcut for GetWindowSize().x)
    IMGUI_API float         GetWindowHeight();                          // get current window height (shortcut for GetWindowSize().y)

    // Prefer using SetNextXXX functions (before Begin) rather that SetXXX functions (after Begin).
    IMGUI_API void          SetNextWindowPos(const ImVec2& pos, ImGuiCond cond = 0, const ImVec2& pivot = ImVec2(0,0)); // set next window position. call before Begin(). use pivot=(0.5f,0.5f) to center on given point, etc.
    IMGUI_API void          SetNextWindowSize(const ImVec2& size, ImGuiCond cond = 0);                  // set next window size. set axis to 0.0f to force an auto-fit on this axis. call before Begin()
    IMGUI_API void          SetNextWindowSizeConstraints(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeCallback custom_callback = NULL, void* custom_callback_data = NULL); // set next window size limits. use -1,-1 on either X/Y axis to preserve the current size. Sizes will be rounded down. Use callback to apply non-trivial programmatic constraints.
    IMGUI_API void          SetNextWindowContentSize(const ImVec2& size);                               // set next window content size (~ enforce the range of scrollbars). not including window decorations (title bar, menu bar, etc.). set an axis to 0.0f to leave it automatic. call before Begin()
    IMGUI_API void          SetNextWindowCollapsed(bool collapsed, ImGuiCond cond = 0);                 // set next window collapsed state. call before Begin()
    IMGUI_API void          SetNextWindowFocus();                                                       // set next window to be focused / front-most. call before Begin()
    IMGUI_API void          SetNextWindowBgAlpha(float alpha);                                          // set next window background color alpha. helper to easily modify ImGuiCol_WindowBg/ChildBg/PopupBg. you may also use ImGuiWindowFlags_NoBackground.
    IMGUI_API void          SetWindowPos(const ImVec2& pos, ImGuiCond cond = 0);                        // (not recommended) set current window position - call within Begin()/End(). prefer using SetNextWindowPos(), as this may incur tearing and side-effects.
    IMGUI_API void          SetWindowSize(const ImVec2& size, ImGuiCond cond = 0);                      // (not recommended) set current window size - call within Begin()/End(). set to ImVec2(0,0) to force an auto-fit. prefer using SetNextWindowSize(), as this may incur tearing and minor side-effects.
    IMGUI_API void          SetWindowCollapsed(bool collapsed, ImGuiCond cond = 0);                     // (not recommended) set current window collapsed state. prefer using SetNextWindowCollapsed().
    IMGUI_API void          SetWindowFocus();                                                           // (not recommended) set current window to be focused / front-most. prefer using SetNextWindowFocus().
    IMGUI_API void          SetWindowFontScale(float scale);                                            // set font scale. Adjust IO.FontGlobalScale if you want to scale all windows
    IMGUI_API void          SetWindowPos(const char* name, const ImVec2& pos, ImGuiCond cond = 0);      // set named window position.
    IMGUI_API void          SetWindowSize(const char* name, const ImVec2& size, ImGuiCond cond = 0);    // set named window size. set axis to 0.0f to force an auto-fit on this axis.
    IMGUI_API void          SetWindowCollapsed(const char* name, bool collapsed, ImGuiCond cond = 0);   // set named window collapsed state
    IMGUI_API void          SetWindowFocus(const char* name);                                           // set named window to be focused / front-most. use NULL to remove focus.

    // Content region
    // - Those functions are bound to be redesigned soon (they are confusing, incomplete and return values in local window coordinates which increases confusion)
    IMGUI_API ImVec2        GetContentRegionMax();                                          // current content boundaries (typically window boundaries including scrolling, or current column boundaries), in windows coordinates
    IMGUI_API ImVec2        GetContentRegionAvail();                                        // == GetContentRegionMax() - GetCursorPos()
    IMGUI_API ImVec2        GetWindowContentRegionMin();                                    // content boundaries min (roughly (0,0)-Scroll), in window coordinates
    IMGUI_API ImVec2        GetWindowContentRegionMax();                                    // content boundaries max (roughly (0,0)+Size-Scroll) where Size can be override with SetNextWindowContentSize(), in window coordinates
    IMGUI_API float         GetWindowContentRegionWidth();                                  //

    // Windows Scrolling
    IMGUI_API float         GetScrollX();                                                   // get scrolling amount [0..GetScrollMaxX()]
    IMGUI_API float         GetScrollY();                                                   // get scrolling amount [0..GetScrollMaxY()]
    IMGUI_API float         GetScrollMaxX();                                                // get maximum scrolling amount ~~ ContentSize.X - WindowSize.X
    IMGUI_API float         GetScrollMaxY();                                                // get maximum scrolling amount ~~ ContentSize.Y - WindowSize.Y
    IMGUI_API void          SetScrollX(float scroll_x);                                     // set scrolling amount [0..GetScrollMaxX()]
    IMGUI_API void          SetScrollY(float scroll_y);                                     // set scrolling amount [0..GetScrollMaxY()]
    IMGUI_API void          SetScrollHereY(float center_y_ratio = 0.5f);                    // adjust scrolling amount to make current cursor position visible. center_y_ratio=0.0: top, 0.5: center, 1.0: bottom. When using to make a "default/current item" visible, consider using SetItemDefaultFocus() instead.
    IMGUI_API void          SetScrollFromPosY(float local_y, float center_y_ratio = 0.5f);  // adjust scrolling amount to make given position visible. Generally GetCursorStartPos() + offset to compute a valid position.

    // Parameters stacks (shared)
    IMGUI_API void          PushFont(ImFont* font);                                         // use NULL as a shortcut to push default font
    IMGUI_API void          PopFont();
    IMGUI_API void          PushStyleColor(ImGuiCol idx, ImU32 col);
    IMGUI_API void          PushStyleColor(ImGuiCol idx, const ImVec4& col);
    IMGUI_API void          PopStyleColor(int count = 1);
    IMGUI_API void          PushStyleVar(ImGuiStyleVar idx, float val);
    IMGUI_API void          PushStyleVar(ImGuiStyleVar idx, const ImVec2& val);
    IMGUI_API void          PopStyleVar(int count = 1);
    IMGUI_API const ImVec4& GetStyleColorVec4(ImGuiCol idx);                                // retrieve style color as stored in ImGuiStyle structure. use to feed back into PushStyleColor(), otherwise use GetColorU32() to get style color with style alpha baked in.
    IMGUI_API ImFont*       GetFont();                                                      // get current font
    IMGUI_API float         GetFontSize();                                                  // get current font size (= height in pixels) of current font with current scale applied
    IMGUI_API ImVec2        GetFontTexUvWhitePixel();                                       // get UV coordinate for a while pixel, useful to draw custom shapes via the ImDrawList API
    IMGUI_API ImU32         GetColorU32(ImGuiCol idx, float alpha_mul = 1.0f);              // retrieve given style color with style alpha applied and optional extra alpha multiplier
    IMGUI_API ImU32         GetColorU32(const ImVec4& col);                                 // retrieve given color with style alpha applied
    IMGUI_API ImU32         GetColorU32(ImU32 col);                                         // retrieve given color with style alpha applied

    // Parameters stacks (current window)
    IMGUI_API void          PushItemWidth(float item_width);                                // set width of items for common large "item+label" widgets. >0.0f: width in pixels, <0.0f align xx pixels to the right of window (so -1.0f always align width to the right side). 0.0f = default to ~2/3 of windows width, 
    IMGUI_API void          PopItemWidth();
    IMGUI_API void          SetNextItemWidth(float item_width);                             // set width of the _next_ common large "item+label" widget. >0.0f: width in pixels, <0.0f align xx pixels to the right of window (so -1.0f always align width to the right side)
    IMGUI_API float         CalcItemWidth();                                                // width of item given pushed settings and current cursor position
    IMGUI_API void          PushTextWrapPos(float wrap_local_pos_x = 0.0f);                 // word-wrapping for Text*() commands. < 0.0f: no wrapping; 0.0f: wrap to end of window (or column); > 0.0f: wrap at 'wrap_pos_x' position in window local space
    IMGUI_API void          PopTextWrapPos();
    IMGUI_API void          PushAllowKeyboardFocus(bool allow_keyboard_focus);              // allow focusing using TAB/Shift-TAB, enabled by default but you can disable it for certain widgets
    IMGUI_API void          PopAllowKeyboardFocus();
    IMGUI_API void          PushButtonRepeat(bool repeat);                                  // in 'repeat' mode, Button*() functions return repeated true in a typematic manner (using io.KeyRepeatDelay/io.KeyRepeatRate setting). Note that you can call IsItemActive() after any Button() to tell if the button is held in the current frame.
    IMGUI_API void          PopButtonRepeat();

    // Cursor / Layout
    // - By "cursor" we mean the current output position.
    // - The typical widget behavior is to output themselves at the current cursor position, then move the cursor one line down.
    IMGUI_API void          Separator();                                                    // separator, generally horizontal. inside a menu bar or in horizontal layout mode, this becomes a vertical separator.
    IMGUI_API void          SameLine(float offset_from_start_x=0.0f, float spacing=-1.0f);  // call between widgets or groups to layout them horizontally. X position given in window coordinates.
    IMGUI_API void          NewLine();                                                      // undo a SameLine() or force a new line when in an horizontal-layout context.
    IMGUI_API void          Spacing();                                                      // add vertical spacing.
    IMGUI_API void          Dummy(const ImVec2& size);                                      // add a dummy item of given size. unlike InvisibleButton(), Dummy() won't take the mouse click or be navigable into.
    IMGUI_API void          Indent(float indent_w = 0.0f);                                  // move content position toward the right, by style.IndentSpacing or indent_w if != 0
    IMGUI_API void          Unindent(float indent_w = 0.0f);                                // move content position back to the left, by style.IndentSpacing or indent_w if != 0
    IMGUI_API void          BeginGroup();                                                   // lock horizontal starting position
    IMGUI_API void          EndGroup();                                                     // unlock horizontal starting position + capture the whole group bounding box into one "item" (so you can use IsItemHovered() or layout primitives such as SameLine() on whole group, etc.)
    IMGUI_API ImVec2        GetCursorPos();                                                 // cursor position in window coordinates (relative to window position)
    IMGUI_API float         GetCursorPosX();                                                //   (some functions are using window-relative coordinates, such as: GetCursorPos, GetCursorStartPos, GetContentRegionMax, GetWindowContentRegion* etc.
    IMGUI_API float         GetCursorPosY();                                                //    other functions such as GetCursorScreenPos or everything in ImDrawList::
    IMGUI_API void          SetCursorPos(const ImVec2& local_pos);                          //    are using the main, absolute coordinate system.
    IMGUI_API void          SetCursorPosX(float local_x);                                   //    GetWindowPos() + GetCursorPos() == GetCursorScreenPos() etc.)
    IMGUI_API void          SetCursorPosY(float local_y);                                   //
    IMGUI_API ImVec2        GetCursorStartPos();                                            // initial cursor position in window coordinates
    IMGUI_API ImVec2        GetCursorScreenPos();                                           // cursor position in absolute screen coordinates [0..io.DisplaySize] (useful to work with ImDrawList API)
    IMGUI_API void          SetCursorScreenPos(const ImVec2& pos);                          // cursor position in absolute screen coordinates [0..io.DisplaySize]
    IMGUI_API void          AlignTextToFramePadding();                                      // vertically align upcoming text baseline to FramePadding.y so that it will align properly to regularly framed items (call if you have text on a line before a framed item)
    IMGUI_API float         GetTextLineHeight();                                            // ~ FontSize
    IMGUI_API float         GetTextLineHeightWithSpacing();                                 // ~ FontSize + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of text)
    IMGUI_API float         GetFrameHeight();                                               // ~ FontSize + style.FramePadding.y * 2
    IMGUI_API float         GetFrameHeightWithSpacing();                                    // ~ FontSize + style.FramePadding.y * 2 + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of framed widgets)

    // ID stack/scopes
    // - Read the FAQ for more details about how ID are handled in dear imgui. If you are creating widgets in a loop you most
    //   likely want to push a unique identifier (e.g. object pointer, loop index) to uniquely differentiate them.
    // - The resulting ID are hashes of the entire stack.
    // - You can also use the "Label##foobar" syntax within widget label to distinguish them from each others.
    // - In this header file we use the "label"/"name" terminology to denote a string that will be displayed and used as an ID,
    //   whereas "str_id" denote a string that is only used as an ID and not normally displayed.
    IMGUI_API void          PushID(const char* str_id);                                     // push string into the ID stack (will hash string).
    IMGUI_API void          PushID(const char* str_id_begin, const char* str_id_end);       // push string into the ID stack (will hash string).
    IMGUI_API void          PushID(const void* ptr_id);                                     // push pointer into the ID stack (will hash pointer).
    IMGUI_API void          PushID(int int_id);                                             // push integer into the ID stack (will hash integer).
    IMGUI_API void          PopID();                                                        // pop from the ID stack.
    IMGUI_API ImGuiID       GetID(const char* str_id);                                      // calculate unique ID (hash of whole ID stack + given parameter). e.g. if you want to query into ImGuiStorage yourself
    IMGUI_API ImGuiID       GetID(const char* str_id_begin, const char* str_id_end);
    IMGUI_API ImGuiID       GetID(const void* ptr_id);

    // Widgets: Text
    IMGUI_API void          TextUnformatted(const char* text, const char* text_end = NULL);                // raw text without formatting. Roughly equivalent to Text("%s", text) but: A) doesn't require null terminated string if 'text_end' is specified, B) it's faster, no memory copy is done, no buffer size limits, recommended for long chunks of text.
    IMGUI_API void          Text(const char* fmt, ...)                                      IM_FMTARGS(1); // simple formatted text
    IMGUI_API void          TextV(const char* fmt, va_list args)                            IM_FMTLIST(1);
    IMGUI_API void          TextColored(const ImVec4& col, const char* fmt, ...)            IM_FMTARGS(2); // shortcut for PushStyleColor(ImGuiCol_Text, col); Text(fmt, ...); PopStyleColor();
    IMGUI_API void          TextColoredV(const ImVec4& col, const char* fmt, va_list args)  IM_FMTLIST(2);
    IMGUI_API void          TextDisabled(const char* fmt, ...)                              IM_FMTARGS(1); // shortcut for PushStyleColor(ImGuiCol_Text, style.Colors[ImGuiCol_TextDisabled]); Text(fmt, ...); PopStyleColor();
    IMGUI_API void          TextDisabledV(const char* fmt, va_list args)                    IM_FMTLIST(1);
    IMGUI_API void          TextWrapped(const char* fmt, ...)                               IM_FMTARGS(1); // shortcut for PushTextWrapPos(0.0f); Text(fmt, ...); PopTextWrapPos();. Note that this won't work on an auto-resizing window if there's no other widgets to extend the window width, yoy may need to set a size using SetNextWindowSize().
    IMGUI_API void          TextWrappedV(const char* fmt, va_list args)                     IM_FMTLIST(1);
    IMGUI_API void          LabelText(const char* label, const char* fmt, ...)              IM_FMTARGS(2); // display text+label aligned the same way as value+label widgets
    IMGUI_API void          LabelTextV(const char* label, const char* fmt, va_list args)    IM_FMTLIST(2);
    IMGUI_API void          BulletText(const char* fmt, ...)                                IM_FMTARGS(1); // shortcut for Bullet()+Text()
    IMGUI_API void          BulletTextV(const char* fmt, va_list args)                      IM_FMTLIST(1);

    // Widgets: Main
    // - Most widgets return true when the value has been changed or when pressed/selected
    IMGUI_API bool          Button(const char* label, const ImVec2& size = ImVec2(0,0));    // button
    IMGUI_API bool          SmallButton(const char* label);                                 // button with FramePadding=(0,0) to easily embed within text
    IMGUI_API bool          InvisibleButton(const char* str_id, const ImVec2& size);        // button behavior without the visuals, frequently useful to build custom behaviors using the public api (along with IsItemActive, IsItemHovered, etc.)
    IMGUI_API bool          ArrowButton(const char* str_id, ImGuiDir dir);                  // square button with an arrow shape
    IMGUI_API void          Image(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0,0), const ImVec2& uv1 = ImVec2(1,1), const ImVec4& tint_col = ImVec4(1,1,1,1), const ImVec4& border_col = ImVec4(0,0,0,0));
    IMGUI_API bool          ImageButton(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0,0),  const ImVec2& uv1 = ImVec2(1,1), int frame_padding = -1, const ImVec4& bg_col = ImVec4(0,0,0,0), const ImVec4& tint_col = ImVec4(1,1,1,1));    // <0 frame_padding uses default frame padding settings. 0 for no padding
    IMGUI_API bool          Checkbox(const char* label, bool* v);
    IMGUI_API bool          CheckboxFlags(const char* label, unsigned int* flags, unsigned int flags_value);
    IMGUI_API bool          RadioButton(const char* label, bool active);                    // use with e.g. if (RadioButton("one", my_value==1)) { my_value = 1; }
    IMGUI_API bool          RadioButton(const char* label, int* v, int v_button);           // shortcut to handle the above pattern when value is an integer
    IMGUI_API void          ProgressBar(float fraction, const ImVec2& size_arg = ImVec2(-1,0), const char* overlay = NULL);
    IMGUI_API void          Bullet();                                                       // draw a small circle and keep the cursor on the same line. advance cursor x position by GetTreeNodeToLabelSpacing(), same distance that TreeNode() uses

    // Widgets: Combo Box
    // - The new BeginCombo()/EndCombo() api allows you to manage your contents and selection state however you want it, by creating e.g. Selectable() items.
    // - The old Combo() api are helpers over BeginCombo()/EndCombo() which are kept available for convenience purpose.
    IMGUI_API bool          BeginCombo(const char* label, const char* preview_value, ImGuiComboFlags flags = 0);
    IMGUI_API void          EndCombo(); // only call EndCombo() if BeginCombo() returns true!
    IMGUI_API bool          Combo(const char* label, int* current_item, const char* const items[], int items_count, int popup_max_height_in_items = -1);
    IMGUI_API bool          Combo(const char* label, int* current_item, const char* items_separated_by_zeros, int popup_max_height_in_items = -1);      // Separate items with \0 within a string, end item-list with \0\0. e.g. "One\0Two\0Three\0"
    IMGUI_API bool          Combo(const char* label, int* current_item, bool(*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int popup_max_height_in_items = -1);

    // Widgets: Drags
    // - CTRL+Click on any drag box to turn them into an input box. Manually input values aren't clamped and can go off-bounds.
    // - For all the Float2/Float3/Float4/Int2/Int3/Int4 versions of every functions, note that a 'float v[X]' function argument is the same as 'float* v', the array syntax is just a way to document the number of elements that are expected to be accessible. You can pass address of your first element out of a contiguous set, e.g. &myvector.x
    // - Adjust format string to decorate the value with a prefix, a suffix, or adapt the editing and display precision e.g. "%.3f" -> 1.234; "%5.2f secs" -> 01.23 secs; "Biscuit: %.0f" -> Biscuit: 1; etc.
    // - Speed are per-pixel of mouse movement (v_speed=0.2f: mouse needs to move by 5 pixels to increase value by 1). For gamepad/keyboard navigation, minimum speed is Max(v_speed, minimum_step_at_given_precision).
    IMGUI_API bool          DragFloat(const char* label, float* v, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = "%.3f", float power = 1.0f);     // If v_min >= v_max we have no bound
    IMGUI_API bool          DragFloat2(const char* label, float v[2], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = "%.3f", float power = 1.0f);
    IMGUI_API bool          DragFloat3(const char* label, float v[3], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = "%.3f", float power = 1.0f);
    IMGUI_API bool          DragFloat4(const char* label, float v[4], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = "%.3f", float power = 1.0f);
    IMGUI_API bool          DragFloatRange2(const char* label, float* v_current_min, float* v_current_max, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = "%.3f", const char* format_max = NULL, float power = 1.0f);
    IMGUI_API bool          DragInt(const char* label, int* v, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = "%d");                                       // If v_min >= v_max we have no bound
    IMGUI_API bool          DragInt2(const char* label, int v[2], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = "%d");
    IMGUI_API bool          DragInt3(const char* label, int v[3], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = "%d");
    IMGUI_API bool          DragInt4(const char* label, int v[4], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = "%d");
    IMGUI_API bool          DragIntRange2(const char* label, int* v_current_min, int* v_current_max, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = "%d", const char* format_max = NULL);
    IMGUI_API bool          DragScalar(const char* label, ImGuiDataType data_type, void* v, float v_speed, const void* v_min = NULL, const void* v_max = NULL, const char* format = NULL, float power = 1.0f);
    IMGUI_API bool          DragScalarN(const char* label, ImGuiDataType data_type, void* v, int components, float v_speed, const void* v_min = NULL, const void* v_max = NULL, const char* format = NULL, float power = 1.0f);

    // Widgets: Sliders
    // - CTRL+Click on any slider to turn them into an input box. Manually input values aren't clamped and can go off-bounds.
    // - Adjust format string to decorate the value with a prefix, a suffix, or adapt the editing and display precision e.g. "%.3f" -> 1.234; "%5.2f secs" -> 01.23 secs; "Biscuit: %.0f" -> Biscuit: 1; etc.
    IMGUI_API bool          SliderFloat(const char* label, float* v, float v_min, float v_max, const char* format = "%.3f", float power = 1.0f);     // adjust format to decorate the value with a prefix or a suffix for in-slider labels or unit display. Use power!=1.0 for power curve sliders
    IMGUI_API bool          SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* format = "%.3f", float power = 1.0f);
    IMGUI_API bool          SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* format = "%.3f", float power = 1.0f);
    IMGUI_API bool          SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* format = "%.3f", float power = 1.0f);
    IMGUI_API bool          SliderAngle(const char* label, float* v_rad, float v_degrees_min = -360.0f, float v_degrees_max = +360.0f, const char* format = "%.0f deg");
    IMGUI_API bool          SliderInt(const char* label, int* v, int v_min, int v_max, const char* format = "%d");
    IMGUI_API bool          SliderInt2(const char* label, int v[2], int v_min, int v_max, const char* format = "%d");
    IMGUI_API bool          SliderInt3(const char* label, int v[3], int v_min, int v_max, const char* format = "%d");
    IMGUI_API bool          SliderInt4(const char* label, int v[4], int v_min, int v_max, const char* format = "%d");
    IMGUI_API bool          SliderScalar(const char* label, ImGuiDataType data_type, void* v, const void* v_min, const void* v_max, const char* format = NULL, float power = 1.0f);
    IMGUI_API bool          SliderScalarN(const char* label, ImGuiDataType data_type, void* v, int components, const void* v_min, const void* v_max, const char* format = NULL, float power = 1.0f);
    IMGUI_API bool          VSliderFloat(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* format = "%.3f", float power = 1.0f);
    IMGUI_API bool          VSliderInt(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* format = "%d");
    IMGUI_API bool          VSliderScalar(const char* label, const ImVec2& size, ImGuiDataType data_type, void* v, const void* v_min, const void* v_max, const char* format = NULL, float power = 1.0f);

    // Widgets: Input with Keyboard
    // - If you want to use InputText() with a dynamic string type such as std::string or your own, see misc/cpp/imgui_stdlib.h
    // - Most of the ImGuiInputTextFlags flags are only useful for InputText() and not for InputFloatX, InputIntX, InputDouble etc.
    IMGUI_API bool          InputText(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags = 0, ImGuiInputTextCallback callback = NULL, void* user_data = NULL);
    IMGUI_API bool          InputTextMultiline(const char* label, char* buf, size_t buf_size, const ImVec2& size = ImVec2(0,0), ImGuiInputTextFlags flags = 0, ImGuiInputTextCallback callback = NULL, void* user_data = NULL);
    IMGUI_API bool          InputTextWithHint(const char* label, const char* hint, char* buf, size_t buf_size, ImGuiInputTextFlags flags = 0, ImGuiInputTextCallback callback = NULL, void* user_data = NULL);
    IMGUI_API bool          InputFloat(const char* label, float* v, float step = 0.0f, float step_fast = 0.0f, const char* format = "%.3f", ImGuiInputTextFlags flags = 0);
    IMGUI_API bool          InputFloat2(const char* label, float v[2], const char* format = "%.3f", ImGuiInputTextFlags flags = 0);
    IMGUI_API bool          InputFloat3(const char* label, float v[3], const char* format = "%.3f", ImGuiInputTextFlags flags = 0);
    IMGUI_API bool          InputFloat4(const char* label, float v[4], const char* format = "%.3f", ImGuiInputTextFlags flags = 0);
    IMGUI_API bool          InputInt(const char* label, int* v, int step = 1, int step_fast = 100, ImGuiInputTextFlags flags = 0);
    IMGUI_API bool          InputInt2(const char* label, int v[2], ImGuiInputTextFlags flags = 0);
    IMGUI_API bool          InputInt3(const char* label, int v[3], ImGuiInputTextFlags flags = 0);
    IMGUI_API bool          InputInt4(const char* label, int v[4], ImGuiInputTextFlags flags = 0);
    IMGUI_API bool          InputDouble(const char* label, double* v, double step = 0.0, double step_fast = 0.0, const char* format = "%.6f", ImGuiInputTextFlags flags = 0);
    IMGUI_API bool          InputScalar(const char* label, ImGuiDataType data_type, void* v, const void* step = NULL, const void* step_fast = NULL, const char* format = NULL, ImGuiInputTextFlags flags = 0);
    IMGUI_API bool          InputScalarN(const char* label, ImGuiDataType data_type, void* v, int components, const void* step = NULL, const void* step_fast = NULL, const char* format = NULL, ImGuiInputTextFlags flags = 0);

    // Widgets: Color Editor/Picker (tip: the ColorEdit* functions have a little colored preview square that can be left-clicked to open a picker, and right-clicked to open an option menu.)
    // - Note that in C++ a 'float v[X]' function argument is the _same_ as 'float* v', the array syntax is just a way to document the number of elements that are expected to be accessible.
    // - You can pass the address of a first float element out of a contiguous structure, e.g. &myvector.x
    IMGUI_API bool          ColorEdit3(const char* label, float col[3], ImGuiColorEditFlags flags = 0);
    IMGUI_API bool          ColorEdit4(const char* label, float col[4], ImGuiColorEditFlags flags = 0);
    IMGUI_API bool          ColorPicker3(const char* label, float col[3], ImGuiColorEditFlags flags = 0);
    IMGUI_API bool          ColorPicker4(const char* label, float col[4], ImGuiColorEditFlags flags = 0, const float* ref_col = NULL);
    IMGUI_API bool          ColorButton(const char* desc_id, const ImVec4& col, ImGuiColorEditFlags flags = 0, ImVec2 size = ImVec2(0,0));  // display a colored square/button, hover for details, return true when pressed.
    IMGUI_API void          SetColorEditOptions(ImGuiColorEditFlags flags);                     // initialize current options (generally on application startup) if you want to select a default format, picker type, etc. User will be able to change many settings, unless you pass the _NoOptions flag to your calls.

    // Widgets: Trees
    // - TreeNode functions return true when the node is open, in which case you need to also call TreePop() when you are finished displaying the tree node contents.
    IMGUI_API bool          TreeNode(const char* label);
    IMGUI_API bool          TreeNode(const char* str_id, const char* fmt, ...) IM_FMTARGS(2);   // helper variation to easily decorelate the id from the displayed string. Read the FAQ about why and how to use ID. to align arbitrary text at the same level as a TreeNode() you can use Bullet().
    IMGUI_API bool          TreeNode(const void* ptr_id, const char* fmt, ...) IM_FMTARGS(2);   // "
    IMGUI_API bool          TreeNodeV(const char* str_id, const char* fmt, va_list args) IM_FMTLIST(2);
    IMGUI_API bool          TreeNodeV(const void* ptr_id, const char* fmt, va_list args) IM_FMTLIST(2);
    IMGUI_API bool          TreeNodeEx(const char* label, ImGuiTreeNodeFlags flags = 0);
    IMGUI_API bool          TreeNodeEx(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, ...) IM_FMTARGS(3);
    IMGUI_API bool          TreeNodeEx(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, ...) IM_FMTARGS(3);
    IMGUI_API bool          TreeNodeExV(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args) IM_FMTLIST(3);
    IMGUI_API bool          TreeNodeExV(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args) IM_FMTLIST(3);
    IMGUI_API void          TreePush(const char* str_id);                                       // ~ Indent()+PushId(). Already called by TreeNode() when returning true, but you can call TreePush/TreePop yourself if desired.
    IMGUI_API void          TreePush(const void* ptr_id = NULL);                                // "
    IMGUI_API void          TreePop();                                                          // ~ Unindent()+PopId()
    IMGUI_API void          TreeAdvanceToLabelPos();                                            // advance cursor x position by GetTreeNodeToLabelSpacing()
    IMGUI_API float         GetTreeNodeToLabelSpacing();                                        // horizontal distance preceding label when using TreeNode*() or Bullet() == (g.FontSize + style.FramePadding.x*2) for a regular unframed TreeNode
    IMGUI_API void          SetNextTreeNodeOpen(bool is_open, ImGuiCond cond = 0);              // set next TreeNode/CollapsingHeader open state.
    IMGUI_API bool          CollapsingHeader(const char* label, ImGuiTreeNodeFlags flags = 0);  // if returning 'true' the header is open. doesn't indent nor push on ID stack. user doesn't have to call TreePop().
    IMGUI_API bool          CollapsingHeader(const char* label, bool* p_open, ImGuiTreeNodeFlags flags = 0); // when 'p_open' isn't NULL, display an additional small close button on upper right of the header

    // Widgets: Selectables
    // - A selectable highlights when hovered, and can display another color when selected.
    // - Neighbors selectable extend their highlight bounds in order to leave no gap between them.
    IMGUI_API bool          Selectable(const char* label, bool selected = false, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0,0));  // "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x>0.0: specify width. size.y==0.0: use label height, size.y>0.0: specify height
    IMGUI_API bool          Selectable(const char* label, bool* p_selected, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0,0));       // "bool* p_selected" point to the selection state (read-write), as a convenient helper.

    // Widgets: List Boxes
    // - FIXME: To be consistent with all the newer API, ListBoxHeader/ListBoxFooter should in reality be called BeginListBox/EndListBox. Will rename them.
    IMGUI_API bool          ListBox(const char* label, int* current_item, const char* const items[], int items_count, int height_in_items = -1);
    IMGUI_API bool          ListBox(const char* label, int* current_item, bool (*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int height_in_items = -1);
    IMGUI_API bool          ListBoxHeader(const char* label, const ImVec2& size = ImVec2(0,0)); // use if you want to reimplement ListBox() will custom data or interactions. if the function return true, you can output elements then call ListBoxFooter() afterwards.
    IMGUI_API bool          ListBoxHeader(const char* label, int items_count, int height_in_items = -1); // "
    IMGUI_API void          ListBoxFooter();                                                    // terminate the scrolling region. only call ListBoxFooter() if ListBoxHeader() returned true!

    // Widgets: Data Plotting
    IMGUI_API void          PlotLines(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0), int stride = sizeof(float));
    IMGUI_API void          PlotLines(const char* label, float(*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0));
    IMGUI_API void          PlotHistogram(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0), int stride = sizeof(float));
    IMGUI_API void          PlotHistogram(const char* label, float(*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0));

    // Widgets: Value() Helpers.
    // - Those are merely shortcut to calling Text() with a format string. Output single value in "name: value" format (tip: freely declare more in your code to handle your types. you can add functions to the ImGui namespace)
    IMGUI_API void          Value(const char* prefix, bool b);
    IMGUI_API void          Value(const char* prefix, int v);
    IMGUI_API void          Value(const char* prefix, unsigned int v);
    IMGUI_API void          Value(const char* prefix, float v, const char* float_format = NULL);

    // Widgets: Menus
    IMGUI_API bool          BeginMainMenuBar();                                                 // create and append to a full screen menu-bar.
    IMGUI_API void          EndMainMenuBar();                                                   // only call EndMainMenuBar() if BeginMainMenuBar() returns true!
    IMGUI_API bool          BeginMenuBar();                                                     // append to menu-bar of current window (requires ImGuiWindowFlags_MenuBar flag set on parent window).
    IMGUI_API void          EndMenuBar();                                                       // only call EndMenuBar() if BeginMenuBar() returns true!
    IMGUI_API bool          BeginMenu(const char* label, bool enabled = true);                  // create a sub-menu entry. only call EndMenu() if this returns true!
    IMGUI_API void          EndMenu();                                                          // only call EndMenu() if BeginMenu() returns true!
    IMGUI_API bool          MenuItem(const char* label, const char* shortcut = NULL, bool selected = false, bool enabled = true);  // return true when activated. shortcuts are displayed for convenience but not processed by ImGui at the moment
    IMGUI_API bool          MenuItem(const char* label, const char* shortcut, bool* p_selected, bool enabled = true);              // return true when activated + toggle (*p_selected) if p_selected != NULL

    // Tooltips
    IMGUI_API void          BeginTooltip();                                                     // begin/append a tooltip window. to create full-featured tooltip (with any kind of items).
    IMGUI_API void          EndTooltip();
    IMGUI_API void          SetTooltip(const char* fmt, ...) IM_FMTARGS(1);                     // set a text-only tooltip, typically use with ImGui::IsItemHovered(). override any previous call to SetTooltip().
    IMGUI_API void          SetTooltipV(const char* fmt, va_list args) IM_FMTLIST(1);

    // Popups, Modals
    // The properties of popups windows are:
    // - They block normal mouse hovering detection outside them. (*)
    // - Unless modal, they can be closed by clicking anywhere outside them, or by pressing ESCAPE.
    // - Their visibility state (~bool) is held internally by imgui instead of being held by the programmer as we are used to with regular Begin() calls.
    //   User can manipulate the visibility state by calling OpenPopup().
    // (*) One can use IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup) to bypass it and detect hovering even when normally blocked by a popup.
    // Those three properties are connected. The library needs to hold their visibility state because it can close popups at any time.
    IMGUI_API void          OpenPopup(const char* str_id);                                      // call to mark popup as open (don't call every frame!). popups are closed when user click outside, or if CloseCurrentPopup() is called within a BeginPopup()/EndPopup() block. By default, Selectable()/MenuItem() are calling CloseCurrentPopup(). Popup identifiers are relative to the current ID-stack (so OpenPopup and BeginPopup needs to be at the same level).
    IMGUI_API bool          BeginPopup(const char* str_id, ImGuiWindowFlags flags = 0);                                             // return true if the popup is open, and you can start outputting to it. only call EndPopup() if BeginPopup() returns true!
    IMGUI_API bool          BeginPopupContextItem(const char* str_id = NULL, int mouse_button = 1);                                 // helper to open and begin popup when clicked on last item. if you can pass a NULL str_id only if the previous item had an id. If you want to use that on a non-interactive item such as Text() you need to pass in an explicit ID here. read comments in .cpp!
    IMGUI_API bool          BeginPopupContextWindow(const char* str_id = NULL, int mouse_button = 1, bool also_over_items = true);  // helper to open and begin popup when clicked on current window.
    IMGUI_API bool          BeginPopupContextVoid(const char* str_id = NULL, int mouse_button = 1);                                 // helper to open and begin popup when clicked in void (where there are no imgui windows).
    IMGUI_API bool          BeginPopupModal(const char* name, bool* p_open = NULL, ImGuiWindowFlags flags = 0);                     // modal dialog (regular window with title bar, block interactions behind the modal window, can't close the modal window by clicking outside)
    IMGUI_API void          EndPopup();                                                                                             // only call EndPopup() if BeginPopupXXX() returns true!
    IMGUI_API bool          OpenPopupOnItemClick(const char* str_id = NULL, int mouse_button = 1);                                  // helper to open popup when clicked on last item (note: actually triggers on the mouse _released_ event to be consistent with popup behaviors). return true when just opened.
    IMGUI_API bool          IsPopupOpen(const char* str_id);                                    // return true if the popup is open at the current begin-ed level of the popup stack.
    IMGUI_API void          CloseCurrentPopup();                                                // close the popup we have begin-ed into. clicking on a MenuItem or Selectable automatically close the current popup.

    // Columns
    // - You can also use SameLine(pos_x) to mimic simplified columns.
    // - The columns API is work-in-progress and rather lacking (columns are arguably the worst part of dear imgui at the moment!)
    IMGUI_API void          Columns(int count = 1, const char* id = NULL, bool border = true);
    IMGUI_API void          NextColumn();                                                       // next column, defaults to current row or next row if the current row is finished
    IMGUI_API int           GetColumnIndex();                                                   // get current column index
    IMGUI_API float         GetColumnWidth(int column_index = -1);                              // get column width (in pixels). pass -1 to use current column
    IMGUI_API void          SetColumnWidth(int column_index, float width);                      // set column width (in pixels). pass -1 to use current column
    IMGUI_API float         GetColumnOffset(int column_index = -1);                             // get position of column line (in pixels, from the left side of the contents region). pass -1 to use current column, otherwise 0..GetColumnsCount() inclusive. column 0 is typically 0.0f
    IMGUI_API void          SetColumnOffset(int column_index, float offset_x);                  // set position of column line (in pixels, from the left side of the contents region). pass -1 to use current column
    IMGUI_API int           GetColumnsCount();

    // Tab Bars, Tabs
    // [BETA API] API may evolve!
    IMGUI_API bool          BeginTabBar(const char* str_id, ImGuiTabBarFlags flags = 0);        // create and append into a TabBar
    IMGUI_API void          EndTabBar();                                                        // only call EndTabBar() if BeginTabBar() returns true!
    IMGUI_API bool          BeginTabItem(const char* label, bool* p_open = NULL, ImGuiTabItemFlags flags = 0);// create a Tab. Returns true if the Tab is selected.
    IMGUI_API void          EndTabItem();                                                       // only call EndTabItem() if BeginTabItem() returns true!
    IMGUI_API void          SetTabItemClosed(const char* tab_or_docked_window_label);           // notify TabBar or Docking system of a closed tab/window ahead (useful to reduce visual flicker on reorderable tab bars). For tab-bar: call after BeginTabBar() and before Tab submissions. Otherwise call with a window name.

    // Logging/Capture
    // - All text output from the interface can be captured into tty/file/clipboard. By default, tree nodes are automatically opened during logging.
    IMGUI_API void          LogToTTY(int auto_open_depth = -1);                                 // start logging to tty (stdout)
    IMGUI_API void          LogToFile(int auto_open_depth = -1, const char* filename = NULL);   // start logging to file
    IMGUI_API void          LogToClipboard(int auto_open_depth = -1);                           // start logging to OS clipboard
    IMGUI_API void          LogFinish();                                                        // stop logging (close file, etc.)
    IMGUI_API void          LogButtons();                                                       // helper to display buttons for logging to tty/file/clipboard
    IMGUI_API void          LogText(const char* fmt, ...) IM_FMTARGS(1);                        // pass text data straight to log (without being displayed)

    // Drag and Drop
    // [BETA API] API may evolve!
    IMGUI_API bool          BeginDragDropSource(ImGuiDragDropFlags flags = 0);                                      // call when the current item is active. If this return true, you can call SetDragDropPayload() + EndDragDropSource()
    IMGUI_API bool          SetDragDropPayload(const char* type, const void* data, size_t sz, ImGuiCond cond = 0);  // type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui.
    IMGUI_API void          EndDragDropSource();                                                                    // only call EndDragDropSource() if BeginDragDropSource() returns true!
    IMGUI_API bool                  BeginDragDropTarget();                                                          // call after submitting an item that may receive a payload. If this returns true, you can call AcceptDragDropPayload() + EndDragDropTarget()
    IMGUI_API const ImGuiPayload*   AcceptDragDropPayload(const char* type, ImGuiDragDropFlags flags = 0);          // accept contents of a given type. If ImGuiDragDropFlags_AcceptBeforeDelivery is set you can peek into the payload before the mouse button is released.
    IMGUI_API void                  EndDragDropTarget();                                                            // only call EndDragDropTarget() if BeginDragDropTarget() returns true!
    IMGUI_API const ImGuiPayload*   GetDragDropPayload();                                                           // peek directly into the current payload from anywhere. may return NULL. use ImGuiPayload::IsDataType() to test for the payload type.

    // Clipping
    IMGUI_API void          PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect);
    IMGUI_API void          PopClipRect();

    // Focus, Activation
    // - Prefer using "SetItemDefaultFocus()" over "if (IsWindowAppearing()) SetScrollHereY()" when applicable to signify "this is the default item"
    IMGUI_API void          SetItemDefaultFocus();                                              // make last item the default focused item of a window.
    IMGUI_API void          SetKeyboardFocusHere(int offset = 0);                               // focus keyboard on the next widget. Use positive 'offset' to access sub components of a multiple component widget. Use -1 to access previous widget.

    // Item/Widgets Utilities
    // - Most of the functions are referring to the last/previous item we submitted.
    // - See Demo Window under "Widgets->Querying Status" for an interactive visualization of most of those functions.
    IMGUI_API bool          IsItemHovered(ImGuiHoveredFlags flags = 0);                         // is the last item hovered? (and usable, aka not blocked by a popup, etc.). See ImGuiHoveredFlags for more options.
    IMGUI_API bool          IsItemActive();                                                     // is the last item active? (e.g. button being held, text field being edited. This will continuously return true while holding mouse button on an item. Items that don't interact will always return false)
    IMGUI_API bool          IsItemFocused();                                                    // is the last item focused for keyboard/gamepad navigation?
    IMGUI_API bool          IsItemClicked(int mouse_button = 0);                                // is the last item clicked? (e.g. button/node just clicked on) == IsMouseClicked(mouse_button) && IsItemHovered()
    IMGUI_API bool          IsItemVisible();                                                    // is the last item visible? (items may be out of sight because of clipping/scrolling)
    IMGUI_API bool          IsItemEdited();                                                     // did the last item modify its underlying value this frame? or was pressed? This is generally the same as the "bool" return value of many widgets.
    IMGUI_API bool          IsItemActivated();                                                  // was the last item just made active (item was previously inactive).
    IMGUI_API bool          IsItemDeactivated();                                                // was the last item just made inactive (item was previously active). Useful for Undo/Redo patterns with widgets that requires continuous editing.
    IMGUI_API bool          IsItemDeactivatedAfterEdit();                                       // was the last item just made inactive and made a value change when it was active? (e.g. Slider/Drag moved). Useful for Undo/Redo patterns with widgets that requires continuous editing. Note that you may get false positives (some widgets such as Combo()/ListBox()/Selectable() will return true even when clicking an already selected item).
    IMGUI_API bool          IsAnyItemHovered();                                                 // is any item hovered?
    IMGUI_API bool          IsAnyItemActive();                                                  // is any item active?
    IMGUI_API bool          IsAnyItemFocused();                                                 // is any item focused?
    IMGUI_API ImVec2        GetItemRectMin();                                                   // get upper-left bounding rectangle of the last item (screen space)
    IMGUI_API ImVec2        GetItemRectMax();                                                   // get lower-right bounding rectangle of the last item (screen space)
    IMGUI_API ImVec2        GetItemRectSize();                                                  // get size of last item
    IMGUI_API void          SetItemAllowOverlap();                                              // allow last item to be overlapped by a subsequent item. sometimes useful with invisible buttons, selectables, etc. to catch unused area.

    // Miscellaneous Utilities
    IMGUI_API bool          IsRectVisible(const ImVec2& size);                                  // test if rectangle (of given size, starting from cursor position) is visible / not clipped.
    IMGUI_API bool          IsRectVisible(const ImVec2& rect_min, const ImVec2& rect_max);      // test if rectangle (in screen space) is visible / not clipped. to perform coarse clipping on user's side.
    IMGUI_API double        GetTime();                                                          // get global imgui time. incremented by io.DeltaTime every frame.
    IMGUI_API int           GetFrameCount();                                                    // get global imgui frame count. incremented by 1 every frame.
    IMGUI_API ImDrawList*   GetBackgroundDrawList();                                            // this draw list will be the first rendering one. Useful to quickly draw shapes/text behind dear imgui contents.
    IMGUI_API ImDrawList*   GetForegroundDrawList();                                            // this draw list will be the last rendered one. Useful to quickly draw shapes/text over dear imgui contents.
    IMGUI_API ImDrawListSharedData* GetDrawListSharedData();                                    // you may use this when creating your own ImDrawList instances.
    IMGUI_API const char*   GetStyleColorName(ImGuiCol idx);                                    // get a string corresponding to the enum value (for display, saving, etc.).
    IMGUI_API void          SetStateStorage(ImGuiStorage* storage);                             // replace current window storage with our own (if you want to manipulate it yourself, typically clear subsection of it)
    IMGUI_API ImGuiStorage* GetStateStorage();
    IMGUI_API ImVec2        CalcTextSize(const char* text, const char* text_end = NULL, bool hide_text_after_double_hash = false, float wrap_width = -1.0f);
    IMGUI_API void          CalcListClipping(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end);    // calculate coarse clipping for large list of evenly sized items. Prefer using the ImGuiListClipper higher-level helper if you can.
    IMGUI_API bool          BeginChildFrame(ImGuiID id, const ImVec2& size, ImGuiWindowFlags flags = 0); // helper to create a child window / scrolling region that looks like a normal widget frame
    IMGUI_API void          EndChildFrame();                                                    // always call EndChildFrame() regardless of BeginChildFrame() return values (which indicates a collapsed/clipped window)

    // Color Utilities
    IMGUI_API ImVec4        ColorConvertU32ToFloat4(ImU32 in);
    IMGUI_API ImU32         ColorConvertFloat4ToU32(const ImVec4& in);
    IMGUI_API void          ColorConvertRGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v);
    IMGUI_API void          ColorConvertHSVtoRGB(float h, float s, float v, float& out_r, float& out_g, float& out_b);

    // Inputs Utilities
    IMGUI_API int           GetKeyIndex(ImGuiKey imgui_key);                                    // map ImGuiKey_* values into user's key index. == io.KeyMap[key]
    IMGUI_API bool          IsKeyDown(int user_key_index);                                      // is key being held. == io.KeysDown[user_key_index]. note that imgui doesn't know the semantic of each entry of io.KeysDown[]. Use your own indices/enums according to how your backend/engine stored them into io.KeysDown[]!
    IMGUI_API bool          IsKeyPressed(int user_key_index, bool repeat = true);               // was key pressed (went from !Down to Down). if repeat=true, uses io.KeyRepeatDelay / KeyRepeatRate
    IMGUI_API bool          IsKeyReleased(int user_key_index);                                  // was key released (went from Down to !Down)..
    IMGUI_API int           GetKeyPressedAmount(int key_index, float repeat_delay, float rate); // uses provided repeat rate/delay. return a count, most often 0 or 1 but might be >1 if RepeatRate is small enough that DeltaTime > RepeatRate
    IMGUI_API bool          IsMouseDown(int button);                                            // is mouse button held (0=left, 1=right, 2=middle)
    IMGUI_API bool          IsAnyMouseDown();                                                   // is any mouse button held
    IMGUI_API bool          IsMouseClicked(int button, bool repeat = false);                    // did mouse button clicked (went from !Down to Down) (0=left, 1=right, 2=middle)
    IMGUI_API bool          IsMouseDoubleClicked(int button);                                   // did mouse button double-clicked. a double-click returns false in IsMouseClicked(). uses io.MouseDoubleClickTime.
    IMGUI_API bool          IsMouseReleased(int button);                                        // did mouse button released (went from Down to !Down)
    IMGUI_API bool          IsMouseDragging(int button = 0, float lock_threshold = -1.0f);      // is mouse dragging. if lock_threshold < -1.0f uses io.MouseDraggingThreshold
    IMGUI_API bool          IsMouseHoveringRect(const ImVec2& r_min, const ImVec2& r_max, bool clip = true);  // is mouse hovering given bounding rect (in screen space). clipped by current clipping settings, but disregarding of other consideration of focus/window ordering/popup-block.
    IMGUI_API bool          IsMousePosValid(const ImVec2* mouse_pos = NULL);                    // by convention we use (-FLT_MAX,-FLT_MAX) to denote that there is no mouse
    IMGUI_API ImVec2        GetMousePos();                                                      // shortcut to ImGui::GetIO().MousePos provided by user, to be consistent with other calls
    IMGUI_API ImVec2        GetMousePosOnOpeningCurrentPopup();                                 // retrieve backup of mouse position at the time of opening popup we have BeginPopup() into
    IMGUI_API ImVec2        GetMouseDragDelta(int button = 0, float lock_threshold = -1.0f);    // return the delta from the initial clicking position while the mouse button is pressed or was just released. This is locked and return 0.0f until the mouse moves past a distance threshold at least once. If lock_threshold < -1.0f uses io.MouseDraggingThreshold.
    IMGUI_API void          ResetMouseDragDelta(int button = 0);                                //
    IMGUI_API ImGuiMouseCursor GetMouseCursor();                                                // get desired cursor type, reset in ImGui::NewFrame(), this is updated during the frame. valid before Render(). If you use software rendering by setting io.MouseDrawCursor ImGui will render those for you
    IMGUI_API void          SetMouseCursor(ImGuiMouseCursor type);                              // set desired cursor type
    IMGUI_API void          CaptureKeyboardFromApp(bool want_capture_keyboard_value = true);    // attention: misleading name! manually override io.WantCaptureKeyboard flag next frame (said flag is entirely left for your application to handle). e.g. force capture keyboard when your widget is being hovered. This is equivalent to setting "io.WantCaptureKeyboard = want_capture_keyboard_value"; after the next NewFrame() call.
    IMGUI_API void          CaptureMouseFromApp(bool want_capture_mouse_value = true);          // attention: misleading name! manually override io.WantCaptureMouse flag next frame (said flag is entirely left for your application to handle). This is equivalent to setting "io.WantCaptureMouse = want_capture_mouse_value;" after the next NewFrame() call.

    // Clipboard Utilities (also see the LogToClipboard() function to capture or output text data to the clipboard)
    IMGUI_API const char*   GetClipboardText();
    IMGUI_API void          SetClipboardText(const char* text);

    // Settings/.Ini Utilities
    // - The disk functions are automatically called if io.IniFilename != NULL (default is "imgui.ini").
    // - Set io.IniFilename to NULL to load/save manually. Read io.WantSaveIniSettings description about handling .ini saving manually.
    IMGUI_API void          LoadIniSettingsFromDisk(const char* ini_filename);                  // call after CreateContext() and before the first call to NewFrame(). NewFrame() automatically calls LoadIniSettingsFromDisk(io.IniFilename).
    IMGUI_API void          LoadIniSettingsFromMemory(const char* ini_data, size_t ini_size=0); // call after CreateContext() and before the first call to NewFrame() to provide .ini data from your own data source.
    IMGUI_API void          SaveIniSettingsToDisk(const char* ini_filename);                    // this is automatically called (if io.IniFilename is not empty) a few seconds after any modification that should be reflected in the .ini file (and also by DestroyContext).
    IMGUI_API const char*   SaveIniSettingsToMemory(size_t* out_ini_size = NULL);               // return a zero-terminated string with the .ini data which you can save by your own mean. call when io.WantSaveIniSettings is set, then save data by your own mean and clear io.WantSaveIniSettings.

    // Memory Allocators
    // - All those functions are not reliant on the current context.
    // - If you reload the contents of imgui.cpp at runtime, you may need to call SetCurrentContext() + SetAllocatorFunctions() again because we use global storage for those.
    IMGUI_API void          SetAllocatorFunctions(void* (*alloc_func)(size_t sz, void* user_data), void (*free_func)(void* ptr, void* user_data), void* user_data = NULL);
    IMGUI_API void*         MemAlloc(size_t size);
    IMGUI_API void          MemFree(void* ptr);

} // namespace ImGui

//-----------------------------------------------------------------------------
// Flags & Enumerations
//-----------------------------------------------------------------------------

// Flags for ImGui::Begin()
enum ImGuiWindowFlags_
{
    ImGuiWindowFlags_None                   = 0,
    ImGuiWindowFlags_NoTitleBar             = 1 << 0,   // Disable title-bar
    ImGuiWindowFlags_NoResize               = 1 << 1,   // Disable user resizing with the lower-right grip
    ImGuiWindowFlags_NoMove                 = 1 << 2,   // Disable user moving the window
    ImGuiWindowFlags_NoScrollbar            = 1 << 3,   // Disable scrollbars (window can still scroll with mouse or programmatically)
    ImGuiWindowFlags_NoScrollWithMouse      = 1 << 4,   // Disable user vertically scrolling with mouse wheel. On child window, mouse wheel will be forwarded to the parent unless NoScrollbar is also set.
    ImGuiWindowFlags_NoCollapse             = 1 << 5,   // Disable user collapsing window by double-clicking on it
    ImGuiWindowFlags_AlwaysAutoResize       = 1 << 6,   // Resize every window to its content every frame
    ImGuiWindowFlags_NoBackground           = 1 << 7,   // Disable drawing background color (WindowBg, etc.) and outside border. Similar as using SetNextWindowBgAlpha(0.0f).
    ImGuiWindowFlags_NoSavedSettings        = 1 << 8,   // Never load/save settings in .ini file
    ImGuiWindowFlags_NoMouseInputs          = 1 << 9,   // Disable catching mouse, hovering test with pass through.
    ImGuiWindowFlags_MenuBar                = 1 << 10,  // Has a menu-bar
    ImGuiWindowFlags_HorizontalScrollbar    = 1 << 11,  // Allow horizontal scrollbar to appear (off by default). You may use SetNextWindowContentSize(ImVec2(width,0.0f)); prior to calling Begin() to specify width. Read code in imgui_demo in the "Horizontal Scrolling" section.
    ImGuiWindowFlags_NoFocusOnAppearing     = 1 << 12,  // Disable taking focus when transitioning from hidden to visible state
    ImGuiWindowFlags_NoBringToFrontOnFocus  = 1 << 13,  // Disable bringing window to front when taking focus (e.g. clicking on it or programmatically giving it focus)
    ImGuiWindowFlags_AlwaysVerticalScrollbar= 1 << 14,  // Always show vertical scrollbar (even if ContentSize.y < Size.y)
    ImGuiWindowFlags_AlwaysHorizontalScrollbar=1<< 15,  // Always show horizontal scrollbar (even if ContentSize.x < Size.x)
    ImGuiWindowFlags_AlwaysUseWindowPadding = 1 << 16,  // Ensure child windows without border uses style.WindowPadding (ignored by default for non-bordered child windows, because more convenient)
    ImGuiWindowFlags_NoNavInputs            = 1 << 18,  // No gamepad/keyboard navigation within the window
    ImGuiWindowFlags_NoNavFocus             = 1 << 19,  // No focusing toward this window with gamepad/keyboard navigation (e.g. skipped by CTRL+TAB)
    ImGuiWindowFlags_UnsavedDocument        = 1 << 20,  // Append '*' to title without affecting the ID, as a convenience to avoid using the ### operator. When used in a tab/docking context, tab is selected on closure and closure is deferred by one frame to allow code to cancel the closure (with a confirmation popup, etc.) without flicker.
    ImGuiWindowFlags_NoNav                  = ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus,
    ImGuiWindowFlags_NoDecoration           = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse,
    ImGuiWindowFlags_NoInputs               = ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus,

    // [Internal]
    ImGuiWindowFlags_NavFlattened           = 1 << 23,  // [BETA] Allow gamepad/keyboard navigation to cross over parent border to this child (only use on child that have no scrolling!)
    ImGuiWindowFlags_ChildWindow            = 1 << 24,  // Don't use! For internal use by BeginChild()
    ImGuiWindowFlags_Tooltip                = 1 << 25,  // Don't use! For internal use by BeginTooltip()
    ImGuiWindowFlags_Popup                  = 1 << 26,  // Don't use! For internal use by BeginPopup()
    ImGuiWindowFlags_Modal                  = 1 << 27,  // Don't use! For internal use by BeginPopupModal()
    ImGuiWindowFlags_ChildMenu              = 1 << 28   // Don't use! For internal use by BeginMenu()

    // [Obsolete]
    //ImGuiWindowFlags_ShowBorders          = 1 << 7,   // --> Set style.FrameBorderSize=1.0f / style.WindowBorderSize=1.0f to enable borders around windows and items
    //ImGuiWindowFlags_ResizeFromAnySide    = 1 << 17,  // --> Set io.ConfigWindowsResizeFromEdges and make sure mouse cursors are supported by back-end (io.BackendFlags & ImGuiBackendFlags_HasMouseCursors)
};

// Flags for ImGui::InputText()
enum ImGuiInputTextFlags_
{
    ImGuiInputTextFlags_None                = 0,
    ImGuiInputTextFlags_CharsDecimal        = 1 << 0,   // Allow 0123456789.+-*/
    ImGuiInputTextFlags_CharsHexadecimal    = 1 << 1,   // Allow 0123456789ABCDEFabcdef
    ImGuiInputTextFlags_CharsUppercase      = 1 << 2,   // Turn a..z into A..Z
    ImGuiInputTextFlags_CharsNoBlank        = 1 << 3,   // Filter out spaces, tabs
    ImGuiInputTextFlags_AutoSelectAll       = 1 << 4,   // Select entire text when first taking mouse focus
    ImGuiInputTextFlags_EnterReturnsTrue    = 1 << 5,   // Return 'true' when Enter is pressed (as opposed to every time the value was modified). Consider looking at the IsItemDeactivatedAfterEdit() function.
    ImGuiInputTextFlags_CallbackCompletion  = 1 << 6,   // Callback on pressing TAB (for completion handling)
    ImGuiInputTextFlags_CallbackHistory     = 1 << 7,   // Callback on pressing Up/Down arrows (for history handling)
    ImGuiInputTextFlags_CallbackAlways      = 1 << 8,   // Callback on each iteration. User code may query cursor position, modify text buffer.
    ImGuiInputTextFlags_CallbackCharFilter  = 1 << 9,   // Callback on character inputs to replace or discard them. Modify 'EventChar' to replace or discard, or return 1 in callback to discard.
    ImGuiInputTextFlags_AllowTabInput       = 1 << 10,  // Pressing TAB input a '\t' character into the text field
    ImGuiInputTextFlags_CtrlEnterForNewLine = 1 << 11,  // In multi-line mode, unfocus with Enter, add new line with Ctrl+Enter (default is opposite: unfocus with Ctrl+Enter, add line with Enter).
    ImGuiInputTextFlags_NoHorizontalScroll  = 1 << 12,  // Disable following the cursor horizontally
    ImGuiInputTextFlags_AlwaysInsertMode    = 1 << 13,  // Insert mode
    ImGuiInputTextFlags_ReadOnly            = 1 << 14,  // Read-only mode
    ImGuiInputTextFlags_Password            = 1 << 15,  // Password mode, display all characters as '*'
    ImGuiInputTextFlags_NoUndoRedo          = 1 << 16,  // Disable undo/redo. Note that input text owns the text data while active, if you want to provide your own undo/redo stack you need e.g. to call ClearActiveID().
    ImGuiInputTextFlags_CharsScientific     = 1 << 17,  // Allow 0123456789.+-*/eE (Scientific notation input)
    ImGuiInputTextFlags_CallbackResize      = 1 << 18,  // Callback on buffer capacity changes request (beyond 'buf_size' parameter value), allowing the string to grow. Notify when the string wants to be resized (for string types which hold a cache of their Size). You will be provided a new BufSize in the callback and NEED to honor it. (see misc/cpp/imgui_stdlib.h for an example of using this)
    // [Internal]
    ImGuiInputTextFlags_Multiline           = 1 << 20   // For internal use by InputTextMultiline()
};

// Flags for ImGui::TreeNodeEx(), ImGui::CollapsingHeader*()
enum ImGuiTreeNodeFlags_
{
    ImGuiTreeNodeFlags_None                 = 0,
    ImGuiTreeNodeFlags_Selected             = 1 << 0,   // Draw as selected
    ImGuiTreeNodeFlags_Framed               = 1 << 1,   // Full colored frame (e.g. for CollapsingHeader)
    ImGuiTreeNodeFlags_AllowItemOverlap     = 1 << 2,   // Hit testing to allow subsequent widgets to overlap this one
    ImGuiTreeNodeFlags_NoTreePushOnOpen     = 1 << 3,   // Don't do a TreePush() when open (e.g. for CollapsingHeader) = no extra indent nor pushing on ID stack
    ImGuiTreeNodeFlags_NoAutoOpenOnLog      = 1 << 4,   // Don't automatically and temporarily open node when Logging is active (by default logging will automatically open tree nodes)
    ImGuiTreeNodeFlags_DefaultOpen          = 1 << 5,   // Default node to be open
    ImGuiTreeNodeFlags_OpenOnDoubleClick    = 1 << 6,   // Need double-click to open node
    ImGuiTreeNodeFlags_OpenOnArrow          = 1 << 7,   // Only open when clicking on the arrow part. If ImGuiTreeNodeFlags_OpenOnDoubleClick is also set, single-click arrow or double-click all box to open.
    ImGuiTreeNodeFlags_Leaf                 = 1 << 8,   // No collapsing, no arrow (use as a convenience for leaf nodes).
    ImGuiTreeNodeFlags_Bullet               = 1 << 9,   // Display a bullet instead of arrow
    ImGuiTreeNodeFlags_FramePadding         = 1 << 10,  // Use FramePadding (even for an unframed text node) to vertically align text baseline to regular widget height. Equivalent to calling AlignTextToFramePadding().
    //ImGuiTreeNodeFlags_SpanAllAvailWidth  = 1 << 11,  // FIXME: TODO: Extend hit box horizontally even if not framed
    //ImGuiTreeNodeFlags_NoScrollOnOpen     = 1 << 12,  // FIXME: TODO: Disable automatic scroll on TreePop() if node got just open and contents is not visible
    ImGuiTreeNodeFlags_NavLeftJumpsBackHere = 1 << 13,  // (WIP) Nav: left direction may move to this TreeNode() from any of its child (items submitted between TreeNode and TreePop)
    ImGuiTreeNodeFlags_CollapsingHeader     = ImGuiTreeNodeFlags_Framed | ImGuiTreeNodeFlags_NoTreePushOnOpen | ImGuiTreeNodeFlags_NoAutoOpenOnLog

    // Obsolete names (will be removed)
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    , ImGuiTreeNodeFlags_AllowOverlapMode = ImGuiTreeNodeFlags_AllowItemOverlap
#endif
};

// Flags for ImGui::Selectable()
enum ImGuiSelectableFlags_
{
    ImGuiSelectableFlags_None               = 0,
    ImGuiSelectableFlags_DontClosePopups    = 1 << 0,   // Clicking this don't close parent popup window
    ImGuiSelectableFlags_SpanAllColumns     = 1 << 1,   // Selectable frame can span all columns (text will still fit in current column)
    ImGuiSelectableFlags_AllowDoubleClick   = 1 << 2,   // Generate press events on double clicks too
    ImGuiSelectableFlags_Disabled           = 1 << 3    // Cannot be selected, display greyed out text
};

// Flags for ImGui::BeginCombo()
enum ImGuiComboFlags_
{
    ImGuiComboFlags_None                    = 0,
    ImGuiComboFlags_PopupAlignLeft          = 1 << 0,   // Align the popup toward the left by default
    ImGuiComboFlags_HeightSmall             = 1 << 1,   // Max ~4 items visible. Tip: If you want your combo popup to be a specific size you can use SetNextWindowSizeConstraints() prior to calling BeginCombo()
    ImGuiComboFlags_HeightRegular           = 1 << 2,   // Max ~8 items visible (default)
    ImGuiComboFlags_HeightLarge             = 1 << 3,   // Max ~20 items visible
    ImGuiComboFlags_HeightLargest           = 1 << 4,   // As many fitting items as possible
    ImGuiComboFlags_NoArrowButton           = 1 << 5,   // Display on the preview box without the square arrow button
    ImGuiComboFlags_NoPreview               = 1 << 6,   // Display only a square arrow button
    ImGuiComboFlags_HeightMask_             = ImGuiComboFlags_HeightSmall | ImGuiComboFlags_HeightRegular | ImGuiComboFlags_HeightLarge | ImGuiComboFlags_HeightLargest
};

// Flags for ImGui::BeginTabBar()
enum ImGuiTabBarFlags_
{
    ImGuiTabBarFlags_None                           = 0,
    ImGuiTabBarFlags_Reorderable                    = 1 << 0,   // Allow manually dragging tabs to re-order them + New tabs are appended at the end of list
    ImGuiTabBarFlags_AutoSelectNewTabs              = 1 << 1,   // Automatically select new tabs when they appear
    ImGuiTabBarFlags_TabListPopupButton             = 1 << 2,
    ImGuiTabBarFlags_NoCloseWithMiddleMouseButton   = 1 << 3,   // Disable behavior of closing tabs (that are submitted with p_open != NULL) with middle mouse button. You can still repro this behavior on user's side with if (IsItemHovered() && IsMouseClicked(2)) *p_open = false.
    ImGuiTabBarFlags_NoTabListScrollingButtons      = 1 << 4,
    ImGuiTabBarFlags_NoTooltip                      = 1 << 5,   // Disable tooltips when hovering a tab
    ImGuiTabBarFlags_FittingPolicyResizeDown        = 1 << 6,   // Resize tabs when they don't fit
    ImGuiTabBarFlags_FittingPolicyScroll            = 1 << 7,   // Add scroll buttons when tabs don't fit
    ImGuiTabBarFlags_FittingPolicyMask_             = ImGuiTabBarFlags_FittingPolicyResizeDown | ImGuiTabBarFlags_FittingPolicyScroll,
    ImGuiTabBarFlags_FittingPolicyDefault_          = ImGuiTabBarFlags_FittingPolicyResizeDown
};

// Flags for ImGui::BeginTabItem()
enum ImGuiTabItemFlags_
{
    ImGuiTabItemFlags_None                          = 0,
    ImGuiTabItemFlags_UnsavedDocument               = 1 << 0,   // Append '*' to title without affecting the ID, as a convenience to avoid using the ### operator. Also: tab is selected on closure and closure is deferred by one frame to allow code to undo it without flicker.
    ImGuiTabItemFlags_SetSelected                   = 1 << 1,   // Trigger flag to programmatically make the tab selected when calling BeginTabItem()
    ImGuiTabItemFlags_NoCloseWithMiddleMouseButton  = 1 << 2,   // Disable behavior of closing tabs (that are submitted with p_open != NULL) with middle mouse button. You can still repro this behavior on user's side with if (IsItemHovered() && IsMouseClicked(2)) *p_open = false.
    ImGuiTabItemFlags_NoPushId                      = 1 << 3    // Don't call PushID(tab->ID)/PopID() on BeginTabItem()/EndTabItem()
};

// Flags for ImGui::IsWindowFocused()
enum ImGuiFocusedFlags_
{
    ImGuiFocusedFlags_None                          = 0,
    ImGuiFocusedFlags_ChildWindows                  = 1 << 0,   // IsWindowFocused(): Return true if any children of the window is focused
    ImGuiFocusedFlags_RootWindow                    = 1 << 1,   // IsWindowFocused(): Test from root window (top most parent of the current hierarchy)
    ImGuiFocusedFlags_AnyWindow                     = 1 << 2,   // IsWindowFocused(): Return true if any window is focused. Important: If you are trying to tell how to dispatch your low-level inputs, do NOT use this. Use ImGui::GetIO().WantCaptureMouse instead.
    ImGuiFocusedFlags_RootAndChildWindows           = ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_ChildWindows
};

// Flags for ImGui::IsItemHovered(), ImGui::IsWindowHovered()
// Note: if you are trying to check whether your mouse should be dispatched to imgui or to your app, you should use the 'io.WantCaptureMouse' boolean for that. Please read the FAQ!
// Note: windows with the ImGuiWindowFlags_NoInputs flag are ignored by IsWindowHovered() calls.
enum ImGuiHoveredFlags_
{
    ImGuiHoveredFlags_None                          = 0,        // Return true if directly over the item/window, not obstructed by another window, not obstructed by an active popup or modal blocking inputs under them.
    ImGuiHoveredFlags_ChildWindows                  = 1 << 0,   // IsWindowHovered() only: Return true if any children of the window is hovered
    ImGuiHoveredFlags_RootWindow                    = 1 << 1,   // IsWindowHovered() only: Test from root window (top most parent of the current hierarchy)
    ImGuiHoveredFlags_AnyWindow                     = 1 << 2,   // IsWindowHovered() only: Return true if any window is hovered
    ImGuiHoveredFlags_AllowWhenBlockedByPopup       = 1 << 3,   // Return true even if a popup window is normally blocking access to this item/window
    //ImGuiHoveredFlags_AllowWhenBlockedByModal     = 1 << 4,   // Return true even if a modal popup window is normally blocking access to this item/window. FIXME-TODO: Unavailable yet.
    ImGuiHoveredFlags_AllowWhenBlockedByActiveItem  = 1 << 5,   // Return true even if an active item is blocking access to this item/window. Useful for Drag and Drop patterns.
    ImGuiHoveredFlags_AllowWhenOverlapped           = 1 << 6,   // Return true even if the position is overlapped by another window
    ImGuiHoveredFlags_AllowWhenDisabled             = 1 << 7,   // Return true even if the item is disabled
    ImGuiHoveredFlags_RectOnly                      = ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem | ImGuiHoveredFlags_AllowWhenOverlapped,
    ImGuiHoveredFlags_RootAndChildWindows           = ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows
};

// Flags for ImGui::BeginDragDropSource(), ImGui::AcceptDragDropPayload()
enum ImGuiDragDropFlags_
{
    ImGuiDragDropFlags_None                         = 0,
    // BeginDragDropSource() flags
    ImGuiDragDropFlags_SourceNoPreviewTooltip       = 1 << 0,   // By default, a successful call to BeginDragDropSource opens a tooltip so you can display a preview or description of the source contents. This flag disable this behavior.
    ImGuiDragDropFlags_SourceNoDisableHover         = 1 << 1,   // By default, when dragging we clear data so that IsItemHovered() will return false, to avoid subsequent user code submitting tooltips. This flag disable this behavior so you can still call IsItemHovered() on the source item.
    ImGuiDragDropFlags_SourceNoHoldToOpenOthers     = 1 << 2,   // Disable the behavior that allows to open tree nodes and collapsing header by holding over them while dragging a source item.
    ImGuiDragDropFlags_SourceAllowNullID            = 1 << 3,   // Allow items such as Text(), Image() that have no unique identifier to be used as drag source, by manufacturing a temporary identifier based on their window-relative position. This is extremely unusual within the dear imgui ecosystem and so we made it explicit.
    ImGuiDragDropFlags_SourceExtern                 = 1 << 4,   // External source (from outside of imgui), won't attempt to read current item/window info. Will always return true. Only one Extern source can be active simultaneously.
    ImGuiDragDropFlags_SourceAutoExpirePayload      = 1 << 5,   // Automatically expire the payload if the source cease to be submitted (otherwise payloads are persisting while being dragged)
    // AcceptDragDropPayload() flags
    ImGuiDragDropFlags_AcceptBeforeDelivery         = 1 << 10,  // AcceptDragDropPayload() will returns true even before the mouse button is released. You can then call IsDelivery() to test if the payload needs to be delivered.
    ImGuiDragDropFlags_AcceptNoDrawDefaultRect      = 1 << 11,  // Do not draw the default highlight rectangle when hovering over target.
    ImGuiDragDropFlags_AcceptNoPreviewTooltip       = 1 << 12,  // Request hiding the BeginDragDropSource tooltip from the BeginDragDropTarget site.
    ImGuiDragDropFlags_AcceptPeekOnly               = ImGuiDragDropFlags_AcceptBeforeDelivery | ImGuiDragDropFlags_AcceptNoDrawDefaultRect  // For peeking ahead and inspecting the payload before delivery.
};

// Standard Drag and Drop payload types. You can define you own payload types using short strings. Types starting with '_' are defined by Dear ImGui.
#define IMGUI_PAYLOAD_TYPE_COLOR_3F     "_COL3F"    // float[3]: Standard type for colors, without alpha. User code may use this type.
#define IMGUI_PAYLOAD_TYPE_COLOR_4F     "_COL4F"    // float[4]: Standard type for colors. User code may use this type.

// A primary data type
enum ImGuiDataType_
{
    ImGuiDataType_S8,       // char
    ImGuiDataType_U8,       // unsigned char
    ImGuiDataType_S16,      // short
    ImGuiDataType_U16,      // unsigned short
    ImGuiDataType_S32,      // int
    ImGuiDataType_U32,      // unsigned int
    ImGuiDataType_S64,      // long long / __int64
    ImGuiDataType_U64,      // unsigned long long / unsigned __int64
    ImGuiDataType_Float,    // float
    ImGuiDataType_Double,   // double
    ImGuiDataType_COUNT
};

// A cardinal direction
enum ImGuiDir_
{
    ImGuiDir_None    = -1,
    ImGuiDir_Left    = 0,
    ImGuiDir_Right   = 1,
    ImGuiDir_Up      = 2,
    ImGuiDir_Down    = 3,
    ImGuiDir_COUNT
};

// User fill ImGuiIO.KeyMap[] array with indices into the ImGuiIO.KeysDown[512] array
enum ImGuiKey_
{
    ImGuiKey_Tab,
    ImGuiKey_LeftArrow,
    ImGuiKey_RightArrow,
    ImGuiKey_UpArrow,
    ImGuiKey_DownArrow,
    ImGuiKey_PageUp,
    ImGuiKey_PageDown,
    ImGuiKey_Home,
    ImGuiKey_End,
    ImGuiKey_Insert,
    ImGuiKey_Delete,
    ImGuiKey_Backspace,
    ImGuiKey_Space,
    ImGuiKey_Enter,
    ImGuiKey_Escape,
    ImGuiKey_A,         // for text edit CTRL+A: select all
    ImGuiKey_C,         // for text edit CTRL+C: copy
    ImGuiKey_V,         // for text edit CTRL+V: paste
    ImGuiKey_X,         // for text edit CTRL+X: cut
    ImGuiKey_Y,         // for text edit CTRL+Y: redo
    ImGuiKey_Z,         // for text edit CTRL+Z: undo
    ImGuiKey_COUNT
};

// Gamepad/Keyboard directional navigation
// Keyboard: Set io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard to enable. NewFrame() will automatically fill io.NavInputs[] based on your io.KeysDown[] + io.KeyMap[] arrays.
// Gamepad:  Set io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad to enable. Back-end: set ImGuiBackendFlags_HasGamepad and fill the io.NavInputs[] fields before calling NewFrame(). Note that io.NavInputs[] is cleared by EndFrame().
// Read instructions in imgui.cpp for more details. Download PNG/PSD at http://goo.gl/9LgVZW.
enum ImGuiNavInput_
{
    // Gamepad Mapping
    ImGuiNavInput_Activate,      // activate / open / toggle / tweak value       // e.g. Cross  (PS4), A (Xbox), A (Switch), Space (Keyboard)
    ImGuiNavInput_Cancel,        // cancel / close / exit                        // e.g. Circle (PS4), B (Xbox), B (Switch), Escape (Keyboard)
    ImGuiNavInput_Input,         // text input / on-screen keyboard              // e.g. Triang.(PS4), Y (Xbox), X (Switch), Return (Keyboard)
    ImGuiNavInput_Menu,          // tap: toggle menu / hold: focus, move, resize // e.g. Square (PS4), X (Xbox), Y (Switch), Alt (Keyboard)
    ImGuiNavInput_DpadLeft,      // move / tweak / resize window (w/ PadMenu)    // e.g. D-pad Left/Right/Up/Down (Gamepads), Arrow keys (Keyboard)
    ImGuiNavInput_DpadRight,     //
    ImGuiNavInput_DpadUp,        //
    ImGuiNavInput_DpadDown,      //
    ImGuiNavInput_LStickLeft,    // scroll / move window (w/ PadMenu)            // e.g. Left Analog Stick Left/Right/Up/Down
    ImGuiNavInput_LStickRight,   //
    ImGuiNavInput_LStickUp,      //
    ImGuiNavInput_LStickDown,    //
    ImGuiNavInput_FocusPrev,     // next window (w/ PadMenu)                     // e.g. L1 or L2 (PS4), LB or LT (Xbox), L or ZL (Switch)
    ImGuiNavInput_FocusNext,     // prev window (w/ PadMenu)                     // e.g. R1 or R2 (PS4), RB or RT (Xbox), R or ZL (Switch)
    ImGuiNavInput_TweakSlow,     // slower tweaks                                // e.g. L1 or L2 (PS4), LB or LT (Xbox), L or ZL (Switch)
    ImGuiNavInput_TweakFast,     // faster tweaks                                // e.g. R1 or R2 (PS4), RB or RT (Xbox), R or ZL (Switch)

    // [Internal] Don't use directly! This is used internally to differentiate keyboard from gamepad inputs for behaviors that require to differentiate them.
    // Keyboard behavior that have no corresponding gamepad mapping (e.g. CTRL+TAB) will be directly reading from io.KeysDown[] instead of io.NavInputs[].
    ImGuiNavInput_KeyMenu_,      // toggle menu                                  // = io.KeyAlt
    ImGuiNavInput_KeyTab_,       // tab                                          // = Tab key
    ImGuiNavInput_KeyLeft_,      // move left                                    // = Arrow keys
    ImGuiNavInput_KeyRight_,     // move right
    ImGuiNavInput_KeyUp_,        // move up
    ImGuiNavInput_KeyDown_,      // move down
    ImGuiNavInput_COUNT,
    ImGuiNavInput_InternalStart_ = ImGuiNavInput_KeyMenu_
};

// Configuration flags stored in io.ConfigFlags. Set by user/application.
enum ImGuiConfigFlags_
{
    ImGuiConfigFlags_None                   = 0,
    ImGuiConfigFlags_NavEnableKeyboard      = 1 << 0,   // Master keyboard navigation enable flag. NewFrame() will automatically fill io.NavInputs[] based on io.KeysDown[].
    ImGuiConfigFlags_NavEnableGamepad       = 1 << 1,   // Master gamepad navigation enable flag. This is mostly to instruct your imgui back-end to fill io.NavInputs[]. Back-end also needs to set ImGuiBackendFlags_HasGamepad.
    ImGuiConfigFlags_NavEnableSetMousePos   = 1 << 2,   // Instruct navigation to move the mouse cursor. May be useful on TV/console systems where moving a virtual mouse is awkward. Will update io.MousePos and set io.WantSetMousePos=true. If enabled you MUST honor io.WantSetMousePos requests in your binding, otherwise ImGui will react as if the mouse is jumping around back and forth.
    ImGuiConfigFlags_NavNoCaptureKeyboard   = 1 << 3,   // Instruct navigation to not set the io.WantCaptureKeyboard flag when io.NavActive is set.
    ImGuiConfigFlags_NoMouse                = 1 << 4,   // Instruct imgui to clear mouse position/buttons in NewFrame(). This allows ignoring the mouse information set by the back-end.
    ImGuiConfigFlags_NoMouseCursorChange    = 1 << 5,   // Instruct back-end to not alter mouse cursor shape and visibility. Use if the back-end cursor changes are interfering with yours and you don't want to use SetMouseCursor() to change mouse cursor. You may want to honor requests from imgui by reading GetMouseCursor() yourself instead.

    // User storage (to allow your back-end/engine to communicate to code that may be shared between multiple projects. Those flags are not used by core ImGui)
    ImGuiConfigFlags_IsSRGB                 = 1 << 20,  // Application is SRGB-aware.
    ImGuiConfigFlags_IsTouchScreen          = 1 << 21   // Application is using a touch screen instead of a mouse.
};

// Back-end capabilities flags stored in io.BackendFlags. Set by imgui_impl_xxx or custom back-end.
enum ImGuiBackendFlags_
{
    ImGuiBackendFlags_None                  = 0,
    ImGuiBackendFlags_HasGamepad            = 1 << 0,   // Back-end supports gamepad and currently has one connected.
    ImGuiBackendFlags_HasMouseCursors       = 1 << 1,   // Back-end supports honoring GetMouseCursor() value to change the OS cursor shape.
    ImGuiBackendFlags_HasSetMousePos        = 1 << 2    // Back-end supports io.WantSetMousePos requests to reposition the OS mouse position (only used if ImGuiConfigFlags_NavEnableSetMousePos is set).
};

// Enumeration for PushStyleColor() / PopStyleColor()
enum ImGuiCol_
{
    ImGuiCol_Text,
    ImGuiCol_TextDisabled,
    ImGuiCol_WindowBg,              // Background of normal windows
    ImGuiCol_ChildBg,               // Background of child windows
    ImGuiCol_PopupBg,               // Background of popups, menus, tooltips windows
    ImGuiCol_Border,
    ImGuiCol_BorderShadow,
    ImGuiCol_FrameBg,               // Background of checkbox, radio button, plot, slider, text input
    ImGuiCol_FrameBgHovered,
    ImGuiCol_FrameBgActive,
    ImGuiCol_TitleBg,
    ImGuiCol_TitleBgActive,
    ImGuiCol_TitleBgCollapsed,
    ImGuiCol_MenuBarBg,
    ImGuiCol_ScrollbarBg,
    ImGuiCol_ScrollbarGrab,
    ImGuiCol_ScrollbarGrabHovered,
    ImGuiCol_ScrollbarGrabActive,
    ImGuiCol_CheckMark,
    ImGuiCol_SliderGrab,
    ImGuiCol_SliderGrabActive,
    ImGuiCol_Button,
    ImGuiCol_ButtonHovered,
    ImGuiCol_ButtonActive,
    ImGuiCol_Header,
    ImGuiCol_HeaderHovered,
    ImGuiCol_HeaderActive,
    ImGuiCol_Separator,
    ImGuiCol_SeparatorHovered,
    ImGuiCol_SeparatorActive,
    ImGuiCol_ResizeGrip,
    ImGuiCol_ResizeGripHovered,
    ImGuiCol_ResizeGripActive,
    ImGuiCol_Tab,
    ImGuiCol_TabHovered,
    ImGuiCol_TabActive,
    ImGuiCol_TabUnfocused,
    ImGuiCol_TabUnfocusedActive,
    ImGuiCol_PlotLines,
    ImGuiCol_PlotLinesHovered,
    ImGuiCol_PlotHistogram,
    ImGuiCol_PlotHistogramHovered,
    ImGuiCol_TextSelectedBg,
    ImGuiCol_DragDropTarget,
    ImGuiCol_NavHighlight,          // Gamepad/keyboard: current highlighted item
    ImGuiCol_NavWindowingHighlight, // Highlight window when using CTRL+TAB
    ImGuiCol_NavWindowingDimBg,     // Darken/colorize entire screen behind the CTRL+TAB window list, when active
    ImGuiCol_ModalWindowDimBg,      // Darken/colorize entire screen behind a modal window, when one is active
    ImGuiCol_COUNT

    // Obsolete names (will be removed)
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    , ImGuiCol_ModalWindowDarkening = ImGuiCol_ModalWindowDimBg                      // [renamed in 1.63]
    , ImGuiCol_ChildWindowBg = ImGuiCol_ChildBg                                      // [renamed in 1.53]
    , ImGuiCol_Column = ImGuiCol_Separator, ImGuiCol_ColumnHovered = ImGuiCol_SeparatorHovered, ImGuiCol_ColumnActive = ImGuiCol_SeparatorActive  // [renamed in 1.51]
    //ImGuiCol_CloseButton, ImGuiCol_CloseButtonActive, ImGuiCol_CloseButtonHovered, // [unused since 1.60+] the close button now uses regular button colors.
    //ImGuiCol_ComboBg,                                                              // [unused since 1.53+] ComboBg has been merged with PopupBg, so a redirect isn't accurate.
#endif
};

// Enumeration for PushStyleVar() / PopStyleVar() to temporarily modify the ImGuiStyle structure.
// NB: the enum only refers to fields of ImGuiStyle which makes sense to be pushed/popped inside UI code. During initialization, feel free to just poke into ImGuiStyle directly.
// NB: if changing this enum, you need to update the associated internal table GStyleVarInfo[] accordingly. This is where we link enum values to members offset/type.
enum ImGuiStyleVar_
{
    // Enum name --------------------- // Member in ImGuiStyle structure (see ImGuiStyle for descriptions)
    ImGuiStyleVar_Alpha,               // float     Alpha
    ImGuiStyleVar_WindowPadding,       // ImVec2    WindowPadding
    ImGuiStyleVar_WindowRounding,      // float     WindowRounding
    ImGuiStyleVar_WindowBorderSize,    // float     WindowBorderSize
    ImGuiStyleVar_WindowMinSize,       // ImVec2    WindowMinSize
    ImGuiStyleVar_WindowTitleAlign,    // ImVec2    WindowTitleAlign
    ImGuiStyleVar_ChildRounding,       // float     ChildRounding
    ImGuiStyleVar_ChildBorderSize,     // float     ChildBorderSize
    ImGuiStyleVar_PopupRounding,       // float     PopupRounding
    ImGuiStyleVar_PopupBorderSize,     // float     PopupBorderSize
    ImGuiStyleVar_FramePadding,        // ImVec2    FramePadding
    ImGuiStyleVar_FrameRounding,       // float     FrameRounding
    ImGuiStyleVar_FrameBorderSize,     // float     FrameBorderSize
    ImGuiStyleVar_ItemSpacing,         // ImVec2    ItemSpacing
    ImGuiStyleVar_ItemInnerSpacing,    // ImVec2    ItemInnerSpacing
    ImGuiStyleVar_IndentSpacing,       // float     IndentSpacing
    ImGuiStyleVar_ScrollbarSize,       // float     ScrollbarSize
    ImGuiStyleVar_ScrollbarRounding,   // float     ScrollbarRounding
    ImGuiStyleVar_GrabMinSize,         // float     GrabMinSize
    ImGuiStyleVar_GrabRounding,        // float     GrabRounding
    ImGuiStyleVar_TabRounding,         // float     TabRounding
    ImGuiStyleVar_ButtonTextAlign,     // ImVec2    ButtonTextAlign
    ImGuiStyleVar_SelectableTextAlign, // ImVec2    SelectableTextAlign
    ImGuiStyleVar_COUNT

    // Obsolete names (will be removed)
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    , ImGuiStyleVar_Count_ = ImGuiStyleVar_COUNT, ImGuiStyleVar_ChildWindowRounding = ImGuiStyleVar_ChildRounding
#endif
};

// Flags for ColorEdit3() / ColorEdit4() / ColorPicker3() / ColorPicker4() / ColorButton()
enum ImGuiColorEditFlags_
{
    ImGuiColorEditFlags_None            = 0,
    ImGuiColorEditFlags_NoAlpha         = 1 << 1,   //              // ColorEdit, ColorPicker, ColorButton: ignore Alpha component (will only read 3 components from the input pointer).
    ImGuiColorEditFlags_NoPicker        = 1 << 2,   //              // ColorEdit: disable picker when clicking on colored square.
    ImGuiColorEditFlags_NoOptions       = 1 << 3,   //              // ColorEdit: disable toggling options menu when right-clicking on inputs/small preview.
    ImGuiColorEditFlags_NoSmallPreview  = 1 << 4,   //              // ColorEdit, ColorPicker: disable colored square preview next to the inputs. (e.g. to show only the inputs)
    ImGuiColorEditFlags_NoInputs        = 1 << 5,   //              // ColorEdit, ColorPicker: disable inputs sliders/text widgets (e.g. to show only the small preview colored square).
    ImGuiColorEditFlags_NoTooltip       = 1 << 6,   //              // ColorEdit, ColorPicker, ColorButton: disable tooltip when hovering the preview.
    ImGuiColorEditFlags_NoLabel         = 1 << 7,   //              // ColorEdit, ColorPicker: disable display of inline text label (the label is still forwarded to the tooltip and picker).
    ImGuiColorEditFlags_NoSidePreview   = 1 << 8,   //              // ColorPicker: disable bigger color preview on right side of the picker, use small colored square preview instead.
    ImGuiColorEditFlags_NoDragDrop      = 1 << 9,   //              // ColorEdit: disable drag and drop target. ColorButton: disable drag and drop source.

    // User Options (right-click on widget to change some of them).
    ImGuiColorEditFlags_AlphaBar        = 1 << 16,  //              // ColorEdit, ColorPicker: show vertical alpha bar/gradient in picker.
    ImGuiColorEditFlags_AlphaPreview    = 1 << 17,  //              // ColorEdit, ColorPicker, ColorButton: display preview as a transparent color over a checkerboard, instead of opaque.
    ImGuiColorEditFlags_AlphaPreviewHalf= 1 << 18,  //              // ColorEdit, ColorPicker, ColorButton: display half opaque / half checkerboard, instead of opaque.
    ImGuiColorEditFlags_HDR             = 1 << 19,  //              // (WIP) ColorEdit: Currently only disable 0.0f..1.0f limits in RGBA edition (note: you probably want to use ImGuiColorEditFlags_Float flag as well).
    ImGuiColorEditFlags_DisplayRGB      = 1 << 20,  // [Display]    // ColorEdit: override _display_ type among RGB/HSV/Hex. ColorPicker: select any combination using one or more of RGB/HSV/Hex.
    ImGuiColorEditFlags_DisplayHSV      = 1 << 21,  // [Display]    // "
    ImGuiColorEditFlags_DisplayHex      = 1 << 22,  // [Display]    // "
    ImGuiColorEditFlags_Uint8           = 1 << 23,  // [DataType]   // ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0..255.
    ImGuiColorEditFlags_Float           = 1 << 24,  // [DataType]   // ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0.0f..1.0f floats instead of 0..255 integers. No round-trip of value via integers.
    ImGuiColorEditFlags_PickerHueBar    = 1 << 25,  // [Picker]     // ColorPicker: bar for Hue, rectangle for Sat/Value.
    ImGuiColorEditFlags_PickerHueWheel  = 1 << 26,  // [Picker]     // ColorPicker: wheel for Hue, triangle for Sat/Value.
    ImGuiColorEditFlags_InputRGB        = 1 << 27,  // [Input]      // ColorEdit, ColorPicker: input and output data in RGB format.
    ImGuiColorEditFlags_InputHSV        = 1 << 28,  // [Input]      // ColorEdit, ColorPicker: input and output data in HSV format.

    // Defaults Options. You can set application defaults using SetColorEditOptions(). The intent is that you probably don't want to
    // override them in most of your calls. Let the user choose via the option menu and/or call SetColorEditOptions() once during startup.
    ImGuiColorEditFlags__OptionsDefault = ImGuiColorEditFlags_Uint8|ImGuiColorEditFlags_DisplayRGB|ImGuiColorEditFlags_InputRGB|ImGuiColorEditFlags_PickerHueBar,

    // [Internal] Masks
    ImGuiColorEditFlags__DisplayMask    = ImGuiColorEditFlags_DisplayRGB|ImGuiColorEditFlags_DisplayHSV|ImGuiColorEditFlags_DisplayHex,
    ImGuiColorEditFlags__DataTypeMask   = ImGuiColorEditFlags_Uint8|ImGuiColorEditFlags_Float,
    ImGuiColorEditFlags__PickerMask     = ImGuiColorEditFlags_PickerHueWheel|ImGuiColorEditFlags_PickerHueBar,
    ImGuiColorEditFlags__InputMask      = ImGuiColorEditFlags_InputRGB|ImGuiColorEditFlags_InputHSV

    // Obsolete names (will be removed)
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    , ImGuiColorEditFlags_RGB = ImGuiColorEditFlags_DisplayRGB, ImGuiColorEditFlags_HSV = ImGuiColorEditFlags_DisplayHSV, ImGuiColorEditFlags_HEX = ImGuiColorEditFlags_DisplayHex
#endif
};

// Enumeration for GetMouseCursor()
// User code may request binding to display given cursor by calling SetMouseCursor(), which is why we have some cursors that are marked unused here
enum ImGuiMouseCursor_
{
    ImGuiMouseCursor_None = -1,
    ImGuiMouseCursor_Arrow = 0,
    ImGuiMouseCursor_TextInput,         // When hovering over InputText, etc.
    ImGuiMouseCursor_ResizeAll,         // (Unused by imgui functions)
    ImGuiMouseCursor_ResizeNS,          // When hovering over an horizontal border
    ImGuiMouseCursor_ResizeEW,          // When hovering over a vertical border or a column
    ImGuiMouseCursor_ResizeNESW,        // When hovering over the bottom-left corner of a window
    ImGuiMouseCursor_ResizeNWSE,        // When hovering over the bottom-right corner of a window
    ImGuiMouseCursor_Hand,              // (Unused by imgui functions. Use for e.g. hyperlinks)
    ImGuiMouseCursor_COUNT

    // Obsolete names (will be removed)
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    , ImGuiMouseCursor_Count_ = ImGuiMouseCursor_COUNT
#endif
};

// Enumateration for ImGui::SetWindow***(), SetNextWindow***(), SetNextTreeNode***() functions
// Represent a condition.
// Important: Treat as a regular enum! Do NOT combine multiple values using binary operators! All the functions above treat 0 as a shortcut to ImGuiCond_Always.
enum ImGuiCond_
{
    ImGuiCond_Always        = 1 << 0,   // Set the variable
    ImGuiCond_Once          = 1 << 1,   // Set the variable once per runtime session (only the first call with succeed)
    ImGuiCond_FirstUseEver  = 1 << 2,   // Set the variable if the object/window has no persistently saved data (no entry in .ini file)
    ImGuiCond_Appearing     = 1 << 3    // Set the variable if the object/window is appearing after being hidden/inactive (or the first time)

    // Obsolete names (will be removed)
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    , ImGuiSetCond_Always = ImGuiCond_Always, ImGuiSetCond_Once = ImGuiCond_Once, ImGuiSetCond_FirstUseEver = ImGuiCond_FirstUseEver, ImGuiSetCond_Appearing = ImGuiCond_Appearing
#endif
};

//-----------------------------------------------------------------------------
// Helpers: Memory allocations macros
// IM_MALLOC(), IM_FREE(), IM_NEW(), IM_PLACEMENT_NEW(), IM_DELETE()
// We call C++ constructor on own allocated memory via the placement "new(ptr) Type()" syntax.
// Defining a custom placement new() with a dummy parameter allows us to bypass including <new> which on some platforms complains when user has disabled exceptions.
//-----------------------------------------------------------------------------

struct ImNewDummy {};
inline void* operator new(size_t, ImNewDummy, void* ptr) { return ptr; }
inline void  operator delete(void*, ImNewDummy, void*)   {} // This is only required so we can use the symmetrical new()
#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
#define IM_PLACEMENT_NEW(_PTR)              new(ImNewDummy(), _PTR)
#define IM_NEW(_TYPE)                       new(ImNewDummy(), ImGui::MemAlloc(sizeof(_TYPE))) _TYPE
template<typename T> void IM_DELETE(T* p)   { if (p) { p->~T(); ImGui::MemFree(p); } }

//-----------------------------------------------------------------------------
// Helper: ImVector<>
// Lightweight std::vector<>-like class to avoid dragging dependencies (also, some implementations of STL with debug enabled are absurdly slow, we bypass it so our code runs fast in debug).
// You generally do NOT need to care or use this ever. But we need to make it available in imgui.h because some of our data structures are relying on it.
// Important: clear() frees memory, resize(0) keep the allocated buffer. We use resize(0) a lot to intentionally recycle allocated buffers across frames and amortize our costs.
// Important: our implementation does NOT call C++ constructors/destructors, we treat everything as raw data! This is intentional but be extra mindful of that,
// do NOT use this class as a std::vector replacement in your own code! Many of the structures used by dear imgui can be safely initialized by a zero-memset.
//-----------------------------------------------------------------------------

template<typename T>
struct ImVector
{
    int                 Size;
    int                 Capacity;
    T*                  Data;

    // Provide standard typedefs but we don't use them ourselves.
    typedef T                   value_type;
    typedef value_type*         iterator;
    typedef const value_type*   const_iterator;

    // Constructors, destructor
    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
    inline ImVector(const ImVector<T>& src)                 { Size = Capacity = 0; Data = NULL; operator=(src); }
    inline ImVector<T>& operator=(const ImVector<T>& src)   { clear(); resize(src.Size); memcpy(Data, src.Data, (size_t)Size * sizeof(T)); return *this; }
    inline ~ImVector()                                      { if (Data) IM_FREE(Data); }

    inline bool         empty() const                       { return Size == 0; }
    inline int          size() const                        { return Size; }
    inline int          size_in_bytes() const               { return Size * (int)sizeof(T); }
    inline int          capacity() const                    { return Capacity; }
    inline T&           operator[](int i)                   { IM_ASSERT(i < Size); return Data[i]; }
    inline const T&     operator[](int i) const             { IM_ASSERT(i < Size); return Data[i]; }

    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }
    inline T*           begin()                             { return Data; }
    inline const T*     begin() const                       { return Data; }
    inline T*           end()                               { return Data + Size; }
    inline const T*     end() const                         { return Data + Size; }
    inline T&           front()                             { IM_ASSERT(Size > 0); return Data[0]; }
    inline const T&     front() const                       { IM_ASSERT(Size > 0); return Data[0]; }
    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
    inline const T&     back() const                        { IM_ASSERT(Size > 0); return Data[Size - 1]; }
    inline void         swap(ImVector<T>& rhs)              { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; T* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }

    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > sz ? new_capacity : sz; }
    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
    inline void         resize(int new_size, const T& v)    { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }
    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

    // NB: It is illegal to call push_back/push_front/insert with a reference pointing inside the ImVector data itself! e.g. v.push_back(v[10]) is forbidden.
    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
    inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }
    inline void         push_front(const T& v)              { if (Size == 0) push_back(v); else insert(Data, v); }
    inline T*           erase(const T* it)                  { IM_ASSERT(it >= Data && it < Data+Size); const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + 1, ((size_t)Size - (size_t)off - 1) * sizeof(T)); Size--; return Data + off; }
    inline T*           erase(const T* it, const T* it_last){ IM_ASSERT(it >= Data && it < Data+Size && it_last > it && it_last <= Data+Size); const ptrdiff_t count = it_last - it; const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + count, ((size_t)Size - (size_t)off - count) * sizeof(T)); Size -= (int)count; return Data + off; }
    inline T*           erase_unsorted(const T* it)         { IM_ASSERT(it >= Data && it < Data+Size);  const ptrdiff_t off = it - Data; if (it < Data+Size-1) memcpy(Data + off, Data + Size - 1, sizeof(T)); Size--; return Data + off; }
    inline T*           insert(const T* it, const T& v)     { IM_ASSERT(it >= Data && it <= Data+Size); const ptrdiff_t off = it - Data; if (Size == Capacity) reserve(_grow_capacity(Size + 1)); if (off < (int)Size) memmove(Data + off + 1, Data + off, ((size_t)Size - (size_t)off) * sizeof(T)); memcpy(&Data[off], &v, sizeof(v)); Size++; return Data + off; }
    inline bool         contains(const T& v) const          { const T* data = Data;  const T* data_end = Data + Size; while (data < data_end) if (*data++ == v) return true; return false; }
    inline int          index_from_ptr(const T* it) const   { IM_ASSERT(it >= Data && it <= Data+Size); const ptrdiff_t off = it - Data; return (int)off; }
};

//-----------------------------------------------------------------------------
// ImGuiStyle
// You may modify the ImGui::GetStyle() main instance during initialization and before NewFrame().
// During the frame, use ImGui::PushStyleVar(ImGuiStyleVar_XXXX)/PopStyleVar() to alter the main style values,
// and ImGui::PushStyleColor(ImGuiCol_XXX)/PopStyleColor() for colors.
//-----------------------------------------------------------------------------

struct ImGuiStyle
{
    float       Alpha;                      // Global alpha applies to everything in ImGui.
    ImVec2      WindowPadding;              // Padding within a window.
    float       WindowRounding;             // Radius of window corners rounding. Set to 0.0f to have rectangular windows.
    float       WindowBorderSize;           // Thickness of border around windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
    ImVec2      WindowMinSize;              // Minimum window size. This is a global setting. If you want to constraint individual windows, use SetNextWindowSizeConstraints().
    ImVec2      WindowTitleAlign;           // Alignment for title bar text. Defaults to (0.0f,0.5f) for left-aligned,vertically centered.
    float       ChildRounding;              // Radius of child window corners rounding. Set to 0.0f to have rectangular windows.
    float       ChildBorderSize;            // Thickness of border around child windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
    float       PopupRounding;              // Radius of popup window corners rounding. (Note that tooltip windows use WindowRounding)
    float       PopupBorderSize;            // Thickness of border around popup/tooltip windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
    ImVec2      FramePadding;               // Padding within a framed rectangle (used by most widgets).
    float       FrameRounding;              // Radius of frame corners rounding. Set to 0.0f to have rectangular frame (used by most widgets).
    float       FrameBorderSize;            // Thickness of border around frames. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
    ImVec2      ItemSpacing;                // Horizontal and vertical spacing between widgets/lines.
    ImVec2      ItemInnerSpacing;           // Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label).
    ImVec2      TouchExtraPadding;          // Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!
    float       IndentSpacing;              // Horizontal indentation when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).
    float       ColumnsMinSpacing;          // Minimum horizontal spacing between two columns.
    float       ScrollbarSize;              // Width of the vertical scrollbar, Height of the horizontal scrollbar.
    float       ScrollbarRounding;          // Radius of grab corners for scrollbar.
    float       GrabMinSize;                // Minimum width/height of a grab box for slider/scrollbar.
    float       GrabRounding;               // Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.
    float       TabRounding;                // Radius of upper corners of a tab. Set to 0.0f to have rectangular tabs.
    float       TabBorderSize;              // Thickness of border around tabs.
    ImVec2      ButtonTextAlign;            // Alignment of button text when button is larger than text. Defaults to (0.5f, 0.5f) (centered).
    ImVec2      SelectableTextAlign;        // Alignment of selectable text when selectable is larger than text. Defaults to (0.0f, 0.0f) (top-left aligned).
    ImVec2      DisplayWindowPadding;       // Window position are clamped to be visible within the display area by at least this amount. Only applies to regular windows.
    ImVec2      DisplaySafeAreaPadding;     // If you cannot see the edges of your screen (e.g. on a TV) increase the safe area padding. Apply to popups/tooltips as well regular windows. NB: Prefer configuring your TV sets correctly!
    float       MouseCursorScale;           // Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). May be removed later.
    bool        AntiAliasedLines;           // Enable anti-aliasing on lines/borders. Disable if you are really tight on CPU/GPU.
    bool        AntiAliasedFill;            // Enable anti-aliasing on filled shapes (rounded rectangles, circles, etc.)
    float       CurveTessellationTol;       // Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.
    ImVec4      Colors[ImGuiCol_COUNT];

    IMGUI_API ImGuiStyle();
    IMGUI_API void ScaleAllSizes(float scale_factor);
};

//-----------------------------------------------------------------------------
// ImGuiIO
// Communicate most settings and inputs/outputs to Dear ImGui using this structure.
// Access via ImGui::GetIO(). Read 'Programmer guide' section in .cpp file for general usage.
//-----------------------------------------------------------------------------

struct ImGuiIO
{
    //------------------------------------------------------------------
    // Configuration (fill once)                // Default value
    //------------------------------------------------------------------

    ImGuiConfigFlags   ConfigFlags;             // = 0              // See ImGuiConfigFlags_ enum. Set by user/application. Gamepad/keyboard navigation options, etc.
    ImGuiBackendFlags  BackendFlags;            // = 0              // See ImGuiBackendFlags_ enum. Set by back-end (imgui_impl_xxx files or custom back-end) to communicate features supported by the back-end.
    ImVec2      DisplaySize;                    // <unset>          // Main display size, in pixels.
    float       DeltaTime;                      // = 1.0f/60.0f     // Time elapsed since last frame, in seconds.
    float       IniSavingRate;                  // = 5.0f           // Minimum time between saving positions/sizes to .ini file, in seconds.
    const char* IniFilename;                    // = "imgui.ini"    // Path to .ini file. Set NULL to disable automatic .ini loading/saving, if e.g. you want to manually load/save from memory.
    const char* LogFilename;                    // = "imgui_log.txt"// Path to .log file (default parameter to ImGui::LogToFile when no file is specified).
    float       MouseDoubleClickTime;           // = 0.30f          // Time for a double-click, in seconds.
    float       MouseDoubleClickMaxDist;        // = 6.0f           // Distance threshold to stay in to validate a double-click, in pixels.
    float       MouseDragThreshold;             // = 6.0f           // Distance threshold before considering we are dragging.
    int         KeyMap[ImGuiKey_COUNT];         // <unset>          // Map of indices into the KeysDown[512] entries array which represent your "native" keyboard state.
    float       KeyRepeatDelay;                 // = 0.250f         // When holding a key/button, time before it starts repeating, in seconds (for buttons in Repeat mode, etc.).
    float       KeyRepeatRate;                  // = 0.050f         // When holding a key/button, rate at which it repeats, in seconds.
    void*       UserData;                       // = NULL           // Store your own data for retrieval by callbacks.

    ImFontAtlas*Fonts;                          // <auto>           // Load, rasterize and pack one or more fonts into a single texture.
    float       FontGlobalScale;                // = 1.0f           // Global scale all fonts
    bool        FontAllowUserScaling;           // = false          // Allow user scaling text of individual window with CTRL+Wheel.
    ImFont*     FontDefault;                    // = NULL           // Font to use on NewFrame(). Use NULL to uses Fonts->Fonts[0].
    ImVec2      DisplayFramebufferScale;        // = (1, 1)         // For retina display or other situations where window coordinates are different from framebuffer coordinates. This generally ends up in ImDrawData::FramebufferScale.

    // Miscellaneous options
    bool        MouseDrawCursor;                // = false          // Request ImGui to draw a mouse cursor for you (if you are on a platform without a mouse cursor). Cannot be easily renamed to 'io.ConfigXXX' because this is frequently used by back-end implementations.
    bool        ConfigMacOSXBehaviors;          // = defined(__APPLE__) // OS X style: Text editing cursor movement using Alt instead of Ctrl, Shortcuts using Cmd/Super instead of Ctrl, Line/Text Start and End using Cmd+Arrows instead of Home/End, Double click selects by word instead of selecting whole text, Multi-selection in lists uses Cmd/Super instead of Ctrl (was called io.OptMacOSXBehaviors prior to 1.63)
    bool        ConfigInputTextCursorBlink;     // = true           // Set to false to disable blinking cursor, for users who consider it distracting. (was called: io.OptCursorBlink prior to 1.63)
    bool        ConfigWindowsResizeFromEdges;   // = true           // Enable resizing of windows from their edges and from the lower-left corner. This requires (io.BackendFlags & ImGuiBackendFlags_HasMouseCursors) because it needs mouse cursor feedback. (This used to be a per-window ImGuiWindowFlags_ResizeFromAnySide flag)
    bool        ConfigWindowsMoveFromTitleBarOnly; // = false       // [BETA] Set to true to only allow moving windows when clicked+dragged from the title bar. Windows without a title bar are not affected.

    //------------------------------------------------------------------
    // Platform Functions
    // (the imgui_impl_xxxx back-end files are setting those up for you)
    //------------------------------------------------------------------

    // Optional: Platform/Renderer back-end name (informational only! will be displayed in About Window) + User data for back-end/wrappers to store their own stuff.
    const char* BackendPlatformName;            // = NULL
    const char* BackendRendererName;            // = NULL
    void*       BackendPlatformUserData;        // = NULL
    void*       BackendRendererUserData;        // = NULL
    void*       BackendLanguageUserData;        // = NULL

    // Optional: Access OS clipboard
    // (default to use native Win32 clipboard on Windows, otherwise uses a private clipboard. Override to access OS clipboard on other architectures)
    const char* (*GetClipboardTextFn)(void* user_data);
    void        (*SetClipboardTextFn)(void* user_data, const char* text);
    void*       ClipboardUserData;

    // Optional: Notify OS Input Method Editor of the screen position of your cursor for text input position (e.g. when using Japanese/Chinese IME on Windows)
    // (default to use native imm32 api on Windows)
    void        (*ImeSetInputScreenPosFn)(int x, int y);
    void*       ImeWindowHandle;                // = NULL           // (Windows) Set this to your HWND to get automatic IME cursor positioning.

#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    // [OBSOLETE since 1.60+] Rendering function, will be automatically called in Render(). Please call your rendering function yourself now!
    // You can obtain the ImDrawData* by calling ImGui::GetDrawData() after Render(). See example applications if you are unsure of how to implement this.
    void        (*RenderDrawListsFn)(ImDrawData* data);
#else
    // This is only here to keep ImGuiIO the same size/layout, so that IMGUI_DISABLE_OBSOLETE_FUNCTIONS can exceptionally be used outside of imconfig.h.
    void*       RenderDrawListsFnUnused;
#endif

    //------------------------------------------------------------------
    // Input - Fill before calling NewFrame()
    //------------------------------------------------------------------

    ImVec2      MousePos;                       // Mouse position, in pixels. Set to ImVec2(-FLT_MAX,-FLT_MAX) if mouse is unavailable (on another screen, etc.)
    bool        MouseDown[5];                   // Mouse buttons: 0=left, 1=right, 2=middle + extras. ImGui itself mostly only uses left button (BeginPopupContext** are using right button). Others buttons allows us to track if the mouse is being used by your application + available to user as a convenience via IsMouse** API.
    float       MouseWheel;                     // Mouse wheel Vertical: 1 unit scrolls about 5 lines text.
    float       MouseWheelH;                    // Mouse wheel Horizontal. Most users don't have a mouse with an horizontal wheel, may not be filled by all back-ends.
    bool        KeyCtrl;                        // Keyboard modifier pressed: Control
    bool        KeyShift;                       // Keyboard modifier pressed: Shift
    bool        KeyAlt;                         // Keyboard modifier pressed: Alt
    bool        KeySuper;                       // Keyboard modifier pressed: Cmd/Super/Windows
    bool        KeysDown[512];                  // Keyboard keys that are pressed (ideally left in the "native" order your engine has access to keyboard keys, so you can use your own defines/enums for keys).
    float       NavInputs[ImGuiNavInput_COUNT]; // Gamepad inputs. Cleared back to zero by EndFrame(). Keyboard keys will be auto-mapped and be written here by NewFrame().

    // Functions
    IMGUI_API void  AddInputCharacter(ImWchar c);               // Queue new character input
    IMGUI_API void  AddInputCharactersUTF8(const char* str);    // Queue new characters input from an UTF-8 string
    IMGUI_API void  ClearInputCharacters();                     // Clear the text input buffer manually

    //------------------------------------------------------------------
    // Output - Retrieve after calling NewFrame()
    //------------------------------------------------------------------

    bool        WantCaptureMouse;               // When io.WantCaptureMouse is true, imgui will use the mouse inputs, do not dispatch them to your main game/application (in both cases, always pass on mouse inputs to imgui). (e.g. unclicked mouse is hovering over an imgui window, widget is active, mouse was clicked over an imgui window, etc.).
    bool        WantCaptureKeyboard;            // When io.WantCaptureKeyboard is true, imgui will use the keyboard inputs, do not dispatch them to your main game/application (in both cases, always pass keyboard inputs to imgui). (e.g. InputText active, or an imgui window is focused and navigation is enabled, etc.).
    bool        WantTextInput;                  // Mobile/console: when io.WantTextInput is true, you may display an on-screen keyboard. This is set by ImGui when it wants textual keyboard input to happen (e.g. when a InputText widget is active).
    bool        WantSetMousePos;                // MousePos has been altered, back-end should reposition mouse on next frame. Set only when ImGuiConfigFlags_NavEnableSetMousePos flag is enabled.
    bool        WantSaveIniSettings;            // When manual .ini load/save is active (io.IniFilename == NULL), this will be set to notify your application that you can call SaveIniSettingsToMemory() and save yourself. IMPORTANT: You need to clear io.WantSaveIniSettings yourself.
    bool        NavActive;                      // Directional navigation is currently allowed (will handle ImGuiKey_NavXXX events) = a window is focused and it doesn't use the ImGuiWindowFlags_NoNavInputs flag.
    bool        NavVisible;                     // Directional navigation is visible and allowed (will handle ImGuiKey_NavXXX events).
    float       Framerate;                      // Application framerate estimation, in frame per second. Solely for convenience. Rolling average estimation based on IO.DeltaTime over 120 frames
    int         MetricsRenderVertices;          // Vertices output during last call to Render()
    int         MetricsRenderIndices;           // Indices output during last call to Render() = number of triangles * 3
    int         MetricsRenderWindows;           // Number of visible windows
    int         MetricsActiveWindows;           // Number of active windows
    int         MetricsActiveAllocations;       // Number of active allocations, updated by MemAlloc/MemFree based on current context. May be off if you have multiple imgui contexts.
    ImVec2      MouseDelta;                     // Mouse delta. Note that this is zero if either current or previous position are invalid (-FLT_MAX,-FLT_MAX), so a disappearing/reappearing mouse won't have a huge delta.

    //------------------------------------------------------------------
    // [Internal] ImGui will maintain those fields. Forward compatibility not guaranteed!
    //------------------------------------------------------------------

    ImVec2      MousePosPrev;                   // Previous mouse position (note that MouseDelta is not necessary == MousePos-MousePosPrev, in case either position is invalid)
    ImVec2      MouseClickedPos[5];             // Position at time of clicking
    double      MouseClickedTime[5];            // Time of last click (used to figure out double-click)
    bool        MouseClicked[5];                // Mouse button went from !Down to Down
    bool        MouseDoubleClicked[5];          // Has mouse button been double-clicked?
    bool        MouseReleased[5];               // Mouse button went from Down to !Down
    bool        MouseDownOwned[5];              // Track if button was clicked inside an imgui window. We don't request mouse capture from the application if click started outside ImGui bounds.
    bool        MouseDownWasDoubleClick[5];     // Track if button down was a double-click
    float       MouseDownDuration[5];           // Duration the mouse button has been down (0.0f == just clicked)
    float       MouseDownDurationPrev[5];       // Previous time the mouse button has been down
    ImVec2      MouseDragMaxDistanceAbs[5];     // Maximum distance, absolute, on each axis, of how much mouse has traveled from the clicking point
    float       MouseDragMaxDistanceSqr[5];     // Squared maximum distance of how much mouse has traveled from the clicking point
    float       KeysDownDuration[512];          // Duration the keyboard key has been down (0.0f == just pressed)
    float       KeysDownDurationPrev[512];      // Previous duration the key has been down
    float       NavInputsDownDuration[ImGuiNavInput_COUNT];
    float       NavInputsDownDurationPrev[ImGuiNavInput_COUNT];
    ImVector<ImWchar> InputQueueCharacters;     // Queue of _characters_ input (obtained by platform back-end). Fill using AddInputCharacter() helper.

    IMGUI_API   ImGuiIO();
};

//-----------------------------------------------------------------------------
// Misc data structures
//-----------------------------------------------------------------------------

// Shared state of InputText(), passed as an argument to your callback when a ImGuiInputTextFlags_Callback* flag is used.
// The callback function should return 0 by default.
// Callbacks (follow a flag name and see comments in ImGuiInputTextFlags_ declarations for more details)
// - ImGuiInputTextFlags_CallbackCompletion:  Callback on pressing TAB
// - ImGuiInputTextFlags_CallbackHistory:     Callback on pressing Up/Down arrows
// - ImGuiInputTextFlags_CallbackAlways:      Callback on each iteration
// - ImGuiInputTextFlags_CallbackCharFilter:  Callback on character inputs to replace or discard them. Modify 'EventChar' to replace or discard, or return 1 in callback to discard.
// - ImGuiInputTextFlags_CallbackResize:      Callback on buffer capacity changes request (beyond 'buf_size' parameter value), allowing the string to grow.
struct ImGuiInputTextCallbackData
{
    ImGuiInputTextFlags EventFlag;      // One ImGuiInputTextFlags_Callback*    // Read-only
    ImGuiInputTextFlags Flags;          // What user passed to InputText()      // Read-only
    void*               UserData;       // What user passed to InputText()      // Read-only

    // Arguments for the different callback events
    // - To modify the text buffer in a callback, prefer using the InsertChars() / DeleteChars() function. InsertChars() will take care of calling the resize callback if necessary.
    // - If you know your edits are not going to resize the underlying buffer allocation, you may modify the contents of 'Buf[]' directly. You need to update 'BufTextLen' accordingly (0 <= BufTextLen < BufSize) and set 'BufDirty'' to true so InputText can update its internal state.
    ImWchar             EventChar;      // Character input                      // Read-write   // [CharFilter] Replace character with another one, or set to zero to drop. return 1 is equivalent to setting EventChar=0;
    ImGuiKey            EventKey;       // Key pressed (Up/Down/TAB)            // Read-only    // [Completion,History]
    char*               Buf;            // Text buffer                          // Read-write   // [Resize] Can replace pointer / [Completion,History,Always] Only write to pointed data, don't replace the actual pointer!
    int                 BufTextLen;     // Text length (in bytes)               // Read-write   // [Resize,Completion,History,Always] Exclude zero-terminator storage. In C land: == strlen(some_text), in C++ land: string.length()
    int                 BufSize;        // Buffer size (in bytes) = capacity+1  // Read-only    // [Resize,Completion,History,Always] Include zero-terminator storage. In C land == ARRAYSIZE(my_char_array), in C++ land: string.capacity()+1
    bool                BufDirty;       // Set if you modify Buf/BufTextLen!    // Write        // [Completion,History,Always]
    int                 CursorPos;      //                                      // Read-write   // [Completion,History,Always]
    int                 SelectionStart; //                                      // Read-write   // [Completion,History,Always] == to SelectionEnd when no selection)
    int                 SelectionEnd;   //                                      // Read-write   // [Completion,History,Always]

    // Helper functions for text manipulation.
    // Use those function to benefit from the CallbackResize behaviors. Calling those function reset the selection.
    IMGUI_API ImGuiInputTextCallbackData();
    IMGUI_API void      DeleteChars(int pos, int bytes_count);
    IMGUI_API void      InsertChars(int pos, const char* text, const char* text_end = NULL);
    bool                HasSelection() const { return SelectionStart != SelectionEnd; }
};

// Resizing callback data to apply custom constraint. As enabled by SetNextWindowSizeConstraints(). Callback is called during the next Begin().
// NB: For basic min/max size constraint on each axis you don't need to use the callback! The SetNextWindowSizeConstraints() parameters are enough.
struct ImGuiSizeCallbackData
{
    void*   UserData;       // Read-only.   What user passed to SetNextWindowSizeConstraints()
    ImVec2  Pos;            // Read-only.   Window position, for reference.
    ImVec2  CurrentSize;    // Read-only.   Current window size.
    ImVec2  DesiredSize;    // Read-write.  Desired size, based on user's mouse position. Write to this field to restrain resizing.
};

// Data payload for Drag and Drop operations: AcceptDragDropPayload(), GetDragDropPayload()
struct ImGuiPayload
{
    // Members
    void*           Data;               // Data (copied and owned by dear imgui)
    int             DataSize;           // Data size

    // [Internal]
    ImGuiID         SourceId;           // Source item id
    ImGuiID         SourceParentId;     // Source parent id (if available)
    int             DataFrameCount;     // Data timestamp
    char            DataType[32+1];     // Data type tag (short user-supplied string, 32 characters max)
    bool            Preview;            // Set when AcceptDragDropPayload() was called and mouse has been hovering the target item (nb: handle overlapping drag targets)
    bool            Delivery;           // Set when AcceptDragDropPayload() was called and mouse button is released over the target item.

    ImGuiPayload()  { Clear(); }
    void Clear()    { SourceId = SourceParentId = 0; Data = NULL; DataSize = 0; memset(DataType, 0, sizeof(DataType)); DataFrameCount = -1; Preview = Delivery = false; }
    bool IsDataType(const char* type) const { return DataFrameCount != -1 && strcmp(type, DataType) == 0; }
    bool IsPreview() const                  { return Preview; }
    bool IsDelivery() const                 { return Delivery; }
};

//-----------------------------------------------------------------------------
// Obsolete functions (Will be removed! Read 'API BREAKING CHANGES' section in imgui.cpp for details)
// Please keep your copy of dear imgui up to date! Occasionally set '#define IMGUI_DISABLE_OBSOLETE_FUNCTIONS' in imconfig.h to stay ahead.
//-----------------------------------------------------------------------------

#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
namespace ImGui
{
    // OBSOLETED in 1.70 (from May 2019)
    static inline float GetContentRegionAvailWidth()          { return GetContentRegionAvail().x; }
    // OBSOLETED in 1.69 (from Mar 2019)
    static inline ImDrawList* GetOverlayDrawList()            { return GetForegroundDrawList(); }
    // OBSOLETED in 1.66 (from Sep 2018)
    static inline void  SetScrollHere(float center_ratio=0.5f){ SetScrollHereY(center_ratio); }
    // OBSOLETED in 1.63 (between Aug 2018 and Sept 2018)
    static inline bool  IsItemDeactivatedAfterChange()        { return IsItemDeactivatedAfterEdit(); }
    // OBSOLETED in 1.61 (between Apr 2018 and Aug 2018)
    IMGUI_API bool      InputFloat(const char* label, float* v, float step, float step_fast, int decimal_precision, ImGuiInputTextFlags flags = 0); // Use the 'const char* format' version instead of 'decimal_precision'!
    IMGUI_API bool      InputFloat2(const char* label, float v[2], int decimal_precision, ImGuiInputTextFlags flags = 0);
    IMGUI_API bool      InputFloat3(const char* label, float v[3], int decimal_precision, ImGuiInputTextFlags flags = 0);
    IMGUI_API bool      InputFloat4(const char* label, float v[4], int decimal_precision, ImGuiInputTextFlags flags = 0);
    // OBSOLETED in 1.60 (between Dec 2017 and Apr 2018)
    static inline bool  IsAnyWindowFocused()                  { return IsWindowFocused(ImGuiFocusedFlags_AnyWindow); }
    static inline bool  IsAnyWindowHovered()                  { return IsWindowHovered(ImGuiHoveredFlags_AnyWindow); }
    static inline ImVec2 CalcItemRectClosestPoint(const ImVec2& pos, bool on_edge = false, float outward = 0.f) { IM_UNUSED(on_edge); IM_UNUSED(outward); IM_ASSERT(0); return pos; }
    // OBSOLETED in 1.53 (between Oct 2017 and Dec 2017)
    static inline void  ShowTestWindow()                      { return ShowDemoWindow(); }
    static inline bool  IsRootWindowFocused()                 { return IsWindowFocused(ImGuiFocusedFlags_RootWindow); }
    static inline bool  IsRootWindowOrAnyChildFocused()       { return IsWindowFocused(ImGuiFocusedFlags_RootAndChildWindows); }
    static inline void  SetNextWindowContentWidth(float w)    { SetNextWindowContentSize(ImVec2(w, 0.0f)); }
    static inline float GetItemsLineHeightWithSpacing()       { return GetFrameHeightWithSpacing(); }
    // OBSOLETED in 1.52 (between Aug 2017 and Oct 2017)
    IMGUI_API bool      Begin(const char* name, bool* p_open, const ImVec2& size_on_first_use, float bg_alpha_override = -1.0f, ImGuiWindowFlags flags = 0); // Use SetNextWindowSize(size, ImGuiCond_FirstUseEver) + SetNextWindowBgAlpha() instead.
    static inline bool  IsRootWindowOrAnyChildHovered()       { return IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows); }
    static inline void  AlignFirstTextHeightToWidgets()       { AlignTextToFramePadding(); }
    static inline void  SetNextWindowPosCenter(ImGuiCond c=0) { ImGuiIO& io = GetIO(); SetNextWindowPos(ImVec2(io.DisplaySize.x * 0.5f, io.DisplaySize.y * 0.5f), c, ImVec2(0.5f, 0.5f)); }
    // OBSOLETED in 1.51 (between Jun 2017 and Aug 2017)
    static inline bool  IsItemHoveredRect()                   { return IsItemHovered(ImGuiHoveredFlags_RectOnly); }
    static inline bool  IsPosHoveringAnyWindow(const ImVec2&) { IM_ASSERT(0); return false; } // This was misleading and partly broken. You probably want to use the ImGui::GetIO().WantCaptureMouse flag instead.
    static inline bool  IsMouseHoveringAnyWindow()            { return IsWindowHovered(ImGuiHoveredFlags_AnyWindow); }
    static inline bool  IsMouseHoveringWindow()               { return IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem); }
}
typedef ImGuiInputTextCallback      ImGuiTextEditCallback;    // OBSOLETE in 1.63 (from Aug 2018): made the names consistent
typedef ImGuiInputTextCallbackData  ImGuiTextEditCallbackData;
#endif

//-----------------------------------------------------------------------------
// Helpers
//-----------------------------------------------------------------------------

// Helper: Execute a block of code at maximum once a frame. Convenient if you want to quickly create an UI within deep-nested code that runs multiple times every frame.
// Usage: static ImGuiOnceUponAFrame oaf; if (oaf) ImGui::Text("This will be called only once per frame");
struct ImGuiOnceUponAFrame
{
    ImGuiOnceUponAFrame() { RefFrame = -1; }
    mutable int RefFrame;
    operator bool() const { int current_frame = ImGui::GetFrameCount(); if (RefFrame == current_frame) return false; RefFrame = current_frame; return true; }
};

// Helper: Macro for ImGuiOnceUponAFrame. Attention: The macro expands into 2 statement so make sure you don't use it within e.g. an if() statement without curly braces.
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
#define IMGUI_ONCE_UPON_A_FRAME     static ImGuiOnceUponAFrame imgui_oaf; if (imgui_oaf)    // OBSOLETED in 1.51, will remove!
#endif

// Helper: Parse and apply text filters. In format "aaaaa[,bbbb][,ccccc]"
struct ImGuiTextFilter
{
    IMGUI_API           ImGuiTextFilter(const char* default_filter = "");
    IMGUI_API bool      Draw(const char* label = "Filter (inc,-exc)", float width = 0.0f);  // Helper calling InputText+Build
    IMGUI_API bool      PassFilter(const char* text, const char* text_end = NULL) const;
    IMGUI_API void      Build();
    void                Clear()          { InputBuf[0] = 0; Build(); }
    bool                IsActive() const { return !Filters.empty(); }

    // [Internal]
    struct TextRange
    {
        const char* b;
        const char* e;

        TextRange() { b = e = NULL; }
        TextRange(const char* _b, const char* _e) { b = _b; e = _e; }
        const char*     begin() const   { return b; }
        const char*     end () const    { return e; }
        bool            empty() const   { return b == e; }
        IMGUI_API void  split(char separator, ImVector<TextRange>* out) const;
    };
    char                InputBuf[256];
    ImVector<TextRange> Filters;
    int                 CountGrep;
};

// Helper: Growable text buffer for logging/accumulating text
// (this could be called 'ImGuiTextBuilder' / 'ImGuiStringBuilder')
struct ImGuiTextBuffer
{
    ImVector<char>      Buf;
    static char         EmptyString[1];

    ImGuiTextBuffer()   { }
    inline char         operator[](int i)       { IM_ASSERT(Buf.Data != NULL); return Buf.Data[i]; }
    const char*         begin() const           { return Buf.Data ? &Buf.front() : EmptyString; }
    const char*         end() const             { return Buf.Data ? &Buf.back() : EmptyString; }   // Buf is zero-terminated, so end() will point on the zero-terminator
    int                 size() const            { return Buf.Size ? Buf.Size - 1 : 0; }
    bool                empty()                 { return Buf.Size <= 1; }
    void                clear()                 { Buf.clear(); }
    void                reserve(int capacity)   { Buf.reserve(capacity); }
    const char*         c_str() const           { return Buf.Data ? Buf.Data : EmptyString; }
    IMGUI_API void      append(const char* str, const char* str_end = NULL);
    IMGUI_API void      appendf(const char* fmt, ...) IM_FMTARGS(2);
    IMGUI_API void      appendfv(const char* fmt, va_list args) IM_FMTLIST(2);
};

// Helper: Key->Value storage
// Typically you don't have to worry about this since a storage is held within each Window.
// We use it to e.g. store collapse state for a tree (Int 0/1)
// This is optimized for efficient lookup (dichotomy into a contiguous buffer) and rare insertion (typically tied to user interactions aka max once a frame)
// You can use it as custom user storage for temporary values. Declare your own storage if, for example:
// - You want to manipulate the open/close state of a particular sub-tree in your interface (tree node uses Int 0/1 to store their state).
// - You want to store custom debug data easily without adding or editing structures in your code (probably not efficient, but convenient)
// Types are NOT stored, so it is up to you to make sure your Key don't collide with different types.
struct ImGuiStorage
{
    struct Pair
    {
        ImGuiID key;
        union { int val_i; float val_f; void* val_p; };
        Pair(ImGuiID _key, int _val_i)   { key = _key; val_i = _val_i; }
        Pair(ImGuiID _key, float _val_f) { key = _key; val_f = _val_f; }
        Pair(ImGuiID _key, void* _val_p) { key = _key; val_p = _val_p; }
    };
    ImVector<Pair>      Data;

    // - Get***() functions find pair, never add/allocate. Pairs are sorted so a query is O(log N)
    // - Set***() functions find pair, insertion on demand if missing.
    // - Sorted insertion is costly, paid once. A typical frame shouldn't need to insert any new pair.
    void                Clear() { Data.clear(); }
    IMGUI_API int       GetInt(ImGuiID key, int default_val = 0) const;
    IMGUI_API void      SetInt(ImGuiID key, int val);
    IMGUI_API bool      GetBool(ImGuiID key, bool default_val = false) const;
    IMGUI_API void      SetBool(ImGuiID key, bool val);
    IMGUI_API float     GetFloat(ImGuiID key, float default_val = 0.0f) const;
    IMGUI_API void      SetFloat(ImGuiID key, float val);
    IMGUI_API void*     GetVoidPtr(ImGuiID key) const; // default_val is NULL
    IMGUI_API void      SetVoidPtr(ImGuiID key, void* val);

    // - Get***Ref() functions finds pair, insert on demand if missing, return pointer. Useful if you intend to do Get+Set.
    // - References are only valid until a new value is added to the storage. Calling a Set***() function or a Get***Ref() function invalidates the pointer.
    // - A typical use case where this is convenient for quick hacking (e.g. add storage during a live Edit&Continue session if you can't modify existing struct)
    //      float* pvar = ImGui::GetFloatRef(key); ImGui::SliderFloat("var", pvar, 0, 100.0f); some_var += *pvar;
    IMGUI_API int*      GetIntRef(ImGuiID key, int default_val = 0);
    IMGUI_API bool*     GetBoolRef(ImGuiID key, bool default_val = false);
    IMGUI_API float*    GetFloatRef(ImGuiID key, float default_val = 0.0f);
    IMGUI_API void**    GetVoidPtrRef(ImGuiID key, void* default_val = NULL);

    // Use on your own storage if you know only integer are being stored (open/close all tree nodes)
    IMGUI_API void      SetAllInt(int val);

    // For quicker full rebuild of a storage (instead of an incremental one), you may add all your contents and then sort once.
    IMGUI_API void      BuildSortByKey();
};

// Helper: Manually clip large list of items.
// If you are submitting lots of evenly spaced items and you have a random access to the list, you can perform coarse clipping based on visibility to save yourself from processing those items at all.
// The clipper calculates the range of visible items and advance the cursor to compensate for the non-visible items we have skipped.
// ImGui already clip items based on their bounds but it needs to measure text size to do so. Coarse clipping before submission makes this cost and your own data fetching/submission cost null.
// Usage:
//     ImGuiListClipper clipper(1000);  // we have 1000 elements, evenly spaced.
//     while (clipper.Step())
//         for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)
//             ImGui::Text("line number %d", i);
// - Step 0: the clipper let you process the first element, regardless of it being visible or not, so we can measure the element height (step skipped if we passed a known height as second arg to constructor).
// - Step 1: the clipper infer height from first element, calculate the actual range of elements to display, and position the cursor before the first element.
// - (Step 2: dummy step only required if an explicit items_height was passed to constructor or Begin() and user call Step(). Does nothing and switch to Step 3.)
// - Step 3: the clipper validate that we have reached the expected Y position (corresponding to element DisplayEnd), advance the cursor to the end of the list and then returns 'false' to end the loop.
struct ImGuiListClipper
{
    float   StartPosY;
    float   ItemsHeight;
    int     ItemsCount, StepNo, DisplayStart, DisplayEnd;

    // items_count:  Use -1 to ignore (you can call Begin later). Use INT_MAX if you don't know how many items you have (in which case the cursor won't be advanced in the final step).
    // items_height: Use -1.0f to be calculated automatically on first step. Otherwise pass in the distance between your items, typically GetTextLineHeightWithSpacing() or GetFrameHeightWithSpacing().
    // If you don't specify an items_height, you NEED to call Step(). If you specify items_height you may call the old Begin()/End() api directly, but prefer calling Step().
    ImGuiListClipper(int items_count = -1, float items_height = -1.0f)  { Begin(items_count, items_height); } // NB: Begin() initialize every fields (as we allow user to call Begin/End multiple times on a same instance if they want).
    ~ImGuiListClipper()                                                 { IM_ASSERT(ItemsCount == -1); }      // Assert if user forgot to call End() or Step() until false.

    IMGUI_API bool Step();                                              // Call until it returns false. The DisplayStart/DisplayEnd fields will be set and you can process/draw those items.
    IMGUI_API void Begin(int items_count, float items_height = -1.0f);  // Automatically called by constructor if you passed 'items_count' or by Step() in Step 1.
    IMGUI_API void End();                                               // Automatically called on the last call of Step() that returns false.
};

// Helpers macros to generate 32-bits encoded colors
#ifdef IMGUI_USE_BGRA_PACKED_COLOR
#define IM_COL32_R_SHIFT    16
#define IM_COL32_G_SHIFT    8
#define IM_COL32_B_SHIFT    0
#define IM_COL32_A_SHIFT    24
#define IM_COL32_A_MASK     0xFF000000
#else
#define IM_COL32_R_SHIFT    0
#define IM_COL32_G_SHIFT    8
#define IM_COL32_B_SHIFT    16
#define IM_COL32_A_SHIFT    24
#define IM_COL32_A_MASK     0xFF000000
#endif
#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
#define IM_COL32_WHITE       IM_COL32(255,255,255,255)  // Opaque white = 0xFFFFFFFF
#define IM_COL32_BLACK       IM_COL32(0,0,0,255)        // Opaque black
#define IM_COL32_BLACK_TRANS IM_COL32(0,0,0,0)          // Transparent black = 0x00000000

// Helper: ImColor() implicitly converts colors to either ImU32 (packed 4x1 byte) or ImVec4 (4x1 float)
// Prefer using IM_COL32() macros if you want a guaranteed compile-time ImU32 for usage with ImDrawList API.
// **Avoid storing ImColor! Store either u32 of ImVec4. This is not a full-featured color class. MAY OBSOLETE.
// **None of the ImGui API are using ImColor directly but you can use it as a convenience to pass colors in either ImU32 or ImVec4 formats. Explicitly cast to ImU32 or ImVec4 if needed.
struct ImColor
{
    ImVec4              Value;

    ImColor()                                                       { Value.x = Value.y = Value.z = Value.w = 0.0f; }
    ImColor(int r, int g, int b, int a = 255)                       { float sc = 1.0f/255.0f; Value.x = (float)r * sc; Value.y = (float)g * sc; Value.z = (float)b * sc; Value.w = (float)a * sc; }
    ImColor(ImU32 rgba)                                             { float sc = 1.0f/255.0f; Value.x = (float)((rgba>>IM_COL32_R_SHIFT)&0xFF) * sc; Value.y = (float)((rgba>>IM_COL32_G_SHIFT)&0xFF) * sc; Value.z = (float)((rgba>>IM_COL32_B_SHIFT)&0xFF) * sc; Value.w = (float)((rgba>>IM_COL32_A_SHIFT)&0xFF) * sc; }
    ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }
    ImColor(const ImVec4& col)                                      { Value = col; }
    inline operator ImU32() const                                   { return ImGui::ColorConvertFloat4ToU32(Value); }
    inline operator ImVec4() const                                  { return Value; }

    // FIXME-OBSOLETE: May need to obsolete/cleanup those helpers.
    inline void    SetHSV(float h, float s, float v, float a = 1.0f){ ImGui::ColorConvertHSVtoRGB(h, s, v, Value.x, Value.y, Value.z); Value.w = a; }
    static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }
};

//-----------------------------------------------------------------------------
// Draw List API (ImDrawCmd, ImDrawIdx, ImDrawVert, ImDrawChannel, ImDrawListFlags, ImDrawList, ImDrawData)
// Hold a series of drawing commands. The user provides a renderer for ImDrawData which essentially contains an array of ImDrawList.
//-----------------------------------------------------------------------------

// Draw callbacks for advanced uses.
// NB: You most likely do NOT need to use draw callbacks just to create your own widget or customized UI rendering,
// you can poke into the draw list for that! Draw callback may be useful for example to: 
//  A) Change your GPU render state,
//  B) render a complex 3D scene inside a UI element without an intermediate texture/render target, etc.
// The expected behavior from your rendering function is 'if (cmd.UserCallback != NULL) { cmd.UserCallback(parent_list, cmd); } else { RenderTriangles() }'
typedef void (*ImDrawCallback)(const ImDrawList* parent_list, const ImDrawCmd* cmd);

// Special Draw Callback value to request renderer back-end to reset the graphics/render state.
// The renderer back-end needs to handle this special value, otherwise it will crash trying to call a function at this address.
// This is useful for example if you submitted callbacks which you know have altered the render state and you want it to be restored.
// It is not done by default because they are many perfectly useful way of altering render state for imgui contents (e.g. changing shader/blending settings before an Image call).
#define ImDrawCallback_ResetRenderState     (ImDrawCallback)(-1)

// Typically, 1 command = 1 GPU draw call (unless command is a callback)
struct ImDrawCmd
{
    unsigned int    ElemCount;              // Number of indices (multiple of 3) to be rendered as triangles. Vertices are stored in the callee ImDrawList's vtx_buffer[] array, indices in idx_buffer[].
    ImVec4          ClipRect;               // Clipping rectangle (x1, y1, x2, y2). Subtract ImDrawData->DisplayPos to get clipping rectangle in "viewport" coordinates
    ImTextureID     TextureId;              // User-provided texture ID. Set by user in ImfontAtlas::SetTexID() for fonts or passed to Image*() functions. Ignore if never using images or multiple fonts atlas.
    ImDrawCallback  UserCallback;           // If != NULL, call the function instead of rendering the vertices. clip_rect and texture_id will be set normally.
    void*           UserCallbackData;       // The draw callback code can access this.

    ImDrawCmd() { ElemCount = 0; ClipRect.x = ClipRect.y = ClipRect.z = ClipRect.w = 0.0f; TextureId = (ImTextureID)NULL; UserCallback = NULL; UserCallbackData = NULL; }
};

// Vertex index (override with '#define ImDrawIdx unsigned int' in imconfig.h)
#ifndef ImDrawIdx
typedef unsigned short ImDrawIdx;
#endif

// Vertex layout
#ifndef IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT
struct ImDrawVert
{
    ImVec2  pos;
    ImVec2  uv;
    ImU32   col;
};
#else
// You can override the vertex format layout by defining IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT in imconfig.h
// The code expect ImVec2 pos (8 bytes), ImVec2 uv (8 bytes), ImU32 col (4 bytes), but you can re-order them or add other fields as needed to simplify integration in your engine.
// The type has to be described within the macro (you can either declare the struct or use a typedef)
// NOTE: IMGUI DOESN'T CLEAR THE STRUCTURE AND DOESN'T CALL A CONSTRUCTOR SO ANY CUSTOM FIELD WILL BE UNINITIALIZED. IF YOU ADD EXTRA FIELDS (SUCH AS A 'Z' COORDINATES) YOU WILL NEED TO CLEAR THEM DURING RENDER OR TO IGNORE THEM.
IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT;
#endif

// Draw channels are used by the Columns API to "split" the render list into different channels while building, so items of each column can be batched together.
// You can also use them to simulate drawing layers and submit primitives in a different order than how they will be rendered.
struct ImDrawChannel
{
    ImVector<ImDrawCmd>     CmdBuffer;
    ImVector<ImDrawIdx>     IdxBuffer;
};

enum ImDrawCornerFlags_
{
    ImDrawCornerFlags_TopLeft   = 1 << 0, // 0x1
    ImDrawCornerFlags_TopRight  = 1 << 1, // 0x2
    ImDrawCornerFlags_BotLeft   = 1 << 2, // 0x4
    ImDrawCornerFlags_BotRight  = 1 << 3, // 0x8
    ImDrawCornerFlags_Top       = ImDrawCornerFlags_TopLeft | ImDrawCornerFlags_TopRight,   // 0x3
    ImDrawCornerFlags_Bot       = ImDrawCornerFlags_BotLeft | ImDrawCornerFlags_BotRight,   // 0xC
    ImDrawCornerFlags_Left      = ImDrawCornerFlags_TopLeft | ImDrawCornerFlags_BotLeft,    // 0x5
    ImDrawCornerFlags_Right     = ImDrawCornerFlags_TopRight | ImDrawCornerFlags_BotRight,  // 0xA
    ImDrawCornerFlags_All       = 0xF     // In your function calls you may use ~0 (= all bits sets) instead of ImDrawCornerFlags_All, as a convenience
};

enum ImDrawListFlags_
{
    ImDrawListFlags_None             = 0,
    ImDrawListFlags_AntiAliasedLines = 1 << 0,  // Lines are anti-aliased (*2 the number of triangles for 1.0f wide line, otherwise *3 the number of triangles)
    ImDrawListFlags_AntiAliasedFill  = 1 << 1   // Filled shapes have anti-aliased edges (*2 the number of vertices)
};

// Draw command list
// This is the low-level list of polygons that ImGui functions are filling. At the end of the frame, all command lists are passed to your ImGuiIO::RenderDrawListFn function for rendering.
// Each ImGui window contains its own ImDrawList. You can use ImGui::GetWindowDrawList() to access the current window draw list and draw custom primitives.
// You can interleave normal ImGui:: calls and adding primitives to the current draw list.
// All positions are generally in pixel coordinates (top-left at (0,0), bottom-right at io.DisplaySize), but you are totally free to apply whatever transformation matrix to want to the data (if you apply such transformation you'll want to apply it to ClipRect as well)
// Important: Primitives are always added to the list and not culled (culling is done at higher-level by ImGui:: functions), if you use this API a lot consider coarse culling your drawn objects.
struct ImDrawList
{
    // This is what you have to render
    ImVector<ImDrawCmd>     CmdBuffer;          // Draw commands. Typically 1 command = 1 GPU draw call, unless the command is a callback.
    ImVector<ImDrawIdx>     IdxBuffer;          // Index buffer. Each command consume ImDrawCmd::ElemCount of those
    ImVector<ImDrawVert>    VtxBuffer;          // Vertex buffer.
    ImDrawListFlags         Flags;              // Flags, you may poke into these to adjust anti-aliasing settings per-primitive.

    // [Internal, used while building lists]
    const ImDrawListSharedData* _Data;          // Pointer to shared draw data (you can use ImGui::GetDrawListSharedData() to get the one from current ImGui context)
    const char*             _OwnerName;         // Pointer to owner window's name for debugging
    unsigned int            _VtxCurrentIdx;     // [Internal] == VtxBuffer.Size
    ImDrawVert*             _VtxWritePtr;       // [Internal] point within VtxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)
    ImDrawIdx*              _IdxWritePtr;       // [Internal] point within IdxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)
    ImVector<ImVec4>        _ClipRectStack;     // [Internal]
    ImVector<ImTextureID>   _TextureIdStack;    // [Internal]
    ImVector<ImVec2>        _Path;              // [Internal] current path building
    int                     _ChannelsCurrent;   // [Internal] current channel number (0)
    int                     _ChannelsCount;     // [Internal] number of active channels (1+)
    ImVector<ImDrawChannel> _Channels;          // [Internal] draw channels for columns API (not resized down so _ChannelsCount may be smaller than _Channels.Size)

    // If you want to create ImDrawList instances, pass them ImGui::GetDrawListSharedData() or create and use your own ImDrawListSharedData (so you can use ImDrawList without ImGui)
    ImDrawList(const ImDrawListSharedData* shared_data) { _Data = shared_data; _OwnerName = NULL; Clear(); }
    ~ImDrawList() { ClearFreeMemory(); }
    IMGUI_API void  PushClipRect(ImVec2 clip_rect_min, ImVec2 clip_rect_max, bool intersect_with_current_clip_rect = false);  // Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)
    IMGUI_API void  PushClipRectFullScreen();
    IMGUI_API void  PopClipRect();
    IMGUI_API void  PushTextureID(ImTextureID texture_id);
    IMGUI_API void  PopTextureID();
    inline ImVec2   GetClipRectMin() const { const ImVec4& cr = _ClipRectStack.back(); return ImVec2(cr.x, cr.y); }
    inline ImVec2   GetClipRectMax() const { const ImVec4& cr = _ClipRectStack.back(); return ImVec2(cr.z, cr.w); }

    // Primitives
    IMGUI_API void  AddLine(const ImVec2& a, const ImVec2& b, ImU32 col, float thickness = 1.0f);
    IMGUI_API void  AddRect(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners_flags = ImDrawCornerFlags_All, float thickness = 1.0f);   // a: upper-left, b: lower-right (== upper-left + size), rounding_corners_flags: 4-bits corresponding to which corner to round
    IMGUI_API void  AddRectFilled(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners_flags = ImDrawCornerFlags_All);                     // a: upper-left, b: lower-right (== upper-left + size)
    IMGUI_API void  AddRectFilledMultiColor(const ImVec2& a, const ImVec2& b, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left);
    IMGUI_API void  AddQuad(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col, float thickness = 1.0f);
    IMGUI_API void  AddQuadFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col);
    IMGUI_API void  AddTriangle(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col, float thickness = 1.0f);
    IMGUI_API void  AddTriangleFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col);
    IMGUI_API void  AddCircle(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12, float thickness = 1.0f);
    IMGUI_API void  AddCircleFilled(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12);
    IMGUI_API void  AddText(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL);
    IMGUI_API void  AddText(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL, float wrap_width = 0.0f, const ImVec4* cpu_fine_clip_rect = NULL);
    IMGUI_API void  AddImage(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a = ImVec2(0,0), const ImVec2& uv_b = ImVec2(1,1), ImU32 col = IM_COL32_WHITE);
    IMGUI_API void  AddImageQuad(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a = ImVec2(0,0), const ImVec2& uv_b = ImVec2(1,0), const ImVec2& uv_c = ImVec2(1,1), const ImVec2& uv_d = ImVec2(0,1), ImU32 col = IM_COL32_WHITE);
    IMGUI_API void  AddImageRounded(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col, float rounding, int rounding_corners = ImDrawCornerFlags_All);
    IMGUI_API void  AddPolyline(const ImVec2* points, int num_points, ImU32 col, bool closed, float thickness);
    IMGUI_API void  AddConvexPolyFilled(const ImVec2* points, int num_points, ImU32 col); // Note: Anti-aliased filling requires points to be in clockwise order.
    IMGUI_API void  AddBezierCurve(const ImVec2& pos0, const ImVec2& cp0, const ImVec2& cp1, const ImVec2& pos1, ImU32 col, float thickness, int num_segments = 0);

    // Stateful path API, add points then finish with PathFillConvex() or PathStroke()
    inline    void  PathClear()                                                 { _Path.Size = 0; }
    inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }
    inline    void  PathLineToMergeDuplicate(const ImVec2& pos)                 { if (_Path.Size == 0 || memcmp(&_Path.Data[_Path.Size-1], &pos, 8) != 0) _Path.push_back(pos); }
    inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }  // Note: Anti-aliased filling requires points to be in clockwise order.
    inline    void  PathStroke(ImU32 col, bool closed, float thickness = 1.0f)  { AddPolyline(_Path.Data, _Path.Size, col, closed, thickness); _Path.Size = 0; }
    IMGUI_API void  PathArcTo(const ImVec2& centre, float radius, float a_min, float a_max, int num_segments = 10);
    IMGUI_API void  PathArcToFast(const ImVec2& centre, float radius, int a_min_of_12, int a_max_of_12);                                            // Use precomputed angles for a 12 steps circle
    IMGUI_API void  PathBezierCurveTo(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, int num_segments = 0);
    IMGUI_API void  PathRect(const ImVec2& rect_min, const ImVec2& rect_max, float rounding = 0.0f, int rounding_corners_flags = ImDrawCornerFlags_All);

    // Channels
    // - Use to simulate layers. By switching channels to can render out-of-order (e.g. submit foreground primitives before background primitives)
    // - Use to minimize draw calls (e.g. if going back-and-forth between multiple non-overlapping clipping rectangles, prefer to append into separate channels then merge at the end)
    IMGUI_API void  ChannelsSplit(int channels_count);
    IMGUI_API void  ChannelsMerge();
    IMGUI_API void  ChannelsSetCurrent(int channel_index);

    // Advanced
    IMGUI_API void  AddCallback(ImDrawCallback callback, void* callback_data);  // Your rendering function must check for 'UserCallback' in ImDrawCmd and call the function instead of rendering triangles.
    IMGUI_API void  AddDrawCmd();                                               // This is useful if you need to forcefully create a new draw call (to allow for dependent rendering / blending). Otherwise primitives are merged into the same draw-call as much as possible
    IMGUI_API ImDrawList* CloneOutput() const;                                  // Create a clone of the CmdBuffer/IdxBuffer/VtxBuffer.

    // Internal helpers
    // NB: all primitives needs to be reserved via PrimReserve() beforehand!
    IMGUI_API void  Clear();
    IMGUI_API void  ClearFreeMemory();
    IMGUI_API void  PrimReserve(int idx_count, int vtx_count);
    IMGUI_API void  PrimRect(const ImVec2& a, const ImVec2& b, ImU32 col);      // Axis aligned rectangle (composed of two triangles)
    IMGUI_API void  PrimRectUV(const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col);
    IMGUI_API void  PrimQuadUV(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col);
    inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col){ _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }
    inline    void  PrimWriteIdx(ImDrawIdx idx)                                 { *_IdxWritePtr = idx; _IdxWritePtr++; }
    inline    void  PrimVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col)     { PrimWriteIdx((ImDrawIdx)_VtxCurrentIdx); PrimWriteVtx(pos, uv, col); }
    IMGUI_API void  UpdateClipRect();
    IMGUI_API void  UpdateTextureID();
};

// All draw data to render an ImGui frame
// (NB: the style and the naming convention here is a little inconsistent, we currently preserve them for backward compatibility purpose,
// as this is one of the oldest structure exposed by the library! Basically, ImDrawList == CmdList)
struct ImDrawData
{
    bool            Valid;                  // Only valid after Render() is called and before the next NewFrame() is called.
    ImDrawList**    CmdLists;               // Array of ImDrawList* to render. The ImDrawList are owned by ImGuiContext and only pointed to from here.
    int             CmdListsCount;          // Number of ImDrawList* to render
    int             TotalIdxCount;          // For convenience, sum of all ImDrawList's IdxBuffer.Size
    int             TotalVtxCount;          // For convenience, sum of all ImDrawList's VtxBuffer.Size
    ImVec2          DisplayPos;             // Upper-left position of the viewport to render (== upper-left of the orthogonal projection matrix to use)
    ImVec2          DisplaySize;            // Size of the viewport to render (== io.DisplaySize for the main viewport) (DisplayPos + DisplaySize == lower-right of the orthogonal projection matrix to use)
    ImVec2          FramebufferScale;       // Amount of pixels for each unit of DisplaySize. Based on io.DisplayFramebufferScale. Generally (1,1) on normal display, (2,2) on OSX with Retina display.

    // Functions
    ImDrawData()    { Valid = false; Clear(); }
    ~ImDrawData()   { Clear(); }
    void Clear()    { Valid = false; CmdLists = NULL; CmdListsCount = TotalVtxCount = TotalIdxCount = 0; DisplayPos = DisplaySize = FramebufferScale = ImVec2(0.f, 0.f); } // The ImDrawList are owned by ImGuiContext!
    IMGUI_API void  DeIndexAllBuffers();                    // Helper to convert all buffers from indexed to non-indexed, in case you cannot render indexed. Note: this is slow and most likely a waste of resources. Always prefer indexed rendering!
    IMGUI_API void  ScaleClipRects(const ImVec2& fb_scale); // Helper to scale the ClipRect field of each ImDrawCmd. Use if your final output buffer is at a different scale than ImGui expects, or if there is a difference between your window resolution and framebuffer resolution.
};

//-----------------------------------------------------------------------------
// Font API (ImFontConfig, ImFontGlyph, ImFontAtlasFlags, ImFontAtlas, ImFontGlyphRangesBuilder, ImFont)
//-----------------------------------------------------------------------------

struct ImFontConfig
{
    void*           FontData;               //          // TTF/OTF data
    int             FontDataSize;           //          // TTF/OTF data size
    bool            FontDataOwnedByAtlas;   // true     // TTF/OTF data ownership taken by the container ImFontAtlas (will delete memory itself).
    int             FontNo;                 // 0        // Index of font within TTF/OTF file
    float           SizePixels;             //          // Size in pixels for rasterizer (more or less maps to the resulting font height).
    int             OversampleH;            // 3        // Rasterize at higher quality for sub-pixel positioning. Read https://github.com/nothings/stb/blob/master/tests/oversample/README.md for details.
    int             OversampleV;            // 1        // Rasterize at higher quality for sub-pixel positioning. We don't use sub-pixel positions on the Y axis.
    bool            PixelSnapH;             // false    // Align every glyph to pixel boundary. Useful e.g. if you are merging a non-pixel aligned font with the default font. If enabled, you can set OversampleH/V to 1.
    ImVec2          GlyphExtraSpacing;      // 0, 0     // Extra spacing (in pixels) between glyphs. Only X axis is supported for now.
    ImVec2          GlyphOffset;            // 0, 0     // Offset all glyphs from this font input.
    const ImWchar*  GlyphRanges;            // NULL     // Pointer to a user-provided list of Unicode range (2 value per range, values are inclusive, zero-terminated list). THE ARRAY DATA NEEDS TO PERSIST AS LONG AS THE FONT IS ALIVE.
    float           GlyphMinAdvanceX;       // 0        // Minimum AdvanceX for glyphs, set Min to align font icons, set both Min/Max to enforce mono-space font
    float           GlyphMaxAdvanceX;       // FLT_MAX  // Maximum AdvanceX for glyphs
    bool            MergeMode;              // false    // Merge into previous ImFont, so you can combine multiple inputs font into one ImFont (e.g. ASCII font + icons + Japanese glyphs). You may want to use GlyphOffset.y when merge font of different heights.
    unsigned int    RasterizerFlags;        // 0x00     // Settings for custom font rasterizer (e.g. ImGuiFreeType). Leave as zero if you aren't using one.
    float           RasterizerMultiply;     // 1.0f     // Brighten (>1.0f) or darken (<1.0f) font output. Brightening small fonts may be a good workaround to make them more readable.

    // [Internal]
    char            Name[40];               // Name (strictly to ease debugging)
    ImFont*         DstFont;

    IMGUI_API ImFontConfig();
};

struct ImFontGlyph
{
    ImWchar         Codepoint;          // 0x0000..0xFFFF
    float           AdvanceX;           // Distance to next character (= data from font + ImFontConfig::GlyphExtraSpacing.x baked in)
    float           X0, Y0, X1, Y1;     // Glyph corners
    float           U0, V0, U1, V1;     // Texture coordinates
};

// Helper to build glyph ranges from text/string data. Feed your application strings/characters to it then call BuildRanges().
// This is essentially a tightly packed of vector of 64k booleans = 8KB storage.
struct ImFontGlyphRangesBuilder
{
    ImVector<int> UsedChars;            // Store 1-bit per Unicode code point (0=unused, 1=used)

    ImFontGlyphRangesBuilder()          { UsedChars.resize(0x10000 / sizeof(int)); memset(UsedChars.Data, 0, 0x10000 / sizeof(int)); }
    bool            GetBit(int n) const { int off = (n >> 5); int mask = 1 << (n & 31); return (UsedChars[off] & mask) != 0; }  // Get bit n in the array
    void            SetBit(int n)       { int off = (n >> 5); int mask = 1 << (n & 31); UsedChars[off] |= mask; }               // Set bit n in the array
    void            AddChar(ImWchar c)  { SetBit(c); }                          // Add character
    IMGUI_API void  AddText(const char* text, const char* text_end = NULL);     // Add string (each character of the UTF-8 string are added)
    IMGUI_API void  AddRanges(const ImWchar* ranges);                           // Add ranges, e.g. builder.AddRanges(ImFontAtlas::GetGlyphRangesDefault()) to force add all of ASCII/Latin+Ext
    IMGUI_API void  BuildRanges(ImVector<ImWchar>* out_ranges);                 // Output new ranges
};

enum ImFontAtlasFlags_
{
    ImFontAtlasFlags_None               = 0,
    ImFontAtlasFlags_NoPowerOfTwoHeight = 1 << 0,   // Don't round the height to next power of two
    ImFontAtlasFlags_NoMouseCursors     = 1 << 1    // Don't build software mouse cursors into the atlas
};

// Load and rasterize multiple TTF/OTF fonts into a same texture. The font atlas will build a single texture holding:
//  - One or more fonts.
//  - Custom graphics data needed to render the shapes needed by Dear ImGui.
//  - Mouse cursor shapes for software cursor rendering (unless setting 'Flags |= ImFontAtlasFlags_NoMouseCursors' in the font atlas).
// It is the user-code responsibility to setup/build the atlas, then upload the pixel data into a texture accessible by your graphics api.
//  - Optionally, call any of the AddFont*** functions. If you don't call any, the default font embedded in the code will be loaded for you.
//  - Call GetTexDataAsAlpha8() or GetTexDataAsRGBA32() to build and retrieve pixels data.
//  - Upload the pixels data into a texture within your graphics system (see imgui_impl_xxxx.cpp examples)
//  - Call SetTexID(my_tex_id); and pass the pointer/identifier to your texture in a format natural to your graphics API.
//    This value will be passed back to you during rendering to identify the texture. Read FAQ entry about ImTextureID for more details.
// Common pitfalls:
// - If you pass a 'glyph_ranges' array to AddFont*** functions, you need to make sure that your array persist up until the
//   atlas is build (when calling GetTexData*** or Build()). We only copy the pointer, not the data.
// - Important: By default, AddFontFromMemoryTTF() takes ownership of the data. Even though we are not writing to it, we will free the pointer on destruction.
//   You can set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed,
// - Even though many functions are suffixed with "TTF", OTF data is supported just as well.
// - This is an old API and it is currently awkward for those and and various other reasons! We will address them in the future!
struct ImFontAtlas
{
    IMGUI_API ImFontAtlas();
    IMGUI_API ~ImFontAtlas();
    IMGUI_API ImFont*           AddFont(const ImFontConfig* font_cfg);
    IMGUI_API ImFont*           AddFontDefault(const ImFontConfig* font_cfg = NULL);
    IMGUI_API ImFont*           AddFontFromFileTTF(const char* filename, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);
    IMGUI_API ImFont*           AddFontFromMemoryTTF(void* font_data, int font_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL); // Note: Transfer ownership of 'ttf_data' to ImFontAtlas! Will be deleted after destruction of the atlas. Set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed.
    IMGUI_API ImFont*           AddFontFromMemoryCompressedTTF(const void* compressed_font_data, int compressed_font_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL); // 'compressed_font_data' still owned by caller. Compress with binary_to_compressed_c.cpp.
    IMGUI_API ImFont*           AddFontFromMemoryCompressedBase85TTF(const char* compressed_font_data_base85, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);              // 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.
    IMGUI_API void              ClearInputData();           // Clear input data (all ImFontConfig structures including sizes, TTF data, glyph ranges, etc.) = all the data used to build the texture and fonts.
    IMGUI_API void              ClearTexData();             // Clear output texture data (CPU side). Saves RAM once the texture has been copied to graphics memory.
    IMGUI_API void              ClearFonts();               // Clear output font data (glyphs storage, UV coordinates).
    IMGUI_API void              Clear();                    // Clear all input and output.

    // Build atlas, retrieve pixel data.
    // User is in charge of copying the pixels into graphics memory (e.g. create a texture with your engine). Then store your texture handle with SetTexID().
    // The pitch is always = Width * BytesPerPixels (1 or 4)
    // Building in RGBA32 format is provided for convenience and compatibility, but note that unless you manually manipulate or copy color data into
    // the texture (e.g. when using the AddCustomRect*** api), then the RGB pixels emitted will always be white (~75% of memory/bandwidth waste.
    IMGUI_API bool              Build();                    // Build pixels data. This is called automatically for you by the GetTexData*** functions.
    IMGUI_API void              GetTexDataAsAlpha8(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL);  // 1 byte per-pixel
    IMGUI_API void              GetTexDataAsRGBA32(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL);  // 4 bytes-per-pixel
    bool                        IsBuilt()                   { return Fonts.Size > 0 && (TexPixelsAlpha8 != NULL || TexPixelsRGBA32 != NULL); }
    void                        SetTexID(ImTextureID id)    { TexID = id; }

    //-------------------------------------------
    // Glyph Ranges
    //-------------------------------------------

    // Helpers to retrieve list of common Unicode ranges (2 value per range, values are inclusive, zero-terminated list)
    // NB: Make sure that your string are UTF-8 and NOT in your local code page. In C++11, you can create UTF-8 string literal using the u8"Hello world" syntax. See FAQ for details.
    // NB: Consider using ImFontGlyphRangesBuilder to build glyph ranges from textual data.
    IMGUI_API const ImWchar*    GetGlyphRangesDefault();                // Basic Latin, Extended Latin
    IMGUI_API const ImWchar*    GetGlyphRangesKorean();                 // Default + Korean characters
    IMGUI_API const ImWchar*    GetGlyphRangesJapanese();               // Default + Hiragana, Katakana, Half-Width, Selection of 1946 Ideographs
    IMGUI_API const ImWchar*    GetGlyphRangesChineseFull();            // Default + Half-Width + Japanese Hiragana/Katakana + full set of about 21000 CJK Unified Ideographs
    IMGUI_API const ImWchar*    GetGlyphRangesChineseSimplifiedCommon();// Default + Half-Width + Japanese Hiragana/Katakana + set of 2500 CJK Unified Ideographs for common simplified Chinese
    IMGUI_API const ImWchar*    GetGlyphRangesCyrillic();               // Default + about 400 Cyrillic characters
    IMGUI_API const ImWchar*    GetGlyphRangesThai();                   // Default + Thai characters
    IMGUI_API const ImWchar*    GetGlyphRangesVietnamese();             // Default + Vietname characters

    //-------------------------------------------
    // Custom Rectangles/Glyphs API
    //-------------------------------------------

    // You can request arbitrary rectangles to be packed into the atlas, for your own purposes. After calling Build(), you can query the rectangle position and render your pixels.
    // You can also request your rectangles to be mapped as font glyph (given a font + Unicode point), so you can render e.g. custom colorful icons and use them as regular glyphs.
    struct CustomRect
    {
        unsigned int    ID;             // Input    // User ID. Use <0x10000 to map into a font glyph, >=0x10000 for other/internal/custom texture data.
        unsigned short  Width, Height;  // Input    // Desired rectangle dimension
        unsigned short  X, Y;           // Output   // Packed position in Atlas
        float           GlyphAdvanceX;  // Input    // For custom font glyphs only (ID<0x10000): glyph xadvance
        ImVec2          GlyphOffset;    // Input    // For custom font glyphs only (ID<0x10000): glyph display offset
        ImFont*         Font;           // Input    // For custom font glyphs only (ID<0x10000): target font
        CustomRect()            { ID = 0xFFFFFFFF; Width = Height = 0; X = Y = 0xFFFF; GlyphAdvanceX = 0.0f; GlyphOffset = ImVec2(0,0); Font = NULL; }
        bool IsPacked() const   { return X != 0xFFFF; }
    };

    IMGUI_API int       AddCustomRectRegular(unsigned int id, int width, int height);                                                                   // Id needs to be >= 0x10000. Id >= 0x80000000 are reserved for ImGui and ImDrawList
    IMGUI_API int       AddCustomRectFontGlyph(ImFont* font, ImWchar id, int width, int height, float advance_x, const ImVec2& offset = ImVec2(0,0));   // Id needs to be < 0x10000 to register a rectangle to map into a specific font.
    const CustomRect*   GetCustomRectByIndex(int index) const { if (index < 0) return NULL; return &CustomRects[index]; }

    // [Internal]
    IMGUI_API void      CalcCustomRectUV(const CustomRect* rect, ImVec2* out_uv_min, ImVec2* out_uv_max);
    IMGUI_API bool      GetMouseCursorTexData(ImGuiMouseCursor cursor, ImVec2* out_offset, ImVec2* out_size, ImVec2 out_uv_border[2], ImVec2 out_uv_fill[2]);

    //-------------------------------------------
    // Members
    //-------------------------------------------

    bool                        Locked;             // Marked as Locked by ImGui::NewFrame() so attempt to modify the atlas will assert.
    ImFontAtlasFlags            Flags;              // Build flags (see ImFontAtlasFlags_)
    ImTextureID                 TexID;              // User data to refer to the texture once it has been uploaded to user's graphic systems. It is passed back to you during rendering via the ImDrawCmd structure.
    int                         TexDesiredWidth;    // Texture width desired by user before Build(). Must be a power-of-two. If have many glyphs your graphics API have texture size restrictions you may want to increase texture width to decrease height.
    int                         TexGlyphPadding;    // Padding between glyphs within texture in pixels. Defaults to 1. If your rendering method doesn't rely on bilinear filtering you may set this to 0.

    // [Internal]
    // NB: Access texture data via GetTexData*() calls! Which will setup a default font for you.
    unsigned char*              TexPixelsAlpha8;    // 1 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight
    unsigned int*               TexPixelsRGBA32;    // 4 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight * 4
    int                         TexWidth;           // Texture width calculated during Build().
    int                         TexHeight;          // Texture height calculated during Build().
    ImVec2                      TexUvScale;         // = (1.0f/TexWidth, 1.0f/TexHeight)
    ImVec2                      TexUvWhitePixel;    // Texture coordinates to a white pixel
    ImVector<ImFont*>           Fonts;              // Hold all the fonts returned by AddFont*. Fonts[0] is the default font upon calling ImGui::NewFrame(), use ImGui::PushFont()/PopFont() to change the current font.
    ImVector<CustomRect>        CustomRects;        // Rectangles for packing custom texture data into the atlas.
    ImVector<ImFontConfig>      ConfigData;         // Internal data
    int                         CustomRectIds[1];   // Identifiers of custom texture rectangle used by ImFontAtlas/ImDrawList

#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    typedef ImFontGlyphRangesBuilder GlyphRangesBuilder; // OBSOLETE 1.67+
#endif
};

// Font runtime data and rendering
// ImFontAtlas automatically loads a default embedded font for you when you call GetTexDataAsAlpha8() or GetTexDataAsRGBA32().
struct ImFont
{
    // Members: Hot ~20/24 bytes (for CalcTextSize)
    ImVector<float>             IndexAdvanceX;      // 12-16 // out //            // Sparse. Glyphs->AdvanceX in a directly indexable way (cache-friendly for CalcTextSize functions which only this this info, and are often bottleneck in large UI).
    float                       FallbackAdvanceX;   // 4     // out // = FallbackGlyph->AdvanceX
    float                       FontSize;           // 4     // in  //            // Height of characters/line, set during loading (don't change after loading)

    // Members: Hot ~36/48 bytes (for CalcTextSize + render loop)
    ImVector<ImWchar>           IndexLookup;        // 12-16 // out //            // Sparse. Index glyphs by Unicode code-point.
    ImVector<ImFontGlyph>       Glyphs;             // 12-16 // out //            // All glyphs.
    const ImFontGlyph*          FallbackGlyph;      // 4-8   // out // = FindGlyph(FontFallbackChar)
    ImVec2                      DisplayOffset;      // 8     // in  // = (0,0)    // Offset font rendering by xx pixels

    // Members: Cold ~32/40 bytes
    ImFontAtlas*                ContainerAtlas;     // 4-8   // out //            // What we has been loaded into
    const ImFontConfig*         ConfigData;         // 4-8   // in  //            // Pointer within ContainerAtlas->ConfigData
    short                       ConfigDataCount;    // 2     // in  // ~ 1        // Number of ImFontConfig involved in creating this font. Bigger than 1 when merging multiple font sources into one ImFont.
    ImWchar                     FallbackChar;       // 2     // in  // = '?'      // Replacement glyph if one isn't found. Only set via SetFallbackChar()
    float                       Scale;              // 4     // in  // = 1.f      // Base font scale, multiplied by the per-window font scale which you can adjust with SetWindowFontScale()
    float                       Ascent, Descent;    // 4+4   // out //            // Ascent: distance from top to bottom of e.g. 'A' [0..FontSize]
    int                         MetricsTotalSurface;// 4     // out //            // Total surface in pixels to get an idea of the font rasterization/texture cost (not exact, we approximate the cost of padding between glyphs)
    bool                        DirtyLookupTables;  // 1     // out //

    // Methods
    IMGUI_API ImFont();
    IMGUI_API ~ImFont();
    IMGUI_API const ImFontGlyph*FindGlyph(ImWchar c) const;
    IMGUI_API const ImFontGlyph*FindGlyphNoFallback(ImWchar c) const;
    float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexAdvanceX.Size) ? IndexAdvanceX[(int)c] : FallbackAdvanceX; }
    bool                        IsLoaded() const                    { return ContainerAtlas != NULL; }
    const char*                 GetDebugName() const                { return ConfigData ? ConfigData->Name : "<unknown>"; }

    // 'max_width' stops rendering after a certain width (could be turned into a 2d size). FLT_MAX to disable.
    // 'wrap_width' enable automatic word-wrapping across multiple lines to fit into given width. 0.0f to disable.
    IMGUI_API ImVec2            CalcTextSizeA(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end = NULL, const char** remaining = NULL) const; // utf8
    IMGUI_API const char*       CalcWordWrapPositionA(float scale, const char* text, const char* text_end, float wrap_width) const;
    IMGUI_API void              RenderChar(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, ImWchar c) const;
    IMGUI_API void              RenderText(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width = 0.0f, bool cpu_fine_clip = false) const;

    // [Internal] Don't use!
    IMGUI_API void              BuildLookupTable();
    IMGUI_API void              ClearOutputData();
    IMGUI_API void              GrowIndex(int new_size);
    IMGUI_API void              AddGlyph(ImWchar c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x);
    IMGUI_API void              AddRemapChar(ImWchar dst, ImWchar src, bool overwrite_dst = true); // Makes 'dst' character/glyph points to 'src' character/glyph. Currently needs to be called AFTER fonts have been built.
    IMGUI_API void              SetFallbackChar(ImWchar c);

#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    typedef ImFontGlyph Glyph; // OBSOLETE 1.52+
#endif
};

#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__) && __GNUC__ >= 8
#pragma GCC diagnostic pop
#endif

// Include imgui_user.h at the end of imgui.h (convenient for user to only explicitly include vanilla imgui.h)
#ifdef IMGUI_INCLUDE_IMGUI_USER_H
#include "imgui_user.h"
#endif

```

`UnrealFinderTool/ImGUI/imgui_demo.cpp`:

```cpp
// dear imgui, v1.70
// (demo code)

// Message to the person tempted to delete this file when integrating Dear ImGui into their code base:
// Do NOT remove this file from your project! Think again! It is the most useful reference code that you and other coders
// will want to refer to and call. Have the ImGui::ShowDemoWindow() function wired in an always-available debug menu of
// your game/app! Removing this file from your project is hindering access to documentation for everyone in your team,
// likely leading you to poorer usage of the library.
// Everything in this file will be stripped out by the linker if you don't call ImGui::ShowDemoWindow().
// If you want to link core Dear ImGui in your shipped builds but want an easy guarantee that the demo will not be linked,
// you can setup your imconfig.h with #define IMGUI_DISABLE_DEMO_WINDOWS and those functions will be empty.
// In other situation, whenever you have Dear ImGui available you probably want this to be available for reference.
// Thank you,
// -Your beloved friend, imgui_demo.cpp (that you won't delete)

// Message to beginner C/C++ programmers about the meaning of the 'static' keyword:
// In this demo code, we frequently we use 'static' variables inside functions. A static variable persist across calls, so it is
// essentially like a global variable but declared inside the scope of the function. We do this as a way to gather code and data
// in the same place, to make the demo source code faster to read, faster to write, and smaller in size.
// It also happens to be a convenient way of storing simple UI related information as long as your function doesn't need to be reentrant
// or used in threads. This might be a pattern you will want to use in your code, but most of the real data you would be editing is
// likely going to be stored outside your functions.

/*

Index of this file:

// [SECTION] Forward Declarations, Helpers
// [SECTION] Demo Window / ShowDemoWindow()
// [SECTION] About Window / ShowAboutWindow()
// [SECTION] Style Editor / ShowStyleEditor()
// [SECTION] Example App: Main Menu Bar / ShowExampleAppMainMenuBar()
// [SECTION] Example App: Debug Console / ShowExampleAppConsole()
// [SECTION] Example App: Debug Log / ShowExampleAppLog()
// [SECTION] Example App: Simple Layout / ShowExampleAppLayout()
// [SECTION] Example App: Property Editor / ShowExampleAppPropertyEditor()
// [SECTION] Example App: Long Text / ShowExampleAppLongText()
// [SECTION] Example App: Auto Resize / ShowExampleAppAutoResize()
// [SECTION] Example App: Constrained Resize / ShowExampleAppConstrainedResize()
// [SECTION] Example App: Simple Overlay / ShowExampleAppSimpleOverlay()
// [SECTION] Example App: Manipulating Window Titles / ShowExampleAppWindowTitles()
// [SECTION] Example App: Custom Rendering using ImDrawList API / ShowExampleAppCustomRendering()
// [SECTION] Example App: Documents Handling / ShowExampleAppDocuments()

*/

#include "pch.h"
#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS
#endif

#include "imgui.h"
#include <ctype.h>          // toupper
#include <limits.h>         // INT_MIN, INT_MAX
#include <math.h>           // sqrtf, powf, cosf, sinf, floorf, ceilf
#include <stdio.h>          // vsnprintf, sscanf, printf
#include <stdlib.h>         // NULL, malloc, free, atoi
#if defined(_MSC_VER) && _MSC_VER <= 1500 // MSVC 2008 or earlier
#include <stddef.h>         // intptr_t
#else
#include <stdint.h>         // intptr_t
#endif

#ifdef _MSC_VER
#pragma warning (disable: 4996) // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen
#endif
#ifdef __clang__
#pragma clang diagnostic ignored "-Wold-style-cast"             // warning : use of old-style cast                              // yes, they are more terse.
#pragma clang diagnostic ignored "-Wdeprecated-declarations"    // warning : 'xx' is deprecated: The POSIX name for this item.. // for strdup used in demo code (so user can copy & paste the code)
#pragma clang diagnostic ignored "-Wint-to-void-pointer-cast"   // warning : cast to 'void *' from smaller integer type 'int'
#pragma clang diagnostic ignored "-Wformat-security"            // warning : warning: format string is not a string literal
#pragma clang diagnostic ignored "-Wexit-time-destructors"      // warning : declaration requires an exit-time destructor       // exit-time destruction order is undefined. if MemFree() leads to users code that has been disabled before exit it might cause problems. ImGui coding style welcomes static/globals.
#pragma clang diagnostic ignored "-Wunused-macros"              // warning : warning: macro is not used                         // we define snprintf/vsnprintf on Windows so they are available, but not always used.
#if __has_warning("-Wzero-as-null-pointer-constant")
#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"  // warning : zero as null pointer constant                  // some standard header variations use #define NULL 0
#endif
#if __has_warning("-Wdouble-promotion")
#pragma clang diagnostic ignored "-Wdouble-promotion"           // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.
#endif
#if __has_warning("-Wreserved-id-macro")
#pragma clang diagnostic ignored "-Wreserved-id-macro"          // warning : macro name is a reserved identifier                //
#endif
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wint-to-pointer-cast"          // warning: cast to pointer from integer of different size
#pragma GCC diagnostic ignored "-Wformat-security"              // warning : format string is not a string literal (potentially insecure)
#pragma GCC diagnostic ignored "-Wdouble-promotion"             // warning: implicit conversion from 'float' to 'double' when passing argument to function
#pragma GCC diagnostic ignored "-Wconversion"                   // warning: conversion to 'xxxx' from 'xxxx' may alter its value
#if (__GNUC__ >= 6)
#pragma GCC diagnostic ignored "-Wmisleading-indentation"       // warning: this 'if' clause does not guard this statement      // GCC 6.0+ only. See #883 on GitHub.
#endif
#endif

// Play it nice with Windows users. Notepad in 2017 still doesn't display text data with Unix-style \n.
#ifdef _WIN32
#define IM_NEWLINE  "\r\n"
#define snprintf    _snprintf
#define vsnprintf   _vsnprintf
#else
#define IM_NEWLINE  "\n"
#endif

#define IM_MAX(_A,_B)       (((_A) >= (_B)) ? (_A) : (_B))

//-----------------------------------------------------------------------------
// [SECTION] Forward Declarations, Helpers
//-----------------------------------------------------------------------------

#if !defined(IMGUI_DISABLE_OBSOLETE_FUNCTIONS) && defined(IMGUI_DISABLE_TEST_WINDOWS) && !defined(IMGUI_DISABLE_DEMO_WINDOWS)   // Obsolete name since 1.53, TEST->DEMO
#define IMGUI_DISABLE_DEMO_WINDOWS
#endif

#if !defined(IMGUI_DISABLE_DEMO_WINDOWS)

// Forward Declarations
static void ShowExampleAppDocuments(bool* p_open);
static void ShowExampleAppMainMenuBar();
static void ShowExampleAppConsole(bool* p_open);
static void ShowExampleAppLog(bool* p_open);
static void ShowExampleAppLayout(bool* p_open);
static void ShowExampleAppPropertyEditor(bool* p_open);
static void ShowExampleAppLongText(bool* p_open);
static void ShowExampleAppAutoResize(bool* p_open);
static void ShowExampleAppConstrainedResize(bool* p_open);
static void ShowExampleAppSimpleOverlay(bool* p_open);
static void ShowExampleAppWindowTitles(bool* p_open);
static void ShowExampleAppCustomRendering(bool* p_open);
static void ShowExampleMenuFile();

// Helper to display a little (?) mark which shows a tooltip when hovered.
// In your own code you may want to display an actual icon if you are using a merged icon fonts (see misc/fonts/README.txt)
static void HelpMarker(const char* desc)
{
    ImGui::TextDisabled("(?)");
    if (ImGui::IsItemHovered())
    {
        ImGui::BeginTooltip();
        ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);
        ImGui::TextUnformatted(desc);
        ImGui::PopTextWrapPos();
        ImGui::EndTooltip();
    }
}

// Helper to display basic user controls.
void ImGui::ShowUserGuide()
{
    ImGuiIO& io = ImGui::GetIO();
    ImGui::BulletText("Double-click on title bar to collapse window.");
    ImGui::BulletText("Click and drag on lower right corner to resize window\n(double-click to auto fit window to its contents).");
    ImGui::BulletText("Click and drag on any empty space to move window.");
    ImGui::BulletText("TAB/SHIFT+TAB to cycle through keyboard editable fields.");
    ImGui::BulletText("CTRL+Click on a slider or drag box to input value as text.");
    if (io.FontAllowUserScaling)
        ImGui::BulletText("CTRL+Mouse Wheel to zoom window contents.");
    ImGui::BulletText("Mouse Wheel to scroll.");
    ImGui::BulletText("While editing text:\n");
    ImGui::Indent();
    ImGui::BulletText("Hold SHIFT or use mouse to select text.");
    ImGui::BulletText("CTRL+Left/Right to word jump.");
    ImGui::BulletText("CTRL+A or double-click to select all.");
    ImGui::BulletText("CTRL+X,CTRL+C,CTRL+V to use clipboard.");
    ImGui::BulletText("CTRL+Z,CTRL+Y to undo/redo.");
    ImGui::BulletText("ESCAPE to revert.");
    ImGui::BulletText("You can apply arithmetic operators +,*,/ on numerical values.\nUse +- to subtract.");
    ImGui::Unindent();
}

//-----------------------------------------------------------------------------
// [SECTION] Demo Window / ShowDemoWindow()
//-----------------------------------------------------------------------------

// We split the contents of the big ShowDemoWindow() function into smaller functions (because the link time of very large functions grow non-linearly)
static void ShowDemoWindowWidgets();
static void ShowDemoWindowLayout();
static void ShowDemoWindowPopups();
static void ShowDemoWindowColumns();
static void ShowDemoWindowMisc();

// Demonstrate most Dear ImGui features (this is big function!)
// You may execute this function to experiment with the UI and understand what it does. You may then search for keywords in the code when you are interested by a specific feature.
void ImGui::ShowDemoWindow(bool* p_open)
{
    IM_ASSERT(ImGui::GetCurrentContext() != NULL && "Missing dear imgui context. Refer to examples app!"); // Exceptionally add an extra assert here for people confused with initial dear imgui setup

    // Examples Apps (accessible from the "Examples" menu)
    static bool show_app_documents = false;
    static bool show_app_main_menu_bar = false;
    static bool show_app_console = false;
    static bool show_app_log = false;
    static bool show_app_layout = false;
    static bool show_app_property_editor = false;
    static bool show_app_long_text = false;
    static bool show_app_auto_resize = false;
    static bool show_app_constrained_resize = false;
    static bool show_app_simple_overlay = false;
    static bool show_app_window_titles = false;
    static bool show_app_custom_rendering = false;

    if (show_app_documents)           ShowExampleAppDocuments(&show_app_documents);
    if (show_app_main_menu_bar)       ShowExampleAppMainMenuBar();
    if (show_app_console)             ShowExampleAppConsole(&show_app_console);
    if (show_app_log)                 ShowExampleAppLog(&show_app_log);
    if (show_app_layout)              ShowExampleAppLayout(&show_app_layout);
    if (show_app_property_editor)     ShowExampleAppPropertyEditor(&show_app_property_editor);
    if (show_app_long_text)           ShowExampleAppLongText(&show_app_long_text);
    if (show_app_auto_resize)         ShowExampleAppAutoResize(&show_app_auto_resize);
    if (show_app_constrained_resize)  ShowExampleAppConstrainedResize(&show_app_constrained_resize);
    if (show_app_simple_overlay)      ShowExampleAppSimpleOverlay(&show_app_simple_overlay);
    if (show_app_window_titles)       ShowExampleAppWindowTitles(&show_app_window_titles);
    if (show_app_custom_rendering)    ShowExampleAppCustomRendering(&show_app_custom_rendering);

    // Dear ImGui Apps (accessible from the "Help" menu)
    static bool show_app_metrics = false;
    static bool show_app_style_editor = false;
    static bool show_app_about = false;

    if (show_app_metrics)             { ImGui::ShowMetricsWindow(&show_app_metrics); }
    if (show_app_style_editor)        { ImGui::Begin("Style Editor", &show_app_style_editor); ImGui::ShowStyleEditor(); ImGui::End(); }
    if (show_app_about)               { ImGui::ShowAboutWindow(&show_app_about); }

    // Demonstrate the various window flags. Typically you would just use the default!
    static bool no_titlebar = false;
    static bool no_scrollbar = false;
    static bool no_menu = false;
    static bool no_move = false;
    static bool no_resize = false;
    static bool no_collapse = false;
    static bool no_close = false;
    static bool no_nav = false;
    static bool no_background = false;
    static bool no_bring_to_front = false;

    ImGuiWindowFlags window_flags = 0;
    if (no_titlebar)        window_flags |= ImGuiWindowFlags_NoTitleBar;
    if (no_scrollbar)       window_flags |= ImGuiWindowFlags_NoScrollbar;
    if (!no_menu)           window_flags |= ImGuiWindowFlags_MenuBar;
    if (no_move)            window_flags |= ImGuiWindowFlags_NoMove;
    if (no_resize)          window_flags |= ImGuiWindowFlags_NoResize;
    if (no_collapse)        window_flags |= ImGuiWindowFlags_NoCollapse;
    if (no_nav)             window_flags |= ImGuiWindowFlags_NoNav;
    if (no_background)      window_flags |= ImGuiWindowFlags_NoBackground;
    if (no_bring_to_front)  window_flags |= ImGuiWindowFlags_NoBringToFrontOnFocus;
    if (no_close)           p_open = NULL; // Don't pass our bool* to Begin

    // We specify a default position/size in case there's no data in the .ini file. Typically this isn't required! We only do it to make the Demo applications a little more welcoming.
    ImGui::SetNextWindowPos(ImVec2(650, 20), ImGuiCond_FirstUseEver);
    ImGui::SetNextWindowSize(ImVec2(550, 680), ImGuiCond_FirstUseEver);

    // Main body of the Demo window starts here.
    if (!ImGui::Begin("ImGui Demo", p_open, window_flags))
    {
        // Early out if the window is collapsed, as an optimization.
        ImGui::End();
        return;
    }

    // Most "big" widgets share a common width settings by default.
    //ImGui::PushItemWidth(ImGui::GetWindowWidth() * 0.65f);    // Use 2/3 of the space for widgets and 1/3 for labels (default)
    ImGui::PushItemWidth(ImGui::GetFontSize() * -12);           // Use fixed width for labels (by passing a negative value), the rest goes to widgets. We choose a width proportional to our font size.

    // Menu Bar
    if (ImGui::BeginMenuBar())
    {
        if (ImGui::BeginMenu("Menu"))
        {
            ShowExampleMenuFile();
            ImGui::EndMenu();
        }
        if (ImGui::BeginMenu("Examples"))
        {
            ImGui::MenuItem("Main menu bar", NULL, &show_app_main_menu_bar);
            ImGui::MenuItem("Console", NULL, &show_app_console);
            ImGui::MenuItem("Log", NULL, &show_app_log);
            ImGui::MenuItem("Simple layout", NULL, &show_app_layout);
            ImGui::MenuItem("Property editor", NULL, &show_app_property_editor);
            ImGui::MenuItem("Long text display", NULL, &show_app_long_text);
            ImGui::MenuItem("Auto-resizing window", NULL, &show_app_auto_resize);
            ImGui::MenuItem("Constrained-resizing window", NULL, &show_app_constrained_resize);
            ImGui::MenuItem("Simple overlay", NULL, &show_app_simple_overlay);
            ImGui::MenuItem("Manipulating window titles", NULL, &show_app_window_titles);
            ImGui::MenuItem("Custom rendering", NULL, &show_app_custom_rendering);
            ImGui::MenuItem("Documents", NULL, &show_app_documents);
            ImGui::EndMenu();
        }
        if (ImGui::BeginMenu("Help"))
        {
            ImGui::MenuItem("Metrics", NULL, &show_app_metrics);
            ImGui::MenuItem("Style Editor", NULL, &show_app_style_editor);
            ImGui::MenuItem("About Dear ImGui", NULL, &show_app_about);
            ImGui::EndMenu();
        }
        ImGui::EndMenuBar();
    }

    ImGui::Text("dear imgui says hello. (%s)", IMGUI_VERSION);
    ImGui::Spacing();

    if (ImGui::CollapsingHeader("Help"))
    {
        ImGui::Text("PROGRAMMER GUIDE:");
        ImGui::BulletText("Please see the ShowDemoWindow() code in imgui_demo.cpp. <- you are here!");
        ImGui::BulletText("Please see the comments in imgui.cpp.");
        ImGui::BulletText("Please see the examples/ in application.");
        ImGui::BulletText("Enable 'io.ConfigFlags |= NavEnableKeyboard' for keyboard controls.");
        ImGui::BulletText("Enable 'io.ConfigFlags |= NavEnableGamepad' for gamepad controls.");
        ImGui::Separator();

        ImGui::Text("USER GUIDE:");
        ImGui::ShowUserGuide();
    }

    if (ImGui::CollapsingHeader("Configuration"))
    {
        ImGuiIO& io = ImGui::GetIO();

        if (ImGui::TreeNode("Configuration##2"))
        {
            ImGui::CheckboxFlags("io.ConfigFlags: NavEnableKeyboard", (unsigned int *)&io.ConfigFlags, ImGuiConfigFlags_NavEnableKeyboard);
            ImGui::CheckboxFlags("io.ConfigFlags: NavEnableGamepad", (unsigned int *)&io.ConfigFlags, ImGuiConfigFlags_NavEnableGamepad);
            ImGui::SameLine(); HelpMarker("Required back-end to feed in gamepad inputs in io.NavInputs[] and set io.BackendFlags |= ImGuiBackendFlags_HasGamepad.\n\nRead instructions in imgui.cpp for details.");
            ImGui::CheckboxFlags("io.ConfigFlags: NavEnableSetMousePos", (unsigned int *)&io.ConfigFlags, ImGuiConfigFlags_NavEnableSetMousePos);
            ImGui::SameLine(); HelpMarker("Instruct navigation to move the mouse cursor. See comment for ImGuiConfigFlags_NavEnableSetMousePos.");
            ImGui::CheckboxFlags("io.ConfigFlags: NoMouse", (unsigned int *)&io.ConfigFlags, ImGuiConfigFlags_NoMouse);
            if (io.ConfigFlags & ImGuiConfigFlags_NoMouse) // Create a way to restore this flag otherwise we could be stuck completely!
            {
                if (fmodf((float)ImGui::GetTime(), 0.40f) < 0.20f)
                {
                    ImGui::SameLine();
                    ImGui::Text("<<PRESS SPACE TO DISABLE>>");
                }
                if (ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_Space)))
                    io.ConfigFlags &= ~ImGuiConfigFlags_NoMouse;
            }
            ImGui::CheckboxFlags("io.ConfigFlags: NoMouseCursorChange", (unsigned int *)&io.ConfigFlags, ImGuiConfigFlags_NoMouseCursorChange);
            ImGui::SameLine(); HelpMarker("Instruct back-end to not alter mouse cursor shape and visibility.");
            ImGui::Checkbox("io.ConfigInputTextCursorBlink", &io.ConfigInputTextCursorBlink);
            ImGui::SameLine(); HelpMarker("Set to false to disable blinking cursor, for users who consider it distracting");
            ImGui::Checkbox("io.ConfigWindowsResizeFromEdges", &io.ConfigWindowsResizeFromEdges);
            ImGui::SameLine(); HelpMarker("Enable resizing of windows from their edges and from the lower-left corner.\nThis requires (io.BackendFlags & ImGuiBackendFlags_HasMouseCursors) because it needs mouse cursor feedback.");
            ImGui::Checkbox("io.ConfigWindowsMoveFromTitleBarOnly", &io.ConfigWindowsMoveFromTitleBarOnly);
            ImGui::Checkbox("io.MouseDrawCursor", &io.MouseDrawCursor);
            ImGui::SameLine(); HelpMarker("Instruct Dear ImGui to render a mouse cursor for you. Note that a mouse cursor rendered via your application GPU rendering path will feel more laggy than hardware cursor, but will be more in sync with your other visuals.\n\nSome desktop applications may use both kinds of cursors (e.g. enable software cursor only when resizing/dragging something).");
            ImGui::TreePop();
            ImGui::Separator();
        }

        if (ImGui::TreeNode("Backend Flags"))
        {
            HelpMarker("Those flags are set by the back-ends (imgui_impl_xxx files) to specify their capabilities.");
            ImGuiBackendFlags backend_flags = io.BackendFlags; // Make a local copy to avoid modifying actual back-end flags.
            ImGui::CheckboxFlags("io.BackendFlags: HasGamepad", (unsigned int *)&backend_flags, ImGuiBackendFlags_HasGamepad);
            ImGui::CheckboxFlags("io.BackendFlags: HasMouseCursors", (unsigned int *)&backend_flags, ImGuiBackendFlags_HasMouseCursors);
            ImGui::CheckboxFlags("io.BackendFlags: HasSetMousePos", (unsigned int *)&backend_flags, ImGuiBackendFlags_HasSetMousePos);
            ImGui::TreePop();
            ImGui::Separator();
        }

        if (ImGui::TreeNode("Style"))
        {
            ImGui::ShowStyleEditor();
            ImGui::TreePop();
            ImGui::Separator();
        }

        if (ImGui::TreeNode("Capture/Logging"))
        {
            ImGui::TextWrapped("The logging API redirects all text output so you can easily capture the content of a window or a block. Tree nodes can be automatically expanded.");
            HelpMarker("Try opening any of the contents below in this window and then click one of the \"Log To\" button.");
            ImGui::LogButtons();
            ImGui::TextWrapped("You can also call ImGui::LogText() to output directly to the log without a visual output.");
            if (ImGui::Button("Copy \"Hello, world!\" to clipboard"))
            {
                ImGui::LogToClipboard();
                ImGui::LogText("Hello, world!");
                ImGui::LogFinish();
            }
            ImGui::TreePop();
        }
    }

    if (ImGui::CollapsingHeader("Window options"))
    {
        ImGui::Checkbox("No titlebar", &no_titlebar); ImGui::SameLine(150);
        ImGui::Checkbox("No scrollbar", &no_scrollbar); ImGui::SameLine(300);
        ImGui::Checkbox("No menu", &no_menu);
        ImGui::Checkbox("No move", &no_move); ImGui::SameLine(150);
        ImGui::Checkbox("No resize", &no_resize); ImGui::SameLine(300);
        ImGui::Checkbox("No collapse", &no_collapse);
        ImGui::Checkbox("No close", &no_close); ImGui::SameLine(150);
        ImGui::Checkbox("No nav", &no_nav); ImGui::SameLine(300);
        ImGui::Checkbox("No background", &no_background);
        ImGui::Checkbox("No bring to front", &no_bring_to_front);
    }

    // All demo contents
    ShowDemoWindowWidgets();
    ShowDemoWindowLayout();
    ShowDemoWindowPopups();
    ShowDemoWindowColumns();
    ShowDemoWindowMisc();

    // End of ShowDemoWindow()
    ImGui::End();
}

static void ShowDemoWindowWidgets()
{
    if (!ImGui::CollapsingHeader("Widgets"))
        return;

    if (ImGui::TreeNode("Basic"))
    {
        static int clicked = 0;
        if (ImGui::Button("Button"))
            clicked++;
        if (clicked & 1)
        {
            ImGui::SameLine();
            ImGui::Text("Thanks for clicking me!");
        }

        static bool check = true;
        ImGui::Checkbox("checkbox", &check);

        static int e = 0;
        ImGui::RadioButton("radio a", &e, 0); ImGui::SameLine();
        ImGui::RadioButton("radio b", &e, 1); ImGui::SameLine();
        ImGui::RadioButton("radio c", &e, 2);

        // Color buttons, demonstrate using PushID() to add unique identifier in the ID stack, and changing style.
        for (int i = 0; i < 7; i++)
        {
            if (i > 0)
                ImGui::SameLine();
            ImGui::PushID(i);
            ImGui::PushStyleColor(ImGuiCol_Button, (ImVec4)ImColor::HSV(i/7.0f, 0.6f, 0.6f));
            ImGui::PushStyleColor(ImGuiCol_ButtonHovered, (ImVec4)ImColor::HSV(i/7.0f, 0.7f, 0.7f));
            ImGui::PushStyleColor(ImGuiCol_ButtonActive, (ImVec4)ImColor::HSV(i/7.0f, 0.8f, 0.8f));
            ImGui::Button("Click");
            ImGui::PopStyleColor(3);
            ImGui::PopID();
        }

        // Use AlignTextToFramePadding() to align text baseline to the baseline of framed elements (otherwise a Text+SameLine+Button sequence will have the text a little too high by default)
        ImGui::AlignTextToFramePadding();
        ImGui::Text("Hold to repeat:");
        ImGui::SameLine();

        // Arrow buttons with Repeater
        static int counter = 0;
        float spacing = ImGui::GetStyle().ItemInnerSpacing.x;
        ImGui::PushButtonRepeat(true);
        if (ImGui::ArrowButton("##left", ImGuiDir_Left)) { counter--; }
        ImGui::SameLine(0.0f, spacing);
        if (ImGui::ArrowButton("##right", ImGuiDir_Right)) { counter++; }
        ImGui::PopButtonRepeat();
        ImGui::SameLine();
        ImGui::Text("%d", counter);

        ImGui::Text("Hover over me");
        if (ImGui::IsItemHovered())
            ImGui::SetTooltip("I am a tooltip");

        ImGui::SameLine();
        ImGui::Text("- or me");
        if (ImGui::IsItemHovered())
        {
            ImGui::BeginTooltip();
            ImGui::Text("I am a fancy tooltip");
            static float arr[] = { 0.6f, 0.1f, 1.0f, 0.5f, 0.92f, 0.1f, 0.2f };
            ImGui::PlotLines("Curve", arr, IM_ARRAYSIZE(arr));
            ImGui::EndTooltip();
        }

        ImGui::Separator();

        ImGui::LabelText("label", "Value");

        {
            // Using the _simplified_ one-liner Combo() api here
            // See "Combo" section for examples of how to use the more complete BeginCombo()/EndCombo() api.
            const char* items[] = { "AAAA", "BBBB", "CCCC", "DDDD", "EEEE", "FFFF", "GGGG", "HHHH", "IIII", "JJJJ", "KKKK", "LLLLLLL", "MMMM", "OOOOOOO" };
            static int item_current = 0;
            ImGui::Combo("combo", &item_current, items, IM_ARRAYSIZE(items));
            ImGui::SameLine(); HelpMarker("Refer to the \"Combo\" section below for an explanation of the full BeginCombo/EndCombo API, and demonstration of various flags.\n");
        }

        {
            static char str0[128] = "Hello, world!";
            ImGui::InputText("input text", str0, IM_ARRAYSIZE(str0));
            ImGui::SameLine(); HelpMarker("USER:\nHold SHIFT or use mouse to select text.\n" "CTRL+Left/Right to word jump.\n" "CTRL+A or double-click to select all.\n" "CTRL+X,CTRL+C,CTRL+V clipboard.\n" "CTRL+Z,CTRL+Y undo/redo.\n" "ESCAPE to revert.\n\nPROGRAMMER:\nYou can use the ImGuiInputTextFlags_CallbackResize facility if you need to wire InputText() to a dynamic string type. See misc/cpp/imgui_stdlib.h for an example (this is not demonstrated in imgui_demo.cpp).");

            static char str1[128] = "";
            ImGui::InputTextWithHint("input text (w/ hint)", "enter text here", str1, IM_ARRAYSIZE(str1));

            static int i0 = 123;
            ImGui::InputInt("input int", &i0);
            ImGui::SameLine(); HelpMarker("You can apply arithmetic operators +,*,/ on numerical values.\n  e.g. [ 100 ], input \'*2\', result becomes [ 200 ]\nUse +- to subtract.\n");

            static float f0 = 0.001f;
            ImGui::InputFloat("input float", &f0, 0.01f, 1.0f, "%.3f");

            static double d0 = 999999.00000001;
            ImGui::InputDouble("input double", &d0, 0.01f, 1.0f, "%.8f");

            static float f1 = 1.e10f;
            ImGui::InputFloat("input scientific", &f1, 0.0f, 0.0f, "%e");
            ImGui::SameLine(); HelpMarker("You can input value using the scientific notation,\n  e.g. \"1e+8\" becomes \"100000000\".\n");

            static float vec4a[4] = { 0.10f, 0.20f, 0.30f, 0.44f };
            ImGui::InputFloat3("input float3", vec4a);
        }

        {
            static int i1 = 50, i2 = 42;
            ImGui::DragInt("drag int", &i1, 1);
            ImGui::SameLine(); HelpMarker("Click and drag to edit value.\nHold SHIFT/ALT for faster/slower edit.\nDouble-click or CTRL+click to input value.");

            ImGui::DragInt("drag int 0..100", &i2, 1, 0, 100, "%d%%");

            static float f1=1.00f, f2=0.0067f;
            ImGui::DragFloat("drag float", &f1, 0.005f);
            ImGui::DragFloat("drag small float", &f2, 0.0001f, 0.0f, 0.0f, "%.06f ns");
        }

        {
            static int i1=0;
            ImGui::SliderInt("slider int", &i1, -1, 3);
            ImGui::SameLine(); HelpMarker("CTRL+click to input value.");

            static float f1=0.123f, f2=0.0f;
            ImGui::SliderFloat("slider float", &f1, 0.0f, 1.0f, "ratio = %.3f");
            ImGui::SliderFloat("slider float (curve)", &f2, -10.0f, 10.0f, "%.4f", 2.0f);
            static float angle = 0.0f;
            ImGui::SliderAngle("slider angle", &angle);
        }

        {
            static float col1[3] = { 1.0f,0.0f,0.2f };
            static float col2[4] = { 0.4f,0.7f,0.0f,0.5f };
            ImGui::ColorEdit3("color 1", col1);
            ImGui::SameLine(); HelpMarker("Click on the colored square to open a color picker.\nClick and hold to use drag and drop.\nRight-click on the colored square to show options.\nCTRL+click on individual component to input value.\n");

            ImGui::ColorEdit4("color 2", col2);
        }

        {
            // List box
            const char* listbox_items[] = { "Apple", "Banana", "Cherry", "Kiwi", "Mango", "Orange", "Pineapple", "Strawberry", "Watermelon" };
            static int listbox_item_current = 1;
            ImGui::ListBox("listbox\n(single select)", &listbox_item_current, listbox_items, IM_ARRAYSIZE(listbox_items), 4);

            //static int listbox_item_current2 = 2;
            //ImGui::SetNextItemWidth(-1);
            //ImGui::ListBox("##listbox2", &listbox_item_current2, listbox_items, IM_ARRAYSIZE(listbox_items), 4);
        }

        ImGui::TreePop();
    }

    // Testing ImGuiOnceUponAFrame helper.
    //static ImGuiOnceUponAFrame once;
    //for (int i = 0; i < 5; i++)
    //    if (once)
    //        ImGui::Text("This will be displayed only once.");

    if (ImGui::TreeNode("Trees"))
    {
        if (ImGui::TreeNode("Basic trees"))
        {
            for (int i = 0; i < 5; i++)
                if (ImGui::TreeNode((void*)(intptr_t)i, "Child %d", i))
                {
                    ImGui::Text("blah blah");
                    ImGui::SameLine();
                    if (ImGui::SmallButton("button")) { };
                    ImGui::TreePop();
                }
            ImGui::TreePop();
        }

        if (ImGui::TreeNode("Advanced, with Selectable nodes"))
        {
            HelpMarker("This is a more typical looking tree with selectable nodes.\nClick to select, CTRL+Click to toggle, click on arrows or double-click to open.");
            static bool align_label_with_current_x_position = false;
            ImGui::Checkbox("Align label with current X position)", &align_label_with_current_x_position);
            ImGui::Text("Hello!");
            if (align_label_with_current_x_position)
                ImGui::Unindent(ImGui::GetTreeNodeToLabelSpacing());

            static int selection_mask = (1 << 2); // Dumb representation of what may be user-side selection state. You may carry selection state inside or outside your objects in whatever format you see fit.
            int node_clicked = -1;                // Temporary storage of what node we have clicked to process selection at the end of the loop. May be a pointer to your own node type, etc.
            ImGui::PushStyleVar(ImGuiStyleVar_IndentSpacing, ImGui::GetFontSize()*3); // Increase spacing to differentiate leaves from expanded contents.
            for (int i = 0; i < 6; i++)
            {
                // Disable the default open on single-click behavior and pass in Selected flag according to our selection state.
                ImGuiTreeNodeFlags node_flags = ImGuiTreeNodeFlags_OpenOnArrow | ImGuiTreeNodeFlags_OpenOnDoubleClick;
                if (selection_mask & (1 << i))
                    node_flags |= ImGuiTreeNodeFlags_Selected;
                if (i < 3)
                {
                    // Items 0..2 are Tree Node
                    bool node_open = ImGui::TreeNodeEx((void*)(intptr_t)i, node_flags, "Selectable Node %d", i);
                    if (ImGui::IsItemClicked())
                        node_clicked = i;
                    if (node_open)
                    {
                        ImGui::Text("Blah blah\nBlah Blah");
                        ImGui::TreePop();
                    }
                }
                else
                {
                    // Items 3..5 are Tree Leaves
                    // The only reason we use TreeNode at all is to allow selection of the leaf.
                    // Otherwise we can use BulletText() or TreeAdvanceToLabelPos()+Text().
                    node_flags |= ImGuiTreeNodeFlags_Leaf | ImGuiTreeNodeFlags_NoTreePushOnOpen; // ImGuiTreeNodeFlags_Bullet
                    ImGui::TreeNodeEx((void*)(intptr_t)i, node_flags, "Selectable Leaf %d", i);
                    if (ImGui::IsItemClicked())
                        node_clicked = i;
                }
            }
            if (node_clicked != -1)
            {
                // Update selection state. Process outside of tree loop to avoid visual inconsistencies during the clicking-frame.
                if (ImGui::GetIO().KeyCtrl)
                    selection_mask ^= (1 << node_clicked);          // CTRL+click to toggle
                else //if (!(selection_mask & (1 << node_clicked))) // Depending on selection behavior you want, this commented bit preserve selection when clicking on item that is part of the selection
                    selection_mask = (1 << node_clicked);           // Click to single-select
            }
            ImGui::PopStyleVar();
            if (align_label_with_current_x_position)
                ImGui::Indent(ImGui::GetTreeNodeToLabelSpacing());
            ImGui::TreePop();
        }
        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Collapsing Headers"))
    {
        static bool closable_group = true;
        ImGui::Checkbox("Show 2nd header", &closable_group);
        if (ImGui::CollapsingHeader("Header"))
        {
            ImGui::Text("IsItemHovered: %d", ImGui::IsItemHovered());
            for (int i = 0; i < 5; i++)
                ImGui::Text("Some content %d", i);
        }
        if (ImGui::CollapsingHeader("Header with a close button", &closable_group))
        {
            ImGui::Text("IsItemHovered: %d", ImGui::IsItemHovered());
            for (int i = 0; i < 5; i++)
                ImGui::Text("More content %d", i);
        }
        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Bullets"))
    {
        ImGui::BulletText("Bullet point 1");
        ImGui::BulletText("Bullet point 2\nOn multiple lines");
        ImGui::Bullet(); ImGui::Text("Bullet point 3 (two calls)");
        ImGui::Bullet(); ImGui::SmallButton("Button");
        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Text"))
    {
        if (ImGui::TreeNode("Colored Text"))
        {
            // Using shortcut. You can use PushStyleColor()/PopStyleColor() for more flexibility.
            ImGui::TextColored(ImVec4(1.0f,0.0f,1.0f,1.0f), "Pink");
            ImGui::TextColored(ImVec4(1.0f,1.0f,0.0f,1.0f), "Yellow");
            ImGui::TextDisabled("Disabled");
            ImGui::SameLine(); HelpMarker("The TextDisabled color is stored in ImGuiStyle.");
            ImGui::TreePop();
        }

        if (ImGui::TreeNode("Word Wrapping"))
        {
            // Using shortcut. You can use PushTextWrapPos()/PopTextWrapPos() for more flexibility.
            ImGui::TextWrapped("This text should automatically wrap on the edge of the window. The current implementation for text wrapping follows simple rules suitable for English and possibly other languages.");
            ImGui::Spacing();

            static float wrap_width = 200.0f;
            ImGui::SliderFloat("Wrap width", &wrap_width, -20, 600, "%.0f");

            ImGui::Text("Test paragraph 1:");
            ImVec2 pos = ImGui::GetCursorScreenPos();
            ImGui::GetWindowDrawList()->AddRectFilled(ImVec2(pos.x + wrap_width, pos.y), ImVec2(pos.x + wrap_width + 10, pos.y + ImGui::GetTextLineHeight()), IM_COL32(255,0,255,255));
            ImGui::PushTextWrapPos(ImGui::GetCursorPos().x + wrap_width);
            ImGui::Text("The lazy dog is a good dog. This paragraph is made to fit within %.0f pixels. Testing a 1 character word. The quick brown fox jumps over the lazy dog.", wrap_width);
            ImGui::GetWindowDrawList()->AddRect(ImGui::GetItemRectMin(), ImGui::GetItemRectMax(), IM_COL32(255,255,0,255));
            ImGui::PopTextWrapPos();

            ImGui::Text("Test paragraph 2:");
            pos = ImGui::GetCursorScreenPos();
            ImGui::GetWindowDrawList()->AddRectFilled(ImVec2(pos.x + wrap_width, pos.y), ImVec2(pos.x + wrap_width + 10, pos.y + ImGui::GetTextLineHeight()), IM_COL32(255,0,255,255));
            ImGui::PushTextWrapPos(ImGui::GetCursorPos().x + wrap_width);
            ImGui::Text("aaaaaaaa bbbbbbbb, c cccccccc,dddddddd. d eeeeeeee   ffffffff. gggggggg!hhhhhhhh");
            ImGui::GetWindowDrawList()->AddRect(ImGui::GetItemRectMin(), ImGui::GetItemRectMax(), IM_COL32(255,255,0,255));
            ImGui::PopTextWrapPos();

            ImGui::TreePop();
        }

        if (ImGui::TreeNode("UTF-8 Text"))
        {
            // UTF-8 test with Japanese characters
            // (Needs a suitable font, try Noto, or Arial Unicode, or M+ fonts. Read misc/fonts/README.txt for details.)
            // - From C++11 you can use the u8"my text" syntax to encode literal strings as UTF-8
            // - For earlier compiler, you may be able to encode your sources as UTF-8 (e.g. Visual Studio save your file as 'UTF-8 without signature')
            // - FOR THIS DEMO FILE ONLY, BECAUSE WE WANT TO SUPPORT OLD COMPILERS, WE ARE *NOT* INCLUDING RAW UTF-8 CHARACTERS IN THIS SOURCE FILE.
            //   Instead we are encoding a few strings with hexadecimal constants. Don't do this in your application!
            //   Please use u8"text in any language" in your application!
            // Note that characters values are preserved even by InputText() if the font cannot be displayed, so you can safely copy & paste garbled characters into another application.
            ImGui::TextWrapped("CJK text will only appears if the font was loaded with the appropriate CJK character ranges. Call io.Font->AddFontFromFileTTF() manually to load extra character ranges. Read misc/fonts/README.txt for details.");
            ImGui::Text("Hiragana: \xe3\x81\x8b\xe3\x81\x8d\xe3\x81\x8f\xe3\x81\x91\xe3\x81\x93 (kakikukeko)"); // Normally we would use u8"blah blah" with the proper characters directly in the string.
            ImGui::Text("Kanjis: \xe6\x97\xa5\xe6\x9c\xac\xe8\xaa\x9e (nihongo)");
            static char buf[32] = "\xe6\x97\xa5\xe6\x9c\xac\xe8\xaa\x9e";
            //static char buf[32] = u8"NIHONGO"; // <- this is how you would write it with C++11, using real kanjis
            ImGui::InputText("UTF-8 input", buf, IM_ARRAYSIZE(buf));
            ImGui::TreePop();
        }
        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Images"))
    {
        ImGuiIO& io = ImGui::GetIO();
        ImGui::TextWrapped("Below we are displaying the font texture (which is the only texture we have access to in this demo). Use the 'ImTextureID' type as storage to pass pointers or identifier to your own texture data. Hover the texture for a zoomed view!");

        // Here we are grabbing the font texture because that's the only one we have access to inside the demo code.
        // Remember that ImTextureID is just storage for whatever you want it to be, it is essentially a value that will be passed to the render function inside the ImDrawCmd structure.
        // If you use one of the default imgui_impl_XXXX.cpp renderer, they all have comments at the top of their file to specify what they expect to be stored in ImTextureID.
        // (for example, the imgui_impl_dx11.cpp renderer expect a 'ID3D11ShaderResourceView*' pointer. The imgui_impl_glfw_gl3.cpp renderer expect a GLuint OpenGL texture identifier etc.)
        // If you decided that ImTextureID = MyEngineTexture*, then you can pass your MyEngineTexture* pointers to ImGui::Image(), and gather width/height through your own functions, etc.
        // Using ShowMetricsWindow() as a "debugger" to inspect the draw data that are being passed to your render will help you debug issues if you are confused about this.
        // Consider using the lower-level ImDrawList::AddImage() API, via ImGui::GetWindowDrawList()->AddImage().
        ImTextureID my_tex_id = io.Fonts->TexID;
        float my_tex_w = (float)io.Fonts->TexWidth;
        float my_tex_h = (float)io.Fonts->TexHeight;

        ImGui::Text("%.0fx%.0f", my_tex_w, my_tex_h);
        ImVec2 pos = ImGui::GetCursorScreenPos();
        ImGui::Image(my_tex_id, ImVec2(my_tex_w, my_tex_h), ImVec2(0,0), ImVec2(1,1), ImVec4(1.0f,1.0f,1.0f,1.0f), ImVec4(1.0f,1.0f,1.0f,0.5f));
        if (ImGui::IsItemHovered())
        {
            ImGui::BeginTooltip();
            float region_sz = 32.0f;
            float region_x = io.MousePos.x - pos.x - region_sz * 0.5f; if (region_x < 0.0f) region_x = 0.0f; else if (region_x > my_tex_w - region_sz) region_x = my_tex_w - region_sz;
            float region_y = io.MousePos.y - pos.y - region_sz * 0.5f; if (region_y < 0.0f) region_y = 0.0f; else if (region_y > my_tex_h - region_sz) region_y = my_tex_h - region_sz;
            float zoom = 4.0f;
            ImGui::Text("Min: (%.2f, %.2f)", region_x, region_y);
            ImGui::Text("Max: (%.2f, %.2f)", region_x + region_sz, region_y + region_sz);
            ImVec2 uv0 = ImVec2((region_x) / my_tex_w, (region_y) / my_tex_h);
            ImVec2 uv1 = ImVec2((region_x + region_sz) / my_tex_w, (region_y + region_sz) / my_tex_h);
            ImGui::Image(my_tex_id, ImVec2(region_sz * zoom, region_sz * zoom), uv0, uv1, ImVec4(1.0f, 1.0f, 1.0f, 1.0f), ImVec4(1.0f, 1.0f, 1.0f, 0.5f));
            ImGui::EndTooltip();
        }
        ImGui::TextWrapped("And now some textured buttons..");
        static int pressed_count = 0;
        for (int i = 0; i < 8; i++)
        {
            ImGui::PushID(i);
            int frame_padding = -1 + i;     // -1 = uses default padding
            if (ImGui::ImageButton(my_tex_id, ImVec2(32,32), ImVec2(0,0), ImVec2(32.0f/my_tex_w,32/my_tex_h), frame_padding, ImVec4(0.0f,0.0f,0.0f,1.0f)))
                pressed_count += 1;
            ImGui::PopID();
            ImGui::SameLine();
        }
        ImGui::NewLine();
        ImGui::Text("Pressed %d times.", pressed_count);
        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Combo"))
    {
        // Expose flags as checkbox for the demo
        static ImGuiComboFlags flags = 0;
        ImGui::CheckboxFlags("ImGuiComboFlags_PopupAlignLeft", (unsigned int*)&flags, ImGuiComboFlags_PopupAlignLeft);
        ImGui::SameLine(); HelpMarker("Only makes a difference if the popup is larger than the combo");
        if (ImGui::CheckboxFlags("ImGuiComboFlags_NoArrowButton", (unsigned int*)&flags, ImGuiComboFlags_NoArrowButton))
            flags &= ~ImGuiComboFlags_NoPreview;     // Clear the other flag, as we cannot combine both
        if (ImGui::CheckboxFlags("ImGuiComboFlags_NoPreview", (unsigned int*)&flags, ImGuiComboFlags_NoPreview))
            flags &= ~ImGuiComboFlags_NoArrowButton; // Clear the other flag, as we cannot combine both

        // General BeginCombo() API, you have full control over your selection data and display type.
        // (your selection data could be an index, a pointer to the object, an id for the object, a flag stored in the object itself, etc.)
        const char* items[] = { "AAAA", "BBBB", "CCCC", "DDDD", "EEEE", "FFFF", "GGGG", "HHHH", "IIII", "JJJJ", "KKKK", "LLLLLLL", "MMMM", "OOOOOOO" };
        static const char* item_current = items[0];            // Here our selection is a single pointer stored outside the object.
        if (ImGui::BeginCombo("combo 1", item_current, flags)) // The second parameter is the label previewed before opening the combo.
        {
            for (int n = 0; n < IM_ARRAYSIZE(items); n++)
            {
                bool is_selected = (item_current == items[n]);
                if (ImGui::Selectable(items[n], is_selected))
                    item_current = items[n];
                if (is_selected)
                    ImGui::SetItemDefaultFocus();   // Set the initial focus when opening the combo (scrolling + for keyboard navigation support in the upcoming navigation branch)
            }
            ImGui::EndCombo();
        }

        // Simplified one-liner Combo() API, using values packed in a single constant string
        static int item_current_2 = 0;
        ImGui::Combo("combo 2 (one-liner)", &item_current_2, "aaaa\0bbbb\0cccc\0dddd\0eeee\0\0");

        // Simplified one-liner Combo() using an array of const char*
        static int item_current_3 = -1; // If the selection isn't within 0..count, Combo won't display a preview
        ImGui::Combo("combo 3 (array)", &item_current_3, items, IM_ARRAYSIZE(items));

        // Simplified one-liner Combo() using an accessor function
        struct FuncHolder { static bool ItemGetter(void* data, int idx, const char** out_str) { *out_str = ((const char**)data)[idx]; return true; } };
        static int item_current_4 = 0;
        ImGui::Combo("combo 4 (function)", &item_current_4, &FuncHolder::ItemGetter, items, IM_ARRAYSIZE(items));

        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Selectables"))
    {
        // Selectable() has 2 overloads:
        // - The one taking "bool selected" as a read-only selection information. When Selectable() has been clicked is returns true and you can alter selection state accordingly.
        // - The one taking "bool* p_selected" as a read-write selection information (convenient in some cases)
        // The earlier is more flexible, as in real application your selection may be stored in a different manner (in flags within objects, as an external list, etc).
        if (ImGui::TreeNode("Basic"))
        {
            static bool selection[5] = { false, true, false, false, false };
            ImGui::Selectable("1. I am selectable", &selection[0]);
            ImGui::Selectable("2. I am selectable", &selection[1]);
            ImGui::Text("3. I am not selectable");
            ImGui::Selectable("4. I am selectable", &selection[3]);
            if (ImGui::Selectable("5. I am double clickable", selection[4], ImGuiSelectableFlags_AllowDoubleClick))
                if (ImGui::IsMouseDoubleClicked(0))
                    selection[4] = !selection[4];
            ImGui::TreePop();
        }
        if (ImGui::TreeNode("Selection State: Single Selection"))
        {
            static int selected = -1;
            for (int n = 0; n < 5; n++)
            {
                char buf[32];
                sprintf(buf, "Object %d", n);
                if (ImGui::Selectable(buf, selected == n))
                    selected = n;
            }
            ImGui::TreePop();
        }
        if (ImGui::TreeNode("Selection State: Multiple Selection"))
        {
            HelpMarker("Hold CTRL and click to select multiple items.");
            static bool selection[5] = { false, false, false, false, false };
            for (int n = 0; n < 5; n++)
            {
                char buf[32];
                sprintf(buf, "Object %d", n);
                if (ImGui::Selectable(buf, selection[n]))
                {
                    if (!ImGui::GetIO().KeyCtrl)    // Clear selection when CTRL is not held
                        memset(selection, 0, sizeof(selection));
                    selection[n] ^= 1;
                }
            }
            ImGui::TreePop();
        }
        if (ImGui::TreeNode("Rendering more text into the same line"))
        {
            // Using the Selectable() override that takes "bool* p_selected" parameter and toggle your booleans automatically.
            static bool selected[3] = { false, false, false };
            ImGui::Selectable("main.c",    &selected[0]); ImGui::SameLine(300); ImGui::Text(" 2,345 bytes");
            ImGui::Selectable("Hello.cpp", &selected[1]); ImGui::SameLine(300); ImGui::Text("12,345 bytes");
            ImGui::Selectable("Hello.h",   &selected[2]); ImGui::SameLine(300); ImGui::Text(" 2,345 bytes");
            ImGui::TreePop();
        }
        if (ImGui::TreeNode("In columns"))
        {
            ImGui::Columns(3, NULL, false);
            static bool selected[16] = { 0 };
            for (int i = 0; i < 16; i++)
            {
                char label[32]; sprintf(label, "Item %d", i);
                if (ImGui::Selectable(label, &selected[i])) {}
                ImGui::NextColumn();
            }
            ImGui::Columns(1);
            ImGui::TreePop();
        }
        if (ImGui::TreeNode("Grid"))
        {
            static bool selected[4*4] = { true, false, false, false, false, true, false, false, false, false, true, false, false, false, false, true };
            for (int i = 0; i < 4*4; i++)
            {
                ImGui::PushID(i);
                if (ImGui::Selectable("Sailor", &selected[i], 0, ImVec2(50,50)))
                {
                    // Note: We _unnecessarily_ test for both x/y and i here only to silence some static analyzer. The second part of each test is unnecessary.
                    int x = i % 4;
                    int y = i / 4;
                    if (x > 0)           { selected[i - 1] ^= 1; }
                    if (x < 3 && i < 15) { selected[i + 1] ^= 1; }
                    if (y > 0 && i > 3)  { selected[i - 4] ^= 1; }
                    if (y < 3 && i < 12) { selected[i + 4] ^= 1; }
                }
                if ((i % 4) < 3) ImGui::SameLine();
                ImGui::PopID();
            }
            ImGui::TreePop();
        }
        if (ImGui::TreeNode("Alignment"))
        {
            HelpMarker("Alignment applies when a selectable is larger than its text content.\nBy default, Selectables uses style.SelectableTextAlign but it can be overriden on a per-item basis using PushStyleVar().");
            static bool selected[3*3] = { true, false, true, false, true, false, true, false, true };
            for (int y = 0; y < 3; y++)
            {
                for (int x = 0; x < 3; x++)
                {
                    ImVec2 alignment = ImVec2((float)x / 2.0f, (float)y / 2.0f);
                    char name[32];
                    sprintf(name, "(%.1f,%.1f)", alignment.x, alignment.y);
                    if (x > 0) ImGui::SameLine();
                    ImGui::PushStyleVar(ImGuiStyleVar_SelectableTextAlign, alignment);
                    ImGui::Selectable(name, &selected[3*y+x], ImGuiSelectableFlags_None, ImVec2(80,80));
                    ImGui::PopStyleVar();
                }
            }
            ImGui::TreePop();
        }
        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Text Input"))
    {
        if (ImGui::TreeNode("Multi-line Text Input"))
        {
            // Note: we are using a fixed-sized buffer for simplicity here. See ImGuiInputTextFlags_CallbackResize
            // and the code in misc/cpp/imgui_stdlib.h for how to setup InputText() for dynamically resizing strings.
            static char text[1024 * 16] =
                "/*\n"
                " The Pentium F00F bug, shorthand for F0 0F C7 C8,\n"
                " the hexadecimal encoding of one offending instruction,\n"
                " more formally, the invalid operand with locked CMPXCHG8B\n"
                " instruction bug, is a design flaw in the majority of\n"
                " Intel Pentium, Pentium MMX, and Pentium OverDrive\n"
                " processors (all in the P5 microarchitecture).\n"
                "*/\n\n"
                "label:\n"
                "\tlock cmpxchg8b eax\n";

            static ImGuiInputTextFlags flags = ImGuiInputTextFlags_AllowTabInput;
            HelpMarker("You can use the ImGuiInputTextFlags_CallbackResize facility if you need to wire InputTextMultiline() to a dynamic string type. See misc/cpp/imgui_stdlib.h for an example. (This is not demonstrated in imgui_demo.cpp)");
            ImGui::CheckboxFlags("ImGuiInputTextFlags_ReadOnly", (unsigned int*)&flags, ImGuiInputTextFlags_ReadOnly);
            ImGui::CheckboxFlags("ImGuiInputTextFlags_AllowTabInput", (unsigned int*)&flags, ImGuiInputTextFlags_AllowTabInput);
            ImGui::CheckboxFlags("ImGuiInputTextFlags_CtrlEnterForNewLine", (unsigned int*)&flags, ImGuiInputTextFlags_CtrlEnterForNewLine);
            ImGui::InputTextMultiline("##source", text, IM_ARRAYSIZE(text), ImVec2(-1.0f, ImGui::GetTextLineHeight() * 16), flags);
            ImGui::TreePop();
        }

        if (ImGui::TreeNode("Filtered Text Input"))
        {
            static char buf1[64] = ""; ImGui::InputText("default", buf1, 64);
            static char buf2[64] = ""; ImGui::InputText("decimal", buf2, 64, ImGuiInputTextFlags_CharsDecimal);
            static char buf3[64] = ""; ImGui::InputText("hexadecimal", buf3, 64, ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsUppercase);
            static char buf4[64] = ""; ImGui::InputText("uppercase", buf4, 64, ImGuiInputTextFlags_CharsUppercase);
            static char buf5[64] = ""; ImGui::InputText("no blank", buf5, 64, ImGuiInputTextFlags_CharsNoBlank);
            struct TextFilters { static int FilterImGuiLetters(ImGuiInputTextCallbackData* data) { if (data->EventChar < 256 && strchr("imgui", (char)data->EventChar)) return 0; return 1; } };
            static char buf6[64] = ""; ImGui::InputText("\"imgui\" letters", buf6, 64, ImGuiInputTextFlags_CallbackCharFilter, TextFilters::FilterImGuiLetters);

            ImGui::Text("Password input");
            static char bufpass[64] = "password123";
            ImGui::InputText("password", bufpass, 64, ImGuiInputTextFlags_Password | ImGuiInputTextFlags_CharsNoBlank);
            ImGui::SameLine(); HelpMarker("Display all characters as '*'.\nDisable clipboard cut and copy.\nDisable logging.\n");
            ImGui::InputTextWithHint("password (w/ hint)", "<password>", bufpass, 64, ImGuiInputTextFlags_Password | ImGuiInputTextFlags_CharsNoBlank);
            ImGui::InputText("password (clear)", bufpass, 64, ImGuiInputTextFlags_CharsNoBlank);
            ImGui::TreePop();
        }

        if (ImGui::TreeNode("Resize Callback"))
        {
            // If you have a custom string type you would typically create a ImGui::InputText() wrapper than takes your type as input.
            // See misc/cpp/imgui_stdlib.h and .cpp for an implementation of this using std::string.
            HelpMarker("Demonstrate using ImGuiInputTextFlags_CallbackResize to wire your resizable string type to InputText().\n\nSee misc/cpp/imgui_stdlib.h for an implementation of this for std::string.");
            struct Funcs
            {
                static int MyResizeCallback(ImGuiInputTextCallbackData* data)
                {
                    if (data->EventFlag == ImGuiInputTextFlags_CallbackResize)
                    {
                        ImVector<char>* my_str = (ImVector<char>*)data->UserData;
                        IM_ASSERT(my_str->begin() == data->Buf);
                        my_str->resize(data->BufSize);  // NB: On resizing calls, generally data->BufSize == data->BufTextLen + 1
                        data->Buf = my_str->begin();
                    }
                    return 0;
                }

                // Tip: Because ImGui:: is a namespace you would typicall add your own function into the namespace in your own source files.
                // For example, you may add a function called ImGui::InputText(const char* label, MyString* my_str).
                static bool MyInputTextMultiline(const char* label, ImVector<char>* my_str, const ImVec2& size = ImVec2(0, 0), ImGuiInputTextFlags flags = 0)
                {
                    IM_ASSERT((flags & ImGuiInputTextFlags_CallbackResize) == 0);
                    return ImGui::InputTextMultiline(label, my_str->begin(), (size_t)my_str->size(), size, flags | ImGuiInputTextFlags_CallbackResize, Funcs::MyResizeCallback, (void*)my_str);
                }
            };

            // For this demo we are using ImVector as a string container.
            // Note that because we need to store a terminating zero character, our size/capacity are 1 more than usually reported by a typical string class.
            static ImVector<char> my_str;
            if (my_str.empty())
                my_str.push_back(0);
            Funcs::MyInputTextMultiline("##MyStr", &my_str, ImVec2(-1.0f, ImGui::GetTextLineHeight() * 16));
            ImGui::Text("Data: %p\nSize: %d\nCapacity: %d", (void*)my_str.begin(), my_str.size(), my_str.capacity());
            ImGui::TreePop();
        }

        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Plots Widgets"))
    {
        static bool animate = true;
        ImGui::Checkbox("Animate", &animate);

        static float arr[] = { 0.6f, 0.1f, 1.0f, 0.5f, 0.92f, 0.1f, 0.2f };
        ImGui::PlotLines("Frame Times", arr, IM_ARRAYSIZE(arr));

        // Create a dummy array of contiguous float values to plot
        // Tip: If your float aren't contiguous but part of a structure, you can pass a pointer to your first float and the sizeof() of your structure in the Stride parameter.
        static float values[90] = { 0 };
        static int values_offset = 0;
        static double refresh_time = 0.0;
        if (!animate || refresh_time == 0.0)
            refresh_time = ImGui::GetTime();
        while (refresh_time < ImGui::GetTime()) // Create dummy data at fixed 60 hz rate for the demo
        {
            static float phase = 0.0f;
            values[values_offset] = cosf(phase);
            values_offset = (values_offset+1) % IM_ARRAYSIZE(values);
            phase += 0.10f*values_offset;
            refresh_time += 1.0f/60.0f;
        }
        ImGui::PlotLines("Lines", values, IM_ARRAYSIZE(values), values_offset, "avg 0.0", -1.0f, 1.0f, ImVec2(0,80));
        ImGui::PlotHistogram("Histogram", arr, IM_ARRAYSIZE(arr), 0, NULL, 0.0f, 1.0f, ImVec2(0,80));

        // Use functions to generate output
        // FIXME: This is rather awkward because current plot API only pass in indices. We probably want an API passing floats and user provide sample rate/count.
        struct Funcs
        {
            static float Sin(void*, int i) { return sinf(i * 0.1f); }
            static float Saw(void*, int i) { return (i & 1) ? 1.0f : -1.0f; }
        };
        static int func_type = 0, display_count = 70;
        ImGui::Separator();
        ImGui::SetNextItemWidth(100);
        ImGui::Combo("func", &func_type, "Sin\0Saw\0");
        ImGui::SameLine();
        ImGui::SliderInt("Sample count", &display_count, 1, 400);
        float (*func)(void*, int) = (func_type == 0) ? Funcs::Sin : Funcs::Saw;
        ImGui::PlotLines("Lines", func, NULL, display_count, 0, NULL, -1.0f, 1.0f, ImVec2(0,80));
        ImGui::PlotHistogram("Histogram", func, NULL, display_count, 0, NULL, -1.0f, 1.0f, ImVec2(0,80));
        ImGui::Separator();

        // Animate a simple progress bar
        static float progress = 0.0f, progress_dir = 1.0f;
        if (animate)
        {
            progress += progress_dir * 0.4f * ImGui::GetIO().DeltaTime;
            if (progress >= +1.1f) { progress = +1.1f; progress_dir *= -1.0f; }
            if (progress <= -0.1f) { progress = -0.1f; progress_dir *= -1.0f; }
        }

        // Typically we would use ImVec2(-1.0f,0.0f) to use all available width, or ImVec2(width,0.0f) for a specified width. ImVec2(0.0f,0.0f) uses ItemWidth.
        ImGui::ProgressBar(progress, ImVec2(0.0f,0.0f));
        ImGui::SameLine(0.0f, ImGui::GetStyle().ItemInnerSpacing.x);
        ImGui::Text("Progress Bar");

        float progress_saturated = (progress < 0.0f) ? 0.0f : (progress > 1.0f) ? 1.0f : progress;
        char buf[32];
        sprintf(buf, "%d/%d", (int)(progress_saturated*1753), 1753);
        ImGui::ProgressBar(progress, ImVec2(0.f,0.f), buf);
        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Color/Picker Widgets"))
    {
        static ImVec4 color = ImVec4(114.0f/255.0f, 144.0f/255.0f, 154.0f/255.0f, 200.0f/255.0f);

        static bool alpha_preview = true;
        static bool alpha_half_preview = false;
        static bool drag_and_drop = true;
        static bool options_menu = true;
        static bool hdr = false;
        ImGui::Checkbox("With Alpha Preview", &alpha_preview);
        ImGui::Checkbox("With Half Alpha Preview", &alpha_half_preview);
        ImGui::Checkbox("With Drag and Drop", &drag_and_drop);
        ImGui::Checkbox("With Options Menu", &options_menu); ImGui::SameLine(); HelpMarker("Right-click on the individual color widget to show options.");
        ImGui::Checkbox("With HDR", &hdr); ImGui::SameLine(); HelpMarker("Currently all this does is to lift the 0..1 limits on dragging widgets.");
        int misc_flags = (hdr ? ImGuiColorEditFlags_HDR : 0) | (drag_and_drop ? 0 : ImGuiColorEditFlags_NoDragDrop) | (alpha_half_preview ? ImGuiColorEditFlags_AlphaPreviewHalf : (alpha_preview ? ImGuiColorEditFlags_AlphaPreview : 0)) | (options_menu ? 0 : ImGuiColorEditFlags_NoOptions);

        ImGui::Text("Color widget:");
        ImGui::SameLine(); HelpMarker("Click on the colored square to open a color picker.\nCTRL+click on individual component to input value.\n");
        ImGui::ColorEdit3("MyColor##1", (float*)&color, misc_flags);

        ImGui::Text("Color widget HSV with Alpha:");
        ImGui::ColorEdit4("MyColor##2", (float*)&color, ImGuiColorEditFlags_DisplayHSV | misc_flags);

        ImGui::Text("Color widget with Float Display:");
        ImGui::ColorEdit4("MyColor##2f", (float*)&color, ImGuiColorEditFlags_Float | misc_flags);

        ImGui::Text("Color button with Picker:");
        ImGui::SameLine(); HelpMarker("With the ImGuiColorEditFlags_NoInputs flag you can hide all the slider/text inputs.\nWith the ImGuiColorEditFlags_NoLabel flag you can pass a non-empty label which will only be used for the tooltip and picker popup.");
        ImGui::ColorEdit4("MyColor##3", (float*)&color, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoLabel | misc_flags);

        ImGui::Text("Color button with Custom Picker Popup:");

        // Generate a dummy default palette. The palette will persist and can be edited.
        static bool saved_palette_init = true;
        static ImVec4 saved_palette[32] = { };
        if (saved_palette_init)
        {
            for (int n = 0; n < IM_ARRAYSIZE(saved_palette); n++)
            {
                ImGui::ColorConvertHSVtoRGB(n / 31.0f, 0.8f, 0.8f, saved_palette[n].x, saved_palette[n].y, saved_palette[n].z);
                saved_palette[n].w = 1.0f; // Alpha
            }
            saved_palette_init = false;
        }

        static ImVec4 backup_color;
        bool open_popup = ImGui::ColorButton("MyColor##3b", color, misc_flags);
        ImGui::SameLine();
        open_popup |= ImGui::Button("Palette");
        if (open_popup)
        {
            ImGui::OpenPopup("mypicker");
            backup_color = color;
        }
        if (ImGui::BeginPopup("mypicker"))
        {
            ImGui::Text("MY CUSTOM COLOR PICKER WITH AN AMAZING PALETTE!");
            ImGui::Separator();
            ImGui::ColorPicker4("##picker", (float*)&color, misc_flags | ImGuiColorEditFlags_NoSidePreview | ImGuiColorEditFlags_NoSmallPreview);
            ImGui::SameLine();

            ImGui::BeginGroup(); // Lock X position
            ImGui::Text("Current");
            ImGui::ColorButton("##current", color, ImGuiColorEditFlags_NoPicker | ImGuiColorEditFlags_AlphaPreviewHalf, ImVec2(60,40));
            ImGui::Text("Previous");
            if (ImGui::ColorButton("##previous", backup_color, ImGuiColorEditFlags_NoPicker | ImGuiColorEditFlags_AlphaPreviewHalf, ImVec2(60,40)))
                color = backup_color;
            ImGui::Separator();
            ImGui::Text("Palette");
            for (int n = 0; n < IM_ARRAYSIZE(saved_palette); n++)
            {
                ImGui::PushID(n);
                if ((n % 8) != 0)
                    ImGui::SameLine(0.0f, ImGui::GetStyle().ItemSpacing.y);
                if (ImGui::ColorButton("##palette", saved_palette[n], ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_NoPicker | ImGuiColorEditFlags_NoTooltip, ImVec2(20,20)))
                    color = ImVec4(saved_palette[n].x, saved_palette[n].y, saved_palette[n].z, color.w); // Preserve alpha!

                // Allow user to drop colors into each palette entry
                // (Note that ColorButton is already a drag source by default, unless using ImGuiColorEditFlags_NoDragDrop)
                if (ImGui::BeginDragDropTarget())
                {
                    if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_3F))
                        memcpy((float*)&saved_palette[n], payload->Data, sizeof(float) * 3);
                    if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_4F))
                        memcpy((float*)&saved_palette[n], payload->Data, sizeof(float) * 4);
                    ImGui::EndDragDropTarget();
                }

                ImGui::PopID();
            }
            ImGui::EndGroup();
            ImGui::EndPopup();
        }

        ImGui::Text("Color button only:");
        ImGui::ColorButton("MyColor##3c", *(ImVec4*)&color, misc_flags, ImVec2(80,80));

        ImGui::Text("Color picker:");
        static bool alpha = true;
        static bool alpha_bar = true;
        static bool side_preview = true;
        static bool ref_color = false;
        static ImVec4 ref_color_v(1.0f,0.0f,1.0f,0.5f);
        static int display_mode = 0;
        static int picker_mode = 0;
        ImGui::Checkbox("With Alpha", &alpha);
        ImGui::Checkbox("With Alpha Bar", &alpha_bar);
        ImGui::Checkbox("With Side Preview", &side_preview);
        if (side_preview)
        {
            ImGui::SameLine();
            ImGui::Checkbox("With Ref Color", &ref_color);
            if (ref_color)
            {
                ImGui::SameLine();
                ImGui::ColorEdit4("##RefColor", &ref_color_v.x, ImGuiColorEditFlags_NoInputs | misc_flags);
            }
        }
        ImGui::Combo("Display Mode", &display_mode, "Auto/Current\0None\0RGB Only\0HSV Only\0Hex Only\0");
        ImGui::SameLine(); HelpMarker("ColorEdit defaults to displaying RGB inputs if you don't specify a display mode, but the user can change it with a right-click.\n\nColorPicker defaults to displaying RGB+HSV+Hex if you don't specify a display mode.\n\nYou can change the defaults using SetColorEditOptions().");
        ImGui::Combo("Picker Mode", &picker_mode, "Auto/Current\0Hue bar + SV rect\0Hue wheel + SV triangle\0");
        ImGui::SameLine(); HelpMarker("User can right-click the picker to change mode.");
        ImGuiColorEditFlags flags = misc_flags;
        if (!alpha)            flags |= ImGuiColorEditFlags_NoAlpha;        // This is by default if you call ColorPicker3() instead of ColorPicker4()
        if (alpha_bar)         flags |= ImGuiColorEditFlags_AlphaBar;
        if (!side_preview)     flags |= ImGuiColorEditFlags_NoSidePreview;
        if (picker_mode == 1)  flags |= ImGuiColorEditFlags_PickerHueBar;
        if (picker_mode == 2)  flags |= ImGuiColorEditFlags_PickerHueWheel;
        if (display_mode == 1) flags |= ImGuiColorEditFlags_NoInputs;       // Disable all RGB/HSV/Hex displays
        if (display_mode == 2) flags |= ImGuiColorEditFlags_DisplayRGB;     // Override display mode
        if (display_mode == 3) flags |= ImGuiColorEditFlags_DisplayHSV;
        if (display_mode == 4) flags |= ImGuiColorEditFlags_DisplayHex;
        ImGui::ColorPicker4("MyColor##4", (float*)&color, flags, ref_color ? &ref_color_v.x : NULL);

        ImGui::Text("Programmatically set defaults:");
        ImGui::SameLine(); HelpMarker("SetColorEditOptions() is designed to allow you to set boot-time default.\nWe don't have Push/Pop functions because you can force options on a per-widget basis if needed, and the user can change non-forced ones with the options menu.\nWe don't have a getter to avoid encouraging you to persistently save values that aren't forward-compatible.");
        if (ImGui::Button("Default: Uint8 + HSV + Hue Bar"))
            ImGui::SetColorEditOptions(ImGuiColorEditFlags_Uint8 | ImGuiColorEditFlags_DisplayHSV | ImGuiColorEditFlags_PickerHueBar);
        if (ImGui::Button("Default: Float + HDR + Hue Wheel"))
            ImGui::SetColorEditOptions(ImGuiColorEditFlags_Float | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_PickerHueWheel);

        // HSV encoded support (to avoid RGB<>HSV round trips and singularities when S==0 or V==0)
        static ImVec4 color_stored_as_hsv(0.23f, 1.0f, 1.0f, 1.0f);
        ImGui::Spacing();
        ImGui::Text("HSV encoded colors");
        ImGui::SameLine(); HelpMarker("By default, colors are given to ColorEdit and ColorPicker in RGB, but ImGuiColorEditFlags_InputHSV allows you to store colors as HSV and pass them to ColorEdit and ColorPicker as HSV. This comes with the added benefit that you can manipulate hue values with the picker even when saturation or value are zero.");
        ImGui::Text("Color widget with InputHSV:");
        ImGui::ColorEdit4("HSV shown as HSV##1", (float*)&color_stored_as_hsv, ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_InputHSV | ImGuiColorEditFlags_Float);
        ImGui::ColorEdit4("HSV shown as RGB##1", (float*)&color_stored_as_hsv, ImGuiColorEditFlags_DisplayHSV | ImGuiColorEditFlags_InputHSV | ImGuiColorEditFlags_Float);
        ImGui::DragFloat4("Raw HSV values", (float*)&color_stored_as_hsv, 0.01f, 0.0f, 1.0f);

        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Range Widgets"))
    {
        static float begin = 10, end = 90;
        static int begin_i = 100, end_i = 1000;
        ImGui::DragFloatRange2("range", &begin, &end, 0.25f, 0.0f, 100.0f, "Min: %.1f %%", "Max: %.1f %%");
        ImGui::DragIntRange2("range int (no bounds)", &begin_i, &end_i, 5, 0, 0, "Min: %d units", "Max: %d units");
        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Data Types"))
    {
        // The DragScalar/InputScalar/SliderScalar functions allow various data types: signed/unsigned int/long long and float/double
        // To avoid polluting the public API with all possible combinations, we use the ImGuiDataType enum to pass the type,
        // and passing all arguments by address.
        // This is the reason the test code below creates local variables to hold "zero" "one" etc. for each types.
        // In practice, if you frequently use a given type that is not covered by the normal API entry points, you can wrap it
        // yourself inside a 1 line function which can take typed argument as value instead of void*, and then pass their address
        // to the generic function. For example:
        //   bool MySliderU64(const char *label, u64* value, u64 min = 0, u64 max = 0, const char* format = "%lld")
        //   {
        //      return SliderScalar(label, ImGuiDataType_U64, value, &min, &max, format);
        //   }

        // Limits (as helper variables that we can take the address of)
        // Note that the SliderScalar function has a maximum usable range of half the natural type maximum, hence the /2 below.
        #ifndef LLONG_MIN
        ImS64 LLONG_MIN = -9223372036854775807LL - 1;
        ImS64 LLONG_MAX = 9223372036854775807LL;
        ImU64 ULLONG_MAX = (2ULL * 9223372036854775807LL + 1);
        #endif
        const char    s8_zero  = 0,   s8_one  = 1,   s8_fifty  = 50, s8_min  = -128,        s8_max = 127;
        const ImU8    u8_zero  = 0,   u8_one  = 1,   u8_fifty  = 50, u8_min  = 0,           u8_max = 255;
        const short   s16_zero = 0,   s16_one = 1,   s16_fifty = 50, s16_min = -32768,      s16_max = 32767;
        const ImU16   u16_zero = 0,   u16_one = 1,   u16_fifty = 50, u16_min = 0,           u16_max = 65535;
        const ImS32   s32_zero = 0,   s32_one = 1,   s32_fifty = 50, s32_min = INT_MIN/2,   s32_max = INT_MAX/2,    s32_hi_a = INT_MAX/2 - 100,    s32_hi_b = INT_MAX/2;
        const ImU32   u32_zero = 0,   u32_one = 1,   u32_fifty = 50, u32_min = 0,           u32_max = UINT_MAX/2,   u32_hi_a = UINT_MAX/2 - 100,   u32_hi_b = UINT_MAX/2;
        const ImS64   s64_zero = 0,   s64_one = 1,   s64_fifty = 50, s64_min = LLONG_MIN/2, s64_max = LLONG_MAX/2,  s64_hi_a = LLONG_MAX/2 - 100,  s64_hi_b = LLONG_MAX/2;
        const ImU64   u64_zero = 0,   u64_one = 1,   u64_fifty = 50, u64_min = 0,           u64_max = ULLONG_MAX/2, u64_hi_a = ULLONG_MAX/2 - 100, u64_hi_b = ULLONG_MAX/2;
        const float   f32_zero = 0.f, f32_one = 1.f, f32_lo_a = -10000000000.0f, f32_hi_a = +10000000000.0f;
        const double  f64_zero = 0.,  f64_one = 1.,  f64_lo_a = -1000000000000000.0, f64_hi_a = +1000000000000000.0;

        // State
        static char   s8_v  = 127;
        static ImU8   u8_v  = 255;
        static short  s16_v = 32767;
        static ImU16  u16_v = 65535;
        static ImS32  s32_v = -1;
        static ImU32  u32_v = (ImU32)-1;
        static ImS64  s64_v = -1;
        static ImU64  u64_v = (ImU64)-1;
        static float  f32_v = 0.123f;
        static double f64_v = 90000.01234567890123456789;

        const float drag_speed = 0.2f;
        static bool drag_clamp = false;
        ImGui::Text("Drags:");
        ImGui::Checkbox("Clamp integers to 0..50", &drag_clamp); ImGui::SameLine(); HelpMarker("As with every widgets in dear imgui, we never modify values unless there is a user interaction.\nYou can override the clamping limits by using CTRL+Click to input a value.");
        ImGui::DragScalar("drag s8",        ImGuiDataType_S8,     &s8_v,  drag_speed, drag_clamp ? &s8_zero  : NULL, drag_clamp ? &s8_fifty  : NULL);
        ImGui::DragScalar("drag u8",        ImGuiDataType_U8,     &u8_v,  drag_speed, drag_clamp ? &u8_zero  : NULL, drag_clamp ? &u8_fifty  : NULL, "%u ms");
        ImGui::DragScalar("drag s16",       ImGuiDataType_S16,    &s16_v, drag_speed, drag_clamp ? &s16_zero : NULL, drag_clamp ? &s16_fifty : NULL);
        ImGui::DragScalar("drag u16",       ImGuiDataType_U16,    &u16_v, drag_speed, drag_clamp ? &u16_zero : NULL, drag_clamp ? &u16_fifty : NULL, "%u ms");
        ImGui::DragScalar("drag s32",       ImGuiDataType_S32,    &s32_v, drag_speed, drag_clamp ? &s32_zero : NULL, drag_clamp ? &s32_fifty : NULL);
        ImGui::DragScalar("drag u32",       ImGuiDataType_U32,    &u32_v, drag_speed, drag_clamp ? &u32_zero : NULL, drag_clamp ? &u32_fifty : NULL, "%u ms");
        ImGui::DragScalar("drag s64",       ImGuiDataType_S64,    &s64_v, drag_speed, drag_clamp ? &s64_zero : NULL, drag_clamp ? &s64_fifty : NULL);
        ImGui::DragScalar("drag u64",       ImGuiDataType_U64,    &u64_v, drag_speed, drag_clamp ? &u64_zero : NULL, drag_clamp ? &u64_fifty : NULL);
        ImGui::DragScalar("drag float",     ImGuiDataType_Float,  &f32_v, 0.005f,  &f32_zero, &f32_one, "%f", 1.0f);
        ImGui::DragScalar("drag float ^2",  ImGuiDataType_Float,  &f32_v, 0.005f,  &f32_zero, &f32_one, "%f", 2.0f); ImGui::SameLine(); HelpMarker("You can use the 'power' parameter to increase tweaking precision on one side of the range.");
        ImGui::DragScalar("drag double",    ImGuiDataType_Double, &f64_v, 0.0005f, &f64_zero, NULL,     "%.10f grams", 1.0f);
        ImGui::DragScalar("drag double ^2", ImGuiDataType_Double, &f64_v, 0.0005f, &f64_zero, &f64_one, "0 < %.10f < 1", 2.0f);

        ImGui::Text("Sliders");
        ImGui::SliderScalar("slider s8 full",     ImGuiDataType_S8,     &s8_v,  &s8_min,   &s8_max,   "%d");
        ImGui::SliderScalar("slider u8 full",     ImGuiDataType_U8,     &u8_v,  &u8_min,   &u8_max,   "%u");
        ImGui::SliderScalar("slider s16 full",    ImGuiDataType_S16,    &s16_v, &s16_min,  &s16_max,  "%d");
        ImGui::SliderScalar("slider u16 full",    ImGuiDataType_U16,    &u16_v, &u16_min,  &u16_max,  "%u");
        ImGui::SliderScalar("slider s32 low",     ImGuiDataType_S32,    &s32_v, &s32_zero, &s32_fifty,"%d");
        ImGui::SliderScalar("slider s32 high",    ImGuiDataType_S32,    &s32_v, &s32_hi_a, &s32_hi_b, "%d");
        ImGui::SliderScalar("slider s32 full",    ImGuiDataType_S32,    &s32_v, &s32_min,  &s32_max,  "%d");
        ImGui::SliderScalar("slider u32 low",     ImGuiDataType_U32,    &u32_v, &u32_zero, &u32_fifty,"%u");
        ImGui::SliderScalar("slider u32 high",    ImGuiDataType_U32,    &u32_v, &u32_hi_a, &u32_hi_b, "%u");
        ImGui::SliderScalar("slider u32 full",    ImGuiDataType_U32,    &u32_v, &u32_min,  &u32_max,  "%u");
        ImGui::SliderScalar("slider s64 low",     ImGuiDataType_S64,    &s64_v, &s64_zero, &s64_fifty,"%I64d");
        ImGui::SliderScalar("slider s64 high",    ImGuiDataType_S64,    &s64_v, &s64_hi_a, &s64_hi_b, "%I64d");
        ImGui::SliderScalar("slider s64 full",    ImGuiDataType_S64,    &s64_v, &s64_min,  &s64_max,  "%I64d");
        ImGui::SliderScalar("slider u64 low",     ImGuiDataType_U64,    &u64_v, &u64_zero, &u64_fifty,"%I64u ms");
        ImGui::SliderScalar("slider u64 high",    ImGuiDataType_U64,    &u64_v, &u64_hi_a, &u64_hi_b, "%I64u ms");
        ImGui::SliderScalar("slider u64 full",    ImGuiDataType_U64,    &u64_v, &u64_min,  &u64_max,  "%I64u ms");
        ImGui::SliderScalar("slider float low",   ImGuiDataType_Float,  &f32_v, &f32_zero, &f32_one);
        ImGui::SliderScalar("slider float low^2", ImGuiDataType_Float,  &f32_v, &f32_zero, &f32_one,  "%.10f", 2.0f);
        ImGui::SliderScalar("slider float high",  ImGuiDataType_Float,  &f32_v, &f32_lo_a, &f32_hi_a, "%e");
        ImGui::SliderScalar("slider double low",  ImGuiDataType_Double, &f64_v, &f64_zero, &f64_one,  "%.10f grams", 1.0f);
        ImGui::SliderScalar("slider double low^2",ImGuiDataType_Double, &f64_v, &f64_zero, &f64_one,  "%.10f", 2.0f);
        ImGui::SliderScalar("slider double high", ImGuiDataType_Double, &f64_v, &f64_lo_a, &f64_hi_a, "%e grams", 1.0f);

        static bool inputs_step = true;
        ImGui::Text("Inputs");
        ImGui::Checkbox("Show step buttons", &inputs_step);
        ImGui::InputScalar("input s8",      ImGuiDataType_S8,     &s8_v,  inputs_step ? &s8_one  : NULL, NULL, "%d");
        ImGui::InputScalar("input u8",      ImGuiDataType_U8,     &u8_v,  inputs_step ? &u8_one  : NULL, NULL, "%u");
        ImGui::InputScalar("input s16",     ImGuiDataType_S16,    &s16_v, inputs_step ? &s16_one : NULL, NULL, "%d");
        ImGui::InputScalar("input u16",     ImGuiDataType_U16,    &u16_v, inputs_step ? &u16_one : NULL, NULL, "%u");
        ImGui::InputScalar("input s32",     ImGuiDataType_S32,    &s32_v, inputs_step ? &s32_one : NULL, NULL, "%d");
        ImGui::InputScalar("input s32 hex", ImGuiDataType_S32,    &s32_v, inputs_step ? &s32_one : NULL, NULL, "%08X", ImGuiInputTextFlags_CharsHexadecimal);
        ImGui::InputScalar("input u32",     ImGuiDataType_U32,    &u32_v, inputs_step ? &u32_one : NULL, NULL, "%u");
        ImGui::InputScalar("input u32 hex", ImGuiDataType_U32,    &u32_v, inputs_step ? &u32_one : NULL, NULL, "%08X", ImGuiInputTextFlags_CharsHexadecimal);
        ImGui::InputScalar("input s64",     ImGuiDataType_S64,    &s64_v, inputs_step ? &s64_one : NULL);
        ImGui::InputScalar("input u64",     ImGuiDataType_U64,    &u64_v, inputs_step ? &u64_one : NULL);
        ImGui::InputScalar("input float",   ImGuiDataType_Float,  &f32_v, inputs_step ? &f32_one : NULL);
        ImGui::InputScalar("input double",  ImGuiDataType_Double, &f64_v, inputs_step ? &f64_one : NULL);

        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Multi-component Widgets"))
    {
        static float vec4f[4] = { 0.10f, 0.20f, 0.30f, 0.44f };
        static int vec4i[4] = { 1, 5, 100, 255 };

        ImGui::InputFloat2("input float2", vec4f);
        ImGui::DragFloat2("drag float2", vec4f, 0.01f, 0.0f, 1.0f);
        ImGui::SliderFloat2("slider float2", vec4f, 0.0f, 1.0f);
        ImGui::InputInt2("input int2", vec4i);
        ImGui::DragInt2("drag int2", vec4i, 1, 0, 255);
        ImGui::SliderInt2("slider int2", vec4i, 0, 255);
        ImGui::Spacing();

        ImGui::InputFloat3("input float3", vec4f);
        ImGui::DragFloat3("drag float3", vec4f, 0.01f, 0.0f, 1.0f);
        ImGui::SliderFloat3("slider float3", vec4f, 0.0f, 1.0f);
        ImGui::InputInt3("input int3", vec4i);
        ImGui::DragInt3("drag int3", vec4i, 1, 0, 255);
        ImGui::SliderInt3("slider int3", vec4i, 0, 255);
        ImGui::Spacing();

        ImGui::InputFloat4("input float4", vec4f);
        ImGui::DragFloat4("drag float4", vec4f, 0.01f, 0.0f, 1.0f);
        ImGui::SliderFloat4("slider float4", vec4f, 0.0f, 1.0f);
        ImGui::InputInt4("input int4", vec4i);
        ImGui::DragInt4("drag int4", vec4i, 1, 0, 255);
        ImGui::SliderInt4("slider int4", vec4i, 0, 255);

        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Vertical Sliders"))
    {
        const float spacing = 4;
        ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(spacing, spacing));

        static int int_value = 0;
        ImGui::VSliderInt("##int", ImVec2(18,160), &int_value, 0, 5);
        ImGui::SameLine();

        static float values[7] = { 0.0f, 0.60f, 0.35f, 0.9f, 0.70f, 0.20f, 0.0f };
        ImGui::PushID("set1");
        for (int i = 0; i < 7; i++)
        {
            if (i > 0) ImGui::SameLine();
            ImGui::PushID(i);
            ImGui::PushStyleColor(ImGuiCol_FrameBg, (ImVec4)ImColor::HSV(i/7.0f, 0.5f, 0.5f));
            ImGui::PushStyleColor(ImGuiCol_FrameBgHovered, (ImVec4)ImColor::HSV(i/7.0f, 0.6f, 0.5f));
            ImGui::PushStyleColor(ImGuiCol_FrameBgActive, (ImVec4)ImColor::HSV(i/7.0f, 0.7f, 0.5f));
            ImGui::PushStyleColor(ImGuiCol_SliderGrab, (ImVec4)ImColor::HSV(i/7.0f, 0.9f, 0.9f));
            ImGui::VSliderFloat("##v", ImVec2(18,160), &values[i], 0.0f, 1.0f, "");
            if (ImGui::IsItemActive() || ImGui::IsItemHovered())
                ImGui::SetTooltip("%.3f", values[i]);
            ImGui::PopStyleColor(4);
            ImGui::PopID();
        }
        ImGui::PopID();

        ImGui::SameLine();
        ImGui::PushID("set2");
        static float values2[4] = { 0.20f, 0.80f, 0.40f, 0.25f };
        const int rows = 3;
        const ImVec2 small_slider_size(18, (160.0f-(rows-1)*spacing)/rows);
        for (int nx = 0; nx < 4; nx++)
        {
            if (nx > 0) ImGui::SameLine();
            ImGui::BeginGroup();
            for (int ny = 0; ny < rows; ny++)
            {
                ImGui::PushID(nx*rows+ny);
                ImGui::VSliderFloat("##v", small_slider_size, &values2[nx], 0.0f, 1.0f, "");
                if (ImGui::IsItemActive() || ImGui::IsItemHovered())
                    ImGui::SetTooltip("%.3f", values2[nx]);
                ImGui::PopID();
            }
            ImGui::EndGroup();
        }
        ImGui::PopID();

        ImGui::SameLine();
        ImGui::PushID("set3");
        for (int i = 0; i < 4; i++)
        {
            if (i > 0) ImGui::SameLine();
            ImGui::PushID(i);
            ImGui::PushStyleVar(ImGuiStyleVar_GrabMinSize, 40);
            ImGui::VSliderFloat("##v", ImVec2(40,160), &values[i], 0.0f, 1.0f, "%.2f\nsec");
            ImGui::PopStyleVar();
            ImGui::PopID();
        }
        ImGui::PopID();
        ImGui::PopStyleVar();
        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Drag and Drop"))
    {
        {
            // ColorEdit widgets automatically act as drag source and drag target.
            // They are using standardized payload strings IMGUI_PAYLOAD_TYPE_COLOR_3F and IMGUI_PAYLOAD_TYPE_COLOR_4F to allow your own widgets
            // to use colors in their drag and drop interaction. Also see the demo in Color Picker -> Palette demo.
            ImGui::BulletText("Drag and drop in standard widgets");
            ImGui::Indent();
            static float col1[3] = { 1.0f,0.0f,0.2f };
            static float col2[4] = { 0.4f,0.7f,0.0f,0.5f };
            ImGui::ColorEdit3("color 1", col1);
            ImGui::ColorEdit4("color 2", col2);
            ImGui::Unindent();
        }

        {
            ImGui::BulletText("Drag and drop to copy/swap items");
            ImGui::Indent();
            enum Mode
            {
                Mode_Copy,
                Mode_Move,
                Mode_Swap
            };
            static int mode = 0;
            if (ImGui::RadioButton("Copy", mode == Mode_Copy)) { mode = Mode_Copy; } ImGui::SameLine();
            if (ImGui::RadioButton("Move", mode == Mode_Move)) { mode = Mode_Move; } ImGui::SameLine();
            if (ImGui::RadioButton("Swap", mode == Mode_Swap)) { mode = Mode_Swap; }
            static const char* names[9] = { "Bobby", "Beatrice", "Betty", "Brianna", "Barry", "Bernard", "Bibi", "Blaine", "Bryn" };
            for (int n = 0; n < IM_ARRAYSIZE(names); n++)
            {
                ImGui::PushID(n);
                if ((n % 3) != 0)
                    ImGui::SameLine();
                ImGui::Button(names[n], ImVec2(60,60));

                // Our buttons are both drag sources and drag targets here!
                if (ImGui::BeginDragDropSource(ImGuiDragDropFlags_None))
                {
                    ImGui::SetDragDropPayload("DND_DEMO_CELL", &n, sizeof(int));        // Set payload to carry the index of our item (could be anything)
                    if (mode == Mode_Copy) { ImGui::Text("Copy %s", names[n]); }        // Display preview (could be anything, e.g. when dragging an image we could decide to display the filename and a small preview of the image, etc.)
                    if (mode == Mode_Move) { ImGui::Text("Move %s", names[n]); }
                    if (mode == Mode_Swap) { ImGui::Text("Swap %s", names[n]); }
                    ImGui::EndDragDropSource();
                }
                if (ImGui::BeginDragDropTarget())
                {
                    if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("DND_DEMO_CELL"))
                    {
                        IM_ASSERT(payload->DataSize == sizeof(int));
                        int payload_n = *(const int*)payload->Data;
                        if (mode == Mode_Copy)
                        {
                            names[n] = names[payload_n];
                        }
                        if (mode == Mode_Move)
                        {
                            names[n] = names[payload_n];
                            names[payload_n] = "";
                        }
                        if (mode == Mode_Swap)
                        {
                            const char* tmp = names[n];
                            names[n] = names[payload_n];
                            names[payload_n] = tmp;
                        }
                    }
                    ImGui::EndDragDropTarget();
                }
                ImGui::PopID();
            }
            ImGui::Unindent();
        }

        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Querying Status (Active/Focused/Hovered etc.)"))
    {
        // Display the value of IsItemHovered() and other common item state functions. Note that the flags can be combined.
        // (because BulletText is an item itself and that would affect the output of IsItemHovered() we pass all state in a single call to simplify the code).
        static int item_type = 1;
        static bool b = false;
        static float col4f[4] = { 1.0f, 0.5, 0.0f, 1.0f };
        static char str[16] = {};
        ImGui::RadioButton("Text", &item_type, 0);
        ImGui::RadioButton("Button", &item_type, 1);
        ImGui::RadioButton("Checkbox", &item_type, 2);
        ImGui::RadioButton("SliderFloat", &item_type, 3);
        ImGui::RadioButton("InputText", &item_type, 4);
        ImGui::RadioButton("ColorEdit4", &item_type, 5);
        ImGui::RadioButton("MenuItem", &item_type, 6);
        ImGui::RadioButton("TreeNode (w/ double-click)", &item_type, 7);
        ImGui::RadioButton("ListBox", &item_type, 8);
        ImGui::Separator();
        bool ret = false;
        if (item_type == 0) { ImGui::Text("ITEM: Text"); }                                              // Testing text items with no identifier/interaction
        if (item_type == 1) { ret = ImGui::Button("ITEM: Button"); }                                    // Testing button
        if (item_type == 2) { ret = ImGui::Checkbox("ITEM: Checkbox", &b); }                            // Testing checkbox
        if (item_type == 3) { ret = ImGui::SliderFloat("ITEM: SliderFloat", &col4f[0], 0.0f, 1.0f); }   // Testing basic item
        if (item_type == 4) { ret = ImGui::InputText("ITEM: InputText", &str[0], IM_ARRAYSIZE(str)); }  // Testing input text (which handles tabbing)
        if (item_type == 5) { ret = ImGui::ColorEdit4("ITEM: ColorEdit4", col4f); }                     // Testing multi-component items (IsItemXXX flags are reported merged)
        if (item_type == 6) { ret = ImGui::MenuItem("ITEM: MenuItem"); }                                // Testing menu item (they use ImGuiButtonFlags_PressedOnRelease button policy)
        if (item_type == 7) { ret = ImGui::TreeNodeEx("ITEM: TreeNode w/ ImGuiTreeNodeFlags_OpenOnDoubleClick", ImGuiTreeNodeFlags_OpenOnDoubleClick | ImGuiTreeNodeFlags_NoTreePushOnOpen); } // Testing tree node with ImGuiButtonFlags_PressedOnDoubleClick button policy.
        if (item_type == 8) { const char* items[] = { "Apple", "Banana", "Cherry", "Kiwi" }; static int current = 1; ret = ImGui::ListBox("ITEM: ListBox", &current, items, IM_ARRAYSIZE(items), IM_ARRAYSIZE(items)); }
        ImGui::BulletText(
            "Return value = %d\n"
            "IsItemFocused() = %d\n"
            "IsItemHovered() = %d\n"
            "IsItemHovered(_AllowWhenBlockedByPopup) = %d\n"
            "IsItemHovered(_AllowWhenBlockedByActiveItem) = %d\n"
            "IsItemHovered(_AllowWhenOverlapped) = %d\n"
            "IsItemHovered(_RectOnly) = %d\n"
            "IsItemActive() = %d\n"
            "IsItemEdited() = %d\n"
            "IsItemActivated() = %d\n"
            "IsItemDeactivated() = %d\n"
            "IsItemDeactivatedAfterEdit() = %d\n"
            "IsItemVisible() = %d\n"
            "IsItemClicked() = %d\n"
            "GetItemRectMin() = (%.1f, %.1f)\n"
            "GetItemRectMax() = (%.1f, %.1f)\n"
            "GetItemRectSize() = (%.1f, %.1f)",
            ret,
            ImGui::IsItemFocused(),
            ImGui::IsItemHovered(),
            ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup),
            ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem),
            ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenOverlapped),
            ImGui::IsItemHovered(ImGuiHoveredFlags_RectOnly),
            ImGui::IsItemActive(),
            ImGui::IsItemEdited(),
            ImGui::IsItemActivated(),
            ImGui::IsItemDeactivated(),
            ImGui::IsItemDeactivatedAfterEdit(),
            ImGui::IsItemVisible(),
            ImGui::IsItemClicked(),
            ImGui::GetItemRectMin().x, ImGui::GetItemRectMin().y,
            ImGui::GetItemRectMax().x, ImGui::GetItemRectMax().y,
            ImGui::GetItemRectSize().x, ImGui::GetItemRectSize().y
        );

        static bool embed_all_inside_a_child_window = false;
        ImGui::Checkbox("Embed everything inside a child window (for additional testing)", &embed_all_inside_a_child_window);
        if (embed_all_inside_a_child_window)
            ImGui::BeginChild("outer_child", ImVec2(0, ImGui::GetFontSize() * 20), true);

        // Testing IsWindowFocused() function with its various flags. Note that the flags can be combined.
        ImGui::BulletText(
            "IsWindowFocused() = %d\n"
            "IsWindowFocused(_ChildWindows) = %d\n"
            "IsWindowFocused(_ChildWindows|_RootWindow) = %d\n"
            "IsWindowFocused(_RootWindow) = %d\n"
            "IsWindowFocused(_AnyWindow) = %d\n",
            ImGui::IsWindowFocused(),
            ImGui::IsWindowFocused(ImGuiFocusedFlags_ChildWindows),
            ImGui::IsWindowFocused(ImGuiFocusedFlags_ChildWindows | ImGuiFocusedFlags_RootWindow),
            ImGui::IsWindowFocused(ImGuiFocusedFlags_RootWindow),
            ImGui::IsWindowFocused(ImGuiFocusedFlags_AnyWindow));

        // Testing IsWindowHovered() function with its various flags. Note that the flags can be combined.
        ImGui::BulletText(
            "IsWindowHovered() = %d\n"
            "IsWindowHovered(_AllowWhenBlockedByPopup) = %d\n"
            "IsWindowHovered(_AllowWhenBlockedByActiveItem) = %d\n"
            "IsWindowHovered(_ChildWindows) = %d\n"
            "IsWindowHovered(_ChildWindows|_RootWindow) = %d\n"
            "IsWindowHovered(_ChildWindows|_AllowWhenBlockedByPopup) = %d\n"
            "IsWindowHovered(_RootWindow) = %d\n"
            "IsWindowHovered(_AnyWindow) = %d\n",
            ImGui::IsWindowHovered(),
            ImGui::IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup),
            ImGui::IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem),
            ImGui::IsWindowHovered(ImGuiHoveredFlags_ChildWindows),
            ImGui::IsWindowHovered(ImGuiHoveredFlags_ChildWindows | ImGuiHoveredFlags_RootWindow),
            ImGui::IsWindowHovered(ImGuiHoveredFlags_ChildWindows | ImGuiHoveredFlags_AllowWhenBlockedByPopup),
            ImGui::IsWindowHovered(ImGuiHoveredFlags_RootWindow),
            ImGui::IsWindowHovered(ImGuiHoveredFlags_AnyWindow));

        ImGui::BeginChild("child", ImVec2(0, 50), true);
        ImGui::Text("This is another child window for testing the _ChildWindows flag.");
        ImGui::EndChild();
        if (embed_all_inside_a_child_window)
            ImGui::EndChild();

        // Calling IsItemHovered() after begin returns the hovered status of the title bar.
        // This is useful in particular if you want to create a context menu (with BeginPopupContextItem) associated to the title bar of a window.
        static bool test_window = false;
        ImGui::Checkbox("Hovered/Active tests after Begin() for title bar testing", &test_window);
        if (test_window)
        {
            ImGui::Begin("Title bar Hovered/Active tests", &test_window);
            if (ImGui::BeginPopupContextItem()) // <-- This is using IsItemHovered()
            {
                if (ImGui::MenuItem("Close")) { test_window = false; }
                ImGui::EndPopup();
            }
            ImGui::Text(
                "IsItemHovered() after begin = %d (== is title bar hovered)\n"
                "IsItemActive() after begin = %d (== is window being clicked/moved)\n",
                ImGui::IsItemHovered(), ImGui::IsItemActive());
            ImGui::End();
        }

        ImGui::TreePop();
    }
}

static void ShowDemoWindowLayout()
{
    if (!ImGui::CollapsingHeader("Layout"))
        return;

    if (ImGui::TreeNode("Child windows"))
    {
        HelpMarker("Use child windows to begin into a self-contained independent scrolling/clipping regions within a host window.");
        static bool disable_mouse_wheel = false;
        static bool disable_menu = false;
        ImGui::Checkbox("Disable Mouse Wheel", &disable_mouse_wheel);
        ImGui::Checkbox("Disable Menu", &disable_menu);

        static int line = 50;
        bool goto_line = ImGui::Button("Goto");
        ImGui::SameLine();
        ImGui::SetNextItemWidth(100);
        goto_line |= ImGui::InputInt("##Line", &line, 0, 0, ImGuiInputTextFlags_EnterReturnsTrue);

        // Child 1: no border, enable horizontal scrollbar
        {
            ImGuiWindowFlags window_flags = ImGuiWindowFlags_HorizontalScrollbar | (disable_mouse_wheel ? ImGuiWindowFlags_NoScrollWithMouse : 0);
            ImGui::BeginChild("Child1", ImVec2(ImGui::GetWindowContentRegionWidth() * 0.5f, 260), false, window_flags);
            for (int i = 0; i < 100; i++)
            {
                ImGui::Text("%04d: scrollable region", i);
                if (goto_line && line == i)
                    ImGui::SetScrollHereY();
            }
            if (goto_line && line >= 100)
                ImGui::SetScrollHereY();
            ImGui::EndChild();
        }

        ImGui::SameLine();

        // Child 2: rounded border
        {
            ImGuiWindowFlags window_flags = (disable_mouse_wheel ? ImGuiWindowFlags_NoScrollWithMouse : 0) | (disable_menu ? 0 : ImGuiWindowFlags_MenuBar);
            ImGui::PushStyleVar(ImGuiStyleVar_ChildRounding, 5.0f);
            ImGui::BeginChild("Child2", ImVec2(0, 260), true, window_flags);
            if (!disable_menu && ImGui::BeginMenuBar())
            {
                if (ImGui::BeginMenu("Menu"))
                {
                    ShowExampleMenuFile();
                    ImGui::EndMenu();
                }
                ImGui::EndMenuBar();
            }
            ImGui::Columns(2);
            for (int i = 0; i < 100; i++)
            {
                char buf[32];
                sprintf(buf, "%03d", i);
                ImGui::Button(buf, ImVec2(-1.0f, 0.0f));
                ImGui::NextColumn();
            }
            ImGui::EndChild();
            ImGui::PopStyleVar();
        }

        ImGui::Separator();

        // Demonstrate a few extra things
        // - Changing ImGuiCol_ChildBg (which is transparent black in default styles)
        // - Using SetCursorPos() to position the child window (because the child window is an item from the POV of the parent window)
        //   You can also call SetNextWindowPos() to position the child window. The parent window will effectively layout from this position.
        // - Using ImGui::GetItemRectMin/Max() to query the "item" state (because the child window is an item from the POV of the parent window)
        //   See "Widgets" -> "Querying Status (Active/Focused/Hovered etc.)" section for more details about this.
        {
            ImGui::SetCursorPosX(50);
            ImGui::PushStyleColor(ImGuiCol_ChildBg, IM_COL32(255, 0, 0, 100));
            ImGui::BeginChild("blah", ImVec2(200, 100), true, ImGuiWindowFlags_None);
            for (int n = 0; n < 50; n++)
                ImGui::Text("Some test %d", n);
            ImGui::EndChild();
            ImVec2 child_rect_min = ImGui::GetItemRectMin();
            ImVec2 child_rect_max = ImGui::GetItemRectMax();
            ImGui::PopStyleColor();
            ImGui::Text("Rect of child window is: (%.0f,%.0f) (%.0f,%.0f)", child_rect_min.x, child_rect_min.y, child_rect_max.x, child_rect_max.y);
        }

        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Widgets Width"))
    {
        // Use SetNextItemWidth() to set the width of a single upcoming item.
        // Use PushItemWidth()/PopItemWidth() to set the width of a group of items.
        static float f = 0.0f;
        ImGui::Text("SetNextItemWidth/PushItemWidth(100)");
        ImGui::SameLine(); HelpMarker("Fixed width.");
        ImGui::SetNextItemWidth(100);
        ImGui::DragFloat("float##1", &f);

        ImGui::Text("SetNextItemWidth/PushItemWidth(GetWindowWidth() * 0.5f)");
        ImGui::SameLine(); HelpMarker("Half of window width.");
        ImGui::SetNextItemWidth(ImGui::GetWindowWidth() * 0.5f);
        ImGui::DragFloat("float##2", &f);

        ImGui::Text("SetNextItemWidth/PushItemWidth(GetContentRegionAvail().x * 0.5f)");
        ImGui::SameLine(); HelpMarker("Half of available width.\n(~ right-cursor_pos)\n(works within a column set)");
        ImGui::SetNextItemWidth(ImGui::GetContentRegionAvail().x * 0.5f);
        ImGui::DragFloat("float##3", &f);

        ImGui::Text("SetNextItemWidth/PushItemWidth(-100)");
        ImGui::SameLine(); HelpMarker("Align to right edge minus 100");
        ImGui::SetNextItemWidth(-100);
        ImGui::DragFloat("float##4", &f);

        // Demonstrate using PushItemWidth to surround three items. Calling SetNextItemWidth() before each of them would have the same effect.
        ImGui::Text("SetNextItemWidth/PushItemWidth(-1)");
        ImGui::SameLine(); HelpMarker("Align to right edge");
        ImGui::PushItemWidth(-1);
        ImGui::DragFloat("float##5a", &f);
        ImGui::DragFloat("float##5b", &f);
        ImGui::DragFloat("float##5c", &f);
        ImGui::PopItemWidth();

        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Basic Horizontal Layout"))
    {
        ImGui::TextWrapped("(Use ImGui::SameLine() to keep adding items to the right of the preceding item)");

        // Text
        ImGui::Text("Two items: Hello"); ImGui::SameLine();
        ImGui::TextColored(ImVec4(1,1,0,1), "Sailor");

        // Adjust spacing
        ImGui::Text("More spacing: Hello"); ImGui::SameLine(0, 20);
        ImGui::TextColored(ImVec4(1,1,0,1), "Sailor");

        // Button
        ImGui::AlignTextToFramePadding();
        ImGui::Text("Normal buttons"); ImGui::SameLine();
        ImGui::Button("Banana"); ImGui::SameLine();
        ImGui::Button("Apple"); ImGui::SameLine();
        ImGui::Button("Corniflower");

        // Button
        ImGui::Text("Small buttons"); ImGui::SameLine();
        ImGui::SmallButton("Like this one"); ImGui::SameLine();
        ImGui::Text("can fit within a text block.");

        // Aligned to arbitrary position. Easy/cheap column.
        ImGui::Text("Aligned");
        ImGui::SameLine(150); ImGui::Text("x=150");
        ImGui::SameLine(300); ImGui::Text("x=300");
        ImGui::Text("Aligned");
        ImGui::SameLine(150); ImGui::SmallButton("x=150");
        ImGui::SameLine(300); ImGui::SmallButton("x=300");

        // Checkbox
        static bool c1 = false, c2 = false, c3 = false, c4 = false;
        ImGui::Checkbox("My", &c1); ImGui::SameLine();
        ImGui::Checkbox("Tailor", &c2); ImGui::SameLine();
        ImGui::Checkbox("Is", &c3); ImGui::SameLine();
        ImGui::Checkbox("Rich", &c4);

        // Various
        static float f0 = 1.0f, f1 = 2.0f, f2 = 3.0f;
        ImGui::PushItemWidth(80);
        const char* items[] = { "AAAA", "BBBB", "CCCC", "DDDD" };
        static int item = -1;
        ImGui::Combo("Combo", &item, items, IM_ARRAYSIZE(items)); ImGui::SameLine();
        ImGui::SliderFloat("X", &f0, 0.0f, 5.0f); ImGui::SameLine();
        ImGui::SliderFloat("Y", &f1, 0.0f, 5.0f); ImGui::SameLine();
        ImGui::SliderFloat("Z", &f2, 0.0f, 5.0f);
        ImGui::PopItemWidth();

        ImGui::PushItemWidth(80);
        ImGui::Text("Lists:");
        static int selection[4] = { 0, 1, 2, 3 };
        for (int i = 0; i < 4; i++)
        {
            if (i > 0) ImGui::SameLine();
            ImGui::PushID(i);
            ImGui::ListBox("", &selection[i], items, IM_ARRAYSIZE(items));
            ImGui::PopID();
            //if (ImGui::IsItemHovered()) ImGui::SetTooltip("ListBox %d hovered", i);
        }
        ImGui::PopItemWidth();

        // Dummy
        ImVec2 button_sz(40, 40);
        ImGui::Button("A", button_sz); ImGui::SameLine();
        ImGui::Dummy(button_sz); ImGui::SameLine();
        ImGui::Button("B", button_sz);

        // Manually wrapping (we should eventually provide this as an automatic layout feature, but for now you can do it manually)
        ImGui::Text("Manually wrapping:");
        ImGuiStyle& style = ImGui::GetStyle();
        int buttons_count = 20;
        float window_visible_x2 = ImGui::GetWindowPos().x + ImGui::GetWindowContentRegionMax().x;
        for (int n = 0; n < buttons_count; n++)
        {
            ImGui::PushID(n);
            ImGui::Button("Box", button_sz);
            float last_button_x2 = ImGui::GetItemRectMax().x;
            float next_button_x2 = last_button_x2 + style.ItemSpacing.x + button_sz.x; // Expected position if next button was on same line
            if (n + 1 < buttons_count && next_button_x2 < window_visible_x2)
                ImGui::SameLine();
            ImGui::PopID();
        }

        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Tabs"))
    {
        if (ImGui::TreeNode("Basic"))
        {
            ImGuiTabBarFlags tab_bar_flags = ImGuiTabBarFlags_None;
            if (ImGui::BeginTabBar("MyTabBar", tab_bar_flags))
            {
                if (ImGui::BeginTabItem("Avocado"))
                {
                    ImGui::Text("This is the Avocado tab!\nblah blah blah blah blah");
                    ImGui::EndTabItem();
                }
                if (ImGui::BeginTabItem("Broccoli"))
                {
                    ImGui::Text("This is the Broccoli tab!\nblah blah blah blah blah");
                    ImGui::EndTabItem();
                }
                if (ImGui::BeginTabItem("Cucumber"))
                {
                    ImGui::Text("This is the Cucumber tab!\nblah blah blah blah blah");
                    ImGui::EndTabItem();
                }
                ImGui::EndTabBar();
            }
            ImGui::Separator();
            ImGui::TreePop();
        }

        if (ImGui::TreeNode("Advanced & Close Button"))
        {
            // Expose a couple of the available flags. In most cases you may just call BeginTabBar() with no flags (0).
            static ImGuiTabBarFlags tab_bar_flags = ImGuiTabBarFlags_Reorderable;
            ImGui::CheckboxFlags("ImGuiTabBarFlags_Reorderable", (unsigned int*)&tab_bar_flags, ImGuiTabBarFlags_Reorderable);
            ImGui::CheckboxFlags("ImGuiTabBarFlags_AutoSelectNewTabs", (unsigned int*)&tab_bar_flags, ImGuiTabBarFlags_AutoSelectNewTabs);
            ImGui::CheckboxFlags("ImGuiTabBarFlags_TabListPopupButton", (unsigned int*)&tab_bar_flags, ImGuiTabBarFlags_TabListPopupButton);
            ImGui::CheckboxFlags("ImGuiTabBarFlags_NoCloseWithMiddleMouseButton", (unsigned int*)&tab_bar_flags, ImGuiTabBarFlags_NoCloseWithMiddleMouseButton);
            if ((tab_bar_flags & ImGuiTabBarFlags_FittingPolicyMask_) == 0)
                tab_bar_flags |= ImGuiTabBarFlags_FittingPolicyDefault_;
            if (ImGui::CheckboxFlags("ImGuiTabBarFlags_FittingPolicyResizeDown", (unsigned int*)&tab_bar_flags, ImGuiTabBarFlags_FittingPolicyResizeDown))
                tab_bar_flags &= ~(ImGuiTabBarFlags_FittingPolicyMask_ ^ ImGuiTabBarFlags_FittingPolicyResizeDown);
            if (ImGui::CheckboxFlags("ImGuiTabBarFlags_FittingPolicyScroll", (unsigned int*)&tab_bar_flags, ImGuiTabBarFlags_FittingPolicyScroll))
                tab_bar_flags &= ~(ImGuiTabBarFlags_FittingPolicyMask_ ^ ImGuiTabBarFlags_FittingPolicyScroll);

            // Tab Bar
            const char* names[4] = { "Artichoke", "Beetroot", "Celery", "Daikon" };
            static bool opened[4] = { true, true, true, true }; // Persistent user state
            for (int n = 0; n < IM_ARRAYSIZE(opened); n++)
            {
                if (n > 0) { ImGui::SameLine(); }
                ImGui::Checkbox(names[n], &opened[n]);
            }

            // Passing a bool* to BeginTabItem() is similar to passing one to Begin(): the underlying bool will be set to false when the tab is closed.
            if (ImGui::BeginTabBar("MyTabBar", tab_bar_flags))
            {
                for (int n = 0; n < IM_ARRAYSIZE(opened); n++)
                    if (opened[n] && ImGui::BeginTabItem(names[n], &opened[n]))
                    {
                        ImGui::Text("This is the %s tab!", names[n]);
                        if (n & 1)
                            ImGui::Text("I am an odd tab.");
                        ImGui::EndTabItem();
                    }
                ImGui::EndTabBar();
            }
            ImGui::Separator();
            ImGui::TreePop();
        }
        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Groups"))
    {
        HelpMarker("Using ImGui::BeginGroup()/EndGroup() to layout items. BeginGroup() basically locks the horizontal position. EndGroup() bundles the whole group so that you can use functions such as IsItemHovered() on it.");
        ImGui::BeginGroup();
        {
            ImGui::BeginGroup();
            ImGui::Button("AAA");
            ImGui::SameLine();
            ImGui::Button("BBB");
            ImGui::SameLine();
            ImGui::BeginGroup();
            ImGui::Button("CCC");
            ImGui::Button("DDD");
            ImGui::EndGroup();
            ImGui::SameLine();
            ImGui::Button("EEE");
            ImGui::EndGroup();
            if (ImGui::IsItemHovered())
                ImGui::SetTooltip("First group hovered");
        }
        // Capture the group size and create widgets using the same size
        ImVec2 size = ImGui::GetItemRectSize();
        const float values[5] = { 0.5f, 0.20f, 0.80f, 0.60f, 0.25f };
        ImGui::PlotHistogram("##values", values, IM_ARRAYSIZE(values), 0, NULL, 0.0f, 1.0f, size);

        ImGui::Button("ACTION", ImVec2((size.x - ImGui::GetStyle().ItemSpacing.x)*0.5f, size.y));
        ImGui::SameLine();
        ImGui::Button("REACTION", ImVec2((size.x - ImGui::GetStyle().ItemSpacing.x)*0.5f, size.y));
        ImGui::EndGroup();
        ImGui::SameLine();

        ImGui::Button("LEVERAGE\nBUZZWORD", size);
        ImGui::SameLine();

        if (ImGui::ListBoxHeader("List", size))
        {
            ImGui::Selectable("Selected", true);
            ImGui::Selectable("Not Selected", false);
            ImGui::ListBoxFooter();
        }

        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Text Baseline Alignment"))
    {
        HelpMarker("This is testing the vertical alignment that gets applied on text to keep it aligned with widgets. Lines only composed of text or \"small\" widgets fit in less vertical spaces than lines with normal widgets.");

        ImGui::Text("One\nTwo\nThree"); ImGui::SameLine();
        ImGui::Text("Hello\nWorld"); ImGui::SameLine();
        ImGui::Text("Banana");

        ImGui::Text("Banana"); ImGui::SameLine();
        ImGui::Text("Hello\nWorld"); ImGui::SameLine();
        ImGui::Text("One\nTwo\nThree");

        ImGui::Button("HOP##1"); ImGui::SameLine();
        ImGui::Text("Banana"); ImGui::SameLine();
        ImGui::Text("Hello\nWorld"); ImGui::SameLine();
        ImGui::Text("Banana");

        ImGui::Button("HOP##2"); ImGui::SameLine();
        ImGui::Text("Hello\nWorld"); ImGui::SameLine();
        ImGui::Text("Banana");

        ImGui::Button("TEST##1"); ImGui::SameLine();
        ImGui::Text("TEST"); ImGui::SameLine();
        ImGui::SmallButton("TEST##2");

        ImGui::AlignTextToFramePadding(); // If your line starts with text, call this to align it to upcoming widgets.
        ImGui::Text("Text aligned to Widget"); ImGui::SameLine();
        ImGui::Button("Widget##1"); ImGui::SameLine();
        ImGui::Text("Widget"); ImGui::SameLine();
        ImGui::SmallButton("Widget##2"); ImGui::SameLine();
        ImGui::Button("Widget##3");

        // Tree
        const float spacing = ImGui::GetStyle().ItemInnerSpacing.x;
        ImGui::Button("Button##1");
        ImGui::SameLine(0.0f, spacing);
        if (ImGui::TreeNode("Node##1")) { for (int i = 0; i < 6; i++) ImGui::BulletText("Item %d..", i); ImGui::TreePop(); }    // Dummy tree data

        ImGui::AlignTextToFramePadding();         // Vertically align text node a bit lower so it'll be vertically centered with upcoming widget. Otherwise you can use SmallButton (smaller fit).
        bool node_open = ImGui::TreeNode("Node##2");  // Common mistake to avoid: if we want to SameLine after TreeNode we need to do it before we add child content.
        ImGui::SameLine(0.0f, spacing); ImGui::Button("Button##2");
        if (node_open) { for (int i = 0; i < 6; i++) ImGui::BulletText("Item %d..", i); ImGui::TreePop(); }   // Dummy tree data

        // Bullet
        ImGui::Button("Button##3");
        ImGui::SameLine(0.0f, spacing);
        ImGui::BulletText("Bullet text");

        ImGui::AlignTextToFramePadding();
        ImGui::BulletText("Node");
        ImGui::SameLine(0.0f, spacing); ImGui::Button("Button##4");

        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Scrolling"))
    {
        HelpMarker("Use SetScrollHereY() or SetScrollFromPosY() to scroll to a given position.");

        static bool track = true;
        static int track_line = 50, scroll_to_px = 200;
        ImGui::Checkbox("Track", &track);
        ImGui::PushItemWidth(100);
        ImGui::SameLine(130); track |= ImGui::DragInt("##line", &track_line, 0.25f, 0, 99, "Line = %d");
        bool scroll_to = ImGui::Button("Scroll To Pos");
        ImGui::SameLine(130); scroll_to |= ImGui::DragInt("##pos_y", &scroll_to_px, 1.00f, 0, 9999, "Y = %d px");
        ImGui::PopItemWidth();
        if (scroll_to) track = false;

        for (int i = 0; i < 5; i++)
        {
            if (i > 0) ImGui::SameLine();
            ImGui::BeginGroup();
            ImGui::Text("%s", i == 0 ? "Top" : i == 1 ? "25%" : i == 2 ? "Center" : i == 3 ? "75%" : "Bottom");
            ImGui::BeginChild(ImGui::GetID((void*)(intptr_t)i), ImVec2(ImGui::GetWindowWidth() * 0.17f, 200.0f), true);
            if (scroll_to)
                ImGui::SetScrollFromPosY(ImGui::GetCursorStartPos().y + scroll_to_px, i * 0.25f);
            for (int line = 0; line < 100; line++)
            {
                if (track && line == track_line)
                {
                    ImGui::TextColored(ImVec4(1,1,0,1), "Line %d", line);
                    ImGui::SetScrollHereY(i * 0.25f); // 0.0f:top, 0.5f:center, 1.0f:bottom
                }
                else
                {
                    ImGui::Text("Line %d", line);
                }
            }
            float scroll_y = ImGui::GetScrollY(), scroll_max_y = ImGui::GetScrollMaxY();
            ImGui::EndChild();
            ImGui::Text("%.0f/%0.f", scroll_y, scroll_max_y);
            ImGui::EndGroup();
        }
        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Horizontal Scrolling"))
    {
        HelpMarker("Horizontal scrolling for a window has to be enabled explicitly via the ImGuiWindowFlags_HorizontalScrollbar flag.\n\nYou may want to explicitly specify content width by calling SetNextWindowContentWidth() before Begin().");
        static int lines = 7;
        ImGui::SliderInt("Lines", &lines, 1, 15);
        ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 3.0f);
        ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(2.0f, 1.0f));
        ImGui::BeginChild("scrolling", ImVec2(0, ImGui::GetFrameHeightWithSpacing() * 7 + 30), true, ImGuiWindowFlags_HorizontalScrollbar);
        for (int line = 0; line < lines; line++)
        {
            // Display random stuff (for the sake of this trivial demo we are using basic Button+SameLine. If you want to create your own time line for a real application you may be better off
            // manipulating the cursor position yourself, aka using SetCursorPos/SetCursorScreenPos to position the widgets yourself. You may also want to use the lower-level ImDrawList API)
            int num_buttons = 10 + ((line & 1) ? line * 9 : line * 3);
            for (int n = 0; n < num_buttons; n++)
            {
                if (n > 0) ImGui::SameLine();
                ImGui::PushID(n + line * 1000);
                char num_buf[16];
                sprintf(num_buf, "%d", n);
                const char* label = (!(n%15)) ? "FizzBuzz" : (!(n%3)) ? "Fizz" : (!(n%5)) ? "Buzz" : num_buf;
                float hue = n*0.05f;
                ImGui::PushStyleColor(ImGuiCol_Button, (ImVec4)ImColor::HSV(hue, 0.6f, 0.6f));
                ImGui::PushStyleColor(ImGuiCol_ButtonHovered, (ImVec4)ImColor::HSV(hue, 0.7f, 0.7f));
                ImGui::PushStyleColor(ImGuiCol_ButtonActive, (ImVec4)ImColor::HSV(hue, 0.8f, 0.8f));
                ImGui::Button(label, ImVec2(40.0f + sinf((float)(line + n)) * 20.0f, 0.0f));
                ImGui::PopStyleColor(3);
                ImGui::PopID();
            }
        }
        float scroll_x = ImGui::GetScrollX();
        float scroll_max_x = ImGui::GetScrollMaxX();
        ImGui::EndChild();
        ImGui::PopStyleVar(2);
        float scroll_x_delta = 0.0f;
        ImGui::SmallButton("<<"); if (ImGui::IsItemActive()) { scroll_x_delta = -ImGui::GetIO().DeltaTime * 1000.0f; } ImGui::SameLine();
        ImGui::Text("Scroll from code"); ImGui::SameLine();
        ImGui::SmallButton(">>"); if (ImGui::IsItemActive()) { scroll_x_delta = +ImGui::GetIO().DeltaTime * 1000.0f; } ImGui::SameLine();
        ImGui::Text("%.0f/%.0f", scroll_x, scroll_max_x);
        if (scroll_x_delta != 0.0f)
        {
            ImGui::BeginChild("scrolling"); // Demonstrate a trick: you can use Begin to set yourself in the context of another window (here we are already out of your child window)
            ImGui::SetScrollX(ImGui::GetScrollX() + scroll_x_delta);
            ImGui::EndChild();
        }
        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Clipping"))
    {
        static ImVec2 size(100, 100), offset(50, 20);
        ImGui::TextWrapped("On a per-widget basis we are occasionally clipping text CPU-side if it won't fit in its frame. Otherwise we are doing coarser clipping + passing a scissor rectangle to the renderer. The system is designed to try minimizing both execution and CPU/GPU rendering cost.");
        ImGui::DragFloat2("size", (float*)&size, 0.5f, 1.0f, 200.0f, "%.0f");
        ImGui::TextWrapped("(Click and drag)");
        ImVec2 pos = ImGui::GetCursorScreenPos();
        ImVec4 clip_rect(pos.x, pos.y, pos.x + size.x, pos.y + size.y);
        ImGui::InvisibleButton("##dummy", size);
        if (ImGui::IsItemActive() && ImGui::IsMouseDragging()) { offset.x += ImGui::GetIO().MouseDelta.x; offset.y += ImGui::GetIO().MouseDelta.y; }
        ImGui::GetWindowDrawList()->AddRectFilled(pos, ImVec2(pos.x + size.x, pos.y + size.y), IM_COL32(90, 90, 120, 255));
        ImGui::GetWindowDrawList()->AddText(ImGui::GetFont(), ImGui::GetFontSize()*2.0f, ImVec2(pos.x + offset.x, pos.y + offset.y), IM_COL32(255, 255, 255, 255), "Line 1 hello\nLine 2 clip me!", NULL, 0.0f, &clip_rect);
        ImGui::TreePop();
    }
}

static void ShowDemoWindowPopups()
{
    if (!ImGui::CollapsingHeader("Popups & Modal windows"))
        return;

    // The properties of popups windows are:
    // - They block normal mouse hovering detection outside them. (*)
    // - Unless modal, they can be closed by clicking anywhere outside them, or by pressing ESCAPE.
    // - Their visibility state (~bool) is held internally by imgui instead of being held by the programmer as we are used to with regular Begin() calls.
    //   User can manipulate the visibility state by calling OpenPopup().
    // (*) One can use IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup) to bypass it and detect hovering even when normally blocked by a popup.
    // Those three properties are connected. The library needs to hold their visibility state because it can close popups at any time.

    // Typical use for regular windows:
    //   bool my_tool_is_active = false; if (ImGui::Button("Open")) my_tool_is_active = true; [...] if (my_tool_is_active) Begin("My Tool", &my_tool_is_active) { [...] } End();
    // Typical use for popups:
    //   if (ImGui::Button("Open")) ImGui::OpenPopup("MyPopup"); if (ImGui::BeginPopup("MyPopup") { [...] EndPopup(); }

    // With popups we have to go through a library call (here OpenPopup) to manipulate the visibility state.
    // This may be a bit confusing at first but it should quickly make sense. Follow on the examples below.

    if (ImGui::TreeNode("Popups"))
    {
        ImGui::TextWrapped("When a popup is active, it inhibits interacting with windows that are behind the popup. Clicking outside the popup closes it.");

        static int selected_fish = -1;
        const char* names[] = { "Bream", "Haddock", "Mackerel", "Pollock", "Tilefish" };
        static bool toggles[] = { true, false, false, false, false };

        // Simple selection popup
        // (If you want to show the current selection inside the Button itself, you may want to build a string using the "###" operator to preserve a constant ID with a variable label)
        if (ImGui::Button("Select.."))
            ImGui::OpenPopup("my_select_popup");
        ImGui::SameLine();
        ImGui::TextUnformatted(selected_fish == -1 ? "<None>" : names[selected_fish]);
        if (ImGui::BeginPopup("my_select_popup"))
        {
            ImGui::Text("Aquarium");
            ImGui::Separator();
            for (int i = 0; i < IM_ARRAYSIZE(names); i++)
                if (ImGui::Selectable(names[i]))
                    selected_fish = i;
            ImGui::EndPopup();
        }

        // Showing a menu with toggles
        if (ImGui::Button("Toggle.."))
            ImGui::OpenPopup("my_toggle_popup");
        if (ImGui::BeginPopup("my_toggle_popup"))
        {
            for (int i = 0; i < IM_ARRAYSIZE(names); i++)
                ImGui::MenuItem(names[i], "", &toggles[i]);
            if (ImGui::BeginMenu("Sub-menu"))
            {
                ImGui::MenuItem("Click me");
                ImGui::EndMenu();
            }

            ImGui::Separator();
            ImGui::Text("Tooltip here");
            if (ImGui::IsItemHovered())
                ImGui::SetTooltip("I am a tooltip over a popup");

            if (ImGui::Button("Stacked Popup"))
                ImGui::OpenPopup("another popup");
            if (ImGui::BeginPopup("another popup"))
            {
                for (int i = 0; i < IM_ARRAYSIZE(names); i++)
                    ImGui::MenuItem(names[i], "", &toggles[i]);
                if (ImGui::BeginMenu("Sub-menu"))
                {
                    ImGui::MenuItem("Click me");
                    if (ImGui::Button("Stacked Popup"))
                        ImGui::OpenPopup("another popup");
                    if (ImGui::BeginPopup("another popup"))
                    {
                        ImGui::Text("I am the last one here.");
                        ImGui::EndPopup();
                    }
                    ImGui::EndMenu();
                }
                ImGui::EndPopup();
            }
            ImGui::EndPopup();
        }

        // Call the more complete ShowExampleMenuFile which we use in various places of this demo
        if (ImGui::Button("File Menu.."))
            ImGui::OpenPopup("my_file_popup");
        if (ImGui::BeginPopup("my_file_popup"))
        {
            ShowExampleMenuFile();
            ImGui::EndPopup();
        }

        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Context menus"))
    {
        // BeginPopupContextItem() is a helper to provide common/simple popup behavior of essentially doing:
        //    if (IsItemHovered() && IsMouseReleased(0))
        //       OpenPopup(id);
        //    return BeginPopup(id);
        // For more advanced uses you may want to replicate and cuztomize this code. This the comments inside BeginPopupContextItem() implementation.
        static float value = 0.5f;
        ImGui::Text("Value = %.3f (<-- right-click here)", value);
        if (ImGui::BeginPopupContextItem("item context menu"))
        {
            if (ImGui::Selectable("Set to zero")) value = 0.0f;
            if (ImGui::Selectable("Set to PI")) value = 3.1415f;
            ImGui::SetNextItemWidth(-1);
            ImGui::DragFloat("##Value", &value, 0.1f, 0.0f, 0.0f);
            ImGui::EndPopup();
        }

        // We can also use OpenPopupOnItemClick() which is the same as BeginPopupContextItem() but without the Begin call.
        // So here we will make it that clicking on the text field with the right mouse button (1) will toggle the visibility of the popup above.
        ImGui::Text("(You can also right-click me to open the same popup as above.)");
        ImGui::OpenPopupOnItemClick("item context menu", 1);

        // When used after an item that has an ID (here the Button), we can skip providing an ID to BeginPopupContextItem().
        // BeginPopupContextItem() will use the last item ID as the popup ID.
        // In addition here, we want to include your editable label inside the button label. We use the ### operator to override the ID (read FAQ about ID for details)
        static char name[32] = "Label1";
        char buf[64]; sprintf(buf, "Button: %s###Button", name); // ### operator override ID ignoring the preceding label
        ImGui::Button(buf);
        if (ImGui::BeginPopupContextItem())
        {
            ImGui::Text("Edit name:");
            ImGui::InputText("##edit", name, IM_ARRAYSIZE(name));
            if (ImGui::Button("Close"))
                ImGui::CloseCurrentPopup();
            ImGui::EndPopup();
        }
        ImGui::SameLine(); ImGui::Text("(<-- right-click here)");

        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Modals"))
    {
        ImGui::TextWrapped("Modal windows are like popups but the user cannot close them by clicking outside the window.");

        if (ImGui::Button("Delete.."))
            ImGui::OpenPopup("Delete?");

        if (ImGui::BeginPopupModal("Delete?", NULL, ImGuiWindowFlags_AlwaysAutoResize))
        {
            ImGui::Text("All those beautiful files will be deleted.\nThis operation cannot be undone!\n\n");
            ImGui::Separator();

            //static int dummy_i = 0;
            //ImGui::Combo("Combo", &dummy_i, "Delete\0Delete harder\0");

            static bool dont_ask_me_next_time = false;
            ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0, 0));
            ImGui::Checkbox("Don't ask me next time", &dont_ask_me_next_time);
            ImGui::PopStyleVar();

            if (ImGui::Button("OK", ImVec2(120, 0))) { ImGui::CloseCurrentPopup(); }
            ImGui::SetItemDefaultFocus();
            ImGui::SameLine();
            if (ImGui::Button("Cancel", ImVec2(120, 0))) { ImGui::CloseCurrentPopup(); }
            ImGui::EndPopup();
        }

        if (ImGui::Button("Stacked modals.."))
            ImGui::OpenPopup("Stacked 1");
        if (ImGui::BeginPopupModal("Stacked 1", NULL, ImGuiWindowFlags_MenuBar))
        {
            if (ImGui::BeginMenuBar())
            {
                if (ImGui::BeginMenu("File"))
                {
                    if (ImGui::MenuItem("Dummy menu item")) {}
                    ImGui::EndMenu();
                }
                ImGui::EndMenuBar();
            }
            ImGui::Text("Hello from Stacked The First\nUsing style.Colors[ImGuiCol_ModalWindowDimBg] behind it.");

            // Testing behavior of widgets stacking their own regular popups over the modal.
            static int item = 1;
            static float color[4] = { 0.4f,0.7f,0.0f,0.5f };
            ImGui::Combo("Combo", &item, "aaaa\0bbbb\0cccc\0dddd\0eeee\0\0");
            ImGui::ColorEdit4("color", color);

            if (ImGui::Button("Add another modal.."))
                ImGui::OpenPopup("Stacked 2");

            // Also demonstrate passing a bool* to BeginPopupModal(), this will create a regular close button which will close the popup.
            // Note that the visibility state of popups is owned by imgui, so the input value of the bool actually doesn't matter here.
            bool dummy_open = true;
            if (ImGui::BeginPopupModal("Stacked 2", &dummy_open))
            {
                ImGui::Text("Hello from Stacked The Second!");
                if (ImGui::Button("Close"))
                    ImGui::CloseCurrentPopup();
                ImGui::EndPopup();
            }

            if (ImGui::Button("Close"))
                ImGui::CloseCurrentPopup();
            ImGui::EndPopup();
        }

        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Menus inside a regular window"))
    {
        ImGui::TextWrapped("Below we are testing adding menu items to a regular window. It's rather unusual but should work!");
        ImGui::Separator();
        // NB: As a quirk in this very specific example, we want to differentiate the parent of this menu from the parent of the various popup menus above.
        // To do so we are encloding the items in a PushID()/PopID() block to make them two different menusets. If we don't, opening any popup above and hovering our menu here
        // would open it. This is because once a menu is active, we allow to switch to a sibling menu by just hovering on it, which is the desired behavior for regular menus.
        ImGui::PushID("foo");
        ImGui::MenuItem("Menu item", "CTRL+M");
        if (ImGui::BeginMenu("Menu inside a regular window"))
        {
            ShowExampleMenuFile();
            ImGui::EndMenu();
        }
        ImGui::PopID();
        ImGui::Separator();
        ImGui::TreePop();
    }
}

static void ShowDemoWindowColumns()
{
    if (!ImGui::CollapsingHeader("Columns"))
        return;

    ImGui::PushID("Columns");

    static bool disable_indent = false;
    ImGui::Checkbox("Disable tree indentation", &disable_indent);
    ImGui::SameLine();
    HelpMarker("Disable the indenting of tree nodes so demo columns can use the full window width.");
    if (disable_indent)
        ImGui::PushStyleVar(ImGuiStyleVar_IndentSpacing, 0.0f);

    // Basic columns
    if (ImGui::TreeNode("Basic"))
    {
        ImGui::Text("Without border:");
        ImGui::Columns(3, "mycolumns3", false);  // 3-ways, no border
        ImGui::Separator();
        for (int n = 0; n < 14; n++)
        {
            char label[32];
            sprintf(label, "Item %d", n);
            if (ImGui::Selectable(label)) {}
            //if (ImGui::Button(label, ImVec2(-1,0))) {}
            ImGui::NextColumn();
        }
        ImGui::Columns(1);
        ImGui::Separator();

        ImGui::Text("With border:");
        ImGui::Columns(4, "mycolumns"); // 4-ways, with border
        ImGui::Separator();
        ImGui::Text("ID"); ImGui::NextColumn();
        ImGui::Text("Name"); ImGui::NextColumn();
        ImGui::Text("Path"); ImGui::NextColumn();
        ImGui::Text("Hovered"); ImGui::NextColumn();
        ImGui::Separator();
        const char* names[3] = { "One", "Two", "Three" };
        const char* paths[3] = { "/path/one", "/path/two", "/path/three" };
        static int selected = -1;
        for (int i = 0; i < 3; i++)
        {
            char label[32];
            sprintf(label, "%04d", i);
            if (ImGui::Selectable(label, selected == i, ImGuiSelectableFlags_SpanAllColumns))
                selected = i;
            bool hovered = ImGui::IsItemHovered();
            ImGui::NextColumn();
            ImGui::Text(names[i]); ImGui::NextColumn();
            ImGui::Text(paths[i]); ImGui::NextColumn();
            ImGui::Text("%d", hovered); ImGui::NextColumn();
        }
        ImGui::Columns(1);
        ImGui::Separator();
        ImGui::TreePop();
    }

    // Create multiple items in a same cell before switching to next column
    if (ImGui::TreeNode("Mixed items"))
    {
        ImGui::Columns(3, "mixed");
        ImGui::Separator();

        ImGui::Text("Hello");
        ImGui::Button("Banana");
        ImGui::NextColumn();

        ImGui::Text("ImGui");
        ImGui::Button("Apple");
        static float foo = 1.0f;
        ImGui::InputFloat("red", &foo, 0.05f, 0, "%.3f");
        ImGui::Text("An extra line here.");
        ImGui::NextColumn();

        ImGui::Text("Sailor");
        ImGui::Button("Corniflower");
        static float bar = 1.0f;
        ImGui::InputFloat("blue", &bar, 0.05f, 0, "%.3f");
        ImGui::NextColumn();

        if (ImGui::CollapsingHeader("Category A")) { ImGui::Text("Blah blah blah"); } ImGui::NextColumn();
        if (ImGui::CollapsingHeader("Category B")) { ImGui::Text("Blah blah blah"); } ImGui::NextColumn();
        if (ImGui::CollapsingHeader("Category C")) { ImGui::Text("Blah blah blah"); } ImGui::NextColumn();
        ImGui::Columns(1);
        ImGui::Separator();
        ImGui::TreePop();
    }

    // Word wrapping
    if (ImGui::TreeNode("Word-wrapping"))
    {
        ImGui::Columns(2, "word-wrapping");
        ImGui::Separator();
        ImGui::TextWrapped("The quick brown fox jumps over the lazy dog.");
        ImGui::TextWrapped("Hello Left");
        ImGui::NextColumn();
        ImGui::TextWrapped("The quick brown fox jumps over the lazy dog.");
        ImGui::TextWrapped("Hello Right");
        ImGui::Columns(1);
        ImGui::Separator();
        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Borders"))
    {
        // NB: Future columns API should allow automatic horizontal borders.
        static bool h_borders = true;
        static bool v_borders = true;
        ImGui::Checkbox("horizontal", &h_borders);
        ImGui::SameLine();
        ImGui::Checkbox("vertical", &v_borders);
        ImGui::Columns(4, NULL, v_borders);
        for (int i = 0; i < 4*3; i++)
        {
            if (h_borders && ImGui::GetColumnIndex() == 0)
                ImGui::Separator();
            ImGui::Text("%c%c%c", 'a'+i, 'a'+i, 'a'+i);
            ImGui::Text("Width %.2f", ImGui::GetColumnWidth());
            ImGui::Text("Offset %.2f", ImGui::GetColumnOffset());
            ImGui::Text("Long text that is likely to clip");
            ImGui::Button("Button", ImVec2(-1.0f, 0.0f));
            ImGui::NextColumn();
        }
        ImGui::Columns(1);
        if (h_borders)
            ImGui::Separator();
        ImGui::TreePop();
    }

    // Scrolling columns
    /*
    if (ImGui::TreeNode("Vertical Scrolling"))
    {
        ImGui::BeginChild("##header", ImVec2(0, ImGui::GetTextLineHeightWithSpacing()+ImGui::GetStyle().ItemSpacing.y));
        ImGui::Columns(3);
        ImGui::Text("ID"); ImGui::NextColumn();
        ImGui::Text("Name"); ImGui::NextColumn();
        ImGui::Text("Path"); ImGui::NextColumn();
        ImGui::Columns(1);
        ImGui::Separator();
        ImGui::EndChild();
        ImGui::BeginChild("##scrollingregion", ImVec2(0, 60));
        ImGui::Columns(3);
        for (int i = 0; i < 10; i++)
        {
            ImGui::Text("%04d", i); ImGui::NextColumn();
            ImGui::Text("Foobar"); ImGui::NextColumn();
            ImGui::Text("/path/foobar/%04d/", i); ImGui::NextColumn();
        }
        ImGui::Columns(1);
        ImGui::EndChild();
        ImGui::TreePop();
    }
    */

    if (ImGui::TreeNode("Horizontal Scrolling"))
    {
        ImGui::SetNextWindowContentSize(ImVec2(1500.0f, 0.0f));
        ImGui::BeginChild("##ScrollingRegion", ImVec2(0, ImGui::GetFontSize() * 20), false, ImGuiWindowFlags_HorizontalScrollbar);
        ImGui::Columns(10);
        int ITEMS_COUNT = 2000;
        ImGuiListClipper clipper(ITEMS_COUNT);  // Also demonstrate using the clipper for large list
        while (clipper.Step())
        {
            for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)
                for (int j = 0; j < 10; j++)
                {
                    ImGui::Text("Line %d Column %d...", i, j);
                    ImGui::NextColumn();
                }
        }
        ImGui::Columns(1);
        ImGui::EndChild();
        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Tree"))
    {
        ImGui::Columns(2, "tree", true);
        for (int x = 0; x < 3; x++)
        {
            bool open1 = ImGui::TreeNode((void*)(intptr_t)x, "Node%d", x);
            ImGui::NextColumn();
            ImGui::Text("Node contents");
            ImGui::NextColumn();
            if (open1)
            {
                for (int y = 0; y < 5; y++)
                {
                    bool open2 = ImGui::TreeNode((void*)(intptr_t)y, "Node%d.%d", x, y);
                    ImGui::NextColumn();
                    ImGui::Text("Node contents");
                    if (open2)
                    {
                        ImGui::Text("Even more contents");
                        if (ImGui::TreeNode("Tree in column"))
                        {
                            ImGui::Text("The quick brown fox jumps over the lazy dog");
                            ImGui::TreePop();
                        }
                    }
                    ImGui::NextColumn();
                    if (open2)
                        ImGui::TreePop();
                }
                ImGui::TreePop();
            }
        }
        ImGui::Columns(1);
        ImGui::TreePop();
    }

    if (disable_indent)
        ImGui::PopStyleVar();
    ImGui::PopID();
}

static void ShowDemoWindowMisc()
{
    if (ImGui::CollapsingHeader("Filtering"))
    {
        static ImGuiTextFilter filter;
        ImGui::Text("Filter usage:\n"
                    "  \"\"         display all lines\n"
                    "  \"xxx\"      display lines containing \"xxx\"\n"
                    "  \"xxx,yyy\"  display lines containing \"xxx\" or \"yyy\"\n"
                    "  \"-xxx\"     hide lines containing \"xxx\"");
        filter.Draw();
        const char* lines[] = { "aaa1.c", "bbb1.c", "ccc1.c", "aaa2.cpp", "bbb2.cpp", "ccc2.cpp", "abc.h", "hello, world" };
        for (int i = 0; i < IM_ARRAYSIZE(lines); i++)
            if (filter.PassFilter(lines[i]))
                ImGui::BulletText("%s", lines[i]);
    }

    if (ImGui::CollapsingHeader("Inputs, Navigation & Focus"))
    {
        ImGuiIO& io = ImGui::GetIO();

        ImGui::Text("WantCaptureMouse: %d", io.WantCaptureMouse);
        ImGui::Text("WantCaptureKeyboard: %d", io.WantCaptureKeyboard);
        ImGui::Text("WantTextInput: %d", io.WantTextInput);
        ImGui::Text("WantSetMousePos: %d", io.WantSetMousePos);
        ImGui::Text("NavActive: %d, NavVisible: %d", io.NavActive, io.NavVisible);

        if (ImGui::TreeNode("Keyboard, Mouse & Navigation State"))
        {
            if (ImGui::IsMousePosValid())
                ImGui::Text("Mouse pos: (%g, %g)", io.MousePos.x, io.MousePos.y);
            else
                ImGui::Text("Mouse pos: <INVALID>");
            ImGui::Text("Mouse delta: (%g, %g)", io.MouseDelta.x, io.MouseDelta.y);
            ImGui::Text("Mouse down:");     for (int i = 0; i < IM_ARRAYSIZE(io.MouseDown); i++) if (io.MouseDownDuration[i] >= 0.0f)   { ImGui::SameLine(); ImGui::Text("b%d (%.02f secs)", i, io.MouseDownDuration[i]); }
            ImGui::Text("Mouse clicked:");  for (int i = 0; i < IM_ARRAYSIZE(io.MouseDown); i++) if (ImGui::IsMouseClicked(i))          { ImGui::SameLine(); ImGui::Text("b%d", i); }
            ImGui::Text("Mouse dbl-clicked:"); for (int i = 0; i < IM_ARRAYSIZE(io.MouseDown); i++) if (ImGui::IsMouseDoubleClicked(i)) { ImGui::SameLine(); ImGui::Text("b%d", i); }
            ImGui::Text("Mouse released:"); for (int i = 0; i < IM_ARRAYSIZE(io.MouseDown); i++) if (ImGui::IsMouseReleased(i))         { ImGui::SameLine(); ImGui::Text("b%d", i); }
            ImGui::Text("Mouse wheel: %.1f", io.MouseWheel);

            ImGui::Text("Keys down:");      for (int i = 0; i < IM_ARRAYSIZE(io.KeysDown); i++) if (io.KeysDownDuration[i] >= 0.0f)     { ImGui::SameLine(); ImGui::Text("%d (0x%X) (%.02f secs)", i, i, io.KeysDownDuration[i]); }
            ImGui::Text("Keys pressed:");   for (int i = 0; i < IM_ARRAYSIZE(io.KeysDown); i++) if (ImGui::IsKeyPressed(i))             { ImGui::SameLine(); ImGui::Text("%d (0x%X)", i, i); }
            ImGui::Text("Keys release:");   for (int i = 0; i < IM_ARRAYSIZE(io.KeysDown); i++) if (ImGui::IsKeyReleased(i))            { ImGui::SameLine(); ImGui::Text("%d (0x%X)", i, i); }
            ImGui::Text("Keys mods: %s%s%s%s", io.KeyCtrl ? "CTRL " : "", io.KeyShift ? "SHIFT " : "", io.KeyAlt ? "ALT " : "", io.KeySuper ? "SUPER " : "");
            ImGui::Text("Chars queue:");    for (int i = 0; i < io.InputQueueCharacters.Size; i++) { ImWchar c = io.InputQueueCharacters[i]; ImGui::SameLine();  ImGui::Text("\'%c\' (0x%04X)", (c > ' ' && c <= 255) ? (char)c : '?', c); } // FIXME: We should convert 'c' to UTF-8 here but the functions are not public.

            ImGui::Text("NavInputs down:"); for (int i = 0; i < IM_ARRAYSIZE(io.NavInputs); i++) if (io.NavInputs[i] > 0.0f)                    { ImGui::SameLine(); ImGui::Text("[%d] %.2f", i, io.NavInputs[i]); }
            ImGui::Text("NavInputs pressed:"); for (int i = 0; i < IM_ARRAYSIZE(io.NavInputs); i++) if (io.NavInputsDownDuration[i] == 0.0f)    { ImGui::SameLine(); ImGui::Text("[%d]", i); }
            ImGui::Text("NavInputs duration:"); for (int i = 0; i < IM_ARRAYSIZE(io.NavInputs); i++) if (io.NavInputsDownDuration[i] >= 0.0f)   { ImGui::SameLine(); ImGui::Text("[%d] %.2f", i, io.NavInputsDownDuration[i]); }

            ImGui::Button("Hovering me sets the\nkeyboard capture flag");
            if (ImGui::IsItemHovered())
                ImGui::CaptureKeyboardFromApp(true);
            ImGui::SameLine();
            ImGui::Button("Holding me clears the\nthe keyboard capture flag");
            if (ImGui::IsItemActive())
                ImGui::CaptureKeyboardFromApp(false);

            ImGui::TreePop();
        }

        if (ImGui::TreeNode("Tabbing"))
        {
            ImGui::Text("Use TAB/SHIFT+TAB to cycle through keyboard editable fields.");
            static char buf[32] = "dummy";
            ImGui::InputText("1", buf, IM_ARRAYSIZE(buf));
            ImGui::InputText("2", buf, IM_ARRAYSIZE(buf));
            ImGui::InputText("3", buf, IM_ARRAYSIZE(buf));
            ImGui::PushAllowKeyboardFocus(false);
            ImGui::InputText("4 (tab skip)", buf, IM_ARRAYSIZE(buf));
            //ImGui::SameLine(); HelpMarker("Use ImGui::PushAllowKeyboardFocus(bool)\nto disable tabbing through certain widgets.");
            ImGui::PopAllowKeyboardFocus();
            ImGui::InputText("5", buf, IM_ARRAYSIZE(buf));
            ImGui::TreePop();
        }

        if (ImGui::TreeNode("Focus from code"))
        {
            bool focus_1 = ImGui::Button("Focus on 1"); ImGui::SameLine();
            bool focus_2 = ImGui::Button("Focus on 2"); ImGui::SameLine();
            bool focus_3 = ImGui::Button("Focus on 3");
            int has_focus = 0;
            static char buf[128] = "click on a button to set focus";

            if (focus_1) ImGui::SetKeyboardFocusHere();
            ImGui::InputText("1", buf, IM_ARRAYSIZE(buf));
            if (ImGui::IsItemActive()) has_focus = 1;

            if (focus_2) ImGui::SetKeyboardFocusHere();
            ImGui::InputText("2", buf, IM_ARRAYSIZE(buf));
            if (ImGui::IsItemActive()) has_focus = 2;

            ImGui::PushAllowKeyboardFocus(false);
            if (focus_3) ImGui::SetKeyboardFocusHere();
            ImGui::InputText("3 (tab skip)", buf, IM_ARRAYSIZE(buf));
            if (ImGui::IsItemActive()) has_focus = 3;
            ImGui::PopAllowKeyboardFocus();

            if (has_focus)
                ImGui::Text("Item with focus: %d", has_focus);
            else
                ImGui::Text("Item with focus: <none>");

            // Use >= 0 parameter to SetKeyboardFocusHere() to focus an upcoming item
            static float f3[3] = { 0.0f, 0.0f, 0.0f };
            int focus_ahead = -1;
            if (ImGui::Button("Focus on X")) { focus_ahead = 0; } ImGui::SameLine();
            if (ImGui::Button("Focus on Y")) { focus_ahead = 1; } ImGui::SameLine();
            if (ImGui::Button("Focus on Z")) { focus_ahead = 2; }
            if (focus_ahead != -1) ImGui::SetKeyboardFocusHere(focus_ahead);
            ImGui::SliderFloat3("Float3", &f3[0], 0.0f, 1.0f);

            ImGui::TextWrapped("NB: Cursor & selection are preserved when refocusing last used item in code.");
            ImGui::TreePop();
        }

        if (ImGui::TreeNode("Dragging"))
        {
            ImGui::TextWrapped("You can use ImGui::GetMouseDragDelta(0) to query for the dragged amount on any widget.");
            for (int button = 0; button < 3; button++)
                ImGui::Text("IsMouseDragging(%d):\n  w/ default threshold: %d,\n  w/ zero threshold: %d\n  w/ large threshold: %d",
                    button, ImGui::IsMouseDragging(button), ImGui::IsMouseDragging(button, 0.0f), ImGui::IsMouseDragging(button, 20.0f));

            ImGui::Button("Drag Me");
            if (ImGui::IsItemActive())
                ImGui::GetForegroundDrawList()->AddLine(io.MouseClickedPos[0], io.MousePos, ImGui::GetColorU32(ImGuiCol_Button), 4.0f); // Draw a line between the button and the mouse cursor

            // Drag operations gets "unlocked" when the mouse has moved past a certain threshold (the default threshold is stored in io.MouseDragThreshold)
            // You can request a lower or higher threshold using the second parameter of IsMouseDragging() and GetMouseDragDelta()
            ImVec2 value_raw = ImGui::GetMouseDragDelta(0, 0.0f);
            ImVec2 value_with_lock_threshold = ImGui::GetMouseDragDelta(0);
            ImVec2 mouse_delta = io.MouseDelta;
            ImGui::Text("GetMouseDragDelta(0):\n  w/ default threshold: (%.1f, %.1f),\n  w/ zero threshold: (%.1f, %.1f)\nMouseDelta: (%.1f, %.1f)", value_with_lock_threshold.x, value_with_lock_threshold.y, value_raw.x, value_raw.y, mouse_delta.x, mouse_delta.y);
            ImGui::TreePop();
        }

        if (ImGui::TreeNode("Mouse cursors"))
        {
            const char* mouse_cursors_names[] = { "Arrow", "TextInput", "Move", "ResizeNS", "ResizeEW", "ResizeNESW", "ResizeNWSE", "Hand" };
            IM_ASSERT(IM_ARRAYSIZE(mouse_cursors_names) == ImGuiMouseCursor_COUNT);

            ImGui::Text("Current mouse cursor = %d: %s", ImGui::GetMouseCursor(), mouse_cursors_names[ImGui::GetMouseCursor()]);
            ImGui::Text("Hover to see mouse cursors:");
            ImGui::SameLine(); HelpMarker("Your application can render a different mouse cursor based on what ImGui::GetMouseCursor() returns. If software cursor rendering (io.MouseDrawCursor) is set ImGui will draw the right cursor for you, otherwise your backend needs to handle it.");
            for (int i = 0; i < ImGuiMouseCursor_COUNT; i++)
            {
                char label[32];
                sprintf(label, "Mouse cursor %d: %s", i, mouse_cursors_names[i]);
                ImGui::Bullet(); ImGui::Selectable(label, false);
                if (ImGui::IsItemHovered() || ImGui::IsItemFocused())
                    ImGui::SetMouseCursor(i);
            }
            ImGui::TreePop();
        }
    }
}

//-----------------------------------------------------------------------------
// [SECTION] About Window / ShowAboutWindow()
// Access from ImGui Demo -> Help -> About
//-----------------------------------------------------------------------------

void ImGui::ShowAboutWindow(bool* p_open)
{
    if (!ImGui::Begin("About Dear ImGui", p_open, ImGuiWindowFlags_AlwaysAutoResize))
    {
        ImGui::End();
        return;
    }
    ImGui::Text("Dear ImGui %s", ImGui::GetVersion());
    ImGui::Separator();
    ImGui::Text("By Omar Cornut and all dear imgui contributors.");
    ImGui::Text("Dear ImGui is licensed under the MIT License, see LICENSE for more information.");

    static bool show_config_info = false;
    ImGui::Checkbox("Config/Build Information", &show_config_info);
    if (show_config_info)
    {
        ImGuiIO& io = ImGui::GetIO();
        ImGuiStyle& style = ImGui::GetStyle();

        bool copy_to_clipboard = ImGui::Button("Copy to clipboard");
        ImGui::BeginChildFrame(ImGui::GetID("cfginfos"), ImVec2(0, ImGui::GetTextLineHeightWithSpacing() * 18), ImGuiWindowFlags_NoMove);
        if (copy_to_clipboard)
            ImGui::LogToClipboard();

        ImGui::Text("Dear ImGui %s (%d)", IMGUI_VERSION, IMGUI_VERSION_NUM);
        ImGui::Separator();
        ImGui::Text("sizeof(size_t): %d, sizeof(ImDrawIdx): %d, sizeof(ImDrawVert): %d", (int)sizeof(size_t), (int)sizeof(ImDrawIdx), (int)sizeof(ImDrawVert));
        ImGui::Text("define: __cplusplus=%d", (int)__cplusplus);
#ifdef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
        ImGui::Text("define: IMGUI_DISABLE_OBSOLETE_FUNCTIONS");
#endif
#ifdef IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS
        ImGui::Text("define: IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS");
#endif
#ifdef IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS
        ImGui::Text("define: IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS");
#endif
#ifdef IMGUI_DISABLE_WIN32_FUNCTIONS
        ImGui::Text("define: IMGUI_DISABLE_WIN32_FUNCTIONS");
#endif
#ifdef IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS
        ImGui::Text("define: IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS");
#endif
#ifdef IMGUI_DISABLE_MATH_FUNCTIONS
        ImGui::Text("define: IMGUI_DISABLE_MATH_FUNCTIONS");
#endif
#ifdef IMGUI_DISABLE_DEFAULT_ALLOCATORS
        ImGui::Text("define: IMGUI_DISABLE_DEFAULT_ALLOCATORS");
#endif
#ifdef IMGUI_USE_BGRA_PACKED_COLOR
        ImGui::Text("define: IMGUI_USE_BGRA_PACKED_COLOR");
#endif
#ifdef _WIN32
        ImGui::Text("define: _WIN32");
#endif
#ifdef _WIN64
        ImGui::Text("define: _WIN64");
#endif
#ifdef __linux__
        ImGui::Text("define: __linux__");
#endif
#ifdef __APPLE__
        ImGui::Text("define: __APPLE__");
#endif
#ifdef _MSC_VER
        ImGui::Text("define: _MSC_VER=%d", _MSC_VER);
#endif
#ifdef __MINGW32__
        ImGui::Text("define: __MINGW32__");
#endif
#ifdef __MINGW64__
        ImGui::Text("define: __MINGW64__");
#endif
#ifdef __GNUC__
        ImGui::Text("define: __GNUC__=%d", (int)__GNUC__);
#endif
#ifdef __clang_version__
        ImGui::Text("define: __clang_version__=%s", __clang_version__);
#endif
        ImGui::Separator();
        ImGui::Text("io.BackendPlatformName: %s", io.BackendPlatformName ? io.BackendPlatformName : "NULL");
        ImGui::Text("io.BackendRendererName: %s", io.BackendRendererName ? io.BackendRendererName : "NULL");
        ImGui::Text("io.ConfigFlags: 0x%08X", io.ConfigFlags);
        if (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard)        ImGui::Text(" NavEnableKeyboard");
        if (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad)         ImGui::Text(" NavEnableGamepad");
        if (io.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos)     ImGui::Text(" NavEnableSetMousePos");
        if (io.ConfigFlags & ImGuiConfigFlags_NavNoCaptureKeyboard)     ImGui::Text(" NavNoCaptureKeyboard");
        if (io.ConfigFlags & ImGuiConfigFlags_NoMouse)                  ImGui::Text(" NoMouse");
        if (io.ConfigFlags & ImGuiConfigFlags_NoMouseCursorChange)      ImGui::Text(" NoMouseCursorChange");
        if (io.MouseDrawCursor)                                         ImGui::Text("io.MouseDrawCursor");
        if (io.ConfigMacOSXBehaviors)                                   ImGui::Text("io.ConfigMacOSXBehaviors");
        if (io.ConfigInputTextCursorBlink)                              ImGui::Text("io.ConfigInputTextCursorBlink");
        if (io.ConfigWindowsResizeFromEdges)                            ImGui::Text("io.ConfigWindowsResizeFromEdges");
        if (io.ConfigWindowsMoveFromTitleBarOnly)                       ImGui::Text("io.ConfigWindowsMoveFromTitleBarOnly");
        ImGui::Text("io.BackendFlags: 0x%08X", io.BackendFlags);
        if (io.BackendFlags & ImGuiBackendFlags_HasGamepad)             ImGui::Text(" HasGamepad");
        if (io.BackendFlags & ImGuiBackendFlags_HasMouseCursors)        ImGui::Text(" HasMouseCursors");
        if (io.BackendFlags & ImGuiBackendFlags_HasSetMousePos)         ImGui::Text(" HasSetMousePos");
        ImGui::Separator();
        ImGui::Text("io.Fonts: %d fonts, Flags: 0x%08X, TexSize: %d,%d", io.Fonts->Fonts.Size, io.Fonts->Flags, io.Fonts->TexWidth, io.Fonts->TexHeight);
        ImGui::Text("io.DisplaySize: %.2f,%.2f", io.DisplaySize.x, io.DisplaySize.y);
        ImGui::Text("io.DisplayFramebufferScale: %.2f,%.2f", io.DisplayFramebufferScale.x, io.DisplayFramebufferScale.y);
        ImGui::Separator();
        ImGui::Text("style.WindowPadding: %.2f,%.2f", style.WindowPadding.x, style.WindowPadding.y);
        ImGui::Text("style.WindowBorderSize: %.2f", style.WindowBorderSize);
        ImGui::Text("style.FramePadding: %.2f,%.2f", style.FramePadding.x, style.FramePadding.y);
        ImGui::Text("style.FrameRounding: %.2f", style.FrameRounding);
        ImGui::Text("style.FrameBorderSize: %.2f", style.FrameBorderSize);
        ImGui::Text("style.ItemSpacing: %.2f,%.2f", style.ItemSpacing.x, style.ItemSpacing.y);
        ImGui::Text("style.ItemInnerSpacing: %.2f,%.2f", style.ItemInnerSpacing.x, style.ItemInnerSpacing.y);

        if (copy_to_clipboard)
            ImGui::LogFinish();
        ImGui::EndChildFrame();
    }
    ImGui::End();
}

//-----------------------------------------------------------------------------
// [SECTION] Style Editor / ShowStyleEditor()
//-----------------------------------------------------------------------------

// Demo helper function to select among default colors. See ShowStyleEditor() for more advanced options.
// Here we use the simplified Combo() api that packs items into a single literal string. Useful for quick combo boxes where the choices are known locally.
bool ImGui::ShowStyleSelector(const char* label)
{
    static int style_idx = -1;
    if (ImGui::Combo(label, &style_idx, "Classic\0Dark\0Light\0"))
    {
        switch (style_idx)
        {
        case 0: ImGui::StyleColorsClassic(); break;
        case 1: ImGui::StyleColorsDark(); break;
        case 2: ImGui::StyleColorsLight(); break;
        }
        return true;
    }
    return false;
}

// Demo helper function to select among loaded fonts.
// Here we use the regular BeginCombo()/EndCombo() api which is more the more flexible one.
void ImGui::ShowFontSelector(const char* label)
{
    ImGuiIO& io = ImGui::GetIO();
    ImFont* font_current = ImGui::GetFont();
    if (ImGui::BeginCombo(label, font_current->GetDebugName()))
    {
        for (int n = 0; n < io.Fonts->Fonts.Size; n++)
        {
            ImFont* font = io.Fonts->Fonts[n];
            ImGui::PushID((void*)font);
            if (ImGui::Selectable(font->GetDebugName(), font == font_current))
                io.FontDefault = font;
            ImGui::PopID();
        }
        ImGui::EndCombo();
    }
    ImGui::SameLine();
    HelpMarker(
        "- Load additional fonts with io.Fonts->AddFontFromFileTTF().\n"
        "- The font atlas is built when calling io.Fonts->GetTexDataAsXXXX() or io.Fonts->Build().\n"
        "- Read FAQ and documentation in misc/fonts/ for more details.\n"
        "- If you need to add/remove fonts at runtime (e.g. for DPI change), do it before calling NewFrame().");
}

void ImGui::ShowStyleEditor(ImGuiStyle* ref)
{
    // You can pass in a reference ImGuiStyle structure to compare to, revert to and save to (else it compares to an internally stored reference)
    ImGuiStyle& style = ImGui::GetStyle();
    static ImGuiStyle ref_saved_style;

    // Default to using internal storage as reference
    static bool init = true;
    if (init && ref == NULL)
        ref_saved_style = style;
    init = false;
    if (ref == NULL)
        ref = &ref_saved_style;

    ImGui::PushItemWidth(ImGui::GetWindowWidth() * 0.50f);

    if (ImGui::ShowStyleSelector("Colors##Selector"))
        ref_saved_style = style;
    ImGui::ShowFontSelector("Fonts##Selector");

    // Simplified Settings
    if (ImGui::SliderFloat("FrameRounding", &style.FrameRounding, 0.0f, 12.0f, "%.0f"))
        style.GrabRounding = style.FrameRounding; // Make GrabRounding always the same value as FrameRounding
    { bool window_border = (style.WindowBorderSize > 0.0f); if (ImGui::Checkbox("WindowBorder", &window_border)) style.WindowBorderSize = window_border ? 1.0f : 0.0f; }
    ImGui::SameLine();
    { bool frame_border = (style.FrameBorderSize > 0.0f); if (ImGui::Checkbox("FrameBorder", &frame_border)) style.FrameBorderSize = frame_border ? 1.0f : 0.0f; }
    ImGui::SameLine();
    { bool popup_border = (style.PopupBorderSize > 0.0f); if (ImGui::Checkbox("PopupBorder", &popup_border)) style.PopupBorderSize = popup_border ? 1.0f : 0.0f; }

    // Save/Revert button
    if (ImGui::Button("Save Ref"))
        *ref = ref_saved_style = style;
    ImGui::SameLine();
    if (ImGui::Button("Revert Ref"))
        style = *ref;
    ImGui::SameLine();
    HelpMarker("Save/Revert in local non-persistent storage. Default Colors definition are not affected. Use \"Export Colors\" below to save them somewhere.");

    ImGui::Separator();

    if (ImGui::BeginTabBar("##tabs", ImGuiTabBarFlags_None))
    {
        if (ImGui::BeginTabItem("Sizes"))
        {
            ImGui::Text("Main");
            ImGui::SliderFloat2("WindowPadding", (float*)&style.WindowPadding, 0.0f, 20.0f, "%.0f");
            ImGui::SliderFloat2("FramePadding", (float*)&style.FramePadding, 0.0f, 20.0f, "%.0f");
            ImGui::SliderFloat2("ItemSpacing", (float*)&style.ItemSpacing, 0.0f, 20.0f, "%.0f");
            ImGui::SliderFloat2("ItemInnerSpacing", (float*)&style.ItemInnerSpacing, 0.0f, 20.0f, "%.0f");
            ImGui::SliderFloat2("TouchExtraPadding", (float*)&style.TouchExtraPadding, 0.0f, 10.0f, "%.0f");
            ImGui::SliderFloat("IndentSpacing", &style.IndentSpacing, 0.0f, 30.0f, "%.0f");
            ImGui::SliderFloat("ScrollbarSize", &style.ScrollbarSize, 1.0f, 20.0f, "%.0f");
            ImGui::SliderFloat("GrabMinSize", &style.GrabMinSize, 1.0f, 20.0f, "%.0f");
            ImGui::Text("Borders");
            ImGui::SliderFloat("WindowBorderSize", &style.WindowBorderSize, 0.0f, 1.0f, "%.0f");
            ImGui::SliderFloat("ChildBorderSize", &style.ChildBorderSize, 0.0f, 1.0f, "%.0f");
            ImGui::SliderFloat("PopupBorderSize", &style.PopupBorderSize, 0.0f, 1.0f, "%.0f");
            ImGui::SliderFloat("FrameBorderSize", &style.FrameBorderSize, 0.0f, 1.0f, "%.0f");
            ImGui::SliderFloat("TabBorderSize", &style.TabBorderSize, 0.0f, 1.0f, "%.0f");
            ImGui::Text("Rounding");
            ImGui::SliderFloat("WindowRounding", &style.WindowRounding, 0.0f, 12.0f, "%.0f");
            ImGui::SliderFloat("ChildRounding", &style.ChildRounding, 0.0f, 12.0f, "%.0f");
            ImGui::SliderFloat("FrameRounding", &style.FrameRounding, 0.0f, 12.0f, "%.0f");
            ImGui::SliderFloat("PopupRounding", &style.PopupRounding, 0.0f, 12.0f, "%.0f");
            ImGui::SliderFloat("ScrollbarRounding", &style.ScrollbarRounding, 0.0f, 12.0f, "%.0f");
            ImGui::SliderFloat("GrabRounding", &style.GrabRounding, 0.0f, 12.0f, "%.0f");
            ImGui::SliderFloat("TabRounding", &style.TabRounding, 0.0f, 12.0f, "%.0f");
            ImGui::Text("Alignment");
            ImGui::SliderFloat2("WindowTitleAlign", (float*)&style.WindowTitleAlign, 0.0f, 1.0f, "%.2f");
            ImGui::SliderFloat2("ButtonTextAlign", (float*)&style.ButtonTextAlign, 0.0f, 1.0f, "%.2f"); ImGui::SameLine(); HelpMarker("Alignment applies when a button is larger than its text content.");
            ImGui::SliderFloat2("SelectableTextAlign", (float*)&style.SelectableTextAlign, 0.0f, 1.0f, "%.2f"); ImGui::SameLine(); HelpMarker("Alignment applies when a selectable is larger than its text content.");
            ImGui::Text("Safe Area Padding"); ImGui::SameLine(); HelpMarker("Adjust if you cannot see the edges of your screen (e.g. on a TV where scaling has not been configured).");
            ImGui::SliderFloat2("DisplaySafeAreaPadding", (float*)&style.DisplaySafeAreaPadding, 0.0f, 30.0f, "%.0f");
            ImGui::EndTabItem();
        }

        if (ImGui::BeginTabItem("Colors"))
        {
            static int output_dest = 0;
            static bool output_only_modified = true;
            if (ImGui::Button("Export Unsaved"))
            {
                if (output_dest == 0)
                    ImGui::LogToClipboard();
                else
                    ImGui::LogToTTY();
                ImGui::LogText("ImVec4* colors = ImGui::GetStyle().Colors;" IM_NEWLINE);
                for (int i = 0; i < ImGuiCol_COUNT; i++)
                {
                    const ImVec4& col = style.Colors[i];
                    const char* name = ImGui::GetStyleColorName(i);
                    if (!output_only_modified || memcmp(&col, &ref->Colors[i], sizeof(ImVec4)) != 0)
                        ImGui::LogText("colors[ImGuiCol_%s]%*s= ImVec4(%.2ff, %.2ff, %.2ff, %.2ff);" IM_NEWLINE, name, 23 - (int)strlen(name), "", col.x, col.y, col.z, col.w);
                }
                ImGui::LogFinish();
            }
            ImGui::SameLine(); ImGui::SetNextItemWidth(120); ImGui::Combo("##output_type", &output_dest, "To Clipboard\0To TTY\0");
            ImGui::SameLine(); ImGui::Checkbox("Only Modified Colors", &output_only_modified);

            static ImGuiTextFilter filter;
            filter.Draw("Filter colors", ImGui::GetFontSize() * 16);

            static ImGuiColorEditFlags alpha_flags = 0;
            ImGui::RadioButton("Opaque", &alpha_flags, 0); ImGui::SameLine();
            ImGui::RadioButton("Alpha", &alpha_flags, ImGuiColorEditFlags_AlphaPreview); ImGui::SameLine();
            ImGui::RadioButton("Both", &alpha_flags, ImGuiColorEditFlags_AlphaPreviewHalf); ImGui::SameLine();
            HelpMarker("In the color list:\nLeft-click on colored square to open color picker,\nRight-click to open edit options menu.");

            ImGui::BeginChild("##colors", ImVec2(0, 0), true, ImGuiWindowFlags_AlwaysVerticalScrollbar | ImGuiWindowFlags_AlwaysHorizontalScrollbar | ImGuiWindowFlags_NavFlattened);
            ImGui::PushItemWidth(-160);
            for (int i = 0; i < ImGuiCol_COUNT; i++)
            {
                const char* name = ImGui::GetStyleColorName(i);
                if (!filter.PassFilter(name))
                    continue;
                ImGui::PushID(i);
                ImGui::ColorEdit4("##color", (float*)&style.Colors[i], ImGuiColorEditFlags_AlphaBar | alpha_flags);
                if (memcmp(&style.Colors[i], &ref->Colors[i], sizeof(ImVec4)) != 0)
                {
                    // Tips: in a real user application, you may want to merge and use an icon font into the main font, so instead of "Save"/"Revert" you'd use icons.
                    // Read the FAQ and misc/fonts/README.txt about using icon fonts. It's really easy and super convenient!
                    ImGui::SameLine(0.0f, style.ItemInnerSpacing.x); if (ImGui::Button("Save")) ref->Colors[i] = style.Colors[i];
                    ImGui::SameLine(0.0f, style.ItemInnerSpacing.x); if (ImGui::Button("Revert")) style.Colors[i] = ref->Colors[i];
                }
                ImGui::SameLine(0.0f, style.ItemInnerSpacing.x);
                ImGui::TextUnformatted(name);
                ImGui::PopID();
            }
            ImGui::PopItemWidth();
            ImGui::EndChild();

            ImGui::EndTabItem();
        }

        if (ImGui::BeginTabItem("Fonts"))
        {
            ImGuiIO& io = ImGui::GetIO();
            ImFontAtlas* atlas = io.Fonts;
            HelpMarker("Read FAQ and misc/fonts/README.txt for details on font loading.");
            ImGui::PushItemWidth(120);
            for (int i = 0; i < atlas->Fonts.Size; i++)
            {
                ImFont* font = atlas->Fonts[i];
                ImGui::PushID(font);
                bool font_details_opened = ImGui::TreeNode(font, "Font %d: \"%s\"\n%.2f px, %d glyphs, %d file(s)", i, font->ConfigData ? font->ConfigData[0].Name : "", font->FontSize, font->Glyphs.Size, font->ConfigDataCount);
                ImGui::SameLine(); if (ImGui::SmallButton("Set as default")) { io.FontDefault = font; }
                if (font_details_opened)
                {
                    ImGui::PushFont(font);
                    ImGui::Text("The quick brown fox jumps over the lazy dog");
                    ImGui::PopFont();
                    ImGui::DragFloat("Font scale", &font->Scale, 0.005f, 0.3f, 2.0f, "%.1f");   // Scale only this font
                    ImGui::SameLine(); HelpMarker("Note than the default embedded font is NOT meant to be scaled.\n\nFont are currently rendered into bitmaps at a given size at the time of building the atlas. You may oversample them to get some flexibility with scaling. You can also render at multiple sizes and select which one to use at runtime.\n\n(Glimmer of hope: the atlas system should hopefully be rewritten in the future to make scaling more natural and automatic.)");
                    ImGui::InputFloat("Font offset", &font->DisplayOffset.y, 1, 1, "%.0f");
                    ImGui::Text("Ascent: %f, Descent: %f, Height: %f", font->Ascent, font->Descent, font->Ascent - font->Descent);
                    ImGui::Text("Fallback character: '%c' (%d)", font->FallbackChar, font->FallbackChar);
                    const float surface_sqrt = sqrtf((float)font->MetricsTotalSurface);
                    ImGui::Text("Texture surface: %d pixels (approx) ~ %dx%d", font->MetricsTotalSurface, (int)surface_sqrt, (int)surface_sqrt);
                    for (int config_i = 0; config_i < font->ConfigDataCount; config_i++)
                        if (const ImFontConfig* cfg = &font->ConfigData[config_i])
                            ImGui::BulletText("Input %d: \'%s\', Oversample: (%d,%d), PixelSnapH: %d", config_i, cfg->Name, cfg->OversampleH, cfg->OversampleV, cfg->PixelSnapH);
                    if (ImGui::TreeNode("Glyphs", "Glyphs (%d)", font->Glyphs.Size))
                    {
                        // Display all glyphs of the fonts in separate pages of 256 characters
                        for (int base = 0; base < 0x10000; base += 256)
                        {
                            int count = 0;
                            for (int n = 0; n < 256; n++)
                                count += font->FindGlyphNoFallback((ImWchar)(base + n)) ? 1 : 0;
                            if (count > 0 && ImGui::TreeNode((void*)(intptr_t)base, "U+%04X..U+%04X (%d %s)", base, base + 255, count, count > 1 ? "glyphs" : "glyph"))
                            {
                                float cell_size = font->FontSize * 1;
                                float cell_spacing = style.ItemSpacing.y;
                                ImVec2 base_pos = ImGui::GetCursorScreenPos();
                                ImDrawList* draw_list = ImGui::GetWindowDrawList();
                                for (int n = 0; n < 256; n++)
                                {
                                    ImVec2 cell_p1(base_pos.x + (n % 16) * (cell_size + cell_spacing), base_pos.y + (n / 16) * (cell_size + cell_spacing));
                                    ImVec2 cell_p2(cell_p1.x + cell_size, cell_p1.y + cell_size);
                                    const ImFontGlyph* glyph = font->FindGlyphNoFallback((ImWchar)(base + n));
                                    draw_list->AddRect(cell_p1, cell_p2, glyph ? IM_COL32(255, 255, 255, 100) : IM_COL32(255, 255, 255, 50));
                                    if (glyph)
                                        font->RenderChar(draw_list, cell_size, cell_p1, ImGui::GetColorU32(ImGuiCol_Text), (ImWchar)(base + n)); // We use ImFont::RenderChar as a shortcut because we don't have UTF-8 conversion functions available to generate a string.
                                    if (glyph && ImGui::IsMouseHoveringRect(cell_p1, cell_p2))
                                    {
                                        ImGui::BeginTooltip();
                                        ImGui::Text("Codepoint: U+%04X", base + n);
                                        ImGui::Separator();
                                        ImGui::Text("AdvanceX: %.1f", glyph->AdvanceX);
                                        ImGui::Text("Pos: (%.2f,%.2f)->(%.2f,%.2f)", glyph->X0, glyph->Y0, glyph->X1, glyph->Y1);
                                        ImGui::Text("UV: (%.3f,%.3f)->(%.3f,%.3f)", glyph->U0, glyph->V0, glyph->U1, glyph->V1);
                                        ImGui::EndTooltip();
                                    }
                                }
                                ImGui::Dummy(ImVec2((cell_size + cell_spacing) * 16, (cell_size + cell_spacing) * 16));
                                ImGui::TreePop();
                            }
                        }
                        ImGui::TreePop();
                    }
                    ImGui::TreePop();
                }
                ImGui::PopID();
            }
            if (ImGui::TreeNode("Atlas texture", "Atlas texture (%dx%d pixels)", atlas->TexWidth, atlas->TexHeight))
            {
                ImVec4 tint_col = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
                ImVec4 border_col = ImVec4(1.0f, 1.0f, 1.0f, 0.5f);
                ImGui::Image(atlas->TexID, ImVec2((float)atlas->TexWidth, (float)atlas->TexHeight), ImVec2(0, 0), ImVec2(1, 1), tint_col, border_col);
                ImGui::TreePop();
            }

            static float window_scale = 1.0f;
            if (ImGui::DragFloat("this window scale", &window_scale, 0.005f, 0.3f, 2.0f, "%.2f"))   // scale only this window
                ImGui::SetWindowFontScale(window_scale);
            ImGui::DragFloat("global scale", &io.FontGlobalScale, 0.005f, 0.3f, 2.0f, "%.2f");      // scale everything
            ImGui::PopItemWidth();

            ImGui::EndTabItem();
        }

        if (ImGui::BeginTabItem("Rendering"))
        {
            ImGui::Checkbox("Anti-aliased lines", &style.AntiAliasedLines); ImGui::SameLine(); HelpMarker("When disabling anti-aliasing lines, you'll probably want to disable borders in your style as well.");
            ImGui::Checkbox("Anti-aliased fill", &style.AntiAliasedFill);
            ImGui::PushItemWidth(100);
            ImGui::DragFloat("Curve Tessellation Tolerance", &style.CurveTessellationTol, 0.02f, 0.10f, FLT_MAX, "%.2f", 2.0f);
            if (style.CurveTessellationTol < 0.10f) style.CurveTessellationTol = 0.10f;
            ImGui::DragFloat("Global Alpha", &style.Alpha, 0.005f, 0.20f, 1.0f, "%.2f"); // Not exposing zero here so user doesn't "lose" the UI (zero alpha clips all widgets). But application code could have a toggle to switch between zero and non-zero.
            ImGui::PopItemWidth();

            ImGui::EndTabItem();
        }

        ImGui::EndTabBar();
    }

    ImGui::PopItemWidth();
}

//-----------------------------------------------------------------------------
// [SECTION] Example App: Main Menu Bar / ShowExampleAppMainMenuBar()
//-----------------------------------------------------------------------------

// Demonstrate creating a "main" fullscreen menu bar and populating it.
// Note the difference between BeginMainMenuBar() and BeginMenuBar():
// - BeginMenuBar() = menu-bar inside current window we Begin()-ed into (the window needs the ImGuiWindowFlags_MenuBar flag)
// - BeginMainMenuBar() = helper to create menu-bar-sized window at the top of the main viewport + call BeginMenuBar() into it.
static void ShowExampleAppMainMenuBar()
{
    if (ImGui::BeginMainMenuBar())
    {
        if (ImGui::BeginMenu("File"))
        {
            ShowExampleMenuFile();
            ImGui::EndMenu();
        }
        if (ImGui::BeginMenu("Edit"))
        {
            if (ImGui::MenuItem("Undo", "CTRL+Z")) {}
            if (ImGui::MenuItem("Redo", "CTRL+Y", false, false)) {}  // Disabled item
            ImGui::Separator();
            if (ImGui::MenuItem("Cut", "CTRL+X")) {}
            if (ImGui::MenuItem("Copy", "CTRL+C")) {}
            if (ImGui::MenuItem("Paste", "CTRL+V")) {}
            ImGui::EndMenu();
        }
        ImGui::EndMainMenuBar();
    }
}

// Note that shortcuts are currently provided for display only (future version will add flags to BeginMenu to process shortcuts)
static void ShowExampleMenuFile()
{
    ImGui::MenuItem("(dummy menu)", NULL, false, false);
    if (ImGui::MenuItem("New")) {}
    if (ImGui::MenuItem("Open", "Ctrl+O")) {}
    if (ImGui::BeginMenu("Open Recent"))
    {
        ImGui::MenuItem("fish_hat.c");
        ImGui::MenuItem("fish_hat.inl");
        ImGui::MenuItem("fish_hat.h");
        if (ImGui::BeginMenu("More.."))
        {
            ImGui::MenuItem("Hello");
            ImGui::MenuItem("Sailor");
            if (ImGui::BeginMenu("Recurse.."))
            {
                ShowExampleMenuFile();
                ImGui::EndMenu();
            }
            ImGui::EndMenu();
        }
        ImGui::EndMenu();
    }
    if (ImGui::MenuItem("Save", "Ctrl+S")) {}
    if (ImGui::MenuItem("Save As..")) {}
    ImGui::Separator();
    if (ImGui::BeginMenu("Options"))
    {
        static bool enabled = true;
        ImGui::MenuItem("Enabled", "", &enabled);
        ImGui::BeginChild("child", ImVec2(0, 60), true);
        for (int i = 0; i < 10; i++)
            ImGui::Text("Scrolling Text %d", i);
        ImGui::EndChild();
        static float f = 0.5f;
        static int n = 0;
        static bool b = true;
        ImGui::SliderFloat("Value", &f, 0.0f, 1.0f);
        ImGui::InputFloat("Input", &f, 0.1f);
        ImGui::Combo("Combo", &n, "Yes\0No\0Maybe\0\0");
        ImGui::Checkbox("Check", &b);
        ImGui::EndMenu();
    }
    if (ImGui::BeginMenu("Colors"))
    {
        float sz = ImGui::GetTextLineHeight();
        for (int i = 0; i < ImGuiCol_COUNT; i++)
        {
            const char* name = ImGui::GetStyleColorName((ImGuiCol)i);
            ImVec2 p = ImGui::GetCursorScreenPos();
            ImGui::GetWindowDrawList()->AddRectFilled(p, ImVec2(p.x+sz, p.y+sz), ImGui::GetColorU32((ImGuiCol)i));
            ImGui::Dummy(ImVec2(sz, sz));
            ImGui::SameLine();
            ImGui::MenuItem(name);
        }
        ImGui::EndMenu();
    }
    if (ImGui::BeginMenu("Disabled", false)) // Disabled
    {
        IM_ASSERT(0);
    }
    if (ImGui::MenuItem("Checked", NULL, true)) {}
    if (ImGui::MenuItem("Quit", "Alt+F4")) {}
}

//-----------------------------------------------------------------------------
// [SECTION] Example App: Debug Console / ShowExampleAppConsole()
//-----------------------------------------------------------------------------

// Demonstrate creating a simple console window, with scrolling, filtering, completion and history.
// For the console example, here we are using a more C++ like approach of declaring a class to hold the data and the functions.
struct ExampleAppConsole
{
    char                  InputBuf[256];
    ImVector<char*>       Items;
    ImVector<const char*> Commands;
    ImVector<char*>       History;
    int                   HistoryPos;    // -1: new line, 0..History.Size-1 browsing history.
    ImGuiTextFilter       Filter;
    bool                  AutoScroll;
    bool                  ScrollToBottom;

    ExampleAppConsole()
    {
        ClearLog();
        memset(InputBuf, 0, sizeof(InputBuf));
        HistoryPos = -1;
        Commands.push_back("HELP");
        Commands.push_back("HISTORY");
        Commands.push_back("CLEAR");
        Commands.push_back("CLASSIFY");  // "classify" is only here to provide an example of "C"+[tab] completing to "CL" and displaying matches.
        AutoScroll = true;
        ScrollToBottom = true;
        AddLog("Welcome to Dear ImGui!");
    }
    ~ExampleAppConsole()
    {
        ClearLog();
        for (int i = 0; i < History.Size; i++)
            free(History[i]);
    }

    // Portable helpers
    static int   Stricmp(const char* str1, const char* str2)         { int d; while ((d = toupper(*str2) - toupper(*str1)) == 0 && *str1) { str1++; str2++; } return d; }
    static int   Strnicmp(const char* str1, const char* str2, int n) { int d = 0; while (n > 0 && (d = toupper(*str2) - toupper(*str1)) == 0 && *str1) { str1++; str2++; n--; } return d; }
    static char* Strdup(const char *str)                             { size_t len = strlen(str) + 1; void* buf = malloc(len); IM_ASSERT(buf); return (char*)memcpy(buf, (const void*)str, len); }
    static void  Strtrim(char* str)                                  { char* str_end = str + strlen(str); while (str_end > str && str_end[-1] == ' ') str_end--; *str_end = 0; }

    void    ClearLog()
    {
        for (int i = 0; i < Items.Size; i++)
            free(Items[i]);
        Items.clear();
        ScrollToBottom = true;
    }

    void    AddLog(const char* fmt, ...) IM_FMTARGS(2)
    {
        // FIXME-OPT
        char buf[1024];
        va_list args;
        va_start(args, fmt);
        vsnprintf(buf, IM_ARRAYSIZE(buf), fmt, args);
        buf[IM_ARRAYSIZE(buf)-1] = 0;
        va_end(args);
        Items.push_back(Strdup(buf));
        if (AutoScroll)
            ScrollToBottom = true;
    }

    void    Draw(const char* title, bool* p_open)
    {
        ImGui::SetNextWindowSize(ImVec2(520,600), ImGuiCond_FirstUseEver);
        if (!ImGui::Begin(title, p_open))
        {
            ImGui::End();
            return;
        }

        // As a specific feature guaranteed by the library, after calling Begin() the last Item represent the title bar. So e.g. IsItemHovered() will return true when hovering the title bar.
        // Here we create a context menu only available from the title bar.
        if (ImGui::BeginPopupContextItem())
        {
            if (ImGui::MenuItem("Close Console"))
                *p_open = false;
            ImGui::EndPopup();
        }

        ImGui::TextWrapped("This example implements a console with basic coloring, completion and history. A more elaborate implementation may want to store entries along with extra data such as timestamp, emitter, etc.");
        ImGui::TextWrapped("Enter 'HELP' for help, press TAB to use text completion.");

        // TODO: display items starting from the bottom

        if (ImGui::SmallButton("Add Dummy Text"))  { AddLog("%d some text", Items.Size); AddLog("some more text"); AddLog("display very important message here!"); } ImGui::SameLine();
        if (ImGui::SmallButton("Add Dummy Error")) { AddLog("[error] something went wrong"); } ImGui::SameLine();
        if (ImGui::SmallButton("Clear")) { ClearLog(); } ImGui::SameLine();
        bool copy_to_clipboard = ImGui::SmallButton("Copy"); ImGui::SameLine();
        if (ImGui::SmallButton("Scroll to bottom")) ScrollToBottom = true;
        //static float t = 0.0f; if (ImGui::GetTime() - t > 0.02f) { t = ImGui::GetTime(); AddLog("Spam %f", t); }

        ImGui::Separator();

        // Options menu
        if (ImGui::BeginPopup("Options"))
        {
            if (ImGui::Checkbox("Auto-scroll", &AutoScroll))
                if (AutoScroll)
                    ScrollToBottom = true;
            ImGui::EndPopup();
        }

        // Options, Filter
        if (ImGui::Button("Options"))
            ImGui::OpenPopup("Options");
        ImGui::SameLine();
        Filter.Draw("Filter (\"incl,-excl\") (\"error\")", 180);
        ImGui::Separator();

        const float footer_height_to_reserve = ImGui::GetStyle().ItemSpacing.y + ImGui::GetFrameHeightWithSpacing(); // 1 separator, 1 input text
        ImGui::BeginChild("ScrollingRegion", ImVec2(0, -footer_height_to_reserve), false, ImGuiWindowFlags_HorizontalScrollbar); // Leave room for 1 separator + 1 InputText
        if (ImGui::BeginPopupContextWindow())
        {
            if (ImGui::Selectable("Clear")) ClearLog();
            ImGui::EndPopup();
        }

        // Display every line as a separate entry so we can change their color or add custom widgets. If you only want raw text you can use ImGui::TextUnformatted(log.begin(), log.end());
        // NB- if you have thousands of entries this approach may be too inefficient and may require user-side clipping to only process visible items.
        // You can seek and display only the lines that are visible using the ImGuiListClipper helper, if your elements are evenly spaced and you have cheap random access to the elements.
        // To use the clipper we could replace the 'for (int i = 0; i < Items.Size; i++)' loop with:
        //     ImGuiListClipper clipper(Items.Size);
        //     while (clipper.Step())
        //         for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)
        // However, note that you can not use this code as is if a filter is active because it breaks the 'cheap random-access' property. We would need random-access on the post-filtered list.
        // A typical application wanting coarse clipping and filtering may want to pre-compute an array of indices that passed the filtering test, recomputing this array when user changes the filter,
        // and appending newly elements as they are inserted. This is left as a task to the user until we can manage to improve this example code!
        // If your items are of variable size you may want to implement code similar to what ImGuiListClipper does. Or split your data into fixed height items to allow random-seeking into your list.
        ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(4,1)); // Tighten spacing
        if (copy_to_clipboard)
            ImGui::LogToClipboard();
        for (int i = 0; i < Items.Size; i++)
        {
            const char* item = Items[i];
            if (!Filter.PassFilter(item))
                continue;

            // Normally you would store more information in your item (e.g. make Items[] an array of structure, store color/type etc.)
            bool pop_color = false;
            if (strstr(item, "[error]"))            { ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 0.4f, 0.4f, 1.0f)); pop_color = true; }
            else if (strncmp(item, "# ", 2) == 0)   { ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 0.8f, 0.6f, 1.0f)); pop_color = true; }
            ImGui::TextUnformatted(item);
            if (pop_color)
                ImGui::PopStyleColor();
        }
        if (copy_to_clipboard)
            ImGui::LogFinish();
        if (ScrollToBottom)
            ImGui::SetScrollHereY(1.0f);
        ScrollToBottom = false;
        ImGui::PopStyleVar();
        ImGui::EndChild();
        ImGui::Separator();

        // Command-line
        bool reclaim_focus = false;
        if (ImGui::InputText("Input", InputBuf, IM_ARRAYSIZE(InputBuf), ImGuiInputTextFlags_EnterReturnsTrue|ImGuiInputTextFlags_CallbackCompletion|ImGuiInputTextFlags_CallbackHistory, &TextEditCallbackStub, (void*)this))
        {
            char* s = InputBuf;
            Strtrim(s);
            if (s[0])
                ExecCommand(s);
            strcpy(s, "");
            reclaim_focus = true;
        }

        // Auto-focus on window apparition
        ImGui::SetItemDefaultFocus();
        if (reclaim_focus)
            ImGui::SetKeyboardFocusHere(-1); // Auto focus previous widget

        ImGui::End();
    }

    void    ExecCommand(const char* command_line)
    {
        AddLog("# %s\n", command_line);

        // Insert into history. First find match and delete it so it can be pushed to the back. This isn't trying to be smart or optimal.
        HistoryPos = -1;
        for (int i = History.Size-1; i >= 0; i--)
            if (Stricmp(History[i], command_line) == 0)
            {
                free(History[i]);
                History.erase(History.begin() + i);
                break;
            }
        History.push_back(Strdup(command_line));

        // Process command
        if (Stricmp(command_line, "CLEAR") == 0)
        {
            ClearLog();
        }
        else if (Stricmp(command_line, "HELP") == 0)
        {
            AddLog("Commands:");
            for (int i = 0; i < Commands.Size; i++)
                AddLog("- %s", Commands[i]);
        }
        else if (Stricmp(command_line, "HISTORY") == 0)
        {
            int first = History.Size - 10;
            for (int i = first > 0 ? first : 0; i < History.Size; i++)
                AddLog("%3d: %s\n", i, History[i]);
        }
        else
        {
            AddLog("Unknown command: '%s'\n", command_line);
        }

        // On commad input, we scroll to bottom even if AutoScroll==false
        ScrollToBottom = true;
    }

    static int TextEditCallbackStub(ImGuiInputTextCallbackData* data) // In C++11 you are better off using lambdas for this sort of forwarding callbacks
    {
        ExampleAppConsole* console = (ExampleAppConsole*)data->UserData;
        return console->TextEditCallback(data);
    }

    int     TextEditCallback(ImGuiInputTextCallbackData* data)
    {
        //AddLog("cursor: %d, selection: %d-%d", data->CursorPos, data->SelectionStart, data->SelectionEnd);
        switch (data->EventFlag)
        {
        case ImGuiInputTextFlags_CallbackCompletion:
            {
                // Example of TEXT COMPLETION

                // Locate beginning of current word
                const char* word_end = data->Buf + data->CursorPos;
                const char* word_start = word_end;
                while (word_start > data->Buf)
                {
                    const char c = word_start[-1];
                    if (c == ' ' || c == '\t' || c == ',' || c == ';')
                        break;
                    word_start--;
                }

                // Build a list of candidates
                ImVector<const char*> candidates;
                for (int i = 0; i < Commands.Size; i++)
                    if (Strnicmp(Commands[i], word_start, (int)(word_end-word_start)) == 0)
                        candidates.push_back(Commands[i]);

                if (candidates.Size == 0)
                {
                    // No match
                    AddLog("No match for \"%.*s\"!\n", (int)(word_end-word_start), word_start);
                }
                else if (candidates.Size == 1)
                {
                    // Single match. Delete the beginning of the word and replace it entirely so we've got nice casing
                    data->DeleteChars((int)(word_start-data->Buf), (int)(word_end-word_start));
                    data->InsertChars(data->CursorPos, candidates[0]);
                    data->InsertChars(data->CursorPos, " ");
                }
                else
                {
                    // Multiple matches. Complete as much as we can, so inputing "C" will complete to "CL" and display "CLEAR" and "CLASSIFY"
                    int match_len = (int)(word_end - word_start);
                    for (;;)
                    {
                        int c = 0;
                        bool all_candidates_matches = true;
                        for (int i = 0; i < candidates.Size && all_candidates_matches; i++)
                            if (i == 0)
                                c = toupper(candidates[i][match_len]);
                            else if (c == 0 || c != toupper(candidates[i][match_len]))
                                all_candidates_matches = false;
                        if (!all_candidates_matches)
                            break;
                        match_len++;
                    }

                    if (match_len > 0)
                    {
                        data->DeleteChars((int)(word_start - data->Buf), (int)(word_end-word_start));
                        data->InsertChars(data->CursorPos, candidates[0], candidates[0] + match_len);
                    }

                    // List matches
                    AddLog("Possible matches:\n");
                    for (int i = 0; i < candidates.Size; i++)
                        AddLog("- %s\n", candidates[i]);
                }

                break;
            }
        case ImGuiInputTextFlags_CallbackHistory:
            {
                // Example of HISTORY
                const int prev_history_pos = HistoryPos;
                if (data->EventKey == ImGuiKey_UpArrow)
                {
                    if (HistoryPos == -1)
                        HistoryPos = History.Size - 1;
                    else if (HistoryPos > 0)
                        HistoryPos--;
                }
                else if (data->EventKey == ImGuiKey_DownArrow)
                {
                    if (HistoryPos != -1)
                        if (++HistoryPos >= History.Size)
                            HistoryPos = -1;
                }

                // A better implementation would preserve the data on the current input line along with cursor position.
                if (prev_history_pos != HistoryPos)
                {
                    const char* history_str = (HistoryPos >= 0) ? History[HistoryPos] : "";
                    data->DeleteChars(0, data->BufTextLen);
                    data->InsertChars(0, history_str);
                }
            }
        }
        return 0;
    }
};

static void ShowExampleAppConsole(bool* p_open)
{
    static ExampleAppConsole console;
    console.Draw("Example: Console", p_open);
}

//-----------------------------------------------------------------------------
// [SECTION] Example App: Debug Log / ShowExampleAppLog()
//-----------------------------------------------------------------------------

// Usage:
//  static ExampleAppLog my_log;
//  my_log.AddLog("Hello %d world\n", 123);
//  my_log.Draw("title");
struct ExampleAppLog
{
    ImGuiTextBuffer     Buf;
    ImGuiTextFilter     Filter;
    ImVector<int>       LineOffsets;        // Index to lines offset. We maintain this with AddLog() calls, allowing us to have a random access on lines
    bool                AutoScroll;
    bool                ScrollToBottom;

    ExampleAppLog()
    {
        AutoScroll = true;
        ScrollToBottom = false;
        Clear();
    }

    void    Clear()
    {
        Buf.clear();
        LineOffsets.clear();
        LineOffsets.push_back(0);
    }

    void    AddLog(const char* fmt, ...) IM_FMTARGS(2)
    {
        int old_size = Buf.size();
        va_list args;
        va_start(args, fmt);
        Buf.appendfv(fmt, args);
        va_end(args);
        for (int new_size = Buf.size(); old_size < new_size; old_size++)
            if (Buf[old_size] == '\n')
                LineOffsets.push_back(old_size + 1);
        if (AutoScroll)
            ScrollToBottom = true;
    }

    void    Draw(const char* title, bool* p_open = NULL)
    {
        if (!ImGui::Begin(title, p_open))
        {
            ImGui::End();
            return;
        }

        // Options menu
        if (ImGui::BeginPopup("Options"))
        {
            if (ImGui::Checkbox("Auto-scroll", &AutoScroll))
                if (AutoScroll)
                    ScrollToBottom = true;
            ImGui::EndPopup();
        }

        // Main window
        if (ImGui::Button("Options"))
            ImGui::OpenPopup("Options");
        ImGui::SameLine();
        bool clear = ImGui::Button("Clear");
        ImGui::SameLine();
        bool copy = ImGui::Button("Copy");
        ImGui::SameLine();
        Filter.Draw("Filter", -100.0f);

        ImGui::Separator();
        ImGui::BeginChild("scrolling", ImVec2(0,0), false, ImGuiWindowFlags_HorizontalScrollbar);

        if (clear)
            Clear();
        if (copy)
            ImGui::LogToClipboard();

        ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0, 0));
        const char* buf = Buf.begin();
        const char* buf_end = Buf.end();
        if (Filter.IsActive())
        {
            // In this example we don't use the clipper when Filter is enabled.
            // This is because we don't have a random access on the result on our filter.
            // A real application processing logs with ten of thousands of entries may want to store the result of search/filter.
            // especially if the filtering function is not trivial (e.g. reg-exp).
            for (int line_no = 0; line_no < LineOffsets.Size; line_no++)
            {
                const char* line_start = buf + LineOffsets[line_no];
                const char* line_end = (line_no + 1 < LineOffsets.Size) ? (buf + LineOffsets[line_no + 1] - 1) : buf_end;
                if (Filter.PassFilter(line_start, line_end))
                    ImGui::TextUnformatted(line_start, line_end);
            }
        }
        else
        {
            // The simplest and easy way to display the entire buffer:
            //   ImGui::TextUnformatted(buf_begin, buf_end);
            // And it'll just work. TextUnformatted() has specialization for large blob of text and will fast-forward to skip non-visible lines.
            // Here we instead demonstrate using the clipper to only process lines that are within the visible area.
            // If you have tens of thousands of items and their processing cost is non-negligible, coarse clipping them on your side is recommended.
            // Using ImGuiListClipper requires A) random access into your data, and B) items all being the  same height,
            // both of which we can handle since we an array pointing to the beginning of each line of text.
            // When using the filter (in the block of code above) we don't have random access into the data to display anymore, which is why we don't use the clipper.
            // Storing or skimming through the search result would make it possible (and would be recommended if you want to search through tens of thousands of entries)
            ImGuiListClipper clipper;
            clipper.Begin(LineOffsets.Size);
            while (clipper.Step())
            {
                for (int line_no = clipper.DisplayStart; line_no < clipper.DisplayEnd; line_no++)
                {
                    const char* line_start = buf + LineOffsets[line_no];
                    const char* line_end = (line_no + 1 < LineOffsets.Size) ? (buf + LineOffsets[line_no + 1] - 1) : buf_end;
                    ImGui::TextUnformatted(line_start, line_end);
                }
            }
            clipper.End();
        }
        ImGui::PopStyleVar();

        if (ScrollToBottom)
            ImGui::SetScrollHereY(1.0f);
        ScrollToBottom = false;
        ImGui::EndChild();
        ImGui::End();
    }
};

// Demonstrate creating a simple log window with basic filtering.
static void ShowExampleAppLog(bool* p_open)
{
    static ExampleAppLog log;

    // For the demo: add a debug button _BEFORE_ the normal log window contents
    // We take advantage of a rarely used feature: multiple calls to Begin()/End() are appending to the _same_ window.
    // Most of the contents of the window will be added by the log.Draw() call.
    ImGui::SetNextWindowSize(ImVec2(500, 400), ImGuiCond_FirstUseEver);
    ImGui::Begin("Example: Log", p_open);
    if (ImGui::SmallButton("[Debug] Add 5 entries"))
    {
        static int counter = 0;
        for (int n = 0; n < 5; n++)
        {
            const char* categories[3] = { "info", "warn", "error" };
            const char* words[] = { "Bumfuzzled", "Cattywampus", "Snickersnee", "Abibliophobia", "Absquatulate", "Nincompoop", "Pauciloquent" };
            log.AddLog("[%05d] [%s] Hello, current time is %.1f, here's a word: '%s'\n",
                ImGui::GetFrameCount(), categories[counter % IM_ARRAYSIZE(categories)], ImGui::GetTime(), words[counter % IM_ARRAYSIZE(words)]);
            counter++;
        }
    }
    ImGui::End();

    // Actually call in the regular Log helper (which will Begin() into the same window as we just did)
    log.Draw("Example: Log", p_open);
}

//-----------------------------------------------------------------------------
// [SECTION] Example App: Simple Layout / ShowExampleAppLayout()
//-----------------------------------------------------------------------------

// Demonstrate create a window with multiple child windows.
static void ShowExampleAppLayout(bool* p_open)
{
    ImGui::SetNextWindowSize(ImVec2(500, 440), ImGuiCond_FirstUseEver);
    if (ImGui::Begin("Example: Simple layout", p_open, ImGuiWindowFlags_MenuBar))
    {
        if (ImGui::BeginMenuBar())
        {
            if (ImGui::BeginMenu("File"))
            {
                if (ImGui::MenuItem("Close")) *p_open = false;
                ImGui::EndMenu();
            }
            ImGui::EndMenuBar();
        }

        // left
        static int selected = 0;
        ImGui::BeginChild("left pane", ImVec2(150, 0), true);
        for (int i = 0; i < 100; i++)
        {
            char label[128];
            sprintf(label, "MyObject %d", i);
            if (ImGui::Selectable(label, selected == i))
                selected = i;
        }
        ImGui::EndChild();
        ImGui::SameLine();

        // right
        ImGui::BeginGroup();
            ImGui::BeginChild("item view", ImVec2(0, -ImGui::GetFrameHeightWithSpacing())); // Leave room for 1 line below us
                ImGui::Text("MyObject: %d", selected);
                ImGui::Separator();
                if (ImGui::BeginTabBar("##Tabs", ImGuiTabBarFlags_None))
                {
                    if (ImGui::BeginTabItem("Description"))
                    {
                        ImGui::TextWrapped("Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. ");
                        ImGui::EndTabItem();
                    }
                    if (ImGui::BeginTabItem("Details"))
                    {
                        ImGui::Text("ID: 0123456789");
                        ImGui::EndTabItem();
                    }
                    ImGui::EndTabBar();
                }
            ImGui::EndChild();
            if (ImGui::Button("Revert")) {}
            ImGui::SameLine();
            if (ImGui::Button("Save")) {}
        ImGui::EndGroup();
    }
    ImGui::End();
}

//-----------------------------------------------------------------------------
// [SECTION] Example App: Property Editor / ShowExampleAppPropertyEditor()
//-----------------------------------------------------------------------------

// Demonstrate create a simple property editor.
static void ShowExampleAppPropertyEditor(bool* p_open)
{
    ImGui::SetNextWindowSize(ImVec2(430,450), ImGuiCond_FirstUseEver);
    if (!ImGui::Begin("Example: Property editor", p_open))
    {
        ImGui::End();
        return;
    }

    HelpMarker("This example shows how you may implement a property editor using two columns.\nAll objects/fields data are dummies here.\nRemember that in many simple cases, you can use ImGui::SameLine(xxx) to position\nyour cursor horizontally instead of using the Columns() API.");

    ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(2,2));
    ImGui::Columns(2);
    ImGui::Separator();

    struct funcs
    {
        static void ShowDummyObject(const char* prefix, int uid)
        {
            ImGui::PushID(uid);                      // Use object uid as identifier. Most commonly you could also use the object pointer as a base ID.
            ImGui::AlignTextToFramePadding();  // Text and Tree nodes are less high than regular widgets, here we add vertical spacing to make the tree lines equal high.
            bool node_open = ImGui::TreeNode("Object", "%s_%u", prefix, uid);
            ImGui::NextColumn();
            ImGui::AlignTextToFramePadding();
            ImGui::Text("my sailor is rich");
            ImGui::NextColumn();
            if (node_open)
            {
                static float dummy_members[8] = { 0.0f,0.0f,1.0f,3.1416f,100.0f,999.0f };
                for (int i = 0; i < 8; i++)
                {
                    ImGui::PushID(i); // Use field index as identifier.
                    if (i < 2)
                    {
                        ShowDummyObject("Child", 424242);
                    }
                    else
                    {
                        // Here we use a TreeNode to highlight on hover (we could use e.g. Selectable as well)
                        ImGui::AlignTextToFramePadding();
                        ImGui::TreeNodeEx("Field", ImGuiTreeNodeFlags_Leaf | ImGuiTreeNodeFlags_NoTreePushOnOpen | ImGuiTreeNodeFlags_Bullet, "Field_%d", i);
                        ImGui::NextColumn();
                        ImGui::SetNextItemWidth(-1);
                        if (i >= 5)
                            ImGui::InputFloat("##value", &dummy_members[i], 1.0f);
                        else
                            ImGui::DragFloat("##value", &dummy_members[i], 0.01f);
                        ImGui::NextColumn();
                    }
                    ImGui::PopID();
                }
                ImGui::TreePop();
            }
            ImGui::PopID();
        }
    };

    // Iterate dummy objects with dummy members (all the same data)
    for (int obj_i = 0; obj_i < 3; obj_i++)
        funcs::ShowDummyObject("Object", obj_i);

    ImGui::Columns(1);
    ImGui::Separator();
    ImGui::PopStyleVar();
    ImGui::End();
}

//-----------------------------------------------------------------------------
// [SECTION] Example App: Long Text / ShowExampleAppLongText()
//-----------------------------------------------------------------------------

// Demonstrate/test rendering huge amount of text, and the incidence of clipping.
static void ShowExampleAppLongText(bool* p_open)
{
    ImGui::SetNextWindowSize(ImVec2(520,600), ImGuiCond_FirstUseEver);
    if (!ImGui::Begin("Example: Long text display", p_open))
    {
        ImGui::End();
        return;
    }

    static int test_type = 0;
    static ImGuiTextBuffer log;
    static int lines = 0;
    ImGui::Text("Printing unusually long amount of text.");
    ImGui::Combo("Test type", &test_type, "Single call to TextUnformatted()\0Multiple calls to Text(), clipped manually\0Multiple calls to Text(), not clipped (slow)\0");
    ImGui::Text("Buffer contents: %d lines, %d bytes", lines, log.size());
    if (ImGui::Button("Clear")) { log.clear(); lines = 0; }
    ImGui::SameLine();
    if (ImGui::Button("Add 1000 lines"))
    {
        for (int i = 0; i < 1000; i++)
            log.appendf("%i The quick brown fox jumps over the lazy dog\n", lines+i);
        lines += 1000;
    }
    ImGui::BeginChild("Log");
    switch (test_type)
    {
    case 0:
        // Single call to TextUnformatted() with a big buffer
        ImGui::TextUnformatted(log.begin(), log.end());
        break;
    case 1:
        {
            // Multiple calls to Text(), manually coarsely clipped - demonstrate how to use the ImGuiListClipper helper.
            ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0,0));
            ImGuiListClipper clipper(lines);
            while (clipper.Step())
                for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)
                    ImGui::Text("%i The quick brown fox jumps over the lazy dog", i);
            ImGui::PopStyleVar();
            break;
        }
    case 2:
        // Multiple calls to Text(), not clipped (slow)
        ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0,0));
        for (int i = 0; i < lines; i++)
            ImGui::Text("%i The quick brown fox jumps over the lazy dog", i);
        ImGui::PopStyleVar();
        break;
    }
    ImGui::EndChild();
    ImGui::End();
}

//-----------------------------------------------------------------------------
// [SECTION] Example App: Auto Resize / ShowExampleAppAutoResize()
//-----------------------------------------------------------------------------

// Demonstrate creating a window which gets auto-resized according to its content.
static void ShowExampleAppAutoResize(bool* p_open)
{
    if (!ImGui::Begin("Example: Auto-resizing window", p_open, ImGuiWindowFlags_AlwaysAutoResize))
    {
        ImGui::End();
        return;
    }

    static int lines = 10;
    ImGui::Text("Window will resize every-frame to the size of its content.\nNote that you probably don't want to query the window size to\noutput your content because that would create a feedback loop.");
    ImGui::SliderInt("Number of lines", &lines, 1, 20);
    for (int i = 0; i < lines; i++)
        ImGui::Text("%*sThis is line %d", i * 4, "", i); // Pad with space to extend size horizontally
    ImGui::End();
}

//-----------------------------------------------------------------------------
// [SECTION] Example App: Constrained Resize / ShowExampleAppConstrainedResize()
//-----------------------------------------------------------------------------

// Demonstrate creating a window with custom resize constraints.
static void ShowExampleAppConstrainedResize(bool* p_open)
{
    struct CustomConstraints // Helper functions to demonstrate programmatic constraints
    {
        static void Square(ImGuiSizeCallbackData* data) { data->DesiredSize = ImVec2(IM_MAX(data->DesiredSize.x, data->DesiredSize.y), IM_MAX(data->DesiredSize.x, data->DesiredSize.y)); }
        static void Step(ImGuiSizeCallbackData* data)   { float step = (float)(int)(intptr_t)data->UserData; data->DesiredSize = ImVec2((int)(data->DesiredSize.x / step + 0.5f) * step, (int)(data->DesiredSize.y / step + 0.5f) * step); }
    };

    static bool auto_resize = false;
    static int type = 0;
    static int display_lines = 10;
    if (type == 0) ImGui::SetNextWindowSizeConstraints(ImVec2(-1, 0),    ImVec2(-1, FLT_MAX));      // Vertical only
    if (type == 1) ImGui::SetNextWindowSizeConstraints(ImVec2(0, -1),    ImVec2(FLT_MAX, -1));      // Horizontal only
    if (type == 2) ImGui::SetNextWindowSizeConstraints(ImVec2(100, 100), ImVec2(FLT_MAX, FLT_MAX)); // Width > 100, Height > 100
    if (type == 3) ImGui::SetNextWindowSizeConstraints(ImVec2(400, -1),  ImVec2(500, -1));          // Width 400-500
    if (type == 4) ImGui::SetNextWindowSizeConstraints(ImVec2(-1, 400),  ImVec2(-1, 500));          // Height 400-500
    if (type == 5) ImGui::SetNextWindowSizeConstraints(ImVec2(0, 0),     ImVec2(FLT_MAX, FLT_MAX), CustomConstraints::Square);                     // Always Square
    if (type == 6) ImGui::SetNextWindowSizeConstraints(ImVec2(0, 0),     ImVec2(FLT_MAX, FLT_MAX), CustomConstraints::Step, (void*)(intptr_t)100); // Fixed Step

    ImGuiWindowFlags flags = auto_resize ? ImGuiWindowFlags_AlwaysAutoResize : 0;
    if (ImGui::Begin("Example: Constrained Resize", p_open, flags))
    {
        const char* desc[] =
        {
            "Resize vertical only",
            "Resize horizontal only",
            "Width > 100, Height > 100",
            "Width 400-500",
            "Height 400-500",
            "Custom: Always Square",
            "Custom: Fixed Steps (100)",
        };
        if (ImGui::Button("200x200")) { ImGui::SetWindowSize(ImVec2(200, 200)); } ImGui::SameLine();
        if (ImGui::Button("500x500")) { ImGui::SetWindowSize(ImVec2(500, 500)); } ImGui::SameLine();
        if (ImGui::Button("800x200")) { ImGui::SetWindowSize(ImVec2(800, 200)); }
        ImGui::SetNextItemWidth(200);
        ImGui::Combo("Constraint", &type, desc, IM_ARRAYSIZE(desc));
        ImGui::SetNextItemWidth(200);
        ImGui::DragInt("Lines", &display_lines, 0.2f, 1, 100);
        ImGui::Checkbox("Auto-resize", &auto_resize);
        for (int i = 0; i < display_lines; i++)
            ImGui::Text("%*sHello, sailor! Making this line long enough for the example.", i * 4, "");
    }
    ImGui::End();
}

//-----------------------------------------------------------------------------
// [SECTION] Example App: Simple Overlay / ShowExampleAppSimpleOverlay()
//-----------------------------------------------------------------------------

// Demonstrate creating a simple static window with no decoration + a context-menu to choose which corner of the screen to use.
static void ShowExampleAppSimpleOverlay(bool* p_open)
{
    const float DISTANCE = 10.0f;
    static int corner = 0;
    ImGuiIO& io = ImGui::GetIO();
    if (corner != -1)
    {
        ImVec2 window_pos = ImVec2((corner & 1) ? io.DisplaySize.x - DISTANCE : DISTANCE, (corner & 2) ? io.DisplaySize.y - DISTANCE : DISTANCE);
        ImVec2 window_pos_pivot = ImVec2((corner & 1) ? 1.0f : 0.0f, (corner & 2) ? 1.0f : 0.0f);
        ImGui::SetNextWindowPos(window_pos, ImGuiCond_Always, window_pos_pivot);
    }
    ImGui::SetNextWindowBgAlpha(0.35f); // Transparent background
    if (ImGui::Begin("Example: Simple overlay", p_open, (corner != -1 ? ImGuiWindowFlags_NoMove : 0) | ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoNav))
    {
        ImGui::Text("Simple overlay\n" "in the corner of the screen.\n" "(right-click to change position)");
        ImGui::Separator();
        if (ImGui::IsMousePosValid())
            ImGui::Text("Mouse Position: (%.1f,%.1f)", io.MousePos.x, io.MousePos.y);
        else
            ImGui::Text("Mouse Position: <invalid>");
        if (ImGui::BeginPopupContextWindow())
        {
            if (ImGui::MenuItem("Custom",       NULL, corner == -1)) corner = -1;
            if (ImGui::MenuItem("Top-left",     NULL, corner == 0)) corner = 0;
            if (ImGui::MenuItem("Top-right",    NULL, corner == 1)) corner = 1;
            if (ImGui::MenuItem("Bottom-left",  NULL, corner == 2)) corner = 2;
            if (ImGui::MenuItem("Bottom-right", NULL, corner == 3)) corner = 3;
            if (p_open && ImGui::MenuItem("Close")) *p_open = false;
            ImGui::EndPopup();
        }
    }
    ImGui::End();
}

//-----------------------------------------------------------------------------
// [SECTION] Example App: Manipulating Window Titles / ShowExampleAppWindowTitles()
//-----------------------------------------------------------------------------

// Demonstrate using "##" and "###" in identifiers to manipulate ID generation.
// This apply to all regular items as well. Read FAQ section "How can I have multiple widgets with the same label? Can I have widget without a label? (Yes). A primer on the purpose of labels/IDs." for details.
static void ShowExampleAppWindowTitles(bool*)
{
    // By default, Windows are uniquely identified by their title.
    // You can use the "##" and "###" markers to manipulate the display/ID.

    // Using "##" to display same title but have unique identifier.
    ImGui::SetNextWindowPos(ImVec2(100, 100), ImGuiCond_FirstUseEver);
    ImGui::Begin("Same title as another window##1");
    ImGui::Text("This is window 1.\nMy title is the same as window 2, but my identifier is unique.");
    ImGui::End();

    ImGui::SetNextWindowPos(ImVec2(100, 200), ImGuiCond_FirstUseEver);
    ImGui::Begin("Same title as another window##2");
    ImGui::Text("This is window 2.\nMy title is the same as window 1, but my identifier is unique.");
    ImGui::End();

    // Using "###" to display a changing title but keep a static identifier "AnimatedTitle"
    char buf[128];
    sprintf(buf, "Animated title %c %d###AnimatedTitle", "|/-\\"[(int)(ImGui::GetTime() / 0.25f) & 3], ImGui::GetFrameCount());
    ImGui::SetNextWindowPos(ImVec2(100, 300), ImGuiCond_FirstUseEver);
    ImGui::Begin(buf);
    ImGui::Text("This window has a changing title.");
    ImGui::End();
}

//-----------------------------------------------------------------------------
// [SECTION] Example App: Custom Rendering using ImDrawList API / ShowExampleAppCustomRendering()
//-----------------------------------------------------------------------------

// Demonstrate using the low-level ImDrawList to draw custom shapes.
static void ShowExampleAppCustomRendering(bool* p_open)
{
    ImGui::SetNextWindowSize(ImVec2(350, 560), ImGuiCond_FirstUseEver);
    if (!ImGui::Begin("Example: Custom rendering", p_open))
    {
        ImGui::End();
        return;
    }

    // Tip: If you do a lot of custom rendering, you probably want to use your own geometrical types and benefit of overloaded operators, etc.
    // Define IM_VEC2_CLASS_EXTRA in imconfig.h to create implicit conversions between your types and ImVec2/ImVec4.
    // ImGui defines overloaded operators but they are internal to imgui.cpp and not exposed outside (to avoid messing with your types)
    // In this example we are not using the maths operators!
    ImDrawList* draw_list = ImGui::GetWindowDrawList();

    if (ImGui::BeginTabBar("##TabBar"))
    {
        // Primitives
        if (ImGui::BeginTabItem("Primitives"))
        {
            static float sz = 36.0f;
            static float thickness = 3.0f;
            static ImVec4 colf = ImVec4(1.0f, 1.0f, 0.4f, 1.0f);
            ImGui::DragFloat("Size", &sz, 0.2f, 2.0f, 72.0f, "%.0f");
            ImGui::DragFloat("Thickness", &thickness, 0.05f, 1.0f, 8.0f, "%.02f");
            ImGui::ColorEdit4("Color", &colf.x);
            const ImVec2 p = ImGui::GetCursorScreenPos();
            const ImU32 col = ImColor(colf);
            float x = p.x + 4.0f, y = p.y + 4.0f;
            float spacing = 10.0f;
            ImDrawCornerFlags corners_none = 0;
            ImDrawCornerFlags corners_all = ImDrawCornerFlags_All;
            ImDrawCornerFlags corners_tl_br = ImDrawCornerFlags_TopLeft | ImDrawCornerFlags_BotRight;
            for (int n = 0; n < 2; n++)
            {
                // First line uses a thickness of 1.0f, second line uses the configurable thickness
                float th = (n == 0) ? 1.0f : thickness;
                draw_list->AddCircle(ImVec2(x + sz*0.5f, y + sz*0.5f), sz*0.5f, col, 6, th);                x += sz + spacing;  // Hexagon
                draw_list->AddCircle(ImVec2(x + sz*0.5f, y + sz*0.5f), sz*0.5f, col, 20, th);               x += sz + spacing;  // Circle
                draw_list->AddRect(ImVec2(x, y), ImVec2(x + sz, y + sz), col, 0.0f,  corners_none, th);     x += sz + spacing;  // Square
                draw_list->AddRect(ImVec2(x, y), ImVec2(x + sz, y + sz), col, 10.0f, corners_all, th);      x += sz + spacing;  // Square with all rounded corners
                draw_list->AddRect(ImVec2(x, y), ImVec2(x + sz, y + sz), col, 10.0f, corners_tl_br, th);    x += sz + spacing;  // Square with two rounded corners
                draw_list->AddTriangle(ImVec2(x+sz*0.5f,y), ImVec2(x+sz, y+sz-0.5f), ImVec2(x, y+sz-0.5f), col, th);      x += sz + spacing;      // Triangle
                draw_list->AddTriangle(ImVec2(x+sz*0.2f,y), ImVec2(x, y+sz-0.5f), ImVec2(x+sz*0.4f, y+sz-0.5f), col, th); x += sz*0.4f + spacing; // Thin triangle
                draw_list->AddLine(ImVec2(x, y), ImVec2(x + sz, y), col, th);                               x += sz + spacing;  // Horizontal line (note: drawing a filled rectangle will be faster!)
                draw_list->AddLine(ImVec2(x, y), ImVec2(x, y + sz), col, th);                               x += spacing;       // Vertical line (note: drawing a filled rectangle will be faster!)
                draw_list->AddLine(ImVec2(x, y), ImVec2(x + sz, y + sz), col, th);                          x += sz + spacing;  // Diagonal line
                draw_list->AddBezierCurve(ImVec2(x, y), ImVec2(x + sz*1.3f, y + sz*0.3f), ImVec2(x + sz - sz*1.3f, y + sz - sz*0.3f), ImVec2(x + sz, y + sz), col, th);
                x = p.x + 4;
                y += sz + spacing;
            }
            draw_list->AddCircleFilled(ImVec2(x + sz*0.5f, y + sz*0.5f), sz*0.5f, col, 6);              x += sz + spacing;  // Hexagon
            draw_list->AddCircleFilled(ImVec2(x + sz*0.5f, y + sz*0.5f), sz*0.5f, col, 32);             x += sz + spacing;  // Circle
            draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x + sz, y + sz), col);                        x += sz + spacing;  // Square
            draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x + sz, y + sz), col, 10.0f);                 x += sz + spacing;  // Square with all rounded corners
            draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x + sz, y + sz), col, 10.0f, corners_tl_br);  x += sz + spacing;  // Square with two rounded corners
            draw_list->AddTriangleFilled(ImVec2(x+sz*0.5f,y), ImVec2(x+sz, y+sz-0.5f), ImVec2(x, y+sz-0.5f), col);      x += sz + spacing;      // Triangle
            draw_list->AddTriangleFilled(ImVec2(x+sz*0.2f,y), ImVec2(x, y+sz-0.5f), ImVec2(x+sz*0.4f, y+sz-0.5f), col); x += sz*0.4f + spacing; // Thin triangle
            draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x + sz, y + thickness), col);                 x += sz + spacing;  // Horizontal line (faster than AddLine, but only handle integer thickness)
            draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x + thickness, y + sz), col);                 x += spacing*2.0f;  // Vertical line (faster than AddLine, but only handle integer thickness)
            draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x + 1, y + 1), col);                          x += sz;            // Pixel (faster than AddLine)
            draw_list->AddRectFilledMultiColor(ImVec2(x, y), ImVec2(x + sz, y + sz), IM_COL32(0, 0, 0, 255), IM_COL32(255, 0, 0, 255), IM_COL32(255, 255, 0, 255), IM_COL32(0, 255, 0, 255));
            ImGui::Dummy(ImVec2((sz + spacing) * 9.8f, (sz + spacing) * 3));
            ImGui::EndTabItem();
        }

        if (ImGui::BeginTabItem("Canvas"))
        {
            static ImVector<ImVec2> points;
            static bool adding_line = false;
            if (ImGui::Button("Clear")) points.clear();
            if (points.Size >= 2) { ImGui::SameLine(); if (ImGui::Button("Undo")) { points.pop_back(); points.pop_back(); } }
            ImGui::Text("Left-click and drag to add lines,\nRight-click to undo");

            // Here we are using InvisibleButton() as a convenience to 1) advance the cursor and 2) allows us to use IsItemHovered()
            // But you can also draw directly and poll mouse/keyboard by yourself. You can manipulate the cursor using GetCursorPos() and SetCursorPos().
            // If you only use the ImDrawList API, you can notify the owner window of its extends by using SetCursorPos(max).
            ImVec2 canvas_pos = ImGui::GetCursorScreenPos();            // ImDrawList API uses screen coordinates!
            ImVec2 canvas_size = ImGui::GetContentRegionAvail();        // Resize canvas to what's available
            if (canvas_size.x < 50.0f) canvas_size.x = 50.0f;
            if (canvas_size.y < 50.0f) canvas_size.y = 50.0f;
            draw_list->AddRectFilledMultiColor(canvas_pos, ImVec2(canvas_pos.x + canvas_size.x, canvas_pos.y + canvas_size.y), IM_COL32(50, 50, 50, 255), IM_COL32(50, 50, 60, 255), IM_COL32(60, 60, 70, 255), IM_COL32(50, 50, 60, 255));
            draw_list->AddRect(canvas_pos, ImVec2(canvas_pos.x + canvas_size.x, canvas_pos.y + canvas_size.y), IM_COL32(255, 255, 255, 255));

            bool adding_preview = false;
            ImGui::InvisibleButton("canvas", canvas_size);
            ImVec2 mouse_pos_in_canvas = ImVec2(ImGui::GetIO().MousePos.x - canvas_pos.x, ImGui::GetIO().MousePos.y - canvas_pos.y);
            if (adding_line)
            {
                adding_preview = true;
                points.push_back(mouse_pos_in_canvas);
                if (!ImGui::IsMouseDown(0))
                    adding_line = adding_preview = false;
            }
            if (ImGui::IsItemHovered())
            {
                if (!adding_line && ImGui::IsMouseClicked(0))
                {
                    points.push_back(mouse_pos_in_canvas);
                    adding_line = true;
                }
                if (ImGui::IsMouseClicked(1) && !points.empty())
                {
                    adding_line = adding_preview = false;
                    points.pop_back();
                    points.pop_back();
                }
            }
            draw_list->PushClipRect(canvas_pos, ImVec2(canvas_pos.x + canvas_size.x, canvas_pos.y + canvas_size.y), true);      // clip lines within the canvas (if we resize it, etc.)
            for (int i = 0; i < points.Size - 1; i += 2)
                draw_list->AddLine(ImVec2(canvas_pos.x + points[i].x, canvas_pos.y + points[i].y), ImVec2(canvas_pos.x + points[i + 1].x, canvas_pos.y + points[i + 1].y), IM_COL32(255, 255, 0, 255), 2.0f);
            draw_list->PopClipRect();
            if (adding_preview)
                points.pop_back();
            ImGui::EndTabItem();
        }

        if (ImGui::BeginTabItem("BG/FG draw lists"))
        {
            static bool draw_bg = true;
            static bool draw_fg = true;
            ImGui::Checkbox("Draw in Background draw list", &draw_bg);
            ImGui::Checkbox("Draw in Foreground draw list", &draw_fg);
            ImVec2 window_pos = ImGui::GetWindowPos();
            ImVec2 window_size = ImGui::GetWindowSize();
            ImVec2 window_center = ImVec2(window_pos.x + window_size.x * 0.5f, window_pos.y + window_size.y * 0.5f);
            if (draw_bg)
                ImGui::GetBackgroundDrawList()->AddCircle(window_center, window_size.x * 0.6f, IM_COL32(255, 0, 0, 200), 32, 10+4);
            if (draw_fg)
                ImGui::GetForegroundDrawList()->AddCircle(window_center, window_size.y * 0.6f, IM_COL32(0, 255, 0, 200), 32, 10);
            ImGui::EndTabItem();
        }

        ImGui::EndTabBar();
    }

    ImGui::End();
}

//-----------------------------------------------------------------------------
// [SECTION] Example App: Documents Handling / ShowExampleAppDocuments()
//-----------------------------------------------------------------------------

// Simplified structure to mimic a Document model
struct MyDocument
{
    const char* Name;           // Document title
    bool        Open;           // Set when the document is open (in this demo, we keep an array of all available documents to simplify the demo)
    bool        OpenPrev;       // Copy of Open from last update.
    bool        Dirty;          // Set when the document has been modified
    bool        WantClose;      // Set when the document
    ImVec4      Color;          // An arbitrary variable associated to the document

    MyDocument(const char* name, bool open = true, const ImVec4& color = ImVec4(1.0f,1.0f,1.0f,1.0f))
    {
        Name = name;
        Open = OpenPrev = open;
        Dirty = false;
        WantClose = false;
        Color = color;
    }
    void DoOpen()       { Open = true; }
    void DoQueueClose() { WantClose = true; }
    void DoForceClose() { Open = false; Dirty = false; }
    void DoSave()       { Dirty = false; }

    // Display dummy contents for the Document
    static void DisplayContents(MyDocument* doc)
    {
        ImGui::PushID(doc);
        ImGui::Text("Document \"%s\"", doc->Name);
        ImGui::PushStyleColor(ImGuiCol_Text, doc->Color);
        ImGui::TextWrapped("Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.");
        ImGui::PopStyleColor();
        if (ImGui::Button("Modify", ImVec2(100, 0)))
            doc->Dirty = true;
        ImGui::SameLine();
        if (ImGui::Button("Save", ImVec2(100, 0)))
            doc->DoSave();
        ImGui::ColorEdit3("color", &doc->Color.x);  // Useful to test drag and drop and hold-dragged-to-open-tab behavior.
        ImGui::PopID();
    }

    // Display context menu for the Document
    static void DisplayContextMenu(MyDocument* doc)
    {
        if (!ImGui::BeginPopupContextItem())
            return;

        char buf[256];
        sprintf(buf, "Save %s", doc->Name);
        if (ImGui::MenuItem(buf, "CTRL+S", false, doc->Open))
            doc->DoSave();
        if (ImGui::MenuItem("Close", "CTRL+W", false, doc->Open))
            doc->DoQueueClose();
        ImGui::EndPopup();
    }
};

struct ExampleAppDocuments
{
    ImVector<MyDocument> Documents;

    ExampleAppDocuments()
    {
        Documents.push_back(MyDocument("Lettuce",             true,  ImVec4(0.4f, 0.8f, 0.4f, 1.0f)));
        Documents.push_back(MyDocument("Eggplant",            true,  ImVec4(0.8f, 0.5f, 1.0f, 1.0f)));
        Documents.push_back(MyDocument("Carrot",              true,  ImVec4(1.0f, 0.8f, 0.5f, 1.0f)));
        Documents.push_back(MyDocument("Tomato",              false, ImVec4(1.0f, 0.3f, 0.4f, 1.0f)));
        Documents.push_back(MyDocument("A Rather Long Title", false));
        Documents.push_back(MyDocument("Some Document",       false));
    }
};

// [Optional] Notify the system of Tabs/Windows closure that happened outside the regular tab interface.
// If a tab has been closed programmatically (aka closed from another source such as the Checkbox() in the demo, as opposed
// to clicking on the regular tab closing button) and stops being submitted, it will take a frame for the tab bar to notice its absence.
// During this frame there will be a gap in the tab bar, and if the tab that has disappeared was the selected one, the tab bar
// will report no selected tab during the frame. This will effectively give the impression of a flicker for one frame.
// We call SetTabItemClosed() to manually notify the Tab Bar or Docking system of removed tabs to avoid this glitch.
// Note that this completely optional, and only affect tab bars with the ImGuiTabBarFlags_Reorderable flag.
static void NotifyOfDocumentsClosedElsewhere(ExampleAppDocuments& app)
{
    for (int doc_n = 0; doc_n < app.Documents.Size; doc_n++)
    {
        MyDocument* doc = &app.Documents[doc_n];
        if (!doc->Open && doc->OpenPrev)
            ImGui::SetTabItemClosed(doc->Name);
        doc->OpenPrev = doc->Open;
    }
}

void ShowExampleAppDocuments(bool* p_open)
{
    static ExampleAppDocuments app;

    // Options
    static bool opt_reorderable = true;
    static ImGuiTabBarFlags opt_fitting_flags = ImGuiTabBarFlags_FittingPolicyDefault_;

    if (!ImGui::Begin("Example: Documents", p_open, ImGuiWindowFlags_MenuBar))
    {
        ImGui::End();
        return;
    }

    // Menu
    if (ImGui::BeginMenuBar())
    {
        if (ImGui::BeginMenu("File"))
        {
            int open_count = 0;
            for (int doc_n = 0; doc_n < app.Documents.Size; doc_n++)
                open_count += app.Documents[doc_n].Open ? 1 : 0;

            if (ImGui::BeginMenu("Open", open_count < app.Documents.Size))
            {
                for (int doc_n = 0; doc_n < app.Documents.Size; doc_n++)
                {
                    MyDocument* doc = &app.Documents[doc_n];
                    if (!doc->Open)
                        if (ImGui::MenuItem(doc->Name))
                            doc->DoOpen();
                }
                ImGui::EndMenu();
            }
            if (ImGui::MenuItem("Close All Documents", NULL, false, open_count > 0))
                for (int doc_n = 0; doc_n < app.Documents.Size; doc_n++)
                    app.Documents[doc_n].DoQueueClose();
            if (ImGui::MenuItem("Exit", "Alt+F4")) {}
            ImGui::EndMenu();
        }
        ImGui::EndMenuBar();
    }

    // [Debug] List documents with one checkbox for each
    for (int doc_n = 0; doc_n < app.Documents.Size; doc_n++)
    {
        MyDocument* doc = &app.Documents[doc_n];
        if (doc_n > 0)
            ImGui::SameLine();
        ImGui::PushID(doc);
        if (ImGui::Checkbox(doc->Name, &doc->Open))
            if (!doc->Open)
                doc->DoForceClose();
        ImGui::PopID();
    }

    ImGui::Separator();

    // Submit Tab Bar and Tabs
    {
        ImGuiTabBarFlags tab_bar_flags = (opt_fitting_flags) | (opt_reorderable ? ImGuiTabBarFlags_Reorderable : 0);
        if (ImGui::BeginTabBar("##tabs", tab_bar_flags))
        {
            if (opt_reorderable)
                NotifyOfDocumentsClosedElsewhere(app);

            // [DEBUG] Stress tests
            //if ((ImGui::GetFrameCount() % 30) == 0) docs[1].Open ^= 1;            // [DEBUG] Automatically show/hide a tab. Test various interactions e.g. dragging with this on.
            //if (ImGui::GetIO().KeyCtrl) ImGui::SetTabItemSelected(docs[1].Name);  // [DEBUG] Test SetTabItemSelected(), probably not very useful as-is anyway..

            // Submit Tabs
            for (int doc_n = 0; doc_n < app.Documents.Size; doc_n++)
            {
                MyDocument* doc = &app.Documents[doc_n];
                if (!doc->Open)
                    continue;

                ImGuiTabItemFlags tab_flags = (doc->Dirty ? ImGuiTabItemFlags_UnsavedDocument : 0);
                bool visible = ImGui::BeginTabItem(doc->Name, &doc->Open, tab_flags);

                // Cancel attempt to close when unsaved add to save queue so we can display a popup.
                if (!doc->Open && doc->Dirty)
                {
                    doc->Open = true;
                    doc->DoQueueClose();
                }

                MyDocument::DisplayContextMenu(doc);
                if (visible)
                {
                    MyDocument::DisplayContents(doc);
                    ImGui::EndTabItem();
                }
            }

            ImGui::EndTabBar();
        }
    }

    // Update closing queue
    static ImVector<MyDocument*> close_queue;
    if (close_queue.empty())
    {
        // Close queue is locked once we started a popup
        for (int doc_n = 0; doc_n < app.Documents.Size; doc_n++)
        {
            MyDocument* doc = &app.Documents[doc_n];
            if (doc->WantClose)
            {
                doc->WantClose = false;
                close_queue.push_back(doc);
            }
        }
    }

    // Display closing confirmation UI
    if (!close_queue.empty())
    {
        int close_queue_unsaved_documents = 0;
        for (int n = 0; n < close_queue.Size; n++)
            if (close_queue[n]->Dirty)
                close_queue_unsaved_documents++;

        if (close_queue_unsaved_documents == 0)
        {
            // Close documents when all are unsaved
            for (int n = 0; n < close_queue.Size; n++)
                close_queue[n]->DoForceClose();
            close_queue.clear();
        }
        else
        {
            if (!ImGui::IsPopupOpen("Save?"))
                ImGui::OpenPopup("Save?");
            if (ImGui::BeginPopupModal("Save?"))
            {
                ImGui::Text("Save change to the following items?");
                ImGui::SetNextItemWidth(-1.0f);
                if (ImGui::ListBoxHeader("##", close_queue_unsaved_documents, 6))
                {
                    for (int n = 0; n < close_queue.Size; n++)
                        if (close_queue[n]->Dirty)
                            ImGui::Text("%s", close_queue[n]->Name);
                    ImGui::ListBoxFooter();
                }

                if (ImGui::Button("Yes", ImVec2(80, 0)))
                {
                    for (int n = 0; n < close_queue.Size; n++)
                    {
                        if (close_queue[n]->Dirty)
                            close_queue[n]->DoSave();
                        close_queue[n]->DoForceClose();
                    }
                    close_queue.clear();
                    ImGui::CloseCurrentPopup();
                }
                ImGui::SameLine();
                if (ImGui::Button("No", ImVec2(80, 0)))
                {
                    for (int n = 0; n < close_queue.Size; n++)
                        close_queue[n]->DoForceClose();
                    close_queue.clear();
                    ImGui::CloseCurrentPopup();
                }
                ImGui::SameLine();
                if (ImGui::Button("Cancel", ImVec2(80, 0)))
                {
                    close_queue.clear();
                    ImGui::CloseCurrentPopup();
                }
                ImGui::EndPopup();
            }
        }
    }

    ImGui::End();
}

// End of Demo code
#else

void ImGui::ShowAboutWindow(bool*) {}
void ImGui::ShowDemoWindow(bool*) {}
void ImGui::ShowUserGuide() {}
void ImGui::ShowStyleEditor(ImGuiStyle*) {}

#endif

```

`UnrealFinderTool/ImGUI/imgui_draw.cpp`:

```cpp
// dear imgui, v1.70
// (drawing and font code)

/*

Index of this file:

// [SECTION] STB libraries implementation
// [SECTION] Style functions
// [SECTION] ImDrawList
// [SECTION] ImDrawData
// [SECTION] Helpers ShadeVertsXXX functions
// [SECTION] ImFontConfig
// [SECTION] ImFontAtlas
// [SECTION] ImFontAtlas glyph ranges helpers
// [SECTION] ImFontGlyphRangesBuilder
// [SECTION] ImFont
// [SECTION] Internal Render Helpers
// [SECTION] Decompression code
// [SECTION] Default font data (ProggyClean.ttf)

*/

#include "pch.h"
#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS
#endif

#include "imgui.h"
#ifndef IMGUI_DEFINE_MATH_OPERATORS
#define IMGUI_DEFINE_MATH_OPERATORS
#endif
#include "imgui_internal.h"

#include <stdio.h>      // vsnprintf, sscanf, printf
#if !defined(alloca)
#if defined(__GLIBC__) || defined(__sun) || defined(__CYGWIN__) || defined(__APPLE__)
#include <alloca.h>     // alloca (glibc uses <alloca.h>. Note that Cygwin may have _WIN32 defined, so the order matters here)
#elif defined(_WIN32)
#include <malloc.h>     // alloca
#if !defined(alloca)
#define alloca _alloca  // for clang with MS Codegen
#endif
#else
#include <stdlib.h>     // alloca
#endif
#endif

// Visual Studio warnings
#ifdef _MSC_VER
#pragma warning (disable: 4505) // unreferenced local function has been removed (stb stuff)
#pragma warning (disable: 4996) // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen
#endif

// Clang/GCC warnings with -Weverything
#ifdef __clang__
#pragma clang diagnostic ignored "-Wold-style-cast"         // warning : use of old-style cast                              // yes, they are more terse.
#pragma clang diagnostic ignored "-Wfloat-equal"            // warning : comparing floating point with == or != is unsafe   // storing and comparing against same constants ok.
#pragma clang diagnostic ignored "-Wglobal-constructors"    // warning : declaration requires a global destructor           // similar to above, not sure what the exact difference is.
#pragma clang diagnostic ignored "-Wsign-conversion"        // warning : implicit conversion changes signedness             //
#if __has_warning("-Wzero-as-null-pointer-constant")
#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"  // warning : zero as null pointer constant              // some standard header variations use #define NULL 0
#endif
#if __has_warning("-Wcomma")
#pragma clang diagnostic ignored "-Wcomma"                  // warning : possible misuse of comma operator here             //
#endif
#if __has_warning("-Wreserved-id-macro")
#pragma clang diagnostic ignored "-Wreserved-id-macro"      // warning : macro name is a reserved identifier                //
#endif
#if __has_warning("-Wdouble-promotion")
#pragma clang diagnostic ignored "-Wdouble-promotion"       // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.
#endif
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wunused-function"          // warning: 'xxxx' defined but not used
#pragma GCC diagnostic ignored "-Wdouble-promotion"         // warning: implicit conversion from 'float' to 'double' when passing argument to function
#pragma GCC diagnostic ignored "-Wconversion"               // warning: conversion to 'xxxx' from 'xxxx' may alter its value
#pragma GCC diagnostic ignored "-Wstack-protector"          // warning: stack protector not protecting local variables: variable length buffer
#if __GNUC__ >= 8
#pragma GCC diagnostic ignored "-Wclass-memaccess"          // warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead
#endif
#endif

//-------------------------------------------------------------------------
// [SECTION] STB libraries implementation
//-------------------------------------------------------------------------

// Compile time options:
//#define IMGUI_STB_NAMESPACE           ImStb
//#define IMGUI_STB_TRUETYPE_FILENAME   "my_folder/stb_truetype.h"
//#define IMGUI_STB_RECT_PACK_FILENAME  "my_folder/stb_rect_pack.h"
//#define IMGUI_DISABLE_STB_TRUETYPE_IMPLEMENTATION
//#define IMGUI_DISABLE_STB_RECT_PACK_IMPLEMENTATION

#ifdef IMGUI_STB_NAMESPACE
namespace IMGUI_STB_NAMESPACE
{
#endif

#ifdef _MSC_VER
#pragma warning (push)
#pragma warning (disable: 4456)                             // declaration of 'xx' hides previous local declaration
#endif

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-function"
#pragma clang diagnostic ignored "-Wmissing-prototypes"
#pragma clang diagnostic ignored "-Wimplicit-fallthrough"
#pragma clang diagnostic ignored "-Wcast-qual"              // warning : cast from 'const xxxx *' to 'xxx *' drops const qualifier //
#endif

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wtype-limits"              // warning: comparison is always true due to limited range of data type [-Wtype-limits]
#pragma GCC diagnostic ignored "-Wcast-qual"                // warning: cast from type 'const xxxx *' to type 'xxxx *' casts away qualifiers
#endif

#ifndef STB_RECT_PACK_IMPLEMENTATION                        // in case the user already have an implementation in the _same_ compilation unit (e.g. unity builds)
#ifndef IMGUI_DISABLE_STB_RECT_PACK_IMPLEMENTATION
#define STBRP_STATIC
#define STBRP_ASSERT(x)     IM_ASSERT(x)
#define STBRP_SORT          ImQsort
#define STB_RECT_PACK_IMPLEMENTATION
#endif
#ifdef IMGUI_STB_RECT_PACK_FILENAME
#include IMGUI_STB_RECT_PACK_FILENAME
#else
#include "imstb_rectpack.h"
#endif
#endif

#ifndef STB_TRUETYPE_IMPLEMENTATION                         // in case the user already have an implementation in the _same_ compilation unit (e.g. unity builds)
#ifndef IMGUI_DISABLE_STB_TRUETYPE_IMPLEMENTATION
#define STBTT_malloc(x,u)   ((void)(u), IM_ALLOC(x))
#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
#define STBTT_assert(x)     IM_ASSERT(x)
#define STBTT_fmod(x,y)     ImFmod(x,y)
#define STBTT_sqrt(x)       ImSqrt(x)
#define STBTT_pow(x,y)      ImPow(x,y)
#define STBTT_fabs(x)       ImFabs(x)
#define STBTT_ifloor(x)     ((int)ImFloorStd(x))
#define STBTT_iceil(x)      ((int)ImCeil(x))
#define STBTT_STATIC
#define STB_TRUETYPE_IMPLEMENTATION
#else
#define STBTT_DEF extern
#endif
#ifdef IMGUI_STB_TRUETYPE_FILENAME
#include IMGUI_STB_TRUETYPE_FILENAME
#else
#include "imstb_truetype.h"
#endif
#endif

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif

#ifdef __clang__
#pragma clang diagnostic pop
#endif

#ifdef _MSC_VER
#pragma warning (pop)
#endif

#ifdef IMGUI_STB_NAMESPACE
} // namespace ImStb
using namespace IMGUI_STB_NAMESPACE;
#endif

//-----------------------------------------------------------------------------
// [SECTION] Style functions
//-----------------------------------------------------------------------------

void ImGui::StyleColorsDark(ImGuiStyle* dst)
{
    ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();
    ImVec4* colors = style->Colors;

    colors[ImGuiCol_Text]                   = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);
    colors[ImGuiCol_TextDisabled]           = ImVec4(0.50f, 0.50f, 0.50f, 1.00f);
    colors[ImGuiCol_WindowBg]               = ImVec4(0.06f, 0.06f, 0.06f, 0.94f);
    colors[ImGuiCol_ChildBg]                = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
    colors[ImGuiCol_PopupBg]                = ImVec4(0.08f, 0.08f, 0.08f, 0.94f);
    colors[ImGuiCol_Border]                 = ImVec4(0.43f, 0.43f, 0.50f, 0.50f);
    colors[ImGuiCol_BorderShadow]           = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
    colors[ImGuiCol_FrameBg]                = ImVec4(0.16f, 0.29f, 0.48f, 0.54f);
    colors[ImGuiCol_FrameBgHovered]         = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
    colors[ImGuiCol_FrameBgActive]          = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
    colors[ImGuiCol_TitleBg]                = ImVec4(0.04f, 0.04f, 0.04f, 1.00f);
    colors[ImGuiCol_TitleBgActive]          = ImVec4(0.16f, 0.29f, 0.48f, 1.00f);
    colors[ImGuiCol_TitleBgCollapsed]       = ImVec4(0.00f, 0.00f, 0.00f, 0.51f);
    colors[ImGuiCol_MenuBarBg]              = ImVec4(0.14f, 0.14f, 0.14f, 1.00f);
    colors[ImGuiCol_ScrollbarBg]            = ImVec4(0.02f, 0.02f, 0.02f, 0.53f);
    colors[ImGuiCol_ScrollbarGrab]          = ImVec4(0.31f, 0.31f, 0.31f, 1.00f);
    colors[ImGuiCol_ScrollbarGrabHovered]   = ImVec4(0.41f, 0.41f, 0.41f, 1.00f);
    colors[ImGuiCol_ScrollbarGrabActive]    = ImVec4(0.51f, 0.51f, 0.51f, 1.00f);
    colors[ImGuiCol_CheckMark]              = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
    colors[ImGuiCol_SliderGrab]             = ImVec4(0.24f, 0.52f, 0.88f, 1.00f);
    colors[ImGuiCol_SliderGrabActive]       = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
    colors[ImGuiCol_Button]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
    colors[ImGuiCol_ButtonHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
    colors[ImGuiCol_ButtonActive]           = ImVec4(0.06f, 0.53f, 0.98f, 1.00f);
    colors[ImGuiCol_Header]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.31f);
    colors[ImGuiCol_HeaderHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 0.80f);
    colors[ImGuiCol_HeaderActive]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
    colors[ImGuiCol_Separator]              = colors[ImGuiCol_Border];
    colors[ImGuiCol_SeparatorHovered]       = ImVec4(0.10f, 0.40f, 0.75f, 0.78f);
    colors[ImGuiCol_SeparatorActive]        = ImVec4(0.10f, 0.40f, 0.75f, 1.00f);
    colors[ImGuiCol_ResizeGrip]             = ImVec4(0.26f, 0.59f, 0.98f, 0.25f);
    colors[ImGuiCol_ResizeGripHovered]      = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
    colors[ImGuiCol_ResizeGripActive]       = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);
    colors[ImGuiCol_Tab]                    = ImLerp(colors[ImGuiCol_Header],       colors[ImGuiCol_TitleBgActive], 0.80f);
    colors[ImGuiCol_TabHovered]             = colors[ImGuiCol_HeaderHovered];
    colors[ImGuiCol_TabActive]              = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);
    colors[ImGuiCol_TabUnfocused]           = ImLerp(colors[ImGuiCol_Tab],          colors[ImGuiCol_TitleBg], 0.80f);
    colors[ImGuiCol_TabUnfocusedActive]     = ImLerp(colors[ImGuiCol_TabActive],    colors[ImGuiCol_TitleBg], 0.40f);
    colors[ImGuiCol_PlotLines]              = ImVec4(0.61f, 0.61f, 0.61f, 1.00f);
    colors[ImGuiCol_PlotLinesHovered]       = ImVec4(1.00f, 0.43f, 0.35f, 1.00f);
    colors[ImGuiCol_PlotHistogram]          = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);
    colors[ImGuiCol_PlotHistogramHovered]   = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);
    colors[ImGuiCol_TextSelectedBg]         = ImVec4(0.26f, 0.59f, 0.98f, 0.35f);
    colors[ImGuiCol_DragDropTarget]         = ImVec4(1.00f, 1.00f, 0.00f, 0.90f);
    colors[ImGuiCol_NavHighlight]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
    colors[ImGuiCol_NavWindowingHighlight]  = ImVec4(1.00f, 1.00f, 1.00f, 0.70f);
    colors[ImGuiCol_NavWindowingDimBg]      = ImVec4(0.80f, 0.80f, 0.80f, 0.20f);
    colors[ImGuiCol_ModalWindowDimBg]       = ImVec4(0.80f, 0.80f, 0.80f, 0.35f);
}

void ImGui::StyleColorsClassic(ImGuiStyle* dst)
{
    ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();
    ImVec4* colors = style->Colors;

    colors[ImGuiCol_Text]                   = ImVec4(0.90f, 0.90f, 0.90f, 1.00f);
    colors[ImGuiCol_TextDisabled]           = ImVec4(0.60f, 0.60f, 0.60f, 1.00f);
    colors[ImGuiCol_WindowBg]               = ImVec4(0.00f, 0.00f, 0.00f, 0.70f);
    colors[ImGuiCol_ChildBg]                = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
    colors[ImGuiCol_PopupBg]                = ImVec4(0.11f, 0.11f, 0.14f, 0.92f);
    colors[ImGuiCol_Border]                 = ImVec4(0.50f, 0.50f, 0.50f, 0.50f);
    colors[ImGuiCol_BorderShadow]           = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
    colors[ImGuiCol_FrameBg]                = ImVec4(0.43f, 0.43f, 0.43f, 0.39f);
    colors[ImGuiCol_FrameBgHovered]         = ImVec4(0.47f, 0.47f, 0.69f, 0.40f);
    colors[ImGuiCol_FrameBgActive]          = ImVec4(0.42f, 0.41f, 0.64f, 0.69f);
    colors[ImGuiCol_TitleBg]                = ImVec4(0.27f, 0.27f, 0.54f, 0.83f);
    colors[ImGuiCol_TitleBgActive]          = ImVec4(0.32f, 0.32f, 0.63f, 0.87f);
    colors[ImGuiCol_TitleBgCollapsed]       = ImVec4(0.40f, 0.40f, 0.80f, 0.20f);
    colors[ImGuiCol_MenuBarBg]              = ImVec4(0.40f, 0.40f, 0.55f, 0.80f);
    colors[ImGuiCol_ScrollbarBg]            = ImVec4(0.20f, 0.25f, 0.30f, 0.60f);
    colors[ImGuiCol_ScrollbarGrab]          = ImVec4(0.40f, 0.40f, 0.80f, 0.30f);
    colors[ImGuiCol_ScrollbarGrabHovered]   = ImVec4(0.40f, 0.40f, 0.80f, 0.40f);
    colors[ImGuiCol_ScrollbarGrabActive]    = ImVec4(0.41f, 0.39f, 0.80f, 0.60f);
    colors[ImGuiCol_CheckMark]              = ImVec4(0.90f, 0.90f, 0.90f, 0.50f);
    colors[ImGuiCol_SliderGrab]             = ImVec4(1.00f, 1.00f, 1.00f, 0.30f);
    colors[ImGuiCol_SliderGrabActive]       = ImVec4(0.41f, 0.39f, 0.80f, 0.60f);
    colors[ImGuiCol_Button]                 = ImVec4(0.35f, 0.40f, 0.61f, 0.62f);
    colors[ImGuiCol_ButtonHovered]          = ImVec4(0.40f, 0.48f, 0.71f, 0.79f);
    colors[ImGuiCol_ButtonActive]           = ImVec4(0.46f, 0.54f, 0.80f, 1.00f);
    colors[ImGuiCol_Header]                 = ImVec4(0.40f, 0.40f, 0.90f, 0.45f);
    colors[ImGuiCol_HeaderHovered]          = ImVec4(0.45f, 0.45f, 0.90f, 0.80f);
    colors[ImGuiCol_HeaderActive]           = ImVec4(0.53f, 0.53f, 0.87f, 0.80f);
    colors[ImGuiCol_Separator]              = ImVec4(0.50f, 0.50f, 0.50f, 1.00f);
    colors[ImGuiCol_SeparatorHovered]       = ImVec4(0.60f, 0.60f, 0.70f, 1.00f);
    colors[ImGuiCol_SeparatorActive]        = ImVec4(0.70f, 0.70f, 0.90f, 1.00f);
    colors[ImGuiCol_ResizeGrip]             = ImVec4(1.00f, 1.00f, 1.00f, 0.16f);
    colors[ImGuiCol_ResizeGripHovered]      = ImVec4(0.78f, 0.82f, 1.00f, 0.60f);
    colors[ImGuiCol_ResizeGripActive]       = ImVec4(0.78f, 0.82f, 1.00f, 0.90f);
    colors[ImGuiCol_Tab]                    = ImLerp(colors[ImGuiCol_Header],       colors[ImGuiCol_TitleBgActive], 0.80f);
    colors[ImGuiCol_TabHovered]             = colors[ImGuiCol_HeaderHovered];
    colors[ImGuiCol_TabActive]              = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);
    colors[ImGuiCol_TabUnfocused]           = ImLerp(colors[ImGuiCol_Tab],          colors[ImGuiCol_TitleBg], 0.80f);
    colors[ImGuiCol_TabUnfocusedActive]     = ImLerp(colors[ImGuiCol_TabActive],    colors[ImGuiCol_TitleBg], 0.40f);
    colors[ImGuiCol_PlotLines]              = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);
    colors[ImGuiCol_PlotLinesHovered]       = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);
    colors[ImGuiCol_PlotHistogram]          = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);
    colors[ImGuiCol_PlotHistogramHovered]   = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);
    colors[ImGuiCol_TextSelectedBg]         = ImVec4(0.00f, 0.00f, 1.00f, 0.35f);
    colors[ImGuiCol_DragDropTarget]         = ImVec4(1.00f, 1.00f, 0.00f, 0.90f);
    colors[ImGuiCol_NavHighlight]           = colors[ImGuiCol_HeaderHovered];
    colors[ImGuiCol_NavWindowingHighlight]  = ImVec4(1.00f, 1.00f, 1.00f, 0.70f);
    colors[ImGuiCol_NavWindowingDimBg]      = ImVec4(0.80f, 0.80f, 0.80f, 0.20f);
    colors[ImGuiCol_ModalWindowDimBg]       = ImVec4(0.20f, 0.20f, 0.20f, 0.35f);
}

// Those light colors are better suited with a thicker font than the default one + FrameBorder
void ImGui::StyleColorsLight(ImGuiStyle* dst)
{
    ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();
    ImVec4* colors = style->Colors;

    colors[ImGuiCol_Text]                   = ImVec4(0.00f, 0.00f, 0.00f, 1.00f);
    colors[ImGuiCol_TextDisabled]           = ImVec4(0.60f, 0.60f, 0.60f, 1.00f);
    colors[ImGuiCol_WindowBg]               = ImVec4(0.94f, 0.94f, 0.94f, 1.00f);
    colors[ImGuiCol_ChildBg]                = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
    colors[ImGuiCol_PopupBg]                = ImVec4(1.00f, 1.00f, 1.00f, 0.98f);
    colors[ImGuiCol_Border]                 = ImVec4(0.00f, 0.00f, 0.00f, 0.30f);
    colors[ImGuiCol_BorderShadow]           = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
    colors[ImGuiCol_FrameBg]                = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);
    colors[ImGuiCol_FrameBgHovered]         = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
    colors[ImGuiCol_FrameBgActive]          = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
    colors[ImGuiCol_TitleBg]                = ImVec4(0.96f, 0.96f, 0.96f, 1.00f);
    colors[ImGuiCol_TitleBgActive]          = ImVec4(0.82f, 0.82f, 0.82f, 1.00f);
    colors[ImGuiCol_TitleBgCollapsed]       = ImVec4(1.00f, 1.00f, 1.00f, 0.51f);
    colors[ImGuiCol_MenuBarBg]              = ImVec4(0.86f, 0.86f, 0.86f, 1.00f);
    colors[ImGuiCol_ScrollbarBg]            = ImVec4(0.98f, 0.98f, 0.98f, 0.53f);
    colors[ImGuiCol_ScrollbarGrab]          = ImVec4(0.69f, 0.69f, 0.69f, 0.80f);
    colors[ImGuiCol_ScrollbarGrabHovered]   = ImVec4(0.49f, 0.49f, 0.49f, 0.80f);
    colors[ImGuiCol_ScrollbarGrabActive]    = ImVec4(0.49f, 0.49f, 0.49f, 1.00f);
    colors[ImGuiCol_CheckMark]              = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
    colors[ImGuiCol_SliderGrab]             = ImVec4(0.26f, 0.59f, 0.98f, 0.78f);
    colors[ImGuiCol_SliderGrabActive]       = ImVec4(0.46f, 0.54f, 0.80f, 0.60f);
    colors[ImGuiCol_Button]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
    colors[ImGuiCol_ButtonHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
    colors[ImGuiCol_ButtonActive]           = ImVec4(0.06f, 0.53f, 0.98f, 1.00f);
    colors[ImGuiCol_Header]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.31f);
    colors[ImGuiCol_HeaderHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 0.80f);
    colors[ImGuiCol_HeaderActive]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
    colors[ImGuiCol_Separator]              = ImVec4(0.39f, 0.39f, 0.39f, 1.00f);
    colors[ImGuiCol_SeparatorHovered]       = ImVec4(0.14f, 0.44f, 0.80f, 0.78f);
    colors[ImGuiCol_SeparatorActive]        = ImVec4(0.14f, 0.44f, 0.80f, 1.00f);
    colors[ImGuiCol_ResizeGrip]             = ImVec4(0.80f, 0.80f, 0.80f, 0.56f);
    colors[ImGuiCol_ResizeGripHovered]      = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
    colors[ImGuiCol_ResizeGripActive]       = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);
    colors[ImGuiCol_Tab]                    = ImLerp(colors[ImGuiCol_Header],       colors[ImGuiCol_TitleBgActive], 0.90f);
    colors[ImGuiCol_TabHovered]             = colors[ImGuiCol_HeaderHovered];
    colors[ImGuiCol_TabActive]              = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);
    colors[ImGuiCol_TabUnfocused]           = ImLerp(colors[ImGuiCol_Tab],          colors[ImGuiCol_TitleBg], 0.80f);
    colors[ImGuiCol_TabUnfocusedActive]     = ImLerp(colors[ImGuiCol_TabActive],    colors[ImGuiCol_TitleBg], 0.40f);
    colors[ImGuiCol_PlotLines]              = ImVec4(0.39f, 0.39f, 0.39f, 1.00f);
    colors[ImGuiCol_PlotLinesHovered]       = ImVec4(1.00f, 0.43f, 0.35f, 1.00f);
    colors[ImGuiCol_PlotHistogram]          = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);
    colors[ImGuiCol_PlotHistogramHovered]   = ImVec4(1.00f, 0.45f, 0.00f, 1.00f);
    colors[ImGuiCol_TextSelectedBg]         = ImVec4(0.26f, 0.59f, 0.98f, 0.35f);
    colors[ImGuiCol_DragDropTarget]         = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);
    colors[ImGuiCol_NavHighlight]           = colors[ImGuiCol_HeaderHovered];
    colors[ImGuiCol_NavWindowingHighlight]  = ImVec4(0.70f, 0.70f, 0.70f, 0.70f);
    colors[ImGuiCol_NavWindowingDimBg]      = ImVec4(0.20f, 0.20f, 0.20f, 0.20f);
    colors[ImGuiCol_ModalWindowDimBg]       = ImVec4(0.20f, 0.20f, 0.20f, 0.35f);
}

//-----------------------------------------------------------------------------
// ImDrawList
//-----------------------------------------------------------------------------

ImDrawListSharedData::ImDrawListSharedData()
{
    Font = NULL;
    FontSize = 0.0f;
    CurveTessellationTol = 0.0f;
    ClipRectFullscreen = ImVec4(-8192.0f, -8192.0f, +8192.0f, +8192.0f);

    // Const data
    for (int i = 0; i < IM_ARRAYSIZE(CircleVtx12); i++)
    {
        const float a = ((float)i * 2 * IM_PI) / (float)IM_ARRAYSIZE(CircleVtx12);
        CircleVtx12[i] = ImVec2(ImCos(a), ImSin(a));
    }
}

void ImDrawList::Clear()
{
    CmdBuffer.resize(0);
    IdxBuffer.resize(0);
    VtxBuffer.resize(0);
    Flags = ImDrawListFlags_AntiAliasedLines | ImDrawListFlags_AntiAliasedFill;
    _VtxCurrentIdx = 0;
    _VtxWritePtr = NULL;
    _IdxWritePtr = NULL;
    _ClipRectStack.resize(0);
    _TextureIdStack.resize(0);
    _Path.resize(0);
    _ChannelsCurrent = 0;
    _ChannelsCount = 1;
    // NB: Do not clear channels so our allocations are re-used after the first frame.
}

void ImDrawList::ClearFreeMemory()
{
    CmdBuffer.clear();
    IdxBuffer.clear();
    VtxBuffer.clear();
    _VtxCurrentIdx = 0;
    _VtxWritePtr = NULL;
    _IdxWritePtr = NULL;
    _ClipRectStack.clear();
    _TextureIdStack.clear();
    _Path.clear();
    _ChannelsCurrent = 0;
    _ChannelsCount = 1;
    for (int i = 0; i < _Channels.Size; i++)
    {
        if (i == 0) memset(&_Channels[0], 0, sizeof(_Channels[0]));  // channel 0 is a copy of CmdBuffer/IdxBuffer, don't destruct again
        _Channels[i].CmdBuffer.clear();
        _Channels[i].IdxBuffer.clear();
    }
    _Channels.clear();
}

ImDrawList* ImDrawList::CloneOutput() const
{
    ImDrawList* dst = IM_NEW(ImDrawList(NULL));
    dst->CmdBuffer = CmdBuffer;
    dst->IdxBuffer = IdxBuffer;
    dst->VtxBuffer = VtxBuffer;
    dst->Flags = Flags;
    return dst;
}

// Using macros because C++ is a terrible language, we want guaranteed inline, no code in header, and no overhead in Debug builds
#define GetCurrentClipRect()    (_ClipRectStack.Size ? _ClipRectStack.Data[_ClipRectStack.Size-1]  : _Data->ClipRectFullscreen)
#define GetCurrentTextureId()   (_TextureIdStack.Size ? _TextureIdStack.Data[_TextureIdStack.Size-1] : (ImTextureID)NULL)

void ImDrawList::AddDrawCmd()
{
    ImDrawCmd draw_cmd;
    draw_cmd.ClipRect = GetCurrentClipRect();
    draw_cmd.TextureId = GetCurrentTextureId();

    IM_ASSERT(draw_cmd.ClipRect.x <= draw_cmd.ClipRect.z && draw_cmd.ClipRect.y <= draw_cmd.ClipRect.w);
    CmdBuffer.push_back(draw_cmd);
}

void ImDrawList::AddCallback(ImDrawCallback callback, void* callback_data)
{
    ImDrawCmd* current_cmd = CmdBuffer.Size ? &CmdBuffer.back() : NULL;
    if (!current_cmd || current_cmd->ElemCount != 0 || current_cmd->UserCallback != NULL)
    {
        AddDrawCmd();
        current_cmd = &CmdBuffer.back();
    }
    current_cmd->UserCallback = callback;
    current_cmd->UserCallbackData = callback_data;

    AddDrawCmd(); // Force a new command after us (see comment below)
}

// Our scheme may appears a bit unusual, basically we want the most-common calls AddLine AddRect etc. to not have to perform any check so we always have a command ready in the stack.
// The cost of figuring out if a new command has to be added or if we can merge is paid in those Update** functions only.
void ImDrawList::UpdateClipRect()
{
    // If current command is used with different settings we need to add a new command
    const ImVec4 curr_clip_rect = GetCurrentClipRect();
    ImDrawCmd* curr_cmd = CmdBuffer.Size > 0 ? &CmdBuffer.Data[CmdBuffer.Size-1] : NULL;
    if (!curr_cmd || (curr_cmd->ElemCount != 0 && memcmp(&curr_cmd->ClipRect, &curr_clip_rect, sizeof(ImVec4)) != 0) || curr_cmd->UserCallback != NULL)
    {
        AddDrawCmd();
        return;
    }

    // Try to merge with previous command if it matches, else use current command
    ImDrawCmd* prev_cmd = CmdBuffer.Size > 1 ? curr_cmd - 1 : NULL;
    if (curr_cmd->ElemCount == 0 && prev_cmd && memcmp(&prev_cmd->ClipRect, &curr_clip_rect, sizeof(ImVec4)) == 0 && prev_cmd->TextureId == GetCurrentTextureId() && prev_cmd->UserCallback == NULL)
        CmdBuffer.pop_back();
    else
        curr_cmd->ClipRect = curr_clip_rect;
}

void ImDrawList::UpdateTextureID()
{
    // If current command is used with different settings we need to add a new command
    const ImTextureID curr_texture_id = GetCurrentTextureId();
    ImDrawCmd* curr_cmd = CmdBuffer.Size ? &CmdBuffer.back() : NULL;
    if (!curr_cmd || (curr_cmd->ElemCount != 0 && curr_cmd->TextureId != curr_texture_id) || curr_cmd->UserCallback != NULL)
    {
        AddDrawCmd();
        return;
    }

    // Try to merge with previous command if it matches, else use current command
    ImDrawCmd* prev_cmd = CmdBuffer.Size > 1 ? curr_cmd - 1 : NULL;
    if (curr_cmd->ElemCount == 0 && prev_cmd && prev_cmd->TextureId == curr_texture_id && memcmp(&prev_cmd->ClipRect, &GetCurrentClipRect(), sizeof(ImVec4)) == 0 && prev_cmd->UserCallback == NULL)
        CmdBuffer.pop_back();
    else
        curr_cmd->TextureId = curr_texture_id;
}

#undef GetCurrentClipRect
#undef GetCurrentTextureId

// Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)
void ImDrawList::PushClipRect(ImVec2 cr_min, ImVec2 cr_max, bool intersect_with_current_clip_rect)
{
    ImVec4 cr(cr_min.x, cr_min.y, cr_max.x, cr_max.y);
    if (intersect_with_current_clip_rect && _ClipRectStack.Size)
    {
        ImVec4 current = _ClipRectStack.Data[_ClipRectStack.Size-1];
        if (cr.x < current.x) cr.x = current.x;
        if (cr.y < current.y) cr.y = current.y;
        if (cr.z > current.z) cr.z = current.z;
        if (cr.w > current.w) cr.w = current.w;
    }
    cr.z = ImMax(cr.x, cr.z);
    cr.w = ImMax(cr.y, cr.w);

    _ClipRectStack.push_back(cr);
    UpdateClipRect();
}

void ImDrawList::PushClipRectFullScreen()
{
    PushClipRect(ImVec2(_Data->ClipRectFullscreen.x, _Data->ClipRectFullscreen.y), ImVec2(_Data->ClipRectFullscreen.z, _Data->ClipRectFullscreen.w));
}

void ImDrawList::PopClipRect()
{
    IM_ASSERT(_ClipRectStack.Size > 0);
    _ClipRectStack.pop_back();
    UpdateClipRect();
}

void ImDrawList::PushTextureID(ImTextureID texture_id)
{
    _TextureIdStack.push_back(texture_id);
    UpdateTextureID();
}

void ImDrawList::PopTextureID()
{
    IM_ASSERT(_TextureIdStack.Size > 0);
    _TextureIdStack.pop_back();
    UpdateTextureID();
}

void ImDrawList::ChannelsSplit(int channels_count)
{
    IM_ASSERT(_ChannelsCurrent == 0 && _ChannelsCount == 1);
    int old_channels_count = _Channels.Size;
    if (old_channels_count < channels_count)
        _Channels.resize(channels_count);
    _ChannelsCount = channels_count;

    // _Channels[] (24/32 bytes each) hold storage that we'll swap with this->_CmdBuffer/_IdxBuffer
    // The content of _Channels[0] at this point doesn't matter. We clear it to make state tidy in a debugger but we don't strictly need to.
    // When we switch to the next channel, we'll copy _CmdBuffer/_IdxBuffer into _Channels[0] and then _Channels[1] into _CmdBuffer/_IdxBuffer
    memset(&_Channels[0], 0, sizeof(ImDrawChannel));
    for (int i = 1; i < channels_count; i++)
    {
        if (i >= old_channels_count)
        {
            IM_PLACEMENT_NEW(&_Channels[i]) ImDrawChannel();
        }
        else
        {
            _Channels[i].CmdBuffer.resize(0);
            _Channels[i].IdxBuffer.resize(0);
        }
        if (_Channels[i].CmdBuffer.Size == 0)
        {
            ImDrawCmd draw_cmd;
            draw_cmd.ClipRect = _ClipRectStack.back();
            draw_cmd.TextureId = _TextureIdStack.back();
            _Channels[i].CmdBuffer.push_back(draw_cmd);
        }
    }
}

void ImDrawList::ChannelsMerge()
{
    // Note that we never use or rely on channels.Size because it is merely a buffer that we never shrink back to 0 to keep all sub-buffers ready for use.
    if (_ChannelsCount <= 1)
        return;

    ChannelsSetCurrent(0);
    if (CmdBuffer.Size && CmdBuffer.back().ElemCount == 0)
        CmdBuffer.pop_back();

    int new_cmd_buffer_count = 0, new_idx_buffer_count = 0;
    for (int i = 1; i < _ChannelsCount; i++)
    {
        ImDrawChannel& ch = _Channels[i];
        if (ch.CmdBuffer.Size && ch.CmdBuffer.back().ElemCount == 0)
            ch.CmdBuffer.pop_back();
        new_cmd_buffer_count += ch.CmdBuffer.Size;
        new_idx_buffer_count += ch.IdxBuffer.Size;
    }
    CmdBuffer.resize(CmdBuffer.Size + new_cmd_buffer_count);
    IdxBuffer.resize(IdxBuffer.Size + new_idx_buffer_count);

    ImDrawCmd* cmd_write = CmdBuffer.Data + CmdBuffer.Size - new_cmd_buffer_count;
    _IdxWritePtr = IdxBuffer.Data + IdxBuffer.Size - new_idx_buffer_count;
    for (int i = 1; i < _ChannelsCount; i++)
    {
        ImDrawChannel& ch = _Channels[i];
        if (int sz = ch.CmdBuffer.Size) { memcpy(cmd_write, ch.CmdBuffer.Data, sz * sizeof(ImDrawCmd)); cmd_write += sz; }
        if (int sz = ch.IdxBuffer.Size) { memcpy(_IdxWritePtr, ch.IdxBuffer.Data, sz * sizeof(ImDrawIdx)); _IdxWritePtr += sz; }
    }
    UpdateClipRect(); // We call this instead of AddDrawCmd(), so that empty channels won't produce an extra draw call.
    _ChannelsCount = 1;
}

void ImDrawList::ChannelsSetCurrent(int idx)
{
    IM_ASSERT(idx < _ChannelsCount);
    if (_ChannelsCurrent == idx) return;
    memcpy(&_Channels.Data[_ChannelsCurrent].CmdBuffer, &CmdBuffer, sizeof(CmdBuffer)); // copy 12 bytes, four times
    memcpy(&_Channels.Data[_ChannelsCurrent].IdxBuffer, &IdxBuffer, sizeof(IdxBuffer));
    _ChannelsCurrent = idx;
    memcpy(&CmdBuffer, &_Channels.Data[_ChannelsCurrent].CmdBuffer, sizeof(CmdBuffer));
    memcpy(&IdxBuffer, &_Channels.Data[_ChannelsCurrent].IdxBuffer, sizeof(IdxBuffer));
    _IdxWritePtr = IdxBuffer.Data + IdxBuffer.Size;
}

// NB: this can be called with negative count for removing primitives (as long as the result does not underflow)
void ImDrawList::PrimReserve(int idx_count, int vtx_count)
{
    ImDrawCmd& draw_cmd = CmdBuffer.Data[CmdBuffer.Size-1];
    draw_cmd.ElemCount += idx_count;

    int vtx_buffer_old_size = VtxBuffer.Size;
    VtxBuffer.resize(vtx_buffer_old_size + vtx_count);
    _VtxWritePtr = VtxBuffer.Data + vtx_buffer_old_size;

    int idx_buffer_old_size = IdxBuffer.Size;
    IdxBuffer.resize(idx_buffer_old_size + idx_count);
    _IdxWritePtr = IdxBuffer.Data + idx_buffer_old_size;
}

// Fully unrolled with inline call to keep our debug builds decently fast.
void ImDrawList::PrimRect(const ImVec2& a, const ImVec2& c, ImU32 col)
{
    ImVec2 b(c.x, a.y), d(a.x, c.y), uv(_Data->TexUvWhitePixel);
    ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;
    _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);
    _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);
    _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;
    _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col;
    _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col;
    _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv; _VtxWritePtr[3].col = col;
    _VtxWritePtr += 4;
    _VtxCurrentIdx += 4;
    _IdxWritePtr += 6;
}

void ImDrawList::PrimRectUV(const ImVec2& a, const ImVec2& c, const ImVec2& uv_a, const ImVec2& uv_c, ImU32 col)
{
    ImVec2 b(c.x, a.y), d(a.x, c.y), uv_b(uv_c.x, uv_a.y), uv_d(uv_a.x, uv_c.y);
    ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;
    _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);
    _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);
    _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv_a; _VtxWritePtr[0].col = col;
    _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv_b; _VtxWritePtr[1].col = col;
    _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv_c; _VtxWritePtr[2].col = col;
    _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv_d; _VtxWritePtr[3].col = col;
    _VtxWritePtr += 4;
    _VtxCurrentIdx += 4;
    _IdxWritePtr += 6;
}

void ImDrawList::PrimQuadUV(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col)
{
    ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;
    _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);
    _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);
    _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv_a; _VtxWritePtr[0].col = col;
    _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv_b; _VtxWritePtr[1].col = col;
    _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv_c; _VtxWritePtr[2].col = col;
    _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv_d; _VtxWritePtr[3].col = col;
    _VtxWritePtr += 4;
    _VtxCurrentIdx += 4;
    _IdxWritePtr += 6;
}

// On AddPolyline() and AddConvexPolyFilled() we intentionally avoid using ImVec2 and superflous function calls to optimize debug/non-inlined builds.
// Those macros expects l-values.
#define IM_NORMALIZE2F_OVER_ZERO(VX,VY)     { float d2 = VX*VX + VY*VY; if (d2 > 0.0f) { float inv_len = 1.0f / ImSqrt(d2); VX *= inv_len; VY *= inv_len; } }
#define IM_FIXNORMAL2F(VX,VY)               { float d2 = VX*VX + VY*VY; if (d2 < 0.5f) d2 = 0.5f; float inv_lensq = 1.0f / d2; VX *= inv_lensq; VY *= inv_lensq; }

// TODO: Thickness anti-aliased lines cap are missing their AA fringe.
// We avoid using the ImVec2 math operators here to reduce cost to a minimum for debug/non-inlined builds.
void ImDrawList::AddPolyline(const ImVec2* points, const int points_count, ImU32 col, bool closed, float thickness)
{
    if (points_count < 2)
        return;

    const ImVec2 uv = _Data->TexUvWhitePixel;

    int count = points_count;
    if (!closed)
        count = points_count-1;

    const bool thick_line = thickness > 1.0f;
    if (Flags & ImDrawListFlags_AntiAliasedLines)
    {
        // Anti-aliased stroke
        const float AA_SIZE = 1.0f;
        const ImU32 col_trans = col & ~IM_COL32_A_MASK;

        const int idx_count = thick_line ? count*18 : count*12;
        const int vtx_count = thick_line ? points_count*4 : points_count*3;
        PrimReserve(idx_count, vtx_count);

        // Temporary buffer
        ImVec2* temp_normals = (ImVec2*)alloca(points_count * (thick_line ? 5 : 3) * sizeof(ImVec2)); //-V630
        ImVec2* temp_points = temp_normals + points_count;

        for (int i1 = 0; i1 < count; i1++)
        {
            const int i2 = (i1+1) == points_count ? 0 : i1+1;
            float dx = points[i2].x - points[i1].x;
            float dy = points[i2].y - points[i1].y;
            IM_NORMALIZE2F_OVER_ZERO(dx, dy);
            temp_normals[i1].x = dy;
            temp_normals[i1].y = -dx;
        }
        if (!closed)
            temp_normals[points_count-1] = temp_normals[points_count-2];

        if (!thick_line)
        {
            if (!closed)
            {
                temp_points[0] = points[0] + temp_normals[0] * AA_SIZE;
                temp_points[1] = points[0] - temp_normals[0] * AA_SIZE;
                temp_points[(points_count-1)*2+0] = points[points_count-1] + temp_normals[points_count-1] * AA_SIZE;
                temp_points[(points_count-1)*2+1] = points[points_count-1] - temp_normals[points_count-1] * AA_SIZE;
            }

            // FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.
            unsigned int idx1 = _VtxCurrentIdx;
            for (int i1 = 0; i1 < count; i1++)
            {
                const int i2 = (i1+1) == points_count ? 0 : i1+1;
                unsigned int idx2 = (i1+1) == points_count ? _VtxCurrentIdx : idx1+3;

                // Average normals
                float dm_x = (temp_normals[i1].x + temp_normals[i2].x) * 0.5f;
                float dm_y = (temp_normals[i1].y + temp_normals[i2].y) * 0.5f;
                IM_FIXNORMAL2F(dm_x, dm_y)
                dm_x *= AA_SIZE;
                dm_y *= AA_SIZE;

                // Add temporary vertexes
                ImVec2* out_vtx = &temp_points[i2*2];
                out_vtx[0].x = points[i2].x + dm_x;
                out_vtx[0].y = points[i2].y + dm_y;
                out_vtx[1].x = points[i2].x - dm_x;
                out_vtx[1].y = points[i2].y - dm_y;

                // Add indexes
                _IdxWritePtr[0] = (ImDrawIdx)(idx2+0); _IdxWritePtr[1] = (ImDrawIdx)(idx1+0); _IdxWritePtr[2] = (ImDrawIdx)(idx1+2);
                _IdxWritePtr[3] = (ImDrawIdx)(idx1+2); _IdxWritePtr[4] = (ImDrawIdx)(idx2+2); _IdxWritePtr[5] = (ImDrawIdx)(idx2+0);
                _IdxWritePtr[6] = (ImDrawIdx)(idx2+1); _IdxWritePtr[7] = (ImDrawIdx)(idx1+1); _IdxWritePtr[8] = (ImDrawIdx)(idx1+0);
                _IdxWritePtr[9] = (ImDrawIdx)(idx1+0); _IdxWritePtr[10]= (ImDrawIdx)(idx2+0); _IdxWritePtr[11]= (ImDrawIdx)(idx2+1);
                _IdxWritePtr += 12;

                idx1 = idx2;
            }

            // Add vertexes
            for (int i = 0; i < points_count; i++)
            {
                _VtxWritePtr[0].pos = points[i];          _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;
                _VtxWritePtr[1].pos = temp_points[i*2+0]; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;
                _VtxWritePtr[2].pos = temp_points[i*2+1]; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col_trans;
                _VtxWritePtr += 3;
            }
        }
        else
        {
            const float half_inner_thickness = (thickness - AA_SIZE) * 0.5f;
            if (!closed)
            {
                temp_points[0] = points[0] + temp_normals[0] * (half_inner_thickness + AA_SIZE);
                temp_points[1] = points[0] + temp_normals[0] * (half_inner_thickness);
                temp_points[2] = points[0] - temp_normals[0] * (half_inner_thickness);
                temp_points[3] = points[0] - temp_normals[0] * (half_inner_thickness + AA_SIZE);
                temp_points[(points_count-1)*4+0] = points[points_count-1] + temp_normals[points_count-1] * (half_inner_thickness + AA_SIZE);
                temp_points[(points_count-1)*4+1] = points[points_count-1] + temp_normals[points_count-1] * (half_inner_thickness);
                temp_points[(points_count-1)*4+2] = points[points_count-1] - temp_normals[points_count-1] * (half_inner_thickness);
                temp_points[(points_count-1)*4+3] = points[points_count-1] - temp_normals[points_count-1] * (half_inner_thickness + AA_SIZE);
            }

            // FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.
            unsigned int idx1 = _VtxCurrentIdx;
            for (int i1 = 0; i1 < count; i1++)
            {
                const int i2 = (i1+1) == points_count ? 0 : i1+1;
                unsigned int idx2 = (i1+1) == points_count ? _VtxCurrentIdx : idx1+4;

                // Average normals
                float dm_x = (temp_normals[i1].x + temp_normals[i2].x) * 0.5f;
                float dm_y = (temp_normals[i1].y + temp_normals[i2].y) * 0.5f;
                IM_FIXNORMAL2F(dm_x, dm_y);
                float dm_out_x = dm_x * (half_inner_thickness + AA_SIZE);
                float dm_out_y = dm_y * (half_inner_thickness + AA_SIZE);
                float dm_in_x = dm_x * half_inner_thickness;
                float dm_in_y = dm_y * half_inner_thickness;

                // Add temporary vertexes
                ImVec2* out_vtx = &temp_points[i2*4];
                out_vtx[0].x = points[i2].x + dm_out_x;
                out_vtx[0].y = points[i2].y + dm_out_y;
                out_vtx[1].x = points[i2].x + dm_in_x;
                out_vtx[1].y = points[i2].y + dm_in_y;
                out_vtx[2].x = points[i2].x - dm_in_x;
                out_vtx[2].y = points[i2].y - dm_in_y;
                out_vtx[3].x = points[i2].x - dm_out_x;
                out_vtx[3].y = points[i2].y - dm_out_y;

                // Add indexes
                _IdxWritePtr[0]  = (ImDrawIdx)(idx2+1); _IdxWritePtr[1]  = (ImDrawIdx)(idx1+1); _IdxWritePtr[2]  = (ImDrawIdx)(idx1+2);
                _IdxWritePtr[3]  = (ImDrawIdx)(idx1+2); _IdxWritePtr[4]  = (ImDrawIdx)(idx2+2); _IdxWritePtr[5]  = (ImDrawIdx)(idx2+1);
                _IdxWritePtr[6]  = (ImDrawIdx)(idx2+1); _IdxWritePtr[7]  = (ImDrawIdx)(idx1+1); _IdxWritePtr[8]  = (ImDrawIdx)(idx1+0);
                _IdxWritePtr[9]  = (ImDrawIdx)(idx1+0); _IdxWritePtr[10] = (ImDrawIdx)(idx2+0); _IdxWritePtr[11] = (ImDrawIdx)(idx2+1);
                _IdxWritePtr[12] = (ImDrawIdx)(idx2+2); _IdxWritePtr[13] = (ImDrawIdx)(idx1+2); _IdxWritePtr[14] = (ImDrawIdx)(idx1+3);
                _IdxWritePtr[15] = (ImDrawIdx)(idx1+3); _IdxWritePtr[16] = (ImDrawIdx)(idx2+3); _IdxWritePtr[17] = (ImDrawIdx)(idx2+2);
                _IdxWritePtr += 18;

                idx1 = idx2;
            }

            // Add vertexes
            for (int i = 0; i < points_count; i++)
            {
                _VtxWritePtr[0].pos = temp_points[i*4+0]; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col_trans;
                _VtxWritePtr[1].pos = temp_points[i*4+1]; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col;
                _VtxWritePtr[2].pos = temp_points[i*4+2]; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col;
                _VtxWritePtr[3].pos = temp_points[i*4+3]; _VtxWritePtr[3].uv = uv; _VtxWritePtr[3].col = col_trans;
                _VtxWritePtr += 4;
            }
        }
        _VtxCurrentIdx += (ImDrawIdx)vtx_count;
    }
    else
    {
        // Non Anti-aliased Stroke
        const int idx_count = count*6;
        const int vtx_count = count*4;      // FIXME-OPT: Not sharing edges
        PrimReserve(idx_count, vtx_count);

        for (int i1 = 0; i1 < count; i1++)
        {
            const int i2 = (i1+1) == points_count ? 0 : i1+1;
            const ImVec2& p1 = points[i1];
            const ImVec2& p2 = points[i2];

            float dx = p2.x - p1.x;
            float dy = p2.y - p1.y;
            IM_NORMALIZE2F_OVER_ZERO(dx, dy);
            dx *= (thickness * 0.5f);
            dy *= (thickness * 0.5f);

            _VtxWritePtr[0].pos.x = p1.x + dy; _VtxWritePtr[0].pos.y = p1.y - dx; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;
            _VtxWritePtr[1].pos.x = p2.x + dy; _VtxWritePtr[1].pos.y = p2.y - dx; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col;
            _VtxWritePtr[2].pos.x = p2.x - dy; _VtxWritePtr[2].pos.y = p2.y + dx; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col;
            _VtxWritePtr[3].pos.x = p1.x - dy; _VtxWritePtr[3].pos.y = p1.y + dx; _VtxWritePtr[3].uv = uv; _VtxWritePtr[3].col = col;
            _VtxWritePtr += 4;

            _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx+1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx+2);
            _IdxWritePtr[3] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[4] = (ImDrawIdx)(_VtxCurrentIdx+2); _IdxWritePtr[5] = (ImDrawIdx)(_VtxCurrentIdx+3);
            _IdxWritePtr += 6;
            _VtxCurrentIdx += 4;
        }
    }
}

// We intentionally avoid using ImVec2 and its math operators here to reduce cost to a minimum for debug/non-inlined builds.
void ImDrawList::AddConvexPolyFilled(const ImVec2* points, const int points_count, ImU32 col)
{
    if (points_count < 3)
        return;

    const ImVec2 uv = _Data->TexUvWhitePixel;

    if (Flags & ImDrawListFlags_AntiAliasedFill)
    {
        // Anti-aliased Fill
        const float AA_SIZE = 1.0f;
        const ImU32 col_trans = col & ~IM_COL32_A_MASK;
        const int idx_count = (points_count-2)*3 + points_count*6;
        const int vtx_count = (points_count*2);
        PrimReserve(idx_count, vtx_count);

        // Add indexes for fill
        unsigned int vtx_inner_idx = _VtxCurrentIdx;
        unsigned int vtx_outer_idx = _VtxCurrentIdx+1;
        for (int i = 2; i < points_count; i++)
        {
            _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx+((i-1)<<1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_inner_idx+(i<<1));
            _IdxWritePtr += 3;
        }

        // Compute normals
        ImVec2* temp_normals = (ImVec2*)alloca(points_count * sizeof(ImVec2)); //-V630
        for (int i0 = points_count-1, i1 = 0; i1 < points_count; i0 = i1++)
        {
            const ImVec2& p0 = points[i0];
            const ImVec2& p1 = points[i1];
            float dx = p1.x - p0.x;
            float dy = p1.y - p0.y;
            IM_NORMALIZE2F_OVER_ZERO(dx, dy);
            temp_normals[i0].x = dy;
            temp_normals[i0].y = -dx;
        }

        for (int i0 = points_count-1, i1 = 0; i1 < points_count; i0 = i1++)
        {
            // Average normals
            const ImVec2& n0 = temp_normals[i0];
            const ImVec2& n1 = temp_normals[i1];
            float dm_x = (n0.x + n1.x) * 0.5f;
            float dm_y = (n0.y + n1.y) * 0.5f;
            IM_FIXNORMAL2F(dm_x, dm_y);
            dm_x *= AA_SIZE * 0.5f;
            dm_y *= AA_SIZE * 0.5f;

            // Add vertices
            _VtxWritePtr[0].pos.x = (points[i1].x - dm_x); _VtxWritePtr[0].pos.y = (points[i1].y - dm_y); _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;        // Inner
            _VtxWritePtr[1].pos.x = (points[i1].x + dm_x); _VtxWritePtr[1].pos.y = (points[i1].y + dm_y); _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;  // Outer
            _VtxWritePtr += 2;

            // Add indexes for fringes
            _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx+(i1<<1)); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx+(i0<<1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_outer_idx+(i0<<1));
            _IdxWritePtr[3] = (ImDrawIdx)(vtx_outer_idx+(i0<<1)); _IdxWritePtr[4] = (ImDrawIdx)(vtx_outer_idx+(i1<<1)); _IdxWritePtr[5] = (ImDrawIdx)(vtx_inner_idx+(i1<<1));
            _IdxWritePtr += 6;
        }
        _VtxCurrentIdx += (ImDrawIdx)vtx_count;
    }
    else
    {
        // Non Anti-aliased Fill
        const int idx_count = (points_count-2)*3;
        const int vtx_count = points_count;
        PrimReserve(idx_count, vtx_count);
        for (int i = 0; i < vtx_count; i++)
        {
            _VtxWritePtr[0].pos = points[i]; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;
            _VtxWritePtr++;
        }
        for (int i = 2; i < points_count; i++)
        {
            _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx+i-1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx+i);
            _IdxWritePtr += 3;
        }
        _VtxCurrentIdx += (ImDrawIdx)vtx_count;
    }
}

void ImDrawList::PathArcToFast(const ImVec2& centre, float radius, int a_min_of_12, int a_max_of_12)
{
    if (radius == 0.0f || a_min_of_12 > a_max_of_12)
    {
        _Path.push_back(centre);
        return;
    }
    _Path.reserve(_Path.Size + (a_max_of_12 - a_min_of_12 + 1));
    for (int a = a_min_of_12; a <= a_max_of_12; a++)
    {
        const ImVec2& c = _Data->CircleVtx12[a % IM_ARRAYSIZE(_Data->CircleVtx12)];
        _Path.push_back(ImVec2(centre.x + c.x * radius, centre.y + c.y * radius));
    }
}

void ImDrawList::PathArcTo(const ImVec2& centre, float radius, float a_min, float a_max, int num_segments)
{
    if (radius == 0.0f)
    {
        _Path.push_back(centre);
        return;
    }

    // Note that we are adding a point at both a_min and a_max.
    // If you are trying to draw a full closed circle you don't want the overlapping points!
    _Path.reserve(_Path.Size + (num_segments + 1));
    for (int i = 0; i <= num_segments; i++)
    {
        const float a = a_min + ((float)i / (float)num_segments) * (a_max - a_min);
        _Path.push_back(ImVec2(centre.x + ImCos(a) * radius, centre.y + ImSin(a) * radius));
    }
}

static void PathBezierToCasteljau(ImVector<ImVec2>* path, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, float tess_tol, int level)
{
    float dx = x4 - x1;
    float dy = y4 - y1;
    float d2 = ((x2 - x4) * dy - (y2 - y4) * dx);
    float d3 = ((x3 - x4) * dy - (y3 - y4) * dx);
    d2 = (d2 >= 0) ? d2 : -d2;
    d3 = (d3 >= 0) ? d3 : -d3;
    if ((d2+d3) * (d2+d3) < tess_tol * (dx*dx + dy*dy))
    {
        path->push_back(ImVec2(x4, y4));
    }
    else if (level < 10)
    {
        float x12 = (x1+x2)*0.5f,       y12 = (y1+y2)*0.5f;
        float x23 = (x2+x3)*0.5f,       y23 = (y2+y3)*0.5f;
        float x34 = (x3+x4)*0.5f,       y34 = (y3+y4)*0.5f;
        float x123 = (x12+x23)*0.5f,    y123 = (y12+y23)*0.5f;
        float x234 = (x23+x34)*0.5f,    y234 = (y23+y34)*0.5f;
        float x1234 = (x123+x234)*0.5f, y1234 = (y123+y234)*0.5f;

        PathBezierToCasteljau(path, x1,y1,        x12,y12,    x123,y123,  x1234,y1234, tess_tol, level+1);
        PathBezierToCasteljau(path, x1234,y1234,  x234,y234,  x34,y34,    x4,y4,       tess_tol, level+1);
    }
}

void ImDrawList::PathBezierCurveTo(const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, int num_segments)
{
    ImVec2 p1 = _Path.back();
    if (num_segments == 0)
    {
        // Auto-tessellated
        PathBezierToCasteljau(&_Path, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x, p4.y, _Data->CurveTessellationTol, 0);
    }
    else
    {
        float t_step = 1.0f / (float)num_segments;
        for (int i_step = 1; i_step <= num_segments; i_step++)
        {
            float t = t_step * i_step;
            float u = 1.0f - t;
            float w1 = u*u*u;
            float w2 = 3*u*u*t;
            float w3 = 3*u*t*t;
            float w4 = t*t*t;
            _Path.push_back(ImVec2(w1*p1.x + w2*p2.x + w3*p3.x + w4*p4.x, w1*p1.y + w2*p2.y + w3*p3.y + w4*p4.y));
        }
    }
}

void ImDrawList::PathRect(const ImVec2& a, const ImVec2& b, float rounding, int rounding_corners)
{
    rounding = ImMin(rounding, ImFabs(b.x - a.x) * ( ((rounding_corners & ImDrawCornerFlags_Top)  == ImDrawCornerFlags_Top)  || ((rounding_corners & ImDrawCornerFlags_Bot)   == ImDrawCornerFlags_Bot)   ? 0.5f : 1.0f ) - 1.0f);
    rounding = ImMin(rounding, ImFabs(b.y - a.y) * ( ((rounding_corners & ImDrawCornerFlags_Left) == ImDrawCornerFlags_Left) || ((rounding_corners & ImDrawCornerFlags_Right) == ImDrawCornerFlags_Right) ? 0.5f : 1.0f ) - 1.0f);

    if (rounding <= 0.0f || rounding_corners == 0)
    {
        PathLineTo(a);
        PathLineTo(ImVec2(b.x, a.y));
        PathLineTo(b);
        PathLineTo(ImVec2(a.x, b.y));
    }
    else
    {
        const float rounding_tl = (rounding_corners & ImDrawCornerFlags_TopLeft) ? rounding : 0.0f;
        const float rounding_tr = (rounding_corners & ImDrawCornerFlags_TopRight) ? rounding : 0.0f;
        const float rounding_br = (rounding_corners & ImDrawCornerFlags_BotRight) ? rounding : 0.0f;
        const float rounding_bl = (rounding_corners & ImDrawCornerFlags_BotLeft) ? rounding : 0.0f;
        PathArcToFast(ImVec2(a.x + rounding_tl, a.y + rounding_tl), rounding_tl, 6, 9);
        PathArcToFast(ImVec2(b.x - rounding_tr, a.y + rounding_tr), rounding_tr, 9, 12);
        PathArcToFast(ImVec2(b.x - rounding_br, b.y - rounding_br), rounding_br, 0, 3);
        PathArcToFast(ImVec2(a.x + rounding_bl, b.y - rounding_bl), rounding_bl, 3, 6);
    }
}

void ImDrawList::AddLine(const ImVec2& a, const ImVec2& b, ImU32 col, float thickness)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;
    PathLineTo(a + ImVec2(0.5f,0.5f));
    PathLineTo(b + ImVec2(0.5f,0.5f));
    PathStroke(col, false, thickness);
}

// a: upper-left, b: lower-right. we don't render 1 px sized rectangles properly.
void ImDrawList::AddRect(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding, int rounding_corners_flags, float thickness)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;
    if (Flags & ImDrawListFlags_AntiAliasedLines)
        PathRect(a + ImVec2(0.5f,0.5f), b - ImVec2(0.50f,0.50f), rounding, rounding_corners_flags);
    else
        PathRect(a + ImVec2(0.5f,0.5f), b - ImVec2(0.49f,0.49f), rounding, rounding_corners_flags); // Better looking lower-right corner and rounded non-AA shapes.
    PathStroke(col, true, thickness);
}

void ImDrawList::AddRectFilled(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding, int rounding_corners_flags)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;
    if (rounding > 0.0f)
    {
        PathRect(a, b, rounding, rounding_corners_flags);
        PathFillConvex(col);
    }
    else
    {
        PrimReserve(6, 4);
        PrimRect(a, b, col);
    }
}

void ImDrawList::AddRectFilledMultiColor(const ImVec2& a, const ImVec2& c, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left)
{
    if (((col_upr_left | col_upr_right | col_bot_right | col_bot_left) & IM_COL32_A_MASK) == 0)
        return;

    const ImVec2 uv = _Data->TexUvWhitePixel;
    PrimReserve(6, 4);
    PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx+1)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx+2));
    PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx+2)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx+3));
    PrimWriteVtx(a, uv, col_upr_left);
    PrimWriteVtx(ImVec2(c.x, a.y), uv, col_upr_right);
    PrimWriteVtx(c, uv, col_bot_right);
    PrimWriteVtx(ImVec2(a.x, c.y), uv, col_bot_left);
}

void ImDrawList::AddQuad(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col, float thickness)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;

    PathLineTo(a);
    PathLineTo(b);
    PathLineTo(c);
    PathLineTo(d);
    PathStroke(col, true, thickness);
}

void ImDrawList::AddQuadFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;

    PathLineTo(a);
    PathLineTo(b);
    PathLineTo(c);
    PathLineTo(d);
    PathFillConvex(col);
}

void ImDrawList::AddTriangle(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col, float thickness)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;

    PathLineTo(a);
    PathLineTo(b);
    PathLineTo(c);
    PathStroke(col, true, thickness);
}

void ImDrawList::AddTriangleFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;

    PathLineTo(a);
    PathLineTo(b);
    PathLineTo(c);
    PathFillConvex(col);
}

void ImDrawList::AddCircle(const ImVec2& centre, float radius, ImU32 col, int num_segments, float thickness)
{
    if ((col & IM_COL32_A_MASK) == 0 || num_segments <= 2)
        return;

    // Because we are filling a closed shape we remove 1 from the count of segments/points
    const float a_max = IM_PI*2.0f * ((float)num_segments - 1.0f) / (float)num_segments;
    PathArcTo(centre, radius-0.5f, 0.0f, a_max, num_segments - 1);
    PathStroke(col, true, thickness);
}

void ImDrawList::AddCircleFilled(const ImVec2& centre, float radius, ImU32 col, int num_segments)
{
    if ((col & IM_COL32_A_MASK) == 0 || num_segments <= 2)
        return;

    // Because we are filling a closed shape we remove 1 from the count of segments/points
    const float a_max = IM_PI*2.0f * ((float)num_segments - 1.0f) / (float)num_segments;
    PathArcTo(centre, radius, 0.0f, a_max, num_segments - 1);
    PathFillConvex(col);
}

void ImDrawList::AddBezierCurve(const ImVec2& pos0, const ImVec2& cp0, const ImVec2& cp1, const ImVec2& pos1, ImU32 col, float thickness, int num_segments)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;

    PathLineTo(pos0);
    PathBezierCurveTo(cp0, cp1, pos1, num_segments);
    PathStroke(col, false, thickness);
}

void ImDrawList::AddText(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end, float wrap_width, const ImVec4* cpu_fine_clip_rect)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;

    if (text_end == NULL)
        text_end = text_begin + strlen(text_begin);
    if (text_begin == text_end)
        return;

    // Pull default font/size from the shared ImDrawListSharedData instance
    if (font == NULL)
        font = _Data->Font;
    if (font_size == 0.0f)
        font_size = _Data->FontSize;

    IM_ASSERT(font->ContainerAtlas->TexID == _TextureIdStack.back());  // Use high-level ImGui::PushFont() or low-level ImDrawList::PushTextureId() to change font.

    ImVec4 clip_rect = _ClipRectStack.back();
    if (cpu_fine_clip_rect)
    {
        clip_rect.x = ImMax(clip_rect.x, cpu_fine_clip_rect->x);
        clip_rect.y = ImMax(clip_rect.y, cpu_fine_clip_rect->y);
        clip_rect.z = ImMin(clip_rect.z, cpu_fine_clip_rect->z);
        clip_rect.w = ImMin(clip_rect.w, cpu_fine_clip_rect->w);
    }
    font->RenderText(this, font_size, pos, col, clip_rect, text_begin, text_end, wrap_width, cpu_fine_clip_rect != NULL);
}

void ImDrawList::AddText(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end)
{
    AddText(NULL, 0.0f, pos, col, text_begin, text_end);
}

void ImDrawList::AddImage(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;

    const bool push_texture_id = _TextureIdStack.empty() || user_texture_id != _TextureIdStack.back();
    if (push_texture_id)
        PushTextureID(user_texture_id);

    PrimReserve(6, 4);
    PrimRectUV(a, b, uv_a, uv_b, col);

    if (push_texture_id)
        PopTextureID();
}

void ImDrawList::AddImageQuad(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;

    const bool push_texture_id = _TextureIdStack.empty() || user_texture_id != _TextureIdStack.back();
    if (push_texture_id)
        PushTextureID(user_texture_id);

    PrimReserve(6, 4);
    PrimQuadUV(a, b, c, d, uv_a, uv_b, uv_c, uv_d, col);

    if (push_texture_id)
        PopTextureID();
}

void ImDrawList::AddImageRounded(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col, float rounding, int rounding_corners)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;

    if (rounding <= 0.0f || (rounding_corners & ImDrawCornerFlags_All) == 0)
    {
        AddImage(user_texture_id, a, b, uv_a, uv_b, col);
        return;
    }

    const bool push_texture_id = _TextureIdStack.empty() || user_texture_id != _TextureIdStack.back();
    if (push_texture_id)
        PushTextureID(user_texture_id);

    int vert_start_idx = VtxBuffer.Size;
    PathRect(a, b, rounding, rounding_corners);
    PathFillConvex(col);
    int vert_end_idx = VtxBuffer.Size;
    ImGui::ShadeVertsLinearUV(this, vert_start_idx, vert_end_idx, a, b, uv_a, uv_b, true);

    if (push_texture_id)
        PopTextureID();
}

//-----------------------------------------------------------------------------
// [SECTION] ImDrawData
//-----------------------------------------------------------------------------

// For backward compatibility: convert all buffers from indexed to de-indexed, in case you cannot render indexed. Note: this is slow and most likely a waste of resources. Always prefer indexed rendering!
void ImDrawData::DeIndexAllBuffers()
{
    ImVector<ImDrawVert> new_vtx_buffer;
    TotalVtxCount = TotalIdxCount = 0;
    for (int i = 0; i < CmdListsCount; i++)
    {
        ImDrawList* cmd_list = CmdLists[i];
        if (cmd_list->IdxBuffer.empty())
            continue;
        new_vtx_buffer.resize(cmd_list->IdxBuffer.Size);
        for (int j = 0; j < cmd_list->IdxBuffer.Size; j++)
            new_vtx_buffer[j] = cmd_list->VtxBuffer[cmd_list->IdxBuffer[j]];
        cmd_list->VtxBuffer.swap(new_vtx_buffer);
        cmd_list->IdxBuffer.resize(0);
        TotalVtxCount += cmd_list->VtxBuffer.Size;
    }
}

// Helper to scale the ClipRect field of each ImDrawCmd.
// Use if your final output buffer is at a different scale than draw_data->DisplaySize,
// or if there is a difference between your window resolution and framebuffer resolution.
void ImDrawData::ScaleClipRects(const ImVec2& fb_scale)
{
    for (int i = 0; i < CmdListsCount; i++)
    {
        ImDrawList* cmd_list = CmdLists[i];
        for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)
        {
            ImDrawCmd* cmd = &cmd_list->CmdBuffer[cmd_i];
            cmd->ClipRect = ImVec4(cmd->ClipRect.x * fb_scale.x, cmd->ClipRect.y * fb_scale.y, cmd->ClipRect.z * fb_scale.x, cmd->ClipRect.w * fb_scale.y);
        }
    }
}

//-----------------------------------------------------------------------------
// [SECTION] Helpers ShadeVertsXXX functions
//-----------------------------------------------------------------------------

// Generic linear color gradient, write to RGB fields, leave A untouched.
void ImGui::ShadeVertsLinearColorGradientKeepAlpha(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, ImVec2 gradient_p0, ImVec2 gradient_p1, ImU32 col0, ImU32 col1)
{
    ImVec2 gradient_extent = gradient_p1 - gradient_p0;
    float gradient_inv_length2 = 1.0f / ImLengthSqr(gradient_extent);
    ImDrawVert* vert_start = draw_list->VtxBuffer.Data + vert_start_idx;
    ImDrawVert* vert_end = draw_list->VtxBuffer.Data + vert_end_idx;
    for (ImDrawVert* vert = vert_start; vert < vert_end; vert++)
    {
        float d = ImDot(vert->pos - gradient_p0, gradient_extent);
        float t = ImClamp(d * gradient_inv_length2, 0.0f, 1.0f);
        int r = ImLerp((int)(col0 >> IM_COL32_R_SHIFT) & 0xFF, (int)(col1 >> IM_COL32_R_SHIFT) & 0xFF, t);
        int g = ImLerp((int)(col0 >> IM_COL32_G_SHIFT) & 0xFF, (int)(col1 >> IM_COL32_G_SHIFT) & 0xFF, t);
        int b = ImLerp((int)(col0 >> IM_COL32_B_SHIFT) & 0xFF, (int)(col1 >> IM_COL32_B_SHIFT) & 0xFF, t);
        vert->col = (r << IM_COL32_R_SHIFT) | (g << IM_COL32_G_SHIFT) | (b << IM_COL32_B_SHIFT) | (vert->col & IM_COL32_A_MASK);
    }
}

// Distribute UV over (a, b) rectangle
void ImGui::ShadeVertsLinearUV(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, bool clamp)
{
    const ImVec2 size = b - a;
    const ImVec2 uv_size = uv_b - uv_a;
    const ImVec2 scale = ImVec2(
        size.x != 0.0f ? (uv_size.x / size.x) : 0.0f,
        size.y != 0.0f ? (uv_size.y / size.y) : 0.0f);

    ImDrawVert* vert_start = draw_list->VtxBuffer.Data + vert_start_idx;
    ImDrawVert* vert_end = draw_list->VtxBuffer.Data + vert_end_idx;
    if (clamp)
    {
        const ImVec2 min = ImMin(uv_a, uv_b);
        const ImVec2 max = ImMax(uv_a, uv_b);
        for (ImDrawVert* vertex = vert_start; vertex < vert_end; ++vertex)
            vertex->uv = ImClamp(uv_a + ImMul(ImVec2(vertex->pos.x, vertex->pos.y) - a, scale), min, max);
    }
    else
    {
        for (ImDrawVert* vertex = vert_start; vertex < vert_end; ++vertex)
            vertex->uv = uv_a + ImMul(ImVec2(vertex->pos.x, vertex->pos.y) - a, scale);
    }
}

//-----------------------------------------------------------------------------
// [SECTION] ImFontConfig
//-----------------------------------------------------------------------------

ImFontConfig::ImFontConfig()
{
    FontData = NULL;
    FontDataSize = 0;
    FontDataOwnedByAtlas = true;
    FontNo = 0;
    SizePixels = 0.0f;
    OversampleH = 3; // FIXME: 2 may be a better default?
    OversampleV = 1;
    PixelSnapH = false;
    GlyphExtraSpacing = ImVec2(0.0f, 0.0f);
    GlyphOffset = ImVec2(0.0f, 0.0f);
    GlyphRanges = NULL;
    GlyphMinAdvanceX = 0.0f;
    GlyphMaxAdvanceX = FLT_MAX;
    MergeMode = false;
    RasterizerFlags = 0x00;
    RasterizerMultiply = 1.0f;
    memset(Name, 0, sizeof(Name));
    DstFont = NULL;
}

//-----------------------------------------------------------------------------
// [SECTION] ImFontAtlas
//-----------------------------------------------------------------------------

// A work of art lies ahead! (. = white layer, X = black layer, others are blank)
// The white texels on the top left are the ones we'll use everywhere in ImGui to render filled shapes.
const int FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF = 108;
const int FONT_ATLAS_DEFAULT_TEX_DATA_H      = 27;
const unsigned int FONT_ATLAS_DEFAULT_TEX_DATA_ID = 0x80000000;
static const char FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS[FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF * FONT_ATLAS_DEFAULT_TEX_DATA_H + 1] =
{
    "..-         -XXXXXXX-    X    -           X           -XXXXXXX          -          XXXXXXX-     XX          "
    "..-         -X.....X-   X.X   -          X.X          -X.....X          -          X.....X-    X..X         "
    "---         -XXX.XXX-  X...X  -         X...X         -X....X           -           X....X-    X..X         "
    "X           -  X.X  - X.....X -        X.....X        -X...X            -            X...X-    X..X         "
    "XX          -  X.X  -X.......X-       X.......X       -X..X.X           -           X.X..X-    X..X         "
    "X.X         -  X.X  -XXXX.XXXX-       XXXX.XXXX       -X.X X.X          -          X.X X.X-    X..XXX       "
    "X..X        -  X.X  -   X.X   -          X.X          -XX   X.X         -         X.X   XX-    X..X..XXX    "
    "X...X       -  X.X  -   X.X   -    XX    X.X    XX    -      X.X        -        X.X      -    X..X..X..XX  "
    "X....X      -  X.X  -   X.X   -   X.X    X.X    X.X   -       X.X       -       X.X       -    X..X..X..X.X "
    "X.....X     -  X.X  -   X.X   -  X..X    X.X    X..X  -        X.X      -      X.X        -XXX X..X..X..X..X"
    "X......X    -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -         X.X   XX-XX   X.X         -X..XX........X..X"
    "X.......X   -  X.X  -   X.X   -X.....................X-          X.X X.X-X.X X.X          -X...X...........X"
    "X........X  -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -           X.X..X-X..X.X           - X..............X"
    "X.........X -XXX.XXX-   X.X   -  X..X    X.X    X..X  -            X...X-X...X            -  X.............X"
    "X..........X-X.....X-   X.X   -   X.X    X.X    X.X   -           X....X-X....X           -  X.............X"
    "X......XXXXX-XXXXXXX-   X.X   -    XX    X.X    XX    -          X.....X-X.....X          -   X............X"
    "X...X..X    ---------   X.X   -          X.X          -          XXXXXXX-XXXXXXX          -   X...........X "
    "X..X X..X   -       -XXXX.XXXX-       XXXX.XXXX       -------------------------------------    X..........X "
    "X.X  X..X   -       -X.......X-       X.......X       -    XX           XX    -           -    X..........X "
    "XX    X..X  -       - X.....X -        X.....X        -   X.X           X.X   -           -     X........X  "
    "      X..X          -  X...X  -         X...X         -  X..X           X..X  -           -     X........X  "
    "       XX           -   X.X   -          X.X          - X...XXXXXXXXXXXXX...X -           -     XXXXXXXXXX  "
    "------------        -    X    -           X           -X.....................X-           ------------------"
    "                    ----------------------------------- X...XXXXXXXXXXXXX...X -                             "
    "                                                      -  X..X           X..X  -                             "
    "                                                      -   X.X           X.X   -                             "
    "                                                      -    XX           XX    -                             "
};

static const ImVec2 FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[ImGuiMouseCursor_COUNT][3] =
{
    // Pos ........ Size ......... Offset ......
    { ImVec2( 0,3), ImVec2(12,19), ImVec2( 0, 0) }, // ImGuiMouseCursor_Arrow
    { ImVec2(13,0), ImVec2( 7,16), ImVec2( 1, 8) }, // ImGuiMouseCursor_TextInput
    { ImVec2(31,0), ImVec2(23,23), ImVec2(11,11) }, // ImGuiMouseCursor_ResizeAll
    { ImVec2(21,0), ImVec2( 9,23), ImVec2( 4,11) }, // ImGuiMouseCursor_ResizeNS
    { ImVec2(55,18),ImVec2(23, 9), ImVec2(11, 4) }, // ImGuiMouseCursor_ResizeEW
    { ImVec2(73,0), ImVec2(17,17), ImVec2( 8, 8) }, // ImGuiMouseCursor_ResizeNESW
    { ImVec2(55,0), ImVec2(17,17), ImVec2( 8, 8) }, // ImGuiMouseCursor_ResizeNWSE
    { ImVec2(91,0), ImVec2(17,22), ImVec2( 5, 0) }, // ImGuiMouseCursor_Hand
};

ImFontAtlas::ImFontAtlas()
{
    Locked = false;
    Flags = ImFontAtlasFlags_None;
    TexID = (ImTextureID)NULL;
    TexDesiredWidth = 0;
    TexGlyphPadding = 1;

    TexPixelsAlpha8 = NULL;
    TexPixelsRGBA32 = NULL;
    TexWidth = TexHeight = 0;
    TexUvScale = ImVec2(0.0f, 0.0f);
    TexUvWhitePixel = ImVec2(0.0f, 0.0f);
    for (int n = 0; n < IM_ARRAYSIZE(CustomRectIds); n++)
        CustomRectIds[n] = -1;
}

ImFontAtlas::~ImFontAtlas()
{
    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
    Clear();
}

void    ImFontAtlas::ClearInputData()
{
    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
    for (int i = 0; i < ConfigData.Size; i++)
        if (ConfigData[i].FontData && ConfigData[i].FontDataOwnedByAtlas)
        {
            IM_FREE(ConfigData[i].FontData);
            ConfigData[i].FontData = NULL;
        }

    // When clearing this we lose access to the font name and other information used to build the font.
    for (int i = 0; i < Fonts.Size; i++)
        if (Fonts[i]->ConfigData >= ConfigData.Data && Fonts[i]->ConfigData < ConfigData.Data + ConfigData.Size)
        {
            Fonts[i]->ConfigData = NULL;
            Fonts[i]->ConfigDataCount = 0;
        }
    ConfigData.clear();
    CustomRects.clear();
    for (int n = 0; n < IM_ARRAYSIZE(CustomRectIds); n++)
        CustomRectIds[n] = -1;
}

void    ImFontAtlas::ClearTexData()
{
    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
    if (TexPixelsAlpha8)
        IM_FREE(TexPixelsAlpha8);
    if (TexPixelsRGBA32)
        IM_FREE(TexPixelsRGBA32);
    TexPixelsAlpha8 = NULL;
    TexPixelsRGBA32 = NULL;
}

void    ImFontAtlas::ClearFonts()
{
    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
    for (int i = 0; i < Fonts.Size; i++)
        IM_DELETE(Fonts[i]);
    Fonts.clear();
}

void    ImFontAtlas::Clear()
{
    ClearInputData();
    ClearTexData();
    ClearFonts();
}

void    ImFontAtlas::GetTexDataAsAlpha8(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)
{
    // Build atlas on demand
    if (TexPixelsAlpha8 == NULL)
    {
        if (ConfigData.empty())
            AddFontDefault();
        Build();
    }

    *out_pixels = TexPixelsAlpha8;
    if (out_width) *out_width = TexWidth;
    if (out_height) *out_height = TexHeight;
    if (out_bytes_per_pixel) *out_bytes_per_pixel = 1;
}

void    ImFontAtlas::GetTexDataAsRGBA32(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)
{
    // Convert to RGBA32 format on demand
    // Although it is likely to be the most commonly used format, our font rendering is 1 channel / 8 bpp
    if (!TexPixelsRGBA32)
    {
        unsigned char* pixels = NULL;
        GetTexDataAsAlpha8(&pixels, NULL, NULL);
        if (pixels)
        {
            TexPixelsRGBA32 = (unsigned int*)IM_ALLOC((size_t)TexWidth * (size_t)TexHeight * 4);
            const unsigned char* src = pixels;
            unsigned int* dst = TexPixelsRGBA32;
            for (int n = TexWidth * TexHeight; n > 0; n--)
                *dst++ = IM_COL32(255, 255, 255, (unsigned int)(*src++));
        }
    }

    *out_pixels = (unsigned char*)TexPixelsRGBA32;
    if (out_width) *out_width = TexWidth;
    if (out_height) *out_height = TexHeight;
    if (out_bytes_per_pixel) *out_bytes_per_pixel = 4;
}

ImFont* ImFontAtlas::AddFont(const ImFontConfig* font_cfg)
{
    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
    IM_ASSERT(font_cfg->FontData != NULL && font_cfg->FontDataSize > 0);
    IM_ASSERT(font_cfg->SizePixels > 0.0f);

    // Create new font
    if (!font_cfg->MergeMode)
        Fonts.push_back(IM_NEW(ImFont));
    else
        IM_ASSERT(!Fonts.empty() && "Cannot use MergeMode for the first font"); // When using MergeMode make sure that a font has already been added before. You can use ImGui::GetIO().Fonts->AddFontDefault() to add the default imgui font.

    ConfigData.push_back(*font_cfg);
    ImFontConfig& new_font_cfg = ConfigData.back();
    if (new_font_cfg.DstFont == NULL)
        new_font_cfg.DstFont = Fonts.back();
    if (!new_font_cfg.FontDataOwnedByAtlas)
    {
        new_font_cfg.FontData = IM_ALLOC(new_font_cfg.FontDataSize);
        new_font_cfg.FontDataOwnedByAtlas = true;
        memcpy(new_font_cfg.FontData, font_cfg->FontData, (size_t)new_font_cfg.FontDataSize);
    }

    // Invalidate texture
    ClearTexData();
    return new_font_cfg.DstFont;
}

// Default font TTF is compressed with stb_compress then base85 encoded (see misc/fonts/binary_to_compressed_c.cpp for encoder)
static unsigned int stb_decompress_length(const unsigned char *input);
static unsigned int stb_decompress(unsigned char *output, const unsigned char *input, unsigned int length);
static const char*  GetDefaultCompressedFontDataTTFBase85();
static unsigned int Decode85Byte(char c)                                    { return c >= '\\' ? c-36 : c-35; }
static void         Decode85(const unsigned char* src, unsigned char* dst)
{
    while (*src)
    {
        unsigned int tmp = Decode85Byte(src[0]) + 85*(Decode85Byte(src[1]) + 85*(Decode85Byte(src[2]) + 85*(Decode85Byte(src[3]) + 85*Decode85Byte(src[4]))));
        dst[0] = ((tmp >> 0) & 0xFF); dst[1] = ((tmp >> 8) & 0xFF); dst[2] = ((tmp >> 16) & 0xFF); dst[3] = ((tmp >> 24) & 0xFF);   // We can't assume little-endianness.
        src += 5;
        dst += 4;
    }
}

// Load embedded ProggyClean.ttf at size 13, disable oversampling
ImFont* ImFontAtlas::AddFontDefault(const ImFontConfig* font_cfg_template)
{
    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
    if (!font_cfg_template)
    {
        font_cfg.OversampleH = font_cfg.OversampleV = 1;
        font_cfg.PixelSnapH = true;
    }
    if (font_cfg.SizePixels <= 0.0f)
        font_cfg.SizePixels = 13.0f * 1.0f;
    if (font_cfg.Name[0] == '\0')
        ImFormatString(font_cfg.Name, IM_ARRAYSIZE(font_cfg.Name), "ProggyClean.ttf, %dpx", (int)font_cfg.SizePixels);

    const char* ttf_compressed_base85 = GetDefaultCompressedFontDataTTFBase85();
    const ImWchar* glyph_ranges = font_cfg.GlyphRanges != NULL ? font_cfg.GlyphRanges : GetGlyphRangesDefault();
    ImFont* font = AddFontFromMemoryCompressedBase85TTF(ttf_compressed_base85, font_cfg.SizePixels, &font_cfg, glyph_ranges);
    font->DisplayOffset.y = 1.0f;
    return font;
}

ImFont* ImFontAtlas::AddFontFromFileTTF(const char* filename, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)
{
    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
    size_t data_size = 0;
    void* data = ImFileLoadToMemory(filename, "rb", &data_size, 0);
    if (!data)
    {
        IM_ASSERT(0); // Could not load file.
        return NULL;
    }
    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
    if (font_cfg.Name[0] == '\0')
    {
        // Store a short copy of filename into into the font name for convenience
        const char* p;
        for (p = filename + strlen(filename); p > filename && p[-1] != '/' && p[-1] != '\\'; p--) {}
        ImFormatString(font_cfg.Name, IM_ARRAYSIZE(font_cfg.Name), "%s, %.0fpx", p, size_pixels);
    }
    return AddFontFromMemoryTTF(data, (int)data_size, size_pixels, &font_cfg, glyph_ranges);
}

// NB: Transfer ownership of 'ttf_data' to ImFontAtlas, unless font_cfg_template->FontDataOwnedByAtlas == false. Owned TTF buffer will be deleted after Build().
ImFont* ImFontAtlas::AddFontFromMemoryTTF(void* ttf_data, int ttf_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)
{
    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
    IM_ASSERT(font_cfg.FontData == NULL);
    font_cfg.FontData = ttf_data;
    font_cfg.FontDataSize = ttf_size;
    font_cfg.SizePixels = size_pixels;
    if (glyph_ranges)
        font_cfg.GlyphRanges = glyph_ranges;
    return AddFont(&font_cfg);
}

ImFont* ImFontAtlas::AddFontFromMemoryCompressedTTF(const void* compressed_ttf_data, int compressed_ttf_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)
{
    const unsigned int buf_decompressed_size = stb_decompress_length((const unsigned char*)compressed_ttf_data);
    unsigned char* buf_decompressed_data = (unsigned char *)IM_ALLOC(buf_decompressed_size);
    stb_decompress(buf_decompressed_data, (const unsigned char*)compressed_ttf_data, (unsigned int)compressed_ttf_size);

    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
    IM_ASSERT(font_cfg.FontData == NULL);
    font_cfg.FontDataOwnedByAtlas = true;
    return AddFontFromMemoryTTF(buf_decompressed_data, (int)buf_decompressed_size, size_pixels, &font_cfg, glyph_ranges);
}

ImFont* ImFontAtlas::AddFontFromMemoryCompressedBase85TTF(const char* compressed_ttf_data_base85, float size_pixels, const ImFontConfig* font_cfg, const ImWchar* glyph_ranges)
{
    int compressed_ttf_size = (((int)strlen(compressed_ttf_data_base85) + 4) / 5) * 4;
    void* compressed_ttf = IM_ALLOC((size_t)compressed_ttf_size);
    Decode85((const unsigned char*)compressed_ttf_data_base85, (unsigned char*)compressed_ttf);
    ImFont* font = AddFontFromMemoryCompressedTTF(compressed_ttf, compressed_ttf_size, size_pixels, font_cfg, glyph_ranges);
    IM_FREE(compressed_ttf);
    return font;
}

int ImFontAtlas::AddCustomRectRegular(unsigned int id, int width, int height)
{
    IM_ASSERT(id >= 0x10000);
    IM_ASSERT(width > 0 && width <= 0xFFFF);
    IM_ASSERT(height > 0 && height <= 0xFFFF);
    CustomRect r;
    r.ID = id;
    r.Width = (unsigned short)width;
    r.Height = (unsigned short)height;
    CustomRects.push_back(r);
    return CustomRects.Size - 1; // Return index
}

int ImFontAtlas::AddCustomRectFontGlyph(ImFont* font, ImWchar id, int width, int height, float advance_x, const ImVec2& offset)
{
    IM_ASSERT(font != NULL);
    IM_ASSERT(width > 0 && width <= 0xFFFF);
    IM_ASSERT(height > 0 && height <= 0xFFFF);
    CustomRect r;
    r.ID = id;
    r.Width = (unsigned short)width;
    r.Height = (unsigned short)height;
    r.GlyphAdvanceX = advance_x;
    r.GlyphOffset = offset;
    r.Font = font;
    CustomRects.push_back(r);
    return CustomRects.Size - 1; // Return index
}

void ImFontAtlas::CalcCustomRectUV(const CustomRect* rect, ImVec2* out_uv_min, ImVec2* out_uv_max)
{
    IM_ASSERT(TexWidth > 0 && TexHeight > 0);   // Font atlas needs to be built before we can calculate UV coordinates
    IM_ASSERT(rect->IsPacked());                // Make sure the rectangle has been packed
    *out_uv_min = ImVec2((float)rect->X * TexUvScale.x, (float)rect->Y * TexUvScale.y);
    *out_uv_max = ImVec2((float)(rect->X + rect->Width) * TexUvScale.x, (float)(rect->Y + rect->Height) * TexUvScale.y);
}

bool ImFontAtlas::GetMouseCursorTexData(ImGuiMouseCursor cursor_type, ImVec2* out_offset, ImVec2* out_size, ImVec2 out_uv_border[2], ImVec2 out_uv_fill[2])
{
    if (cursor_type <= ImGuiMouseCursor_None || cursor_type >= ImGuiMouseCursor_COUNT)
        return false;
    if (Flags & ImFontAtlasFlags_NoMouseCursors)
        return false;

    IM_ASSERT(CustomRectIds[0] != -1);
    ImFontAtlas::CustomRect& r = CustomRects[CustomRectIds[0]];
    IM_ASSERT(r.ID == FONT_ATLAS_DEFAULT_TEX_DATA_ID);
    ImVec2 pos = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][0] + ImVec2((float)r.X, (float)r.Y);
    ImVec2 size = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][1];
    *out_size = size;
    *out_offset = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][2];
    out_uv_border[0] = (pos) * TexUvScale;
    out_uv_border[1] = (pos + size) * TexUvScale;
    pos.x += FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF + 1;
    out_uv_fill[0] = (pos) * TexUvScale;
    out_uv_fill[1] = (pos + size) * TexUvScale;
    return true;
}

bool    ImFontAtlas::Build()
{
    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
    return ImFontAtlasBuildWithStbTruetype(this);
}

void    ImFontAtlasBuildMultiplyCalcLookupTable(unsigned char out_table[256], float in_brighten_factor)
{
    for (unsigned int i = 0; i < 256; i++)
    {
        unsigned int value = (unsigned int)(i * in_brighten_factor);
        out_table[i] = value > 255 ? 255 : (value & 0xFF);
    }
}

void    ImFontAtlasBuildMultiplyRectAlpha8(const unsigned char table[256], unsigned char* pixels, int x, int y, int w, int h, int stride)
{
    unsigned char* data = pixels + x + y * stride;
    for (int j = h; j > 0; j--, data += stride)
        for (int i = 0; i < w; i++)
            data[i] = table[data[i]];
}

// Temporary data for one source font (multiple source fonts can be merged into one destination ImFont)
// (C++03 doesn't allow instancing ImVector<> with function-local types so we declare the type here.)
struct ImFontBuildSrcData
{
    stbtt_fontinfo      FontInfo;
    stbtt_pack_range    PackRange;          // Hold the list of codepoints to pack (essentially points to Codepoints.Data)
    stbrp_rect*         Rects;              // Rectangle to pack. We first fill in their size and the packer will give us their position.
    stbtt_packedchar*   PackedChars;        // Output glyphs
    const ImWchar*      SrcRanges;          // Ranges as requested by user (user is allowed to request too much, e.g. 0x0020..0xFFFF)
    int                 DstIndex;           // Index into atlas->Fonts[] and dst_tmp_array[]
    int                 GlyphsHighest;      // Highest requested codepoint
    int                 GlyphsCount;        // Glyph count (excluding missing glyphs and glyphs already set by an earlier source font)
    ImBoolVector        GlyphsSet;          // Glyph bit map (random access, 1-bit per codepoint. This will be a maximum of 8KB)
    ImVector<int>       GlyphsList;         // Glyph codepoints list (flattened version of GlyphsMap)
};

// Temporary data for one destination ImFont* (multiple source fonts can be merged into one destination ImFont)
struct ImFontBuildDstData
{
    int                 SrcCount;           // Number of source fonts targeting this destination font.
    int                 GlyphsHighest;
    int                 GlyphsCount;
    ImBoolVector        GlyphsSet;          // This is used to resolve collision when multiple sources are merged into a same destination font.
};

static void UnpackBoolVectorToFlatIndexList(const ImBoolVector* in, ImVector<int>* out)
{
    IM_ASSERT(sizeof(in->Storage.Data[0]) == sizeof(int));
    const int* it_begin = in->Storage.begin();
    const int* it_end = in->Storage.end();
    for (const int* it = it_begin; it < it_end; it++)
        if (int entries_32 = *it)
            for (int bit_n = 0; bit_n < 32; bit_n++)
                if (entries_32 & (1 << bit_n))
                    out->push_back((int)((it - it_begin) << 5) + bit_n);
}

bool    ImFontAtlasBuildWithStbTruetype(ImFontAtlas* atlas)
{
    IM_ASSERT(atlas->ConfigData.Size > 0);

    ImFontAtlasBuildRegisterDefaultCustomRects(atlas);

    // Clear atlas
    atlas->TexID = (ImTextureID)NULL;
    atlas->TexWidth = atlas->TexHeight = 0;
    atlas->TexUvScale = ImVec2(0.0f, 0.0f);
    atlas->TexUvWhitePixel = ImVec2(0.0f, 0.0f);
    atlas->ClearTexData();

    // Temporary storage for building
    ImVector<ImFontBuildSrcData> src_tmp_array;
    ImVector<ImFontBuildDstData> dst_tmp_array;
    src_tmp_array.resize(atlas->ConfigData.Size);
    dst_tmp_array.resize(atlas->Fonts.Size);
    memset(src_tmp_array.Data, 0, (size_t)src_tmp_array.size_in_bytes());
    memset(dst_tmp_array.Data, 0, (size_t)dst_tmp_array.size_in_bytes());

    // 1. Initialize font loading structure, check font data validity
    for (int src_i = 0; src_i < atlas->ConfigData.Size; src_i++)
    {
        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
        ImFontConfig& cfg = atlas->ConfigData[src_i];
        IM_ASSERT(cfg.DstFont && (!cfg.DstFont->IsLoaded() || cfg.DstFont->ContainerAtlas == atlas));

        // Find index from cfg.DstFont (we allow the user to set cfg.DstFont. Also it makes casual debugging nicer than when storing indices)
        src_tmp.DstIndex = -1;
        for (int output_i = 0; output_i < atlas->Fonts.Size && src_tmp.DstIndex == -1; output_i++)
            if (cfg.DstFont == atlas->Fonts[output_i])
                src_tmp.DstIndex = output_i;
        IM_ASSERT(src_tmp.DstIndex != -1); // cfg.DstFont not pointing within atlas->Fonts[] array?
        if (src_tmp.DstIndex == -1)
            return false;

        // Initialize helper structure for font loading and verify that the TTF/OTF data is correct
        const int font_offset = stbtt_GetFontOffsetForIndex((unsigned char*)cfg.FontData, cfg.FontNo);
        IM_ASSERT(font_offset >= 0 && "FontData is incorrect, or FontNo cannot be found.");
        if (!stbtt_InitFont(&src_tmp.FontInfo, (unsigned char*)cfg.FontData, font_offset))
            return false;

        // Measure highest codepoints
        ImFontBuildDstData& dst_tmp = dst_tmp_array[src_tmp.DstIndex];
        src_tmp.SrcRanges = cfg.GlyphRanges ? cfg.GlyphRanges : atlas->GetGlyphRangesDefault();
        for (const ImWchar* src_range = src_tmp.SrcRanges; src_range[0] && src_range[1]; src_range += 2)
            src_tmp.GlyphsHighest = ImMax(src_tmp.GlyphsHighest, (int)src_range[1]);
        dst_tmp.SrcCount++;
        dst_tmp.GlyphsHighest = ImMax(dst_tmp.GlyphsHighest, src_tmp.GlyphsHighest);
    }

    // 2. For every requested codepoint, check for their presence in the font data, and handle redundancy or overlaps between source fonts to avoid unused glyphs.
    int total_glyphs_count = 0;
    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
    {
        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
        ImFontBuildDstData& dst_tmp = dst_tmp_array[src_tmp.DstIndex];
        src_tmp.GlyphsSet.Resize(src_tmp.GlyphsHighest + 1);
        if (dst_tmp.GlyphsSet.Storage.empty())
            dst_tmp.GlyphsSet.Resize(dst_tmp.GlyphsHighest + 1);

        for (const ImWchar* src_range = src_tmp.SrcRanges; src_range[0] && src_range[1]; src_range += 2)
            for (int codepoint = src_range[0]; codepoint <= src_range[1]; codepoint++)
            {
                if (dst_tmp.GlyphsSet.GetBit(codepoint))    // Don't overwrite existing glyphs. We could make this an option for MergeMode (e.g. MergeOverwrite==true)
                    continue;
                if (!stbtt_FindGlyphIndex(&src_tmp.FontInfo, codepoint))    // It is actually in the font?
                    continue;

                // Add to avail set/counters
                src_tmp.GlyphsCount++;
                dst_tmp.GlyphsCount++;
                src_tmp.GlyphsSet.SetBit(codepoint, true);
                dst_tmp.GlyphsSet.SetBit(codepoint, true);
                total_glyphs_count++;
            }
    }

    // 3. Unpack our bit map into a flat list (we now have all the Unicode points that we know are requested _and_ available _and_ not overlapping another)
    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
    {
        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
        src_tmp.GlyphsList.reserve(src_tmp.GlyphsCount);
        UnpackBoolVectorToFlatIndexList(&src_tmp.GlyphsSet, &src_tmp.GlyphsList);
        src_tmp.GlyphsSet.Clear();
        IM_ASSERT(src_tmp.GlyphsList.Size == src_tmp.GlyphsCount);
    }
    for (int dst_i = 0; dst_i < dst_tmp_array.Size; dst_i++)
        dst_tmp_array[dst_i].GlyphsSet.Clear();
    dst_tmp_array.clear();

    // Allocate packing character data and flag packed characters buffer as non-packed (x0=y0=x1=y1=0)
    // (We technically don't need to zero-clear buf_rects, but let's do it for the sake of sanity)
    ImVector<stbrp_rect> buf_rects;
    ImVector<stbtt_packedchar> buf_packedchars;
    buf_rects.resize(total_glyphs_count);
    buf_packedchars.resize(total_glyphs_count);
    memset(buf_rects.Data, 0, (size_t)buf_rects.size_in_bytes());
    memset(buf_packedchars.Data, 0, (size_t)buf_packedchars.size_in_bytes());

    // 4. Gather glyphs sizes so we can pack them in our virtual canvas.
    int total_surface = 0;
    int buf_rects_out_n = 0;
    int buf_packedchars_out_n = 0;
    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
    {
        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
        if (src_tmp.GlyphsCount == 0)
            continue;

        src_tmp.Rects = &buf_rects[buf_rects_out_n];
        src_tmp.PackedChars = &buf_packedchars[buf_packedchars_out_n];
        buf_rects_out_n += src_tmp.GlyphsCount;
        buf_packedchars_out_n += src_tmp.GlyphsCount;

        // Convert our ranges in the format stb_truetype wants
        ImFontConfig& cfg = atlas->ConfigData[src_i];
        src_tmp.PackRange.font_size = cfg.SizePixels;
        src_tmp.PackRange.first_unicode_codepoint_in_range = 0;
        src_tmp.PackRange.array_of_unicode_codepoints = src_tmp.GlyphsList.Data;
        src_tmp.PackRange.num_chars = src_tmp.GlyphsList.Size;
        src_tmp.PackRange.chardata_for_range = src_tmp.PackedChars;
        src_tmp.PackRange.h_oversample = (unsigned char)cfg.OversampleH;
        src_tmp.PackRange.v_oversample = (unsigned char)cfg.OversampleV;

        // Gather the sizes of all rectangles we will need to pack (this loop is based on stbtt_PackFontRangesGatherRects)
        const float scale = (cfg.SizePixels > 0) ? stbtt_ScaleForPixelHeight(&src_tmp.FontInfo, cfg.SizePixels) : stbtt_ScaleForMappingEmToPixels(&src_tmp.FontInfo, -cfg.SizePixels);
        const int padding = atlas->TexGlyphPadding;
        for (int glyph_i = 0; glyph_i < src_tmp.GlyphsList.Size; glyph_i++)
        {
            int x0, y0, x1, y1;
            const int glyph_index_in_font = stbtt_FindGlyphIndex(&src_tmp.FontInfo, src_tmp.GlyphsList[glyph_i]);
            IM_ASSERT(glyph_index_in_font != 0);
            stbtt_GetGlyphBitmapBoxSubpixel(&src_tmp.FontInfo, glyph_index_in_font, scale * cfg.OversampleH, scale * cfg.OversampleV, 0, 0, &x0, &y0, &x1, &y1);
            src_tmp.Rects[glyph_i].w = (stbrp_coord)(x1 - x0 + padding + cfg.OversampleH - 1);
            src_tmp.Rects[glyph_i].h = (stbrp_coord)(y1 - y0 + padding + cfg.OversampleV - 1);
            total_surface += src_tmp.Rects[glyph_i].w * src_tmp.Rects[glyph_i].h;
        }
    }

    // We need a width for the skyline algorithm, any width!
    // The exact width doesn't really matter much, but some API/GPU have texture size limitations and increasing width can decrease height.
    // User can override TexDesiredWidth and TexGlyphPadding if they wish, otherwise we use a simple heuristic to select the width based on expected surface.
    const int surface_sqrt = (int)ImSqrt((float)total_surface) + 1;
    atlas->TexHeight = 0;
    if (atlas->TexDesiredWidth > 0)
        atlas->TexWidth = atlas->TexDesiredWidth;
    else
        atlas->TexWidth = (surface_sqrt >= 4096*0.7f) ? 4096 : (surface_sqrt >= 2048*0.7f) ? 2048 : (surface_sqrt >= 1024*0.7f) ? 1024 : 512;

    // 5. Start packing
    // Pack our extra data rectangles first, so it will be on the upper-left corner of our texture (UV will have small values).
    const int TEX_HEIGHT_MAX = 1024 * 32;
    stbtt_pack_context spc = {};
    stbtt_PackBegin(&spc, NULL, atlas->TexWidth, TEX_HEIGHT_MAX, 0, atlas->TexGlyphPadding, NULL);
    ImFontAtlasBuildPackCustomRects(atlas, spc.pack_info);

    // 6. Pack each source font. No rendering yet, we are working with rectangles in an infinitely tall texture at this point.
    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
    {
        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
        if (src_tmp.GlyphsCount == 0)
            continue;

        stbrp_pack_rects((stbrp_context*)spc.pack_info, src_tmp.Rects, src_tmp.GlyphsCount);

        // Extend texture height and mark missing glyphs as non-packed so we won't render them.
        // FIXME: We are not handling packing failure here (would happen if we got off TEX_HEIGHT_MAX or if a single if larger than TexWidth?)
        for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++)
            if (src_tmp.Rects[glyph_i].was_packed)
                atlas->TexHeight = ImMax(atlas->TexHeight, src_tmp.Rects[glyph_i].y + src_tmp.Rects[glyph_i].h);
    }

    // 7. Allocate texture
    atlas->TexHeight = (atlas->Flags & ImFontAtlasFlags_NoPowerOfTwoHeight) ? (atlas->TexHeight + 1) : ImUpperPowerOfTwo(atlas->TexHeight);
    atlas->TexUvScale = ImVec2(1.0f / atlas->TexWidth, 1.0f / atlas->TexHeight);
    atlas->TexPixelsAlpha8 = (unsigned char*)IM_ALLOC(atlas->TexWidth * atlas->TexHeight);
    memset(atlas->TexPixelsAlpha8, 0, atlas->TexWidth * atlas->TexHeight);
    spc.pixels = atlas->TexPixelsAlpha8;
    spc.height = atlas->TexHeight;

    // 8. Render/rasterize font characters into the texture
    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
    {
        ImFontConfig& cfg = atlas->ConfigData[src_i];
        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
        if (src_tmp.GlyphsCount == 0)
            continue;

        stbtt_PackFontRangesRenderIntoRects(&spc, &src_tmp.FontInfo, &src_tmp.PackRange, 1, src_tmp.Rects);

        // Apply multiply operator
        if (cfg.RasterizerMultiply != 1.0f)
        {
            unsigned char multiply_table[256];
            ImFontAtlasBuildMultiplyCalcLookupTable(multiply_table, cfg.RasterizerMultiply);
            stbrp_rect* r = &src_tmp.Rects[0];
            for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++, r++)
                if (r->was_packed)
                    ImFontAtlasBuildMultiplyRectAlpha8(multiply_table, atlas->TexPixelsAlpha8, r->x, r->y, r->w, r->h, atlas->TexWidth * 1);
        }
        src_tmp.Rects = NULL;
    }

    // End packing
    stbtt_PackEnd(&spc);
    buf_rects.clear();

    // 9. Setup ImFont and glyphs for runtime
    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
    {
        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
        if (src_tmp.GlyphsCount == 0)
            continue;

        ImFontConfig& cfg = atlas->ConfigData[src_i];
        ImFont* dst_font = cfg.DstFont; // We can have multiple input fonts writing into a same destination font (when using MergeMode=true)

        const float font_scale = stbtt_ScaleForPixelHeight(&src_tmp.FontInfo, cfg.SizePixels);
        int unscaled_ascent, unscaled_descent, unscaled_line_gap;
        stbtt_GetFontVMetrics(&src_tmp.FontInfo, &unscaled_ascent, &unscaled_descent, &unscaled_line_gap);

        const float ascent = ImFloor(unscaled_ascent * font_scale + ((unscaled_ascent > 0.0f) ? +1 : -1));
        const float descent = ImFloor(unscaled_descent * font_scale + ((unscaled_descent > 0.0f) ? +1 : -1));
        ImFontAtlasBuildSetupFont(atlas, dst_font, &cfg, ascent, descent);
        const float font_off_x = cfg.GlyphOffset.x;
        const float font_off_y = cfg.GlyphOffset.y + (float)(int)(dst_font->Ascent + 0.5f);

        for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++)
        {
            const int codepoint = src_tmp.GlyphsList[glyph_i];
            const stbtt_packedchar& pc = src_tmp.PackedChars[glyph_i];

            const float char_advance_x_org = pc.xadvance;
            const float char_advance_x_mod = ImClamp(char_advance_x_org, cfg.GlyphMinAdvanceX, cfg.GlyphMaxAdvanceX);
            float char_off_x = font_off_x;
            if (char_advance_x_org != char_advance_x_mod)
                char_off_x += cfg.PixelSnapH ? (float)(int)((char_advance_x_mod - char_advance_x_org) * 0.5f) : (char_advance_x_mod - char_advance_x_org) * 0.5f;

            // Register glyph
            stbtt_aligned_quad q;
            float dummy_x = 0.0f, dummy_y = 0.0f;
            stbtt_GetPackedQuad(src_tmp.PackedChars, atlas->TexWidth, atlas->TexHeight, glyph_i, &dummy_x, &dummy_y, &q, 0);
            dst_font->AddGlyph((ImWchar)codepoint, q.x0 + char_off_x, q.y0 + font_off_y, q.x1 + char_off_x, q.y1 + font_off_y, q.s0, q.t0, q.s1, q.t1, char_advance_x_mod);
        }
    }

    // Cleanup temporary (ImVector doesn't honor destructor)
    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
        src_tmp_array[src_i].~ImFontBuildSrcData();

    ImFontAtlasBuildFinish(atlas);
    return true;
}

void ImFontAtlasBuildRegisterDefaultCustomRects(ImFontAtlas* atlas)
{
    if (atlas->CustomRectIds[0] >= 0)
        return;
    if (!(atlas->Flags & ImFontAtlasFlags_NoMouseCursors))
        atlas->CustomRectIds[0] = atlas->AddCustomRectRegular(FONT_ATLAS_DEFAULT_TEX_DATA_ID, FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF*2+1, FONT_ATLAS_DEFAULT_TEX_DATA_H);
    else
        atlas->CustomRectIds[0] = atlas->AddCustomRectRegular(FONT_ATLAS_DEFAULT_TEX_DATA_ID, 2, 2);
}

void ImFontAtlasBuildSetupFont(ImFontAtlas* atlas, ImFont* font, ImFontConfig* font_config, float ascent, float descent)
{
    if (!font_config->MergeMode)
    {
        font->ClearOutputData();
        font->FontSize = font_config->SizePixels;
        font->ConfigData = font_config;
        font->ContainerAtlas = atlas;
        font->Ascent = ascent;
        font->Descent = descent;
    }
    font->ConfigDataCount++;
}

void ImFontAtlasBuildPackCustomRects(ImFontAtlas* atlas, void* stbrp_context_opaque)
{
    stbrp_context* pack_context = (stbrp_context*)stbrp_context_opaque;
    IM_ASSERT(pack_context != NULL);

    ImVector<ImFontAtlas::CustomRect>& user_rects = atlas->CustomRects;
    IM_ASSERT(user_rects.Size >= 1); // We expect at least the default custom rects to be registered, else something went wrong.

    ImVector<stbrp_rect> pack_rects;
    pack_rects.resize(user_rects.Size);
    memset(pack_rects.Data, 0, (size_t)pack_rects.size_in_bytes());
    for (int i = 0; i < user_rects.Size; i++)
    {
        pack_rects[i].w = user_rects[i].Width;
        pack_rects[i].h = user_rects[i].Height;
    }
    stbrp_pack_rects(pack_context, &pack_rects[0], pack_rects.Size);
    for (int i = 0; i < pack_rects.Size; i++)
        if (pack_rects[i].was_packed)
        {
            user_rects[i].X = pack_rects[i].x;
            user_rects[i].Y = pack_rects[i].y;
            IM_ASSERT(pack_rects[i].w == user_rects[i].Width && pack_rects[i].h == user_rects[i].Height);
            atlas->TexHeight = ImMax(atlas->TexHeight, pack_rects[i].y + pack_rects[i].h);
        }
}

static void ImFontAtlasBuildRenderDefaultTexData(ImFontAtlas* atlas)
{
    IM_ASSERT(atlas->CustomRectIds[0] >= 0);
    IM_ASSERT(atlas->TexPixelsAlpha8 != NULL);
    ImFontAtlas::CustomRect& r = atlas->CustomRects[atlas->CustomRectIds[0]];
    IM_ASSERT(r.ID == FONT_ATLAS_DEFAULT_TEX_DATA_ID);
    IM_ASSERT(r.IsPacked());

    const int w = atlas->TexWidth;
    if (!(atlas->Flags & ImFontAtlasFlags_NoMouseCursors))
    {
        // Render/copy pixels
        IM_ASSERT(r.Width == FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF * 2 + 1 && r.Height == FONT_ATLAS_DEFAULT_TEX_DATA_H);
        for (int y = 0, n = 0; y < FONT_ATLAS_DEFAULT_TEX_DATA_H; y++)
            for (int x = 0; x < FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF; x++, n++)
            {
                const int offset0 = (int)(r.X + x) + (int)(r.Y + y) * w;
                const int offset1 = offset0 + FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF + 1;
                atlas->TexPixelsAlpha8[offset0] = FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS[n] == '.' ? 0xFF : 0x00;
                atlas->TexPixelsAlpha8[offset1] = FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS[n] == 'X' ? 0xFF : 0x00;
            }
    }
    else
    {
        IM_ASSERT(r.Width == 2 && r.Height == 2);
        const int offset = (int)(r.X) + (int)(r.Y) * w;
        atlas->TexPixelsAlpha8[offset] = atlas->TexPixelsAlpha8[offset + 1] = atlas->TexPixelsAlpha8[offset + w] = atlas->TexPixelsAlpha8[offset + w + 1] = 0xFF;
    }
    atlas->TexUvWhitePixel = ImVec2((r.X + 0.5f) * atlas->TexUvScale.x, (r.Y + 0.5f) * atlas->TexUvScale.y);
}

void ImFontAtlasBuildFinish(ImFontAtlas* atlas)
{
    // Render into our custom data block
    ImFontAtlasBuildRenderDefaultTexData(atlas);

    // Register custom rectangle glyphs
    for (int i = 0; i < atlas->CustomRects.Size; i++)
    {
        const ImFontAtlas::CustomRect& r = atlas->CustomRects[i];
        if (r.Font == NULL || r.ID > 0x10000)
            continue;

        IM_ASSERT(r.Font->ContainerAtlas == atlas);
        ImVec2 uv0, uv1;
        atlas->CalcCustomRectUV(&r, &uv0, &uv1);
        r.Font->AddGlyph((ImWchar)r.ID, r.GlyphOffset.x, r.GlyphOffset.y, r.GlyphOffset.x + r.Width, r.GlyphOffset.y + r.Height, uv0.x, uv0.y, uv1.x, uv1.y, r.GlyphAdvanceX);
    }

    // Build all fonts lookup tables
    for (int i = 0; i < atlas->Fonts.Size; i++)
        if (atlas->Fonts[i]->DirtyLookupTables)
            atlas->Fonts[i]->BuildLookupTable();
}

// Retrieve list of range (2 int per range, values are inclusive)
const ImWchar*   ImFontAtlas::GetGlyphRangesDefault()
{
    static const ImWchar ranges[] =
    {
        0x0020, 0x00FF, // Basic Latin + Latin Supplement
        0,
    };
    return &ranges[0];
}

const ImWchar*  ImFontAtlas::GetGlyphRangesKorean()
{
    static const ImWchar ranges[] =
    {
        0x0020, 0x00FF, // Basic Latin + Latin Supplement
        0x3131, 0x3163, // Korean alphabets
        0xAC00, 0xD79D, // Korean characters
        0,
    };
    return &ranges[0];
}

const ImWchar*  ImFontAtlas::GetGlyphRangesChineseFull()
{
    static const ImWchar ranges[] =
    {
        0x0020, 0x00FF, // Basic Latin + Latin Supplement
        0x2000, 0x206F, // General Punctuation
        0x3000, 0x30FF, // CJK Symbols and Punctuations, Hiragana, Katakana
        0x31F0, 0x31FF, // Katakana Phonetic Extensions
        0xFF00, 0xFFEF, // Half-width characters
        0x4e00, 0x9FAF, // CJK Ideograms
        0,
    };
    return &ranges[0];
}

static void UnpackAccumulativeOffsetsIntoRanges(int base_codepoint, const short* accumulative_offsets, int accumulative_offsets_count, ImWchar* out_ranges)
{
    for (int n = 0; n < accumulative_offsets_count; n++, out_ranges += 2)
    {
        out_ranges[0] = out_ranges[1] = (ImWchar)(base_codepoint + accumulative_offsets[n]);
        base_codepoint += accumulative_offsets[n];
    }
    out_ranges[0] = 0;
}

//-------------------------------------------------------------------------
// [SECTION] ImFontAtlas glyph ranges helpers
//-------------------------------------------------------------------------

const ImWchar*  ImFontAtlas::GetGlyphRangesChineseSimplifiedCommon()
{
    // Store 2500 regularly used characters for Simplified Chinese.
    // Sourced from https://zh.wiktionary.org/wiki/%E9%99%84%E5%BD%95:%E7%8E%B0%E4%BB%A3%E6%B1%89%E8%AF%AD%E5%B8%B8%E7%94%A8%E5%AD%97%E8%A1%A8
    // This table covers 97.97% of all characters used during the month in July, 1987.
    // You can use ImFontGlyphRangesBuilder to create your own ranges derived from this, by merging existing ranges or adding new characters.
    // (Stored as accumulative offsets from the initial unicode codepoint 0x4E00. This encoding is designed to helps us compact the source code size.)
    static const short accumulative_offsets_from_0x4E00[] =
    {
        0,1,2,4,1,1,1,1,2,1,3,2,1,2,2,1,1,1,1,1,5,2,1,2,3,3,3,2,2,4,1,1,1,2,1,5,2,3,1,2,1,2,1,1,2,1,1,2,2,1,4,1,1,1,1,5,10,1,2,19,2,1,2,1,2,1,2,1,2,
        1,5,1,6,3,2,1,2,2,1,1,1,4,8,5,1,1,4,1,1,3,1,2,1,5,1,2,1,1,1,10,1,1,5,2,4,6,1,4,2,2,2,12,2,1,1,6,1,1,1,4,1,1,4,6,5,1,4,2,2,4,10,7,1,1,4,2,4,
        2,1,4,3,6,10,12,5,7,2,14,2,9,1,1,6,7,10,4,7,13,1,5,4,8,4,1,1,2,28,5,6,1,1,5,2,5,20,2,2,9,8,11,2,9,17,1,8,6,8,27,4,6,9,20,11,27,6,68,2,2,1,1,
        1,2,1,2,2,7,6,11,3,3,1,1,3,1,2,1,1,1,1,1,3,1,1,8,3,4,1,5,7,2,1,4,4,8,4,2,1,2,1,1,4,5,6,3,6,2,12,3,1,3,9,2,4,3,4,1,5,3,3,1,3,7,1,5,1,1,1,1,2,
        3,4,5,2,3,2,6,1,1,2,1,7,1,7,3,4,5,15,2,2,1,5,3,22,19,2,1,1,1,1,2,5,1,1,1,6,1,1,12,8,2,9,18,22,4,1,1,5,1,16,1,2,7,10,15,1,1,6,2,4,1,2,4,1,6,
        1,1,3,2,4,1,6,4,5,1,2,1,1,2,1,10,3,1,3,2,1,9,3,2,5,7,2,19,4,3,6,1,1,1,1,1,4,3,2,1,1,1,2,5,3,1,1,1,2,2,1,1,2,1,1,2,1,3,1,1,1,3,7,1,4,1,1,2,1,
        1,2,1,2,4,4,3,8,1,1,1,2,1,3,5,1,3,1,3,4,6,2,2,14,4,6,6,11,9,1,15,3,1,28,5,2,5,5,3,1,3,4,5,4,6,14,3,2,3,5,21,2,7,20,10,1,2,19,2,4,28,28,2,3,
        2,1,14,4,1,26,28,42,12,40,3,52,79,5,14,17,3,2,2,11,3,4,6,3,1,8,2,23,4,5,8,10,4,2,7,3,5,1,1,6,3,1,2,2,2,5,28,1,1,7,7,20,5,3,29,3,17,26,1,8,4,
        27,3,6,11,23,5,3,4,6,13,24,16,6,5,10,25,35,7,3,2,3,3,14,3,6,2,6,1,4,2,3,8,2,1,1,3,3,3,4,1,1,13,2,2,4,5,2,1,14,14,1,2,2,1,4,5,2,3,1,14,3,12,
        3,17,2,16,5,1,2,1,8,9,3,19,4,2,2,4,17,25,21,20,28,75,1,10,29,103,4,1,2,1,1,4,2,4,1,2,3,24,2,2,2,1,1,2,1,3,8,1,1,1,2,1,1,3,1,1,1,6,1,5,3,1,1,
        1,3,4,1,1,5,2,1,5,6,13,9,16,1,1,1,1,3,2,3,2,4,5,2,5,2,2,3,7,13,7,2,2,1,1,1,1,2,3,3,2,1,6,4,9,2,1,14,2,14,2,1,18,3,4,14,4,11,41,15,23,15,23,
        176,1,3,4,1,1,1,1,5,3,1,2,3,7,3,1,1,2,1,2,4,4,6,2,4,1,9,7,1,10,5,8,16,29,1,1,2,2,3,1,3,5,2,4,5,4,1,1,2,2,3,3,7,1,6,10,1,17,1,44,4,6,2,1,1,6,
        5,4,2,10,1,6,9,2,8,1,24,1,2,13,7,8,8,2,1,4,1,3,1,3,3,5,2,5,10,9,4,9,12,2,1,6,1,10,1,1,7,7,4,10,8,3,1,13,4,3,1,6,1,3,5,2,1,2,17,16,5,2,16,6,
        1,4,2,1,3,3,6,8,5,11,11,1,3,3,2,4,6,10,9,5,7,4,7,4,7,1,1,4,2,1,3,6,8,7,1,6,11,5,5,3,24,9,4,2,7,13,5,1,8,82,16,61,1,1,1,4,2,2,16,10,3,8,1,1,
        6,4,2,1,3,1,1,1,4,3,8,4,2,2,1,1,1,1,1,6,3,5,1,1,4,6,9,2,1,1,1,2,1,7,2,1,6,1,5,4,4,3,1,8,1,3,3,1,3,2,2,2,2,3,1,6,1,2,1,2,1,3,7,1,8,2,1,2,1,5,
        2,5,3,5,10,1,2,1,1,3,2,5,11,3,9,3,5,1,1,5,9,1,2,1,5,7,9,9,8,1,3,3,3,6,8,2,3,2,1,1,32,6,1,2,15,9,3,7,13,1,3,10,13,2,14,1,13,10,2,1,3,10,4,15,
        2,15,15,10,1,3,9,6,9,32,25,26,47,7,3,2,3,1,6,3,4,3,2,8,5,4,1,9,4,2,2,19,10,6,2,3,8,1,2,2,4,2,1,9,4,4,4,6,4,8,9,2,3,1,1,1,1,3,5,5,1,3,8,4,6,
        2,1,4,12,1,5,3,7,13,2,5,8,1,6,1,2,5,14,6,1,5,2,4,8,15,5,1,23,6,62,2,10,1,1,8,1,2,2,10,4,2,2,9,2,1,1,3,2,3,1,5,3,3,2,1,3,8,1,1,1,11,3,1,1,4,
        3,7,1,14,1,2,3,12,5,2,5,1,6,7,5,7,14,11,1,3,1,8,9,12,2,1,11,8,4,4,2,6,10,9,13,1,1,3,1,5,1,3,2,4,4,1,18,2,3,14,11,4,29,4,2,7,1,3,13,9,2,2,5,
        3,5,20,7,16,8,5,72,34,6,4,22,12,12,28,45,36,9,7,39,9,191,1,1,1,4,11,8,4,9,2,3,22,1,1,1,1,4,17,1,7,7,1,11,31,10,2,4,8,2,3,2,1,4,2,16,4,32,2,
        3,19,13,4,9,1,5,2,14,8,1,1,3,6,19,6,5,1,16,6,2,10,8,5,1,2,3,1,5,5,1,11,6,6,1,3,3,2,6,3,8,1,1,4,10,7,5,7,7,5,8,9,2,1,3,4,1,1,3,1,3,3,2,6,16,
        1,4,6,3,1,10,6,1,3,15,2,9,2,10,25,13,9,16,6,2,2,10,11,4,3,9,1,2,6,6,5,4,30,40,1,10,7,12,14,33,6,3,6,7,3,1,3,1,11,14,4,9,5,12,11,49,18,51,31,
        140,31,2,2,1,5,1,8,1,10,1,4,4,3,24,1,10,1,3,6,6,16,3,4,5,2,1,4,2,57,10,6,22,2,22,3,7,22,6,10,11,36,18,16,33,36,2,5,5,1,1,1,4,10,1,4,13,2,7,
        5,2,9,3,4,1,7,43,3,7,3,9,14,7,9,1,11,1,1,3,7,4,18,13,1,14,1,3,6,10,73,2,2,30,6,1,11,18,19,13,22,3,46,42,37,89,7,3,16,34,2,2,3,9,1,7,1,1,1,2,
        2,4,10,7,3,10,3,9,5,28,9,2,6,13,7,3,1,3,10,2,7,2,11,3,6,21,54,85,2,1,4,2,2,1,39,3,21,2,2,5,1,1,1,4,1,1,3,4,15,1,3,2,4,4,2,3,8,2,20,1,8,7,13,
        4,1,26,6,2,9,34,4,21,52,10,4,4,1,5,12,2,11,1,7,2,30,12,44,2,30,1,1,3,6,16,9,17,39,82,2,2,24,7,1,7,3,16,9,14,44,2,1,2,1,2,3,5,2,4,1,6,7,5,3,
        2,6,1,11,5,11,2,1,18,19,8,1,3,24,29,2,1,3,5,2,2,1,13,6,5,1,46,11,3,5,1,1,5,8,2,10,6,12,6,3,7,11,2,4,16,13,2,5,1,1,2,2,5,2,28,5,2,23,10,8,4,
        4,22,39,95,38,8,14,9,5,1,13,5,4,3,13,12,11,1,9,1,27,37,2,5,4,4,63,211,95,2,2,2,1,3,5,2,1,1,2,2,1,1,1,3,2,4,1,2,1,1,5,2,2,1,1,2,3,1,3,1,1,1,
        3,1,4,2,1,3,6,1,1,3,7,15,5,3,2,5,3,9,11,4,2,22,1,6,3,8,7,1,4,28,4,16,3,3,25,4,4,27,27,1,4,1,2,2,7,1,3,5,2,28,8,2,14,1,8,6,16,25,3,3,3,14,3,
        3,1,1,2,1,4,6,3,8,4,1,1,1,2,3,6,10,6,2,3,18,3,2,5,5,4,3,1,5,2,5,4,23,7,6,12,6,4,17,11,9,5,1,1,10,5,12,1,1,11,26,33,7,3,6,1,17,7,1,5,12,1,11,
        2,4,1,8,14,17,23,1,2,1,7,8,16,11,9,6,5,2,6,4,16,2,8,14,1,11,8,9,1,1,1,9,25,4,11,19,7,2,15,2,12,8,52,7,5,19,2,16,4,36,8,1,16,8,24,26,4,6,2,9,
        5,4,36,3,28,12,25,15,37,27,17,12,59,38,5,32,127,1,2,9,17,14,4,1,2,1,1,8,11,50,4,14,2,19,16,4,17,5,4,5,26,12,45,2,23,45,104,30,12,8,3,10,2,2,
        3,3,1,4,20,7,2,9,6,15,2,20,1,3,16,4,11,15,6,134,2,5,59,1,2,2,2,1,9,17,3,26,137,10,211,59,1,2,4,1,4,1,1,1,2,6,2,3,1,1,2,3,2,3,1,3,4,4,2,3,3,
        1,4,3,1,7,2,2,3,1,2,1,3,3,3,2,2,3,2,1,3,14,6,1,3,2,9,6,15,27,9,34,145,1,1,2,1,1,1,1,2,1,1,1,1,2,2,2,3,1,2,1,1,1,2,3,5,8,3,5,2,4,1,3,2,2,2,12,
        4,1,1,1,10,4,5,1,20,4,16,1,15,9,5,12,2,9,2,5,4,2,26,19,7,1,26,4,30,12,15,42,1,6,8,172,1,1,4,2,1,1,11,2,2,4,2,1,2,1,10,8,1,2,1,4,5,1,2,5,1,8,
        4,1,3,4,2,1,6,2,1,3,4,1,2,1,1,1,1,12,5,7,2,4,3,1,1,1,3,3,6,1,2,2,3,3,3,2,1,2,12,14,11,6,6,4,12,2,8,1,7,10,1,35,7,4,13,15,4,3,23,21,28,52,5,
        26,5,6,1,7,10,2,7,53,3,2,1,1,1,2,163,532,1,10,11,1,3,3,4,8,2,8,6,2,2,23,22,4,2,2,4,2,1,3,1,3,3,5,9,8,2,1,2,8,1,10,2,12,21,20,15,105,2,3,1,1,
        3,2,3,1,1,2,5,1,4,15,11,19,1,1,1,1,5,4,5,1,1,2,5,3,5,12,1,2,5,1,11,1,1,15,9,1,4,5,3,26,8,2,1,3,1,1,15,19,2,12,1,2,5,2,7,2,19,2,20,6,26,7,5,
        2,2,7,34,21,13,70,2,128,1,1,2,1,1,2,1,1,3,2,2,2,15,1,4,1,3,4,42,10,6,1,49,85,8,1,2,1,1,4,4,2,3,6,1,5,7,4,3,211,4,1,2,1,2,5,1,2,4,2,2,6,5,6,
        10,3,4,48,100,6,2,16,296,5,27,387,2,2,3,7,16,8,5,38,15,39,21,9,10,3,7,59,13,27,21,47,5,21,6
    };
    static ImWchar base_ranges[] = // not zero-terminated
    {
        0x0020, 0x00FF, // Basic Latin + Latin Supplement
        0x2000, 0x206F, // General Punctuation
        0x3000, 0x30FF, // CJK Symbols and Punctuations, Hiragana, Katakana
        0x31F0, 0x31FF, // Katakana Phonetic Extensions
        0xFF00, 0xFFEF  // Half-width characters
    };
    static ImWchar full_ranges[IM_ARRAYSIZE(base_ranges) + IM_ARRAYSIZE(accumulative_offsets_from_0x4E00) * 2 + 1] = { 0 };
    if (!full_ranges[0])
    {
        memcpy(full_ranges, base_ranges, sizeof(base_ranges));
        UnpackAccumulativeOffsetsIntoRanges(0x4E00, accumulative_offsets_from_0x4E00, IM_ARRAYSIZE(accumulative_offsets_from_0x4E00), full_ranges + IM_ARRAYSIZE(base_ranges));
    }
    return &full_ranges[0];
}

const ImWchar*  ImFontAtlas::GetGlyphRangesJapanese()
{
    // 1946 common ideograms code points for Japanese
    // Sourced from http://theinstructionlimit.com/common-kanji-character-ranges-for-xna-spritefont-rendering
    // FIXME: Source a list of the revised 2136 Joyo Kanji list from 2010 and rebuild this.
    // You can use ImFontGlyphRangesBuilder to create your own ranges derived from this, by merging existing ranges or adding new characters.
    // (Stored as accumulative offsets from the initial unicode codepoint 0x4E00. This encoding is designed to helps us compact the source code size.)
    static const short accumulative_offsets_from_0x4E00[] =
    {
        0,1,2,4,1,1,1,1,2,1,6,2,2,1,8,5,7,11,1,2,10,10,8,2,4,20,2,11,8,2,1,2,1,6,2,1,7,5,3,7,1,1,13,7,9,1,4,6,1,2,1,10,1,1,9,2,2,4,5,6,14,1,1,9,3,18,
        5,4,2,2,10,7,1,1,1,3,2,4,3,23,2,10,12,2,14,2,4,13,1,6,10,3,1,7,13,6,4,13,5,2,3,17,2,2,5,7,6,4,1,7,14,16,6,13,9,15,1,1,7,16,4,7,1,19,9,2,7,15,
        2,6,5,13,25,4,14,13,11,25,1,1,1,2,1,2,2,3,10,11,3,3,1,1,4,4,2,1,4,9,1,4,3,5,5,2,7,12,11,15,7,16,4,5,16,2,1,1,6,3,3,1,1,2,7,6,6,7,1,4,7,6,1,1,
        2,1,12,3,3,9,5,8,1,11,1,2,3,18,20,4,1,3,6,1,7,3,5,5,7,2,2,12,3,1,4,2,3,2,3,11,8,7,4,17,1,9,25,1,1,4,2,2,4,1,2,7,1,1,1,3,1,2,6,16,1,2,1,1,3,12,
        20,2,5,20,8,7,6,2,1,1,1,1,6,2,1,2,10,1,1,6,1,3,1,2,1,4,1,12,4,1,3,1,1,1,1,1,10,4,7,5,13,1,15,1,1,30,11,9,1,15,38,14,1,32,17,20,1,9,31,2,21,9,
        4,49,22,2,1,13,1,11,45,35,43,55,12,19,83,1,3,2,3,13,2,1,7,3,18,3,13,8,1,8,18,5,3,7,25,24,9,24,40,3,17,24,2,1,6,2,3,16,15,6,7,3,12,1,9,7,3,3,
        3,15,21,5,16,4,5,12,11,11,3,6,3,2,31,3,2,1,1,23,6,6,1,4,2,6,5,2,1,1,3,3,22,2,6,2,3,17,3,2,4,5,1,9,5,1,1,6,15,12,3,17,2,14,2,8,1,23,16,4,2,23,
        8,15,23,20,12,25,19,47,11,21,65,46,4,3,1,5,6,1,2,5,26,2,1,1,3,11,1,1,1,2,1,2,3,1,1,10,2,3,1,1,1,3,6,3,2,2,6,6,9,2,2,2,6,2,5,10,2,4,1,2,1,2,2,
        3,1,1,3,1,2,9,23,9,2,1,1,1,1,5,3,2,1,10,9,6,1,10,2,31,25,3,7,5,40,1,15,6,17,7,27,180,1,3,2,2,1,1,1,6,3,10,7,1,3,6,17,8,6,2,2,1,3,5,5,8,16,14,
        15,1,1,4,1,2,1,1,1,3,2,7,5,6,2,5,10,1,4,2,9,1,1,11,6,1,44,1,3,7,9,5,1,3,1,1,10,7,1,10,4,2,7,21,15,7,2,5,1,8,3,4,1,3,1,6,1,4,2,1,4,10,8,1,4,5,
        1,5,10,2,7,1,10,1,1,3,4,11,10,29,4,7,3,5,2,3,33,5,2,19,3,1,4,2,6,31,11,1,3,3,3,1,8,10,9,12,11,12,8,3,14,8,6,11,1,4,41,3,1,2,7,13,1,5,6,2,6,12,
        12,22,5,9,4,8,9,9,34,6,24,1,1,20,9,9,3,4,1,7,2,2,2,6,2,28,5,3,6,1,4,6,7,4,2,1,4,2,13,6,4,4,3,1,8,8,3,2,1,5,1,2,2,3,1,11,11,7,3,6,10,8,6,16,16,
        22,7,12,6,21,5,4,6,6,3,6,1,3,2,1,2,8,29,1,10,1,6,13,6,6,19,31,1,13,4,4,22,17,26,33,10,4,15,12,25,6,67,10,2,3,1,6,10,2,6,2,9,1,9,4,4,1,2,16,2,
        5,9,2,3,8,1,8,3,9,4,8,6,4,8,11,3,2,1,1,3,26,1,7,5,1,11,1,5,3,5,2,13,6,39,5,1,5,2,11,6,10,5,1,15,5,3,6,19,21,22,2,4,1,6,1,8,1,4,8,2,4,2,2,9,2,
        1,1,1,4,3,6,3,12,7,1,14,2,4,10,2,13,1,17,7,3,2,1,3,2,13,7,14,12,3,1,29,2,8,9,15,14,9,14,1,3,1,6,5,9,11,3,38,43,20,7,7,8,5,15,12,19,15,81,8,7,
        1,5,73,13,37,28,8,8,1,15,18,20,165,28,1,6,11,8,4,14,7,15,1,3,3,6,4,1,7,14,1,1,11,30,1,5,1,4,14,1,4,2,7,52,2,6,29,3,1,9,1,21,3,5,1,26,3,11,14,
        11,1,17,5,1,2,1,3,2,8,1,2,9,12,1,1,2,3,8,3,24,12,7,7,5,17,3,3,3,1,23,10,4,4,6,3,1,16,17,22,3,10,21,16,16,6,4,10,2,1,1,2,8,8,6,5,3,3,3,39,25,
        15,1,1,16,6,7,25,15,6,6,12,1,22,13,1,4,9,5,12,2,9,1,12,28,8,3,5,10,22,60,1,2,40,4,61,63,4,1,13,12,1,4,31,12,1,14,89,5,16,6,29,14,2,5,49,18,18,
        5,29,33,47,1,17,1,19,12,2,9,7,39,12,3,7,12,39,3,1,46,4,12,3,8,9,5,31,15,18,3,2,2,66,19,13,17,5,3,46,124,13,57,34,2,5,4,5,8,1,1,1,4,3,1,17,5,
        3,5,3,1,8,5,6,3,27,3,26,7,12,7,2,17,3,7,18,78,16,4,36,1,2,1,6,2,1,39,17,7,4,13,4,4,4,1,10,4,2,4,6,3,10,1,19,1,26,2,4,33,2,73,47,7,3,8,2,4,15,
        18,1,29,2,41,14,1,21,16,41,7,39,25,13,44,2,2,10,1,13,7,1,7,3,5,20,4,8,2,49,1,10,6,1,6,7,10,7,11,16,3,12,20,4,10,3,1,2,11,2,28,9,2,4,7,2,15,1,
        27,1,28,17,4,5,10,7,3,24,10,11,6,26,3,2,7,2,2,49,16,10,16,15,4,5,27,61,30,14,38,22,2,7,5,1,3,12,23,24,17,17,3,3,2,4,1,6,2,7,5,1,1,5,1,1,9,4,
        1,3,6,1,8,2,8,4,14,3,5,11,4,1,3,32,1,19,4,1,13,11,5,2,1,8,6,8,1,6,5,13,3,23,11,5,3,16,3,9,10,1,24,3,198,52,4,2,2,5,14,5,4,22,5,20,4,11,6,41,
        1,5,2,2,11,5,2,28,35,8,22,3,18,3,10,7,5,3,4,1,5,3,8,9,3,6,2,16,22,4,5,5,3,3,18,23,2,6,23,5,27,8,1,33,2,12,43,16,5,2,3,6,1,20,4,2,9,7,1,11,2,
        10,3,14,31,9,3,25,18,20,2,5,5,26,14,1,11,17,12,40,19,9,6,31,83,2,7,9,19,78,12,14,21,76,12,113,79,34,4,1,1,61,18,85,10,2,2,13,31,11,50,6,33,159,
        179,6,6,7,4,4,2,4,2,5,8,7,20,32,22,1,3,10,6,7,28,5,10,9,2,77,19,13,2,5,1,4,4,7,4,13,3,9,31,17,3,26,2,6,6,5,4,1,7,11,3,4,2,1,6,2,20,4,1,9,2,6,
        3,7,1,1,1,20,2,3,1,6,2,3,6,2,4,8,1,5,13,8,4,11,23,1,10,6,2,1,3,21,2,2,4,24,31,4,10,10,2,5,192,15,4,16,7,9,51,1,2,1,1,5,1,1,2,1,3,5,3,1,3,4,1,
        3,1,3,3,9,8,1,2,2,2,4,4,18,12,92,2,10,4,3,14,5,25,16,42,4,14,4,2,21,5,126,30,31,2,1,5,13,3,22,5,6,6,20,12,1,14,12,87,3,19,1,8,2,9,9,3,3,23,2,
        3,7,6,3,1,2,3,9,1,3,1,6,3,2,1,3,11,3,1,6,10,3,2,3,1,2,1,5,1,1,11,3,6,4,1,7,2,1,2,5,5,34,4,14,18,4,19,7,5,8,2,6,79,1,5,2,14,8,2,9,2,1,36,28,16,
        4,1,1,1,2,12,6,42,39,16,23,7,15,15,3,2,12,7,21,64,6,9,28,8,12,3,3,41,59,24,51,55,57,294,9,9,2,6,2,15,1,2,13,38,90,9,9,9,3,11,7,1,1,1,5,6,3,2,
        1,2,2,3,8,1,4,4,1,5,7,1,4,3,20,4,9,1,1,1,5,5,17,1,5,2,6,2,4,1,4,5,7,3,18,11,11,32,7,5,4,7,11,127,8,4,3,3,1,10,1,1,6,21,14,1,16,1,7,1,3,6,9,65,
        51,4,3,13,3,10,1,1,12,9,21,110,3,19,24,1,1,10,62,4,1,29,42,78,28,20,18,82,6,3,15,6,84,58,253,15,155,264,15,21,9,14,7,58,40,39,
    };
    static ImWchar base_ranges[] = // not zero-terminated
    {
        0x0020, 0x00FF, // Basic Latin + Latin Supplement
        0x3000, 0x30FF, // CJK Symbols and Punctuations, Hiragana, Katakana
        0x31F0, 0x31FF, // Katakana Phonetic Extensions
        0xFF00, 0xFFEF  // Half-width characters
    };
    static ImWchar full_ranges[IM_ARRAYSIZE(base_ranges) + IM_ARRAYSIZE(accumulative_offsets_from_0x4E00)*2 + 1] = { 0 };
    if (!full_ranges[0])
    {
        memcpy(full_ranges, base_ranges, sizeof(base_ranges));
        UnpackAccumulativeOffsetsIntoRanges(0x4E00, accumulative_offsets_from_0x4E00, IM_ARRAYSIZE(accumulative_offsets_from_0x4E00), full_ranges + IM_ARRAYSIZE(base_ranges));
    }
    return &full_ranges[0];
}

const ImWchar*  ImFontAtlas::GetGlyphRangesCyrillic()
{
    static const ImWchar ranges[] =
    {
        0x0020, 0x00FF, // Basic Latin + Latin Supplement
        0x0400, 0x052F, // Cyrillic + Cyrillic Supplement
        0x2DE0, 0x2DFF, // Cyrillic Extended-A
        0xA640, 0xA69F, // Cyrillic Extended-B
        0,
    };
    return &ranges[0];
}

const ImWchar*  ImFontAtlas::GetGlyphRangesThai()
{
    static const ImWchar ranges[] =
    {
        0x0020, 0x00FF, // Basic Latin
        0x2010, 0x205E, // Punctuations
        0x0E00, 0x0E7F, // Thai
        0,
    };
    return &ranges[0];
}

const ImWchar*  ImFontAtlas::GetGlyphRangesVietnamese()
{
    static const ImWchar ranges[] =
    {
        0x0020, 0x00FF, // Basic Latin
        0x0102, 0x0103,
        0x0110, 0x0111,
        0x0128, 0x0129,
        0x0168, 0x0169,
        0x01A0, 0x01A1,
        0x01AF, 0x01B0,
        0x1EA0, 0x1EF9,
        0,
    };
    return &ranges[0];
}

//-----------------------------------------------------------------------------
// [SECTION] ImFontGlyphRangesBuilder
//-----------------------------------------------------------------------------

void ImFontGlyphRangesBuilder::AddText(const char* text, const char* text_end)
{
    while (text_end ? (text < text_end) : *text)
    {
        unsigned int c = 0;
        int c_len = ImTextCharFromUtf8(&c, text, text_end);
        text += c_len;
        if (c_len == 0)
            break;
        if (c < 0x10000)
            AddChar((ImWchar)c);
    }
}

void ImFontGlyphRangesBuilder::AddRanges(const ImWchar* ranges)
{
    for (; ranges[0]; ranges += 2)
        for (ImWchar c = ranges[0]; c <= ranges[1]; c++)
            AddChar(c);
}

void ImFontGlyphRangesBuilder::BuildRanges(ImVector<ImWchar>* out_ranges)
{
    for (int n = 0; n < 0x10000; n++)
        if (GetBit(n))
        {
            out_ranges->push_back((ImWchar)n);
            while (n < 0x10000 && GetBit(n + 1))
                n++;
            out_ranges->push_back((ImWchar)n);
        }
    out_ranges->push_back(0);
}

//-----------------------------------------------------------------------------
// [SECTION] ImFont
//-----------------------------------------------------------------------------

ImFont::ImFont()
{
    FontSize = 0.0f;
    FallbackAdvanceX = 0.0f;
    FallbackChar = (ImWchar)'?';
    DisplayOffset = ImVec2(0.0f, 0.0f);
    FallbackGlyph = NULL;
    ContainerAtlas = NULL;
    ConfigData = NULL;
    ConfigDataCount = 0;
    DirtyLookupTables = false;
    Scale = 1.0f;
    Ascent = Descent = 0.0f;
    MetricsTotalSurface = 0;
}

ImFont::~ImFont()
{
    ClearOutputData();
}

void    ImFont::ClearOutputData()
{
    FontSize = 0.0f;
    FallbackAdvanceX = 0.0f;
    Glyphs.clear();
    IndexAdvanceX.clear();
    IndexLookup.clear();
    FallbackGlyph = NULL;
    ContainerAtlas = NULL;
    DirtyLookupTables = true;
    Ascent = Descent = 0.0f;
    MetricsTotalSurface = 0;
}

void ImFont::BuildLookupTable()
{
    int max_codepoint = 0;
    for (int i = 0; i != Glyphs.Size; i++)
        max_codepoint = ImMax(max_codepoint, (int)Glyphs[i].Codepoint);

    IM_ASSERT(Glyphs.Size < 0xFFFF); // -1 is reserved
    IndexAdvanceX.clear();
    IndexLookup.clear();
    DirtyLookupTables = false;
    GrowIndex(max_codepoint + 1);
    for (int i = 0; i < Glyphs.Size; i++)
    {
        int codepoint = (int)Glyphs[i].Codepoint;
        IndexAdvanceX[codepoint] = Glyphs[i].AdvanceX;
        IndexLookup[codepoint] = (ImWchar)i;
    }

    // Create a glyph to handle TAB
    // FIXME: Needs proper TAB handling but it needs to be contextualized (or we could arbitrary say that each string starts at "column 0" ?)
    if (FindGlyph((ImWchar)' '))
    {
        if (Glyphs.back().Codepoint != '\t')   // So we can call this function multiple times
            Glyphs.resize(Glyphs.Size + 1);
        ImFontGlyph& tab_glyph = Glyphs.back();
        tab_glyph = *FindGlyph((ImWchar)' ');
        tab_glyph.Codepoint = '\t';
        tab_glyph.AdvanceX *= IM_TABSIZE;
        IndexAdvanceX[(int)tab_glyph.Codepoint] = (float)tab_glyph.AdvanceX;
        IndexLookup[(int)tab_glyph.Codepoint] = (ImWchar)(Glyphs.Size-1);
    }

    FallbackGlyph = FindGlyphNoFallback(FallbackChar);
    FallbackAdvanceX = FallbackGlyph ? FallbackGlyph->AdvanceX : 0.0f;
    for (int i = 0; i < max_codepoint + 1; i++)
        if (IndexAdvanceX[i] < 0.0f)
            IndexAdvanceX[i] = FallbackAdvanceX;
}

void ImFont::SetFallbackChar(ImWchar c)
{
    FallbackChar = c;
    BuildLookupTable();
}

void ImFont::GrowIndex(int new_size)
{
    IM_ASSERT(IndexAdvanceX.Size == IndexLookup.Size);
    if (new_size <= IndexLookup.Size)
        return;
    IndexAdvanceX.resize(new_size, -1.0f);
    IndexLookup.resize(new_size, (ImWchar)-1);
}

// x0/y0/x1/y1 are offset from the character upper-left layout position, in pixels. Therefore x0/y0 are often fairly close to zero.
// Not to be mistaken with texture coordinates, which are held by u0/v0/u1/v1 in normalized format (0.0..1.0 on each texture axis).
void ImFont::AddGlyph(ImWchar codepoint, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x)
{
    Glyphs.resize(Glyphs.Size + 1);
    ImFontGlyph& glyph = Glyphs.back();
    glyph.Codepoint = (ImWchar)codepoint;
    glyph.X0 = x0;
    glyph.Y0 = y0;
    glyph.X1 = x1;
    glyph.Y1 = y1;
    glyph.U0 = u0;
    glyph.V0 = v0;
    glyph.U1 = u1;
    glyph.V1 = v1;
    glyph.AdvanceX = advance_x + ConfigData->GlyphExtraSpacing.x;  // Bake spacing into AdvanceX

    if (ConfigData->PixelSnapH)
        glyph.AdvanceX = (float)(int)(glyph.AdvanceX + 0.5f);

    // Compute rough surface usage metrics (+1 to account for average padding, +0.99 to round)
    DirtyLookupTables = true;
    MetricsTotalSurface += (int)((glyph.U1 - glyph.U0) * ContainerAtlas->TexWidth + 1.99f) * (int)((glyph.V1 - glyph.V0) * ContainerAtlas->TexHeight + 1.99f);
}

void ImFont::AddRemapChar(ImWchar dst, ImWchar src, bool overwrite_dst)
{
    IM_ASSERT(IndexLookup.Size > 0);    // Currently this can only be called AFTER the font has been built, aka after calling ImFontAtlas::GetTexDataAs*() function.
    int index_size = IndexLookup.Size;

    if (dst < index_size && IndexLookup.Data[dst] == (ImWchar)-1 && !overwrite_dst) // 'dst' already exists
        return;
    if (src >= index_size && dst >= index_size) // both 'dst' and 'src' don't exist -> no-op
        return;

    GrowIndex(dst + 1);
    IndexLookup[dst] = (src < index_size) ? IndexLookup.Data[src] : (ImWchar)-1;
    IndexAdvanceX[dst] = (src < index_size) ? IndexAdvanceX.Data[src] : 1.0f;
}

const ImFontGlyph* ImFont::FindGlyph(ImWchar c) const
{
    if (c >= IndexLookup.Size)
        return FallbackGlyph;
    const ImWchar i = IndexLookup.Data[c];
    if (i == (ImWchar)-1)
        return FallbackGlyph;
    return &Glyphs.Data[i];
}

const ImFontGlyph* ImFont::FindGlyphNoFallback(ImWchar c) const
{
    if (c >= IndexLookup.Size)
        return NULL;
    const ImWchar i = IndexLookup.Data[c];
    if (i == (ImWchar)-1)
        return NULL;
    return &Glyphs.Data[i];
}

const char* ImFont::CalcWordWrapPositionA(float scale, const char* text, const char* text_end, float wrap_width) const
{
    // Simple word-wrapping for English, not full-featured. Please submit failing cases!
    // FIXME: Much possible improvements (don't cut things like "word !", "word!!!" but cut within "word,,,,", more sensible support for punctuations, support for Unicode punctuations, etc.)

    // For references, possible wrap point marked with ^
    //  "aaa bbb, ccc,ddd. eee   fff. ggg!"
    //      ^    ^    ^   ^   ^__    ^    ^

    // List of hardcoded separators: .,;!?'"

    // Skip extra blanks after a line returns (that includes not counting them in width computation)
    // e.g. "Hello    world" --> "Hello" "World"

    // Cut words that cannot possibly fit within one line.
    // e.g.: "The tropical fish" with ~5 characters worth of width --> "The tr" "opical" "fish"

    float line_width = 0.0f;
    float word_width = 0.0f;
    float blank_width = 0.0f;
    wrap_width /= scale; // We work with unscaled widths to avoid scaling every characters

    const char* word_end = text;
    const char* prev_word_end = NULL;
    bool inside_word = true;

    const char* s = text;
    while (s < text_end)
    {
        unsigned int c = (unsigned int)*s;
        const char* next_s;
        if (c < 0x80)
            next_s = s + 1;
        else
            next_s = s + ImTextCharFromUtf8(&c, s, text_end);
        if (c == 0)
            break;

        if (c < 32)
        {
            if (c == '\n')
            {
                line_width = word_width = blank_width = 0.0f;
                inside_word = true;
                s = next_s;
                continue;
            }
            if (c == '\r')
            {
                s = next_s;
                continue;
            }
        }

        const float char_width = ((int)c < IndexAdvanceX.Size ? IndexAdvanceX.Data[c] : FallbackAdvanceX);
        if (ImCharIsBlankW(c))
        {
            if (inside_word)
            {
                line_width += blank_width;
                blank_width = 0.0f;
                word_end = s;
            }
            blank_width += char_width;
            inside_word = false;
        }
        else
        {
            word_width += char_width;
            if (inside_word)
            {
                word_end = next_s;
            }
            else
            {
                prev_word_end = word_end;
                line_width += word_width + blank_width;
                word_width = blank_width = 0.0f;
            }

            // Allow wrapping after punctuation.
            inside_word = !(c == '.' || c == ',' || c == ';' || c == '!' || c == '?' || c == '\"');
        }

        // We ignore blank width at the end of the line (they can be skipped)
        if (line_width + word_width >= wrap_width)
        {
            // Words that cannot possibly fit within an entire line will be cut anywhere.
            if (word_width < wrap_width)
                s = prev_word_end ? prev_word_end : word_end;
            break;
        }

        s = next_s;
    }

    return s;
}

ImVec2 ImFont::CalcTextSizeA(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end, const char** remaining) const
{
    if (!text_end)
        text_end = text_begin + strlen(text_begin); // FIXME-OPT: Need to avoid this.

    const float line_height = size;
    const float scale = size / FontSize;

    ImVec2 text_size = ImVec2(0,0);
    float line_width = 0.0f;

    const bool word_wrap_enabled = (wrap_width > 0.0f);
    const char* word_wrap_eol = NULL;

    const char* s = text_begin;
    while (s < text_end)
    {
        if (word_wrap_enabled)
        {
            // Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.
            if (!word_wrap_eol)
            {
                word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - line_width);
                if (word_wrap_eol == s) // Wrap_width is too small to fit anything. Force displaying 1 character to minimize the height discontinuity.
                    word_wrap_eol++;    // +1 may not be a character start point in UTF-8 but it's ok because we use s >= word_wrap_eol below
            }

            if (s >= word_wrap_eol)
            {
                if (text_size.x < line_width)
                    text_size.x = line_width;
                text_size.y += line_height;
                line_width = 0.0f;
                word_wrap_eol = NULL;

                // Wrapping skips upcoming blanks
                while (s < text_end)
                {
                    const char c = *s;
                    if (ImCharIsBlankA(c)) { s++; } else if (c == '\n') { s++; break; } else { break; }
                }
                continue;
            }
        }

        // Decode and advance source
        const char* prev_s = s;
        unsigned int c = (unsigned int)*s;
        if (c < 0x80)
        {
            s += 1;
        }
        else
        {
            s += ImTextCharFromUtf8(&c, s, text_end);
            if (c == 0) // Malformed UTF-8?
                break;
        }

        if (c < 32)
        {
            if (c == '\n')
            {
                text_size.x = ImMax(text_size.x, line_width);
                text_size.y += line_height;
                line_width = 0.0f;
                continue;
            }
            if (c == '\r')
                continue;
        }

        const float char_width = ((int)c < IndexAdvanceX.Size ? IndexAdvanceX.Data[c] : FallbackAdvanceX) * scale;
        if (line_width + char_width >= max_width)
        {
            s = prev_s;
            break;
        }

        line_width += char_width;
    }

    if (text_size.x < line_width)
        text_size.x = line_width;

    if (line_width > 0 || text_size.y == 0.0f)
        text_size.y += line_height;

    if (remaining)
        *remaining = s;

    return text_size;
}

void ImFont::RenderChar(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, ImWchar c) const
{
    if (c == ' ' || c == '\t' || c == '\n' || c == '\r') // Match behavior of RenderText(), those 4 codepoints are hard-coded.
        return;
    if (const ImFontGlyph* glyph = FindGlyph(c))
    {
        float scale = (size >= 0.0f) ? (size / FontSize) : 1.0f;
        pos.x = (float)(int)pos.x + DisplayOffset.x;
        pos.y = (float)(int)pos.y + DisplayOffset.y;
        draw_list->PrimReserve(6, 4);
        draw_list->PrimRectUV(ImVec2(pos.x + glyph->X0 * scale, pos.y + glyph->Y0 * scale), ImVec2(pos.x + glyph->X1 * scale, pos.y + glyph->Y1 * scale), ImVec2(glyph->U0, glyph->V0), ImVec2(glyph->U1, glyph->V1), col);
    }
}

void ImFont::RenderText(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width, bool cpu_fine_clip) const
{
    if (!text_end)
        text_end = text_begin + strlen(text_begin); // ImGui functions generally already provides a valid text_end, so this is merely to handle direct calls.

    // Align to be pixel perfect
    pos.x = (float)(int)pos.x + DisplayOffset.x;
    pos.y = (float)(int)pos.y + DisplayOffset.y;
    float x = pos.x;
    float y = pos.y;
    if (y > clip_rect.w)
        return;

    const float scale = size / FontSize;
    const float line_height = FontSize * scale;
    const bool word_wrap_enabled = (wrap_width > 0.0f);
    const char* word_wrap_eol = NULL;

    // Fast-forward to first visible line
    const char* s = text_begin;
    if (y + line_height < clip_rect.y && !word_wrap_enabled)
        while (y + line_height < clip_rect.y && s < text_end)
        {
            s = (const char*)memchr(s, '\n', text_end - s);
            s = s ? s + 1 : text_end;
            y += line_height;
        }

    // For large text, scan for the last visible line in order to avoid over-reserving in the call to PrimReserve()
    // Note that very large horizontal line will still be affected by the issue (e.g. a one megabyte string buffer without a newline will likely crash atm)
    if (text_end - s > 10000 && !word_wrap_enabled)
    {
        const char* s_end = s;
        float y_end = y;
        while (y_end < clip_rect.w && s_end < text_end)
        {
            s_end = (const char*)memchr(s_end, '\n', text_end - s_end);
            s_end = s_end ? s_end + 1 : text_end;
            y_end += line_height;
        }
        text_end = s_end;
    }
    if (s == text_end)
        return;

    // Reserve vertices for remaining worse case (over-reserving is useful and easily amortized)
    const int vtx_count_max = (int)(text_end - s) * 4;
    const int idx_count_max = (int)(text_end - s) * 6;
    const int idx_expected_size = draw_list->IdxBuffer.Size + idx_count_max;
    draw_list->PrimReserve(idx_count_max, vtx_count_max);

    ImDrawVert* vtx_write = draw_list->_VtxWritePtr;
    ImDrawIdx* idx_write = draw_list->_IdxWritePtr;
    unsigned int vtx_current_idx = draw_list->_VtxCurrentIdx;

    while (s < text_end)
    {
        if (word_wrap_enabled)
        {
            // Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.
            if (!word_wrap_eol)
            {
                word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - (x - pos.x));
                if (word_wrap_eol == s) // Wrap_width is too small to fit anything. Force displaying 1 character to minimize the height discontinuity.
                    word_wrap_eol++;    // +1 may not be a character start point in UTF-8 but it's ok because we use s >= word_wrap_eol below
            }

            if (s >= word_wrap_eol)
            {
                x = pos.x;
                y += line_height;
                word_wrap_eol = NULL;

                // Wrapping skips upcoming blanks
                while (s < text_end)
                {
                    const char c = *s;
                    if (ImCharIsBlankA(c)) { s++; } else if (c == '\n') { s++; break; } else { break; }
                }
                continue;
            }
        }

        // Decode and advance source
        unsigned int c = (unsigned int)*s;
        if (c < 0x80)
        {
            s += 1;
        }
        else
        {
            s += ImTextCharFromUtf8(&c, s, text_end);
            if (c == 0) // Malformed UTF-8?
                break;
        }

        if (c < 32)
        {
            if (c == '\n')
            {
                x = pos.x;
                y += line_height;
                if (y > clip_rect.w)
                    break; // break out of main loop
                continue;
            }
            if (c == '\r')
                continue;
        }

        float char_width = 0.0f;
        if (const ImFontGlyph* glyph = FindGlyph((ImWchar)c))
        {
            char_width = glyph->AdvanceX * scale;

            // Arbitrarily assume that both space and tabs are empty glyphs as an optimization
            if (c != ' ' && c != '\t')
            {
                // We don't do a second finer clipping test on the Y axis as we've already skipped anything before clip_rect.y and exit once we pass clip_rect.w
                float x1 = x + glyph->X0 * scale;
                float x2 = x + glyph->X1 * scale;
                float y1 = y + glyph->Y0 * scale;
                float y2 = y + glyph->Y1 * scale;
                if (x1 <= clip_rect.z && x2 >= clip_rect.x)
                {
                    // Render a character
                    float u1 = glyph->U0;
                    float v1 = glyph->V0;
                    float u2 = glyph->U1;
                    float v2 = glyph->V1;

                    // CPU side clipping used to fit text in their frame when the frame is too small. Only does clipping for axis aligned quads.
                    if (cpu_fine_clip)
                    {
                        if (x1 < clip_rect.x)
                        {
                            u1 = u1 + (1.0f - (x2 - clip_rect.x) / (x2 - x1)) * (u2 - u1);
                            x1 = clip_rect.x;
                        }
                        if (y1 < clip_rect.y)
                        {
                            v1 = v1 + (1.0f - (y2 - clip_rect.y) / (y2 - y1)) * (v2 - v1);
                            y1 = clip_rect.y;
                        }
                        if (x2 > clip_rect.z)
                        {
                            u2 = u1 + ((clip_rect.z - x1) / (x2 - x1)) * (u2 - u1);
                            x2 = clip_rect.z;
                        }
                        if (y2 > clip_rect.w)
                        {
                            v2 = v1 + ((clip_rect.w - y1) / (y2 - y1)) * (v2 - v1);
                            y2 = clip_rect.w;
                        }
                        if (y1 >= y2)
                        {
                            x += char_width;
                            continue;
                        }
                    }

                    // We are NOT calling PrimRectUV() here because non-inlined causes too much overhead in a debug builds. Inlined here:
                    {
                        idx_write[0] = (ImDrawIdx)(vtx_current_idx); idx_write[1] = (ImDrawIdx)(vtx_current_idx+1); idx_write[2] = (ImDrawIdx)(vtx_current_idx+2);
                        idx_write[3] = (ImDrawIdx)(vtx_current_idx); idx_write[4] = (ImDrawIdx)(vtx_current_idx+2); idx_write[5] = (ImDrawIdx)(vtx_current_idx+3);
                        vtx_write[0].pos.x = x1; vtx_write[0].pos.y = y1; vtx_write[0].col = col; vtx_write[0].uv.x = u1; vtx_write[0].uv.y = v1;
                        vtx_write[1].pos.x = x2; vtx_write[1].pos.y = y1; vtx_write[1].col = col; vtx_write[1].uv.x = u2; vtx_write[1].uv.y = v1;
                        vtx_write[2].pos.x = x2; vtx_write[2].pos.y = y2; vtx_write[2].col = col; vtx_write[2].uv.x = u2; vtx_write[2].uv.y = v2;
                        vtx_write[3].pos.x = x1; vtx_write[3].pos.y = y2; vtx_write[3].col = col; vtx_write[3].uv.x = u1; vtx_write[3].uv.y = v2;
                        vtx_write += 4;
                        vtx_current_idx += 4;
                        idx_write += 6;
                    }
                }
            }
        }

        x += char_width;
    }

    // Give back unused vertices
    draw_list->VtxBuffer.resize((int)(vtx_write - draw_list->VtxBuffer.Data));
    draw_list->IdxBuffer.resize((int)(idx_write - draw_list->IdxBuffer.Data));
    draw_list->CmdBuffer[draw_list->CmdBuffer.Size-1].ElemCount -= (idx_expected_size - draw_list->IdxBuffer.Size);
    draw_list->_VtxWritePtr = vtx_write;
    draw_list->_IdxWritePtr = idx_write;
    draw_list->_VtxCurrentIdx = (unsigned int)draw_list->VtxBuffer.Size;
}

//-----------------------------------------------------------------------------
// [SECTION] Internal Render Helpers
// (progressively moved from imgui.cpp to here when they are redesigned to stop accessing ImGui global state)
//-----------------------------------------------------------------------------
// - RenderMouseCursor()
// - RenderArrowPointingAt()
// - RenderRectFilledRangeH()
// - RenderPixelEllipsis()
//-----------------------------------------------------------------------------

void ImGui::RenderMouseCursor(ImDrawList* draw_list, ImVec2 pos, float scale, ImGuiMouseCursor mouse_cursor)
{
    if (mouse_cursor == ImGuiMouseCursor_None)
        return;
    IM_ASSERT(mouse_cursor > ImGuiMouseCursor_None && mouse_cursor < ImGuiMouseCursor_COUNT);

    const ImU32 col_shadow = IM_COL32(0, 0, 0, 48);
    const ImU32 col_border = IM_COL32(0, 0, 0, 255);          // Black
    const ImU32 col_fill   = IM_COL32(255, 255, 255, 255);    // White

    ImFontAtlas* font_atlas = draw_list->_Data->Font->ContainerAtlas;
    ImVec2 offset, size, uv[4];
    if (font_atlas->GetMouseCursorTexData(mouse_cursor, &offset, &size, &uv[0], &uv[2]))
    {
        pos -= offset;
        const ImTextureID tex_id = font_atlas->TexID;
        draw_list->PushTextureID(tex_id);
        draw_list->AddImage(tex_id, pos + ImVec2(1,0)*scale, pos + ImVec2(1,0)*scale + size*scale, uv[2], uv[3], col_shadow);
        draw_list->AddImage(tex_id, pos + ImVec2(2,0)*scale, pos + ImVec2(2,0)*scale + size*scale, uv[2], uv[3], col_shadow);
        draw_list->AddImage(tex_id, pos,                     pos + size*scale,                     uv[2], uv[3], col_border);
        draw_list->AddImage(tex_id, pos,                     pos + size*scale,                     uv[0], uv[1], col_fill);
        draw_list->PopTextureID();
    }
}

// Render an arrow. 'pos' is position of the arrow tip. half_sz.x is length from base to tip. half_sz.y is length on each side.
void ImGui::RenderArrowPointingAt(ImDrawList* draw_list, ImVec2 pos, ImVec2 half_sz, ImGuiDir direction, ImU32 col)
{
    switch (direction)
    {
    case ImGuiDir_Left:  draw_list->AddTriangleFilled(ImVec2(pos.x + half_sz.x, pos.y - half_sz.y), ImVec2(pos.x + half_sz.x, pos.y + half_sz.y), pos, col); return;
    case ImGuiDir_Right: draw_list->AddTriangleFilled(ImVec2(pos.x - half_sz.x, pos.y + half_sz.y), ImVec2(pos.x - half_sz.x, pos.y - half_sz.y), pos, col); return;
    case ImGuiDir_Up:    draw_list->AddTriangleFilled(ImVec2(pos.x + half_sz.x, pos.y + half_sz.y), ImVec2(pos.x - half_sz.x, pos.y + half_sz.y), pos, col); return;
    case ImGuiDir_Down:  draw_list->AddTriangleFilled(ImVec2(pos.x - half_sz.x, pos.y - half_sz.y), ImVec2(pos.x + half_sz.x, pos.y - half_sz.y), pos, col); return;
    case ImGuiDir_None: case ImGuiDir_COUNT: break; // Fix warnings
    }
}

static inline float ImAcos01(float x)
{
    if (x <= 0.0f) return IM_PI * 0.5f;
    if (x >= 1.0f) return 0.0f;
    return ImAcos(x);
    //return (-0.69813170079773212f * x * x - 0.87266462599716477f) * x + 1.5707963267948966f; // Cheap approximation, may be enough for what we do.
}

// FIXME: Cleanup and move code to ImDrawList.
void ImGui::RenderRectFilledRangeH(ImDrawList* draw_list, const ImRect& rect, ImU32 col, float x_start_norm, float x_end_norm, float rounding)
{
    if (x_end_norm == x_start_norm)
        return;
    if (x_start_norm > x_end_norm)
        ImSwap(x_start_norm, x_end_norm);

    ImVec2 p0 = ImVec2(ImLerp(rect.Min.x, rect.Max.x, x_start_norm), rect.Min.y);
    ImVec2 p1 = ImVec2(ImLerp(rect.Min.x, rect.Max.x, x_end_norm), rect.Max.y);
    if (rounding == 0.0f)
    {
        draw_list->AddRectFilled(p0, p1, col, 0.0f);
        return;
    }

    rounding = ImClamp(ImMin((rect.Max.x - rect.Min.x) * 0.5f, (rect.Max.y - rect.Min.y) * 0.5f) - 1.0f, 0.0f, rounding);
    const float inv_rounding = 1.0f / rounding;
    const float arc0_b = ImAcos01(1.0f - (p0.x - rect.Min.x) * inv_rounding);
    const float arc0_e = ImAcos01(1.0f - (p1.x - rect.Min.x) * inv_rounding);
    const float half_pi = IM_PI * 0.5f; // We will == compare to this because we know this is the exact value ImAcos01 can return.
    const float x0 = ImMax(p0.x, rect.Min.x + rounding);
    if (arc0_b == arc0_e)
    {
        draw_list->PathLineTo(ImVec2(x0, p1.y));
        draw_list->PathLineTo(ImVec2(x0, p0.y));
    }
    else if (arc0_b == 0.0f && arc0_e == half_pi)
    {
        draw_list->PathArcToFast(ImVec2(x0, p1.y - rounding), rounding, 3, 6); // BL
        draw_list->PathArcToFast(ImVec2(x0, p0.y + rounding), rounding, 6, 9); // TR
    }
    else
    {
        draw_list->PathArcTo(ImVec2(x0, p1.y - rounding), rounding, IM_PI - arc0_e, IM_PI - arc0_b, 3); // BL
        draw_list->PathArcTo(ImVec2(x0, p0.y + rounding), rounding, IM_PI + arc0_b, IM_PI + arc0_e, 3); // TR
    }
    if (p1.x > rect.Min.x + rounding)
    {
        const float arc1_b = ImAcos01(1.0f - (rect.Max.x - p1.x) * inv_rounding);
        const float arc1_e = ImAcos01(1.0f - (rect.Max.x - p0.x) * inv_rounding);
        const float x1 = ImMin(p1.x, rect.Max.x - rounding);
        if (arc1_b == arc1_e)
        {
            draw_list->PathLineTo(ImVec2(x1, p0.y));
            draw_list->PathLineTo(ImVec2(x1, p1.y));
        }
        else if (arc1_b == 0.0f && arc1_e == half_pi)
        {
            draw_list->PathArcToFast(ImVec2(x1, p0.y + rounding), rounding, 9, 12); // TR
            draw_list->PathArcToFast(ImVec2(x1, p1.y - rounding), rounding, 0, 3);  // BR
        }
        else
        {
            draw_list->PathArcTo(ImVec2(x1, p0.y + rounding), rounding, -arc1_e, -arc1_b, 3); // TR
            draw_list->PathArcTo(ImVec2(x1, p1.y - rounding), rounding, +arc1_b, +arc1_e, 3); // BR
        }
    }
    draw_list->PathFillConvex(col);
}

// FIXME: Rendering an ellipsis "..." is a surprisingly tricky problem for us... we cannot rely on font glyph having it,
// and regular dot are typically too wide. If we render a dot/shape ourselves it comes with the risk that it wouldn't match
// the boldness or positioning of what the font uses...
void ImGui::RenderPixelEllipsis(ImDrawList* draw_list, ImVec2 pos, int count, ImU32 col)
{
    ImFont* font = draw_list->_Data->Font;
    const float font_scale = draw_list->_Data->FontSize / font->FontSize;
    pos.y += (float)(int)(font->DisplayOffset.y + font->Ascent * font_scale + 0.5f - 1.0f);
    for (int dot_n = 0; dot_n < count; dot_n++)
        draw_list->AddRectFilled(ImVec2(pos.x + dot_n * 2.0f, pos.y), ImVec2(pos.x + dot_n * 2.0f + 1.0f, pos.y + 1.0f), col);
}

//-----------------------------------------------------------------------------
// [SECTION] Decompression code
//-----------------------------------------------------------------------------
// Compressed with stb_compress() then converted to a C array and encoded as base85.
// Use the program in misc/fonts/binary_to_compressed_c.cpp to create the array from a TTF file.
// The purpose of encoding as base85 instead of "0x00,0x01,..." style is only save on _source code_ size.
// Decompression from stb.h (public domain) by Sean Barrett https://github.com/nothings/stb/blob/master/stb.h
//-----------------------------------------------------------------------------

static unsigned int stb_decompress_length(const unsigned char *input)
{
    return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];
}

static unsigned char *stb__barrier_out_e, *stb__barrier_out_b;
static const unsigned char *stb__barrier_in_b;
static unsigned char *stb__dout;
static void stb__match(const unsigned char *data, unsigned int length)
{
    // INVERSE of memmove... write each byte before copying the next...
    IM_ASSERT(stb__dout + length <= stb__barrier_out_e);
    if (stb__dout + length > stb__barrier_out_e) { stb__dout += length; return; }
    if (data < stb__barrier_out_b) { stb__dout = stb__barrier_out_e+1; return; }
    while (length--) *stb__dout++ = *data++;
}

static void stb__lit(const unsigned char *data, unsigned int length)
{
    IM_ASSERT(stb__dout + length <= stb__barrier_out_e);
    if (stb__dout + length > stb__barrier_out_e) { stb__dout += length; return; }
    if (data < stb__barrier_in_b) { stb__dout = stb__barrier_out_e+1; return; }
    memcpy(stb__dout, data, length);
    stb__dout += length;
}

#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
#define stb__in3(x)   ((i[x] << 16) + stb__in2((x)+1))
#define stb__in4(x)   ((i[x] << 24) + stb__in3((x)+1))

static const unsigned char *stb_decompress_token(const unsigned char *i)
{
    if (*i >= 0x20) { // use fewer if's for cases that expand small
        if (*i >= 0x80)       stb__match(stb__dout-i[1]-1, i[0] - 0x80 + 1), i += 2;
        else if (*i >= 0x40)  stb__match(stb__dout-(stb__in2(0) - 0x4000 + 1), i[2]+1), i += 3;
        else /* *i >= 0x20 */ stb__lit(i+1, i[0] - 0x20 + 1), i += 1 + (i[0] - 0x20 + 1);
    } else { // more ifs for cases that expand large, since overhead is amortized
        if (*i >= 0x18)       stb__match(stb__dout-(stb__in3(0) - 0x180000 + 1), i[3]+1), i += 4;
        else if (*i >= 0x10)  stb__match(stb__dout-(stb__in3(0) - 0x100000 + 1), stb__in2(3)+1), i += 5;
        else if (*i >= 0x08)  stb__lit(i+2, stb__in2(0) - 0x0800 + 1), i += 2 + (stb__in2(0) - 0x0800 + 1);
        else if (*i == 0x07)  stb__lit(i+3, stb__in2(1) + 1), i += 3 + (stb__in2(1) + 1);
        else if (*i == 0x06)  stb__match(stb__dout-(stb__in3(1)+1), i[4]+1), i += 5;
        else if (*i == 0x04)  stb__match(stb__dout-(stb__in3(1)+1), stb__in2(4)+1), i += 6;
    }
    return i;
}

static unsigned int stb_adler32(unsigned int adler32, unsigned char *buffer, unsigned int buflen)
{
    const unsigned long ADLER_MOD = 65521;
    unsigned long s1 = adler32 & 0xffff, s2 = adler32 >> 16;
    unsigned long blocklen, i;

    blocklen = buflen % 5552;
    while (buflen) {
        for (i=0; i + 7 < blocklen; i += 8) {
            s1 += buffer[0], s2 += s1;
            s1 += buffer[1], s2 += s1;
            s1 += buffer[2], s2 += s1;
            s1 += buffer[3], s2 += s1;
            s1 += buffer[4], s2 += s1;
            s1 += buffer[5], s2 += s1;
            s1 += buffer[6], s2 += s1;
            s1 += buffer[7], s2 += s1;

            buffer += 8;
        }

        for (; i < blocklen; ++i)
            s1 += *buffer++, s2 += s1;

        s1 %= ADLER_MOD, s2 %= ADLER_MOD;
        buflen -= blocklen;
        blocklen = 5552;
    }
    return (unsigned int)(s2 << 16) + (unsigned int)s1;
}

static unsigned int stb_decompress(unsigned char *output, const unsigned char *i, unsigned int /*length*/)
{
    unsigned int olen;
    if (stb__in4(0) != 0x57bC0000) return 0;
    if (stb__in4(4) != 0)          return 0; // error! stream is > 4GB
    olen = stb_decompress_length(i);
    stb__barrier_in_b = i;
    stb__barrier_out_e = output + olen;
    stb__barrier_out_b = output;
    i += 16;

    stb__dout = output;
    for (;;) {
        const unsigned char *old_i = i;
        i = stb_decompress_token(i);
        if (i == old_i) {
            if (*i == 0x05 && i[1] == 0xfa) {
                IM_ASSERT(stb__dout == output + olen);
                if (stb__dout != output + olen) return 0;
                if (stb_adler32(1, output, olen) != (unsigned int) stb__in4(2))
                    return 0;
                return olen;
            } else {
                IM_ASSERT(0); /* NOTREACHED */
                return 0;
            }
        }
        IM_ASSERT(stb__dout <= output + olen);
        if (stb__dout > output + olen)
            return 0;
    }
}

//-----------------------------------------------------------------------------
// [SECTION] Default font data (ProggyClean.ttf)
//-----------------------------------------------------------------------------
// ProggyClean.ttf
// Copyright (c) 2004, 2005 Tristan Grimmer
// MIT license (see License.txt in http://www.upperbounds.net/download/ProggyClean.ttf.zip)
// Download and more information at http://upperbounds.net
//-----------------------------------------------------------------------------
// File: 'ProggyClean.ttf' (41208 bytes)
// Exported using misc/fonts/binary_to_compressed_c.cpp (with compression + base85 string encoding).
// The purpose of encoding as base85 instead of "0x00,0x01,..." style is only save on _source code_ size.
//-----------------------------------------------------------------------------
static const char proggy_clean_ttf_compressed_data_base85[11980+1] =
    "7])#######hV0qs'/###[),##/l:$#Q6>##5[n42>c-TH`->>#/e>11NNV=Bv(*:.F?uu#(gRU.o0XGH`$vhLG1hxt9?W`#,5LsCp#-i>.r$<$6pD>Lb';9Crc6tgXmKVeU2cD4Eo3R/"
    "2*>]b(MC;$jPfY.;h^`IWM9<Lh2TlS+f-s$o6Q<BWH`YiU.xfLq$N;$0iR/GX:U(jcW2p/W*q?-qmnUCI;jHSAiFWM.R*kU@C=GH?a9wp8f$e.-4^Qg1)Q-GL(lf(r/7GrRgwV%MS=C#"
    "`8ND>Qo#t'X#(v#Y9w0#1D$CIf;W'#pWUPXOuxXuU(H9M(1<q-UE31#^-V'8IRUo7Qf./L>=Ke$$'5F%)]0^#0X@U.a<r:QLtFsLcL6##lOj)#.Y5<-R&KgLwqJfLgN&;Q?gI^#DY2uL"
    "i@^rMl9t=cWq6##weg>$FBjVQTSDgEKnIS7EM9>ZY9w0#L;>>#Mx&4Mvt//L[MkA#W@lK.N'[0#7RL_&#w+F%HtG9M#XL`N&.,GM4Pg;-<nLENhvx>-VsM.M0rJfLH2eTM`*oJMHRC`N"
    "kfimM2J,W-jXS:)r0wK#@Fge$U>`w'N7G#$#fB#$E^$#:9:hk+eOe--6x)F7*E%?76%^GMHePW-Z5l'&GiF#$956:rS?dA#fiK:)Yr+`&#0j@'DbG&#^$PG.Ll+DNa<XCMKEV*N)LN/N"
    "*b=%Q6pia-Xg8I$<MR&,VdJe$<(7G;Ckl'&hF;;$<_=X(b.RS%%)###MPBuuE1V:v&cX&#2m#(&cV]`k9OhLMbn%s$G2,B$BfD3X*sp5#l,$R#]x_X1xKX%b5U*[r5iMfUo9U`N99hG)"
    "tm+/Us9pG)XPu`<0s-)WTt(gCRxIg(%6sfh=ktMKn3j)<6<b5Sk_/0(^]AaN#(p/L>&VZ>1i%h1S9u5o@YaaW$e+b<TWFn/Z:Oh(Cx2$lNEoN^e)#CFY@@I;BOQ*sRwZtZxRcU7uW6CX"
    "ow0i(?$Q[cjOd[P4d)]>ROPOpxTO7Stwi1::iB1q)C_=dV26J;2,]7op$]uQr@_V7$q^%lQwtuHY]=DX,n3L#0PHDO4f9>dC@O>HBuKPpP*E,N+b3L#lpR/MrTEH.IAQk.a>D[.e;mc."
    "x]Ip.PH^'/aqUO/$1WxLoW0[iLA<QT;5HKD+@qQ'NQ(3_PLhE48R.qAPSwQ0/WK?Z,[x?-J;jQTWA0X@KJ(_Y8N-:/M74:/-ZpKrUss?d#dZq]DAbkU*JqkL+nwX@@47`5>w=4h(9.`G"
    "CRUxHPeR`5Mjol(dUWxZa(>STrPkrJiWx`5U7F#.g*jrohGg`cg:lSTvEY/EV_7H4Q9[Z%cnv;JQYZ5q.l7Zeas:HOIZOB?G<Nald$qs]@]L<J7bR*>gv:[7MI2k).'2($5FNP&EQ(,)"
    "U]W]+fh18.vsai00);D3@4ku5P?DP8aJt+;qUM]=+b'8@;mViBKx0DE[-auGl8:PJ&Dj+M6OC]O^((##]`0i)drT;-7X`=-H3[igUnPG-NZlo.#k@h#=Ork$m>a>$-?Tm$UV(?#P6YY#"
    "'/###xe7q.73rI3*pP/$1>s9)W,JrM7SN]'/4C#v$U`0#V.[0>xQsH$fEmPMgY2u7Kh(G%siIfLSoS+MK2eTM$=5,M8p`A.;_R%#u[K#$x4AG8.kK/HSB==-'Ie/QTtG?-.*^N-4B/ZM"
    "_3YlQC7(p7q)&](`6_c)$/*JL(L-^(]$wIM`dPtOdGA,U3:w2M-0<q-]L_?^)1vw'.,MRsqVr.L;aN&#/EgJ)PBc[-f>+WomX2u7lqM2iEumMTcsF?-aT=Z-97UEnXglEn1K-bnEO`gu"
    "Ft(c%=;Am_Qs@jLooI&NX;]0#j4#F14;gl8-GQpgwhrq8'=l_f-b49'UOqkLu7-##oDY2L(te+Mch&gLYtJ,MEtJfLh'x'M=$CS-ZZ%P]8bZ>#S?YY#%Q&q'3^Fw&?D)UDNrocM3A76/"
    "/oL?#h7gl85[qW/NDOk%16ij;+:1a'iNIdb-ou8.P*w,v5#EI$TWS>Pot-R*H'-SEpA:g)f+O$%%`kA#G=8RMmG1&O`>to8bC]T&$,n.LoO>29sp3dt-52U%VM#q7'DHpg+#Z9%H[K<L"
    "%a2E-grWVM3@2=-k22tL]4$##6We'8UJCKE[d_=%wI;'6X-GsLX4j^SgJ$##R*w,vP3wK#iiW&#*h^D&R?jp7+/u&#(AP##XU8c$fSYW-J95_-Dp[g9wcO&#M-h1OcJlc-*vpw0xUX&#"
    "OQFKNX@QI'IoPp7nb,QU//MQ&ZDkKP)X<WSVL(68uVl&#c'[0#(s1X&xm$Y%B7*K:eDA323j998GXbA#pwMs-jgD$9QISB-A_(aN4xoFM^@C58D0+Q+q3n0#3U1InDjF682-SjMXJK)("
    "h$hxua_K]ul92%'BOU&#BRRh-slg8KDlr:%L71Ka:.A;%YULjDPmL<LYs8i#XwJOYaKPKc1h:'9Ke,g)b),78=I39B;xiY$bgGw-&.Zi9InXDuYa%G*f2Bq7mn9^#p1vv%#(Wi-;/Z5h"
    "o;#2:;%d&#x9v68C5g?ntX0X)pT`;%pB3q7mgGN)3%(P8nTd5L7GeA-GL@+%J3u2:(Yf>et`e;)f#Km8&+DC$I46>#Kr]]u-[=99tts1.qb#q72g1WJO81q+eN'03'eM>&1XxY-caEnO"
    "j%2n8)),?ILR5^.Ibn<-X-Mq7[a82Lq:F&#ce+S9wsCK*x`569E8ew'He]h:sI[2LM$[guka3ZRd6:t%IG:;$%YiJ:Nq=?eAw;/:nnDq0(CYcMpG)qLN4$##&J<j$UpK<Q4a1]MupW^-"
    "sj_$%[HK%'F####QRZJ::Y3EGl4'@%FkiAOg#p[##O`gukTfBHagL<LHw%q&OV0##F=6/:chIm0@eCP8X]:kFI%hl8hgO@RcBhS-@Qb$%+m=hPDLg*%K8ln(wcf3/'DW-$.lR?n[nCH-"
    "eXOONTJlh:.RYF%3'p6sq:UIMA945&^HFS87@$EP2iG<-lCO$%c`uKGD3rC$x0BL8aFn--`ke%#HMP'vh1/R&O_J9'um,.<tx[@%wsJk&bUT2`0uMv7gg#qp/ij.L56'hl;.s5CUrxjO"
    "M7-##.l+Au'A&O:-T72L]P`&=;ctp'XScX*rU.>-XTt,%OVU4)S1+R-#dg0/Nn?Ku1^0f$B*P:Rowwm-`0PKjYDDM'3]d39VZHEl4,.j']Pk-M.h^&:0FACm$maq-&sgw0t7/6(^xtk%"
    "LuH88Fj-ekm>GA#_>568x6(OFRl-IZp`&b,_P'$M<Jnq79VsJW/mWS*PUiq76;]/NM_>hLbxfc$mj`,O;&%W2m`Zh:/)Uetw:aJ%]K9h:TcF]u_-Sj9,VK3M.*'&0D[Ca]J9gp8,kAW]"
    "%(?A%R$f<->Zts'^kn=-^@c4%-pY6qI%J%1IGxfLU9CP8cbPlXv);C=b),<2mOvP8up,UVf3839acAWAW-W?#ao/^#%KYo8fRULNd2.>%m]UK:n%r$'sw]J;5pAoO_#2mO3n,'=H5(et"
    "Hg*`+RLgv>=4U8guD$I%D:W>-r5V*%j*W:Kvej.Lp$<M-SGZ':+Q_k+uvOSLiEo(<aD/K<CCc`'Lx>'?;++O'>()jLR-^u68PHm8ZFWe+ej8h:9r6L*0//c&iH&R8pRbA#Kjm%upV1g:"
    "a_#Ur7FuA#(tRh#.Y5K+@?3<-8m0$PEn;J:rh6?I6uG<-`wMU'ircp0LaE_OtlMb&1#6T.#FDKu#1Lw%u%+GM+X'e?YLfjM[VO0MbuFp7;>Q&#WIo)0@F%q7c#4XAXN-U&VB<HFF*qL("
    "$/V,;(kXZejWO`<[5?\?ewY(*9=%wDc;,u<'9t3W-(H1th3+G]ucQ]kLs7df($/*JL]@*t7Bu_G3_7mp7<iaQjO@.kLg;x3B0lqp7Hf,^Ze7-##@/c58Mo(3;knp0%)A7?-W+eI'o8)b<"
    "nKnw'Ho8C=Y>pqB>0ie&jhZ[?iLR@@_AvA-iQC(=ksRZRVp7`.=+NpBC%rh&3]R:8XDmE5^V8O(x<<aG/1N$#FX$0V5Y6x'aErI3I$7x%E`v<-BY,)%-?Psf*l?%C3.mM(=/M0:JxG'?"
    "7WhH%o'a<-80g0NBxoO(GH<dM]n.+%q@jH?f.UsJ2Ggs&4<-e47&Kl+f//9@`b+?.TeN_&B8Ss?v;^Trk;f#YvJkl&w$]>-+k?'(<S:68tq*WoDfZu';mM?8X[ma8W%*`-=;D.(nc7/;"
    ")g:T1=^J$&BRV(-lTmNB6xqB[@0*o.erM*<SWF]u2=st-*(6v>^](H.aREZSi,#1:[IXaZFOm<-ui#qUq2$##Ri;u75OK#(RtaW-K-F`S+cF]uN`-KMQ%rP/Xri.LRcB##=YL3BgM/3M"
    "D?@f&1'BW-)Ju<L25gl8uhVm1hL$##*8###'A3/LkKW+(^rWX?5W_8g)a(m&K8P>#bmmWCMkk&#TR`C,5d>g)F;t,4:@_l8G/5h4vUd%&%950:VXD'QdWoY-F$BtUwmfe$YqL'8(PWX("
    "P?^@Po3$##`MSs?DWBZ/S>+4%>fX,VWv/w'KD`LP5IbH;rTV>n3cEK8U#bX]l-/V+^lj3;vlMb&[5YQ8#pekX9JP3XUC72L,,?+Ni&co7ApnO*5NK,((W-i:$,kp'UDAO(G0Sq7MVjJs"
    "bIu)'Z,*[>br5fX^:FPAWr-m2KgL<LUN098kTF&#lvo58=/vjDo;.;)Ka*hLR#/k=rKbxuV`>Q_nN6'8uTG&#1T5g)uLv:873UpTLgH+#FgpH'_o1780Ph8KmxQJ8#H72L4@768@Tm&Q"
    "h4CB/5OvmA&,Q&QbUoi$a_%3M01H)4x7I^&KQVgtFnV+;[Pc>[m4k//,]1?#`VY[Jr*3&&slRfLiVZJ:]?=K3Sw=[$=uRB?3xk48@aeg<Z'<$#4H)6,>e0jT6'N#(q%.O=?2S]u*(m<-"
    "V8J'(1)G][68hW$5'q[GC&5j`TE?m'esFGNRM)j,ffZ?-qx8;->g4t*:CIP/[Qap7/9'#(1sao7w-.qNUdkJ)tCF&#B^;xGvn2r9FEPFFFcL@.iFNkTve$m%#QvQS8U@)2Z+3K:AKM5i"
    "sZ88+dKQ)W6>J%CL<KE>`.d*(B`-n8D9oK<Up]c$X$(,)M8Zt7/[rdkqTgl-0cuGMv'?>-XV1q['-5k'cAZ69e;D_?$ZPP&s^+7])$*$#@QYi9,5P&#9r+$%CE=68>K8r0=dSC%%(@p7"
    ".m7jilQ02'0-VWAg<a/''3u.=4L$Y)6k/K:_[3=&jvL<L0C/2'v:^;-DIBW,B4E68:kZ;%?8(Q8BH=kO65BW?xSG&#@uU,DS*,?.+(o(#1vCS8#CHF>TlGW'b)Tq7VT9q^*^$$.:&N@@"
    "$&)WHtPm*5_rO0&e%K&#-30j(E4#'Zb.o/(Tpm$>K'f@[PvFl,hfINTNU6u'0pao7%XUp9]5.>%h`8_=VYbxuel.NTSsJfLacFu3B'lQSu/m6-Oqem8T+oE--$0a/k]uj9EwsG>%veR*"
    "hv^BFpQj:K'#SJ,sB-'#](j.Lg92rTw-*n%@/;39rrJF,l#qV%OrtBeC6/,;qB3ebNW[?,Hqj2L.1NP&GjUR=1D8QaS3Up&@*9wP?+lo7b?@%'k4`p0Z$22%K3+iCZj?XJN4Nm&+YF]u"
    "@-W$U%VEQ/,,>>#)D<h#`)h0:<Q6909ua+&VU%n2:cG3FJ-%@Bj-DgLr`Hw&HAKjKjseK</xKT*)B,N9X3]krc12t'pgTV(Lv-tL[xg_%=M_q7a^x?7Ubd>#%8cY#YZ?=,`Wdxu/ae&#"
    "w6)R89tI#6@s'(6Bf7a&?S=^ZI_kS&ai`&=tE72L_D,;^R)7[$s<Eh#c&)q.MXI%#v9ROa5FZO%sF7q7Nwb&#ptUJ:aqJe$Sl68%.D###EC><?-aF&#RNQv>o8lKN%5/$(vdfq7+ebA#"
    "u1p]ovUKW&Y%q]'>$1@-[xfn$7ZTp7mM,G,Ko7a&Gu%G[RMxJs[0MM%wci.LFDK)(<c`Q8N)jEIF*+?P2a8g%)$q]o2aH8C&<SibC/q,(e:v;-b#6[$NtDZ84Je2KNvB#$P5?tQ3nt(0"
    "d=j.LQf./Ll33+(;q3L-w=8dX$#WF&uIJ@-bfI>%:_i2B5CsR8&9Z&#=mPEnm0f`<&c)QL5uJ#%u%lJj+D-r;BoF&#4DoS97h5g)E#o:&S4weDF,9^Hoe`h*L+_a*NrLW-1pG_&2UdB8"
    "6e%B/:=>)N4xeW.*wft-;$'58-ESqr<b?UI(_%@[P46>#U`'6AQ]m&6/`Z>#S?YY#Vc;r7U2&326d=w&H####?TZ`*4?&.MK?LP8Vxg>$[QXc%QJv92.(Db*B)gb*BM9dM*hJMAo*c&#"
    "b0v=Pjer]$gG&JXDf->'StvU7505l9$AFvgYRI^&<^b68?j#q9QX4SM'RO#&sL1IM.rJfLUAj221]d##DW=m83u5;'bYx,*Sl0hL(W;;$doB&O/TQ:(Z^xBdLjL<Lni;''X.`$#8+1GD"
    ":k$YUWsbn8ogh6rxZ2Z9]%nd+>V#*8U_72Lh+2Q8Cj0i:6hp&$C/:p(HK>T8Y[gHQ4`4)'$Ab(Nof%V'8hL&#<NEdtg(n'=S1A(Q1/I&4([%dM`,Iu'1:_hL>SfD07&6D<fp8dHM7/g+"
    "tlPN9J*rKaPct&?'uBCem^jn%9_K)<,C5K3s=5g&GmJb*[SYq7K;TRLGCsM-$$;S%:Y@r7AK0pprpL<Lrh,q7e/%KWK:50I^+m'vi`3?%Zp+<-d+$L-Sv:@.o19n$s0&39;kn;S%BSq*"
    "$3WoJSCLweV[aZ'MQIjO<7;X-X;&+dMLvu#^UsGEC9WEc[X(wI7#2.(F0jV*eZf<-Qv3J-c+J5AlrB#$p(H68LvEA'q3n0#m,[`*8Ft)FcYgEud]CWfm68,(aLA$@EFTgLXoBq/UPlp7"
    ":d[/;r_ix=:TF`S5H-b<LI&HY(K=h#)]Lk$K14lVfm:x$H<3^Ql<M`$OhapBnkup'D#L$Pb_`N*g]2e;X/Dtg,bsj&K#2[-:iYr'_wgH)NUIR8a1n#S?Yej'h8^58UbZd+^FKD*T@;6A"
    "7aQC[K8d-(v6GI$x:T<&'Gp5Uf>@M.*J:;$-rv29'M]8qMv-tLp,'886iaC=Hb*YJoKJ,(j%K=H`K.v9HggqBIiZu'QvBT.#=)0ukruV&.)3=(^1`o*Pj4<-<aN((^7('#Z0wK#5GX@7"
    "u][`*S^43933A4rl][`*O4CgLEl]v$1Q3AeF37dbXk,.)vj#x'd`;qgbQR%FW,2(?LO=s%Sc68%NP'##Aotl8x=BE#j1UD([3$M(]UI2LX3RpKN@;/#f'f/&_mt&F)XdF<9t4)Qa.*kT"
    "LwQ'(TTB9.xH'>#MJ+gLq9-##@HuZPN0]u:h7.T..G:;$/Usj(T7`Q8tT72LnYl<-qx8;-HV7Q-&Xdx%1a,hC=0u+HlsV>nuIQL-5<N?)NBS)QN*_I,?&)2'IM%L3I)X((e/dl2&8'<M"
    ":^#M*Q+[T.Xri.LYS3v%fF`68h;b-X[/En'CR.q7E)p'/kle2HM,u;^%OKC-N+Ll%F9CF<Nf'^#t2L,;27W:0O@6##U6W7:$rJfLWHj$#)woqBefIZ.PK<b*t7ed;p*_m;4ExK#h@&]>"
    "_>@kXQtMacfD.m-VAb8;IReM3$wf0''hra*so568'Ip&vRs849'MRYSp%:t:h5qSgwpEr$B>Q,;s(C#$)`svQuF$##-D,##,g68@2[T;.XSdN9Qe)rpt._K-#5wF)sP'##p#C0c%-Gb%"
    "hd+<-j'Ai*x&&HMkT]C'OSl##5RG[JXaHN;d'uA#x._U;.`PU@(Z3dt4r152@:v,'R.Sj'w#0<-;kPI)FfJ&#AYJ&#//)>-k=m=*XnK$>=)72L]0I%>.G690a:$##<,);?;72#?x9+d;"
    "^V'9;jY@;)br#q^YQpx:X#Te$Z^'=-=bGhLf:D6&bNwZ9-ZD#n^9HhLMr5G;']d&6'wYmTFmL<LD)F^%[tC'8;+9E#C$g%#5Y>q9wI>P(9mI[>kC-ekLC/R&CH+s'B;K-M6$EB%is00:"
    "+A4[7xks.LrNk0&E)wILYF@2L'0Nb$+pv<(2.768/FrY&h$^3i&@+G%JT'<-,v`3;_)I9M^AE]CN?Cl2AZg+%4iTpT3<n-&%H%b<FDj2M<hH=&Eh<2Len$b*aTX=-8QxN)k11IM1c^j%"
    "9s<L<NFSo)B?+<-(GxsF,^-Eh@$4dXhN$+#rxK8'je'D7k`e;)2pYwPA'_p9&@^18ml1^[@g4t*[JOa*[=Qp7(qJ_oOL^('7fB&Hq-:sf,sNj8xq^>$U4O]GKx'm9)b@p7YsvK3w^YR-"
    "CdQ*:Ir<($u&)#(&?L9Rg3H)4fiEp^iI9O8KnTj,]H?D*r7'M;PwZ9K0E^k&-cpI;.p/6_vwoFMV<->#%Xi.LxVnrU(4&8/P+:hLSKj$#U%]49t'I:rgMi'FL@a:0Y-uA[39',(vbma*"
    "hU%<-SRF`Tt:542R_VV$p@[p8DV[A,?1839FWdF<TddF<9Ah-6&9tWoDlh]&1SpGMq>Ti1O*H&#(AL8[_P%.M>v^-))qOT*F5Cq0`Ye%+$B6i:7@0IX<N+T+0MlMBPQ*Vj>SsD<U4JHY"
    "8kD2)2fU/M#$e.)T4,_=8hLim[&);?UkK'-x?'(:siIfL<$pFM`i<?%W(mGDHM%>iWP,##P`%/L<eXi:@Z9C.7o=@(pXdAO/NLQ8lPl+HPOQa8wD8=^GlPa8TKI1CjhsCTSLJM'/Wl>-"
    "S(qw%sf/@%#B6;/U7K]uZbi^Oc^2n<bhPmUkMw>%t<)'mEVE''n`WnJra$^TKvX5B>;_aSEK',(hwa0:i4G?.Bci.(X[?b*($,=-n<.Q%`(X=?+@Am*Js0&=3bh8K]mL<LoNs'6,'85`"
    "0?t/'_U59@]ddF<#LdF<eWdF<OuN/45rY<-L@&#+fm>69=Lb,OcZV/);TTm8VI;?%OtJ<(b4mq7M6:u?KRdF<gR@2L=FNU-<b[(9c/ML3m;Z[$oF3g)GAWqpARc=<ROu7cL5l;-[A]%/"
    "+fsd;l#SafT/f*W]0=O'$(Tb<[)*@e775R-:Yob%g*>l*:xP?Yb.5)%w_I?7uk5JC+FS(m#i'k.'a0i)9<7b'fs'59hq$*5Uhv##pi^8+hIEBF`nvo`;'l0.^S1<-wUK2/Coh58KKhLj"
    "M=SO*rfO`+qC`W-On.=AJ56>>i2@2LH6A:&5q`?9I3@@'04&p2/LVa*T-4<-i3;M9UvZd+N7>b*eIwg:CC)c<>nO&#<IGe;__.thjZl<%w(Wk2xmp4Q@I#I9,DF]u7-P=.-_:YJ]aS@V"
    "?6*C()dOp7:WL,b&3Rg/.cmM9&r^>$(>.Z-I&J(Q0Hd5Q%7Co-b`-c<N(6r@ip+AurK<m86QIth*#v;-OBqi+L7wDE-Ir8K['m+DDSLwK&/.?-V%U_%3:qKNu$_b*B-kp7NaD'QdWQPK"
    "Yq[@>P)hI;*_F]u`Rb[.j8_Q/<&>uu+VsH$sM9TA%?)(vmJ80),P7E>)tjD%2L=-t#fK[%`v=Q8<FfNkgg^oIbah*#8/Qt$F&:K*-(N/'+1vMB,u()-a.VUU*#[e%gAAO(S>WlA2);Sa"
    ">gXm8YB`1d@K#n]76-a$U,mF<fX]idqd)<3,]J7JmW4`6]uks=4-72L(jEk+:bJ0M^q-8Dm_Z?0olP1C9Sa&H[d&c$ooQUj]Exd*3ZM@-WGW2%s',B-_M%>%Ul:#/'xoFM9QX-$.QN'>"
    "[%$Z$uF6pA6Ki2O5:8w*vP1<-1`[G,)-m#>0`P&#eb#.3i)rtB61(o'$?X3B</R90;eZ]%Ncq;-Tl]#F>2Qft^ae_5tKL9MUe9b*sLEQ95C&`=G?@Mj=wh*'3E>=-<)Gt*Iw)'QG:`@I"
    "wOf7&]1i'S01B+Ev/Nac#9S;=;YQpg_6U`*kVY39xK,[/6Aj7:'1Bm-_1EYfa1+o&o4hp7KN_Q(OlIo@S%;jVdn0'1<Vc52=u`3^o-n1'g4v58Hj&6_t7$##?M)c<$bgQ_'SY((-xkA#"
    "Y(,p'H9rIVY-b,'%bCPF7.J<Up^,(dU1VY*5#WkTU>h19w,WQhLI)3S#f$2(eb,jr*b;3Vw]*7NH%$c4Vs,eD9>XW8?N]o+(*pgC%/72LV-u<Hp,3@e^9UB1J+ak9-TN/mhKPg+AJYd$"
    "MlvAF_jCK*.O-^(63adMT->W%iewS8W6m2rtCpo'RS1R84=@paTKt)>=%&1[)*vp'u+x,VrwN;&]kuO9JDbg=pO$J*.jVe;u'm0dr9l,<*wMK*Oe=g8lV_KEBFkO'oU]^=[-792#ok,)"
    "i]lR8qQ2oA8wcRCZ^7w/Njh;?.stX?Q1>S1q4Bn$)K1<-rGdO'$Wr.Lc.CG)$/*JL4tNR/,SVO3,aUw'DJN:)Ss;wGn9A32ijw%FL+Z0Fn.U9;reSq)bmI32U==5ALuG&#Vf1398/pVo"
    "1*c-(aY168o<`JsSbk-,1N;$>0:OUas(3:8Z972LSfF8eb=c-;>SPw7.6hn3m`9^Xkn(r.qS[0;T%&Qc=+STRxX'q1BNk3&*eu2;&8q$&x>Q#Q7^Tf+6<(d%ZVmj2bDi%.3L2n+4W'$P"
    "iDDG)g,r%+?,$@?uou5tSe2aN_AQU*<h`e-GI7)?OK2A.d7_c)?wQ5AS@DL3r#7fSkgl6-++D:'A,uq7SvlB$pcpH'q3n0#_%dY#xCpr-l<F0NR@-##FEV6NTF6##$l84N1w?AO>'IAO"
    "URQ##V^Fv-XFbGM7Fl(N<3DhLGF%q.1rC$#:T__&Pi68%0xi_&[qFJ(77j_&JWoF.V735&T,[R*:xFR*K5>>#`bW-?4Ne_&6Ne_&6Ne_&n`kr-#GJcM6X;uM6X;uM(.a..^2TkL%oR(#"
    ";u.T%fAr%4tJ8&><1=GHZ_+m9/#H1F^R#SC#*N=BA9(D?v[UiFY>>^8p,KKF.W]L29uLkLlu/+4T<XoIB&hx=T1PcDaB&;HH+-AFr?(m9HZV)FKS8JCw;SD=6[^/DZUL`EUDf]GGlG&>"
    "w$)F./^n3+rlo+DB;5sIYGNk+i1t-69Jg--0pao7Sm#K)pdHW&;LuDNH@H>#/X-TI(;P>#,Gc>#0Su>#4`1?#8lC?#<xU?#@.i?#D:%@#HF7@#LRI@#P_[@#Tkn@#Xw*A#]-=A#a9OA#"
    "d<F&#*;G##.GY##2Sl##6`($#:l:$#>xL$#B.`$#F:r$#JF.%#NR@%#R_R%#Vke%#Zww%#_-4&#3^Rh%Sflr-k'MS.o?.5/sWel/wpEM0%3'/1)K^f1-d>G21&v(35>V`39V7A4=onx4"
    "A1OY5EI0;6Ibgr6M$HS7Q<)58C5w,;WoA*#[%T*#`1g*#d=#+#hI5+#lUG+#pbY+#tnl+#x$),#&1;,#*=M,#.I`,#2Ur,#6b.-#;w[H#iQtA#m^0B#qjBB#uvTB##-hB#'9$C#+E6C#"
    "/QHC#3^ZC#7jmC#;v)D#?,<D#C8ND#GDaD#KPsD#O]/E#g1A5#KA*1#gC17#MGd;#8(02#L-d3#rWM4#Hga1#,<w0#T.j<#O#'2#CYN1#qa^:#_4m3#o@/=#eG8=#t8J5#`+78#4uI-#"
    "m3B2#SB[8#Q0@8#i[*9#iOn8#1Nm;#^sN9#qh<9#:=x-#P;K2#$%X9#bC+.#Rg;<#mN=.#MTF.#RZO.#2?)4#Y#(/#[)1/#b;L/#dAU/#0Sv;#lY$0#n`-0#sf60#(F24#wrH0#%/e0#"
    "TmD<#%JSMFove:CTBEXI:<eh2g)B,3h2^G3i;#d3jD>)4kMYD4lVu`4m`:&5niUA5@(A5BA1]PBB:xlBCC=2CDLXMCEUtiCf&0g2'tN?PGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CP"
    "GT4CPGT4CPGT4CPGT4CPGT4CPGT4CP-qekC`.9kEg^+F$kwViFJTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5o,^<-28ZI'O?;xp"
    "O?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xp;7q-#lLYI:xvD=#";

static const char* GetDefaultCompressedFontDataTTFBase85()
{
    return proggy_clean_ttf_compressed_data_base85;
}

```

`UnrealFinderTool/ImGUI/imgui_impl_dx11.cpp`:

```cpp
// dear imgui: Renderer for DirectX11
// This needs to be used along with a Platform Binding (e.g. Win32)

// Implemented features:
//  [X] Renderer: User texture binding. Use 'ID3D11ShaderResourceView*' as ImTextureID. Read the FAQ about ImTextureID in imgui.cpp.

// You can copy and use unmodified imgui_impl_* files in your project. See main.cpp for an example of using this.
// If you are new to dear imgui, read examples/README.txt and read the documentation at the top of imgui.cpp
// https://github.com/ocornut/imgui

// CHANGELOG
// (minor and older changes stripped away, please see git history for details)
//  2019-04-30: DirectX11: Added support for special ImDrawCallback_ResetRenderState callback to reset render state.
//  2018-12-03: Misc: Added #pragma comment statement to automatically link with d3dcompiler.lib when using D3DCompile().
//  2018-11-30: Misc: Setting up io.BackendRendererName so it can be displayed in the About Window.
//  2018-08-01: DirectX11: Querying for IDXGIFactory instead of IDXGIFactory1 to increase compatibility.
//  2018-07-13: DirectX11: Fixed unreleased resources in Init and Shutdown functions.
//  2018-06-08: Misc: Extracted imgui_impl_dx11.cpp/.h away from the old combined DX11+Win32 example.
//  2018-06-08: DirectX11: Use draw_data->DisplayPos and draw_data->DisplaySize to setup projection matrix and clipping rectangle.
//  2018-02-16: Misc: Obsoleted the io.RenderDrawListsFn callback and exposed ImGui_ImplDX11_RenderDrawData() in the .h file so you can call it yourself.
//  2018-02-06: Misc: Removed call to ImGui::Shutdown() which is not available from 1.60 WIP, user needs to call CreateContext/DestroyContext themselves.
//  2016-05-07: DirectX11: Disabling depth-write.

#include "pch.h"
#include "imgui.h"
#include "imgui_impl_dx11.h"

// DirectX
#include <stdio.h>
#include <d3d11.h>
#include <d3dcompiler.h>
#ifdef _MSC_VER
#pragma comment(lib, "d3dcompiler") // Automatically link with d3dcompiler.lib as we are using D3DCompile() below.
#endif

// DirectX data
static ID3D11Device*            g_pd3dDevice = NULL;
static ID3D11DeviceContext*     g_pd3dDeviceContext = NULL;
static IDXGIFactory*            g_pFactory = NULL;
static ID3D11Buffer*            g_pVB = NULL;
static ID3D11Buffer*            g_pIB = NULL;
static ID3D10Blob*              g_pVertexShaderBlob = NULL;
static ID3D11VertexShader*      g_pVertexShader = NULL;
static ID3D11InputLayout*       g_pInputLayout = NULL;
static ID3D11Buffer*            g_pVertexConstantBuffer = NULL;
static ID3D10Blob*              g_pPixelShaderBlob = NULL;
static ID3D11PixelShader*       g_pPixelShader = NULL;
static ID3D11SamplerState*      g_pFontSampler = NULL;
static ID3D11ShaderResourceView*g_pFontTextureView = NULL;
static ID3D11RasterizerState*   g_pRasterizerState = NULL;
static ID3D11BlendState*        g_pBlendState = NULL;
static ID3D11DepthStencilState* g_pDepthStencilState = NULL;
static int                      g_VertexBufferSize = 5000, g_IndexBufferSize = 10000;

struct VERTEX_CONSTANT_BUFFER
{
    float   mvp[4][4];
};

static void ImGui_ImplDX11_SetupRenderState(ImDrawData* draw_data, ID3D11DeviceContext* ctx)
{
    // Setup viewport
    D3D11_VIEWPORT vp;
    memset(&vp, 0, sizeof(D3D11_VIEWPORT));
    vp.Width = draw_data->DisplaySize.x;
    vp.Height = draw_data->DisplaySize.y;
    vp.MinDepth = 0.0f;
    vp.MaxDepth = 1.0f;
    vp.TopLeftX = vp.TopLeftY = 0;
    ctx->RSSetViewports(1, &vp);

    // Setup shader and vertex buffers
    unsigned int stride = sizeof(ImDrawVert);
    unsigned int offset = 0;
    ctx->IASetInputLayout(g_pInputLayout);
    ctx->IASetVertexBuffers(0, 1, &g_pVB, &stride, &offset);
    ctx->IASetIndexBuffer(g_pIB, sizeof(ImDrawIdx) == 2 ? DXGI_FORMAT_R16_UINT : DXGI_FORMAT_R32_UINT, 0);
    ctx->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
    ctx->VSSetShader(g_pVertexShader, NULL, 0);
    ctx->VSSetConstantBuffers(0, 1, &g_pVertexConstantBuffer);
    ctx->PSSetShader(g_pPixelShader, NULL, 0);
    ctx->PSSetSamplers(0, 1, &g_pFontSampler);

    // Setup blend state
    const float blend_factor[4] = { 0.f, 0.f, 0.f, 0.f };
    ctx->OMSetBlendState(g_pBlendState, blend_factor, 0xffffffff);
    ctx->OMSetDepthStencilState(g_pDepthStencilState, 0);
    ctx->RSSetState(g_pRasterizerState);
}

// Render function
// (this used to be set in io.RenderDrawListsFn and called by ImGui::Render(), but you can now call this directly from your main loop)
void ImGui_ImplDX11_RenderDrawData(ImDrawData* draw_data)
{
    // Avoid rendering when minimized
    if (draw_data->DisplaySize.x <= 0.0f || draw_data->DisplaySize.y <= 0.0f)
        return;

    ID3D11DeviceContext* ctx = g_pd3dDeviceContext;

    // Create and grow vertex/index buffers if needed
    if (!g_pVB || g_VertexBufferSize < draw_data->TotalVtxCount)
    {
        if (g_pVB) { g_pVB->Release(); g_pVB = NULL; }
        g_VertexBufferSize = draw_data->TotalVtxCount + 5000;
        D3D11_BUFFER_DESC desc;
        memset(&desc, 0, sizeof(D3D11_BUFFER_DESC));
        desc.Usage = D3D11_USAGE_DYNAMIC;
        desc.ByteWidth = g_VertexBufferSize * sizeof(ImDrawVert);
        desc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
        desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
        desc.MiscFlags = 0;
        if (g_pd3dDevice->CreateBuffer(&desc, NULL, &g_pVB) < 0)
            return;
    }
    if (!g_pIB || g_IndexBufferSize < draw_data->TotalIdxCount)
    {
        if (g_pIB) { g_pIB->Release(); g_pIB = NULL; }
        g_IndexBufferSize = draw_data->TotalIdxCount + 10000;
        D3D11_BUFFER_DESC desc;
        memset(&desc, 0, sizeof(D3D11_BUFFER_DESC));
        desc.Usage = D3D11_USAGE_DYNAMIC;
        desc.ByteWidth = g_IndexBufferSize * sizeof(ImDrawIdx);
        desc.BindFlags = D3D11_BIND_INDEX_BUFFER;
        desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
        if (g_pd3dDevice->CreateBuffer(&desc, NULL, &g_pIB) < 0)
            return;
    }

    // Upload vertex/index data into a single contiguous GPU buffer
    D3D11_MAPPED_SUBRESOURCE vtx_resource, idx_resource;
    if (ctx->Map(g_pVB, 0, D3D11_MAP_WRITE_DISCARD, 0, &vtx_resource) != S_OK)
        return;
    if (ctx->Map(g_pIB, 0, D3D11_MAP_WRITE_DISCARD, 0, &idx_resource) != S_OK)
        return;
    ImDrawVert* vtx_dst = (ImDrawVert*)vtx_resource.pData;
    ImDrawIdx* idx_dst = (ImDrawIdx*)idx_resource.pData;
    for (int n = 0; n < draw_data->CmdListsCount; n++)
    {
        const ImDrawList* cmd_list = draw_data->CmdLists[n];
        memcpy(vtx_dst, cmd_list->VtxBuffer.Data, cmd_list->VtxBuffer.Size * sizeof(ImDrawVert));
        memcpy(idx_dst, cmd_list->IdxBuffer.Data, cmd_list->IdxBuffer.Size * sizeof(ImDrawIdx));
        vtx_dst += cmd_list->VtxBuffer.Size;
        idx_dst += cmd_list->IdxBuffer.Size;
    }
    ctx->Unmap(g_pVB, 0);
    ctx->Unmap(g_pIB, 0);

    // Setup orthographic projection matrix into our constant buffer
    // Our visible imgui space lies from draw_data->DisplayPos (top left) to draw_data->DisplayPos+data_data->DisplaySize (bottom right).
    {
        D3D11_MAPPED_SUBRESOURCE mapped_resource;
        if (ctx->Map(g_pVertexConstantBuffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &mapped_resource) != S_OK)
            return;
        VERTEX_CONSTANT_BUFFER* constant_buffer = (VERTEX_CONSTANT_BUFFER*)mapped_resource.pData;
        float L = draw_data->DisplayPos.x;
        float R = draw_data->DisplayPos.x + draw_data->DisplaySize.x;
        float T = draw_data->DisplayPos.y;
        float B = draw_data->DisplayPos.y + draw_data->DisplaySize.y;
        float mvp[4][4] =
        {
            { 2.0f/(R-L),   0.0f,           0.0f,       0.0f },
            { 0.0f,         2.0f/(T-B),     0.0f,       0.0f },
            { 0.0f,         0.0f,           0.5f,       0.0f },
            { (R+L)/(L-R),  (T+B)/(B-T),    0.5f,       1.0f },
        };
        memcpy(&constant_buffer->mvp, mvp, sizeof(mvp));
        ctx->Unmap(g_pVertexConstantBuffer, 0);
    }

    // Backup DX state that will be modified to restore it afterwards (unfortunately this is very ugly looking and verbose. Close your eyes!)
    struct BACKUP_DX11_STATE
    {
        UINT                        ScissorRectsCount, ViewportsCount;
        D3D11_RECT                  ScissorRects[D3D11_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE];
        D3D11_VIEWPORT              Viewports[D3D11_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE];
        ID3D11RasterizerState*      RS;
        ID3D11BlendState*           BlendState;
        FLOAT                       BlendFactor[4];
        UINT                        SampleMask;
        UINT                        StencilRef;
        ID3D11DepthStencilState*    DepthStencilState;
        ID3D11ShaderResourceView*   PSShaderResource;
        ID3D11SamplerState*         PSSampler;
        ID3D11PixelShader*          PS;
        ID3D11VertexShader*         VS;
        UINT                        PSInstancesCount, VSInstancesCount;
        ID3D11ClassInstance*        PSInstances[256], *VSInstances[256];   // 256 is max according to PSSetShader documentation
        D3D11_PRIMITIVE_TOPOLOGY    PrimitiveTopology;
        ID3D11Buffer*               IndexBuffer, *VertexBuffer, *VSConstantBuffer;
        UINT                        IndexBufferOffset, VertexBufferStride, VertexBufferOffset;
        DXGI_FORMAT                 IndexBufferFormat;
        ID3D11InputLayout*          InputLayout;
    };
    BACKUP_DX11_STATE old;
    old.ScissorRectsCount = old.ViewportsCount = D3D11_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE;
    ctx->RSGetScissorRects(&old.ScissorRectsCount, old.ScissorRects);
    ctx->RSGetViewports(&old.ViewportsCount, old.Viewports);
    ctx->RSGetState(&old.RS);
    ctx->OMGetBlendState(&old.BlendState, old.BlendFactor, &old.SampleMask);
    ctx->OMGetDepthStencilState(&old.DepthStencilState, &old.StencilRef);
    ctx->PSGetShaderResources(0, 1, &old.PSShaderResource);
    ctx->PSGetSamplers(0, 1, &old.PSSampler);
    old.PSInstancesCount = old.VSInstancesCount = 256;
    ctx->PSGetShader(&old.PS, old.PSInstances, &old.PSInstancesCount);
    ctx->VSGetShader(&old.VS, old.VSInstances, &old.VSInstancesCount);
    ctx->VSGetConstantBuffers(0, 1, &old.VSConstantBuffer);
    ctx->IAGetPrimitiveTopology(&old.PrimitiveTopology);
    ctx->IAGetIndexBuffer(&old.IndexBuffer, &old.IndexBufferFormat, &old.IndexBufferOffset);
    ctx->IAGetVertexBuffers(0, 1, &old.VertexBuffer, &old.VertexBufferStride, &old.VertexBufferOffset);
    ctx->IAGetInputLayout(&old.InputLayout);

    // Setup desired DX state
    ImGui_ImplDX11_SetupRenderState(draw_data, ctx);

    // Render command lists
    int vtx_offset = 0;
    int idx_offset = 0;
    ImVec2 clip_off = draw_data->DisplayPos;
    for (int n = 0; n < draw_data->CmdListsCount; n++)
    {
        const ImDrawList* cmd_list = draw_data->CmdLists[n];
        for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)
        {
            const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];
            if (pcmd->UserCallback != NULL)
            {
                // User callback, registered via ImDrawList::AddCallback()
                // (ImDrawCallback_ResetRenderState is a special callback value used by the user to request the renderer to reset render state.)
                if (pcmd->UserCallback == ImDrawCallback_ResetRenderState)
                    ImGui_ImplDX11_SetupRenderState(draw_data, ctx);
                else
                    pcmd->UserCallback(cmd_list, pcmd);
            }
            else
            {
                // Apply scissor/clipping rectangle
                const D3D11_RECT r = { (LONG)(pcmd->ClipRect.x - clip_off.x), (LONG)(pcmd->ClipRect.y - clip_off.y), (LONG)(pcmd->ClipRect.z - clip_off.x), (LONG)(pcmd->ClipRect.w - clip_off.y) };
                ctx->RSSetScissorRects(1, &r);

                // Bind texture, Draw
                ID3D11ShaderResourceView* texture_srv = (ID3D11ShaderResourceView*)pcmd->TextureId;
                ctx->PSSetShaderResources(0, 1, &texture_srv);
                ctx->DrawIndexed(pcmd->ElemCount, idx_offset, vtx_offset);
            }
            idx_offset += pcmd->ElemCount;
        }
        vtx_offset += cmd_list->VtxBuffer.Size;
    }

    // Restore modified DX state
    ctx->RSSetScissorRects(old.ScissorRectsCount, old.ScissorRects);
    ctx->RSSetViewports(old.ViewportsCount, old.Viewports);
    ctx->RSSetState(old.RS); if (old.RS) old.RS->Release();
    ctx->OMSetBlendState(old.BlendState, old.BlendFactor, old.SampleMask); if (old.BlendState) old.BlendState->Release();
    ctx->OMSetDepthStencilState(old.DepthStencilState, old.StencilRef); if (old.DepthStencilState) old.DepthStencilState->Release();
    ctx->PSSetShaderResources(0, 1, &old.PSShaderResource); if (old.PSShaderResource) old.PSShaderResource->Release();
    ctx->PSSetSamplers(0, 1, &old.PSSampler); if (old.PSSampler) old.PSSampler->Release();
    ctx->PSSetShader(old.PS, old.PSInstances, old.PSInstancesCount); if (old.PS) old.PS->Release();
    for (UINT i = 0; i < old.PSInstancesCount; i++) if (old.PSInstances[i]) old.PSInstances[i]->Release();
    ctx->VSSetShader(old.VS, old.VSInstances, old.VSInstancesCount); if (old.VS) old.VS->Release();
    ctx->VSSetConstantBuffers(0, 1, &old.VSConstantBuffer); if (old.VSConstantBuffer) old.VSConstantBuffer->Release();
    for (UINT i = 0; i < old.VSInstancesCount; i++) if (old.VSInstances[i]) old.VSInstances[i]->Release();
    ctx->IASetPrimitiveTopology(old.PrimitiveTopology);
    ctx->IASetIndexBuffer(old.IndexBuffer, old.IndexBufferFormat, old.IndexBufferOffset); if (old.IndexBuffer) old.IndexBuffer->Release();
    ctx->IASetVertexBuffers(0, 1, &old.VertexBuffer, &old.VertexBufferStride, &old.VertexBufferOffset); if (old.VertexBuffer) old.VertexBuffer->Release();
    ctx->IASetInputLayout(old.InputLayout); if (old.InputLayout) old.InputLayout->Release();
}

static void ImGui_ImplDX11_CreateFontsTexture()
{
    // Build texture atlas
    ImGuiIO& io = ImGui::GetIO();
    unsigned char* pixels;
    int width, height;
    io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);

    // Upload texture to graphics system
    {
        D3D11_TEXTURE2D_DESC desc;
        ZeroMemory(&desc, sizeof(desc));
        desc.Width = width;
        desc.Height = height;
        desc.MipLevels = 1;
        desc.ArraySize = 1;
        desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
        desc.SampleDesc.Count = 1;
        desc.Usage = D3D11_USAGE_DEFAULT;
        desc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
        desc.CPUAccessFlags = 0;

        ID3D11Texture2D *pTexture = NULL;
        D3D11_SUBRESOURCE_DATA subResource;
        subResource.pSysMem = pixels;
        subResource.SysMemPitch = desc.Width * 4;
        subResource.SysMemSlicePitch = 0;
        g_pd3dDevice->CreateTexture2D(&desc, &subResource, &pTexture);

        // Create texture view
        D3D11_SHADER_RESOURCE_VIEW_DESC srvDesc;
        ZeroMemory(&srvDesc, sizeof(srvDesc));
        srvDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
        srvDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
        srvDesc.Texture2D.MipLevels = desc.MipLevels;
        srvDesc.Texture2D.MostDetailedMip = 0;
        g_pd3dDevice->CreateShaderResourceView(pTexture, &srvDesc, &g_pFontTextureView);
        pTexture->Release();
    }

    // Store our identifier
    io.Fonts->TexID = (ImTextureID)g_pFontTextureView;

    // Create texture sampler
    {
        D3D11_SAMPLER_DESC desc;
        ZeroMemory(&desc, sizeof(desc));
        desc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;
        desc.AddressU = D3D11_TEXTURE_ADDRESS_WRAP;
        desc.AddressV = D3D11_TEXTURE_ADDRESS_WRAP;
        desc.AddressW = D3D11_TEXTURE_ADDRESS_WRAP;
        desc.MipLODBias = 0.f;
        desc.ComparisonFunc = D3D11_COMPARISON_ALWAYS;
        desc.MinLOD = 0.f;
        desc.MaxLOD = 0.f;
        g_pd3dDevice->CreateSamplerState(&desc, &g_pFontSampler);
    }
}

bool    ImGui_ImplDX11_CreateDeviceObjects()
{
    if (!g_pd3dDevice)
        return false;
    if (g_pFontSampler)
        ImGui_ImplDX11_InvalidateDeviceObjects();

    // By using D3DCompile() from <d3dcompiler.h> / d3dcompiler.lib, we introduce a dependency to a given version of d3dcompiler_XX.dll (see D3DCOMPILER_DLL_A)
    // If you would like to use this DX11 sample code but remove this dependency you can:
    //  1) compile once, save the compiled shader blobs into a file or source code and pass them to CreateVertexShader()/CreatePixelShader() [preferred solution]
    //  2) use code to detect any version of the DLL and grab a pointer to D3DCompile from the DLL.
    // See https://github.com/ocornut/imgui/pull/638 for sources and details.

    // Create the vertex shader
    {
        static const char* vertexShader =
            "cbuffer vertexBuffer : register(b0) \
            {\
            float4x4 ProjectionMatrix; \
            };\
            struct VS_INPUT\
            {\
            float2 pos : POSITION;\
            float4 col : COLOR0;\
            float2 uv  : TEXCOORD0;\
            };\
            \
            struct PS_INPUT\
            {\
            float4 pos : SV_POSITION;\
            float4 col : COLOR0;\
            float2 uv  : TEXCOORD0;\
            };\
            \
            PS_INPUT main(VS_INPUT input)\
            {\
            PS_INPUT output;\
            output.pos = mul( ProjectionMatrix, float4(input.pos.xy, 0.f, 1.f));\
            output.col = input.col;\
            output.uv  = input.uv;\
            return output;\
            }";

        D3DCompile(vertexShader, strlen(vertexShader), NULL, NULL, NULL, "main", "vs_4_0", 0, 0, &g_pVertexShaderBlob, NULL);
        if (g_pVertexShaderBlob == NULL) // NB: Pass ID3D10Blob* pErrorBlob to D3DCompile() to get error showing in (const char*)pErrorBlob->GetBufferPointer(). Make sure to Release() the blob!
            return false;
        if (g_pd3dDevice->CreateVertexShader((DWORD*)g_pVertexShaderBlob->GetBufferPointer(), g_pVertexShaderBlob->GetBufferSize(), NULL, &g_pVertexShader) != S_OK)
            return false;

        // Create the input layout
        D3D11_INPUT_ELEMENT_DESC local_layout[] =
        {
            { "POSITION", 0, DXGI_FORMAT_R32G32_FLOAT,   0, (size_t)(&((ImDrawVert*)0)->pos), D3D11_INPUT_PER_VERTEX_DATA, 0 },
            { "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT,   0, (size_t)(&((ImDrawVert*)0)->uv),  D3D11_INPUT_PER_VERTEX_DATA, 0 },
            { "COLOR",    0, DXGI_FORMAT_R8G8B8A8_UNORM, 0, (size_t)(&((ImDrawVert*)0)->col), D3D11_INPUT_PER_VERTEX_DATA, 0 },
        };
        if (g_pd3dDevice->CreateInputLayout(local_layout, 3, g_pVertexShaderBlob->GetBufferPointer(), g_pVertexShaderBlob->GetBufferSize(), &g_pInputLayout) != S_OK)
            return false;

        // Create the constant buffer
        {
            D3D11_BUFFER_DESC desc;
            desc.ByteWidth = sizeof(VERTEX_CONSTANT_BUFFER);
            desc.Usage = D3D11_USAGE_DYNAMIC;
            desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
            desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
            desc.MiscFlags = 0;
            g_pd3dDevice->CreateBuffer(&desc, NULL, &g_pVertexConstantBuffer);
        }
    }

    // Create the pixel shader
    {
        static const char* pixelShader =
            "struct PS_INPUT\
            {\
            float4 pos : SV_POSITION;\
            float4 col : COLOR0;\
            float2 uv  : TEXCOORD0;\
            };\
            sampler sampler0;\
            Texture2D texture0;\
            \
            float4 main(PS_INPUT input) : SV_Target\
            {\
            float4 out_col = input.col * texture0.Sample(sampler0, input.uv); \
            return out_col; \
            }";

        D3DCompile(pixelShader, strlen(pixelShader), NULL, NULL, NULL, "main", "ps_4_0", 0, 0, &g_pPixelShaderBlob, NULL);
        if (g_pPixelShaderBlob == NULL)  // NB: Pass ID3D10Blob* pErrorBlob to D3DCompile() to get error showing in (const char*)pErrorBlob->GetBufferPointer(). Make sure to Release() the blob!
            return false;
        if (g_pd3dDevice->CreatePixelShader((DWORD*)g_pPixelShaderBlob->GetBufferPointer(), g_pPixelShaderBlob->GetBufferSize(), NULL, &g_pPixelShader) != S_OK)
            return false;
    }

    // Create the blending setup
    {
        D3D11_BLEND_DESC desc;
        ZeroMemory(&desc, sizeof(desc));
        desc.AlphaToCoverageEnable = false;
        desc.RenderTarget[0].BlendEnable = true;
        desc.RenderTarget[0].SrcBlend = D3D11_BLEND_SRC_ALPHA;
        desc.RenderTarget[0].DestBlend = D3D11_BLEND_INV_SRC_ALPHA;
        desc.RenderTarget[0].BlendOp = D3D11_BLEND_OP_ADD;
        desc.RenderTarget[0].SrcBlendAlpha = D3D11_BLEND_INV_SRC_ALPHA;
        desc.RenderTarget[0].DestBlendAlpha = D3D11_BLEND_ZERO;
        desc.RenderTarget[0].BlendOpAlpha = D3D11_BLEND_OP_ADD;
        desc.RenderTarget[0].RenderTargetWriteMask = D3D11_COLOR_WRITE_ENABLE_ALL;
        g_pd3dDevice->CreateBlendState(&desc, &g_pBlendState);
    }

    // Create the rasterizer state
    {
        D3D11_RASTERIZER_DESC desc;
        ZeroMemory(&desc, sizeof(desc));
        desc.FillMode = D3D11_FILL_SOLID;
        desc.CullMode = D3D11_CULL_NONE;
        desc.ScissorEnable = true;
        desc.DepthClipEnable = true;
        g_pd3dDevice->CreateRasterizerState(&desc, &g_pRasterizerState);
    }

    // Create depth-stencil State
    {
        D3D11_DEPTH_STENCIL_DESC desc;
        ZeroMemory(&desc, sizeof(desc));
        desc.DepthEnable = false;
        desc.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ALL;
        desc.DepthFunc = D3D11_COMPARISON_ALWAYS;
        desc.StencilEnable = false;
        desc.FrontFace.StencilFailOp = desc.FrontFace.StencilDepthFailOp = desc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
        desc.FrontFace.StencilFunc = D3D11_COMPARISON_ALWAYS;
        desc.BackFace = desc.FrontFace;
        g_pd3dDevice->CreateDepthStencilState(&desc, &g_pDepthStencilState);
    }

    ImGui_ImplDX11_CreateFontsTexture();

    return true;
}

void    ImGui_ImplDX11_InvalidateDeviceObjects()
{
    if (!g_pd3dDevice)
        return;

    if (g_pFontSampler) { g_pFontSampler->Release(); g_pFontSampler = NULL; }
    if (g_pFontTextureView) { g_pFontTextureView->Release(); g_pFontTextureView = NULL; ImGui::GetIO().Fonts->TexID = NULL; } // We copied g_pFontTextureView to io.Fonts->TexID so let's clear that as well.
    if (g_pIB) { g_pIB->Release(); g_pIB = NULL; }
    if (g_pVB) { g_pVB->Release(); g_pVB = NULL; }

    if (g_pBlendState) { g_pBlendState->Release(); g_pBlendState = NULL; }
    if (g_pDepthStencilState) { g_pDepthStencilState->Release(); g_pDepthStencilState = NULL; }
    if (g_pRasterizerState) { g_pRasterizerState->Release(); g_pRasterizerState = NULL; }
    if (g_pPixelShader) { g_pPixelShader->Release(); g_pPixelShader = NULL; }
    if (g_pPixelShaderBlob) { g_pPixelShaderBlob->Release(); g_pPixelShaderBlob = NULL; }
    if (g_pVertexConstantBuffer) { g_pVertexConstantBuffer->Release(); g_pVertexConstantBuffer = NULL; }
    if (g_pInputLayout) { g_pInputLayout->Release(); g_pInputLayout = NULL; }
    if (g_pVertexShader) { g_pVertexShader->Release(); g_pVertexShader = NULL; }
    if (g_pVertexShaderBlob) { g_pVertexShaderBlob->Release(); g_pVertexShaderBlob = NULL; }
}

bool    ImGui_ImplDX11_Init(ID3D11Device* device, ID3D11DeviceContext* device_context)
{
    ImGuiIO& io = ImGui::GetIO();
    io.BackendRendererName = "imgui_impl_dx11";

    // Get factory from device
    IDXGIDevice* pDXGIDevice = NULL;
    IDXGIAdapter* pDXGIAdapter = NULL;
    IDXGIFactory* pFactory = NULL;

    if (device->QueryInterface(IID_PPV_ARGS(&pDXGIDevice)) == S_OK)
        if (pDXGIDevice->GetParent(IID_PPV_ARGS(&pDXGIAdapter)) == S_OK)
            if (pDXGIAdapter->GetParent(IID_PPV_ARGS(&pFactory)) == S_OK)
            {
                g_pd3dDevice = device;
                g_pd3dDeviceContext = device_context;
                g_pFactory = pFactory;
            }
    if (pDXGIDevice) pDXGIDevice->Release();
    if (pDXGIAdapter) pDXGIAdapter->Release();
    g_pd3dDevice->AddRef();
    g_pd3dDeviceContext->AddRef();

    return true;
}

void ImGui_ImplDX11_Shutdown()
{
    ImGui_ImplDX11_InvalidateDeviceObjects();
    if (g_pFactory) { g_pFactory->Release(); g_pFactory = NULL; }
    if (g_pd3dDevice) { g_pd3dDevice->Release(); g_pd3dDevice = NULL; }
    if (g_pd3dDeviceContext) { g_pd3dDeviceContext->Release(); g_pd3dDeviceContext = NULL; }
}

void ImGui_ImplDX11_NewFrame()
{
    if (!g_pFontSampler)
        ImGui_ImplDX11_CreateDeviceObjects();
}

```

`UnrealFinderTool/ImGUI/imgui_impl_dx11.h`:

```h
// dear imgui: Renderer for DirectX11
// This needs to be used along with a Platform Binding (e.g. Win32)

// Implemented features:
//  [X] Renderer: User texture binding. Use 'ID3D11ShaderResourceView*' as ImTextureID. Read the FAQ about ImTextureID in imgui.cpp.

// You can copy and use unmodified imgui_impl_* files in your project. See main.cpp for an example of using this.
// If you are new to dear imgui, read examples/README.txt and read the documentation at the top of imgui.cpp.
// https://github.com/ocornut/imgui

#pragma once

struct ID3D11Device;
struct ID3D11DeviceContext;

IMGUI_IMPL_API bool     ImGui_ImplDX11_Init(ID3D11Device* device, ID3D11DeviceContext* device_context);
IMGUI_IMPL_API void     ImGui_ImplDX11_Shutdown();
IMGUI_IMPL_API void     ImGui_ImplDX11_NewFrame();
IMGUI_IMPL_API void     ImGui_ImplDX11_RenderDrawData(ImDrawData* draw_data);

// Use if you want to reset your rendering device without losing ImGui state.
IMGUI_IMPL_API void     ImGui_ImplDX11_InvalidateDeviceObjects();
IMGUI_IMPL_API bool     ImGui_ImplDX11_CreateDeviceObjects();

```

`UnrealFinderTool/ImGUI/imgui_impl_win32.cpp`:

```cpp
// dear imgui: Platform Binding for Windows (standard windows API for 32 and 64 bits applications)
// This needs to be used along with a Renderer (e.g. DirectX11, OpenGL3, Vulkan..)

// Implemented features:
//  [X] Platform: Clipboard support (for Win32 this is actually part of core imgui)
//  [X] Platform: Mouse cursor shape and visibility. Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange'.
//  [X] Platform: Keyboard arrays indexed using VK_* Virtual Key Codes, e.g. ImGui::IsKeyPressed(VK_SPACE).
//  [X] Platform: Gamepad support. Enabled with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.

#include "pch.h"
#include "imgui.h"
#include "imgui_impl_win32.h"
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
//#include <XInput.h>
#include <tchar.h>

// CHANGELOG
// (minor and older changes stripped away, please see git history for details)
//  2019-01-17: Misc: Using GetForegroundWindow()+IsChild() instead of GetActiveWindow() to be compatible with windows created in a different thread or parent.
//  2019-01-17: Inputs: Added support for mouse buttons 4 and 5 via WM_XBUTTON* messages.
//  2019-01-15: Inputs: Added support for XInput gamepads (if ImGuiConfigFlags_NavEnableGamepad is set by user application).
//  2018-11-30: Misc: Setting up io.BackendPlatformName so it can be displayed in the About Window.
//  2018-06-29: Inputs: Added support for the ImGuiMouseCursor_Hand cursor.
//  2018-06-10: Inputs: Fixed handling of mouse wheel messages to support fine position messages (typically sent by track-pads).
//  2018-06-08: Misc: Extracted imgui_impl_win32.cpp/.h away from the old combined DX9/DX10/DX11/DX12 examples.
//  2018-03-20: Misc: Setup io.BackendFlags ImGuiBackendFlags_HasMouseCursors and ImGuiBackendFlags_HasSetMousePos flags + honor ImGuiConfigFlags_NoMouseCursorChange flag.
//  2018-02-20: Inputs: Added support for mouse cursors (ImGui::GetMouseCursor() value and WM_SETCURSOR message handling).
//  2018-02-06: Inputs: Added mapping for ImGuiKey_Space.
//  2018-02-06: Inputs: Honoring the io.WantSetMousePos by repositioning the mouse (when using navigation and ImGuiConfigFlags_NavMoveMouse is set).
//  2018-02-06: Misc: Removed call to ImGui::Shutdown() which is not available from 1.60 WIP, user needs to call CreateContext/DestroyContext themselves.
//  2018-01-20: Inputs: Added Horizontal Mouse Wheel support.
//  2018-01-08: Inputs: Added mapping for ImGuiKey_Insert.
//  2018-01-05: Inputs: Added WM_LBUTTONDBLCLK double-click handlers for window classes with the CS_DBLCLKS flag.
//  2017-10-23: Inputs: Added WM_SYSKEYDOWN / WM_SYSKEYUP handlers so e.g. the VK_MENU key can be read.
//  2017-10-23: Inputs: Using Win32 ::SetCapture/::GetCapture() to retrieve mouse positions outside the client area when dragging.
//  2016-11-12: Inputs: Only call Win32 ::SetCursor(NULL) when io.MouseDrawCursor is set.

// Win32 Data
static HWND                 g_hWnd = 0;
static INT64                g_Time = 0;
static INT64                g_TicksPerSecond = 0;
static ImGuiMouseCursor     g_LastMouseCursor = ImGuiMouseCursor_COUNT;
static bool                 g_HasGamepad = false;
static bool                 g_WantUpdateHasGamepad = true;

// Functions
bool    ImGui_ImplWin32_Init(void* hwnd)
{
    if (!::QueryPerformanceFrequency((LARGE_INTEGER *)&g_TicksPerSecond))
        return false;
    if (!::QueryPerformanceCounter((LARGE_INTEGER *)&g_Time))
        return false;

    // Setup back-end capabilities flags
    g_hWnd = (HWND)hwnd;
    ImGuiIO& io = ImGui::GetIO();
    io.BackendFlags |= ImGuiBackendFlags_HasMouseCursors;         // We can honor GetMouseCursor() values (optional)
    io.BackendFlags |= ImGuiBackendFlags_HasSetMousePos;          // We can honor io.WantSetMousePos requests (optional, rarely used)
    io.BackendPlatformName = "imgui_impl_win32";
    io.ImeWindowHandle = hwnd;

    // Keyboard mapping. ImGui will use those indices to peek into the io.KeysDown[] array that we will update during the application lifetime.
    io.KeyMap[ImGuiKey_Tab] = VK_TAB;
    io.KeyMap[ImGuiKey_LeftArrow] = VK_LEFT;
    io.KeyMap[ImGuiKey_RightArrow] = VK_RIGHT;
    io.KeyMap[ImGuiKey_UpArrow] = VK_UP;
    io.KeyMap[ImGuiKey_DownArrow] = VK_DOWN;
    io.KeyMap[ImGuiKey_PageUp] = VK_PRIOR;
    io.KeyMap[ImGuiKey_PageDown] = VK_NEXT;
    io.KeyMap[ImGuiKey_Home] = VK_HOME;
    io.KeyMap[ImGuiKey_End] = VK_END;
    io.KeyMap[ImGuiKey_Insert] = VK_INSERT;
    io.KeyMap[ImGuiKey_Delete] = VK_DELETE;
    io.KeyMap[ImGuiKey_Backspace] = VK_BACK;
    io.KeyMap[ImGuiKey_Space] = VK_SPACE;
    io.KeyMap[ImGuiKey_Enter] = VK_RETURN;
    io.KeyMap[ImGuiKey_Escape] = VK_ESCAPE;
    io.KeyMap[ImGuiKey_A] = 'A';
    io.KeyMap[ImGuiKey_C] = 'C';
    io.KeyMap[ImGuiKey_V] = 'V';
    io.KeyMap[ImGuiKey_X] = 'X';
    io.KeyMap[ImGuiKey_Y] = 'Y';
    io.KeyMap[ImGuiKey_Z] = 'Z';

    return true;
}

void    ImGui_ImplWin32_Shutdown()
{
    g_hWnd = (HWND)0;
}

static bool ImGui_ImplWin32_UpdateMouseCursor()
{
    ImGuiIO& io = ImGui::GetIO();
    if (io.ConfigFlags & ImGuiConfigFlags_NoMouseCursorChange)
        return false;

    ImGuiMouseCursor imgui_cursor = ImGui::GetMouseCursor();
    if (imgui_cursor == ImGuiMouseCursor_None || io.MouseDrawCursor)
    {
        // Hide OS mouse cursor if imgui is drawing it or if it wants no cursor
        ::SetCursor(NULL);
    }
    else
    {
        // Show OS mouse cursor
        LPTSTR win32_cursor = IDC_ARROW;
        switch (imgui_cursor)
        {
        case ImGuiMouseCursor_Arrow:        win32_cursor = IDC_ARROW; break;
        case ImGuiMouseCursor_TextInput:    win32_cursor = IDC_IBEAM; break;
        case ImGuiMouseCursor_ResizeAll:    win32_cursor = IDC_SIZEALL; break;
        case ImGuiMouseCursor_ResizeEW:     win32_cursor = IDC_SIZEWE; break;
        case ImGuiMouseCursor_ResizeNS:     win32_cursor = IDC_SIZENS; break;
        case ImGuiMouseCursor_ResizeNESW:   win32_cursor = IDC_SIZENESW; break;
        case ImGuiMouseCursor_ResizeNWSE:   win32_cursor = IDC_SIZENWSE; break;
        case ImGuiMouseCursor_Hand:         win32_cursor = IDC_HAND; break;
        }
        ::SetCursor(::LoadCursor(NULL, win32_cursor));
    }
    return true;
}

static void ImGui_ImplWin32_UpdateMousePos()
{
    ImGuiIO& io = ImGui::GetIO();

    // Set OS mouse position if requested (rarely used, only when ImGuiConfigFlags_NavEnableSetMousePos is enabled by user)
    if (io.WantSetMousePos)
    {
        POINT pos = { (int)io.MousePos.x, (int)io.MousePos.y };
        ::ClientToScreen(g_hWnd, &pos);
        ::SetCursorPos(pos.x, pos.y);
    }

    // Set mouse position
    io.MousePos = ImVec2(-FLT_MAX, -FLT_MAX);
    POINT pos;
    if (HWND active_window = ::GetForegroundWindow())
        if (active_window == g_hWnd || ::IsChild(active_window, g_hWnd))
            if (::GetCursorPos(&pos) && ::ScreenToClient(g_hWnd, &pos))
                io.MousePos = ImVec2((float)pos.x, (float)pos.y);
}

//#ifdef _MSC_VER
//#pragma comment(lib, "xinput")
//#endif

// Gamepad navigation mapping
/*
static void ImGui_ImplWin32_UpdateGamepads()
{
    ImGuiIO& io = ImGui::GetIO();
    memset(io.NavInputs, 0, sizeof(io.NavInputs));
    if ((io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) == 0)
        return;

    // Calling XInputGetState() every frame on disconnected gamepads is unfortunately too slow.
    // Instead we refresh gamepad availability by calling XInputGetCapabilities() _only_ after receiving WM_DEVICECHANGE.
    if (g_WantUpdateHasGamepad)
    {
        XINPUT_CAPABILITIES caps;
        g_HasGamepad = (XInputGetCapabilities(0, XINPUT_FLAG_GAMEPAD, &caps) == ERROR_SUCCESS);
        g_WantUpdateHasGamepad = false;
    }

    XINPUT_STATE xinput_state;
    io.BackendFlags &= ~ImGuiBackendFlags_HasGamepad;
    if (g_HasGamepad && XInputGetState(0, &xinput_state) == ERROR_SUCCESS)
    {
        const XINPUT_GAMEPAD& gamepad = xinput_state.Gamepad;
        io.BackendFlags |= ImGuiBackendFlags_HasGamepad;

        #define MAP_BUTTON(NAV_NO, BUTTON_ENUM)     { io.NavInputs[NAV_NO] = (gamepad.wButtons & BUTTON_ENUM) ? 1.0f : 0.0f; }
        #define MAP_ANALOG(NAV_NO, VALUE, V0, V1)   { float vn = (float)(VALUE - V0) / (float)(V1 - V0); if (vn > 1.0f) vn = 1.0f; if (vn > 0.0f && io.NavInputs[NAV_NO] < vn) io.NavInputs[NAV_NO] = vn; }
        MAP_BUTTON(ImGuiNavInput_Activate,      XINPUT_GAMEPAD_A);              // Cross / A
        MAP_BUTTON(ImGuiNavInput_Cancel,        XINPUT_GAMEPAD_B);              // Circle / B
        MAP_BUTTON(ImGuiNavInput_Menu,          XINPUT_GAMEPAD_X);              // Square / X
        MAP_BUTTON(ImGuiNavInput_Input,         XINPUT_GAMEPAD_Y);              // Triangle / Y
        MAP_BUTTON(ImGuiNavInput_DpadLeft,      XINPUT_GAMEPAD_DPAD_LEFT);      // D-Pad Left
        MAP_BUTTON(ImGuiNavInput_DpadRight,     XINPUT_GAMEPAD_DPAD_RIGHT);     // D-Pad Right
        MAP_BUTTON(ImGuiNavInput_DpadUp,        XINPUT_GAMEPAD_DPAD_UP);        // D-Pad Up
        MAP_BUTTON(ImGuiNavInput_DpadDown,      XINPUT_GAMEPAD_DPAD_DOWN);      // D-Pad Down
        MAP_BUTTON(ImGuiNavInput_FocusPrev,     XINPUT_GAMEPAD_LEFT_SHOULDER);  // L1 / LB
        MAP_BUTTON(ImGuiNavInput_FocusNext,     XINPUT_GAMEPAD_RIGHT_SHOULDER); // R1 / RB
        MAP_BUTTON(ImGuiNavInput_TweakSlow,     XINPUT_GAMEPAD_LEFT_SHOULDER);  // L1 / LB
        MAP_BUTTON(ImGuiNavInput_TweakFast,     XINPUT_GAMEPAD_RIGHT_SHOULDER); // R1 / RB
        MAP_ANALOG(ImGuiNavInput_LStickLeft,    gamepad.sThumbLX,  -XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE, -32768);
        MAP_ANALOG(ImGuiNavInput_LStickRight,   gamepad.sThumbLX,  +XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE, +32767);
        MAP_ANALOG(ImGuiNavInput_LStickUp,      gamepad.sThumbLY,  +XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE, +32767);
        MAP_ANALOG(ImGuiNavInput_LStickDown,    gamepad.sThumbLY,  -XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE, -32767);
        #undef MAP_BUTTON
        #undef MAP_ANALOG
    }
}
*/
void    ImGui_ImplWin32_NewFrame()
{
    ImGuiIO& io = ImGui::GetIO();
    IM_ASSERT(io.Fonts->IsBuilt() && "Font atlas not built! It is generally built by the renderer back-end. Missing call to renderer _NewFrame() function? e.g. ImGui_ImplOpenGL3_NewFrame().");

    // Setup display size (every frame to accommodate for window resizing)
    RECT rect;
    ::GetClientRect(g_hWnd, &rect);
    io.DisplaySize = ImVec2((float)(rect.right - rect.left), (float)(rect.bottom - rect.top));

    // Setup time step
    INT64 current_time;
    ::QueryPerformanceCounter((LARGE_INTEGER *)&current_time);
    io.DeltaTime = (float)(current_time - g_Time) / g_TicksPerSecond;
    g_Time = current_time;

    // Read keyboard modifiers inputs
    io.KeyCtrl = (::GetKeyState(VK_CONTROL) & 0x8000) != 0;
    io.KeyShift = (::GetKeyState(VK_SHIFT) & 0x8000) != 0;
    io.KeyAlt = (::GetKeyState(VK_MENU) & 0x8000) != 0;
    io.KeySuper = false;
    // io.KeysDown[], io.MousePos, io.MouseDown[], io.MouseWheel: filled by the WndProc handler below.

    // Update OS mouse position
    ImGui_ImplWin32_UpdateMousePos();

    // Update OS mouse cursor with the cursor requested by imgui
    ImGuiMouseCursor mouse_cursor = io.MouseDrawCursor ? ImGuiMouseCursor_None : ImGui::GetMouseCursor();
    if (g_LastMouseCursor != mouse_cursor)
    {
        g_LastMouseCursor = mouse_cursor;
        ImGui_ImplWin32_UpdateMouseCursor();
    }

    // Update game controllers (if enabled and available)
    //ImGui_ImplWin32_UpdateGamepads();
}

// Allow compilation with old Windows SDK. MinGW doesn't have default _WIN32_WINNT/WINVER versions.
#ifndef WM_MOUSEHWHEEL
#define WM_MOUSEHWHEEL 0x020E
#endif
#ifndef DBT_DEVNODES_CHANGED
#define DBT_DEVNODES_CHANGED 0x0007
#endif

// Process Win32 mouse/keyboard inputs.
// You can read the io.WantCaptureMouse, io.WantCaptureKeyboard flags to tell if dear imgui wants to use your inputs.
// - When io.WantCaptureMouse is true, do not dispatch mouse input data to your main application.
// - When io.WantCaptureKeyboard is true, do not dispatch keyboard input data to your main application.
// Generally you may always pass all inputs to dear imgui, and hide them from your application based on those two flags.
// PS: In this Win32 handler, we use the capture API (GetCapture/SetCapture/ReleaseCapture) to be able to read mouse coordinates when dragging mouse outside of our window bounds.
// PS: We treat DBLCLK messages as regular mouse down messages, so this code will work on windows classes that have the CS_DBLCLKS flag set. Our own example app code doesn't set this flag.
IMGUI_IMPL_API LRESULT ImGui_ImplWin32_WndProcHandler(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    if (ImGui::GetCurrentContext() == NULL)
        return 0;

    ImGuiIO& io = ImGui::GetIO();
    switch (msg)
    {
    case WM_LBUTTONDOWN: case WM_LBUTTONDBLCLK:
    case WM_RBUTTONDOWN: case WM_RBUTTONDBLCLK:
    case WM_MBUTTONDOWN: case WM_MBUTTONDBLCLK:
    case WM_XBUTTONDOWN: case WM_XBUTTONDBLCLK:
    {
        int button = 0;
        if (msg == WM_LBUTTONDOWN || msg == WM_LBUTTONDBLCLK) { button = 0; }
        if (msg == WM_RBUTTONDOWN || msg == WM_RBUTTONDBLCLK) { button = 1; }
        if (msg == WM_MBUTTONDOWN || msg == WM_MBUTTONDBLCLK) { button = 2; }
        if (msg == WM_XBUTTONDOWN || msg == WM_XBUTTONDBLCLK) { button = (GET_XBUTTON_WPARAM(wParam) == XBUTTON1) ? 3 : 4; }
        if (!ImGui::IsAnyMouseDown() && ::GetCapture() == NULL)
            ::SetCapture(hwnd);
        io.MouseDown[button] = true;
        return 0;
    }
    case WM_LBUTTONUP:
    case WM_RBUTTONUP:
    case WM_MBUTTONUP:
    case WM_XBUTTONUP:
    {
        int button = 0;
        if (msg == WM_LBUTTONUP) { button = 0; }
        if (msg == WM_RBUTTONUP) { button = 1; }
        if (msg == WM_MBUTTONUP) { button = 2; }
        if (msg == WM_XBUTTONUP) { button = (GET_XBUTTON_WPARAM(wParam) == XBUTTON1) ? 3 : 4; }
        io.MouseDown[button] = false;
        if (!ImGui::IsAnyMouseDown() && ::GetCapture() == hwnd)
            ::ReleaseCapture();
        return 0;
    }
    case WM_MOUSEWHEEL:
        io.MouseWheel += (float)GET_WHEEL_DELTA_WPARAM(wParam) / (float)WHEEL_DELTA;
        return 0;
    case WM_MOUSEHWHEEL:
        io.MouseWheelH += (float)GET_WHEEL_DELTA_WPARAM(wParam) / (float)WHEEL_DELTA;
        return 0;
    case WM_KEYDOWN:
    case WM_SYSKEYDOWN:
        if (wParam < 256)
            io.KeysDown[wParam] = 1;
        return 0;
    case WM_KEYUP:
    case WM_SYSKEYUP:
        if (wParam < 256)
            io.KeysDown[wParam] = 0;
        return 0;
    case WM_CHAR:
        // You can also use ToAscii()+GetKeyboardState() to retrieve characters.
        if (wParam > 0 && wParam < 0x10000)
            io.AddInputCharacter((unsigned short)wParam);
        return 0;
    case WM_SETCURSOR:
        if (LOWORD(lParam) == HTCLIENT && ImGui_ImplWin32_UpdateMouseCursor())
            return 1;
        return 0;
    case WM_DEVICECHANGE:
        if ((UINT)wParam == DBT_DEVNODES_CHANGED)
            g_WantUpdateHasGamepad = true;
        return 0;
    }
    return 0;
}


```

`UnrealFinderTool/ImGUI/imgui_impl_win32.h`:

```h
// dear imgui: Platform Binding for Windows (standard windows API for 32 and 64 bits applications)
// This needs to be used along with a Renderer (e.g. DirectX11, OpenGL3, Vulkan..)

// Implemented features:
//  [X] Platform: Clipboard support (for Win32 this is actually part of core imgui)
//  [X] Platform: Mouse cursor shape and visibility. Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange'.
//  [X] Platform: Keyboard arrays indexed using VK_* Virtual Key Codes, e.g. ImGui::IsKeyPressed(VK_SPACE).
//  [X] Platform: Gamepad support. Enabled with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.

#pragma once

IMGUI_IMPL_API bool     ImGui_ImplWin32_Init(void* hwnd);
IMGUI_IMPL_API void     ImGui_ImplWin32_Shutdown();
IMGUI_IMPL_API void     ImGui_ImplWin32_NewFrame();

// Handler for Win32 messages, update mouse/keyboard data.
// You may or not need this for your implementation, but it can serve as reference for handling inputs.
// Intentionally commented out to avoid dragging dependencies on <windows.h> types. You can COPY this line into your .cpp code instead.
/*
IMGUI_IMPL_API LRESULT  ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
*/

```

`UnrealFinderTool/ImGUI/imgui_internal.h`:

```h
// dear imgui, v1.70
// (internal structures/api)

// You may use this file to debug, understand or extend ImGui features but we don't provide any guarantee of forward compatibility!
// Set:
//   #define IMGUI_DEFINE_MATH_OPERATORS
// To implement maths operators for ImVec2 (disabled by default to not collide with using IM_VEC2_CLASS_EXTRA along with your own math types+operators)

/*

Index of this file:
// Header mess
// Forward declarations
// STB libraries includes
// Context pointer
// Generic helpers
// Misc data structures
// Main imgui context
// Tab bar, tab item
// Internal API

*/

#pragma once

//-----------------------------------------------------------------------------
// Header mess
//-----------------------------------------------------------------------------

#ifndef IMGUI_VERSION
#error Must include imgui.h before imgui_internal.h
#endif

#include <stdio.h>      // FILE*
#include <stdlib.h>     // NULL, malloc, free, qsort, atoi, atof
#include <math.h>       // sqrtf, fabsf, fmodf, powf, floorf, ceilf, cosf, sinf
#include <limits.h>     // INT_MIN, INT_MAX

#ifdef _MSC_VER
#pragma warning (push)
#pragma warning (disable: 4251) // class 'xxx' needs to have dll-interface to be used by clients of struct 'xxx' // when IMGUI_API is set to__declspec(dllexport)
#endif

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-function"                // for stb_textedit.h
#pragma clang diagnostic ignored "-Wmissing-prototypes"             // for stb_textedit.h
#pragma clang diagnostic ignored "-Wold-style-cast"
#if __has_warning("-Wzero-as-null-pointer-constant")
#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"
#endif
#if __has_warning("-Wdouble-promotion")
#pragma clang diagnostic ignored "-Wdouble-promotion"
#endif
#endif

//-----------------------------------------------------------------------------
// Forward declarations
//-----------------------------------------------------------------------------

struct ImRect;                      // An axis-aligned rectangle (2 points)
struct ImDrawDataBuilder;           // Helper to build a ImDrawData instance
struct ImDrawListSharedData;        // Data shared between all ImDrawList instances
struct ImGuiColorMod;               // Stacked color modifier, backup of modified data so we can restore it
struct ImGuiColumnData;             // Storage data for a single column
struct ImGuiColumns;                // Storage data for a columns set
struct ImGuiContext;                // Main imgui context
struct ImGuiDataTypeInfo;           // Type information associated to a ImGuiDataType enum
struct ImGuiGroupData;              // Stacked storage data for BeginGroup()/EndGroup()
struct ImGuiInputTextState;         // Internal state of the currently focused/edited text input box
struct ImGuiItemHoveredDataBackup;  // Backup and restore IsItemHovered() internal data
struct ImGuiMenuColumns;            // Simple column measurement, currently used for MenuItem() only
struct ImGuiNavMoveResult;          // Result of a directional navigation move query result
struct ImGuiNextWindowData;         // Storage for SetNexWindow** functions
struct ImGuiPopupData;              // Storage for current popup stack
struct ImGuiSettingsHandler;        // Storage for one type registered in the .ini file
struct ImGuiStyleMod;               // Stacked style modifier, backup of modified data so we can restore it
struct ImGuiTabBar;                 // Storage for a tab bar
struct ImGuiTabItem;                // Storage for a tab item (within a tab bar)
struct ImGuiWindow;                 // Storage for one window
struct ImGuiWindowTempData;         // Temporary storage for one window (that's the data which in theory we could ditch at the end of the frame)
struct ImGuiWindowSettings;         // Storage for window settings stored in .ini file (we keep one of those even if the actual window wasn't instanced during this session)

// Use your programming IDE "Go to definition" facility on the names of the center columns to find the actual flags/enum lists.
typedef int ImGuiLayoutType;        // -> enum ImGuiLayoutType_        // Enum: Horizontal or vertical
typedef int ImGuiButtonFlags;       // -> enum ImGuiButtonFlags_       // Flags: for ButtonEx(), ButtonBehavior()
typedef int ImGuiDragFlags;         // -> enum ImGuiDragFlags_         // Flags: for DragBehavior()
typedef int ImGuiItemFlags;         // -> enum ImGuiItemFlags_         // Flags: for PushItemFlag()
typedef int ImGuiItemStatusFlags;   // -> enum ImGuiItemStatusFlags_   // Flags: for DC.LastItemStatusFlags
typedef int ImGuiNavHighlightFlags; // -> enum ImGuiNavHighlightFlags_ // Flags: for RenderNavHighlight()
typedef int ImGuiNavDirSourceFlags; // -> enum ImGuiNavDirSourceFlags_ // Flags: for GetNavInputAmount2d()
typedef int ImGuiNavMoveFlags;      // -> enum ImGuiNavMoveFlags_      // Flags: for navigation requests
typedef int ImGuiSeparatorFlags;    // -> enum ImGuiSeparatorFlags_    // Flags: for Separator() - internal
typedef int ImGuiSliderFlags;       // -> enum ImGuiSliderFlags_       // Flags: for SliderBehavior()
typedef int ImGuiTextFlags;         // -> enum ImGuiTextFlags_         // Flags: for TextEx()

//-------------------------------------------------------------------------
// STB libraries includes
//-------------------------------------------------------------------------

namespace ImStb
{

#undef STB_TEXTEDIT_STRING
#undef STB_TEXTEDIT_CHARTYPE
#define STB_TEXTEDIT_STRING             ImGuiInputTextState
#define STB_TEXTEDIT_CHARTYPE           ImWchar
#define STB_TEXTEDIT_GETWIDTH_NEWLINE   -1.0f
#define STB_TEXTEDIT_UNDOSTATECOUNT     99
#define STB_TEXTEDIT_UNDOCHARCOUNT      999
#include "imstb_textedit.h"

} // namespace ImStb

//-----------------------------------------------------------------------------
// Context pointer
//-----------------------------------------------------------------------------

#ifndef GImGui
extern IMGUI_API ImGuiContext* GImGui;  // Current implicit ImGui context pointer
#endif

//-----------------------------------------------------------------------------
// Generic helpers
//-----------------------------------------------------------------------------

#define IM_PI           3.14159265358979323846f
#ifdef _WIN32
#define IM_NEWLINE      "\r\n"   // Play it nice with Windows users (2018/05 news: Microsoft announced that Notepad will finally display Unix-style carriage returns!)
#else
#define IM_NEWLINE      "\n"
#endif
#define IM_TABSIZE      (4)

#define IMGUI_DEBUG_LOG(_FMT,...)       printf("[%05d] " _FMT, GImGui->FrameCount, __VA_ARGS__)
#define IM_STATIC_ASSERT(_COND)         typedef char static_assertion_##__line__[(_COND)?1:-1]
#define IM_F32_TO_INT8_UNBOUND(_VAL)    ((int)((_VAL) * 255.0f + ((_VAL)>=0 ? 0.5f : -0.5f)))   // Unsaturated, for display purpose
#define IM_F32_TO_INT8_SAT(_VAL)        ((int)(ImSaturate(_VAL) * 255.0f + 0.5f))               // Saturated, always output 0..255

// Enforce cdecl calling convention for functions called by the standard library, in case compilation settings changed the default to e.g. __vectorcall
#ifdef _MSC_VER
#define IMGUI_CDECL __cdecl
#else
#define IMGUI_CDECL
#endif

// Helpers: UTF-8 <> wchar
IMGUI_API int           ImTextStrToUtf8(char* buf, int buf_size, const ImWchar* in_text, const ImWchar* in_text_end);      // return output UTF-8 bytes count
IMGUI_API int           ImTextCharFromUtf8(unsigned int* out_char, const char* in_text, const char* in_text_end);          // read one character. return input UTF-8 bytes count
IMGUI_API int           ImTextStrFromUtf8(ImWchar* buf, int buf_size, const char* in_text, const char* in_text_end, const char** in_remaining = NULL);   // return input UTF-8 bytes count
IMGUI_API int           ImTextCountCharsFromUtf8(const char* in_text, const char* in_text_end);                            // return number of UTF-8 code-points (NOT bytes count)
IMGUI_API int           ImTextCountUtf8BytesFromChar(const char* in_text, const char* in_text_end);                        // return number of bytes to express one char in UTF-8
IMGUI_API int           ImTextCountUtf8BytesFromStr(const ImWchar* in_text, const ImWchar* in_text_end);                   // return number of bytes to express string in UTF-8

// Helpers: Misc
IMGUI_API ImU32         ImHashData(const void* data, size_t data_size, ImU32 seed = 0);
IMGUI_API ImU32         ImHashStr(const char* data, size_t data_size = 0, ImU32 seed = 0);
IMGUI_API void*         ImFileLoadToMemory(const char* filename, const char* file_open_mode, size_t* out_file_size = NULL, int padding_bytes = 0);
IMGUI_API FILE*         ImFileOpen(const char* filename, const char* file_open_mode);
static inline bool      ImCharIsBlankA(char c)          { return c == ' ' || c == '\t'; }
static inline bool      ImCharIsBlankW(unsigned int c)  { return c == ' ' || c == '\t' || c == 0x3000; }
static inline bool      ImIsPowerOfTwo(int v)           { return v != 0 && (v & (v - 1)) == 0; }
static inline int       ImUpperPowerOfTwo(int v)        { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return v; }
#define ImQsort         qsort
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
static inline ImU32     ImHash(const void* data, int size, ImU32 seed = 0) { return size ? ImHashData(data, (size_t)size, seed) : ImHashStr((const char*)data, 0, seed); } // [moved to ImHashStr/ImHashData in 1.68]
#endif

// Helpers: Geometry
IMGUI_API ImVec2        ImLineClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& p);
IMGUI_API bool          ImTriangleContainsPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p);
IMGUI_API ImVec2        ImTriangleClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p);
IMGUI_API void          ImTriangleBarycentricCoords(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p, float& out_u, float& out_v, float& out_w);
IMGUI_API ImGuiDir      ImGetDirQuadrantFromDelta(float dx, float dy);

// Helpers: String
IMGUI_API int           ImStricmp(const char* str1, const char* str2);
IMGUI_API int           ImStrnicmp(const char* str1, const char* str2, size_t count);
IMGUI_API void          ImStrncpy(char* dst, const char* src, size_t count);
IMGUI_API char*         ImStrdup(const char* str);
IMGUI_API char*         ImStrdupcpy(char* dst, size_t* p_dst_size, const char* str);
IMGUI_API const char*   ImStrchrRange(const char* str_begin, const char* str_end, char c);
IMGUI_API int           ImStrlenW(const ImWchar* str);
IMGUI_API const char*   ImStreolRange(const char* str, const char* str_end);                // End end-of-line
IMGUI_API const ImWchar*ImStrbolW(const ImWchar* buf_mid_line, const ImWchar* buf_begin);   // Find beginning-of-line
IMGUI_API const char*   ImStristr(const char* haystack, const char* haystack_end, const char* needle, const char* needle_end);
IMGUI_API void          ImStrTrimBlanks(char* str);
IMGUI_API int           ImFormatString(char* buf, size_t buf_size, const char* fmt, ...) IM_FMTARGS(3);
IMGUI_API int           ImFormatStringV(char* buf, size_t buf_size, const char* fmt, va_list args) IM_FMTLIST(3);
IMGUI_API const char*   ImParseFormatFindStart(const char* format);
IMGUI_API const char*   ImParseFormatFindEnd(const char* format);
IMGUI_API const char*   ImParseFormatTrimDecorations(const char* format, char* buf, size_t buf_size);
IMGUI_API int           ImParseFormatPrecision(const char* format, int default_value);

// Helpers: ImVec2/ImVec4 operators
// We are keeping those disabled by default so they don't leak in user space, to allow user enabling implicit cast operators between ImVec2 and their own types (using IM_VEC2_CLASS_EXTRA etc.)
// We unfortunately don't have a unary- operator for ImVec2 because this would needs to be defined inside the class itself.
#ifdef IMGUI_DEFINE_MATH_OPERATORS
static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }
static inline ImVec2 operator/(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x/rhs, lhs.y/rhs); }
static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }
static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }
static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }
static inline ImVec2 operator/(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x/rhs.x, lhs.y/rhs.y); }
static inline ImVec2& operator+=(ImVec2& lhs, const ImVec2& rhs)                { lhs.x += rhs.x; lhs.y += rhs.y; return lhs; }
static inline ImVec2& operator-=(ImVec2& lhs, const ImVec2& rhs)                { lhs.x -= rhs.x; lhs.y -= rhs.y; return lhs; }
static inline ImVec2& operator*=(ImVec2& lhs, const float rhs)                  { lhs.x *= rhs; lhs.y *= rhs; return lhs; }
static inline ImVec2& operator/=(ImVec2& lhs, const float rhs)                  { lhs.x /= rhs; lhs.y /= rhs; return lhs; }
static inline ImVec4 operator+(const ImVec4& lhs, const ImVec4& rhs)            { return ImVec4(lhs.x+rhs.x, lhs.y+rhs.y, lhs.z+rhs.z, lhs.w+rhs.w); }
static inline ImVec4 operator-(const ImVec4& lhs, const ImVec4& rhs)            { return ImVec4(lhs.x-rhs.x, lhs.y-rhs.y, lhs.z-rhs.z, lhs.w-rhs.w); }
static inline ImVec4 operator*(const ImVec4& lhs, const ImVec4& rhs)            { return ImVec4(lhs.x*rhs.x, lhs.y*rhs.y, lhs.z*rhs.z, lhs.w*rhs.w); }
#endif

// Helpers: Maths
// - Wrapper for standard libs functions. (Note that imgui_demo.cpp does _not_ use them to keep the code easy to copy)
#ifndef IMGUI_DISABLE_MATH_FUNCTIONS
static inline float  ImFabs(float x)                                            { return fabsf(x); }
static inline float  ImSqrt(float x)                                            { return sqrtf(x); }
static inline float  ImPow(float x, float y)                                    { return powf(x, y); }
static inline double ImPow(double x, double y)                                  { return pow(x, y); }
static inline float  ImFmod(float x, float y)                                   { return fmodf(x, y); }
static inline double ImFmod(double x, double y)                                 { return fmod(x, y); }
static inline float  ImCos(float x)                                             { return cosf(x); }
static inline float  ImSin(float x)                                             { return sinf(x); }
static inline float  ImAcos(float x)                                            { return acosf(x); }
static inline float  ImAtan2(float y, float x)                                  { return atan2f(y, x); }
static inline double ImAtof(const char* s)                                      { return atof(s); }
static inline float  ImFloorStd(float x)                                        { return floorf(x); }   // we already uses our own ImFloor() { return (float)(int)v } internally so the standard one wrapper is named differently (it's used by stb_truetype)
static inline float  ImCeil(float x)                                            { return ceilf(x); }
#endif
// - ImMin/ImMax/ImClamp/ImLerp/ImSwap are used by widgets which support for variety of types: signed/unsigned int/long long float/double
// (Exceptionally using templates here but we could also redefine them for variety of types)
template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }
template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }
template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }
template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }
template<typename T> static inline void ImSwap(T& a, T& b)                      { T tmp = a; a = b; b = tmp; }
template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }
template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }
// - Misc maths helpers
static inline ImVec2 ImMin(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x < rhs.x ? lhs.x : rhs.x, lhs.y < rhs.y ? lhs.y : rhs.y); }
static inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x >= rhs.x ? lhs.x : rhs.x, lhs.y >= rhs.y ? lhs.y : rhs.y); }
static inline ImVec2 ImClamp(const ImVec2& v, const ImVec2& mn, ImVec2 mx)      { return ImVec2((v.x < mn.x) ? mn.x : (v.x > mx.x) ? mx.x : v.x, (v.y < mn.y) ? mn.y : (v.y > mx.y) ? mx.y : v.y); }
static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, float t)          { return ImVec2(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t); }
static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }
static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t)          { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }
static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }
static inline float  ImLengthSqr(const ImVec2& lhs)                             { return lhs.x*lhs.x + lhs.y*lhs.y; }
static inline float  ImLengthSqr(const ImVec4& lhs)                             { return lhs.x*lhs.x + lhs.y*lhs.y + lhs.z*lhs.z + lhs.w*lhs.w; }
static inline float  ImInvLength(const ImVec2& lhs, float fail_value)           { float d = lhs.x*lhs.x + lhs.y*lhs.y; if (d > 0.0f) return 1.0f / ImSqrt(d); return fail_value; }
static inline float  ImFloor(float f)                                           { return (float)(int)f; }
static inline ImVec2 ImFloor(const ImVec2& v)                                   { return ImVec2((float)(int)v.x, (float)(int)v.y); }
static inline int    ImModPositive(int a, int b)                                { return (a + b) % b; }
static inline float  ImDot(const ImVec2& a, const ImVec2& b)                    { return a.x * b.x + a.y * b.y; }
static inline ImVec2 ImRotate(const ImVec2& v, float cos_a, float sin_a)        { return ImVec2(v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a); }
static inline float  ImLinearSweep(float current, float target, float speed)    { if (current < target) return ImMin(current + speed, target); if (current > target) return ImMax(current - speed, target); return current; }
static inline ImVec2 ImMul(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }

// Helper: ImBoolVector. Store 1-bit per value.
// Note that Resize() currently clears the whole vector.
struct ImBoolVector
{
    ImVector<int>   Storage;
    ImBoolVector()  { }
    void            Resize(int sz)          { Storage.resize((sz + 31) >> 5); memset(Storage.Data, 0, (size_t)Storage.Size * sizeof(Storage.Data[0])); }
    void            Clear()                 { Storage.clear(); }
    bool            GetBit(int n) const     { int off = (n >> 5); int mask = 1 << (n & 31); return (Storage[off] & mask) != 0; }
    void            SetBit(int n, bool v)   { int off = (n >> 5); int mask = 1 << (n & 31); if (v) Storage[off] |= mask; else Storage[off] &= ~mask; }
};

// Helper: ImPool<>. Basic keyed storage for contiguous instances, slow/amortized insertion, O(1) indexable, O(Log N) queries by ID over a dense/hot buffer,
// Honor constructor/destructor. Add/remove invalidate all pointers. Indexes have the same lifetime as the associated object.
typedef int ImPoolIdx;
template<typename T>
struct IMGUI_API ImPool
{
    ImVector<T>     Data;       // Contiguous data
    ImGuiStorage    Map;        // ID->Index
    ImPoolIdx       FreeIdx;    // Next free idx to use

    ImPool()    { FreeIdx = 0; }
    ~ImPool()   { Clear(); }
    T*          GetByKey(ImGuiID key)               { int idx = Map.GetInt(key, -1); return (idx != -1) ? &Data[idx] : NULL; }
    T*          GetByIndex(ImPoolIdx n)             { return &Data[n]; }
    ImPoolIdx   GetIndex(const T* p) const          { IM_ASSERT(p >= Data.Data && p < Data.Data + Data.Size); return (ImPoolIdx)(p - Data.Data); }
    T*          GetOrAddByKey(ImGuiID key)          { int* p_idx = Map.GetIntRef(key, -1); if (*p_idx != -1) return &Data[*p_idx]; *p_idx = FreeIdx; return Add(); }
    bool        Contains(const T* p) const          { return (p >= Data.Data && p < Data.Data + Data.Size); }
    void        Clear()                             { for (int n = 0; n < Map.Data.Size; n++) { int idx = Map.Data[n].val_i; if (idx != -1) Data[idx].~T(); } Map.Clear(); Data.clear(); FreeIdx = 0; }
    T*          Add()                               { int idx = FreeIdx; if (idx == Data.Size) { Data.resize(Data.Size + 1); FreeIdx++; } else { FreeIdx = *(int*)&Data[idx]; } IM_PLACEMENT_NEW(&Data[idx]) T(); return &Data[idx]; }
    void        Remove(ImGuiID key, const T* p)     { Remove(key, GetIndex(p)); }
    void        Remove(ImGuiID key, ImPoolIdx idx)  { Data[idx].~T(); *(int*)&Data[idx] = FreeIdx; FreeIdx = idx; Map.SetInt(key, -1); }
    void        Reserve(int capacity)               { Data.reserve(capacity); Map.Data.reserve(capacity); }
    int         GetSize() const                     { return Data.Size; }
};

//-----------------------------------------------------------------------------
// Misc data structures
//-----------------------------------------------------------------------------

enum ImGuiButtonFlags_
{
    ImGuiButtonFlags_None                   = 0,
    ImGuiButtonFlags_Repeat                 = 1 << 0,   // hold to repeat
    ImGuiButtonFlags_PressedOnClickRelease  = 1 << 1,   // [Default] return true on click + release on same item
    ImGuiButtonFlags_PressedOnClick         = 1 << 2,   // return true on click (default requires click+release)
    ImGuiButtonFlags_PressedOnRelease       = 1 << 3,   // return true on release (default requires click+release)
    ImGuiButtonFlags_PressedOnDoubleClick   = 1 << 4,   // return true on double-click (default requires click+release)
    ImGuiButtonFlags_FlattenChildren        = 1 << 5,   // allow interactions even if a child window is overlapping
    ImGuiButtonFlags_AllowItemOverlap       = 1 << 6,   // require previous frame HoveredId to either match id or be null before being usable, use along with SetItemAllowOverlap()
    ImGuiButtonFlags_DontClosePopups        = 1 << 7,   // disable automatically closing parent popup on press // [UNUSED]
    ImGuiButtonFlags_Disabled               = 1 << 8,   // disable interactions
    ImGuiButtonFlags_AlignTextBaseLine      = 1 << 9,   // vertically align button to match text baseline - ButtonEx() only // FIXME: Should be removed and handled by SmallButton(), not possible currently because of DC.CursorPosPrevLine
    ImGuiButtonFlags_NoKeyModifiers         = 1 << 10,  // disable interaction if a key modifier is held
    ImGuiButtonFlags_NoHoldingActiveID      = 1 << 11,  // don't set ActiveId while holding the mouse (ImGuiButtonFlags_PressedOnClick only)
    ImGuiButtonFlags_PressedOnDragDropHold  = 1 << 12,  // press when held into while we are drag and dropping another item (used by e.g. tree nodes, collapsing headers)
    ImGuiButtonFlags_NoNavFocus             = 1 << 13,  // don't override navigation focus when activated
    ImGuiButtonFlags_NoHoveredOnNav         = 1 << 14   // don't report as hovered when navigated on
};

enum ImGuiSliderFlags_
{
    ImGuiSliderFlags_None                   = 0,
    ImGuiSliderFlags_Vertical               = 1 << 0
};

enum ImGuiDragFlags_
{
    ImGuiDragFlags_None                     = 0,
    ImGuiDragFlags_Vertical                 = 1 << 0
};

enum ImGuiColumnsFlags_
{
    // Default: 0
    ImGuiColumnsFlags_None                  = 0,
    ImGuiColumnsFlags_NoBorder              = 1 << 0,   // Disable column dividers
    ImGuiColumnsFlags_NoResize              = 1 << 1,   // Disable resizing columns when clicking on the dividers
    ImGuiColumnsFlags_NoPreserveWidths      = 1 << 2,   // Disable column width preservation when adjusting columns
    ImGuiColumnsFlags_NoForceWithinWindow   = 1 << 3,   // Disable forcing columns to fit within window
    ImGuiColumnsFlags_GrowParentContentsSize= 1 << 4    // (WIP) Restore pre-1.51 behavior of extending the parent window contents size but _without affecting the columns width at all_. Will eventually remove.
};

enum ImGuiSelectableFlagsPrivate_
{
    // NB: need to be in sync with last value of ImGuiSelectableFlags_
    ImGuiSelectableFlags_NoHoldingActiveID  = 1 << 10,
    ImGuiSelectableFlags_PressedOnClick     = 1 << 11,
    ImGuiSelectableFlags_PressedOnRelease   = 1 << 12,
    ImGuiSelectableFlags_DrawFillAvailWidth = 1 << 13,  // FIXME: We may be able to remove this (added in 6251d379 for menus)
    ImGuiSelectableFlags_AllowItemOverlap   = 1 << 14
};

enum ImGuiSeparatorFlags_
{
    ImGuiSeparatorFlags_None                = 0,
    ImGuiSeparatorFlags_Horizontal          = 1 << 0,   // Axis default to current layout type, so generally Horizontal unless e.g. in a menu bar
    ImGuiSeparatorFlags_Vertical            = 1 << 1
};

// Transient per-window flags, reset at the beginning of the frame. For child window, inherited from parent on first Begin().
// This is going to be exposed in imgui.h when stabilized enough.
enum ImGuiItemFlags_
{
    ImGuiItemFlags_NoTabStop                = 1 << 0,  // false
    ImGuiItemFlags_ButtonRepeat             = 1 << 1,  // false    // Button() will return true multiple times based on io.KeyRepeatDelay and io.KeyRepeatRate settings.
    ImGuiItemFlags_Disabled                 = 1 << 2,  // false    // [BETA] Disable interactions but doesn't affect visuals yet. See github.com/ocornut/imgui/issues/211
    ImGuiItemFlags_NoNav                    = 1 << 3,  // false
    ImGuiItemFlags_NoNavDefaultFocus        = 1 << 4,  // false
    ImGuiItemFlags_SelectableDontClosePopup = 1 << 5,  // false    // MenuItem/Selectable() automatically closes current Popup window
    ImGuiItemFlags_Default_                 = 0
};

// Storage for LastItem data
enum ImGuiItemStatusFlags_
{
    ImGuiItemStatusFlags_None               = 0,
    ImGuiItemStatusFlags_HoveredRect        = 1 << 0,
    ImGuiItemStatusFlags_HasDisplayRect     = 1 << 1,
    ImGuiItemStatusFlags_Edited             = 1 << 2,   // Value exposed by item was edited in the current frame (should match the bool return value of most widgets)
    ImGuiItemStatusFlags_ToggledSelection   = 1 << 3    // Set when Selectable(), TreeNode() reports toggling a selection. We can't report "Selected" because reporting the change allows us to handle clipping with less issues.

#ifdef IMGUI_ENABLE_TEST_ENGINE
    , // [imgui-test only]
    ImGuiItemStatusFlags_Openable           = 1 << 10,  //
    ImGuiItemStatusFlags_Opened             = 1 << 11,  //
    ImGuiItemStatusFlags_Checkable          = 1 << 12,  //
    ImGuiItemStatusFlags_Checked            = 1 << 13   //
#endif
};

enum ImGuiTextFlags_
{
    ImGuiTextFlags_None = 0,
    ImGuiTextFlags_NoWidthForLargeClippedText = 1 << 0
};

// FIXME: this is in development, not exposed/functional as a generic feature yet.
// Horizontal/Vertical enums are fixed to 0/1 so they may be used to index ImVec2
enum ImGuiLayoutType_
{
    ImGuiLayoutType_Horizontal = 0,
    ImGuiLayoutType_Vertical = 1
};

enum ImGuiLogType
{
    ImGuiLogType_None = 0,
    ImGuiLogType_TTY,
    ImGuiLogType_File,
    ImGuiLogType_Buffer,
    ImGuiLogType_Clipboard
};

// X/Y enums are fixed to 0/1 so they may be used to index ImVec2
enum ImGuiAxis
{
    ImGuiAxis_None = -1,
    ImGuiAxis_X = 0,
    ImGuiAxis_Y = 1
};

enum ImGuiPlotType
{
    ImGuiPlotType_Lines,
    ImGuiPlotType_Histogram
};

enum ImGuiInputSource
{
    ImGuiInputSource_None = 0,
    ImGuiInputSource_Mouse,
    ImGuiInputSource_Nav,
    ImGuiInputSource_NavKeyboard,   // Only used occasionally for storage, not tested/handled by most code
    ImGuiInputSource_NavGamepad,    // "
    ImGuiInputSource_COUNT
};

// FIXME-NAV: Clarify/expose various repeat delay/rate
enum ImGuiInputReadMode
{
    ImGuiInputReadMode_Down,
    ImGuiInputReadMode_Pressed,
    ImGuiInputReadMode_Released,
    ImGuiInputReadMode_Repeat,
    ImGuiInputReadMode_RepeatSlow,
    ImGuiInputReadMode_RepeatFast
};

enum ImGuiNavHighlightFlags_
{
    ImGuiNavHighlightFlags_None         = 0,
    ImGuiNavHighlightFlags_TypeDefault  = 1 << 0,
    ImGuiNavHighlightFlags_TypeThin     = 1 << 1,
    ImGuiNavHighlightFlags_AlwaysDraw   = 1 << 2,       // Draw rectangular highlight if (g.NavId == id) _even_ when using the mouse.
    ImGuiNavHighlightFlags_NoRounding   = 1 << 3
};

enum ImGuiNavDirSourceFlags_
{
    ImGuiNavDirSourceFlags_None         = 0,
    ImGuiNavDirSourceFlags_Keyboard     = 1 << 0,
    ImGuiNavDirSourceFlags_PadDPad      = 1 << 1,
    ImGuiNavDirSourceFlags_PadLStick    = 1 << 2
};

enum ImGuiNavMoveFlags_
{
    ImGuiNavMoveFlags_None                  = 0,
    ImGuiNavMoveFlags_LoopX                 = 1 << 0,   // On failed request, restart from opposite side
    ImGuiNavMoveFlags_LoopY                 = 1 << 1,
    ImGuiNavMoveFlags_WrapX                 = 1 << 2,   // On failed request, request from opposite side one line down (when NavDir==right) or one line up (when NavDir==left)
    ImGuiNavMoveFlags_WrapY                 = 1 << 3,   // This is not super useful for provided for completeness
    ImGuiNavMoveFlags_AllowCurrentNavId     = 1 << 4,   // Allow scoring and considering the current NavId as a move target candidate. This is used when the move source is offset (e.g. pressing PageDown actually needs to send a Up move request, if we are pressing PageDown from the bottom-most item we need to stay in place)
    ImGuiNavMoveFlags_AlsoScoreVisibleSet   = 1 << 5    // Store alternate result in NavMoveResultLocalVisibleSet that only comprise elements that are already fully visible.
};

enum ImGuiNavForward
{
    ImGuiNavForward_None,
    ImGuiNavForward_ForwardQueued,
    ImGuiNavForward_ForwardActive
};

enum ImGuiNavLayer
{
    ImGuiNavLayer_Main  = 0,    // Main scrolling layer
    ImGuiNavLayer_Menu  = 1,    // Menu layer (access with Alt/ImGuiNavInput_Menu)
    ImGuiNavLayer_COUNT
};

enum ImGuiPopupPositionPolicy
{
    ImGuiPopupPositionPolicy_Default,
    ImGuiPopupPositionPolicy_ComboBox
};

// 1D vector (this odd construct is used to facilitate the transition between 1D and 2D, and the maintenance of some branches/patches)
struct ImVec1
{
    float   x;
    ImVec1()         { x = 0.0f; }
    ImVec1(float _x) { x = _x; }
};

// 2D axis aligned bounding-box
// NB: we can't rely on ImVec2 math operators being available here
struct IMGUI_API ImRect
{
    ImVec2      Min;    // Upper-left
    ImVec2      Max;    // Lower-right

    ImRect()                                        : Min(FLT_MAX,FLT_MAX), Max(-FLT_MAX,-FLT_MAX)  {}
    ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}
    ImRect(const ImVec4& v)                         : Min(v.x, v.y), Max(v.z, v.w)                  {}
    ImRect(float x1, float y1, float x2, float y2)  : Min(x1, y1), Max(x2, y2)                      {}

    ImVec2      GetCenter() const                   { return ImVec2((Min.x + Max.x) * 0.5f, (Min.y + Max.y) * 0.5f); }
    ImVec2      GetSize() const                     { return ImVec2(Max.x - Min.x, Max.y - Min.y); }
    float       GetWidth() const                    { return Max.x - Min.x; }
    float       GetHeight() const                   { return Max.y - Min.y; }
    ImVec2      GetTL() const                       { return Min; }                   // Top-left
    ImVec2      GetTR() const                       { return ImVec2(Max.x, Min.y); }  // Top-right
    ImVec2      GetBL() const                       { return ImVec2(Min.x, Max.y); }  // Bottom-left
    ImVec2      GetBR() const                       { return Max; }                   // Bottom-right
    bool        Contains(const ImVec2& p) const     { return p.x     >= Min.x && p.y     >= Min.y && p.x     <  Max.x && p.y     <  Max.y; }
    bool        Contains(const ImRect& r) const     { return r.Min.x >= Min.x && r.Min.y >= Min.y && r.Max.x <= Max.x && r.Max.y <= Max.y; }
    bool        Overlaps(const ImRect& r) const     { return r.Min.y <  Max.y && r.Max.y >  Min.y && r.Min.x <  Max.x && r.Max.x >  Min.x; }
    void        Add(const ImVec2& p)                { if (Min.x > p.x)     Min.x = p.x;     if (Min.y > p.y)     Min.y = p.y;     if (Max.x < p.x)     Max.x = p.x;     if (Max.y < p.y)     Max.y = p.y; }
    void        Add(const ImRect& r)                { if (Min.x > r.Min.x) Min.x = r.Min.x; if (Min.y > r.Min.y) Min.y = r.Min.y; if (Max.x < r.Max.x) Max.x = r.Max.x; if (Max.y < r.Max.y) Max.y = r.Max.y; }
    void        Expand(const float amount)          { Min.x -= amount;   Min.y -= amount;   Max.x += amount;   Max.y += amount; }
    void        Expand(const ImVec2& amount)        { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }
    void        Translate(const ImVec2& d)          { Min.x += d.x; Min.y += d.y; Max.x += d.x; Max.y += d.y; }
    void        TranslateX(float dx)                { Min.x += dx; Max.x += dx; }
    void        TranslateY(float dy)                { Min.y += dy; Max.y += dy; }
    void        ClipWith(const ImRect& r)           { Min = ImMax(Min, r.Min); Max = ImMin(Max, r.Max); }                   // Simple version, may lead to an inverted rectangle, which is fine for Contains/Overlaps test but not for display.
    void        ClipWithFull(const ImRect& r)       { Min = ImClamp(Min, r.Min, r.Max); Max = ImClamp(Max, r.Min, r.Max); } // Full version, ensure both points are fully clipped.
    void        Floor()                             { Min.x = (float)(int)Min.x; Min.y = (float)(int)Min.y; Max.x = (float)(int)Max.x; Max.y = (float)(int)Max.y; }
    bool        IsInverted() const                  { return Min.x > Max.x || Min.y > Max.y; }
};

// Type information associated to one ImGuiDataType. Retrieve with DataTypeGetInfo().
struct ImGuiDataTypeInfo
{
    size_t      Size;           // Size in byte
    const char* PrintFmt;       // Default printf format for the type
    const char* ScanFmt;        // Default scanf format for the type
};

// Stacked color modifier, backup of modified data so we can restore it
struct ImGuiColorMod
{
    ImGuiCol    Col;
    ImVec4      BackupValue;
};

// Stacked style modifier, backup of modified data so we can restore it. Data type inferred from the variable.
struct ImGuiStyleMod
{
    ImGuiStyleVar   VarIdx;
    union           { int BackupInt[2]; float BackupFloat[2]; };
    ImGuiStyleMod(ImGuiStyleVar idx, int v)     { VarIdx = idx; BackupInt[0] = v; }
    ImGuiStyleMod(ImGuiStyleVar idx, float v)   { VarIdx = idx; BackupFloat[0] = v; }
    ImGuiStyleMod(ImGuiStyleVar idx, ImVec2 v)  { VarIdx = idx; BackupFloat[0] = v.x; BackupFloat[1] = v.y; }
};

// Stacked storage data for BeginGroup()/EndGroup()
struct ImGuiGroupData
{
    ImVec2      BackupCursorPos;
    ImVec2      BackupCursorMaxPos;
    ImVec1      BackupIndent;
    ImVec1      BackupGroupOffset;
    ImVec2      BackupCurrentLineSize;
    float       BackupCurrentLineTextBaseOffset;
    ImGuiID     BackupActiveIdIsAlive;
    bool        BackupActiveIdPreviousFrameIsAlive;
    bool        AdvanceCursor;
};

// Simple column measurement, currently used for MenuItem() only.. This is very short-sighted/throw-away code and NOT a generic helper.
struct IMGUI_API ImGuiMenuColumns
{
    float       Spacing;
    float       Width, NextWidth;
    float       Pos[3], NextWidths[3];

    ImGuiMenuColumns();
    void        Update(int count, float spacing, bool clear);
    float       DeclColumns(float w0, float w1, float w2);
    float       CalcExtraSpace(float avail_w);
};

// Internal state of the currently focused/edited text input box
struct IMGUI_API ImGuiInputTextState
{
    ImGuiID                 ID;                     // widget id owning the text state
    int                     CurLenW, CurLenA;       // we need to maintain our buffer length in both UTF-8 and wchar format. UTF-8 len is valid even if TextA is not.
    ImVector<ImWchar>       TextW;                  // edit buffer, we need to persist but can't guarantee the persistence of the user-provided buffer. so we copy into own buffer.
    ImVector<char>          TextA;                  // temporary UTF8 buffer for callbacks and other operations. this is not updated in every code-path! size=capacity.
    ImVector<char>          InitialTextA;           // backup of end-user buffer at the time of focus (in UTF-8, unaltered)
    bool                    TextAIsValid;           // temporary UTF8 buffer is not initially valid before we make the widget active (until then we pull the data from user argument)
    int                     BufCapacityA;           // end-user buffer capacity
    float                   ScrollX;                // horizontal scrolling/offset
    ImStb::STB_TexteditState Stb;                   // state for stb_textedit.h
    float                   CursorAnim;             // timer for cursor blink, reset on every user action so the cursor reappears immediately
    bool                    CursorFollow;           // set when we want scrolling to follow the current cursor position (not always!)
    bool                    SelectedAllMouseLock;   // after a double-click to select all, we ignore further mouse drags to update selection

    // Temporarily set when active
    ImGuiInputTextFlags     UserFlags;
    ImGuiInputTextCallback  UserCallback;
    void*                   UserCallbackData;

    ImGuiInputTextState()                           { memset(this, 0, sizeof(*this)); }
    void                ClearFreeMemory()           { TextW.clear(); TextA.clear(); InitialTextA.clear(); }
    void                CursorAnimReset()           { CursorAnim = -0.30f; }                                   // After a user-input the cursor stays on for a while without blinking
    void                CursorClamp()               { Stb.cursor = ImMin(Stb.cursor, CurLenW); Stb.select_start = ImMin(Stb.select_start, CurLenW); Stb.select_end = ImMin(Stb.select_end, CurLenW); }
    bool                HasSelection() const        { return Stb.select_start != Stb.select_end; }
    void                ClearSelection()            { Stb.select_start = Stb.select_end = Stb.cursor; }
    void                SelectAll()                 { Stb.select_start = 0; Stb.cursor = Stb.select_end = CurLenW; Stb.has_preferred_x = 0; }
    int                 GetUndoAvailCount() const   { return Stb.undostate.undo_point; }
    int                 GetRedoAvailCount() const   { return STB_TEXTEDIT_UNDOSTATECOUNT - Stb.undostate.redo_point; }
    void                OnKeyPressed(int key);      // Cannot be inline because we call in code in stb_textedit.h implementation
};

// Windows data saved in imgui.ini file
struct ImGuiWindowSettings
{
    char*       Name;
    ImGuiID     ID;
    ImVec2      Pos;
    ImVec2      Size;
    bool        Collapsed;

    ImGuiWindowSettings() { Name = NULL; ID = 0; Pos = Size = ImVec2(0,0); Collapsed = false; }
};

struct ImGuiSettingsHandler
{
    const char* TypeName;       // Short description stored in .ini file. Disallowed characters: '[' ']'
    ImGuiID     TypeHash;       // == ImHashStr(TypeName)
    void*       (*ReadOpenFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler, const char* name);              // Read: Called when entering into a new ini entry e.g. "[Window][Name]"
    void        (*ReadLineFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler, void* entry, const char* line); // Read: Called for every line of text within an ini entry
    void        (*WriteAllFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* out_buf);      // Write: Output every entries into 'out_buf'
    void*       UserData;

    ImGuiSettingsHandler() { memset(this, 0, sizeof(*this)); }
};

// Storage for current popup stack
struct ImGuiPopupData
{
    ImGuiID             PopupId;        // Set on OpenPopup()
    ImGuiWindow*        Window;         // Resolved on BeginPopup() - may stay unresolved if user never calls OpenPopup()
    ImGuiWindow*        SourceWindow;   // Set on OpenPopup() copy of NavWindow at the time of opening the popup
    int                 OpenFrameCount; // Set on OpenPopup()
    ImGuiID             OpenParentId;   // Set on OpenPopup(), we need this to differentiate multiple menu sets from each others (e.g. inside menu bar vs loose menu items)
    ImVec2              OpenPopupPos;   // Set on OpenPopup(), preferred popup position (typically == OpenMousePos when using mouse)
    ImVec2              OpenMousePos;   // Set on OpenPopup(), copy of mouse position at the time of opening popup

    ImGuiPopupData() { PopupId = 0; Window = SourceWindow = NULL; OpenFrameCount = -1; OpenParentId = 0; }
};

struct ImGuiColumnData
{
    float               OffsetNorm;         // Column start offset, normalized 0.0 (far left) -> 1.0 (far right)
    float               OffsetNormBeforeResize;
    ImGuiColumnsFlags   Flags;              // Not exposed
    ImRect              ClipRect;

    ImGuiColumnData()   { OffsetNorm = OffsetNormBeforeResize = 0.0f; Flags = ImGuiColumnsFlags_None; }
};

struct ImGuiColumns
{
    ImGuiID             ID;
    ImGuiColumnsFlags   Flags;
    bool                IsFirstFrame;
    bool                IsBeingResized;
    int                 Current;
    int                 Count;
    float               MinX, MaxX;
    float               LineMinY, LineMaxY;
    float               BackupCursorPosY;       // Backup of CursorPos at the time of BeginColumns()
    float               BackupCursorMaxPosX;    // Backup of CursorMaxPos at the time of BeginColumns()
    ImVector<ImGuiColumnData> Columns;

    ImGuiColumns()      { Clear(); }
    void Clear()
    {
        ID = 0;
        Flags = ImGuiColumnsFlags_None;
        IsFirstFrame = false;
        IsBeingResized = false;
        Current = 0;
        Count = 1;
        MinX = MaxX = 0.0f;
        LineMinY = LineMaxY = 0.0f;
        BackupCursorPosY = 0.0f;
        BackupCursorMaxPosX = 0.0f;
        Columns.clear();
    }
};

// Data shared between all ImDrawList instances
struct IMGUI_API ImDrawListSharedData
{
    ImVec2          TexUvWhitePixel;            // UV of white pixel in the atlas
    ImFont*         Font;                       // Current/default font (optional, for simplified AddText overload)
    float           FontSize;                   // Current/default font size (optional, for simplified AddText overload)
    float           CurveTessellationTol;
    ImVec4          ClipRectFullscreen;         // Value for PushClipRectFullscreen()

    // Const data
    // FIXME: Bake rounded corners fill/borders in atlas
    ImVec2          CircleVtx12[12];

    ImDrawListSharedData();
};

struct ImDrawDataBuilder
{
    ImVector<ImDrawList*>   Layers[2];           // Global layers for: regular, tooltip

    void Clear()            { for (int n = 0; n < IM_ARRAYSIZE(Layers); n++) Layers[n].resize(0); }
    void ClearFreeMemory()  { for (int n = 0; n < IM_ARRAYSIZE(Layers); n++) Layers[n].clear(); }
    IMGUI_API void FlattenIntoSingleLayer();
};

struct ImGuiNavMoveResult
{
    ImGuiID       ID;           // Best candidate
    ImGuiID       SelectScopeId;// Best candidate window current selectable group ID
    ImGuiWindow*  Window;       // Best candidate window
    float         DistBox;      // Best candidate box distance to current NavId
    float         DistCenter;   // Best candidate center distance to current NavId
    float         DistAxial;
    ImRect        RectRel;      // Best candidate bounding box in window relative space

    ImGuiNavMoveResult() { Clear(); }
    void Clear()         { ID = SelectScopeId = 0; Window = NULL; DistBox = DistCenter = DistAxial = FLT_MAX; RectRel = ImRect(); }
};

// Storage for SetNexWindow** functions
struct ImGuiNextWindowData
{
    ImGuiCond               PosCond;
    ImGuiCond               SizeCond;
    ImGuiCond               ContentSizeCond;
    ImGuiCond               CollapsedCond;
    ImGuiCond               SizeConstraintCond;
    ImGuiCond               FocusCond;
    ImGuiCond               BgAlphaCond;
    ImVec2                  PosVal;
    ImVec2                  PosPivotVal;
    ImVec2                  SizeVal;
    ImVec2                  ContentSizeVal;
    bool                    CollapsedVal;
    ImRect                  SizeConstraintRect;
    ImGuiSizeCallback       SizeCallback;
    void*                   SizeCallbackUserData;
    float                   BgAlphaVal;
    ImVec2                  MenuBarOffsetMinVal;                // This is not exposed publicly, so we don't clear it.

    ImGuiNextWindowData()
    {
        PosCond = SizeCond = ContentSizeCond = CollapsedCond = SizeConstraintCond = FocusCond = BgAlphaCond = 0;
        PosVal = PosPivotVal = SizeVal = ImVec2(0.0f, 0.0f);
        ContentSizeVal = ImVec2(0.0f, 0.0f);
        CollapsedVal = false;
        SizeConstraintRect = ImRect();
        SizeCallback = NULL;
        SizeCallbackUserData = NULL;
        BgAlphaVal = FLT_MAX;
        MenuBarOffsetMinVal = ImVec2(0.0f, 0.0f);
    }

    void    Clear()
    {
        PosCond = SizeCond = ContentSizeCond = CollapsedCond = SizeConstraintCond = FocusCond = BgAlphaCond = 0;
    }
};

//-----------------------------------------------------------------------------
// Tabs
//-----------------------------------------------------------------------------

struct ImGuiTabBarSortItem
{
    int             Index;
    float           Width;
};

struct ImGuiTabBarRef
{
    ImGuiTabBar*    Ptr;                    // Either field can be set, not both. Dock node tab bars are loose while BeginTabBar() ones are in a pool.
    int             IndexInMainPool;

    ImGuiTabBarRef(ImGuiTabBar* ptr)        { Ptr = ptr; IndexInMainPool = -1; }
    ImGuiTabBarRef(int index_in_main_pool)  { Ptr = NULL; IndexInMainPool = index_in_main_pool; }
};

//-----------------------------------------------------------------------------
// Main imgui context
//-----------------------------------------------------------------------------

struct ImGuiContext
{
    bool                    Initialized;
    bool                    FrameScopeActive;                   // Set by NewFrame(), cleared by EndFrame()
    bool                    FrameScopePushedImplicitWindow;     // Set by NewFrame(), cleared by EndFrame()
    bool                    FontAtlasOwnedByContext;            // Io.Fonts-> is owned by the ImGuiContext and will be destructed along with it.
    ImGuiIO                 IO;
    ImGuiStyle              Style;
    ImFont*                 Font;                               // (Shortcut) == FontStack.empty() ? IO.Font : FontStack.back()
    float                   FontSize;                           // (Shortcut) == FontBaseSize * g.CurrentWindow->FontWindowScale == window->FontSize(). Text height for current window.
    float                   FontBaseSize;                       // (Shortcut) == IO.FontGlobalScale * Font->Scale * Font->FontSize. Base text height.
    ImDrawListSharedData    DrawListSharedData;

    double                  Time;
    int                     FrameCount;
    int                     FrameCountEnded;
    int                     FrameCountRendered;
    ImVector<ImGuiWindow*>  Windows;                            // Windows, sorted in display order, back to front
    ImVector<ImGuiWindow*>  WindowsFocusOrder;                  // Windows, sorted in focus order, back to front
    ImVector<ImGuiWindow*>  WindowsSortBuffer;
    ImVector<ImGuiWindow*>  CurrentWindowStack;
    ImGuiStorage            WindowsById;
    int                     WindowsActiveCount;
    ImGuiWindow*            CurrentWindow;                      // Being drawn into
    ImGuiWindow*            HoveredWindow;                      // Will catch mouse inputs
    ImGuiWindow*            HoveredRootWindow;                  // Will catch mouse inputs (for focus/move only)
    ImGuiID                 HoveredId;                          // Hovered widget
    bool                    HoveredIdAllowOverlap;
    ImGuiID                 HoveredIdPreviousFrame;
    float                   HoveredIdTimer;                     // Measure contiguous hovering time
    float                   HoveredIdNotActiveTimer;            // Measure contiguous hovering time where the item has not been active
    ImGuiID                 ActiveId;                           // Active widget
    ImGuiID                 ActiveIdPreviousFrame;
    ImGuiID                 ActiveIdIsAlive;                    // Active widget has been seen this frame (we can't use a bool as the ActiveId may change within the frame)
    float                   ActiveIdTimer;
    bool                    ActiveIdIsJustActivated;            // Set at the time of activation for one frame
    bool                    ActiveIdAllowOverlap;               // Active widget allows another widget to steal active id (generally for overlapping widgets, but not always)
    bool                    ActiveIdHasBeenPressed;             // Track whether the active id led to a press (this is to allow changing between PressOnClick and PressOnRelease without pressing twice). Used by range_select branch.
    bool                    ActiveIdHasBeenEdited;              // Was the value associated to the widget Edited over the course of the Active state.
    bool                    ActiveIdPreviousFrameIsAlive;
    bool                    ActiveIdPreviousFrameHasBeenEdited;
    int                     ActiveIdAllowNavDirFlags;           // Active widget allows using directional navigation (e.g. can activate a button and move away from it)
    int                     ActiveIdBlockNavInputFlags;
    ImVec2                  ActiveIdClickOffset;                // Clicked offset from upper-left corner, if applicable (currently only set by ButtonBehavior)
    ImGuiWindow*            ActiveIdWindow;
    ImGuiWindow*            ActiveIdPreviousFrameWindow;
    ImGuiInputSource        ActiveIdSource;                     // Activating with mouse or nav (gamepad/keyboard)
    ImGuiID                 LastActiveId;                       // Store the last non-zero ActiveId, useful for animation.
    float                   LastActiveIdTimer;                  // Store the last non-zero ActiveId timer since the beginning of activation, useful for animation.
    ImVec2                  LastValidMousePos;
    ImGuiWindow*            MovingWindow;                       // Track the window we clicked on (in order to preserve focus). The actually window that is moved is generally MovingWindow->RootWindow.
    ImVector<ImGuiColorMod> ColorModifiers;                     // Stack for PushStyleColor()/PopStyleColor()
    ImVector<ImGuiStyleMod> StyleModifiers;                     // Stack for PushStyleVar()/PopStyleVar()
    ImVector<ImFont*>       FontStack;                          // Stack for PushFont()/PopFont()
    ImVector<ImGuiPopupData>OpenPopupStack;                     // Which popups are open (persistent)
    ImVector<ImGuiPopupData>BeginPopupStack;                    // Which level of BeginPopup() we are in (reset every frame)
    ImGuiNextWindowData     NextWindowData;                     // Storage for SetNextWindow** functions
    bool                    NextTreeNodeOpenVal;                // Storage for SetNextTreeNode** functions
    ImGuiCond               NextTreeNodeOpenCond;

    // Navigation data (for gamepad/keyboard)
    ImGuiWindow*            NavWindow;                          // Focused window for navigation. Could be called 'FocusWindow'
    ImGuiID                 NavId;                              // Focused item for navigation
    ImGuiID                 NavActivateId;                      // ~~ (g.ActiveId == 0) && IsNavInputPressed(ImGuiNavInput_Activate) ? NavId : 0, also set when calling ActivateItem()
    ImGuiID                 NavActivateDownId;                  // ~~ IsNavInputDown(ImGuiNavInput_Activate) ? NavId : 0
    ImGuiID                 NavActivatePressedId;               // ~~ IsNavInputPressed(ImGuiNavInput_Activate) ? NavId : 0
    ImGuiID                 NavInputId;                         // ~~ IsNavInputPressed(ImGuiNavInput_Input) ? NavId : 0
    ImGuiID                 NavJustTabbedId;                    // Just tabbed to this id.
    ImGuiID                 NavJustMovedToId;                   // Just navigated to this id (result of a successfully MoveRequest).
    ImGuiID                 NavJustMovedToMultiSelectScopeId;   // Just navigated to this select scope id (result of a successfully MoveRequest).
    ImGuiID                 NavNextActivateId;                  // Set by ActivateItem(), queued until next frame.
    ImGuiInputSource        NavInputSource;                     // Keyboard or Gamepad mode? THIS WILL ONLY BE None or NavGamepad or NavKeyboard.
    ImRect                  NavScoringRectScreen;               // Rectangle used for scoring, in screen space. Based of window->DC.NavRefRectRel[], modified for directional navigation scoring.
    int                     NavScoringCount;                    // Metrics for debugging
    ImGuiWindow*            NavWindowingTarget;                 // When selecting a window (holding Menu+FocusPrev/Next, or equivalent of CTRL-TAB) this window is temporarily displayed front-most.
    ImGuiWindow*            NavWindowingTargetAnim;             // Record of last valid NavWindowingTarget until DimBgRatio and NavWindowingHighlightAlpha becomes 0.0f
    ImGuiWindow*            NavWindowingList;
    float                   NavWindowingTimer;
    float                   NavWindowingHighlightAlpha;
    bool                    NavWindowingToggleLayer;
    ImGuiNavLayer           NavLayer;                           // Layer we are navigating on. For now the system is hard-coded for 0=main contents and 1=menu/title bar, may expose layers later.
    int                     NavIdTabCounter;                    // == NavWindow->DC.FocusIdxTabCounter at time of NavId processing
    bool                    NavIdIsAlive;                       // Nav widget has been seen this frame ~~ NavRefRectRel is valid
    bool                    NavMousePosDirty;                   // When set we will update mouse position if (io.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos) if set (NB: this not enabled by default)
    bool                    NavDisableHighlight;                // When user starts using mouse, we hide gamepad/keyboard highlight (NB: but they are still available, which is why NavDisableHighlight isn't always != NavDisableMouseHover)
    bool                    NavDisableMouseHover;               // When user starts using gamepad/keyboard, we hide mouse hovering highlight until mouse is touched again.
    bool                    NavAnyRequest;                      // ~~ NavMoveRequest || NavInitRequest
    bool                    NavInitRequest;                     // Init request for appearing window to select first item
    bool                    NavInitRequestFromMove;
    ImGuiID                 NavInitResultId;
    ImRect                  NavInitResultRectRel;
    bool                    NavMoveFromClampedRefRect;          // Set by manual scrolling, if we scroll to a point where NavId isn't visible we reset navigation from visible items
    bool                    NavMoveRequest;                     // Move request for this frame
    ImGuiNavMoveFlags       NavMoveRequestFlags;
    ImGuiNavForward         NavMoveRequestForward;              // None / ForwardQueued / ForwardActive (this is used to navigate sibling parent menus from a child menu)
    ImGuiDir                NavMoveDir, NavMoveDirLast;         // Direction of the move request (left/right/up/down), direction of the previous move request
    ImGuiDir                NavMoveClipDir;
    ImGuiNavMoveResult      NavMoveResultLocal;                 // Best move request candidate within NavWindow
    ImGuiNavMoveResult      NavMoveResultLocalVisibleSet;       // Best move request candidate within NavWindow that are mostly visible (when using ImGuiNavMoveFlags_AlsoScoreVisibleSet flag)
    ImGuiNavMoveResult      NavMoveResultOther;                 // Best move request candidate within NavWindow's flattened hierarchy (when using ImGuiWindowFlags_NavFlattened flag)

    // Tabbing system (older than Nav, active even if Nav is disabled. FIXME-NAV: This needs a redesign!)
    ImGuiWindow*            FocusRequestCurrWindow;             //
    ImGuiWindow*            FocusRequestNextWindow;             //
    int                     FocusRequestCurrCounterAll;         // Any item being requested for focus, stored as an index (we on layout to be stable between the frame pressing TAB and the next frame, semi-ouch)
    int                     FocusRequestCurrCounterTab;         // Tab item being requested for focus, stored as an index
    int                     FocusRequestNextCounterAll;         // Stored for next frame
    int                     FocusRequestNextCounterTab;         // "
    bool                    FocusTabPressed;                    //

    // Render
    ImDrawData              DrawData;                           // Main ImDrawData instance to pass render information to the user
    ImDrawDataBuilder       DrawDataBuilder;
    float                   DimBgRatio;                         // 0.0..1.0 animation when fading in a dimming background (for modal window and CTRL+TAB list)
    ImDrawList              BackgroundDrawList;                 // First draw list to be rendered.
    ImDrawList              ForegroundDrawList;                 // Last draw list to be rendered. This is where we the render software mouse cursor (if io.MouseDrawCursor is set) and most debug overlays.
    ImGuiMouseCursor        MouseCursor;

    // Drag and Drop
    bool                    DragDropActive;
    bool                    DragDropWithinSourceOrTarget;
    ImGuiDragDropFlags      DragDropSourceFlags;
    int                     DragDropSourceFrameCount;
    int                     DragDropMouseButton;
    ImGuiPayload            DragDropPayload;
    ImRect                  DragDropTargetRect;
    ImGuiID                 DragDropTargetId;
    ImGuiDragDropFlags      DragDropAcceptFlags;
    float                   DragDropAcceptIdCurrRectSurface;    // Target item surface (we resolve overlapping targets by prioritizing the smaller surface)
    ImGuiID                 DragDropAcceptIdCurr;               // Target item id (set at the time of accepting the payload)
    ImGuiID                 DragDropAcceptIdPrev;               // Target item id from previous frame (we need to store this to allow for overlapping drag and drop targets)
    int                     DragDropAcceptFrameCount;           // Last time a target expressed a desire to accept the source
    ImVector<unsigned char> DragDropPayloadBufHeap;             // We don't expose the ImVector<> directly
    unsigned char           DragDropPayloadBufLocal[8];         // Local buffer for small payloads

    // Tab bars
    ImPool<ImGuiTabBar>             TabBars;
    ImGuiTabBar*                    CurrentTabBar;
    ImVector<ImGuiTabBarRef>        CurrentTabBarStack;
    ImVector<ImGuiTabBarSortItem>   TabSortByWidthBuffer;

    // Widget state
    ImGuiInputTextState     InputTextState;
    ImFont                  InputTextPasswordFont;
    ImGuiID                 TempInputTextId;                    // Temporary text input when CTRL+clicking on a slider, etc.
    ImGuiColorEditFlags     ColorEditOptions;                   // Store user options for color edit widgets
    ImVec4                  ColorPickerRef;
    bool                    DragCurrentAccumDirty;
    float                   DragCurrentAccum;                   // Accumulator for dragging modification. Always high-precision, not rounded by end-user precision settings
    float                   DragSpeedDefaultRatio;              // If speed == 0.0f, uses (max-min) * DragSpeedDefaultRatio
    ImVec2                  ScrollbarClickDeltaToGrabCenter;    // Distance between mouse and center of grab box, normalized in parent space. Use storage?
    int                     TooltipOverrideCount;
    ImVector<char>          PrivateClipboard;                   // If no custom clipboard handler is defined

    // Range-Select/Multi-Select
    // [This is unused in this branch, but left here to facilitate merging/syncing multiple branches]
    ImGuiID                 MultiSelectScopeId;

    // Platform support
    ImVec2                  PlatformImePos;                     // Cursor position request & last passed to the OS Input Method Editor
    ImVec2                  PlatformImeLastPos;

    // Settings
    bool                           SettingsLoaded;
    float                          SettingsDirtyTimer;          // Save .ini Settings to memory when time reaches zero
    ImGuiTextBuffer                SettingsIniData;             // In memory .ini settings
    ImVector<ImGuiSettingsHandler> SettingsHandlers;            // List of .ini settings handlers
    ImVector<ImGuiWindowSettings>  SettingsWindows;             // ImGuiWindow .ini settings entries (parsed from the last loaded .ini file and maintained on saving)

    // Logging
    bool                    LogEnabled;
    ImGuiLogType            LogType;
    FILE*                   LogFile;                            // If != NULL log to stdout/ file
    ImGuiTextBuffer         LogBuffer;                          // Accumulation buffer when log to clipboard. This is pointer so our GImGui static constructor doesn't call heap allocators.
    float                   LogLinePosY;
    bool                    LogLineFirstItem;
    int                     LogDepthRef;
    int                     LogDepthToExpand;
    int                     LogDepthToExpandDefault;            // Default/stored value for LogDepthMaxExpand if not specified in the LogXXX function call.

    // Misc
    float                   FramerateSecPerFrame[120];          // Calculate estimate of framerate for user over the last 2 seconds.
    int                     FramerateSecPerFrameIdx;
    float                   FramerateSecPerFrameAccum;
    int                     WantCaptureMouseNextFrame;          // Explicit capture via CaptureKeyboardFromApp()/CaptureMouseFromApp() sets those flags
    int                     WantCaptureKeyboardNextFrame;
    int                     WantTextInputNextFrame;
    char                    TempBuffer[1024*3+1];               // Temporary text buffer

    ImGuiContext(ImFontAtlas* shared_font_atlas) : BackgroundDrawList(NULL), ForegroundDrawList(NULL)
    {
        Initialized = false;
        FrameScopeActive = FrameScopePushedImplicitWindow = false;
        Font = NULL;
        FontSize = FontBaseSize = 0.0f;
        FontAtlasOwnedByContext = shared_font_atlas ? false : true;
        IO.Fonts = shared_font_atlas ? shared_font_atlas : IM_NEW(ImFontAtlas)();

        Time = 0.0f;
        FrameCount = 0;
        FrameCountEnded = FrameCountRendered = -1;
        WindowsActiveCount = 0;
        CurrentWindow = NULL;
        HoveredWindow = NULL;
        HoveredRootWindow = NULL;
        HoveredId = 0;
        HoveredIdAllowOverlap = false;
        HoveredIdPreviousFrame = 0;
        HoveredIdTimer = HoveredIdNotActiveTimer = 0.0f;
        ActiveId = 0;
        ActiveIdPreviousFrame = 0;
        ActiveIdIsAlive = 0;
        ActiveIdTimer = 0.0f;
        ActiveIdIsJustActivated = false;
        ActiveIdAllowOverlap = false;
        ActiveIdHasBeenPressed = false;
        ActiveIdHasBeenEdited = false;
        ActiveIdPreviousFrameIsAlive = false;
        ActiveIdPreviousFrameHasBeenEdited = false;
        ActiveIdAllowNavDirFlags = 0x00;
        ActiveIdBlockNavInputFlags = 0x00;
        ActiveIdClickOffset = ImVec2(-1,-1);
        ActiveIdWindow = ActiveIdPreviousFrameWindow = NULL;
        ActiveIdSource = ImGuiInputSource_None;
        LastActiveId = 0;
        LastActiveIdTimer = 0.0f;
        LastValidMousePos = ImVec2(0.0f, 0.0f);
        MovingWindow = NULL;
        NextTreeNodeOpenVal = false;
        NextTreeNodeOpenCond = 0;

        NavWindow = NULL;
        NavId = NavActivateId = NavActivateDownId = NavActivatePressedId = NavInputId = 0;
        NavJustTabbedId = NavJustMovedToId = NavJustMovedToMultiSelectScopeId = NavNextActivateId = 0;
        NavInputSource = ImGuiInputSource_None;
        NavScoringRectScreen = ImRect();
        NavScoringCount = 0;
        NavWindowingTarget = NavWindowingTargetAnim = NavWindowingList = NULL;
        NavWindowingTimer = NavWindowingHighlightAlpha = 0.0f;
        NavWindowingToggleLayer = false;
        NavLayer = ImGuiNavLayer_Main;
        NavIdTabCounter = INT_MAX;
        NavIdIsAlive = false;
        NavMousePosDirty = false;
        NavDisableHighlight = true;
        NavDisableMouseHover = false;
        NavAnyRequest = false;
        NavInitRequest = false;
        NavInitRequestFromMove = false;
        NavInitResultId = 0;
        NavMoveFromClampedRefRect = false;
        NavMoveRequest = false;
        NavMoveRequestFlags = 0;
        NavMoveRequestForward = ImGuiNavForward_None;
        NavMoveDir = NavMoveDirLast = NavMoveClipDir = ImGuiDir_None;

        FocusRequestCurrWindow = FocusRequestNextWindow = NULL;
        FocusRequestCurrCounterAll = FocusRequestCurrCounterTab = INT_MAX;
        FocusRequestNextCounterAll = FocusRequestNextCounterTab = INT_MAX;
        FocusTabPressed = false;

        DimBgRatio = 0.0f;
        BackgroundDrawList._Data = &DrawListSharedData;
        BackgroundDrawList._OwnerName = "##Background"; // Give it a name for debugging
        ForegroundDrawList._Data = &DrawListSharedData;
        ForegroundDrawList._OwnerName = "##Foreground"; // Give it a name for debugging
        MouseCursor = ImGuiMouseCursor_Arrow;

        DragDropActive = DragDropWithinSourceOrTarget = false;
        DragDropSourceFlags = 0;
        DragDropSourceFrameCount = -1;
        DragDropMouseButton = -1;
        DragDropTargetId = 0;
        DragDropAcceptFlags = 0;
        DragDropAcceptIdCurrRectSurface = 0.0f;
        DragDropAcceptIdPrev = DragDropAcceptIdCurr = 0;
        DragDropAcceptFrameCount = -1;
        memset(DragDropPayloadBufLocal, 0, sizeof(DragDropPayloadBufLocal));

        CurrentTabBar = NULL;

        TempInputTextId = 0;
        ColorEditOptions = ImGuiColorEditFlags__OptionsDefault;
        DragCurrentAccumDirty = false;
        DragCurrentAccum = 0.0f;
        DragSpeedDefaultRatio = 1.0f / 100.0f;
        ScrollbarClickDeltaToGrabCenter = ImVec2(0.0f, 0.0f);
        TooltipOverrideCount = 0;

        MultiSelectScopeId = 0;

        PlatformImePos = PlatformImeLastPos = ImVec2(FLT_MAX, FLT_MAX);

        SettingsLoaded = false;
        SettingsDirtyTimer = 0.0f;

        LogEnabled = false;
        LogType = ImGuiLogType_None;
        LogFile = NULL;
        LogLinePosY = FLT_MAX;
        LogLineFirstItem = false;
        LogDepthRef = 0;
        LogDepthToExpand = LogDepthToExpandDefault = 2;

        memset(FramerateSecPerFrame, 0, sizeof(FramerateSecPerFrame));
        FramerateSecPerFrameIdx = 0;
        FramerateSecPerFrameAccum = 0.0f;
        WantCaptureMouseNextFrame = WantCaptureKeyboardNextFrame = WantTextInputNextFrame = -1;
        memset(TempBuffer, 0, sizeof(TempBuffer));
    }
};

//-----------------------------------------------------------------------------
// ImGuiWindow
//-----------------------------------------------------------------------------

// Transient per-window data, reset at the beginning of the frame. This used to be called ImGuiDrawContext, hence the DC variable name in ImGuiWindow.
// FIXME: That's theory, in practice the delimitation between ImGuiWindow and ImGuiWindowTempData is quite tenuous and could be reconsidered.
struct IMGUI_API ImGuiWindowTempData
{
    ImVec2                  CursorPos;
    ImVec2                  CursorPosPrevLine;
    ImVec2                  CursorStartPos;         // Initial position in client area with padding
    ImVec2                  CursorMaxPos;           // Used to implicitly calculate the size of our contents, always growing during the frame. Turned into window->SizeContents at the beginning of next frame
    ImVec2                  CurrentLineSize;
    float                   CurrentLineTextBaseOffset;
    ImVec2                  PrevLineSize;
    float                   PrevLineTextBaseOffset;
    int                     TreeDepth;
    ImU32                   TreeStoreMayJumpToParentOnPop; // Store a copy of !g.NavIdIsAlive for TreeDepth 0..31.. Could be turned into a ImU64 if necessary.
    ImGuiID                 LastItemId;
    ImGuiItemStatusFlags    LastItemStatusFlags;
    ImRect                  LastItemRect;           // Interaction rect
    ImRect                  LastItemDisplayRect;    // End-user display rect (only valid if LastItemStatusFlags & ImGuiItemStatusFlags_HasDisplayRect)
    ImGuiNavLayer           NavLayerCurrent;        // Current layer, 0..31 (we currently only use 0..1)
    int                     NavLayerCurrentMask;    // = (1 << NavLayerCurrent) used by ItemAdd prior to clipping.
    int                     NavLayerActiveMask;     // Which layer have been written to (result from previous frame)
    int                     NavLayerActiveMaskNext; // Which layer have been written to (buffer for current frame)
    bool                    NavHideHighlightOneFrame;
    bool                    NavHasScroll;           // Set when scrolling can be used (ScrollMax > 0.0f)
    bool                    MenuBarAppending;       // FIXME: Remove this
    ImVec2                  MenuBarOffset;          // MenuBarOffset.x is sort of equivalent of a per-layer CursorPos.x, saved/restored as we switch to the menu bar. The only situation when MenuBarOffset.y is > 0 if when (SafeAreaPadding.y > FramePadding.y), often used on TVs.
    ImVector<ImGuiWindow*>  ChildWindows;
    ImGuiStorage*           StateStorage;
    ImGuiLayoutType         LayoutType;
    ImGuiLayoutType         ParentLayoutType;       // Layout type of parent window at the time of Begin()
    int                     FocusCounterAll;        // Counter for focus/tabbing system. Start at -1 and increase as assigned via FocusableItemRegister() (FIXME-NAV: Needs redesign)
    int                     FocusCounterTab;        // (same, but only count widgets which you can Tab through)

    // We store the current settings outside of the vectors to increase memory locality (reduce cache misses). The vectors are rarely modified. Also it allows us to not heap allocate for short-lived windows which are not using those settings.
    ImGuiItemFlags          ItemFlags;              // == ItemFlagsStack.back() [empty == ImGuiItemFlags_Default]
    float                   ItemWidth;              // == ItemWidthStack.back(). 0.0: default, >0.0: width in pixels, <0.0: align xx pixels to the right of window
    float                   NextItemWidth;
    float                   TextWrapPos;            // == TextWrapPosStack.back() [empty == -1.0f]
    ImVector<ImGuiItemFlags>ItemFlagsStack;
    ImVector<float>         ItemWidthStack;
    ImVector<float>         TextWrapPosStack;
    ImVector<ImGuiGroupData>GroupStack;
    short                   StackSizesBackup[6];    // Store size of various stacks for asserting

    ImVec1                  Indent;                 // Indentation / start position from left of window (increased by TreePush/TreePop, etc.)
    ImVec1                  GroupOffset;
    ImVec1                  ColumnsOffset;          // Offset to the current column (if ColumnsCurrent > 0). FIXME: This and the above should be a stack to allow use cases like Tree->Column->Tree. Need revamp columns API.
    ImGuiColumns*           CurrentColumns;         // Current columns set

    ImGuiWindowTempData()
    {
        CursorPos = CursorPosPrevLine = CursorStartPos = CursorMaxPos = ImVec2(0.0f, 0.0f);
        CurrentLineSize = PrevLineSize = ImVec2(0.0f, 0.0f);
        CurrentLineTextBaseOffset = PrevLineTextBaseOffset = 0.0f;
        TreeDepth = 0;
        TreeStoreMayJumpToParentOnPop = 0x00;
        LastItemId = 0;
        LastItemStatusFlags = 0;
        LastItemRect = LastItemDisplayRect = ImRect();
        NavLayerActiveMask = NavLayerActiveMaskNext = 0x00;
        NavLayerCurrent = ImGuiNavLayer_Main;
        NavLayerCurrentMask = (1 << ImGuiNavLayer_Main);
        NavHideHighlightOneFrame = false;
        NavHasScroll = false;
        MenuBarAppending = false;
        MenuBarOffset = ImVec2(0.0f, 0.0f);
        StateStorage = NULL;
        LayoutType = ParentLayoutType = ImGuiLayoutType_Vertical;
        FocusCounterAll = FocusCounterTab = -1;

        ItemFlags = ImGuiItemFlags_Default_;
        ItemWidth = 0.0f;
        NextItemWidth = +FLT_MAX;
        TextWrapPos = -1.0f;
        memset(StackSizesBackup, 0, sizeof(StackSizesBackup));

        Indent = ImVec1(0.0f);
        GroupOffset = ImVec1(0.0f);
        ColumnsOffset = ImVec1(0.0f);
        CurrentColumns = NULL;
    }
};

// Storage for one window
struct IMGUI_API ImGuiWindow
{
    char*                   Name;
    ImGuiID                 ID;                                 // == ImHash(Name)
    ImGuiWindowFlags        Flags;                              // See enum ImGuiWindowFlags_
    ImVec2                  Pos;                                // Position (always rounded-up to nearest pixel)
    ImVec2                  Size;                               // Current size (==SizeFull or collapsed title bar size)
    ImVec2                  SizeFull;                           // Size when non collapsed
    ImVec2                  SizeFullAtLastBegin;                // Copy of SizeFull at the end of Begin. This is the reference value we'll use on the next frame to decide if we need scrollbars.
    ImVec2                  SizeContents;                       // Size of contents (== extents reach of the drawing cursor) from previous frame. Include decoration, window title, border, menu, etc.
    ImVec2                  SizeContentsExplicit;               // Size of contents explicitly set by the user via SetNextWindowContentSize()
    ImVec2                  WindowPadding;                      // Window padding at the time of begin.
    float                   WindowRounding;                     // Window rounding at the time of begin.
    float                   WindowBorderSize;                   // Window border size at the time of begin.
    int                     NameBufLen;                         // Size of buffer storing Name. May be larger than strlen(Name)!
    ImGuiID                 MoveId;                             // == window->GetID("#MOVE")
    ImGuiID                 ChildId;                            // ID of corresponding item in parent window (for navigation to return from child window to parent window)
    ImVec2                  Scroll;
    ImVec2                  ScrollTarget;                       // target scroll position. stored as cursor position with scrolling canceled out, so the highest point is always 0.0f. (FLT_MAX for no change)
    ImVec2                  ScrollTargetCenterRatio;            // 0.0f = scroll so that target position is at top, 0.5f = scroll so that target position is centered
    ImVec2                  ScrollbarSizes;                     // Size taken by scrollbars on each axis
    bool                    ScrollbarX, ScrollbarY;
    bool                    Active;                             // Set to true on Begin(), unless Collapsed
    bool                    WasActive;
    bool                    WriteAccessed;                      // Set to true when any widget access the current window
    bool                    Collapsed;                          // Set when collapsing window to become only title-bar
    bool                    WantCollapseToggle;
    bool                    SkipItems;                          // Set when items can safely be all clipped (e.g. window not visible or collapsed)
    bool                    Appearing;                          // Set during the frame where the window is appearing (or re-appearing)
    bool                    Hidden;                             // Do not display (== (HiddenFrames*** > 0))
    bool                    HasCloseButton;                     // Set when the window has a close button (p_open != NULL)
    signed char             ResizeBorderHeld;                   // Current border being held for resize (-1: none, otherwise 0-3)
    short                   BeginCount;                         // Number of Begin() during the current frame (generally 0 or 1, 1+ if appending via multiple Begin/End pairs)
    short                   BeginOrderWithinParent;             // Order within immediate parent window, if we are a child window. Otherwise 0.
    short                   BeginOrderWithinContext;            // Order within entire imgui context. This is mostly used for debugging submission order related issues.
    ImGuiID                 PopupId;                            // ID in the popup stack when this window is used as a popup/menu (because we use generic Name/ID for recycling)
    int                     AutoFitFramesX, AutoFitFramesY;
    bool                    AutoFitOnlyGrows;
    int                     AutoFitChildAxises;
    ImGuiDir                AutoPosLastDirection;
    int                     HiddenFramesCanSkipItems;           // Hide the window for N frames
    int                     HiddenFramesCannotSkipItems;        // Hide the window for N frames while allowing items to be submitted so we can measure their size
    ImGuiCond               SetWindowPosAllowFlags;             // store acceptable condition flags for SetNextWindowPos() use.
    ImGuiCond               SetWindowSizeAllowFlags;            // store acceptable condition flags for SetNextWindowSize() use.
    ImGuiCond               SetWindowCollapsedAllowFlags;       // store acceptable condition flags for SetNextWindowCollapsed() use.
    ImVec2                  SetWindowPosVal;                    // store window position when using a non-zero Pivot (position set needs to be processed when we know the window size)
    ImVec2                  SetWindowPosPivot;                  // store window pivot for positioning. ImVec2(0,0) when positioning from top-left corner; ImVec2(0.5f,0.5f) for centering; ImVec2(1,1) for bottom right.

    ImGuiWindowTempData     DC;                                 // Temporary per-window data, reset at the beginning of the frame. This used to be called ImGuiDrawContext, hence the "DC" variable name.
    ImVector<ImGuiID>       IDStack;                            // ID stack. ID are hashes seeded with the value at the top of the stack
    ImRect                  ClipRect;                           // Current clipping rectangle. = DrawList->clip_rect_stack.back(). Scissoring / clipping rectangle. x1, y1, x2, y2.
    ImRect                  OuterRectClipped;                   // = WindowRect just after setup in Begin(). == window->Rect() for root window.
    ImRect                  InnerMainRect, InnerClipRect;
    ImRect                  ContentsRegionRect;                 // FIXME: This is currently confusing/misleading. Maximum visible content position ~~ Pos + (SizeContentsExplicit ? SizeContentsExplicit : Size - ScrollbarSizes) - CursorStartPos, per axis
    int                     LastFrameActive;                    // Last frame number the window was Active.
    float                   ItemWidthDefault;
    ImGuiMenuColumns        MenuColumns;                        // Simplified columns storage for menu items
    ImGuiStorage            StateStorage;
    ImVector<ImGuiColumns>  ColumnsStorage;
    float                   FontWindowScale;                    // User scale multiplier per-window
    int                     SettingsIdx;                        // Index into SettingsWindow[] (indices are always valid as we only grow the array from the back)

    ImDrawList*             DrawList;                           // == &DrawListInst (for backward compatibility reason with code using imgui_internal.h we keep this a pointer)
    ImDrawList              DrawListInst;
    ImGuiWindow*            ParentWindow;                       // If we are a child _or_ popup window, this is pointing to our parent. Otherwise NULL.
    ImGuiWindow*            RootWindow;                         // Point to ourself or first ancestor that is not a child window.
    ImGuiWindow*            RootWindowForTitleBarHighlight;     // Point to ourself or first ancestor which will display TitleBgActive color when this window is active.
    ImGuiWindow*            RootWindowForNav;                   // Point to ourself or first ancestor which doesn't have the NavFlattened flag.

    ImGuiWindow*            NavLastChildNavWindow;              // When going to the menu bar, we remember the child window we came from. (This could probably be made implicit if we kept g.Windows sorted by last focused including child window.)
    ImGuiID                 NavLastIds[ImGuiNavLayer_COUNT];    // Last known NavId for this window, per layer (0/1)
    ImRect                  NavRectRel[ImGuiNavLayer_COUNT];    // Reference rectangle, in window relative space

public:
    ImGuiWindow(ImGuiContext* context, const char* name);
    ~ImGuiWindow();

    ImGuiID     GetID(const char* str, const char* str_end = NULL);
    ImGuiID     GetID(const void* ptr);
    ImGuiID     GetIDNoKeepAlive(const char* str, const char* str_end = NULL);
    ImGuiID     GetIDNoKeepAlive(const void* ptr);
    ImGuiID     GetIDFromRectangle(const ImRect& r_abs);

    // We don't use g.FontSize because the window may be != g.CurrentWidow.
    ImRect      Rect() const                            { return ImRect(Pos.x, Pos.y, Pos.x+Size.x, Pos.y+Size.y); }
    float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }
    float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }
    ImRect      TitleBarRect() const                    { return ImRect(Pos, ImVec2(Pos.x + SizeFull.x, Pos.y + TitleBarHeight())); }
    float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? DC.MenuBarOffset.y + CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }
    ImRect      MenuBarRect() const                     { float y1 = Pos.y + TitleBarHeight(); return ImRect(Pos.x, y1, Pos.x + SizeFull.x, y1 + MenuBarHeight()); }
};

// Backup and restore just enough data to be able to use IsItemHovered() on item A after another B in the same window has overwritten the data.
struct ImGuiItemHoveredDataBackup
{
    ImGuiID                 LastItemId;
    ImGuiItemStatusFlags    LastItemStatusFlags;
    ImRect                  LastItemRect;
    ImRect                  LastItemDisplayRect;

    ImGuiItemHoveredDataBackup() { Backup(); }
    void Backup()           { ImGuiWindow* window = GImGui->CurrentWindow; LastItemId = window->DC.LastItemId; LastItemStatusFlags = window->DC.LastItemStatusFlags; LastItemRect = window->DC.LastItemRect; LastItemDisplayRect = window->DC.LastItemDisplayRect; }
    void Restore() const    { ImGuiWindow* window = GImGui->CurrentWindow; window->DC.LastItemId = LastItemId; window->DC.LastItemStatusFlags = LastItemStatusFlags; window->DC.LastItemRect = LastItemRect; window->DC.LastItemDisplayRect = LastItemDisplayRect; }
};

//-----------------------------------------------------------------------------
// Tab bar, tab item
//-----------------------------------------------------------------------------

enum ImGuiTabBarFlagsPrivate_
{
    ImGuiTabBarFlags_DockNode                   = 1 << 20,  // Part of a dock node [we don't use this in the master branch but it facilitate branch syncing to keep this around]
    ImGuiTabBarFlags_IsFocused                  = 1 << 21,
    ImGuiTabBarFlags_SaveSettings               = 1 << 22   // FIXME: Settings are handled by the docking system, this only request the tab bar to mark settings dirty when reordering tabs
};

enum ImGuiTabItemFlagsPrivate_
{
    ImGuiTabItemFlags_NoCloseButton             = 1 << 20   // Store whether p_open is set or not, which we need to recompute WidthContents during layout.
};

// Storage for one active tab item (sizeof() 26~32 bytes)
struct ImGuiTabItem
{
    ImGuiID             ID;
    ImGuiTabItemFlags   Flags;
    int                 LastFrameVisible;
    int                 LastFrameSelected;      // This allows us to infer an ordered list of the last activated tabs with little maintenance
    int                 NameOffset;             // When Window==NULL, offset to name within parent ImGuiTabBar::TabsNames
    float               Offset;                 // Position relative to beginning of tab
    float               Width;                  // Width currently displayed
    float               WidthContents;          // Width of actual contents, stored during BeginTabItem() call

    ImGuiTabItem()      { ID = Flags = 0; LastFrameVisible = LastFrameSelected = -1; NameOffset = -1; Offset = Width = WidthContents = 0.0f; }
};

// Storage for a tab bar (sizeof() 92~96 bytes)
struct ImGuiTabBar
{
    ImVector<ImGuiTabItem> Tabs;
    ImGuiID             ID;                     // Zero for tab-bars used by docking
    ImGuiID             SelectedTabId;          // Selected tab
    ImGuiID             NextSelectedTabId;
    ImGuiID             VisibleTabId;           // Can occasionally be != SelectedTabId (e.g. when previewing contents for CTRL+TAB preview)
    int                 CurrFrameVisible;
    int                 PrevFrameVisible;
    ImRect              BarRect;
    float               ContentsHeight;
    float               OffsetMax;              // Distance from BarRect.Min.x, locked during layout
    float               OffsetNextTab;          // Distance from BarRect.Min.x, incremented with each BeginTabItem() call, not used if ImGuiTabBarFlags_Reorderable if set.
    float               ScrollingAnim;
    float               ScrollingTarget;
    float               ScrollingTargetDistToVisibility;
    float               ScrollingSpeed;
    ImGuiTabBarFlags    Flags;
    ImGuiID             ReorderRequestTabId;
    int                 ReorderRequestDir;
    bool                WantLayout;
    bool                VisibleTabWasSubmitted;
    short               LastTabItemIdx;         // For BeginTabItem()/EndTabItem()
    ImVec2              FramePadding;           // style.FramePadding locked at the time of BeginTabBar()
    ImGuiTextBuffer     TabsNames;              // For non-docking tab bar we re-append names in a contiguous buffer.

    ImGuiTabBar();
    int                 GetTabOrder(const ImGuiTabItem* tab) const  { return Tabs.index_from_ptr(tab); }
    const char*         GetTabName(const ImGuiTabItem* tab) const
    {
        IM_ASSERT(tab->NameOffset != -1 && tab->NameOffset < TabsNames.Buf.Size);
        return TabsNames.Buf.Data + tab->NameOffset;
    }
};

//-----------------------------------------------------------------------------
// Internal API
// No guarantee of forward compatibility here.
//-----------------------------------------------------------------------------

namespace ImGui
{
    // We should always have a CurrentWindow in the stack (there is an implicit "Debug" window)
    // If this ever crash because g.CurrentWindow is NULL it means that either
    // - ImGui::NewFrame() has never been called, which is illegal.
    // - You are calling ImGui functions after ImGui::EndFrame()/ImGui::Render() and before the next ImGui::NewFrame(), which is also illegal.
    inline    ImGuiWindow*  GetCurrentWindowRead()      { ImGuiContext& g = *GImGui; return g.CurrentWindow; }
    inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }
    IMGUI_API ImGuiWindow*  FindWindowByID(ImGuiID id);
    IMGUI_API ImGuiWindow*  FindWindowByName(const char* name);
    IMGUI_API void          FocusWindow(ImGuiWindow* window);
    IMGUI_API void          FocusTopMostWindowUnderOne(ImGuiWindow* under_this_window, ImGuiWindow* ignore_window);
    IMGUI_API void          BringWindowToFocusFront(ImGuiWindow* window);
    IMGUI_API void          BringWindowToDisplayFront(ImGuiWindow* window);
    IMGUI_API void          BringWindowToDisplayBack(ImGuiWindow* window);
    IMGUI_API void          UpdateWindowParentAndRootLinks(ImGuiWindow* window, ImGuiWindowFlags flags, ImGuiWindow* parent_window);
    IMGUI_API ImVec2        CalcWindowExpectedSize(ImGuiWindow* window);
    IMGUI_API bool          IsWindowChildOf(ImGuiWindow* window, ImGuiWindow* potential_parent);
    IMGUI_API bool          IsWindowNavFocusable(ImGuiWindow* window);
    IMGUI_API void          SetWindowScrollX(ImGuiWindow* window, float new_scroll_x);
    IMGUI_API void          SetWindowScrollY(ImGuiWindow* window, float new_scroll_y);
    IMGUI_API float         GetWindowScrollMaxX(ImGuiWindow* window);
    IMGUI_API float         GetWindowScrollMaxY(ImGuiWindow* window);
    IMGUI_API ImRect        GetWindowAllowedExtentRect(ImGuiWindow* window);
    IMGUI_API void          SetWindowPos(ImGuiWindow* window, const ImVec2& pos, ImGuiCond cond);
    IMGUI_API void          SetWindowSize(ImGuiWindow* window, const ImVec2& size, ImGuiCond cond);
    IMGUI_API void          SetWindowCollapsed(ImGuiWindow* window, bool collapsed, ImGuiCond cond);

    IMGUI_API void          SetCurrentFont(ImFont* font);
    inline ImFont*          GetDefaultFont() { ImGuiContext& g = *GImGui; return g.IO.FontDefault ? g.IO.FontDefault : g.IO.Fonts->Fonts[0]; }

    // Init
    IMGUI_API void          Initialize(ImGuiContext* context);
    IMGUI_API void          Shutdown(ImGuiContext* context);    // Since 1.60 this is a _private_ function. You can call DestroyContext() to destroy the context created by CreateContext().

    // NewFrame
    IMGUI_API void          UpdateHoveredWindowAndCaptureFlags();
    IMGUI_API void          StartMouseMovingWindow(ImGuiWindow* window);
    IMGUI_API void          UpdateMouseMovingWindowNewFrame();
    IMGUI_API void          UpdateMouseMovingWindowEndFrame();

    // Settings
    IMGUI_API void                  MarkIniSettingsDirty();
    IMGUI_API void                  MarkIniSettingsDirty(ImGuiWindow* window);
    IMGUI_API ImGuiWindowSettings*  CreateNewWindowSettings(const char* name);
    IMGUI_API ImGuiWindowSettings*  FindWindowSettings(ImGuiID id);
    IMGUI_API ImGuiWindowSettings*  FindOrCreateWindowSettings(const char* name);
    IMGUI_API ImGuiSettingsHandler* FindSettingsHandler(const char* type_name);

    // Basic Accessors
    inline ImGuiID          GetItemID()     { ImGuiContext& g = *GImGui; return g.CurrentWindow->DC.LastItemId; }
    inline ImGuiID          GetActiveID()   { ImGuiContext& g = *GImGui; return g.ActiveId; }
    inline ImGuiID          GetFocusID()    { ImGuiContext& g = *GImGui; return g.NavId; }
    IMGUI_API void          SetActiveID(ImGuiID id, ImGuiWindow* window);
    IMGUI_API void          SetFocusID(ImGuiID id, ImGuiWindow* window);
    IMGUI_API void          ClearActiveID();
    IMGUI_API ImGuiID       GetHoveredID();
    IMGUI_API void          SetHoveredID(ImGuiID id);
    IMGUI_API void          KeepAliveID(ImGuiID id);
    IMGUI_API void          MarkItemEdited(ImGuiID id);
    IMGUI_API void          PushOverrideID(ImGuiID id);

    // Basic Helpers for widget code
    IMGUI_API void          ItemSize(const ImVec2& size, float text_offset_y = 0.0f);
    IMGUI_API void          ItemSize(const ImRect& bb, float text_offset_y = 0.0f);
    IMGUI_API bool          ItemAdd(const ImRect& bb, ImGuiID id, const ImRect* nav_bb = NULL);
    IMGUI_API bool          ItemHoverable(const ImRect& bb, ImGuiID id);
    IMGUI_API bool          IsClippedEx(const ImRect& bb, ImGuiID id, bool clip_even_when_logged);
    IMGUI_API bool          FocusableItemRegister(ImGuiWindow* window, ImGuiID id);   // Return true if focus is requested
    IMGUI_API void          FocusableItemUnregister(ImGuiWindow* window);
    IMGUI_API float         GetNextItemWidth();
    IMGUI_API ImVec2        CalcItemSize(ImVec2 size, float default_w, float default_h);
    IMGUI_API float         CalcWrapWidthForPos(const ImVec2& pos, float wrap_pos_x);
    IMGUI_API void          PushMultiItemsWidths(int components, float width_full);
    IMGUI_API void          PushItemFlag(ImGuiItemFlags option, bool enabled);
    IMGUI_API void          PopItemFlag();
    IMGUI_API bool          IsItemToggledSelection();                                           // was the last item selection toggled? (after Selectable(), TreeNode() etc. We only returns toggle _event_ in order to handle clipping correctly)
    IMGUI_API ImVec2        GetWorkRectMax();

    // Logging/Capture
    IMGUI_API void          LogBegin(ImGuiLogType type, int auto_open_depth);   // -> BeginCapture() when we design v2 api, for now stay under the radar by using the old name.
    IMGUI_API void          LogToBuffer(int auto_open_depth = -1);              // Start logging/capturing to internal buffer

    // Popups, Modals, Tooltips
    IMGUI_API void          OpenPopupEx(ImGuiID id);
    IMGUI_API void          ClosePopupToLevel(int remaining, bool restore_focus_to_window_under_popup);
    IMGUI_API void          ClosePopupsOverWindow(ImGuiWindow* ref_window, bool restore_focus_to_window_under_popup);
    IMGUI_API bool          IsPopupOpen(ImGuiID id); // Test for id within current popup stack level (currently begin-ed into); this doesn't scan the whole popup stack!
    IMGUI_API bool          BeginPopupEx(ImGuiID id, ImGuiWindowFlags extra_flags);
    IMGUI_API void          BeginTooltipEx(ImGuiWindowFlags extra_flags, bool override_previous_tooltip = true);
    IMGUI_API ImGuiWindow*  GetFrontMostPopupModal();
    IMGUI_API ImVec2        FindBestWindowPosForPopup(ImGuiWindow* window);
    IMGUI_API ImVec2        FindBestWindowPosForPopupEx(const ImVec2& ref_pos, const ImVec2& size, ImGuiDir* last_dir, const ImRect& r_outer, const ImRect& r_avoid, ImGuiPopupPositionPolicy policy = ImGuiPopupPositionPolicy_Default);

    // Navigation
    IMGUI_API void          NavInitWindow(ImGuiWindow* window, bool force_reinit);
    IMGUI_API bool          NavMoveRequestButNoResultYet();
    IMGUI_API void          NavMoveRequestCancel();
    IMGUI_API void          NavMoveRequestForward(ImGuiDir move_dir, ImGuiDir clip_dir, const ImRect& bb_rel, ImGuiNavMoveFlags move_flags);
    IMGUI_API void          NavMoveRequestTryWrapping(ImGuiWindow* window, ImGuiNavMoveFlags move_flags);
    IMGUI_API float         GetNavInputAmount(ImGuiNavInput n, ImGuiInputReadMode mode);
    IMGUI_API ImVec2        GetNavInputAmount2d(ImGuiNavDirSourceFlags dir_sources, ImGuiInputReadMode mode, float slow_factor = 0.0f, float fast_factor = 0.0f);
    IMGUI_API int           CalcTypematicPressedRepeatAmount(float t, float t_prev, float repeat_delay, float repeat_rate);
    IMGUI_API void          ActivateItem(ImGuiID id);   // Remotely activate a button, checkbox, tree node etc. given its unique ID. activation is queued and processed on the next frame when the item is encountered again.
    IMGUI_API void          SetNavID(ImGuiID id, int nav_layer);
    IMGUI_API void          SetNavIDWithRectRel(ImGuiID id, int nav_layer, const ImRect& rect_rel);

    // Inputs
    inline bool             IsKeyPressedMap(ImGuiKey key, bool repeat = true)           { const int key_index = GImGui->IO.KeyMap[key]; return (key_index >= 0) ? IsKeyPressed(key_index, repeat) : false; }
    inline bool             IsNavInputDown(ImGuiNavInput n)                             { return GImGui->IO.NavInputs[n] > 0.0f; }
    inline bool             IsNavInputPressed(ImGuiNavInput n, ImGuiInputReadMode mode) { return GetNavInputAmount(n, mode) > 0.0f; }
    inline bool             IsNavInputPressedAnyOfTwo(ImGuiNavInput n1, ImGuiNavInput n2, ImGuiInputReadMode mode) { return (GetNavInputAmount(n1, mode) + GetNavInputAmount(n2, mode)) > 0.0f; }

    // Drag and Drop
    IMGUI_API bool          BeginDragDropTargetCustom(const ImRect& bb, ImGuiID id);
    IMGUI_API void          ClearDragDrop();
    IMGUI_API bool          IsDragDropPayloadBeingAccepted();

    // New Columns API (FIXME-WIP)
    IMGUI_API void          BeginColumns(const char* str_id, int count, ImGuiColumnsFlags flags = 0); // setup number of columns. use an identifier to distinguish multiple column sets. close with EndColumns().
    IMGUI_API void          EndColumns();                                                             // close columns
    IMGUI_API void          PushColumnClipRect(int column_index = -1);
    IMGUI_API ImGuiID       GetColumnsID(const char* str_id, int count);
    IMGUI_API ImGuiColumns* FindOrCreateColumns(ImGuiWindow* window, ImGuiID id);

    // Tab Bars
    IMGUI_API bool          BeginTabBarEx(ImGuiTabBar* tab_bar, const ImRect& bb, ImGuiTabBarFlags flags);
    IMGUI_API ImGuiTabItem* TabBarFindTabByID(ImGuiTabBar* tab_bar, ImGuiID tab_id);
    IMGUI_API void          TabBarRemoveTab(ImGuiTabBar* tab_bar, ImGuiID tab_id);
    IMGUI_API void          TabBarCloseTab(ImGuiTabBar* tab_bar, ImGuiTabItem* tab);
    IMGUI_API void          TabBarQueueChangeTabOrder(ImGuiTabBar* tab_bar, const ImGuiTabItem* tab, int dir);
    IMGUI_API bool          TabItemEx(ImGuiTabBar* tab_bar, const char* label, bool* p_open, ImGuiTabItemFlags flags);
    IMGUI_API ImVec2        TabItemCalcSize(const char* label, bool has_close_button);
    IMGUI_API void          TabItemBackground(ImDrawList* draw_list, const ImRect& bb, ImGuiTabItemFlags flags, ImU32 col);
    IMGUI_API bool          TabItemLabelAndCloseButton(ImDrawList* draw_list, const ImRect& bb, ImGuiTabItemFlags flags, ImVec2 frame_padding, const char* label, ImGuiID tab_id, ImGuiID close_button_id);

    // Render helpers
    // AVOID USING OUTSIDE OF IMGUI.CPP! NOT FOR PUBLIC CONSUMPTION. THOSE FUNCTIONS ARE A MESS. THEIR SIGNATURE AND BEHAVIOR WILL CHANGE, THEY NEED TO BE REFACTORED INTO SOMETHING DECENT.
    // NB: All position are in absolute pixels coordinates (we are never using window coordinates internally)
    IMGUI_API void          RenderText(ImVec2 pos, const char* text, const char* text_end = NULL, bool hide_text_after_hash = true);
    IMGUI_API void          RenderTextWrapped(ImVec2 pos, const char* text, const char* text_end, float wrap_width);
    IMGUI_API void          RenderTextClipped(const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align = ImVec2(0,0), const ImRect* clip_rect = NULL);
    IMGUI_API void          RenderTextClippedEx(ImDrawList* draw_list, const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align = ImVec2(0, 0), const ImRect* clip_rect = NULL);
    IMGUI_API void          RenderFrame(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border = true, float rounding = 0.0f);
    IMGUI_API void          RenderFrameBorder(ImVec2 p_min, ImVec2 p_max, float rounding = 0.0f);
    IMGUI_API void          RenderColorRectWithAlphaCheckerboard(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, float grid_step, ImVec2 grid_off, float rounding = 0.0f, int rounding_corners_flags = ~0);
    IMGUI_API void          RenderArrow(ImVec2 pos, ImGuiDir dir, float scale = 1.0f);
    IMGUI_API void          RenderBullet(ImVec2 pos);
    IMGUI_API void          RenderCheckMark(ImVec2 pos, ImU32 col, float sz);
    IMGUI_API void          RenderNavHighlight(const ImRect& bb, ImGuiID id, ImGuiNavHighlightFlags flags = ImGuiNavHighlightFlags_TypeDefault); // Navigation highlight
    IMGUI_API const char*   FindRenderedTextEnd(const char* text, const char* text_end = NULL); // Find the optional ## from which we stop displaying text.
    IMGUI_API void          LogRenderedText(const ImVec2* ref_pos, const char* text, const char* text_end = NULL);

    // Render helpers (those functions don't access any ImGui state!)
    IMGUI_API void          RenderMouseCursor(ImDrawList* draw_list, ImVec2 pos, float scale, ImGuiMouseCursor mouse_cursor = ImGuiMouseCursor_Arrow);
    IMGUI_API void          RenderArrowPointingAt(ImDrawList* draw_list, ImVec2 pos, ImVec2 half_sz, ImGuiDir direction, ImU32 col);
    IMGUI_API void          RenderRectFilledRangeH(ImDrawList* draw_list, const ImRect& rect, ImU32 col, float x_start_norm, float x_end_norm, float rounding);
    IMGUI_API void          RenderPixelEllipsis(ImDrawList* draw_list, ImVec2 pos, int count, ImU32 col);

    // Widgets
    IMGUI_API void          TextEx(const char* text, const char* text_end = NULL, ImGuiTextFlags flags = 0);
    IMGUI_API bool          ButtonEx(const char* label, const ImVec2& size_arg = ImVec2(0,0), ImGuiButtonFlags flags = 0);
    IMGUI_API bool          CloseButton(ImGuiID id, const ImVec2& pos, float radius);
    IMGUI_API bool          CollapseButton(ImGuiID id, const ImVec2& pos);
    IMGUI_API bool          ArrowButtonEx(const char* str_id, ImGuiDir dir, ImVec2 size_arg, ImGuiButtonFlags flags);
    IMGUI_API void          Scrollbar(ImGuiAxis axis);
    IMGUI_API ImGuiID       GetScrollbarID(ImGuiWindow* window, ImGuiAxis axis);
    IMGUI_API void          VerticalSeparator();        // Vertical separator, for menu bars (use current line height). Not exposed because it is misleading and it doesn't have an effect on regular layout.

    // Widgets low-level behaviors
    IMGUI_API bool          ButtonBehavior(const ImRect& bb, ImGuiID id, bool* out_hovered, bool* out_held, ImGuiButtonFlags flags = 0);
    IMGUI_API bool          DragBehavior(ImGuiID id, ImGuiDataType data_type, void* v, float v_speed, const void* v_min, const void* v_max, const char* format, float power, ImGuiDragFlags flags);
    IMGUI_API bool          SliderBehavior(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, void* v, const void* v_min, const void* v_max, const char* format, float power, ImGuiSliderFlags flags, ImRect* out_grab_bb);
    IMGUI_API bool          SplitterBehavior(const ImRect& bb, ImGuiID id, ImGuiAxis axis, float* size1, float* size2, float min_size1, float min_size2, float hover_extend = 0.0f, float hover_visibility_delay = 0.0f);
    IMGUI_API bool          TreeNodeBehavior(ImGuiID id, ImGuiTreeNodeFlags flags, const char* label, const char* label_end = NULL);
    IMGUI_API bool          TreeNodeBehaviorIsOpen(ImGuiID id, ImGuiTreeNodeFlags flags = 0);                     // Consume previous SetNextTreeNodeOpened() data, if any. May return true when logging
    IMGUI_API void          TreePushOverrideID(ImGuiID id);

    // Template functions are instantiated in imgui_widgets.cpp for a finite number of types.
    // To use them externally (for custom widget) you may need an "extern template" statement in your code in order to link to existing instances and silence Clang warnings (see #2036).
    // e.g. " extern template IMGUI_API float RoundScalarWithFormatT<float, float>(const char* format, ImGuiDataType data_type, float v); "
    template<typename T, typename SIGNED_T, typename FLOAT_T>   IMGUI_API bool  DragBehaviorT(ImGuiDataType data_type, T* v, float v_speed, T v_min, T v_max, const char* format, float power, ImGuiDragFlags flags);
    template<typename T, typename SIGNED_T, typename FLOAT_T>   IMGUI_API bool  SliderBehaviorT(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, T* v, T v_min, T v_max, const char* format, float power, ImGuiSliderFlags flags, ImRect* out_grab_bb);
    template<typename T, typename FLOAT_T>                      IMGUI_API float SliderCalcRatioFromValueT(ImGuiDataType data_type, T v, T v_min, T v_max, float power, float linear_zero_pos);
    template<typename T, typename SIGNED_T>                     IMGUI_API T     RoundScalarWithFormatT(const char* format, ImGuiDataType data_type, T v);

    // Data type helpers
    IMGUI_API const ImGuiDataTypeInfo*  DataTypeGetInfo(ImGuiDataType data_type);
    IMGUI_API int           DataTypeFormatString(char* buf, int buf_size, ImGuiDataType data_type, const void* data_ptr, const char* format);
    IMGUI_API void          DataTypeApplyOp(ImGuiDataType data_type, int op, void* output, void* arg_1, const void* arg_2);
    IMGUI_API bool          DataTypeApplyOpFromText(const char* buf, const char* initial_value_buf, ImGuiDataType data_type, void* data_ptr, const char* format);

    // InputText
    IMGUI_API bool          InputTextEx(const char* label, const char* hint, char* buf, int buf_size, const ImVec2& size_arg, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback = NULL, void* user_data = NULL);
    IMGUI_API bool          TempInputTextScalar(const ImRect& bb, ImGuiID id, const char* label, ImGuiDataType data_type, void* data_ptr, const char* format);
    inline bool             TempInputTextIsActive(ImGuiID id) { ImGuiContext& g = *GImGui; return (g.ActiveId == id && g.TempInputTextId == id); }

    // Color
    IMGUI_API void          ColorTooltip(const char* text, const float* col, ImGuiColorEditFlags flags);
    IMGUI_API void          ColorEditOptionsPopup(const float* col, ImGuiColorEditFlags flags);
    IMGUI_API void          ColorPickerOptionsPopup(const float* ref_col, ImGuiColorEditFlags flags);

    // Plot
    IMGUI_API void          PlotEx(ImGuiPlotType plot_type, const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 frame_size);

    // Shade functions (write over already created vertices)
    IMGUI_API void          ShadeVertsLinearColorGradientKeepAlpha(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, ImVec2 gradient_p0, ImVec2 gradient_p1, ImU32 col0, ImU32 col1);
    IMGUI_API void          ShadeVertsLinearUV(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, bool clamp);

} // namespace ImGui

// ImFontAtlas internals
IMGUI_API bool              ImFontAtlasBuildWithStbTruetype(ImFontAtlas* atlas);
IMGUI_API void              ImFontAtlasBuildRegisterDefaultCustomRects(ImFontAtlas* atlas);
IMGUI_API void              ImFontAtlasBuildSetupFont(ImFontAtlas* atlas, ImFont* font, ImFontConfig* font_config, float ascent, float descent);
IMGUI_API void              ImFontAtlasBuildPackCustomRects(ImFontAtlas* atlas, void* stbrp_context_opaque);
IMGUI_API void              ImFontAtlasBuildFinish(ImFontAtlas* atlas);
IMGUI_API void              ImFontAtlasBuildMultiplyCalcLookupTable(unsigned char out_table[256], float in_multiply_factor);
IMGUI_API void              ImFontAtlasBuildMultiplyRectAlpha8(const unsigned char table[256], unsigned char* pixels, int x, int y, int w, int h, int stride);

// Test engine hooks (imgui-test)
//#define IMGUI_ENABLE_TEST_ENGINE
#ifdef IMGUI_ENABLE_TEST_ENGINE
extern void                 ImGuiTestEngineHook_PreNewFrame(ImGuiContext* ctx);
extern void                 ImGuiTestEngineHook_PostNewFrame(ImGuiContext* ctx);
extern void                 ImGuiTestEngineHook_ItemAdd(ImGuiContext* ctx, const ImRect& bb, ImGuiID id);
extern void                 ImGuiTestEngineHook_ItemInfo(ImGuiContext* ctx, ImGuiID id, const char* label, ImGuiItemStatusFlags flags);
#define IMGUI_TEST_ENGINE_ITEM_ADD(_BB, _ID)                ImGuiTestEngineHook_ItemAdd(&g, _BB, _ID)               // Register status flags
#define IMGUI_TEST_ENGINE_ITEM_INFO(_ID, _LABEL, _FLAGS)  ImGuiTestEngineHook_ItemInfo(&g, _ID, _LABEL, _FLAGS)   // Register status flags
#else
#define IMGUI_TEST_ENGINE_ITEM_ADD(_BB, _ID)                do { } while (0)
#define IMGUI_TEST_ENGINE_ITEM_INFO(_ID, _LABEL, _FLAGS)  do { } while (0)
#endif

#ifdef __clang__
#pragma clang diagnostic pop
#endif

#ifdef _MSC_VER
#pragma warning (pop)
#endif

```

`UnrealFinderTool/ImGUI/imgui_widgets.cpp`:

```cpp
// dear imgui, v1.70
// (widgets code)

/*

Index of this file:

// [SECTION] Forward Declarations
// [SECTION] Widgets: Text, etc.
// [SECTION] Widgets: Main (Button, Image, Checkbox, RadioButton, ProgressBar, Bullet, etc.)
// [SECTION] Widgets: Low-level Layout helpers (Spacing, Dummy, NewLine, Separator, etc.)
// [SECTION] Widgets: ComboBox
// [SECTION] Data Type and Data Formatting Helpers
// [SECTION] Widgets: DragScalar, DragFloat, DragInt, etc.
// [SECTION] Widgets: SliderScalar, SliderFloat, SliderInt, etc.
// [SECTION] Widgets: InputScalar, InputFloat, InputInt, etc.
// [SECTION] Widgets: InputText, InputTextMultiline
// [SECTION] Widgets: ColorEdit, ColorPicker, ColorButton, etc.
// [SECTION] Widgets: TreeNode, CollapsingHeader, etc.
// [SECTION] Widgets: Selectable
// [SECTION] Widgets: ListBox
// [SECTION] Widgets: PlotLines, PlotHistogram
// [SECTION] Widgets: Value helpers
// [SECTION] Widgets: MenuItem, BeginMenu, EndMenu, etc.
// [SECTION] Widgets: BeginTabBar, EndTabBar, etc.
// [SECTION] Widgets: BeginTabItem, EndTabItem, etc.

*/

#include "pch.h"
#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS
#endif

#include "imgui.h"
#ifndef IMGUI_DEFINE_MATH_OPERATORS
#define IMGUI_DEFINE_MATH_OPERATORS
#endif
#include "imgui_internal.h"

#include <ctype.h>      // toupper
#if defined(_MSC_VER) && _MSC_VER <= 1500 // MSVC 2008 or earlier
#include <stddef.h>     // intptr_t
#else
#include <stdint.h>     // intptr_t
#endif

// Visual Studio warnings
#ifdef _MSC_VER
#pragma warning (disable: 4127) // condition expression is constant
#pragma warning (disable: 4996) // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen
#endif

// Clang/GCC warnings with -Weverything
#ifdef __clang__
#pragma clang diagnostic ignored "-Wold-style-cast"         // warning : use of old-style cast                              // yes, they are more terse.
#pragma clang diagnostic ignored "-Wfloat-equal"            // warning : comparing floating point with == or != is unsafe   // storing and comparing against same constants (typically 0.0f) is ok.
#pragma clang diagnostic ignored "-Wformat-nonliteral"      // warning : format string is not a string literal              // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.
#pragma clang diagnostic ignored "-Wsign-conversion"        // warning : implicit conversion changes signedness             //
#if __has_warning("-Wzero-as-null-pointer-constant")
#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"  // warning : zero as null pointer constant              // some standard header variations use #define NULL 0
#endif
#if __has_warning("-Wdouble-promotion")
#pragma clang diagnostic ignored "-Wdouble-promotion"       // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.
#endif
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wformat-nonliteral"        // warning: format not a string literal, format string not checked
#if __GNUC__ >= 8
#pragma GCC diagnostic ignored "-Wclass-memaccess"          // warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead
#endif
#endif

//-------------------------------------------------------------------------
// Data
//-------------------------------------------------------------------------

// Those MIN/MAX values are not define because we need to point to them
static const signed char    IM_S8_MIN  = -128;
static const signed char    IM_S8_MAX  = 127;
static const unsigned char  IM_U8_MIN  = 0;
static const unsigned char  IM_U8_MAX  = 0xFF;
static const signed short   IM_S16_MIN = -32768;
static const signed short   IM_S16_MAX = 32767;
static const unsigned short IM_U16_MIN = 0;
static const unsigned short IM_U16_MAX = 0xFFFF;
static const ImS32          IM_S32_MIN = INT_MIN;    // (-2147483647 - 1), (0x80000000);
static const ImS32          IM_S32_MAX = INT_MAX;    // (2147483647), (0x7FFFFFFF)
static const ImU32          IM_U32_MIN = 0;
static const ImU32          IM_U32_MAX = UINT_MAX;   // (0xFFFFFFFF)
#ifdef LLONG_MIN
static const ImS64          IM_S64_MIN = LLONG_MIN;  // (-9223372036854775807ll - 1ll);
static const ImS64          IM_S64_MAX = LLONG_MAX;  // (9223372036854775807ll);
#else
static const ImS64          IM_S64_MIN = -9223372036854775807LL - 1;
static const ImS64          IM_S64_MAX = 9223372036854775807LL;
#endif
static const ImU64          IM_U64_MIN = 0;
#ifdef ULLONG_MAX
static const ImU64          IM_U64_MAX = ULLONG_MAX; // (0xFFFFFFFFFFFFFFFFull);
#else
static const ImU64          IM_U64_MAX = (2ULL * 9223372036854775807LL + 1);
#endif

//-------------------------------------------------------------------------
// [SECTION] Forward Declarations
//-------------------------------------------------------------------------

// For InputTextEx()
static bool             InputTextFilterCharacter(unsigned int* p_char, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data);
static int              InputTextCalcTextLenAndLineCount(const char* text_begin, const char** out_text_end);
static ImVec2           InputTextCalcTextSizeW(const ImWchar* text_begin, const ImWchar* text_end, const ImWchar** remaining = NULL, ImVec2* out_offset = NULL, bool stop_on_new_line = false);

//-------------------------------------------------------------------------
// [SECTION] Widgets: Text, etc.
//-------------------------------------------------------------------------
// - TextUnformatted()
// - Text()
// - TextV()
// - TextColored()
// - TextColoredV()
// - TextDisabled()
// - TextDisabledV()
// - TextWrapped()
// - TextWrappedV()
// - LabelText()
// - LabelTextV()
// - BulletText()
// - BulletTextV()
//-------------------------------------------------------------------------

void ImGui::TextEx(const char* text, const char* text_end, ImGuiTextFlags flags)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImGuiContext& g = *GImGui;
    IM_ASSERT(text != NULL);
    const char* text_begin = text;
    if (text_end == NULL)
        text_end = text + strlen(text); // FIXME-OPT

    const ImVec2 text_pos(window->DC.CursorPos.x, window->DC.CursorPos.y + window->DC.CurrentLineTextBaseOffset);
    const float wrap_pos_x = window->DC.TextWrapPos;
    const bool wrap_enabled = (wrap_pos_x >= 0.0f);
    if (text_end - text > 2000 && !wrap_enabled)
    {
        // Long text!
        // Perform manual coarse clipping to optimize for long multi-line text
        // - From this point we will only compute the width of lines that are visible. Optimization only available when word-wrapping is disabled.
        // - We also don't vertically center the text within the line full height, which is unlikely to matter because we are likely the biggest and only item on the line.
        // - We use memchr(), pay attention that well optimized versions of those str/mem functions are much faster than a casually written loop.
        const char* line = text;
        const float line_height = GetTextLineHeight();
        ImVec2 text_size(0,0);

        // Lines to skip (can't skip when logging text)
        ImVec2 pos = text_pos;
        if (!g.LogEnabled)
        {
            int lines_skippable = (int)((window->ClipRect.Min.y - text_pos.y) / line_height);
            if (lines_skippable > 0)
            {
                int lines_skipped = 0;
                while (line < text_end && lines_skipped < lines_skippable)
                {
                    const char* line_end = (const char*)memchr(line, '\n', text_end - line);
                    if (!line_end)
                        line_end = text_end;
                    if ((flags & ImGuiTextFlags_NoWidthForLargeClippedText) == 0)
                        text_size.x = ImMax(text_size.x, CalcTextSize(line, line_end).x);
                    line = line_end + 1;
                    lines_skipped++;
                }
                pos.y += lines_skipped * line_height;
            }
        }

        // Lines to render
        if (line < text_end)
        {
            ImRect line_rect(pos, pos + ImVec2(FLT_MAX, line_height));
            while (line < text_end)
            {
                if (IsClippedEx(line_rect, 0, false))
                    break;

                const char* line_end = (const char*)memchr(line, '\n', text_end - line);
                if (!line_end)
                    line_end = text_end;
                text_size.x = ImMax(text_size.x, CalcTextSize(line, line_end).x);
                RenderText(pos, line, line_end, false);
                line = line_end + 1;
                line_rect.Min.y += line_height;
                line_rect.Max.y += line_height;
                pos.y += line_height;
            }

            // Count remaining lines
            int lines_skipped = 0;
            while (line < text_end)
            {
                const char* line_end = (const char*)memchr(line, '\n', text_end - line);
                if (!line_end)
                    line_end = text_end;
                if ((flags & ImGuiTextFlags_NoWidthForLargeClippedText) == 0)
                    text_size.x = ImMax(text_size.x, CalcTextSize(line, line_end).x);
                line = line_end + 1;
                lines_skipped++;
            }
            pos.y += lines_skipped * line_height;
        }
        text_size.y = (pos - text_pos).y;

        ImRect bb(text_pos, text_pos + text_size);
        ItemSize(text_size);
        ItemAdd(bb, 0);
    }
    else
    {
        const float wrap_width = wrap_enabled ? CalcWrapWidthForPos(window->DC.CursorPos, wrap_pos_x) : 0.0f;
        const ImVec2 text_size = CalcTextSize(text_begin, text_end, false, wrap_width);

        ImRect bb(text_pos, text_pos + text_size);
        ItemSize(text_size);
        if (!ItemAdd(bb, 0))
            return;

        // Render (we don't hide text after ## in this end-user function)
        RenderTextWrapped(bb.Min, text_begin, text_end, wrap_width);
    }
}

void ImGui::TextUnformatted(const char* text, const char* text_end)
{
    TextEx(text, text_end, ImGuiTextFlags_NoWidthForLargeClippedText);
}

void ImGui::Text(const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    TextV(fmt, args);
    va_end(args);
}

void ImGui::TextV(const char* fmt, va_list args)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImGuiContext& g = *GImGui;
    const char* text_end = g.TempBuffer + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);
    TextEx(g.TempBuffer, text_end, ImGuiTextFlags_NoWidthForLargeClippedText);
}

void ImGui::TextColored(const ImVec4& col, const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    TextColoredV(col, fmt, args);
    va_end(args);
}

void ImGui::TextColoredV(const ImVec4& col, const char* fmt, va_list args)
{
    PushStyleColor(ImGuiCol_Text, col);
    TextV(fmt, args);
    PopStyleColor();
}

void ImGui::TextDisabled(const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    TextDisabledV(fmt, args);
    va_end(args);
}

void ImGui::TextDisabledV(const char* fmt, va_list args)
{
    PushStyleColor(ImGuiCol_Text, GImGui->Style.Colors[ImGuiCol_TextDisabled]);
    TextV(fmt, args);
    PopStyleColor();
}

void ImGui::TextWrapped(const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    TextWrappedV(fmt, args);
    va_end(args);
}

void ImGui::TextWrappedV(const char* fmt, va_list args)
{
    ImGuiWindow* window = GetCurrentWindow();
    bool need_backup = (window->DC.TextWrapPos < 0.0f);  // Keep existing wrap position if one is already set
    if (need_backup)
        PushTextWrapPos(0.0f);
    TextV(fmt, args);
    if (need_backup)
        PopTextWrapPos();
}

void ImGui::LabelText(const char* label, const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    LabelTextV(label, fmt, args);
    va_end(args);
}

// Add a label+text combo aligned to other label+value widgets
void ImGui::LabelTextV(const char* label, const char* fmt, va_list args)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const float w = GetNextItemWidth();

    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    const ImRect value_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2));
    const ImRect total_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w + (label_size.x > 0.0f ? style.ItemInnerSpacing.x : 0.0f), style.FramePadding.y*2) + label_size);
    ItemSize(total_bb, style.FramePadding.y);
    if (!ItemAdd(total_bb, 0))
        return;

    // Render
    const char* value_text_begin = &g.TempBuffer[0];
    const char* value_text_end = value_text_begin + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);
    RenderTextClipped(value_bb.Min, value_bb.Max, value_text_begin, value_text_end, NULL, ImVec2(0.0f,0.5f));
    if (label_size.x > 0.0f)
        RenderText(ImVec2(value_bb.Max.x + style.ItemInnerSpacing.x, value_bb.Min.y + style.FramePadding.y), label);
}

void ImGui::BulletText(const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    BulletTextV(fmt, args);
    va_end(args);
}

// Text with a little bullet aligned to the typical tree node.
void ImGui::BulletTextV(const char* fmt, va_list args)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;

    const char* text_begin = g.TempBuffer;
    const char* text_end = text_begin + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);
    const ImVec2 label_size = CalcTextSize(text_begin, text_end, false);
    const float text_base_offset_y = ImMax(0.0f, window->DC.CurrentLineTextBaseOffset); // Latch before ItemSize changes it
    const float line_height = ImMax(ImMin(window->DC.CurrentLineSize.y, g.FontSize + g.Style.FramePadding.y*2), g.FontSize);
    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(g.FontSize + (label_size.x > 0.0f ? (label_size.x + style.FramePadding.x*2) : 0.0f), ImMax(line_height, label_size.y)));  // Empty text doesn't add padding
    ItemSize(bb);
    if (!ItemAdd(bb, 0))
        return;

    // Render
    RenderBullet(bb.Min + ImVec2(style.FramePadding.x + g.FontSize*0.5f, line_height*0.5f));
    RenderText(bb.Min+ImVec2(g.FontSize + style.FramePadding.x*2, text_base_offset_y), text_begin, text_end, false);
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: Main
//-------------------------------------------------------------------------
// - ButtonBehavior() [Internal]
// - Button()
// - SmallButton()
// - InvisibleButton()
// - ArrowButton()
// - CloseButton() [Internal]
// - CollapseButton() [Internal]
// - Scrollbar() [Internal]
// - Image()
// - ImageButton()
// - Checkbox()
// - CheckboxFlags()
// - RadioButton()
// - ProgressBar()
// - Bullet()
//-------------------------------------------------------------------------

// The ButtonBehavior() function is key to many interactions and used by many/most widgets.
// Because we handle so many cases (keyboard/gamepad navigation, drag and drop) and many specific behavior (via ImGuiButtonFlags_),
// this code is a little complex.
// By far the most common path is interacting with the Mouse using the default ImGuiButtonFlags_PressedOnClickRelease button behavior.
// See the series of events below and the corresponding state reported by dear imgui:
//------------------------------------------------------------------------------------------------------------------------------------------------
// with PressedOnClickRelease:             return-value  IsItemHovered()  IsItemActive()  IsItemActivated()  IsItemDeactivated()  IsItemClicked()
//   Frame N+0 (mouse is outside bb)        -             -                -               -                  -                    -    
//   Frame N+1 (mouse moves inside bb)      -             true             -               -                  -                    -    
//   Frame N+2 (mouse button is down)       -             true             true            true               -                    true
//   Frame N+3 (mouse button is down)       -             true             true            -                  -                    -    
//   Frame N+4 (mouse moves outside bb)     -             -                true            -                  -                    -
//   Frame N+5 (mouse moves inside bb)      -             true             true            -                  -                    -
//   Frame N+6 (mouse button is released)   true          true             -               -                  true                 -    
//   Frame N+7 (mouse button is released)   -             true             -               -                  -                    -    
//   Frame N+8 (mouse moves outside bb)     -             -                -               -                  -                    -    
//------------------------------------------------------------------------------------------------------------------------------------------------
// with PressedOnClick:                    return-value  IsItemHovered()  IsItemActive()  IsItemActivated()  IsItemDeactivated()  IsItemClicked()
//   Frame N+2 (mouse button is down)       true          true             true            true               -                    true
//   Frame N+3 (mouse button is down)       -             true             true            -                  -                    -    
//   Frame N+6 (mouse button is released)   -             true             -               -                  true                 -    
//   Frame N+7 (mouse button is released)   -             true             -               -                  -                    -    
//------------------------------------------------------------------------------------------------------------------------------------------------
// with PressedOnRelease:                  return-value  IsItemHovered()  IsItemActive()  IsItemActivated()  IsItemDeactivated()  IsItemClicked()
//   Frame N+2 (mouse button is down)       -             true             -               -                  -                    true
//   Frame N+3 (mouse button is down)       -             true             -               -                  -                    -    
//   Frame N+6 (mouse button is released)   true          true             -               -                  -                    -
//   Frame N+7 (mouse button is released)   -             true             -               -                  -                    -    
//------------------------------------------------------------------------------------------------------------------------------------------------
// with PressedOnDoubleClick:              return-value  IsItemHovered()  IsItemActive()  IsItemActivated()  IsItemDeactivated()  IsItemClicked()
//   Frame N+0 (mouse button is down)       -             true             -               -                  -                    true
//   Frame N+1 (mouse button is down)       -             true             -               -                  -                    -    
//   Frame N+2 (mouse button is released)   -             true             -               -                  -                    -
//   Frame N+3 (mouse button is released)   -             true             -               -                  -                    -    
//   Frame N+4 (mouse button is down)       true          true             true            true               -                    true
//   Frame N+5 (mouse button is down)       -             true             true            -                  -                    -    
//   Frame N+6 (mouse button is released)   -             true             -               -                  true                 -
//   Frame N+7 (mouse button is released)   -             true             -               -                  -                    -    
//------------------------------------------------------------------------------------------------------------------------------------------------
// Note that some combinations are supported,
// - PressedOnDragDropHold can generally be associated with any flag.
// - PressedOnDoubleClick can be associated by PressedOnClickRelease/PressedOnRelease, in which case the second release event won't be reported.
//------------------------------------------------------------------------------------------------------------------------------------------------
// The behavior of the return-value changes when ImGuiButtonFlags_Repeat is set:
//                                         Repeat+                  Repeat+           Repeat+             Repeat+
//                                         PressedOnClickRelease    PressedOnClick    PressedOnRelease    PressedOnDoubleClick
//-------------------------------------------------------------------------------------------------------------------------------------------------
//   Frame N+0 (mouse button is down)       -                        true              -                   true 
//   ...                                    -                        -                 -                   -
//   Frame N + RepeatDelay                  true                     true              -                   true
//   ...                                    -                        -                 -                   -
//   Frame N + RepeatDelay + RepeatRate*N   true                     true              -                   true
//-------------------------------------------------------------------------------------------------------------------------------------------------

bool ImGui::ButtonBehavior(const ImRect& bb, ImGuiID id, bool* out_hovered, bool* out_held, ImGuiButtonFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();

    if (flags & ImGuiButtonFlags_Disabled)
    {
        if (out_hovered) *out_hovered = false;
        if (out_held) *out_held = false;
        if (g.ActiveId == id) ClearActiveID();
        return false;
    }

    // Default behavior requires click+release on same spot
    if ((flags & (ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_PressedOnRelease | ImGuiButtonFlags_PressedOnDoubleClick)) == 0)
        flags |= ImGuiButtonFlags_PressedOnClickRelease;

    ImGuiWindow* backup_hovered_window = g.HoveredWindow;
    if ((flags & ImGuiButtonFlags_FlattenChildren) && g.HoveredRootWindow == window)
        g.HoveredWindow = window;

#ifdef IMGUI_ENABLE_TEST_ENGINE
    if (id != 0 && window->DC.LastItemId != id)
        ImGuiTestEngineHook_ItemAdd(&g, bb, id);
#endif

    bool pressed = false;
    bool hovered = ItemHoverable(bb, id);

    // Drag source doesn't report as hovered
    if (hovered && g.DragDropActive && g.DragDropPayload.SourceId == id && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoDisableHover))
        hovered = false;

    // Special mode for Drag and Drop where holding button pressed for a long time while dragging another item triggers the button
    if (g.DragDropActive && (flags & ImGuiButtonFlags_PressedOnDragDropHold) && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoHoldToOpenOthers))
        if (IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))
        {
            hovered = true;
            SetHoveredID(id);
            if (CalcTypematicPressedRepeatAmount(g.HoveredIdTimer + 0.0001f, g.HoveredIdTimer + 0.0001f - g.IO.DeltaTime, 0.01f, 0.70f)) // FIXME: Our formula for CalcTypematicPressedRepeatAmount() is fishy
            {
                pressed = true;
                FocusWindow(window);
            }
        }

    if ((flags & ImGuiButtonFlags_FlattenChildren) && g.HoveredRootWindow == window)
        g.HoveredWindow = backup_hovered_window;

    // AllowOverlap mode (rarely used) requires previous frame HoveredId to be null or to match. This allows using patterns where a later submitted widget overlaps a previous one.
    if (hovered && (flags & ImGuiButtonFlags_AllowItemOverlap) && (g.HoveredIdPreviousFrame != id && g.HoveredIdPreviousFrame != 0))
        hovered = false;

    // Mouse
    if (hovered)
    {
        if (!(flags & ImGuiButtonFlags_NoKeyModifiers) || (!g.IO.KeyCtrl && !g.IO.KeyShift && !g.IO.KeyAlt))
        {
            if ((flags & ImGuiButtonFlags_PressedOnClickRelease) && g.IO.MouseClicked[0])
            {
                SetActiveID(id, window);
                if (!(flags & ImGuiButtonFlags_NoNavFocus))
                    SetFocusID(id, window);
                FocusWindow(window);
            }
            if (((flags & ImGuiButtonFlags_PressedOnClick) && g.IO.MouseClicked[0]) || ((flags & ImGuiButtonFlags_PressedOnDoubleClick) && g.IO.MouseDoubleClicked[0]))
            {
                pressed = true;
                if (flags & ImGuiButtonFlags_NoHoldingActiveID)
                    ClearActiveID();
                else
                    SetActiveID(id, window); // Hold on ID
                FocusWindow(window);
            }
            if ((flags & ImGuiButtonFlags_PressedOnRelease) && g.IO.MouseReleased[0])
            {
                if (!((flags & ImGuiButtonFlags_Repeat) && g.IO.MouseDownDurationPrev[0] >= g.IO.KeyRepeatDelay))  // Repeat mode trumps <on release>
                    pressed = true;
                ClearActiveID();
            }

            // 'Repeat' mode acts when held regardless of _PressedOn flags (see table above).
            // Relies on repeat logic of IsMouseClicked() but we may as well do it ourselves if we end up exposing finer RepeatDelay/RepeatRate settings.
            if ((flags & ImGuiButtonFlags_Repeat) && g.ActiveId == id && g.IO.MouseDownDuration[0] > 0.0f && IsMouseClicked(0, true))
                pressed = true;
        }

        if (pressed)
            g.NavDisableHighlight = true;
    }

    // Gamepad/Keyboard navigation
    // We report navigated item as hovered but we don't set g.HoveredId to not interfere with mouse.
    if (g.NavId == id && !g.NavDisableHighlight && g.NavDisableMouseHover && (g.ActiveId == 0 || g.ActiveId == id || g.ActiveId == window->MoveId))
        if (!(flags & ImGuiButtonFlags_NoHoveredOnNav))
            hovered = true;

    if (g.NavActivateDownId == id)
    {
        bool nav_activated_by_code = (g.NavActivateId == id);
        bool nav_activated_by_inputs = IsNavInputPressed(ImGuiNavInput_Activate, (flags & ImGuiButtonFlags_Repeat) ? ImGuiInputReadMode_Repeat : ImGuiInputReadMode_Pressed);
        if (nav_activated_by_code || nav_activated_by_inputs)
            pressed = true;
        if (nav_activated_by_code || nav_activated_by_inputs || g.ActiveId == id)
        {
            // Set active id so it can be queried by user via IsItemActive(), equivalent of holding the mouse button.
            g.NavActivateId = id; // This is so SetActiveId assign a Nav source
            SetActiveID(id, window);
            if ((nav_activated_by_code || nav_activated_by_inputs) && !(flags & ImGuiButtonFlags_NoNavFocus))
                SetFocusID(id, window);
            g.ActiveIdAllowNavDirFlags = (1 << ImGuiDir_Left) | (1 << ImGuiDir_Right) | (1 << ImGuiDir_Up) | (1 << ImGuiDir_Down);
        }
    }

    bool held = false;
    if (g.ActiveId == id)
    {
        if (pressed)
            g.ActiveIdHasBeenPressed = true;
        if (g.ActiveIdSource == ImGuiInputSource_Mouse)
        {
            if (g.ActiveIdIsJustActivated)
                g.ActiveIdClickOffset = g.IO.MousePos - bb.Min;
            if (g.IO.MouseDown[0])
            {
                held = true;
            }
            else
            {
                if (hovered && (flags & ImGuiButtonFlags_PressedOnClickRelease) && !g.DragDropActive)
                {
                    bool is_double_click_release = (flags & ImGuiButtonFlags_PressedOnDoubleClick) && g.IO.MouseDownWasDoubleClick[0];
                    bool is_repeating_already = (flags & ImGuiButtonFlags_Repeat) && g.IO.MouseDownDurationPrev[0] >= g.IO.KeyRepeatDelay; // Repeat mode trumps <on release>
                    if (!is_double_click_release && !is_repeating_already)
                        pressed = true;
                }
                ClearActiveID();
            }
            if (!(flags & ImGuiButtonFlags_NoNavFocus))
                g.NavDisableHighlight = true;
        }
        else if (g.ActiveIdSource == ImGuiInputSource_Nav)
        {
            if (g.NavActivateDownId != id)
                ClearActiveID();
        }
    }

    if (out_hovered) *out_hovered = hovered;
    if (out_held) *out_held = held;

    return pressed;
}

bool ImGui::ButtonEx(const char* label, const ImVec2& size_arg, ImGuiButtonFlags flags)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const ImGuiID id = window->GetID(label);
    const ImVec2 label_size = CalcTextSize(label, NULL, true);

    ImVec2 pos = window->DC.CursorPos;
    if ((flags & ImGuiButtonFlags_AlignTextBaseLine) && style.FramePadding.y < window->DC.CurrentLineTextBaseOffset) // Try to vertically align buttons that are smaller/have no padding so that text baseline matches (bit hacky, since it shouldn't be a flag)
        pos.y += window->DC.CurrentLineTextBaseOffset - style.FramePadding.y;
    ImVec2 size = CalcItemSize(size_arg, label_size.x + style.FramePadding.x * 2.0f, label_size.y + style.FramePadding.y * 2.0f);

    const ImRect bb(pos, pos + size);
    ItemSize(size, style.FramePadding.y);
    if (!ItemAdd(bb, id))
        return false;

    if (window->DC.ItemFlags & ImGuiItemFlags_ButtonRepeat)
        flags |= ImGuiButtonFlags_Repeat;
    bool hovered, held;
    bool pressed = ButtonBehavior(bb, id, &hovered, &held, flags);
    if (pressed)
        MarkItemEdited(id);

    // Render
    const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
    RenderNavHighlight(bb, id);
    RenderFrame(bb.Min, bb.Max, col, true, style.FrameRounding);
    RenderTextClipped(bb.Min + style.FramePadding, bb.Max - style.FramePadding, label, NULL, &label_size, style.ButtonTextAlign, &bb);

    // Automatically close popups
    //if (pressed && !(flags & ImGuiButtonFlags_DontClosePopups) && (window->Flags & ImGuiWindowFlags_Popup))
    //    CloseCurrentPopup();

    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.LastItemStatusFlags);
    return pressed;
}

bool ImGui::Button(const char* label, const ImVec2& size_arg)
{
    return ButtonEx(label, size_arg, 0);
}

// Small buttons fits within text without additional vertical spacing.
bool ImGui::SmallButton(const char* label)
{
    ImGuiContext& g = *GImGui;
    float backup_padding_y = g.Style.FramePadding.y;
    g.Style.FramePadding.y = 0.0f;
    bool pressed = ButtonEx(label, ImVec2(0, 0), ImGuiButtonFlags_AlignTextBaseLine);
    g.Style.FramePadding.y = backup_padding_y;
    return pressed;
}

// Tip: use ImGui::PushID()/PopID() to push indices or pointers in the ID stack.
// Then you can keep 'str_id' empty or the same for all your buttons (instead of creating a string based on a non-string id)
bool ImGui::InvisibleButton(const char* str_id, const ImVec2& size_arg)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    // Cannot use zero-size for InvisibleButton(). Unlike Button() there is not way to fallback using the label size.
    IM_ASSERT(size_arg.x != 0.0f && size_arg.y != 0.0f);

    const ImGuiID id = window->GetID(str_id);
    ImVec2 size = CalcItemSize(size_arg, 0.0f, 0.0f);
    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);
    ItemSize(size);
    if (!ItemAdd(bb, id))
        return false;

    bool hovered, held;
    bool pressed = ButtonBehavior(bb, id, &hovered, &held);

    return pressed;
}

bool ImGui::ArrowButtonEx(const char* str_id, ImGuiDir dir, ImVec2 size, ImGuiButtonFlags flags)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiID id = window->GetID(str_id);
    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);
    const float default_size = GetFrameHeight();
    ItemSize(size, (size.y >= default_size) ? g.Style.FramePadding.y : 0.0f);
    if (!ItemAdd(bb, id))
        return false;

    if (window->DC.ItemFlags & ImGuiItemFlags_ButtonRepeat)
        flags |= ImGuiButtonFlags_Repeat;

    bool hovered, held;
    bool pressed = ButtonBehavior(bb, id, &hovered, &held, flags);

    // Render
    const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
    RenderNavHighlight(bb, id);
    RenderFrame(bb.Min, bb.Max, col, true, g.Style.FrameRounding);
    RenderArrow(bb.Min + ImVec2(ImMax(0.0f, (size.x - g.FontSize) * 0.5f), ImMax(0.0f, (size.y - g.FontSize) * 0.5f)), dir);

    return pressed;
}

bool ImGui::ArrowButton(const char* str_id, ImGuiDir dir)
{
    float sz = GetFrameHeight();
    return ArrowButtonEx(str_id, dir, ImVec2(sz, sz), 0);
}

// Button to close a window
bool ImGui::CloseButton(ImGuiID id, const ImVec2& pos, float radius)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    // We intentionally allow interaction when clipped so that a mechanical Alt,Right,Validate sequence close a window.
    // (this isn't the regular behavior of buttons, but it doesn't affect the user much because navigation tends to keep items visible).
    const ImRect bb(pos - ImVec2(radius,radius), pos + ImVec2(radius,radius));
    bool is_clipped = !ItemAdd(bb, id);

    bool hovered, held;
    bool pressed = ButtonBehavior(bb, id, &hovered, &held);
    if (is_clipped)
        return pressed;

    // Render
    ImVec2 center = bb.GetCenter();
    if (hovered)
        window->DrawList->AddCircleFilled(center, ImMax(2.0f, radius), GetColorU32(held ? ImGuiCol_ButtonActive : ImGuiCol_ButtonHovered), 9);

    float cross_extent = (radius * 0.7071f) - 1.0f;
    ImU32 cross_col = GetColorU32(ImGuiCol_Text);
    center -= ImVec2(0.5f, 0.5f);
    window->DrawList->AddLine(center + ImVec2(+cross_extent,+cross_extent), center + ImVec2(-cross_extent,-cross_extent), cross_col, 1.0f);
    window->DrawList->AddLine(center + ImVec2(+cross_extent,-cross_extent), center + ImVec2(-cross_extent,+cross_extent), cross_col, 1.0f);

    return pressed;
}

bool ImGui::CollapseButton(ImGuiID id, const ImVec2& pos)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    ImRect bb(pos, pos + ImVec2(g.FontSize, g.FontSize) + g.Style.FramePadding * 2.0f);
    ItemAdd(bb, id);
    bool hovered, held;
    bool pressed = ButtonBehavior(bb, id, &hovered, &held, ImGuiButtonFlags_None);

    ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
    if (hovered || held)
        window->DrawList->AddCircleFilled(bb.GetCenter() + ImVec2(0.0f, -0.5f), g.FontSize * 0.5f + 1.0f, col, 9);
    RenderArrow(bb.Min + g.Style.FramePadding, window->Collapsed ? ImGuiDir_Right : ImGuiDir_Down, 1.0f);

    // Switch to moving the window after mouse is moved beyond the initial drag threshold
    if (IsItemActive() && IsMouseDragging())
        StartMouseMovingWindow(window);

    return pressed;
}

ImGuiID ImGui::GetScrollbarID(ImGuiWindow* window, ImGuiAxis axis)
{
    return window->GetIDNoKeepAlive(axis == ImGuiAxis_X ? "#SCROLLX" : "#SCROLLY");
}

// Vertical/Horizontal scrollbar
// The entire piece of code below is rather confusing because:
// - We handle absolute seeking (when first clicking outside the grab) and relative manipulation (afterward or when clicking inside the grab)
// - We store values as normalized ratio and in a form that allows the window content to change while we are holding on a scrollbar
// - We handle both horizontal and vertical scrollbars, which makes the terminology not ideal.
void ImGui::Scrollbar(ImGuiAxis axis)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    const bool horizontal = (axis == ImGuiAxis_X);
    const ImGuiStyle& style = g.Style;
    const ImGuiID id = GetScrollbarID(window, axis);
    KeepAliveID(id);

    // Render background
    bool other_scrollbar = (horizontal ? window->ScrollbarY : window->ScrollbarX);
    float other_scrollbar_size_w = other_scrollbar ? style.ScrollbarSize : 0.0f;
    const ImRect host_rect = window->Rect();
    const float border_size = window->WindowBorderSize;
    ImRect bb = horizontal
        ? ImRect(host_rect.Min.x + border_size, host_rect.Max.y - style.ScrollbarSize, host_rect.Max.x - other_scrollbar_size_w - border_size, host_rect.Max.y - border_size)
        : ImRect(host_rect.Max.x - style.ScrollbarSize, host_rect.Min.y + border_size, host_rect.Max.x - border_size, host_rect.Max.y - other_scrollbar_size_w - border_size);
    bb.Min.x = ImMax(host_rect.Min.x, bb.Min.x); // Handle case where the host rectangle is smaller than the scrollbar
    bb.Min.y = ImMax(host_rect.Min.y, bb.Min.y);
    if (!horizontal)
        bb.Min.y += window->TitleBarHeight() + ((window->Flags & ImGuiWindowFlags_MenuBar) ? window->MenuBarHeight() : 0.0f); // FIXME: InnerRect?

    const float bb_width = bb.GetWidth();
    const float bb_height = bb.GetHeight();
    if (bb_width <= 0.0f || bb_height <= 0.0f)
        return;

    // When we are too small, start hiding and disabling the grab (this reduce visual noise on very small window and facilitate using the resize grab)
    float alpha = 1.0f;
    if ((axis == ImGuiAxis_Y) && bb_height < g.FontSize + g.Style.FramePadding.y * 2.0f)
    {
        alpha = ImSaturate((bb_height - g.FontSize) / (g.Style.FramePadding.y * 2.0f));
        if (alpha <= 0.0f)
            return;
    }
    const bool allow_interaction = (alpha >= 1.0f);

    int window_rounding_corners;
    if (horizontal)
        window_rounding_corners = ImDrawCornerFlags_BotLeft | (other_scrollbar ? 0 : ImDrawCornerFlags_BotRight);
    else
        window_rounding_corners = (((window->Flags & ImGuiWindowFlags_NoTitleBar) && !(window->Flags & ImGuiWindowFlags_MenuBar)) ? ImDrawCornerFlags_TopRight : 0) | (other_scrollbar ? 0 : ImDrawCornerFlags_BotRight);
    window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(ImGuiCol_ScrollbarBg), window->WindowRounding, window_rounding_corners);
    bb.Expand(ImVec2(-ImClamp((float)(int)((bb_width - 2.0f) * 0.5f), 0.0f, 3.0f), -ImClamp((float)(int)((bb_height - 2.0f) * 0.5f), 0.0f, 3.0f)));

    // V denote the main, longer axis of the scrollbar (= height for a vertical scrollbar)
    float scrollbar_size_v = horizontal ? bb.GetWidth() : bb.GetHeight();
    float scroll_v = horizontal ? window->Scroll.x : window->Scroll.y;
    float win_size_avail_v = (horizontal ? window->SizeFull.x : window->SizeFull.y) - other_scrollbar_size_w;
    float win_size_contents_v = horizontal ? window->SizeContents.x : window->SizeContents.y;

    // Calculate the height of our grabbable box. It generally represent the amount visible (vs the total scrollable amount)
    // But we maintain a minimum size in pixel to allow for the user to still aim inside.
    IM_ASSERT(ImMax(win_size_contents_v, win_size_avail_v) > 0.0f); // Adding this assert to check if the ImMax(XXX,1.0f) is still needed. PLEASE CONTACT ME if this triggers.
    const float win_size_v = ImMax(ImMax(win_size_contents_v, win_size_avail_v), 1.0f);
    const float grab_h_pixels = ImClamp(scrollbar_size_v * (win_size_avail_v / win_size_v), style.GrabMinSize, scrollbar_size_v);
    const float grab_h_norm = grab_h_pixels / scrollbar_size_v;

    // Handle input right away. None of the code of Begin() is relying on scrolling position before calling Scrollbar().
    bool held = false;
    bool hovered = false;
    const bool previously_held = (g.ActiveId == id);
    ButtonBehavior(bb, id, &hovered, &held, ImGuiButtonFlags_NoNavFocus);

    float scroll_max = ImMax(1.0f, win_size_contents_v - win_size_avail_v);
    float scroll_ratio = ImSaturate(scroll_v / scroll_max);
    float grab_v_norm = scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v;
    if (held && allow_interaction && grab_h_norm < 1.0f)
    {
        float scrollbar_pos_v = horizontal ? bb.Min.x : bb.Min.y;
        float mouse_pos_v = horizontal ? g.IO.MousePos.x : g.IO.MousePos.y;
        float* click_delta_to_grab_center_v = horizontal ? &g.ScrollbarClickDeltaToGrabCenter.x : &g.ScrollbarClickDeltaToGrabCenter.y;

        // Click position in scrollbar normalized space (0.0f->1.0f)
        const float clicked_v_norm = ImSaturate((mouse_pos_v - scrollbar_pos_v) / scrollbar_size_v);
        SetHoveredID(id);

        bool seek_absolute = false;
        if (!previously_held)
        {
            // On initial click calculate the distance between mouse and the center of the grab
            if (clicked_v_norm >= grab_v_norm && clicked_v_norm <= grab_v_norm + grab_h_norm)
            {
                *click_delta_to_grab_center_v = clicked_v_norm - grab_v_norm - grab_h_norm*0.5f;
            }
            else
            {
                seek_absolute = true;
                *click_delta_to_grab_center_v = 0.0f;
            }
        }

        // Apply scroll
        // It is ok to modify Scroll here because we are being called in Begin() after the calculation of SizeContents and before setting up our starting position
        const float scroll_v_norm = ImSaturate((clicked_v_norm - *click_delta_to_grab_center_v - grab_h_norm*0.5f) / (1.0f - grab_h_norm));
        scroll_v = (float)(int)(0.5f + scroll_v_norm * scroll_max);//(win_size_contents_v - win_size_v));
        if (horizontal)
            window->Scroll.x = scroll_v;
        else
            window->Scroll.y = scroll_v;

        // Update values for rendering
        scroll_ratio = ImSaturate(scroll_v / scroll_max);
        grab_v_norm = scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v;

        // Update distance to grab now that we have seeked and saturated
        if (seek_absolute)
            *click_delta_to_grab_center_v = clicked_v_norm - grab_v_norm - grab_h_norm*0.5f;
    }

    // Render grab
    const ImU32 grab_col = GetColorU32(held ? ImGuiCol_ScrollbarGrabActive : hovered ? ImGuiCol_ScrollbarGrabHovered : ImGuiCol_ScrollbarGrab, alpha);
    ImRect grab_rect;
    if (horizontal)
        grab_rect = ImRect(ImLerp(bb.Min.x, bb.Max.x, grab_v_norm), bb.Min.y, ImMin(ImLerp(bb.Min.x, bb.Max.x, grab_v_norm) + grab_h_pixels, host_rect.Max.x), bb.Max.y);
    else
        grab_rect = ImRect(bb.Min.x, ImLerp(bb.Min.y, bb.Max.y, grab_v_norm), bb.Max.x, ImMin(ImLerp(bb.Min.y, bb.Max.y, grab_v_norm) + grab_h_pixels, host_rect.Max.y));
    window->DrawList->AddRectFilled(grab_rect.Min, grab_rect.Max, grab_col, style.ScrollbarRounding);
}

void ImGui::Image(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, const ImVec4& tint_col, const ImVec4& border_col)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);
    if (border_col.w > 0.0f)
        bb.Max += ImVec2(2, 2);
    ItemSize(bb);
    if (!ItemAdd(bb, 0))
        return;

    if (border_col.w > 0.0f)
    {
        window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(border_col), 0.0f);
        window->DrawList->AddImage(user_texture_id, bb.Min + ImVec2(1, 1), bb.Max - ImVec2(1, 1), uv0, uv1, GetColorU32(tint_col));
    }
    else
    {
        window->DrawList->AddImage(user_texture_id, bb.Min, bb.Max, uv0, uv1, GetColorU32(tint_col));
    }
}

// frame_padding < 0: uses FramePadding from style (default)
// frame_padding = 0: no framing
// frame_padding > 0: set framing size
// The color used are the button colors.
bool ImGui::ImageButton(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, int frame_padding, const ImVec4& bg_col, const ImVec4& tint_col)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;

    // Default to using texture ID as ID. User can still push string/integer prefixes.
    // We could hash the size/uv to create a unique ID but that would prevent the user from animating UV.
    PushID((void*)(intptr_t)user_texture_id);
    const ImGuiID id = window->GetID("#image");
    PopID();

    const ImVec2 padding = (frame_padding >= 0) ? ImVec2((float)frame_padding, (float)frame_padding) : style.FramePadding;
    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size + padding * 2);
    const ImRect image_bb(window->DC.CursorPos + padding, window->DC.CursorPos + padding + size);
    ItemSize(bb);
    if (!ItemAdd(bb, id))
        return false;

    bool hovered, held;
    bool pressed = ButtonBehavior(bb, id, &hovered, &held);

    // Render
    const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
    RenderNavHighlight(bb, id);
    RenderFrame(bb.Min, bb.Max, col, true, ImClamp((float)ImMin(padding.x, padding.y), 0.0f, style.FrameRounding));
    if (bg_col.w > 0.0f)
        window->DrawList->AddRectFilled(image_bb.Min, image_bb.Max, GetColorU32(bg_col));
    window->DrawList->AddImage(user_texture_id, image_bb.Min, image_bb.Max, uv0, uv1, GetColorU32(tint_col));

    return pressed;
}

bool ImGui::Checkbox(const char* label, bool* v)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const ImGuiID id = window->GetID(label);
    const ImVec2 label_size = CalcTextSize(label, NULL, true);

    const float square_sz = GetFrameHeight();
    const ImVec2 pos = window->DC.CursorPos;
    const ImRect total_bb(pos, pos + ImVec2(square_sz + (label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), label_size.y + style.FramePadding.y * 2.0f));
    ItemSize(total_bb, style.FramePadding.y);
    if (!ItemAdd(total_bb, id))
        return false;

    bool hovered, held;
    bool pressed = ButtonBehavior(total_bb, id, &hovered, &held);
    if (pressed)
    {
        *v = !(*v);
        MarkItemEdited(id);
    }

    const ImRect check_bb(pos, pos + ImVec2(square_sz, square_sz));
    RenderNavHighlight(total_bb, id);
    RenderFrame(check_bb.Min, check_bb.Max, GetColorU32((held && hovered) ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg), true, style.FrameRounding);
    if (*v)
    {
        const float pad = ImMax(1.0f, (float)(int)(square_sz / 6.0f));
        RenderCheckMark(check_bb.Min + ImVec2(pad, pad), GetColorU32(ImGuiCol_CheckMark), square_sz - pad*2.0f);
    }

    if (g.LogEnabled)
        LogRenderedText(&total_bb.Min, *v ? "[x]" : "[ ]");
    if (label_size.x > 0.0f)
        RenderText(ImVec2(check_bb.Max.x + style.ItemInnerSpacing.x, check_bb.Min.y + style.FramePadding.y), label);

    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.ItemFlags | ImGuiItemStatusFlags_Checkable | (*v ? ImGuiItemStatusFlags_Checked : 0));
    return pressed;
}

bool ImGui::CheckboxFlags(const char* label, unsigned int* flags, unsigned int flags_value)
{
    bool v = ((*flags & flags_value) == flags_value);
    bool pressed = Checkbox(label, &v);
    if (pressed)
    {
        if (v)
            *flags |= flags_value;
        else
            *flags &= ~flags_value;
    }

    return pressed;
}

bool ImGui::RadioButton(const char* label, bool active)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const ImGuiID id = window->GetID(label);
    const ImVec2 label_size = CalcTextSize(label, NULL, true);

    const float square_sz = GetFrameHeight();
    const ImVec2 pos = window->DC.CursorPos;
    const ImRect check_bb(pos, pos + ImVec2(square_sz, square_sz));
    const ImRect total_bb(pos, pos + ImVec2(square_sz + (label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), label_size.y + style.FramePadding.y * 2.0f));
    ItemSize(total_bb, style.FramePadding.y);
    if (!ItemAdd(total_bb, id))
        return false;

    ImVec2 center = check_bb.GetCenter();
    center.x = (float)(int)center.x + 0.5f;
    center.y = (float)(int)center.y + 0.5f;
    const float radius = (square_sz - 1.0f) * 0.5f;

    bool hovered, held;
    bool pressed = ButtonBehavior(total_bb, id, &hovered, &held);
    if (pressed)
        MarkItemEdited(id);

    RenderNavHighlight(total_bb, id);
    window->DrawList->AddCircleFilled(center, radius, GetColorU32((held && hovered) ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg), 16);
    if (active)
    {
        const float pad = ImMax(1.0f, (float)(int)(square_sz / 6.0f));
        window->DrawList->AddCircleFilled(center, radius - pad, GetColorU32(ImGuiCol_CheckMark), 16);
    }

    if (style.FrameBorderSize > 0.0f)
    {
        window->DrawList->AddCircle(center + ImVec2(1,1), radius, GetColorU32(ImGuiCol_BorderShadow), 16, style.FrameBorderSize);
        window->DrawList->AddCircle(center, radius, GetColorU32(ImGuiCol_Border), 16, style.FrameBorderSize);
    }

    if (g.LogEnabled)
        LogRenderedText(&total_bb.Min, active ? "(x)" : "( )");
    if (label_size.x > 0.0f)
        RenderText(ImVec2(check_bb.Max.x + style.ItemInnerSpacing.x, check_bb.Min.y + style.FramePadding.y), label);

    return pressed;
}

bool ImGui::RadioButton(const char* label, int* v, int v_button)
{
    const bool pressed = RadioButton(label, *v == v_button);
    if (pressed)
        *v = v_button;
    return pressed;
}

// size_arg (for each axis) < 0.0f: align to end, 0.0f: auto, > 0.0f: specified size
void ImGui::ProgressBar(float fraction, const ImVec2& size_arg, const char* overlay)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;

    ImVec2 pos = window->DC.CursorPos;
    ImVec2 size = CalcItemSize(size_arg, GetNextItemWidth(), g.FontSize + style.FramePadding.y*2.0f);
    ImRect bb(pos, pos + size);
    ItemSize(size, style.FramePadding.y);
    if (!ItemAdd(bb, 0))
        return;

    // Render
    fraction = ImSaturate(fraction);
    RenderFrame(bb.Min, bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);
    bb.Expand(ImVec2(-style.FrameBorderSize, -style.FrameBorderSize));
    const ImVec2 fill_br = ImVec2(ImLerp(bb.Min.x, bb.Max.x, fraction), bb.Max.y);
    RenderRectFilledRangeH(window->DrawList, bb, GetColorU32(ImGuiCol_PlotHistogram), 0.0f, fraction, style.FrameRounding);

    // Default displaying the fraction as percentage string, but user can override it
    char overlay_buf[32];
    if (!overlay)
    {
        ImFormatString(overlay_buf, IM_ARRAYSIZE(overlay_buf), "%.0f%%", fraction*100+0.01f);
        overlay = overlay_buf;
    }

    ImVec2 overlay_size = CalcTextSize(overlay, NULL);
    if (overlay_size.x > 0.0f)
        RenderTextClipped(ImVec2(ImClamp(fill_br.x + style.ItemSpacing.x, bb.Min.x, bb.Max.x - overlay_size.x - style.ItemInnerSpacing.x), bb.Min.y), bb.Max, overlay, NULL, &overlay_size, ImVec2(0.0f,0.5f), &bb);
}

void ImGui::Bullet()
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const float line_height = ImMax(ImMin(window->DC.CurrentLineSize.y, g.FontSize + g.Style.FramePadding.y*2), g.FontSize);
    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(g.FontSize, line_height));
    ItemSize(bb);
    if (!ItemAdd(bb, 0))
    {
        SameLine(0, style.FramePadding.x*2);
        return;
    }

    // Render and stay on same line
    RenderBullet(bb.Min + ImVec2(style.FramePadding.x + g.FontSize*0.5f, line_height*0.5f));
    SameLine(0, style.FramePadding.x*2);
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: Low-level Layout helpers
//-------------------------------------------------------------------------
// - Spacing()
// - Dummy()
// - NewLine()
// - AlignTextToFramePadding()
// - Separator()
// - VerticalSeparator() [Internal]
// - SplitterBehavior() [Internal]
//-------------------------------------------------------------------------

void ImGui::Spacing()
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;
    ItemSize(ImVec2(0,0));
}

void ImGui::Dummy(const ImVec2& size)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);
    ItemSize(size);
    ItemAdd(bb, 0);
}

void ImGui::NewLine()
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImGuiContext& g = *GImGui;
    const ImGuiLayoutType backup_layout_type = window->DC.LayoutType;
    window->DC.LayoutType = ImGuiLayoutType_Vertical;
    if (window->DC.CurrentLineSize.y > 0.0f)     // In the event that we are on a line with items that is smaller that FontSize high, we will preserve its height.
        ItemSize(ImVec2(0,0));
    else
        ItemSize(ImVec2(0.0f, g.FontSize));
    window->DC.LayoutType = backup_layout_type;
}

void ImGui::AlignTextToFramePadding()
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImGuiContext& g = *GImGui;
    window->DC.CurrentLineSize.y = ImMax(window->DC.CurrentLineSize.y, g.FontSize + g.Style.FramePadding.y * 2);
    window->DC.CurrentLineTextBaseOffset = ImMax(window->DC.CurrentLineTextBaseOffset, g.Style.FramePadding.y);
}

// Horizontal/vertical separating line
void ImGui::Separator()
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;
    ImGuiContext& g = *GImGui;

    // Those flags should eventually be overrideable by the user
    ImGuiSeparatorFlags flags = (window->DC.LayoutType == ImGuiLayoutType_Horizontal) ? ImGuiSeparatorFlags_Vertical : ImGuiSeparatorFlags_Horizontal;
    IM_ASSERT(ImIsPowerOfTwo(flags & (ImGuiSeparatorFlags_Horizontal | ImGuiSeparatorFlags_Vertical)));   // Check that only 1 option is selected
    if (flags & ImGuiSeparatorFlags_Vertical)
    {
        VerticalSeparator();
        return;
    }

    // Horizontal Separator
    if (window->DC.CurrentColumns)
        PopClipRect();

    float x1 = window->Pos.x;
    float x2 = window->Pos.x + window->Size.x;
    if (!window->DC.GroupStack.empty())
        x1 += window->DC.Indent.x;

    const ImRect bb(ImVec2(x1, window->DC.CursorPos.y), ImVec2(x2, window->DC.CursorPos.y+1.0f));
    ItemSize(ImVec2(0.0f, 1.0f)); // NB: we don't provide our width so that it doesn't get feed back into AutoFit
    if (!ItemAdd(bb, 0))
    {
        if (window->DC.CurrentColumns)
            PushColumnClipRect();
        return;
    }

    window->DrawList->AddLine(bb.Min, ImVec2(bb.Max.x,bb.Min.y), GetColorU32(ImGuiCol_Separator));

    if (g.LogEnabled)
        LogRenderedText(&bb.Min, "--------------------------------");

    if (window->DC.CurrentColumns)
    {
        PushColumnClipRect();
        window->DC.CurrentColumns->LineMinY = window->DC.CursorPos.y;
    }
}

void ImGui::VerticalSeparator()
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;
    ImGuiContext& g = *GImGui;

    float y1 = window->DC.CursorPos.y;
    float y2 = window->DC.CursorPos.y + window->DC.CurrentLineSize.y;
    const ImRect bb(ImVec2(window->DC.CursorPos.x, y1), ImVec2(window->DC.CursorPos.x + 1.0f, y2));
    ItemSize(ImVec2(1.0f, 0.0f));
    if (!ItemAdd(bb, 0))
        return;

    window->DrawList->AddLine(ImVec2(bb.Min.x, bb.Min.y), ImVec2(bb.Min.x, bb.Max.y), GetColorU32(ImGuiCol_Separator));
    if (g.LogEnabled)
        LogText(" |");
}

// Using 'hover_visibility_delay' allows us to hide the highlight and mouse cursor for a short time, which can be convenient to reduce visual noise.
bool ImGui::SplitterBehavior(const ImRect& bb, ImGuiID id, ImGuiAxis axis, float* size1, float* size2, float min_size1, float min_size2, float hover_extend, float hover_visibility_delay)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    const ImGuiItemFlags item_flags_backup = window->DC.ItemFlags;
    window->DC.ItemFlags |= ImGuiItemFlags_NoNav | ImGuiItemFlags_NoNavDefaultFocus;
    bool item_add = ItemAdd(bb, id);
    window->DC.ItemFlags = item_flags_backup;
    if (!item_add)
        return false;

    bool hovered, held;
    ImRect bb_interact = bb;
    bb_interact.Expand(axis == ImGuiAxis_Y ? ImVec2(0.0f, hover_extend) : ImVec2(hover_extend, 0.0f));
    ButtonBehavior(bb_interact, id, &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_AllowItemOverlap);
    if (g.ActiveId != id)
        SetItemAllowOverlap();

    if (held || (g.HoveredId == id && g.HoveredIdPreviousFrame == id && g.HoveredIdTimer >= hover_visibility_delay))
        SetMouseCursor(axis == ImGuiAxis_Y ? ImGuiMouseCursor_ResizeNS : ImGuiMouseCursor_ResizeEW);

    ImRect bb_render = bb;
    if (held)
    {
        ImVec2 mouse_delta_2d = g.IO.MousePos - g.ActiveIdClickOffset - bb_interact.Min;
        float mouse_delta = (axis == ImGuiAxis_Y) ? mouse_delta_2d.y : mouse_delta_2d.x;

        // Minimum pane size
        float size_1_maximum_delta = ImMax(0.0f, *size1 - min_size1);
        float size_2_maximum_delta = ImMax(0.0f, *size2 - min_size2);
        if (mouse_delta < -size_1_maximum_delta)
            mouse_delta = -size_1_maximum_delta;
        if (mouse_delta > size_2_maximum_delta)
            mouse_delta = size_2_maximum_delta;

        // Apply resize
        if (mouse_delta != 0.0f)
        {
            if (mouse_delta < 0.0f)
                IM_ASSERT(*size1 + mouse_delta >= min_size1);
            if (mouse_delta > 0.0f)
                IM_ASSERT(*size2 - mouse_delta >= min_size2);
            *size1 += mouse_delta;
            *size2 -= mouse_delta;
            bb_render.Translate((axis == ImGuiAxis_X) ? ImVec2(mouse_delta, 0.0f) : ImVec2(0.0f, mouse_delta));
            MarkItemEdited(id);
        }
    }

    // Render
    const ImU32 col = GetColorU32(held ? ImGuiCol_SeparatorActive : (hovered && g.HoveredIdTimer >= hover_visibility_delay) ? ImGuiCol_SeparatorHovered : ImGuiCol_Separator);
    window->DrawList->AddRectFilled(bb_render.Min, bb_render.Max, col, g.Style.FrameRounding);

    return held;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: ComboBox
//-------------------------------------------------------------------------
// - BeginCombo()
// - EndCombo()
// - Combo()
//-------------------------------------------------------------------------

static float CalcMaxPopupHeightFromItemCount(int items_count)
{
    ImGuiContext& g = *GImGui;
    if (items_count <= 0)
        return FLT_MAX;
    return (g.FontSize + g.Style.ItemSpacing.y) * items_count - g.Style.ItemSpacing.y + (g.Style.WindowPadding.y * 2);
}

bool ImGui::BeginCombo(const char* label, const char* preview_value, ImGuiComboFlags flags)
{
    // Always consume the SetNextWindowSizeConstraint() call in our early return paths
    ImGuiContext& g = *GImGui;
    ImGuiCond backup_next_window_size_constraint = g.NextWindowData.SizeConstraintCond;
    g.NextWindowData.SizeConstraintCond = 0;

    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    IM_ASSERT((flags & (ImGuiComboFlags_NoArrowButton | ImGuiComboFlags_NoPreview)) != (ImGuiComboFlags_NoArrowButton | ImGuiComboFlags_NoPreview)); // Can't use both flags together

    const ImGuiStyle& style = g.Style;
    const ImGuiID id = window->GetID(label);

    const float arrow_size = (flags & ImGuiComboFlags_NoArrowButton) ? 0.0f : GetFrameHeight();
    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    const float expected_w = GetNextItemWidth();
    const float w = (flags & ImGuiComboFlags_NoPreview) ? arrow_size : expected_w;
    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2.0f));
    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));
    ItemSize(total_bb, style.FramePadding.y);
    if (!ItemAdd(total_bb, id, &frame_bb))
        return false;

    bool hovered, held;
    bool pressed = ButtonBehavior(frame_bb, id, &hovered, &held);
    bool popup_open = IsPopupOpen(id);

    const ImU32 frame_col = GetColorU32(hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);
    const float value_x2 = ImMax(frame_bb.Min.x, frame_bb.Max.x - arrow_size);
    RenderNavHighlight(frame_bb, id);
    if (!(flags & ImGuiComboFlags_NoPreview))
        window->DrawList->AddRectFilled(frame_bb.Min, ImVec2(value_x2, frame_bb.Max.y), frame_col, style.FrameRounding, ImDrawCornerFlags_Left);
    if (!(flags & ImGuiComboFlags_NoArrowButton))
    {
        window->DrawList->AddRectFilled(ImVec2(value_x2, frame_bb.Min.y), frame_bb.Max, GetColorU32((popup_open || hovered) ? ImGuiCol_ButtonHovered : ImGuiCol_Button), style.FrameRounding, (w <= arrow_size) ? ImDrawCornerFlags_All : ImDrawCornerFlags_Right);
        RenderArrow(ImVec2(value_x2 + style.FramePadding.y, frame_bb.Min.y + style.FramePadding.y), ImGuiDir_Down);
    }
    RenderFrameBorder(frame_bb.Min, frame_bb.Max, style.FrameRounding);
    if (preview_value != NULL && !(flags & ImGuiComboFlags_NoPreview))
        RenderTextClipped(frame_bb.Min + style.FramePadding, ImVec2(value_x2, frame_bb.Max.y), preview_value, NULL, NULL, ImVec2(0.0f,0.0f));
    if (label_size.x > 0)
        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

    if ((pressed || g.NavActivateId == id) && !popup_open)
    {
        if (window->DC.NavLayerCurrent == 0)
            window->NavLastIds[0] = id;
        OpenPopupEx(id);
        popup_open = true;
    }

    if (!popup_open)
        return false;

    if (backup_next_window_size_constraint)
    {
        g.NextWindowData.SizeConstraintCond = backup_next_window_size_constraint;
        g.NextWindowData.SizeConstraintRect.Min.x = ImMax(g.NextWindowData.SizeConstraintRect.Min.x, w);
    }
    else
    {
        if ((flags & ImGuiComboFlags_HeightMask_) == 0)
            flags |= ImGuiComboFlags_HeightRegular;
        IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiComboFlags_HeightMask_));    // Only one
        int popup_max_height_in_items = -1;
        if (flags & ImGuiComboFlags_HeightRegular)     popup_max_height_in_items = 8;
        else if (flags & ImGuiComboFlags_HeightSmall)  popup_max_height_in_items = 4;
        else if (flags & ImGuiComboFlags_HeightLarge)  popup_max_height_in_items = 20;
        SetNextWindowSizeConstraints(ImVec2(w, 0.0f), ImVec2(FLT_MAX, CalcMaxPopupHeightFromItemCount(popup_max_height_in_items)));
    }

    char name[16];
    ImFormatString(name, IM_ARRAYSIZE(name), "##Combo_%02d", g.BeginPopupStack.Size); // Recycle windows based on depth

    // Peak into expected window size so we can position it
    if (ImGuiWindow* popup_window = FindWindowByName(name))
        if (popup_window->WasActive)
        {
            ImVec2 size_expected = CalcWindowExpectedSize(popup_window);
            if (flags & ImGuiComboFlags_PopupAlignLeft)
                popup_window->AutoPosLastDirection = ImGuiDir_Left;
            ImRect r_outer = GetWindowAllowedExtentRect(popup_window);
            ImVec2 pos = FindBestWindowPosForPopupEx(frame_bb.GetBL(), size_expected, &popup_window->AutoPosLastDirection, r_outer, frame_bb, ImGuiPopupPositionPolicy_ComboBox);
            SetNextWindowPos(pos);
        }

    // Horizontally align ourselves with the framed text
    ImGuiWindowFlags window_flags = ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_Popup | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings;
    PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(style.FramePadding.x, style.WindowPadding.y));
    bool ret = Begin(name, NULL, window_flags);
    PopStyleVar();
    if (!ret)
    {
        EndPopup();
        IM_ASSERT(0);   // This should never happen as we tested for IsPopupOpen() above
        return false;
    }
    return true;
}

void ImGui::EndCombo()
{
    EndPopup();
}

// Getter for the old Combo() API: const char*[]
static bool Items_ArrayGetter(void* data, int idx, const char** out_text)
{
    const char* const* items = (const char* const*)data;
    if (out_text)
        *out_text = items[idx];
    return true;
}

// Getter for the old Combo() API: "item1\0item2\0item3\0"
static bool Items_SingleStringGetter(void* data, int idx, const char** out_text)
{
    // FIXME-OPT: we could pre-compute the indices to fasten this. But only 1 active combo means the waste is limited.
    const char* items_separated_by_zeros = (const char*)data;
    int items_count = 0;
    const char* p = items_separated_by_zeros;
    while (*p)
    {
        if (idx == items_count)
            break;
        p += strlen(p) + 1;
        items_count++;
    }
    if (!*p)
        return false;
    if (out_text)
        *out_text = p;
    return true;
}

// Old API, prefer using BeginCombo() nowadays if you can.
bool ImGui::Combo(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int popup_max_height_in_items)
{
    ImGuiContext& g = *GImGui;

    // Call the getter to obtain the preview string which is a parameter to BeginCombo()
    const char* preview_value = NULL;
    if (*current_item >= 0 && *current_item < items_count)
        items_getter(data, *current_item, &preview_value);

    // The old Combo() API exposed "popup_max_height_in_items". The new more general BeginCombo() API doesn't have/need it, but we emulate it here.
    if (popup_max_height_in_items != -1 && !g.NextWindowData.SizeConstraintCond)
        SetNextWindowSizeConstraints(ImVec2(0,0), ImVec2(FLT_MAX, CalcMaxPopupHeightFromItemCount(popup_max_height_in_items)));

    if (!BeginCombo(label, preview_value, ImGuiComboFlags_None))
        return false;

    // Display items
    // FIXME-OPT: Use clipper (but we need to disable it on the appearing frame to make sure our call to SetItemDefaultFocus() is processed)
    bool value_changed = false;
    for (int i = 0; i < items_count; i++)
    {
        PushID((void*)(intptr_t)i);
        const bool item_selected = (i == *current_item);
        const char* item_text;
        if (!items_getter(data, i, &item_text))
            item_text = "*Unknown item*";
        if (Selectable(item_text, item_selected))
        {
            value_changed = true;
            *current_item = i;
        }
        if (item_selected)
            SetItemDefaultFocus();
        PopID();
    }

    EndCombo();
    return value_changed;
}

// Combo box helper allowing to pass an array of strings.
bool ImGui::Combo(const char* label, int* current_item, const char* const items[], int items_count, int height_in_items)
{
    const bool value_changed = Combo(label, current_item, Items_ArrayGetter, (void*)items, items_count, height_in_items);
    return value_changed;
}

// Combo box helper allowing to pass all items in a single string literal holding multiple zero-terminated items "item1\0item2\0"
bool ImGui::Combo(const char* label, int* current_item, const char* items_separated_by_zeros, int height_in_items)
{
    int items_count = 0;
    const char* p = items_separated_by_zeros;       // FIXME-OPT: Avoid computing this, or at least only when combo is open
    while (*p)
    {
        p += strlen(p) + 1;
        items_count++;
    }
    bool value_changed = Combo(label, current_item, Items_SingleStringGetter, (void*)items_separated_by_zeros, items_count, height_in_items);
    return value_changed;
}

//-------------------------------------------------------------------------
// [SECTION] Data Type and Data Formatting Helpers [Internal]
//-------------------------------------------------------------------------
// - PatchFormatStringFloatToInt()
// - DataTypeGetInfo()
// - DataTypeFormatString()
// - DataTypeApplyOp()
// - DataTypeApplyOpFromText()
// - GetMinimumStepAtDecimalPrecision
// - RoundScalarWithFormat<>()
//-------------------------------------------------------------------------

static const ImGuiDataTypeInfo GDataTypeInfo[] =
{
    { sizeof(char),             "%d",   "%d"    },  // ImGuiDataType_S8
    { sizeof(unsigned char),    "%u",   "%u"    },
    { sizeof(short),            "%d",   "%d"    },  // ImGuiDataType_S16
    { sizeof(unsigned short),   "%u",   "%u"    },
    { sizeof(int),              "%d",   "%d"    },  // ImGuiDataType_S32
    { sizeof(unsigned int),     "%u",   "%u"    },
#ifdef _MSC_VER
    { sizeof(ImS64),            "%I64d","%I64d" },  // ImGuiDataType_S64
    { sizeof(ImU64),            "%I64u","%I64u" },
#else
    { sizeof(ImS64),            "%lld", "%lld"  },  // ImGuiDataType_S64
    { sizeof(ImU64),            "%llu", "%llu"  },
#endif
    { sizeof(float),            "%f",   "%f"    },  // ImGuiDataType_Float (float are promoted to double in va_arg)
    { sizeof(double),           "%f",   "%lf"   },  // ImGuiDataType_Double
};
IM_STATIC_ASSERT(IM_ARRAYSIZE(GDataTypeInfo) == ImGuiDataType_COUNT);

// FIXME-LEGACY: Prior to 1.61 our DragInt() function internally used floats and because of this the compile-time default value for format was "%.0f".
// Even though we changed the compile-time default, we expect users to have carried %f around, which would break the display of DragInt() calls.
// To honor backward compatibility we are rewriting the format string, unless IMGUI_DISABLE_OBSOLETE_FUNCTIONS is enabled. What could possibly go wrong?!
static const char* PatchFormatStringFloatToInt(const char* fmt)
{
    if (fmt[0] == '%' && fmt[1] == '.' && fmt[2] == '0' && fmt[3] == 'f' && fmt[4] == 0) // Fast legacy path for "%.0f" which is expected to be the most common case.
        return "%d";
    const char* fmt_start = ImParseFormatFindStart(fmt);    // Find % (if any, and ignore %%)
    const char* fmt_end = ImParseFormatFindEnd(fmt_start);  // Find end of format specifier, which itself is an exercise of confidence/recklessness (because snprintf is dependent on libc or user).
    if (fmt_end > fmt_start && fmt_end[-1] == 'f')
    {
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
        if (fmt_start == fmt && fmt_end[0] == 0)
            return "%d";
        ImGuiContext& g = *GImGui;
        ImFormatString(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), "%.*s%%d%s", (int)(fmt_start - fmt), fmt, fmt_end); // Honor leading and trailing decorations, but lose alignment/precision.
        return g.TempBuffer;
#else
        IM_ASSERT(0 && "DragInt(): Invalid format string!"); // Old versions used a default parameter of "%.0f", please replace with e.g. "%d"
#endif
    }
    return fmt;
}

const ImGuiDataTypeInfo* ImGui::DataTypeGetInfo(ImGuiDataType data_type)
{
    IM_ASSERT(data_type >= 0 && data_type < ImGuiDataType_COUNT);
    return &GDataTypeInfo[data_type];
}

int ImGui::DataTypeFormatString(char* buf, int buf_size, ImGuiDataType data_type, const void* data_ptr, const char* format)
{
    // Signedness doesn't matter when pushing integer arguments
    if (data_type == ImGuiDataType_S32 || data_type == ImGuiDataType_U32)
        return ImFormatString(buf, buf_size, format, *(const ImU32*)data_ptr);
    if (data_type == ImGuiDataType_S64 || data_type == ImGuiDataType_U64)
        return ImFormatString(buf, buf_size, format, *(const ImU64*)data_ptr);
    if (data_type == ImGuiDataType_Float)
        return ImFormatString(buf, buf_size, format, *(const float*)data_ptr);
    if (data_type == ImGuiDataType_Double)
        return ImFormatString(buf, buf_size, format, *(const double*)data_ptr);
    if (data_type == ImGuiDataType_S8)
        return ImFormatString(buf, buf_size, format, *(const ImS8*)data_ptr);
    if (data_type == ImGuiDataType_U8)
        return ImFormatString(buf, buf_size, format, *(const ImU8*)data_ptr);
    if (data_type == ImGuiDataType_S16)
        return ImFormatString(buf, buf_size, format, *(const ImS16*)data_ptr);
    if (data_type == ImGuiDataType_U16)
        return ImFormatString(buf, buf_size, format, *(const ImU16*)data_ptr);
    IM_ASSERT(0);
    return 0;
}

void ImGui::DataTypeApplyOp(ImGuiDataType data_type, int op, void* output, void* arg1, const void* arg2)
{
    IM_ASSERT(op == '+' || op == '-');
    switch (data_type)
    {
        case ImGuiDataType_S8:
            if (op == '+') { *(ImS8*)output  = ImAddClampOverflow(*(const ImS8*)arg1,  *(const ImS8*)arg2,  IM_S8_MIN,  IM_S8_MAX); }
            if (op == '-') { *(ImS8*)output  = ImSubClampOverflow(*(const ImS8*)arg1,  *(const ImS8*)arg2,  IM_S8_MIN,  IM_S8_MAX); }
            return;
        case ImGuiDataType_U8:
            if (op == '+') { *(ImU8*)output  = ImAddClampOverflow(*(const ImU8*)arg1,  *(const ImU8*)arg2,  IM_U8_MIN,  IM_U8_MAX); }
            if (op == '-') { *(ImU8*)output  = ImSubClampOverflow(*(const ImU8*)arg1,  *(const ImU8*)arg2,  IM_U8_MIN,  IM_U8_MAX); }
            return;
        case ImGuiDataType_S16:
            if (op == '+') { *(ImS16*)output = ImAddClampOverflow(*(const ImS16*)arg1, *(const ImS16*)arg2, IM_S16_MIN, IM_S16_MAX); }
            if (op == '-') { *(ImS16*)output = ImSubClampOverflow(*(const ImS16*)arg1, *(const ImS16*)arg2, IM_S16_MIN, IM_S16_MAX); }
            return;
        case ImGuiDataType_U16:
            if (op == '+') { *(ImU16*)output = ImAddClampOverflow(*(const ImU16*)arg1, *(const ImU16*)arg2, IM_U16_MIN, IM_U16_MAX); }
            if (op == '-') { *(ImU16*)output = ImSubClampOverflow(*(const ImU16*)arg1, *(const ImU16*)arg2, IM_U16_MIN, IM_U16_MAX); }
            return;
        case ImGuiDataType_S32:
            if (op == '+') { *(ImS32*)output = ImAddClampOverflow(*(const ImS32*)arg1, *(const ImS32*)arg2, IM_S32_MIN, IM_S32_MAX); }
            if (op == '-') { *(ImS32*)output = ImSubClampOverflow(*(const ImS32*)arg1, *(const ImS32*)arg2, IM_S32_MIN, IM_S32_MAX); }
            return;
        case ImGuiDataType_U32:
            if (op == '+') { *(ImU32*)output = ImAddClampOverflow(*(const ImU32*)arg1, *(const ImU32*)arg2, IM_U32_MIN, IM_U32_MAX); }
            if (op == '-') { *(ImU32*)output = ImSubClampOverflow(*(const ImU32*)arg1, *(const ImU32*)arg2, IM_U32_MIN, IM_U32_MAX); }
            return;
        case ImGuiDataType_S64:
            if (op == '+') { *(ImS64*)output = ImAddClampOverflow(*(const ImS64*)arg1, *(const ImS64*)arg2, IM_S64_MIN, IM_S64_MAX); }
            if (op == '-') { *(ImS64*)output = ImSubClampOverflow(*(const ImS64*)arg1, *(const ImS64*)arg2, IM_S64_MIN, IM_S64_MAX); }
            return;
        case ImGuiDataType_U64:
            if (op == '+') { *(ImU64*)output = ImAddClampOverflow(*(const ImU64*)arg1, *(const ImU64*)arg2, IM_U64_MIN, IM_U64_MAX); }
            if (op == '-') { *(ImU64*)output = ImSubClampOverflow(*(const ImU64*)arg1, *(const ImU64*)arg2, IM_U64_MIN, IM_U64_MAX); }
            return;
        case ImGuiDataType_Float:
            if (op == '+') { *(float*)output = *(const float*)arg1 + *(const float*)arg2; }
            if (op == '-') { *(float*)output = *(const float*)arg1 - *(const float*)arg2; }
            return;
        case ImGuiDataType_Double:
            if (op == '+') { *(double*)output = *(const double*)arg1 + *(const double*)arg2; }
            if (op == '-') { *(double*)output = *(const double*)arg1 - *(const double*)arg2; }
            return;
        case ImGuiDataType_COUNT: break;
    }
    IM_ASSERT(0);
}

// User can input math operators (e.g. +100) to edit a numerical values.
// NB: This is _not_ a full expression evaluator. We should probably add one and replace this dumb mess..
bool ImGui::DataTypeApplyOpFromText(const char* buf, const char* initial_value_buf, ImGuiDataType data_type, void* data_ptr, const char* format)
{
    while (ImCharIsBlankA(*buf))
        buf++;

    // We don't support '-' op because it would conflict with inputing negative value.
    // Instead you can use +-100 to subtract from an existing value
    char op = buf[0];
    if (op == '+' || op == '*' || op == '/')
    {
        buf++;
        while (ImCharIsBlankA(*buf))
            buf++;
    }
    else
    {
        op = 0;
    }
    if (!buf[0])
        return false;

    // Copy the value in an opaque buffer so we can compare at the end of the function if it changed at all.
    IM_ASSERT(data_type < ImGuiDataType_COUNT);
    int data_backup[2];
    const ImGuiDataTypeInfo* type_info = ImGui::DataTypeGetInfo(data_type);
    IM_ASSERT(type_info->Size <= sizeof(data_backup));
    memcpy(data_backup, data_ptr, type_info->Size);

    if (format == NULL)
        format = type_info->ScanFmt;

    // FIXME-LEGACY: The aim is to remove those operators and write a proper expression evaluator at some point..
    int arg1i = 0;
    if (data_type == ImGuiDataType_S32)
    {
        int* v = (int*)data_ptr;
        int arg0i = *v;
        float arg1f = 0.0f;
        if (op && sscanf(initial_value_buf, format, &arg0i) < 1)
            return false;
        // Store operand in a float so we can use fractional value for multipliers (*1.1), but constant always parsed as integer so we can fit big integers (e.g. 2000000003) past float precision
        if (op == '+')      { if (sscanf(buf, "%d", &arg1i)) *v = (int)(arg0i + arg1i); }                   // Add (use "+-" to subtract)
        else if (op == '*') { if (sscanf(buf, "%f", &arg1f)) *v = (int)(arg0i * arg1f); }                   // Multiply
        else if (op == '/') { if (sscanf(buf, "%f", &arg1f) && arg1f != 0.0f) *v = (int)(arg0i / arg1f); }  // Divide
        else                { if (sscanf(buf, format, &arg1i) == 1) *v = arg1i; }                           // Assign constant
    }
    else if (data_type == ImGuiDataType_Float)
    {
        // For floats we have to ignore format with precision (e.g. "%.2f") because sscanf doesn't take them in
        format = "%f";
        float* v = (float*)data_ptr;
        float arg0f = *v, arg1f = 0.0f;
        if (op && sscanf(initial_value_buf, format, &arg0f) < 1)
            return false;
        if (sscanf(buf, format, &arg1f) < 1)
            return false;
        if (op == '+')      { *v = arg0f + arg1f; }                    // Add (use "+-" to subtract)
        else if (op == '*') { *v = arg0f * arg1f; }                    // Multiply
        else if (op == '/') { if (arg1f != 0.0f) *v = arg0f / arg1f; } // Divide
        else                { *v = arg1f; }                            // Assign constant
    }
    else if (data_type == ImGuiDataType_Double)
    {
        format = "%lf"; // scanf differentiate float/double unlike printf which forces everything to double because of ellipsis
        double* v = (double*)data_ptr;
        double arg0f = *v, arg1f = 0.0;
        if (op && sscanf(initial_value_buf, format, &arg0f) < 1)
            return false;
        if (sscanf(buf, format, &arg1f) < 1)
            return false;
        if (op == '+')      { *v = arg0f + arg1f; }                    // Add (use "+-" to subtract)
        else if (op == '*') { *v = arg0f * arg1f; }                    // Multiply
        else if (op == '/') { if (arg1f != 0.0f) *v = arg0f / arg1f; } // Divide
        else                { *v = arg1f; }                            // Assign constant
    }
    else if (data_type == ImGuiDataType_U32 || data_type == ImGuiDataType_S64 || data_type == ImGuiDataType_U64)
    {
        // All other types assign constant
        // We don't bother handling support for legacy operators since they are a little too crappy. Instead we will later implement a proper expression evaluator in the future.
        sscanf(buf, format, data_ptr);
    }
    else
    {
        // Small types need a 32-bit buffer to receive the result from scanf()
        int v32;
        sscanf(buf, format, &v32);
        if (data_type == ImGuiDataType_S8)
            *(ImS8*)data_ptr = (ImS8)ImClamp(v32, (int)IM_S8_MIN, (int)IM_S8_MAX);
        else if (data_type == ImGuiDataType_U8)
            *(ImU8*)data_ptr = (ImU8)ImClamp(v32, (int)IM_U8_MIN, (int)IM_U8_MAX);
        else if (data_type == ImGuiDataType_S16)
            *(ImS16*)data_ptr = (ImS16)ImClamp(v32, (int)IM_S16_MIN, (int)IM_S16_MAX);
        else if (data_type == ImGuiDataType_U16)
            *(ImU16*)data_ptr = (ImU16)ImClamp(v32, (int)IM_U16_MIN, (int)IM_U16_MAX);
        else
            IM_ASSERT(0);
    }

    return memcmp(data_backup, data_ptr, type_info->Size) != 0;
}

static float GetMinimumStepAtDecimalPrecision(int decimal_precision)
{
    static const float min_steps[10] = { 1.0f, 0.1f, 0.01f, 0.001f, 0.0001f, 0.00001f, 0.000001f, 0.0000001f, 0.00000001f, 0.000000001f };
    if (decimal_precision < 0)
        return FLT_MIN;
    return (decimal_precision < IM_ARRAYSIZE(min_steps)) ? min_steps[decimal_precision] : ImPow(10.0f, (float)-decimal_precision);
}

template<typename TYPE>
static const char* ImAtoi(const char* src, TYPE* output)
{
    int negative = 0;
    if (*src == '-') { negative = 1; src++; }
    if (*src == '+') { src++; }
    TYPE v = 0;
    while (*src >= '0' && *src <= '9')
        v = (v * 10) + (*src++ - '0');
    *output = negative ? -v : v;
    return src;
}

template<typename TYPE, typename SIGNEDTYPE>
TYPE ImGui::RoundScalarWithFormatT(const char* format, ImGuiDataType data_type, TYPE v)
{
    const char* fmt_start = ImParseFormatFindStart(format);
    if (fmt_start[0] != '%' || fmt_start[1] == '%') // Don't apply if the value is not visible in the format string
        return v;
    char v_str[64];
    ImFormatString(v_str, IM_ARRAYSIZE(v_str), fmt_start, v);
    const char* p = v_str;
    while (*p == ' ')
        p++;
    if (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double)
        v = (TYPE)ImAtof(p);
    else
        ImAtoi(p, (SIGNEDTYPE*)&v);
    return v;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: DragScalar, DragFloat, DragInt, etc.
//-------------------------------------------------------------------------
// - DragBehaviorT<>() [Internal]
// - DragBehavior() [Internal]
// - DragScalar()
// - DragScalarN()
// - DragFloat()
// - DragFloat2()
// - DragFloat3()
// - DragFloat4()
// - DragFloatRange2()
// - DragInt()
// - DragInt2()
// - DragInt3()
// - DragInt4()
// - DragIntRange2()
//-------------------------------------------------------------------------

// This is called by DragBehavior() when the widget is active (held by mouse or being manipulated with Nav controls)
template<typename TYPE, typename SIGNEDTYPE, typename FLOATTYPE>
bool ImGui::DragBehaviorT(ImGuiDataType data_type, TYPE* v, float v_speed, const TYPE v_min, const TYPE v_max, const char* format, float power, ImGuiDragFlags flags)
{
    ImGuiContext& g = *GImGui;
    const ImGuiAxis axis = (flags & ImGuiDragFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;
    const bool is_decimal = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);
    const bool has_min_max = (v_min != v_max);
    const bool is_power = (power != 1.0f && is_decimal && has_min_max && (v_max - v_min < FLT_MAX));

    // Default tweak speed
    if (v_speed == 0.0f && has_min_max && (v_max - v_min < FLT_MAX))
        v_speed = (float)((v_max - v_min) * g.DragSpeedDefaultRatio);

    // Inputs accumulates into g.DragCurrentAccum, which is flushed into the current value as soon as it makes a difference with our precision settings
    float adjust_delta = 0.0f;
    if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && g.IO.MouseDragMaxDistanceSqr[0] > 1.0f*1.0f)
    {
        adjust_delta = g.IO.MouseDelta[axis];
        if (g.IO.KeyAlt)
            adjust_delta *= 1.0f / 100.0f;
        if (g.IO.KeyShift)
            adjust_delta *= 10.0f;
    }
    else if (g.ActiveIdSource == ImGuiInputSource_Nav)
    {
        int decimal_precision = is_decimal ? ImParseFormatPrecision(format, 3) : 0;
        adjust_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard | ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_RepeatFast, 1.0f / 10.0f, 10.0f)[axis];
        v_speed = ImMax(v_speed, GetMinimumStepAtDecimalPrecision(decimal_precision));
    }
    adjust_delta *= v_speed;

    // For vertical drag we currently assume that Up=higher value (like we do with vertical sliders). This may become a parameter.
    if (axis == ImGuiAxis_Y)
        adjust_delta = -adjust_delta;

    // Clear current value on activation
    // Avoid altering values and clamping when we are _already_ past the limits and heading in the same direction, so e.g. if range is 0..255, current value is 300 and we are pushing to the right side, keep the 300.
    bool is_just_activated = g.ActiveIdIsJustActivated;
    bool is_already_past_limits_and_pushing_outward = has_min_max && ((*v >= v_max && adjust_delta > 0.0f) || (*v <= v_min && adjust_delta < 0.0f));
    bool is_drag_direction_change_with_power = is_power && ((adjust_delta < 0 && g.DragCurrentAccum > 0) || (adjust_delta > 0 && g.DragCurrentAccum < 0));
    if (is_just_activated || is_already_past_limits_and_pushing_outward || is_drag_direction_change_with_power)
    {
        g.DragCurrentAccum = 0.0f;
        g.DragCurrentAccumDirty = false;
    }
    else if (adjust_delta != 0.0f)
    {
        g.DragCurrentAccum += adjust_delta;
        g.DragCurrentAccumDirty = true;
    }

    if (!g.DragCurrentAccumDirty)
        return false;

    TYPE v_cur = *v;
    FLOATTYPE v_old_ref_for_accum_remainder = (FLOATTYPE)0.0f;

    if (is_power)
    {
        // Offset + round to user desired precision, with a curve on the v_min..v_max range to get more precision on one side of the range
        FLOATTYPE v_old_norm_curved = ImPow((FLOATTYPE)(v_cur - v_min) / (FLOATTYPE)(v_max - v_min), (FLOATTYPE)1.0f / power);
        FLOATTYPE v_new_norm_curved = v_old_norm_curved + (g.DragCurrentAccum / (v_max - v_min));
        v_cur = v_min + (TYPE)ImPow(ImSaturate((float)v_new_norm_curved), power) * (v_max - v_min);
        v_old_ref_for_accum_remainder = v_old_norm_curved;
    }
    else
    {
        v_cur += (TYPE)g.DragCurrentAccum;
    }

    // Round to user desired precision based on format string
    v_cur = RoundScalarWithFormatT<TYPE, SIGNEDTYPE>(format, data_type, v_cur);

    // Preserve remainder after rounding has been applied. This also allow slow tweaking of values.
    g.DragCurrentAccumDirty = false;
    if (is_power)
    {
        FLOATTYPE v_cur_norm_curved = ImPow((FLOATTYPE)(v_cur - v_min) / (FLOATTYPE)(v_max - v_min), (FLOATTYPE)1.0f / power);
        g.DragCurrentAccum -= (float)(v_cur_norm_curved - v_old_ref_for_accum_remainder);
    }
    else
    {
        g.DragCurrentAccum -= (float)((SIGNEDTYPE)v_cur - (SIGNEDTYPE)*v);
    }

    // Lose zero sign for float/double
    if (v_cur == (TYPE)-0)
        v_cur = (TYPE)0;

    // Clamp values (+ handle overflow/wrap-around for integer types)
    if (*v != v_cur && has_min_max)
    {
        if (v_cur < v_min || (v_cur > *v && adjust_delta < 0.0f && !is_decimal))
            v_cur = v_min;
        if (v_cur > v_max || (v_cur < *v && adjust_delta > 0.0f && !is_decimal))
            v_cur = v_max;
    }

    // Apply result
    if (*v == v_cur)
        return false;
    *v = v_cur;
    return true;
}

bool ImGui::DragBehavior(ImGuiID id, ImGuiDataType data_type, void* v, float v_speed, const void* v_min, const void* v_max, const char* format, float power, ImGuiDragFlags flags)
{
    ImGuiContext& g = *GImGui;
    if (g.ActiveId == id)
    {
        if (g.ActiveIdSource == ImGuiInputSource_Mouse && !g.IO.MouseDown[0])
            ClearActiveID();
        else if (g.ActiveIdSource == ImGuiInputSource_Nav && g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)
            ClearActiveID();
    }
    if (g.ActiveId != id)
        return false;

    switch (data_type)
    {
    case ImGuiDataType_S8:     { ImS32 v32 = (ImS32)*(ImS8*)v;  bool r = DragBehaviorT<ImS32, ImS32, float >(ImGuiDataType_S32, &v32, v_speed, v_min ? *(const ImS8*) v_min : IM_S8_MIN,  v_max ? *(const ImS8*)v_max  : IM_S8_MAX,  format, power, flags); if (r) *(ImS8*)v = (ImS8)v32; return r; }
    case ImGuiDataType_U8:     { ImU32 v32 = (ImU32)*(ImU8*)v;  bool r = DragBehaviorT<ImU32, ImS32, float >(ImGuiDataType_U32, &v32, v_speed, v_min ? *(const ImU8*) v_min : IM_U8_MIN,  v_max ? *(const ImU8*)v_max  : IM_U8_MAX,  format, power, flags); if (r) *(ImU8*)v = (ImU8)v32; return r; }
    case ImGuiDataType_S16:    { ImS32 v32 = (ImS32)*(ImS16*)v; bool r = DragBehaviorT<ImS32, ImS32, float >(ImGuiDataType_S32, &v32, v_speed, v_min ? *(const ImS16*)v_min : IM_S16_MIN, v_max ? *(const ImS16*)v_max : IM_S16_MAX, format, power, flags); if (r) *(ImS16*)v = (ImS16)v32; return r; }
    case ImGuiDataType_U16:    { ImU32 v32 = (ImU32)*(ImU16*)v; bool r = DragBehaviorT<ImU32, ImS32, float >(ImGuiDataType_U32, &v32, v_speed, v_min ? *(const ImU16*)v_min : IM_U16_MIN, v_max ? *(const ImU16*)v_max : IM_U16_MAX, format, power, flags); if (r) *(ImU16*)v = (ImU16)v32; return r; }
    case ImGuiDataType_S32:    return DragBehaviorT<ImS32, ImS32, float >(data_type, (ImS32*)v,  v_speed, v_min ? *(const ImS32* )v_min : IM_S32_MIN, v_max ? *(const ImS32* )v_max : IM_S32_MAX, format, power, flags);
    case ImGuiDataType_U32:    return DragBehaviorT<ImU32, ImS32, float >(data_type, (ImU32*)v,  v_speed, v_min ? *(const ImU32* )v_min : IM_U32_MIN, v_max ? *(const ImU32* )v_max : IM_U32_MAX, format, power, flags);
    case ImGuiDataType_S64:    return DragBehaviorT<ImS64, ImS64, double>(data_type, (ImS64*)v,  v_speed, v_min ? *(const ImS64* )v_min : IM_S64_MIN, v_max ? *(const ImS64* )v_max : IM_S64_MAX, format, power, flags);
    case ImGuiDataType_U64:    return DragBehaviorT<ImU64, ImS64, double>(data_type, (ImU64*)v,  v_speed, v_min ? *(const ImU64* )v_min : IM_U64_MIN, v_max ? *(const ImU64* )v_max : IM_U64_MAX, format, power, flags);
    case ImGuiDataType_Float:  return DragBehaviorT<float, float, float >(data_type, (float*)v,  v_speed, v_min ? *(const float* )v_min : -FLT_MAX,   v_max ? *(const float* )v_max : FLT_MAX,    format, power, flags);
    case ImGuiDataType_Double: return DragBehaviorT<double,double,double>(data_type, (double*)v, v_speed, v_min ? *(const double*)v_min : -DBL_MAX,   v_max ? *(const double*)v_max : DBL_MAX,    format, power, flags);
    case ImGuiDataType_COUNT:  break;
    }
    IM_ASSERT(0);
    return false;
}

bool ImGui::DragScalar(const char* label, ImGuiDataType data_type, void* v, float v_speed, const void* v_min, const void* v_max, const char* format, float power)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    if (power != 1.0f)
        IM_ASSERT(v_min != NULL && v_max != NULL); // When using a power curve the drag needs to have known bounds

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const ImGuiID id = window->GetID(label);
    const float w = GetNextItemWidth();

    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2.0f));
    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

    ItemSize(total_bb, style.FramePadding.y);
    if (!ItemAdd(total_bb, id, &frame_bb))
        return false;

    // Default format string when passing NULL
    if (format == NULL)
        format = DataTypeGetInfo(data_type)->PrintFmt;
    else if (data_type == ImGuiDataType_S32 && strcmp(format, "%d") != 0) // (FIXME-LEGACY: Patch old "%.0f" format string to use "%d", read function more details.)
        format = PatchFormatStringFloatToInt(format);

    // Tabbing or CTRL-clicking on Drag turns it into an input box
    const bool hovered = ItemHoverable(frame_bb, id);
    bool temp_input_is_active = TempInputTextIsActive(id);
    bool temp_input_start = false;
    if (!temp_input_is_active)
    {
        const bool focus_requested = FocusableItemRegister(window, id);
        const bool clicked = (hovered && g.IO.MouseClicked[0]);
        const bool double_clicked = (hovered && g.IO.MouseDoubleClicked[0]);
        if (focus_requested || clicked || double_clicked || g.NavActivateId == id || g.NavInputId == id)
        {
            SetActiveID(id, window);
            SetFocusID(id, window);
            FocusWindow(window);
            g.ActiveIdAllowNavDirFlags = (1 << ImGuiDir_Up) | (1 << ImGuiDir_Down);
            if (focus_requested || (clicked && g.IO.KeyCtrl) || double_clicked || g.NavInputId == id)
            {
                temp_input_start = true;
                FocusableItemUnregister(window);
            }
        }
    }
    if (temp_input_is_active || temp_input_start)
        return TempInputTextScalar(frame_bb, id, label, data_type, v, format);

    // Draw frame
    const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : g.HoveredId == id ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);
    RenderNavHighlight(frame_bb, id);
    RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, style.FrameRounding);

    // Drag behavior
    const bool value_changed = DragBehavior(id, data_type, v, v_speed, v_min, v_max, format, power, ImGuiDragFlags_None);
    if (value_changed)
        MarkItemEdited(id);

    // Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
    char value_buf[64];
    const char* value_buf_end = value_buf + DataTypeFormatString(value_buf, IM_ARRAYSIZE(value_buf), data_type, v, format);
    RenderTextClipped(frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f, 0.5f));

    if (label_size.x > 0.0f)
        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.ItemFlags);
    return value_changed;
}

bool ImGui::DragScalarN(const char* label, ImGuiDataType data_type, void* v, int components, float v_speed, const void* v_min, const void* v_max, const char* format, float power)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    bool value_changed = false;
    BeginGroup();
    PushID(label);
    PushMultiItemsWidths(components, GetNextItemWidth());
    size_t type_size = GDataTypeInfo[data_type].Size;
    for (int i = 0; i < components; i++)
    {
        PushID(i);
        value_changed |= DragScalar("", data_type, v, v_speed, v_min, v_max, format, power);
        SameLine(0, g.Style.ItemInnerSpacing.x);
        PopID();
        PopItemWidth();
        v = (void*)((char*)v + type_size);
    }
    PopID();

    TextEx(label, FindRenderedTextEnd(label));
    EndGroup();
    return value_changed;
}

bool ImGui::DragFloat(const char* label, float* v, float v_speed, float v_min, float v_max, const char* format, float power)
{
    return DragScalar(label, ImGuiDataType_Float, v, v_speed, &v_min, &v_max, format, power);
}

bool ImGui::DragFloat2(const char* label, float v[2], float v_speed, float v_min, float v_max, const char* format, float power)
{
    return DragScalarN(label, ImGuiDataType_Float, v, 2, v_speed, &v_min, &v_max, format, power);
}

bool ImGui::DragFloat3(const char* label, float v[3], float v_speed, float v_min, float v_max, const char* format, float power)
{
    return DragScalarN(label, ImGuiDataType_Float, v, 3, v_speed, &v_min, &v_max, format, power);
}

bool ImGui::DragFloat4(const char* label, float v[4], float v_speed, float v_min, float v_max, const char* format, float power)
{
    return DragScalarN(label, ImGuiDataType_Float, v, 4, v_speed, &v_min, &v_max, format, power);
}

bool ImGui::DragFloatRange2(const char* label, float* v_current_min, float* v_current_max, float v_speed, float v_min, float v_max, const char* format, const char* format_max, float power)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    PushID(label);
    BeginGroup();
    PushMultiItemsWidths(2, GetNextItemWidth());

    bool value_changed = DragFloat("##min", v_current_min, v_speed, (v_min >= v_max) ? -FLT_MAX : v_min, (v_min >= v_max) ? *v_current_max : ImMin(v_max, *v_current_max), format, power);
    PopItemWidth();
    SameLine(0, g.Style.ItemInnerSpacing.x);
    value_changed |= DragFloat("##max", v_current_max, v_speed, (v_min >= v_max) ? *v_current_min : ImMax(v_min, *v_current_min), (v_min >= v_max) ? FLT_MAX : v_max, format_max ? format_max : format, power);
    PopItemWidth();
    SameLine(0, g.Style.ItemInnerSpacing.x);

    TextEx(label, FindRenderedTextEnd(label));
    EndGroup();
    PopID();
    return value_changed;
}

// NB: v_speed is float to allow adjusting the drag speed with more precision
bool ImGui::DragInt(const char* label, int* v, float v_speed, int v_min, int v_max, const char* format)
{
    return DragScalar(label, ImGuiDataType_S32, v, v_speed, &v_min, &v_max, format);
}

bool ImGui::DragInt2(const char* label, int v[2], float v_speed, int v_min, int v_max, const char* format)
{
    return DragScalarN(label, ImGuiDataType_S32, v, 2, v_speed, &v_min, &v_max, format);
}

bool ImGui::DragInt3(const char* label, int v[3], float v_speed, int v_min, int v_max, const char* format)
{
    return DragScalarN(label, ImGuiDataType_S32, v, 3, v_speed, &v_min, &v_max, format);
}

bool ImGui::DragInt4(const char* label, int v[4], float v_speed, int v_min, int v_max, const char* format)
{
    return DragScalarN(label, ImGuiDataType_S32, v, 4, v_speed, &v_min, &v_max, format);
}

bool ImGui::DragIntRange2(const char* label, int* v_current_min, int* v_current_max, float v_speed, int v_min, int v_max, const char* format, const char* format_max)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    PushID(label);
    BeginGroup();
    PushMultiItemsWidths(2, GetNextItemWidth());

    bool value_changed = DragInt("##min", v_current_min, v_speed, (v_min >= v_max) ? INT_MIN : v_min, (v_min >= v_max) ? *v_current_max : ImMin(v_max, *v_current_max), format);
    PopItemWidth();
    SameLine(0, g.Style.ItemInnerSpacing.x);
    value_changed |= DragInt("##max", v_current_max, v_speed, (v_min >= v_max) ? *v_current_min : ImMax(v_min, *v_current_min), (v_min >= v_max) ? INT_MAX : v_max, format_max ? format_max : format);
    PopItemWidth();
    SameLine(0, g.Style.ItemInnerSpacing.x);

    TextEx(label, FindRenderedTextEnd(label));
    EndGroup();
    PopID();

    return value_changed;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: SliderScalar, SliderFloat, SliderInt, etc.
//-------------------------------------------------------------------------
// - SliderBehaviorT<>() [Internal]
// - SliderBehavior() [Internal]
// - SliderScalar()
// - SliderScalarN()
// - SliderFloat()
// - SliderFloat2()
// - SliderFloat3()
// - SliderFloat4()
// - SliderAngle()
// - SliderInt()
// - SliderInt2()
// - SliderInt3()
// - SliderInt4()
// - VSliderScalar()
// - VSliderFloat()
// - VSliderInt()
//-------------------------------------------------------------------------

template<typename TYPE, typename FLOATTYPE>
float ImGui::SliderCalcRatioFromValueT(ImGuiDataType data_type, TYPE v, TYPE v_min, TYPE v_max, float power, float linear_zero_pos)
{
    if (v_min == v_max)
        return 0.0f;

    const bool is_power = (power != 1.0f) && (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double);
    const TYPE v_clamped = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);
    if (is_power)
    {
        if (v_clamped < 0.0f)
        {
            const float f = 1.0f - (float)((v_clamped - v_min) / (ImMin((TYPE)0, v_max) - v_min));
            return (1.0f - ImPow(f, 1.0f/power)) * linear_zero_pos;
        }
        else
        {
            const float f = (float)((v_clamped - ImMax((TYPE)0, v_min)) / (v_max - ImMax((TYPE)0, v_min)));
            return linear_zero_pos + ImPow(f, 1.0f/power) * (1.0f - linear_zero_pos);
        }
    }

    // Linear slider
    return (float)((FLOATTYPE)(v_clamped - v_min) / (FLOATTYPE)(v_max - v_min));
}

// FIXME: Move some of the code into SliderBehavior(). Current responsability is larger than what the equivalent DragBehaviorT<> does, we also do some rendering, etc.
template<typename TYPE, typename SIGNEDTYPE, typename FLOATTYPE>
bool ImGui::SliderBehaviorT(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, TYPE* v, const TYPE v_min, const TYPE v_max, const char* format, float power, ImGuiSliderFlags flags, ImRect* out_grab_bb)
{
    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;

    const ImGuiAxis axis = (flags & ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;
    const bool is_decimal = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);
    const bool is_power = (power != 1.0f) && is_decimal;

    const float grab_padding = 2.0f;
    const float slider_sz = (bb.Max[axis] - bb.Min[axis]) - grab_padding * 2.0f;
    float grab_sz = style.GrabMinSize;
    SIGNEDTYPE v_range = (v_min < v_max ? v_max - v_min : v_min - v_max);
    if (!is_decimal && v_range >= 0)                                             // v_range < 0 may happen on integer overflows
        grab_sz = ImMax((float)(slider_sz / (v_range + 1)), style.GrabMinSize);  // For integer sliders: if possible have the grab size represent 1 unit
    grab_sz = ImMin(grab_sz, slider_sz);
    const float slider_usable_sz = slider_sz - grab_sz;
    const float slider_usable_pos_min = bb.Min[axis] + grab_padding + grab_sz * 0.5f;
    const float slider_usable_pos_max = bb.Max[axis] - grab_padding - grab_sz * 0.5f;

    // For power curve sliders that cross over sign boundary we want the curve to be symmetric around 0.0f
    float linear_zero_pos;   // 0.0->1.0f
    if (is_power && v_min * v_max < 0.0f)
    {
        // Different sign
        const FLOATTYPE linear_dist_min_to_0 = ImPow(v_min >= 0 ? (FLOATTYPE)v_min : -(FLOATTYPE)v_min, (FLOATTYPE)1.0f / power);
        const FLOATTYPE linear_dist_max_to_0 = ImPow(v_max >= 0 ? (FLOATTYPE)v_max : -(FLOATTYPE)v_max, (FLOATTYPE)1.0f / power);
        linear_zero_pos = (float)(linear_dist_min_to_0 / (linear_dist_min_to_0 + linear_dist_max_to_0));
    }
    else
    {
        // Same sign
        linear_zero_pos = v_min < 0.0f ? 1.0f : 0.0f;
    }

    // Process interacting with the slider
    bool value_changed = false;
    if (g.ActiveId == id)
    {
        bool set_new_value = false;
        float clicked_t = 0.0f;
        if (g.ActiveIdSource == ImGuiInputSource_Mouse)
        {
            if (!g.IO.MouseDown[0])
            {
                ClearActiveID();
            }
            else
            {
                const float mouse_abs_pos = g.IO.MousePos[axis];
                clicked_t = (slider_usable_sz > 0.0f) ? ImClamp((mouse_abs_pos - slider_usable_pos_min) / slider_usable_sz, 0.0f, 1.0f) : 0.0f;
                if (axis == ImGuiAxis_Y)
                    clicked_t = 1.0f - clicked_t;
                set_new_value = true;
            }
        }
        else if (g.ActiveIdSource == ImGuiInputSource_Nav)
        {
            const ImVec2 delta2 = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard | ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_RepeatFast, 0.0f, 0.0f);
            float delta = (axis == ImGuiAxis_X) ? delta2.x : -delta2.y;
            if (g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)
            {
                ClearActiveID();
            }
            else if (delta != 0.0f)
            {
                clicked_t = SliderCalcRatioFromValueT<TYPE,FLOATTYPE>(data_type, *v, v_min, v_max, power, linear_zero_pos);
                const int decimal_precision = is_decimal ? ImParseFormatPrecision(format, 3) : 0;
                if ((decimal_precision > 0) || is_power)
                {
                    delta /= 100.0f;    // Gamepad/keyboard tweak speeds in % of slider bounds
                    if (IsNavInputDown(ImGuiNavInput_TweakSlow))
                        delta /= 10.0f;
                }
                else
                {
                    if ((v_range >= -100.0f && v_range <= 100.0f) || IsNavInputDown(ImGuiNavInput_TweakSlow))
                        delta = ((delta < 0.0f) ? -1.0f : +1.0f) / (float)v_range; // Gamepad/keyboard tweak speeds in integer steps
                    else
                        delta /= 100.0f;
                }
                if (IsNavInputDown(ImGuiNavInput_TweakFast))
                    delta *= 10.0f;
                set_new_value = true;
                if ((clicked_t >= 1.0f && delta > 0.0f) || (clicked_t <= 0.0f && delta < 0.0f)) // This is to avoid applying the saturation when already past the limits
                    set_new_value = false;
                else
                    clicked_t = ImSaturate(clicked_t + delta);
            }
        }

        if (set_new_value)
        {
            TYPE v_new;
            if (is_power)
            {
                // Account for power curve scale on both sides of the zero
                if (clicked_t < linear_zero_pos)
                {
                    // Negative: rescale to the negative range before powering
                    float a = 1.0f - (clicked_t / linear_zero_pos);
                    a = ImPow(a, power);
                    v_new = ImLerp(ImMin(v_max, (TYPE)0), v_min, a);
                }
                else
                {
                    // Positive: rescale to the positive range before powering
                    float a;
                    if (ImFabs(linear_zero_pos - 1.0f) > 1.e-6f)
                        a = (clicked_t - linear_zero_pos) / (1.0f - linear_zero_pos);
                    else
                        a = clicked_t;
                    a = ImPow(a, power);
                    v_new = ImLerp(ImMax(v_min, (TYPE)0), v_max, a);
                }
            }
            else
            {
                // Linear slider
                if (is_decimal)
                {
                    v_new = ImLerp(v_min, v_max, clicked_t);
                }
                else
                {
                    // For integer values we want the clicking position to match the grab box so we round above
                    // This code is carefully tuned to work with large values (e.g. high ranges of U64) while preserving this property..
                    FLOATTYPE v_new_off_f = (v_max - v_min) * clicked_t;
                    TYPE v_new_off_floor = (TYPE)(v_new_off_f);
                    TYPE v_new_off_round = (TYPE)(v_new_off_f + (FLOATTYPE)0.5);
                    if (!is_decimal && v_new_off_floor < v_new_off_round)
                        v_new = v_min + v_new_off_round;
                    else
                        v_new = v_min + v_new_off_floor;
                }
            }

            // Round to user desired precision based on format string
            v_new = RoundScalarWithFormatT<TYPE,SIGNEDTYPE>(format, data_type, v_new);

            // Apply result
            if (*v != v_new)
            {
                *v = v_new;
                value_changed = true;
            }
        }
    }

    if (slider_sz < 1.0f)
    {
        *out_grab_bb = ImRect(bb.Min, bb.Min);
    }
    else
    {
        // Output grab position so it can be displayed by the caller
        float grab_t = SliderCalcRatioFromValueT<TYPE, FLOATTYPE>(data_type, *v, v_min, v_max, power, linear_zero_pos);
        if (axis == ImGuiAxis_Y)
            grab_t = 1.0f - grab_t;
        const float grab_pos = ImLerp(slider_usable_pos_min, slider_usable_pos_max, grab_t);
        if (axis == ImGuiAxis_X)
            *out_grab_bb = ImRect(grab_pos - grab_sz * 0.5f, bb.Min.y + grab_padding, grab_pos + grab_sz * 0.5f, bb.Max.y - grab_padding);
        else
            *out_grab_bb = ImRect(bb.Min.x + grab_padding, grab_pos - grab_sz * 0.5f, bb.Max.x - grab_padding, grab_pos + grab_sz * 0.5f);
    }

    return value_changed;
}

// For 32-bits and larger types, slider bounds are limited to half the natural type range.
// So e.g. an integer Slider between INT_MAX-10 and INT_MAX will fail, but an integer Slider between INT_MAX/2-10 and INT_MAX/2 will be ok.
// It would be possible to lift that limitation with some work but it doesn't seem to be worth it for sliders.
bool ImGui::SliderBehavior(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, void* v, const void* v_min, const void* v_max, const char* format, float power, ImGuiSliderFlags flags, ImRect* out_grab_bb)
{
    switch (data_type)
    {
    case ImGuiDataType_S8:  { ImS32 v32 = (ImS32)*(ImS8*)v;  bool r = SliderBehaviorT<ImS32, ImS32, float >(bb, id, ImGuiDataType_S32, &v32, *(const ImS8*)v_min,  *(const ImS8*)v_max,  format, power, flags, out_grab_bb); if (r) *(ImS8*)v  = (ImS8)v32;  return r; }
    case ImGuiDataType_U8:  { ImU32 v32 = (ImU32)*(ImU8*)v;  bool r = SliderBehaviorT<ImU32, ImS32, float >(bb, id, ImGuiDataType_U32, &v32, *(const ImU8*)v_min,  *(const ImU8*)v_max,  format, power, flags, out_grab_bb); if (r) *(ImU8*)v  = (ImU8)v32;  return r; }
    case ImGuiDataType_S16: { ImS32 v32 = (ImS32)*(ImS16*)v; bool r = SliderBehaviorT<ImS32, ImS32, float >(bb, id, ImGuiDataType_S32, &v32, *(const ImS16*)v_min, *(const ImS16*)v_max, format, power, flags, out_grab_bb); if (r) *(ImS16*)v = (ImS16)v32; return r; }
    case ImGuiDataType_U16: { ImU32 v32 = (ImU32)*(ImU16*)v; bool r = SliderBehaviorT<ImU32, ImS32, float >(bb, id, ImGuiDataType_U32, &v32, *(const ImU16*)v_min, *(const ImU16*)v_max, format, power, flags, out_grab_bb); if (r) *(ImU16*)v = (ImU16)v32; return r; }
    case ImGuiDataType_S32:
        IM_ASSERT(*(const ImS32*)v_min >= IM_S32_MIN/2 && *(const ImS32*)v_max <= IM_S32_MAX/2);
        return SliderBehaviorT<ImS32, ImS32, float >(bb, id, data_type, (ImS32*)v,  *(const ImS32*)v_min,  *(const ImS32*)v_max,  format, power, flags, out_grab_bb);
    case ImGuiDataType_U32:
        IM_ASSERT(*(const ImU32*)v_min <= IM_U32_MAX/2);
        return SliderBehaviorT<ImU32, ImS32, float >(bb, id, data_type, (ImU32*)v,  *(const ImU32*)v_min,  *(const ImU32*)v_max,  format, power, flags, out_grab_bb);
    case ImGuiDataType_S64:
        IM_ASSERT(*(const ImS64*)v_min >= IM_S64_MIN/2 && *(const ImS64*)v_max <= IM_S64_MAX/2);
        return SliderBehaviorT<ImS64, ImS64, double>(bb, id, data_type, (ImS64*)v,  *(const ImS64*)v_min,  *(const ImS64*)v_max,  format, power, flags, out_grab_bb);
    case ImGuiDataType_U64:
        IM_ASSERT(*(const ImU64*)v_min <= IM_U64_MAX/2);
        return SliderBehaviorT<ImU64, ImS64, double>(bb, id, data_type, (ImU64*)v,  *(const ImU64*)v_min,  *(const ImU64*)v_max,  format, power, flags, out_grab_bb);
    case ImGuiDataType_Float:
        IM_ASSERT(*(const float*)v_min >= -FLT_MAX/2.0f && *(const float*)v_max <= FLT_MAX/2.0f);
        return SliderBehaviorT<float, float, float >(bb, id, data_type, (float*)v,  *(const float*)v_min,  *(const float*)v_max,  format, power, flags, out_grab_bb);
    case ImGuiDataType_Double:
        IM_ASSERT(*(const double*)v_min >= -DBL_MAX/2.0f && *(const double*)v_max <= DBL_MAX/2.0f);
        return SliderBehaviorT<double,double,double>(bb, id, data_type, (double*)v, *(const double*)v_min, *(const double*)v_max, format, power, flags, out_grab_bb);
    case ImGuiDataType_COUNT: break;
    }
    IM_ASSERT(0);
    return false;
}

bool ImGui::SliderScalar(const char* label, ImGuiDataType data_type, void* v, const void* v_min, const void* v_max, const char* format, float power)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const ImGuiID id = window->GetID(label);
    const float w = GetNextItemWidth();

    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2.0f));
    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

    ItemSize(total_bb, style.FramePadding.y);
    if (!ItemAdd(total_bb, id, &frame_bb))
        return false;

    // Default format string when passing NULL
    if (format == NULL)
        format = DataTypeGetInfo(data_type)->PrintFmt;
    else if (data_type == ImGuiDataType_S32 && strcmp(format, "%d") != 0) // (FIXME-LEGACY: Patch old "%.0f" format string to use "%d", read function more details.)
        format = PatchFormatStringFloatToInt(format);

    // Tabbing or CTRL-clicking on Slider turns it into an input box
    const bool hovered = ItemHoverable(frame_bb, id);
    bool temp_input_is_active = TempInputTextIsActive(id);
    bool temp_input_start = false;
    if (!temp_input_is_active)
    {
        const bool focus_requested = FocusableItemRegister(window, id);
        const bool clicked = (hovered && g.IO.MouseClicked[0]);
        if (focus_requested || clicked || g.NavActivateId == id || g.NavInputId == id)
        {
            SetActiveID(id, window);
            SetFocusID(id, window);
            FocusWindow(window);
            g.ActiveIdAllowNavDirFlags = (1 << ImGuiDir_Up) | (1 << ImGuiDir_Down);
            if (focus_requested || (clicked && g.IO.KeyCtrl) || g.NavInputId == id)
            {
                temp_input_start = true;
                FocusableItemUnregister(window);
            }
        }
    }
    if (temp_input_is_active || temp_input_start)
        return TempInputTextScalar(frame_bb, id, label, data_type, v, format);

    // Draw frame
    const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : g.HoveredId == id ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);
    RenderNavHighlight(frame_bb, id);
    RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, g.Style.FrameRounding);

    // Slider behavior
    ImRect grab_bb;
    const bool value_changed = SliderBehavior(frame_bb, id, data_type, v, v_min, v_max, format, power, ImGuiSliderFlags_None, &grab_bb);
    if (value_changed)
        MarkItemEdited(id);

    // Render grab
    if (grab_bb.Max.x > grab_bb.Min.x)
        window->DrawList->AddRectFilled(grab_bb.Min, grab_bb.Max, GetColorU32(g.ActiveId == id ? ImGuiCol_SliderGrabActive : ImGuiCol_SliderGrab), style.GrabRounding);

    // Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
    char value_buf[64];
    const char* value_buf_end = value_buf + DataTypeFormatString(value_buf, IM_ARRAYSIZE(value_buf), data_type, v, format);
    RenderTextClipped(frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f,0.5f));

    if (label_size.x > 0.0f)
        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.ItemFlags);
    return value_changed;
}

// Add multiple sliders on 1 line for compact edition of multiple components
bool ImGui::SliderScalarN(const char* label, ImGuiDataType data_type, void* v, int components, const void* v_min, const void* v_max, const char* format, float power)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    bool value_changed = false;
    BeginGroup();
    PushID(label);
    PushMultiItemsWidths(components, GetNextItemWidth());
    size_t type_size = GDataTypeInfo[data_type].Size;
    for (int i = 0; i < components; i++)
    {
        PushID(i);
        value_changed |= SliderScalar("", data_type, v, v_min, v_max, format, power);
        SameLine(0, g.Style.ItemInnerSpacing.x);
        PopID();
        PopItemWidth();
        v = (void*)((char*)v + type_size);
    }
    PopID();

    TextEx(label, FindRenderedTextEnd(label));
    EndGroup();
    return value_changed;
}

bool ImGui::SliderFloat(const char* label, float* v, float v_min, float v_max, const char* format, float power)
{
    return SliderScalar(label, ImGuiDataType_Float, v, &v_min, &v_max, format, power);
}

bool ImGui::SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* format, float power)
{
    return SliderScalarN(label, ImGuiDataType_Float, v, 2, &v_min, &v_max, format, power);
}

bool ImGui::SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* format, float power)
{
    return SliderScalarN(label, ImGuiDataType_Float, v, 3, &v_min, &v_max, format, power);
}

bool ImGui::SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* format, float power)
{
    return SliderScalarN(label, ImGuiDataType_Float, v, 4, &v_min, &v_max, format, power);
}

bool ImGui::SliderAngle(const char* label, float* v_rad, float v_degrees_min, float v_degrees_max, const char* format)
{
    if (format == NULL)
        format = "%.0f deg";
    float v_deg = (*v_rad) * 360.0f / (2*IM_PI);
    bool value_changed = SliderFloat(label, &v_deg, v_degrees_min, v_degrees_max, format, 1.0f);
    *v_rad = v_deg * (2*IM_PI) / 360.0f;
    return value_changed;
}

bool ImGui::SliderInt(const char* label, int* v, int v_min, int v_max, const char* format)
{
    return SliderScalar(label, ImGuiDataType_S32, v, &v_min, &v_max, format);
}

bool ImGui::SliderInt2(const char* label, int v[2], int v_min, int v_max, const char* format)
{
    return SliderScalarN(label, ImGuiDataType_S32, v, 2, &v_min, &v_max, format);
}

bool ImGui::SliderInt3(const char* label, int v[3], int v_min, int v_max, const char* format)
{
    return SliderScalarN(label, ImGuiDataType_S32, v, 3, &v_min, &v_max, format);
}

bool ImGui::SliderInt4(const char* label, int v[4], int v_min, int v_max, const char* format)
{
    return SliderScalarN(label, ImGuiDataType_S32, v, 4, &v_min, &v_max, format);
}

bool ImGui::VSliderScalar(const char* label, const ImVec2& size, ImGuiDataType data_type, void* v, const void* v_min, const void* v_max, const char* format, float power)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const ImGuiID id = window->GetID(label);

    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + size);
    const ImRect bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

    ItemSize(bb, style.FramePadding.y);
    if (!ItemAdd(frame_bb, id))
        return false;

    // Default format string when passing NULL
    if (format == NULL)
        format = DataTypeGetInfo(data_type)->PrintFmt;
    else if (data_type == ImGuiDataType_S32 && strcmp(format, "%d") != 0) // (FIXME-LEGACY: Patch old "%.0f" format string to use "%d", read function more details.)
        format = PatchFormatStringFloatToInt(format);

    const bool hovered = ItemHoverable(frame_bb, id);
    if ((hovered && g.IO.MouseClicked[0]) || g.NavActivateId == id || g.NavInputId == id)
    {
        SetActiveID(id, window);
        SetFocusID(id, window);
        FocusWindow(window);
        g.ActiveIdAllowNavDirFlags = (1 << ImGuiDir_Left) | (1 << ImGuiDir_Right);
    }

    // Draw frame
    const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : g.HoveredId == id ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);
    RenderNavHighlight(frame_bb, id);
    RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, g.Style.FrameRounding);

    // Slider behavior
    ImRect grab_bb;
    const bool value_changed = SliderBehavior(frame_bb, id, data_type, v, v_min, v_max, format, power, ImGuiSliderFlags_Vertical, &grab_bb);
    if (value_changed)
        MarkItemEdited(id);

    // Render grab
    if (grab_bb.Max.y > grab_bb.Min.y)
        window->DrawList->AddRectFilled(grab_bb.Min, grab_bb.Max, GetColorU32(g.ActiveId == id ? ImGuiCol_SliderGrabActive : ImGuiCol_SliderGrab), style.GrabRounding);

    // Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
    // For the vertical slider we allow centered text to overlap the frame padding
    char value_buf[64];
    const char* value_buf_end = value_buf + DataTypeFormatString(value_buf, IM_ARRAYSIZE(value_buf), data_type, v, format);
    RenderTextClipped(ImVec2(frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y), frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f,0.0f));
    if (label_size.x > 0.0f)
        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

    return value_changed;
}

bool ImGui::VSliderFloat(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* format, float power)
{
    return VSliderScalar(label, size, ImGuiDataType_Float, v, &v_min, &v_max, format, power);
}

bool ImGui::VSliderInt(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* format)
{
    return VSliderScalar(label, size, ImGuiDataType_S32, v, &v_min, &v_max, format);
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: InputScalar, InputFloat, InputInt, etc.
//-------------------------------------------------------------------------
// - ImParseFormatFindStart() [Internal]
// - ImParseFormatFindEnd() [Internal]
// - ImParseFormatTrimDecorations() [Internal]
// - ImParseFormatPrecision() [Internal]
// - TempInputTextScalar() [Internal]
// - InputScalar()
// - InputScalarN()
// - InputFloat()
// - InputFloat2()
// - InputFloat3()
// - InputFloat4()
// - InputInt()
// - InputInt2()
// - InputInt3()
// - InputInt4()
// - InputDouble()
//-------------------------------------------------------------------------

// We don't use strchr() because our strings are usually very short and often start with '%'
const char* ImParseFormatFindStart(const char* fmt)
{
    while (char c = fmt[0])
    {
        if (c == '%' && fmt[1] != '%')
            return fmt;
        else if (c == '%')
            fmt++;
        fmt++;
    }
    return fmt;
}

const char* ImParseFormatFindEnd(const char* fmt)
{
    // Printf/scanf types modifiers: I/L/h/j/l/t/w/z. Other uppercase letters qualify as types aka end of the format.
    if (fmt[0] != '%')
        return fmt;
    const unsigned int ignored_uppercase_mask = (1 << ('I'-'A')) | (1 << ('L'-'A'));
    const unsigned int ignored_lowercase_mask = (1 << ('h'-'a')) | (1 << ('j'-'a')) | (1 << ('l'-'a')) | (1 << ('t'-'a')) | (1 << ('w'-'a')) | (1 << ('z'-'a'));
    for (char c; (c = *fmt) != 0; fmt++)
    {
        if (c >= 'A' && c <= 'Z' && ((1 << (c - 'A')) & ignored_uppercase_mask) == 0)
            return fmt + 1;
        if (c >= 'a' && c <= 'z' && ((1 << (c - 'a')) & ignored_lowercase_mask) == 0)
            return fmt + 1;
    }
    return fmt;
}

// Extract the format out of a format string with leading or trailing decorations
//  fmt = "blah blah"  -> return fmt
//  fmt = "%.3f"       -> return fmt
//  fmt = "hello %.3f" -> return fmt + 6
//  fmt = "%.3f hello" -> return buf written with "%.3f"
const char* ImParseFormatTrimDecorations(const char* fmt, char* buf, size_t buf_size)
{
    const char* fmt_start = ImParseFormatFindStart(fmt);
    if (fmt_start[0] != '%')
        return fmt;
    const char* fmt_end = ImParseFormatFindEnd(fmt_start);
    if (fmt_end[0] == 0) // If we only have leading decoration, we don't need to copy the data.
        return fmt_start;
    ImStrncpy(buf, fmt_start, ImMin((size_t)(fmt_end - fmt_start) + 1, buf_size));
    return buf;
}

// Parse display precision back from the display format string
// FIXME: This is still used by some navigation code path to infer a minimum tweak step, but we should aim to rework widgets so it isn't needed.
int ImParseFormatPrecision(const char* fmt, int default_precision)
{
    fmt = ImParseFormatFindStart(fmt);
    if (fmt[0] != '%')
        return default_precision;
    fmt++;
    while (*fmt >= '0' && *fmt <= '9')
        fmt++;
    int precision = INT_MAX;
    if (*fmt == '.')
    {
        fmt = ImAtoi<int>(fmt + 1, &precision);
        if (precision < 0 || precision > 99)
            precision = default_precision;
    }
    if (*fmt == 'e' || *fmt == 'E') // Maximum precision with scientific notation
        precision = -1;
    if ((*fmt == 'g' || *fmt == 'G') && precision == INT_MAX)
        precision = -1;
    return (precision == INT_MAX) ? default_precision : precision;
}

// Create text input in place of another active widget (e.g. used when doing a CTRL+Click on drag/slider widgets)
// FIXME: Facilitate using this in variety of other situations.
bool ImGui::TempInputTextScalar(const ImRect& bb, ImGuiID id, const char* label, ImGuiDataType data_type, void* data_ptr, const char* format)
{
    ImGuiContext& g = *GImGui;

    // On the first frame, g.TempInputTextId == 0, then on subsequent frames it becomes == id.
    // We clear ActiveID on the first frame to allow the InputText() taking it back.
    const bool init = (g.TempInputTextId != id);
    if (init)
        ClearActiveID();

    char fmt_buf[32];
    char data_buf[32];
    format = ImParseFormatTrimDecorations(format, fmt_buf, IM_ARRAYSIZE(fmt_buf));
    DataTypeFormatString(data_buf, IM_ARRAYSIZE(data_buf), data_type, data_ptr, format);
    ImStrTrimBlanks(data_buf);

    g.CurrentWindow->DC.CursorPos = bb.Min;
    ImGuiInputTextFlags flags = ImGuiInputTextFlags_AutoSelectAll | ((data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double) ? ImGuiInputTextFlags_CharsScientific : ImGuiInputTextFlags_CharsDecimal);
    bool value_changed = InputTextEx(label, NULL, data_buf, IM_ARRAYSIZE(data_buf), bb.GetSize(), flags);
    if (init)
    {
        // First frame we started displaying the InputText widget, we expect it to take the active id.
        IM_ASSERT(g.ActiveId == id);
        g.TempInputTextId = g.ActiveId;
    }
    if (value_changed)
        return DataTypeApplyOpFromText(data_buf, g.InputTextState.InitialTextA.Data, data_type, data_ptr, NULL);
    return false;
}

bool ImGui::InputScalar(const char* label, ImGuiDataType data_type, void* data_ptr, const void* step, const void* step_fast, const char* format, ImGuiInputTextFlags flags)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    ImGuiStyle& style = g.Style;

    if (format == NULL)
        format = DataTypeGetInfo(data_type)->PrintFmt;

    char buf[64];
    DataTypeFormatString(buf, IM_ARRAYSIZE(buf), data_type, data_ptr, format);

    bool value_changed = false;
    if ((flags & (ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsScientific)) == 0)
        flags |= ImGuiInputTextFlags_CharsDecimal;
    flags |= ImGuiInputTextFlags_AutoSelectAll;

    if (step != NULL)
    {
        const float button_size = GetFrameHeight();

        BeginGroup(); // The only purpose of the group here is to allow the caller to query item data e.g. IsItemActive()
        PushID(label);
        SetNextItemWidth(ImMax(1.0f, GetNextItemWidth() - (button_size + style.ItemInnerSpacing.x) * 2));
        if (InputText("", buf, IM_ARRAYSIZE(buf), flags)) // PushId(label) + "" gives us the expected ID from outside point of view
            value_changed = DataTypeApplyOpFromText(buf, g.InputTextState.InitialTextA.Data, data_type, data_ptr, format);

        // Step buttons
        const ImVec2 backup_frame_padding = style.FramePadding;
        style.FramePadding.x = style.FramePadding.y;
        ImGuiButtonFlags button_flags = ImGuiButtonFlags_Repeat | ImGuiButtonFlags_DontClosePopups;
        if (flags & ImGuiInputTextFlags_ReadOnly)
            button_flags |= ImGuiButtonFlags_Disabled;
        SameLine(0, style.ItemInnerSpacing.x);
        if (ButtonEx("-", ImVec2(button_size, button_size), button_flags))
        {
            DataTypeApplyOp(data_type, '-', data_ptr, data_ptr, g.IO.KeyCtrl && step_fast ? step_fast : step);
            value_changed = true;
        }
        SameLine(0, style.ItemInnerSpacing.x);
        if (ButtonEx("+", ImVec2(button_size, button_size), button_flags))
        {
            DataTypeApplyOp(data_type, '+', data_ptr, data_ptr, g.IO.KeyCtrl && step_fast ? step_fast : step);
            value_changed = true;
        }
        SameLine(0, style.ItemInnerSpacing.x);
        TextEx(label, FindRenderedTextEnd(label));
        style.FramePadding = backup_frame_padding;

        PopID();
        EndGroup();
    }
    else
    {
        if (InputText(label, buf, IM_ARRAYSIZE(buf), flags))
            value_changed = DataTypeApplyOpFromText(buf, g.InputTextState.InitialTextA.Data, data_type, data_ptr, format);
    }

    return value_changed;
}

bool ImGui::InputScalarN(const char* label, ImGuiDataType data_type, void* v, int components, const void* step, const void* step_fast, const char* format, ImGuiInputTextFlags flags)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    bool value_changed = false;
    BeginGroup();
    PushID(label);
    PushMultiItemsWidths(components, GetNextItemWidth());
    size_t type_size = GDataTypeInfo[data_type].Size;
    for (int i = 0; i < components; i++)
    {
        PushID(i);
        value_changed |= InputScalar("", data_type, v, step, step_fast, format, flags);
        SameLine(0, g.Style.ItemInnerSpacing.x);
        PopID();
        PopItemWidth();
        v = (void*)((char*)v + type_size);
    }
    PopID();

    TextEx(label, FindRenderedTextEnd(label));
    EndGroup();
    return value_changed;
}

bool ImGui::InputFloat(const char* label, float* v, float step, float step_fast, const char* format, ImGuiInputTextFlags flags)
{
    flags |= ImGuiInputTextFlags_CharsScientific;
    return InputScalar(label, ImGuiDataType_Float, (void*)v, (void*)(step>0.0f ? &step : NULL), (void*)(step_fast>0.0f ? &step_fast : NULL), format, flags);
}

bool ImGui::InputFloat2(const char* label, float v[2], const char* format, ImGuiInputTextFlags flags)
{
    return InputScalarN(label, ImGuiDataType_Float, v, 2, NULL, NULL, format, flags);
}

bool ImGui::InputFloat3(const char* label, float v[3], const char* format, ImGuiInputTextFlags flags)
{
    return InputScalarN(label, ImGuiDataType_Float, v, 3, NULL, NULL, format, flags);
}

bool ImGui::InputFloat4(const char* label, float v[4], const char* format, ImGuiInputTextFlags flags)
{
    return InputScalarN(label, ImGuiDataType_Float, v, 4, NULL, NULL, format, flags);
}

// Prefer using "const char* format" directly, which is more flexible and consistent with other API.
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
bool ImGui::InputFloat(const char* label, float* v, float step, float step_fast, int decimal_precision, ImGuiInputTextFlags flags)
{
    char format[16] = "%f";
    if (decimal_precision >= 0)
        ImFormatString(format, IM_ARRAYSIZE(format), "%%.%df", decimal_precision);
    return InputFloat(label, v, step, step_fast, format, flags);
}

bool ImGui::InputFloat2(const char* label, float v[2], int decimal_precision, ImGuiInputTextFlags flags)
{
    char format[16] = "%f";
    if (decimal_precision >= 0)
        ImFormatString(format, IM_ARRAYSIZE(format), "%%.%df", decimal_precision);
    return InputScalarN(label, ImGuiDataType_Float, v, 2, NULL, NULL, format, flags);
}

bool ImGui::InputFloat3(const char* label, float v[3], int decimal_precision, ImGuiInputTextFlags flags)
{
    char format[16] = "%f";
    if (decimal_precision >= 0)
        ImFormatString(format, IM_ARRAYSIZE(format), "%%.%df", decimal_precision);
    return InputScalarN(label, ImGuiDataType_Float, v, 3, NULL, NULL, format, flags);
}

bool ImGui::InputFloat4(const char* label, float v[4], int decimal_precision, ImGuiInputTextFlags flags)
{
    char format[16] = "%f";
    if (decimal_precision >= 0)
        ImFormatString(format, IM_ARRAYSIZE(format), "%%.%df", decimal_precision);
    return InputScalarN(label, ImGuiDataType_Float, v, 4, NULL, NULL, format, flags);
}
#endif // IMGUI_DISABLE_OBSOLETE_FUNCTIONS

bool ImGui::InputInt(const char* label, int* v, int step, int step_fast, ImGuiInputTextFlags flags)
{
    // Hexadecimal input provided as a convenience but the flag name is awkward. Typically you'd use InputText() to parse your own data, if you want to handle prefixes.
    const char* format = (flags & ImGuiInputTextFlags_CharsHexadecimal) ? "%08X" : "%d";
    return InputScalar(label, ImGuiDataType_S32, (void*)v, (void*)(step>0 ? &step : NULL), (void*)(step_fast>0 ? &step_fast : NULL), format, flags);
}

bool ImGui::InputInt2(const char* label, int v[2], ImGuiInputTextFlags flags)
{
    return InputScalarN(label, ImGuiDataType_S32, v, 2, NULL, NULL, "%d", flags);
}

bool ImGui::InputInt3(const char* label, int v[3], ImGuiInputTextFlags flags)
{
    return InputScalarN(label, ImGuiDataType_S32, v, 3, NULL, NULL, "%d", flags);
}

bool ImGui::InputInt4(const char* label, int v[4], ImGuiInputTextFlags flags)
{
    return InputScalarN(label, ImGuiDataType_S32, v, 4, NULL, NULL, "%d", flags);
}

bool ImGui::InputDouble(const char* label, double* v, double step, double step_fast, const char* format, ImGuiInputTextFlags flags)
{
    flags |= ImGuiInputTextFlags_CharsScientific;
    return InputScalar(label, ImGuiDataType_Double, (void*)v, (void*)(step>0.0 ? &step : NULL), (void*)(step_fast>0.0 ? &step_fast : NULL), format, flags);
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: InputText, InputTextMultiline, InputTextWithHint
//-------------------------------------------------------------------------
// - InputText()
// - InputTextWithHint()
// - InputTextMultiline()
// - InputTextEx() [Internal]
//-------------------------------------------------------------------------

bool ImGui::InputText(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data)
{
    IM_ASSERT(!(flags & ImGuiInputTextFlags_Multiline)); // call InputTextMultiline()
    return InputTextEx(label, NULL, buf, (int)buf_size, ImVec2(0,0), flags, callback, user_data);
}

bool ImGui::InputTextMultiline(const char* label, char* buf, size_t buf_size, const ImVec2& size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data)
{
    return InputTextEx(label, NULL, buf, (int)buf_size, size, flags | ImGuiInputTextFlags_Multiline, callback, user_data);
}

bool ImGui::InputTextWithHint(const char* label, const char* hint, char* buf, size_t buf_size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data)
{
    IM_ASSERT(!(flags & ImGuiInputTextFlags_Multiline)); // call InputTextMultiline()
    return InputTextEx(label, hint, buf, (int)buf_size, ImVec2(0, 0), flags, callback, user_data);
}

static int InputTextCalcTextLenAndLineCount(const char* text_begin, const char** out_text_end)
{
    int line_count = 0;
    const char* s = text_begin;
    while (char c = *s++) // We are only matching for \n so we can ignore UTF-8 decoding
        if (c == '\n')
            line_count++;
    s--;
    if (s[0] != '\n' && s[0] != '\r')
        line_count++;
    *out_text_end = s;
    return line_count;
}

static ImVec2 InputTextCalcTextSizeW(const ImWchar* text_begin, const ImWchar* text_end, const ImWchar** remaining, ImVec2* out_offset, bool stop_on_new_line)
{
    ImGuiContext& g = *GImGui;
    ImFont* font = g.Font;
    const float line_height = g.FontSize;
    const float scale = line_height / font->FontSize;

    ImVec2 text_size = ImVec2(0,0);
    float line_width = 0.0f;

    const ImWchar* s = text_begin;
    while (s < text_end)
    {
        unsigned int c = (unsigned int)(*s++);
        if (c == '\n')
        {
            text_size.x = ImMax(text_size.x, line_width);
            text_size.y += line_height;
            line_width = 0.0f;
            if (stop_on_new_line)
                break;
            continue;
        }
        if (c == '\r')
            continue;

        const float char_width = font->GetCharAdvance((ImWchar)c) * scale;
        line_width += char_width;
    }

    if (text_size.x < line_width)
        text_size.x = line_width;

    if (out_offset)
        *out_offset = ImVec2(line_width, text_size.y + line_height);  // offset allow for the possibility of sitting after a trailing \n

    if (line_width > 0 || text_size.y == 0.0f)                        // whereas size.y will ignore the trailing \n
        text_size.y += line_height;

    if (remaining)
        *remaining = s;

    return text_size;
}

// Wrapper for stb_textedit.h to edit text (our wrapper is for: statically sized buffer, single-line, wchar characters. InputText converts between UTF-8 and wchar)
namespace ImStb
{

static int     STB_TEXTEDIT_STRINGLEN(const STB_TEXTEDIT_STRING* obj)                             { return obj->CurLenW; }
static ImWchar STB_TEXTEDIT_GETCHAR(const STB_TEXTEDIT_STRING* obj, int idx)                      { return obj->TextW[idx]; }
static float   STB_TEXTEDIT_GETWIDTH(STB_TEXTEDIT_STRING* obj, int line_start_idx, int char_idx)  { ImWchar c = obj->TextW[line_start_idx+char_idx]; if (c == '\n') return STB_TEXTEDIT_GETWIDTH_NEWLINE; return GImGui->Font->GetCharAdvance(c) * (GImGui->FontSize / GImGui->Font->FontSize); }
static int     STB_TEXTEDIT_KEYTOTEXT(int key)                                                    { return key >= 0x10000 ? 0 : key; }
static ImWchar STB_TEXTEDIT_NEWLINE = '\n';
static void    STB_TEXTEDIT_LAYOUTROW(StbTexteditRow* r, STB_TEXTEDIT_STRING* obj, int line_start_idx)
{
    const ImWchar* text = obj->TextW.Data;
    const ImWchar* text_remaining = NULL;
    const ImVec2 size = InputTextCalcTextSizeW(text + line_start_idx, text + obj->CurLenW, &text_remaining, NULL, true);
    r->x0 = 0.0f;
    r->x1 = size.x;
    r->baseline_y_delta = size.y;
    r->ymin = 0.0f;
    r->ymax = size.y;
    r->num_chars = (int)(text_remaining - (text + line_start_idx));
}

static bool is_separator(unsigned int c)                                        { return ImCharIsBlankW(c) || c==',' || c==';' || c=='(' || c==')' || c=='{' || c=='}' || c=='[' || c==']' || c=='|'; }
static int  is_word_boundary_from_right(STB_TEXTEDIT_STRING* obj, int idx)      { return idx > 0 ? (is_separator( obj->TextW[idx-1] ) && !is_separator( obj->TextW[idx] ) ) : 1; }
static int  STB_TEXTEDIT_MOVEWORDLEFT_IMPL(STB_TEXTEDIT_STRING* obj, int idx)   { idx--; while (idx >= 0 && !is_word_boundary_from_right(obj, idx)) idx--; return idx < 0 ? 0 : idx; }
#ifdef __APPLE__    // FIXME: Move setting to IO structure
static int  is_word_boundary_from_left(STB_TEXTEDIT_STRING* obj, int idx)       { return idx > 0 ? (!is_separator( obj->TextW[idx-1] ) && is_separator( obj->TextW[idx] ) ) : 1; }
static int  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL(STB_TEXTEDIT_STRING* obj, int idx)  { idx++; int len = obj->CurLenW; while (idx < len && !is_word_boundary_from_left(obj, idx)) idx++; return idx > len ? len : idx; }
#else
static int  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL(STB_TEXTEDIT_STRING* obj, int idx)  { idx++; int len = obj->CurLenW; while (idx < len && !is_word_boundary_from_right(obj, idx)) idx++; return idx > len ? len : idx; }
#endif
#define STB_TEXTEDIT_MOVEWORDLEFT   STB_TEXTEDIT_MOVEWORDLEFT_IMPL    // They need to be #define for stb_textedit.h
#define STB_TEXTEDIT_MOVEWORDRIGHT  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL

static void STB_TEXTEDIT_DELETECHARS(STB_TEXTEDIT_STRING* obj, int pos, int n)
{
    ImWchar* dst = obj->TextW.Data + pos;

    // We maintain our buffer length in both UTF-8 and wchar formats
    obj->CurLenA -= ImTextCountUtf8BytesFromStr(dst, dst + n);
    obj->CurLenW -= n;

    // Offset remaining text (FIXME-OPT: Use memmove)
    const ImWchar* src = obj->TextW.Data + pos + n;
    while (ImWchar c = *src++)
        *dst++ = c;
    *dst = '\0';
}

static bool STB_TEXTEDIT_INSERTCHARS(STB_TEXTEDIT_STRING* obj, int pos, const ImWchar* new_text, int new_text_len)
{
    const bool is_resizable = (obj->UserFlags & ImGuiInputTextFlags_CallbackResize) != 0;
    const int text_len = obj->CurLenW;
    IM_ASSERT(pos <= text_len);

    const int new_text_len_utf8 = ImTextCountUtf8BytesFromStr(new_text, new_text + new_text_len);
    if (!is_resizable && (new_text_len_utf8 + obj->CurLenA + 1 > obj->BufCapacityA))
        return false;

    // Grow internal buffer if needed
    if (new_text_len + text_len + 1 > obj->TextW.Size)
    {
        if (!is_resizable)
            return false;
        IM_ASSERT(text_len < obj->TextW.Size);
        obj->TextW.resize(text_len + ImClamp(new_text_len * 4, 32, ImMax(256, new_text_len)) + 1);
    }

    ImWchar* text = obj->TextW.Data;
    if (pos != text_len)
        memmove(text + pos + new_text_len, text + pos, (size_t)(text_len - pos) * sizeof(ImWchar));
    memcpy(text + pos, new_text, (size_t)new_text_len * sizeof(ImWchar));

    obj->CurLenW += new_text_len;
    obj->CurLenA += new_text_len_utf8;
    obj->TextW[obj->CurLenW] = '\0';

    return true;
}

// We don't use an enum so we can build even with conflicting symbols (if another user of stb_textedit.h leak their STB_TEXTEDIT_K_* symbols)
#define STB_TEXTEDIT_K_LEFT         0x10000 // keyboard input to move cursor left
#define STB_TEXTEDIT_K_RIGHT        0x10001 // keyboard input to move cursor right
#define STB_TEXTEDIT_K_UP           0x10002 // keyboard input to move cursor up
#define STB_TEXTEDIT_K_DOWN         0x10003 // keyboard input to move cursor down
#define STB_TEXTEDIT_K_LINESTART    0x10004 // keyboard input to move cursor to start of line
#define STB_TEXTEDIT_K_LINEEND      0x10005 // keyboard input to move cursor to end of line
#define STB_TEXTEDIT_K_TEXTSTART    0x10006 // keyboard input to move cursor to start of text
#define STB_TEXTEDIT_K_TEXTEND      0x10007 // keyboard input to move cursor to end of text
#define STB_TEXTEDIT_K_DELETE       0x10008 // keyboard input to delete selection or character under cursor
#define STB_TEXTEDIT_K_BACKSPACE    0x10009 // keyboard input to delete selection or character left of cursor
#define STB_TEXTEDIT_K_UNDO         0x1000A // keyboard input to perform undo
#define STB_TEXTEDIT_K_REDO         0x1000B // keyboard input to perform redo
#define STB_TEXTEDIT_K_WORDLEFT     0x1000C // keyboard input to move cursor left one word
#define STB_TEXTEDIT_K_WORDRIGHT    0x1000D // keyboard input to move cursor right one word
#define STB_TEXTEDIT_K_SHIFT        0x20000

#define STB_TEXTEDIT_IMPLEMENTATION
#include "imstb_textedit.h"

}

void ImGuiInputTextState::OnKeyPressed(int key)
{
    stb_textedit_key(this, &Stb, key);
    CursorFollow = true;
    CursorAnimReset();
}

ImGuiInputTextCallbackData::ImGuiInputTextCallbackData()
{
    memset(this, 0, sizeof(*this));
}

// Public API to manipulate UTF-8 text
// We expose UTF-8 to the user (unlike the STB_TEXTEDIT_* functions which are manipulating wchar)
// FIXME: The existence of this rarely exercised code path is a bit of a nuisance.
void ImGuiInputTextCallbackData::DeleteChars(int pos, int bytes_count)
{
    IM_ASSERT(pos + bytes_count <= BufTextLen);
    char* dst = Buf + pos;
    const char* src = Buf + pos + bytes_count;
    while (char c = *src++)
        *dst++ = c;
    *dst = '\0';

    if (CursorPos + bytes_count >= pos)
        CursorPos -= bytes_count;
    else if (CursorPos >= pos)
        CursorPos = pos;
    SelectionStart = SelectionEnd = CursorPos;
    BufDirty = true;
    BufTextLen -= bytes_count;
}

void ImGuiInputTextCallbackData::InsertChars(int pos, const char* new_text, const char* new_text_end)
{
    const bool is_resizable = (Flags & ImGuiInputTextFlags_CallbackResize) != 0;
    const int new_text_len = new_text_end ? (int)(new_text_end - new_text) : (int)strlen(new_text);
    if (new_text_len + BufTextLen >= BufSize)
    {
        if (!is_resizable)
            return;

        // Contrary to STB_TEXTEDIT_INSERTCHARS() this is working in the UTF8 buffer, hence the midly similar code (until we remove the U16 buffer alltogether!)
        ImGuiContext& g = *GImGui;
        ImGuiInputTextState* edit_state = &g.InputTextState;
        IM_ASSERT(edit_state->ID != 0 && g.ActiveId == edit_state->ID);
        IM_ASSERT(Buf == edit_state->TextA.Data);
        int new_buf_size = BufTextLen + ImClamp(new_text_len * 4, 32, ImMax(256, new_text_len)) + 1;
        edit_state->TextA.reserve(new_buf_size + 1);
        Buf = edit_state->TextA.Data;
        BufSize = edit_state->BufCapacityA = new_buf_size;
    }

    if (BufTextLen != pos)
        memmove(Buf + pos + new_text_len, Buf + pos, (size_t)(BufTextLen - pos));
    memcpy(Buf + pos, new_text, (size_t)new_text_len * sizeof(char));
    Buf[BufTextLen + new_text_len] = '\0';

    if (CursorPos >= pos)
        CursorPos += new_text_len;
    SelectionStart = SelectionEnd = CursorPos;
    BufDirty = true;
    BufTextLen += new_text_len;
}

// Return false to discard a character.
static bool InputTextFilterCharacter(unsigned int* p_char, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data)
{
    unsigned int c = *p_char;

    // Filter non-printable (NB: isprint is unreliable! see #2467)
    if (c < 0x20)
    {
        bool pass = false;
        pass |= (c == '\n' && (flags & ImGuiInputTextFlags_Multiline));
        pass |= (c == '\t' && (flags & ImGuiInputTextFlags_AllowTabInput));
        if (!pass)
            return false;
    }

    // Filter private Unicode range. GLFW on OSX seems to send private characters for special keys like arrow keys (FIXME)
    if (c >= 0xE000 && c <= 0xF8FF)
        return false;

    // Generic named filters
    if (flags & (ImGuiInputTextFlags_CharsDecimal | ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsUppercase | ImGuiInputTextFlags_CharsNoBlank | ImGuiInputTextFlags_CharsScientific))
    {
        if (flags & ImGuiInputTextFlags_CharsDecimal)
            if (!(c >= '0' && c <= '9') && (c != '.') && (c != '-') && (c != '+') && (c != '*') && (c != '/'))
                return false;

        if (flags & ImGuiInputTextFlags_CharsScientific)
            if (!(c >= '0' && c <= '9') && (c != '.') && (c != '-') && (c != '+') && (c != '*') && (c != '/') && (c != 'e') && (c != 'E'))
                return false;

        if (flags & ImGuiInputTextFlags_CharsHexadecimal)
            if (!(c >= '0' && c <= '9') && !(c >= 'a' && c <= 'f') && !(c >= 'A' && c <= 'F'))
                return false;

        if (flags & ImGuiInputTextFlags_CharsUppercase)
            if (c >= 'a' && c <= 'z')
                *p_char = (c += (unsigned int)('A'-'a'));

        if (flags & ImGuiInputTextFlags_CharsNoBlank)
            if (ImCharIsBlankW(c))
                return false;
    }

    // Custom callback filter
    if (flags & ImGuiInputTextFlags_CallbackCharFilter)
    {
        ImGuiInputTextCallbackData callback_data;
        memset(&callback_data, 0, sizeof(ImGuiInputTextCallbackData));
        callback_data.EventFlag = ImGuiInputTextFlags_CallbackCharFilter;
        callback_data.EventChar = (ImWchar)c;
        callback_data.Flags = flags;
        callback_data.UserData = user_data;
        if (callback(&callback_data) != 0)
            return false;
        *p_char = callback_data.EventChar;
        if (!callback_data.EventChar)
            return false;
    }

    return true;
}

// Edit a string of text
// - buf_size account for the zero-terminator, so a buf_size of 6 can hold "Hello" but not "Hello!".
//   This is so we can easily call InputText() on static arrays using ARRAYSIZE() and to match
//   Note that in std::string world, capacity() would omit 1 byte used by the zero-terminator.
// - When active, hold on a privately held copy of the text (and apply back to 'buf'). So changing 'buf' while the InputText is active has no effect.
// - If you want to use ImGui::InputText() with std::string, see misc/cpp/imgui_stdlib.h
// (FIXME: Rather confusing and messy function, among the worse part of our codebase, expecting to rewrite a V2 at some point.. Partly because we are
//  doing UTF8 > U16 > UTF8 conversions on the go to easily interface with stb_textedit. Ideally should stay in UTF-8 all the time. See https://github.com/nothings/stb/issues/188)
bool ImGui::InputTextEx(const char* label, const char* hint, char* buf, int buf_size, const ImVec2& size_arg, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* callback_user_data)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    IM_ASSERT(!((flags & ImGuiInputTextFlags_CallbackHistory) && (flags & ImGuiInputTextFlags_Multiline)));        // Can't use both together (they both use up/down keys)
    IM_ASSERT(!((flags & ImGuiInputTextFlags_CallbackCompletion) && (flags & ImGuiInputTextFlags_AllowTabInput))); // Can't use both together (they both use tab key)

    ImGuiContext& g = *GImGui;
    ImGuiIO& io = g.IO;
    const ImGuiStyle& style = g.Style;

    const bool RENDER_SELECTION_WHEN_INACTIVE = false;
    const bool is_multiline = (flags & ImGuiInputTextFlags_Multiline) != 0;
    const bool is_readonly = (flags & ImGuiInputTextFlags_ReadOnly) != 0;
    const bool is_password = (flags & ImGuiInputTextFlags_Password) != 0;
    const bool is_undoable = (flags & ImGuiInputTextFlags_NoUndoRedo) == 0;
    const bool is_resizable = (flags & ImGuiInputTextFlags_CallbackResize) != 0;
    if (is_resizable)
        IM_ASSERT(callback != NULL); // Must provide a callback if you set the ImGuiInputTextFlags_CallbackResize flag!

    if (is_multiline) // Open group before calling GetID() because groups tracks id created within their scope,
        BeginGroup();
    const ImGuiID id = window->GetID(label);
    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    ImVec2 size = CalcItemSize(size_arg, GetNextItemWidth(), (is_multiline ? GetTextLineHeight() * 8.0f : label_size.y) + style.FramePadding.y*2.0f); // Arbitrary default of 8 lines high for multi-line
    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + size);
    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? (style.ItemInnerSpacing.x + label_size.x) : 0.0f, 0.0f));

    ImGuiWindow* draw_window = window;
    if (is_multiline)
    {
        if (!ItemAdd(total_bb, id, &frame_bb))
        {
            ItemSize(total_bb, style.FramePadding.y);
            EndGroup();
            return false;
        }
        if (!BeginChildFrame(id, frame_bb.GetSize()))
        {
            EndChildFrame();
            EndGroup();
            return false;
        }
        draw_window = GetCurrentWindow();
        draw_window->DC.NavLayerActiveMaskNext |= draw_window->DC.NavLayerCurrentMask; // This is to ensure that EndChild() will display a navigation highlight
        size.x -= draw_window->ScrollbarSizes.x;
    }
    else
    {
        ItemSize(total_bb, style.FramePadding.y);
        if (!ItemAdd(total_bb, id, &frame_bb))
            return false;
    }
    const bool hovered = ItemHoverable(frame_bb, id);
    if (hovered)
        g.MouseCursor = ImGuiMouseCursor_TextInput;

    // NB: we are only allowed to access 'edit_state' if we are the active widget.
    ImGuiInputTextState* state = NULL;
    if (g.InputTextState.ID == id)
        state = &g.InputTextState;

    const bool focus_requested = FocusableItemRegister(window, id);
    const bool focus_requested_by_code = focus_requested && (g.FocusRequestCurrWindow == window && g.FocusRequestCurrCounterAll == window->DC.FocusCounterAll);
    const bool focus_requested_by_tab = focus_requested && !focus_requested_by_code;

    const bool user_clicked = hovered && io.MouseClicked[0];
    const bool user_nav_input_start = (g.ActiveId != id) && ((g.NavInputId == id) || (g.NavActivateId == id && g.NavInputSource == ImGuiInputSource_NavKeyboard));
    const bool user_scroll_finish = is_multiline && state != NULL && g.ActiveId == 0 && g.ActiveIdPreviousFrame == GetScrollbarID(draw_window, ImGuiAxis_Y);
    const bool user_scroll_active = is_multiline && state != NULL && g.ActiveId == GetScrollbarID(draw_window, ImGuiAxis_Y);

    bool clear_active_id = false;
    bool select_all = (g.ActiveId != id) && ((flags & ImGuiInputTextFlags_AutoSelectAll) != 0 || user_nav_input_start) && (!is_multiline);

    const bool init_make_active = (focus_requested || user_clicked || user_scroll_finish || user_nav_input_start);
    const bool init_state = (init_make_active || user_scroll_active);
    if (init_state && g.ActiveId != id)
    {
        // Access state even if we don't own it yet.
        state = &g.InputTextState;
        state->CursorAnimReset();

        // Take a copy of the initial buffer value (both in original UTF-8 format and converted to wchar)
        // From the moment we focused we are ignoring the content of 'buf' (unless we are in read-only mode)
        const int buf_len = (int)strlen(buf);
        state->InitialTextA.resize(buf_len + 1);    // UTF-8. we use +1 to make sure that .Data is always pointing to at least an empty string.
        memcpy(state->InitialTextA.Data, buf, buf_len + 1);

        // Start edition
        const char* buf_end = NULL;
        state->TextW.resize(buf_size + 1);          // wchar count <= UTF-8 count. we use +1 to make sure that .Data is always pointing to at least an empty string.
        state->TextA.resize(0);
        state->TextAIsValid = false;                // TextA is not valid yet (we will display buf until then)
        state->CurLenW = ImTextStrFromUtf8(state->TextW.Data, buf_size, buf, NULL, &buf_end);
        state->CurLenA = (int)(buf_end - buf);      // We can't get the result from ImStrncpy() above because it is not UTF-8 aware. Here we'll cut off malformed UTF-8.

        // Preserve cursor position and undo/redo stack if we come back to same widget
        // FIXME: For non-readonly widgets we might be able to require that TextAIsValid && TextA == buf ? (untested) and discard undo stack if user buffer has changed.
        const bool recycle_state = (state->ID == id);
        if (recycle_state)
        {
            // Recycle existing cursor/selection/undo stack but clamp position
            // Note a single mouse click will override the cursor/position immediately by calling stb_textedit_click handler.
            state->CursorClamp();
        }
        else
        {
            state->ID = id;
            state->ScrollX = 0.0f;
            stb_textedit_initialize_state(&state->Stb, !is_multiline);
            if (!is_multiline && focus_requested_by_code)
                select_all = true;
        }
        if (flags & ImGuiInputTextFlags_AlwaysInsertMode)
            state->Stb.insert_mode = 1;
        if (!is_multiline && (focus_requested_by_tab || (user_clicked && io.KeyCtrl)))
            select_all = true;
    }

    if (g.ActiveId != id && init_make_active)
    {
        IM_ASSERT(state && state->ID == id);
        SetActiveID(id, window);
        SetFocusID(id, window);
        FocusWindow(window);
        IM_ASSERT(ImGuiNavInput_COUNT < 32);
        g.ActiveIdBlockNavInputFlags = (1 << ImGuiNavInput_Cancel);
        if (flags & (ImGuiInputTextFlags_CallbackCompletion | ImGuiInputTextFlags_AllowTabInput))  // Disable keyboard tabbing out as we will use the \t character.
            g.ActiveIdBlockNavInputFlags |= (1 << ImGuiNavInput_KeyTab_);
        if (!is_multiline && !(flags & ImGuiInputTextFlags_CallbackHistory))
            g.ActiveIdAllowNavDirFlags = ((1 << ImGuiDir_Up) | (1 << ImGuiDir_Down));
    }

    // We have an edge case if ActiveId was set through another widget (e.g. widget being swapped), clear id immediately (don't wait until the end of the function)
    if (g.ActiveId == id && state == NULL)
        ClearActiveID();

    // Release focus when we click outside
    if (g.ActiveId == id && io.MouseClicked[0] && !init_state && !init_make_active) //-V560
        clear_active_id = true;

    // Lock the decision of whether we are going to take the path displaying the cursor or selection
    const bool render_cursor = (g.ActiveId == id) || (state && user_scroll_active);
    bool render_selection = state && state->HasSelection() && (RENDER_SELECTION_WHEN_INACTIVE || render_cursor);
    bool value_changed = false;
    bool enter_pressed = false;

    // When read-only we always use the live data passed to the function
    // FIXME-OPT: Because our selection/cursor code currently needs the wide text we need to convert it when active, which is not ideal :(
    if (is_readonly && state != NULL && (render_cursor || render_selection))
    {
        const char* buf_end = NULL;
        state->TextW.resize(buf_size + 1);
        state->CurLenW = ImTextStrFromUtf8(state->TextW.Data, state->TextW.Size, buf, NULL, &buf_end);
        state->CurLenA = (int)(buf_end - buf);
        state->CursorClamp();
        render_selection &= state->HasSelection();
    }

    // Select the buffer to render.
    const bool buf_display_from_state = (render_cursor || render_selection || g.ActiveId == id) && !is_readonly && state && state->TextAIsValid;
    const bool is_displaying_hint = (hint != NULL && (buf_display_from_state ? state->TextA.Data : buf)[0] == 0);

    // Password pushes a temporary font with only a fallback glyph
    if (is_password && !is_displaying_hint)
    {
        const ImFontGlyph* glyph = g.Font->FindGlyph('*');
        ImFont* password_font = &g.InputTextPasswordFont;
        password_font->FontSize = g.Font->FontSize;
        password_font->Scale = g.Font->Scale;
        password_font->DisplayOffset = g.Font->DisplayOffset;
        password_font->Ascent = g.Font->Ascent;
        password_font->Descent = g.Font->Descent;
        password_font->ContainerAtlas = g.Font->ContainerAtlas;
        password_font->FallbackGlyph = glyph;
        password_font->FallbackAdvanceX = glyph->AdvanceX;
        IM_ASSERT(password_font->Glyphs.empty() && password_font->IndexAdvanceX.empty() && password_font->IndexLookup.empty());
        PushFont(password_font);
    }

    // Process mouse inputs and character inputs
    int backup_current_text_length = 0;
    if (g.ActiveId == id)
    {
        IM_ASSERT(state != NULL);
        backup_current_text_length = state->CurLenA;
        state->BufCapacityA = buf_size;
        state->UserFlags = flags;
        state->UserCallback = callback;
        state->UserCallbackData = callback_user_data;

        // Although we are active we don't prevent mouse from hovering other elements unless we are interacting right now with the widget.
        // Down the line we should have a cleaner library-wide concept of Selected vs Active.
        g.ActiveIdAllowOverlap = !io.MouseDown[0];
        g.WantTextInputNextFrame = 1;

        // Edit in progress
        const float mouse_x = (io.MousePos.x - frame_bb.Min.x - style.FramePadding.x) + state->ScrollX;
        const float mouse_y = (is_multiline ? (io.MousePos.y - draw_window->DC.CursorPos.y - style.FramePadding.y) : (g.FontSize*0.5f));

        const bool is_osx = io.ConfigMacOSXBehaviors;
        if (select_all || (hovered && !is_osx && io.MouseDoubleClicked[0]))
        {
            state->SelectAll();
            state->SelectedAllMouseLock = true;
        }
        else if (hovered && is_osx && io.MouseDoubleClicked[0])
        {
            // Double-click select a word only, OS X style (by simulating keystrokes)
            state->OnKeyPressed(STB_TEXTEDIT_K_WORDLEFT);
            state->OnKeyPressed(STB_TEXTEDIT_K_WORDRIGHT | STB_TEXTEDIT_K_SHIFT);
        }
        else if (io.MouseClicked[0] && !state->SelectedAllMouseLock)
        {
            if (hovered)
            {
                stb_textedit_click(state, &state->Stb, mouse_x, mouse_y);
                state->CursorAnimReset();
            }
        }
        else if (io.MouseDown[0] && !state->SelectedAllMouseLock && (io.MouseDelta.x != 0.0f || io.MouseDelta.y != 0.0f))
        {
            stb_textedit_drag(state, &state->Stb, mouse_x, mouse_y);
            state->CursorAnimReset();
            state->CursorFollow = true;
        }
        if (state->SelectedAllMouseLock && !io.MouseDown[0])
            state->SelectedAllMouseLock = false;

        // It is ill-defined whether the back-end needs to send a \t character when pressing the TAB keys.
        // Win32 and GLFW naturally do it but not SDL.
        const bool ignore_char_inputs = (io.KeyCtrl && !io.KeyAlt) || (is_osx && io.KeySuper);
        if ((flags & ImGuiInputTextFlags_AllowTabInput) && IsKeyPressedMap(ImGuiKey_Tab) && !ignore_char_inputs && !io.KeyShift && !is_readonly)
            if (!io.InputQueueCharacters.contains('\t'))
            {
                unsigned int c = '\t'; // Insert TAB
                if (InputTextFilterCharacter(&c, flags, callback, callback_user_data))
                    state->OnKeyPressed((int)c);
            }

        // Process regular text input (before we check for Return because using some IME will effectively send a Return?)
        // We ignore CTRL inputs, but need to allow ALT+CTRL as some keyboards (e.g. German) use AltGR (which _is_ Alt+Ctrl) to input certain characters.
        if (io.InputQueueCharacters.Size > 0)
        {
            if (!ignore_char_inputs && !is_readonly && !user_nav_input_start)
                for (int n = 0; n < io.InputQueueCharacters.Size; n++)
                {
                    // Insert character if they pass filtering
                    unsigned int c = (unsigned int)io.InputQueueCharacters[n];
                    if (c == '\t' && io.KeyShift)
                        continue;
                    if (InputTextFilterCharacter(&c, flags, callback, callback_user_data))
                        state->OnKeyPressed((int)c);
                }

            // Consume characters
            io.InputQueueCharacters.resize(0);
        }
    }

    // Process other shortcuts/key-presses
    bool cancel_edit = false;
    if (g.ActiveId == id && !g.ActiveIdIsJustActivated && !clear_active_id)
    {
        IM_ASSERT(state != NULL);
        const int k_mask = (io.KeyShift ? STB_TEXTEDIT_K_SHIFT : 0);
        const bool is_osx = io.ConfigMacOSXBehaviors;
        const bool is_shortcut_key = (is_osx ? (io.KeySuper && !io.KeyCtrl) : (io.KeyCtrl && !io.KeySuper)) && !io.KeyAlt && !io.KeyShift; // OS X style: Shortcuts using Cmd/Super instead of Ctrl
        const bool is_osx_shift_shortcut = is_osx && io.KeySuper && io.KeyShift && !io.KeyCtrl && !io.KeyAlt;
        const bool is_wordmove_key_down = is_osx ? io.KeyAlt : io.KeyCtrl;                     // OS X style: Text editing cursor movement using Alt instead of Ctrl
        const bool is_startend_key_down = is_osx && io.KeySuper && !io.KeyCtrl && !io.KeyAlt;  // OS X style: Line/Text Start and End using Cmd+Arrows instead of Home/End
        const bool is_ctrl_key_only = io.KeyCtrl && !io.KeyShift && !io.KeyAlt && !io.KeySuper;
        const bool is_shift_key_only = io.KeyShift && !io.KeyCtrl && !io.KeyAlt && !io.KeySuper;

        const bool is_cut   = ((is_shortcut_key && IsKeyPressedMap(ImGuiKey_X)) || (is_shift_key_only && IsKeyPressedMap(ImGuiKey_Delete))) && !is_readonly && !is_password && (!is_multiline || state->HasSelection());
        const bool is_copy  = ((is_shortcut_key && IsKeyPressedMap(ImGuiKey_C)) || (is_ctrl_key_only  && IsKeyPressedMap(ImGuiKey_Insert))) && !is_password && (!is_multiline || state->HasSelection());
        const bool is_paste = ((is_shortcut_key && IsKeyPressedMap(ImGuiKey_V)) || (is_shift_key_only && IsKeyPressedMap(ImGuiKey_Insert))) && !is_readonly;
        const bool is_undo  = ((is_shortcut_key && IsKeyPressedMap(ImGuiKey_Z)) && !is_readonly && is_undoable);
        const bool is_redo  = ((is_shortcut_key && IsKeyPressedMap(ImGuiKey_Y)) || (is_osx_shift_shortcut && IsKeyPressedMap(ImGuiKey_Z))) && !is_readonly && is_undoable;

        if (IsKeyPressedMap(ImGuiKey_LeftArrow))                        { state->OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_LINESTART : is_wordmove_key_down ? STB_TEXTEDIT_K_WORDLEFT : STB_TEXTEDIT_K_LEFT) | k_mask); }
        else if (IsKeyPressedMap(ImGuiKey_RightArrow))                  { state->OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_LINEEND : is_wordmove_key_down ? STB_TEXTEDIT_K_WORDRIGHT : STB_TEXTEDIT_K_RIGHT) | k_mask); }
        else if (IsKeyPressedMap(ImGuiKey_UpArrow) && is_multiline)     { if (io.KeyCtrl) SetWindowScrollY(draw_window, ImMax(draw_window->Scroll.y - g.FontSize, 0.0f)); else state->OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_TEXTSTART : STB_TEXTEDIT_K_UP) | k_mask); }
        else if (IsKeyPressedMap(ImGuiKey_DownArrow) && is_multiline)   { if (io.KeyCtrl) SetWindowScrollY(draw_window, ImMin(draw_window->Scroll.y + g.FontSize, GetScrollMaxY())); else state->OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_TEXTEND : STB_TEXTEDIT_K_DOWN) | k_mask); }
        else if (IsKeyPressedMap(ImGuiKey_Home))                        { state->OnKeyPressed(io.KeyCtrl ? STB_TEXTEDIT_K_TEXTSTART | k_mask : STB_TEXTEDIT_K_LINESTART | k_mask); }
        else if (IsKeyPressedMap(ImGuiKey_End))                         { state->OnKeyPressed(io.KeyCtrl ? STB_TEXTEDIT_K_TEXTEND | k_mask : STB_TEXTEDIT_K_LINEEND | k_mask); }
        else if (IsKeyPressedMap(ImGuiKey_Delete) && !is_readonly)      { state->OnKeyPressed(STB_TEXTEDIT_K_DELETE | k_mask); }
        else if (IsKeyPressedMap(ImGuiKey_Backspace) && !is_readonly)
        {
            if (!state->HasSelection())
            {
                if (is_wordmove_key_down)
                    state->OnKeyPressed(STB_TEXTEDIT_K_WORDLEFT|STB_TEXTEDIT_K_SHIFT);
                else if (is_osx && io.KeySuper && !io.KeyAlt && !io.KeyCtrl)
                    state->OnKeyPressed(STB_TEXTEDIT_K_LINESTART|STB_TEXTEDIT_K_SHIFT);
            }
            state->OnKeyPressed(STB_TEXTEDIT_K_BACKSPACE | k_mask);
        }
        else if (IsKeyPressedMap(ImGuiKey_Enter))
        {
            bool ctrl_enter_for_new_line = (flags & ImGuiInputTextFlags_CtrlEnterForNewLine) != 0;
            if (!is_multiline || (ctrl_enter_for_new_line && !io.KeyCtrl) || (!ctrl_enter_for_new_line && io.KeyCtrl))
            {
                enter_pressed = clear_active_id = true;
            }
            else if (!is_readonly)
            {
                unsigned int c = '\n'; // Insert new line
                if (InputTextFilterCharacter(&c, flags, callback, callback_user_data))
                    state->OnKeyPressed((int)c);
            }
        }
        else if (IsKeyPressedMap(ImGuiKey_Escape))
        {
            clear_active_id = cancel_edit = true;
        }
        else if (is_undo || is_redo)
        {
            state->OnKeyPressed(is_undo ? STB_TEXTEDIT_K_UNDO : STB_TEXTEDIT_K_REDO);
            state->ClearSelection();
        }
        else if (is_shortcut_key && IsKeyPressedMap(ImGuiKey_A))
        {
            state->SelectAll();
            state->CursorFollow = true;
        }
        else if (is_cut || is_copy)
        {
            // Cut, Copy
            if (io.SetClipboardTextFn)
            {
                const int ib = state->HasSelection() ? ImMin(state->Stb.select_start, state->Stb.select_end) : 0;
                const int ie = state->HasSelection() ? ImMax(state->Stb.select_start, state->Stb.select_end) : state->CurLenW;
                const int clipboard_data_len = ImTextCountUtf8BytesFromStr(state->TextW.Data + ib, state->TextW.Data + ie) + 1;
                char* clipboard_data = (char*)IM_ALLOC(clipboard_data_len * sizeof(char));
                ImTextStrToUtf8(clipboard_data, clipboard_data_len, state->TextW.Data + ib, state->TextW.Data + ie);
                SetClipboardText(clipboard_data);
                MemFree(clipboard_data);
            }
            if (is_cut)
            {
                if (!state->HasSelection())
                    state->SelectAll();
                state->CursorFollow = true;
                stb_textedit_cut(state, &state->Stb);
            }
        }
        else if (is_paste)
        {
            if (const char* clipboard = GetClipboardText())
            {
                // Filter pasted buffer
                const int clipboard_len = (int)strlen(clipboard);
                ImWchar* clipboard_filtered = (ImWchar*)IM_ALLOC((clipboard_len+1) * sizeof(ImWchar));
                int clipboard_filtered_len = 0;
                for (const char* s = clipboard; *s; )
                {
                    unsigned int c;
                    s += ImTextCharFromUtf8(&c, s, NULL);
                    if (c == 0)
                        break;
                    if (c >= 0x10000 || !InputTextFilterCharacter(&c, flags, callback, callback_user_data))
                        continue;
                    clipboard_filtered[clipboard_filtered_len++] = (ImWchar)c;
                }
                clipboard_filtered[clipboard_filtered_len] = 0;
                if (clipboard_filtered_len > 0) // If everything was filtered, ignore the pasting operation
                {
                    stb_textedit_paste(state, &state->Stb, clipboard_filtered, clipboard_filtered_len);
                    state->CursorFollow = true;
                }
                MemFree(clipboard_filtered);
            }
        }

        // Update render selection flag after events have been handled, so selection highlight can be displayed during the same frame.
        render_selection |= state->HasSelection() && (RENDER_SELECTION_WHEN_INACTIVE || render_cursor);
    }

    // Process callbacks and apply result back to user's buffer.
    if (g.ActiveId == id)
    {
        IM_ASSERT(state != NULL);
        const char* apply_new_text = NULL;
        int apply_new_text_length = 0;
        if (cancel_edit)
        {
            // Restore initial value. Only return true if restoring to the initial value changes the current buffer contents.
            if (!is_readonly && strcmp(buf, state->InitialTextA.Data) != 0)
            {
                apply_new_text = state->InitialTextA.Data;
                apply_new_text_length = state->InitialTextA.Size - 1;
            }
        }

        // When using 'ImGuiInputTextFlags_EnterReturnsTrue' as a special case we reapply the live buffer back to the input buffer before clearing ActiveId, even though strictly speaking it wasn't modified on this frame.
        // If we didn't do that, code like InputInt() with ImGuiInputTextFlags_EnterReturnsTrue would fail. Also this allows the user to use InputText() with ImGuiInputTextFlags_EnterReturnsTrue without maintaining any user-side storage.
        bool apply_edit_back_to_user_buffer = !cancel_edit || (enter_pressed && (flags & ImGuiInputTextFlags_EnterReturnsTrue) != 0);
        if (apply_edit_back_to_user_buffer)
        {
            // Apply new value immediately - copy modified buffer back
            // Note that as soon as the input box is active, the in-widget value gets priority over any underlying modification of the input buffer
            // FIXME: We actually always render 'buf' when calling DrawList->AddText, making the comment above incorrect.
            // FIXME-OPT: CPU waste to do this every time the widget is active, should mark dirty state from the stb_textedit callbacks.
            if (!is_readonly)
            {
                state->TextAIsValid = true;
                state->TextA.resize(state->TextW.Size * 4 + 1);
                ImTextStrToUtf8(state->TextA.Data, state->TextA.Size, state->TextW.Data, NULL);
            }

            // User callback
            if ((flags & (ImGuiInputTextFlags_CallbackCompletion | ImGuiInputTextFlags_CallbackHistory | ImGuiInputTextFlags_CallbackAlways)) != 0)
            {
                IM_ASSERT(callback != NULL);

                // The reason we specify the usage semantic (Completion/History) is that Completion needs to disable keyboard TABBING at the moment.
                ImGuiInputTextFlags event_flag = 0;
                ImGuiKey event_key = ImGuiKey_COUNT;
                if ((flags & ImGuiInputTextFlags_CallbackCompletion) != 0 && IsKeyPressedMap(ImGuiKey_Tab))
                {
                    event_flag = ImGuiInputTextFlags_CallbackCompletion;
                    event_key = ImGuiKey_Tab;
                }
                else if ((flags & ImGuiInputTextFlags_CallbackHistory) != 0 && IsKeyPressedMap(ImGuiKey_UpArrow))
                {
                    event_flag = ImGuiInputTextFlags_CallbackHistory;
                    event_key = ImGuiKey_UpArrow;
                }
                else if ((flags & ImGuiInputTextFlags_CallbackHistory) != 0 && IsKeyPressedMap(ImGuiKey_DownArrow))
                {
                    event_flag = ImGuiInputTextFlags_CallbackHistory;
                    event_key = ImGuiKey_DownArrow;
                }
                else if (flags & ImGuiInputTextFlags_CallbackAlways)
                    event_flag = ImGuiInputTextFlags_CallbackAlways;

                if (event_flag)
                {
                    ImGuiInputTextCallbackData callback_data;
                    memset(&callback_data, 0, sizeof(ImGuiInputTextCallbackData));
                    callback_data.EventFlag = event_flag;
                    callback_data.Flags = flags;
                    callback_data.UserData = callback_user_data;

                    callback_data.EventKey = event_key;
                    callback_data.Buf = state->TextA.Data;
                    callback_data.BufTextLen = state->CurLenA;
                    callback_data.BufSize = state->BufCapacityA;
                    callback_data.BufDirty = false;

                    // We have to convert from wchar-positions to UTF-8-positions, which can be pretty slow (an incentive to ditch the ImWchar buffer, see https://github.com/nothings/stb/issues/188)
                    ImWchar* text = state->TextW.Data;
                    const int utf8_cursor_pos = callback_data.CursorPos = ImTextCountUtf8BytesFromStr(text, text + state->Stb.cursor);
                    const int utf8_selection_start = callback_data.SelectionStart = ImTextCountUtf8BytesFromStr(text, text + state->Stb.select_start);
                    const int utf8_selection_end = callback_data.SelectionEnd = ImTextCountUtf8BytesFromStr(text, text + state->Stb.select_end);

                    // Call user code
                    callback(&callback_data);

                    // Read back what user may have modified
                    IM_ASSERT(callback_data.Buf == state->TextA.Data);  // Invalid to modify those fields
                    IM_ASSERT(callback_data.BufSize == state->BufCapacityA);
                    IM_ASSERT(callback_data.Flags == flags);
                    if (callback_data.CursorPos != utf8_cursor_pos)            { state->Stb.cursor = ImTextCountCharsFromUtf8(callback_data.Buf, callback_data.Buf + callback_data.CursorPos); state->CursorFollow = true; }
                    if (callback_data.SelectionStart != utf8_selection_start)  { state->Stb.select_start = ImTextCountCharsFromUtf8(callback_data.Buf, callback_data.Buf + callback_data.SelectionStart); }
                    if (callback_data.SelectionEnd != utf8_selection_end)      { state->Stb.select_end = ImTextCountCharsFromUtf8(callback_data.Buf, callback_data.Buf + callback_data.SelectionEnd); }
                    if (callback_data.BufDirty)
                    {
                        IM_ASSERT(callback_data.BufTextLen == (int)strlen(callback_data.Buf)); // You need to maintain BufTextLen if you change the text!
                        if (callback_data.BufTextLen > backup_current_text_length && is_resizable)
                            state->TextW.resize(state->TextW.Size + (callback_data.BufTextLen - backup_current_text_length));
                        state->CurLenW = ImTextStrFromUtf8(state->TextW.Data, state->TextW.Size, callback_data.Buf, NULL);
                        state->CurLenA = callback_data.BufTextLen;  // Assume correct length and valid UTF-8 from user, saves us an extra strlen()
                        state->CursorAnimReset();
                    }
                }
            }

            // Will copy result string if modified
            if (!is_readonly && strcmp(state->TextA.Data, buf) != 0)
            {
                apply_new_text = state->TextA.Data;
                apply_new_text_length = state->CurLenA;
            }
        }

        // Copy result to user buffer
        if (apply_new_text)
        {
            IM_ASSERT(apply_new_text_length >= 0);
            if (backup_current_text_length != apply_new_text_length && is_resizable)
            {
                ImGuiInputTextCallbackData callback_data;
                callback_data.EventFlag = ImGuiInputTextFlags_CallbackResize;
                callback_data.Flags = flags;
                callback_data.Buf = buf;
                callback_data.BufTextLen = apply_new_text_length;
                callback_data.BufSize = ImMax(buf_size, apply_new_text_length + 1);
                callback_data.UserData = callback_user_data;
                callback(&callback_data);
                buf = callback_data.Buf;
                buf_size = callback_data.BufSize;
                apply_new_text_length = ImMin(callback_data.BufTextLen, buf_size - 1);
                IM_ASSERT(apply_new_text_length <= buf_size);
            }

            // If the underlying buffer resize was denied or not carried to the next frame, apply_new_text_length+1 may be >= buf_size.
            ImStrncpy(buf, apply_new_text, ImMin(apply_new_text_length + 1, buf_size));
            value_changed = true;
        }

        // Clear temporary user storage
        state->UserFlags = 0;
        state->UserCallback = NULL;
        state->UserCallbackData = NULL;
    }

    // Release active ID at the end of the function (so e.g. pressing Return still does a final application of the value)
    if (clear_active_id && g.ActiveId == id)
        ClearActiveID();

    // Render frame
    if (!is_multiline)
    {
        RenderNavHighlight(frame_bb, id);
        RenderFrame(frame_bb.Min, frame_bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);
    }

    const ImVec4 clip_rect(frame_bb.Min.x, frame_bb.Min.y, frame_bb.Min.x + size.x, frame_bb.Min.y + size.y); // Not using frame_bb.Max because we have adjusted size
    ImVec2 draw_pos = is_multiline ? draw_window->DC.CursorPos : frame_bb.Min + style.FramePadding;
    ImVec2 text_size(0.0f, 0.0f);

    // Set upper limit of single-line InputTextEx() at 2 million characters strings. The current pathological worst case is a long line
    // without any carriage return, which would makes ImFont::RenderText() reserve too many vertices and probably crash. Avoid it altogether.
    // Note that we only use this limit on single-line InputText(), so a pathologically large line on a InputTextMultiline() would still crash.
    const int buf_display_max_length = 2 * 1024 * 1024;
    const char* buf_display = buf_display_from_state ? state->TextA.Data : buf; //-V595
    const char* buf_display_end = NULL; // We have specialized paths below for setting the length
    if (is_displaying_hint)
    {
        buf_display = hint;
        buf_display_end = hint + strlen(hint);
    }

    // Render text. We currently only render selection when the widget is active or while scrolling.
    // FIXME: We could remove the '&& render_cursor' to keep rendering selection when inactive.
    if (render_cursor || render_selection)
    {
        IM_ASSERT(state != NULL);
        if (!is_displaying_hint)
            buf_display_end = buf_display + state->CurLenA;

        // Render text (with cursor and selection)
        // This is going to be messy. We need to:
        // - Display the text (this alone can be more easily clipped)
        // - Handle scrolling, highlight selection, display cursor (those all requires some form of 1d->2d cursor position calculation)
        // - Measure text height (for scrollbar)
        // We are attempting to do most of that in **one main pass** to minimize the computation cost (non-negligible for large amount of text) + 2nd pass for selection rendering (we could merge them by an extra refactoring effort)
        // FIXME: This should occur on buf_display but we'd need to maintain cursor/select_start/select_end for UTF-8.
        const ImWchar* text_begin = state->TextW.Data;
        ImVec2 cursor_offset, select_start_offset;

        {
            // Find lines numbers straddling 'cursor' (slot 0) and 'select_start' (slot 1) positions.
            const ImWchar* searches_input_ptr[2] = { NULL, NULL };
            int searches_result_line_no[2] = { -1000, -1000 };
            int searches_remaining = 0;
            if (render_cursor)
            {
                searches_input_ptr[0] = text_begin + state->Stb.cursor;
                searches_result_line_no[0] = -1;
                searches_remaining++;
            }
            if (render_selection)
            {
                searches_input_ptr[1] = text_begin + ImMin(state->Stb.select_start, state->Stb.select_end);
                searches_result_line_no[1] = -1;
                searches_remaining++;
            }

            // Iterate all lines to find our line numbers
            // In multi-line mode, we never exit the loop until all lines are counted, so add one extra to the searches_remaining counter.
            searches_remaining += is_multiline ? 1 : 0;
            int line_count = 0;
            //for (const ImWchar* s = text_begin; (s = (const ImWchar*)wcschr((const wchar_t*)s, (wchar_t)'\n')) != NULL; s++)  // FIXME-OPT: Could use this when wchar_t are 16-bits
            for (const ImWchar* s = text_begin; *s != 0; s++)
                if (*s == '\n')
                {
                    line_count++;
                    if (searches_result_line_no[0] == -1 && s >= searches_input_ptr[0]) { searches_result_line_no[0] = line_count; if (--searches_remaining <= 0) break; }
                    if (searches_result_line_no[1] == -1 && s >= searches_input_ptr[1]) { searches_result_line_no[1] = line_count; if (--searches_remaining <= 0) break; }
                }
            line_count++;
            if (searches_result_line_no[0] == -1)
                searches_result_line_no[0] = line_count;
            if (searches_result_line_no[1] == -1)
                searches_result_line_no[1] = line_count;

            // Calculate 2d position by finding the beginning of the line and measuring distance
            cursor_offset.x = InputTextCalcTextSizeW(ImStrbolW(searches_input_ptr[0], text_begin), searches_input_ptr[0]).x;
            cursor_offset.y = searches_result_line_no[0] * g.FontSize;
            if (searches_result_line_no[1] >= 0)
            {
                select_start_offset.x = InputTextCalcTextSizeW(ImStrbolW(searches_input_ptr[1], text_begin), searches_input_ptr[1]).x;
                select_start_offset.y = searches_result_line_no[1] * g.FontSize;
            }

            // Store text height (note that we haven't calculated text width at all, see GitHub issues #383, #1224)
            if (is_multiline)
                text_size = ImVec2(size.x, line_count * g.FontSize);
        }

        // Scroll
        if (render_cursor && state->CursorFollow)
        {
            // Horizontal scroll in chunks of quarter width
            if (!(flags & ImGuiInputTextFlags_NoHorizontalScroll))
            {
                const float scroll_increment_x = size.x * 0.25f;
                if (cursor_offset.x < state->ScrollX)
                    state->ScrollX = (float)(int)ImMax(0.0f, cursor_offset.x - scroll_increment_x);
                else if (cursor_offset.x - size.x >= state->ScrollX)
                    state->ScrollX = (float)(int)(cursor_offset.x - size.x + scroll_increment_x);
            }
            else
            {
                state->ScrollX = 0.0f;
            }

            // Vertical scroll
            if (is_multiline)
            {
                float scroll_y = draw_window->Scroll.y;
                if (cursor_offset.y - g.FontSize < scroll_y)
                    scroll_y = ImMax(0.0f, cursor_offset.y - g.FontSize);
                else if (cursor_offset.y - size.y >= scroll_y)
                    scroll_y = cursor_offset.y - size.y;
                draw_window->DC.CursorPos.y += (draw_window->Scroll.y - scroll_y);   // Manipulate cursor pos immediately avoid a frame of lag
                draw_window->Scroll.y = scroll_y;
                draw_pos.y = draw_window->DC.CursorPos.y;
            }

            state->CursorFollow = false;
        }

        // Draw selection
        const ImVec2 draw_scroll = ImVec2(state->ScrollX, 0.0f);
        if (render_selection)
        {
            const ImWchar* text_selected_begin = text_begin + ImMin(state->Stb.select_start, state->Stb.select_end);
            const ImWchar* text_selected_end = text_begin + ImMax(state->Stb.select_start, state->Stb.select_end);

            ImU32 bg_color = GetColorU32(ImGuiCol_TextSelectedBg, render_cursor ? 1.0f : 0.6f); // FIXME: current code flow mandate that render_cursor is always true here, we are leaving the transparent one for tests.
            float bg_offy_up = is_multiline ? 0.0f : -1.0f;    // FIXME: those offsets should be part of the style? they don't play so well with multi-line selection.
            float bg_offy_dn = is_multiline ? 0.0f : 2.0f;
            ImVec2 rect_pos = draw_pos + select_start_offset - draw_scroll;
            for (const ImWchar* p = text_selected_begin; p < text_selected_end; )
            {
                if (rect_pos.y > clip_rect.w + g.FontSize)
                    break;
                if (rect_pos.y < clip_rect.y)
                {
                    //p = (const ImWchar*)wmemchr((const wchar_t*)p, '\n', text_selected_end - p);  // FIXME-OPT: Could use this when wchar_t are 16-bits
                    //p = p ? p + 1 : text_selected_end;
                    while (p < text_selected_end)
                        if (*p++ == '\n')
                            break;
                }
                else
                {
                    ImVec2 rect_size = InputTextCalcTextSizeW(p, text_selected_end, &p, NULL, true);
                    if (rect_size.x <= 0.0f) rect_size.x = (float)(int)(g.Font->GetCharAdvance((ImWchar)' ') * 0.50f); // So we can see selected empty lines
                    ImRect rect(rect_pos + ImVec2(0.0f, bg_offy_up - g.FontSize), rect_pos +ImVec2(rect_size.x, bg_offy_dn));
                    rect.ClipWith(clip_rect);
                    if (rect.Overlaps(clip_rect))
                        draw_window->DrawList->AddRectFilled(rect.Min, rect.Max, bg_color);
                }
                rect_pos.x = draw_pos.x - draw_scroll.x;
                rect_pos.y += g.FontSize;
            }
        }

        // We test for 'buf_display_max_length' as a way to avoid some pathological cases (e.g. single-line 1 MB string) which would make ImDrawList crash.
        if (is_multiline || (buf_display_end - buf_display) < buf_display_max_length)
        {
            ImU32 col = GetColorU32(is_displaying_hint ? ImGuiCol_TextDisabled : ImGuiCol_Text);
            draw_window->DrawList->AddText(g.Font, g.FontSize, draw_pos - draw_scroll, col, buf_display, buf_display_end, 0.0f, is_multiline ? NULL : &clip_rect);
        }

        // Draw blinking cursor
        if (render_cursor)
        {
            state->CursorAnim += io.DeltaTime;
            bool cursor_is_visible = (!g.IO.ConfigInputTextCursorBlink) || (state->CursorAnim <= 0.0f) || ImFmod(state->CursorAnim, 1.20f) <= 0.80f;
            ImVec2 cursor_screen_pos = draw_pos + cursor_offset - draw_scroll;
            ImRect cursor_screen_rect(cursor_screen_pos.x, cursor_screen_pos.y - g.FontSize + 0.5f, cursor_screen_pos.x + 1.0f, cursor_screen_pos.y - 1.5f);
            if (cursor_is_visible && cursor_screen_rect.Overlaps(clip_rect))
                draw_window->DrawList->AddLine(cursor_screen_rect.Min, cursor_screen_rect.GetBL(), GetColorU32(ImGuiCol_Text));

            // Notify OS of text input position for advanced IME (-1 x offset so that Windows IME can cover our cursor. Bit of an extra nicety.)
            if (!is_readonly)
                g.PlatformImePos = ImVec2(cursor_screen_pos.x - 1.0f, cursor_screen_pos.y - g.FontSize);
        }
    }
    else
    {
        // Render text only (no selection, no cursor)
        if (is_multiline)
            text_size = ImVec2(size.x, InputTextCalcTextLenAndLineCount(buf_display, &buf_display_end) * g.FontSize); // We don't need width
        else if (!is_displaying_hint && g.ActiveId == id)
            buf_display_end = buf_display + state->CurLenA;
        else if (!is_displaying_hint)
            buf_display_end = buf_display + strlen(buf_display);

        if (is_multiline || (buf_display_end - buf_display) < buf_display_max_length)
        {
            ImU32 col = GetColorU32(is_displaying_hint ? ImGuiCol_TextDisabled : ImGuiCol_Text);
            draw_window->DrawList->AddText(g.Font, g.FontSize, draw_pos, col, buf_display, buf_display_end, 0.0f, is_multiline ? NULL : &clip_rect);
        }
    }

    if (is_multiline)
    {
        Dummy(text_size + ImVec2(0.0f, g.FontSize)); // Always add room to scroll an extra line
        EndChildFrame();
        EndGroup();
    }

    if (is_password && !is_displaying_hint)
        PopFont();

    // Log as text
    if (g.LogEnabled && !(is_password && !is_displaying_hint))
        LogRenderedText(&draw_pos, buf_display, buf_display_end);

    if (label_size.x > 0)
        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

    if (value_changed)
        MarkItemEdited(id);

    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.ItemFlags);
    if ((flags & ImGuiInputTextFlags_EnterReturnsTrue) != 0)
        return enter_pressed;
    else
        return value_changed;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: ColorEdit, ColorPicker, ColorButton, etc.
//-------------------------------------------------------------------------
// - ColorEdit3()
// - ColorEdit4()
// - ColorPicker3()
// - RenderColorRectWithAlphaCheckerboard() [Internal]
// - ColorPicker4()
// - ColorButton()
// - SetColorEditOptions()
// - ColorTooltip() [Internal]
// - ColorEditOptionsPopup() [Internal]
// - ColorPickerOptionsPopup() [Internal]
//-------------------------------------------------------------------------

bool ImGui::ColorEdit3(const char* label, float col[3], ImGuiColorEditFlags flags)
{
    return ColorEdit4(label, col, flags | ImGuiColorEditFlags_NoAlpha);
}

// Edit colors components (each component in 0.0f..1.0f range).
// See enum ImGuiColorEditFlags_ for available options. e.g. Only access 3 floats if ImGuiColorEditFlags_NoAlpha flag is set.
// With typical options: Left-click on colored square to open color picker. Right-click to open option menu. CTRL-Click over input fields to edit them and TAB to go to next item.
bool ImGui::ColorEdit4(const char* label, float col[4], ImGuiColorEditFlags flags)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const float square_sz = GetFrameHeight();
    const float w_extra = (flags & ImGuiColorEditFlags_NoSmallPreview) ? 0.0f : (square_sz + style.ItemInnerSpacing.x);
    const float w_items_all = GetNextItemWidth() - w_extra;
    const char* label_display_end = FindRenderedTextEnd(label);

    BeginGroup();
    PushID(label);

    // If we're not showing any slider there's no point in doing any HSV conversions
    const ImGuiColorEditFlags flags_untouched = flags;
    if (flags & ImGuiColorEditFlags_NoInputs)
        flags = (flags & (~ImGuiColorEditFlags__DisplayMask)) | ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_NoOptions;

    // Context menu: display and modify options (before defaults are applied)
    if (!(flags & ImGuiColorEditFlags_NoOptions))
        ColorEditOptionsPopup(col, flags);

    // Read stored options
    if (!(flags & ImGuiColorEditFlags__DisplayMask))
        flags |= (g.ColorEditOptions & ImGuiColorEditFlags__DisplayMask);
    if (!(flags & ImGuiColorEditFlags__DataTypeMask))
        flags |= (g.ColorEditOptions & ImGuiColorEditFlags__DataTypeMask);
    if (!(flags & ImGuiColorEditFlags__PickerMask))
        flags |= (g.ColorEditOptions & ImGuiColorEditFlags__PickerMask);
    if (!(flags & ImGuiColorEditFlags__InputMask))
        flags |= (g.ColorEditOptions & ImGuiColorEditFlags__InputMask);
    flags |= (g.ColorEditOptions & ~(ImGuiColorEditFlags__DisplayMask | ImGuiColorEditFlags__DataTypeMask | ImGuiColorEditFlags__PickerMask | ImGuiColorEditFlags__InputMask));
    IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags__DisplayMask)); // Check that only 1 is selected
    IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags__InputMask));   // Check that only 1 is selected

    const bool alpha = (flags & ImGuiColorEditFlags_NoAlpha) == 0;
    const bool hdr = (flags & ImGuiColorEditFlags_HDR) != 0;
    const int components = alpha ? 4 : 3;

    // Convert to the formats we need
    float f[4] = { col[0], col[1], col[2], alpha ? col[3] : 1.0f };
    if ((flags & ImGuiColorEditFlags_InputHSV) && (flags & ImGuiColorEditFlags_DisplayRGB))
        ColorConvertHSVtoRGB(f[0], f[1], f[2], f[0], f[1], f[2]);
    else if ((flags & ImGuiColorEditFlags_InputRGB) && (flags & ImGuiColorEditFlags_DisplayHSV))
        ColorConvertRGBtoHSV(f[0], f[1], f[2], f[0], f[1], f[2]);
    int i[4] = { IM_F32_TO_INT8_UNBOUND(f[0]), IM_F32_TO_INT8_UNBOUND(f[1]), IM_F32_TO_INT8_UNBOUND(f[2]), IM_F32_TO_INT8_UNBOUND(f[3]) };

    bool value_changed = false;
    bool value_changed_as_float = false;

    if ((flags & (ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_DisplayHSV)) != 0 && (flags & ImGuiColorEditFlags_NoInputs) == 0)
    {
        // RGB/HSV 0..255 Sliders
        const float w_item_one  = ImMax(1.0f, (float)(int)((w_items_all - (style.ItemInnerSpacing.x) * (components-1)) / (float)components));
        const float w_item_last = ImMax(1.0f, (float)(int)(w_items_all - (w_item_one + style.ItemInnerSpacing.x) * (components-1)));

        const bool hide_prefix = (w_item_one <= CalcTextSize((flags & ImGuiColorEditFlags_Float) ? "M:0.000" : "M:000").x);
        static const char* ids[4] = { "##X", "##Y", "##Z", "##W" };
        static const char* fmt_table_int[3][4] =
        {
            {   "%3d",   "%3d",   "%3d",   "%3d" }, // Short display
            { "R:%3d", "G:%3d", "B:%3d", "A:%3d" }, // Long display for RGBA
            { "H:%3d", "S:%3d", "V:%3d", "A:%3d" }  // Long display for HSVA
        };
        static const char* fmt_table_float[3][4] =
        {
            {   "%0.3f",   "%0.3f",   "%0.3f",   "%0.3f" }, // Short display
            { "R:%0.3f", "G:%0.3f", "B:%0.3f", "A:%0.3f" }, // Long display for RGBA
            { "H:%0.3f", "S:%0.3f", "V:%0.3f", "A:%0.3f" }  // Long display for HSVA
        };
        const int fmt_idx = hide_prefix ? 0 : (flags & ImGuiColorEditFlags_DisplayHSV) ? 2 : 1;

        for (int n = 0; n < components; n++)
        {
            if (n > 0)
                SameLine(0, style.ItemInnerSpacing.x);
            SetNextItemWidth((n + 1 < components) ? w_item_one : w_item_last);
            if (flags & ImGuiColorEditFlags_Float)
            {
                value_changed |= DragFloat(ids[n], &f[n], 1.0f/255.0f, 0.0f, hdr ? 0.0f : 1.0f, fmt_table_float[fmt_idx][n]);
                value_changed_as_float |= value_changed;
            }
            else
            {
                value_changed |= DragInt(ids[n], &i[n], 1.0f, 0, hdr ? 0 : 255, fmt_table_int[fmt_idx][n]);
            }
            if (!(flags & ImGuiColorEditFlags_NoOptions))
                OpenPopupOnItemClick("context");
        }
    }
    else if ((flags & ImGuiColorEditFlags_DisplayHex) != 0 && (flags & ImGuiColorEditFlags_NoInputs) == 0)
    {
        // RGB Hexadecimal Input
        char buf[64];
        if (alpha)
            ImFormatString(buf, IM_ARRAYSIZE(buf), "#%02X%02X%02X%02X", ImClamp(i[0],0,255), ImClamp(i[1],0,255), ImClamp(i[2],0,255), ImClamp(i[3],0,255));
        else
            ImFormatString(buf, IM_ARRAYSIZE(buf), "#%02X%02X%02X", ImClamp(i[0],0,255), ImClamp(i[1],0,255), ImClamp(i[2],0,255));
        SetNextItemWidth(w_items_all);
        if (InputText("##Text", buf, IM_ARRAYSIZE(buf), ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsUppercase))
        {
            value_changed = true;
            char* p = buf;
            while (*p == '#' || ImCharIsBlankA(*p))
                p++;
            i[0] = i[1] = i[2] = i[3] = 0;
            if (alpha)
                sscanf(p, "%02X%02X%02X%02X", (unsigned int*)&i[0], (unsigned int*)&i[1], (unsigned int*)&i[2], (unsigned int*)&i[3]); // Treat at unsigned (%X is unsigned)
            else
                sscanf(p, "%02X%02X%02X", (unsigned int*)&i[0], (unsigned int*)&i[1], (unsigned int*)&i[2]);
        }
        if (!(flags & ImGuiColorEditFlags_NoOptions))
            OpenPopupOnItemClick("context");
    }

    ImGuiWindow* picker_active_window = NULL;
    if (!(flags & ImGuiColorEditFlags_NoSmallPreview))
    {
        if (!(flags & ImGuiColorEditFlags_NoInputs))
            SameLine(0, style.ItemInnerSpacing.x);

        const ImVec4 col_v4(col[0], col[1], col[2], alpha ? col[3] : 1.0f);
        if (ColorButton("##ColorButton", col_v4, flags))
        {
            if (!(flags & ImGuiColorEditFlags_NoPicker))
            {
                // Store current color and open a picker
                g.ColorPickerRef = col_v4;
                OpenPopup("picker");
                SetNextWindowPos(window->DC.LastItemRect.GetBL() + ImVec2(-1,style.ItemSpacing.y));
            }
        }
        if (!(flags & ImGuiColorEditFlags_NoOptions))
            OpenPopupOnItemClick("context");

        if (BeginPopup("picker"))
        {
            picker_active_window = g.CurrentWindow;
            if (label != label_display_end)
            {
                TextEx(label, label_display_end);
                Spacing();
            }
            ImGuiColorEditFlags picker_flags_to_forward = ImGuiColorEditFlags__DataTypeMask | ImGuiColorEditFlags__PickerMask | ImGuiColorEditFlags__InputMask | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaBar;
            ImGuiColorEditFlags picker_flags = (flags_untouched & picker_flags_to_forward) | ImGuiColorEditFlags_DisplayHSV | ImGuiColorEditFlags_NoLabel | ImGuiColorEditFlags_AlphaPreviewHalf;
            SetNextItemWidth(square_sz * 12.0f); // Use 256 + bar sizes?
            value_changed |= ColorPicker4("##picker", col, picker_flags, &g.ColorPickerRef.x);
            EndPopup();
        }
    }

    if (label != label_display_end && !(flags & ImGuiColorEditFlags_NoLabel))
    {
        SameLine(0, style.ItemInnerSpacing.x);
        TextEx(label, label_display_end);
    }

    // Convert back
    if (value_changed && picker_active_window == NULL)
    {
        if (!value_changed_as_float)
            for (int n = 0; n < 4; n++)
                f[n] = i[n] / 255.0f;
        if ((flags & ImGuiColorEditFlags_DisplayHSV) && (flags & ImGuiColorEditFlags_InputRGB))
            ColorConvertHSVtoRGB(f[0], f[1], f[2], f[0], f[1], f[2]);
        if ((flags & ImGuiColorEditFlags_DisplayRGB) && (flags & ImGuiColorEditFlags_InputHSV))
            ColorConvertRGBtoHSV(f[0], f[1], f[2], f[0], f[1], f[2]);

        col[0] = f[0];
        col[1] = f[1];
        col[2] = f[2];
        if (alpha)
            col[3] = f[3];
    }

    PopID();
    EndGroup();

    // Drag and Drop Target
    // NB: The flag test is merely an optional micro-optimization, BeginDragDropTarget() does the same test.
    if ((window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HoveredRect) && !(flags & ImGuiColorEditFlags_NoDragDrop) && BeginDragDropTarget())
    {
        bool accepted_drag_drop = false;
        if (const ImGuiPayload* payload = AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_3F))
        {
            memcpy((float*)col, payload->Data, sizeof(float) * 3); // Preserve alpha if any //-V512
            value_changed = accepted_drag_drop = true;
        }
        if (const ImGuiPayload* payload = AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_4F))
        {
            memcpy((float*)col, payload->Data, sizeof(float) * components);
            value_changed = accepted_drag_drop = true;
        }

        // Drag-drop payloads are always RGB
        if (accepted_drag_drop && (flags & ImGuiColorEditFlags_InputHSV))
            ColorConvertRGBtoHSV(col[0], col[1], col[2], col[0], col[1], col[2]);
        EndDragDropTarget();
    }

    // When picker is being actively used, use its active id so IsItemActive() will function on ColorEdit4().
    if (picker_active_window && g.ActiveId != 0 && g.ActiveIdWindow == picker_active_window)
        window->DC.LastItemId = g.ActiveId;

    if (value_changed)
        MarkItemEdited(window->DC.LastItemId);

    return value_changed;
}

bool ImGui::ColorPicker3(const char* label, float col[3], ImGuiColorEditFlags flags)
{
    float col4[4] = { col[0], col[1], col[2], 1.0f };
    if (!ColorPicker4(label, col4, flags | ImGuiColorEditFlags_NoAlpha))
        return false;
    col[0] = col4[0]; col[1] = col4[1]; col[2] = col4[2];
    return true;
}

static inline ImU32 ImAlphaBlendColor(ImU32 col_a, ImU32 col_b)
{
    float t = ((col_b >> IM_COL32_A_SHIFT) & 0xFF) / 255.f;
    int r = ImLerp((int)(col_a >> IM_COL32_R_SHIFT) & 0xFF, (int)(col_b >> IM_COL32_R_SHIFT) & 0xFF, t);
    int g = ImLerp((int)(col_a >> IM_COL32_G_SHIFT) & 0xFF, (int)(col_b >> IM_COL32_G_SHIFT) & 0xFF, t);
    int b = ImLerp((int)(col_a >> IM_COL32_B_SHIFT) & 0xFF, (int)(col_b >> IM_COL32_B_SHIFT) & 0xFF, t);
    return IM_COL32(r, g, b, 0xFF);
}

// Helper for ColorPicker4()
// NB: This is rather brittle and will show artifact when rounding this enabled if rounded corners overlap multiple cells. Caller currently responsible for avoiding that.
// I spent a non reasonable amount of time trying to getting this right for ColorButton with rounding+anti-aliasing+ImGuiColorEditFlags_HalfAlphaPreview flag + various grid sizes and offsets, and eventually gave up... probably more reasonable to disable rounding alltogether.
void ImGui::RenderColorRectWithAlphaCheckerboard(ImVec2 p_min, ImVec2 p_max, ImU32 col, float grid_step, ImVec2 grid_off, float rounding, int rounding_corners_flags)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (((col & IM_COL32_A_MASK) >> IM_COL32_A_SHIFT) < 0xFF)
    {
        ImU32 col_bg1 = GetColorU32(ImAlphaBlendColor(IM_COL32(204,204,204,255), col));
        ImU32 col_bg2 = GetColorU32(ImAlphaBlendColor(IM_COL32(128,128,128,255), col));
        window->DrawList->AddRectFilled(p_min, p_max, col_bg1, rounding, rounding_corners_flags);

        int yi = 0;
        for (float y = p_min.y + grid_off.y; y < p_max.y; y += grid_step, yi++)
        {
            float y1 = ImClamp(y, p_min.y, p_max.y), y2 = ImMin(y + grid_step, p_max.y);
            if (y2 <= y1)
                continue;
            for (float x = p_min.x + grid_off.x + (yi & 1) * grid_step; x < p_max.x; x += grid_step * 2.0f)
            {
                float x1 = ImClamp(x, p_min.x, p_max.x), x2 = ImMin(x + grid_step, p_max.x);
                if (x2 <= x1)
                    continue;
                int rounding_corners_flags_cell = 0;
                if (y1 <= p_min.y) { if (x1 <= p_min.x) rounding_corners_flags_cell |= ImDrawCornerFlags_TopLeft; if (x2 >= p_max.x) rounding_corners_flags_cell |= ImDrawCornerFlags_TopRight; }
                if (y2 >= p_max.y) { if (x1 <= p_min.x) rounding_corners_flags_cell |= ImDrawCornerFlags_BotLeft; if (x2 >= p_max.x) rounding_corners_flags_cell |= ImDrawCornerFlags_BotRight; }
                rounding_corners_flags_cell &= rounding_corners_flags;
                window->DrawList->AddRectFilled(ImVec2(x1,y1), ImVec2(x2,y2), col_bg2, rounding_corners_flags_cell ? rounding : 0.0f, rounding_corners_flags_cell);
            }
        }
    }
    else
    {
        window->DrawList->AddRectFilled(p_min, p_max, col, rounding, rounding_corners_flags);
    }
}

// Helper for ColorPicker4()
static void RenderArrowsForVerticalBar(ImDrawList* draw_list, ImVec2 pos, ImVec2 half_sz, float bar_w)
{
    ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + half_sz.x + 1,         pos.y), ImVec2(half_sz.x + 2, half_sz.y + 1), ImGuiDir_Right, IM_COL32_BLACK);
    ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + half_sz.x,             pos.y), half_sz,                              ImGuiDir_Right, IM_COL32_WHITE);
    ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + bar_w - half_sz.x - 1, pos.y), ImVec2(half_sz.x + 2, half_sz.y + 1), ImGuiDir_Left,  IM_COL32_BLACK);
    ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + bar_w - half_sz.x,     pos.y), half_sz,                              ImGuiDir_Left,  IM_COL32_WHITE);
}

// Note: ColorPicker4() only accesses 3 floats if ImGuiColorEditFlags_NoAlpha flag is set.
// (In C++ the 'float col[4]' notation for a function argument is equivalent to 'float* col', we only specify a size to facilitate understanding of the code.)
// FIXME: we adjust the big color square height based on item width, which may cause a flickering feedback loop (if automatic height makes a vertical scrollbar appears, affecting automatic width..)
bool ImGui::ColorPicker4(const char* label, float col[4], ImGuiColorEditFlags flags, const float* ref_col)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImDrawList* draw_list = window->DrawList;
    ImGuiStyle& style = g.Style;
    ImGuiIO& io = g.IO;

    PushID(label);
    BeginGroup();

    if (!(flags & ImGuiColorEditFlags_NoSidePreview))
        flags |= ImGuiColorEditFlags_NoSmallPreview;

    // Context menu: display and store options.
    if (!(flags & ImGuiColorEditFlags_NoOptions))
        ColorPickerOptionsPopup(col, flags);

    // Read stored options
    if (!(flags & ImGuiColorEditFlags__PickerMask))
        flags |= ((g.ColorEditOptions & ImGuiColorEditFlags__PickerMask) ? g.ColorEditOptions : ImGuiColorEditFlags__OptionsDefault) & ImGuiColorEditFlags__PickerMask;
    if (!(flags & ImGuiColorEditFlags__InputMask))
        flags |= ((g.ColorEditOptions & ImGuiColorEditFlags__InputMask) ? g.ColorEditOptions : ImGuiColorEditFlags__OptionsDefault) & ImGuiColorEditFlags__InputMask;
    IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags__PickerMask)); // Check that only 1 is selected
    IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags__InputMask));  // Check that only 1 is selected
    if (!(flags & ImGuiColorEditFlags_NoOptions))
        flags |= (g.ColorEditOptions & ImGuiColorEditFlags_AlphaBar);

    // Setup
    int components = (flags & ImGuiColorEditFlags_NoAlpha) ? 3 : 4;
    bool alpha_bar = (flags & ImGuiColorEditFlags_AlphaBar) && !(flags & ImGuiColorEditFlags_NoAlpha);
    ImVec2 picker_pos = window->DC.CursorPos;
    float square_sz = GetFrameHeight();
    float bars_width = square_sz; // Arbitrary smallish width of Hue/Alpha picking bars
    float sv_picker_size = ImMax(bars_width * 1, GetNextItemWidth() - (alpha_bar ? 2 : 1) * (bars_width + style.ItemInnerSpacing.x)); // Saturation/Value picking box
    float bar0_pos_x = picker_pos.x + sv_picker_size + style.ItemInnerSpacing.x;
    float bar1_pos_x = bar0_pos_x + bars_width + style.ItemInnerSpacing.x;
    float bars_triangles_half_sz = (float)(int)(bars_width * 0.20f);

    float backup_initial_col[4];
    memcpy(backup_initial_col, col, components * sizeof(float));

    float wheel_thickness = sv_picker_size * 0.08f;
    float wheel_r_outer = sv_picker_size * 0.50f;
    float wheel_r_inner = wheel_r_outer - wheel_thickness;
    ImVec2 wheel_center(picker_pos.x + (sv_picker_size + bars_width)*0.5f, picker_pos.y + sv_picker_size*0.5f);

    // Note: the triangle is displayed rotated with triangle_pa pointing to Hue, but most coordinates stays unrotated for logic.
    float triangle_r = wheel_r_inner - (int)(sv_picker_size * 0.027f);
    ImVec2 triangle_pa = ImVec2(triangle_r, 0.0f); // Hue point.
    ImVec2 triangle_pb = ImVec2(triangle_r * -0.5f, triangle_r * -0.866025f); // Black point.
    ImVec2 triangle_pc = ImVec2(triangle_r * -0.5f, triangle_r * +0.866025f); // White point.

    float H = col[0], S = col[1], V = col[2];
    float R = col[0], G = col[1], B = col[2];
    if (flags & ImGuiColorEditFlags_InputRGB)
        ColorConvertRGBtoHSV(R, G, B, H, S, V);
    else if (flags & ImGuiColorEditFlags_InputHSV)
        ColorConvertHSVtoRGB(H, S, V, R, G, B);

    bool value_changed = false, value_changed_h = false, value_changed_sv = false;

    PushItemFlag(ImGuiItemFlags_NoNav, true);
    if (flags & ImGuiColorEditFlags_PickerHueWheel)
    {
        // Hue wheel + SV triangle logic
        InvisibleButton("hsv", ImVec2(sv_picker_size + style.ItemInnerSpacing.x + bars_width, sv_picker_size));
        if (IsItemActive())
        {
            ImVec2 initial_off = g.IO.MouseClickedPos[0] - wheel_center;
            ImVec2 current_off = g.IO.MousePos - wheel_center;
            float initial_dist2 = ImLengthSqr(initial_off);
            if (initial_dist2 >= (wheel_r_inner-1)*(wheel_r_inner-1) && initial_dist2 <= (wheel_r_outer+1)*(wheel_r_outer+1))
            {
                // Interactive with Hue wheel
                H = ImAtan2(current_off.y, current_off.x) / IM_PI*0.5f;
                if (H < 0.0f)
                    H += 1.0f;
                value_changed = value_changed_h = true;
            }
            float cos_hue_angle = ImCos(-H * 2.0f * IM_PI);
            float sin_hue_angle = ImSin(-H * 2.0f * IM_PI);
            if (ImTriangleContainsPoint(triangle_pa, triangle_pb, triangle_pc, ImRotate(initial_off, cos_hue_angle, sin_hue_angle)))
            {
                // Interacting with SV triangle
                ImVec2 current_off_unrotated = ImRotate(current_off, cos_hue_angle, sin_hue_angle);
                if (!ImTriangleContainsPoint(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated))
                    current_off_unrotated = ImTriangleClosestPoint(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated);
                float uu, vv, ww;
                ImTriangleBarycentricCoords(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated, uu, vv, ww);
                V = ImClamp(1.0f - vv, 0.0001f, 1.0f);
                S = ImClamp(uu / V, 0.0001f, 1.0f);
                value_changed = value_changed_sv = true;
            }
        }
        if (!(flags & ImGuiColorEditFlags_NoOptions))
            OpenPopupOnItemClick("context");
    }
    else if (flags & ImGuiColorEditFlags_PickerHueBar)
    {
        // SV rectangle logic
        InvisibleButton("sv", ImVec2(sv_picker_size, sv_picker_size));
        if (IsItemActive())
        {
            S = ImSaturate((io.MousePos.x - picker_pos.x) / (sv_picker_size-1));
            V = 1.0f - ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size-1));
            value_changed = value_changed_sv = true;
        }
        if (!(flags & ImGuiColorEditFlags_NoOptions))
            OpenPopupOnItemClick("context");

        // Hue bar logic
        SetCursorScreenPos(ImVec2(bar0_pos_x, picker_pos.y));
        InvisibleButton("hue", ImVec2(bars_width, sv_picker_size));
        if (IsItemActive())
        {
            H = ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size-1));
            value_changed = value_changed_h = true;
        }
    }

    // Alpha bar logic
    if (alpha_bar)
    {
        SetCursorScreenPos(ImVec2(bar1_pos_x, picker_pos.y));
        InvisibleButton("alpha", ImVec2(bars_width, sv_picker_size));
        if (IsItemActive())
        {
            col[3] = 1.0f - ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size-1));
            value_changed = true;
        }
    }
    PopItemFlag(); // ImGuiItemFlags_NoNav

    if (!(flags & ImGuiColorEditFlags_NoSidePreview))
    {
        SameLine(0, style.ItemInnerSpacing.x);
        BeginGroup();
    }

    if (!(flags & ImGuiColorEditFlags_NoLabel))
    {
        const char* label_display_end = FindRenderedTextEnd(label);
        if (label != label_display_end)
        {
            if ((flags & ImGuiColorEditFlags_NoSidePreview))
                SameLine(0, style.ItemInnerSpacing.x);
            TextEx(label, label_display_end);
        }
    }

    if (!(flags & ImGuiColorEditFlags_NoSidePreview))
    {
        PushItemFlag(ImGuiItemFlags_NoNavDefaultFocus, true);
        ImVec4 col_v4(col[0], col[1], col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : col[3]);
        if ((flags & ImGuiColorEditFlags_NoLabel))
            Text("Current");

        ImGuiColorEditFlags sub_flags_to_forward = ImGuiColorEditFlags__InputMask | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf | ImGuiColorEditFlags_NoTooltip;
        ColorButton("##current", col_v4, (flags & sub_flags_to_forward), ImVec2(square_sz * 3, square_sz * 2));
        if (ref_col != NULL)
        {
            Text("Original");
            ImVec4 ref_col_v4(ref_col[0], ref_col[1], ref_col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : ref_col[3]);
            if (ColorButton("##original", ref_col_v4, (flags & sub_flags_to_forward), ImVec2(square_sz * 3, square_sz * 2)))
            {
                memcpy(col, ref_col, components * sizeof(float));
                value_changed = true;
            }
        }
        PopItemFlag();
        EndGroup();
    }

    // Convert back color to RGB
    if (value_changed_h || value_changed_sv)
    {
        if (flags & ImGuiColorEditFlags_InputRGB)
        {
            ColorConvertHSVtoRGB(H >= 1.0f ? H - 10 * 1e-6f : H, S > 0.0f ? S : 10*1e-6f, V > 0.0f ? V : 1e-6f, col[0], col[1], col[2]);
        }
        else if (flags & ImGuiColorEditFlags_InputHSV)
        {
            col[0] = H;
            col[1] = S;
            col[2] = V;
        }
    }

    // R,G,B and H,S,V slider color editor
    bool value_changed_fix_hue_wrap = false;
    if ((flags & ImGuiColorEditFlags_NoInputs) == 0)
    {
        PushItemWidth((alpha_bar ? bar1_pos_x : bar0_pos_x) + bars_width - picker_pos.x);
        ImGuiColorEditFlags sub_flags_to_forward = ImGuiColorEditFlags__DataTypeMask | ImGuiColorEditFlags__InputMask | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_NoOptions | ImGuiColorEditFlags_NoSmallPreview | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf;
        ImGuiColorEditFlags sub_flags = (flags & sub_flags_to_forward) | ImGuiColorEditFlags_NoPicker;
        if (flags & ImGuiColorEditFlags_DisplayRGB || (flags & ImGuiColorEditFlags__DisplayMask) == 0)
            if (ColorEdit4("##rgb", col, sub_flags | ImGuiColorEditFlags_DisplayRGB))
            {
                // FIXME: Hackily differenciating using the DragInt (ActiveId != 0 && !ActiveIdAllowOverlap) vs. using the InputText or DropTarget.
                // For the later we don't want to run the hue-wrap canceling code. If you are well versed in HSV picker please provide your input! (See #2050)
                value_changed_fix_hue_wrap = (g.ActiveId != 0 && !g.ActiveIdAllowOverlap);
                value_changed = true;
            }
        if (flags & ImGuiColorEditFlags_DisplayHSV || (flags & ImGuiColorEditFlags__DisplayMask) == 0)
            value_changed |= ColorEdit4("##hsv", col, sub_flags | ImGuiColorEditFlags_DisplayHSV);
        if (flags & ImGuiColorEditFlags_DisplayHex || (flags & ImGuiColorEditFlags__DisplayMask) == 0)
            value_changed |= ColorEdit4("##hex", col, sub_flags | ImGuiColorEditFlags_DisplayHex);
        PopItemWidth();
    }

    // Try to cancel hue wrap (after ColorEdit4 call), if any
    if (value_changed_fix_hue_wrap && (flags & ImGuiColorEditFlags_InputRGB))
    {
        float new_H, new_S, new_V;
        ColorConvertRGBtoHSV(col[0], col[1], col[2], new_H, new_S, new_V);
        if (new_H <= 0 && H > 0)
        {
            if (new_V <= 0 && V != new_V)
                ColorConvertHSVtoRGB(H, S, new_V <= 0 ? V * 0.5f : new_V, col[0], col[1], col[2]);
            else if (new_S <= 0)
                ColorConvertHSVtoRGB(H, new_S <= 0 ? S * 0.5f : new_S, new_V, col[0], col[1], col[2]);
        }
    }

    if (value_changed)
    {
        if (flags & ImGuiColorEditFlags_InputRGB)
        {
            R = col[0];
            G = col[1];
            B = col[2];
            ColorConvertRGBtoHSV(R, G, B, H, S, V);
        }
        else if (flags & ImGuiColorEditFlags_InputHSV)
        {
            H = col[0];
            S = col[1];
            V = col[2];
            ColorConvertHSVtoRGB(H, S, V, R, G, B);
        }
    }

    ImVec4 hue_color_f(1, 1, 1, 1); ColorConvertHSVtoRGB(H, 1, 1, hue_color_f.x, hue_color_f.y, hue_color_f.z);
    ImU32 hue_color32 = ColorConvertFloat4ToU32(hue_color_f);
    ImU32 col32_no_alpha = ColorConvertFloat4ToU32(ImVec4(R, G, B, 1.0f));

    const ImU32 hue_colors[6+1] = { IM_COL32(255,0,0,255), IM_COL32(255,255,0,255), IM_COL32(0,255,0,255), IM_COL32(0,255,255,255), IM_COL32(0,0,255,255), IM_COL32(255,0,255,255), IM_COL32(255,0,0,255) };
    ImVec2 sv_cursor_pos;

    if (flags & ImGuiColorEditFlags_PickerHueWheel)
    {
        // Render Hue Wheel
        const float aeps = 1.5f / wheel_r_outer; // Half a pixel arc length in radians (2pi cancels out).
        const int segment_per_arc = ImMax(4, (int)wheel_r_outer / 12);
        for (int n = 0; n < 6; n++)
        {
            const float a0 = (n)     /6.0f * 2.0f * IM_PI - aeps;
            const float a1 = (n+1.0f)/6.0f * 2.0f * IM_PI + aeps;
            const int vert_start_idx = draw_list->VtxBuffer.Size;
            draw_list->PathArcTo(wheel_center, (wheel_r_inner + wheel_r_outer)*0.5f, a0, a1, segment_per_arc);
            draw_list->PathStroke(IM_COL32_WHITE, false, wheel_thickness);
            const int vert_end_idx = draw_list->VtxBuffer.Size;

            // Paint colors over existing vertices
            ImVec2 gradient_p0(wheel_center.x + ImCos(a0) * wheel_r_inner, wheel_center.y + ImSin(a0) * wheel_r_inner);
            ImVec2 gradient_p1(wheel_center.x + ImCos(a1) * wheel_r_inner, wheel_center.y + ImSin(a1) * wheel_r_inner);
            ShadeVertsLinearColorGradientKeepAlpha(draw_list, vert_start_idx, vert_end_idx, gradient_p0, gradient_p1, hue_colors[n], hue_colors[n+1]);
        }

        // Render Cursor + preview on Hue Wheel
        float cos_hue_angle = ImCos(H * 2.0f * IM_PI);
        float sin_hue_angle = ImSin(H * 2.0f * IM_PI);
        ImVec2 hue_cursor_pos(wheel_center.x + cos_hue_angle * (wheel_r_inner+wheel_r_outer)*0.5f, wheel_center.y + sin_hue_angle * (wheel_r_inner+wheel_r_outer)*0.5f);
        float hue_cursor_rad = value_changed_h ? wheel_thickness * 0.65f : wheel_thickness * 0.55f;
        int hue_cursor_segments = ImClamp((int)(hue_cursor_rad / 1.4f), 9, 32);
        draw_list->AddCircleFilled(hue_cursor_pos, hue_cursor_rad, hue_color32, hue_cursor_segments);
        draw_list->AddCircle(hue_cursor_pos, hue_cursor_rad+1, IM_COL32(128,128,128,255), hue_cursor_segments);
        draw_list->AddCircle(hue_cursor_pos, hue_cursor_rad, IM_COL32_WHITE, hue_cursor_segments);

        // Render SV triangle (rotated according to hue)
        ImVec2 tra = wheel_center + ImRotate(triangle_pa, cos_hue_angle, sin_hue_angle);
        ImVec2 trb = wheel_center + ImRotate(triangle_pb, cos_hue_angle, sin_hue_angle);
        ImVec2 trc = wheel_center + ImRotate(triangle_pc, cos_hue_angle, sin_hue_angle);
        ImVec2 uv_white = GetFontTexUvWhitePixel();
        draw_list->PrimReserve(6, 6);
        draw_list->PrimVtx(tra, uv_white, hue_color32);
        draw_list->PrimVtx(trb, uv_white, hue_color32);
        draw_list->PrimVtx(trc, uv_white, IM_COL32_WHITE);
        draw_list->PrimVtx(tra, uv_white, IM_COL32_BLACK_TRANS);
        draw_list->PrimVtx(trb, uv_white, IM_COL32_BLACK);
        draw_list->PrimVtx(trc, uv_white, IM_COL32_BLACK_TRANS);
        draw_list->AddTriangle(tra, trb, trc, IM_COL32(128,128,128,255), 1.5f);
        sv_cursor_pos = ImLerp(ImLerp(trc, tra, ImSaturate(S)), trb, ImSaturate(1 - V));
    }
    else if (flags & ImGuiColorEditFlags_PickerHueBar)
    {
        // Render SV Square
        draw_list->AddRectFilledMultiColor(picker_pos, picker_pos + ImVec2(sv_picker_size,sv_picker_size), IM_COL32_WHITE, hue_color32, hue_color32, IM_COL32_WHITE);
        draw_list->AddRectFilledMultiColor(picker_pos, picker_pos + ImVec2(sv_picker_size,sv_picker_size), IM_COL32_BLACK_TRANS, IM_COL32_BLACK_TRANS, IM_COL32_BLACK, IM_COL32_BLACK);
        RenderFrameBorder(picker_pos, picker_pos + ImVec2(sv_picker_size,sv_picker_size), 0.0f);
        sv_cursor_pos.x = ImClamp((float)(int)(picker_pos.x + ImSaturate(S)     * sv_picker_size + 0.5f), picker_pos.x + 2, picker_pos.x + sv_picker_size - 2); // Sneakily prevent the circle to stick out too much
        sv_cursor_pos.y = ImClamp((float)(int)(picker_pos.y + ImSaturate(1 - V) * sv_picker_size + 0.5f), picker_pos.y + 2, picker_pos.y + sv_picker_size - 2);

        // Render Hue Bar
        for (int i = 0; i < 6; ++i)
            draw_list->AddRectFilledMultiColor(ImVec2(bar0_pos_x, picker_pos.y + i * (sv_picker_size / 6)), ImVec2(bar0_pos_x + bars_width, picker_pos.y + (i + 1) * (sv_picker_size / 6)), hue_colors[i], hue_colors[i], hue_colors[i + 1], hue_colors[i + 1]);
        float bar0_line_y = (float)(int)(picker_pos.y + H * sv_picker_size + 0.5f);
        RenderFrameBorder(ImVec2(bar0_pos_x, picker_pos.y), ImVec2(bar0_pos_x + bars_width, picker_pos.y + sv_picker_size), 0.0f);
        RenderArrowsForVerticalBar(draw_list, ImVec2(bar0_pos_x - 1, bar0_line_y), ImVec2(bars_triangles_half_sz + 1, bars_triangles_half_sz), bars_width + 2.0f);
    }

    // Render cursor/preview circle (clamp S/V within 0..1 range because floating points colors may lead HSV values to be out of range)
    float sv_cursor_rad = value_changed_sv ? 10.0f : 6.0f;
    draw_list->AddCircleFilled(sv_cursor_pos, sv_cursor_rad, col32_no_alpha, 12);
    draw_list->AddCircle(sv_cursor_pos, sv_cursor_rad+1, IM_COL32(128,128,128,255), 12);
    draw_list->AddCircle(sv_cursor_pos, sv_cursor_rad, IM_COL32_WHITE, 12);

    // Render alpha bar
    if (alpha_bar)
    {
        float alpha = ImSaturate(col[3]);
        ImRect bar1_bb(bar1_pos_x, picker_pos.y, bar1_pos_x + bars_width, picker_pos.y + sv_picker_size);
        RenderColorRectWithAlphaCheckerboard(bar1_bb.Min, bar1_bb.Max, IM_COL32(0,0,0,0), bar1_bb.GetWidth() / 2.0f, ImVec2(0.0f, 0.0f));
        draw_list->AddRectFilledMultiColor(bar1_bb.Min, bar1_bb.Max, col32_no_alpha, col32_no_alpha, col32_no_alpha & ~IM_COL32_A_MASK, col32_no_alpha & ~IM_COL32_A_MASK);
        float bar1_line_y = (float)(int)(picker_pos.y + (1.0f - alpha) * sv_picker_size + 0.5f);
        RenderFrameBorder(bar1_bb.Min, bar1_bb.Max, 0.0f);
        RenderArrowsForVerticalBar(draw_list, ImVec2(bar1_pos_x - 1, bar1_line_y), ImVec2(bars_triangles_half_sz + 1, bars_triangles_half_sz), bars_width + 2.0f);
    }

    EndGroup();

    if (value_changed && memcmp(backup_initial_col, col, components * sizeof(float)) == 0)
        value_changed = false;
    if (value_changed)
        MarkItemEdited(window->DC.LastItemId);

    PopID();

    return value_changed;
}

// A little colored square. Return true when clicked.
// FIXME: May want to display/ignore the alpha component in the color display? Yet show it in the tooltip.
// 'desc_id' is not called 'label' because we don't display it next to the button, but only in the tooltip.
// Note that 'col' may be encoded in HSV if ImGuiColorEditFlags_InputHSV is set.
bool ImGui::ColorButton(const char* desc_id, const ImVec4& col, ImGuiColorEditFlags flags, ImVec2 size)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiID id = window->GetID(desc_id);
    float default_size = GetFrameHeight();
    if (size.x == 0.0f)
        size.x = default_size;
    if (size.y == 0.0f)
        size.y = default_size;
    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);
    ItemSize(bb, (size.y >= default_size) ? g.Style.FramePadding.y : 0.0f);
    if (!ItemAdd(bb, id))
        return false;

    bool hovered, held;
    bool pressed = ButtonBehavior(bb, id, &hovered, &held);

    if (flags & ImGuiColorEditFlags_NoAlpha)
        flags &= ~(ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf);

    ImVec4 col_rgb = col;
    if (flags & ImGuiColorEditFlags_InputHSV)
        ColorConvertHSVtoRGB(col_rgb.x, col_rgb.y, col_rgb.z, col_rgb.x, col_rgb.y, col_rgb.z);

    ImVec4 col_rgb_without_alpha(col_rgb.x, col_rgb.y, col_rgb.z, 1.0f);
    float grid_step = ImMin(size.x, size.y) / 2.99f;
    float rounding = ImMin(g.Style.FrameRounding, grid_step * 0.5f);
    ImRect bb_inner = bb;
    float off = -0.75f; // The border (using Col_FrameBg) tends to look off when color is near-opaque and rounding is enabled. This offset seemed like a good middle ground to reduce those artifacts.
    bb_inner.Expand(off);
    if ((flags & ImGuiColorEditFlags_AlphaPreviewHalf) && col_rgb.w < 1.0f)
    {
        float mid_x = (float)(int)((bb_inner.Min.x + bb_inner.Max.x) * 0.5f + 0.5f);
        RenderColorRectWithAlphaCheckerboard(ImVec2(bb_inner.Min.x + grid_step, bb_inner.Min.y), bb_inner.Max, GetColorU32(col_rgb), grid_step, ImVec2(-grid_step + off, off), rounding, ImDrawCornerFlags_TopRight| ImDrawCornerFlags_BotRight);
        window->DrawList->AddRectFilled(bb_inner.Min, ImVec2(mid_x, bb_inner.Max.y), GetColorU32(col_rgb_without_alpha), rounding, ImDrawCornerFlags_TopLeft|ImDrawCornerFlags_BotLeft);
    }
    else
    {
        // Because GetColorU32() multiplies by the global style Alpha and we don't want to display a checkerboard if the source code had no alpha
        ImVec4 col_source = (flags & ImGuiColorEditFlags_AlphaPreview) ? col_rgb : col_rgb_without_alpha;
        if (col_source.w < 1.0f)
            RenderColorRectWithAlphaCheckerboard(bb_inner.Min, bb_inner.Max, GetColorU32(col_source), grid_step, ImVec2(off, off), rounding);
        else
            window->DrawList->AddRectFilled(bb_inner.Min, bb_inner.Max, GetColorU32(col_source), rounding, ImDrawCornerFlags_All);
    }
    RenderNavHighlight(bb, id);
    if (g.Style.FrameBorderSize > 0.0f)
        RenderFrameBorder(bb.Min, bb.Max, rounding);
    else
        window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(ImGuiCol_FrameBg), rounding); // Color button are often in need of some sort of border

    // Drag and Drop Source
    // NB: The ActiveId test is merely an optional micro-optimization, BeginDragDropSource() does the same test.
    if (g.ActiveId == id && !(flags & ImGuiColorEditFlags_NoDragDrop) && BeginDragDropSource())
    {
        if (flags & ImGuiColorEditFlags_NoAlpha)
            SetDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_3F, &col_rgb, sizeof(float) * 3, ImGuiCond_Once);
        else
            SetDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_4F, &col_rgb, sizeof(float) * 4, ImGuiCond_Once);
        ColorButton(desc_id, col, flags);
        SameLine();
        TextEx("Color");
        EndDragDropSource();
    }

    // Tooltip
    if (!(flags & ImGuiColorEditFlags_NoTooltip) && hovered)
        ColorTooltip(desc_id, &col.x, flags & (ImGuiColorEditFlags__InputMask | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf));

    if (pressed)
        MarkItemEdited(id);

    return pressed;
}

// Initialize/override default color options
void ImGui::SetColorEditOptions(ImGuiColorEditFlags flags)
{
    ImGuiContext& g = *GImGui;
    if ((flags & ImGuiColorEditFlags__DisplayMask) == 0)
        flags |= ImGuiColorEditFlags__OptionsDefault & ImGuiColorEditFlags__DisplayMask;
    if ((flags & ImGuiColorEditFlags__DataTypeMask) == 0)
        flags |= ImGuiColorEditFlags__OptionsDefault & ImGuiColorEditFlags__DataTypeMask;
    if ((flags & ImGuiColorEditFlags__PickerMask) == 0)
        flags |= ImGuiColorEditFlags__OptionsDefault & ImGuiColorEditFlags__PickerMask;
    if ((flags & ImGuiColorEditFlags__InputMask) == 0)
        flags |= ImGuiColorEditFlags__OptionsDefault & ImGuiColorEditFlags__InputMask;
    IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags__DisplayMask));    // Check only 1 option is selected
    IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags__DataTypeMask));   // Check only 1 option is selected
    IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags__PickerMask));     // Check only 1 option is selected
    IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags__InputMask));      // Check only 1 option is selected
    g.ColorEditOptions = flags;
}

// Note: only access 3 floats if ImGuiColorEditFlags_NoAlpha flag is set.
void ImGui::ColorTooltip(const char* text, const float* col, ImGuiColorEditFlags flags)
{
    ImGuiContext& g = *GImGui;

    BeginTooltipEx(0, true);
    const char* text_end = text ? FindRenderedTextEnd(text, NULL) : text;
    if (text_end > text)
    {
        TextEx(text, text_end);
        Separator();
    }

    ImVec2 sz(g.FontSize * 3 + g.Style.FramePadding.y * 2, g.FontSize * 3 + g.Style.FramePadding.y * 2);
    ImVec4 cf(col[0], col[1], col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : col[3]);
    int cr = IM_F32_TO_INT8_SAT(col[0]), cg = IM_F32_TO_INT8_SAT(col[1]), cb = IM_F32_TO_INT8_SAT(col[2]), ca = (flags & ImGuiColorEditFlags_NoAlpha) ? 255 : IM_F32_TO_INT8_SAT(col[3]);
    ColorButton("##preview", cf, (flags & (ImGuiColorEditFlags__InputMask | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf)) | ImGuiColorEditFlags_NoTooltip, sz);
    SameLine();
    if ((flags & ImGuiColorEditFlags_InputRGB) || !(flags & ImGuiColorEditFlags__InputMask))
    {
        if (flags & ImGuiColorEditFlags_NoAlpha)
            Text("#%02X%02X%02X\nR: %d, G: %d, B: %d\n(%.3f, %.3f, %.3f)", cr, cg, cb, cr, cg, cb, col[0], col[1], col[2]);
        else
            Text("#%02X%02X%02X%02X\nR:%d, G:%d, B:%d, A:%d\n(%.3f, %.3f, %.3f, %.3f)", cr, cg, cb, ca, cr, cg, cb, ca, col[0], col[1], col[2], col[3]);
    }
    else if (flags & ImGuiColorEditFlags_InputHSV)
    {
        if (flags & ImGuiColorEditFlags_NoAlpha)
            Text("H: %.3f, S: %.3f, V: %.3f", col[0], col[1], col[2]);
        else
            Text("H: %.3f, S: %.3f, V: %.3f, A: %.3f", col[0], col[1], col[2], col[3]);
    }
    EndTooltip();
}

void ImGui::ColorEditOptionsPopup(const float* col, ImGuiColorEditFlags flags)
{
    bool allow_opt_inputs = !(flags & ImGuiColorEditFlags__DisplayMask);
    bool allow_opt_datatype = !(flags & ImGuiColorEditFlags__DataTypeMask);
    if ((!allow_opt_inputs && !allow_opt_datatype) || !BeginPopup("context"))
        return;
    ImGuiContext& g = *GImGui;
    ImGuiColorEditFlags opts = g.ColorEditOptions;
    if (allow_opt_inputs)
    {
        if (RadioButton("RGB", (opts & ImGuiColorEditFlags_DisplayRGB) != 0)) opts = (opts & ~ImGuiColorEditFlags__DisplayMask) | ImGuiColorEditFlags_DisplayRGB;
        if (RadioButton("HSV", (opts & ImGuiColorEditFlags_DisplayHSV) != 0)) opts = (opts & ~ImGuiColorEditFlags__DisplayMask) | ImGuiColorEditFlags_DisplayHSV;
        if (RadioButton("Hex", (opts & ImGuiColorEditFlags_DisplayHex) != 0)) opts = (opts & ~ImGuiColorEditFlags__DisplayMask) | ImGuiColorEditFlags_DisplayHex;
    }
    if (allow_opt_datatype)
    {
        if (allow_opt_inputs) Separator();
        if (RadioButton("0..255",     (opts & ImGuiColorEditFlags_Uint8) != 0)) opts = (opts & ~ImGuiColorEditFlags__DataTypeMask) | ImGuiColorEditFlags_Uint8;
        if (RadioButton("0.00..1.00", (opts & ImGuiColorEditFlags_Float) != 0)) opts = (opts & ~ImGuiColorEditFlags__DataTypeMask) | ImGuiColorEditFlags_Float;
    }

    if (allow_opt_inputs || allow_opt_datatype)
        Separator();
    if (Button("Copy as..", ImVec2(-1,0)))
        OpenPopup("Copy");
    if (BeginPopup("Copy"))
    {
        int cr = IM_F32_TO_INT8_SAT(col[0]), cg = IM_F32_TO_INT8_SAT(col[1]), cb = IM_F32_TO_INT8_SAT(col[2]), ca = (flags & ImGuiColorEditFlags_NoAlpha) ? 255 : IM_F32_TO_INT8_SAT(col[3]);
        char buf[64];
        ImFormatString(buf, IM_ARRAYSIZE(buf), "(%.3ff, %.3ff, %.3ff, %.3ff)", col[0], col[1], col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : col[3]);
        if (Selectable(buf))
            SetClipboardText(buf);
        ImFormatString(buf, IM_ARRAYSIZE(buf), "(%d,%d,%d,%d)", cr, cg, cb, ca);
        if (Selectable(buf))
            SetClipboardText(buf);
        if (flags & ImGuiColorEditFlags_NoAlpha)
            ImFormatString(buf, IM_ARRAYSIZE(buf), "0x%02X%02X%02X", cr, cg, cb);
        else
            ImFormatString(buf, IM_ARRAYSIZE(buf), "0x%02X%02X%02X%02X", cr, cg, cb, ca);
        if (Selectable(buf))
            SetClipboardText(buf);
        EndPopup();
    }

    g.ColorEditOptions = opts;
    EndPopup();
}

void ImGui::ColorPickerOptionsPopup(const float* ref_col, ImGuiColorEditFlags flags)
{
    bool allow_opt_picker = !(flags & ImGuiColorEditFlags__PickerMask);
    bool allow_opt_alpha_bar = !(flags & ImGuiColorEditFlags_NoAlpha) && !(flags & ImGuiColorEditFlags_AlphaBar);
    if ((!allow_opt_picker && !allow_opt_alpha_bar) || !BeginPopup("context"))
        return;
    ImGuiContext& g = *GImGui;
    if (allow_opt_picker)
    {
        ImVec2 picker_size(g.FontSize * 8, ImMax(g.FontSize * 8 - (GetFrameHeight() + g.Style.ItemInnerSpacing.x), 1.0f)); // FIXME: Picker size copied from main picker function
        PushItemWidth(picker_size.x);
        for (int picker_type = 0; picker_type < 2; picker_type++)
        {
            // Draw small/thumbnail version of each picker type (over an invisible button for selection)
            if (picker_type > 0) Separator();
            PushID(picker_type);
            ImGuiColorEditFlags picker_flags = ImGuiColorEditFlags_NoInputs|ImGuiColorEditFlags_NoOptions|ImGuiColorEditFlags_NoLabel|ImGuiColorEditFlags_NoSidePreview|(flags & ImGuiColorEditFlags_NoAlpha);
            if (picker_type == 0) picker_flags |= ImGuiColorEditFlags_PickerHueBar;
            if (picker_type == 1) picker_flags |= ImGuiColorEditFlags_PickerHueWheel;
            ImVec2 backup_pos = GetCursorScreenPos();
            if (Selectable("##selectable", false, 0, picker_size)) // By default, Selectable() is closing popup
                g.ColorEditOptions = (g.ColorEditOptions & ~ImGuiColorEditFlags__PickerMask) | (picker_flags & ImGuiColorEditFlags__PickerMask);
            SetCursorScreenPos(backup_pos);
            ImVec4 dummy_ref_col;
            memcpy(&dummy_ref_col, ref_col, sizeof(float) * ((picker_flags & ImGuiColorEditFlags_NoAlpha) ? 3 : 4));
            ColorPicker4("##dummypicker", &dummy_ref_col.x, picker_flags);
            PopID();
        }
        PopItemWidth();
    }
    if (allow_opt_alpha_bar)
    {
        if (allow_opt_picker) Separator();
        CheckboxFlags("Alpha Bar", (unsigned int*)&g.ColorEditOptions, ImGuiColorEditFlags_AlphaBar);
    }
    EndPopup();
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: TreeNode, CollapsingHeader, etc.
//-------------------------------------------------------------------------
// - TreeNode()
// - TreeNodeV()
// - TreeNodeEx()
// - TreeNodeExV()
// - TreeNodeBehavior() [Internal]
// - TreePush()
// - TreePop()
// - TreeAdvanceToLabelPos()
// - GetTreeNodeToLabelSpacing()
// - SetNextTreeNodeOpen()
// - CollapsingHeader()
//-------------------------------------------------------------------------

bool ImGui::TreeNode(const char* str_id, const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    bool is_open = TreeNodeExV(str_id, 0, fmt, args);
    va_end(args);
    return is_open;
}

bool ImGui::TreeNode(const void* ptr_id, const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    bool is_open = TreeNodeExV(ptr_id, 0, fmt, args);
    va_end(args);
    return is_open;
}

bool ImGui::TreeNode(const char* label)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;
    return TreeNodeBehavior(window->GetID(label), 0, label, NULL);
}

bool ImGui::TreeNodeV(const char* str_id, const char* fmt, va_list args)
{
    return TreeNodeExV(str_id, 0, fmt, args);
}

bool ImGui::TreeNodeV(const void* ptr_id, const char* fmt, va_list args)
{
    return TreeNodeExV(ptr_id, 0, fmt, args);
}

bool ImGui::TreeNodeEx(const char* label, ImGuiTreeNodeFlags flags)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    return TreeNodeBehavior(window->GetID(label), flags, label, NULL);
}

bool ImGui::TreeNodeEx(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    bool is_open = TreeNodeExV(str_id, flags, fmt, args);
    va_end(args);
    return is_open;
}

bool ImGui::TreeNodeEx(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    bool is_open = TreeNodeExV(ptr_id, flags, fmt, args);
    va_end(args);
    return is_open;
}

bool ImGui::TreeNodeExV(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const char* label_end = g.TempBuffer + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);
    return TreeNodeBehavior(window->GetID(str_id), flags, g.TempBuffer, label_end);
}

bool ImGui::TreeNodeExV(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const char* label_end = g.TempBuffer + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);
    return TreeNodeBehavior(window->GetID(ptr_id), flags, g.TempBuffer, label_end);
}

bool ImGui::TreeNodeBehaviorIsOpen(ImGuiID id, ImGuiTreeNodeFlags flags)
{
    if (flags & ImGuiTreeNodeFlags_Leaf)
        return true;

    // We only write to the tree storage if the user clicks (or explicitly use SetNextTreeNode*** functions)
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImGuiStorage* storage = window->DC.StateStorage;

    bool is_open;
    if (g.NextTreeNodeOpenCond != 0)
    {
        if (g.NextTreeNodeOpenCond & ImGuiCond_Always)
        {
            is_open = g.NextTreeNodeOpenVal;
            storage->SetInt(id, is_open);
        }
        else
        {
            // We treat ImGuiCond_Once and ImGuiCond_FirstUseEver the same because tree node state are not saved persistently.
            const int stored_value = storage->GetInt(id, -1);
            if (stored_value == -1)
            {
                is_open = g.NextTreeNodeOpenVal;
                storage->SetInt(id, is_open);
            }
            else
            {
                is_open = stored_value != 0;
            }
        }
        g.NextTreeNodeOpenCond = 0;
    }
    else
    {
        is_open = storage->GetInt(id, (flags & ImGuiTreeNodeFlags_DefaultOpen) ? 1 : 0) != 0;
    }

    // When logging is enabled, we automatically expand tree nodes (but *NOT* collapsing headers.. seems like sensible behavior).
    // NB- If we are above max depth we still allow manually opened nodes to be logged.
    if (g.LogEnabled && !(flags & ImGuiTreeNodeFlags_NoAutoOpenOnLog) && (window->DC.TreeDepth - g.LogDepthRef) < g.LogDepthToExpand)
        is_open = true;

    return is_open;
}

bool ImGui::TreeNodeBehavior(ImGuiID id, ImGuiTreeNodeFlags flags, const char* label, const char* label_end)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const bool display_frame = (flags & ImGuiTreeNodeFlags_Framed) != 0;
    const ImVec2 padding = (display_frame || (flags & ImGuiTreeNodeFlags_FramePadding)) ? style.FramePadding : ImVec2(style.FramePadding.x, 0.0f);

    if (!label_end)
        label_end = FindRenderedTextEnd(label);
    const ImVec2 label_size = CalcTextSize(label, label_end, false);

    // We vertically grow up to current line height up the typical widget height.
    const float text_base_offset_y = ImMax(padding.y, window->DC.CurrentLineTextBaseOffset); // Latch before ItemSize changes it
    const float frame_height = ImMax(ImMin(window->DC.CurrentLineSize.y, g.FontSize + style.FramePadding.y*2), label_size.y + padding.y*2);
    ImRect frame_bb = ImRect(window->DC.CursorPos, ImVec2(GetWorkRectMax().x, window->DC.CursorPos.y + frame_height));
    if (display_frame)
    {
        // Framed header expand a little outside the default padding
        frame_bb.Min.x -= (float)(int)(window->WindowPadding.x*0.5f) - 1;
        frame_bb.Max.x += (float)(int)(window->WindowPadding.x*0.5f) - 1;
    }

    const float text_offset_x = (g.FontSize + (display_frame ? padding.x*3 : padding.x*2));   // Collapser arrow width + Spacing
    const float text_width = g.FontSize + (label_size.x > 0.0f ? label_size.x + padding.x*2 : 0.0f);   // Include collapser
    ItemSize(ImVec2(text_width, frame_height), text_base_offset_y);

    // For regular tree nodes, we arbitrary allow to click past 2 worth of ItemSpacing
    // (Ideally we'd want to add a flag for the user to specify if we want the hit test to be done up to the right side of the content or not)
    const ImRect interact_bb = display_frame ? frame_bb : ImRect(frame_bb.Min.x, frame_bb.Min.y, frame_bb.Min.x + text_width + style.ItemSpacing.x*2, frame_bb.Max.y);
    bool is_open = TreeNodeBehaviorIsOpen(id, flags);
    bool is_leaf = (flags & ImGuiTreeNodeFlags_Leaf) != 0;

    // Store a flag for the current depth to tell if we will allow closing this node when navigating one of its child.
    // For this purpose we essentially compare if g.NavIdIsAlive went from 0 to 1 between TreeNode() and TreePop().
    // This is currently only support 32 level deep and we are fine with (1 << Depth) overflowing into a zero.
    if (is_open && !g.NavIdIsAlive && (flags & ImGuiTreeNodeFlags_NavLeftJumpsBackHere) && !(flags & ImGuiTreeNodeFlags_NoTreePushOnOpen))
        window->DC.TreeStoreMayJumpToParentOnPop |= (1 << window->DC.TreeDepth);

    bool item_add = ItemAdd(interact_bb, id);
    window->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_HasDisplayRect;
    window->DC.LastItemDisplayRect = frame_bb;

    if (!item_add)
    {
        if (is_open && !(flags & ImGuiTreeNodeFlags_NoTreePushOnOpen))
            TreePushOverrideID(id);
        IMGUI_TEST_ENGINE_ITEM_INFO(window->DC.LastItemId, label, window->DC.ItemFlags | (is_leaf ? 0 : ImGuiItemStatusFlags_Openable) | (is_open ? ImGuiItemStatusFlags_Opened : 0));
        return is_open;
    }

    // Flags that affects opening behavior:
    // - 0 (default) .................... single-click anywhere to open
    // - OpenOnDoubleClick .............. double-click anywhere to open
    // - OpenOnArrow .................... single-click on arrow to open
    // - OpenOnDoubleClick|OpenOnArrow .. single-click on arrow or double-click anywhere to open
    ImGuiButtonFlags button_flags = ImGuiButtonFlags_NoKeyModifiers;
    if (flags & ImGuiTreeNodeFlags_AllowItemOverlap)
        button_flags |= ImGuiButtonFlags_AllowItemOverlap;
    if (flags & ImGuiTreeNodeFlags_OpenOnDoubleClick)
        button_flags |= ImGuiButtonFlags_PressedOnDoubleClick | ((flags & ImGuiTreeNodeFlags_OpenOnArrow) ? ImGuiButtonFlags_PressedOnClickRelease : 0);
    if (!is_leaf)
        button_flags |= ImGuiButtonFlags_PressedOnDragDropHold;

    bool selected = (flags & ImGuiTreeNodeFlags_Selected) != 0;
    const bool was_selected = selected;

    bool hovered, held;
    bool pressed = ButtonBehavior(interact_bb, id, &hovered, &held, button_flags);
    bool toggled = false;
    if (!is_leaf)
    {
        if (pressed)
        {
            toggled = !(flags & (ImGuiTreeNodeFlags_OpenOnArrow | ImGuiTreeNodeFlags_OpenOnDoubleClick)) || (g.NavActivateId == id);
            if (flags & ImGuiTreeNodeFlags_OpenOnArrow)
                toggled |= IsMouseHoveringRect(interact_bb.Min, ImVec2(interact_bb.Min.x + text_offset_x, interact_bb.Max.y)) && (!g.NavDisableMouseHover);
            if (flags & ImGuiTreeNodeFlags_OpenOnDoubleClick)
                toggled |= g.IO.MouseDoubleClicked[0];
            if (g.DragDropActive && is_open) // When using Drag and Drop "hold to open" we keep the node highlighted after opening, but never close it again.
                toggled = false;
        }

        if (g.NavId == id && g.NavMoveRequest && g.NavMoveDir == ImGuiDir_Left && is_open)
        {
            toggled = true;
            NavMoveRequestCancel();
        }
        if (g.NavId == id && g.NavMoveRequest && g.NavMoveDir == ImGuiDir_Right && !is_open) // If there's something upcoming on the line we may want to give it the priority?
        {
            toggled = true;
            NavMoveRequestCancel();
        }

        if (toggled)
        {
            is_open = !is_open;
            window->DC.StateStorage->SetInt(id, is_open);
        }
    }
    if (flags & ImGuiTreeNodeFlags_AllowItemOverlap)
        SetItemAllowOverlap();

    // In this branch, TreeNodeBehavior() cannot toggle the selection so this will never trigger.
    if (selected != was_selected) //-V547
        window->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_ToggledSelection;

    // Render
    const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header);
    const ImVec2 text_pos = frame_bb.Min + ImVec2(text_offset_x, text_base_offset_y);
    ImGuiNavHighlightFlags nav_highlight_flags = ImGuiNavHighlightFlags_TypeThin;
    if (display_frame)
    {
        // Framed type
        RenderFrame(frame_bb.Min, frame_bb.Max, col, true, style.FrameRounding);
        RenderNavHighlight(frame_bb, id, nav_highlight_flags);
        RenderArrow(frame_bb.Min + ImVec2(padding.x, text_base_offset_y), is_open ? ImGuiDir_Down : ImGuiDir_Right, 1.0f);
        if (g.LogEnabled)
        {
            // NB: '##' is normally used to hide text (as a library-wide feature), so we need to specify the text range to make sure the ## aren't stripped out here.
            const char log_prefix[] = "\n##";
            const char log_suffix[] = "##";
            LogRenderedText(&text_pos, log_prefix, log_prefix+3);
            RenderTextClipped(text_pos, frame_bb.Max, label, label_end, &label_size);
            LogRenderedText(&text_pos, log_suffix, log_suffix+2);
        }
        else
        {
            RenderTextClipped(text_pos, frame_bb.Max, label, label_end, &label_size);
        }
    }
    else
    {
        // Unframed typed for tree nodes
        if (hovered || selected)
        {
            RenderFrame(frame_bb.Min, frame_bb.Max, col, false);
            RenderNavHighlight(frame_bb, id, nav_highlight_flags);
        }

        if (flags & ImGuiTreeNodeFlags_Bullet)
            RenderBullet(frame_bb.Min + ImVec2(text_offset_x * 0.5f, g.FontSize*0.50f + text_base_offset_y));
        else if (!is_leaf)
            RenderArrow(frame_bb.Min + ImVec2(padding.x, g.FontSize*0.15f + text_base_offset_y), is_open ? ImGuiDir_Down : ImGuiDir_Right, 0.70f);
        if (g.LogEnabled)
            LogRenderedText(&text_pos, ">");
        RenderText(text_pos, label, label_end, false);
    }

    if (is_open && !(flags & ImGuiTreeNodeFlags_NoTreePushOnOpen))
        TreePushOverrideID(id);
    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.ItemFlags | (is_leaf ? 0 : ImGuiItemStatusFlags_Openable) | (is_open ? ImGuiItemStatusFlags_Opened : 0));
    return is_open;
}

void ImGui::TreePush(const char* str_id)
{
    ImGuiWindow* window = GetCurrentWindow();
    Indent();
    window->DC.TreeDepth++;
    PushID(str_id ? str_id : "#TreePush");
}

void ImGui::TreePush(const void* ptr_id)
{
    ImGuiWindow* window = GetCurrentWindow();
    Indent();
    window->DC.TreeDepth++;
    PushID(ptr_id ? ptr_id : (const void*)"#TreePush");
}

void ImGui::TreePushOverrideID(ImGuiID id)
{
    ImGuiWindow* window = GetCurrentWindow();
    Indent();
    window->DC.TreeDepth++;
    window->IDStack.push_back(id);
}

void ImGui::TreePop()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    Unindent();

    window->DC.TreeDepth--;
    if (g.NavMoveDir == ImGuiDir_Left && g.NavWindow == window && NavMoveRequestButNoResultYet())
        if (g.NavIdIsAlive && (window->DC.TreeStoreMayJumpToParentOnPop & (1 << window->DC.TreeDepth)))
        {
            SetNavID(window->IDStack.back(), g.NavLayer);
            NavMoveRequestCancel();
        }
    window->DC.TreeStoreMayJumpToParentOnPop &= (1 << window->DC.TreeDepth) - 1;

    IM_ASSERT(window->IDStack.Size > 1); // There should always be 1 element in the IDStack (pushed during window creation). If this triggers you called TreePop/PopID too much.
    PopID();
}

void ImGui::TreeAdvanceToLabelPos()
{
    ImGuiContext& g = *GImGui;
    g.CurrentWindow->DC.CursorPos.x += GetTreeNodeToLabelSpacing();
}

// Horizontal distance preceding label when using TreeNode() or Bullet()
float ImGui::GetTreeNodeToLabelSpacing()
{
    ImGuiContext& g = *GImGui;
    return g.FontSize + (g.Style.FramePadding.x * 2.0f);
}

void ImGui::SetNextTreeNodeOpen(bool is_open, ImGuiCond cond)
{
    ImGuiContext& g = *GImGui;
    if (g.CurrentWindow->SkipItems)
        return;
    g.NextTreeNodeOpenVal = is_open;
    g.NextTreeNodeOpenCond = cond ? cond : ImGuiCond_Always;
}

// CollapsingHeader returns true when opened but do not indent nor push into the ID stack (because of the ImGuiTreeNodeFlags_NoTreePushOnOpen flag).
// This is basically the same as calling TreeNodeEx(label, ImGuiTreeNodeFlags_CollapsingHeader). You can remove the _NoTreePushOnOpen flag if you want behavior closer to normal TreeNode().
bool ImGui::CollapsingHeader(const char* label, ImGuiTreeNodeFlags flags)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    return TreeNodeBehavior(window->GetID(label), flags | ImGuiTreeNodeFlags_CollapsingHeader, label);
}

bool ImGui::CollapsingHeader(const char* label, bool* p_open, ImGuiTreeNodeFlags flags)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    if (p_open && !*p_open)
        return false;

    ImGuiID id = window->GetID(label);
    bool is_open = TreeNodeBehavior(id, flags | ImGuiTreeNodeFlags_CollapsingHeader | (p_open ? ImGuiTreeNodeFlags_AllowItemOverlap : 0), label);
    if (p_open)
    {
        // Create a small overlapping close button // FIXME: We can evolve this into user accessible helpers to add extra buttons on title bars, headers, etc.
        ImGuiContext& g = *GImGui;
        ImGuiItemHoveredDataBackup last_item_backup;
        float button_radius = g.FontSize * 0.5f;
        ImVec2 button_center = ImVec2(ImMin(window->DC.LastItemRect.Max.x, window->ClipRect.Max.x) - g.Style.FramePadding.x - button_radius, window->DC.LastItemRect.GetCenter().y);
        if (CloseButton(window->GetID((void*)((intptr_t)id+1)), button_center, button_radius))
            *p_open = false;
        last_item_backup.Restore();
    }

    return is_open;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: Selectable
//-------------------------------------------------------------------------
// - Selectable()
//-------------------------------------------------------------------------

// Tip: pass a non-visible label (e.g. "##dummy") then you can use the space to draw other text or image.
// But you need to make sure the ID is unique, e.g. enclose calls in PushID/PopID or use ##unique_id.
bool ImGui::Selectable(const char* label, bool selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;

    if ((flags & ImGuiSelectableFlags_SpanAllColumns) && window->DC.CurrentColumns) // FIXME-OPT: Avoid if vertically clipped.
        PopClipRect();

    ImGuiID id = window->GetID(label);
    ImVec2 label_size = CalcTextSize(label, NULL, true);
    ImVec2 size(size_arg.x != 0.0f ? size_arg.x : label_size.x, size_arg.y != 0.0f ? size_arg.y : label_size.y);
    ImVec2 pos = window->DC.CursorPos;
    pos.y += window->DC.CurrentLineTextBaseOffset;
    ImRect bb_inner(pos, pos + size);
    ItemSize(size);

    // Fill horizontal space.
    ImVec2 window_padding = window->WindowPadding;
    float max_x = (flags & ImGuiSelectableFlags_SpanAllColumns) ? GetWindowContentRegionMax().x : GetContentRegionMax().x;
    float w_draw = ImMax(label_size.x, window->Pos.x + max_x - window_padding.x - pos.x);
    ImVec2 size_draw((size_arg.x != 0 && !(flags & ImGuiSelectableFlags_DrawFillAvailWidth)) ? size_arg.x : w_draw, size_arg.y != 0.0f ? size_arg.y : size.y);
    ImRect bb(pos, pos + size_draw);
    if (size_arg.x == 0.0f || (flags & ImGuiSelectableFlags_DrawFillAvailWidth))
        bb.Max.x += window_padding.x;

    // Selectables are tightly packed together so we extend the box to cover spacing between selectable.
    const float spacing_x = style.ItemSpacing.x;
    const float spacing_y = style.ItemSpacing.y;
    const float spacing_L = (float)(int)(spacing_x * 0.50f);
    const float spacing_U = (float)(int)(spacing_y * 0.50f);
    bb.Min.x -= spacing_L;
    bb.Min.y -= spacing_U;
    bb.Max.x += (spacing_x - spacing_L);
    bb.Max.y += (spacing_y - spacing_U);

    bool item_add;
    if (flags & ImGuiSelectableFlags_Disabled)
    {
        ImGuiItemFlags backup_item_flags = window->DC.ItemFlags;
        window->DC.ItemFlags |= ImGuiItemFlags_Disabled | ImGuiItemFlags_NoNavDefaultFocus;
        item_add = ItemAdd(bb, id);
        window->DC.ItemFlags = backup_item_flags;
    }
    else
    {
        item_add = ItemAdd(bb, id);
    }
    if (!item_add)
    {
        if ((flags & ImGuiSelectableFlags_SpanAllColumns) && window->DC.CurrentColumns)
            PushColumnClipRect();
        return false;
    }

    // We use NoHoldingActiveID on menus so user can click and _hold_ on a menu then drag to browse child entries
    ImGuiButtonFlags button_flags = 0;
    if (flags & ImGuiSelectableFlags_NoHoldingActiveID) button_flags |= ImGuiButtonFlags_NoHoldingActiveID;
    if (flags & ImGuiSelectableFlags_PressedOnClick) button_flags |= ImGuiButtonFlags_PressedOnClick;
    if (flags & ImGuiSelectableFlags_PressedOnRelease) button_flags |= ImGuiButtonFlags_PressedOnRelease;
    if (flags & ImGuiSelectableFlags_Disabled) button_flags |= ImGuiButtonFlags_Disabled;
    if (flags & ImGuiSelectableFlags_AllowDoubleClick) button_flags |= ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnDoubleClick;
    if (flags & ImGuiSelectableFlags_AllowItemOverlap) button_flags |= ImGuiButtonFlags_AllowItemOverlap;

    if (flags & ImGuiSelectableFlags_Disabled)
        selected = false;

    const bool was_selected = selected;
    bool hovered, held;
    bool pressed = ButtonBehavior(bb, id, &hovered, &held, button_flags);
    // Hovering selectable with mouse updates NavId accordingly so navigation can be resumed with gamepad/keyboard (this doesn't happen on most widgets)
    if (pressed || hovered)
        if (!g.NavDisableMouseHover && g.NavWindow == window && g.NavLayer == window->DC.NavLayerCurrent)
        {
            g.NavDisableHighlight = true;
            SetNavID(id, window->DC.NavLayerCurrent);
        }
    if (pressed)
        MarkItemEdited(id);

    if (flags & ImGuiSelectableFlags_AllowItemOverlap)
        SetItemAllowOverlap();

    // In this branch, Selectable() cannot toggle the selection so this will never trigger.
    if (selected != was_selected) //-V547
        window->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_ToggledSelection;

    // Render
    if (hovered || selected)
    {
        const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header);
        RenderFrame(bb.Min, bb.Max, col, false, 0.0f);
        RenderNavHighlight(bb, id, ImGuiNavHighlightFlags_TypeThin | ImGuiNavHighlightFlags_NoRounding);
    }

    if ((flags & ImGuiSelectableFlags_SpanAllColumns) && window->DC.CurrentColumns)
    {
        PushColumnClipRect();
        bb.Max.x -= (GetContentRegionMax().x - max_x);
    }

    if (flags & ImGuiSelectableFlags_Disabled) PushStyleColor(ImGuiCol_Text, style.Colors[ImGuiCol_TextDisabled]);
    RenderTextClipped(bb_inner.Min, bb_inner.Max, label, NULL, &label_size, style.SelectableTextAlign, &bb);
    if (flags & ImGuiSelectableFlags_Disabled) PopStyleColor();

    // Automatically close popups
    if (pressed && (window->Flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiSelectableFlags_DontClosePopups) && !(window->DC.ItemFlags & ImGuiItemFlags_SelectableDontClosePopup))
        CloseCurrentPopup();

    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.ItemFlags);
    return pressed;
}

bool ImGui::Selectable(const char* label, bool* p_selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)
{
    if (Selectable(label, *p_selected, flags, size_arg))
    {
        *p_selected = !*p_selected;
        return true;
    }
    return false;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: ListBox
//-------------------------------------------------------------------------
// - ListBox()
// - ListBoxHeader()
// - ListBoxFooter()
//-------------------------------------------------------------------------
// FIXME: This is an old API. We should redesign some of it, rename ListBoxHeader->BeginListBox, ListBoxFooter->EndListBox
// and promote using them over existing ListBox() functions, similarly to change with combo boxes.
//-------------------------------------------------------------------------

// FIXME: In principle this function should be called BeginListBox(). We should rename it after re-evaluating if we want to keep the same signature.
// Helper to calculate the size of a listbox and display a label on the right.
// Tip: To have a list filling the entire window width, PushItemWidth(-1) and pass an non-visible label e.g. "##empty"
bool ImGui::ListBoxHeader(const char* label, const ImVec2& size_arg)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    const ImGuiStyle& style = GetStyle();
    const ImGuiID id = GetID(label);
    const ImVec2 label_size = CalcTextSize(label, NULL, true);

    // Size default to hold ~7 items. Fractional number of items helps seeing that we can scroll down/up without looking at scrollbar.
    ImVec2 size = CalcItemSize(size_arg, GetNextItemWidth(), GetTextLineHeightWithSpacing() * 7.4f + style.ItemSpacing.y);
    ImVec2 frame_size = ImVec2(size.x, ImMax(size.y, label_size.y));
    ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + frame_size);
    ImRect bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));
    window->DC.LastItemRect = bb; // Forward storage for ListBoxFooter.. dodgy.

    if (!IsRectVisible(bb.Min, bb.Max))
    {
        ItemSize(bb.GetSize(), style.FramePadding.y);
        ItemAdd(bb, 0, &frame_bb);
        return false;
    }

    BeginGroup();
    if (label_size.x > 0)
        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

    BeginChildFrame(id, frame_bb.GetSize());
    return true;
}

// FIXME: In principle this function should be called EndListBox(). We should rename it after re-evaluating if we want to keep the same signature.
bool ImGui::ListBoxHeader(const char* label, int items_count, int height_in_items)
{
    // Size default to hold ~7.25 items.
    // We add +25% worth of item height to allow the user to see at a glance if there are more items up/down, without looking at the scrollbar.
    // We don't add this extra bit if items_count <= height_in_items. It is slightly dodgy, because it means a dynamic list of items will make the widget resize occasionally when it crosses that size.
    // I am expecting that someone will come and complain about this behavior in a remote future, then we can advise on a better solution.
    if (height_in_items < 0)
        height_in_items = ImMin(items_count, 7);
    const ImGuiStyle& style = GetStyle();
    float height_in_items_f = (height_in_items < items_count) ? (height_in_items + 0.25f) : (height_in_items + 0.00f);

    // We include ItemSpacing.y so that a list sized for the exact number of items doesn't make a scrollbar appears. We could also enforce that by passing a flag to BeginChild().
    ImVec2 size;
    size.x = 0.0f;
    size.y = GetTextLineHeightWithSpacing() * height_in_items_f + style.FramePadding.y * 2.0f;
    return ListBoxHeader(label, size);
}

// FIXME: In principle this function should be called EndListBox(). We should rename it after re-evaluating if we want to keep the same signature.
void ImGui::ListBoxFooter()
{
    ImGuiWindow* parent_window = GetCurrentWindow()->ParentWindow;
    const ImRect bb = parent_window->DC.LastItemRect;
    const ImGuiStyle& style = GetStyle();

    EndChildFrame();

    // Redeclare item size so that it includes the label (we have stored the full size in LastItemRect)
    // We call SameLine() to restore DC.CurrentLine* data
    SameLine();
    parent_window->DC.CursorPos = bb.Min;
    ItemSize(bb, style.FramePadding.y);
    EndGroup();
}

bool ImGui::ListBox(const char* label, int* current_item, const char* const items[], int items_count, int height_items)
{
    const bool value_changed = ListBox(label, current_item, Items_ArrayGetter, (void*)items, items_count, height_items);
    return value_changed;
}

bool ImGui::ListBox(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int height_in_items)
{
    if (!ListBoxHeader(label, items_count, height_in_items))
        return false;

    // Assume all items have even height (= 1 line of text). If you need items of different or variable sizes you can create a custom version of ListBox() in your code without using the clipper.
    ImGuiContext& g = *GImGui;
    bool value_changed = false;
    ImGuiListClipper clipper(items_count, GetTextLineHeightWithSpacing()); // We know exactly our line height here so we pass it as a minor optimization, but generally you don't need to.
    while (clipper.Step())
        for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)
        {
            const bool item_selected = (i == *current_item);
            const char* item_text;
            if (!items_getter(data, i, &item_text))
                item_text = "*Unknown item*";

            PushID(i);
            if (Selectable(item_text, item_selected))
            {
                *current_item = i;
                value_changed = true;
            }
            if (item_selected)
                SetItemDefaultFocus();
            PopID();
        }
    ListBoxFooter();
    if (value_changed)
        MarkItemEdited(g.CurrentWindow->DC.LastItemId);

    return value_changed;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: PlotLines, PlotHistogram
//-------------------------------------------------------------------------
// - PlotEx() [Internal]
// - PlotLines()
// - PlotHistogram()
//-------------------------------------------------------------------------

void ImGui::PlotEx(ImGuiPlotType plot_type, const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 frame_size)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const ImGuiID id = window->GetID(label);

    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    if (frame_size.x == 0.0f)
        frame_size.x = GetNextItemWidth();
    if (frame_size.y == 0.0f)
        frame_size.y = label_size.y + (style.FramePadding.y * 2);

    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + frame_size);
    const ImRect inner_bb(frame_bb.Min + style.FramePadding, frame_bb.Max - style.FramePadding);
    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0));
    ItemSize(total_bb, style.FramePadding.y);
    if (!ItemAdd(total_bb, 0, &frame_bb))
        return;
    const bool hovered = ItemHoverable(frame_bb, id);

    // Determine scale from values if not specified
    if (scale_min == FLT_MAX || scale_max == FLT_MAX)
    {
        float v_min = FLT_MAX;
        float v_max = -FLT_MAX;
        for (int i = 0; i < values_count; i++)
        {
            const float v = values_getter(data, i);
            if (v != v) // Ignore NaN values
                continue;
            v_min = ImMin(v_min, v);
            v_max = ImMax(v_max, v);
        }
        if (scale_min == FLT_MAX)
            scale_min = v_min;
        if (scale_max == FLT_MAX)
            scale_max = v_max;
    }

    RenderFrame(frame_bb.Min, frame_bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);

    const int values_count_min = (plot_type == ImGuiPlotType_Lines) ? 2 : 1;
    if (values_count >= values_count_min)
    {
        int res_w = ImMin((int)frame_size.x, values_count) + ((plot_type == ImGuiPlotType_Lines) ? -1 : 0);
        int item_count = values_count + ((plot_type == ImGuiPlotType_Lines) ? -1 : 0);

        // Tooltip on hover
        int v_hovered = -1;
        if (hovered && inner_bb.Contains(g.IO.MousePos))
        {
            const float t = ImClamp((g.IO.MousePos.x - inner_bb.Min.x) / (inner_bb.Max.x - inner_bb.Min.x), 0.0f, 0.9999f);
            const int v_idx = (int)(t * item_count);
            IM_ASSERT(v_idx >= 0 && v_idx < values_count);

            const float v0 = values_getter(data, (v_idx + values_offset) % values_count);
            const float v1 = values_getter(data, (v_idx + 1 + values_offset) % values_count);
            if (plot_type == ImGuiPlotType_Lines)
                SetTooltip("%d: %8.4g\n%d: %8.4g", v_idx, v0, v_idx+1, v1);
            else if (plot_type == ImGuiPlotType_Histogram)
                SetTooltip("%d: %8.4g", v_idx, v0);
            v_hovered = v_idx;
        }

        const float t_step = 1.0f / (float)res_w;
        const float inv_scale = (scale_min == scale_max) ? 0.0f : (1.0f / (scale_max - scale_min));

        float v0 = values_getter(data, (0 + values_offset) % values_count);
        float t0 = 0.0f;
        ImVec2 tp0 = ImVec2( t0, 1.0f - ImSaturate((v0 - scale_min) * inv_scale) );                       // Point in the normalized space of our target rectangle
        float histogram_zero_line_t = (scale_min * scale_max < 0.0f) ? (-scale_min * inv_scale) : (scale_min < 0.0f ? 0.0f : 1.0f);   // Where does the zero line stands

        const ImU32 col_base = GetColorU32((plot_type == ImGuiPlotType_Lines) ? ImGuiCol_PlotLines : ImGuiCol_PlotHistogram);
        const ImU32 col_hovered = GetColorU32((plot_type == ImGuiPlotType_Lines) ? ImGuiCol_PlotLinesHovered : ImGuiCol_PlotHistogramHovered);

        for (int n = 0; n < res_w; n++)
        {
            const float t1 = t0 + t_step;
            const int v1_idx = (int)(t0 * item_count + 0.5f);
            IM_ASSERT(v1_idx >= 0 && v1_idx < values_count);
            const float v1 = values_getter(data, (v1_idx + values_offset + 1) % values_count);
            const ImVec2 tp1 = ImVec2( t1, 1.0f - ImSaturate((v1 - scale_min) * inv_scale) );

            // NB: Draw calls are merged together by the DrawList system. Still, we should render our batch are lower level to save a bit of CPU.
            ImVec2 pos0 = ImLerp(inner_bb.Min, inner_bb.Max, tp0);
            ImVec2 pos1 = ImLerp(inner_bb.Min, inner_bb.Max, (plot_type == ImGuiPlotType_Lines) ? tp1 : ImVec2(tp1.x, histogram_zero_line_t));
            if (plot_type == ImGuiPlotType_Lines)
            {
                window->DrawList->AddLine(pos0, pos1, v_hovered == v1_idx ? col_hovered : col_base);
            }
            else if (plot_type == ImGuiPlotType_Histogram)
            {
                if (pos1.x >= pos0.x + 2.0f)
                    pos1.x -= 1.0f;
                window->DrawList->AddRectFilled(pos0, pos1, v_hovered == v1_idx ? col_hovered : col_base);
            }

            t0 = t1;
            tp0 = tp1;
        }
    }

    // Text overlay
    if (overlay_text)
        RenderTextClipped(ImVec2(frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y), frame_bb.Max, overlay_text, NULL, NULL, ImVec2(0.5f,0.0f));

    if (label_size.x > 0.0f)
        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, inner_bb.Min.y), label);
}

struct ImGuiPlotArrayGetterData
{
    const float* Values;
    int Stride;

    ImGuiPlotArrayGetterData(const float* values, int stride) { Values = values; Stride = stride; }
};

static float Plot_ArrayGetter(void* data, int idx)
{
    ImGuiPlotArrayGetterData* plot_data = (ImGuiPlotArrayGetterData*)data;
    const float v = *(const float*)(const void*)((const unsigned char*)plot_data->Values + (size_t)idx * plot_data->Stride);
    return v;
}

void ImGui::PlotLines(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)
{
    ImGuiPlotArrayGetterData data(values, stride);
    PlotEx(ImGuiPlotType_Lines, label, &Plot_ArrayGetter, (void*)&data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);
}

void ImGui::PlotLines(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)
{
    PlotEx(ImGuiPlotType_Lines, label, values_getter, data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);
}

void ImGui::PlotHistogram(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)
{
    ImGuiPlotArrayGetterData data(values, stride);
    PlotEx(ImGuiPlotType_Histogram, label, &Plot_ArrayGetter, (void*)&data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);
}

void ImGui::PlotHistogram(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)
{
    PlotEx(ImGuiPlotType_Histogram, label, values_getter, data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: Value helpers
// Those is not very useful, legacy API.
//-------------------------------------------------------------------------
// - Value()
//-------------------------------------------------------------------------

void ImGui::Value(const char* prefix, bool b)
{
    Text("%s: %s", prefix, (b ? "true" : "false"));
}

void ImGui::Value(const char* prefix, int v)
{
    Text("%s: %d", prefix, v);
}

void ImGui::Value(const char* prefix, unsigned int v)
{
    Text("%s: %d", prefix, v);
}

void ImGui::Value(const char* prefix, float v, const char* float_format)
{
    if (float_format)
    {
        char fmt[64];
        ImFormatString(fmt, IM_ARRAYSIZE(fmt), "%%s: %s", float_format);
        Text(fmt, prefix, v);
    }
    else
    {
        Text("%s: %.3f", prefix, v);
    }
}

//-------------------------------------------------------------------------
// [SECTION] MenuItem, BeginMenu, EndMenu, etc.
//-------------------------------------------------------------------------
// - ImGuiMenuColumns [Internal]
// - BeginMainMenuBar()
// - EndMainMenuBar()
// - BeginMenuBar()
// - EndMenuBar()
// - BeginMenu()
// - EndMenu()
// - MenuItem()
//-------------------------------------------------------------------------

// Helpers for internal use
ImGuiMenuColumns::ImGuiMenuColumns()
{
    Spacing = Width = NextWidth = 0.0f;
    memset(Pos, 0, sizeof(Pos));
    memset(NextWidths, 0, sizeof(NextWidths));
}

void ImGuiMenuColumns::Update(int count, float spacing, bool clear)
{
    IM_ASSERT(count == IM_ARRAYSIZE(Pos));
    IM_UNUSED(count);
    Width = NextWidth = 0.0f;
    Spacing = spacing;
    if (clear)
        memset(NextWidths, 0, sizeof(NextWidths));
    for (int i = 0; i < IM_ARRAYSIZE(Pos); i++)
    {
        if (i > 0 && NextWidths[i] > 0.0f)
            Width += Spacing;
        Pos[i] = (float)(int)Width;
        Width += NextWidths[i];
        NextWidths[i] = 0.0f;
    }
}

float ImGuiMenuColumns::DeclColumns(float w0, float w1, float w2) // not using va_arg because they promote float to double
{
    NextWidth = 0.0f;
    NextWidths[0] = ImMax(NextWidths[0], w0);
    NextWidths[1] = ImMax(NextWidths[1], w1);
    NextWidths[2] = ImMax(NextWidths[2], w2);
    for (int i = 0; i < IM_ARRAYSIZE(Pos); i++)
        NextWidth += NextWidths[i] + ((i > 0 && NextWidths[i] > 0.0f) ? Spacing : 0.0f);
    return ImMax(Width, NextWidth);
}

float ImGuiMenuColumns::CalcExtraSpace(float avail_w)
{
    return ImMax(0.0f, avail_w - Width);
}

// For the main menu bar, which cannot be moved, we honor g.Style.DisplaySafeAreaPadding to ensure text can be visible on a TV set.
bool ImGui::BeginMainMenuBar()
{
    ImGuiContext& g = *GImGui;
    g.NextWindowData.MenuBarOffsetMinVal = ImVec2(g.Style.DisplaySafeAreaPadding.x, ImMax(g.Style.DisplaySafeAreaPadding.y - g.Style.FramePadding.y, 0.0f));
    SetNextWindowPos(ImVec2(0.0f, 0.0f));
    SetNextWindowSize(ImVec2(g.IO.DisplaySize.x, g.NextWindowData.MenuBarOffsetMinVal.y + g.FontBaseSize + g.Style.FramePadding.y));
    PushStyleVar(ImGuiStyleVar_WindowRounding, 0.0f);
    PushStyleVar(ImGuiStyleVar_WindowMinSize, ImVec2(0,0));
    ImGuiWindowFlags window_flags = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_MenuBar;
    bool is_open = Begin("##MainMenuBar", NULL, window_flags) && BeginMenuBar();
    PopStyleVar(2);
    g.NextWindowData.MenuBarOffsetMinVal = ImVec2(0.0f, 0.0f);
    if (!is_open)
    {
        End();
        return false;
    }
    return true; //-V1020
}

void ImGui::EndMainMenuBar()
{
    EndMenuBar();

    // When the user has left the menu layer (typically: closed menus through activation of an item), we restore focus to the previous window
    // FIXME: With this strategy we won't be able to restore a NULL focus.
    ImGuiContext& g = *GImGui;
    if (g.CurrentWindow == g.NavWindow && g.NavLayer == 0)
        FocusTopMostWindowUnderOne(g.NavWindow, NULL);

    End();
}

bool ImGui::BeginMenuBar()
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;
    if (!(window->Flags & ImGuiWindowFlags_MenuBar))
        return false;

    IM_ASSERT(!window->DC.MenuBarAppending);
    BeginGroup(); // Backup position on layer 0
    PushID("##menubar");

    // We don't clip with current window clipping rectangle as it is already set to the area below. However we clip with window full rect.
    // We remove 1 worth of rounding to Max.x to that text in long menus and small windows don't tend to display over the lower-right rounded area, which looks particularly glitchy.
    ImRect bar_rect = window->MenuBarRect();
    ImRect clip_rect(ImFloor(bar_rect.Min.x + 0.5f), ImFloor(bar_rect.Min.y + window->WindowBorderSize + 0.5f), ImFloor(ImMax(bar_rect.Min.x, bar_rect.Max.x - window->WindowRounding) + 0.5f), ImFloor(bar_rect.Max.y + 0.5f));
    clip_rect.ClipWith(window->OuterRectClipped);
    PushClipRect(clip_rect.Min, clip_rect.Max, false);

    window->DC.CursorPos = ImVec2(bar_rect.Min.x + window->DC.MenuBarOffset.x, bar_rect.Min.y + window->DC.MenuBarOffset.y);
    window->DC.LayoutType = ImGuiLayoutType_Horizontal;
    window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;
    window->DC.NavLayerCurrentMask = (1 << ImGuiNavLayer_Menu);
    window->DC.MenuBarAppending = true;
    AlignTextToFramePadding();
    return true;
}

void ImGui::EndMenuBar()
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;
    ImGuiContext& g = *GImGui;

    // Nav: When a move request within one of our child menu failed, capture the request to navigate among our siblings.
    if (NavMoveRequestButNoResultYet() && (g.NavMoveDir == ImGuiDir_Left || g.NavMoveDir == ImGuiDir_Right) && (g.NavWindow->Flags & ImGuiWindowFlags_ChildMenu))
    {
        ImGuiWindow* nav_earliest_child = g.NavWindow;
        while (nav_earliest_child->ParentWindow && (nav_earliest_child->ParentWindow->Flags & ImGuiWindowFlags_ChildMenu))
            nav_earliest_child = nav_earliest_child->ParentWindow;
        if (nav_earliest_child->ParentWindow == window && nav_earliest_child->DC.ParentLayoutType == ImGuiLayoutType_Horizontal && g.NavMoveRequestForward == ImGuiNavForward_None)
        {
            // To do so we claim focus back, restore NavId and then process the movement request for yet another frame.
            // This involve a one-frame delay which isn't very problematic in this situation. We could remove it by scoring in advance for multiple window (probably not worth the hassle/cost)
            const ImGuiNavLayer layer = ImGuiNavLayer_Menu;
            IM_ASSERT(window->DC.NavLayerActiveMaskNext & (1 << layer)); // Sanity check
            FocusWindow(window);
            SetNavIDWithRectRel(window->NavLastIds[layer], layer, window->NavRectRel[layer]);
            g.NavLayer = layer;
            g.NavDisableHighlight = true; // Hide highlight for the current frame so we don't see the intermediary selection.
            g.NavMoveRequestForward = ImGuiNavForward_ForwardQueued;
            NavMoveRequestCancel();
        }
    }

    IM_ASSERT(window->Flags & ImGuiWindowFlags_MenuBar);
    IM_ASSERT(window->DC.MenuBarAppending);
    PopClipRect();
    PopID();
    window->DC.MenuBarOffset.x = window->DC.CursorPos.x - window->MenuBarRect().Min.x; // Save horizontal position so next append can reuse it. This is kinda equivalent to a per-layer CursorPos.
    window->DC.GroupStack.back().AdvanceCursor = false;
    EndGroup(); // Restore position on layer 0
    window->DC.LayoutType = ImGuiLayoutType_Vertical;
    window->DC.NavLayerCurrent = ImGuiNavLayer_Main;
    window->DC.NavLayerCurrentMask = (1 << ImGuiNavLayer_Main);
    window->DC.MenuBarAppending = false;
}

bool ImGui::BeginMenu(const char* label, bool enabled)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const ImGuiID id = window->GetID(label);

    ImVec2 label_size = CalcTextSize(label, NULL, true);

    bool pressed;
    bool menu_is_open = IsPopupOpen(id);
    bool menuset_is_open = !(window->Flags & ImGuiWindowFlags_Popup) && (g.OpenPopupStack.Size > g.BeginPopupStack.Size && g.OpenPopupStack[g.BeginPopupStack.Size].OpenParentId == window->IDStack.back());
    ImGuiWindow* backed_nav_window = g.NavWindow;
    if (menuset_is_open)
        g.NavWindow = window;  // Odd hack to allow hovering across menus of a same menu-set (otherwise we wouldn't be able to hover parent)

    // The reference position stored in popup_pos will be used by Begin() to find a suitable position for the child menu,
    // However the final position is going to be different! It is choosen by FindBestWindowPosForPopup().
    // e.g. Menus tend to overlap each other horizontally to amplify relative Z-ordering.
    ImVec2 popup_pos, pos = window->DC.CursorPos;
    if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)
    {
        // Menu inside an horizontal menu bar
        // Selectable extend their highlight by half ItemSpacing in each direction.
        // For ChildMenu, the popup position will be overwritten by the call to FindBestWindowPosForPopup() in Begin()
        popup_pos = ImVec2(pos.x - 1.0f - (float)(int)(style.ItemSpacing.x * 0.5f), pos.y - style.FramePadding.y + window->MenuBarHeight());
        window->DC.CursorPos.x += (float)(int)(style.ItemSpacing.x * 0.5f);
        PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(style.ItemSpacing.x * 2.0f, style.ItemSpacing.y));
        float w = label_size.x;
        pressed = Selectable(label, menu_is_open, ImGuiSelectableFlags_NoHoldingActiveID | ImGuiSelectableFlags_PressedOnClick | ImGuiSelectableFlags_DontClosePopups | (!enabled ? ImGuiSelectableFlags_Disabled : 0), ImVec2(w, 0.0f));
        PopStyleVar();
        window->DC.CursorPos.x += (float)(int)(style.ItemSpacing.x * (-1.0f + 0.5f)); // -1 spacing to compensate the spacing added when Selectable() did a SameLine(). It would also work to call SameLine() ourselves after the PopStyleVar().
    }
    else
    {
        // Menu inside a menu
        popup_pos = ImVec2(pos.x, pos.y - style.WindowPadding.y);
        float w = window->MenuColumns.DeclColumns(label_size.x, 0.0f, (float)(int)(g.FontSize * 1.20f)); // Feedback to next frame
        float extra_w = ImMax(0.0f, GetContentRegionAvail().x - w);
        pressed = Selectable(label, menu_is_open, ImGuiSelectableFlags_NoHoldingActiveID | ImGuiSelectableFlags_PressedOnClick | ImGuiSelectableFlags_DontClosePopups | ImGuiSelectableFlags_DrawFillAvailWidth | (!enabled ? ImGuiSelectableFlags_Disabled : 0), ImVec2(w, 0.0f));
        if (!enabled) PushStyleColor(ImGuiCol_Text, g.Style.Colors[ImGuiCol_TextDisabled]);
        RenderArrow(pos + ImVec2(window->MenuColumns.Pos[2] + extra_w + g.FontSize * 0.30f, 0.0f), ImGuiDir_Right);
        if (!enabled) PopStyleColor();
    }

    const bool hovered = enabled && ItemHoverable(window->DC.LastItemRect, id);
    if (menuset_is_open)
        g.NavWindow = backed_nav_window;

    bool want_open = false;
    bool want_close = false;
    if (window->DC.LayoutType == ImGuiLayoutType_Vertical) // (window->Flags & (ImGuiWindowFlags_Popup|ImGuiWindowFlags_ChildMenu))
    {
        // Close menu when not hovering it anymore unless we are moving roughly in the direction of the menu
        // Implement http://bjk5.com/post/44698559168/breaking-down-amazons-mega-dropdown to avoid using timers, so menus feels more reactive.
        bool moving_toward_other_child_menu = false;

        ImGuiWindow* child_menu_window = (g.BeginPopupStack.Size < g.OpenPopupStack.Size && g.OpenPopupStack[g.BeginPopupStack.Size].SourceWindow == window) ? g.OpenPopupStack[g.BeginPopupStack.Size].Window : NULL;
        if (g.HoveredWindow == window && child_menu_window != NULL && !(window->Flags & ImGuiWindowFlags_MenuBar))
        {
            // FIXME-DPI: Values should be derived from a master "scale" factor.
            ImRect next_window_rect = child_menu_window->Rect();
            ImVec2 ta = g.IO.MousePos - g.IO.MouseDelta;
            ImVec2 tb = (window->Pos.x < child_menu_window->Pos.x) ? next_window_rect.GetTL() : next_window_rect.GetTR();
            ImVec2 tc = (window->Pos.x < child_menu_window->Pos.x) ? next_window_rect.GetBL() : next_window_rect.GetBR();
            float extra = ImClamp(ImFabs(ta.x - tb.x) * 0.30f, 5.0f, 30.0f);    // add a bit of extra slack.
            ta.x += (window->Pos.x < child_menu_window->Pos.x) ? -0.5f : +0.5f; // to avoid numerical issues
            tb.y = ta.y + ImMax((tb.y - extra) - ta.y, -100.0f);                // triangle is maximum 200 high to limit the slope and the bias toward large sub-menus // FIXME: Multiply by fb_scale?
            tc.y = ta.y + ImMin((tc.y + extra) - ta.y, +100.0f);
            moving_toward_other_child_menu = ImTriangleContainsPoint(ta, tb, tc, g.IO.MousePos);
            //GetForegroundDrawList()->AddTriangleFilled(ta, tb, tc, moving_within_opened_triangle ? IM_COL32(0,128,0,128) : IM_COL32(128,0,0,128)); // [DEBUG]
        }
        if (menu_is_open && !hovered && g.HoveredWindow == window && g.HoveredIdPreviousFrame != 0 && g.HoveredIdPreviousFrame != id && !moving_toward_other_child_menu)
            want_close = true;

        if (!menu_is_open && hovered && pressed) // Click to open
            want_open = true;
        else if (!menu_is_open && hovered && !moving_toward_other_child_menu) // Hover to open
            want_open = true;

        if (g.NavActivateId == id)
        {
            want_close = menu_is_open;
            want_open = !menu_is_open;
        }
        if (g.NavId == id && g.NavMoveRequest && g.NavMoveDir == ImGuiDir_Right) // Nav-Right to open
        {
            want_open = true;
            NavMoveRequestCancel();
        }
    }
    else
    {
        // Menu bar
        if (menu_is_open && pressed && menuset_is_open) // Click an open menu again to close it
        {
            want_close = true;
            want_open = menu_is_open = false;
        }
        else if (pressed || (hovered && menuset_is_open && !menu_is_open)) // First click to open, then hover to open others
        {
            want_open = true;
        }
        else if (g.NavId == id && g.NavMoveRequest && g.NavMoveDir == ImGuiDir_Down) // Nav-Down to open
        {
            want_open = true;
            NavMoveRequestCancel();
        }
    }

    if (!enabled) // explicitly close if an open menu becomes disabled, facilitate users code a lot in pattern such as 'if (BeginMenu("options", has_object)) { ..use object.. }'
        want_close = true;
    if (want_close && IsPopupOpen(id))
        ClosePopupToLevel(g.BeginPopupStack.Size, true);

    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.ItemFlags | ImGuiItemStatusFlags_Openable | (menu_is_open ? ImGuiItemStatusFlags_Opened : 0));

    if (!menu_is_open && want_open && g.OpenPopupStack.Size > g.BeginPopupStack.Size)
    {
        // Don't recycle same menu level in the same frame, first close the other menu and yield for a frame.
        OpenPopup(label);
        return false;
    }

    menu_is_open |= want_open;
    if (want_open)
        OpenPopup(label);

    if (menu_is_open)
    {
        // Sub-menus are ChildWindow so that mouse can be hovering across them (otherwise top-most popup menu would steal focus and not allow hovering on parent menu)
        SetNextWindowPos(popup_pos, ImGuiCond_Always);
        ImGuiWindowFlags flags = ImGuiWindowFlags_ChildMenu | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoNavFocus;
        if (window->Flags & (ImGuiWindowFlags_Popup|ImGuiWindowFlags_ChildMenu))
            flags |= ImGuiWindowFlags_ChildWindow;
        menu_is_open = BeginPopupEx(id, flags); // menu_is_open can be 'false' when the popup is completely clipped (e.g. zero size display)
    }

    return menu_is_open;
}

void ImGui::EndMenu()
{
    // Nav: When a left move request _within our child menu_ failed, close ourselves (the _parent_ menu).
    // A menu doesn't close itself because EndMenuBar() wants the catch the last Left<>Right inputs.
    // However, it means that with the current code, a BeginMenu() from outside another menu or a menu-bar won't be closable with the Left direction.
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (g.NavWindow && g.NavWindow->ParentWindow == window && g.NavMoveDir == ImGuiDir_Left && NavMoveRequestButNoResultYet() && window->DC.LayoutType == ImGuiLayoutType_Vertical)
    {
        ClosePopupToLevel(g.BeginPopupStack.Size, true);
        NavMoveRequestCancel();
    }

    EndPopup();
}

bool ImGui::MenuItem(const char* label, const char* shortcut, bool selected, bool enabled)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    ImGuiStyle& style = g.Style;
    ImVec2 pos = window->DC.CursorPos;
    ImVec2 label_size = CalcTextSize(label, NULL, true);

    ImGuiSelectableFlags flags = ImGuiSelectableFlags_PressedOnRelease | (enabled ? 0 : ImGuiSelectableFlags_Disabled);
    bool pressed;
    if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)
    {
        // Mimic the exact layout spacing of BeginMenu() to allow MenuItem() inside a menu bar, which is a little misleading but may be useful
        // Note that in this situation we render neither the shortcut neither the selected tick mark
        float w = label_size.x;
        window->DC.CursorPos.x += (float)(int)(style.ItemSpacing.x * 0.5f);
        PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(style.ItemSpacing.x * 2.0f, style.ItemSpacing.y));
        pressed = Selectable(label, false, flags, ImVec2(w, 0.0f));
        PopStyleVar();
        window->DC.CursorPos.x += (float)(int)(style.ItemSpacing.x * (-1.0f + 0.5f)); // -1 spacing to compensate the spacing added when Selectable() did a SameLine(). It would also work to call SameLine() ourselves after the PopStyleVar().
    }
    else
    {
        ImVec2 shortcut_size = shortcut ? CalcTextSize(shortcut, NULL) : ImVec2(0.0f, 0.0f);
        float w = window->MenuColumns.DeclColumns(label_size.x, shortcut_size.x, (float)(int)(g.FontSize * 1.20f)); // Feedback for next frame
        float extra_w = ImMax(0.0f, GetContentRegionAvail().x - w);
        pressed = Selectable(label, false, flags | ImGuiSelectableFlags_DrawFillAvailWidth, ImVec2(w, 0.0f));
        if (shortcut_size.x > 0.0f)
        {
            PushStyleColor(ImGuiCol_Text, g.Style.Colors[ImGuiCol_TextDisabled]);
            RenderText(pos + ImVec2(window->MenuColumns.Pos[1] + extra_w, 0.0f), shortcut, NULL, false);
            PopStyleColor();
        }
        if (selected)
            RenderCheckMark(pos + ImVec2(window->MenuColumns.Pos[2] + extra_w + g.FontSize * 0.40f, g.FontSize * 0.134f * 0.5f), GetColorU32(enabled ? ImGuiCol_Text : ImGuiCol_TextDisabled), g.FontSize  * 0.866f);
    }

    IMGUI_TEST_ENGINE_ITEM_INFO(window->DC.LastItemId, label, window->DC.ItemFlags | ImGuiItemStatusFlags_Checkable | (selected ? ImGuiItemStatusFlags_Checked : 0));
    return pressed;
}

bool ImGui::MenuItem(const char* label, const char* shortcut, bool* p_selected, bool enabled)
{
    if (MenuItem(label, shortcut, p_selected ? *p_selected : false, enabled))
    {
        if (p_selected)
            *p_selected = !*p_selected;
        return true;
    }
    return false;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: BeginTabBar, EndTabBar, etc.
//-------------------------------------------------------------------------
// [BETA API] API may evolve! This code has been extracted out of the Docking branch,
// and some of the construct which are not used in Master may be left here to facilitate merging.
//-------------------------------------------------------------------------
// - BeginTabBar()
// - BeginTabBarEx() [Internal]
// - EndTabBar()
// - TabBarLayout() [Internal]
// - TabBarCalcTabID() [Internal]
// - TabBarCalcMaxTabWidth() [Internal]
// - TabBarFindTabById() [Internal]
// - TabBarRemoveTab() [Internal]
// - TabBarCloseTab() [Internal]
// - TabBarScrollClamp()v
// - TabBarScrollToTab() [Internal]
// - TabBarQueueChangeTabOrder() [Internal]
// - TabBarScrollingButtons() [Internal]
// - TabBarTabListPopupButton() [Internal]
//-------------------------------------------------------------------------

namespace ImGui
{
    static void             TabBarLayout(ImGuiTabBar* tab_bar);
    static ImU32            TabBarCalcTabID(ImGuiTabBar* tab_bar, const char* label);
    static float            TabBarCalcMaxTabWidth();
    static float            TabBarScrollClamp(ImGuiTabBar* tab_bar, float scrolling);
    static void             TabBarScrollToTab(ImGuiTabBar* tab_bar, ImGuiTabItem* tab);
    static ImGuiTabItem*    TabBarScrollingButtons(ImGuiTabBar* tab_bar);
    static ImGuiTabItem*    TabBarTabListPopupButton(ImGuiTabBar* tab_bar);
}

ImGuiTabBar::ImGuiTabBar()
{
    ID = 0;
    SelectedTabId = NextSelectedTabId = VisibleTabId = 0;
    CurrFrameVisible = PrevFrameVisible = -1;
    ContentsHeight = 0.0f;
    OffsetMax = OffsetNextTab = 0.0f;
    ScrollingAnim = ScrollingTarget = ScrollingTargetDistToVisibility = ScrollingSpeed = 0.0f;
    Flags = ImGuiTabBarFlags_None;
    ReorderRequestTabId = 0;
    ReorderRequestDir = 0;
    WantLayout = VisibleTabWasSubmitted = false;
    LastTabItemIdx = -1;
}

static int IMGUI_CDECL TabItemComparerByVisibleOffset(const void* lhs, const void* rhs)
{
    const ImGuiTabItem* a = (const ImGuiTabItem*)lhs;
    const ImGuiTabItem* b = (const ImGuiTabItem*)rhs;
    return (int)(a->Offset - b->Offset);
}

static int IMGUI_CDECL TabBarSortItemComparer(const void* lhs, const void* rhs)
{
    const ImGuiTabBarSortItem* a = (const ImGuiTabBarSortItem*)lhs;
    const ImGuiTabBarSortItem* b = (const ImGuiTabBarSortItem*)rhs;
    if (int d = (int)(b->Width - a->Width))
        return d;
    return (b->Index - a->Index);
}

static ImGuiTabBar* GetTabBarFromTabBarRef(const ImGuiTabBarRef& ref)
{
    ImGuiContext& g = *GImGui;
    return ref.Ptr ? ref.Ptr : g.TabBars.GetByIndex(ref.IndexInMainPool);
}

static ImGuiTabBarRef GetTabBarRefFromTabBar(ImGuiTabBar* tab_bar)
{
    ImGuiContext& g = *GImGui;
    if (g.TabBars.Contains(tab_bar))
        return ImGuiTabBarRef(g.TabBars.GetIndex(tab_bar));
    return ImGuiTabBarRef(tab_bar);
}

bool    ImGui::BeginTabBar(const char* str_id, ImGuiTabBarFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (window->SkipItems)
        return false;

    ImGuiID id = window->GetID(str_id);
    ImGuiTabBar* tab_bar = g.TabBars.GetOrAddByKey(id);
    ImRect tab_bar_bb = ImRect(window->DC.CursorPos.x, window->DC.CursorPos.y, window->InnerClipRect.Max.x, window->DC.CursorPos.y + g.FontSize + g.Style.FramePadding.y * 2);
    tab_bar->ID = id;
    return BeginTabBarEx(tab_bar, tab_bar_bb, flags | ImGuiTabBarFlags_IsFocused);
}

bool    ImGui::BeginTabBarEx(ImGuiTabBar* tab_bar, const ImRect& tab_bar_bb, ImGuiTabBarFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (window->SkipItems)
        return false;

    if ((flags & ImGuiTabBarFlags_DockNode) == 0)
        PushOverrideID(tab_bar->ID);

    // Add to stack
    g.CurrentTabBarStack.push_back(GetTabBarRefFromTabBar(tab_bar));
    g.CurrentTabBar = tab_bar;

    if (tab_bar->CurrFrameVisible == g.FrameCount)
    {
        //IMGUI_DEBUG_LOG("BeginTabBarEx already called this frame\n", g.FrameCount);
        IM_ASSERT(0);
        return true;
    }

    // When toggling back from ordered to manually-reorderable, shuffle tabs to enforce the last visible order.
    // Otherwise, the most recently inserted tabs would move at the end of visible list which can be a little too confusing or magic for the user.
    if ((flags & ImGuiTabBarFlags_Reorderable) && !(tab_bar->Flags & ImGuiTabBarFlags_Reorderable) && tab_bar->Tabs.Size > 1 && tab_bar->PrevFrameVisible != -1)
        ImQsort(tab_bar->Tabs.Data, tab_bar->Tabs.Size, sizeof(ImGuiTabItem), TabItemComparerByVisibleOffset);

    // Flags
    if ((flags & ImGuiTabBarFlags_FittingPolicyMask_) == 0)
        flags |= ImGuiTabBarFlags_FittingPolicyDefault_;

    tab_bar->Flags = flags;
    tab_bar->BarRect = tab_bar_bb;
    tab_bar->WantLayout = true; // Layout will be done on the first call to ItemTab()
    tab_bar->PrevFrameVisible = tab_bar->CurrFrameVisible;
    tab_bar->CurrFrameVisible = g.FrameCount;
    tab_bar->FramePadding = g.Style.FramePadding;

    // Layout
    ItemSize(ImVec2(tab_bar->OffsetMax, tab_bar->BarRect.GetHeight()));
    window->DC.CursorPos.x = tab_bar->BarRect.Min.x;

    // Draw separator
    const ImU32 col = GetColorU32((flags & ImGuiTabBarFlags_IsFocused) ? ImGuiCol_TabActive : ImGuiCol_Tab);
    const float y = tab_bar->BarRect.Max.y - 1.0f;
    {
        const float separator_min_x = tab_bar->BarRect.Min.x - window->WindowPadding.x;
        const float separator_max_x = tab_bar->BarRect.Max.x + window->WindowPadding.x;
        window->DrawList->AddLine(ImVec2(separator_min_x, y), ImVec2(separator_max_x, y), col, 1.0f);
    }
    return true;
}

void    ImGui::EndTabBar()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (window->SkipItems)
        return;

    ImGuiTabBar* tab_bar = g.CurrentTabBar;
    if (tab_bar == NULL)
    {
        IM_ASSERT(tab_bar != NULL && "Mismatched BeginTabBar()/EndTabBar()!");
        return; // FIXME-ERRORHANDLING
    }
    if (tab_bar->WantLayout)
        TabBarLayout(tab_bar);

    // Restore the last visible height if no tab is visible, this reduce vertical flicker/movement when a tabs gets removed without calling SetTabItemClosed().
    const bool tab_bar_appearing = (tab_bar->PrevFrameVisible + 1 < g.FrameCount);
    if (tab_bar->VisibleTabWasSubmitted || tab_bar->VisibleTabId == 0 || tab_bar_appearing)
        tab_bar->ContentsHeight = ImMax(window->DC.CursorPos.y - tab_bar->BarRect.Max.y, 0.0f);
    else
        window->DC.CursorPos.y = tab_bar->BarRect.Max.y + tab_bar->ContentsHeight;

    if ((tab_bar->Flags & ImGuiTabBarFlags_DockNode) == 0)
        PopID();

    g.CurrentTabBarStack.pop_back();
    g.CurrentTabBar = g.CurrentTabBarStack.empty() ? NULL : GetTabBarFromTabBarRef(g.CurrentTabBarStack.back());
}

// This is called only once a frame before by the first call to ItemTab()
// The reason we're not calling it in BeginTabBar() is to leave a chance to the user to call the SetTabItemClosed() functions.
static void ImGui::TabBarLayout(ImGuiTabBar* tab_bar)
{
    ImGuiContext& g = *GImGui;
    tab_bar->WantLayout = false;

    // Garbage collect
    int tab_dst_n = 0;
    for (int tab_src_n = 0; tab_src_n < tab_bar->Tabs.Size; tab_src_n++)
    {
        ImGuiTabItem* tab = &tab_bar->Tabs[tab_src_n];
        if (tab->LastFrameVisible < tab_bar->PrevFrameVisible)
        {
            if (tab->ID == tab_bar->SelectedTabId)
                tab_bar->SelectedTabId = 0;
            continue;
        }
        if (tab_dst_n != tab_src_n)
            tab_bar->Tabs[tab_dst_n] = tab_bar->Tabs[tab_src_n];
        tab_dst_n++;
    }
    if (tab_bar->Tabs.Size != tab_dst_n)
        tab_bar->Tabs.resize(tab_dst_n);

    // Setup next selected tab
    ImGuiID scroll_track_selected_tab_id = 0;
    if (tab_bar->NextSelectedTabId)
    {
        tab_bar->SelectedTabId = tab_bar->NextSelectedTabId;
        tab_bar->NextSelectedTabId = 0;
        scroll_track_selected_tab_id = tab_bar->SelectedTabId;
    }

    // Process order change request (we could probably process it when requested but it's just saner to do it in a single spot).
    if (tab_bar->ReorderRequestTabId != 0)
    {
        if (ImGuiTabItem* tab1 = TabBarFindTabByID(tab_bar, tab_bar->ReorderRequestTabId))
        {
            //IM_ASSERT(tab_bar->Flags & ImGuiTabBarFlags_Reorderable); // <- this may happen when using debug tools
            int tab2_order = tab_bar->GetTabOrder(tab1) + tab_bar->ReorderRequestDir;
            if (tab2_order >= 0 && tab2_order < tab_bar->Tabs.Size)
            {
                ImGuiTabItem* tab2 = &tab_bar->Tabs[tab2_order];
                ImGuiTabItem item_tmp = *tab1;
                *tab1 = *tab2;
                *tab2 = item_tmp;
                if (tab2->ID == tab_bar->SelectedTabId)
                    scroll_track_selected_tab_id = tab2->ID;
                tab1 = tab2 = NULL;
            }
            if (tab_bar->Flags & ImGuiTabBarFlags_SaveSettings)
                MarkIniSettingsDirty();
        }
        tab_bar->ReorderRequestTabId = 0;
    }

    // Tab List Popup (will alter tab_bar->BarRect and therefore the available width!)
    const bool tab_list_popup_button = (tab_bar->Flags & ImGuiTabBarFlags_TabListPopupButton) != 0;
    if (tab_list_popup_button)
        if (ImGuiTabItem* tab_to_select = TabBarTabListPopupButton(tab_bar)) // NB: Will alter BarRect.Max.x!
            scroll_track_selected_tab_id = tab_bar->SelectedTabId = tab_to_select->ID;

    ImVector<ImGuiTabBarSortItem>& width_sort_buffer = g.TabSortByWidthBuffer;
    width_sort_buffer.resize(tab_bar->Tabs.Size);

    // Compute ideal widths
    float width_total_contents = 0.0f;
    ImGuiTabItem* most_recently_selected_tab = NULL;
    bool found_selected_tab_id = false;
    for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)
    {
        ImGuiTabItem* tab = &tab_bar->Tabs[tab_n];
        IM_ASSERT(tab->LastFrameVisible >= tab_bar->PrevFrameVisible);

        if (most_recently_selected_tab == NULL || most_recently_selected_tab->LastFrameSelected < tab->LastFrameSelected)
            most_recently_selected_tab = tab;
        if (tab->ID == tab_bar->SelectedTabId)
            found_selected_tab_id = true;

        // Refresh tab width immediately, otherwise changes of style e.g. style.FramePadding.x would noticeably lag in the tab bar.
        // Additionally, when using TabBarAddTab() to manipulate tab bar order we occasionally insert new tabs that don't have a width yet,
        // and we cannot wait for the next BeginTabItem() call. We cannot compute this width within TabBarAddTab() because font size depends on the active window.
        const char* tab_name = tab_bar->GetTabName(tab);
        tab->WidthContents = TabItemCalcSize(tab_name, (tab->Flags & ImGuiTabItemFlags_NoCloseButton) ? false : true).x;

        width_total_contents += (tab_n > 0 ? g.Style.ItemInnerSpacing.x : 0.0f) + tab->WidthContents;

        // Store data so we can build an array sorted by width if we need to shrink tabs down
        width_sort_buffer[tab_n].Index = tab_n;
        width_sort_buffer[tab_n].Width = tab->WidthContents;
    }

    // Compute width
    const float width_avail = tab_bar->BarRect.GetWidth();
    float width_excess = (width_avail < width_total_contents) ? (width_total_contents - width_avail) : 0.0f;
    if (width_excess > 0.0f && (tab_bar->Flags & ImGuiTabBarFlags_FittingPolicyResizeDown))
    {
        // If we don't have enough room, resize down the largest tabs first
        if (tab_bar->Tabs.Size > 1)
            ImQsort(width_sort_buffer.Data, (size_t)width_sort_buffer.Size, sizeof(ImGuiTabBarSortItem), TabBarSortItemComparer);
        int tab_count_same_width = 1;
        while (width_excess > 0.0f && tab_count_same_width < tab_bar->Tabs.Size)
        {
            while (tab_count_same_width < tab_bar->Tabs.Size && width_sort_buffer[0].Width == width_sort_buffer[tab_count_same_width].Width)
                tab_count_same_width++;
            float width_to_remove_per_tab_max = (tab_count_same_width < tab_bar->Tabs.Size) ? (width_sort_buffer[0].Width - width_sort_buffer[tab_count_same_width].Width) : (width_sort_buffer[0].Width - 1.0f);
            float width_to_remove_per_tab = ImMin(width_excess / tab_count_same_width, width_to_remove_per_tab_max);
            for (int tab_n = 0; tab_n < tab_count_same_width; tab_n++)
                width_sort_buffer[tab_n].Width -= width_to_remove_per_tab;
            width_excess -= width_to_remove_per_tab * tab_count_same_width;
        }
        for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)
            tab_bar->Tabs[width_sort_buffer[tab_n].Index].Width = (float)(int)width_sort_buffer[tab_n].Width;
    }
    else
    {
        const float tab_max_width = TabBarCalcMaxTabWidth();
        for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)
        {
            ImGuiTabItem* tab = &tab_bar->Tabs[tab_n];
            tab->Width = ImMin(tab->WidthContents, tab_max_width);
        }
    }

    // Layout all active tabs
    float offset_x = 0.0f;
    for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)
    {
        ImGuiTabItem* tab = &tab_bar->Tabs[tab_n];
        tab->Offset = offset_x;
        if (scroll_track_selected_tab_id == 0 && g.NavJustMovedToId == tab->ID)
            scroll_track_selected_tab_id = tab->ID;
        offset_x += tab->Width + g.Style.ItemInnerSpacing.x;
    }
    tab_bar->OffsetMax = ImMax(offset_x - g.Style.ItemInnerSpacing.x, 0.0f);
    tab_bar->OffsetNextTab = 0.0f;

    // Horizontal scrolling buttons
    const bool scrolling_buttons = (tab_bar->OffsetMax > tab_bar->BarRect.GetWidth() && tab_bar->Tabs.Size > 1) && !(tab_bar->Flags & ImGuiTabBarFlags_NoTabListScrollingButtons) && (tab_bar->Flags & ImGuiTabBarFlags_FittingPolicyScroll);
    if (scrolling_buttons)
        if (ImGuiTabItem* tab_to_select = TabBarScrollingButtons(tab_bar)) // NB: Will alter BarRect.Max.x!
            scroll_track_selected_tab_id = tab_bar->SelectedTabId = tab_to_select->ID;

    // If we have lost the selected tab, select the next most recently active one
    if (found_selected_tab_id == false)
        tab_bar->SelectedTabId = 0;
    if (tab_bar->SelectedTabId == 0 && tab_bar->NextSelectedTabId == 0 && most_recently_selected_tab != NULL)
        scroll_track_selected_tab_id = tab_bar->SelectedTabId = most_recently_selected_tab->ID;

    // Lock in visible tab
    tab_bar->VisibleTabId = tab_bar->SelectedTabId;
    tab_bar->VisibleTabWasSubmitted = false;

    // Update scrolling
    if (scroll_track_selected_tab_id)
        if (ImGuiTabItem* scroll_track_selected_tab = TabBarFindTabByID(tab_bar, scroll_track_selected_tab_id))
            TabBarScrollToTab(tab_bar, scroll_track_selected_tab);
    tab_bar->ScrollingAnim = TabBarScrollClamp(tab_bar, tab_bar->ScrollingAnim);
    tab_bar->ScrollingTarget = TabBarScrollClamp(tab_bar, tab_bar->ScrollingTarget);
    if (tab_bar->ScrollingAnim != tab_bar->ScrollingTarget)
    {
        // Scrolling speed adjust itself so we can always reach our target in 1/3 seconds.
        // Teleport if we are aiming far off the visible line
        tab_bar->ScrollingSpeed = ImMax(tab_bar->ScrollingSpeed, 70.0f * g.FontSize);
        tab_bar->ScrollingSpeed = ImMax(tab_bar->ScrollingSpeed, ImFabs(tab_bar->ScrollingTarget - tab_bar->ScrollingAnim) / 0.3f);
        const bool teleport = (tab_bar->PrevFrameVisible + 1 < g.FrameCount) || (tab_bar->ScrollingTargetDistToVisibility > 10.0f * g.FontSize);
        tab_bar->ScrollingAnim = teleport ? tab_bar->ScrollingTarget : ImLinearSweep(tab_bar->ScrollingAnim, tab_bar->ScrollingTarget, g.IO.DeltaTime * tab_bar->ScrollingSpeed);
    }
    else
    {
        tab_bar->ScrollingSpeed = 0.0f;
    }

    // Clear name buffers
    if ((tab_bar->Flags & ImGuiTabBarFlags_DockNode) == 0)
        tab_bar->TabsNames.Buf.resize(0);
}

// Dockables uses Name/ID in the global namespace. Non-dockable items use the ID stack.
static ImU32   ImGui::TabBarCalcTabID(ImGuiTabBar* tab_bar, const char* label)
{
    if (tab_bar->Flags & ImGuiTabBarFlags_DockNode)
    {
        ImGuiID id = ImHashStr(label);
        KeepAliveID(id);
        return id;
    }
    else
    {
        ImGuiWindow* window = GImGui->CurrentWindow;
        return window->GetID(label);
    }
}

static float ImGui::TabBarCalcMaxTabWidth()
{
    ImGuiContext& g = *GImGui;
    return g.FontSize * 20.0f;
}

ImGuiTabItem* ImGui::TabBarFindTabByID(ImGuiTabBar* tab_bar, ImGuiID tab_id)
{
    if (tab_id != 0)
        for (int n = 0; n < tab_bar->Tabs.Size; n++)
            if (tab_bar->Tabs[n].ID == tab_id)
                return &tab_bar->Tabs[n];
    return NULL;
}

// The *TabId fields be already set by the docking system _before_ the actual TabItem was created, so we clear them regardless.
void ImGui::TabBarRemoveTab(ImGuiTabBar* tab_bar, ImGuiID tab_id)
{
    if (ImGuiTabItem* tab = TabBarFindTabByID(tab_bar, tab_id))
        tab_bar->Tabs.erase(tab);
    if (tab_bar->VisibleTabId == tab_id)      { tab_bar->VisibleTabId = 0; }
    if (tab_bar->SelectedTabId == tab_id)     { tab_bar->SelectedTabId = 0; }
    if (tab_bar->NextSelectedTabId == tab_id) { tab_bar->NextSelectedTabId = 0; }
}

// Called on manual closure attempt
void ImGui::TabBarCloseTab(ImGuiTabBar* tab_bar, ImGuiTabItem* tab)
{
    if ((tab_bar->VisibleTabId == tab->ID) && !(tab->Flags & ImGuiTabItemFlags_UnsavedDocument))
    {
        // This will remove a frame of lag for selecting another tab on closure.
        // However we don't run it in the case where the 'Unsaved' flag is set, so user gets a chance to fully undo the closure
        tab->LastFrameVisible = -1;
        tab_bar->SelectedTabId = tab_bar->NextSelectedTabId = 0;
    }
    else if ((tab_bar->VisibleTabId != tab->ID) && (tab->Flags & ImGuiTabItemFlags_UnsavedDocument))
    {
        // Actually select before expecting closure
        tab_bar->NextSelectedTabId = tab->ID;
    }
}

static float ImGui::TabBarScrollClamp(ImGuiTabBar* tab_bar, float scrolling)
{
    scrolling = ImMin(scrolling, tab_bar->OffsetMax - tab_bar->BarRect.GetWidth());
    return ImMax(scrolling, 0.0f);
}

static void ImGui::TabBarScrollToTab(ImGuiTabBar* tab_bar, ImGuiTabItem* tab)
{
    ImGuiContext& g = *GImGui;
    float margin = g.FontSize * 1.0f; // When to scroll to make Tab N+1 visible always make a bit of N visible to suggest more scrolling area (since we don't have a scrollbar)
    int order = tab_bar->GetTabOrder(tab);
    float tab_x1 = tab->Offset + (order > 0 ? -margin : 0.0f);
    float tab_x2 = tab->Offset + tab->Width + (order + 1 < tab_bar->Tabs.Size ? margin : 1.0f);
    tab_bar->ScrollingTargetDistToVisibility = 0.0f;
    if (tab_bar->ScrollingTarget > tab_x1)
    {
        tab_bar->ScrollingTargetDistToVisibility = ImMax(tab_bar->ScrollingAnim - tab_x2, 0.0f);
        tab_bar->ScrollingTarget = tab_x1;
    }
    else if (tab_bar->ScrollingTarget < tab_x2 - tab_bar->BarRect.GetWidth())
    {
        tab_bar->ScrollingTargetDistToVisibility = ImMax((tab_x1 - tab_bar->BarRect.GetWidth()) - tab_bar->ScrollingAnim, 0.0f);
        tab_bar->ScrollingTarget = tab_x2 - tab_bar->BarRect.GetWidth();
    }
}

void ImGui::TabBarQueueChangeTabOrder(ImGuiTabBar* tab_bar, const ImGuiTabItem* tab, int dir)
{
    IM_ASSERT(dir == -1 || dir == +1);
    IM_ASSERT(tab_bar->ReorderRequestTabId == 0);
    tab_bar->ReorderRequestTabId = tab->ID;
    tab_bar->ReorderRequestDir = dir;
}

static ImGuiTabItem* ImGui::TabBarScrollingButtons(ImGuiTabBar* tab_bar)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    const ImVec2 arrow_button_size(g.FontSize - 2.0f, g.FontSize + g.Style.FramePadding.y * 2.0f);
    const float scrolling_buttons_width = arrow_button_size.x * 2.0f;

    const ImVec2 backup_cursor_pos = window->DC.CursorPos;
    //window->DrawList->AddRect(ImVec2(tab_bar->BarRect.Max.x - scrolling_buttons_width, tab_bar->BarRect.Min.y), ImVec2(tab_bar->BarRect.Max.x, tab_bar->BarRect.Max.y), IM_COL32(255,0,0,255));

    const ImRect avail_bar_rect = tab_bar->BarRect;
    bool want_clip_rect = !avail_bar_rect.Contains(ImRect(window->DC.CursorPos, window->DC.CursorPos + ImVec2(scrolling_buttons_width, 0.0f)));
    if (want_clip_rect)
        PushClipRect(tab_bar->BarRect.Min, tab_bar->BarRect.Max + ImVec2(g.Style.ItemInnerSpacing.x, 0.0f), true);

    ImGuiTabItem* tab_to_select = NULL;

    int select_dir = 0;
    ImVec4 arrow_col = g.Style.Colors[ImGuiCol_Text];
    arrow_col.w *= 0.5f;

    PushStyleColor(ImGuiCol_Text, arrow_col);
    PushStyleColor(ImGuiCol_Button, ImVec4(0, 0, 0, 0));
    const float backup_repeat_delay = g.IO.KeyRepeatDelay;
    const float backup_repeat_rate = g.IO.KeyRepeatRate;
    g.IO.KeyRepeatDelay = 0.250f;
    g.IO.KeyRepeatRate = 0.200f;
    window->DC.CursorPos = ImVec2(tab_bar->BarRect.Max.x - scrolling_buttons_width, tab_bar->BarRect.Min.y);
    if (ArrowButtonEx("##<", ImGuiDir_Left, arrow_button_size, ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_Repeat))
        select_dir = -1;
    window->DC.CursorPos = ImVec2(tab_bar->BarRect.Max.x - scrolling_buttons_width + arrow_button_size.x, tab_bar->BarRect.Min.y);
    if (ArrowButtonEx("##>", ImGuiDir_Right, arrow_button_size, ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_Repeat))
        select_dir = +1;
    PopStyleColor(2);
    g.IO.KeyRepeatRate = backup_repeat_rate;
    g.IO.KeyRepeatDelay = backup_repeat_delay;

    if (want_clip_rect)
        PopClipRect();

    if (select_dir != 0)
        if (ImGuiTabItem* tab_item = TabBarFindTabByID(tab_bar, tab_bar->SelectedTabId))
        {
            int selected_order = tab_bar->GetTabOrder(tab_item);
            int target_order = selected_order + select_dir;
            tab_to_select = &tab_bar->Tabs[(target_order >= 0 && target_order < tab_bar->Tabs.Size) ? target_order : selected_order]; // If we are at the end of the list, still scroll to make our tab visible
        }
    window->DC.CursorPos = backup_cursor_pos;
    tab_bar->BarRect.Max.x -= scrolling_buttons_width + 1.0f;

    return tab_to_select;
}

static ImGuiTabItem* ImGui::TabBarTabListPopupButton(ImGuiTabBar* tab_bar)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    // We use g.Style.FramePadding.y to match the square ArrowButton size
    const float tab_list_popup_button_width = g.FontSize + g.Style.FramePadding.y;
    const ImVec2 backup_cursor_pos = window->DC.CursorPos;
    window->DC.CursorPos = ImVec2(tab_bar->BarRect.Min.x - g.Style.FramePadding.y, tab_bar->BarRect.Min.y);
    tab_bar->BarRect.Min.x += tab_list_popup_button_width;

    ImVec4 arrow_col = g.Style.Colors[ImGuiCol_Text];
    arrow_col.w *= 0.5f;
    PushStyleColor(ImGuiCol_Text, arrow_col);
    PushStyleColor(ImGuiCol_Button, ImVec4(0, 0, 0, 0));
    bool open = BeginCombo("##v", NULL, ImGuiComboFlags_NoPreview);
    PopStyleColor(2);

    ImGuiTabItem* tab_to_select = NULL;
    if (open)
    {
        for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)
        {
            ImGuiTabItem* tab = &tab_bar->Tabs[tab_n];
            const char* tab_name = tab_bar->GetTabName(tab);
            if (Selectable(tab_name, tab_bar->SelectedTabId == tab->ID))
                tab_to_select = tab;
        }
        EndCombo();
    }

    window->DC.CursorPos = backup_cursor_pos;
    return tab_to_select;
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: BeginTabItem, EndTabItem, etc.
//-------------------------------------------------------------------------
// [BETA API] API may evolve! This code has been extracted out of the Docking branch,
// and some of the construct which are not used in Master may be left here to facilitate merging.
//-------------------------------------------------------------------------
// - BeginTabItem()
// - EndTabItem()
// - TabItemEx() [Internal]
// - SetTabItemClosed()
// - TabItemCalcSize() [Internal]
// - TabItemBackground() [Internal]
// - TabItemLabelAndCloseButton() [Internal]
//-------------------------------------------------------------------------

bool    ImGui::BeginTabItem(const char* label, bool* p_open, ImGuiTabItemFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (window->SkipItems)
        return false;

    ImGuiTabBar* tab_bar = g.CurrentTabBar;
    if (tab_bar == NULL)
    {
        IM_ASSERT(tab_bar && "Needs to be called between BeginTabBar() and EndTabBar()!");
        return false; // FIXME-ERRORHANDLING
    }
    bool ret = TabItemEx(tab_bar, label, p_open, flags);
    if (ret && !(flags & ImGuiTabItemFlags_NoPushId))
    {
        ImGuiTabItem* tab = &tab_bar->Tabs[tab_bar->LastTabItemIdx];
        PushOverrideID(tab->ID); // We already hashed 'label' so push into the ID stack directly instead of doing another hash through PushID(label)
    }
    return ret;
}

void    ImGui::EndTabItem()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (window->SkipItems)
        return;

    ImGuiTabBar* tab_bar = g.CurrentTabBar;
    if (tab_bar == NULL)
    {
        IM_ASSERT(tab_bar != NULL && "Needs to be called between BeginTabBar() and EndTabBar()!");
        return;
    }
    IM_ASSERT(tab_bar->LastTabItemIdx >= 0);
    ImGuiTabItem* tab = &tab_bar->Tabs[tab_bar->LastTabItemIdx];
    if (!(tab->Flags & ImGuiTabItemFlags_NoPushId))
        window->IDStack.pop_back();
}

bool    ImGui::TabItemEx(ImGuiTabBar* tab_bar, const char* label, bool* p_open, ImGuiTabItemFlags flags)
{
    // Layout whole tab bar if not already done
    if (tab_bar->WantLayout)
        TabBarLayout(tab_bar);

    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (window->SkipItems)
        return false;

    const ImGuiStyle& style = g.Style;
    const ImGuiID id = TabBarCalcTabID(tab_bar, label);

    // If the user called us with *p_open == false, we early out and don't render. We make a dummy call to ItemAdd() so that attempts to use a contextual popup menu with an implicit ID won't use an older ID.
    if (p_open && !*p_open)
    {
        PushItemFlag(ImGuiItemFlags_NoNav | ImGuiItemFlags_NoNavDefaultFocus, true);
        ItemAdd(ImRect(), id);
        PopItemFlag();
        return false;
    }

    // Calculate tab contents size
    ImVec2 size = TabItemCalcSize(label, p_open != NULL);

    // Acquire tab data
    ImGuiTabItem* tab = TabBarFindTabByID(tab_bar, id);
    bool tab_is_new = false;
    if (tab == NULL)
    {
        tab_bar->Tabs.push_back(ImGuiTabItem());
        tab = &tab_bar->Tabs.back();
        tab->ID = id;
        tab->Width = size.x;
        tab_is_new = true;
    }
    tab_bar->LastTabItemIdx = (short)tab_bar->Tabs.index_from_ptr(tab);
    tab->WidthContents = size.x;

    if (p_open == NULL)
        flags |= ImGuiTabItemFlags_NoCloseButton;

    const bool tab_bar_appearing = (tab_bar->PrevFrameVisible + 1 < g.FrameCount);
    const bool tab_bar_focused = (tab_bar->Flags & ImGuiTabBarFlags_IsFocused) != 0;
    const bool tab_appearing = (tab->LastFrameVisible + 1 < g.FrameCount);
    tab->LastFrameVisible = g.FrameCount;
    tab->Flags = flags;

    // Append name with zero-terminator
    tab->NameOffset = tab_bar->TabsNames.size();
    tab_bar->TabsNames.append(label, label + strlen(label) + 1);

    // If we are not reorderable, always reset offset based on submission order.
    // (We already handled layout and sizing using the previous known order, but sizing is not affected by order!)
    if (!tab_appearing && !(tab_bar->Flags & ImGuiTabBarFlags_Reorderable))
    {
        tab->Offset = tab_bar->OffsetNextTab;
        tab_bar->OffsetNextTab += tab->Width + g.Style.ItemInnerSpacing.x;
    }

    // Update selected tab
    if (tab_appearing && (tab_bar->Flags & ImGuiTabBarFlags_AutoSelectNewTabs) && tab_bar->NextSelectedTabId == 0)
        if (!tab_bar_appearing || tab_bar->SelectedTabId == 0)
            tab_bar->NextSelectedTabId = id;  // New tabs gets activated
    if ((flags & ImGuiTabItemFlags_SetSelected) && (tab_bar->SelectedTabId != id)) // SetSelected can only be passed on explicit tab bar
        tab_bar->NextSelectedTabId = id;

    // Lock visibility
    bool tab_contents_visible = (tab_bar->VisibleTabId == id);
    if (tab_contents_visible)
        tab_bar->VisibleTabWasSubmitted = true;

    // On the very first frame of a tab bar we let first tab contents be visible to minimize appearing glitches
    if (!tab_contents_visible && tab_bar->SelectedTabId == 0 && tab_bar_appearing)
        if (tab_bar->Tabs.Size == 1 && !(tab_bar->Flags & ImGuiTabBarFlags_AutoSelectNewTabs))
            tab_contents_visible = true;

    if (tab_appearing && !(tab_bar_appearing && !tab_is_new))
    {
        PushItemFlag(ImGuiItemFlags_NoNav | ImGuiItemFlags_NoNavDefaultFocus, true);
        ItemAdd(ImRect(), id);
        PopItemFlag();
        return tab_contents_visible;
    }

    if (tab_bar->SelectedTabId == id)
        tab->LastFrameSelected = g.FrameCount;

    // Backup current layout position
    const ImVec2 backup_main_cursor_pos = window->DC.CursorPos;

    // Layout
    size.x = tab->Width;
    window->DC.CursorPos = tab_bar->BarRect.Min + ImVec2((float)(int)tab->Offset - tab_bar->ScrollingAnim, 0.0f);
    ImVec2 pos = window->DC.CursorPos;
    ImRect bb(pos, pos + size);

    // We don't have CPU clipping primitives to clip the CloseButton (until it becomes a texture), so need to add an extra draw call (temporary in the case of vertical animation)
    bool want_clip_rect = (bb.Min.x < tab_bar->BarRect.Min.x) || (bb.Max.x >= tab_bar->BarRect.Max.x);
    if (want_clip_rect)
        PushClipRect(ImVec2(ImMax(bb.Min.x, tab_bar->BarRect.Min.x), bb.Min.y - 1), ImVec2(tab_bar->BarRect.Max.x, bb.Max.y), true);

    ItemSize(bb, style.FramePadding.y);
    if (!ItemAdd(bb, id))
    {
        if (want_clip_rect)
            PopClipRect();
        window->DC.CursorPos = backup_main_cursor_pos;
        return tab_contents_visible;
    }

    // Click to Select a tab
    ImGuiButtonFlags button_flags = (ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_AllowItemOverlap);
    if (g.DragDropActive)
        button_flags |= ImGuiButtonFlags_PressedOnDragDropHold;
    bool hovered, held;
    bool pressed = ButtonBehavior(bb, id, &hovered, &held, button_flags);
    if (pressed)
        tab_bar->NextSelectedTabId = id;
    hovered |= (g.HoveredId == id);

    // Allow the close button to overlap unless we are dragging (in which case we don't want any overlapping tabs to be hovered)
    if (!held)
        SetItemAllowOverlap();

    // Drag and drop: re-order tabs
    if (held && !tab_appearing && IsMouseDragging(0))
    {
        if (!g.DragDropActive && (tab_bar->Flags & ImGuiTabBarFlags_Reorderable))
        {
            // While moving a tab it will jump on the other side of the mouse, so we also test for MouseDelta.x
            if (g.IO.MouseDelta.x < 0.0f && g.IO.MousePos.x < bb.Min.x)
            {
                if (tab_bar->Flags & ImGuiTabBarFlags_Reorderable)
                    TabBarQueueChangeTabOrder(tab_bar, tab, -1);
            }
            else if (g.IO.MouseDelta.x > 0.0f && g.IO.MousePos.x > bb.Max.x)
            {
                if (tab_bar->Flags & ImGuiTabBarFlags_Reorderable)
                    TabBarQueueChangeTabOrder(tab_bar, tab, +1);
            }
        }
    }

#if 0
    if (hovered && g.HoveredIdNotActiveTimer > 0.50f && bb.GetWidth() < tab->WidthContents)
    {
        // Enlarge tab display when hovering
        bb.Max.x = bb.Min.x + (float)(int)ImLerp(bb.GetWidth(), tab->WidthContents, ImSaturate((g.HoveredIdNotActiveTimer - 0.40f) * 6.0f));
        display_draw_list = GetForegroundDrawList(window);
        TabItemBackground(display_draw_list, bb, flags, GetColorU32(ImGuiCol_TitleBgActive));
    }
#endif

    // Render tab shape
    ImDrawList* display_draw_list = window->DrawList;
    const ImU32 tab_col = GetColorU32((held || hovered) ? ImGuiCol_TabHovered : tab_contents_visible ? (tab_bar_focused ? ImGuiCol_TabActive : ImGuiCol_TabUnfocusedActive) : (tab_bar_focused ? ImGuiCol_Tab : ImGuiCol_TabUnfocused));
    TabItemBackground(display_draw_list, bb, flags, tab_col);
    RenderNavHighlight(bb, id);

    // Select with right mouse button. This is so the common idiom for context menu automatically highlight the current widget.
    const bool hovered_unblocked = IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup);
    if (hovered_unblocked && (IsMouseClicked(1) || IsMouseReleased(1)))
        tab_bar->NextSelectedTabId = id;

    if (tab_bar->Flags & ImGuiTabBarFlags_NoCloseWithMiddleMouseButton)
        flags |= ImGuiTabItemFlags_NoCloseWithMiddleMouseButton;

    // Render tab label, process close button
    const ImGuiID close_button_id = p_open ? window->GetID((void*)((intptr_t)id + 1)) : 0;
    bool just_closed = TabItemLabelAndCloseButton(display_draw_list, bb, flags, tab_bar->FramePadding, label, id, close_button_id);
    if (just_closed && p_open != NULL)
    {
        *p_open = false;
        TabBarCloseTab(tab_bar, tab);
    }

    // Restore main window position so user can draw there
    if (want_clip_rect)
        PopClipRect();
    window->DC.CursorPos = backup_main_cursor_pos;

    // Tooltip (FIXME: Won't work over the close button because ItemOverlap systems messes up with HoveredIdTimer)
    // We test IsItemHovered() to discard e.g. when another item is active or drag and drop over the tab bar (which g.HoveredId ignores)
    if (g.HoveredId == id && !held && g.HoveredIdNotActiveTimer > 0.50f && IsItemHovered())
        if (!(tab_bar->Flags & ImGuiTabBarFlags_NoTooltip))
            SetTooltip("%.*s", (int)(FindRenderedTextEnd(label) - label), label);

    return tab_contents_visible;
}

// [Public] This is call is 100% optional but it allows to remove some one-frame glitches when a tab has been unexpectedly removed.
// To use it to need to call the function SetTabItemClosed() after BeginTabBar() and before any call to BeginTabItem()
void    ImGui::SetTabItemClosed(const char* label)
{
    ImGuiContext& g = *GImGui;
    bool is_within_manual_tab_bar = g.CurrentTabBar && !(g.CurrentTabBar->Flags & ImGuiTabBarFlags_DockNode);
    if (is_within_manual_tab_bar)
    {
        ImGuiTabBar* tab_bar = g.CurrentTabBar;
        IM_ASSERT(tab_bar->WantLayout);         // Needs to be called AFTER BeginTabBar() and BEFORE the first call to BeginTabItem()
        ImGuiID tab_id = TabBarCalcTabID(tab_bar, label);
        TabBarRemoveTab(tab_bar, tab_id);
    }
}

ImVec2 ImGui::TabItemCalcSize(const char* label, bool has_close_button)
{
    ImGuiContext& g = *GImGui;
    ImVec2 label_size = CalcTextSize(label, NULL, true);
    ImVec2 size = ImVec2(label_size.x + g.Style.FramePadding.x, label_size.y + g.Style.FramePadding.y * 2.0f);
    if (has_close_button)
        size.x += g.Style.FramePadding.x + (g.Style.ItemInnerSpacing.x + g.FontSize); // We use Y intentionally to fit the close button circle.
    else
        size.x += g.Style.FramePadding.x + 1.0f;
    return ImVec2(ImMin(size.x, TabBarCalcMaxTabWidth()), size.y);
}

void ImGui::TabItemBackground(ImDrawList* draw_list, const ImRect& bb, ImGuiTabItemFlags flags, ImU32 col)
{
    // While rendering tabs, we trim 1 pixel off the top of our bounding box so they can fit within a regular frame height while looking "detached" from it.
    ImGuiContext& g = *GImGui;
    const float width = bb.GetWidth();
    IM_UNUSED(flags);
    IM_ASSERT(width > 0.0f);
    const float rounding = ImMax(0.0f, ImMin(g.Style.TabRounding, width * 0.5f - 1.0f));
    const float y1 = bb.Min.y + 1.0f;
    const float y2 = bb.Max.y - 1.0f;
    draw_list->PathLineTo(ImVec2(bb.Min.x, y2));
    draw_list->PathArcToFast(ImVec2(bb.Min.x + rounding, y1 + rounding), rounding, 6, 9);
    draw_list->PathArcToFast(ImVec2(bb.Max.x - rounding, y1 + rounding), rounding, 9, 12);
    draw_list->PathLineTo(ImVec2(bb.Max.x, y2));
    draw_list->PathFillConvex(col);
    if (g.Style.TabBorderSize > 0.0f)
    {
        draw_list->PathLineTo(ImVec2(bb.Min.x + 0.5f, y2));
        draw_list->PathArcToFast(ImVec2(bb.Min.x + rounding + 0.5f, y1 + rounding + 0.5f), rounding, 6, 9);
        draw_list->PathArcToFast(ImVec2(bb.Max.x - rounding - 0.5f, y1 + rounding + 0.5f), rounding, 9, 12);
        draw_list->PathLineTo(ImVec2(bb.Max.x - 0.5f, y2));
        draw_list->PathStroke(GetColorU32(ImGuiCol_Border), false, g.Style.TabBorderSize);
    }
}

// Render text label (with custom clipping) + Unsaved Document marker + Close Button logic
// We tend to lock style.FramePadding for a given tab-bar, hence the 'frame_padding' parameter.
bool ImGui::TabItemLabelAndCloseButton(ImDrawList* draw_list, const ImRect& bb, ImGuiTabItemFlags flags, ImVec2 frame_padding, const char* label, ImGuiID tab_id, ImGuiID close_button_id)
{
    ImGuiContext& g = *GImGui;
    ImVec2 label_size = CalcTextSize(label, NULL, true);
    if (bb.GetWidth() <= 1.0f)
        return false;

    // Render text label (with clipping + alpha gradient) + unsaved marker
    const char* TAB_UNSAVED_MARKER = "*";
    ImRect text_pixel_clip_bb(bb.Min.x + frame_padding.x, bb.Min.y + frame_padding.y, bb.Max.x - frame_padding.x, bb.Max.y);
    if (flags & ImGuiTabItemFlags_UnsavedDocument)
    {
        text_pixel_clip_bb.Max.x -= CalcTextSize(TAB_UNSAVED_MARKER, NULL, false).x;
        ImVec2 unsaved_marker_pos(ImMin(bb.Min.x + frame_padding.x + label_size.x + 2, text_pixel_clip_bb.Max.x), bb.Min.y + frame_padding.y + (float)(int)(-g.FontSize * 0.25f));
        RenderTextClippedEx(draw_list, unsaved_marker_pos, bb.Max - frame_padding, TAB_UNSAVED_MARKER, NULL, NULL);
    }
    ImRect text_ellipsis_clip_bb = text_pixel_clip_bb;

    // Close Button
    // We are relying on a subtle and confusing distinction between 'hovered' and 'g.HoveredId' which happens because we are using ImGuiButtonFlags_AllowOverlapMode + SetItemAllowOverlap()
    //  'hovered' will be true when hovering the Tab but NOT when hovering the close button
    //  'g.HoveredId==id' will be true when hovering the Tab including when hovering the close button
    //  'g.ActiveId==close_button_id' will be true when we are holding on the close button, in which case both hovered booleans are false
    bool close_button_pressed = false;
    bool close_button_visible = false;
    if (close_button_id != 0)
        if (g.HoveredId == tab_id || g.HoveredId == close_button_id || g.ActiveId == close_button_id)
            close_button_visible = true;
    if (close_button_visible)
    {
        ImGuiItemHoveredDataBackup last_item_backup;
        const float close_button_sz = g.FontSize * 0.5f;
        if (CloseButton(close_button_id, ImVec2(bb.Max.x - frame_padding.x - close_button_sz, bb.Min.y + frame_padding.y + close_button_sz), close_button_sz))
            close_button_pressed = true;
        last_item_backup.Restore();

        // Close with middle mouse button
        if (!(flags & ImGuiTabItemFlags_NoCloseWithMiddleMouseButton) && IsMouseClicked(2))
            close_button_pressed = true;

        text_pixel_clip_bb.Max.x -= close_button_sz * 2.0f;
    }

    // Label with ellipsis
    // FIXME: This should be extracted into a helper but the use of text_pixel_clip_bb and !close_button_visible makes it tricky to abstract at the moment
    const char* label_display_end = FindRenderedTextEnd(label);
    if (label_size.x > text_ellipsis_clip_bb.GetWidth())
    {
        const int ellipsis_dot_count = 3;
        const float ellipsis_width = (1.0f + 1.0f) * ellipsis_dot_count - 1.0f;
        const char* label_end = NULL;
        float label_size_clipped_x = g.Font->CalcTextSizeA(g.FontSize, text_ellipsis_clip_bb.GetWidth() - ellipsis_width + 1.0f, 0.0f, label, label_display_end, &label_end).x;
        if (label_end == label && label_end < label_display_end)    // Always display at least 1 character if there's no room for character + ellipsis
        {
            label_end = label + ImTextCountUtf8BytesFromChar(label, label_display_end);
            label_size_clipped_x = g.Font->CalcTextSizeA(g.FontSize, FLT_MAX, 0.0f, label, label_end).x;
        }
        while (label_end > label && ImCharIsBlankA(label_end[-1])) // Trim trailing space
        {
            label_end--;
            label_size_clipped_x -= g.Font->CalcTextSizeA(g.FontSize, FLT_MAX, 0.0f, label_end, label_end + 1).x; // Ascii blanks are always 1 byte
        }
        RenderTextClippedEx(draw_list, text_pixel_clip_bb.Min, text_pixel_clip_bb.Max, label, label_end, &label_size, ImVec2(0.0f, 0.0f));

        const float ellipsis_x = text_pixel_clip_bb.Min.x + label_size_clipped_x + 1.0f;
        if (!close_button_visible && ellipsis_x + ellipsis_width <= bb.Max.x)
            RenderPixelEllipsis(draw_list, ImVec2(ellipsis_x, text_pixel_clip_bb.Min.y), ellipsis_dot_count, GetColorU32(ImGuiCol_Text));
    }
    else
    {
        RenderTextClippedEx(draw_list, text_pixel_clip_bb.Min, text_pixel_clip_bb.Max, label, label_display_end, &label_size, ImVec2(0.0f, 0.0f));
    }

    return close_button_pressed;
}

```

`UnrealFinderTool/ImGUI/imstb_rectpack.h`:

```h
// stb_rect_pack.h - v0.11 - public domain - rectangle packing
// Sean Barrett 2014
//
// Useful for e.g. packing rectangular textures into an atlas.
// Does not do rotation.
//
// Not necessarily the awesomest packing method, but better than
// the totally naive one in stb_truetype (which is primarily what
// this is meant to replace).
//
// Has only had a few tests run, may have issues.
//
// More docs to come.
//
// No memory allocations; uses qsort() and assert() from stdlib.
// Can override those by defining STBRP_SORT and STBRP_ASSERT.
//
// This library currently uses the Skyline Bottom-Left algorithm.
//
// Please note: better rectangle packers are welcome! Please
// implement them to the same API, but with a different init
// function.
//
// Credits
//
//  Library
//    Sean Barrett
//  Minor features
//    Martins Mozeiko
//    github:IntellectualKitty
//    
//  Bugfixes / warning fixes
//    Jeremy Jaussaud
//
// Version history:
//
//     0.11  (2017-03-03)  return packing success/fail result
//     0.10  (2016-10-25)  remove cast-away-const to avoid warnings
//     0.09  (2016-08-27)  fix compiler warnings
//     0.08  (2015-09-13)  really fix bug with empty rects (w=0 or h=0)
//     0.07  (2015-09-13)  fix bug with empty rects (w=0 or h=0)
//     0.06  (2015-04-15)  added STBRP_SORT to allow replacing qsort
//     0.05:  added STBRP_ASSERT to allow replacing assert
//     0.04:  fixed minor bug in STBRP_LARGE_RECTS support
//     0.01:  initial release
//
// LICENSE
//
//   See end of file for license information.

//////////////////////////////////////////////////////////////////////////////
//
//       INCLUDE SECTION
//

#ifndef STB_INCLUDE_STB_RECT_PACK_H
#define STB_INCLUDE_STB_RECT_PACK_H

#define STB_RECT_PACK_VERSION  1

#ifdef STBRP_STATIC
#define STBRP_DEF static
#else
#define STBRP_DEF extern
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct stbrp_context stbrp_context;
typedef struct stbrp_node    stbrp_node;
typedef struct stbrp_rect    stbrp_rect;

#ifdef STBRP_LARGE_RECTS
typedef int            stbrp_coord;
#else
typedef unsigned short stbrp_coord;
#endif

STBRP_DEF int stbrp_pack_rects (stbrp_context *context, stbrp_rect *rects, int num_rects);
// Assign packed locations to rectangles. The rectangles are of type
// 'stbrp_rect' defined below, stored in the array 'rects', and there
// are 'num_rects' many of them.
//
// Rectangles which are successfully packed have the 'was_packed' flag
// set to a non-zero value and 'x' and 'y' store the minimum location
// on each axis (i.e. bottom-left in cartesian coordinates, top-left
// if you imagine y increasing downwards). Rectangles which do not fit
// have the 'was_packed' flag set to 0.
//
// You should not try to access the 'rects' array from another thread
// while this function is running, as the function temporarily reorders
// the array while it executes.
//
// To pack into another rectangle, you need to call stbrp_init_target
// again. To continue packing into the same rectangle, you can call
// this function again. Calling this multiple times with multiple rect
// arrays will probably produce worse packing results than calling it
// a single time with the full rectangle array, but the option is
// available.
//
// The function returns 1 if all of the rectangles were successfully
// packed and 0 otherwise.

struct stbrp_rect
{
   // reserved for your use:
   int            id;

   // input:
   stbrp_coord    w, h;

   // output:
   stbrp_coord    x, y;
   int            was_packed;  // non-zero if valid packing

}; // 16 bytes, nominally


STBRP_DEF void stbrp_init_target (stbrp_context *context, int width, int height, stbrp_node *nodes, int num_nodes);
// Initialize a rectangle packer to:
//    pack a rectangle that is 'width' by 'height' in dimensions
//    using temporary storage provided by the array 'nodes', which is 'num_nodes' long
//
// You must call this function every time you start packing into a new target.
//
// There is no "shutdown" function. The 'nodes' memory must stay valid for
// the following stbrp_pack_rects() call (or calls), but can be freed after
// the call (or calls) finish.
//
// Note: to guarantee best results, either:
//       1. make sure 'num_nodes' >= 'width'
//   or  2. call stbrp_allow_out_of_mem() defined below with 'allow_out_of_mem = 1'
//
// If you don't do either of the above things, widths will be quantized to multiples
// of small integers to guarantee the algorithm doesn't run out of temporary storage.
//
// If you do #2, then the non-quantized algorithm will be used, but the algorithm
// may run out of temporary storage and be unable to pack some rectangles.

STBRP_DEF void stbrp_setup_allow_out_of_mem (stbrp_context *context, int allow_out_of_mem);
// Optionally call this function after init but before doing any packing to
// change the handling of the out-of-temp-memory scenario, described above.
// If you call init again, this will be reset to the default (false).


STBRP_DEF void stbrp_setup_heuristic (stbrp_context *context, int heuristic);
// Optionally select which packing heuristic the library should use. Different
// heuristics will produce better/worse results for different data sets.
// If you call init again, this will be reset to the default.

enum
{
   STBRP_HEURISTIC_Skyline_default=0,
   STBRP_HEURISTIC_Skyline_BL_sortHeight = STBRP_HEURISTIC_Skyline_default,
   STBRP_HEURISTIC_Skyline_BF_sortHeight
};


//////////////////////////////////////////////////////////////////////////////
//
// the details of the following structures don't matter to you, but they must
// be visible so you can handle the memory allocations for them

struct stbrp_node
{
   stbrp_coord  x,y;
   stbrp_node  *next;
};

struct stbrp_context
{
   int width;
   int height;
   int align;
   int init_mode;
   int heuristic;
   int num_nodes;
   stbrp_node *active_head;
   stbrp_node *free_head;
   stbrp_node extra[2]; // we allocate two extra nodes so optimal user-node-count is 'width' not 'width+2'
};

#ifdef __cplusplus
}
#endif

#endif

//////////////////////////////////////////////////////////////////////////////
//
//     IMPLEMENTATION SECTION
//

#ifdef STB_RECT_PACK_IMPLEMENTATION
#ifndef STBRP_SORT
#include <stdlib.h>
#define STBRP_SORT qsort
#endif

#ifndef STBRP_ASSERT
#include <assert.h>
#define STBRP_ASSERT assert
#endif

#ifdef _MSC_VER
#define STBRP__NOTUSED(v)  (void)(v)
#define STBRP__CDECL __cdecl
#else
#define STBRP__NOTUSED(v)  (void)sizeof(v)
#define STBRP__CDECL
#endif

enum
{
   STBRP__INIT_skyline = 1
};

STBRP_DEF void stbrp_setup_heuristic(stbrp_context *context, int heuristic)
{
   switch (context->init_mode) {
      case STBRP__INIT_skyline:
         STBRP_ASSERT(heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight || heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight);
         context->heuristic = heuristic;
         break;
      default:
         STBRP_ASSERT(0);
   }
}

STBRP_DEF void stbrp_setup_allow_out_of_mem(stbrp_context *context, int allow_out_of_mem)
{
   if (allow_out_of_mem)
      // if it's ok to run out of memory, then don't bother aligning them;
      // this gives better packing, but may fail due to OOM (even though
      // the rectangles easily fit). @TODO a smarter approach would be to only
      // quantize once we've hit OOM, then we could get rid of this parameter.
      context->align = 1;
   else {
      // if it's not ok to run out of memory, then quantize the widths
      // so that num_nodes is always enough nodes.
      //
      // I.e. num_nodes * align >= width
      //                  align >= width / num_nodes
      //                  align = ceil(width/num_nodes)

      context->align = (context->width + context->num_nodes-1) / context->num_nodes;
   }
}

STBRP_DEF void stbrp_init_target(stbrp_context *context, int width, int height, stbrp_node *nodes, int num_nodes)
{
   int i;
#ifndef STBRP_LARGE_RECTS
   STBRP_ASSERT(width <= 0xffff && height <= 0xffff);
#endif

   for (i=0; i < num_nodes-1; ++i)
      nodes[i].next = &nodes[i+1];
   nodes[i].next = NULL;
   context->init_mode = STBRP__INIT_skyline;
   context->heuristic = STBRP_HEURISTIC_Skyline_default;
   context->free_head = &nodes[0];
   context->active_head = &context->extra[0];
   context->width = width;
   context->height = height;
   context->num_nodes = num_nodes;
   stbrp_setup_allow_out_of_mem(context, 0);

   // node 0 is the full width, node 1 is the sentinel (lets us not store width explicitly)
   context->extra[0].x = 0;
   context->extra[0].y = 0;
   context->extra[0].next = &context->extra[1];
   context->extra[1].x = (stbrp_coord) width;
#ifdef STBRP_LARGE_RECTS
   context->extra[1].y = (1<<30);
#else
   context->extra[1].y = 65535;
#endif
   context->extra[1].next = NULL;
}

// find minimum y position if it starts at x1
static int stbrp__skyline_find_min_y(stbrp_context *c, stbrp_node *first, int x0, int width, int *pwaste)
{
   stbrp_node *node = first;
   int x1 = x0 + width;
   int min_y, visited_width, waste_area;

   STBRP__NOTUSED(c);

   STBRP_ASSERT(first->x <= x0);

   #if 0
   // skip in case we're past the node
   while (node->next->x <= x0)
      ++node;
   #else
   STBRP_ASSERT(node->next->x > x0); // we ended up handling this in the caller for efficiency
   #endif

   STBRP_ASSERT(node->x <= x0);

   min_y = 0;
   waste_area = 0;
   visited_width = 0;
   while (node->x < x1) {
      if (node->y > min_y) {
         // raise min_y higher.
         // we've accounted for all waste up to min_y,
         // but we'll now add more waste for everything we've visted
         waste_area += visited_width * (node->y - min_y);
         min_y = node->y;
         // the first time through, visited_width might be reduced
         if (node->x < x0)
            visited_width += node->next->x - x0;
         else
            visited_width += node->next->x - node->x;
      } else {
         // add waste area
         int under_width = node->next->x - node->x;
         if (under_width + visited_width > width)
            under_width = width - visited_width;
         waste_area += under_width * (min_y - node->y);
         visited_width += under_width;
      }
      node = node->next;
   }

   *pwaste = waste_area;
   return min_y;
}

typedef struct
{
   int x,y;
   stbrp_node **prev_link;
} stbrp__findresult;

static stbrp__findresult stbrp__skyline_find_best_pos(stbrp_context *c, int width, int height)
{
   int best_waste = (1<<30), best_x, best_y = (1 << 30);
   stbrp__findresult fr;
   stbrp_node **prev, *node, *tail, **best = NULL;

   // align to multiple of c->align
   width = (width + c->align - 1);
   width -= width % c->align;
   STBRP_ASSERT(width % c->align == 0);

   node = c->active_head;
   prev = &c->active_head;
   while (node->x + width <= c->width) {
      int y,waste;
      y = stbrp__skyline_find_min_y(c, node, node->x, width, &waste);
      if (c->heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight) { // actually just want to test BL
         // bottom left
         if (y < best_y) {
            best_y = y;
            best = prev;
         }
      } else {
         // best-fit
         if (y + height <= c->height) {
            // can only use it if it first vertically
            if (y < best_y || (y == best_y && waste < best_waste)) {
               best_y = y;
               best_waste = waste;
               best = prev;
            }
         }
      }
      prev = &node->next;
      node = node->next;
   }

   best_x = (best == NULL) ? 0 : (*best)->x;

   // if doing best-fit (BF), we also have to try aligning right edge to each node position
   //
   // e.g, if fitting
   //
   //     ____________________
   //    |____________________|
   //
   //            into
   //
   //   |                         |
   //   |             ____________|
   //   |____________|
   //
   // then right-aligned reduces waste, but bottom-left BL is always chooses left-aligned
   //
   // This makes BF take about 2x the time

   if (c->heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight) {
      tail = c->active_head;
      node = c->active_head;
      prev = &c->active_head;
      // find first node that's admissible
      while (tail->x < width)
         tail = tail->next;
      while (tail) {
         int xpos = tail->x - width;
         int y,waste;
         STBRP_ASSERT(xpos >= 0);
         // find the left position that matches this
         while (node->next->x <= xpos) {
            prev = &node->next;
            node = node->next;
         }
         STBRP_ASSERT(node->next->x > xpos && node->x <= xpos);
         y = stbrp__skyline_find_min_y(c, node, xpos, width, &waste);
         if (y + height < c->height) {
            if (y <= best_y) {
               if (y < best_y || waste < best_waste || (waste==best_waste && xpos < best_x)) {
                  best_x = xpos;
                  STBRP_ASSERT(y <= best_y);
                  best_y = y;
                  best_waste = waste;
                  best = prev;
               }
            }
         }
         tail = tail->next;
      }         
   }

   fr.prev_link = best;
   fr.x = best_x;
   fr.y = best_y;
   return fr;
}

static stbrp__findresult stbrp__skyline_pack_rectangle(stbrp_context *context, int width, int height)
{
   // find best position according to heuristic
   stbrp__findresult res = stbrp__skyline_find_best_pos(context, width, height);
   stbrp_node *node, *cur;

   // bail if:
   //    1. it failed
   //    2. the best node doesn't fit (we don't always check this)
   //    3. we're out of memory
   if (res.prev_link == NULL || res.y + height > context->height || context->free_head == NULL) {
      res.prev_link = NULL;
      return res;
   }

   // on success, create new node
   node = context->free_head;
   node->x = (stbrp_coord) res.x;
   node->y = (stbrp_coord) (res.y + height);

   context->free_head = node->next;

   // insert the new node into the right starting point, and
   // let 'cur' point to the remaining nodes needing to be
   // stiched back in

   cur = *res.prev_link;
   if (cur->x < res.x) {
      // preserve the existing one, so start testing with the next one
      stbrp_node *next = cur->next;
      cur->next = node;
      cur = next;
   } else {
      *res.prev_link = node;
   }

   // from here, traverse cur and free the nodes, until we get to one
   // that shouldn't be freed
   while (cur->next && cur->next->x <= res.x + width) {
      stbrp_node *next = cur->next;
      // move the current node to the free list
      cur->next = context->free_head;
      context->free_head = cur;
      cur = next;
   }

   // stitch the list back in
   node->next = cur;

   if (cur->x < res.x + width)
      cur->x = (stbrp_coord) (res.x + width);

#ifdef _DEBUG
   cur = context->active_head;
   while (cur->x < context->width) {
      STBRP_ASSERT(cur->x < cur->next->x);
      cur = cur->next;
   }
   STBRP_ASSERT(cur->next == NULL);

   {
      int count=0;
      cur = context->active_head;
      while (cur) {
         cur = cur->next;
         ++count;
      }
      cur = context->free_head;
      while (cur) {
         cur = cur->next;
         ++count;
      }
      STBRP_ASSERT(count == context->num_nodes+2);
   }
#endif

   return res;
}

static int STBRP__CDECL rect_height_compare(const void *a, const void *b)
{
   const stbrp_rect *p = (const stbrp_rect *) a;
   const stbrp_rect *q = (const stbrp_rect *) b;
   if (p->h > q->h)
      return -1;
   if (p->h < q->h)
      return  1;
   return (p->w > q->w) ? -1 : (p->w < q->w);
}

static int STBRP__CDECL rect_original_order(const void *a, const void *b)
{
   const stbrp_rect *p = (const stbrp_rect *) a;
   const stbrp_rect *q = (const stbrp_rect *) b;
   return (p->was_packed < q->was_packed) ? -1 : (p->was_packed > q->was_packed);
}

#ifdef STBRP_LARGE_RECTS
#define STBRP__MAXVAL  0xffffffff
#else
#define STBRP__MAXVAL  0xffff
#endif

STBRP_DEF int stbrp_pack_rects(stbrp_context *context, stbrp_rect *rects, int num_rects)
{
   int i, all_rects_packed = 1;

   // we use the 'was_packed' field internally to allow sorting/unsorting
   for (i=0; i < num_rects; ++i) {
      rects[i].was_packed = i;
      #ifndef STBRP_LARGE_RECTS
      STBRP_ASSERT(rects[i].w <= 0xffff && rects[i].h <= 0xffff);
      #endif
   }

   // sort according to heuristic
   STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_height_compare);

   for (i=0; i < num_rects; ++i) {
      if (rects[i].w == 0 || rects[i].h == 0) {
         rects[i].x = rects[i].y = 0;  // empty rect needs no space
      } else {
         stbrp__findresult fr = stbrp__skyline_pack_rectangle(context, rects[i].w, rects[i].h);
         if (fr.prev_link) {
            rects[i].x = (stbrp_coord) fr.x;
            rects[i].y = (stbrp_coord) fr.y;
         } else {
            rects[i].x = rects[i].y = STBRP__MAXVAL;
         }
      }
   }

   // unsort
   STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_original_order);

   // set was_packed flags and all_rects_packed status
   for (i=0; i < num_rects; ++i) {
      rects[i].was_packed = !(rects[i].x == STBRP__MAXVAL && rects[i].y == STBRP__MAXVAL);
      if (!rects[i].was_packed)
         all_rects_packed = 0;
   }

   // return the all_rects_packed status
   return all_rects_packed;
}
#endif

/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of 
this software and associated documentation files (the "Software"), to deal in 
the Software without restriction, including without limitation the rights to 
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies 
of the Software, and to permit persons to whom the Software is furnished to do 
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all 
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this 
software, either in source code form or as a compiled binary, for any purpose, 
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this 
software dedicate any and all copyright interest in the software to the public 
domain. We make this dedication for the benefit of the public at large and to 
the detriment of our heirs and successors. We intend this dedication to be an 
overt act of relinquishment in perpetuity of all present and future rights to 
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN 
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/

```

`UnrealFinderTool/ImGUI/imstb_textedit.h`:

```h
// [ImGui] this is a slightly modified version of stb_textedit.h 1.12. Those changes would need to be pushed into nothings/stb
// [ImGui] - 2018-06: fixed undo/redo after pasting large amount of text (over 32 kb). Redo will still fail when undo buffers are exhausted, but text won't be corrupted (see nothings/stb issue #620)
// [ImGui] - 2018-06: fix in stb_textedit_discard_redo (see https://github.com/nothings/stb/issues/321)
// [ImGui] - fixed some minor warnings

// stb_textedit.h - v1.12  - public domain - Sean Barrett
// Development of this library was sponsored by RAD Game Tools
//
// This C header file implements the guts of a multi-line text-editing
// widget; you implement display, word-wrapping, and low-level string
// insertion/deletion, and stb_textedit will map user inputs into
// insertions & deletions, plus updates to the cursor position,
// selection state, and undo state.
//
// It is intended for use in games and other systems that need to build
// their own custom widgets and which do not have heavy text-editing
// requirements (this library is not recommended for use for editing large
// texts, as its performance does not scale and it has limited undo).
//
// Non-trivial behaviors are modelled after Windows text controls.
// 
//
// LICENSE
//
// See end of file for license information.
//
//
// DEPENDENCIES
//
// Uses the C runtime function 'memmove', which you can override
// by defining STB_TEXTEDIT_memmove before the implementation.
// Uses no other functions. Performs no runtime allocations.
//
//
// VERSION HISTORY
//
//   1.12 (2018-01-29) user can change STB_TEXTEDIT_KEYTYPE, fix redo to avoid crash
//   1.11 (2017-03-03) fix HOME on last line, dragging off single-line textfield
//   1.10 (2016-10-25) supress warnings about casting away const with -Wcast-qual
//   1.9  (2016-08-27) customizable move-by-word
//   1.8  (2016-04-02) better keyboard handling when mouse button is down
//   1.7  (2015-09-13) change y range handling in case baseline is non-0
//   1.6  (2015-04-15) allow STB_TEXTEDIT_memmove
//   1.5  (2014-09-10) add support for secondary keys for OS X
//   1.4  (2014-08-17) fix signed/unsigned warnings
//   1.3  (2014-06-19) fix mouse clicking to round to nearest char boundary
//   1.2  (2014-05-27) fix some RAD types that had crept into the new code
//   1.1  (2013-12-15) move-by-word (requires STB_TEXTEDIT_IS_SPACE )
//   1.0  (2012-07-26) improve documentation, initial public release
//   0.3  (2012-02-24) bugfixes, single-line mode; insert mode
//   0.2  (2011-11-28) fixes to undo/redo
//   0.1  (2010-07-08) initial version
//
// ADDITIONAL CONTRIBUTORS
//
//   Ulf Winklemann: move-by-word in 1.1
//   Fabian Giesen: secondary key inputs in 1.5
//   Martins Mozeiko: STB_TEXTEDIT_memmove in 1.6
//
//   Bugfixes:
//      Scott Graham
//      Daniel Keller
//      Omar Cornut
//      Dan Thompson
//
// USAGE
//
// This file behaves differently depending on what symbols you define
// before including it.
//
//
// Header-file mode:
//
//   If you do not define STB_TEXTEDIT_IMPLEMENTATION before including this,
//   it will operate in "header file" mode. In this mode, it declares a
//   single public symbol, STB_TexteditState, which encapsulates the current
//   state of a text widget (except for the string, which you will store
//   separately).
//
//   To compile in this mode, you must define STB_TEXTEDIT_CHARTYPE to a
//   primitive type that defines a single character (e.g. char, wchar_t, etc).
//
//   To save space or increase undo-ability, you can optionally define the
//   following things that are used by the undo system:
//
//      STB_TEXTEDIT_POSITIONTYPE         small int type encoding a valid cursor position
//      STB_TEXTEDIT_UNDOSTATECOUNT       the number of undo states to allow
//      STB_TEXTEDIT_UNDOCHARCOUNT        the number of characters to store in the undo buffer
//
//   If you don't define these, they are set to permissive types and
//   moderate sizes. The undo system does no memory allocations, so
//   it grows STB_TexteditState by the worst-case storage which is (in bytes):
//
//        [4 + 3 * sizeof(STB_TEXTEDIT_POSITIONTYPE)] * STB_TEXTEDIT_UNDOSTATE_COUNT
//      +          sizeof(STB_TEXTEDIT_CHARTYPE)      * STB_TEXTEDIT_UNDOCHAR_COUNT
//
//
// Implementation mode:
//
//   If you define STB_TEXTEDIT_IMPLEMENTATION before including this, it
//   will compile the implementation of the text edit widget, depending
//   on a large number of symbols which must be defined before the include.
//
//   The implementation is defined only as static functions. You will then
//   need to provide your own APIs in the same file which will access the
//   static functions.
//
//   The basic concept is that you provide a "string" object which
//   behaves like an array of characters. stb_textedit uses indices to
//   refer to positions in the string, implicitly representing positions
//   in the displayed textedit. This is true for both plain text and
//   rich text; even with rich text stb_truetype interacts with your
//   code as if there was an array of all the displayed characters.
//
// Symbols that must be the same in header-file and implementation mode:
//
//     STB_TEXTEDIT_CHARTYPE             the character type
//     STB_TEXTEDIT_POSITIONTYPE         small type that is a valid cursor position
//     STB_TEXTEDIT_UNDOSTATECOUNT       the number of undo states to allow
//     STB_TEXTEDIT_UNDOCHARCOUNT        the number of characters to store in the undo buffer
//
// Symbols you must define for implementation mode:
//
//    STB_TEXTEDIT_STRING               the type of object representing a string being edited,
//                                      typically this is a wrapper object with other data you need
//
//    STB_TEXTEDIT_STRINGLEN(obj)       the length of the string (ideally O(1))
//    STB_TEXTEDIT_LAYOUTROW(&r,obj,n)  returns the results of laying out a line of characters
//                                        starting from character #n (see discussion below)
//    STB_TEXTEDIT_GETWIDTH(obj,n,i)    returns the pixel delta from the xpos of the i'th character
//                                        to the xpos of the i+1'th char for a line of characters
//                                        starting at character #n (i.e. accounts for kerning
//                                        with previous char)
//    STB_TEXTEDIT_KEYTOTEXT(k)         maps a keyboard input to an insertable character
//                                        (return type is int, -1 means not valid to insert)
//    STB_TEXTEDIT_GETCHAR(obj,i)       returns the i'th character of obj, 0-based
//    STB_TEXTEDIT_NEWLINE              the character returned by _GETCHAR() we recognize
//                                        as manually wordwrapping for end-of-line positioning
//
//    STB_TEXTEDIT_DELETECHARS(obj,i,n)      delete n characters starting at i
//    STB_TEXTEDIT_INSERTCHARS(obj,i,c*,n)   insert n characters at i (pointed to by STB_TEXTEDIT_CHARTYPE*)
//
//    STB_TEXTEDIT_K_SHIFT       a power of two that is or'd in to a keyboard input to represent the shift key
//
//    STB_TEXTEDIT_K_LEFT        keyboard input to move cursor left
//    STB_TEXTEDIT_K_RIGHT       keyboard input to move cursor right
//    STB_TEXTEDIT_K_UP          keyboard input to move cursor up
//    STB_TEXTEDIT_K_DOWN        keyboard input to move cursor down
//    STB_TEXTEDIT_K_LINESTART   keyboard input to move cursor to start of line  // e.g. HOME
//    STB_TEXTEDIT_K_LINEEND     keyboard input to move cursor to end of line    // e.g. END
//    STB_TEXTEDIT_K_TEXTSTART   keyboard input to move cursor to start of text  // e.g. ctrl-HOME
//    STB_TEXTEDIT_K_TEXTEND     keyboard input to move cursor to end of text    // e.g. ctrl-END
//    STB_TEXTEDIT_K_DELETE      keyboard input to delete selection or character under cursor
//    STB_TEXTEDIT_K_BACKSPACE   keyboard input to delete selection or character left of cursor
//    STB_TEXTEDIT_K_UNDO        keyboard input to perform undo
//    STB_TEXTEDIT_K_REDO        keyboard input to perform redo
//
// Optional:
//    STB_TEXTEDIT_K_INSERT              keyboard input to toggle insert mode
//    STB_TEXTEDIT_IS_SPACE(ch)          true if character is whitespace (e.g. 'isspace'),
//                                          required for default WORDLEFT/WORDRIGHT handlers
//    STB_TEXTEDIT_MOVEWORDLEFT(obj,i)   custom handler for WORDLEFT, returns index to move cursor to
//    STB_TEXTEDIT_MOVEWORDRIGHT(obj,i)  custom handler for WORDRIGHT, returns index to move cursor to
//    STB_TEXTEDIT_K_WORDLEFT            keyboard input to move cursor left one word // e.g. ctrl-LEFT
//    STB_TEXTEDIT_K_WORDRIGHT           keyboard input to move cursor right one word // e.g. ctrl-RIGHT
//    STB_TEXTEDIT_K_LINESTART2          secondary keyboard input to move cursor to start of line
//    STB_TEXTEDIT_K_LINEEND2            secondary keyboard input to move cursor to end of line
//    STB_TEXTEDIT_K_TEXTSTART2          secondary keyboard input to move cursor to start of text
//    STB_TEXTEDIT_K_TEXTEND2            secondary keyboard input to move cursor to end of text
//
// Todo:
//    STB_TEXTEDIT_K_PGUP        keyboard input to move cursor up a page
//    STB_TEXTEDIT_K_PGDOWN      keyboard input to move cursor down a page
//
// Keyboard input must be encoded as a single integer value; e.g. a character code
// and some bitflags that represent shift states. to simplify the interface, SHIFT must
// be a bitflag, so we can test the shifted state of cursor movements to allow selection,
// i.e. (STB_TEXTED_K_RIGHT|STB_TEXTEDIT_K_SHIFT) should be shifted right-arrow.
//
// You can encode other things, such as CONTROL or ALT, in additional bits, and
// then test for their presence in e.g. STB_TEXTEDIT_K_WORDLEFT. For example,
// my Windows implementations add an additional CONTROL bit, and an additional KEYDOWN
// bit. Then all of the STB_TEXTEDIT_K_ values bitwise-or in the KEYDOWN bit,
// and I pass both WM_KEYDOWN and WM_CHAR events to the "key" function in the
// API below. The control keys will only match WM_KEYDOWN events because of the
// keydown bit I add, and STB_TEXTEDIT_KEYTOTEXT only tests for the KEYDOWN
// bit so it only decodes WM_CHAR events.
//
// STB_TEXTEDIT_LAYOUTROW returns information about the shape of one displayed
// row of characters assuming they start on the i'th character--the width and
// the height and the number of characters consumed. This allows this library
// to traverse the entire layout incrementally. You need to compute word-wrapping
// here.
//
// Each textfield keeps its own insert mode state, which is not how normal
// applications work. To keep an app-wide insert mode, update/copy the
// "insert_mode" field of STB_TexteditState before/after calling API functions.
//
// API
//
//    void stb_textedit_initialize_state(STB_TexteditState *state, int is_single_line)
//
//    void stb_textedit_click(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)
//    void stb_textedit_drag(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)
//    int  stb_textedit_cut(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
//    int  stb_textedit_paste(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE *text, int len)
//    void stb_textedit_key(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXEDIT_KEYTYPE key)
//
//    Each of these functions potentially updates the string and updates the
//    state.
//
//      initialize_state:
//          set the textedit state to a known good default state when initially
//          constructing the textedit.
//
//      click:
//          call this with the mouse x,y on a mouse down; it will update the cursor
//          and reset the selection start/end to the cursor point. the x,y must
//          be relative to the text widget, with (0,0) being the top left.
//     
//      drag:
//          call this with the mouse x,y on a mouse drag/up; it will update the
//          cursor and the selection end point
//     
//      cut:
//          call this to delete the current selection; returns true if there was
//          one. you should FIRST copy the current selection to the system paste buffer.
//          (To copy, just copy the current selection out of the string yourself.)
//     
//      paste:
//          call this to paste text at the current cursor point or over the current
//          selection if there is one.
//     
//      key:
//          call this for keyboard inputs sent to the textfield. you can use it
//          for "key down" events or for "translated" key events. if you need to
//          do both (as in Win32), or distinguish Unicode characters from control
//          inputs, set a high bit to distinguish the two; then you can define the
//          various definitions like STB_TEXTEDIT_K_LEFT have the is-key-event bit
//          set, and make STB_TEXTEDIT_KEYTOCHAR check that the is-key-event bit is
//          clear. STB_TEXTEDIT_KEYTYPE defaults to int, but you can #define it to
//          anything other type you wante before including.
//
//     
//   When rendering, you can read the cursor position and selection state from
//   the STB_TexteditState.
//
//
// Notes:
//
// This is designed to be usable in IMGUI, so it allows for the possibility of
// running in an IMGUI that has NOT cached the multi-line layout. For this
// reason, it provides an interface that is compatible with computing the
// layout incrementally--we try to make sure we make as few passes through
// as possible. (For example, to locate the mouse pointer in the text, we
// could define functions that return the X and Y positions of characters
// and binary search Y and then X, but if we're doing dynamic layout this
// will run the layout algorithm many times, so instead we manually search
// forward in one pass. Similar logic applies to e.g. up-arrow and
// down-arrow movement.)
//
// If it's run in a widget that *has* cached the layout, then this is less
// efficient, but it's not horrible on modern computers. But you wouldn't
// want to edit million-line files with it.


////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////
////   Header-file mode
////
////

#ifndef INCLUDE_STB_TEXTEDIT_H
#define INCLUDE_STB_TEXTEDIT_H

////////////////////////////////////////////////////////////////////////
//
//     STB_TexteditState
//
// Definition of STB_TexteditState which you should store
// per-textfield; it includes cursor position, selection state,
// and undo state.
//

#ifndef STB_TEXTEDIT_UNDOSTATECOUNT
#define STB_TEXTEDIT_UNDOSTATECOUNT   99
#endif
#ifndef STB_TEXTEDIT_UNDOCHARCOUNT
#define STB_TEXTEDIT_UNDOCHARCOUNT   999
#endif
#ifndef STB_TEXTEDIT_CHARTYPE
#define STB_TEXTEDIT_CHARTYPE        int
#endif
#ifndef STB_TEXTEDIT_POSITIONTYPE
#define STB_TEXTEDIT_POSITIONTYPE    int
#endif

typedef struct
{
   // private data
   STB_TEXTEDIT_POSITIONTYPE  where;
   STB_TEXTEDIT_POSITIONTYPE  insert_length;
   STB_TEXTEDIT_POSITIONTYPE  delete_length;
   int                        char_storage;
} StbUndoRecord;

typedef struct
{
   // private data
   StbUndoRecord          undo_rec [STB_TEXTEDIT_UNDOSTATECOUNT];
   STB_TEXTEDIT_CHARTYPE  undo_char[STB_TEXTEDIT_UNDOCHARCOUNT];
   short undo_point, redo_point;
   int undo_char_point, redo_char_point;
} StbUndoState;

typedef struct
{
   /////////////////////
   //
   // public data
   //

   int cursor;
   // position of the text cursor within the string

   int select_start;          // selection start point
   int select_end;
   // selection start and end point in characters; if equal, no selection.
   // note that start may be less than or greater than end (e.g. when
   // dragging the mouse, start is where the initial click was, and you
   // can drag in either direction)

   unsigned char insert_mode;
   // each textfield keeps its own insert mode state. to keep an app-wide
   // insert mode, copy this value in/out of the app state

   /////////////////////
   //
   // private data
   //
   unsigned char cursor_at_end_of_line; // not implemented yet
   unsigned char initialized;
   unsigned char has_preferred_x;
   unsigned char single_line;
   unsigned char padding1, padding2, padding3;
   float preferred_x; // this determines where the cursor up/down tries to seek to along x
   StbUndoState undostate;
} STB_TexteditState;


////////////////////////////////////////////////////////////////////////
//
//     StbTexteditRow
//
// Result of layout query, used by stb_textedit to determine where
// the text in each row is.

// result of layout query
typedef struct
{
   float x0,x1;             // starting x location, end x location (allows for align=right, etc)
   float baseline_y_delta;  // position of baseline relative to previous row's baseline
   float ymin,ymax;         // height of row above and below baseline
   int num_chars;
} StbTexteditRow;
#endif //INCLUDE_STB_TEXTEDIT_H


////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////
////   Implementation mode
////
////


// implementation isn't include-guarded, since it might have indirectly
// included just the "header" portion
#ifdef STB_TEXTEDIT_IMPLEMENTATION

#ifndef STB_TEXTEDIT_memmove
#include <string.h>
#define STB_TEXTEDIT_memmove memmove
#endif


/////////////////////////////////////////////////////////////////////////////
//
//      Mouse input handling
//

// traverse the layout to locate the nearest character to a display position
static int stb_text_locate_coord(STB_TEXTEDIT_STRING *str, float x, float y)
{
   StbTexteditRow r;
   int n = STB_TEXTEDIT_STRINGLEN(str);
   float base_y = 0, prev_x;
   int i=0, k;

   r.x0 = r.x1 = 0;
   r.ymin = r.ymax = 0;
   r.num_chars = 0;

   // search rows to find one that straddles 'y'
   while (i < n) {
      STB_TEXTEDIT_LAYOUTROW(&r, str, i);
      if (r.num_chars <= 0)
         return n;

      if (i==0 && y < base_y + r.ymin)
         return 0;

      if (y < base_y + r.ymax)
         break;

      i += r.num_chars;
      base_y += r.baseline_y_delta;
   }

   // below all text, return 'after' last character
   if (i >= n)
      return n;

   // check if it's before the beginning of the line
   if (x < r.x0)
      return i;

   // check if it's before the end of the line
   if (x < r.x1) {
      // search characters in row for one that straddles 'x'
      prev_x = r.x0;
      for (k=0; k < r.num_chars; ++k) {
         float w = STB_TEXTEDIT_GETWIDTH(str, i, k);
         if (x < prev_x+w) {
            if (x < prev_x+w/2)
               return k+i;
            else
               return k+i+1;
         }
         prev_x += w;
      }
      // shouldn't happen, but if it does, fall through to end-of-line case
   }

   // if the last character is a newline, return that. otherwise return 'after' the last character
   if (STB_TEXTEDIT_GETCHAR(str, i+r.num_chars-1) == STB_TEXTEDIT_NEWLINE)
      return i+r.num_chars-1;
   else
      return i+r.num_chars;
}

// API click: on mouse down, move the cursor to the clicked location, and reset the selection
static void stb_textedit_click(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)
{
   // In single-line mode, just always make y = 0. This lets the drag keep working if the mouse
   // goes off the top or bottom of the text
   if( state->single_line )
   {
      StbTexteditRow r;
      STB_TEXTEDIT_LAYOUTROW(&r, str, 0);
      y = r.ymin;
   }

   state->cursor = stb_text_locate_coord(str, x, y);
   state->select_start = state->cursor;
   state->select_end = state->cursor;
   state->has_preferred_x = 0;
}

// API drag: on mouse drag, move the cursor and selection endpoint to the clicked location
static void stb_textedit_drag(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)
{
   int p = 0;

   // In single-line mode, just always make y = 0. This lets the drag keep working if the mouse
   // goes off the top or bottom of the text
   if( state->single_line )
   {
      StbTexteditRow r;
      STB_TEXTEDIT_LAYOUTROW(&r, str, 0);
      y = r.ymin;
   }

   if (state->select_start == state->select_end)
      state->select_start = state->cursor;

   p = stb_text_locate_coord(str, x, y);
   state->cursor = state->select_end = p;
}

/////////////////////////////////////////////////////////////////////////////
//
//      Keyboard input handling
//

// forward declarations
static void stb_text_undo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state);
static void stb_text_redo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state);
static void stb_text_makeundo_delete(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int length);
static void stb_text_makeundo_insert(STB_TexteditState *state, int where, int length);
static void stb_text_makeundo_replace(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int old_length, int new_length);

typedef struct
{
   float x,y;    // position of n'th character
   float height; // height of line
   int first_char, length; // first char of row, and length
   int prev_first;  // first char of previous row
} StbFindState;

// find the x/y location of a character, and remember info about the previous row in
// case we get a move-up event (for page up, we'll have to rescan)
static void stb_textedit_find_charpos(StbFindState *find, STB_TEXTEDIT_STRING *str, int n, int single_line)
{
   StbTexteditRow r;
   int prev_start = 0;
   int z = STB_TEXTEDIT_STRINGLEN(str);
   int i=0, first;

   if (n == z) {
      // if it's at the end, then find the last line -- simpler than trying to
      // explicitly handle this case in the regular code
      if (single_line) {
         STB_TEXTEDIT_LAYOUTROW(&r, str, 0);
         find->y = 0;
         find->first_char = 0;
         find->length = z;
         find->height = r.ymax - r.ymin;
         find->x = r.x1;
      } else {
         find->y = 0;
         find->x = 0;
         find->height = 1;
         while (i < z) {
            STB_TEXTEDIT_LAYOUTROW(&r, str, i);
            prev_start = i;
            i += r.num_chars;
         }
         find->first_char = i;
         find->length = 0;
         find->prev_first = prev_start;
      }
      return;
   }

   // search rows to find the one that straddles character n
   find->y = 0;

   for(;;) {
      STB_TEXTEDIT_LAYOUTROW(&r, str, i);
      if (n < i + r.num_chars)
         break;
      prev_start = i;
      i += r.num_chars;
      find->y += r.baseline_y_delta;
   }

   find->first_char = first = i;
   find->length = r.num_chars;
   find->height = r.ymax - r.ymin;
   find->prev_first = prev_start;

   // now scan to find xpos
   find->x = r.x0;
   i = 0;
   for (i=0; first+i < n; ++i)
      find->x += STB_TEXTEDIT_GETWIDTH(str, first, i);
}

#define STB_TEXT_HAS_SELECTION(s)   ((s)->select_start != (s)->select_end)

// make the selection/cursor state valid if client altered the string
static void stb_textedit_clamp(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
{
   int n = STB_TEXTEDIT_STRINGLEN(str);
   if (STB_TEXT_HAS_SELECTION(state)) {
      if (state->select_start > n) state->select_start = n;
      if (state->select_end   > n) state->select_end = n;
      // if clamping forced them to be equal, move the cursor to match
      if (state->select_start == state->select_end)
         state->cursor = state->select_start;
   }
   if (state->cursor > n) state->cursor = n;
}

// delete characters while updating undo
static void stb_textedit_delete(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int len)
{
   stb_text_makeundo_delete(str, state, where, len);
   STB_TEXTEDIT_DELETECHARS(str, where, len);
   state->has_preferred_x = 0;
}

// delete the section
static void stb_textedit_delete_selection(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
{
   stb_textedit_clamp(str, state);
   if (STB_TEXT_HAS_SELECTION(state)) {
      if (state->select_start < state->select_end) {
         stb_textedit_delete(str, state, state->select_start, state->select_end - state->select_start);
         state->select_end = state->cursor = state->select_start;
      } else {
         stb_textedit_delete(str, state, state->select_end, state->select_start - state->select_end);
         state->select_start = state->cursor = state->select_end;
      }
      state->has_preferred_x = 0;
   }
}

// canoncialize the selection so start <= end
static void stb_textedit_sortselection(STB_TexteditState *state)
{
   if (state->select_end < state->select_start) {
      int temp = state->select_end;
      state->select_end = state->select_start;
      state->select_start = temp;
   }
}

// move cursor to first character of selection
static void stb_textedit_move_to_first(STB_TexteditState *state)
{
   if (STB_TEXT_HAS_SELECTION(state)) {
      stb_textedit_sortselection(state);
      state->cursor = state->select_start;
      state->select_end = state->select_start;
      state->has_preferred_x = 0;
   }
}

// move cursor to last character of selection
static void stb_textedit_move_to_last(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
{
   if (STB_TEXT_HAS_SELECTION(state)) {
      stb_textedit_sortselection(state);
      stb_textedit_clamp(str, state);
      state->cursor = state->select_end;
      state->select_start = state->select_end;
      state->has_preferred_x = 0;
   }
}

#ifdef STB_TEXTEDIT_IS_SPACE
static int is_word_boundary( STB_TEXTEDIT_STRING *str, int idx )
{
   return idx > 0 ? (STB_TEXTEDIT_IS_SPACE( STB_TEXTEDIT_GETCHAR(str,idx-1) ) && !STB_TEXTEDIT_IS_SPACE( STB_TEXTEDIT_GETCHAR(str, idx) ) ) : 1;
}

#ifndef STB_TEXTEDIT_MOVEWORDLEFT
static int stb_textedit_move_to_word_previous( STB_TEXTEDIT_STRING *str, int c )
{
   --c; // always move at least one character
   while( c >= 0 && !is_word_boundary( str, c ) )
      --c;

   if( c < 0 )
      c = 0;

   return c;
}
#define STB_TEXTEDIT_MOVEWORDLEFT stb_textedit_move_to_word_previous
#endif

#ifndef STB_TEXTEDIT_MOVEWORDRIGHT
static int stb_textedit_move_to_word_next( STB_TEXTEDIT_STRING *str, int c )
{
   const int len = STB_TEXTEDIT_STRINGLEN(str);
   ++c; // always move at least one character
   while( c < len && !is_word_boundary( str, c ) )
      ++c;

   if( c > len )
      c = len;

   return c;
}
#define STB_TEXTEDIT_MOVEWORDRIGHT stb_textedit_move_to_word_next
#endif

#endif

// update selection and cursor to match each other
static void stb_textedit_prep_selection_at_cursor(STB_TexteditState *state)
{
   if (!STB_TEXT_HAS_SELECTION(state))
      state->select_start = state->select_end = state->cursor;
   else
      state->cursor = state->select_end;
}

// API cut: delete selection
static int stb_textedit_cut(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
{
   if (STB_TEXT_HAS_SELECTION(state)) {
      stb_textedit_delete_selection(str,state); // implicity clamps
      state->has_preferred_x = 0;
      return 1;
   }
   return 0;
}

// API paste: replace existing selection with passed-in text
static int stb_textedit_paste_internal(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE *text, int len)
{
   // if there's a selection, the paste should delete it
   stb_textedit_clamp(str, state);
   stb_textedit_delete_selection(str,state);
   // try to insert the characters
   if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, text, len)) {
      stb_text_makeundo_insert(state, state->cursor, len);
      state->cursor += len;
      state->has_preferred_x = 0;
      return 1;
   }
   // remove the undo since we didn't actually insert the characters
   if (state->undostate.undo_point)
      --state->undostate.undo_point;
   return 0;
}

#ifndef STB_TEXTEDIT_KEYTYPE
#define STB_TEXTEDIT_KEYTYPE int
#endif

// API key: process a keyboard input
static void stb_textedit_key(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_KEYTYPE key)
{
retry:
   switch (key) {
      default: {
         int c = STB_TEXTEDIT_KEYTOTEXT(key);
         if (c > 0) {
            STB_TEXTEDIT_CHARTYPE ch = (STB_TEXTEDIT_CHARTYPE) c;

            // can't add newline in single-line mode
            if (c == '\n' && state->single_line)
               break;

            if (state->insert_mode && !STB_TEXT_HAS_SELECTION(state) && state->cursor < STB_TEXTEDIT_STRINGLEN(str)) {
               stb_text_makeundo_replace(str, state, state->cursor, 1, 1);
               STB_TEXTEDIT_DELETECHARS(str, state->cursor, 1);
               if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, &ch, 1)) {
                  ++state->cursor;
                  state->has_preferred_x = 0;
               }
            } else {
               stb_textedit_delete_selection(str,state); // implicity clamps
               if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, &ch, 1)) {
                  stb_text_makeundo_insert(state, state->cursor, 1);
                  ++state->cursor;
                  state->has_preferred_x = 0;
               }
            }
         }
         break;
      }

#ifdef STB_TEXTEDIT_K_INSERT
      case STB_TEXTEDIT_K_INSERT:
         state->insert_mode = !state->insert_mode;
         break;
#endif
         
      case STB_TEXTEDIT_K_UNDO:
         stb_text_undo(str, state);
         state->has_preferred_x = 0;
         break;

      case STB_TEXTEDIT_K_REDO:
         stb_text_redo(str, state);
         state->has_preferred_x = 0;
         break;

      case STB_TEXTEDIT_K_LEFT:
         // if currently there's a selection, move cursor to start of selection
         if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_move_to_first(state);
         else 
            if (state->cursor > 0)
               --state->cursor;
         state->has_preferred_x = 0;
         break;

      case STB_TEXTEDIT_K_RIGHT:
         // if currently there's a selection, move cursor to end of selection
         if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_move_to_last(str, state);
         else
            ++state->cursor;
         stb_textedit_clamp(str, state);
         state->has_preferred_x = 0;
         break;

      case STB_TEXTEDIT_K_LEFT | STB_TEXTEDIT_K_SHIFT:
         stb_textedit_clamp(str, state);
         stb_textedit_prep_selection_at_cursor(state);
         // move selection left
         if (state->select_end > 0)
            --state->select_end;
         state->cursor = state->select_end;
         state->has_preferred_x = 0;
         break;

#ifdef STB_TEXTEDIT_MOVEWORDLEFT
      case STB_TEXTEDIT_K_WORDLEFT:
         if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_move_to_first(state);
         else {
            state->cursor = STB_TEXTEDIT_MOVEWORDLEFT(str, state->cursor);
            stb_textedit_clamp( str, state );
         }
         break;

      case STB_TEXTEDIT_K_WORDLEFT | STB_TEXTEDIT_K_SHIFT:
         if( !STB_TEXT_HAS_SELECTION( state ) )
            stb_textedit_prep_selection_at_cursor(state);

         state->cursor = STB_TEXTEDIT_MOVEWORDLEFT(str, state->cursor);
         state->select_end = state->cursor;

         stb_textedit_clamp( str, state );
         break;
#endif

#ifdef STB_TEXTEDIT_MOVEWORDRIGHT
      case STB_TEXTEDIT_K_WORDRIGHT:
         if (STB_TEXT_HAS_SELECTION(state)) 
            stb_textedit_move_to_last(str, state);
         else {
            state->cursor = STB_TEXTEDIT_MOVEWORDRIGHT(str, state->cursor);
            stb_textedit_clamp( str, state );
         }
         break;

      case STB_TEXTEDIT_K_WORDRIGHT | STB_TEXTEDIT_K_SHIFT:
         if( !STB_TEXT_HAS_SELECTION( state ) )
            stb_textedit_prep_selection_at_cursor(state);

         state->cursor = STB_TEXTEDIT_MOVEWORDRIGHT(str, state->cursor);
         state->select_end = state->cursor;

         stb_textedit_clamp( str, state );
         break;
#endif

      case STB_TEXTEDIT_K_RIGHT | STB_TEXTEDIT_K_SHIFT:
         stb_textedit_prep_selection_at_cursor(state);
         // move selection right
         ++state->select_end;
         stb_textedit_clamp(str, state);
         state->cursor = state->select_end;
         state->has_preferred_x = 0;
         break;

      case STB_TEXTEDIT_K_DOWN:
      case STB_TEXTEDIT_K_DOWN | STB_TEXTEDIT_K_SHIFT: {
         StbFindState find;
         StbTexteditRow row;
         int i, sel = (key & STB_TEXTEDIT_K_SHIFT) != 0;

         if (state->single_line) {
            // on windows, up&down in single-line behave like left&right
            key = STB_TEXTEDIT_K_RIGHT | (key & STB_TEXTEDIT_K_SHIFT);
            goto retry;
         }

         if (sel)
            stb_textedit_prep_selection_at_cursor(state);
         else if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_move_to_last(str,state);

         // compute current position of cursor point
         stb_textedit_clamp(str, state);
         stb_textedit_find_charpos(&find, str, state->cursor, state->single_line);

         // now find character position down a row
         if (find.length) {
            float goal_x = state->has_preferred_x ? state->preferred_x : find.x;
            float x;
            int start = find.first_char + find.length;
            state->cursor = start;
            STB_TEXTEDIT_LAYOUTROW(&row, str, state->cursor);
            x = row.x0;
            for (i=0; i < row.num_chars; ++i) {
               float dx = STB_TEXTEDIT_GETWIDTH(str, start, i);
               #ifdef STB_TEXTEDIT_GETWIDTH_NEWLINE
               if (dx == STB_TEXTEDIT_GETWIDTH_NEWLINE)
                  break;
               #endif
               x += dx;
               if (x > goal_x)
                  break;
               ++state->cursor;
            }
            stb_textedit_clamp(str, state);

            state->has_preferred_x = 1;
            state->preferred_x = goal_x;

            if (sel)
               state->select_end = state->cursor;
         }
         break;
      }
         
      case STB_TEXTEDIT_K_UP:
      case STB_TEXTEDIT_K_UP | STB_TEXTEDIT_K_SHIFT: {
         StbFindState find;
         StbTexteditRow row;
         int i, sel = (key & STB_TEXTEDIT_K_SHIFT) != 0;

         if (state->single_line) {
            // on windows, up&down become left&right
            key = STB_TEXTEDIT_K_LEFT | (key & STB_TEXTEDIT_K_SHIFT);
            goto retry;
         }

         if (sel)
            stb_textedit_prep_selection_at_cursor(state);
         else if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_move_to_first(state);

         // compute current position of cursor point
         stb_textedit_clamp(str, state);
         stb_textedit_find_charpos(&find, str, state->cursor, state->single_line);

         // can only go up if there's a previous row
         if (find.prev_first != find.first_char) {
            // now find character position up a row
            float goal_x = state->has_preferred_x ? state->preferred_x : find.x;
            float x;
            state->cursor = find.prev_first;
            STB_TEXTEDIT_LAYOUTROW(&row, str, state->cursor);
            x = row.x0;
            for (i=0; i < row.num_chars; ++i) {
               float dx = STB_TEXTEDIT_GETWIDTH(str, find.prev_first, i);
               #ifdef STB_TEXTEDIT_GETWIDTH_NEWLINE
               if (dx == STB_TEXTEDIT_GETWIDTH_NEWLINE)
                  break;
               #endif
               x += dx;
               if (x > goal_x)
                  break;
               ++state->cursor;
            }
            stb_textedit_clamp(str, state);

            state->has_preferred_x = 1;
            state->preferred_x = goal_x;

            if (sel)
               state->select_end = state->cursor;
         }
         break;
      }

      case STB_TEXTEDIT_K_DELETE:
      case STB_TEXTEDIT_K_DELETE | STB_TEXTEDIT_K_SHIFT:
         if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_delete_selection(str, state);
         else {
            int n = STB_TEXTEDIT_STRINGLEN(str);
            if (state->cursor < n)
               stb_textedit_delete(str, state, state->cursor, 1);
         }
         state->has_preferred_x = 0;
         break;

      case STB_TEXTEDIT_K_BACKSPACE:
      case STB_TEXTEDIT_K_BACKSPACE | STB_TEXTEDIT_K_SHIFT:
         if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_delete_selection(str, state);
         else {
            stb_textedit_clamp(str, state);
            if (state->cursor > 0) {
               stb_textedit_delete(str, state, state->cursor-1, 1);
               --state->cursor;
            }
         }
         state->has_preferred_x = 0;
         break;
         
#ifdef STB_TEXTEDIT_K_TEXTSTART2
      case STB_TEXTEDIT_K_TEXTSTART2:
#endif
      case STB_TEXTEDIT_K_TEXTSTART:
         state->cursor = state->select_start = state->select_end = 0;
         state->has_preferred_x = 0;
         break;

#ifdef STB_TEXTEDIT_K_TEXTEND2
      case STB_TEXTEDIT_K_TEXTEND2:
#endif
      case STB_TEXTEDIT_K_TEXTEND:
         state->cursor = STB_TEXTEDIT_STRINGLEN(str);
         state->select_start = state->select_end = 0;
         state->has_preferred_x = 0;
         break;
        
#ifdef STB_TEXTEDIT_K_TEXTSTART2
      case STB_TEXTEDIT_K_TEXTSTART2 | STB_TEXTEDIT_K_SHIFT:
#endif
      case STB_TEXTEDIT_K_TEXTSTART | STB_TEXTEDIT_K_SHIFT:
         stb_textedit_prep_selection_at_cursor(state);
         state->cursor = state->select_end = 0;
         state->has_preferred_x = 0;
         break;

#ifdef STB_TEXTEDIT_K_TEXTEND2
      case STB_TEXTEDIT_K_TEXTEND2 | STB_TEXTEDIT_K_SHIFT:
#endif
      case STB_TEXTEDIT_K_TEXTEND | STB_TEXTEDIT_K_SHIFT:
         stb_textedit_prep_selection_at_cursor(state);
         state->cursor = state->select_end = STB_TEXTEDIT_STRINGLEN(str);
         state->has_preferred_x = 0;
         break;


#ifdef STB_TEXTEDIT_K_LINESTART2
      case STB_TEXTEDIT_K_LINESTART2:
#endif
      case STB_TEXTEDIT_K_LINESTART:
         stb_textedit_clamp(str, state);
         stb_textedit_move_to_first(state);
         if (state->single_line)
            state->cursor = 0;
         else while (state->cursor > 0 && STB_TEXTEDIT_GETCHAR(str, state->cursor-1) != STB_TEXTEDIT_NEWLINE)
            --state->cursor;
         state->has_preferred_x = 0;
         break;

#ifdef STB_TEXTEDIT_K_LINEEND2
      case STB_TEXTEDIT_K_LINEEND2:
#endif
      case STB_TEXTEDIT_K_LINEEND: {
         int n = STB_TEXTEDIT_STRINGLEN(str);
         stb_textedit_clamp(str, state);
         stb_textedit_move_to_first(state);
         if (state->single_line)
             state->cursor = n;
         else while (state->cursor < n && STB_TEXTEDIT_GETCHAR(str, state->cursor) != STB_TEXTEDIT_NEWLINE)
             ++state->cursor;
         state->has_preferred_x = 0;
         break;
      }

#ifdef STB_TEXTEDIT_K_LINESTART2
      case STB_TEXTEDIT_K_LINESTART2 | STB_TEXTEDIT_K_SHIFT:
#endif
      case STB_TEXTEDIT_K_LINESTART | STB_TEXTEDIT_K_SHIFT:
         stb_textedit_clamp(str, state);
         stb_textedit_prep_selection_at_cursor(state);
         if (state->single_line)
            state->cursor = 0;
         else while (state->cursor > 0 && STB_TEXTEDIT_GETCHAR(str, state->cursor-1) != STB_TEXTEDIT_NEWLINE)
            --state->cursor;
         state->select_end = state->cursor;
         state->has_preferred_x = 0;
         break;

#ifdef STB_TEXTEDIT_K_LINEEND2
      case STB_TEXTEDIT_K_LINEEND2 | STB_TEXTEDIT_K_SHIFT:
#endif
      case STB_TEXTEDIT_K_LINEEND | STB_TEXTEDIT_K_SHIFT: {
         int n = STB_TEXTEDIT_STRINGLEN(str);
         stb_textedit_clamp(str, state);
         stb_textedit_prep_selection_at_cursor(state);
         if (state->single_line)
             state->cursor = n;
         else while (state->cursor < n && STB_TEXTEDIT_GETCHAR(str, state->cursor) != STB_TEXTEDIT_NEWLINE)
            ++state->cursor;
         state->select_end = state->cursor;
         state->has_preferred_x = 0;
         break;
      }

// @TODO:
//    STB_TEXTEDIT_K_PGUP      - move cursor up a page
//    STB_TEXTEDIT_K_PGDOWN    - move cursor down a page
   }
}

/////////////////////////////////////////////////////////////////////////////
//
//      Undo processing
//
// @OPTIMIZE: the undo/redo buffer should be circular

static void stb_textedit_flush_redo(StbUndoState *state)
{
   state->redo_point = STB_TEXTEDIT_UNDOSTATECOUNT;
   state->redo_char_point = STB_TEXTEDIT_UNDOCHARCOUNT;
}

// discard the oldest entry in the undo list
static void stb_textedit_discard_undo(StbUndoState *state)
{
   if (state->undo_point > 0) {
      // if the 0th undo state has characters, clean those up
      if (state->undo_rec[0].char_storage >= 0) {
         int n = state->undo_rec[0].insert_length, i;
         // delete n characters from all other records
         state->undo_char_point -= n;
         STB_TEXTEDIT_memmove(state->undo_char, state->undo_char + n, (size_t) (state->undo_char_point*sizeof(STB_TEXTEDIT_CHARTYPE)));
         for (i=0; i < state->undo_point; ++i)
            if (state->undo_rec[i].char_storage >= 0)
               state->undo_rec[i].char_storage -= n; // @OPTIMIZE: get rid of char_storage and infer it
      }
      --state->undo_point;
      STB_TEXTEDIT_memmove(state->undo_rec, state->undo_rec+1, (size_t) (state->undo_point*sizeof(state->undo_rec[0])));
   }
}

// discard the oldest entry in the redo list--it's bad if this
// ever happens, but because undo & redo have to store the actual
// characters in different cases, the redo character buffer can
// fill up even though the undo buffer didn't
static void stb_textedit_discard_redo(StbUndoState *state)
{
   int k = STB_TEXTEDIT_UNDOSTATECOUNT-1;

   if (state->redo_point <= k) {
      // if the k'th undo state has characters, clean those up
      if (state->undo_rec[k].char_storage >= 0) {
         int n = state->undo_rec[k].insert_length, i;
         // move the remaining redo character data to the end of the buffer
         state->redo_char_point += n;
         STB_TEXTEDIT_memmove(state->undo_char + state->redo_char_point, state->undo_char + state->redo_char_point-n, (size_t) ((STB_TEXTEDIT_UNDOCHARCOUNT - state->redo_char_point)*sizeof(STB_TEXTEDIT_CHARTYPE)));
         // adjust the position of all the other records to account for above memmove
         for (i=state->redo_point; i < k; ++i)
            if (state->undo_rec[i].char_storage >= 0)
               state->undo_rec[i].char_storage += n;
      }
      // now move all the redo records towards the end of the buffer; the first one is at 'redo_point'
      STB_TEXTEDIT_memmove(state->undo_rec + state->redo_point+1, state->undo_rec + state->redo_point, (size_t) ((STB_TEXTEDIT_UNDOSTATECOUNT - state->redo_point)*sizeof(state->undo_rec[0])));
      // now move redo_point to point to the new one
      ++state->redo_point;
   }
}

static StbUndoRecord *stb_text_create_undo_record(StbUndoState *state, int numchars)
{
   // any time we create a new undo record, we discard redo
   stb_textedit_flush_redo(state);

   // if we have no free records, we have to make room, by sliding the
   // existing records down
   if (state->undo_point == STB_TEXTEDIT_UNDOSTATECOUNT)
      stb_textedit_discard_undo(state);

   // if the characters to store won't possibly fit in the buffer, we can't undo
   if (numchars > STB_TEXTEDIT_UNDOCHARCOUNT) {
      state->undo_point = 0;
      state->undo_char_point = 0;
      return NULL;
   }

   // if we don't have enough free characters in the buffer, we have to make room
   while (state->undo_char_point + numchars > STB_TEXTEDIT_UNDOCHARCOUNT)
      stb_textedit_discard_undo(state);

   return &state->undo_rec[state->undo_point++];
}

static STB_TEXTEDIT_CHARTYPE *stb_text_createundo(StbUndoState *state, int pos, int insert_len, int delete_len)
{
   StbUndoRecord *r = stb_text_create_undo_record(state, insert_len);
   if (r == NULL)
      return NULL;

   r->where = pos;
   r->insert_length = (STB_TEXTEDIT_POSITIONTYPE) insert_len;
   r->delete_length = (STB_TEXTEDIT_POSITIONTYPE) delete_len;

   if (insert_len == 0) {
      r->char_storage = -1;
      return NULL;
   } else {
      r->char_storage = state->undo_char_point;
      state->undo_char_point += insert_len;
      return &state->undo_char[r->char_storage];
   }
}

static void stb_text_undo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
{
   StbUndoState *s = &state->undostate;
   StbUndoRecord u, *r;
   if (s->undo_point == 0)
      return;

   // we need to do two things: apply the undo record, and create a redo record
   u = s->undo_rec[s->undo_point-1];
   r = &s->undo_rec[s->redo_point-1];
   r->char_storage = -1;

   r->insert_length = u.delete_length;
   r->delete_length = u.insert_length;
   r->where = u.where;

   if (u.delete_length) {
      // if the undo record says to delete characters, then the redo record will
      // need to re-insert the characters that get deleted, so we need to store
      // them.

      // there are three cases:
      //    there's enough room to store the characters
      //    characters stored for *redoing* don't leave room for redo
      //    characters stored for *undoing* don't leave room for redo
      // if the last is true, we have to bail

      if (s->undo_char_point + u.delete_length >= STB_TEXTEDIT_UNDOCHARCOUNT) {
         // the undo records take up too much character space; there's no space to store the redo characters
         r->insert_length = 0;
      } else {
         int i;

         // there's definitely room to store the characters eventually
         while (s->undo_char_point + u.delete_length > s->redo_char_point) {
            // should never happen:
            if (s->redo_point == STB_TEXTEDIT_UNDOSTATECOUNT)
               return;
            // there's currently not enough room, so discard a redo record
            stb_textedit_discard_redo(s);
         }
         r = &s->undo_rec[s->redo_point-1];

         r->char_storage = s->redo_char_point - u.delete_length;
         s->redo_char_point = s->redo_char_point - u.delete_length;

         // now save the characters
         for (i=0; i < u.delete_length; ++i)
            s->undo_char[r->char_storage + i] = STB_TEXTEDIT_GETCHAR(str, u.where + i);
      }

      // now we can carry out the deletion
      STB_TEXTEDIT_DELETECHARS(str, u.where, u.delete_length);
   }

   // check type of recorded action:
   if (u.insert_length) {
      // easy case: was a deletion, so we need to insert n characters
      STB_TEXTEDIT_INSERTCHARS(str, u.where, &s->undo_char[u.char_storage], u.insert_length);
      s->undo_char_point -= u.insert_length;
   }

   state->cursor = u.where + u.insert_length;

   s->undo_point--;
   s->redo_point--;
}

static void stb_text_redo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
{
   StbUndoState *s = &state->undostate;
   StbUndoRecord *u, r;
   if (s->redo_point == STB_TEXTEDIT_UNDOSTATECOUNT)
      return;

   // we need to do two things: apply the redo record, and create an undo record
   u = &s->undo_rec[s->undo_point];
   r = s->undo_rec[s->redo_point];

   // we KNOW there must be room for the undo record, because the redo record
   // was derived from an undo record

   u->delete_length = r.insert_length;
   u->insert_length = r.delete_length;
   u->where = r.where;
   u->char_storage = -1;

   if (r.delete_length) {
      // the redo record requires us to delete characters, so the undo record
      // needs to store the characters

      if (s->undo_char_point + u->insert_length > s->redo_char_point) {
         u->insert_length = 0;
         u->delete_length = 0;
      } else {
         int i;
         u->char_storage = s->undo_char_point;
         s->undo_char_point = s->undo_char_point + u->insert_length;

         // now save the characters
         for (i=0; i < u->insert_length; ++i)
            s->undo_char[u->char_storage + i] = STB_TEXTEDIT_GETCHAR(str, u->where + i);
      }

      STB_TEXTEDIT_DELETECHARS(str, r.where, r.delete_length);
   }

   if (r.insert_length) {
      // easy case: need to insert n characters
      STB_TEXTEDIT_INSERTCHARS(str, r.where, &s->undo_char[r.char_storage], r.insert_length);
      s->redo_char_point += r.insert_length;
   }

   state->cursor = r.where + r.insert_length;

   s->undo_point++;
   s->redo_point++;
}

static void stb_text_makeundo_insert(STB_TexteditState *state, int where, int length)
{
   stb_text_createundo(&state->undostate, where, 0, length);
}

static void stb_text_makeundo_delete(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int length)
{
   int i;
   STB_TEXTEDIT_CHARTYPE *p = stb_text_createundo(&state->undostate, where, length, 0);
   if (p) {
      for (i=0; i < length; ++i)
         p[i] = STB_TEXTEDIT_GETCHAR(str, where+i);
   }
}

static void stb_text_makeundo_replace(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int old_length, int new_length)
{
   int i;
   STB_TEXTEDIT_CHARTYPE *p = stb_text_createundo(&state->undostate, where, old_length, new_length);
   if (p) {
      for (i=0; i < old_length; ++i)
         p[i] = STB_TEXTEDIT_GETCHAR(str, where+i);
   }
}

// reset the state to default
static void stb_textedit_clear_state(STB_TexteditState *state, int is_single_line)
{
   state->undostate.undo_point = 0;
   state->undostate.undo_char_point = 0;
   state->undostate.redo_point = STB_TEXTEDIT_UNDOSTATECOUNT;
   state->undostate.redo_char_point = STB_TEXTEDIT_UNDOCHARCOUNT;
   state->select_end = state->select_start = 0;
   state->cursor = 0;
   state->has_preferred_x = 0;
   state->preferred_x = 0;
   state->cursor_at_end_of_line = 0;
   state->initialized = 1;
   state->single_line = (unsigned char) is_single_line;
   state->insert_mode = 0;
}

// API initialize
static void stb_textedit_initialize_state(STB_TexteditState *state, int is_single_line)
{
   stb_textedit_clear_state(state, is_single_line);
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wcast-qual"
#endif

static int stb_textedit_paste(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE const *ctext, int len)
{
   return stb_textedit_paste_internal(str, state, (STB_TEXTEDIT_CHARTYPE *) ctext, len);
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif

#endif//STB_TEXTEDIT_IMPLEMENTATION

/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of 
this software and associated documentation files (the "Software"), to deal in 
the Software without restriction, including without limitation the rights to 
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies 
of the Software, and to permit persons to whom the Software is furnished to do 
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all 
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this 
software, either in source code form or as a compiled binary, for any purpose, 
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this 
software dedicate any and all copyright interest in the software to the public 
domain. We make this dedication for the benefit of the public at large and to 
the detriment of our heirs and successors. We intend this dedication to be an 
overt act of relinquishment in perpetuity of all present and future rights to 
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN 
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/

```

`UnrealFinderTool/ImGUI/imstb_truetype.h`:

```h
// stb_truetype.h - v1.19 - public domain
// authored from 2009-2016 by Sean Barrett / RAD Game Tools
//
//   This library processes TrueType files:
//        parse files
//        extract glyph metrics
//        extract glyph shapes
//        render glyphs to one-channel bitmaps with antialiasing (box filter)
//        render glyphs to one-channel SDF bitmaps (signed-distance field/function)
//
//   Todo:
//        non-MS cmaps
//        crashproof on bad data
//        hinting? (no longer patented)
//        cleartype-style AA?
//        optimize: use simple memory allocator for intermediates
//        optimize: build edge-list directly from curves
//        optimize: rasterize directly from curves?
//
// ADDITIONAL CONTRIBUTORS
//
//   Mikko Mononen: compound shape support, more cmap formats
//   Tor Andersson: kerning, subpixel rendering
//   Dougall Johnson: OpenType / Type 2 font handling
//   Daniel Ribeiro Maciel: basic GPOS-based kerning
//
//   Misc other:
//       Ryan Gordon
//       Simon Glass
//       github:IntellectualKitty
//       Imanol Celaya
//       Daniel Ribeiro Maciel
//
//   Bug/warning reports/fixes:
//       "Zer" on mollyrocket       Fabian "ryg" Giesen
//       Cass Everitt               Martins Mozeiko
//       stoiko (Haemimont Games)   Cap Petschulat
//       Brian Hook                 Omar Cornut
//       Walter van Niftrik         github:aloucks
//       David Gow                  Peter LaValle
//       David Given                Sergey Popov
//       Ivan-Assen Ivanov          Giumo X. Clanjor
//       Anthony Pesch              Higor Euripedes
//       Johan Duparc               Thomas Fields
//       Hou Qiming                 Derek Vinyard
//       Rob Loach                  Cort Stratton
//       Kenney Phillis Jr.         github:oyvindjam
//       Brian Costabile            github:vassvik
//       
// VERSION HISTORY
//
//   1.19 (2018-02-11) GPOS kerning, STBTT_fmod
//   1.18 (2018-01-29) add missing function
//   1.17 (2017-07-23) make more arguments const; doc fix
//   1.16 (2017-07-12) SDF support
//   1.15 (2017-03-03) make more arguments const
//   1.14 (2017-01-16) num-fonts-in-TTC function
//   1.13 (2017-01-02) support OpenType fonts, certain Apple fonts
//   1.12 (2016-10-25) suppress warnings about casting away const with -Wcast-qual
//   1.11 (2016-04-02) fix unused-variable warning
//   1.10 (2016-04-02) user-defined fabs(); rare memory leak; remove duplicate typedef
//   1.09 (2016-01-16) warning fix; avoid crash on outofmem; use allocation userdata properly
//   1.08 (2015-09-13) document stbtt_Rasterize(); fixes for vertical & horizontal edges
//   1.07 (2015-08-01) allow PackFontRanges to accept arrays of sparse codepoints;
//                     variant PackFontRanges to pack and render in separate phases;
//                     fix stbtt_GetFontOFfsetForIndex (never worked for non-0 input?);
//                     fixed an assert() bug in the new rasterizer
//                     replace assert() with STBTT_assert() in new rasterizer
//
//   Full history can be found at the end of this file.
//
// LICENSE
//
//   See end of file for license information.
//
// USAGE
//
//   Include this file in whatever places neeed to refer to it. In ONE C/C++
//   file, write:
//      #define STB_TRUETYPE_IMPLEMENTATION
//   before the #include of this file. This expands out the actual
//   implementation into that C/C++ file.
//
//   To make the implementation private to the file that generates the implementation,
//      #define STBTT_STATIC
//
//   Simple 3D API (don't ship this, but it's fine for tools and quick start)
//           stbtt_BakeFontBitmap()               -- bake a font to a bitmap for use as texture
//           stbtt_GetBakedQuad()                 -- compute quad to draw for a given char
//
//   Improved 3D API (more shippable):
//           #include "stb_rect_pack.h"           -- optional, but you really want it
//           stbtt_PackBegin()
//           stbtt_PackSetOversampling()          -- for improved quality on small fonts
//           stbtt_PackFontRanges()               -- pack and renders
//           stbtt_PackEnd()
//           stbtt_GetPackedQuad()
//
//   "Load" a font file from a memory buffer (you have to keep the buffer loaded)
//           stbtt_InitFont()
//           stbtt_GetFontOffsetForIndex()        -- indexing for TTC font collections
//           stbtt_GetNumberOfFonts()             -- number of fonts for TTC font collections
//
//   Render a unicode codepoint to a bitmap
//           stbtt_GetCodepointBitmap()           -- allocates and returns a bitmap
//           stbtt_MakeCodepointBitmap()          -- renders into bitmap you provide
//           stbtt_GetCodepointBitmapBox()        -- how big the bitmap must be
//
//   Character advance/positioning
//           stbtt_GetCodepointHMetrics()
//           stbtt_GetFontVMetrics()
//           stbtt_GetFontVMetricsOS2()
//           stbtt_GetCodepointKernAdvance()
//
//   Starting with version 1.06, the rasterizer was replaced with a new,
//   faster and generally-more-precise rasterizer. The new rasterizer more
//   accurately measures pixel coverage for anti-aliasing, except in the case
//   where multiple shapes overlap, in which case it overestimates the AA pixel
//   coverage. Thus, anti-aliasing of intersecting shapes may look wrong. If
//   this turns out to be a problem, you can re-enable the old rasterizer with
//        #define STBTT_RASTERIZER_VERSION 1
//   which will incur about a 15% speed hit.
//
// ADDITIONAL DOCUMENTATION
//
//   Immediately after this block comment are a series of sample programs.
//
//   After the sample programs is the "header file" section. This section
//   includes documentation for each API function.
//
//   Some important concepts to understand to use this library:
//
//      Codepoint
//         Characters are defined by unicode codepoints, e.g. 65 is
//         uppercase A, 231 is lowercase c with a cedilla, 0x7e30 is
//         the hiragana for "ma".
//
//      Glyph
//         A visual character shape (every codepoint is rendered as
//         some glyph)
//
//      Glyph index
//         A font-specific integer ID representing a glyph
//
//      Baseline
//         Glyph shapes are defined relative to a baseline, which is the
//         bottom of uppercase characters. Characters extend both above
//         and below the baseline.
//
//      Current Point
//         As you draw text to the screen, you keep track of a "current point"
//         which is the origin of each character. The current point's vertical
//         position is the baseline. Even "baked fonts" use this model.
//
//      Vertical Font Metrics
//         The vertical qualities of the font, used to vertically position
//         and space the characters. See docs for stbtt_GetFontVMetrics.
//
//      Font Size in Pixels or Points
//         The preferred interface for specifying font sizes in stb_truetype
//         is to specify how tall the font's vertical extent should be in pixels.
//         If that sounds good enough, skip the next paragraph.
//
//         Most font APIs instead use "points", which are a common typographic
//         measurement for describing font size, defined as 72 points per inch.
//         stb_truetype provides a point API for compatibility. However, true
//         "per inch" conventions don't make much sense on computer displays
//         since different monitors have different number of pixels per
//         inch. For example, Windows traditionally uses a convention that
//         there are 96 pixels per inch, thus making 'inch' measurements have
//         nothing to do with inches, and thus effectively defining a point to
//         be 1.333 pixels. Additionally, the TrueType font data provides
//         an explicit scale factor to scale a given font's glyphs to points,
//         but the author has observed that this scale factor is often wrong
//         for non-commercial fonts, thus making fonts scaled in points
//         according to the TrueType spec incoherently sized in practice.
//
// DETAILED USAGE:
//
//  Scale:
//    Select how high you want the font to be, in points or pixels.
//    Call ScaleForPixelHeight or ScaleForMappingEmToPixels to compute
//    a scale factor SF that will be used by all other functions.
//
//  Baseline:
//    You need to select a y-coordinate that is the baseline of where
//    your text will appear. Call GetFontBoundingBox to get the baseline-relative
//    bounding box for all characters. SF*-y0 will be the distance in pixels
//    that the worst-case character could extend above the baseline, so if
//    you want the top edge of characters to appear at the top of the
//    screen where y=0, then you would set the baseline to SF*-y0.
//
//  Current point:
//    Set the current point where the first character will appear. The
//    first character could extend left of the current point; this is font
//    dependent. You can either choose a current point that is the leftmost
//    point and hope, or add some padding, or check the bounding box or
//    left-side-bearing of the first character to be displayed and set
//    the current point based on that.
//
//  Displaying a character:
//    Compute the bounding box of the character. It will contain signed values
//    relative to <current_point, baseline>. I.e. if it returns x0,y0,x1,y1,
//    then the character should be displayed in the rectangle from
//    <current_point+SF*x0, baseline+SF*y0> to <current_point+SF*x1,baseline+SF*y1).
//
//  Advancing for the next character:
//    Call GlyphHMetrics, and compute 'current_point += SF * advance'.
// 
//
// ADVANCED USAGE
//
//   Quality:
//
//    - Use the functions with Subpixel at the end to allow your characters
//      to have subpixel positioning. Since the font is anti-aliased, not
//      hinted, this is very import for quality. (This is not possible with
//      baked fonts.)
//
//    - Kerning is now supported, and if you're supporting subpixel rendering
//      then kerning is worth using to give your text a polished look.
//
//   Performance:
//
//    - Convert Unicode codepoints to glyph indexes and operate on the glyphs;
//      if you don't do this, stb_truetype is forced to do the conversion on
//      every call.
//
//    - There are a lot of memory allocations. We should modify it to take
//      a temp buffer and allocate from the temp buffer (without freeing),
//      should help performance a lot.
//
// NOTES
//
//   The system uses the raw data found in the .ttf file without changing it
//   and without building auxiliary data structures. This is a bit inefficient
//   on little-endian systems (the data is big-endian), but assuming you're
//   caching the bitmaps or glyph shapes this shouldn't be a big deal.
//
//   It appears to be very hard to programmatically determine what font a
//   given file is in a general way. I provide an API for this, but I don't
//   recommend it.
//
//
// SOURCE STATISTICS (based on v0.6c, 2050 LOC)
//
//   Documentation & header file        520 LOC  \___ 660 LOC documentation
//   Sample code                        140 LOC  /
//   Truetype parsing                   620 LOC  ---- 620 LOC TrueType
//   Software rasterization             240 LOC  \                           .
//   Curve tesselation                  120 LOC   \__ 550 LOC Bitmap creation
//   Bitmap management                  100 LOC   /
//   Baked bitmap interface              70 LOC  /
//   Font name matching & access        150 LOC  ---- 150 
//   C runtime library abstraction       60 LOC  ----  60
//
//
// PERFORMANCE MEASUREMENTS FOR 1.06:
//
//                      32-bit     64-bit
//   Previous release:  8.83 s     7.68 s
//   Pool allocations:  7.72 s     6.34 s
//   Inline sort     :  6.54 s     5.65 s
//   New rasterizer  :  5.63 s     5.00 s

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
////
////  SAMPLE PROGRAMS
////
//
//  Incomplete text-in-3d-api example, which draws quads properly aligned to be lossless
//
#if 0
#define STB_TRUETYPE_IMPLEMENTATION  // force following include to generate implementation
#include "stb_truetype.h"

unsigned char ttf_buffer[1<<20];
unsigned char temp_bitmap[512*512];

stbtt_bakedchar cdata[96]; // ASCII 32..126 is 95 glyphs
GLuint ftex;

void my_stbtt_initfont(void)
{
   fread(ttf_buffer, 1, 1<<20, fopen("c:/windows/fonts/times.ttf", "rb"));
   stbtt_BakeFontBitmap(ttf_buffer,0, 32.0, temp_bitmap,512,512, 32,96, cdata); // no guarantee this fits!
   // can free ttf_buffer at this point
   glGenTextures(1, &ftex);
   glBindTexture(GL_TEXTURE_2D, ftex);
   glTexImage2D(GL_TEXTURE_2D, 0, GL_ALPHA, 512,512, 0, GL_ALPHA, GL_UNSIGNED_BYTE, temp_bitmap);
   // can free temp_bitmap at this point
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
}

void my_stbtt_print(float x, float y, char *text)
{
   // assume orthographic projection with units = screen pixels, origin at top left
   glEnable(GL_TEXTURE_2D);
   glBindTexture(GL_TEXTURE_2D, ftex);
   glBegin(GL_QUADS);
   while (*text) {
      if (*text >= 32 && *text < 128) {
         stbtt_aligned_quad q;
         stbtt_GetBakedQuad(cdata, 512,512, *text-32, &x,&y,&q,1);//1=opengl & d3d10+,0=d3d9
         glTexCoord2f(q.s0,q.t1); glVertex2f(q.x0,q.y0);
         glTexCoord2f(q.s1,q.t1); glVertex2f(q.x1,q.y0);
         glTexCoord2f(q.s1,q.t0); glVertex2f(q.x1,q.y1);
         glTexCoord2f(q.s0,q.t0); glVertex2f(q.x0,q.y1);
      }
      ++text;
   }
   glEnd();
}
#endif
//
//
//////////////////////////////////////////////////////////////////////////////
//
// Complete program (this compiles): get a single bitmap, print as ASCII art
//
#if 0
#include <stdio.h>
#define STB_TRUETYPE_IMPLEMENTATION  // force following include to generate implementation
#include "stb_truetype.h"

char ttf_buffer[1<<25];

int main(int argc, char **argv)
{
   stbtt_fontinfo font;
   unsigned char *bitmap;
   int w,h,i,j,c = (argc > 1 ? atoi(argv[1]) : 'a'), s = (argc > 2 ? atoi(argv[2]) : 20);

   fread(ttf_buffer, 1, 1<<25, fopen(argc > 3 ? argv[3] : "c:/windows/fonts/arialbd.ttf", "rb"));

   stbtt_InitFont(&font, ttf_buffer, stbtt_GetFontOffsetForIndex(ttf_buffer,0));
   bitmap = stbtt_GetCodepointBitmap(&font, 0,stbtt_ScaleForPixelHeight(&font, s), c, &w, &h, 0,0);

   for (j=0; j < h; ++j) {
      for (i=0; i < w; ++i)
         putchar(" .:ioVM@"[bitmap[j*w+i]>>5]);
      putchar('\n');
   }
   return 0;
}
#endif 
//
// Output:
//
//     .ii.
//    @@@@@@.
//   V@Mio@@o
//   :i.  V@V
//     :oM@@M
//   :@@@MM@M
//   @@o  o@M
//  :@@.  M@M
//   @@@o@@@@
//   :M@@V:@@.
//  
//////////////////////////////////////////////////////////////////////////////
// 
// Complete program: print "Hello World!" banner, with bugs
//
#if 0
char buffer[24<<20];
unsigned char screen[20][79];

int main(int arg, char **argv)
{
   stbtt_fontinfo font;
   int i,j,ascent,baseline,ch=0;
   float scale, xpos=2; // leave a little padding in case the character extends left
   char *text = "Heljo World!"; // intentionally misspelled to show 'lj' brokenness

   fread(buffer, 1, 1000000, fopen("c:/windows/fonts/arialbd.ttf", "rb"));
   stbtt_InitFont(&font, buffer, 0);

   scale = stbtt_ScaleForPixelHeight(&font, 15);
   stbtt_GetFontVMetrics(&font, &ascent,0,0);
   baseline = (int) (ascent*scale);

   while (text[ch]) {
      int advance,lsb,x0,y0,x1,y1;
      float x_shift = xpos - (float) floor(xpos);
      stbtt_GetCodepointHMetrics(&font, text[ch], &advance, &lsb);
      stbtt_GetCodepointBitmapBoxSubpixel(&font, text[ch], scale,scale,x_shift,0, &x0,&y0,&x1,&y1);
      stbtt_MakeCodepointBitmapSubpixel(&font, &screen[baseline + y0][(int) xpos + x0], x1-x0,y1-y0, 79, scale,scale,x_shift,0, text[ch]);
      // note that this stomps the old data, so where character boxes overlap (e.g. 'lj') it's wrong
      // because this API is really for baking character bitmaps into textures. if you want to render
      // a sequence of characters, you really need to render each bitmap to a temp buffer, then
      // "alpha blend" that into the working buffer
      xpos += (advance * scale);
      if (text[ch+1])
         xpos += scale*stbtt_GetCodepointKernAdvance(&font, text[ch],text[ch+1]);
      ++ch;
   }

   for (j=0; j < 20; ++j) {
      for (i=0; i < 78; ++i)
         putchar(" .:ioVM@"[screen[j][i]>>5]);
      putchar('\n');
   }

   return 0;
}
#endif


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
////
////   INTEGRATION WITH YOUR CODEBASE
////
////   The following sections allow you to supply alternate definitions
////   of C library functions used by stb_truetype, e.g. if you don't
////   link with the C runtime library.

#ifdef STB_TRUETYPE_IMPLEMENTATION
   // #define your own (u)stbtt_int8/16/32 before including to override this
   #ifndef stbtt_uint8
   typedef unsigned char   stbtt_uint8;
   typedef signed   char   stbtt_int8;
   typedef unsigned short  stbtt_uint16;
   typedef signed   short  stbtt_int16;
   typedef unsigned int    stbtt_uint32;
   typedef signed   int    stbtt_int32;
   #endif

   typedef char stbtt__check_size32[sizeof(stbtt_int32)==4 ? 1 : -1];
   typedef char stbtt__check_size16[sizeof(stbtt_int16)==2 ? 1 : -1];

   // e.g. #define your own STBTT_ifloor/STBTT_iceil() to avoid math.h
   #ifndef STBTT_ifloor
   #include <math.h>
   #define STBTT_ifloor(x)   ((int) floor(x))
   #define STBTT_iceil(x)    ((int) ceil(x))
   #endif

   #ifndef STBTT_sqrt
   #include <math.h>
   #define STBTT_sqrt(x)      sqrt(x)
   #define STBTT_pow(x,y)     pow(x,y)
   #endif

   #ifndef STBTT_fmod
   #include <math.h>
   #define STBTT_fmod(x,y)    fmod(x,y)
   #endif

   #ifndef STBTT_cos
   #include <math.h>
   #define STBTT_cos(x)       cos(x)
   #define STBTT_acos(x)      acos(x)
   #endif

   #ifndef STBTT_fabs
   #include <math.h>
   #define STBTT_fabs(x)      fabs(x)
   #endif

   // #define your own functions "STBTT_malloc" / "STBTT_free" to avoid malloc.h
   #ifndef STBTT_malloc
   #include <stdlib.h>
   #define STBTT_malloc(x,u)  ((void)(u),malloc(x))
   #define STBTT_free(x,u)    ((void)(u),free(x))
   #endif

   #ifndef STBTT_assert
   #include <assert.h>
   #define STBTT_assert(x)    assert(x)
   #endif

   #ifndef STBTT_strlen
   #include <string.h>
   #define STBTT_strlen(x)    strlen(x)
   #endif

   #ifndef STBTT_memcpy
   #include <string.h>
   #define STBTT_memcpy       memcpy
   #define STBTT_memset       memset
   #endif
#endif

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
////
////   INTERFACE
////
////

#ifndef __STB_INCLUDE_STB_TRUETYPE_H__
#define __STB_INCLUDE_STB_TRUETYPE_H__

#ifdef STBTT_STATIC
#define STBTT_DEF static
#else
#define STBTT_DEF extern
#endif

#ifdef __cplusplus
extern "C" {
#endif

// private structure
typedef struct
{
   unsigned char *data;
   int cursor;
   int size;
} stbtt__buf;

//////////////////////////////////////////////////////////////////////////////
//
// TEXTURE BAKING API
//
// If you use this API, you only have to call two functions ever.
//

typedef struct
{
   unsigned short x0,y0,x1,y1; // coordinates of bbox in bitmap
   float xoff,yoff,xadvance;
} stbtt_bakedchar;

STBTT_DEF int stbtt_BakeFontBitmap(const unsigned char *data, int offset,  // font location (use offset=0 for plain .ttf)
                                float pixel_height,                     // height of font in pixels
                                unsigned char *pixels, int pw, int ph,  // bitmap to be filled in
                                int first_char, int num_chars,          // characters to bake
                                stbtt_bakedchar *chardata);             // you allocate this, it's num_chars long
// if return is positive, the first unused row of the bitmap
// if return is negative, returns the negative of the number of characters that fit
// if return is 0, no characters fit and no rows were used
// This uses a very crappy packing.

typedef struct
{
   float x0,y0,s0,t0; // top-left
   float x1,y1,s1,t1; // bottom-right
} stbtt_aligned_quad;

STBTT_DEF void stbtt_GetBakedQuad(const stbtt_bakedchar *chardata, int pw, int ph,  // same data as above
                               int char_index,             // character to display
                               float *xpos, float *ypos,   // pointers to current position in screen pixel space
                               stbtt_aligned_quad *q,      // output: quad to draw
                               int opengl_fillrule);       // true if opengl fill rule; false if DX9 or earlier
// Call GetBakedQuad with char_index = 'character - first_char', and it
// creates the quad you need to draw and advances the current position.
//
// The coordinate system used assumes y increases downwards.
//
// Characters will extend both above and below the current position;
// see discussion of "BASELINE" above.
//
// It's inefficient; you might want to c&p it and optimize it.



//////////////////////////////////////////////////////////////////////////////
//
// NEW TEXTURE BAKING API
//
// This provides options for packing multiple fonts into one atlas, not
// perfectly but better than nothing.

typedef struct
{
   unsigned short x0,y0,x1,y1; // coordinates of bbox in bitmap
   float xoff,yoff,xadvance;
   float xoff2,yoff2;
} stbtt_packedchar;

typedef struct stbtt_pack_context stbtt_pack_context;
typedef struct stbtt_fontinfo stbtt_fontinfo;
#ifndef STB_RECT_PACK_VERSION
typedef struct stbrp_rect stbrp_rect;
#endif

STBTT_DEF int  stbtt_PackBegin(stbtt_pack_context *spc, unsigned char *pixels, int width, int height, int stride_in_bytes, int padding, void *alloc_context);
// Initializes a packing context stored in the passed-in stbtt_pack_context.
// Future calls using this context will pack characters into the bitmap passed
// in here: a 1-channel bitmap that is width * height. stride_in_bytes is
// the distance from one row to the next (or 0 to mean they are packed tightly
// together). "padding" is the amount of padding to leave between each
// character (normally you want '1' for bitmaps you'll use as textures with
// bilinear filtering).
//
// Returns 0 on failure, 1 on success.

STBTT_DEF void stbtt_PackEnd  (stbtt_pack_context *spc);
// Cleans up the packing context and frees all memory.

#define STBTT_POINT_SIZE(x)   (-(x))

STBTT_DEF int  stbtt_PackFontRange(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, float font_size,
                                int first_unicode_char_in_range, int num_chars_in_range, stbtt_packedchar *chardata_for_range);
// Creates character bitmaps from the font_index'th font found in fontdata (use
// font_index=0 if you don't know what that is). It creates num_chars_in_range
// bitmaps for characters with unicode values starting at first_unicode_char_in_range
// and increasing. Data for how to render them is stored in chardata_for_range;
// pass these to stbtt_GetPackedQuad to get back renderable quads.
//
// font_size is the full height of the character from ascender to descender,
// as computed by stbtt_ScaleForPixelHeight. To use a point size as computed
// by stbtt_ScaleForMappingEmToPixels, wrap the point size in STBTT_POINT_SIZE()
// and pass that result as 'font_size':
//       ...,                  20 , ... // font max minus min y is 20 pixels tall
//       ..., STBTT_POINT_SIZE(20), ... // 'M' is 20 pixels tall

typedef struct
{
   float font_size;
   int first_unicode_codepoint_in_range;  // if non-zero, then the chars are continuous, and this is the first codepoint
   int *array_of_unicode_codepoints;       // if non-zero, then this is an array of unicode codepoints
   int num_chars;
   stbtt_packedchar *chardata_for_range; // output
   unsigned char h_oversample, v_oversample; // don't set these, they're used internally
} stbtt_pack_range;

STBTT_DEF int  stbtt_PackFontRanges(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges);
// Creates character bitmaps from multiple ranges of characters stored in
// ranges. This will usually create a better-packed bitmap than multiple
// calls to stbtt_PackFontRange. Note that you can call this multiple
// times within a single PackBegin/PackEnd.

STBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample);
// Oversampling a font increases the quality by allowing higher-quality subpixel
// positioning, and is especially valuable at smaller text sizes.
//
// This function sets the amount of oversampling for all following calls to
// stbtt_PackFontRange(s) or stbtt_PackFontRangesGatherRects for a given
// pack context. The default (no oversampling) is achieved by h_oversample=1
// and v_oversample=1. The total number of pixels required is
// h_oversample*v_oversample larger than the default; for example, 2x2
// oversampling requires 4x the storage of 1x1. For best results, render
// oversampled textures with bilinear filtering. Look at the readme in
// stb/tests/oversample for information about oversampled fonts
//
// To use with PackFontRangesGather etc., you must set it before calls
// call to PackFontRangesGatherRects.

STBTT_DEF void stbtt_GetPackedQuad(const stbtt_packedchar *chardata, int pw, int ph,  // same data as above
                               int char_index,             // character to display
                               float *xpos, float *ypos,   // pointers to current position in screen pixel space
                               stbtt_aligned_quad *q,      // output: quad to draw
                               int align_to_integer);

STBTT_DEF int  stbtt_PackFontRangesGatherRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects);
STBTT_DEF void stbtt_PackFontRangesPackRects(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects);
STBTT_DEF int  stbtt_PackFontRangesRenderIntoRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects);
// Calling these functions in sequence is roughly equivalent to calling
// stbtt_PackFontRanges(). If you more control over the packing of multiple
// fonts, or if you want to pack custom data into a font texture, take a look
// at the source to of stbtt_PackFontRanges() and create a custom version 
// using these functions, e.g. call GatherRects multiple times,
// building up a single array of rects, then call PackRects once,
// then call RenderIntoRects repeatedly. This may result in a
// better packing than calling PackFontRanges multiple times
// (or it may not).

// this is an opaque structure that you shouldn't mess with which holds
// all the context needed from PackBegin to PackEnd.
struct stbtt_pack_context {
   void *user_allocator_context;
   void *pack_info;
   int   width;
   int   height;
   int   stride_in_bytes;
   int   padding;
   unsigned int   h_oversample, v_oversample;
   unsigned char *pixels;
   void  *nodes;
};

//////////////////////////////////////////////////////////////////////////////
//
// FONT LOADING
//
//

STBTT_DEF int stbtt_GetNumberOfFonts(const unsigned char *data);
// This function will determine the number of fonts in a font file.  TrueType
// collection (.ttc) files may contain multiple fonts, while TrueType font
// (.ttf) files only contain one font. The number of fonts can be used for
// indexing with the previous function where the index is between zero and one
// less than the total fonts. If an error occurs, -1 is returned.

STBTT_DEF int stbtt_GetFontOffsetForIndex(const unsigned char *data, int index);
// Each .ttf/.ttc file may have more than one font. Each font has a sequential
// index number starting from 0. Call this function to get the font offset for
// a given index; it returns -1 if the index is out of range. A regular .ttf
// file will only define one font and it always be at offset 0, so it will
// return '0' for index 0, and -1 for all other indices.

// The following structure is defined publically so you can declare one on
// the stack or as a global or etc, but you should treat it as opaque.
struct stbtt_fontinfo
{
   void           * userdata;
   unsigned char  * data;              // pointer to .ttf file
   int              fontstart;         // offset of start of font

   int numGlyphs;                     // number of glyphs, needed for range checking

   int loca,head,glyf,hhea,hmtx,kern,gpos; // table locations as offset from start of .ttf
   int index_map;                     // a cmap mapping for our chosen character encoding
   int indexToLocFormat;              // format needed to map from glyph index to glyph

   stbtt__buf cff;                    // cff font data
   stbtt__buf charstrings;            // the charstring index
   stbtt__buf gsubrs;                 // global charstring subroutines index
   stbtt__buf subrs;                  // private charstring subroutines index
   stbtt__buf fontdicts;              // array of font dicts
   stbtt__buf fdselect;               // map from glyph to fontdict
};

STBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset);
// Given an offset into the file that defines a font, this function builds
// the necessary cached info for the rest of the system. You must allocate
// the stbtt_fontinfo yourself, and stbtt_InitFont will fill it out. You don't
// need to do anything special to free it, because the contents are pure
// value data with no additional data structures. Returns 0 on failure.


//////////////////////////////////////////////////////////////////////////////
//
// CHARACTER TO GLYPH-INDEX CONVERSIOn

STBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint);
// If you're going to perform multiple operations on the same character
// and you want a speed-up, call this function with the character you're
// going to process, then use glyph-based functions instead of the
// codepoint-based functions.


//////////////////////////////////////////////////////////////////////////////
//
// CHARACTER PROPERTIES
//

STBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float pixels);
// computes a scale factor to produce a font whose "height" is 'pixels' tall.
// Height is measured as the distance from the highest ascender to the lowest
// descender; in other words, it's equivalent to calling stbtt_GetFontVMetrics
// and computing:
//       scale = pixels / (ascent - descent)
// so if you prefer to measure height by the ascent only, use a similar calculation.

STBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels);
// computes a scale factor to produce a font whose EM size is mapped to
// 'pixels' tall. This is probably what traditional APIs compute, but
// I'm not positive.

STBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap);
// ascent is the coordinate above the baseline the font extends; descent
// is the coordinate below the baseline the font extends (i.e. it is typically negative)
// lineGap is the spacing between one row's descent and the next row's ascent...
// so you should advance the vertical position by "*ascent - *descent + *lineGap"
//   these are expressed in unscaled coordinates, so you must multiply by
//   the scale factor for a given size

STBTT_DEF int  stbtt_GetFontVMetricsOS2(const stbtt_fontinfo *info, int *typoAscent, int *typoDescent, int *typoLineGap);
// analogous to GetFontVMetrics, but returns the "typographic" values from the OS/2
// table (specific to MS/Windows TTF files).
//
// Returns 1 on success (table present), 0 on failure.

STBTT_DEF void stbtt_GetFontBoundingBox(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1);
// the bounding box around all possible characters

STBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing);
// leftSideBearing is the offset from the current horizontal position to the left edge of the character
// advanceWidth is the offset from the current horizontal position to the next horizontal position
//   these are expressed in unscaled coordinates

STBTT_DEF int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2);
// an additional amount to add to the 'advance' value between ch1 and ch2

STBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1);
// Gets the bounding box of the visible part of the glyph, in unscaled coordinates

STBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing);
STBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2);
STBTT_DEF int  stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1);
// as above, but takes one or more glyph indices for greater efficiency


//////////////////////////////////////////////////////////////////////////////
//
// GLYPH SHAPES (you probably don't need these, but they have to go before
// the bitmaps for C declaration-order reasons)
//

#ifndef STBTT_vmove // you can predefine these to use different values (but why?)
   enum {
      STBTT_vmove=1,
      STBTT_vline,
      STBTT_vcurve,
      STBTT_vcubic
   };
#endif

#ifndef stbtt_vertex // you can predefine this to use different values
                   // (we share this with other code at RAD)
   #define stbtt_vertex_type short // can't use stbtt_int16 because that's not visible in the header file
   typedef struct
   {
      stbtt_vertex_type x,y,cx,cy,cx1,cy1;
      unsigned char type,padding;
   } stbtt_vertex;
#endif

STBTT_DEF int stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index);
// returns non-zero if nothing is drawn for this glyph

STBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices);
STBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **vertices);
// returns # of vertices and fills *vertices with the pointer to them
//   these are expressed in "unscaled" coordinates
//
// The shape is a series of countours. Each one starts with
// a STBTT_moveto, then consists of a series of mixed
// STBTT_lineto and STBTT_curveto segments. A lineto
// draws a line from previous endpoint to its x,y; a curveto
// draws a quadratic bezier from previous endpoint to
// its x,y, using cx,cy as the bezier control point.

STBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *vertices);
// frees the data allocated above

//////////////////////////////////////////////////////////////////////////////
//
// BITMAP RENDERING
//

STBTT_DEF void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata);
// frees the bitmap allocated below

STBTT_DEF unsigned char *stbtt_GetCodepointBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff);
// allocates a large-enough single-channel 8bpp bitmap and renders the
// specified character/glyph at the specified scale into it, with
// antialiasing. 0 is no coverage (transparent), 255 is fully covered (opaque).
// *width & *height are filled out with the width & height of the bitmap,
// which is stored left-to-right, top-to-bottom.
//
// xoff/yoff are the offset it pixel space from the glyph origin to the top-left of the bitmap

STBTT_DEF unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff);
// the same as stbtt_GetCodepoitnBitmap, but you can specify a subpixel
// shift for the character

STBTT_DEF void stbtt_MakeCodepointBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint);
// the same as stbtt_GetCodepointBitmap, but you pass in storage for the bitmap
// in the form of 'output', with row spacing of 'out_stride' bytes. the bitmap
// is clipped to out_w/out_h bytes. Call stbtt_GetCodepointBitmapBox to get the
// width and height and positioning info for it first.

STBTT_DEF void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint);
// same as stbtt_MakeCodepointBitmap, but you can specify a subpixel
// shift for the character

STBTT_DEF void stbtt_MakeCodepointBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int codepoint);
// same as stbtt_MakeCodepointBitmapSubpixel, but prefiltering
// is performed (see stbtt_PackSetOversampling)

STBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1);
// get the bbox of the bitmap centered around the glyph origin; so the
// bitmap width is ix1-ix0, height is iy1-iy0, and location to place
// the bitmap top left is (leftSideBearing*scale,iy0).
// (Note that the bitmap uses y-increases-down, but the shape uses
// y-increases-up, so CodepointBitmapBox and CodepointBox are inverted.)

STBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1);
// same as stbtt_GetCodepointBitmapBox, but you can specify a subpixel
// shift for the character

// the following functions are equivalent to the above functions, but operate
// on glyph indices instead of Unicode codepoints (for efficiency)
STBTT_DEF unsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff);
STBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff);
STBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph);
STBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph);
STBTT_DEF void stbtt_MakeGlyphBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int glyph);
STBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1);
STBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1);


// @TODO: don't expose this structure
typedef struct
{
   int w,h,stride;
   unsigned char *pixels;
} stbtt__bitmap;

// rasterize a shape with quadratic beziers into a bitmap
STBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result,        // 1-channel bitmap to draw into
                               float flatness_in_pixels,     // allowable error of curve in pixels
                               stbtt_vertex *vertices,       // array of vertices defining shape
                               int num_verts,                // number of vertices in above array
                               float scale_x, float scale_y, // scale applied to input vertices
                               float shift_x, float shift_y, // translation applied to input vertices
                               int x_off, int y_off,         // another translation applied to input
                               int invert,                   // if non-zero, vertically flip shape
                               void *userdata);              // context for to STBTT_MALLOC

//////////////////////////////////////////////////////////////////////////////
//
// Signed Distance Function (or Field) rendering

STBTT_DEF void stbtt_FreeSDF(unsigned char *bitmap, void *userdata);
// frees the SDF bitmap allocated below

STBTT_DEF unsigned char * stbtt_GetGlyphSDF(const stbtt_fontinfo *info, float scale, int glyph, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff);
STBTT_DEF unsigned char * stbtt_GetCodepointSDF(const stbtt_fontinfo *info, float scale, int codepoint, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff);
// These functions compute a discretized SDF field for a single character, suitable for storing
// in a single-channel texture, sampling with bilinear filtering, and testing against
// larger than some threshhold to produce scalable fonts.
//        info              --  the font
//        scale             --  controls the size of the resulting SDF bitmap, same as it would be creating a regular bitmap
//        glyph/codepoint   --  the character to generate the SDF for
//        padding           --  extra "pixels" around the character which are filled with the distance to the character (not 0),
//                                 which allows effects like bit outlines
//        onedge_value      --  value 0-255 to test the SDF against to reconstruct the character (i.e. the isocontour of the character)
//        pixel_dist_scale  --  what value the SDF should increase by when moving one SDF "pixel" away from the edge (on the 0..255 scale)
//                                 if positive, > onedge_value is inside; if negative, < onedge_value is inside
//        width,height      --  output height & width of the SDF bitmap (including padding)
//        xoff,yoff         --  output origin of the character
//        return value      --  a 2D array of bytes 0..255, width*height in size
//
// pixel_dist_scale & onedge_value are a scale & bias that allows you to make
// optimal use of the limited 0..255 for your application, trading off precision
// and special effects. SDF values outside the range 0..255 are clamped to 0..255.
//
// Example:
//      scale = stbtt_ScaleForPixelHeight(22)
//      padding = 5
//      onedge_value = 180
//      pixel_dist_scale = 180/5.0 = 36.0
//
//      This will create an SDF bitmap in which the character is about 22 pixels
//      high but the whole bitmap is about 22+5+5=32 pixels high. To produce a filled
//      shape, sample the SDF at each pixel and fill the pixel if the SDF value
//      is greater than or equal to 180/255. (You'll actually want to antialias,
//      which is beyond the scope of this example.) Additionally, you can compute
//      offset outlines (e.g. to stroke the character border inside & outside,
//      or only outside). For example, to fill outside the character up to 3 SDF
//      pixels, you would compare against (180-36.0*3)/255 = 72/255. The above
//      choice of variables maps a range from 5 pixels outside the shape to
//      2 pixels inside the shape to 0..255; this is intended primarily for apply
//      outside effects only (the interior range is needed to allow proper
//      antialiasing of the font at *smaller* sizes)
//
// The function computes the SDF analytically at each SDF pixel, not by e.g.
// building a higher-res bitmap and approximating it. In theory the quality
// should be as high as possible for an SDF of this size & representation, but
// unclear if this is true in practice (perhaps building a higher-res bitmap
// and computing from that can allow drop-out prevention).
//
// The algorithm has not been optimized at all, so expect it to be slow
// if computing lots of characters or very large sizes. 



//////////////////////////////////////////////////////////////////////////////
//
// Finding the right font...
//
// You should really just solve this offline, keep your own tables
// of what font is what, and don't try to get it out of the .ttf file.
// That's because getting it out of the .ttf file is really hard, because
// the names in the file can appear in many possible encodings, in many
// possible languages, and e.g. if you need a case-insensitive comparison,
// the details of that depend on the encoding & language in a complex way
// (actually underspecified in truetype, but also gigantic).
//
// But you can use the provided functions in two possible ways:
//     stbtt_FindMatchingFont() will use *case-sensitive* comparisons on
//             unicode-encoded names to try to find the font you want;
//             you can run this before calling stbtt_InitFont()
//
//     stbtt_GetFontNameString() lets you get any of the various strings
//             from the file yourself and do your own comparisons on them.
//             You have to have called stbtt_InitFont() first.


STBTT_DEF int stbtt_FindMatchingFont(const unsigned char *fontdata, const char *name, int flags);
// returns the offset (not index) of the font that matches, or -1 if none
//   if you use STBTT_MACSTYLE_DONTCARE, use a font name like "Arial Bold".
//   if you use any other flag, use a font name like "Arial"; this checks
//     the 'macStyle' header field; i don't know if fonts set this consistently
#define STBTT_MACSTYLE_DONTCARE     0
#define STBTT_MACSTYLE_BOLD         1
#define STBTT_MACSTYLE_ITALIC       2
#define STBTT_MACSTYLE_UNDERSCORE   4
#define STBTT_MACSTYLE_NONE         8   // <= not same as 0, this makes us check the bitfield is 0

STBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2);
// returns 1/0 whether the first string interpreted as utf8 is identical to
// the second string interpreted as big-endian utf16... useful for strings from next func

STBTT_DEF const char *stbtt_GetFontNameString(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID);
// returns the string (which may be big-endian double byte, e.g. for unicode)
// and puts the length in bytes in *length.
//
// some of the values for the IDs are below; for more see the truetype spec:
//     http://developer.apple.com/textfonts/TTRefMan/RM06/Chap6name.html
//     http://www.microsoft.com/typography/otspec/name.htm

enum { // platformID
   STBTT_PLATFORM_ID_UNICODE   =0,
   STBTT_PLATFORM_ID_MAC       =1,
   STBTT_PLATFORM_ID_ISO       =2,
   STBTT_PLATFORM_ID_MICROSOFT =3
};

enum { // encodingID for STBTT_PLATFORM_ID_UNICODE
   STBTT_UNICODE_EID_UNICODE_1_0    =0,
   STBTT_UNICODE_EID_UNICODE_1_1    =1,
   STBTT_UNICODE_EID_ISO_10646      =2,
   STBTT_UNICODE_EID_UNICODE_2_0_BMP=3,
   STBTT_UNICODE_EID_UNICODE_2_0_FULL=4
};

enum { // encodingID for STBTT_PLATFORM_ID_MICROSOFT
   STBTT_MS_EID_SYMBOL        =0,
   STBTT_MS_EID_UNICODE_BMP   =1,
   STBTT_MS_EID_SHIFTJIS      =2,
   STBTT_MS_EID_UNICODE_FULL  =10
};

enum { // encodingID for STBTT_PLATFORM_ID_MAC; same as Script Manager codes
   STBTT_MAC_EID_ROMAN        =0,   STBTT_MAC_EID_ARABIC       =4,
   STBTT_MAC_EID_JAPANESE     =1,   STBTT_MAC_EID_HEBREW       =5,
   STBTT_MAC_EID_CHINESE_TRAD =2,   STBTT_MAC_EID_GREEK        =6,
   STBTT_MAC_EID_KOREAN       =3,   STBTT_MAC_EID_RUSSIAN      =7
};

enum { // languageID for STBTT_PLATFORM_ID_MICROSOFT; same as LCID...
       // problematic because there are e.g. 16 english LCIDs and 16 arabic LCIDs
   STBTT_MS_LANG_ENGLISH     =0x0409,   STBTT_MS_LANG_ITALIAN     =0x0410,
   STBTT_MS_LANG_CHINESE     =0x0804,   STBTT_MS_LANG_JAPANESE    =0x0411,
   STBTT_MS_LANG_DUTCH       =0x0413,   STBTT_MS_LANG_KOREAN      =0x0412,
   STBTT_MS_LANG_FRENCH      =0x040c,   STBTT_MS_LANG_RUSSIAN     =0x0419,
   STBTT_MS_LANG_GERMAN      =0x0407,   STBTT_MS_LANG_SPANISH     =0x0409,
   STBTT_MS_LANG_HEBREW      =0x040d,   STBTT_MS_LANG_SWEDISH     =0x041D
};

enum { // languageID for STBTT_PLATFORM_ID_MAC
   STBTT_MAC_LANG_ENGLISH      =0 ,   STBTT_MAC_LANG_JAPANESE     =11,
   STBTT_MAC_LANG_ARABIC       =12,   STBTT_MAC_LANG_KOREAN       =23,
   STBTT_MAC_LANG_DUTCH        =4 ,   STBTT_MAC_LANG_RUSSIAN      =32,
   STBTT_MAC_LANG_FRENCH       =1 ,   STBTT_MAC_LANG_SPANISH      =6 ,
   STBTT_MAC_LANG_GERMAN       =2 ,   STBTT_MAC_LANG_SWEDISH      =5 ,
   STBTT_MAC_LANG_HEBREW       =10,   STBTT_MAC_LANG_CHINESE_SIMPLIFIED =33,
   STBTT_MAC_LANG_ITALIAN      =3 ,   STBTT_MAC_LANG_CHINESE_TRAD =19
};

#ifdef __cplusplus
}
#endif

#endif // __STB_INCLUDE_STB_TRUETYPE_H__

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
////
////   IMPLEMENTATION
////
////

#ifdef STB_TRUETYPE_IMPLEMENTATION

#ifndef STBTT_MAX_OVERSAMPLE
#define STBTT_MAX_OVERSAMPLE   8
#endif

#if STBTT_MAX_OVERSAMPLE > 255
#error "STBTT_MAX_OVERSAMPLE cannot be > 255"
#endif

typedef int stbtt__test_oversample_pow2[(STBTT_MAX_OVERSAMPLE & (STBTT_MAX_OVERSAMPLE-1)) == 0 ? 1 : -1];

#ifndef STBTT_RASTERIZER_VERSION
#define STBTT_RASTERIZER_VERSION 2
#endif

#ifdef _MSC_VER
#define STBTT__NOTUSED(v)  (void)(v)
#else
#define STBTT__NOTUSED(v)  (void)sizeof(v)
#endif

//////////////////////////////////////////////////////////////////////////
//
// stbtt__buf helpers to parse data from file
//

static stbtt_uint8 stbtt__buf_get8(stbtt__buf *b)
{
   if (b->cursor >= b->size)
      return 0;
   return b->data[b->cursor++];
}

static stbtt_uint8 stbtt__buf_peek8(stbtt__buf *b)
{
   if (b->cursor >= b->size)
      return 0;
   return b->data[b->cursor];
}

static void stbtt__buf_seek(stbtt__buf *b, int o)
{
   STBTT_assert(!(o > b->size || o < 0));
   b->cursor = (o > b->size || o < 0) ? b->size : o;
}

static void stbtt__buf_skip(stbtt__buf *b, int o)
{
   stbtt__buf_seek(b, b->cursor + o);
}

static stbtt_uint32 stbtt__buf_get(stbtt__buf *b, int n)
{
   stbtt_uint32 v = 0;
   int i;
   STBTT_assert(n >= 1 && n <= 4);
   for (i = 0; i < n; i++)
      v = (v << 8) | stbtt__buf_get8(b);
   return v;
}

static stbtt__buf stbtt__new_buf(const void *p, size_t size)
{
   stbtt__buf r;
   STBTT_assert(size < 0x40000000);
   r.data = (stbtt_uint8*) p;
   r.size = (int) size;
   r.cursor = 0;
   return r;
}

#define stbtt__buf_get16(b)  stbtt__buf_get((b), 2)
#define stbtt__buf_get32(b)  stbtt__buf_get((b), 4)

static stbtt__buf stbtt__buf_range(const stbtt__buf *b, int o, int s)
{
   stbtt__buf r = stbtt__new_buf(NULL, 0);
   if (o < 0 || s < 0 || o > b->size || s > b->size - o) return r;
   r.data = b->data + o;
   r.size = s;
   return r;
}

static stbtt__buf stbtt__cff_get_index(stbtt__buf *b)
{
   int count, start, offsize;
   start = b->cursor;
   count = stbtt__buf_get16(b);
   if (count) {
      offsize = stbtt__buf_get8(b);
      STBTT_assert(offsize >= 1 && offsize <= 4);
      stbtt__buf_skip(b, offsize * count);
      stbtt__buf_skip(b, stbtt__buf_get(b, offsize) - 1);
   }
   return stbtt__buf_range(b, start, b->cursor - start);
}

static stbtt_uint32 stbtt__cff_int(stbtt__buf *b)
{
   int b0 = stbtt__buf_get8(b);
   if (b0 >= 32 && b0 <= 246)       return b0 - 139;
   else if (b0 >= 247 && b0 <= 250) return (b0 - 247)*256 + stbtt__buf_get8(b) + 108;
   else if (b0 >= 251 && b0 <= 254) return -(b0 - 251)*256 - stbtt__buf_get8(b) - 108;
   else if (b0 == 28)               return stbtt__buf_get16(b);
   else if (b0 == 29)               return stbtt__buf_get32(b);
   STBTT_assert(0);
   return 0;
}

static void stbtt__cff_skip_operand(stbtt__buf *b) {
   int v, b0 = stbtt__buf_peek8(b);
   STBTT_assert(b0 >= 28);
   if (b0 == 30) {
      stbtt__buf_skip(b, 1);
      while (b->cursor < b->size) {
         v = stbtt__buf_get8(b);
         if ((v & 0xF) == 0xF || (v >> 4) == 0xF)
            break;
      }
   } else {
      stbtt__cff_int(b);
   }
}

static stbtt__buf stbtt__dict_get(stbtt__buf *b, int key)
{
   stbtt__buf_seek(b, 0);
   while (b->cursor < b->size) {
      int start = b->cursor, end, op;
      while (stbtt__buf_peek8(b) >= 28)
         stbtt__cff_skip_operand(b);
      end = b->cursor;
      op = stbtt__buf_get8(b);
      if (op == 12)  op = stbtt__buf_get8(b) | 0x100;
      if (op == key) return stbtt__buf_range(b, start, end-start);
   }
   return stbtt__buf_range(b, 0, 0);
}

static void stbtt__dict_get_ints(stbtt__buf *b, int key, int outcount, stbtt_uint32 *out)
{
   int i;
   stbtt__buf operands = stbtt__dict_get(b, key);
   for (i = 0; i < outcount && operands.cursor < operands.size; i++)
      out[i] = stbtt__cff_int(&operands);
}

static int stbtt__cff_index_count(stbtt__buf *b)
{
   stbtt__buf_seek(b, 0);
   return stbtt__buf_get16(b);
}

static stbtt__buf stbtt__cff_index_get(stbtt__buf b, int i)
{
   int count, offsize, start, end;
   stbtt__buf_seek(&b, 0);
   count = stbtt__buf_get16(&b);
   offsize = stbtt__buf_get8(&b);
   STBTT_assert(i >= 0 && i < count);
   STBTT_assert(offsize >= 1 && offsize <= 4);
   stbtt__buf_skip(&b, i*offsize);
   start = stbtt__buf_get(&b, offsize);
   end = stbtt__buf_get(&b, offsize);
   return stbtt__buf_range(&b, 2+(count+1)*offsize+start, end - start);
}

//////////////////////////////////////////////////////////////////////////
//
// accessors to parse data from file
//

// on platforms that don't allow misaligned reads, if we want to allow
// truetype fonts that aren't padded to alignment, define ALLOW_UNALIGNED_TRUETYPE

#define ttBYTE(p)     (* (stbtt_uint8 *) (p))
#define ttCHAR(p)     (* (stbtt_int8 *) (p))
#define ttFixed(p)    ttLONG(p)

static stbtt_uint16 ttUSHORT(stbtt_uint8 *p) { return p[0]*256 + p[1]; }
static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }
static stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }
static stbtt_int32 ttLONG(stbtt_uint8 *p)    { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }

#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
#define stbtt_tag(p,str)           stbtt_tag4(p,str[0],str[1],str[2],str[3])

static int stbtt__isfont(stbtt_uint8 *font)
{
   // check the version number
   if (stbtt_tag4(font, '1',0,0,0))  return 1; // TrueType 1
   if (stbtt_tag(font, "typ1"))   return 1; // TrueType with type 1 font -- we don't support this!
   if (stbtt_tag(font, "OTTO"))   return 1; // OpenType with CFF
   if (stbtt_tag4(font, 0,1,0,0)) return 1; // OpenType 1.0
   if (stbtt_tag(font, "true"))   return 1; // Apple specification for TrueType fonts
   return 0;
}

// @OPTIMIZE: binary search
static stbtt_uint32 stbtt__find_table(stbtt_uint8 *data, stbtt_uint32 fontstart, const char *tag)
{
   stbtt_int32 num_tables = ttUSHORT(data+fontstart+4);
   stbtt_uint32 tabledir = fontstart + 12;
   stbtt_int32 i;
   for (i=0; i < num_tables; ++i) {
      stbtt_uint32 loc = tabledir + 16*i;
      if (stbtt_tag(data+loc+0, tag))
         return ttULONG(data+loc+8);
   }
   return 0;
}

static int stbtt_GetFontOffsetForIndex_internal(unsigned char *font_collection, int index)
{
   // if it's just a font, there's only one valid index
   if (stbtt__isfont(font_collection))
      return index == 0 ? 0 : -1;

   // check if it's a TTC
   if (stbtt_tag(font_collection, "ttcf")) {
      // version 1?
      if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {
         stbtt_int32 n = ttLONG(font_collection+8);
         if (index >= n)
            return -1;
         return ttULONG(font_collection+12+index*4);
      }
   }
   return -1;
}

static int stbtt_GetNumberOfFonts_internal(unsigned char *font_collection)
{
   // if it's just a font, there's only one valid font
   if (stbtt__isfont(font_collection))
      return 1;

   // check if it's a TTC
   if (stbtt_tag(font_collection, "ttcf")) {
      // version 1?
      if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {
         return ttLONG(font_collection+8);
      }
   }
   return 0;
}

static stbtt__buf stbtt__get_subrs(stbtt__buf cff, stbtt__buf fontdict)
{
   stbtt_uint32 subrsoff = 0, private_loc[2] = { 0, 0 };
   stbtt__buf pdict;
   stbtt__dict_get_ints(&fontdict, 18, 2, private_loc);
   if (!private_loc[1] || !private_loc[0]) return stbtt__new_buf(NULL, 0);
   pdict = stbtt__buf_range(&cff, private_loc[1], private_loc[0]);
   stbtt__dict_get_ints(&pdict, 19, 1, &subrsoff);
   if (!subrsoff) return stbtt__new_buf(NULL, 0);
   stbtt__buf_seek(&cff, private_loc[1]+subrsoff);
   return stbtt__cff_get_index(&cff);
}

static int stbtt_InitFont_internal(stbtt_fontinfo *info, unsigned char *data, int fontstart)
{
   stbtt_uint32 cmap, t;
   stbtt_int32 i,numTables;

   info->data = data;
   info->fontstart = fontstart;
   info->cff = stbtt__new_buf(NULL, 0);

   cmap = stbtt__find_table(data, fontstart, "cmap");       // required
   info->loca = stbtt__find_table(data, fontstart, "loca"); // required
   info->head = stbtt__find_table(data, fontstart, "head"); // required
   info->glyf = stbtt__find_table(data, fontstart, "glyf"); // required
   info->hhea = stbtt__find_table(data, fontstart, "hhea"); // required
   info->hmtx = stbtt__find_table(data, fontstart, "hmtx"); // required
   info->kern = stbtt__find_table(data, fontstart, "kern"); // not required
   info->gpos = stbtt__find_table(data, fontstart, "GPOS"); // not required

   if (!cmap || !info->head || !info->hhea || !info->hmtx)
      return 0;
   if (info->glyf) {
      // required for truetype
      if (!info->loca) return 0;
   } else {
      // initialization for CFF / Type2 fonts (OTF)
      stbtt__buf b, topdict, topdictidx;
      stbtt_uint32 cstype = 2, charstrings = 0, fdarrayoff = 0, fdselectoff = 0;
      stbtt_uint32 cff;

      cff = stbtt__find_table(data, fontstart, "CFF ");
      if (!cff) return 0;

      info->fontdicts = stbtt__new_buf(NULL, 0);
      info->fdselect = stbtt__new_buf(NULL, 0);

      // @TODO this should use size from table (not 512MB)
      info->cff = stbtt__new_buf(data+cff, 512*1024*1024);
      b = info->cff;

      // read the header
      stbtt__buf_skip(&b, 2);
      stbtt__buf_seek(&b, stbtt__buf_get8(&b)); // hdrsize

      // @TODO the name INDEX could list multiple fonts,
      // but we just use the first one.
      stbtt__cff_get_index(&b);  // name INDEX
      topdictidx = stbtt__cff_get_index(&b);
      topdict = stbtt__cff_index_get(topdictidx, 0);
      stbtt__cff_get_index(&b);  // string INDEX
      info->gsubrs = stbtt__cff_get_index(&b);

      stbtt__dict_get_ints(&topdict, 17, 1, &charstrings);
      stbtt__dict_get_ints(&topdict, 0x100 | 6, 1, &cstype);
      stbtt__dict_get_ints(&topdict, 0x100 | 36, 1, &fdarrayoff);
      stbtt__dict_get_ints(&topdict, 0x100 | 37, 1, &fdselectoff);
      info->subrs = stbtt__get_subrs(b, topdict);

      // we only support Type 2 charstrings
      if (cstype != 2) return 0;
      if (charstrings == 0) return 0;

      if (fdarrayoff) {
         // looks like a CID font
         if (!fdselectoff) return 0;
         stbtt__buf_seek(&b, fdarrayoff);
         info->fontdicts = stbtt__cff_get_index(&b);
         info->fdselect = stbtt__buf_range(&b, fdselectoff, b.size-fdselectoff);
      }

      stbtt__buf_seek(&b, charstrings);
      info->charstrings = stbtt__cff_get_index(&b);
   }

   t = stbtt__find_table(data, fontstart, "maxp");
   if (t)
      info->numGlyphs = ttUSHORT(data+t+4);
   else
      info->numGlyphs = 0xffff;

   // find a cmap encoding table we understand *now* to avoid searching
   // later. (todo: could make this installable)
   // the same regardless of glyph.
   numTables = ttUSHORT(data + cmap + 2);
   info->index_map = 0;
   for (i=0; i < numTables; ++i) {
      stbtt_uint32 encoding_record = cmap + 4 + 8 * i;
      // find an encoding we understand:
      switch(ttUSHORT(data+encoding_record)) {
         case STBTT_PLATFORM_ID_MICROSOFT:
            switch (ttUSHORT(data+encoding_record+2)) {
               case STBTT_MS_EID_UNICODE_BMP:
               case STBTT_MS_EID_UNICODE_FULL:
                  // MS/Unicode
                  info->index_map = cmap + ttULONG(data+encoding_record+4);
                  break;
            }
            break;
        case STBTT_PLATFORM_ID_UNICODE:
            // Mac/iOS has these
            // all the encodingIDs are unicode, so we don't bother to check it
            info->index_map = cmap + ttULONG(data+encoding_record+4);
            break;
      }
   }
   if (info->index_map == 0)
      return 0;

   info->indexToLocFormat = ttUSHORT(data+info->head + 50);
   return 1;
}

STBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint)
{
   stbtt_uint8 *data = info->data;
   stbtt_uint32 index_map = info->index_map;

   stbtt_uint16 format = ttUSHORT(data + index_map + 0);
   if (format == 0) { // apple byte encoding
      stbtt_int32 bytes = ttUSHORT(data + index_map + 2);
      if (unicode_codepoint < bytes-6)
         return ttBYTE(data + index_map + 6 + unicode_codepoint);
      return 0;
   } else if (format == 6) {
      stbtt_uint32 first = ttUSHORT(data + index_map + 6);
      stbtt_uint32 count = ttUSHORT(data + index_map + 8);
      if ((stbtt_uint32) unicode_codepoint >= first && (stbtt_uint32) unicode_codepoint < first+count)
         return ttUSHORT(data + index_map + 10 + (unicode_codepoint - first)*2);
      return 0;
   } else if (format == 2) {
      STBTT_assert(0); // @TODO: high-byte mapping for japanese/chinese/korean
      return 0;
   } else if (format == 4) { // standard mapping for windows fonts: binary search collection of ranges
      stbtt_uint16 segcount = ttUSHORT(data+index_map+6) >> 1;
      stbtt_uint16 searchRange = ttUSHORT(data+index_map+8) >> 1;
      stbtt_uint16 entrySelector = ttUSHORT(data+index_map+10);
      stbtt_uint16 rangeShift = ttUSHORT(data+index_map+12) >> 1;

      // do a binary search of the segments
      stbtt_uint32 endCount = index_map + 14;
      stbtt_uint32 search = endCount;

      if (unicode_codepoint > 0xffff)
         return 0;

      // they lie from endCount .. endCount + segCount
      // but searchRange is the nearest power of two, so...
      if (unicode_codepoint >= ttUSHORT(data + search + rangeShift*2))
         search += rangeShift*2;

      // now decrement to bias correctly to find smallest
      search -= 2;
      while (entrySelector) {
         stbtt_uint16 end;
         searchRange >>= 1;
         end = ttUSHORT(data + search + searchRange*2);
         if (unicode_codepoint > end)
            search += searchRange*2;
         --entrySelector;
      }
      search += 2;

      {
         stbtt_uint16 offset, start;
         stbtt_uint16 item = (stbtt_uint16) ((search - endCount) >> 1);

         STBTT_assert(unicode_codepoint <= ttUSHORT(data + endCount + 2*item));
         start = ttUSHORT(data + index_map + 14 + segcount*2 + 2 + 2*item);
         if (unicode_codepoint < start)
            return 0;

         offset = ttUSHORT(data + index_map + 14 + segcount*6 + 2 + 2*item);
         if (offset == 0)
            return (stbtt_uint16) (unicode_codepoint + ttSHORT(data + index_map + 14 + segcount*4 + 2 + 2*item));

         return ttUSHORT(data + offset + (unicode_codepoint-start)*2 + index_map + 14 + segcount*6 + 2 + 2*item);
      }
   } else if (format == 12 || format == 13) {
      stbtt_uint32 ngroups = ttULONG(data+index_map+12);
      stbtt_int32 low,high;
      low = 0; high = (stbtt_int32)ngroups;
      // Binary search the right group.
      while (low < high) {
         stbtt_int32 mid = low + ((high-low) >> 1); // rounds down, so low <= mid < high
         stbtt_uint32 start_char = ttULONG(data+index_map+16+mid*12);
         stbtt_uint32 end_char = ttULONG(data+index_map+16+mid*12+4);
         if ((stbtt_uint32) unicode_codepoint < start_char)
            high = mid;
         else if ((stbtt_uint32) unicode_codepoint > end_char)
            low = mid+1;
         else {
            stbtt_uint32 start_glyph = ttULONG(data+index_map+16+mid*12+8);
            if (format == 12)
               return start_glyph + unicode_codepoint-start_char;
            else // format == 13
               return start_glyph;
         }
      }
      return 0; // not found
   }
   // @TODO
   STBTT_assert(0);
   return 0;
}

STBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices)
{
   return stbtt_GetGlyphShape(info, stbtt_FindGlyphIndex(info, unicode_codepoint), vertices);
}

static void stbtt_setvertex(stbtt_vertex *v, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy)
{
   v->type = type;
   v->x = (stbtt_int16) x;
   v->y = (stbtt_int16) y;
   v->cx = (stbtt_int16) cx;
   v->cy = (stbtt_int16) cy;
}

static int stbtt__GetGlyfOffset(const stbtt_fontinfo *info, int glyph_index)
{
   int g1,g2;

   STBTT_assert(!info->cff.size);

   if (glyph_index >= info->numGlyphs) return -1; // glyph index out of range
   if (info->indexToLocFormat >= 2)    return -1; // unknown index->glyph map format

   if (info->indexToLocFormat == 0) {
      g1 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2) * 2;
      g2 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2 + 2) * 2;
   } else {
      g1 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4);
      g2 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4 + 4);
   }

   return g1==g2 ? -1 : g1; // if length is 0, return -1
}

static int stbtt__GetGlyphInfoT2(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1);

STBTT_DEF int stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)
{
   if (info->cff.size) {
      stbtt__GetGlyphInfoT2(info, glyph_index, x0, y0, x1, y1);
   } else {
      int g = stbtt__GetGlyfOffset(info, glyph_index);
      if (g < 0) return 0;

      if (x0) *x0 = ttSHORT(info->data + g + 2);
      if (y0) *y0 = ttSHORT(info->data + g + 4);
      if (x1) *x1 = ttSHORT(info->data + g + 6);
      if (y1) *y1 = ttSHORT(info->data + g + 8);
   }
   return 1;
}

STBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1)
{
   return stbtt_GetGlyphBox(info, stbtt_FindGlyphIndex(info,codepoint), x0,y0,x1,y1);
}

STBTT_DEF int stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index)
{
   stbtt_int16 numberOfContours;
   int g;
   if (info->cff.size)
      return stbtt__GetGlyphInfoT2(info, glyph_index, NULL, NULL, NULL, NULL) == 0;
   g = stbtt__GetGlyfOffset(info, glyph_index);
   if (g < 0) return 1;
   numberOfContours = ttSHORT(info->data + g);
   return numberOfContours == 0;
}

static int stbtt__close_shape(stbtt_vertex *vertices, int num_vertices, int was_off, int start_off,
    stbtt_int32 sx, stbtt_int32 sy, stbtt_int32 scx, stbtt_int32 scy, stbtt_int32 cx, stbtt_int32 cy)
{
   if (start_off) {
      if (was_off)
         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+scx)>>1, (cy+scy)>>1, cx,cy);
      stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, sx,sy,scx,scy);
   } else {
      if (was_off)
         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve,sx,sy,cx,cy);
      else
         stbtt_setvertex(&vertices[num_vertices++], STBTT_vline,sx,sy,0,0);
   }
   return num_vertices;
}

static int stbtt__GetGlyphShapeTT(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
{
   stbtt_int16 numberOfContours;
   stbtt_uint8 *endPtsOfContours;
   stbtt_uint8 *data = info->data;
   stbtt_vertex *vertices=0;
   int num_vertices=0;
   int g = stbtt__GetGlyfOffset(info, glyph_index);

   *pvertices = NULL;

   if (g < 0) return 0;

   numberOfContours = ttSHORT(data + g);

   if (numberOfContours > 0) {
      stbtt_uint8 flags=0,flagcount;
      stbtt_int32 ins, i,j=0,m,n, next_move, was_off=0, off, start_off=0;
      stbtt_int32 x,y,cx,cy,sx,sy, scx,scy;
      stbtt_uint8 *points;
      endPtsOfContours = (data + g + 10);
      ins = ttUSHORT(data + g + 10 + numberOfContours * 2);
      points = data + g + 10 + numberOfContours * 2 + 2 + ins;

      n = 1+ttUSHORT(endPtsOfContours + numberOfContours*2-2);

      m = n + 2*numberOfContours;  // a loose bound on how many vertices we might need
      vertices = (stbtt_vertex *) STBTT_malloc(m * sizeof(vertices[0]), info->userdata);
      if (vertices == 0)
         return 0;

      next_move = 0;
      flagcount=0;

      // in first pass, we load uninterpreted data into the allocated array
      // above, shifted to the end of the array so we won't overwrite it when
      // we create our final data starting from the front

      off = m - n; // starting offset for uninterpreted data, regardless of how m ends up being calculated

      // first load flags

      for (i=0; i < n; ++i) {
         if (flagcount == 0) {
            flags = *points++;
            if (flags & 8)
               flagcount = *points++;
         } else
            --flagcount;
         vertices[off+i].type = flags;
      }

      // now load x coordinates
      x=0;
      for (i=0; i < n; ++i) {
         flags = vertices[off+i].type;
         if (flags & 2) {
            stbtt_int16 dx = *points++;
            x += (flags & 16) ? dx : -dx; // ???
         } else {
            if (!(flags & 16)) {
               x = x + (stbtt_int16) (points[0]*256 + points[1]);
               points += 2;
            }
         }
         vertices[off+i].x = (stbtt_int16) x;
      }

      // now load y coordinates
      y=0;
      for (i=0; i < n; ++i) {
         flags = vertices[off+i].type;
         if (flags & 4) {
            stbtt_int16 dy = *points++;
            y += (flags & 32) ? dy : -dy; // ???
         } else {
            if (!(flags & 32)) {
               y = y + (stbtt_int16) (points[0]*256 + points[1]);
               points += 2;
            }
         }
         vertices[off+i].y = (stbtt_int16) y;
      }

      // now convert them to our format
      num_vertices=0;
      sx = sy = cx = cy = scx = scy = 0;
      for (i=0; i < n; ++i) {
         flags = vertices[off+i].type;
         x     = (stbtt_int16) vertices[off+i].x;
         y     = (stbtt_int16) vertices[off+i].y;

         if (next_move == i) {
            if (i != 0)
               num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);

            // now start the new one               
            start_off = !(flags & 1);
            if (start_off) {
               // if we start off with an off-curve point, then when we need to find a point on the curve
               // where we can start, and we need to save some state for when we wraparound.
               scx = x;
               scy = y;
               if (!(vertices[off+i+1].type & 1)) {
                  // next point is also a curve point, so interpolate an on-point curve
                  sx = (x + (stbtt_int32) vertices[off+i+1].x) >> 1;
                  sy = (y + (stbtt_int32) vertices[off+i+1].y) >> 1;
               } else {
                  // otherwise just use the next point as our start point
                  sx = (stbtt_int32) vertices[off+i+1].x;
                  sy = (stbtt_int32) vertices[off+i+1].y;
                  ++i; // we're using point i+1 as the starting point, so skip it
               }
            } else {
               sx = x;
               sy = y;
            }
            stbtt_setvertex(&vertices[num_vertices++], STBTT_vmove,sx,sy,0,0);
            was_off = 0;
            next_move = 1 + ttUSHORT(endPtsOfContours+j*2);
            ++j;
         } else {
            if (!(flags & 1)) { // if it's a curve
               if (was_off) // two off-curve control points in a row means interpolate an on-curve midpoint
                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);
               cx = x;
               cy = y;
               was_off = 1;
            } else {
               if (was_off)
                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, x,y, cx, cy);
               else
                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vline, x,y,0,0);
               was_off = 0;
            }
         }
      }
      num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);
   } else if (numberOfContours == -1) {
      // Compound shapes.
      int more = 1;
      stbtt_uint8 *comp = data + g + 10;
      num_vertices = 0;
      vertices = 0;
      while (more) {
         stbtt_uint16 flags, gidx;
         int comp_num_verts = 0, i;
         stbtt_vertex *comp_verts = 0, *tmp = 0;
         float mtx[6] = {1,0,0,1,0,0}, m, n;
         
         flags = ttSHORT(comp); comp+=2;
         gidx = ttSHORT(comp); comp+=2;

         if (flags & 2) { // XY values
            if (flags & 1) { // shorts
               mtx[4] = ttSHORT(comp); comp+=2;
               mtx[5] = ttSHORT(comp); comp+=2;
            } else {
               mtx[4] = ttCHAR(comp); comp+=1;
               mtx[5] = ttCHAR(comp); comp+=1;
            }
         }
         else {
            // @TODO handle matching point
            STBTT_assert(0);
         }
         if (flags & (1<<3)) { // WE_HAVE_A_SCALE
            mtx[0] = mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[1] = mtx[2] = 0;
         } else if (flags & (1<<6)) { // WE_HAVE_AN_X_AND_YSCALE
            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[1] = mtx[2] = 0;
            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
         } else if (flags & (1<<7)) { // WE_HAVE_A_TWO_BY_TWO
            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[1] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[2] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
         }
         
         // Find transformation scales.
         m = (float) STBTT_sqrt(mtx[0]*mtx[0] + mtx[1]*mtx[1]);
         n = (float) STBTT_sqrt(mtx[2]*mtx[2] + mtx[3]*mtx[3]);

         // Get indexed glyph.
         comp_num_verts = stbtt_GetGlyphShape(info, gidx, &comp_verts);
         if (comp_num_verts > 0) {
            // Transform vertices.
            for (i = 0; i < comp_num_verts; ++i) {
               stbtt_vertex* v = &comp_verts[i];
               stbtt_vertex_type x,y;
               x=v->x; y=v->y;
               v->x = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));
               v->y = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));
               x=v->cx; y=v->cy;
               v->cx = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));
               v->cy = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));
            }
            // Append vertices.
            tmp = (stbtt_vertex*)STBTT_malloc((num_vertices+comp_num_verts)*sizeof(stbtt_vertex), info->userdata);
            if (!tmp) {
               if (vertices) STBTT_free(vertices, info->userdata);
               if (comp_verts) STBTT_free(comp_verts, info->userdata);
               return 0;
            }
            if (num_vertices > 0) STBTT_memcpy(tmp, vertices, num_vertices*sizeof(stbtt_vertex));
            STBTT_memcpy(tmp+num_vertices, comp_verts, comp_num_verts*sizeof(stbtt_vertex));
            if (vertices) STBTT_free(vertices, info->userdata);
            vertices = tmp;
            STBTT_free(comp_verts, info->userdata);
            num_vertices += comp_num_verts;
         }
         // More components ?
         more = flags & (1<<5);
      }
   } else if (numberOfContours < 0) {
      // @TODO other compound variations?
      STBTT_assert(0);
   } else {
      // numberOfCounters == 0, do nothing
   }

   *pvertices = vertices;
   return num_vertices;
}

typedef struct
{
   int bounds;
   int started;
   float first_x, first_y;
   float x, y;
   stbtt_int32 min_x, max_x, min_y, max_y;

   stbtt_vertex *pvertices;
   int num_vertices;
} stbtt__csctx;

#define STBTT__CSCTX_INIT(bounds) {bounds,0, 0,0, 0,0, 0,0,0,0, NULL, 0}

static void stbtt__track_vertex(stbtt__csctx *c, stbtt_int32 x, stbtt_int32 y)
{
   if (x > c->max_x || !c->started) c->max_x = x;
   if (y > c->max_y || !c->started) c->max_y = y;
   if (x < c->min_x || !c->started) c->min_x = x;
   if (y < c->min_y || !c->started) c->min_y = y;
   c->started = 1;
}

static void stbtt__csctx_v(stbtt__csctx *c, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy, stbtt_int32 cx1, stbtt_int32 cy1)
{
   if (c->bounds) {
      stbtt__track_vertex(c, x, y);
      if (type == STBTT_vcubic) {
         stbtt__track_vertex(c, cx, cy);
         stbtt__track_vertex(c, cx1, cy1);
      }
   } else {
      stbtt_setvertex(&c->pvertices[c->num_vertices], type, x, y, cx, cy);
      c->pvertices[c->num_vertices].cx1 = (stbtt_int16) cx1;
      c->pvertices[c->num_vertices].cy1 = (stbtt_int16) cy1;
   }
   c->num_vertices++;
}

static void stbtt__csctx_close_shape(stbtt__csctx *ctx)
{
   if (ctx->first_x != ctx->x || ctx->first_y != ctx->y)
      stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->first_x, (int)ctx->first_y, 0, 0, 0, 0);
}

static void stbtt__csctx_rmove_to(stbtt__csctx *ctx, float dx, float dy)
{
   stbtt__csctx_close_shape(ctx);
   ctx->first_x = ctx->x = ctx->x + dx;
   ctx->first_y = ctx->y = ctx->y + dy;
   stbtt__csctx_v(ctx, STBTT_vmove, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);
}

static void stbtt__csctx_rline_to(stbtt__csctx *ctx, float dx, float dy)
{
   ctx->x += dx;
   ctx->y += dy;
   stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);
}

static void stbtt__csctx_rccurve_to(stbtt__csctx *ctx, float dx1, float dy1, float dx2, float dy2, float dx3, float dy3)
{
   float cx1 = ctx->x + dx1;
   float cy1 = ctx->y + dy1;
   float cx2 = cx1 + dx2;
   float cy2 = cy1 + dy2;
   ctx->x = cx2 + dx3;
   ctx->y = cy2 + dy3;
   stbtt__csctx_v(ctx, STBTT_vcubic, (int)ctx->x, (int)ctx->y, (int)cx1, (int)cy1, (int)cx2, (int)cy2);
}

static stbtt__buf stbtt__get_subr(stbtt__buf idx, int n)
{
   int count = stbtt__cff_index_count(&idx);
   int bias = 107;
   if (count >= 33900)
      bias = 32768;
   else if (count >= 1240)
      bias = 1131;
   n += bias;
   if (n < 0 || n >= count)
      return stbtt__new_buf(NULL, 0);
   return stbtt__cff_index_get(idx, n);
}

static stbtt__buf stbtt__cid_get_glyph_subrs(const stbtt_fontinfo *info, int glyph_index)
{
   stbtt__buf fdselect = info->fdselect;
   int nranges, start, end, v, fmt, fdselector = -1, i;

   stbtt__buf_seek(&fdselect, 0);
   fmt = stbtt__buf_get8(&fdselect);
   if (fmt == 0) {
      // untested
      stbtt__buf_skip(&fdselect, glyph_index);
      fdselector = stbtt__buf_get8(&fdselect);
   } else if (fmt == 3) {
      nranges = stbtt__buf_get16(&fdselect);
      start = stbtt__buf_get16(&fdselect);
      for (i = 0; i < nranges; i++) {
         v = stbtt__buf_get8(&fdselect);
         end = stbtt__buf_get16(&fdselect);
         if (glyph_index >= start && glyph_index < end) {
            fdselector = v;
            break;
         }
         start = end;
      }
   }
   if (fdselector == -1) stbtt__new_buf(NULL, 0);
   return stbtt__get_subrs(info->cff, stbtt__cff_index_get(info->fontdicts, fdselector));
}

static int stbtt__run_charstring(const stbtt_fontinfo *info, int glyph_index, stbtt__csctx *c)
{
   int in_header = 1, maskbits = 0, subr_stack_height = 0, sp = 0, v, i, b0;
   int has_subrs = 0, clear_stack;
   float s[48];
   stbtt__buf subr_stack[10], subrs = info->subrs, b;
   float f;

#define STBTT__CSERR(s) (0)

   // this currently ignores the initial width value, which isn't needed if we have hmtx
   b = stbtt__cff_index_get(info->charstrings, glyph_index);
   while (b.cursor < b.size) {
      i = 0;
      clear_stack = 1;
      b0 = stbtt__buf_get8(&b);
      switch (b0) {
      // @TODO implement hinting
      case 0x13: // hintmask
      case 0x14: // cntrmask
         if (in_header)
            maskbits += (sp / 2); // implicit "vstem"
         in_header = 0;
         stbtt__buf_skip(&b, (maskbits + 7) / 8);
         break;

      case 0x01: // hstem
      case 0x03: // vstem
      case 0x12: // hstemhm
      case 0x17: // vstemhm
         maskbits += (sp / 2);
         break;

      case 0x15: // rmoveto
         in_header = 0;
         if (sp < 2) return STBTT__CSERR("rmoveto stack");
         stbtt__csctx_rmove_to(c, s[sp-2], s[sp-1]);
         break;
      case 0x04: // vmoveto
         in_header = 0;
         if (sp < 1) return STBTT__CSERR("vmoveto stack");
         stbtt__csctx_rmove_to(c, 0, s[sp-1]);
         break;
      case 0x16: // hmoveto
         in_header = 0;
         if (sp < 1) return STBTT__CSERR("hmoveto stack");
         stbtt__csctx_rmove_to(c, s[sp-1], 0);
         break;

      case 0x05: // rlineto
         if (sp < 2) return STBTT__CSERR("rlineto stack");
         for (; i + 1 < sp; i += 2)
            stbtt__csctx_rline_to(c, s[i], s[i+1]);
         break;

      // hlineto/vlineto and vhcurveto/hvcurveto alternate horizontal and vertical
      // starting from a different place.

      case 0x07: // vlineto
         if (sp < 1) return STBTT__CSERR("vlineto stack");
         goto vlineto;
      case 0x06: // hlineto
         if (sp < 1) return STBTT__CSERR("hlineto stack");
         for (;;) {
            if (i >= sp) break;
            stbtt__csctx_rline_to(c, s[i], 0);
            i++;
      vlineto:
            if (i >= sp) break;
            stbtt__csctx_rline_to(c, 0, s[i]);
            i++;
         }
         break;

      case 0x1F: // hvcurveto
         if (sp < 4) return STBTT__CSERR("hvcurveto stack");
         goto hvcurveto;
      case 0x1E: // vhcurveto
         if (sp < 4) return STBTT__CSERR("vhcurveto stack");
         for (;;) {
            if (i + 3 >= sp) break;
            stbtt__csctx_rccurve_to(c, 0, s[i], s[i+1], s[i+2], s[i+3], (sp - i == 5) ? s[i + 4] : 0.0f);
            i += 4;
      hvcurveto:
            if (i + 3 >= sp) break;
            stbtt__csctx_rccurve_to(c, s[i], 0, s[i+1], s[i+2], (sp - i == 5) ? s[i+4] : 0.0f, s[i+3]);
            i += 4;
         }
         break;

      case 0x08: // rrcurveto
         if (sp < 6) return STBTT__CSERR("rcurveline stack");
         for (; i + 5 < sp; i += 6)
            stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);
         break;

      case 0x18: // rcurveline
         if (sp < 8) return STBTT__CSERR("rcurveline stack");
         for (; i + 5 < sp - 2; i += 6)
            stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);
         if (i + 1 >= sp) return STBTT__CSERR("rcurveline stack");
         stbtt__csctx_rline_to(c, s[i], s[i+1]);
         break;

      case 0x19: // rlinecurve
         if (sp < 8) return STBTT__CSERR("rlinecurve stack");
         for (; i + 1 < sp - 6; i += 2)
            stbtt__csctx_rline_to(c, s[i], s[i+1]);
         if (i + 5 >= sp) return STBTT__CSERR("rlinecurve stack");
         stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);
         break;

      case 0x1A: // vvcurveto
      case 0x1B: // hhcurveto
         if (sp < 4) return STBTT__CSERR("(vv|hh)curveto stack");
         f = 0.0;
         if (sp & 1) { f = s[i]; i++; }
         for (; i + 3 < sp; i += 4) {
            if (b0 == 0x1B)
               stbtt__csctx_rccurve_to(c, s[i], f, s[i+1], s[i+2], s[i+3], 0.0);
            else
               stbtt__csctx_rccurve_to(c, f, s[i], s[i+1], s[i+2], 0.0, s[i+3]);
            f = 0.0;
         }
         break;

      case 0x0A: // callsubr
         if (!has_subrs) {
            if (info->fdselect.size)
               subrs = stbtt__cid_get_glyph_subrs(info, glyph_index);
            has_subrs = 1;
         }
         // fallthrough
      case 0x1D: // callgsubr
         if (sp < 1) return STBTT__CSERR("call(g|)subr stack");
         v = (int) s[--sp];
         if (subr_stack_height >= 10) return STBTT__CSERR("recursion limit");
         subr_stack[subr_stack_height++] = b;
         b = stbtt__get_subr(b0 == 0x0A ? subrs : info->gsubrs, v);
         if (b.size == 0) return STBTT__CSERR("subr not found");
         b.cursor = 0;
         clear_stack = 0;
         break;

      case 0x0B: // return
         if (subr_stack_height <= 0) return STBTT__CSERR("return outside subr");
         b = subr_stack[--subr_stack_height];
         clear_stack = 0;
         break;

      case 0x0E: // endchar
         stbtt__csctx_close_shape(c);
         return 1;

      case 0x0C: { // two-byte escape
         float dx1, dx2, dx3, dx4, dx5, dx6, dy1, dy2, dy3, dy4, dy5, dy6;
         float dx, dy;
         int b1 = stbtt__buf_get8(&b);
         switch (b1) {
         // @TODO These "flex" implementations ignore the flex-depth and resolution,
         // and always draw beziers.
         case 0x22: // hflex
            if (sp < 7) return STBTT__CSERR("hflex stack");
            dx1 = s[0];
            dx2 = s[1];
            dy2 = s[2];
            dx3 = s[3];
            dx4 = s[4];
            dx5 = s[5];
            dx6 = s[6];
            stbtt__csctx_rccurve_to(c, dx1, 0, dx2, dy2, dx3, 0);
            stbtt__csctx_rccurve_to(c, dx4, 0, dx5, -dy2, dx6, 0);
            break;

         case 0x23: // flex
            if (sp < 13) return STBTT__CSERR("flex stack");
            dx1 = s[0];
            dy1 = s[1];
            dx2 = s[2];
            dy2 = s[3];
            dx3 = s[4];
            dy3 = s[5];
            dx4 = s[6];
            dy4 = s[7];
            dx5 = s[8];
            dy5 = s[9];
            dx6 = s[10];
            dy6 = s[11];
            //fd is s[12]
            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);
            stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);
            break;

         case 0x24: // hflex1
            if (sp < 9) return STBTT__CSERR("hflex1 stack");
            dx1 = s[0];
            dy1 = s[1];
            dx2 = s[2];
            dy2 = s[3];
            dx3 = s[4];
            dx4 = s[5];
            dx5 = s[6];
            dy5 = s[7];
            dx6 = s[8];
            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, 0);
            stbtt__csctx_rccurve_to(c, dx4, 0, dx5, dy5, dx6, -(dy1+dy2+dy5));
            break;

         case 0x25: // flex1
            if (sp < 11) return STBTT__CSERR("flex1 stack");
            dx1 = s[0];
            dy1 = s[1];
            dx2 = s[2];
            dy2 = s[3];
            dx3 = s[4];
            dy3 = s[5];
            dx4 = s[6];
            dy4 = s[7];
            dx5 = s[8];
            dy5 = s[9];
            dx6 = dy6 = s[10];
            dx = dx1+dx2+dx3+dx4+dx5;
            dy = dy1+dy2+dy3+dy4+dy5;
            if (STBTT_fabs(dx) > STBTT_fabs(dy))
               dy6 = -dy;
            else
               dx6 = -dx;
            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);
            stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);
            break;

         default:
            return STBTT__CSERR("unimplemented");
         }
      } break;

      default:
         if (b0 != 255 && b0 != 28 && (b0 < 32 || b0 > 254))
            return STBTT__CSERR("reserved operator");

         // push immediate
         if (b0 == 255) {
            f = (float)(stbtt_int32)stbtt__buf_get32(&b) / 0x10000;
         } else {
            stbtt__buf_skip(&b, -1);
            f = (float)(stbtt_int16)stbtt__cff_int(&b);
         }
         if (sp >= 48) return STBTT__CSERR("push stack overflow");
         s[sp++] = f;
         clear_stack = 0;
         break;
      }
      if (clear_stack) sp = 0;
   }
   return STBTT__CSERR("no endchar");

#undef STBTT__CSERR
}

static int stbtt__GetGlyphShapeT2(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
{
   // runs the charstring twice, once to count and once to output (to avoid realloc)
   stbtt__csctx count_ctx = STBTT__CSCTX_INIT(1);
   stbtt__csctx output_ctx = STBTT__CSCTX_INIT(0);
   if (stbtt__run_charstring(info, glyph_index, &count_ctx)) {
      *pvertices = (stbtt_vertex*)STBTT_malloc(count_ctx.num_vertices*sizeof(stbtt_vertex), info->userdata);
      output_ctx.pvertices = *pvertices;
      if (stbtt__run_charstring(info, glyph_index, &output_ctx)) {
         STBTT_assert(output_ctx.num_vertices == count_ctx.num_vertices);
         return output_ctx.num_vertices;
      }
   }
   *pvertices = NULL;
   return 0;
}

static int stbtt__GetGlyphInfoT2(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)
{
   stbtt__csctx c = STBTT__CSCTX_INIT(1);
   int r = stbtt__run_charstring(info, glyph_index, &c);
   if (x0)  *x0 = r ? c.min_x : 0;
   if (y0)  *y0 = r ? c.min_y : 0;
   if (x1)  *x1 = r ? c.max_x : 0;
   if (y1)  *y1 = r ? c.max_y : 0;
   return r ? c.num_vertices : 0;
}

STBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
{
   if (!info->cff.size)
      return stbtt__GetGlyphShapeTT(info, glyph_index, pvertices);
   else
      return stbtt__GetGlyphShapeT2(info, glyph_index, pvertices);
}

STBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing)
{
   stbtt_uint16 numOfLongHorMetrics = ttUSHORT(info->data+info->hhea + 34);
   if (glyph_index < numOfLongHorMetrics) {
      if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*glyph_index);
      if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*glyph_index + 2);
   } else {
      if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*(numOfLongHorMetrics-1));
      if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*numOfLongHorMetrics + 2*(glyph_index - numOfLongHorMetrics));
   }
}

static int  stbtt__GetGlyphKernInfoAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)
{
   stbtt_uint8 *data = info->data + info->kern;
   stbtt_uint32 needle, straw;
   int l, r, m;

   // we only look at the first table. it must be 'horizontal' and format 0.
   if (!info->kern)
      return 0;
   if (ttUSHORT(data+2) < 1) // number of tables, need at least 1
      return 0;
   if (ttUSHORT(data+8) != 1) // horizontal flag must be set in format
      return 0;

   l = 0;
   r = ttUSHORT(data+10) - 1;
   needle = glyph1 << 16 | glyph2;
   while (l <= r) {
      m = (l + r) >> 1;
      straw = ttULONG(data+18+(m*6)); // note: unaligned read
      if (needle < straw)
         r = m - 1;
      else if (needle > straw)
         l = m + 1;
      else
         return ttSHORT(data+22+(m*6));
   }
   return 0;
}

static stbtt_int32  stbtt__GetCoverageIndex(stbtt_uint8 *coverageTable, int glyph)
{
    stbtt_uint16 coverageFormat = ttUSHORT(coverageTable);
    switch(coverageFormat) {
        case 1: {
            stbtt_uint16 glyphCount = ttUSHORT(coverageTable + 2);

            // Binary search.
            stbtt_int32 l=0, r=glyphCount-1, m;
            int straw, needle=glyph;
            while (l <= r) {
                stbtt_uint8 *glyphArray = coverageTable + 4;
                stbtt_uint16 glyphID;
                m = (l + r) >> 1;
                glyphID = ttUSHORT(glyphArray + 2 * m);
                straw = glyphID;
                if (needle < straw)
                    r = m - 1;
                else if (needle > straw)
                    l = m + 1;
                else {
                     return m;
                }
            }
        } break;

        case 2: {
            stbtt_uint16 rangeCount = ttUSHORT(coverageTable + 2);
            stbtt_uint8 *rangeArray = coverageTable + 4;

            // Binary search.
            stbtt_int32 l=0, r=rangeCount-1, m;
            int strawStart, strawEnd, needle=glyph;
            while (l <= r) {
                stbtt_uint8 *rangeRecord;
                m = (l + r) >> 1;
                rangeRecord = rangeArray + 6 * m;
                strawStart = ttUSHORT(rangeRecord);
                strawEnd = ttUSHORT(rangeRecord + 2);
                if (needle < strawStart)
                    r = m - 1;
                else if (needle > strawEnd)
                    l = m + 1;
                else {
                    stbtt_uint16 startCoverageIndex = ttUSHORT(rangeRecord + 4);
                    return startCoverageIndex + glyph - strawStart;
                }
            }
        } break;

        default: {
            // There are no other cases.
            STBTT_assert(0);
        } break;
    }

    return -1;
}

static stbtt_int32  stbtt__GetGlyphClass(stbtt_uint8 *classDefTable, int glyph)
{
    stbtt_uint16 classDefFormat = ttUSHORT(classDefTable);
    switch(classDefFormat)
    {
        case 1: {
            stbtt_uint16 startGlyphID = ttUSHORT(classDefTable + 2);
            stbtt_uint16 glyphCount = ttUSHORT(classDefTable + 4);
            stbtt_uint8 *classDef1ValueArray = classDefTable + 6;

            if (glyph >= startGlyphID && glyph < startGlyphID + glyphCount)
                return (stbtt_int32)ttUSHORT(classDef1ValueArray + 2 * (glyph - startGlyphID));

            classDefTable = classDef1ValueArray + 2 * glyphCount;
        } break;

        case 2: {
            stbtt_uint16 classRangeCount = ttUSHORT(classDefTable + 2);
            stbtt_uint8 *classRangeRecords = classDefTable + 4;

            // Binary search.
            stbtt_int32 l=0, r=classRangeCount-1, m;
            int strawStart, strawEnd, needle=glyph;
            while (l <= r) {
                stbtt_uint8 *classRangeRecord;
                m = (l + r) >> 1;
                classRangeRecord = classRangeRecords + 6 * m;
                strawStart = ttUSHORT(classRangeRecord);
                strawEnd = ttUSHORT(classRangeRecord + 2);
                if (needle < strawStart)
                    r = m - 1;
                else if (needle > strawEnd)
                    l = m + 1;
                else
                    return (stbtt_int32)ttUSHORT(classRangeRecord + 4);
            }

            classDefTable = classRangeRecords + 6 * classRangeCount;
        } break;

        default: {
            // There are no other cases.
            STBTT_assert(0);
        } break;
    }

    return -1;
}

// Define to STBTT_assert(x) if you want to break on unimplemented formats.
#define STBTT_GPOS_TODO_assert(x)

static stbtt_int32  stbtt__GetGlyphGPOSInfoAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)
{
    stbtt_uint16 lookupListOffset;
    stbtt_uint8 *lookupList;
    stbtt_uint16 lookupCount;
    stbtt_uint8 *data;
    stbtt_int32 i;

    if (!info->gpos) return 0;

    data = info->data + info->gpos;

    if (ttUSHORT(data+0) != 1) return 0; // Major version 1
    if (ttUSHORT(data+2) != 0) return 0; // Minor version 0

    lookupListOffset = ttUSHORT(data+8);
    lookupList = data + lookupListOffset;
    lookupCount = ttUSHORT(lookupList);

    for (i=0; i<lookupCount; ++i) {
        stbtt_uint16 lookupOffset = ttUSHORT(lookupList + 2 + 2 * i);
        stbtt_uint8 *lookupTable = lookupList + lookupOffset;

        stbtt_uint16 lookupType = ttUSHORT(lookupTable);
        stbtt_uint16 subTableCount = ttUSHORT(lookupTable + 4);
        stbtt_uint8 *subTableOffsets = lookupTable + 6;
        switch(lookupType) {
            case 2: { // Pair Adjustment Positioning Subtable
                stbtt_int32 sti;
                for (sti=0; sti<subTableCount; sti++) {
                    stbtt_uint16 subtableOffset = ttUSHORT(subTableOffsets + 2 * sti);
                    stbtt_uint8 *table = lookupTable + subtableOffset;
                    stbtt_uint16 posFormat = ttUSHORT(table);
                    stbtt_uint16 coverageOffset = ttUSHORT(table + 2);
                    stbtt_int32 coverageIndex = stbtt__GetCoverageIndex(table + coverageOffset, glyph1);
                    if (coverageIndex == -1) continue;

                    switch (posFormat) {
                        case 1: {
                            stbtt_int32 l, r, m;
                            int straw, needle;
                            stbtt_uint16 valueFormat1 = ttUSHORT(table + 4);
                            stbtt_uint16 valueFormat2 = ttUSHORT(table + 6);
                            stbtt_int32 valueRecordPairSizeInBytes = 2;
                            stbtt_uint16 pairSetCount = ttUSHORT(table + 8);
                            stbtt_uint16 pairPosOffset = ttUSHORT(table + 10 + 2 * coverageIndex);
                            stbtt_uint8 *pairValueTable = table + pairPosOffset;
                            stbtt_uint16 pairValueCount = ttUSHORT(pairValueTable);
                            stbtt_uint8 *pairValueArray = pairValueTable + 2;
                            // TODO: Support more formats.
                            STBTT_GPOS_TODO_assert(valueFormat1 == 4);
                            if (valueFormat1 != 4) return 0;
                            STBTT_GPOS_TODO_assert(valueFormat2 == 0);
                            if (valueFormat2 != 0) return 0;

                            STBTT_assert(coverageIndex < pairSetCount);
                            STBTT__NOTUSED(pairSetCount);

                            needle=glyph2;
                            r=pairValueCount-1;
                            l=0;

                            // Binary search.
                            while (l <= r) {
                                stbtt_uint16 secondGlyph;
                                stbtt_uint8 *pairValue;
                                m = (l + r) >> 1;
                                pairValue = pairValueArray + (2 + valueRecordPairSizeInBytes) * m;
                                secondGlyph = ttUSHORT(pairValue);
                                straw = secondGlyph;
                                if (needle < straw)
                                    r = m - 1;
                                else if (needle > straw)
                                    l = m + 1;
                                else {
                                    stbtt_int16 xAdvance = ttSHORT(pairValue + 2);
                                    return xAdvance;
                                }
                            }
                        } break;

                        case 2: {
                            stbtt_uint16 valueFormat1 = ttUSHORT(table + 4);
                            stbtt_uint16 valueFormat2 = ttUSHORT(table + 6);

                            stbtt_uint16 classDef1Offset = ttUSHORT(table + 8);
                            stbtt_uint16 classDef2Offset = ttUSHORT(table + 10);
                            int glyph1class = stbtt__GetGlyphClass(table + classDef1Offset, glyph1);
                            int glyph2class = stbtt__GetGlyphClass(table + classDef2Offset, glyph2);

                            stbtt_uint16 class1Count = ttUSHORT(table + 12);
                            stbtt_uint16 class2Count = ttUSHORT(table + 14);
                            STBTT_assert(glyph1class < class1Count);
                            STBTT_assert(glyph2class < class2Count);

                            // TODO: Support more formats.
                            STBTT_GPOS_TODO_assert(valueFormat1 == 4);
                            if (valueFormat1 != 4) return 0;
                            STBTT_GPOS_TODO_assert(valueFormat2 == 0);
                            if (valueFormat2 != 0) return 0;

                            if (glyph1class >= 0 && glyph1class < class1Count && glyph2class >= 0 && glyph2class < class2Count) {
                                stbtt_uint8 *class1Records = table + 16;
                                stbtt_uint8 *class2Records = class1Records + 2 * (glyph1class * class2Count);
                                stbtt_int16 xAdvance = ttSHORT(class2Records + 2 * glyph2class);
                                return xAdvance;
                            }
                        } break;

                        default: {
                            // There are no other cases.
                            STBTT_assert(0);
                            break;
                        };
                    }
                }
                break;
            };

            default:
                // TODO: Implement other stuff.
                break;
        }
    }

    return 0;
}

STBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int g1, int g2)
{
   int xAdvance = 0;

   if (info->gpos)
      xAdvance += stbtt__GetGlyphGPOSInfoAdvance(info, g1, g2);

   if (info->kern)
      xAdvance += stbtt__GetGlyphKernInfoAdvance(info, g1, g2);

   return xAdvance;
}

STBTT_DEF int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2)
{
   if (!info->kern && !info->gpos) // if no kerning table, don't waste time looking up both codepoint->glyphs
      return 0;
   return stbtt_GetGlyphKernAdvance(info, stbtt_FindGlyphIndex(info,ch1), stbtt_FindGlyphIndex(info,ch2));
}

STBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing)
{
   stbtt_GetGlyphHMetrics(info, stbtt_FindGlyphIndex(info,codepoint), advanceWidth, leftSideBearing);
}

STBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap)
{
   if (ascent ) *ascent  = ttSHORT(info->data+info->hhea + 4);
   if (descent) *descent = ttSHORT(info->data+info->hhea + 6);
   if (lineGap) *lineGap = ttSHORT(info->data+info->hhea + 8);
}

STBTT_DEF int  stbtt_GetFontVMetricsOS2(const stbtt_fontinfo *info, int *typoAscent, int *typoDescent, int *typoLineGap)
{
   int tab = stbtt__find_table(info->data, info->fontstart, "OS/2");
   if (!tab)
      return 0;
   if (typoAscent ) *typoAscent  = ttSHORT(info->data+tab + 68);
   if (typoDescent) *typoDescent = ttSHORT(info->data+tab + 70);
   if (typoLineGap) *typoLineGap = ttSHORT(info->data+tab + 72);
   return 1;
}

STBTT_DEF void stbtt_GetFontBoundingBox(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1)
{
   *x0 = ttSHORT(info->data + info->head + 36);
   *y0 = ttSHORT(info->data + info->head + 38);
   *x1 = ttSHORT(info->data + info->head + 40);
   *y1 = ttSHORT(info->data + info->head + 42);
}

STBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float height)
{
   int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);
   return (float) height / fheight;
}

STBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels)
{
   int unitsPerEm = ttUSHORT(info->data + info->head + 18);
   return pixels / unitsPerEm;
}

STBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *v)
{
   STBTT_free(v, info->userdata);
}

//////////////////////////////////////////////////////////////////////////////
//
// antialiasing software rasterizer
//

STBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)
{
   int x0=0,y0=0,x1,y1; // =0 suppresses compiler warning
   if (!stbtt_GetGlyphBox(font, glyph, &x0,&y0,&x1,&y1)) {
      // e.g. space character
      if (ix0) *ix0 = 0;
      if (iy0) *iy0 = 0;
      if (ix1) *ix1 = 0;
      if (iy1) *iy1 = 0;
   } else {
      // move to integral bboxes (treating pixels as little squares, what pixels get touched)?
      if (ix0) *ix0 = STBTT_ifloor( x0 * scale_x + shift_x);
      if (iy0) *iy0 = STBTT_ifloor(-y1 * scale_y + shift_y);
      if (ix1) *ix1 = STBTT_iceil ( x1 * scale_x + shift_x);
      if (iy1) *iy1 = STBTT_iceil (-y0 * scale_y + shift_y);
   }
}

STBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)
{
   stbtt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y,0.0f,0.0f, ix0, iy0, ix1, iy1);
}

STBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)
{
   stbtt_GetGlyphBitmapBoxSubpixel(font, stbtt_FindGlyphIndex(font,codepoint), scale_x, scale_y,shift_x,shift_y, ix0,iy0,ix1,iy1);
}

STBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)
{
   stbtt_GetCodepointBitmapBoxSubpixel(font, codepoint, scale_x, scale_y,0.0f,0.0f, ix0,iy0,ix1,iy1);
}

//////////////////////////////////////////////////////////////////////////////
//
//  Rasterizer

typedef struct stbtt__hheap_chunk
{
   struct stbtt__hheap_chunk *next;
} stbtt__hheap_chunk;

typedef struct stbtt__hheap
{
   struct stbtt__hheap_chunk *head;
   void   *first_free;
   int    num_remaining_in_head_chunk;
} stbtt__hheap;

static void *stbtt__hheap_alloc(stbtt__hheap *hh, size_t size, void *userdata)
{
   if (hh->first_free) {
      void *p = hh->first_free;
      hh->first_free = * (void **) p;
      return p;
   } else {
      if (hh->num_remaining_in_head_chunk == 0) {
         int count = (size < 32 ? 2000 : size < 128 ? 800 : 100);
         stbtt__hheap_chunk *c = (stbtt__hheap_chunk *) STBTT_malloc(sizeof(stbtt__hheap_chunk) + size * count, userdata);
         if (c == NULL)
            return NULL;
         c->next = hh->head;
         hh->head = c;
         hh->num_remaining_in_head_chunk = count;
      }
      --hh->num_remaining_in_head_chunk;
      return (char *) (hh->head) + sizeof(stbtt__hheap_chunk) + size * hh->num_remaining_in_head_chunk;
   }
}

static void stbtt__hheap_free(stbtt__hheap *hh, void *p)
{
   *(void **) p = hh->first_free;
   hh->first_free = p;
}

static void stbtt__hheap_cleanup(stbtt__hheap *hh, void *userdata)
{
   stbtt__hheap_chunk *c = hh->head;
   while (c) {
      stbtt__hheap_chunk *n = c->next;
      STBTT_free(c, userdata);
      c = n;
   }
}

typedef struct stbtt__edge {
   float x0,y0, x1,y1;
   int invert;
} stbtt__edge;


typedef struct stbtt__active_edge
{
   struct stbtt__active_edge *next;
   #if STBTT_RASTERIZER_VERSION==1
   int x,dx;
   float ey;
   int direction;
   #elif STBTT_RASTERIZER_VERSION==2
   float fx,fdx,fdy;
   float direction;
   float sy;
   float ey;
   #else
   #error "Unrecognized value of STBTT_RASTERIZER_VERSION"
   #endif
} stbtt__active_edge;

#if STBTT_RASTERIZER_VERSION == 1
#define STBTT_FIXSHIFT   10
#define STBTT_FIX        (1 << STBTT_FIXSHIFT)
#define STBTT_FIXMASK    (STBTT_FIX-1)

static stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)
{
   stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);
   float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);
   STBTT_assert(z != NULL);
   if (!z) return z;
   
   // round dx down to avoid overshooting
   if (dxdy < 0)
      z->dx = -STBTT_ifloor(STBTT_FIX * -dxdy);
   else
      z->dx = STBTT_ifloor(STBTT_FIX * dxdy);

   z->x = STBTT_ifloor(STBTT_FIX * e->x0 + z->dx * (start_point - e->y0)); // use z->dx so when we offset later it's by the same amount
   z->x -= off_x * STBTT_FIX;

   z->ey = e->y1;
   z->next = 0;
   z->direction = e->invert ? 1 : -1;
   return z;
}
#elif STBTT_RASTERIZER_VERSION == 2
static stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)
{
   stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);
   float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);
   STBTT_assert(z != NULL);
   //STBTT_assert(e->y0 <= start_point);
   if (!z) return z;
   z->fdx = dxdy;
   z->fdy = dxdy != 0.0f ? (1.0f/dxdy) : 0.0f;
   z->fx = e->x0 + dxdy * (start_point - e->y0);
   z->fx -= off_x;
   z->direction = e->invert ? 1.0f : -1.0f;
   z->sy = e->y0;
   z->ey = e->y1;
   z->next = 0;
   return z;
}
#else
#error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif

#if STBTT_RASTERIZER_VERSION == 1
// note: this routine clips fills that extend off the edges... ideally this
// wouldn't happen, but it could happen if the truetype glyph bounding boxes
// are wrong, or if the user supplies a too-small bitmap
static void stbtt__fill_active_edges(unsigned char *scanline, int len, stbtt__active_edge *e, int max_weight)
{
   // non-zero winding fill
   int x0=0, w=0;

   while (e) {
      if (w == 0) {
         // if we're currently at zero, we need to record the edge start point
         x0 = e->x; w += e->direction;
      } else {
         int x1 = e->x; w += e->direction;
         // if we went to zero, we need to draw
         if (w == 0) {
            int i = x0 >> STBTT_FIXSHIFT;
            int j = x1 >> STBTT_FIXSHIFT;

            if (i < len && j >= 0) {
               if (i == j) {
                  // x0,x1 are the same pixel, so compute combined coverage
                  scanline[i] = scanline[i] + (stbtt_uint8) ((x1 - x0) * max_weight >> STBTT_FIXSHIFT);
               } else {
                  if (i >= 0) // add antialiasing for x0
                     scanline[i] = scanline[i] + (stbtt_uint8) (((STBTT_FIX - (x0 & STBTT_FIXMASK)) * max_weight) >> STBTT_FIXSHIFT);
                  else
                     i = -1; // clip

                  if (j < len) // add antialiasing for x1
                     scanline[j] = scanline[j] + (stbtt_uint8) (((x1 & STBTT_FIXMASK) * max_weight) >> STBTT_FIXSHIFT);
                  else
                     j = len; // clip

                  for (++i; i < j; ++i) // fill pixels between x0 and x1
                     scanline[i] = scanline[i] + (stbtt_uint8) max_weight;
               }
            }
         }
      }
      
      e = e->next;
   }
}

static void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)
{
   stbtt__hheap hh = { 0, 0, 0 };
   stbtt__active_edge *active = NULL;
   int y,j=0;
   int max_weight = (255 / vsubsample);  // weight per vertical scanline
   int s; // vertical subsample index
   unsigned char scanline_data[512], *scanline;

   if (result->w > 512)
      scanline = (unsigned char *) STBTT_malloc(result->w, userdata);
   else
      scanline = scanline_data;

   y = off_y * vsubsample;
   e[n].y0 = (off_y + result->h) * (float) vsubsample + 1;

   while (j < result->h) {
      STBTT_memset(scanline, 0, result->w);
      for (s=0; s < vsubsample; ++s) {
         // find center of pixel for this scanline
         float scan_y = y + 0.5f;
         stbtt__active_edge **step = &active;

         // update all active edges;
         // remove all active edges that terminate before the center of this scanline
         while (*step) {
            stbtt__active_edge * z = *step;
            if (z->ey <= scan_y) {
               *step = z->next; // delete from list
               STBTT_assert(z->direction);
               z->direction = 0;
               stbtt__hheap_free(&hh, z);
            } else {
               z->x += z->dx; // advance to position for current scanline
               step = &((*step)->next); // advance through list
            }
         }

         // resort the list if needed
         for(;;) {
            int changed=0;
            step = &active;
            while (*step && (*step)->next) {
               if ((*step)->x > (*step)->next->x) {
                  stbtt__active_edge *t = *step;
                  stbtt__active_edge *q = t->next;

                  t->next = q->next;
                  q->next = t;
                  *step = q;
                  changed = 1;
               }
               step = &(*step)->next;
            }
            if (!changed) break;
         }

         // insert all edges that start before the center of this scanline -- omit ones that also end on this scanline
         while (e->y0 <= scan_y) {
            if (e->y1 > scan_y) {
               stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y, userdata);
               if (z != NULL) {
                  // find insertion point
                  if (active == NULL)
                     active = z;
                  else if (z->x < active->x) {
                     // insert at front
                     z->next = active;
                     active = z;
                  } else {
                     // find thing to insert AFTER
                     stbtt__active_edge *p = active;
                     while (p->next && p->next->x < z->x)
                        p = p->next;
                     // at this point, p->next->x is NOT < z->x
                     z->next = p->next;
                     p->next = z;
                  }
               }
            }
            ++e;
         }

         // now process all active edges in XOR fashion
         if (active)
            stbtt__fill_active_edges(scanline, result->w, active, max_weight);

         ++y;
      }
      STBTT_memcpy(result->pixels + j * result->stride, scanline, result->w);
      ++j;
   }

   stbtt__hheap_cleanup(&hh, userdata);

   if (scanline != scanline_data)
      STBTT_free(scanline, userdata);
}

#elif STBTT_RASTERIZER_VERSION == 2

// the edge passed in here does not cross the vertical line at x or the vertical line at x+1
// (i.e. it has already been clipped to those)
static void stbtt__handle_clipped_edge(float *scanline, int x, stbtt__active_edge *e, float x0, float y0, float x1, float y1)
{
   if (y0 == y1) return;
   STBTT_assert(y0 < y1);
   STBTT_assert(e->sy <= e->ey);
   if (y0 > e->ey) return;
   if (y1 < e->sy) return;
   if (y0 < e->sy) {
      x0 += (x1-x0) * (e->sy - y0) / (y1-y0);
      y0 = e->sy;
   }
   if (y1 > e->ey) {
      x1 += (x1-x0) * (e->ey - y1) / (y1-y0);
      y1 = e->ey;
   }

   if (x0 == x)
      STBTT_assert(x1 <= x+1);
   else if (x0 == x+1)
      STBTT_assert(x1 >= x);
   else if (x0 <= x)
      STBTT_assert(x1 <= x);
   else if (x0 >= x+1)
      STBTT_assert(x1 >= x+1);
   else
      STBTT_assert(x1 >= x && x1 <= x+1);

   if (x0 <= x && x1 <= x)
      scanline[x] += e->direction * (y1-y0);
   else if (x0 >= x+1 && x1 >= x+1)
      ;
   else {
      STBTT_assert(x0 >= x && x0 <= x+1 && x1 >= x && x1 <= x+1);
      scanline[x] += e->direction * (y1-y0) * (1-((x0-x)+(x1-x))/2); // coverage = 1 - average x position
   }
}

static void stbtt__fill_active_edges_new(float *scanline, float *scanline_fill, int len, stbtt__active_edge *e, float y_top)
{
   float y_bottom = y_top+1;

   while (e) {
      // brute force every pixel

      // compute intersection points with top & bottom
      STBTT_assert(e->ey >= y_top);

      if (e->fdx == 0) {
         float x0 = e->fx;
         if (x0 < len) {
            if (x0 >= 0) {
               stbtt__handle_clipped_edge(scanline,(int) x0,e, x0,y_top, x0,y_bottom);
               stbtt__handle_clipped_edge(scanline_fill-1,(int) x0+1,e, x0,y_top, x0,y_bottom);
            } else {
               stbtt__handle_clipped_edge(scanline_fill-1,0,e, x0,y_top, x0,y_bottom);
            }
         }
      } else {
         float x0 = e->fx;
         float dx = e->fdx;
         float xb = x0 + dx;
         float x_top, x_bottom;
         float sy0,sy1;
         float dy = e->fdy;
         STBTT_assert(e->sy <= y_bottom && e->ey >= y_top);

         // compute endpoints of line segment clipped to this scanline (if the
         // line segment starts on this scanline. x0 is the intersection of the
         // line with y_top, but that may be off the line segment.
         if (e->sy > y_top) {
            x_top = x0 + dx * (e->sy - y_top);
            sy0 = e->sy;
         } else {
            x_top = x0;
            sy0 = y_top;
         }
         if (e->ey < y_bottom) {
            x_bottom = x0 + dx * (e->ey - y_top);
            sy1 = e->ey;
         } else {
            x_bottom = xb;
            sy1 = y_bottom;
         }

         if (x_top >= 0 && x_bottom >= 0 && x_top < len && x_bottom < len) {
            // from here on, we don't have to range check x values

            if ((int) x_top == (int) x_bottom) {
               float height;
               // simple case, only spans one pixel
               int x = (int) x_top;
               height = sy1 - sy0;
               STBTT_assert(x >= 0 && x < len);
               scanline[x] += e->direction * (1-((x_top - x) + (x_bottom-x))/2)  * height;
               scanline_fill[x] += e->direction * height; // everything right of this pixel is filled
            } else {
               int x,x1,x2;
               float y_crossing, step, sign, area;
               // covers 2+ pixels
               if (x_top > x_bottom) {
                  // flip scanline vertically; signed area is the same
                  float t;
                  sy0 = y_bottom - (sy0 - y_top);
                  sy1 = y_bottom - (sy1 - y_top);
                  t = sy0, sy0 = sy1, sy1 = t;
                  t = x_bottom, x_bottom = x_top, x_top = t;
                  dx = -dx;
                  dy = -dy;
                  t = x0, x0 = xb, xb = t;
               }

               x1 = (int) x_top;
               x2 = (int) x_bottom;
               // compute intersection with y axis at x1+1
               y_crossing = (x1+1 - x0) * dy + y_top;

               sign = e->direction;
               // area of the rectangle covered from y0..y_crossing
               area = sign * (y_crossing-sy0);
               // area of the triangle (x_top,y0), (x+1,y0), (x+1,y_crossing)
               scanline[x1] += area * (1-((x_top - x1)+(x1+1-x1))/2);

               step = sign * dy;
               for (x = x1+1; x < x2; ++x) {
                  scanline[x] += area + step/2;
                  area += step;
               }
               y_crossing += dy * (x2 - (x1+1));

               STBTT_assert(STBTT_fabs(area) <= 1.01f);

               scanline[x2] += area + sign * (1-((x2-x2)+(x_bottom-x2))/2) * (sy1-y_crossing);

               scanline_fill[x2] += sign * (sy1-sy0);
            }
         } else {
            // if edge goes outside of box we're drawing, we require
            // clipping logic. since this does not match the intended use
            // of this library, we use a different, very slow brute
            // force implementation
            int x;
            for (x=0; x < len; ++x) {
               // cases:
               //
               // there can be up to two intersections with the pixel. any intersection
               // with left or right edges can be handled by splitting into two (or three)
               // regions. intersections with top & bottom do not necessitate case-wise logic.
               //
               // the old way of doing this found the intersections with the left & right edges,
               // then used some simple logic to produce up to three segments in sorted order
               // from top-to-bottom. however, this had a problem: if an x edge was epsilon
               // across the x border, then the corresponding y position might not be distinct
               // from the other y segment, and it might ignored as an empty segment. to avoid
               // that, we need to explicitly produce segments based on x positions.

               // rename variables to clearly-defined pairs
               float y0 = y_top;
               float x1 = (float) (x);
               float x2 = (float) (x+1);
               float x3 = xb;
               float y3 = y_bottom;

               // x = e->x + e->dx * (y-y_top)
               // (y-y_top) = (x - e->x) / e->dx
               // y = (x - e->x) / e->dx + y_top
               float y1 = (x - x0) / dx + y_top;
               float y2 = (x+1 - x0) / dx + y_top;

               if (x0 < x1 && x3 > x2) {         // three segments descending down-right
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
               } else if (x3 < x1 && x0 > x2) {  // three segments descending down-left
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
               } else if (x0 < x1 && x3 > x1) {  // two segments across x, down-right
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
               } else if (x3 < x1 && x0 > x1) {  // two segments across x, down-left
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
               } else if (x0 < x2 && x3 > x2) {  // two segments across x+1, down-right
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
               } else if (x3 < x2 && x0 > x2) {  // two segments across x+1, down-left
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
               } else {  // one segment
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x3,y3);
               }
            }
         }
      }
      e = e->next;
   }
}

// directly AA rasterize edges w/o supersampling
static void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)
{
   stbtt__hheap hh = { 0, 0, 0 };
   stbtt__active_edge *active = NULL;
   int y,j=0, i;
   float scanline_data[129], *scanline, *scanline2;

   STBTT__NOTUSED(vsubsample);

   if (result->w > 64)
      scanline = (float *) STBTT_malloc((result->w*2+1) * sizeof(float), userdata);
   else
      scanline = scanline_data;

   scanline2 = scanline + result->w;

   y = off_y;
   e[n].y0 = (float) (off_y + result->h) + 1;

   while (j < result->h) {
      // find center of pixel for this scanline
      float scan_y_top    = y + 0.0f;
      float scan_y_bottom = y + 1.0f;
      stbtt__active_edge **step = &active;

      STBTT_memset(scanline , 0, result->w*sizeof(scanline[0]));
      STBTT_memset(scanline2, 0, (result->w+1)*sizeof(scanline[0]));

      // update all active edges;
      // remove all active edges that terminate before the top of this scanline
      while (*step) {
         stbtt__active_edge * z = *step;
         if (z->ey <= scan_y_top) {
            *step = z->next; // delete from list
            STBTT_assert(z->direction);
            z->direction = 0;
            stbtt__hheap_free(&hh, z);
         } else {
            step = &((*step)->next); // advance through list
         }
      }

      // insert all edges that start before the bottom of this scanline
      while (e->y0 <= scan_y_bottom) {
         if (e->y0 != e->y1) {
            stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y_top, userdata);
            if (z != NULL) {
               STBTT_assert(z->ey >= scan_y_top);
               // insert at front
               z->next = active;
               active = z;
            }
         }
         ++e;
      }

      // now process all active edges
      if (active)
         stbtt__fill_active_edges_new(scanline, scanline2+1, result->w, active, scan_y_top);

      {
         float sum = 0;
         for (i=0; i < result->w; ++i) {
            float k;
            int m;
            sum += scanline2[i];
            k = scanline[i] + sum;
            k = (float) STBTT_fabs(k)*255 + 0.5f;
            m = (int) k;
            if (m > 255) m = 255;
            result->pixels[j*result->stride + i] = (unsigned char) m;
         }
      }
      // advance all the edges
      step = &active;
      while (*step) {
         stbtt__active_edge *z = *step;
         z->fx += z->fdx; // advance to position for current scanline
         step = &((*step)->next); // advance through list
      }

      ++y;
      ++j;
   }

   stbtt__hheap_cleanup(&hh, userdata);

   if (scanline != scanline_data)
      STBTT_free(scanline, userdata);
}
#else
#error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif

#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)

static void stbtt__sort_edges_ins_sort(stbtt__edge *p, int n)
{
   int i,j;
   for (i=1; i < n; ++i) {
      stbtt__edge t = p[i], *a = &t;
      j = i;
      while (j > 0) {
         stbtt__edge *b = &p[j-1];
         int c = STBTT__COMPARE(a,b);
         if (!c) break;
         p[j] = p[j-1];
         --j;
      }
      if (i != j)
         p[j] = t;
   }
}

static void stbtt__sort_edges_quicksort(stbtt__edge *p, int n)
{
   /* threshhold for transitioning to insertion sort */
   while (n > 12) {
      stbtt__edge t;
      int c01,c12,c,m,i,j;

      /* compute median of three */
      m = n >> 1;
      c01 = STBTT__COMPARE(&p[0],&p[m]);
      c12 = STBTT__COMPARE(&p[m],&p[n-1]);
      /* if 0 >= mid >= end, or 0 < mid < end, then use mid */
      if (c01 != c12) {
         /* otherwise, we'll need to swap something else to middle */
         int z;
         c = STBTT__COMPARE(&p[0],&p[n-1]);
         /* 0>mid && mid<n:  0>n => n; 0<n => 0 */
         /* 0<mid && mid>n:  0>n => 0; 0<n => n */
         z = (c == c12) ? 0 : n-1;
         t = p[z];
         p[z] = p[m];
         p[m] = t;
      }
      /* now p[m] is the median-of-three */
      /* swap it to the beginning so it won't move around */
      t = p[0];
      p[0] = p[m];
      p[m] = t;

      /* partition loop */
      i=1;
      j=n-1;
      for(;;) {
         /* handling of equality is crucial here */
         /* for sentinels & efficiency with duplicates */
         for (;;++i) {
            if (!STBTT__COMPARE(&p[i], &p[0])) break;
         }
         for (;;--j) {
            if (!STBTT__COMPARE(&p[0], &p[j])) break;
         }
         /* make sure we haven't crossed */
         if (i >= j) break;
         t = p[i];
         p[i] = p[j];
         p[j] = t;

         ++i;
         --j;
      }
      /* recurse on smaller side, iterate on larger */
      if (j < (n-i)) {
         stbtt__sort_edges_quicksort(p,j);
         p = p+i;
         n = n-i;
      } else {
         stbtt__sort_edges_quicksort(p+i, n-i);
         n = j;
      }
   }
}

static void stbtt__sort_edges(stbtt__edge *p, int n)
{
   stbtt__sort_edges_quicksort(p, n);
   stbtt__sort_edges_ins_sort(p, n);
}

typedef struct
{
   float x,y;
} stbtt__point;

static void stbtt__rasterize(stbtt__bitmap *result, stbtt__point *pts, int *wcount, int windings, float scale_x, float scale_y, float shift_x, float shift_y, int off_x, int off_y, int invert, void *userdata)
{
   float y_scale_inv = invert ? -scale_y : scale_y;
   stbtt__edge *e;
   int n,i,j,k,m;
#if STBTT_RASTERIZER_VERSION == 1
   int vsubsample = result->h < 8 ? 15 : 5;
#elif STBTT_RASTERIZER_VERSION == 2
   int vsubsample = 1;
#else
   #error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif
   // vsubsample should divide 255 evenly; otherwise we won't reach full opacity

   // now we have to blow out the windings into explicit edge lists
   n = 0;
   for (i=0; i < windings; ++i)
      n += wcount[i];

   e = (stbtt__edge *) STBTT_malloc(sizeof(*e) * (n+1), userdata); // add an extra one as a sentinel
   if (e == 0) return;
   n = 0;

   m=0;
   for (i=0; i < windings; ++i) {
      stbtt__point *p = pts + m;
      m += wcount[i];
      j = wcount[i]-1;
      for (k=0; k < wcount[i]; j=k++) {
         int a=k,b=j;
         // skip the edge if horizontal
         if (p[j].y == p[k].y)
            continue;
         // add edge from j to k to the list
         e[n].invert = 0;
         if (invert ? p[j].y > p[k].y : p[j].y < p[k].y) {
            e[n].invert = 1;
            a=j,b=k;
         }
         e[n].x0 = p[a].x * scale_x + shift_x;
         e[n].y0 = (p[a].y * y_scale_inv + shift_y) * vsubsample;
         e[n].x1 = p[b].x * scale_x + shift_x;
         e[n].y1 = (p[b].y * y_scale_inv + shift_y) * vsubsample;
         ++n;
      }
   }

   // now sort the edges by their highest point (should snap to integer, and then by x)
   //STBTT_sort(e, n, sizeof(e[0]), stbtt__edge_compare);
   stbtt__sort_edges(e, n);

   // now, traverse the scanlines and find the intersections on each scanline, use xor winding rule
   stbtt__rasterize_sorted_edges(result, e, n, vsubsample, off_x, off_y, userdata);

   STBTT_free(e, userdata);
}

static void stbtt__add_point(stbtt__point *points, int n, float x, float y)
{
   if (!points) return; // during first pass, it's unallocated
   points[n].x = x;
   points[n].y = y;
}

// tesselate until threshhold p is happy... @TODO warped to compensate for non-linear stretching
static int stbtt__tesselate_curve(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float objspace_flatness_squared, int n)
{
   // midpoint
   float mx = (x0 + 2*x1 + x2)/4;
   float my = (y0 + 2*y1 + y2)/4;
   // versus directly drawn line
   float dx = (x0+x2)/2 - mx;
   float dy = (y0+y2)/2 - my;
   if (n > 16) // 65536 segments on one curve better be enough!
      return 1;
   if (dx*dx+dy*dy > objspace_flatness_squared) { // half-pixel error allowed... need to be smaller if AA
      stbtt__tesselate_curve(points, num_points, x0,y0, (x0+x1)/2.0f,(y0+y1)/2.0f, mx,my, objspace_flatness_squared,n+1);
      stbtt__tesselate_curve(points, num_points, mx,my, (x1+x2)/2.0f,(y1+y2)/2.0f, x2,y2, objspace_flatness_squared,n+1);
   } else {
      stbtt__add_point(points, *num_points,x2,y2);
      *num_points = *num_points+1;
   }
   return 1;
}

static void stbtt__tesselate_cubic(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float x3, float y3, float objspace_flatness_squared, int n)
{
   // @TODO this "flatness" calculation is just made-up nonsense that seems to work well enough
   float dx0 = x1-x0;
   float dy0 = y1-y0;
   float dx1 = x2-x1;
   float dy1 = y2-y1;
   float dx2 = x3-x2;
   float dy2 = y3-y2;
   float dx = x3-x0;
   float dy = y3-y0;
   float longlen = (float) (STBTT_sqrt(dx0*dx0+dy0*dy0)+STBTT_sqrt(dx1*dx1+dy1*dy1)+STBTT_sqrt(dx2*dx2+dy2*dy2));
   float shortlen = (float) STBTT_sqrt(dx*dx+dy*dy);
   float flatness_squared = longlen*longlen-shortlen*shortlen;

   if (n > 16) // 65536 segments on one curve better be enough!
      return;

   if (flatness_squared > objspace_flatness_squared) {
      float x01 = (x0+x1)/2;
      float y01 = (y0+y1)/2;
      float x12 = (x1+x2)/2;
      float y12 = (y1+y2)/2;
      float x23 = (x2+x3)/2;
      float y23 = (y2+y3)/2;

      float xa = (x01+x12)/2;
      float ya = (y01+y12)/2;
      float xb = (x12+x23)/2;
      float yb = (y12+y23)/2;

      float mx = (xa+xb)/2;
      float my = (ya+yb)/2;

      stbtt__tesselate_cubic(points, num_points, x0,y0, x01,y01, xa,ya, mx,my, objspace_flatness_squared,n+1);
      stbtt__tesselate_cubic(points, num_points, mx,my, xb,yb, x23,y23, x3,y3, objspace_flatness_squared,n+1);
   } else {
      stbtt__add_point(points, *num_points,x3,y3);
      *num_points = *num_points+1;
   }
}

// returns number of contours
static stbtt__point *stbtt_FlattenCurves(stbtt_vertex *vertices, int num_verts, float objspace_flatness, int **contour_lengths, int *num_contours, void *userdata)
{
   stbtt__point *points=0;
   int num_points=0;

   float objspace_flatness_squared = objspace_flatness * objspace_flatness;
   int i,n=0,start=0, pass;

   // count how many "moves" there are to get the contour count
   for (i=0; i < num_verts; ++i)
      if (vertices[i].type == STBTT_vmove)
         ++n;

   *num_contours = n;
   if (n == 0) return 0;

   *contour_lengths = (int *) STBTT_malloc(sizeof(**contour_lengths) * n, userdata);

   if (*contour_lengths == 0) {
      *num_contours = 0;
      return 0;
   }

   // make two passes through the points so we don't need to realloc
   for (pass=0; pass < 2; ++pass) {
      float x=0,y=0;
      if (pass == 1) {
         points = (stbtt__point *) STBTT_malloc(num_points * sizeof(points[0]), userdata);
         if (points == NULL) goto error;
      }
      num_points = 0;
      n= -1;
      for (i=0; i < num_verts; ++i) {
         switch (vertices[i].type) {
            case STBTT_vmove:
               // start the next contour
               if (n >= 0)
                  (*contour_lengths)[n] = num_points - start;
               ++n;
               start = num_points;

               x = vertices[i].x, y = vertices[i].y;
               stbtt__add_point(points, num_points++, x,y);
               break;
            case STBTT_vline:
               x = vertices[i].x, y = vertices[i].y;
               stbtt__add_point(points, num_points++, x, y);
               break;
            case STBTT_vcurve:
               stbtt__tesselate_curve(points, &num_points, x,y,
                                        vertices[i].cx, vertices[i].cy,
                                        vertices[i].x,  vertices[i].y,
                                        objspace_flatness_squared, 0);
               x = vertices[i].x, y = vertices[i].y;
               break;
            case STBTT_vcubic:
               stbtt__tesselate_cubic(points, &num_points, x,y,
                                        vertices[i].cx, vertices[i].cy,
                                        vertices[i].cx1, vertices[i].cy1,
                                        vertices[i].x,  vertices[i].y,
                                        objspace_flatness_squared, 0);
               x = vertices[i].x, y = vertices[i].y;
               break;
         }
      }
      (*contour_lengths)[n] = num_points - start;
   }

   return points;
error:
   STBTT_free(points, userdata);
   STBTT_free(*contour_lengths, userdata);
   *contour_lengths = 0;
   *num_contours = 0;
   return NULL;
}

STBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result, float flatness_in_pixels, stbtt_vertex *vertices, int num_verts, float scale_x, float scale_y, float shift_x, float shift_y, int x_off, int y_off, int invert, void *userdata)
{
   float scale            = scale_x > scale_y ? scale_y : scale_x;
   int winding_count      = 0;
   int *winding_lengths   = NULL;
   stbtt__point *windings = stbtt_FlattenCurves(vertices, num_verts, flatness_in_pixels / scale, &winding_lengths, &winding_count, userdata);
   if (windings) {
      stbtt__rasterize(result, windings, winding_lengths, winding_count, scale_x, scale_y, shift_x, shift_y, x_off, y_off, invert, userdata);
      STBTT_free(winding_lengths, userdata);
      STBTT_free(windings, userdata);
   }
}

STBTT_DEF void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata)
{
   STBTT_free(bitmap, userdata);
}

STBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff)
{
   int ix0,iy0,ix1,iy1;
   stbtt__bitmap gbm;
   stbtt_vertex *vertices;   
   int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);

   if (scale_x == 0) scale_x = scale_y;
   if (scale_y == 0) {
      if (scale_x == 0) {
         STBTT_free(vertices, info->userdata);
         return NULL;
      }
      scale_y = scale_x;
   }

   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,&ix1,&iy1);

   // now we get the size
   gbm.w = (ix1 - ix0);
   gbm.h = (iy1 - iy0);
   gbm.pixels = NULL; // in case we error

   if (width ) *width  = gbm.w;
   if (height) *height = gbm.h;
   if (xoff  ) *xoff   = ix0;
   if (yoff  ) *yoff   = iy0;
   
   if (gbm.w && gbm.h) {
      gbm.pixels = (unsigned char *) STBTT_malloc(gbm.w * gbm.h, info->userdata);
      if (gbm.pixels) {
         gbm.stride = gbm.w;

         stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0, iy0, 1, info->userdata);
      }
   }
   STBTT_free(vertices, info->userdata);
   return gbm.pixels;
}   

STBTT_DEF unsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff)
{
   return stbtt_GetGlyphBitmapSubpixel(info, scale_x, scale_y, 0.0f, 0.0f, glyph, width, height, xoff, yoff);
}

STBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph)
{
   int ix0,iy0;
   stbtt_vertex *vertices;
   int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);
   stbtt__bitmap gbm;   

   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,0,0);
   gbm.pixels = output;
   gbm.w = out_w;
   gbm.h = out_h;
   gbm.stride = out_stride;

   if (gbm.w && gbm.h)
      stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0,iy0, 1, info->userdata);

   STBTT_free(vertices, info->userdata);
}

STBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph)
{
   stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f,0.0f, glyph);
}

STBTT_DEF unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff)
{
   return stbtt_GetGlyphBitmapSubpixel(info, scale_x, scale_y,shift_x,shift_y, stbtt_FindGlyphIndex(info,codepoint), width,height,xoff,yoff);
}   

STBTT_DEF void stbtt_MakeCodepointBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int codepoint)
{
   stbtt_MakeGlyphBitmapSubpixelPrefilter(info, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, oversample_x, oversample_y, sub_x, sub_y, stbtt_FindGlyphIndex(info,codepoint));
}

STBTT_DEF void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint)
{
   stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, stbtt_FindGlyphIndex(info,codepoint));
}

STBTT_DEF unsigned char *stbtt_GetCodepointBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff)
{
   return stbtt_GetCodepointBitmapSubpixel(info, scale_x, scale_y, 0.0f,0.0f, codepoint, width,height,xoff,yoff);
}   

STBTT_DEF void stbtt_MakeCodepointBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint)
{
   stbtt_MakeCodepointBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f,0.0f, codepoint);
}

//////////////////////////////////////////////////////////////////////////////
//
// bitmap baking
//
// This is SUPER-CRAPPY packing to keep source code small

static int stbtt_BakeFontBitmap_internal(unsigned char *data, int offset,  // font location (use offset=0 for plain .ttf)
                                float pixel_height,                     // height of font in pixels
                                unsigned char *pixels, int pw, int ph,  // bitmap to be filled in
                                int first_char, int num_chars,          // characters to bake
                                stbtt_bakedchar *chardata)
{
   float scale;
   int x,y,bottom_y, i;
   stbtt_fontinfo f;
   f.userdata = NULL;
   if (!stbtt_InitFont(&f, data, offset))
      return -1;
   STBTT_memset(pixels, 0, pw*ph); // background of 0 around pixels
   x=y=1;
   bottom_y = 1;

   scale = stbtt_ScaleForPixelHeight(&f, pixel_height);

   for (i=0; i < num_chars; ++i) {
      int advance, lsb, x0,y0,x1,y1,gw,gh;
      int g = stbtt_FindGlyphIndex(&f, first_char + i);
      stbtt_GetGlyphHMetrics(&f, g, &advance, &lsb);
      stbtt_GetGlyphBitmapBox(&f, g, scale,scale, &x0,&y0,&x1,&y1);
      gw = x1-x0;
      gh = y1-y0;
      if (x + gw + 1 >= pw)
         y = bottom_y, x = 1; // advance to next row
      if (y + gh + 1 >= ph) // check if it fits vertically AFTER potentially moving to next row
         return -i;
      STBTT_assert(x+gw < pw);
      STBTT_assert(y+gh < ph);
      stbtt_MakeGlyphBitmap(&f, pixels+x+y*pw, gw,gh,pw, scale,scale, g);
      chardata[i].x0 = (stbtt_int16) x;
      chardata[i].y0 = (stbtt_int16) y;
      chardata[i].x1 = (stbtt_int16) (x + gw);
      chardata[i].y1 = (stbtt_int16) (y + gh);
      chardata[i].xadvance = scale * advance;
      chardata[i].xoff     = (float) x0;
      chardata[i].yoff     = (float) y0;
      x = x + gw + 1;
      if (y+gh+1 > bottom_y)
         bottom_y = y+gh+1;
   }
   return bottom_y;
}

STBTT_DEF void stbtt_GetBakedQuad(const stbtt_bakedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int opengl_fillrule)
{
   float d3d_bias = opengl_fillrule ? 0 : -0.5f;
   float ipw = 1.0f / pw, iph = 1.0f / ph;
   const stbtt_bakedchar *b = chardata + char_index;
   int round_x = STBTT_ifloor((*xpos + b->xoff) + 0.5f);
   int round_y = STBTT_ifloor((*ypos + b->yoff) + 0.5f);

   q->x0 = round_x + d3d_bias;
   q->y0 = round_y + d3d_bias;
   q->x1 = round_x + b->x1 - b->x0 + d3d_bias;
   q->y1 = round_y + b->y1 - b->y0 + d3d_bias;

   q->s0 = b->x0 * ipw;
   q->t0 = b->y0 * iph;
   q->s1 = b->x1 * ipw;
   q->t1 = b->y1 * iph;

   *xpos += b->xadvance;
}

//////////////////////////////////////////////////////////////////////////////
//
// rectangle packing replacement routines if you don't have stb_rect_pack.h
//

#ifndef STB_RECT_PACK_VERSION

typedef int stbrp_coord;

////////////////////////////////////////////////////////////////////////////////////
//                                                                                //
//                                                                                //
// COMPILER WARNING ?!?!?                                                         //
//                                                                                //
//                                                                                //
// if you get a compile warning due to these symbols being defined more than      //
// once, move #include "stb_rect_pack.h" before #include "stb_truetype.h"         //
//                                                                                //
////////////////////////////////////////////////////////////////////////////////////

typedef struct
{
   int width,height;
   int x,y,bottom_y;
} stbrp_context;

typedef struct
{
   unsigned char x;
} stbrp_node;

struct stbrp_rect
{
   stbrp_coord x,y;
   int id,w,h,was_packed;
};

static void stbrp_init_target(stbrp_context *con, int pw, int ph, stbrp_node *nodes, int num_nodes)
{
   con->width  = pw;
   con->height = ph;
   con->x = 0;
   con->y = 0;
   con->bottom_y = 0;
   STBTT__NOTUSED(nodes);
   STBTT__NOTUSED(num_nodes);   
}

static void stbrp_pack_rects(stbrp_context *con, stbrp_rect *rects, int num_rects)
{
   int i;
   for (i=0; i < num_rects; ++i) {
      if (con->x + rects[i].w > con->width) {
         con->x = 0;
         con->y = con->bottom_y;
      }
      if (con->y + rects[i].h > con->height)
         break;
      rects[i].x = con->x;
      rects[i].y = con->y;
      rects[i].was_packed = 1;
      con->x += rects[i].w;
      if (con->y + rects[i].h > con->bottom_y)
         con->bottom_y = con->y + rects[i].h;
   }
   for (   ; i < num_rects; ++i)
      rects[i].was_packed = 0;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
// bitmap baking
//
// This is SUPER-AWESOME (tm Ryan Gordon) packing using stb_rect_pack.h. If
// stb_rect_pack.h isn't available, it uses the BakeFontBitmap strategy.

STBTT_DEF int stbtt_PackBegin(stbtt_pack_context *spc, unsigned char *pixels, int pw, int ph, int stride_in_bytes, int padding, void *alloc_context)
{
   stbrp_context *context = (stbrp_context *) STBTT_malloc(sizeof(*context)            ,alloc_context);
   int            num_nodes = pw - padding;
   stbrp_node    *nodes   = (stbrp_node    *) STBTT_malloc(sizeof(*nodes  ) * num_nodes,alloc_context);

   if (context == NULL || nodes == NULL) {
      if (context != NULL) STBTT_free(context, alloc_context);
      if (nodes   != NULL) STBTT_free(nodes  , alloc_context);
      return 0;
   }

   spc->user_allocator_context = alloc_context;
   spc->width = pw;
   spc->height = ph;
   spc->pixels = pixels;
   spc->pack_info = context;
   spc->nodes = nodes;
   spc->padding = padding;
   spc->stride_in_bytes = stride_in_bytes != 0 ? stride_in_bytes : pw;
   spc->h_oversample = 1;
   spc->v_oversample = 1;

   stbrp_init_target(context, pw-padding, ph-padding, nodes, num_nodes);

   if (pixels)
      STBTT_memset(pixels, 0, pw*ph); // background of 0 around pixels

   return 1;
}

STBTT_DEF void stbtt_PackEnd  (stbtt_pack_context *spc)
{
   STBTT_free(spc->nodes    , spc->user_allocator_context);
   STBTT_free(spc->pack_info, spc->user_allocator_context);
}

STBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample)
{
   STBTT_assert(h_oversample <= STBTT_MAX_OVERSAMPLE);
   STBTT_assert(v_oversample <= STBTT_MAX_OVERSAMPLE);
   if (h_oversample <= STBTT_MAX_OVERSAMPLE)
      spc->h_oversample = h_oversample;
   if (v_oversample <= STBTT_MAX_OVERSAMPLE)
      spc->v_oversample = v_oversample;
}

#define STBTT__OVER_MASK  (STBTT_MAX_OVERSAMPLE-1)

static void stbtt__h_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)
{
   unsigned char buffer[STBTT_MAX_OVERSAMPLE];
   int safe_w = w - kernel_width;
   int j;
   STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze
   for (j=0; j < h; ++j) {
      int i;
      unsigned int total;
      STBTT_memset(buffer, 0, kernel_width);

      total = 0;

      // make kernel_width a constant in common cases so compiler can optimize out the divide
      switch (kernel_width) {
         case 2:
            for (i=0; i <= safe_w; ++i) {
               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
               pixels[i] = (unsigned char) (total / 2);
            }
            break;
         case 3:
            for (i=0; i <= safe_w; ++i) {
               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
               pixels[i] = (unsigned char) (total / 3);
            }
            break;
         case 4:
            for (i=0; i <= safe_w; ++i) {
               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
               pixels[i] = (unsigned char) (total / 4);
            }
            break;
         case 5:
            for (i=0; i <= safe_w; ++i) {
               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
               pixels[i] = (unsigned char) (total / 5);
            }
            break;
         default:
            for (i=0; i <= safe_w; ++i) {
               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
               pixels[i] = (unsigned char) (total / kernel_width);
            }
            break;
      }

      for (; i < w; ++i) {
         STBTT_assert(pixels[i] == 0);
         total -= buffer[i & STBTT__OVER_MASK];
         pixels[i] = (unsigned char) (total / kernel_width);
      }

      pixels += stride_in_bytes;
   }
}

static void stbtt__v_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)
{
   unsigned char buffer[STBTT_MAX_OVERSAMPLE];
   int safe_h = h - kernel_width;
   int j;
   STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze
   for (j=0; j < w; ++j) {
      int i;
      unsigned int total;
      STBTT_memset(buffer, 0, kernel_width);

      total = 0;

      // make kernel_width a constant in common cases so compiler can optimize out the divide
      switch (kernel_width) {
         case 2:
            for (i=0; i <= safe_h; ++i) {
               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
               pixels[i*stride_in_bytes] = (unsigned char) (total / 2);
            }
            break;
         case 3:
            for (i=0; i <= safe_h; ++i) {
               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
               pixels[i*stride_in_bytes] = (unsigned char) (total / 3);
            }
            break;
         case 4:
            for (i=0; i <= safe_h; ++i) {
               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
               pixels[i*stride_in_bytes] = (unsigned char) (total / 4);
            }
            break;
         case 5:
            for (i=0; i <= safe_h; ++i) {
               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
               pixels[i*stride_in_bytes] = (unsigned char) (total / 5);
            }
            break;
         default:
            for (i=0; i <= safe_h; ++i) {
               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
               pixels[i*stride_in_bytes] = (unsigned char) (total / kernel_width);
            }
            break;
      }

      for (; i < h; ++i) {
         STBTT_assert(pixels[i*stride_in_bytes] == 0);
         total -= buffer[i & STBTT__OVER_MASK];
         pixels[i*stride_in_bytes] = (unsigned char) (total / kernel_width);
      }

      pixels += 1;
   }
}

static float stbtt__oversample_shift(int oversample)
{
   if (!oversample)
      return 0.0f;

   // The prefilter is a box filter of width "oversample",
   // which shifts phase by (oversample - 1)/2 pixels in
   // oversampled space. We want to shift in the opposite
   // direction to counter this.
   return (float)-(oversample - 1) / (2.0f * (float)oversample);
}

// rects array must be big enough to accommodate all characters in the given ranges
STBTT_DEF int stbtt_PackFontRangesGatherRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)
{
   int i,j,k;

   k=0;
   for (i=0; i < num_ranges; ++i) {
      float fh = ranges[i].font_size;
      float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);
      ranges[i].h_oversample = (unsigned char) spc->h_oversample;
      ranges[i].v_oversample = (unsigned char) spc->v_oversample;
      for (j=0; j < ranges[i].num_chars; ++j) {
         int x0,y0,x1,y1;
         int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];
         int glyph = stbtt_FindGlyphIndex(info, codepoint);
         stbtt_GetGlyphBitmapBoxSubpixel(info,glyph,
                                         scale * spc->h_oversample,
                                         scale * spc->v_oversample,
                                         0,0,
                                         &x0,&y0,&x1,&y1);
         rects[k].w = (stbrp_coord) (x1-x0 + spc->padding + spc->h_oversample-1);
         rects[k].h = (stbrp_coord) (y1-y0 + spc->padding + spc->v_oversample-1);
         ++k;
      }
   }

   return k;
}

STBTT_DEF void stbtt_MakeGlyphBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int prefilter_x, int prefilter_y, float *sub_x, float *sub_y, int glyph)
{
   stbtt_MakeGlyphBitmapSubpixel(info,
                                 output,
                                 out_w - (prefilter_x - 1),
                                 out_h - (prefilter_y - 1),
                                 out_stride,
                                 scale_x,
                                 scale_y,
                                 shift_x,
                                 shift_y,
                                 glyph);

   if (prefilter_x > 1)
      stbtt__h_prefilter(output, out_w, out_h, out_stride, prefilter_x);

   if (prefilter_y > 1)
      stbtt__v_prefilter(output, out_w, out_h, out_stride, prefilter_y);

   *sub_x = stbtt__oversample_shift(prefilter_x);
   *sub_y = stbtt__oversample_shift(prefilter_y);
}

// rects array must be big enough to accommodate all characters in the given ranges
STBTT_DEF int stbtt_PackFontRangesRenderIntoRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)
{
   int i,j,k, return_value = 1;

   // save current values
   int old_h_over = spc->h_oversample;
   int old_v_over = spc->v_oversample;

   k = 0;
   for (i=0; i < num_ranges; ++i) {
      float fh = ranges[i].font_size;
      float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);
      float recip_h,recip_v,sub_x,sub_y;
      spc->h_oversample = ranges[i].h_oversample;
      spc->v_oversample = ranges[i].v_oversample;
      recip_h = 1.0f / spc->h_oversample;
      recip_v = 1.0f / spc->v_oversample;
      sub_x = stbtt__oversample_shift(spc->h_oversample);
      sub_y = stbtt__oversample_shift(spc->v_oversample);
      for (j=0; j < ranges[i].num_chars; ++j) {
         stbrp_rect *r = &rects[k];
         if (r->was_packed) {
            stbtt_packedchar *bc = &ranges[i].chardata_for_range[j];
            int advance, lsb, x0,y0,x1,y1;
            int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];
            int glyph = stbtt_FindGlyphIndex(info, codepoint);
            stbrp_coord pad = (stbrp_coord) spc->padding;

            // pad on left and top
            r->x += pad;
            r->y += pad;
            r->w -= pad;
            r->h -= pad;
            stbtt_GetGlyphHMetrics(info, glyph, &advance, &lsb);
            stbtt_GetGlyphBitmapBox(info, glyph,
                                    scale * spc->h_oversample,
                                    scale * spc->v_oversample,
                                    &x0,&y0,&x1,&y1);
            stbtt_MakeGlyphBitmapSubpixel(info,
                                          spc->pixels + r->x + r->y*spc->stride_in_bytes,
                                          r->w - spc->h_oversample+1,
                                          r->h - spc->v_oversample+1,
                                          spc->stride_in_bytes,
                                          scale * spc->h_oversample,
                                          scale * spc->v_oversample,
                                          0,0,
                                          glyph);

            if (spc->h_oversample > 1)
               stbtt__h_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,
                                  r->w, r->h, spc->stride_in_bytes,
                                  spc->h_oversample);

            if (spc->v_oversample > 1)
               stbtt__v_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,
                                  r->w, r->h, spc->stride_in_bytes,
                                  spc->v_oversample);

            bc->x0       = (stbtt_int16)  r->x;
            bc->y0       = (stbtt_int16)  r->y;
            bc->x1       = (stbtt_int16) (r->x + r->w);
            bc->y1       = (stbtt_int16) (r->y + r->h);
            bc->xadvance =                scale * advance;
            bc->xoff     =       (float)  x0 * recip_h + sub_x;
            bc->yoff     =       (float)  y0 * recip_v + sub_y;
            bc->xoff2    =                (x0 + r->w) * recip_h + sub_x;
            bc->yoff2    =                (y0 + r->h) * recip_v + sub_y;
         } else {
            return_value = 0; // if any fail, report failure
         }

         ++k;
      }
   }

   // restore original values
   spc->h_oversample = old_h_over;
   spc->v_oversample = old_v_over;

   return return_value;
}

STBTT_DEF void stbtt_PackFontRangesPackRects(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects)
{
   stbrp_pack_rects((stbrp_context *) spc->pack_info, rects, num_rects);
}

STBTT_DEF int stbtt_PackFontRanges(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges)
{
   stbtt_fontinfo info;
   int i,j,n, return_value = 1;
   //stbrp_context *context = (stbrp_context *) spc->pack_info;
   stbrp_rect    *rects;

   // flag all characters as NOT packed
   for (i=0; i < num_ranges; ++i)
      for (j=0; j < ranges[i].num_chars; ++j)
         ranges[i].chardata_for_range[j].x0 =
         ranges[i].chardata_for_range[j].y0 =
         ranges[i].chardata_for_range[j].x1 =
         ranges[i].chardata_for_range[j].y1 = 0;

   n = 0;
   for (i=0; i < num_ranges; ++i)
      n += ranges[i].num_chars;
         
   rects = (stbrp_rect *) STBTT_malloc(sizeof(*rects) * n, spc->user_allocator_context);
   if (rects == NULL)
      return 0;

   info.userdata = spc->user_allocator_context;
   stbtt_InitFont(&info, fontdata, stbtt_GetFontOffsetForIndex(fontdata,font_index));

   n = stbtt_PackFontRangesGatherRects(spc, &info, ranges, num_ranges, rects);

   stbtt_PackFontRangesPackRects(spc, rects, n);
  
   return_value = stbtt_PackFontRangesRenderIntoRects(spc, &info, ranges, num_ranges, rects);

   STBTT_free(rects, spc->user_allocator_context);
   return return_value;
}

STBTT_DEF int stbtt_PackFontRange(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, float font_size,
            int first_unicode_codepoint_in_range, int num_chars_in_range, stbtt_packedchar *chardata_for_range)
{
   stbtt_pack_range range;
   range.first_unicode_codepoint_in_range = first_unicode_codepoint_in_range;
   range.array_of_unicode_codepoints = NULL;
   range.num_chars                   = num_chars_in_range;
   range.chardata_for_range          = chardata_for_range;
   range.font_size                   = font_size;
   return stbtt_PackFontRanges(spc, fontdata, font_index, &range, 1);
}

STBTT_DEF void stbtt_GetPackedQuad(const stbtt_packedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int align_to_integer)
{
   float ipw = 1.0f / pw, iph = 1.0f / ph;
   const stbtt_packedchar *b = chardata + char_index;

   if (align_to_integer) {
      float x = (float) STBTT_ifloor((*xpos + b->xoff) + 0.5f);
      float y = (float) STBTT_ifloor((*ypos + b->yoff) + 0.5f);
      q->x0 = x;
      q->y0 = y;
      q->x1 = x + b->xoff2 - b->xoff;
      q->y1 = y + b->yoff2 - b->yoff;
   } else {
      q->x0 = *xpos + b->xoff;
      q->y0 = *ypos + b->yoff;
      q->x1 = *xpos + b->xoff2;
      q->y1 = *ypos + b->yoff2;
   }

   q->s0 = b->x0 * ipw;
   q->t0 = b->y0 * iph;
   q->s1 = b->x1 * ipw;
   q->t1 = b->y1 * iph;

   *xpos += b->xadvance;
}

//////////////////////////////////////////////////////////////////////////////
//
// sdf computation
//

#define STBTT_min(a,b)  ((a) < (b) ? (a) : (b))
#define STBTT_max(a,b)  ((a) < (b) ? (b) : (a))

static int stbtt__ray_intersect_bezier(float orig[2], float ray[2], float q0[2], float q1[2], float q2[2], float hits[2][2])
{
   float q0perp = q0[1]*ray[0] - q0[0]*ray[1];
   float q1perp = q1[1]*ray[0] - q1[0]*ray[1];
   float q2perp = q2[1]*ray[0] - q2[0]*ray[1];
   float roperp = orig[1]*ray[0] - orig[0]*ray[1];

   float a = q0perp - 2*q1perp + q2perp;
   float b = q1perp - q0perp;
   float c = q0perp - roperp;

   float s0 = 0., s1 = 0.;
   int num_s = 0;

   if (a != 0.0) {
      float discr = b*b - a*c;
      if (discr > 0.0) {
         float rcpna = -1 / a;
         float d = (float) STBTT_sqrt(discr);
         s0 = (b+d) * rcpna;
         s1 = (b-d) * rcpna;
         if (s0 >= 0.0 && s0 <= 1.0)
            num_s = 1;
         if (d > 0.0 && s1 >= 0.0 && s1 <= 1.0) {
            if (num_s == 0) s0 = s1;
            ++num_s;
         }
      }
   } else {
      // 2*b*s + c = 0
      // s = -c / (2*b)
      s0 = c / (-2 * b);
      if (s0 >= 0.0 && s0 <= 1.0)
         num_s = 1;
   }

   if (num_s == 0)
      return 0;
   else {
      float rcp_len2 = 1 / (ray[0]*ray[0] + ray[1]*ray[1]);
      float rayn_x = ray[0] * rcp_len2, rayn_y = ray[1] * rcp_len2;

      float q0d =   q0[0]*rayn_x +   q0[1]*rayn_y;
      float q1d =   q1[0]*rayn_x +   q1[1]*rayn_y;
      float q2d =   q2[0]*rayn_x +   q2[1]*rayn_y;
      float rod = orig[0]*rayn_x + orig[1]*rayn_y;

      float q10d = q1d - q0d;
      float q20d = q2d - q0d;
      float q0rd = q0d - rod;

      hits[0][0] = q0rd + s0*(2.0f - 2.0f*s0)*q10d + s0*s0*q20d;
      hits[0][1] = a*s0+b;

      if (num_s > 1) {
         hits[1][0] = q0rd + s1*(2.0f - 2.0f*s1)*q10d + s1*s1*q20d;
         hits[1][1] = a*s1+b;
         return 2;
      } else {
         return 1;
      }
   }
}

static int equal(float *a, float *b)
{
   return (a[0] == b[0] && a[1] == b[1]);
}

static int stbtt__compute_crossings_x(float x, float y, int nverts, stbtt_vertex *verts)
{
   int i;
   float orig[2], ray[2] = { 1, 0 };
   float y_frac;
   int winding = 0;

   orig[0] = x;
   orig[1] = y;

   // make sure y never passes through a vertex of the shape
   y_frac = (float) STBTT_fmod(y, 1.0f);
   if (y_frac < 0.01f)
      y += 0.01f;
   else if (y_frac > 0.99f)
      y -= 0.01f;
   orig[1] = y;

   // test a ray from (-infinity,y) to (x,y)
   for (i=0; i < nverts; ++i) {
      if (verts[i].type == STBTT_vline) {
         int x0 = (int) verts[i-1].x, y0 = (int) verts[i-1].y;
         int x1 = (int) verts[i  ].x, y1 = (int) verts[i  ].y;
         if (y > STBTT_min(y0,y1) && y < STBTT_max(y0,y1) && x > STBTT_min(x0,x1)) {
            float x_inter = (y - y0) / (y1 - y0) * (x1-x0) + x0;
            if (x_inter < x)  
               winding += (y0 < y1) ? 1 : -1;
         }
      }
      if (verts[i].type == STBTT_vcurve) {
         int x0 = (int) verts[i-1].x , y0 = (int) verts[i-1].y ;
         int x1 = (int) verts[i  ].cx, y1 = (int) verts[i  ].cy;
         int x2 = (int) verts[i  ].x , y2 = (int) verts[i  ].y ;
         int ax = STBTT_min(x0,STBTT_min(x1,x2)), ay = STBTT_min(y0,STBTT_min(y1,y2));
         int by = STBTT_max(y0,STBTT_max(y1,y2));
         if (y > ay && y < by && x > ax) {
            float q0[2],q1[2],q2[2];
            float hits[2][2];
            q0[0] = (float)x0;
            q0[1] = (float)y0;
            q1[0] = (float)x1;
            q1[1] = (float)y1;
            q2[0] = (float)x2;
            q2[1] = (float)y2;
            if (equal(q0,q1) || equal(q1,q2)) {
               x0 = (int)verts[i-1].x;
               y0 = (int)verts[i-1].y;
               x1 = (int)verts[i  ].x;
               y1 = (int)verts[i  ].y;
               if (y > STBTT_min(y0,y1) && y < STBTT_max(y0,y1) && x > STBTT_min(x0,x1)) {
                  float x_inter = (y - y0) / (y1 - y0) * (x1-x0) + x0;
                  if (x_inter < x)  
                     winding += (y0 < y1) ? 1 : -1;
               }
            } else {
               int num_hits = stbtt__ray_intersect_bezier(orig, ray, q0, q1, q2, hits);
               if (num_hits >= 1)
                  if (hits[0][0] < 0)
                     winding += (hits[0][1] < 0 ? -1 : 1);
               if (num_hits >= 2)
                  if (hits[1][0] < 0)
                     winding += (hits[1][1] < 0 ? -1 : 1);
            }
         } 
      }
   }
   return winding;
}

static float stbtt__cuberoot( float x )
{
   if (x<0)
      return -(float) STBTT_pow(-x,1.0f/3.0f);
   else
      return  (float) STBTT_pow( x,1.0f/3.0f);
}

// x^3 + c*x^2 + b*x + a = 0
static int stbtt__solve_cubic(float a, float b, float c, float* r)
{
	float s = -a / 3;
	float p = b - a*a / 3;
	float q = a * (2*a*a - 9*b) / 27 + c;
   float p3 = p*p*p;
	float d = q*q + 4*p3 / 27;
	if (d >= 0) {
		float z = (float) STBTT_sqrt(d);
		float u = (-q + z) / 2;
		float v = (-q - z) / 2;
		u = stbtt__cuberoot(u);
		v = stbtt__cuberoot(v);
		r[0] = s + u + v;
		return 1;
	} else {
	   float u = (float) STBTT_sqrt(-p/3);
	   float v = (float) STBTT_acos(-STBTT_sqrt(-27/p3) * q / 2) / 3; // p3 must be negative, since d is negative
	   float m = (float) STBTT_cos(v);
      float n = (float) STBTT_cos(v-3.141592/2)*1.732050808f;
	   r[0] = s + u * 2 * m;
	   r[1] = s - u * (m + n);
	   r[2] = s - u * (m - n);

      //STBTT_assert( STBTT_fabs(((r[0]+a)*r[0]+b)*r[0]+c) < 0.05f);  // these asserts may not be safe at all scales, though they're in bezier t parameter units so maybe?
      //STBTT_assert( STBTT_fabs(((r[1]+a)*r[1]+b)*r[1]+c) < 0.05f);
      //STBTT_assert( STBTT_fabs(((r[2]+a)*r[2]+b)*r[2]+c) < 0.05f);
   	return 3;
   }
}

STBTT_DEF unsigned char * stbtt_GetGlyphSDF(const stbtt_fontinfo *info, float scale, int glyph, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff)
{
   float scale_x = scale, scale_y = scale;
   int ix0,iy0,ix1,iy1;
   int w,h;
   unsigned char *data;

   // if one scale is 0, use same scale for both
   if (scale_x == 0) scale_x = scale_y;
   if (scale_y == 0) {
      if (scale_x == 0) return NULL;  // if both scales are 0, return NULL
      scale_y = scale_x;
   }

   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale, scale, 0.0f,0.0f, &ix0,&iy0,&ix1,&iy1);

   // if empty, return NULL
   if (ix0 == ix1 || iy0 == iy1)
      return NULL;

   ix0 -= padding;
   iy0 -= padding;
   ix1 += padding;
   iy1 += padding;

   w = (ix1 - ix0);
   h = (iy1 - iy0);

   if (width ) *width  = w;
   if (height) *height = h;
   if (xoff  ) *xoff   = ix0;
   if (yoff  ) *yoff   = iy0;

   // invert for y-downwards bitmaps
   scale_y = -scale_y;
      
   {
      int x,y,i,j;
      float *precompute;
      stbtt_vertex *verts;
      int num_verts = stbtt_GetGlyphShape(info, glyph, &verts);
      data = (unsigned char *) STBTT_malloc(w * h, info->userdata);
      precompute = (float *) STBTT_malloc(num_verts * sizeof(float), info->userdata);

      for (i=0,j=num_verts-1; i < num_verts; j=i++) {
         if (verts[i].type == STBTT_vline) {
            float x0 = verts[i].x*scale_x, y0 = verts[i].y*scale_y;
            float x1 = verts[j].x*scale_x, y1 = verts[j].y*scale_y;
            float dist = (float) STBTT_sqrt((x1-x0)*(x1-x0) + (y1-y0)*(y1-y0));
            precompute[i] = (dist == 0) ? 0.0f : 1.0f / dist;
         } else if (verts[i].type == STBTT_vcurve) {
            float x2 = verts[j].x *scale_x, y2 = verts[j].y *scale_y;
            float x1 = verts[i].cx*scale_x, y1 = verts[i].cy*scale_y;
            float x0 = verts[i].x *scale_x, y0 = verts[i].y *scale_y;
            float bx = x0 - 2*x1 + x2, by = y0 - 2*y1 + y2;
            float len2 = bx*bx + by*by;
            if (len2 != 0.0f)
               precompute[i] = 1.0f / (bx*bx + by*by);
            else
               precompute[i] = 0.0f;
         } else
            precompute[i] = 0.0f;
      }

      for (y=iy0; y < iy1; ++y) {
         for (x=ix0; x < ix1; ++x) {
            float val;
            float min_dist = 999999.0f;
            float sx = (float) x + 0.5f;
            float sy = (float) y + 0.5f;
            float x_gspace = (sx / scale_x);
            float y_gspace = (sy / scale_y);

            int winding = stbtt__compute_crossings_x(x_gspace, y_gspace, num_verts, verts); // @OPTIMIZE: this could just be a rasterization, but needs to be line vs. non-tesselated curves so a new path

            for (i=0; i < num_verts; ++i) {
               float x0 = verts[i].x*scale_x, y0 = verts[i].y*scale_y;

               // check against every point here rather than inside line/curve primitives -- @TODO: wrong if multiple 'moves' in a row produce a garbage point, and given culling, probably more efficient to do within line/curve
               float dist2 = (x0-sx)*(x0-sx) + (y0-sy)*(y0-sy);
               if (dist2 < min_dist*min_dist)
                  min_dist = (float) STBTT_sqrt(dist2);

               if (verts[i].type == STBTT_vline) {
                  float x1 = verts[i-1].x*scale_x, y1 = verts[i-1].y*scale_y;

                  // coarse culling against bbox
                  //if (sx > STBTT_min(x0,x1)-min_dist && sx < STBTT_max(x0,x1)+min_dist &&
                  //    sy > STBTT_min(y0,y1)-min_dist && sy < STBTT_max(y0,y1)+min_dist)
                  float dist = (float) STBTT_fabs((x1-x0)*(y0-sy) - (y1-y0)*(x0-sx)) * precompute[i];
                  STBTT_assert(i != 0);
                  if (dist < min_dist) {
                     // check position along line
                     // x' = x0 + t*(x1-x0), y' = y0 + t*(y1-y0)
                     // minimize (x'-sx)*(x'-sx)+(y'-sy)*(y'-sy)
                     float dx = x1-x0, dy = y1-y0;
                     float px = x0-sx, py = y0-sy;
                     // minimize (px+t*dx)^2 + (py+t*dy)^2 = px*px + 2*px*dx*t + t^2*dx*dx + py*py + 2*py*dy*t + t^2*dy*dy
                     // derivative: 2*px*dx + 2*py*dy + (2*dx*dx+2*dy*dy)*t, set to 0 and solve
                     float t = -(px*dx + py*dy) / (dx*dx + dy*dy);
                     if (t >= 0.0f && t <= 1.0f)
                        min_dist = dist;
                  }
               } else if (verts[i].type == STBTT_vcurve) {
                  float x2 = verts[i-1].x *scale_x, y2 = verts[i-1].y *scale_y;
                  float x1 = verts[i  ].cx*scale_x, y1 = verts[i  ].cy*scale_y;
                  float box_x0 = STBTT_min(STBTT_min(x0,x1),x2);
                  float box_y0 = STBTT_min(STBTT_min(y0,y1),y2);
                  float box_x1 = STBTT_max(STBTT_max(x0,x1),x2);
                  float box_y1 = STBTT_max(STBTT_max(y0,y1),y2);
                  // coarse culling against bbox to avoid computing cubic unnecessarily
                  if (sx > box_x0-min_dist && sx < box_x1+min_dist && sy > box_y0-min_dist && sy < box_y1+min_dist) {
                     int num=0;
                     float ax = x1-x0, ay = y1-y0;
                     float bx = x0 - 2*x1 + x2, by = y0 - 2*y1 + y2;
                     float mx = x0 - sx, my = y0 - sy;
                     float res[3],px,py,t,it;
                     float a_inv = precompute[i];
                     if (a_inv == 0.0) { // if a_inv is 0, it's 2nd degree so use quadratic formula
                        float a = 3*(ax*bx + ay*by);
                        float b = 2*(ax*ax + ay*ay) + (mx*bx+my*by);
                        float c = mx*ax+my*ay;
                        if (a == 0.0) { // if a is 0, it's linear
                           if (b != 0.0) {
                              res[num++] = -c/b;
                           }
                        } else {
                           float discriminant = b*b - 4*a*c;
                           if (discriminant < 0)
                              num = 0;
                           else {
                              float root = (float) STBTT_sqrt(discriminant);
                              res[0] = (-b - root)/(2*a);
                              res[1] = (-b + root)/(2*a);
                              num = 2; // don't bother distinguishing 1-solution case, as code below will still work
                           }
                        }
                     } else {
                        float b = 3*(ax*bx + ay*by) * a_inv; // could precompute this as it doesn't depend on sample point
                        float c = (2*(ax*ax + ay*ay) + (mx*bx+my*by)) * a_inv;
                        float d = (mx*ax+my*ay) * a_inv;
                        num = stbtt__solve_cubic(b, c, d, res);
                     }
                     if (num >= 1 && res[0] >= 0.0f && res[0] <= 1.0f) {
                        t = res[0], it = 1.0f - t;
                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;
                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;
                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);
                        if (dist2 < min_dist * min_dist)
                           min_dist = (float) STBTT_sqrt(dist2);
                     }
                     if (num >= 2 && res[1] >= 0.0f && res[1] <= 1.0f) {
                        t = res[1], it = 1.0f - t;
                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;
                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;
                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);
                        if (dist2 < min_dist * min_dist)
                           min_dist = (float) STBTT_sqrt(dist2);
                     }
                     if (num >= 3 && res[2] >= 0.0f && res[2] <= 1.0f) {
                        t = res[2], it = 1.0f - t;
                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;
                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;
                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);
                        if (dist2 < min_dist * min_dist)
                           min_dist = (float) STBTT_sqrt(dist2);
                     }
                  }
               }
            }
            if (winding == 0)
               min_dist = -min_dist;  // if outside the shape, value is negative
            val = onedge_value + pixel_dist_scale * min_dist;
            if (val < 0)
               val = 0;
            else if (val > 255)
               val = 255;
            data[(y-iy0)*w+(x-ix0)] = (unsigned char) val;
         }
      }
      STBTT_free(precompute, info->userdata);
      STBTT_free(verts, info->userdata);
   }
   return data;
}   

STBTT_DEF unsigned char * stbtt_GetCodepointSDF(const stbtt_fontinfo *info, float scale, int codepoint, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff)
{
   return stbtt_GetGlyphSDF(info, scale, stbtt_FindGlyphIndex(info, codepoint), padding, onedge_value, pixel_dist_scale, width, height, xoff, yoff);
}

STBTT_DEF void stbtt_FreeSDF(unsigned char *bitmap, void *userdata)
{
   STBTT_free(bitmap, userdata);
}

//////////////////////////////////////////////////////////////////////////////
//
// font name matching -- recommended not to use this
//

// check if a utf8 string contains a prefix which is the utf16 string; if so return length of matching utf8 string
static stbtt_int32 stbtt__CompareUTF8toUTF16_bigendian_prefix(stbtt_uint8 *s1, stbtt_int32 len1, stbtt_uint8 *s2, stbtt_int32 len2) 
{
   stbtt_int32 i=0;

   // convert utf16 to utf8 and compare the results while converting
   while (len2) {
      stbtt_uint16 ch = s2[0]*256 + s2[1];
      if (ch < 0x80) {
         if (i >= len1) return -1;
         if (s1[i++] != ch) return -1;
      } else if (ch < 0x800) {
         if (i+1 >= len1) return -1;
         if (s1[i++] != 0xc0 + (ch >> 6)) return -1;
         if (s1[i++] != 0x80 + (ch & 0x3f)) return -1;
      } else if (ch >= 0xd800 && ch < 0xdc00) {
         stbtt_uint32 c;
         stbtt_uint16 ch2 = s2[2]*256 + s2[3];
         if (i+3 >= len1) return -1;
         c = ((ch - 0xd800) << 10) + (ch2 - 0xdc00) + 0x10000;
         if (s1[i++] != 0xf0 + (c >> 18)) return -1;
         if (s1[i++] != 0x80 + ((c >> 12) & 0x3f)) return -1;
         if (s1[i++] != 0x80 + ((c >>  6) & 0x3f)) return -1;
         if (s1[i++] != 0x80 + ((c      ) & 0x3f)) return -1;
         s2 += 2; // plus another 2 below
         len2 -= 2;
      } else if (ch >= 0xdc00 && ch < 0xe000) {
         return -1;
      } else {
         if (i+2 >= len1) return -1;
         if (s1[i++] != 0xe0 + (ch >> 12)) return -1;
         if (s1[i++] != 0x80 + ((ch >> 6) & 0x3f)) return -1;
         if (s1[i++] != 0x80 + ((ch     ) & 0x3f)) return -1;
      }
      s2 += 2;
      len2 -= 2;
   }
   return i;
}

static int stbtt_CompareUTF8toUTF16_bigendian_internal(char *s1, int len1, char *s2, int len2) 
{
   return len1 == stbtt__CompareUTF8toUTF16_bigendian_prefix((stbtt_uint8*) s1, len1, (stbtt_uint8*) s2, len2);
}

// returns results in whatever encoding you request... but note that 2-byte encodings
// will be BIG-ENDIAN... use stbtt_CompareUTF8toUTF16_bigendian() to compare
STBTT_DEF const char *stbtt_GetFontNameString(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID)
{
   stbtt_int32 i,count,stringOffset;
   stbtt_uint8 *fc = font->data;
   stbtt_uint32 offset = font->fontstart;
   stbtt_uint32 nm = stbtt__find_table(fc, offset, "name");
   if (!nm) return NULL;

   count = ttUSHORT(fc+nm+2);
   stringOffset = nm + ttUSHORT(fc+nm+4);
   for (i=0; i < count; ++i) {
      stbtt_uint32 loc = nm + 6 + 12 * i;
      if (platformID == ttUSHORT(fc+loc+0) && encodingID == ttUSHORT(fc+loc+2)
          && languageID == ttUSHORT(fc+loc+4) && nameID == ttUSHORT(fc+loc+6)) {
         *length = ttUSHORT(fc+loc+8);
         return (const char *) (fc+stringOffset+ttUSHORT(fc+loc+10));
      }
   }
   return NULL;
}

static int stbtt__matchpair(stbtt_uint8 *fc, stbtt_uint32 nm, stbtt_uint8 *name, stbtt_int32 nlen, stbtt_int32 target_id, stbtt_int32 next_id)
{
   stbtt_int32 i;
   stbtt_int32 count = ttUSHORT(fc+nm+2);
   stbtt_int32 stringOffset = nm + ttUSHORT(fc+nm+4);

   for (i=0; i < count; ++i) {
      stbtt_uint32 loc = nm + 6 + 12 * i;
      stbtt_int32 id = ttUSHORT(fc+loc+6);
      if (id == target_id) {
         // find the encoding
         stbtt_int32 platform = ttUSHORT(fc+loc+0), encoding = ttUSHORT(fc+loc+2), language = ttUSHORT(fc+loc+4);

         // is this a Unicode encoding?
         if (platform == 0 || (platform == 3 && encoding == 1) || (platform == 3 && encoding == 10)) {
            stbtt_int32 slen = ttUSHORT(fc+loc+8);
            stbtt_int32 off = ttUSHORT(fc+loc+10);

            // check if there's a prefix match
            stbtt_int32 matchlen = stbtt__CompareUTF8toUTF16_bigendian_prefix(name, nlen, fc+stringOffset+off,slen);
            if (matchlen >= 0) {
               // check for target_id+1 immediately following, with same encoding & language
               if (i+1 < count && ttUSHORT(fc+loc+12+6) == next_id && ttUSHORT(fc+loc+12) == platform && ttUSHORT(fc+loc+12+2) == encoding && ttUSHORT(fc+loc+12+4) == language) {
                  slen = ttUSHORT(fc+loc+12+8);
                  off = ttUSHORT(fc+loc+12+10);
                  if (slen == 0) {
                     if (matchlen == nlen)
                        return 1;
                  } else if (matchlen < nlen && name[matchlen] == ' ') {
                     ++matchlen;
                     if (stbtt_CompareUTF8toUTF16_bigendian_internal((char*) (name+matchlen), nlen-matchlen, (char*)(fc+stringOffset+off),slen))
                        return 1;
                  }
               } else {
                  // if nothing immediately following
                  if (matchlen == nlen)
                     return 1;
               }
            }
         }

         // @TODO handle other encodings
      }
   }
   return 0;
}

static int stbtt__matches(stbtt_uint8 *fc, stbtt_uint32 offset, stbtt_uint8 *name, stbtt_int32 flags)
{
   stbtt_int32 nlen = (stbtt_int32) STBTT_strlen((char *) name);
   stbtt_uint32 nm,hd;
   if (!stbtt__isfont(fc+offset)) return 0;

   // check italics/bold/underline flags in macStyle...
   if (flags) {
      hd = stbtt__find_table(fc, offset, "head");
      if ((ttUSHORT(fc+hd+44) & 7) != (flags & 7)) return 0;
   }

   nm = stbtt__find_table(fc, offset, "name");
   if (!nm) return 0;

   if (flags) {
      // if we checked the macStyle flags, then just check the family and ignore the subfamily
      if (stbtt__matchpair(fc, nm, name, nlen, 16, -1))  return 1;
      if (stbtt__matchpair(fc, nm, name, nlen,  1, -1))  return 1;
      if (stbtt__matchpair(fc, nm, name, nlen,  3, -1))  return 1;
   } else {
      if (stbtt__matchpair(fc, nm, name, nlen, 16, 17))  return 1;
      if (stbtt__matchpair(fc, nm, name, nlen,  1,  2))  return 1;
      if (stbtt__matchpair(fc, nm, name, nlen,  3, -1))  return 1;
   }

   return 0;
}

static int stbtt_FindMatchingFont_internal(unsigned char *font_collection, char *name_utf8, stbtt_int32 flags)
{
   stbtt_int32 i;
   for (i=0;;++i) {
      stbtt_int32 off = stbtt_GetFontOffsetForIndex(font_collection, i);
      if (off < 0) return off;
      if (stbtt__matches((stbtt_uint8 *) font_collection, off, (stbtt_uint8*) name_utf8, flags))
         return off;
   }
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wcast-qual"
#endif

STBTT_DEF int stbtt_BakeFontBitmap(const unsigned char *data, int offset,
                                float pixel_height, unsigned char *pixels, int pw, int ph,
                                int first_char, int num_chars, stbtt_bakedchar *chardata)
{
   return stbtt_BakeFontBitmap_internal((unsigned char *) data, offset, pixel_height, pixels, pw, ph, first_char, num_chars, chardata);
}

STBTT_DEF int stbtt_GetFontOffsetForIndex(const unsigned char *data, int index)
{
   return stbtt_GetFontOffsetForIndex_internal((unsigned char *) data, index);   
}

STBTT_DEF int stbtt_GetNumberOfFonts(const unsigned char *data)
{
   return stbtt_GetNumberOfFonts_internal((unsigned char *) data);
}

STBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset)
{
   return stbtt_InitFont_internal(info, (unsigned char *) data, offset);
}

STBTT_DEF int stbtt_FindMatchingFont(const unsigned char *fontdata, const char *name, int flags)
{
   return stbtt_FindMatchingFont_internal((unsigned char *) fontdata, (char *) name, flags);
}

STBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2)
{
   return stbtt_CompareUTF8toUTF16_bigendian_internal((char *) s1, len1, (char *) s2, len2);
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif

#endif // STB_TRUETYPE_IMPLEMENTATION


// FULL VERSION HISTORY
//
//   1.19 (2018-02-11) OpenType GPOS kerning (horizontal only), STBTT_fmod
//   1.18 (2018-01-29) add missing function
//   1.17 (2017-07-23) make more arguments const; doc fix
//   1.16 (2017-07-12) SDF support
//   1.15 (2017-03-03) make more arguments const
//   1.14 (2017-01-16) num-fonts-in-TTC function
//   1.13 (2017-01-02) support OpenType fonts, certain Apple fonts
//   1.12 (2016-10-25) suppress warnings about casting away const with -Wcast-qual
//   1.11 (2016-04-02) fix unused-variable warning
//   1.10 (2016-04-02) allow user-defined fabs() replacement
//                     fix memory leak if fontsize=0.0
//                     fix warning from duplicate typedef
//   1.09 (2016-01-16) warning fix; avoid crash on outofmem; use alloc userdata for PackFontRanges
//   1.08 (2015-09-13) document stbtt_Rasterize(); fixes for vertical & horizontal edges
//   1.07 (2015-08-01) allow PackFontRanges to accept arrays of sparse codepoints;
//                     allow PackFontRanges to pack and render in separate phases;
//                     fix stbtt_GetFontOFfsetForIndex (never worked for non-0 input?);
//                     fixed an assert() bug in the new rasterizer
//                     replace assert() with STBTT_assert() in new rasterizer
//   1.06 (2015-07-14) performance improvements (~35% faster on x86 and x64 on test machine)
//                     also more precise AA rasterizer, except if shapes overlap
//                     remove need for STBTT_sort
//   1.05 (2015-04-15) fix misplaced definitions for STBTT_STATIC
//   1.04 (2015-04-15) typo in example
//   1.03 (2015-04-12) STBTT_STATIC, fix memory leak in new packing, various fixes
//   1.02 (2014-12-10) fix various warnings & compile issues w/ stb_rect_pack, C++
//   1.01 (2014-12-08) fix subpixel position when oversampling to exactly match
//                        non-oversampled; STBTT_POINT_SIZE for packed case only
//   1.00 (2014-12-06) add new PackBegin etc. API, w/ support for oversampling
//   0.99 (2014-09-18) fix multiple bugs with subpixel rendering (ryg)
//   0.9  (2014-08-07) support certain mac/iOS fonts without an MS platformID
//   0.8b (2014-07-07) fix a warning
//   0.8  (2014-05-25) fix a few more warnings
//   0.7  (2013-09-25) bugfix: subpixel glyph bug fixed in 0.5 had come back
//   0.6c (2012-07-24) improve documentation
//   0.6b (2012-07-20) fix a few more warnings
//   0.6  (2012-07-17) fix warnings; added stbtt_ScaleForMappingEmToPixels,
//                        stbtt_GetFontBoundingBox, stbtt_IsGlyphEmpty
//   0.5  (2011-12-09) bugfixes:
//                        subpixel glyph renderer computed wrong bounding box
//                        first vertex of shape can be off-curve (FreeSans)
//   0.4b (2011-12-03) fixed an error in the font baking example
//   0.4  (2011-12-01) kerning, subpixel rendering (tor)
//                    bugfixes for:
//                        codepoint-to-glyph conversion using table fmt=12
//                        codepoint-to-glyph conversion using table fmt=4
//                        stbtt_GetBakedQuad with non-square texture (Zer)
//                    updated Hello World! sample to use kerning and subpixel
//                    fixed some warnings
//   0.3  (2009-06-24) cmap fmt=12, compound shapes (MM)
//                    userdata, malloc-from-userdata, non-zero fill (stb)
//   0.2  (2009-03-11) Fix unsigned/signed char warnings
//   0.1  (2009-03-09) First public release
//

/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of 
this software and associated documentation files (the "Software"), to deal in 
the Software without restriction, including without limitation the rights to 
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies 
of the Software, and to permit persons to whom the Software is furnished to do 
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all 
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this 
software, either in source code form or as a compiled binary, for any purpose, 
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this 
software dedicate any and all copyright interest in the software to the public 
domain. We make this dedication for the benefit of the public at large and to 
the detriment of our heirs and successors. We intend this dedication to be an 
overt act of relinquishment in perpetuity of all present and future rights to 
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN 
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/

```

`UnrealFinderTool/InstanceLogger.cpp`:

```cpp
#include "pch.h"
#include "ObjectsStore.h"
#include "NamesStore.h"
#include "EngineClasses.h"
#include "InstanceLogger.h"

#include <cinttypes>

InstanceLogger::InstanceLogger(const uintptr_t gObjObjectsAddress, const uintptr_t gNamesAddress) :
	gObjectsAddress(gObjObjectsAddress),
	gNamesAddress(gNamesAddress)
{
}

bool InstanceLogger::ObjectDump()
{
	FILE* log = nullptr;
	fopen_s(&log, "ObjectDump.txt", "w+");

	if (log == nullptr)
	{
		OutputDebugString("Can't open 'ObjectDump.txt' for write.");
		return false;
	}

	for (size_t i = 0; i < ObjectsStore().GetObjectsNum(); ++i)
	{
		if (ObjectsStore().GetByIndex(i)->GetAddress() != NULL)
		{
			const UEObject* obj = ObjectsStore().GetByIndex(i);
			fprintf(log, "[%06i] %-100s 0x%" PRIXPTR "\n", int(i), obj->GetName().c_str(), obj->GetAddress());
		}
	}

	fclose(log);
	return true;
}

bool InstanceLogger::NameDump()
{
	FILE* log = nullptr;
	fopen_s(&log, "NameDump.txt", "w+");

	if (log == nullptr)
	{
		OutputDebugString("Can't open 'NameDump.txt' for write.");
		return false;
	}

	for (size_t i = 0; i < NamesStore().GetNamesNum(); ++i)
	{
		std::string str = NamesStore().GetByIndex(i);
		if (!str.empty())
			fprintf(log, "[%06i] %s\n", int(i), NamesStore().GetByIndex(i).c_str());
	}

	fclose(log);
	return true;
}

LoggerRetState InstanceLogger::Start()
{
	LoggerState s = FetchData();
	if (s != LoggerState::Good)
		return { s, 0, 0 };

	NameDump();
	ObjectDump();

	return { LoggerState::Good, ObjectsStore().GetObjectsNum(), NamesStore().GetNamesNum() };
}

LoggerState InstanceLogger::FetchData()
{
	if (!Utils::IsValidGNamesAddress(gNamesAddress))
		return LoggerState::BadGNameAddress;

	if (!Utils::IsValidGObjectsAddress(gObjectsAddress))
		return LoggerState::BadGObjectAddress;

	// GNames
	if (!NamesStore::Initialize(gNamesAddress))
		return LoggerState::BadGName;

	// GObjects
	if (!ObjectsStore::Initialize(gObjectsAddress))
		return LoggerState::BadGObject;

	return LoggerState::Good;
}
```

`UnrealFinderTool/InstanceLogger.h`:

```h
#pragma once

class UObject;

enum class LoggerState
{
	Good,
	BadGObjectAddress,
	BadGNameAddress,
	BadGObject,
	BadGName
};

struct LoggerRetState
{
	LoggerState State;
	size_t GObjectsCount;
	size_t GNamesCount;
};

class InstanceLogger
{
	uintptr_t gObjectsAddress, gNamesAddress;

	LoggerState FetchData();
	bool ObjectDump();
	bool NameDump();
public:
	InstanceLogger(uintptr_t gObjObjectsAddress, uintptr_t gNamesAddress);
	LoggerRetState Start();
};
```

`UnrealFinderTool/JsonReflector.cpp`:

```cpp
#include "pch.h"
#include "Memory.h"
#include "JsonReflector.h"
#include <fstream>

JsonStructs JsonReflector::StructsList;
nlohmann::json JsonReflector::JsonObj;
nlohmann::json JsonReflector::JsonBaseObj;

#pragma region JsonReflector
bool JsonReflector::ReadJsonFile(const std::string& fileName, nlohmann::json* jsonObj)
{
	// read a JSON file
	std::ifstream i(fileName.c_str());
	if (!i.good()) return false;
	i >> *reinterpret_cast<nlohmann::json*>(jsonObj);
	return true;
}

bool JsonReflector::ReadJsonFile(const std::string& fileName)
{
	return ReadJsonFile(fileName, &JsonObj);
}

JsonStruct JsonReflector::GetStruct(const std::string& structName)
{
	auto s = StructsList.find(structName);
	if (s != StructsList.end())
		return s->second;

	throw std::exception(("Can't find " + structName + " in loaded structs.").c_str());
}

bool JsonReflector::LoadStruct(const std::string& structName, nlohmann::json* jsonObj, const bool overrideOld)
{
	// Check is already here
	if (StructsList.find(structName) != StructsList.end() && !overrideOld) return true;

	// Don't make it reference var
	auto j = *jsonObj;
	auto jOver = JsonObj;

	for (const auto& parent : j.at("structs").items())
	{
		const std::string eName = parent.value().at("name");
		if (eName == structName)
		{
			JsonStruct tempToSave;
			JsonVariables vars;
			int structSize = 0;
			int offset = 0;

			// Get Super
			const std::string eSuper = parent.value().at("super");
			if (!eSuper.empty())
			{
				tempToSave.StructSuper = eSuper;

				// Add super struct Variables to struct first
				if (LoadStruct(eSuper, overrideOld ? &jOver : jsonObj, overrideOld))
				{
					auto s = StructsList.find(eSuper);
					if (s != StructsList.end())
					{
						for (const auto& var : s->second.Vars)
						{
							JsonVar variable = var.second;

							const std::string& name = variable.Name;
							std::string type = variable.Type;

							auto jVar = JsonVar(name, type, offset, IsStructType(type));
							vars.push_back({ name , jVar });

							offset += jVar.Size;
						}

						structSize += s->second.GetSize(false);
					}
				}
				else
				{
					throw std::exception(("Can't find `" + eSuper + "` Struct.").c_str());
				}
			}

			// Init vars
			auto element = parent.value().at("vars");
			for (const auto& var : element.items())
			{
				nlohmann::json::iterator it = var.value().begin();

				if (it.value().is_number_unsigned())
					structSize += static_cast<int>(var.value());
				else
					structSize += VarSizeFromJson(it.value(), overrideOld);

				const std::string& name = it.key();
				std::string type = it.value();

				JsonVar jVar(name, type, offset, IsStructType(type));
				vars.push_back({ name , jVar });


				offset += jVar.Size;
			}

			// Init struct
			tempToSave.StructName = eName;
			tempToSave.Vars = vars;
			tempToSave.SetSize(structSize);

			// [Copy] the struct to structs list
			{
				// Override old struct
				if (overrideOld)
				{
					// check if it in the list
					auto foundIt = StructsList.find(eName);
					if (foundIt != StructsList.end())
					{
						*foundIt = { eName, tempToSave };
					}
				}

				// check if it not in the list
				if (StructsList.find(eName) == StructsList.end())
					StructsList.push_back({ eName, tempToSave });
			}

			return true;
		}
	}

	// if code hit here then there is no override in the `override engine` file
	// so by return true i just give it the struct from `EngineBase` file, because it already loaded !!
	return overrideOld;
}

bool JsonReflector::Load(nlohmann::json* jsonObj, const bool overrideOld)
{
	auto j = *jsonObj;

	for (const auto& parent : j.at("structs").items())
	{
		const std::string eName = parent.value().at("name");
		// Check is already here
		if (StructsList.find(eName) != StructsList.end() && !overrideOld) continue;

		JsonStruct tempToSave;
		JsonVariables vars;
		int structSize = 0;
		int offset = 0;

		// Get Super
		const std::string eSuper = parent.value().at("super");
		if (!eSuper.empty())
		{
			tempToSave.StructSuper = eSuper;

			// Add super struct Variables to struct first
			if (LoadStruct(eSuper, jsonObj, overrideOld))
			{
				auto s = StructsList.find(eSuper);
				if (s != StructsList.end())
				{
					for (const auto& var : s->second.Vars)
					{
						JsonVar variable = var.second;

						const std::string& name = variable.Name;
						std::string type = variable.Type;

						auto jVar = JsonVar(name, type, offset, IsStructType(type));
						vars.push_back({ name , jVar });

						offset += jVar.Size;
					}

					structSize += s->second.GetSize(false);
				}
			}
			else
			{
				throw std::exception(("Can't find `" + eSuper + "` Struct.").c_str());
			}
		}

		// Init vars
		auto element = parent.value().at("vars");
		for (const auto& var : element.items())
		{
			nlohmann::json::iterator it = var.value().begin();

			if (it.value().is_number_unsigned())
				structSize += static_cast<int>(var.value());
			else
				structSize += VarSizeFromJson(it.value(), overrideOld); // VarSizeFromJson Load other struct if not loaded

			const std::string& name = it.key();
			std::string type = it.value();

			auto jVar = JsonVar(name, type, offset, IsStructType(type));
			vars.push_back({ name , jVar });

			offset += jVar.Size;
		}

		// Init struct
		tempToSave.StructName = eName;
		tempToSave.Vars = vars;
		tempToSave.SetSize(structSize);

		// [Copy] the struct to structs list
		{
			// Override old struct
			if (overrideOld)
			{
				// check if it in the list
				auto foundIt = StructsList.find(eName);
				if (foundIt != StructsList.end())
				{
					*foundIt = { eName, tempToSave };
				}

				// Update all structs that inheritance form this overrides struct
				// Twice to be sure all structs override
				for (size_t i = 0; i < 2; i++)
				{
					for (auto& jStructContainer : StructsList)
					{
						auto& jStruct = jStructContainer.second;
						LoadStruct(jStruct.StructName, &JsonBaseObj, true);
					}
				}
			}

			// check if it not in the list
			if (StructsList.find(eName) == StructsList.end())
				StructsList.push_back({ eName, tempToSave });
		}
	}
	return true;
}

bool JsonReflector::Load(const bool overrideOld)
{
	return Load(&JsonObj, overrideOld);
}

bool JsonReflector::ReadAndLoadFile(const std::string& fileName, nlohmann::json* jsonObj, const bool overrideOld)
{
	return ReadJsonFile(fileName, jsonObj) && Load(jsonObj, overrideOld);
}

bool JsonReflector::ReadAndLoadFile(const std::string& fileName, const bool overrideOld)
{
	return ReadAndLoadFile(fileName, &JsonObj, overrideOld);
}

int JsonReflector::VarSizeFromJson(const std::string& typeName, const bool overrideOld)
{
	if (typeName == "bool")
		return sizeof(bool);
	if (typeName == "int8")
		return sizeof(int8_t);
	if (typeName == "int16")
		return sizeof(int16_t);
	if (typeName == "int" || typeName == "int32")
		return sizeof(int32_t);
	if (typeName == "int64")
		return sizeof(int64_t);

	if (typeName == "uint8")
		return sizeof(uint8_t);
	if (typeName == "uint16")
		return sizeof(uint16_t);
	if (typeName == "uint" || typeName == "uint32")
		return sizeof(uint32_t);
	if (typeName == "uint64")
		return sizeof(uint64_t);

	if (Utils::EndsWith(typeName, "*")) // pointer
		return sizeof(uintptr_t);
	if (typeName == "DWORD")
		return sizeof(DWORD);
	if (typeName == "DWORD64")
		return sizeof(DWORD64);
	if (typeName == "string")
		return sizeof(uintptr_t);

	// Other type (usually) structs
	if (Utils::IsNumber(typeName))
		return std::stoi(typeName);

	if (IsStructType(typeName))
	{
		if (LoadStruct(typeName, &JsonObj, overrideOld))
		{
			auto s = StructsList.find(typeName);
			if (s != StructsList.end())
				return s->second.GetSize(false);
		}
		throw std::exception(("Cant find struct `" + typeName + "`.").c_str());
	}
	throw std::exception(("Cant detect size of `" + typeName + "`.").c_str());
}

bool JsonReflector::IsStructType(const std::string& typeName)
{
	const bool isStruct =
		typeName == "bool" ||
		typeName == "int8" ||
		typeName == "int16" ||
		typeName == "int" ||
		typeName == "int32" ||
		typeName == "int64" ||

		typeName == "uint8" ||
		typeName == "uint16" ||
		typeName == "uint" ||
		typeName == "uint32" ||
		typeName == "uint64" ||

		Utils::EndsWith(typeName, "*") || // pointer
		typeName == "DWORD" ||
		typeName == "DWORD64" ||
		typeName == "string" ||

		Utils::IsNumber(typeName);
	return !isStruct;
}
#pragma endregion

#pragma region JsonStruct
int JsonStruct::GetSize(const bool subUnneeded)
{
	if (!Utils::MemoryObj || !subUnneeded)
		return structSize;

	return structSize - GetUnneededSize();
}

int JsonStruct::GetUnneededSize()
{
	int sSub = 0;

	if (Utils::ProgramIs64() && !Utils::MemoryObj->Is64Bit)
	{
		// if it's 32bit game (4byte pointer) sub 4byte for every pointer
		for (auto& varContainer : Vars)
		{
			auto& var = varContainer.second;
			if (Utils::EndsWith(var.Type, "*"))
				sSub += 0x4;
			else if (var.IsStruct)
				sSub += var.Struct.GetUnneededSize();
		}
	}

	return sSub;
}

void JsonStruct::SetSize(const int newSize)
{
	structSize = newSize;
}

JsonVar& JsonStruct::operator[](const std::string& varName)
{
	return GetVar(varName);
}

JsonVar& JsonStruct::GetVar(const std::string& varName)
{
	if (Vars.find(varName) != Vars.end())
		return Vars.find(varName)->second;

	throw std::exception(("Not found " + varName + " in JsonVariables").c_str());
}
#pragma endregion

#pragma region JsonVar
JsonVar::JsonVar(const std::string& name, const std::string& type, const int offset, const bool isStruct)
{
	Name = name;
	Type = type;
	Size = JsonReflector::VarSizeFromJson(Type, false);
	Offset = offset;
	IsStruct = isStruct;

	if (IsStruct)
		LoadStructVars();
}

JsonVar& JsonVar::operator[](const std::string& varName)
{
	if (!IsStruct)
		throw std::exception((Name + " not a struct.").c_str());

	return GetVar(varName);
}

JsonVar& JsonVar::GetVar(const std::string& varName)
{
	if (!IsStruct)
		throw std::exception((Name + " not a struct.").c_str());

	if (Struct.Vars.find(varName) != Struct.Vars.end())
		return Struct.Vars.find(varName)->second;

	throw std::exception(("Not found " + varName + " in JsonVariables").c_str());
}

void JsonVar::LoadStructVars()
{
	if (!IsStruct)
		throw std::exception((Name + " Not a struct.").c_str());

	auto sStructIt = JsonReflector::StructsList.find(Type);
	if (sStructIt == JsonReflector::StructsList.end())
		throw std::exception(("Can't find struct When try read as " + Type).c_str());

	Struct = sStructIt->second;
}
#pragma endregion

```

`UnrealFinderTool/JsonReflector.h`:

```h
#pragma once
#include "json.hpp"
#include "UnsortedMap.h"

class JsonStruct;
class JsonVar;
class Memory;

using JsonStructs = UnsortedMap<std::string, JsonStruct>;
using JsonVariables = UnsortedMap<std::string, JsonVar>;

class JsonReflector
{
public:
	// json reader for EngineBaseFile
	static nlohmann::json JsonBaseObj;
	// Main json reader for structs
	static nlohmann::json JsonObj;
	// Contains all loaded structs
	static JsonStructs StructsList;
	// Read Json file into memory to be ready to load structs inside them
	static bool ReadJsonFile(const std::string& fileName, nlohmann::json* jsonObj);
	// Read Json file into memory to be ready to load structs inside them, [Using main `JsonObj`]
	static bool ReadJsonFile(const std::string& fileName);
	// Check variable type is struct
	static bool IsStructType(const std::string& typeName);
	// Read struct form loaded json structs
	static JsonStruct GetStruct(const std::string& structName);
	// Load all json structs inside `StructsList`
	static bool Load(nlohmann::json* jsonObj, bool overrideOld = false);
	// Load all json structs inside `StructsList`, [Using main `JsonObj`]
	static bool Load(bool overrideOld = false);
	// Read Json file into memory AND read all structs inside json file, then store structs inside `StructsList`
	static bool ReadAndLoadFile(const std::string& fileName, nlohmann::json* jsonObj, bool overrideOld = false);
	// Read Json file into memory AND read all structs inside json file, then store structs inside `StructsList`, [Using main `JsonObj`]
	static bool ReadAndLoadFile(const std::string& fileName, bool overrideOld = false);
	// Load json struct by name
	static bool LoadStruct(const std::string& structName, nlohmann::json* jsonObj, bool overrideOld = false);
	// Get json struct variable size
	static int VarSizeFromJson(const std::string& typeName, bool overrideOld);
};

class JsonStruct
{
	// Size of this struct
	int structSize = 0;
	// Get unneeded size to sub from the struct size
	int GetUnneededSize();

public:
	// Struct Name
	std::string StructName;
	// Super Name
	std::string StructSuper;
	// Variables inside this struct
	JsonVariables Vars;

	// Size of this struct, useful for 32bit games in 64bit version of this tool
	int GetSize(bool subUnneeded = true);
	// Don't use it outside `JsonReflector Load Functions`
	void SetSize(int newSize);
	// Access to variable inside this struct
	JsonVar& operator[](const std::string& varName);
	// Access to variable inside this struct
	JsonVar& GetVar(const std::string& varName);
};

class JsonVar
{
public:
	// Variable Name
	std::string Name;
	// Variable Type
	std::string Type;
	// Variable Size
	int Size = 0;
	// Variable offset of his parent
	int Offset = 0;
	// Variable is struct
	bool IsStruct = false;
	// If this variable is struct this is pointer to struct contains variables
	JsonStruct Struct{};

	JsonVar(const std::string& name, const std::string& type, int offset, bool isStruct);

	// Access variable inside this variable, ONLY work if this variable is struct
	JsonVar& operator[](const std::string& varName);
	// Read variable as struct, ONLY work if this variable is struct [NOT POINTER TO STRUCT]
	void LoadStructVars();
private:
	// Access variable in this variable if this variable is struct
	JsonVar& GetVar(const std::string& varName);
};

```

`UnrealFinderTool/KProcessHacker.h`:

```h
#pragma once

#if INTPTR_MAX == INT32_MAX
#define KProcessHacker KProcessHacker_2_38_x86
#define KProcessHackerSize KProcessHacker_2_38_x86_size
#else
#define KProcessHacker KProcessHacker_2_38_x64
#define KProcessHackerSize KProcessHacker_2_38_x64_size
#endif

const size_t KProcessHacker_2_38_x86_size = 36376;
const unsigned char KProcessHacker_2_38_x86[36376] = {
	0x4D, 0x5A, 0x90, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00,
	0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x02, 0x00, 0x00,
	0x0E, 0x1F, 0xBA, 0x0E, 0x00, 0xB4, 0x09, 0xCD, 0x21, 0xB8, 0x01, 0x4C, 0xCD, 0x21, 0x54, 0x68,
	0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 0x67, 0x72, 0x61, 0x6D, 0x20, 0x63, 0x61, 0x6E, 0x6E, 0x6F,
	0x74, 0x20, 0x62, 0x65, 0x20, 0x72, 0x75, 0x6E, 0x20, 0x69, 0x6E, 0x20, 0x44, 0x4F, 0x53, 0x20,
	0x6D, 0x6F, 0x64, 0x65, 0x2E, 0x0D, 0x0D, 0x0A, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0F, 0xAF, 0x3D, 0x7C, 0x4B, 0xCE, 0x53, 0x2F, 0x4B, 0xCE, 0x53, 0x2F, 0x4B, 0xCE, 0x53, 0x2F,
	0x42, 0xB6, 0xC6, 0x2F, 0x4F, 0xCE, 0x53, 0x2F, 0x4B, 0xCE, 0x52, 0x2F, 0x06, 0xCE, 0x53, 0x2F,
	0x88, 0xC1, 0x0E, 0x2F, 0x4E, 0xCE, 0x53, 0x2F, 0x88, 0xC1, 0x0C, 0x2F, 0x4A, 0xCE, 0x53, 0x2F,
	0x42, 0xB6, 0xD0, 0x2F, 0x46, 0xCE, 0x53, 0x2F, 0x42, 0xB6, 0xC7, 0x2F, 0x4A, 0xCE, 0x53, 0x2F,
	0x42, 0xB6, 0xC2, 0x2F, 0x4A, 0xCE, 0x53, 0x2F, 0x52, 0x69, 0x63, 0x68, 0x4B, 0xCE, 0x53, 0x2F,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x45, 0x00, 0x00, 0x4C, 0x01, 0x07, 0x00,
	0xE2, 0x77, 0x69, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x02, 0x01,
	0x0B, 0x01, 0x09, 0x00, 0x80, 0x51, 0x00, 0x00, 0x80, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xBE, 0x57, 0x00, 0x00, 0x80, 0x04, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
	0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x06, 0x00, 0x01, 0x00, 0x06, 0x00, 0x01, 0x00,
	0x05, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x69, 0x00, 0x00, 0x80, 0x04, 0x00, 0x00,
	0x9C, 0x38, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x10, 0x00, 0x00,
	0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0x57, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00,
	0x00, 0x60, 0x00, 0x00, 0xF8, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x80, 0x69, 0x00, 0x00, 0x98, 0x24, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x78, 0x05, 0x00, 0x00,
	0x40, 0x13, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x60, 0x13, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x12, 0x00, 0x00, 0x3C, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x2E, 0x74, 0x65, 0x78, 0x74, 0x00, 0x00, 0x00, 0x4A, 0x0D, 0x00, 0x00, 0x80, 0x04, 0x00, 0x00,
	0x80, 0x0D, 0x00, 0x00, 0x80, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x68, 0x2E, 0x72, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00,
	0xB4, 0x06, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x48,
	0x2E, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0xB4, 0x02, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00,
	0x00, 0x03, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0xC8, 0x50, 0x41, 0x47, 0x45, 0x00, 0x00, 0x00, 0x00,
	0x50, 0x3B, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x80, 0x3B, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x60,
	0x49, 0x4E, 0x49, 0x54, 0x00, 0x00, 0x00, 0x00, 0x42, 0x08, 0x00, 0x00, 0x80, 0x57, 0x00, 0x00,
	0x80, 0x08, 0x00, 0x00, 0x80, 0x57, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0xE2, 0x2E, 0x72, 0x73, 0x72, 0x63, 0x00, 0x00, 0x00,
	0xF8, 0x02, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x42,
	0x2E, 0x72, 0x65, 0x6C, 0x6F, 0x63, 0x00, 0x00, 0x0E, 0x06, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00,
	0x80, 0x06, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x1C, 0xA1, 0x10,
	0x1A, 0x01, 0x00, 0x33, 0xC5, 0x89, 0x45, 0xFC, 0x83, 0x65, 0xE4, 0x00, 0x53, 0x8B, 0x1D, 0x0C,
	0x12, 0x01, 0x00, 0x56, 0x8B, 0x75, 0x0C, 0x8B, 0x46, 0x60, 0x57, 0x8B, 0x78, 0x04, 0xFF, 0xD3,
	0x33, 0xC0, 0x40, 0x39, 0x05, 0xA8, 0x1B, 0x01, 0x00, 0x75, 0x38, 0x83, 0x65, 0xF4, 0x00, 0x83,
	0x65, 0xF8, 0x00, 0x89, 0x45, 0xE8, 0x89, 0x45, 0xEC, 0x0F, 0xB6, 0x46, 0x20, 0x50, 0x8B, 0x47,
	0x04, 0x83, 0xC0, 0x1C, 0x50, 0x8D, 0x45, 0xE8, 0x50, 0xC7, 0x45, 0xF0, 0x14, 0x00, 0x00, 0x00,
	0xFF, 0x15, 0x98, 0x12, 0x01, 0x00, 0x84, 0xC0, 0x75, 0x09, 0xBF, 0x61, 0x00, 0x00, 0xC0, 0xFF,
	0xD3, 0xEB, 0x03, 0x8B, 0x7D, 0xE4, 0x83, 0x66, 0x1C, 0x00, 0x32, 0xD2, 0x8B, 0xCE, 0x89, 0x7E,
	0x18, 0xFF, 0x15, 0x28, 0x13, 0x01, 0x00, 0x8B, 0x4D, 0xFC, 0x8B, 0xC7, 0x5F, 0x5E, 0x33, 0xCD,
	0x5B, 0xE8, 0xE5, 0x08, 0x00, 0x00, 0xC9, 0xC2, 0x08, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x51, 0x51, 0x53, 0x56, 0x57, 0xC7, 0x45, 0xFC, 0x00, 0x08, 0x00,
	0x00, 0xC7, 0x45, 0xF8, 0x08, 0x00, 0x00, 0x00, 0xBE, 0x4B, 0x70, 0x68, 0x54, 0x56, 0xFF, 0x75,
	0xFC, 0x6A, 0x01, 0xFF, 0x15, 0x20, 0x12, 0x01, 0x00, 0x8B, 0xF8, 0x85, 0xFF, 0x74, 0x2D, 0x8D,
	0x45, 0xFC, 0x50, 0xFF, 0x75, 0xFC, 0x57, 0x6A, 0x0B, 0xFF, 0x15, 0x30, 0x12, 0x01, 0x00, 0x8B,
	0xD8, 0x85, 0xDB, 0x7D, 0x1E, 0x56, 0x57, 0xFF, 0x15, 0x18, 0x12, 0x01, 0x00, 0x81, 0xFB, 0x04,
	0x00, 0x00, 0xC0, 0x75, 0x13, 0xFF, 0x4D, 0xF8, 0x75, 0xC3, 0xEB, 0x0C, 0xBB, 0x9A, 0x00, 0x00,
	0xC0, 0xEB, 0x05, 0x8B, 0x45, 0x08, 0x89, 0x38, 0x5F, 0x5E, 0x8B, 0xC3, 0x5B, 0xC9, 0xC2, 0x04,
	0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x0C, 0x8D, 0x45,
	0xF4, 0x50, 0xE8, 0x79, 0xFF, 0xFF, 0xFF, 0x33, 0xD2, 0x3B, 0xC2, 0x7C, 0x5F, 0x8B, 0x4D, 0xF4,
	0x88, 0x55, 0xFF, 0x89, 0x55, 0xF8, 0x39, 0x11, 0x76, 0x3A, 0x8B, 0x45, 0x0C, 0x56, 0x8B, 0x75,
	0x08, 0x57, 0x8D, 0x3C, 0x06, 0x8D, 0x41, 0x0C, 0x53, 0x3B, 0xFE, 0x72, 0x0F, 0x8B, 0x10, 0x3B,
	0xF2, 0x72, 0x09, 0x8B, 0x58, 0x04, 0x03, 0xDA, 0x3B, 0xFB, 0x76, 0x11, 0xFF, 0x45, 0xF8, 0x8B,
	0x55, 0xF8, 0x05, 0x1C, 0x01, 0x00, 0x00, 0x3B, 0x11, 0x72, 0xDE, 0xEB, 0x04, 0xC6, 0x45, 0xFF,
	0x01, 0x5B, 0x5F, 0x5E, 0x68, 0x4B, 0x70, 0x68, 0x54, 0x51, 0xFF, 0x15, 0x18, 0x12, 0x01, 0x00,
	0x33, 0xC0, 0x38, 0x45, 0xFF, 0x75, 0x05, 0xB8, 0x05, 0x00, 0x00, 0xC0, 0xC9, 0xC2, 0x08, 0x00,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x6A, 0x58, 0x68, 0x38, 0x14, 0x01, 0x00, 0xE8, 0xFA, 0x09,
	0x00, 0x00, 0x8B, 0x4D, 0x0C, 0x89, 0x4D, 0x98, 0x8B, 0x41, 0x60, 0x8B, 0x78, 0x10, 0x8B, 0x58,
	0x08, 0x8B, 0x70, 0x0C, 0x8A, 0x41, 0x20, 0x88, 0x45, 0xA0, 0x85, 0xDB, 0x74, 0x0E, 0x85, 0xFF,
	0x75, 0x0A, 0xBE, 0x06, 0x02, 0x00, 0xC0, 0xE9, 0xE3, 0x04, 0x00, 0x00, 0x83, 0xFB, 0x40, 0x77,
	0xF1, 0x84, 0xC0, 0x74, 0x45, 0x83, 0x65, 0xFC, 0x00, 0x6A, 0x01, 0x53, 0x57, 0xFF, 0x15, 0x38,
	0x12, 0x01, 0x00, 0x53, 0x57, 0x8D, 0x45, 0xA4, 0x50, 0xE8, 0xCE, 0x07, 0x00, 0x00, 0x83, 0xC4,
	0x0C, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xEB, 0x2E, 0x8B, 0x45, 0xEC, 0x8B, 0x00, 0x8B,
	0x00, 0x89, 0x45, 0x9C, 0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x65, 0xE8, 0x8B, 0x75, 0x9C, 0xC7, 0x45,
	0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xE9, 0x95, 0x04, 0x00, 0x00, 0x53, 0x57, 0x8D, 0x45, 0xA4, 0x50,
	0xE8, 0x97, 0x07, 0x00, 0x00, 0x83, 0xC4, 0x0C, 0xB8, 0x97, 0x21, 0x99, 0x99, 0x3B, 0xF0, 0x0F,
	0x87, 0x33, 0x02, 0x00, 0x00, 0x0F, 0x84, 0x0E, 0x02, 0x00, 0x00, 0xB8, 0xDF, 0x20, 0x99, 0x99,
	0x3B, 0xF0, 0x0F, 0x87, 0xF4, 0x00, 0x00, 0x00, 0x0F, 0x84, 0xD6, 0x00, 0x00, 0x00, 0x81, 0xFE,
	0x03, 0x20, 0x99, 0x99, 0x0F, 0x84, 0xAB, 0x00, 0x00, 0x00, 0x81, 0xFE, 0xCB, 0x20, 0x99, 0x99,
	0x0F, 0x84, 0x84, 0x00, 0x00, 0x00, 0x81, 0xFE, 0xCF, 0x20, 0x99, 0x99, 0x74, 0x61, 0x81, 0xFE,
	0xD3, 0x20, 0x99, 0x99, 0x74, 0x3E, 0x81, 0xFE, 0xD7, 0x20, 0x99, 0x99, 0x74, 0x21, 0x81, 0xFE,
	0xDB, 0x20, 0x99, 0x99, 0x0F, 0x85, 0x4C, 0x03, 0x00, 0x00, 0x83, 0xFB, 0x04, 0x75, 0x7B, 0xFF,
	0x75, 0xA0, 0xFF, 0x75, 0xA4, 0xE8, 0x60, 0x33, 0x00, 0x00, 0xE9, 0x0E, 0x04, 0x00, 0x00, 0x83,
	0xFB, 0x04, 0x75, 0x66, 0xFF, 0x75, 0xA0, 0xFF, 0x75, 0xA4, 0xE8, 0xF7, 0x32, 0x00, 0x00, 0xE9,
	0xF9, 0x03, 0x00, 0x00, 0x83, 0xFB, 0x0C, 0x75, 0x51, 0xFF, 0x75, 0xA0, 0xFF, 0x75, 0xAC, 0xFF,
	0x75, 0xA8, 0xFF, 0x75, 0xA4, 0xE8, 0xEC, 0x31, 0x00, 0x00, 0xE9, 0xDE, 0x03, 0x00, 0x00, 0x83,
	0xFB, 0x0C, 0x75, 0x36, 0xFF, 0x75, 0xA0, 0xFF, 0x75, 0xAC, 0xFF, 0x75, 0xA8, 0xFF, 0x75, 0xA4,
	0xE8, 0xE5, 0x30, 0x00, 0x00, 0xE9, 0xC3, 0x03, 0x00, 0x00, 0x83, 0xFB, 0x0C, 0x75, 0x1B, 0xFF,
	0x75, 0xA0, 0xFF, 0x75, 0xAC, 0xFF, 0x75, 0xA8, 0xFF, 0x75, 0xA4, 0xE8, 0xAE, 0x2F, 0x00, 0x00,
	0xE9, 0xA8, 0x03, 0x00, 0x00, 0x83, 0xFB, 0x04, 0x74, 0x0A, 0xBE, 0x04, 0x00, 0x00, 0xC0, 0xE9,
	0x9B, 0x03, 0x00, 0x00, 0xFF, 0x75, 0xA0, 0xFF, 0x75, 0xA4, 0xE8, 0xFD, 0x15, 0x00, 0x00, 0xE9,
	0x89, 0x03, 0x00, 0x00, 0x83, 0xFB, 0x08, 0x75, 0xE1, 0xFF, 0x75, 0xA0, 0xFF, 0x75, 0xA8, 0xFF,
	0x75, 0xA4, 0xE8, 0x93, 0x33, 0x00, 0x00, 0xE9, 0x71, 0x03, 0x00, 0x00, 0x81, 0xFE, 0xE3, 0x20,
	0x99, 0x99, 0x0F, 0x84, 0xDC, 0x00, 0x00, 0x00, 0x81, 0xFE, 0xE7, 0x20, 0x99, 0x99, 0x0F, 0x84,
	0xAB, 0x00, 0x00, 0x00, 0x81, 0xFE, 0xEB, 0x20, 0x99, 0x99, 0x74, 0x7E, 0x81, 0xFE, 0xEF, 0x20,
	0x99, 0x99, 0x74, 0x51, 0x81, 0xFE, 0xF3, 0x20, 0x99, 0x99, 0x74, 0x27, 0x81, 0xFE, 0x93, 0x21,
	0x99, 0x99, 0x0F, 0x85, 0x5E, 0x02, 0x00, 0x00, 0x83, 0xFB, 0x0C, 0x75, 0x8D, 0xFF, 0x75, 0xA0,
	0xFF, 0x75, 0xAC, 0xFF, 0x75, 0xA8, 0xFF, 0x75, 0xA4, 0xE8, 0xFA, 0x39, 0x00, 0x00, 0xE9, 0x1A,
	0x03, 0x00, 0x00, 0x83, 0xFB, 0x10, 0x0F, 0x85, 0x6E, 0xFF, 0xFF, 0xFF, 0xFF, 0x75, 0xA0, 0xFF,
	0x75, 0xB0, 0xFF, 0x75, 0xAC, 0xFF, 0x75, 0xA8, 0xFF, 0x75, 0xA4, 0xE8, 0x04, 0x36, 0x00, 0x00,
	0xE9, 0xF8, 0x02, 0x00, 0x00, 0x83, 0xFB, 0x14, 0x0F, 0x85, 0x4C, 0xFF, 0xFF, 0xFF, 0xFF, 0x75,
	0xA0, 0xFF, 0x75, 0xB4, 0xFF, 0x75, 0xB0, 0xFF, 0x75, 0xAC, 0xFF, 0x75, 0xA8, 0xFF, 0x75, 0xA4,
	0xE8, 0x93, 0x33, 0x00, 0x00, 0xE9, 0xD3, 0x02, 0x00, 0x00, 0x83, 0xFB, 0x14, 0x0F, 0x85, 0x27,
	0xFF, 0xFF, 0xFF, 0xFF, 0x75, 0xA0, 0xFF, 0x75, 0xB4, 0xFF, 0x75, 0xB0, 0xFF, 0x75, 0xAC, 0xFF,
	0x75, 0xA8, 0xFF, 0x75, 0xA4, 0xE8, 0x7E, 0x4A, 0x00, 0x00, 0xE9, 0xAE, 0x02, 0x00, 0x00, 0x83,
	0xFB, 0x14, 0x0F, 0x85, 0x02, 0xFF, 0xFF, 0xFF, 0xFF, 0x75, 0xA0, 0xFF, 0x75, 0xB4, 0xFF, 0x75,
	0xB0, 0xFF, 0x75, 0xAC, 0xFF, 0x75, 0xA8, 0xFF, 0x75, 0xA4, 0xE8, 0x4D, 0x49, 0x00, 0x00, 0xE9,
	0x89, 0x02, 0x00, 0x00, 0x83, 0xFB, 0x14, 0x0F, 0x85, 0xDD, 0xFE, 0xFF, 0xFF, 0xFF, 0x75, 0xA0,
	0xFF, 0x75, 0xB4, 0xFF, 0x75, 0xB0, 0xFF, 0x75, 0xAC, 0xFF, 0x75, 0xA8, 0xFF, 0x75, 0xA4, 0xE8,
	0x1C, 0x48, 0x00, 0x00, 0xE9, 0x64, 0x02, 0x00, 0x00, 0x83, 0xFB, 0x0C, 0x0F, 0x85, 0xB8, 0xFE,
	0xFF, 0xFF, 0xFF, 0x75, 0xA0, 0xFF, 0x75, 0xAC, 0xFF, 0x75, 0xA8, 0xFF, 0x75, 0xA4, 0xE8, 0x29,
	0x3A, 0x00, 0x00, 0xE9, 0x45, 0x02, 0x00, 0x00, 0xB8, 0xB3, 0x21, 0x99, 0x99, 0x3B, 0xF0, 0x0F,
	0x87, 0x25, 0x01, 0x00, 0x00, 0x0F, 0x84, 0xFD, 0x00, 0x00, 0x00, 0x81, 0xFE, 0x9B, 0x21, 0x99,
	0x99, 0x0F, 0x84, 0xD5, 0x00, 0x00, 0x00, 0x81, 0xFE, 0x9F, 0x21, 0x99, 0x99, 0x0F, 0x84, 0xAD,
	0x00, 0x00, 0x00, 0x81, 0xFE, 0xA3, 0x21, 0x99, 0x99, 0x0F, 0x84, 0x85, 0x00, 0x00, 0x00, 0x81,
	0xFE, 0xA7, 0x21, 0x99, 0x99, 0x74, 0x61, 0x81, 0xFE, 0xAB, 0x21, 0x99, 0x99, 0x74, 0x31, 0x81,
	0xFE, 0xAF, 0x21, 0x99, 0x99, 0x0F, 0x85, 0x1B, 0x01, 0x00, 0x00, 0x83, 0xFB, 0x14, 0x0F, 0x85,
	0x46, 0xFE, 0xFF, 0xFF, 0xFF, 0x75, 0xA0, 0xFF, 0x75, 0xB4, 0xFF, 0x75, 0xB0, 0xFF, 0x75, 0xAC,
	0xFF, 0x75, 0xA8, 0xFF, 0x75, 0xA4, 0xE8, 0xB7, 0x3C, 0x00, 0x00, 0xE9, 0xCD, 0x01, 0x00, 0x00,
	0x83, 0xFB, 0x18, 0x0F, 0x85, 0x21, 0xFE, 0xFF, 0xFF, 0xFF, 0x75, 0xA0, 0xFF, 0x75, 0xB8, 0xFF,
	0x75, 0xB4, 0xFF, 0x75, 0xB0, 0xFF, 0x75, 0xAC, 0xFF, 0x75, 0xA8, 0xFF, 0x75, 0xA4, 0xE8, 0x2D,
	0x43, 0x00, 0x00, 0xE9, 0xA5, 0x01, 0x00, 0x00, 0x83, 0xFB, 0x08, 0x0F, 0x85, 0xF9, 0xFD, 0xFF,
	0xFF, 0xFF, 0x75, 0xA0, 0xFF, 0x75, 0xA8, 0xFF, 0x75, 0xA4, 0xE8, 0xE7, 0x3B, 0x00, 0x00, 0xE9,
	0x89, 0x01, 0x00, 0x00, 0x83, 0xFB, 0x08, 0x0F, 0x85, 0xDD, 0xFD, 0xFF, 0xFF, 0xFF, 0x75, 0xA0,
	0xFF, 0x75, 0xA8, 0xFF, 0x75, 0xA4, 0xE8, 0x7F, 0x3B, 0x00, 0x00, 0xE9, 0x6D, 0x01, 0x00, 0x00,
	0x83, 0xFB, 0x08, 0x0F, 0x85, 0xC1, 0xFD, 0xFF, 0xFF, 0xFF, 0x75, 0xA0, 0xFF, 0x75, 0xA8, 0xFF,
	0x75, 0xA4, 0xE8, 0xCF, 0x3F, 0x00, 0x00, 0xE9, 0x51, 0x01, 0x00, 0x00, 0x83, 0xFB, 0x08, 0x0F,
	0x85, 0xA5, 0xFD, 0xFF, 0xFF, 0xFF, 0x75, 0xA0, 0xFF, 0x75, 0xA8, 0xFF, 0x75, 0xA4, 0xE8, 0xB9,
	0x3A, 0x00, 0x00, 0xE9, 0x35, 0x01, 0x00, 0x00, 0x83, 0xFB, 0x10, 0x0F, 0x85, 0x89, 0xFD, 0xFF,
	0xFF, 0xFF, 0x75, 0xA0, 0xFF, 0x75, 0xB0, 0xFF, 0x75, 0xAC, 0xFF, 0x75, 0xA8, 0xFF, 0x75, 0xA4,
	0xE8, 0xB5, 0x3D, 0x00, 0x00, 0xE9, 0x13, 0x01, 0x00, 0x00, 0x81, 0xFE, 0x5B, 0x22, 0x99, 0x99,
	0x0F, 0x84, 0xEA, 0x00, 0x00, 0x00, 0x81, 0xFE, 0x5F, 0x22, 0x99, 0x99, 0x0F, 0x84, 0xB9, 0x00,
	0x00, 0x00, 0x81, 0xFE, 0x63, 0x22, 0x99, 0x99, 0x0F, 0x84, 0x8B, 0x00, 0x00, 0x00, 0x81, 0xFE,
	0x67, 0x22, 0x99, 0x99, 0x74, 0x5B, 0x81, 0xFE, 0x23, 0x23, 0x99, 0x99, 0x74, 0x37, 0x81, 0xFE,
	0x27, 0x23, 0x99, 0x99, 0x74, 0x0A, 0xBE, 0x10, 0x00, 0x00, 0xC0, 0xE9, 0xCF, 0x00, 0x00, 0x00,
	0x83, 0xFB, 0x14, 0x0F, 0x85, 0x21, 0xFD, 0xFF, 0xFF, 0xFF, 0x75, 0xA0, 0xFF, 0x75, 0xB4, 0xFF,
	0x75, 0xB0, 0xFF, 0x75, 0xAC, 0xFF, 0x75, 0xA8, 0xFF, 0x75, 0xA4, 0xE8, 0xD4, 0x35, 0x00, 0x00,
	0xE9, 0xA8, 0x00, 0x00, 0x00, 0x83, 0xFB, 0x08, 0x0F, 0x85, 0xFC, 0xFC, 0xFF, 0xFF, 0xFF, 0x75,
	0xA0, 0xFF, 0x75, 0xA8, 0xFF, 0x75, 0xA4, 0xE8, 0x4C, 0x35, 0x00, 0x00, 0xE9, 0x8C, 0x00, 0x00,
	0x00, 0x83, 0xFB, 0x1C, 0x0F, 0x85, 0xE0, 0xFC, 0xFF, 0xFF, 0xFF, 0x75, 0xA0, 0xFF, 0x75, 0xBC,
	0xFF, 0x75, 0xB8, 0xFF, 0x75, 0xB4, 0xFF, 0x75, 0xB0, 0xFF, 0x75, 0xAC, 0xFF, 0x75, 0xA8, 0xFF,
	0x75, 0xA4, 0xE8, 0x85, 0x21, 0x00, 0x00, 0xEB, 0x64, 0x83, 0xFB, 0x14, 0x0F, 0x85, 0xB8, 0xFC,
	0xFF, 0xFF, 0xFF, 0x75, 0xA0, 0xFF, 0x75, 0xB4, 0xFF, 0x75, 0xB0, 0xFF, 0x75, 0xAC, 0xFF, 0x75,
	0xA8, 0xFF, 0x75, 0xA4, 0xE8, 0xCF, 0x1E, 0x00, 0x00, 0xEB, 0x42, 0x83, 0xFB, 0x18, 0x0F, 0x85,
	0x96, 0xFC, 0xFF, 0xFF, 0xFF, 0x75, 0xA0, 0xFF, 0x75, 0xB8, 0xFF, 0x75, 0xB4, 0xFF, 0x75, 0xB0,
	0xFF, 0x75, 0xAC, 0xFF, 0x75, 0xA8, 0xFF, 0x75, 0xA4, 0xE8, 0xF6, 0x23, 0x00, 0x00, 0xEB, 0x1D,
	0x83, 0xFB, 0x10, 0x0F, 0x85, 0x71, 0xFC, 0xFF, 0xFF, 0xFF, 0x75, 0xA0, 0xFF, 0x75, 0xB0, 0xFF,
	0x75, 0xAC, 0xFF, 0x75, 0xA8, 0xFF, 0x75, 0xA4, 0xE8, 0x21, 0x1C, 0x00, 0x00, 0x8B, 0xF0, 0x8B,
	0x4D, 0x98, 0x89, 0x71, 0x18, 0x83, 0x61, 0x1C, 0x00, 0x32, 0xD2, 0xFF, 0x15, 0x28, 0x13, 0x01,
	0x00, 0x8B, 0xC6, 0xE8, 0x1C, 0x05, 0x00, 0x00, 0xC2, 0x08, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x51, 0x56, 0x8B, 0x75, 0x08, 0x80, 0x3E, 0x00, 0x75, 0x04, 0x33,
	0xC0, 0xEB, 0x5B, 0x80, 0x7E, 0x01, 0x00, 0x75, 0x52, 0x8B, 0x46, 0x04, 0x8B, 0x4E, 0x0C, 0x53,
	0x8B, 0x5E, 0x08, 0x57, 0x89, 0x45, 0xFC, 0x8B, 0x46, 0x10, 0x50, 0x8D, 0x14, 0x01, 0x51, 0x89,
	0x55, 0x08, 0xE8, 0x0F, 0xFA, 0xFF, 0xFF, 0x85, 0xC0, 0x7C, 0x26, 0x8B, 0x7E, 0x0C, 0xEB, 0x10,
	0x53, 0xFF, 0x75, 0xFC, 0x57, 0xFF, 0x15, 0x3C, 0x12, 0x01, 0x00, 0x3B, 0xC3, 0x74, 0x08, 0x47,
	0x3B, 0x7D, 0x08, 0x72, 0xEB, 0xEB, 0x0E, 0x8B, 0x46, 0x14, 0x03, 0xC7, 0x89, 0x46, 0x18, 0xEB,
	0x04, 0x83, 0x66, 0x18, 0x00, 0x5F, 0xC6, 0x46, 0x01, 0x01, 0x5B, 0x8B, 0x46, 0x18, 0x5E, 0xC9,
	0xC2, 0x04, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x6A, 0x1C, 0x68, 0x58, 0x14, 0x01, 0x00, 0xE8,
	0x80, 0x02, 0x00, 0x00, 0x83, 0x65, 0xFC, 0x00, 0x6A, 0x04, 0x6A, 0x08, 0x8B, 0x7D, 0x08, 0x57,
	0x8B, 0x35, 0x38, 0x12, 0x01, 0x00, 0xFF, 0xD6, 0x66, 0x8B, 0x1F, 0x66, 0x89, 0x5D, 0xD4, 0x66,
	0x89, 0x5D, 0xD6, 0x83, 0x65, 0xD8, 0x00, 0x8B, 0x47, 0x04, 0x89, 0x45, 0xE4, 0x0F, 0xB7, 0xFB,
	0x6A, 0x02, 0x57, 0x50, 0xFF, 0xD6, 0x6A, 0xFE, 0x5E, 0x89, 0x75, 0xFC, 0xF6, 0xC3, 0x01, 0x74,
	0x0A, 0xB8, 0x0D, 0x00, 0x00, 0xC0, 0xE9, 0x8E, 0x00, 0x00, 0x00, 0x66, 0x85, 0xDB, 0x74, 0x31,
	0x68, 0x4B, 0x70, 0x68, 0x55, 0x57, 0x33, 0xDB, 0x43, 0x53, 0xFF, 0x15, 0x20, 0x12, 0x01, 0x00,
	0x89, 0x45, 0xD8, 0x85, 0xC0, 0x75, 0x07, 0xB8, 0x9A, 0x00, 0x00, 0xC0, 0xEB, 0x6B, 0x89, 0x5D,
	0xFC, 0x57, 0xFF, 0x75, 0xE4, 0x50, 0xE8, 0xF1, 0x01, 0x00, 0x00, 0x83, 0xC4, 0x0C, 0x89, 0x75,
	0xFC, 0x8B, 0x4D, 0xD4, 0x8B, 0x45, 0x0C, 0x89, 0x08, 0x8B, 0x4D, 0xD8, 0x89, 0x48, 0x04, 0x33,
	0xC0, 0xEB, 0x46, 0x8B, 0x45, 0xEC, 0x8B, 0x00, 0x8B, 0x00, 0x89, 0x45, 0xE0, 0x33, 0xC0, 0x40,
	0xC3, 0x8B, 0x65, 0xE8, 0x68, 0x4B, 0x70, 0x68, 0x55, 0xFF, 0x75, 0xD8, 0xFF, 0x15, 0x18, 0x12,
	0x01, 0x00, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x8B, 0x45, 0xE0, 0xEB, 0x1B, 0x8B, 0x45,
	0xEC, 0x8B, 0x00, 0x8B, 0x00, 0x89, 0x45, 0xDC, 0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x65, 0xE8, 0xC7,
	0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x8B, 0x45, 0xDC, 0xE8, 0xEB, 0x01, 0x00, 0x00, 0xC2, 0x08,
	0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0xA1, 0x20, 0x1A, 0x01, 0x00,
	0x85, 0xC0, 0x74, 0x19, 0x83, 0x3D, 0x38, 0x1A, 0x01, 0x00, 0x00, 0x74, 0x10, 0xFF, 0x75, 0x08,
	0xFF, 0xD0, 0x33, 0xC9, 0x85, 0xC0, 0x0F, 0x9D, 0xC1, 0x8A, 0xC1, 0xEB, 0x19, 0xA1, 0x08, 0x19,
	0x01, 0x00, 0x83, 0xF8, 0xFF, 0x75, 0x04, 0x32, 0xC0, 0xEB, 0x0B, 0x8B, 0x4D, 0x08, 0x03, 0xC8,
	0xFF, 0x15, 0xBC, 0x12, 0x01, 0x00, 0x5D, 0xC2, 0x04, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0xA1, 0x38, 0x1A, 0x01, 0x00, 0x85, 0xC0, 0x74, 0x03, 0x5D, 0xFF,
	0xE0, 0xA1, 0x08, 0x19, 0x01, 0x00, 0x83, 0xF8, 0xFF, 0x74, 0x0B, 0x8B, 0x4D, 0x08, 0x03, 0xC8,
	0xFF, 0x15, 0xC0, 0x12, 0x01, 0x00, 0x5D, 0xC2, 0x04, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x81, 0xEC, 0x00, 0x01, 0x00, 0x00, 0x53, 0x8B, 0x5D, 0x0C, 0x56,
	0x8B, 0x75, 0x08, 0x46, 0x8D, 0x04, 0x1E, 0x83, 0xF8, 0x40, 0x76, 0x04, 0x33, 0xC0, 0xEB, 0x58,
	0x8B, 0x4D, 0x10, 0x83, 0xE1, 0x01, 0x3B, 0x4D, 0x10, 0x75, 0xF1, 0xFF, 0x75, 0x10, 0x50, 0x8D,
	0x85, 0x00, 0xFF, 0xFF, 0xFF, 0x50, 0xFF, 0x15, 0xE4, 0x12, 0x01, 0x00, 0x89, 0x45, 0x10, 0x3B,
	0xC6, 0x76, 0xD9, 0x57, 0x33, 0xC0, 0x33, 0xFF, 0x85, 0xDB, 0x76, 0x22, 0x8D, 0x94, 0xB5, 0x00,
	0xFF, 0xFF, 0xFF, 0x8D, 0x0C, 0x30, 0x3B, 0x4D, 0x10, 0x73, 0x13, 0x8B, 0x0A, 0x8B, 0x5D, 0x14,
	0x03, 0xF9, 0x89, 0x0C, 0x83, 0x40, 0x83, 0xC2, 0x04, 0x3B, 0x45, 0x0C, 0x72, 0xE5, 0x8B, 0x4D,
	0x18, 0x85, 0xC9, 0x74, 0x02, 0x89, 0x39, 0x5F, 0x5E, 0x5B, 0xC9, 0xC2, 0x14, 0x00, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x8B, 0x55, 0x0C, 0x8B, 0x45, 0x08, 0xC6,
	0x02, 0x00, 0x8B, 0x00, 0x8B, 0x08, 0x81, 0xF9, 0x05, 0x00, 0x00, 0xC0, 0x74, 0x10, 0x81, 0xF9,
	0x01, 0x00, 0x00, 0x80, 0x74, 0x08, 0x81, 0xF9, 0x06, 0x00, 0x00, 0xC0, 0x75, 0x11, 0x83, 0x78,
	0x10, 0x01, 0x76, 0x0B, 0x8B, 0x4D, 0x10, 0xC6, 0x02, 0x01, 0x8B, 0x40, 0x18, 0x89, 0x01, 0x33,
	0xC0, 0x40, 0x5D, 0xC2, 0x0C, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x3B, 0x0D, 0x10, 0x1A, 0x01,
	0x00, 0x75, 0x03, 0xC2, 0x00, 0x00, 0xE9, 0x05, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x51, 0x89, 0x4D, 0xFC, 0x6A, 0x00, 0xFF, 0x35, 0x14, 0x1A, 0x01,
	0x00, 0xFF, 0x35, 0x10, 0x1A, 0x01, 0x00, 0xFF, 0x75, 0xFC, 0x68, 0xF7, 0x00, 0x00, 0x00, 0xFF,
	0x15, 0x24, 0x13, 0x01, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xFF, 0x25, 0x28, 0x12,
	0x01, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xFF, 0x25, 0x2C, 0x13, 0x01, 0x00, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0x68, 0xC0, 0x0E, 0x01, 0x00, 0x64, 0xFF, 0x35, 0x00, 0x00, 0x00, 0x00,
	0x8B, 0x44, 0x24, 0x10, 0x89, 0x6C, 0x24, 0x10, 0x8D, 0x6C, 0x24, 0x10, 0x2B, 0xE0, 0x53, 0x56,
	0x57, 0xA1, 0x10, 0x1A, 0x01, 0x00, 0x31, 0x45, 0xFC, 0x33, 0xC5, 0x50, 0x89, 0x65, 0xE8, 0xFF,
	0x75, 0xF8, 0x8B, 0x45, 0xFC, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x89, 0x45, 0xF8, 0x8D,
	0x45, 0xF0, 0x64, 0xA3, 0x00, 0x00, 0x00, 0x00, 0xC3, 0x8B, 0x4D, 0xF0, 0x64, 0x89, 0x0D, 0x00,
	0x00, 0x00, 0x00, 0x59, 0x5F, 0x5F, 0x5E, 0x5B, 0x8B, 0xE5, 0x5D, 0x51, 0xC3, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x14, 0x53, 0x8B, 0x5D, 0x0C, 0x56, 0x8B, 0x73, 0x08,
	0x33, 0x35, 0x10, 0x1A, 0x01, 0x00, 0x57, 0x8B, 0x06, 0xC6, 0x45, 0xFF, 0x00, 0xC7, 0x45, 0xF8,
	0x01, 0x00, 0x00, 0x00, 0x8D, 0x7B, 0x10, 0x83, 0xF8, 0xFE, 0x74, 0x0D, 0x8B, 0x4E, 0x04, 0x03,
	0xCF, 0x33, 0x0C, 0x38, 0xE8, 0x02, 0xFF, 0xFF, 0xFF, 0x8B, 0x4E, 0x0C, 0x8B, 0x46, 0x08, 0x03,
	0xCF, 0x33, 0x0C, 0x38, 0xE8, 0xF2, 0xFE, 0xFF, 0xFF, 0x8B, 0x45, 0x08, 0xF6, 0x40, 0x04, 0x66,
	0x0F, 0x85, 0xE2, 0x00, 0x00, 0x00, 0x8B, 0x4D, 0x10, 0x8D, 0x55, 0xEC, 0x89, 0x53, 0xFC, 0x8B,
	0x5B, 0x0C, 0x89, 0x45, 0xEC, 0x89, 0x4D, 0xF0, 0x83, 0xFB, 0xFE, 0x74, 0x5F, 0x8D, 0x49, 0x00,
	0x8D, 0x04, 0x5B, 0x8B, 0x4C, 0x86, 0x14, 0x8D, 0x44, 0x86, 0x10, 0x89, 0x45, 0xF4, 0x8B, 0x00,
	0x89, 0x45, 0x08, 0x85, 0xC9, 0x74, 0x14, 0x8B, 0xD7, 0xE8, 0x0F, 0x02, 0x00, 0x00, 0xC6, 0x45,
	0xFF, 0x01, 0x85, 0xC0, 0x7C, 0x40, 0x7F, 0x47, 0x8B, 0x45, 0x08, 0x8B, 0xD8, 0x83, 0xF8, 0xFE,
	0x75, 0xCE, 0x80, 0x7D, 0xFF, 0x00, 0x74, 0x24, 0x8B, 0x06, 0x83, 0xF8, 0xFE, 0x74, 0x0D, 0x8B,
	0x4E, 0x04, 0x03, 0xCF, 0x33, 0x0C, 0x38, 0xE8, 0x7F, 0xFE, 0xFF, 0xFF, 0x8B, 0x4E, 0x0C, 0x8B,
	0x56, 0x08, 0x03, 0xCF, 0x33, 0x0C, 0x3A, 0xE8, 0x6F, 0xFE, 0xFF, 0xFF, 0x8B, 0x45, 0xF8, 0x5F,
	0x5E, 0x5B, 0x8B, 0xE5, 0x5D, 0xC3, 0xC7, 0x45, 0xF8, 0x00, 0x00, 0x00, 0x00, 0xEB, 0xC9, 0x8B,
	0x4D, 0x0C, 0xE8, 0xDF, 0x01, 0x00, 0x00, 0x8B, 0x45, 0x0C, 0x39, 0x58, 0x0C, 0x74, 0x12, 0x68,
	0x10, 0x1A, 0x01, 0x00, 0x57, 0x8B, 0xD3, 0x8B, 0xC8, 0xE8, 0xE2, 0x01, 0x00, 0x00, 0x8B, 0x45,
	0x0C, 0x8B, 0x4D, 0x08, 0x89, 0x48, 0x0C, 0x8B, 0x06, 0x83, 0xF8, 0xFE, 0x74, 0x0D, 0x8B, 0x4E,
	0x04, 0x03, 0xCF, 0x33, 0x0C, 0x38, 0xE8, 0x20, 0xFE, 0xFF, 0xFF, 0x8B, 0x4E, 0x0C, 0x8B, 0x56,
	0x08, 0x03, 0xCF, 0x33, 0x0C, 0x3A, 0xE8, 0x10, 0xFE, 0xFF, 0xFF, 0x8B, 0x45, 0xF4, 0x8B, 0x48,
	0x08, 0x8B, 0xD7, 0xE8, 0x7C, 0x01, 0x00, 0x00, 0xBA, 0xFE, 0xFF, 0xFF, 0xFF, 0x39, 0x53, 0x0C,
	0x74, 0x8A, 0x68, 0x10, 0x1A, 0x01, 0x00, 0x57, 0x8B, 0xCB, 0xE8, 0x91, 0x01, 0x00, 0x00, 0xE9,
	0x54, 0xFF, 0xFF, 0xFF, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x68, 0xC0, 0x0E, 0x01,
	0x00, 0x64, 0xFF, 0x35, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x44, 0x24, 0x10, 0x89, 0x6C, 0x24, 0x10,
	0x8D, 0x6C, 0x24, 0x10, 0x2B, 0xE0, 0x53, 0x56, 0x57, 0xA1, 0x10, 0x1A, 0x01, 0x00, 0x31, 0x45,
	0xFC, 0x33, 0xC5, 0x89, 0x45, 0xE4, 0x50, 0x89, 0x65, 0xE8, 0xFF, 0x75, 0xF8, 0x8B, 0x45, 0xFC,
	0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x89, 0x45, 0xF8, 0x8D, 0x45, 0xF0, 0x64, 0xA3, 0x00,
	0x00, 0x00, 0x00, 0xC3, 0x8B, 0x4D, 0xE4, 0x33, 0xCD, 0xE8, 0x8D, 0xFD, 0xFF, 0xFF, 0xE9, 0x26,
	0xFE, 0xFF, 0xFF, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x53, 0x56, 0x57, 0x8B, 0x54, 0x24, 0x10, 0x8B,
	0x44, 0x24, 0x14, 0x8B, 0x4C, 0x24, 0x18, 0x55, 0x52, 0x50, 0x51, 0x51, 0x68, 0xFB, 0x10, 0x01,
	0x00, 0x64, 0xFF, 0x35, 0x00, 0x00, 0x00, 0x00, 0xA1, 0x10, 0x1A, 0x01, 0x00, 0x33, 0xC4, 0x89,
	0x44, 0x24, 0x08, 0x64, 0x89, 0x25, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x44, 0x24, 0x30, 0x8B, 0x58,
	0x08, 0x8B, 0x4C, 0x24, 0x2C, 0x33, 0x19, 0x8B, 0x70, 0x0C, 0x83, 0xFE, 0xFE, 0x74, 0x2E, 0x8B,
	0x54, 0x24, 0x34, 0x83, 0xFA, 0xFE, 0x74, 0x04, 0x3B, 0xF2, 0x76, 0x21, 0x8D, 0x34, 0x76, 0x8D,
	0x5C, 0xB3, 0x10, 0x8B, 0x0B, 0x89, 0x48, 0x0C, 0x83, 0x7B, 0x04, 0x00, 0x75, 0xCC, 0xB9, 0x01,
	0x00, 0x00, 0x00, 0x8B, 0x43, 0x08, 0xE8, 0xD1, 0x00, 0x00, 0x00, 0xEB, 0xBD, 0x64, 0x8F, 0x05,
	0x00, 0x00, 0x00, 0x00, 0x83, 0xC4, 0x18, 0x5F, 0x5E, 0x5B, 0xC3, 0x8B, 0x4C, 0x24, 0x04, 0xF7,
	0x41, 0x04, 0x06, 0x00, 0x00, 0x00, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x74, 0x33, 0x8B, 0x44, 0x24,
	0x08, 0x8B, 0x48, 0x08, 0x33, 0xC8, 0xE8, 0xE0, 0xFC, 0xFF, 0xFF, 0x55, 0x8B, 0x68, 0x18, 0xFF,
	0x70, 0x0C, 0xFF, 0x70, 0x10, 0xFF, 0x70, 0x14, 0xE8, 0x4B, 0xFF, 0xFF, 0xFF, 0x83, 0xC4, 0x0C,
	0x5D, 0x8B, 0x44, 0x24, 0x08, 0x8B, 0x54, 0x24, 0x10, 0x89, 0x02, 0xB8, 0x03, 0x00, 0x00, 0x00,
	0xC3, 0x55, 0x8B, 0x4C, 0x24, 0x08, 0x8B, 0x29, 0xFF, 0x71, 0x1C, 0xFF, 0x71, 0x18, 0xFF, 0x71,
	0x28, 0xE8, 0x22, 0xFF, 0xFF, 0xFF, 0x83, 0xC4, 0x0C, 0x5D, 0xC2, 0x04, 0x00, 0x55, 0x56, 0x57,
	0x53, 0x8B, 0xEA, 0x33, 0xC0, 0x33, 0xDB, 0x33, 0xD2, 0x33, 0xF6, 0x33, 0xFF, 0xFF, 0xD1, 0x5B,
	0x5F, 0x5E, 0x5D, 0xC3, 0x8B, 0xEA, 0x8B, 0xF1, 0x8B, 0xC1, 0x33, 0xC0, 0x33, 0xDB, 0x33, 0xC9,
	0x33, 0xD2, 0x33, 0xFF, 0xFF, 0xE6, 0x55, 0x8B, 0xEC, 0x53, 0x56, 0x57, 0x6A, 0x00, 0x6A, 0x00,
	0x68, 0x9B, 0x11, 0x01, 0x00, 0x51, 0xE8, 0x29, 0x00, 0x00, 0x00, 0x5F, 0x5E, 0x5B, 0x5D, 0xC3,
	0x55, 0x8B, 0x6C, 0x24, 0x08, 0x52, 0x51, 0xFF, 0x74, 0x24, 0x14, 0xE8, 0xC8, 0xFE, 0xFF, 0xFF,
	0x83, 0xC4, 0x0C, 0x5D, 0xC2, 0x08, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xFF, 0xD0, 0xC3, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0xFF, 0x25, 0x34, 0x13, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x92, 0x5F, 0x00, 0x00, 0xA0, 0x5F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x59, 0x00, 0x00,
	0x9C, 0x59, 0x00, 0x00, 0xAE, 0x59, 0x00, 0x00, 0xB8, 0x59, 0x00, 0x00, 0xCC, 0x59, 0x00, 0x00,
	0xD8, 0x59, 0x00, 0x00, 0xF0, 0x59, 0x00, 0x00, 0x08, 0x5A, 0x00, 0x00, 0x12, 0x5A, 0x00, 0x00,
	0x22, 0x5A, 0x00, 0x00, 0x3E, 0x5A, 0x00, 0x00, 0x50, 0x5A, 0x00, 0x00, 0x60, 0x5A, 0x00, 0x00,
	0x74, 0x5A, 0x00, 0x00, 0x84, 0x5A, 0x00, 0x00, 0xA0, 0x5A, 0x00, 0x00, 0xB4, 0x5A, 0x00, 0x00,
	0xCC, 0x5A, 0x00, 0x00, 0xE8, 0x5A, 0x00, 0x00, 0xF8, 0x5A, 0x00, 0x00, 0x0C, 0x5B, 0x00, 0x00,
	0x26, 0x5B, 0x00, 0x00, 0x3E, 0x5B, 0x00, 0x00, 0x56, 0x5B, 0x00, 0x00, 0x70, 0x5B, 0x00, 0x00,
	0x88, 0x5B, 0x00, 0x00, 0x98, 0x5B, 0x00, 0x00, 0xAE, 0x5B, 0x00, 0x00, 0xC4, 0x5B, 0x00, 0x00,
	0xD8, 0x5B, 0x00, 0x00, 0xEE, 0x5B, 0x00, 0x00, 0x06, 0x5C, 0x00, 0x00, 0x22, 0x5C, 0x00, 0x00,
	0x3E, 0x5C, 0x00, 0x00, 0x5C, 0x5C, 0x00, 0x00, 0x70, 0x59, 0x00, 0x00, 0x76, 0x5C, 0x00, 0x00,
	0x94, 0x5C, 0x00, 0x00, 0xB2, 0x5C, 0x00, 0x00, 0xCE, 0x5C, 0x00, 0x00, 0xE2, 0x5C, 0x00, 0x00,
	0xFC, 0x5C, 0x00, 0x00, 0x08, 0x5D, 0x00, 0x00, 0x1A, 0x5D, 0x00, 0x00, 0x30, 0x5D, 0x00, 0x00,
	0x4E, 0x5D, 0x00, 0x00, 0x6C, 0x5D, 0x00, 0x00, 0x86, 0x5D, 0x00, 0x00, 0x9C, 0x5D, 0x00, 0x00,
	0xAC, 0x5D, 0x00, 0x00, 0xC8, 0x5D, 0x00, 0x00, 0xDC, 0x5D, 0x00, 0x00, 0xEA, 0x5D, 0x00, 0x00,
	0x00, 0x5E, 0x00, 0x00, 0x16, 0x5E, 0x00, 0x00, 0x2A, 0x5E, 0x00, 0x00, 0x44, 0x5E, 0x00, 0x00,
	0x62, 0x5E, 0x00, 0x00, 0x7C, 0x5E, 0x00, 0x00, 0x94, 0x5E, 0x00, 0x00, 0xA8, 0x5E, 0x00, 0x00,
	0xBA, 0x5E, 0x00, 0x00, 0xCE, 0x5E, 0x00, 0x00, 0xDE, 0x5E, 0x00, 0x00, 0xF4, 0x5E, 0x00, 0x00,
	0x04, 0x5F, 0x00, 0x00, 0x24, 0x5F, 0x00, 0x00, 0x3A, 0x5F, 0x00, 0x00, 0x52, 0x5F, 0x00, 0x00,
	0x66, 0x5F, 0x00, 0x00, 0x74, 0x5F, 0x00, 0x00, 0x5A, 0x59, 0x00, 0x00, 0x6C, 0x5C, 0x00, 0x00,
	0x48, 0x59, 0x00, 0x00, 0xB6, 0x5F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xE2, 0x77, 0x69, 0x55, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
	0x5E, 0x00, 0x00, 0x00, 0xA8, 0x13, 0x00, 0x00, 0xA8, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x1A, 0x01, 0x00,
	0x10, 0x14, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x52, 0x53, 0x44, 0x53, 0x91, 0xE5, 0x7F, 0xB7,
	0xDE, 0x2C, 0x9C, 0x42, 0xAF, 0x26, 0x46, 0xC1, 0x91, 0x80, 0x7A, 0x90, 0x06, 0x00, 0x00, 0x00,
	0x64, 0x3A, 0x5C, 0x70, 0x72, 0x6F, 0x6A, 0x65, 0x63, 0x74, 0x73, 0x5C, 0x70, 0x72, 0x6F, 0x63,
	0x65, 0x73, 0x73, 0x68, 0x61, 0x63, 0x6B, 0x65, 0x72, 0x32, 0x5C, 0x6B, 0x70, 0x72, 0x6F, 0x63,
	0x65, 0x73, 0x73, 0x68, 0x61, 0x63, 0x6B, 0x65, 0x72, 0x5C, 0x62, 0x69, 0x6E, 0x5C, 0x69, 0x33,
	0x38, 0x36, 0x5C, 0x6B, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x68, 0x61, 0x63, 0x6B, 0x65,
	0x72, 0x2E, 0x70, 0x64, 0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xC0, 0x0E, 0x00, 0x00, 0xFB, 0x10, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
	0xD4, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0xD0, 0x1D, 0x01, 0x00,
	0xDE, 0x1D, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE4, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
	0x88, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0x7A, 0x06, 0x01, 0x00,
	0x88, 0x06, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
	0xC4, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0x8E, 0x0C, 0x01, 0x00,
	0x9C, 0x0C, 0x01, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0x63, 0x0C, 0x01, 0x00, 0x71, 0x0C, 0x01, 0x00,
	0xFE, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xBC, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
	0xFE, 0xFF, 0xFF, 0xFF, 0xDC, 0x26, 0x01, 0x00, 0xEA, 0x26, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFE, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xB8, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
	0xFE, 0xFF, 0xFF, 0xFF, 0xB0, 0x27, 0x01, 0x00, 0xBE, 0x27, 0x01, 0x00, 0xFE, 0xFF, 0xFF, 0xFF,
	0x7C, 0x28, 0x01, 0x00, 0x8A, 0x28, 0x01, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0xBA, 0x28, 0x01, 0x00,
	0xC8, 0x28, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
	0xB4, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0x36, 0x2A, 0x01, 0x00,
	0x44, 0x2A, 0x01, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0x88, 0x2A, 0x01, 0x00, 0x96, 0x2A, 0x01, 0x00,
	0xFE, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xCC, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
	0xFE, 0xFF, 0xFF, 0xFF, 0x83, 0x2C, 0x01, 0x00, 0x91, 0x2C, 0x01, 0x00, 0xFE, 0xFF, 0xFF, 0xFF,
	0x27, 0x2D, 0x01, 0x00, 0x2B, 0x2D, 0x01, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
	0xAC, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0xB7, 0x2D, 0x01, 0x00,
	0xC5, 0x2D, 0x01, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0x67, 0x2E, 0x01, 0x00, 0x75, 0x2E, 0x01, 0x00,
	0xE4, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x3C, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
	0xFE, 0xFF, 0xFF, 0xFF, 0x92, 0x2F, 0x01, 0x00, 0xA3, 0x2F, 0x01, 0x00, 0xFE, 0xFF, 0xFF, 0xFF,
	0x35, 0x30, 0x01, 0x00, 0x46, 0x30, 0x01, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0x1B, 0x31, 0x01, 0x00,
	0x2C, 0x31, 0x01, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0x04, 0x32, 0x01, 0x00, 0x15, 0x32, 0x01, 0x00,
	0xFE, 0xFF, 0xFF, 0xFF, 0x94, 0x32, 0x01, 0x00, 0xA5, 0x32, 0x01, 0x00, 0xFE, 0xFF, 0xFF, 0xFF,
	0x1B, 0x33, 0x01, 0x00, 0x2C, 0x33, 0x01, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0xA2, 0x33, 0x01, 0x00,
	0xB3, 0x33, 0x01, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0xC8, 0x34, 0x01, 0x00, 0xD9, 0x34, 0x01, 0x00,
	0xFE, 0xFF, 0xFF, 0xFF, 0xB2, 0x35, 0x01, 0x00, 0xC3, 0x35, 0x01, 0x00, 0xFE, 0xFF, 0xFF, 0xFF,
	0x7C, 0x36, 0x01, 0x00, 0x8D, 0x36, 0x01, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0xE3, 0x36, 0x01, 0x00,
	0xE7, 0x36, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
	0xC0, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0x74, 0x37, 0x01, 0x00,
	0x82, 0x37, 0x01, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0x19, 0x38, 0x01, 0x00, 0x27, 0x38, 0x01, 0x00,
	0xFE, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xC8, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
	0xFE, 0xFF, 0xFF, 0xFF, 0xE4, 0x38, 0x01, 0x00, 0xF2, 0x38, 0x01, 0x00, 0xFE, 0xFF, 0xFF, 0xFF,
	0x01, 0x39, 0x01, 0x00, 0x0F, 0x39, 0x01, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
	0xCC, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0x66, 0x39, 0x01, 0x00,
	0x74, 0x39, 0x01, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0xF5, 0x39, 0x01, 0x00, 0x03, 0x3A, 0x01, 0x00,
	0xFE, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xAC, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
	0xFE, 0xFF, 0xFF, 0xFF, 0x33, 0x3C, 0x01, 0x00, 0x41, 0x3C, 0x01, 0x00, 0xFE, 0xFF, 0xFF, 0xFF,
	0xC5, 0x3D, 0x01, 0x00, 0xD3, 0x3D, 0x01, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0x6C, 0x3D, 0x01, 0x00,
	0x7A, 0x3D, 0x01, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0xF7, 0x3C, 0x01, 0x00, 0x05, 0x3D, 0x01, 0x00,
	0xFE, 0xFF, 0xFF, 0xFF, 0x12, 0x3E, 0x01, 0x00, 0x16, 0x3E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFE, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xB4, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
	0xFE, 0xFF, 0xFF, 0xFF, 0x61, 0x3E, 0x01, 0x00, 0x6F, 0x3E, 0x01, 0x00, 0xFE, 0xFF, 0xFF, 0xFF,
	0x65, 0x3F, 0x01, 0x00, 0x73, 0x3F, 0x01, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0xDA, 0x3E, 0x01, 0x00,
	0xE8, 0x3E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
	0xCC, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0x92, 0x40, 0x01, 0x00,
	0xA0, 0x40, 0x01, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0xD0, 0x41, 0x01, 0x00, 0xDE, 0x41, 0x01, 0x00,
	0xFE, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xC4, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
	0xFE, 0xFF, 0xFF, 0xFF, 0x4E, 0x42, 0x01, 0x00, 0x5C, 0x42, 0x01, 0x00, 0xFE, 0xFF, 0xFF, 0xFF,
	0xDB, 0x42, 0x01, 0x00, 0xE9, 0x42, 0x01, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
	0xCC, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0x39, 0x43, 0x01, 0x00,
	0x47, 0x43, 0x01, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0xBD, 0x43, 0x01, 0x00, 0xCB, 0x43, 0x01, 0x00,
	0xFE, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xC8, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
	0xFE, 0xFF, 0xFF, 0xFF, 0x50, 0x46, 0x01, 0x00, 0x5E, 0x46, 0x01, 0x00, 0xFE, 0xFF, 0xFF, 0xFF,
	0x5A, 0x47, 0x01, 0x00, 0x68, 0x47, 0x01, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0x0F, 0x47, 0x01, 0x00,
	0x1D, 0x47, 0x01, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0xA7, 0x47, 0x01, 0x00, 0xAB, 0x47, 0x01, 0x00,
	0xFE, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xC8, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
	0xFE, 0xFF, 0xFF, 0xFF, 0xF8, 0x47, 0x01, 0x00, 0x06, 0x48, 0x01, 0x00, 0xFE, 0xFF, 0xFF, 0xFF,
	0x02, 0x49, 0x01, 0x00, 0x10, 0x49, 0x01, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0x70, 0x48, 0x01, 0x00,
	0x7E, 0x48, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
	0x6C, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0xAF, 0x4A, 0x01, 0x00,
	0xBD, 0x4A, 0x01, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0xF8, 0x4A, 0x01, 0x00, 0x06, 0x4B, 0x01, 0x00,
	0xFE, 0xFF, 0xFF, 0xFF, 0x46, 0x4C, 0x01, 0x00, 0x54, 0x4C, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xE4, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x24, 0xFD, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
	0xFE, 0xFF, 0xFF, 0xFF, 0xD9, 0x4F, 0x01, 0x00, 0xFB, 0x4F, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFE, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xD4, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
	0xFE, 0xFF, 0xFF, 0xFF, 0x39, 0x51, 0x01, 0x00, 0x47, 0x51, 0x01, 0x00, 0xFE, 0xFF, 0xFF, 0xFF,
	0xCA, 0x51, 0x01, 0x00, 0xCE, 0x51, 0x01, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
	0xD4, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0x45, 0x52, 0x01, 0x00,
	0x53, 0x52, 0x01, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0xD6, 0x52, 0x01, 0x00, 0xDA, 0x52, 0x01, 0x00,
	0xFE, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xC8, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
	0xFE, 0xFF, 0xFF, 0xFF, 0xA0, 0x53, 0x01, 0x00, 0xAE, 0x53, 0x01, 0x00, 0xFE, 0xFF, 0xFF, 0xFF,
	0xF1, 0x53, 0x01, 0x00, 0xFF, 0x53, 0x01, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0x6E, 0x54, 0x01, 0x00,
	0x72, 0x54, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x56, 0x64, 0xA1, 0x24, 0x01, 0x00, 0x00,
	0x8B, 0x75, 0x08, 0x3B, 0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x56, 0x8B, 0x75, 0x08, 0x57, 0x8D, 0xBE,
	0x40, 0x02, 0x00, 0x00, 0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x53, 0x56, 0x57, 0x33, 0xD2, 0x6A, 0x08,
	0x42, 0x5E, 0x8D, 0xB9, 0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x51, 0x51, 0x53, 0x56, 0x64, 0x8B, 0x35,
	0x24, 0x01, 0x00, 0x00, 0x66, 0xFF, 0x8E, 0x84, 0x00, 0x00, 0x00, 0x57, 0xC7, 0x45, 0xFC, 0x00,
	0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x51, 0x53, 0x64, 0x8B, 0x1D, 0x24, 0x01, 0x00, 0x00, 0x56, 0x8D,
	0xB3, 0x3C, 0x01, 0x00, 0x00, 0x66, 0xFF, 0x0E, 0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x83, 0xE4, 0xF8,
	0x56, 0x64, 0x8B, 0x35, 0x24, 0x01, 0x00, 0x00, 0x57, 0x66, 0xFF, 0x8E, 0x3C, 0x01, 0x00, 0x00,
	0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x0C, 0x83, 0x4D, 0xF8, 0xFF, 0x56, 0x57, 0x8B, 0x7D,
	0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x53, 0x56, 0x57, 0x8B, 0x7D, 0x08, 0x8D, 0xB7, 0x40, 0x02, 0x00,
	0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x83, 0xE4, 0xF8, 0x51, 0x53, 0x56, 0x8B, 0x75, 0x08, 0x57, 0x8D,
	0xBE, 0x60, 0x02, 0x00, 0x00, 0xF6, 0x07, 0x40, 0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x83, 0xE4, 0xF8,
	0x51, 0x53, 0x56, 0x8B, 0x75, 0x08, 0x57, 0x8D, 0xBE, 0x80, 0x02, 0x00, 0x00, 0xF6, 0x07, 0x40,
	0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x8D, 0x87, 0x68, 0x02, 0x00, 0x00, 0xF6, 0x00, 0x20, 0x53, 0x8A,
	0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x53, 0x56, 0x8B, 0xF1, 0x8B, 0xDA, 0x57, 0x8D, 0xBE, 0xB8, 0x03,
	0x4E, 0xE6, 0x40, 0xBB, 0xB1, 0x19, 0xBF, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x35, 0xB0, 0x1B, 0x01, 0x00, 0xFF, 0x15, 0x30, 0x13,
	0x01, 0x00, 0xC2, 0x04, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x83,
	0xEC, 0x18, 0xA1, 0x10, 0x1A, 0x01, 0x00, 0x33, 0xC5, 0x89, 0x45, 0xFC, 0x8B, 0x45, 0x08, 0x8B,
	0x4D, 0x0C, 0x85, 0xC0, 0x75, 0x05, 0x8B, 0x45, 0x10, 0xEB, 0x29, 0x8D, 0x55, 0xE8, 0x52, 0x6A,
	0x10, 0x8D, 0x55, 0xEC, 0x52, 0x6A, 0x02, 0x51, 0x50, 0xFF, 0x15, 0x10, 0x12, 0x01, 0x00, 0x83,
	0x7D, 0xF0, 0x04, 0x74, 0x05, 0xB8, 0x24, 0x00, 0x00, 0xC0, 0x85, 0xC0, 0x8B, 0x45, 0x10, 0x7C,
	0x03, 0x8B, 0x45, 0xF8, 0x8B, 0x4D, 0xFC, 0x33, 0xCD, 0xE8, 0x8D, 0xF1, 0xFF, 0xFF, 0xC9, 0xC2,
	0x0C, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x34,
	0x53, 0x56, 0x57, 0x8B, 0x3D, 0x24, 0x12, 0x01, 0x00, 0x68, 0xE0, 0x54, 0x01, 0x00, 0x8D, 0x45,
	0xEC, 0x50, 0xFF, 0xD7, 0x8B, 0x75, 0x08, 0x66, 0x8B, 0x06, 0x66, 0x03, 0x45, 0xEC, 0xBB, 0x4B,
	0x70, 0x68, 0x54, 0x66, 0x89, 0x45, 0xF4, 0x66, 0x89, 0x45, 0xF6, 0x0F, 0xB7, 0xC0, 0x53, 0x50,
	0x6A, 0x01, 0xFF, 0x15, 0x20, 0x12, 0x01, 0x00, 0x89, 0x45, 0xF8, 0x85, 0xC0, 0x75, 0x0A, 0xB8,
	0x9A, 0x00, 0x00, 0xC0, 0xE9, 0xC7, 0x00, 0x00, 0x00, 0x0F, 0xB7, 0x0E, 0x51, 0xFF, 0x76, 0x04,
	0x50, 0xE8, 0x66, 0xF1, 0xFF, 0xFF, 0x0F, 0xB7, 0x45, 0xEC, 0x8B, 0x4D, 0xF8, 0x50, 0x0F, 0xB7,
	0x06, 0xFF, 0x75, 0xF0, 0xD1, 0xE8, 0x8D, 0x04, 0x41, 0x50, 0xE8, 0x4D, 0xF1, 0xFF, 0xFF, 0x8D,
	0x45, 0xF4, 0x83, 0xC4, 0x18, 0x89, 0x45, 0xD4, 0x8D, 0x45, 0xCC, 0x50, 0x33, 0xF6, 0x68, 0x19,
	0x00, 0x02, 0x00, 0x8D, 0x45, 0xFC, 0x50, 0xC7, 0x45, 0xCC, 0x18, 0x00, 0x00, 0x00, 0x89, 0x75,
	0xD0, 0xC7, 0x45, 0xD8, 0x40, 0x02, 0x00, 0x00, 0x89, 0x75, 0xDC, 0x89, 0x75, 0xE0, 0xFF, 0x15,
	0x1C, 0x12, 0x01, 0x00, 0x53, 0xFF, 0x75, 0xF8, 0x89, 0x45, 0x08, 0xFF, 0x15, 0x18, 0x12, 0x01,
	0x00, 0x39, 0x75, 0x08, 0x7D, 0x06, 0x89, 0x75, 0x08, 0x89, 0x75, 0xFC, 0x68, 0xC4, 0x54, 0x01,
	0x00, 0x8D, 0x45, 0xE4, 0x50, 0xFF, 0xD7, 0x6A, 0x01, 0x8D, 0x45, 0xE4, 0x50, 0xFF, 0x75, 0xFC,
	0xE8, 0xC5, 0xFE, 0xFF, 0xFF, 0xA3, 0xA8, 0x1B, 0x01, 0x00, 0x68, 0x8C, 0x54, 0x01, 0x00, 0x8D,
	0x45, 0xE4, 0x50, 0xFF, 0xD7, 0x56, 0x8D, 0x45, 0xE4, 0x50, 0xFF, 0x75, 0xFC, 0xE8, 0xA8, 0xFE,
	0xFF, 0xFF, 0xFF, 0x75, 0xFC, 0xA3, 0xAC, 0x1B, 0x01, 0x00, 0xE8, 0xB1, 0x06, 0x00, 0x00, 0x39,
	0x75, 0xFC, 0x74, 0x09, 0xFF, 0x75, 0xFC, 0xFF, 0x15, 0x14, 0x12, 0x01, 0x00, 0x8B, 0x45, 0x08,
	0x5F, 0x5E, 0x5B, 0xC9, 0xC2, 0x04, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x6A, 0x0C, 0x68, 0x18,
	0x14, 0x01, 0x00, 0xE8, 0xAC, 0xF0, 0xFF, 0xFF, 0x80, 0x7D, 0x0C, 0x00, 0x74, 0x3F, 0x83, 0x65,
	0xFC, 0x00, 0x6A, 0x04, 0x6A, 0x04, 0x8B, 0x75, 0x08, 0x56, 0xFF, 0x15, 0x2C, 0x12, 0x01, 0x00,
	0xA1, 0xA0, 0x1B, 0x01, 0x00, 0x89, 0x06, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xEB, 0x28,
	0x8B, 0x45, 0xEC, 0x8B, 0x00, 0x8B, 0x00, 0x89, 0x45, 0xE4, 0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x65,
	0xE8, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x8B, 0x45, 0xE4, 0xEB, 0x0D, 0x8B, 0x45, 0x08,
	0x8B, 0x0D, 0xA0, 0x1B, 0x01, 0x00, 0x89, 0x08, 0x33, 0xC0, 0xE8, 0x9A, 0xF0, 0xFF, 0xFF, 0xC2,
	0x08, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x51, 0x51, 0x56,
	0x8B, 0x75, 0x08, 0x89, 0x35, 0x9C, 0x1B, 0x01, 0x00, 0xE8, 0xDC, 0x05, 0x00, 0x00, 0x85, 0xC0,
	0x7C, 0x63, 0xE8, 0xE9, 0x06, 0x00, 0x00, 0xFF, 0x75, 0x0C, 0xE8, 0x49, 0xFE, 0xFF, 0xFF, 0x85,
	0xC0, 0x7C, 0x52, 0x68, 0xF8, 0x54, 0x01, 0x00, 0x8D, 0x45, 0xF8, 0x50, 0xFF, 0x15, 0x24, 0x12,
	0x01, 0x00, 0x8D, 0x45, 0x08, 0x50, 0x6A, 0x00, 0x68, 0x00, 0x01, 0x00, 0x00, 0x6A, 0x22, 0x8D,
	0x45, 0xF8, 0x50, 0x6A, 0x00, 0x56, 0xFF, 0x15, 0x34, 0x12, 0x01, 0x00, 0x85, 0xC0, 0x7C, 0x25,
	0x8B, 0x4D, 0x08, 0x89, 0x0D, 0xB0, 0x1B, 0x01, 0x00, 0xC7, 0x46, 0x38, 0x86, 0x04, 0x01, 0x00,
	0xC7, 0x46, 0x70, 0x16, 0x06, 0x01, 0x00, 0xC7, 0x46, 0x34, 0x06, 0x1C, 0x01, 0x00, 0x81, 0x61,
	0x1C, 0x7F, 0xFF, 0xFF, 0xFF, 0x5E, 0xC9, 0xC2, 0x08, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x83, 0x7D, 0x0C, 0x08, 0x73, 0x0A, 0xB8, 0x0D, 0x00, 0x00, 0xC0,
	0xE9, 0x84, 0x00, 0x00, 0x00, 0x8B, 0x45, 0x08, 0x83, 0x38, 0x02, 0x75, 0xEE, 0x56, 0x8B, 0x70,
	0x04, 0x83, 0xFE, 0x40, 0x77, 0x0D, 0x8B, 0xCE, 0x6B, 0xC9, 0x24, 0x83, 0xC1, 0x08, 0x39, 0x4D,
	0x0C, 0x73, 0x07, 0xB8, 0x0D, 0x00, 0x00, 0xC0, 0xEB, 0x5E, 0x53, 0x57, 0x33, 0xFF, 0x85, 0xF6,
	0x76, 0x4F, 0x83, 0xC0, 0x0C, 0xBA, 0xFF, 0xFF, 0x00, 0x00, 0x0F, 0xB7, 0x48, 0xFC, 0x3B, 0x0D,
	0x84, 0x1A, 0x01, 0x00, 0x75, 0x33, 0x0F, 0xB7, 0x48, 0xFE, 0x3B, 0x0D, 0x88, 0x1A, 0x01, 0x00,
	0x75, 0x27, 0x0F, 0xB7, 0x08, 0x8B, 0xDA, 0x66, 0x3B, 0xCB, 0x74, 0x09, 0x66, 0x3B, 0x0D, 0x94,
	0x1B, 0x01, 0x00, 0x75, 0x14, 0x0F, 0xB7, 0x48, 0x02, 0x66, 0x3B, 0xCB, 0x74, 0x1F, 0x0F, 0xB7,
	0xC9, 0x3B, 0x0D, 0x8C, 0x1A, 0x01, 0x00, 0x74, 0x14, 0x47, 0x83, 0xC0, 0x24, 0x3B, 0xFE, 0x72,
	0xB9, 0xB8, 0x25, 0x02, 0x00, 0xC0, 0x5F, 0x5B, 0x5E, 0x5D, 0xC2, 0x08, 0x00, 0x8B, 0x48, 0x04,
	0x89, 0x0D, 0x7C, 0x1A, 0x01, 0x00, 0x0F, 0xBF, 0x48, 0x08, 0x89, 0x0D, 0x00, 0x19, 0x01, 0x00,
	0x0F, 0xBF, 0x48, 0x0A, 0x89, 0x0D, 0x04, 0x19, 0x01, 0x00, 0x0F, 0xBF, 0x48, 0x10, 0x89, 0x0D,
	0x08, 0x19, 0x01, 0x00, 0x0F, 0xBF, 0x48, 0x12, 0x89, 0x0D, 0x0C, 0x19, 0x01, 0x00, 0x0F, 0xBF,
	0x48, 0x14, 0x89, 0x0D, 0x10, 0x19, 0x01, 0x00, 0x0F, 0xBF, 0x48, 0x16, 0x89, 0x0D, 0x14, 0x19,
	0x01, 0x00, 0x0F, 0xBF, 0x48, 0x18, 0x89, 0x0D, 0x18, 0x19, 0x01, 0x00, 0x0F, 0xBF, 0x48, 0x1A,
	0x89, 0x0D, 0x1C, 0x19, 0x01, 0x00, 0x0F, 0xBF, 0x40, 0x1C, 0xA3, 0x20, 0x19, 0x01, 0x00, 0x33,
	0xC0, 0xEB, 0x93, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x8B, 0x0D, 0x84, 0x1A, 0x01, 0x00, 0xA1, 0x88,
	0x1A, 0x01, 0x00, 0x53, 0x56, 0x0F, 0xB7, 0x35, 0x94, 0x1B, 0x01, 0x00, 0x57, 0x83, 0xF9, 0x05,
	0x0F, 0x85, 0x3A, 0x01, 0x00, 0x00, 0x83, 0xF8, 0x01, 0x0F, 0x85, 0x92, 0x00, 0x00, 0x00, 0x68,
	0xB4, 0x55, 0x01, 0x00, 0xE8, 0x1F, 0x05, 0x00, 0x00, 0x33, 0xDB, 0xC7, 0x05, 0x7C, 0x1A, 0x01,
	0x00, 0x33, 0x00, 0x00, 0x00, 0x3B, 0xF3, 0x0F, 0x84, 0x0E, 0x04, 0x00, 0x00, 0x83, 0xFE, 0x01,
	0x0F, 0x84, 0x05, 0x04, 0x00, 0x00, 0x83, 0xFE, 0x02, 0x74, 0x09, 0x83, 0xFE, 0x03, 0x0F, 0x85,
	0xF7, 0x03, 0x00, 0x00, 0xC7, 0x05, 0x04, 0x19, 0x01, 0x00, 0xC4, 0x00, 0x00, 0x00, 0xC7, 0x05,
	0x08, 0x19, 0x01, 0x00, 0x80, 0x00, 0x00, 0x00, 0xC7, 0x05, 0x14, 0x19, 0x01, 0x00, 0x40, 0x00,
	0x00, 0x00, 0xC7, 0x05, 0x18, 0x19, 0x01, 0x00, 0x4C, 0x00, 0x00, 0x00, 0x3B, 0xC3, 0x0F, 0x84,
	0xB5, 0x03, 0x00, 0x00, 0x6A, 0x10, 0x5A, 0xC7, 0x05, 0x64, 0x1A, 0x01, 0x00, 0x24, 0x19, 0x01,
	0x00, 0x89, 0x15, 0x68, 0x1A, 0x01, 0x00, 0xB9, 0x00, 0x00, 0x10, 0x00, 0xC7, 0x05, 0x44, 0x1A,
	0x01, 0x00, 0xA0, 0x19, 0x01, 0x00, 0x89, 0x15, 0x48, 0x1A, 0x01, 0x00, 0xE9, 0x40, 0x03, 0x00,
	0x00, 0x83, 0xF8, 0x02, 0x0F, 0x85, 0x91, 0x03, 0x00, 0x00, 0x68, 0x98, 0x55, 0x01, 0x00, 0xE8,
	0x84, 0x04, 0x00, 0x00, 0x33, 0xDB, 0xC7, 0x05, 0x7C, 0x1A, 0x01, 0x00, 0x34, 0x00, 0x00, 0x00,
	0x3B, 0xF3, 0x74, 0x0E, 0x83, 0xFE, 0x01, 0x74, 0x09, 0x83, 0xFE, 0x02, 0x0F, 0x85, 0x69, 0x03,
	0x00, 0x00, 0xC7, 0x05, 0x04, 0x19, 0x01, 0x00, 0xD4, 0x00, 0x00, 0x00, 0xC7, 0x05, 0x08, 0x19,
	0x01, 0x00, 0x90, 0x00, 0x00, 0x00, 0xC7, 0x05, 0x14, 0x19, 0x01, 0x00, 0x40, 0x00, 0x00, 0x00,
	0xC7, 0x05, 0x18, 0x19, 0x01, 0x00, 0x4C, 0x00, 0x00, 0x00, 0x3B, 0xC3, 0x0F, 0x84, 0x27, 0x03,
	0x00, 0x00, 0x8D, 0x88, 0x00, 0x00, 0xFB, 0xFF, 0x6A, 0x10, 0x5A, 0x89, 0x0D, 0x6C, 0x1A, 0x01,
	0x00, 0xC7, 0x05, 0x64, 0x1A, 0x01, 0x00, 0x34, 0x19, 0x01, 0x00, 0x89, 0x15, 0x68, 0x1A, 0x01,
	0x00, 0xB9, 0x00, 0x00, 0x10, 0x00, 0xC7, 0x05, 0x44, 0x1A, 0x01, 0x00, 0xB0, 0x19, 0x01, 0x00,
	0x89, 0x15, 0x48, 0x1A, 0x01, 0x00, 0x05, 0x00, 0x00, 0xFE, 0xFF, 0xE9, 0xA6, 0x02, 0x00, 0x00,
	0x83, 0xF9, 0x06, 0x0F, 0x85, 0xE9, 0x02, 0x00, 0x00, 0x33, 0xDB, 0x3B, 0xC3, 0x0F, 0x85, 0xB7,
	0x00, 0x00, 0x00, 0x68, 0xB4, 0x55, 0x01, 0x00, 0xE8, 0xDB, 0x03, 0x00, 0x00, 0x6A, 0x08, 0xC7,
	0x05, 0x7C, 0x1A, 0x01, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x59, 0x3B, 0xF3, 0x75, 0x16, 0xC7, 0x05,
	0x14, 0x19, 0x01, 0x00, 0x40, 0x00, 0x00, 0x00, 0xC7, 0x05, 0x18, 0x19, 0x01, 0x00, 0x4C, 0x00,
	0x00, 0x00, 0xEB, 0x1E, 0x83, 0xFE, 0x01, 0x74, 0x09, 0x83, 0xFE, 0x02, 0x0F, 0x85, 0xA9, 0x02,
	0x00, 0x00, 0xC7, 0x05, 0x18, 0x19, 0x01, 0x00, 0x14, 0x00, 0x00, 0x00, 0x89, 0x0D, 0x14, 0x19,
	0x01, 0x00, 0xC7, 0x05, 0x00, 0x19, 0x01, 0x00, 0x0C, 0x00, 0x00, 0x00, 0xC7, 0x05, 0x04, 0x19,
	0x01, 0x00, 0xDC, 0x00, 0x00, 0x00, 0xC7, 0x05, 0x08, 0x19, 0x01, 0x00, 0x98, 0x00, 0x00, 0x00,
	0x89, 0x0D, 0x0C, 0x19, 0x01, 0x00, 0x3B, 0xC3, 0x0F, 0x84, 0x5B, 0x02, 0x00, 0x00, 0xA3, 0x6C,
	0x1A, 0x01, 0x00, 0xC7, 0x05, 0x64, 0x1A, 0x01, 0x00, 0x44, 0x19, 0x01, 0x00, 0xC7, 0x05, 0x68,
	0x1A, 0x01, 0x00, 0x10, 0x00, 0x00, 0x00, 0xB9, 0x00, 0x00, 0x10, 0x00, 0xC7, 0x05, 0x44, 0x1A,
	0x01, 0x00, 0xC0, 0x19, 0x01, 0x00, 0xC7, 0x05, 0x48, 0x1A, 0x01, 0x00, 0x18, 0x00, 0x00, 0x00,
	0x05, 0x00, 0x00, 0xFB, 0xFF, 0xE9, 0xDC, 0x01, 0x00, 0x00, 0x83, 0xF8, 0x01, 0x0F, 0x85, 0xD0,
	0x00, 0x00, 0x00, 0x68, 0x70, 0x55, 0x01, 0x00, 0xE8, 0x1B, 0x03, 0x00, 0x00, 0x68, 0x4C, 0x55,
	0x01, 0x00, 0x8B, 0xF8, 0xE8, 0x0F, 0x03, 0x00, 0x00, 0xC7, 0x05, 0x7C, 0x1A, 0x01, 0x00, 0x3D,
	0x00, 0x00, 0x00, 0x3B, 0xF3, 0x74, 0x09, 0x83, 0xFE, 0x01, 0x0F, 0x85, 0xFB, 0x01, 0x00, 0x00,
	0x6A, 0x08, 0x59, 0xC7, 0x05, 0x00, 0x19, 0x01, 0x00, 0x0C, 0x00, 0x00, 0x00, 0xC7, 0x05, 0x04,
	0x19, 0x01, 0x00, 0xF4, 0x00, 0x00, 0x00, 0xC7, 0x05, 0x08, 0x19, 0x01, 0x00, 0xB0, 0x00, 0x00,
	0x00, 0x89, 0x0D, 0x0C, 0x19, 0x01, 0x00, 0x89, 0x0D, 0x14, 0x19, 0x01, 0x00, 0xC7, 0x05, 0x18,
	0x19, 0x01, 0x00, 0x14, 0x00, 0x00, 0x00, 0x3B, 0xFB, 0x74, 0x3D, 0xC6, 0x05, 0x60, 0x1A, 0x01,
	0x00, 0x01, 0x88, 0x1D, 0x61, 0x1A, 0x01, 0x00, 0xC7, 0x05, 0x64, 0x1A, 0x01, 0x00, 0x54, 0x19,
	0x01, 0x00, 0xC7, 0x05, 0x68, 0x1A, 0x01, 0x00, 0x1B, 0x00, 0x00, 0x00, 0x89, 0x3D, 0x6C, 0x1A,
	0x01, 0x00, 0xC7, 0x05, 0x70, 0x1A, 0x01, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x89, 0x1D, 0x74, 0x1A,
	0x01, 0x00, 0x89, 0x1D, 0x78, 0x1A, 0x01, 0x00, 0x3B, 0xC3, 0x0F, 0x84, 0x69, 0x01, 0x00, 0x00,
	0xC7, 0x05, 0x44, 0x1A, 0x01, 0x00, 0xD8, 0x19, 0x01, 0x00, 0xC7, 0x05, 0x48, 0x1A, 0x01, 0x00,
	0x18, 0x00, 0x00, 0x00, 0xC7, 0x05, 0x50, 0x1A, 0x01, 0x00, 0x00, 0xA0, 0x01, 0x00, 0xE9, 0x28,
	0x01, 0x00, 0x00, 0x83, 0xF8, 0x02, 0x75, 0x71, 0x68, 0x28, 0x55, 0x01, 0x00, 0xE8, 0x46, 0x02,
	0x00, 0x00, 0xC7, 0x05, 0x7C, 0x1A, 0x01, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x3B, 0xF3, 0x0F, 0x85,
	0x37, 0x01, 0x00, 0x00, 0x6A, 0x08, 0x59, 0xC7, 0x05, 0x00, 0x19, 0x01, 0x00, 0x0C, 0x00, 0x00,
	0x00, 0xC7, 0x05, 0x04, 0x19, 0x01, 0x00, 0x50, 0x01, 0x00, 0x00, 0xC7, 0x05, 0x08, 0x19, 0x01,
	0x00, 0xB0, 0x00, 0x00, 0x00, 0x89, 0x0D, 0x0C, 0x19, 0x01, 0x00, 0x89, 0x0D, 0x14, 0x19, 0x01,
	0x00, 0xC7, 0x05, 0x18, 0x19, 0x01, 0x00, 0x14, 0x00, 0x00, 0x00, 0x3B, 0xC3, 0x0F, 0x84, 0xE6,
	0x00, 0x00, 0x00, 0xC7, 0x05, 0x64, 0x1A, 0x01, 0x00, 0x70, 0x19, 0x01, 0x00, 0xC7, 0x05, 0x44,
	0x1A, 0x01, 0x00, 0xF0, 0x19, 0x01, 0x00, 0xEB, 0x6F, 0x83, 0xF8, 0x03, 0x0F, 0x85, 0xCB, 0x00,
	0x00, 0x00, 0x68, 0x28, 0x55, 0x01, 0x00, 0xE8, 0xCC, 0x01, 0x00, 0x00, 0xC7, 0x05, 0x7C, 0x1A,
	0x01, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x3B, 0xF3, 0x0F, 0x85, 0xBD, 0x00, 0x00, 0x00, 0xC7, 0x05,
	0x00, 0x19, 0x01, 0x00, 0x0C, 0x00, 0x00, 0x00, 0xC7, 0x05, 0x04, 0x19, 0x01, 0x00, 0x50, 0x01,
	0x00, 0x00, 0xC7, 0x05, 0x08, 0x19, 0x01, 0x00, 0xB0, 0x00, 0x00, 0x00, 0xC7, 0x05, 0x14, 0x19,
	0x01, 0x00, 0x08, 0x00, 0x00, 0x00, 0xC7, 0x05, 0x18, 0x19, 0x01, 0x00, 0x14, 0x00, 0x00, 0x00,
	0x3B, 0xC3, 0x74, 0x75, 0xC7, 0x05, 0x64, 0x1A, 0x01, 0x00, 0x88, 0x19, 0x01, 0x00, 0xC7, 0x05,
	0x44, 0x1A, 0x01, 0x00, 0x00, 0x1A, 0x01, 0x00, 0xC7, 0x05, 0x48, 0x1A, 0x01, 0x00, 0x10, 0x00,
	0x00, 0x00, 0xB9, 0x00, 0x80, 0x00, 0x00, 0xC7, 0x05, 0x68, 0x1A, 0x01, 0x00, 0x18, 0x00, 0x00,
	0x00, 0xA3, 0x6C, 0x1A, 0x01, 0x00, 0xC6, 0x05, 0x60, 0x1A, 0x01, 0x00, 0x01, 0x88, 0x1D, 0x61,
	0x1A, 0x01, 0x00, 0x89, 0x0D, 0x70, 0x1A, 0x01, 0x00, 0x89, 0x1D, 0x74, 0x1A, 0x01, 0x00, 0x89,
	0x1D, 0x78, 0x1A, 0x01, 0x00, 0x89, 0x0D, 0x50, 0x1A, 0x01, 0x00, 0x89, 0x1D, 0x58, 0x1A, 0x01,
	0x00, 0x89, 0x1D, 0x54, 0x1A, 0x01, 0x00, 0xA3, 0x4C, 0x1A, 0x01, 0x00, 0x88, 0x1D, 0x41, 0x1A,
	0x01, 0x00, 0xC6, 0x05, 0x40, 0x1A, 0x01, 0x00, 0x01, 0x33, 0xC0, 0xEB, 0x13, 0x77, 0x05, 0x83,
	0xF9, 0x06, 0x76, 0x07, 0x83, 0x0D, 0x7C, 0x1A, 0x01, 0x00, 0xFF, 0xB8, 0xBB, 0x00, 0x00, 0xC0,
	0x5F, 0x5E, 0x5B, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x8B, 0xFF, 0x56, 0x68, 0x80, 0x1A,
	0x01, 0x00, 0xC7, 0x05, 0x80, 0x1A, 0x01, 0x00, 0x1C, 0x01, 0x00, 0x00, 0xFF, 0x15, 0x40, 0x12,
	0x01, 0x00, 0x8B, 0xF0, 0x85, 0xF6, 0x7C, 0x10, 0x83, 0x3D, 0x7C, 0x1A, 0x01, 0x00, 0x00, 0x75,
	0x05, 0xE8, 0x72, 0xFB, 0xFF, 0xFF, 0x8B, 0xC6, 0x5E, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x0C, 0x56, 0x33, 0xF6, 0x39, 0x75, 0x08, 0x75, 0x0A,
	0xB8, 0x01, 0x00, 0x00, 0xC0, 0xE9, 0x94, 0x00, 0x00, 0x00, 0x68, 0xC4, 0x55, 0x01, 0x00, 0x8D,
	0x45, 0xF4, 0x50, 0xFF, 0x15, 0x24, 0x12, 0x01, 0x00, 0x8D, 0x45, 0xFC, 0x50, 0x56, 0x56, 0x8B,
	0x35, 0x10, 0x12, 0x01, 0x00, 0x6A, 0x02, 0x8D, 0x45, 0xF4, 0x50, 0xFF, 0x75, 0x08, 0xFF, 0xD6,
	0x3D, 0x05, 0x00, 0x00, 0x80, 0x74, 0x07, 0x3D, 0x23, 0x00, 0x00, 0xC0, 0x75, 0xC2, 0x53, 0x57,
	0xBB, 0x4B, 0x70, 0x68, 0x54, 0x53, 0xFF, 0x75, 0xFC, 0x6A, 0x01, 0xFF, 0x15, 0x20, 0x12, 0x01,
	0x00, 0x8B, 0xF8, 0x85, 0xFF, 0x75, 0x07, 0xB8, 0x9A, 0x00, 0x00, 0xC0, 0xEB, 0x3E, 0x8D, 0x45,
	0xFC, 0x50, 0xFF, 0x75, 0xFC, 0x8D, 0x45, 0xF4, 0x57, 0x6A, 0x02, 0x50, 0xFF, 0x75, 0x08, 0xFF,
	0xD6, 0x8B, 0xF0, 0x85, 0xF6, 0x7C, 0x1B, 0x83, 0x7F, 0x04, 0x03, 0x75, 0x10, 0xFF, 0x77, 0x08,
	0x8D, 0x47, 0x0C, 0x50, 0xE8, 0xC7, 0xF9, 0xFF, 0xFF, 0x8B, 0xF0, 0xEB, 0x05, 0xBE, 0x24, 0x00,
	0x00, 0xC0, 0x53, 0x57, 0xFF, 0x15, 0x18, 0x12, 0x01, 0x00, 0x8B, 0xC6, 0x5F, 0x5B, 0x5E, 0xC9,
	0xC2, 0x04, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x51, 0x51, 0xFF,
	0x75, 0x08, 0x8D, 0x45, 0xF8, 0x50, 0xFF, 0x15, 0x24, 0x12, 0x01, 0x00, 0x8D, 0x45, 0xF8, 0x50,
	0xFF, 0x15, 0x44, 0x12, 0x01, 0x00, 0xC9, 0xC2, 0x04, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0x83, 0x3D, 0x7C, 0x1A, 0x01, 0x00, 0x3E, 0x72, 0x0F, 0x68, 0x0A, 0x57, 0x01, 0x00, 0xE8, 0xC5,
	0xFF, 0xFF, 0xFF, 0xA3, 0x30, 0x1A, 0x01, 0x00, 0x68, 0xEA, 0x56, 0x01, 0x00, 0xE8, 0xB6, 0xFF,
	0xFF, 0xFF, 0x68, 0xA2, 0x56, 0x01, 0x00, 0xA3, 0x28, 0x1A, 0x01, 0x00, 0xE8, 0xA7, 0xFF, 0xFF,
	0xFF, 0x68, 0x78, 0x56, 0x01, 0x00, 0xA3, 0x20, 0x1A, 0x01, 0x00, 0xE8, 0x98, 0xFF, 0xFF, 0xFF,
	0x68, 0x30, 0x56, 0x01, 0x00, 0xA3, 0x2C, 0x1A, 0x01, 0x00, 0xE8, 0x89, 0xFF, 0xFF, 0xFF, 0x68,
	0x10, 0x56, 0x01, 0x00, 0xA3, 0x38, 0x1A, 0x01, 0x00, 0xE8, 0x7A, 0xFF, 0xFF, 0xFF, 0x68, 0xEE,
	0x55, 0x01, 0x00, 0xA3, 0x24, 0x1A, 0x01, 0x00, 0xE8, 0x6B, 0xFF, 0xFF, 0xFF, 0xA3, 0x34, 0x1A,
	0x01, 0x00, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0xA1, 0x7C, 0x1A,
	0x01, 0x00, 0x8D, 0x48, 0xCD, 0x83, 0xF9, 0x09, 0x77, 0x08, 0x8B, 0x45, 0x08, 0x8B, 0x40, 0xF0,
	0xEB, 0x13, 0x83, 0xF8, 0x3D, 0x72, 0x0C, 0xA1, 0x28, 0x1A, 0x01, 0x00, 0x85, 0xC0, 0x74, 0x03,
	0x5D, 0xFF, 0xE0, 0x33, 0xC0, 0x5D, 0xC2, 0x04, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x8B, 0xFF,
	0x55, 0x8B, 0xEC, 0x56, 0x33, 0xF6, 0x83, 0x3D, 0x04, 0x19, 0x01, 0x00, 0xFF, 0x75, 0x04, 0x33,
	0xC0, 0xEB, 0x23, 0x57, 0x8B, 0x7D, 0x08, 0x57, 0xE8, 0xD9, 0xE6, 0xFF, 0xFF, 0x84, 0xC0, 0x74,
	0x12, 0xA1, 0x04, 0x19, 0x01, 0x00, 0x8B, 0x34, 0x38, 0x85, 0xF6, 0x75, 0x06, 0x57, 0xE8, 0x0D,
	0xE7, 0xFF, 0xFF, 0x8B, 0xC6, 0x5F, 0x5E, 0x5D, 0xC2, 0x04, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x8B, 0x4D, 0x0C, 0x33, 0xC0, 0x40, 0xF0, 0x0F, 0xC1, 0x01, 0x8B,
	0x45, 0x08, 0x8B, 0x0D, 0x10, 0x19, 0x01, 0x00, 0x03, 0xC8, 0x83, 0x39, 0x00, 0x74, 0x08, 0x33,
	0xD2, 0xFF, 0x15, 0x30, 0x1A, 0x01, 0x00, 0x5D, 0xC2, 0x08, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0x6A, 0x24, 0x68, 0x80, 0x14, 0x01, 0x00, 0xE8, 0x18, 0xE8, 0xFF, 0xFF, 0x8B, 0x4D, 0x08, 0x8B,
	0x11, 0x8B, 0xC2, 0x83, 0xE0, 0xF8, 0x8B, 0x75, 0x0C, 0x89, 0x75, 0xCC, 0x8D, 0x70, 0x18, 0xF7,
	0xD8, 0x1B, 0xC0, 0x23, 0xC6, 0x89, 0x45, 0xD0, 0x8B, 0x49, 0x04, 0x8B, 0xF1, 0x81, 0xE6, 0xFF,
	0xFF, 0xFF, 0xFD, 0x89, 0x75, 0xD4, 0xBE, 0xFF, 0xFF, 0x00, 0x00, 0x66, 0x89, 0x75, 0xD8, 0x33,
	0xF6, 0x66, 0x89, 0x75, 0xDA, 0xC1, 0xE9, 0x19, 0x83, 0xE1, 0x01, 0x83, 0xE2, 0x06, 0x0B, 0xCA,
	0x89, 0x4D, 0xDC, 0x89, 0x75, 0xE0, 0x3B, 0xC6, 0x74, 0x2D, 0x50, 0xE8, 0xF8, 0xFE, 0xFF, 0xFF,
	0x3B, 0xC6, 0x74, 0x23, 0x8B, 0x0D, 0x18, 0x19, 0x01, 0x00, 0x83, 0xF9, 0xFF, 0x74, 0x18, 0x83,
	0x3D, 0x7C, 0x1A, 0x01, 0x00, 0x3D, 0x72, 0x07, 0x66, 0x0F, 0xB6, 0x04, 0x01, 0xEB, 0x04, 0x66,
	0x8B, 0x04, 0x01, 0x66, 0x89, 0x45, 0xD8, 0x8B, 0x45, 0x10, 0x8B, 0x78, 0x08, 0x8D, 0x4F, 0x18,
	0x89, 0x48, 0x08, 0xFF, 0x40, 0x0C, 0x3B, 0x38, 0x72, 0x3B, 0x3B, 0x48, 0x04, 0x77, 0x36, 0x89,
	0x75, 0xFC, 0x6A, 0x06, 0x59, 0x8D, 0x75, 0xCC, 0xF3, 0xA5, 0xEB, 0x20, 0x8B, 0x45, 0xEC, 0x8B,
	0x00, 0x8B, 0x00, 0x89, 0x45, 0xE4, 0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x65, 0xE8, 0x8B, 0x45, 0x10,
	0x83, 0x78, 0x10, 0x00, 0x75, 0x06, 0x8B, 0x4D, 0xE4, 0x89, 0x48, 0x10, 0xC7, 0x45, 0xFC, 0xFE,
	0xFF, 0xFF, 0xFF, 0xEB, 0x0C, 0x39, 0x70, 0x10, 0x75, 0x07, 0xC7, 0x40, 0x10, 0x23, 0x00, 0x00,
	0xC0, 0x32, 0xC0, 0xE8, 0x81, 0xE7, 0xFF, 0xFF, 0xC2, 0x0C, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x53, 0xFF, 0x75, 0x14, 0xFF, 0x75, 0x10, 0xFF, 0x75, 0x0C, 0xE8,
	0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x75, 0x0C, 0x8A, 0xD8, 0xFF, 0x75, 0x08, 0xE8, 0xBF, 0xFE, 0xFF,
	0xFF, 0x8A, 0xC3, 0x5B, 0x5D, 0xC2, 0x10, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x6A, 0x28,
	0x68, 0xA0, 0x14, 0x01, 0x00, 0xE8, 0xFA, 0xE6, 0xFF, 0xFF, 0x33, 0xDB, 0x83, 0x3D, 0x7C, 0x1A,
	0x01, 0x00, 0x3E, 0x72, 0x1B, 0x39, 0x1D, 0x30, 0x1A, 0x01, 0x00, 0x74, 0x09, 0x83, 0x3D, 0x10,
	0x19, 0x01, 0x00, 0xFF, 0x75, 0x0A, 0xB8, 0xBB, 0x00, 0x00, 0xC0, 0xE9, 0x55, 0x01, 0x00, 0x00,
	0x38, 0x5D, 0x18, 0x74, 0x4B, 0x89, 0x5D, 0xFC, 0x6A, 0x04, 0xFF, 0x75, 0x10, 0x8B, 0x7D, 0x0C,
	0x57, 0x8B, 0x35, 0x2C, 0x12, 0x01, 0x00, 0xFF, 0xD6, 0x39, 0x5D, 0x14, 0x74, 0x09, 0x6A, 0x04,
	0x6A, 0x04, 0xFF, 0x75, 0x14, 0xFF, 0xD6, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xEB, 0x23,
	0x8B, 0x45, 0xEC, 0x8B, 0x00, 0x8B, 0x00, 0x89, 0x45, 0xE4, 0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x45,
	0xE4, 0x8B, 0x65, 0xE8, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xE9, 0x05, 0x01, 0x00, 0x00,
	0x8B, 0x7D, 0x0C, 0x53, 0x8D, 0x45, 0x0C, 0x50, 0xFF, 0x75, 0x18, 0xA1, 0x54, 0x12, 0x01, 0x00,
	0xFF, 0x30, 0x53, 0xFF, 0x75, 0x08, 0xFF, 0x15, 0x50, 0x12, 0x01, 0x00, 0x3B, 0xC3, 0x0F, 0x8C,
	0xE1, 0x00, 0x00, 0x00, 0xFF, 0x75, 0x0C, 0xE8, 0xC2, 0xFD, 0xFF, 0xFF, 0x3B, 0xC3, 0x75, 0x13,
	0x8B, 0x4D, 0x0C, 0xFF, 0x15, 0x4C, 0x12, 0x01, 0x00, 0xB8, 0x01, 0x00, 0x00, 0xC0, 0xE9, 0xC2,
	0x00, 0x00, 0x00, 0x89, 0x7D, 0xC8, 0x8B, 0x75, 0x10, 0x8D, 0x0C, 0x37, 0x89, 0x4D, 0xCC, 0x8D,
	0x4F, 0x04, 0x89, 0x4D, 0xD0, 0x89, 0x5D, 0xD4, 0x89, 0x5D, 0xD8, 0x53, 0x8D, 0x4D, 0xC8, 0x51,
	0x83, 0x3D, 0x7C, 0x1A, 0x01, 0x00, 0x3E, 0x72, 0x07, 0x68, 0x20, 0x27, 0x01, 0x00, 0xEB, 0x05,
	0x68, 0x30, 0x26, 0x01, 0x00, 0x50, 0xFF, 0x15, 0x48, 0x12, 0x01, 0x00, 0xFF, 0x75, 0x0C, 0xE8,
	0xAC, 0xE4, 0xFF, 0xFF, 0x8B, 0x4D, 0x0C, 0xFF, 0x15, 0x4C, 0x12, 0x01, 0x00, 0x83, 0xFE, 0x04,
	0x72, 0x35, 0x38, 0x5D, 0x18, 0x74, 0x2B, 0xC7, 0x45, 0xFC, 0x01, 0x00, 0x00, 0x00, 0x8B, 0x45,
	0xD4, 0x89, 0x07, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xEB, 0x1B, 0x8B, 0x45, 0xEC, 0x8B,
	0x00, 0x8B, 0x00, 0x89, 0x45, 0xE0, 0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x45, 0xE0, 0xE9, 0x2F, 0xFF,
	0xFF, 0xFF, 0x8B, 0x45, 0xD4, 0x89, 0x07, 0x8B, 0x75, 0x14, 0x3B, 0xF3, 0x74, 0x34, 0x8B, 0x45,
	0xD0, 0x2B, 0xC7, 0x38, 0x5D, 0x18, 0x74, 0x28, 0xC7, 0x45, 0xFC, 0x02, 0x00, 0x00, 0x00, 0x89,
	0x06, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xEB, 0x18, 0x8B, 0x45, 0xEC, 0x8B, 0x00, 0x8B,
	0x00, 0x89, 0x45, 0xDC, 0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x45, 0xDC, 0xE9, 0xF1, 0xFE, 0xFF, 0xFF,
	0x89, 0x06, 0x8B, 0x45, 0xD8, 0xE8, 0xBF, 0xE5, 0xFF, 0xFF, 0xC2, 0x14, 0x00, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x51, 0x6A, 0x08, 0x59, 0x39, 0x4D, 0x10, 0x73, 0x0C,
	0x8B, 0x45, 0x14, 0x89, 0x08, 0xB8, 0x23, 0x00, 0x00, 0xC0, 0xEB, 0x5E, 0x53, 0x33, 0xC0, 0x56,
	0x8B, 0x75, 0x0C, 0x66, 0x89, 0x06, 0x8D, 0x46, 0x08, 0x57, 0x8B, 0x7D, 0x08, 0x89, 0x46, 0x04,
	0x89, 0x45, 0x0C, 0x8B, 0x47, 0x04, 0x33, 0xDB, 0x8B, 0xD1, 0x3B, 0xC3, 0x74, 0x2D, 0x8D, 0x4D,
	0xFC, 0x51, 0xFF, 0x75, 0x10, 0x56, 0x50, 0xFF, 0x15, 0x58, 0x12, 0x01, 0x00, 0x3B, 0xC3, 0x7D,
	0x0F, 0x3D, 0x04, 0x00, 0x00, 0xC0, 0x75, 0x03, 0x83, 0xC0, 0x1F, 0x8B, 0x55, 0xFC, 0xEB, 0x12,
	0x0F, 0xB7, 0x06, 0x01, 0x45, 0x0C, 0x83, 0xC0, 0x08, 0x8B, 0xD0, 0x39, 0x5F, 0x34, 0x75, 0x0E,
	0x33, 0xC0, 0x8B, 0x4D, 0x14, 0x5F, 0x5E, 0x89, 0x11, 0x5B, 0xC9, 0xC2, 0x10, 0x00, 0x8B, 0xC7,
	0x0F, 0xB7, 0x48, 0x30, 0x03, 0xD9, 0x8B, 0x48, 0x20, 0x3B, 0xC1, 0x74, 0x06, 0x8B, 0xC1, 0x85,
	0xC0, 0x75, 0xED, 0x03, 0xD3, 0x89, 0x55, 0x08, 0x3B, 0x55, 0x10, 0x76, 0x07, 0xB8, 0x23, 0x00,
	0x00, 0xC0, 0xEB, 0xCE, 0x01, 0x5D, 0x0C, 0x0F, 0xB7, 0x47, 0x30, 0x29, 0x45, 0x0C, 0x50, 0xFF,
	0x77, 0x34, 0xFF, 0x75, 0x0C, 0xE8, 0xA2, 0xE4, 0xFF, 0xFF, 0x8B, 0x47, 0x20, 0x83, 0xC4, 0x0C,
	0x3B, 0xF8, 0x74, 0x06, 0x8B, 0xF8, 0x85, 0xFF, 0x75, 0xDD, 0x66, 0x01, 0x1E, 0x8B, 0x55, 0x08,
	0xEB, 0x9E, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x6A, 0x2C, 0x68, 0xD8, 0x14, 0x01, 0x00, 0xE8,
	0x90, 0xE4, 0xFF, 0xFF, 0x33, 0xDB, 0x38, 0x5D, 0x1C, 0x74, 0x25, 0x33, 0xC0, 0x83, 0x7D, 0x10,
	0x03, 0x0F, 0x94, 0xC0, 0x48, 0x83, 0xE0, 0x03, 0x40, 0x89, 0x5D, 0xFC, 0x50, 0xFF, 0x75, 0x18,
	0xFF, 0x75, 0x14, 0xFF, 0x15, 0x38, 0x12, 0x01, 0x00, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF,
	0x53, 0x8D, 0x45, 0xE4, 0x50, 0xFF, 0x75, 0x1C, 0xA1, 0x54, 0x12, 0x01, 0x00, 0xFF, 0x30, 0x53,
	0xFF, 0x75, 0x08, 0xFF, 0x15, 0x50, 0x12, 0x01, 0x00, 0x8B, 0xF0, 0x3B, 0xF3, 0x0F, 0x8C, 0xCD,
	0x00, 0x00, 0x00, 0x8B, 0x4D, 0xE4, 0xA1, 0x68, 0x12, 0x01, 0x00, 0x3B, 0x08, 0x75, 0x37, 0x81,
	0x4D, 0x0C, 0x00, 0x00, 0x00, 0x80, 0x83, 0x7D, 0x10, 0x03, 0x74, 0x3C, 0xBE, 0x03, 0x00, 0x00,
	0xC0, 0xE9, 0xA1, 0x00, 0x00, 0x00, 0x8B, 0x45, 0xEC, 0x8B, 0x00, 0x8B, 0x00, 0x89, 0x45, 0xE0,
	0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x65, 0xE8, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x8B, 0x45,
	0xE0, 0xE9, 0x8C, 0x00, 0x00, 0x00, 0x39, 0x5D, 0x0C, 0x7D, 0xCB, 0xFF, 0x15, 0x4C, 0x12, 0x01,
	0x00, 0xB8, 0x08, 0x00, 0x00, 0xC0, 0xEB, 0x7A, 0x83, 0x7D, 0x18, 0x02, 0x75, 0x39, 0xC7, 0x45,
	0xFC, 0x01, 0x00, 0x00, 0x00, 0x8B, 0x45, 0x14, 0x66, 0x8B, 0x00, 0x66, 0x89, 0x45, 0x1C, 0xC7,
	0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xEB, 0x24, 0x8B, 0x45, 0xEC, 0x8B, 0x00, 0x8B, 0x00, 0x89,
	0x45, 0xDC, 0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x65, 0xE8, 0x8B, 0x75, 0xDC, 0xC7, 0x45, 0xFC, 0xFE,
	0xFF, 0xFF, 0xFF, 0x33, 0xDB, 0xEB, 0x05, 0xBE, 0x04, 0x00, 0x00, 0xC0, 0x3B, 0xF3, 0x7C, 0x27,
	0x8D, 0x45, 0xC4, 0x50, 0xFF, 0x75, 0xE4, 0xFF, 0x15, 0x64, 0x12, 0x01, 0x00, 0x53, 0x8D, 0x45,
	0x1C, 0x50, 0xFF, 0x75, 0x0C, 0xFF, 0x15, 0x60, 0x12, 0x01, 0x00, 0x8B, 0xF0, 0x8D, 0x45, 0xC4,
	0x50, 0xFF, 0x15, 0x5C, 0x12, 0x01, 0x00, 0x8B, 0x4D, 0xE4, 0xFF, 0x15, 0x4C, 0x12, 0x01, 0x00,
	0x8B, 0xC6, 0xE8, 0xB2, 0xE3, 0xFF, 0xFF, 0xC2, 0x18, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x20, 0x83, 0x7D, 0x0C, 0x00, 0xC6, 0x45, 0xFF, 0x00,
	0xC6, 0x45, 0xFE, 0x00, 0x74, 0x06, 0x83, 0x7D, 0x14, 0x00, 0x75, 0x10, 0xF6, 0x45, 0x20, 0x01,
	0x75, 0x0A, 0xB8, 0x30, 0x00, 0x00, 0xC0, 0xE9, 0x26, 0x01, 0x00, 0x00, 0x8A, 0x45, 0x24, 0x84,
	0xC0, 0x74, 0x13, 0xF7, 0x45, 0x1C, 0x00, 0x02, 0x00, 0x00, 0x74, 0x0A, 0xB8, 0xF4, 0x00, 0x00,
	0xC0, 0xE9, 0x0C, 0x01, 0x00, 0x00, 0x8B, 0x0D, 0x68, 0x12, 0x01, 0x00, 0x53, 0x8B, 0x5D, 0x08,
	0x3B, 0x19, 0x75, 0x0D, 0x81, 0x4D, 0x10, 0x00, 0x00, 0x00, 0x80, 0xC6, 0x45, 0x24, 0x00, 0xEB,
	0x03, 0x88, 0x45, 0x24, 0x57, 0x8B, 0x3D, 0x74, 0x12, 0x01, 0x00, 0xFF, 0xD7, 0x3B, 0xD8, 0x75,
	0x10, 0xF6, 0x45, 0x20, 0x01, 0x74, 0x0A, 0xB8, 0xDB, 0x00, 0x00, 0xC0, 0xE9, 0xCF, 0x00, 0x00,
	0x00, 0x56, 0xFF, 0xD7, 0x8B, 0x35, 0x64, 0x12, 0x01, 0x00, 0x3B, 0xD8, 0x74, 0x0B, 0x8D, 0x45,
	0xE0, 0x50, 0x53, 0xFF, 0xD6, 0xC6, 0x45, 0xFF, 0x01, 0xF6, 0x45, 0x20, 0x01, 0x74, 0x25, 0xFF,
	0x75, 0x24, 0xFF, 0x75, 0x10, 0xFF, 0x15, 0x70, 0x12, 0x01, 0x00, 0x80, 0x7D, 0xFF, 0x00, 0x8B,
	0xF0, 0x74, 0x0A, 0x8D, 0x45, 0xE0, 0x50, 0xFF, 0x15, 0x5C, 0x12, 0x01, 0x00, 0x8B, 0xC6, 0xE9,
	0x8B, 0x00, 0x00, 0x00, 0x33, 0xC0, 0x50, 0x8D, 0x4D, 0x08, 0x51, 0xFF, 0x75, 0x24, 0x50, 0x50,
	0xFF, 0x75, 0x10, 0xFF, 0x15, 0x50, 0x12, 0x01, 0x00, 0x80, 0x7D, 0xFF, 0x00, 0x8B, 0xD8, 0x74,
	0x0A, 0x8D, 0x45, 0xE0, 0x50, 0xFF, 0x15, 0x5C, 0x12, 0x01, 0x00, 0x85, 0xDB, 0x7D, 0x04, 0x8B,
	0xC3, 0xEB, 0x5C, 0xFF, 0xD7, 0x39, 0x45, 0x0C, 0x74, 0x0D, 0x8D, 0x45, 0xE0, 0x50, 0xFF, 0x75,
	0x0C, 0xFF, 0xD6, 0xC6, 0x45, 0xFE, 0x01, 0x8D, 0x45, 0xF8, 0x50, 0x33, 0xF6, 0x56, 0x56, 0xFF,
	0x75, 0x18, 0x56, 0xFF, 0x75, 0x1C, 0xFF, 0x75, 0x08, 0xFF, 0x15, 0x6C, 0x12, 0x01, 0x00, 0x8B,
	0x4D, 0x08, 0x8B, 0xF8, 0xFF, 0x15, 0x4C, 0x12, 0x01, 0x00, 0x80, 0x7D, 0xFE, 0x00, 0x74, 0x0A,
	0x8D, 0x45, 0xE0, 0x50, 0xFF, 0x15, 0x5C, 0x12, 0x01, 0x00, 0x3B, 0xFE, 0x7C, 0x0A, 0x8B, 0x45,
	0xF8, 0x8B, 0x4D, 0x14, 0x89, 0x01, 0xEB, 0x05, 0x8B, 0x45, 0x14, 0x89, 0x30, 0x8B, 0xC7, 0x5E,
	0x5F, 0x5B, 0xC9, 0xC2, 0x20, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x6A, 0x14, 0x68, 0x00,
	0x15, 0x01, 0x00, 0xE8, 0xFC, 0xE1, 0xFF, 0xFF, 0x33, 0xDB, 0x89, 0x5D, 0xE4, 0x89, 0x5D, 0xE0,
	0x38, 0x5D, 0x24, 0x74, 0x3E, 0x89, 0x5D, 0xFC, 0x8B, 0x7D, 0x14, 0x3B, 0xFB, 0x74, 0x0B, 0x6A,
	0x01, 0x6A, 0x04, 0x57, 0xFF, 0x15, 0x2C, 0x12, 0x01, 0x00, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF,
	0xFF, 0xEB, 0x23, 0x8B, 0x45, 0xEC, 0x8B, 0x00, 0x8B, 0x00, 0x89, 0x45, 0xDC, 0x33, 0xC0, 0x40,
	0xC3, 0x8B, 0x65, 0xE8, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x8B, 0x45, 0xDC, 0xE9, 0xB8,
	0x00, 0x00, 0x00, 0x8B, 0x7D, 0x14, 0x53, 0x8D, 0x45, 0xE4, 0x50, 0xFF, 0x75, 0x24, 0xA1, 0x54,
	0x12, 0x01, 0x00, 0xFF, 0x30, 0x53, 0xFF, 0x75, 0x08, 0x8B, 0x35, 0x50, 0x12, 0x01, 0x00, 0xFF,
	0xD6, 0x3B, 0xC3, 0x0F, 0x8C, 0x92, 0x00, 0x00, 0x00, 0x39, 0x5D, 0x10, 0x74, 0x1B, 0x53, 0x8D,
	0x45, 0xE0, 0x50, 0xFF, 0x75, 0x24, 0xA1, 0x54, 0x12, 0x01, 0x00, 0xFF, 0x30, 0x53, 0xFF, 0x75,
	0x10, 0xFF, 0xD6, 0x8B, 0xF0, 0x3B, 0xF3, 0x7C, 0x67, 0xFF, 0x75, 0x24, 0xFF, 0x75, 0x20, 0xFF,
	0x75, 0x1C, 0xFF, 0x75, 0x18, 0x8D, 0x45, 0x14, 0x50, 0xFF, 0x75, 0x0C, 0xFF, 0x75, 0xE0, 0xFF,
	0x75, 0xE4, 0xE8, 0xE9, 0xFD, 0xFF, 0xFF, 0x8B, 0xF0, 0x3B, 0xFB, 0x74, 0x36, 0x38, 0x5D, 0x24,
	0x74, 0x2C, 0xC7, 0x45, 0xFC, 0x01, 0x00, 0x00, 0x00, 0x8B, 0x45, 0x14, 0x89, 0x07, 0xC7, 0x45,
	0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xEB, 0x1C, 0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x65, 0xE8, 0xBE, 0x05,
	0x00, 0x00, 0xC0, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x33, 0xDB, 0xEB, 0x05, 0x8B, 0x45,
	0x14, 0x89, 0x07, 0x8B, 0x4D, 0xE0, 0x3B, 0xCB, 0x74, 0x06, 0xFF, 0x15, 0x4C, 0x12, 0x01, 0x00,
	0x8B, 0x4D, 0xE4, 0xFF, 0x15, 0x4C, 0x12, 0x01, 0x00, 0x8B, 0xC6, 0xE8, 0x39, 0xE1, 0xFF, 0xFF,
	0xC2, 0x20, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x6A, 0x34, 0x68, 0x28, 0x15, 0x01, 0x00, 0xE8,
	0xE0, 0xE0, 0xFF, 0xFF, 0x33, 0xDB, 0x89, 0x5D, 0xBC, 0x33, 0xC0, 0x8D, 0x7D, 0xC0, 0xAB, 0xAB,
	0xAB, 0xAB, 0xAB, 0x38, 0x5D, 0x18, 0x74, 0x4F, 0x89, 0x5D, 0xFC, 0x6A, 0x04, 0x6A, 0x04, 0xFF,
	0x75, 0x08, 0xFF, 0x15, 0x2C, 0x12, 0x01, 0x00, 0x6A, 0x04, 0x6A, 0x18, 0x8B, 0x75, 0x10, 0x56,
	0xFF, 0x15, 0x38, 0x12, 0x01, 0x00, 0x6A, 0x06, 0x59, 0x8D, 0x7D, 0xBC, 0xF3, 0xA5, 0xC7, 0x45,
	0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xEB, 0x2B, 0x8B, 0x45, 0xEC, 0x8B, 0x00, 0x8B, 0x00, 0x89, 0x45,
	0xE0, 0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x65, 0xE8, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x8B,
	0x45, 0xE0, 0xE9, 0xB7, 0x00, 0x00, 0x00, 0x6A, 0x06, 0x59, 0x8B, 0x75, 0x10, 0x8D, 0x7D, 0xBC,
	0xF3, 0xA5, 0x39, 0x5D, 0xC4, 0x75, 0x0A, 0xB8, 0x0D, 0x00, 0x00, 0xC0, 0xE9, 0x9D, 0x00, 0x00,
	0x00, 0x38, 0x5D, 0x18, 0x74, 0x13, 0xF7, 0x45, 0xC8, 0x00, 0x02, 0x00, 0x00, 0x75, 0xE8, 0x38,
	0x5D, 0x18, 0x74, 0x05, 0x39, 0x5D, 0xC0, 0x7C, 0xDE, 0x8D, 0x45, 0xD4, 0x50, 0xFF, 0x75, 0xC4,
	0xE8, 0xB3, 0xDD, 0xFF, 0xFF, 0x3B, 0xC3, 0x7C, 0x75, 0x8D, 0x45, 0xD4, 0x89, 0x45, 0xC4, 0x89,
	0x5D, 0xCC, 0x89, 0x5D, 0xD0, 0x8D, 0x45, 0xE4, 0x50, 0x53, 0xFF, 0x75, 0x0C, 0x53, 0x53, 0xFF,
	0x75, 0x14, 0x8D, 0x45, 0xBC, 0x50, 0xFF, 0x15, 0x78, 0x12, 0x01, 0x00, 0x8B, 0xF0, 0x39, 0x5D,
	0xD8, 0x74, 0x0E, 0x68, 0x4B, 0x70, 0x68, 0x55, 0xFF, 0x75, 0xD8, 0xFF, 0x15, 0x18, 0x12, 0x01,
	0x00, 0x38, 0x5D, 0x18, 0x74, 0x2E, 0xC7, 0x45, 0xFC, 0x01, 0x00, 0x00, 0x00, 0x8B, 0x45, 0xE4,
	0x8B, 0x4D, 0x08, 0x89, 0x01, 0xEB, 0x14, 0x8B, 0x45, 0xEC, 0x8B, 0x00, 0x8B, 0x00, 0x89, 0x45,
	0xDC, 0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x65, 0xE8, 0x8B, 0x75, 0xDC, 0xC7, 0x45, 0xFC, 0xFE, 0xFF,
	0xFF, 0xFF, 0xEB, 0x08, 0x8B, 0x45, 0xE4, 0x8B, 0x4D, 0x08, 0x89, 0x01, 0x8B, 0xC6, 0xE8, 0x06,
	0xE0, 0xFF, 0xFF, 0xC2, 0x14, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x8B, 0xFF, 0x55, 0x8B,
	0xEC, 0x56, 0x8B, 0x75, 0x08, 0x56, 0xE8, 0xDD, 0xF6, 0xFF, 0xFF, 0x8B, 0x0D, 0x7C, 0x12, 0x01,
	0x00, 0x3B, 0x01, 0x75, 0x1D, 0x83, 0x7E, 0x44, 0x00, 0x75, 0x06, 0x83, 0x7E, 0x40, 0x00, 0x74,
	0x11, 0xFF, 0x75, 0x14, 0xFF, 0x75, 0x10, 0xFF, 0x75, 0x0C, 0x56, 0xE8, 0x12, 0xFA, 0xFF, 0xFF,
	0xEB, 0x10, 0xFF, 0x75, 0x14, 0xFF, 0x75, 0x10, 0xFF, 0x75, 0x0C, 0x56, 0xFF, 0x15, 0x58, 0x12,
	0x01, 0x00, 0xB9, 0x23, 0x00, 0x00, 0xC0, 0x5E, 0x3D, 0x05, 0x00, 0x00, 0x80, 0x75, 0x02, 0x8B,
	0xC1, 0x3D, 0x04, 0x00, 0x00, 0xC0, 0x75, 0x02, 0x8B, 0xC1, 0x5D, 0xC2, 0x10, 0x00, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0x68, 0xA4, 0x00, 0x00, 0x00, 0x68, 0x50, 0x15, 0x01, 0x00, 0xE8, 0x09,
	0xE1, 0xFF, 0xFF, 0x8B, 0x45, 0x08, 0x89, 0x45, 0x98, 0x8B, 0x7D, 0x0C, 0x8B, 0x45, 0x14, 0x89,
	0x45, 0x9C, 0x8B, 0x5D, 0x1C, 0x89, 0x9D, 0x5C, 0xFF, 0xFF, 0xFF, 0x80, 0x7D, 0x20, 0x00, 0x74,
	0x24, 0x83, 0x65, 0xFC, 0x00, 0x6A, 0x04, 0xFF, 0x75, 0x18, 0x50, 0x8B, 0x35, 0x2C, 0x12, 0x01,
	0x00, 0xFF, 0xD6, 0x85, 0xDB, 0x74, 0x07, 0x6A, 0x04, 0x6A, 0x04, 0x53, 0xFF, 0xD6, 0xC7, 0x45,
	0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x6A, 0x00, 0x8D, 0x45, 0x90, 0x50, 0xFF, 0x75, 0x20, 0xA1, 0x54,
	0x12, 0x01, 0x00, 0xFF, 0x30, 0x6A, 0x00, 0xFF, 0x75, 0x98, 0x8B, 0x35, 0x50, 0x12, 0x01, 0x00,
	0xFF, 0xD6, 0x85, 0xC0, 0x0F, 0x8C, 0x81, 0x07, 0x00, 0x00, 0x8B, 0x4D, 0x90, 0xA1, 0x68, 0x12,
	0x01, 0x00, 0x3B, 0x08, 0x75, 0x32, 0x81, 0xCF, 0x00, 0x00, 0x00, 0x80, 0xC6, 0x45, 0xA8, 0x00,
	0xEB, 0x40, 0x8B, 0x45, 0xEC, 0x8B, 0x00, 0x8B, 0x00, 0x89, 0x85, 0x50, 0xFF, 0xFF, 0xFF, 0x33,
	0xC0, 0x40, 0xC3, 0x8B, 0x65, 0xE8, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x8B, 0x85, 0x50,
	0xFF, 0xFF, 0xFF, 0xE9, 0x43, 0x07, 0x00, 0x00, 0x85, 0xFF, 0x7D, 0x10, 0xFF, 0x15, 0x4C, 0x12,
	0x01, 0x00, 0xB8, 0x08, 0x00, 0x00, 0xC0, 0xE9, 0x2F, 0x07, 0x00, 0x00, 0x8A, 0x45, 0x20, 0x88,
	0x45, 0xA8, 0x8B, 0x45, 0x10, 0x6A, 0x08, 0x5B, 0x3B, 0xC3, 0x0F, 0x87, 0xD1, 0x06, 0x00, 0x00,
	0xFF, 0x24, 0x85, 0x04, 0x37, 0x01, 0x00, 0x8D, 0x85, 0x78, 0xFF, 0xFF, 0xFF, 0x50, 0x51, 0xFF,
	0x15, 0x64, 0x12, 0x01, 0x00, 0x33, 0xF6, 0x56, 0x6A, 0x38, 0x8D, 0x45, 0xAC, 0x50, 0x56, 0x57,
	0xFF, 0x15, 0x94, 0x12, 0x01, 0x00, 0x89, 0x45, 0xA8, 0x8D, 0x85, 0x78, 0xFF, 0xFF, 0xFF, 0x50,
	0xFF, 0x15, 0x5C, 0x12, 0x01, 0x00, 0x39, 0x75, 0xA8, 0x7C, 0x47, 0x83, 0x7D, 0x18, 0x38, 0x75,
	0x3A, 0xC7, 0x45, 0xFC, 0x01, 0x00, 0x00, 0x00, 0x6A, 0x0E, 0x59, 0x8D, 0x75, 0xAC, 0x8B, 0x7D,
	0x9C, 0xF3, 0xA5, 0xEB, 0x1D, 0x8B, 0x45, 0xEC, 0x8B, 0x00, 0x8B, 0x00, 0x89, 0x85, 0x54, 0xFF,
	0xFF, 0xFF, 0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x65, 0xE8, 0x8B, 0x85, 0x54, 0xFF, 0xFF, 0xFF, 0x89,
	0x45, 0xA8, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xEB, 0x07, 0xC7, 0x45, 0xA8, 0x04, 0x00,
	0x00, 0xC0, 0xC7, 0x45, 0xA0, 0x38, 0x00, 0x00, 0x00, 0xE9, 0x4E, 0x06, 0x00, 0x00, 0x89, 0x5D,
	0xA0, 0x8D, 0x85, 0x78, 0xFF, 0xFF, 0xFF, 0x50, 0x51, 0xFF, 0x15, 0x64, 0x12, 0x01, 0x00, 0x33,
	0xC0, 0x50, 0x8D, 0x4D, 0xA4, 0x51, 0xFF, 0x75, 0xA8, 0x50, 0x50, 0x57, 0xFF, 0xD6, 0x89, 0x45,
	0xA8, 0x8D, 0x85, 0x78, 0xFF, 0xFF, 0xFF, 0x50, 0xFF, 0x15, 0x5C, 0x12, 0x01, 0x00, 0x83, 0x7D,
	0xA8, 0x00, 0x0F, 0x8C, 0x14, 0x06, 0x00, 0x00, 0x8B, 0x7D, 0x18, 0x8B, 0xC7, 0x3B, 0xFB, 0x73,
	0x02, 0x8B, 0xC3, 0x68, 0x4B, 0x70, 0x68, 0x51, 0x50, 0x6A, 0x01, 0xFF, 0x15, 0x90, 0x12, 0x01,
	0x00, 0x8B, 0xF0, 0x89, 0x75, 0x98, 0x85, 0xF6, 0x0F, 0x84, 0x82, 0x00, 0x00, 0x00, 0x57, 0x6A,
	0x00, 0x56, 0xE8, 0x71, 0xDD, 0xFF, 0xFF, 0x83, 0xC4, 0x0C, 0x8D, 0x45, 0xA0, 0x50, 0x57, 0x56,
	0xFF, 0x75, 0xA4, 0xE8, 0xB4, 0xFD, 0xFF, 0xFF, 0x89, 0x45, 0xA8, 0x85, 0xC0, 0x7C, 0x53, 0x8B,
	0x46, 0x04, 0x85, 0xC0, 0x74, 0x08, 0x2B, 0xC6, 0x03, 0x45, 0x9C, 0x89, 0x46, 0x04, 0xC7, 0x45,
	0xFC, 0x02, 0x00, 0x00, 0x00, 0x57, 0x56, 0xFF, 0x75, 0x9C, 0xE8, 0x2D, 0xDD, 0xFF, 0xFF, 0x83,
	0xC4, 0x0C, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xEB, 0x27, 0x8B, 0x45, 0xEC, 0x8B, 0x00,
	0x8B, 0x00, 0x89, 0x85, 0x4C, 0xFF, 0xFF, 0xFF, 0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x65, 0xE8, 0x8B,
	0x85, 0x4C, 0xFF, 0xFF, 0xFF, 0x89, 0x45, 0xA8, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x8B,
	0x75, 0x98, 0x68, 0x4B, 0x70, 0x68, 0x51, 0x56, 0xFF, 0x15, 0x18, 0x12, 0x01, 0x00, 0xEB, 0x07,
	0xC7, 0x45, 0xA8, 0x9A, 0x00, 0x00, 0xC0, 0x8B, 0x4D, 0xA4, 0xFF, 0x15, 0x4C, 0x12, 0x01, 0x00,
	0xE9, 0x57, 0x05, 0x00, 0x00, 0x6A, 0x60, 0x59, 0x89, 0x4D, 0xA0, 0x8B, 0x45, 0x18, 0x3B, 0xC1,
	0x73, 0x02, 0x8B, 0xC1, 0x03, 0xC3, 0x68, 0x4B, 0x70, 0x68, 0x51, 0x50, 0x6A, 0x01, 0xFF, 0x15,
	0x90, 0x12, 0x01, 0x00, 0x8B, 0xF0, 0x89, 0x75, 0x98, 0x85, 0xF6, 0x0F, 0x84, 0xAB, 0x00, 0x00,
	0x00, 0xFF, 0x75, 0x18, 0x6A, 0x00, 0x56, 0xE8, 0xAC, 0xDC, 0xFF, 0xFF, 0x83, 0xC4, 0x0C, 0x8D,
	0x85, 0x78, 0xFF, 0xFF, 0xFF, 0x50, 0xFF, 0x75, 0x90, 0xFF, 0x15, 0x64, 0x12, 0x01, 0x00, 0x8D,
	0x45, 0xA0, 0x50, 0xFF, 0x75, 0x18, 0x56, 0x6A, 0x02, 0x57, 0xFF, 0x15, 0x94, 0x12, 0x01, 0x00,
	0x89, 0x45, 0xA8, 0x8D, 0x85, 0x78, 0xFF, 0xFF, 0xFF, 0x50, 0xFF, 0x15, 0x5C, 0x12, 0x01, 0x00,
	0x83, 0x7D, 0xA8, 0x00, 0x7C, 0x55, 0x8B, 0x46, 0x04, 0x85, 0xC0, 0x74, 0x08, 0x2B, 0xC6, 0x03,
	0x45, 0x9C, 0x89, 0x46, 0x04, 0xC7, 0x45, 0xFC, 0x03, 0x00, 0x00, 0x00, 0xFF, 0x75, 0x18, 0x56,
	0xFF, 0x75, 0x9C, 0xE8, 0x44, 0xDC, 0xFF, 0xFF, 0x83, 0xC4, 0x0C, 0xC7, 0x45, 0xFC, 0xFE, 0xFF,
	0xFF, 0xFF, 0xEB, 0x27, 0x8B, 0x45, 0xEC, 0x8B, 0x00, 0x8B, 0x00, 0x89, 0x85, 0x74, 0xFF, 0xFF,
	0xFF, 0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x65, 0xE8, 0x8B, 0x85, 0x74, 0xFF, 0xFF, 0xFF, 0x89, 0x45,
	0xA8, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x8B, 0x75, 0x98, 0x68, 0x4B, 0x70, 0x68, 0x51,
	0x56, 0xFF, 0x15, 0x18, 0x12, 0x01, 0x00, 0xE9, 0x80, 0x04, 0x00, 0x00, 0xC7, 0x45, 0xA8, 0x9A,
	0x00, 0x00, 0xC0, 0xE9, 0x74, 0x04, 0x00, 0x00, 0x8D, 0x85, 0x78, 0xFF, 0xFF, 0xFF, 0x50, 0x51,
	0xFF, 0x15, 0x64, 0x12, 0x01, 0x00, 0x6A, 0x00, 0x6A, 0x02, 0x8D, 0x45, 0xA4, 0x50, 0x6A, 0x04,
	0x5E, 0x56, 0x57, 0xFF, 0x15, 0x94, 0x12, 0x01, 0x00, 0x89, 0x45, 0xA8, 0x8D, 0x85, 0x78, 0xFF,
	0xFF, 0xFF, 0x50, 0xFF, 0x15, 0x5C, 0x12, 0x01, 0x00, 0x83, 0x7D, 0xA8, 0x00, 0x7C, 0x42, 0x83,
	0x7D, 0x18, 0x02, 0x75, 0x35, 0x89, 0x75, 0xFC, 0x66, 0x8B, 0x45, 0xA4, 0x8B, 0x4D, 0x9C, 0x66,
	0x89, 0x01, 0xEB, 0x1D, 0x8B, 0x45, 0xEC, 0x8B, 0x00, 0x8B, 0x00, 0x89, 0x85, 0x68, 0xFF, 0xFF,
	0xFF, 0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x65, 0xE8, 0x8B, 0x85, 0x68, 0xFF, 0xFF, 0xFF, 0x89, 0x45,
	0xA8, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xEB, 0x07, 0xC7, 0x45, 0xA8, 0x04, 0x00, 0x00,
	0xC0, 0xC7, 0x45, 0xA0, 0x02, 0x00, 0x00, 0x00, 0xE9, 0xEF, 0x03, 0x00, 0x00, 0x8D, 0x85, 0x78,
	0xFF, 0xFF, 0xFF, 0x50, 0x51, 0xFF, 0x15, 0x64, 0x12, 0x01, 0x00, 0x33, 0xF6, 0x56, 0x6A, 0x18,
	0x8D, 0x45, 0xCC, 0x50, 0x56, 0x57, 0xFF, 0x15, 0x8C, 0x12, 0x01, 0x00, 0x89, 0x45, 0xA8, 0x8D,
	0x85, 0x78, 0xFF, 0xFF, 0xFF, 0x50, 0xFF, 0x15, 0x5C, 0x12, 0x01, 0x00, 0x39, 0x75, 0xA8, 0x7C,
	0x47, 0x83, 0x7D, 0x18, 0x18, 0x75, 0x3A, 0xC7, 0x45, 0xFC, 0x05, 0x00, 0x00, 0x00, 0x6A, 0x06,
	0x59, 0x8D, 0x75, 0xCC, 0x8B, 0x7D, 0x9C, 0xF3, 0xA5, 0xEB, 0x1D, 0x8B, 0x45, 0xEC, 0x8B, 0x00,
	0x8B, 0x00, 0x89, 0x85, 0x58, 0xFF, 0xFF, 0xFF, 0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x65, 0xE8, 0x8B,
	0x85, 0x58, 0xFF, 0xFF, 0xFF, 0x89, 0x45, 0xA8, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xEB,
	0x07, 0xC7, 0x45, 0xA8, 0x04, 0x00, 0x00, 0xC0, 0xC7, 0x45, 0xA0, 0x18, 0x00, 0x00, 0x00, 0xE9,
	0x68, 0x03, 0x00, 0x00, 0x8D, 0x85, 0x78, 0xFF, 0xFF, 0xFF, 0x50, 0x51, 0xFF, 0x15, 0x64, 0x12,
	0x01, 0x00, 0x33, 0xF6, 0x56, 0x6A, 0x1C, 0x8D, 0x45, 0xC8, 0x50, 0x56, 0x57, 0xFF, 0x15, 0x88,
	0x12, 0x01, 0x00, 0x89, 0x45, 0xA8, 0x8D, 0x85, 0x78, 0xFF, 0xFF, 0xFF, 0x50, 0xFF, 0x15, 0x5C,
	0x12, 0x01, 0x00, 0x39, 0x75, 0xA8, 0x7C, 0x47, 0x83, 0x7D, 0x18, 0x1C, 0x75, 0x3A, 0xC7, 0x45,
	0xFC, 0x06, 0x00, 0x00, 0x00, 0x6A, 0x07, 0x59, 0x8D, 0x75, 0xC8, 0x8B, 0x7D, 0x9C, 0xF3, 0xA5,
	0xEB, 0x1D, 0x8B, 0x45, 0xEC, 0x8B, 0x00, 0x8B, 0x00, 0x89, 0x85, 0x60, 0xFF, 0xFF, 0xFF, 0x33,
	0xC0, 0x40, 0xC3, 0x8B, 0x65, 0xE8, 0x8B, 0x85, 0x60, 0xFF, 0xFF, 0xFF, 0x89, 0x45, 0xA8, 0xC7,
	0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xEB, 0x07, 0xC7, 0x45, 0xA8, 0x04, 0x00, 0x00, 0xC0, 0xC7,
	0x45, 0xA0, 0x1C, 0x00, 0x00, 0x00, 0xE9, 0xE1, 0x02, 0x00, 0x00, 0x83, 0x3D, 0x00, 0x19, 0x01,
	0x00, 0xFF, 0x0F, 0x84, 0x18, 0x01, 0x00, 0x00, 0x83, 0x3D, 0x0C, 0x19, 0x01, 0x00, 0xFF, 0x0F,
	0x84, 0x0B, 0x01, 0x00, 0x00, 0x83, 0x3D, 0x14, 0x19, 0x01, 0x00, 0xFF, 0x0F, 0x84, 0xFE, 0x00,
	0x00, 0x00, 0x8D, 0x85, 0x78, 0xFF, 0xFF, 0xFF, 0x50, 0x51, 0xFF, 0x15, 0x64, 0x12, 0x01, 0x00,
	0x33, 0xDB, 0x53, 0x8D, 0x45, 0xA4, 0x50, 0xFF, 0x75, 0xA8, 0x53, 0x53, 0x57, 0xFF, 0xD6, 0x89,
	0x45, 0xA8, 0x8D, 0x85, 0x78, 0xFF, 0xFF, 0xFF, 0x50, 0xFF, 0x15, 0x5C, 0x12, 0x01, 0x00, 0x39,
	0x5D, 0xA8, 0x0F, 0x8C, 0xCF, 0x00, 0x00, 0x00, 0xFF, 0x75, 0xA4, 0xE8, 0x48, 0xF1, 0xFF, 0xFF,
	0x3B, 0xC3, 0x74, 0x31, 0x8B, 0x0D, 0x14, 0x19, 0x01, 0x00, 0x8D, 0x34, 0x01, 0x68, 0x30, 0x57,
	0x01, 0x00, 0x8D, 0x45, 0x94, 0x50, 0xFF, 0x15, 0x24, 0x12, 0x01, 0x00, 0x53, 0x8D, 0x45, 0x94,
	0x50, 0x56, 0xFF, 0x15, 0x84, 0x12, 0x01, 0x00, 0x84, 0xC0, 0x75, 0x10, 0xC7, 0x45, 0xA8, 0x24,
	0x00, 0x00, 0xC0, 0xEB, 0x07, 0xC7, 0x45, 0xA8, 0xBB, 0x00, 0x00, 0xC0, 0x39, 0x5D, 0xA8, 0x7C,
	0x74, 0xA1, 0x0C, 0x19, 0x01, 0x00, 0x8B, 0x4D, 0xA4, 0x8B, 0x04, 0x08, 0x3B, 0xC3, 0x74, 0x12,
	0x8B, 0x0D, 0x00, 0x19, 0x01, 0x00, 0x8D, 0x34, 0x01, 0x8D, 0x7D, 0xD0, 0xA5, 0xA5, 0xA5, 0xA5,
	0xEB, 0x09, 0x33, 0xC0, 0x8D, 0x7D, 0xD0, 0xAB, 0xAB, 0xAB, 0xAB, 0x89, 0x5D, 0xE0, 0x83, 0x7D,
	0x18, 0x14, 0x75, 0x3A, 0xC7, 0x45, 0xFC, 0x07, 0x00, 0x00, 0x00, 0x6A, 0x05, 0x59, 0x8D, 0x75,
	0xD0, 0x8B, 0x7D, 0x9C, 0xF3, 0xA5, 0xEB, 0x1D, 0x8B, 0x45, 0xEC, 0x8B, 0x00, 0x8B, 0x00, 0x89,
	0x85, 0x70, 0xFF, 0xFF, 0xFF, 0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x65, 0xE8, 0x8B, 0x85, 0x70, 0xFF,
	0xFF, 0xFF, 0x89, 0x45, 0xA8, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xEB, 0x07, 0xC7, 0x45,
	0xA8, 0x04, 0x00, 0x00, 0xC0, 0x8B, 0x4D, 0xA4, 0xFF, 0x15, 0x4C, 0x12, 0x01, 0x00, 0xEB, 0x07,
	0xC7, 0x45, 0xA8, 0xBB, 0x00, 0x00, 0xC0, 0xC7, 0x45, 0xA0, 0x14, 0x00, 0x00, 0x00, 0xE9, 0xA9,
	0x01, 0x00, 0x00, 0x8D, 0x85, 0x78, 0xFF, 0xFF, 0xFF, 0x50, 0x51, 0xFF, 0x15, 0x64, 0x12, 0x01,
	0x00, 0x6A, 0x00, 0x8D, 0x45, 0xA4, 0x50, 0xFF, 0x75, 0xA8, 0xA1, 0x7C, 0x12, 0x01, 0x00, 0xFF,
	0x30, 0x6A, 0x00, 0x57, 0xFF, 0xD6, 0x89, 0x45, 0xA8, 0x8D, 0x85, 0x78, 0xFF, 0xFF, 0xFF, 0x50,
	0xFF, 0x15, 0x5C, 0x12, 0x01, 0x00, 0x83, 0x7D, 0xA8, 0x00, 0x0F, 0x8C, 0xF8, 0xFD, 0xFF, 0xFF,
	0x8B, 0x45, 0xA4, 0x8A, 0x48, 0x24, 0x88, 0x4D, 0xCC, 0x8A, 0x48, 0x25, 0x88, 0x4D, 0xCD, 0x8A,
	0x48, 0x26, 0x88, 0x4D, 0xCE, 0x8A, 0x48, 0x27, 0x88, 0x4D, 0xCF, 0x8A, 0x48, 0x28, 0x88, 0x4D,
	0xD0, 0x8A, 0x48, 0x29, 0x88, 0x4D, 0xD1, 0x8A, 0x48, 0x2A, 0x88, 0x4D, 0xD2, 0x8A, 0x48, 0x2B,
	0x88, 0x4D, 0xD3, 0x8B, 0x48, 0x38, 0x89, 0x4D, 0xD4, 0x8B, 0x48, 0x3C, 0x89, 0x4D, 0xD8, 0x8B,
	0x48, 0x2C, 0x89, 0x4D, 0xDC, 0x83, 0x7D, 0x18, 0x18, 0x75, 0x40, 0x89, 0x5D, 0xFC, 0x6A, 0x06,
	0x59, 0x8D, 0x75, 0xCC, 0x8B, 0x7D, 0x9C, 0xF3, 0xA5, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF,
	0xEB, 0x30, 0x8B, 0x45, 0xEC, 0x8B, 0x00, 0x8B, 0x00, 0x89, 0x85, 0x6C, 0xFF, 0xFF, 0xFF, 0x33,
	0xC0, 0x40, 0xC3, 0x8B, 0x65, 0xE8, 0x8B, 0x85, 0x6C, 0xFF, 0xFF, 0xFF, 0x89, 0x45, 0xA8, 0xC7,
	0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x8B, 0x45, 0xA4, 0xEB, 0x07, 0xC7, 0x45, 0xA8, 0x04, 0x00,
	0x00, 0xC0, 0x8B, 0xC8, 0xFF, 0x15, 0x4C, 0x12, 0x01, 0x00, 0xE9, 0x59, 0xFD, 0xFF, 0xFF, 0x83,
	0x7D, 0x18, 0x04, 0x0F, 0x85, 0xAF, 0x00, 0x00, 0x00, 0x8D, 0x85, 0x78, 0xFF, 0xFF, 0xFF, 0x50,
	0x51, 0xFF, 0x15, 0x64, 0x12, 0x01, 0x00, 0x33, 0xDB, 0x53, 0x8D, 0x45, 0x98, 0x50, 0xFF, 0x75,
	0xA8, 0xA1, 0x7C, 0x12, 0x01, 0x00, 0xFF, 0x30, 0x53, 0x57, 0xFF, 0xD6, 0x89, 0x45, 0xA8, 0x8D,
	0x85, 0x78, 0xFF, 0xFF, 0xFF, 0x50, 0xFF, 0x15, 0x5C, 0x12, 0x01, 0x00, 0x39, 0x5D, 0xA8, 0x0F,
	0x8C, 0x87, 0x00, 0x00, 0x00, 0x8B, 0x45, 0x98, 0x39, 0x58, 0x04, 0x74, 0x26, 0x8B, 0x40, 0x04,
	0x8B, 0x40, 0x08, 0x3B, 0xC3, 0x74, 0x1C, 0x8D, 0x4D, 0xA4, 0x51, 0x53, 0x8B, 0x0D, 0x80, 0x12,
	0x01, 0x00, 0xFF, 0x31, 0x53, 0x53, 0x53, 0x50, 0xFF, 0x15, 0x6C, 0x12, 0x01, 0x00, 0x89, 0x45,
	0xA8, 0xEB, 0x03, 0x89, 0x5D, 0xA4, 0x39, 0x5D, 0xA8, 0x7C, 0x35, 0xC7, 0x45, 0xFC, 0x09, 0x00,
	0x00, 0x00, 0x8B, 0x45, 0x9C, 0x8B, 0x4D, 0xA4, 0x89, 0x08, 0xEB, 0x1D, 0x8B, 0x45, 0xEC, 0x8B,
	0x00, 0x8B, 0x00, 0x89, 0x85, 0x64, 0xFF, 0xFF, 0xFF, 0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x65, 0xE8,
	0x8B, 0x85, 0x64, 0xFF, 0xFF, 0xFF, 0x89, 0x45, 0xA8, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF,
	0x8B, 0x4D, 0x98, 0xE9, 0xB2, 0xFA, 0xFF, 0xFF, 0xC7, 0x45, 0xA8, 0x04, 0x00, 0x00, 0xC0, 0xEB,
	0x0B, 0xC7, 0x45, 0xA8, 0x03, 0x00, 0x00, 0xC0, 0x83, 0x65, 0xA0, 0x00, 0x8B, 0x4D, 0x90, 0xFF,
	0x15, 0x4C, 0x12, 0x01, 0x00, 0x8B, 0x85, 0x5C, 0xFF, 0xFF, 0xFF, 0x85, 0xC0, 0x74, 0x29, 0x80,
	0x7D, 0x20, 0x00, 0x74, 0x1E, 0xC7, 0x45, 0xFC, 0x0A, 0x00, 0x00, 0x00, 0x8B, 0x4D, 0xA0, 0x89,
	0x08, 0xEB, 0x07, 0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x65, 0xE8, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF,
	0xFF, 0xEB, 0x05, 0x8B, 0x4D, 0xA0, 0x89, 0x08, 0x8B, 0x45, 0xA8, 0xE8, 0x64, 0xD9, 0xFF, 0xFF,
	0xC2, 0x1C, 0x00, 0x90, 0xE7, 0x2F, 0x01, 0x00, 0x6E, 0x30, 0x01, 0x00, 0x65, 0x31, 0x01, 0x00,
	0x48, 0x32, 0x01, 0x00, 0xCD, 0x32, 0x01, 0x00, 0x54, 0x33, 0x01, 0x00, 0xDB, 0x33, 0x01, 0x00,
	0x13, 0x35, 0x01, 0x00, 0xEF, 0x35, 0x01, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x6A, 0x20,
	0x68, 0xE8, 0x15, 0x01, 0x00, 0xE8, 0x1A, 0xD7, 0xFF, 0xFF, 0x33, 0xDB, 0x38, 0x5D, 0x14, 0x74,
	0x53, 0x89, 0x5D, 0xFC, 0x6A, 0x04, 0x6A, 0x04, 0x8B, 0x7D, 0x08, 0x57, 0xFF, 0x15, 0x2C, 0x12,
	0x01, 0x00, 0x6A, 0x04, 0x6A, 0x08, 0x8B, 0x75, 0x10, 0x56, 0xFF, 0x15, 0x38, 0x12, 0x01, 0x00,
	0x8B, 0x0E, 0x89, 0x4D, 0xD0, 0x8B, 0x76, 0x04, 0x89, 0x75, 0xD4, 0xC7, 0x45, 0xFC, 0xFE, 0xFF,
	0xFF, 0xFF, 0xEB, 0x31, 0x8B, 0x45, 0xEC, 0x8B, 0x00, 0x8B, 0x00, 0x89, 0x45, 0xE0, 0x33, 0xC0,
	0x40, 0xC3, 0x8B, 0x65, 0xE8, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x8B, 0x45, 0xE0, 0xE9,
	0xA9, 0x00, 0x00, 0x00, 0x8B, 0x45, 0x10, 0x8B, 0x08, 0x89, 0x4D, 0xD0, 0x8B, 0x70, 0x04, 0x89,
	0x75, 0xD4, 0x8B, 0x7D, 0x08, 0x3B, 0xF3, 0x74, 0x23, 0x8D, 0x45, 0xDC, 0x50, 0x8D, 0x45, 0x08,
	0x50, 0x8D, 0x45, 0xD0, 0x50, 0xFF, 0x15, 0xA0, 0x12, 0x01, 0x00, 0x8B, 0xF0, 0x3B, 0xF3, 0x7C,
	0x7A, 0x8B, 0x4D, 0xDC, 0xFF, 0x15, 0x4C, 0x12, 0x01, 0x00, 0xEB, 0x0D, 0x8D, 0x45, 0x08, 0x50,
	0x51, 0xFF, 0x15, 0x9C, 0x12, 0x01, 0x00, 0x8B, 0xF0, 0x3B, 0xF3, 0x7C, 0x5E, 0x8D, 0x45, 0xE4,
	0x50, 0x53, 0xA1, 0x54, 0x12, 0x01, 0x00, 0xFF, 0x30, 0xFF, 0x75, 0x0C, 0x53, 0x53, 0xFF, 0x75,
	0x08, 0xFF, 0x15, 0x6C, 0x12, 0x01, 0x00, 0x8B, 0xF0, 0x8B, 0x4D, 0x08, 0xFF, 0x15, 0x4C, 0x12,
	0x01, 0x00, 0x3B, 0xF3, 0x7C, 0x35, 0x38, 0x5D, 0x14, 0x74, 0x2B, 0xC7, 0x45, 0xFC, 0x01, 0x00,
	0x00, 0x00, 0x8B, 0x45, 0xE4, 0x89, 0x07, 0xEB, 0x14, 0x8B, 0x45, 0xEC, 0x8B, 0x00, 0x8B, 0x00,
	0x89, 0x45, 0xD8, 0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x65, 0xE8, 0x8B, 0x75, 0xD8, 0xC7, 0x45, 0xFC,
	0xFE, 0xFF, 0xFF, 0xFF, 0xEB, 0x05, 0x8B, 0x45, 0xE4, 0x89, 0x07, 0x8B, 0xC6, 0xE8, 0x57, 0xD6,
	0xFF, 0xFF, 0xC2, 0x10, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x6A, 0x18, 0x68, 0x10, 0x16, 0x01,
	0x00, 0xE8, 0xFE, 0xD5, 0xFF, 0xFF, 0x33, 0xDB, 0x38, 0x5D, 0x14, 0x74, 0x17, 0x89, 0x5D, 0xFC,
	0x6A, 0x04, 0x6A, 0x04, 0xFF, 0x75, 0x10, 0xFF, 0x15, 0x2C, 0x12, 0x01, 0x00, 0xC7, 0x45, 0xFC,
	0xFE, 0xFF, 0xFF, 0xFF, 0x53, 0x8D, 0x45, 0xE4, 0x50, 0xFF, 0x75, 0x14, 0xA1, 0x54, 0x12, 0x01,
	0x00, 0xFF, 0x30, 0x53, 0xFF, 0x75, 0x08, 0xFF, 0x15, 0x50, 0x12, 0x01, 0x00, 0x3B, 0xC3, 0x0F,
	0x8C, 0x93, 0x00, 0x00, 0x00, 0xFF, 0x75, 0xE4, 0xFF, 0x15, 0xAC, 0x12, 0x01, 0x00, 0x8B, 0xF0,
	0x8D, 0x45, 0xE0, 0x50, 0x53, 0xA1, 0xA8, 0x12, 0x01, 0x00, 0xFF, 0x30, 0xFF, 0x75, 0x0C, 0x53,
	0x53, 0x56, 0xFF, 0x15, 0x6C, 0x12, 0x01, 0x00, 0x8B, 0xF8, 0x56, 0xFF, 0x15, 0xA4, 0x12, 0x01,
	0x00, 0x8B, 0x4D, 0xE4, 0xFF, 0x15, 0x4C, 0x12, 0x01, 0x00, 0x3B, 0xFB, 0x7C, 0x58, 0x38, 0x5D,
	0x14, 0x74, 0x4B, 0xC7, 0x45, 0xFC, 0x01, 0x00, 0x00, 0x00, 0x8B, 0x45, 0xE0, 0x8B, 0x4D, 0x10,
	0x89, 0x01, 0xEB, 0x31, 0x8B, 0x45, 0xEC, 0x8B, 0x00, 0x8B, 0x00, 0x89, 0x45, 0xDC, 0x33, 0xC0,
	0x40, 0xC3, 0x8B, 0x65, 0xE8, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x8B, 0x45, 0xDC, 0xEB,
	0x27, 0x8B, 0x45, 0xEC, 0x8B, 0x00, 0x8B, 0x00, 0x89, 0x45, 0xD8, 0x33, 0xC0, 0x40, 0xC3, 0x8B,
	0x65, 0xE8, 0x8B, 0x7D, 0xD8, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xEB, 0x08, 0x8B, 0x45,
	0xE0, 0x8B, 0x4D, 0x10, 0x89, 0x01, 0x8B, 0xC7, 0xE8, 0x6C, 0xD5, 0xFF, 0xFF, 0xC2, 0x10, 0x00,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x6A, 0x14, 0x68, 0x38, 0x16, 0x01, 0x00, 0xE8, 0x12, 0xD5,
	0xFF, 0xFF, 0x33, 0xDB, 0x89, 0x5D, 0xE4, 0x38, 0x5D, 0x14, 0x74, 0x3A, 0x89, 0x5D, 0xFC, 0x6A,
	0x04, 0x6A, 0x04, 0x8B, 0x7D, 0x10, 0x57, 0xFF, 0x15, 0x2C, 0x12, 0x01, 0x00, 0xC7, 0x45, 0xFC,
	0xFE, 0xFF, 0xFF, 0xFF, 0xEB, 0x23, 0x8B, 0x45, 0xEC, 0x8B, 0x00, 0x8B, 0x00, 0x89, 0x45, 0xE0,
	0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x65, 0xE8, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x8B, 0x45,
	0xE0, 0xE9, 0x93, 0x00, 0x00, 0x00, 0x8B, 0x7D, 0x10, 0x53, 0x8D, 0x45, 0x10, 0x50, 0xFF, 0x75,
	0x14, 0xA1, 0x54, 0x12, 0x01, 0x00, 0xFF, 0x30, 0x53, 0xFF, 0x75, 0x08, 0xFF, 0x15, 0x50, 0x12,
	0x01, 0x00, 0x3B, 0xC3, 0x7C, 0x73, 0xFF, 0x75, 0x10, 0xFF, 0x15, 0xB4, 0x12, 0x01, 0x00, 0x3B,
	0xC3, 0x74, 0x1D, 0x8D, 0x4D, 0xE4, 0x51, 0x53, 0x8B, 0x0D, 0xB0, 0x12, 0x01, 0x00, 0xFF, 0x31,
	0xFF, 0x75, 0x0C, 0x53, 0x53, 0x50, 0xFF, 0x15, 0x6C, 0x12, 0x01, 0x00, 0x8B, 0xF0, 0xEB, 0x05,
	0xBE, 0x25, 0x02, 0x00, 0xC0, 0x8B, 0x4D, 0x10, 0xFF, 0x15, 0x4C, 0x12, 0x01, 0x00, 0x3B, 0xF3,
	0x7C, 0x35, 0x38, 0x5D, 0x14, 0x74, 0x2B, 0xC7, 0x45, 0xFC, 0x01, 0x00, 0x00, 0x00, 0x8B, 0x45,
	0xE4, 0x89, 0x07, 0xEB, 0x14, 0x8B, 0x45, 0xEC, 0x8B, 0x00, 0x8B, 0x00, 0x89, 0x45, 0xDC, 0x33,
	0xC0, 0x40, 0xC3, 0x8B, 0x65, 0xE8, 0x8B, 0x75, 0xDC, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF,
	0xEB, 0x05, 0x8B, 0x45, 0xE4, 0x89, 0x07, 0x8B, 0xC6, 0xE8, 0x7B, 0xD4, 0xFF, 0xFF, 0xC2, 0x10,
	0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x56, 0x33, 0xF6, 0x39, 0x35,
	0x34, 0x1A, 0x01, 0x00, 0x75, 0x07, 0xB8, 0xBB, 0x00, 0x00, 0xC0, 0xEB, 0x33, 0x56, 0x8D, 0x45,
	0x0C, 0x50, 0xFF, 0x75, 0x0C, 0xA1, 0x54, 0x12, 0x01, 0x00, 0xFF, 0x30, 0x56, 0xFF, 0x75, 0x08,
	0xFF, 0x15, 0x50, 0x12, 0x01, 0x00, 0x3B, 0xC6, 0x7C, 0x16, 0xFF, 0x75, 0x0C, 0xFF, 0x15, 0x34,
	0x1A, 0x01, 0x00, 0x8B, 0x4D, 0x0C, 0x8B, 0xF0, 0xFF, 0x15, 0x4C, 0x12, 0x01, 0x00, 0x8B, 0xC6,
	0x5E, 0x5D, 0xC2, 0x08, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x56,
	0x33, 0xF6, 0x39, 0x35, 0x24, 0x1A, 0x01, 0x00, 0x75, 0x07, 0xB8, 0xBB, 0x00, 0x00, 0xC0, 0xEB,
	0x33, 0x56, 0x8D, 0x45, 0x0C, 0x50, 0xFF, 0x75, 0x0C, 0xA1, 0x54, 0x12, 0x01, 0x00, 0xFF, 0x30,
	0x56, 0xFF, 0x75, 0x08, 0xFF, 0x15, 0x50, 0x12, 0x01, 0x00, 0x3B, 0xC6, 0x7C, 0x16, 0xFF, 0x75,
	0x0C, 0xFF, 0x15, 0x24, 0x1A, 0x01, 0x00, 0x8B, 0x4D, 0x0C, 0x8B, 0xF0, 0xFF, 0x15, 0x4C, 0x12,
	0x01, 0x00, 0x8B, 0xC6, 0x5E, 0x5D, 0xC2, 0x08, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x8B, 0xFF,
	0x55, 0x8B, 0xEC, 0x51, 0x51, 0x83, 0x3D, 0xAC, 0x1B, 0x01, 0x00, 0x00, 0x74, 0x07, 0xB8, 0xBB,
	0x00, 0x00, 0xC0, 0xEB, 0x5B, 0x68, 0x60, 0x1A, 0x01, 0x00, 0xE8, 0x61, 0xD0, 0xFF, 0xFF, 0x89,
	0x45, 0xF8, 0x85, 0xC0, 0x74, 0xE8, 0x8B, 0x0D, 0x7C, 0x1A, 0x01, 0x00, 0x83, 0xF9, 0x33, 0x74,
	0x31, 0x83, 0xF9, 0x34, 0x74, 0x2C, 0x83, 0xF9, 0x3E, 0x74, 0x27, 0x83, 0xF9, 0x3C, 0x74, 0x14,
	0x83, 0xF9, 0x3D, 0x74, 0x0F, 0x83, 0xF9, 0x3F, 0x75, 0xC4, 0x8B, 0x55, 0x0C, 0x8B, 0x4D, 0x08,
	0xFF, 0xD0, 0xEB, 0x16, 0xFF, 0x75, 0x0C, 0x8B, 0x4D, 0x08, 0xFF, 0x55, 0xF8, 0x89, 0x45, 0xFC,
	0xEB, 0x0B, 0xFF, 0x75, 0x0C, 0xFF, 0x75, 0x08, 0xFF, 0xD0, 0x89, 0x45, 0xFC, 0x8B, 0x45, 0xFC,
	0xC9, 0xC2, 0x08, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x6A,
	0x00, 0x8D, 0x45, 0x10, 0x50, 0xFF, 0x75, 0x10, 0xA1, 0x54, 0x12, 0x01, 0x00, 0xFF, 0x30, 0x6A,
	0x00, 0xFF, 0x75, 0x08, 0xFF, 0x15, 0x50, 0x12, 0x01, 0x00, 0x85, 0xC0, 0x7C, 0x70, 0x56, 0xFF,
	0x15, 0x74, 0x12, 0x01, 0x00, 0x39, 0x45, 0x10, 0x74, 0x53, 0xFF, 0x75, 0x0C, 0xFF, 0x75, 0x10,
	0xE8, 0x49, 0xFF, 0xFF, 0xFF, 0x8B, 0xF0, 0x81, 0xFE, 0xBB, 0x00, 0x00, 0xC0, 0x75, 0x43, 0x8D,
	0x45, 0x08, 0x50, 0xA1, 0x54, 0x12, 0x01, 0x00, 0x6A, 0x00, 0xFF, 0x30, 0x6A, 0x01, 0x6A, 0x00,
	0x68, 0x00, 0x02, 0x00, 0x00, 0xFF, 0x75, 0x10, 0xFF, 0x15, 0x6C, 0x12, 0x01, 0x00, 0x8B, 0xF0,
	0x85, 0xF6, 0x7C, 0x1E, 0xFF, 0x75, 0x0C, 0xFF, 0x75, 0x08, 0xFF, 0x15, 0xB8, 0x12, 0x01, 0x00,
	0xFF, 0x75, 0x08, 0x8B, 0xF0, 0xFF, 0x15, 0x14, 0x12, 0x01, 0x00, 0xEB, 0x05, 0xBE, 0xDB, 0x00,
	0x00, 0xC0, 0x8B, 0x4D, 0x10, 0xFF, 0x15, 0x4C, 0x12, 0x01, 0x00, 0x8B, 0xC6, 0x5E, 0x5D, 0xC2,
	0x0C, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x6A, 0x34, 0x68, 0x60, 0x16, 0x01, 0x00, 0xE8,
	0x60, 0xD2, 0xFF, 0xFF, 0x80, 0x7D, 0x1C, 0x00, 0x74, 0x59, 0x8B, 0x45, 0x0C, 0x48, 0x74, 0x05,
	0x6A, 0x04, 0x58, 0xEB, 0x03, 0x33, 0xC0, 0x40, 0x83, 0x65, 0xFC, 0x00, 0x50, 0xFF, 0x75, 0x14,
	0x8B, 0x5D, 0x10, 0x53, 0x8B, 0x35, 0x2C, 0x12, 0x01, 0x00, 0xFF, 0xD6, 0x83, 0x7D, 0x18, 0x00,
	0x74, 0x09, 0x6A, 0x04, 0x6A, 0x04, 0xFF, 0x75, 0x18, 0xFF, 0xD6, 0x6A, 0xFE, 0x5F, 0x89, 0x7D,
	0xFC, 0xEB, 0x26, 0x8B, 0x45, 0xEC, 0x8B, 0x00, 0x8B, 0x00, 0x89, 0x45, 0xE0, 0x33, 0xC0, 0x40,
	0xC3, 0x8B, 0x65, 0xE8, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x8B, 0x45, 0xE0, 0xE9, 0xD4,
	0x01, 0x00, 0x00, 0x6A, 0xFE, 0x5F, 0x8B, 0x5D, 0x10, 0x33, 0xF6, 0x56, 0x8D, 0x45, 0xE4, 0x50,
	0xFF, 0x75, 0x1C, 0xA1, 0x54, 0x12, 0x01, 0x00, 0xFF, 0x30, 0x56, 0xFF, 0x75, 0x08, 0xFF, 0x15,
	0x50, 0x12, 0x01, 0x00, 0x89, 0x45, 0x10, 0x3B, 0xC6, 0x0F, 0x8C, 0xA5, 0x01, 0x00, 0x00, 0x8B,
	0x45, 0x0C, 0x48, 0x0F, 0x84, 0x0E, 0x01, 0x00, 0x00, 0x48, 0x0F, 0x84, 0x98, 0x00, 0x00, 0x00,
	0x48, 0x74, 0x0C, 0xC7, 0x45, 0x10, 0x03, 0x00, 0x00, 0xC0, 0xE9, 0x4F, 0x01, 0x00, 0x00, 0x8D,
	0x45, 0x0C, 0x50, 0x56, 0xA1, 0x54, 0x12, 0x01, 0x00, 0xFF, 0x30, 0x68, 0x00, 0x04, 0x00, 0x00,
	0x56, 0x68, 0x00, 0x02, 0x00, 0x00, 0xFF, 0x75, 0xE4, 0xFF, 0x15, 0x6C, 0x12, 0x01, 0x00, 0x89,
	0x45, 0x10, 0x3B, 0xC6, 0x0F, 0x8C, 0xC8, 0x00, 0x00, 0x00, 0x56, 0x6A, 0x04, 0x8D, 0x45, 0x08,
	0x50, 0x6A, 0x21, 0xFF, 0x75, 0x0C, 0xFF, 0x15, 0x8C, 0x12, 0x01, 0x00, 0x89, 0x45, 0x10, 0x3B,
	0xC6, 0x7C, 0x3A, 0x83, 0x7D, 0x14, 0x04, 0x75, 0x2D, 0xC7, 0x45, 0xFC, 0x03, 0x00, 0x00, 0x00,
	0x8B, 0x45, 0x08, 0x89, 0x03, 0xEB, 0x1A, 0x8B, 0x45, 0xEC, 0x8B, 0x00, 0x8B, 0x00, 0x89, 0x45,
	0xDC, 0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x65, 0xE8, 0x8B, 0x45, 0xDC, 0x89, 0x45, 0x10, 0x6A, 0xFE,
	0x5F, 0x89, 0x7D, 0xFC, 0xEB, 0x07, 0xC7, 0x45, 0x10, 0x04, 0x00, 0x00, 0xC0, 0xFF, 0x75, 0x0C,
	0xFF, 0x15, 0x14, 0x12, 0x01, 0x00, 0xEB, 0x6A, 0x8D, 0x45, 0xBC, 0x50, 0xFF, 0x75, 0xE4, 0xFF,
	0x15, 0x64, 0x12, 0x01, 0x00, 0x56, 0x6A, 0x04, 0x8D, 0x45, 0x0C, 0x50, 0x6A, 0x22, 0x6A, 0xFF,
	0xFF, 0x15, 0x8C, 0x12, 0x01, 0x00, 0x89, 0x45, 0x10, 0x8D, 0x45, 0xBC, 0x50, 0xFF, 0x15, 0x5C,
	0x12, 0x01, 0x00, 0x39, 0x75, 0x10, 0x7C, 0x3A, 0x83, 0x7D, 0x14, 0x04, 0x75, 0x2D, 0xC7, 0x45,
	0xFC, 0x02, 0x00, 0x00, 0x00, 0x8B, 0x45, 0x0C, 0x89, 0x03, 0xEB, 0x1A, 0x8B, 0x45, 0xEC, 0x8B,
	0x00, 0x8B, 0x00, 0x89, 0x45, 0xD8, 0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x65, 0xE8, 0x8B, 0x45, 0xD8,
	0x89, 0x45, 0x10, 0x6A, 0xFE, 0x5F, 0x89, 0x7D, 0xFC, 0xEB, 0x07, 0xC7, 0x45, 0x10, 0x04, 0x00,
	0x00, 0xC0, 0x6A, 0x04, 0x5E, 0xEB, 0x57, 0x32, 0xC0, 0x8B, 0x0D, 0x2C, 0x1A, 0x01, 0x00, 0x3B,
	0xCE, 0x74, 0x07, 0xFF, 0x75, 0xE4, 0xFF, 0xD1, 0xEB, 0x07, 0xC7, 0x45, 0x10, 0xBB, 0x00, 0x00,
	0xC0, 0x39, 0x75, 0x10, 0x7C, 0x35, 0x33, 0xC9, 0x41, 0x39, 0x4D, 0x14, 0x75, 0x26, 0x89, 0x4D,
	0xFC, 0x88, 0x03, 0xEB, 0x1A, 0x8B, 0x45, 0xEC, 0x8B, 0x00, 0x8B, 0x00, 0x89, 0x45, 0xD4, 0x33,
	0xC0, 0x40, 0xC3, 0x8B, 0x65, 0xE8, 0x8B, 0x45, 0xD4, 0x89, 0x45, 0x10, 0x6A, 0xFE, 0x5F, 0x89,
	0x7D, 0xFC, 0xEB, 0x07, 0xC7, 0x45, 0x10, 0x04, 0x00, 0x00, 0xC0, 0x33, 0xF6, 0x46, 0x8B, 0x4D,
	0xE4, 0xFF, 0x15, 0x4C, 0x12, 0x01, 0x00, 0x8B, 0x45, 0x18, 0x85, 0xC0, 0x74, 0x26, 0x80, 0x7D,
	0x1C, 0x00, 0x74, 0x1E, 0xC7, 0x45, 0xFC, 0x04, 0x00, 0x00, 0x00, 0x89, 0x30, 0x89, 0x7D, 0xFC,
	0xEB, 0x12, 0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x65, 0xE8, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF,
	0xEB, 0x02, 0x89, 0x30, 0x8B, 0x45, 0x10, 0xE8, 0x6D, 0xD0, 0xFF, 0xFF, 0xC2, 0x18, 0x00, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0x6A, 0x2C, 0x68, 0xB0, 0x16, 0x01, 0x00, 0xE8, 0x14, 0xD0, 0xFF, 0xFF,
	0x80, 0x7D, 0x18, 0x00, 0x74, 0x3B, 0x83, 0x65, 0xFC, 0x00, 0x6A, 0x04, 0xFF, 0x75, 0x14, 0x8B,
	0x7D, 0x10, 0x57, 0xFF, 0x15, 0x38, 0x12, 0x01, 0x00, 0x6A, 0xFE, 0x5B, 0x89, 0x5D, 0xFC, 0xEB,
	0x26, 0x8B, 0x45, 0xEC, 0x8B, 0x00, 0x8B, 0x00, 0x89, 0x45, 0xE4, 0x33, 0xC0, 0x40, 0xC3, 0x8B,
	0x65, 0xE8, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x8B, 0x45, 0xE4, 0xE9, 0x59, 0x01, 0x00,
	0x00, 0x6A, 0xFE, 0x5B, 0x8B, 0x7D, 0x10, 0x6A, 0x00, 0x8D, 0x45, 0x10, 0x50, 0xFF, 0x75, 0x18,
	0xA1, 0x54, 0x12, 0x01, 0x00, 0xFF, 0x30, 0x6A, 0x00, 0xFF, 0x75, 0x08, 0xFF, 0x15, 0x50, 0x12,
	0x01, 0x00, 0x8B, 0xF0, 0x85, 0xF6, 0x0F, 0x8C, 0x2C, 0x01, 0x00, 0x00, 0x8B, 0x45, 0x0C, 0x6A,
	0x02, 0x59, 0x2B, 0xC1, 0x0F, 0x84, 0x94, 0x00, 0x00, 0x00, 0x48, 0x74, 0x0A, 0xBE, 0x03, 0x00,
	0x00, 0xC0, 0xE9, 0x08, 0x01, 0x00, 0x00, 0x83, 0x7D, 0x14, 0x04, 0x75, 0x2A, 0x89, 0x4D, 0xFC,
	0x8B, 0x07, 0x89, 0x45, 0x18, 0x89, 0x5D, 0xFC, 0xEB, 0x22, 0x8B, 0x45, 0xEC, 0x8B, 0x00, 0x8B,
	0x00, 0x89, 0x45, 0xE0, 0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x65, 0xE8, 0x8B, 0x75, 0xE0, 0xC7, 0x45,
	0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xEB, 0x05, 0xBE, 0x04, 0x00, 0x00, 0xC0, 0x85, 0xF6, 0x0F, 0x8C,
	0xCB, 0x00, 0x00, 0x00, 0x8D, 0x45, 0x14, 0x50, 0x6A, 0x00, 0xA1, 0x54, 0x12, 0x01, 0x00, 0xFF,
	0x30, 0xB8, 0x00, 0x02, 0x00, 0x00, 0x50, 0x6A, 0x00, 0x50, 0xFF, 0x75, 0x10, 0xFF, 0x15, 0x6C,
	0x12, 0x01, 0x00, 0x8B, 0xF0, 0x85, 0xF6, 0x0F, 0x8C, 0xA2, 0x00, 0x00, 0x00, 0x6A, 0x04, 0x8D,
	0x45, 0x18, 0x50, 0x6A, 0x21, 0xFF, 0x75, 0x14, 0xFF, 0x15, 0xC4, 0x12, 0x01, 0x00, 0x8B, 0xF0,
	0xFF, 0x75, 0x14, 0xFF, 0x15, 0x14, 0x12, 0x01, 0x00, 0xE9, 0x81, 0x00, 0x00, 0x00, 0x83, 0x7D,
	0x14, 0x04, 0x75, 0x2E, 0xC7, 0x45, 0xFC, 0x01, 0x00, 0x00, 0x00, 0x8B, 0x07, 0x89, 0x45, 0x14,
	0x89, 0x5D, 0xFC, 0xEB, 0x22, 0x8B, 0x45, 0xEC, 0x8B, 0x00, 0x8B, 0x00, 0x89, 0x45, 0xDC, 0x33,
	0xC0, 0x40, 0xC3, 0x8B, 0x65, 0xE8, 0x8B, 0x75, 0xDC, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF,
	0xEB, 0x05, 0xBE, 0x04, 0x00, 0x00, 0xC0, 0x85, 0xF6, 0x7C, 0x44, 0xFF, 0x75, 0x10, 0xE8, 0x23,
	0xCD, 0xFF, 0xFF, 0x84, 0xC0, 0x74, 0x33, 0x8D, 0x45, 0xC4, 0x50, 0xFF, 0x75, 0x10, 0xFF, 0x15,
	0x64, 0x12, 0x01, 0x00, 0x6A, 0x04, 0x8D, 0x45, 0x14, 0x50, 0x6A, 0x22, 0x6A, 0xFF, 0xFF, 0x15,
	0xC4, 0x12, 0x01, 0x00, 0x8B, 0xF0, 0x8D, 0x45, 0xC4, 0x50, 0xFF, 0x15, 0x5C, 0x12, 0x01, 0x00,
	0xFF, 0x75, 0x10, 0xE8, 0x38, 0xCD, 0xFF, 0xFF, 0xEB, 0x05, 0xBE, 0x0A, 0x01, 0x00, 0xC0, 0x8B,
	0x4D, 0x10, 0xFF, 0x15, 0x4C, 0x12, 0x01, 0x00, 0x8B, 0xC6, 0xE8, 0xBA, 0xCE, 0xFF, 0xFF, 0xC2,
	0x14, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0xFF, 0x75, 0x10,
	0xA1, 0x80, 0x12, 0x01, 0x00, 0xFF, 0x30, 0xFF, 0x75, 0x0C, 0x6A, 0x00, 0xFF, 0x75, 0x08, 0xE8,
	0x64, 0xED, 0xFF, 0xFF, 0x5D, 0xC2, 0x0C, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x8B, 0xFF,
	0x55, 0x8B, 0xEC, 0x8B, 0x55, 0x0C, 0x8B, 0x45, 0x08, 0x85, 0xD2, 0x74, 0x22, 0x0F, 0xB7, 0x0A,
	0x66, 0x89, 0x08, 0x66, 0x89, 0x48, 0x02, 0x8D, 0x48, 0x08, 0x89, 0x48, 0x04, 0x0F, 0xB7, 0x00,
	0x50, 0xFF, 0x72, 0x04, 0x51, 0xE8, 0x02, 0xCE, 0xFF, 0xFF, 0x83, 0xC4, 0x0C, 0xEB, 0x0C, 0x33,
	0xC9, 0x21, 0x48, 0x04, 0x66, 0x89, 0x08, 0x66, 0x89, 0x48, 0x02, 0x5D, 0xC2, 0x08, 0x00, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0x6A, 0x14, 0x68, 0xE8, 0x16, 0x01, 0x00, 0xE8, 0xF4, 0xCD, 0xFF, 0xFF,
	0x80, 0x7D, 0x1C, 0x00, 0x74, 0x4C, 0x83, 0x65, 0xFC, 0x00, 0x6A, 0x01, 0xFF, 0x75, 0x14, 0x8B,
	0x7D, 0x10, 0x57, 0x8B, 0x35, 0x2C, 0x12, 0x01, 0x00, 0xFF, 0xD6, 0x8B, 0x5D, 0x18, 0x85, 0xDB,
	0x74, 0x07, 0x6A, 0x01, 0x6A, 0x04, 0x53, 0xFF, 0xD6, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF,
	0xEB, 0x26, 0x8B, 0x45, 0xEC, 0x8B, 0x00, 0x8B, 0x00, 0x89, 0x45, 0xE0, 0x33, 0xC0, 0x40, 0xC3,
	0x8B, 0x65, 0xE8, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x8B, 0x45, 0xE0, 0xE9, 0x48, 0x01,
	0x00, 0x00, 0x8B, 0x5D, 0x18, 0x8B, 0x7D, 0x10, 0x6A, 0x00, 0x8D, 0x45, 0x10, 0x50, 0xFF, 0x75,
	0x1C, 0xA1, 0x80, 0x12, 0x01, 0x00, 0xFF, 0x30, 0x6A, 0x00, 0xFF, 0x75, 0x08, 0xFF, 0x15, 0x50,
	0x12, 0x01, 0x00, 0x89, 0x45, 0xE4, 0x33, 0xF6, 0x3B, 0xC6, 0x0F, 0x8C, 0x1A, 0x01, 0x00, 0x00,
	0xC7, 0x45, 0xFC, 0x01, 0x00, 0x00, 0x00, 0x8B, 0x45, 0x0C, 0x2B, 0xC6, 0x0F, 0x84, 0xB1, 0x00,
	0x00, 0x00, 0x48, 0x74, 0x7C, 0x48, 0x74, 0x0C, 0xC7, 0x45, 0xE4, 0x03, 0x00, 0x00, 0xC0, 0xE9,
	0xE3, 0x00, 0x00, 0x00, 0x8B, 0x45, 0x10, 0x39, 0x70, 0x18, 0x74, 0x3F, 0x3B, 0xFE, 0x74, 0x21,
	0x8B, 0x40, 0x18, 0x83, 0xC0, 0x0C, 0x0F, 0xB7, 0x08, 0x83, 0xC1, 0x08, 0x3B, 0x4D, 0x14, 0x77,
	0x09, 0x50, 0x57, 0xE8, 0xE6, 0xFE, 0xFF, 0xFF, 0xEB, 0x07, 0xC7, 0x45, 0xE4, 0x23, 0x00, 0x00,
	0xC0, 0x3B, 0xDE, 0x0F, 0x84, 0xAE, 0x00, 0x00, 0x00, 0x8B, 0x45, 0x10, 0x8B, 0x40, 0x18, 0x0F,
	0xB7, 0x40, 0x0C, 0x83, 0xC0, 0x08, 0xE9, 0x81, 0x00, 0x00, 0x00, 0x3B, 0xFE, 0x74, 0x16, 0x83,
	0x7D, 0x14, 0x08, 0x72, 0x09, 0x56, 0x57, 0xE8, 0xB2, 0xFE, 0xFF, 0xFF, 0xEB, 0x07, 0xC7, 0x45,
	0xE4, 0x23, 0x00, 0x00, 0xC0, 0x3B, 0xDE, 0x74, 0x7E, 0xC7, 0x03, 0x08, 0x00, 0x00, 0x00, 0xEB,
	0x76, 0x3B, 0xFE, 0x74, 0x21, 0x8B, 0x45, 0x10, 0x83, 0xC0, 0x1C, 0x0F, 0xB7, 0x08, 0x83, 0xC1,
	0x08, 0x3B, 0x4D, 0x14, 0x77, 0x09, 0x50, 0x57, 0xE8, 0x81, 0xFE, 0xFF, 0xFF, 0xEB, 0x07, 0xC7,
	0x45, 0xE4, 0x23, 0x00, 0x00, 0xC0, 0x3B, 0xDE, 0x74, 0x4D, 0x8B, 0x45, 0x10, 0x0F, 0xB7, 0x40,
	0x1C, 0xEB, 0xA0, 0x6A, 0x0C, 0x58, 0x39, 0x45, 0x14, 0x75, 0x16, 0x8B, 0x4D, 0x10, 0x8B, 0x51,
	0x08, 0x89, 0x17, 0x8B, 0x51, 0x0C, 0x89, 0x57, 0x04, 0x8B, 0x49, 0x10, 0x89, 0x4F, 0x08, 0xEB,
	0x07, 0xC7, 0x45, 0xE4, 0x04, 0x00, 0x00, 0xC0, 0x3B, 0xDE, 0x74, 0x1B, 0x89, 0x03, 0xEB, 0x17,
	0x8B, 0x45, 0xEC, 0x8B, 0x00, 0x8B, 0x00, 0x89, 0x45, 0xDC, 0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x65,
	0xE8, 0x8B, 0x45, 0xDC, 0x89, 0x45, 0xE4, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x8B, 0x4D,
	0x10, 0xFF, 0x15, 0x4C, 0x12, 0x01, 0x00, 0x8B, 0x45, 0xE4, 0xE8, 0x9A, 0xCC, 0xFF, 0xFF, 0xC2,
	0x18, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x6A, 0x1C, 0x68, 0x10, 0x17, 0x01, 0x00, 0xE8,
	0x40, 0xCC, 0xFF, 0xFF, 0x33, 0xDB, 0x38, 0x5D, 0x14, 0x74, 0x53, 0x89, 0x5D, 0xFC, 0x6A, 0x04,
	0x6A, 0x04, 0x8B, 0x7D, 0x08, 0x57, 0xFF, 0x15, 0x2C, 0x12, 0x01, 0x00, 0x6A, 0x04, 0x6A, 0x08,
	0x8B, 0x75, 0x10, 0x56, 0xFF, 0x15, 0x38, 0x12, 0x01, 0x00, 0x8B, 0x06, 0x89, 0x45, 0xD4, 0x8B,
	0x4E, 0x04, 0x89, 0x4D, 0xD8, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xEB, 0x31, 0x8B, 0x45,
	0xEC, 0x8B, 0x00, 0x8B, 0x00, 0x89, 0x45, 0xE0, 0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x65, 0xE8, 0xC7,
	0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x8B, 0x45, 0xE0, 0xE9, 0x91, 0x00, 0x00, 0x00, 0x8B, 0x4D,
	0x10, 0x8B, 0x01, 0x89, 0x45, 0xD4, 0x8B, 0x49, 0x04, 0x89, 0x4D, 0xD8, 0x8B, 0x7D, 0x08, 0x3B,
	0xC3, 0x8D, 0x45, 0x08, 0x50, 0x74, 0x0D, 0x53, 0x8D, 0x45, 0xD4, 0x50, 0xFF, 0x15, 0xA0, 0x12,
	0x01, 0x00, 0xEB, 0x07, 0x51, 0xFF, 0x15, 0xD0, 0x12, 0x01, 0x00, 0x3B, 0xC3, 0x7C, 0x60, 0x8D,
	0x45, 0xE4, 0x50, 0x53, 0xA1, 0xCC, 0x12, 0x01, 0x00, 0xFF, 0x30, 0xFF, 0x75, 0x0C, 0x53, 0x53,
	0xFF, 0x75, 0x08, 0xFF, 0x15, 0x6C, 0x12, 0x01, 0x00, 0x8B, 0xF0, 0x8B, 0x4D, 0x08, 0xFF, 0x15,
	0x4C, 0x12, 0x01, 0x00, 0x3B, 0xF3, 0x7C, 0x35, 0x38, 0x5D, 0x14, 0x74, 0x2B, 0xC7, 0x45, 0xFC,
	0x01, 0x00, 0x00, 0x00, 0x8B, 0x45, 0xE4, 0x89, 0x07, 0xEB, 0x14, 0x8B, 0x45, 0xEC, 0x8B, 0x00,
	0x8B, 0x00, 0x89, 0x45, 0xDC, 0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x65, 0xE8, 0x8B, 0x75, 0xDC, 0xC7,
	0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xEB, 0x05, 0x8B, 0x45, 0xE4, 0x89, 0x07, 0x8B, 0xC6, 0xE8,
	0x95, 0xCB, 0xFF, 0xFF, 0xC2, 0x10, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x6A, 0x14, 0x68, 0x38,
	0x17, 0x01, 0x00, 0xE8, 0x3C, 0xCB, 0xFF, 0xFF, 0x33, 0xDB, 0x38, 0x5D, 0x14, 0x74, 0x3A, 0x89,
	0x5D, 0xFC, 0x6A, 0x04, 0x6A, 0x04, 0x8B, 0x7D, 0x10, 0x57, 0xFF, 0x15, 0x2C, 0x12, 0x01, 0x00,
	0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xEB, 0x23, 0x8B, 0x45, 0xEC, 0x8B, 0x00, 0x8B, 0x00,
	0x89, 0x45, 0xE0, 0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x65, 0xE8, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF,
	0xFF, 0x8B, 0x45, 0xE0, 0xE9, 0x88, 0x00, 0x00, 0x00, 0x8B, 0x7D, 0x10, 0x53, 0x8D, 0x45, 0x10,
	0x50, 0xFF, 0x75, 0x14, 0xA1, 0xCC, 0x12, 0x01, 0x00, 0xFF, 0x30, 0x53, 0xFF, 0x75, 0x08, 0xFF,
	0x15, 0x50, 0x12, 0x01, 0x00, 0x3B, 0xC3, 0x7C, 0x68, 0xFF, 0x75, 0x10, 0xFF, 0x15, 0xD4, 0x12,
	0x01, 0x00, 0x8D, 0x4D, 0xE4, 0x51, 0x53, 0x8B, 0x0D, 0x54, 0x12, 0x01, 0x00, 0xFF, 0x31, 0xFF,
	0x75, 0x0C, 0x53, 0x53, 0x50, 0xFF, 0x15, 0x6C, 0x12, 0x01, 0x00, 0x8B, 0xF0, 0x8B, 0x4D, 0x10,
	0xFF, 0x15, 0x4C, 0x12, 0x01, 0x00, 0x3B, 0xF3, 0x7C, 0x35, 0x38, 0x5D, 0x14, 0x74, 0x2B, 0xC7,
	0x45, 0xFC, 0x01, 0x00, 0x00, 0x00, 0x8B, 0x45, 0xE4, 0x89, 0x07, 0xEB, 0x14, 0x8B, 0x45, 0xEC,
	0x8B, 0x00, 0x8B, 0x00, 0x89, 0x45, 0xDC, 0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x65, 0xE8, 0x8B, 0x75,
	0xDC, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xEB, 0x05, 0x8B, 0x45, 0xE4, 0x89, 0x07, 0x8B,
	0xC6, 0xE8, 0xB3, 0xCA, 0xFF, 0xFF, 0xC2, 0x10, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x8B, 0xFF,
	0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x0C, 0x83, 0x3D, 0xAC, 0x1B, 0x01, 0x00, 0x00, 0x56, 0x57, 0x74,
	0x0A, 0xB8, 0xBB, 0x00, 0x00, 0xC0, 0xE9, 0x96, 0x00, 0x00, 0x00, 0x68, 0x40, 0x1A, 0x01, 0x00,
	0xE8, 0x3B, 0xC7, 0xFF, 0xFF, 0x8B, 0xF0, 0x89, 0x75, 0xF8, 0x85, 0xF6, 0x74, 0xE3, 0xA1, 0x7C,
	0x1A, 0x01, 0x00, 0x83, 0xF8, 0x33, 0x75, 0x0A, 0xFF, 0x75, 0x0C, 0xFF, 0x75, 0x08, 0xFF, 0xD6,
	0xEB, 0x6F, 0x83, 0xF8, 0x34, 0x74, 0x52, 0x83, 0xF8, 0x3C, 0x74, 0x4D, 0x83, 0xF8, 0x3D, 0x74,
	0x48, 0x83, 0xF8, 0x3E, 0x75, 0x25, 0xFF, 0x15, 0xC8, 0x12, 0x01, 0x00, 0x33, 0xC9, 0x39, 0x45,
	0x08, 0x0F, 0x94, 0xC1, 0x89, 0x4D, 0xF4, 0xFF, 0x75, 0xF4, 0xFF, 0x75, 0x0C, 0x8B, 0x7D, 0x08,
	0xFF, 0x55, 0xF8, 0x89, 0x45, 0xFC, 0x8B, 0x45, 0xFC, 0xEB, 0x36, 0x83, 0xF8, 0x3F, 0x75, 0x91,
	0xFF, 0x15, 0xC8, 0x12, 0x01, 0x00, 0x8B, 0x4D, 0x08, 0x8B, 0x55, 0x0C, 0x3B, 0xC8, 0x0F, 0x94,
	0xC0, 0x0F, 0xB6, 0xC0, 0x50, 0xFF, 0xD6, 0xEB, 0x18, 0xFF, 0x15, 0xC8, 0x12, 0x01, 0x00, 0x39,
	0x45, 0x08, 0x0F, 0x94, 0xC0, 0x0F, 0xB6, 0xC0, 0x50, 0xFF, 0x75, 0x0C, 0xFF, 0x75, 0x08, 0xFF,
	0xD6, 0x5F, 0x5E, 0xC9, 0xC2, 0x08, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x8B, 0xFF, 0x55, 0x8B,
	0xEC, 0x6A, 0x00, 0x8D, 0x45, 0x10, 0x50, 0xFF, 0x75, 0x10, 0xA1, 0xCC, 0x12, 0x01, 0x00, 0xFF,
	0x30, 0x6A, 0x00, 0xFF, 0x75, 0x08, 0xFF, 0x15, 0x50, 0x12, 0x01, 0x00, 0x85, 0xC0, 0x7C, 0x2C,
	0x56, 0xFF, 0x15, 0xC8, 0x12, 0x01, 0x00, 0x39, 0x45, 0x10, 0x74, 0x0F, 0xFF, 0x75, 0x0C, 0xFF,
	0x75, 0x10, 0xE8, 0x07, 0xFF, 0xFF, 0xFF, 0x8B, 0xF0, 0xEB, 0x05, 0xBE, 0xDB, 0x00, 0x00, 0xC0,
	0x8B, 0x4D, 0x10, 0xFF, 0x15, 0x4C, 0x12, 0x01, 0x00, 0x8B, 0xC6, 0x5E, 0x5D, 0xC2, 0x0C, 0x00,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x8B, 0x45, 0x14, 0x8B, 0x00,
	0x56, 0x8B, 0x70, 0x40, 0x6A, 0x00, 0x6A, 0x00, 0x83, 0xC0, 0x30, 0x50, 0xFF, 0x15, 0xD8, 0x12,
	0x01, 0x00, 0x56, 0xFF, 0x15, 0xC8, 0x12, 0x01, 0x00, 0x50, 0xE8, 0xBF, 0xFE, 0xFF, 0xFF, 0x5E,
	0x5D, 0xC2, 0x14, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x6A,
	0x00, 0x8D, 0x45, 0x08, 0x50, 0xFF, 0x75, 0x10, 0xA1, 0xCC, 0x12, 0x01, 0x00, 0xFF, 0x30, 0x6A,
	0x00, 0xFF, 0x75, 0x08, 0xFF, 0x15, 0x50, 0x12, 0x01, 0x00, 0x85, 0xC0, 0x7C, 0x1E, 0x56, 0xFF,
	0x75, 0x10, 0xFF, 0x75, 0x0C, 0xFF, 0x75, 0x08, 0xFF, 0x15, 0xDC, 0x12, 0x01, 0x00, 0x8B, 0x4D,
	0x08, 0x8B, 0xF0, 0xFF, 0x15, 0x4C, 0x12, 0x01, 0x00, 0x8B, 0xC6, 0x5E, 0x5D, 0xC2, 0x0C, 0x00,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x6A, 0x00, 0x8D, 0x45, 0x08,
	0x50, 0xFF, 0x75, 0x10, 0xA1, 0xCC, 0x12, 0x01, 0x00, 0xFF, 0x30, 0x6A, 0x00, 0xFF, 0x75, 0x08,
	0xFF, 0x15, 0x50, 0x12, 0x01, 0x00, 0x85, 0xC0, 0x7C, 0x1E, 0x56, 0xFF, 0x75, 0x10, 0xFF, 0x75,
	0x0C, 0xFF, 0x75, 0x08, 0xFF, 0x15, 0xE0, 0x12, 0x01, 0x00, 0x8B, 0x4D, 0x08, 0x8B, 0xF0, 0xFF,
	0x15, 0x4C, 0x12, 0x01, 0x00, 0x8B, 0xC6, 0x5E, 0x5D, 0xC2, 0x0C, 0x00, 0xCC, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x8B, 0x45, 0x14, 0x56, 0x8B, 0x30, 0x8D, 0x46, 0x54,
	0x50, 0xFF, 0x76, 0x4C, 0x6A, 0x00, 0xFF, 0x76, 0x48, 0xFF, 0x76, 0x44, 0xE8, 0x3F, 0xC7, 0xFF,
	0xFF, 0x80, 0x3E, 0x00, 0x89, 0x46, 0x50, 0x75, 0x0E, 0x6A, 0x00, 0x6A, 0x00, 0x83, 0xC6, 0x34,
	0x56, 0xFF, 0x15, 0xD8, 0x12, 0x01, 0x00, 0x5E, 0x5D, 0xC2, 0x14, 0x00, 0xCC, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0x6A, 0x18, 0x68, 0x60, 0x17, 0x01, 0x00, 0xE8, 0x36, 0xC8, 0xFF, 0xFF, 0x80, 0x7D,
	0x1C, 0x00, 0x74, 0x4C, 0x83, 0x65, 0xFC, 0x00, 0x6A, 0x04, 0xFF, 0x75, 0x14, 0x8B, 0x5D, 0x10,
	0x53, 0x8B, 0x35, 0x2C, 0x12, 0x01, 0x00, 0xFF, 0xD6, 0x83, 0x7D, 0x18, 0x00, 0x74, 0x09, 0x6A,
	0x04, 0x6A, 0x04, 0xFF, 0x75, 0x18, 0xFF, 0xD6, 0x6A, 0xFE, 0x5F, 0x89, 0x7D, 0xFC, 0xEB, 0x26,
	0x8B, 0x45, 0xEC, 0x8B, 0x00, 0x8B, 0x00, 0x89, 0x45, 0xE0, 0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x65,
	0xE8, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x8B, 0x45, 0xE0, 0xE9, 0x4C, 0x01, 0x00, 0x00,
	0x6A, 0xFE, 0x5F, 0x8B, 0x5D, 0x10, 0x6A, 0x00, 0x8D, 0x45, 0xE4, 0x50, 0xFF, 0x75, 0x1C, 0xA1,
	0xCC, 0x12, 0x01, 0x00, 0xFF, 0x30, 0x6A, 0x00, 0xFF, 0x75, 0x08, 0xFF, 0x15, 0x50, 0x12, 0x01,
	0x00, 0x89, 0x45, 0x10, 0x85, 0xC0, 0x0F, 0x8C, 0x20, 0x01, 0x00, 0x00, 0x8B, 0x45, 0x0C, 0x48,
	0x0F, 0x84, 0x9A, 0x00, 0x00, 0x00, 0x6A, 0x02, 0x5E, 0x2B, 0xC6, 0x74, 0x0E, 0xC7, 0x45, 0x10,
	0x03, 0x00, 0x00, 0xC0, 0x33, 0xF6, 0xE9, 0xC8, 0x00, 0x00, 0x00, 0x8D, 0x45, 0x08, 0x50, 0x6A,
	0x00, 0xA1, 0xCC, 0x12, 0x01, 0x00, 0xFF, 0x30, 0x6A, 0x40, 0x6A, 0x00, 0x68, 0x00, 0x02, 0x00,
	0x00, 0xFF, 0x75, 0xE4, 0xFF, 0x15, 0x6C, 0x12, 0x01, 0x00, 0x89, 0x45, 0x10, 0x85, 0xC0, 0x0F,
	0x8C, 0x9B, 0x00, 0x00, 0x00, 0x6A, 0x00, 0x6A, 0x04, 0x8D, 0x45, 0x0C, 0x50, 0x6A, 0x16, 0xFF,
	0x75, 0x08, 0xFF, 0x15, 0x88, 0x12, 0x01, 0x00, 0x89, 0x45, 0x10, 0x85, 0xC0, 0x7C, 0x36, 0x83,
	0x7D, 0x14, 0x04, 0x75, 0x29, 0x89, 0x75, 0xFC, 0x8B, 0x45, 0x0C, 0x89, 0x03, 0xEB, 0x1A, 0x8B,
	0x45, 0xEC, 0x8B, 0x00, 0x8B, 0x00, 0x89, 0x45, 0xDC, 0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x65, 0xE8,
	0x8B, 0x45, 0xDC, 0x89, 0x45, 0x10, 0x6A, 0xFE, 0x5F, 0x89, 0x7D, 0xFC, 0xEB, 0x07, 0xC7, 0x45,
	0x10, 0x04, 0x00, 0x00, 0xC0, 0xFF, 0x75, 0x08, 0xFF, 0x15, 0x14, 0x12, 0x01, 0x00, 0xEB, 0x40,
	0xFF, 0x75, 0xE4, 0xFF, 0x15, 0xE8, 0x12, 0x01, 0x00, 0x83, 0x7D, 0x14, 0x04, 0x75, 0x2A, 0xC7,
	0x45, 0xFC, 0x01, 0x00, 0x00, 0x00, 0x89, 0x03, 0xEB, 0x1A, 0x8B, 0x45, 0xEC, 0x8B, 0x00, 0x8B,
	0x00, 0x89, 0x45, 0xD8, 0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x65, 0xE8, 0x8B, 0x45, 0xD8, 0x89, 0x45,
	0x10, 0x6A, 0xFE, 0x5F, 0x89, 0x7D, 0xFC, 0xEB, 0x07, 0xC7, 0x45, 0x10, 0x04, 0x00, 0x00, 0xC0,
	0x6A, 0x04, 0x5E, 0x8B, 0x4D, 0xE4, 0xFF, 0x15, 0x4C, 0x12, 0x01, 0x00, 0x8B, 0x45, 0x18, 0x85,
	0xC0, 0x74, 0x26, 0x80, 0x7D, 0x1C, 0x00, 0x74, 0x1E, 0xC7, 0x45, 0xFC, 0x03, 0x00, 0x00, 0x00,
	0x89, 0x30, 0x89, 0x7D, 0xFC, 0xEB, 0x12, 0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x65, 0xE8, 0xC7, 0x45,
	0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xEB, 0x02, 0x89, 0x30, 0x8B, 0x45, 0x10, 0xE8, 0xD8, 0xC6, 0xFF,
	0xFF, 0xC2, 0x18, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x6A, 0x18, 0x68, 0xA0, 0x17, 0x01,
	0x00, 0xE8, 0x7E, 0xC6, 0xFF, 0xFF, 0x33, 0xDB, 0x38, 0x5D, 0x18, 0x74, 0x3B, 0x89, 0x5D, 0xFC,
	0x6A, 0x04, 0xFF, 0x75, 0x14, 0x8B, 0x7D, 0x10, 0x57, 0xFF, 0x15, 0x38, 0x12, 0x01, 0x00, 0xC7,
	0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xEB, 0x23, 0x8B, 0x45, 0xEC, 0x8B, 0x00, 0x8B, 0x00, 0x89,
	0x45, 0xE0, 0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x65, 0xE8, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF,
	0x8B, 0x45, 0xE0, 0xE9, 0x80, 0x01, 0x00, 0x00, 0x8B, 0x7D, 0x10, 0x53, 0x8D, 0x45, 0x10, 0x50,
	0xFF, 0x75, 0x18, 0xA1, 0xCC, 0x12, 0x01, 0x00, 0xFF, 0x30, 0x53, 0xFF, 0x75, 0x08, 0xFF, 0x15,
	0x50, 0x12, 0x01, 0x00, 0x8B, 0xF0, 0x3B, 0xF3, 0x0F, 0x8C, 0x58, 0x01, 0x00, 0x00, 0x8B, 0x45,
	0x0C, 0x6A, 0x02, 0x59, 0x2B, 0xC1, 0x0F, 0x84, 0x98, 0x00, 0x00, 0x00, 0x48, 0x74, 0x0A, 0xBE,
	0x03, 0x00, 0x00, 0xC0, 0xE9, 0x34, 0x01, 0x00, 0x00, 0x83, 0x7D, 0x14, 0x04, 0x75, 0x30, 0x89,
	0x4D, 0xFC, 0x8B, 0x07, 0x89, 0x45, 0x18, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xEB, 0x24,
	0x8B, 0x45, 0xEC, 0x8B, 0x00, 0x8B, 0x00, 0x89, 0x45, 0xDC, 0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x65,
	0xE8, 0x8B, 0x75, 0xDC, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x33, 0xDB, 0xEB, 0x05, 0xBE,
	0x04, 0x00, 0x00, 0xC0, 0x3B, 0xF3, 0x0F, 0x8C, 0xF1, 0x00, 0x00, 0x00, 0x8D, 0x45, 0x14, 0x50,
	0x53, 0xA1, 0xCC, 0x12, 0x01, 0x00, 0xFF, 0x30, 0x6A, 0x20, 0x53, 0x68, 0x00, 0x02, 0x00, 0x00,
	0xFF, 0x75, 0x10, 0xFF, 0x15, 0x6C, 0x12, 0x01, 0x00, 0x8B, 0xF0, 0x3B, 0xF3, 0x0F, 0x8C, 0xCA,
	0x00, 0x00, 0x00, 0x6A, 0x04, 0x8D, 0x45, 0x18, 0x50, 0x6A, 0x16, 0xFF, 0x75, 0x14, 0xFF, 0x15,
	0xF0, 0x12, 0x01, 0x00, 0x8B, 0xF0, 0xFF, 0x75, 0x14, 0xFF, 0x15, 0x14, 0x12, 0x01, 0x00, 0xE9,
	0xA9, 0x00, 0x00, 0x00, 0x89, 0x5D, 0xE4, 0x83, 0x7D, 0x14, 0x04, 0x75, 0x34, 0xC7, 0x45, 0xFC,
	0x01, 0x00, 0x00, 0x00, 0x8B, 0x07, 0x89, 0x45, 0xE4, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF,
	0xEB, 0x24, 0x8B, 0x45, 0xEC, 0x8B, 0x00, 0x8B, 0x00, 0x89, 0x45, 0xD8, 0x33, 0xC0, 0x40, 0xC3,
	0x8B, 0x65, 0xE8, 0x8B, 0x75, 0xD8, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x33, 0xDB, 0xEB,
	0x05, 0xBE, 0x04, 0x00, 0x00, 0xC0, 0x3B, 0xF3, 0x7C, 0x63, 0x53, 0x8D, 0x45, 0x08, 0x50, 0xFF,
	0x75, 0x18, 0xA1, 0xA8, 0x12, 0x01, 0x00, 0xFF, 0x30, 0x6A, 0x04, 0xFF, 0x75, 0xE4, 0xFF, 0x15,
	0x50, 0x12, 0x01, 0x00, 0x8B, 0xF0, 0x3B, 0xF3, 0x7C, 0x43, 0x8D, 0x45, 0x14, 0x50, 0x53, 0xA1,
	0xA8, 0x12, 0x01, 0x00, 0xFF, 0x30, 0x6A, 0x04, 0x53, 0x68, 0x00, 0x02, 0x00, 0x00, 0xFF, 0x75,
	0x08, 0xFF, 0x15, 0x6C, 0x12, 0x01, 0x00, 0x8B, 0xF0, 0x3B, 0xF3, 0x7C, 0x17, 0xFF, 0x75, 0x14,
	0xFF, 0x75, 0x10, 0xFF, 0x15, 0xEC, 0x12, 0x01, 0x00, 0x8B, 0xF0, 0xFF, 0x75, 0x14, 0xFF, 0x15,
	0x14, 0x12, 0x01, 0x00, 0x8B, 0x4D, 0x08, 0xFF, 0x15, 0x4C, 0x12, 0x01, 0x00, 0x8B, 0x4D, 0x10,
	0xFF, 0x15, 0x4C, 0x12, 0x01, 0x00, 0x8B, 0xC6, 0xE8, 0xFC, 0xC4, 0xFF, 0xFF, 0xC2, 0x14, 0x00,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x44, 0x56, 0x33,
	0xF6, 0x56, 0x8D, 0x45, 0x10, 0x50, 0xFF, 0x75, 0x10, 0xA1, 0xCC, 0x12, 0x01, 0x00, 0xFF, 0x30,
	0x56, 0xFF, 0x75, 0x08, 0xFF, 0x15, 0x50, 0x12, 0x01, 0x00, 0x3B, 0xC6, 0x7C, 0x6F, 0xFF, 0x15,
	0xC8, 0x12, 0x01, 0x00, 0x39, 0x45, 0x10, 0x74, 0x54, 0x8B, 0x45, 0x0C, 0x56, 0x89, 0x45, 0xFC,
	0x56, 0x8D, 0x45, 0xEC, 0x50, 0xFF, 0x15, 0x00, 0x13, 0x01, 0x00, 0x56, 0x56, 0x56, 0x56, 0x68,
	0x06, 0x45, 0x01, 0x00, 0x56, 0xFF, 0x75, 0x10, 0x8D, 0x45, 0xBC, 0x50, 0xFF, 0x15, 0xFC, 0x12,
	0x01, 0x00, 0x6A, 0x02, 0x56, 0x8D, 0x45, 0xBC, 0x50, 0x50, 0xFF, 0x15, 0xF8, 0x12, 0x01, 0x00,
	0x84, 0xC0, 0x74, 0x12, 0x56, 0x56, 0x56, 0x56, 0x8D, 0x45, 0xEC, 0x50, 0xFF, 0x15, 0xF4, 0x12,
	0x01, 0x00, 0x8B, 0xF0, 0xEB, 0x0C, 0xBE, 0x01, 0x00, 0x00, 0xC0, 0xEB, 0x05, 0xBE, 0xDB, 0x00,
	0x00, 0xC0, 0x8B, 0x4D, 0x10, 0xFF, 0x15, 0x4C, 0x12, 0x01, 0x00, 0x8B, 0xC6, 0x5E, 0xC9, 0xC2,
	0x0C, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x6A, 0x74, 0x68, 0xD8, 0x17, 0x01, 0x00, 0xE8,
	0x00, 0xC4, 0xFF, 0xFF, 0x33, 0xDB, 0x89, 0x5D, 0xE4, 0x8B, 0x75, 0x10, 0x83, 0xFE, 0x40, 0x76,
	0x0A, 0xB8, 0xF1, 0x00, 0x00, 0xC0, 0xE9, 0x37, 0x02, 0x00, 0x00, 0x8B, 0xC6, 0xC1, 0xE0, 0x02,
	0x38, 0x5D, 0x20, 0x74, 0x5A, 0x89, 0x5D, 0xFC, 0x6A, 0x04, 0x5F, 0x57, 0x50, 0xFF, 0x75, 0x14,
	0x8B, 0x35, 0x2C, 0x12, 0x01, 0x00, 0xFF, 0xD6, 0x39, 0x5D, 0x18, 0x74, 0x07, 0x57, 0x57, 0xFF,
	0x75, 0x18, 0xFF, 0xD6, 0x8B, 0x4D, 0x1C, 0x3B, 0xCB, 0x74, 0x08, 0x57, 0x57, 0x51, 0xFF, 0xD6,
	0x8B, 0x4D, 0x1C, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x8B, 0x75, 0x10, 0xEB, 0x23, 0x8B,
	0x45, 0xEC, 0x8B, 0x00, 0x8B, 0x00, 0x89, 0x45, 0xE0, 0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x65, 0xE8,
	0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x8B, 0x45, 0xE0, 0xE9, 0xD3, 0x01, 0x00, 0x00, 0x8B,
	0x4D, 0x1C, 0x8B, 0xC6, 0xC1, 0xE0, 0x02, 0x3B, 0xC3, 0x75, 0x58, 0x38, 0x5D, 0x20, 0x74, 0x3B,
	0xC7, 0x45, 0xFC, 0x01, 0x00, 0x00, 0x00, 0x8B, 0x45, 0x18, 0x3B, 0xC3, 0x74, 0x02, 0x89, 0x18,
	0x3B, 0xCB, 0x74, 0x1B, 0x89, 0x19, 0xEB, 0x17, 0x8B, 0x45, 0xEC, 0x8B, 0x00, 0x8B, 0x00, 0x89,
	0x45, 0xDC, 0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x65, 0xE8, 0x8B, 0x45, 0xDC, 0x89, 0x45, 0xE4, 0xC7,
	0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xE9, 0x84, 0x01, 0x00, 0x00, 0x8B, 0x45, 0x18, 0x3B, 0xC3,
	0x74, 0x02, 0x89, 0x18, 0x3B, 0xCB, 0x0F, 0x84, 0x73, 0x01, 0x00, 0x00, 0x89, 0x19, 0xE9, 0x6C,
	0x01, 0x00, 0x00, 0x68, 0x4B, 0x70, 0x68, 0x62, 0x50, 0x53, 0xFF, 0x15, 0x20, 0x12, 0x01, 0x00,
	0x8B, 0xF8, 0x89, 0x7D, 0xD4, 0x3B, 0xFB, 0x75, 0x0A, 0xB8, 0x9A, 0x00, 0x00, 0xC0, 0xE9, 0x4F,
	0x01, 0x00, 0x00, 0x8B, 0x45, 0x0C, 0x89, 0x45, 0xC0, 0x89, 0x75, 0xC4, 0x89, 0x7D, 0xC8, 0xFF,
	0x15, 0xC8, 0x12, 0x01, 0x00, 0x39, 0x45, 0x08, 0x75, 0x39, 0x8D, 0x85, 0x7C, 0xFF, 0xFF, 0xFF,
	0x89, 0x45, 0x08, 0xC6, 0x85, 0x7C, 0xFF, 0xFF, 0xFF, 0x01, 0xB1, 0x01, 0xFF, 0x15, 0x04, 0x12,
	0x01, 0x00, 0x88, 0x45, 0x13, 0x8D, 0x45, 0x20, 0x50, 0x8D, 0x45, 0x08, 0x50, 0x53, 0x53, 0x8D,
	0x45, 0x80, 0x50, 0xE8, 0x3A, 0xFA, 0xFF, 0xFF, 0x8A, 0x4D, 0x13, 0xFF, 0x15, 0x00, 0x12, 0x01,
	0x00, 0xEB, 0x5B, 0x88, 0x9D, 0x7C, 0xFF, 0xFF, 0xFF, 0x53, 0x53, 0x8D, 0x45, 0xB0, 0x50, 0xFF,
	0x15, 0x00, 0x13, 0x01, 0x00, 0x53, 0x53, 0x53, 0x53, 0x68, 0xD2, 0x45, 0x01, 0x00, 0x53, 0xFF,
	0x75, 0x08, 0x8D, 0x45, 0x80, 0x50, 0xFF, 0x15, 0xFC, 0x12, 0x01, 0x00, 0x6A, 0x02, 0x53, 0x8D,
	0x85, 0x7C, 0xFF, 0xFF, 0xFF, 0x50, 0x8D, 0x45, 0x80, 0x50, 0xFF, 0x15, 0xF8, 0x12, 0x01, 0x00,
	0x84, 0xC0, 0x74, 0x13, 0x53, 0x53, 0x53, 0x53, 0x8D, 0x45, 0xB0, 0x50, 0xFF, 0x15, 0xF4, 0x12,
	0x01, 0x00, 0x89, 0x45, 0xE4, 0xEB, 0x07, 0xC7, 0x45, 0xE4, 0x01, 0x00, 0x00, 0xC0, 0x39, 0x5D,
	0xE4, 0x0F, 0x8C, 0x8C, 0x00, 0x00, 0x00, 0x38, 0x5D, 0x20, 0x74, 0x5D, 0xC7, 0x45, 0xFC, 0x02,
	0x00, 0x00, 0x00, 0x8B, 0x75, 0xCC, 0x8B, 0xC6, 0xC1, 0xE0, 0x02, 0x50, 0x57, 0xFF, 0x75, 0x14,
	0xE8, 0x17, 0xC2, 0xFF, 0xFF, 0x83, 0xC4, 0x0C, 0x8B, 0x45, 0x18, 0x3B, 0xC3, 0x74, 0x02, 0x89,
	0x30, 0x8B, 0x45, 0x1C, 0x3B, 0xC3, 0x74, 0x05, 0x8B, 0x4D, 0xD0, 0x89, 0x08, 0xC7, 0x45, 0xFC,
	0xFE, 0xFF, 0xFF, 0xFF, 0xEB, 0x4D, 0x8B, 0x45, 0xEC, 0x8B, 0x00, 0x8B, 0x00, 0x89, 0x45, 0xD8,
	0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x65, 0xE8, 0x8B, 0x45, 0xD8, 0x89, 0x45, 0xE4, 0xC7, 0x45, 0xFC,
	0xFE, 0xFF, 0xFF, 0xFF, 0x8B, 0x7D, 0xD4, 0xEB, 0x2A, 0x8B, 0x75, 0xCC, 0x8B, 0xC6, 0xC1, 0xE0,
	0x02, 0x50, 0x57, 0xFF, 0x75, 0x14, 0xE8, 0xC1, 0xC1, 0xFF, 0xFF, 0x83, 0xC4, 0x0C, 0x8B, 0x45,
	0x18, 0x3B, 0xC3, 0x74, 0x02, 0x89, 0x30, 0x8B, 0x45, 0x1C, 0x3B, 0xC3, 0x74, 0x05, 0x8B, 0x4D,
	0xD0, 0x89, 0x08, 0x68, 0x4B, 0x70, 0x68, 0x62, 0x57, 0xFF, 0x15, 0x18, 0x12, 0x01, 0x00, 0x8B,
	0x45, 0xE4, 0xE8, 0xF2, 0xC1, 0xFF, 0xFF, 0xC2, 0x1C, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x6A, 0x00, 0x8D, 0x45, 0x08, 0x50, 0xFF, 0x75, 0x20, 0xA1, 0xCC,
	0x12, 0x01, 0x00, 0xFF, 0x30, 0x6A, 0x00, 0xFF, 0x75, 0x08, 0xFF, 0x15, 0x50, 0x12, 0x01, 0x00,
	0x85, 0xC0, 0x7C, 0x29, 0x56, 0xFF, 0x75, 0x20, 0xFF, 0x75, 0x1C, 0xFF, 0x75, 0x18, 0xFF, 0x75,
	0x14, 0xFF, 0x75, 0x10, 0xFF, 0x75, 0x0C, 0xFF, 0x75, 0x08, 0xE8, 0x59, 0xFD, 0xFF, 0xFF, 0x8B,
	0x4D, 0x08, 0x8B, 0xF0, 0xFF, 0x15, 0x4C, 0x12, 0x01, 0x00, 0x8B, 0xC6, 0x5E, 0x5D, 0xC2, 0x1C,
	0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x68, 0xBC, 0x02, 0x00, 0x00, 0x68, 0x10, 0x18, 0x01, 0x00,
	0xE8, 0x07, 0xC3, 0xFF, 0xFF, 0x8B, 0x45, 0x08, 0x89, 0x85, 0xAC, 0xFD, 0xFF, 0xFF, 0x8B, 0x4D,
	0x0C, 0x89, 0x8D, 0xA8, 0xFD, 0xFF, 0xFF, 0x8B, 0x45, 0x10, 0x89, 0x85, 0xB0, 0xFD, 0xFF, 0xFF,
	0x8B, 0x45, 0x14, 0x89, 0x85, 0xB8, 0xFD, 0xFF, 0xFF, 0x8B, 0x55, 0x20, 0x89, 0x95, 0xC0, 0xFD,
	0xFF, 0xFF, 0x8D, 0xB5, 0x34, 0xFD, 0xFF, 0xFF, 0x89, 0xB5, 0xBC, 0xFD, 0xFF, 0xFF, 0x33, 0xDB,
	0x88, 0x9D, 0xE3, 0xFD, 0xFF, 0xFF, 0x88, 0x9D, 0xE1, 0xFD, 0xFF, 0xFF, 0x89, 0x8D, 0xD0, 0xFD,
	0xFF, 0xFF, 0x89, 0x85, 0xC4, 0xFD, 0xFF, 0xFF, 0x8D, 0x8D, 0xE4, 0xFD, 0xFF, 0xFF, 0x89, 0x8D,
	0xD8, 0xFD, 0xFF, 0xFF, 0xB8, 0x00, 0xC0, 0x00, 0x00, 0x8B, 0x55, 0x18, 0x3B, 0xD0, 0x73, 0x02,
	0x8B, 0xC2, 0x89, 0x95, 0xCC, 0xFD, 0xFF, 0xFF, 0x8B, 0xF8, 0x39, 0x9D, 0xCC, 0xFD, 0xFF, 0xFF,
	0x0F, 0x84, 0x19, 0x03, 0x00, 0x00, 0x3B, 0xBD, 0xCC, 0xFD, 0xFF, 0xFF, 0x76, 0x06, 0x8B, 0xBD,
	0xCC, 0xFD, 0xFF, 0xFF, 0x81, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x76, 0x09, 0xC6, 0x85, 0xE2, 0xFD,
	0xFF, 0xFF, 0x01, 0xEB, 0x34, 0x88, 0x9D, 0xE2, 0xFD, 0xFF, 0xFF, 0x8D, 0x85, 0xE4, 0xFD, 0xFF,
	0xFF, 0x81, 0xFF, 0x00, 0x02, 0x00, 0x00, 0x0F, 0x87, 0x02, 0x01, 0x00, 0x00, 0x3B, 0xC8, 0x74,
	0x0C, 0x68, 0x4B, 0x70, 0x68, 0x43, 0x51, 0xFF, 0x15, 0x18, 0x12, 0x01, 0x00, 0x8D, 0x85, 0xE4,
	0xFD, 0xFF, 0xFF, 0x89, 0x85, 0xD8, 0xFD, 0xFF, 0xFF, 0x89, 0x9D, 0xC8, 0xFD, 0xFF, 0xFF, 0x88,
	0x9D, 0xE0, 0xFD, 0xFF, 0xFF, 0x88, 0x9D, 0xDF, 0xFD, 0xFF, 0xFF, 0x8D, 0x85, 0x8C, 0xFD, 0xFF,
	0xFF, 0x50, 0xFF, 0xB5, 0xAC, 0xFD, 0xFF, 0xFF, 0xFF, 0x15, 0x64, 0x12, 0x01, 0x00, 0x89, 0x5D,
	0xFC, 0x8B, 0x85, 0xD0, 0xFD, 0xFF, 0xFF, 0x3B, 0x85, 0xA8, 0xFD, 0xFF, 0xFF, 0x75, 0x24, 0x38,
	0x5D, 0x1C, 0x74, 0x1F, 0xC6, 0x85, 0xE3, 0xFD, 0xFF, 0xFF, 0x01, 0x6A, 0x01, 0xFF, 0x75, 0x18,
	0x50, 0xFF, 0x15, 0x38, 0x12, 0x01, 0x00, 0x88, 0x9D, 0xE3, 0xFD, 0xFF, 0xFF, 0x8B, 0x85, 0xD0,
	0xFD, 0xFF, 0xFF, 0x38, 0x9D, 0xE2, 0xFD, 0xFF, 0xFF, 0x0F, 0x84, 0xB4, 0x00, 0x00, 0x00, 0x89,
	0x1E, 0xB9, 0xFF, 0x0F, 0x00, 0x00, 0x23, 0xC1, 0x8B, 0xD7, 0x23, 0xD1, 0x8D, 0x8C, 0x02, 0xFF,
	0x0F, 0x00, 0x00, 0xC1, 0xE9, 0x0C, 0x8B, 0xD7, 0xC1, 0xEA, 0x0C, 0x03, 0xCA, 0x8D, 0x0C, 0x8D,
	0x1C, 0x00, 0x00, 0x00, 0x66, 0x89, 0x4E, 0x04, 0x33, 0xC9, 0x66, 0x89, 0x4E, 0x06, 0x8B, 0x8D,
	0xD0, 0xFD, 0xFF, 0xFF, 0x81, 0xE1, 0x00, 0xF0, 0xFF, 0xFF, 0x89, 0x4E, 0x10, 0x89, 0x46, 0x18,
	0x89, 0x7E, 0x14, 0x53, 0xFF, 0x75, 0x1C, 0x56, 0xFF, 0x15, 0x14, 0x13, 0x01, 0x00, 0xC6, 0x85,
	0xE0, 0xFD, 0xFF, 0xFF, 0x01, 0x6A, 0x20, 0x53, 0x53, 0x6A, 0x01, 0x53, 0x56, 0xFF, 0x15, 0x10,
	0x13, 0x01, 0x00, 0x89, 0x85, 0xC8, 0xFD, 0xFF, 0xFF, 0x3B, 0xC3, 0x75, 0x56, 0xC6, 0x85, 0xE1,
	0xFD, 0xFF, 0xFF, 0x01, 0x68, 0x9A, 0x00, 0x00, 0xC0, 0xFF, 0x15, 0x0C, 0x13, 0x01, 0x00, 0x3B,
	0xC8, 0x0F, 0x85, 0x12, 0xFF, 0xFF, 0xFF, 0xEB, 0x0E, 0xD1, 0xEF, 0x81, 0xFF, 0x00, 0x02, 0x00,
	0x00, 0x0F, 0x86, 0xF6, 0xFE, 0xFF, 0xFF, 0x68, 0x4B, 0x70, 0x68, 0x43, 0x57, 0x53, 0xFF, 0x15,
	0x20, 0x12, 0x01, 0x00, 0x3B, 0xC3, 0x89, 0x85, 0xD8, 0xFD, 0xFF, 0xFF, 0x74, 0xDB, 0xE9, 0xE6,
	0xFE, 0xFF, 0xFF, 0x57, 0x50, 0xFF, 0xB5, 0xD8, 0xFD, 0xFF, 0xFF, 0xE8, 0x2C, 0xBF, 0xFF, 0xFF,
	0x83, 0xC4, 0x0C, 0x8D, 0x85, 0x8C, 0xFD, 0xFF, 0xFF, 0x50, 0xFF, 0x15, 0x5C, 0x12, 0x01, 0x00,
	0x8D, 0x85, 0x8C, 0xFD, 0xFF, 0xFF, 0x50, 0xFF, 0xB5, 0xB0, 0xFD, 0xFF, 0xFF, 0xFF, 0x15, 0x64,
	0x12, 0x01, 0x00, 0x8B, 0x85, 0xC4, 0xFD, 0xFF, 0xFF, 0x3B, 0x85, 0xB8, 0xFD, 0xFF, 0xFF, 0x75,
	0x24, 0x38, 0x5D, 0x1C, 0x74, 0x1F, 0xC6, 0x85, 0xE3, 0xFD, 0xFF, 0xFF, 0x01, 0x6A, 0x01, 0xFF,
	0x75, 0x18, 0x50, 0xFF, 0x15, 0x2C, 0x12, 0x01, 0x00, 0x88, 0x9D, 0xE3, 0xFD, 0xFF, 0xFF, 0x8B,
	0x85, 0xC4, 0xFD, 0xFF, 0xFF, 0xC6, 0x85, 0xDF, 0xFD, 0xFF, 0xFF, 0x01, 0x57, 0x38, 0x9D, 0xE2,
	0xFD, 0xFF, 0xFF, 0x74, 0x08, 0xFF, 0xB5, 0xC8, 0xFD, 0xFF, 0xFF, 0xEB, 0x06, 0xFF, 0xB5, 0xD8,
	0xFD, 0xFF, 0xFF, 0x50, 0xE8, 0xB3, 0xBE, 0xFF, 0xFF, 0x83, 0xC4, 0x0C, 0xC7, 0x45, 0xFC, 0xFE,
	0xFF, 0xFF, 0xFF, 0x8D, 0x85, 0x8C, 0xFD, 0xFF, 0xFF, 0x50, 0xFF, 0x15, 0x5C, 0x12, 0x01, 0x00,
	0x38, 0x9D, 0xE2, 0xFD, 0xFF, 0xFF, 0x74, 0x14, 0x56, 0xFF, 0xB5, 0xC8, 0xFD, 0xFF, 0xFF, 0xFF,
	0x15, 0x08, 0x13, 0x01, 0x00, 0x56, 0xFF, 0x15, 0x04, 0x13, 0x01, 0x00, 0x29, 0xBD, 0xCC, 0xFD,
	0xFF, 0xFF, 0x01, 0xBD, 0xD0, 0xFD, 0xFF, 0xFF, 0x01, 0xBD, 0xC4, 0xFD, 0xFF, 0xFF, 0x8B, 0x8D,
	0xD8, 0xFD, 0xFF, 0xFF, 0xE9, 0xB1, 0xFD, 0xFF, 0xFF, 0x8B, 0x45, 0xEC, 0x8B, 0x08, 0x8B, 0x09,
	0x89, 0x8D, 0xB4, 0xFD, 0xFF, 0xFF, 0x8D, 0x8D, 0xA4, 0xFD, 0xFF, 0xFF, 0x51, 0x8D, 0x8D, 0xD7,
	0xFD, 0xFF, 0xFF, 0x51, 0x50, 0xE8, 0xBA, 0xBD, 0xFF, 0xFF, 0xC3, 0x8B, 0x65, 0xE8, 0x8D, 0x85,
	0x8C, 0xFD, 0xFF, 0xFF, 0x50, 0xFF, 0x15, 0x5C, 0x12, 0x01, 0x00, 0x33, 0xDB, 0x39, 0x9D, 0xC8,
	0xFD, 0xFF, 0xFF, 0x74, 0x12, 0xFF, 0xB5, 0xBC, 0xFD, 0xFF, 0xFF, 0xFF, 0xB5, 0xC8, 0xFD, 0xFF,
	0xFF, 0xFF, 0x15, 0x08, 0x13, 0x01, 0x00, 0x38, 0x9D, 0xE0, 0xFD, 0xFF, 0xFF, 0x74, 0x0C, 0xFF,
	0xB5, 0xBC, 0xFD, 0xFF, 0xFF, 0xFF, 0x15, 0x04, 0x13, 0x01, 0x00, 0x8D, 0x85, 0xE4, 0xFD, 0xFF,
	0xFF, 0x39, 0x85, 0xD8, 0xFD, 0xFF, 0xFF, 0x74, 0x11, 0x68, 0x4B, 0x70, 0x68, 0x43, 0xFF, 0xB5,
	0xD8, 0xFD, 0xFF, 0xFF, 0xFF, 0x15, 0x18, 0x12, 0x01, 0x00, 0x38, 0x9D, 0xE3, 0xFD, 0xFF, 0xFF,
	0x75, 0x3E, 0x38, 0x9D, 0xE1, 0xFD, 0xFF, 0xFF, 0x75, 0x36, 0x38, 0x9D, 0xDF, 0xFD, 0xFF, 0xFF,
	0x74, 0x16, 0x38, 0x9D, 0xD7, 0xFD, 0xFF, 0xFF, 0x74, 0x0E, 0x8B, 0x85, 0xA4, 0xFD, 0xFF, 0xFF,
	0x2B, 0x85, 0xD0, 0xFD, 0xFF, 0xFF, 0xEB, 0x09, 0x8B, 0x45, 0x18, 0x2B, 0x85, 0xCC, 0xFD, 0xFF,
	0xFF, 0x8B, 0x8D, 0xC0, 0xFD, 0xFF, 0xFF, 0x89, 0x01, 0xB8, 0x0D, 0x00, 0x00, 0x80, 0xEB, 0x06,
	0x8B, 0x85, 0xB4, 0xFD, 0xFF, 0xFF, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xEB, 0x23, 0x8D,
	0x85, 0xE4, 0xFD, 0xFF, 0xFF, 0x3B, 0xC8, 0x74, 0x0C, 0x68, 0x4B, 0x70, 0x68, 0x43, 0x51, 0xFF,
	0x15, 0x18, 0x12, 0x01, 0x00, 0x8B, 0x45, 0x18, 0x8B, 0x8D, 0xC0, 0xFD, 0xFF, 0xFF, 0x89, 0x01,
	0x33, 0xC0, 0xE8, 0x8D, 0xBF, 0xFF, 0xFF, 0xC2, 0x1C, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0x6A, 0x0C, 0x68, 0x30, 0x18, 0x01, 0x00, 0xE8, 0x68, 0xBD, 0xFF, 0xFF, 0x8B, 0x5D, 0x1C, 0x8B,
	0x75, 0x14, 0x84, 0xDB, 0x74, 0x6A, 0x8B, 0x45, 0x0C, 0x8D, 0x0C, 0x30, 0x3B, 0xC8, 0x72, 0x59,
	0x8B, 0x55, 0x10, 0x8D, 0x04, 0x32, 0x3B, 0xC2, 0x72, 0x4F, 0x8B, 0x15, 0x18, 0x13, 0x01, 0x00,
	0x8B, 0x12, 0x3B, 0xCA, 0x77, 0x43, 0x3B, 0xC2, 0x77, 0x3F, 0x8B, 0x7D, 0x18, 0x85, 0xFF, 0x74,
	0x42, 0x83, 0x65, 0xFC, 0x00, 0x6A, 0x04, 0x6A, 0x04, 0x57, 0xFF, 0x15, 0x2C, 0x12, 0x01, 0x00,
	0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xEB, 0x2A, 0x8B, 0x45, 0xEC, 0x8B, 0x00, 0x8B, 0x00,
	0x89, 0x45, 0xE4, 0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x65, 0xE8, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF,
	0xFF, 0x8B, 0x45, 0xE4, 0xE9, 0x86, 0x00, 0x00, 0x00, 0xB8, 0x05, 0x00, 0x00, 0xC0, 0xEB, 0x7F,
	0x8B, 0x7D, 0x18, 0x33, 0xC0, 0x3B, 0xF0, 0x74, 0x5C, 0x50, 0x8D, 0x4D, 0x14, 0x51, 0x53, 0x8B,
	0x0D, 0x54, 0x12, 0x01, 0x00, 0xFF, 0x31, 0x50, 0xFF, 0x75, 0x08, 0xFF, 0x15, 0x50, 0x12, 0x01,
	0x00, 0x89, 0x45, 0x18, 0x85, 0xC0, 0x7C, 0x27, 0x8D, 0x45, 0x10, 0x50, 0x53, 0x56, 0xFF, 0x75,
	0x10, 0xFF, 0x15, 0x74, 0x12, 0x01, 0x00, 0x50, 0xFF, 0x75, 0x0C, 0xFF, 0x75, 0x14, 0xE8, 0x63,
	0xFB, 0xFF, 0xFF, 0x89, 0x45, 0x18, 0x8B, 0x4D, 0x14, 0xFF, 0x15, 0x4C, 0x12, 0x01, 0x00, 0x8B,
	0x45, 0x10, 0x85, 0xFF, 0x74, 0x26, 0x84, 0xDB, 0x74, 0x20, 0xC7, 0x45, 0xFC, 0x01, 0x00, 0x00,
	0x00, 0x89, 0x07, 0xEB, 0x0C, 0x89, 0x45, 0x18, 0xEB, 0xE8, 0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x65,
	0xE8, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xEB, 0x02, 0x89, 0x07, 0x8B, 0x45, 0x18, 0xE8,
	0xB5, 0xBC, 0xFF, 0xFF, 0xC2, 0x18, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x6A, 0x0C, 0x68, 0x58,
	0x18, 0x01, 0x00, 0xE8, 0x5C, 0xBC, 0xFF, 0xFF, 0x8B, 0x5D, 0x1C, 0x8B, 0x75, 0x14, 0x84, 0xDB,
	0x74, 0x6A, 0x8B, 0x45, 0x0C, 0x8D, 0x0C, 0x30, 0x3B, 0xC8, 0x72, 0x59, 0x8B, 0x55, 0x10, 0x8D,
	0x04, 0x32, 0x3B, 0xC2, 0x72, 0x4F, 0x8B, 0x15, 0x18, 0x13, 0x01, 0x00, 0x8B, 0x12, 0x3B, 0xCA,
	0x77, 0x43, 0x3B, 0xC2, 0x77, 0x3F, 0x8B, 0x7D, 0x18, 0x85, 0xFF, 0x74, 0x42, 0x83, 0x65, 0xFC,
	0x00, 0x6A, 0x04, 0x6A, 0x04, 0x57, 0xFF, 0x15, 0x2C, 0x12, 0x01, 0x00, 0xC7, 0x45, 0xFC, 0xFE,
	0xFF, 0xFF, 0xFF, 0xEB, 0x2A, 0x8B, 0x45, 0xEC, 0x8B, 0x00, 0x8B, 0x00, 0x89, 0x45, 0xE4, 0x33,
	0xC0, 0x40, 0xC3, 0x8B, 0x65, 0xE8, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x8B, 0x45, 0xE4,
	0xE9, 0x86, 0x00, 0x00, 0x00, 0xB8, 0x05, 0x00, 0x00, 0xC0, 0xEB, 0x7F, 0x8B, 0x7D, 0x18, 0x33,
	0xC0, 0x3B, 0xF0, 0x74, 0x5C, 0x50, 0x8D, 0x4D, 0x14, 0x51, 0x53, 0x8B, 0x0D, 0x54, 0x12, 0x01,
	0x00, 0xFF, 0x31, 0x50, 0xFF, 0x75, 0x08, 0xFF, 0x15, 0x50, 0x12, 0x01, 0x00, 0x89, 0x45, 0x18,
	0x85, 0xC0, 0x7C, 0x27, 0x8D, 0x45, 0x0C, 0x50, 0x53, 0x56, 0xFF, 0x75, 0x0C, 0xFF, 0x75, 0x14,
	0xFF, 0x75, 0x10, 0xFF, 0x15, 0x74, 0x12, 0x01, 0x00, 0x50, 0xE8, 0x57, 0xFA, 0xFF, 0xFF, 0x89,
	0x45, 0x18, 0x8B, 0x4D, 0x14, 0xFF, 0x15, 0x4C, 0x12, 0x01, 0x00, 0x8B, 0x45, 0x0C, 0x85, 0xFF,
	0x74, 0x26, 0x84, 0xDB, 0x74, 0x20, 0xC7, 0x45, 0xFC, 0x01, 0x00, 0x00, 0x00, 0x89, 0x07, 0xEB,
	0x0C, 0x89, 0x45, 0x18, 0xEB, 0xE8, 0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x65, 0xE8, 0xC7, 0x45, 0xFC,
	0xFE, 0xFF, 0xFF, 0xFF, 0xEB, 0x02, 0x89, 0x07, 0x8B, 0x45, 0x18, 0xE8, 0xA9, 0xBB, 0xFF, 0xFF,
	0xC2, 0x18, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x6A, 0x18, 0x68, 0x80, 0x18, 0x01, 0x00, 0xE8,
	0x50, 0xBB, 0xFF, 0xFF, 0x8B, 0x5D, 0x14, 0x80, 0x7D, 0x1C, 0x00, 0x74, 0x48, 0x8B, 0x45, 0x0C,
	0x8D, 0x0C, 0x18, 0x3B, 0xC8, 0x0F, 0x82, 0xA5, 0x00, 0x00, 0x00, 0x8B, 0x4D, 0x10, 0x8D, 0x04,
	0x19, 0x3B, 0xC1, 0x0F, 0x82, 0x97, 0x00, 0x00, 0x00, 0x8B, 0x0D, 0x18, 0x13, 0x01, 0x00, 0x3B,
	0x01, 0x0F, 0x87, 0x89, 0x00, 0x00, 0x00, 0x83, 0x7D, 0x18, 0x00, 0x74, 0x18, 0x83, 0x65, 0xFC,
	0x00, 0x6A, 0x04, 0x6A, 0x04, 0xFF, 0x75, 0x18, 0xFF, 0x15, 0x2C, 0x12, 0x01, 0x00, 0xC7, 0x45,
	0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x33, 0xC0, 0x3B, 0xD8, 0x0F, 0x84, 0x08, 0x01, 0x00, 0x00, 0x8B,
	0x7D, 0x0C, 0x8D, 0x0C, 0x1F, 0x8B, 0x15, 0x18, 0x13, 0x01, 0x00, 0x3B, 0x0A, 0x0F, 0x86, 0x91,
	0x00, 0x00, 0x00, 0xB8, 0x00, 0xF0, 0xFF, 0xFF, 0x23, 0xF8, 0x8D, 0x71, 0xFF, 0x23, 0xF0, 0xC7,
	0x45, 0xFC, 0x01, 0x00, 0x00, 0x00, 0x3B, 0xFE, 0x77, 0x4B, 0x57, 0xFF, 0x15, 0x1C, 0x13, 0x01,
	0x00, 0x84, 0xC0, 0x75, 0x35, 0x68, 0x05, 0x00, 0x00, 0xC0, 0xFF, 0x15, 0x0C, 0x13, 0x01, 0x00,
	0x8B, 0x45, 0xEC, 0x8B, 0x00, 0x8B, 0x00, 0x89, 0x45, 0xE0, 0x33, 0xC0, 0x40, 0xC3, 0x8B, 0x45,
	0xE0, 0x8B, 0x65, 0xE8, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xE9, 0xC3, 0x00, 0x00, 0x00,
	0xB8, 0x05, 0x00, 0x00, 0xC0, 0xE9, 0xB9, 0x00, 0x00, 0x00, 0x81, 0xC7, 0x00, 0x10, 0x00, 0x00,
	0x89, 0x7D, 0xD8, 0xEB, 0xB1, 0x53, 0xFF, 0x75, 0x0C, 0xFF, 0x75, 0x10, 0xE8, 0x5B, 0xBA, 0xFF,
	0xFF, 0x83, 0xC4, 0x0C, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x83, 0x65, 0x14, 0x00, 0xEB,
	0x5E, 0x8B, 0x45, 0xEC, 0x8B, 0x00, 0x8B, 0x00, 0x89, 0x45, 0xDC, 0x33, 0xC0, 0x40, 0xC3, 0x8B,
	0x45, 0xDC, 0xEB, 0xAD, 0x50, 0x8D, 0x4D, 0xE4, 0x51, 0xFF, 0x75, 0x1C, 0x8B, 0x0D, 0x54, 0x12,
	0x01, 0x00, 0xFF, 0x31, 0x50, 0xFF, 0x75, 0x08, 0xFF, 0x15, 0x50, 0x12, 0x01, 0x00, 0x89, 0x45,
	0x14, 0x85, 0xC0, 0x7C, 0x27, 0x8D, 0x45, 0x0C, 0x50, 0xFF, 0x75, 0x1C, 0x53, 0xFF, 0x75, 0x10,
	0xFF, 0x15, 0x74, 0x12, 0x01, 0x00, 0x50, 0x57, 0xFF, 0x75, 0xE4, 0xE8, 0xC6, 0xF8, 0xFF, 0xFF,
	0x89, 0x45, 0x14, 0x8B, 0x4D, 0xE4, 0xFF, 0x15, 0x4C, 0x12, 0x01, 0x00, 0x8B, 0x5D, 0x0C, 0x8B,
	0x45, 0x18, 0x85, 0xC0, 0x74, 0x2A, 0x80, 0x7D, 0x1C, 0x00, 0x74, 0x22, 0xC7, 0x45, 0xFC, 0x02,
	0x00, 0x00, 0x00, 0x89, 0x18, 0xEB, 0x0E, 0x33, 0xDB, 0x89, 0x45, 0x14, 0xEB, 0xE1, 0x33, 0xC0,
	0x40, 0xC3, 0x8B, 0x65, 0xE8, 0xC7, 0x45, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xEB, 0x02, 0x89, 0x18,
	0x8B, 0x45, 0x14, 0xE8, 0x11, 0xBA, 0xFF, 0xFF, 0xC2, 0x18, 0x00, 0xCC, 0x44, 0x00, 0x69, 0x00,
	0x73, 0x00, 0x61, 0x00, 0x62, 0x00, 0x6C, 0x00, 0x65, 0x00, 0x44, 0x00, 0x79, 0x00, 0x6E, 0x00,
	0x61, 0x00, 0x6D, 0x00, 0x69, 0x00, 0x63, 0x00, 0x50, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x63, 0x00,
	0x65, 0x00, 0x64, 0x00, 0x75, 0x00, 0x72, 0x00, 0x65, 0x00, 0x53, 0x00, 0x63, 0x00, 0x61, 0x00,
	0x6E, 0x00, 0x00, 0x00, 0x53, 0x00, 0x65, 0x00, 0x63, 0x00, 0x75, 0x00, 0x72, 0x00, 0x69, 0x00,
	0x74, 0x00, 0x79, 0x00, 0x4C, 0x00, 0x65, 0x00, 0x76, 0x00, 0x65, 0x00, 0x6C, 0x00, 0x00, 0x00,
	0x5C, 0x00, 0x50, 0x00, 0x61, 0x00, 0x72, 0x00, 0x61, 0x00, 0x6D, 0x00, 0x65, 0x00, 0x74, 0x00,
	0x65, 0x00, 0x72, 0x00, 0x73, 0x00, 0x00, 0x00, 0x5C, 0x00, 0x44, 0x00, 0x65, 0x00, 0x76, 0x00,
	0x69, 0x00, 0x63, 0x00, 0x65, 0x00, 0x5C, 0x00, 0x4B, 0x00, 0x50, 0x00, 0x72, 0x00, 0x6F, 0x00,
	0x63, 0x00, 0x65, 0x00, 0x73, 0x00, 0x73, 0x00, 0x48, 0x00, 0x61, 0x00, 0x63, 0x00, 0x6B, 0x00,
	0x65, 0x00, 0x72, 0x00, 0x32, 0x00, 0x00, 0x00, 0x49, 0x00, 0x6F, 0x00, 0x53, 0x00, 0x65, 0x00,
	0x74, 0x00, 0x49, 0x00, 0x6F, 0x00, 0x43, 0x00, 0x6F, 0x00, 0x6D, 0x00, 0x70, 0x00, 0x6C, 0x00,
	0x65, 0x00, 0x74, 0x00, 0x69, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x00, 0x00, 0x52, 0x00, 0x74, 0x00,
	0x6C, 0x00, 0x4D, 0x00, 0x61, 0x00, 0x70, 0x00, 0x47, 0x00, 0x65, 0x00, 0x6E, 0x00, 0x65, 0x00,
	0x72, 0x00, 0x69, 0x00, 0x63, 0x00, 0x4D, 0x00, 0x61, 0x00, 0x73, 0x00, 0x6B, 0x00, 0x00, 0x00,
	0x4C, 0x00, 0x73, 0x00, 0x61, 0x00, 0x46, 0x00, 0x72, 0x00, 0x65, 0x00, 0x65, 0x00, 0x52, 0x00,
	0x65, 0x00, 0x74, 0x00, 0x75, 0x00, 0x72, 0x00, 0x6E, 0x00, 0x42, 0x00, 0x75, 0x00, 0x66, 0x00,
	0x66, 0x00, 0x65, 0x00, 0x72, 0x00, 0x00, 0x00, 0x52, 0x00, 0x74, 0x00, 0x6C, 0x00, 0x43, 0x00,
	0x72, 0x00, 0x65, 0x00, 0x61, 0x00, 0x74, 0x00, 0x65, 0x00, 0x48, 0x00, 0x65, 0x00, 0x61, 0x00,
	0x70, 0x00, 0x00, 0x00, 0x4E, 0x00, 0x74, 0x00, 0x43, 0x00, 0x6C, 0x00, 0x6F, 0x00, 0x73, 0x00,
	0x65, 0x00, 0x00, 0x00, 0x44, 0x00, 0x79, 0x00, 0x6E, 0x00, 0x61, 0x00, 0x6D, 0x00, 0x69, 0x00,
	0x63, 0x00, 0x43, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x66, 0x00, 0x69, 0x00, 0x67, 0x00, 0x75, 0x00,
	0x72, 0x00, 0x61, 0x00, 0x74, 0x00, 0x69, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x00, 0x00, 0x50, 0x00,
	0x73, 0x00, 0x53, 0x00, 0x75, 0x00, 0x73, 0x00, 0x70, 0x00, 0x65, 0x00, 0x6E, 0x00, 0x64, 0x00,
	0x50, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x63, 0x00, 0x65, 0x00, 0x73, 0x00, 0x73, 0x00, 0x00, 0x00,
	0x50, 0x00, 0x73, 0x00, 0x52, 0x00, 0x65, 0x00, 0x73, 0x00, 0x75, 0x00, 0x6D, 0x00, 0x65, 0x00,
	0x50, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x63, 0x00, 0x65, 0x00, 0x73, 0x00, 0x73, 0x00, 0x00, 0x00,
	0x50, 0x00, 0x73, 0x00, 0x52, 0x00, 0x65, 0x00, 0x6C, 0x00, 0x65, 0x00, 0x61, 0x00, 0x73, 0x00,
	0x65, 0x00, 0x50, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x63, 0x00, 0x65, 0x00, 0x73, 0x00, 0x73, 0x00,
	0x45, 0x00, 0x78, 0x00, 0x69, 0x00, 0x74, 0x00, 0x53, 0x00, 0x79, 0x00, 0x6E, 0x00, 0x63, 0x00,
	0x68, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x69, 0x00, 0x7A, 0x00, 0x61, 0x00, 0x74, 0x00,
	0x69, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x00, 0x00, 0x50, 0x00, 0x73, 0x00, 0x49, 0x00, 0x73, 0x00,
	0x50, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x74, 0x00, 0x65, 0x00, 0x63, 0x00, 0x74, 0x00, 0x65, 0x00,
	0x64, 0x00, 0x50, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x63, 0x00, 0x65, 0x00, 0x73, 0x00, 0x73, 0x00,
	0x00, 0x00, 0x50, 0x00, 0x73, 0x00, 0x41, 0x00, 0x63, 0x00, 0x71, 0x00, 0x75, 0x00, 0x69, 0x00,
	0x72, 0x00, 0x65, 0x00, 0x50, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x63, 0x00, 0x65, 0x00, 0x73, 0x00,
	0x73, 0x00, 0x45, 0x00, 0x78, 0x00, 0x69, 0x00, 0x74, 0x00, 0x53, 0x00, 0x79, 0x00, 0x6E, 0x00,
	0x63, 0x00, 0x68, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x69, 0x00, 0x7A, 0x00, 0x61, 0x00,
	0x74, 0x00, 0x69, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x00, 0x00, 0x4F, 0x00, 0x62, 0x00, 0x47, 0x00,
	0x65, 0x00, 0x74, 0x00, 0x4F, 0x00, 0x62, 0x00, 0x6A, 0x00, 0x65, 0x00, 0x63, 0x00, 0x74, 0x00,
	0x54, 0x00, 0x79, 0x00, 0x70, 0x00, 0x65, 0x00, 0x00, 0x00, 0x45, 0x00, 0x78, 0x00, 0x66, 0x00,
	0x55, 0x00, 0x6E, 0x00, 0x62, 0x00, 0x6C, 0x00, 0x6F, 0x00, 0x63, 0x00, 0x6B, 0x00, 0x50, 0x00,
	0x75, 0x00, 0x73, 0x00, 0x68, 0x00, 0x4C, 0x00, 0x6F, 0x00, 0x63, 0x00, 0x6B, 0x00, 0x00, 0x00,
	0x45, 0x00, 0x74, 0x00, 0x77, 0x00, 0x52, 0x00, 0x65, 0x00, 0x67, 0x00, 0x69, 0x00, 0x73, 0x00,
	0x74, 0x00, 0x72, 0x00, 0x61, 0x00, 0x74, 0x00, 0x69, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xA1, 0x10, 0x1A, 0x01, 0x00, 0xB9, 0x4E, 0xE6, 0x40, 0xBB, 0x85,
	0xC0, 0x74, 0x04, 0x3B, 0xC1, 0x75, 0x1A, 0xA1, 0x20, 0x13, 0x01, 0x00, 0x8B, 0x00, 0x35, 0x10,
	0x1A, 0x01, 0x00, 0xA3, 0x10, 0x1A, 0x01, 0x00, 0x75, 0x07, 0x8B, 0xC1, 0xA3, 0x10, 0x1A, 0x01,
	0x00, 0xF7, 0xD0, 0xA3, 0x14, 0x1A, 0x01, 0x00, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x8B, 0xFF,
	0x55, 0x8B, 0xEC, 0xE8, 0xBD, 0xFF, 0xFF, 0xFF, 0x5D, 0xE9, 0x3A, 0xC6, 0xFF, 0xFF, 0xCC, 0xCC,
	0x18, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x5F, 0x00, 0x00,
	0x0C, 0x12, 0x00, 0x00, 0x0C, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xAE, 0x5F, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x92, 0x5F, 0x00, 0x00,
	0xA0, 0x5F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x59, 0x00, 0x00, 0x9C, 0x59, 0x00, 0x00,
	0xAE, 0x59, 0x00, 0x00, 0xB8, 0x59, 0x00, 0x00, 0xCC, 0x59, 0x00, 0x00, 0xD8, 0x59, 0x00, 0x00,
	0xF0, 0x59, 0x00, 0x00, 0x08, 0x5A, 0x00, 0x00, 0x12, 0x5A, 0x00, 0x00, 0x22, 0x5A, 0x00, 0x00,
	0x3E, 0x5A, 0x00, 0x00, 0x50, 0x5A, 0x00, 0x00, 0x60, 0x5A, 0x00, 0x00, 0x74, 0x5A, 0x00, 0x00,
	0x84, 0x5A, 0x00, 0x00, 0xA0, 0x5A, 0x00, 0x00, 0xB4, 0x5A, 0x00, 0x00, 0xCC, 0x5A, 0x00, 0x00,
	0xE8, 0x5A, 0x00, 0x00, 0xF8, 0x5A, 0x00, 0x00, 0x0C, 0x5B, 0x00, 0x00, 0x26, 0x5B, 0x00, 0x00,
	0x3E, 0x5B, 0x00, 0x00, 0x56, 0x5B, 0x00, 0x00, 0x70, 0x5B, 0x00, 0x00, 0x88, 0x5B, 0x00, 0x00,
	0x98, 0x5B, 0x00, 0x00, 0xAE, 0x5B, 0x00, 0x00, 0xC4, 0x5B, 0x00, 0x00, 0xD8, 0x5B, 0x00, 0x00,
	0xEE, 0x5B, 0x00, 0x00, 0x06, 0x5C, 0x00, 0x00, 0x22, 0x5C, 0x00, 0x00, 0x3E, 0x5C, 0x00, 0x00,
	0x5C, 0x5C, 0x00, 0x00, 0x70, 0x59, 0x00, 0x00, 0x76, 0x5C, 0x00, 0x00, 0x94, 0x5C, 0x00, 0x00,
	0xB2, 0x5C, 0x00, 0x00, 0xCE, 0x5C, 0x00, 0x00, 0xE2, 0x5C, 0x00, 0x00, 0xFC, 0x5C, 0x00, 0x00,
	0x08, 0x5D, 0x00, 0x00, 0x1A, 0x5D, 0x00, 0x00, 0x30, 0x5D, 0x00, 0x00, 0x4E, 0x5D, 0x00, 0x00,
	0x6C, 0x5D, 0x00, 0x00, 0x86, 0x5D, 0x00, 0x00, 0x9C, 0x5D, 0x00, 0x00, 0xAC, 0x5D, 0x00, 0x00,
	0xC8, 0x5D, 0x00, 0x00, 0xDC, 0x5D, 0x00, 0x00, 0xEA, 0x5D, 0x00, 0x00, 0x00, 0x5E, 0x00, 0x00,
	0x16, 0x5E, 0x00, 0x00, 0x2A, 0x5E, 0x00, 0x00, 0x44, 0x5E, 0x00, 0x00, 0x62, 0x5E, 0x00, 0x00,
	0x7C, 0x5E, 0x00, 0x00, 0x94, 0x5E, 0x00, 0x00, 0xA8, 0x5E, 0x00, 0x00, 0xBA, 0x5E, 0x00, 0x00,
	0xCE, 0x5E, 0x00, 0x00, 0xDE, 0x5E, 0x00, 0x00, 0xF4, 0x5E, 0x00, 0x00, 0x04, 0x5F, 0x00, 0x00,
	0x24, 0x5F, 0x00, 0x00, 0x3A, 0x5F, 0x00, 0x00, 0x52, 0x5F, 0x00, 0x00, 0x66, 0x5F, 0x00, 0x00,
	0x74, 0x5F, 0x00, 0x00, 0x5A, 0x59, 0x00, 0x00, 0x6C, 0x5C, 0x00, 0x00, 0x48, 0x59, 0x00, 0x00,
	0xB6, 0x5F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4F, 0x01, 0x49, 0x6F, 0x44, 0x65, 0x6C, 0x65,
	0x74, 0x65, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x00, 0x00, 0xE3, 0x01, 0x49, 0x6F, 0x66, 0x43,
	0x6F, 0x6D, 0x70, 0x6C, 0x65, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x00, 0x00,
	0xD5, 0x04, 0x53, 0x65, 0x50, 0x72, 0x69, 0x76, 0x69, 0x6C, 0x65, 0x67, 0x65, 0x43, 0x68, 0x65,
	0x63, 0x6B, 0x00, 0x00, 0x53, 0x03, 0x50, 0x73, 0x47, 0x65, 0x74, 0x43, 0x75, 0x72, 0x72, 0x65,
	0x6E, 0x74, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x49, 0x64, 0x00, 0x51, 0x05, 0x5A, 0x77,
	0x51, 0x75, 0x65, 0x72, 0x79, 0x56, 0x61, 0x6C, 0x75, 0x65, 0x4B, 0x65, 0x79, 0x00, 0x0B, 0x05,
	0x5A, 0x77, 0x43, 0x6C, 0x6F, 0x73, 0x65, 0x00, 0x4E, 0x00, 0x45, 0x78, 0x46, 0x72, 0x65, 0x65,
	0x50, 0x6F, 0x6F, 0x6C, 0x57, 0x69, 0x74, 0x68, 0x54, 0x61, 0x67, 0x00, 0x31, 0x05, 0x5A, 0x77,
	0x4F, 0x70, 0x65, 0x6E, 0x4B, 0x65, 0x79, 0x00, 0x41, 0x00, 0x45, 0x78, 0x41, 0x6C, 0x6C, 0x6F,
	0x63, 0x61, 0x74, 0x65, 0x50, 0x6F, 0x6F, 0x6C, 0x57, 0x69, 0x74, 0x68, 0x54, 0x61, 0x67, 0x00,
	0x1D, 0x04, 0x52, 0x74, 0x6C, 0x49, 0x6E, 0x69, 0x74, 0x55, 0x6E, 0x69, 0x63, 0x6F, 0x64, 0x65,
	0x53, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x00, 0x00, 0xA7, 0x05, 0x6D, 0x65, 0x6D, 0x63, 0x70, 0x79,
	0x00, 0x00, 0x45, 0x03, 0x50, 0x72, 0x6F, 0x62, 0x65, 0x46, 0x6F, 0x72, 0x57, 0x72, 0x69, 0x74,
	0x65, 0x00, 0x50, 0x05, 0x5A, 0x77, 0x51, 0x75, 0x65, 0x72, 0x79, 0x53, 0x79, 0x73, 0x74, 0x65,
	0x6D, 0x49, 0x6E, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x00, 0x00, 0x3E, 0x01,
	0x49, 0x6F, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x00, 0x00,
	0x44, 0x03, 0x50, 0x72, 0x6F, 0x62, 0x65, 0x46, 0x6F, 0x72, 0x52, 0x65, 0x61, 0x64, 0x00, 0x00,
	0xBA, 0x03, 0x52, 0x74, 0x6C, 0x43, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 0x4D, 0x65, 0x6D, 0x6F,
	0x72, 0x79, 0x00, 0x00, 0x16, 0x04, 0x52, 0x74, 0x6C, 0x47, 0x65, 0x74, 0x56, 0x65, 0x72, 0x73,
	0x69, 0x6F, 0x6E, 0x00, 0xA1, 0x02, 0x4D, 0x6D, 0x47, 0x65, 0x74, 0x53, 0x79, 0x73, 0x74, 0x65,
	0x6D, 0x52, 0x6F, 0x75, 0x74, 0x69, 0x6E, 0x65, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x00,
	0x4A, 0x00, 0x45, 0x78, 0x45, 0x6E, 0x75, 0x6D, 0x48, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x54, 0x61,
	0x62, 0x6C, 0x65, 0x00, 0x30, 0x03, 0x4F, 0x62, 0x66, 0x44, 0x65, 0x72, 0x65, 0x66, 0x65, 0x72,
	0x65, 0x6E, 0x63, 0x65, 0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x00, 0x00, 0x28, 0x03, 0x4F, 0x62,
	0x52, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6E, 0x63, 0x65, 0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x42,
	0x79, 0x48, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x00, 0x80, 0x03, 0x50, 0x73, 0x50, 0x72, 0x6F, 0x63,
	0x65, 0x73, 0x73, 0x54, 0x79, 0x70, 0x65, 0x00, 0x26, 0x03, 0x4F, 0x62, 0x51, 0x75, 0x65, 0x72,
	0x79, 0x4E, 0x61, 0x6D, 0x65, 0x53, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x00, 0x67, 0x02, 0x4B, 0x65,
	0x55, 0x6E, 0x73, 0x74, 0x61, 0x63, 0x6B, 0x44, 0x65, 0x74, 0x61, 0x63, 0x68, 0x50, 0x72, 0x6F,
	0x63, 0x65, 0x73, 0x73, 0x00, 0x00, 0x2D, 0x03, 0x4F, 0x62, 0x53, 0x65, 0x74, 0x48, 0x61, 0x6E,
	0x64, 0x6C, 0x65, 0x41, 0x74, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x73, 0x00, 0x63, 0x02,
	0x4B, 0x65, 0x53, 0x74, 0x61, 0x63, 0x6B, 0x41, 0x74, 0x74, 0x61, 0x63, 0x68, 0x50, 0x72, 0x6F,
	0x63, 0x65, 0x73, 0x73, 0x00, 0x00, 0x77, 0x03, 0x50, 0x73, 0x49, 0x6E, 0x69, 0x74, 0x69, 0x61,
	0x6C, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x00, 0x00,
	0x25, 0x03, 0x4F, 0x62, 0x4F, 0x70, 0x65, 0x6E, 0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x42, 0x79,
	0x50, 0x6F, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x00, 0x19, 0x03, 0x4F, 0x62, 0x43, 0x6C, 0x6F, 0x73,
	0x65, 0x48, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x00, 0x69, 0x01, 0x49, 0x6F, 0x47, 0x65, 0x74, 0x43,
	0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x00, 0x24, 0x03,
	0x4F, 0x62, 0x4F, 0x70, 0x65, 0x6E, 0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x42, 0x79, 0x4E, 0x61,
	0x6D, 0x65, 0x00, 0x00, 0x5C, 0x01, 0x49, 0x6F, 0x46, 0x69, 0x6C, 0x65, 0x4F, 0x62, 0x6A, 0x65,
	0x63, 0x74, 0x54, 0x79, 0x70, 0x65, 0x00, 0x00, 0x57, 0x01, 0x49, 0x6F, 0x44, 0x72, 0x69, 0x76,
	0x65, 0x72, 0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x54, 0x79, 0x70, 0x65, 0x00, 0x00, 0xEC, 0x03,
	0x52, 0x74, 0x6C, 0x45, 0x71, 0x75, 0x61, 0x6C, 0x55, 0x6E, 0x69, 0x63, 0x6F, 0x64, 0x65, 0x53,
	0x74, 0x72, 0x69, 0x6E, 0x67, 0x00, 0x48, 0x05, 0x5A, 0x77, 0x51, 0x75, 0x65, 0x72, 0x79, 0x49,
	0x6E, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x54, 0x68, 0x72, 0x65, 0x61, 0x64,
	0x00, 0x00, 0x47, 0x05, 0x5A, 0x77, 0x51, 0x75, 0x65, 0x72, 0x79, 0x49, 0x6E, 0x66, 0x6F, 0x72,
	0x6D, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x00, 0x40, 0x00,
	0x45, 0x78, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x50, 0x6F, 0x6F, 0x6C, 0x57, 0x69,
	0x74, 0x68, 0x51, 0x75, 0x6F, 0x74, 0x61, 0x54, 0x61, 0x67, 0x00, 0x00, 0x4C, 0x05, 0x5A, 0x77,
	0x51, 0x75, 0x65, 0x72, 0x79, 0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x00, 0xA9, 0x05, 0x6D, 0x65,
	0x6D, 0x73, 0x65, 0x74, 0x00, 0x00, 0x7D, 0x03, 0x50, 0x73, 0x4C, 0x6F, 0x6F, 0x6B, 0x75, 0x70,
	0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x42, 0x79, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73,
	0x49, 0x64, 0x00, 0x00, 0x7E, 0x03, 0x50, 0x73, 0x4C, 0x6F, 0x6F, 0x6B, 0x75, 0x70, 0x50, 0x72,
	0x6F, 0x63, 0x65, 0x73, 0x73, 0x54, 0x68, 0x72, 0x65, 0x61, 0x64, 0x42, 0x79, 0x43, 0x69, 0x64,
	0x00, 0x00, 0x4E, 0x03, 0x50, 0x73, 0x44, 0x65, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6E, 0x63,
	0x65, 0x50, 0x72, 0x69, 0x6D, 0x61, 0x72, 0x79, 0x54, 0x6F, 0x6B, 0x65, 0x6E, 0x00, 0xE8, 0x04,
	0x53, 0x65, 0x54, 0x6F, 0x6B, 0x65, 0x6E, 0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x54, 0x79, 0x70,
	0x65, 0x00, 0x82, 0x03, 0x50, 0x73, 0x52, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6E, 0x63, 0x65, 0x50,
	0x72, 0x69, 0x6D, 0x61, 0x72, 0x79, 0x54, 0x6F, 0x6B, 0x65, 0x6E, 0x00, 0x7C, 0x03, 0x50, 0x73,
	0x4A, 0x6F, 0x62, 0x54, 0x79, 0x70, 0x65, 0x00, 0x65, 0x03, 0x50, 0x73, 0x47, 0x65, 0x74, 0x50,
	0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x4A, 0x6F, 0x62, 0x00, 0x6C, 0x05, 0x5A, 0x77, 0x54, 0x65,
	0x72, 0x6D, 0x69, 0x6E, 0x61, 0x74, 0x65, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x00, 0x00,
	0x39, 0x00, 0x45, 0x78, 0x41, 0x63, 0x71, 0x75, 0x69, 0x72, 0x65, 0x52, 0x75, 0x6E, 0x64, 0x6F,
	0x77, 0x6E, 0x50, 0x72, 0x6F, 0x74, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x00, 0x00, 0x7C, 0x00,
	0x45, 0x78, 0x52, 0x65, 0x6C, 0x65, 0x61, 0x73, 0x65, 0x52, 0x75, 0x6E, 0x64, 0x6F, 0x77, 0x6E,
	0x50, 0x72, 0x6F, 0x74, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x00, 0x00, 0x63, 0x05, 0x5A, 0x77,
	0x53, 0x65, 0x74, 0x49, 0x6E, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x50, 0x72,
	0x6F, 0x63, 0x65, 0x73, 0x73, 0x00, 0x07, 0x02, 0x4B, 0x65, 0x47, 0x65, 0x74, 0x43, 0x75, 0x72,
	0x72, 0x65, 0x6E, 0x74, 0x54, 0x68, 0x72, 0x65, 0x61, 0x64, 0x00, 0x00, 0x99, 0x03, 0x50, 0x73,
	0x54, 0x68, 0x72, 0x65, 0x61, 0x64, 0x54, 0x79, 0x70, 0x65, 0x00, 0x00, 0x7F, 0x03, 0x50, 0x73,
	0x4C, 0x6F, 0x6F, 0x6B, 0x75, 0x70, 0x54, 0x68, 0x72, 0x65, 0x61, 0x64, 0x42, 0x79, 0x54, 0x68,
	0x72, 0x65, 0x61, 0x64, 0x49, 0x64, 0x00, 0x00, 0xC4, 0x01, 0x49, 0x6F, 0x54, 0x68, 0x72, 0x65,
	0x61, 0x64, 0x54, 0x6F, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x00, 0x56, 0x02, 0x4B, 0x65,
	0x53, 0x65, 0x74, 0x45, 0x76, 0x65, 0x6E, 0x74, 0x00, 0x00, 0x51, 0x03, 0x50, 0x73, 0x47, 0x65,
	0x74, 0x43, 0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0x54, 0x68, 0x72, 0x65, 0x61, 0x64, 0x00, 0x00,
	0x8B, 0x03, 0x50, 0x73, 0x53, 0x65, 0x74, 0x43, 0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0x54, 0x68,
	0x72, 0x65, 0x61, 0x64, 0x00, 0x00, 0xB1, 0x04, 0x52, 0x74, 0x6C, 0x57, 0x61, 0x6C, 0x6B, 0x46,
	0x72, 0x61, 0x6D, 0x65, 0x43, 0x68, 0x61, 0x69, 0x6E, 0x00, 0x74, 0x03, 0x50, 0x73, 0x47, 0x65,
	0x74, 0x54, 0x68, 0x72, 0x65, 0x61, 0x64, 0x57, 0x69, 0x6E, 0x33, 0x32, 0x54, 0x68, 0x72, 0x65,
	0x61, 0x64, 0x00, 0x00, 0x46, 0x03, 0x50, 0x73, 0x41, 0x73, 0x73, 0x69, 0x67, 0x6E, 0x49, 0x6D,
	0x70, 0x65, 0x72, 0x73, 0x6F, 0x6E, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x54, 0x6F, 0x6B, 0x65, 0x6E,
	0x00, 0x00, 0x64, 0x05, 0x5A, 0x77, 0x53, 0x65, 0x74, 0x49, 0x6E, 0x66, 0x6F, 0x72, 0x6D, 0x61,
	0x74, 0x69, 0x6F, 0x6E, 0x54, 0x68, 0x72, 0x65, 0x61, 0x64, 0x00, 0x00, 0x6D, 0x02, 0x4B, 0x65,
	0x57, 0x61, 0x69, 0x74, 0x46, 0x6F, 0x72, 0x53, 0x69, 0x6E, 0x67, 0x6C, 0x65, 0x4F, 0x62, 0x6A,
	0x65, 0x63, 0x74, 0x00, 0x25, 0x02, 0x4B, 0x65, 0x49, 0x6E, 0x73, 0x65, 0x72, 0x74, 0x51, 0x75,
	0x65, 0x75, 0x65, 0x41, 0x70, 0x63, 0x00, 0x00, 0x15, 0x02, 0x4B, 0x65, 0x49, 0x6E, 0x69, 0x74,
	0x69, 0x61, 0x6C, 0x69, 0x7A, 0x65, 0x41, 0x70, 0x63, 0x00, 0x18, 0x02, 0x4B, 0x65, 0x49, 0x6E,
	0x69, 0x74, 0x69, 0x61, 0x6C, 0x69, 0x7A, 0x65, 0x45, 0x76, 0x65, 0x6E, 0x74, 0x00, 0xCB, 0x02,
	0x4D, 0x6D, 0x55, 0x6E, 0x6C, 0x6F, 0x63, 0x6B, 0x50, 0x61, 0x67, 0x65, 0x73, 0x00, 0xCD, 0x02,
	0x4D, 0x6D, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x4C, 0x6F, 0x63, 0x6B, 0x65, 0x64, 0x50, 0x61, 0x67,
	0x65, 0x73, 0x00, 0x00, 0x75, 0x00, 0x45, 0x78, 0x52, 0x61, 0x69, 0x73, 0x65, 0x53, 0x74, 0x61,
	0x74, 0x75, 0x73, 0x00, 0xB0, 0x02, 0x4D, 0x6D, 0x4D, 0x61, 0x70, 0x4C, 0x6F, 0x63, 0x6B, 0x65,
	0x64, 0x50, 0x61, 0x67, 0x65, 0x73, 0x53, 0x70, 0x65, 0x63, 0x69, 0x66, 0x79, 0x43, 0x61, 0x63,
	0x68, 0x65, 0x00, 0x00, 0xBC, 0x02, 0x4D, 0x6D, 0x50, 0x72, 0x6F, 0x62, 0x65, 0x41, 0x6E, 0x64,
	0x4C, 0x6F, 0x63, 0x6B, 0x50, 0x61, 0x67, 0x65, 0x73, 0x00, 0xA4, 0x02, 0x4D, 0x6D, 0x48, 0x69,
	0x67, 0x68, 0x65, 0x73, 0x74, 0x55, 0x73, 0x65, 0x72, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,
	0x00, 0x00, 0xA5, 0x02, 0x4D, 0x6D, 0x49, 0x73, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x56,
	0x61, 0x6C, 0x69, 0x64, 0x00, 0x00, 0x66, 0x02, 0x4B, 0x65, 0x54, 0x69, 0x63, 0x6B, 0x43, 0x6F,
	0x75, 0x6E, 0x74, 0x00, 0xF6, 0x01, 0x4B, 0x65, 0x42, 0x75, 0x67, 0x43, 0x68, 0x65, 0x63, 0x6B,
	0x45, 0x78, 0x00, 0x00, 0x6E, 0x74, 0x6F, 0x73, 0x6B, 0x72, 0x6E, 0x6C, 0x2E, 0x65, 0x78, 0x65,
	0x00, 0x00, 0x4D, 0x00, 0x4B, 0x66, 0x4C, 0x6F, 0x77, 0x65, 0x72, 0x49, 0x72, 0x71, 0x6C, 0x00,
	0x4E, 0x00, 0x4B, 0x66, 0x52, 0x61, 0x69, 0x73, 0x65, 0x49, 0x72, 0x71, 0x6C, 0x00, 0x48, 0x41,
	0x4C, 0x2E, 0x64, 0x6C, 0x6C, 0x00, 0xA0, 0x04, 0x52, 0x74, 0x6C, 0x55, 0x6E, 0x77, 0x69, 0x6E,
	0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
	0x10, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x80,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
	0x09, 0x04, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x60, 0x60, 0x00, 0x00, 0x98, 0x02, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x98, 0x02, 0x34, 0x00, 0x00, 0x00, 0x56, 0x00, 0x53, 0x00, 0x5F, 0x00, 0x56, 0x00, 0x45, 0x00,
	0x52, 0x00, 0x53, 0x00, 0x49, 0x00, 0x4F, 0x00, 0x4E, 0x00, 0x5F, 0x00, 0x49, 0x00, 0x4E, 0x00,
	0x46, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xBD, 0x04, 0xEF, 0xFE, 0x00, 0x00, 0x01, 0x00,
	0x08, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
	0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x01, 0x00, 0x00,
	0x01, 0x00, 0x53, 0x00, 0x74, 0x00, 0x72, 0x00, 0x69, 0x00, 0x6E, 0x00, 0x67, 0x00, 0x46, 0x00,
	0x69, 0x00, 0x6C, 0x00, 0x65, 0x00, 0x49, 0x00, 0x6E, 0x00, 0x66, 0x00, 0x6F, 0x00, 0x00, 0x00,
	0xD4, 0x01, 0x00, 0x00, 0x01, 0x00, 0x30, 0x00, 0x34, 0x00, 0x30, 0x00, 0x39, 0x00, 0x30, 0x00,
	0x34, 0x00, 0x45, 0x00, 0x34, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x05, 0x00, 0x01, 0x00, 0x43, 0x00,
	0x6F, 0x00, 0x6D, 0x00, 0x70, 0x00, 0x61, 0x00, 0x6E, 0x00, 0x79, 0x00, 0x4E, 0x00, 0x61, 0x00,
	0x6D, 0x00, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x6A, 0x00, 0x33, 0x00, 0x32, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x46, 0x00, 0x0F, 0x00, 0x01, 0x00, 0x46, 0x00, 0x69, 0x00, 0x6C, 0x00,
	0x65, 0x00, 0x44, 0x00, 0x65, 0x00, 0x73, 0x00, 0x63, 0x00, 0x72, 0x00, 0x69, 0x00, 0x70, 0x00,
	0x74, 0x00, 0x69, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4B, 0x00, 0x50, 0x00,
	0x72, 0x00, 0x6F, 0x00, 0x63, 0x00, 0x65, 0x00, 0x73, 0x00, 0x73, 0x00, 0x48, 0x00, 0x61, 0x00,
	0x63, 0x00, 0x6B, 0x00, 0x65, 0x00, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x04, 0x00,
	0x01, 0x00, 0x46, 0x00, 0x69, 0x00, 0x6C, 0x00, 0x65, 0x00, 0x56, 0x00, 0x65, 0x00, 0x72, 0x00,
	0x73, 0x00, 0x69, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x2E, 0x00,
	0x38, 0x00, 0x00, 0x00, 0x64, 0x00, 0x20, 0x00, 0x01, 0x00, 0x4C, 0x00, 0x65, 0x00, 0x67, 0x00,
	0x61, 0x00, 0x6C, 0x00, 0x43, 0x00, 0x6F, 0x00, 0x70, 0x00, 0x79, 0x00, 0x72, 0x00, 0x69, 0x00,
	0x67, 0x00, 0x68, 0x00, 0x74, 0x00, 0x00, 0x00, 0x4C, 0x00, 0x69, 0x00, 0x63, 0x00, 0x65, 0x00,
	0x6E, 0x00, 0x73, 0x00, 0x65, 0x00, 0x64, 0x00, 0x20, 0x00, 0x75, 0x00, 0x6E, 0x00, 0x64, 0x00,
	0x65, 0x00, 0x72, 0x00, 0x20, 0x00, 0x74, 0x00, 0x68, 0x00, 0x65, 0x00, 0x20, 0x00, 0x47, 0x00,
	0x4E, 0x00, 0x55, 0x00, 0x20, 0x00, 0x47, 0x00, 0x50, 0x00, 0x4C, 0x00, 0x2C, 0x00, 0x20, 0x00,
	0x76, 0x00, 0x33, 0x00, 0x2E, 0x00, 0x00, 0x00, 0x4E, 0x00, 0x13, 0x00, 0x01, 0x00, 0x4F, 0x00,
	0x72, 0x00, 0x69, 0x00, 0x67, 0x00, 0x69, 0x00, 0x6E, 0x00, 0x61, 0x00, 0x6C, 0x00, 0x46, 0x00,
	0x69, 0x00, 0x6C, 0x00, 0x65, 0x00, 0x6E, 0x00, 0x61, 0x00, 0x6D, 0x00, 0x65, 0x00, 0x00, 0x00,
	0x6B, 0x00, 0x70, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x63, 0x00, 0x65, 0x00, 0x73, 0x00, 0x73, 0x00,
	0x68, 0x00, 0x61, 0x00, 0x63, 0x00, 0x6B, 0x00, 0x65, 0x00, 0x72, 0x00, 0x2E, 0x00, 0x73, 0x00,
	0x79, 0x00, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x0F, 0x00, 0x01, 0x00, 0x50, 0x00,
	0x72, 0x00, 0x6F, 0x00, 0x64, 0x00, 0x75, 0x00, 0x63, 0x00, 0x74, 0x00, 0x4E, 0x00, 0x61, 0x00,
	0x6D, 0x00, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4B, 0x00, 0x50, 0x00, 0x72, 0x00, 0x6F, 0x00,
	0x63, 0x00, 0x65, 0x00, 0x73, 0x00, 0x73, 0x00, 0x48, 0x00, 0x61, 0x00, 0x63, 0x00, 0x6B, 0x00,
	0x65, 0x00, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2C, 0x00, 0x04, 0x00, 0x01, 0x00, 0x50, 0x00,
	0x72, 0x00, 0x6F, 0x00, 0x64, 0x00, 0x75, 0x00, 0x63, 0x00, 0x74, 0x00, 0x56, 0x00, 0x65, 0x00,
	0x72, 0x00, 0x73, 0x00, 0x69, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x00, 0x00, 0x32, 0x00, 0x2E, 0x00,
	0x38, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x01, 0x00, 0x56, 0x00, 0x61, 0x00, 0x72, 0x00,
	0x46, 0x00, 0x69, 0x00, 0x6C, 0x00, 0x65, 0x00, 0x49, 0x00, 0x6E, 0x00, 0x66, 0x00, 0x6F, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x04, 0x00, 0x00, 0x00, 0x54, 0x00, 0x72, 0x00, 0x61, 0x00,
	0x6E, 0x00, 0x73, 0x00, 0x6C, 0x00, 0x61, 0x00, 0x74, 0x00, 0x69, 0x00, 0x6F, 0x00, 0x6E, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x09, 0x04, 0xE4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x8F, 0x34, 0x9F, 0x34, 0xB5, 0x34, 0xE2, 0x34,
	0x03, 0x35, 0x45, 0x35, 0x5B, 0x35, 0x69, 0x35, 0xFC, 0x35, 0x19, 0x36, 0x5F, 0x36, 0x3D, 0x3B,
	0x97, 0x3B, 0xCB, 0x3B, 0xE2, 0x3B, 0x2C, 0x3C, 0x7E, 0x3C, 0xBC, 0x3C, 0xC6, 0x3C, 0xDE, 0x3C,
	0xF2, 0x3C, 0x06, 0x3D, 0x12, 0x3D, 0x22, 0x3D, 0x68, 0x3D, 0xFD, 0x3D, 0x1D, 0x3E, 0x23, 0x3E,
	0x31, 0x3E, 0x3E, 0x3E, 0x4A, 0x3E, 0x55, 0x3E, 0x72, 0x3E, 0xD2, 0x3E, 0xB0, 0x3F, 0x00, 0x00,
	0x00, 0x10, 0x00, 0x00, 0x74, 0x01, 0x00, 0x00, 0x03, 0x30, 0x1D, 0x30, 0x3A, 0x30, 0x8D, 0x30,
	0x99, 0x30, 0x91, 0x31, 0xC6, 0x31, 0x9C, 0x33, 0xA0, 0x33, 0x2C, 0x34, 0x30, 0x34, 0x4C, 0x34,
	0x50, 0x34, 0x6C, 0x34, 0x70, 0x34, 0x78, 0x34, 0x7C, 0x34, 0x94, 0x34, 0x98, 0x34, 0xB4, 0x34,
	0xB8, 0x34, 0xC0, 0x34, 0xC4, 0x34, 0xCC, 0x34, 0xD0, 0x34, 0xEC, 0x34, 0xF0, 0x34, 0xF8, 0x34,
	0xFC, 0x34, 0x14, 0x35, 0x18, 0x35, 0x20, 0x35, 0x24, 0x35, 0x3C, 0x35, 0x40, 0x35, 0x48, 0x35,
	0x4C, 0x35, 0x64, 0x35, 0x68, 0x35, 0x70, 0x35, 0x74, 0x35, 0x7C, 0x35, 0x80, 0x35, 0x88, 0x35,
	0x8C, 0x35, 0x94, 0x35, 0x98, 0x35, 0xA0, 0x35, 0xA4, 0x35, 0xAC, 0x35, 0xB0, 0x35, 0xB8, 0x35,
	0xBC, 0x35, 0xC4, 0x35, 0xC8, 0x35, 0xD0, 0x35, 0xD4, 0x35, 0xDC, 0x35, 0xE0, 0x35, 0xFC, 0x35,
	0x00, 0x36, 0x08, 0x36, 0x0C, 0x36, 0x24, 0x36, 0x28, 0x36, 0x30, 0x36, 0x34, 0x36, 0x4C, 0x36,
	0x50, 0x36, 0x58, 0x36, 0x5C, 0x36, 0x74, 0x36, 0x78, 0x36, 0x80, 0x36, 0x84, 0x36, 0x8C, 0x36,
	0x90, 0x36, 0x98, 0x36, 0x9C, 0x36, 0xA4, 0x36, 0xA8, 0x36, 0xC4, 0x36, 0xC8, 0x36, 0xD0, 0x36,
	0xD4, 0x36, 0xDC, 0x36, 0xE0, 0x36, 0xFC, 0x36, 0x00, 0x37, 0x08, 0x37, 0x0C, 0x37, 0x24, 0x37,
	0x28, 0x37, 0x30, 0x37, 0x34, 0x37, 0x4C, 0x37, 0x50, 0x37, 0x58, 0x37, 0x5C, 0x37, 0x74, 0x37,
	0x78, 0x37, 0x80, 0x37, 0x84, 0x37, 0x8C, 0x37, 0x90, 0x37, 0x98, 0x37, 0x9C, 0x37, 0xB4, 0x37,
	0xB8, 0x37, 0xC0, 0x37, 0xC4, 0x37, 0xCC, 0x37, 0xD0, 0x37, 0xEC, 0x37, 0xF0, 0x37, 0xF8, 0x37,
	0xFC, 0x37, 0x04, 0x38, 0x08, 0x38, 0x24, 0x38, 0x28, 0x38, 0x44, 0x38, 0x48, 0x38, 0x50, 0x38,
	0x54, 0x38, 0x6C, 0x38, 0x70, 0x38, 0x78, 0x38, 0x7C, 0x38, 0x94, 0x38, 0x98, 0x38, 0xA0, 0x38,
	0xA4, 0x38, 0xAC, 0x38, 0xB0, 0x38, 0x08, 0x3C, 0x0E, 0x3C, 0x23, 0x3C, 0x4B, 0x3C, 0x85, 0x3C,
	0x8A, 0x3C, 0xB4, 0x3C, 0x20, 0x3D, 0x2D, 0x3D, 0x3D, 0x3D, 0x56, 0x3D, 0x5B, 0x3D, 0x76, 0x3D,
	0x89, 0x3D, 0x9F, 0x3D, 0xBC, 0x3D, 0xC1, 0x3D, 0xF2, 0x3D, 0x15, 0x3E, 0x34, 0x3E, 0x3E, 0x3E,
	0x58, 0x3E, 0x65, 0x3E, 0x6C, 0x3E, 0x73, 0x3E, 0x7A, 0x3E, 0xE0, 0x3E, 0xEC, 0x3E, 0xFF, 0x3E,
	0x13, 0x3F, 0x32, 0x3F, 0x3C, 0x3F, 0x46, 0x3F, 0x50, 0x3F, 0x5A, 0x3F, 0x64, 0x3F, 0x6E, 0x3F,
	0x78, 0x3F, 0x82, 0x3F, 0x8B, 0x3F, 0x9A, 0x3F, 0x9F, 0x3F, 0xA8, 0x3F, 0xC0, 0x3F, 0xCD, 0x3F,
	0xF6, 0x3F, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x84, 0x01, 0x00, 0x00, 0x00, 0x30, 0x0A, 0x30,
	0x14, 0x30, 0x29, 0x30, 0x2D, 0x30, 0x33, 0x30, 0x3E, 0x30, 0x42, 0x30, 0x48, 0x30, 0x5B, 0x30,
	0x68, 0x30, 0x84, 0x30, 0x8E, 0x30, 0x98, 0x30, 0xA2, 0x30, 0xBD, 0x30, 0xC3, 0x30, 0xC7, 0x30,
	0xCD, 0x30, 0xD8, 0x30, 0xDC, 0x30, 0xE2, 0x30, 0x04, 0x31, 0x11, 0x31, 0x20, 0x31, 0x2A, 0x31,
	0x44, 0x31, 0x4E, 0x31, 0x54, 0x31, 0x5E, 0x31, 0x68, 0x31, 0x72, 0x31, 0x7F, 0x31, 0x85, 0x31,
	0x89, 0x31, 0x8F, 0x31, 0x9E, 0x31, 0xA2, 0x31, 0xA8, 0x31, 0xC4, 0x31, 0xCE, 0x31, 0xDB, 0x31,
	0xF5, 0x31, 0xFF, 0x31, 0x09, 0x32, 0x13, 0x32, 0x19, 0x32, 0x1F, 0x32, 0x2D, 0x32, 0x34, 0x32,
	0x3A, 0x32, 0x3E, 0x32, 0x44, 0x32, 0x4E, 0x32, 0x54, 0x32, 0x5E, 0x32, 0x64, 0x32, 0x72, 0x32,
	0x76, 0x32, 0x7C, 0x32, 0x86, 0x32, 0x99, 0x32, 0xA4, 0x32, 0xB9, 0x32, 0xC3, 0x32, 0xCD, 0x32,
	0xD7, 0x32, 0xDD, 0x32, 0xE3, 0x32, 0xF5, 0x32, 0xF9, 0x32, 0xFF, 0x32, 0x03, 0x33, 0x13, 0x33,
	0x1E, 0x33, 0x30, 0x33, 0x3A, 0x33, 0x44, 0x33, 0x4E, 0x33, 0x58, 0x33, 0x66, 0x33, 0x6A, 0x33,
	0x70, 0x33, 0x74, 0x33, 0x7A, 0x33, 0x89, 0x33, 0x92, 0x33, 0x98, 0x33, 0x9F, 0x33, 0xA5, 0x33,
	0xAB, 0x33, 0xB1, 0x33, 0xB7, 0x33, 0xBD, 0x33, 0xC3, 0x33, 0xC8, 0x33, 0xCE, 0x33, 0xD4, 0x33,
	0xE6, 0x33, 0xFE, 0x33, 0x04, 0x34, 0x0E, 0x34, 0x1A, 0x34, 0x4B, 0x34, 0x55, 0x34, 0x61, 0x34,
	0x8D, 0x34, 0xD6, 0x34, 0xF8, 0x34, 0x02, 0x35, 0x12, 0x35, 0x1A, 0x35, 0x24, 0x35, 0x29, 0x35,
	0x33, 0x35, 0x38, 0x35, 0x42, 0x35, 0x47, 0x35, 0x51, 0x35, 0x56, 0x35, 0x60, 0x35, 0x65, 0x35,
	0x6F, 0x35, 0x74, 0x35, 0x7E, 0x35, 0x8E, 0x35, 0xA8, 0x35, 0xC8, 0x35, 0xE2, 0x35, 0x14, 0x36,
	0x23, 0x36, 0x33, 0x36, 0x96, 0x36, 0xA1, 0x36, 0x51, 0x37, 0x5E, 0x37, 0x67, 0x37, 0x6F, 0x37,
	0x93, 0x37, 0xDC, 0x37, 0xE8, 0x37, 0x05, 0x38, 0x32, 0x38, 0x3A, 0x38, 0x41, 0x38, 0x48, 0x38,
	0x59, 0x38, 0x29, 0x39, 0xBB, 0x39, 0xE5, 0x39, 0xF9, 0x39, 0x05, 0x3A, 0x17, 0x3A, 0x5D, 0x3A,
	0xB9, 0x3A, 0xC7, 0x3A, 0xD3, 0x3A, 0xDC, 0x3A, 0x38, 0x3B, 0x57, 0x3B, 0x76, 0x3B, 0x97, 0x3B,
	0xA9, 0x3B, 0xC5, 0x3B, 0xD7, 0x3B, 0x0B, 0x3C, 0x16, 0x3C, 0x26, 0x3C, 0x4F, 0x3C, 0x76, 0x3C,
	0xAF, 0x3C, 0xBB, 0x3C, 0xD7, 0x3C, 0x4C, 0x3D, 0x55, 0x3D, 0x6B, 0x3D, 0x94, 0x3D, 0xA2, 0x3D,
	0x38, 0x3E, 0x4D, 0x3E, 0xAD, 0x3E, 0xDE, 0x3E, 0x0A, 0x3F, 0x3D, 0x3F, 0x5F, 0x3F, 0x6C, 0x3F,
	0x7E, 0x3F, 0xBE, 0x3F, 0xE3, 0x3F, 0xF1, 0x3F, 0x00, 0x30, 0x00, 0x00, 0x04, 0x01, 0x00, 0x00,
	0x02, 0x30, 0x12, 0x30, 0x7B, 0x30, 0x9A, 0x30, 0xBD, 0x30, 0x4A, 0x31, 0x5C, 0x31, 0x80, 0x31,
	0xAB, 0x31, 0xBC, 0x31, 0xCC, 0x31, 0x33, 0x32, 0x52, 0x32, 0x65, 0x32, 0x75, 0x32, 0xD7, 0x32,
	0xE8, 0x32, 0xF8, 0x32, 0x5E, 0x33, 0x6F, 0x33, 0x7F, 0x33, 0xDD, 0x33, 0xEA, 0x33, 0xF7, 0x33,
	0x0C, 0x34, 0x2B, 0x34, 0x46, 0x34, 0x4E, 0x34, 0x58, 0x34, 0x64, 0x34, 0x82, 0x34, 0x92, 0x34,
	0xFA, 0x34, 0x1D, 0x35, 0x2B, 0x35, 0x42, 0x35, 0xE6, 0x35, 0x03, 0x36, 0x12, 0x36, 0x28, 0x36,
	0x4E, 0x36, 0x5A, 0x36, 0xC1, 0x36, 0x04, 0x37, 0x08, 0x37, 0x0C, 0x37, 0x10, 0x37, 0x14, 0x37,
	0x18, 0x37, 0x1C, 0x37, 0x20, 0x37, 0x24, 0x37, 0x31, 0x37, 0x4E, 0x37, 0x5C, 0x37, 0xB7, 0x37,
	0xC6, 0x37, 0xD3, 0x37, 0xE3, 0x37, 0xF3, 0x37, 0xFE, 0x37, 0x4D, 0x38, 0x69, 0x38, 0x7D, 0x38,
	0x89, 0x38, 0x9A, 0x38, 0xA6, 0x38, 0xB4, 0x38, 0xBD, 0x38, 0xC6, 0x38, 0x39, 0x39, 0x59, 0x39,
	0x92, 0x39, 0x9E, 0x39, 0xAB, 0x39, 0xBA, 0x39, 0xC8, 0x39, 0xDA, 0x39, 0x30, 0x3A, 0x46, 0x3A,
	0x52, 0x3A, 0x5F, 0x3A, 0x6A, 0x3A, 0x84, 0x3A, 0x9A, 0x3A, 0xA6, 0x3A, 0xB3, 0x3A, 0xBE, 0x3A,
	0xD7, 0x3A, 0xE6, 0x3A, 0xF8, 0x3A, 0x59, 0x3B, 0x66, 0x3B, 0x71, 0x3B, 0x94, 0x3B, 0xAA, 0x3B,
	0xBC, 0x3B, 0xC7, 0x3B, 0xD7, 0x3B, 0xEB, 0x3B, 0x16, 0x3C, 0x64, 0x3C, 0x70, 0x3C, 0xA5, 0x3C,
	0xBB, 0x3C, 0xD8, 0x3C, 0x22, 0x3D, 0x31, 0x3D, 0x42, 0x3D, 0x4F, 0x3D, 0x9B, 0x3D, 0xF3, 0x3D,
	0x37, 0x3E, 0x55, 0x3E, 0x91, 0x3E, 0x9E, 0x3E, 0x0B, 0x3F, 0x1F, 0x3F, 0x3A, 0x3F, 0x45, 0x3F,
	0xA0, 0x3F, 0xB0, 0x3F, 0xBC, 0x3F, 0xD4, 0x3F, 0xF1, 0x3F, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00,
	0xDC, 0x00, 0x00, 0x00, 0x57, 0x30, 0x75, 0x30, 0xC2, 0x30, 0xCF, 0x30, 0xF3, 0x31, 0x0B, 0x32,
	0x28, 0x32, 0x36, 0x32, 0x8E, 0x32, 0x97, 0x32, 0xA5, 0x32, 0xB5, 0x32, 0xC0, 0x32, 0x0F, 0x33,
	0x2C, 0x33, 0x65, 0x33, 0x71, 0x33, 0x7E, 0x33, 0x89, 0x33, 0x97, 0x33, 0xA2, 0x33, 0xF8, 0x33,
	0x0C, 0x34, 0x1F, 0x34, 0x48, 0x34, 0x72, 0x34, 0x8B, 0x34, 0xBB, 0x34, 0xC8, 0x34, 0xD3, 0x34,
	0xF5, 0x34, 0x1E, 0x35, 0x25, 0x35, 0x49, 0x35, 0x56, 0x35, 0x6A, 0x35, 0x75, 0x35, 0x95, 0x35,
	0xA2, 0x35, 0xB6, 0x35, 0xC1, 0x35, 0x03, 0x36, 0x15, 0x36, 0x33, 0x36, 0x80, 0x36, 0x8D, 0x36,
	0xC2, 0x36, 0xD6, 0x36, 0xF4, 0x36, 0x3A, 0x37, 0x45, 0x37, 0x88, 0x37, 0xCD, 0x37, 0xEB, 0x37,
	0x24, 0x38, 0x30, 0x38, 0xA2, 0x38, 0xB5, 0x38, 0xD0, 0x38, 0xDB, 0x38, 0x33, 0x39, 0x40, 0x39,
	0x50, 0x39, 0x63, 0x39, 0x75, 0x39, 0x80, 0x39, 0x89, 0x39, 0x92, 0x39, 0xBA, 0x39, 0xC6, 0x39,
	0xD0, 0x39, 0xE7, 0x39, 0xF0, 0x39, 0xFE, 0x39, 0x0C, 0x3A, 0x1E, 0x3A, 0x37, 0x3A, 0x4B, 0x3A,
	0x82, 0x3A, 0x3C, 0x3B, 0x61, 0x3B, 0x7E, 0x3B, 0x9D, 0x3B, 0xB1, 0x3B, 0xBA, 0x3B, 0xC8, 0x3B,
	0xDC, 0x3B, 0xEE, 0x3B, 0x9B, 0x3C, 0xBF, 0x3C, 0xCC, 0x3C, 0xF6, 0x3C, 0x0C, 0x3D, 0xD9, 0x3D,
	0x0A, 0x3E, 0x33, 0x3E, 0x9A, 0x3E, 0xAF, 0x3E, 0xCB, 0x3E, 0xF0, 0x3E, 0x1C, 0x3F, 0x2F, 0x3F,
	0x55, 0x3F, 0x9C, 0x3F, 0xB1, 0x3F, 0xB8, 0x3F, 0x00, 0x50, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00,
	0x07, 0x30, 0x23, 0x30, 0x37, 0x30, 0x56, 0x30, 0xC1, 0x30, 0xE3, 0x30, 0x0C, 0x31, 0x2C, 0x31,
	0x71, 0x31, 0x7D, 0x31, 0x93, 0x31, 0xAB, 0x31, 0xEF, 0x31, 0x18, 0x32, 0x38, 0x32, 0x7D, 0x32,
	0x89, 0x32, 0xA5, 0x32, 0xB7, 0x32, 0xFB, 0x32, 0x2B, 0x33, 0x4A, 0x33, 0x67, 0x33, 0x8D, 0x33,
	0x9C, 0x33, 0x0E, 0x34, 0x1A, 0x34, 0x32, 0x34, 0x48, 0x34, 0x86, 0x37, 0x98, 0x37, 0x9F, 0x37,
	0xA4, 0x37, 0xAD, 0x37, 0xB4, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x98, 0x24, 0x00, 0x00, 0x00, 0x02, 0x02, 0x00, 0x30, 0x82, 0x24, 0x8B, 0x06, 0x09, 0x2A, 0x86,
	0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x02, 0xA0, 0x82, 0x24, 0x7C, 0x30, 0x82, 0x24, 0x78, 0x02,
	0x01, 0x01, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x05, 0x2B, 0x0E, 0x03, 0x02, 0x1A, 0x05, 0x00, 0x30,
	0x4C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x04, 0xA0, 0x3E, 0x30,
	0x3C, 0x30, 0x17, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x0F, 0x30,
	0x09, 0x03, 0x01, 0x00, 0xA0, 0x04, 0xA2, 0x02, 0x80, 0x00, 0x30, 0x21, 0x30, 0x09, 0x06, 0x05,
	0x2B, 0x0E, 0x03, 0x02, 0x1A, 0x05, 0x00, 0x04, 0x14, 0xBD, 0x01, 0xBE, 0xE3, 0x72, 0x99, 0xE1,
	0xF6, 0x50, 0xAC, 0xEF, 0x44, 0x79, 0x6E, 0x95, 0xD8, 0x3D, 0x62, 0x05, 0xDD, 0xA0, 0x82, 0x1F,
	0xDE, 0x30, 0x82, 0x05, 0x3B, 0x30, 0x82, 0x03, 0x23, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x0A,
	0x61, 0x20, 0x4D, 0xB4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86,
	0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x7F, 0x31, 0x0B, 0x30, 0x09, 0x06,
	0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04,
	0x08, 0x13, 0x0A, 0x57, 0x61, 0x73, 0x68, 0x69, 0x6E, 0x67, 0x74, 0x6F, 0x6E, 0x31, 0x10, 0x30,
	0x0E, 0x06, 0x03, 0x55, 0x04, 0x07, 0x13, 0x07, 0x52, 0x65, 0x64, 0x6D, 0x6F, 0x6E, 0x64, 0x31,
	0x1E, 0x30, 0x1C, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x15, 0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73,
	0x6F, 0x66, 0x74, 0x20, 0x43, 0x6F, 0x72, 0x70, 0x6F, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x31,
	0x29, 0x30, 0x27, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x20, 0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73,
	0x6F, 0x66, 0x74, 0x20, 0x43, 0x6F, 0x64, 0x65, 0x20, 0x56, 0x65, 0x72, 0x69, 0x66, 0x69, 0x63,
	0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x52, 0x6F, 0x6F, 0x74, 0x30, 0x1E, 0x17, 0x0D, 0x31, 0x31,
	0x30, 0x34, 0x31, 0x35, 0x31, 0x39, 0x34, 0x35, 0x33, 0x33, 0x5A, 0x17, 0x0D, 0x32, 0x31, 0x30,
	0x34, 0x31, 0x35, 0x31, 0x39, 0x35, 0x35, 0x33, 0x33, 0x5A, 0x30, 0x6C, 0x31, 0x0B, 0x30, 0x09,
	0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55,
	0x04, 0x0A, 0x13, 0x0C, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x20, 0x49, 0x6E, 0x63,
	0x31, 0x19, 0x30, 0x17, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x10, 0x77, 0x77, 0x77, 0x2E, 0x64,
	0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x31, 0x2B, 0x30, 0x29, 0x06,
	0x03, 0x55, 0x04, 0x03, 0x13, 0x22, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x20, 0x48,
	0x69, 0x67, 0x68, 0x20, 0x41, 0x73, 0x73, 0x75, 0x72, 0x61, 0x6E, 0x63, 0x65, 0x20, 0x45, 0x56,
	0x20, 0x52, 0x6F, 0x6F, 0x74, 0x20, 0x43, 0x41, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0D, 0x06, 0x09,
	0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0F, 0x00,
	0x30, 0x82, 0x01, 0x0A, 0x02, 0x82, 0x01, 0x01, 0x00, 0xC6, 0xCC, 0xE5, 0x73, 0xE6, 0xFB, 0xD4,
	0xBB, 0xE5, 0x2D, 0x2D, 0x32, 0xA6, 0xDF, 0xE5, 0x81, 0x3F, 0xC9, 0xCD, 0x25, 0x49, 0xB6, 0x71,
	0x2A, 0xC3, 0xD5, 0x94, 0x34, 0x67, 0xA2, 0x0A, 0x1C, 0xB0, 0x5F, 0x69, 0xA6, 0x40, 0xB1, 0xC4,
	0xB7, 0xB2, 0x8F, 0xD0, 0x98, 0xA4, 0xA9, 0x41, 0x59, 0x3A, 0xD3, 0xDC, 0x94, 0xD6, 0x3C, 0xDB,
	0x74, 0x38, 0xA4, 0x4A, 0xCC, 0x4D, 0x25, 0x82, 0xF7, 0x4A, 0xA5, 0x53, 0x12, 0x38, 0xEE, 0xF3,
	0x49, 0x6D, 0x71, 0x91, 0x7E, 0x63, 0xB6, 0xAB, 0xA6, 0x5F, 0xC3, 0xA4, 0x84, 0xF8, 0x4F, 0x62,
	0x51, 0xBE, 0xF8, 0xC5, 0xEC, 0xDB, 0x38, 0x92, 0xE3, 0x06, 0xE5, 0x08, 0x91, 0x0C, 0xC4, 0x28,
	0x41, 0x55, 0xFB, 0xCB, 0x5A, 0x89, 0x15, 0x7E, 0x71, 0xE8, 0x35, 0xBF, 0x4D, 0x72, 0x09, 0x3D,
	0xBE, 0x3A, 0x38, 0x50, 0x5B, 0x77, 0x31, 0x1B, 0x8D, 0xB3, 0xC7, 0x24, 0x45, 0x9A, 0xA7, 0xAC,
	0x6D, 0x00, 0x14, 0x5A, 0x04, 0xB7, 0xBA, 0x13, 0xEB, 0x51, 0x0A, 0x98, 0x41, 0x41, 0x22, 0x4E,
	0x65, 0x61, 0x87, 0x81, 0x41, 0x50, 0xA6, 0x79, 0x5C, 0x89, 0xDE, 0x19, 0x4A, 0x57, 0xD5, 0x2E,
	0xE6, 0x5D, 0x1C, 0x53, 0x2C, 0x7E, 0x98, 0xCD, 0x1A, 0x06, 0x16, 0xA4, 0x68, 0x73, 0xD0, 0x34,
	0x04, 0x13, 0x5C, 0xA1, 0x71, 0xD3, 0x5A, 0x7C, 0x55, 0xDB, 0x5E, 0x64, 0xE1, 0x37, 0x87, 0x30,
	0x56, 0x04, 0xE5, 0x11, 0xB4, 0x29, 0x80, 0x12, 0xF1, 0x79, 0x39, 0x88, 0xA2, 0x02, 0x11, 0x7C,
	0x27, 0x66, 0xB7, 0x88, 0xB7, 0x78, 0xF2, 0xCA, 0x0A, 0xA8, 0x38, 0xAB, 0x0A, 0x64, 0xC2, 0xBF,
	0x66, 0x5D, 0x95, 0x84, 0xC1, 0xA1, 0x25, 0x1E, 0x87, 0x5D, 0x1A, 0x50, 0x0B, 0x20, 0x12, 0xCC,
	0x41, 0xBB, 0x6E, 0x0B, 0x51, 0x38, 0xB8, 0x4B, 0xCB, 0x02, 0x03, 0x01, 0x00, 0x01, 0xA3, 0x81,
	0xCB, 0x30, 0x81, 0xC8, 0x30, 0x11, 0x06, 0x03, 0x55, 0x1D, 0x20, 0x04, 0x0A, 0x30, 0x08, 0x30,
	0x06, 0x06, 0x04, 0x55, 0x1D, 0x20, 0x00, 0x30, 0x0B, 0x06, 0x03, 0x55, 0x1D, 0x0F, 0x04, 0x04,
	0x03, 0x02, 0x01, 0x86, 0x30, 0x0F, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x01, 0x01, 0xFF, 0x04, 0x05,
	0x30, 0x03, 0x01, 0x01, 0xFF, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x1D, 0x0E, 0x04, 0x16, 0x04, 0x14,
	0xB1, 0x3E, 0xC3, 0x69, 0x03, 0xF8, 0xBF, 0x47, 0x01, 0xD4, 0x98, 0x26, 0x1A, 0x08, 0x02, 0xEF,
	0x63, 0x64, 0x2B, 0xC3, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x1D, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80,
	0x14, 0x62, 0xFB, 0x0A, 0x21, 0x5B, 0x7F, 0x43, 0x6E, 0x11, 0xDA, 0x09, 0x54, 0x50, 0x6B, 0xF5,
	0xD2, 0x96, 0x71, 0xF1, 0x9E, 0x30, 0x55, 0x06, 0x03, 0x55, 0x1D, 0x1F, 0x04, 0x4E, 0x30, 0x4C,
	0x30, 0x4A, 0xA0, 0x48, 0xA0, 0x46, 0x86, 0x44, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x63,
	0x72, 0x6C, 0x2E, 0x6D, 0x69, 0x63, 0x72, 0x6F, 0x73, 0x6F, 0x66, 0x74, 0x2E, 0x63, 0x6F, 0x6D,
	0x2F, 0x70, 0x6B, 0x69, 0x2F, 0x63, 0x72, 0x6C, 0x2F, 0x70, 0x72, 0x6F, 0x64, 0x75, 0x63, 0x74,
	0x73, 0x2F, 0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73, 0x6F, 0x66, 0x74, 0x43, 0x6F, 0x64, 0x65, 0x56,
	0x65, 0x72, 0x69, 0x66, 0x52, 0x6F, 0x6F, 0x74, 0x2E, 0x63, 0x72, 0x6C, 0x30, 0x0D, 0x06, 0x09,
	0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x82, 0x02, 0x01, 0x00,
	0x20, 0x8C, 0xC1, 0x59, 0xED, 0x6F, 0x9C, 0x6B, 0x2D, 0xC1, 0x4A, 0x3E, 0x75, 0x1D, 0x45, 0x4C,
	0x41, 0x50, 0x1C, 0xBD, 0x80, 0xEA, 0xD9, 0xB0, 0x92, 0x8B, 0x06, 0x2A, 0x13, 0x3F, 0x53, 0x16,
	0x9E, 0x56, 0x39, 0x6A, 0x8A, 0x63, 0xB6, 0x78, 0x24, 0x79, 0xF5, 0x7D, 0xB8, 0xB9, 0x47, 0xA1,
	0x0A, 0x96, 0xC2, 0xF6, 0xCB, 0xBD, 0xA2, 0x66, 0x9F, 0x06, 0xE1, 0xAC, 0xD2, 0x79, 0x09, 0x0E,
	0xFD, 0x3C, 0xDC, 0xAC, 0x02, 0x0C, 0x70, 0xAF, 0x3F, 0x1B, 0xEC, 0x78, 0x7E, 0xD4, 0xEB, 0x4B,
	0x05, 0x60, 0x26, 0xD9, 0x73, 0x61, 0x91, 0x21, 0xED, 0xB0, 0x68, 0x63, 0xE0, 0x97, 0x12, 0xAB,
	0x6F, 0xA0, 0x12, 0xED, 0xD9, 0x9F, 0xD2, 0xDA, 0x27, 0x3C, 0xB3, 0xE4, 0x56, 0xF9, 0xD1, 0xD4,
	0x81, 0x0F, 0x71, 0xBD, 0x42, 0x7C, 0xA6, 0x89, 0xDC, 0xCD, 0xD5, 0xBD, 0x95, 0xA2, 0xAB, 0xF1,
	0x93, 0x11, 0x7D, 0xE8, 0xAC, 0x31, 0x29, 0xA8, 0x5D, 0x66, 0x70, 0x41, 0x9D, 0xFC, 0x75, 0xC9,
	0xD5, 0xB3, 0x1A, 0x39, 0x2A, 0xD0, 0x85, 0x05, 0x50, 0x8B, 0xAC, 0x91, 0xCA, 0xC4, 0x93, 0xCB,
	0x71, 0xA5, 0x9D, 0xA4, 0x94, 0x6F, 0x58, 0x0C, 0xFA, 0x6E, 0x20, 0xC4, 0x08, 0x31, 0xB5, 0x85,
	0x9D, 0x7E, 0x81, 0xF9, 0xD2, 0x3D, 0xCA, 0x5B, 0x18, 0x85, 0x6C, 0x0A, 0x86, 0xEC, 0x22, 0x09,
	0x1B, 0xA5, 0x74, 0x34, 0x4F, 0x7F, 0x28, 0xBC, 0x95, 0x4A, 0xAB, 0x1D, 0xB6, 0x98, 0xB0, 0x5D,
	0x09, 0xA4, 0x77, 0x76, 0x7E, 0xEF, 0xA7, 0x8E, 0x5D, 0x84, 0xF6, 0x18, 0x24, 0xCB, 0xD1, 0x6D,
	0xA6, 0xC3, 0xA1, 0x9C, 0xC2, 0x10, 0x75, 0x80, 0xFF, 0x9D, 0x32, 0xFD, 0xE6, 0xCF, 0x43, 0x3A,
	0x82, 0xF7, 0xCE, 0x8F, 0xE1, 0x72, 0x2A, 0x9B, 0x62, 0xB7, 0x5F, 0xED, 0x95, 0x1A, 0x39, 0x5C,
	0x2F, 0x94, 0x6D, 0x48, 0xB7, 0x01, 0x5F, 0x33, 0x2F, 0xBB, 0xDC, 0x2D, 0x73, 0x34, 0x89, 0x04,
	0x42, 0x0A, 0x1C, 0x8B, 0x79, 0xF9, 0xA3, 0xFA, 0x17, 0xEF, 0xFA, 0xA1, 0x1A, 0x10, 0xDF, 0xE0,
	0xB2, 0xC1, 0x95, 0xEB, 0x5C, 0x0C, 0x05, 0x97, 0x3B, 0x35, 0x3E, 0x18, 0x88, 0x4D, 0xDB, 0x6C,
	0xBF, 0x24, 0x89, 0x8D, 0xC8, 0xBD, 0xD8, 0x9F, 0x7B, 0x39, 0x3A, 0x24, 0xA0, 0xD5, 0xDF, 0xD1,
	0xF3, 0x4A, 0x1A, 0x97, 0xF6, 0xA6, 0x6F, 0x7A, 0x1F, 0xB0, 0x90, 0xA9, 0xB3, 0xAC, 0x01, 0x39,
	0x91, 0xD3, 0x61, 0xB7, 0x64, 0xF1, 0x3E, 0x57, 0x38, 0x03, 0xAF, 0xCE, 0x7A, 0xD2, 0xB5, 0x90,
	0xF5, 0xAE, 0xDC, 0x39, 0x99, 0xD5, 0xB6, 0x3C, 0x97, 0xED, 0xA6, 0xCB, 0x16, 0xC7, 0x7D, 0x6B,
	0x2A, 0x4C, 0x90, 0x94, 0xE6, 0x4C, 0x54, 0xFD, 0x1E, 0xCD, 0x20, 0xEC, 0xCE, 0x68, 0x9C, 0x87,
	0x58, 0xE9, 0x61, 0x60, 0xBE, 0xEB, 0x0E, 0xC9, 0xD5, 0x19, 0x7D, 0x9F, 0xE9, 0x78, 0xBD, 0x0E,
	0xAC, 0x21, 0x75, 0x07, 0x8F, 0xA9, 0x6E, 0xE0, 0x8C, 0x6A, 0x2A, 0x6B, 0x9C, 0xE3, 0xE7, 0x65,
	0xBC, 0xBC, 0x2D, 0x3C, 0x6D, 0xDC, 0x04, 0xDC, 0x67, 0x45, 0x36, 0x32, 0xAF, 0x04, 0x81, 0xBC,
	0xA8, 0x00, 0x6E, 0x61, 0x4C, 0x95, 0xC5, 0x5C, 0xD4, 0x8E, 0x8E, 0x9F, 0x2F, 0xC1, 0x32, 0x74,
	0xBD, 0xBD, 0x11, 0x65, 0x03, 0x07, 0xCD, 0xEF, 0xB7, 0x5E, 0x02, 0x57, 0xDA, 0x86, 0xD4, 0x1A,
	0x28, 0x34, 0xAF, 0x88, 0x49, 0xB2, 0xCF, 0xA5, 0xDD, 0x82, 0x56, 0x6F, 0x68, 0xAA, 0x14, 0xE2,
	0x59, 0x54, 0xFE, 0xFF, 0xEA, 0xEE, 0xEF, 0xEA, 0x92, 0x70, 0x22, 0x60, 0x81, 0xE3, 0x25, 0x23,
	0xC0, 0x9F, 0xCC, 0x0F, 0x49, 0xB2, 0x35, 0xAA, 0x58, 0xC3, 0x3A, 0xC3, 0xD9, 0x16, 0x94, 0x10,
	0x30, 0x82, 0x06, 0x6A, 0x30, 0x82, 0x05, 0x52, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x10, 0x03,
	0x01, 0x9A, 0x02, 0x3A, 0xFF, 0x58, 0xB1, 0x6B, 0xD6, 0xD5, 0xEA, 0xE6, 0x17, 0xF0, 0x66, 0x30,
	0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x62,
	0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x15, 0x30,
	0x13, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x0C, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74,
	0x20, 0x49, 0x6E, 0x63, 0x31, 0x19, 0x30, 0x17, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x10, 0x77,
	0x77, 0x77, 0x2E, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x31,
	0x21, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x18, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65,
	0x72, 0x74, 0x20, 0x41, 0x73, 0x73, 0x75, 0x72, 0x65, 0x64, 0x20, 0x49, 0x44, 0x20, 0x43, 0x41,
	0x2D, 0x31, 0x30, 0x1E, 0x17, 0x0D, 0x31, 0x34, 0x31, 0x30, 0x32, 0x32, 0x30, 0x30, 0x30, 0x30,
	0x30, 0x30, 0x5A, 0x17, 0x0D, 0x32, 0x34, 0x31, 0x30, 0x32, 0x32, 0x30, 0x30, 0x30, 0x30, 0x30,
	0x30, 0x5A, 0x30, 0x47, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55,
	0x53, 0x31, 0x11, 0x30, 0x0F, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x08, 0x44, 0x69, 0x67, 0x69,
	0x43, 0x65, 0x72, 0x74, 0x31, 0x25, 0x30, 0x23, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x1C, 0x44,
	0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x20, 0x54, 0x69, 0x6D, 0x65, 0x73, 0x74, 0x61, 0x6D,
	0x70, 0x20, 0x52, 0x65, 0x73, 0x70, 0x6F, 0x6E, 0x64, 0x65, 0x72, 0x30, 0x82, 0x01, 0x22, 0x30,
	0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82,
	0x01, 0x0F, 0x00, 0x30, 0x82, 0x01, 0x0A, 0x02, 0x82, 0x01, 0x01, 0x00, 0xA3, 0x64, 0x5D, 0xFC,
	0x7C, 0xB3, 0xE0, 0x82, 0x35, 0xE0, 0xE0, 0xF6, 0xC6, 0x2A, 0xE6, 0x49, 0x75, 0x3B, 0xCC, 0x6E,
	0xE0, 0x53, 0xA9, 0x9F, 0x1F, 0x64, 0x59, 0xE6, 0x7C, 0x6B, 0x7F, 0x6B, 0x8C, 0x9D, 0x55, 0xF8,
	0x92, 0xE3, 0x9E, 0xD5, 0x5A, 0x63, 0x5B, 0x02, 0x49, 0x50, 0xD9, 0x83, 0xCE, 0x6F, 0x66, 0xEE,
	0xDD, 0xCB, 0x85, 0xE9, 0x5F, 0xA5, 0xF9, 0xD4, 0x87, 0x74, 0x88, 0x44, 0x3B, 0x19, 0xC9, 0xE5,
	0xF5, 0x91, 0x9F, 0xC6, 0x14, 0x39, 0xAC, 0x24, 0xEA, 0xA8, 0x4B, 0x2C, 0x91, 0x89, 0xCC, 0x5E,
	0x28, 0xF4, 0x64, 0xB6, 0x50, 0xB7, 0xF5, 0x12, 0xB3, 0x73, 0x96, 0x0A, 0x67, 0xA3, 0xBE, 0x61,
	0x9F, 0xAE, 0xF3, 0xFD, 0x12, 0x78, 0x75, 0x0E, 0xA6, 0x5B, 0x14, 0xFD, 0x45, 0x23, 0x8E, 0x86,
	0x44, 0x55, 0x7D, 0x18, 0x86, 0x05, 0x8C, 0x55, 0x87, 0x79, 0x48, 0x46, 0xF7, 0xCA, 0x0E, 0x8D,
	0xA7, 0xDE, 0x4E, 0x5F, 0xE2, 0xA8, 0xB6, 0x2D, 0x59, 0x02, 0x61, 0x88, 0x61, 0x72, 0x18, 0x68,
	0xB9, 0xB8, 0x7C, 0xEE, 0xE6, 0xE7, 0x34, 0x2F, 0x31, 0x77, 0x81, 0x30, 0x1F, 0xBB, 0x36, 0x01,
	0x8D, 0xEF, 0x27, 0xE3, 0xF7, 0x9A, 0xF0, 0x4C, 0x31, 0x64, 0x8D, 0xE3, 0xEB, 0xFA, 0x19, 0x87,
	0xA8, 0x7E, 0xCF, 0xEC, 0x8C, 0x0C, 0x36, 0x5B, 0x7A, 0xC1, 0x7A, 0xB8, 0x78, 0xC7, 0xC9, 0x06,
	0x2E, 0x46, 0x10, 0xC8, 0x8D, 0xE8, 0x04, 0x60, 0xDB, 0xBC, 0x73, 0x74, 0xFA, 0x4E, 0xD8, 0xFE,
	0xAA, 0x40, 0xF1, 0xB2, 0xCE, 0x70, 0x46, 0x83, 0xE9, 0xDA, 0x40, 0xA1, 0x59, 0x3A, 0xD9, 0x15,
	0x09, 0x57, 0x99, 0x56, 0x30, 0x93, 0xF3, 0xC9, 0x61, 0xCC, 0xD0, 0x08, 0xCC, 0x6B, 0xEC, 0x62,
	0x42, 0x91, 0xAC, 0x02, 0xC0, 0xEF, 0xA4, 0xF0, 0x89, 0x11, 0x8F, 0x77, 0x02, 0x03, 0x01, 0x00,
	0x01, 0xA3, 0x82, 0x03, 0x35, 0x30, 0x82, 0x03, 0x31, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x1D, 0x0F,
	0x01, 0x01, 0xFF, 0x04, 0x04, 0x03, 0x02, 0x07, 0x80, 0x30, 0x0C, 0x06, 0x03, 0x55, 0x1D, 0x13,
	0x01, 0x01, 0xFF, 0x04, 0x02, 0x30, 0x00, 0x30, 0x16, 0x06, 0x03, 0x55, 0x1D, 0x25, 0x01, 0x01,
	0xFF, 0x04, 0x0C, 0x30, 0x0A, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x08, 0x30,
	0x82, 0x01, 0xBF, 0x06, 0x03, 0x55, 0x1D, 0x20, 0x04, 0x82, 0x01, 0xB6, 0x30, 0x82, 0x01, 0xB2,
	0x30, 0x82, 0x01, 0xA1, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x86, 0xFD, 0x6C, 0x07, 0x01, 0x30,
	0x82, 0x01, 0x92, 0x30, 0x28, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x02, 0x01, 0x16,
	0x1C, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3A, 0x2F, 0x2F, 0x77, 0x77, 0x77, 0x2E, 0x64, 0x69, 0x67,
	0x69, 0x63, 0x65, 0x72, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x43, 0x50, 0x53, 0x30, 0x82, 0x01,
	0x64, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x02, 0x02, 0x30, 0x82, 0x01, 0x56, 0x1E,
	0x82, 0x01, 0x52, 0x00, 0x41, 0x00, 0x6E, 0x00, 0x79, 0x00, 0x20, 0x00, 0x75, 0x00, 0x73, 0x00,
	0x65, 0x00, 0x20, 0x00, 0x6F, 0x00, 0x66, 0x00, 0x20, 0x00, 0x74, 0x00, 0x68, 0x00, 0x69, 0x00,
	0x73, 0x00, 0x20, 0x00, 0x43, 0x00, 0x65, 0x00, 0x72, 0x00, 0x74, 0x00, 0x69, 0x00, 0x66, 0x00,
	0x69, 0x00, 0x63, 0x00, 0x61, 0x00, 0x74, 0x00, 0x65, 0x00, 0x20, 0x00, 0x63, 0x00, 0x6F, 0x00,
	0x6E, 0x00, 0x73, 0x00, 0x74, 0x00, 0x69, 0x00, 0x74, 0x00, 0x75, 0x00, 0x74, 0x00, 0x65, 0x00,
	0x73, 0x00, 0x20, 0x00, 0x61, 0x00, 0x63, 0x00, 0x63, 0x00, 0x65, 0x00, 0x70, 0x00, 0x74, 0x00,
	0x61, 0x00, 0x6E, 0x00, 0x63, 0x00, 0x65, 0x00, 0x20, 0x00, 0x6F, 0x00, 0x66, 0x00, 0x20, 0x00,
	0x74, 0x00, 0x68, 0x00, 0x65, 0x00, 0x20, 0x00, 0x44, 0x00, 0x69, 0x00, 0x67, 0x00, 0x69, 0x00,
	0x43, 0x00, 0x65, 0x00, 0x72, 0x00, 0x74, 0x00, 0x20, 0x00, 0x43, 0x00, 0x50, 0x00, 0x2F, 0x00,
	0x43, 0x00, 0x50, 0x00, 0x53, 0x00, 0x20, 0x00, 0x61, 0x00, 0x6E, 0x00, 0x64, 0x00, 0x20, 0x00,
	0x74, 0x00, 0x68, 0x00, 0x65, 0x00, 0x20, 0x00, 0x52, 0x00, 0x65, 0x00, 0x6C, 0x00, 0x79, 0x00,
	0x69, 0x00, 0x6E, 0x00, 0x67, 0x00, 0x20, 0x00, 0x50, 0x00, 0x61, 0x00, 0x72, 0x00, 0x74, 0x00,
	0x79, 0x00, 0x20, 0x00, 0x41, 0x00, 0x67, 0x00, 0x72, 0x00, 0x65, 0x00, 0x65, 0x00, 0x6D, 0x00,
	0x65, 0x00, 0x6E, 0x00, 0x74, 0x00, 0x20, 0x00, 0x77, 0x00, 0x68, 0x00, 0x69, 0x00, 0x63, 0x00,
	0x68, 0x00, 0x20, 0x00, 0x6C, 0x00, 0x69, 0x00, 0x6D, 0x00, 0x69, 0x00, 0x74, 0x00, 0x20, 0x00,
	0x6C, 0x00, 0x69, 0x00, 0x61, 0x00, 0x62, 0x00, 0x69, 0x00, 0x6C, 0x00, 0x69, 0x00, 0x74, 0x00,
	0x79, 0x00, 0x20, 0x00, 0x61, 0x00, 0x6E, 0x00, 0x64, 0x00, 0x20, 0x00, 0x61, 0x00, 0x72, 0x00,
	0x65, 0x00, 0x20, 0x00, 0x69, 0x00, 0x6E, 0x00, 0x63, 0x00, 0x6F, 0x00, 0x72, 0x00, 0x70, 0x00,
	0x6F, 0x00, 0x72, 0x00, 0x61, 0x00, 0x74, 0x00, 0x65, 0x00, 0x64, 0x00, 0x20, 0x00, 0x68, 0x00,
	0x65, 0x00, 0x72, 0x00, 0x65, 0x00, 0x69, 0x00, 0x6E, 0x00, 0x20, 0x00, 0x62, 0x00, 0x79, 0x00,
	0x20, 0x00, 0x72, 0x00, 0x65, 0x00, 0x66, 0x00, 0x65, 0x00, 0x72, 0x00, 0x65, 0x00, 0x6E, 0x00,
	0x63, 0x00, 0x65, 0x00, 0x2E, 0x30, 0x0B, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x86, 0xFD, 0x6C,
	0x03, 0x15, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x1D, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0x15,
	0x00, 0x12, 0x2B, 0x13, 0x98, 0xB2, 0x99, 0x07, 0xED, 0x1E, 0xDF, 0xA2, 0xBE, 0x57, 0x0D, 0x2B,
	0x67, 0x02, 0xCD, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x1D, 0x0E, 0x04, 0x16, 0x04, 0x14, 0x61, 0x5A,
	0x4D, 0x24, 0xB6, 0x49, 0x32, 0x9D, 0x4A, 0x2A, 0x79, 0x1A, 0x83, 0x4B, 0xF4, 0x1E, 0x89, 0xC1,
	0xCA, 0x7D, 0x30, 0x7D, 0x06, 0x03, 0x55, 0x1D, 0x1F, 0x04, 0x76, 0x30, 0x74, 0x30, 0x38, 0xA0,
	0x36, 0xA0, 0x34, 0x86, 0x32, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x63, 0x72, 0x6C, 0x33,
	0x2E, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x44, 0x69,
	0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x41, 0x73, 0x73, 0x75, 0x72, 0x65, 0x64, 0x49, 0x44, 0x43,
	0x41, 0x2D, 0x31, 0x2E, 0x63, 0x72, 0x6C, 0x30, 0x38, 0xA0, 0x36, 0xA0, 0x34, 0x86, 0x32, 0x68,
	0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x63, 0x72, 0x6C, 0x34, 0x2E, 0x64, 0x69, 0x67, 0x69, 0x63,
	0x65, 0x72, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74,
	0x41, 0x73, 0x73, 0x75, 0x72, 0x65, 0x64, 0x49, 0x44, 0x43, 0x41, 0x2D, 0x31, 0x2E, 0x63, 0x72,
	0x6C, 0x30, 0x77, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x01, 0x01, 0x04, 0x6B, 0x30,
	0x69, 0x30, 0x24, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x01, 0x86, 0x18, 0x68,
	0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x6F, 0x63, 0x73, 0x70, 0x2E, 0x64, 0x69, 0x67, 0x69, 0x63,
	0x65, 0x72, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x30, 0x41, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05,
	0x07, 0x30, 0x02, 0x86, 0x35, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x63, 0x61, 0x63, 0x65,
	0x72, 0x74, 0x73, 0x2E, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2E, 0x63, 0x6F, 0x6D,
	0x2F, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x41, 0x73, 0x73, 0x75, 0x72, 0x65, 0x64,
	0x49, 0x44, 0x43, 0x41, 0x2D, 0x31, 0x2E, 0x63, 0x72, 0x74, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86,
	0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x82, 0x01, 0x01, 0x00, 0x9D, 0x25,
	0x7E, 0x1B, 0x33, 0x4D, 0xB2, 0x26, 0x81, 0x5C, 0x9B, 0x86, 0xCE, 0x23, 0x20, 0x0F, 0x80, 0x87,
	0xE5, 0x88, 0xFF, 0xFF, 0xB1, 0xD4, 0x6A, 0x2C, 0x31, 0xED, 0x3A, 0x17, 0x19, 0x71, 0x17, 0xCD,
	0xA9, 0x1B, 0xBC, 0x5A, 0x16, 0x39, 0x00, 0x9D, 0xE3, 0x6C, 0x84, 0xE4, 0x5A, 0x40, 0xFB, 0xDE,
	0x06, 0x01, 0x8C, 0x37, 0xFA, 0x9B, 0xB1, 0x9D, 0x24, 0x7E, 0xFE, 0x20, 0xA4, 0x57, 0xAD, 0x5B,
	0xB7, 0x9A, 0xB0, 0x60, 0x26, 0xEA, 0x69, 0x57, 0x21, 0x5D, 0x34, 0x2F, 0x1F, 0x71, 0xB0, 0x83,
	0x94, 0x19, 0x05, 0x6B, 0x35, 0x90, 0x10, 0xA0, 0x7B, 0x97, 0xC7, 0xF6, 0x3F, 0xE7, 0xE2, 0x11,
	0x41, 0xA6, 0xBD, 0x62, 0xD9, 0xF0, 0x27, 0x3D, 0x38, 0x1D, 0x28, 0x6F, 0x3A, 0x52, 0x09, 0xF0,
	0xEC, 0x70, 0x62, 0xD3, 0x62, 0x4B, 0xB0, 0xE0, 0x73, 0xA6, 0x92, 0xC0, 0xD3, 0x8E, 0x31, 0xD8,
	0x2F, 0xE3, 0x6D, 0x17, 0x13, 0x06, 0xEE, 0xE4, 0x03, 0xB6, 0x14, 0xAB, 0xF3, 0x8F, 0x43, 0xA7,
	0x71, 0x9D, 0x21, 0xDD, 0x14, 0xCA, 0x15, 0x5D, 0x92, 0x41, 0xDA, 0xF9, 0x0F, 0x81, 0xD1, 0x99,
	0x74, 0x0D, 0x26, 0xC4, 0x0E, 0x7F, 0x1B, 0xB5, 0xF5, 0xA0, 0xF1, 0xC6, 0x77, 0x06, 0x28, 0x15,
	0xE9, 0xD8, 0x93, 0xE5, 0x55, 0x16, 0xF0, 0xBB, 0x0A, 0xAB, 0x1C, 0xDB, 0x5C, 0x48, 0x27, 0x66,
	0xC8, 0xA3, 0x8B, 0x0A, 0x1C, 0xE5, 0x95, 0xDA, 0xAE, 0xC4, 0x2E, 0x59, 0xA0, 0x61, 0xDD, 0xDA,
	0xF3, 0x6D, 0xA2, 0x61, 0xE9, 0x8A, 0x0B, 0x6D, 0xEC, 0x12, 0x18, 0xBD, 0xF7, 0x55, 0x54, 0x40,
	0x03, 0x92, 0x2B, 0x6B, 0xC2, 0x51, 0xC2, 0x0A, 0x48, 0xAF, 0xB0, 0xD4, 0x6E, 0xE0, 0xF4, 0x14,
	0x0A, 0x3A, 0x1B, 0xE3, 0x8F, 0x3D, 0xCA, 0xAF, 0x6A, 0x8D, 0x7B, 0xDC, 0xD8, 0x44, 0x30, 0x82,
	0x06, 0x96, 0x30, 0x82, 0x05, 0x7E, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x10, 0x03, 0xE9, 0x01,
	0x7D, 0x54, 0xCD, 0x93, 0xF0, 0x94, 0xD0, 0xA2, 0xAB, 0x7F, 0xC0, 0xE3, 0xF5, 0x30, 0x0D, 0x06,
	0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x73, 0x31, 0x0B,
	0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x15, 0x30, 0x13, 0x06,
	0x03, 0x55, 0x04, 0x0A, 0x13, 0x0C, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x20, 0x49,
	0x6E, 0x63, 0x31, 0x19, 0x30, 0x17, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x10, 0x77, 0x77, 0x77,
	0x2E, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x31, 0x32, 0x30,
	0x30, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x29, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74,
	0x20, 0x48, 0x69, 0x67, 0x68, 0x20, 0x41, 0x73, 0x73, 0x75, 0x72, 0x61, 0x6E, 0x63, 0x65, 0x20,
	0x43, 0x6F, 0x64, 0x65, 0x20, 0x53, 0x69, 0x67, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x43, 0x41, 0x2D,
	0x31, 0x30, 0x1E, 0x17, 0x0D, 0x31, 0x33, 0x31, 0x30, 0x33, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
	0x30, 0x5A, 0x17, 0x0D, 0x31, 0x35, 0x31, 0x31, 0x30, 0x34, 0x31, 0x32, 0x30, 0x30, 0x30, 0x30,
	0x5A, 0x30, 0x64, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x41, 0x55,
	0x31, 0x18, 0x30, 0x16, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x0F, 0x4E, 0x65, 0x77, 0x20, 0x53,
	0x6F, 0x75, 0x74, 0x68, 0x20, 0x57, 0x61, 0x6C, 0x65, 0x73, 0x31, 0x0F, 0x30, 0x0D, 0x06, 0x03,
	0x55, 0x04, 0x07, 0x13, 0x06, 0x53, 0x79, 0x64, 0x6E, 0x65, 0x79, 0x31, 0x14, 0x30, 0x12, 0x06,
	0x03, 0x55, 0x04, 0x0A, 0x13, 0x0B, 0x57, 0x65, 0x6E, 0x20, 0x4A, 0x69, 0x61, 0x20, 0x4C, 0x69,
	0x75, 0x31, 0x14, 0x30, 0x12, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x0B, 0x57, 0x65, 0x6E, 0x20,
	0x4A, 0x69, 0x61, 0x20, 0x4C, 0x69, 0x75, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0D, 0x06, 0x09, 0x2A,
	0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0F, 0x00, 0x30,
	0x82, 0x01, 0x0A, 0x02, 0x82, 0x01, 0x01, 0x00, 0xD3, 0x1D, 0xC2, 0xE0, 0x3F, 0x42, 0x5C, 0xAD,
	0x9E, 0x41, 0x16, 0x88, 0xEF, 0x79, 0x4A, 0x73, 0x7D, 0x58, 0x94, 0xFB, 0xF5, 0xD6, 0xC5, 0x8B,
	0xB9, 0x81, 0x57, 0x59, 0x82, 0xAF, 0x2C, 0x3E, 0x87, 0xDA, 0xCF, 0x25, 0xC6, 0x34, 0x23, 0x33,
	0x95, 0xF7, 0x10, 0xAE, 0x18, 0xF7, 0xA6, 0xFF, 0x51, 0x42, 0xFF, 0xDA, 0x14, 0xE6, 0x2F, 0x01,
	0xCB, 0x3A, 0xA4, 0xB5, 0x0D, 0xDA, 0xE0, 0x33, 0x09, 0xC6, 0x57, 0xF3, 0x62, 0xE3, 0x57, 0x98,
	0x72, 0xBF, 0x88, 0x05, 0x90, 0x31, 0x3F, 0x45, 0xBE, 0x7F, 0x0A, 0x82, 0x16, 0x1D, 0xB9, 0xC3,
	0xF7, 0x00, 0x40, 0xD4, 0x37, 0x9C, 0xFA, 0x94, 0xAA, 0xDB, 0x22, 0xBC, 0x61, 0xA8, 0x75, 0xB6,
	0xC7, 0x45, 0x49, 0x16, 0xE1, 0xDE, 0xBA, 0x51, 0x50, 0x00, 0xF6, 0x76, 0xA6, 0x43, 0x27, 0xB0,
	0x3C, 0xE4, 0xA2, 0x21, 0x64, 0x38, 0x48, 0xAC, 0x89, 0x83, 0xF5, 0x2B, 0xFD, 0x41, 0xBB, 0x5A,
	0x30, 0xD3, 0xBF, 0x35, 0xCB, 0x89, 0xEB, 0x9C, 0x10, 0xC6, 0x5D, 0xD5, 0xE3, 0x6B, 0x2D, 0xE7,
	0xFD, 0x6C, 0xF9, 0xDA, 0xB3, 0x17, 0xFF, 0xC3, 0x82, 0xDA, 0x24, 0x4E, 0x76, 0x6D, 0xA5, 0x28,
	0x33, 0x52, 0x78, 0x27, 0x40, 0xFB, 0xFB, 0xF8, 0x6D, 0x38, 0x97, 0x03, 0x81, 0x83, 0x52, 0xDC,
	0xEC, 0x87, 0xA2, 0xE0, 0xAB, 0x3F, 0x87, 0xA9, 0x67, 0x5C, 0x5A, 0xDC, 0x21, 0x6A, 0x5B, 0x09,
	0x26, 0x1E, 0x19, 0x1F, 0x09, 0xD3, 0x83, 0x0C, 0x11, 0xA7, 0xCA, 0x7E, 0xBD, 0x71, 0x44, 0xCC,
	0x9B, 0xB9, 0x55, 0x67, 0xEE, 0x29, 0xE2, 0xC2, 0x2C, 0x57, 0x6C, 0xDD, 0xB0, 0x96, 0xB3, 0x06,
	0x59, 0x99, 0x0B, 0x92, 0x03, 0x24, 0xAE, 0xA3, 0x35, 0x27, 0xAA, 0x4B, 0x3A, 0xB8, 0xEA, 0x94,
	0xFD, 0xC9, 0x1A, 0xA9, 0xB7, 0xB6, 0xCC, 0x6B, 0x02, 0x03, 0x01, 0x00, 0x01, 0xA3, 0x82, 0x03,
	0x33, 0x30, 0x82, 0x03, 0x2F, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x1D, 0x23, 0x04, 0x18, 0x30, 0x16,
	0x80, 0x14, 0x97, 0x48, 0x03, 0xEB, 0x15, 0x08, 0x6B, 0xB9, 0xB2, 0x58, 0x23, 0xCC, 0x94, 0x2E,
	0xF1, 0xC6, 0x65, 0xD2, 0x64, 0x8E, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x1D, 0x0E, 0x04, 0x16, 0x04,
	0x14, 0xA8, 0xA3, 0x4D, 0x2A, 0x8E, 0xA5, 0x2E, 0x70, 0x45, 0xB6, 0xFA, 0x5B, 0xFA, 0xAD, 0x22,
	0x25, 0xED, 0xBA, 0x8B, 0x6C, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x1D, 0x0F, 0x01, 0x01, 0xFF, 0x04,
	0x04, 0x03, 0x02, 0x07, 0x80, 0x30, 0x13, 0x06, 0x03, 0x55, 0x1D, 0x25, 0x04, 0x0C, 0x30, 0x0A,
	0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x03, 0x30, 0x69, 0x06, 0x03, 0x55, 0x1D,
	0x1F, 0x04, 0x62, 0x30, 0x60, 0x30, 0x2E, 0xA0, 0x2C, 0xA0, 0x2A, 0x86, 0x28, 0x68, 0x74, 0x74,
	0x70, 0x3A, 0x2F, 0x2F, 0x63, 0x72, 0x6C, 0x33, 0x2E, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72,
	0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x68, 0x61, 0x2D, 0x63, 0x73, 0x2D, 0x32, 0x30, 0x31, 0x31,
	0x61, 0x2E, 0x63, 0x72, 0x6C, 0x30, 0x2E, 0xA0, 0x2C, 0xA0, 0x2A, 0x86, 0x28, 0x68, 0x74, 0x74,
	0x70, 0x3A, 0x2F, 0x2F, 0x63, 0x72, 0x6C, 0x34, 0x2E, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72,
	0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x68, 0x61, 0x2D, 0x63, 0x73, 0x2D, 0x32, 0x30, 0x31, 0x31,
	0x61, 0x2E, 0x63, 0x72, 0x6C, 0x30, 0x82, 0x01, 0xC4, 0x06, 0x03, 0x55, 0x1D, 0x20, 0x04, 0x82,
	0x01, 0xBB, 0x30, 0x82, 0x01, 0xB7, 0x30, 0x82, 0x01, 0xB3, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01,
	0x86, 0xFD, 0x6C, 0x03, 0x01, 0x30, 0x82, 0x01, 0xA4, 0x30, 0x3A, 0x06, 0x08, 0x2B, 0x06, 0x01,
	0x05, 0x05, 0x07, 0x02, 0x01, 0x16, 0x2E, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x77, 0x77,
	0x77, 0x2E, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x73,
	0x73, 0x6C, 0x2D, 0x63, 0x70, 0x73, 0x2D, 0x72, 0x65, 0x70, 0x6F, 0x73, 0x69, 0x74, 0x6F, 0x72,
	0x79, 0x2E, 0x68, 0x74, 0x6D, 0x30, 0x82, 0x01, 0x64, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05,
	0x07, 0x02, 0x02, 0x30, 0x82, 0x01, 0x56, 0x1E, 0x82, 0x01, 0x52, 0x00, 0x41, 0x00, 0x6E, 0x00,
	0x79, 0x00, 0x20, 0x00, 0x75, 0x00, 0x73, 0x00, 0x65, 0x00, 0x20, 0x00, 0x6F, 0x00, 0x66, 0x00,
	0x20, 0x00, 0x74, 0x00, 0x68, 0x00, 0x69, 0x00, 0x73, 0x00, 0x20, 0x00, 0x43, 0x00, 0x65, 0x00,
	0x72, 0x00, 0x74, 0x00, 0x69, 0x00, 0x66, 0x00, 0x69, 0x00, 0x63, 0x00, 0x61, 0x00, 0x74, 0x00,
	0x65, 0x00, 0x20, 0x00, 0x63, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x73, 0x00, 0x74, 0x00, 0x69, 0x00,
	0x74, 0x00, 0x75, 0x00, 0x74, 0x00, 0x65, 0x00, 0x73, 0x00, 0x20, 0x00, 0x61, 0x00, 0x63, 0x00,
	0x63, 0x00, 0x65, 0x00, 0x70, 0x00, 0x74, 0x00, 0x61, 0x00, 0x6E, 0x00, 0x63, 0x00, 0x65, 0x00,
	0x20, 0x00, 0x6F, 0x00, 0x66, 0x00, 0x20, 0x00, 0x74, 0x00, 0x68, 0x00, 0x65, 0x00, 0x20, 0x00,
	0x44, 0x00, 0x69, 0x00, 0x67, 0x00, 0x69, 0x00, 0x43, 0x00, 0x65, 0x00, 0x72, 0x00, 0x74, 0x00,
	0x20, 0x00, 0x43, 0x00, 0x50, 0x00, 0x2F, 0x00, 0x43, 0x00, 0x50, 0x00, 0x53, 0x00, 0x20, 0x00,
	0x61, 0x00, 0x6E, 0x00, 0x64, 0x00, 0x20, 0x00, 0x74, 0x00, 0x68, 0x00, 0x65, 0x00, 0x20, 0x00,
	0x52, 0x00, 0x65, 0x00, 0x6C, 0x00, 0x79, 0x00, 0x69, 0x00, 0x6E, 0x00, 0x67, 0x00, 0x20, 0x00,
	0x50, 0x00, 0x61, 0x00, 0x72, 0x00, 0x74, 0x00, 0x79, 0x00, 0x20, 0x00, 0x41, 0x00, 0x67, 0x00,
	0x72, 0x00, 0x65, 0x00, 0x65, 0x00, 0x6D, 0x00, 0x65, 0x00, 0x6E, 0x00, 0x74, 0x00, 0x20, 0x00,
	0x77, 0x00, 0x68, 0x00, 0x69, 0x00, 0x63, 0x00, 0x68, 0x00, 0x20, 0x00, 0x6C, 0x00, 0x69, 0x00,
	0x6D, 0x00, 0x69, 0x00, 0x74, 0x00, 0x20, 0x00, 0x6C, 0x00, 0x69, 0x00, 0x61, 0x00, 0x62, 0x00,
	0x69, 0x00, 0x6C, 0x00, 0x69, 0x00, 0x74, 0x00, 0x79, 0x00, 0x20, 0x00, 0x61, 0x00, 0x6E, 0x00,
	0x64, 0x00, 0x20, 0x00, 0x61, 0x00, 0x72, 0x00, 0x65, 0x00, 0x20, 0x00, 0x69, 0x00, 0x6E, 0x00,
	0x63, 0x00, 0x6F, 0x00, 0x72, 0x00, 0x70, 0x00, 0x6F, 0x00, 0x72, 0x00, 0x61, 0x00, 0x74, 0x00,
	0x65, 0x00, 0x64, 0x00, 0x20, 0x00, 0x68, 0x00, 0x65, 0x00, 0x72, 0x00, 0x65, 0x00, 0x69, 0x00,
	0x6E, 0x00, 0x20, 0x00, 0x62, 0x00, 0x79, 0x00, 0x20, 0x00, 0x72, 0x00, 0x65, 0x00, 0x66, 0x00,
	0x65, 0x00, 0x72, 0x00, 0x65, 0x00, 0x6E, 0x00, 0x63, 0x00, 0x65, 0x00, 0x2E, 0x30, 0x81, 0x86,
	0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x01, 0x01, 0x04, 0x7A, 0x30, 0x78, 0x30, 0x24,
	0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x01, 0x86, 0x18, 0x68, 0x74, 0x74, 0x70,
	0x3A, 0x2F, 0x2F, 0x6F, 0x63, 0x73, 0x70, 0x2E, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74,
	0x2E, 0x63, 0x6F, 0x6D, 0x30, 0x50, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x02,
	0x86, 0x44, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x63, 0x61, 0x63, 0x65, 0x72, 0x74, 0x73,
	0x2E, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x44, 0x69,
	0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x48, 0x69, 0x67, 0x68, 0x41, 0x73, 0x73, 0x75, 0x72, 0x61,
	0x6E, 0x63, 0x65, 0x43, 0x6F, 0x64, 0x65, 0x53, 0x69, 0x67, 0x6E, 0x69, 0x6E, 0x67, 0x43, 0x41,
	0x2D, 0x31, 0x2E, 0x63, 0x72, 0x74, 0x30, 0x0C, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x01, 0x01, 0xFF,
	0x04, 0x02, 0x30, 0x00, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01,
	0x05, 0x05, 0x00, 0x03, 0x82, 0x01, 0x01, 0x00, 0xBB, 0xC0, 0x31, 0xB3, 0xDD, 0x6B, 0x1C, 0x6E,
	0xBE, 0xC7, 0x7B, 0x8D, 0xC1, 0xEC, 0xFA, 0x93, 0x81, 0x49, 0xC6, 0x4E, 0x0C, 0x95, 0x9E, 0x58,
	0x57, 0xDB, 0x5C, 0x28, 0xEF, 0x54, 0x9D, 0xDF, 0x0B, 0xE9, 0x20, 0xCC, 0xB7, 0xEC, 0x51, 0x5A,
	0xAE, 0xB1, 0x80, 0xA2, 0x8D, 0x64, 0xA1, 0xF4, 0x06, 0x5D, 0x38, 0xCB, 0x99, 0x7D, 0xB5, 0x92,
	0x95, 0xF1, 0x23, 0x85, 0x13, 0x92, 0x90, 0x3C, 0x67, 0x3E, 0xD6, 0xD1, 0xDB, 0x93, 0x0E, 0xC1,
	0x61, 0x8A, 0xDD, 0x99, 0x89, 0xF0, 0xF1, 0xFC, 0x8D, 0x06, 0xEC, 0x5A, 0x94, 0x52, 0x42, 0xCD,
	0x74, 0x32, 0xD6, 0x83, 0x8E, 0x33, 0xB4, 0xC3, 0xE4, 0x78, 0x4E, 0x75, 0x4B, 0x64, 0xDC, 0xE0,
	0x78, 0x68, 0x6A, 0xB2, 0xE6, 0x62, 0x68, 0x48, 0xFF, 0x7D, 0xCD, 0x6F, 0xB7, 0xEF, 0xEB, 0xFF,
	0xDF, 0xDA, 0xD1, 0xEE, 0xFC, 0x1E, 0x98, 0xF9, 0xC3, 0x38, 0xFF, 0x25, 0x65, 0xF0, 0x50, 0x39,
	0x17, 0x6B, 0x24, 0x14, 0x8A, 0x84, 0x16, 0x14, 0x63, 0x51, 0x57, 0xDA, 0x5F, 0x61, 0xA1, 0x7B,
	0xBD, 0x6D, 0x47, 0x98, 0x15, 0x71, 0x4E, 0x8D, 0x30, 0x67, 0xF0, 0x32, 0x0D, 0x5E, 0x8B, 0xFA,
	0xA6, 0xE3, 0x57, 0x31, 0x80, 0x49, 0x25, 0xDF, 0x9B, 0x85, 0xBA, 0x32, 0xC0, 0xD9, 0xF4, 0xCC,
	0xD4, 0x84, 0xD6, 0xD1, 0xB2, 0x79, 0xBA, 0xD0, 0xEF, 0x22, 0xB0, 0xDA, 0x37, 0x58, 0x26, 0xEA,
	0x2E, 0x11, 0x9D, 0x5C, 0x84, 0x8D, 0x9A, 0x92, 0x75, 0xB9, 0x3A, 0xBB, 0x08, 0x4C, 0x02, 0xAF,
	0x9F, 0x1B, 0x46, 0xC5, 0x35, 0x76, 0x52, 0xF1, 0x13, 0xF5, 0x56, 0xFD, 0xB9, 0xD1, 0x90, 0x02,
	0x23, 0x34, 0x15, 0x03, 0xF4, 0xE8, 0x9B, 0x98, 0xBA, 0xE1, 0x34, 0xF7, 0xCC, 0x9D, 0x64, 0x09,
	0xFC, 0xF7, 0x2D, 0x2C, 0x74, 0x6C, 0x71, 0x4A, 0x30, 0x82, 0x06, 0xC2, 0x30, 0x82, 0x05, 0xAA,
	0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x10, 0x02, 0xC4, 0xD1, 0xE5, 0x8A, 0x4A, 0x68, 0x0C, 0x56,
	0x8D, 0xA3, 0x04, 0x7E, 0x7E, 0x4D, 0x5F, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7,
	0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x6C, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04,
	0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x0C,
	0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x20, 0x49, 0x6E, 0x63, 0x31, 0x19, 0x30, 0x17,
	0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x10, 0x77, 0x77, 0x77, 0x2E, 0x64, 0x69, 0x67, 0x69, 0x63,
	0x65, 0x72, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x31, 0x2B, 0x30, 0x29, 0x06, 0x03, 0x55, 0x04, 0x03,
	0x13, 0x22, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x20, 0x48, 0x69, 0x67, 0x68, 0x20,
	0x41, 0x73, 0x73, 0x75, 0x72, 0x61, 0x6E, 0x63, 0x65, 0x20, 0x45, 0x56, 0x20, 0x52, 0x6F, 0x6F,
	0x74, 0x20, 0x43, 0x41, 0x30, 0x1E, 0x17, 0x0D, 0x31, 0x31, 0x30, 0x32, 0x31, 0x31, 0x31, 0x32,
	0x30, 0x30, 0x30, 0x30, 0x5A, 0x17, 0x0D, 0x32, 0x36, 0x30, 0x32, 0x31, 0x30, 0x31, 0x32, 0x30,
	0x30, 0x30, 0x30, 0x5A, 0x30, 0x73, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13,
	0x02, 0x55, 0x53, 0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x0C, 0x44, 0x69,
	0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x20, 0x49, 0x6E, 0x63, 0x31, 0x19, 0x30, 0x17, 0x06, 0x03,
	0x55, 0x04, 0x0B, 0x13, 0x10, 0x77, 0x77, 0x77, 0x2E, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72,
	0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x31, 0x32, 0x30, 0x30, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x29,
	0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x20, 0x48, 0x69, 0x67, 0x68, 0x20, 0x41, 0x73,
	0x73, 0x75, 0x72, 0x61, 0x6E, 0x63, 0x65, 0x20, 0x43, 0x6F, 0x64, 0x65, 0x20, 0x53, 0x69, 0x67,
	0x6E, 0x69, 0x6E, 0x67, 0x20, 0x43, 0x41, 0x2D, 0x31, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0D, 0x06,
	0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0F,
	0x00, 0x30, 0x82, 0x01, 0x0A, 0x02, 0x82, 0x01, 0x01, 0x00, 0xC5, 0xF9, 0x23, 0xE6, 0x94, 0x27,
	0xC4, 0x80, 0x14, 0xA4, 0x80, 0x32, 0x5F, 0x40, 0xA3, 0x8D, 0x6F, 0x70, 0xC0, 0xE5, 0x36, 0x71,
	0x71, 0x3A, 0x75, 0xA4, 0xAA, 0x1A, 0x92, 0x94, 0x89, 0x5E, 0xAC, 0x23, 0x71, 0xCB, 0x4E, 0x67,
	0x7D, 0x41, 0x3F, 0xAA, 0xE3, 0x4B, 0xB7, 0x7B, 0xBE, 0x9D, 0xC1, 0xA8, 0x38, 0x8F, 0x69, 0x2F,
	0x3A, 0x24, 0xE9, 0x77, 0x59, 0x12, 0xC7, 0x66, 0x04, 0x43, 0xC2, 0x0D, 0x26, 0x82, 0x89, 0x40,
	0x19, 0xF2, 0x2C, 0xEA, 0xE7, 0x4C, 0xE7, 0x7C, 0x05, 0x1A, 0xB8, 0xFF, 0x88, 0x09, 0x4F, 0x26,
	0x37, 0xEF, 0x3A, 0xA4, 0xFA, 0x22, 0x6C, 0x88, 0xC9, 0x4A, 0x1B, 0x61, 0xF2, 0xAE, 0x10, 0x5E,
	0x6F, 0xBC, 0xD1, 0x79, 0x9B, 0x59, 0x18, 0x60, 0xE5, 0xEE, 0x29, 0xB5, 0x03, 0x2A, 0xA4, 0xCE,
	0xF1, 0x83, 0x19, 0x4F, 0x69, 0x05, 0x73, 0x28, 0x09, 0xFB, 0x22, 0x10, 0x93, 0x22, 0xA0, 0x90,
	0x19, 0x1A, 0x4C, 0x31, 0xF2, 0xD3, 0x2B, 0xD8, 0x84, 0x43, 0xAF, 0x3C, 0x63, 0xFF, 0x98, 0xDB,
	0x20, 0xD2, 0x09, 0x2B, 0x54, 0xC1, 0xEA, 0xFD, 0x6A, 0x83, 0xE7, 0x10, 0xA3, 0x12, 0x71, 0xF5,
	0xD6, 0xD7, 0xE1, 0x12, 0x7A, 0xD5, 0xE0, 0x56, 0x5A, 0xCE, 0xEA, 0x01, 0x5B, 0x68, 0x65, 0x5B,
	0xC1, 0x3F, 0x58, 0x52, 0x33, 0xA9, 0x35, 0x61, 0x4E, 0x22, 0xCB, 0x81, 0xCA, 0x36, 0xA3, 0x12,
	0xCB, 0x06, 0xD6, 0xCF, 0x1B, 0x4D, 0x18, 0x7E, 0xB9, 0x92, 0xB9, 0x12, 0xCF, 0x40, 0x26, 0xD8,
	0x9A, 0x36, 0x85, 0xB3, 0x15, 0xAA, 0x47, 0x93, 0x84, 0x6B, 0x07, 0xBB, 0xBC, 0xD5, 0xB3, 0xDE,
	0x25, 0x00, 0x11, 0x89, 0x00, 0x68, 0xC1, 0x29, 0x3C, 0xEA, 0x3E, 0x2D, 0xEE, 0x50, 0xAB, 0xD7,
	0x1C, 0x30, 0x06, 0x78, 0x3C, 0xA5, 0x10, 0x23, 0x67, 0x91, 0x02, 0x03, 0x01, 0x00, 0x01, 0xA3,
	0x82, 0x03, 0x57, 0x30, 0x82, 0x03, 0x53, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x1D, 0x0F, 0x01, 0x01,
	0xFF, 0x04, 0x04, 0x03, 0x02, 0x01, 0x86, 0x30, 0x13, 0x06, 0x03, 0x55, 0x1D, 0x25, 0x04, 0x0C,
	0x30, 0x0A, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x03, 0x30, 0x82, 0x01, 0xC3,
	0x06, 0x03, 0x55, 0x1D, 0x20, 0x04, 0x82, 0x01, 0xBA, 0x30, 0x82, 0x01, 0xB6, 0x30, 0x82, 0x01,
	0xB2, 0x06, 0x08, 0x60, 0x86, 0x48, 0x01, 0x86, 0xFD, 0x6C, 0x03, 0x30, 0x82, 0x01, 0xA4, 0x30,
	0x3A, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x02, 0x01, 0x16, 0x2E, 0x68, 0x74, 0x74,
	0x70, 0x3A, 0x2F, 0x2F, 0x77, 0x77, 0x77, 0x2E, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74,
	0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x73, 0x73, 0x6C, 0x2D, 0x63, 0x70, 0x73, 0x2D, 0x72, 0x65, 0x70,
	0x6F, 0x73, 0x69, 0x74, 0x6F, 0x72, 0x79, 0x2E, 0x68, 0x74, 0x6D, 0x30, 0x82, 0x01, 0x64, 0x06,
	0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x02, 0x02, 0x30, 0x82, 0x01, 0x56, 0x1E, 0x82, 0x01,
	0x52, 0x00, 0x41, 0x00, 0x6E, 0x00, 0x79, 0x00, 0x20, 0x00, 0x75, 0x00, 0x73, 0x00, 0x65, 0x00,
	0x20, 0x00, 0x6F, 0x00, 0x66, 0x00, 0x20, 0x00, 0x74, 0x00, 0x68, 0x00, 0x69, 0x00, 0x73, 0x00,
	0x20, 0x00, 0x43, 0x00, 0x65, 0x00, 0x72, 0x00, 0x74, 0x00, 0x69, 0x00, 0x66, 0x00, 0x69, 0x00,
	0x63, 0x00, 0x61, 0x00, 0x74, 0x00, 0x65, 0x00, 0x20, 0x00, 0x63, 0x00, 0x6F, 0x00, 0x6E, 0x00,
	0x73, 0x00, 0x74, 0x00, 0x69, 0x00, 0x74, 0x00, 0x75, 0x00, 0x74, 0x00, 0x65, 0x00, 0x73, 0x00,
	0x20, 0x00, 0x61, 0x00, 0x63, 0x00, 0x63, 0x00, 0x65, 0x00, 0x70, 0x00, 0x74, 0x00, 0x61, 0x00,
	0x6E, 0x00, 0x63, 0x00, 0x65, 0x00, 0x20, 0x00, 0x6F, 0x00, 0x66, 0x00, 0x20, 0x00, 0x74, 0x00,
	0x68, 0x00, 0x65, 0x00, 0x20, 0x00, 0x44, 0x00, 0x69, 0x00, 0x67, 0x00, 0x69, 0x00, 0x43, 0x00,
	0x65, 0x00, 0x72, 0x00, 0x74, 0x00, 0x20, 0x00, 0x43, 0x00, 0x50, 0x00, 0x2F, 0x00, 0x43, 0x00,
	0x50, 0x00, 0x53, 0x00, 0x20, 0x00, 0x61, 0x00, 0x6E, 0x00, 0x64, 0x00, 0x20, 0x00, 0x74, 0x00,
	0x68, 0x00, 0x65, 0x00, 0x20, 0x00, 0x52, 0x00, 0x65, 0x00, 0x6C, 0x00, 0x79, 0x00, 0x69, 0x00,
	0x6E, 0x00, 0x67, 0x00, 0x20, 0x00, 0x50, 0x00, 0x61, 0x00, 0x72, 0x00, 0x74, 0x00, 0x79, 0x00,
	0x20, 0x00, 0x41, 0x00, 0x67, 0x00, 0x72, 0x00, 0x65, 0x00, 0x65, 0x00, 0x6D, 0x00, 0x65, 0x00,
	0x6E, 0x00, 0x74, 0x00, 0x20, 0x00, 0x77, 0x00, 0x68, 0x00, 0x69, 0x00, 0x63, 0x00, 0x68, 0x00,
	0x20, 0x00, 0x6C, 0x00, 0x69, 0x00, 0x6D, 0x00, 0x69, 0x00, 0x74, 0x00, 0x20, 0x00, 0x6C, 0x00,
	0x69, 0x00, 0x61, 0x00, 0x62, 0x00, 0x69, 0x00, 0x6C, 0x00, 0x69, 0x00, 0x74, 0x00, 0x79, 0x00,
	0x20, 0x00, 0x61, 0x00, 0x6E, 0x00, 0x64, 0x00, 0x20, 0x00, 0x61, 0x00, 0x72, 0x00, 0x65, 0x00,
	0x20, 0x00, 0x69, 0x00, 0x6E, 0x00, 0x63, 0x00, 0x6F, 0x00, 0x72, 0x00, 0x70, 0x00, 0x6F, 0x00,
	0x72, 0x00, 0x61, 0x00, 0x74, 0x00, 0x65, 0x00, 0x64, 0x00, 0x20, 0x00, 0x68, 0x00, 0x65, 0x00,
	0x72, 0x00, 0x65, 0x00, 0x69, 0x00, 0x6E, 0x00, 0x20, 0x00, 0x62, 0x00, 0x79, 0x00, 0x20, 0x00,
	0x72, 0x00, 0x65, 0x00, 0x66, 0x00, 0x65, 0x00, 0x72, 0x00, 0x65, 0x00, 0x6E, 0x00, 0x63, 0x00,
	0x65, 0x00, 0x2E, 0x30, 0x12, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x01, 0x01, 0xFF, 0x04, 0x08, 0x30,
	0x06, 0x01, 0x01, 0xFF, 0x02, 0x01, 0x00, 0x30, 0x7F, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05,
	0x07, 0x01, 0x01, 0x04, 0x73, 0x30, 0x71, 0x30, 0x24, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05,
	0x07, 0x30, 0x01, 0x86, 0x18, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x6F, 0x63, 0x73, 0x70,
	0x2E, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x30, 0x49, 0x06,
	0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x02, 0x86, 0x3D, 0x68, 0x74, 0x74, 0x70, 0x3A,
	0x2F, 0x2F, 0x63, 0x61, 0x63, 0x65, 0x72, 0x74, 0x73, 0x2E, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65,
	0x72, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x48,
	0x69, 0x67, 0x68, 0x41, 0x73, 0x73, 0x75, 0x72, 0x61, 0x6E, 0x63, 0x65, 0x45, 0x56, 0x52, 0x6F,
	0x6F, 0x74, 0x43, 0x41, 0x2E, 0x63, 0x72, 0x74, 0x30, 0x81, 0x8F, 0x06, 0x03, 0x55, 0x1D, 0x1F,
	0x04, 0x81, 0x87, 0x30, 0x81, 0x84, 0x30, 0x40, 0xA0, 0x3E, 0xA0, 0x3C, 0x86, 0x3A, 0x68, 0x74,
	0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x63, 0x72, 0x6C, 0x33, 0x2E, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65,
	0x72, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x48,
	0x69, 0x67, 0x68, 0x41, 0x73, 0x73, 0x75, 0x72, 0x61, 0x6E, 0x63, 0x65, 0x45, 0x56, 0x52, 0x6F,
	0x6F, 0x74, 0x43, 0x41, 0x2E, 0x63, 0x72, 0x6C, 0x30, 0x40, 0xA0, 0x3E, 0xA0, 0x3C, 0x86, 0x3A,
	0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x63, 0x72, 0x6C, 0x34, 0x2E, 0x64, 0x69, 0x67, 0x69,
	0x63, 0x65, 0x72, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72,
	0x74, 0x48, 0x69, 0x67, 0x68, 0x41, 0x73, 0x73, 0x75, 0x72, 0x61, 0x6E, 0x63, 0x65, 0x45, 0x56,
	0x52, 0x6F, 0x6F, 0x74, 0x43, 0x41, 0x2E, 0x63, 0x72, 0x6C, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x1D,
	0x0E, 0x04, 0x16, 0x04, 0x14, 0x97, 0x48, 0x03, 0xEB, 0x15, 0x08, 0x6B, 0xB9, 0xB2, 0x58, 0x23,
	0xCC, 0x94, 0x2E, 0xF1, 0xC6, 0x65, 0xD2, 0x64, 0x8E, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x1D, 0x23,
	0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0xB1, 0x3E, 0xC3, 0x69, 0x03, 0xF8, 0xBF, 0x47, 0x01, 0xD4,
	0x98, 0x26, 0x1A, 0x08, 0x02, 0xEF, 0x63, 0x64, 0x2B, 0xC3, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86,
	0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x82, 0x01, 0x01, 0x00, 0x49, 0xEB,
	0x7C, 0x60, 0xBE, 0xAE, 0xEF, 0xC9, 0x7C, 0xB3, 0xC5, 0xBA, 0x4B, 0x64, 0xDF, 0x16, 0x69, 0xE2,
	0x86, 0xFA, 0x29, 0xD9, 0xDE, 0x98, 0x85, 0x7D, 0x40, 0x66, 0x26, 0x33, 0x2F, 0x44, 0x55, 0xAA,
	0xAA, 0x90, 0xE9, 0x35, 0x70, 0x0A, 0x34, 0xBE, 0xD3, 0xAE, 0x54, 0x2E, 0x8E, 0x65, 0x00, 0xD6,
	0x7A, 0x32, 0x20, 0x3E, 0x6C, 0x26, 0xB8, 0x98, 0xA9, 0x39, 0xB1, 0xBC, 0x95, 0xC7, 0xAA, 0xE9,
	0xF5, 0xEE, 0x46, 0x66, 0xC6, 0xB3, 0xE8, 0x12, 0xF8, 0xB3, 0x97, 0x9D, 0xFF, 0x74, 0x58, 0x82,
	0x34, 0x99, 0x75, 0x50, 0xAC, 0x44, 0x8F, 0xE8, 0x92, 0xCE, 0x7D, 0x8B, 0x0F, 0x31, 0x96, 0xC7,
	0xDC, 0xD3, 0x11, 0x30, 0x98, 0x74, 0x16, 0xC6, 0xE5, 0x6B, 0x45, 0x76, 0xA3, 0x94, 0x01, 0xCD,
	0x33, 0x00, 0x7A, 0x48, 0xF6, 0x6F, 0x86, 0x31, 0xC9, 0x56, 0x2B, 0x33, 0x22, 0xD5, 0xF8, 0x01,
	0xB6, 0x44, 0xCE, 0x8C, 0xB4, 0xCA, 0x88, 0xD2, 0xE4, 0x16, 0xE3, 0xE7, 0xF6, 0xE2, 0x3E, 0xE1,
	0x09, 0xC0, 0x9D, 0x79, 0x43, 0x43, 0x7F, 0x55, 0x5C, 0x05, 0xAD, 0x93, 0x10, 0xC6, 0x2C, 0x0D,
	0x6B, 0xC0, 0x9E, 0xEA, 0x78, 0xE5, 0xD2, 0x77, 0xD6, 0xB8, 0xDA, 0x9A, 0x98, 0x7F, 0xBA, 0x4C,
	0x92, 0x2B, 0x9D, 0xBD, 0xA4, 0x88, 0xB1, 0xDD, 0xAF, 0xC3, 0x4C, 0xD2, 0x97, 0x9B, 0x03, 0xC6,
	0xAE, 0x5F, 0x1B, 0x44, 0x0F, 0x33, 0x37, 0x15, 0xE3, 0xCB, 0xFF, 0x2F, 0x56, 0xD3, 0x16, 0xA4,
	0x5B, 0x55, 0x67, 0x9D, 0xA2, 0xCA, 0xDB, 0x34, 0x6C, 0x0C, 0x73, 0x4A, 0xB5, 0x7B, 0xA4, 0xB6,
	0xB3, 0xE9, 0x35, 0x02, 0x78, 0x70, 0xEC, 0x00, 0x7A, 0xCB, 0xFC, 0x4B, 0x4F, 0x22, 0x36, 0xBB,
	0x14, 0x84, 0xC9, 0x8F, 0x91, 0xDD, 0x0F, 0x3C, 0x75, 0x8C, 0xCA, 0x0B, 0x88, 0xE7, 0x30, 0x82,
	0x06, 0xCD, 0x30, 0x82, 0x05, 0xB5, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x10, 0x06, 0xFD, 0xF9,
	0x03, 0x96, 0x03, 0xAD, 0xEA, 0x00, 0x0A, 0xEB, 0x3F, 0x27, 0xBB, 0xBA, 0x1B, 0x30, 0x0D, 0x06,
	0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x65, 0x31, 0x0B,
	0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x15, 0x30, 0x13, 0x06,
	0x03, 0x55, 0x04, 0x0A, 0x13, 0x0C, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x20, 0x49,
	0x6E, 0x63, 0x31, 0x19, 0x30, 0x17, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x10, 0x77, 0x77, 0x77,
	0x2E, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x31, 0x24, 0x30,
	0x22, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x1B, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74,
	0x20, 0x41, 0x73, 0x73, 0x75, 0x72, 0x65, 0x64, 0x20, 0x49, 0x44, 0x20, 0x52, 0x6F, 0x6F, 0x74,
	0x20, 0x43, 0x41, 0x30, 0x1E, 0x17, 0x0D, 0x30, 0x36, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30,
	0x30, 0x30, 0x30, 0x5A, 0x17, 0x0D, 0x32, 0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30,
	0x30, 0x30, 0x5A, 0x30, 0x62, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02,
	0x55, 0x53, 0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x0C, 0x44, 0x69, 0x67,
	0x69, 0x43, 0x65, 0x72, 0x74, 0x20, 0x49, 0x6E, 0x63, 0x31, 0x19, 0x30, 0x17, 0x06, 0x03, 0x55,
	0x04, 0x0B, 0x13, 0x10, 0x77, 0x77, 0x77, 0x2E, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74,
	0x2E, 0x63, 0x6F, 0x6D, 0x31, 0x21, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x18, 0x44,
	0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x20, 0x41, 0x73, 0x73, 0x75, 0x72, 0x65, 0x64, 0x20,
	0x49, 0x44, 0x20, 0x43, 0x41, 0x2D, 0x31, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0D, 0x06, 0x09, 0x2A,
	0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0F, 0x00, 0x30,
	0x82, 0x01, 0x0A, 0x02, 0x82, 0x01, 0x01, 0x00, 0xE8, 0x82, 0x2D, 0x99, 0xF9, 0xCA, 0xC2, 0x42,
	0x95, 0xA5, 0x80, 0x73, 0x40, 0x70, 0xD2, 0x9E, 0x56, 0x54, 0x5C, 0xA9, 0xC4, 0xD2, 0x41, 0x06,
	0x8F, 0xC9, 0x33, 0xFC, 0x4D, 0x45, 0x91, 0x5C, 0x81, 0x9F, 0xED, 0x2C, 0x9C, 0xF8, 0x16, 0x59,
	0xDF, 0x9E, 0xB5, 0x24, 0x15, 0xC2, 0x98, 0xB9, 0xB4, 0x77, 0x49, 0xDC, 0x89, 0xC4, 0x0A, 0xDA,
	0xAF, 0xCB, 0x5E, 0x6B, 0xED, 0xAD, 0xB0, 0x71, 0x31, 0xEB, 0xCF, 0x3A, 0x40, 0x0C, 0x46, 0x4D,
	0x93, 0xEC, 0x8B, 0x7A, 0x36, 0x08, 0x03, 0xAB, 0x0C, 0x34, 0xFE, 0x18, 0x49, 0x82, 0xFE, 0xC7,
	0xC7, 0x31, 0x48, 0x80, 0x7C, 0x1E, 0xA2, 0x0F, 0x92, 0x0E, 0x50, 0xC9, 0xC6, 0x87, 0xEB, 0x36,
	0x3F, 0xD8, 0x30, 0xC3, 0xFF, 0xA6, 0xF7, 0xFB, 0xA2, 0xCD, 0x6F, 0x73, 0x23, 0xFE, 0xAC, 0x56,
	0x05, 0x90, 0xF0, 0x32, 0x21, 0x16, 0x89, 0xC6, 0x70, 0x88, 0xF9, 0x05, 0x97, 0x7D, 0xA3, 0xC7,
	0x43, 0xDD, 0x02, 0xE8, 0x3B, 0x3D, 0xED, 0xB1, 0x41, 0xA3, 0xED, 0x3F, 0xBE, 0xDB, 0x95, 0x48,
	0xC4, 0xEE, 0x1E, 0xB3, 0xF2, 0xBC, 0x0C, 0x2B, 0x99, 0xD0, 0xC6, 0x5D, 0x12, 0x42, 0x81, 0xE1,
	0x83, 0x6E, 0x82, 0x73, 0x3F, 0x26, 0x4B, 0x14, 0x90, 0xAE, 0x59, 0x66, 0x0A, 0xC4, 0x8D, 0xBE,
	0xD2, 0xCE, 0x06, 0xAE, 0xAD, 0x84, 0x6F, 0x48, 0x84, 0x9B, 0x4F, 0x40, 0xB9, 0xF1, 0x4C, 0xF2,
	0xAF, 0x98, 0xFB, 0xF6, 0xCE, 0x40, 0x5D, 0x5C, 0xF6, 0xA8, 0xF1, 0x2F, 0xAF, 0xEC, 0x89, 0x22,
	0xF2, 0x6B, 0x18, 0x65, 0xB1, 0xC1, 0x73, 0xAD, 0xD7, 0xF1, 0xD8, 0xCF, 0x1E, 0x0A, 0x74, 0x5C,
	0x42, 0xB8, 0x68, 0x7E, 0xB7, 0xD5, 0x77, 0x0A, 0x27, 0x56, 0x7C, 0x0F, 0x62, 0xA4, 0x3F, 0x32,
	0x14, 0x60, 0x95, 0xFD, 0x07, 0x04, 0xA2, 0x09, 0x02, 0x03, 0x01, 0x00, 0x01, 0xA3, 0x82, 0x03,
	0x7A, 0x30, 0x82, 0x03, 0x76, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x1D, 0x0F, 0x01, 0x01, 0xFF, 0x04,
	0x04, 0x03, 0x02, 0x01, 0x86, 0x30, 0x3B, 0x06, 0x03, 0x55, 0x1D, 0x25, 0x04, 0x34, 0x30, 0x32,
	0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x01, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05,
	0x05, 0x07, 0x03, 0x02, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x03, 0x06, 0x08,
	0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x04, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07,
	0x03, 0x08, 0x30, 0x82, 0x01, 0xD2, 0x06, 0x03, 0x55, 0x1D, 0x20, 0x04, 0x82, 0x01, 0xC9, 0x30,
	0x82, 0x01, 0xC5, 0x30, 0x82, 0x01, 0xB4, 0x06, 0x0A, 0x60, 0x86, 0x48, 0x01, 0x86, 0xFD, 0x6C,
	0x00, 0x01, 0x04, 0x30, 0x82, 0x01, 0xA4, 0x30, 0x3A, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05,
	0x07, 0x02, 0x01, 0x16, 0x2E, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x77, 0x77, 0x77, 0x2E,
	0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x73, 0x73, 0x6C,
	0x2D, 0x63, 0x70, 0x73, 0x2D, 0x72, 0x65, 0x70, 0x6F, 0x73, 0x69, 0x74, 0x6F, 0x72, 0x79, 0x2E,
	0x68, 0x74, 0x6D, 0x30, 0x82, 0x01, 0x64, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x02,
	0x02, 0x30, 0x82, 0x01, 0x56, 0x1E, 0x82, 0x01, 0x52, 0x00, 0x41, 0x00, 0x6E, 0x00, 0x79, 0x00,
	0x20, 0x00, 0x75, 0x00, 0x73, 0x00, 0x65, 0x00, 0x20, 0x00, 0x6F, 0x00, 0x66, 0x00, 0x20, 0x00,
	0x74, 0x00, 0x68, 0x00, 0x69, 0x00, 0x73, 0x00, 0x20, 0x00, 0x43, 0x00, 0x65, 0x00, 0x72, 0x00,
	0x74, 0x00, 0x69, 0x00, 0x66, 0x00, 0x69, 0x00, 0x63, 0x00, 0x61, 0x00, 0x74, 0x00, 0x65, 0x00,
	0x20, 0x00, 0x63, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x73, 0x00, 0x74, 0x00, 0x69, 0x00, 0x74, 0x00,
	0x75, 0x00, 0x74, 0x00, 0x65, 0x00, 0x73, 0x00, 0x20, 0x00, 0x61, 0x00, 0x63, 0x00, 0x63, 0x00,
	0x65, 0x00, 0x70, 0x00, 0x74, 0x00, 0x61, 0x00, 0x6E, 0x00, 0x63, 0x00, 0x65, 0x00, 0x20, 0x00,
	0x6F, 0x00, 0x66, 0x00, 0x20, 0x00, 0x74, 0x00, 0x68, 0x00, 0x65, 0x00, 0x20, 0x00, 0x44, 0x00,
	0x69, 0x00, 0x67, 0x00, 0x69, 0x00, 0x43, 0x00, 0x65, 0x00, 0x72, 0x00, 0x74, 0x00, 0x20, 0x00,
	0x43, 0x00, 0x50, 0x00, 0x2F, 0x00, 0x43, 0x00, 0x50, 0x00, 0x53, 0x00, 0x20, 0x00, 0x61, 0x00,
	0x6E, 0x00, 0x64, 0x00, 0x20, 0x00, 0x74, 0x00, 0x68, 0x00, 0x65, 0x00, 0x20, 0x00, 0x52, 0x00,
	0x65, 0x00, 0x6C, 0x00, 0x79, 0x00, 0x69, 0x00, 0x6E, 0x00, 0x67, 0x00, 0x20, 0x00, 0x50, 0x00,
	0x61, 0x00, 0x72, 0x00, 0x74, 0x00, 0x79, 0x00, 0x20, 0x00, 0x41, 0x00, 0x67, 0x00, 0x72, 0x00,
	0x65, 0x00, 0x65, 0x00, 0x6D, 0x00, 0x65, 0x00, 0x6E, 0x00, 0x74, 0x00, 0x20, 0x00, 0x77, 0x00,
	0x68, 0x00, 0x69, 0x00, 0x63, 0x00, 0x68, 0x00, 0x20, 0x00, 0x6C, 0x00, 0x69, 0x00, 0x6D, 0x00,
	0x69, 0x00, 0x74, 0x00, 0x20, 0x00, 0x6C, 0x00, 0x69, 0x00, 0x61, 0x00, 0x62, 0x00, 0x69, 0x00,
	0x6C, 0x00, 0x69, 0x00, 0x74, 0x00, 0x79, 0x00, 0x20, 0x00, 0x61, 0x00, 0x6E, 0x00, 0x64, 0x00,
	0x20, 0x00, 0x61, 0x00, 0x72, 0x00, 0x65, 0x00, 0x20, 0x00, 0x69, 0x00, 0x6E, 0x00, 0x63, 0x00,
	0x6F, 0x00, 0x72, 0x00, 0x70, 0x00, 0x6F, 0x00, 0x72, 0x00, 0x61, 0x00, 0x74, 0x00, 0x65, 0x00,
	0x64, 0x00, 0x20, 0x00, 0x68, 0x00, 0x65, 0x00, 0x72, 0x00, 0x65, 0x00, 0x69, 0x00, 0x6E, 0x00,
	0x20, 0x00, 0x62, 0x00, 0x79, 0x00, 0x20, 0x00, 0x72, 0x00, 0x65, 0x00, 0x66, 0x00, 0x65, 0x00,
	0x72, 0x00, 0x65, 0x00, 0x6E, 0x00, 0x63, 0x00, 0x65, 0x00, 0x2E, 0x30, 0x0B, 0x06, 0x09, 0x60,
	0x86, 0x48, 0x01, 0x86, 0xFD, 0x6C, 0x03, 0x15, 0x30, 0x12, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x01,
	0x01, 0xFF, 0x04, 0x08, 0x30, 0x06, 0x01, 0x01, 0xFF, 0x02, 0x01, 0x00, 0x30, 0x79, 0x06, 0x08,
	0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x01, 0x01, 0x04, 0x6D, 0x30, 0x6B, 0x30, 0x24, 0x06, 0x08,
	0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x01, 0x86, 0x18, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F,
	0x2F, 0x6F, 0x63, 0x73, 0x70, 0x2E, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2E, 0x63,
	0x6F, 0x6D, 0x30, 0x43, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x02, 0x86, 0x37,
	0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x63, 0x61, 0x63, 0x65, 0x72, 0x74, 0x73, 0x2E, 0x64,
	0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x44, 0x69, 0x67, 0x69,
	0x43, 0x65, 0x72, 0x74, 0x41, 0x73, 0x73, 0x75, 0x72, 0x65, 0x64, 0x49, 0x44, 0x52, 0x6F, 0x6F,
	0x74, 0x43, 0x41, 0x2E, 0x63, 0x72, 0x74, 0x30, 0x81, 0x81, 0x06, 0x03, 0x55, 0x1D, 0x1F, 0x04,
	0x7A, 0x30, 0x78, 0x30, 0x3A, 0xA0, 0x38, 0xA0, 0x36, 0x86, 0x34, 0x68, 0x74, 0x74, 0x70, 0x3A,
	0x2F, 0x2F, 0x63, 0x72, 0x6C, 0x33, 0x2E, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2E,
	0x63, 0x6F, 0x6D, 0x2F, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x41, 0x73, 0x73, 0x75,
	0x72, 0x65, 0x64, 0x49, 0x44, 0x52, 0x6F, 0x6F, 0x74, 0x43, 0x41, 0x2E, 0x63, 0x72, 0x6C, 0x30,
	0x3A, 0xA0, 0x38, 0xA0, 0x36, 0x86, 0x34, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x63, 0x72,
	0x6C, 0x34, 0x2E, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x2F,
	0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x41, 0x73, 0x73, 0x75, 0x72, 0x65, 0x64, 0x49,
	0x44, 0x52, 0x6F, 0x6F, 0x74, 0x43, 0x41, 0x2E, 0x63, 0x72, 0x6C, 0x30, 0x1D, 0x06, 0x03, 0x55,
	0x1D, 0x0E, 0x04, 0x16, 0x04, 0x14, 0x15, 0x00, 0x12, 0x2B, 0x13, 0x98, 0xB2, 0x99, 0x07, 0xED,
	0x1E, 0xDF, 0xA2, 0xBE, 0x57, 0x0D, 0x2B, 0x67, 0x02, 0xCD, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x1D,
	0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0x45, 0xEB, 0xA2, 0xAF, 0xF4, 0x92, 0xCB, 0x82, 0x31,
	0x2D, 0x51, 0x8B, 0xA7, 0xA7, 0x21, 0x9D, 0xF3, 0x6D, 0xC8, 0x0F, 0x30, 0x0D, 0x06, 0x09, 0x2A,
	0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x82, 0x01, 0x01, 0x00, 0x46,
	0x50, 0x3E, 0xC9, 0xB7, 0x28, 0x24, 0xA7, 0x38, 0x1D, 0xB6, 0x5B, 0x29, 0xAF, 0x52, 0xCF, 0x52,
	0xE9, 0x31, 0x47, 0xAB, 0x56, 0x5C, 0x7B, 0xD5, 0x0D, 0x0B, 0x41, 0xB3, 0xEF, 0xEC, 0x75, 0x1F,
	0x74, 0x38, 0xF2, 0xB2, 0x5C, 0x61, 0xA2, 0x9C, 0x95, 0xC3, 0x50, 0xE4, 0x82, 0xB9, 0x23, 0xD1,
	0xBA, 0x3A, 0x86, 0x72, 0xAD, 0x38, 0x78, 0xAC, 0x75, 0x5D, 0x17, 0x17, 0x34, 0x72, 0x47, 0x85,
	0x94, 0x56, 0xD1, 0xEB, 0xBB, 0x36, 0x84, 0x77, 0xCC, 0x24, 0xA5, 0xF3, 0x04, 0x19, 0x55, 0xA9,
	0xE7, 0xE3, 0xE7, 0xAB, 0x62, 0xCD, 0xFB, 0x8B, 0x2D, 0x90, 0xC2, 0xC0, 0xD2, 0xB5, 0x94, 0xBD,
	0x5E, 0x4F, 0xB1, 0x05, 0xD2, 0x0E, 0x3D, 0x1A, 0xA9, 0x14, 0x5B, 0xA6, 0x86, 0x31, 0x62, 0xA8,
	0xA8, 0x33, 0xE4, 0x9B, 0x39, 0xA7, 0xC4, 0xF5, 0xCE, 0x1D, 0x78, 0x76, 0x94, 0x25, 0x73, 0xE4,
	0x2A, 0xAB, 0xCF, 0x9C, 0x76, 0x4B, 0xED, 0x5F, 0xC2, 0x4B, 0x16, 0xE4, 0x4B, 0x70, 0x4C, 0x00,
	0x89, 0x1E, 0xFC, 0xC5, 0x79, 0xBC, 0x4C, 0x12, 0x57, 0xFE, 0x5F, 0xE1, 0x1E, 0xBC, 0x02, 0x5D,
	0xA8, 0xFE, 0xFB, 0x07, 0x38, 0x4F, 0x0D, 0xC6, 0x5D, 0x91, 0xB9, 0x0F, 0x67, 0x45, 0xCD, 0xD6,
	0x83, 0xED, 0xE7, 0x92, 0x0D, 0x8D, 0xB1, 0x69, 0x8C, 0x4F, 0xFB, 0x59, 0xE0, 0x23, 0x0F, 0xD2,
	0xAA, 0xAE, 0x00, 0x7C, 0xEE, 0x9C, 0x42, 0x0E, 0xCF, 0x91, 0xD7, 0x27, 0xB7, 0x16, 0xEE, 0x0F,
	0xC3, 0xBD, 0x7C, 0x0A, 0xA0, 0xEE, 0x2C, 0x08, 0x55, 0x85, 0x22, 0xB8, 0xEB, 0x18, 0x1A, 0x4D,
	0xFC, 0x2A, 0x21, 0xAD, 0x49, 0x31, 0x83, 0x47, 0x95, 0x77, 0x71, 0xDC, 0xB1, 0x1B, 0x4B, 0x4B,
	0x1C, 0x10, 0x9C, 0x77, 0x14, 0xC1, 0x9D, 0x4F, 0x2F, 0x5A, 0x95, 0x08, 0x29, 0x10, 0x26, 0x31,
	0x82, 0x04, 0x34, 0x30, 0x82, 0x04, 0x30, 0x02, 0x01, 0x01, 0x30, 0x81, 0x87, 0x30, 0x73, 0x31,
	0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x15, 0x30, 0x13,
	0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x0C, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x20,
	0x49, 0x6E, 0x63, 0x31, 0x19, 0x30, 0x17, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x10, 0x77, 0x77,
	0x77, 0x2E, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x31, 0x32,
	0x30, 0x30, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x29, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72,
	0x74, 0x20, 0x48, 0x69, 0x67, 0x68, 0x20, 0x41, 0x73, 0x73, 0x75, 0x72, 0x61, 0x6E, 0x63, 0x65,
	0x20, 0x43, 0x6F, 0x64, 0x65, 0x20, 0x53, 0x69, 0x67, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x43, 0x41,
	0x2D, 0x31, 0x02, 0x10, 0x03, 0xE9, 0x01, 0x7D, 0x54, 0xCD, 0x93, 0xF0, 0x94, 0xD0, 0xA2, 0xAB,
	0x7F, 0xC0, 0xE3, 0xF5, 0x30, 0x09, 0x06, 0x05, 0x2B, 0x0E, 0x03, 0x02, 0x1A, 0x05, 0x00, 0xA0,
	0x70, 0x30, 0x10, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x0C, 0x31,
	0x02, 0x30, 0x00, 0x30, 0x19, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x03,
	0x31, 0x0C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x04, 0x30, 0x1C,
	0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x0B, 0x31, 0x0E, 0x30, 0x0C,
	0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x15, 0x30, 0x23, 0x06, 0x09,
	0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x04, 0x31, 0x16, 0x04, 0x14, 0xE6, 0x7D, 0x64,
	0x4F, 0x60, 0xEB, 0xF0, 0x7E, 0xBC, 0x21, 0x86, 0x75, 0x1F, 0x02, 0x93, 0xA2, 0x42, 0xDB, 0xB7,
	0x73, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00,
	0x04, 0x82, 0x01, 0x00, 0x1D, 0x12, 0xFE, 0x8D, 0x1F, 0xEA, 0x97, 0x9C, 0x81, 0x84, 0xCD, 0x4E,
	0xDA, 0x22, 0x1B, 0x0E, 0x01, 0xB3, 0x3B, 0xE3, 0xBC, 0x4D, 0x45, 0x2C, 0xD4, 0xD9, 0x1A, 0xED,
	0x9A, 0x4E, 0xF3, 0x20, 0xEF, 0x46, 0xDB, 0xEA, 0x22, 0x2C, 0x83, 0xA2, 0xEB, 0x30, 0x04, 0x5F,
	0x0F, 0xD0, 0xEE, 0x5D, 0x61, 0x68, 0x18, 0x47, 0xBD, 0x5A, 0x94, 0x7C, 0x8C, 0x26, 0xD7, 0x5F,
	0x34, 0x35, 0x84, 0xD6, 0xEE, 0x46, 0xA4, 0x86, 0xA2, 0xF2, 0xDB, 0x22, 0xC8, 0x80, 0xB6, 0xCA,
	0x0E, 0x3B, 0x0A, 0x16, 0x10, 0x50, 0x43, 0xD9, 0x75, 0x53, 0xCD, 0x76, 0x2F, 0x0B, 0x08, 0x7D,
	0xF8, 0x65, 0x23, 0x7F, 0xBC, 0x7A, 0x9F, 0x4B, 0xBA, 0x67, 0xF2, 0x16, 0x17, 0x75, 0x57, 0x66,
	0x4C, 0x54, 0x51, 0xAC, 0x02, 0x4C, 0x68, 0x96, 0xB7, 0x80, 0xBE, 0xD9, 0x3B, 0x08, 0xE4, 0x8D,
	0x6E, 0x06, 0x3D, 0x4C, 0x6F, 0x38, 0x22, 0xF8, 0xF9, 0xBC, 0xD7, 0xD8, 0x4F, 0xC7, 0x73, 0x3B,
	0xB1, 0x0F, 0x53, 0x75, 0x1A, 0x72, 0xDA, 0xCA, 0x77, 0x78, 0x69, 0x22, 0x45, 0x5A, 0x4E, 0x45,
	0xC3, 0xF5, 0xC5, 0x48, 0x99, 0x27, 0x1B, 0x80, 0x4B, 0x8E, 0x43, 0x27, 0x00, 0xC6, 0x74, 0x72,
	0x79, 0x69, 0x47, 0x8D, 0x40, 0x30, 0x23, 0xBC, 0xE6, 0x08, 0x5D, 0x47, 0x19, 0xFF, 0xFE, 0x85,
	0xDC, 0x3F, 0x81, 0xD2, 0x8B, 0x22, 0x4A, 0x32, 0x4D, 0x30, 0xB8, 0xA5, 0x83, 0xA8, 0xCF, 0xB7,
	0xFA, 0x7F, 0x30, 0xAE, 0xD9, 0x6C, 0x8D, 0x4D, 0x44, 0x40, 0xED, 0x58, 0x30, 0xED, 0x29, 0xF7,
	0xB2, 0x27, 0xA8, 0x38, 0x65, 0x0B, 0x3A, 0xBE, 0x38, 0x40, 0xBE, 0xDD, 0x21, 0x09, 0xE2, 0x1B,
	0x53, 0xE6, 0x44, 0x42, 0x8C, 0x27, 0x3F, 0x67, 0xD0, 0x91, 0xF0, 0x60, 0xD8, 0xF9, 0x2B, 0x2C,
	0x04, 0x79, 0x88, 0xB5, 0xA1, 0x82, 0x02, 0x0F, 0x30, 0x82, 0x02, 0x0B, 0x06, 0x09, 0x2A, 0x86,
	0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x06, 0x31, 0x82, 0x01, 0xFC, 0x30, 0x82, 0x01, 0xF8, 0x02,
	0x01, 0x01, 0x30, 0x76, 0x30, 0x62, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13,
	0x02, 0x55, 0x53, 0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x0C, 0x44, 0x69,
	0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x20, 0x49, 0x6E, 0x63, 0x31, 0x19, 0x30, 0x17, 0x06, 0x03,
	0x55, 0x04, 0x0B, 0x13, 0x10, 0x77, 0x77, 0x77, 0x2E, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72,
	0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x31, 0x21, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x18,
	0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x20, 0x41, 0x73, 0x73, 0x75, 0x72, 0x65, 0x64,
	0x20, 0x49, 0x44, 0x20, 0x43, 0x41, 0x2D, 0x31, 0x02, 0x10, 0x03, 0x01, 0x9A, 0x02, 0x3A, 0xFF,
	0x58, 0xB1, 0x6B, 0xD6, 0xD5, 0xEA, 0xE6, 0x17, 0xF0, 0x66, 0x30, 0x09, 0x06, 0x05, 0x2B, 0x0E,
	0x03, 0x02, 0x1A, 0x05, 0x00, 0xA0, 0x5D, 0x30, 0x18, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7,
	0x0D, 0x01, 0x09, 0x03, 0x31, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07,
	0x01, 0x30, 0x1C, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x05, 0x31, 0x0F,
	0x17, 0x0D, 0x31, 0x35, 0x30, 0x35, 0x33, 0x30, 0x30, 0x38, 0x34, 0x32, 0x31, 0x34, 0x5A, 0x30,
	0x23, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x04, 0x31, 0x16, 0x04, 0x14,
	0x88, 0x9D, 0x5C, 0x13, 0x59, 0xC1, 0x1B, 0xE0, 0x00, 0xD7, 0xB8, 0x63, 0x7B, 0x77, 0x85, 0x9C,
	0x7C, 0xE8, 0x30, 0x6C, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01,
	0x01, 0x05, 0x00, 0x04, 0x82, 0x01, 0x00, 0x81, 0x7C, 0xB0, 0x53, 0x40, 0xE3, 0xAE, 0x29, 0x4B,
	0xA3, 0x74, 0x67, 0xB0, 0x84, 0xFF, 0x51, 0xCC, 0xB3, 0x76, 0xE3, 0x46, 0xC0, 0x6D, 0xA0, 0x1C,
	0x1A, 0x83, 0x3F, 0xBA, 0x17, 0xD1, 0x38, 0xF0, 0xD6, 0x6F, 0x3D, 0x28, 0xBA, 0x5B, 0x64, 0xC3,
	0x06, 0x44, 0xFB, 0x34, 0x84, 0x49, 0x2E, 0xE0, 0x39, 0xB2, 0xC8, 0x6F, 0xA8, 0x08, 0x62, 0xA6,
	0xC5, 0xEC, 0xCF, 0xF4, 0x26, 0x17, 0xCD, 0x42, 0x67, 0x07, 0x8C, 0x36, 0x10, 0xE4, 0x5B, 0x70,
	0x3F, 0xA3, 0xAD, 0xFA, 0xD1, 0x54, 0x5F, 0x46, 0x03, 0x15, 0xE0, 0x43, 0x38, 0x61, 0xF4, 0x93,
	0x79, 0xD2, 0xB6, 0xC5, 0xF5, 0xC8, 0x41, 0x4D, 0xCE, 0x08, 0x2A, 0x0A, 0xEE, 0x31, 0xC0, 0xE7,
	0x8E, 0x43, 0xCC, 0x48, 0xBF, 0xD0, 0x13, 0xE1, 0x70, 0x66, 0x29, 0xB1, 0x9E, 0x40, 0x88, 0x91,
	0xED, 0xFB, 0x6A, 0xD4, 0x0A, 0xF2, 0xA4, 0xDA, 0x5D, 0x81, 0x1F, 0xB5, 0x7A, 0xA9, 0x39, 0x96,
	0x97, 0x6D, 0x43, 0xDC, 0xBA, 0x8D, 0xD7, 0x6D, 0x67, 0x99, 0x90, 0x8F, 0x8C, 0xFA, 0x62, 0x36,
	0x4C, 0x5F, 0x5F, 0x0D, 0xF8, 0xFE, 0x75, 0x85, 0x1B, 0x2D, 0xF0, 0xA1, 0x36, 0x3E, 0x56, 0xCD,
	0x58, 0x50, 0xC0, 0x20, 0x1D, 0x76, 0xF1, 0x74, 0x34, 0x79, 0x14, 0x8F, 0xBB, 0x7D, 0x52, 0xAE,
	0xC0, 0xEE, 0x4F, 0x38, 0xF5, 0x0A, 0x06, 0x64, 0xFC, 0x76, 0xEE, 0x6B, 0x86, 0x21, 0x0A, 0xFC,
	0xF2, 0x2F, 0xF4, 0xE2, 0x7B, 0xAD, 0x47, 0xD4, 0xF5, 0x29, 0xF6, 0x46, 0x86, 0xBC, 0x77, 0x5D,
	0x00, 0xB3, 0x1F, 0x5E, 0x56, 0x88, 0xA4, 0xE8, 0x80, 0xAF, 0x79, 0xD6, 0xBF, 0x49, 0x86, 0xBC,
	0x24, 0x54, 0x2C, 0xEA, 0x01, 0x3D, 0x3E, 0xFB, 0xF4, 0x0E, 0x8C, 0x64, 0x3E, 0x0D, 0x56, 0xFB,
	0x47, 0xAA, 0xB1, 0xFD, 0x6E, 0xBF, 0x9E, 0x00
};

const size_t KProcessHacker_2_38_x64_size = 40088;
const unsigned char KProcessHacker_2_38_x64[40088] = {
	0x4D, 0x5A, 0x90, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00,
	0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00,
	0x0E, 0x1F, 0xBA, 0x0E, 0x00, 0xB4, 0x09, 0xCD, 0x21, 0xB8, 0x01, 0x4C, 0xCD, 0x21, 0x54, 0x68,
	0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 0x67, 0x72, 0x61, 0x6D, 0x20, 0x63, 0x61, 0x6E, 0x6E, 0x6F,
	0x74, 0x20, 0x62, 0x65, 0x20, 0x72, 0x75, 0x6E, 0x20, 0x69, 0x6E, 0x20, 0x44, 0x4F, 0x53, 0x20,
	0x6D, 0x6F, 0x64, 0x65, 0x2E, 0x0D, 0x0D, 0x0A, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xB2, 0xC6, 0xAF, 0xE4, 0xF6, 0xA7, 0xC1, 0xB7, 0xF6, 0xA7, 0xC1, 0xB7, 0xF6, 0xA7, 0xC1, 0xB7,
	0xF6, 0xA7, 0xC0, 0xB7, 0xB1, 0xA7, 0xC1, 0xB7, 0xFF, 0xDF, 0x52, 0xB7, 0xF5, 0xA7, 0xC1, 0xB7,
	0xFF, 0xDF, 0x54, 0xB7, 0xF5, 0xA7, 0xC1, 0xB7, 0xFF, 0xDF, 0x42, 0xB7, 0xF3, 0xA7, 0xC1, 0xB7,
	0xFF, 0xDF, 0x48, 0xB7, 0xFF, 0xA7, 0xC1, 0xB7, 0xFF, 0xDF, 0x55, 0xB7, 0xF7, 0xA7, 0xC1, 0xB7,
	0xFF, 0xDF, 0x50, 0xB7, 0xF7, 0xA7, 0xC1, 0xB7, 0x52, 0x69, 0x63, 0x68, 0xF6, 0xA7, 0xC1, 0xB7,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x50, 0x45, 0x00, 0x00, 0x64, 0x86, 0x07, 0x00, 0xE4, 0x77, 0x69, 0x55, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x22, 0x00, 0x0B, 0x02, 0x09, 0x00, 0x00, 0x5E, 0x00, 0x00,
	0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0xA0, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
	0x06, 0x00, 0x01, 0x00, 0x06, 0x00, 0x01, 0x00, 0x06, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0xC0, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0xF2, 0x6F, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x84, 0xA0, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0xB0, 0x00, 0x00, 0xF8, 0x02, 0x00, 0x00,
	0x00, 0x50, 0x00, 0x00, 0x7C, 0x02, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x98, 0x24, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x32, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2E, 0x74, 0x65, 0x78, 0x74, 0x00, 0x00, 0x00,
	0x70, 0x14, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x68,
	0x2E, 0x72, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0xD4, 0x0A, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00,
	0x00, 0x0C, 0x00, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x48, 0x2E, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00,
	0x40, 0x03, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0xC8,
	0x2E, 0x70, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x7C, 0x02, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00,
	0x00, 0x04, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x48, 0x50, 0x41, 0x47, 0x45, 0x00, 0x00, 0x00, 0x00,
	0xB2, 0x3C, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x2C, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x60,
	0x49, 0x4E, 0x49, 0x54, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x09, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00,
	0x00, 0x0A, 0x00, 0x00, 0x00, 0x6A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0xE2, 0x2E, 0x72, 0x73, 0x72, 0x63, 0x00, 0x00, 0x00,
	0xF8, 0x02, 0x00, 0x00, 0x00, 0xB0, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x74, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x42,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x74,
	0x24, 0x18, 0x57, 0x48, 0x83, 0xEC, 0x40, 0x48, 0x8B, 0x05, 0xE2, 0x30, 0x00, 0x00, 0x48, 0x33,
	0xC4, 0x48, 0x89, 0x44, 0x24, 0x38, 0x48, 0x8B, 0x82, 0xB8, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xDA,
	0x33, 0xFF, 0x48, 0x8B, 0x70, 0x08, 0xFF, 0x15, 0x0C, 0x20, 0x00, 0x00, 0x44, 0x8D, 0x5F, 0x01,
	0x44, 0x39, 0x1D, 0xE9, 0x32, 0x00, 0x00, 0x75, 0x40, 0x48, 0x8B, 0x56, 0x08, 0x44, 0x8A, 0x43,
	0x40, 0x21, 0x7C, 0x24, 0x2C, 0x21, 0x7C, 0x24, 0x30, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0x48, 0x83,
	0xC2, 0x20, 0x44, 0x89, 0x5C, 0x24, 0x20, 0x44, 0x89, 0x5C, 0x24, 0x24, 0xC7, 0x44, 0x24, 0x28,
	0x14, 0x00, 0x00, 0x00, 0xFF, 0x15, 0xDE, 0x1F, 0x00, 0x00, 0x84, 0xC0, 0x75, 0x0B, 0xBF, 0x61,
	0x00, 0x00, 0xC0, 0xFF, 0x15, 0xBF, 0x1F, 0x00, 0x00, 0x48, 0x83, 0x63, 0x38, 0x00, 0x33, 0xD2,
	0x48, 0x8B, 0xCB, 0x89, 0x7B, 0x30, 0xFF, 0x15, 0xA4, 0x1F, 0x00, 0x00, 0x8B, 0xC7, 0x48, 0x8B,
	0x4C, 0x24, 0x38, 0x48, 0x33, 0xCC, 0xE8, 0xF5, 0x0D, 0x00, 0x00, 0x48, 0x8B, 0x5C, 0x24, 0x50,
	0x48, 0x8B, 0x74, 0x24, 0x60, 0x48, 0x83, 0xC4, 0x40, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x6C, 0x24, 0x10, 0x48, 0x89,
	0x74, 0x24, 0x20, 0x57, 0x41, 0x54, 0x41, 0x55, 0x48, 0x83, 0xEC, 0x20, 0xB8, 0x00, 0x08, 0x00,
	0x00, 0x4C, 0x8B, 0xEA, 0x4C, 0x8B, 0xE1, 0xBD, 0x08, 0x00, 0x00, 0x00, 0x33, 0xFF, 0x89, 0x44,
	0x24, 0x50, 0x8B, 0xD0, 0xB9, 0x01, 0x00, 0x00, 0x00, 0x41, 0xB8, 0x4B, 0x70, 0x68, 0x54, 0xFF,
	0x15, 0xFB, 0x1E, 0x00, 0x00, 0x48, 0x8B, 0xF0, 0x48, 0x3B, 0xC7, 0x0F, 0x84, 0x99, 0x00, 0x00,
	0x00, 0x44, 0x8B, 0x44, 0x24, 0x50, 0x4C, 0x8D, 0x4C, 0x24, 0x50, 0x48, 0x8B, 0xD0, 0xB9, 0x0B,
	0x00, 0x00, 0x00, 0xFF, 0x15, 0xFF, 0x1E, 0x00, 0x00, 0x3B, 0xC7, 0x8B, 0xD8, 0x7D, 0x26, 0xBA,
	0x4B, 0x70, 0x68, 0x54, 0x48, 0x8B, 0xCE, 0xFF, 0x15, 0xCB, 0x1E, 0x00, 0x00, 0x81, 0xFB, 0x04,
	0x00, 0x00, 0xC0, 0x75, 0x0B, 0x83, 0xC5, 0xFF, 0x74, 0x65, 0x8B, 0x44, 0x24, 0x50, 0xEB, 0xA2,
	0x48, 0x8B, 0x74, 0x24, 0x50, 0x3B, 0xDF, 0x7C, 0x56, 0x8B, 0xD7, 0x39, 0x3E, 0x76, 0x2F, 0x4F,
	0x8D, 0x04, 0x2C, 0x48, 0x8D, 0x4E, 0x18, 0x4D, 0x3B, 0xC4, 0x72, 0x10, 0x4C, 0x3B, 0x21, 0x72,
	0x0B, 0x8B, 0x41, 0x08, 0x48, 0x03, 0x01, 0x4C, 0x3B, 0xC0, 0x76, 0x0F, 0xFF, 0xC2, 0x48, 0x81,
	0xC1, 0x28, 0x01, 0x00, 0x00, 0x3B, 0x16, 0x73, 0x05, 0xEB, 0xDC, 0x40, 0xB7, 0x01, 0xBA, 0x4B,
	0x70, 0x68, 0x54, 0x48, 0x8B, 0xCE, 0xFF, 0x15, 0x6C, 0x1E, 0x00, 0x00, 0x40, 0xF6, 0xDF, 0x1B,
	0xC0, 0xF7, 0xD0, 0x25, 0x05, 0x00, 0x00, 0xC0, 0xEB, 0x07, 0xBB, 0x9A, 0x00, 0x00, 0xC0, 0x8B,
	0xC3, 0x48, 0x8B, 0x5C, 0x24, 0x40, 0x48, 0x8B, 0x6C, 0x24, 0x48, 0x48, 0x8B, 0x74, 0x24, 0x58,
	0x48, 0x83, 0xC4, 0x20, 0x41, 0x5D, 0x41, 0x5C, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x74, 0x24, 0x18, 0x48, 0x89, 0x7C, 0x24, 0x20, 0x41,
	0x54, 0x41, 0x55, 0x41, 0x57, 0x48, 0x81, 0xEC, 0x00, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x05, 0x0D,
	0x2F, 0x00, 0x00, 0x48, 0x33, 0xC4, 0x48, 0x89, 0x84, 0x24, 0xF0, 0x00, 0x00, 0x00, 0x4C, 0x8B,
	0xFA, 0x48, 0x89, 0x54, 0x24, 0x40, 0x48, 0x8B, 0x82, 0xB8, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0x68,
	0x20, 0x8B, 0x70, 0x10, 0x8B, 0x78, 0x18, 0x44, 0x8A, 0x62, 0x40, 0x85, 0xF6, 0x74, 0x0F, 0x4D,
	0x85, 0xED, 0x75, 0x0A, 0xBB, 0x06, 0x02, 0x00, 0xC0, 0xE9, 0x32, 0x09, 0x00, 0x00, 0x81, 0xFE,
	0x80, 0x00, 0x00, 0x00, 0x76, 0x0A, 0xBB, 0x06, 0x02, 0x00, 0xC0, 0xE9, 0x20, 0x09, 0x00, 0x00,
	0x45, 0x84, 0xE4, 0x74, 0x31, 0x41, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xD6, 0x49, 0x8B,
	0xCD, 0xFF, 0x15, 0x11, 0x1E, 0x00, 0x00, 0x4C, 0x8B, 0xC6, 0x49, 0x8B, 0xD5, 0x48, 0x8D, 0x4C,
	0x24, 0x70, 0xE8, 0xA9, 0x0C, 0x00, 0x00, 0x90, 0xEB, 0x1C, 0x8B, 0xD8, 0x4C, 0x8B, 0x7C, 0x24,
	0x40, 0xE9, 0xEA, 0x08, 0x00, 0x00, 0x4C, 0x8B, 0xC6, 0x49, 0x8B, 0xD5, 0x48, 0x8D, 0x4C, 0x24,
	0x70, 0xE8, 0x8A, 0x0C, 0x00, 0x00, 0xB8, 0x97, 0x21, 0x99, 0x99, 0x3B, 0xF8, 0x0F, 0x87, 0x16,
	0x04, 0x00, 0x00, 0x3B, 0xF8, 0x0F, 0x84, 0xDF, 0x03, 0x00, 0x00, 0xB8, 0xDF, 0x20, 0x99, 0x99,
	0x3B, 0xF8, 0x0F, 0x87, 0x0F, 0x02, 0x00, 0x00, 0x3B, 0xF8, 0x0F, 0x84, 0xE0, 0x01, 0x00, 0x00,
	0x81, 0xFF, 0x03, 0x20, 0x99, 0x99, 0x0F, 0x84, 0xB1, 0x01, 0x00, 0x00, 0x81, 0xFF, 0xCB, 0x20,
	0x99, 0x99, 0x0F, 0x84, 0x76, 0x01, 0x00, 0x00, 0x81, 0xFF, 0xCF, 0x20, 0x99, 0x99, 0x0F, 0x84,
	0x3B, 0x01, 0x00, 0x00, 0x81, 0xFF, 0xD3, 0x20, 0x99, 0x99, 0x0F, 0x84, 0x00, 0x01, 0x00, 0x00,
	0x81, 0xFF, 0xD7, 0x20, 0x99, 0x99, 0x0F, 0x84, 0x80, 0x00, 0x00, 0x00, 0x81, 0xFF, 0xDB, 0x20,
	0x99, 0x99, 0x0F, 0x85, 0xC7, 0x06, 0x00, 0x00, 0x83, 0xFE, 0x08, 0x74, 0x0A, 0xBB, 0x04, 0x00,
	0x00, 0xC0, 0xE9, 0x59, 0x08, 0x00, 0x00, 0x48, 0x83, 0x3D, 0x39, 0x2E, 0x00, 0x00, 0x00, 0x75,
	0x0A, 0xBB, 0xBB, 0x00, 0x00, 0xC0, 0xE9, 0x45, 0x08, 0x00, 0x00, 0x48, 0x83, 0x64, 0x24, 0x28,
	0x00, 0x48, 0x8D, 0x44, 0x24, 0x68, 0x48, 0x89, 0x44, 0x24, 0x20, 0x45, 0x8A, 0xCC, 0x4C, 0x8B,
	0x05, 0x53, 0x1D, 0x00, 0x00, 0x4D, 0x8B, 0x00, 0x33, 0xD2, 0x48, 0x8B, 0x4C, 0x24, 0x70, 0xFF,
	0x15, 0x93, 0x1D, 0x00, 0x00, 0x8B, 0xD8, 0x85, 0xC0, 0x0F, 0x88, 0x11, 0x08, 0x00, 0x00, 0x48,
	0x8B, 0x4C, 0x24, 0x68, 0xFF, 0x15, 0xEE, 0x2D, 0x00, 0x00, 0x8B, 0xD8, 0x48, 0x8B, 0x4C, 0x24,
	0x68, 0xFF, 0x15, 0x99, 0x1D, 0x00, 0x00, 0xE9, 0xF4, 0x07, 0x00, 0x00, 0x83, 0xFE, 0x08, 0x74,
	0x0A, 0xBB, 0x04, 0x00, 0x00, 0xC0, 0xE9, 0xE5, 0x07, 0x00, 0x00, 0x48, 0x83, 0x3D, 0xE5, 0x2D,
	0x00, 0x00, 0x00, 0x75, 0x0A, 0xBB, 0xBB, 0x00, 0x00, 0xC0, 0xE9, 0xD1, 0x07, 0x00, 0x00, 0x48,
	0x83, 0x64, 0x24, 0x28, 0x00, 0x48, 0x8D, 0x44, 0x24, 0x60, 0x48, 0x89, 0x44, 0x24, 0x20, 0x45,
	0x8A, 0xCC, 0x4C, 0x8B, 0x05, 0xDF, 0x1C, 0x00, 0x00, 0x4D, 0x8B, 0x00, 0x33, 0xD2, 0x48, 0x8B,
	0x4C, 0x24, 0x70, 0xFF, 0x15, 0x1F, 0x1D, 0x00, 0x00, 0x8B, 0xD8, 0x85, 0xC0, 0x0F, 0x88, 0x9D,
	0x07, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x60, 0xFF, 0x15, 0x9A, 0x2D, 0x00, 0x00, 0x8B, 0xD8,
	0x48, 0x8B, 0x4C, 0x24, 0x60, 0xFF, 0x15, 0x25, 0x1D, 0x00, 0x00, 0xE9, 0x80, 0x07, 0x00, 0x00,
	0x83, 0xFE, 0x18, 0x74, 0x0A, 0xBB, 0x04, 0x00, 0x00, 0xC0, 0xE9, 0x71, 0x07, 0x00, 0x00, 0x45,
	0x8A, 0xCC, 0x4C, 0x8B, 0x84, 0x24, 0x80, 0x00, 0x00, 0x00, 0x8B, 0x54, 0x24, 0x78, 0x48, 0x8B,
	0x4C, 0x24, 0x70, 0xE8, 0x70, 0x69, 0x00, 0x00, 0x8B, 0xD8, 0xE9, 0x51, 0x07, 0x00, 0x00, 0x83,
	0xFE, 0x18, 0x74, 0x0A, 0xBB, 0x04, 0x00, 0x00, 0xC0, 0xE9, 0x42, 0x07, 0x00, 0x00, 0x45, 0x8A,
	0xCC, 0x4C, 0x8B, 0x84, 0x24, 0x80, 0x00, 0x00, 0x00, 0x8B, 0x54, 0x24, 0x78, 0x48, 0x8B, 0x4C,
	0x24, 0x70, 0xE8, 0x45, 0x68, 0x00, 0x00, 0x8B, 0xD8, 0xE9, 0x22, 0x07, 0x00, 0x00, 0x83, 0xFE,
	0x18, 0x74, 0x0A, 0xBB, 0x04, 0x00, 0x00, 0xC0, 0xE9, 0x13, 0x07, 0x00, 0x00, 0x45, 0x8A, 0xCC,
	0x4C, 0x8B, 0x84, 0x24, 0x80, 0x00, 0x00, 0x00, 0x8B, 0x54, 0x24, 0x78, 0x48, 0x8B, 0x4C, 0x24,
	0x70, 0xE8, 0xEE, 0x66, 0x00, 0x00, 0x8B, 0xD8, 0xE9, 0xF3, 0x06, 0x00, 0x00, 0x83, 0xFE, 0x08,
	0x74, 0x0A, 0xBB, 0x04, 0x00, 0x00, 0xC0, 0xE9, 0xE4, 0x06, 0x00, 0x00, 0x41, 0x8A, 0xD4, 0x48,
	0x8B, 0x4C, 0x24, 0x70, 0xE8, 0x7B, 0x4E, 0x00, 0x00, 0x8B, 0xD8, 0xE9, 0xD0, 0x06, 0x00, 0x00,
	0x83, 0xFE, 0x10, 0x74, 0x0A, 0xBB, 0x04, 0x00, 0x00, 0xC0, 0xE9, 0xC1, 0x06, 0x00, 0x00, 0x45,
	0x8A, 0xC4, 0x8B, 0x54, 0x24, 0x78, 0x48, 0x8B, 0x4C, 0x24, 0x70, 0xE8, 0xC8, 0x69, 0x00, 0x00,
	0x8B, 0xD8, 0xE9, 0xA9, 0x06, 0x00, 0x00, 0x81, 0xFF, 0xE3, 0x20, 0x99, 0x99, 0x0F, 0x84, 0x70,
	0x01, 0x00, 0x00, 0x81, 0xFF, 0xE7, 0x20, 0x99, 0x99, 0x0F, 0x84, 0x1D, 0x01, 0x00, 0x00, 0x81,
	0xFF, 0xEB, 0x20, 0x99, 0x99, 0x0F, 0x84, 0xCA, 0x00, 0x00, 0x00, 0x81, 0xFF, 0xEF, 0x20, 0x99,
	0x99, 0x74, 0x7C, 0x81, 0xFF, 0xF3, 0x20, 0x99, 0x99, 0x74, 0x3B, 0x81, 0xFF, 0x93, 0x21, 0x99,
	0x99, 0x0F, 0x85, 0xC8, 0x04, 0x00, 0x00, 0x83, 0xFE, 0x18, 0x74, 0x0A, 0xBB, 0x04, 0x00, 0x00,
	0xC0, 0xE9, 0x5A, 0x06, 0x00, 0x00, 0x45, 0x8A, 0xCC, 0x4C, 0x8B, 0x84, 0x24, 0x80, 0x00, 0x00,
	0x00, 0x8B, 0x54, 0x24, 0x78, 0x48, 0x8B, 0x4C, 0x24, 0x70, 0xE8, 0x11, 0x71, 0x00, 0x00, 0x8B,
	0xD8, 0xE9, 0x3A, 0x06, 0x00, 0x00, 0x83, 0xFE, 0x20, 0x74, 0x0A, 0xBB, 0x04, 0x00, 0x00, 0xC0,
	0xE9, 0x2B, 0x06, 0x00, 0x00, 0x44, 0x88, 0x64, 0x24, 0x20, 0x44, 0x8B, 0x8C, 0x24, 0x88, 0x00,
	0x00, 0x00, 0x4C, 0x8B, 0x84, 0x24, 0x80, 0x00, 0x00, 0x00, 0x8B, 0x54, 0x24, 0x78, 0x48, 0x8B,
	0x4C, 0x24, 0x70, 0xE8, 0xC4, 0x6C, 0x00, 0x00, 0x8B, 0xD8, 0xE9, 0x01, 0x06, 0x00, 0x00, 0x83,
	0xFE, 0x28, 0x74, 0x0A, 0xBB, 0x04, 0x00, 0x00, 0xC0, 0xE9, 0xF2, 0x05, 0x00, 0x00, 0x44, 0x88,
	0x64, 0x24, 0x28, 0x48, 0x8B, 0x84, 0x24, 0x90, 0x00, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x20,
	0x44, 0x8B, 0x8C, 0x24, 0x88, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0x84, 0x24, 0x80, 0x00, 0x00, 0x00,
	0x8B, 0x54, 0x24, 0x78, 0x48, 0x8B, 0x4C, 0x24, 0x70, 0xE8, 0xDE, 0x69, 0x00, 0x00, 0x8B, 0xD8,
	0xE9, 0xBB, 0x05, 0x00, 0x00, 0x83, 0xFE, 0x28, 0x74, 0x0A, 0xBB, 0x04, 0x00, 0x00, 0xC0, 0xE9,
	0xAC, 0x05, 0x00, 0x00, 0x44, 0x88, 0x64, 0x24, 0x28, 0x48, 0x8B, 0x84, 0x24, 0x90, 0x00, 0x00,
	0x00, 0x48, 0x89, 0x44, 0x24, 0x20, 0x4C, 0x8B, 0x8C, 0x24, 0x88, 0x00, 0x00, 0x00, 0x4C, 0x8B,
	0x84, 0x24, 0x80, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x54, 0x24, 0x78, 0x48, 0x8B, 0x4C, 0x24, 0x70,
	0xE8, 0x6B, 0x82, 0x00, 0x00, 0x8B, 0xD8, 0xE9, 0x74, 0x05, 0x00, 0x00, 0x83, 0xFE, 0x28, 0x74,
	0x0A, 0xBB, 0x04, 0x00, 0x00, 0xC0, 0xE9, 0x65, 0x05, 0x00, 0x00, 0x44, 0x88, 0x64, 0x24, 0x28,
	0x48, 0x8B, 0x84, 0x24, 0x90, 0x00, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x20, 0x4C, 0x8B, 0x8C,
	0x24, 0x88, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0x84, 0x24, 0x80, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x54,
	0x24, 0x78, 0x48, 0x8B, 0x4C, 0x24, 0x70, 0xE8, 0xC0, 0x80, 0x00, 0x00, 0x8B, 0xD8, 0xE9, 0x2D,
	0x05, 0x00, 0x00, 0x83, 0xFE, 0x28, 0x74, 0x0A, 0xBB, 0x04, 0x00, 0x00, 0xC0, 0xE9, 0x1E, 0x05,
	0x00, 0x00, 0x44, 0x88, 0x64, 0x24, 0x28, 0x48, 0x8B, 0x84, 0x24, 0x90, 0x00, 0x00, 0x00, 0x48,
	0x89, 0x44, 0x24, 0x20, 0x4C, 0x8B, 0x8C, 0x24, 0x88, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0x84, 0x24,
	0x80, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x54, 0x24, 0x78, 0x48, 0x8B, 0x4C, 0x24, 0x70, 0xE8, 0x15,
	0x7F, 0x00, 0x00, 0x8B, 0xD8, 0xE9, 0xE6, 0x04, 0x00, 0x00, 0x83, 0xFE, 0x18, 0x74, 0x0A, 0xBB,
	0x04, 0x00, 0x00, 0xC0, 0xE9, 0xD7, 0x04, 0x00, 0x00, 0x45, 0x8A, 0xCC, 0x4C, 0x8B, 0x84, 0x24,
	0x80, 0x00, 0x00, 0x00, 0x8B, 0x54, 0x24, 0x78, 0x48, 0x8B, 0x4C, 0x24, 0x70, 0xE8, 0x9E, 0x70,
	0x00, 0x00, 0x8B, 0xD8, 0xE9, 0xB7, 0x04, 0x00, 0x00, 0xB8, 0xB3, 0x21, 0x99, 0x99, 0x3B, 0xF8,
	0x0F, 0x87, 0xC9, 0x02, 0x00, 0x00, 0x3B, 0xF8, 0x0F, 0x84, 0x88, 0x02, 0x00, 0x00, 0x81, 0xFF,
	0x9B, 0x21, 0x99, 0x99, 0x0F, 0x84, 0x04, 0x02, 0x00, 0x00, 0x81, 0xFF, 0x9F, 0x21, 0x99, 0x99,
	0x0F, 0x84, 0xD1, 0x01, 0x00, 0x00, 0x81, 0xFF, 0xA3, 0x21, 0x99, 0x99, 0x0F, 0x84, 0x5D, 0x01,
	0x00, 0x00, 0x81, 0xFF, 0xA7, 0x21, 0x99, 0x99, 0x0F, 0x84, 0xE9, 0x00, 0x00, 0x00, 0x81, 0xFF,
	0xAB, 0x21, 0x99, 0x99, 0x74, 0x52, 0x81, 0xFF, 0xAF, 0x21, 0x99, 0x99, 0x0F, 0x85, 0xBD, 0x02,
	0x00, 0x00, 0x83, 0xFE, 0x28, 0x74, 0x0A, 0xBB, 0x04, 0x00, 0x00, 0xC0, 0xE9, 0x4F, 0x04, 0x00,
	0x00, 0x44, 0x88, 0x64, 0x24, 0x28, 0x48, 0x8B, 0x84, 0x24, 0x90, 0x00, 0x00, 0x00, 0x48, 0x89,
	0x44, 0x24, 0x20, 0x44, 0x8B, 0x8C, 0x24, 0x88, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0x84, 0x24, 0x80,
	0x00, 0x00, 0x00, 0x8B, 0x54, 0x24, 0x78, 0x48, 0x8B, 0x4C, 0x24, 0x70, 0xE8, 0xDF, 0x75, 0x00,
	0x00, 0x8B, 0xD8, 0xE9, 0x18, 0x04, 0x00, 0x00, 0x83, 0xFE, 0x28, 0x74, 0x0A, 0xBB, 0x04, 0x00,
	0x00, 0xC0, 0xE9, 0x09, 0x04, 0x00, 0x00, 0x48, 0x83, 0x64, 0x24, 0x28, 0x00, 0x48, 0x8D, 0x44,
	0x24, 0x58, 0x48, 0x89, 0x44, 0x24, 0x20, 0x45, 0x8A, 0xCC, 0x4C, 0x8B, 0x05, 0x5F, 0x1A, 0x00,
	0x00, 0x4D, 0x8B, 0x00, 0x33, 0xD2, 0x48, 0x8B, 0x4C, 0x24, 0x70, 0xFF, 0x15, 0x57, 0x19, 0x00,
	0x00, 0x8B, 0xD8, 0x85, 0xC0, 0x0F, 0x88, 0xD5, 0x03, 0x00, 0x00, 0x44, 0x88, 0x64, 0x24, 0x30,
	0x48, 0x8B, 0x84, 0x24, 0x90, 0x00, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x28, 0x48, 0x8B, 0x84,
	0x24, 0x88, 0x00, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x20, 0x4C, 0x8B, 0x8C, 0x24, 0x80, 0x00,
	0x00, 0x00, 0x44, 0x8B, 0x44, 0x24, 0x7C, 0x8B, 0x54, 0x24, 0x78, 0x48, 0x8B, 0x4C, 0x24, 0x58,
	0xE8, 0x37, 0x72, 0x00, 0x00, 0x8B, 0xD8, 0x48, 0x8B, 0x4C, 0x24, 0x58, 0xFF, 0x15, 0x2E, 0x19,
	0x00, 0x00, 0xE9, 0x89, 0x03, 0x00, 0x00, 0x83, 0xFE, 0x10, 0x74, 0x0A, 0xBB, 0x04, 0x00, 0x00,
	0xC0, 0xE9, 0x7A, 0x03, 0x00, 0x00, 0x48, 0x83, 0x64, 0x24, 0x28, 0x00, 0x48, 0x8D, 0x44, 0x24,
	0x48, 0x48, 0x89, 0x44, 0x24, 0x20, 0x45, 0x8A, 0xCC, 0x4C, 0x8B, 0x05, 0xD0, 0x19, 0x00, 0x00,
	0x4D, 0x8B, 0x00, 0x33, 0xD2, 0x48, 0x8B, 0x4C, 0x24, 0x70, 0xFF, 0x15, 0xC8, 0x18, 0x00, 0x00,
	0x8B, 0xD8, 0x85, 0xC0, 0x0F, 0x88, 0x46, 0x03, 0x00, 0x00, 0x45, 0x8A, 0xC4, 0x48, 0x8B, 0x54,
	0x24, 0x78, 0x48, 0x8B, 0x4C, 0x24, 0x48, 0xFF, 0x15, 0x83, 0x19, 0x00, 0x00, 0x8B, 0xD8, 0x48,
	0x8B, 0x4C, 0x24, 0x48, 0xFF, 0x15, 0xC6, 0x18, 0x00, 0x00, 0xE9, 0x21, 0x03, 0x00, 0x00, 0x83,
	0xFE, 0x10, 0x74, 0x0A, 0xBB, 0x04, 0x00, 0x00, 0xC0, 0xE9, 0x12, 0x03, 0x00, 0x00, 0x48, 0x83,
	0x64, 0x24, 0x28, 0x00, 0x48, 0x8D, 0x44, 0x24, 0x50, 0x48, 0x89, 0x44, 0x24, 0x20, 0x45, 0x8A,
	0xCC, 0x4C, 0x8B, 0x05, 0x68, 0x19, 0x00, 0x00, 0x4D, 0x8B, 0x00, 0x33, 0xD2, 0x48, 0x8B, 0x4C,
	0x24, 0x70, 0xFF, 0x15, 0x60, 0x18, 0x00, 0x00, 0x8B, 0xD8, 0x85, 0xC0, 0x0F, 0x88, 0xDE, 0x02,
	0x00, 0x00, 0x45, 0x8A, 0xC4, 0x48, 0x8B, 0x54, 0x24, 0x78, 0x48, 0x8B, 0x4C, 0x24, 0x50, 0xFF,
	0x15, 0x4B, 0x19, 0x00, 0x00, 0x8B, 0xD8, 0x48, 0x8B, 0x4C, 0x24, 0x50, 0xFF, 0x15, 0x5E, 0x18,
	0x00, 0x00, 0xE9, 0xB9, 0x02, 0x00, 0x00, 0x83, 0xFE, 0x10, 0x74, 0x0A, 0xBB, 0x04, 0x00, 0x00,
	0xC0, 0xE9, 0xAA, 0x02, 0x00, 0x00, 0x45, 0x8A, 0xC4, 0x8B, 0x54, 0x24, 0x78, 0x48, 0x8B, 0x4C,
	0x24, 0x70, 0xE8, 0xF5, 0x6F, 0x00, 0x00, 0x8B, 0xD8, 0xE9, 0x92, 0x02, 0x00, 0x00, 0x83, 0xFE,
	0x10, 0x74, 0x0A, 0xBB, 0x04, 0x00, 0x00, 0xC0, 0xE9, 0x83, 0x02, 0x00, 0x00, 0x48, 0x83, 0x64,
	0x24, 0x28, 0x00, 0x48, 0x8D, 0x44, 0x24, 0x40, 0x48, 0x89, 0x44, 0x24, 0x20, 0x45, 0x8A, 0xCC,
	0x4C, 0x8B, 0x05, 0xD9, 0x18, 0x00, 0x00, 0x4D, 0x8B, 0x00, 0x33, 0xD2, 0x48, 0x8B, 0x4C, 0x24,
	0x70, 0xFF, 0x15, 0xD1, 0x17, 0x00, 0x00, 0x8B, 0xD8, 0x85, 0xC0, 0x0F, 0x88, 0x4F, 0x02, 0x00,
	0x00, 0x65, 0x48, 0x8B, 0x04, 0x25, 0x88, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x40, 0x48,
	0x3B, 0xC8, 0x74, 0x12, 0x8B, 0x54, 0x24, 0x78, 0xE8, 0x03, 0x6F, 0x00, 0x00, 0x8B, 0xD8, 0x48,
	0x8B, 0x4C, 0x24, 0x40, 0xEB, 0x05, 0xBB, 0xDB, 0x00, 0x00, 0xC0, 0xFF, 0x15, 0xBF, 0x17, 0x00,
	0x00, 0xE9, 0x1A, 0x02, 0x00, 0x00, 0x83, 0xFE, 0x20, 0x74, 0x0A, 0xBB, 0x04, 0x00, 0x00, 0xC0,
	0xE9, 0x0B, 0x02, 0x00, 0x00, 0x44, 0x88, 0x64, 0x24, 0x20, 0x44, 0x8B, 0x8C, 0x24, 0x88, 0x00,
	0x00, 0x00, 0x4C, 0x8B, 0x84, 0x24, 0x80, 0x00, 0x00, 0x00, 0x8B, 0x54, 0x24, 0x78, 0x48, 0x8B,
	0x4C, 0x24, 0x70, 0xE8, 0xAC, 0x75, 0x00, 0x00, 0x8B, 0xD8, 0xE9, 0xE1, 0x01, 0x00, 0x00, 0x81,
	0xFF, 0x5B, 0x22, 0x99, 0x99, 0x0F, 0x84, 0xA3, 0x01, 0x00, 0x00, 0x81, 0xFF, 0x5F, 0x22, 0x99,
	0x99, 0x0F, 0x84, 0x4B, 0x01, 0x00, 0x00, 0x81, 0xFF, 0x63, 0x22, 0x99, 0x99, 0x0F, 0x84, 0xFD,
	0x00, 0x00, 0x00, 0x81, 0xFF, 0x67, 0x22, 0x99, 0x99, 0x0F, 0x84, 0x96, 0x00, 0x00, 0x00, 0x81,
	0xFF, 0x23, 0x23, 0x99, 0x99, 0x74, 0x58, 0x81, 0xFF, 0x27, 0x23, 0x99, 0x99, 0x74, 0x0A, 0xBB,
	0x10, 0x00, 0x00, 0xC0, 0xE9, 0x97, 0x01, 0x00, 0x00, 0x83, 0xFE, 0x28, 0x74, 0x0A, 0xBB, 0x04,
	0x00, 0x00, 0xC0, 0xE9, 0x88, 0x01, 0x00, 0x00, 0x44, 0x88, 0x64, 0x24, 0x28, 0x48, 0x8B, 0x84,
	0x24, 0x90, 0x00, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x20, 0x44, 0x8B, 0x8C, 0x24, 0x88, 0x00,
	0x00, 0x00, 0x4C, 0x8B, 0x84, 0x24, 0x80, 0x00, 0x00, 0x00, 0x8B, 0x54, 0x24, 0x78, 0x48, 0x8B,
	0x4C, 0x24, 0x70, 0xE8, 0xE0, 0x69, 0x00, 0x00, 0x8B, 0xD8, 0xE9, 0x51, 0x01, 0x00, 0x00, 0x83,
	0xFE, 0x10, 0x74, 0x0A, 0xBB, 0x04, 0x00, 0x00, 0xC0, 0xE9, 0x42, 0x01, 0x00, 0x00, 0x44, 0x88,
	0x64, 0x24, 0x20, 0x4C, 0x8B, 0x0D, 0x9E, 0x16, 0x00, 0x00, 0x4D, 0x8B, 0x09, 0x4C, 0x8B, 0x44,
	0x24, 0x78, 0x33, 0xD2, 0x48, 0x8B, 0x4C, 0x24, 0x70, 0xE8, 0x92, 0x5F, 0x00, 0x00, 0x8B, 0xD8,
	0xE9, 0x1B, 0x01, 0x00, 0x00, 0x83, 0xFE, 0x30, 0x74, 0x0A, 0xBB, 0x04, 0x00, 0x00, 0xC0, 0xE9,
	0x0C, 0x01, 0x00, 0x00, 0x44, 0x88, 0x64, 0x24, 0x38, 0x8B, 0x84, 0x24, 0x98, 0x00, 0x00, 0x00,
	0x89, 0x44, 0x24, 0x30, 0x8B, 0x84, 0x24, 0x94, 0x00, 0x00, 0x00, 0x89, 0x44, 0x24, 0x28, 0x8B,
	0x84, 0x24, 0x90, 0x00, 0x00, 0x00, 0x89, 0x44, 0x24, 0x20, 0x4C, 0x8B, 0x8C, 0x24, 0x88, 0x00,
	0x00, 0x00, 0x4C, 0x8B, 0x84, 0x24, 0x80, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x54, 0x24, 0x78, 0x48,
	0x8B, 0x4C, 0x24, 0x70, 0xE8, 0xCB, 0x5D, 0x00, 0x00, 0x8B, 0xD8, 0xE9, 0xC0, 0x00, 0x00, 0x00,
	0x83, 0xFE, 0x28, 0x74, 0x0A, 0xBB, 0x04, 0x00, 0x00, 0xC0, 0xE9, 0xB1, 0x00, 0x00, 0x00, 0x44,
	0x88, 0x64, 0x24, 0x28, 0x8B, 0x84, 0x24, 0x90, 0x00, 0x00, 0x00, 0x89, 0x44, 0x24, 0x20, 0x4C,
	0x8B, 0x8C, 0x24, 0x88, 0x00, 0x00, 0x00, 0x44, 0x8B, 0x84, 0x24, 0x80, 0x00, 0x00, 0x00, 0x48,
	0x8B, 0x54, 0x24, 0x78, 0x48, 0x8B, 0x4C, 0x24, 0x70, 0xE8, 0x5A, 0x5A, 0x00, 0x00, 0x8B, 0xD8,
	0xEB, 0x7E, 0x83, 0xFE, 0x30, 0x74, 0x07, 0xBB, 0x04, 0x00, 0x00, 0xC0, 0xEB, 0x72, 0x44, 0x88,
	0x64, 0x24, 0x30, 0x48, 0x8B, 0x84, 0x24, 0x98, 0x00, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x28,
	0x8B, 0x84, 0x24, 0x90, 0x00, 0x00, 0x00, 0x89, 0x44, 0x24, 0x20, 0x4C, 0x8B, 0x8C, 0x24, 0x88,
	0x00, 0x00, 0x00, 0x44, 0x8B, 0x84, 0x24, 0x80, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x54, 0x24, 0x78,
	0x48, 0x8B, 0x4C, 0x24, 0x70, 0xE8, 0xEE, 0x50, 0x00, 0x00, 0x8B, 0xD8, 0xEB, 0x32, 0x83, 0xFE,
	0x20, 0x74, 0x07, 0xBB, 0x04, 0x00, 0x00, 0xC0, 0xEB, 0x26, 0x44, 0x88, 0x64, 0x24, 0x20, 0x4C,
	0x8B, 0x8C, 0x24, 0x88, 0x00, 0x00, 0x00, 0x44, 0x8B, 0x84, 0x24, 0x80, 0x00, 0x00, 0x00, 0x48,
	0x8B, 0x54, 0x24, 0x78, 0x48, 0x8B, 0x4C, 0x24, 0x70, 0xE8, 0xBE, 0x4D, 0x00, 0x00, 0x8B, 0xD8,
	0x41, 0x89, 0x5F, 0x30, 0x49, 0x83, 0x67, 0x38, 0x00, 0x33, 0xD2, 0x49, 0x8B, 0xCF, 0xFF, 0x15,
	0xCC, 0x14, 0x00, 0x00, 0x8B, 0xC3, 0x48, 0x8B, 0x8C, 0x24, 0xF0, 0x00, 0x00, 0x00, 0x48, 0x33,
	0xCC, 0xE8, 0x1A, 0x03, 0x00, 0x00, 0x4C, 0x8D, 0x9C, 0x24, 0x00, 0x01, 0x00, 0x00, 0x49, 0x8B,
	0x5B, 0x20, 0x49, 0x8B, 0x73, 0x30, 0x49, 0x8B, 0x7B, 0x38, 0x49, 0x8B, 0xE3, 0x41, 0x5F, 0x41,
	0x5D, 0x41, 0x5C, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x8B, 0xC4, 0x48,
	0x89, 0x58, 0x08, 0x48, 0x89, 0x68, 0x10, 0x48, 0x89, 0x70, 0x18, 0x48, 0x89, 0x78, 0x20, 0x41,
	0x54, 0x48, 0x83, 0xEC, 0x20, 0x33, 0xFF, 0x48, 0x8B, 0xD9, 0x40, 0x38, 0x39, 0x75, 0x04, 0x33,
	0xC0, 0xEB, 0x5E, 0x40, 0x38, 0x79, 0x01, 0x75, 0x54, 0x8B, 0x51, 0x20, 0x4C, 0x8B, 0x61, 0x08,
	0x8B, 0x69, 0x10, 0x48, 0x8B, 0x49, 0x18, 0x48, 0x8D, 0x34, 0x11, 0xE8, 0xD4, 0xF4, 0xFF, 0xFF,
	0x3B, 0xC7, 0x7C, 0x31, 0x48, 0x8B, 0x7B, 0x18, 0xEB, 0x17, 0x4C, 0x8B, 0xC5, 0x49, 0x8B, 0xD4,
	0x48, 0x8B, 0xCF, 0xFF, 0x15, 0x6F, 0x14, 0x00, 0x00, 0x48, 0x3B, 0xC5, 0x74, 0x0A, 0x48, 0xFF,
	0xC7, 0x48, 0x3B, 0xFE, 0x72, 0xE4, 0xEB, 0x11, 0x48, 0x63, 0x43, 0x24, 0x48, 0x03, 0xC7, 0x48,
	0x89, 0x43, 0x28, 0xEB, 0x04, 0x48, 0x89, 0x7B, 0x28, 0xC6, 0x43, 0x01, 0x01, 0x48, 0x8B, 0x43,
	0x28, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x8B, 0x6C, 0x24, 0x38, 0x48, 0x8B, 0x74, 0x24, 0x40,
	0x48, 0x8B, 0x7C, 0x24, 0x48, 0x48, 0x83, 0xC4, 0x20, 0x41, 0x5C, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x8B, 0xC4, 0x48, 0x89, 0x58, 0x08, 0x48, 0x89, 0x70, 0x10, 0x48,
	0x89, 0x78, 0x18, 0x4C, 0x89, 0x60, 0x20, 0x41, 0x55, 0x48, 0x83, 0xEC, 0x40, 0x48, 0x8B, 0xFA,
	0x48, 0x8B, 0xD9, 0xBA, 0x10, 0x00, 0x00, 0x00, 0x44, 0x8D, 0x42, 0xF4, 0xFF, 0x15, 0xE6, 0x13,
	0x00, 0x00, 0x0F, 0xB7, 0x33, 0x66, 0x89, 0x74, 0x24, 0x28, 0x66, 0x89, 0x74, 0x24, 0x2A, 0x45,
	0x33, 0xED, 0x4C, 0x89, 0x6C, 0x24, 0x30, 0x4C, 0x8B, 0x63, 0x08, 0x4C, 0x89, 0x64, 0x24, 0x20,
	0x48, 0x8B, 0xDE, 0x45, 0x8D, 0x45, 0x02, 0x48, 0x8B, 0xD6, 0x49, 0x8B, 0xCC, 0xFF, 0x15, 0xB5,
	0x13, 0x00, 0x00, 0x90, 0xB9, 0x01, 0x00, 0x00, 0x00, 0x84, 0x4C, 0x24, 0x28, 0x74, 0x07, 0xB8,
	0x0D, 0x00, 0x00, 0xC0, 0xEB, 0x5A, 0x66, 0x41, 0x3B, 0xF5, 0x74, 0x46, 0x41, 0xB8, 0x4B, 0x70,
	0x68, 0x55, 0x48, 0x8B, 0xD3, 0xFF, 0x15, 0x25, 0x13, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x30,
	0x49, 0x3B, 0xC5, 0x75, 0x07, 0xB8, 0x9A, 0x00, 0x00, 0xC0, 0xEB, 0x34, 0x4C, 0x8B, 0xC3, 0x49,
	0x8B, 0xD4, 0x48, 0x8B, 0xC8, 0xE8, 0x16, 0x02, 0x00, 0x00, 0xEB, 0x16, 0x8B, 0xD8, 0xBA, 0x4B,
	0x70, 0x68, 0x55, 0x48, 0x8B, 0x4C, 0x24, 0x30, 0xFF, 0x15, 0xFA, 0x12, 0x00, 0x00, 0x8B, 0xC3,
	0xEB, 0x0E, 0xF3, 0x0F, 0x6F, 0x44, 0x24, 0x28, 0xF3, 0x0F, 0x7F, 0x07, 0x33, 0xC0, 0xEB, 0x00,
	0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x8B, 0x74, 0x24, 0x58, 0x48, 0x8B, 0x7C, 0x24, 0x60, 0x4C,
	0x8B, 0x64, 0x24, 0x68, 0x48, 0x83, 0xC4, 0x40, 0x41, 0x5D, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0x40, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8B, 0x05, 0xEF, 0x23, 0x00,
	0x00, 0x33, 0xDB, 0x48, 0x3B, 0xC3, 0x74, 0x12, 0x48, 0x39, 0x1D, 0x11, 0x24, 0x00, 0x00, 0x74,
	0x09, 0xFF, 0xD0, 0x3B, 0xC3, 0x0F, 0x9D, 0xC0, 0xEB, 0x18, 0x8B, 0x05, 0xA8, 0x23, 0x00, 0x00,
	0x83, 0xF8, 0xFF, 0x75, 0x04, 0x32, 0xC0, 0xEB, 0x09, 0x48, 0x03, 0xC8, 0xFF, 0x15, 0xA6, 0x13,
	0x00, 0x00, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0x48, 0x83, 0xEC, 0x28, 0x48, 0x8B, 0x05, 0xD5, 0x23, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x74, 0x04,
	0xFF, 0xD0, 0xEB, 0x14, 0x8B, 0x05, 0x6E, 0x23, 0x00, 0x00, 0x83, 0xF8, 0xFF, 0x74, 0x09, 0x48,
	0x03, 0xC8, 0xFF, 0x15, 0x98, 0x13, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x74, 0x24, 0x10, 0x57, 0x48,
	0x81, 0xEC, 0x20, 0x02, 0x00, 0x00, 0x8D, 0x59, 0x01, 0x8B, 0xFA, 0x49, 0x8B, 0xF1, 0x03, 0xD3,
	0x83, 0xFA, 0x40, 0x76, 0x04, 0x33, 0xC0, 0xEB, 0x57, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0x45, 0x33,
	0xC0, 0xFF, 0x15, 0x91, 0x13, 0x00, 0x00, 0x44, 0x8B, 0xD8, 0x3B, 0xC3, 0x76, 0xE7, 0x33, 0xD2,
	0x45, 0x33, 0xC0, 0x48, 0x63, 0xC3, 0x85, 0xFF, 0x74, 0x24, 0x48, 0x8D, 0x4C, 0xC4, 0x20, 0x8D,
	0x04, 0x1A, 0x41, 0x3B, 0xC3, 0x73, 0x17, 0x48, 0x8B, 0x01, 0xFF, 0xC2, 0x48, 0x83, 0xC1, 0x08,
	0x48, 0x89, 0x06, 0x48, 0x83, 0xC6, 0x08, 0x44, 0x03, 0xC0, 0x3B, 0xD7, 0x72, 0xE1, 0x48, 0x8B,
	0x8C, 0x24, 0x50, 0x02, 0x00, 0x00, 0x48, 0x85, 0xC9, 0x74, 0x03, 0x44, 0x89, 0x01, 0x8B, 0xC2,
	0x4C, 0x8D, 0x9C, 0x24, 0x20, 0x02, 0x00, 0x00, 0x49, 0x8B, 0x5B, 0x10, 0x49, 0x8B, 0x73, 0x18,
	0x49, 0x8B, 0xE3, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC6, 0x02, 0x00, 0x48,
	0x8B, 0x09, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x81, 0x39, 0x05, 0x00, 0x00, 0xC0, 0x74, 0x10, 0x81,
	0x39, 0x01, 0x00, 0x00, 0x80, 0x74, 0x08, 0x81, 0x39, 0x06, 0x00, 0x00, 0xC0, 0x75, 0x0E, 0x39,
	0x41, 0x18, 0x76, 0x09, 0x88, 0x02, 0x48, 0x8B, 0x49, 0x28, 0x49, 0x89, 0x08, 0xC3, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x66, 0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x48, 0x3B, 0x0D, 0x59, 0x22, 0x00, 0x00, 0x75, 0x12, 0x48, 0xC1, 0xC1, 0x10, 0x66, 0xF7, 0xC1,
	0xFF, 0xFF, 0x75, 0x03, 0xC2, 0x00, 0x00, 0x48, 0xC1, 0xC9, 0x10, 0xE9, 0x08, 0x00, 0x00, 0x00,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x38, 0x4C, 0x8B, 0x0D, 0x35,
	0x22, 0x00, 0x00, 0x4C, 0x8B, 0x05, 0x26, 0x22, 0x00, 0x00, 0x48, 0x83, 0x64, 0x24, 0x20, 0x00,
	0x48, 0x8B, 0xD1, 0xB9, 0xF7, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x3A, 0x13, 0x00, 0x00, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xFF, 0x25, 0x34, 0x13, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x66, 0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x4C, 0x8B, 0xD9, 0x48, 0x2B, 0xD1, 0x0F, 0x82, 0x9E, 0x01, 0x00, 0x00, 0x49, 0x83, 0xF8, 0x08,
	0x72, 0x62, 0xF6, 0xC1, 0x07, 0x74, 0x37, 0xF6, 0xC1, 0x01, 0x74, 0x0C, 0x8A, 0x04, 0x0A, 0x49,
	0xFF, 0xC8, 0x88, 0x01, 0x48, 0x83, 0xC1, 0x01, 0xF6, 0xC1, 0x02, 0x74, 0x0F, 0x66, 0x8B, 0x04,
	0x0A, 0x49, 0x83, 0xE8, 0x02, 0x66, 0x89, 0x01, 0x48, 0x83, 0xC1, 0x02, 0xF6, 0xC1, 0x04, 0x74,
	0x0D, 0x8B, 0x04, 0x0A, 0x49, 0x83, 0xE8, 0x04, 0x89, 0x01, 0x48, 0x83, 0xC1, 0x04, 0x4D, 0x8B,
	0xC8, 0x49, 0xC1, 0xE9, 0x05, 0x75, 0x50, 0x4D, 0x8B, 0xC8, 0x49, 0xC1, 0xE9, 0x03, 0x74, 0x14,
	0x48, 0x8B, 0x04, 0x0A, 0x48, 0x89, 0x01, 0x48, 0x83, 0xC1, 0x08, 0x49, 0xFF, 0xC9, 0x75, 0xF0,
	0x49, 0x83, 0xE0, 0x07, 0x4D, 0x85, 0xC0, 0x75, 0x07, 0x49, 0x8B, 0xC3, 0xC3, 0x0F, 0x1F, 0x00,
	0x8A, 0x04, 0x0A, 0x88, 0x01, 0x48, 0xFF, 0xC1, 0x49, 0xFF, 0xC8, 0x75, 0xF3, 0x49, 0x8B, 0xC3,
	0xC3, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90, 0x49, 0x81, 0xF9, 0x00, 0x20, 0x00, 0x00, 0x73, 0x42,
	0x48, 0x8B, 0x04, 0x0A, 0x4C, 0x8B, 0x54, 0x0A, 0x08, 0x48, 0x83, 0xC1, 0x20, 0x48, 0x89, 0x41,
	0xE0, 0x4C, 0x89, 0x51, 0xE8, 0x48, 0x8B, 0x44, 0x0A, 0xF0, 0x4C, 0x8B, 0x54, 0x0A, 0xF8, 0x49,
	0xFF, 0xC9, 0x48, 0x89, 0x41, 0xF0, 0x4C, 0x89, 0x51, 0xF8, 0x75, 0xD4, 0x49, 0x83, 0xE0, 0x1F,
	0xE9, 0x72, 0xFF, 0xFF, 0xFF, 0x66, 0x66, 0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x66, 0x90, 0x48, 0x81, 0xFA, 0x00, 0x10, 0x00, 0x00, 0x72, 0xB5, 0xB8, 0x20, 0x00, 0x00, 0x00,
	0x0F, 0x18, 0x04, 0x0A, 0x0F, 0x18, 0x44, 0x0A, 0x40, 0x48, 0x81, 0xC1, 0x80, 0x00, 0x00, 0x00,
	0xFF, 0xC8, 0x75, 0xEC, 0x48, 0x81, 0xE9, 0x00, 0x10, 0x00, 0x00, 0xB8, 0x40, 0x00, 0x00, 0x00,
	0x4C, 0x8B, 0x0C, 0x0A, 0x4C, 0x8B, 0x54, 0x0A, 0x08, 0x4C, 0x0F, 0xC3, 0x09, 0x4C, 0x0F, 0xC3,
	0x51, 0x08, 0x4C, 0x8B, 0x4C, 0x0A, 0x10, 0x4C, 0x8B, 0x54, 0x0A, 0x18, 0x4C, 0x0F, 0xC3, 0x49,
	0x10, 0x4C, 0x0F, 0xC3, 0x51, 0x18, 0x4C, 0x8B, 0x4C, 0x0A, 0x20, 0x4C, 0x8B, 0x54, 0x0A, 0x28,
	0x48, 0x83, 0xC1, 0x40, 0x4C, 0x0F, 0xC3, 0x49, 0xE0, 0x4C, 0x0F, 0xC3, 0x51, 0xE8, 0x4C, 0x8B,
	0x4C, 0x0A, 0xF0, 0x4C, 0x8B, 0x54, 0x0A, 0xF8, 0xFF, 0xC8, 0x4C, 0x0F, 0xC3, 0x49, 0xF0, 0x4C,
	0x0F, 0xC3, 0x51, 0xF8, 0x75, 0xAA, 0x49, 0x81, 0xE8, 0x00, 0x10, 0x00, 0x00, 0x49, 0x81, 0xF8,
	0x00, 0x10, 0x00, 0x00, 0x0F, 0x83, 0x71, 0xFF, 0xFF, 0xFF, 0xF0, 0x80, 0x0C, 0x24, 0x00, 0xE9,
	0xBA, 0xFE, 0xFF, 0xFF, 0x66, 0x66, 0x66, 0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x90, 0x49, 0x03, 0xC8, 0x49, 0x83, 0xF8,
	0x08, 0x72, 0x61, 0xF6, 0xC1, 0x07, 0x74, 0x36, 0xF6, 0xC1, 0x01, 0x74, 0x0B, 0x48, 0xFF, 0xC9,
	0x8A, 0x04, 0x0A, 0x49, 0xFF, 0xC8, 0x88, 0x01, 0xF6, 0xC1, 0x02, 0x74, 0x0F, 0x48, 0x83, 0xE9,
	0x02, 0x66, 0x8B, 0x04, 0x0A, 0x49, 0x83, 0xE8, 0x02, 0x66, 0x89, 0x01, 0xF6, 0xC1, 0x04, 0x74,
	0x0D, 0x48, 0x83, 0xE9, 0x04, 0x8B, 0x04, 0x0A, 0x49, 0x83, 0xE8, 0x04, 0x89, 0x01, 0x4D, 0x8B,
	0xC8, 0x49, 0xC1, 0xE9, 0x05, 0x75, 0x50, 0x4D, 0x8B, 0xC8, 0x49, 0xC1, 0xE9, 0x03, 0x74, 0x14,
	0x48, 0x83, 0xE9, 0x08, 0x48, 0x8B, 0x04, 0x0A, 0x49, 0xFF, 0xC9, 0x48, 0x89, 0x01, 0x75, 0xF0,
	0x49, 0x83, 0xE0, 0x07, 0x4D, 0x85, 0xC0, 0x75, 0x07, 0x49, 0x8B, 0xC3, 0xC3, 0x0F, 0x1F, 0x00,
	0x48, 0xFF, 0xC9, 0x8A, 0x04, 0x0A, 0x49, 0xFF, 0xC8, 0x88, 0x01, 0x75, 0xF3, 0x49, 0x8B, 0xC3,
	0xC3, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90, 0x49, 0x81, 0xF9, 0x00, 0x20, 0x00, 0x00, 0x73, 0x42,
	0x48, 0x8B, 0x44, 0x0A, 0xF8, 0x4C, 0x8B, 0x54, 0x0A, 0xF0, 0x48, 0x83, 0xE9, 0x20, 0x48, 0x89,
	0x41, 0x18, 0x4C, 0x89, 0x51, 0x10, 0x48, 0x8B, 0x44, 0x0A, 0x08, 0x4C, 0x8B, 0x14, 0x0A, 0x49,
	0xFF, 0xC9, 0x48, 0x89, 0x41, 0x08, 0x4C, 0x89, 0x11, 0x75, 0xD5, 0x49, 0x83, 0xE0, 0x1F, 0xE9,
	0x73, 0xFF, 0xFF, 0xFF, 0x66, 0x66, 0x66, 0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x66, 0x90, 0x48, 0x81, 0xFA, 0x00, 0xF0, 0xFF, 0xFF, 0x77, 0xB5, 0xB8, 0x20, 0x00, 0x00, 0x00,
	0x48, 0x81, 0xE9, 0x80, 0x00, 0x00, 0x00, 0x0F, 0x18, 0x04, 0x0A, 0x0F, 0x18, 0x44, 0x0A, 0x40,
	0xFF, 0xC8, 0x75, 0xEC, 0x48, 0x81, 0xC1, 0x00, 0x10, 0x00, 0x00, 0xB8, 0x40, 0x00, 0x00, 0x00,
	0x4C, 0x8B, 0x4C, 0x0A, 0xF8, 0x4C, 0x8B, 0x54, 0x0A, 0xF0, 0x4C, 0x0F, 0xC3, 0x49, 0xF8, 0x4C,
	0x0F, 0xC3, 0x51, 0xF0, 0x4C, 0x8B, 0x4C, 0x0A, 0xE8, 0x4C, 0x8B, 0x54, 0x0A, 0xE0, 0x4C, 0x0F,
	0xC3, 0x49, 0xE8, 0x4C, 0x0F, 0xC3, 0x51, 0xE0, 0x4C, 0x8B, 0x4C, 0x0A, 0xD8, 0x4C, 0x8B, 0x54,
	0x0A, 0xD0, 0x48, 0x83, 0xE9, 0x40, 0x4C, 0x0F, 0xC3, 0x49, 0x18, 0x4C, 0x0F, 0xC3, 0x51, 0x10,
	0x4C, 0x8B, 0x4C, 0x0A, 0x08, 0x4C, 0x8B, 0x14, 0x0A, 0xFF, 0xC8, 0x4C, 0x0F, 0xC3, 0x49, 0x08,
	0x4C, 0x0F, 0xC3, 0x11, 0x75, 0xAA, 0x49, 0x81, 0xE8, 0x00, 0x10, 0x00, 0x00, 0x49, 0x81, 0xF8,
	0x00, 0x10, 0x00, 0x00, 0x0F, 0x83, 0x71, 0xFF, 0xFF, 0xFF, 0xF0, 0x80, 0x0C, 0x24, 0x00, 0xE9,
	0xBA, 0xFE, 0xFF, 0xFF, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x40, 0x53, 0x48, 0x83,
	0xEC, 0x20, 0x45, 0x8B, 0x18, 0x48, 0x8B, 0xDA, 0x4C, 0x8B, 0xC9, 0x41, 0x83, 0xE3, 0xF8, 0x41,
	0xF6, 0x00, 0x04, 0x4C, 0x8B, 0xD1, 0x74, 0x13, 0x41, 0x8B, 0x40, 0x08, 0x4D, 0x63, 0x50, 0x04,
	0xF7, 0xD8, 0x4C, 0x03, 0xD1, 0x48, 0x63, 0xC8, 0x4C, 0x23, 0xD1, 0x49, 0x63, 0xC3, 0x4A, 0x8B,
	0x14, 0x10, 0x48, 0x8B, 0x43, 0x10, 0x8B, 0x48, 0x08, 0x48, 0x03, 0x4B, 0x08, 0xF6, 0x41, 0x03,
	0x0F, 0x74, 0x0C, 0x0F, 0xB6, 0x41, 0x03, 0x83, 0xE0, 0xF0, 0x48, 0x98, 0x4C, 0x03, 0xC8, 0x4C,
	0x33, 0xCA, 0x49, 0x8B, 0xC9, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xE9, 0xF1, 0xFB, 0xFF, 0xFF, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x28, 0x4D, 0x8B, 0x41, 0x38,
	0x48, 0x8B, 0xCA, 0x49, 0x8B, 0xD1, 0xE8, 0x81, 0xFF, 0xFF, 0xFF, 0xB8, 0x01, 0x00, 0x00, 0x00,
	0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x8B, 0xC4, 0x48,
	0x89, 0x58, 0x08, 0x48, 0x89, 0x68, 0x10, 0x48, 0x89, 0x70, 0x18, 0x48, 0x89, 0x78, 0x20, 0x41,
	0x54, 0x48, 0x83, 0xEC, 0x20, 0x4D, 0x8B, 0x51, 0x38, 0x48, 0x8B, 0xF2, 0x4D, 0x8B, 0xE0, 0x41,
	0x8B, 0x02, 0x48, 0x8B, 0xE9, 0x49, 0x8B, 0xD1, 0x48, 0x03, 0xC0, 0x48, 0x8B, 0xCE, 0x49, 0x8B,
	0xF9, 0x49, 0x8D, 0x5C, 0xC2, 0x04, 0x4C, 0x8B, 0xC3, 0xE8, 0x2E, 0xFF, 0xFF, 0xFF, 0x44, 0x8B,
	0x1B, 0x44, 0x8B, 0x55, 0x04, 0x41, 0x8B, 0xC3, 0x41, 0x83, 0xE3, 0x02, 0xBA, 0x01, 0x00, 0x00,
	0x00, 0x23, 0xC2, 0x41, 0x80, 0xE2, 0x66, 0x44, 0x0F, 0x44, 0xD8, 0x45, 0x85, 0xDB, 0x74, 0x13,
	0x4C, 0x8B, 0xCF, 0x4D, 0x8B, 0xC4, 0x48, 0x8B, 0xD6, 0x48, 0x8B, 0xCD, 0xE8, 0xA5, 0xFB, 0xFF,
	0xFF, 0x8B, 0xD0, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x8B, 0x6C, 0x24, 0x38, 0x48, 0x8B, 0x74,
	0x24, 0x40, 0x48, 0x8B, 0x7C, 0x24, 0x48, 0x8B, 0xC2, 0x48, 0x83, 0xC4, 0x20, 0x41, 0x5C, 0xC3,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x66, 0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x48, 0x8B, 0xC1, 0x49, 0x83, 0xF8, 0x08, 0x72, 0x53, 0x0F, 0xB6, 0xD2, 0x49, 0xB9, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x49, 0x0F, 0xAF, 0xD1, 0x49, 0x83, 0xF8, 0x40, 0x72, 0x1E,
	0x48, 0xF7, 0xD9, 0x83, 0xE1, 0x07, 0x74, 0x06, 0x4C, 0x2B, 0xC1, 0x48, 0x89, 0x10, 0x48, 0x03,
	0xC8, 0x4D, 0x8B, 0xC8, 0x49, 0x83, 0xE0, 0x3F, 0x49, 0xC1, 0xE9, 0x06, 0x75, 0x39, 0x4D, 0x8B,
	0xC8, 0x49, 0x83, 0xE0, 0x07, 0x49, 0xC1, 0xE9, 0x03, 0x74, 0x11, 0x66, 0x66, 0x66, 0x90, 0x90,
	0x48, 0x89, 0x11, 0x48, 0x83, 0xC1, 0x08, 0x49, 0xFF, 0xC9, 0x75, 0xF4, 0x4D, 0x85, 0xC0, 0x74,
	0x0A, 0x88, 0x11, 0x48, 0xFF, 0xC1, 0x49, 0xFF, 0xC8, 0x75, 0xF6, 0xC2, 0x00, 0x00, 0x66, 0x90,
	0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90, 0x49, 0x81, 0xF9, 0x00, 0x1C, 0x00, 0x00, 0x73, 0x30,
	0x48, 0x89, 0x11, 0x48, 0x89, 0x51, 0x08, 0x48, 0x89, 0x51, 0x10, 0x48, 0x83, 0xC1, 0x40, 0x48,
	0x89, 0x51, 0xD8, 0x48, 0x89, 0x51, 0xE0, 0x49, 0xFF, 0xC9, 0x48, 0x89, 0x51, 0xE8, 0x48, 0x89,
	0x51, 0xF0, 0x48, 0x89, 0x51, 0xF8, 0x75, 0xD8, 0xEB, 0x94, 0x66, 0x0F, 0x1F, 0x44, 0x00, 0x00,
	0x48, 0x0F, 0xC3, 0x11, 0x48, 0x0F, 0xC3, 0x51, 0x08, 0x48, 0x0F, 0xC3, 0x51, 0x10, 0x48, 0x83,
	0xC1, 0x40, 0x48, 0x0F, 0xC3, 0x51, 0xD8, 0x48, 0x0F, 0xC3, 0x51, 0xE0, 0x49, 0xFF, 0xC9, 0x48,
	0x0F, 0xC3, 0x51, 0xE8, 0x48, 0x0F, 0xC3, 0x51, 0xF0, 0x48, 0x0F, 0xC3, 0x51, 0xF8, 0x75, 0xD0,
	0xF0, 0x80, 0x0C, 0x24, 0x00, 0xE9, 0x54, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xF0, 0xA2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0xA3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1C, 0xA3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0xA3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x46, 0xA3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x56, 0xA3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x72, 0xA3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0xA3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x8E, 0xA3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA4, 0xA3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xBC, 0xA3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCE, 0xA3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xE2, 0xA3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEE, 0xA3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFE, 0xA3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0xA4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x22, 0xA4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0xA4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x4E, 0xA4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0xA4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x74, 0xA4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8C, 0xA4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xA6, 0xA4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xBA, 0xA4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xCE, 0xA4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE2, 0xA4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xF8, 0xA4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0xA5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x2A, 0xA5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3A, 0xA5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x54, 0xA5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6C, 0xA5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x88, 0xA5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0xA5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xBE, 0xA5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xDA, 0xA5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xF2, 0xA5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0xA6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x28, 0xA6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0xA6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x52, 0xA6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6C, 0xA6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x80, 0xA6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9E, 0xA6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xB8, 0xA6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCA, 0xA6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xE8, 0xA6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xA6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1A, 0xA7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2E, 0xA7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x42, 0xA7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0xA7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x62, 0xA7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xA7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x8A, 0xA7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0xA7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xBA, 0xA7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD4, 0xA7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xEC, 0xA7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xA7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1A, 0xA8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0xA8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x4C, 0xA8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0xA8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x72, 0xA8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8A, 0xA8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xAA, 0xA8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xA8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xD0, 0xA8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE4, 0xA8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x02, 0xA9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xE4, 0x77, 0x69, 0x55, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
	0x5F, 0x00, 0x00, 0x00, 0x5C, 0x32, 0x00, 0x00, 0x5C, 0x1C, 0x00, 0x00, 0x52, 0x53, 0x44, 0x53,
	0xFC, 0xB1, 0x4A, 0x5E, 0x71, 0xBC, 0xA5, 0x41, 0xAB, 0xC3, 0x9A, 0x92, 0xAF, 0x34, 0x99, 0xBC,
	0x05, 0x00, 0x00, 0x00, 0x64, 0x3A, 0x5C, 0x70, 0x72, 0x6F, 0x6A, 0x65, 0x63, 0x74, 0x73, 0x5C,
	0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x68, 0x61, 0x63, 0x6B, 0x65, 0x72, 0x32, 0x5C, 0x6B,
	0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x68, 0x61, 0x63, 0x6B, 0x65, 0x72, 0x5C, 0x62, 0x69,
	0x6E, 0x5C, 0x61, 0x6D, 0x64, 0x36, 0x34, 0x5C, 0x6B, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73,
	0x68, 0x61, 0x63, 0x6B, 0x65, 0x72, 0x2E, 0x70, 0x64, 0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x01, 0x04, 0x01, 0x00, 0x04, 0x42, 0x00, 0x00, 0x01, 0x04, 0x01, 0x00, 0x04, 0x62, 0x00, 0x00,
	0x09, 0x19, 0x0A, 0x00, 0x19, 0xC4, 0x11, 0x00, 0x19, 0x74, 0x10, 0x00, 0x19, 0x64, 0x0F, 0x00,
	0x19, 0x34, 0x0E, 0x00, 0x19, 0xB2, 0x15, 0xD0, 0xF6, 0x1E, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
	0x55, 0x8F, 0x00, 0x00, 0x69, 0x8F, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x69, 0x8F, 0x00, 0x00,
	0xBD, 0x8F, 0x00, 0x00, 0xCA, 0x8F, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xCA, 0x8F, 0x00, 0x00,
	0x57, 0x90, 0x00, 0x00, 0x62, 0x90, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x62, 0x90, 0x00, 0x00,
	0x09, 0x1D, 0x0C, 0x00, 0x1D, 0xC4, 0x13, 0x00, 0x1D, 0x74, 0x12, 0x00, 0x1D, 0x64, 0x11, 0x00,
	0x1D, 0x34, 0x10, 0x00, 0x1D, 0xB2, 0x19, 0xF0, 0x17, 0xE0, 0x15, 0xD0, 0xF6, 0x1E, 0x00, 0x00,
	0x04, 0x00, 0x00, 0x00, 0x56, 0x8D, 0x00, 0x00, 0x88, 0x8D, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x88, 0x8D, 0x00, 0x00, 0x62, 0x8E, 0x00, 0x00, 0x6B, 0x8E, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x6B, 0x8E, 0x00, 0x00, 0xAF, 0x8E, 0x00, 0x00, 0xB4, 0x8E, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0xB4, 0x8E, 0x00, 0x00, 0xEF, 0x8E, 0x00, 0x00, 0xF3, 0x8E, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0xF3, 0x8E, 0x00, 0x00, 0x09, 0x15, 0x08, 0x00, 0x15, 0x74, 0x0E, 0x00, 0x15, 0x64, 0x0D, 0x00,
	0x15, 0x34, 0x0C, 0x00, 0x15, 0x92, 0x11, 0xC0, 0xF6, 0x1E, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
	0x66, 0x87, 0x00, 0x00, 0x79, 0x87, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x79, 0x87, 0x00, 0x00,
	0xFA, 0x87, 0x00, 0x00, 0x04, 0x88, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x88, 0x00, 0x00,
	0x09, 0x15, 0x08, 0x00, 0x15, 0x74, 0x10, 0x00, 0x15, 0x64, 0x0F, 0x00, 0x15, 0x34, 0x0E, 0x00,
	0x15, 0xB2, 0x11, 0xC0, 0xF6, 0x1E, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x56, 0x86, 0x00, 0x00,
	0x80, 0x86, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x82, 0x86, 0x00, 0x00, 0x09, 0x87, 0x00, 0x00,
	0x13, 0x87, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x13, 0x87, 0x00, 0x00, 0x09, 0x1D, 0x0C, 0x00,
	0x1D, 0xC4, 0x0F, 0x00, 0x1D, 0x74, 0x0E, 0x00, 0x1D, 0x64, 0x0D, 0x00, 0x1D, 0x34, 0x0C, 0x00,
	0x1D, 0x72, 0x19, 0xF0, 0x17, 0xE0, 0x15, 0xD0, 0xF6, 0x1E, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
	0x20, 0x84, 0x00, 0x00, 0x50, 0x84, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x50, 0x84, 0x00, 0x00,
	0x8F, 0x84, 0x00, 0x00, 0xB7, 0x85, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xB7, 0x85, 0x00, 0x00,
	0x09, 0x1C, 0x0A, 0x00, 0x1C, 0xC4, 0x15, 0x00, 0x1C, 0x74, 0x14, 0x00, 0x1C, 0x64, 0x13, 0x00,
	0x1C, 0x34, 0x12, 0x00, 0x1C, 0xF2, 0x15, 0xD0, 0xF6, 0x1E, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
	0x4E, 0x82, 0x00, 0x00, 0x62, 0x82, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x62, 0x82, 0x00, 0x00,
	0xB6, 0x82, 0x00, 0x00, 0xC3, 0x82, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xC3, 0x82, 0x00, 0x00,
	0x43, 0x83, 0x00, 0x00, 0x50, 0x83, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x50, 0x83, 0x00, 0x00,
	0x09, 0x1C, 0x0B, 0x00, 0x1C, 0x74, 0x18, 0x00, 0x1C, 0x64, 0x17, 0x00, 0x1C, 0x34, 0x16, 0x00,
	0x1C, 0x01, 0x12, 0x00, 0x15, 0xE0, 0x13, 0xD0, 0x11, 0xC0, 0x00, 0x00, 0xF6, 0x1E, 0x00, 0x00,
	0x05, 0x00, 0x00, 0x00, 0xC5, 0x7F, 0x00, 0x00, 0xEF, 0x7F, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0xEF, 0x7F, 0x00, 0x00, 0xD5, 0x80, 0x00, 0x00, 0xDE, 0x80, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0xDE, 0x80, 0x00, 0x00, 0x53, 0x81, 0x00, 0x00, 0x5C, 0x81, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x5C, 0x81, 0x00, 0x00, 0xA8, 0x81, 0x00, 0x00, 0xAD, 0x81, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0xAD, 0x81, 0x00, 0x00, 0xE5, 0x81, 0x00, 0x00, 0xEB, 0x81, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0xEB, 0x81, 0x00, 0x00, 0x09, 0x15, 0x08, 0x00, 0x15, 0x74, 0x0E, 0x00, 0x15, 0x64, 0x0D, 0x00,
	0x15, 0x34, 0x0C, 0x00, 0x15, 0x92, 0x11, 0xC0, 0xF6, 0x1E, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
	0xA3, 0x7D, 0x00, 0x00, 0xB6, 0x7D, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xB6, 0x7D, 0x00, 0x00,
	0x43, 0x7E, 0x00, 0x00, 0x4D, 0x7E, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x4D, 0x7E, 0x00, 0x00,
	0x09, 0x15, 0x08, 0x00, 0x15, 0x74, 0x0E, 0x00, 0x15, 0x64, 0x0D, 0x00, 0x15, 0x34, 0x0C, 0x00,
	0x15, 0x92, 0x11, 0xC0, 0xF6, 0x1E, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xA1, 0x7C, 0x00, 0x00,
	0xB4, 0x7C, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xB4, 0x7C, 0x00, 0x00, 0x41, 0x7D, 0x00, 0x00,
	0x4B, 0x7D, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x4B, 0x7D, 0x00, 0x00, 0x09, 0x15, 0x08, 0x00,
	0x15, 0x74, 0x12, 0x00, 0x15, 0x64, 0x11, 0x00, 0x15, 0x34, 0x10, 0x00, 0x15, 0xD2, 0x11, 0xC0,
	0xF6, 0x1E, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x7A, 0x7B, 0x00, 0x00, 0xA4, 0x7B, 0x00, 0x00,
	0x01, 0x00, 0x00, 0x00, 0xA6, 0x7B, 0x00, 0x00, 0x47, 0x7C, 0x00, 0x00, 0x51, 0x7C, 0x00, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x51, 0x7C, 0x00, 0x00, 0x01, 0x19, 0x0A, 0x00, 0x19, 0x54, 0x18, 0x00,
	0x19, 0x34, 0x16, 0x00, 0x19, 0xF2, 0x12, 0xF0, 0x10, 0xE0, 0x0E, 0xD0, 0x0C, 0x70, 0x0B, 0x60,
	0x09, 0x1D, 0x0A, 0x00, 0x1D, 0x74, 0x15, 0x00, 0x1D, 0x64, 0x14, 0x00, 0x1D, 0x34, 0x12, 0x00,
	0x1D, 0xD2, 0x19, 0xE0, 0x17, 0xD0, 0x15, 0xC0, 0xF6, 0x1E, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
	0x7D, 0x75, 0x00, 0x00, 0x92, 0x75, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x92, 0x75, 0x00, 0x00,
	0x16, 0x76, 0x00, 0x00, 0x25, 0x76, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x25, 0x76, 0x00, 0x00,
	0x01, 0x1C, 0x0C, 0x00, 0x1C, 0x64, 0x0D, 0x00, 0x1C, 0x54, 0x0B, 0x00, 0x1C, 0x34, 0x0A, 0x00,
	0x1C, 0x32, 0x18, 0xF0, 0x16, 0xE0, 0x14, 0xD0, 0x12, 0xC0, 0x10, 0x70, 0x01, 0x0A, 0x04, 0x00,
	0x0A, 0x34, 0x0B, 0x00, 0x0A, 0x72, 0x06, 0x70, 0x09, 0x06, 0x02, 0x00, 0x06, 0x32, 0x02, 0x30,
	0xF6, 0x1E, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x11, 0x63, 0x00, 0x00, 0x29, 0x63, 0x00, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x2B, 0x63, 0x00, 0x00, 0x19, 0x15, 0x02, 0x00, 0x06, 0x92, 0x02, 0x30,
	0xB8, 0x22, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x01, 0x06, 0x02, 0x00, 0x06, 0x52, 0x02, 0x50,
	0x19, 0x23, 0x08, 0x00, 0x11, 0x01, 0x73, 0x00, 0x0A, 0xF0, 0x08, 0xE0, 0x06, 0xD0, 0x04, 0x70,
	0x03, 0x60, 0x02, 0x30, 0xDC, 0x22, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xC3, 0x92, 0x00, 0x00,
	0x3F, 0x94, 0x00, 0x00, 0x96, 0x9C, 0x00, 0x00, 0x8C, 0x94, 0x00, 0x00, 0x81, 0x03, 0x00, 0x00,
	0x01, 0x12, 0x07, 0x00, 0x12, 0x64, 0x47, 0x00, 0x12, 0x34, 0x46, 0x00, 0x12, 0x01, 0x44, 0x00,
	0x0B, 0x70, 0x00, 0x00, 0x09, 0x19, 0x0A, 0x00, 0x19, 0xC4, 0x11, 0x00, 0x19, 0x74, 0x10, 0x00,
	0x19, 0x64, 0x0F, 0x00, 0x19, 0x34, 0x0E, 0x00, 0x19, 0xB2, 0x15, 0xD0, 0xF6, 0x1E, 0x00, 0x00,
	0x02, 0x00, 0x00, 0x00, 0xA0, 0x78, 0x00, 0x00, 0xB9, 0x78, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0xB9, 0x78, 0x00, 0x00, 0x79, 0x79, 0x00, 0x00, 0x83, 0x79, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x83, 0x79, 0x00, 0x00, 0x09, 0x0F, 0x04, 0x00, 0x0F, 0x34, 0x0A, 0x00, 0x0F, 0x72, 0x0B, 0x70,
	0xF6, 0x1E, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x74, 0x68, 0x00, 0x00, 0x86, 0x68, 0x00, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x86, 0x68, 0x00, 0x00, 0x09, 0x19, 0x0A, 0x00, 0x19, 0xC4, 0x0D, 0x00,
	0x19, 0x74, 0x0C, 0x00, 0x19, 0x64, 0x0B, 0x00, 0x19, 0x34, 0x0A, 0x00, 0x19, 0x72, 0x15, 0xD0,
	0xF6, 0x1E, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x73, 0x1C, 0x00, 0x00, 0xB4, 0x1C, 0x00, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x20, 0x1D, 0x00, 0x00, 0xEC, 0x1C, 0x00, 0x00, 0xFC, 0x1C, 0x00, 0x00,
	0x01, 0x00, 0x00, 0x00, 0xFC, 0x1C, 0x00, 0x00, 0x01, 0x18, 0x0A, 0x00, 0x18, 0x64, 0x0B, 0x00,
	0x18, 0x54, 0x09, 0x00, 0x18, 0x34, 0x08, 0x00, 0x18, 0x32, 0x14, 0xD0, 0x12, 0xC0, 0x10, 0x70,
	0x01, 0x0D, 0x05, 0x00, 0x0D, 0x34, 0x15, 0x00, 0x0D, 0x01, 0x12, 0x00, 0x06, 0x70, 0x00, 0x00,
	0x19, 0x1E, 0x06, 0x00, 0x0F, 0x64, 0x0C, 0x00, 0x0F, 0x34, 0x0A, 0x00, 0x0F, 0x72, 0x0B, 0x70,
	0xB8, 0x22, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x09, 0x1D, 0x0C, 0x00, 0x1D, 0xC4, 0x13, 0x00,
	0x1D, 0x74, 0x12, 0x00, 0x1D, 0x64, 0x11, 0x00, 0x1D, 0x34, 0x10, 0x00, 0x1D, 0xB2, 0x19, 0xF0,
	0x17, 0xE0, 0x15, 0xD0, 0xF6, 0x1E, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0xB0, 0x98, 0x00, 0x00,
	0xC3, 0x98, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xC3, 0x98, 0x00, 0x00, 0x07, 0x99, 0x00, 0x00,
	0x41, 0x99, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x4F, 0x99, 0x00, 0x00, 0xED, 0x99, 0x00, 0x00,
	0xF2, 0x99, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xF2, 0x99, 0x00, 0x00, 0x09, 0x19, 0x0A, 0x00,
	0x19, 0x74, 0x10, 0x00, 0x19, 0x64, 0x0F, 0x00, 0x19, 0x34, 0x0E, 0x00, 0x19, 0x92, 0x15, 0xE0,
	0x13, 0xD0, 0x11, 0xC0, 0xF6, 0x1E, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x4E, 0x97, 0x00, 0x00,
	0x61, 0x97, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x61, 0x97, 0x00, 0x00, 0x1B, 0x98, 0x00, 0x00,
	0x20, 0x98, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x20, 0x98, 0x00, 0x00, 0x09, 0x19, 0x0A, 0x00,
	0x19, 0x74, 0x10, 0x00, 0x19, 0x64, 0x0F, 0x00, 0x19, 0x34, 0x0E, 0x00, 0x19, 0x92, 0x15, 0xE0,
	0x13, 0xD0, 0x11, 0xC0, 0xF6, 0x1E, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xEA, 0x95, 0x00, 0x00,
	0xFD, 0x95, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xFD, 0x95, 0x00, 0x00, 0xB7, 0x96, 0x00, 0x00,
	0xBC, 0x96, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xBC, 0x96, 0x00, 0x00, 0x01, 0x06, 0x02, 0x00,
	0x06, 0x52, 0x02, 0x30, 0x09, 0x21, 0x09, 0x00, 0x21, 0x34, 0x26, 0x00, 0x21, 0x01, 0x1E, 0x00,
	0x1A, 0xF0, 0x18, 0xD0, 0x16, 0xC0, 0x14, 0x70, 0x13, 0x60, 0x00, 0x00, 0xF6, 0x1E, 0x00, 0x00,
	0x03, 0x00, 0x00, 0x00, 0x47, 0x8A, 0x00, 0x00, 0xA7, 0x8A, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0xA7, 0x8A, 0x00, 0x00, 0xCB, 0x8A, 0x00, 0x00, 0xDD, 0x8A, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0xDD, 0x8A, 0x00, 0x00, 0x2F, 0x8C, 0x00, 0x00, 0x64, 0x8C, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x64, 0x8C, 0x00, 0x00, 0x09, 0x18, 0x09, 0x00, 0x18, 0xC4, 0x16, 0x00, 0x18, 0x74, 0x15, 0x00,
	0x18, 0x64, 0x14, 0x00, 0x18, 0x01, 0x12, 0x00, 0x11, 0xD0, 0x00, 0x00, 0xF6, 0x1E, 0x00, 0x00,
	0x02, 0x00, 0x00, 0x00, 0x0E, 0x7A, 0x00, 0x00, 0x45, 0x7A, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x47, 0x7A, 0x00, 0x00, 0x1C, 0x7B, 0x00, 0x00, 0x26, 0x7B, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x26, 0x7B, 0x00, 0x00, 0x19, 0x26, 0x09, 0x00, 0x14, 0x34, 0x26, 0x00, 0x14, 0x01, 0x1E, 0x00,
	0x0D, 0xE0, 0x0B, 0xD0, 0x09, 0xC0, 0x07, 0x70, 0x06, 0x60, 0x00, 0x00, 0xDC, 0x22, 0x00, 0x00,
	0x0B, 0x00, 0x00, 0x00, 0x61, 0x6C, 0x00, 0x00, 0x92, 0x6C, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x92, 0x6C, 0x00, 0x00, 0x2E, 0x6E, 0x00, 0x00, 0x34, 0x6E, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x34, 0x6E, 0x00, 0x00, 0x19, 0x6F, 0x00, 0x00, 0x3C, 0x6F, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x3C, 0x6F, 0x00, 0x00, 0x78, 0x70, 0x00, 0x00, 0x9B, 0x70, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x9B, 0x70, 0x00, 0x00, 0x18, 0x71, 0x00, 0x00, 0x2D, 0x71, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x2D, 0x71, 0x00, 0x00, 0x94, 0x71, 0x00, 0x00, 0xA9, 0x71, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0xA9, 0x71, 0x00, 0x00, 0x0F, 0x72, 0x00, 0x00, 0x1B, 0x72, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x1B, 0x72, 0x00, 0x00, 0xD2, 0x72, 0x00, 0x00, 0xE2, 0x72, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0xE2, 0x72, 0x00, 0x00, 0x18, 0x74, 0x00, 0x00, 0x28, 0x74, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x28, 0x74, 0x00, 0x00, 0xA2, 0x74, 0x00, 0x00, 0xB7, 0x74, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0xB7, 0x74, 0x00, 0x00, 0xEF, 0x74, 0x00, 0x00, 0xF9, 0x74, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0xF9, 0x74, 0x00, 0x00, 0xE1, 0x00, 0x00, 0x00, 0x01, 0x0F, 0x06, 0x00, 0x0F, 0x64, 0x07, 0x00,
	0x0F, 0x34, 0x06, 0x00, 0x0F, 0x32, 0x0B, 0x70, 0x01, 0x0A, 0x04, 0x00, 0x0A, 0x34, 0x06, 0x00,
	0x0A, 0x32, 0x06, 0x70, 0x09, 0x19, 0x0A, 0x00, 0x19, 0xC4, 0x11, 0x00, 0x19, 0x74, 0x10, 0x00,
	0x19, 0x64, 0x0F, 0x00, 0x19, 0x34, 0x0E, 0x00, 0x19, 0xB2, 0x15, 0xE0, 0xF6, 0x1E, 0x00, 0x00,
	0x03, 0x00, 0x00, 0x00, 0x71, 0x69, 0x00, 0x00, 0x9B, 0x69, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x9B, 0x69, 0x00, 0x00, 0x9C, 0x6A, 0x00, 0x00, 0xA2, 0x6A, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0xA4, 0x6A, 0x00, 0x00, 0xC1, 0x6A, 0x00, 0x00, 0xC5, 0x6A, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0xC7, 0x6A, 0x00, 0x00, 0x01, 0x0B, 0x03, 0x00, 0x0B, 0x01, 0x18, 0x00, 0x04, 0x30, 0x00, 0x00,
	0x01, 0x10, 0x06, 0x00, 0x10, 0x64, 0x0D, 0x00, 0x10, 0x34, 0x0C, 0x00, 0x10, 0x92, 0x0C, 0x70,
	0x19, 0x2E, 0x0B, 0x00, 0x1C, 0x74, 0x27, 0x00, 0x1C, 0x64, 0x26, 0x00, 0x1C, 0x34, 0x24, 0x00,
	0x1C, 0x01, 0x20, 0x00, 0x15, 0xF0, 0x13, 0xD0, 0x11, 0xC0, 0x00, 0x00, 0xDC, 0x22, 0x00, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x45, 0x12, 0x00, 0x00, 0x68, 0x12, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x6A, 0x12, 0x00, 0x00, 0xF1, 0x00, 0x00, 0x00, 0x01, 0x0A, 0x04, 0x00, 0x0A, 0x34, 0x0D, 0x00,
	0x0A, 0x92, 0x06, 0x70, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x06, 0x02, 0x00,
	0x06, 0x32, 0x02, 0x30, 0x01, 0x19, 0x0A, 0x00, 0x19, 0x74, 0x09, 0x00, 0x19, 0x64, 0x08, 0x00,
	0x19, 0x54, 0x07, 0x00, 0x19, 0x34, 0x06, 0x00, 0x19, 0x32, 0x15, 0xC0, 0x00, 0x00, 0x00, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x32, 0xA2, 0xDF, 0x2D, 0x99, 0x2B, 0x00, 0x00, 0xCD, 0x5D, 0x20, 0xD2, 0x66, 0xD4, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x08, 0x10, 0x00, 0x00, 0xBB, 0x10, 0x00, 0x00, 0x80, 0x37, 0x00, 0x00, 0xC4, 0x10, 0x00, 0x00,
	0xCA, 0x11, 0x00, 0x00, 0x58, 0x37, 0x00, 0x00, 0xD0, 0x11, 0x00, 0x00, 0xA4, 0x1B, 0x00, 0x00,
	0x60, 0x3A, 0x00, 0x00, 0xAC, 0x1B, 0x00, 0x00, 0x4C, 0x1C, 0x00, 0x00, 0xB4, 0x3A, 0x00, 0x00,
	0x54, 0x1C, 0x00, 0x00, 0x3B, 0x1D, 0x00, 0x00, 0x18, 0x37, 0x00, 0x00, 0x44, 0x1D, 0x00, 0x00,
	0x88, 0x1D, 0x00, 0x00, 0xAC, 0x3A, 0x00, 0x00, 0x90, 0x1D, 0x00, 0x00, 0xBD, 0x1D, 0x00, 0x00,
	0xC0, 0x32, 0x00, 0x00, 0xC4, 0x1D, 0x00, 0x00, 0x55, 0x1E, 0x00, 0x00, 0xA0, 0x36, 0x00, 0x00,
	0xC8, 0x1E, 0x00, 0x00, 0xEF, 0x1E, 0x00, 0x00, 0xC8, 0x32, 0x00, 0x00, 0x10, 0x1F, 0x00, 0x00,
	0x44, 0x22, 0x00, 0x00, 0xA8, 0x3A, 0x00, 0x00, 0x4C, 0x22, 0x00, 0x00, 0xAF, 0x22, 0x00, 0x00,
	0xAC, 0x3A, 0x00, 0x00, 0xB8, 0x22, 0x00, 0x00, 0xD5, 0x22, 0x00, 0x00, 0xC0, 0x32, 0x00, 0x00,
	0xDC, 0x22, 0x00, 0x00, 0x70, 0x23, 0x00, 0x00, 0xB4, 0x3A, 0x00, 0x00, 0x80, 0x23, 0x00, 0x00,
	0x6A, 0x24, 0x00, 0x00, 0xD0, 0x3A, 0x00, 0x00, 0x08, 0x60, 0x00, 0x00, 0xEE, 0x60, 0x00, 0x00,
	0x98, 0x3A, 0x00, 0x00, 0x08, 0x61, 0x00, 0x00, 0x71, 0x61, 0x00, 0x00, 0x58, 0x36, 0x00, 0x00,
	0x78, 0x61, 0x00, 0x00, 0xFC, 0x62, 0x00, 0x00, 0x70, 0x37, 0x00, 0x00, 0x04, 0x63, 0x00, 0x00,
	0x3D, 0x63, 0x00, 0x00, 0x38, 0x36, 0x00, 0x00, 0x44, 0x63, 0x00, 0x00, 0x2D, 0x64, 0x00, 0x00,
	0x2C, 0x36, 0x00, 0x00, 0x10, 0x66, 0x00, 0x00, 0x1E, 0x67, 0x00, 0x00, 0xC8, 0x32, 0x00, 0x00,
	0x24, 0x67, 0x00, 0x00, 0x58, 0x67, 0x00, 0x00, 0xC0, 0x32, 0x00, 0x00, 0x60, 0x67, 0x00, 0x00,
	0xB0, 0x68, 0x00, 0x00, 0xF4, 0x36, 0x00, 0x00, 0xB8, 0x68, 0x00, 0x00, 0x16, 0x69, 0x00, 0x00,
	0xD8, 0x39, 0x00, 0x00, 0x1C, 0x69, 0x00, 0x00, 0xFC, 0x6A, 0x00, 0x00, 0xF4, 0x39, 0x00, 0x00,
	0x04, 0x6B, 0x00, 0x00, 0x12, 0x6C, 0x00, 0x00, 0x10, 0x36, 0x00, 0x00, 0x18, 0x6C, 0x00, 0x00,
	0x32, 0x75, 0x00, 0x00, 0x04, 0x39, 0x00, 0x00, 0x38, 0x75, 0x00, 0x00, 0x93, 0x76, 0x00, 0x00,
	0xD0, 0x35, 0x00, 0x00, 0x9C, 0x76, 0x00, 0x00, 0x5D, 0x78, 0x00, 0x00, 0xB8, 0x35, 0x00, 0x00,
	0x64, 0x78, 0x00, 0x00, 0xCA, 0x79, 0x00, 0x00, 0xB4, 0x36, 0x00, 0x00, 0xD0, 0x79, 0x00, 0x00,
	0x4E, 0x7B, 0x00, 0x00, 0xC4, 0x38, 0x00, 0x00, 0x54, 0x7B, 0x00, 0x00, 0x76, 0x7C, 0x00, 0x00,
	0x7C, 0x35, 0x00, 0x00, 0x7C, 0x7C, 0x00, 0x00, 0x6F, 0x7D, 0x00, 0x00, 0x40, 0x35, 0x00, 0x00,
	0x78, 0x7D, 0x00, 0x00, 0x71, 0x7E, 0x00, 0x00, 0x04, 0x35, 0x00, 0x00, 0x78, 0x7E, 0x00, 0x00,
	0x73, 0x7F, 0x00, 0x00, 0x50, 0x3A, 0x00, 0x00, 0x7C, 0x7F, 0x00, 0x00, 0x15, 0x82, 0x00, 0x00,
	0x90, 0x34, 0x00, 0x00, 0x1C, 0x82, 0x00, 0x00, 0xE0, 0x83, 0x00, 0x00, 0x40, 0x34, 0x00, 0x00,
	0xE8, 0x83, 0x00, 0x00, 0xE5, 0x85, 0x00, 0x00, 0xFC, 0x33, 0x00, 0x00, 0xEC, 0x85, 0x00, 0x00,
	0x2A, 0x86, 0x00, 0x00, 0xC0, 0x32, 0x00, 0x00, 0x30, 0x86, 0x00, 0x00, 0x38, 0x87, 0x00, 0x00,
	0xC0, 0x33, 0x00, 0x00, 0x40, 0x87, 0x00, 0x00, 0x28, 0x88, 0x00, 0x00, 0x84, 0x33, 0x00, 0x00,
	0x30, 0x88, 0x00, 0x00, 0xB4, 0x88, 0x00, 0x00, 0xE8, 0x39, 0x00, 0x00, 0xBC, 0x88, 0x00, 0x00,
	0xBC, 0x89, 0x00, 0x00, 0x44, 0x3A, 0x00, 0x00, 0xC4, 0x89, 0x00, 0x00, 0xF4, 0x89, 0x00, 0x00,
	0xAC, 0x3A, 0x00, 0x00, 0xFC, 0x89, 0x00, 0x00, 0xCA, 0x8C, 0x00, 0x00, 0x74, 0x38, 0x00, 0x00,
	0xD0, 0x8C, 0x00, 0x00, 0x1A, 0x8D, 0x00, 0x00, 0x6C, 0x38, 0x00, 0x00, 0x20, 0x8D, 0x00, 0x00,
	0x1C, 0x8F, 0x00, 0x00, 0x20, 0x33, 0x00, 0x00, 0x24, 0x8F, 0x00, 0x00, 0x3B, 0x91, 0x00, 0x00,
	0xD0, 0x32, 0x00, 0x00, 0x44, 0x91, 0x00, 0x00, 0x81, 0x95, 0x00, 0x00, 0x70, 0x36, 0x00, 0x00,
	0x88, 0x95, 0x00, 0x00, 0xE5, 0x96, 0x00, 0x00, 0x2C, 0x38, 0x00, 0x00, 0xEC, 0x96, 0x00, 0x00,
	0x49, 0x98, 0x00, 0x00, 0xEC, 0x37, 0x00, 0x00, 0x50, 0x98, 0x00, 0x00, 0x1F, 0x9A, 0x00, 0x00,
	0x98, 0x37, 0x00, 0x00, 0x96, 0x9C, 0x00, 0x00, 0xB2, 0x9C, 0x00, 0x00, 0x68, 0x36, 0x00, 0x00,
	0x64, 0xA0, 0x00, 0x00, 0x82, 0xA0, 0x00, 0x00, 0xC0, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x89, 0x5C, 0x24, 0x10, 0x57, 0x48, 0x83,
	0xEC, 0x50, 0x48, 0x8B, 0xD9, 0x48, 0x89, 0x0D, 0x04, 0xE3, 0xFF, 0xFF, 0x48, 0x8D, 0x0D, 0xDD,
	0xE1, 0xFF, 0xFF, 0x48, 0x8B, 0xFA, 0xC7, 0x05, 0xD0, 0xE1, 0xFF, 0xFF, 0x1C, 0x01, 0x00, 0x00,
	0xFF, 0x15, 0x3A, 0xD0, 0xFF, 0xFF, 0x44, 0x8B, 0xD8, 0x85, 0xC0, 0x78, 0x0E, 0x83, 0x3D, 0xAC,
	0xE1, 0xFF, 0xFF, 0x00, 0x75, 0x05, 0xE8, 0xF1, 0x04, 0x00, 0x00, 0x45, 0x85, 0xDB, 0x0F, 0x88,
	0x8C, 0x00, 0x00, 0x00, 0xE8, 0xB7, 0x05, 0x00, 0x00, 0x48, 0x8B, 0xCF, 0xE8, 0x17, 0x01, 0x00,
	0x00, 0x85, 0xC0, 0x78, 0x7E, 0x48, 0x8D, 0x15, 0xB4, 0x39, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24,
	0x40, 0xFF, 0x15, 0x99, 0xCF, 0xFF, 0xFF, 0x4C, 0x8D, 0x5C, 0x24, 0x60, 0x4C, 0x8D, 0x44, 0x24,
	0x40, 0x4C, 0x89, 0x5C, 0x24, 0x30, 0x41, 0xB9, 0x22, 0x00, 0x00, 0x00, 0x33, 0xD2, 0x48, 0x8B,
	0xCB, 0xC6, 0x44, 0x24, 0x28, 0x00, 0xC7, 0x44, 0x24, 0x20, 0x00, 0x01, 0x00, 0x00, 0xFF, 0x15,
	0xAC, 0xCF, 0xFF, 0xFF, 0x44, 0x8B, 0xD8, 0x85, 0xC0, 0x78, 0x38, 0x48, 0x8B, 0x44, 0x24, 0x60,
	0x48, 0x8D, 0x0D, 0x51, 0xAF, 0xFF, 0xFF, 0x48, 0x89, 0x4B, 0x70, 0x48, 0x8D, 0x0D, 0x0E, 0xB1,
	0xFF, 0xFF, 0x48, 0x89, 0x05, 0x6F, 0xE2, 0xFF, 0xFF, 0x48, 0x89, 0x8B, 0xE0, 0x00, 0x00, 0x00,
	0x48, 0x8D, 0x0D, 0x1D, 0x00, 0x00, 0x00, 0x48, 0x89, 0x4B, 0x68, 0x0F, 0xBA, 0x70, 0x30, 0x07,
	0x41, 0x8B, 0xC3, 0x48, 0x8B, 0x5C, 0x24, 0x68, 0x48, 0x83, 0xC4, 0x50, 0x5F, 0xC3, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x8B, 0x0D, 0x3D, 0xE2, 0xFF, 0xFF, 0x48, 0xFF, 0x25, 0x16, 0xCF,
	0xFF, 0xFF, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x40, 0x53, 0x48, 0x83, 0xEC, 0x50, 0x48, 0x8B,
	0x05, 0xEB, 0xDF, 0xFF, 0xFF, 0x48, 0x33, 0xC4, 0x48, 0x89, 0x44, 0x24, 0x48, 0x48, 0x8D, 0x44,
	0x24, 0x30, 0x41, 0x8B, 0xD8, 0x4C, 0x8D, 0x4C, 0x24, 0x38, 0x48, 0x89, 0x44, 0x24, 0x28, 0x41,
	0xB8, 0x02, 0x00, 0x00, 0x00, 0xC7, 0x44, 0x24, 0x20, 0x10, 0x00, 0x00, 0x00, 0xFF, 0x15, 0xED,
	0xCE, 0xFF, 0xFF, 0x83, 0x7C, 0x24, 0x3C, 0x04, 0x44, 0x8B, 0xD8, 0xB8, 0x24, 0x00, 0x00, 0xC0,
	0x44, 0x0F, 0x45, 0xD8, 0x8B, 0x44, 0x24, 0x44, 0x45, 0x85, 0xDB, 0x0F, 0x48, 0xC3, 0x48, 0x8B,
	0x4C, 0x24, 0x48, 0x48, 0x33, 0xCC, 0xE8, 0x35, 0xBD, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x50, 0x5B,
	0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x89, 0x5C, 0x24, 0x10, 0x57, 0x48, 0x81,
	0xEC, 0x90, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xF9, 0x48, 0x8D, 0x15, 0xC1, 0x38, 0x00, 0x00, 0x48,
	0x8D, 0x4C, 0x24, 0x38, 0xFF, 0x15, 0x76, 0xCE, 0xFF, 0xFF, 0x44, 0x0F, 0xB7, 0x1F, 0xBB, 0x01,
	0x00, 0x00, 0x00, 0x66, 0x44, 0x03, 0x5C, 0x24, 0x38, 0x41, 0xB8, 0x4B, 0x70, 0x68, 0x54, 0x8B,
	0xCB, 0x41, 0x0F, 0xB7, 0xD3, 0x66, 0x44, 0x89, 0x5C, 0x24, 0x28, 0x66, 0x44, 0x89, 0x5C, 0x24,
	0x2A, 0xFF, 0x15, 0x39, 0xCE, 0xFF, 0xFF, 0x48, 0x89, 0x44, 0x24, 0x30, 0x48, 0x85, 0xC0, 0x75,
	0x0A, 0xB8, 0x9A, 0x00, 0x00, 0xC0, 0xE9, 0x10, 0x01, 0x00, 0x00, 0x44, 0x0F, 0xB7, 0x07, 0x48,
	0x8B, 0x57, 0x08, 0x48, 0x8B, 0xC8, 0xE8, 0x25, 0xBD, 0xFF, 0xFF, 0x0F, 0xB7, 0x0F, 0x48, 0x8B,
	0x44, 0x24, 0x30, 0x44, 0x0F, 0xB7, 0x44, 0x24, 0x38, 0x48, 0x8B, 0x54, 0x24, 0x40, 0x48, 0xD1,
	0xE9, 0x48, 0x8D, 0x0C, 0x48, 0xE8, 0x06, 0xBD, 0xFF, 0xFF, 0x48, 0x83, 0x64, 0x24, 0x60, 0x00,
	0x48, 0x83, 0x64, 0x24, 0x78, 0x00, 0x48, 0x83, 0xA4, 0x24, 0x80, 0x00, 0x00, 0x00, 0x00, 0x48,
	0x8D, 0x44, 0x24, 0x28, 0x4C, 0x8D, 0x44, 0x24, 0x58, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0xBA, 0x19,
	0x00, 0x02, 0x00, 0x48, 0x89, 0x44, 0x24, 0x68, 0xC7, 0x44, 0x24, 0x58, 0x30, 0x00, 0x00, 0x00,
	0xC7, 0x44, 0x24, 0x70, 0x40, 0x02, 0x00, 0x00, 0xFF, 0x15, 0x12, 0xCE, 0xFF, 0xFF, 0x48, 0x8B,
	0x4C, 0x24, 0x30, 0xBA, 0x4B, 0x70, 0x68, 0x54, 0x8B, 0xF8, 0xFF, 0x15, 0xA8, 0xCD, 0xFF, 0xFF,
	0x85, 0xFF, 0x79, 0x07, 0x33, 0xFF, 0x48, 0x21, 0x7C, 0x24, 0x20, 0x48, 0x8D, 0x15, 0xFE, 0x37,
	0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x48, 0xFF, 0x15, 0x93, 0xCD, 0xFF, 0xFF, 0x48, 0x8B, 0x4C,
	0x24, 0x20, 0x48, 0x85, 0xC9, 0x74, 0x0F, 0x48, 0x8D, 0x54, 0x24, 0x48, 0x44, 0x8B, 0xC3, 0xE8,
	0x74, 0xFE, 0xFF, 0xFF, 0x8B, 0xD8, 0x48, 0x8D, 0x15, 0xF3, 0x37, 0x00, 0x00, 0x48, 0x8D, 0x4C,
	0x24, 0x48, 0x89, 0x1D, 0x88, 0xE0, 0xFF, 0xFF, 0xFF, 0x15, 0x62, 0xCD, 0xFF, 0xFF, 0x48, 0x8B,
	0x4C, 0x24, 0x20, 0x48, 0x85, 0xC9, 0x75, 0x04, 0x33, 0xC0, 0xEB, 0x12, 0x48, 0x8D, 0x54, 0x24,
	0x48, 0x45, 0x33, 0xC0, 0xE8, 0x3F, 0xFE, 0xFF, 0xFF, 0x48, 0x8B, 0x4C, 0x24, 0x20, 0x89, 0x05,
	0x60, 0xE0, 0xFF, 0xFF, 0xE8, 0x6B, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x20, 0x48, 0x85,
	0xC9, 0x74, 0x06, 0xFF, 0x15, 0x4F, 0xCD, 0xFF, 0xFF, 0x8B, 0xC7, 0x48, 0x8B, 0x9C, 0x24, 0xA8,
	0x00, 0x00, 0x00, 0x48, 0x81, 0xC4, 0x90, 0x00, 0x00, 0x00, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0x40, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8B, 0xD9, 0x84, 0xD2, 0x74,
	0x1C, 0xBA, 0x04, 0x00, 0x00, 0x00, 0x44, 0x8B, 0xC2, 0xFF, 0x15, 0x01, 0xCD, 0xFF, 0xFF, 0x44,
	0x8B, 0x1D, 0x02, 0xE0, 0xFF, 0xFF, 0x44, 0x89, 0x1B, 0xEB, 0x0A, 0xEB, 0x0A, 0x8B, 0x05, 0xF5,
	0xDF, 0xFF, 0xFF, 0x89, 0x01, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x89, 0x5C, 0x24, 0x10, 0x57, 0x48, 0x83, 0xEC, 0x40, 0x48, 0x8B,
	0xF9, 0x48, 0x85, 0xC9, 0x75, 0x0A, 0xB8, 0x01, 0x00, 0x00, 0xC0, 0xE9, 0xC2, 0x00, 0x00, 0x00,
	0x48, 0x8D, 0x15, 0x69, 0x37, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x30, 0xFF, 0x15, 0x9E, 0xCC,
	0xFF, 0xFF, 0x45, 0x33, 0xC9, 0x4C, 0x8D, 0x5C, 0x24, 0x50, 0x4C, 0x89, 0x5C, 0x24, 0x28, 0x83,
	0x64, 0x24, 0x20, 0x00, 0x48, 0x8D, 0x54, 0x24, 0x30, 0x45, 0x8D, 0x41, 0x02, 0x48, 0x8B, 0xCF,
	0xFF, 0x15, 0x9A, 0xCC, 0xFF, 0xFF, 0x3D, 0x05, 0x00, 0x00, 0x80, 0x74, 0x07, 0x3D, 0x23, 0x00,
	0x00, 0xC0, 0x75, 0xB2, 0x8B, 0x54, 0x24, 0x50, 0xB9, 0x01, 0x00, 0x00, 0x00, 0x41, 0xB8, 0x4B,
	0x70, 0x68, 0x54, 0xFF, 0x15, 0x47, 0xCC, 0xFF, 0xFF, 0x48, 0x8B, 0xD8, 0x48, 0x85, 0xC0, 0x75,
	0x07, 0xB8, 0x9A, 0x00, 0x00, 0xC0, 0xEB, 0x5A, 0x48, 0x8D, 0x44, 0x24, 0x50, 0x48, 0x8D, 0x54,
	0x24, 0x30, 0x4C, 0x8B, 0xCB, 0x48, 0x89, 0x44, 0x24, 0x28, 0x8B, 0x44, 0x24, 0x50, 0x41, 0xB8,
	0x02, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xCF, 0x89, 0x44, 0x24, 0x20, 0xFF, 0x15, 0x3F, 0xCC, 0xFF,
	0xFF, 0x8B, 0xF8, 0x85, 0xC0, 0x78, 0x1B, 0x83, 0x7B, 0x04, 0x03, 0x75, 0x10, 0x8B, 0x53, 0x08,
	0x48, 0x8D, 0x4B, 0x0C, 0xE8, 0x2B, 0x00, 0x00, 0x00, 0x8B, 0xF8, 0xEB, 0x05, 0xBF, 0x24, 0x00,
	0x00, 0xC0, 0xBA, 0x4B, 0x70, 0x68, 0x54, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0xE8, 0xCB, 0xFF, 0xFF,
	0x8B, 0xC7, 0x48, 0x8B, 0x5C, 0x24, 0x58, 0x48, 0x83, 0xC4, 0x40, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0x44, 0x8B, 0xCA, 0x4C, 0x8B, 0xC1, 0x83, 0xFA, 0x08, 0x73, 0x06, 0xB8,
	0x0D, 0x00, 0x00, 0xC0, 0xC3, 0x83, 0x39, 0x02, 0x75, 0xF5, 0x8B, 0x51, 0x04, 0x83, 0xFA, 0x40,
	0x77, 0xED, 0x48, 0x8D, 0x0C, 0xD2, 0x48, 0x8D, 0x0C, 0x8D, 0x08, 0x00, 0x00, 0x00, 0x4C, 0x3B,
	0xC9, 0x72, 0xDC, 0x33, 0xC9, 0x3B, 0xD1, 0x76, 0x56, 0x44, 0x0F, 0xB7, 0x0D, 0xA3, 0xDE, 0xFF,
	0xFF, 0x49, 0x83, 0xC0, 0x0C, 0x41, 0xBA, 0xFF, 0xFF, 0x00, 0x00, 0x41, 0x0F, 0xB7, 0x40, 0xFC,
	0x3B, 0x05, 0x7E, 0xDD, 0xFF, 0xFF, 0x75, 0x2D, 0x41, 0x0F, 0xB7, 0x40, 0xFE, 0x3B, 0x05, 0x75,
	0xDD, 0xFF, 0xFF, 0x75, 0x20, 0x66, 0x45, 0x39, 0x10, 0x74, 0x06, 0x66, 0x45, 0x39, 0x08, 0x75,
	0x14, 0x66, 0x45, 0x39, 0x50, 0x02, 0x74, 0x1D, 0x41, 0x0F, 0xB7, 0x40, 0x02, 0x3B, 0x05, 0x59,
	0xDD, 0xFF, 0xFF, 0x74, 0x10, 0xFF, 0xC1, 0x49, 0x83, 0xC0, 0x24, 0x3B, 0xCA, 0x72, 0xBC, 0xB8,
	0x25, 0x02, 0x00, 0xC0, 0xC3, 0x41, 0x8B, 0x40, 0x04, 0x89, 0x05, 0x21, 0xDD, 0xFF, 0xFF, 0x41,
	0x0F, 0xBF, 0x40, 0x08, 0x89, 0x05, 0x36, 0xDC, 0xFF, 0xFF, 0x41, 0x0F, 0xBF, 0x40, 0x0A, 0x89,
	0x05, 0x2F, 0xDC, 0xFF, 0xFF, 0x41, 0x0F, 0xBF, 0x40, 0x10, 0x89, 0x05, 0x28, 0xDC, 0xFF, 0xFF,
	0x41, 0x0F, 0xBF, 0x40, 0x12, 0x89, 0x05, 0x21, 0xDC, 0xFF, 0xFF, 0x41, 0x0F, 0xBF, 0x40, 0x14,
	0x89, 0x05, 0x1A, 0xDC, 0xFF, 0xFF, 0x41, 0x0F, 0xBF, 0x40, 0x16, 0x89, 0x05, 0x13, 0xDC, 0xFF,
	0xFF, 0x41, 0x0F, 0xBF, 0x40, 0x18, 0x89, 0x05, 0x0C, 0xDC, 0xFF, 0xFF, 0x41, 0x0F, 0xBF, 0x40,
	0x1A, 0x89, 0x05, 0x05, 0xDC, 0xFF, 0xFF, 0x41, 0x0F, 0xBF, 0x40, 0x1C, 0x89, 0x05, 0xFE, 0xDB,
	0xFF, 0xFF, 0x33, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x8B, 0x15, 0xC2, 0xDC,
	0xFF, 0xFF, 0x8B, 0x0D, 0xC0, 0xDC, 0xFF, 0xFF, 0x0F, 0xB7, 0x05, 0xC5, 0xDD, 0xFF, 0xFF, 0x83,
	0xFA, 0x05, 0x75, 0x4B, 0x83, 0xF9, 0x01, 0x75, 0x29, 0xC7, 0x05, 0x8D, 0xDC, 0xFF, 0xFF, 0x33,
	0x00, 0x00, 0x00, 0x85, 0xC0, 0x0F, 0x84, 0x97, 0x00, 0x00, 0x00, 0x3B, 0xC1, 0x0F, 0x84, 0x8F,
	0x00, 0x00, 0x00, 0x83, 0xF8, 0x02, 0x74, 0x79, 0x83, 0xF8, 0x03, 0x74, 0x74, 0xE9, 0x80, 0x00,
	0x00, 0x00, 0x83, 0xF9, 0x02, 0x75, 0x7B, 0xC7, 0x05, 0x5F, 0xDC, 0xFF, 0xFF, 0x34, 0x00, 0x00,
	0x00, 0x85, 0xC0, 0x74, 0x5C, 0x83, 0xF8, 0x01, 0x74, 0x57, 0x83, 0xF8, 0x02, 0xEB, 0xDC, 0x83,
	0xFA, 0x06, 0x75, 0x55, 0x85, 0xC9, 0x75, 0x0C, 0xC7, 0x05, 0x3E, 0xDC, 0xFF, 0xFF, 0x3C, 0x00,
	0x00, 0x00, 0xEB, 0xDD, 0x83, 0xF9, 0x01, 0x75, 0x12, 0xC7, 0x05, 0x2D, 0xDC, 0xFF, 0xFF, 0x3D,
	0x00, 0x00, 0x00, 0x85, 0xC0, 0x74, 0x2A, 0x3B, 0xC1, 0xEB, 0xB0, 0x83, 0xF9, 0x02, 0x75, 0x0E,
	0xC7, 0x05, 0x16, 0xDC, 0xFF, 0xFF, 0x3E, 0x00, 0x00, 0x00, 0x85, 0xC0, 0xEB, 0x9D, 0x83, 0xF9,
	0x03, 0x75, 0x11, 0xC7, 0x05, 0x03, 0xDC, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x85, 0xC0, 0x75,
	0x11, 0x33, 0xC0, 0xC3, 0x77, 0x05, 0x83, 0xFA, 0x06, 0x76, 0x07, 0x83, 0x0D, 0xEE, 0xDB, 0xFF,
	0xFF, 0xFF, 0xB8, 0xBB, 0x00, 0x00, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0x48, 0x83, 0xEC, 0x38, 0x83, 0x3D, 0xD5, 0xDB, 0xFF, 0xFF, 0x3E, 0x72, 0x24, 0x48, 0x8D, 0x15,
	0xDC, 0x34, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0xFF, 0x15, 0xE1, 0xC9, 0xFF, 0xFF, 0x48,
	0x8D, 0x4C, 0x24, 0x20, 0xFF, 0x15, 0x46, 0xCA, 0xFF, 0xFF, 0x48, 0x89, 0x05, 0x1F, 0xDB, 0xFF,
	0xFF, 0x48, 0x8D, 0x15, 0xE8, 0x34, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0xFF, 0x15, 0xBD,
	0xC9, 0xFF, 0xFF, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0xFF, 0x15, 0x22, 0xCA, 0xFF, 0xFF, 0x48, 0x8D,
	0x15, 0xEB, 0x34, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0x48, 0x89, 0x05, 0xDF, 0xDA, 0xFF,
	0xFF, 0xFF, 0x15, 0x99, 0xC9, 0xFF, 0xFF, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0xFF, 0x15, 0xFE, 0xC9,
	0xFF, 0xFF, 0x48, 0x8D, 0x15, 0x17, 0x35, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0x48, 0x89,
	0x05, 0xAB, 0xDA, 0xFF, 0xFF, 0xFF, 0x15, 0x75, 0xC9, 0xFF, 0xFF, 0x48, 0x8D, 0x4C, 0x24, 0x20,
	0xFF, 0x15, 0xDA, 0xC9, 0xFF, 0xFF, 0x48, 0x8D, 0x15, 0x23, 0x35, 0x00, 0x00, 0x48, 0x8D, 0x4C,
	0x24, 0x20, 0x48, 0x89, 0x05, 0x9F, 0xDA, 0xFF, 0xFF, 0xFF, 0x15, 0x51, 0xC9, 0xFF, 0xFF, 0x48,
	0x8D, 0x4C, 0x24, 0x20, 0xFF, 0x15, 0xB6, 0xC9, 0xFF, 0xFF, 0x48, 0x8D, 0x15, 0x4F, 0x35, 0x00,
	0x00, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0x48, 0x89, 0x05, 0x93, 0xDA, 0xFF, 0xFF, 0xFF, 0x15, 0x2D,
	0xC9, 0xFF, 0xFF, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0xFF, 0x15, 0x92, 0xC9, 0xFF, 0xFF, 0x48, 0x8D,
	0x15, 0x4B, 0x35, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0x48, 0x89, 0x05, 0x47, 0xDA, 0xFF,
	0xFF, 0xFF, 0x15, 0x09, 0xC9, 0xFF, 0xFF, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0xFF, 0x15, 0x6E, 0xC9,
	0xFF, 0xFF, 0x48, 0x89, 0x05, 0x4F, 0xDA, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x28, 0x8B, 0x15, 0xC2, 0xDA, 0xFF, 0xFF, 0x8D, 0x42,
	0xCD, 0x83, 0xF8, 0x09, 0x77, 0x06, 0x48, 0x8B, 0x41, 0xE0, 0xEB, 0x17, 0x83, 0xFA, 0x3D, 0x72,
	0x10, 0x48, 0x8B, 0x05, 0x08, 0xDA, 0xFF, 0xFF, 0x48, 0x85, 0xC0, 0x74, 0x04, 0xFF, 0xD0, 0xEB,
	0x02, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0x48, 0x89, 0x5C, 0x24, 0x08, 0x4C, 0x89, 0x44, 0x24, 0x18, 0x57, 0x48, 0x83, 0xEC, 0x40, 0x49,
	0x8B, 0xF8, 0x48, 0x8B, 0xC2, 0x4C, 0x8B, 0xD1, 0x4C, 0x8B, 0x01, 0x44, 0x8B, 0x1D, 0x6E, 0xDA,
	0xFF, 0xFF, 0x41, 0x83, 0xFB, 0x3E, 0x72, 0x20, 0x8B, 0x0D, 0x9E, 0xD9, 0xFF, 0xFF, 0x83, 0xF9,
	0xFF, 0x74, 0x0E, 0x49, 0x8B, 0xD0, 0x48, 0xD3, 0xFA, 0x48, 0x83, 0xE2, 0xF0, 0x33, 0xDB, 0xEB,
	0x10, 0x33, 0xDB, 0x48, 0x8B, 0xD3, 0xEB, 0x09, 0x49, 0x8B, 0xD0, 0x48, 0x83, 0xE2, 0xF8, 0x33,
	0xDB, 0x48, 0x89, 0x44, 0x24, 0x20, 0x48, 0x8D, 0x42, 0x30, 0x48, 0xF7, 0xDA, 0x4D, 0x1B, 0xC9,
	0x4C, 0x23, 0xC8, 0x4C, 0x89, 0x4C, 0x24, 0x28, 0x41, 0x8B, 0x4A, 0x08, 0x8B, 0xC1, 0x0F, 0xBA,
	0xF0, 0x19, 0x89, 0x44, 0x24, 0x30, 0xB8, 0xFF, 0xFF, 0x00, 0x00, 0x66, 0x89, 0x44, 0x24, 0x34,
	0x66, 0x89, 0x5C, 0x24, 0x36, 0x41, 0x83, 0xFB, 0x3E, 0x72, 0x1F, 0x8B, 0x0D, 0x3F, 0xD9, 0xFF,
	0xFF, 0x83, 0xF9, 0xFF, 0x74, 0x0E, 0x49, 0xD3, 0xE8, 0x41, 0x83, 0xE0, 0x03, 0x44, 0x89, 0x44,
	0x24, 0x38, 0xEB, 0x18, 0x89, 0x5C, 0x24, 0x38, 0xEB, 0x12, 0xC1, 0xE9, 0x19, 0x83, 0xE1, 0x01,
	0x41, 0x8B, 0xC0, 0x83, 0xE0, 0x06, 0x0B, 0xC8, 0x89, 0x4C, 0x24, 0x38, 0x89, 0x5C, 0x24, 0x3C,
	0x4C, 0x3B, 0xCB, 0x74, 0x35, 0x49, 0x8B, 0xC9, 0xE8, 0xF7, 0xFE, 0xFF, 0xFF, 0x48, 0x3B, 0xC3,
	0x74, 0x28, 0x8B, 0x0D, 0xF0, 0xD8, 0xFF, 0xFF, 0x83, 0xF9, 0xFF, 0x74, 0x1D, 0x83, 0x3D, 0xAC,
	0xD9, 0xFF, 0xFF, 0x3D, 0x72, 0x0B, 0x0F, 0xB6, 0x04, 0x01, 0x66, 0x89, 0x44, 0x24, 0x34, 0xEB,
	0x09, 0x0F, 0xB7, 0x0C, 0x01, 0x66, 0x89, 0x4C, 0x24, 0x34, 0x48, 0x8B, 0x4F, 0x10, 0x48, 0x8D,
	0x41, 0x20, 0x48, 0x89, 0x47, 0x10, 0xFF, 0x47, 0x18, 0x48, 0x3B, 0x0F, 0x72, 0x29, 0x48, 0x3B,
	0x47, 0x08, 0x77, 0x23, 0x48, 0x8D, 0x54, 0x24, 0x20, 0x41, 0xB8, 0x20, 0x00, 0x00, 0x00, 0xE8,
	0x8C, 0xB6, 0xFF, 0xFF, 0xEB, 0x0F, 0x48, 0x8B, 0x4C, 0x24, 0x60, 0x33, 0xDB, 0x39, 0x59, 0x1C,
	0x75, 0x03, 0x89, 0x41, 0x1C, 0xEB, 0x0C, 0x39, 0x5F, 0x1C, 0x75, 0x07, 0xC7, 0x47, 0x1C, 0x23,
	0x00, 0x00, 0xC0, 0x32, 0xC0, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x40, 0x5F, 0xC3,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x74,
	0x24, 0x10, 0x57, 0x48, 0x83, 0xEC, 0x20, 0x49, 0x8B, 0xC0, 0x48, 0x8B, 0xDA, 0x48, 0x8B, 0xF9,
	0x48, 0x8B, 0xD0, 0x48, 0x8B, 0xCB, 0x4D, 0x8B, 0xC1, 0xE8, 0x82, 0xFE, 0xFF, 0xFF, 0x41, 0xB8,
	0x01, 0x00, 0x00, 0x00, 0x40, 0x8A, 0xF0, 0xF0, 0x4C, 0x0F, 0xC1, 0x03, 0x8B, 0x0D, 0x2E, 0xD8,
	0xFF, 0xFF, 0x48, 0x03, 0xCF, 0x48, 0x83, 0x39, 0x00, 0x74, 0x08, 0x33, 0xD2, 0xFF, 0x15, 0x5D,
	0xD8, 0xFF, 0xFF, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x40, 0x8A, 0xC6, 0x48, 0x8B, 0x74, 0x24, 0x38,
	0x48, 0x83, 0xC4, 0x20, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x8B, 0xC4, 0x48,
	0x89, 0x58, 0x08, 0x48, 0x89, 0x70, 0x10, 0x48, 0x89, 0x78, 0x18, 0x4C, 0x89, 0x60, 0x20, 0x41,
	0x56, 0x48, 0x83, 0xEC, 0x60, 0x4D, 0x8B, 0xE1, 0x45, 0x8B, 0xF0, 0x48, 0x8B, 0xF2, 0x48, 0x8B,
	0xD9, 0x83, 0x3D, 0xA8, 0xD8, 0xFF, 0xFF, 0x3E, 0x72, 0x1D, 0x48, 0x83, 0x3D, 0x0E, 0xD8, 0xFF,
	0xFF, 0x00, 0x74, 0x09, 0x83, 0x3D, 0xC5, 0xD7, 0xFF, 0xFF, 0xFF, 0x75, 0x0A, 0xB8, 0xBB, 0x00,
	0x00, 0xC0, 0xE9, 0x7A, 0x01, 0x00, 0x00, 0x80, 0xBC, 0x24, 0x90, 0x00, 0x00, 0x00, 0x00, 0x74,
	0x2F, 0x49, 0x8B, 0xD6, 0xBF, 0x04, 0x00, 0x00, 0x00, 0x44, 0x8B, 0xC7, 0x48, 0x8B, 0xCE, 0xFF,
	0x15, 0x9B, 0xC6, 0xFF, 0xFF, 0x4D, 0x85, 0xE4, 0x74, 0x0F, 0x44, 0x8B, 0xC7, 0x48, 0x8B, 0xD7,
	0x49, 0x8B, 0xCC, 0xFF, 0x15, 0x87, 0xC6, 0xFF, 0xFF, 0xEB, 0x05, 0xE9, 0x41, 0x01, 0x00, 0x00,
	0x48, 0x83, 0x64, 0x24, 0x28, 0x00, 0x48, 0x8D, 0x44, 0x24, 0x30, 0x48, 0x89, 0x44, 0x24, 0x20,
	0x44, 0x8A, 0x8C, 0x24, 0x90, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0x05, 0xC9, 0xC6, 0xFF, 0xFF, 0x4D,
	0x8B, 0x00, 0x33, 0xD2, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0x0B, 0xC7, 0xFF, 0xFF, 0x85, 0xC0, 0x0F,
	0x88, 0x0C, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x33, 0xFF, 0x83, 0x3D, 0x31, 0xD7,
	0xFF, 0xFF, 0xFF, 0x0F, 0x84, 0xEA, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xCB, 0xE8, 0x53, 0xB3, 0xFF,
	0xFF, 0x84, 0xC0, 0x74, 0x17, 0x8B, 0x05, 0x19, 0xD7, 0xFF, 0xFF, 0x48, 0x8B, 0x3C, 0x18, 0x48,
	0x85, 0xFF, 0x75, 0x08, 0x48, 0x8B, 0xCB, 0xE8, 0x84, 0xB3, 0xFF, 0xFF, 0x48, 0x85, 0xFF, 0x75,
	0x0A, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0xE9, 0xB8, 0x00, 0x00, 0x00, 0x48, 0x89, 0x74, 0x24, 0x38,
	0x4A, 0x8D, 0x04, 0x36, 0x48, 0x89, 0x44, 0x24, 0x40, 0x48, 0x8D, 0x46, 0x08, 0x48, 0x89, 0x44,
	0x24, 0x48, 0x83, 0x64, 0x24, 0x50, 0x00, 0x83, 0x64, 0x24, 0x54, 0x00, 0x83, 0x3D, 0xAD, 0xD7,
	0xFF, 0xFF, 0x3E, 0x72, 0x1A, 0x45, 0x33, 0xC9, 0x4C, 0x8D, 0x44, 0x24, 0x38, 0x48, 0x8D, 0x15,
	0x64, 0xFE, 0xFF, 0xFF, 0x48, 0x8B, 0xCF, 0xFF, 0x15, 0x53, 0xC6, 0xFF, 0xFF, 0xEB, 0x18, 0x45,
	0x33, 0xC9, 0x4C, 0x8D, 0x44, 0x24, 0x38, 0x48, 0x8D, 0x15, 0xF2, 0xFC, 0xFF, 0xFF, 0x48, 0x8B,
	0xCF, 0xFF, 0x15, 0x39, 0xC6, 0xFF, 0xFF, 0x48, 0x8B, 0x4C, 0x24, 0x30, 0xE8, 0x0F, 0xB3, 0xFF,
	0xFF, 0x48, 0x8B, 0x4C, 0x24, 0x30, 0xFF, 0x15, 0x74, 0xC6, 0xFF, 0xFF, 0x41, 0x83, 0xFE, 0x08,
	0x72, 0x1A, 0x80, 0xBC, 0x24, 0x90, 0x00, 0x00, 0x00, 0x00, 0x74, 0x0A, 0x8B, 0x44, 0x24, 0x50,
	0x89, 0x06, 0xEB, 0x08, 0xEB, 0x3B, 0x8B, 0x44, 0x24, 0x50, 0x89, 0x06, 0x4D, 0x85, 0xE4, 0x74,
	0x1C, 0x8B, 0x44, 0x24, 0x48, 0x2B, 0xC6, 0x80, 0xBC, 0x24, 0x90, 0x00, 0x00, 0x00, 0x00, 0x74,
	0x08, 0x41, 0x89, 0x04, 0x24, 0xEB, 0x06, 0xEB, 0x18, 0x41, 0x89, 0x04, 0x24, 0x8B, 0x44, 0x24,
	0x54, 0xEB, 0x0E, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0x24, 0xC6, 0xFF, 0xFF, 0xB8, 0x01, 0x00, 0x00,
	0xC0, 0x4C, 0x8D, 0x5C, 0x24, 0x60, 0x49, 0x8B, 0x5B, 0x10, 0x49, 0x8B, 0x73, 0x18, 0x49, 0x8B,
	0x7B, 0x20, 0x4D, 0x8B, 0x63, 0x28, 0x49, 0x8B, 0xE3, 0x41, 0x5E, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x6C, 0x24, 0x10, 0x48, 0x89,
	0x74, 0x24, 0x20, 0x57, 0x41, 0x54, 0x41, 0x55, 0x41, 0x56, 0x41, 0x57, 0x48, 0x83, 0xEC, 0x20,
	0xBF, 0x10, 0x00, 0x00, 0x00, 0x4D, 0x8B, 0xF1, 0x45, 0x8B, 0xF8, 0x4C, 0x8B, 0xE2, 0x48, 0x8B,
	0xF1, 0x44, 0x3B, 0xC7, 0x73, 0x0D, 0x41, 0x89, 0x39, 0xB8, 0x23, 0x00, 0x00, 0xC0, 0xE9, 0xB2,
	0x00, 0x00, 0x00, 0x33, 0xDB, 0x4C, 0x8D, 0x6A, 0x10, 0x4C, 0x89, 0x6A, 0x08, 0x66, 0x89, 0x1A,
	0x48, 0x8B, 0x49, 0x08, 0x48, 0x3B, 0xCB, 0x74, 0x38, 0x4C, 0x8D, 0x4C, 0x24, 0x60, 0xFF, 0x15,
	0x54, 0xC5, 0xFF, 0xFF, 0x3B, 0xC3, 0x44, 0x8B, 0xD8, 0x7D, 0x1C, 0xB8, 0x23, 0x00, 0x00, 0xC0,
	0x41, 0x81, 0xFB, 0x04, 0x00, 0x00, 0xC0, 0x44, 0x0F, 0x44, 0xD8, 0x8B, 0x44, 0x24, 0x60, 0x41,
	0x89, 0x06, 0x41, 0x8B, 0xC3, 0xEB, 0x6E, 0x41, 0x0F, 0xB7, 0x04, 0x24, 0x4C, 0x03, 0xE8, 0x03,
	0xF8, 0x48, 0x39, 0x5E, 0x60, 0x74, 0x59, 0x48, 0x8B, 0xCE, 0x8B, 0xEB, 0x0F, 0xB7, 0x41, 0x58,
	0x03, 0xE8, 0x48, 0x8B, 0x41, 0x40, 0x48, 0x3B, 0xC8, 0x74, 0x08, 0x48, 0x8B, 0xC8, 0x48, 0x3B,
	0xC3, 0x75, 0xE9, 0x03, 0xFD, 0x41, 0x3B, 0xFF, 0x76, 0x07, 0xBB, 0x23, 0x00, 0x00, 0xC0, 0xEB,
	0x2F, 0x8B, 0xC5, 0x4C, 0x03, 0xE8, 0x44, 0x0F, 0xB7, 0x46, 0x58, 0x48, 0x8B, 0x56, 0x60, 0x4D,
	0x2B, 0xE8, 0x49, 0x8B, 0xCD, 0xE8, 0x36, 0xB3, 0xFF, 0xFF, 0x4C, 0x8B, 0x5E, 0x40, 0x49, 0x3B,
	0xF3, 0x74, 0x08, 0x49, 0x8B, 0xF3, 0x4C, 0x3B, 0xDB, 0x75, 0xDB, 0x66, 0x41, 0x01, 0x2C, 0x24,
	0x41, 0x89, 0x3E, 0x8B, 0xC3, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x8B, 0x6C, 0x24, 0x58, 0x48,
	0x8B, 0x74, 0x24, 0x68, 0x48, 0x83, 0xC4, 0x20, 0x41, 0x5F, 0x41, 0x5E, 0x41, 0x5D, 0x41, 0x5C,
	0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x89, 0x5C, 0x24, 0x18, 0x56, 0x57, 0x41,
	0x54, 0x41, 0x55, 0x41, 0x56, 0x48, 0x81, 0xEC, 0xF0, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x05, 0xCD,
	0xD4, 0xFF, 0xFF, 0x48, 0x33, 0xC4, 0x48, 0x89, 0x84, 0x24, 0xE0, 0x00, 0x00, 0x00, 0x4D, 0x8B,
	0xE1, 0x41, 0x8B, 0xD8, 0x48, 0x8B, 0xFA, 0x4C, 0x8B, 0xF1, 0x4C, 0x8B, 0xAC, 0x24, 0x48, 0x01,
	0x00, 0x00, 0x4C, 0x89, 0x6C, 0x24, 0x70, 0x80, 0xBC, 0x24, 0x50, 0x01, 0x00, 0x00, 0x00, 0x74,
	0x36, 0x8B, 0xB4, 0x24, 0x40, 0x01, 0x00, 0x00, 0x48, 0x8B, 0xD6, 0x41, 0xB8, 0x04, 0x00, 0x00,
	0x00, 0x49, 0x8B, 0xC9, 0xFF, 0x15, 0xA6, 0xC3, 0xFF, 0xFF, 0x4D, 0x85, 0xED, 0x74, 0x11, 0xBA,
	0x04, 0x00, 0x00, 0x00, 0x44, 0x8B, 0xC2, 0x49, 0x8B, 0xCD, 0xFF, 0x15, 0x90, 0xC3, 0xFF, 0xFF,
	0xEB, 0x0C, 0xE9, 0x73, 0x08, 0x00, 0x00, 0x8B, 0xB4, 0x24, 0x40, 0x01, 0x00, 0x00, 0x48, 0x83,
	0x64, 0x24, 0x28, 0x00, 0x48, 0x8D, 0x44, 0x24, 0x48, 0x48, 0x89, 0x44, 0x24, 0x20, 0x44, 0x8A,
	0x8C, 0x24, 0x50, 0x01, 0x00, 0x00, 0x4C, 0x8B, 0x05, 0xCB, 0xC3, 0xFF, 0xFF, 0x4D, 0x8B, 0x00,
	0x33, 0xD2, 0x49, 0x8B, 0xCE, 0xFF, 0x15, 0x0D, 0xC4, 0xFF, 0xFF, 0x85, 0xC0, 0x0F, 0x88, 0x37,
	0x08, 0x00, 0x00, 0x48, 0x8B, 0x05, 0x0E, 0xC4, 0xFF, 0xFF, 0x48, 0x8B, 0x08, 0x48, 0x39, 0x4C,
	0x24, 0x48, 0x75, 0x0C, 0x48, 0x81, 0xCF, 0x00, 0x00, 0x00, 0x80, 0x45, 0x32, 0xED, 0xEB, 0x22,
	0x48, 0x85, 0xFF, 0x79, 0x15, 0x48, 0x8B, 0x4C, 0x24, 0x48, 0xFF, 0x15, 0x00, 0xC4, 0xFF, 0xFF,
	0xB8, 0x08, 0x00, 0x00, 0xC0, 0xE9, 0x00, 0x08, 0x00, 0x00, 0x44, 0x8A, 0xAC, 0x24, 0x50, 0x01,
	0x00, 0x00, 0x85, 0xDB, 0x0F, 0x84, 0x3F, 0x07, 0x00, 0x00, 0x41, 0xBE, 0x01, 0x00, 0x00, 0x00,
	0x41, 0x2B, 0xDE, 0x0F, 0x84, 0xE5, 0x05, 0x00, 0x00, 0x41, 0x2B, 0xDE, 0x0F, 0x84, 0x07, 0x05,
	0x00, 0x00, 0x41, 0x2B, 0xDE, 0x0F, 0x84, 0x8C, 0x04, 0x00, 0x00, 0x41, 0x2B, 0xDE, 0x0F, 0x84,
	0x07, 0x04, 0x00, 0x00, 0x41, 0x2B, 0xDE, 0x0F, 0x84, 0x82, 0x03, 0x00, 0x00, 0x41, 0x2B, 0xDE,
	0x0F, 0x84, 0x0F, 0x02, 0x00, 0x00, 0x41, 0x2B, 0xDE, 0x0F, 0x84, 0xF9, 0x00, 0x00, 0x00, 0x41,
	0x3B, 0xDE, 0x74, 0x13, 0xBF, 0x03, 0x00, 0x00, 0xC0, 0x89, 0x7C, 0x24, 0x40, 0x83, 0x64, 0x24,
	0x44, 0x00, 0xE9, 0x59, 0x07, 0x00, 0x00, 0x83, 0xFE, 0x08, 0x0F, 0x85, 0xCA, 0x00, 0x00, 0x00,
	0x48, 0x8D, 0x54, 0x24, 0x78, 0x48, 0x8B, 0x4C, 0x24, 0x48, 0xFF, 0x15, 0x90, 0xC3, 0xFF, 0xFF,
	0x48, 0x83, 0x64, 0x24, 0x28, 0x00, 0x48, 0x8D, 0x44, 0x24, 0x60, 0x48, 0x89, 0x44, 0x24, 0x20,
	0x45, 0x8A, 0xCD, 0x4C, 0x8B, 0x05, 0x16, 0xC3, 0xFF, 0xFF, 0x4D, 0x8B, 0x00, 0x33, 0xD2, 0x48,
	0x8B, 0xCF, 0xFF, 0x15, 0x20, 0xC3, 0xFF, 0xFF, 0x8B, 0xF8, 0x89, 0x44, 0x24, 0x40, 0x48, 0x8D,
	0x4C, 0x24, 0x78, 0xFF, 0x15, 0xDF, 0xC2, 0xFF, 0xFF, 0x85, 0xFF, 0x0F, 0x88, 0xFF, 0x06, 0x00,
	0x00, 0x48, 0x8B, 0x4C, 0x24, 0x60, 0x48, 0x83, 0x79, 0x08, 0x00, 0x74, 0x46, 0x48, 0x8B, 0x49,
	0x08, 0x48, 0x8B, 0x49, 0x08, 0x48, 0x85, 0xC9, 0x74, 0x39, 0x48, 0x8D, 0x44, 0x24, 0x50, 0x48,
	0x89, 0x44, 0x24, 0x30, 0xC6, 0x44, 0x24, 0x28, 0x00, 0x48, 0x8B, 0x05, 0xC8, 0xC2, 0xFF, 0xFF,
	0x48, 0x8B, 0x10, 0x48, 0x89, 0x54, 0x24, 0x20, 0x45, 0x33, 0xC9, 0x45, 0x33, 0xC0, 0x33, 0xD2,
	0xFF, 0x15, 0x02, 0xC3, 0xFF, 0xFF, 0x8B, 0xF8, 0x89, 0x44, 0x24, 0x40, 0x48, 0x8B, 0x44, 0x24,
	0x50, 0xEB, 0x07, 0x33, 0xC0, 0x48, 0x89, 0x44, 0x24, 0x50, 0x85, 0xFF, 0x78, 0x0C, 0x49, 0x89,
	0x04, 0x24, 0xEB, 0x06, 0x8B, 0xF8, 0x89, 0x44, 0x24, 0x40, 0x48, 0x8B, 0x4C, 0x24, 0x60, 0xFF,
	0x15, 0xBB, 0xC2, 0xFF, 0xFF, 0xE9, 0x86, 0x06, 0x00, 0x00, 0xBF, 0x04, 0x00, 0x00, 0xC0, 0x89,
	0x7C, 0x24, 0x40, 0xE9, 0x78, 0x06, 0x00, 0x00, 0x48, 0x8D, 0x54, 0x24, 0x78, 0x48, 0x8B, 0x4C,
	0x24, 0x48, 0xFF, 0x15, 0xB8, 0xC2, 0xFF, 0xFF, 0x48, 0x83, 0x64, 0x24, 0x28, 0x00, 0x48, 0x8D,
	0x44, 0x24, 0x60, 0x48, 0x89, 0x44, 0x24, 0x20, 0x45, 0x8A, 0xCD, 0x4C, 0x8B, 0x05, 0x3E, 0xC2,
	0xFF, 0xFF, 0x4D, 0x8B, 0x00, 0x33, 0xD2, 0x48, 0x8B, 0xCF, 0xFF, 0x15, 0x48, 0xC2, 0xFF, 0xFF,
	0x8B, 0xF8, 0x89, 0x44, 0x24, 0x40, 0x48, 0x8D, 0x4C, 0x24, 0x78, 0xFF, 0x15, 0x07, 0xC2, 0xFF,
	0xFF, 0x85, 0xFF, 0x0F, 0x88, 0xAF, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x60, 0x8A, 0x41,
	0x48, 0x88, 0x84, 0x24, 0xA8, 0x00, 0x00, 0x00, 0x8A, 0x41, 0x49, 0x88, 0x84, 0x24, 0xA9, 0x00,
	0x00, 0x00, 0x8A, 0x41, 0x4A, 0x88, 0x84, 0x24, 0xAA, 0x00, 0x00, 0x00, 0x8A, 0x41, 0x4B, 0x88,
	0x84, 0x24, 0xAB, 0x00, 0x00, 0x00, 0x8A, 0x41, 0x4C, 0x88, 0x84, 0x24, 0xAC, 0x00, 0x00, 0x00,
	0x8A, 0x41, 0x4D, 0x88, 0x84, 0x24, 0xAD, 0x00, 0x00, 0x00, 0x8A, 0x41, 0x4E, 0x88, 0x84, 0x24,
	0xAE, 0x00, 0x00, 0x00, 0x8A, 0x41, 0x4F, 0x88, 0x84, 0x24, 0xAF, 0x00, 0x00, 0x00, 0x48, 0x8B,
	0x41, 0x68, 0x48, 0x89, 0x84, 0x24, 0xB0, 0x00, 0x00, 0x00, 0x8B, 0x41, 0x50, 0x89, 0x84, 0x24,
	0xB8, 0x00, 0x00, 0x00, 0x83, 0xFE, 0x18, 0x75, 0x30, 0x48, 0x8D, 0x94, 0x24, 0xA8, 0x00, 0x00,
	0x00, 0x48, 0x8B, 0x02, 0x49, 0x89, 0x04, 0x24, 0x48, 0x8B, 0x42, 0x08, 0x49, 0x89, 0x44, 0x24,
	0x08, 0x48, 0x8B, 0x42, 0x10, 0x49, 0x89, 0x44, 0x24, 0x10, 0xEB, 0x0B, 0x8B, 0xF8, 0x89, 0x44,
	0x24, 0x40, 0x48, 0x8B, 0x4C, 0x24, 0x60, 0xEB, 0x09, 0xBF, 0x04, 0x00, 0x00, 0xC0, 0x89, 0x7C,
	0x24, 0x40, 0xFF, 0x15, 0xA8, 0xC1, 0xFF, 0xFF, 0xC7, 0x44, 0x24, 0x44, 0x18, 0x00, 0x00, 0x00,
	0xE9, 0x6B, 0x05, 0x00, 0x00, 0x83, 0xC8, 0xFF, 0x39, 0x05, 0xA2, 0xD1, 0xFF, 0xFF, 0x0F, 0x84,
	0x45, 0x01, 0x00, 0x00, 0x39, 0x05, 0xA2, 0xD1, 0xFF, 0xFF, 0x0F, 0x84, 0x39, 0x01, 0x00, 0x00,
	0x39, 0x05, 0x9E, 0xD1, 0xFF, 0xFF, 0x0F, 0x84, 0x2D, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x54, 0x24,
	0x78, 0x48, 0x8B, 0x4C, 0x24, 0x48, 0xFF, 0x15, 0x84, 0xC1, 0xFF, 0xFF, 0x48, 0x83, 0x64, 0x24,
	0x28, 0x00, 0x48, 0x8D, 0x44, 0x24, 0x50, 0x48, 0x89, 0x44, 0x24, 0x20, 0x45, 0x8A, 0xCD, 0x45,
	0x33, 0xC0, 0x33, 0xD2, 0x48, 0x8B, 0xCF, 0xFF, 0x15, 0x1B, 0xC1, 0xFF, 0xFF, 0x8B, 0xF8, 0x89,
	0x44, 0x24, 0x40, 0x48, 0x8D, 0x4C, 0x24, 0x78, 0xFF, 0x15, 0xDA, 0xC0, 0xFF, 0xFF, 0x85, 0xFF,
	0x0F, 0x88, 0xEC, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x50, 0xE8, 0x44, 0xF7, 0xFF, 0xFF,
	0x48, 0x85, 0xC0, 0x74, 0x3B, 0x8B, 0x1D, 0x39, 0xD1, 0xFF, 0xFF, 0x48, 0x03, 0xD8, 0x48, 0x8D,
	0x15, 0x7B, 0x2C, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x60, 0xFF, 0x15, 0x10, 0xC0, 0xFF, 0xFF,
	0x45, 0x33, 0xC0, 0x48, 0x8D, 0x54, 0x24, 0x60, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0x8F, 0xC0, 0xFF,
	0xFF, 0x84, 0xC0, 0x75, 0x14, 0xBF, 0x24, 0x00, 0x00, 0xC0, 0x89, 0x7C, 0x24, 0x40, 0xEB, 0x09,
	0xBF, 0xBB, 0x00, 0x00, 0xC0, 0x89, 0x7C, 0x24, 0x40, 0x85, 0xFF, 0x78, 0x7F, 0x8B, 0x0D, 0xE9,
	0xD0, 0xFF, 0xFF, 0x48, 0x8B, 0x44, 0x24, 0x50, 0x48, 0x8B, 0x14, 0x01, 0x48, 0x85, 0xD2, 0x74,
	0x16, 0x8B, 0x05, 0xC9, 0xD0, 0xFF, 0xFF, 0xF3, 0x0F, 0x6F, 0x04, 0x10, 0xF3, 0x0F, 0x7F, 0x84,
	0x24, 0xA8, 0x00, 0x00, 0x00, 0xEB, 0x13, 0x33, 0xD2, 0x44, 0x8D, 0x42, 0x10, 0x48, 0x8D, 0x8C,
	0x24, 0xA8, 0x00, 0x00, 0x00, 0xE8, 0x16, 0xB3, 0xFF, 0xFF, 0x48, 0x83, 0xA4, 0x24, 0xB8, 0x00,
	0x00, 0x00, 0x00, 0x83, 0xFE, 0x18, 0x75, 0x2B, 0x48, 0x8D, 0x8C, 0x24, 0xA8, 0x00, 0x00, 0x00,
	0x48, 0x8B, 0x01, 0x49, 0x89, 0x04, 0x24, 0x48, 0x8B, 0x41, 0x08, 0x49, 0x89, 0x44, 0x24, 0x08,
	0x48, 0x8B, 0x41, 0x10, 0x49, 0x89, 0x44, 0x24, 0x10, 0xEB, 0x06, 0x8B, 0xF8, 0x89, 0x44, 0x24,
	0x40, 0xEB, 0x09, 0xBF, 0x04, 0x00, 0x00, 0xC0, 0x89, 0x7C, 0x24, 0x40, 0x48, 0x8B, 0x4C, 0x24,
	0x50, 0xFF, 0x15, 0x49, 0xC0, 0xFF, 0xFF, 0xEB, 0x09, 0xBF, 0xBB, 0x00, 0x00, 0xC0, 0x89, 0x7C,
	0x24, 0x40, 0xC7, 0x44, 0x24, 0x44, 0x18, 0x00, 0x00, 0x00, 0xE9, 0x01, 0x04, 0x00, 0x00, 0x48,
	0x8D, 0x54, 0x24, 0x78, 0x48, 0x8B, 0x4C, 0x24, 0x48, 0xFF, 0x15, 0x41, 0xC0, 0xFF, 0xFF, 0x48,
	0x83, 0x64, 0x24, 0x20, 0x00, 0x41, 0xB9, 0x30, 0x00, 0x00, 0x00, 0x4C, 0x8D, 0x84, 0x24, 0xA8,
	0x00, 0x00, 0x00, 0x33, 0xD2, 0x48, 0x8B, 0xCF, 0xFF, 0x15, 0x12, 0xC0, 0xFF, 0xFF, 0x8B, 0xF8,
	0x89, 0x44, 0x24, 0x40, 0x48, 0x8D, 0x4C, 0x24, 0x78, 0xFF, 0x15, 0x99, 0xBF, 0xFF, 0xFF, 0x85,
	0xFF, 0x78, 0x2B, 0x83, 0xFE, 0x30, 0x75, 0x1D, 0x49, 0x8B, 0xCC, 0x48, 0x8D, 0x94, 0x24, 0xA8,
	0x00, 0x00, 0x00, 0x44, 0x8B, 0xC6, 0xE8, 0xE5, 0xAD, 0xFF, 0xFF, 0xEB, 0x06, 0x8B, 0xF8, 0x89,
	0x44, 0x24, 0x40, 0xEB, 0x09, 0xBF, 0x04, 0x00, 0x00, 0xC0, 0x89, 0x7C, 0x24, 0x40, 0xC7, 0x44,
	0x24, 0x44, 0x30, 0x00, 0x00, 0x00, 0xE9, 0x85, 0x03, 0x00, 0x00, 0x48, 0x8D, 0x54, 0x24, 0x78,
	0x48, 0x8B, 0x4C, 0x24, 0x48, 0xFF, 0x15, 0xC5, 0xBF, 0xFF, 0xFF, 0x48, 0x83, 0x64, 0x24, 0x20,
	0x00, 0x41, 0xB9, 0x30, 0x00, 0x00, 0x00, 0x4C, 0x8D, 0x84, 0x24, 0xA8, 0x00, 0x00, 0x00, 0x33,
	0xD2, 0x48, 0x8B, 0xCF, 0xFF, 0x15, 0x7E, 0xBF, 0xFF, 0xFF, 0x8B, 0xF8, 0x89, 0x44, 0x24, 0x40,
	0x48, 0x8D, 0x4C, 0x24, 0x78, 0xFF, 0x15, 0x1D, 0xBF, 0xFF, 0xFF, 0x85, 0xFF, 0x78, 0x2B, 0x83,
	0xFE, 0x30, 0x75, 0x1D, 0x49, 0x8B, 0xCC, 0x48, 0x8D, 0x94, 0x24, 0xA8, 0x00, 0x00, 0x00, 0x44,
	0x8B, 0xC6, 0xE8, 0x69, 0xAD, 0xFF, 0xFF, 0xEB, 0x06, 0x8B, 0xF8, 0x89, 0x44, 0x24, 0x40, 0xEB,
	0x09, 0xBF, 0x04, 0x00, 0x00, 0xC0, 0x89, 0x7C, 0x24, 0x40, 0xC7, 0x44, 0x24, 0x44, 0x30, 0x00,
	0x00, 0x00, 0xE9, 0x09, 0x03, 0x00, 0x00, 0x48, 0x8D, 0x54, 0x24, 0x78, 0x48, 0x8B, 0x4C, 0x24,
	0x48, 0xFF, 0x15, 0x49, 0xBF, 0xFF, 0xFF, 0x48, 0x83, 0x64, 0x24, 0x20, 0x00, 0x41, 0xB9, 0x02,
	0x00, 0x00, 0x00, 0x4C, 0x8D, 0x44, 0x24, 0x58, 0x41, 0x8D, 0x51, 0x02, 0x48, 0x8B, 0xCF, 0xFF,
	0x15, 0xA3, 0xBE, 0xFF, 0xFF, 0x8B, 0xF8, 0x89, 0x44, 0x24, 0x40, 0x48, 0x8D, 0x4C, 0x24, 0x78,
	0xFF, 0x15, 0xA2, 0xBE, 0xFF, 0xFF, 0x85, 0xFF, 0x78, 0x22, 0x83, 0xFE, 0x02, 0x75, 0x14, 0x0F,
	0xB7, 0x44, 0x24, 0x58, 0x66, 0x41, 0x89, 0x04, 0x24, 0xEB, 0x06, 0x8B, 0xF8, 0x89, 0x44, 0x24,
	0x40, 0xEB, 0x09, 0xBF, 0x04, 0x00, 0x00, 0xC0, 0x89, 0x7C, 0x24, 0x40, 0xC7, 0x44, 0x24, 0x44,
	0x02, 0x00, 0x00, 0x00, 0xE9, 0x97, 0x02, 0x00, 0x00, 0xBA, 0x68, 0x00, 0x00, 0x00, 0x89, 0x54,
	0x24, 0x44, 0x8B, 0xC6, 0x3B, 0xF2, 0x0F, 0x42, 0xC2, 0x8D, 0x50, 0x08, 0x41, 0xB8, 0x4B, 0x70,
	0x68, 0x51, 0x41, 0x8B, 0xCE, 0xFF, 0x15, 0xAD, 0xBE, 0xFF, 0xFF, 0x48, 0x8B, 0xD8, 0x48, 0x89,
	0x44, 0x24, 0x60, 0x48, 0x85, 0xC0, 0x0F, 0x84, 0x94, 0x00, 0x00, 0x00, 0x44, 0x8B, 0xEE, 0x44,
	0x8B, 0xC6, 0x33, 0xD2, 0x48, 0x8B, 0xC8, 0xE8, 0x04, 0xB1, 0xFF, 0xFF, 0x48, 0x8D, 0x54, 0x24,
	0x78, 0x48, 0x8B, 0x4C, 0x24, 0x48, 0xFF, 0x15, 0x94, 0xBE, 0xFF, 0xFF, 0x4C, 0x8D, 0x5C, 0x24,
	0x44, 0x4C, 0x89, 0x5C, 0x24, 0x20, 0x44, 0x8B, 0xCE, 0x4C, 0x8B, 0xC3, 0xBA, 0x02, 0x00, 0x00,
	0x00, 0x48, 0x8B, 0xCF, 0xFF, 0x15, 0xEE, 0xBD, 0xFF, 0xFF, 0x8B, 0xF8, 0x89, 0x44, 0x24, 0x40,
	0x48, 0x8D, 0x4C, 0x24, 0x78, 0xFF, 0x15, 0xED, 0xBD, 0xFF, 0xFF, 0x85, 0xFF, 0x78, 0x2E, 0x48,
	0x8B, 0x43, 0x08, 0x48, 0x85, 0xC0, 0x74, 0x0A, 0x48, 0x2B, 0xC3, 0x49, 0x03, 0xC4, 0x48, 0x89,
	0x43, 0x08, 0x4D, 0x8B, 0xC5, 0x48, 0x8B, 0xD3, 0x49, 0x8B, 0xCC, 0xE8, 0x30, 0xAC, 0xFF, 0xFF,
	0xEB, 0x0B, 0x8B, 0xF8, 0x89, 0x44, 0x24, 0x40, 0x48, 0x8B, 0x5C, 0x24, 0x60, 0xBA, 0x4B, 0x70,
	0x68, 0x51, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0x0D, 0xBD, 0xFF, 0xFF, 0xE9, 0xD0, 0x01, 0x00, 0x00,
	0xBF, 0x9A, 0x00, 0x00, 0xC0, 0x89, 0x7C, 0x24, 0x40, 0xE9, 0xC2, 0x01, 0x00, 0x00, 0xBB, 0x10,
	0x00, 0x00, 0x00, 0x89, 0x5C, 0x24, 0x44, 0x48, 0x8D, 0x54, 0x24, 0x78, 0x48, 0x8B, 0x4C, 0x24,
	0x48, 0xFF, 0x15, 0xF9, 0xBD, 0xFF, 0xFF, 0x48, 0x83, 0x64, 0x24, 0x28, 0x00, 0x48, 0x8D, 0x44,
	0x24, 0x60, 0x48, 0x89, 0x44, 0x24, 0x20, 0x45, 0x8A, 0xCD, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x48,
	0x8B, 0xCF, 0xFF, 0x15, 0x90, 0xBD, 0xFF, 0xFF, 0x8B, 0xF8, 0x89, 0x44, 0x24, 0x40, 0x48, 0x8D,
	0x4C, 0x24, 0x78, 0xFF, 0x15, 0x4F, 0xBD, 0xFF, 0xFF, 0x85, 0xFF, 0x0F, 0x88, 0x6F, 0x01, 0x00,
	0x00, 0x8B, 0xD6, 0x3B, 0xF3, 0x0F, 0x42, 0xD3, 0x41, 0xB8, 0x4B, 0x70, 0x68, 0x51, 0x41, 0x8B,
	0xCE, 0xFF, 0x15, 0x91, 0xBD, 0xFF, 0xFF, 0x48, 0x8B, 0xD8, 0x48, 0x89, 0x44, 0x24, 0x50, 0x48,
	0x85, 0xC0, 0x0F, 0x84, 0xBB, 0x00, 0x00, 0x00, 0x44, 0x8B, 0xEE, 0x44, 0x8B, 0xC6, 0x33, 0xD2,
	0x48, 0x8B, 0xC8, 0xE8, 0xE8, 0xAF, 0xFF, 0xFF, 0x48, 0x8B, 0x7C, 0x24, 0x60, 0x48, 0x8B, 0xCF,
	0xE8, 0x7F, 0xF3, 0xFF, 0xFF, 0x48, 0x8B, 0x15, 0x14, 0xBD, 0xFF, 0xFF, 0x48, 0x3B, 0x02, 0x75,
	0x21, 0x83, 0x7F, 0x74, 0x00, 0x75, 0x06, 0x83, 0x7F, 0x70, 0x00, 0x74, 0x15, 0x4C, 0x8D, 0x4C,
	0x24, 0x44, 0x44, 0x8B, 0xC6, 0x48, 0x8B, 0xD3, 0x48, 0x8B, 0xCF, 0xE8, 0x34, 0xF7, 0xFF, 0xFF,
	0xEB, 0x14, 0x4C, 0x8D, 0x4C, 0x24, 0x44, 0x44, 0x8B, 0xC6, 0x48, 0x8B, 0xD3, 0x48, 0x8B, 0xCF,
	0xFF, 0x15, 0xD2, 0xBC, 0xFF, 0xFF, 0xB9, 0x23, 0x00, 0x00, 0xC0, 0x3D, 0x05, 0x00, 0x00, 0x80,
	0x0F, 0x44, 0xC1, 0x8D, 0x79, 0xE1, 0x3B, 0xC7, 0x0F, 0x44, 0xC1, 0x8B, 0xF8, 0x89, 0x44, 0x24,
	0x40, 0x85, 0xC0, 0x78, 0x2E, 0x48, 0x8B, 0x43, 0x08, 0x48, 0x85, 0xC0, 0x74, 0x0A, 0x48, 0x2B,
	0xC3, 0x49, 0x03, 0xC4, 0x48, 0x89, 0x43, 0x08, 0x4D, 0x8B, 0xC5, 0x48, 0x8B, 0xD3, 0x49, 0x8B,
	0xCC, 0xE8, 0xEA, 0xAA, 0xFF, 0xFF, 0xEB, 0x0B, 0x8B, 0xF8, 0x89, 0x44, 0x24, 0x40, 0x48, 0x8B,
	0x5C, 0x24, 0x50, 0xBA, 0x4B, 0x70, 0x68, 0x51, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0xC7, 0xBB, 0xFF,
	0xFF, 0xEB, 0x09, 0xBF, 0x9A, 0x00, 0x00, 0xC0, 0x89, 0x7C, 0x24, 0x40, 0x48, 0x8B, 0x4C, 0x24,
	0x60, 0xFF, 0x15, 0xA9, 0xBC, 0xFF, 0xFF, 0xEB, 0x77, 0x48, 0x8D, 0x54, 0x24, 0x78, 0x48, 0x8B,
	0x4C, 0x24, 0x48, 0xFF, 0x15, 0xB7, 0xBC, 0xFF, 0xFF, 0x48, 0x83, 0x64, 0x24, 0x20, 0x00, 0x41,
	0xB9, 0x38, 0x00, 0x00, 0x00, 0x4C, 0x8D, 0x84, 0x24, 0xA8, 0x00, 0x00, 0x00, 0x33, 0xD2, 0x48,
	0x8B, 0xCF, 0xFF, 0x15, 0x10, 0xBC, 0xFF, 0xFF, 0x8B, 0xF8, 0x89, 0x44, 0x24, 0x40, 0x48, 0x8D,
	0x4C, 0x24, 0x78, 0xFF, 0x15, 0x0F, 0xBC, 0xFF, 0xFF, 0x85, 0xFF, 0x78, 0x2B, 0x83, 0xFE, 0x38,
	0x75, 0x1D, 0x49, 0x8B, 0xCC, 0x48, 0x8D, 0x94, 0x24, 0xA8, 0x00, 0x00, 0x00, 0x44, 0x8B, 0xC6,
	0xE8, 0x5B, 0xAA, 0xFF, 0xFF, 0xEB, 0x06, 0x8B, 0xF8, 0x89, 0x44, 0x24, 0x40, 0xEB, 0x09, 0xBF,
	0x04, 0x00, 0x00, 0xC0, 0x89, 0x7C, 0x24, 0x40, 0xC7, 0x44, 0x24, 0x44, 0x38, 0x00, 0x00, 0x00,
	0x48, 0x8B, 0x4C, 0x24, 0x48, 0xFF, 0x15, 0x25, 0xBC, 0xFF, 0xFF, 0x4C, 0x8B, 0x6C, 0x24, 0x70,
	0x4D, 0x85, 0xED, 0x74, 0x23, 0x80, 0xBC, 0x24, 0x50, 0x01, 0x00, 0x00, 0x00, 0x74, 0x10, 0x8B,
	0x44, 0x24, 0x44, 0x41, 0x89, 0x45, 0x00, 0xEB, 0x04, 0x8B, 0x7C, 0x24, 0x40, 0xEB, 0x09, 0x8B,
	0x4C, 0x24, 0x44, 0x49, 0x8B, 0xC5, 0x89, 0x08, 0x8B, 0xC7, 0x48, 0x8B, 0x8C, 0x24, 0xE0, 0x00,
	0x00, 0x00, 0x48, 0x33, 0xCC, 0xE8, 0x86, 0xA9, 0xFF, 0xFF, 0x48, 0x8B, 0x9C, 0x24, 0x30, 0x01,
	0x00, 0x00, 0x48, 0x81, 0xC4, 0xF0, 0x00, 0x00, 0x00, 0x41, 0x5E, 0x41, 0x5D, 0x41, 0x5C, 0x5F,
	0x5E, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x8B, 0xC4, 0x48, 0x89, 0x58, 0x08, 0x48,
	0x89, 0x70, 0x18, 0x48, 0x89, 0x78, 0x20, 0x48, 0x89, 0x50, 0x10, 0x41, 0x54, 0x41, 0x55, 0x41,
	0x56, 0x48, 0x83, 0xEC, 0x70, 0x4D, 0x8B, 0xE9, 0x45, 0x8B, 0xE0, 0x48, 0x8B, 0xFA, 0x4C, 0x8B,
	0xF1, 0x8A, 0x9C, 0x24, 0xB8, 0x00, 0x00, 0x00, 0x84, 0xDB, 0x74, 0x2B, 0xB8, 0x04, 0x00, 0x00,
	0x00, 0x44, 0x8D, 0x40, 0xFD, 0x41, 0x83, 0xFC, 0x03, 0x44, 0x0F, 0x45, 0xC0, 0x8B, 0xB4, 0x24,
	0xB0, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xD6, 0x49, 0x8B, 0xC9, 0xFF, 0x15, 0xD8, 0xBA, 0xFF, 0xFF,
	0xEB, 0x0C, 0xE9, 0xE1, 0x00, 0x00, 0x00, 0x8B, 0xB4, 0x24, 0xB0, 0x00, 0x00, 0x00, 0x48, 0x83,
	0x64, 0x24, 0x28, 0x00, 0x48, 0x8D, 0x44, 0x24, 0x30, 0x48, 0x89, 0x44, 0x24, 0x20, 0x44, 0x8A,
	0xCB, 0x4C, 0x8B, 0x05, 0xD0, 0xBA, 0xFF, 0xFF, 0x4D, 0x8B, 0x00, 0x33, 0xD2, 0x49, 0x8B, 0xCE,
	0xFF, 0x15, 0x12, 0xBB, 0xFF, 0xFF, 0x8B, 0xD8, 0x85, 0xC0, 0x0F, 0x88, 0xA8, 0x00, 0x00, 0x00,
	0x48, 0x8B, 0x4C, 0x24, 0x30, 0x48, 0x8B, 0x05, 0x0C, 0xBB, 0xFF, 0xFF, 0x48, 0x3B, 0x08, 0x75,
	0x11, 0x48, 0x81, 0xCF, 0x00, 0x00, 0x00, 0x80, 0x48, 0x89, 0xBC, 0x24, 0x98, 0x00, 0x00, 0x00,
	0xEB, 0x12, 0x48, 0x85, 0xFF, 0x79, 0x0D, 0xFF, 0x15, 0x03, 0xBB, 0xFF, 0xFF, 0xB8, 0x08, 0x00,
	0x00, 0xC0, 0xEB, 0x74, 0x41, 0x83, 0xFC, 0x03, 0x74, 0x07, 0xBB, 0x03, 0x00, 0x00, 0xC0, 0xEB,
	0x5F, 0x83, 0xFE, 0x02, 0x75, 0x20, 0x41, 0x0F, 0xB7, 0x45, 0x00, 0x66, 0x89, 0x84, 0x24, 0xB8,
	0x00, 0x00, 0x00, 0xEB, 0x0F, 0x8B, 0xD8, 0x48, 0x8B, 0xBC, 0x24, 0x98, 0x00, 0x00, 0x00, 0x48,
	0x8B, 0x4C, 0x24, 0x30, 0xEB, 0x05, 0xBB, 0x04, 0x00, 0x00, 0xC0, 0x85, 0xDB, 0x78, 0x31, 0x48,
	0x8D, 0x54, 0x24, 0x38, 0xFF, 0x15, 0xD6, 0xBA, 0xFF, 0xFF, 0x45, 0x33, 0xC0, 0x48, 0x8D, 0x94,
	0x24, 0xB8, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xCF, 0xFF, 0x15, 0x92, 0xBA, 0xFF, 0xFF, 0x8B, 0xD8,
	0x48, 0x8D, 0x4C, 0x24, 0x38, 0xFF, 0x15, 0x3D, 0xBA, 0xFF, 0xFF, 0x48, 0x8B, 0x4C, 0x24, 0x30,
	0xFF, 0x15, 0x8A, 0xBA, 0xFF, 0xFF, 0x8B, 0xC3, 0x4C, 0x8D, 0x5C, 0x24, 0x70, 0x49, 0x8B, 0x5B,
	0x20, 0x49, 0x8B, 0x73, 0x30, 0x49, 0x8B, 0x7B, 0x38, 0x49, 0x8B, 0xE3, 0x41, 0x5E, 0x41, 0x5D,
	0x41, 0x5C, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x89, 0x5C, 0x24,
	0x08, 0x48, 0x89, 0x6C, 0x24, 0x18, 0x56, 0x57, 0x41, 0x55, 0x41, 0x56, 0x41, 0x57, 0x48, 0x81,
	0xEC, 0x80, 0x00, 0x00, 0x00, 0x33, 0xDB, 0x4D, 0x8B, 0xF9, 0x49, 0x8B, 0xE8, 0x4C, 0x8B, 0xEA,
	0x48, 0x8B, 0xF1, 0x44, 0x8A, 0xF3, 0x88, 0x9C, 0x24, 0xB8, 0x00, 0x00, 0x00, 0x48, 0x3B, 0xD3,
	0x74, 0x05, 0x4C, 0x3B, 0xCB, 0x75, 0x14, 0xF6, 0x84, 0x24, 0xE0, 0x00, 0x00, 0x00, 0x01, 0x75,
	0x0A, 0xB8, 0x30, 0x00, 0x00, 0xC0, 0xE9, 0x56, 0x01, 0x00, 0x00, 0x40, 0x8A, 0xBC, 0x24, 0xE8,
	0x00, 0x00, 0x00, 0x40, 0x3A, 0xFB, 0x74, 0x15, 0x0F, 0xBA, 0xA4, 0x24, 0xD8, 0x00, 0x00, 0x00,
	0x09, 0x73, 0x0A, 0xB8, 0xF4, 0x00, 0x00, 0xC0, 0xE9, 0x34, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x05,
	0xD4, 0xB9, 0xFF, 0xFF, 0x48, 0x3B, 0x08, 0x75, 0x0A, 0x48, 0x81, 0xCD, 0x00, 0x00, 0x00, 0x80,
	0x40, 0x8A, 0xFB, 0xFF, 0x15, 0xA7, 0xB9, 0xFF, 0xFF, 0x48, 0x3B, 0xF0, 0x75, 0x14, 0xF6, 0x84,
	0x24, 0xE0, 0x00, 0x00, 0x00, 0x01, 0x74, 0x0A, 0xB8, 0xDB, 0x00, 0x00, 0xC0, 0xE9, 0xFF, 0x00,
	0x00, 0x00, 0xFF, 0x15, 0x88, 0xB9, 0xFF, 0xFF, 0x48, 0x3B, 0xF0, 0x74, 0x11, 0x48, 0x8D, 0x54,
	0x24, 0x50, 0x48, 0x8B, 0xCE, 0xFF, 0x15, 0xC5, 0xB9, 0xFF, 0xFF, 0x41, 0xB6, 0x01, 0xF6, 0x84,
	0x24, 0xE0, 0x00, 0x00, 0x00, 0x01, 0x48, 0x8B, 0xCD, 0x74, 0x24, 0x40, 0x8A, 0xD7, 0xFF, 0x15,
	0x6C, 0xB9, 0xFF, 0xFF, 0x8B, 0xF8, 0x44, 0x3A, 0xF3, 0x0F, 0x84, 0xC0, 0x00, 0x00, 0x00, 0x48,
	0x8D, 0x4C, 0x24, 0x50, 0xFF, 0x15, 0x1E, 0xB9, 0xFF, 0xFF, 0xE9, 0xB0, 0x00, 0x00, 0x00, 0x48,
	0x8D, 0x44, 0x24, 0x40, 0x44, 0x8A, 0xCF, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x48, 0x89, 0x5C, 0x24,
	0x28, 0x48, 0x89, 0x44, 0x24, 0x20, 0xFF, 0x15, 0x2C, 0xB9, 0xFF, 0xFF, 0x8B, 0xF8, 0x44, 0x3A,
	0xF3, 0x74, 0x0B, 0x48, 0x8D, 0x4C, 0x24, 0x50, 0xFF, 0x15, 0xEA, 0xB8, 0xFF, 0xFF, 0x3B, 0xFB,
	0x7C, 0x7D, 0xFF, 0x15, 0x08, 0xB9, 0xFF, 0xFF, 0x4C, 0x3B, 0xE8, 0x74, 0x16, 0x48, 0x8D, 0x54,
	0x24, 0x50, 0x49, 0x8B, 0xCD, 0xFF, 0x15, 0x45, 0xB9, 0xFF, 0xFF, 0xC6, 0x84, 0x24, 0xB8, 0x00,
	0x00, 0x00, 0x01, 0x44, 0x8B, 0x8C, 0x24, 0xD0, 0x00, 0x00, 0x00, 0x8B, 0x94, 0x24, 0xD8, 0x00,
	0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x40, 0x48, 0x8D, 0x44, 0x24, 0x48, 0x45, 0x33, 0xC0, 0x48,
	0x89, 0x44, 0x24, 0x30, 0x88, 0x5C, 0x24, 0x28, 0x48, 0x89, 0x5C, 0x24, 0x20, 0xFF, 0x15, 0x05,
	0xB9, 0xFF, 0xFF, 0x48, 0x8B, 0x4C, 0x24, 0x40, 0x8B, 0xF8, 0xFF, 0x15, 0xE0, 0xB8, 0xFF, 0xFF,
	0x38, 0x9C, 0x24, 0xB8, 0x00, 0x00, 0x00, 0x74, 0x0B, 0x48, 0x8D, 0x4C, 0x24, 0x50, 0xFF, 0x15,
	0x74, 0xB8, 0xFF, 0xFF, 0x3B, 0xFB, 0x48, 0x0F, 0x4D, 0x5C, 0x24, 0x48, 0x49, 0x89, 0x1F, 0x8B,
	0xC7, 0x4C, 0x8D, 0x9C, 0x24, 0x80, 0x00, 0x00, 0x00, 0x49, 0x8B, 0x5B, 0x30, 0x49, 0x8B, 0x6B,
	0x40, 0x49, 0x8B, 0xE3, 0x41, 0x5F, 0x41, 0x5E, 0x41, 0x5D, 0x5F, 0x5E, 0xC3, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x8B, 0xC4, 0x48, 0x89, 0x58, 0x08, 0x48, 0x89, 0x70, 0x10, 0x48,
	0x89, 0x78, 0x18, 0x4C, 0x89, 0x60, 0x20, 0x41, 0x55, 0x48, 0x83, 0xEC, 0x60, 0x49, 0x8B, 0xD9,
	0x49, 0x8B, 0xF8, 0x4C, 0x8B, 0xEA, 0x4C, 0x8B, 0xE1, 0x48, 0x83, 0x60, 0xD8, 0x00, 0x48, 0x83,
	0x60, 0xE0, 0x00, 0x40, 0x8A, 0xB4, 0x24, 0xA8, 0x00, 0x00, 0x00, 0x40, 0x84, 0xF6, 0x74, 0x1E,
	0x48, 0x85, 0xDB, 0x74, 0x12, 0xBA, 0x08, 0x00, 0x00, 0x00, 0x44, 0x8D, 0x42, 0xF9, 0x48, 0x8B,
	0xCB, 0xFF, 0x15, 0x69, 0xB7, 0xFF, 0xFF, 0xEB, 0x05, 0xE9, 0xF1, 0x00, 0x00, 0x00, 0x48, 0x83,
	0x64, 0x24, 0x28, 0x00, 0x48, 0x8D, 0x44, 0x24, 0x40, 0x48, 0x89, 0x44, 0x24, 0x20, 0x44, 0x8A,
	0xCE, 0x4C, 0x8B, 0x05, 0xB0, 0xB7, 0xFF, 0xFF, 0x4D, 0x8B, 0x00, 0x33, 0xD2, 0x49, 0x8B, 0xCC,
	0xFF, 0x15, 0xF2, 0xB7, 0xFF, 0xFF, 0x85, 0xC0, 0x0F, 0x88, 0xC1, 0x00, 0x00, 0x00, 0x48, 0x85,
	0xFF, 0x74, 0x3D, 0x48, 0x83, 0x64, 0x24, 0x28, 0x00, 0x48, 0x8D, 0x44, 0x24, 0x48, 0x48, 0x89,
	0x44, 0x24, 0x20, 0x44, 0x8A, 0xCE, 0x4C, 0x8B, 0x05, 0x7B, 0xB7, 0xFF, 0xFF, 0x4D, 0x8B, 0x00,
	0x33, 0xD2, 0x48, 0x8B, 0xCF, 0xFF, 0x15, 0xBD, 0xB7, 0xFF, 0xFF, 0x8B, 0xF8, 0x85, 0xC0, 0x79,
	0x0F, 0x48, 0x8B, 0x4C, 0x24, 0x40, 0xFF, 0x15, 0xD4, 0xB7, 0xFF, 0xFF, 0x8B, 0xC7, 0xEB, 0x7F,
	0x40, 0x88, 0x74, 0x24, 0x38, 0x8B, 0x84, 0x24, 0xA0, 0x00, 0x00, 0x00, 0x89, 0x44, 0x24, 0x30,
	0x8B, 0x84, 0x24, 0x98, 0x00, 0x00, 0x00, 0x89, 0x44, 0x24, 0x28, 0x8B, 0x84, 0x24, 0x90, 0x00,
	0x00, 0x00, 0x89, 0x44, 0x24, 0x20, 0x4C, 0x8D, 0x4C, 0x24, 0x50, 0x4D, 0x8B, 0xC5, 0x48, 0x8B,
	0x54, 0x24, 0x48, 0x48, 0x8B, 0x4C, 0x24, 0x40, 0xE8, 0x2F, 0xFD, 0xFF, 0xFF, 0x8B, 0xF8, 0x48,
	0x85, 0xDB, 0x74, 0x1E, 0x40, 0x84, 0xF6, 0x74, 0x11, 0x48, 0x8B, 0x4C, 0x24, 0x50, 0x48, 0x89,
	0x0B, 0xEB, 0x05, 0xBF, 0x05, 0x00, 0x00, 0xC0, 0xEB, 0x08, 0x48, 0x8B, 0x44, 0x24, 0x50, 0x48,
	0x89, 0x03, 0x48, 0x8B, 0x4C, 0x24, 0x48, 0x48, 0x85, 0xC9, 0x74, 0x06, 0xFF, 0x15, 0x5E, 0xB7,
	0xFF, 0xFF, 0x48, 0x8B, 0x4C, 0x24, 0x40, 0xFF, 0x15, 0x53, 0xB7, 0xFF, 0xFF, 0x8B, 0xC7, 0x4C,
	0x8D, 0x5C, 0x24, 0x60, 0x49, 0x8B, 0x5B, 0x10, 0x49, 0x8B, 0x73, 0x18, 0x49, 0x8B, 0x7B, 0x20,
	0x4D, 0x8B, 0x63, 0x28, 0x49, 0x8B, 0xE3, 0x41, 0x5D, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0x48, 0x8B, 0xC4, 0x48, 0x89, 0x70, 0x08, 0x48, 0x89, 0x78, 0x10, 0x4C, 0x89, 0x60, 0x18, 0x41,
	0x55, 0x48, 0x81, 0xEC, 0x90, 0x00, 0x00, 0x00, 0x4D, 0x8B, 0xE9, 0x4D, 0x8B, 0xE0, 0x48, 0x8B,
	0xF1, 0x83, 0x60, 0xC0, 0x00, 0x33, 0xD2, 0x44, 0x8D, 0x42, 0x28, 0x48, 0x8D, 0x48, 0xC8, 0xE8,
	0x7C, 0xA9, 0xFF, 0xFF, 0x80, 0xBC, 0x24, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x74, 0x3E, 0xBA, 0x08,
	0x00, 0x00, 0x00, 0x44, 0x8B, 0xC2, 0x48, 0x8B, 0xCE, 0xFF, 0x15, 0x01, 0xB6, 0xFF, 0xFF, 0xBF,
	0x30, 0x00, 0x00, 0x00, 0x44, 0x8D, 0x47, 0xD4, 0x48, 0x8B, 0xD7, 0x49, 0x8B, 0xCC, 0xFF, 0x15,
	0x34, 0xB6, 0xFF, 0xFF, 0x48, 0x8D, 0x4C, 0x24, 0x58, 0x49, 0x8B, 0xD4, 0x4C, 0x8B, 0xC7, 0xE8,
	0xCC, 0xA4, 0xFF, 0xFF, 0x90, 0xEB, 0x18, 0xE9, 0xE8, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24,
	0x58, 0x49, 0x8B, 0xD4, 0x41, 0xB8, 0x30, 0x00, 0x00, 0x00, 0xE8, 0xB1, 0xA4, 0xFF, 0xFF, 0x48,
	0x8B, 0x4C, 0x24, 0x68, 0x48, 0x85, 0xC9, 0x75, 0x0A, 0xB8, 0x0D, 0x00, 0x00, 0xC0, 0xE9, 0xC1,
	0x00, 0x00, 0x00, 0x80, 0xBC, 0x24, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x74, 0x12, 0x0F, 0xBA, 0x64,
	0x24, 0x70, 0x09, 0x73, 0x0A, 0xB8, 0x0D, 0x00, 0x00, 0xC0, 0xE9, 0xA5, 0x00, 0x00, 0x00, 0x80,
	0xBC, 0x24, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x74, 0x12, 0x48, 0x83, 0x7C, 0x24, 0x60, 0x00, 0x7D,
	0x0A, 0xB8, 0x0D, 0x00, 0x00, 0xC0, 0xE9, 0x89, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x54, 0x24, 0x48,
	0xE8, 0x9F, 0xA1, 0xFF, 0xFF, 0x85, 0xC0, 0x78, 0x7B, 0x48, 0x8D, 0x44, 0x24, 0x48, 0x48, 0x89,
	0x44, 0x24, 0x68, 0x48, 0x83, 0x64, 0x24, 0x78, 0x00, 0x48, 0x83, 0xA4, 0x24, 0x80, 0x00, 0x00,
	0x00, 0x00, 0x48, 0x8D, 0x44, 0x24, 0x40, 0x48, 0x89, 0x44, 0x24, 0x30, 0x48, 0x83, 0x64, 0x24,
	0x28, 0x00, 0x83, 0x64, 0x24, 0x20, 0x00, 0x45, 0x33, 0xC9, 0x45, 0x33, 0xC0, 0x49, 0x8B, 0xD5,
	0x48, 0x8D, 0x4C, 0x24, 0x58, 0xFF, 0x15, 0x95, 0xB5, 0xFF, 0xFF, 0x8B, 0xF8, 0x48, 0x8B, 0x4C,
	0x24, 0x50, 0x48, 0x85, 0xC9, 0x74, 0x0B, 0xBA, 0x4B, 0x70, 0x68, 0x55, 0xFF, 0x15, 0xF6, 0xB4,
	0xFF, 0xFF, 0x80, 0xBC, 0x24, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x74, 0x0E, 0x48, 0x8B, 0x44, 0x24,
	0x40, 0x48, 0x89, 0x06, 0xEB, 0x02, 0x8B, 0xF8, 0xEB, 0x08, 0x48, 0x8B, 0x44, 0x24, 0x40, 0x48,
	0x89, 0x06, 0x8B, 0xC7, 0x4C, 0x8D, 0x9C, 0x24, 0x90, 0x00, 0x00, 0x00, 0x49, 0x8B, 0x73, 0x10,
	0x49, 0x8B, 0x7B, 0x18, 0x4D, 0x8B, 0x63, 0x20, 0x49, 0x8B, 0xE3, 0x41, 0x5D, 0xC3, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x74, 0x24, 0x10, 0x48, 0x89,
	0x7C, 0x24, 0x18, 0x41, 0x54, 0x48, 0x83, 0xEC, 0x70, 0x41, 0x8A, 0xF1, 0x49, 0x8B, 0xD8, 0x44,
	0x8B, 0xE2, 0x48, 0x8B, 0xF9, 0x45, 0x84, 0xC9, 0x74, 0x31, 0xBA, 0x08, 0x00, 0x00, 0x00, 0x44,
	0x8B, 0xC2, 0xFF, 0x15, 0x98, 0xB4, 0xFF, 0xFF, 0xBA, 0x10, 0x00, 0x00, 0x00, 0x44, 0x8D, 0x42,
	0xF4, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0xCE, 0xB4, 0xFF, 0xFF, 0xF3, 0x0F, 0x6F, 0x2B, 0xF3, 0x0F,
	0x7F, 0x6C, 0x24, 0x58, 0xEB, 0x10, 0xE9, 0xB4, 0x00, 0x00, 0x00, 0xF3, 0x41, 0x0F, 0x6F, 0x00,
	0xF3, 0x0F, 0x7F, 0x44, 0x24, 0x58, 0x48, 0x83, 0x7C, 0x24, 0x60, 0x00, 0x74, 0x28, 0x4C, 0x8D,
	0x44, 0x24, 0x50, 0x48, 0x8D, 0x54, 0x24, 0x40, 0x48, 0x8D, 0x4C, 0x24, 0x58, 0xFF, 0x15, 0x95,
	0xB5, 0xFF, 0xFF, 0x8B, 0xD8, 0x85, 0xC0, 0x78, 0x1F, 0x48, 0x8B, 0x4C, 0x24, 0x50, 0xFF, 0x15,
	0x1C, 0xB5, 0xFF, 0xFF, 0xEB, 0x12, 0x48, 0x8D, 0x54, 0x24, 0x40, 0x48, 0x8B, 0x4C, 0x24, 0x58,
	0xFF, 0x15, 0x3A, 0xB5, 0xFF, 0xFF, 0x8B, 0xD8, 0x85, 0xDB, 0x79, 0x04, 0x8B, 0xC3, 0xEB, 0x5F,
	0x48, 0x8D, 0x44, 0x24, 0x48, 0x48, 0x89, 0x44, 0x24, 0x30, 0xC6, 0x44, 0x24, 0x28, 0x00, 0x48,
	0x8B, 0x05, 0x72, 0xB4, 0xFF, 0xFF, 0x48, 0x8B, 0x08, 0x48, 0x89, 0x4C, 0x24, 0x20, 0x45, 0x8B,
	0xCC, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x48, 0x8B, 0x4C, 0x24, 0x40, 0xFF, 0x15, 0xE7, 0xB4, 0xFF,
	0xFF, 0x8B, 0xD8, 0x48, 0x8B, 0x4C, 0x24, 0x40, 0xFF, 0x15, 0xC2, 0xB4, 0xFF, 0xFF, 0x85, 0xDB,
	0x78, 0x1B, 0x40, 0x84, 0xF6, 0x74, 0x0E, 0x48, 0x8B, 0x4C, 0x24, 0x48, 0x48, 0x89, 0x0F, 0xEB,
	0x02, 0x8B, 0xD8, 0xEB, 0x08, 0x48, 0x8B, 0x44, 0x24, 0x48, 0x48, 0x89, 0x07, 0x8B, 0xC3, 0x4C,
	0x8D, 0x5C, 0x24, 0x70, 0x49, 0x8B, 0x5B, 0x10, 0x49, 0x8B, 0x73, 0x18, 0x49, 0x8B, 0x7B, 0x20,
	0x49, 0x8B, 0xE3, 0x41, 0x5C, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x89, 0x5C, 0x24,
	0x08, 0x48, 0x89, 0x74, 0x24, 0x10, 0x48, 0x89, 0x7C, 0x24, 0x18, 0x41, 0x54, 0x48, 0x83, 0xEC,
	0x50, 0x45, 0x8A, 0xE1, 0x49, 0x8B, 0xF8, 0x8B, 0xF2, 0x48, 0x8B, 0xD9, 0x45, 0x84, 0xC9, 0x74,
	0x18, 0xBA, 0x08, 0x00, 0x00, 0x00, 0x44, 0x8B, 0xC2, 0x48, 0x8B, 0xCF, 0xFF, 0x15, 0x6E, 0xB3,
	0xFF, 0xFF, 0xEB, 0x05, 0xE9, 0xA0, 0x00, 0x00, 0x00, 0x48, 0x83, 0x64, 0x24, 0x28, 0x00, 0x48,
	0x8D, 0x44, 0x24, 0x40, 0x48, 0x89, 0x44, 0x24, 0x20, 0x45, 0x8A, 0xCC, 0x4C, 0x8B, 0x05, 0xB5,
	0xB3, 0xFF, 0xFF, 0x4D, 0x8B, 0x00, 0x33, 0xD2, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0xF7, 0xB3, 0xFF,
	0xFF, 0x85, 0xC0, 0x78, 0x74, 0x48, 0x8B, 0x4C, 0x24, 0x40, 0xFF, 0x15, 0x50, 0xB4, 0xFF, 0xFF,
	0x48, 0x8B, 0xD8, 0x48, 0x8D, 0x44, 0x24, 0x48, 0x48, 0x89, 0x44, 0x24, 0x30, 0xC6, 0x44, 0x24,
	0x28, 0x00, 0x48, 0x8B, 0x0D, 0x3F, 0xB4, 0xFF, 0xFF, 0x48, 0x8B, 0x11, 0x48, 0x89, 0x54, 0x24,
	0x20, 0x44, 0x8B, 0xCE, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0xF6, 0xB3,
	0xFF, 0xFF, 0x8B, 0xF0, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0x4B, 0xB4, 0xFF, 0xFF, 0x48, 0x8B, 0x4C,
	0x24, 0x40, 0xFF, 0x15, 0xC8, 0xB3, 0xFF, 0xFF, 0x85, 0xF6, 0x78, 0x1B, 0x45, 0x84, 0xE4, 0x74,
	0x0E, 0x48, 0x8B, 0x44, 0x24, 0x48, 0x48, 0x89, 0x07, 0xEB, 0x02, 0x8B, 0xF0, 0xEB, 0x08, 0x48,
	0x8B, 0x44, 0x24, 0x48, 0x48, 0x89, 0x07, 0x8B, 0xC6, 0x48, 0x8B, 0x5C, 0x24, 0x60, 0x48, 0x8B,
	0x74, 0x24, 0x68, 0x48, 0x8B, 0x7C, 0x24, 0x70, 0x48, 0x83, 0xC4, 0x50, 0x41, 0x5C, 0xC3, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x8B, 0xC4, 0x48, 0x89, 0x58, 0x08, 0x48,
	0x89, 0x70, 0x10, 0x48, 0x89, 0x78, 0x18, 0x41, 0x54, 0x48, 0x83, 0xEC, 0x50, 0x41, 0x8A, 0xF1,
	0x49, 0x8B, 0xF8, 0x44, 0x8B, 0xE2, 0x48, 0x8B, 0xD9, 0x48, 0x83, 0x60, 0xE8, 0x00, 0x45, 0x84,
	0xC9, 0x74, 0x18, 0xBA, 0x08, 0x00, 0x00, 0x00, 0x44, 0x8B, 0xC2, 0x48, 0x8B, 0xCF, 0xFF, 0x15,
	0x6C, 0xB2, 0xFF, 0xFF, 0xEB, 0x05, 0xE9, 0xA0, 0x00, 0x00, 0x00, 0x48, 0x83, 0x64, 0x24, 0x28,
	0x00, 0x48, 0x8D, 0x44, 0x24, 0x48, 0x48, 0x89, 0x44, 0x24, 0x20, 0x44, 0x8A, 0xCE, 0x4C, 0x8B,
	0x05, 0xB3, 0xB2, 0xFF, 0xFF, 0x4D, 0x8B, 0x00, 0x33, 0xD2, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0xF5,
	0xB2, 0xFF, 0xFF, 0x85, 0xC0, 0x78, 0x74, 0x48, 0x8B, 0x4C, 0x24, 0x48, 0xFF, 0x15, 0x6E, 0xB3,
	0xFF, 0xFF, 0x48, 0x85, 0xC0, 0x74, 0x33, 0x48, 0x8D, 0x4C, 0x24, 0x40, 0x48, 0x89, 0x4C, 0x24,
	0x30, 0xC6, 0x44, 0x24, 0x28, 0x00, 0x48, 0x8B, 0x0D, 0x2B, 0xB3, 0xFF, 0xFF, 0x48, 0x8B, 0x11,
	0x48, 0x89, 0x54, 0x24, 0x20, 0x45, 0x8B, 0xCC, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x48, 0x8B, 0xC8,
	0xFF, 0x15, 0xF2, 0xB2, 0xFF, 0xFF, 0x8B, 0xD8, 0xEB, 0x05, 0xBB, 0x25, 0x02, 0x00, 0xC0, 0x48,
	0x8B, 0x4C, 0x24, 0x48, 0xFF, 0x15, 0xC6, 0xB2, 0xFF, 0xFF, 0x85, 0xDB, 0x78, 0x1B, 0x40, 0x84,
	0xF6, 0x74, 0x0E, 0x48, 0x8B, 0x44, 0x24, 0x40, 0x48, 0x89, 0x07, 0xEB, 0x02, 0x8B, 0xD8, 0xEB,
	0x08, 0x48, 0x8B, 0x44, 0x24, 0x40, 0x48, 0x89, 0x07, 0x8B, 0xC3, 0x48, 0x8B, 0x5C, 0x24, 0x60,
	0x48, 0x8B, 0x74, 0x24, 0x68, 0x48, 0x8B, 0x7C, 0x24, 0x70, 0x48, 0x83, 0xC4, 0x50, 0x41, 0x5C,
	0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4C, 0x8B, 0xDC, 0x49, 0x89, 0x5B, 0x08, 0x49,
	0x89, 0x73, 0x10, 0x57, 0x48, 0x83, 0xEC, 0x50, 0x49, 0x83, 0x63, 0xD0, 0x00, 0x45, 0x8A, 0xC8,
	0x4C, 0x8B, 0x05, 0xF1, 0xB1, 0xFF, 0xFF, 0x4D, 0x8B, 0x00, 0x49, 0x8D, 0x43, 0x20, 0x8B, 0xF2,
	0x33, 0xD2, 0x49, 0x89, 0x43, 0xC8, 0xFF, 0x15, 0x2C, 0xB2, 0xFF, 0xFF, 0x85, 0xC0, 0x0F, 0x88,
	0xAF, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x16, 0xB2, 0xFF, 0xFF, 0x48, 0x8B, 0x5C, 0x24, 0x78, 0x48,
	0x3B, 0xD8, 0x0F, 0x84, 0x8B, 0x00, 0x00, 0x00, 0x83, 0x3D, 0x65, 0xC4, 0xFF, 0xFF, 0x00, 0x75,
	0x26, 0x48, 0x8D, 0x0D, 0xE8, 0xC2, 0xFF, 0xFF, 0xE8, 0xCF, 0x9C, 0xFF, 0xFF, 0x48, 0x85, 0xC0,
	0x74, 0x10, 0x8B, 0xD6, 0x48, 0x8B, 0xCB, 0xFF, 0xD0, 0x8B, 0xF8, 0x3D, 0xBB, 0x00, 0x00, 0xC0,
	0x75, 0x5A, 0x48, 0x8B, 0x5C, 0x24, 0x78, 0x48, 0x8D, 0x44, 0x24, 0x40, 0x41, 0xB9, 0x01, 0x00,
	0x00, 0x00, 0x45, 0x33, 0xC0, 0x48, 0x89, 0x44, 0x24, 0x30, 0x48, 0x8B, 0x05, 0x77, 0xB1, 0xFF,
	0xFF, 0xC6, 0x44, 0x24, 0x28, 0x00, 0x48, 0x8B, 0x08, 0xBA, 0x00, 0x02, 0x00, 0x00, 0x48, 0x89,
	0x4C, 0x24, 0x20, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0xEC, 0xB1, 0xFF, 0xFF, 0x8B, 0xF8, 0x85, 0xC0,
	0x78, 0x1A, 0x48, 0x8B, 0x4C, 0x24, 0x40, 0x8B, 0xD6, 0xFF, 0x15, 0x31, 0xB2, 0xFF, 0xFF, 0x48,
	0x8B, 0x4C, 0x24, 0x40, 0x8B, 0xF8, 0xFF, 0x15, 0xEC, 0xB0, 0xFF, 0xFF, 0x48, 0x8B, 0x5C, 0x24,
	0x78, 0xEB, 0x05, 0xBF, 0xDB, 0x00, 0x00, 0xC0, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0x9F, 0xB1, 0xFF,
	0xFF, 0x8B, 0xC7, 0x48, 0x8B, 0x5C, 0x24, 0x60, 0x48, 0x8B, 0x74, 0x24, 0x68, 0x48, 0x83, 0xC4,
	0x50, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x89, 0x5C, 0x24,
	0x08, 0x48, 0x89, 0x74, 0x24, 0x10, 0x48, 0x89, 0x7C, 0x24, 0x18, 0x41, 0x54, 0x41, 0x55, 0x41,
	0x56, 0x48, 0x81, 0xEC, 0x90, 0x00, 0x00, 0x00, 0x45, 0x8B, 0xE9, 0x4D, 0x8B, 0xF0, 0x8B, 0xF2,
	0x48, 0x8B, 0xD9, 0x80, 0xBC, 0x24, 0xD8, 0x00, 0x00, 0x00, 0x00, 0x74, 0x47, 0x83, 0xFA, 0x01,
	0x74, 0x0A, 0xBF, 0x04, 0x00, 0x00, 0x00, 0x44, 0x8B, 0xC7, 0xEB, 0x09, 0xBF, 0x04, 0x00, 0x00,
	0x00, 0x44, 0x8D, 0x47, 0xFD, 0x49, 0x8B, 0xD5, 0x49, 0x8B, 0xCE, 0xFF, 0x15, 0x4F, 0xB0, 0xFF,
	0xFF, 0x4C, 0x8B, 0xA4, 0x24, 0xD0, 0x00, 0x00, 0x00, 0x4D, 0x85, 0xE4, 0x74, 0x0F, 0x44, 0x8B,
	0xC7, 0x48, 0x8B, 0xD7, 0x49, 0x8B, 0xCC, 0xFF, 0x15, 0x33, 0xB0, 0xFF, 0xFF, 0xEB, 0x12, 0xE9,
	0x03, 0x02, 0x00, 0x00, 0xBF, 0x04, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0xA4, 0x24, 0xD0, 0x00, 0x00,
	0x00, 0x48, 0x83, 0x64, 0x24, 0x28, 0x00, 0x48, 0x8D, 0x44, 0x24, 0x48, 0x48, 0x89, 0x44, 0x24,
	0x20, 0x44, 0x8A, 0x8C, 0x24, 0xD8, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0x05, 0x68, 0xB0, 0xFF, 0xFF,
	0x4D, 0x8B, 0x00, 0x33, 0xD2, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0xAA, 0xB0, 0xFF, 0xFF, 0x8B, 0xD8,
	0x89, 0x44, 0x24, 0x40, 0x85, 0xC0, 0x0F, 0x88, 0xBB, 0x01, 0x00, 0x00, 0x83, 0xEE, 0x01, 0x0F,
	0x84, 0x37, 0x01, 0x00, 0x00, 0x83, 0xEE, 0x01, 0x0F, 0x84, 0xBE, 0x00, 0x00, 0x00, 0x83, 0xFE,
	0x01, 0x74, 0x10, 0xBB, 0x03, 0x00, 0x00, 0xC0, 0x89, 0x5C, 0x24, 0x40, 0x33, 0xFF, 0xE9, 0x68,
	0x01, 0x00, 0x00, 0x48, 0x8D, 0x44, 0x24, 0x50, 0x48, 0x89, 0x44, 0x24, 0x30, 0xC6, 0x44, 0x24,
	0x28, 0x00, 0x48, 0x8B, 0x05, 0x0F, 0xB0, 0xFF, 0xFF, 0x48, 0x8B, 0x08, 0x48, 0x89, 0x4C, 0x24,
	0x20, 0x41, 0xB9, 0x00, 0x04, 0x00, 0x00, 0x45, 0x33, 0xC0, 0xBA, 0x00, 0x02, 0x00, 0x00, 0x48,
	0x8B, 0x4C, 0x24, 0x48, 0xFF, 0x15, 0x7E, 0xB0, 0xFF, 0xFF, 0x8B, 0xD8, 0x89, 0x44, 0x24, 0x40,
	0x85, 0xC0, 0x0F, 0x88, 0x23, 0x01, 0x00, 0x00, 0x48, 0x83, 0x64, 0x24, 0x20, 0x00, 0x44, 0x8B,
	0xCF, 0x4C, 0x8D, 0x44, 0x24, 0x44, 0xBA, 0x21, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x50,
	0xFF, 0x15, 0x32, 0xB0, 0xFF, 0xFF, 0x8B, 0xD8, 0x89, 0x44, 0x24, 0x40, 0x85, 0xC0, 0x78, 0x2C,
	0x44, 0x3B, 0xEF, 0x75, 0x1E, 0x8B, 0x44, 0x24, 0x44, 0x41, 0x89, 0x06, 0xEB, 0x13, 0x8B, 0xD8,
	0x89, 0x44, 0x24, 0x40, 0xBF, 0x04, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0xA4, 0x24, 0xD0, 0x00, 0x00,
	0x00, 0xEB, 0x09, 0xBB, 0x04, 0x00, 0x00, 0xC0, 0x89, 0x5C, 0x24, 0x40, 0x48, 0x8B, 0x4C, 0x24,
	0x50, 0xFF, 0x15, 0x31, 0xAF, 0xFF, 0xFF, 0xE9, 0xBF, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x54, 0x24,
	0x58, 0x48, 0x8B, 0x4C, 0x24, 0x48, 0xFF, 0x15, 0x04, 0xB0, 0xFF, 0xFF, 0x48, 0x83, 0x64, 0x24,
	0x20, 0x00, 0x44, 0x8B, 0xCF, 0x4C, 0x8D, 0x44, 0x24, 0x44, 0xBA, 0x22, 0x00, 0x00, 0x00, 0x48,
	0x83, 0xC9, 0xFF, 0xFF, 0x15, 0xBF, 0xAF, 0xFF, 0xFF, 0x8B, 0xD8, 0x89, 0x44, 0x24, 0x40, 0x48,
	0x8D, 0x4C, 0x24, 0x58, 0xFF, 0x15, 0x5E, 0xAF, 0xFF, 0xFF, 0x85, 0xDB, 0x78, 0x7D, 0x44, 0x3B,
	0xEF, 0x75, 0x1E, 0x8B, 0x44, 0x24, 0x44, 0x41, 0x89, 0x06, 0xEB, 0x13, 0x8B, 0xD8, 0x89, 0x44,
	0x24, 0x40, 0xBF, 0x04, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0xA4, 0x24, 0xD0, 0x00, 0x00, 0x00, 0xEB,
	0x5A, 0xBB, 0x04, 0x00, 0x00, 0xC0, 0x89, 0x5C, 0x24, 0x40, 0xEB, 0x4F, 0x32, 0xC9, 0x48, 0x8B,
	0x05, 0xD3, 0xBF, 0xFF, 0xFF, 0x48, 0x85, 0xC0, 0x74, 0x0B, 0x48, 0x8B, 0x4C, 0x24, 0x48, 0xFF,
	0xD0, 0x8A, 0xC8, 0xEB, 0x09, 0xBB, 0xBB, 0x00, 0x00, 0xC0, 0x89, 0x5C, 0x24, 0x40, 0x85, 0xDB,
	0x78, 0x24, 0x41, 0x83, 0xFD, 0x01, 0x75, 0x15, 0x41, 0x88, 0x0E, 0xEB, 0x0E, 0x8B, 0xD8, 0x89,
	0x44, 0x24, 0x40, 0x4C, 0x8B, 0xA4, 0x24, 0xD0, 0x00, 0x00, 0x00, 0xEB, 0x09, 0xBB, 0x04, 0x00,
	0x00, 0xC0, 0x89, 0x5C, 0x24, 0x40, 0xBF, 0x01, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x48,
	0xFF, 0x15, 0x2A, 0xAF, 0xFF, 0xFF, 0x4D, 0x85, 0xE4, 0x74, 0x1A, 0x80, 0xBC, 0x24, 0xD8, 0x00,
	0x00, 0x00, 0x00, 0x74, 0x0C, 0x41, 0x89, 0x3C, 0x24, 0xEB, 0x04, 0x8B, 0x5C, 0x24, 0x40, 0xEB,
	0x04, 0x41, 0x89, 0x3C, 0x24, 0x8B, 0xC3, 0x4C, 0x8D, 0x9C, 0x24, 0x90, 0x00, 0x00, 0x00, 0x49,
	0x8B, 0x5B, 0x20, 0x49, 0x8B, 0x73, 0x28, 0x49, 0x8B, 0x7B, 0x30, 0x49, 0x8B, 0xE3, 0x41, 0x5E,
	0x41, 0x5D, 0x41, 0x5C, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x8B, 0xC4, 0x48,
	0x89, 0x58, 0x08, 0x48, 0x89, 0x70, 0x10, 0x48, 0x89, 0x78, 0x18, 0x4C, 0x89, 0x60, 0x20, 0x41,
	0x55, 0x48, 0x81, 0xEC, 0x80, 0x00, 0x00, 0x00, 0x41, 0x8B, 0xF1, 0x4D, 0x8B, 0xE0, 0x8B, 0xFA,
	0x4C, 0x8B, 0xE9, 0x8A, 0x9C, 0x24, 0xB0, 0x00, 0x00, 0x00, 0x84, 0xDB, 0x74, 0x19, 0x48, 0x8B,
	0xD6, 0x41, 0xB8, 0x04, 0x00, 0x00, 0x00, 0x49, 0x8B, 0xCC, 0xFF, 0x15, 0x08, 0xAE, 0xFF, 0xFF,
	0xEB, 0x05, 0xE9, 0x5B, 0x01, 0x00, 0x00, 0x48, 0x83, 0x64, 0x24, 0x28, 0x00, 0x48, 0x8D, 0x44,
	0x24, 0x40, 0x48, 0x89, 0x44, 0x24, 0x20, 0x44, 0x8A, 0xCB, 0x4C, 0x8B, 0x05, 0x07, 0xAE, 0xFF,
	0xFF, 0x4D, 0x8B, 0x00, 0x33, 0xD2, 0x49, 0x8B, 0xCD, 0xFF, 0x15, 0x49, 0xAE, 0xFF, 0xFF, 0x8B,
	0xD8, 0x85, 0xC0, 0x0F, 0x88, 0x29, 0x01, 0x00, 0x00, 0x83, 0xEF, 0x02, 0x0F, 0x84, 0x9C, 0x00,
	0x00, 0x00, 0x83, 0xFF, 0x01, 0x74, 0x0A, 0xBB, 0x03, 0x00, 0x00, 0xC0, 0xE9, 0x04, 0x01, 0x00,
	0x00, 0x83, 0xFE, 0x04, 0x75, 0x11, 0x41, 0x8B, 0x04, 0x24, 0x89, 0x84, 0x24, 0xB0, 0x00, 0x00,
	0x00, 0xEB, 0x02, 0x8B, 0xD8, 0xEB, 0x05, 0xBB, 0x04, 0x00, 0x00, 0xC0, 0x85, 0xDB, 0x0F, 0x88,
	0xE1, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x44, 0x24, 0x48, 0x48, 0x89, 0x44, 0x24, 0x30, 0xC6, 0x44,
	0x24, 0x28, 0x00, 0x48, 0x8B, 0x05, 0x9E, 0xAD, 0xFF, 0xFF, 0x48, 0x8B, 0x08, 0x48, 0x89, 0x4C,
	0x24, 0x20, 0xBA, 0x00, 0x02, 0x00, 0x00, 0x44, 0x8B, 0xCA, 0x45, 0x33, 0xC0, 0x48, 0x8B, 0x4C,
	0x24, 0x40, 0xFF, 0x15, 0x10, 0xAE, 0xFF, 0xFF, 0x8B, 0xD8, 0x85, 0xC0, 0x0F, 0x88, 0xA3, 0x00,
	0x00, 0x00, 0x41, 0xB9, 0x04, 0x00, 0x00, 0x00, 0x4C, 0x8D, 0x84, 0x24, 0xB0, 0x00, 0x00, 0x00,
	0x41, 0x8D, 0x51, 0x1D, 0x48, 0x8B, 0x4C, 0x24, 0x48, 0xFF, 0x15, 0x29, 0xAE, 0xFF, 0xFF, 0x8B,
	0xD8, 0x48, 0x8B, 0x4C, 0x24, 0x48, 0xFF, 0x15, 0xFC, 0xAC, 0xFF, 0xFF, 0xEB, 0x77, 0x83, 0xFE,
	0x04, 0x75, 0x11, 0x41, 0x8B, 0x04, 0x24, 0x89, 0x84, 0x24, 0xB0, 0x00, 0x00, 0x00, 0xEB, 0x02,
	0x8B, 0xD8, 0xEB, 0x05, 0xBB, 0x04, 0x00, 0x00, 0xC0, 0x85, 0xDB, 0x78, 0x58, 0x48, 0x8B, 0x4C,
	0x24, 0x40, 0xE8, 0xDD, 0x99, 0xFF, 0xFF, 0x84, 0xC0, 0x74, 0x45, 0x48, 0x8D, 0x54, 0x24, 0x50,
	0x48, 0x8B, 0x4C, 0x24, 0x40, 0xFF, 0x15, 0xA5, 0xAD, 0xFF, 0xFF, 0x41, 0xB9, 0x04, 0x00, 0x00,
	0x00, 0x4C, 0x8D, 0x84, 0x24, 0xB0, 0x00, 0x00, 0x00, 0x41, 0x8D, 0x51, 0x1E, 0x48, 0x83, 0xC9,
	0xFF, 0xFF, 0x15, 0xC1, 0xAD, 0xFF, 0xFF, 0x8B, 0xD8, 0x48, 0x8D, 0x4C, 0x24, 0x50, 0xFF, 0x15,
	0x04, 0xAD, 0xFF, 0xFF, 0x48, 0x8B, 0x4C, 0x24, 0x40, 0xE8, 0xE2, 0x99, 0xFF, 0xFF, 0xEB, 0x05,
	0xBB, 0x0A, 0x01, 0x00, 0xC0, 0x48, 0x8B, 0x4C, 0x24, 0x40, 0xFF, 0x15, 0x40, 0xAD, 0xFF, 0xFF,
	0x8B, 0xC3, 0x4C, 0x8D, 0x9C, 0x24, 0x80, 0x00, 0x00, 0x00, 0x49, 0x8B, 0x5B, 0x10, 0x49, 0x8B,
	0x73, 0x18, 0x49, 0x8B, 0x7B, 0x20, 0x4D, 0x8B, 0x63, 0x28, 0x49, 0x8B, 0xE3, 0x41, 0x5D, 0xC3,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x8B, 0xC4, 0x48, 0x89, 0x58, 0x08, 0x48,
	0x89, 0x70, 0x10, 0x48, 0x89, 0x78, 0x18, 0x4C, 0x89, 0x60, 0x20, 0x41, 0x55, 0x41, 0x56, 0x41,
	0x57, 0x48, 0x83, 0xEC, 0x40, 0x45, 0x8B, 0xE9, 0x49, 0x8B, 0xF0, 0x44, 0x8B, 0xE2, 0x4C, 0x8B,
	0xF1, 0x8A, 0x9C, 0x24, 0x88, 0x00, 0x00, 0x00, 0x45, 0x33, 0xFF, 0x41, 0x3A, 0xDF, 0x74, 0x35,
	0x49, 0x8B, 0xD5, 0x45, 0x8D, 0x47, 0x01, 0x48, 0x8B, 0xCE, 0xFF, 0x15, 0xF0, 0xAB, 0xFF, 0xFF,
	0x48, 0x8B, 0xBC, 0x24, 0x80, 0x00, 0x00, 0x00, 0x49, 0x3B, 0xFF, 0x74, 0x11, 0x41, 0x8D, 0x57,
	0x04, 0x45, 0x8D, 0x47, 0x01, 0x48, 0x8B, 0xCF, 0xFF, 0x15, 0xD2, 0xAB, 0xFF, 0xFF, 0xEB, 0x0D,
	0xE9, 0x71, 0x01, 0x00, 0x00, 0x48, 0x8B, 0xBC, 0x24, 0x80, 0x00, 0x00, 0x00, 0x4C, 0x89, 0x7C,
	0x24, 0x28, 0x48, 0x8D, 0x44, 0x24, 0x38, 0x48, 0x89, 0x44, 0x24, 0x20, 0x44, 0x8A, 0xCB, 0x4C,
	0x8B, 0x05, 0x52, 0xAC, 0xFF, 0xFF, 0x4D, 0x8B, 0x00, 0x33, 0xD2, 0x49, 0x8B, 0xCE, 0xFF, 0x15,
	0x54, 0xAC, 0xFF, 0xFF, 0x8B, 0xD8, 0x41, 0x3B, 0xC7, 0x0F, 0x8C, 0x37, 0x01, 0x00, 0x00, 0x45,
	0x3B, 0xE7, 0x0F, 0x84, 0xE9, 0x00, 0x00, 0x00, 0x41, 0x83, 0xEC, 0x01, 0x0F, 0x84, 0x9C, 0x00,
	0x00, 0x00, 0x41, 0x83, 0xFC, 0x01, 0x74, 0x0E, 0xBB, 0x03, 0x00, 0x00, 0xC0, 0x89, 0x5C, 0x24,
	0x30, 0xE9, 0xFF, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x44, 0x24, 0x38, 0x4C, 0x39, 0x78, 0x30, 0x74,
	0x4D, 0x49, 0x3B, 0xF7, 0x74, 0x27, 0x48, 0x8B, 0x50, 0x30, 0x48, 0x83, 0xC2, 0x18, 0x0F, 0xB7,
	0x0A, 0x48, 0x83, 0xC1, 0x10, 0x49, 0x3B, 0xCD, 0x77, 0x0A, 0x48, 0x8B, 0xCE, 0xE8, 0x0A, 0x01,
	0x00, 0x00, 0xEB, 0x09, 0xBB, 0x23, 0x00, 0x00, 0xC0, 0x89, 0x5C, 0x24, 0x30, 0x49, 0x3B, 0xFF,
	0x0F, 0x84, 0xBF, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x44, 0x24, 0x38, 0x48, 0x8B, 0x48, 0x30, 0x0F,
	0xB7, 0x41, 0x18, 0x48, 0x83, 0xC0, 0x10, 0x89, 0x07, 0xE9, 0xA7, 0x00, 0x00, 0x00, 0x49, 0x3B,
	0xF7, 0x74, 0x1E, 0x41, 0x83, 0xFD, 0x10, 0x72, 0x0F, 0x66, 0x44, 0x89, 0x3E, 0x66, 0x44, 0x89,
	0x7E, 0x02, 0x4C, 0x89, 0x7E, 0x08, 0xEB, 0x09, 0xBB, 0x23, 0x00, 0x00, 0xC0, 0x89, 0x5C, 0x24,
	0x30, 0x49, 0x3B, 0xFF, 0x74, 0x7F, 0xC7, 0x07, 0x10, 0x00, 0x00, 0x00, 0xEB, 0x77, 0x49, 0x3B,
	0xF7, 0x74, 0x28, 0x48, 0x8B, 0x54, 0x24, 0x38, 0x48, 0x83, 0xC2, 0x38, 0x0F, 0xB7, 0x0A, 0x48,
	0x83, 0xC1, 0x10, 0x49, 0x3B, 0xCD, 0x77, 0x0A, 0x48, 0x8B, 0xCE, 0xE8, 0x8C, 0x00, 0x00, 0x00,
	0xEB, 0x09, 0xBB, 0x23, 0x00, 0x00, 0xC0, 0x89, 0x5C, 0x24, 0x30, 0x49, 0x3B, 0xFF, 0x74, 0x45,
	0x48, 0x8B, 0x44, 0x24, 0x38, 0x0F, 0xB7, 0x48, 0x38, 0x48, 0x83, 0xC1, 0x10, 0x89, 0x0F, 0xEB,
	0x34, 0x41, 0x83, 0xFD, 0x18, 0x75, 0x1A, 0x48, 0x8B, 0x4C, 0x24, 0x38, 0x8B, 0x41, 0x10, 0x89,
	0x06, 0x48, 0x8B, 0x41, 0x18, 0x48, 0x89, 0x46, 0x08, 0x8B, 0x41, 0x20, 0x89, 0x46, 0x10, 0xEB,
	0x09, 0xBB, 0x04, 0x00, 0x00, 0xC0, 0x89, 0x5C, 0x24, 0x30, 0x49, 0x3B, 0xFF, 0x74, 0x06, 0xC7,
	0x07, 0x18, 0x00, 0x00, 0x00, 0xEB, 0x02, 0x8B, 0xD8, 0x48, 0x8B, 0x4C, 0x24, 0x38, 0xFF, 0x15,
	0x3C, 0xAB, 0xFF, 0xFF, 0x8B, 0xC3, 0x48, 0x8B, 0x5C, 0x24, 0x60, 0x48, 0x8B, 0x74, 0x24, 0x68,
	0x48, 0x8B, 0x7C, 0x24, 0x70, 0x4C, 0x8B, 0x64, 0x24, 0x78, 0x48, 0x83, 0xC4, 0x40, 0x41, 0x5F,
	0x41, 0x5E, 0x41, 0x5D, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x28,
	0x33, 0xC0, 0x4C, 0x8B, 0xC1, 0x48, 0x3B, 0xD0, 0x74, 0x20, 0x0F, 0xB7, 0x02, 0x66, 0x89, 0x01,
	0x66, 0x89, 0x41, 0x02, 0x48, 0x83, 0xC1, 0x10, 0x49, 0x89, 0x48, 0x08, 0x48, 0x8B, 0x52, 0x08,
	0x4C, 0x8B, 0xC0, 0xE8, 0xF8, 0x98, 0xFF, 0xFF, 0xEB, 0x0B, 0x66, 0x89, 0x01, 0x66, 0x89, 0x41,
	0x02, 0x48, 0x89, 0x41, 0x08, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x74, 0x24, 0x10, 0x48, 0x89, 0x7C, 0x24, 0x18, 0x41,
	0x54, 0x48, 0x83, 0xEC, 0x60, 0x41, 0x8A, 0xF1, 0x49, 0x8B, 0xD8, 0x44, 0x8B, 0xE2, 0x48, 0x8B,
	0xF9, 0x45, 0x84, 0xC9, 0x74, 0x31, 0xBA, 0x08, 0x00, 0x00, 0x00, 0x44, 0x8B, 0xC2, 0xFF, 0x15,
	0xBC, 0xA9, 0xFF, 0xFF, 0xBA, 0x10, 0x00, 0x00, 0x00, 0x44, 0x8D, 0x42, 0xF4, 0x48, 0x8B, 0xCB,
	0xFF, 0x15, 0xF2, 0xA9, 0xFF, 0xFF, 0xF3, 0x0F, 0x6F, 0x2B, 0xF3, 0x0F, 0x7F, 0x6C, 0x24, 0x50,
	0xEB, 0x10, 0xE9, 0x9A, 0x00, 0x00, 0x00, 0xF3, 0x41, 0x0F, 0x6F, 0x00, 0xF3, 0x0F, 0x7F, 0x44,
	0x24, 0x50, 0x48, 0x83, 0x7C, 0x24, 0x50, 0x00, 0x74, 0x14, 0x4C, 0x8D, 0x44, 0x24, 0x40, 0x33,
	0xD2, 0x48, 0x8D, 0x4C, 0x24, 0x50, 0xFF, 0x15, 0xBC, 0xAA, 0xFF, 0xFF, 0xEB, 0x10, 0x48, 0x8D,
	0x54, 0x24, 0x40, 0x48, 0x8B, 0x4C, 0x24, 0x58, 0xFF, 0x15, 0x2A, 0xAB, 0xFF, 0xFF, 0x85, 0xC0,
	0x78, 0x5F, 0x48, 0x8D, 0x44, 0x24, 0x48, 0x48, 0x89, 0x44, 0x24, 0x30, 0xC6, 0x44, 0x24, 0x28,
	0x00, 0x48, 0x8B, 0x05, 0xF8, 0xAA, 0xFF, 0xFF, 0x48, 0x8B, 0x08, 0x48, 0x89, 0x4C, 0x24, 0x20,
	0x45, 0x8B, 0xCC, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x48, 0x8B, 0x4C, 0x24, 0x40, 0xFF, 0x15, 0x25,
	0xAA, 0xFF, 0xFF, 0x8B, 0xD8, 0x48, 0x8B, 0x4C, 0x24, 0x40, 0xFF, 0x15, 0x00, 0xAA, 0xFF, 0xFF,
	0x85, 0xDB, 0x78, 0x1B, 0x40, 0x84, 0xF6, 0x74, 0x0E, 0x48, 0x8B, 0x4C, 0x24, 0x48, 0x48, 0x89,
	0x0F, 0xEB, 0x02, 0x8B, 0xD8, 0xEB, 0x08, 0x48, 0x8B, 0x44, 0x24, 0x48, 0x48, 0x89, 0x07, 0x8B,
	0xC3, 0x4C, 0x8D, 0x5C, 0x24, 0x60, 0x49, 0x8B, 0x5B, 0x10, 0x49, 0x8B, 0x73, 0x18, 0x49, 0x8B,
	0x7B, 0x20, 0x49, 0x8B, 0xE3, 0x41, 0x5C, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x74, 0x24, 0x10, 0x48, 0x89, 0x7C, 0x24, 0x18, 0x41,
	0x54, 0x48, 0x83, 0xEC, 0x50, 0x41, 0x8A, 0xF1, 0x49, 0x8B, 0xD8, 0x44, 0x8B, 0xE2, 0x48, 0x8B,
	0xF9, 0x45, 0x84, 0xC9, 0x74, 0x18, 0xBA, 0x08, 0x00, 0x00, 0x00, 0x44, 0x8B, 0xC2, 0x48, 0x8B,
	0xCB, 0xFF, 0x15, 0xA9, 0xA8, 0xFF, 0xFF, 0xEB, 0x05, 0xE9, 0x94, 0x00, 0x00, 0x00, 0x48, 0x83,
	0x64, 0x24, 0x28, 0x00, 0x48, 0x8D, 0x44, 0x24, 0x40, 0x48, 0x89, 0x44, 0x24, 0x20, 0x44, 0x8A,
	0xCE, 0x4C, 0x8B, 0x05, 0x38, 0xAA, 0xFF, 0xFF, 0x4D, 0x8B, 0x00, 0x33, 0xD2, 0x48, 0x8B, 0xCF,
	0xFF, 0x15, 0x32, 0xA9, 0xFF, 0xFF, 0x85, 0xC0, 0x78, 0x68, 0x48, 0x8B, 0x4C, 0x24, 0x40, 0xFF,
	0x15, 0xCB, 0xA9, 0xFF, 0xFF, 0x48, 0x8D, 0x4C, 0x24, 0x48, 0x48, 0x89, 0x4C, 0x24, 0x30, 0xC6,
	0x44, 0x24, 0x28, 0x00, 0x48, 0x8B, 0x0D, 0xBD, 0xA8, 0xFF, 0xFF, 0x48, 0x8B, 0x11, 0x48, 0x89,
	0x54, 0x24, 0x20, 0x45, 0x8B, 0xCC, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x48, 0x8B, 0xC8, 0xFF, 0x15,
	0x34, 0xA9, 0xFF, 0xFF, 0x8B, 0xF8, 0x48, 0x8B, 0x4C, 0x24, 0x40, 0xFF, 0x15, 0x0F, 0xA9, 0xFF,
	0xFF, 0x85, 0xFF, 0x78, 0x1B, 0x40, 0x84, 0xF6, 0x74, 0x0E, 0x48, 0x8B, 0x4C, 0x24, 0x48, 0x48,
	0x89, 0x0B, 0xEB, 0x02, 0x8B, 0xF8, 0xEB, 0x08, 0x48, 0x8B, 0x44, 0x24, 0x48, 0x48, 0x89, 0x03,
	0x8B, 0xC7, 0x48, 0x8B, 0x5C, 0x24, 0x60, 0x48, 0x8B, 0x74, 0x24, 0x68, 0x48, 0x8B, 0x7C, 0x24,
	0x70, 0x48, 0x83, 0xC4, 0x50, 0x41, 0x5C, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0x48, 0x89, 0x5C, 0x24, 0x08, 0x57, 0x48, 0x83, 0xEC, 0x20, 0x83, 0x3D, 0xF3, 0xBA, 0xFF, 0xFF,
	0x00, 0x8B, 0xFA, 0x48, 0x8B, 0xD9, 0x74, 0x07, 0xB8, 0xBB, 0x00, 0x00, 0xC0, 0xEB, 0x5A, 0x48,
	0x8D, 0x0D, 0x2A, 0xB9, 0xFF, 0xFF, 0xE8, 0x51, 0x93, 0xFF, 0xFF, 0x4C, 0x8B, 0xD8, 0x48, 0x85,
	0xC0, 0x74, 0xE5, 0x8B, 0x05, 0x87, 0xB9, 0xFF, 0xFF, 0x83, 0xF8, 0x33, 0x75, 0x0A, 0x8B, 0xD7,
	0x48, 0x8B, 0xCB, 0x41, 0xFF, 0xD3, 0xEB, 0x31, 0x83, 0xF8, 0x34, 0x74, 0x14, 0x83, 0xF8, 0x3C,
	0x74, 0x0F, 0x83, 0xF8, 0x3D, 0x74, 0x0A, 0x83, 0xF8, 0x3E, 0x74, 0x05, 0x83, 0xF8, 0x3F, 0x75,
	0xB7, 0x65, 0x48, 0x8B, 0x04, 0x25, 0x88, 0x01, 0x00, 0x00, 0x8B, 0xD7, 0x48, 0x8B, 0xCB, 0x48,
	0x3B, 0xD8, 0x41, 0x0F, 0x94, 0xC0, 0x41, 0xFF, 0xD3, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x83,
	0xC4, 0x20, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x8B, 0xC4, 0x53,
	0x48, 0x81, 0xEC, 0xC0, 0x00, 0x00, 0x00, 0x48, 0x83, 0x64, 0x24, 0x28, 0x00, 0x45, 0x8A, 0xC8,
	0x4C, 0x8B, 0x05, 0xF9, 0xA8, 0xFF, 0xFF, 0x4D, 0x8B, 0x00, 0x48, 0x8D, 0x40, 0x20, 0x8B, 0xDA,
	0x33, 0xD2, 0x48, 0x89, 0x44, 0x24, 0x20, 0xFF, 0x15, 0xEB, 0xA7, 0xFF, 0xFF, 0x85, 0xC0, 0x0F,
	0x88, 0xBE, 0x00, 0x00, 0x00, 0x65, 0x48, 0x8B, 0x04, 0x25, 0x88, 0x01, 0x00, 0x00, 0x48, 0x39,
	0x84, 0x24, 0xE8, 0x00, 0x00, 0x00, 0x0F, 0x84, 0x92, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8C, 0x24,
	0x98, 0x00, 0x00, 0x00, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x89, 0x9C, 0x24, 0xB0, 0x00, 0x00, 0x00,
	0xFF, 0x15, 0x82, 0xA8, 0xFF, 0xFF, 0x48, 0x83, 0x64, 0x24, 0x38, 0x00, 0x48, 0x8B, 0x94, 0x24,
	0xE8, 0x00, 0x00, 0x00, 0xC6, 0x44, 0x24, 0x30, 0x00, 0x48, 0x83, 0x64, 0x24, 0x28, 0x00, 0x48,
	0x83, 0x64, 0x24, 0x20, 0x00, 0x4C, 0x8D, 0x0D, 0x78, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24,
	0x40, 0x45, 0x33, 0xC0, 0xFF, 0x15, 0x36, 0xA8, 0xFF, 0xFF, 0x48, 0x8D, 0x54, 0x24, 0x40, 0x48,
	0x8D, 0x4C, 0x24, 0x40, 0x41, 0xB9, 0x02, 0x00, 0x00, 0x00, 0x45, 0x33, 0xC0, 0xFF, 0x15, 0x2D,
	0xA8, 0xFF, 0xFF, 0x84, 0xC0, 0x74, 0x20, 0x48, 0x83, 0x64, 0x24, 0x20, 0x00, 0x48, 0x8D, 0x8C,
	0x24, 0x98, 0x00, 0x00, 0x00, 0x45, 0x33, 0xC9, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0xFF, 0x15, 0x35,
	0xA8, 0xFF, 0xFF, 0x8B, 0xD8, 0xEB, 0x0C, 0xBB, 0x01, 0x00, 0x00, 0xC0, 0xEB, 0x05, 0xBB, 0xDB,
	0x00, 0x00, 0xC0, 0x48, 0x8B, 0x8C, 0x24, 0xE8, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x4F, 0xA7, 0xFF,
	0xFF, 0x8B, 0xC3, 0x48, 0x81, 0xC4, 0xC0, 0x00, 0x00, 0x00, 0x5B, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0x40, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x49, 0x8B, 0x09, 0x45, 0x33, 0xC0,
	0x33, 0xD2, 0x8B, 0x59, 0x70, 0x48, 0x83, 0xC1, 0x58, 0xFF, 0x15, 0xB9, 0xA7, 0xFF, 0xFF, 0x65,
	0x48, 0x8B, 0x0C, 0x25, 0x88, 0x01, 0x00, 0x00, 0x8B, 0xD3, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xE9,
	0x3C, 0xFE, 0xFF, 0xFF, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x8B, 0xC4, 0x48,
	0x89, 0x58, 0x18, 0x4C, 0x89, 0x48, 0x20, 0x89, 0x50, 0x10, 0x48, 0x89, 0x48, 0x08, 0x56, 0x57,
	0x41, 0x54, 0x41, 0x55, 0x41, 0x57, 0x48, 0x81, 0xEC, 0xF0, 0x00, 0x00, 0x00, 0x45, 0x8B, 0xF8,
	0x48, 0x8B, 0xD9, 0x45, 0x33, 0xE4, 0x41, 0x83, 0xF8, 0x40, 0x76, 0x0A, 0xB8, 0xF1, 0x00, 0x00,
	0xC0, 0xE9, 0x7C, 0x02, 0x00, 0x00, 0x45, 0x8B, 0xE8, 0x41, 0xC1, 0xE5, 0x03, 0x44, 0x38, 0xA4,
	0x24, 0x50, 0x01, 0x00, 0x00, 0x74, 0x65, 0x41, 0x8B, 0xD5, 0x41, 0xB8, 0x08, 0x00, 0x00, 0x00,
	0x49, 0x8B, 0xC9, 0xFF, 0x15, 0xC7, 0xA5, 0xFF, 0xFF, 0x48, 0x8B, 0xB4, 0x24, 0x40, 0x01, 0x00,
	0x00, 0x48, 0x85, 0xF6, 0x74, 0x16, 0xBB, 0x04, 0x00, 0x00, 0x00, 0x44, 0x8B, 0xC3, 0x48, 0x8B,
	0xD3, 0x48, 0x8B, 0xCE, 0xFF, 0x15, 0xA6, 0xA5, 0xFF, 0xFF, 0xEB, 0x05, 0xBB, 0x04, 0x00, 0x00,
	0x00, 0x48, 0x8B, 0xBC, 0x24, 0x48, 0x01, 0x00, 0x00, 0x48, 0x85, 0xFF, 0x74, 0x0F, 0x44, 0x8B,
	0xC3, 0x48, 0x8B, 0xD3, 0x48, 0x8B, 0xCF, 0xFF, 0x15, 0x83, 0xA5, 0xFF, 0xFF, 0x48, 0x8B, 0x9C,
	0x24, 0x20, 0x01, 0x00, 0x00, 0xEB, 0x15, 0xE9, 0x06, 0x02, 0x00, 0x00, 0x48, 0x8B, 0xBC, 0x24,
	0x48, 0x01, 0x00, 0x00, 0x48, 0x8B, 0xB4, 0x24, 0x40, 0x01, 0x00, 0x00, 0x45, 0x85, 0xED, 0x75,
	0x39, 0x44, 0x38, 0xAC, 0x24, 0x50, 0x01, 0x00, 0x00, 0x74, 0x17, 0x48, 0x85, 0xF6, 0x74, 0x03,
	0x44, 0x21, 0x2E, 0x48, 0x85, 0xFF, 0x74, 0x03, 0x83, 0x27, 0x00, 0xEB, 0x03, 0x44, 0x8B, 0xE0,
	0xEB, 0x10, 0x48, 0x85, 0xF6, 0x74, 0x03, 0x83, 0x26, 0x00, 0x48, 0x85, 0xFF, 0x74, 0x03, 0x83,
	0x27, 0x00, 0x41, 0x8B, 0xC4, 0xE9, 0xB8, 0x01, 0x00, 0x00, 0x41, 0x8B, 0xD5, 0x33, 0xC9, 0x41,
	0xB8, 0x4B, 0x70, 0x68, 0x62, 0xFF, 0x15, 0xF5, 0xA4, 0xFF, 0xFF, 0x4C, 0x8B, 0xE8, 0x48, 0x89,
	0x44, 0x24, 0x40, 0x48, 0x85, 0xC0, 0x75, 0x0A, 0xB8, 0x9A, 0x00, 0x00, 0xC0, 0xE9, 0x90, 0x01,
	0x00, 0x00, 0x8B, 0x84, 0x24, 0x28, 0x01, 0x00, 0x00, 0x89, 0x84, 0x24, 0xD8, 0x00, 0x00, 0x00,
	0x44, 0x89, 0xBC, 0x24, 0xDC, 0x00, 0x00, 0x00, 0x4C, 0x89, 0xAC, 0x24, 0xE0, 0x00, 0x00, 0x00,
	0x65, 0x48, 0x8B, 0x04, 0x25, 0x88, 0x01, 0x00, 0x00, 0x48, 0x3B, 0xD8, 0x75, 0x49, 0x48, 0x8D,
	0x44, 0x24, 0x60, 0x48, 0x89, 0x44, 0x24, 0x48, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x88, 0x44, 0x24,
	0x60, 0x44, 0x0F, 0x20, 0xC3, 0x44, 0x0F, 0x22, 0xC0, 0x48, 0x8D, 0x44, 0x24, 0x50, 0x48, 0x89,
	0x44, 0x24, 0x20, 0x4C, 0x8D, 0x4C, 0x24, 0x48, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x48, 0x8D, 0x4C,
	0x24, 0x68, 0xE8, 0x49, 0x01, 0x00, 0x00, 0x44, 0x0F, 0xB6, 0xDB, 0x45, 0x0F, 0x22, 0xC3, 0x45,
	0x33, 0xFF, 0xE9, 0x89, 0x00, 0x00, 0x00, 0x45, 0x33, 0xFF, 0x44, 0x88, 0x7C, 0x24, 0x60, 0x45,
	0x33, 0xC0, 0x33, 0xD2, 0x48, 0x8D, 0x8C, 0x24, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x15, 0xF6, 0xA5,
	0xFF, 0xFF, 0x4C, 0x89, 0x7C, 0x24, 0x38, 0x44, 0x88, 0x7C, 0x24, 0x30, 0x4C, 0x89, 0x7C, 0x24,
	0x28, 0x4C, 0x89, 0x7C, 0x24, 0x20, 0x4C, 0x8D, 0x0D, 0x03, 0x01, 0x00, 0x00, 0x45, 0x33, 0xC0,
	0x48, 0x8B, 0xD3, 0x48, 0x8D, 0x4C, 0x24, 0x68, 0xFF, 0x15, 0xB2, 0xA5, 0xFF, 0xFF, 0x45, 0x8D,
	0x4F, 0x02, 0x45, 0x33, 0xC0, 0x48, 0x8D, 0x54, 0x24, 0x60, 0x48, 0x8D, 0x4C, 0x24, 0x68, 0xFF,
	0x15, 0xAB, 0xA5, 0xFF, 0xFF, 0x41, 0x3A, 0xC7, 0x74, 0x20, 0x4C, 0x89, 0x7C, 0x24, 0x20, 0x45,
	0x33, 0xC9, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x48, 0x8D, 0x8C, 0x24, 0xC0, 0x00, 0x00, 0x00, 0xFF,
	0x15, 0xB3, 0xA5, 0xFF, 0xFF, 0x44, 0x8B, 0xE0, 0xEB, 0x06, 0x41, 0xBC, 0x01, 0x00, 0x00, 0xC0,
	0x45, 0x3B, 0xE7, 0x7C, 0x7C, 0x44, 0x38, 0xBC, 0x24, 0x50, 0x01, 0x00, 0x00, 0x74, 0x3F, 0x8B,
	0x9C, 0x24, 0xE8, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0xC3, 0x49, 0xC1, 0xE0, 0x03, 0x49, 0x8B, 0xD5,
	0x48, 0x8B, 0x8C, 0x24, 0x38, 0x01, 0x00, 0x00, 0xE8, 0xC3, 0x92, 0xFF, 0xFF, 0x49, 0x3B, 0xF7,
	0x74, 0x02, 0x89, 0x1E, 0x49, 0x3B, 0xFF, 0x74, 0x09, 0x8B, 0x84, 0x24, 0xEC, 0x00, 0x00, 0x00,
	0x89, 0x07, 0xEB, 0x08, 0x44, 0x8B, 0xE0, 0x4C, 0x8B, 0x6C, 0x24, 0x40, 0xEB, 0x33, 0x8B, 0x9C,
	0x24, 0xE8, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0xC3, 0x49, 0xC1, 0xE0, 0x03, 0x49, 0x8B, 0xD5, 0x48,
	0x8B, 0x8C, 0x24, 0x38, 0x01, 0x00, 0x00, 0xE8, 0x84, 0x92, 0xFF, 0xFF, 0x49, 0x3B, 0xF7, 0x74,
	0x02, 0x89, 0x1E, 0x49, 0x3B, 0xFF, 0x74, 0x09, 0x8B, 0x84, 0x24, 0xEC, 0x00, 0x00, 0x00, 0x89,
	0x07, 0xBA, 0x4B, 0x70, 0x68, 0x62, 0x49, 0x8B, 0xCD, 0xFF, 0x15, 0x59, 0xA3, 0xFF, 0xFF, 0x41,
	0x8B, 0xC4, 0x48, 0x8B, 0x9C, 0x24, 0x30, 0x01, 0x00, 0x00, 0x48, 0x81, 0xC4, 0xF0, 0x00, 0x00,
	0x00, 0x41, 0x5F, 0x41, 0x5D, 0x41, 0x5C, 0x5F, 0x5E, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0x40, 0x53, 0x48, 0x83, 0xEC, 0x30, 0x49, 0x8B, 0x19, 0x45, 0x33, 0xC0, 0x4C, 0x8B, 0x8B, 0x80,
	0x00, 0x00, 0x00, 0x8B, 0x53, 0x7C, 0x8B, 0x4B, 0x78, 0x48, 0x8D, 0x83, 0x8C, 0x00, 0x00, 0x00,
	0x48, 0x89, 0x44, 0x24, 0x20, 0xE8, 0xCA, 0x90, 0xFF, 0xFF, 0x80, 0x3B, 0x00, 0x89, 0x83, 0x88,
	0x00, 0x00, 0x00, 0x75, 0x0F, 0x48, 0x8D, 0x4B, 0x60, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0xFF, 0x15,
	0x84, 0xA4, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x30, 0x5B, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0x48, 0x8B, 0xC4, 0x48, 0x89, 0x58, 0x08, 0x48, 0x89, 0x70, 0x10, 0x48, 0x89, 0x78, 0x18, 0x4C,
	0x89, 0x60, 0x20, 0x41, 0x55, 0x41, 0x56, 0x41, 0x57, 0x48, 0x83, 0xEC, 0x60, 0x45, 0x8B, 0xE9,
	0x4D, 0x8B, 0xF8, 0x44, 0x8B, 0xE2, 0x48, 0x8B, 0xD9, 0x44, 0x8A, 0xB4, 0x24, 0xA8, 0x00, 0x00,
	0x00, 0x45, 0x84, 0xF6, 0x74, 0x37, 0x49, 0x8B, 0xD5, 0xBF, 0x04, 0x00, 0x00, 0x00, 0x44, 0x8B,
	0xC7, 0x49, 0x8B, 0xCF, 0xFF, 0x15, 0xB6, 0xA2, 0xFF, 0xFF, 0x48, 0x8B, 0xB4, 0x24, 0xA0, 0x00,
	0x00, 0x00, 0x48, 0x85, 0xF6, 0x74, 0x0F, 0x44, 0x8B, 0xC7, 0x48, 0x8B, 0xD7, 0x48, 0x8B, 0xCE,
	0xFF, 0x15, 0x9A, 0xA2, 0xFF, 0xFF, 0xEB, 0x12, 0xE9, 0x70, 0x01, 0x00, 0x00, 0xBF, 0x04, 0x00,
	0x00, 0x00, 0x48, 0x8B, 0xB4, 0x24, 0xA0, 0x00, 0x00, 0x00, 0x48, 0x83, 0x64, 0x24, 0x28, 0x00,
	0x48, 0x8D, 0x44, 0x24, 0x48, 0x48, 0x89, 0x44, 0x24, 0x20, 0x45, 0x8A, 0xCE, 0x4C, 0x8B, 0x05,
	0x1C, 0xA4, 0xFF, 0xFF, 0x4D, 0x8B, 0x00, 0x33, 0xD2, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0x16, 0xA3,
	0xFF, 0xFF, 0x8B, 0xD8, 0x89, 0x44, 0x24, 0x40, 0x85, 0xC0, 0x0F, 0x88, 0x2D, 0x01, 0x00, 0x00,
	0x41, 0x83, 0xEC, 0x01, 0x0F, 0x84, 0xC4, 0x00, 0x00, 0x00, 0x41, 0x83, 0xFC, 0x02, 0x74, 0x10,
	0xBB, 0x03, 0x00, 0x00, 0xC0, 0x89, 0x5C, 0x24, 0x40, 0x33, 0xFF, 0xE9, 0xEA, 0x00, 0x00, 0x00,
	0x48, 0x8D, 0x44, 0x24, 0x50, 0x48, 0x89, 0x44, 0x24, 0x30, 0xC6, 0x44, 0x24, 0x28, 0x00, 0x48,
	0x8B, 0x05, 0xCA, 0xA3, 0xFF, 0xFF, 0x48, 0x8B, 0x08, 0x48, 0x89, 0x4C, 0x24, 0x20, 0x41, 0xB9,
	0x40, 0x00, 0x00, 0x00, 0x45, 0x33, 0xC0, 0xBA, 0x00, 0x02, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24,
	0x48, 0xFF, 0x15, 0xF1, 0xA2, 0xFF, 0xFF, 0x8B, 0xD8, 0x89, 0x44, 0x24, 0x40, 0x85, 0xC0, 0x0F,
	0x88, 0xA5, 0x00, 0x00, 0x00, 0x48, 0x83, 0x64, 0x24, 0x20, 0x00, 0x44, 0x8B, 0xCF, 0x4C, 0x8D,
	0x44, 0x24, 0x44, 0xBA, 0x16, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x50, 0xFF, 0x15, 0xBD,
	0xA2, 0xFF, 0xFF, 0x8B, 0xD8, 0x89, 0x44, 0x24, 0x40, 0x85, 0xC0, 0x78, 0x34, 0x44, 0x3B, 0xEF,
	0x75, 0x26, 0x8B, 0x44, 0x24, 0x44, 0x41, 0x89, 0x07, 0xEB, 0x1B, 0x8B, 0xD8, 0x89, 0x44, 0x24,
	0x40, 0xBF, 0x04, 0x00, 0x00, 0x00, 0x44, 0x8A, 0xB4, 0x24, 0xA8, 0x00, 0x00, 0x00, 0x48, 0x8B,
	0xB4, 0x24, 0xA0, 0x00, 0x00, 0x00, 0xEB, 0x09, 0xBB, 0x04, 0x00, 0x00, 0xC0, 0x89, 0x5C, 0x24,
	0x40, 0x48, 0x8B, 0x4C, 0x24, 0x50, 0xFF, 0x15, 0x9C, 0xA1, 0xFF, 0xFF, 0xEB, 0x3C, 0x48, 0x8B,
	0x4C, 0x24, 0x48, 0xFF, 0x15, 0x0F, 0xA3, 0xFF, 0xFF, 0x41, 0x83, 0xFD, 0x08, 0x75, 0x1D, 0x49,
	0x89, 0x07, 0xEB, 0x16, 0x8B, 0xD8, 0x89, 0x44, 0x24, 0x40, 0x44, 0x8A, 0xB4, 0x24, 0xA8, 0x00,
	0x00, 0x00, 0x48, 0x8B, 0xB4, 0x24, 0xA0, 0x00, 0x00, 0x00, 0xEB, 0x09, 0xBB, 0x04, 0x00, 0x00,
	0xC0, 0x89, 0x5C, 0x24, 0x40, 0xBF, 0x08, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x48, 0xFF,
	0x15, 0x1B, 0xA2, 0xFF, 0xFF, 0x48, 0x85, 0xF6, 0x74, 0x11, 0x45, 0x84, 0xF6, 0x74, 0x0A, 0x89,
	0x3E, 0xEB, 0x04, 0x8B, 0x5C, 0x24, 0x40, 0xEB, 0x02, 0x89, 0x3E, 0x8B, 0xC3, 0x4C, 0x8D, 0x5C,
	0x24, 0x60, 0x49, 0x8B, 0x5B, 0x20, 0x49, 0x8B, 0x73, 0x28, 0x49, 0x8B, 0x7B, 0x30, 0x4D, 0x8B,
	0x63, 0x38, 0x49, 0x8B, 0xE3, 0x41, 0x5F, 0x41, 0x5E, 0x41, 0x5D, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x8B, 0xC4, 0x48, 0x89, 0x58, 0x08, 0x48, 0x89, 0x70, 0x10, 0x48,
	0x89, 0x78, 0x18, 0x4C, 0x89, 0x60, 0x20, 0x41, 0x55, 0x48, 0x83, 0xEC, 0x60, 0x41, 0x8B, 0xF1,
	0x4D, 0x8B, 0xE0, 0x8B, 0xFA, 0x48, 0x8B, 0xD9, 0x44, 0x8A, 0xAC, 0x24, 0x90, 0x00, 0x00, 0x00,
	0x45, 0x84, 0xED, 0x74, 0x19, 0x48, 0x8B, 0xD6, 0x41, 0xB8, 0x04, 0x00, 0x00, 0x00, 0x49, 0x8B,
	0xCC, 0xFF, 0x15, 0x01, 0xA1, 0xFF, 0xFF, 0xEB, 0x05, 0xE9, 0xB2, 0x01, 0x00, 0x00, 0x48, 0x83,
	0x64, 0x24, 0x28, 0x00, 0x48, 0x8D, 0x44, 0x24, 0x40, 0x48, 0x89, 0x44, 0x24, 0x20, 0x45, 0x8A,
	0xCD, 0x4C, 0x8B, 0x05, 0x48, 0xA2, 0xFF, 0xFF, 0x4D, 0x8B, 0x00, 0x33, 0xD2, 0x48, 0x8B, 0xCB,
	0xFF, 0x15, 0x42, 0xA1, 0xFF, 0xFF, 0x8B, 0xD8, 0x85, 0xC0, 0x0F, 0x88, 0x80, 0x01, 0x00, 0x00,
	0x83, 0xEF, 0x02, 0x0F, 0x84, 0xA2, 0x00, 0x00, 0x00, 0x83, 0xFF, 0x01, 0x74, 0x0A, 0xBB, 0x03,
	0x00, 0x00, 0xC0, 0xE9, 0x5B, 0x01, 0x00, 0x00, 0x83, 0xFE, 0x04, 0x75, 0x11, 0x41, 0x8B, 0x04,
	0x24, 0x89, 0x84, 0x24, 0x90, 0x00, 0x00, 0x00, 0xEB, 0x02, 0x8B, 0xD8, 0xEB, 0x05, 0xBB, 0x04,
	0x00, 0x00, 0xC0, 0x85, 0xDB, 0x0F, 0x88, 0x38, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x44, 0x24, 0x48,
	0x48, 0x89, 0x44, 0x24, 0x30, 0xC6, 0x44, 0x24, 0x28, 0x00, 0x48, 0x8B, 0x05, 0xDF, 0xA1, 0xFF,
	0xFF, 0x48, 0x8B, 0x08, 0x48, 0x89, 0x4C, 0x24, 0x20, 0x41, 0xB9, 0x20, 0x00, 0x00, 0x00, 0x45,
	0x33, 0xC0, 0xBA, 0x00, 0x02, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x40, 0xFF, 0x15, 0x06, 0xA1,
	0xFF, 0xFF, 0x8B, 0xD8, 0x85, 0xC0, 0x0F, 0x88, 0xF7, 0x00, 0x00, 0x00, 0x41, 0xB9, 0x04, 0x00,
	0x00, 0x00, 0x4C, 0x8D, 0x84, 0x24, 0x90, 0x00, 0x00, 0x00, 0x41, 0x8D, 0x51, 0x12, 0x48, 0x8B,
	0x4C, 0x24, 0x48, 0xFF, 0x15, 0x87, 0xA1, 0xFF, 0xFF, 0x8B, 0xD8, 0x48, 0x8B, 0x4C, 0x24, 0x48,
	0xFF, 0x15, 0xF2, 0x9F, 0xFF, 0xFF, 0xE9, 0xC8, 0x00, 0x00, 0x00, 0x33, 0xC9, 0x48, 0x89, 0x4C,
	0x24, 0x50, 0x83, 0xFE, 0x08, 0x75, 0x1C, 0x49, 0x8B, 0x0C, 0x24, 0x48, 0x89, 0x4C, 0x24, 0x50,
	0xEB, 0x0F, 0x8B, 0xD8, 0x44, 0x8A, 0xAC, 0x24, 0x90, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24,
	0x50, 0xEB, 0x05, 0xBB, 0x04, 0x00, 0x00, 0xC0, 0x85, 0xDB, 0x0F, 0x88, 0x93, 0x00, 0x00, 0x00,
	0x48, 0x83, 0x64, 0x24, 0x28, 0x00, 0x48, 0x8D, 0x44, 0x24, 0x58, 0x48, 0x89, 0x44, 0x24, 0x20,
	0x45, 0x8A, 0xCD, 0x4C, 0x8B, 0x05, 0xAE, 0xA0, 0xFF, 0xFF, 0x4D, 0x8B, 0x00, 0xBA, 0x04, 0x00,
	0x00, 0x00, 0xFF, 0x15, 0x30, 0xA0, 0xFF, 0xFF, 0x8B, 0xD8, 0x85, 0xC0, 0x78, 0x65, 0x48, 0x8D,
	0x44, 0x24, 0x48, 0x48, 0x89, 0x44, 0x24, 0x30, 0xC6, 0x44, 0x24, 0x28, 0x00, 0x48, 0x8B, 0x05,
	0x84, 0xA0, 0xFF, 0xFF, 0x48, 0x8B, 0x08, 0x48, 0x89, 0x4C, 0x24, 0x20, 0x41, 0xB9, 0x04, 0x00,
	0x00, 0x00, 0x45, 0x33, 0xC0, 0xBA, 0x00, 0x02, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x58, 0xFF,
	0x15, 0x33, 0xA0, 0xFF, 0xFF, 0x8B, 0xD8, 0x85, 0xC0, 0x78, 0x1D, 0x48, 0x8B, 0x54, 0x24, 0x48,
	0x48, 0x8B, 0x4C, 0x24, 0x40, 0xFF, 0x15, 0xDD, 0xA0, 0xFF, 0xFF, 0x8B, 0xD8, 0x48, 0x8B, 0x4C,
	0x24, 0x48, 0xFF, 0x15, 0x30, 0x9F, 0xFF, 0xFF, 0x48, 0x8B, 0x4C, 0x24, 0x58, 0xFF, 0x15, 0xED,
	0x9F, 0xFF, 0xFF, 0x48, 0x8B, 0x4C, 0x24, 0x40, 0xFF, 0x15, 0xE2, 0x9F, 0xFF, 0xFF, 0x8B, 0xC3,
	0x4C, 0x8D, 0x5C, 0x24, 0x60, 0x49, 0x8B, 0x5B, 0x10, 0x49, 0x8B, 0x73, 0x18, 0x49, 0x8B, 0x7B,
	0x20, 0x4D, 0x8B, 0x63, 0x28, 0x49, 0x8B, 0xE3, 0x41, 0x5D, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0x40, 0x53, 0x56, 0x57, 0x41, 0x55, 0x41, 0x56, 0x41, 0x57, 0x48, 0x81,
	0xEC, 0x98, 0x03, 0x00, 0x00, 0x48, 0x8B, 0x05, 0xA4, 0xAF, 0xFF, 0xFF, 0x48, 0x33, 0xC4, 0x48,
	0x89, 0x84, 0x24, 0x80, 0x03, 0x00, 0x00, 0x4C, 0x89, 0x8C, 0x24, 0x90, 0x00, 0x00, 0x00, 0x4C,
	0x89, 0x44, 0x24, 0x68, 0x48, 0x89, 0x94, 0x24, 0x88, 0x00, 0x00, 0x00, 0x48, 0x89, 0x8C, 0x24,
	0x80, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x84, 0x24, 0x00, 0x04, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24,
	0x78, 0x48, 0x89, 0x44, 0x24, 0x60, 0x48, 0x8D, 0x84, 0x24, 0xD0, 0x00, 0x00, 0x00, 0x48, 0x89,
	0x44, 0x24, 0x50, 0x33, 0xDB, 0x88, 0x5C, 0x24, 0x30, 0x88, 0x5C, 0x24, 0x32, 0x4C, 0x8B, 0xEA,
	0x48, 0x89, 0x54, 0x24, 0x58, 0x4D, 0x8B, 0xF9, 0x48, 0x8D, 0xB4, 0x24, 0x80, 0x01, 0x00, 0x00,
	0x48, 0x89, 0x74, 0x24, 0x38, 0xBF, 0x00, 0xC0, 0x00, 0x00, 0x48, 0x8B, 0x84, 0x24, 0xF0, 0x03,
	0x00, 0x00, 0x48, 0x3B, 0xC7, 0x48, 0x0F, 0x42, 0xF8, 0x4C, 0x8B, 0xF0, 0x48, 0x89, 0x44, 0x24,
	0x48, 0x4C, 0x3B, 0xF3, 0x0F, 0x84, 0x49, 0x03, 0x00, 0x00, 0x49, 0x3B, 0xFE, 0x49, 0x0F, 0x47,
	0xFE, 0x48, 0x81, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x76, 0x0A, 0xC6, 0x44, 0x24, 0x31, 0x01, 0xE9,
	0x9B, 0x00, 0x00, 0x00, 0x88, 0x5C, 0x24, 0x31, 0x48, 0x81, 0xFF, 0x00, 0x02, 0x00, 0x00, 0x77,
	0x2A, 0x48, 0x8D, 0x84, 0x24, 0x80, 0x01, 0x00, 0x00, 0x48, 0x3B, 0xF0, 0x74, 0x0E, 0xBA, 0x4B,
	0x70, 0x68, 0x43, 0x48, 0x8B, 0xCE, 0xFF, 0x15, 0xDC, 0x9D, 0xFF, 0xFF, 0x48, 0x8D, 0xB4, 0x24,
	0x80, 0x01, 0x00, 0x00, 0x48, 0x89, 0x74, 0x24, 0x38, 0xEB, 0x64, 0x48, 0x8D, 0x84, 0x24, 0x80,
	0x01, 0x00, 0x00, 0x48, 0x3B, 0xF0, 0x75, 0x57, 0x41, 0xB8, 0x4B, 0x70, 0x68, 0x43, 0x48, 0x8B,
	0xD7, 0x33, 0xC9, 0xFF, 0x15, 0xA7, 0x9D, 0xFF, 0xFF, 0x48, 0x8B, 0xF0, 0x48, 0x89, 0x44, 0x24,
	0x38, 0x48, 0x3B, 0xC3, 0x75, 0x39, 0x48, 0xD1, 0xEF, 0x48, 0x81, 0xFF, 0x00, 0x02, 0x00, 0x00,
	0x76, 0x20, 0x41, 0xB8, 0x4B, 0x70, 0x68, 0x43, 0x48, 0x8B, 0xD7, 0x33, 0xC9, 0xFF, 0x15, 0x7D,
	0x9D, 0xFF, 0xFF, 0x48, 0x8B, 0xF0, 0x48, 0x89, 0x44, 0x24, 0x38, 0x48, 0x3B, 0xC3, 0x74, 0xD6,
	0xEB, 0x0D, 0x48, 0x8D, 0xB4, 0x24, 0x80, 0x01, 0x00, 0x00, 0x48, 0x89, 0x74, 0x24, 0x38, 0x48,
	0x89, 0x5C, 0x24, 0x40, 0x88, 0x5C, 0x24, 0x33, 0x88, 0x5C, 0x24, 0x34, 0x48, 0x8D, 0x94, 0x24,
	0x98, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x8C, 0x24, 0x80, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x5E, 0x9E,
	0xFF, 0xFF, 0x90, 0x4C, 0x3B, 0xAC, 0x24, 0x88, 0x00, 0x00, 0x00, 0x75, 0x29, 0x38, 0x9C, 0x24,
	0xF8, 0x03, 0x00, 0x00, 0x74, 0x20, 0xC6, 0x44, 0x24, 0x30, 0x01, 0x41, 0xB8, 0x01, 0x00, 0x00,
	0x00, 0x48, 0x8B, 0x94, 0x24, 0xF0, 0x03, 0x00, 0x00, 0x49, 0x8B, 0xCD, 0xFF, 0x15, 0x76, 0x9D,
	0xFF, 0xFF, 0x88, 0x5C, 0x24, 0x30, 0x38, 0x5C, 0x24, 0x31, 0x0F, 0x84, 0xB1, 0x00, 0x00, 0x00,
	0x4C, 0x8D, 0x8C, 0x24, 0xD0, 0x00, 0x00, 0x00, 0x49, 0x89, 0x19, 0x41, 0x8B, 0xCD, 0x41, 0xB8,
	0xFF, 0x0F, 0x00, 0x00, 0x41, 0x23, 0xC8, 0x8B, 0xC7, 0x41, 0x23, 0xC0, 0x8D, 0x94, 0x01, 0xFF,
	0x0F, 0x00, 0x00, 0xC1, 0xEA, 0x0C, 0x48, 0x8B, 0xC7, 0x48, 0xC1, 0xE8, 0x0C, 0x03, 0xC2, 0x48,
	0x8D, 0x04, 0xC5, 0x30, 0x00, 0x00, 0x00, 0x66, 0x41, 0x89, 0x41, 0x08, 0x66, 0x41, 0x89, 0x59,
	0x0A, 0x49, 0x8B, 0xC5, 0x48, 0x25, 0x00, 0xF0, 0xFF, 0xFF, 0x49, 0x89, 0x41, 0x20, 0x49, 0x8B,
	0xC5, 0x49, 0x23, 0xC0, 0x41, 0x89, 0x41, 0x2C, 0x41, 0x89, 0x79, 0x28, 0x45, 0x33, 0xC0, 0x8A,
	0x94, 0x24, 0xF8, 0x03, 0x00, 0x00, 0x49, 0x8B, 0xC9, 0xFF, 0x15, 0xA1, 0x9E, 0xFF, 0xFF, 0xC6,
	0x44, 0x24, 0x33, 0x01, 0xC7, 0x44, 0x24, 0x28, 0x20, 0x00, 0x00, 0x00, 0x89, 0x5C, 0x24, 0x20,
	0x45, 0x33, 0xC9, 0x33, 0xD2, 0x45, 0x8D, 0x41, 0x01, 0x48, 0x8D, 0x8C, 0x24, 0xD0, 0x00, 0x00,
	0x00, 0xFF, 0x15, 0x71, 0x9E, 0xFF, 0xFF, 0x48, 0x89, 0x44, 0x24, 0x40, 0x48, 0x3B, 0xC3, 0x75,
	0x1E, 0xC6, 0x44, 0x24, 0x32, 0x01, 0xB9, 0x9A, 0x00, 0x00, 0xC0, 0xFF, 0x15, 0x47, 0x9E, 0xFF,
	0xFF, 0x4C, 0x8B, 0xC7, 0x49, 0x8B, 0xD5, 0x48, 0x8B, 0xCE, 0xE8, 0x51, 0x8B, 0xFF, 0xFF, 0x48,
	0x8D, 0x8C, 0x24, 0x98, 0x00, 0x00, 0x00, 0xFF, 0x15, 0xDB, 0x9C, 0xFF, 0xFF, 0x48, 0x8D, 0x94,
	0x24, 0x98, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x68, 0xFF, 0x15, 0x40, 0x9D, 0xFF, 0xFF,
	0x4C, 0x3B, 0xBC, 0x24, 0x90, 0x00, 0x00, 0x00, 0x75, 0x29, 0x38, 0x9C, 0x24, 0xF8, 0x03, 0x00,
	0x00, 0x74, 0x20, 0xC6, 0x44, 0x24, 0x30, 0x01, 0x41, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x48, 0x8B,
	0x94, 0x24, 0xF0, 0x03, 0x00, 0x00, 0x49, 0x8B, 0xCF, 0xFF, 0x15, 0x11, 0x9C, 0xFF, 0xFF, 0x88,
	0x5C, 0x24, 0x30, 0xC6, 0x44, 0x24, 0x34, 0x01, 0x38, 0x5C, 0x24, 0x31, 0x74, 0x12, 0x4C, 0x8B,
	0xC7, 0x48, 0x8B, 0x54, 0x24, 0x40, 0x49, 0x8B, 0xCF, 0xE8, 0xE2, 0x8A, 0xFF, 0xFF, 0xEB, 0x0F,
	0x4C, 0x8B, 0xC7, 0x48, 0x8B, 0xD6, 0x49, 0x8B, 0xCF, 0xE8, 0xD2, 0x8A, 0xFF, 0xFF, 0x90, 0x48,
	0x8D, 0x8C, 0x24, 0x98, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x5B, 0x9C, 0xFF, 0xFF, 0x38, 0x5C, 0x24,
	0x31, 0x74, 0x21, 0x48, 0x8D, 0x94, 0x24, 0xD0, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x40,
	0xFF, 0x15, 0x8A, 0x9D, 0xFF, 0xFF, 0x48, 0x8D, 0x8C, 0x24, 0xD0, 0x00, 0x00, 0x00, 0xFF, 0x15,
	0xA4, 0x9D, 0xFF, 0xFF, 0x4C, 0x2B, 0xF7, 0x4C, 0x89, 0x74, 0x24, 0x48, 0x4C, 0x03, 0xEF, 0x4C,
	0x89, 0x6C, 0x24, 0x58, 0x4C, 0x03, 0xFF, 0xE9, 0x55, 0xFD, 0xFF, 0xFF, 0x8B, 0xF0, 0x48, 0x8D,
	0x8C, 0x24, 0x98, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x0C, 0x9C, 0xFF, 0xFF, 0x48, 0x8B, 0x4C, 0x24,
	0x40, 0x33, 0xDB, 0x48, 0x3B, 0xCB, 0x74, 0x10, 0x48, 0x8B, 0x7C, 0x24, 0x50, 0x48, 0x8B, 0xD7,
	0xFF, 0x15, 0x3A, 0x9D, 0xFF, 0xFF, 0xEB, 0x05, 0x48, 0x8B, 0x7C, 0x24, 0x50, 0x38, 0x5C, 0x24,
	0x33, 0x74, 0x09, 0x48, 0x8B, 0xCF, 0xFF, 0x15, 0x4C, 0x9D, 0xFF, 0xFF, 0x48, 0x8D, 0x84, 0x24,
	0x80, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x38, 0x48, 0x3B, 0xC8, 0x74, 0x0B, 0xBA, 0x4B,
	0x70, 0x68, 0x43, 0xFF, 0x15, 0x1F, 0x9B, 0xFF, 0xFF, 0x38, 0x5C, 0x24, 0x30, 0x75, 0x40, 0x38,
	0x5C, 0x24, 0x32, 0x75, 0x3A, 0x38, 0x5C, 0x24, 0x34, 0x74, 0x18, 0x38, 0x5C, 0x24, 0x35, 0x74,
	0x12, 0x8B, 0x4C, 0x24, 0x70, 0x2B, 0x4C, 0x24, 0x58, 0x48, 0x8B, 0x44, 0x24, 0x60, 0x48, 0x89,
	0x08, 0xEB, 0x15, 0x48, 0x8B, 0x8C, 0x24, 0xF0, 0x03, 0x00, 0x00, 0x48, 0x2B, 0x4C, 0x24, 0x48,
	0x48, 0x8B, 0x44, 0x24, 0x60, 0x48, 0x89, 0x08, 0xB8, 0x0D, 0x00, 0x00, 0x80, 0xEB, 0x31, 0x8B,
	0xC6, 0xEB, 0x2D, 0x48, 0x8D, 0x84, 0x24, 0x80, 0x01, 0x00, 0x00, 0x48, 0x3B, 0xF0, 0x74, 0x0E,
	0xBA, 0x4B, 0x70, 0x68, 0x43, 0x48, 0x8B, 0xCE, 0xFF, 0x15, 0xBA, 0x9A, 0xFF, 0xFF, 0x48, 0x8B,
	0x84, 0x24, 0xF0, 0x03, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x78, 0x48, 0x89, 0x01, 0x33, 0xC0,
	0x48, 0x8B, 0x8C, 0x24, 0x80, 0x03, 0x00, 0x00, 0x48, 0x33, 0xCC, 0xE8, 0x30, 0x89, 0xFF, 0xFF,
	0x48, 0x81, 0xC4, 0x98, 0x03, 0x00, 0x00, 0x41, 0x5F, 0x41, 0x5E, 0x41, 0x5D, 0x5F, 0x5E, 0x5B,
	0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x74,
	0x24, 0x10, 0x48, 0x89, 0x7C, 0x24, 0x18, 0x41, 0x54, 0x41, 0x55, 0x41, 0x56, 0x48, 0x83, 0xEC,
	0x50, 0x49, 0x8B, 0xF1, 0x4D, 0x8B, 0xF0, 0x4C, 0x8B, 0xEA, 0x48, 0x8B, 0xF9, 0x44, 0x8A, 0xA4,
	0x24, 0x98, 0x00, 0x00, 0x00, 0x45, 0x84, 0xE4, 0x74, 0x52, 0x4E, 0x8D, 0x14, 0x0A, 0x4C, 0x3B,
	0xD2, 0x72, 0x3F, 0x4F, 0x8D, 0x1C, 0x08, 0x4D, 0x3B, 0xD8, 0x72, 0x36, 0x48, 0x8B, 0x05, 0x2D,
	0x9C, 0xFF, 0xFF, 0x4C, 0x3B, 0x10, 0x77, 0x2A, 0x4C, 0x3B, 0x18, 0x77, 0x25, 0x48, 0x8B, 0x9C,
	0x24, 0x90, 0x00, 0x00, 0x00, 0x48, 0x85, 0xDB, 0x74, 0x2A, 0xBA, 0x08, 0x00, 0x00, 0x00, 0x44,
	0x8B, 0xC2, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0x25, 0x9A, 0xFF, 0xFF, 0xEB, 0x17, 0xE9, 0xC8, 0x00,
	0x00, 0x00, 0xB8, 0x05, 0x00, 0x00, 0xC0, 0xE9, 0xBE, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x9C, 0x24,
	0x90, 0x00, 0x00, 0x00, 0x48, 0x85, 0xF6, 0x0F, 0x84, 0x84, 0x00, 0x00, 0x00, 0x48, 0x83, 0x64,
	0x24, 0x28, 0x00, 0x48, 0x8D, 0x44, 0x24, 0x40, 0x48, 0x89, 0x44, 0x24, 0x20, 0x45, 0x8A, 0xCC,
	0x4C, 0x8B, 0x05, 0x51, 0x9A, 0xFF, 0xFF, 0x4D, 0x8B, 0x00, 0x33, 0xD2, 0x48, 0x8B, 0xCF, 0xFF,
	0x15, 0x93, 0x9A, 0xFF, 0xFF, 0x8B, 0xF8, 0x89, 0x84, 0x24, 0x98, 0x00, 0x00, 0x00, 0x85, 0xC0,
	0x78, 0x48, 0xFF, 0x15, 0x78, 0x9A, 0xFF, 0xFF, 0x4C, 0x8B, 0xC0, 0x48, 0x8D, 0x44, 0x24, 0x48,
	0x48, 0x89, 0x44, 0x24, 0x30, 0x44, 0x88, 0x64, 0x24, 0x28, 0x48, 0x89, 0x74, 0x24, 0x20, 0x4D,
	0x8B, 0xCE, 0x49, 0x8B, 0xD5, 0x48, 0x8B, 0x4C, 0x24, 0x40, 0xE8, 0xC5, 0xFA, 0xFF, 0xFF, 0x8B,
	0xF8, 0x89, 0x84, 0x24, 0x98, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x40, 0xFF, 0x15, 0x6D,
	0x9A, 0xFF, 0xFF, 0x4C, 0x8B, 0x5C, 0x24, 0x48, 0xEB, 0x13, 0x4C, 0x8B, 0x5C, 0x24, 0x48, 0xEB,
	0x0C, 0x45, 0x33, 0xDB, 0x33, 0xFF, 0x89, 0xBC, 0x24, 0x98, 0x00, 0x00, 0x00, 0x48, 0x85, 0xDB,
	0x74, 0x16, 0x45, 0x84, 0xE4, 0x74, 0x0E, 0x4C, 0x89, 0x1B, 0xEB, 0x07, 0x8B, 0xBC, 0x24, 0x98,
	0x00, 0x00, 0x00, 0xEB, 0x03, 0x4C, 0x89, 0x1B, 0x8B, 0xC7, 0x4C, 0x8D, 0x5C, 0x24, 0x50, 0x49,
	0x8B, 0x5B, 0x20, 0x49, 0x8B, 0x73, 0x28, 0x49, 0x8B, 0x7B, 0x30, 0x49, 0x8B, 0xE3, 0x41, 0x5E,
	0x41, 0x5D, 0x41, 0x5C, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x89, 0x5C, 0x24,
	0x08, 0x48, 0x89, 0x74, 0x24, 0x10, 0x48, 0x89, 0x7C, 0x24, 0x18, 0x41, 0x54, 0x41, 0x55, 0x41,
	0x56, 0x48, 0x83, 0xEC, 0x50, 0x49, 0x8B, 0xF1, 0x4D, 0x8B, 0xF0, 0x4C, 0x8B, 0xEA, 0x48, 0x8B,
	0xF9, 0x44, 0x8A, 0xA4, 0x24, 0x98, 0x00, 0x00, 0x00, 0x45, 0x84, 0xE4, 0x74, 0x52, 0x4E, 0x8D,
	0x14, 0x0A, 0x4C, 0x3B, 0xD2, 0x72, 0x3F, 0x4F, 0x8D, 0x1C, 0x08, 0x4D, 0x3B, 0xD8, 0x72, 0x36,
	0x48, 0x8B, 0x05, 0xC9, 0x9A, 0xFF, 0xFF, 0x4C, 0x3B, 0x10, 0x77, 0x2A, 0x4C, 0x3B, 0x18, 0x77,
	0x25, 0x48, 0x8B, 0x9C, 0x24, 0x90, 0x00, 0x00, 0x00, 0x48, 0x85, 0xDB, 0x74, 0x2A, 0xBA, 0x08,
	0x00, 0x00, 0x00, 0x44, 0x8B, 0xC2, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0xC1, 0x98, 0xFF, 0xFF, 0xEB,
	0x17, 0xE9, 0xC8, 0x00, 0x00, 0x00, 0xB8, 0x05, 0x00, 0x00, 0xC0, 0xE9, 0xBE, 0x00, 0x00, 0x00,
	0x48, 0x8B, 0x9C, 0x24, 0x90, 0x00, 0x00, 0x00, 0x48, 0x85, 0xF6, 0x0F, 0x84, 0x84, 0x00, 0x00,
	0x00, 0x48, 0x83, 0x64, 0x24, 0x28, 0x00, 0x48, 0x8D, 0x44, 0x24, 0x40, 0x48, 0x89, 0x44, 0x24,
	0x20, 0x45, 0x8A, 0xCC, 0x4C, 0x8B, 0x05, 0xED, 0x98, 0xFF, 0xFF, 0x4D, 0x8B, 0x00, 0x33, 0xD2,
	0x48, 0x8B, 0xCF, 0xFF, 0x15, 0x2F, 0x99, 0xFF, 0xFF, 0x8B, 0xF8, 0x89, 0x84, 0x24, 0x98, 0x00,
	0x00, 0x00, 0x85, 0xC0, 0x78, 0x48, 0xFF, 0x15, 0x14, 0x99, 0xFF, 0xFF, 0x48, 0x8B, 0xC8, 0x48,
	0x8D, 0x44, 0x24, 0x48, 0x48, 0x89, 0x44, 0x24, 0x30, 0x44, 0x88, 0x64, 0x24, 0x28, 0x48, 0x89,
	0x74, 0x24, 0x20, 0x4D, 0x8B, 0xCD, 0x4C, 0x8B, 0x44, 0x24, 0x40, 0x49, 0x8B, 0xD6, 0xE8, 0x61,
	0xF9, 0xFF, 0xFF, 0x8B, 0xF8, 0x89, 0x84, 0x24, 0x98, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24,
	0x40, 0xFF, 0x15, 0x09, 0x99, 0xFF, 0xFF, 0x4C, 0x8B, 0x5C, 0x24, 0x48, 0xEB, 0x13, 0x4C, 0x8B,
	0x5C, 0x24, 0x48, 0xEB, 0x0C, 0x45, 0x33, 0xDB, 0x33, 0xFF, 0x89, 0xBC, 0x24, 0x98, 0x00, 0x00,
	0x00, 0x48, 0x85, 0xDB, 0x74, 0x16, 0x45, 0x84, 0xE4, 0x74, 0x0E, 0x4C, 0x89, 0x1B, 0xEB, 0x07,
	0x8B, 0xBC, 0x24, 0x98, 0x00, 0x00, 0x00, 0xEB, 0x03, 0x4C, 0x89, 0x1B, 0x8B, 0xC7, 0x4C, 0x8D,
	0x5C, 0x24, 0x50, 0x49, 0x8B, 0x5B, 0x20, 0x49, 0x8B, 0x73, 0x28, 0x49, 0x8B, 0x7B, 0x30, 0x49,
	0x8B, 0xE3, 0x41, 0x5E, 0x41, 0x5D, 0x41, 0x5C, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0x48, 0x8B, 0xC4, 0x48, 0x89, 0x58, 0x08, 0x48, 0x89, 0x70, 0x10, 0x48, 0x89, 0x78, 0x18, 0x4C,
	0x89, 0x60, 0x20, 0x41, 0x55, 0x41, 0x56, 0x41, 0x57, 0x48, 0x83, 0xEC, 0x60, 0x49, 0x8B, 0xF9,
	0x4D, 0x8B, 0xF0, 0x4C, 0x8B, 0xE2, 0x48, 0x8B, 0xD9, 0x44, 0x8A, 0xBC, 0x24, 0xA8, 0x00, 0x00,
	0x00, 0x45, 0x84, 0xFF, 0x74, 0x4C, 0x4A, 0x8D, 0x04, 0x0A, 0x48, 0x3B, 0xC2, 0x72, 0x39, 0x4D,
	0x03, 0xC8, 0x4D, 0x3B, 0xC8, 0x72, 0x31, 0x48, 0x8B, 0x05, 0x62, 0x99, 0xFF, 0xFF, 0x4C, 0x3B,
	0x08, 0x77, 0x25, 0x48, 0x8B, 0xB4, 0x24, 0xA0, 0x00, 0x00, 0x00, 0x48, 0x85, 0xF6, 0x74, 0x2A,
	0xBA, 0x08, 0x00, 0x00, 0x00, 0x44, 0x8B, 0xC2, 0x48, 0x8B, 0xCE, 0xFF, 0x15, 0x5F, 0x97, 0xFF,
	0xFF, 0xEB, 0x17, 0xE9, 0x38, 0x01, 0x00, 0x00, 0xB8, 0x05, 0x00, 0x00, 0xC0, 0xE9, 0x2E, 0x01,
	0x00, 0x00, 0x48, 0x8B, 0xB4, 0x24, 0xA0, 0x00, 0x00, 0x00, 0x48, 0x85, 0xFF, 0x0F, 0x84, 0xF5,
	0x00, 0x00, 0x00, 0x49, 0x8D, 0x0C, 0x3C, 0x48, 0x8B, 0x05, 0x12, 0x99, 0xFF, 0xFF, 0x48, 0x3B,
	0x08, 0x76, 0x61, 0x49, 0x8B, 0xDC, 0x48, 0xC7, 0xC0, 0x00, 0xF0, 0xFF, 0xFF, 0x48, 0x23, 0xD8,
	0x4C, 0x8D, 0x69, 0xFF, 0x4C, 0x23, 0xE8, 0x49, 0x3B, 0xDD, 0x77, 0x26, 0x48, 0x8B, 0xCB, 0xFF,
	0x15, 0x0B, 0x99, 0xFF, 0xFF, 0x84, 0xC0, 0x75, 0x0B, 0xB9, 0x05, 0x00, 0x00, 0xC0, 0xFF, 0x15,
	0xD4, 0x98, 0xFF, 0xFF, 0x48, 0x81, 0xC3, 0x00, 0x10, 0x00, 0x00, 0x48, 0x89, 0x5C, 0x24, 0x50,
	0xEB, 0xD5, 0x4C, 0x8B, 0xC7, 0x49, 0x8B, 0xD4, 0x49, 0x8B, 0xCE, 0xE8, 0xD0, 0x85, 0xFF, 0xFF,
	0x90, 0x33, 0xDB, 0x89, 0x9C, 0x24, 0xA8, 0x00, 0x00, 0x00, 0xE9, 0x94, 0x00, 0x00, 0x00, 0xE9,
	0xAC, 0x00, 0x00, 0x00, 0x48, 0x83, 0x64, 0x24, 0x28, 0x00, 0x48, 0x8D, 0x44, 0x24, 0x40, 0x48,
	0x89, 0x44, 0x24, 0x20, 0x45, 0x8A, 0xCF, 0x4C, 0x8B, 0x05, 0x1A, 0x97, 0xFF, 0xFF, 0x4D, 0x8B,
	0x00, 0x33, 0xD2, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0x5C, 0x97, 0xFF, 0xFF, 0x8B, 0xD8, 0x89, 0x84,
	0x24, 0xA8, 0x00, 0x00, 0x00, 0x85, 0xC0, 0x78, 0x48, 0xFF, 0x15, 0x41, 0x97, 0xFF, 0xFF, 0x4C,
	0x8B, 0xC0, 0x48, 0x8D, 0x44, 0x24, 0x48, 0x48, 0x89, 0x44, 0x24, 0x30, 0x44, 0x88, 0x7C, 0x24,
	0x28, 0x48, 0x89, 0x7C, 0x24, 0x20, 0x4D, 0x8B, 0xCE, 0x49, 0x8B, 0xD4, 0x48, 0x8B, 0x4C, 0x24,
	0x40, 0xE8, 0x8E, 0xF7, 0xFF, 0xFF, 0x8B, 0xD8, 0x89, 0x84, 0x24, 0xA8, 0x00, 0x00, 0x00, 0x48,
	0x8B, 0x4C, 0x24, 0x40, 0xFF, 0x15, 0x36, 0x97, 0xFF, 0xFF, 0x48, 0x8B, 0x7C, 0x24, 0x48, 0xEB,
	0x12, 0x48, 0x8B, 0x7C, 0x24, 0x48, 0xEB, 0x0B, 0x33, 0xFF, 0x33, 0xDB, 0x89, 0x9C, 0x24, 0xA8,
	0x00, 0x00, 0x00, 0x48, 0x85, 0xF6, 0x74, 0x16, 0x45, 0x84, 0xFF, 0x74, 0x0E, 0x48, 0x89, 0x3E,
	0xEB, 0x07, 0x8B, 0x9C, 0x24, 0xA8, 0x00, 0x00, 0x00, 0xEB, 0x03, 0x48, 0x89, 0x3E, 0x8B, 0xC3,
	0x4C, 0x8D, 0x5C, 0x24, 0x60, 0x49, 0x8B, 0x5B, 0x20, 0x49, 0x8B, 0x73, 0x28, 0x49, 0x8B, 0x7B,
	0x30, 0x4D, 0x8B, 0x63, 0x38, 0x49, 0x8B, 0xE3, 0x41, 0x5F, 0x41, 0x5E, 0x41, 0x5D, 0xC3, 0xCC,
	0x5C, 0x00, 0x44, 0x00, 0x65, 0x00, 0x76, 0x00, 0x69, 0x00, 0x63, 0x00, 0x65, 0x00, 0x5C, 0x00,
	0x4B, 0x00, 0x50, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x63, 0x00, 0x65, 0x00, 0x73, 0x00, 0x73, 0x00,
	0x48, 0x00, 0x61, 0x00, 0x63, 0x00, 0x6B, 0x00, 0x65, 0x00, 0x72, 0x00, 0x32, 0x00, 0x00, 0x00,
	0x5C, 0x00, 0x50, 0x00, 0x61, 0x00, 0x72, 0x00, 0x61, 0x00, 0x6D, 0x00, 0x65, 0x00, 0x74, 0x00,
	0x65, 0x00, 0x72, 0x00, 0x73, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0x53, 0x00, 0x65, 0x00, 0x63, 0x00, 0x75, 0x00, 0x72, 0x00, 0x69, 0x00, 0x74, 0x00, 0x79, 0x00,
	0x4C, 0x00, 0x65, 0x00, 0x76, 0x00, 0x65, 0x00, 0x6C, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC,
	0x44, 0x00, 0x69, 0x00, 0x73, 0x00, 0x61, 0x00, 0x62, 0x00, 0x6C, 0x00, 0x65, 0x00, 0x44, 0x00,
	0x79, 0x00, 0x6E, 0x00, 0x61, 0x00, 0x6D, 0x00, 0x69, 0x00, 0x63, 0x00, 0x50, 0x00, 0x72, 0x00,
	0x6F, 0x00, 0x63, 0x00, 0x65, 0x00, 0x64, 0x00, 0x75, 0x00, 0x72, 0x00, 0x65, 0x00, 0x53, 0x00,
	0x63, 0x00, 0x61, 0x00, 0x6E, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0x44, 0x00, 0x79, 0x00, 0x6E, 0x00, 0x61, 0x00, 0x6D, 0x00, 0x69, 0x00, 0x63, 0x00, 0x43, 0x00,
	0x6F, 0x00, 0x6E, 0x00, 0x66, 0x00, 0x69, 0x00, 0x67, 0x00, 0x75, 0x00, 0x72, 0x00, 0x61, 0x00,
	0x74, 0x00, 0x69, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0x45, 0x00, 0x78, 0x00, 0x66, 0x00, 0x55, 0x00, 0x6E, 0x00, 0x62, 0x00, 0x6C, 0x00, 0x6F, 0x00,
	0x63, 0x00, 0x6B, 0x00, 0x50, 0x00, 0x75, 0x00, 0x73, 0x00, 0x68, 0x00, 0x4C, 0x00, 0x6F, 0x00,
	0x63, 0x00, 0x6B, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0x4F, 0x00, 0x62, 0x00, 0x47, 0x00, 0x65, 0x00, 0x74, 0x00, 0x4F, 0x00, 0x62, 0x00, 0x6A, 0x00,
	0x65, 0x00, 0x63, 0x00, 0x74, 0x00, 0x54, 0x00, 0x79, 0x00, 0x70, 0x00, 0x65, 0x00, 0x00, 0x00,
	0x50, 0x00, 0x73, 0x00, 0x41, 0x00, 0x63, 0x00, 0x71, 0x00, 0x75, 0x00, 0x69, 0x00, 0x72, 0x00,
	0x65, 0x00, 0x50, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x63, 0x00, 0x65, 0x00, 0x73, 0x00, 0x73, 0x00,
	0x45, 0x00, 0x78, 0x00, 0x69, 0x00, 0x74, 0x00, 0x53, 0x00, 0x79, 0x00, 0x6E, 0x00, 0x63, 0x00,
	0x68, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x69, 0x00, 0x7A, 0x00, 0x61, 0x00, 0x74, 0x00,
	0x69, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0x50, 0x00, 0x73, 0x00, 0x49, 0x00, 0x73, 0x00, 0x50, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x74, 0x00,
	0x65, 0x00, 0x63, 0x00, 0x74, 0x00, 0x65, 0x00, 0x64, 0x00, 0x50, 0x00, 0x72, 0x00, 0x6F, 0x00,
	0x63, 0x00, 0x65, 0x00, 0x73, 0x00, 0x73, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0x50, 0x00, 0x73, 0x00, 0x52, 0x00, 0x65, 0x00, 0x6C, 0x00, 0x65, 0x00, 0x61, 0x00, 0x73, 0x00,
	0x65, 0x00, 0x50, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x63, 0x00, 0x65, 0x00, 0x73, 0x00, 0x73, 0x00,
	0x45, 0x00, 0x78, 0x00, 0x69, 0x00, 0x74, 0x00, 0x53, 0x00, 0x79, 0x00, 0x6E, 0x00, 0x63, 0x00,
	0x68, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x69, 0x00, 0x7A, 0x00, 0x61, 0x00, 0x74, 0x00,
	0x69, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0x50, 0x00, 0x73, 0x00, 0x52, 0x00, 0x65, 0x00, 0x73, 0x00, 0x75, 0x00, 0x6D, 0x00, 0x65, 0x00,
	0x50, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x63, 0x00, 0x65, 0x00, 0x73, 0x00, 0x73, 0x00, 0x00, 0x00,
	0x50, 0x00, 0x73, 0x00, 0x53, 0x00, 0x75, 0x00, 0x73, 0x00, 0x70, 0x00, 0x65, 0x00, 0x6E, 0x00,
	0x64, 0x00, 0x50, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x63, 0x00, 0x65, 0x00, 0x73, 0x00, 0x73, 0x00,
	0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0x45, 0x00, 0x74, 0x00, 0x77, 0x00, 0x52, 0x00, 0x65, 0x00, 0x67, 0x00, 0x69, 0x00, 0x73, 0x00,
	0x74, 0x00, 0x72, 0x00, 0x61, 0x00, 0x74, 0x00, 0x69, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x00, 0x00,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x40, 0x55, 0x48, 0x83, 0xEC, 0x30, 0x48, 0x8B, 0xEA, 0x4C,
	0x8D, 0x45, 0x70, 0x48, 0x8D, 0x55, 0x35, 0xE8, 0xB0, 0x81, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x30,
	0x5D, 0xC3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x05, 0xF1, 0xA0, 0xFF, 0xFF, 0x48,
	0xBA, 0x32, 0xA2, 0xDF, 0x2D, 0x99, 0x2B, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x74, 0x05, 0x48, 0x3B,
	0xC2, 0x75, 0x2F, 0x48, 0x8D, 0x0D, 0xD6, 0xA0, 0xFF, 0xFF, 0x48, 0xB8, 0x20, 0x03, 0x00, 0x00,
	0x80, 0xF7, 0xFF, 0xFF, 0x48, 0x8B, 0x00, 0x48, 0x33, 0xC1, 0x48, 0xB9, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0x00, 0x00, 0x48, 0x23, 0xC1, 0x48, 0x0F, 0x44, 0xC2, 0x48, 0x89, 0x05, 0xAE, 0xA0,
	0xFF, 0xFF, 0x48, 0xF7, 0xD0, 0x48, 0x89, 0x05, 0xAC, 0xA0, 0xFF, 0xFF, 0xC3, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x28, 0x4C, 0x8B, 0xC2, 0x4C, 0x8B, 0xC9, 0xE8, 0x95,
	0xFF, 0xFF, 0xFF, 0x49, 0x8B, 0xD0, 0x49, 0x8B, 0xC9, 0x48, 0x83, 0xC4, 0x28, 0xE9, 0x86, 0xBF,
	0xFF, 0xFF, 0xCC, 0xCC, 0xB0, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xF4, 0xA8, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xF0, 0xA2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0xA3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1C, 0xA3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0xA3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x46, 0xA3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x56, 0xA3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x72, 0xA3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0xA3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x8E, 0xA3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA4, 0xA3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xBC, 0xA3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCE, 0xA3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xE2, 0xA3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEE, 0xA3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFE, 0xA3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0xA4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x22, 0xA4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0xA4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x4E, 0xA4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0xA4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x74, 0xA4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8C, 0xA4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xA6, 0xA4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xBA, 0xA4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xCE, 0xA4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE2, 0xA4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xF8, 0xA4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0xA5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x2A, 0xA5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3A, 0xA5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x54, 0xA5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6C, 0xA5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x88, 0xA5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0xA5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xBE, 0xA5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xDA, 0xA5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xF2, 0xA5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0xA6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x28, 0xA6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0xA6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x52, 0xA6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6C, 0xA6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x80, 0xA6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9E, 0xA6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xB8, 0xA6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCA, 0xA6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xE8, 0xA6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xA6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1A, 0xA7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2E, 0xA7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x42, 0xA7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0xA7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x62, 0xA7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xA7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x8A, 0xA7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0xA7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xBA, 0xA7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD4, 0xA7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xEC, 0xA7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xA7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1A, 0xA8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0xA8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x4C, 0xA8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0xA8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x72, 0xA8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8A, 0xA8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xAA, 0xA8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xA8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xD0, 0xA8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE4, 0xA8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x02, 0xA9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x73, 0x00, 0x45, 0x78, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x50, 0x6F, 0x6F, 0x6C,
	0x57, 0x69, 0x74, 0x68, 0x54, 0x61, 0x67, 0x00, 0x8B, 0x00, 0x45, 0x78, 0x46, 0x72, 0x65, 0x65,
	0x50, 0x6F, 0x6F, 0x6C, 0x57, 0x69, 0x74, 0x68, 0x54, 0x61, 0x67, 0x00, 0xBA, 0x05, 0x52, 0x74,
	0x6C, 0x49, 0x6E, 0x69, 0x74, 0x55, 0x6E, 0x69, 0x63, 0x6F, 0x64, 0x65, 0x53, 0x74, 0x72, 0x69,
	0x6E, 0x67, 0x00, 0x00, 0xE3, 0x01, 0x49, 0x6F, 0x44, 0x65, 0x6C, 0x65, 0x74, 0x65, 0x44, 0x65,
	0x76, 0x69, 0x63, 0x65, 0x00, 0x00, 0xB6, 0x04, 0x50, 0x72, 0x6F, 0x62, 0x65, 0x46, 0x6F, 0x72,
	0x57, 0x72, 0x69, 0x74, 0x65, 0x00, 0x82, 0x07, 0x5A, 0x77, 0x51, 0x75, 0x65, 0x72, 0x79, 0x53,
	0x79, 0x73, 0x74, 0x65, 0x6D, 0x49, 0x6E, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x69, 0x6F, 0x6E,
	0x00, 0x00, 0x83, 0x07, 0x5A, 0x77, 0x51, 0x75, 0x65, 0x72, 0x79, 0x56, 0x61, 0x6C, 0x75, 0x65,
	0x4B, 0x65, 0x79, 0x00, 0x12, 0x07, 0x5A, 0x77, 0x43, 0x6C, 0x6F, 0x73, 0x65, 0x00, 0xA3, 0x02,
	0x49, 0x6F, 0x66, 0x43, 0x6F, 0x6D, 0x70, 0x6C, 0x65, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65,
	0x73, 0x74, 0x00, 0x00, 0xC5, 0x04, 0x50, 0x73, 0x47, 0x65, 0x74, 0x43, 0x75, 0x72, 0x72, 0x65,
	0x6E, 0x74, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x49, 0x64, 0x00, 0xCE, 0x01, 0x49, 0x6F,
	0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x00, 0x00, 0xA0, 0x06,
	0x53, 0x65, 0x50, 0x72, 0x69, 0x76, 0x69, 0x6C, 0x65, 0x67, 0x65, 0x43, 0x68, 0x65, 0x63, 0x6B,
	0x00, 0x00, 0x4E, 0x07, 0x5A, 0x77, 0x4F, 0x70, 0x65, 0x6E, 0x4B, 0x65, 0x79, 0x00, 0xB5, 0x04,
	0x50, 0x72, 0x6F, 0x62, 0x65, 0x46, 0x6F, 0x72, 0x52, 0x65, 0x61, 0x64, 0x00, 0x00, 0xAE, 0x05,
	0x52, 0x74, 0x6C, 0x47, 0x65, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x00, 0x3F, 0x05,
	0x52, 0x74, 0x6C, 0x43, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 0x4D, 0x65, 0x6D, 0x6F, 0x72, 0x79,
	0x00, 0x00, 0xBF, 0x03, 0x4D, 0x6D, 0x47, 0x65, 0x74, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x52,
	0x6F, 0x75, 0x74, 0x69, 0x6E, 0x65, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x00, 0xFF, 0x04,
	0x50, 0x73, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x54, 0x79, 0x70, 0x65, 0x00, 0x76, 0x04,
	0x4F, 0x62, 0x4F, 0x70, 0x65, 0x6E, 0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x42, 0x79, 0x4E, 0x61,
	0x6D, 0x65, 0x00, 0x00, 0x7C, 0x07, 0x5A, 0x77, 0x51, 0x75, 0x65, 0x72, 0x79, 0x4F, 0x62, 0x6A,
	0x65, 0x63, 0x74, 0x00, 0x7A, 0x05, 0x52, 0x74, 0x6C, 0x45, 0x71, 0x75, 0x61, 0x6C, 0x55, 0x6E,
	0x69, 0x63, 0x6F, 0x64, 0x65, 0x53, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x00, 0x81, 0x03, 0x4B, 0x65,
	0x55, 0x6E, 0x73, 0x74, 0x61, 0x63, 0x6B, 0x44, 0x65, 0x74, 0x61, 0x63, 0x68, 0x50, 0x72, 0x6F,
	0x63, 0x65, 0x73, 0x73, 0x00, 0x00, 0x83, 0x00, 0x45, 0x78, 0x45, 0x6E, 0x75, 0x6D, 0x48, 0x61,
	0x6E, 0x64, 0x6C, 0x65, 0x54, 0x61, 0x62, 0x6C, 0x65, 0x00, 0x7A, 0x04, 0x4F, 0x62, 0x51, 0x75,
	0x65, 0x72, 0x79, 0x4E, 0x61, 0x6D, 0x65, 0x53, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x00, 0xF2, 0x01,
	0x49, 0x6F, 0x46, 0x69, 0x6C, 0x65, 0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x54, 0x79, 0x70, 0x65,
	0x00, 0x00, 0xEC, 0x01, 0x49, 0x6F, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72, 0x4F, 0x62, 0x6A, 0x65,
	0x63, 0x74, 0x54, 0x79, 0x70, 0x65, 0x00, 0x00, 0x04, 0x02, 0x49, 0x6F, 0x47, 0x65, 0x74, 0x43,
	0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x00, 0x7C, 0x04,
	0x4F, 0x62, 0x52, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6E, 0x63, 0x65, 0x4F, 0x62, 0x6A, 0x65, 0x63,
	0x74, 0x42, 0x79, 0x48, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x00, 0x65, 0x04, 0x4F, 0x62, 0x43, 0x6C,
	0x6F, 0x73, 0x65, 0x48, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x00, 0xF2, 0x04, 0x50, 0x73, 0x49, 0x6E,
	0x69, 0x74, 0x69, 0x61, 0x6C, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x50, 0x72, 0x6F, 0x63, 0x65,
	0x73, 0x73, 0x00, 0x00, 0x84, 0x04, 0x4F, 0x62, 0x53, 0x65, 0x74, 0x48, 0x61, 0x6E, 0x64, 0x6C,
	0x65, 0x41, 0x74, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x73, 0x00, 0x73, 0x07, 0x5A, 0x77,
	0x51, 0x75, 0x65, 0x72, 0x79, 0x49, 0x6E, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x69, 0x6F, 0x6E,
	0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x00, 0x88, 0x04, 0x4F, 0x62, 0x66, 0x44, 0x65, 0x72,
	0x65, 0x66, 0x65, 0x72, 0x65, 0x6E, 0x63, 0x65, 0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x00, 0x00,
	0x72, 0x00, 0x45, 0x78, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x50, 0x6F, 0x6F, 0x6C,
	0x57, 0x69, 0x74, 0x68, 0x51, 0x75, 0x6F, 0x74, 0x61, 0x54, 0x61, 0x67, 0x00, 0x00, 0x75, 0x07,
	0x5A, 0x77, 0x51, 0x75, 0x65, 0x72, 0x79, 0x49, 0x6E, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x69,
	0x6F, 0x6E, 0x54, 0x68, 0x72, 0x65, 0x61, 0x64, 0x00, 0x00, 0x77, 0x04, 0x4F, 0x62, 0x4F, 0x70,
	0x65, 0x6E, 0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x42, 0x79, 0x50, 0x6F, 0x69, 0x6E, 0x74, 0x65,
	0x72, 0x00, 0x77, 0x03, 0x4B, 0x65, 0x53, 0x74, 0x61, 0x63, 0x6B, 0x41, 0x74, 0x74, 0x61, 0x63,
	0x68, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x00, 0x00, 0x64, 0x00, 0x45, 0x78, 0x41, 0x63,
	0x71, 0x75, 0x69, 0x72, 0x65, 0x52, 0x75, 0x6E, 0x64, 0x6F, 0x77, 0x6E, 0x50, 0x72, 0x6F, 0x74,
	0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x00, 0x00, 0xFC, 0x04, 0x50, 0x73, 0x4C, 0x6F, 0x6F, 0x6B,
	0x75, 0x70, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x42, 0x79, 0x50, 0x72, 0x6F, 0x63, 0x65,
	0x73, 0x73, 0x49, 0x64, 0x00, 0x00, 0xFA, 0x04, 0x50, 0x73, 0x4A, 0x6F, 0x62, 0x54, 0x79, 0x70,
	0x65, 0x00, 0x02, 0x05, 0x50, 0x73, 0x52, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6E, 0x63, 0x65, 0x50,
	0x72, 0x69, 0x6D, 0x61, 0x72, 0x79, 0x54, 0x6F, 0x6B, 0x65, 0x6E, 0x00, 0xB9, 0x06, 0x53, 0x65,
	0x54, 0x6F, 0x6B, 0x65, 0x6E, 0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x54, 0x79, 0x70, 0x65, 0x00,
	0xBE, 0x00, 0x45, 0x78, 0x52, 0x65, 0x6C, 0x65, 0x61, 0x73, 0x65, 0x52, 0x75, 0x6E, 0x64, 0x6F,
	0x77, 0x6E, 0x50, 0x72, 0x6F, 0x74, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x00, 0x00, 0xA3, 0x07,
	0x5A, 0x77, 0x53, 0x65, 0x74, 0x49, 0x6E, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x69, 0x6F, 0x6E,
	0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x00, 0xDE, 0x04, 0x50, 0x73, 0x47, 0x65, 0x74, 0x50,
	0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x4A, 0x6F, 0x62, 0x00, 0xFD, 0x04, 0x50, 0x73, 0x4C, 0x6F,
	0x6F, 0x6B, 0x75, 0x70, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x54, 0x68, 0x72, 0x65, 0x61,
	0x64, 0x42, 0x79, 0x43, 0x69, 0x64, 0x00, 0x00, 0xB1, 0x07, 0x5A, 0x77, 0x54, 0x65, 0x72, 0x6D,
	0x69, 0x6E, 0x61, 0x74, 0x65, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x00, 0x00, 0xBF, 0x04,
	0x50, 0x73, 0x44, 0x65, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6E, 0x63, 0x65, 0x50, 0x72, 0x69,
	0x6D, 0x61, 0x72, 0x79, 0x54, 0x6F, 0x6B, 0x65, 0x6E, 0x00, 0x7D, 0x02, 0x49, 0x6F, 0x54, 0x68,
	0x72, 0x65, 0x61, 0x64, 0x54, 0x6F, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x00, 0x69, 0x06,
	0x52, 0x74, 0x6C, 0x57, 0x61, 0x6C, 0x6B, 0x46, 0x72, 0x61, 0x6D, 0x65, 0x43, 0x68, 0x61, 0x69,
	0x6E, 0x00, 0xF1, 0x02, 0x4B, 0x65, 0x49, 0x6E, 0x69, 0x74, 0x69, 0x61, 0x6C, 0x69, 0x7A, 0x65,
	0x41, 0x70, 0x63, 0x00, 0x65, 0x03, 0x4B, 0x65, 0x53, 0x65, 0x74, 0x45, 0x76, 0x65, 0x6E, 0x74,
	0x00, 0x00, 0x05, 0x03, 0x4B, 0x65, 0x49, 0x6E, 0x73, 0x65, 0x72, 0x74, 0x51, 0x75, 0x65, 0x75,
	0x65, 0x41, 0x70, 0x63, 0x00, 0x00, 0xF7, 0x02, 0x4B, 0x65, 0x49, 0x6E, 0x69, 0x74, 0x69, 0x61,
	0x6C, 0x69, 0x7A, 0x65, 0x45, 0x76, 0x65, 0x6E, 0x74, 0x00, 0x0E, 0x05, 0x50, 0x73, 0x53, 0x65,
	0x74, 0x43, 0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0x54, 0x68, 0x72, 0x65, 0x61, 0x64, 0x00, 0x00,
	0xEF, 0x04, 0x50, 0x73, 0x47, 0x65, 0x74, 0x54, 0x68, 0x72, 0x65, 0x61, 0x64, 0x57, 0x69, 0x6E,
	0x33, 0x32, 0x54, 0x68, 0x72, 0x65, 0x61, 0x64, 0x00, 0x00, 0xA5, 0x07, 0x5A, 0x77, 0x53, 0x65,
	0x74, 0x49, 0x6E, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x54, 0x68, 0x72, 0x65,
	0x61, 0x64, 0x00, 0x00, 0x87, 0x03, 0x4B, 0x65, 0x57, 0x61, 0x69, 0x74, 0x46, 0x6F, 0x72, 0x53,
	0x69, 0x6E, 0x67, 0x6C, 0x65, 0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x00, 0x1F, 0x05, 0x50, 0x73,
	0x54, 0x68, 0x72, 0x65, 0x61, 0x64, 0x54, 0x79, 0x70, 0x65, 0x00, 0x00, 0xB8, 0x04, 0x50, 0x73,
	0x41, 0x73, 0x73, 0x69, 0x67, 0x6E, 0x49, 0x6D, 0x70, 0x65, 0x72, 0x73, 0x6F, 0x6E, 0x61, 0x74,
	0x69, 0x6F, 0x6E, 0x54, 0x6F, 0x6B, 0x65, 0x6E, 0x00, 0x00, 0xC3, 0x04, 0x50, 0x73, 0x47, 0x65,
	0x74, 0x43, 0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0x54, 0x68, 0x72, 0x65, 0x61, 0x64, 0x00, 0x00,
	0xFE, 0x04, 0x50, 0x73, 0x4C, 0x6F, 0x6F, 0x6B, 0x75, 0x70, 0x54, 0x68, 0x72, 0x65, 0x61, 0x64,
	0x42, 0x79, 0x54, 0x68, 0x72, 0x65, 0x61, 0x64, 0x49, 0x64, 0x00, 0x00, 0xEE, 0x03, 0x4D, 0x6D,
	0x55, 0x6E, 0x6D, 0x61, 0x70, 0x4C, 0x6F, 0x63, 0x6B, 0x65, 0x64, 0x50, 0x61, 0x67, 0x65, 0x73,
	0x00, 0x00, 0xAF, 0x00, 0x45, 0x78, 0x52, 0x61, 0x69, 0x73, 0x65, 0x53, 0x74, 0x61, 0x74, 0x75,
	0x73, 0x00, 0xC2, 0x03, 0x4D, 0x6D, 0x48, 0x69, 0x67, 0x68, 0x65, 0x73, 0x74, 0x55, 0x73, 0x65,
	0x72, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x00, 0x00, 0xD0, 0x03, 0x4D, 0x6D, 0x4D, 0x61,
	0x70, 0x4C, 0x6F, 0x63, 0x6B, 0x65, 0x64, 0x50, 0x61, 0x67, 0x65, 0x73, 0x53, 0x70, 0x65, 0x63,
	0x69, 0x66, 0x79, 0x43, 0x61, 0x63, 0x68, 0x65, 0x00, 0x00, 0xDC, 0x03, 0x4D, 0x6D, 0x50, 0x72,
	0x6F, 0x62, 0x65, 0x41, 0x6E, 0x64, 0x4C, 0x6F, 0x63, 0x6B, 0x50, 0x61, 0x67, 0x65, 0x73, 0x00,
	0xEC, 0x03, 0x4D, 0x6D, 0x55, 0x6E, 0x6C, 0x6F, 0x63, 0x6B, 0x50, 0x61, 0x67, 0x65, 0x73, 0x00,
	0xC3, 0x03, 0x4D, 0x6D, 0x49, 0x73, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x56, 0x61, 0x6C,
	0x69, 0x64, 0x00, 0x00, 0xC8, 0x02, 0x4B, 0x65, 0x42, 0x75, 0x67, 0x43, 0x68, 0x65, 0x63, 0x6B,
	0x45, 0x78, 0x00, 0x00, 0x6E, 0x74, 0x6F, 0x73, 0x6B, 0x72, 0x6E, 0x6C, 0x2E, 0x65, 0x78, 0x65,
	0x00, 0x00, 0xBD, 0x07, 0x5F, 0x5F, 0x43, 0x5F, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63,
	0x5F, 0x68, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
	0x10, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x80,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
	0x09, 0x04, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x60, 0xB0, 0x00, 0x00, 0x98, 0x02, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x98, 0x02, 0x34, 0x00, 0x00, 0x00, 0x56, 0x00, 0x53, 0x00, 0x5F, 0x00, 0x56, 0x00, 0x45, 0x00,
	0x52, 0x00, 0x53, 0x00, 0x49, 0x00, 0x4F, 0x00, 0x4E, 0x00, 0x5F, 0x00, 0x49, 0x00, 0x4E, 0x00,
	0x46, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xBD, 0x04, 0xEF, 0xFE, 0x00, 0x00, 0x01, 0x00,
	0x08, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
	0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x01, 0x00, 0x00,
	0x01, 0x00, 0x53, 0x00, 0x74, 0x00, 0x72, 0x00, 0x69, 0x00, 0x6E, 0x00, 0x67, 0x00, 0x46, 0x00,
	0x69, 0x00, 0x6C, 0x00, 0x65, 0x00, 0x49, 0x00, 0x6E, 0x00, 0x66, 0x00, 0x6F, 0x00, 0x00, 0x00,
	0xD4, 0x01, 0x00, 0x00, 0x01, 0x00, 0x30, 0x00, 0x34, 0x00, 0x30, 0x00, 0x39, 0x00, 0x30, 0x00,
	0x34, 0x00, 0x45, 0x00, 0x34, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x05, 0x00, 0x01, 0x00, 0x43, 0x00,
	0x6F, 0x00, 0x6D, 0x00, 0x70, 0x00, 0x61, 0x00, 0x6E, 0x00, 0x79, 0x00, 0x4E, 0x00, 0x61, 0x00,
	0x6D, 0x00, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x6A, 0x00, 0x33, 0x00, 0x32, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x46, 0x00, 0x0F, 0x00, 0x01, 0x00, 0x46, 0x00, 0x69, 0x00, 0x6C, 0x00,
	0x65, 0x00, 0x44, 0x00, 0x65, 0x00, 0x73, 0x00, 0x63, 0x00, 0x72, 0x00, 0x69, 0x00, 0x70, 0x00,
	0x74, 0x00, 0x69, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4B, 0x00, 0x50, 0x00,
	0x72, 0x00, 0x6F, 0x00, 0x63, 0x00, 0x65, 0x00, 0x73, 0x00, 0x73, 0x00, 0x48, 0x00, 0x61, 0x00,
	0x63, 0x00, 0x6B, 0x00, 0x65, 0x00, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x04, 0x00,
	0x01, 0x00, 0x46, 0x00, 0x69, 0x00, 0x6C, 0x00, 0x65, 0x00, 0x56, 0x00, 0x65, 0x00, 0x72, 0x00,
	0x73, 0x00, 0x69, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x2E, 0x00,
	0x38, 0x00, 0x00, 0x00, 0x64, 0x00, 0x20, 0x00, 0x01, 0x00, 0x4C, 0x00, 0x65, 0x00, 0x67, 0x00,
	0x61, 0x00, 0x6C, 0x00, 0x43, 0x00, 0x6F, 0x00, 0x70, 0x00, 0x79, 0x00, 0x72, 0x00, 0x69, 0x00,
	0x67, 0x00, 0x68, 0x00, 0x74, 0x00, 0x00, 0x00, 0x4C, 0x00, 0x69, 0x00, 0x63, 0x00, 0x65, 0x00,
	0x6E, 0x00, 0x73, 0x00, 0x65, 0x00, 0x64, 0x00, 0x20, 0x00, 0x75, 0x00, 0x6E, 0x00, 0x64, 0x00,
	0x65, 0x00, 0x72, 0x00, 0x20, 0x00, 0x74, 0x00, 0x68, 0x00, 0x65, 0x00, 0x20, 0x00, 0x47, 0x00,
	0x4E, 0x00, 0x55, 0x00, 0x20, 0x00, 0x47, 0x00, 0x50, 0x00, 0x4C, 0x00, 0x2C, 0x00, 0x20, 0x00,
	0x76, 0x00, 0x33, 0x00, 0x2E, 0x00, 0x00, 0x00, 0x4E, 0x00, 0x13, 0x00, 0x01, 0x00, 0x4F, 0x00,
	0x72, 0x00, 0x69, 0x00, 0x67, 0x00, 0x69, 0x00, 0x6E, 0x00, 0x61, 0x00, 0x6C, 0x00, 0x46, 0x00,
	0x69, 0x00, 0x6C, 0x00, 0x65, 0x00, 0x6E, 0x00, 0x61, 0x00, 0x6D, 0x00, 0x65, 0x00, 0x00, 0x00,
	0x6B, 0x00, 0x70, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x63, 0x00, 0x65, 0x00, 0x73, 0x00, 0x73, 0x00,
	0x68, 0x00, 0x61, 0x00, 0x63, 0x00, 0x6B, 0x00, 0x65, 0x00, 0x72, 0x00, 0x2E, 0x00, 0x73, 0x00,
	0x79, 0x00, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x0F, 0x00, 0x01, 0x00, 0x50, 0x00,
	0x72, 0x00, 0x6F, 0x00, 0x64, 0x00, 0x75, 0x00, 0x63, 0x00, 0x74, 0x00, 0x4E, 0x00, 0x61, 0x00,
	0x6D, 0x00, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4B, 0x00, 0x50, 0x00, 0x72, 0x00, 0x6F, 0x00,
	0x63, 0x00, 0x65, 0x00, 0x73, 0x00, 0x73, 0x00, 0x48, 0x00, 0x61, 0x00, 0x63, 0x00, 0x6B, 0x00,
	0x65, 0x00, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2C, 0x00, 0x04, 0x00, 0x01, 0x00, 0x50, 0x00,
	0x72, 0x00, 0x6F, 0x00, 0x64, 0x00, 0x75, 0x00, 0x63, 0x00, 0x74, 0x00, 0x56, 0x00, 0x65, 0x00,
	0x72, 0x00, 0x73, 0x00, 0x69, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x00, 0x00, 0x32, 0x00, 0x2E, 0x00,
	0x38, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x01, 0x00, 0x56, 0x00, 0x61, 0x00, 0x72, 0x00,
	0x46, 0x00, 0x69, 0x00, 0x6C, 0x00, 0x65, 0x00, 0x49, 0x00, 0x6E, 0x00, 0x66, 0x00, 0x6F, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x04, 0x00, 0x00, 0x00, 0x54, 0x00, 0x72, 0x00, 0x61, 0x00,
	0x6E, 0x00, 0x73, 0x00, 0x6C, 0x00, 0x61, 0x00, 0x74, 0x00, 0x69, 0x00, 0x6F, 0x00, 0x6E, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x09, 0x04, 0xE4, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x98, 0x24, 0x00, 0x00, 0x00, 0x02, 0x02, 0x00, 0x30, 0x82, 0x24, 0x8B, 0x06, 0x09, 0x2A, 0x86,
	0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x02, 0xA0, 0x82, 0x24, 0x7C, 0x30, 0x82, 0x24, 0x78, 0x02,
	0x01, 0x01, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x05, 0x2B, 0x0E, 0x03, 0x02, 0x1A, 0x05, 0x00, 0x30,
	0x4C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x04, 0xA0, 0x3E, 0x30,
	0x3C, 0x30, 0x17, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x0F, 0x30,
	0x09, 0x03, 0x01, 0x00, 0xA0, 0x04, 0xA2, 0x02, 0x80, 0x00, 0x30, 0x21, 0x30, 0x09, 0x06, 0x05,
	0x2B, 0x0E, 0x03, 0x02, 0x1A, 0x05, 0x00, 0x04, 0x14, 0x61, 0xB5, 0x5B, 0xB7, 0xC1, 0x11, 0xF9,
	0x3B, 0xD3, 0xEA, 0x9A, 0xC7, 0x15, 0x91, 0xE1, 0xA6, 0xB8, 0x9F, 0xEE, 0xE1, 0xA0, 0x82, 0x1F,
	0xDE, 0x30, 0x82, 0x05, 0x3B, 0x30, 0x82, 0x03, 0x23, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x0A,
	0x61, 0x20, 0x4D, 0xB4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86,
	0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x7F, 0x31, 0x0B, 0x30, 0x09, 0x06,
	0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04,
	0x08, 0x13, 0x0A, 0x57, 0x61, 0x73, 0x68, 0x69, 0x6E, 0x67, 0x74, 0x6F, 0x6E, 0x31, 0x10, 0x30,
	0x0E, 0x06, 0x03, 0x55, 0x04, 0x07, 0x13, 0x07, 0x52, 0x65, 0x64, 0x6D, 0x6F, 0x6E, 0x64, 0x31,
	0x1E, 0x30, 0x1C, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x15, 0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73,
	0x6F, 0x66, 0x74, 0x20, 0x43, 0x6F, 0x72, 0x70, 0x6F, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x31,
	0x29, 0x30, 0x27, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x20, 0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73,
	0x6F, 0x66, 0x74, 0x20, 0x43, 0x6F, 0x64, 0x65, 0x20, 0x56, 0x65, 0x72, 0x69, 0x66, 0x69, 0x63,
	0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x52, 0x6F, 0x6F, 0x74, 0x30, 0x1E, 0x17, 0x0D, 0x31, 0x31,
	0x30, 0x34, 0x31, 0x35, 0x31, 0x39, 0x34, 0x35, 0x33, 0x33, 0x5A, 0x17, 0x0D, 0x32, 0x31, 0x30,
	0x34, 0x31, 0x35, 0x31, 0x39, 0x35, 0x35, 0x33, 0x33, 0x5A, 0x30, 0x6C, 0x31, 0x0B, 0x30, 0x09,
	0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55,
	0x04, 0x0A, 0x13, 0x0C, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x20, 0x49, 0x6E, 0x63,
	0x31, 0x19, 0x30, 0x17, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x10, 0x77, 0x77, 0x77, 0x2E, 0x64,
	0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x31, 0x2B, 0x30, 0x29, 0x06,
	0x03, 0x55, 0x04, 0x03, 0x13, 0x22, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x20, 0x48,
	0x69, 0x67, 0x68, 0x20, 0x41, 0x73, 0x73, 0x75, 0x72, 0x61, 0x6E, 0x63, 0x65, 0x20, 0x45, 0x56,
	0x20, 0x52, 0x6F, 0x6F, 0x74, 0x20, 0x43, 0x41, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0D, 0x06, 0x09,
	0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0F, 0x00,
	0x30, 0x82, 0x01, 0x0A, 0x02, 0x82, 0x01, 0x01, 0x00, 0xC6, 0xCC, 0xE5, 0x73, 0xE6, 0xFB, 0xD4,
	0xBB, 0xE5, 0x2D, 0x2D, 0x32, 0xA6, 0xDF, 0xE5, 0x81, 0x3F, 0xC9, 0xCD, 0x25, 0x49, 0xB6, 0x71,
	0x2A, 0xC3, 0xD5, 0x94, 0x34, 0x67, 0xA2, 0x0A, 0x1C, 0xB0, 0x5F, 0x69, 0xA6, 0x40, 0xB1, 0xC4,
	0xB7, 0xB2, 0x8F, 0xD0, 0x98, 0xA4, 0xA9, 0x41, 0x59, 0x3A, 0xD3, 0xDC, 0x94, 0xD6, 0x3C, 0xDB,
	0x74, 0x38, 0xA4, 0x4A, 0xCC, 0x4D, 0x25, 0x82, 0xF7, 0x4A, 0xA5, 0x53, 0x12, 0x38, 0xEE, 0xF3,
	0x49, 0x6D, 0x71, 0x91, 0x7E, 0x63, 0xB6, 0xAB, 0xA6, 0x5F, 0xC3, 0xA4, 0x84, 0xF8, 0x4F, 0x62,
	0x51, 0xBE, 0xF8, 0xC5, 0xEC, 0xDB, 0x38, 0x92, 0xE3, 0x06, 0xE5, 0x08, 0x91, 0x0C, 0xC4, 0x28,
	0x41, 0x55, 0xFB, 0xCB, 0x5A, 0x89, 0x15, 0x7E, 0x71, 0xE8, 0x35, 0xBF, 0x4D, 0x72, 0x09, 0x3D,
	0xBE, 0x3A, 0x38, 0x50, 0x5B, 0x77, 0x31, 0x1B, 0x8D, 0xB3, 0xC7, 0x24, 0x45, 0x9A, 0xA7, 0xAC,
	0x6D, 0x00, 0x14, 0x5A, 0x04, 0xB7, 0xBA, 0x13, 0xEB, 0x51, 0x0A, 0x98, 0x41, 0x41, 0x22, 0x4E,
	0x65, 0x61, 0x87, 0x81, 0x41, 0x50, 0xA6, 0x79, 0x5C, 0x89, 0xDE, 0x19, 0x4A, 0x57, 0xD5, 0x2E,
	0xE6, 0x5D, 0x1C, 0x53, 0x2C, 0x7E, 0x98, 0xCD, 0x1A, 0x06, 0x16, 0xA4, 0x68, 0x73, 0xD0, 0x34,
	0x04, 0x13, 0x5C, 0xA1, 0x71, 0xD3, 0x5A, 0x7C, 0x55, 0xDB, 0x5E, 0x64, 0xE1, 0x37, 0x87, 0x30,
	0x56, 0x04, 0xE5, 0x11, 0xB4, 0x29, 0x80, 0x12, 0xF1, 0x79, 0x39, 0x88, 0xA2, 0x02, 0x11, 0x7C,
	0x27, 0x66, 0xB7, 0x88, 0xB7, 0x78, 0xF2, 0xCA, 0x0A, 0xA8, 0x38, 0xAB, 0x0A, 0x64, 0xC2, 0xBF,
	0x66, 0x5D, 0x95, 0x84, 0xC1, 0xA1, 0x25, 0x1E, 0x87, 0x5D, 0x1A, 0x50, 0x0B, 0x20, 0x12, 0xCC,
	0x41, 0xBB, 0x6E, 0x0B, 0x51, 0x38, 0xB8, 0x4B, 0xCB, 0x02, 0x03, 0x01, 0x00, 0x01, 0xA3, 0x81,
	0xCB, 0x30, 0x81, 0xC8, 0x30, 0x11, 0x06, 0x03, 0x55, 0x1D, 0x20, 0x04, 0x0A, 0x30, 0x08, 0x30,
	0x06, 0x06, 0x04, 0x55, 0x1D, 0x20, 0x00, 0x30, 0x0B, 0x06, 0x03, 0x55, 0x1D, 0x0F, 0x04, 0x04,
	0x03, 0x02, 0x01, 0x86, 0x30, 0x0F, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x01, 0x01, 0xFF, 0x04, 0x05,
	0x30, 0x03, 0x01, 0x01, 0xFF, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x1D, 0x0E, 0x04, 0x16, 0x04, 0x14,
	0xB1, 0x3E, 0xC3, 0x69, 0x03, 0xF8, 0xBF, 0x47, 0x01, 0xD4, 0x98, 0x26, 0x1A, 0x08, 0x02, 0xEF,
	0x63, 0x64, 0x2B, 0xC3, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x1D, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80,
	0x14, 0x62, 0xFB, 0x0A, 0x21, 0x5B, 0x7F, 0x43, 0x6E, 0x11, 0xDA, 0x09, 0x54, 0x50, 0x6B, 0xF5,
	0xD2, 0x96, 0x71, 0xF1, 0x9E, 0x30, 0x55, 0x06, 0x03, 0x55, 0x1D, 0x1F, 0x04, 0x4E, 0x30, 0x4C,
	0x30, 0x4A, 0xA0, 0x48, 0xA0, 0x46, 0x86, 0x44, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x63,
	0x72, 0x6C, 0x2E, 0x6D, 0x69, 0x63, 0x72, 0x6F, 0x73, 0x6F, 0x66, 0x74, 0x2E, 0x63, 0x6F, 0x6D,
	0x2F, 0x70, 0x6B, 0x69, 0x2F, 0x63, 0x72, 0x6C, 0x2F, 0x70, 0x72, 0x6F, 0x64, 0x75, 0x63, 0x74,
	0x73, 0x2F, 0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73, 0x6F, 0x66, 0x74, 0x43, 0x6F, 0x64, 0x65, 0x56,
	0x65, 0x72, 0x69, 0x66, 0x52, 0x6F, 0x6F, 0x74, 0x2E, 0x63, 0x72, 0x6C, 0x30, 0x0D, 0x06, 0x09,
	0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x82, 0x02, 0x01, 0x00,
	0x20, 0x8C, 0xC1, 0x59, 0xED, 0x6F, 0x9C, 0x6B, 0x2D, 0xC1, 0x4A, 0x3E, 0x75, 0x1D, 0x45, 0x4C,
	0x41, 0x50, 0x1C, 0xBD, 0x80, 0xEA, 0xD9, 0xB0, 0x92, 0x8B, 0x06, 0x2A, 0x13, 0x3F, 0x53, 0x16,
	0x9E, 0x56, 0x39, 0x6A, 0x8A, 0x63, 0xB6, 0x78, 0x24, 0x79, 0xF5, 0x7D, 0xB8, 0xB9, 0x47, 0xA1,
	0x0A, 0x96, 0xC2, 0xF6, 0xCB, 0xBD, 0xA2, 0x66, 0x9F, 0x06, 0xE1, 0xAC, 0xD2, 0x79, 0x09, 0x0E,
	0xFD, 0x3C, 0xDC, 0xAC, 0x02, 0x0C, 0x70, 0xAF, 0x3F, 0x1B, 0xEC, 0x78, 0x7E, 0xD4, 0xEB, 0x4B,
	0x05, 0x60, 0x26, 0xD9, 0x73, 0x61, 0x91, 0x21, 0xED, 0xB0, 0x68, 0x63, 0xE0, 0x97, 0x12, 0xAB,
	0x6F, 0xA0, 0x12, 0xED, 0xD9, 0x9F, 0xD2, 0xDA, 0x27, 0x3C, 0xB3, 0xE4, 0x56, 0xF9, 0xD1, 0xD4,
	0x81, 0x0F, 0x71, 0xBD, 0x42, 0x7C, 0xA6, 0x89, 0xDC, 0xCD, 0xD5, 0xBD, 0x95, 0xA2, 0xAB, 0xF1,
	0x93, 0x11, 0x7D, 0xE8, 0xAC, 0x31, 0x29, 0xA8, 0x5D, 0x66, 0x70, 0x41, 0x9D, 0xFC, 0x75, 0xC9,
	0xD5, 0xB3, 0x1A, 0x39, 0x2A, 0xD0, 0x85, 0x05, 0x50, 0x8B, 0xAC, 0x91, 0xCA, 0xC4, 0x93, 0xCB,
	0x71, 0xA5, 0x9D, 0xA4, 0x94, 0x6F, 0x58, 0x0C, 0xFA, 0x6E, 0x20, 0xC4, 0x08, 0x31, 0xB5, 0x85,
	0x9D, 0x7E, 0x81, 0xF9, 0xD2, 0x3D, 0xCA, 0x5B, 0x18, 0x85, 0x6C, 0x0A, 0x86, 0xEC, 0x22, 0x09,
	0x1B, 0xA5, 0x74, 0x34, 0x4F, 0x7F, 0x28, 0xBC, 0x95, 0x4A, 0xAB, 0x1D, 0xB6, 0x98, 0xB0, 0x5D,
	0x09, 0xA4, 0x77, 0x76, 0x7E, 0xEF, 0xA7, 0x8E, 0x5D, 0x84, 0xF6, 0x18, 0x24, 0xCB, 0xD1, 0x6D,
	0xA6, 0xC3, 0xA1, 0x9C, 0xC2, 0x10, 0x75, 0x80, 0xFF, 0x9D, 0x32, 0xFD, 0xE6, 0xCF, 0x43, 0x3A,
	0x82, 0xF7, 0xCE, 0x8F, 0xE1, 0x72, 0x2A, 0x9B, 0x62, 0xB7, 0x5F, 0xED, 0x95, 0x1A, 0x39, 0x5C,
	0x2F, 0x94, 0x6D, 0x48, 0xB7, 0x01, 0x5F, 0x33, 0x2F, 0xBB, 0xDC, 0x2D, 0x73, 0x34, 0x89, 0x04,
	0x42, 0x0A, 0x1C, 0x8B, 0x79, 0xF9, 0xA3, 0xFA, 0x17, 0xEF, 0xFA, 0xA1, 0x1A, 0x10, 0xDF, 0xE0,
	0xB2, 0xC1, 0x95, 0xEB, 0x5C, 0x0C, 0x05, 0x97, 0x3B, 0x35, 0x3E, 0x18, 0x88, 0x4D, 0xDB, 0x6C,
	0xBF, 0x24, 0x89, 0x8D, 0xC8, 0xBD, 0xD8, 0x9F, 0x7B, 0x39, 0x3A, 0x24, 0xA0, 0xD5, 0xDF, 0xD1,
	0xF3, 0x4A, 0x1A, 0x97, 0xF6, 0xA6, 0x6F, 0x7A, 0x1F, 0xB0, 0x90, 0xA9, 0xB3, 0xAC, 0x01, 0x39,
	0x91, 0xD3, 0x61, 0xB7, 0x64, 0xF1, 0x3E, 0x57, 0x38, 0x03, 0xAF, 0xCE, 0x7A, 0xD2, 0xB5, 0x90,
	0xF5, 0xAE, 0xDC, 0x39, 0x99, 0xD5, 0xB6, 0x3C, 0x97, 0xED, 0xA6, 0xCB, 0x16, 0xC7, 0x7D, 0x6B,
	0x2A, 0x4C, 0x90, 0x94, 0xE6, 0x4C, 0x54, 0xFD, 0x1E, 0xCD, 0x20, 0xEC, 0xCE, 0x68, 0x9C, 0x87,
	0x58, 0xE9, 0x61, 0x60, 0xBE, 0xEB, 0x0E, 0xC9, 0xD5, 0x19, 0x7D, 0x9F, 0xE9, 0x78, 0xBD, 0x0E,
	0xAC, 0x21, 0x75, 0x07, 0x8F, 0xA9, 0x6E, 0xE0, 0x8C, 0x6A, 0x2A, 0x6B, 0x9C, 0xE3, 0xE7, 0x65,
	0xBC, 0xBC, 0x2D, 0x3C, 0x6D, 0xDC, 0x04, 0xDC, 0x67, 0x45, 0x36, 0x32, 0xAF, 0x04, 0x81, 0xBC,
	0xA8, 0x00, 0x6E, 0x61, 0x4C, 0x95, 0xC5, 0x5C, 0xD4, 0x8E, 0x8E, 0x9F, 0x2F, 0xC1, 0x32, 0x74,
	0xBD, 0xBD, 0x11, 0x65, 0x03, 0x07, 0xCD, 0xEF, 0xB7, 0x5E, 0x02, 0x57, 0xDA, 0x86, 0xD4, 0x1A,
	0x28, 0x34, 0xAF, 0x88, 0x49, 0xB2, 0xCF, 0xA5, 0xDD, 0x82, 0x56, 0x6F, 0x68, 0xAA, 0x14, 0xE2,
	0x59, 0x54, 0xFE, 0xFF, 0xEA, 0xEE, 0xEF, 0xEA, 0x92, 0x70, 0x22, 0x60, 0x81, 0xE3, 0x25, 0x23,
	0xC0, 0x9F, 0xCC, 0x0F, 0x49, 0xB2, 0x35, 0xAA, 0x58, 0xC3, 0x3A, 0xC3, 0xD9, 0x16, 0x94, 0x10,
	0x30, 0x82, 0x06, 0x6A, 0x30, 0x82, 0x05, 0x52, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x10, 0x03,
	0x01, 0x9A, 0x02, 0x3A, 0xFF, 0x58, 0xB1, 0x6B, 0xD6, 0xD5, 0xEA, 0xE6, 0x17, 0xF0, 0x66, 0x30,
	0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x62,
	0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x15, 0x30,
	0x13, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x0C, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74,
	0x20, 0x49, 0x6E, 0x63, 0x31, 0x19, 0x30, 0x17, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x10, 0x77,
	0x77, 0x77, 0x2E, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x31,
	0x21, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x18, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65,
	0x72, 0x74, 0x20, 0x41, 0x73, 0x73, 0x75, 0x72, 0x65, 0x64, 0x20, 0x49, 0x44, 0x20, 0x43, 0x41,
	0x2D, 0x31, 0x30, 0x1E, 0x17, 0x0D, 0x31, 0x34, 0x31, 0x30, 0x32, 0x32, 0x30, 0x30, 0x30, 0x30,
	0x30, 0x30, 0x5A, 0x17, 0x0D, 0x32, 0x34, 0x31, 0x30, 0x32, 0x32, 0x30, 0x30, 0x30, 0x30, 0x30,
	0x30, 0x5A, 0x30, 0x47, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55,
	0x53, 0x31, 0x11, 0x30, 0x0F, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x08, 0x44, 0x69, 0x67, 0x69,
	0x43, 0x65, 0x72, 0x74, 0x31, 0x25, 0x30, 0x23, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x1C, 0x44,
	0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x20, 0x54, 0x69, 0x6D, 0x65, 0x73, 0x74, 0x61, 0x6D,
	0x70, 0x20, 0x52, 0x65, 0x73, 0x70, 0x6F, 0x6E, 0x64, 0x65, 0x72, 0x30, 0x82, 0x01, 0x22, 0x30,
	0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82,
	0x01, 0x0F, 0x00, 0x30, 0x82, 0x01, 0x0A, 0x02, 0x82, 0x01, 0x01, 0x00, 0xA3, 0x64, 0x5D, 0xFC,
	0x7C, 0xB3, 0xE0, 0x82, 0x35, 0xE0, 0xE0, 0xF6, 0xC6, 0x2A, 0xE6, 0x49, 0x75, 0x3B, 0xCC, 0x6E,
	0xE0, 0x53, 0xA9, 0x9F, 0x1F, 0x64, 0x59, 0xE6, 0x7C, 0x6B, 0x7F, 0x6B, 0x8C, 0x9D, 0x55, 0xF8,
	0x92, 0xE3, 0x9E, 0xD5, 0x5A, 0x63, 0x5B, 0x02, 0x49, 0x50, 0xD9, 0x83, 0xCE, 0x6F, 0x66, 0xEE,
	0xDD, 0xCB, 0x85, 0xE9, 0x5F, 0xA5, 0xF9, 0xD4, 0x87, 0x74, 0x88, 0x44, 0x3B, 0x19, 0xC9, 0xE5,
	0xF5, 0x91, 0x9F, 0xC6, 0x14, 0x39, 0xAC, 0x24, 0xEA, 0xA8, 0x4B, 0x2C, 0x91, 0x89, 0xCC, 0x5E,
	0x28, 0xF4, 0x64, 0xB6, 0x50, 0xB7, 0xF5, 0x12, 0xB3, 0x73, 0x96, 0x0A, 0x67, 0xA3, 0xBE, 0x61,
	0x9F, 0xAE, 0xF3, 0xFD, 0x12, 0x78, 0x75, 0x0E, 0xA6, 0x5B, 0x14, 0xFD, 0x45, 0x23, 0x8E, 0x86,
	0x44, 0x55, 0x7D, 0x18, 0x86, 0x05, 0x8C, 0x55, 0x87, 0x79, 0x48, 0x46, 0xF7, 0xCA, 0x0E, 0x8D,
	0xA7, 0xDE, 0x4E, 0x5F, 0xE2, 0xA8, 0xB6, 0x2D, 0x59, 0x02, 0x61, 0x88, 0x61, 0x72, 0x18, 0x68,
	0xB9, 0xB8, 0x7C, 0xEE, 0xE6, 0xE7, 0x34, 0x2F, 0x31, 0x77, 0x81, 0x30, 0x1F, 0xBB, 0x36, 0x01,
	0x8D, 0xEF, 0x27, 0xE3, 0xF7, 0x9A, 0xF0, 0x4C, 0x31, 0x64, 0x8D, 0xE3, 0xEB, 0xFA, 0x19, 0x87,
	0xA8, 0x7E, 0xCF, 0xEC, 0x8C, 0x0C, 0x36, 0x5B, 0x7A, 0xC1, 0x7A, 0xB8, 0x78, 0xC7, 0xC9, 0x06,
	0x2E, 0x46, 0x10, 0xC8, 0x8D, 0xE8, 0x04, 0x60, 0xDB, 0xBC, 0x73, 0x74, 0xFA, 0x4E, 0xD8, 0xFE,
	0xAA, 0x40, 0xF1, 0xB2, 0xCE, 0x70, 0x46, 0x83, 0xE9, 0xDA, 0x40, 0xA1, 0x59, 0x3A, 0xD9, 0x15,
	0x09, 0x57, 0x99, 0x56, 0x30, 0x93, 0xF3, 0xC9, 0x61, 0xCC, 0xD0, 0x08, 0xCC, 0x6B, 0xEC, 0x62,
	0x42, 0x91, 0xAC, 0x02, 0xC0, 0xEF, 0xA4, 0xF0, 0x89, 0x11, 0x8F, 0x77, 0x02, 0x03, 0x01, 0x00,
	0x01, 0xA3, 0x82, 0x03, 0x35, 0x30, 0x82, 0x03, 0x31, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x1D, 0x0F,
	0x01, 0x01, 0xFF, 0x04, 0x04, 0x03, 0x02, 0x07, 0x80, 0x30, 0x0C, 0x06, 0x03, 0x55, 0x1D, 0x13,
	0x01, 0x01, 0xFF, 0x04, 0x02, 0x30, 0x00, 0x30, 0x16, 0x06, 0x03, 0x55, 0x1D, 0x25, 0x01, 0x01,
	0xFF, 0x04, 0x0C, 0x30, 0x0A, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x08, 0x30,
	0x82, 0x01, 0xBF, 0x06, 0x03, 0x55, 0x1D, 0x20, 0x04, 0x82, 0x01, 0xB6, 0x30, 0x82, 0x01, 0xB2,
	0x30, 0x82, 0x01, 0xA1, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x86, 0xFD, 0x6C, 0x07, 0x01, 0x30,
	0x82, 0x01, 0x92, 0x30, 0x28, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x02, 0x01, 0x16,
	0x1C, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3A, 0x2F, 0x2F, 0x77, 0x77, 0x77, 0x2E, 0x64, 0x69, 0x67,
	0x69, 0x63, 0x65, 0x72, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x43, 0x50, 0x53, 0x30, 0x82, 0x01,
	0x64, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x02, 0x02, 0x30, 0x82, 0x01, 0x56, 0x1E,
	0x82, 0x01, 0x52, 0x00, 0x41, 0x00, 0x6E, 0x00, 0x79, 0x00, 0x20, 0x00, 0x75, 0x00, 0x73, 0x00,
	0x65, 0x00, 0x20, 0x00, 0x6F, 0x00, 0x66, 0x00, 0x20, 0x00, 0x74, 0x00, 0x68, 0x00, 0x69, 0x00,
	0x73, 0x00, 0x20, 0x00, 0x43, 0x00, 0x65, 0x00, 0x72, 0x00, 0x74, 0x00, 0x69, 0x00, 0x66, 0x00,
	0x69, 0x00, 0x63, 0x00, 0x61, 0x00, 0x74, 0x00, 0x65, 0x00, 0x20, 0x00, 0x63, 0x00, 0x6F, 0x00,
	0x6E, 0x00, 0x73, 0x00, 0x74, 0x00, 0x69, 0x00, 0x74, 0x00, 0x75, 0x00, 0x74, 0x00, 0x65, 0x00,
	0x73, 0x00, 0x20, 0x00, 0x61, 0x00, 0x63, 0x00, 0x63, 0x00, 0x65, 0x00, 0x70, 0x00, 0x74, 0x00,
	0x61, 0x00, 0x6E, 0x00, 0x63, 0x00, 0x65, 0x00, 0x20, 0x00, 0x6F, 0x00, 0x66, 0x00, 0x20, 0x00,
	0x74, 0x00, 0x68, 0x00, 0x65, 0x00, 0x20, 0x00, 0x44, 0x00, 0x69, 0x00, 0x67, 0x00, 0x69, 0x00,
	0x43, 0x00, 0x65, 0x00, 0x72, 0x00, 0x74, 0x00, 0x20, 0x00, 0x43, 0x00, 0x50, 0x00, 0x2F, 0x00,
	0x43, 0x00, 0x50, 0x00, 0x53, 0x00, 0x20, 0x00, 0x61, 0x00, 0x6E, 0x00, 0x64, 0x00, 0x20, 0x00,
	0x74, 0x00, 0x68, 0x00, 0x65, 0x00, 0x20, 0x00, 0x52, 0x00, 0x65, 0x00, 0x6C, 0x00, 0x79, 0x00,
	0x69, 0x00, 0x6E, 0x00, 0x67, 0x00, 0x20, 0x00, 0x50, 0x00, 0x61, 0x00, 0x72, 0x00, 0x74, 0x00,
	0x79, 0x00, 0x20, 0x00, 0x41, 0x00, 0x67, 0x00, 0x72, 0x00, 0x65, 0x00, 0x65, 0x00, 0x6D, 0x00,
	0x65, 0x00, 0x6E, 0x00, 0x74, 0x00, 0x20, 0x00, 0x77, 0x00, 0x68, 0x00, 0x69, 0x00, 0x63, 0x00,
	0x68, 0x00, 0x20, 0x00, 0x6C, 0x00, 0x69, 0x00, 0x6D, 0x00, 0x69, 0x00, 0x74, 0x00, 0x20, 0x00,
	0x6C, 0x00, 0x69, 0x00, 0x61, 0x00, 0x62, 0x00, 0x69, 0x00, 0x6C, 0x00, 0x69, 0x00, 0x74, 0x00,
	0x79, 0x00, 0x20, 0x00, 0x61, 0x00, 0x6E, 0x00, 0x64, 0x00, 0x20, 0x00, 0x61, 0x00, 0x72, 0x00,
	0x65, 0x00, 0x20, 0x00, 0x69, 0x00, 0x6E, 0x00, 0x63, 0x00, 0x6F, 0x00, 0x72, 0x00, 0x70, 0x00,
	0x6F, 0x00, 0x72, 0x00, 0x61, 0x00, 0x74, 0x00, 0x65, 0x00, 0x64, 0x00, 0x20, 0x00, 0x68, 0x00,
	0x65, 0x00, 0x72, 0x00, 0x65, 0x00, 0x69, 0x00, 0x6E, 0x00, 0x20, 0x00, 0x62, 0x00, 0x79, 0x00,
	0x20, 0x00, 0x72, 0x00, 0x65, 0x00, 0x66, 0x00, 0x65, 0x00, 0x72, 0x00, 0x65, 0x00, 0x6E, 0x00,
	0x63, 0x00, 0x65, 0x00, 0x2E, 0x30, 0x0B, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x86, 0xFD, 0x6C,
	0x03, 0x15, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x1D, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0x15,
	0x00, 0x12, 0x2B, 0x13, 0x98, 0xB2, 0x99, 0x07, 0xED, 0x1E, 0xDF, 0xA2, 0xBE, 0x57, 0x0D, 0x2B,
	0x67, 0x02, 0xCD, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x1D, 0x0E, 0x04, 0x16, 0x04, 0x14, 0x61, 0x5A,
	0x4D, 0x24, 0xB6, 0x49, 0x32, 0x9D, 0x4A, 0x2A, 0x79, 0x1A, 0x83, 0x4B, 0xF4, 0x1E, 0x89, 0xC1,
	0xCA, 0x7D, 0x30, 0x7D, 0x06, 0x03, 0x55, 0x1D, 0x1F, 0x04, 0x76, 0x30, 0x74, 0x30, 0x38, 0xA0,
	0x36, 0xA0, 0x34, 0x86, 0x32, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x63, 0x72, 0x6C, 0x33,
	0x2E, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x44, 0x69,
	0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x41, 0x73, 0x73, 0x75, 0x72, 0x65, 0x64, 0x49, 0x44, 0x43,
	0x41, 0x2D, 0x31, 0x2E, 0x63, 0x72, 0x6C, 0x30, 0x38, 0xA0, 0x36, 0xA0, 0x34, 0x86, 0x32, 0x68,
	0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x63, 0x72, 0x6C, 0x34, 0x2E, 0x64, 0x69, 0x67, 0x69, 0x63,
	0x65, 0x72, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74,
	0x41, 0x73, 0x73, 0x75, 0x72, 0x65, 0x64, 0x49, 0x44, 0x43, 0x41, 0x2D, 0x31, 0x2E, 0x63, 0x72,
	0x6C, 0x30, 0x77, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x01, 0x01, 0x04, 0x6B, 0x30,
	0x69, 0x30, 0x24, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x01, 0x86, 0x18, 0x68,
	0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x6F, 0x63, 0x73, 0x70, 0x2E, 0x64, 0x69, 0x67, 0x69, 0x63,
	0x65, 0x72, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x30, 0x41, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05,
	0x07, 0x30, 0x02, 0x86, 0x35, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x63, 0x61, 0x63, 0x65,
	0x72, 0x74, 0x73, 0x2E, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2E, 0x63, 0x6F, 0x6D,
	0x2F, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x41, 0x73, 0x73, 0x75, 0x72, 0x65, 0x64,
	0x49, 0x44, 0x43, 0x41, 0x2D, 0x31, 0x2E, 0x63, 0x72, 0x74, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86,
	0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x82, 0x01, 0x01, 0x00, 0x9D, 0x25,
	0x7E, 0x1B, 0x33, 0x4D, 0xB2, 0x26, 0x81, 0x5C, 0x9B, 0x86, 0xCE, 0x23, 0x20, 0x0F, 0x80, 0x87,
	0xE5, 0x88, 0xFF, 0xFF, 0xB1, 0xD4, 0x6A, 0x2C, 0x31, 0xED, 0x3A, 0x17, 0x19, 0x71, 0x17, 0xCD,
	0xA9, 0x1B, 0xBC, 0x5A, 0x16, 0x39, 0x00, 0x9D, 0xE3, 0x6C, 0x84, 0xE4, 0x5A, 0x40, 0xFB, 0xDE,
	0x06, 0x01, 0x8C, 0x37, 0xFA, 0x9B, 0xB1, 0x9D, 0x24, 0x7E, 0xFE, 0x20, 0xA4, 0x57, 0xAD, 0x5B,
	0xB7, 0x9A, 0xB0, 0x60, 0x26, 0xEA, 0x69, 0x57, 0x21, 0x5D, 0x34, 0x2F, 0x1F, 0x71, 0xB0, 0x83,
	0x94, 0x19, 0x05, 0x6B, 0x35, 0x90, 0x10, 0xA0, 0x7B, 0x97, 0xC7, 0xF6, 0x3F, 0xE7, 0xE2, 0x11,
	0x41, 0xA6, 0xBD, 0x62, 0xD9, 0xF0, 0x27, 0x3D, 0x38, 0x1D, 0x28, 0x6F, 0x3A, 0x52, 0x09, 0xF0,
	0xEC, 0x70, 0x62, 0xD3, 0x62, 0x4B, 0xB0, 0xE0, 0x73, 0xA6, 0x92, 0xC0, 0xD3, 0x8E, 0x31, 0xD8,
	0x2F, 0xE3, 0x6D, 0x17, 0x13, 0x06, 0xEE, 0xE4, 0x03, 0xB6, 0x14, 0xAB, 0xF3, 0x8F, 0x43, 0xA7,
	0x71, 0x9D, 0x21, 0xDD, 0x14, 0xCA, 0x15, 0x5D, 0x92, 0x41, 0xDA, 0xF9, 0x0F, 0x81, 0xD1, 0x99,
	0x74, 0x0D, 0x26, 0xC4, 0x0E, 0x7F, 0x1B, 0xB5, 0xF5, 0xA0, 0xF1, 0xC6, 0x77, 0x06, 0x28, 0x15,
	0xE9, 0xD8, 0x93, 0xE5, 0x55, 0x16, 0xF0, 0xBB, 0x0A, 0xAB, 0x1C, 0xDB, 0x5C, 0x48, 0x27, 0x66,
	0xC8, 0xA3, 0x8B, 0x0A, 0x1C, 0xE5, 0x95, 0xDA, 0xAE, 0xC4, 0x2E, 0x59, 0xA0, 0x61, 0xDD, 0xDA,
	0xF3, 0x6D, 0xA2, 0x61, 0xE9, 0x8A, 0x0B, 0x6D, 0xEC, 0x12, 0x18, 0xBD, 0xF7, 0x55, 0x54, 0x40,
	0x03, 0x92, 0x2B, 0x6B, 0xC2, 0x51, 0xC2, 0x0A, 0x48, 0xAF, 0xB0, 0xD4, 0x6E, 0xE0, 0xF4, 0x14,
	0x0A, 0x3A, 0x1B, 0xE3, 0x8F, 0x3D, 0xCA, 0xAF, 0x6A, 0x8D, 0x7B, 0xDC, 0xD8, 0x44, 0x30, 0x82,
	0x06, 0x96, 0x30, 0x82, 0x05, 0x7E, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x10, 0x03, 0xE9, 0x01,
	0x7D, 0x54, 0xCD, 0x93, 0xF0, 0x94, 0xD0, 0xA2, 0xAB, 0x7F, 0xC0, 0xE3, 0xF5, 0x30, 0x0D, 0x06,
	0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x73, 0x31, 0x0B,
	0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x15, 0x30, 0x13, 0x06,
	0x03, 0x55, 0x04, 0x0A, 0x13, 0x0C, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x20, 0x49,
	0x6E, 0x63, 0x31, 0x19, 0x30, 0x17, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x10, 0x77, 0x77, 0x77,
	0x2E, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x31, 0x32, 0x30,
	0x30, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x29, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74,
	0x20, 0x48, 0x69, 0x67, 0x68, 0x20, 0x41, 0x73, 0x73, 0x75, 0x72, 0x61, 0x6E, 0x63, 0x65, 0x20,
	0x43, 0x6F, 0x64, 0x65, 0x20, 0x53, 0x69, 0x67, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x43, 0x41, 0x2D,
	0x31, 0x30, 0x1E, 0x17, 0x0D, 0x31, 0x33, 0x31, 0x30, 0x33, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
	0x30, 0x5A, 0x17, 0x0D, 0x31, 0x35, 0x31, 0x31, 0x30, 0x34, 0x31, 0x32, 0x30, 0x30, 0x30, 0x30,
	0x5A, 0x30, 0x64, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x41, 0x55,
	0x31, 0x18, 0x30, 0x16, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x0F, 0x4E, 0x65, 0x77, 0x20, 0x53,
	0x6F, 0x75, 0x74, 0x68, 0x20, 0x57, 0x61, 0x6C, 0x65, 0x73, 0x31, 0x0F, 0x30, 0x0D, 0x06, 0x03,
	0x55, 0x04, 0x07, 0x13, 0x06, 0x53, 0x79, 0x64, 0x6E, 0x65, 0x79, 0x31, 0x14, 0x30, 0x12, 0x06,
	0x03, 0x55, 0x04, 0x0A, 0x13, 0x0B, 0x57, 0x65, 0x6E, 0x20, 0x4A, 0x69, 0x61, 0x20, 0x4C, 0x69,
	0x75, 0x31, 0x14, 0x30, 0x12, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x0B, 0x57, 0x65, 0x6E, 0x20,
	0x4A, 0x69, 0x61, 0x20, 0x4C, 0x69, 0x75, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0D, 0x06, 0x09, 0x2A,
	0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0F, 0x00, 0x30,
	0x82, 0x01, 0x0A, 0x02, 0x82, 0x01, 0x01, 0x00, 0xD3, 0x1D, 0xC2, 0xE0, 0x3F, 0x42, 0x5C, 0xAD,
	0x9E, 0x41, 0x16, 0x88, 0xEF, 0x79, 0x4A, 0x73, 0x7D, 0x58, 0x94, 0xFB, 0xF5, 0xD6, 0xC5, 0x8B,
	0xB9, 0x81, 0x57, 0x59, 0x82, 0xAF, 0x2C, 0x3E, 0x87, 0xDA, 0xCF, 0x25, 0xC6, 0x34, 0x23, 0x33,
	0x95, 0xF7, 0x10, 0xAE, 0x18, 0xF7, 0xA6, 0xFF, 0x51, 0x42, 0xFF, 0xDA, 0x14, 0xE6, 0x2F, 0x01,
	0xCB, 0x3A, 0xA4, 0xB5, 0x0D, 0xDA, 0xE0, 0x33, 0x09, 0xC6, 0x57, 0xF3, 0x62, 0xE3, 0x57, 0x98,
	0x72, 0xBF, 0x88, 0x05, 0x90, 0x31, 0x3F, 0x45, 0xBE, 0x7F, 0x0A, 0x82, 0x16, 0x1D, 0xB9, 0xC3,
	0xF7, 0x00, 0x40, 0xD4, 0x37, 0x9C, 0xFA, 0x94, 0xAA, 0xDB, 0x22, 0xBC, 0x61, 0xA8, 0x75, 0xB6,
	0xC7, 0x45, 0x49, 0x16, 0xE1, 0xDE, 0xBA, 0x51, 0x50, 0x00, 0xF6, 0x76, 0xA6, 0x43, 0x27, 0xB0,
	0x3C, 0xE4, 0xA2, 0x21, 0x64, 0x38, 0x48, 0xAC, 0x89, 0x83, 0xF5, 0x2B, 0xFD, 0x41, 0xBB, 0x5A,
	0x30, 0xD3, 0xBF, 0x35, 0xCB, 0x89, 0xEB, 0x9C, 0x10, 0xC6, 0x5D, 0xD5, 0xE3, 0x6B, 0x2D, 0xE7,
	0xFD, 0x6C, 0xF9, 0xDA, 0xB3, 0x17, 0xFF, 0xC3, 0x82, 0xDA, 0x24, 0x4E, 0x76, 0x6D, 0xA5, 0x28,
	0x33, 0x52, 0x78, 0x27, 0x40, 0xFB, 0xFB, 0xF8, 0x6D, 0x38, 0x97, 0x03, 0x81, 0x83, 0x52, 0xDC,
	0xEC, 0x87, 0xA2, 0xE0, 0xAB, 0x3F, 0x87, 0xA9, 0x67, 0x5C, 0x5A, 0xDC, 0x21, 0x6A, 0x5B, 0x09,
	0x26, 0x1E, 0x19, 0x1F, 0x09, 0xD3, 0x83, 0x0C, 0x11, 0xA7, 0xCA, 0x7E, 0xBD, 0x71, 0x44, 0xCC,
	0x9B, 0xB9, 0x55, 0x67, 0xEE, 0x29, 0xE2, 0xC2, 0x2C, 0x57, 0x6C, 0xDD, 0xB0, 0x96, 0xB3, 0x06,
	0x59, 0x99, 0x0B, 0x92, 0x03, 0x24, 0xAE, 0xA3, 0x35, 0x27, 0xAA, 0x4B, 0x3A, 0xB8, 0xEA, 0x94,
	0xFD, 0xC9, 0x1A, 0xA9, 0xB7, 0xB6, 0xCC, 0x6B, 0x02, 0x03, 0x01, 0x00, 0x01, 0xA3, 0x82, 0x03,
	0x33, 0x30, 0x82, 0x03, 0x2F, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x1D, 0x23, 0x04, 0x18, 0x30, 0x16,
	0x80, 0x14, 0x97, 0x48, 0x03, 0xEB, 0x15, 0x08, 0x6B, 0xB9, 0xB2, 0x58, 0x23, 0xCC, 0x94, 0x2E,
	0xF1, 0xC6, 0x65, 0xD2, 0x64, 0x8E, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x1D, 0x0E, 0x04, 0x16, 0x04,
	0x14, 0xA8, 0xA3, 0x4D, 0x2A, 0x8E, 0xA5, 0x2E, 0x70, 0x45, 0xB6, 0xFA, 0x5B, 0xFA, 0xAD, 0x22,
	0x25, 0xED, 0xBA, 0x8B, 0x6C, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x1D, 0x0F, 0x01, 0x01, 0xFF, 0x04,
	0x04, 0x03, 0x02, 0x07, 0x80, 0x30, 0x13, 0x06, 0x03, 0x55, 0x1D, 0x25, 0x04, 0x0C, 0x30, 0x0A,
	0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x03, 0x30, 0x69, 0x06, 0x03, 0x55, 0x1D,
	0x1F, 0x04, 0x62, 0x30, 0x60, 0x30, 0x2E, 0xA0, 0x2C, 0xA0, 0x2A, 0x86, 0x28, 0x68, 0x74, 0x74,
	0x70, 0x3A, 0x2F, 0x2F, 0x63, 0x72, 0x6C, 0x33, 0x2E, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72,
	0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x68, 0x61, 0x2D, 0x63, 0x73, 0x2D, 0x32, 0x30, 0x31, 0x31,
	0x61, 0x2E, 0x63, 0x72, 0x6C, 0x30, 0x2E, 0xA0, 0x2C, 0xA0, 0x2A, 0x86, 0x28, 0x68, 0x74, 0x74,
	0x70, 0x3A, 0x2F, 0x2F, 0x63, 0x72, 0x6C, 0x34, 0x2E, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72,
	0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x68, 0x61, 0x2D, 0x63, 0x73, 0x2D, 0x32, 0x30, 0x31, 0x31,
	0x61, 0x2E, 0x63, 0x72, 0x6C, 0x30, 0x82, 0x01, 0xC4, 0x06, 0x03, 0x55, 0x1D, 0x20, 0x04, 0x82,
	0x01, 0xBB, 0x30, 0x82, 0x01, 0xB7, 0x30, 0x82, 0x01, 0xB3, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01,
	0x86, 0xFD, 0x6C, 0x03, 0x01, 0x30, 0x82, 0x01, 0xA4, 0x30, 0x3A, 0x06, 0x08, 0x2B, 0x06, 0x01,
	0x05, 0x05, 0x07, 0x02, 0x01, 0x16, 0x2E, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x77, 0x77,
	0x77, 0x2E, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x73,
	0x73, 0x6C, 0x2D, 0x63, 0x70, 0x73, 0x2D, 0x72, 0x65, 0x70, 0x6F, 0x73, 0x69, 0x74, 0x6F, 0x72,
	0x79, 0x2E, 0x68, 0x74, 0x6D, 0x30, 0x82, 0x01, 0x64, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05,
	0x07, 0x02, 0x02, 0x30, 0x82, 0x01, 0x56, 0x1E, 0x82, 0x01, 0x52, 0x00, 0x41, 0x00, 0x6E, 0x00,
	0x79, 0x00, 0x20, 0x00, 0x75, 0x00, 0x73, 0x00, 0x65, 0x00, 0x20, 0x00, 0x6F, 0x00, 0x66, 0x00,
	0x20, 0x00, 0x74, 0x00, 0x68, 0x00, 0x69, 0x00, 0x73, 0x00, 0x20, 0x00, 0x43, 0x00, 0x65, 0x00,
	0x72, 0x00, 0x74, 0x00, 0x69, 0x00, 0x66, 0x00, 0x69, 0x00, 0x63, 0x00, 0x61, 0x00, 0x74, 0x00,
	0x65, 0x00, 0x20, 0x00, 0x63, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x73, 0x00, 0x74, 0x00, 0x69, 0x00,
	0x74, 0x00, 0x75, 0x00, 0x74, 0x00, 0x65, 0x00, 0x73, 0x00, 0x20, 0x00, 0x61, 0x00, 0x63, 0x00,
	0x63, 0x00, 0x65, 0x00, 0x70, 0x00, 0x74, 0x00, 0x61, 0x00, 0x6E, 0x00, 0x63, 0x00, 0x65, 0x00,
	0x20, 0x00, 0x6F, 0x00, 0x66, 0x00, 0x20, 0x00, 0x74, 0x00, 0x68, 0x00, 0x65, 0x00, 0x20, 0x00,
	0x44, 0x00, 0x69, 0x00, 0x67, 0x00, 0x69, 0x00, 0x43, 0x00, 0x65, 0x00, 0x72, 0x00, 0x74, 0x00,
	0x20, 0x00, 0x43, 0x00, 0x50, 0x00, 0x2F, 0x00, 0x43, 0x00, 0x50, 0x00, 0x53, 0x00, 0x20, 0x00,
	0x61, 0x00, 0x6E, 0x00, 0x64, 0x00, 0x20, 0x00, 0x74, 0x00, 0x68, 0x00, 0x65, 0x00, 0x20, 0x00,
	0x52, 0x00, 0x65, 0x00, 0x6C, 0x00, 0x79, 0x00, 0x69, 0x00, 0x6E, 0x00, 0x67, 0x00, 0x20, 0x00,
	0x50, 0x00, 0x61, 0x00, 0x72, 0x00, 0x74, 0x00, 0x79, 0x00, 0x20, 0x00, 0x41, 0x00, 0x67, 0x00,
	0x72, 0x00, 0x65, 0x00, 0x65, 0x00, 0x6D, 0x00, 0x65, 0x00, 0x6E, 0x00, 0x74, 0x00, 0x20, 0x00,
	0x77, 0x00, 0x68, 0x00, 0x69, 0x00, 0x63, 0x00, 0x68, 0x00, 0x20, 0x00, 0x6C, 0x00, 0x69, 0x00,
	0x6D, 0x00, 0x69, 0x00, 0x74, 0x00, 0x20, 0x00, 0x6C, 0x00, 0x69, 0x00, 0x61, 0x00, 0x62, 0x00,
	0x69, 0x00, 0x6C, 0x00, 0x69, 0x00, 0x74, 0x00, 0x79, 0x00, 0x20, 0x00, 0x61, 0x00, 0x6E, 0x00,
	0x64, 0x00, 0x20, 0x00, 0x61, 0x00, 0x72, 0x00, 0x65, 0x00, 0x20, 0x00, 0x69, 0x00, 0x6E, 0x00,
	0x63, 0x00, 0x6F, 0x00, 0x72, 0x00, 0x70, 0x00, 0x6F, 0x00, 0x72, 0x00, 0x61, 0x00, 0x74, 0x00,
	0x65, 0x00, 0x64, 0x00, 0x20, 0x00, 0x68, 0x00, 0x65, 0x00, 0x72, 0x00, 0x65, 0x00, 0x69, 0x00,
	0x6E, 0x00, 0x20, 0x00, 0x62, 0x00, 0x79, 0x00, 0x20, 0x00, 0x72, 0x00, 0x65, 0x00, 0x66, 0x00,
	0x65, 0x00, 0x72, 0x00, 0x65, 0x00, 0x6E, 0x00, 0x63, 0x00, 0x65, 0x00, 0x2E, 0x30, 0x81, 0x86,
	0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x01, 0x01, 0x04, 0x7A, 0x30, 0x78, 0x30, 0x24,
	0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x01, 0x86, 0x18, 0x68, 0x74, 0x74, 0x70,
	0x3A, 0x2F, 0x2F, 0x6F, 0x63, 0x73, 0x70, 0x2E, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74,
	0x2E, 0x63, 0x6F, 0x6D, 0x30, 0x50, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x02,
	0x86, 0x44, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x63, 0x61, 0x63, 0x65, 0x72, 0x74, 0x73,
	0x2E, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x44, 0x69,
	0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x48, 0x69, 0x67, 0x68, 0x41, 0x73, 0x73, 0x75, 0x72, 0x61,
	0x6E, 0x63, 0x65, 0x43, 0x6F, 0x64, 0x65, 0x53, 0x69, 0x67, 0x6E, 0x69, 0x6E, 0x67, 0x43, 0x41,
	0x2D, 0x31, 0x2E, 0x63, 0x72, 0x74, 0x30, 0x0C, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x01, 0x01, 0xFF,
	0x04, 0x02, 0x30, 0x00, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01,
	0x05, 0x05, 0x00, 0x03, 0x82, 0x01, 0x01, 0x00, 0xBB, 0xC0, 0x31, 0xB3, 0xDD, 0x6B, 0x1C, 0x6E,
	0xBE, 0xC7, 0x7B, 0x8D, 0xC1, 0xEC, 0xFA, 0x93, 0x81, 0x49, 0xC6, 0x4E, 0x0C, 0x95, 0x9E, 0x58,
	0x57, 0xDB, 0x5C, 0x28, 0xEF, 0x54, 0x9D, 0xDF, 0x0B, 0xE9, 0x20, 0xCC, 0xB7, 0xEC, 0x51, 0x5A,
	0xAE, 0xB1, 0x80, 0xA2, 0x8D, 0x64, 0xA1, 0xF4, 0x06, 0x5D, 0x38, 0xCB, 0x99, 0x7D, 0xB5, 0x92,
	0x95, 0xF1, 0x23, 0x85, 0x13, 0x92, 0x90, 0x3C, 0x67, 0x3E, 0xD6, 0xD1, 0xDB, 0x93, 0x0E, 0xC1,
	0x61, 0x8A, 0xDD, 0x99, 0x89, 0xF0, 0xF1, 0xFC, 0x8D, 0x06, 0xEC, 0x5A, 0x94, 0x52, 0x42, 0xCD,
	0x74, 0x32, 0xD6, 0x83, 0x8E, 0x33, 0xB4, 0xC3, 0xE4, 0x78, 0x4E, 0x75, 0x4B, 0x64, 0xDC, 0xE0,
	0x78, 0x68, 0x6A, 0xB2, 0xE6, 0x62, 0x68, 0x48, 0xFF, 0x7D, 0xCD, 0x6F, 0xB7, 0xEF, 0xEB, 0xFF,
	0xDF, 0xDA, 0xD1, 0xEE, 0xFC, 0x1E, 0x98, 0xF9, 0xC3, 0x38, 0xFF, 0x25, 0x65, 0xF0, 0x50, 0x39,
	0x17, 0x6B, 0x24, 0x14, 0x8A, 0x84, 0x16, 0x14, 0x63, 0x51, 0x57, 0xDA, 0x5F, 0x61, 0xA1, 0x7B,
	0xBD, 0x6D, 0x47, 0x98, 0x15, 0x71, 0x4E, 0x8D, 0x30, 0x67, 0xF0, 0x32, 0x0D, 0x5E, 0x8B, 0xFA,
	0xA6, 0xE3, 0x57, 0x31, 0x80, 0x49, 0x25, 0xDF, 0x9B, 0x85, 0xBA, 0x32, 0xC0, 0xD9, 0xF4, 0xCC,
	0xD4, 0x84, 0xD6, 0xD1, 0xB2, 0x79, 0xBA, 0xD0, 0xEF, 0x22, 0xB0, 0xDA, 0x37, 0x58, 0x26, 0xEA,
	0x2E, 0x11, 0x9D, 0x5C, 0x84, 0x8D, 0x9A, 0x92, 0x75, 0xB9, 0x3A, 0xBB, 0x08, 0x4C, 0x02, 0xAF,
	0x9F, 0x1B, 0x46, 0xC5, 0x35, 0x76, 0x52, 0xF1, 0x13, 0xF5, 0x56, 0xFD, 0xB9, 0xD1, 0x90, 0x02,
	0x23, 0x34, 0x15, 0x03, 0xF4, 0xE8, 0x9B, 0x98, 0xBA, 0xE1, 0x34, 0xF7, 0xCC, 0x9D, 0x64, 0x09,
	0xFC, 0xF7, 0x2D, 0x2C, 0x74, 0x6C, 0x71, 0x4A, 0x30, 0x82, 0x06, 0xC2, 0x30, 0x82, 0x05, 0xAA,
	0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x10, 0x02, 0xC4, 0xD1, 0xE5, 0x8A, 0x4A, 0x68, 0x0C, 0x56,
	0x8D, 0xA3, 0x04, 0x7E, 0x7E, 0x4D, 0x5F, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7,
	0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x6C, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04,
	0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x0C,
	0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x20, 0x49, 0x6E, 0x63, 0x31, 0x19, 0x30, 0x17,
	0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x10, 0x77, 0x77, 0x77, 0x2E, 0x64, 0x69, 0x67, 0x69, 0x63,
	0x65, 0x72, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x31, 0x2B, 0x30, 0x29, 0x06, 0x03, 0x55, 0x04, 0x03,
	0x13, 0x22, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x20, 0x48, 0x69, 0x67, 0x68, 0x20,
	0x41, 0x73, 0x73, 0x75, 0x72, 0x61, 0x6E, 0x63, 0x65, 0x20, 0x45, 0x56, 0x20, 0x52, 0x6F, 0x6F,
	0x74, 0x20, 0x43, 0x41, 0x30, 0x1E, 0x17, 0x0D, 0x31, 0x31, 0x30, 0x32, 0x31, 0x31, 0x31, 0x32,
	0x30, 0x30, 0x30, 0x30, 0x5A, 0x17, 0x0D, 0x32, 0x36, 0x30, 0x32, 0x31, 0x30, 0x31, 0x32, 0x30,
	0x30, 0x30, 0x30, 0x5A, 0x30, 0x73, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13,
	0x02, 0x55, 0x53, 0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x0C, 0x44, 0x69,
	0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x20, 0x49, 0x6E, 0x63, 0x31, 0x19, 0x30, 0x17, 0x06, 0x03,
	0x55, 0x04, 0x0B, 0x13, 0x10, 0x77, 0x77, 0x77, 0x2E, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72,
	0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x31, 0x32, 0x30, 0x30, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x29,
	0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x20, 0x48, 0x69, 0x67, 0x68, 0x20, 0x41, 0x73,
	0x73, 0x75, 0x72, 0x61, 0x6E, 0x63, 0x65, 0x20, 0x43, 0x6F, 0x64, 0x65, 0x20, 0x53, 0x69, 0x67,
	0x6E, 0x69, 0x6E, 0x67, 0x20, 0x43, 0x41, 0x2D, 0x31, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0D, 0x06,
	0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0F,
	0x00, 0x30, 0x82, 0x01, 0x0A, 0x02, 0x82, 0x01, 0x01, 0x00, 0xC5, 0xF9, 0x23, 0xE6, 0x94, 0x27,
	0xC4, 0x80, 0x14, 0xA4, 0x80, 0x32, 0x5F, 0x40, 0xA3, 0x8D, 0x6F, 0x70, 0xC0, 0xE5, 0x36, 0x71,
	0x71, 0x3A, 0x75, 0xA4, 0xAA, 0x1A, 0x92, 0x94, 0x89, 0x5E, 0xAC, 0x23, 0x71, 0xCB, 0x4E, 0x67,
	0x7D, 0x41, 0x3F, 0xAA, 0xE3, 0x4B, 0xB7, 0x7B, 0xBE, 0x9D, 0xC1, 0xA8, 0x38, 0x8F, 0x69, 0x2F,
	0x3A, 0x24, 0xE9, 0x77, 0x59, 0x12, 0xC7, 0x66, 0x04, 0x43, 0xC2, 0x0D, 0x26, 0x82, 0x89, 0x40,
	0x19, 0xF2, 0x2C, 0xEA, 0xE7, 0x4C, 0xE7, 0x7C, 0x05, 0x1A, 0xB8, 0xFF, 0x88, 0x09, 0x4F, 0x26,
	0x37, 0xEF, 0x3A, 0xA4, 0xFA, 0x22, 0x6C, 0x88, 0xC9, 0x4A, 0x1B, 0x61, 0xF2, 0xAE, 0x10, 0x5E,
	0x6F, 0xBC, 0xD1, 0x79, 0x9B, 0x59, 0x18, 0x60, 0xE5, 0xEE, 0x29, 0xB5, 0x03, 0x2A, 0xA4, 0xCE,
	0xF1, 0x83, 0x19, 0x4F, 0x69, 0x05, 0x73, 0x28, 0x09, 0xFB, 0x22, 0x10, 0x93, 0x22, 0xA0, 0x90,
	0x19, 0x1A, 0x4C, 0x31, 0xF2, 0xD3, 0x2B, 0xD8, 0x84, 0x43, 0xAF, 0x3C, 0x63, 0xFF, 0x98, 0xDB,
	0x20, 0xD2, 0x09, 0x2B, 0x54, 0xC1, 0xEA, 0xFD, 0x6A, 0x83, 0xE7, 0x10, 0xA3, 0x12, 0x71, 0xF5,
	0xD6, 0xD7, 0xE1, 0x12, 0x7A, 0xD5, 0xE0, 0x56, 0x5A, 0xCE, 0xEA, 0x01, 0x5B, 0x68, 0x65, 0x5B,
	0xC1, 0x3F, 0x58, 0x52, 0x33, 0xA9, 0x35, 0x61, 0x4E, 0x22, 0xCB, 0x81, 0xCA, 0x36, 0xA3, 0x12,
	0xCB, 0x06, 0xD6, 0xCF, 0x1B, 0x4D, 0x18, 0x7E, 0xB9, 0x92, 0xB9, 0x12, 0xCF, 0x40, 0x26, 0xD8,
	0x9A, 0x36, 0x85, 0xB3, 0x15, 0xAA, 0x47, 0x93, 0x84, 0x6B, 0x07, 0xBB, 0xBC, 0xD5, 0xB3, 0xDE,
	0x25, 0x00, 0x11, 0x89, 0x00, 0x68, 0xC1, 0x29, 0x3C, 0xEA, 0x3E, 0x2D, 0xEE, 0x50, 0xAB, 0xD7,
	0x1C, 0x30, 0x06, 0x78, 0x3C, 0xA5, 0x10, 0x23, 0x67, 0x91, 0x02, 0x03, 0x01, 0x00, 0x01, 0xA3,
	0x82, 0x03, 0x57, 0x30, 0x82, 0x03, 0x53, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x1D, 0x0F, 0x01, 0x01,
	0xFF, 0x04, 0x04, 0x03, 0x02, 0x01, 0x86, 0x30, 0x13, 0x06, 0x03, 0x55, 0x1D, 0x25, 0x04, 0x0C,
	0x30, 0x0A, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x03, 0x30, 0x82, 0x01, 0xC3,
	0x06, 0x03, 0x55, 0x1D, 0x20, 0x04, 0x82, 0x01, 0xBA, 0x30, 0x82, 0x01, 0xB6, 0x30, 0x82, 0x01,
	0xB2, 0x06, 0x08, 0x60, 0x86, 0x48, 0x01, 0x86, 0xFD, 0x6C, 0x03, 0x30, 0x82, 0x01, 0xA4, 0x30,
	0x3A, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x02, 0x01, 0x16, 0x2E, 0x68, 0x74, 0x74,
	0x70, 0x3A, 0x2F, 0x2F, 0x77, 0x77, 0x77, 0x2E, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74,
	0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x73, 0x73, 0x6C, 0x2D, 0x63, 0x70, 0x73, 0x2D, 0x72, 0x65, 0x70,
	0x6F, 0x73, 0x69, 0x74, 0x6F, 0x72, 0x79, 0x2E, 0x68, 0x74, 0x6D, 0x30, 0x82, 0x01, 0x64, 0x06,
	0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x02, 0x02, 0x30, 0x82, 0x01, 0x56, 0x1E, 0x82, 0x01,
	0x52, 0x00, 0x41, 0x00, 0x6E, 0x00, 0x79, 0x00, 0x20, 0x00, 0x75, 0x00, 0x73, 0x00, 0x65, 0x00,
	0x20, 0x00, 0x6F, 0x00, 0x66, 0x00, 0x20, 0x00, 0x74, 0x00, 0x68, 0x00, 0x69, 0x00, 0x73, 0x00,
	0x20, 0x00, 0x43, 0x00, 0x65, 0x00, 0x72, 0x00, 0x74, 0x00, 0x69, 0x00, 0x66, 0x00, 0x69, 0x00,
	0x63, 0x00, 0x61, 0x00, 0x74, 0x00, 0x65, 0x00, 0x20, 0x00, 0x63, 0x00, 0x6F, 0x00, 0x6E, 0x00,
	0x73, 0x00, 0x74, 0x00, 0x69, 0x00, 0x74, 0x00, 0x75, 0x00, 0x74, 0x00, 0x65, 0x00, 0x73, 0x00,
	0x20, 0x00, 0x61, 0x00, 0x63, 0x00, 0x63, 0x00, 0x65, 0x00, 0x70, 0x00, 0x74, 0x00, 0x61, 0x00,
	0x6E, 0x00, 0x63, 0x00, 0x65, 0x00, 0x20, 0x00, 0x6F, 0x00, 0x66, 0x00, 0x20, 0x00, 0x74, 0x00,
	0x68, 0x00, 0x65, 0x00, 0x20, 0x00, 0x44, 0x00, 0x69, 0x00, 0x67, 0x00, 0x69, 0x00, 0x43, 0x00,
	0x65, 0x00, 0x72, 0x00, 0x74, 0x00, 0x20, 0x00, 0x43, 0x00, 0x50, 0x00, 0x2F, 0x00, 0x43, 0x00,
	0x50, 0x00, 0x53, 0x00, 0x20, 0x00, 0x61, 0x00, 0x6E, 0x00, 0x64, 0x00, 0x20, 0x00, 0x74, 0x00,
	0x68, 0x00, 0x65, 0x00, 0x20, 0x00, 0x52, 0x00, 0x65, 0x00, 0x6C, 0x00, 0x79, 0x00, 0x69, 0x00,
	0x6E, 0x00, 0x67, 0x00, 0x20, 0x00, 0x50, 0x00, 0x61, 0x00, 0x72, 0x00, 0x74, 0x00, 0x79, 0x00,
	0x20, 0x00, 0x41, 0x00, 0x67, 0x00, 0x72, 0x00, 0x65, 0x00, 0x65, 0x00, 0x6D, 0x00, 0x65, 0x00,
	0x6E, 0x00, 0x74, 0x00, 0x20, 0x00, 0x77, 0x00, 0x68, 0x00, 0x69, 0x00, 0x63, 0x00, 0x68, 0x00,
	0x20, 0x00, 0x6C, 0x00, 0x69, 0x00, 0x6D, 0x00, 0x69, 0x00, 0x74, 0x00, 0x20, 0x00, 0x6C, 0x00,
	0x69, 0x00, 0x61, 0x00, 0x62, 0x00, 0x69, 0x00, 0x6C, 0x00, 0x69, 0x00, 0x74, 0x00, 0x79, 0x00,
	0x20, 0x00, 0x61, 0x00, 0x6E, 0x00, 0x64, 0x00, 0x20, 0x00, 0x61, 0x00, 0x72, 0x00, 0x65, 0x00,
	0x20, 0x00, 0x69, 0x00, 0x6E, 0x00, 0x63, 0x00, 0x6F, 0x00, 0x72, 0x00, 0x70, 0x00, 0x6F, 0x00,
	0x72, 0x00, 0x61, 0x00, 0x74, 0x00, 0x65, 0x00, 0x64, 0x00, 0x20, 0x00, 0x68, 0x00, 0x65, 0x00,
	0x72, 0x00, 0x65, 0x00, 0x69, 0x00, 0x6E, 0x00, 0x20, 0x00, 0x62, 0x00, 0x79, 0x00, 0x20, 0x00,
	0x72, 0x00, 0x65, 0x00, 0x66, 0x00, 0x65, 0x00, 0x72, 0x00, 0x65, 0x00, 0x6E, 0x00, 0x63, 0x00,
	0x65, 0x00, 0x2E, 0x30, 0x12, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x01, 0x01, 0xFF, 0x04, 0x08, 0x30,
	0x06, 0x01, 0x01, 0xFF, 0x02, 0x01, 0x00, 0x30, 0x7F, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05,
	0x07, 0x01, 0x01, 0x04, 0x73, 0x30, 0x71, 0x30, 0x24, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05,
	0x07, 0x30, 0x01, 0x86, 0x18, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x6F, 0x63, 0x73, 0x70,
	0x2E, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x30, 0x49, 0x06,
	0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x02, 0x86, 0x3D, 0x68, 0x74, 0x74, 0x70, 0x3A,
	0x2F, 0x2F, 0x63, 0x61, 0x63, 0x65, 0x72, 0x74, 0x73, 0x2E, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65,
	0x72, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x48,
	0x69, 0x67, 0x68, 0x41, 0x73, 0x73, 0x75, 0x72, 0x61, 0x6E, 0x63, 0x65, 0x45, 0x56, 0x52, 0x6F,
	0x6F, 0x74, 0x43, 0x41, 0x2E, 0x63, 0x72, 0x74, 0x30, 0x81, 0x8F, 0x06, 0x03, 0x55, 0x1D, 0x1F,
	0x04, 0x81, 0x87, 0x30, 0x81, 0x84, 0x30, 0x40, 0xA0, 0x3E, 0xA0, 0x3C, 0x86, 0x3A, 0x68, 0x74,
	0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x63, 0x72, 0x6C, 0x33, 0x2E, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65,
	0x72, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x48,
	0x69, 0x67, 0x68, 0x41, 0x73, 0x73, 0x75, 0x72, 0x61, 0x6E, 0x63, 0x65, 0x45, 0x56, 0x52, 0x6F,
	0x6F, 0x74, 0x43, 0x41, 0x2E, 0x63, 0x72, 0x6C, 0x30, 0x40, 0xA0, 0x3E, 0xA0, 0x3C, 0x86, 0x3A,
	0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x63, 0x72, 0x6C, 0x34, 0x2E, 0x64, 0x69, 0x67, 0x69,
	0x63, 0x65, 0x72, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72,
	0x74, 0x48, 0x69, 0x67, 0x68, 0x41, 0x73, 0x73, 0x75, 0x72, 0x61, 0x6E, 0x63, 0x65, 0x45, 0x56,
	0x52, 0x6F, 0x6F, 0x74, 0x43, 0x41, 0x2E, 0x63, 0x72, 0x6C, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x1D,
	0x0E, 0x04, 0x16, 0x04, 0x14, 0x97, 0x48, 0x03, 0xEB, 0x15, 0x08, 0x6B, 0xB9, 0xB2, 0x58, 0x23,
	0xCC, 0x94, 0x2E, 0xF1, 0xC6, 0x65, 0xD2, 0x64, 0x8E, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x1D, 0x23,
	0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0xB1, 0x3E, 0xC3, 0x69, 0x03, 0xF8, 0xBF, 0x47, 0x01, 0xD4,
	0x98, 0x26, 0x1A, 0x08, 0x02, 0xEF, 0x63, 0x64, 0x2B, 0xC3, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86,
	0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x82, 0x01, 0x01, 0x00, 0x49, 0xEB,
	0x7C, 0x60, 0xBE, 0xAE, 0xEF, 0xC9, 0x7C, 0xB3, 0xC5, 0xBA, 0x4B, 0x64, 0xDF, 0x16, 0x69, 0xE2,
	0x86, 0xFA, 0x29, 0xD9, 0xDE, 0x98, 0x85, 0x7D, 0x40, 0x66, 0x26, 0x33, 0x2F, 0x44, 0x55, 0xAA,
	0xAA, 0x90, 0xE9, 0x35, 0x70, 0x0A, 0x34, 0xBE, 0xD3, 0xAE, 0x54, 0x2E, 0x8E, 0x65, 0x00, 0xD6,
	0x7A, 0x32, 0x20, 0x3E, 0x6C, 0x26, 0xB8, 0x98, 0xA9, 0x39, 0xB1, 0xBC, 0x95, 0xC7, 0xAA, 0xE9,
	0xF5, 0xEE, 0x46, 0x66, 0xC6, 0xB3, 0xE8, 0x12, 0xF8, 0xB3, 0x97, 0x9D, 0xFF, 0x74, 0x58, 0x82,
	0x34, 0x99, 0x75, 0x50, 0xAC, 0x44, 0x8F, 0xE8, 0x92, 0xCE, 0x7D, 0x8B, 0x0F, 0x31, 0x96, 0xC7,
	0xDC, 0xD3, 0x11, 0x30, 0x98, 0x74, 0x16, 0xC6, 0xE5, 0x6B, 0x45, 0x76, 0xA3, 0x94, 0x01, 0xCD,
	0x33, 0x00, 0x7A, 0x48, 0xF6, 0x6F, 0x86, 0x31, 0xC9, 0x56, 0x2B, 0x33, 0x22, 0xD5, 0xF8, 0x01,
	0xB6, 0x44, 0xCE, 0x8C, 0xB4, 0xCA, 0x88, 0xD2, 0xE4, 0x16, 0xE3, 0xE7, 0xF6, 0xE2, 0x3E, 0xE1,
	0x09, 0xC0, 0x9D, 0x79, 0x43, 0x43, 0x7F, 0x55, 0x5C, 0x05, 0xAD, 0x93, 0x10, 0xC6, 0x2C, 0x0D,
	0x6B, 0xC0, 0x9E, 0xEA, 0x78, 0xE5, 0xD2, 0x77, 0xD6, 0xB8, 0xDA, 0x9A, 0x98, 0x7F, 0xBA, 0x4C,
	0x92, 0x2B, 0x9D, 0xBD, 0xA4, 0x88, 0xB1, 0xDD, 0xAF, 0xC3, 0x4C, 0xD2, 0x97, 0x9B, 0x03, 0xC6,
	0xAE, 0x5F, 0x1B, 0x44, 0x0F, 0x33, 0x37, 0x15, 0xE3, 0xCB, 0xFF, 0x2F, 0x56, 0xD3, 0x16, 0xA4,
	0x5B, 0x55, 0x67, 0x9D, 0xA2, 0xCA, 0xDB, 0x34, 0x6C, 0x0C, 0x73, 0x4A, 0xB5, 0x7B, 0xA4, 0xB6,
	0xB3, 0xE9, 0x35, 0x02, 0x78, 0x70, 0xEC, 0x00, 0x7A, 0xCB, 0xFC, 0x4B, 0x4F, 0x22, 0x36, 0xBB,
	0x14, 0x84, 0xC9, 0x8F, 0x91, 0xDD, 0x0F, 0x3C, 0x75, 0x8C, 0xCA, 0x0B, 0x88, 0xE7, 0x30, 0x82,
	0x06, 0xCD, 0x30, 0x82, 0x05, 0xB5, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x10, 0x06, 0xFD, 0xF9,
	0x03, 0x96, 0x03, 0xAD, 0xEA, 0x00, 0x0A, 0xEB, 0x3F, 0x27, 0xBB, 0xBA, 0x1B, 0x30, 0x0D, 0x06,
	0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x65, 0x31, 0x0B,
	0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x15, 0x30, 0x13, 0x06,
	0x03, 0x55, 0x04, 0x0A, 0x13, 0x0C, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x20, 0x49,
	0x6E, 0x63, 0x31, 0x19, 0x30, 0x17, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x10, 0x77, 0x77, 0x77,
	0x2E, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x31, 0x24, 0x30,
	0x22, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x1B, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74,
	0x20, 0x41, 0x73, 0x73, 0x75, 0x72, 0x65, 0x64, 0x20, 0x49, 0x44, 0x20, 0x52, 0x6F, 0x6F, 0x74,
	0x20, 0x43, 0x41, 0x30, 0x1E, 0x17, 0x0D, 0x30, 0x36, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30,
	0x30, 0x30, 0x30, 0x5A, 0x17, 0x0D, 0x32, 0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30,
	0x30, 0x30, 0x5A, 0x30, 0x62, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02,
	0x55, 0x53, 0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x0C, 0x44, 0x69, 0x67,
	0x69, 0x43, 0x65, 0x72, 0x74, 0x20, 0x49, 0x6E, 0x63, 0x31, 0x19, 0x30, 0x17, 0x06, 0x03, 0x55,
	0x04, 0x0B, 0x13, 0x10, 0x77, 0x77, 0x77, 0x2E, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74,
	0x2E, 0x63, 0x6F, 0x6D, 0x31, 0x21, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x18, 0x44,
	0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x20, 0x41, 0x73, 0x73, 0x75, 0x72, 0x65, 0x64, 0x20,
	0x49, 0x44, 0x20, 0x43, 0x41, 0x2D, 0x31, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0D, 0x06, 0x09, 0x2A,
	0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0F, 0x00, 0x30,
	0x82, 0x01, 0x0A, 0x02, 0x82, 0x01, 0x01, 0x00, 0xE8, 0x82, 0x2D, 0x99, 0xF9, 0xCA, 0xC2, 0x42,
	0x95, 0xA5, 0x80, 0x73, 0x40, 0x70, 0xD2, 0x9E, 0x56, 0x54, 0x5C, 0xA9, 0xC4, 0xD2, 0x41, 0x06,
	0x8F, 0xC9, 0x33, 0xFC, 0x4D, 0x45, 0x91, 0x5C, 0x81, 0x9F, 0xED, 0x2C, 0x9C, 0xF8, 0x16, 0x59,
	0xDF, 0x9E, 0xB5, 0x24, 0x15, 0xC2, 0x98, 0xB9, 0xB4, 0x77, 0x49, 0xDC, 0x89, 0xC4, 0x0A, 0xDA,
	0xAF, 0xCB, 0x5E, 0x6B, 0xED, 0xAD, 0xB0, 0x71, 0x31, 0xEB, 0xCF, 0x3A, 0x40, 0x0C, 0x46, 0x4D,
	0x93, 0xEC, 0x8B, 0x7A, 0x36, 0x08, 0x03, 0xAB, 0x0C, 0x34, 0xFE, 0x18, 0x49, 0x82, 0xFE, 0xC7,
	0xC7, 0x31, 0x48, 0x80, 0x7C, 0x1E, 0xA2, 0x0F, 0x92, 0x0E, 0x50, 0xC9, 0xC6, 0x87, 0xEB, 0x36,
	0x3F, 0xD8, 0x30, 0xC3, 0xFF, 0xA6, 0xF7, 0xFB, 0xA2, 0xCD, 0x6F, 0x73, 0x23, 0xFE, 0xAC, 0x56,
	0x05, 0x90, 0xF0, 0x32, 0x21, 0x16, 0x89, 0xC6, 0x70, 0x88, 0xF9, 0x05, 0x97, 0x7D, 0xA3, 0xC7,
	0x43, 0xDD, 0x02, 0xE8, 0x3B, 0x3D, 0xED, 0xB1, 0x41, 0xA3, 0xED, 0x3F, 0xBE, 0xDB, 0x95, 0x48,
	0xC4, 0xEE, 0x1E, 0xB3, 0xF2, 0xBC, 0x0C, 0x2B, 0x99, 0xD0, 0xC6, 0x5D, 0x12, 0x42, 0x81, 0xE1,
	0x83, 0x6E, 0x82, 0x73, 0x3F, 0x26, 0x4B, 0x14, 0x90, 0xAE, 0x59, 0x66, 0x0A, 0xC4, 0x8D, 0xBE,
	0xD2, 0xCE, 0x06, 0xAE, 0xAD, 0x84, 0x6F, 0x48, 0x84, 0x9B, 0x4F, 0x40, 0xB9, 0xF1, 0x4C, 0xF2,
	0xAF, 0x98, 0xFB, 0xF6, 0xCE, 0x40, 0x5D, 0x5C, 0xF6, 0xA8, 0xF1, 0x2F, 0xAF, 0xEC, 0x89, 0x22,
	0xF2, 0x6B, 0x18, 0x65, 0xB1, 0xC1, 0x73, 0xAD, 0xD7, 0xF1, 0xD8, 0xCF, 0x1E, 0x0A, 0x74, 0x5C,
	0x42, 0xB8, 0x68, 0x7E, 0xB7, 0xD5, 0x77, 0x0A, 0x27, 0x56, 0x7C, 0x0F, 0x62, 0xA4, 0x3F, 0x32,
	0x14, 0x60, 0x95, 0xFD, 0x07, 0x04, 0xA2, 0x09, 0x02, 0x03, 0x01, 0x00, 0x01, 0xA3, 0x82, 0x03,
	0x7A, 0x30, 0x82, 0x03, 0x76, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x1D, 0x0F, 0x01, 0x01, 0xFF, 0x04,
	0x04, 0x03, 0x02, 0x01, 0x86, 0x30, 0x3B, 0x06, 0x03, 0x55, 0x1D, 0x25, 0x04, 0x34, 0x30, 0x32,
	0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x01, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05,
	0x05, 0x07, 0x03, 0x02, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x03, 0x06, 0x08,
	0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x04, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07,
	0x03, 0x08, 0x30, 0x82, 0x01, 0xD2, 0x06, 0x03, 0x55, 0x1D, 0x20, 0x04, 0x82, 0x01, 0xC9, 0x30,
	0x82, 0x01, 0xC5, 0x30, 0x82, 0x01, 0xB4, 0x06, 0x0A, 0x60, 0x86, 0x48, 0x01, 0x86, 0xFD, 0x6C,
	0x00, 0x01, 0x04, 0x30, 0x82, 0x01, 0xA4, 0x30, 0x3A, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05,
	0x07, 0x02, 0x01, 0x16, 0x2E, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x77, 0x77, 0x77, 0x2E,
	0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x73, 0x73, 0x6C,
	0x2D, 0x63, 0x70, 0x73, 0x2D, 0x72, 0x65, 0x70, 0x6F, 0x73, 0x69, 0x74, 0x6F, 0x72, 0x79, 0x2E,
	0x68, 0x74, 0x6D, 0x30, 0x82, 0x01, 0x64, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x02,
	0x02, 0x30, 0x82, 0x01, 0x56, 0x1E, 0x82, 0x01, 0x52, 0x00, 0x41, 0x00, 0x6E, 0x00, 0x79, 0x00,
	0x20, 0x00, 0x75, 0x00, 0x73, 0x00, 0x65, 0x00, 0x20, 0x00, 0x6F, 0x00, 0x66, 0x00, 0x20, 0x00,
	0x74, 0x00, 0x68, 0x00, 0x69, 0x00, 0x73, 0x00, 0x20, 0x00, 0x43, 0x00, 0x65, 0x00, 0x72, 0x00,
	0x74, 0x00, 0x69, 0x00, 0x66, 0x00, 0x69, 0x00, 0x63, 0x00, 0x61, 0x00, 0x74, 0x00, 0x65, 0x00,
	0x20, 0x00, 0x63, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x73, 0x00, 0x74, 0x00, 0x69, 0x00, 0x74, 0x00,
	0x75, 0x00, 0x74, 0x00, 0x65, 0x00, 0x73, 0x00, 0x20, 0x00, 0x61, 0x00, 0x63, 0x00, 0x63, 0x00,
	0x65, 0x00, 0x70, 0x00, 0x74, 0x00, 0x61, 0x00, 0x6E, 0x00, 0x63, 0x00, 0x65, 0x00, 0x20, 0x00,
	0x6F, 0x00, 0x66, 0x00, 0x20, 0x00, 0x74, 0x00, 0x68, 0x00, 0x65, 0x00, 0x20, 0x00, 0x44, 0x00,
	0x69, 0x00, 0x67, 0x00, 0x69, 0x00, 0x43, 0x00, 0x65, 0x00, 0x72, 0x00, 0x74, 0x00, 0x20, 0x00,
	0x43, 0x00, 0x50, 0x00, 0x2F, 0x00, 0x43, 0x00, 0x50, 0x00, 0x53, 0x00, 0x20, 0x00, 0x61, 0x00,
	0x6E, 0x00, 0x64, 0x00, 0x20, 0x00, 0x74, 0x00, 0x68, 0x00, 0x65, 0x00, 0x20, 0x00, 0x52, 0x00,
	0x65, 0x00, 0x6C, 0x00, 0x79, 0x00, 0x69, 0x00, 0x6E, 0x00, 0x67, 0x00, 0x20, 0x00, 0x50, 0x00,
	0x61, 0x00, 0x72, 0x00, 0x74, 0x00, 0x79, 0x00, 0x20, 0x00, 0x41, 0x00, 0x67, 0x00, 0x72, 0x00,
	0x65, 0x00, 0x65, 0x00, 0x6D, 0x00, 0x65, 0x00, 0x6E, 0x00, 0x74, 0x00, 0x20, 0x00, 0x77, 0x00,
	0x68, 0x00, 0x69, 0x00, 0x63, 0x00, 0x68, 0x00, 0x20, 0x00, 0x6C, 0x00, 0x69, 0x00, 0x6D, 0x00,
	0x69, 0x00, 0x74, 0x00, 0x20, 0x00, 0x6C, 0x00, 0x69, 0x00, 0x61, 0x00, 0x62, 0x00, 0x69, 0x00,
	0x6C, 0x00, 0x69, 0x00, 0x74, 0x00, 0x79, 0x00, 0x20, 0x00, 0x61, 0x00, 0x6E, 0x00, 0x64, 0x00,
	0x20, 0x00, 0x61, 0x00, 0x72, 0x00, 0x65, 0x00, 0x20, 0x00, 0x69, 0x00, 0x6E, 0x00, 0x63, 0x00,
	0x6F, 0x00, 0x72, 0x00, 0x70, 0x00, 0x6F, 0x00, 0x72, 0x00, 0x61, 0x00, 0x74, 0x00, 0x65, 0x00,
	0x64, 0x00, 0x20, 0x00, 0x68, 0x00, 0x65, 0x00, 0x72, 0x00, 0x65, 0x00, 0x69, 0x00, 0x6E, 0x00,
	0x20, 0x00, 0x62, 0x00, 0x79, 0x00, 0x20, 0x00, 0x72, 0x00, 0x65, 0x00, 0x66, 0x00, 0x65, 0x00,
	0x72, 0x00, 0x65, 0x00, 0x6E, 0x00, 0x63, 0x00, 0x65, 0x00, 0x2E, 0x30, 0x0B, 0x06, 0x09, 0x60,
	0x86, 0x48, 0x01, 0x86, 0xFD, 0x6C, 0x03, 0x15, 0x30, 0x12, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x01,
	0x01, 0xFF, 0x04, 0x08, 0x30, 0x06, 0x01, 0x01, 0xFF, 0x02, 0x01, 0x00, 0x30, 0x79, 0x06, 0x08,
	0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x01, 0x01, 0x04, 0x6D, 0x30, 0x6B, 0x30, 0x24, 0x06, 0x08,
	0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x01, 0x86, 0x18, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F,
	0x2F, 0x6F, 0x63, 0x73, 0x70, 0x2E, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2E, 0x63,
	0x6F, 0x6D, 0x30, 0x43, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x02, 0x86, 0x37,
	0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x63, 0x61, 0x63, 0x65, 0x72, 0x74, 0x73, 0x2E, 0x64,
	0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x44, 0x69, 0x67, 0x69,
	0x43, 0x65, 0x72, 0x74, 0x41, 0x73, 0x73, 0x75, 0x72, 0x65, 0x64, 0x49, 0x44, 0x52, 0x6F, 0x6F,
	0x74, 0x43, 0x41, 0x2E, 0x63, 0x72, 0x74, 0x30, 0x81, 0x81, 0x06, 0x03, 0x55, 0x1D, 0x1F, 0x04,
	0x7A, 0x30, 0x78, 0x30, 0x3A, 0xA0, 0x38, 0xA0, 0x36, 0x86, 0x34, 0x68, 0x74, 0x74, 0x70, 0x3A,
	0x2F, 0x2F, 0x63, 0x72, 0x6C, 0x33, 0x2E, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2E,
	0x63, 0x6F, 0x6D, 0x2F, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x41, 0x73, 0x73, 0x75,
	0x72, 0x65, 0x64, 0x49, 0x44, 0x52, 0x6F, 0x6F, 0x74, 0x43, 0x41, 0x2E, 0x63, 0x72, 0x6C, 0x30,
	0x3A, 0xA0, 0x38, 0xA0, 0x36, 0x86, 0x34, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x63, 0x72,
	0x6C, 0x34, 0x2E, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x2F,
	0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x41, 0x73, 0x73, 0x75, 0x72, 0x65, 0x64, 0x49,
	0x44, 0x52, 0x6F, 0x6F, 0x74, 0x43, 0x41, 0x2E, 0x63, 0x72, 0x6C, 0x30, 0x1D, 0x06, 0x03, 0x55,
	0x1D, 0x0E, 0x04, 0x16, 0x04, 0x14, 0x15, 0x00, 0x12, 0x2B, 0x13, 0x98, 0xB2, 0x99, 0x07, 0xED,
	0x1E, 0xDF, 0xA2, 0xBE, 0x57, 0x0D, 0x2B, 0x67, 0x02, 0xCD, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x1D,
	0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0x45, 0xEB, 0xA2, 0xAF, 0xF4, 0x92, 0xCB, 0x82, 0x31,
	0x2D, 0x51, 0x8B, 0xA7, 0xA7, 0x21, 0x9D, 0xF3, 0x6D, 0xC8, 0x0F, 0x30, 0x0D, 0x06, 0x09, 0x2A,
	0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x82, 0x01, 0x01, 0x00, 0x46,
	0x50, 0x3E, 0xC9, 0xB7, 0x28, 0x24, 0xA7, 0x38, 0x1D, 0xB6, 0x5B, 0x29, 0xAF, 0x52, 0xCF, 0x52,
	0xE9, 0x31, 0x47, 0xAB, 0x56, 0x5C, 0x7B, 0xD5, 0x0D, 0x0B, 0x41, 0xB3, 0xEF, 0xEC, 0x75, 0x1F,
	0x74, 0x38, 0xF2, 0xB2, 0x5C, 0x61, 0xA2, 0x9C, 0x95, 0xC3, 0x50, 0xE4, 0x82, 0xB9, 0x23, 0xD1,
	0xBA, 0x3A, 0x86, 0x72, 0xAD, 0x38, 0x78, 0xAC, 0x75, 0x5D, 0x17, 0x17, 0x34, 0x72, 0x47, 0x85,
	0x94, 0x56, 0xD1, 0xEB, 0xBB, 0x36, 0x84, 0x77, 0xCC, 0x24, 0xA5, 0xF3, 0x04, 0x19, 0x55, 0xA9,
	0xE7, 0xE3, 0xE7, 0xAB, 0x62, 0xCD, 0xFB, 0x8B, 0x2D, 0x90, 0xC2, 0xC0, 0xD2, 0xB5, 0x94, 0xBD,
	0x5E, 0x4F, 0xB1, 0x05, 0xD2, 0x0E, 0x3D, 0x1A, 0xA9, 0x14, 0x5B, 0xA6, 0x86, 0x31, 0x62, 0xA8,
	0xA8, 0x33, 0xE4, 0x9B, 0x39, 0xA7, 0xC4, 0xF5, 0xCE, 0x1D, 0x78, 0x76, 0x94, 0x25, 0x73, 0xE4,
	0x2A, 0xAB, 0xCF, 0x9C, 0x76, 0x4B, 0xED, 0x5F, 0xC2, 0x4B, 0x16, 0xE4, 0x4B, 0x70, 0x4C, 0x00,
	0x89, 0x1E, 0xFC, 0xC5, 0x79, 0xBC, 0x4C, 0x12, 0x57, 0xFE, 0x5F, 0xE1, 0x1E, 0xBC, 0x02, 0x5D,
	0xA8, 0xFE, 0xFB, 0x07, 0x38, 0x4F, 0x0D, 0xC6, 0x5D, 0x91, 0xB9, 0x0F, 0x67, 0x45, 0xCD, 0xD6,
	0x83, 0xED, 0xE7, 0x92, 0x0D, 0x8D, 0xB1, 0x69, 0x8C, 0x4F, 0xFB, 0x59, 0xE0, 0x23, 0x0F, 0xD2,
	0xAA, 0xAE, 0x00, 0x7C, 0xEE, 0x9C, 0x42, 0x0E, 0xCF, 0x91, 0xD7, 0x27, 0xB7, 0x16, 0xEE, 0x0F,
	0xC3, 0xBD, 0x7C, 0x0A, 0xA0, 0xEE, 0x2C, 0x08, 0x55, 0x85, 0x22, 0xB8, 0xEB, 0x18, 0x1A, 0x4D,
	0xFC, 0x2A, 0x21, 0xAD, 0x49, 0x31, 0x83, 0x47, 0x95, 0x77, 0x71, 0xDC, 0xB1, 0x1B, 0x4B, 0x4B,
	0x1C, 0x10, 0x9C, 0x77, 0x14, 0xC1, 0x9D, 0x4F, 0x2F, 0x5A, 0x95, 0x08, 0x29, 0x10, 0x26, 0x31,
	0x82, 0x04, 0x34, 0x30, 0x82, 0x04, 0x30, 0x02, 0x01, 0x01, 0x30, 0x81, 0x87, 0x30, 0x73, 0x31,
	0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x15, 0x30, 0x13,
	0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x0C, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x20,
	0x49, 0x6E, 0x63, 0x31, 0x19, 0x30, 0x17, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x10, 0x77, 0x77,
	0x77, 0x2E, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x31, 0x32,
	0x30, 0x30, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x29, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72,
	0x74, 0x20, 0x48, 0x69, 0x67, 0x68, 0x20, 0x41, 0x73, 0x73, 0x75, 0x72, 0x61, 0x6E, 0x63, 0x65,
	0x20, 0x43, 0x6F, 0x64, 0x65, 0x20, 0x53, 0x69, 0x67, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x43, 0x41,
	0x2D, 0x31, 0x02, 0x10, 0x03, 0xE9, 0x01, 0x7D, 0x54, 0xCD, 0x93, 0xF0, 0x94, 0xD0, 0xA2, 0xAB,
	0x7F, 0xC0, 0xE3, 0xF5, 0x30, 0x09, 0x06, 0x05, 0x2B, 0x0E, 0x03, 0x02, 0x1A, 0x05, 0x00, 0xA0,
	0x70, 0x30, 0x10, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x0C, 0x31,
	0x02, 0x30, 0x00, 0x30, 0x19, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x03,
	0x31, 0x0C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x04, 0x30, 0x1C,
	0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x0B, 0x31, 0x0E, 0x30, 0x0C,
	0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x15, 0x30, 0x23, 0x06, 0x09,
	0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x04, 0x31, 0x16, 0x04, 0x14, 0xF8, 0xB8, 0xAC,
	0xF6, 0x28, 0x3C, 0xAB, 0x9E, 0x8A, 0xB4, 0x24, 0x66, 0x1F, 0x67, 0x41, 0xD5, 0x52, 0xC4, 0x20,
	0xB1, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00,
	0x04, 0x82, 0x01, 0x00, 0x00, 0x1E, 0x16, 0xBC, 0xB2, 0x31, 0x8C, 0xBA, 0xD8, 0x58, 0x9E, 0x10,
	0x38, 0xA7, 0x08, 0x7A, 0x56, 0xE4, 0xB3, 0x80, 0x58, 0xB2, 0xE1, 0x34, 0x0C, 0xDF, 0x68, 0x7A,
	0x55, 0x43, 0x56, 0x27, 0xFE, 0xF4, 0x98, 0xDF, 0x47, 0xDD, 0x7A, 0xDA, 0x53, 0xB6, 0x67, 0xD8,
	0xB4, 0x11, 0x91, 0xF8, 0xFC, 0xE3, 0xD2, 0x86, 0x9B, 0xE1, 0x3A, 0x39, 0x1E, 0x08, 0xB8, 0xA0,
	0x60, 0xB8, 0x3A, 0x01, 0x68, 0xAF, 0xB4, 0xD3, 0x2E, 0xF6, 0xD3, 0x27, 0x01, 0xB8, 0x48, 0x63,
	0x29, 0x94, 0x39, 0x0B, 0x0E, 0x99, 0xAD, 0x4B, 0xC4, 0x91, 0x3F, 0x3C, 0x81, 0x05, 0x69, 0x38,
	0x8D, 0xB1, 0x95, 0x15, 0x7C, 0x7A, 0x0E, 0x53, 0x16, 0x19, 0xEC, 0x67, 0x2B, 0x4F, 0xA8, 0xE7,
	0xDA, 0x64, 0x27, 0x05, 0x16, 0x68, 0x03, 0xAB, 0xBB, 0xEB, 0xCB, 0xC9, 0x80, 0x83, 0xB6, 0x95,
	0x87, 0x8A, 0x4F, 0xAC, 0x72, 0x66, 0x63, 0x7E, 0xA3, 0xD0, 0x0F, 0xDB, 0xC7, 0x8B, 0x7F, 0xFA,
	0x39, 0x41, 0x71, 0xDE, 0xE5, 0x51, 0xF2, 0x50, 0xD2, 0xEF, 0xD9, 0x77, 0xE4, 0xFA, 0x88, 0x30,
	0xC9, 0xF9, 0xBB, 0xAE, 0x63, 0xA7, 0x12, 0x09, 0x65, 0x61, 0x79, 0x11, 0xB8, 0xC4, 0x4B, 0x77,
	0x9E, 0x4F, 0xB8, 0xCB, 0xEB, 0x96, 0x92, 0xA9, 0xB8, 0x0F, 0x27, 0xBB, 0xDF, 0x04, 0x3D, 0x6D,
	0xED, 0x74, 0x96, 0x71, 0x76, 0xF6, 0xDC, 0x7A, 0x79, 0xDF, 0xDA, 0x0D, 0x4E, 0x47, 0x25, 0x01,
	0x32, 0xED, 0x07, 0xFD, 0xCB, 0x5B, 0x92, 0xB7, 0x79, 0x6F, 0x7A, 0xD7, 0x6A, 0x93, 0xCB, 0xF8,
	0x1E, 0x98, 0xB3, 0x8B, 0x56, 0x51, 0x29, 0x78, 0x89, 0x4D, 0x52, 0x4A, 0xFA, 0x7E, 0xD7, 0x2E,
	0x9E, 0x63, 0xD8, 0x1D, 0xA2, 0xCA, 0xEF, 0xAC, 0x78, 0xDC, 0x93, 0x92, 0x06, 0x76, 0x0D, 0xA8,
	0x5B, 0x7D, 0x4A, 0x5F, 0xA1, 0x82, 0x02, 0x0F, 0x30, 0x82, 0x02, 0x0B, 0x06, 0x09, 0x2A, 0x86,
	0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x06, 0x31, 0x82, 0x01, 0xFC, 0x30, 0x82, 0x01, 0xF8, 0x02,
	0x01, 0x01, 0x30, 0x76, 0x30, 0x62, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13,
	0x02, 0x55, 0x53, 0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x0C, 0x44, 0x69,
	0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x20, 0x49, 0x6E, 0x63, 0x31, 0x19, 0x30, 0x17, 0x06, 0x03,
	0x55, 0x04, 0x0B, 0x13, 0x10, 0x77, 0x77, 0x77, 0x2E, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72,
	0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x31, 0x21, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x18,
	0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x20, 0x41, 0x73, 0x73, 0x75, 0x72, 0x65, 0x64,
	0x20, 0x49, 0x44, 0x20, 0x43, 0x41, 0x2D, 0x31, 0x02, 0x10, 0x03, 0x01, 0x9A, 0x02, 0x3A, 0xFF,
	0x58, 0xB1, 0x6B, 0xD6, 0xD5, 0xEA, 0xE6, 0x17, 0xF0, 0x66, 0x30, 0x09, 0x06, 0x05, 0x2B, 0x0E,
	0x03, 0x02, 0x1A, 0x05, 0x00, 0xA0, 0x5D, 0x30, 0x18, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7,
	0x0D, 0x01, 0x09, 0x03, 0x31, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07,
	0x01, 0x30, 0x1C, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x05, 0x31, 0x0F,
	0x17, 0x0D, 0x31, 0x35, 0x30, 0x35, 0x33, 0x30, 0x30, 0x38, 0x34, 0x32, 0x31, 0x34, 0x5A, 0x30,
	0x23, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x04, 0x31, 0x16, 0x04, 0x14,
	0x84, 0xE8, 0x74, 0xD1, 0xD0, 0x66, 0x0A, 0x35, 0x18, 0x65, 0x77, 0xDE, 0xBC, 0x98, 0x4F, 0x63,
	0xB7, 0xC4, 0xC2, 0xB4, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01,
	0x01, 0x05, 0x00, 0x04, 0x82, 0x01, 0x00, 0x07, 0xA9, 0xF9, 0xCD, 0x0D, 0xDD, 0xF4, 0xB4, 0x53,
	0x47, 0x01, 0x4A, 0x16, 0x89, 0x97, 0xBE, 0x07, 0xC5, 0xE5, 0x33, 0x85, 0xDC, 0x36, 0xFF, 0x63,
	0xE7, 0xF0, 0x5D, 0xE4, 0x56, 0xA8, 0x0A, 0xEA, 0x1D, 0x21, 0xB6, 0xE9, 0x56, 0xCF, 0x1E, 0x1A,
	0xC6, 0x33, 0x3F, 0xF3, 0xDD, 0xED, 0xAC, 0x5D, 0x72, 0x55, 0xAA, 0x5D, 0x43, 0x5E, 0xC8, 0xC4,
	0x91, 0x40, 0xFD, 0x27, 0x07, 0x13, 0xEF, 0x89, 0x40, 0xA3, 0x52, 0xC2, 0x29, 0x69, 0xDC, 0x82,
	0xE7, 0x85, 0xB7, 0xBB, 0x49, 0x86, 0x3D, 0x58, 0x19, 0xD0, 0xC6, 0x3B, 0x51, 0x88, 0x4D, 0xCA,
	0x02, 0x05, 0xC8, 0xA1, 0x86, 0x8D, 0xE5, 0x18, 0x8C, 0xFB, 0x76, 0xB8, 0x22, 0x64, 0x10, 0xC2,
	0xAC, 0x7A, 0x6B, 0x70, 0x50, 0x8E, 0xD3, 0xDD, 0xFE, 0x37, 0x7F, 0x38, 0x27, 0x5B, 0x69, 0x04,
	0x08, 0x73, 0xB6, 0xC4, 0x9D, 0x31, 0x79, 0x6F, 0xFE, 0x11, 0xFE, 0xE3, 0xA2, 0x6E, 0xB9, 0x9A,
	0x37, 0xBB, 0x73, 0x19, 0x80, 0x6A, 0x3A, 0x0F, 0x85, 0xC7, 0x54, 0x09, 0x8D, 0xAA, 0x53, 0xBE,
	0x72, 0x62, 0x9D, 0x8E, 0xBA, 0x5B, 0xAB, 0xD9, 0xA3, 0x02, 0x95, 0xF1, 0x59, 0xCD, 0x79, 0x67,
	0xE0, 0x86, 0x05, 0xA0, 0x3C, 0xDE, 0x3C, 0x60, 0xDD, 0xB5, 0x11, 0xA7, 0x64, 0x03, 0x5E, 0xFE,
	0x85, 0x5E, 0x1E, 0xFC, 0x5B, 0xE7, 0xEB, 0x2A, 0x16, 0x95, 0x66, 0x75, 0xBD, 0x0C, 0x48, 0x1C,
	0xFD, 0x61, 0x8B, 0x3B, 0xA9, 0xC2, 0xD3, 0x99, 0x24, 0x8E, 0x6F, 0x42, 0x45, 0x49, 0x31, 0x6B,
	0x85, 0x1B, 0x3E, 0x56, 0x06, 0x92, 0x93, 0xDE, 0xB3, 0xB5, 0x89, 0xDA, 0x2F, 0xE8, 0x84, 0x19,
	0xD4, 0x83, 0xB9, 0x1B, 0xD8, 0xE0, 0xE3, 0x47, 0x0E, 0xF6, 0xD1, 0xBB, 0xB7, 0x05, 0x2F, 0xD9,
	0x56, 0xA6, 0xDA, 0xF4, 0x1A, 0xEA, 0x51, 0x00
};
```

`UnrealFinderTool/Logger.cpp`:

```cpp
#include "pch.h"
#include "Logger.h"

std::ostream* Logger::stream = nullptr;

void Logger::SetStream(std::ostream* _stream)
{
	stream = _stream;
}

void Logger::Log(const std::string& message)
{
	if (stream != nullptr)
	{
		(*stream) << message << '\n' << std::flush;
	}
}

```

`UnrealFinderTool/Logger.h`:

```h
#pragma once

#include <ostream>
#include <string>
#include <chrono>

#include "tinyformat.h"

class Logger
{
public:

	/// <summary>
	/// Sets the stream where the output goes to.
	/// </summary>
	/// <param name="stream">[in] The stream.</param>
	static void SetStream(std::ostream* stream);

	/// <summary>
	/// Logs the given message.
	/// </summary>
	/// <param name="message">The message.</param>
	static void Log(const std::string& message);

	/// <summary>
	/// Formats and logs the given message.
	/// </summary>
	/// <typeparam name="Args">Type of the arguments.</typeparam>
	/// <param name="fmt">Describes the format to use.</param>
	/// <param name="args">Variable arguments providing the arguments.</param>
	template<typename... Args>
	static void Log(const char* fmt, const Args&... args)
	{
		Log(tfm::format(fmt, args...));
	}

private:
	static std::ostream *stream;
};

```

`UnrealFinderTool/Memory.cpp`:

```cpp
#include "pch.h"
#include "JsonReflector.h"
#include "Memory.h"

#include <TlHelp32.h>
#include <psapi.h>

BypaPH* Memory::bypaPh = nullptr;

Memory::Memory(const HANDLE processHandle, const bool useKernal)
{
	if (processHandle == nullptr || processHandle == INVALID_HANDLE_VALUE)
		throw std::exception("processId can't be NULL");

	ProcessHandle = processHandle;
	ProcessId = GetProcessId(processHandle);
	this->useKernal = useKernal;
	if (useKernal && bypaPh == nullptr)
		bypaPh = new BypaPH(ProcessId);

	IsWow64Process(ProcessHandle, &Is64Bit);
	Is64Bit = !Is64Bit;
}

Memory::Memory(const int processId, const bool useKernal)
{
	if (processId == 0)
		return;

	ProcessHandle = OpenProcess(PROCESS_ALL_ACCESS, false, processId);
	ProcessId = GetProcessId(ProcessHandle);
	this->useKernal = useKernal;
	if (useKernal && bypaPh == nullptr)
		bypaPh = new BypaPH(ProcessId);

	IsWow64Process(ProcessHandle, &Is64Bit);
	Is64Bit = !Is64Bit;
}

void Memory::UpdateHandle(const HANDLE processHandle)
{
	ProcessHandle = processHandle;
}

int Memory::GetProcessIdByName(const std::string& processName)
{
	PROCESSENTRY32 pe32;
	pe32.dwSize = sizeof(PROCESSENTRY32);
	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

	if (Process32First(hSnapshot, &pe32))
	{
		do
		{
			if (processName == pe32.szExeFile)
				break;
		}
		while (Process32Next(hSnapshot, &pe32));
	}

	if (hSnapshot != INVALID_HANDLE_VALUE)
		CloseHandle(hSnapshot);
	const int err = GetLastError();
	//std::cout << err << std::endl;
	if (err != 0)
		return 0;
	return pe32.th32ProcessID;
}

std::string Memory::GetProcessNameById(const DWORD pId)
{
	std::string ret;
	PROCESSENTRY32 pe32;
	pe32.dwSize = sizeof(PROCESSENTRY32);
	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

	if (Process32First(hSnapshot, &pe32))
	{
		do
		{
			if (pe32.th32ProcessID == pId)
			{
				ret = pe32.szExeFile;
				break;
			}
		}
		while (Process32Next(hSnapshot, &pe32));
	}

	if (hSnapshot != INVALID_HANDLE_VALUE)
		CloseHandle(hSnapshot);

	const int err = GetLastError();
	//std::cout << err << std::endl;
	if (err != 0)
		return ret;
	return ret;
}

MODULEINFO Memory::GetModuleInfo(const LPCTSTR lpModuleName)
{
	MODULEINFO miInfos = {nullptr};
	const HMODULE hModule = GetModuleHandle(lpModuleName);
	if (hModule) GetModuleInformation(GetCurrentProcess(), hModule, &miInfos, sizeof MODULEINFO);

	return miInfos;
}

bool Memory::IsHandleValid(const HANDLE processHandle)
{
	if (!processHandle || processHandle == INVALID_HANDLE_VALUE)
		return false;

	DWORD handleInformation;
	return GetHandleInformation(processHandle, &handleInformation) == TRUE;
}

bool Memory::IsValidProcess(const int p_id, const PHANDLE pHandle)
{
	DWORD exitCode;
	HANDLE p = OpenProcess(PROCESS_ALL_ACCESS, false, p_id);
	bool valid = p_id != 0 && GetExitCodeProcess(p, &exitCode) != FALSE && exitCode == STILL_ACTIVE;

	if (pHandle && valid)
		*pHandle = p;
	else if (valid)
		CloseHandle(p);

	return valid;
}

bool Memory::IsValidProcess(const int p_id)
{
	return IsValidProcess(p_id, nullptr);
}

bool Memory::IsStaticAddress(const uintptr_t address)
{
	if (ProcessId == NULL || address == NULL)
		return false;

	auto queryVirtualMemory = reinterpret_cast<hsNtQueryVirtualMemory>(GetProcAddress(LoadLibraryW(L"ntdll.dll"), "NtQueryVirtualMemory"));

	if (!queryVirtualMemory)
		return false;

	if (!IsHandleValid(ProcessHandle))
		return false;

	SECTION_INFO sectionInformation;

	NTSTATUS returnStatus = queryVirtualMemory(ProcessHandle, reinterpret_cast<PVOID>(address), MemoryMappedFilenameInformation, &sectionInformation, sizeof(sectionInformation), nullptr);

	if (!NT_SUCCESS(returnStatus))
		return false;

	wchar_t* deviceName = sectionInformation.szData;
	wchar_t* filePath = deviceName;

	while (*(filePath++) != '\\') {} 
	while (*(filePath++) != '\\') {}
	while (*(filePath++) != '\\') {}
	*(filePath - 1) = 0;

	auto driveLetters = new wchar_t[MAX_PATH + 1];
	auto driveSize = GetLogicalDriveStringsW(MAX_PATH, driveLetters);

	if (driveSize > MAX_PATH)
	{
		delete[] driveLetters;
		driveLetters = new wchar_t[size_t(driveSize + 1)];
		driveSize = GetLogicalDriveStringsW(driveSize, driveLetters);
	}

	for (int i = 0; i != driveSize / 4; ++i)
	{
		driveLetters[i * 4 + 2] = 0;
		wchar_t buffer[64]{ 0 };

		QueryDosDeviceW(&driveLetters[size_t(i * 4)], buffer, 64 * 2);

		if (!wcscmp(buffer, deviceName))
		{
			filePath -= 3;
			filePath[2] = '\\';
			filePath[1] = ':';
			filePath[0] = driveLetters[i * 4];

			delete[] driveLetters;

			/*
			HMODULE Ret = GetModuleHandleW(FilePath);

			if (nullptr == Ret)
			{
				return FALSE;
			}
			Address = reinterpret_cast<uintptr_t>(Ret);
			*/

			return true;
		}
	}

	delete[] driveLetters;
	return false;
}

bool Memory::SuspendProcess()
{
	typedef LONG (NTAPI *NtSuspendProcess)(IN HANDLE ProcessHandle);
	static auto pfnNtSuspendProcess = reinterpret_cast<NtSuspendProcess>(GetProcAddress(GetModuleHandle("ntdll"), "NtSuspendProcess"));

	return NT_SUCCESS(pfnNtSuspendProcess(ProcessHandle));
}

bool Memory::ResumeProcess()
{
	typedef LONG (NTAPI *NtResumeProcess)(IN HANDLE ProcessHandle);
	static auto pfnNtResumeProcess = reinterpret_cast<NtResumeProcess>(GetProcAddress(GetModuleHandle("ntdll"), "NtResumeProcess"));

	return NT_SUCCESS(pfnNtResumeProcess(ProcessHandle));
}

bool Memory::IsSuspend()
{
	return false;
}

BOOL Memory::SetPrivilegeM(const HANDLE hToken, const LPCTSTR lpszPrivilege, const BOOL bEnablePrivilege)
{
	TOKEN_PRIVILEGES tp;
	LUID luid;

	if (!LookupPrivilegeValue(nullptr, lpszPrivilege, &luid))
	{
		//printf("LookupPrivilegeValue error: %u\n", GetLastError() );
		return FALSE;
	}

	tp.PrivilegeCount = 1;
	tp.Privileges[0].Luid = luid;
	if (bEnablePrivilege)
		tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
	else
		tp.Privileges[0].Attributes = 0;

	if (!AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), static_cast<PTOKEN_PRIVILEGES>(nullptr),
	                           static_cast<PDWORD>(nullptr)))
	{
		//printf("AdjustTokenPrivileges error: %u\n", GetLastError() );
		return FALSE;
	}

	if (GetLastError() == ERROR_NOT_ALL_ASSIGNED)
	{
		//printf("The token does not have the specified privilege. \n");
		return FALSE;
	}

	return TRUE;
}

BOOL Memory::GetDebugPrivileges()
{
	HANDLE hToken = nullptr;
	if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hToken))
		return FALSE;

	return SetPrivilegeM(hToken, SE_DEBUG_NAME, TRUE);
}

size_t Memory::ReadBytes(const uintptr_t address, const LPVOID buf, const size_t len)
{
	if (address == static_cast<uintptr_t>(-1))
		return 0;

	SIZE_T numberOfBytesActuallyRead = 0;
	const SIZE_T numberOfBytesToRead = len;

	if (useKernal)
	{
		const auto state = bypaPh->RWVM(bypaPh->m_hTarget,
		                                reinterpret_cast<LPVOID>(address),
		                                buf,
		                                numberOfBytesToRead,
		                                &numberOfBytesActuallyRead);
		/*if (state != STATUS_PARTIAL_COPY && state != STATUS_SUCCESS)
			std::cout << "Memory Error! " << GetLastError() << std::endl;*/
	}
	else
	{
		const auto success = ReadProcessMemory(ProcessHandle, reinterpret_cast<LPCVOID>(address), buf,
		                                       numberOfBytesToRead, &numberOfBytesActuallyRead);
		/*if (!success && GetLastError() != 299)
			std::cout << "Memory Error! " << GetLastError() << std::endl;*/
	}

	return numberOfBytesActuallyRead;
}

size_t Memory::ReadBytes(const uintptr_t baseAddress, JsonVar& jsonVar, const LPVOID buf)
{
	if (baseAddress == static_cast<uintptr_t>(-1))
		return 0;

	SIZE_T numberOfBytesActuallyRead = 0;
	const SIZE_T numberOfBytesToRead = jsonVar.Size;

	if (useKernal)
	{
		const bool state = bypaPh->RWVM(bypaPh->m_hTarget,
		                                reinterpret_cast<LPVOID>(baseAddress + jsonVar.Offset),
		                                buf,
		                                numberOfBytesToRead,
		                                &numberOfBytesActuallyRead);

		/*if (state != STATUS_PARTIAL_COPY && state != STATUS_SUCCESS)
			std::cout << "Memory Error! " << GetLastError() << std::endl;*/
	}
	else
	{
		const bool success = ReadProcessMemory(ProcessHandle,
		                                       reinterpret_cast<LPCVOID>(baseAddress + jsonVar.Offset),
		                                       buf,
		                                       numberOfBytesToRead,
		                                       &numberOfBytesActuallyRead);

		/*if (!success && GetLastError() != 299)
			std::cout << "Memory Error! " << GetLastError() << std::endl;*/
	}

	return numberOfBytesActuallyRead;
}

bool Memory::ReadBool(const uintptr_t address)
{
	if (address == static_cast<uintptr_t>(-1))
		return false;

	bool buffer = true;
	const SIZE_T numberOfBytesToRead = sizeof buffer; //this is equal to 1
	SIZE_T numberOfBytesActuallyRead;

	if (useKernal)
	{
		const auto state = bypaPh->RWVM(bypaPh->m_hTarget,
		                                reinterpret_cast<LPVOID>(address),
		                                &buffer,
		                                numberOfBytesToRead,
		                                &numberOfBytesActuallyRead);
		if (state != STATUS_SUCCESS)
			return false;
	}
	else
	{
		const auto state = ReadProcessMemory(ProcessHandle, reinterpret_cast<LPCVOID>(address), &buffer,
		                                     numberOfBytesToRead, &numberOfBytesActuallyRead);
		if (!state)
		{
			return false;
		}
	}

	return buffer;
}

int Memory::ReadInt(const uintptr_t address)
{
	if (address == static_cast<uintptr_t>(-1))
		return -1;

	int buffer = 0;
	const SIZE_T numberOfBytesToRead = sizeof buffer; //this is equal to 4
	SIZE_T numberOfBytesActuallyRead;

	if (useKernal)
	{
		const auto state = bypaPh->RWVM(bypaPh->m_hTarget,
		                                reinterpret_cast<LPVOID>(address),
		                                &buffer,
		                                numberOfBytesToRead,
		                                &numberOfBytesActuallyRead);
		if (state != STATUS_SUCCESS)
			return -1;
	}
	else
	{
		const auto state = ReadProcessMemory(ProcessHandle, reinterpret_cast<LPCVOID>(address), &buffer,
		                                     numberOfBytesToRead, &numberOfBytesActuallyRead);
		if (!state)
		{
			return -1;
		}
	}

	return buffer;
}

INT64 Memory::ReadInt64(const uintptr_t address)
{
	if (address == static_cast<uintptr_t>(-1))
		return -1;
	INT64 buffer = 0;
	const SIZE_T numberOfBytesToRead = sizeof(buffer); //this is equal to 8
	SIZE_T numberOfBytesActuallyRead;
	if (useKernal)
	{
		const auto state = bypaPh->RWVM(bypaPh->m_hTarget,
		                                reinterpret_cast<LPVOID>(address),
		                                &buffer,
		                                numberOfBytesToRead,
		                                &numberOfBytesActuallyRead);
		if (state != STATUS_SUCCESS)
			return -1;
	}
	else
	{
		const auto state = ReadProcessMemory(ProcessHandle, reinterpret_cast<LPCVOID>(address), &buffer,
		                                     numberOfBytesToRead, &numberOfBytesActuallyRead);
		if (!state)
		{
			return -1;
		}
	}
	return buffer;
}

UINT32 Memory::ReadUInt(const uintptr_t address)
{
	if (address == static_cast<uintptr_t>(-1))
		return -1;

	UINT32 buffer = 0;
	const SIZE_T numberOfBytesToRead = sizeof buffer; //this is equal to 4
	SIZE_T numberOfBytesActuallyRead;
	if (useKernal)
	{
		const auto state = bypaPh->RWVM(bypaPh->m_hTarget,
		                                reinterpret_cast<LPVOID>(address),
		                                &buffer,
		                                numberOfBytesToRead,
		                                &numberOfBytesActuallyRead);
		if (state != STATUS_SUCCESS)
			return -1;
	}
	else
	{
		const auto state = ReadProcessMemory(ProcessHandle, reinterpret_cast<LPCVOID>(address), &buffer,
		                                     numberOfBytesToRead, &numberOfBytesActuallyRead);
		if (!state)
		{
			return -1;
		}
	}
	return buffer;
}

UINT64 Memory::ReadUInt64(const uintptr_t address)
{
	if (address == static_cast<uintptr_t>(-1))
		return -1;
	UINT64 buffer = 0;
	const SIZE_T numberOfBytesToRead = sizeof(buffer); //this is equal to 8
	SIZE_T numberOfBytesActuallyRead;
	if (useKernal)
	{
		const auto state = bypaPh->RWVM(bypaPh->m_hTarget,
		                                reinterpret_cast<LPVOID>(address),
		                                &buffer,
		                                numberOfBytesToRead,
		                                &numberOfBytesActuallyRead);
		if (state != STATUS_SUCCESS)
			return -1;
	}
	else
	{
		const auto state = ReadProcessMemory(ProcessHandle, reinterpret_cast<LPCVOID>(address), &buffer,
		                                     numberOfBytesToRead, &numberOfBytesActuallyRead);
		if (!state)
		{
			// std::cout << "Memory Error! " << GetLastError() << std::endl;
			return -1;
		}
	}
	return buffer;
}

float Memory::ReadFloat(const uintptr_t address)
{
	if (address == static_cast<uintptr_t>(-1))
		return -1;

	float buffer = 0.0;
	const SIZE_T numberOfBytesToRead = sizeof(buffer); //this is equal to 4
	SIZE_T numberOfBytesActuallyRead;
	if (useKernal)
	{
		const auto state = bypaPh->RWVM(bypaPh->m_hTarget,
		                                reinterpret_cast<LPVOID>(address),
		                                &buffer,
		                                numberOfBytesToRead,
		                                &numberOfBytesActuallyRead);
		if (state != STATUS_SUCCESS)
			return -1;
	}
	else
	{
		const auto state = ReadProcessMemory(ProcessHandle, reinterpret_cast<LPCVOID>(address), &buffer,
		                                     numberOfBytesToRead, &numberOfBytesActuallyRead);
		if (!state)
		{
			return -1;
		}
	}
	return buffer;
}

int Memory::GetPointerAddress(const uintptr_t address, const int offsets[], const int offsetCount)
{
	if (address == static_cast<uintptr_t>(-1))
		return -1;

	auto ptr = ReadInt(address);
	for (auto i = 0; i < offsetCount - 1; i++)
	{
		ptr += offsets[i];
		ptr = ReadInt(ptr);
	}
	ptr += offsets[offsetCount - 1];
	return ptr;
}

uintptr_t Memory::ReadAddress(const uintptr_t address)
{
	return Is64Bit ? ReadInt64(address) : ReadInt(address);
}

int Memory::ReadPointerInt(const uintptr_t address, int offsets[], const int offsetCount)
{
	if (address == static_cast<uintptr_t>(-1))
		return -1;

	return ReadInt(GetPointerAddress(address, offsets, offsetCount));
}

float Memory::ReadPointerFloat(const uintptr_t address, int offsets[], int offsetCount)
{
	if (address == static_cast<uintptr_t>(-1))
		return -1;
	return ReadFloat(GetPointerAddress(address, offsets, offsetCount));
}

std::string Memory::ReadText(uintptr_t address)
{
	std::string ret;
	if (address == static_cast<uintptr_t>(-1))
		return "";

	char buffer = 0;
	const SIZE_T numberOfBytesToRead = sizeof buffer;
	SIZE_T numberOfBytesActuallyRead;

	while (true)
	{
		if (useKernal)
		{
			const auto state = bypaPh->RWVM(bypaPh->m_hTarget,
			                                reinterpret_cast<LPVOID>(address),
			                                &buffer,
			                                numberOfBytesToRead,
			                                &numberOfBytesActuallyRead);
			if (state != STATUS_SUCCESS)
				return "";
		}
		else
		{
			const auto state = ReadProcessMemory(ProcessHandle, reinterpret_cast<LPCVOID>(address), &buffer,
			                                     numberOfBytesToRead, &numberOfBytesActuallyRead);
			if (!state)
				return "";
		}

		if (buffer == 0)
			break;
		ret.push_back(buffer);
		address++;
	}
	return ret;
}

std::string Memory::ReadPointerText(const uintptr_t address, int offsets[], int offsetCount)
{
	if (address == static_cast<uintptr_t>(-1))
		return "";
	return ReadText(GetPointerAddress(address, offsets, offsetCount));
}

```

`UnrealFinderTool/Memory.h`:

```h
#pragma once
#include <string>
#include <psapi.h>
#pragma comment(lib, "psapi")

class JsonVar;

class Memory
{
	typedef enum _MEMORY_INFORMATION_CLASS
	{
		MemoryBasicInformation,
		MemoryWorkingSetInformation,
		MemoryMappedFilenameInformation,
		MemoryRegionInformation,
		MemoryWorkingSetExInformation,
		MemorySharedCommitInformation,
		MemoryImageInformation,
		MemoryRegionInformationEx,
		MemoryPrivilegedBasicInformation,
		MemoryEnclaveImageInformation,
		MemoryBasicInformationCapped
	} MEMORY_INFORMATION_CLASS;

	typedef NTSTATUS(NTAPI* hsNtQueryVirtualMemory)(
		HANDLE ProcessHandle,
		PVOID BaseAddress, MEMORY_INFORMATION_CLASS MemoryInformationClass,
		PVOID Buffer, SIZE_T Length, PSIZE_T ResultLength
		);

	struct SECTION_INFO
	{
		WORD Len;
		WORD MaxLen;
		wchar_t* szData;
		BYTE pData[MAX_PATH * 2];
	};

	bool useKernal = false;
	static BypaPH* bypaPh;
public:
	HANDLE ProcessHandle = nullptr;
	int ProcessId = 0;
	BOOL Is64Bit = false;

	explicit Memory(HANDLE processHandle, bool useKernal = false);
	explicit Memory(int processId, bool useKernal = false);

	static int GetProcessIdByName(const std::string& processName);
	static std::string GetProcessNameById(DWORD pId);
	static bool IsValidProcess(int p_id, PHANDLE pHandle);
	static bool IsValidProcess(int p_id);
	static bool IsHandleValid(HANDLE processHandle);

	bool IsStaticAddress(uintptr_t address);
	void UpdateHandle(HANDLE processHandle);
	BOOL SetPrivilegeM(HANDLE hToken, LPCTSTR lpszPrivilege, BOOL bEnablePrivilege);
	BOOL GetDebugPrivileges();
	MODULEINFO GetModuleInfo(LPCTSTR lpModuleName);
	bool SuspendProcess();
	bool ResumeProcess();
	bool IsSuspend();

	template<typename T>
	size_t Read(uintptr_t address, T& ret);
	size_t ReadBytes(uintptr_t address, LPVOID buf, size_t len);
	size_t ReadBytes(uintptr_t baseAddress, JsonVar& jsonVar, LPVOID buf);
	bool ReadBool(uintptr_t address);
	int ReadInt(uintptr_t address);
	INT64 ReadInt64(uintptr_t address);
	UINT32 ReadUInt(uintptr_t address);
	UINT64 ReadUInt64(uintptr_t address);
	uintptr_t ReadAddress(uintptr_t address);
	float ReadFloat(uintptr_t address);
	std::string ReadText(uintptr_t address);
	std::string ReadPointerText(const uintptr_t address, int offsets[], int offsetCount);

	int ReadPointerInt(uintptr_t address, int offsets[], int offsetCount);
	float ReadPointerFloat(uintptr_t address, int offsets[], int offsetCount);
	int GetPointerAddress(uintptr_t address, const int offsets[], int offsetCount);
};

template <typename T>
size_t Memory::Read(const uintptr_t address, T& ret)
{
	if (address == static_cast<uintptr_t>(-1))
		return 0;

	SIZE_T numberOfBytesActuallyRead = 0;
	const SIZE_T numberOfBytesToRead = sizeof(T);

	uintptr_t remoteAddress = reinterpret_cast<uintptr_t>(&ret);

	if (useKernal)
		bypaPh->RWVM(bypaPh->m_hTarget, reinterpret_cast<LPVOID>(address), reinterpret_cast<LPVOID>(remoteAddress), numberOfBytesToRead, &numberOfBytesActuallyRead);
	else
		ReadProcessMemory(ProcessHandle, reinterpret_cast<LPVOID>(address), reinterpret_cast<LPVOID>(remoteAddress), numberOfBytesToRead, &numberOfBytesActuallyRead);

	return numberOfBytesActuallyRead;
}

```

`UnrealFinderTool/MemoryEditor.h`:

```h
// Mini memory editor for Dear ImGui (to embed in your game/tools)
// Animated GIF: https://twitter.com/ocornut/status/894242704317530112
// Get latest version at http://www.github.com/ocornut/imgui_club
//
// Right-click anywhere to access the Options menu!
// You can adjust the keyboard repeat delay/rate in ImGuiIO.
// The code assume a mono-space font for simplicity! If you don't use the default font, use ImGui::PushFont()/PopFont() to switch to a mono-space font before caling this.
//
// Usage:
//   static MemoryEditor mem_edit_1;                                            // store your state somewhere
//   mem_edit_1.DrawWindow("Memory Editor", mem_block, mem_block_size, 0x0000); // create a window and draw memory editor (if you already have a window, use DrawContents())
//
// Usage:
//   static MemoryEditor mem_edit_2;
//   ImGui::Begin("MyWindow")
//   mem_edit_2.DrawContents(this, sizeof(*this), (size_t)this);
//   ImGui::End();
//
// Changelog:
// - v0.10: initial version
// - v0.11: always refresh active text input with the latest byte from source memory if it's not being edited.
// - v0.12: added OptMidRowsCount to allow extra spacing every XX rows.
// - v0.13: added optional ReadFn/WriteFn handlers to access memory via a function. various warning fixes for 64-bits.
// - v0.14: added GotoAddr member, added GotoAddrAndHighlight() and highlighting. fixed minor scrollbar glitch when resizing.
// - v0.15: added maximum window width. minor optimization.
// - v0.16: added OptGreyOutZeroes option. various sizing fixes when resizing using the "Rows" drag.
// - v0.17: added HighlightFn handler for optional non-contiguous highlighting.
// - v0.18: fixes for displaying 64-bits addresses, fixed mouse click gaps introduced in recent changes, cursor tracking scrolling fixes.
// - v0.19: fixed auto-focus of next byte leaving WantCaptureKeyboard=false for one frame. we now capture the keyboard during that transition.
// - v0.20: added options menu. added OptShowAscii checkbox. added optional HexII display. split Draw() in DrawWindow()/DrawContents(). fixing glyph width. refactoring/cleaning code.
// - v0.21: fixes for using DrawContents() in our own window. fixed HexII to actually be useful and not on the wrong side.
// - v0.22: clicking Ascii view select the byte in the Hex view. Ascii view highlight selection.
// - v0.23: fixed right-arrow triggering a byte write.
// - v0.24: changed DragInt("Rows" to use a %d data format (which is desirable since imgui 1.61).
// - v0.25: fixed wording: all occurrences of "Rows" renamed to "Columns".
// - v0.26: fixed clicking on hex region
// - v0.30: added data preview for common data types
// - v0.31: added OptUpperCaseHex option to select lower/upper casing display [@samhocevar]
// - v0.32: changed signatures to use void* instead of unsigned char*
// - v0.33: added OptShowOptions option to hide all the interactive option setting.
// - v0.34: binary preview now applies endianess setting [@nicolasnoble]
//
// Todo/Bugs:
// - Arrows are being sent to the InputText() about to disappear which for LeftArrow makes the text cursor appear at position 1 for one frame.
// - Using InputText() is awkward and maybe overkill here, consider implementing something custom.

#pragma once
#pragma warning(disable: 4996)
#include <cstdio>      // sprintf, scanf
#include <cstdint>     // uint8_t, etc.

#ifdef _MSC_VER
#define _PRISizeT   "I"
#define ImSnprintf  _snprintf
#else
#define _PRISizeT   "z"
#define ImSnprintf  snprintf
#endif

struct MemoryEditor
{
	typedef unsigned char u8;

	enum DataType
	{
		DataType_S8,
		DataType_U8,
		DataType_S16,
		DataType_U16,
		DataType_S32,
		DataType_U32,
		DataType_S64,
		DataType_U64,
		DataType_Float,
		DataType_Double,
		DataType_COUNT
	};

	enum DataFormat
	{
		DataFormat_Bin = 0,
		DataFormat_Dec = 1,
		DataFormat_Hex = 2,
		DataFormat_COUNT
	};

	// Settings
	bool            Open;										// = true   // set to false when DrawWindow() was closed. ignore if not using DrawWindow().
	bool            ReadOnly;									// = false  // disable any editing.
	int             Cols;										// = 16     // number of columns to display.
	bool            OptShowOptions;								// = true   // display options button/context menu. when disabled, options will be locked unless you provide your own UI for them.
	bool            OptShowDataPreview;							// = false  // display a footer previewing the decimal/binary/hex/float representation of the currently selected bytes.
	bool            OptShowDataPreviewAs;						// = true   // 
	bool            OptShowDataPreviewDec;						// = true   // 
	bool            OptShowDataPreviewHex;						// = true   // 
	bool            OptShowDataPreviewBin;						// = true   // 
	bool            OptShowHexIi;								// = false  // display values in HexII representation instead of regular hexadecimal: hide null/zero bytes, ascii values as ".X".
	bool            OptShowAscii;								// = true   // display ASCII representation on the right side.
	bool            OptGreyOutZeroes;							// = true   // display null/zero bytes using the TextDisabled color.
	bool            OptUpperCaseHex;							// = true   // display hexadecimal values as "FF" instead of "ff".
	int             OptMidColsCount;							// = 8      // set to 0 to disable extra spacing between every mid-cols.
	int             OptAddrDigitsCount;							// = 0      // number of addr digits to display (default calculated based on maximum displayed addr).
	ImU32           HighlightColor;								//          // background color of highlighted bytes.
	u8				(*ReadFn)(const u8* data, size_t off);		// = NULL   // optional handler to read bytes.
	void            (*WriteFn)(u8* data, size_t off, u8 d);		// = NULL   // optional handler to write bytes.
	bool            (*HighlightFn)(const u8* data, size_t off);	// = NULL	// optional handler to return Highlight property (to support non-contiguous highlighting).

	// [Internal State]
	bool            ContentsWidthChanged;
	size_t          DataPreviewAddr;
	size_t          DataEditingAddr;
	bool            DataEditingTakeFocus;
	char            DataInputBuf[32];
	char            AddrInputBuf[32];
	size_t          GotoAddr;
	size_t          HighlightMin, HighlightMax;
	int             PreviewEndianess;
	DataType        PreviewDataType;

	MemoryEditor()
	{
		// Settings
		Open = true;
		ReadOnly = false;
		Cols = 16;
		OptShowOptions = true;
		OptShowDataPreview = false;
		OptShowDataPreviewAs = true;
		OptShowDataPreviewDec = true;
		OptShowDataPreviewHex = true;
		OptShowDataPreviewBin = true;
		OptShowHexIi = false;
		OptShowAscii = true;
		OptGreyOutZeroes = true;
		OptUpperCaseHex = true;
		OptMidColsCount = 8;
		OptAddrDigitsCount = 0;
		HighlightColor = IM_COL32(255, 255, 255, 50);
		ReadFn = nullptr;
		WriteFn = nullptr;
		HighlightFn = nullptr;

		// State/Internals
		ContentsWidthChanged = false;
		DataPreviewAddr = DataEditingAddr = (size_t)-1;
		DataEditingTakeFocus = false;
		memset(DataInputBuf, 0, sizeof(DataInputBuf));
		memset(AddrInputBuf, 0, sizeof(AddrInputBuf));
		GotoAddr = (size_t)-1;
		HighlightMin = HighlightMax = (size_t)-1;
		PreviewEndianess = 0;
		PreviewDataType = DataType_S32;
	}

	void GotoAddrAndHighlight(size_t addr_min, size_t addr_max)
	{
		GotoAddr = addr_min;
		HighlightMin = addr_min;
		HighlightMax = addr_max;
	}

	struct Sizes
	{
		int     AddrDigitsCount;
		float   LineHeight;
		float   GlyphWidth;
		float   HexCellWidth;
		float   SpacingBetweenMidCols;
		float   PosHexStart;
		float   PosHexEnd;
		float   PosAsciiStart;
		float   PosAsciiEnd;
		float   WindowWidth;
	};

	void CalcSizes(Sizes& s, size_t mem_size, size_t base_display_addr)
	{
		ImGuiStyle& style = ImGui::GetStyle();
		s.AddrDigitsCount = OptAddrDigitsCount;
		if (s.AddrDigitsCount == 0)
			for (size_t n = base_display_addr + mem_size - 1; n > 0; n >>= 4)
				s.AddrDigitsCount++;
		s.LineHeight = ImGui::GetTextLineHeight();
		s.GlyphWidth = ImGui::CalcTextSize("F").x + 1;                  // We assume the font is mono-space
		s.HexCellWidth = (float)(int)(s.GlyphWidth * 2.5f);             // "FF " we include trailing space in the width to easily catch clicks everywhere
		s.SpacingBetweenMidCols = (float)(int)(s.HexCellWidth * 0.25f); // Every OptMidColsCount columns we add a bit of extra spacing
		s.PosHexStart = (s.AddrDigitsCount + 2) * s.GlyphWidth;
		s.PosHexEnd = s.PosHexStart + (s.HexCellWidth * Cols);
		s.PosAsciiStart = s.PosAsciiEnd = s.PosHexEnd;
		if (OptShowAscii)
		{
			s.PosAsciiStart = s.PosHexEnd + s.GlyphWidth * 1;
			if (OptMidColsCount > 0)
				s.PosAsciiStart += (float)((Cols + OptMidColsCount - 1) / OptMidColsCount) * s.SpacingBetweenMidCols;
			s.PosAsciiEnd = s.PosAsciiStart + Cols * s.GlyphWidth;
		}
		s.WindowWidth = s.PosAsciiEnd + style.ScrollbarSize + style.WindowPadding.x * 2 + s.GlyphWidth;
	}

	// Standalone Memory Editor window
	void DrawWindow(const char* title, void* mem_data, size_t mem_size, size_t base_display_addr = 0x0000)
	{
		Sizes s;
		CalcSizes(s, mem_size, base_display_addr);
		ImGui::SetNextWindowSizeConstraints(ImVec2(0.0f, 0.0f), ImVec2(s.WindowWidth, FLT_MAX));

		Open = true;
		if (ImGui::Begin(title, &Open, ImGuiWindowFlags_NoScrollbar))
		{
			if (ImGui::IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows) && ImGui::IsMouseClicked(1))
				ImGui::OpenPopup("context");
			DrawContents(mem_data, mem_size, base_display_addr);
			if (ContentsWidthChanged)
			{
				CalcSizes(s, mem_size, base_display_addr);
				ImGui::SetWindowSize(ImVec2(s.WindowWidth, ImGui::GetWindowSize().y));
			}
		}
		ImGui::End();
	}

	// Memory Editor contents only
	void DrawContents(void* mem_data_void_ptr, size_t mem_size, size_t base_display_addr = 0x0000)
	{
		u8* mem_data = (u8*)mem_data_void_ptr;
		Sizes s;
		CalcSizes(s, mem_size, base_display_addr);
		ImGuiStyle& style = ImGui::GetStyle();

		// We begin into our scrolling region with the 'ImGuiWindowFlags_NoMove' in order to prevent click from moving the window.
		// This is used as a facility since our main click detection code doesn't assign an ActiveId so the click would normally be caught as a window-move.
		const float height_separator = style.ItemSpacing.y;
		float footer_height = 0;
		if (OptShowOptions)
			footer_height += height_separator + ImGui::GetFrameHeightWithSpacing() * 1;

		if (OptShowDataPreview)
		{
			float items_count = 0;
			if (OptShowDataPreviewBin) ++items_count;
			if (OptShowDataPreviewHex) ++items_count;
			if (OptShowDataPreviewDec) ++items_count;
			footer_height += height_separator + ImGui::GetFrameHeightWithSpacing() * 1 + ImGui::GetTextLineHeightWithSpacing() * items_count;
		}

		if (!OptShowDataPreviewAs)
			footer_height -= ImGui::GetItemsLineHeightWithSpacing();

		ImGui::BeginChild("##scrolling", ImVec2(0, -footer_height), false, ImGuiWindowFlags_NoMove);
		ImDrawList* draw_list = ImGui::GetWindowDrawList();

		ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0, 0));
		ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0, 0));

		const int line_total_count = (int)((mem_size + Cols - 1) / Cols);
		ImGuiListClipper clipper(line_total_count, s.LineHeight);
		const size_t visible_start_addr = clipper.DisplayStart * Cols;
		const size_t visible_end_addr = clipper.DisplayEnd * Cols;

		bool data_next = false;

		if (ReadOnly || DataEditingAddr >= mem_size)
			DataEditingAddr = (size_t)-1;
		if (DataPreviewAddr >= mem_size)
			DataPreviewAddr = (size_t)-1;

		size_t preview_data_type_size = OptShowDataPreview ? DataTypeGetSize(PreviewDataType) : 0;

		size_t data_editing_addr_backup = DataEditingAddr;
		size_t data_editing_addr_next = (size_t)-1;
		if (DataEditingAddr != (size_t)-1)
		{
			// Move cursor but only apply on next frame so scrolling with be synchronized (because currently we can't change the scrolling while the window is being rendered)
			if (ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_UpArrow)) && DataEditingAddr >= (size_t)Cols) { data_editing_addr_next = DataEditingAddr - Cols; DataEditingTakeFocus = true; }
			else if (ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_DownArrow)) && DataEditingAddr < mem_size - Cols) { data_editing_addr_next = DataEditingAddr + Cols; DataEditingTakeFocus = true; }
			else if (ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_LeftArrow)) && DataEditingAddr > 0) { data_editing_addr_next = DataEditingAddr - 1; DataEditingTakeFocus = true; }
			else if (ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_RightArrow)) && DataEditingAddr < mem_size - 1) { data_editing_addr_next = DataEditingAddr + 1; DataEditingTakeFocus = true; }
		}
		if (data_editing_addr_next != (size_t)-1 && (data_editing_addr_next / Cols) != (data_editing_addr_backup / Cols))
		{
			// Track cursor movements
			const int scroll_offset = ((int)(data_editing_addr_next / Cols) - (int)(data_editing_addr_backup / Cols));
			const bool scroll_desired = (scroll_offset < 0 && data_editing_addr_next < visible_start_addr + Cols * 2) || (scroll_offset > 0 && data_editing_addr_next > visible_end_addr - Cols * 2);
			if (scroll_desired)
				ImGui::SetScrollY(ImGui::GetScrollY() + scroll_offset * s.LineHeight);
		}

		// Draw vertical separator
		ImVec2 window_pos = ImGui::GetWindowPos();
		if (OptShowAscii)
			draw_list->AddLine(ImVec2(window_pos.x + s.PosAsciiStart - s.GlyphWidth, window_pos.y), ImVec2(window_pos.x + s.PosAsciiStart - s.GlyphWidth, window_pos.y + 9999), ImGui::GetColorU32(ImGuiCol_Border));

		const ImU32 color_text = ImGui::GetColorU32(ImGuiCol_Text);
		const ImU32 color_disabled = OptGreyOutZeroes ? ImGui::GetColorU32(ImGuiCol_TextDisabled) : color_text;

		const char* format_address = OptUpperCaseHex ? "%0*" _PRISizeT "X: " : "%0*" _PRISizeT "x: ";
		const char* format_data = OptUpperCaseHex ? "%0*" _PRISizeT "X" : "%0*" _PRISizeT "x";
		const char* format_range = OptUpperCaseHex ? "Range %0*" _PRISizeT "X..%0*" _PRISizeT "X" : "Range %0*" _PRISizeT "x..%0*" _PRISizeT "x";
		const char* format_byte = OptUpperCaseHex ? "%02X" : "%02x";
		const char* format_byte_space = OptUpperCaseHex ? "%02X " : "%02x ";

		for (int line_i = clipper.DisplayStart; line_i < clipper.DisplayEnd; line_i++) // display only visible lines
		{
			size_t addr = (size_t)(line_i * Cols);
			ImGui::Text(format_address, s.AddrDigitsCount, base_display_addr + addr);

			// Draw Hexadecimal
			for (int n = 0; n < Cols && addr < mem_size; n++, addr++)
			{
				float byte_pos_x = s.PosHexStart + s.HexCellWidth * n;
				if (OptMidColsCount > 0)
					byte_pos_x += (float)(n / OptMidColsCount) * s.SpacingBetweenMidCols;
				ImGui::SameLine(byte_pos_x);

				// Draw highlight
				bool is_highlight_from_user_range = (addr >= HighlightMin && addr < HighlightMax);
				bool is_highlight_from_user_func = (HighlightFn && HighlightFn(mem_data, addr));
				bool is_highlight_from_preview = (addr >= DataPreviewAddr && addr < DataPreviewAddr + preview_data_type_size);
				if (is_highlight_from_user_range || is_highlight_from_user_func || is_highlight_from_preview)
				{
					ImVec2 pos = ImGui::GetCursorScreenPos();
					float highlight_width = s.GlyphWidth * 2;
					bool is_next_byte_highlighted = (addr + 1 < mem_size) && ((HighlightMax != (size_t)-1 && addr + 1 < HighlightMax) || (HighlightFn && HighlightFn(mem_data, addr + 1)));
					if (is_next_byte_highlighted || (n + 1 == Cols))
					{
						highlight_width = s.HexCellWidth;
						if (OptMidColsCount > 0 && n > 0 && (n + 1) < Cols && ((n + 1) % OptMidColsCount) == 0)
							highlight_width += s.SpacingBetweenMidCols;
					}
					draw_list->AddRectFilled(pos, ImVec2(pos.x + highlight_width, pos.y + s.LineHeight), HighlightColor);
				}

				if (DataEditingAddr == addr)
				{
					// Display text input on current byte
					bool data_write = false;
					ImGui::PushID((void*)addr);
					if (DataEditingTakeFocus)
					{
						ImGui::SetKeyboardFocusHere();
						ImGui::CaptureKeyboardFromApp(true);
						sprintf(AddrInputBuf, format_data, s.AddrDigitsCount, base_display_addr + addr);
						sprintf(DataInputBuf, format_byte, ReadFn ? ReadFn(mem_data, addr) : mem_data[addr]);
					}
					ImGui::PushItemWidth(s.GlyphWidth * 2);
					struct UserData
					{
						// FIXME: We should have a way to retrieve the text edit cursor position more easily in the API, this is rather tedious. This is such a ugly mess we may be better off not using InputText() at all here.
						static int Callback(ImGuiInputTextCallbackData* data)
						{
							UserData* user_data = (UserData*)data->UserData;
							if (!data->HasSelection())
								user_data->CursorPos = data->CursorPos;
							if (data->SelectionStart == 0 && data->SelectionEnd == data->BufTextLen)
							{
								// When not editing a byte, always rewrite its content (this is a bit tricky, since InputText technically "owns" the master copy of the buffer we edit it in there)
								data->DeleteChars(0, data->BufTextLen);
								data->InsertChars(0, user_data->CurrentBufOverwrite);
								data->SelectionStart = 0;
								data->SelectionEnd = data->CursorPos = 2;
							}
							return 0;
						}
						char   CurrentBufOverwrite[3];  // Input
						int    CursorPos;               // Output
					};
					UserData user_data;
					user_data.CursorPos = -1;
					sprintf(user_data.CurrentBufOverwrite, format_byte, ReadFn ? ReadFn(mem_data, addr) : mem_data[addr]);
					ImGuiInputTextFlags flags = ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_EnterReturnsTrue | ImGuiInputTextFlags_AutoSelectAll | ImGuiInputTextFlags_NoHorizontalScroll | ImGuiInputTextFlags_AlwaysInsertMode | ImGuiInputTextFlags_CallbackAlways;
					if (ImGui::InputText("##data", DataInputBuf, 32, flags, UserData::Callback, &user_data))
						data_write = data_next = true;
					else if (!DataEditingTakeFocus && !ImGui::IsItemActive())
						DataEditingAddr = data_editing_addr_next = (size_t)-1;
					DataEditingTakeFocus = false;
					ImGui::PopItemWidth();
					if (user_data.CursorPos >= 2)
						data_write = data_next = true;
					if (data_editing_addr_next != (size_t)-1)
						data_write = data_next = false;
					unsigned int data_input_value = 0;
					if (data_write && sscanf(DataInputBuf, "%X", &data_input_value) == 1)
					{
						if (WriteFn)
							WriteFn(mem_data, addr, (u8)data_input_value);
						else
							mem_data[addr] = (u8)data_input_value;
					}
					ImGui::PopID();
				}
				else
				{
					// NB: The trailing space is not visible but ensure there's no gap that the mouse cannot click on.
					u8 b = ReadFn ? ReadFn(mem_data, addr) : mem_data[addr];

					if (OptShowHexIi)
					{
						if ((b >= 32 && b < 128))
							ImGui::Text(".%c ", b);
						else if (b == 0xFF && OptGreyOutZeroes)
							ImGui::TextDisabled("## ");
						else if (b == 0x00)
							ImGui::Text("   ");
						else
							ImGui::Text(format_byte_space, b);
					}
					else
					{
						if (b == 0 && OptGreyOutZeroes)
							ImGui::TextDisabled("00 ");
						else
							ImGui::Text(format_byte_space, b);
					}
					if (ImGui::IsItemHovered() && ImGui::IsMouseClicked(0))
					{
						DataEditingTakeFocus = true;
						data_editing_addr_next = addr;
					}
				}
			}

			if (OptShowAscii)
			{
				// Draw ASCII values
				ImGui::SameLine(s.PosAsciiStart);
				ImVec2 pos = ImGui::GetCursorScreenPos();
				addr = line_i * Cols;
				ImGui::PushID(line_i);
				if (ImGui::InvisibleButton("ascii", ImVec2(s.PosAsciiEnd - s.PosAsciiStart, s.LineHeight)))
				{
					DataEditingAddr = DataPreviewAddr = addr + (size_t)((ImGui::GetIO().MousePos.x - pos.x) / s.GlyphWidth);
					DataEditingTakeFocus = true;
				}
				ImGui::PopID();
				for (int n = 0; n < Cols && addr < mem_size; n++, addr++)
				{
					if (addr == DataEditingAddr)
					{
						draw_list->AddRectFilled(pos, ImVec2(pos.x + s.GlyphWidth, pos.y + s.LineHeight), ImGui::GetColorU32(ImGuiCol_FrameBg));
						draw_list->AddRectFilled(pos, ImVec2(pos.x + s.GlyphWidth, pos.y + s.LineHeight), ImGui::GetColorU32(ImGuiCol_TextSelectedBg));
					}
					unsigned char c = ReadFn ? ReadFn(mem_data, addr) : mem_data[addr];
					char display_c = (c < 32 || c >= 128) ? '.' : c;
					draw_list->AddText(pos, (display_c == '.') ? color_disabled : color_text, &display_c, &display_c + 1);
					pos.x += s.GlyphWidth;
				}
			}
		}
		clipper.End();
		ImGui::PopStyleVar(2);
		ImGui::EndChild();

		if (data_next && DataEditingAddr < mem_size)
		{
			DataEditingAddr = DataPreviewAddr = DataEditingAddr + 1;
			DataEditingTakeFocus = true;
		}
		else if (data_editing_addr_next != (size_t)-1)
		{
			DataEditingAddr = DataPreviewAddr = data_editing_addr_next;
		}

		bool next_show_data_preview = OptShowDataPreview;
		if (OptShowOptions)
		{
			ImGui::Separator();

			// Options menu

			if (ImGui::Button("Options"))
				ImGui::OpenPopup("context");
			if (ImGui::BeginPopup("context"))
			{
				ImGui::PushItemWidth(56);
				if (ImGui::DragInt("##cols", &Cols, 0.2f, 4, 32, "%d cols")) { ContentsWidthChanged = true; }
				ImGui::PopItemWidth();
				ImGui::Checkbox("Show Data Preview", &next_show_data_preview);
				ImGui::Checkbox("Show HexII", &OptShowHexIi);
				if (ImGui::Checkbox("Show Ascii", &OptShowAscii)) { ContentsWidthChanged = true; }
				ImGui::Checkbox("Grey out zeroes", &OptGreyOutZeroes);
				ImGui::Checkbox("Uppercase Hex", &OptUpperCaseHex);

				ImGui::EndPopup();
			}

			ImGui::SameLine();
			ImGui::Text(format_range, s.AddrDigitsCount, base_display_addr, s.AddrDigitsCount, base_display_addr + mem_size - 1);
			ImGui::SameLine();
			ImGui::PushItemWidth((s.AddrDigitsCount + 1) * s.GlyphWidth + style.FramePadding.x * 2.0f);
			if (ImGui::InputText("##addr", AddrInputBuf, 32, ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_EnterReturnsTrue))
			{
				size_t goto_addr;
				if (sscanf(AddrInputBuf, "%" _PRISizeT "X", &goto_addr) == 1)
				{
					GotoAddr = goto_addr - base_display_addr;
					HighlightMin = HighlightMax = (size_t)-1;
				}
			}
			ImGui::PopItemWidth();

			if (GotoAddr != (size_t)-1)
			{
				if (GotoAddr < mem_size)
				{
					ImGui::BeginChild("##scrolling");
					ImGui::SetScrollFromPosY(ImGui::GetCursorStartPos().y + (GotoAddr / Cols) * ImGui::GetTextLineHeight());
					ImGui::EndChild();
					DataEditingAddr = DataPreviewAddr = GotoAddr;
					DataEditingTakeFocus = true;
				}
				GotoAddr = (size_t)-1;
			}
		}

		if (OptShowDataPreview)
		{
			ImGui::Separator();
			if (OptShowDataPreviewAs)
			{
				ImGui::AlignTextToFramePadding();
				ImGui::Text("Preview as:");
				ImGui::SameLine();
				ImGui::PushItemWidth((s.GlyphWidth * 10.0f) + style.FramePadding.x * 2.0f + style.ItemInnerSpacing.x);
				if (ImGui::BeginCombo("##combo_type", DataTypeGetDesc(PreviewDataType), ImGuiComboFlags_HeightLargest))
				{
					for (int n = 0; n < DataType_COUNT; n++)
						if (ImGui::Selectable(DataTypeGetDesc((DataType)n), PreviewDataType == n))
							PreviewDataType = (DataType)n;
					ImGui::EndCombo();
				}
				ImGui::PopItemWidth();
				ImGui::SameLine();
				ImGui::PushItemWidth((s.GlyphWidth * 6.0f) + style.FramePadding.x * 2.0f + style.ItemInnerSpacing.x);
				ImGui::Combo("##combo_endianess", &PreviewEndianess, "LE\0BE\0\0");
				ImGui::PopItemWidth();
			}

			char buf[128];
			float x = s.GlyphWidth * 6.0f;
			bool has_value = DataPreviewAddr != (size_t)-1;

			if (OptShowDataPreviewDec)
			{
				if (has_value)
					DisplayPreviewData(DataPreviewAddr, mem_data, mem_size, PreviewDataType, DataFormat_Dec, buf, (size_t)IM_ARRAYSIZE(buf));
				ImGui::Text("Dec"); ImGui::SameLine(x); ImGui::TextUnformatted(has_value ? buf : "N/A");
				ContextMenu(buf);
			}

			if (OptShowDataPreviewHex)
			{
				if (has_value)
					DisplayPreviewData(DataPreviewAddr, mem_data, mem_size, PreviewDataType, DataFormat_Hex, buf, (size_t)IM_ARRAYSIZE(buf));
				ImGui::Text("Hex"); ImGui::SameLine(x); ImGui::TextUnformatted(has_value ? buf : "N/A");
				ContextMenu(buf);
			}

			if (OptShowDataPreviewBin)
			{
				if (has_value)
					DisplayPreviewData(DataPreviewAddr, mem_data, mem_size, PreviewDataType, DataFormat_Bin, buf, (size_t)IM_ARRAYSIZE(buf));
				ImGui::Text("Bin"); ImGui::SameLine(x); ImGui::TextUnformatted(has_value ? buf : "N/A");
				ContextMenu(buf);
			}
		}

		OptShowDataPreview = next_show_data_preview;

		// Notify the main window of our ideal child content size (FIXME: we are missing an API to get the contents size from the child)
		ImGui::SetCursorPosX(s.WindowWidth);
	}

	void ContextMenu(const std::string& parentStr)
	{
		if (ImGui::BeginPopupContextItem("item context menu"))
		{
			if (ImGui::Selectable(ICON_FA_COPY " Copy"))
				ImGui::SetClipboardText(parentStr.c_str());
			ImGui::EndPopup();
		}
	}

	// Utilities for Data Preview
	const char* DataTypeGetDesc(DataType data_type) const
	{
		const char* descs[] = { "Int8", "Uint8", "Int16", "Uint16", "Int32", "Uint32", "Int64", "Uint64", "Float", "Double" };
		IM_ASSERT(data_type >= 0 && data_type < DataType_COUNT);
		return descs[data_type];
	}

	size_t DataTypeGetSize(DataType data_type) const
	{
		const size_t sizes[] = { 1, 1, 2, 2, 4, 4, 8, 8, 4, 8 };
		IM_ASSERT(data_type >= 0 && data_type < DataType_COUNT);
		return sizes[data_type];
	}

	const char* DataFormatGetDesc(DataFormat data_format) const
	{
		const char* descs[] = { "Bin", "Dec", "Hex" };
		IM_ASSERT(data_format >= 0 && data_format < DataFormat_COUNT);
		return descs[data_format];
	}

	bool IsBigEndian() const
	{
		uint16_t x = 1;
		char c[2];
		memcpy(c, &x, 2);
		return c[0] != 0;
	}

	static void* EndianessCopyBigEndian(void* _dst, void* _src, size_t s, int is_little_endian)
	{
		if (is_little_endian)
		{
			uint8_t* dst = (uint8_t*)_dst;
			uint8_t* src = (uint8_t*)_src + s - 1;
			for (int i = 0, n = (int)s; i < n; ++i)
				memcpy(dst++, src--, 1);
			return _dst;
		}
		else
		{
			return memcpy(_dst, _src, s);
		}
	}

	static void* EndianessCopyLittleEndian(void* _dst, void* _src, size_t s, int is_little_endian)
	{
		if (is_little_endian)
		{
			return memcpy(_dst, _src, s);
		}
		else
		{
			uint8_t* dst = (uint8_t*)_dst;
			uint8_t* src = (uint8_t*)_src + s - 1;
			for (int i = 0, n = (int)s; i < n; ++i)
				memcpy(dst++, src--, 1);
			return _dst;
		}
	}

	void* EndianessCopy(void* dst, void* src, size_t size) const
	{
		static void* (*fp)(void*, void*, size_t, int) = NULL;
		if (fp == NULL)
			fp = IsBigEndian() ? EndianessCopyBigEndian : EndianessCopyLittleEndian;
		return fp(dst, src, size, PreviewEndianess);
	}

	const char* FormatBinary(const uint8_t* buf, int width) const
	{
		IM_ASSERT(width <= 64);
		size_t out_n = 0;
		static char out_buf[64 + 8 + 1];
		int n = width / 8;
		for (int j = n - 1; j >= 0; --j)
		{
			for (int i = 0; i < 8; ++i)
				out_buf[out_n++] = (buf[j] & (1 << (7 - i))) ? '1' : '0';
			out_buf[out_n++] = ' ';
		}
		IM_ASSERT(out_n < IM_ARRAYSIZE(out_buf));
		out_buf[out_n] = 0;
		return out_buf;
	}

	void DisplayPreviewData(size_t addr, const u8* mem_data, size_t mem_size, DataType data_type, DataFormat data_format, char* out_buf, size_t out_buf_size) const
	{
		uint8_t buf[8];
		size_t elem_size = DataTypeGetSize(data_type);
		size_t size = addr + elem_size > mem_size ? mem_size - addr : elem_size;
		if (ReadFn)
			for (int i = 0, n = (int)size; i < n; ++i)
				buf[i] = ReadFn(mem_data, addr + i);
		else
			memcpy(buf, mem_data + addr, size);

		if (data_format == DataFormat_Bin)
		{
			uint8_t binbuf[8];
			EndianessCopy(binbuf, buf, size);
			ImSnprintf(out_buf, out_buf_size, "%s", FormatBinary(binbuf, (int)size * 8));
			return;
		}

		out_buf[0] = 0;
		switch (data_type)
		{
		case DataType_S8:
		{
			int8_t int8 = 0;
			EndianessCopy(&int8, buf, size);
			if (data_format == DataFormat_Dec) { ImSnprintf(out_buf, out_buf_size, "%hhd", int8); return; }
			if (data_format == DataFormat_Hex) { ImSnprintf(out_buf, out_buf_size, "%02x", int8 & 0xFF); return; }
			break;
		}
		case DataType_U8:
		{
			uint8_t uint8 = 0;
			EndianessCopy(&uint8, buf, size);
			if (data_format == DataFormat_Dec) { ImSnprintf(out_buf, out_buf_size, "%hhu", uint8); return; }
			if (data_format == DataFormat_Hex) { ImSnprintf(out_buf, out_buf_size, "%02x", uint8 & 0XFF); return; }
			break;
		}
		case DataType_S16:
		{
			int16_t int16 = 0;
			EndianessCopy(&int16, buf, size);
			if (data_format == DataFormat_Dec) { ImSnprintf(out_buf, out_buf_size, "%hd", int16); return; }
			if (data_format == DataFormat_Hex) { ImSnprintf(out_buf, out_buf_size, "%04x", int16 & 0xFFFF); return; }
			break;
		}
		case DataType_U16:
		{
			uint16_t uint16 = 0;
			EndianessCopy(&uint16, buf, size);
			if (data_format == DataFormat_Dec) { ImSnprintf(out_buf, out_buf_size, "%hu", uint16); return; }
			if (data_format == DataFormat_Hex) { ImSnprintf(out_buf, out_buf_size, "%04x", uint16 & 0xFFFF); return; }
			break;
		}
		case DataType_S32:
		{
			int32_t int32 = 0;
			EndianessCopy(&int32, buf, size);
			if (data_format == DataFormat_Dec) { ImSnprintf(out_buf, out_buf_size, "%d", int32); return; }
			if (data_format == DataFormat_Hex) { ImSnprintf(out_buf, out_buf_size, "%08x", int32); return; }
			break;
		}
		case DataType_U32:
		{
			uint32_t uint32 = 0;
			EndianessCopy(&uint32, buf, size);
			if (data_format == DataFormat_Dec) { ImSnprintf(out_buf, out_buf_size, "%u", uint32); return; }
			if (data_format == DataFormat_Hex) { ImSnprintf(out_buf, out_buf_size, "%08x", uint32); return; }
			break;
		}
		case DataType_S64:
		{
			int64_t int64 = 0;
			EndianessCopy(&int64, buf, size);
			if (data_format == DataFormat_Dec) { ImSnprintf(out_buf, out_buf_size, "%lld", (long long)int64); return; }
			if (data_format == DataFormat_Hex) { ImSnprintf(out_buf, out_buf_size, "%16llx", (long long)int64); return; }
			break;
		}
		case DataType_U64:
		{
			uint64_t uint64 = 0;
			EndianessCopy(&uint64, buf, size);
			if (data_format == DataFormat_Dec) { ImSnprintf(out_buf, out_buf_size, "%llu", (long long)uint64); return; }
			if (data_format == DataFormat_Hex) { ImSnprintf(out_buf, out_buf_size, "%16llx", (long long)uint64); return; }
			break;
		}
		case DataType_Float:
		{
			float float32 = 0.0f;
			EndianessCopy(&float32, buf, size);
			if (data_format == DataFormat_Dec) { ImSnprintf(out_buf, out_buf_size, "%f", float32); return; }
			if (data_format == DataFormat_Hex) { ImSnprintf(out_buf, out_buf_size, "%a", float32); return; }
			break;
		}
		case DataType_Double:
		{
			double float64 = 0.0;
			EndianessCopy(&float64, buf, size);
			if (data_format == DataFormat_Dec) { ImSnprintf(out_buf, out_buf_size, "%f", float64); return; }
			if (data_format == DataFormat_Hex) { ImSnprintf(out_buf, out_buf_size, "%a", float64); return; }
			break;
		}
		case DataType_COUNT:
			break;
		} // Switch
		IM_ASSERT(0); // Shouldn't reach
	}
};

#undef _PRISizeT
#undef ImSnprintf
```

`UnrealFinderTool/Midi/MIDI.cpp`:

```cpp
#include "pch.h"
#include "MIDI.h"

#pragma comment(lib, "winmm")

#define M_THD		0x6468544D		// Start of file
#define M_TRK		0x6B72544D		// Start of track

#define BUFFER_TIME_LENGTH		60   // Amount to fill in milliseconds

// These structures are stored in MIDI files; they need to be byte aligned.
//
#pragma pack(1)

// Contents of MThd chunk.
struct MidiFileHdr
{
	WORD wFormat; // Format (hi-lo)
	WORD wTrackCount; // # tracks (hi-lo)
	WORD wTimeDivision; // Time division (hi-lo)
};

#pragma pack() // End of need for byte-aligned structures


// Macros for swapping hi/lo-endian data
//
#define WORDSWAP(w)		(((w) >> 8) | \
						(((w) << 8) & 0xFF00))

#define DWORDSWAP(dw)	(((dw) >> 24) | \
						(((dw) >> 8) & 0x0000FF00) | \
						(((dw) << 8) & 0x00FF0000) | \
						(((dw) << 24) & 0xFF000000))


static char GteBadRunStat[] = "Reference to missing running status.";
//static char GteRunStatMsgTrunc[] = "Running status message truncated";
//static char GteChanMsgTrunc[] = "Channel message truncated";
static char GteSysExLenTrunc[] = "SysEx event truncated (length)";
static char GteSysExTrunc[] = "SysEx event truncated";
//static char GteMetaNoClass[] = "Meta event truncated (no class byte)";
static char GteMetaLenTrunc[] = "Meta event truncated (length)";
static char GteMetaTrunc[] = "Meta event truncated";
static char GteNoMem[] = "Out of memory during malloc call";


//////////////////////////////////////////////////////////////////////
// CMIDI -- Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMIDI::CMIDI()
	: mDwSoundSize(0)
	  , mPSoundData(nullptr)
	  , mDwFormat(0)
	  , mDwTrackCount(0)
	  , mDwTimeDivision(0)
	  , mBPlaying(FALSE)
	  , mHStream(nullptr)
	  , mDwProgressBytes(0)
	  , mBLooped(FALSE)
	  , mTkCurrentTime(0)
	  , mDwBufferTickLength(0)
	  , mDwCurrentTempo(0)
	  , mDwTempoMultiplier(100)
	  , mBInsertTempo(FALSE)
	  , mBBuffersPrepared(FALSE)
	  , mNCurrentBuffer(0)
	  , mUMidiDeviceId(MIDI_MAPPER)
	  , mNEmptyBuffers(0)
	  , mBPaused(FALSE)
	  , mUCallbackStatus(0)
	  , mHBufferReturnEvent(nullptr)

	  , mPWndParent(nullptr)
	  , mPtsTrack(nullptr)
	  , mPtsFound(nullptr)
	  , mDwStatus(0)
	  , mTkNext(0)
	  , mDwMallocBlocks(0), mTeTemp()
{
	mHBufferReturnEvent = CreateEvent(nullptr, FALSE, FALSE, TEXT("Wait For Buffer Return"));
	//ASSERT(m_hBufferReturnEvent != 0);
}

CMIDI::~CMIDI()
{
	Stop(FALSE);

	if (mHBufferReturnEvent)
		::CloseHandle(mHBufferReturnEvent);
}


BOOL CMIDI::Create(const UINT uResId, const HWND pWndParent /* = NULL */)
{
	return Create(MAKEINTRESOURCE(uResId), pWndParent);
}


BOOL CMIDI::Create(const LPCTSTR pszResId, const HWND pWndParent /* = NULL */)
{
	//////////////////////////////////////////////////////////////////
	// load resource
	HINSTANCE hApp = GetModuleHandle(nullptr);
	//ASSERT(hApp);

	HRSRC hResInfo = FindResource(hApp, pszResId, TEXT("MIDI"));
	if (hResInfo == nullptr)
		return FALSE;

	HGLOBAL hRes = LoadResource(hApp, hResInfo);
	if (hRes == nullptr)
		return FALSE;

	LPVOID pTheSound = LockResource(hRes);
	if (pTheSound == nullptr)
		return FALSE;

	DWORD dwTheSound = ::SizeofResource(hApp, hResInfo);

	return Create(static_cast<LPBYTE>(pTheSound), dwTheSound, pWndParent);
}


BOOL CMIDI::Create(const LPBYTE pSoundData, const DWORD dwSize, HWND pParent /* = NULL */)
{
	if (mPSoundData)
	{
		// already created
		//ASSERT(FALSE);
		return FALSE;
	}

	//ASSERT(pSoundData != 0);
	//ASSERT(dwSize > 0);

	auto p = LPBYTE(pSoundData);

	// check header of MIDI
	if (*reinterpret_cast<DWORD*>(p) != M_THD)
	{
		//ASSERT(FALSE);
		return FALSE;
	}
	p += sizeof(DWORD);

	// check header size
	DWORD dwHeaderSize = DWORDSWAP(*(DWORD*)p);
	if (dwHeaderSize != sizeof(MidiFileHdr))
	{
		//ASSERT(FALSE);
		return FALSE;
	}
	p += sizeof(DWORD);

	// get header
	MidiFileHdr hdr;
	CopyMemory(&hdr, p, dwHeaderSize);
	mDwFormat = DWORD(WORDSWAP(hdr.wFormat));
	mDwTrackCount = DWORD(WORDSWAP(hdr.wTrackCount));
	mDwTimeDivision = DWORD(WORDSWAP(hdr.wTimeDivision));
	p += dwHeaderSize;

	// create the array of tracks
	mTracks.resize(mDwTrackCount);
	for (DWORD i = 0; i < mDwTrackCount; ++i)
	{
		// check header of track
		if (*reinterpret_cast<DWORD*>(p) != M_TRK)
		{
			//ASSERT(FALSE);
			return FALSE;
		}
		p += sizeof(DWORD);

		mTracks[i].DwTrackLength = DWORDSWAP(*(DWORD*)p);
		p += sizeof(DWORD);

		mTracks[i].PTrackStart = mTracks[i].PTrackCurrent = p;
		p += mTracks[i].DwTrackLength;

		// Handle bozo MIDI files which contain empty track chunks
		if (!mTracks[i].DwTrackLength)
		{
			mTracks[i].FdwTrack |= ITS_F_ENDOFTRK;
			continue;
		}

		// We always preread the time from each track so the mixer code can
		// determine which track has the next event with a minimum of work
		if (!GetTrackVdWord(&mTracks[i], &mTracks[i].TkNextEventDue))
		{
			//TRACE0("Error in MIDI data\n");
			//ASSERT(FALSE);
			return FALSE;
		}
	}


	mPSoundData = pSoundData;
	mDwSoundSize = dwSize;
	mPWndParent = &pParent;

	// allocate volume channels and initialise them
	mVolumes.resize(NUM_CHANNELS, VOLUME_INIT);

	if (! StreamBufferSetup())
	{
		//ASSERT(FALSE);
		return FALSE;
	}

	return TRUE;
}


BOOL CMIDI::Play(BOOL bInfinite /* = FALSE */)
{
	if (IsPaused())
	{
		Continue();
		return TRUE;
	}

	// calling Play() while it is already playing will restart from scratch
	if (IsPlaying())
		Stop();

	// Clear the status of our callback so it will handle
	// MOM_DONE callbacks once more
	mUCallbackStatus = 0;

	if (!mBLooped)
		mBInsertTempo = TRUE;

	MMRESULT mmResult;
	if ((mmResult = midiStreamRestart(mHStream)) != MMSYSERR_NOERROR)
	{
		MidiError(mmResult);
		return FALSE;
	}

	mBPlaying = TRUE;
	mBLooped = bInfinite;

	return mBPlaying;
}


BOOL CMIDI::Stop(BOOL bReOpen /*=TRUE*/)
{
	MMRESULT mmrRetVal;

	if (IsPlaying() || (mUCallbackStatus != STATUS_CALLBACKDEAD))
	{
		mBPlaying = mBPaused = FALSE;
		if (mUCallbackStatus != STATUS_CALLBACKDEAD && mUCallbackStatus != STATUS_WAITINGFOREND)
			mUCallbackStatus = STATUS_KILLCALLBACK;

		if ((mmrRetVal = midiStreamStop(mHStream)) != MMSYSERR_NOERROR)
		{
			MidiError(mmrRetVal);
			return FALSE;
		}
		if ((mmrRetVal = midiOutReset(reinterpret_cast<HMIDIOUT>(mHStream))) != MMSYSERR_NOERROR)
		{
			MidiError(mmrRetVal);
			return FALSE;
		}
		// Wait for the callback thread to release this thread, which it will do by
		// calling SetEvent() once all buffers are returned to it
		if (WaitForSingleObject(mHBufferReturnEvent, DEBUG_CALLBACK_TIMEOUT) == WAIT_TIMEOUT)
		{
			// Note, this is a risky move because the callback may be genuinely busy, but
			// when we're debugging, it's safer and faster than freezing the application,
			// which leaves the MIDI device locked up and forces a system reset...
			//TRACE0("Timed out waiting for MIDI callback\n");
			mUCallbackStatus = STATUS_CALLBACKDEAD;
		}
	}

	if (mUCallbackStatus == STATUS_CALLBACKDEAD)
	{
		mUCallbackStatus = 0;
		FreeBuffers();
		if (mHStream)
		{
			if ((mmrRetVal = midiStreamClose(mHStream)) != MMSYSERR_NOERROR)
			{
				MidiError(mmrRetVal);
			}
			mHStream = nullptr;
		}

		if (bReOpen)
		{
			if (!StreamBufferSetup())
			{
				// Error setting up for MIDI file
				// Notification is already taken care of...
				return FALSE;
			}
			if (! mBLooped)
			{
				Rewind();
				mDwProgressBytes = 0;
				mDwStatus = 0;
			}
		}
	}
	return TRUE;
}


BOOL CMIDI::Pause()
{
	if (! mBPaused && mBPlaying && mPSoundData && mHStream)
	{
		midiStreamPause(mHStream);
		mBPaused = TRUE;
	}
	return FALSE;
}


BOOL CMIDI::Continue()
{
	if (mBPaused && mBPlaying && mPSoundData && mHStream)
	{
		midiStreamRestart(mHStream);
		mBPaused = FALSE;
	}
	return FALSE;
}


BOOL CMIDI::Rewind()
{
	if (! mPSoundData)
		return FALSE;

	for (DWORD i = 0; i < mDwTrackCount; ++i)
	{
		mTracks[i].PTrackCurrent = mTracks[i].PTrackStart;
		mTracks[i].ByRunningStatus = 0;
		mTracks[i].TkNextEventDue = 0;
		mTracks[i].FdwTrack = 0;

		// Handle bozo MIDI files which contain empty track chunks
		if (!mTracks[i].DwTrackLength)
		{
			mTracks[i].FdwTrack |= ITS_F_ENDOFTRK;
			continue;
		}

		// We always preread the time from each track so the mixer code can
		// determine which track has the next event with a minimum of work
		if (!GetTrackVdWord(&mTracks[i], &mTracks[i].TkNextEventDue))
		{
			//TRACE0("Error in MIDI data\n");
			//ASSERT(FALSE);
			return FALSE;
		}
	}

	return TRUE;
}


size_t CMIDI::GetChannelCount() const
{
	return mVolumes.size();
}


void CMIDI::SetVolume(const size_t percent)
{
	const size_t dwSize = mVolumes.size();
	for (size_t i = 0; i < dwSize; ++i)
		SetChannelVolume(i, percent);
}


size_t CMIDI::GetVolume() const
{
	size_t dwVolume = 0;
	const size_t dwSize = mVolumes.size();
	for (size_t i = 0; i < dwSize; ++i)
		dwVolume += GetChannelVolume(i);

	return dwVolume / GetChannelCount();
}


void CMIDI::SetChannelVolume(const size_t dwChannel, const size_t dwPercent)
{
	//ASSERT(dwChannel < m_Volumes.size());

	if (!mBPlaying)
		return;

	mVolumes[dwChannel] = (dwPercent > 100) ? 100 : dwPercent;
	size_t dwEvent = MIDI_CTRLCHANGE | dwChannel | (static_cast<DWORD>(MIDICTRL_VOLUME) << 8) | (static_cast<DWORD>(mVolumes[dwChannel] * VOLUME_MAX / 100) << 16);
	MMRESULT mmrRetVal;
	if ((mmrRetVal = midiOutShortMsg(reinterpret_cast<HMIDIOUT>(mHStream), static_cast<DWORD>(dwEvent))) != MMSYSERR_NOERROR)
	{
		MidiError(mmrRetVal);
		return;
	}
}


size_t CMIDI::GetChannelVolume(size_t dwChannel) const
{
	//ASSERT(dwChannel < GetChannelCount());
	return mVolumes[dwChannel];
}


void CMIDI::SetTempo(DWORD dwPercent)
{
	mDwTempoMultiplier = dwPercent ? dwPercent : 1;
	mBInsertTempo = TRUE;
}


DWORD CMIDI::GetTempo() const
{
	return mDwTempoMultiplier;
}


void CMIDI::SetInfinitePlay(BOOL bSet)
{
	mBLooped = bSet;
}

//////////////////////////////////////////////////////////////////////
// CMIDI -- implementation
//////////////////////////////////////////////////////////////////////

// This function converts MIDI data from the track buffers setup by a
// previous call to ConverterInit().  It will convert data until an error is
// encountered or the output buffer has been filled with as much event data
// as possible, not to exceed dwMaxLength. This function can take a couple
// bit flags, passed through dwFlags. Information about the success/failure
// of this operation and the number of output bytes actually converted will
// be returned in the CONVERTINFO structure pointed at by lpciInfo.
int CMIDI::ConvertToBuffer(const DWORD dwFlags, ConvertInfo* lpciInfo)
{
	int nChkErr;

	lpciInfo->DwBytesRecorded = 0;

	if (dwFlags & CONVERTF_RESET)
	{
		mDwProgressBytes = 0;
		mDwStatus = 0;
		memset(&mTeTemp, 0, sizeof(TempEvent));
		mPtsTrack = mPtsFound = nullptr;
	}

	// If we were already done, then return with a warning...
	if (mDwStatus & CONVERTF_STATUS_DONE)
	{
		if (mBLooped)
		{
			Rewind();
			mDwProgressBytes = 0;
			mDwStatus = 0;
		}
		else
			return CONVERTERR_DONE;
	}
	else if (mDwStatus & CONVERTF_STATUS_STUCK)
	{
		// The caller is asking us to continue, but we're already hosed because we
		// previously identified something as corrupt, so complain louder this time.
		return (CONVERTERR_STUCK);
	}
	else if (mDwStatus & CONVERTF_STATUS_GOTEVENT)
	{
		// Turn off this bit flag
		mDwStatus ^= CONVERTF_STATUS_GOTEVENT;

		// The following code for this case is duplicated from below, and is
		// designed to handle a "straggler" event, should we have one left over
		// from previous processing the last time this function was called.

		// Don't add end of track event 'til we're done
		if (mTeTemp.byShortData[0] == MIDI_META && mTeTemp.byShortData[1] == MIDI_META_EOT)
		{
			if (mDwMallocBlocks)
			{
				delete [] mTeTemp.pLongData;
				--mDwMallocBlocks;
			}
		}
		else if ((nChkErr = AddEventToStreamBuffer(&mTeTemp, lpciInfo)) != CONVERTERR_NOERROR)
		{
			if (nChkErr == CONVERTERR_BUFFERFULL)
			{
				// Do some processing and tell caller that this buffer's full
				mDwStatus |= CONVERTF_STATUS_GOTEVENT;
				return CONVERTERR_NOERROR;
			}
			else if (nChkErr == CONVERTERR_METASKIP)
			{
				// We skip by all meta events that aren't tempo changes...
			}
			else
			{
				//TRACE0("Unable to add event to stream buffer.\n");
				if (mDwMallocBlocks)
				{
					delete [] mTeTemp.pLongData;
					mDwMallocBlocks--;
				}
				return (TRUE);
			}
		}
	}

	for (;;)
	{
		mPtsFound = nullptr;
		mTkNext = 0xFFFFFFFFL;
		// Find nearest event due
		for (auto& m_track : mTracks)
		{
			mPtsTrack = &m_track;
			if (!(mPtsTrack->FdwTrack & ITS_F_ENDOFTRK) && (mPtsTrack->TkNextEventDue < mTkNext))
			{
				mTkNext = mPtsTrack->TkNextEventDue;
				mPtsFound = mPtsTrack;
			}
		}

		// None found?  We must be done, so return to the caller with a smile.
		if (!mPtsFound)
		{
			mDwStatus |= CONVERTF_STATUS_DONE;
			// Need to set return buffer members properly
			return CONVERTERR_NOERROR;
		}

		// Ok, get the event header from that track
		if (!GetTrackEvent(mPtsFound, &mTeTemp))
		{
			// Warn future calls that this converter is stuck at a corrupt spot
			// and can't continue
			mDwStatus |= CONVERTF_STATUS_STUCK;
			return CONVERTERR_CORRUPT;
		}

		// Don't add end of track event 'til we're done
		if (mTeTemp.byShortData[0] == MIDI_META && mTeTemp.byShortData[1] == MIDI_META_EOT)
		{
			if (mDwMallocBlocks)
			{
				delete [] mTeTemp.pLongData;
				--mDwMallocBlocks;
			}
			continue;
		}

		if ((nChkErr = AddEventToStreamBuffer(&mTeTemp, lpciInfo)) != CONVERTERR_NOERROR)
		{
			if (nChkErr == CONVERTERR_BUFFERFULL)
			{
				// Do some processing and tell somebody this buffer is full...
				mDwStatus |= CONVERTF_STATUS_GOTEVENT;
				return CONVERTERR_NOERROR;
			}
			else if (nChkErr == CONVERTERR_METASKIP)
			{
				// We skip by all meta events that aren't tempo changes...
			}
			else
			{
				//TRACE0("Unable to add event to stream buffer.\n");
				if (mDwMallocBlocks)
				{
					delete [] mTeTemp.pLongData;
					mDwMallocBlocks--;
				}
				return TRUE;
			}
		}
	}
}

// GetTrackEvent
//
// Fills in the event struct with the next event from the track
//
// pteTemp->tkEvent will contain the absolute tick time of the event
// pteTemp->byShortData[0] will contain
//  MIDI_META if the event is a meta event;
//   in this case pteTemp->byShortData[1] will contain the meta class
//  MIDI_SYSEX or MIDI_SYSEXEND if the event is a SysEx event
//  Otherwise, the event is a channel message and pteTemp->byShortData[1]
//   and pteTemp->byShortData[2] will contain the rest of the event.
//
// pteTemp->dwEventLength will contain
//  The total length of the channel message in pteTemp->byShortData if
//   the event is a channel message
//  The total length of the parameter data pointed to by
//   pteTemp->pLongData otherwise
//
// pteTemp->pLongData will point at any additional parameters if the 
//  event is a SysEx or meta event with non-zero length; else
//  it will contain NULL
//
// Returns TRUE on success or FALSE on any kind of parse error
// Prints its own error message ONLY in the debug version
//
// Maintains the state of the input track (i.e. 
// ptsTrack->pTrackPointers, and ptsTrack->byRunningStatus).
//
BOOL CMIDI::GetTrackEvent(Track* ptsTrack, TempEvent* pteTemp)
{
	DWORD idx;

	// Clear out the temporary event structure to get rid of old data...
	memset(pteTemp, 0, sizeof(TempEvent));

	// Already at end of track? There's nothing to read.
	if (ptsTrack->FdwTrack & ITS_F_ENDOFTRK)
		return FALSE;

	// Get the first byte, which determines the type of event.
	BYTE byByte;
	if (!GetTrackByte(ptsTrack, &byByte))
		return FALSE;

	// If the high bit is not set, then this is a channel message
	// which uses the status byte from the last channel message
	// we saw. NOTE: We do not clear running status across SysEx or
	// meta events even though the spec says to because there are
	// actually files out there which contain that sequence of data.
	if (!(byByte & 0x80))
	{
		// No previous status byte? We're hosed.
		if (!ptsTrack->ByRunningStatus)
		{
			TrackError(ptsTrack, GteBadRunStat);
			return FALSE;
		}

		pteTemp->byShortData[0] = ptsTrack->ByRunningStatus;
		pteTemp->byShortData[1] = byByte;

		byByte = pteTemp->byShortData[0] & 0xF0;
		pteTemp->dwEventLength = 2;

		// Only program change and channel pressure events are 2 bytes long;
		// the rest are 3 and need another byte
		if ((byByte != MIDI_PRGMCHANGE) && (byByte != MIDI_CHANPRESS))
		{
			if (!GetTrackByte(ptsTrack, &pteTemp->byShortData[2]))
				return FALSE;
			++pteTemp->dwEventLength;
		}
	}
	else if ((byByte & 0xF0) != MIDI_SYSEX)
	{
		// Not running status, not in SysEx range - must be
		// normal channel message (0x80-0xEF)
		pteTemp->byShortData[0] = byByte;
		ptsTrack->ByRunningStatus = byByte;

		// Strip off channel and just keep message type
		byByte &= 0xF0;

		UINT dwEventLength = (byByte == MIDI_PRGMCHANGE || byByte == MIDI_CHANPRESS) ? 1 : 2;
		pteTemp->dwEventLength = dwEventLength + 1;

		if (!GetTrackByte(ptsTrack, &pteTemp->byShortData[1]))
			return FALSE;
		if (dwEventLength == 2)
			if (!GetTrackByte(ptsTrack, &pteTemp->byShortData[2]))
				return FALSE;
	}
	else if ((byByte == MIDI_SYSEX) || (byByte == MIDI_SYSEXEND))
	{
		// One of the SysEx types. (They are the same as far as we're concerned;
		// there is only a semantic difference in how the data would actually
		// get sent when the file is played. We must take care to put the proper
		// event type back on the output track, however.)
		//
		// Parse the general format of:
		//  BYTE 	bEvent (MIDI_SYSEX or MIDI_SYSEXEND)
		//  VDWORD 	cbParms
		//  BYTE   	abParms[cbParms]
		pteTemp->byShortData[0] = byByte;
		if (!GetTrackVdWord(ptsTrack, &pteTemp->dwEventLength))
		{
			TrackError(ptsTrack, GteSysExLenTrunc);
			return FALSE;
		}

		// Malloc a temporary memory block to hold the parameter data
		pteTemp->pLongData = new BYTE [pteTemp->dwEventLength];
		if (pteTemp->pLongData == nullptr)
		{
			TrackError(ptsTrack, GteNoMem);
			return FALSE;
		}
		// Increment our counter, which tells the program to look around for
		// a malloc block to free, should it need to exit or reset before the
		// block would normally be freed
		++mDwMallocBlocks;

		// Copy from the input buffer to the parameter data buffer
		for (idx = 0; idx < pteTemp->dwEventLength; idx++)
			if (!GetTrackByte(ptsTrack, pteTemp->pLongData + idx))
			{
				TrackError(ptsTrack, GteSysExTrunc);
				return FALSE;
			}
	}
	else if (byByte == MIDI_META)
	{
		// It's a meta event. Parse the general form:
		//  BYTE	bEvent	(MIDI_META)
		//  BYTE	bClass
		//  VDWORD	cbParms
		//  BYTE	abParms[cbParms]
		pteTemp->byShortData[0] = byByte;

		if (!GetTrackByte(ptsTrack, &pteTemp->byShortData[1]))
			return FALSE;

		if (!GetTrackVdWord(ptsTrack, &pteTemp->dwEventLength))
		{
			TrackError(ptsTrack, GteMetaLenTrunc);
			return FALSE;
		}

		// NOTE: It's perfectly valid to have a meta with no data
		// In this case, dwEventLength == 0 and pLongData == NULL
		if (pteTemp->dwEventLength)
		{
			// Malloc a temporary memory block to hold the parameter data
			pteTemp->pLongData = new BYTE [pteTemp->dwEventLength];
			if (pteTemp->pLongData == nullptr)
			{
				TrackError(ptsTrack, GteNoMem);
				return FALSE;
			}
			// Increment our counter, which tells the program to look around for
			// a malloc block to free, should it need to exit or reset before the
			// block would normally be freed
			++mDwMallocBlocks;

			// Copy from the input buffer to the parameter data buffer
			for (idx = 0; idx < pteTemp->dwEventLength; idx++)
				if (!GetTrackByte(ptsTrack, pteTemp->pLongData + idx))
				{
					TrackError(ptsTrack, GteMetaTrunc);
					return FALSE;
				}
		}

		if (pteTemp->byShortData[1] == MIDI_META_EOT)
			ptsTrack->FdwTrack |= ITS_F_ENDOFTRK;
	}
	else
	{
		// Messages in this range are system messages and aren't supposed to
		// be in a normal MIDI file. If they are, we've either disparaged or the
		// authoring software is stupid.
		return FALSE;
	}

	// Event time was already stored as the current track time
	pteTemp->tkEvent = ptsTrack->TkNextEventDue;

	// Now update to the next event time. The code above MUST properly
	// maintain the end of track flag in case the end of track meta is
	// missing.  NOTE: This code is a continuation of the track event
	// time pre-read which is done at the end of track initialization.
	if (!(ptsTrack->FdwTrack & ITS_F_ENDOFTRK))
	{
		DWORD tkDelta;

		if (!GetTrackVdWord(ptsTrack, &tkDelta))
			return FALSE;

		ptsTrack->TkNextEventDue += tkDelta;
	}

	return TRUE;
}


// GetTrackVDWord
//
// Attempts to parse a variable length DWORD from the given track. A VDWord
// in a MIDI file
//  (a) is in lo-hi format 
//  (b) has the high bit set on every byte except the last
//
// Returns the DWORD in *lpdw and TRUE on success; else
// FALSE if we hit end of track first.
BOOL CMIDI::GetTrackVdWord(Track* ptsTrack, const LPDWORD lpdw)
{
	//ASSERT(ptsTrack != 0);
	//ASSERT(lpdw != 0);

	if (ptsTrack->FdwTrack & ITS_F_ENDOFTRK)
		return FALSE;

	BYTE byByte;
	DWORD dw = 0;

	do
	{
		if (!GetTrackByte(ptsTrack, &byByte))
			return FALSE;

		dw = (dw << 7) | (byByte & 0x7F);
	}
	while (byByte & 0x80);

	*lpdw = dw;

	return TRUE;
}


// AddEventToStreamBuffer
//
// Put the given event into the given stream buffer at the given location
// pteTemp must point to an event filled out in accordance with the
// description given in GetTrackEvent
//
// Handles its own error notification by displaying to the appropriate
// output device (either our debugging window, or the screen).
int CMIDI::AddEventToStreamBuffer(TempEvent* pteTemp, ConvertInfo* lpciInfo)
{
	auto* pmeEvent = reinterpret_cast<MIDIEVENT *>(lpciInfo->MhBuffer.lpData
		+ lpciInfo->DwStartOffset
		+ lpciInfo->DwBytesRecorded);

	// When we see a new, empty buffer, set the start time on it...
	if (!lpciInfo->DwBytesRecorded)
		lpciInfo->TkStart = mTkCurrentTime;

	// Use the above set start time to figure out how much longer we should fill
	// this buffer before officially declaring it as "full"
	if (mTkCurrentTime - lpciInfo->TkStart > mDwBufferTickLength)
	{
		if (lpciInfo->BTimesUp)
		{
			lpciInfo->BTimesUp = FALSE;
			return CONVERTERR_BUFFERFULL;
		}
		else
		{
			lpciInfo->BTimesUp = TRUE;
		}
	}

	// Delta time is absolute event time minus absolute time
	// already gone by on this track
	DWORD tkDelta = pteTemp->tkEvent - mTkCurrentTime;

	// Event time is now current time on this track
	mTkCurrentTime = pteTemp->tkEvent;

	if (mBInsertTempo)
	{
		mBInsertTempo = FALSE;

		if (lpciInfo->DwMaxLength - lpciInfo->DwBytesRecorded < 3 * sizeof(DWORD))
		{
			// Cleanup from our write operation
			return CONVERTERR_BUFFERFULL;
		}
		if (mDwCurrentTempo)
		{
			pmeEvent->dwDeltaTime = 0;
			pmeEvent->dwStreamID = 0;
			pmeEvent->dwEvent = (mDwCurrentTempo * 100) / mDwTempoMultiplier;
			pmeEvent->dwEvent |= (static_cast<DWORD>(MEVT_TEMPO) << 24) | MEVT_F_SHORT;

			lpciInfo->DwBytesRecorded += 3 * sizeof(DWORD);
			pmeEvent += 3 * sizeof(DWORD);
		}
	}

	if (pteTemp->byShortData[0] < MIDI_SYSEX)
	{
		// Channel message. We know how long it is, just copy it.
		// Need 3 DWORD's: delta-t, stream-ID, event
		if (lpciInfo->DwMaxLength - lpciInfo->DwBytesRecorded < 3 * sizeof(DWORD))
		{
			// Cleanup from our write operation
			return CONVERTERR_BUFFERFULL;
		}

		pmeEvent->dwDeltaTime = tkDelta;
		pmeEvent->dwStreamID = 0;
		pmeEvent->dwEvent = (pteTemp->byShortData[0])
			| (static_cast<DWORD>(pteTemp->byShortData[1]) << 8)
			| (static_cast<DWORD>(pteTemp->byShortData[2]) << 16)
			| MEVT_F_SHORT;

		if (((pteTemp->byShortData[0] & 0xF0) == MIDI_CTRLCHANGE) && (pteTemp->byShortData[1] == MIDICTRL_VOLUME))
		{
			// If this is a volume change, generate a callback so we can grab
			// the new volume for our cache
			pmeEvent->dwEvent |= MEVT_F_CALLBACK;
		}
		lpciInfo->DwBytesRecorded += 3 * sizeof(DWORD);
	}
	else if ((pteTemp->byShortData[0] == MIDI_SYSEX) || (pteTemp->byShortData[0] == MIDI_SYSEXEND))
	{
		//TRACE0("AddEventToStreamBuffer: Ignoring SysEx event.\n");
		if (mDwMallocBlocks)
		{
			delete [] pteTemp->pLongData;
			--mDwMallocBlocks;
		}
	}
	else
	{
		// Better be a meta event.
		//  BYTE	byEvent
		//  BYTE	byEventType
		//  VDWORD	dwEventLength
		//  BYTE	pLongEventData[dwEventLength]
		//ASSERT( pteTemp->byShortData[0] == MIDI_META );

		// The only meta-event we care about is change tempo
		if (pteTemp->byShortData[1] != MIDI_META_TEMPO)
		{
			if (mDwMallocBlocks)
			{
				delete [] pteTemp->pLongData;
				--mDwMallocBlocks;
			}
			return CONVERTERR_METASKIP;
		}

		// We should have three bytes of parameter data...
		//ASSERT(pteTemp->dwEventLength == 3);

		// Need 3 DWORD's: delta-t, stream-ID, event data
		if (lpciInfo->DwMaxLength - lpciInfo->DwBytesRecorded < 3 * sizeof(DWORD))
		{
			// Cleanup the temporary event if necessary and return
			if (mDwMallocBlocks)
			{
				delete [] pteTemp->pLongData;
				--mDwMallocBlocks;
			}
			return CONVERTERR_BUFFERFULL;
		}

		pmeEvent->dwDeltaTime = tkDelta;
		pmeEvent->dwStreamID = 0;
		// Note: this is backwards from above because we're converting a single
		//		 data value from hi-lo to lo-hi format...
		pmeEvent->dwEvent = (pteTemp->pLongData[2])
			| (static_cast<DWORD>(pteTemp->pLongData[1]) << 8)
			| (static_cast<DWORD>(pteTemp->pLongData[0]) << 16);

		// This next step has absolutely nothing to do with the conversion of a
		// MIDI file to a stream, it's simply put here to add the functionality
		// of the tempo slider. If you don't need this, be sure to remove the
		// next two lines.
		mDwCurrentTempo = pmeEvent->dwEvent;
		pmeEvent->dwEvent = (pmeEvent->dwEvent * 100) / mDwTempoMultiplier;

		pmeEvent->dwEvent |= (static_cast<DWORD>(MEVT_TEMPO) << 24) | MEVT_F_SHORT;

		mDwBufferTickLength = (mDwTimeDivision * 1000 * BUFFER_TIME_LENGTH) / mDwCurrentTempo;
		//TRACE1("m_dwBufferTickLength = %lu\n", m_dwBufferTickLength);

		if (mDwMallocBlocks)
		{
			delete [] pteTemp->pLongData;
			--mDwMallocBlocks;
		}
		lpciInfo->DwBytesRecorded += 3 * sizeof(DWORD);
	}

	return CONVERTERR_NOERROR;
}


// StreamBufferSetup()
//
// Opens a MIDI stream. Then it goes about converting the data into a midiStream buffer for playback.
BOOL CMIDI::StreamBufferSetup()
{
	int nChkErr;
	BOOL bFoundEnd = FALSE;

	MMRESULT mmrRetVal;

	if (!mHStream)
		if ((mmrRetVal = midiStreamOpen(&mHStream,
		                                &mUMidiDeviceId,
		                                uintptr_t(1), uintptr_t(MidiProc),
		                                uintptr_t(this),
		                                CALLBACK_FUNCTION)) != MMSYSERR_NOERROR)
		{
			MidiError(mmrRetVal);
			return FALSE;
		}

	// allocate stream buffers and initialise them
	mStreamBuffers.resize(NUM_STREAM_BUFFERS);

	MIDIPROPTIMEDIV mptd;
	mptd.cbStruct = sizeof(mptd);
	mptd.dwTimeDiv = mDwTimeDivision;
	if ((mmrRetVal = midiStreamProperty(mHStream, reinterpret_cast<LPBYTE>(&mptd),
	                                    MIDIPROP_SET | MIDIPROP_TIMEDIV)) != MMSYSERR_NOERROR)
	{
		MidiError(mmrRetVal);
		return FALSE;
	}

	mNEmptyBuffers = 0;
	DWORD dwConvertFlag = CONVERTF_RESET;

	for (mNCurrentBuffer = 0; mNCurrentBuffer < NUM_STREAM_BUFFERS; mNCurrentBuffer++)
	{
		mStreamBuffers[mNCurrentBuffer].MhBuffer.dwBufferLength = OUT_BUFFER_SIZE;
		mStreamBuffers[mNCurrentBuffer].MhBuffer.lpData = new char [OUT_BUFFER_SIZE];
		if (mStreamBuffers[mNCurrentBuffer].MhBuffer.lpData == nullptr)
			return FALSE;

		// Tell the converter to convert up to one entire buffer's length of output
		// data. Also, set a flag so it knows to reset any saved state variables it
		// may keep from call to call.
		mStreamBuffers[mNCurrentBuffer].DwStartOffset = 0;
		mStreamBuffers[mNCurrentBuffer].DwMaxLength = OUT_BUFFER_SIZE;
		mStreamBuffers[mNCurrentBuffer].TkStart = 0;
		mStreamBuffers[mNCurrentBuffer].BTimesUp = FALSE;

		if ((nChkErr = ConvertToBuffer(dwConvertFlag, &mStreamBuffers[mNCurrentBuffer])) != CONVERTERR_NOERROR)
		{
			if (nChkErr == CONVERTERR_DONE)
			{
				bFoundEnd = TRUE;
			}
			else
			{
				//TRACE0("Initial conversion pass failed\n");
				return FALSE;
			}
		}
		mStreamBuffers[mNCurrentBuffer].MhBuffer.dwBytesRecorded = mStreamBuffers[mNCurrentBuffer].DwBytesRecorded;

		if (!mBBuffersPrepared)
			if ((mmrRetVal = midiOutPrepareHeader(reinterpret_cast<HMIDIOUT>(mHStream),
			                                      &mStreamBuffers[mNCurrentBuffer].MhBuffer,
			                                      sizeof(MIDIHDR))) != MMSYSERR_NOERROR)
			{
				MidiError(mmrRetVal);
				return FALSE;
			}

		if ((mmrRetVal = midiStreamOut(mHStream,
		                               &mStreamBuffers[mNCurrentBuffer].MhBuffer,
		                               sizeof(MIDIHDR))) != MMSYSERR_NOERROR)
		{
			MidiError(mmrRetVal);
			break;
		}
		dwConvertFlag = 0;

		if (bFoundEnd)
			break;
	}

	mBBuffersPrepared = TRUE;
	mNCurrentBuffer = 0;
	return TRUE;
}

// This function unprepared and frees all our buffers -- something we must
// do to work around a bug in MMYSYSTEM that prevents a device from playing
// back properly unless it is closed and reopened after each stop.
void CMIDI::FreeBuffers()
{
	DWORD idx;
	MMRESULT mmrRetVal;

	if (mBBuffersPrepared)
	{
		for (idx = 0; idx < NUM_STREAM_BUFFERS; idx++)
			if ((mmrRetVal = midiOutUnprepareHeader(reinterpret_cast<HMIDIOUT>(mHStream),
			                                        &mStreamBuffers[idx].MhBuffer,
			                                        sizeof(MIDIHDR))) != MMSYSERR_NOERROR)
			{
				MidiError(mmrRetVal);
			}
		mBBuffersPrepared = FALSE;
	}
	// Free our stream buffers...
	for (idx = 0; idx < NUM_STREAM_BUFFERS; idx++)
		if (mStreamBuffers[idx].MhBuffer.lpData)
		{
			delete [] mStreamBuffers[idx].MhBuffer.lpData;
			mStreamBuffers[idx].MhBuffer.lpData = nullptr;
		}
}

//////////////////////////////////////////////////////////////////////
// CMIDI -- error handling
//////////////////////////////////////////////////////////////////////

void CMIDI::MidiError(const MMRESULT mmResult)
{
#ifdef _DEBUG
	char chText[512];
	midiOutGetErrorText(mmResult, chText, sizeof(chText));
	//TRACE1("Midi error: %hs\n", chText);
#endif
}


void CMIDI::TrackError(Track* ptsTrack, LPSTR errMsg)
{
	//TRACE1("Track buffer offset %lu\n", (DWORD)(ptsTrack->pTrackCurrent - ptsTrack->pTrackStart));
	//TRACE1("Track total length %lu\n", ptsTrack->dwTrackLength);
	//TRACE1("%hs\n", lpszErr);
}

//////////////////////////////////////////////////////////////////////
// CMIDI -- overridable
//////////////////////////////////////////////////////////////////////

void CMIDI::OnMidiOutOpen()
{
}


void CMIDI::OnMidiOutDone(MIDIHDR& rHdr)
{
	if (mUCallbackStatus == STATUS_CALLBACKDEAD)
		return;

	++mNEmptyBuffers;

	if (mUCallbackStatus == STATUS_WAITINGFOREND)
	{
		if (mNEmptyBuffers < NUM_STREAM_BUFFERS)
			return;
		else
		{
			mUCallbackStatus = STATUS_CALLBACKDEAD;
			Stop();
			SetEvent(mHBufferReturnEvent);
			return;
		}
	}

	// This flag is set whenever the callback is waiting for all buffers to
	// come back.
	if (mUCallbackStatus == STATUS_KILLCALLBACK)
	{
		// Count NUM_STREAM_BUFFERS-1 being returned for the last time
		if (mNEmptyBuffers < NUM_STREAM_BUFFERS)
			return;
		else
		{
			// Change the status to callback dead
			mUCallbackStatus = STATUS_CALLBACKDEAD;
			SetEvent(mHBufferReturnEvent);
			return;
		}
	}

	mDwProgressBytes += mStreamBuffers[mNCurrentBuffer].MhBuffer.dwBytesRecorded;

	///////////////////////////////////////////////////////////////////////////////
	// Fill an available buffer with audio data again...

	if (mBPlaying && mNEmptyBuffers)
	{
		mStreamBuffers[mNCurrentBuffer].DwStartOffset = 0;
		mStreamBuffers[mNCurrentBuffer].DwMaxLength = OUT_BUFFER_SIZE;
		mStreamBuffers[mNCurrentBuffer].TkStart = 0;
		mStreamBuffers[mNCurrentBuffer].DwBytesRecorded = 0;
		mStreamBuffers[mNCurrentBuffer].BTimesUp = FALSE;

		int nChkErr;

		if ((nChkErr = ConvertToBuffer(0, &mStreamBuffers[mNCurrentBuffer])) != CONVERTERR_NOERROR)
		{
			if (nChkErr == CONVERTERR_DONE)
			{
				mUCallbackStatus = STATUS_WAITINGFOREND;
				return;
			}
			else
			{
				//TRACE0("MidiProc() conversion pass failed!\n");
				return;
			}
		}

		mStreamBuffers[mNCurrentBuffer].MhBuffer.dwBytesRecorded = mStreamBuffers[mNCurrentBuffer].DwBytesRecorded;

		MMRESULT mmrRetVal;
		if ((mmrRetVal = midiStreamOut(mHStream, &mStreamBuffers[mNCurrentBuffer].MhBuffer, sizeof(MIDIHDR))) !=
			MMSYSERR_NOERROR)
		{
			MidiError(mmrRetVal);
			return;
		}
		mNCurrentBuffer = (mNCurrentBuffer + 1) % NUM_STREAM_BUFFERS;
		mNEmptyBuffers--;
	}
}


void CMIDI::OnMidiOutPositionCB(MIDIHDR& rHdr, MIDIEVENT& rEvent)
{
	if (MIDIEVENT_TYPE(rEvent.dwEvent) == MIDI_CTRLCHANGE)
	{
		if (MIDIEVENT_DATA1(rEvent.dwEvent) == MIDICTRL_VOLUME)
		{
			// Mask off the channel number and cache the volume data byte
			mVolumes[MIDIEVENT_CHANNEL(rEvent.dwEvent)] = DWORD(MIDIEVENT_VOLUME(rEvent.dwEvent) * 100 / VOLUME_MAX);
			if (mPWndParent/* && ::IsWindow(m_pWndParent->GetSafeHwnd())*/)
				// Do not use SendMessage(), because a change of the midi stream has no effect
				// during callback handling, so if the owner wants to adjust the volume, as a
				// result of the windows message, (s)he will not hear that change.
				PostMessage(*mPWndParent,
				            WM_MIDI_VOLUMECHANGED,
				            WPARAM(this),
				            LPARAM(
					            MAKELONG(
						            WORD(MIDIEVENT_CHANNEL(rEvent.dwEvent)),
						            WORD(MIDIEVENT_VOLUME(rEvent.dwEvent)*100/VOLUME_MAX)
					            )
				            )
				);
		}
	}
}


void CMIDI::OnMidiOutClose()
{
}

//////////////////////////////////////////////////////////////////////
// CMIDI -- static members
//////////////////////////////////////////////////////////////////////

void CMIDI::MidiProc(HMIDIOUT hMidi, const UINT uMsg, const uintptr_t dwInstanceData, const uintptr_t dwParam1, uintptr_t dwParam2)
{
	auto* pMidi = reinterpret_cast<CMIDI*>(dwInstanceData);
	//ASSERT(pMidi != 0);
	auto* pHdr = reinterpret_cast<MIDIHDR*>(dwParam1);

	switch (uMsg)
	{
	case MOM_OPEN:
		pMidi->OnMidiOutOpen();
		break;

	case MOM_CLOSE:
		pMidi->OnMidiOutClose();
		break;

	case MOM_DONE:
		//ASSERT(pHdr != 0);
		pMidi->OnMidiOutDone(*pHdr);
		break;

	case MOM_POSITIONCB:
		//ASSERT(pHdr != 0);
		pMidi->OnMidiOutPositionCB(*pHdr, *reinterpret_cast<MIDIEVENT*>(pHdr->lpData + pHdr->dwOffset));
		break;

	default:
		break;
	}
}

```

`UnrealFinderTool/Midi/MIDI.h`:

```h
#pragma once
#ifndef MIDI_h
#define MIDI_h

#include <mmsystem.h>
#include <vector>
using namespace std;


// This message is sent to the controlling window, if the volume changes in
// another way than explicitly set by the owner of the CMIDI object.
// WPARAM	the pointer to the MIDI object
// LPARAM	lo-word: the number of the channel that changed volume
//			hi-word: the new volume in percent
#define	WM_MIDI_VOLUMECHANGED	WM_USER+23


#define MIDI_CTRLCHANGE			((BYTE)0xB0)		// + ctrlr + value
#define MIDI_PRGMCHANGE			((BYTE)0xC0)		// + new patch
#define MIDI_CHANPRESS			((BYTE)0xD0)		// + pressure (1 byte)

#define MIDICTRL_VOLUME			((BYTE)0x07)

#define MIDIEVENT_CHANNEL(dw)	(dw & 0x0000000F)
#define MIDIEVENT_TYPE(dw)		(dw & 0x000000F0)
#define MIDIEVENT_DATA1(dw)		((dw & 0x0000FF00) >> 8)
#define MIDIEVENT_VOLUME(dw)	((dw & 0x007F0000) >> 16)

#define MIDI_SYSEX				((BYTE)0xF0)		// SysEx begin
#define MIDI_SYSEXEND			((BYTE)0xF7)		// SysEx end
#define MIDI_META				((BYTE)0xFF)		// Meta event begin
#define MIDI_META_TEMPO			((BYTE)0x51)		// Tempo change
#define MIDI_META_EOT			((BYTE)0x2F)		// End-of-track


// flags for the ConvertToBuffer() method
#define CONVERTF_RESET				0x00000001
#define CONVERTF_STATUS_DONE		0x00000001
#define CONVERTF_STATUS_STUCK		0x00000002
#define CONVERTF_STATUS_GOTEVENT	0x00000004

// Return values from the ConvertToBuffer() method
#define CONVERTERR_NOERROR		0		// No error occured
#define CONVERTERR_CORRUPT		-101	// The input file is corrupt
// The converter has already encountered a corrupt file and cannot convert any
// more of this file -- must reset the converter
#define CONVERTERR_STUCK		-102
#define CONVERTERR_DONE			-103	// Converter is done
#define CONVERTERR_BUFFERFULL	-104	// The buffer is full
#define CONVERTERR_METASKIP		-105	// Skipping unknown meta event

#define STATUS_KILLCALLBACK		100		// Signals that the callback should die
#define STATUS_CALLBACKDEAD		200		// Signals callback is done processing
#define STATUS_WAITINGFOREND	300		// Callback's waiting for buffers to play

// Description of a track
//
struct Track
{
	DWORD FdwTrack; // Track's flags
	DWORD DwTrackLength; // Total bytes in track
	LPBYTE PTrackStart; // -> start of track data buffer
	LPBYTE PTrackCurrent; // -> next byte to read in buffer
	DWORD TkNextEventDue; // Absolute time of next event in track
	BYTE ByRunningStatus; // Running status from last channel msg

	Track()
		: FdwTrack(0)
		  , DwTrackLength(0)
		  , PTrackStart(nullptr)
		  , PTrackCurrent(nullptr)
		  , TkNextEventDue(0)
		  , ByRunningStatus(0)
	{
	}
};

#define ITS_F_ENDOFTRK		0x00000001


// This structure is used to pass information to the ConvertToBuffer()
// system and then internally by that function to send information about the
// target stream buffer and current state of the conversion process to internal
// lower level conversion routines.
struct ConvertInfo
{
	MIDIHDR MhBuffer; // Standard Windows stream buffer header
	DWORD DwStartOffset; // Start offset from mhStreamBuffer.lpStart
	DWORD DwMaxLength; // Max length to convert on this pass
	DWORD DwBytesRecorded;
	DWORD TkStart;
	BOOL BTimesUp;

	ConvertInfo()
		: DwStartOffset(0)
		  , DwMaxLength(0)
		  , DwBytesRecorded(0)
		  , TkStart(0)
		  , BTimesUp(FALSE)
	{
		memset(&MhBuffer, 0, sizeof(MIDIHDR));
	}
};

// Temporary event structure which stores event data until we're ready to
// dump it into a stream buffer
struct TempEvent
{
	DWORD tkEvent; // Absolute time of event
	BYTE byShortData[4]; // Event type and parameters if channel msg
	DWORD dwEventLength; // Length of data which follows if meta or sysex
	LPBYTE pLongData; // -> Event data if applicable
};

class CMIDI
{
protected:
	typedef vector<Track> TrackArray;
	typedef vector<size_t> VolumeArray;
	typedef vector<ConvertInfo> ConvertArray;

	enum
	{
		NUM_CHANNELS = 16,
		// 16 volume channels
		VOLUME_INIT = 100,
		// 100% volume by default
		NUM_STREAM_BUFFERS = 2,
		OUT_BUFFER_SIZE = 1024,
		// Max stream buffer size in bytes
		DEBUG_CALLBACK_TIMEOUT = 2000,
		VOLUME_MIN = 0,
		VOLUME_MAX = 127 // == 100%
	};

public:
	CMIDI();
	virtual ~CMIDI();

	BOOL Create(LPBYTE pSoundData, DWORD dwSize, HWND pParent = nullptr);
	BOOL Create(LPCTSTR pszResId, HWND pWndParent = nullptr);
	BOOL Create(UINT uResId, HWND pWndParent = nullptr);

	BOOL Play(BOOL bInfinite = FALSE);
	BOOL Stop(BOOL bReOpen = TRUE);
	BOOL IsPlaying() const { return mBPlaying; }

	BOOL Pause();
	BOOL Continue();
	BOOL IsPaused() const { return mBPaused; }

	// Set playback position back to the start
	BOOL Rewind();

	// Get the number of volume channels
	size_t GetChannelCount() const;

	// Set the volume of a channel in percent. Channels are from 0 to (GetChannelCount()-1)
	void SetChannelVolume(size_t channel, size_t percent);

	// Get the volume of a channel in percent
	size_t GetChannelVolume(size_t channel) const;

	// Set the volume for all channels in percent
	void SetVolume(size_t percent);

	// Get the average volume for all channels
	size_t GetVolume() const;

	// Set the tempo of the playback. Default: 100%
	void SetTempo(DWORD percent);

	// Get the current tempo in percent (usually 100)
	DWORD GetTempo() const;

	// You can (un)set an infinite loop during playback.
	// Note that "Play()" resets this setting!
	void SetInfinitePlay(BOOL bSet = TRUE);

protected: // implementation
	// This function converts MIDI data from the track buffers.
	int ConvertToBuffer(DWORD dwFlags, ConvertInfo* lpciInfo);

	// Fills in the event struct with the next event from the track
	BOOL GetTrackEvent(Track* ptsTrack, TempEvent* pteTemp);

	// Retrieve the next byte from the track buffer, refilling the buffer from
	// disk if necessary.
	BOOL GetTrackByte(Track* ptsTrack, const LPBYTE lpbyByte)
	{
		if (DWORD(ptsTrack->PTrackCurrent - ptsTrack->PTrackStart) == ptsTrack->DwTrackLength)
			return FALSE;
		*lpbyByte = *ptsTrack->PTrackCurrent++;
		return TRUE;
	}

	// Attempts to parse a variable length DWORD from the given track.
	BOOL GetTrackVdWord(Track* ptsTrack, LPDWORD lpdw);

	// Put the given event into the given stream buffer at the given location.
	int AddEventToStreamBuffer(TempEvent* pteTemp, ConvertInfo* lpciInfo);

	// Opens a MIDI stream. Then it goes about converting the data into a midiStream buffer for playback.
	BOOL StreamBufferSetup();

	void FreeBuffers();


protected: // error handling
	// The default implementation writes the error message in the
	// debuggers output window. Override if you want a different
	// behavior.
	virtual void MidiError(MMRESULT result);

	// Failure in converting track into stream.
	// The default implementation displays the offset and the total
	// number of bytes of the failed track and the error message in
	// the debuggers output window. 
	virtual void TrackError(Track*, LPSTR errMsg);


protected: // overrideable
	// NOTE THAT, IF YOU OVERRIDE ONE OF THESE METHODS, YOU MUST CALL
	// THE BASE CLASS IMPLEMENTATION TOO!

	// called when a MIDI output device is opened
	virtual void OnMidiOutOpen();

	// called when the MIDI output device is closed
	virtual void OnMidiOutClose();

	// called when the specified system-exclusive or stream buffer
	// has been played and is being returned to the application
	virtual void OnMidiOutDone(MIDIHDR&);

	// called when a MEVT_F_CALLBACK event is reached in the MIDI output stream
	virtual void OnMidiOutPositionCB(MIDIHDR&, MIDIEVENT&);


private: // callback procedure
	// This procedure calls the overrideable above.
	static void CALLBACK MidiProc(HMIDIOUT, UINT, uintptr_t, uintptr_t, uintptr_t);


protected: // data members
	DWORD mDwSoundSize;
	LPVOID mPSoundData;
	DWORD mDwFormat;
	DWORD mDwTrackCount;
	DWORD mDwTimeDivision;
	BOOL mBPlaying;
	HMIDISTRM mHStream;
	DWORD mDwProgressBytes;
	BOOL mBLooped;
	DWORD mTkCurrentTime;
	DWORD mDwBufferTickLength;
	DWORD mDwCurrentTempo;
	DWORD mDwTempoMultiplier;
	BOOL mBInsertTempo;
	BOOL mBBuffersPrepared;
	int mNCurrentBuffer;
	UINT mUMidiDeviceId;
	int mNEmptyBuffers;
	BOOL mBPaused;
	UINT mUCallbackStatus;
	HANDLE mHBufferReturnEvent;
	HWND* mPWndParent;
	TrackArray mTracks;
	VolumeArray mVolumes;
	ConvertArray mStreamBuffers;

	// data members especially for ConvertToBuffer()
	Track* mPtsTrack;
	Track* mPtsFound;
	DWORD mDwStatus;
	DWORD mTkNext;
	DWORD mDwMallocBlocks;
	TempEvent mTeTemp;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // MIDI_h

```

`UnrealFinderTool/Midi/MIDI_Resource.h`:

```h
/* Autogenerated by hxtools bin2c */
#pragma once
#ifdef __cplusplus
extern "C" {
#endif

/* Autogenerated from Video_Game_Themes_-_Duke_Nukem.mid */
static const unsigned char midi_track1[57249] = {'M','T','h','d',0,0,0,06,0,01,0,'O',01,0200,'M','T','r','k',0,0,0,'#',0,0377,'X',04,01,02,'`',010,0,0377,0177,03,0,0,'A',0,0377,'Q',03,013,07,0313,0203,0,0377,'X',04,04,02,'`',010,0,0377,'/',0,'M','T','r','k',0,0,036,0251,0,0377,03,'"','D','u','k','e',' ','N','u','k','e','m',' ','6','4',' ','I','n','t','r','o','/','C','r','e','d','i','t','s',' ','T','h','e','m','e',' ',0,0260,0,0,0,0300,'#',0,0260,012,'!',0,0260,'[',05,0,0260,']',0,0,0377,'Y',02,03,0,0,0260,07,'i',0,0260,'n',0177,030,0260,'d',0,0,0260,'e',0,034,0260,06,02,0,0260,'&',0,034,0260,'d',0177,0,0260,'e',0177,'P',0340,0,'@',030,0260,01,0,0201,'H',0220,036,'d',0,0260,'t',0,0134,0200,036,0,04,0220,'!','d',0134,0200,'!',0,'d',0220,'#','d',0134,0200,'#',0,0201,'D',0220,036,'d',0134,0200,036,0,04,0220,'#','d',0134,0200,'#',0,'d',0220,'%','d',0134,0200,'%',0,0201,'D',0220,036,'d',0134,0200,036,0,04,0220,'%','d',0134,0200,'%',0,'d',0220,'&','d',0134,0200,'&',0,'d',0220,036,'d',0134,0200,036,0,'d',0220,'%','d',0201,'<',0200,'%',0,04,0220,'#','d',0134,0200,'#',0,04,0220,'!','d',0134,0200,'!',0,04,0220,036,'d',0134,0200,036,0,04,0220,034,'n',0134,0200,034,0,04,0220,035,'d',0134,0200,035,0,04,0220,036,'d',0134,0200,036,0,04,0220,037,'n',0201,'<',0200,037,0,04,0220,'#','d',0134,0200,'#',0,04,0220,'!','d',0134,0200,'!',0,04,0220,037,'d',0134,0200,037,0,04,0220,036,'d',0134,0200,036,0,04,0220,'!','d',0134,0200,'!',0,'d',0220,'#','d',0134,0200,'#',0,0201,'D',0220,036,'d',0134,0200,036,0,04,0220,'#','d',0134,0200,'#',0,'d',0220,'%','d',0134,0200,'%',0,0201,'D',0220,036,'d',0134,0200,036,0,04,0220,'%','d',0134,0200,'%',0,'d',0220,'&','d',0134,0200,'&',0,'d',0220,036,'d',0134,0200,036,0,'d',0220,'%','d',0201,'<',0200,'%',0,04,0220,'#','d',0134,0200,'#',0,04,0220,'!','d',0134,0200,'!',0,04,0220,036,'d',0134,0200,036,0,04,0220,037,'n',0134,0200,037,0,04,0220,'!','n',0134,0200,'!',0,04,0220,'#','n',0134,0200,'#',0,04,0220,037,'n',0,0220,'&','n',0201,'<',0200,'&',0,04,0220,'#','d',0134,0200,'#',0,04,0220,'!','d',0134,0200,'!',0,04,0220,'#','d',',',0200,037,0,'0',0200,'#',0,04,0220,'*','d',0134,0200,'*',0,04,0220,'*','d','0',0200,'*',0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,'*','d',0134,0200,'*',0,04,0220,'*','d','0',0200,'*',0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,'&','d',0134,0200,'&',0,04,0220,'%','d','0',0200,'%',0,'0',0220,036,'d','0',0200,036,0,'0',0220,037,'d',0134,0200,037,0,04,0220,037,'d','4',0200,037,0,',',0220,037,'d',0134,0200,037,0,04,0220,'*','d',0134,0200,'*',0,04,0220,'*','d','0',0200,'*',0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,'*','d',0134,0200,'*',0,04,0220,'*','d','0',0200,'*',0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,'&','d',0134,0200,'&',0,04,0220,'%','d','0',0200,'%',0,'0',0220,036,'d','0',0200,036,0,'0',0220,037,'d',0134,0200,037,0,04,0220,036,'d','4',0200,036,0,',',0220,036,'d',0134,0200,036,0,04,0220,'+','d',0134,0200,'+',0,04,0220,'+','Z','0',0200,'+',0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'d',0134,0200,037,0,04,0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'d',0134,0200,037,0,04,0220,037,'Z','0',0200,037,0,'0',0220,'+','d',0134,0200,'+',0,04,0220,'+','Z','0',0200,'+',0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'d',0134,0200,037,0,04,0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'d',0134,0200,037,0,04,0220,037,'Z','0',0200,037,0,'0',0220,036,'d',0134,0200,036,0,04,0220,'!','d',0134,0200,'!',0,'d',0220,'#','d',0134,0200,'#',0,0201,'D',0220,036,'d',0134,0200,036,0,04,0220,'#','d',0134,0200,'#',0,'d',0220,'%','d',0134,0200,'%',0,0201,'D',0220,036,'d',0134,0200,036,0,04,0220,'%','d',0134,0200,'%',0,'d',0220,'&','d',0134,0200,'&',0,'d',0220,036,'d',0134,0200,036,0,'d',0220,'%','d',0201,'<',0200,'%',0,04,0220,'#','d',0134,0200,'#',0,04,0220,'!','d',0134,0200,'!',0,04,0220,036,'d',0134,0200,036,0,04,0220,034,'n',0134,0200,034,0,04,0220,035,'d',0134,0200,035,0,04,0220,036,'d',0134,0200,036,0,04,0220,037,'n',0201,'<',0200,037,0,04,0220,'#','d',0134,0200,'#',0,04,0220,'!','d',0134,0200,'!',0,04,0220,037,'d',0134,0200,037,0,04,0220,'*','d',0134,0200,'*',0,04,0220,'*','d','0',0200,'*',0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,'*','d',0134,0200,'*',0,04,0220,'*','d','0',0200,'*',0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,'&','d',0134,0200,'&',0,04,0220,'%','d','0',0200,'%',0,'0',0220,036,'d','0',0200,036,0,'0',0220,037,'d',0134,0200,037,0,04,0220,037,'d','4',0200,037,0,',',0220,037,'d',0134,0200,037,0,04,0220,'*','d',0134,0200,'*',0,04,0220,'*','d','0',0200,'*',0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,'*','d',0134,0200,'*',0,04,0220,'*','d','0',0200,'*',0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,'&','d',0134,0200,'&',0,04,0220,'%','d','0',0200,'%',0,'0',0220,036,'d','0',0200,036,0,'0',0220,037,'d',0134,0200,037,0,04,0220,036,'d','4',0200,036,0,',',0220,036,'d',0134,0200,036,0,04,0220,'*','d',0134,0200,'*',0,04,0220,'*','d','0',0200,'*',0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,'*','d',0134,0200,'*',0,04,0220,'*','d','0',0200,'*',0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,'*','n',0134,0200,'*',0,04,0220,'*','d',0134,0200,'*',0,04,0220,'(','n',0134,0200,'(',0,04,0220,'(','d',0134,0200,'(',0,04,0220,'&','n',',',0200,'&',0,'4',0220,'&','d',0134,0200,'&',0,04,0220,'%','n','4',0200,'%',0,',',0220,'&','n',0134,0200,'&',0,04,0220,'*','d',0134,0200,'*',0,04,0220,'*','d','0',0200,'*',0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,'*','d',0134,0200,'*',0,04,0220,'*','d','0',0200,'*',0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,'&','d',0134,0200,'&',0,04,0220,'%','d','0',0200,'%',0,'0',0220,036,'d','0',0200,036,0,'0',0220,037,'d',0134,0200,037,0,04,0220,036,'d','4',0200,036,0,',',0220,036,'d',0134,0200,036,0,04,0220,'*','d',0134,0200,'*',0,04,0220,'*','Z','0',0200,'*',0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'Z','0',0200,036,0,'0',0220,'*','d',0134,0200,'*',0,04,0220,'*','Z','0',0200,'*',0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'Z','0',0200,036,0,',',0260,'u',0177,'d',0220,036,'d',0,0260,'t',0,0134,0200,036,0,04,0220,'!','d',0134,0200,'!',0,'d',0220,'#','d',0134,0200,'#',0,0201,'D',0220,036,'d',0134,0200,036,0,04,0220,'#','d',0134,0200,'#',0,'d',0220,'%','d',0134,0200,'%',0,0201,'D',0220,036,'d',0134,0200,036,0,04,0220,'%','d',0134,0200,'%',0,'d',0220,'&','d',0134,0200,'&',0,'d',0220,036,'d',0134,0200,036,0,'d',0220,'%','d',0201,'<',0200,'%',0,04,0220,'#','d',0134,0200,'#',0,04,0220,'!','d',0134,0200,'!',0,04,0220,036,'d',0134,0200,036,0,04,0220,034,'n',0134,0200,034,0,04,0220,035,'d',0134,0200,035,0,04,0220,036,'d',0134,0200,036,0,04,0220,037,'n',0201,'<',0200,037,0,04,0220,'#','d',0134,0200,'#',0,04,0220,'!','d',0134,0200,'!',0,04,0220,037,'d',0134,0200,037,0,04,0220,036,'d',0134,0200,036,0,04,0220,'!','d',0134,0200,'!',0,'d',0220,'#','d',0134,0200,'#',0,0201,'D',0220,036,'d',0134,0200,036,0,04,0220,'#','d',0134,0200,'#',0,'d',0220,'%','d',0134,0200,'%',0,0201,'D',0220,036,'d',0134,0200,036,0,04,0220,'%','d',0134,0200,'%',0,'d',0220,'&','d',0134,0200,'&',0,'d',0220,036,'d',0134,0200,036,0,'d',0220,'%','d',0201,'<',0200,'%',0,04,0220,'#','d',0134,0200,'#',0,04,0220,'!','d',0134,0200,'!',0,04,0220,036,'d',0134,0200,036,0,04,0220,037,'n',0134,0200,037,0,04,0220,'!','n',0134,0200,'!',0,04,0220,'#','n',0134,0200,'#',0,04,0220,037,'n',0,0220,'&','n',0201,'<',0200,'&',0,04,0220,'#','d',0134,0200,'#',0,04,0220,'!','d',0134,0200,'!',0,04,0220,'#','d',',',0200,037,0,'0',0200,'#',0,04,0220,'*','d',0134,0200,'*',0,04,0220,'*','d','0',0200,'*',0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,'*','d',0134,0200,'*',0,04,0220,'*','d','0',0200,'*',0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,'&','d',0134,0200,'&',0,04,0220,'%','d','0',0200,'%',0,'0',0220,036,'d','0',0200,036,0,'0',0220,037,'d',0134,0200,037,0,04,0220,037,'d','4',0200,037,0,',',0220,037,'d',0134,0200,037,0,04,0220,'*','d',0134,0200,'*',0,04,0220,'*','d','0',0200,'*',0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,'*','d',0134,0200,'*',0,04,0220,'*','d','0',0200,'*',0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,'&','d',0134,0200,'&',0,04,0220,'%','d','0',0200,'%',0,'0',0220,036,'d','0',0200,036,0,'0',0220,037,'d',0134,0200,037,0,04,0220,036,'d','4',0200,036,0,',',0220,036,'d',0134,0200,036,0,04,0220,'+','d',0134,0200,'+',0,04,0220,'+','Z','0',0200,'+',0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'d',0134,0200,037,0,04,0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'d',0134,0200,037,0,04,0220,037,'Z','0',0200,037,0,'0',0220,'+','d',0134,0200,'+',0,04,0220,'+','Z','0',0200,'+',0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'d',0134,0200,037,0,04,0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'d',0134,0200,037,0,04,0220,037,'Z','0',0200,037,0,'0',0220,036,'d',0134,0200,036,0,04,0220,'!','d',0134,0200,'!',0,'d',0220,'#','d',0134,0200,'#',0,0201,'D',0220,036,'d',0134,0200,036,0,04,0220,'#','d',0134,0200,'#',0,'d',0220,'%','d',0134,0200,'%',0,0201,'D',0220,036,'d',0134,0200,036,0,04,0220,'%','d',0134,0200,'%',0,'d',0220,'&','d',0134,0200,'&',0,'d',0220,036,'d',0134,0200,036,0,'d',0220,'%','d',0201,'<',0200,'%',0,04,0220,'#','d',0134,0200,'#',0,04,0220,'!','d',0134,0200,'!',0,04,0220,036,'d',0134,0200,036,0,04,0220,034,'n',0134,0200,034,0,04,0220,035,'d',0134,0200,035,0,04,0220,036,'d',0134,0200,036,0,04,0220,037,'n',0201,'<',0200,037,0,04,0220,'#','d',0134,0200,'#',0,04,0220,'!','d',0134,0200,'!',0,04,0220,037,'d',0134,0200,037,0,04,0220,'*','d',0134,0200,'*',0,04,0220,'*','d','0',0200,'*',0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,'*','d',0134,0200,'*',0,04,0220,'*','d','0',0200,'*',0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,'&','d',0134,0200,'&',0,04,0220,'%','d','0',0200,'%',0,'0',0220,036,'d','0',0200,036,0,'0',0220,037,'d',0134,0200,037,0,04,0220,037,'d','4',0200,037,0,',',0220,037,'d',0134,0200,037,0,04,0220,'*','d',0134,0200,'*',0,04,0220,'*','d','0',0200,'*',0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,'*','d',0134,0200,'*',0,04,0220,'*','d','0',0200,'*',0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,'&','d',0134,0200,'&',0,04,0220,'%','d','0',0200,'%',0,'0',0220,036,'d','0',0200,036,0,'0',0220,037,'d',0134,0200,037,0,04,0220,036,'d','4',0200,036,0,',',0220,036,'d',0134,0200,036,0,04,0220,'*','d',0134,0200,'*',0,04,0220,'*','d','0',0200,'*',0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,'*','d',0134,0200,'*',0,04,0220,'*','d','0',0200,'*',0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,'*','n',0134,0200,'*',0,04,0220,'*','d',0134,0200,'*',0,04,0220,'(','n',0134,0200,'(',0,04,0220,'(','d',0134,0200,'(',0,04,0220,'&','n',',',0200,'&',0,'4',0220,'&','d',0134,0200,'&',0,04,0220,'%','n','4',0200,'%',0,',',0220,'&','n',0134,0200,'&',0,04,0220,'*','d',0134,0200,'*',0,04,0220,'*','d','0',0200,'*',0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,'*','d',0134,0200,'*',0,04,0220,'*','d','0',0200,'*',0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,'&','d',0134,0200,'&',0,04,0220,'%','d','0',0200,'%',0,'0',0220,036,'d','0',0200,036,0,'0',0220,037,'d',0134,0200,037,0,04,0220,036,'d','4',0200,036,0,',',0220,036,'d',0134,0200,036,0,04,0220,'*','d',0134,0200,'*',0,04,0220,'*','Z','0',0200,'*',0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'Z','0',0200,036,0,'0',0220,'*','d',0134,0200,'*',0,04,0220,'*','Z','0',0200,'*',0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'Z','0',0200,036,0,',',0260,'u',0177,0202,'$',0220,036,'d',0,0260,'t',0,0134,0200,036,0,04,0220,'!','d',0134,0200,'!',0,'d',0220,'#','d',0134,0200,'#',0,0201,'D',0220,036,'d',0134,0200,036,0,04,0220,'#','d',0134,0200,'#',0,'d',0220,'%','d',0134,0200,'%',0,0201,'D',0220,036,'d',0134,0200,036,0,04,0220,'%','d',0134,0200,'%',0,'d',0220,'&','d',0134,0200,'&',0,'d',0220,036,'d',0134,0200,036,0,'d',0220,'%','d',0201,'<',0200,'%',0,04,0220,'#','d',0134,0200,'#',0,04,0220,'!','d',0134,0200,'!',0,04,0220,036,'d',0134,0200,036,0,04,0220,034,'n',0134,0200,034,0,04,0220,035,'d',0134,0200,035,0,04,0220,036,'d',0134,0200,036,0,04,0220,037,'n',0201,'<',0200,037,0,04,0220,'#','d',0134,0200,'#',0,04,0220,'!','d',0134,0200,'!',0,04,0220,037,'d',0134,0200,037,0,04,0220,036,'d',0134,0200,036,0,04,0220,'!','d',0134,0200,'!',0,'d',0220,'#','d',0134,0200,'#',0,0201,'D',0220,036,'d',0134,0200,036,0,04,0220,'#','d',0134,0200,'#',0,'d',0220,'%','d',0134,0200,'%',0,0201,'D',0220,036,'d',0134,0200,036,0,04,0220,'%','d',0134,0200,'%',0,'d',0220,'&','d',0134,0200,'&',0,'d',0220,036,'d',0134,0200,036,0,'d',0220,'%','d',0201,'<',0200,'%',0,04,0220,'#','d',0134,0200,'#',0,04,0220,'!','d',0134,0200,'!',0,04,0220,036,'d',0134,0200,036,0,04,0220,037,'n',0134,0200,037,0,04,0220,'!','n',0134,0200,'!',0,04,0220,'#','n',0134,0200,'#',0,04,0220,037,'n',0,0220,'&','n',0201,'<',0200,'&',0,04,0220,'#','d',0134,0200,'#',0,04,0220,'!','d',0134,0200,'!',0,04,0220,'#','d',',',0200,037,0,'0',0200,'#',0,04,0220,'*','d',0134,0200,'*',0,04,0220,'*','d','0',0200,'*',0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,'*','d',0134,0200,'*',0,04,0220,'*','d','0',0200,'*',0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,'&','d',0134,0200,'&',0,04,0220,'%','d','0',0200,'%',0,'0',0220,036,'d','0',0200,036,0,'0',0220,037,'d',0134,0200,037,0,04,0220,037,'d','4',0200,037,0,',',0220,037,'d',0134,0200,037,0,04,0220,'*','d',0134,0200,'*',0,04,0220,'*','d','0',0200,'*',0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,'*','d',0134,0200,'*',0,04,0220,'*','d','0',0200,'*',0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,'&','d',0134,0200,'&',0,04,0220,'%','d','0',0200,'%',0,'0',0220,036,'d','0',0200,036,0,'0',0220,037,'d',0134,0200,037,0,04,0220,036,'d','4',0200,036,0,',',0220,036,'d',0134,0200,036,0,04,0220,'+','d',0134,0200,'+',0,04,0220,'+','Z','0',0200,'+',0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'d',0134,0200,037,0,04,0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'d',0134,0200,037,0,04,0220,037,'Z','0',0200,037,0,'0',0220,'+','d',0134,0200,'+',0,04,0220,'+','Z','0',0200,'+',0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'d',0134,0200,037,0,04,0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'Z','0',0200,037,0,'0',0220,037,'d',0134,0200,037,0,04,0220,037,'Z','0',0200,037,0,'0',0220,036,'d',0134,0200,036,0,04,0220,'!','d',0134,0200,'!',0,'d',0220,'#','d',0134,0200,'#',0,0201,'D',0220,036,'d',0134,0200,036,0,04,0220,'#','d',0134,0200,'#',0,'d',0220,'%','d',0134,0200,'%',0,0201,'D',0220,036,'d',0134,0200,036,0,04,0220,'%','d',0134,0200,'%',0,'d',0220,'&','d',0134,0200,'&',0,'d',0220,036,'d',0134,0200,036,0,'d',0220,'%','d',0201,'<',0200,'%',0,04,0220,'#','d',0134,0200,'#',0,04,0220,'!','d',0134,0200,'!',0,04,0220,036,'d',0134,0200,036,0,04,0220,034,'n',0134,0200,034,0,04,0220,035,'d',0134,0200,035,0,04,0220,036,'d',0134,0200,036,0,04,0220,037,'n',0201,'<',0200,037,0,04,0220,'#','d',0134,0200,'#',0,04,0220,'!','d',0134,0200,'!',0,04,0220,037,'d',0134,0200,037,0,04,0220,'*','d',0134,0200,'*',0,04,0220,'*','d','0',0200,'*',0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,'*','d',0134,0200,'*',0,04,0220,'*','d','0',0200,'*',0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,'&','d',0134,0200,'&',0,04,0220,'%','d','0',0200,'%',0,'0',0220,036,'d','0',0200,036,0,'0',0220,037,'d',0134,0200,037,0,04,0220,037,'d','4',0200,037,0,',',0220,037,'d',0134,0200,037,0,04,0220,'*','d',0134,0200,'*',0,04,0220,'*','d','0',0200,'*',0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,'*','d',0134,0200,'*',0,04,0220,'*','d','0',0200,'*',0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,'&','d',0134,0200,'&',0,04,0220,'%','d','0',0200,'%',0,'0',0220,036,'d','0',0200,036,0,'0',0220,037,'d',0134,0200,037,0,04,0220,036,'d','4',0200,036,0,',',0220,036,'d',0134,0200,036,0,04,0220,'*','d',0134,0200,'*',0,04,0220,'*','d','0',0200,'*',0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,'*','d',0134,0200,'*',0,04,0220,'*','d','0',0200,'*',0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,'*','n',0134,0200,'*',0,04,0220,'*','d',0134,0200,'*',0,04,0220,'(','n',0134,0200,'(',0,04,0220,'(','d',0134,0200,'(',0,04,0220,'&','n',',',0200,'&',0,'4',0220,'&','d',0134,0200,'&',0,04,0220,'%','n','4',0200,'%',0,',',0220,'&','n',0134,0200,'&',0,04,0220,'*','d',0134,0200,'*',0,04,0220,'*','d','0',0200,'*',0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,'*','d',0134,0200,'*',0,04,0220,'*','d','0',0200,'*',0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,036,'d','0',0200,036,0,'0',0220,'&','d',0134,0200,'&',0,04,0220,'%','d','0',0200,'%',0,'0',0220,036,'d','0',0200,036,0,'0',0220,037,'d',0134,0200,037,0,04,0220,036,'d','4',0200,036,0,',',0220,036,'d',0134,0200,036,0,04,0220,'*','d',0134,0200,'*',0,04,0220,'*','Z','0',0200,'*',0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'Z','0',0200,036,0,'0',0220,'*','d',0134,0200,'*',0,04,0220,'*','Z','0',0200,'*',0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'Z','0',0200,036,0,'0',0220,036,'d',0134,0200,036,0,04,0220,036,'Z','0',0200,036,0,',',0260,'u',0177,0,0377,'/',0,'M','T','r','k',0,0,034,0370,0,0377,03,030,'S','e','q','u','e','n','c','e','d',' ','b','y',' ','T','h','e',' ','B','a','r','r','i','e','r',0,0261,0,0,0,0301,036,0,0261,012,'5',0,0261,'[',05,0,0261,']',0,0,0377,'Y',02,0,0,0,0261,07,'n',0,0261,'n',0177,030,0261,'d',0,0,0261,'e',0,034,0261,06,02,0,0261,'&',0,034,0261,'d',0177,0,0261,'e',0177,'P',0341,0,'@',030,0261,01,0,0201,'H',0261,'t',0,0230,0,0221,'1','d',0,0221,'*','d',0134,0201,'1',0,0,0201,'*',0,04,0221,'4','d',0,0221,'-','d',0134,0201,'4',0,0,0201,'-',0,'d',0221,'6','d',0,0221,'/','d',0134,0201,'6',0,0,0201,'/',0,0201,'D',0221,'1','d',0,0221,'*','d',0134,0201,'1',0,0,0201,'*',0,04,0221,'6','d',0,0221,'/','d',0134,0201,'6',0,0,0201,'/',0,'d',0221,'8','d',0,0221,'1','d',0134,0201,'8',0,0,0201,'1',0,0201,'D',0221,'1','d',0,0221,'*','d',0134,0201,'1',0,0,0201,'*',0,04,0221,'1','d',0,0221,'8','d',0134,0201,'1',0,0,0201,'8',0,'d',0221,'9','d',0,0221,'2','d',0134,0201,'9',0,0,0201,'2',0,'d',0221,'*','d',0,0221,'1','d',0134,0201,'*',0,0,0201,'1',0,'d',0221,'9','d',0,0221,'1','d',0201,'<',0201,'9',0,0,0201,'1',0,04,0221,'8','d',0,0221,'/','d',0134,0201,'8',0,0,0201,'/',0,04,0221,'6','d',0,0221,'-','d',0134,0201,'6',0,0,0201,'-',0,04,0221,'1','d',0,0221,'*','d',0134,0201,'1',0,0,0201,'*',0,04,0221,'9','d',0,0221,'4','d',0,0221,'/','d',0202,034,0201,'9',0,0,0201,'4',0,0,0201,'/',0,04,0221,';','d',0,0221,'2','d',0,0221,'-','d',0201,'<',0201,'-',0,04,0221,'/','d',0134,0201,';',0,0,0201,'2',0,0,0201,'/',0,04,0221,'>','d',0,0221,'4','d',0,0221,'-','d',0134,0201,'-',0,04,0221,'/','d',0134,0201,'>',0,0,0201,'4',0,0,0201,'/',0,04,0221,'=','d',0134,0201,'=',0,04,0221,'=','d',0134,0201,'=',0,'d',0221,'6','d',0,0221,'=','d',0202,034,0201,'=',0,04,0221,'=','d',0134,0201,'=',0,04,0221,'=','d',0134,0201,'6',0,0,0201,'=',0,'d',0221,'6','d',0,0221,'>','d',0202,034,0201,'6',0,0,0201,'>',0,04,0221,';','d',0,0221,'6','d',0134,0201,';',0,0,0201,'6',0,04,0221,'6','d',0,0221,';','d',0134,0201,'6',0,0,0201,';',0,'d',0221,';','d',0,0221,'4','d','`',0221,'4','@',0,0221,';','@',0201,'<',0201,';','@',0,0201,'4','@',0,0201,'4',0,0,0201,';',0,04,0221,'4','d',0,0221,';','d',0134,0201,'4',0,0,0201,';',0,04,0221,'4','d',0,0221,';','d',0134,0201,'4',0,0,0201,';',0,'d',0221,';','d',0,0221,'4','d',0134,0201,';',0,0,0201,'4',0,'d',0221,'4','d',0,0221,';','d',0201,'<',0201,'4',0,0,0201,';',0,04,0221,'2','d',0,0221,'9','d',0201,'<',0201,'2',0,0,0201,'9',0,04,0221,'2','d',0,0221,'7','d',0201,'<',0201,'2',0,0,0201,'7',0,04,0221,'2','d',0,0221,'9','d',0201,'<',0201,'2',0,0,0201,'9',0,04,0221,'1','d',0,0221,'6','d','`',0221,'1','@',0,0221,'6','@',0201,'<',0201,'1','@',0,0201,'6','@',0,0201,'1',0,0,0201,'6',0,04,0221,'=','d',0,0221,'6','d',0134,0201,'=',0,0,0201,'6',0,04,0221,'6','d',0,0221,'=','d',0134,0201,'6',0,0,0201,'=',0,'d',0221,'6','d',0,0221,'=','d',0134,0201,'6',0,0,0201,'=',0,'d',0221,'6','d',0,0221,'>','d',0201,'<',0201,'6',0,0,0201,'>',0,04,0221,'6','d',0,0221,'=','d',0201,'<',0201,'6',0,0,0201,'=',0,04,0221,'4','d',0,0221,';','d',0201,'<',0201,'4',0,0,0201,';',0,04,0221,'=','d',0,0221,'6','d',0202,034,0201,'=',0,0,0201,'6',0,04,0221,'2','d',0,0221,'9','d',0134,0201,'2',0,0,0201,'9',0,04,0221,'/','d',0,0221,'6','d',0134,0201,'/',0,0,0201,'6',0,'d',0221,'2','d',0,0221,'9','d',0134,0201,'2',0,0,0201,'9',0,'d',0221,'6','d',0,0221,';','d',0134,0201,'6',0,0,0201,';',0,'d',0221,'4','d',0,0221,'8','d',0201,'<',0201,'4',0,0,0201,'8',0,04,0221,'/','d',0,0221,'4','d',0134,0201,'/',0,0,0201,'4',0,'d',0221,'1','d',0,0221,'8','d',0134,0201,'1',0,0,0201,'8',0,'d',0221,'1','d',0,0221,'9','d',0202,034,0201,'1',0,0,0201,'9',0,04,0221,'+','f',0,0221,'2','f',04,0221,'6','f','X',0201,'+',0,04,0201,'2',0,0,0201,'6',0,0,0221,'+','^',0,0221,'2','^',04,0221,'6','^','X',0201,'+',0,04,0201,'2',0,0,0201,'6',0,'`',0221,'+','f',0,0221,'2','f',04,0221,'6','f','X',0201,'+',0,04,0201,'2',0,0,0201,'6',0,0201,'@',0221,'+','f',0,0221,'2','f',04,0221,'6','f','X',0201,'+',0,04,0201,'2',0,0,0201,'6',0,0,0221,'+','^',0,0221,'2','^',04,0221,'6','^','X',0201,'+',0,04,0201,'2',0,0,0201,'6',0,'`',0221,'+','f',0,0221,'2','f',04,0221,'6','f','X',0201,'+',0,04,0201,'2',0,0,0201,'6',0,0204,'@',0221,'+','f',0,0221,'2','f',04,0221,'6','f','X',0201,'+',0,04,0201,'2',0,0,0201,'6',0,0,0221,'+','^',0,0221,'2','^',04,0221,'6','^','X',0201,'+',0,04,0201,'2',0,0,0201,'6',0,'`',0221,'+','f',0,0221,'2','f',04,0221,'6','f','X',0201,'+',0,04,0201,'2',0,0,0201,'6',0,0201,'@',0221,'+','f',0,0221,'2','f',04,0221,'6','f','X',0201,'+',0,04,0201,'2',0,0,0201,'6',0,0,0221,'+','^',0,0221,'2','^',04,0221,'6','^','X',0201,'+',0,04,0201,'2',0,0,0201,'6',0,'`',0221,'+','f',0,0221,'2','f',04,0221,'6','f','X',0201,'+',0,04,0201,'2',0,0,0201,'6',0,0234,'@',0221,'=','d',0134,0201,'=',0,04,0221,'=','d',0134,0201,'=',0,'d',0221,'6','d',0,0221,'=','d',0202,034,0201,'=',0,04,0221,'=','d',0134,0201,'=',0,04,0221,'=','d',0134,0201,'6',0,0,0201,'=',0,'d',0221,'6','d',0,0221,'>','d',0202,034,0201,'6',0,0,0201,'>',0,04,0221,';','d',0,0221,'6','d',0134,0201,';',0,0,0201,'6',0,04,0221,'6','d',0,0221,';','d',0134,0201,'6',0,0,0201,';',0,'d',0221,';','d',0,0221,'4','d','`',0221,'4','@',0,0221,';','@',0201,'<',0201,';','@',0,0201,'4','@',0,0201,'4',0,0,0201,';',0,04,0221,'4','d',0,0221,';','d',0134,0201,'4',0,0,0201,';',0,04,0221,'4','d',0,0221,';','d',0134,0201,'4',0,0,0201,';',0,'d',0221,';','d',0,0221,'4','d',0134,0201,';',0,0,0201,'4',0,'d',0221,'4','d',0,0221,';','d',0201,'<',0201,'4',0,0,0201,';',0,04,0221,'2','d',0,0221,'9','d',0201,'<',0201,'2',0,0,0201,'9',0,04,0221,'2','d',0,0221,'7','d',0201,'<',0201,'2',0,0,0201,'7',0,04,0221,'2','d',0,0221,'9','d',0201,'<',0201,'2',0,0,0201,'9',0,04,0221,'1','d',0,0221,'6','d','`',0221,'1','@',0,0221,'6','@',0201,'<',0201,'1','@',0,0201,'6','@',0,0201,'1',0,0,0201,'6',0,04,0221,'=','d',0,0221,'6','d',0134,0201,'=',0,0,0201,'6',0,04,0221,'6','d',0,0221,'=','d',0134,0201,'6',0,0,0201,'=',0,'d',0221,'6','d',0,0221,'=','d',0134,0201,'6',0,0,0201,'=',0,'d',0221,'6','d',0,0221,'>','d',0201,'<',0201,'6',0,0,0201,'>',0,04,0221,'6','d',0,0221,'=','d',0201,'<',0201,'6',0,0,0201,'=',0,04,0221,'4','d',0,0221,';','d',0201,'<',0201,'4',0,0,0201,';',0,04,0221,'=','d',0,0221,'6','d',0202,034,0201,'=',0,0,0201,'6',0,04,0221,'2','d',0,0221,'9','d',0134,0201,'2',0,0,0201,'9',0,04,0221,'/','d',0,0221,'6','d',0134,0201,'/',0,0,0201,'6',0,'d',0221,'2','d',0,0221,'9','d',0134,0201,'2',0,0,0201,'9',0,'d',0221,'6','d',0,0221,';','d',0134,0201,'6',0,0,0201,';',0,'d',0221,'4','d',0,0221,'8','d',0201,'<',0201,'4',0,0,0201,'8',0,04,0221,'/','d',0,0221,'4','d',0134,0201,'/',0,0,0201,'4',0,'d',0221,'1','d',0,0221,'8','d',0134,0201,'1',0,0,0201,'8',0,'d',0221,'1','d',0,0221,'9','d',0202,034,0201,'1',0,0,0201,'9',0,04,0221,'2','d',0,0221,'9','d','X',0221,'2','d',04,0201,'2',0,0,0201,'9',0,04,0221,'9','d','X',0201,'2',0,04,0201,'9',0,'d',0221,'2','n',0,0221,'9','n',0202,020,0221,'2','d',014,0201,'9',0,04,0221,'9','d','L',0201,'2',0,04,0221,'2','d',014,0201,'9',0,04,0221,'9','d','L',0201,'2',0,020,0201,'2',0,0,0201,'9',0,'d',0221,'4','n',0,0221,';','n',0202,034,0201,'4',0,0,0201,';',0,04,0221,'2','d',0,0221,';','d',0134,0201,'2',0,0,0201,';',0,04,0221,'2','d',0,0221,';','d',0134,0201,'2',0,0,0201,';',0,'d',0221,';','n',0,0221,'4','n','`',0221,'4','@',0,0221,';','@',0201,'<',0201,';','@',0,0201,'4','@',0,0201,'4',0,0,0201,';',0,04,0221,'4','d',0,0221,';','d',0134,0201,'4',0,0,0201,';',0,04,0221,'4','d',0,0221,';','d',0134,0201,'4',0,0,0201,';',0,'d',0221,';','d',0,0221,'4','d',0134,0201,';',0,0,0201,'4',0,'d',0221,'6','f',0,0221,'=','f',0201,'<',0201,'6',0,0,0201,'=',0,04,0221,'4','h',0,0221,';','h',0201,'<',0201,'4',0,0,0201,';',0,04,0221,'2','j',0,0221,'9','j',0201,'<',0201,'2',0,0,0201,'9',0,04,0221,'8','l',0,0221,'1','l',0201,'<',0201,'8',0,0,0201,'1',0,04,0221,'2','n',0,0221,'9','n','`',0221,'2','@',0,0221,'9','@',0201,'<',0201,'2','@',0,0201,'9','@',0,0201,'2',0,0,0201,'9',0,04,0221,'2','d',0,0221,'=','d',0134,0201,'2',0,0,0201,'=',0,04,0221,'=','d',0,0221,'2','d',0134,0201,'=',0,0,0201,'2',0,'d',0221,';','d',0,0221,'2','d',0134,0201,';',0,0,0201,'2',0,'d',0221,'9','d',0,0221,'4','d',0201,'<',0201,'9',0,0,0201,'4',0,04,0221,'8','d',0,0221,'4','d',0201,'<',0201,'8',0,0,0201,'4',0,04,0221,'4','d',0,0221,'9','d',0201,'<',0201,'4',0,0,0201,'9',0,04,0221,'8','l',0,0221,'4','l',0134,0201,'8',0,04,0221,'6','l',0134,0201,'6',0,04,0221,'8','l',0134,0201,'4',0,0,0201,'8',0,04,0221,'6','d',0,0221,'9','d',0134,0201,'6',0,0,0201,'9',0,04,0221,'2','d',0,0221,'6','d',0134,0201,'2',0,0,0201,'6',0,'d',0221,'2','d',0,0221,'9','d',0134,0201,'2',0,0,0201,'9',0,'d',0221,'6','d',0,0221,';','d',0134,0201,'6',0,0,0201,';',0,'d',0221,'4','d',0,0221,'8','d',0201,'<',0201,'4',0,0,0201,'8',0,04,0221,'/','d',0,0221,'4','d',0134,0201,'/',0,0,0201,'4',0,'d',0221,'1','d',0,0221,'8','d',0134,0201,'1',0,0,0201,'8',0,'d',0221,'1','d',0,0221,'9','d',0202,034,0201,'1',0,0,0201,'9',0,04,0221,'*','f',04,0221,'6','f','X',0201,'*',0,04,0201,'6',0,0,0221,'*','^',04,0221,'6','^','X',0201,'*',0,04,0201,'6',0,'`',0221,'*','f',04,0221,'6','f','X',0201,'*',0,04,0201,'6',0,0201,'@',0221,'*','f',04,0221,'6','f','X',0201,'*',0,04,0201,'6',0,0,0221,'*','^',04,0221,'6','^','X',0201,'*',0,04,0201,'6',0,'`',0221,'*','f',04,0221,'6','f','X',0201,'*',0,04,0201,'6',0,0204,'@',0221,'*','f',04,0221,'6','f','X',0201,'*',0,04,0201,'6',0,0,0221,'*','^',04,0221,'6','^','X',0201,'*',0,04,0201,'6',0,'`',0221,'*','f',04,0221,'6','f','X',0201,'*',0,04,0201,'6',0,0201,'@',0221,'*','f',04,0221,'6','f','X',0201,'*',0,04,0201,'6',0,0,0221,'*','^',04,0221,'6','^','X',0201,'*',0,04,0201,'6',0,'`',0221,'*','f',04,0221,'6','f','X',0201,'*',0,04,0201,'6',0,0204,'<',0261,'u',0177,'d',0261,'t',0,0230,0,0221,'1','d',0,0221,'*','d',0134,0201,'1',0,0,0201,'*',0,04,0221,'4','d',0,0221,'-','d',0134,0201,'4',0,0,0201,'-',0,'d',0221,'6','d',0,0221,'/','d',0134,0201,'6',0,0,0201,'/',0,0201,'D',0221,'1','d',0,0221,'*','d',0134,0201,'1',0,0,0201,'*',0,04,0221,'6','d',0,0221,'/','d',0134,0201,'6',0,0,0201,'/',0,'d',0221,'8','d',0,0221,'1','d',0134,0201,'8',0,0,0201,'1',0,0201,'D',0221,'1','d',0,0221,'*','d',0134,0201,'1',0,0,0201,'*',0,04,0221,'1','d',0,0221,'8','d',0134,0201,'1',0,0,0201,'8',0,'d',0221,'9','d',0,0221,'2','d',0134,0201,'9',0,0,0201,'2',0,'d',0221,'*','d',0,0221,'1','d',0134,0201,'*',0,0,0201,'1',0,'d',0221,'9','d',0,0221,'1','d',0201,'<',0201,'9',0,0,0201,'1',0,04,0221,'8','d',0,0221,'/','d',0134,0201,'8',0,0,0201,'/',0,04,0221,'6','d',0,0221,'-','d',0134,0201,'6',0,0,0201,'-',0,04,0221,'1','d',0,0221,'*','d',0134,0201,'1',0,0,0201,'*',0,04,0221,'9','d',0,0221,'4','d',0,0221,'/','d',0202,034,0201,'9',0,0,0201,'4',0,0,0201,'/',0,04,0221,';','d',0,0221,'2','d',0,0221,'-','d',0201,'<',0201,'-',0,04,0221,'/','d',0134,0201,';',0,0,0201,'2',0,0,0201,'/',0,04,0221,'>','d',0,0221,'4','d',0,0221,'-','d',0134,0201,'-',0,04,0221,'/','d',0134,0201,'>',0,0,0201,'4',0,0,0201,'/',0,04,0221,'=','d',0134,0201,'=',0,04,0221,'=','d',0134,0201,'=',0,'d',0221,'6','d',0,0221,'=','d',0202,034,0201,'=',0,04,0221,'=','d',0134,0201,'=',0,04,0221,'=','d',0134,0201,'6',0,0,0201,'=',0,'d',0221,'6','d',0,0221,'>','d',0202,034,0201,'6',0,0,0201,'>',0,04,0221,';','d',0,0221,'6','d',0134,0201,';',0,0,0201,'6',0,04,0221,'6','d',0,0221,';','d',0134,0201,'6',0,0,0201,';',0,'d',0221,';','d',0,0221,'4','d','`',0221,'4','@',0,0221,';','@',0201,'<',0201,';','@',0,0201,'4','@',0,0201,'4',0,0,0201,';',0,04,0221,'4','d',0,0221,';','d',0134,0201,'4',0,0,0201,';',0,04,0221,'4','d',0,0221,';','d',0134,0201,'4',0,0,0201,';',0,'d',0221,';','d',0,0221,'4','d',0134,0201,';',0,0,0201,'4',0,'d',0221,'4','d',0,0221,';','d',0201,'<',0201,'4',0,0,0201,';',0,04,0221,'2','d',0,0221,'9','d',0201,'<',0201,'2',0,0,0201,'9',0,04,0221,'2','d',0,0221,'7','d',0201,'<',0201,'2',0,0,0201,'7',0,04,0221,'2','d',0,0221,'9','d',0201,'<',0201,'2',0,0,0201,'9',0,04,0221,'1','d',0,0221,'6','d','`',0221,'1','@',0,0221,'6','@',0201,'<',0201,'1','@',0,0201,'6','@',0,0201,'1',0,0,0201,'6',0,04,0221,'=','d',0,0221,'6','d',0134,0201,'=',0,0,0201,'6',0,04,0221,'6','d',0,0221,'=','d',0134,0201,'6',0,0,0201,'=',0,'d',0221,'6','d',0,0221,'=','d',0134,0201,'6',0,0,0201,'=',0,'d',0221,'6','d',0,0221,'>','d',0201,'<',0201,'6',0,0,0201,'>',0,04,0221,'6','d',0,0221,'=','d',0201,'<',0201,'6',0,0,0201,'=',0,04,0221,'4','d',0,0221,';','d',0201,'<',0201,'4',0,0,0201,';',0,04,0221,'=','d',0,0221,'6','d',0202,034,0201,'=',0,0,0201,'6',0,04,0221,'2','d',0,0221,'9','d',0134,0201,'2',0,0,0201,'9',0,04,0221,'/','d',0,0221,'6','d',0134,0201,'/',0,0,0201,'6',0,'d',0221,'2','d',0,0221,'9','d',0134,0201,'2',0,0,0201,'9',0,'d',0221,'6','d',0,0221,';','d',0134,0201,'6',0,0,0201,';',0,'d',0221,'4','d',0,0221,'8','d',0201,'<',0201,'4',0,0,0201,'8',0,04,0221,'/','d',0,0221,'4','d',0134,0201,'/',0,0,0201,'4',0,'d',0221,'1','d',0,0221,'8','d',0134,0201,'1',0,0,0201,'8',0,'d',0221,'1','d',0,0221,'9','d',0202,034,0201,'1',0,0,0201,'9',0,04,0221,'+','f',0,0221,'2','f',04,0221,'6','f','X',0201,'+',0,04,0201,'2',0,0,0201,'6',0,0,0221,'+','^',0,0221,'2','^',04,0221,'6','^','X',0201,'+',0,04,0201,'2',0,0,0201,'6',0,'`',0221,'+','f',0,0221,'2','f',04,0221,'6','f','X',0201,'+',0,04,0201,'2',0,0,0201,'6',0,0201,'@',0221,'+','f',0,0221,'2','f',04,0221,'6','f','X',0201,'+',0,04,0201,'2',0,0,0201,'6',0,0,0221,'+','^',0,0221,'2','^',04,0221,'6','^','X',0201,'+',0,04,0201,'2',0,0,0201,'6',0,'`',0221,'+','f',0,0221,'2','f',04,0221,'6','f','X',0201,'+',0,04,0201,'2',0,0,0201,'6',0,0204,'@',0221,'+','f',0,0221,'2','f',04,0221,'6','f','X',0201,'+',0,04,0201,'2',0,0,0201,'6',0,0,0221,'+','^',0,0221,'2','^',04,0221,'6','^','X',0201,'+',0,04,0201,'2',0,0,0201,'6',0,'`',0221,'+','f',0,0221,'2','f',04,0221,'6','f','X',0201,'+',0,04,0201,'2',0,0,0201,'6',0,0201,'@',0221,'+','f',0,0221,'2','f',04,0221,'6','f','X',0201,'+',0,04,0201,'2',0,0,0201,'6',0,0,0221,'+','^',0,0221,'2','^',04,0221,'6','^','X',0201,'+',0,04,0201,'2',0,0,0201,'6',0,'`',0221,'+','f',0,0221,'2','f',04,0221,'6','f','X',0201,'+',0,04,0201,'2',0,0,0201,'6',0,0234,'@',0221,'=','d',0134,0201,'=',0,04,0221,'=','d',0134,0201,'=',0,'d',0221,'6','d',0,0221,'=','d',0202,034,0201,'=',0,04,0221,'=','d',0134,0201,'=',0,04,0221,'=','d',0134,0201,'6',0,0,0201,'=',0,'d',0221,'6','d',0,0221,'>','d',0202,034,0201,'6',0,0,0201,'>',0,04,0221,';','d',0,0221,'6','d',0134,0201,';',0,0,0201,'6',0,04,0221,'6','d',0,0221,';','d',0134,0201,'6',0,0,0201,';',0,'d',0221,';','d',0,0221,'4','d','`',0221,'4','@',0,0221,';','@',0201,'<',0201,';','@',0,0201,'4','@',0,0201,'4',0,0,0201,';',0,04,0221,'4','d',0,0221,';','d',0134,0201,'4',0,0,0201,';',0,04,0221,'4','d',0,0221,';','d',0134,0201,'4',0,0,0201,';',0,'d',0221,';','d',0,0221,'4','d',0134,0201,';',0,0,0201,'4',0,'d',0221,'4','d',0,0221,';','d',0201,'<',0201,'4',0,0,0201,';',0,04,0221,'2','d',0,0221,'9','d',0201,'<',0201,'2',0,0,0201,'9',0,04,0221,'2','d',0,0221,'7','d',0201,'<',0201,'2',0,0,0201,'7',0,04,0221,'2','d',0,0221,'9','d',0201,'<',0201,'2',0,0,0201,'9',0,04,0221,'1','d',0,0221,'6','d','`',0221,'1','@',0,0221,'6','@',0201,'<',0201,'1','@',0,0201,'6','@',0,0201,'1',0,0,0201,'6',0,04,0221,'=','d',0,0221,'6','d',0134,0201,'=',0,0,0201,'6',0,04,0221,'6','d',0,0221,'=','d',0134,0201,'6',0,0,0201,'=',0,'d',0221,'6','d',0,0221,'=','d',0134,0201,'6',0,0,0201,'=',0,'d',0221,'6','d',0,0221,'>','d',0201,'<',0201,'6',0,0,0201,'>',0,04,0221,'6','d',0,0221,'=','d',0201,'<',0201,'6',0,0,0201,'=',0,04,0221,'4','d',0,0221,';','d',0201,'<',0201,'4',0,0,0201,';',0,04,0221,'=','d',0,0221,'6','d',0202,034,0201,'=',0,0,0201,'6',0,04,0221,'2','d',0,0221,'9','d',0134,0201,'2',0,0,0201,'9',0,04,0221,'/','d',0,0221,'6','d',0134,0201,'/',0,0,0201,'6',0,'d',0221,'2','d',0,0221,'9','d',0134,0201,'2',0,0,0201,'9',0,'d',0221,'6','d',0,0221,';','d',0134,0201,'6',0,0,0201,';',0,'d',0221,'4','d',0,0221,'8','d',0201,'<',0201,'4',0,0,0201,'8',0,04,0221,'/','d',0,0221,'4','d',0134,0201,'/',0,0,0201,'4',0,'d',0221,'1','d',0,0221,'8','d',0134,0201,'1',0,0,0201,'8',0,'d',0221,'1','d',0,0221,'9','d',0202,034,0201,'1',0,0,0201,'9',0,04,0221,'2','d',0,0221,'9','d','X',0221,'2','d',04,0201,'2',0,0,0201,'9',0,04,0221,'9','d','X',0201,'2',0,04,0201,'9',0,'d',0221,'2','n',0,0221,'9','n',0202,020,0221,'2','d',014,0201,'9',0,04,0221,'9','d','L',0201,'2',0,04,0221,'2','d',014,0201,'9',0,04,0221,'9','d','L',0201,'2',0,020,0201,'2',0,0,0201,'9',0,'d',0221,'4','n',0,0221,';','n',0202,034,0201,'4',0,0,0201,';',0,04,0221,'2','d',0,0221,';','d',0134,0201,'2',0,0,0201,';',0,04,0221,'2','d',0,0221,';','d',0134,0201,'2',0,0,0201,';',0,'d',0221,';','n',0,0221,'4','n','`',0221,'4','@',0,0221,';','@',0201,'<',0201,';','@',0,0201,'4','@',0,0201,'4',0,0,0201,';',0,04,0221,'4','d',0,0221,';','d',0134,0201,'4',0,0,0201,';',0,04,0221,'4','d',0,0221,';','d',0134,0201,'4',0,0,0201,';',0,'d',0221,';','d',0,0221,'4','d',0134,0201,';',0,0,0201,'4',0,'d',0221,'6','f',0,0221,'=','f',0201,'<',0201,'6',0,0,0201,'=',0,04,0221,'4','h',0,0221,';','h',0201,'<',0201,'4',0,0,0201,';',0,04,0221,'2','j',0,0221,'9','j',0201,'<',0201,'2',0,0,0201,'9',0,04,0221,'8','l',0,0221,'1','l',0201,'<',0201,'8',0,0,0201,'1',0,04,0221,'2','n',0,0221,'9','n','`',0221,'2','@',0,0221,'9','@',0201,'<',0201,'2','@',0,0201,'9','@',0,0201,'2',0,0,0201,'9',0,04,0221,'2','d',0,0221,'=','d',0134,0201,'2',0,0,0201,'=',0,04,0221,'=','d',0,0221,'2','d',0134,0201,'=',0,0,0201,'2',0,'d',0221,';','d',0,0221,'2','d',0134,0201,';',0,0,0201,'2',0,'d',0221,'9','d',0,0221,'4','d',0201,'<',0201,'9',0,0,0201,'4',0,04,0221,'8','d',0,0221,'4','d',0201,'<',0201,'8',0,0,0201,'4',0,04,0221,'4','d',0,0221,'9','d',0201,'<',0201,'4',0,0,0201,'9',0,04,0221,'8','l',0,0221,'4','l',0134,0201,'8',0,04,0221,'6','l',0134,0201,'6',0,04,0221,'8','l',0134,0201,'4',0,0,0201,'8',0,04,0221,'6','d',0,0221,'9','d',0134,0201,'6',0,0,0201,'9',0,04,0221,'2','d',0,0221,'6','d',0134,0201,'2',0,0,0201,'6',0,'d',0221,'2','d',0,0221,'9','d',0134,0201,'2',0,0,0201,'9',0,'d',0221,'6','d',0,0221,';','d',0134,0201,'6',0,0,0201,';',0,'d',0221,'4','d',0,0221,'8','d',0201,'<',0201,'4',0,0,0201,'8',0,04,0221,'/','d',0,0221,'4','d',0134,0201,'/',0,0,0201,'4',0,'d',0221,'1','d',0,0221,'8','d',0134,0201,'1',0,0,0201,'8',0,'d',0221,'1','d',0,0221,'9','d',0202,034,0201,'1',0,0,0201,'9',0,04,0221,'*','f',04,0221,'6','f','X',0201,'*',0,04,0201,'6',0,0,0221,'*','^',04,0221,'6','^','X',0201,'*',0,04,0201,'6',0,'`',0221,'*','f',04,0221,'6','f','X',0201,'*',0,04,0201,'6',0,0201,'@',0221,'*','f',04,0221,'6','f','X',0201,'*',0,04,0201,'6',0,0,0221,'*','^',04,0221,'6','^','X',0201,'*',0,04,0201,'6',0,'`',0221,'*','f',04,0221,'6','f','X',0201,'*',0,04,0201,'6',0,0204,'@',0221,'*','f',04,0221,'6','f','X',0201,'*',0,04,0201,'6',0,0,0221,'*','^',04,0221,'6','^','X',0201,'*',0,04,0201,'6',0,'`',0221,'*','f',04,0221,'6','f','X',0201,'*',0,04,0201,'6',0,0201,'@',0221,'*','f',04,0221,'6','f','X',0201,'*',0,04,0201,'6',0,0,0221,'*','^',04,0221,'6','^','X',0201,'*',0,04,0201,'6',0,'`',0221,'*','f',04,0221,'6','f','X',0201,'*',0,04,0201,'6',0,0204,'<',0261,'u',0177,0202,'$',0261,'t',0,0230,0,0221,'1','d',0,0221,'*','d',0134,0201,'1',0,0,0201,'*',0,04,0221,'4','d',0,0221,'-','d',0134,0201,'4',0,0,0201,'-',0,'d',0221,'6','d',0,0221,'/','d',0134,0201,'6',0,0,0201,'/',0,0201,'D',0221,'1','d',0,0221,'*','d',0134,0201,'1',0,0,0201,'*',0,04,0221,'6','d',0,0221,'/','d',0134,0201,'6',0,0,0201,'/',0,'d',0221,'8','d',0,0221,'1','d',0134,0201,'8',0,0,0201,'1',0,0201,'D',0221,'1','d',0,0221,'*','d',0134,0201,'1',0,0,0201,'*',0,04,0221,'1','d',0,0221,'8','d',0134,0201,'1',0,0,0201,'8',0,'d',0221,'9','d',0,0221,'2','d',0134,0201,'9',0,0,0201,'2',0,'d',0221,'*','d',0,0221,'1','d',0134,0201,'*',0,0,0201,'1',0,'d',0221,'9','d',0,0221,'1','d',0201,'<',0201,'9',0,0,0201,'1',0,04,0221,'8','d',0,0221,'/','d',0134,0201,'8',0,0,0201,'/',0,04,0221,'6','d',0,0221,'-','d',0134,0201,'6',0,0,0201,'-',0,04,0221,'1','d',0,0221,'*','d',0134,0201,'1',0,0,0201,'*',0,04,0221,'9','d',0,0221,'4','d',0,0221,'/','d',0202,034,0201,'9',0,0,0201,'4',0,0,0201,'/',0,04,0221,';','d',0,0221,'2','d',0,0221,'-','d',0201,'<',0201,'-',0,04,0221,'/','d',0134,0201,';',0,0,0201,'2',0,0,0201,'/',0,04,0221,'>','d',0,0221,'4','d',0,0221,'-','d',0134,0201,'-',0,04,0221,'/','d',0134,0201,'>',0,0,0201,'4',0,0,0201,'/',0,04,0221,'=','d',0134,0201,'=',0,04,0221,'=','d',0134,0201,'=',0,'d',0221,'6','d',0,0221,'=','d',0202,034,0201,'=',0,04,0221,'=','d',0134,0201,'=',0,04,0221,'=','d',0134,0201,'6',0,0,0201,'=',0,'d',0221,'6','d',0,0221,'>','d',0202,034,0201,'6',0,0,0201,'>',0,04,0221,';','d',0,0221,'6','d',0134,0201,';',0,0,0201,'6',0,04,0221,'6','d',0,0221,';','d',0134,0201,'6',0,0,0201,';',0,'d',0221,';','d',0,0221,'4','d','`',0221,'4','@',0,0221,';','@',0201,'<',0201,';','@',0,0201,'4','@',0,0201,'4',0,0,0201,';',0,04,0221,'4','d',0,0221,';','d',0134,0201,'4',0,0,0201,';',0,04,0221,'4','d',0,0221,';','d',0134,0201,'4',0,0,0201,';',0,'d',0221,';','d',0,0221,'4','d',0134,0201,';',0,0,0201,'4',0,'d',0221,'4','d',0,0221,';','d',0201,'<',0201,'4',0,0,0201,';',0,04,0221,'2','d',0,0221,'9','d',0201,'<',0201,'2',0,0,0201,'9',0,04,0221,'2','d',0,0221,'7','d',0201,'<',0201,'2',0,0,0201,'7',0,04,0221,'2','d',0,0221,'9','d',0201,'<',0201,'2',0,0,0201,'9',0,04,0221,'1','d',0,0221,'6','d','`',0221,'1','@',0,0221,'6','@',0201,'<',0201,'1','@',0,0201,'6','@',0,0201,'1',0,0,0201,'6',0,04,0221,'=','d',0,0221,'6','d',0134,0201,'=',0,0,0201,'6',0,04,0221,'6','d',0,0221,'=','d',0134,0201,'6',0,0,0201,'=',0,'d',0221,'6','d',0,0221,'=','d',0134,0201,'6',0,0,0201,'=',0,'d',0221,'6','d',0,0221,'>','d',0201,'<',0201,'6',0,0,0201,'>',0,04,0221,'6','d',0,0221,'=','d',0201,'<',0201,'6',0,0,0201,'=',0,04,0221,'4','d',0,0221,';','d',0201,'<',0201,'4',0,0,0201,';',0,04,0221,'=','d',0,0221,'6','d',0202,034,0201,'=',0,0,0201,'6',0,04,0221,'2','d',0,0221,'9','d',0134,0201,'2',0,0,0201,'9',0,04,0221,'/','d',0,0221,'6','d',0134,0201,'/',0,0,0201,'6',0,'d',0221,'2','d',0,0221,'9','d',0134,0201,'2',0,0,0201,'9',0,'d',0221,'6','d',0,0221,';','d',0134,0201,'6',0,0,0201,';',0,'d',0221,'4','d',0,0221,'8','d',0201,'<',0201,'4',0,0,0201,'8',0,04,0221,'/','d',0,0221,'4','d',0134,0201,'/',0,0,0201,'4',0,'d',0221,'1','d',0,0221,'8','d',0134,0201,'1',0,0,0201,'8',0,'d',0221,'1','d',0,0221,'9','d',0202,034,0201,'1',0,0,0201,'9',0,04,0221,'+','f',0,0221,'2','f',04,0221,'6','f','X',0201,'+',0,04,0201,'2',0,0,0201,'6',0,0,0221,'+','^',0,0221,'2','^',04,0221,'6','^','X',0201,'+',0,04,0201,'2',0,0,0201,'6',0,'`',0221,'+','f',0,0221,'2','f',04,0221,'6','f','X',0201,'+',0,04,0201,'2',0,0,0201,'6',0,0201,'@',0221,'+','f',0,0221,'2','f',04,0221,'6','f','X',0201,'+',0,04,0201,'2',0,0,0201,'6',0,0,0221,'+','^',0,0221,'2','^',04,0221,'6','^','X',0201,'+',0,04,0201,'2',0,0,0201,'6',0,'`',0221,'+','f',0,0221,'2','f',04,0221,'6','f','X',0201,'+',0,04,0201,'2',0,0,0201,'6',0,0204,'@',0221,'+','f',0,0221,'2','f',04,0221,'6','f','X',0201,'+',0,04,0201,'2',0,0,0201,'6',0,0,0221,'+','^',0,0221,'2','^',04,0221,'6','^','X',0201,'+',0,04,0201,'2',0,0,0201,'6',0,'`',0221,'+','f',0,0221,'2','f',04,0221,'6','f','X',0201,'+',0,04,0201,'2',0,0,0201,'6',0,0201,'@',0221,'+','f',0,0221,'2','f',04,0221,'6','f','X',0201,'+',0,04,0201,'2',0,0,0201,'6',0,0,0221,'+','^',0,0221,'2','^',04,0221,'6','^','X',0201,'+',0,04,0201,'2',0,0,0201,'6',0,'`',0221,'+','f',0,0221,'2','f',04,0221,'6','f','X',0201,'+',0,04,0201,'2',0,0,0201,'6',0,0234,'@',0221,'=','d',0134,0201,'=',0,04,0221,'=','d',0134,0201,'=',0,'d',0221,'6','d',0,0221,'=','d',0202,034,0201,'=',0,04,0221,'=','d',0134,0201,'=',0,04,0221,'=','d',0134,0201,'6',0,0,0201,'=',0,'d',0221,'6','d',0,0221,'>','d',0202,034,0201,'6',0,0,0201,'>',0,04,0221,';','d',0,0221,'6','d',0134,0201,';',0,0,0201,'6',0,04,0221,'6','d',0,0221,';','d',0134,0201,'6',0,0,0201,';',0,'d',0221,';','d',0,0221,'4','d','`',0221,'4','@',0,0221,';','@',0201,'<',0201,';','@',0,0201,'4','@',0,0201,'4',0,0,0201,';',0,04,0221,'4','d',0,0221,';','d',0134,0201,'4',0,0,0201,';',0,04,0221,'4','d',0,0221,';','d',0134,0201,'4',0,0,0201,';',0,'d',0221,';','d',0,0221,'4','d',0134,0201,';',0,0,0201,'4',0,'d',0221,'4','d',0,0221,';','d',0201,'<',0201,'4',0,0,0201,';',0,04,0221,'2','d',0,0221,'9','d',0201,'<',0201,'2',0,0,0201,'9',0,04,0221,'2','d',0,0221,'7','d',0201,'<',0201,'2',0,0,0201,'7',0,04,0221,'2','d',0,0221,'9','d',0201,'<',0201,'2',0,0,0201,'9',0,04,0221,'1','d',0,0221,'6','d','`',0221,'1','@',0,0221,'6','@',0201,'<',0201,'1','@',0,0201,'6','@',0,0201,'1',0,0,0201,'6',0,04,0221,'=','d',0,0221,'6','d',0134,0201,'=',0,0,0201,'6',0,04,0221,'6','d',0,0221,'=','d',0134,0201,'6',0,0,0201,'=',0,'d',0221,'6','d',0,0221,'=','d',0134,0201,'6',0,0,0201,'=',0,'d',0221,'6','d',0,0221,'>','d',0201,'<',0201,'6',0,0,0201,'>',0,04,0221,'6','d',0,0221,'=','d',0201,'<',0201,'6',0,0,0201,'=',0,04,0221,'4','d',0,0221,';','d',0201,'<',0201,'4',0,0,0201,';',0,04,0221,'=','d',0,0221,'6','d',0202,034,0201,'=',0,0,0201,'6',0,04,0221,'2','d',0,0221,'9','d',0134,0201,'2',0,0,0201,'9',0,04,0221,'/','d',0,0221,'6','d',0134,0201,'/',0,0,0201,'6',0,'d',0221,'2','d',0,0221,'9','d',0134,0201,'2',0,0,0201,'9',0,'d',0221,'6','d',0,0221,';','d',0134,0201,'6',0,0,0201,';',0,'d',0221,'4','d',0,0221,'8','d',0201,'<',0201,'4',0,0,0201,'8',0,04,0221,'/','d',0,0221,'4','d',0134,0201,'/',0,0,0201,'4',0,'d',0221,'1','d',0,0221,'8','d',0134,0201,'1',0,0,0201,'8',0,'d',0221,'1','d',0,0221,'9','d',0202,034,0201,'1',0,0,0201,'9',0,04,0221,'2','d',0,0221,'9','d','X',0221,'2','d',04,0201,'2',0,0,0201,'9',0,04,0221,'9','d','X',0201,'2',0,04,0201,'9',0,'d',0221,'2','n',0,0221,'9','n',0202,020,0221,'2','d',014,0201,'9',0,04,0221,'9','d','L',0201,'2',0,04,0221,'2','d',014,0201,'9',0,04,0221,'9','d','L',0201,'2',0,020,0201,'2',0,0,0201,'9',0,'d',0221,'4','n',0,0221,';','n',0202,034,0201,'4',0,0,0201,';',0,04,0221,'2','d',0,0221,';','d',0134,0201,'2',0,0,0201,';',0,04,0221,'2','d',0,0221,';','d',0134,0201,'2',0,0,0201,';',0,'d',0221,';','n',0,0221,'4','n','`',0221,'4','@',0,0221,';','@',0201,'<',0201,';','@',0,0201,'4','@',0,0201,'4',0,0,0201,';',0,04,0221,'4','d',0,0221,';','d',0134,0201,'4',0,0,0201,';',0,04,0221,'4','d',0,0221,';','d',0134,0201,'4',0,0,0201,';',0,'d',0221,';','d',0,0221,'4','d',0134,0201,';',0,0,0201,'4',0,'d',0221,'6','f',0,0221,'=','f',0201,'<',0201,'6',0,0,0201,'=',0,04,0221,'4','h',0,0221,';','h',0201,'<',0201,'4',0,0,0201,';',0,04,0221,'2','j',0,0221,'9','j',0201,'<',0201,'2',0,0,0201,'9',0,04,0221,'8','l',0,0221,'1','l',0201,'<',0201,'8',0,0,0201,'1',0,04,0221,'2','n',0,0221,'9','n','`',0221,'2','@',0,0221,'9','@',0201,'<',0201,'2','@',0,0201,'9','@',0,0201,'2',0,0,0201,'9',0,04,0221,'2','d',0,0221,'=','d',0134,0201,'2',0,0,0201,'=',0,04,0221,'=','d',0,0221,'2','d',0134,0201,'=',0,0,0201,'2',0,'d',0221,';','d',0,0221,'2','d',0134,0201,';',0,0,0201,'2',0,'d',0221,'9','d',0,0221,'4','d',0201,'<',0201,'9',0,0,0201,'4',0,04,0221,'8','d',0,0221,'4','d',0201,'<',0201,'8',0,0,0201,'4',0,04,0221,'4','d',0,0221,'9','d',0201,'<',0201,'4',0,0,0201,'9',0,04,0221,'8','l',0,0221,'4','l',0134,0201,'8',0,04,0221,'6','l',0134,0201,'6',0,04,0221,'8','l',0134,0201,'4',0,0,0201,'8',0,04,0221,'6','d',0,0221,'9','d',0134,0201,'6',0,0,0201,'9',0,04,0221,'2','d',0,0221,'6','d',0134,0201,'2',0,0,0201,'6',0,'d',0221,'2','d',0,0221,'9','d',0134,0201,'2',0,0,0201,'9',0,'d',0221,'6','d',0,0221,';','d',0134,0201,'6',0,0,0201,';',0,'d',0221,'4','d',0,0221,'8','d',0201,'<',0201,'4',0,0,0201,'8',0,04,0221,'/','d',0,0221,'4','d',0134,0201,'/',0,0,0201,'4',0,'d',0221,'1','d',0,0221,'8','d',0134,0201,'1',0,0,0201,'8',0,'d',0221,'1','d',0,0221,'9','d',0202,034,0201,'1',0,0,0201,'9',0,04,0221,'*','f',04,0221,'6','f','X',0201,'*',0,04,0201,'6',0,0,0221,'*','^',04,0221,'6','^','X',0201,'*',0,04,0201,'6',0,'`',0221,'*','f',04,0221,'6','f','X',0201,'*',0,04,0201,'6',0,0201,'@',0221,'*','f',04,0221,'6','f','X',0201,'*',0,04,0201,'6',0,0,0221,'*','^',04,0221,'6','^','X',0201,'*',0,04,0201,'6',0,'`',0221,'*','f',04,0221,'6','f','X',0201,'*',0,04,0201,'6',0,0204,'@',0221,'*','f',04,0221,'6','f','X',0201,'*',0,04,0201,'6',0,0,0221,'*','^',04,0221,'6','^','X',0201,'*',0,04,0201,'6',0,'`',0221,'*','f',04,0221,'6','f','X',0201,'*',0,04,0201,'6',0,0201,'@',0221,'*','f',04,0221,'6','f','X',0201,'*',0,04,0201,'6',0,0,0221,'*','^',04,0221,'6','^','X',0201,'*',0,04,0201,'6',0,'`',0221,'*','f',04,0221,'6','f','X',0201,'*',0,04,0201,'6',0,0204,'<',0261,'u',0177,0,0377,'/',0,'M','T','r','k',0,0,037,'d',0,0262,0,0,0,0302,036,0,0262,012,'I',0,0262,'[',05,0,0262,']',0,0,0377,'Y',02,0,0,0,0262,07,'d',0,0262,'n',0177,030,0262,'d',0,0,0262,'e',0,034,0262,06,02,0,0262,'&',0,034,0262,'d',0177,0,0262,'e',0177,'P',0342,0,'@',030,0262,01,0,0201,'H',0222,'*','d',0,0262,'t',0,0134,0202,'*',0,04,0222,'-','d',0134,0202,'-',0,'d',0222,'/','d',0134,0202,'/',0,0201,'D',0222,'*','d',0134,0202,'*',0,04,0222,'/','d',0134,0202,'/',0,'d',0222,'1','d',0134,0202,'1',0,0201,'D',0222,'*','d',0134,0202,'*',0,04,0222,'1','d',0134,0202,'1',0,'d',0222,'2','d',0134,0202,'2',0,'d',0222,'*','d',0134,0202,'*',0,'d',0222,'1','d',0201,'<',0202,'1',0,04,0222,'/','d',0134,0202,'/',0,04,0222,'-','d',0134,0202,'-',0,04,0222,'*','d',0134,0202,'*',0,04,0222,'(','n',0,0222,'1','n',0202,034,0202,'(',0,0,0202,'1',0,04,0222,'2','n',0,0222,'+','n',0201,'<',0202,'2',0,04,0222,'2','d',0134,0202,'+',0,0,0202,'2',0,04,0222,'1','d',0134,0202,'1',0,04,0222,'/','d',0134,0202,'/',0,04,0222,'*','d',0134,0202,'*',0,04,0222,'(','d',0,0222,'-','d',0134,0202,'(',0,0,0202,'-',0,'d',0222,'*','d',0,0222,'/','d',0134,0202,'*',0,0,0202,'/',0,0201,'D',0222,'*','d',0134,0202,'*',0,04,0222,'*','d',0,0222,'/','d',0134,0202,'*',0,0,0202,'/',0,'d',0222,',','d',0,0222,'1','d',0134,0202,',',0,0,0202,'1',0,0201,'D',0222,'*','d',0134,0202,'*',0,04,0222,',','d',0,0222,'1','d',0134,0202,',',0,0,0202,'1',0,'d',0222,'-','d',0,0222,'2','d',0134,0202,'-',0,0,0202,'2',0,'d',0222,'*','d',0134,0202,'*',0,'d',0222,'-','d',0,0222,'1','d',0201,'<',0202,'-',0,0,0202,'1',0,04,0222,',','d',0,0222,'/','d',0134,0202,',',0,0,0202,'/',0,04,0222,'*','d',0,0222,'-','d',0134,0202,'*',0,0,0202,'-',0,04,0222,'*','d',0134,0202,'*',0,04,0222,'(','n',0,0222,'/','n',0202,034,0202,'(',0,0,0202,'/',0,04,0222,'&','n',0,0222,'-','n',0201,'<',0202,'-',0,04,0222,'/','d',0134,0202,'&',0,0,0202,'/',0,04,0222,'(','d',0,0222,'-','d',0134,0202,'-',0,04,0222,'/','d',0134,0202,'(',0,0,0202,'/',0,04,0222,'*','Z',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'+','X',0134,0202,'+',0,04,0222,'+','Q',',',0202,'+',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'(','X',0134,0202,'(',0,04,0222,'+','Q','4',0202,'+',0,',',0222,'+','X',0134,0202,'+',0,04,0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'2','X',0134,0202,'2',0,04,0222,'1','Q',',',0202,'1',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'+','X',0134,0202,'+',0,04,0222,'*','Q','4',0202,'*',0,',',0222,'*','X',0134,0202,'*',0,04,0222,'+','X',0134,0202,'+',0,04,0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','X',0134,0202,'+',0,04,0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','X',0134,0202,'+',0,04,0222,'+','Q',',',0202,'+',0,'4',0222,'+','X',0134,0202,'+',0,04,0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','X',0134,0202,'+',0,04,0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','X',0134,0202,'+',0,04,0222,'+','Q',',',0202,'+',0,'4',0222,'*','d',0134,0202,'*',0,04,0222,'-','d',0134,0202,'-',0,'d',0222,'/','d',0134,0202,'/',0,0201,'D',0222,'*','d',0134,0202,'*',0,04,0222,'/','d',0134,0202,'/',0,'d',0222,'1','d',0134,0202,'1',0,0201,'D',0222,'*','d',0134,0202,'*',0,04,0222,'1','d',0134,0202,'1',0,'d',0222,'2','d',0134,0202,'2',0,'d',0222,'*','d',0134,0202,'*',0,'d',0222,'1','d',0201,'<',0202,'1',0,04,0222,'/','d',0134,0202,'/',0,04,0222,'-','d',0134,0202,'-',0,04,0222,'*','d',0134,0202,'*',0,04,0222,'(','n',0,0222,'1','n',0202,034,0202,'(',0,0,0202,'1',0,04,0222,'2','n',0,0222,'+','n',0201,'<',0202,'2',0,04,0222,'2','d',0134,0202,'+',0,0,0202,'2',0,04,0222,'1','d',0134,0202,'1',0,04,0222,'/','d',0134,0202,'/',0,04,0222,'*','Z',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'+','X',0134,0202,'+',0,04,0222,'+','Q',',',0202,'+',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'(','X',0134,0202,'(',0,04,0222,'+','Q','4',0202,'+',0,',',0222,'+','X',0134,0202,'+',0,04,0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'2','X',0134,0202,'2',0,04,0222,'1','Q',',',0202,'1',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'+','X',0134,0202,'+',0,04,0222,'*','Q','4',0202,'*',0,',',0222,'*','X',0134,0202,'*',0,04,0222,'*','Z',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'6','Q',',',0202,'6',0,'4',0222,'6','Q',',',0202,'6',0,'4',0222,'4','X',0134,0202,'4',0,04,0222,'4','Q',',',0202,'4',0,'4',0222,'2','Q',',',0202,'2',0,'4',0222,'2','X',0134,0202,'2',0,04,0222,'1','Q','4',0202,'1',0,',',0222,'2','X',0134,0202,'2',0,04,0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'2','X',0134,0202,'2',0,04,0222,'1','Q',',',0202,'1',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'+','X',0134,0202,'+',0,04,0222,'*','Q','4',0202,'*',0,',',0222,'*','X',0134,0202,'*',0,04,0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'0',0262,'u',0177,'d',0222,'*','d',0,0262,'t',0,0134,0202,'*',0,04,0222,'-','d',0134,0202,'-',0,'d',0222,'/','d',0134,0202,'/',0,0201,'D',0222,'*','d',0134,0202,'*',0,04,0222,'/','d',0134,0202,'/',0,'d',0222,'1','d',0134,0202,'1',0,0201,'D',0222,'*','d',0134,0202,'*',0,04,0222,'1','d',0134,0202,'1',0,'d',0222,'2','d',0134,0202,'2',0,'d',0222,'*','d',0134,0202,'*',0,'d',0222,'1','d',0201,'<',0202,'1',0,04,0222,'/','d',0134,0202,'/',0,04,0222,'-','d',0134,0202,'-',0,04,0222,'*','d',0134,0202,'*',0,04,0222,'(','n',0,0222,'1','n',0202,034,0202,'(',0,0,0202,'1',0,04,0222,'2','n',0,0222,'+','n',0201,'<',0202,'2',0,04,0222,'2','d',0134,0202,'+',0,0,0202,'2',0,04,0222,'1','d',0134,0202,'1',0,04,0222,'/','d',0134,0202,'/',0,04,0222,'*','d',0134,0202,'*',0,04,0222,'(','d',0,0222,'-','d',0134,0202,'(',0,0,0202,'-',0,'d',0222,'*','d',0,0222,'/','d',0134,0202,'*',0,0,0202,'/',0,0201,'D',0222,'*','d',0134,0202,'*',0,04,0222,'*','d',0,0222,'/','d',0134,0202,'*',0,0,0202,'/',0,'d',0222,',','d',0,0222,'1','d',0134,0202,',',0,0,0202,'1',0,0201,'D',0222,'*','d',0134,0202,'*',0,04,0222,',','d',0,0222,'1','d',0134,0202,',',0,0,0202,'1',0,'d',0222,'-','d',0,0222,'2','d',0134,0202,'-',0,0,0202,'2',0,'d',0222,'*','d',0134,0202,'*',0,'d',0222,'-','d',0,0222,'1','d',0201,'<',0202,'-',0,0,0202,'1',0,04,0222,',','d',0,0222,'/','d',0134,0202,',',0,0,0202,'/',0,04,0222,'*','d',0,0222,'-','d',0134,0202,'*',0,0,0202,'-',0,04,0222,'*','d',0134,0202,'*',0,04,0222,'(','n',0,0222,'/','n',0202,034,0202,'(',0,0,0202,'/',0,04,0222,'&','n',0,0222,'-','n',0201,'<',0202,'-',0,04,0222,'/','d',0134,0202,'&',0,0,0202,'/',0,04,0222,'(','d',0,0222,'-','d',0134,0202,'-',0,04,0222,'/','d',0134,0202,'(',0,0,0202,'/',0,04,0222,'*','Z',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'+','X',0134,0202,'+',0,04,0222,'+','Q',',',0202,'+',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'(','X',0134,0202,'(',0,04,0222,'+','Q','4',0202,'+',0,',',0222,'+','X',0134,0202,'+',0,04,0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'2','X',0134,0202,'2',0,04,0222,'1','Q',',',0202,'1',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'+','X',0134,0202,'+',0,04,0222,'*','Q','4',0202,'*',0,',',0222,'*','X',0134,0202,'*',0,04,0222,'+','X',0134,0202,'+',0,04,0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','X',0134,0202,'+',0,04,0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','X',0134,0202,'+',0,04,0222,'+','Q',',',0202,'+',0,'4',0222,'+','X',0134,0202,'+',0,04,0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','X',0134,0202,'+',0,04,0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','X',0134,0202,'+',0,04,0222,'+','Q',',',0202,'+',0,'4',0222,'*','d',0134,0202,'*',0,04,0222,'-','d',0134,0202,'-',0,'d',0222,'/','d',0134,0202,'/',0,0201,'D',0222,'*','d',0134,0202,'*',0,04,0222,'/','d',0134,0202,'/',0,'d',0222,'1','d',0134,0202,'1',0,0201,'D',0222,'*','d',0134,0202,'*',0,04,0222,'1','d',0134,0202,'1',0,'d',0222,'2','d',0134,0202,'2',0,'d',0222,'*','d',0134,0202,'*',0,'d',0222,'1','d',0201,'<',0202,'1',0,04,0222,'/','d',0134,0202,'/',0,04,0222,'-','d',0134,0202,'-',0,04,0222,'*','d',0134,0202,'*',0,04,0222,'(','n',0,0222,'1','n',0202,034,0202,'(',0,0,0202,'1',0,04,0222,'2','n',0,0222,'+','n',0201,'<',0202,'2',0,04,0222,'2','d',0134,0202,'+',0,0,0202,'2',0,04,0222,'1','d',0134,0202,'1',0,04,0222,'/','d',0134,0202,'/',0,04,0222,'*','Z',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'+','X',0134,0202,'+',0,04,0222,'+','Q',',',0202,'+',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'(','X',0134,0202,'(',0,04,0222,'+','Q','4',0202,'+',0,',',0222,'+','X',0134,0202,'+',0,04,0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'2','X',0134,0202,'2',0,04,0222,'1','Q',',',0202,'1',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'+','X',0134,0202,'+',0,04,0222,'*','Q','4',0202,'*',0,',',0222,'*','X',0134,0202,'*',0,04,0222,'*','Z',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'6','Q',',',0202,'6',0,'4',0222,'6','Q',',',0202,'6',0,'4',0222,'4','X',0134,0202,'4',0,04,0222,'4','Q',',',0202,'4',0,'4',0222,'2','Q',',',0202,'2',0,'4',0222,'2','X',0134,0202,'2',0,04,0222,'1','Q','4',0202,'1',0,',',0222,'2','X',0134,0202,'2',0,04,0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'2','X',0134,0202,'2',0,04,0222,'1','Q',',',0202,'1',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'+','X',0134,0202,'+',0,04,0222,'*','Q','4',0202,'*',0,',',0222,'*','X',0134,0202,'*',0,04,0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'0',0262,'u',0177,0202,'$',0222,'*','d',0,0262,'t',0,0134,0202,'*',0,04,0222,'-','d',0134,0202,'-',0,'d',0222,'/','d',0134,0202,'/',0,0201,'D',0222,'*','d',0134,0202,'*',0,04,0222,'/','d',0134,0202,'/',0,'d',0222,'1','d',0134,0202,'1',0,0201,'D',0222,'*','d',0134,0202,'*',0,04,0222,'1','d',0134,0202,'1',0,'d',0222,'2','d',0134,0202,'2',0,'d',0222,'*','d',0134,0202,'*',0,'d',0222,'1','d',0201,'<',0202,'1',0,04,0222,'/','d',0134,0202,'/',0,04,0222,'-','d',0134,0202,'-',0,04,0222,'*','d',0134,0202,'*',0,04,0222,'(','n',0,0222,'1','n',0202,034,0202,'(',0,0,0202,'1',0,04,0222,'2','n',0,0222,'+','n',0201,'<',0202,'2',0,04,0222,'2','d',0134,0202,'+',0,0,0202,'2',0,04,0222,'1','d',0134,0202,'1',0,04,0222,'/','d',0134,0202,'/',0,04,0222,'*','d',0134,0202,'*',0,04,0222,'(','d',0,0222,'-','d',0134,0202,'(',0,0,0202,'-',0,'d',0222,'*','d',0,0222,'/','d',0134,0202,'*',0,0,0202,'/',0,0201,'D',0222,'*','d',0134,0202,'*',0,04,0222,'*','d',0,0222,'/','d',0134,0202,'*',0,0,0202,'/',0,'d',0222,',','d',0,0222,'1','d',0134,0202,',',0,0,0202,'1',0,0201,'D',0222,'*','d',0134,0202,'*',0,04,0222,',','d',0,0222,'1','d',0134,0202,',',0,0,0202,'1',0,'d',0222,'-','d',0,0222,'2','d',0134,0202,'-',0,0,0202,'2',0,'d',0222,'*','d',0134,0202,'*',0,'d',0222,'-','d',0,0222,'1','d',0201,'<',0202,'-',0,0,0202,'1',0,04,0222,',','d',0,0222,'/','d',0134,0202,',',0,0,0202,'/',0,04,0222,'*','d',0,0222,'-','d',0134,0202,'*',0,0,0202,'-',0,04,0222,'*','d',0134,0202,'*',0,04,0222,'(','n',0,0222,'/','n',0202,034,0202,'(',0,0,0202,'/',0,04,0222,'&','n',0,0222,'-','n',0201,'<',0202,'-',0,04,0222,'/','d',0134,0202,'&',0,0,0202,'/',0,04,0222,'(','d',0,0222,'-','d',0134,0202,'-',0,04,0222,'/','d',0134,0202,'(',0,0,0202,'/',0,04,0222,'*','Z',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'+','X',0134,0202,'+',0,04,0222,'+','Q',',',0202,'+',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'(','X',0134,0202,'(',0,04,0222,'+','Q','4',0202,'+',0,',',0222,'+','X',0134,0202,'+',0,04,0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'2','X',0134,0202,'2',0,04,0222,'1','Q',',',0202,'1',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'+','X',0134,0202,'+',0,04,0222,'*','Q','4',0202,'*',0,',',0222,'*','X',0134,0202,'*',0,04,0222,'+','X',0134,0202,'+',0,04,0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','X',0134,0202,'+',0,04,0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','X',0134,0202,'+',0,04,0222,'+','Q',',',0202,'+',0,'4',0222,'+','X',0134,0202,'+',0,04,0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','X',0134,0202,'+',0,04,0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','Q',',',0202,'+',0,'4',0222,'+','X',0134,0202,'+',0,04,0222,'+','Q',',',0202,'+',0,'4',0222,'*','d',0134,0202,'*',0,04,0222,'-','d',0134,0202,'-',0,'d',0222,'/','d',0134,0202,'/',0,0201,'D',0222,'*','d',0134,0202,'*',0,04,0222,'/','d',0134,0202,'/',0,'d',0222,'1','d',0134,0202,'1',0,0201,'D',0222,'*','d',0134,0202,'*',0,04,0222,'1','d',0134,0202,'1',0,'d',0222,'2','d',0134,0202,'2',0,'d',0222,'*','d',0134,0202,'*',0,'d',0222,'1','d',0201,'<',0202,'1',0,04,0222,'/','d',0134,0202,'/',0,04,0222,'-','d',0134,0202,'-',0,04,0222,'*','d',0134,0202,'*',0,04,0222,'(','n',0,0222,'1','n',0202,034,0202,'(',0,0,0202,'1',0,04,0222,'2','n',0,0222,'+','n',0201,'<',0202,'2',0,04,0222,'2','d',0134,0202,'+',0,0,0202,'2',0,04,0222,'1','d',0134,0202,'1',0,04,0222,'/','d',0134,0202,'/',0,04,0222,'*','Z',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'+','X',0134,0202,'+',0,04,0222,'+','Q',',',0202,'+',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'(','X',0134,0202,'(',0,04,0222,'+','Q','4',0202,'+',0,',',0222,'+','X',0134,0202,'+',0,04,0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'2','X',0134,0202,'2',0,04,0222,'1','Q',',',0202,'1',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'+','X',0134,0202,'+',0,04,0222,'*','Q','4',0202,'*',0,',',0222,'*','X',0134,0202,'*',0,04,0222,'*','Z',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'6','Q',',',0202,'6',0,'4',0222,'6','Q',',',0202,'6',0,'4',0222,'4','X',0134,0202,'4',0,04,0222,'4','Q',',',0202,'4',0,'4',0222,'2','Q',',',0202,'2',0,'4',0222,'2','X',0134,0202,'2',0,04,0222,'1','Q','4',0202,'1',0,',',0222,'2','X',0134,0202,'2',0,04,0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'2','X',0134,0202,'2',0,04,0222,'1','Q',',',0202,'1',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'+','X',0134,0202,'+',0,04,0222,'*','Q','4',0202,'*',0,',',0222,'*','X',0134,0202,'*',0,04,0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','Q',',',0202,'*',0,'4',0222,'*','X',0134,0202,'*',0,04,0222,'*','Q',',',0202,'*',0,'0',0262,'u',0177,0,0377,'/',0,'M','T','r','k',0,0,024,0223,0,0263,0,0,0,0303,'Q',0,0263,012,0,0,0263,'[',0,0,0263,']',0,0,0377,'Y',02,0,0,0,0263,07,'i',0,0263,'n',0177,030,0263,'d',0,0,0263,'e',0,034,0263,06,02,0,0263,'&',0,034,0263,'d',0177,0,0263,'e',0177,'P',0343,0,'@',030,0263,01,0,0201,'H',0263,'t',0,0347,'@',0223,'C','g',0,0223,'7','g',0,0223,'+','g',',',0203,'C',0,0,0203,'7',0,0,0203,'+',0,04,0223,'E','f',0,0223,'9','f',0,0223,'-','f',',',0203,'E',0,0,0203,'9',0,0,0203,'-',0,04,0223,'G','e',0,0223,';','e',0,0223,'/','e',',',0203,'G',0,0,0203,';',0,0,0203,'/',0,04,0223,'J','d',0,0223,'>','d',0,0223,'2','d',',',0203,'J',0,0,0203,'>',0,0,0203,'2',0,04,0223,'N','i',0,0223,'B','i',0,0223,'6','i',0134,0203,'N',0,0,0203,'B',0,0,0203,'6',0,04,0223,'L','a',0,0223,'@','a',0,0223,'4','a',',',0203,'L',0,0,0203,'@',0,0,0203,'4',0,04,0223,'J','a',0,0223,'>','a',0,0223,'2','a',',',0203,'J',0,0,0203,'>',0,0,0203,'2',0,04,0223,'L','f',0,0223,'@','f',0,0223,'4','f',0134,0203,'L',0,0,0203,'@',0,0,0203,'4',0,04,0223,'N','i',0,0223,'B','i',0,0223,'6','i',',',0203,'N',0,0,0203,'B',0,0,0203,'6',0,0207,'t',0223,'G','q',0,0223,';','q',0,0223,'/','q',',',0203,'G',0,0,0203,';',0,0,0203,'/',0,04,0223,'I','Z',0,0223,'=','Z',0,0223,'1','Z',',',0203,'I',0,0,0203,'=',0,0,0203,'1',0,04,0223,'J','Z',0,0223,'>','Z',0,0223,'2','Z',',',0203,'J',0,0,0203,'>',0,0,0203,'2',0,04,0223,'I','q',0,0223,'=','q',0,0223,'1','q',',',0203,'I',0,0,0203,'=',0,0,0203,'1',0,04,0223,'J','Z',0,0223,'>','Z',0,0223,'2','Z',',',0203,'J',0,0,0203,'>',0,0,0203,'2',0,04,0223,'L','Z',0,0223,'@','Z',0,0223,'4','Z',',',0203,'L',0,0,0203,'@',0,0,0203,'4',0,04,0223,'N','n',0,0223,'B','n',0,0223,'6','n',',',0203,'N',0,0,0203,'B',0,0,0203,'6',0,04,0223,'J','d',0,0223,'>','d',0,0223,'2','d',',',0203,'J',0,0,0203,'>',0,0,0203,'2',0,04,0223,'I','n',0,0223,'=','n',0,0223,'1','n',',',0203,'I',0,0,0203,'=',0,0,0203,'1',0,04,0223,'L','d',0,0223,'@','d',0,0223,'4','d',',',0203,'L',0,0,0203,'@',0,0,0203,'4',0,04,0223,'J','n',0,0223,'>','n',0,0223,'2','n',',',0203,'J',0,0,0203,'>',0,0,0203,'2',0,04,0223,'I','d',0,0223,'=','d',0,0223,'1','d',',',0203,'I',0,0,0203,'=',0,0,0203,'1',0,0230,04,0223,'E','P',0,0223,'6','P',0,0223,'=','P',0205,'|',0203,'E',0,0,0203,'=',0,04,0223,'E','P',0,0223,'>','P',0205,'|',0203,'6',0,0,0203,'E',0,0,0203,'>',0,04,0223,'4','P',0,0223,';','P',0,0223,'D','P',0205,'|',0203,'4',0,0,0203,';',0,0,0203,'D',0,04,0223,'2','P',0,0223,'9','P',0,0223,'B','P',0204,'<',0203,'2',0,0,0203,'9',0,0,0203,'B',0,04,0223,'@','P',0,0223,'0','P',0,0223,'7','P',0201,'<',0203,'@',0,0,0203,'0',0,0,0203,'7',0,04,0223,'9','P',0,0223,'=','P',0,0223,'B','P',0202,'|',0203,'9',0,0,0203,'B',0,04,0223,'6','P',0,0223,'E','P',0202,'|',0203,'=',0,0,0203,'6',0,0,0203,'E',0,04,0223,'E','P',0,0223,'6','P',0,0223,'>','P',0205,'|',0203,'E',0,0,0203,'6',0,0,0203,'>',0,04,0223,'2','P',0,0223,'>','P',0,0223,'E','P',0205,'|',0203,'2',0,0,0203,'>',0,0,0203,'E',0,04,0223,'D','P',0,0223,'8','P',0,0223,'@','P',0205,'|',0203,'D',0,0,0203,'8',0,0,0203,'@',0,04,0223,'B','P',0,0223,'9','P',0,0223,'>','P',0202,'|',0203,'9',0,04,0223,'2','P',0202,'|',0203,'B',0,0,0203,'>',0,0,0203,'2',0,04,0223,';','P',0,0223,'D','P',0205,'|',0203,';',0,0,0203,'D',0,04,0223,'4','P',0,0223,';','P',0,0223,'D','P',0205,034,0203,'4',0,0,0203,';',0,0,0203,'D',0,04,0223,'6','P',0,0223,'=','P',0,0223,'E','P',0201,'<',0203,'6',0,0,0203,'=',0,0,0203,'E',0,04,0223,'4','P',0,0223,';','P',0,0223,'D','P',0201,'<',0203,'4',0,0,0203,';',0,0,0203,'D',0,04,0223,'6','P',0,0223,'=','P',0,0223,'E','P',0201,'<',0203,'6',0,0,0203,'=',0,0,0203,'E',0,04,0223,'=','P',0,0223,'@','P',0,0223,'D','P',0201,'<',0203,'=',0,0,0203,'@',0,0,0203,'D',0,04,0223,'B','P',0,0223,'9','P',0,0223,'2','P','`',0223,'2','@',0,0223,'9','@',0,0223,'B','@',0202,'|',0203,'B','@',0,0203,'9','@',0,0203,'2','@',0,0203,'2',0,0,0203,'9',0,0,0203,'B',0,04,0223,'6','P',0,0223,'>','P',0,0223,'E','P',0202,034,0203,'6',0,0,0203,'>',0,0,0203,'E',0,04,0223,'@','P',0,0223,'8','P',0,0223,'D','P',0204,'<',0203,'@',0,0,0203,'8',0,0,0203,'D',0,04,0223,'8','P',0,0223,'@','P',0,0223,';','P',0202,034,0203,'8',0,0,0203,'@',0,0,0203,';',0,04,0223,'2','P',0,0223,'>','P',0,0223,'E','P',0205,'|',0203,'2',0,0,0203,'>',0,0,0203,'E',0,04,0223,'@','P',0,0223,'4','P',0134,0203,'@',0,0,0203,'4',0,04,0223,'B','S',0,0223,'6','S',0134,0203,'B',0,0,0203,'6',0,04,0223,'D','W',0,0223,'8','W',0134,0203,'D',0,0,0203,'8',0,04,0223,'E','[',0,0223,'9','[',0134,0203,'E',0,0,0203,'9',0,04,0223,'G','_',0,0223,';','_',0134,0203,'G',0,0,0203,';',0,04,0223,'I','b',0,0223,'=','b',0134,0203,'I',0,0,0203,'=',0,04,0223,'J','f',0,0223,'>','f',0134,0203,'J',0,0,0203,'>',0,04,0223,'@','j',0,0223,'L','j',0134,0203,'@',0,0,0203,'L',0,0207,'D',0223,'*','g',0,0223,'6','g',0,0223,'B','g',',',0203,'*',0,0,0203,'6',0,0,0203,'B',0,04,0223,'E','f',0,0223,'9','f',0,0223,'-','f',',',0203,'E',0,0,0203,'9',0,0,0203,'-',0,04,0223,'G','e',0,0223,';','e',0,0223,'/','e',',',0203,'G',0,0,0203,';',0,0,0203,'/',0,04,0223,'1','d',0,0223,'=','d',0,0223,'I','d',',',0203,'1',0,0,0203,'=',0,0,0203,'I',0,04,0223,'4','i',0,0223,'@','i',0,0223,'L','i',',',0203,'4',0,0,0203,'@',0,0,0203,'L',0,04,0223,'6','i',0,0223,'B','i',0,0223,'N','i',',',0203,'6',0,0,0203,'B',0,0,0203,'N',0,04,0223,'1','a',0,0223,'=','a',0,0223,'I','a',',',0203,'1',0,0,0203,'=',0,0,0203,'I',0,04,0223,'2','a',0,0223,'>','a',0,0223,'J','a',',',0203,'2',0,0,0203,'>',0,0,0203,'J',0,04,0223,'L','f',0,0223,'@','f',0,0223,'4','f',0134,0203,'L',0,0,0203,'@',0,0,0203,'4',0,04,0223,'N','i',0,0223,'B','i',0,0223,'6','i',',',0203,'N',0,0,0203,'B',0,0,0203,'6',0,0207,'t',0223,'G','q',0,0223,';','q',0,0223,'/','q',',',0203,'G',0,0,0203,';',0,0,0203,'/',0,04,0223,'I','Z',0,0223,'=','Z',0,0223,'1','Z',',',0203,'I',0,0,0203,'=',0,0,0203,'1',0,04,0223,'J','Z',0,0223,'>','Z',0,0223,'2','Z',',',0203,'J',0,0,0203,'>',0,0,0203,'2',0,04,0223,'I','q',0,0223,'=','q',0,0223,'1','q',',',0203,'I',0,0,0203,'=',0,0,0203,'1',0,04,0223,'J','Z',0,0223,'>','Z',0,0223,'2','Z',',',0203,'J',0,0,0203,'>',0,0,0203,'2',0,04,0223,'L','Z',0,0223,'@','Z',0,0223,'4','Z',',',0203,'L',0,0,0203,'@',0,0,0203,'4',0,04,0223,'N','n',0,0223,'B','n',0,0223,'6','n',',',0203,'N',0,0,0203,'B',0,0,0203,'6',0,04,0223,'J','d',0,0223,'>','d',0,0223,'2','d',',',0203,'J',0,0,0203,'>',0,0,0203,'2',0,04,0223,'I','n',0,0223,'=','n',0,0223,'1','n',',',0203,'I',0,0,0203,'=',0,0,0203,'1',0,04,0223,'L','d',0,0223,'@','d',0,0223,'4','d',',',0203,'L',0,0,0203,'@',0,0,0203,'4',0,04,0223,'J','n',0,0223,'>','n',0,0223,'2','n',',',0203,'J',0,0,0203,'>',0,0,0203,'2',0,04,0223,'I','d',0,0223,'=','d',0,0223,'1','d','(',0203,'I',0,0,0203,'=',0,0,0203,'1',0,04,0263,'u',0177,'d',0263,'t',0,0347,'@',0223,'C','g',0,0223,'7','g',0,0223,'+','g',',',0203,'C',0,0,0203,'7',0,0,0203,'+',0,04,0223,'E','f',0,0223,'9','f',0,0223,'-','f',',',0203,'E',0,0,0203,'9',0,0,0203,'-',0,04,0223,'G','e',0,0223,';','e',0,0223,'/','e',',',0203,'G',0,0,0203,';',0,0,0203,'/',0,04,0223,'J','d',0,0223,'>','d',0,0223,'2','d',',',0203,'J',0,0,0203,'>',0,0,0203,'2',0,04,0223,'N','i',0,0223,'B','i',0,0223,'6','i',0134,0203,'N',0,0,0203,'B',0,0,0203,'6',0,04,0223,'L','a',0,0223,'@','a',0,0223,'4','a',',',0203,'L',0,0,0203,'@',0,0,0203,'4',0,04,0223,'J','a',0,0223,'>','a',0,0223,'2','a',',',0203,'J',0,0,0203,'>',0,0,0203,'2',0,04,0223,'L','f',0,0223,'@','f',0,0223,'4','f',0134,0203,'L',0,0,0203,'@',0,0,0203,'4',0,04,0223,'N','i',0,0223,'B','i',0,0223,'6','i',',',0203,'N',0,0,0203,'B',0,0,0203,'6',0,0207,'t',0223,'G','q',0,0223,';','q',0,0223,'/','q',',',0203,'G',0,0,0203,';',0,0,0203,'/',0,04,0223,'I','Z',0,0223,'=','Z',0,0223,'1','Z',',',0203,'I',0,0,0203,'=',0,0,0203,'1',0,04,0223,'J','Z',0,0223,'>','Z',0,0223,'2','Z',',',0203,'J',0,0,0203,'>',0,0,0203,'2',0,04,0223,'I','q',0,0223,'=','q',0,0223,'1','q',',',0203,'I',0,0,0203,'=',0,0,0203,'1',0,04,0223,'J','Z',0,0223,'>','Z',0,0223,'2','Z',',',0203,'J',0,0,0203,'>',0,0,0203,'2',0,04,0223,'L','Z',0,0223,'@','Z',0,0223,'4','Z',',',0203,'L',0,0,0203,'@',0,0,0203,'4',0,04,0223,'N','n',0,0223,'B','n',0,0223,'6','n',',',0203,'N',0,0,0203,'B',0,0,0203,'6',0,04,0223,'J','d',0,0223,'>','d',0,0223,'2','d',',',0203,'J',0,0,0203,'>',0,0,0203,'2',0,04,0223,'I','n',0,0223,'=','n',0,0223,'1','n',',',0203,'I',0,0,0203,'=',0,0,0203,'1',0,04,0223,'L','d',0,0223,'@','d',0,0223,'4','d',',',0203,'L',0,0,0203,'@',0,0,0203,'4',0,04,0223,'J','n',0,0223,'>','n',0,0223,'2','n',',',0203,'J',0,0,0203,'>',0,0,0203,'2',0,04,0223,'I','d',0,0223,'=','d',0,0223,'1','d',',',0203,'I',0,0,0203,'=',0,0,0203,'1',0,0230,04,0223,'E','P',0,0223,'6','P',0,0223,'=','P',0205,'|',0203,'E',0,0,0203,'=',0,04,0223,'E','P',0,0223,'>','P',0205,'|',0203,'6',0,0,0203,'E',0,0,0203,'>',0,04,0223,'4','P',0,0223,';','P',0,0223,'D','P',0205,'|',0203,'4',0,0,0203,';',0,0,0203,'D',0,04,0223,'2','P',0,0223,'9','P',0,0223,'B','P',0204,'<',0203,'2',0,0,0203,'9',0,0,0203,'B',0,04,0223,'@','P',0,0223,'0','P',0,0223,'7','P',0201,'<',0203,'@',0,0,0203,'0',0,0,0203,'7',0,04,0223,'9','P',0,0223,'=','P',0,0223,'B','P',0202,'|',0203,'9',0,0,0203,'B',0,04,0223,'6','P',0,0223,'E','P',0202,'|',0203,'=',0,0,0203,'6',0,0,0203,'E',0,04,0223,'E','P',0,0223,'6','P',0,0223,'>','P',0205,'|',0203,'E',0,0,0203,'6',0,0,0203,'>',0,04,0223,'2','P',0,0223,'>','P',0,0223,'E','P',0205,'|',0203,'2',0,0,0203,'>',0,0,0203,'E',0,04,0223,'D','P',0,0223,'8','P',0,0223,'@','P',0205,'|',0203,'D',0,0,0203,'8',0,0,0203,'@',0,04,0223,'B','P',0,0223,'9','P',0,0223,'>','P',0202,'|',0203,'9',0,04,0223,'2','P',0202,'|',0203,'B',0,0,0203,'>',0,0,0203,'2',0,04,0223,';','P',0,0223,'D','P',0205,'|',0203,';',0,0,0203,'D',0,04,0223,'4','P',0,0223,';','P',0,0223,'D','P',0205,034,0203,'4',0,0,0203,';',0,0,0203,'D',0,04,0223,'6','P',0,0223,'=','P',0,0223,'E','P',0201,'<',0203,'6',0,0,0203,'=',0,0,0203,'E',0,04,0223,'4','P',0,0223,';','P',0,0223,'D','P',0201,'<',0203,'4',0,0,0203,';',0,0,0203,'D',0,04,0223,'6','P',0,0223,'=','P',0,0223,'E','P',0201,'<',0203,'6',0,0,0203,'=',0,0,0203,'E',0,04,0223,'=','P',0,0223,'@','P',0,0223,'D','P',0201,'<',0203,'=',0,0,0203,'@',0,0,0203,'D',0,04,0223,'B','P',0,0223,'9','P',0,0223,'2','P','`',0223,'2','@',0,0223,'9','@',0,0223,'B','@',0202,'|',0203,'B','@',0,0203,'9','@',0,0203,'2','@',0,0203,'2',0,0,0203,'9',0,0,0203,'B',0,04,0223,'6','P',0,0223,'>','P',0,0223,'E','P',0202,034,0203,'6',0,0,0203,'>',0,0,0203,'E',0,04,0223,'@','P',0,0223,'8','P',0,0223,'D','P',0204,'<',0203,'@',0,0,0203,'8',0,0,0203,'D',0,04,0223,'8','P',0,0223,'@','P',0,0223,';','P',0202,034,0203,'8',0,0,0203,'@',0,0,0203,';',0,04,0223,'2','P',0,0223,'>','P',0,0223,'E','P',0205,'|',0203,'2',0,0,0203,'>',0,0,0203,'E',0,04,0223,'@','P',0,0223,'4','P',0134,0203,'@',0,0,0203,'4',0,04,0223,'B','S',0,0223,'6','S',0134,0203,'B',0,0,0203,'6',0,04,0223,'D','W',0,0223,'8','W',0134,0203,'D',0,0,0203,'8',0,04,0223,'E','[',0,0223,'9','[',0134,0203,'E',0,0,0203,'9',0,04,0223,'G','_',0,0223,';','_',0134,0203,'G',0,0,0203,';',0,04,0223,'I','b',0,0223,'=','b',0134,0203,'I',0,0,0203,'=',0,04,0223,'J','f',0,0223,'>','f',0134,0203,'J',0,0,0203,'>',0,04,0223,'@','j',0,0223,'L','j',0134,0203,'@',0,0,0203,'L',0,0207,'D',0223,'*','g',0,0223,'6','g',0,0223,'B','g',',',0203,'*',0,0,0203,'6',0,0,0203,'B',0,04,0223,'E','f',0,0223,'9','f',0,0223,'-','f',',',0203,'E',0,0,0203,'9',0,0,0203,'-',0,04,0223,'G','e',0,0223,';','e',0,0223,'/','e',',',0203,'G',0,0,0203,';',0,0,0203,'/',0,04,0223,'1','d',0,0223,'=','d',0,0223,'I','d',',',0203,'1',0,0,0203,'=',0,0,0203,'I',0,04,0223,'4','i',0,0223,'@','i',0,0223,'L','i',',',0203,'4',0,0,0203,'@',0,0,0203,'L',0,04,0223,'6','i',0,0223,'B','i',0,0223,'N','i',',',0203,'6',0,0,0203,'B',0,0,0203,'N',0,04,0223,'1','a',0,0223,'=','a',0,0223,'I','a',',',0203,'1',0,0,0203,'=',0,0,0203,'I',0,04,0223,'2','a',0,0223,'>','a',0,0223,'J','a',',',0203,'2',0,0,0203,'>',0,0,0203,'J',0,04,0223,'L','f',0,0223,'@','f',0,0223,'4','f',0134,0203,'L',0,0,0203,'@',0,0,0203,'4',0,04,0223,'N','i',0,0223,'B','i',0,0223,'6','i',',',0203,'N',0,0,0203,'B',0,0,0203,'6',0,0207,'t',0223,'G','q',0,0223,';','q',0,0223,'/','q',',',0203,'G',0,0,0203,';',0,0,0203,'/',0,04,0223,'I','Z',0,0223,'=','Z',0,0223,'1','Z',',',0203,'I',0,0,0203,'=',0,0,0203,'1',0,04,0223,'J','Z',0,0223,'>','Z',0,0223,'2','Z',',',0203,'J',0,0,0203,'>',0,0,0203,'2',0,04,0223,'I','q',0,0223,'=','q',0,0223,'1','q',',',0203,'I',0,0,0203,'=',0,0,0203,'1',0,04,0223,'J','Z',0,0223,'>','Z',0,0223,'2','Z',',',0203,'J',0,0,0203,'>',0,0,0203,'2',0,04,0223,'L','Z',0,0223,'@','Z',0,0223,'4','Z',',',0203,'L',0,0,0203,'@',0,0,0203,'4',0,04,0223,'N','n',0,0223,'B','n',0,0223,'6','n',',',0203,'N',0,0,0203,'B',0,0,0203,'6',0,04,0223,'J','d',0,0223,'>','d',0,0223,'2','d',',',0203,'J',0,0,0203,'>',0,0,0203,'2',0,04,0223,'I','n',0,0223,'=','n',0,0223,'1','n',',',0203,'I',0,0,0203,'=',0,0,0203,'1',0,04,0223,'L','d',0,0223,'@','d',0,0223,'4','d',',',0203,'L',0,0,0203,'@',0,0,0203,'4',0,04,0223,'J','n',0,0223,'>','n',0,0223,'2','n',',',0203,'J',0,0,0203,'>',0,0,0203,'2',0,04,0223,'I','d',0,0223,'=','d',0,0223,'1','d','(',0203,'I',0,0,0203,'=',0,0,0203,'1',0,04,0263,'u',0177,0202,'$',0263,'t',0,0347,'@',0223,'C','g',0,0223,'7','g',0,0223,'+','g',',',0203,'C',0,0,0203,'7',0,0,0203,'+',0,04,0223,'E','f',0,0223,'9','f',0,0223,'-','f',',',0203,'E',0,0,0203,'9',0,0,0203,'-',0,04,0223,'G','e',0,0223,';','e',0,0223,'/','e',',',0203,'G',0,0,0203,';',0,0,0203,'/',0,04,0223,'J','d',0,0223,'>','d',0,0223,'2','d',',',0203,'J',0,0,0203,'>',0,0,0203,'2',0,04,0223,'N','i',0,0223,'B','i',0,0223,'6','i',0134,0203,'N',0,0,0203,'B',0,0,0203,'6',0,04,0223,'L','a',0,0223,'@','a',0,0223,'4','a',',',0203,'L',0,0,0203,'@',0,0,0203,'4',0,04,0223,'J','a',0,0223,'>','a',0,0223,'2','a',',',0203,'J',0,0,0203,'>',0,0,0203,'2',0,04,0223,'L','f',0,0223,'@','f',0,0223,'4','f',0134,0203,'L',0,0,0203,'@',0,0,0203,'4',0,04,0223,'N','i',0,0223,'B','i',0,0223,'6','i',',',0203,'N',0,0,0203,'B',0,0,0203,'6',0,0207,'t',0223,'G','q',0,0223,';','q',0,0223,'/','q',',',0203,'G',0,0,0203,';',0,0,0203,'/',0,04,0223,'I','Z',0,0223,'=','Z',0,0223,'1','Z',',',0203,'I',0,0,0203,'=',0,0,0203,'1',0,04,0223,'J','Z',0,0223,'>','Z',0,0223,'2','Z',',',0203,'J',0,0,0203,'>',0,0,0203,'2',0,04,0223,'I','q',0,0223,'=','q',0,0223,'1','q',',',0203,'I',0,0,0203,'=',0,0,0203,'1',0,04,0223,'J','Z',0,0223,'>','Z',0,0223,'2','Z',',',0203,'J',0,0,0203,'>',0,0,0203,'2',0,04,0223,'L','Z',0,0223,'@','Z',0,0223,'4','Z',',',0203,'L',0,0,0203,'@',0,0,0203,'4',0,04,0223,'N','n',0,0223,'B','n',0,0223,'6','n',',',0203,'N',0,0,0203,'B',0,0,0203,'6',0,04,0223,'J','d',0,0223,'>','d',0,0223,'2','d',',',0203,'J',0,0,0203,'>',0,0,0203,'2',0,04,0223,'I','n',0,0223,'=','n',0,0223,'1','n',',',0203,'I',0,0,0203,'=',0,0,0203,'1',0,04,0223,'L','d',0,0223,'@','d',0,0223,'4','d',',',0203,'L',0,0,0203,'@',0,0,0203,'4',0,04,0223,'J','n',0,0223,'>','n',0,0223,'2','n',',',0203,'J',0,0,0203,'>',0,0,0203,'2',0,04,0223,'I','d',0,0223,'=','d',0,0223,'1','d',',',0203,'I',0,0,0203,'=',0,0,0203,'1',0,0230,04,0223,'E','P',0,0223,'6','P',0,0223,'=','P',0205,'|',0203,'E',0,0,0203,'=',0,04,0223,'E','P',0,0223,'>','P',0205,'|',0203,'6',0,0,0203,'E',0,0,0203,'>',0,04,0223,'4','P',0,0223,';','P',0,0223,'D','P',0205,'|',0203,'4',0,0,0203,';',0,0,0203,'D',0,04,0223,'2','P',0,0223,'9','P',0,0223,'B','P',0204,'<',0203,'2',0,0,0203,'9',0,0,0203,'B',0,04,0223,'@','P',0,0223,'0','P',0,0223,'7','P',0201,'<',0203,'@',0,0,0203,'0',0,0,0203,'7',0,04,0223,'9','P',0,0223,'=','P',0,0223,'B','P',0202,'|',0203,'9',0,0,0203,'B',0,04,0223,'6','P',0,0223,'E','P',0202,'|',0203,'=',0,0,0203,'6',0,0,0203,'E',0,04,0223,'E','P',0,0223,'6','P',0,0223,'>','P',0205,'|',0203,'E',0,0,0203,'6',0,0,0203,'>',0,04,0223,'2','P',0,0223,'>','P',0,0223,'E','P',0205,'|',0203,'2',0,0,0203,'>',0,0,0203,'E',0,04,0223,'D','P',0,0223,'8','P',0,0223,'@','P',0205,'|',0203,'D',0,0,0203,'8',0,0,0203,'@',0,04,0223,'B','P',0,0223,'9','P',0,0223,'>','P',0202,'|',0203,'9',0,04,0223,'2','P',0202,'|',0203,'B',0,0,0203,'>',0,0,0203,'2',0,04,0223,';','P',0,0223,'D','P',0205,'|',0203,';',0,0,0203,'D',0,04,0223,'4','P',0,0223,';','P',0,0223,'D','P',0205,034,0203,'4',0,0,0203,';',0,0,0203,'D',0,04,0223,'6','P',0,0223,'=','P',0,0223,'E','P',0201,'<',0203,'6',0,0,0203,'=',0,0,0203,'E',0,04,0223,'4','P',0,0223,';','P',0,0223,'D','P',0201,'<',0203,'4',0,0,0203,';',0,0,0203,'D',0,04,0223,'6','P',0,0223,'=','P',0,0223,'E','P',0201,'<',0203,'6',0,0,0203,'=',0,0,0203,'E',0,04,0223,'=','P',0,0223,'@','P',0,0223,'D','P',0201,'<',0203,'=',0,0,0203,'@',0,0,0203,'D',0,04,0223,'B','P',0,0223,'9','P',0,0223,'2','P','`',0223,'2','@',0,0223,'9','@',0,0223,'B','@',0202,'|',0203,'B','@',0,0203,'9','@',0,0203,'2','@',0,0203,'2',0,0,0203,'9',0,0,0203,'B',0,04,0223,'6','P',0,0223,'>','P',0,0223,'E','P',0202,034,0203,'6',0,0,0203,'>',0,0,0203,'E',0,04,0223,'@','P',0,0223,'8','P',0,0223,'D','P',0204,'<',0203,'@',0,0,0203,'8',0,0,0203,'D',0,04,0223,'8','P',0,0223,'@','P',0,0223,';','P',0202,034,0203,'8',0,0,0203,'@',0,0,0203,';',0,04,0223,'2','P',0,0223,'>','P',0,0223,'E','P',0205,'|',0203,'2',0,0,0203,'>',0,0,0203,'E',0,04,0223,'@','P',0,0223,'4','P',0134,0203,'@',0,0,0203,'4',0,04,0223,'B','S',0,0223,'6','S',0134,0203,'B',0,0,0203,'6',0,04,0223,'D','W',0,0223,'8','W',0134,0203,'D',0,0,0203,'8',0,04,0223,'E','[',0,0223,'9','[',0134,0203,'E',0,0,0203,'9',0,04,0223,'G','_',0,0223,';','_',0134,0203,'G',0,0,0203,';',0,04,0223,'I','b',0,0223,'=','b',0134,0203,'I',0,0,0203,'=',0,04,0223,'J','f',0,0223,'>','f',0134,0203,'J',0,0,0203,'>',0,04,0223,'@','j',0,0223,'L','j',0134,0203,'@',0,0,0203,'L',0,0207,'D',0223,'*','g',0,0223,'6','g',0,0223,'B','g',',',0203,'*',0,0,0203,'6',0,0,0203,'B',0,04,0223,'E','f',0,0223,'9','f',0,0223,'-','f',',',0203,'E',0,0,0203,'9',0,0,0203,'-',0,04,0223,'G','e',0,0223,';','e',0,0223,'/','e',',',0203,'G',0,0,0203,';',0,0,0203,'/',0,04,0223,'1','d',0,0223,'=','d',0,0223,'I','d',',',0203,'1',0,0,0203,'=',0,0,0203,'I',0,04,0223,'4','i',0,0223,'@','i',0,0223,'L','i',',',0203,'4',0,0,0203,'@',0,0,0203,'L',0,04,0223,'6','i',0,0223,'B','i',0,0223,'N','i',',',0203,'6',0,0,0203,'B',0,0,0203,'N',0,04,0223,'1','a',0,0223,'=','a',0,0223,'I','a',',',0203,'1',0,0,0203,'=',0,0,0203,'I',0,04,0223,'2','a',0,0223,'>','a',0,0223,'J','a',',',0203,'2',0,0,0203,'>',0,0,0203,'J',0,04,0223,'L','f',0,0223,'@','f',0,0223,'4','f',0134,0203,'L',0,0,0203,'@',0,0,0203,'4',0,04,0223,'N','i',0,0223,'B','i',0,0223,'6','i',',',0203,'N',0,0,0203,'B',0,0,0203,'6',0,0207,'t',0223,'G','q',0,0223,';','q',0,0223,'/','q',',',0203,'G',0,0,0203,';',0,0,0203,'/',0,04,0223,'I','Z',0,0223,'=','Z',0,0223,'1','Z',',',0203,'I',0,0,0203,'=',0,0,0203,'1',0,04,0223,'J','Z',0,0223,'>','Z',0,0223,'2','Z',',',0203,'J',0,0,0203,'>',0,0,0203,'2',0,04,0223,'I','q',0,0223,'=','q',0,0223,'1','q',',',0203,'I',0,0,0203,'=',0,0,0203,'1',0,04,0223,'J','Z',0,0223,'>','Z',0,0223,'2','Z',',',0203,'J',0,0,0203,'>',0,0,0203,'2',0,04,0223,'L','Z',0,0223,'@','Z',0,0223,'4','Z',',',0203,'L',0,0,0203,'@',0,0,0203,'4',0,04,0223,'N','n',0,0223,'B','n',0,0223,'6','n',',',0203,'N',0,0,0203,'B',0,0,0203,'6',0,04,0223,'J','d',0,0223,'>','d',0,0223,'2','d',',',0203,'J',0,0,0203,'>',0,0,0203,'2',0,04,0223,'I','n',0,0223,'=','n',0,0223,'1','n',',',0203,'I',0,0,0203,'=',0,0,0203,'1',0,04,0223,'L','d',0,0223,'@','d',0,0223,'4','d',',',0203,'L',0,0,0203,'@',0,0,0203,'4',0,04,0223,'J','n',0,0223,'>','n',0,0223,'2','n',',',0203,'J',0,0,0203,'>',0,0,0203,'2',0,04,0223,'I','d',0,0223,'=','d',0,0223,'1','d','(',0203,'I',0,0,0203,'=',0,0,0203,'1',0,04,0263,'u',0177,0,0377,'/',0,'M','T','r','k',0,0,01,0312,0,0264,0,0,0,0304,'Q',0,0264,012,037,0,0264,'[',02,0,0264,']',0,0,0377,'Y',02,0,0,0,0264,07,'n',0,0264,'n',0177,030,0264,'d',0,0,0264,'e',0,034,0264,06,02,0,0264,'&',0,034,0264,'d',0177,0,0264,'e',0177,'P',0344,0,'@',030,0264,01,0,0201,'H',0264,'t',0,0370,0,0224,036,'n',0,0224,'*','n',0214,0,0224,036,'@',0,0224,'*','@',0205,'|',0204,036,'@',0,0204,'*','@',0,0204,036,0,0,0204,'*',0,04,0224,034,'n',0,0224,'(','n',0202,034,0204,034,0,0,0204,'(',0,04,0224,'&','n',0,0224,032,'n',0202,034,0204,'&',0,0,0204,032,0,04,0224,034,'n',0,0224,'(','n',0201,'<',0204,034,0,0,0204,'(',0,0340,04,0224,'*','n',0,0224,036,'n',0213,'t',0204,036,0,014,0224,'*','@',0,0224,036,'n',0213,'x',0204,036,0,04,0204,'*','@',0,0204,'*',0,0,0264,'u',0177,'d',0264,'t',0,0370,0,0224,036,'n',0,0224,'*','n',0214,0,0224,036,'@',0,0224,'*','@',0205,'|',0204,036,'@',0,0204,'*','@',0,0204,036,0,0,0204,'*',0,04,0224,034,'n',0,0224,'(','n',0202,034,0204,034,0,0,0204,'(',0,04,0224,'&','n',0,0224,032,'n',0202,034,0204,'&',0,0,0204,032,0,04,0224,034,'n',0,0224,'(','n',0201,'<',0204,034,0,0,0204,'(',0,0340,04,0224,'*','n',0,0224,036,'n',0213,'t',0204,036,0,014,0224,'*','@',0,0224,036,'n',0213,'x',0204,036,0,04,0204,'*','@',0,0204,'*',0,0,0264,'u',0177,0202,'$',0264,'t',0,0370,0,0224,036,'n',0,0224,'*','n',0214,0,0224,036,'@',0,0224,'*','@',0205,'|',0204,036,'@',0,0204,'*','@',0,0204,036,0,0,0204,'*',0,04,0224,034,'n',0,0224,'(','n',0202,034,0204,034,0,0,0204,'(',0,04,0224,'&','n',0,0224,032,'n',0202,034,0204,'&',0,0,0204,032,0,04,0224,034,'n',0,0224,'(','n',0201,'<',0204,034,0,0,0204,'(',0,0340,04,0224,'*','n',0,0224,036,'n',0213,'t',0204,036,0,014,0224,'*','@',0,0224,036,'n',0213,'x',0204,036,0,04,0204,'*','@',0,0204,'*',0,0,0264,'u',0177,0,0377,'/',0,'M','T','r','k',0,0,03,0252,0,0265,0,0,0,0305,016,0,0265,012,'S',0,0265,'[',05,0,0265,']',0,0,0377,'Y',02,0,0,0,0265,07,'^',0,0265,'n',0177,030,0265,'d',0,0,0265,'e',0,034,0265,06,02,0,0265,'&',0,034,0265,'d',0177,0,0265,'e',0177,'P',0345,0,'@',030,0265,01,0,0201,'H',0265,'t',0,0201,0300,0,0225,'>',0177,0202,034,0205,'>',0,04,0225,'E',0177,0204,'<',0205,'E',0,04,0225,'D',0177,0,0225,'G',0177,0204,'<',0205,'D',0,0,0205,'G',0,04,0225,'@',0177,0,0225,'G',0177,'`',0225,'@','@',0,0225,'G','@',0205,034,0205,'@','@',0,0205,'G','@',0,0205,'@',0,0,0205,'G',0,04,0225,'I',0177,0201,'<',0205,'I',0,04,0225,'G',0177,0201,'<',0205,'G',0,04,0225,'I',0177,0,0225,'E',0177,0201,'<',0205,'I',0,0,0205,'E',0,04,0225,'G',0177,0,0225,'D',0177,0201,'<',0205,'G',0,0,0205,'D',0,04,0225,'B',0177,0,0225,'E',0177,'`',0225,'B','@',0,0225,'E','@',0202,034,0205,'B','@',0,0205,'E','@',0,0205,'B',0,0,0205,'E',0,04,0225,'I',0177,0202,'|',0205,'I',0,04,0225,'E',0177,0201,'@',0225,'D',0177,0134,0205,'E',0,'d',0225,'E',0177,0134,0205,'D',0,'d',0225,'D',0177,0134,0205,'E',0,04,0225,'=',0177,0,0225,'I',0177,0201,'<',0205,'D',0,04,0225,'=','@',0,0225,'I','@',0202,' ',0225,'E',0177,0134,0205,'=','@',0,0205,'I','@',0,0205,'=',0,0,0205,'I',0,'d',0225,'G',0177,0134,0205,'E',0,'d',0225,'D',0177,0134,0205,'G',0,'d',0225,'@',0177,0134,0205,'D',0,'d',0225,'D',0177,0134,0205,'@',0,'d',0225,'E',0177,0134,0205,'D',0,0201,'@',0205,'E',0,0230,0,0265,'u',0177,'d',0265,'t',0,0201,0300,0,0225,'>',0177,0202,034,0205,'>',0,04,0225,'E',0177,0204,'<',0205,'E',0,04,0225,'D',0177,0,0225,'G',0177,0204,'<',0205,'D',0,0,0205,'G',0,04,0225,'@',0177,0,0225,'G',0177,'`',0225,'@','@',0,0225,'G','@',0205,034,0205,'@','@',0,0205,'G','@',0,0205,'@',0,0,0205,'G',0,04,0225,'I',0177,0201,'<',0205,'I',0,04,0225,'G',0177,0201,'<',0205,'G',0,04,0225,'I',0177,0,0225,'E',0177,0201,'<',0205,'I',0,0,0205,'E',0,04,0225,'G',0177,0,0225,'D',0177,0201,'<',0205,'G',0,0,0205,'D',0,04,0225,'B',0177,0,0225,'E',0177,'`',0225,'B','@',0,0225,'E','@',0202,034,0205,'B','@',0,0205,'E','@',0,0205,'B',0,0,0205,'E',0,04,0225,'I',0177,0202,'|',0205,'I',0,04,0225,'E',0177,0201,'@',0225,'D',0177,0134,0205,'E',0,'d',0225,'E',0177,0134,0205,'D',0,'d',0225,'D',0177,0134,0205,'E',0,04,0225,'=',0177,0,0225,'I',0177,0201,'<',0205,'D',0,04,0225,'=','@',0,0225,'I','@',0202,' ',0225,'E',0177,0134,0205,'=','@',0,0205,'I','@',0,0205,'=',0,0,0205,'I',0,'d',0225,'G',0177,0134,0205,'E',0,'d',0225,'D',0177,0134,0205,'G',0,'d',0225,'@',0177,0134,0205,'D',0,'d',0225,'D',0177,0134,0205,'@',0,'d',0225,'E',0177,0134,0205,'D',0,0201,'@',0205,'E',0,0230,0,0265,'u',0177,0202,'$',0265,'t',0,0201,0300,0,0225,'>',0177,0202,034,0205,'>',0,04,0225,'E',0177,0204,'<',0205,'E',0,04,0225,'D',0177,0,0225,'G',0177,0204,'<',0205,'D',0,0,0205,'G',0,04,0225,'@',0177,0,0225,'G',0177,'`',0225,'@','@',0,0225,'G','@',0205,034,0205,'@','@',0,0205,'G','@',0,0205,'@',0,0,0205,'G',0,04,0225,'I',0177,0201,'<',0205,'I',0,04,0225,'G',0177,0201,'<',0205,'G',0,04,0225,'I',0177,0,0225,'E',0177,0201,'<',0205,'I',0,0,0205,'E',0,04,0225,'G',0177,0,0225,'D',0177,0201,'<',0205,'G',0,0,0205,'D',0,04,0225,'B',0177,0,0225,'E',0177,'`',0225,'B','@',0,0225,'E','@',0202,034,0205,'B','@',0,0205,'E','@',0,0205,'B',0,0,0205,'E',0,04,0225,'I',0177,0202,'|',0205,'I',0,04,0225,'E',0177,0201,'@',0225,'D',0177,0134,0205,'E',0,'d',0225,'E',0177,0134,0205,'D',0,'d',0225,'D',0177,0134,0205,'E',0,04,0225,'=',0177,0,0225,'I',0177,0201,'<',0205,'D',0,04,0225,'=','@',0,0225,'I','@',0202,' ',0225,'E',0177,0134,0205,'=','@',0,0205,'I','@',0,0205,'=',0,0,0205,'I',0,'d',0225,'G',0177,0134,0205,'E',0,'d',0225,'D',0177,0134,0205,'G',0,'d',0225,'@',0177,0134,0205,'D',0,'d',0225,'D',0177,0134,0205,'@',0,'d',0225,'E',0177,0134,0205,'D',0,0201,'@',0205,'E',0,0230,0,0265,'u',0177,0,0377,'/',0,'M','T','r','k',0,0,013,0242,0,0271,0,0,0,0311,030,0,0271,012,'@',0,0271,'[',05,0,0271,']',0,0,0377,'Y',02,0,0,0,0271,07,'_',0,0271,'n',0177,030,0271,'d',0,0,0271,'e',0,034,0271,06,02,0,0271,'&',0,034,0271,'d',0177,0,0271,'e',0177,'P',0351,0,'@',030,0271,01,0,0201,'H',0271,'t',0,0201,'@',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0201,'t',0231,'&','n',',',0211,'&',0,0201,'t',0231,'&','n',',',0211,'&',0,0201,024,0231,'&','e',',',0211,'&',0,04,0231,'&','Z',',',0211,'&',0,04,0231,'&','n',',',0211,'&',0,0201,'t',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0201,'t',0231,'&','i',',',0211,'&',0,04,0231,'&','e',',',0211,'&',0,'d',0231,'&','i',',',0211,'&',0,04,0231,'&','e',',',0211,'&',0,'d',0231,'&','i',',',0211,'&',0,04,0231,'&','Z',',',0211,'&',0,0203,04,0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0203,04,0231,'&','Z',',',0211,'&',0,04,0231,'&','i',',',0211,'&',0,0201,'D',0231,'&','Z',',',0211,'&',0,0201,'D',0231,'&','h',',',0211,'&',0,'4',0231,'&','b',',',0211,'&',0,0201,024,0231,'&','h',',',0211,'&',0,0201,'t',0231,'&','h',',',0211,'&',0,'4',0231,'&','b',',',0211,'&',0,0201,024,0231,'&','h',',',0211,'&',0,0204,'t',0231,'&','h',',',0211,'&',0,'4',0231,'&','b',',',0211,'&',0,0201,024,0231,'&','h',',',0211,'&',0,0201,'t',0231,'&','h',',',0211,'&',0,'4',0231,'&','b',',',0211,'&',0,0201,024,0231,'&','h',',',0211,'&',0,0206,'4',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0203,04,0231,'&','Z',',',0211,'&',0,04,0231,'&','i',',',0211,'&',0,0201,'D',0231,'&','Z',',',0211,'&',0,0203,04,0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,04,0231,'&','Z',',',0211,'&',0,0202,'$',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0203,04,0231,'&','Z',',',0211,'&',0,04,0231,'&','i',',',0211,'&',0,0201,'D',0231,'&','Z',',',0211,'&',0,0203,04,0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,04,0231,'&','Z',',',0211,'&',0,0202,'$',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0203,04,0231,'&','Z',',',0211,'&',0,04,0231,'&','i',',',0211,'&',0,0201,'D',0231,'&','Z',',',0211,'&',0,0201,'D',0231,'&','h',',',0211,'&',0,'4',0231,'&','b',',',0211,'&',0,0201,024,0231,'&','h',',',0211,'&',0,0201,'t',0231,'&','h',',',0211,'&',0,'4',0231,'&','b',',',0211,'&',0,0201,024,0231,'&','h',',',0211,'&',0,0204,'t',0231,'&','h',',',0211,'&',0,'4',0231,'&','b',',',0211,'&',0,0201,024,0231,'&','h',',',0211,'&',0,0201,'t',0231,'&','h',',',0211,'&',0,'4',0231,'&','b',',',0211,'&',0,0201,024,0231,'&','h',',',0211,'&',0,0204,'p',0271,'u',0177,'d',0271,'t',0,0201,'@',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0201,'t',0231,'&','n',',',0211,'&',0,0201,'t',0231,'&','n',',',0211,'&',0,0201,024,0231,'&','e',',',0211,'&',0,04,0231,'&','Z',',',0211,'&',0,04,0231,'&','n',',',0211,'&',0,0201,'t',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0201,'t',0231,'&','i',',',0211,'&',0,04,0231,'&','e',',',0211,'&',0,'d',0231,'&','i',',',0211,'&',0,04,0231,'&','e',',',0211,'&',0,'d',0231,'&','i',',',0211,'&',0,04,0231,'&','Z',',',0211,'&',0,0203,04,0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0203,04,0231,'&','Z',',',0211,'&',0,04,0231,'&','i',',',0211,'&',0,0201,'D',0231,'&','Z',',',0211,'&',0,0201,'D',0231,'&','h',',',0211,'&',0,'4',0231,'&','b',',',0211,'&',0,0201,024,0231,'&','h',',',0211,'&',0,0201,'t',0231,'&','h',',',0211,'&',0,'4',0231,'&','b',',',0211,'&',0,0201,024,0231,'&','h',',',0211,'&',0,0204,'t',0231,'&','h',',',0211,'&',0,'4',0231,'&','b',',',0211,'&',0,0201,024,0231,'&','h',',',0211,'&',0,0201,'t',0231,'&','h',',',0211,'&',0,'4',0231,'&','b',',',0211,'&',0,0201,024,0231,'&','h',',',0211,'&',0,0206,'4',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0203,04,0231,'&','Z',',',0211,'&',0,04,0231,'&','i',',',0211,'&',0,0201,'D',0231,'&','Z',',',0211,'&',0,0203,04,0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,04,0231,'&','Z',',',0211,'&',0,0202,'$',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0203,04,0231,'&','Z',',',0211,'&',0,04,0231,'&','i',',',0211,'&',0,0201,'D',0231,'&','Z',',',0211,'&',0,0203,04,0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,04,0231,'&','Z',',',0211,'&',0,0202,'$',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0203,04,0231,'&','Z',',',0211,'&',0,04,0231,'&','i',',',0211,'&',0,0201,'D',0231,'&','Z',',',0211,'&',0,0201,'D',0231,'&','h',',',0211,'&',0,'4',0231,'&','b',',',0211,'&',0,0201,024,0231,'&','h',',',0211,'&',0,0201,'t',0231,'&','h',',',0211,'&',0,'4',0231,'&','b',',',0211,'&',0,0201,024,0231,'&','h',',',0211,'&',0,0204,'t',0231,'&','h',',',0211,'&',0,'4',0231,'&','b',',',0211,'&',0,0201,024,0231,'&','h',',',0211,'&',0,0201,'t',0231,'&','h',',',0211,'&',0,'4',0231,'&','b',',',0211,'&',0,0201,024,0231,'&','h',',',0211,'&',0,0204,'p',0271,'u',0177,0202,'$',0271,'t',0,0201,'@',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0201,'t',0231,'&','n',',',0211,'&',0,0201,'t',0231,'&','n',',',0211,'&',0,0201,024,0231,'&','e',',',0211,'&',0,04,0231,'&','Z',',',0211,'&',0,04,0231,'&','n',',',0211,'&',0,0201,'t',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0201,'t',0231,'&','i',',',0211,'&',0,04,0231,'&','e',',',0211,'&',0,'d',0231,'&','i',',',0211,'&',0,04,0231,'&','e',',',0211,'&',0,'d',0231,'&','i',',',0211,'&',0,04,0231,'&','Z',',',0211,'&',0,0203,04,0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0203,04,0231,'&','Z',',',0211,'&',0,04,0231,'&','i',',',0211,'&',0,0201,'D',0231,'&','Z',',',0211,'&',0,0201,'D',0231,'&','h',',',0211,'&',0,'4',0231,'&','b',',',0211,'&',0,0201,024,0231,'&','h',',',0211,'&',0,0201,'t',0231,'&','h',',',0211,'&',0,'4',0231,'&','b',',',0211,'&',0,0201,024,0231,'&','h',',',0211,'&',0,0204,'t',0231,'&','h',',',0211,'&',0,'4',0231,'&','b',',',0211,'&',0,0201,024,0231,'&','h',',',0211,'&',0,0201,'t',0231,'&','h',',',0211,'&',0,'4',0231,'&','b',',',0211,'&',0,0201,024,0231,'&','h',',',0211,'&',0,0206,'4',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0202,'T',0231,'&','n',',',0211,'&',0,0203,04,0231,'&','Z',',',0211,'&',0,04,0231,'&','i',',',0211,'&',0,0201,'D',0231,'&','Z',',',0211,'&',0,0203,04,0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,04,0231,'&','Z',',',0211,'&',0,0202,'$',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0203,04,0231,'&','Z',',',0211,'&',0,04,0231,'&','i',',',0211,'&',0,0201,'D',0231,'&','Z',',',0211,'&',0,0203,04,0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,04,0231,'&','Z',',',0211,'&',0,0202,'$',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0202,'T',0231,'&','Z',',',0211,'&',0,0203,04,0231,'&','Z',',',0211,'&',0,04,0231,'&','i',',',0211,'&',0,0201,'D',0231,'&','Z',',',0211,'&',0,0201,'D',0231,'&','h',',',0211,'&',0,'4',0231,'&','b',',',0211,'&',0,0201,024,0231,'&','h',',',0211,'&',0,0201,'t',0231,'&','h',',',0211,'&',0,'4',0231,'&','b',',',0211,'&',0,0201,024,0231,'&','h',',',0211,'&',0,0204,'t',0231,'&','h',',',0211,'&',0,'4',0231,'&','b',',',0211,'&',0,0201,024,0231,'&','h',',',0211,'&',0,0201,'t',0231,'&','h',',',0211,'&',0,'4',0231,'&','b',',',0211,'&',0,0201,024,0231,'&','h',',',0211,'&',0,0204,'p',0271,'u',0177,0,0377,'/',0,'M','T','r','k',0,0,034,'s',0,0271,0,0,0,0311,030,0,0271,012,'@',0,0271,'[',05,0,0271,']',0,0,0377,'Y',02,0,0,0,0271,07,'_',0,0271,'n',0177,030,0271,'d',0,0,0271,'e',0,034,0271,06,02,0,0271,'&',0,034,0271,'d',0177,0,0271,'e',0177,'P',0351,0,'@',030,0271,01,0,0201,'H',0231,'$','n',0,0271,'t',0,',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$','f','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$',']',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$','f','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$','W',',',0211,'$',0,'4',0231,'$',']',',',0211,'$',0,'4',0231,'$','W',',',0211,'$',0,'4',0231,'$',']',',',0211,'$',0,'4',0231,'$','W',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$','f','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$',']',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$','f','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$','W',',',0211,'$',0,'4',0231,'$',']',',',0211,'$',0,'4',0231,'$','W',',',0211,'$',0,'4',0231,'$',']',',',0211,'$',0,'4',0231,'$','W',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$','f','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$',']',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$','f','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$','W',',',0211,'$',0,'4',0231,'$',']',',',0211,'$',0,'4',0231,'$','W',',',0211,'$',0,'4',0231,'$',']',',',0211,'$',0,'4',0231,'$','W',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$','f','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$',']',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$','f','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$','W',',',0211,'$',0,'4',0231,'$',']',',',0211,'$',0,'4',0231,'$','W',',',0211,'$',0,'4',0231,'$',']',',',0211,'$',0,'4',0231,'$','W',',',0211,'$',0,'0',0271,'u',0177,'d',0231,'$','n',0,0271,'t',0,',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$','f','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$',']',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$','f','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$','W',',',0211,'$',0,'4',0231,'$',']',',',0211,'$',0,'4',0231,'$','W',',',0211,'$',0,'4',0231,'$',']',',',0211,'$',0,'4',0231,'$','W',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$','f','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$',']',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$','f','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$','W',',',0211,'$',0,'4',0231,'$',']',',',0211,'$',0,'4',0231,'$','W',',',0211,'$',0,'4',0231,'$',']',',',0211,'$',0,'4',0231,'$','W',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$','f','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$',']',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$','f','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$','W',',',0211,'$',0,'4',0231,'$',']',',',0211,'$',0,'4',0231,'$','W',',',0211,'$',0,'4',0231,'$',']',',',0211,'$',0,'4',0231,'$','W',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$','f','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$',']',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$','f','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$','W',',',0211,'$',0,'4',0231,'$',']',',',0211,'$',0,'4',0231,'$','W',',',0211,'$',0,'4',0231,'$',']',',',0211,'$',0,'4',0231,'$','W',',',0211,'$',0,'0',0271,'u',0177,0202,'$',0231,'$','n',0,0271,'t',0,',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$','f','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$',']',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$','f','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$','W',',',0211,'$',0,'4',0231,'$',']',',',0211,'$',0,'4',0231,'$','W',',',0211,'$',0,'4',0231,'$',']',',',0211,'$',0,'4',0231,'$','W',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$','f','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$',']',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$','f','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$','W',',',0211,'$',0,'4',0231,'$',']',',',0211,'$',0,'4',0231,'$','W',',',0211,'$',0,'4',0231,'$',']',',',0211,'$',0,'4',0231,'$','W',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,0201,024,0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n',',',0211,'$',0,'4',0231,'$','f',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$','f','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$',']',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$','f','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$','W',',',0211,'$',0,'4',0231,'$',']',',',0211,'$',0,'4',0231,'$','W',',',0211,'$',0,'4',0231,'$',']',',',0211,'$',0,'4',0231,'$','W',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$','f','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$',']',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$','f','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$','n','0',0211,'$',0,'0',0231,'$',']',',',0211,'$',0,'4',0231,'$','W',',',0211,'$',0,'4',0231,'$',']',',',0211,'$',0,'4',0231,'$','W',',',0211,'$',0,'4',0231,'$',']',',',0211,'$',0,'4',0231,'$','W',',',0211,'$',0,'0',0271,'u',0177,0,0377,'/',0,'M','T','r','k',0,0,016,0325,0,0271,0,0,0,0311,030,0,0271,012,'@',0,0271,'[',05,0,0271,']',0,0,0377,'Y',02,0,0,0,0271,07,'_',0,0271,'n',0177,030,0271,'d',0,0,0271,'e',0,034,0271,06,02,0,0271,'&',0,034,0271,'d',0177,0,0271,'e',0177,'P',0351,0,'@',030,0271,01,0,0201,'H',0231,'1','v',0,0271,'t',0,0201,'@',0231,'5','d',0201,'<',0211,'1',0,0,0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'1','i',0201,'<',0211,'1',0,04,0231,'5','i',0134,0211,'5',0,04,0231,'9','n',0202,034,0211,'9',0,04,0231,'1','u',0201,'<',0211,'1',0,04,0231,'1','v',0201,'@',0231,'5','d',0201,'<',0211,'1',0,0,0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'1','i',0201,'<',0211,'1',0,'d',0231,'9','n',0202,034,0211,'9',0,0201,'D',0231,'1','v',0201,'@',0231,'5','d',0201,'<',0211,'1',0,0,0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'1','v',0,0231,'1','v',0201,'@',0231,'5','d',0201,'<',0211,'1',0,0,0211,'1',0,0,0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'1','i',0201,'<',0211,'1',0,'d',0231,'9','n',0202,034,0211,'9',0,0231,'D',0231,'1','v',0201,'@',0231,'5','d',0201,'<',0211,'1',0,0,0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'1','i',0201,'<',0211,'1',0,'d',0231,'9','n',0202,034,0211,'9',0,0201,'D',0231,'1','v',0201,'@',0231,'5','d',0201,'<',0211,'1',0,0,0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'1','v',0,0231,'1','v',0201,'@',0231,'5','d',0201,'<',0211,'1',0,0,0211,'1',0,0,0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'1','i',0201,'<',0211,'1',0,'d',0231,'9','n',0202,034,0211,'9',0,0201,'D',0231,'1','v',0201,'@',0231,'5','d',0201,'<',0211,'1',0,0,0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'1','v',0,0231,'1','v',0201,'@',0231,'5','d',0201,'<',0211,'1',0,0,0211,'1',0,0,0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'1','i',0201,'<',0211,'1',0,'d',0231,'9','n',0202,034,0211,'9',0,0231,'@',0271,'u',0177,'d',0231,'1','v',0,0271,'t',0,0201,'@',0231,'5','d',0201,'<',0211,'1',0,0,0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'1','i',0201,'<',0211,'1',0,04,0231,'5','i',0134,0211,'5',0,04,0231,'9','n',0202,034,0211,'9',0,04,0231,'1','u',0201,'<',0211,'1',0,04,0231,'1','v',0201,'@',0231,'5','d',0201,'<',0211,'1',0,0,0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'1','i',0201,'<',0211,'1',0,'d',0231,'9','n',0202,034,0211,'9',0,0201,'D',0231,'1','v',0201,'@',0231,'5','d',0201,'<',0211,'1',0,0,0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'1','v',0,0231,'1','v',0201,'@',0231,'5','d',0201,'<',0211,'1',0,0,0211,'1',0,0,0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'1','i',0201,'<',0211,'1',0,'d',0231,'9','n',0202,034,0211,'9',0,0231,'D',0231,'1','v',0201,'@',0231,'5','d',0201,'<',0211,'1',0,0,0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'1','i',0201,'<',0211,'1',0,'d',0231,'9','n',0202,034,0211,'9',0,0201,'D',0231,'1','v',0201,'@',0231,'5','d',0201,'<',0211,'1',0,0,0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'1','v',0,0231,'1','v',0201,'@',0231,'5','d',0201,'<',0211,'1',0,0,0211,'1',0,0,0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'1','i',0201,'<',0211,'1',0,'d',0231,'9','n',0202,034,0211,'9',0,0201,'D',0231,'1','v',0201,'@',0231,'5','d',0201,'<',0211,'1',0,0,0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'1','v',0,0231,'1','v',0201,'@',0231,'5','d',0201,'<',0211,'1',0,0,0211,'1',0,0,0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'1','i',0201,'<',0211,'1',0,'d',0231,'9','n',0202,034,0211,'9',0,0231,'@',0271,'u',0177,0202,'$',0231,'1','v',0,0271,'t',0,0201,'@',0231,'5','d',0201,'<',0211,'1',0,0,0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'1','i',0201,'<',0211,'1',0,04,0231,'5','i',0134,0211,'5',0,04,0231,'9','n',0202,034,0211,'9',0,04,0231,'1','u',0201,'<',0211,'1',0,04,0231,'1','v',0201,'@',0231,'5','d',0201,'<',0211,'1',0,0,0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'1','i',0201,'<',0211,'1',0,'d',0231,'9','n',0202,034,0211,'9',0,0201,'D',0231,'1','v',0201,'@',0231,'5','d',0201,'<',0211,'1',0,0,0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'1','v',0,0231,'1','v',0201,'@',0231,'5','d',0201,'<',0211,'1',0,0,0211,'1',0,0,0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'1','i',0201,'<',0211,'1',0,'d',0231,'9','n',0202,034,0211,'9',0,0231,'D',0231,'1','v',0201,'@',0231,'5','d',0201,'<',0211,'1',0,0,0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'1','i',0201,'<',0211,'1',0,'d',0231,'9','n',0202,034,0211,'9',0,0201,'D',0231,'1','v',0201,'@',0231,'5','d',0201,'<',0211,'1',0,0,0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'1','v',0,0231,'1','v',0201,'@',0231,'5','d',0201,'<',0211,'1',0,0,0211,'1',0,0,0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'1','i',0201,'<',0211,'1',0,'d',0231,'9','n',0202,034,0211,'9',0,0201,'D',0231,'1','v',0201,'@',0231,'5','d',0201,'<',0211,'1',0,0,0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'1','v',0,0231,'1','v',0201,'@',0231,'5','d',0201,'<',0211,'1',0,0,0211,'1',0,0,0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'5','d',0201,'<',0211,'5',0,04,0231,'1','i',0201,'<',0211,'1',0,'d',0231,'9','n',0202,034,0211,'9',0,0231,'@',0271,'u',0177,0,0377,'/',0,'M','T','r','k',0,0,013,0336,0,0271,0,0,0,0311,030,0,0271,012,'@',0,0271,'[',05,0,0271,']',0,0,0377,'Y',02,0,0,0,0271,07,'_',0,0271,'n',0177,030,0271,'d',0,0,0271,'e',0,034,0271,06,02,0,0271,'&',0,034,0271,'d',0177,0,0271,'e',0177,'P',0351,0,'@',030,0271,01,0,0201,'H',0271,'t',0,0253,'@',0231,'2','m',',',0211,'2',0,04,0231,'2','m',',',0211,'2',0,'d',0231,'0','i',',',0211,'0',0,04,0231,'0','d',',',0211,'0',0,'d',0231,'2','m',',',0211,'2',0,04,0231,'0','i',',',0211,'0',0,04,0231,'/','m',',',0211,'/',0,04,0231,'-','i',',',0211,'-',0,0252,'d',0231,'2','i',',',0211,'2',0,04,0231,'2','d',',',0211,'2',0,04,0231,'2','m',',',0211,'2',0,0201,024,0231,'0','i',',',0211,'0',0,04,0231,'0','d',',',0211,'0',0,04,0231,'0','m',',',0211,'0',0,'4',0231,'2','m',',',0211,'2',0,04,0231,'0','i',',',0211,'0',0,04,0231,'/','m',',',0211,'/',0,04,0231,'-','i',',',0211,'-',0,04,0231,'+','s',',',0211,'+',0,'4',0231,')','p',',',0211,')',0,0201,024,0231,')','s',',',0211,')',0,0201,'t',0231,'+','s',',',0211,'+',0,'4',0231,')','p',',',0211,')',0,0201,024,0231,')','s',',',0211,')',0,'4',0231,'2','n',',',0211,'2',0,04,0231,'2','d',',',0211,'2',0,04,0231,'2','j',',',0211,'2',0,04,0231,'2','d',',',0211,'2',0,04,0231,'0','n',',',0211,'0',0,04,0231,'0','d',',',0211,'0',0,04,0231,'0','j',',',0211,'0',0,04,0231,'0','d',',',0211,'0',0,04,0231,'/','n',',',0211,'/',0,04,0231,'/','d',',',0211,'/',0,04,0231,'/','j',',',0211,'/',0,04,0231,'/','d',',',0211,'/',0,04,0231,'+','s',',',0211,'+',0,'4',0231,')','p',',',0211,')',0,0201,024,0231,')','s',',',0211,')',0,0201,'t',0231,'+','s',',',0211,'+',0,'4',0231,')','p',',',0211,')',0,0201,024,0231,')','s',',',0211,')',0,'4',0231,'2','s',',',0211,'2',0,04,0231,'2','X',',',0211,'2',0,04,0231,'2','X',',',0211,'2',0,04,0231,'0','z',',',0211,'0',0,04,0231,'0','X',',',0211,'0',0,04,0231,'0','X',',',0211,'0',0,04,0231,'2','n',',',0211,'2',0,04,0231,'2','_',',',0211,'2',0,04,0231,'0','n',',',0211,'0',0,04,0231,'0','_',',',0211,'0',0,04,0231,'/','n',',',0211,'/',0,04,0231,'/','_',',',0211,'/',0,0222,'d',0231,'2','i',',',0211,'2',0,04,0231,'2','d',',',0211,'2',0,04,0231,'2','m',',',0211,'2',0,0201,024,0231,'0','i',',',0211,'0',0,04,0231,'0','d',',',0211,'0',0,04,0231,'0','m',',',0211,'0',0,'4',0231,'2','m',',',0211,'2',0,04,0231,'0','i',',',0211,'0',0,04,0231,'/','m',',',0211,'/',0,04,0231,'-','i',',',0211,'-',0,0252,'d',0231,'2','i',',',0211,'2',0,04,0231,'2','d',',',0211,'2',0,04,0231,'2','m',',',0211,'2',0,0201,024,0231,'0','i',',',0211,'0',0,04,0231,'0','d',',',0211,'0',0,04,0231,'0','m',',',0211,'0',0,'4',0231,'2','m',',',0211,'2',0,04,0231,'0','i',',',0211,'0',0,04,0231,'/','m',',',0211,'/',0,04,0231,'-','i',',',0211,'-',0,0252,'d',0231,'2','i',',',0211,'2',0,04,0231,'2','d',',',0211,'2',0,04,0231,'2','m',',',0211,'2',0,0201,024,0231,'0','i',',',0211,'0',0,04,0231,'0','d',',',0211,'0',0,04,0231,'0','m',',',0211,'0',0,'4',0231,'2','m',',',0211,'2',0,04,0231,'0','i',',',0211,'0',0,04,0231,'/','m',',',0211,'/',0,04,0231,'-','i',',',0211,'-',0,04,0231,'+','s',',',0211,'+',0,'4',0231,')','p',',',0211,')',0,0201,024,0231,')','s',',',0211,')',0,0201,'t',0231,'+','s',',',0211,'+',0,'4',0231,')','p',',',0211,')',0,0201,024,0231,')','s',',',0211,')',0,'4',0231,'2','n',',',0211,'2',0,04,0231,'2','d',',',0211,'2',0,04,0231,'2','j',',',0211,'2',0,04,0231,'2','d',',',0211,'2',0,04,0231,'0','n',',',0211,'0',0,04,0231,'0','d',',',0211,'0',0,04,0231,'0','j',',',0211,'0',0,04,0231,'0','d',',',0211,'0',0,04,0231,'/','n',',',0211,'/',0,04,0231,'/','d',',',0211,'/',0,04,0231,'/','j',',',0211,'/',0,04,0231,'/','d',',',0211,'/',0,04,0231,'+','s',',',0211,'+',0,'4',0231,')','p',',',0211,')',0,0201,024,0231,')','s',',',0211,')',0,0201,'t',0231,'+','s',',',0211,'+',0,'4',0231,')','p',',',0211,')',0,0201,024,0231,')','s',',',0211,')',0,'4',0231,'2','s',',',0211,'2',0,04,0231,'2','X',',',0211,'2',0,04,0231,'2','X',',',0211,'2',0,04,0231,'0','z',',',0211,'0',0,04,0231,'0','X',',',0211,'0',0,04,0231,'0','X',',',0211,'0',0,04,0231,'2','n',',',0211,'2',0,04,0231,'2','_',',',0211,'2',0,04,0231,'0','n',',',0211,'0',0,04,0231,'0','_',',',0211,'0',0,04,0231,'/','n',',',0211,'/',0,04,0231,'/','_',',',0211,'/',0,0,0271,'u',0177,'d',0271,'t',0,0253,'@',0231,'2','m',',',0211,'2',0,04,0231,'2','m',',',0211,'2',0,'d',0231,'0','i',',',0211,'0',0,04,0231,'0','d',',',0211,'0',0,'d',0231,'2','m',',',0211,'2',0,04,0231,'0','i',',',0211,'0',0,04,0231,'/','m',',',0211,'/',0,04,0231,'-','i',',',0211,'-',0,0252,'d',0231,'2','i',',',0211,'2',0,04,0231,'2','d',',',0211,'2',0,04,0231,'2','m',',',0211,'2',0,0201,024,0231,'0','i',',',0211,'0',0,04,0231,'0','d',',',0211,'0',0,04,0231,'0','m',',',0211,'0',0,'4',0231,'2','m',',',0211,'2',0,04,0231,'0','i',',',0211,'0',0,04,0231,'/','m',',',0211,'/',0,04,0231,'-','i',',',0211,'-',0,04,0231,'+','s',',',0211,'+',0,'4',0231,')','p',',',0211,')',0,0201,024,0231,')','s',',',0211,')',0,0201,'t',0231,'+','s',',',0211,'+',0,'4',0231,')','p',',',0211,')',0,0201,024,0231,')','s',',',0211,')',0,'4',0231,'2','n',',',0211,'2',0,04,0231,'2','d',',',0211,'2',0,04,0231,'2','j',',',0211,'2',0,04,0231,'2','d',',',0211,'2',0,04,0231,'0','n',',',0211,'0',0,04,0231,'0','d',',',0211,'0',0,04,0231,'0','j',',',0211,'0',0,04,0231,'0','d',',',0211,'0',0,04,0231,'/','n',',',0211,'/',0,04,0231,'/','d',',',0211,'/',0,04,0231,'/','j',',',0211,'/',0,04,0231,'/','d',',',0211,'/',0,04,0231,'+','s',',',0211,'+',0,'4',0231,')','p',',',0211,')',0,0201,024,0231,')','s',',',0211,')',0,0201,'t',0231,'+','s',',',0211,'+',0,'4',0231,')','p',',',0211,')',0,0201,024,0231,')','s',',',0211,')',0,'4',0231,'2','s',',',0211,'2',0,04,0231,'2','X',',',0211,'2',0,04,0231,'2','X',',',0211,'2',0,04,0231,'0','z',',',0211,'0',0,04,0231,'0','X',',',0211,'0',0,04,0231,'0','X',',',0211,'0',0,04,0231,'2','n',',',0211,'2',0,04,0231,'2','_',',',0211,'2',0,04,0231,'0','n',',',0211,'0',0,04,0231,'0','_',',',0211,'0',0,04,0231,'/','n',',',0211,'/',0,04,0231,'/','_',',',0211,'/',0,0222,'d',0231,'2','i',',',0211,'2',0,04,0231,'2','d',',',0211,'2',0,04,0231,'2','m',',',0211,'2',0,0201,024,0231,'0','i',',',0211,'0',0,04,0231,'0','d',',',0211,'0',0,04,0231,'0','m',',',0211,'0',0,'4',0231,'2','m',',',0211,'2',0,04,0231,'0','i',',',0211,'0',0,04,0231,'/','m',',',0211,'/',0,04,0231,'-','i',',',0211,'-',0,0252,'d',0231,'2','i',',',0211,'2',0,04,0231,'2','d',',',0211,'2',0,04,0231,'2','m',',',0211,'2',0,0201,024,0231,'0','i',',',0211,'0',0,04,0231,'0','d',',',0211,'0',0,04,0231,'0','m',',',0211,'0',0,'4',0231,'2','m',',',0211,'2',0,04,0231,'0','i',',',0211,'0',0,04,0231,'/','m',',',0211,'/',0,04,0231,'-','i',',',0211,'-',0,0252,'d',0231,'2','i',',',0211,'2',0,04,0231,'2','d',',',0211,'2',0,04,0231,'2','m',',',0211,'2',0,0201,024,0231,'0','i',',',0211,'0',0,04,0231,'0','d',',',0211,'0',0,04,0231,'0','m',',',0211,'0',0,'4',0231,'2','m',',',0211,'2',0,04,0231,'0','i',',',0211,'0',0,04,0231,'/','m',',',0211,'/',0,04,0231,'-','i',',',0211,'-',0,04,0231,'+','s',',',0211,'+',0,'4',0231,')','p',',',0211,')',0,0201,024,0231,')','s',',',0211,')',0,0201,'t',0231,'+','s',',',0211,'+',0,'4',0231,')','p',',',0211,')',0,0201,024,0231,')','s',',',0211,')',0,'4',0231,'2','n',',',0211,'2',0,04,0231,'2','d',',',0211,'2',0,04,0231,'2','j',',',0211,'2',0,04,0231,'2','d',',',0211,'2',0,04,0231,'0','n',',',0211,'0',0,04,0231,'0','d',',',0211,'0',0,04,0231,'0','j',',',0211,'0',0,04,0231,'0','d',',',0211,'0',0,04,0231,'/','n',',',0211,'/',0,04,0231,'/','d',',',0211,'/',0,04,0231,'/','j',',',0211,'/',0,04,0231,'/','d',',',0211,'/',0,04,0231,'+','s',',',0211,'+',0,'4',0231,')','p',',',0211,')',0,0201,024,0231,')','s',',',0211,')',0,0201,'t',0231,'+','s',',',0211,'+',0,'4',0231,')','p',',',0211,')',0,0201,024,0231,')','s',',',0211,')',0,'4',0231,'2','s',',',0211,'2',0,04,0231,'2','X',',',0211,'2',0,04,0231,'2','X',',',0211,'2',0,04,0231,'0','z',',',0211,'0',0,04,0231,'0','X',',',0211,'0',0,04,0231,'0','X',',',0211,'0',0,04,0231,'2','n',',',0211,'2',0,04,0231,'2','_',',',0211,'2',0,04,0231,'0','n',',',0211,'0',0,04,0231,'0','_',',',0211,'0',0,04,0231,'/','n',',',0211,'/',0,04,0231,'/','_',',',0211,'/',0,0,0271,'u',0177,0202,'$',0271,'t',0,0253,'@',0231,'2','m',',',0211,'2',0,04,0231,'2','m',',',0211,'2',0,'d',0231,'0','i',',',0211,'0',0,04,0231,'0','d',',',0211,'0',0,'d',0231,'2','m',',',0211,'2',0,04,0231,'0','i',',',0211,'0',0,04,0231,'/','m',',',0211,'/',0,04,0231,'-','i',',',0211,'-',0,0252,'d',0231,'2','i',',',0211,'2',0,04,0231,'2','d',',',0211,'2',0,04,0231,'2','m',',',0211,'2',0,0201,024,0231,'0','i',',',0211,'0',0,04,0231,'0','d',',',0211,'0',0,04,0231,'0','m',',',0211,'0',0,'4',0231,'2','m',',',0211,'2',0,04,0231,'0','i',',',0211,'0',0,04,0231,'/','m',',',0211,'/',0,04,0231,'-','i',',',0211,'-',0,04,0231,'+','s',',',0211,'+',0,'4',0231,')','p',',',0211,')',0,0201,024,0231,')','s',',',0211,')',0,0201,'t',0231,'+','s',',',0211,'+',0,'4',0231,')','p',',',0211,')',0,0201,024,0231,')','s',',',0211,')',0,'4',0231,'2','n',',',0211,'2',0,04,0231,'2','d',',',0211,'2',0,04,0231,'2','j',',',0211,'2',0,04,0231,'2','d',',',0211,'2',0,04,0231,'0','n',',',0211,'0',0,04,0231,'0','d',',',0211,'0',0,04,0231,'0','j',',',0211,'0',0,04,0231,'0','d',',',0211,'0',0,04,0231,'/','n',',',0211,'/',0,04,0231,'/','d',',',0211,'/',0,04,0231,'/','j',',',0211,'/',0,04,0231,'/','d',',',0211,'/',0,04,0231,'+','s',',',0211,'+',0,'4',0231,')','p',',',0211,')',0,0201,024,0231,')','s',',',0211,')',0,0201,'t',0231,'+','s',',',0211,'+',0,'4',0231,')','p',',',0211,')',0,0201,024,0231,')','s',',',0211,')',0,'4',0231,'2','s',',',0211,'2',0,04,0231,'2','X',',',0211,'2',0,04,0231,'2','X',',',0211,'2',0,04,0231,'0','z',',',0211,'0',0,04,0231,'0','X',',',0211,'0',0,04,0231,'0','X',',',0211,'0',0,04,0231,'2','n',',',0211,'2',0,04,0231,'2','_',',',0211,'2',0,04,0231,'0','n',',',0211,'0',0,04,0231,'0','_',',',0211,'0',0,04,0231,'/','n',',',0211,'/',0,04,0231,'/','_',',',0211,'/',0,0222,'d',0231,'2','i',',',0211,'2',0,04,0231,'2','d',',',0211,'2',0,04,0231,'2','m',',',0211,'2',0,0201,024,0231,'0','i',',',0211,'0',0,04,0231,'0','d',',',0211,'0',0,04,0231,'0','m',',',0211,'0',0,'4',0231,'2','m',',',0211,'2',0,04,0231,'0','i',',',0211,'0',0,04,0231,'/','m',',',0211,'/',0,04,0231,'-','i',',',0211,'-',0,0252,'d',0231,'2','i',',',0211,'2',0,04,0231,'2','d',',',0211,'2',0,04,0231,'2','m',',',0211,'2',0,0201,024,0231,'0','i',',',0211,'0',0,04,0231,'0','d',',',0211,'0',0,04,0231,'0','m',',',0211,'0',0,'4',0231,'2','m',',',0211,'2',0,04,0231,'0','i',',',0211,'0',0,04,0231,'/','m',',',0211,'/',0,04,0231,'-','i',',',0211,'-',0,0252,'d',0231,'2','i',',',0211,'2',0,04,0231,'2','d',',',0211,'2',0,04,0231,'2','m',',',0211,'2',0,0201,024,0231,'0','i',',',0211,'0',0,04,0231,'0','d',',',0211,'0',0,04,0231,'0','m',',',0211,'0',0,'4',0231,'2','m',',',0211,'2',0,04,0231,'0','i',',',0211,'0',0,04,0231,'/','m',',',0211,'/',0,04,0231,'-','i',',',0211,'-',0,04,0231,'+','s',',',0211,'+',0,'4',0231,')','p',',',0211,')',0,0201,024,0231,')','s',',',0211,')',0,0201,'t',0231,'+','s',',',0211,'+',0,'4',0231,')','p',',',0211,')',0,0201,024,0231,')','s',',',0211,')',0,'4',0231,'2','n',',',0211,'2',0,04,0231,'2','d',',',0211,'2',0,04,0231,'2','j',',',0211,'2',0,04,0231,'2','d',',',0211,'2',0,04,0231,'0','n',',',0211,'0',0,04,0231,'0','d',',',0211,'0',0,04,0231,'0','j',',',0211,'0',0,04,0231,'0','d',',',0211,'0',0,04,0231,'/','n',',',0211,'/',0,04,0231,'/','d',',',0211,'/',0,04,0231,'/','j',',',0211,'/',0,04,0231,'/','d',',',0211,'/',0,04,0231,'+','s',',',0211,'+',0,'4',0231,')','p',',',0211,')',0,0201,024,0231,')','s',',',0211,')',0,0201,'t',0231,'+','s',',',0211,'+',0,'4',0231,')','p',',',0211,')',0,0201,024,0231,')','s',',',0211,')',0,'4',0231,'2','s',',',0211,'2',0,04,0231,'2','X',',',0211,'2',0,04,0231,'2','X',',',0211,'2',0,04,0231,'0','z',',',0211,'0',0,04,0231,'0','X',',',0211,'0',0,04,0231,'0','X',',',0211,'0',0,04,0231,'2','n',',',0211,'2',0,04,0231,'2','_',',',0211,'2',0,04,0231,'0','n',',',0211,'0',0,04,0231,'0','_',',',0211,'0',0,04,0231,'/','n',',',0211,'/',0,04,0231,'/','_',',',0211,'/',0,0,0271,'u',0177,0,0377,'/',0,'M','T','r','k',0,0,04,034,0,0272,0,0,0,0312,037,0,0272,012,'5',0,0272,'[',05,0,0272,']',0,0,0377,'Y',02,0,0,0,0272,07,'i',0,0272,'n',0177,030,0272,'d',0,0,0272,'e',0,034,0272,06,02,0,0272,'&',0,034,0272,'d',0177,0,0272,'e',0177,'P',0352,0,'@',030,0272,01,0,0201,'H',0272,'t',0,0370,0,0232,'1','d',0,0232,'*','d',0134,0212,'1',0,0,0212,'*',0,04,0232,'4','d',0,0232,'-','d',0134,0212,'4',0,0,0212,'-',0,'d',0232,'6','d',0,0232,'/','d',0134,0212,'6',0,0,0212,'/',0,0201,'D',0232,'1','d',0,0232,'*','d',0134,0212,'1',0,0,0212,'*',0,04,0232,'6','d',0,0232,'/','d',0134,0212,'6',0,0,0212,'/',0,'d',0232,'8','d',0,0232,'1','d',0134,0212,'8',0,0,0212,'1',0,0201,'D',0232,'1','d',0,0232,'*','d',0134,0212,'1',0,0,0212,'*',0,04,0232,'8','d',0,0232,'1','d',0134,0212,'8',0,0,0212,'1',0,'d',0232,'9','d',0,0232,'2','d',0134,0212,'9',0,0,0212,'2',0,'d',0232,'*','d',0,0232,'1','d',0134,0212,'*',0,0,0212,'1',0,'d',0232,'9','d',0,0232,'1','d',0201,'<',0212,'9',0,0,0212,'1',0,04,0232,'8','d',0,0232,'/','d',0134,0212,'8',0,0,0212,'/',0,04,0232,'6','d',0,0232,'-','d',0134,0212,'6',0,0,0212,'-',0,04,0232,'1','d',0,0232,'*','d',0134,0212,'1',0,0,0212,'*',0,04,0232,'9','d',0,0232,'4','d',0,0232,'/','d',0202,034,0212,'9',0,0,0212,'4',0,0,0212,'/',0,04,0232,'+','d',0,0232,';','d',0,0232,'2','d',0201,'<',0212,'+',0,04,0232,'/','d',0134,0212,';',0,0,0212,'2',0,0,0212,'/',0,04,0232,'>','d',0,0232,'4','d',0,0232,'-','d',0134,0212,'-',0,04,0232,'/','d',0134,0212,'>',0,0,0212,'4',0,0,0212,'/',0,0370,0,0272,'u',0177,'d',0272,'t',0,0370,0,0232,'1','d',0,0232,'*','d',0134,0212,'1',0,0,0212,'*',0,04,0232,'4','d',0,0232,'-','d',0134,0212,'4',0,0,0212,'-',0,'d',0232,'6','d',0,0232,'/','d',0134,0212,'6',0,0,0212,'/',0,0201,'D',0232,'1','d',0,0232,'*','d',0134,0212,'1',0,0,0212,'*',0,04,0232,'6','d',0,0232,'/','d',0134,0212,'6',0,0,0212,'/',0,'d',0232,'8','d',0,0232,'1','d',0134,0212,'8',0,0,0212,'1',0,0201,'D',0232,'1','d',0,0232,'*','d',0134,0212,'1',0,0,0212,'*',0,04,0232,'8','d',0,0232,'1','d',0134,0212,'8',0,0,0212,'1',0,'d',0232,'9','d',0,0232,'2','d',0134,0212,'9',0,0,0212,'2',0,'d',0232,'*','d',0,0232,'1','d',0134,0212,'*',0,0,0212,'1',0,'d',0232,'9','d',0,0232,'1','d',0201,'<',0212,'9',0,0,0212,'1',0,04,0232,'8','d',0,0232,'/','d',0134,0212,'8',0,0,0212,'/',0,04,0232,'6','d',0,0232,'-','d',0134,0212,'6',0,0,0212,'-',0,04,0232,'1','d',0,0232,'*','d',0134,0212,'1',0,0,0212,'*',0,04,0232,'9','d',0,0232,'4','d',0,0232,'/','d',0202,034,0212,'9',0,0,0212,'4',0,0,0212,'/',0,04,0232,'+','d',0,0232,';','d',0,0232,'2','d',0201,'<',0212,'+',0,04,0232,'/','d',0134,0212,';',0,0,0212,'2',0,0,0212,'/',0,04,0232,'>','d',0,0232,'4','d',0,0232,'-','d',0134,0212,'-',0,04,0232,'/','d',0134,0212,'>',0,0,0212,'4',0,0,0212,'/',0,0370,0,0272,'u',0177,0202,'$',0272,'t',0,0370,0,0232,'1','d',0,0232,'*','d',0134,0212,'1',0,0,0212,'*',0,04,0232,'4','d',0,0232,'-','d',0134,0212,'4',0,0,0212,'-',0,'d',0232,'6','d',0,0232,'/','d',0134,0212,'6',0,0,0212,'/',0,0201,'D',0232,'1','d',0,0232,'*','d',0134,0212,'1',0,0,0212,'*',0,04,0232,'6','d',0,0232,'/','d',0134,0212,'6',0,0,0212,'/',0,'d',0232,'8','d',0,0232,'1','d',0134,0212,'8',0,0,0212,'1',0,0201,'D',0232,'1','d',0,0232,'*','d',0134,0212,'1',0,0,0212,'*',0,04,0232,'8','d',0,0232,'1','d',0134,0212,'8',0,0,0212,'1',0,'d',0232,'9','d',0,0232,'2','d',0134,0212,'9',0,0,0212,'2',0,'d',0232,'*','d',0,0232,'1','d',0134,0212,'*',0,0,0212,'1',0,'d',0232,'9','d',0,0232,'1','d',0201,'<',0212,'9',0,0,0212,'1',0,04,0232,'8','d',0,0232,'/','d',0134,0212,'8',0,0,0212,'/',0,04,0232,'6','d',0,0232,'-','d',0134,0212,'6',0,0,0212,'-',0,04,0232,'1','d',0,0232,'*','d',0134,0212,'1',0,0,0212,'*',0,04,0232,'9','d',0,0232,'4','d',0,0232,'/','d',0202,034,0212,'9',0,0,0212,'4',0,0,0212,'/',0,04,0232,'+','d',0,0232,';','d',0,0232,'2','d',0201,'<',0212,'+',0,04,0232,'/','d',0134,0212,';',0,0,0212,'2',0,0,0212,'/',0,04,0232,'>','d',0,0232,'4','d',0,0232,'-','d',0134,0212,'-',0,04,0232,'/','d',0134,0212,'>',0,0,0212,'4',0,0,0212,'/',0,0370,0,0272,'u',0177,0,0377,'/',0,'M','T','r','k',0,0,036,'t',0,0273,0,0,0,0313,035,0,0273,012,'5',0,0273,'[',05,0,0273,']',0,0,0377,'Y',02,0,0,0,0273,07,'i',0,0273,'n',0177,030,0273,'d',0,0,0273,'e',0,034,0273,06,02,0,0273,'&',0,034,0273,'d',0177,0,0273,'e',0177,'P',0353,0,'@',030,0273,01,0,0201,'H',0273,'t',0,0230,010,0233,'1','d',0,0233,'*','d','`',0213,'1',0,0,0213,'*',0,0,0233,'4','d',0,0233,'-','d','`',0213,'4',0,0,0213,'-',0,'`',0233,'6','d',0,0233,'/','d','`',0213,'6',0,0,0213,'/',0,0201,'@',0233,'1','d',0,0233,'*','d','`',0213,'1',0,0,0213,'*',0,0,0233,'6','d',0,0233,'/','d','`',0213,'6',0,0,0213,'/',0,'`',0233,'8','d',0,0233,'1','d','`',0213,'8',0,0,0213,'1',0,0201,'@',0233,'1','d',0,0233,'*','d','`',0213,'1',0,0,0213,'*',0,0,0233,'8','d',0,0233,'1','d','`',0213,'8',0,0,0213,'1',0,'`',0233,'9','d',0,0233,'2','d','X',0233,'9','@',0,0233,'2','@',010,0213,'9','@',0,0213,'2','@',0,0213,'9',0,0,0213,'2',0,'`',0233,'*','d',0,0233,'1','d','`',0213,'*',0,0,0213,'1',0,'`',0233,'9','d',0,0233,'1','d',0201,'@',0213,'9',0,0,0213,'1',0,0,0233,'8','d',0,0233,'/','d','`',0213,'8',0,0,0213,'/',0,0,0233,'6','d',0,0233,'-','d','`',0213,'6',0,0,0213,'-',0,0,0233,'1','d',0,0233,'*','d','`',0213,'1',0,0,0213,'*',0,0,0233,'9','d',0,0233,'4','d',0,0233,'/','d',0202,' ',0213,'9',0,0,0213,'4',0,0,0213,'/',0,0,0233,';','d',0,0233,'2','d',0,0233,'-','d',0201,'@',0213,'-',0,0,0233,'/','d','`',0213,';',0,0,0213,'2',0,0,0213,'/',0,0,0233,'>','d',0,0233,'4','d',0,0233,'-','d','`',0213,'-',0,0,0233,'/','d','X',0233,'>','@',0,0233,'4','@',0,0233,'/','@',010,0213,'>','@',0,0213,'4','@',0,0213,'/','@',0,0213,'>',0,0,0213,'4',0,0,0213,'/',0,0,0233,'=','d','`',0213,'=',0,0,0233,'=','d','`',0213,'=',0,'`',0233,'6','d',0,0233,'=','d',0202,' ',0213,'=',0,0,0233,'=','d','`',0213,'=',0,0,0233,'=','d','`',0213,'6',0,0,0213,'=',0,'`',0233,'6','d',0,0233,'>','d',0202,' ',0213,'6',0,0,0213,'>',0,0,0233,';','d',0,0233,'6','d','`',0213,';',0,0,0213,'6',0,0,0233,'6','d',0,0233,';','d','`',0213,'6',0,0,0213,';',0,'`',0233,';','d',0,0233,'4','d','X',0233,'4','@',0,0233,';','@',0201,'H',0213,';','@',0,0213,'4','@',0,0213,'4',0,0,0213,';',0,0,0233,'4','d',0,0233,';','d','`',0213,'4',0,0,0213,';',0,0,0233,'4','d',0,0233,';','d','`',0213,'4',0,0,0213,';',0,'`',0233,';','d',0,0233,'4','d','`',0213,';',0,0,0213,'4',0,'`',0233,'4','d',0,0233,';','d',0201,'@',0213,'4',0,0,0213,';',0,0,0233,'2','d',0,0233,'9','d',0201,'@',0213,'2',0,0,0213,'9',0,0,0233,'2','d',0,0233,'7','d',0201,'@',0213,'2',0,0,0213,'7',0,0,0233,'2','d',0,0233,'9','d',0201,'@',0213,'2',0,0,0213,'9',0,0,0233,'1','d',0,0233,'6','d','X',0233,'1','@',0,0233,'6','@',0201,'H',0213,'1','@',0,0213,'6','@',0,0213,'1',0,0,0213,'6',0,0,0233,'=','d',0,0233,'6','d','`',0213,'=',0,0,0213,'6',0,0,0233,'6','d',0,0233,'=','d','`',0213,'6',0,0,0213,'=',0,'`',0233,'6','d',0,0233,'=','d','`',0213,'6',0,0,0213,'=',0,'`',0233,'6','d',0,0233,'>','d',0201,'@',0213,'6',0,0,0213,'>',0,0,0233,'6','d',0,0233,'=','d',0201,'@',0213,'6',0,0,0213,'=',0,0,0233,'4','d',0,0233,';','d',0201,'@',0213,'4',0,0,0213,';',0,0,0233,'=','d',0,0233,'6','d',0202,030,0233,'=','@',0,0233,'6','@',010,0213,'=','@',0,0213,'6','@',0,0213,'=',0,0,0213,'6',0,0,0233,'2','d',0,0233,'9','d','`',0213,'2',0,0,0213,'9',0,0,0233,'/','d',0,0233,'6','d','`',0213,'/',0,0,0213,'6',0,'`',0233,'2','d',0,0233,'9','d','`',0213,'2',0,0,0213,'9',0,'`',0233,'6','d',0,0233,';','d','`',0213,'6',0,0,0213,';',0,'`',0233,'4','d',0,0233,'8','d',0201,'@',0213,'4',0,0,0213,'8',0,0,0233,'/','d',0,0233,'4','d','`',0213,'/',0,0,0213,'4',0,'`',0233,'1','d',0,0233,'8','d','`',0213,'1',0,0,0213,'8',0,'`',0233,'1','d',0,0233,'9','d',0202,030,0233,'1','@',0,0233,'9','@',010,0213,'1','@',0,0213,'9','@',0,0213,'1',0,0,0213,'9',0,0,0233,'+','f',04,0233,'2','f',04,0233,'6','f','X',0213,'+',0,0,0213,'2',0,0,0233,'+','^',04,0213,'6',0,0,0233,'2','^',04,0233,'6','^','X',0213,'+',0,0,0213,'2',0,04,0213,'6',0,0134,0233,'+','f',04,0233,'2','f',04,0233,'6','f','X',0213,'+',0,0,0213,'2',0,04,0213,'6',0,0201,'<',0233,'+','f',04,0233,'2','f',04,0233,'6','f','X',0213,'+',0,0,0213,'2',0,0,0233,'+','^',04,0213,'6',0,0,0233,'2','^',04,0233,'6','^','X',0213,'+',0,0,0213,'2',0,04,0213,'6',0,0134,0233,'+','f',04,0233,'2','f',04,0233,'6','f','X',0213,'+',0,0,0213,'2',0,04,0213,'6',0,0204,'<',0233,'+','f',04,0233,'2','f',04,0233,'6','f','X',0213,'+',0,0,0213,'2',0,0,0233,'+','^',04,0213,'6',0,0,0233,'2','^',04,0233,'6','^','X',0213,'+',0,0,0213,'2',0,04,0213,'6',0,0134,0233,'+','f',04,0233,'2','f',04,0233,'6','f','X',0213,'+',0,0,0213,'2',0,04,0213,'6',0,0201,'<',0233,'+','f',04,0233,'2','f',04,0233,'6','f','X',0213,'+',0,0,0213,'2',0,0,0233,'+','^',04,0213,'6',0,0,0233,'2','^',04,0233,'6','^','X',0213,'+',0,0,0213,'2',0,04,0213,'6',0,0134,0233,'+','f',04,0233,'2','f',04,0233,'6','f','X',0213,'+',0,0,0213,'2',0,04,0213,'6',0,0234,'<',0233,'=','d','`',0213,'=',0,0,0233,'=','d','`',0213,'=',0,'`',0233,'6','d',0,0233,'=','d',0202,' ',0213,'=',0,0,0233,'=','d','`',0213,'=',0,0,0233,'=','d','`',0213,'6',0,0,0213,'=',0,'`',0233,'6','d',0,0233,'>','d',0202,' ',0213,'6',0,0,0213,'>',0,0,0233,';','d',0,0233,'6','d','`',0213,';',0,0,0213,'6',0,0,0233,'6','d',0,0233,';','d','`',0213,'6',0,0,0213,';',0,'`',0233,';','d',0,0233,'4','d','X',0233,'4','@',0,0233,';','@',0201,'H',0213,';','@',0,0213,'4','@',0,0213,'4',0,0,0213,';',0,0,0233,'4','d',0,0233,';','d','`',0213,'4',0,0,0213,';',0,0,0233,'4','d',0,0233,';','d','`',0213,'4',0,0,0213,';',0,'`',0233,';','d',0,0233,'4','d','`',0213,';',0,0,0213,'4',0,'`',0233,'4','d',0,0233,';','d',0201,'@',0213,'4',0,0,0213,';',0,0,0233,'2','d',0,0233,'9','d',0201,'@',0213,'2',0,0,0213,'9',0,0,0233,'2','d',0,0233,'7','d',0201,'@',0213,'2',0,0,0213,'7',0,0,0233,'2','d',0,0233,'9','d',0201,'@',0213,'2',0,0,0213,'9',0,0,0233,'1','d',0,0233,'6','d','X',0233,'1','@',0,0233,'6','@',0201,'H',0213,'1','@',0,0213,'6','@',0,0213,'1',0,0,0213,'6',0,0,0233,'=','d',0,0233,'6','d','`',0213,'=',0,0,0213,'6',0,0,0233,'6','d',0,0233,'=','d','`',0213,'6',0,0,0213,'=',0,'`',0233,'6','d',0,0233,'=','d','`',0213,'6',0,0,0213,'=',0,'`',0233,'6','d',0,0233,'>','d',0201,'@',0213,'6',0,0,0213,'>',0,0,0233,'6','d',0,0233,'=','d',0201,'@',0213,'6',0,0,0213,'=',0,0,0233,'4','d',0,0233,';','d',0201,'@',0213,'4',0,0,0213,';',0,0,0233,'=','d',0,0233,'6','d',0202,030,0233,'=','@',0,0233,'6','@',010,0213,'=','@',0,0213,'6','@',0,0213,'=',0,0,0213,'6',0,0,0233,'2','d',0,0233,'9','d','`',0213,'2',0,0,0213,'9',0,0,0233,'/','d',0,0233,'6','d','`',0213,'/',0,0,0213,'6',0,'`',0233,'2','d',0,0233,'9','d','`',0213,'2',0,0,0213,'9',0,'`',0233,'6','d',0,0233,';','d','`',0213,'6',0,0,0213,';',0,'`',0233,'4','d',0,0233,'8','d',0201,'@',0213,'4',0,0,0213,'8',0,0,0233,'/','d',0,0233,'4','d','`',0213,'/',0,0,0213,'4',0,'`',0233,'1','d',0,0233,'8','d','`',0213,'1',0,0,0213,'8',0,'`',0233,'1','d',0,0233,'9','d',0202,030,0233,'1','@',0,0233,'9','@',010,0213,'1','@',0,0213,'9','@',0,0213,'1',0,0,0213,'9',0,0,0233,'2','d',0,0233,'9','d',0134,0233,'2','d',04,0213,'2',0,0,0213,'9',0,0,0233,'9','d','X',0213,'2',0,010,0213,'9',0,'`',0233,'2','n',0,0233,'9','n',0202,020,0233,'2','d',020,0213,'9',0,0,0233,'9','d','P',0213,'2',0,0,0233,'2','d',020,0213,'9',0,0,0233,'9','d','P',0213,'2',0,020,0213,'2',0,0,0213,'9',0,'`',0233,'4','n',0,0233,';','n',0202,' ',0213,'4',0,0,0213,';',0,0,0233,'2','d',0,0233,';','d','`',0213,'2',0,0,0213,';',0,0,0233,'2','d',0,0233,';','d','`',0213,'2',0,0,0213,';',0,'`',0233,';','n',0,0233,'4','n','X',0233,'4','@',0,0233,';','@',0201,'H',0213,';','@',0,0213,'4','@',0,0213,'4',0,0,0213,';',0,0,0233,'4','d',0,0233,';','d','`',0213,'4',0,0,0213,';',0,0,0233,'4','d',0,0233,';','d','`',0213,'4',0,0,0213,';',0,'`',0233,';','d',0,0233,'4','d','`',0213,';',0,0,0213,'4',0,'`',0233,'6','f',0,0233,'=','f',0201,'@',0213,'6',0,0,0213,'=',0,0,0233,'4','h',0,0233,';','h',0201,'@',0213,'4',0,0,0213,';',0,0,0233,'2','j',0,0233,'9','j',0201,'@',0213,'2',0,0,0213,'9',0,0,0233,'8','l',0,0233,'1','l',0201,'@',0213,'8',0,0,0213,'1',0,0,0233,'2','n',0,0233,'9','n','X',0233,'2','@',0,0233,'9','@',0201,'H',0213,'2','@',0,0213,'9','@',0,0213,'2',0,0,0213,'9',0,0,0233,'2','d',0,0233,'=','d','`',0213,'2',0,0,0213,'=',0,0,0233,'=','d',0,0233,'2','d','`',0213,'=',0,0,0213,'2',0,'`',0233,';','d',0,0233,'2','d','`',0213,';',0,0,0213,'2',0,'`',0233,'9','d',0,0233,'4','d',0201,'@',0213,'9',0,0,0213,'4',0,0,0233,'8','d',0,0233,'4','d',0201,'@',0213,'8',0,0,0213,'4',0,0,0233,'4','d',0,0233,'9','d',0201,'@',0213,'4',0,0,0213,'9',0,0,0233,'4','l',0,0233,'8','l','`',0213,'8',0,0,0233,'6','l','`',0213,'6',0,0,0233,'8','l','X',0233,'4','@',0,0233,'8','@',010,0213,'4','@',0,0213,'8','@',0,0213,'4',0,0,0213,'8',0,0,0233,'6','d',0,0233,'9','d','`',0213,'6',0,0,0213,'9',0,0,0233,'2','d',0,0233,'6','d','`',0213,'2',0,0,0213,'6',0,'`',0233,'2','d',0,0233,'9','d','`',0213,'2',0,0,0213,'9',0,'`',0233,'6','d',0,0233,';','d','`',0213,'6',0,0,0213,';',0,'`',0233,'4','d',0,0233,'8','d',0201,'@',0213,'4',0,0,0213,'8',0,0,0233,'/','d',0,0233,'4','d','`',0213,'/',0,0,0213,'4',0,'`',0233,'1','d',0,0233,'8','d','`',0213,'1',0,0,0213,'8',0,'`',0233,'1','d',0,0233,'9','d',0202,030,0233,'1','@',0,0233,'9','@',010,0213,'1','@',0,0213,'9','@',0,0213,'1',0,0,0213,'9',0,0,0233,'*','f',010,0233,'6','f','X',0213,'*',0,0,0233,'*','^',04,0213,'6',0,04,0233,'6','^','X',0213,'*',0,04,0213,'6',0,0134,0233,'*','f',010,0233,'6','f','X',0213,'*',0,04,0213,'6',0,0201,'<',0233,'*','f',010,0233,'6','f','X',0213,'*',0,0,0233,'*','^',04,0213,'6',0,04,0233,'6','^','X',0213,'*',0,04,0213,'6',0,0134,0233,'*','f',010,0233,'6','f','X',0213,'*',0,04,0213,'6',0,0204,'<',0233,'*','f',010,0233,'6','f','X',0213,'*',0,0,0233,'*','^',04,0213,'6',0,04,0233,'6','^','X',0213,'*',0,04,0213,'6',0,0134,0233,'*','f',010,0233,'6','f','X',0213,'*',0,04,0213,'6',0,0201,'<',0233,'*','f',010,0233,'6','f','X',0213,'*',0,0,0233,'*','^',04,0213,'6',0,04,0233,'6','^','X',0213,'*',0,04,0213,'6',0,0134,0233,'*','f',010,0233,'6','f','X',0213,'*',0,04,0213,'6',0,0204,'0',0273,'u',0177,'d',0273,'t',0,0230,010,0233,'1','d',0,0233,'*','d','`',0213,'1',0,0,0213,'*',0,0,0233,'4','d',0,0233,'-','d','`',0213,'4',0,0,0213,'-',0,'`',0233,'6','d',0,0233,'/','d','`',0213,'6',0,0,0213,'/',0,0201,'@',0233,'1','d',0,0233,'*','d','`',0213,'1',0,0,0213,'*',0,0,0233,'6','d',0,0233,'/','d','`',0213,'6',0,0,0213,'/',0,'`',0233,'8','d',0,0233,'1','d','`',0213,'8',0,0,0213,'1',0,0201,'@',0233,'1','d',0,0233,'*','d','`',0213,'1',0,0,0213,'*',0,0,0233,'8','d',0,0233,'1','d','`',0213,'8',0,0,0213,'1',0,'`',0233,'9','d',0,0233,'2','d','X',0233,'9','@',0,0233,'2','@',010,0213,'9','@',0,0213,'2','@',0,0213,'9',0,0,0213,'2',0,'`',0233,'*','d',0,0233,'1','d','`',0213,'*',0,0,0213,'1',0,'`',0233,'9','d',0,0233,'1','d',0201,'@',0213,'9',0,0,0213,'1',0,0,0233,'8','d',0,0233,'/','d','`',0213,'8',0,0,0213,'/',0,0,0233,'6','d',0,0233,'-','d','`',0213,'6',0,0,0213,'-',0,0,0233,'1','d',0,0233,'*','d','`',0213,'1',0,0,0213,'*',0,0,0233,'9','d',0,0233,'4','d',0,0233,'/','d',0202,' ',0213,'9',0,0,0213,'4',0,0,0213,'/',0,0,0233,';','d',0,0233,'2','d',0,0233,'-','d',0201,'@',0213,'-',0,0,0233,'/','d','`',0213,';',0,0,0213,'2',0,0,0213,'/',0,0,0233,'>','d',0,0233,'4','d',0,0233,'-','d','`',0213,'-',0,0,0233,'/','d','X',0233,'>','@',0,0233,'4','@',0,0233,'/','@',010,0213,'>','@',0,0213,'4','@',0,0213,'/','@',0,0213,'>',0,0,0213,'4',0,0,0213,'/',0,0,0233,'=','d','`',0213,'=',0,0,0233,'=','d','`',0213,'=',0,'`',0233,'6','d',0,0233,'=','d',0202,' ',0213,'=',0,0,0233,'=','d','`',0213,'=',0,0,0233,'=','d','`',0213,'6',0,0,0213,'=',0,'`',0233,'6','d',0,0233,'>','d',0202,' ',0213,'6',0,0,0213,'>',0,0,0233,';','d',0,0233,'6','d','`',0213,';',0,0,0213,'6',0,0,0233,'6','d',0,0233,';','d','`',0213,'6',0,0,0213,';',0,'`',0233,';','d',0,0233,'4','d','X',0233,'4','@',0,0233,';','@',0201,'H',0213,';','@',0,0213,'4','@',0,0213,'4',0,0,0213,';',0,0,0233,'4','d',0,0233,';','d','`',0213,'4',0,0,0213,';',0,0,0233,'4','d',0,0233,';','d','`',0213,'4',0,0,0213,';',0,'`',0233,';','d',0,0233,'4','d','`',0213,';',0,0,0213,'4',0,'`',0233,'4','d',0,0233,';','d',0201,'@',0213,'4',0,0,0213,';',0,0,0233,'2','d',0,0233,'9','d',0201,'@',0213,'2',0,0,0213,'9',0,0,0233,'2','d',0,0233,'7','d',0201,'@',0213,'2',0,0,0213,'7',0,0,0233,'2','d',0,0233,'9','d',0201,'@',0213,'2',0,0,0213,'9',0,0,0233,'1','d',0,0233,'6','d','X',0233,'1','@',0,0233,'6','@',0201,'H',0213,'1','@',0,0213,'6','@',0,0213,'1',0,0,0213,'6',0,0,0233,'=','d',0,0233,'6','d','`',0213,'=',0,0,0213,'6',0,0,0233,'6','d',0,0233,'=','d','`',0213,'6',0,0,0213,'=',0,'`',0233,'6','d',0,0233,'=','d','`',0213,'6',0,0,0213,'=',0,'`',0233,'6','d',0,0233,'>','d',0201,'@',0213,'6',0,0,0213,'>',0,0,0233,'6','d',0,0233,'=','d',0201,'@',0213,'6',0,0,0213,'=',0,0,0233,'4','d',0,0233,';','d',0201,'@',0213,'4',0,0,0213,';',0,0,0233,'=','d',0,0233,'6','d',0202,030,0233,'=','@',0,0233,'6','@',010,0213,'=','@',0,0213,'6','@',0,0213,'=',0,0,0213,'6',0,0,0233,'2','d',0,0233,'9','d','`',0213,'2',0,0,0213,'9',0,0,0233,'/','d',0,0233,'6','d','`',0213,'/',0,0,0213,'6',0,'`',0233,'2','d',0,0233,'9','d','`',0213,'2',0,0,0213,'9',0,'`',0233,'6','d',0,0233,';','d','`',0213,'6',0,0,0213,';',0,'`',0233,'4','d',0,0233,'8','d',0201,'@',0213,'4',0,0,0213,'8',0,0,0233,'/','d',0,0233,'4','d','`',0213,'/',0,0,0213,'4',0,'`',0233,'1','d',0,0233,'8','d','`',0213,'1',0,0,0213,'8',0,'`',0233,'1','d',0,0233,'9','d',0202,030,0233,'1','@',0,0233,'9','@',010,0213,'1','@',0,0213,'9','@',0,0213,'1',0,0,0213,'9',0,0,0233,'+','f',04,0233,'2','f',04,0233,'6','f','X',0213,'+',0,0,0213,'2',0,0,0233,'+','^',04,0213,'6',0,0,0233,'2','^',04,0233,'6','^','X',0213,'+',0,0,0213,'2',0,04,0213,'6',0,0134,0233,'+','f',04,0233,'2','f',04,0233,'6','f','X',0213,'+',0,0,0213,'2',0,04,0213,'6',0,0201,'<',0233,'+','f',04,0233,'2','f',04,0233,'6','f','X',0213,'+',0,0,0213,'2',0,0,0233,'+','^',04,0213,'6',0,0,0233,'2','^',04,0233,'6','^','X',0213,'+',0,0,0213,'2',0,04,0213,'6',0,0134,0233,'+','f',04,0233,'2','f',04,0233,'6','f','X',0213,'+',0,0,0213,'2',0,04,0213,'6',0,0204,'<',0233,'+','f',04,0233,'2','f',04,0233,'6','f','X',0213,'+',0,0,0213,'2',0,0,0233,'+','^',04,0213,'6',0,0,0233,'2','^',04,0233,'6','^','X',0213,'+',0,0,0213,'2',0,04,0213,'6',0,0134,0233,'+','f',04,0233,'2','f',04,0233,'6','f','X',0213,'+',0,0,0213,'2',0,04,0213,'6',0,0201,'<',0233,'+','f',04,0233,'2','f',04,0233,'6','f','X',0213,'+',0,0,0213,'2',0,0,0233,'+','^',04,0213,'6',0,0,0233,'2','^',04,0233,'6','^','X',0213,'+',0,0,0213,'2',0,04,0213,'6',0,0134,0233,'+','f',04,0233,'2','f',04,0233,'6','f','X',0213,'+',0,0,0213,'2',0,04,0213,'6',0,0234,'<',0233,'=','d','`',0213,'=',0,0,0233,'=','d','`',0213,'=',0,'`',0233,'6','d',0,0233,'=','d',0202,' ',0213,'=',0,0,0233,'=','d','`',0213,'=',0,0,0233,'=','d','`',0213,'6',0,0,0213,'=',0,'`',0233,'6','d',0,0233,'>','d',0202,' ',0213,'6',0,0,0213,'>',0,0,0233,';','d',0,0233,'6','d','`',0213,';',0,0,0213,'6',0,0,0233,'6','d',0,0233,';','d','`',0213,'6',0,0,0213,';',0,'`',0233,';','d',0,0233,'4','d','X',0233,'4','@',0,0233,';','@',0201,'H',0213,';','@',0,0213,'4','@',0,0213,'4',0,0,0213,';',0,0,0233,'4','d',0,0233,';','d','`',0213,'4',0,0,0213,';',0,0,0233,'4','d',0,0233,';','d','`',0213,'4',0,0,0213,';',0,'`',0233,';','d',0,0233,'4','d','`',0213,';',0,0,0213,'4',0,'`',0233,'4','d',0,0233,';','d',0201,'@',0213,'4',0,0,0213,';',0,0,0233,'2','d',0,0233,'9','d',0201,'@',0213,'2',0,0,0213,'9',0,0,0233,'2','d',0,0233,'7','d',0201,'@',0213,'2',0,0,0213,'7',0,0,0233,'2','d',0,0233,'9','d',0201,'@',0213,'2',0,0,0213,'9',0,0,0233,'1','d',0,0233,'6','d','X',0233,'1','@',0,0233,'6','@',0201,'H',0213,'1','@',0,0213,'6','@',0,0213,'1',0,0,0213,'6',0,0,0233,'=','d',0,0233,'6','d','`',0213,'=',0,0,0213,'6',0,0,0233,'6','d',0,0233,'=','d','`',0213,'6',0,0,0213,'=',0,'`',0233,'6','d',0,0233,'=','d','`',0213,'6',0,0,0213,'=',0,'`',0233,'6','d',0,0233,'>','d',0201,'@',0213,'6',0,0,0213,'>',0,0,0233,'6','d',0,0233,'=','d',0201,'@',0213,'6',0,0,0213,'=',0,0,0233,'4','d',0,0233,';','d',0201,'@',0213,'4',0,0,0213,';',0,0,0233,'=','d',0,0233,'6','d',0202,030,0233,'=','@',0,0233,'6','@',010,0213,'=','@',0,0213,'6','@',0,0213,'=',0,0,0213,'6',0,0,0233,'2','d',0,0233,'9','d','`',0213,'2',0,0,0213,'9',0,0,0233,'/','d',0,0233,'6','d','`',0213,'/',0,0,0213,'6',0,'`',0233,'2','d',0,0233,'9','d','`',0213,'2',0,0,0213,'9',0,'`',0233,'6','d',0,0233,';','d','`',0213,'6',0,0,0213,';',0,'`',0233,'4','d',0,0233,'8','d',0201,'@',0213,'4',0,0,0213,'8',0,0,0233,'/','d',0,0233,'4','d','`',0213,'/',0,0,0213,'4',0,'`',0233,'1','d',0,0233,'8','d','`',0213,'1',0,0,0213,'8',0,'`',0233,'1','d',0,0233,'9','d',0202,030,0233,'1','@',0,0233,'9','@',010,0213,'1','@',0,0213,'9','@',0,0213,'1',0,0,0213,'9',0,0,0233,'2','d',0,0233,'9','d',0134,0233,'2','d',04,0213,'2',0,0,0213,'9',0,0,0233,'9','d','X',0213,'2',0,010,0213,'9',0,'`',0233,'2','n',0,0233,'9','n',0202,020,0233,'2','d',020,0213,'9',0,0,0233,'9','d','P',0213,'2',0,0,0233,'2','d',020,0213,'9',0,0,0233,'9','d','P',0213,'2',0,020,0213,'2',0,0,0213,'9',0,'`',0233,'4','n',0,0233,';','n',0202,' ',0213,'4',0,0,0213,';',0,0,0233,'2','d',0,0233,';','d','`',0213,'2',0,0,0213,';',0,0,0233,'2','d',0,0233,';','d','`',0213,'2',0,0,0213,';',0,'`',0233,';','n',0,0233,'4','n','X',0233,'4','@',0,0233,';','@',0201,'H',0213,';','@',0,0213,'4','@',0,0213,'4',0,0,0213,';',0,0,0233,'4','d',0,0233,';','d','`',0213,'4',0,0,0213,';',0,0,0233,'4','d',0,0233,';','d','`',0213,'4',0,0,0213,';',0,'`',0233,';','d',0,0233,'4','d','`',0213,';',0,0,0213,'4',0,'`',0233,'6','f',0,0233,'=','f',0201,'@',0213,'6',0,0,0213,'=',0,0,0233,'4','h',0,0233,';','h',0201,'@',0213,'4',0,0,0213,';',0,0,0233,'2','j',0,0233,'9','j',0201,'@',0213,'2',0,0,0213,'9',0,0,0233,'8','l',0,0233,'1','l',0201,'@',0213,'8',0,0,0213,'1',0,0,0233,'2','n',0,0233,'9','n','X',0233,'2','@',0,0233,'9','@',0201,'H',0213,'2','@',0,0213,'9','@',0,0213,'2',0,0,0213,'9',0,0,0233,'2','d',0,0233,'=','d','`',0213,'2',0,0,0213,'=',0,0,0233,'=','d',0,0233,'2','d','`',0213,'=',0,0,0213,'2',0,'`',0233,';','d',0,0233,'2','d','`',0213,';',0,0,0213,'2',0,'`',0233,'9','d',0,0233,'4','d',0201,'@',0213,'9',0,0,0213,'4',0,0,0233,'8','d',0,0233,'4','d',0201,'@',0213,'8',0,0,0213,'4',0,0,0233,'4','d',0,0233,'9','d',0201,'@',0213,'4',0,0,0213,'9',0,0,0233,'4','l',0,0233,'8','l','`',0213,'8',0,0,0233,'6','l','`',0213,'6',0,0,0233,'8','l','X',0233,'4','@',0,0233,'8','@',010,0213,'4','@',0,0213,'8','@',0,0213,'4',0,0,0213,'8',0,0,0233,'6','d',0,0233,'9','d','`',0213,'6',0,0,0213,'9',0,0,0233,'2','d',0,0233,'6','d','`',0213,'2',0,0,0213,'6',0,'`',0233,'2','d',0,0233,'9','d','`',0213,'2',0,0,0213,'9',0,'`',0233,'6','d',0,0233,';','d','`',0213,'6',0,0,0213,';',0,'`',0233,'4','d',0,0233,'8','d',0201,'@',0213,'4',0,0,0213,'8',0,0,0233,'/','d',0,0233,'4','d','`',0213,'/',0,0,0213,'4',0,'`',0233,'1','d',0,0233,'8','d','`',0213,'1',0,0,0213,'8',0,'`',0233,'1','d',0,0233,'9','d',0202,030,0233,'1','@',0,0233,'9','@',010,0213,'1','@',0,0213,'9','@',0,0213,'1',0,0,0213,'9',0,0,0233,'*','f',010,0233,'6','f','X',0213,'*',0,0,0233,'*','^',04,0213,'6',0,04,0233,'6','^','X',0213,'*',0,04,0213,'6',0,0134,0233,'*','f',010,0233,'6','f','X',0213,'*',0,04,0213,'6',0,0201,'<',0233,'*','f',010,0233,'6','f','X',0213,'*',0,0,0233,'*','^',04,0213,'6',0,04,0233,'6','^','X',0213,'*',0,04,0213,'6',0,0134,0233,'*','f',010,0233,'6','f','X',0213,'*',0,04,0213,'6',0,0204,'<',0233,'*','f',010,0233,'6','f','X',0213,'*',0,0,0233,'*','^',04,0213,'6',0,04,0233,'6','^','X',0213,'*',0,04,0213,'6',0,0134,0233,'*','f',010,0233,'6','f','X',0213,'*',0,04,0213,'6',0,0201,'<',0233,'*','f',010,0233,'6','f','X',0213,'*',0,0,0233,'*','^',04,0213,'6',0,04,0233,'6','^','X',0213,'*',0,04,0213,'6',0,0134,0233,'*','f',010,0233,'6','f','X',0213,'*',0,04,0213,'6',0,0204,'0',0273,'u',0177,0202,'$',0273,'t',0,0230,010,0233,'1','d',0,0233,'*','d','`',0213,'1',0,0,0213,'*',0,0,0233,'4','d',0,0233,'-','d','`',0213,'4',0,0,0213,'-',0,'`',0233,'6','d',0,0233,'/','d','`',0213,'6',0,0,0213,'/',0,0201,'@',0233,'1','d',0,0233,'*','d','`',0213,'1',0,0,0213,'*',0,0,0233,'6','d',0,0233,'/','d','`',0213,'6',0,0,0213,'/',0,'`',0233,'8','d',0,0233,'1','d','`',0213,'8',0,0,0213,'1',0,0201,'@',0233,'1','d',0,0233,'*','d','`',0213,'1',0,0,0213,'*',0,0,0233,'8','d',0,0233,'1','d','`',0213,'8',0,0,0213,'1',0,'`',0233,'9','d',0,0233,'2','d','X',0233,'9','@',0,0233,'2','@',010,0213,'9','@',0,0213,'2','@',0,0213,'9',0,0,0213,'2',0,'`',0233,'*','d',0,0233,'1','d','`',0213,'*',0,0,0213,'1',0,'`',0233,'9','d',0,0233,'1','d',0201,'@',0213,'9',0,0,0213,'1',0,0,0233,'8','d',0,0233,'/','d','`',0213,'8',0,0,0213,'/',0,0,0233,'6','d',0,0233,'-','d','`',0213,'6',0,0,0213,'-',0,0,0233,'1','d',0,0233,'*','d','`',0213,'1',0,0,0213,'*',0,0,0233,'9','d',0,0233,'4','d',0,0233,'/','d',0202,' ',0213,'9',0,0,0213,'4',0,0,0213,'/',0,0,0233,';','d',0,0233,'2','d',0,0233,'-','d',0201,'@',0213,'-',0,0,0233,'/','d','`',0213,';',0,0,0213,'2',0,0,0213,'/',0,0,0233,'>','d',0,0233,'4','d',0,0233,'-','d','`',0213,'-',0,0,0233,'/','d','X',0233,'>','@',0,0233,'4','@',0,0233,'/','@',010,0213,'>','@',0,0213,'4','@',0,0213,'/','@',0,0213,'>',0,0,0213,'4',0,0,0213,'/',0,0,0233,'=','d','`',0213,'=',0,0,0233,'=','d','`',0213,'=',0,'`',0233,'6','d',0,0233,'=','d',0202,' ',0213,'=',0,0,0233,'=','d','`',0213,'=',0,0,0233,'=','d','`',0213,'6',0,0,0213,'=',0,'`',0233,'6','d',0,0233,'>','d',0202,' ',0213,'6',0,0,0213,'>',0,0,0233,';','d',0,0233,'6','d','`',0213,';',0,0,0213,'6',0,0,0233,'6','d',0,0233,';','d','`',0213,'6',0,0,0213,';',0,'`',0233,';','d',0,0233,'4','d','X',0233,'4','@',0,0233,';','@',0201,'H',0213,';','@',0,0213,'4','@',0,0213,'4',0,0,0213,';',0,0,0233,'4','d',0,0233,';','d','`',0213,'4',0,0,0213,';',0,0,0233,'4','d',0,0233,';','d','`',0213,'4',0,0,0213,';',0,'`',0233,';','d',0,0233,'4','d','`',0213,';',0,0,0213,'4',0,'`',0233,'4','d',0,0233,';','d',0201,'@',0213,'4',0,0,0213,';',0,0,0233,'2','d',0,0233,'9','d',0201,'@',0213,'2',0,0,0213,'9',0,0,0233,'2','d',0,0233,'7','d',0201,'@',0213,'2',0,0,0213,'7',0,0,0233,'2','d',0,0233,'9','d',0201,'@',0213,'2',0,0,0213,'9',0,0,0233,'1','d',0,0233,'6','d','X',0233,'1','@',0,0233,'6','@',0201,'H',0213,'1','@',0,0213,'6','@',0,0213,'1',0,0,0213,'6',0,0,0233,'=','d',0,0233,'6','d','`',0213,'=',0,0,0213,'6',0,0,0233,'6','d',0,0233,'=','d','`',0213,'6',0,0,0213,'=',0,'`',0233,'6','d',0,0233,'=','d','`',0213,'6',0,0,0213,'=',0,'`',0233,'6','d',0,0233,'>','d',0201,'@',0213,'6',0,0,0213,'>',0,0,0233,'6','d',0,0233,'=','d',0201,'@',0213,'6',0,0,0213,'=',0,0,0233,'4','d',0,0233,';','d',0201,'@',0213,'4',0,0,0213,';',0,0,0233,'=','d',0,0233,'6','d',0202,030,0233,'=','@',0,0233,'6','@',010,0213,'=','@',0,0213,'6','@',0,0213,'=',0,0,0213,'6',0,0,0233,'2','d',0,0233,'9','d','`',0213,'2',0,0,0213,'9',0,0,0233,'/','d',0,0233,'6','d','`',0213,'/',0,0,0213,'6',0,'`',0233,'2','d',0,0233,'9','d','`',0213,'2',0,0,0213,'9',0,'`',0233,'6','d',0,0233,';','d','`',0213,'6',0,0,0213,';',0,'`',0233,'4','d',0,0233,'8','d',0201,'@',0213,'4',0,0,0213,'8',0,0,0233,'/','d',0,0233,'4','d','`',0213,'/',0,0,0213,'4',0,'`',0233,'1','d',0,0233,'8','d','`',0213,'1',0,0,0213,'8',0,'`',0233,'1','d',0,0233,'9','d',0202,030,0233,'1','@',0,0233,'9','@',010,0213,'1','@',0,0213,'9','@',0,0213,'1',0,0,0213,'9',0,0,0233,'+','f',04,0233,'2','f',04,0233,'6','f','X',0213,'+',0,0,0213,'2',0,0,0233,'+','^',04,0213,'6',0,0,0233,'2','^',04,0233,'6','^','X',0213,'+',0,0,0213,'2',0,04,0213,'6',0,0134,0233,'+','f',04,0233,'2','f',04,0233,'6','f','X',0213,'+',0,0,0213,'2',0,04,0213,'6',0,0201,'<',0233,'+','f',04,0233,'2','f',04,0233,'6','f','X',0213,'+',0,0,0213,'2',0,0,0233,'+','^',04,0213,'6',0,0,0233,'2','^',04,0233,'6','^','X',0213,'+',0,0,0213,'2',0,04,0213,'6',0,0134,0233,'+','f',04,0233,'2','f',04,0233,'6','f','X',0213,'+',0,0,0213,'2',0,04,0213,'6',0,0204,'<',0233,'+','f',04,0233,'2','f',04,0233,'6','f','X',0213,'+',0,0,0213,'2',0,0,0233,'+','^',04,0213,'6',0,0,0233,'2','^',04,0233,'6','^','X',0213,'+',0,0,0213,'2',0,04,0213,'6',0,0134,0233,'+','f',04,0233,'2','f',04,0233,'6','f','X',0213,'+',0,0,0213,'2',0,04,0213,'6',0,0201,'<',0233,'+','f',04,0233,'2','f',04,0233,'6','f','X',0213,'+',0,0,0213,'2',0,0,0233,'+','^',04,0213,'6',0,0,0233,'2','^',04,0233,'6','^','X',0213,'+',0,0,0213,'2',0,04,0213,'6',0,0134,0233,'+','f',04,0233,'2','f',04,0233,'6','f','X',0213,'+',0,0,0213,'2',0,04,0213,'6',0,0234,'<',0233,'=','d','`',0213,'=',0,0,0233,'=','d','`',0213,'=',0,'`',0233,'6','d',0,0233,'=','d',0202,' ',0213,'=',0,0,0233,'=','d','`',0213,'=',0,0,0233,'=','d','`',0213,'6',0,0,0213,'=',0,'`',0233,'6','d',0,0233,'>','d',0202,' ',0213,'6',0,0,0213,'>',0,0,0233,';','d',0,0233,'6','d','`',0213,';',0,0,0213,'6',0,0,0233,'6','d',0,0233,';','d','`',0213,'6',0,0,0213,';',0,'`',0233,';','d',0,0233,'4','d','X',0233,'4','@',0,0233,';','@',0201,'H',0213,';','@',0,0213,'4','@',0,0213,'4',0,0,0213,';',0,0,0233,'4','d',0,0233,';','d','`',0213,'4',0,0,0213,';',0,0,0233,'4','d',0,0233,';','d','`',0213,'4',0,0,0213,';',0,'`',0233,';','d',0,0233,'4','d','`',0213,';',0,0,0213,'4',0,'`',0233,'4','d',0,0233,';','d',0201,'@',0213,'4',0,0,0213,';',0,0,0233,'2','d',0,0233,'9','d',0201,'@',0213,'2',0,0,0213,'9',0,0,0233,'2','d',0,0233,'7','d',0201,'@',0213,'2',0,0,0213,'7',0,0,0233,'2','d',0,0233,'9','d',0201,'@',0213,'2',0,0,0213,'9',0,0,0233,'1','d',0,0233,'6','d','X',0233,'1','@',0,0233,'6','@',0201,'H',0213,'1','@',0,0213,'6','@',0,0213,'1',0,0,0213,'6',0,0,0233,'=','d',0,0233,'6','d','`',0213,'=',0,0,0213,'6',0,0,0233,'6','d',0,0233,'=','d','`',0213,'6',0,0,0213,'=',0,'`',0233,'6','d',0,0233,'=','d','`',0213,'6',0,0,0213,'=',0,'`',0233,'6','d',0,0233,'>','d',0201,'@',0213,'6',0,0,0213,'>',0,0,0233,'6','d',0,0233,'=','d',0201,'@',0213,'6',0,0,0213,'=',0,0,0233,'4','d',0,0233,';','d',0201,'@',0213,'4',0,0,0213,';',0,0,0233,'=','d',0,0233,'6','d',0202,030,0233,'=','@',0,0233,'6','@',010,0213,'=','@',0,0213,'6','@',0,0213,'=',0,0,0213,'6',0,0,0233,'2','d',0,0233,'9','d','`',0213,'2',0,0,0213,'9',0,0,0233,'/','d',0,0233,'6','d','`',0213,'/',0,0,0213,'6',0,'`',0233,'2','d',0,0233,'9','d','`',0213,'2',0,0,0213,'9',0,'`',0233,'6','d',0,0233,';','d','`',0213,'6',0,0,0213,';',0,'`',0233,'4','d',0,0233,'8','d',0201,'@',0213,'4',0,0,0213,'8',0,0,0233,'/','d',0,0233,'4','d','`',0213,'/',0,0,0213,'4',0,'`',0233,'1','d',0,0233,'8','d','`',0213,'1',0,0,0213,'8',0,'`',0233,'1','d',0,0233,'9','d',0202,030,0233,'1','@',0,0233,'9','@',010,0213,'1','@',0,0213,'9','@',0,0213,'1',0,0,0213,'9',0,0,0233,'2','d',0,0233,'9','d',0134,0233,'2','d',04,0213,'2',0,0,0213,'9',0,0,0233,'9','d','X',0213,'2',0,010,0213,'9',0,'`',0233,'2','n',0,0233,'9','n',0202,020,0233,'2','d',020,0213,'9',0,0,0233,'9','d','P',0213,'2',0,0,0233,'2','d',020,0213,'9',0,0,0233,'9','d','P',0213,'2',0,020,0213,'2',0,0,0213,'9',0,'`',0233,'4','n',0,0233,';','n',0202,' ',0213,'4',0,0,0213,';',0,0,0233,'2','d',0,0233,';','d','`',0213,'2',0,0,0213,';',0,0,0233,'2','d',0,0233,';','d','`',0213,'2',0,0,0213,';',0,'`',0233,';','n',0,0233,'4','n','X',0233,'4','@',0,0233,';','@',0201,'H',0213,';','@',0,0213,'4','@',0,0213,'4',0,0,0213,';',0,0,0233,'4','d',0,0233,';','d','`',0213,'4',0,0,0213,';',0,0,0233,'4','d',0,0233,';','d','`',0213,'4',0,0,0213,';',0,'`',0233,';','d',0,0233,'4','d','`',0213,';',0,0,0213,'4',0,'`',0233,'6','f',0,0233,'=','f',0201,'@',0213,'6',0,0,0213,'=',0,0,0233,'4','h',0,0233,';','h',0201,'@',0213,'4',0,0,0213,';',0,0,0233,'2','j',0,0233,'9','j',0201,'@',0213,'2',0,0,0213,'9',0,0,0233,'8','l',0,0233,'1','l',0201,'@',0213,'8',0,0,0213,'1',0,0,0233,'2','n',0,0233,'9','n','X',0233,'2','@',0,0233,'9','@',0201,'H',0213,'2','@',0,0213,'9','@',0,0213,'2',0,0,0213,'9',0,0,0233,'2','d',0,0233,'=','d','`',0213,'2',0,0,0213,'=',0,0,0233,'=','d',0,0233,'2','d','`',0213,'=',0,0,0213,'2',0,'`',0233,';','d',0,0233,'2','d','`',0213,';',0,0,0213,'2',0,'`',0233,'9','d',0,0233,'4','d',0201,'@',0213,'9',0,0,0213,'4',0,0,0233,'8','d',0,0233,'4','d',0201,'@',0213,'8',0,0,0213,'4',0,0,0233,'4','d',0,0233,'9','d',0201,'@',0213,'4',0,0,0213,'9',0,0,0233,'4','l',0,0233,'8','l','`',0213,'8',0,0,0233,'6','l','`',0213,'6',0,0,0233,'8','l','X',0233,'4','@',0,0233,'8','@',010,0213,'4','@',0,0213,'8','@',0,0213,'4',0,0,0213,'8',0,0,0233,'6','d',0,0233,'9','d','`',0213,'6',0,0,0213,'9',0,0,0233,'2','d',0,0233,'6','d','`',0213,'2',0,0,0213,'6',0,'`',0233,'2','d',0,0233,'9','d','`',0213,'2',0,0,0213,'9',0,'`',0233,'6','d',0,0233,';','d','`',0213,'6',0,0,0213,';',0,'`',0233,'4','d',0,0233,'8','d',0201,'@',0213,'4',0,0,0213,'8',0,0,0233,'/','d',0,0233,'4','d','`',0213,'/',0,0,0213,'4',0,'`',0233,'1','d',0,0233,'8','d','`',0213,'1',0,0,0213,'8',0,'`',0233,'1','d',0,0233,'9','d',0202,030,0233,'1','@',0,0233,'9','@',010,0213,'1','@',0,0213,'9','@',0,0213,'1',0,0,0213,'9',0,0,0233,'*','f',010,0233,'6','f','X',0213,'*',0,0,0233,'*','^',04,0213,'6',0,04,0233,'6','^','X',0213,'*',0,04,0213,'6',0,0134,0233,'*','f',010,0233,'6','f','X',0213,'*',0,04,0213,'6',0,0201,'<',0233,'*','f',010,0233,'6','f','X',0213,'*',0,0,0233,'*','^',04,0213,'6',0,04,0233,'6','^','X',0213,'*',0,04,0213,'6',0,0134,0233,'*','f',010,0233,'6','f','X',0213,'*',0,04,0213,'6',0,0204,'<',0233,'*','f',010,0233,'6','f','X',0213,'*',0,0,0233,'*','^',04,0213,'6',0,04,0233,'6','^','X',0213,'*',0,04,0213,'6',0,0134,0233,'*','f',010,0233,'6','f','X',0213,'*',0,04,0213,'6',0,0201,'<',0233,'*','f',010,0233,'6','f','X',0213,'*',0,0,0233,'*','^',04,0213,'6',0,04,0233,'6','^','X',0213,'*',0,04,0213,'6',0,0134,0233,'*','f',010,0233,'6','f','X',0213,'*',0,04,0213,'6',0,0204,'0',0273,'u',0177,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,'M','T','r','k',0,0,0,012,0,0377,'Y',02,0,0,0,0377,'/',0,};

#ifdef __cplusplus
} /* extern "C" */
#endif

```

`UnrealFinderTool/ParallelWorker.h`:

```h
#pragma once
#include <functional>
#include <thread>
#include <mutex>
#include <utility>
#include <vector>

enum class ParallelType
{
	Queue,
	SingleShot
};

struct ParallelOptions
{
	// Current index
	size_t NextIndex;
	// Make this variable true if u want to stop parallel worker
	bool ForceStop;
	// Lock to use with `std::lock_guard`
	std::mutex Locker;
};

template <typename IndexType, typename ItemType>
class ParallelWorker
{
protected:
	IndexType defaultType;
	using Lock = std::lock_guard<std::mutex>;
	using QueueFunc = std::function<void(ItemType&, ParallelOptions&)>;
	using SingleShotFunc = std::function<void(ParallelOptions&)>;

	QueueFunc funcQueue;
	SingleShotFunc funcSingleShot;

	std::vector<std::thread> threads;
	int threadsCount;

	ParallelType type;
	IndexType& queue;

public:
	ParallelOptions Options;

	ParallelWorker(IndexType& indexQueue, size_t startIndex, int threadNum, QueueFunc func);
	ParallelWorker(int threadNum, SingleShotFunc func);
	void Start();
	void WaitAll();
	static uint32_t GetCpuCores();
private:
	void Worker();
};

#pragma region ParallelWorker
// Good for any type that's have Index Operator `[]`, map, vector, array, list, ..etc
template <typename IndexType, typename ItemType>
ParallelWorker<IndexType, ItemType>::ParallelWorker(IndexType& indexQueue, const size_t startIndex, const int threadNum, QueueFunc func) :
	funcQueue(std::move(func)),
	threadsCount(threadNum),
	type(ParallelType::Queue),
	queue(indexQueue)
{
	Options.NextIndex = startIndex;
	Options.ForceStop = false;
}

// Good to use while(true) or something like that
template <typename IndexType, typename ItemType>
ParallelWorker<IndexType, ItemType>::ParallelWorker(const int threadNum, SingleShotFunc func) :
	funcSingleShot(std::move(func)),
	threadsCount(threadNum),
	type(ParallelType::SingleShot),
	queue(defaultType)
{
	Options.NextIndex = 0;
	Options.ForceStop = false;
}

template <typename IndexType, typename ItemType>
void ParallelWorker<IndexType, ItemType>::Start()
{
	Options.ForceStop = false;
	// Create and run threads
	for (int i = 0; i < threadsCount; ++i)
		threads.push_back(std::thread(&ParallelWorker::Worker, this));
}

template <typename IndexType, typename ItemType>
void ParallelWorker<IndexType, ItemType>::WaitAll()
{
	// Create and run threads
	for (int i = 0; i < threadsCount; ++i)
		threads[i].join();
}

template <typename IndexType, typename ItemType>
uint32_t ParallelWorker<IndexType, ItemType>::GetCpuCores()
{
	return std::thread::hardware_concurrency();
}

template <typename IndexType, typename ItemType>
void ParallelWorker<IndexType, ItemType>::Worker()
{
	if (type == ParallelType::Queue)
	{
		ItemType* curItem;
		while (Options.NextIndex < queue.size())
		{
			// Lock Scope (DeQueue item)
			{
				Lock lock(Options.Locker);

				if (Options.NextIndex >= queue.size() || Options.ForceStop)
				{
					Options.ForceStop = false;
					break;
				}

				curItem = &queue[Options.NextIndex];
				++Options.NextIndex;
			}

			funcQueue(*curItem, Options);
		}
	}
	else if (type == ParallelType::SingleShot)
	{
		{
			Lock lock(Options.Locker);
			++Options.NextIndex;
		}

		funcSingleShot(Options);
	}
}
#pragma endregion

#pragma region ParallelQueue
template <typename IndexType, typename ItemType>
class ParallelQueue : public ParallelWorker<IndexType, ItemType>
{
public:
	ParallelQueue(IndexType& indexQueue, size_t startIndex, int threadNum, typename ParallelWorker<IndexType, ItemType>::QueueFunc func);
};

template <typename IndexType, typename ItemType>
ParallelQueue<IndexType, ItemType>::ParallelQueue(IndexType& indexQueue, const size_t startIndex, const int threadNum, typename ParallelWorker<IndexType, ItemType>::QueueFunc func)
	: ParallelWorker<IndexType, ItemType>(indexQueue, startIndex, threadNum, func) { }
#pragma endregion

#pragma region ParallelSingleShot
class ParallelSingleShot : public ParallelWorker<std::vector<nullptr_t>, nullptr_t>
{
public:
	ParallelSingleShot(int threadNum, SingleShotFunc func);
};

inline ParallelSingleShot::ParallelSingleShot(const int threadNum, SingleShotFunc func)
	: ParallelWorker<std::vector<nullptr_t>, nullptr_t>(threadNum, func) { }
#pragma endregion

```

`UnrealFinderTool/PatternScan.cpp`:

```cpp
#include "pch.h"
#include "Memory.h"
#include "PatternScan.h"
#include "ParallelWorker.h"

#include <future>

Pattern PatternScan::Parse(const std::string& name, const int offset, std::string hexStr, const uchar_t wildcard, const std::string& delimiter)
{
	if (!delimiter.empty())
		hexStr = Utils::ReplaceString(hexStr, delimiter, "");

	char c_wildcard[3] = { '\0' }; // 3 for Null terminator
	sprintf_s(c_wildcard, sizeof(c_wildcard), "%x", wildcard);

	std::vector<unsigned char> bytes;
	for (unsigned int i = 0; i < hexStr.length(); i += 2)
	{
		auto byte_string = hexStr.substr(i, 2);

		if (byte_string == "??")
			byte_string = c_wildcard;

		bytes.push_back(static_cast<char>(strtol(byte_string.c_str(), nullptr, 16)));
	}

	// Fill Struct
	Pattern ret;
	ret.Name = name;
	ret.Sig = bytes;
	ret.Offset = offset;
	ret.Len = bytes.size();
	ret.Wildcard = wildcard;

	return ret;
}

Pattern PatternScan::Parse(const std::string& name, const int offset, const std::string& patternStr, const uchar_t wildcard)
{
	return Parse(name, offset, patternStr, wildcard, " ");
}

PatternScanResult PatternScan::FindPattern(Memory* mem, uintptr_t dwStart, uintptr_t dwEnd, std::vector<Pattern> patterns,
	const bool firstOnly, const bool useThreads)
{
	std::vector<RegionHolder> mem_regions;
	PatternScanResult ret;
	std::vector<uintptr_t> result;

	// Init map
	for (auto& pattern : patterns)
		ret[pattern.Name] = std::vector<uintptr_t>();

	SYSTEM_INFO si = { 0 };
	GetSystemInfo(&si);

	if (dwStart < reinterpret_cast<uintptr_t>(si.lpMinimumApplicationAddress) || dwStart == 0)
		dwStart = reinterpret_cast<uintptr_t>(si.lpMinimumApplicationAddress);

	if (dwEnd > reinterpret_cast<uintptr_t>(si.lpMaximumApplicationAddress) || dwEnd == 0)
		dwEnd = reinterpret_cast<uintptr_t>(si.lpMaximumApplicationAddress);

	MEMORY_BASIC_INFORMATION info = { 0 };

	// Cycle through memory based on RegionSize
	{
		uintptr_t currentAddress = dwStart;
		bool exitLoop = false;

		do
		{
			// Get Region information
			exitLoop = !(VirtualQueryEx(mem->ProcessHandle, reinterpret_cast<LPVOID>(currentAddress), &info, sizeof info) == sizeof info && currentAddress < dwEnd);

			if (exitLoop)
				break;

			// Size will used to alloc and read memory
			const size_t allocSize = dwEnd - dwStart >= info.RegionSize ? info.RegionSize : dwEnd - dwStart;

			// Bad Memory
			if (!(info.State & MEM_COMMIT) || info.Protect & (PAGE_NOACCESS | PAGE_WRITECOPY | PAGE_TARGETS_INVALID) || info.RegionSize > 0x300000)
			{
				// Get next address
				currentAddress += allocSize;
				continue;
			}

			// Insert region information on Regions Holder
			mem_regions.emplace_back(currentAddress, allocSize);

			// Get next address
			currentAddress += allocSize;

		} while (true);
	}
	
	if (useThreads)
	{
		ParallelQueue<std::vector<RegionHolder>, RegionHolder> 
		worker(mem_regions, 0, Utils::Settings.SdkGen.Threads, [&](RegionHolder& memRegion, ParallelOptions& options)
		{
			const auto pBuf = new BYTE[memRegion.second];

			// Read one page or skip if failed
			const size_t dwOut = mem->ReadBytes(memRegion.first, pBuf, memRegion.second);
			if (dwOut == 0)
			{
				delete[] pBuf;
			}
			else
			{
				// Scan for all pattern in the same memory region
				for (auto& pattern : patterns)
				{
					size_t k = 0;
					const uchar_t* uPattern = pattern.Sig.data();
					const auto nLen = pattern.Len;

					for (size_t j = 0; j <= dwOut; j++)
					{
						// If the byte matches our pattern or wildcard
						if (pBuf[j] == uPattern[k] || uPattern[k] == pattern.Wildcard)
						{
							// Did we find it?
							if (++k == nLen)
							{
								// Our match function places us at the begin of the pattern
								// To locate the pointer we need to subtract nOffset bytes
								std::lock_guard lock(options.Locker);
								ret.find(pattern.Name)->second.push_back(memRegion.first + j - (nLen - 1) + pattern.Offset);
								if (firstOnly)
								{
									options.ForceStop = true;
									break;
								}
							}
						}
						else
						{
							k = 0;
						}
					}
				}

				delete[] pBuf;
			}
		});

		worker.Start();
		worker.WaitAll();
	}
	else
	{
		for (RegionHolder memRegion : mem_regions)
		{
			const auto pBuf = new BYTE[memRegion.second];

			// Read one page or skip if failed
			const SIZE_T dwOut = mem->ReadBytes(memRegion.first, pBuf, memRegion.second);
			if (dwOut == 0)
			{
				delete[] pBuf;
				continue;
			}

			// Scan for all pattern in the same memory region
			for (auto& pattern : patterns)
			{
				size_t k = 0;
				const uchar_t* uPattern = pattern.Sig.data();
				const auto nLen = pattern.Len;

				for (size_t j = 0; j <= dwOut; j++)
				{
					// If the byte matches our pattern or wildcard
					if (pBuf[j] == uPattern[k] || uPattern[k] == pattern.Wildcard)
					{
						// Did we find it?
						if (++k == nLen)
						{
							// Our match function places us at the begin of the pattern
							// To locate the pointer we need to subtract nOffset bytes
							ret.find(pattern.Name)->second.push_back(memRegion.first + j - (nLen - 1) + pattern.Offset);

							if (firstOnly)
								break;
						}
					}
					else
					{
						k = 0;
					}
				}
			}

			delete[] pBuf;
		}
	}

	return ret;
}
```

`UnrealFinderTool/PatternScan.h`:

```h
#pragma once
#include <string>
#include <map>
#include <vector>
#include "Process.h"

class Memory;

typedef unsigned char uchar_t;
using RegionHolder = std::pair<uintptr_t, size_t>;
using PatternScanResult = std::map<std::string, std::vector<uintptr_t>>;

struct Pattern
{
	std::string Name;
	std::vector<uchar_t> Sig;
	size_t Len;
	int Offset;
	uchar_t Wildcard;
};

struct MemoryRegion
{
	uintptr_t Address;
	SIZE_T RegionSize;
};

class PatternScan
{
	static Pattern Parse(const std::string& name, int offset, std::string hexStr, uchar_t wildcard, const std::string& delimiter);
public:
	static Pattern Parse(const std::string& name, int offset, const std::string& patternStr, uchar_t wildcard);
	static PatternScanResult FindPattern(Memory* mem, uintptr_t dwStart, uintptr_t dwEnd,
	                                                          std::vector<Pattern> patterns, bool firstOnly = false,
	                                                          bool useThreads = false);
};
```

`UnrealFinderTool/Scanner.cpp`:

```cpp
#include "pch.h"
#include "Scanner.h"
#include <cassert>
#include <Tlhelp32.h>
#include "ParallelWorker.h"

using namespace Hyperscan;

BOOL HYPERSCAN_CHECK::IsHandleValid(HANDLE ProcessHandle)
{
	if (NULL == ProcessHandle || INVALID_HANDLE_VALUE == ProcessHandle)
	{
		return FALSE;
	}

	DWORD HandleInformation;

	if (TRUE == GetHandleInformation(ProcessHandle, &HandleInformation))
	{
		return TRUE;
	}

	return FALSE;
}

BOOL HYPERSCAN_CHECK::IsProcess64Bit(HANDLE ProcessHandle)
{
	if (NULL == ProcessHandle || INVALID_HANDLE_VALUE == ProcessHandle)
	{
		return FALSE;
	}

	if (TRUE == HYPERSCAN_CHECK::IsHandleValid(ProcessHandle))
	{
		BOOL CheckResult = FALSE;

		if (TRUE == IsWow64Process(ProcessHandle, &CheckResult))
		{
			return CheckResult;
		}

		return FALSE;
	}

	return FALSE;
}

struct SECTION_INFO
{
	WORD Len;
	WORD MaxLen;
	wchar_t * szData;
	BYTE pData[MAX_PATH * 2];
};

typedef enum _MEMORY_INFORMATION_CLASS
{
	MemoryBasicInformation,
	MemoryWorkingSetInformation,
	MemoryMappedFilenameInformation,
	MemoryRegionInformation,
	MemoryWorkingSetExInformation,
	MemorySharedCommitInformation,
	MemoryImageInformation,
	MemoryRegionInformationEx,
	MemoryPrivilegedBasicInformation,
	MemoryEnclaveImageInformation,
	MemoryBasicInformationCapped
} MEMORY_INFORMATION_CLASS;

typedef NTSTATUS(NTAPI *hsNtQueryVirtualMemory)(
	HANDLE ProcessHandle,
	PVOID BaseAddress, MEMORY_INFORMATION_CLASS MemoryInformationClass,
	PVOID Buffer, SIZE_T Length, PSIZE_T ResultLength
	);

BOOL HYPERSCAN_CHECK::IsAddressStatic(DWORD ProcessID, uintptr_t Address)
{
	if (NULL == ProcessID || NULL == Address)
	{
		return FALSE;
	}

	LPVOID QueryVirtualMemoryAddress = GetProcAddress(LoadLibraryW(L"ntdll.dll"), "NtQueryVirtualMemory");

	if (nullptr == QueryVirtualMemoryAddress)
	{
		return FALSE;
	}

	auto QueryVirtualMemory = reinterpret_cast<hsNtQueryVirtualMemory>(QueryVirtualMemoryAddress);

	HANDLE ProcessHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, ProcessID);

	if (FALSE == IsHandleValid(ProcessHandle))
	{
		return FALSE;
	}

	SECTION_INFO SectionInformation;

	NTSTATUS ReturnStatus = QueryVirtualMemory(ProcessHandle, reinterpret_cast<PVOID>(Address), MemoryMappedFilenameInformation, &SectionInformation, sizeof(SectionInformation), nullptr);

	if (!NT_SUCCESS(ReturnStatus))
	{
		CloseHandle(ProcessHandle);
		return FALSE;
	}

	wchar_t * DeviceName = SectionInformation.szData;
	wchar_t * FilePath = DeviceName;

	while (*(FilePath++) != '\\');
	while (*(FilePath++) != '\\');
	while (*(FilePath++) != '\\');
	*(FilePath - 1) = 0;

	auto DriveLetters = new wchar_t[MAX_PATH + 1];
	auto DriveSize = GetLogicalDriveStringsW(MAX_PATH, DriveLetters);

	if (DriveSize > MAX_PATH)
	{
		delete[] DriveLetters;
		DriveLetters = new wchar_t[DriveSize + 1];
		DriveSize = GetLogicalDriveStringsW(DriveSize, DriveLetters);
	}

	for (int i = 0; i != DriveSize / 4; ++i)
	{
		DriveLetters[i * 4 + 2] = 0;
		wchar_t Buffer[64]{ 0 };

		QueryDosDeviceW(&DriveLetters[i * 4], Buffer, 64 * 2);

		if (!wcscmp(Buffer, DeviceName))
		{
			FilePath -= 3;
			FilePath[2] = '\\';
			FilePath[1] = ':';
			FilePath[0] = DriveLetters[i * 4];

			delete[] DriveLetters;

			/*
			HMODULE Ret = GetModuleHandleW(FilePath);

			if (nullptr == Ret)
			{
				CloseHandle(ProcessHandle);
				return FALSE;
			}
			Address = reinterpret_cast<uintptr_t>(Ret);
			*/

			CloseHandle(ProcessHandle);
			return TRUE;
		}
	}

	delete[] DriveLetters;
	CloseHandle(ProcessHandle);

	return FALSE;
}

std::vector<uintptr_t> HYPERSCAN_SCANNER::ScanMemory(DWORD ProcessID, uintptr_t ModuleBaseAddress, uintptr_t ModuleSize, uintptr_t ScanValue,
	ScanAllignment AllignmentOfScan, ScanType TypeOfScan)
{
	std::vector<uintptr_t> AddressHolder;
	AddressHolder.clear();

	if (NULL == ProcessID || NULL == ModuleBaseAddress || NULL == ModuleSize || NULL == AllignmentOfScan
		|| NULL == TypeOfScan)
	{
		return AddressHolder;
	}

	_MEMORY_BASIC_INFORMATION BasicInformation;
	uintptr_t AddressForScan = ModuleBaseAddress;
	HANDLE QueryHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, ProcessID);

#ifndef _WIN64
	if (TRUE == HYPERSCAN_CHECK::IsProcess64Bit(QueryHandle))
	{
		assert("Incompatibility in architectures!");
	}
#endif


	if (INVALID_HANDLE_VALUE == QueryHandle)
	{
		return AddressHolder;
	}

	std::vector<std::pair<uintptr_t, _MEMORY_BASIC_INFORMATION>> mem_blocks;

	while (VirtualQueryEx(QueryHandle, reinterpret_cast<void*>(AddressForScan), &BasicInformation, sizeof(BasicInformation))
		&& AddressForScan < (ModuleBaseAddress + ModuleSize))
	{
		if (BasicInformation.State & MEM_COMMIT)
			mem_blocks.emplace_back(AddressForScan, BasicInformation);
		AddressForScan = reinterpret_cast<uintptr_t>(BasicInformation.BaseAddress) + BasicInformation.RegionSize;
	}

	for (std::pair<uintptr_t, _MEMORY_BASIC_INFORMATION> block : mem_blocks)
	{
		auto memory_block = new UCHAR[block.second.RegionSize];
		if (ReadProcessMemory(QueryHandle, reinterpret_cast<void*>(block.first), memory_block, block.second.RegionSize,
			nullptr))
		{
			for (unsigned int scanIndex = 0; scanIndex != block.second.RegionSize / AllignmentOfScan; ++scanIndex)
			{
				if (HyperscanTypeAll == TypeOfScan)
				{
					AddressHolder.push_back(block.first + scanIndex * AllignmentOfScan);
				}
				else if (HyperscanTypeExact == TypeOfScan)
				{
					if (*reinterpret_cast<uintptr_t*>(memory_block + scanIndex * AllignmentOfScan) == ScanValue)
					{
						AddressHolder.push_back(block.first + scanIndex * AllignmentOfScan);
					}
				}
				else if (HyperscanTypeSmaller == TypeOfScan)
				{
					if (*reinterpret_cast<uintptr_t*>(memory_block + scanIndex * AllignmentOfScan) < ScanValue)
					{
						AddressHolder.push_back(block.first + scanIndex * AllignmentOfScan);
					}
				}
				else if (HyperscanTypeBigger == TypeOfScan)
				{
					if (*reinterpret_cast<uintptr_t*>(memory_block + scanIndex * AllignmentOfScan) > ScanValue)
					{
						AddressHolder.push_back(block.first + scanIndex * AllignmentOfScan);
					}
				}
				else if (HyperscanTypeDifferent == TypeOfScan)
				{
					if (*reinterpret_cast<uintptr_t*>(memory_block + scanIndex * AllignmentOfScan) != ScanValue)
					{
						AddressHolder.push_back(block.first + scanIndex * AllignmentOfScan);
					}
				}
				else
				{
					if (*reinterpret_cast<uintptr_t*>(memory_block + scanIndex * AllignmentOfScan) == ScanValue)
					{
						AddressHolder.push_back(block.first + scanIndex * AllignmentOfScan);
					}
				}
			}
		}
		delete[] memory_block;
	}
	CloseHandle(QueryHandle);
	return AddressHolder;
}

std::vector<uintptr_t> HYPERSCAN_SCANNER::ScanModules(DWORD ProcessID, uintptr_t ScanValue, ScanAllignment AllignmentOfScan,
	ScanType TypeOfScan)
{
	std::vector<uintptr_t> AddressHolder;
	AddressHolder.clear();

	if (NULL == ProcessID || NULL == AllignmentOfScan || NULL == TypeOfScan)
		return AddressHolder;

	HANDLE ModuleSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, ProcessID);

	if (INVALID_HANDLE_VALUE == ModuleSnapshot)
		return AddressHolder;

	MODULEENTRY32 ModuleEntry;
	ModuleEntry.dwSize = sizeof(MODULEENTRY32);

	if (Module32First(ModuleSnapshot, &ModuleEntry))
	{
		do
		{
			std::vector<uintptr_t> TemporaryAddressHolder;
			TemporaryAddressHolder.clear();

			TemporaryAddressHolder = ScanMemory(ProcessID, reinterpret_cast<uintptr_t>(ModuleEntry.modBaseAddr), ModuleEntry.modBaseSize,
				ScanValue, AllignmentOfScan, TypeOfScan);

			AddressHolder.insert(AddressHolder.end(), TemporaryAddressHolder.begin(), TemporaryAddressHolder.end());
		} while (Module32Next(ModuleSnapshot, &ModuleEntry));
	}

	CloseHandle(ModuleSnapshot);
	return AddressHolder;
}

std::vector<uintptr_t> HYPERSCAN_SCANNER::ScanWholeMemoryWithDelimiters(DWORD ProcessID, uintptr_t ScanValue, ScanAllignment AllignmentOfScan,
	ScanType TypeOfScan, uintptr_t BeginAddress, uintptr_t EndAddress)
{
	std::vector<uintptr_t> AddressHolder;
	AddressHolder.clear();

	if (NULL == ProcessID || NULL == EndAddress || NULL == AllignmentOfScan || NULL == TypeOfScan)
		return AddressHolder;

	_MEMORY_BASIC_INFORMATION BasicInformation;
	uintptr_t AddressForScan = BeginAddress;
	HANDLE QueryHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, ProcessID);

#ifndef _WIN64
	if (TRUE == HYPERSCAN_CHECK::IsProcess64Bit(QueryHandle))
	{
		assert("Incompatibility in architectures!");
	}
#endif

	if (INVALID_HANDLE_VALUE == QueryHandle)
		return AddressHolder;

	std::vector<std::pair<uintptr_t, _MEMORY_BASIC_INFORMATION>> mem_blocks;
	while (VirtualQueryEx(QueryHandle, reinterpret_cast<VOID*>(AddressForScan), &BasicInformation, sizeof(BasicInformation))
		&& AddressForScan < EndAddress)
	{
		if (BasicInformation.State & MEM_COMMIT && BasicInformation.Type & MEM_PRIVATE)
		{
			mem_blocks.emplace_back(AddressForScan, BasicInformation);
		}
		AddressForScan = reinterpret_cast<uintptr_t>(BasicInformation.BaseAddress) + BasicInformation.RegionSize;
	}

	ParallelQueue<std::vector<std::pair<uintptr_t, _MEMORY_BASIC_INFORMATION>>, std::pair<uintptr_t, _MEMORY_BASIC_INFORMATION>>
	worker(mem_blocks, 0, Utils::Settings.SdkGen.Threads, [&](const std::pair<uintptr_t, _MEMORY_BASIC_INFORMATION>& block, ParallelOptions& options)
	{
		auto MemoryBlock = new UCHAR[block.second.RegionSize];
		if (ReadProcessMemory(QueryHandle, reinterpret_cast<void*>(block.first), MemoryBlock, block.second.RegionSize,
			nullptr))
		{
			for (unsigned int scanIndex = 0; scanIndex != block.second.RegionSize / AllignmentOfScan; ++scanIndex)
			{
				if (HyperscanTypeAll == TypeOfScan)
				{
					std::lock_guard lock(options.Locker);
					AddressHolder.push_back(block.first + scanIndex * AllignmentOfScan);
				}
				else if (HyperscanTypeExact == TypeOfScan)
				{
					if (*reinterpret_cast<uintptr_t*>(MemoryBlock + scanIndex * AllignmentOfScan) == ScanValue)
					{
						std::lock_guard lock(options.Locker);
						AddressHolder.push_back(block.first + scanIndex * AllignmentOfScan);
					}
				}
				else if (HyperscanTypeSmaller == TypeOfScan)
				{
					if (*reinterpret_cast<uintptr_t*>(MemoryBlock + scanIndex * AllignmentOfScan) < ScanValue)
					{
						std::lock_guard lock(options.Locker);
						AddressHolder.push_back(block.first + scanIndex * AllignmentOfScan);
					}
				}
				else if (HyperscanTypeBigger == TypeOfScan)
				{
					if (*reinterpret_cast<uintptr_t*>(MemoryBlock + scanIndex * AllignmentOfScan) > ScanValue)
					{
						std::lock_guard lock(options.Locker);
						AddressHolder.push_back(block.first + scanIndex * AllignmentOfScan);
					}
				}
				else if (HyperscanTypeDifferent == TypeOfScan)
				{
					if (*reinterpret_cast<uintptr_t*>(MemoryBlock + scanIndex * AllignmentOfScan) != ScanValue)
					{
						std::lock_guard lock(options.Locker);
						AddressHolder.push_back(block.first + scanIndex * AllignmentOfScan);
					}
				}
				else
				{
					if (*reinterpret_cast<uintptr_t*>(MemoryBlock + scanIndex * AllignmentOfScan) == ScanValue)
					{
						std::lock_guard lock(options.Locker);
						AddressHolder.push_back(block.first + scanIndex * AllignmentOfScan);
					}
				}
			}
		}
		delete[] MemoryBlock;
	});
	worker.Start();
	worker.WaitAll();

	CloseHandle(QueryHandle);
	return AddressHolder;
}

std::vector<uintptr_t> HYPERSCAN_SCANNER::Scan(DWORD ProcessID, uintptr_t ScanValue, ScanAllignment allignmentOfScan, ScanType TypeOfScan)
{
	std::vector<uintptr_t> AddressHolder;
	AddressHolder.clear();

	if (NULL == ProcessID || NULL == allignmentOfScan || NULL == TypeOfScan)
	{
		return AddressHolder;
	}

	std::vector<uintptr_t> ModuleScan;
	ModuleScan.clear();

	std::vector<uintptr_t> MemoryScan;
	MemoryScan.clear();

	ModuleScan = ScanModules(ProcessID, ScanValue, allignmentOfScan, TypeOfScan);
	MemoryScan = ScanWholeMemoryWithDelimiters(ProcessID, ScanValue, allignmentOfScan, TypeOfScan);

	AddressHolder.insert(AddressHolder.end(), ModuleScan.begin(), ModuleScan.end());
	AddressHolder.insert(AddressHolder.end(), MemoryScan.begin(), MemoryScan.end());

	return AddressHolder;
}
```

`UnrealFinderTool/Scanner.h`:

```h
#pragma once
#include <iostream>
#include <windows.h>
#include <vector>

#ifndef _WIN64
#undef INT
#define INT int32_t
#else
#undef INT
#define INT int64_t
#endif

namespace Hyperscan
{
	enum ScanAllignment : DWORD
	{
		HyperscanAllignmentByte = 0x1,
		HyperscanAllignment2Bytes = 0x2,
		HyperscanAllignment4Bytes = 0x4,
		HyperscanAllignment8Bytes = 0x8
	};

	enum ScanType : DWORD
	{
		HyperscanTypeExact = 0x00E,
		HyperscanTypeSmaller = 0x0E,
		HyperscanTypeBigger = 0x000E,
		HyperscanTypeDifferent = 0x0000A,
		HyperscanTypeAll = 0xABCDEF
	};

	enum ScanMode : DWORD
	{
		HyperscanScanFirst = 0xFF0,
		HyperscanScanNext = 0x0FF
	};

	typedef class HYPERSCAN_CHECK
	{
	public: static BOOL IsHandleValid(HANDLE ProcessHandle);

	public: static BOOL IsProcess64Bit(HANDLE ProcessHandle);

	public: static BOOL IsAddressStatic(DWORD ProcessID, uintptr_t Address);
	} *PHYPERSCAN_CHECK;

	typedef class HYPERSCAN_SCANNER
	{
	private: static std::vector<UINT_PTR> ScanMemory(DWORD ProcessID, UINT_PTR ModuleBaseAddress, UINT_PTR ModuleSize, uintptr_t ScanValue,
		ScanAllignment AllignmentOfScan, ScanType TypeOfScan);

	private: static std::vector<UINT_PTR> ScanModules(DWORD ProcessID, uintptr_t ScanValue, ScanAllignment AllignmentOfScan,
		ScanType TypeOfScan);

	private: static std::vector<UINT_PTR> ScanWholeMemoryWithDelimiters(DWORD ProcessID, uintptr_t ScanValue, ScanAllignment AllignmentOfScan,
		ScanType TypeOfScan, uintptr_t BeginAddress = 0x000000000, uintptr_t EndAddress = 0x7fffffffffff);

	public: static std::vector<UINT_PTR> Scan(DWORD ProcessID, uintptr_t ScanValue, ScanAllignment allignmentOfScan, ScanType TypeOfScan);
	} *PHYPERSCAN_SCANNER;
}

```

`UnrealFinderTool/SdkGen/Engine/IGenerator.h`:

```h
#pragma once

#include <string>
#include <unordered_map>
#include <vector>
#include <iterator>
#include "PatternScan.h"

enum class SdkType
{
	Internal = 0,
	External = 1
};

class IGenerator
{
public:
	virtual ~IGenerator() = default;

	/// <summary>
	/// Initializes this object.
	/// Add predefined types, ...
	/// </summary>
	/// <returns>true if it succeeds, false if it fails.</returns>
	virtual bool Initialize() = 0;

	/// <summary>
	/// Gets output directory where the files are getting stored.
	/// The name of the game gets appended to this directory.
	/// </summary>
	/// <returns>The output directory.</returns>
	virtual std::string GetOutputDirectory() const
	{
		return "C:/SDK_GEN";
	}

	/// <summary>
	/// Gets the name of the game.
	/// </summary>
	/// <returns>The game name. </returns>
	virtual std::string GetGameName() const = 0;

	/// <summary>
	/// Gets the name of the game.
	/// </summary>
	/// <returns>The game name. </returns>
	virtual void SetGameName(const std::string& gameName) const = 0;

	/// <summary>
	/// Sets the version of the game.
	/// </summary>
	/// <returns>The version of the game.</returns>
	virtual void SetGameVersion(const std::string& gameVersion) const = 0;

	/// <summary>
	/// Gets the version of the game.
	/// </summary>
	/// <returns>The version of the game.</returns>
	virtual std::string GetGameVersion() const = 0;

	/// <summary>
	/// Gets generator type.
	/// </summary>
	virtual SdkType GetSdkType() const = 0;

	/// <summary>
	/// Sets generator type.
	/// </summary>
	/// <returns>The version of the game.</returns>
	virtual void SetSdkType(SdkType sdkType) const = 0;

	virtual void SetIsGObjectsChunks(bool isChunks) const = 0;

	/// <summary>
	/// Check if the generator should dump the object and name arrays.
	/// </summary>
	/// <returns>true if the arrays should get dumped.</returns>
	virtual bool ShouldDumpArrays() const
	{
		return false;
	}

	/// <summary>
	/// Check if the generator should generate empty files (no classes, structs, ...).
	/// </summary>
	/// <returns>true if empty files should get generated.</returns>
	virtual bool ShouldGenerateEmptyFiles() const
	{
		return false;
	}

	/// <summary>
	/// Check if the generated classes should use strings to identify objects.
	/// If false the generated classes use the object index.
	/// Warning: The object index may change for non default classes.
	/// </summary>
	/// <returns>true if strings should be used.</returns>
	virtual bool ShouldUseStrings() const
	{
		return true;
	}

	/// <summary>
	/// Check if strings (<see cref="ShouldUseStrings()" />) should be xor encoded.
	/// </summary>
	/// <returns>true if string should be xor encoded.</returns>
	virtual bool ShouldXorStrings() const
	{
		return false;
	}

	/// <summary>
	/// Check if static methods should get converted to normal methods.
	/// Static methods require a CreateDefaultObject() method in the UObject class.
	/// </summary>
	/// <returns>true if static methods should get converted to normal methods.</returns>
	virtual bool ShouldConvertStaticMethods() const
	{
		return true;
	}

	/// <summary>
	/// Check if we should generate a function parameters file.
	/// Otherwise the parameters are declared inside the function body.
	/// If hooks with access to the parameters are need, this method should return true.
	/// </summary>
	/// <returns>True if a function parameters file should be generated.</returns>
	virtual bool ShouldGenerateFunctionParametersFile() const = 0;

	/// <summary>
	/// Gets namespace name for the classes. If the name is empty no namespace gets generated.
	/// </summary>
	/// <returns>The namespace name.</returns>
	virtual std::string GetNamespaceName() const
	{
		return std::string();
	}

	/// <summary>
	/// Gets a list of custom include files which gets inserted in the SDK.
	/// </summary>
	/// <returns>The list of include files.</returns>
	virtual std::vector<std::string> GetIncludes() const
	{
		return {};
	}

	/// <summary>
	/// Gets the member alignment.
	/// https://msdn.microsoft.com/en-us/library/2e70t5y1.aspx
	/// </summary>
	/// <returns>The member alignment.</returns>
	virtual size_t GetGlobalMemberAlignment() const
	{
		return sizeof(size_t);
	}

	/// <summary>
	/// Gets alignas size for the specific class.
	/// http://cppreference.com/w/cpp/language/alignas
	/// </summary>
	/// <param name="name">The name.</param>
	/// <returns>If the class is not found the return value is 0, else the alignas size.</returns>
	virtual size_t GetClassAlignas(const std::string& name) const
	{
		auto it = alignasClasses.find(name);
		if (it != std::end(alignasClasses))
		{
			return it->second;
		}
		return 0;
	}

	/// <summary>
	/// Gets the declarations of some basic classes and methods.
	/// </summary>
	/// <returns>The basic declarations.</returns>
	virtual std::string GetBasicDeclarations() const
	{
		return std::string();
	}

	/// <summary>
	/// Gets the definitions of the <see cref="GetBasicDeclarations()" /> declarations.
	/// </summary>
	/// <returns>The basic definitions.</returns>
	virtual std::string GetBasicDefinitions() const
	{
		return std::string();
	}

	/// <summary>
	/// Checks if an override is defined for the given type.
	/// </summary>
	/// <param name="type">The parameter type.</param>
	/// <returns>If no override is found the original name is returned.</returns>
	virtual std::string GetOverrideType(const std::string& type) const
	{
		auto it = overrideTypes.find(type);
		if (it == std::end(overrideTypes))
		{
			return type;
		}
		return it->second;
	}

	/// <summary>
	/// Checks if a name is Cpp Keywords.
	/// </summary>
	/// <param name="name">The parameter name.</param>
	/// <returns>If no override is found the original name is returned.</returns>
	virtual std::string GetSafeKeywordsName(const std::string& name) const
	{
		std::string ret = name;
		auto it = keywordsName.find(ret);
		if (it == std::end(keywordsName))
		{
			for (const auto& badChar : badChars)
				ret = Utils::ReplaceString(ret, badChar.first, badChar.second);
			return ret;
		}

		ret = it->second;
		for (const auto& badChar : badChars)
			ret = Utils::ReplaceString(ret, badChar.first, badChar.second);

		return ret;
	}

	struct PredefinedMember
	{
		std::string Type;
		std::string Name;
	};

	/// <summary>
	/// Gets the predefined members of the specific class.
	/// </summary>
	/// <param name="name">The name of the class.</param>
	/// <param name="members">[out] The predefined members.</param>
	/// <returns>true if predefined members are found.</returns>
	virtual bool GetPredefinedClassMembers(const std::string& name, std::vector<PredefinedMember>& members) const
	{
		auto it = predefinedMembers.find(name);
		if (it != std::end(predefinedMembers))
		{
			std::copy(std::begin(it->second), std::end(it->second), std::back_inserter(members));

			return true;
		}

		return false;
	}

	/// <summary>
	/// Gets the static predefined members of the specific class.
	/// </summary>
	/// <param name="name">The name of the class.</param>
	/// <param name="members">[out] The predefined members.</param>
	/// <returns>true if predefined members are found.</returns>
	virtual bool GetPredefinedClassStaticMembers(const std::string& name, std::vector<PredefinedMember>& members) const
	{
		auto it = predefinedStaticMembers.find(name);
		if (it != std::end(predefinedStaticMembers))
		{
			std::copy(std::begin(it->second), std::end(it->second), std::back_inserter(members));

			return true;
		}

		return false;
	}

	using VirtualFunctionPatterns = std::vector<std::tuple<Pattern, const char*>>;

	/// <summary>
	/// Gets the patterns of virtual functions of the specific class.
	/// The generator loops the virtual functions of the class and adds a class method if the pattern matches.
	/// </summary>
	/// <param name="name">The name of the class.</param>
	/// <param name="patterns">[out] The patterns.</param>
	/// <returns>true if patterns are found.</returns>
	virtual bool GetVirtualFunctionPatterns(const std::string& name, VirtualFunctionPatterns& patterns) const
	{
		auto it = virtualFunctionPattern.find(name);
		if (it != std::end(virtualFunctionPattern))
		{
			std::copy(std::begin(it->second), std::end(it->second), std::back_inserter(patterns));

			return true;
		}

		return false;
	}

	struct PredefinedMethod
	{
		enum class Type
		{
			Default,
			Inline
		};

		std::string Signature;
		std::string Body;
		Type MethodType;

		/// <summary>Adds a predefined method which gets splittet in declaration and definition.</summary>
		/// <param name="signature">The method signature.</param>
		/// <param name="body">The method body.</param>
		/// <returns>The method.</returns>
		static PredefinedMethod Default(std::string&& signature, std::string&& body)
		{
			return { signature, body, Type::Default };
		}

		/// <summary>Adds a predefined method which gets included as an inline method.</summary>
		/// <param name="body">The body.</param>
		/// <returns>The method.</returns>
		static PredefinedMethod Inline(std::string&& body)
		{
			return { std::string(), body, Type::Inline };
		}
	};

	/// <summary>Gets the predefined methods of the specific class.</summary>
	/// <param name="name">The name of the class.</param>
	/// <param name="methods">[out] The predefined methods.</param>
	/// <returns>true if predefined methods are found.</returns>
	virtual bool GetPredefinedClassMethods(const std::string& name, std::vector<PredefinedMethod>& methods) const
	{
		auto it = predefinedMethods.find(name);
		if (it != std::end(predefinedMethods))
		{
			std::copy(std::begin(it->second), std::end(it->second), std::back_inserter(methods));

			return true;
		}

		return false;
	}

protected:
	std::unordered_map<std::string, size_t> alignasClasses;
	std::unordered_map<std::string, std::string> badChars;
	std::unordered_map<std::string, std::string> keywordsName;
	std::unordered_map<std::string, std::string> overrideTypes;
	std::unordered_map<std::string, std::vector<PredefinedMember>> predefinedMembers;
	std::unordered_map<std::string, std::vector<PredefinedMember>> predefinedStaticMembers;
	std::unordered_map<std::string, std::vector<PredefinedMethod>> predefinedMethods;
	std::unordered_map<std::string, VirtualFunctionPatterns> virtualFunctionPattern;
};

```

`UnrealFinderTool/SdkGen/Engine/NameValidator.cpp`:

```cpp
#include "pch.h"
#include "NameValidator.h"

#include <cctype>

#include "ObjectsStore.h"

std::string MakeValidName(std::string&& name)
{
	std::string valid(name);

	for (auto i = 0u; i < name.length(); ++i)
	{
		if (valid[i] == ' '
			|| valid[i] == '?'
			|| valid[i] == '+'
			|| valid[i] == '-'
			|| valid[i] == ':'
			|| valid[i] == '/'
			|| valid[i] == '^'
			|| valid[i] == '('
			|| valid[i] == ')'
			|| valid[i] == '['
			|| valid[i] == ']'
			|| valid[i] == '<'
			|| valid[i] == '>'
			|| valid[i] == '&'
			|| valid[i] == '.'
			|| valid[i] == '#'
			|| valid[i] == '\''
			|| valid[i] == '"'
			|| valid[i] == '%')
		{
			valid[i] = '_';
		}
	}

	if (!valid.empty())
	{
		if (std::isdigit(valid[0]))
		{
			valid = '_' + valid;
		}
	}

	return valid;
}

std::string SimplifyEnumName(std::string&& name)
{
	const auto index = name.find_last_of(':');
	if (index == std::string::npos)
		return "";

	return name.substr(index + 1);
}

template<typename T>
std::string MakeUniqueCppNameImpl(const T& t)
{
	std::string name;
	if (ObjectsStore().CountObjects<T>(t.GetName()) > 1)
	{
		name += MakeValidName(t.GetOuter()->GetName()) + "_";
	}
	return name + MakeValidName(t.GetName());
}

std::string MakeUniqueCppName(const UEConst& c)
{
	return MakeUniqueCppNameImpl(c);
}

std::string MakeUniqueCppName(const UEEnum& e)
{
	auto name = MakeUniqueCppNameImpl(e);
	if (!name.empty() && name[0] != 'E')
	{
		name = 'E' + name;
	}
	return name;
}

std::string MakeUniqueCppName(const UEStruct& ss)
{
	std::string name;
	if (ss.IsValid())
	{
		if (ObjectsStore().CountObjects<UEStruct>(ss.GetName()) > 1)
		{
			name += MakeValidName(ss.GetOuter()->GetNameCpp()) + "_";
		}
	}
	
	return name + MakeValidName(ss.GetNameCpp());
}

```

`UnrealFinderTool/SdkGen/Engine/NameValidator.h`:

```h
#pragma once

#include <string>

class UEConst;
class UEEnum;
class UEStruct;

/// <summary>
/// Makes valid C++ name from the given name.
/// </summary>
/// <param name="name">The name to process.</param>
/// <returns>A valid C++ name.</returns>
std::string MakeValidName(std::string&& name);

std::string SimplifyEnumName(std::string&& name);

std::string MakeUniqueCppName(const UEConst& c);
std::string MakeUniqueCppName(const UEEnum& e);
std::string MakeUniqueCppName(const UEStruct& ss);

```

`UnrealFinderTool/SdkGen/Engine/NamesStore.cpp`:

```cpp
#include "pch.h"
#include "Memory.h"
#include "NamesStore.h"

std::vector<FNameEntity> NamesStore::gNames;
int NamesStore::chunkCount = 16384;
int NamesStore::gNamesChunks;
uintptr_t NamesStore::gNamesAddress;

#pragma region NamesStore
bool NamesStore::Initialize(const uintptr_t gNamesAddress, const bool forceReInit)
{
	if (!forceReInit && NamesStore::gNamesAddress != NULL)
		return true;

	gNames.clear();
	gNamesChunks = 0;

	NamesStore::gNamesAddress = gNamesAddress;
	return ReadGNameArray(gNamesAddress);
}

bool NamesStore::ReadGNameArray(const uintptr_t address)
{
	int ptrSize = Utils::PointerSize();
	size_t nameOffset = 0;

	// Get GNames Chunks
	std::vector<uintptr_t> gChunks;
	for (int i = 0; i < 30; ++i)
	{
		uintptr_t addr;
		const int offset = ptrSize * i;

		addr = Utils::MemoryObj->ReadAddress(address + offset);

		if (!IsValidAddress(addr)) break;
		gChunks.push_back(addr);
		gNamesChunks++;
	}

	// Calc AnsiName offset
	{
		uintptr_t noneNameAddress = Utils::MemoryObj->ReadAddress(gChunks[0]);

		Pattern none_sig = PatternScan::Parse("None", 0, "4E 6F 6E 65 00", 0xFF);
		auto result = PatternScan::FindPattern(Utils::MemoryObj, noneNameAddress, noneNameAddress + 0x100, { none_sig }, true);
		auto it = result.find("None");
		if (it != result.end() && !it->second.empty())
			nameOffset = it->second[0] - noneNameAddress;
	}

	// Dump GNames
	int i = 0;
	for (uintptr_t chunkAddress : gChunks)
	{
		for (int j = 0; j < chunkCount; ++j)
		{
			FNameEntity tmp;
			const int offset = ptrSize * j;
			uintptr_t fNameAddress = Utils::MemoryObj->ReadAddress(chunkAddress + offset);

			if (!IsValidAddress(fNameAddress))
			{
				// Push Empty, if i just skip will case a problems, so just add empty item
				tmp.Index = i + 1; // FNameEntity Index look like that 0 .. 2 .. 4 .. 6
				tmp.AnsiName = "";

				gNames.push_back(std::move(tmp));
				++i;
				continue;
			}

			// Read FName
			if (!tmp.ReadData(fNameAddress, nameOffset)) return false;

			gNames.push_back(std::move(tmp));
			++i;
		}
	}

	return true;
}

bool NamesStore::IsValidAddress(const uintptr_t address)
{
	if (INVALID_POINTER_VALUE(address) /*|| pointer <= dwStart || pointer > dwEnd*/)
		return false;

	// Check memory state, type and permission
	MEMORY_BASIC_INFORMATION info;

	//const uintptr_t pointerVal = _memory->ReadInt(pointer);
	if (VirtualQueryEx(Utils::MemoryObj->ProcessHandle, LPVOID(address), &info, sizeof info) == sizeof info)
	{
		// Bad Memory
		return info.Protect != PAGE_NOACCESS;
	}

	return false;
}

uintptr_t NamesStore::GetAddress()
{
	return gNamesAddress;
}

size_t NamesStore::GetNamesNum() const
{
	return chunkCount * gNamesChunks;
}

bool NamesStore::IsValid(const size_t id)
{
	return id >= 0 && id <= GetNamesNum() && !GetByIndex(id).empty();
}

std::string NamesStore::GetByIndex(const size_t id)
{
	// TODO: i think here is a problem, set BP at (return "") and check call stack. (why wrong id)
	if (id > GetNamesNum())
		return "";

	return gNames[id].AnsiName;
}

int NamesStore::GetByName(const std::string& name)
{
	auto retIt = std::find_if(gNames.begin(), gNames.end(), [&](FNameEntity& fName) -> bool
	{
		return fName.AnsiName == name;
	});

	if (retIt == gNames.end())
		return -1;

	return std::distance(gNames.begin(), retIt);
}
#pragma endregion

#pragma region NamesIterator
NamesIterator NamesStore::begin()
{
	return NamesIterator(*this, 0);
}

NamesIterator NamesStore::begin() const
{
	return NamesIterator(*this, 0);
}

NamesIterator NamesStore::end()
{
	return NamesIterator(*this);
}

NamesIterator NamesStore::end() const
{
	return NamesIterator(*this);
}

NamesIterator::NamesIterator(const NamesStore& _store)
	: store(_store),
	  index(_store.GetNamesNum())
{
}

NamesIterator::NamesIterator(const NamesStore& _store, size_t _index)
	: store(_store),
	  index(_index)
{
}

void NamesIterator::swap(NamesIterator& other) noexcept
{
	std::swap(index, other.index);
}

NamesIterator& NamesIterator::operator++()
{
	for (++index; index < store.GetNamesNum(); ++index)
	{
		if (NamesStore(store).IsValid(index))
		{
			break;
		}
	}
	return *this;
}

NamesIterator NamesIterator::operator++ (int)
{
	auto tmp(*this);
	++(*this);
	return tmp;
}

bool NamesIterator::operator==(const NamesIterator& rhs) const
{
	return index == rhs.index;
}

bool NamesIterator::operator!=(const NamesIterator& rhs) const
{
	return index != rhs.index;
}

FNameEntity NamesIterator::operator*() const
{
	return NamesStore::gNames[index];
}

FNameEntity NamesIterator::operator->() const
{
	return NamesStore::gNames[index];
}
#pragma endregion
```

`UnrealFinderTool/SdkGen/Engine/NamesStore.h`:

```h
#pragma once
#include <iterator>
#include "GenericTypes.h"

class Memory;
class NamesIterator;

class NamesStore
{
	friend NamesIterator;
	static std::vector<FNameEntity> gNames;
	static int chunkCount, gNamesChunks;
	static uintptr_t gNamesAddress;
	static bool ReadGNameArray(uintptr_t address);
	static bool IsValidAddress(uintptr_t address);

public:
	/// <summary>
	/// Initializes this object.
	/// </summary>
	/// <returns>true if it succeeds, false if it fails.</returns>
	static bool Initialize(uintptr_t gNamesAddress, bool forceReInit = true);

	/// <summary>Gets the address of the global names store.</summary>
	/// <returns>The address of the global names store.</returns>
	static uintptr_t GetAddress();

	NamesIterator begin();
	NamesIterator begin() const;
	NamesIterator end();
	NamesIterator end() const;

	/// <summary>
	/// Gets the number of available names.
	/// </summary>
	/// <returns>The number of names.</returns>
	size_t GetNamesNum() const;

	/// <summary>
	/// Test if the given id is valid.
	/// </summary>
	/// <param name="id">The identifier.</param>
	/// <returns>true if valid, false if not.</returns>
	bool IsValid(size_t id);

	/// <summary>
	/// Gets a name by id.
	/// </summary>
	/// <param name="id">The identifier.</param>
	/// <returns>The name.</returns>
	std::string GetByIndex(size_t id);

	/// <summary>
	/// Gets id by a name.
	/// </summary>
	/// <param name="name">Name of object.</param>
	/// <returns>Id of name.</returns>
	int GetByName(const std::string& name);
};

class NamesIterator : public std::iterator<std::forward_iterator_tag, FNameEntity>
{
	const NamesStore& store;
	size_t index;

public:
	NamesIterator(const NamesStore& store);

	explicit NamesIterator(const NamesStore& store, size_t index);

	void swap(NamesIterator& other) noexcept;

	NamesIterator& operator++();

	NamesIterator operator++ (int);

	bool operator==(const NamesIterator& rhs) const;

	bool operator!=(const NamesIterator& rhs) const;

	FNameEntity operator*() const;

	FNameEntity operator->() const;
};

```

`UnrealFinderTool/SdkGen/Engine/ObjectsStore.cpp`:

```cpp
#include "pch.h"
#include "Memory.h"
#include "ObjectsStore.h"
#include "EngineClasses.h"
#include "NamesStore.h"
#include <cassert>

GObjectInfo ObjectsStore::GInfo;
GObjects ObjectsStore::GObjObjects;

#pragma region ObjectsStore
bool ObjectsStore::Initialize(const uintptr_t gObjAddress, const bool forceReInit)
{
	ObjectsStore tmp;
	if (!forceReInit && GInfo.GObjAddress != NULL)
		return true;

	// Destroy old object's from heap
	for (size_t i = 0; i < GObjObjects.size(); i++)
	{
		delete GObjObjects[i].second->Object;
		GObjObjects[i].second->Object = nullptr;
	}

	// Clear
	GObjObjects.clear();
	GInfo.Count = 0;
	GInfo.GObjAddress = gObjAddress;

	return tmp.FetchData();
}

bool ObjectsStore::FetchData()
{
	if (!GetGObjectInfo()) return false;
	return ReadUObjectArray();
}

bool ObjectsStore::GetGObjectInfo()
{
	// Check if it's first `UObject` or first `Chunk` address
	// And Get Chunk and other GObjects info
	{
		int skipCount = 0;
		for (size_t uIndex = 0; uIndex <= 20 && skipCount <= 5; ++uIndex)
		{
			uintptr_t curAddress = GInfo.GObjAddress + uIndex * Utils::PointerSize();
			uintptr_t chunk = Utils::MemoryObj->ReadAddress(curAddress);

			// Skip null address
			if (chunk == 0)
			{
				++skipCount;
				continue;
			}

			if (!Utils::IsValidRemoteAddress(Utils::MemoryObj, chunk)) break;

			skipCount = 0;
			GInfo.GChunks.push_back(chunk);
			++GInfo.ChunksCount;
		}

		if (skipCount >= 5)
		{
			GInfo.IsChunksAddress = true;
		}
		else
		{
			GInfo.IsChunksAddress = false;
			GInfo.GChunks.clear();
			GInfo.ChunksCount = 1;
		}
	}

	// Get Work Method [Pointer Next Pointer or FUObjectItem(Flags, ClusterIndex, etc)]
	{
		uintptr_t firstUObj = GInfo.IsChunksAddress ? Utils::MemoryObj->ReadAddress(GInfo.GObjAddress) : GInfo.GObjAddress;
		uintptr_t obj1 = Utils::MemoryObj->ReadAddress(firstUObj);
		uintptr_t obj2 = Utils::MemoryObj->ReadAddress(firstUObj + Utils::PointerSize());

		if (!Utils::IsValidRemoteAddress(Utils::MemoryObj, obj1)) return false;

		// Not Valid mean it's not Pointer Next To Pointer, or GObject address is wrong.
		GInfo.IsPointerNextToPointer = Utils::IsValidRemoteAddress(Utils::MemoryObj, obj2);
	}

	return true;
}

bool ObjectsStore::ReadUObjectArray()
{
	uintptr_t lastObj = NULL;
	for (int i = 0; i < GInfo.ChunksCount; ++i)
	{
		size_t skipCount = 0;
		int offset = i * Utils::PointerSize();
		uintptr_t chunkAddress = GInfo.IsChunksAddress ? Utils::MemoryObj->ReadAddress(GInfo.GObjAddress + size_t(offset)) : GInfo.GObjAddress;

		for (size_t uIndex = 0; GInfo.IsChunksAddress ? uIndex <= numElementsPerChunk : (skipCount <= minZeroAddress); ++uIndex)
		{
			uintptr_t fUObject = NULL;
			uintptr_t dwUObject = NULL;

			// Get object address
			if (GInfo.IsPointerNextToPointer)
			{
				dwUObject = Utils::MemoryObj->ReadAddress(chunkAddress + uIndex * Utils::PointerSize());
			}
			else
			{
				FUObjectItem fUObjectItem;
				fUObject = chunkAddress + uIndex * fUObjectItem.StructSize();
				fUObjectItem.ReadData(fUObject);
				dwUObject = fUObjectItem.Object;
			}

			// Skip null pointer in GObjects array
			if (dwUObject == NULL)
			{
				++skipCount;
				continue;
			}
			skipCount = 0;

			// Object container
			auto curObject = std::make_unique<UEObject>();

			// Break if found bad object in GObjects array, GObjects shouldn't have bad object
			// check is not a static address !
			if (Utils::MemoryObj->IsStaticAddress(dwUObject) || !ReadUObject(dwUObject, *curObject))
				break;

			lastObj = fUObject;
			GObjObjects.push_back(std::make_pair(dwUObject, std::move(curObject)));
			++GInfo.Count;
		}
	}

	return true;
}

bool ObjectsStore::ReadUObject(const uintptr_t uObjectAddress, UEObject& retUObj)
{
	auto tmp = new UObject();
	if (!Utils::IsValidRemoteAddress(Utils::MemoryObj, uObjectAddress) || !tmp->ReadData(uObjectAddress))
		return false;

	retUObj.Object = tmp;
	return true;
}

uintptr_t ObjectsStore::GetAddress()
{
	return GInfo.GObjAddress;
}

size_t ObjectsStore::GetObjectsNum() const 
{
	return GInfo.Count;
}

UEObject* ObjectsStore::GetByIndex(const size_t index) const
{
	return GObjObjects[index].second.get();
}

UEObject* ObjectsStore::GetByAddress(const uintptr_t objAddress)
{
	return GObjObjects.Find(objAddress)->get();
}

UEObject* ObjectsStore::GetByAddress(const uintptr_t objAddress, bool& success)
{
	auto uniquePtr = GObjObjects.Find(objAddress, success);
	return success ? uniquePtr->get() : &UEObjectEmpty;
}

UEClass ObjectsStore::FindClass(const std::string& name) const
{
	auto it = std::find_if(this->begin(), this->end(), [&](const UEObject& obj) -> bool { return obj.GetFullName() == name; });

	if (it != this->end())
		return (*it).Cast<UEClass>();

	return UEClass();
}
#pragma endregion

#pragma region ObjectsIterator
ObjectsIterator ObjectsStore::begin()
{
	return ObjectsIterator(*this, 0);
}

ObjectsIterator ObjectsStore::begin() const
{
	return ObjectsIterator(*this, 0);
}

ObjectsIterator ObjectsStore::end()
{
	return ObjectsIterator(*this);
}

ObjectsIterator ObjectsStore::end() const
{
	return ObjectsIterator(*this);
}

ObjectsIterator::ObjectsIterator(const ObjectsStore& store)
	: store(store),
	  index(store.GetObjectsNum()),
	  current(nullptr)
{
}

ObjectsIterator::ObjectsIterator(const ObjectsStore& store, const size_t index)
	: store(store),
	index(index)
{
	current = store.GetByIndex(index);
}

ObjectsIterator::ObjectsIterator(const ObjectsIterator& other)
	: store(other.store),
	  index(other.index),
	  current(other.current)
{
}

ObjectsIterator::ObjectsIterator(ObjectsIterator&& other) noexcept
	: store(other.store),
	  index(other.index),
	  current(other.current)
{
}

ObjectsIterator& ObjectsIterator::operator=(const ObjectsIterator& rhs)
{
	index = rhs.index;
	current = rhs.current;
	return *this;
}

void ObjectsIterator::swap(ObjectsIterator& other) noexcept
{
	std::swap(index, other.index);
	std::swap(current, other.current);
}

ObjectsIterator& ObjectsIterator::operator++()
{
	for (++index; index < ObjectsStore(store).GetObjectsNum(); ++index)
	{
		current = store.GetByIndex(index);
		if (current->IsValid())
		{
			break;
		}
	}
	return *this;
}

ObjectsIterator ObjectsIterator::operator++(int)
{
	auto tmp(*this);
	++*this;
	return tmp;
}

bool ObjectsIterator::operator==(const ObjectsIterator& rhs) const
{
	return index == rhs.index;
}

bool ObjectsIterator::operator!=(const ObjectsIterator& rhs) const
{
	return index != rhs.index;
}

UEObject ObjectsIterator::operator*() const
{
	assert(current->IsValid() && "ObjectsIterator::current is not valid!");
	return *current;
}

UEObject ObjectsIterator::operator->() const
{
	return operator*();
}
#pragma endregion
```

`UnrealFinderTool/SdkGen/Engine/ObjectsStore.h`:

```h
#pragma once
#include "GenericTypes.h"
#include "ParallelWorker.h"
#include <unordered_map>

class ObjectsIterator;
class Memory;

using GObjects = UnsortedMap<uintptr_t, std::unique_ptr<UEObject>>;

struct GObjectInfo
{
	uintptr_t GObjAddress;
	std::vector<uintptr_t> GChunks;
	int Count, ChunksCount;
	bool IsPointerNextToPointer;
	bool IsChunksAddress;
};

class ObjectsStore
{
	size_t numElementsPerChunk = 0x11000;
	size_t minZeroAddress = 150;

	bool FetchData();
	bool GetGObjectInfo();
	bool ReadUObjectArray();
	bool ReadUObject(uintptr_t uObjectAddress, UEObject& retUObj);

public:
	static GObjectInfo GInfo;
	static GObjects GObjObjects;

	/// <summary>
	/// Initializes this object.
	/// </summary>
	/// <returns>
	/// true if it succeeds, false if it fails.
	/// </returns>
	static bool Initialize(uintptr_t gObjAddress, bool forceReInit = true);
	/// <summary>Gets the address of the global objects store.</summary>
	/// <returns>The address of the global objects store.</returns>
	static uintptr_t GetAddress();

	/// <summary>
	/// Gets the number of available objects.
	/// </summary>
	/// <returns>The number of objects.</returns>
	size_t GetObjectsNum() const;

	/// <summary>
	/// Gets the object by id.
	/// </summary>
	/// <param name="index">The identifier.</param>
	/// <returns>The object.</returns>
	UEObject* GetByIndex(size_t index) const;

	/// <summary>
	/// Gets the object by id.
	/// </summary>
	/// <param name="objAddress">The address of object.</param>
	/// <returns>The object.</returns>
	static UEObject* GetByAddress(uintptr_t objAddress);
	static UEObject* GetByAddress(uintptr_t objAddress, bool& success);

	/// <summary>
	/// Searches for the first class with the given name.
	/// </summary>
	/// <param name="name">The name of the class.</param>
	/// <returns>The found class which is not valid if no class could be found.</returns>
	UEClass FindClass(const std::string& name) const;

	/// <summary>Count objects which have the same name and type.</summary>
	/// <typeparam name="T">Type of the object.</typeparam>
	/// <param name="name">The name to search for.</param>
	/// <returns>The number of objects which share a name.</returns>
	template<class T>
	size_t CountObjects(const std::string& name) const;

	ObjectsIterator begin();
	ObjectsIterator begin() const;
	ObjectsIterator end();
	ObjectsIterator end() const;
};

template <class T>
size_t ObjectsStore::CountObjects(const std::string& name) const
{
	static std::unordered_map<std::string, size_t> cache;

	auto it = cache.find(name);
	if (it != std::end(cache))
		return it->second;

	size_t index = 0;
	size_t count = 0;
	ParallelSingleShot worker(Utils::Settings.SdkGen.Threads, [&](ParallelOptions& options)
	{
		while (index > GObjObjects.size())
		{
			UEObject* curObj;

			// Get current object
			{
				std::lock_guard lock(options.Locker);
				curObj = GObjObjects[index].second.get();
				++index;
			}

			// Calc count of object
			if (curObj->IsA<T>() && curObj->GetName() == name)
			{
				std::lock_guard lock(options.Locker);
				++count;
			}
		}
	});
	worker.Start();
	worker.WaitAll();

	std::lock_guard mainLocker(Utils::MainMutex);
	cache[name] = count;
	return count;
}

/// <summary>An iterator for objects.</summary>
class ObjectsIterator : public std::iterator<std::forward_iterator_tag, UEObject>
{
	const ObjectsStore& store;
	size_t index;
	UEObject* current;

public:
	/// <summary>Constructor.</summary>
	/// <param name="store">The store to iterate.</param>
	ObjectsIterator(const ObjectsStore& store);

	/// <summary>Constructor.</summary>
	/// <param name="store">The store to iterate.</param>
	/// <param name="index">Zero-based start index.</param>
	explicit ObjectsIterator(const ObjectsStore& store, size_t index);

	ObjectsIterator(const ObjectsIterator& other);
	ObjectsIterator(ObjectsIterator&& other) noexcept;

	ObjectsIterator& operator=(const ObjectsIterator& rhs);

	void swap(ObjectsIterator& other) noexcept;

	ObjectsIterator& operator++();

	ObjectsIterator operator++ (int);

	bool operator==(const ObjectsIterator& rhs) const;

	bool operator!=(const ObjectsIterator& rhs) const;

	UEObject operator*() const;

	UEObject operator->() const;
};

```

`UnrealFinderTool/SdkGen/Engine/Package.cpp`:

```cpp
#include "pch.h"

#include <fstream>
#include <unordered_set>
#include <cinttypes>

#include "tinyformat.h"
#include "cpplinq.hpp"
#include "IGenerator.h"
#include "Logger.h"
#include "NameValidator.h"
#include "PatternScan.h"
#include "ObjectsStore.h"
#include "PropertyFlags.h"
#include "FunctionFlags.h"
#include "PrintHelper.h"
#include "ParallelWorker.h"
#include "Package.h"

std::unordered_map<UEObject, const Package*> Package::PackageMap;

/// <summary>
/// Compare two properties.
/// </summary>
/// <param name="lhs">The first property.</param>
/// <param name="rhs">The second property.</param>
/// <returns>true if the first property compares less, else false.</returns>
bool ComparePropertyLess(const UEProperty& lhs, const UEProperty& rhs)
{
	if (lhs.GetOffset() == rhs.GetOffset()
		&& lhs.IsA<UEBoolProperty>()
		&& rhs.IsA<UEBoolProperty>())
	{
		return lhs.Cast<UEBoolProperty>() < rhs.Cast<UEBoolProperty>();
	}

	return lhs.GetOffset() < rhs.GetOffset();
}

Package::Package(UEObject* packageObj)
	: packageObj(packageObj)
{
}

void Package::Process(std::unordered_map<uintptr_t, bool>& processedObjects, std::mutex& packageLocker)
{
	using ObjectItem = std::pair<uintptr_t, std::unique_ptr<UEObject>>;
	static int process_sleep_counter = 0;
	std::vector<UEObject*> objsInPack;

	// Get all objects in this package
	{
		// Wait to get package object's, just to use 6 threads instead of 12 thread
		std::lock_guard lock(packageLocker);

		ParallelQueue<GObjects, ObjectItem>
		worker(ObjectsStore::GObjObjects, 0, Utils::Settings.SdkGen.Threads, [&](ObjectItem& curObj, ParallelOptions& options)
		{
			UEObject* obj = curObj.second.get();
			UEObject* package = obj->GetPackageObject();

			if (packageObj == package)
			{
				std::lock_guard push_lock(options.Locker);
				objsInPack.push_back(obj);
			}
		});
		worker.Start();
		worker.WaitAll();
	}

	for (auto& obj : objsInPack)
	{
		if (obj->IsA<UEEnum>())
		{
			GenerateEnum(obj->Cast<UEEnum>());
		}
		/* in UE4 there is no UEConst
		else if (obj.IsA<UEConst>())
		{
			GenerateConst(obj.Cast<UEConst>());
		}
		*/
		else if (obj->IsA<UEClass>())
		{
			GeneratePrerequisites(*obj, processedObjects);
		}
		else if (obj->IsA<UEScriptStruct>())
		{
			GeneratePrerequisites(*obj, processedObjects);
		}

		Utils::SleepEvery(1, process_sleep_counter, Utils::Settings.Parallel.SleepEvery);
	}
}

bool Package::Save(const fs::path& path) const
{
	extern IGenerator* generator;

	using namespace cpplinq;

	//check if package is empty (no enums, structs or classes without members)
	if (generator->ShouldGenerateEmptyFiles()
		|| (from(Enums) >> where([](auto && e) { return !e.Values.empty(); }) >> any()
			|| from(ScriptStructs) >> where([](auto && s) { return !s.Members.empty() || !s.PredefinedMethods.empty(); }) >> any()
			|| from(Classes) >> where([](auto && c) {return !c.Members.empty() || !c.PredefinedMethods.empty() || !c.Methods.empty(); }) >> any()
			)
		)
	{
		SaveStructs(path);
		SaveClasses(path);
		SaveFunctions(path);

		return true;
	}

	if (Utils::Settings.SdkGen.LoggerShowSkip)
	{
		Logger::Log("Skip Empty:    %s", packageObj->GetFullName());
	}
	
	return false;
}

bool Package::AddDependency(UEObject* package) const
{
	if (package != packageObj)
	{
		dependencies.insert(*package);

		return true;
	}
	return false;
}

void Package::GeneratePrerequisites(const UEObject& obj, std::unordered_map<uintptr_t, bool>& processedObjects)
{
	if (!obj.IsValid())
		return;

	const auto isClass = obj.IsA<UEClass>();
	const auto isScriptStruct = obj.IsA<UEScriptStruct>();
	if (!isClass && !isScriptStruct)
		return;

	const auto name = obj.GetName();
	if (name.find("Default__") != std::string::npos
		|| name.find("<uninitialized>") != std::string::npos
		|| name.find("PLACEHOLDER-CLASS") != std::string::npos)
	{
		return;
	}

	{
		std::lock_guard mainLocker(Utils::MainMutex);
		processedObjects[obj.GetAddress()] |= false;
	}

	auto classPackage = obj.GetPackageObject();
	if (!classPackage->IsValid())
		return;

	if (AddDependency(classPackage))
		return;

	if (!processedObjects[obj.GetAddress()])
	{
		processedObjects[obj.GetAddress()] = true;

		auto outer = obj.GetOuter();
		if (outer->IsValid() && *outer != obj)
		{
			GeneratePrerequisites(*outer, processedObjects);
		}

		auto structObj = obj.Cast<UEStruct>();
		auto super = structObj.GetSuper();
		if (super.IsValid() && super != obj)
		{
			GeneratePrerequisites(super, processedObjects);
		}

		GenerateMemberPrerequisites(structObj.GetChildren().Cast<UEProperty>(), processedObjects);

		if (isClass)
		{
			GenerateClass(obj.Cast<UEClass>());
		}
		else
		{
			GenerateScriptStruct(obj.Cast<UEScriptStruct>());
		}
	}
}

void Package::GenerateMemberPrerequisites(const UEProperty& first, std::unordered_map<uintptr_t, bool>& processedObjects)
{
	using namespace cpplinq;

	for (UEProperty prop = first; prop.IsValid(); prop = prop.GetNext().Cast<UEProperty>())
	{
		const auto info = prop.GetInfo();
		if (info.Type == UEProperty::PropertyType::Primitive)
		{
			if (prop.IsA<UEByteProperty>())
			{
				auto byteProperty = prop.Cast<UEByteProperty>();
				if (byteProperty.IsEnum())
				{
					AddDependency(byteProperty.GetEnum().GetPackageObject());
				}
			}
			else if (prop.IsA<UEEnumProperty>())
			{
				auto enumProperty = prop.Cast<UEEnumProperty>();
				AddDependency(enumProperty.GetEnum().GetPackageObject());
			}
		}
		else if (info.Type == UEProperty::PropertyType::CustomStruct)
		{
			GeneratePrerequisites(prop.Cast<UEStructProperty>().GetStruct(), processedObjects);
		}
		else if (info.Type == UEProperty::PropertyType::Container)
		{
			std::vector<UEProperty> innerProperties;

			if (prop.IsA<UEArrayProperty>())
			{
				innerProperties.push_back(prop.Cast<UEArrayProperty>().GetInner());
			}
			else if (prop.IsA<UEMapProperty>())
			{
				auto mapProp = prop.Cast<UEMapProperty>();
				innerProperties.push_back(mapProp.GetKeyProperty());
				innerProperties.push_back(mapProp.GetValueProperty());
			}

			for (const auto& innerProp : from(innerProperties)
				>> where([](UEProperty && p) { return p.GetInfo().Type == UEProperty::PropertyType::CustomStruct; })
				>> experimental::container())
			{
				GeneratePrerequisites(innerProp.Cast<UEStructProperty>().GetStruct(), processedObjects);
			}
		}
		else if (prop.IsA<UEFunction>())
		{
			auto function = prop.Cast<UEFunction>();

			GenerateMemberPrerequisites(function.GetChildren().Cast<UEProperty>(), processedObjects);
		}
	}
}

void Package::GenerateScriptStruct(const UEScriptStruct& scriptStructObj)
{
	extern IGenerator* generator;

	ScriptStruct ss;
	ss.Name = scriptStructObj.GetName();
	ss.FullName = scriptStructObj.GetFullName();

	{
		static std::string script_struct_format = std::string("Struct:  %-") + std::to_string(Utils::Settings.SdkGen.LoggerSpaceCount) + "s - instance: 0x%" PRIXPTR;
		std::string logStructName = Utils::Settings.SdkGen.LoggerShowStructSaveFileName ? this->GetName() + "." + ss.Name : ss.Name;
		Logger::Log(script_struct_format.c_str(), logStructName, scriptStructObj.GetAddress());
	}

	ss.NameCpp = MakeValidName(scriptStructObj.GetNameCpp());
	ss.NameCppFull = "struct ";

	//some classes need special alignment
	const auto alignment = generator->GetClassAlignas(ss.FullName);
	if (alignment != 0)
	{
		ss.NameCppFull += tfm::format("alignas(%d) ", alignment);
	}

	ss.NameCppFull += MakeUniqueCppName(scriptStructObj);

	ss.Size = scriptStructObj.GetPropertySize();
	ss.InheritedSize = 0;

	size_t offset = 0;

	auto super = scriptStructObj.GetSuper();
	if (super.IsValid() && super != scriptStructObj)
	{
		ss.InheritedSize = offset = super.GetPropertySize();

		ss.NameCppFull += " : public " + MakeUniqueCppName(super.Cast<UEScriptStruct>());
	}

	std::vector<UEProperty> properties;
	for (auto prop = scriptStructObj.GetChildren().Cast<UEProperty>(); prop.IsValid(); prop = prop.GetNext().Cast<UEProperty>())
	{
		if (prop.GetElementSize() > 0
			&& !prop.IsA<UEScriptStruct>()
			&& !prop.IsA<UEFunction>()
			&& !prop.IsA<UEEnum>()
			&& !prop.IsA<UEConst>()
			)
		{
			properties.push_back(prop);
		}
	}
	std::sort(std::begin(properties), std::end(properties), ComparePropertyLess);

	GenerateMembers(scriptStructObj, offset, properties, ss.Members);

	if (generator->GetSdkType() == SdkType::External)
	{
		ss.PredefinedMethods.push_back(IGenerator::PredefinedMethod::Inline(tfm::format(R"(	static %s ReadAsMe(uintptr_t address)
	{
		%s ret;
		%s(address, ret);
		return ret;
	})", scriptStructObj.GetNameCpp(), scriptStructObj.GetNameCpp(), Utils::Settings.SdkGen.MemoryRead)));

		ss.PredefinedMethods.push_back(IGenerator::PredefinedMethod::Inline(tfm::format(R"(	static %s WriteAsMe(const uintptr_t address, %s& toWrite)
	{
		return %s(address, toWrite);
	})", Utils::Settings.SdkGen.MemoryWriteType, scriptStructObj.GetNameCpp(), Utils::Settings.SdkGen.MemoryWrite)));
	}

	generator->GetPredefinedClassMethods(scriptStructObj.GetFullName(), ss.PredefinedMethods);

	ScriptStructs.emplace_back(std::move(ss));
}

void Package::GenerateEnum(const UEEnum& enumObj)
{
	Enum e;
	e.Name = MakeUniqueCppName(enumObj);

	if (e.Name.find("Default__") != std::string::npos
		|| e.Name.find("PLACEHOLDER-CLASS") != std::string::npos)
	{
		return;
	}

	e.FullName = enumObj.GetFullName();

	std::unordered_map<std::string, int> conflicts;
	for (auto&& s : enumObj.GetNames())
	{
		const auto clean = MakeValidName(std::move(s));

		const auto it = conflicts.find(clean);
		if (it == std::end(conflicts))
		{
			e.Values.push_back(clean);
			conflicts[clean] = 1;
		}
		else
		{
			e.Values.push_back(clean + tfm::format("%02d", it->second));
			conflicts[clean]++;
		}
	}

	Enums.emplace_back(std::move(e));
}

void Package::GenerateConst(const UEConst& constObj)
{
	//auto name = MakeValidName(constObj.GetName());
	auto name = MakeUniqueCppName(constObj);

	if (name.find("Default__") != std::string::npos
		|| name.find("PLACEHOLDER-CLASS") != std::string::npos)
	{
		return;
	}

	constants[name] = constObj.GetValue();
}

void Package::GenerateClass(const UEClass& classObj)
{
	extern IGenerator* generator;

	Class c;
	c.Name = classObj.GetName();
	c.FullName = classObj.GetFullName();

	{
		static std::string class_format = std::string("Class:   %-") + std::to_string(Utils::Settings.SdkGen.LoggerSpaceCount) + "s - instance: 0x%" PRIXPTR;
		std::string logClassName = Utils::Settings.SdkGen.LoggerShowClassSaveFileName ? this->GetName() + "." + c.Name : c.Name;
		Logger::Log(class_format.c_str(), logClassName, classObj.GetAddress());
	}

	c.NameCpp = MakeValidName(classObj.GetNameCpp());
	c.NameCppFull = "class " + c.NameCpp;

	c.Size = classObj.GetPropertySize();
	c.InheritedSize = 0;

	size_t offset = 0;

	auto super = classObj.GetSuper();
	if (super.IsValid() && super != classObj)
	{
		c.InheritedSize = offset = super.GetPropertySize();
		c.NameCppFull += " : public " + MakeValidName(super.GetNameCpp());
	}

	std::vector<IGenerator::PredefinedMember> predefinedStaticMembers;
	if (generator->GetPredefinedClassStaticMembers(c.FullName, predefinedStaticMembers))
	{
		for (auto&& prop : predefinedStaticMembers)
		{
			Member p;
			p.Offset = 0;
			p.Size = 0;
			p.Name = prop.Name;
			p.Type = "static " + prop.Type;
			c.Members.push_back(std::move(p));
		}
	}

	std::vector<IGenerator::PredefinedMember> predefinedMembers;
	if (generator->GetPredefinedClassMembers(c.FullName, predefinedMembers))
	{
		for (auto&& prop : predefinedMembers)
		{
			Member p;
			p.Offset = 0;
			p.Size = 0;
			p.Name = prop.Name;
			p.Type = prop.Type;
			p.Comment = "NOT AUTO-GENERATED PROPERTY";
			c.Members.push_back(std::move(p));
		}
	}
	else
	{
		std::vector<UEProperty> properties;
		for (auto prop = classObj.GetChildren().Cast<UEProperty>(); prop.IsValid(); prop = prop.GetNext().Cast<UEProperty>())
		{
			if (prop.GetElementSize() > 0
				&& !prop.IsA<UEScriptStruct>()
				&& !prop.IsA<UEFunction>()
				&& !prop.IsA<UEEnum>()
				&& !prop.IsA<UEConst>()
				&& (!super.IsValid() || (super != classObj && prop.GetOffset() >= super.GetPropertySize()))
				)
			{
				properties.push_back(prop);
			}
		}
		std::sort(std::begin(properties), std::end(properties), ComparePropertyLess);

		GenerateMembers(classObj, offset, properties, c.Members);
	}

	generator->GetPredefinedClassMethods(c.FullName, c.PredefinedMethods);
	
	if (generator->GetSdkType() == SdkType::External)
	{
		c.PredefinedMethods.push_back(IGenerator::PredefinedMethod::Inline(tfm::format(R"(	static %s ReadAsMe(const uintptr_t address)
	{
		%s ret;
		%s(address, ret);
		return ret;
	})", classObj.GetNameCpp(), classObj.GetNameCpp(), Utils::Settings.SdkGen.MemoryRead)));
		c.PredefinedMethods.push_back(IGenerator::PredefinedMethod::Inline(tfm::format(R"(	static %s WriteAsMe(const uintptr_t address, %s& toWrite)
	{
		return %s(address, toWrite);
	})", Utils::Settings.SdkGen.MemoryWriteType, classObj.GetNameCpp(), Utils::Settings.SdkGen.MemoryWrite)));
	}
	else
	{
		if (generator->ShouldUseStrings())
		{
			c.PredefinedMethods.push_back(IGenerator::PredefinedMethod::Inline(tfm::format(R"(	static UClass* StaticClass()
	{
		static auto ptr = UObject::FindClass(%s);
		return ptr;
	})", generator->ShouldXorStrings() ? tfm::format("_xor_(\"%s\")", c.FullName) : tfm::format("\"%s\"", c.FullName))));
		}
		else
		{
			c.PredefinedMethods.push_back(IGenerator::PredefinedMethod::Inline(tfm::format(R"(	static UClass* StaticClass()
	{
		static auto ptr = UObject::GetObjectCasted<UClass>(%d);
		return ptr;
	})", classObj.GetIndex())));
		}

		GenerateMethods(classObj, c.Methods);

		//search virtual functions
		IGenerator::VirtualFunctionPatterns patterns;
		if (generator->GetVirtualFunctionPatterns(c.FullName, patterns))
		{
			int ptrSize = Utils::PointerSize();
			uintptr_t vTableAddress = classObj.Object->VfTable;
			std::vector<uintptr_t> vTable;

			size_t methodCount = 0;
			while (methodCount < 150)
			{
				MEMORY_BASIC_INFORMATION info;
				uintptr_t vAddress;

				// Dereference Pointer
				vAddress = Utils::MemoryObj->ReadAddress(vTableAddress + (methodCount * ptrSize));

				// Check valid address
				auto res = VirtualQueryEx(Utils::MemoryObj->ProcessHandle, reinterpret_cast<LPVOID>(vAddress), &info, sizeof info);
				if (res == NULL || info.Protect & PAGE_NOACCESS)
					break;

				vTable.push_back(vAddress);
				++methodCount;
			}

			for (auto&& pattern : patterns)
			{
				for (auto i = 0u; i < methodCount; ++i)
				{
					if (vTable[i] != NULL)
					{
						auto scanResult = PatternScan::FindPattern(Utils::MemoryObj, vTable[i], vTable[i] + 0x300, { std::get<0>(pattern) }, true);
						auto toFind = scanResult.find(std::get<0>(pattern).Name);
						if (toFind != scanResult.end() && !toFind->second.empty())
						{
							c.PredefinedMethods.push_back(IGenerator::PredefinedMethod::Inline(tfm::format(std::get<1>(pattern), i)));
							break;
						}
					}
				}
			}
		}
	}

	Classes.emplace_back(std::move(c));
}

Package::Member Package::CreatePadding(const size_t id, const size_t offset, const size_t size, std::string reason)
{
	Member ss;
	ss.Name = tfm::format("UnknownData%02d[0x%X]", id, size);
	ss.Type = "unsigned char";
	ss.Flags = 0;
	ss.Offset = offset;
	ss.Size = size;
	ss.Comment = std::move(reason);
	return ss;
}

Package::Member Package::CreateBitfieldPadding(const size_t id, const size_t offset, std::string type, const size_t bits)
{
	Member ss;
	ss.Name = tfm::format("UnknownData%02d : %d", id, bits);
	ss.Type = std::move(type);
	ss.Flags = 0;
	ss.Offset = offset;
	ss.Size = 1;
	return ss;
}

void Package::GenerateMembers(const UEStruct& structObj, size_t offset, const std::vector<UEProperty>& properties, std::vector<Member>& members) const
{
	extern IGenerator* generator;

	std::unordered_map<std::string, size_t> uniqueMemberNames;
	size_t unknownDataCounter = 0;
	UEBoolProperty previousBitfieldProperty;

	for (auto&& prop : properties)
	{
		if (offset < prop.GetOffset())
		{
			previousBitfieldProperty = UEBoolProperty();

			const auto size = prop.GetOffset() - offset;
			members.emplace_back(CreatePadding(unknownDataCounter++, offset, size, "MISSED OFFSET"));
		}

		const auto info = prop.GetInfo();
		if (info.Type != UEProperty::PropertyType::Unknown)
		{
			Member sp;
			sp.Offset = prop.GetOffset();
			sp.Size = info.Size;

			sp.Type = info.CppType;
			sp.Name = MakeValidName(prop.GetName());

			const auto it = uniqueMemberNames.find(sp.Name);
			if (it == std::end(uniqueMemberNames))
			{
				uniqueMemberNames[sp.Name] = 1;
			}
			else
			{
				++uniqueMemberNames[sp.Name];
				sp.Name += tfm::format("%02d", it->second);
			}

			if (prop.GetArrayDim() > 1)
			{
				sp.Name += tfm::format("[0x%X]", prop.GetArrayDim());
			}

			if (prop.IsA<UEBoolProperty>() && prop.Cast<UEBoolProperty>().IsBitfield())
			{
				auto boolProp = prop.Cast<UEBoolProperty>();

				const auto missingBits = boolProp.GetMissingBitsCount(previousBitfieldProperty);
				if (missingBits[1] != -1)
				{
					if (missingBits[0] > 0)
					{
						members.emplace_back(CreateBitfieldPadding(unknownDataCounter++, previousBitfieldProperty.GetOffset(), info.CppType, missingBits[0]));
					}
					if (missingBits[1] > 0)
					{
						members.emplace_back(CreateBitfieldPadding(unknownDataCounter++, sp.Offset, info.CppType, missingBits[1]));
					}
				}
				else if (missingBits[0] > 0)
				{
					members.emplace_back(CreateBitfieldPadding(unknownDataCounter++, sp.Offset, info.CppType, missingBits[0]));
				}

				previousBitfieldProperty = boolProp;

				sp.Name += " : 1";
			}
			else
			{
				previousBitfieldProperty = UEBoolProperty();
			}

			sp.Name = generator->GetSafeKeywordsName(sp.Name);
			sp.Flags = static_cast<size_t>(prop.GetPropertyFlags());
			sp.FlagsString = StringifyFlags(prop.GetPropertyFlags());

			members.emplace_back(std::move(sp));

			const auto sizeMismatch = static_cast<int>(prop.GetElementSize() * prop.GetArrayDim()) - static_cast<int>(info.Size * prop.GetArrayDim());
			if (sizeMismatch > 0)
			{
				members.emplace_back(CreatePadding(unknownDataCounter++, offset, sizeMismatch, "FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY"));
			}
		}
		else
		{
			const auto size = prop.GetElementSize() * prop.GetArrayDim();
			members.emplace_back(CreatePadding(unknownDataCounter++, offset, size, "UNKNOWN PROPERTY: " + prop.GetFullName()));
		}

		offset = prop.GetOffset() + prop.GetElementSize() * prop.GetArrayDim();
	}

	if (offset < structObj.GetPropertySize())
	{
		const auto size = structObj.GetPropertySize() - offset;
		members.emplace_back(CreatePadding(unknownDataCounter++, offset, size, "MISSED OFFSET"));
	}
}

void Package::GenerateMethods(const UEClass& classObj, std::vector<Method>& methods) const
{
	extern IGenerator* generator;

	//some classes (AnimBlueprintGenerated...) have multiple members with the same name, so filter them out
	std::unordered_set<std::string> uniqueMethods;

	for (auto prop = classObj.GetChildren().Cast<UEField>(); prop.IsValid(); prop = prop.GetNext())
	{
		if (!prop.IsA<UEFunction>())
			continue;

		auto function = prop.Cast<UEFunction>();

		Method m;
		m.Index = function.GetIndex();
		m.FullName = function.GetFullName();
		m.Name = MakeValidName(function.GetName());

		m.Name = generator->GetSafeKeywordsName(m.Name);
		if (uniqueMethods.find(m.FullName) != std::end(uniqueMethods))
			continue;

		uniqueMethods.insert(m.FullName);

		m.IsNative = function.GetFunctionFlags() & UEFunctionFlags::Native;
		m.IsStatic = function.GetFunctionFlags() & UEFunctionFlags::Static;
		m.FlagsString = StringifyFlags(function.GetFunctionFlags());

		std::vector<std::pair<UEProperty, Method::Parameter>> parameters;

		std::unordered_map<std::string, size_t> unique;
		for (auto param = function.GetChildren().Cast<UEProperty>(); param.IsValid(); param = param.GetNext().Cast<UEProperty>())
		{
			if (param.GetElementSize() == 0)
				continue;

			const auto info = param.GetInfo();
			if (info.Type != UEProperty::PropertyType::Unknown)
			{
				using Type = Method::Parameter::Type;

				Method::Parameter p;

				if (!Method::Parameter::MakeType(param.GetPropertyFlags(), p.ParamType))
				{
					//child isn't a parameter
					continue;
				}

				p.PassByReference = false;
				p.Name = MakeValidName(param.GetName());

				const auto it = unique.find(p.Name);
				if (it == std::end(unique))
				{
					unique[p.Name] = 1;
				}
				else
				{
					++unique[p.Name];

					p.Name += tfm::format("%02d", it->second);
				}

				p.FlagsString = StringifyFlags(param.GetPropertyFlags());

				p.CppType = info.CppType;
				if (param.IsA<UEBoolProperty>())
				{
					p.CppType = generator->GetOverrideType("bool");
				}

				if (p.ParamType == Type::Default)
				{
					if (param.GetArrayDim() > 1)
					{
						p.CppType = p.CppType + "*";
					}
					else if (info.CanBeReference)
					{
						p.PassByReference = true;
					}
				}

				p.Name = generator->GetSafeKeywordsName(p.Name);

				parameters.emplace_back(std::make_pair(param, std::move(p)));
			}
		}

		std::sort(std::begin(parameters), std::end(parameters), [](auto && lhs, auto && rhs) { return ComparePropertyLess(lhs.first, rhs.first); });

		for (auto& param : parameters)
		{
			m.Parameters.emplace_back(std::move(param.second));
		}

		methods.emplace_back(std::move(m));
	}
}

void Package::SaveStructs(const fs::path & path) const
{
	extern IGenerator* generator;

	std::ofstream os(path / GenerateFileName(FileContentType::Structs, *this));

	PrintFileHeader(os, true);

	if (!constants.empty())
	{
		PrintSectionHeader(os, "Constants");
		for (auto&& c : constants) { PrintConstant(os, c); }

		os << "\n";
	}

	if (!Enums.empty())
	{
		PrintSectionHeader(os, "Enums");
		for (auto&& e : Enums) { PrintEnum(os, e); os << "\n"; }

		os << "\n";
	}

	if (!ScriptStructs.empty())
	{
		PrintSectionHeader(os, "Script Structs");
		for (auto&& s : ScriptStructs) { PrintStruct(os, s); os << "\n"; }
	}

	PrintFileFooter(os);
}

void Package::SaveClasses(const fs::path& path) const
{
	extern IGenerator* generator;

	std::ofstream os(path / GenerateFileName(FileContentType::Classes, *this));

	PrintFileHeader(os, true);

	if (!Classes.empty())
	{
		PrintSectionHeader(os, "Classes");
		for (auto&& c : Classes) { PrintClass(os, c); os << "\n"; }
	}

	PrintFileFooter(os);
}

void Package::SaveFunctions(const fs::path & path) const
{
	extern IGenerator* generator;
	using namespace cpplinq;

	// Skip Functions if it's external
	if (generator->GetSdkType() == SdkType::External)
		return;

	if (generator->ShouldGenerateFunctionParametersFile())
		SaveFunctionParameters(path);

	std::ofstream os(path / GenerateFileName(FileContentType::Functions, *this));

	PrintFileHeader(os, { "\"../SDK.h\"" }, false);

	PrintSectionHeader(os, "Functions");

	for (auto&& s : ScriptStructs)
	{
		for (auto&& m : s.PredefinedMethods)
		{
			if (m.MethodType != IGenerator::PredefinedMethod::Type::Inline)
			{
				os << m.Body << "\n\n";
			}
		}
	}

	for (auto&& c : Classes)
	{
		for (auto&& m : c.PredefinedMethods)
		{
			if (m.MethodType != IGenerator::PredefinedMethod::Type::Inline)
			{
				os << m.Body << "\n\n";
			}
		}

		for (auto&& m : c.Methods)
		{
			//Method Info
			os << "// " << m.FullName << "\n"
				<< "// (" << m.FlagsString << ")\n";
			if (!m.Parameters.empty())
			{
				os << "// Parameters:\n";
				for (auto&& param : m.Parameters)
				{
					tfm::format(os, "// %-30s %-30s (%s)\n", param.CppType, param.Name, param.FlagsString);
				}
			}

			os << "\n";
			os << BuildMethodSignature(m, c, false) << "\n";
			os << BuildMethodBody(c, m) << "\n\n";
		}
	}

	PrintFileFooter(os);
}

void Package::SaveFunctionParameters(const fs::path & path) const
{
	using namespace cpplinq;

	std::ofstream os(path / GenerateFileName(FileContentType::FunctionParameters, *this));

	PrintFileHeader(os, { "\"../SDK.h\"" }, true);

	PrintSectionHeader(os, "Parameters");

	for (auto&& c : Classes)
	{
		for (auto&& m : c.Methods)
		{
			os << "// " << m.FullName << "\n";
			tfm::format(os, "struct %s_%s_Params\n{\n", c.NameCpp, m.Name);
			for (auto&& param : m.Parameters)
			{
				tfm::format(os, "\t%-50s %-58s// (%s)\n", param.CppType, param.Name + ";", param.FlagsString);
			}
			os << "};\n\n";
		}
	}

	PrintFileFooter(os);
}

void Package::PrintConstant(std::ostream & os, const std::pair<std::string, std::string> & c) const
{
	tfm::format(os, "#define CONST_%-50s %s\n", c.first, c.second);
}

void Package::PrintEnum(std::ostream & os, const Enum & e) const
{
	using namespace cpplinq;

	os << "// " << e.FullName << "\nenum class " << e.Name << " : uint8_t\n{\n";
	os << (from(e.Values)
		>> select([](auto && name, auto && i) { return tfm::format("\t%-30s = %d", name, i); })
		>> concatenate(",\n"))
		<< "\n};\n\n";
}

void Package::PrintStruct(std::ostream & os, const ScriptStruct & ss) const
{
	using namespace cpplinq;

	os << "// " << ss.FullName << "\n// ";
	if (ss.InheritedSize)
	{
		os << tfm::format("0x%04X (0x%04X - 0x%04X)\n", ss.Size - ss.InheritedSize, ss.Size, ss.InheritedSize);
	}
	else
	{
		os << tfm::format("0x%04X\n", ss.Size);
	}

	os << ss.NameCppFull << "\n{\n";

	//Member
	os << (from(ss.Members)
		>> select([](auto && m) {
			return tfm::format("\t%-50s %-58s// 0x%04X(0x%04X)", m.Type, m.Name + ";", m.Offset, m.Size)
				+ (!m.Comment.empty() ? " " + m.Comment : "")
				+ (!m.FlagsString.empty() ? " (" + m.FlagsString + ")" : "");
			})
		>> concatenate("\n"))
		<< "\n";

			//Predefined Methods
			if (!ss.PredefinedMethods.empty())
			{
				os << "\n";
				for (auto&& m : ss.PredefinedMethods)
				{
					if (m.MethodType == IGenerator::PredefinedMethod::Type::Inline)
					{
						os << m.Body;
					}
					else
					{
						os << "\t" << m.Signature << ";";
					}
					os << "\n\n";
				}
			}

			os << "};\n";
}

void Package::PrintClass(std::ostream & os, const Class & c) const
{
	using namespace cpplinq;

	os << "// " << c.FullName << "\n// ";
	if (c.InheritedSize)
	{
		tfm::format(os, "0x%04X (0x%04X - 0x%04X)\n", c.Size - c.InheritedSize, c.Size, c.InheritedSize);
	}
	else
	{
		tfm::format(os, "0x%04X\n", c.Size);
	}

	os << c.NameCppFull << "\n{\npublic:\n";

	//Member
	for (auto&& m : c.Members)
	{
		tfm::format(os, "\t%-50s %-58s// 0x%04X(0x%04X)", m.Type, m.Name + ";", m.Offset, m.Size);
		if (!m.Comment.empty())
		{
			os << " " << m.Comment;
		}
		if (!m.FlagsString.empty())
		{
			os << " (" << m.FlagsString << ")";
		}
		os << "\n";
	}

	//Predefined Methods
	if (!c.PredefinedMethods.empty())
	{
		os << "\n";
		for (auto&& m : c.PredefinedMethods)
		{
			if (m.MethodType == IGenerator::PredefinedMethod::Type::Inline)
			{
				os << m.Body;
			}
			else
			{
				os << "\t" << m.Signature << ";";
			}

			os << "\n\n";
		}
	}

	//Methods
	if (!c.Methods.empty())
	{
		os << "\n";
		for (auto&& m : c.Methods)
		{
			os << "\t" << BuildMethodSignature(m, {}, true) << ";\n";
		}
	}

	os << "};\n\n";
}

std::string Package::BuildMethodSignature(const Method & m, const Class & c, bool inHeader) const
{
	extern IGenerator* generator;

	using namespace cpplinq;
	using Type = Method::Parameter::Type;

	std::ostringstream ss;

	if (m.IsStatic && inHeader && !generator->ShouldConvertStaticMethods())
	{
		ss << "static ";
	}

	//Return Type
	auto retn = from(m.Parameters) >> where([](auto && param) { return param.ParamType == Type::Return; });
	if (retn >> any())
	{
		ss << (retn >> first()).CppType;
	}
	else
	{
		ss << "void";
	}
	ss << " ";

	if (!inHeader)
	{
		ss << c.NameCpp << "::";
	}
	if (m.IsStatic && generator->ShouldConvertStaticMethods())
	{
		ss << "STATIC_";
	}
	ss << m.Name;

	//Parameters
	ss << "(";
	ss << (from(m.Parameters)
		>> where([](auto && param) { return param.ParamType != Type::Return; })
		>> orderby([](auto && param) { return param.ParamType; })
		>> select([](auto && param) { return (param.PassByReference ? "const " : "") + param.CppType + (param.PassByReference ? "& " : param.ParamType == Type::Out ? "* " : " ") + param.Name; })
		>> concatenate(", "));
	ss << ")";

	return ss.str();
}

std::string Package::BuildMethodBody(const Class & c, const Method & m) const
{
	extern IGenerator* generator;

	using namespace cpplinq;
	using Type = Method::Parameter::Type;

	std::ostringstream ss;

	//Function Pointer
	ss << "{\n\tstatic auto fn";

	if (generator->ShouldUseStrings())
	{
		ss << " = UObject::FindObject<UFunction>(";

		if (generator->ShouldXorStrings())
		{
			ss << "_xor_(\"" << m.FullName << "\")";
		}
		else
		{
			ss << "\"" << m.FullName << "\"";
		}

		ss << ");\n\n";
	}
	else
	{
		ss << " = UObject::GetObjectCasted<UFunction>(" << m.Index << ");\n\n";
	}

	//Parameters
	if (generator->ShouldGenerateFunctionParametersFile())
	{
		ss << "\t" << c.NameCpp << "_" << m.Name << "_Params params;\n";
	}
	else
	{
		ss << "\tstruct\n\t{\n";
		for (auto&& param : m.Parameters)
		{
			tfm::format(ss, "\t\t%-30s %s;\n", param.CppType, param.Name);
		}
		ss << "\t} params;\n";
	}

	auto defaultParameters = from(m.Parameters) >> where([](auto && param) { return param.ParamType == Type::Default; });
	if (defaultParameters >> any())
	{
		for (auto&& param : defaultParameters >> experimental::container())
		{
			ss << "\tparams." << param.Name << " = " << param.Name << ";\n";
		}
	}

	ss << "\n";

	//Function Call
	ss << "\tauto flags = fn->FunctionFlags;\n";
	if (m.IsNative)
	{
		ss << "\tfn->FunctionFlags |= 0x" << tfm::format("%X", static_cast<std::underlying_type_t<UEFunctionFlags>>(UEFunctionFlags::Native)) << ";\n";
	}

	ss << "\n";

	if (m.IsStatic && !generator->ShouldConvertStaticMethods())
	{
		ss << "\tstatic auto defaultObj = StaticClass()->CreateDefaultObject();\n";
		ss << "\tdefaultObj->ProcessEvent(fn, &params);\n\n";
	}
	else
	{
		ss << "\tUObject::ProcessEvent(fn, &params);\n\n";
	}

	ss << "\tfn->FunctionFlags = flags;\n";

	//Out Parameters
	auto out = from(m.Parameters) >> where([](auto && param) { return param.ParamType == Type::Out; });
	if (out >> any())
	{
		ss << "\n";

		for (auto&& param : out >> experimental::container())
		{
			ss << "\tif (" << param.Name << " != nullptr)\n";
			ss << "\t\t*" << param.Name << " = params." << param.Name << ";\n";
		}
	}

	//Return Value
	auto retn = from(m.Parameters) >> where([](auto && param) { return param.ParamType == Type::Return; });
	if (retn >> any())
	{
		ss << "\n\treturn params." << (retn >> first()).Name << ";\n";
	}

	ss << "}\n";

	return ss.str();
}
```

`UnrealFinderTool/SdkGen/Engine/Package.h`:

```h
#pragma once
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <filesystem>
#include <mutex>

namespace fs = std::filesystem;

#include "GenericTypes.h"

class Package
{
	friend struct std::hash<Package>;
	friend struct PackageDependencyComparer;
	friend bool operator==(const Package& lhs, const Package& rhs);

public:
	static std::unordered_map<UEObject, const Package*> PackageMap;

	/// <summary>
	/// Constructor.
	/// </summary>
	/// <param name="packageObj">The package object.</param>
	Package(UEObject* packageObj);

	std::string GetName() const { return packageObj->GetName(); }

	/// <summary>
	/// Process the classes the package contains.
	/// </summary>
	void Process(std::unordered_map<uintptr_t, bool>& processedObjects, std::mutex& packageLocker);

	/// <summary>
	/// Saves the package classes as C++ code.
	/// Files are only generated if there is code present or the generator forces the generation of empty files.
	/// </summary>
	/// <param name="path">The path to save to.</param>
	/// <returns>true if files got saved, else false.</returns>
	bool Save(const fs::path& path) const;

private:
	bool AddDependency(UEObject* package) const;

	/// <summary>
	/// Checks and generates the prerequisites of the object.
	/// Should be a UEClass or UEScriptStruct.
	/// </summary>
	/// <param name="obj">The object.</param>
	/// <param name="processedObjects"></param>
	void GeneratePrerequisites(const UEObject& obj, std::unordered_map<uintptr_t, bool>& processedObjects);

	/// <summary>
	/// Checks and generates the prerequisites of the members.
	/// </summary>
	/// <param name="first">The first member in the chain.</param>
	/// <param name="processedObjects"></param>
	void GenerateMemberPrerequisites(const UEProperty& first, std::unordered_map<uintptr_t, bool>& processedObjects);

	/// <summary>
	/// Generates a script structure.
	/// </summary>
	/// <param name="scriptStructObj">The script structure object.</param>
	void GenerateScriptStruct(const UEScriptStruct& scriptStructObj);

	/// <summary>
	/// Generates a constant.
	/// </summary>
	/// <param name="constObj">The constant object.</param>
	void GenerateConst(const UEConst& constObj);

	/// <summary>
	/// Generates an enum.
	/// </summary>
	/// <param name="enumObj">The enum object.</param>
	void GenerateEnum(const UEEnum& enumObj);

	/// <summary>
	/// Generates the class.
	/// </summary>
	/// <param name="classObj">The class object.</param>
	void GenerateClass(const UEClass& classObj);

	/// <summary>
	/// Writes all structs into the appropriate file.
	/// </summary>
	/// <param name="path">The path to save to.</param>
	void SaveStructs(const fs::path& path) const;

	/// <summary>
	/// Writes all classes into the appropriate file.
	/// </summary>
	/// <param name="path">The path to save to.</param>
	void SaveClasses(const fs::path& path) const;

	/// <summary>
	/// Writes all functions into the appropriate file.
	/// </summary>
	/// <param name="path">The path to save to.</param>
	void SaveFunctions(const fs::path& path) const;

	/// <summary>
	/// Writes all function parameters into the appropriate file.
	/// </summary>
	/// <param name="path">The path to save to.</param>
	void SaveFunctionParameters(const fs::path& path) const;

	UEObject* packageObj;
	mutable std::unordered_set<UEObject> dependencies;

	/// <summary>
	/// Prints the c++ code of the constant.
	/// </summary>
	/// <param name="os">[in] The stream to print to.</param>
	/// <param name="c">The constant to print.</param>
	void PrintConstant(std::ostream& os, const std::pair<std::string, std::string>& c) const;

	std::unordered_map<std::string, std::string> constants;

	/*
	 * ENUMS
	 */
	struct Enum
	{
		std::string Name;
		std::string FullName;
		std::vector<std::string> Values;
	};

	/// <summary>
	/// Prints the c++ code of the enum.
	/// </summary>
	/// <param name="os">[in] The stream to print to.</param>
	/// <param name="e">The enum to print.</param>
	void PrintEnum(std::ostream& os, const Enum& e) const;


	/*
	 * SCRIPT_STRUCT
	 */
	struct Member
	{
		std::string Name;
		std::string Type;

		size_t Offset;
		size_t Size;

		size_t Flags;
		std::string FlagsString;

		std::string Comment;
	};

	/// <summary>
	/// Generates a padding member.
	/// </summary>
	/// <param name="id">The unique name identifier.</param>
	/// <param name="offset">The offset.</param>
	/// <param name="size">The size.</param>
	/// <param name="reason">The reason.</param>
	/// <returns>A padding member.</returns>
	static Member CreatePadding(size_t id, size_t offset, size_t size, std::string reason);

	/// <summary>
	/// Generates a padding member.
	/// </summary>
	/// <param name="id">The unique name identifier.</param>
	/// <param name="offset">The offset.</param>
	/// <param name="size">The size.</param>
	/// <param name="reason">The reason.</param>
	/// <returns>A padding member.</returns>
	static Member CreateBitfieldPadding(size_t id, size_t offset, std::string type, size_t bits);

	/// <summary>
	/// Generates the members of a struct or class.
	/// </summary>
	/// <param name="structObj">The structure object.</param>
	/// <param name="offset">The start offset.</param>
	/// <param name="properties">The properties describing the members.</param>
	/// <param name="members">[out] The members of the struct or class.</param>
	void GenerateMembers(const UEStruct& structObj, size_t offset, const std::vector<UEProperty>& properties, std::vector<Member>& members) const;

	struct ScriptStruct
	{
		std::string Name;
		std::string FullName;
		std::string NameCpp;
		std::string NameCppFull;

		size_t Size;
		size_t InheritedSize;

		std::vector<Member> Members;

		std::vector<IGenerator::PredefinedMethod> PredefinedMethods;
	};

	/// <summary>
	/// Print the C++ code of the structure.
	/// </summary>
	/// <param name="os">[in] The stream to print to.</param>
	/// <param name="ss">The structure to print.</param>
	void PrintStruct(std::ostream& os, const ScriptStruct& ss) const;

	/*
	 * METHODS
	 */
	struct Method
	{
		struct Parameter
		{
			enum class Type
			{
				Default,
				Out,
				Return
			};

			Type ParamType;
			bool PassByReference;
			std::string CppType;
			std::string Name;
			std::string FlagsString;

			/// <summary>
			/// Generates a valid type of the property flags.
			/// </summary>
			/// <param name="flags">The property flags.</param>
			/// <param name="type">[out] The parameter type.</param>
			/// <returns>true if it is a valid type, else false.</returns>
			static bool MakeType(UEPropertyFlags flags, Type& type);
		};

		size_t Index;
		std::string Name;
		std::string FullName;
		std::vector<Parameter> Parameters;
		std::string FlagsString;
		bool IsNative;
		bool IsStatic;
	};

	/// <summary>
	/// Generates the methods of a class.
	/// </summary>
	/// <param name="classObj">The class object.</param>
	/// <param name="methods">[out] The methods of the class.</param>
	void GenerateMethods(const UEClass& classObj, std::vector<Method>& methods) const;

	struct Class : ScriptStruct
	{
		std::vector<std::string> VirtualFunctions;
		std::vector<Method> Methods;
	};

	/// <summary>
	/// Builds the C++ method signature.
	/// </summary>
	/// <param name="m">The Method to process.</param>
	/// <param name="c">Name of the class.</param>
	/// <param name="inHeader">true if the signature is used as deceleration.</param>
	/// <returns>The method signature.</returns>
	std::string BuildMethodSignature(const Method& m, const Class& c, bool inHeader) const;

	/// <summary>
	/// Builds the c++ method body.
	/// </summary>
	/// <param name="c"></param>
	/// <param name="m">The Method to process.</param>
	/// <returns>The method body.</returns>
	std::string BuildMethodBody(const Class& c, const Method& m) const;

	/// <summary>
	/// Print the C++ code of the class.
	/// </summary>
	/// <param name="os">[in] The stream to print to.</param>
	/// <param name="c">The class to print.</param>
	void PrintClass(std::ostream& os, const Class& c) const;

public:
	std::vector<Class> Classes;
	std::vector<ScriptStruct> ScriptStructs;
	std::vector<Enum> Enums;
};

namespace std
{
	template<>
	struct hash<Package>
	{
		size_t operator()(const Package& package) const noexcept
		{
			return std::hash<uintptr_t>()(package.packageObj->GetAddress());
		}
	};
}

inline bool operator==(const Package& lhs, const Package& rhs) { return rhs.packageObj->GetAddress() == lhs.packageObj->GetAddress(); }
inline bool operator!=(const Package& lhs, const Package& rhs) { return !(lhs == rhs); }

struct PackageDependencyComparer
{
	bool operator()(const std::unique_ptr<Package>& lhs, const std::unique_ptr<Package>& rhs) const
	{
		return operator()(*lhs, *rhs);
	}

	bool operator()(const Package* lhs, const Package* rhs) const
	{
		return operator()(*lhs, *rhs);
	}

	bool operator()(const Package& lhs, const Package& rhs) const
	{
		if (rhs.dependencies.empty())
		{
			return false;
		}

		if (std::find(rhs.dependencies.begin(), rhs.dependencies.end(), *lhs.packageObj) != std::end(rhs.dependencies))
		{
			return true;
		}

		for (const auto& dep : rhs.dependencies)
		{
			const auto package = Package::PackageMap[dep];
			if (package == nullptr)
			{
				// Missing package, should not occur...
				continue;
			}

			if (operator()(lhs, *package))
			{
				return true;
			}
		}

		return false;
	}
};
```

`UnrealFinderTool/SdkGen/Engine/PrintHelper.cpp`:

```cpp
#include "pch.h"
#include "PrintHelper.h"

#include <tinyformat.h>

#include "IGenerator.h"
#include "Package.h"

void PrintFileHeader(std::ostream& os, const std::vector<std::string>& pragmas, const std::vector<std::string>& includes, const bool isHeaderFile)
{
	extern IGenerator* generator;

	if (isHeaderFile)
		os << "#pragma once\n";

	if (!pragmas.empty())
	{
		for (auto&& i : pragmas) { os << "#pragma " << i << "\n"; }
	}
	os << "\n";

	if (generator->GetSdkType() == SdkType::External)
		os << "#include \"" << Utils::Settings.SdkGen.MemoryHeader << "\"\n";

	if (!includes.empty())
	{
		for (auto&& i : includes) { os << "#include " << i << "\n"; }
		os << "\n";
	}

	os << tfm::format("// Name: %s, Version: %s\n\n", generator->GetGameName(), generator->GetGameVersion())
	   << tfm::format("#ifdef _MSC_VER\n\t#pragma pack(push, 0x%X)\n#endif\n\n", generator->GetGlobalMemberAlignment());

	if (!generator->GetNamespaceName().empty())
		os << "namespace " << generator->GetNamespaceName() << "\n{\n";
}

void PrintFileHeader(std::ostream& os, const std::vector<std::string>& includes, const bool isHeaderFile)
{
	PrintFileHeader(os, {}, includes, isHeaderFile);
}

void PrintFileHeader(std::ostream& os, const bool isHeaderFile)
{
	extern IGenerator* generator;

	PrintFileHeader(os, {}, isHeaderFile);
}

void PrintFileFooter(std::ostream& os)
{
	extern IGenerator* generator;

	if (!generator->GetNamespaceName().empty())
	{
		os << "}\n\n";
	}

	os << "#ifdef _MSC_VER\n\t#pragma pack(pop)\n#endif\n";
}

void PrintSectionHeader(std::ostream& os, const char* name)
{
	os  << "//---------------------------------------------------------------------------\n"
		<< "// " << name << "\n"
		<< "//---------------------------------------------------------------------------\n\n";
}

std::string GenerateFileName(const FileContentType type, const Package& package)
{
	extern IGenerator* generator;

	const char* name = "";
	switch (type)
	{
	case FileContentType::Structs:
		name = "%s_structs.h";
		break;
	case FileContentType::Classes:
		name = "%s_classes.h";
		break;
	case FileContentType::Functions:
		name = "%s_functions.cpp";
		break;
	case FileContentType::FunctionParameters:
		name = "%s_parameters.h";
		break;
	default:
		assert(false);
	}

	return tfm::format(name, package.GetName());
}

```

`UnrealFinderTool/SdkGen/Engine/PrintHelper.h`:

```h
#pragma once

#include <vector>
#include <string>

void PrintFileHeader(std::ostream& os, const std::vector<std::string>& pragmas, const std::vector<std::string>& includes, bool isHeaderFile);

void PrintFileHeader(std::ostream& os, const std::vector<std::string>& includes, bool isHeaderFile);

void PrintFileHeader(std::ostream& os, bool isHeaderFile);

void PrintFileFooter(std::ostream& os);

void PrintSectionHeader(std::ostream& os, const char* name);

enum class FileContentType
{
	Structs,
	Classes,
	Functions,
	FunctionParameters
};

/// <summary>
/// Generates a file name composed by the game name and the package object.
/// </summary>
/// <param name="type">The type of the file.</param>
/// <returns>
/// The generated file name.
/// </returns>
std::string GenerateFileName(FileContentType type, const class Package& package);

```

`UnrealFinderTool/SdkGen/Engine/UE4/FunctionFlags.cpp`:

```cpp
#include "pch.h"
#include "FunctionFlags.h"

#include <vector>
#include <sstream>
#include <iterator>

std::string StringifyFlags(const UEFunctionFlags flags)
{
	std::vector<const char*> buffer;

	if (flags & UEFunctionFlags::Final) { buffer.push_back("Final"); }
	if (flags & UEFunctionFlags::RequiredAPI) { buffer.push_back("RequiredAPI"); }
	if (flags & UEFunctionFlags::BlueprintAuthorityOnly) { buffer.push_back("BlueprintAuthorityOnly"); }
	if (flags & UEFunctionFlags::BlueprintCosmetic) { buffer.push_back("BlueprintCosmetic"); }
	if (flags & UEFunctionFlags::Net) { buffer.push_back("Net"); }
	if (flags & UEFunctionFlags::NetReliable) { buffer.push_back("NetReliable"); }
	if (flags & UEFunctionFlags::NetRequest) { buffer.push_back("NetRequest"); }
	if (flags & UEFunctionFlags::Exec) { buffer.push_back("Exec"); }
	if (flags & UEFunctionFlags::Native) { buffer.push_back("Native"); }
	if (flags & UEFunctionFlags::Event) { buffer.push_back("Event"); }
	if (flags & UEFunctionFlags::NetResponse) { buffer.push_back("NetResponse"); }
	if (flags & UEFunctionFlags::Static) { buffer.push_back("Static"); }
	if (flags & UEFunctionFlags::NetMulticast) { buffer.push_back("NetMulticast"); }
	if (flags & UEFunctionFlags::MulticastDelegate) { buffer.push_back("MulticastDelegate"); }
	if (flags & UEFunctionFlags::Public) { buffer.push_back("Public"); }
	if (flags & UEFunctionFlags::Private) { buffer.push_back("Private"); }
	if (flags & UEFunctionFlags::Protected) { buffer.push_back("Protected"); }
	if (flags & UEFunctionFlags::Delegate) { buffer.push_back("Delegate"); }
	if (flags & UEFunctionFlags::NetServer) { buffer.push_back("NetServer"); }
	if (flags & UEFunctionFlags::HasOutParms) { buffer.push_back("HasOutParms"); }
	if (flags & UEFunctionFlags::HasDefaults) { buffer.push_back("HasDefaults"); }
	if (flags & UEFunctionFlags::NetClient) { buffer.push_back("NetClient"); }
	if (flags & UEFunctionFlags::DLLImport) { buffer.push_back("DLLImport"); }
	if (flags & UEFunctionFlags::BlueprintCallable) { buffer.push_back("BlueprintCallable"); }
	if (flags & UEFunctionFlags::BlueprintEvent) { buffer.push_back("BlueprintEvent"); }
	if (flags & UEFunctionFlags::BlueprintPure) { buffer.push_back("BlueprintPure"); }
	if (flags & UEFunctionFlags::Const) { buffer.push_back("Const"); }
	if (flags & UEFunctionFlags::NetValidate) { buffer.push_back("NetValidate"); }

	switch (buffer.size())
	{
	case 0:
		return std::string();
	case 1:
		return std::string(buffer[0]);
	default:
		std::ostringstream os;
		std::copy(buffer.begin(), buffer.end() - 1, std::ostream_iterator<const char*>(os, ", "));
		os << *buffer.rbegin();
		return os.str();
	}
}
```

`UnrealFinderTool/SdkGen/Engine/UE4/FunctionFlags.h`:

```h
#pragma once

#include <type_traits>
#include <string>

enum class UEFunctionFlags : uint32_t
{
	Final = 0x00000001,
	RequiredAPI = 0x00000002,
	BlueprintAuthorityOnly = 0x00000004,
	BlueprintCosmetic = 0x00000008,
	Net = 0x00000040,
	NetReliable = 0x00000080,
	NetRequest = 0x00000100,
	Exec = 0x00000200,
	Native = 0x00000400,
	Event = 0x00000800,
	NetResponse = 0x00001000,
	Static = 0x00002000,
	NetMulticast = 0x00004000,
	MulticastDelegate = 0x00010000,
	Public = 0x00020000,
	Private = 0x00040000,
	Protected = 0x00080000,
	Delegate = 0x00100000,
	NetServer = 0x00200000,
	HasOutParms = 0x00400000,
	HasDefaults = 0x00800000,
	NetClient = 0x01000000,
	DLLImport = 0x02000000,
	BlueprintCallable = 0x04000000,
	BlueprintEvent = 0x08000000,
	BlueprintPure = 0x10000000,
	Const = 0x40000000,
	NetValidate = 0x80000000
};

inline bool operator&(UEFunctionFlags lhs, UEFunctionFlags rhs)
{
	return (static_cast<std::underlying_type_t<UEFunctionFlags>>(lhs) & static_cast<std::underlying_type_t<UEFunctionFlags>>(rhs)) == static_cast<std::underlying_type_t<UEFunctionFlags>>(rhs);
}

std::string StringifyFlags(const UEFunctionFlags flags);

```

`UnrealFinderTool/SdkGen/Engine/UE4/GenericTypes.cpp`:

```cpp
#include "pch.h"
#include "EngineClasses.h"
#include "IGenerator.h"
#include "ObjectsStore.h"
#include "NamesStore.h"
#include "NameValidator.h"
#include "GenericTypes.h"

#pragma region UEObject
bool UEObject::IsA(const std::string& typeName) const
{
	if (!IsValid()) return false;

	for (UEClass super = GetClass(); super.IsValid(); super = super.GetSuper().Cast<UEClass>())
	{
		if (super.GetName() == typeName || super.GetNameCpp() == typeName)
			return true;
	}

	return false;
}

uintptr_t UEObject::GetAddress() const
{
	return Object->ObjAddress;
}

bool UEObject::IsValid() const
{
	return Object->ObjAddress != NULL && Object->VfTable != NULL && (Object->Name.ComparisonIndex > 0 && size_t(Object->Name.ComparisonIndex) <= NamesStore().GetNamesNum());
}

size_t UEObject::GetIndex() const
{
	return Object->InternalIndex;
}

std::string UEObject::GetName() const
{
	// Get Original Object, if not have a value update it
	UEObject* obj = GetObjByAddress(GetAddress());
	if (!obj->objName.empty())
		return obj->objName;

	auto name = NamesStore().GetByIndex(Object->Name.ComparisonIndex);
	if (!name.empty() && (Object->Name.Number > 0 && Object->Name.ComparisonIndex != Object->Name.Number))
		name += '_' + std::to_string(Object->Name.Number);

	auto pos = name.rfind('/');
	if (pos == std::string::npos)
	{
		// Update original and local
		obj->objName = name;
		this->objName = obj->objName;

		return name;
	}

	// Update original and local
	obj->objName = name.substr(pos + 1);
	this->objName = obj->objName;

	return objName;
}

std::string UEObject::GetInstanceClassName() const
{
	if (!IsValid()) return "";

	bool find;
	UEObject* obj = ObjectsStore::GetByAddress(GetAddress(), find);

	return find ? obj->GetClass().GetNameCpp() : "";
}

std::string UEObject::GetFullName() const
{
	// Get Original Object, if not have a value update it
	UEObject* obj = GetObjByAddress(GetAddress());
	if (!obj->fullName.empty())
		return obj->fullName;

	auto cClass = GetClass();
	if (cClass.IsValid())
	{
		std::string temp;

		for (auto outer = GetOuter(); outer->IsValid(); outer = outer->GetOuter())
			temp.insert(0, outer->GetName() + ".");

		std::string name = cClass.GetName();
		name += " ";
		name += temp;
		name += GetName();

		// Update original and local
		obj->fullName = name;
		this->fullName = name;

		return fullName;
	}

	return std::string("(null)");
}

std::string UEObject::GetNameCpp() const
{
	// Get Original Object, if not have a value update it
	UEObject* obj = GetObjByAddress(GetAddress());
	if (!obj->nameCpp.empty())
		return obj->nameCpp;

	std::string name;
	if (IsA<UEClass>())
	{
		auto c = Cast<UEClass>();
		while (c.IsValid())
		{
			const auto className = c.GetName();
			if (className == "Actor")
			{
				name += "A";
				break;
			}
			if (className == "Object")
			{
				name += "U";
				break;
			}

			c = c.GetSuper().Cast<UEClass>();
		}
	}
	else
	{
		name += "F";
	}

	name += GetName();

	// Update original and local
	obj->nameCpp = name;
	this->nameCpp = name;

	return name;
}

UEClass UEObject::GetClass() const
{
	// Must have a class
	/*if (INVALID_POINTER_VALUE(Object->Class))
		return UEClass();*/

	return GetObjByAddress(Object->Class)->Cast<UEClass>();
	// return UEClass(objClass);
}

UEObject* UEObject::GetOuter() const
{
	if (INVALID_POINTER_VALUE(Object->Outer))
		return &UEObjectEmpty;

	bool found;
	UEObject* outer = ObjectsStore::GetByAddress(Object->Outer, found);

	return found ? outer : &UEObjectEmpty;
}

UEObject* UEObject::GetPackageObject() const
{
	// Package Is The Last Outer
	if (!package)
	{
		for (UEObject* outer = GetOuter(); outer->IsValid(); outer = outer->GetOuter())
			package = outer;

		if (!package)
			package = GetObjByAddress(Object->ObjAddress);
	}

	return package;
}

int UEObject::TypeId()
{
	static int ret = NamesStore().GetByName("UObject");
	return ret;
}

UEObject* UEObject::GetObjByAddress(const uintptr_t address)
{
	return ObjectsStore::GetByAddress(address);
}

UEClass UEObject::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".Object");
	return c;
}
#pragma endregion

#pragma region UEField
UEField UEField::GetNext() const
{
	if (objField.Empty())
		objField = Object->Cast<UField>();

	if (INVALID_POINTER_VALUE(objField.Next))
		return UEField();

	return GetObjByAddress(objField.Next)->Cast<UEField>();
	// return UEField(next);
}

int UEField::TypeId()
{
	static int ret = NamesStore().GetByName("UField");
	return ret;
}

UEClass UEField::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".Field");
	return c;
}
#pragma endregion

#pragma region UEEnum
std::vector<std::string> UEEnum::GetNames() const
{
	std::vector<std::string> buffer;
	if (objEnum.Empty())
		objEnum = Object->Cast<UEnum>();

	// Get Names
	uintptr_t dataAddress = objEnum.Names.Data;
	if (objEnum.Names.Count > 300)
	{
		MessageBoxA(nullptr, "UEnum looks bad.", "Problem", MB_OK);
		ExitProcess(-1);
	}
	auto cls = new FUEnumItem[objEnum.Names.Count];
	Utils::MemoryObj->ReadBytes(dataAddress, cls, sizeof(FUEnumItem) * objEnum.Names.Count);

	buffer.reserve(objEnum.Names.Count);
	for (auto i = 0; i < objEnum.Names.Count; ++i)
	{
		size_t index = cls[i].Key.ComparisonIndex;
		if (index > NamesStore().GetNamesNum() || index == 0)
			continue;

		buffer.push_back(NamesStore().GetByIndex(index));
	}

	delete[] cls;
	return buffer;
}

int UEEnum::TypeId()
{
	static int ret = NamesStore().GetByName("Enum");
	return ret;
}

UEClass UEEnum::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".Enum");
	return c;
}
#pragma endregion

#pragma region UEConst
std::string UEConst::GetValue() const
{
	throw;
}

int UEConst::TypeId()
{
	static int ret = NamesStore().GetByName("UConst");
	return ret;
}

UEClass UEConst::StaticClass()
{
	//not supported by UE4
	return UEClass();
}
#pragma endregion

#pragma region UEStruct
UEStruct UEStruct::GetSuper() const
{
	if (objStruct.Empty())
		objStruct = Object->Cast<UStruct>();

	if (INVALID_POINTER_VALUE(objStruct.SuperField))
		return UEStruct();

	return GetObjByAddress(objStruct.SuperField)->Cast<UEStruct>();
	// return UEStruct(superField);
}

UEField UEStruct::GetChildren() const
{
	if (objStruct.Empty())
		objStruct = Object->Cast<UStruct>();

	if (INVALID_POINTER_VALUE(objStruct.Children))
		return UEField();

	return GetObjByAddress(objStruct.Children)->Cast<UEField>();
	// return UEField(children);
}

size_t UEStruct::GetPropertySize() const
{
	if (objStruct.Empty())
		objStruct = Object->Cast<UStruct>();

	return objStruct.PropertySize;
}

int UEStruct::TypeId()
{
	static int ret = NamesStore().GetByName("Struct");
	return ret;
}

UEClass UEStruct::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".Struct");
	return c;
}
#pragma endregion

#pragma region UEScriptStruct
int UEScriptStruct::TypeId()
{
	static int ret = NamesStore().GetByName("ScriptStruct");
	return ret;
}

UEClass UEScriptStruct::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".ScriptStruct");
	return c;
}
#pragma endregion

#pragma region UEFunction
UEFunctionFlags UEFunction::GetFunctionFlags() const
{
	if (objFunction.Empty())
		objFunction = Object->Cast<UFunction>();

	return static_cast<UEFunctionFlags>(objFunction.FunctionFlags);
}

int UEFunction::TypeId()
{
	static int ret = NamesStore().GetByName("Function");
	return ret;
}

UEClass UEFunction::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".Function");
	return c;
}
#pragma endregion

#pragma region UEClass
int UEClass::TypeId()
{
	static int ret = NamesStore().GetByName("Class");
	return ret;
}

UEClass UEClass::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".Class");
	return c;
}
#pragma endregion

#pragma region UEProperty
size_t UEProperty::GetArrayDim() const
{
	if (objProperty.Empty())
		objProperty = Object->Cast<UProperty>();

	return objProperty.ArrayDim;
}

size_t UEProperty::GetElementSize() const
{
	if (objProperty.Empty())
		objProperty = Object->Cast<UProperty>();

	return objProperty.ElementSize;
}

UEPropertyFlags UEProperty::GetPropertyFlags() const
{
	if (objProperty.Empty())
		objProperty = Object->Cast<UProperty>();

	return static_cast<UEPropertyFlags>(objProperty.PropertyFlags.A);
}

size_t UEProperty::GetOffset() const
{
	if (objProperty.Empty())
		objProperty = Object->Cast<UProperty>();

	return objProperty.Offset;
}

UEProperty::Info UEProperty::GetInfo() const
{
	if (infoChanged)
		return curInfo;

	if (IsValid())
	{
		if (IsA<UEByteProperty>())
		{
			infoChanged = true;
			curInfo = Cast<UEByteProperty>().GetInfo();
		}
		else if (IsA<UEUInt16Property>())
		{
			infoChanged = true;
			curInfo = Cast<UEUInt16Property>().GetInfo();
		}
		else if (IsA<UEUInt32Property>())
		{
			infoChanged = true;
			curInfo = Cast<UEUInt32Property>().GetInfo();
		}
		else if (IsA<UEUInt64Property>())
		{
			infoChanged = true;
			curInfo = Cast<UEUInt64Property>().GetInfo();
		}
		else if (IsA<UEInt8Property>())
		{
			infoChanged = true;
			curInfo = Cast<UEInt8Property>().GetInfo();
		}
		else if (IsA<UEInt16Property>())
		{
			infoChanged = true;
			curInfo = Cast<UEInt16Property>().GetInfo();
		}
		else if (IsA<UEIntProperty>())
		{
			infoChanged = true;
			curInfo = Cast<UEIntProperty>().GetInfo();
		}
		else if (IsA<UEInt64Property>())
		{
			infoChanged = true;
			curInfo = Cast<UEInt64Property>().GetInfo();
		}
		else if (IsA<UEFloatProperty>())
		{
			infoChanged = true;
			curInfo = Cast<UEFloatProperty>().GetInfo();
		}
		else if (IsA<UEDoubleProperty>())
		{
			infoChanged = true;
			curInfo = Cast<UEDoubleProperty>().GetInfo();
		}
		else if (IsA<UEBoolProperty>())
		{
			infoChanged = true;
			curInfo = Cast<UEBoolProperty>().GetInfo();
		}
		else if (IsA<UEObjectProperty>())
		{
			infoChanged = true;
			curInfo = Cast<UEObjectProperty>().GetInfo();
		}
		else if (IsA<UEClassProperty>())
		{
			infoChanged = true;
			curInfo = Cast<UEClassProperty>().GetInfo();
		}
		else if (IsA<UEInterfaceProperty>())
		{
			infoChanged = true;
			curInfo = Cast<UEInterfaceProperty>().GetInfo();
		}
		else if (IsA<UEWeakObjectProperty>())
		{
			infoChanged = true;
			curInfo = Cast<UEWeakObjectProperty>().GetInfo();
		}
		else if (IsA<UELazyObjectProperty>())
		{
			infoChanged = true;
			curInfo = Cast<UELazyObjectProperty>().GetInfo();
		}
		else if (IsA<UEAssetObjectProperty>())
		{
			infoChanged = true;
			curInfo = Cast<UEAssetObjectProperty>().GetInfo();
		}
		else if (IsA<UEAssetClassProperty>())
		{
			infoChanged = true;
			curInfo = Cast<UEAssetClassProperty>().GetInfo();
		}
		else if (IsA<UENameProperty>())
		{
			infoChanged = true;
			curInfo = Cast<UENameProperty>().GetInfo();
		}
		else if (IsA<UEStructProperty>())
		{
			infoChanged = true;
			curInfo = Cast<UEStructProperty>().GetInfo();
		}
		else if (IsA<UEStrProperty>())
		{
			infoChanged = true;
			curInfo = Cast<UEStrProperty>().GetInfo();
		}
		else if (IsA<UETextProperty>())
		{
			infoChanged = true;
			curInfo = Cast<UETextProperty>().GetInfo();
		}
		else if (IsA<UEArrayProperty>())
		{
			infoChanged = true;
			curInfo = Cast<UEArrayProperty>().GetInfo();
		}
		else if (IsA<UEMapProperty>())
		{
			infoChanged = true;
			curInfo = Cast<UEMapProperty>().GetInfo();
		}
		else if (IsA<UEDelegateProperty>())
		{
			infoChanged = true;
			curInfo = Cast<UEDelegateProperty>().GetInfo();
		}
		else if (IsA<UEMulticastDelegateProperty>())
		{
			infoChanged = true;
			curInfo = Cast<UEMulticastDelegateProperty>().GetInfo();
		}
		else if (IsA<UEEnumProperty>())
		{
			infoChanged = true;
			curInfo = Cast<UEEnumProperty>().GetInfo();
		}
	}

	if (infoChanged)
		return curInfo;

	return { PropertyType::Unknown };
}

int UEProperty::TypeId()
{
	static int ret = NamesStore().GetByName("Property");
	return ret;
}

UEClass UEProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".Property");
	return c;
}
#pragma endregion

#pragma region UENumericProperty
int UENumericProperty::TypeId()
{
	static int ret = NamesStore().GetByName("NumericProperty");
	return ret;
}

UEClass UENumericProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".NumericProperty");
	return c;
}
#pragma endregion

#pragma region UEUInt16Property
UEProperty::Info UEUInt16Property::GetInfo() const
{
	return Info::Create(PropertyType::Primitive, sizeof(uint16_t), false, "uint16_t");
}

int UEUInt16Property::TypeId()
{
	static int ret = NamesStore().GetByName("UInt16Property");
	return ret;
}

UEClass UEUInt16Property::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".UInt16Property");
	return c;
}
#pragma endregion

#pragma region UEUInt32Property
UEProperty::Info UEUInt32Property::GetInfo() const
{
	return Info::Create(PropertyType::Primitive, sizeof(uint32_t), false, "uint32_t");
}

int UEUInt32Property::TypeId()
{
	static int ret = NamesStore().GetByName("UInt32Property");
	return ret;
}

UEClass UEUInt32Property::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".UInt32Property");
	return c;
}
#pragma endregion

#pragma region UEUInt64Property
UEProperty::Info UEUInt64Property::GetInfo() const
{
	return Info::Create(PropertyType::Primitive, sizeof(uint64_t), false, "uint64_t");
}

int UEUInt64Property::TypeId()
{
	static int ret = NamesStore().GetByName("UInt64Property");
	return ret;
}

UEClass UEUInt64Property::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".UInt64Property");
	return c;
}
#pragma endregion

#pragma region UEInt8Property
UEProperty::Info UEInt8Property::GetInfo() const
{
	return Info::Create(PropertyType::Primitive, sizeof(int8_t), false, "int8_t");
}

int UEInt8Property::TypeId()
{
	static int ret = NamesStore().GetByName("Int8Property");
	return ret;
}

UEClass UEInt8Property::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".Int8Property");
	return c;
}
#pragma endregion

#pragma region UEInt16Property
UEProperty::Info UEInt16Property::GetInfo() const
{
	return Info::Create(PropertyType::Primitive, sizeof(int16_t), false, "int16_t");
}

int UEInt16Property::TypeId()
{
	static int ret = NamesStore().GetByName("Int16Property");
	return ret;
}

UEClass UEInt16Property::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".Int16Property");
	return c;
}
#pragma endregion

#pragma region UEIntProperty
UEProperty::Info UEIntProperty::GetInfo() const
{
	return Info::Create(PropertyType::Primitive, sizeof(int), false, "int");
}

int UEIntProperty::TypeId()
{
	static int ret = NamesStore().GetByName("IntProperty");
	return ret;
}

UEClass UEIntProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".IntProperty");
	return c;
}
#pragma endregion

#pragma region UEInt64Property
UEProperty::Info UEInt64Property::GetInfo() const
{
	return Info::Create(PropertyType::Primitive, sizeof(int64_t), false, "int64_t");
}

int UEInt64Property::TypeId()
{
	static int ret = NamesStore().GetByName("Int64Property");
	return ret;
}

UEClass UEInt64Property::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".Int64Property");
	return c;
}
#pragma endregion

#pragma region UEFloatProperty
UEProperty::Info UEFloatProperty::GetInfo() const
{
	return Info::Create(PropertyType::Primitive, sizeof(float), false, "float");
}

int UEFloatProperty::TypeId()
{
	static int ret = NamesStore().GetByName("FloatProperty");
	return ret;
}

UEClass UEFloatProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".FloatProperty");
	return c;
}
#pragma endregion

#pragma region UEDoubleProperty
UEProperty::Info UEDoubleProperty::GetInfo() const
{
	return Info::Create(PropertyType::Primitive, sizeof(double), false, "double");
}

int UEDoubleProperty::TypeId()
{
	static int ret = NamesStore().GetByName("DoubleProperty");
	return ret;
}

UEClass UEDoubleProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".DoubleProperty");
	return c;
}
#pragma endregion

#pragma region UEObjectPropertyBase
UEClass UEObjectPropertyBase::GetPropertyClass() const
{
	if (objObjectPropertyBase.Empty())
		objObjectPropertyBase = Object->Cast<UObjectPropertyBase>();

	if (INVALID_POINTER_VALUE(objObjectPropertyBase.PropertyClass))
		return UEClass();

	return GetObjByAddress(objObjectPropertyBase.PropertyClass)->Cast<UEClass>();
	// return UEClass(propertyClass);
}

int UEObjectPropertyBase::TypeId()
{
	static int ret = NamesStore().GetByName("ObjectPropertyBase");
	return ret;
}

UEClass UEObjectPropertyBase::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".ObjectPropertyBase");
	return c;
}
#pragma endregion

#pragma region UEObjectProperty
UEProperty::Info UEObjectProperty::GetInfo() const
{
	return Info::Create(PropertyType::Primitive, sizeof(void*), false, "class " + MakeValidName(GetPropertyClass().GetNameCpp()) + "*");
}

int UEObjectProperty::TypeId()
{
	static int ret = NamesStore().GetByName("ObjectProperty");
	return ret;
}

UEClass UEObjectProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".ObjectProperty");
	return c;
}
#pragma endregion

#pragma region UEClassProperty
UEClass UEClassProperty::GetMetaClass() const
{
	if (objClassProperty.Empty())
		objClassProperty = Object->Cast<UClassProperty>();

	if (INVALID_POINTER_VALUE(objClassProperty.MetaClass))
		return UEClass();

	return GetObjByAddress(objClassProperty.MetaClass)->Cast<UEClass>();
	// return UEClass(metaClass);
}

UEProperty::Info UEClassProperty::GetInfo() const
{
	return Info::Create(PropertyType::Primitive, sizeof(void*), false, "class " + MakeValidName(GetMetaClass().GetNameCpp()) + "*");
}

int UEClassProperty::TypeId()
{
	static int ret = NamesStore().GetByName("ClassProperty");
	return ret;
}

UEClass UEClassProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".ClassProperty");
	return c;
}
#pragma endregion

#pragma region UEInterfaceProperty
UEClass UEInterfaceProperty::GetInterfaceClass() const
{
	if (objInterfaceProperty.Empty())
		objInterfaceProperty = Object->Cast<UInterfaceProperty>();

	if (INVALID_POINTER_VALUE(objInterfaceProperty.InterfaceClass))
		return UEClass();

	return GetObjByAddress(objInterfaceProperty.InterfaceClass)->Cast<UEClass>();
	// return UEClass(interfaceClass);
}

UEProperty::Info UEInterfaceProperty::GetInfo() const
{
	return Info::Create(PropertyType::PredefinedStruct, sizeof(FScriptInterface), true, "TScriptInterface<class " + MakeValidName(GetInterfaceClass().GetNameCpp()) + ">");
}

int UEInterfaceProperty::TypeId()
{
	static int ret = NamesStore().GetByName("InterfaceProperty");
	return ret;
}

UEClass UEInterfaceProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".InterfaceProperty");
	return c;
}
#pragma endregion

#pragma region UEWeakObjectProperty
UEProperty::Info UEWeakObjectProperty::GetInfo() const
{
	return Info::Create(PropertyType::Container, sizeof(FWeakObjectPtr), false, "TWeakObjectPtr<class " + MakeValidName(GetPropertyClass().GetNameCpp()) + ">");
}

int UEWeakObjectProperty::TypeId()
{
	static int ret = NamesStore().GetByName("WeakObjectProperty");
	return ret;
}

UEClass UEWeakObjectProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".WeakObjectProperty");
	return c;
}
#pragma endregion

#pragma region UELazyObjectProperty
UEProperty::Info UELazyObjectProperty::GetInfo() const
{
	return Info::Create(PropertyType::Container, sizeof(FLazyObjectPtr), false, "TLazyObjectPtr<class " + MakeValidName(GetPropertyClass().GetNameCpp()) + ">");
}

int UELazyObjectProperty::TypeId()
{
	static int ret = NamesStore().GetByName("LazyObjectProperty");
	return ret;
}

UEClass UELazyObjectProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".LazyObjectProperty");
	return c;
}
#pragma endregion

#pragma region UEAssetObjectProperty
UEProperty::Info UEAssetObjectProperty::GetInfo() const
{
	return Info::Create(PropertyType::Container, sizeof(FAssetPtr), false, "TAssetPtr<class " + MakeValidName(GetPropertyClass().GetNameCpp()) + ">");
}

int UEAssetObjectProperty::TypeId()
{
	static int ret = NamesStore().GetByName("AssetObjectProperty");
	return ret;
}

UEClass UEAssetObjectProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".AssetObjectProperty");
	return c;
}
#pragma endregion

#pragma region UEAssetClassProperty
UEClass UEAssetClassProperty::GetMetaClass() const
{
	if (objAssetClassProperty.Empty())
		objAssetClassProperty = Object->Cast<UAssetClassProperty>();

	if (INVALID_POINTER_VALUE(objAssetClassProperty.MetaClass))
		return UEClass();

	return GetObjByAddress(objAssetClassProperty.MetaClass)->Cast<UEClass>();
	// return UEClass(metaClass);
}

UEProperty::Info UEAssetClassProperty::GetInfo() const
{
	return Info::Create(PropertyType::Primitive, sizeof(uint8_t), false, "");
}

int UEAssetClassProperty::TypeId()
{
	static int ret = NamesStore().GetByName("AssetClassProperty");
	return ret;
}

UEClass UEAssetClassProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".AssetClassProperty");
	return c;
}
#pragma endregion

#pragma region UENameProperty
UEProperty::Info UENameProperty::GetInfo() const
{
	return Info::Create(PropertyType::PredefinedStruct, sizeof(FName), true, "struct FName");
}

int UENameProperty::TypeId()
{
	static int ret = NamesStore().GetByName("NameProperty");
	return ret;
}

UEClass UENameProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".NameProperty");
	return c;
}
#pragma endregion

#pragma region UEStructProperty
UEScriptStruct UEStructProperty::GetStruct() const
{
	if (objStructProperty.Empty())
		objStructProperty = Object->Cast<UStructProperty>();

	if (INVALID_POINTER_VALUE(objStructProperty.Struct))
		return UEScriptStruct();

	return GetObjByAddress(objStructProperty.Struct)->Cast<UEScriptStruct>();
	// return UEScriptStruct(objStruct);
}

UEProperty::Info UEStructProperty::GetInfo() const
{
	return Info::Create(PropertyType::CustomStruct, GetElementSize(), true, "struct " + MakeUniqueCppName(GetStruct()));
}

int UEStructProperty::TypeId()
{
	static int ret = NamesStore().GetByName("StructProperty");
	return ret;
}

UEClass UEStructProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".StructProperty");
	return c;
}
#pragma endregion

#pragma region UEStrProperty
UEProperty::Info UEStrProperty::GetInfo() const
{
	return Info::Create(PropertyType::PredefinedStruct, sizeof(FString), true, "struct FString");
}

int UEStrProperty::TypeId()
{
	static int ret = NamesStore().GetByName("StrProperty");
	return ret;
}

UEClass UEStrProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".StrProperty");
	return c;
}
#pragma endregion

#pragma region UETextProperty
UEProperty::Info UETextProperty::GetInfo() const
{
	return Info::Create(PropertyType::PredefinedStruct, sizeof(FText), true, "struct FText");
}

int UETextProperty::TypeId()
{
	static int ret = NamesStore().GetByName("TextProperty");
	return ret;
}

UEClass UETextProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".TextProperty");
	return c;
}
#pragma endregion

#pragma region UEArrayProperty
UEProperty UEArrayProperty::GetInner() const
{
	if (objArrayProperty.Empty())
		objArrayProperty = Object->Cast<UArrayProperty>();

	if (INVALID_POINTER_VALUE(objArrayProperty.Inner))
		return UEProperty();

	return GetObjByAddress(objArrayProperty.Inner)->Cast<UEProperty>();
	// return UEProperty(inner);
}

UEProperty::Info UEArrayProperty::GetInfo() const
{
	auto inner = GetInner().GetInfo();
	if (inner.Type != PropertyType::Unknown)
	{
		extern IGenerator* generator;

		return Info::Create(PropertyType::Container, sizeof(TArray), false, "TArray<" + generator->GetOverrideType(inner.CppType) + ">");
	}

	return { PropertyType::Unknown };
}

int UEArrayProperty::TypeId()
{
	static int ret = NamesStore().GetByName("ArrayProperty");
	return ret;
}

UEClass UEArrayProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".ArrayProperty");
	return c;
}
#pragma endregion

#pragma region UEMapProperty
UEProperty UEMapProperty::GetKeyProperty() const
{
	if (objMapProperty.Empty())
		objMapProperty = Object->Cast<UMapProperty>();

	if (INVALID_POINTER_VALUE(objMapProperty.KeyProp))
		return UEProperty();

	return GetObjByAddress(objMapProperty.KeyProp)->Cast<UEProperty>();
	// return UEProperty(keyProp);
}

UEProperty UEMapProperty::GetValueProperty() const
{
	if (objMapProperty.Empty())
		objMapProperty = Object->Cast<UMapProperty>();

	if (INVALID_POINTER_VALUE(objMapProperty.ValueProp))
		return UEProperty();

	return GetObjByAddress(objMapProperty.ValueProp)->Cast<UEProperty>();
	// return UEProperty(valueProp);
}

UEProperty::Info UEMapProperty::GetInfo() const
{
	auto key = GetKeyProperty().GetInfo();
	auto value = GetValueProperty().GetInfo();
	if (key.Type != PropertyType::Unknown && value.Type != PropertyType::Unknown)
	{
		extern IGenerator* generator;

		return Info::Create(PropertyType::Container, 0x50, false, "TMap<" + generator->GetOverrideType(key.CppType) + ", " + generator->GetOverrideType(value.CppType) + ">");
	}

	return { PropertyType::Unknown };
}

int UEMapProperty::TypeId()
{
	static int ret = NamesStore().GetByName("MapProperty");
	return ret;
}

UEClass UEMapProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".MapProperty");
	return c;
}
#pragma endregion

#pragma region UEDelegateProperty
UEFunction UEDelegateProperty::GetSignatureFunction() const
{
	if (objDelegateProperty.Empty())
		objDelegateProperty = Object->Cast<UDelegateProperty>();

	if (INVALID_POINTER_VALUE(objDelegateProperty.SignatureFunction))
		return UEFunction();

	return GetObjByAddress(objDelegateProperty.SignatureFunction)->Cast<UEFunction>();
	// return UEFunction(signatureFunction);
}

UEProperty::Info UEDelegateProperty::GetInfo() const
{
	return Info::Create(PropertyType::PredefinedStruct, sizeof(FScriptDelegate), true, "struct FScriptDelegate");
}

int UEDelegateProperty::TypeId()
{
	static int ret = NamesStore().GetByName("DelegateProperty");
	return ret;
}

UEClass UEDelegateProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".DelegateProperty");
	return c;
}
#pragma endregion

#pragma region UEMulticastDelegateProperty
UEFunction UEMulticastDelegateProperty::GetSignatureFunction() const
{
	if (objDelegateProperty.Empty())
		objDelegateProperty = Object->Cast<UDelegateProperty>();

	if (INVALID_POINTER_VALUE(objDelegateProperty.SignatureFunction))
		return UEFunction();

	return GetObjByAddress(objDelegateProperty.SignatureFunction)->Cast<UEFunction>();
	// return UEFunction(signatureFunction);
}

UEProperty::Info UEMulticastDelegateProperty::GetInfo() const
{
	return Info::Create(PropertyType::PredefinedStruct, sizeof(FScriptMulticastDelegate), true, "struct FScriptMulticastDelegate");
}

int UEMulticastDelegateProperty::TypeId()
{
	static int ret = NamesStore().GetByName("MulticastDelegateProperty");
	return ret;
}

UEClass UEMulticastDelegateProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".MulticastDelegateProperty");
	return c;
}
#pragma endregion

#pragma region UEEnumProperty
UENumericProperty UEEnumProperty::GetUnderlyingProperty() const
{
	if (objEnumProperty.Empty())
		objEnumProperty = Object->Cast<UEnumProperty>();

	if (INVALID_POINTER_VALUE(objEnumProperty.UnderlyingProp))
		return UENumericProperty();

	return GetObjByAddress(objEnumProperty.UnderlyingProp)->Cast<UENumericProperty>();
	// return UENumericProperty(underlyingProp);
}

UEEnum UEEnumProperty::GetEnum() const
{
	if (objEnumProperty.Empty())
		objEnumProperty = Object->Cast<UEnumProperty>();

	if (INVALID_POINTER_VALUE(objEnumProperty.Enum))
		return UEEnum();

	return GetObjByAddress(objEnumProperty.Enum)->Cast<UEEnum>();
	// return UEEnum(Enum);
}

UEProperty::Info UEEnumProperty::GetInfo() const
{
	return Info::Create(PropertyType::Primitive, sizeof(uint8_t), false, MakeUniqueCppName(GetEnum()));
}

int UEEnumProperty::TypeId()
{
	static int ret = NamesStore().GetByName("EnumProperty");
	return ret;
}

UEClass UEEnumProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".EnumProperty");
	return c;
}
#pragma endregion

#pragma region UEByteProperty
bool UEByteProperty::IsEnum() const
{
	return GetEnum().IsValid();
}

UEEnum UEByteProperty::GetEnum() const
{
	if (objByteProperty.Empty())
		objByteProperty = Object->Cast<UByteProperty>();

	if (INVALID_POINTER_VALUE(objByteProperty.Enum))
		return UEEnum();

	return GetObjByAddress(objByteProperty.Enum)->Cast<UEEnum>();
	// return UEEnum(enumProperty);
}

UEProperty::Info UEByteProperty::GetInfo() const
{
	if (IsEnum())
	{
		return Info::Create(PropertyType::Primitive, sizeof(uint8_t), false, "TEnumAsByte<" + MakeUniqueCppName(GetEnum()) + ">");
	}
	return Info::Create(PropertyType::Primitive, sizeof(uint8_t), false, "unsigned char");
}

int UEByteProperty::TypeId()
{
	static int ret = NamesStore().GetByName("ByteProperty");
	return ret;
}

UEClass UEByteProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".ByteProperty");
	return c;
}
#pragma endregion

#pragma region UEBoolProperty
int GetBitPosition(uint8_t value)
{
	int i4 = !(value & 0xf) << 2;
	value >>= i4;

	int i2 = !(value & 0x3) << 1;
	value >>= i2;

	int i1 = !(value & 0x1);

	int i0 = (value >> i1) & 1 ? 0 : -8;

	return i4 + i2 + i1 + i0;
}

std::array<int, 2> UEBoolProperty::GetMissingBitsCount(const UEBoolProperty & other) const
{
	// If there is no previous bitfield member, just calculate the missing bits.
	if (!other.IsValid())
	{
		return { GetBitPosition(GetByteMask()), -1 };
	}

	// If both bitfield member belong to the same byte, calculate the bit position difference.
	if (GetOffset() == other.GetOffset())
	{
		return { GetBitPosition(GetByteMask()) - GetBitPosition(other.GetByteMask()) - 1, -1 };
	}

	// If they have different offsets, we need two distances
	// |00001000|00100000|
	// 1.   ^---^
	// 2.       ^--^

	return { std::numeric_limits<uint8_t>::digits - GetBitPosition(other.GetByteMask()) - 1, GetBitPosition(GetByteMask()) };
}

uint8_t UEBoolProperty::GetFieldSize() const
{
	if (objBoolProperty.Empty())
		objBoolProperty = Object->Cast<UBoolProperty>();

	return objBoolProperty.FieldSize;
}

uint8_t UEBoolProperty::GetByteOffset() const
{
	if (objBoolProperty.Empty())
		objBoolProperty = Object->Cast<UBoolProperty>();

	return objBoolProperty.ByteOffset;
}

uint8_t UEBoolProperty::GetByteMask() const
{
	if (objBoolProperty.Empty())
		objBoolProperty = Object->Cast<UBoolProperty>();

	return objBoolProperty.ByteMask;
}

uint8_t UEBoolProperty::GetFieldMask() const
{
	if (objBoolProperty.Empty())
		objBoolProperty = Object->Cast<UBoolProperty>();

	return objBoolProperty.FieldMask;
}

UEProperty::Info UEBoolProperty::GetInfo() const
{
	if (IsNativeBool())
	{
		return Info::Create(PropertyType::Primitive, sizeof(bool), false, "bool");
	}
	return Info::Create(PropertyType::Primitive, sizeof(unsigned char), false, "unsigned char");
}

int UEBoolProperty::TypeId()
{
	static int ret = NamesStore().GetByName("BoolProperty");
	return ret;
}

UEClass UEBoolProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".BoolProperty");
	return c;
}
#pragma endregion
```

`UnrealFinderTool/SdkGen/Engine/UE4/GenericTypes.h`:

```h
#pragma once
#include <string>
#include <vector>
#include <array>

#include "PropertyFlags.h"
#include "FunctionFlags.h"
#include "IGenerator.h"
#include "EngineClasses.h"

class UEClass;
inline UObject UObjectEmpty; // IsValid Will Return False for it

class UEObject
{
protected:
	mutable UClass objClass;
	mutable UEObject* outer = nullptr;
	mutable UEObject* package = nullptr;
	mutable std::string objName, fullName, nameCpp;

public:
	UObject* Object;

	UEObject() : Object(&UObjectEmpty) {}
	explicit UEObject(UObject* object) : Object(object) {}

	uintptr_t GetAddress() const;
	bool IsValid() const;
	size_t GetIndex() const;

	std::string GetName() const;
	std::string GetInstanceClassName() const;
	std::string GetFullName() const;
	std::string GetNameCpp() const;

	UEClass GetClass() const;
	UEObject* GetOuter() const;
	UEObject* GetPackageObject() const;

	template<typename Base>
	Base Cast() const
	{
		Base tmp;
		// Make Compiler think tmp is `UEObject`
		// Then call copy assignment
		// That's to keep copy size as `UEObject`. (either that's will case a memory problem)
		static_cast<typename std::decay<decltype(*this)>::type&>(tmp) = *this;
		return tmp;
		// return Base(Object);
	}

	template<typename T>
	bool IsA() const;

	// Check type in target process (Remote check type)
	bool IsA(const std::string& typeName) const;

	static int TypeId();
	static UEObject* GetObjByAddress(uintptr_t address);
	static UEClass StaticClass();
};

namespace std
{
	template<>
	struct hash<UEObject>
	{
		size_t operator()(const UEObject& obj) const noexcept
		{
			return std::hash<uintptr_t>()(obj.GetAddress());
		}
	};
}

inline UEObject UEObjectEmpty; // IsValid Will Return False for it
inline bool operator==(const UEObject& lhs, const UEObject& rhs) { return rhs.GetAddress() == lhs.GetAddress(); }
inline bool operator!=(const UEObject& lhs, const UEObject& rhs) { return !(lhs.GetAddress() == rhs.GetAddress()); }

class UEField : public UEObject
{
	mutable UField objField;

public:
	using UEObject::UEObject;

	UEField GetNext() const;

	static int TypeId();

	static UEClass StaticClass();
};

class UEEnum : public UEField
{
	mutable UEnum objEnum;

public:
	using UEField::UEField;

	std::vector<std::string> GetNames() const;

	static int TypeId();

	static UEClass StaticClass();
};

class UEConst : public UEField
{
public:
	using UEField::UEField;

	std::string GetValue() const;

	static int TypeId();

	static UEClass StaticClass();
};

class UEStruct : public UEField
{
	mutable UStruct objStruct;

public:
	using UEField::UEField;

	UEStruct GetSuper() const;

	UEField GetChildren() const;

	size_t GetPropertySize() const;

	static int TypeId();

	static UEClass StaticClass();
};

class UEScriptStruct : public UEStruct
{
public:
	using UEStruct::UEStruct;

	static int TypeId();

	static UEClass StaticClass();
};

class UEFunction : public UEStruct
{
	mutable UFunction objFunction;

public:
	using UEStruct::UEStruct;

	UEFunctionFlags GetFunctionFlags() const;

	static int TypeId();

	static UEClass StaticClass();
};

class UEClass : public UEStruct
{
public:
	using UEStruct::UEStruct;

	static int TypeId();

	static UEClass StaticClass();
};

class UEProperty : public UEField
{
public:
	enum class PropertyType
	{
		Unknown,
		Primitive,
		PredefinedStruct,
		CustomStruct,
		Container
	};

	struct Info
	{
		PropertyType Type = PropertyType::Unknown;
		size_t Size = 0;
		bool CanBeReference;
		std::string CppType = "";

		static Info Create(PropertyType type, size_t size, bool reference, std::string&& cppType)
		{
			extern IGenerator* generator;

			return { type, size, reference, generator->GetOverrideType(cppType) };
		}
	};

private:
	mutable UProperty objProperty;
	mutable bool infoChanged = false;
	mutable Info curInfo;

public:
	using UEField::UEField;

	size_t GetArrayDim() const;

	size_t GetElementSize() const;

	UEPropertyFlags GetPropertyFlags() const;

	size_t GetOffset() const;

	Info GetInfo() const;

	static int TypeId();

	static UEClass StaticClass();
};

class UENumericProperty : public UEProperty
{
public:
	using UEProperty::UEProperty;

	static int TypeId();

	static UEClass StaticClass();
};

class UEByteProperty : public UENumericProperty
{
	mutable UByteProperty objByteProperty;

public:
	using UENumericProperty::UENumericProperty;

	bool IsEnum() const;

	UEEnum GetEnum() const;

	UEProperty::Info GetInfo() const;

	static int TypeId();

	static UEClass StaticClass();
};

class UEUInt16Property : public UENumericProperty
{
public:
	using UENumericProperty::UENumericProperty;

	UEProperty::Info GetInfo() const;

	static int TypeId();

	static UEClass StaticClass();
};

class UEUInt32Property : public UENumericProperty
{
public:
	using UENumericProperty::UENumericProperty;

	UEProperty::Info GetInfo() const;

	static int TypeId();

	static UEClass StaticClass();
};

class UEUInt64Property : public UENumericProperty
{
public:
	using UENumericProperty::UENumericProperty;

	UEProperty::Info GetInfo() const;

	static int TypeId();

	static UEClass StaticClass();
};

class UEInt8Property : public UENumericProperty
{
public:
	using UENumericProperty::UENumericProperty;

	UEProperty::Info GetInfo() const;

	static int TypeId();

	static UEClass StaticClass();
};

class UEInt16Property : public UENumericProperty
{
public:
	using UENumericProperty::UENumericProperty;

	UEProperty::Info GetInfo() const;

	static int TypeId();

	static UEClass StaticClass();
};

class UEIntProperty : public UENumericProperty
{
public:
	using UENumericProperty::UENumericProperty;

	UEProperty::Info GetInfo() const;

	static int TypeId();

	static UEClass StaticClass();
};

class UEInt64Property : public UENumericProperty
{
public:
	using UENumericProperty::UENumericProperty;

	UEProperty::Info GetInfo() const;

	static int TypeId();

	static UEClass StaticClass();
};

class UEFloatProperty : public UENumericProperty
{
public:
	using UENumericProperty::UENumericProperty;

	static int TypeId();

	UEProperty::Info GetInfo() const;

	static UEClass StaticClass();
};

class UEDoubleProperty : public UENumericProperty
{
public:
	using UENumericProperty::UENumericProperty;

	UEProperty::Info GetInfo() const;

	static int TypeId();

	static UEClass StaticClass();
};

class UEBoolProperty : public UEProperty
{
	mutable UBoolProperty objBoolProperty;

public:
	using UEProperty::UEProperty;

	bool IsNativeBool() const { return GetFieldMask() == 0xFF; }

	bool IsBitfield() const { return !IsNativeBool(); }

	uint8_t GetFieldSize() const;

	uint8_t GetByteOffset() const;

	uint8_t GetByteMask() const;

	uint8_t GetFieldMask() const;

	std::array<int, 2> GetMissingBitsCount(const UEBoolProperty & other) const;

	UEProperty::Info GetInfo() const;

	static int TypeId();

	static UEClass StaticClass();
};

inline bool operator<(const UEBoolProperty& lhs, const UEBoolProperty& rhs)
{
	if (lhs.GetByteOffset() == rhs.GetByteOffset())
	{
		return lhs.GetByteMask() < rhs.GetByteMask();
	}
	return lhs.GetByteOffset() < rhs.GetByteOffset();
}

class UEObjectPropertyBase : public UEProperty
{
	mutable UObjectPropertyBase objObjectPropertyBase;

public:
	using UEProperty::UEProperty;

	UEClass GetPropertyClass() const;

	static int TypeId();

	static UEClass StaticClass();
};

class UEObjectProperty : public UEObjectPropertyBase
{
public:
	using UEObjectPropertyBase::UEObjectPropertyBase;

	UEProperty::Info GetInfo() const;

	static int TypeId();

	static UEClass StaticClass();
};

class UEClassProperty : public UEObjectProperty
{
	mutable UClassProperty objClassProperty;

public:
	using UEObjectProperty::UEObjectProperty;

	UEClass GetMetaClass() const;

	UEProperty::Info GetInfo() const;

	static int TypeId();

	static UEClass StaticClass();
};

class UEInterfaceProperty : public UEProperty
{
	mutable UInterfaceProperty objInterfaceProperty;

public:
	using UEProperty::UEProperty;

	UEClass GetInterfaceClass() const;

	UEProperty::Info GetInfo() const;

	static int TypeId();

	static UEClass StaticClass();
};

class UEWeakObjectProperty : public UEObjectPropertyBase
{
public:
	using UEObjectPropertyBase::UEObjectPropertyBase;

	UEProperty::Info GetInfo() const;

	static int TypeId();

	static UEClass StaticClass();
};

class UELazyObjectProperty : public UEObjectPropertyBase
{
public:
	using UEObjectPropertyBase::UEObjectPropertyBase;

	UEProperty::Info GetInfo() const;

	static int TypeId();

	static UEClass StaticClass();
};

class UEAssetObjectProperty : public UEObjectPropertyBase
{
public:
	using UEObjectPropertyBase::UEObjectPropertyBase;

	UEProperty::Info GetInfo() const;

	static int TypeId();

	static UEClass StaticClass();
};

class UEAssetClassProperty : public UEAssetObjectProperty
{
	mutable UAssetClassProperty objAssetClassProperty;

public:
	using UEAssetObjectProperty::UEAssetObjectProperty;

	UEClass GetMetaClass() const;

	UEProperty::Info GetInfo() const;

	static int TypeId();

	static UEClass StaticClass();
};

class UENameProperty : public UEProperty
{
public:
	using UEProperty::UEProperty;

	UEProperty::Info GetInfo() const;

	static int TypeId();

	static UEClass StaticClass();
};

class UEStructProperty : public UEProperty
{
	mutable UStructProperty objStructProperty;

public:
	using UEProperty::UEProperty;

	UEScriptStruct GetStruct() const;

	UEProperty::Info GetInfo() const;

	static int TypeId();

	static UEClass StaticClass();
};

class UEStrProperty : public UEProperty
{
public:
	using UEProperty::UEProperty;

	UEProperty::Info GetInfo() const;

	static int TypeId();

	static UEClass StaticClass();
};

class UETextProperty : public UEProperty
{
public:
	using UEProperty::UEProperty;

	UEProperty::Info GetInfo() const;

	static int TypeId();

	static UEClass StaticClass();
};

class UEArrayProperty : public UEProperty
{
	mutable UArrayProperty objArrayProperty;

public:
	using UEProperty::UEProperty;

	UEProperty GetInner() const;

	UEProperty::Info GetInfo() const;

	static int TypeId();

	static UEClass StaticClass();
};

class UEMapProperty : public UEProperty
{
	mutable UMapProperty objMapProperty;

public:
	using UEProperty::UEProperty;

	UEProperty GetKeyProperty() const;
	UEProperty GetValueProperty() const;

	UEProperty::Info GetInfo() const;

	static int TypeId();

	static UEClass StaticClass();
};

class UEDelegateProperty : public UEProperty
{
	mutable UDelegateProperty objDelegateProperty;

public:
	using UEProperty::UEProperty;

	UEFunction GetSignatureFunction() const;

	UEProperty::Info GetInfo() const;

	static int TypeId();

	static UEClass StaticClass();
};

class UEMulticastDelegateProperty : public UEProperty
{
	mutable UDelegateProperty objDelegateProperty;

public:
	using UEProperty::UEProperty;

	UEFunction GetSignatureFunction() const;

	UEProperty::Info GetInfo() const;

	static int TypeId();

	static UEClass StaticClass();
};

class UEEnumProperty : public UEProperty
{
	mutable UEnumProperty objEnumProperty;

public:
	using UEProperty::UEProperty;

	UENumericProperty GetUnderlyingProperty() const;
	UEEnum GetEnum() const;

	UEProperty::Info GetInfo() const;

	static int TypeId();

	static UEClass StaticClass();
};

template<typename T>
bool UEObject::IsA() const
{
	if (!IsValid()) return false;

	int cmpTypeId = T::TypeId();
	for (UEClass super = GetClass(); super.IsValid(); super = super.GetSuper().Cast<UEClass>())
	{
		if (super.Object->Name.ComparisonIndex == cmpTypeId)
			return true;
	}
	return false;
}
```

`UnrealFinderTool/SdkGen/Engine/UE4/PackageCore.cpp`:

```cpp
#include "pch.h"
#include "../Package.h"

bool Package::Method::Parameter::MakeType(UEPropertyFlags flags, Type& type)
{
	if (flags & UEPropertyFlags::ReturnParm)
	{
		type = Type::Return;
	}
	else if (flags & UEPropertyFlags::OutParm)
	{
		//if it is a const parameter make it a default parameter
		if (flags & UEPropertyFlags::ConstParm)
		{
			type = Type::Default;
		}
		else
		{
			type = Type::Out;
		}
	}
	else if (flags & UEPropertyFlags::Parm)
	{
		type = Type::Default;
	}
	else
	{
		return false;
	}

	return true;
}
```

`UnrealFinderTool/SdkGen/Engine/UE4/PropertyFlags.cpp`:

```cpp
#include "pch.h"
#include "PropertyFlags.h"

#include <vector>
#include <sstream>
#include <iterator>

std::string StringifyFlags(const UEPropertyFlags flags)
{
	std::vector<const char*> buffer;

	if (flags & UEPropertyFlags::Edit) { buffer.push_back("Edit"); }
	if (flags & UEPropertyFlags::ConstParm) { buffer.push_back("ConstParm"); }
	if (flags & UEPropertyFlags::BlueprintVisible) { buffer.push_back("BlueprintVisible"); }
	if (flags & UEPropertyFlags::ExportObject) { buffer.push_back("ExportObject"); }
	if (flags & UEPropertyFlags::BlueprintReadOnly) { buffer.push_back("BlueprintReadOnly"); }
	if (flags & UEPropertyFlags::Net) { buffer.push_back("Net"); }
	if (flags & UEPropertyFlags::EditFixedSize) { buffer.push_back("EditFixedSize"); }
	if (flags & UEPropertyFlags::Parm) { buffer.push_back("Parm"); }
	if (flags & UEPropertyFlags::OutParm) { buffer.push_back("OutParm"); }
	if (flags & UEPropertyFlags::ZeroConstructor) { buffer.push_back("ZeroConstructor"); }
	if (flags & UEPropertyFlags::ReturnParm) { buffer.push_back("ReturnParm"); }
	if (flags & UEPropertyFlags::DisableEditOnTemplate) { buffer.push_back("DisableEditOnTemplate"); }
	if (flags & UEPropertyFlags::Transient) { buffer.push_back("Transient"); }
	if (flags & UEPropertyFlags::Config) { buffer.push_back("Config"); }
	if (flags & UEPropertyFlags::DisableEditOnInstance) { buffer.push_back("DisableEditOnInstance"); }
	if (flags & UEPropertyFlags::EditConst) { buffer.push_back("EditConst"); }
	if (flags & UEPropertyFlags::GlobalConfig) { buffer.push_back("GlobalConfig"); }
	if (flags & UEPropertyFlags::InstancedReference) { buffer.push_back("InstancedReference"); }
	if (flags & UEPropertyFlags::DuplicateTransient) { buffer.push_back("DuplicateTransient"); }
	if (flags & UEPropertyFlags::SubobjectReference) { buffer.push_back("SubobjectReference"); }
	if (flags & UEPropertyFlags::SaveGame) { buffer.push_back("SaveGame"); }
	if (flags & UEPropertyFlags::NoClear) { buffer.push_back("NoClear"); }
	if (flags & UEPropertyFlags::ReferenceParm) { buffer.push_back("ReferenceParm"); }
	if (flags & UEPropertyFlags::BlueprintAssignable) { buffer.push_back("BlueprintAssignable"); }
	if (flags & UEPropertyFlags::Deprecated) { buffer.push_back("Deprecated"); }
	if (flags & UEPropertyFlags::IsPlainOldData) { buffer.push_back("IsPlainOldData"); }
	if (flags & UEPropertyFlags::RepSkip) { buffer.push_back("RepSkip"); }
	if (flags & UEPropertyFlags::RepNotify) { buffer.push_back("RepNotify"); }
	if (flags & UEPropertyFlags::Interp) { buffer.push_back("Interp"); }
	if (flags & UEPropertyFlags::NonTransactional) { buffer.push_back("NonTransactional"); }
	if (flags & UEPropertyFlags::EditorOnly) { buffer.push_back("EditorOnly"); }
	if (flags & UEPropertyFlags::NoDestructor) { buffer.push_back("NoDestructor"); }
	if (flags & UEPropertyFlags::AutoWeak) { buffer.push_back("AutoWeak"); }
	if (flags & UEPropertyFlags::ContainsInstancedReference) { buffer.push_back("ContainsInstancedReference"); }
	if (flags & UEPropertyFlags::AssetRegistrySearchable) { buffer.push_back("AssetRegistrySearchable"); }
	if (flags & UEPropertyFlags::SimpleDisplay) { buffer.push_back("SimpleDisplay"); }
	if (flags & UEPropertyFlags::AdvancedDisplay) { buffer.push_back("AdvancedDisplay"); }
	if (flags & UEPropertyFlags::Protected) { buffer.push_back("Protected"); }
	if (flags & UEPropertyFlags::BlueprintCallable) { buffer.push_back("BlueprintCallable"); }
	if (flags & UEPropertyFlags::BlueprintAuthorityOnly) { buffer.push_back("BlueprintAuthorityOnly"); }
	if (flags & UEPropertyFlags::TextExportTransient) { buffer.push_back("TextExportTransient"); }
	if (flags & UEPropertyFlags::NonPIEDuplicateTransient) { buffer.push_back("NonPIEDuplicateTransient"); }
	if (flags & UEPropertyFlags::ExposeOnSpawn) { buffer.push_back("ExposeOnSpawn"); }
	if (flags & UEPropertyFlags::PersistentInstance) { buffer.push_back("PersistentInstance"); }
	if (flags & UEPropertyFlags::UObjectWrapper) { buffer.push_back("UObjectWrapper"); }
	if (flags & UEPropertyFlags::HasGetValueTypeHash) { buffer.push_back("HasGetValueTypeHash"); }
	if (flags & UEPropertyFlags::NativeAccessSpecifierPublic) { buffer.push_back("NativeAccessSpecifierPublic"); }
	if (flags & UEPropertyFlags::NativeAccessSpecifierProtected) { buffer.push_back("NativeAccessSpecifierProtected"); }
	if (flags & UEPropertyFlags::NativeAccessSpecifierPrivate) { buffer.push_back("NativeAccessSpecifierPrivate"); }

	switch (buffer.size())
	{
		case 0:
			return std::string();
		case 1:
			return std::string(buffer[0]);
		default:
			std::ostringstream os;
			std::copy(buffer.begin(), buffer.end() - 1, std::ostream_iterator<const char*>(os, ", "));
			os << *buffer.rbegin();
			return os.str();
	}
}
```

`UnrealFinderTool/SdkGen/Engine/UE4/PropertyFlags.h`:

```h
#pragma once

#include <type_traits>
#include <string>

enum class UEPropertyFlags : uint64_t
{
	Edit = 0x0000000000000001,
	ConstParm = 0x0000000000000002,
	BlueprintVisible = 0x0000000000000004,
	ExportObject = 0x0000000000000008,
	BlueprintReadOnly = 0x0000000000000010,
	Net = 0x0000000000000020,
	EditFixedSize = 0x0000000000000040,
	Parm = 0x0000000000000080,
	OutParm = 0x0000000000000100,
	ZeroConstructor = 0x0000000000000200,
	ReturnParm = 0x0000000000000400,
	DisableEditOnTemplate = 0x0000000000000800,
	Transient = 0x0000000000002000,
	Config = 0x0000000000004000,
	DisableEditOnInstance = 0x0000000000010000,
	EditConst = 0x0000000000020000,
	GlobalConfig = 0x0000000000040000,
	InstancedReference = 0x0000000000080000,
	DuplicateTransient = 0x0000000000200000,
	SubobjectReference = 0x0000000000400000,
	SaveGame = 0x0000000001000000,
	NoClear = 0x0000000002000000,
	ReferenceParm = 0x0000000008000000,
	BlueprintAssignable = 0x0000000010000000,
	Deprecated   = 0x0000000020000000,
	IsPlainOldData = 0x0000000040000000,
	RepSkip = 0x0000000080000000,
	RepNotify = 0x0000000100000000,
	Interp = 0x0000000200000000,
	NonTransactional = 0x0000000400000000,
	EditorOnly = 0x0000000800000000,
	NoDestructor = 0x0000001000000000,
	AutoWeak = 0x0000004000000000,
	ContainsInstancedReference = 0x0000008000000000,
	AssetRegistrySearchable = 0x0000010000000000,
	SimpleDisplay = 0x0000020000000000,
	AdvancedDisplay = 0x0000040000000000,
	Protected = 0x0000080000000000,
	BlueprintCallable = 0x0000100000000000,
	BlueprintAuthorityOnly = 0x0000200000000000,
	TextExportTransient = 0x0000400000000000,
	NonPIEDuplicateTransient = 0x0000800000000000,
	ExposeOnSpawn = 0x0001000000000000,
	PersistentInstance = 0x0002000000000000,
	UObjectWrapper = 0x0004000000000000,
	HasGetValueTypeHash = 0x0008000000000000,
	NativeAccessSpecifierPublic = 0x0010000000000000,
	NativeAccessSpecifierProtected = 0x0020000000000000,
	NativeAccessSpecifierPrivate = 0x0040000000000000
};

inline bool operator&(UEPropertyFlags lhs, UEPropertyFlags rhs)
{
	return (static_cast<std::underlying_type_t<UEPropertyFlags>>(lhs) & static_cast<std::underlying_type_t<UEPropertyFlags>>(rhs)) == static_cast<std::underlying_type_t<UEPropertyFlags>>(rhs);
}

std::string StringifyFlags(const UEPropertyFlags flags);
```

`UnrealFinderTool/SdkGen/Engine/cpplinq.hpp`:

```hpp
// ----------------------------------------------------------------------------------------------
// Copyright (c) Mårten Rånge.
// ----------------------------------------------------------------------------------------------
// This source code is subject to terms and conditions of the Microsoft Public License. A
// copy of the license can be found in the License.html file at the root of this distribution.
// If you cannot locate the Microsoft Public License, please send an email to
// dlr@microsoft.com. By using this source code in any fashion, you are agreeing to be bound
// by the terms of the Microsoft Public License.
// ----------------------------------------------------------------------------------------------
// You must not remove this notice, or any other, from this software.
// ----------------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------
#ifndef CPPLINQ__HEADER_GUARD
#   define CPPLINQ__HEADER_GUARD
// ----------------------------------------------------------------------------
#include <algorithm>
#include <cassert>
#include <climits>
#include <exception>
#include <functional>
#include <iterator>
#include <list>
#include <map>
#include <numeric>
#include <set>
#include <string>
#include <type_traits>
#include <vector>
#include <deque>
#include <unordered_set>
#// ----------------------------------------------------------------------------
#ifdef _MSC_VER
#   pragma warning (push)
#       pragma warning (disable:4512)   // 'class' : assignment operator could not be generated
// Rationale: cpplinq doesn't rely on assignment operators
#       pragma warning (disable:4702)   // unreachable code
// Rationale: Depending on the predicates and the calling
// code the compiler might detect unreacable code that with
// other predicates are reachable.
#endif
// ----------------------------------------------------------------------------
#ifndef CPPLINQ_ASSERT
#   define CPPLINQ_ASSERT(expr) assert(expr)
#endif
#ifndef CPPLINQ_METHOD
#   define CPPLINQ_METHOD
#endif
#ifndef CPPLINQ_INLINEMETHOD
#   define CPPLINQ_INLINEMETHOD inline
#endif
#ifndef CPPLINQ_NOEXCEPT
#   define CPPLINQ_NOEXCEPT noexcept
#endif
// ----------------------------------------------------------------------------

// TODO:    Struggled with getting slice protection
//          and assignment operator detection for MINGW
//          Look into using delete standard functions
// #define CPPLINQ_DETECT_INVALID_METHODS

// ----------------------------------------------------------------------------
namespace cpplinq
{
	typedef std::size_t size_type;

	// -------------------------------------------------------------------------

	struct base_exception : std::exception
	{
		virtual const char* what() const CPPLINQ_NOEXCEPT
		{
			return "base_exception";
		}
	};

	struct programming_error_exception : base_exception
	{
		virtual const char* what() const CPPLINQ_NOEXCEPT
		{
			return "programming_error_exception";
		}
	};

	struct sequence_empty_exception : base_exception
	{
		virtual const char* what() const CPPLINQ_NOEXCEPT
		{
			return "sequence_empty_exception";
		}
	};

	struct out_of_range_exception : base_exception
	{
		virtual const char* what() const CPPLINQ_NOEXCEPT
		{
			return "out_of_range_exception";
		}
	};

	// -------------------------------------------------------------------------
	// Tedious implementation details of cpplinq
	// -------------------------------------------------------------------------

	namespace detail
	{
		size_type const invalid_size = static_cast<size_type>(-1);

		// -------------------------------------------------------------------------

		template<typename TValue>
		struct cleanup_type
		{
			typedef typename std::remove_const<typename std::remove_reference<TValue>::type>::type type;
		};

		template<typename TRangeBuilder, typename TRange>
		struct get_builtup_type
		{
			static TRangeBuilder get_builder();
			static TRange get_range();

			typedef decltype (get_builder().build(get_range())) type;
		};

		template<typename TPredicate, typename TValue>
		struct get_transformed_type
		{
			static TValue get_value();
			static TPredicate get_predicate();

			typedef decltype (get_predicate()(get_value())) raw_type;
			typedef typename cleanup_type<raw_type>::type type;
		};

		template<typename TArray>
		struct get_array_properties;

		template<typename TValue, int Size>
		struct get_array_properties<TValue[Size]>
		{
			enum
			{
				size = Size,
			};

			typedef typename cleanup_type<TValue>::type value_type;
			typedef value_type const* iterator_type;
		};

		template<typename TValue>
		struct opt
		{
			typedef TValue value_type;

			CPPLINQ_INLINEMETHOD opt() CPPLINQ_NOEXCEPT
				: is_initialized(false)
			{
			}

			CPPLINQ_INLINEMETHOD explicit opt(value_type&& value)
				: is_initialized(true)
			{
				new (&storage) value_type(std::move(value));
			}

			CPPLINQ_INLINEMETHOD explicit opt(value_type const& value)
				: is_initialized(true)
			{
				new (&storage) value_type(value);
			}

			CPPLINQ_INLINEMETHOD ~opt() CPPLINQ_NOEXCEPT
			{
				auto ptr = get_ptr();
				if (ptr)
				{
					ptr->~value_type();
				}
				is_initialized = false;
			}

			CPPLINQ_INLINEMETHOD opt(opt const& v)
				: is_initialized(v.is_initialized)
			{
				if (v.is_initialized)
				{
					copy(&storage, &v.storage);
				}
			}

			CPPLINQ_INLINEMETHOD opt(opt&& v) CPPLINQ_NOEXCEPT
				: is_initialized(v.is_initialized)
			{
				if (v.is_initialized)
				{
					move(&storage, &v.storage);
				}
				v.is_initialized = false;
			}

			CPPLINQ_METHOD void swap(opt& v)
			{
				if (is_initialized && v.is_initialized)
				{
					storage_type tmp;

					move(&tmp, &storage);
					move(&storage, &v.storage);
					move(&v.storage, &tmp);
				}
				else if (is_initialized)
				{
					move(&v.storage, &storage);
					v.is_initialized = true;
					is_initialized = false;
				}
				else if (v.is_initialized)
				{
					move(&storage, &v.storage);
					v.is_initialized = false;
					is_initialized = true;
				}
				else
				{
					// Do nothing
				}
			}

			CPPLINQ_INLINEMETHOD opt& operator=(opt const& v)
			{
				if (this == std::addressof(v))
				{
					return *this;
				}

				opt<value_type> o(v);

				swap(o);

				return *this;
			}

			CPPLINQ_INLINEMETHOD opt& operator=(opt&& v)
			{
				if (this == std::addressof(v))
				{
					return *this;
				}

				swap(v);

				return *this;
			}

			CPPLINQ_INLINEMETHOD opt& operator=(value_type v)
			{
				return *this = opt(std::move(v));
			}

			CPPLINQ_INLINEMETHOD void clear() CPPLINQ_NOEXCEPT
			{
				opt empty;
				swap(empty);
			}

			CPPLINQ_INLINEMETHOD value_type const* get_ptr() const CPPLINQ_NOEXCEPT
			{
				if (is_initialized)
				{
					return reinterpret_cast<value_type const*> (&storage);
				}
				else
				{
					return nullptr;
				}
			}

			CPPLINQ_INLINEMETHOD value_type* get_ptr() CPPLINQ_NOEXCEPT
			{
				if (is_initialized)
				{
					return reinterpret_cast<value_type*> (&storage);
				}
				else
				{
					return nullptr;
				}
			}

			CPPLINQ_INLINEMETHOD value_type const& get() const CPPLINQ_NOEXCEPT
			{
				CPPLINQ_ASSERT(is_initialized);

				return *get_ptr();
			}

			CPPLINQ_INLINEMETHOD value_type& get() CPPLINQ_NOEXCEPT
			{
				CPPLINQ_ASSERT(is_initialized);

				return *get_ptr();
			}

			CPPLINQ_INLINEMETHOD bool has_value() const CPPLINQ_NOEXCEPT
			{
				return is_initialized;
			}

			// TODO: To be replaced with explicit operator bool ()
			typedef bool (opt::* type_safe_bool_type) () const;

			CPPLINQ_INLINEMETHOD operator type_safe_bool_type() const CPPLINQ_NOEXCEPT
			{
				return is_initialized ? &opt::has_value : nullptr;
			}

			CPPLINQ_INLINEMETHOD value_type const& operator*() const CPPLINQ_NOEXCEPT
			{
				return get();
			}

			CPPLINQ_INLINEMETHOD value_type& operator*() CPPLINQ_NOEXCEPT
			{
				return get();
			}

			CPPLINQ_INLINEMETHOD value_type const* operator->() const CPPLINQ_NOEXCEPT
			{
				return get_ptr();
			}

			CPPLINQ_INLINEMETHOD value_type* operator->() CPPLINQ_NOEXCEPT
			{
				return get_ptr();
			}

		private:
			typedef typename std::aligned_storage<sizeof(value_type), std::alignment_of<value_type>::value>::type storage_type;

			storage_type storage;
			bool is_initialized;

			CPPLINQ_INLINEMETHOD static void move(storage_type* to, storage_type* from) CPPLINQ_NOEXCEPT
			{
				auto f = reinterpret_cast<value_type*> (from);
				new (to) value_type(std::move(*f));
				f->~value_type();
			}

			CPPLINQ_INLINEMETHOD static void copy(storage_type* to, storage_type const* from)
			{
				auto f = reinterpret_cast<value_type const*> (from);
				new (to) value_type(*f);
			}
		};

		// -------------------------------------------------------------------------
		// The generic interface
		// -------------------------------------------------------------------------
		// _range classes:
		//      inherit base_range
		//      COPYABLE
		//      MOVEABLE (movesemantics)
		//      typedef                 ...         this_type       ;
		//      typedef                 ...         value_type      ;
		//      typedef                 ...         return_type     ;   // value_type | value_type const &
		//      enum { returns_reference = 0|1 };
		//      return_type front () const
		//      bool next ()
		//      template<typename TRangeBuilder>
		//      typename get_builtup_type<TRangeBuilder, this_type>::type operator>>(TRangeBuilder range_builder) const
		// -------------------------------------------------------------------------
		// _builder classes:
		//      inherit base_builder
		//      COPYABLE
		//      MOVEABLE (movesemantics)
		//      typedef                 ...         this_type       ;
		//      template<typename TRange>
		//      TAggregated build (TRange range) const
		// -------------------------------------------------------------------------

		struct base_range
		{
#ifdef CPPLINQ_DETECT_INVALID_METHODS
		protected:
			// In order to prevent object slicing

			CPPLINQ_INLINEMETHOD base_range() CPPLINQ_NOEXCEPT
			{
			}

			CPPLINQ_INLINEMETHOD base_range(base_range const&) CPPLINQ_NOEXCEPT
			{
			}

			CPPLINQ_INLINEMETHOD base_range(base_range&&) CPPLINQ_NOEXCEPT
			{
			}

			CPPLINQ_INLINEMETHOD ~base_range() CPPLINQ_NOEXCEPT
			{
			}

		private:
			CPPLINQ_INLINEMETHOD base_range& operator= (base_range const&);
			CPPLINQ_INLINEMETHOD base_range& operator= (base_range&&);
#endif
		};

		struct base_builder
		{
#ifdef CPPLINQ_DETECT_INVALID_METHODS
		protected:
			// In order to prevent object slicing

			CPPLINQ_INLINEMETHOD base_builder() CPPLINQ_NOEXCEPT
			{
			}

			CPPLINQ_INLINEMETHOD base_builder(base_builder const&) CPPLINQ_NOEXCEPT
			{
			}

			CPPLINQ_INLINEMETHOD base_builder(base_builder&&) CPPLINQ_NOEXCEPT
			{
			}

			CPPLINQ_INLINEMETHOD ~base_builder() CPPLINQ_NOEXCEPT
			{
			}

		private:
			CPPLINQ_INLINEMETHOD base_builder& operator= (base_builder const&);
			CPPLINQ_INLINEMETHOD base_builder& operator= (base_builder&&);
#endif
		};

		template<typename TValueIterator>
		struct from_range : base_range
		{
			static TValueIterator get_iterator();

			typedef from_range<TValueIterator> this_type;
			typedef TValueIterator iterator_type;

			typedef decltype (*get_iterator()) raw_value_type;
			typedef typename cleanup_type<raw_value_type>::type value_type;
			typedef value_type const& return_type;
			enum
			{
				returns_reference = 1,
			};

			iterator_type current;
			iterator_type upcoming;
			iterator_type end;


			CPPLINQ_INLINEMETHOD from_range(iterator_type begin, iterator_type end) CPPLINQ_NOEXCEPT
				: current(std::move(begin)),
				upcoming(current),
				end(std::move(end))
			{
			}

			CPPLINQ_INLINEMETHOD from_range(from_range const& v) CPPLINQ_NOEXCEPT
				: current(v.current),
				upcoming(v.upcoming),
				end(v.end)
			{
			}

			CPPLINQ_INLINEMETHOD from_range(from_range&& v) CPPLINQ_NOEXCEPT
				: current(std::move(v.current)),
				upcoming(std::move(v.upcoming)),
				end(std::move(v.end))
			{
			}

			template<typename TRangeBuilder>
			CPPLINQ_INLINEMETHOD auto operator>>(TRangeBuilder range_builder) const
			{
				return range_builder.build(*this);
			}

			CPPLINQ_INLINEMETHOD auto front() const
			{
				CPPLINQ_ASSERT(current != upcoming);
				CPPLINQ_ASSERT(current != end);

				return *current;
			}

			CPPLINQ_INLINEMETHOD auto next() CPPLINQ_NOEXCEPT
			{
				if (upcoming == end)
				{
					return false;
				}

				current = upcoming;

				++upcoming;

				return true;
			}
		};

		// -------------------------------------------------------------------------

		template<typename TContainer>
		struct from_copy_range : base_range
		{
			typedef from_copy_range<TContainer> this_type;

			typedef TContainer container_type;
			typedef typename TContainer::const_iterator iterator_type;
			typedef typename TContainer::value_type value_type;
			typedef value_type const& return_type;
			enum
			{
				returns_reference = 1,
			};

			container_type container;

			iterator_type current;
			iterator_type upcoming;
			iterator_type end;

			CPPLINQ_INLINEMETHOD from_copy_range(container_type&& container)
				: container(std::move(container)),
				current(container.begin()),
				upcoming(container.begin()),
				end(container.end())
			{
			}

			CPPLINQ_INLINEMETHOD from_copy_range(container_type const& container)
				: container(container),
				current(container.begin()),
				upcoming(container.begin()),
				end(container.end())
			{
			}

			CPPLINQ_INLINEMETHOD from_copy_range(from_copy_range const& v)
				: container(v.container),
				current(v.current),
				upcoming(v.upcoming),
				end(v.end)
			{
			}

			CPPLINQ_INLINEMETHOD from_copy_range(from_copy_range&& v) CPPLINQ_NOEXCEPT
				: container(std::move(v.container)),
				current(std::move(v.current)),
				upcoming(std::move(v.upcoming)),
				end(std::move(v.end))
			{
			}

			template<typename TRangeBuilder>
			CPPLINQ_INLINEMETHOD auto operator>>(TRangeBuilder range_builder) const
			{
				return range_builder.build(*this);
			}

			CPPLINQ_INLINEMETHOD auto front() const
			{
				CPPLINQ_ASSERT(current != upcoming);
				CPPLINQ_ASSERT(current != end);

				return *current;
			}

			CPPLINQ_INLINEMETHOD auto next() CPPLINQ_NOEXCEPT
			{
				if (upcoming == end)
				{
					return false;
				}

				current = upcoming;

				++upcoming;

				return true;
			}
		};

		// -------------------------------------------------------------------------

		struct int_range : base_range
		{
			typedef int_range this_type;
			typedef int value_type;
			typedef int return_type;
			enum
			{
				returns_reference = 0,
			};

			int current;
			int end;

			static int get_current(int begin, int end)
			{
				return (begin < end ? begin : end) - 1; // -1 in order to start one-step before the first element
			}

			static int get_end(int begin, int end) // -1 in order to avoid an extra test in next
			{
				return (begin < end ? end : begin) - 1;
			}

			CPPLINQ_INLINEMETHOD int_range(int begin, int end) CPPLINQ_NOEXCEPT
				: current(get_current(begin, end)),
				end(get_end(begin, end))
			{
			}

			CPPLINQ_INLINEMETHOD int_range(int_range const& v) CPPLINQ_NOEXCEPT
				: current(v.current),
				end(v.end)
			{
			}

			CPPLINQ_INLINEMETHOD int_range(int_range && v) CPPLINQ_NOEXCEPT
				: current(std::move(v.current)),
				end(std::move(v.end))
			{
			}

			template<typename TRangeBuilder>
			CPPLINQ_INLINEMETHOD auto operator>>(TRangeBuilder range_builder) const
			{
				return range_builder.build(*this);
			}

			CPPLINQ_INLINEMETHOD auto front() const
			{
				return current;
			}

			CPPLINQ_INLINEMETHOD auto next() CPPLINQ_NOEXCEPT
			{
				if (current >= end)
				{
					return false;
				}

				++current;

				return true;
			}
		};

		// -------------------------------------------------------------------------

		template <typename TValue>
		struct repeat_range : base_range
		{
			typedef repeat_range<TValue> this_type;
			typedef TValue value_type;
			typedef TValue return_type;
			enum
			{
				returns_reference = 0,
			};

			TValue value;
			size_type remaining;

			CPPLINQ_INLINEMETHOD repeat_range(value_type element, size_type count) CPPLINQ_NOEXCEPT
				: value(std::move(element)),
				remaining(count)
			{
			}

			CPPLINQ_INLINEMETHOD repeat_range(repeat_range const& v) CPPLINQ_NOEXCEPT
				: value(v.value),
				remaining(v.remaining)
			{
			}

			CPPLINQ_INLINEMETHOD repeat_range(repeat_range&& v) CPPLINQ_NOEXCEPT
				: value(std::move(v.value)),
				remaining(std::move(v.remaining))
			{
			}

			template<typename TRangeBuilder>
			CPPLINQ_INLINEMETHOD auto operator>>(TRangeBuilder range_builder) const
			{
				return range_builder.build(*this);
			}

			CPPLINQ_INLINEMETHOD auto front() const
			{
				return value;
			}

			CPPLINQ_INLINEMETHOD auto next() CPPLINQ_NOEXCEPT
			{
				if (remaining == 0U)
				{
					return false;
				}

				--remaining;

				return true;
			}
		};

		// -------------------------------------------------------------------------

		template <typename TValue>
		struct empty_range : base_range
		{
			typedef empty_range<TValue> this_type;
			typedef TValue value_type;
			typedef TValue return_type;
			enum
			{
				returns_reference = 0,
			};

			CPPLINQ_INLINEMETHOD empty_range() CPPLINQ_NOEXCEPT
			{
			}

			CPPLINQ_INLINEMETHOD empty_range(empty_range const& v) CPPLINQ_NOEXCEPT
			{
			}

			CPPLINQ_INLINEMETHOD empty_range(empty_range&& v) CPPLINQ_NOEXCEPT
			{
			}

			template<typename TRangeBuilder>
			CPPLINQ_INLINEMETHOD auto operator>>(TRangeBuilder range_builder) const
			{
				return range_builder.build(*this);
			}

			CPPLINQ_INLINEMETHOD auto front() const
			{
				CPPLINQ_ASSERT(false);

				throw programming_error_exception();
			}

			CPPLINQ_INLINEMETHOD auto next() CPPLINQ_NOEXCEPT
			{
				return false;
			}
		};

		// -------------------------------------------------------------------------

		template <typename TValue>
		struct singleton_range : base_range
		{
			typedef singleton_range<TValue> this_type;
			typedef TValue value_type;
			typedef TValue const& return_type;

			enum
			{
				returns_reference = 1,
			};

			value_type value;
			bool done;

			CPPLINQ_INLINEMETHOD singleton_range(TValue const& value)
				: value(value),
				done(false)
			{
			}

			CPPLINQ_INLINEMETHOD singleton_range(TValue&& value) CPPLINQ_NOEXCEPT
				: value(std::move(value)),
				done(false)
			{
			}

			CPPLINQ_INLINEMETHOD singleton_range(singleton_range const& v) CPPLINQ_NOEXCEPT
				: value(v.value),
				done(v.done)
			{
			}

			CPPLINQ_INLINEMETHOD singleton_range(singleton_range&& v) CPPLINQ_NOEXCEPT
				: value(std::move(v.value)),
				done(std::move(v.done))
			{
			}

			template<typename TRangeBuilder>
			CPPLINQ_INLINEMETHOD auto operator>>(TRangeBuilder range_builder) const
			{
				return range_builder.build(*this);
			}

			CPPLINQ_INLINEMETHOD auto front() const CPPLINQ_NOEXCEPT
			{
				return value;
			}

			CPPLINQ_INLINEMETHOD auto next() CPPLINQ_NOEXCEPT
			{
				auto d = done;
				done = true;
				return !d;
			}
		};

		// -------------------------------------------------------------------------

		struct sorting_range : base_range
		{
#ifdef CPPLINQ_DETECT_INVALID_METHODS
		protected:
			// In order to prevent object slicing

			CPPLINQ_INLINEMETHOD sorting_range() CPPLINQ_NOEXCEPT
			{
			}

			CPPLINQ_INLINEMETHOD sorting_range(sorting_range const&) CPPLINQ_NOEXCEPT
			{
			}

			CPPLINQ_INLINEMETHOD sorting_range(sorting_range&&) CPPLINQ_NOEXCEPT
			{
			}

			CPPLINQ_INLINEMETHOD ~sorting_range() CPPLINQ_NOEXCEPT
			{
			}
		private:
			CPPLINQ_INLINEMETHOD sorting_range& operator= (sorting_range const&);
			CPPLINQ_INLINEMETHOD sorting_range& operator= (sorting_range&&);
#endif
		};

		template<typename TRange, typename TPredicate>
		struct orderby_range : sorting_range
		{

			typedef orderby_range<TRange, TPredicate> this_type;
			typedef TRange range_type;
			typedef TPredicate predicate_type;

			typedef typename TRange::value_type value_type;
			typedef typename TRange::return_type forwarding_return_type;
			typedef value_type const& return_type;
			enum
			{
				forward_returns_reference = TRange::returns_reference,
				returns_reference = 1,
			};

			range_type range;
			predicate_type predicate;
			bool sort_ascending;

			size_type current;
			std::vector<value_type> sorted_values;

			CPPLINQ_INLINEMETHOD orderby_range(range_type range, predicate_type predicate, bool sort_ascending) CPPLINQ_NOEXCEPT
				: range(std::move(range)),
				predicate(std::move(predicate)),
				sort_ascending(sort_ascending),
				current(invalid_size)
			{
				static_assert(!std::is_convertible<range_type, sorting_range>::value, "orderby may not follow orderby or thenby");
			}

			CPPLINQ_INLINEMETHOD orderby_range(orderby_range const& v)
				: range(v.range),
				predicate(v.predicate),
				sort_ascending(v.sort_ascending),
				current(v.current),
				sorted_values(v.sorted_values)
			{
			}

			CPPLINQ_INLINEMETHOD orderby_range(orderby_range&& v) CPPLINQ_NOEXCEPT
				: range(std::move(v.range)),
				predicate(std::move(v.predicate)),
				sort_ascending(std::move(v.sort_ascending)),
				current(std::move(v.current)),
				sorted_values(std::move(v.sorted_values))
			{
			}

			CPPLINQ_INLINEMETHOD auto forwarding_front() const
			{
				return range.front();
			}

			CPPLINQ_INLINEMETHOD auto forwarding_next()
			{
				return range.next();
			}

			CPPLINQ_INLINEMETHOD auto compare_values(value_type const& l, value_type const& r) const
			{
				if (sort_ascending)
				{
					return predicate(l) < predicate(r);
				}
				else
				{
					return predicate(r) < predicate(l);
				}
			}

			template<typename TRangeBuilder>
			CPPLINQ_INLINEMETHOD auto operator>>(TRangeBuilder range_builder) const
			{
				return range_builder.build(*this);
			}

			CPPLINQ_INLINEMETHOD auto front() const
			{
				return sorted_values[current];
			}

			CPPLINQ_METHOD auto next()
			{
				if (current == invalid_size)
				{
					sorted_values.clear();

					while (range.next())
					{
						sorted_values.push_back(range.front());
					}

					if (sorted_values.size() == 0)
					{
						return false;
					}

					std::sort(sorted_values.begin(), sorted_values.end(), [this](value_type const& l, value_type const& r)
						{
							return this->compare_values(l, r);
						}
					);

					current = 0U;
					return true;
				}

				if (current < sorted_values.size())
				{
					++current;
				}

				return current < sorted_values.size();
			}
		};

		template<typename TPredicate>
		struct orderby_builder : base_builder
		{
			typedef orderby_builder<TPredicate> this_type;
			typedef TPredicate predicate_type;

			predicate_type predicate;
			bool sort_ascending;

			CPPLINQ_INLINEMETHOD explicit orderby_builder(predicate_type predicate, bool sort_ascending) CPPLINQ_NOEXCEPT
				: predicate(std::move(predicate)),
				sort_ascending(sort_ascending)
			{
			}

			CPPLINQ_INLINEMETHOD orderby_builder(orderby_builder const& v)
				: predicate(v.predicate),
				sort_ascending(v.sort_ascending)
			{
			}

			CPPLINQ_INLINEMETHOD orderby_builder(orderby_builder&& v) CPPLINQ_NOEXCEPT
				: predicate(std::move(v.predicate)),
				sort_ascending(std::move(v.sort_ascending))
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				return orderby_range<TRange, TPredicate>(std::move(range), predicate, sort_ascending);
			}
		};

		// -------------------------------------------------------------------------

		template<typename TRange, typename TPredicate>
		struct thenby_range : sorting_range
		{
			typedef thenby_range<TRange, TPredicate> this_type;
			typedef TRange range_type;
			typedef TPredicate predicate_type;

			typedef typename TRange::value_type value_type;
			typedef typename TRange::forwarding_return_type forwarding_return_type;
			typedef value_type const& return_type;
			enum
			{
				forward_returns_reference = TRange::forward_returns_reference,
				returns_reference = 1,
			};

			range_type range;
			predicate_type predicate;
			bool sort_ascending;

			size_type current;
			std::vector<value_type> sorted_values;

			CPPLINQ_INLINEMETHOD thenby_range(range_type range, predicate_type predicate, bool sort_ascending) CPPLINQ_NOEXCEPT
				: range(std::move(range)),
				predicate(std::move(predicate)),
				sort_ascending(sort_ascending),
				current(invalid_size)
			{
				static_assert(std::is_convertible<range_type, sorting_range>::value, "thenby may only follow orderby or thenby");
			}

			CPPLINQ_INLINEMETHOD thenby_range(thenby_range const& v)
				: range(v.range),
				predicate(v.predicate),
				sort_ascending(v.sort_ascending),
				current(v.current),
				sorted_values(v.sorted_values)
			{
			}

			CPPLINQ_INLINEMETHOD thenby_range(thenby_range&& v) CPPLINQ_NOEXCEPT
				: range(std::move(v.range)),
				predicate(std::move(v.predicate)),
				sort_ascending(std::move(v.sort_ascending)),
				current(std::move(v.current)),
				sorted_values(std::move(v.sorted_values))
			{
			}

			template<typename TRangeBuilder>
			CPPLINQ_INLINEMETHOD auto operator>>(TRangeBuilder range_builder) const
			{
				return range_builder.build(*this);
			}

			CPPLINQ_INLINEMETHOD auto forwarding_front() const
			{
				return range.front();
			}

			CPPLINQ_INLINEMETHOD auto forwarding_next()
			{
				return range.next();
			}

			CPPLINQ_INLINEMETHOD auto compare_values(value_type const& l, value_type const& r) const
			{
				auto pless = range.compare_values(l, r);
				if (pless)
				{
					return true;
				}

				auto pgreater = range.compare_values(r, l);
				if (pgreater)
				{
					return false;
				}

				if (sort_ascending)
				{
					return predicate(l) < predicate(r);
				}
				else
				{
					return predicate(r) < predicate(l);
				}
			}

			CPPLINQ_INLINEMETHOD auto front() const
			{
				return sorted_values[current];
			}

			CPPLINQ_METHOD auto next()
			{
				if (current == invalid_size)
				{
					sorted_values.clear();

					while (range.forwarding_next())
					{
						sorted_values.push_back(range.forwarding_front());
					}

					if (sorted_values.size() == 0)
					{
						return false;
					}

					std::sort(sorted_values.begin(), sorted_values.end(), [this](value_type const& l, value_type const& r)
						{
							return this->compare_values(l, r);
						}
					);

					current = 0U;
					return true;
				}

				if (current < sorted_values.size())
				{
					++current;
				}

				return current < sorted_values.size();
			}
		};

		template<typename TPredicate>
		struct thenby_builder : base_builder
		{
			typedef thenby_builder<TPredicate> this_type;
			typedef TPredicate predicate_type;

			predicate_type predicate;
			bool sort_ascending;

			CPPLINQ_INLINEMETHOD explicit thenby_builder(predicate_type predicate, bool sort_ascending) CPPLINQ_NOEXCEPT
				: predicate(std::move(predicate)),
				sort_ascending(sort_ascending)
			{
			}

			CPPLINQ_INLINEMETHOD thenby_builder(thenby_builder const& v)
				: predicate(v.predicate),
				sort_ascending(v.sort_ascending)
			{
			}

			CPPLINQ_INLINEMETHOD thenby_builder(thenby_builder&& v) CPPLINQ_NOEXCEPT
				: predicate(std::move(v.predicate)),
				sort_ascending(std::move(v.sort_ascending))
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				return thenby_range<TRange, TPredicate>(std::move(range), predicate, sort_ascending);
			}

		};

		// -------------------------------------------------------------------------

		template<typename TRange>
		struct reverse_range : base_range
		{
			typedef reverse_range<TRange> this_type;
			typedef TRange range_type;

			typedef typename TRange::value_type value_type;
			typedef value_type const& return_type;

			typedef std::vector<value_type> stack_type;

			enum
			{
				returns_reference = 1,
			};


			range_type range;
			size_type capacity;
			std::vector<value_type> reversed;
			bool start;

			CPPLINQ_INLINEMETHOD reverse_range(range_type range, size_type capacity) CPPLINQ_NOEXCEPT
				: range(std::move(range)),
				capacity(capacity),
				start(true)
			{
			}

			CPPLINQ_INLINEMETHOD reverse_range(reverse_range const& v) CPPLINQ_NOEXCEPT
				: range(v.range),
				capacity(v.capacity),
				reversed(v.reversed),
				start(v.start)
			{
			}

			CPPLINQ_INLINEMETHOD reverse_range(reverse_range&& v) CPPLINQ_NOEXCEPT
				: range(std::move(v.range)),
				capacity(std::move(v.capacity)),
				reversed(std::move(v.reversed)),
				start(std::move(v.start))
			{
			}

			template<typename TRangeBuilder>
			CPPLINQ_INLINEMETHOD auto operator>>(TRangeBuilder range_builder) const
			{
				return range_builder.build(*this);
			}

			CPPLINQ_INLINEMETHOD auto front() const CPPLINQ_NOEXCEPT
			{
				CPPLINQ_ASSERT(!start);
				CPPLINQ_ASSERT(!reversed.empty());

				return reversed[reversed.size() - 1];
			}

			CPPLINQ_INLINEMETHOD auto next()
			{
				if (start)
				{
					start = false;

					reversed.clear();
					reversed.reserve(capacity);

					while (range.next())
					{
						reversed.push_back(range.front());
					}

					return !reversed.empty();
				}

				if (reversed.empty())
				{
					return false;
				}

				reversed.pop_back();

				return !reversed.empty();
			}
		};

		struct reverse_builder : base_builder
		{
			typedef reverse_builder this_type;

			size_type capacity;

			CPPLINQ_INLINEMETHOD reverse_builder(size_type capacity) CPPLINQ_NOEXCEPT
				: capacity(capacity)
			{
			}

			CPPLINQ_INLINEMETHOD reverse_builder(reverse_builder const& v) CPPLINQ_NOEXCEPT
				: capacity(v.capacity)
			{
			}

			CPPLINQ_INLINEMETHOD reverse_builder(reverse_builder&& v) CPPLINQ_NOEXCEPT
				: capacity(std::move(v.capacity))
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				return reverse_range<TRange>(std::move(range), capacity);
			}
		};

		// -------------------------------------------------------------------------

		template<typename TRange, typename TPredicate>
		struct where_range : base_range
		{
			typedef where_range<TRange, TPredicate> this_type;
			typedef TRange range_type;
			typedef TPredicate predicate_type;

			typedef typename TRange::value_type value_type;
			typedef typename TRange::return_type return_type;
			enum
			{
				returns_reference = TRange::returns_reference,
			};

			range_type range;
			predicate_type predicate;

			CPPLINQ_INLINEMETHOD where_range(range_type range, predicate_type predicate) CPPLINQ_NOEXCEPT
				: range(std::move(range)),
				predicate(std::move(predicate))
			{
			}

			CPPLINQ_INLINEMETHOD where_range(where_range const& v) CPPLINQ_NOEXCEPT
				: range(v.range),
				predicate(v.predicate)
			{
			}

			CPPLINQ_INLINEMETHOD where_range(where_range&& v) CPPLINQ_NOEXCEPT
				: range(std::move(v.range)),
				predicate(std::move(v.predicate))
			{
			}

			template<typename TRangeBuilder>
			CPPLINQ_INLINEMETHOD auto operator>>(TRangeBuilder range_builder) const
			{
				return range_builder.build(*this);
			}

			CPPLINQ_INLINEMETHOD auto front() const
			{
				return range.front();
			}

			CPPLINQ_INLINEMETHOD auto next()
			{
				while (range.next())
				{
					if (predicate(range.front()))
					{
						return true;
					}
				}

				return false;
			}
		};

		template<typename TPredicate>
		struct where_builder : base_builder
		{
			typedef where_builder<TPredicate> this_type;
			typedef TPredicate predicate_type;

			predicate_type predicate;

			CPPLINQ_INLINEMETHOD explicit where_builder(predicate_type predicate) CPPLINQ_NOEXCEPT
				: predicate(std::move(predicate))
			{
			}

			CPPLINQ_INLINEMETHOD where_builder(where_builder const& v) CPPLINQ_NOEXCEPT
				: predicate(v.predicate)
			{
			}

			CPPLINQ_INLINEMETHOD where_builder(where_builder&& v) CPPLINQ_NOEXCEPT
				: predicate(std::move(v.predicate))
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				return where_range<TRange, TPredicate>(std::move(range), predicate);
			}
		};

		// -------------------------------------------------------------------------

		template<typename TRange>
		struct take_range : base_range
		{
			typedef take_range<TRange> this_type;
			typedef TRange range_type;

			typedef typename TRange::value_type value_type;
			typedef typename TRange::return_type return_type;
			enum
			{
				returns_reference = TRange::returns_reference,
			};

			range_type range;
			size_type count;
			size_type current;


			CPPLINQ_INLINEMETHOD take_range(range_type range, size_type count) CPPLINQ_NOEXCEPT
				: range(std::move(range)),
				count(std::move(count)),
				current(0)
			{
			}

			CPPLINQ_INLINEMETHOD take_range(take_range const& v) CPPLINQ_NOEXCEPT
				: range(v.range),
				count(v.count),
				current(v.current)
			{
			}

			CPPLINQ_INLINEMETHOD take_range(take_range&& v) CPPLINQ_NOEXCEPT
				: range(std::move(v.range)),
				count(std::move(v.count)),
				current(std::move(v.current))
			{
			}

			template<typename TRangeBuilder>
			CPPLINQ_INLINEMETHOD auto operator>>(TRangeBuilder range_builder) const
			{
				return range_builder.build(*this);
			}

			CPPLINQ_INLINEMETHOD auto front() const
			{
				return range.front();
			}

			CPPLINQ_INLINEMETHOD auto next()
			{
				if (current >= count)
				{
					return false;
				}

				++current;

				return range.next();
			}
		};

		struct take_builder : base_builder
		{
			typedef take_builder this_type;

			size_type count;

			CPPLINQ_INLINEMETHOD explicit take_builder(size_type count) CPPLINQ_NOEXCEPT
				: count(std::move(count))
			{
			}

			CPPLINQ_INLINEMETHOD take_builder(take_builder const& v) CPPLINQ_NOEXCEPT
				: count(v.count)
			{
			}

			CPPLINQ_INLINEMETHOD take_builder(take_builder&& v) CPPLINQ_NOEXCEPT
				: count(std::move(v.count))
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				return take_range<TRange>(std::move(range), count);
			}
		};

		// -------------------------------------------------------------------------

		template<typename TRange, typename TPredicate>
		struct take_while_range : base_range
		{
			typedef take_while_range<TRange, TPredicate> this_type;
			typedef TRange range_type;
			typedef TPredicate predicate_type;

			typedef typename TRange::value_type value_type;
			typedef typename TRange::return_type return_type;
			enum
			{
				returns_reference = TRange::returns_reference,
			};

			range_type range;
			predicate_type predicate;
			bool done;


			CPPLINQ_INLINEMETHOD take_while_range(range_type range, predicate_type predicate) CPPLINQ_NOEXCEPT
				: range(std::move(range)),
				predicate(std::move(predicate)),
				done(false)
			{
			}

			CPPLINQ_INLINEMETHOD take_while_range(take_while_range const& v) CPPLINQ_NOEXCEPT
				: range(v.range),
				predicate(v.predicate),
				done(v.done)
			{
			}

			CPPLINQ_INLINEMETHOD take_while_range(take_while_range&& v) CPPLINQ_NOEXCEPT
				: range(std::move(v.range)),
				predicate(std::move(v.predicate)),
				done(std::move(v.done))
			{
			}

			template<typename TRangeBuilder>
			CPPLINQ_INLINEMETHOD auto operator>>(TRangeBuilder range_builder) const
			{
				return range_builder.build(*this);
			}

			CPPLINQ_INLINEMETHOD auto front() const
			{
				return range.front();
			}

			CPPLINQ_INLINEMETHOD auto next()
			{
				if (done)
				{
					return false;
				}

				if (!range.next())
				{
					done = true;
					return false;
				}

				if (!predicate(range.front()))
				{
					done = true;
					return false;
				}

				return true;
			}
		};

		template<typename TPredicate>
		struct take_while_builder : base_builder
		{
			typedef take_while_builder<TPredicate> this_type;
			typedef TPredicate predicate_type;

			predicate_type predicate;

			CPPLINQ_INLINEMETHOD take_while_builder(predicate_type predicate) CPPLINQ_NOEXCEPT
				: predicate(std::move(predicate))
			{
			}

			CPPLINQ_INLINEMETHOD take_while_builder(take_while_builder const& v) CPPLINQ_NOEXCEPT
				: predicate(v.predicate)
			{
			}

			CPPLINQ_INLINEMETHOD take_while_builder(take_while_builder&& v) CPPLINQ_NOEXCEPT
				: predicate(std::move(v.predicate))
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				return take_while_range<TRange, TPredicate>(std::move(range), predicate);
			}

		};

		// -------------------------------------------------------------------------

		template<typename TRange>
		struct skip_range : base_range
		{
			typedef skip_range<TRange> this_type;
			typedef TRange range_type;

			typedef typename TRange::value_type value_type;
			typedef typename TRange::return_type return_type;
			enum
			{
				returns_reference = TRange::returns_reference,
			};

			range_type range;
			size_type count;
			size_type current;

			CPPLINQ_INLINEMETHOD skip_range(range_type range, size_type count) CPPLINQ_NOEXCEPT
				: range(std::move(range)),
				count(std::move(count)),
				current(0)
			{
			}

			CPPLINQ_INLINEMETHOD skip_range(skip_range const& v) CPPLINQ_NOEXCEPT
				: range(v.range),
				count(v.count),
				current(v.current)
			{
			}

			CPPLINQ_INLINEMETHOD skip_range(skip_range&& v) CPPLINQ_NOEXCEPT
				: range(std::move(v.range)),
				count(std::move(v.count)),
				current(std::move(v.current))
			{
			}

			template<typename TRangeBuilder>
			CPPLINQ_INLINEMETHOD auto operator>>(TRangeBuilder range_builder) const
			{
				return range_builder.build(*this);
			}

			CPPLINQ_INLINEMETHOD auto front() const
			{
				return range.front();
			}

			CPPLINQ_INLINEMETHOD auto next()
			{
				if (current == invalid_size)
				{
					return false;
				}

				while (current < count && range.next())
				{
					++current;
				}

				if (current < count)
				{
					current = invalid_size;
					return false;
				}

				return range.next();
			}
		};

		struct skip_builder : base_builder
		{
			typedef skip_builder this_type;

			size_type count;

			CPPLINQ_INLINEMETHOD explicit skip_builder(size_type count) CPPLINQ_NOEXCEPT
				: count(std::move(count))
			{
			}

			CPPLINQ_INLINEMETHOD skip_builder(skip_builder const& v) CPPLINQ_NOEXCEPT
				: count(v.count)
			{
			}

			CPPLINQ_INLINEMETHOD skip_builder(skip_builder&& v) CPPLINQ_NOEXCEPT
				: count(std::move(v.count))
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				return skip_range<TRange>(std::move(range), count);
			}

		};

		// -------------------------------------------------------------------------

		template<typename TRange, typename TPredicate>
		struct skip_while_range : base_range
		{
			typedef skip_while_range<TRange, TPredicate> this_type;
			typedef TRange range_type;
			typedef TPredicate predicate_type;

			typedef typename TRange::value_type value_type;
			typedef typename TRange::return_type return_type;
			enum
			{
				returns_reference = TRange::returns_reference,
			};

			range_type range;
			predicate_type predicate;
			bool skipping;

			CPPLINQ_INLINEMETHOD skip_while_range(range_type range, predicate_type predicate) CPPLINQ_NOEXCEPT
				: range(std::move(range)),
				predicate(std::move(predicate)),
				skipping(true)
			{
			}

			CPPLINQ_INLINEMETHOD skip_while_range(skip_while_range const& v) CPPLINQ_NOEXCEPT
				: range(v.range),
				predicate(v.predicate),
				skipping(v.skipping)
			{
			}

			CPPLINQ_INLINEMETHOD skip_while_range(skip_while_range&& v) CPPLINQ_NOEXCEPT
				: range(std::move(v.range)),
				predicate(std::move(v.predicate)),
				skipping(std::move(v.skipping))
			{
			}

			template<typename TRangeBuilder>
			CPPLINQ_INLINEMETHOD auto operator>>(TRangeBuilder range_builder) const
			{
				return range_builder.build(*this);
			}

			CPPLINQ_INLINEMETHOD auto front() const
			{
				return range.front();
			}

			CPPLINQ_INLINEMETHOD auto next()
			{
				if (!skipping)
				{
					return range.next();
				}

				while (range.next())
				{
					if (!predicate(range.front()))
					{
						skipping = false;
						return true;
					}
				}

				return false;
			}
		};

		template <typename TPredicate>
		struct skip_while_builder : base_builder
		{
			typedef skip_while_builder<TPredicate> this_type;
			typedef TPredicate predicate_type;

			predicate_type predicate;

			CPPLINQ_INLINEMETHOD skip_while_builder(predicate_type predicate) CPPLINQ_NOEXCEPT
				: predicate(std::move(predicate))
			{
			}

			CPPLINQ_INLINEMETHOD skip_while_builder(skip_while_builder const& v) CPPLINQ_NOEXCEPT
				: predicate(v.predicate)
			{
			}

			CPPLINQ_INLINEMETHOD skip_while_builder(skip_while_builder&& v) CPPLINQ_NOEXCEPT
				: predicate(std::move(v.predicate))
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				return skip_while_range<TRange, TPredicate>(std::move(range), predicate);
			}

		};

		// -------------------------------------------------------------------------

		template<typename TRange>
		struct ref_range : base_range
		{
			typedef std::reference_wrapper<typename TRange::value_type const> value_type;
			typedef value_type return_type;
			enum
			{
				returns_reference = 0,
			};

			typedef ref_range<TRange> this_type;
			typedef TRange range_type;

			range_type range;

			CPPLINQ_INLINEMETHOD ref_range(range_type range) CPPLINQ_NOEXCEPT
				: range(std::move(range))
			{
				static_assert(TRange::returns_reference, "ref may only follow a range that returns references");
			}

			CPPLINQ_INLINEMETHOD ref_range(ref_range const& v) CPPLINQ_NOEXCEPT
				: range(v.range)
			{
			}

			CPPLINQ_INLINEMETHOD ref_range(ref_range&& v) CPPLINQ_NOEXCEPT
				: range(std::move(v.range))
			{
			}

			template<typename TRangeBuilder>
			CPPLINQ_INLINEMETHOD auto operator>>(TRangeBuilder range_builder) const
			{
				return range_builder.build(*this);
			}

			CPPLINQ_INLINEMETHOD auto front() const
			{
				return value_type(range.front());
			}

			CPPLINQ_INLINEMETHOD auto next()
			{
				return range.next();
			}
		};

		struct ref_builder : base_builder
		{
			typedef ref_builder this_type;

			CPPLINQ_INLINEMETHOD ref_builder() CPPLINQ_NOEXCEPT
			{
			}

			CPPLINQ_INLINEMETHOD ref_builder(ref_builder const& v) CPPLINQ_NOEXCEPT
			{
			}

			CPPLINQ_INLINEMETHOD ref_builder(ref_builder&& v) CPPLINQ_NOEXCEPT
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				return ref_range<TRange>(std::move(range));
			}
		};

		// -------------------------------------------------------------------------

		template <typename F, typename... T1s, typename T2>
		static auto choose(F && f, std::tuple<T1s...>&&, T2&&) -> decltype (f(std::declval<T1s>()...));
		template <typename F, typename T1, typename... T2s>
		static auto choose(F && f, T1&&, std::tuple<T2s...>&&) -> decltype (f(std::declval<T2s>()...));

		template<typename TRange, typename TPredicate>
		struct select_range : base_range
		{
			static typename TRange::value_type get_source();
			static TPredicate get_predicate();


			typedef decltype(choose(get_predicate(), std::make_tuple(get_source()), std::make_tuple(get_source(), 0))) raw_value_type;
			typedef typename cleanup_type<raw_value_type>::type value_type;
			typedef value_type const& return_type;
			enum
			{
				returns_reference = 1,
			};

			typedef select_range<TRange, TPredicate> this_type;
			typedef TRange range_type;
			typedef TPredicate predicate_type;

			range_type range;
			predicate_type predicate;

			opt<value_type> cache_value;
			size_type current_index;

			CPPLINQ_INLINEMETHOD select_range(range_type range, predicate_type predicate) CPPLINQ_NOEXCEPT
				: range(std::move(range)),
				predicate(std::move(predicate)),
				current_index(0)
			{
			}

			CPPLINQ_INLINEMETHOD select_range(select_range const& v) CPPLINQ_NOEXCEPT
				: range(v.range),
				predicate(v.predicate),
				cache_value(v.cache_value),
				current_index(v.current_index)
			{
			}

			CPPLINQ_INLINEMETHOD select_range(select_range&& v) CPPLINQ_NOEXCEPT
				: range(std::move(v.range)),
				predicate(std::move(v.predicate)),
				cache_value(std::move(v.cache_value)),
				current_index(std::move(v.current_index))
			{
			}

			template<typename TRangeBuilder>
			CPPLINQ_INLINEMETHOD auto operator>>(TRangeBuilder range_builder) const
			{
				return range_builder.build(*this);
			}

			CPPLINQ_INLINEMETHOD auto front() const
			{
				CPPLINQ_ASSERT(cache_value);

				return *cache_value;
			}

			CPPLINQ_INLINEMETHOD auto next()
			{
				if (range.next())
				{
					cache_value = evaluate_predicate(predicate);
					return true;
				}

				cache_value.clear();

				return false;
			}

			template<typename TPredicate_>
			CPPLINQ_INLINEMETHOD auto evaluate_predicate(TPredicate_&& pred) -> decltype (pred(range.front()))
			{
				return pred(range.front());
			}

			template<typename TPredicate_, int = 0 /* VisualStudio Workaround (http://stackoverflow.com/a/28204207/3647361) */>
			CPPLINQ_INLINEMETHOD auto evaluate_predicate(TPredicate_ && pred) -> decltype (pred(range.front(), 0))
			{
				return pred(range.front(), current_index++);
			}
		};

		template<typename TPredicate>
		struct select_builder : base_builder
		{
			typedef select_builder<TPredicate> this_type;
			typedef TPredicate predicate_type;

			predicate_type predicate;

			CPPLINQ_INLINEMETHOD explicit select_builder(predicate_type predicate) CPPLINQ_NOEXCEPT
				: predicate(std::move(predicate))
			{
			}

			CPPLINQ_INLINEMETHOD select_builder(select_builder const& v) CPPLINQ_NOEXCEPT
				: predicate(v.predicate)
			{
			}

			CPPLINQ_INLINEMETHOD select_builder(select_builder&& v) CPPLINQ_NOEXCEPT
				: predicate(std::move(v.predicate))
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				return select_range<TRange, TPredicate>(std::move(range), predicate);
			}
		};

		// -------------------------------------------------------------------------

		// Some trickery in order to force the code to compile on VS2012
		template<typename TRange, typename TPredicate>
		struct select_many_range_helper
		{
			static typename TRange::value_type get_source();
			static TPredicate get_predicate();


			typedef decltype(choose(get_predicate(), std::make_tuple(get_source()), std::make_tuple(get_source(), 0))) raw_inner_range_type;
			typedef typename cleanup_type<raw_inner_range_type>::type inner_range_type;

			static inner_range_type get_inner_range();

			typedef decltype (get_inner_range().front()) raw_value_type;
			typedef typename cleanup_type<raw_value_type>::type value_type;

		};

		template<typename TRange, typename TPredicate>
		struct select_many_range : base_range
		{
			typedef select_many_range_helper<TRange, TPredicate> helper_type;

			typedef typename helper_type::inner_range_type inner_range_type;
			typedef typename helper_type::value_type value_type;
			typedef value_type return_type;
			enum
			{
				returns_reference = 0,
			};

			typedef select_many_range<TRange, TPredicate> this_type;
			typedef TRange range_type;
			typedef TPredicate predicate_type;

			range_type range;
			predicate_type predicate;

			opt<inner_range_type> inner_range;
			size_type current_index;


			CPPLINQ_INLINEMETHOD select_many_range(range_type range, predicate_type predicate) CPPLINQ_NOEXCEPT
				: range(std::move(range)),
				predicate(std::move(predicate)),
				current_index(0)
			{
			}

			CPPLINQ_INLINEMETHOD select_many_range(select_many_range const& v) CPPLINQ_NOEXCEPT
				: range(v.range),
				predicate(v.predicate),
				inner_range(v.inner_range),
				current_index(v.current_index)
			{
			}

			CPPLINQ_INLINEMETHOD select_many_range(select_many_range&& v) CPPLINQ_NOEXCEPT
				: range(std::move(v.range)),
				predicate(std::move(v.predicate)),
				inner_range(std::move(v.inner_range)),
				current_index(std::move(v.current_index))
			{
			}

			template<typename TRangeBuilder>
			CPPLINQ_INLINEMETHOD auto operator>>(TRangeBuilder range_builder) const
			{
				return range_builder.build(*this);
			}

			CPPLINQ_INLINEMETHOD auto front() const
			{
				CPPLINQ_ASSERT(inner_range);

				return inner_range->front();
			}

			CPPLINQ_INLINEMETHOD auto next()
			{
				if (inner_range && inner_range->next())
				{
					return true;
				}

				if (range.next())
				{
					inner_range = evaluate_predicate(predicate);
					return inner_range && inner_range->next();
				}

				inner_range.clear();

				return false;
			}

			template<typename TPredicate_>
			CPPLINQ_INLINEMETHOD auto evaluate_predicate(TPredicate_& pred) -> decltype (pred(range.front()))
			{
				return pred(range.front());
			}

			template<typename TPredicate_, int = 0 /* VisualStudio Workaround (http://stackoverflow.com/a/28204207/3647361) */>
			CPPLINQ_INLINEMETHOD auto evaluate_predicate(TPredicate_ & pred) -> decltype (pred(range.front(), 0))
			{
				return pred(range.front(), current_index++);
			}
		};

		template<typename TPredicate>
		struct select_many_builder : base_builder
		{
			typedef select_many_builder<TPredicate> this_type;
			typedef TPredicate predicate_type;

			predicate_type predicate;

			CPPLINQ_INLINEMETHOD explicit select_many_builder(predicate_type predicate) CPPLINQ_NOEXCEPT
				: predicate(std::move(predicate))
			{
			}

			CPPLINQ_INLINEMETHOD select_many_builder(select_many_builder const& v) CPPLINQ_NOEXCEPT
				: predicate(v.predicate)
			{
			}

			CPPLINQ_INLINEMETHOD select_many_builder(select_many_builder&& v) CPPLINQ_NOEXCEPT
				: predicate(std::move(v.predicate))
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				return select_many_range<TRange, TPredicate>(std::move(range), predicate);
			}

		};

		// -------------------------------------------------------------------------

		template<typename TRange, typename TOtherRange, typename TKeySelector, typename TOtherKeySelector, typename TCombiner>
		struct join_range : base_range
		{
			static typename TRange::value_type get_source();
			static typename TOtherRange::value_type get_other_source();
			static TKeySelector get_key_selector();
			static TOtherKeySelector get_other_key_selector();
			static TCombiner get_combiner();

			typedef decltype(get_key_selector()(get_source())) raw_key_type;
			typedef typename cleanup_type<raw_key_type>::type key_type;

			typedef decltype(get_other_key_selector() (get_other_source())) raw_other_key_type;
			typedef typename cleanup_type<raw_other_key_type>::type other_key_type;

			typedef decltype(get_combiner()(get_source(), get_other_source())) raw_value_type;
			typedef typename cleanup_type<raw_value_type>::type value_type;
			typedef value_type return_type;
			enum
			{
				returns_reference = 0,
			};

			typedef join_range<TRange, TOtherRange, TKeySelector, TOtherKeySelector, TCombiner> this_type;
			typedef TRange range_type;
			typedef TOtherRange other_range_type;
			typedef TKeySelector key_selector_type;
			typedef TOtherKeySelector other_key_selector_type;
			typedef TCombiner combiner_type;
			typedef std::multimap<other_key_type, typename TOtherRange::value_type> map_type;
			typedef typename map_type::const_iterator map_iterator_type;

			range_type range;
			other_range_type other_range;
			key_selector_type key_selector;
			other_key_selector_type other_key_selector;
			combiner_type combiner;

			bool start;
			map_type map;
			map_iterator_type current;

			CPPLINQ_INLINEMETHOD join_range(range_type range, other_range_type other_range, key_selector_type key_selector, other_key_selector_type other_key_selector, combiner_type combiner) CPPLINQ_NOEXCEPT
				: range(std::move(range)),
				other_range(std::move(other_range)),
				key_selector(std::move(key_selector)),
				other_key_selector(std::move(other_key_selector)),
				combiner(std::move(combiner)),
				start(true)
			{
			}

			CPPLINQ_INLINEMETHOD join_range(join_range const& v) CPPLINQ_NOEXCEPT
				: range(v.range),
				other_range(v.other_range),
				key_selector(v.key_selector),
				other_key_selector(v.other_key_selector),
				combiner(v.combiner),
				start(v.start),
				map(v.map),
				current(v.current)
			{
			}

			CPPLINQ_INLINEMETHOD join_range(join_range&& v) CPPLINQ_NOEXCEPT
				: range(std::move(v.range)),
				other_range(std::move(v.other_range)),
				key_selector(std::move(v.key_selector)),
				other_key_selector(std::move(v.other_key_selector)),
				combiner(std::move(v.combiner)),
				start(std::move(v.start)),
				map(std::move(v.map)),
				current(std::move(v.current))
			{
			}

			template<typename TRangeBuilder>
			CPPLINQ_INLINEMETHOD auto operator>>(TRangeBuilder range_builder) const
			{
				return range_builder.build(*this);
			}

			CPPLINQ_INLINEMETHOD auto front() const
			{
				CPPLINQ_ASSERT(current != map.end());

				return combiner(range.front(), current->second);
			}

			CPPLINQ_INLINEMETHOD auto next()
			{
				if (start)
				{
					start = false;
					while (other_range.next())
					{
						auto other_value = other_range.front();
						auto other_key = other_key_selector(other_value);
						map.insert(typename map_type::value_type(std::move(other_key), std::move(other_value)));
					}

					current = map.end();
					if (map.size() == 0U)
					{
						return false;
					}
				}

				if (current != map.end())
				{
					auto previous = current;
					++current;
					if (current != map.end() && !(previous->first < current->first))
					{
						return true;
					}
				}

				while (range.next())
				{
					auto value = range.front();
					auto key = key_selector(value);

					current = map.find(key);
					if (current != map.end())
					{
						return true;
					}
				}

				return false;
			}
		};

		template<typename TOtherRange, typename TKeySelector, typename TOtherKeySelector, typename TCombiner>
		struct join_builder : base_builder
		{
			typedef join_builder<TOtherRange, TKeySelector, TOtherKeySelector, TCombiner> this_type;

			typedef TOtherRange other_range_type;
			typedef TKeySelector key_selector_type;
			typedef TOtherKeySelector other_key_selector_type;
			typedef TCombiner combiner_type;

			other_range_type other_range;
			key_selector_type key_selector;
			other_key_selector_type other_key_selector;
			combiner_type combiner;

			CPPLINQ_INLINEMETHOD join_builder(other_range_type other_range, key_selector_type key_selector, other_key_selector_type other_key_selector, combiner_type combiner) CPPLINQ_NOEXCEPT
				: other_range(std::move(other_range)),
				key_selector(std::move(key_selector)),
				other_key_selector(std::move(other_key_selector)),
				combiner(std::move(combiner))
			{
			}

			CPPLINQ_INLINEMETHOD join_builder(join_builder const& v)
				: other_range(v.other_range),
				key_selector(v.key_selector),
				other_key_selector(v.other_key_selector),
				combiner(v.combiner)
			{
			}

			CPPLINQ_INLINEMETHOD join_builder(join_builder&& v) CPPLINQ_NOEXCEPT
				: other_range(std::move(v.other_range)),
				key_selector(std::move(v.key_selector)),
				other_key_selector(std::move(v.other_key_selector)),
				combiner(std::move(v.combiner))
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				return join_range<TRange, TOtherRange, TKeySelector, TOtherKeySelector, TCombiner>(std::move(range), other_range, key_selector, other_key_selector, combiner);
			}
		};

		// -------------------------------------------------------------------------

		template<typename TRange>
		struct distinct_range : base_range
		{
			typedef distinct_range<TRange> this_type;
			typedef TRange range_type;

			typedef typename cleanup_type<typename TRange::value_type>::type value_type;
			typedef value_type const& return_type;
			enum
			{
				returns_reference = 1,
			};

			typedef std::unordered_set<value_type> set_type;
			typedef typename set_type::const_iterator set_iterator_type;

			range_type range;
			set_type set;
			set_iterator_type current;

			CPPLINQ_INLINEMETHOD distinct_range(range_type range) CPPLINQ_NOEXCEPT
				: range(std::move(range))
			{
			}

			CPPLINQ_INLINEMETHOD distinct_range(distinct_range const& v) CPPLINQ_NOEXCEPT
				: range(v.range),
				set(v.set),
				current(v.current)
			{
			}

			CPPLINQ_INLINEMETHOD distinct_range(distinct_range&& v) CPPLINQ_NOEXCEPT
				: range(std::move(v.range)),
				set(std::move(v.set)),
				current(std::move(v.current))
			{
			}

			template<typename TRangeBuilder>
			CPPLINQ_INLINEMETHOD auto operator>>(TRangeBuilder range_builder) const
			{
				return range_builder.build(*this);
			}

			CPPLINQ_INLINEMETHOD auto front() const
			{
				return *current;
			}

			CPPLINQ_INLINEMETHOD auto next()
			{
				while (range.next())
				{
					auto result = set.insert(range.front());
					if (result.second)
					{
						current = result.first;
						return true;
					}
				}

				return false;
			}
		};

		struct distinct_builder : base_builder
		{
			typedef distinct_builder this_type;

			CPPLINQ_INLINEMETHOD distinct_builder() CPPLINQ_NOEXCEPT
			{
			}

			CPPLINQ_INLINEMETHOD distinct_builder(distinct_builder const& v) CPPLINQ_NOEXCEPT
			{
			}

			CPPLINQ_INLINEMETHOD distinct_builder(distinct_builder&& v) CPPLINQ_NOEXCEPT
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				return distinct_range<TRange>(std::move(range));
			}
		};

		// -------------------------------------------------------------------------

		template<typename TRange, typename TSelector>
		struct distinct_key_selector_range : base_range
		{
			typedef distinct_key_selector_range<TRange, TSelector> this_type;
			typedef TRange range_type;
			typedef TSelector key_selector_type;

			typedef typename cleanup_type<typename TRange::value_type>::type value_type;
			typedef value_type const& return_type;
			enum
			{
				returns_reference = 1,
			};

			typedef typename get_transformed_type<key_selector_type, typename TRange::value_type>::type key_type;
			typedef std::set<key_type> set_type;

			range_type range;
			key_selector_type key_selector;
			set_type set;

			CPPLINQ_INLINEMETHOD distinct_key_selector_range(range_type range, key_selector_type key_selector) CPPLINQ_NOEXCEPT
				: range(std::move(range)),
				key_selector(std::move(key_selector))
			{
			}

			CPPLINQ_INLINEMETHOD distinct_key_selector_range(distinct_key_selector_range const& v) CPPLINQ_NOEXCEPT
				: range(v.range),
				key_selector(v.key_selector),
				set(v.set)
			{
			}

			CPPLINQ_INLINEMETHOD distinct_key_selector_range(distinct_key_selector_range&& v) CPPLINQ_NOEXCEPT
				: range(std::move(v.range)),
				key_selector(std::move(v.key_selector)),
				set(std::move(v.set))
			{
			}

			template<typename TRangeBuilder>
			CPPLINQ_INLINEMETHOD auto operator>>(TRangeBuilder range_builder) const
			{
				return range_builder.build(*this);
			}

			CPPLINQ_INLINEMETHOD auto front() const
			{
				return range.front();
			}

			CPPLINQ_INLINEMETHOD auto next()
			{
				while (range.next())
				{
					auto result = set.insert(key_selector(range.front()));
					if (result.second)
					{
						return true;
					}
				}

				return false;
			}
		};

		template <typename TSelector>
		struct distinct_key_selector_builder : base_builder
		{
			typedef distinct_key_selector_builder<TSelector> this_type;
			typedef TSelector key_selector_type;

			key_selector_type key_selector;

			CPPLINQ_INLINEMETHOD distinct_key_selector_builder(key_selector_type key_selector) CPPLINQ_NOEXCEPT
				: key_selector(std::move(key_selector))
			{
			}

			CPPLINQ_INLINEMETHOD distinct_key_selector_builder(distinct_key_selector_builder const& v) CPPLINQ_NOEXCEPT
				: key_selector(v.key_selector)
			{
			}

			CPPLINQ_INLINEMETHOD distinct_key_selector_builder(distinct_key_selector_builder&& v) CPPLINQ_NOEXCEPT
				: key_selector(std::move(v.key_selector))
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				return distinct_key_selector_range<TRange, TSelector>(std::move(range), key_selector);
			}
		};

		// -------------------------------------------------------------------------

		template<typename TRange, typename TOtherRange>
		struct union_range : base_range
		{
			typedef union_range<TRange, TOtherRange> this_type;
			typedef TRange range_type;
			typedef TOtherRange other_range_type;

			typedef typename cleanup_type<typename TRange::value_type>::type value_type;
			typedef value_type const& return_type;
			enum
			{
				returns_reference = 1,
			};

			typedef std::set<value_type> set_type;
			typedef typename set_type::const_iterator set_iterator_type;


			range_type range;
			other_range_type other_range;
			set_type set;
			set_iterator_type current;

			CPPLINQ_INLINEMETHOD union_range(range_type range, other_range_type other_range) CPPLINQ_NOEXCEPT
				: range(std::move(range)),
				other_range(std::move(other_range))
			{
			}

			CPPLINQ_INLINEMETHOD union_range(union_range const& v) CPPLINQ_NOEXCEPT
				: range(v.range),
				other_range(v.other_range),
				set(v.set),
				current(v.current)
			{
			}

			CPPLINQ_INLINEMETHOD union_range(union_range&& v) CPPLINQ_NOEXCEPT
				: range(std::move(v.range)),
				other_range(std::move(v.other_range)),
				set(std::move(v.set)),
				current(std::move(v.current))
			{
			}

			template<typename TRangeBuilder>
			CPPLINQ_INLINEMETHOD auto operator>>(TRangeBuilder range_builder) const
			{
				return range_builder.build(*this);
			}

			CPPLINQ_INLINEMETHOD auto front() const
			{
				return *current;
			}

			CPPLINQ_INLINEMETHOD auto next()
			{
				while (range.next())
				{
					auto result = set.insert(range.front());
					if (result.second)
					{
						current = result.first;
						return true;
					}
				}

				while (other_range.next())
				{
					auto result = set.insert(other_range.front());
					if (result.second)
					{
						current = result.first;
						return true;
					}
				}

				return false;
			}
		};

		template <typename TOtherRange>
		struct union_builder : base_builder
		{
			typedef union_builder<TOtherRange> this_type;
			typedef TOtherRange other_range_type;

			other_range_type other_range;

			CPPLINQ_INLINEMETHOD union_builder(TOtherRange other_range) CPPLINQ_NOEXCEPT
				: other_range(std::move(other_range))
			{
			}

			CPPLINQ_INLINEMETHOD union_builder(union_builder const& v) CPPLINQ_NOEXCEPT
				: other_range(v.other_range)
			{
			}

			CPPLINQ_INLINEMETHOD union_builder(union_builder&& v) CPPLINQ_NOEXCEPT
				: other_range(std::move(v.other_range))
			{
			}

			template <typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				return union_range<TRange, TOtherRange>(std::move(range), std::move(other_range));
			}
		};

		// -------------------------------------------------------------------------

		template<typename TRange, typename TOtherRange>
		struct intersect_range : base_range
		{
			typedef intersect_range<TRange, TOtherRange> this_type;
			typedef TRange range_type;
			typedef TOtherRange other_range_type;

			typedef typename cleanup_type<typename TRange::value_type>::type value_type;
			typedef value_type const& return_type;
			enum
			{
				returns_reference = 1,
			};

			typedef std::set<value_type> set_type;
			typedef typename set_type::const_iterator set_iterator_type;


			range_type range;
			other_range_type other_range;
			set_type set;
			set_iterator_type current;
			bool start;

			CPPLINQ_INLINEMETHOD intersect_range(range_type range, other_range_type other_range) CPPLINQ_NOEXCEPT
				: range(std::move(range)),
				other_range(std::move(other_range)),
				start(true)
			{
			}

			CPPLINQ_INLINEMETHOD intersect_range(intersect_range const& v) CPPLINQ_NOEXCEPT
				: range(v.range),
				other_range(v.other_range),
				set(v.set),
				current(v.current),
				start(v.start)
			{
			}

			CPPLINQ_INLINEMETHOD intersect_range(intersect_range&& v) CPPLINQ_NOEXCEPT
				: range(std::move(v.range)),
				other_range(std::move(v.other_range)),
				set(std::move(v.set)),
				current(std::move(v.current)),
				start(std::move(v.start))
			{
			}

			template<typename TRangeBuilder>
			CPPLINQ_INLINEMETHOD auto operator>>(TRangeBuilder range_builder) const
			{
				return range_builder.build(*this);
			}

			CPPLINQ_INLINEMETHOD auto front() const
			{
				CPPLINQ_ASSERT(!start);
				return *current;
			}

			CPPLINQ_INLINEMETHOD auto next()
			{
				if (start)
				{
					start = false;

					while (other_range.next())
					{
						set.insert(other_range.front());
					}

					while (range.next())
					{
						current = set.find(range.front());
						if (current != set.end())
						{
							return true;
						}
					}

					set.clear();

					return false;
				}

				if (set.empty())
				{
					return false;
				}

				set.erase(current);

				while (range.next())
				{
					current = set.find(range.front());
					if (current != set.end())
					{
						return true;
					}
				}

				return false;
			}
		};

		template <typename TOtherRange>
		struct intersect_builder : base_builder
		{
			typedef intersect_builder<TOtherRange> this_type;
			typedef TOtherRange other_range_type;

			other_range_type other_range;

			CPPLINQ_INLINEMETHOD intersect_builder(TOtherRange other_range) CPPLINQ_NOEXCEPT
				: other_range(std::move(other_range))
			{
			}

			CPPLINQ_INLINEMETHOD intersect_builder(intersect_builder const& v) CPPLINQ_NOEXCEPT
				: other_range(v.other_range)
			{
			}

			CPPLINQ_INLINEMETHOD intersect_builder(intersect_builder&& v) CPPLINQ_NOEXCEPT
				: other_range(std::move(v.other_range))
			{
			}

			template <typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				return intersect_range<TRange, TOtherRange>(std::move(range), std::move(other_range));
			}
		};

		// -------------------------------------------------------------------------

		template<typename TRange, typename TOtherRange>
		struct except_range : base_range
		{
			typedef except_range<TRange, TOtherRange> this_type;
			typedef TRange range_type;
			typedef TOtherRange other_range_type;

			typedef typename cleanup_type<typename TRange::value_type>::type value_type;
			typedef value_type const& return_type;
			enum
			{
				returns_reference = 1,
			};

			typedef std::unordered_set<value_type> set_type;
			typedef typename set_type::const_iterator set_iterator_type;

			range_type range;
			other_range_type other_range;
			set_type set;
			set_iterator_type current;
			bool start;

			CPPLINQ_INLINEMETHOD except_range(range_type range, other_range_type other_range) CPPLINQ_NOEXCEPT
				: range(std::move(range)),
				other_range(std::move(other_range)),
				start(true)
			{
			}

			CPPLINQ_INLINEMETHOD except_range(except_range const& v) CPPLINQ_NOEXCEPT
				: range(v.range),
				other_range(v.other_range),
				set(v.set),
				current(v.current),
				start(v.start)
			{
			}

			CPPLINQ_INLINEMETHOD except_range(except_range&& v) CPPLINQ_NOEXCEPT
				: range(std::move(v.range)),
				other_range(std::move(v.other_range)),
				set(std::move(v.set)),
				current(std::move(v.current)),
				start(std::move(v.start))
			{
			}

			template<typename TRangeBuilder>
			CPPLINQ_INLINEMETHOD auto operator>>(TRangeBuilder range_builder) const
			{
				return range_builder.build(*this);
			}

			CPPLINQ_INLINEMETHOD auto front() const
			{
				return *current;
			}

			CPPLINQ_INLINEMETHOD auto next()
			{
				if (start)
				{
					start = false;
					while (other_range.next())
					{
						set.insert(other_range.front());
					}
				}

				while (range.next())
				{
					auto result = set.insert(range.front());
					if (result.second)
					{
						current = result.first;
						return true;
					}
				}

				return false;
			}
		};

		template <typename TOtherRange>
		struct except_builder : base_builder
		{
			typedef union_builder<TOtherRange> this_type;
			typedef TOtherRange other_range_type;

			other_range_type other_range;

			CPPLINQ_INLINEMETHOD except_builder(TOtherRange other_range) CPPLINQ_NOEXCEPT
				: other_range(std::move(other_range))
			{
			}

			CPPLINQ_INLINEMETHOD except_builder(except_builder const& v) CPPLINQ_NOEXCEPT
				: other_range(v.other_range)
			{
			}

			CPPLINQ_INLINEMETHOD except_builder(except_builder&& v) CPPLINQ_NOEXCEPT
				: other_range(std::move(v.other_range))
			{
			}

			template <typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				return except_range<TRange, TOtherRange>(std::move(range), std::move(other_range));
			}
		};

		// -------------------------------------------------------------------------

		template<typename TRange, typename TOtherRange>
		struct concat_range : base_range
		{
			typedef concat_range<TRange, TOtherRange> this_type;
			typedef TRange range_type;
			typedef TOtherRange other_range_type;

			typedef typename cleanup_type<typename TRange::value_type>::type value_type;
			typedef typename cleanup_type<typename TOtherRange::value_type>::type other_value_type;
			typedef value_type return_type;

			enum
			{
				returns_reference = 0,
			};

			enum state
			{
				state_initial,
				state_iterating_range,
				state_iterating_other_range,
				state_end,
			};

			range_type range;
			other_range_type other_range;
			state state;

			CPPLINQ_INLINEMETHOD concat_range(range_type range, other_range_type other_range) CPPLINQ_NOEXCEPT
				: range(std::move(range)),
				other_range(std::move(other_range)),
				state(state_initial)
			{
			}

			CPPLINQ_INLINEMETHOD concat_range(concat_range const& v) CPPLINQ_NOEXCEPT
				: range(v.range),
				other_range(v.other_range),
				state(v.state)
			{
			}

			CPPLINQ_INLINEMETHOD concat_range(concat_range&& v) CPPLINQ_NOEXCEPT
				: range(std::move(v.range)),
				other_range(std::move(v.other_range)),
				state(std::move(v.state))
			{
			}

			template<typename TRangeBuilder>
			CPPLINQ_INLINEMETHOD auto operator>>(TRangeBuilder range_builder) const
			{
				return range_builder.build(*this);
			}

			CPPLINQ_INLINEMETHOD auto front() const
			{
				switch (state)
				{
				case state_initial:
				case state_end:
				default:
					CPPLINQ_ASSERT(false); // Intentionally falls through
				case state_iterating_range:
					return range.front();
				case state_iterating_other_range:
					return other_range.front();
				};
			}

			CPPLINQ_INLINEMETHOD auto next()
			{
				switch (state)
				{
				case state_initial:
					if (range.next())
					{
						state = state_iterating_range;
						return true;
					}

					if (other_range.next())
					{
						state = state_iterating_other_range;
						return true;
					}

					state = state_end;
					return false;
				case state_iterating_range:
					if (range.next())
					{
						return true;
					}

					if (other_range.next())
					{
						state = state_iterating_other_range;
						return true;
					}

					state = state_end;
					return false;
				case state_iterating_other_range:
					if (other_range.next())
					{
						return true;
					}

					state = state_end;
					return false;
				case state_end:
				default:
					return false;
				}
			}
		};

		template <typename TOtherRange>
		struct concat_builder : base_builder
		{
			typedef concat_builder<TOtherRange> this_type;
			typedef TOtherRange other_range_type;

			other_range_type other_range;

			CPPLINQ_INLINEMETHOD concat_builder(TOtherRange other_range) CPPLINQ_NOEXCEPT
				: other_range(std::move(other_range))
			{
			}

			CPPLINQ_INLINEMETHOD concat_builder(concat_builder const& v) CPPLINQ_NOEXCEPT
				: other_range(v.other_range)
			{
			}

			CPPLINQ_INLINEMETHOD concat_builder(concat_builder&& v) CPPLINQ_NOEXCEPT
				: other_range(std::move(v.other_range))
			{
			}

			template <typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				return concat_range<TRange, TOtherRange>(std::move(range), std::move(other_range));
			}
		};

		// -------------------------------------------------------------------------

		template<typename TRange, typename TOtherRange>
		struct start_with_range : base_range
		{
			typedef start_with_range<TRange, TOtherRange> this_type;
			typedef TRange range_type;
			typedef TOtherRange other_range_type;

			typedef typename cleanup_type<typename TRange::value_type>::type value_type;
			typedef typename cleanup_type<typename TOtherRange::value_type>::type other_value_type;
			typedef value_type return_type;

			enum
			{
				returns_reference = 0,
			};

			enum state
			{
				state_initial,
				state_iterating_other_range,
				state_iterating_range,
				state_end,
			};

			range_type range;
			other_range_type other_range;
			state state;

			CPPLINQ_INLINEMETHOD start_with_range(range_type range, other_range_type other_range) CPPLINQ_NOEXCEPT
				: range(std::move(range)),
				other_range(std::move(other_range)),
				state(state_initial)
			{
			}

			CPPLINQ_INLINEMETHOD start_with_range(start_with_range const& v) CPPLINQ_NOEXCEPT
				: range(v.range),
				other_range(v.other_range),
				state(v.state)
			{
			}

			CPPLINQ_INLINEMETHOD start_with_range(start_with_range&& v) CPPLINQ_NOEXCEPT
				: range(std::move(v.range)),
				other_range(std::move(v.other_range)),
				state(std::move(v.state))
			{
			}

			template<typename TRangeBuilder>
			CPPLINQ_INLINEMETHOD auto operator>>(TRangeBuilder range_builder) const
			{
				return range_builder.build(*this);
			}

			CPPLINQ_INLINEMETHOD auto front() const
			{
				switch (state)
				{
				case state_initial:
				case state_end:
				default:
					CPPLINQ_ASSERT(false); // Intentionally falls through
				case state_iterating_range:
					return range.front();
				case state_iterating_other_range:
					return other_range.front();
				};
			}

			CPPLINQ_INLINEMETHOD auto next()
			{
				switch (state)
				{
				case state_initial:
					if (other_range.next())
					{
						state = state_iterating_other_range;
						return true;
					}

					if (range.next())
					{
						state = state_iterating_range;
						return true;
					}

					state = state_end;
					return false;
				case state_iterating_other_range:
					if (other_range.next())
					{
						return true;
					}

					if (range.next())
					{
						state = state_iterating_range;
						return true;
					}

					state = state_end;
					return false;
				case state_iterating_range:
					if (range.next())
					{
						return true;
					}

					state = state_end;
					return false;
				case state_end:
				default:
					return false;
				}
			}
		};

		template <typename TOtherRange>
		struct start_with_builder : base_builder
		{
			typedef start_with_builder<TOtherRange> this_type;
			typedef TOtherRange other_range_type;

			other_range_type other_range;

			CPPLINQ_INLINEMETHOD start_with_builder(TOtherRange other_range) CPPLINQ_NOEXCEPT
				: other_range(std::move(other_range))
			{
			}

			CPPLINQ_INLINEMETHOD start_with_builder(start_with_builder const& v) CPPLINQ_NOEXCEPT
				: other_range(v.other_range)
			{
			}

			CPPLINQ_INLINEMETHOD start_with_builder(start_with_builder&& v) CPPLINQ_NOEXCEPT
				: other_range(std::move(v.other_range))
			{
			}

			template <typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				return start_with_range<TRange, TOtherRange>(std::move(range), std::move(other_range));
			}
		};

		// -------------------------------------------------------------------------

		namespace experimental
		{
			// -------------------------------------------------------------------------

			// TODO: Verify that container range aggregator has the right semantics

			template<typename TRange>
			struct container_iterator
			{
				typedef std::forward_iterator_tag iterator_category;
				typedef typename TRange::value_type value_type;
				typedef typename TRange::return_type return_type;
				enum
				{
					returns_reference = TRange::returns_reference,
				};

				typedef std::ptrdiff_t difference_type;
				typedef value_type* pointer;
				typedef value_type& reference;

				typedef container_iterator<TRange> this_type;
				typedef TRange range_type;

				bool has_value;
				opt<range_type> range;

				CPPLINQ_INLINEMETHOD container_iterator() CPPLINQ_NOEXCEPT
					: has_value(false)
				{
				}

				CPPLINQ_INLINEMETHOD container_iterator(range_type r) CPPLINQ_NOEXCEPT
					: range(std::move(r))
				{
					has_value = range && range->next();
				}

				CPPLINQ_INLINEMETHOD container_iterator(container_iterator const& v) CPPLINQ_NOEXCEPT
					: has_value(v.has_value),
					range(v.range)
				{
				}

				CPPLINQ_INLINEMETHOD container_iterator(container_iterator&& v) CPPLINQ_NOEXCEPT
					: has_value(std::move(v.has_value)),
					range(std::move(v.range))
				{
				}

				CPPLINQ_INLINEMETHOD auto operator*() const
				{
					CPPLINQ_ASSERT(has_value);
					CPPLINQ_ASSERT(range);

					return range->front();
				}

				CPPLINQ_INLINEMETHOD auto operator->() const
				{
					static_assert(returns_reference, "operator-> requires a range that returns a reference, typically select causes ranges to return values not references");

					return &range->front();
				}

				CPPLINQ_INLINEMETHOD auto operator++()
				{
					if (has_value && range)
					{
						has_value = range->next();
					}

					return *this;
				}

				CPPLINQ_INLINEMETHOD auto operator==(this_type const& v) const CPPLINQ_NOEXCEPT
				{
					if (!has_value && !v.has_value)
					{
						return true;
					}
					else if (has_value && v.has_value && range.get_ptr() == v.range.get_ptr())
					{
						return true;
					}
					else
					{
						return false;
					}
				}

				CPPLINQ_INLINEMETHOD auto operator!=(this_type const& v) const CPPLINQ_NOEXCEPT
				{
					return !(*this == v);
				}
			};

			template<typename TRange>
			struct container
			{
				typedef container<TRange> this_type;
				typedef TRange range_type;
				typedef typename TRange::value_type value_type;
				typedef typename TRange::return_type return_type;
				enum
				{
					returns_reference = TRange::returns_reference,
				};

				range_type range;

				CPPLINQ_INLINEMETHOD explicit container(TRange range)
					: range(std::move(range))
				{
				}

				CPPLINQ_INLINEMETHOD container(container const& v) CPPLINQ_NOEXCEPT
					: range(v.range)
				{
				}

				CPPLINQ_INLINEMETHOD container(container&& v) CPPLINQ_NOEXCEPT
					: range(std::move(v.range))
				{
				}

				CPPLINQ_INLINEMETHOD auto begin() CPPLINQ_NOEXCEPT
				{
					return container_iterator<TRange>(range);
				}

				CPPLINQ_INLINEMETHOD auto end() CPPLINQ_NOEXCEPT
				{
					return container_iterator<TRange>();
				}
			};

			struct container_builder : base_builder
			{
				typedef container_builder this_type;

				CPPLINQ_INLINEMETHOD container_builder() CPPLINQ_NOEXCEPT
				{
				}

				CPPLINQ_INLINEMETHOD container_builder(container_builder const& v) CPPLINQ_NOEXCEPT
				{
				}

				CPPLINQ_INLINEMETHOD container_builder(container_builder&& v) CPPLINQ_NOEXCEPT
				{
				}

				template<typename TRange>
				CPPLINQ_METHOD auto build(TRange range) const
				{
					return container<TRange>(std::move(range));
				}
			};
		}

		// -------------------------------------------------------------------------

		struct to_vector_builder : base_builder
		{
			typedef to_vector_builder this_type;

			size_type capacity;

			CPPLINQ_INLINEMETHOD explicit to_vector_builder(size_type capacity = 16U) CPPLINQ_NOEXCEPT
				: capacity(capacity)
			{
			}

			CPPLINQ_INLINEMETHOD to_vector_builder(to_vector_builder const& v) CPPLINQ_NOEXCEPT
				: capacity(v.capacity)
			{
			}

			CPPLINQ_INLINEMETHOD to_vector_builder(to_vector_builder&& v) CPPLINQ_NOEXCEPT
				: capacity(std::move(v.capacity))
			{
			}

			template<typename TRange>
			CPPLINQ_METHOD auto build(TRange range) const
			{
				std::vector<typename TRange::value_type> result;
				result.reserve(capacity);

				while (range.next())
				{
					result.push_back(range.front());
				}

				return result;
			}
		};

		struct to_list_builder : base_builder
		{
			typedef to_list_builder this_type;

			CPPLINQ_INLINEMETHOD explicit to_list_builder() CPPLINQ_NOEXCEPT
			{
			}

			CPPLINQ_INLINEMETHOD to_list_builder(to_list_builder const& v) CPPLINQ_NOEXCEPT
			{
			}

			CPPLINQ_INLINEMETHOD to_list_builder(to_list_builder&& v) CPPLINQ_NOEXCEPT
			{
			}

			template<typename TRange>
			CPPLINQ_METHOD auto build(TRange range) const
			{
				std::list<typename TRange::value_type> result;

				while (range.next())
				{
					result.push_back(range.front());
				}

				return result;
			}
		};

		// -------------------------------------------------------------------------

		template<typename TKeySelector>
		struct to_map_builder : base_builder
		{
			static TKeySelector get_key_selector();

			typedef to_map_builder<TKeySelector> this_type;
			typedef TKeySelector key_selector_type;

			key_selector_type key_selector;

			CPPLINQ_INLINEMETHOD explicit to_map_builder(key_selector_type key_selector) CPPLINQ_NOEXCEPT
				: key_selector(std::move(key_selector))
			{
			}

			CPPLINQ_INLINEMETHOD to_map_builder(to_map_builder const& v)
				: key_selector(v.key_selector)
			{
			}

			CPPLINQ_INLINEMETHOD to_map_builder(to_map_builder&& v) CPPLINQ_NOEXCEPT
				: key_selector(std::move(v.key_selector))
			{
			}

			template<typename TRange>
			CPPLINQ_METHOD auto build(TRange range) const
			{
				typedef std::map<
					typename get_transformed_type<key_selector_type, typename TRange::value_type>::type,
					typename TRange::value_type
				> result_type;

				result_type result;

				while (range.next())
				{
					auto v = range.front();
					auto k = key_selector(v);

					result.insert(typename result_type::value_type(std::move(k), std::move(v)));
				}

				return result;
			}
		};

		// -------------------------------------------------------------------------

		struct to_deque_builder : base_builder
		{
			typedef to_deque_builder this_type;

			CPPLINQ_INLINEMETHOD explicit to_deque_builder() CPPLINQ_NOEXCEPT
			{
			}

			CPPLINQ_INLINEMETHOD to_deque_builder(to_deque_builder const& v) CPPLINQ_NOEXCEPT
			{
			}

			CPPLINQ_INLINEMETHOD to_deque_builder(to_deque_builder&& v) CPPLINQ_NOEXCEPT
			{
			}

			template<typename TRange>
			CPPLINQ_METHOD auto build(TRange range) const
			{
				std::deque<typename TRange::value_type> result;

				while (range.next())
				{
					result.push_back(range.front());
				}

				return result;
			}

		};

		// -------------------------------------------------------------------------

		template<typename TKey, typename TValue>
		struct lookup
		{
			typedef TKey key_type;
			typedef TValue value_type;

			typedef std::vector<std::pair<key_type, size_type>> keys_type;
			typedef std::vector<value_type> values_type;

			typedef typename keys_type::const_iterator keys_iterator_type;
			typedef typename values_type::const_iterator values_iterator_type;

			CPPLINQ_METHOD void init(keys_type& k, values_type& v)
			{
				if (v.size() == 0)
				{
					return;
				}

				std::sort(
					k.begin()
					, k.end()
					, [](typename keys_type::value_type const& l, typename keys_type::value_type const& r)
					{
						return l.first < r.first;
					}
				);

				keys.reserve(k.size());
				values.reserve(v.size());

				auto iter = k.begin();
				auto end = k.end();

				auto index = 0U;

				if (iter != end)
				{
					values.push_back(std::move(v[iter->second]));
					keys.push_back(typename keys_type::value_type(iter->first, index));
				}

				auto previous = iter;
				++iter;
				++index;

				while (iter != end)
				{
					values.push_back(v[iter->second]);

					if (previous->first < iter->first)
					{
						keys.push_back(typename keys_type::value_type(iter->first, index));
					}

					previous = iter;
					++iter;
					++index;
				}
			}

			template<typename TRange, typename TKeySelector>
			CPPLINQ_METHOD lookup(size_type capacity, TRange range, TKeySelector key_selector)
			{
				keys_type k;
				values_type v;
				k.reserve(capacity);
				v.reserve(capacity);

				auto index = 0U;
				while (range.next())
				{
					auto value = range.front();
					auto key = key_selector(value);
					v.push_back(std::move(value));
					k.push_back(typename keys_type::value_type(std::move(key), index));
					++index;
				}

				init(k, v);
			}

			template<typename TRange, typename TKeySelector, typename TValueSelector>
			CPPLINQ_METHOD lookup(size_type capacity, TRange range, TKeySelector key_selector, TValueSelector value_selector)
			{
				keys_type k;
				values_type v;
				k.reserve(capacity);
				v.reserve(capacity);

				auto index = 0U;
				while (range.next())
				{
					auto value = range.front();
					auto key = key_selector(value);
					v.push_back(value_selector(value));
					k.push_back(typename keys_type::value_type(std::move(key), index));
					++index;
				}

				init(k, v);
			}

			CPPLINQ_INLINEMETHOD lookup(lookup const& v)
				: values(v.values),
				keys(v.keys)
			{
			}

			CPPLINQ_INLINEMETHOD lookup(lookup&& v) CPPLINQ_NOEXCEPT
				: values(std::move(v.values)),
				keys(std::move(v.keys))
			{
			}

			CPPLINQ_INLINEMETHOD void swap(lookup& v) CPPLINQ_NOEXCEPT
			{
				values.swap(v.values);
				keys.swap(v.keys);
			}

			CPPLINQ_INLINEMETHOD lookup& operator=(lookup const& v)
			{
				if (this == std::addressof(v))
				{
					return *this;
				}

				lookup tmp(v);

				swap(tmp);

				return *this;
			}

			CPPLINQ_INLINEMETHOD lookup& operator=(lookup&& v) CPPLINQ_NOEXCEPT
			{
				if (this == std::addressof(v))
				{
					return *this;
				}

				swap(v);

				return *this;
			}

			struct lookup_range : base_range
			{
				typedef lookup_range this_type;

				enum
				{
					returns_reference = 1,
				};

				typedef TValue value_type;
				typedef value_type const& return_type;

				enum state
				{
					state_initial,
					state_iterating,
					state_end,
				};

				values_type const* values;
				size_type iter;
				size_type end;
				state state;

				CPPLINQ_INLINEMETHOD lookup_range(values_type const* values, size_type iter, size_type end) CPPLINQ_NOEXCEPT
					: values(values),
					iter(iter),
					end(end),
					state(state_initial)
				{
					CPPLINQ_ASSERT(values);
				}

				CPPLINQ_INLINEMETHOD lookup_range(lookup_range const& v) CPPLINQ_NOEXCEPT
					: values(v.values),
					iter(v.iter),
					end(v.end),
					state(v.state)
				{
				}

				CPPLINQ_INLINEMETHOD lookup_range(lookup_range&& v) CPPLINQ_NOEXCEPT
					: values(std::move(v.values)),
					iter(std::move(v.iter)),
					end(std::move(v.end)),
					state(std::move(v.state))
				{
				}

				template<typename TRangeBuilder>
				CPPLINQ_INLINEMETHOD auto operator>>(TRangeBuilder range_builder) const
				{
					return range_builder.build(*this);
				}

				CPPLINQ_INLINEMETHOD auto front() const CPPLINQ_NOEXCEPT
				{
					CPPLINQ_ASSERT(state == state_iterating);
					CPPLINQ_ASSERT(iter < end);

					return (*values)[iter];
				}

				CPPLINQ_INLINEMETHOD auto next() CPPLINQ_NOEXCEPT
				{
					switch (state)
					{
					case state_initial:
					{
						auto has_elements = iter < end;
						state = has_elements ? state_iterating : state_end;
						return has_elements;
					}
					break;
					case state_iterating:
					{
						++iter;

						auto has_elements = iter < end;
						state = has_elements ? state_iterating : state_end;
						return has_elements;
					}
					break;
					case state_end:
					default:
						return false;
					}
				}

			};

			CPPLINQ_METHOD auto operator[](key_type const& key) const CPPLINQ_NOEXCEPT
			{
				if (values.empty())
				{
					return lookup_range(std::addressof(values), 0U, 0U);
				}

				auto find = std::lower_bound(keys.begin(), keys.end(), typename keys_type::value_type(key, 0U),
					[](typename keys_type::value_type const& l, typename keys_type::value_type const& r)
					{
						return l.first < r.first;
					});

				if (find == keys.end())
				{
					return lookup_range(std::addressof(values), 0U, 0U);
				}

				auto next = find + 1;
				if (next == keys.end())
				{
					return lookup_range(std::addressof(values), find->second, values.size());
				}

				return lookup_range(std::addressof(values), find->second, next->second);
			}

			CPPLINQ_INLINEMETHOD auto size_of_keys() const CPPLINQ_NOEXCEPT
			{
				return keys.size();
			}

			CPPLINQ_INLINEMETHOD auto size_of_values() const CPPLINQ_NOEXCEPT
			{
				return values.size();
			}

			CPPLINQ_INLINEMETHOD auto range_of_keys() const CPPLINQ_NOEXCEPT
			{
				return from_range<keys_iterator_type>(keys.begin(), keys.end());
			}

			CPPLINQ_INLINEMETHOD auto range_of_values() const CPPLINQ_NOEXCEPT
			{
				return from_range<values_iterator_type>(values.begin(), values.end());
			}

		private:
			values_type values;
			keys_type keys;
		};

		template<typename TKeySelector>
		struct to_lookup_builder : base_builder
		{
			typedef to_lookup_builder<TKeySelector> this_type;
			typedef TKeySelector key_selector_type;

			key_selector_type key_selector;

			CPPLINQ_INLINEMETHOD explicit to_lookup_builder(key_selector_type key_selector) CPPLINQ_NOEXCEPT
				: key_selector(std::move(key_selector))
			{
			}

			CPPLINQ_INLINEMETHOD to_lookup_builder(to_lookup_builder const& v)
				: key_selector(v.key_selector)
			{
			}

			CPPLINQ_INLINEMETHOD to_lookup_builder(to_lookup_builder&& v) CPPLINQ_NOEXCEPT
				: key_selector(std::move(v.key_selector))
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				typedef lookup<
					typename get_transformed_type<key_selector_type, typename TRange::value_type>::type,
					typename TRange::value_type
				> result_type;

				result_type result(16U, range, key_selector);

				return result;
			}

		};

		template<typename TKeySelector, typename TValueSelector>
		struct to_lookup_value_selector_builder : base_builder
		{
			typedef to_lookup_value_selector_builder<TKeySelector, TValueSelector> this_type;
			typedef TKeySelector key_selector_type;
			typedef TValueSelector value_selector_type;

			key_selector_type key_selector;
			value_selector_type value_selector;

			CPPLINQ_INLINEMETHOD explicit to_lookup_value_selector_builder(key_selector_type key_selector, value_selector_type value_selector) CPPLINQ_NOEXCEPT
				: key_selector(std::move(key_selector)),
				value_selector(std::move(value_selector))
			{
			}

			CPPLINQ_INLINEMETHOD to_lookup_value_selector_builder(to_lookup_value_selector_builder const& v)
				: key_selector(v.key_selector),
				value_selector(v.value_selector)
			{
			}

			CPPLINQ_INLINEMETHOD to_lookup_value_selector_builder(to_lookup_value_selector_builder&& v) CPPLINQ_NOEXCEPT
				: key_selector(std::move(v.key_selector)),
				value_selector(std::move(v.value_selector))
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				typedef lookup<
					typename get_transformed_type<key_selector_type, typename TRange::value_type>::type
					, typename get_transformed_type<value_selector_type, typename TRange::value_type>::type
				> result_type;

				result_type result(16U, range, key_selector, value_selector);

				return result;
			}
		};

		// -------------------------------------------------------------------------

		template<typename TPredicate>
		struct for_each_builder : base_builder
		{
			typedef for_each_builder<TPredicate> this_type;
			typedef TPredicate predicate_type;

			predicate_type predicate;

			CPPLINQ_INLINEMETHOD explicit for_each_builder(predicate_type predicate) CPPLINQ_NOEXCEPT
				: predicate(std::move(predicate))
			{
			}

			CPPLINQ_INLINEMETHOD for_each_builder(for_each_builder const& v) CPPLINQ_NOEXCEPT
				: predicate(v.predicate)
			{
			}

			CPPLINQ_INLINEMETHOD for_each_builder(for_each_builder&& v) CPPLINQ_NOEXCEPT
				: predicate(std::move(v.predicate))
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD void build(TRange range) const
			{
				while (range.next())
				{
					predicate(range.front());
				}
			}
		};

		// -------------------------------------------------------------------------

		template<typename TPredicate>
		struct first_predicate_builder : base_builder
		{
			typedef first_predicate_builder<TPredicate> this_type;
			typedef TPredicate predicate_type;

			predicate_type predicate;

			CPPLINQ_INLINEMETHOD first_predicate_builder(predicate_type predicate) CPPLINQ_NOEXCEPT
				: predicate(std::move(predicate))
			{
			}

			CPPLINQ_INLINEMETHOD first_predicate_builder(first_predicate_builder const& v) CPPLINQ_NOEXCEPT
				: predicate(v.predicate)
			{
			}

			CPPLINQ_INLINEMETHOD first_predicate_builder(first_predicate_builder&& v) CPPLINQ_NOEXCEPT
				: predicate(std::move(v.predicate))
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range)
			{
				while (range.next())
				{
					if (predicate(range.front()))
					{
						return range.front();
					}
				}

				throw sequence_empty_exception();
			}
		};

		// -------------------------------------------------------------------------

		struct first_builder : base_builder
		{
			typedef first_builder this_type;

			CPPLINQ_INLINEMETHOD first_builder() CPPLINQ_NOEXCEPT
			{
			}

			CPPLINQ_INLINEMETHOD first_builder(first_builder const& v) CPPLINQ_NOEXCEPT
			{
			}

			CPPLINQ_INLINEMETHOD first_builder(first_builder&& v) CPPLINQ_NOEXCEPT
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range)
			{
				if (range.next())
				{
					return range.front();
				}

				throw sequence_empty_exception();
			}
		};

		// -------------------------------------------------------------------------

		template<typename TPredicate>
		struct first_or_default_predicate_builder : base_builder
		{
			typedef first_or_default_predicate_builder<TPredicate> this_type;
			typedef TPredicate predicate_type;

			predicate_type predicate;

			CPPLINQ_INLINEMETHOD first_or_default_predicate_builder(predicate_type predicate) CPPLINQ_NOEXCEPT
				: predicate(std::move(predicate))
			{
			}

			CPPLINQ_INLINEMETHOD first_or_default_predicate_builder(first_or_default_predicate_builder const& v) CPPLINQ_NOEXCEPT
				: predicate(v.predicate)
			{
			}

			CPPLINQ_INLINEMETHOD first_or_default_predicate_builder(first_or_default_predicate_builder&& v) CPPLINQ_NOEXCEPT
				: predicate(std::move(v.predicate))
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				while (range.next())
				{
					if (predicate(range.front()))
					{
						return range.front();
					}
				}

				return typename TRange::value_type();
			}
		};

		struct first_or_default_builder : base_builder
		{
			typedef first_or_default_builder this_type;

			CPPLINQ_INLINEMETHOD first_or_default_builder() CPPLINQ_NOEXCEPT
			{
			}

			CPPLINQ_INLINEMETHOD first_or_default_builder(first_or_default_builder const& v) CPPLINQ_NOEXCEPT
			{
			}

			CPPLINQ_INLINEMETHOD first_or_default_builder(first_or_default_builder&& v) CPPLINQ_NOEXCEPT
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				if (range.next())
				{
					return range.front();
				}

				return typename TRange::value_type();
			}
		};

		// -------------------------------------------------------------------------

		template<typename TPredicate>
		struct last_predicate_builder : base_builder
		{
			typedef last_predicate_builder<TPredicate> this_type;
			typedef TPredicate predicate_type;

			predicate_type predicate;

			CPPLINQ_INLINEMETHOD last_predicate_builder(predicate_type predicate) CPPLINQ_NOEXCEPT
				: predicate(std::move(predicate))
			{
			}

			CPPLINQ_INLINEMETHOD last_predicate_builder(last_predicate_builder const& v) CPPLINQ_NOEXCEPT
				: predicate(v.predicate)
			{
			}

			CPPLINQ_INLINEMETHOD last_predicate_builder(last_predicate_builder&& v) CPPLINQ_NOEXCEPT
				: predicate(std::move(v.predicate))
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range)
			{
				opt<typename TRange::value_type> current;

				while (range.next())
				{
					if (predicate(range.front()))
					{
						current = range.front();
					}
				}

				if (current.has_value())
				{
					return current.get();
				}
				else
				{
					throw sequence_empty_exception();
				}
			}
		};

		// -------------------------------------------------------------------------

		struct last_builder : base_builder
		{
			typedef last_builder this_type;

			CPPLINQ_INLINEMETHOD last_builder() CPPLINQ_NOEXCEPT
			{
			}

			CPPLINQ_INLINEMETHOD last_builder(last_builder const& v) CPPLINQ_NOEXCEPT
			{
			}

			CPPLINQ_INLINEMETHOD last_builder(last_builder&& v) CPPLINQ_NOEXCEPT
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range)
			{
				opt<typename TRange::value_type> current;

				while (range.next())
				{
					current = range.front();
				}

				if (current.has_value())
				{
					return current.get();
				}
				else
				{
					throw sequence_empty_exception();
				}
			}
		};

		// -------------------------------------------------------------------------

		template<typename TPredicate>
		struct last_or_default_predicate_builder : base_builder
		{
			typedef last_or_default_predicate_builder<TPredicate> this_type;
			typedef TPredicate predicate_type;

			predicate_type predicate;

			CPPLINQ_INLINEMETHOD last_or_default_predicate_builder(predicate_type predicate) CPPLINQ_NOEXCEPT
				: predicate(std::move(predicate))
			{
			}

			CPPLINQ_INLINEMETHOD last_or_default_predicate_builder(last_or_default_predicate_builder const& v) CPPLINQ_NOEXCEPT
				: predicate(v.predicate)
			{
			}

			CPPLINQ_INLINEMETHOD last_or_default_predicate_builder(last_or_default_predicate_builder&& v) CPPLINQ_NOEXCEPT
				: predicate(std::move(v.predicate))
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				auto current = typename TRange::value_type();

				while (range.next())
				{
					if (predicate(range.front()))
					{
						current = range.front();
					}
				}

				return current;
			}
		};

		struct last_or_default_builder : base_builder
		{
			typedef last_or_default_builder this_type;

			CPPLINQ_INLINEMETHOD last_or_default_builder() CPPLINQ_NOEXCEPT
			{
			}

			CPPLINQ_INLINEMETHOD last_or_default_builder(last_or_default_builder const& v) CPPLINQ_NOEXCEPT
			{
			}

			CPPLINQ_INLINEMETHOD last_or_default_builder(last_or_default_builder&& v) CPPLINQ_NOEXCEPT
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				auto current = typename TRange::value_type();

				while (range.next())
				{
					current = range.front();
				}

				return current;
			}
		};

		// -------------------------------------------------------------------------

		template <typename TPredicate>
		struct count_predicate_builder : base_builder
		{
			typedef count_predicate_builder<TPredicate> this_type;
			typedef TPredicate predicate_type;

			predicate_type predicate;

			CPPLINQ_INLINEMETHOD count_predicate_builder(predicate_type predicate) CPPLINQ_NOEXCEPT
				: predicate(std::move(predicate))
			{
			}

			CPPLINQ_INLINEMETHOD count_predicate_builder(count_predicate_builder const& v) CPPLINQ_NOEXCEPT
				: predicate(v.predicate)
			{
			}

			CPPLINQ_INLINEMETHOD count_predicate_builder(count_predicate_builder&& v) CPPLINQ_NOEXCEPT
				: predicate(std::move(v.predicate))
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				size_type count = 0U;
				while (range.next())
				{
					if (predicate(range.front()))
					{
						++count;
					}
				}
				return count;
			}
		};

		struct count_builder : base_builder
		{
			typedef count_builder this_type;

			CPPLINQ_INLINEMETHOD count_builder() CPPLINQ_NOEXCEPT
			{
			}

			CPPLINQ_INLINEMETHOD count_builder(count_builder const& v) CPPLINQ_NOEXCEPT
			{
			}

			CPPLINQ_INLINEMETHOD count_builder(count_builder&& v) CPPLINQ_NOEXCEPT
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				size_type count = 0U;
				while (range.next())
				{
					++count;
				}
				return count;
			}
		};

		// -------------------------------------------------------------------------

		template <typename TSelector>
		struct sum_selector_builder : base_builder
		{
			typedef sum_selector_builder<TSelector> this_type;
			typedef TSelector selector_type;

			selector_type selector;

			CPPLINQ_INLINEMETHOD sum_selector_builder(selector_type selector) CPPLINQ_NOEXCEPT
				: selector(std::move(selector))
			{
			}

			CPPLINQ_INLINEMETHOD sum_selector_builder(sum_selector_builder const& v) CPPLINQ_NOEXCEPT
				: selector(v.selector)
			{
			}

			CPPLINQ_INLINEMETHOD sum_selector_builder(sum_selector_builder&& v) CPPLINQ_NOEXCEPT
				: selector(std::move(v.selector))
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				typedef typename get_transformed_type<selector_type, typename TRange::value_type>::type value_type;

				auto sum = value_type();
				while (range.next())
				{
					sum += selector(range.front());
				}
				return sum;
			}
		};

		struct sum_builder : base_builder
		{
			typedef sum_builder this_type;

			CPPLINQ_INLINEMETHOD sum_builder() CPPLINQ_NOEXCEPT
			{
			}

			CPPLINQ_INLINEMETHOD sum_builder(sum_builder const& v) CPPLINQ_NOEXCEPT
			{
			}

			CPPLINQ_INLINEMETHOD sum_builder(sum_builder&& v) CPPLINQ_NOEXCEPT
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				auto sum = typename TRange::value_type();
				while (range.next())
				{
					sum += range.front();
				}
				return sum;
			}
		};

		// -------------------------------------------------------------------------

		template <typename TSelector>
		struct max_selector_builder : base_builder
		{
			typedef max_selector_builder<TSelector> this_type;
			typedef TSelector selector_type;

			selector_type selector;

			CPPLINQ_INLINEMETHOD max_selector_builder(selector_type selector) CPPLINQ_NOEXCEPT
				: selector(std::move(selector))
			{
			}

			CPPLINQ_INLINEMETHOD max_selector_builder(max_selector_builder const& v) CPPLINQ_NOEXCEPT
				: selector(v.selector)
			{
			}

			CPPLINQ_INLINEMETHOD max_selector_builder(max_selector_builder&& v) CPPLINQ_NOEXCEPT
				: selector(std::move(v.selector))
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				typedef typename get_transformed_type<selector_type, typename TRange::value_type>::type value_type;

				auto current = std::numeric_limits<value_type>::lowest();
				while (range.next())
				{
					auto v = selector(range.front());
					if (current < v)
					{
						current = std::move(v);
					}
				}

				return current;
			}
		};

		struct max_builder : base_builder
		{
			typedef max_builder this_type;

			CPPLINQ_INLINEMETHOD max_builder() CPPLINQ_NOEXCEPT
			{
			}

			CPPLINQ_INLINEMETHOD max_builder(max_builder const& v) CPPLINQ_NOEXCEPT
			{
			}

			CPPLINQ_INLINEMETHOD max_builder(max_builder&& v) CPPLINQ_NOEXCEPT
			{
			}


			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				auto current = std::numeric_limits<typename TRange::value_type>::lowest();
				while (range.next())
				{
					auto v = range.front();
					if (current < v)
					{
						current = std::move(v);
					}
				}

				return current;
			}
		};

		// -------------------------------------------------------------------------

		template <typename TSelector>
		struct min_selector_builder : base_builder
		{
			typedef min_selector_builder<TSelector> this_type;
			typedef TSelector selector_type;

			selector_type selector;

			CPPLINQ_INLINEMETHOD min_selector_builder(selector_type selector) CPPLINQ_NOEXCEPT
				: selector(std::move(selector))
			{
			}

			CPPLINQ_INLINEMETHOD min_selector_builder(min_selector_builder const& v) CPPLINQ_NOEXCEPT
				: selector(v.selector)
			{
			}

			CPPLINQ_INLINEMETHOD min_selector_builder(min_selector_builder&& v) CPPLINQ_NOEXCEPT
				: selector(std::move(v.selector))
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				typedef typename get_transformed_type<selector_type, typename TRange::value_type>::type value_type;

				auto current = std::numeric_limits<value_type>::max();
				while (range.next())
				{
					auto v = selector(range.front());
					if (v < current)
					{
						current = std::move(v);
					}
				}

				return current;
			}
		};

		struct min_builder : base_builder
		{
			typedef min_builder this_type;

			CPPLINQ_INLINEMETHOD min_builder() CPPLINQ_NOEXCEPT
			{
			}

			CPPLINQ_INLINEMETHOD min_builder(min_builder const& v) CPPLINQ_NOEXCEPT
			{
			}

			CPPLINQ_INLINEMETHOD min_builder(min_builder&& v) CPPLINQ_NOEXCEPT
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				auto current = std::numeric_limits<typename TRange::value_type>::max();
				while (range.next())
				{
					auto v = range.front();
					if (v < current)
					{
						current = std::move(v);
					}
				}

				return current;
			}
		};

		// -------------------------------------------------------------------------

		template <typename TSelector>
		struct avg_selector_builder : base_builder
		{
			typedef avg_selector_builder<TSelector> this_type;
			typedef TSelector selector_type;

			selector_type selector;

			CPPLINQ_INLINEMETHOD avg_selector_builder(selector_type selector) CPPLINQ_NOEXCEPT
				: selector(std::move(selector))
			{
			}

			CPPLINQ_INLINEMETHOD avg_selector_builder(avg_selector_builder const& v) CPPLINQ_NOEXCEPT
				: selector(v.selector)
			{
			}

			CPPLINQ_INLINEMETHOD avg_selector_builder(avg_selector_builder&& v) CPPLINQ_NOEXCEPT
				: selector(std::move(v.selector))
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				typedef typename get_transformed_type<selector_type, typename TRange::value_type>::type value_type;

				auto sum = value_type();
				int count = 0;
				while (range.next())
				{
					sum += selector(range.front());
					++count;
				}

				if (count == 0)
				{
					return sum;
				}

				return sum / count;
			}

		};

		struct avg_builder : base_builder
		{
			typedef avg_builder this_type;

			CPPLINQ_INLINEMETHOD avg_builder() CPPLINQ_NOEXCEPT
			{
			}

			CPPLINQ_INLINEMETHOD avg_builder(avg_builder const& v) CPPLINQ_NOEXCEPT
			{
			}

			CPPLINQ_INLINEMETHOD avg_builder(avg_builder&& v) CPPLINQ_NOEXCEPT
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				auto sum = typename TRange::value_type();
				int count = 0;
				while (range.next())
				{
					sum += range.front();
					++count;
				}

				if (count == 0)
				{
					return sum;
				}

				return sum / count;
			}
		};

		// -------------------------------------------------------------------------

		template <typename TAccumulator>
		struct aggregate_without_seed_builder : base_builder
		{
			typedef aggregate_without_seed_builder<TAccumulator> this_type;
			typedef TAccumulator accumulator_type;

			accumulator_type accumulator;

			CPPLINQ_INLINEMETHOD aggregate_without_seed_builder(accumulator_type accumulator) CPPLINQ_NOEXCEPT
				: accumulator(std::move(accumulator))
			{
			}

			CPPLINQ_INLINEMETHOD aggregate_without_seed_builder(aggregate_without_seed_builder const& v) CPPLINQ_NOEXCEPT
				: accumulator(v.accumulator)
			{
			}

			CPPLINQ_INLINEMETHOD aggregate_without_seed_builder(aggregate_without_seed_builder&& v) CPPLINQ_NOEXCEPT
				: accumulator(std::move(v.accumulator))
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range)
			{
				if (!range.next())
				{
					throw sequence_empty_exception();
				}

				auto sum = range.front();
				while (range.next())
				{
					sum = accumulator(sum, range.front());
				}
				return std::move(sum);
			}
		};

		// -------------------------------------------------------------------------

		template <typename TAccumulate, typename TAccumulator>
		struct aggregate_builder : base_builder
		{
			typedef aggregate_builder<TAccumulate, TAccumulator> this_type;
			typedef TAccumulator accumulator_type;
			typedef TAccumulate seed_type;

			seed_type seed;
			accumulator_type accumulator;

			CPPLINQ_INLINEMETHOD aggregate_builder(seed_type seed, accumulator_type accumulator) CPPLINQ_NOEXCEPT
				: seed(std::move(seed)),
				accumulator(std::move(accumulator))
			{
			}

			CPPLINQ_INLINEMETHOD aggregate_builder(aggregate_builder const& v) CPPLINQ_NOEXCEPT
				: seed(v.seed),
				accumulator(v.accumulator)
			{
			}

			CPPLINQ_INLINEMETHOD aggregate_builder(aggregate_builder&& v) CPPLINQ_NOEXCEPT
				: seed(std::move(v.seed)),
				accumulator(std::move(v.accumulator))
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				auto sum = seed;
				while (range.next())
				{
					sum = accumulator(sum, range.front());
				}
				return sum;
			}
		};

		template <typename TAccumulate, typename TAccumulator, typename TSelector>
		struct aggregate_result_selector_builder : base_builder
		{
			typedef aggregate_result_selector_builder<TAccumulate, TAccumulator, TSelector> this_type;
			typedef TAccumulator accumulator_type;
			typedef TAccumulate seed_type;
			typedef TSelector result_selector_type;

			seed_type seed;
			accumulator_type accumulator;
			result_selector_type result_selector;

			CPPLINQ_INLINEMETHOD aggregate_result_selector_builder(seed_type seed, accumulator_type accumulator, result_selector_type result_selector) CPPLINQ_NOEXCEPT
				: seed(std::move(seed)),
				accumulator(std::move(accumulator)),
				result_selector(std::move(result_selector))
			{
			}

			CPPLINQ_INLINEMETHOD aggregate_result_selector_builder(aggregate_result_selector_builder const& v) CPPLINQ_NOEXCEPT
				: seed(v.seed),
				accumulator(v.accumulator),
				result_selector(v.result_selector)
			{
			}

			CPPLINQ_INLINEMETHOD aggregate_result_selector_builder(aggregate_result_selector_builder&& v) CPPLINQ_NOEXCEPT
				: seed(std::move(v.seed)),
				accumulator(std::move(v.accumulator)),
				result_selector(std::move(v.result_selector))
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const -> decltype (result_selector(seed))
			{
				auto sum = seed;
				while (range.next())
				{
					sum = accumulator(sum, range.front());
				}

				return result_selector(sum);
			}
		};

		// -------------------------------------------------------------------------

		template <typename TOtherRange, typename TComparer>
		struct sequence_equal_predicate_builder : base_builder
		{
			typedef sequence_equal_predicate_builder<TOtherRange, TComparer> this_type;
			typedef TOtherRange other_range_type;
			typedef TComparer comparer_type;

			other_range_type other_range;
			comparer_type comparer;

			CPPLINQ_INLINEMETHOD sequence_equal_predicate_builder(TOtherRange other_range, comparer_type comparer) CPPLINQ_NOEXCEPT
				: other_range(std::move(other_range)),
				comparer(std::move(comparer))
			{
			}

			CPPLINQ_INLINEMETHOD sequence_equal_predicate_builder(sequence_equal_predicate_builder const& v) CPPLINQ_NOEXCEPT
				: other_range(v.other_range),
				comparer(v.comparer)
			{
			}

			CPPLINQ_INLINEMETHOD sequence_equal_predicate_builder(sequence_equal_predicate_builder&& v) CPPLINQ_NOEXCEPT
				: other_range(std::move(v.other_range)),
				comparer(std::move(v.comparer))
			{
			}

			template <typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				auto copy = other_range;
				for (;;)
				{
					bool next1 = range.next();
					bool next2 = copy.next();

					// sequences are not of same length
					if (next1 != next2)
					{
						return false;
					}

					// both sequences are over, next1 = next2 = false
					if (!next1)
					{
						return true;
					}

					if (!comparer(range.front(), copy.front()))
					{
						return false;
					}
				}
			}
		};

		template <typename TOtherRange>
		struct sequence_equal_builder : base_builder
		{
			typedef sequence_equal_builder<TOtherRange> this_type;
			typedef TOtherRange other_range_type;

			other_range_type other_range;

			CPPLINQ_INLINEMETHOD sequence_equal_builder(TOtherRange other_range) CPPLINQ_NOEXCEPT
				: other_range(std::move(other_range))
			{
			}

			CPPLINQ_INLINEMETHOD sequence_equal_builder(sequence_equal_builder const& v) CPPLINQ_NOEXCEPT
				: other_range(v.other_range)
			{
			}

			CPPLINQ_INLINEMETHOD sequence_equal_builder(sequence_equal_builder&& v) CPPLINQ_NOEXCEPT
				: other_range(std::move(v.other_range))
			{
			}

			template <typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				auto copy = other_range;
				for (;;)
				{
					bool next1 = range.next();
					bool next2 = copy.next();

					// sequences are not of same length
					if (next1 != next2)
					{
						return false;
					}

					// both sequences are over, next1 = next2 = false
					if (!next1)
					{
						return true;
					}

					if (range.front() != copy.front())
					{
						return false;
					}
				}
			}
		};

		// -------------------------------------------------------------------------

		template<typename TCharType>
		struct concatenate_builder : base_builder
		{
			typedef concatenate_builder<TCharType> this_type;

			std::basic_string<TCharType> separator;
			size_type capacity;

			CPPLINQ_INLINEMETHOD concatenate_builder(std::basic_string<TCharType> separator, size_type capacity) CPPLINQ_NOEXCEPT
				: separator(std::move(separator)),
				capacity(capacity)
			{
			}

			CPPLINQ_INLINEMETHOD concatenate_builder(concatenate_builder const& v) CPPLINQ_NOEXCEPT
				: separator(v.separator),
				capacity(v.capacity)
			{
			}

			CPPLINQ_INLINEMETHOD concatenate_builder(concatenate_builder&& v) CPPLINQ_NOEXCEPT
				: separator(std::move(v.separator)),
				capacity(std::move(v.capacity))
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				auto first = true;
				std::vector<TCharType> buffer;

				buffer.reserve(capacity);

				while (range.next())
				{
					if (first)
					{
						first = false;
					}
					else
					{
						buffer.insert(buffer.end(), separator.begin(), separator.end());
					}

					auto v = range.front();

					buffer.insert(buffer.end(), v.begin(), v.end());
				}

				return std::basic_string<TCharType>(buffer.begin(), buffer.end());
			}
		};

		// -------------------------------------------------------------------------

		template <typename TPredicate>
		struct any_predicate_builder : base_builder
		{
			typedef any_predicate_builder<TPredicate> this_type;
			typedef TPredicate predicate_type;

			predicate_type predicate;

			CPPLINQ_INLINEMETHOD any_predicate_builder(predicate_type predicate) CPPLINQ_NOEXCEPT
				: predicate(std::move(predicate))
			{
			}

			CPPLINQ_INLINEMETHOD any_predicate_builder(any_predicate_builder const& v) CPPLINQ_NOEXCEPT
				: predicate(v.predicate)
			{
			}

			CPPLINQ_INLINEMETHOD any_predicate_builder(any_predicate_builder&& v) CPPLINQ_NOEXCEPT
				: predicate(std::move(v.predicate))
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				bool any = false;
				while (range.next() && !any)
				{
					any = predicate(range.front());
				}
				return any;
			}
		};

		struct any_builder : base_builder
		{
			typedef any_builder this_type;

			CPPLINQ_INLINEMETHOD any_builder() CPPLINQ_NOEXCEPT
			{
			}

			CPPLINQ_INLINEMETHOD any_builder(any_builder const& v) CPPLINQ_NOEXCEPT
			{
			}

			CPPLINQ_INLINEMETHOD any_builder(any_builder&& v) CPPLINQ_NOEXCEPT
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				return range.next();
			}
		};

		// -------------------------------------------------------------------------

		template <typename TPredicate>
		struct all_predicate_builder : base_builder
		{
			typedef all_predicate_builder<TPredicate> this_type;
			typedef TPredicate predicate_type;

			predicate_type predicate;

			CPPLINQ_INLINEMETHOD all_predicate_builder(predicate_type predicate) CPPLINQ_NOEXCEPT
				: predicate(std::move(predicate))
			{
			}

			CPPLINQ_INLINEMETHOD all_predicate_builder(all_predicate_builder const& v) CPPLINQ_NOEXCEPT
				: predicate(v.predicate)
			{
			}

			CPPLINQ_INLINEMETHOD all_predicate_builder(all_predicate_builder&& v) CPPLINQ_NOEXCEPT
				: predicate(std::move(v.predicate))
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				while (range.next())
				{
					if (!predicate(range.front()))
					{
						return false;
					}
				}

				return true;
			}
		};

		// -------------------------------------------------------------------------

		template <typename TValue>
		struct contains_builder : base_builder
		{
			typedef contains_builder<TValue> this_type;
			typedef TValue value_type;

			value_type value;

			CPPLINQ_INLINEMETHOD contains_builder(value_type value) CPPLINQ_NOEXCEPT
				: value(std::move(value))
			{
			}

			CPPLINQ_INLINEMETHOD contains_builder(contains_builder const& v) CPPLINQ_NOEXCEPT
				: value(v.value)
			{
			}

			CPPLINQ_INLINEMETHOD contains_builder(contains_builder&& v) CPPLINQ_NOEXCEPT
				: value(std::move(v.value))
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				while (range.next())
				{
					if (range.front() == value)
					{
						return true;
					}
				}

				return false;
			}
		};

		template <typename TValue, typename TPredicate>
		struct contains_predicate_builder : base_builder
		{
			typedef contains_predicate_builder<TValue, TPredicate> this_type;
			typedef TValue value_type;
			typedef TPredicate predicate_type;

			value_type value;
			predicate_type predicate;

			CPPLINQ_INLINEMETHOD contains_predicate_builder(value_type value, predicate_type predicate) CPPLINQ_NOEXCEPT
				: value(std::move(value)),
				predicate(std::move(predicate))
			{
			}

			CPPLINQ_INLINEMETHOD contains_predicate_builder(contains_predicate_builder const& v) CPPLINQ_NOEXCEPT
				: value(v.value),
				predicate(v.predicate)
			{
			}

			CPPLINQ_INLINEMETHOD contains_predicate_builder(contains_predicate_builder&& v) CPPLINQ_NOEXCEPT
				: value(std::move(v.value)),
				predicate(std::move(v.predicate))
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				while (range.next())
				{
					if (predicate(range.front(), value))
					{
						return true;
					}
				}

				return false;
			}
		};

		// -------------------------------------------------------------------------

		struct element_at_or_default_builder : base_builder
		{
			typedef element_at_or_default_builder this_type;

			size_type index;

			CPPLINQ_INLINEMETHOD element_at_or_default_builder(size_type index) CPPLINQ_NOEXCEPT
				: index(std::move(index))
			{
			}

			CPPLINQ_INLINEMETHOD element_at_or_default_builder(element_at_or_default_builder const& v) CPPLINQ_NOEXCEPT
				: index(v.index)
			{
			}

			CPPLINQ_INLINEMETHOD element_at_or_default_builder(element_at_or_default_builder&& v) CPPLINQ_NOEXCEPT
				: index(std::move(v.index))
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				size_type current = 0U;

				while (range.next())
				{
					if (current < index)
					{
						++current;
					}
					else
					{
						return range.front();
					}
				}

				return typename TRange::value_type();
			}
		};

		// -------------------------------------------------------------------------

		struct element_at_builder : base_builder
		{
			typedef element_at_builder this_type;

			size_type index;

			CPPLINQ_INLINEMETHOD element_at_builder(size_type index) CPPLINQ_NOEXCEPT
				: index(std::move(index))
			{
			}

			CPPLINQ_INLINEMETHOD element_at_builder(element_at_builder const& v) CPPLINQ_NOEXCEPT
				: index(v.index)
			{
			}

			CPPLINQ_INLINEMETHOD element_at_builder(element_at_builder&& v) CPPLINQ_NOEXCEPT
				: index(std::move(v.index))
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range)
			{
				size_type current = 0U;

				while (range.next())
				{
					if (current < index)
					{
						++current;
					}
					else
					{
						return range.front();
					}
				}

				throw out_of_range_exception();
			}
		};

		// -------------------------------------------------------------------------

		template<typename TRange>
		struct pairwise_range : base_range
		{
			typedef pairwise_range<TRange> this_type;
			typedef TRange range_type;

			typedef typename TRange::value_type element_type;
			typedef std::pair<element_type, element_type> value_type;
			typedef value_type return_type;

			enum
			{
				returns_reference = 0,
			};

			range_type range;
			opt<element_type> previous;
			opt<element_type> current;

			CPPLINQ_INLINEMETHOD pairwise_range(range_type range) CPPLINQ_NOEXCEPT
				: range(std::move(range))
			{
			}

			CPPLINQ_INLINEMETHOD pairwise_range(pairwise_range const& v) CPPLINQ_NOEXCEPT
				: range(v.range),
				previous(v.previous),
				current(v.current)
			{
			}

			CPPLINQ_INLINEMETHOD pairwise_range(pairwise_range&& v) CPPLINQ_NOEXCEPT
				: range(std::move(v.range)),
				previous(std::move(v.previous)),
				current(std::move(v.current))
			{
			}

			template<typename TPairwiseBuilder>
			CPPLINQ_INLINEMETHOD auto operator>>(TPairwiseBuilder pairwise_builder) const
			{
				return pairwise_builder.build(*this);
			}

			CPPLINQ_INLINEMETHOD auto front() const
			{
				CPPLINQ_ASSERT(previous.has_value());
				CPPLINQ_ASSERT(current.has_value());

				return std::make_pair(previous.get(), current.get());
			}

			CPPLINQ_INLINEMETHOD auto next()
			{
				if (!previous.has_value())
				{
					if (range.next())
					{
						current = range.front();
					}
					else
					{
						return false;
					}
				}

				previous.swap(current);

				if (range.next())
				{
					current = range.front();
					return true;
				}

				previous.clear();
				current.clear();

				return false;
			}
		};

		struct pairwise_builder : base_builder
		{
			typedef pairwise_builder this_type;

			CPPLINQ_INLINEMETHOD pairwise_builder() CPPLINQ_NOEXCEPT
			{
			}

			CPPLINQ_INLINEMETHOD pairwise_builder(pairwise_builder const& v) CPPLINQ_NOEXCEPT
			{
			}

			CPPLINQ_INLINEMETHOD pairwise_builder(pairwise_builder&& v) CPPLINQ_NOEXCEPT
			{
			}

			template<typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				return pairwise_range<TRange>(std::move(range));
			}
		};

		// -------------------------------------------------------------------------

		template<typename TRange, typename TOtherRange>
		struct zip_with_range : base_range
		{
			typedef zip_with_range<TRange, TOtherRange> this_type;
			typedef TRange range_type;
			typedef TOtherRange other_range_type;

			typedef typename cleanup_type<typename TRange::value_type>::type left_element_type;
			typedef typename cleanup_type<typename TOtherRange::value_type>::type right_element_type;
			typedef std::pair<left_element_type, right_element_type> value_type;
			typedef value_type return_type;
			enum
			{
				returns_reference = 0,
			};

			range_type range;
			other_range_type other_range;

			CPPLINQ_INLINEMETHOD zip_with_range(range_type range, other_range_type other_range) CPPLINQ_NOEXCEPT
				: range(std::move(range)),
				other_range(std::move(other_range))
			{
			}

			CPPLINQ_INLINEMETHOD zip_with_range(zip_with_range const& v) CPPLINQ_NOEXCEPT
				: range(v.range),
				other_range(v.other_range)
			{
			}

			CPPLINQ_INLINEMETHOD zip_with_range(zip_with_range&& v) CPPLINQ_NOEXCEPT
				: range(std::move(v.range)),
				other_range(std::move(v.other_range))
			{
			}

			template<typename TRangeBuilder>
			CPPLINQ_INLINEMETHOD auto operator>>(TRangeBuilder range_builder) const
			{
				return range_builder.build(*this);
			}

			CPPLINQ_INLINEMETHOD auto front() const
			{
				return std::make_pair(range.front(), other_range.front());
			}

			CPPLINQ_INLINEMETHOD auto next()
			{
				return range.next() && other_range.next();
			}
		};

		template <typename TOtherRange>
		struct zip_with_builder : base_builder
		{
			typedef zip_with_builder<TOtherRange> this_type;
			typedef TOtherRange other_range_type;

			other_range_type other_range;

			CPPLINQ_INLINEMETHOD zip_with_builder(TOtherRange other_range) CPPLINQ_NOEXCEPT
				: other_range(std::move(other_range))
			{
			}

			CPPLINQ_INLINEMETHOD zip_with_builder(zip_with_builder const& v) CPPLINQ_NOEXCEPT
				: other_range(v.other_range)
			{
			}

			CPPLINQ_INLINEMETHOD zip_with_builder(zip_with_builder&& v) CPPLINQ_NOEXCEPT
				: other_range(std::move(v.other_range))
			{
			}

			template <typename TRange>
			CPPLINQ_INLINEMETHOD auto build(TRange range) const
			{
				return zip_with_range<TRange, TOtherRange>(std::move(range), std::move(other_range));
			}
		};

		// -------------------------------------------------------------------------

		template<typename TPredicate>
		struct generate_range : base_range
		{
			static TPredicate get_predicate();

			typedef decltype (get_predicate()()) raw_opt_value_type;
			typedef typename cleanup_type<raw_opt_value_type>::type opt_value_type;

			typedef decltype (*(get_predicate()())) raw_value_type;
			typedef typename cleanup_type<raw_value_type>::type value_type;

			typedef generate_range<TPredicate> this_type;
			typedef TPredicate predicate_type;
			typedef value_type const& return_type;

			enum
			{
				returns_reference = 1,
			};

			TPredicate predicate;
			opt_value_type current_value;

			CPPLINQ_INLINEMETHOD generate_range(TPredicate predicate) CPPLINQ_NOEXCEPT
				: predicate(std::move(predicate))
			{
			}

			CPPLINQ_INLINEMETHOD generate_range(generate_range const& v) CPPLINQ_NOEXCEPT
				: predicate(v.predicate),
				current_value(v.current_value)
			{
			}

			CPPLINQ_INLINEMETHOD generate_range(generate_range&& v) CPPLINQ_NOEXCEPT
				: predicate(std::move(v.predicate)),
				current_value(std::move(v.current_value))
			{
			}

			template<typename TRangeBuilder>
			CPPLINQ_INLINEMETHOD auto operator>>(TRangeBuilder range_builder) const
			{
				return range_builder.build(*this);
			}

			CPPLINQ_INLINEMETHOD auto front() const
			{
				CPPLINQ_ASSERT(current_value);

				return *current_value;
			}

			CPPLINQ_INLINEMETHOD auto next() CPPLINQ_NOEXCEPT
			{
				current_value = predicate();

				return current_value;
			}
		};

		// -------------------------------------------------------------------------

	} // namespace detail

	// -------------------------------------------------------------------------
	// The interface of cpplinq
	// -------------------------------------------------------------------------

	// Range sources

	template<typename TValueIterator>
	CPPLINQ_INLINEMETHOD auto from_iterators(TValueIterator begin, TValueIterator end) CPPLINQ_NOEXCEPT
	{
		return detail::from_range<TValueIterator>(std::move(begin), std::move(end));
	}

	template<typename TContainer>
	CPPLINQ_INLINEMETHOD auto from(TContainer const& container) CPPLINQ_NOEXCEPT
	{
		return from_iterators(container.begin(), container.end());
	}

	template<typename TValueArray>
	CPPLINQ_INLINEMETHOD auto from_array(TValueArray& a) CPPLINQ_NOEXCEPT
	{
		typedef detail::get_array_properties<TValueArray> array_properties;
		typedef typename array_properties::iterator_type iterator_type;

		iterator_type begin = a;
		iterator_type end = begin + array_properties::size;

		return from_iterators(std::move(begin), std::move(end));
	}

	template<typename TContainer>
	CPPLINQ_INLINEMETHOD auto from_copy(TContainer&& container)
	{
		typedef typename detail::cleanup_type<TContainer>::type container_type;

		return detail::from_copy_range<container_type>(std::forward<TContainer>(container));
	}

	template<typename TPredicate>
	CPPLINQ_INLINEMETHOD auto generate(TPredicate predicate) CPPLINQ_NOEXCEPT
	{
		return detail::generate_range<TPredicate>(std::move(predicate));
	}

	// Restriction operators

	template<typename TPredicate>
	CPPLINQ_INLINEMETHOD auto where(TPredicate predicate) CPPLINQ_NOEXCEPT
	{
		return detail::where_builder<TPredicate>(std::move(predicate));
	}

	// Projection operators

	CPPLINQ_INLINEMETHOD auto ref() CPPLINQ_NOEXCEPT
	{
		return detail::ref_builder();
	}

	template<typename TPredicate>
	CPPLINQ_INLINEMETHOD auto select(TPredicate predicate) CPPLINQ_NOEXCEPT
	{
		return detail::select_builder<TPredicate>(std::move(predicate));
	}

	template<typename TPredicate>
	CPPLINQ_INLINEMETHOD auto select_many(TPredicate predicate) CPPLINQ_NOEXCEPT
	{
		return detail::select_many_builder<TPredicate>(std::move(predicate));
	}

	template<typename TOtherRange, typename TKeySelector, typename TOtherKeySelector, typename TCombiner>
	CPPLINQ_INLINEMETHOD auto join(TOtherRange other_range, TKeySelector key_selector, TOtherKeySelector other_key_selector, TCombiner combiner) CPPLINQ_NOEXCEPT
	{
		return detail::join_builder<TOtherRange, TKeySelector, TOtherKeySelector, TCombiner>
			(std::move(other_range), std::move(key_selector), std::move(other_key_selector), std::move(combiner));
	}

	// Concatenation operators

	template <typename TOtherRange>
	CPPLINQ_INLINEMETHOD auto concat(TOtherRange other_range) CPPLINQ_NOEXCEPT
	{
		return detail::concat_builder<TOtherRange>(std::move(other_range));
	}

	template <typename TOtherRange>
	CPPLINQ_INLINEMETHOD auto start_with(TOtherRange other_range) CPPLINQ_NOEXCEPT
	{
		return detail::start_with_builder<TOtherRange>(std::move(other_range));
	}

	// Partitioning operators

	template<typename TPredicate>
	CPPLINQ_INLINEMETHOD auto take_while(TPredicate predicate) CPPLINQ_NOEXCEPT
	{
		return detail::take_while_builder<TPredicate>(std::move(predicate));
	}

	CPPLINQ_INLINEMETHOD auto take(size_type count) CPPLINQ_NOEXCEPT
	{
		return detail::take_builder(count);
	}

	template <typename TPredicate>
	CPPLINQ_INLINEMETHOD auto skip_while(TPredicate predicate) CPPLINQ_NOEXCEPT
	{
		return detail::skip_while_builder<TPredicate>(predicate);
	}

	CPPLINQ_INLINEMETHOD auto skip(size_type count) CPPLINQ_NOEXCEPT
	{
		return detail::skip_builder(count);
	}

	// Ordering operators

	template<typename TPredicate>
	CPPLINQ_INLINEMETHOD auto orderby(TPredicate predicate, bool sort_ascending = true) CPPLINQ_NOEXCEPT
	{
		return detail::orderby_builder<TPredicate>(std::move(predicate), sort_ascending);
	}

	template<typename TPredicate>
	CPPLINQ_INLINEMETHOD auto orderby_ascending(TPredicate predicate) CPPLINQ_NOEXCEPT
	{
		return detail::orderby_builder<TPredicate>(std::move(predicate), true);
	}

	template<typename TPredicate>
	CPPLINQ_INLINEMETHOD auto orderby_descending(TPredicate predicate) CPPLINQ_NOEXCEPT
	{
		return detail::orderby_builder<TPredicate>(std::move(predicate), false);
	}

	template<typename TPredicate>
	CPPLINQ_INLINEMETHOD auto thenby(TPredicate predicate, bool sort_ascending = true) CPPLINQ_NOEXCEPT
	{
		return detail::thenby_builder<TPredicate>(std::move(predicate), sort_ascending);
	}

	template<typename TPredicate>
	CPPLINQ_INLINEMETHOD auto thenby_ascending(TPredicate predicate) CPPLINQ_NOEXCEPT
	{
		return detail::thenby_builder<TPredicate>(std::move(predicate), true);
	}

	template<typename TPredicate>
	CPPLINQ_INLINEMETHOD auto thenby_descending(TPredicate predicate) CPPLINQ_NOEXCEPT
	{
		return detail::thenby_builder<TPredicate>(std::move(predicate), false);
	}

	CPPLINQ_INLINEMETHOD auto reverse(size_type capacity = 16U) CPPLINQ_NOEXCEPT
	{
		return detail::reverse_builder(capacity);
	}

	// Conversion operators

	namespace experimental
	{
		CPPLINQ_INLINEMETHOD auto container() CPPLINQ_NOEXCEPT
		{
			return detail::experimental::container_builder();
		}
	}

	template<typename TValue>
	CPPLINQ_INLINEMETHOD auto to_opt(TValue&& v)
	{
		return detail::opt<typename detail::cleanup_type<TValue>::type>(std::forward<TValue>(v));
	}

	template<typename TValue>
	CPPLINQ_INLINEMETHOD auto to_opt()
	{
		return detail::opt<TValue>();
	}

	CPPLINQ_INLINEMETHOD auto to_vector(size_type capacity = 16U) CPPLINQ_NOEXCEPT
	{
		return detail::to_vector_builder(capacity);
	}

	CPPLINQ_INLINEMETHOD auto to_deque() CPPLINQ_NOEXCEPT
	{
		return detail::to_deque_builder();
	}

	CPPLINQ_INLINEMETHOD auto to_list() CPPLINQ_NOEXCEPT
	{
		return detail::to_list_builder();
	}

	template<typename TKeySelector>
	CPPLINQ_INLINEMETHOD auto to_map(TKeySelector key_selector) CPPLINQ_NOEXCEPT
	{
		return detail::to_map_builder<TKeySelector>(std::move(key_selector));
	}

	template<typename TKeySelector>
	CPPLINQ_INLINEMETHOD auto to_lookup(TKeySelector key_selector) CPPLINQ_NOEXCEPT
	{
		return detail::to_lookup_builder<TKeySelector>(std::move(key_selector));
	}

	template<typename TKeySelector, typename TValueSelector>
	CPPLINQ_INLINEMETHOD auto to_lookup(TKeySelector key_selector, TValueSelector value_selector) CPPLINQ_NOEXCEPT
	{
		return detail::to_lookup_value_selector_builder<TKeySelector, TValueSelector>(std::move(key_selector), std::move(value_selector));
	}

	// Equality operators

	template <typename TOtherRange>
	CPPLINQ_INLINEMETHOD auto sequence_equal(TOtherRange other_range) CPPLINQ_NOEXCEPT
	{
		return detail::sequence_equal_builder<TOtherRange>(std::move(other_range));
	}

	template <typename TOtherRange, typename TComparer>
	CPPLINQ_INLINEMETHOD auto sequence_equal(TOtherRange other_range, TComparer comparer) CPPLINQ_NOEXCEPT
	{
		return detail::sequence_equal_predicate_builder<TOtherRange, TComparer>(std::move(other_range), std::move(comparer));
	}

	// Element operators

	template <typename TPredicate>
	CPPLINQ_INLINEMETHOD auto first(TPredicate predicate)
	{
		return detail::first_predicate_builder<TPredicate>(std::move(predicate));
	}

	CPPLINQ_INLINEMETHOD auto first()
	{
		return detail::first_builder();
	}

	template <typename TPredicate>
	CPPLINQ_INLINEMETHOD auto first_or_default(TPredicate predicate) CPPLINQ_NOEXCEPT
	{
		return detail::first_or_default_predicate_builder<TPredicate>(predicate);
	}

	CPPLINQ_INLINEMETHOD auto first_or_default() CPPLINQ_NOEXCEPT
	{
		return detail::first_or_default_builder();
	}

	template <typename TPredicate>
	CPPLINQ_INLINEMETHOD auto last_or_default(TPredicate predicate) CPPLINQ_NOEXCEPT
	{
		return detail::last_or_default_predicate_builder<TPredicate>(std::move(predicate));
	}

	template <typename TPredicate>
	CPPLINQ_INLINEMETHOD auto last(TPredicate predicate)
	{
		return detail::last_predicate_builder<TPredicate>(std::move(predicate));
	}

	CPPLINQ_INLINEMETHOD auto last()
	{
		return detail::last_builder();
	}

	CPPLINQ_INLINEMETHOD auto last_or_default() CPPLINQ_NOEXCEPT
	{
		return detail::last_or_default_builder();
	}

	CPPLINQ_INLINEMETHOD auto element_at(size_type index) CPPLINQ_NOEXCEPT
	{
		return detail::element_at_builder(index);
	}

	CPPLINQ_INLINEMETHOD auto element_at_or_default(size_type index) CPPLINQ_NOEXCEPT
	{
		return detail::element_at_or_default_builder(index);
	}

	// Generation operators

	CPPLINQ_INLINEMETHOD auto range(int start, int count) CPPLINQ_NOEXCEPT
	{
		auto c = count > 0 ? count : 0;
		auto end = (INT_MAX - c) > start ? (start + c) : INT_MAX;
		return detail::int_range(start, end);
	}

	template <typename TValue>
	CPPLINQ_INLINEMETHOD auto repeat(TValue element, int count) CPPLINQ_NOEXCEPT
	{
		auto c = count > 0 ? count : 0;
		return detail::repeat_range<TValue>(element, c);
	}

	template <typename TValue>
	CPPLINQ_INLINEMETHOD auto empty() CPPLINQ_NOEXCEPT
	{
		return detail::empty_range<TValue>();
	}

	template<typename TValue>
	CPPLINQ_INLINEMETHOD auto singleton(TValue && value) CPPLINQ_NOEXCEPT
	{
		return detail::singleton_range<typename detail::cleanup_type<TValue>::type>(std::forward<TValue>(value));
	}

	// Quantifiers

	template <typename TPredicate>
	CPPLINQ_INLINEMETHOD auto any(TPredicate predicate) CPPLINQ_NOEXCEPT
	{
		return detail::any_predicate_builder<TPredicate>(std::move(predicate));
	}

	CPPLINQ_INLINEMETHOD auto any() CPPLINQ_NOEXCEPT
	{
		return detail::any_builder();
	}

	template <typename TPredicate>
	CPPLINQ_INLINEMETHOD auto all(TPredicate predicate) CPPLINQ_NOEXCEPT
	{
		return detail::all_predicate_builder<TPredicate>(std::move(predicate));
	}

	template <typename TValue>
	CPPLINQ_INLINEMETHOD auto contains(TValue value) CPPLINQ_NOEXCEPT
	{
		return detail::contains_builder<TValue>(value);
	}

	template <typename TValue, typename TPredicate>
	CPPLINQ_INLINEMETHOD auto contains(TValue value, TPredicate predicate) CPPLINQ_NOEXCEPT
	{
		return detail::contains_predicate_builder<TValue, TPredicate>(value, std::move(predicate));
	}

	// Aggregate operators

	template <typename TPredicate>
	CPPLINQ_INLINEMETHOD auto count(TPredicate predicate) CPPLINQ_NOEXCEPT
	{
		return detail::count_predicate_builder<TPredicate>(std::move(predicate));
	}

	CPPLINQ_INLINEMETHOD auto count() CPPLINQ_NOEXCEPT
	{
		return detail::count_builder();
	}

	template<typename TSelector>
	CPPLINQ_INLINEMETHOD auto sum(TSelector selector) CPPLINQ_NOEXCEPT
	{
		return detail::sum_selector_builder<TSelector>(std::move(selector));
	}

	CPPLINQ_INLINEMETHOD auto sum() CPPLINQ_NOEXCEPT
	{
		return detail::sum_builder();
	}

	template<typename TSelector>
	CPPLINQ_INLINEMETHOD auto max(TSelector selector) CPPLINQ_NOEXCEPT
	{
		return detail::max_selector_builder<TSelector>(std::move(selector));
	}

	CPPLINQ_INLINEMETHOD auto max() CPPLINQ_NOEXCEPT
	{
		return detail::max_builder();
	}

	template<typename TSelector>
	CPPLINQ_INLINEMETHOD auto min(TSelector selector) CPPLINQ_NOEXCEPT
	{
		return detail::min_selector_builder<TSelector>(std::move(selector));
	}

	CPPLINQ_INLINEMETHOD auto min() CPPLINQ_NOEXCEPT
	{
		return detail::min_builder();
	}

	template<typename TSelector>
	CPPLINQ_INLINEMETHOD auto avg(TSelector selector) CPPLINQ_NOEXCEPT
	{
		return detail::avg_selector_builder<TSelector>(std::move(selector));
	}

	CPPLINQ_INLINEMETHOD auto avg() CPPLINQ_NOEXCEPT
	{
		return detail::avg_builder();
	}

	template <typename TAccumulator>
	CPPLINQ_INLINEMETHOD auto aggregate(TAccumulator accumulator) CPPLINQ_NOEXCEPT
	{
		return detail::aggregate_without_seed_builder<TAccumulator>(accumulator);
	}

	template <typename TAccumulate, typename TAccumulator>
	CPPLINQ_INLINEMETHOD auto aggregate(TAccumulate seed, TAccumulator accumulator) CPPLINQ_NOEXCEPT
	{
		return detail::aggregate_builder<TAccumulate, TAccumulator>(seed, accumulator);
	}

	template <typename TAccumulate, typename TAccumulator, typename TSelector>
	CPPLINQ_INLINEMETHOD auto aggregate(TAccumulate seed, TAccumulator accumulator, TSelector result_selector) CPPLINQ_NOEXCEPT
	{
		return detail::aggregate_result_selector_builder<TAccumulate, TAccumulator, TSelector>(seed, accumulator, result_selector);
	}

	// set operators
	CPPLINQ_INLINEMETHOD auto distinct() CPPLINQ_NOEXCEPT
	{
		return detail::distinct_builder();
	}

	template <typename TSelector>
	CPPLINQ_INLINEMETHOD auto distinct(TSelector key_selector) CPPLINQ_NOEXCEPT
	{
		return detail::distinct_key_selector_builder<TSelector>(key_selector);
	}

	template <typename TOtherRange>
	CPPLINQ_INLINEMETHOD auto union_with(TOtherRange other_range) CPPLINQ_NOEXCEPT
	{
		return detail::union_builder<TOtherRange>(std::move(other_range));
	}

	template <typename TOtherRange>
	CPPLINQ_INLINEMETHOD auto intersect_with(TOtherRange other_range) CPPLINQ_NOEXCEPT
	{
		return detail::intersect_builder<TOtherRange>(std::move(other_range));
	}

	template <typename TOtherRange>
	CPPLINQ_INLINEMETHOD auto except(TOtherRange other_range) CPPLINQ_NOEXCEPT
	{
		return detail::except_builder<TOtherRange>(std::move(other_range));
	}

	// other operators

	template<typename TPredicate>
	CPPLINQ_INLINEMETHOD auto for_each(TPredicate predicate) CPPLINQ_NOEXCEPT
	{
		return detail::for_each_builder<TPredicate>(std::move(predicate));
	}

	CPPLINQ_INLINEMETHOD auto concatenate(std::string separator, size_type capacity = 16U) CPPLINQ_NOEXCEPT
	{
		return detail::concatenate_builder<char>(std::move(separator), capacity);
	}

	CPPLINQ_INLINEMETHOD auto concatenate(std::wstring separator, size_type capacity = 16U) CPPLINQ_NOEXCEPT
	{
		return detail::concatenate_builder<wchar_t>(std::move(separator), capacity);
	}

	CPPLINQ_INLINEMETHOD auto pairwise() CPPLINQ_NOEXCEPT
	{
		return detail::pairwise_builder();
	}

	template <typename TOtherRange>
	CPPLINQ_INLINEMETHOD auto zip_with(TOtherRange other_range) CPPLINQ_NOEXCEPT
	{
		return detail::zip_with_builder<TOtherRange>(std::move(other_range));
	}

	// -------------------------------------------------------------------------

}
// ----------------------------------------------------------------------------
#ifdef _MSC_VER
#   pragma warning (pop)
#endif
// ----------------------------------------------------------------------------
#endif // CPPLINQ__HEADER_GUARD
// ----------------------------------------------------------------------------
```

`UnrealFinderTool/SdkGen/Engine/tinyformat.h`:

```h
// tinyformat.h
// Copyright (C) 2011, Chris Foster [chris42f (at) gmail (d0t) com]
//
// Boost Software License - Version 1.0
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//------------------------------------------------------------------------------
// Tinyformat: A minimal type safe printf replacement
//
// tinyformat.h is a type safe printf replacement library in a single C++
// header file.  Design goals include:
//
// * Type safety and extensibility for user defined types.
// * C99 printf() compatibility, to the extent possible using std::ostream
// * Simplicity and minimalism.  A single header file to include and distribute
//   with your projects.
// * Augment rather than replace the standard stream formatting mechanism
// * C++98 support, with optional C++11 niceties
//
//
// Main interface example usage
// ----------------------------
//
// To print a date to std::cout:
//
//   std::string weekday = "Wednesday";
//   const char* month = "July";
//   size_t day = 27;
//   long hour = 14;
//   int min = 44;
//
//   tfm::printf("%s, %s %d, %.2d:%.2d\n", weekday, month, day, hour, min);
//
// The strange types here emphasize the type safety of the interface; it is
// possible to print a std::string using the "%s" conversion, and a
// size_t using the "%d" conversion.  A similar result could be achieved
// using either of the tfm::format() functions.  One prints on a user provided
// stream:
//
//   tfm::format(std::cerr, "%s, %s %d, %.2d:%.2d\n",
//               weekday, month, day, hour, min);
//
// The other returns a std::string:
//
//   std::string date = tfm::format("%s, %s %d, %.2d:%.2d\n",
//                                  weekday, month, day, hour, min);
//   std::cout << date;
//
// These are the three primary interface functions.  There is also a
// convenience function printfln() which appends a newline to the usual result
// of printf() for super simple logging.
//
//
// User defined format functions
// -----------------------------
//
// Simulating variadic templates in C++98 is pretty painful since it requires
// writing out the same function for each desired number of arguments.  To make
// this bearable tinyformat comes with a set of macros which are used
// internally to generate the API, but which may also be used in user code.
//
// The three macros TINYFORMAT_ARGTYPES(n), TINYFORMAT_VARARGS(n) and
// TINYFORMAT_PASSARGS(n) will generate a list of n argument types,
// type/name pairs and argument names respectively when called with an integer
// n between 1 and 16.  We can use these to define a macro which generates the
// desired user defined function with n arguments.  To generate all 16 user
// defined function bodies, use the macro TINYFORMAT_FOREACH_ARGNUM.  For an
// example, see the implementation of printf() at the end of the source file.
//
// Sometimes it's useful to be able to pass a list of format arguments through
// to a non-template function.  The FormatList class is provided as a way to do
// this by storing the argument list in a type-opaque way.  Continuing the
// example from above, we construct a FormatList using makeFormatList():
//
//   FormatListRef formatList = tfm::makeFormatList(weekday, month, day, hour, min);
//
// The format list can now be passed into any non-template function and used
// via a call to the vformat() function:
//
//   tfm::vformat(std::cout, "%s, %s %d, %.2d:%.2d\n", formatList);
//
//
// Additional API information
// --------------------------
//
// Error handling: Define TINYFORMAT_ERROR to customize the error handling for
// format strings which are unsupported or have the wrong number of format
// specifiers (calls assert() by default).
//
// User defined types: Uses operator<< for user defined types by default.
// Overload formatValue() for more control.


#ifndef TINYFORMAT_H_INCLUDED
#define TINYFORMAT_H_INCLUDED

namespace tinyformat {}
//------------------------------------------------------------------------------
// Config section.  Customize to your liking!

// Namespace alias to encourage brevity
namespace tfm = tinyformat;

// Error handling; calls assert() by default.
// #define TINYFORMAT_ERROR(reasonString) your_error_handler(reasonString)

// Define for C++11 variadic templates which make the code shorter & more
// general.  If you don't define this, C++11 support is autodetected below.
#define TINYFORMAT_USE_VARIADIC_TEMPLATES


//------------------------------------------------------------------------------
// Implementation details.
#include <algorithm>
#include <cassert>
#include <iostream>
#include <sstream>

#ifndef TINYFORMAT_ERROR
#   define TINYFORMAT_ERROR(reason) assert(0 && reason)
#endif

#if !defined(TINYFORMAT_USE_VARIADIC_TEMPLATES) && !defined(TINYFORMAT_NO_VARIADIC_TEMPLATES)
#   ifdef __GXX_EXPERIMENTAL_CXX0X__
#       define TINYFORMAT_USE_VARIADIC_TEMPLATES
#   endif
#endif

#ifdef TINYFORMAT_USE_VARIADIC_TEMPLATES
#   include <array>
#   if defined(_MSC_VER) && _MSC_VER <= 1800 // VS2013
#       define TINYFORMAT_BRACED_INIT_WORKAROUND(x) (x)
#   else
#       define TINYFORMAT_BRACED_INIT_WORKAROUND(x) {x}
#   endif
#endif

#if defined(__GLIBCXX__) && __GLIBCXX__ < 20080201
//  std::showpos is broken on old libstdc++ as provided with OSX.  See
//  http://gcc.gnu.org/ml/libstdc++/2007-11/msg00075.html
#   define TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND
#endif

#ifdef __APPLE__
// Workaround OSX linker warning: xcode uses different default symbol
// visibilities for static libs vs executables (see issue #25)
#   define TINYFORMAT_HIDDEN __attribute__((visibility("hidden")))
#else
#   define TINYFORMAT_HIDDEN
#endif

namespace tinyformat {

//------------------------------------------------------------------------------
namespace detail {

// Test whether type T1 is convertible to type T2
template <typename T1, typename T2>
struct is_convertible
{
    private:
        // two types of different size
        struct fail { char dummy[2]; };
        struct succeed { char dummy; };
        // Try to convert a T1 to a T2 by plugging into tryConvert
        static fail tryConvert(...);
        static succeed tryConvert(const T2&);
        static const T1& makeT1();
    public:
#       ifdef _MSC_VER
        // Disable spurious loss of precision warnings in tryConvert(makeT1())
#       pragma warning(push)
#       pragma warning(disable:4244)
#       pragma warning(disable:4267)
#       endif
        // Standard trick: the (...) version of tryConvert will be chosen from
        // the overload set only if the version taking a T2 doesn't match.
        // Then we compare the sizes of the return types to check which
        // function matched.  Very neat, in a disgusting kind of way :)
        static const bool value =
            sizeof(tryConvert(makeT1())) == sizeof(succeed);
#       ifdef _MSC_VER
#       pragma warning(pop)
#       endif
};


// Detect when a type is not a wchar_t string
template<typename T> struct is_wchar { typedef int tinyformat_wchar_is_not_supported; };
template<> struct is_wchar<wchar_t*> {};
template<> struct is_wchar<const wchar_t*> {};
template<int n> struct is_wchar<const wchar_t[n]> {};
template<int n> struct is_wchar<wchar_t[n]> {};


// Format the value by casting to type fmtT.  This default implementation
// should never be called.
template<typename T, typename fmtT, bool convertible = is_convertible<T, fmtT>::value>
struct formatValueAsType
{
    static void invoke(std::ostream& /*out*/, const T& /*value*/) { assert(0); }
};
// Specialized version for types that can actually be converted to fmtT, as
// indicated by the "convertible" template parameter.
template<typename T, typename fmtT>
struct formatValueAsType<T,fmtT,true>
{
    static void invoke(std::ostream& out, const T& value)
        { out << static_cast<fmtT>(value); }
};

#ifdef TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND
template<typename T, bool convertible = is_convertible<T, int>::value>
struct formatZeroIntegerWorkaround
{
    static bool invoke(std::ostream& /**/, const T& /**/) { return false; }
};
template<typename T>
struct formatZeroIntegerWorkaround<T,true>
{
    static bool invoke(std::ostream& out, const T& value)
    {
        if (static_cast<int>(value) == 0 && out.flags() & std::ios::showpos)
        {
            out << "+0";
            return true;
        }
        return false;
    }
};
#endif // TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND

// Convert an arbitrary type to integer.  The version with convertible=false
// throws an error.
template<typename T, bool convertible = is_convertible<T,int>::value>
struct convertToInt
{
    static int invoke(const T& /*value*/)
    {
        TINYFORMAT_ERROR("tinyformat: Cannot convert from argument type to "
                         "integer for use as variable width or precision");
        return 0;
    }
};
// Specialization for convertToInt when conversion is possible
template<typename T>
struct convertToInt<T,true>
{
    static int invoke(const T& value) { return static_cast<int>(value); }
};

// Format at most ntrunc characters to the given stream.
template<typename T>
inline void formatTruncated(std::ostream& out, const T& value, int ntrunc)
{
    std::ostringstream tmp;
    tmp << value;
    std::string result = tmp.str();
    out.write(result.c_str(), std::min(ntrunc, static_cast<int>(result.size())));
}
#define TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR(type)       \
inline void formatTruncated(std::ostream& out, type* value, int ntrunc) \
{                                                           \
    std::streamsize len = 0;                                \
    while(len < ntrunc && value[len] != 0)                  \
        ++len;                                              \
    out.write(value, len);                                  \
}
// Overload for const char* and char*.  Could overload for signed & unsigned
// char too, but these are technically unneeded for printf compatibility.
TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR(const char)
TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR(char)
#undef TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR

} // namespace detail


//------------------------------------------------------------------------------
// Variable formatting functions.  May be overridden for user-defined types if
// desired.


/// Format a value into a stream, delegating to operator<< by default.
///
/// Users may override this for their own types.  When this function is called,
/// the stream flags will have been modified according to the format string.
/// The format specification is provided in the range [fmtBegin, fmtEnd).  For
/// truncating conversions, ntrunc is set to the desired maximum number of
/// characters, for example "%.7s" calls formatValue with ntrunc = 7.
///
/// By default, formatValue() uses the usual stream insertion operator
/// operator<< to format the type T, with special cases for the %c and %p
/// conversions.
template<typename T>
inline void formatValue(std::ostream& out, const char* /*fmtBegin*/,
                        const char* fmtEnd, int ntrunc, const T& value)
{
#ifndef TINYFORMAT_ALLOW_WCHAR_STRINGS
    // Since we don't support printing of wchar_t using "%ls", make it fail at
    // compile time in preference to printing as a void* at runtime.
    typedef typename detail::is_wchar<T>::tinyformat_wchar_is_not_supported DummyType;
    (void) DummyType(); // avoid unused type warning with gcc-4.8
#endif
    // The mess here is to support the %c and %p conversions: if these
    // conversions are active we try to convert the type to a char or const
    // void* respectively and format that instead of the value itself.  For the
    // %p conversion it's important to avoid dereferencing the pointer, which
    // could otherwise lead to a crash when printing a dangling (const char*).
    bool canConvertToChar = detail::is_convertible<T,char>::value;
    bool canConvertToVoidPtr = detail::is_convertible<T, const void*>::value;
    if(canConvertToChar && *(fmtEnd-1) == 'c')
        detail::formatValueAsType<T, char>::invoke(out, value);
    else if(canConvertToVoidPtr && *(fmtEnd-1) == 'p')
        detail::formatValueAsType<T, const void*>::invoke(out, value);
#ifdef TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND
    else if(detail::formatZeroIntegerWorkaround<T>::invoke(out, value)) /**/;
#endif
    else if(ntrunc >= 0)
    {
        // Take care not to overread C strings in truncating conversions like
        // "%.4s" where at most 4 characters may be read.
        detail::formatTruncated(out, value, ntrunc);
    }
    else
        out << value;
}


// Overloaded version for char types to support printing as an integer
#define TINYFORMAT_DEFINE_FORMATVALUE_CHAR(charType)                  \
inline void formatValue(std::ostream& out, const char* /*fmtBegin*/,  \
                        const char* fmtEnd, int /**/, charType value) \
{                                                                     \
    switch(*(fmtEnd-1))                                               \
    {                                                                 \
        case 'u': case 'd': case 'i': case 'o': case 'X': case 'x':   \
            out << static_cast<int>(value); break;                    \
        default:                                                      \
            out << value;                   break;                    \
    }                                                                 \
}
// per 3.9.1: char, signed char and unsigned char are all distinct types
TINYFORMAT_DEFINE_FORMATVALUE_CHAR(char)
TINYFORMAT_DEFINE_FORMATVALUE_CHAR(signed char)
TINYFORMAT_DEFINE_FORMATVALUE_CHAR(unsigned char)
#undef TINYFORMAT_DEFINE_FORMATVALUE_CHAR


//------------------------------------------------------------------------------
// Tools for emulating variadic templates in C++98.  The basic idea here is
// stolen from the boost preprocessor metaprogramming library and cut down to
// be just general enough for what we need.

#define TINYFORMAT_ARGTYPES(n) TINYFORMAT_ARGTYPES_ ## n
#define TINYFORMAT_VARARGS(n) TINYFORMAT_VARARGS_ ## n
#define TINYFORMAT_PASSARGS(n) TINYFORMAT_PASSARGS_ ## n
#define TINYFORMAT_PASSARGS_TAIL(n) TINYFORMAT_PASSARGS_TAIL_ ## n

// To keep it as transparent as possible, the macros below have been generated
// using python via the excellent cog.py code generation script.  This avoids
// the need for a bunch of complex (but more general) preprocessor tricks as
// used in boost.preprocessor.
//
// To rerun the code generation in place, use `cog.py -r tinyformat.h`
// (see http://nedbatchelder.com/code/cog).  Alternatively you can just create
// extra versions by hand.

/*[[[cog
maxParams = 16

def makeCommaSepLists(lineTemplate, elemTemplate, startInd=1):
    for j in range(startInd,maxParams+1):
        list = ', '.join([elemTemplate % {'i':i} for i in range(startInd,j+1)])
        cog.outl(lineTemplate % {'j':j, 'list':list})

makeCommaSepLists('#define TINYFORMAT_ARGTYPES_%(j)d %(list)s',
                  'class T%(i)d')

cog.outl()
makeCommaSepLists('#define TINYFORMAT_VARARGS_%(j)d %(list)s',
                  'const T%(i)d& v%(i)d')

cog.outl()
makeCommaSepLists('#define TINYFORMAT_PASSARGS_%(j)d %(list)s', 'v%(i)d')

cog.outl()
cog.outl('#define TINYFORMAT_PASSARGS_TAIL_1')
makeCommaSepLists('#define TINYFORMAT_PASSARGS_TAIL_%(j)d , %(list)s',
                  'v%(i)d', startInd = 2)

cog.outl()
cog.outl('#define TINYFORMAT_FOREACH_ARGNUM(m) \\\n    ' +
         ' '.join(['m(%d)' % (j,) for j in range(1,maxParams+1)]))
]]]*/
#define TINYFORMAT_ARGTYPES_1 class T1
#define TINYFORMAT_ARGTYPES_2 class T1, class T2
#define TINYFORMAT_ARGTYPES_3 class T1, class T2, class T3
#define TINYFORMAT_ARGTYPES_4 class T1, class T2, class T3, class T4
#define TINYFORMAT_ARGTYPES_5 class T1, class T2, class T3, class T4, class T5
#define TINYFORMAT_ARGTYPES_6 class T1, class T2, class T3, class T4, class T5, class T6
#define TINYFORMAT_ARGTYPES_7 class T1, class T2, class T3, class T4, class T5, class T6, class T7
#define TINYFORMAT_ARGTYPES_8 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8
#define TINYFORMAT_ARGTYPES_9 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9
#define TINYFORMAT_ARGTYPES_10 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10
#define TINYFORMAT_ARGTYPES_11 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11
#define TINYFORMAT_ARGTYPES_12 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12
#define TINYFORMAT_ARGTYPES_13 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13
#define TINYFORMAT_ARGTYPES_14 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14
#define TINYFORMAT_ARGTYPES_15 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15
#define TINYFORMAT_ARGTYPES_16 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16

#define TINYFORMAT_VARARGS_1 const T1& v1
#define TINYFORMAT_VARARGS_2 const T1& v1, const T2& v2
#define TINYFORMAT_VARARGS_3 const T1& v1, const T2& v2, const T3& v3
#define TINYFORMAT_VARARGS_4 const T1& v1, const T2& v2, const T3& v3, const T4& v4
#define TINYFORMAT_VARARGS_5 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5
#define TINYFORMAT_VARARGS_6 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6
#define TINYFORMAT_VARARGS_7 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7
#define TINYFORMAT_VARARGS_8 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8
#define TINYFORMAT_VARARGS_9 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9
#define TINYFORMAT_VARARGS_10 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10
#define TINYFORMAT_VARARGS_11 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11
#define TINYFORMAT_VARARGS_12 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11, const T12& v12
#define TINYFORMAT_VARARGS_13 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11, const T12& v12, const T13& v13
#define TINYFORMAT_VARARGS_14 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11, const T12& v12, const T13& v13, const T14& v14
#define TINYFORMAT_VARARGS_15 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11, const T12& v12, const T13& v13, const T14& v14, const T15& v15
#define TINYFORMAT_VARARGS_16 const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11, const T12& v12, const T13& v13, const T14& v14, const T15& v15, const T16& v16

#define TINYFORMAT_PASSARGS_1 v1
#define TINYFORMAT_PASSARGS_2 v1, v2
#define TINYFORMAT_PASSARGS_3 v1, v2, v3
#define TINYFORMAT_PASSARGS_4 v1, v2, v3, v4
#define TINYFORMAT_PASSARGS_5 v1, v2, v3, v4, v5
#define TINYFORMAT_PASSARGS_6 v1, v2, v3, v4, v5, v6
#define TINYFORMAT_PASSARGS_7 v1, v2, v3, v4, v5, v6, v7
#define TINYFORMAT_PASSARGS_8 v1, v2, v3, v4, v5, v6, v7, v8
#define TINYFORMAT_PASSARGS_9 v1, v2, v3, v4, v5, v6, v7, v8, v9
#define TINYFORMAT_PASSARGS_10 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10
#define TINYFORMAT_PASSARGS_11 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11
#define TINYFORMAT_PASSARGS_12 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12
#define TINYFORMAT_PASSARGS_13 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13
#define TINYFORMAT_PASSARGS_14 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14
#define TINYFORMAT_PASSARGS_15 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15
#define TINYFORMAT_PASSARGS_16 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16

#define TINYFORMAT_PASSARGS_TAIL_1
#define TINYFORMAT_PASSARGS_TAIL_2 , v2
#define TINYFORMAT_PASSARGS_TAIL_3 , v2, v3
#define TINYFORMAT_PASSARGS_TAIL_4 , v2, v3, v4
#define TINYFORMAT_PASSARGS_TAIL_5 , v2, v3, v4, v5
#define TINYFORMAT_PASSARGS_TAIL_6 , v2, v3, v4, v5, v6
#define TINYFORMAT_PASSARGS_TAIL_7 , v2, v3, v4, v5, v6, v7
#define TINYFORMAT_PASSARGS_TAIL_8 , v2, v3, v4, v5, v6, v7, v8
#define TINYFORMAT_PASSARGS_TAIL_9 , v2, v3, v4, v5, v6, v7, v8, v9
#define TINYFORMAT_PASSARGS_TAIL_10 , v2, v3, v4, v5, v6, v7, v8, v9, v10
#define TINYFORMAT_PASSARGS_TAIL_11 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11
#define TINYFORMAT_PASSARGS_TAIL_12 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12
#define TINYFORMAT_PASSARGS_TAIL_13 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13
#define TINYFORMAT_PASSARGS_TAIL_14 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14
#define TINYFORMAT_PASSARGS_TAIL_15 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15
#define TINYFORMAT_PASSARGS_TAIL_16 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16

#define TINYFORMAT_FOREACH_ARGNUM(m) \
    m(1) m(2) m(3) m(4) m(5) m(6) m(7) m(8) m(9) m(10) m(11) m(12) m(13) m(14) m(15) m(16)
//[[[end]]]



namespace detail {

// Type-opaque holder for an argument to format(), with associated actions on
// the type held as explicit function pointers.  This allows FormatArg's for
// each argument to be allocated as a homogenous array inside FormatList
// whereas a naive implementation based on inheritance does not.
class FormatArg
{
    public:
        FormatArg() {}

        template<typename T>
        FormatArg(const T& value)
            : m_value(static_cast<const void*>(&value)),
            m_formatImpl(&formatImpl<T>),
            m_toIntImpl(&toIntImpl<T>)
        { }

        void format(std::ostream& out, const char* fmtBegin,
                    const char* fmtEnd, int ntrunc) const
        {
            m_formatImpl(out, fmtBegin, fmtEnd, ntrunc, m_value);
        }

        int toInt() const
        {
            return m_toIntImpl(m_value);
        }

    private:
        template<typename T>
        TINYFORMAT_HIDDEN static void formatImpl(std::ostream& out, const char* fmtBegin,
                        const char* fmtEnd, int ntrunc, const void* value)
        {
            formatValue(out, fmtBegin, fmtEnd, ntrunc, *static_cast<const T*>(value));
        }

        template<typename T>
        TINYFORMAT_HIDDEN static int toIntImpl(const void* value)
        {
            return convertToInt<T>::invoke(*static_cast<const T*>(value));
        }

        const void* m_value;
        void (*m_formatImpl)(std::ostream& out, const char* fmtBegin,
                             const char* fmtEnd, int ntrunc, const void* value);
        int (*m_toIntImpl)(const void* value);
};


// Parse and return an integer from the string c, as atoi()
// On return, c is set to one past the end of the integer.
inline int parseIntAndAdvance(const char*& c)
{
    int i = 0;
    for(;*c >= '0' && *c <= '9'; ++c)
        i = 10*i + (*c - '0');
    return i;
}

// Print literal part of format string and return next format spec
// position.
//
// Skips over any occurrences of '%%', printing a literal '%' to the
// output.  The position of the first % character of the next
// nontrivial format spec is returned, or the end of string.
inline const char* printFormatStringLiteral(std::ostream& out, const char* fmt)
{
    const char* c = fmt;
    for(;; ++c)
    {
        switch(*c)
        {
            case '\0':
                out.write(fmt, static_cast<std::streamsize>(c - fmt));
                return c;
            case '%':
                out.write(fmt, static_cast<std::streamsize>(c - fmt));
                if(*(c+1) != '%')
                    return c;
                // for "%%", tack trailing % onto next literal section.
                fmt = ++c;
                break;
        }
    }
}


// Parse a format string and set the stream state accordingly.
//
// The format mini-language recognized here is meant to be the one from C99,
// with the form "%[flags][width][.precision][length]type".
//
// Formatting options which can't be natively represented using the ostream
// state are returned in spacePadPositive (for space padded positive numbers)
// and ntrunc (for truncating conversions).  argIndex is incremented if
// necessary to pull out variable width and precision .  The function returns a
// pointer to the character after the end of the current format spec.
inline const char* streamStateFromFormat(std::ostream& out, bool& spacePadPositive,
                                         int& ntrunc, const char* fmtStart,
                                         const detail::FormatArg* formatters,
                                         int& argIndex, int numFormatters)
{
    if(*fmtStart != '%')
    {
        TINYFORMAT_ERROR("tinyformat: Not enough conversion specifiers in format string");
        return fmtStart;
    }
    // Reset stream state to defaults.
    out.width(0);
    out.precision(6);
    out.fill(' ');
    // Reset most flags; ignore irrelevant unitbuf & skipws.
    out.unsetf(std::ios::adjustfield | std::ios::basefield |
               std::ios::floatfield | std::ios::showbase | std::ios::boolalpha |
               std::ios::showpoint | std::ios::showpos | std::ios::uppercase);
    bool precisionSet = false;
    bool widthSet = false;
    int widthExtra = 0;
    const char* c = fmtStart + 1;
    // 1) Parse flags
    for(;; ++c)
    {
        switch(*c)
        {
            case '#':
                out.setf(std::ios::showpoint | std::ios::showbase);
                continue;
            case '0':
                // overridden by left alignment ('-' flag)
                if(!(out.flags() & std::ios::left))
                {
                    // Use internal padding so that numeric values are
                    // formatted correctly, eg -00010 rather than 000-10
                    out.fill('0');
                    out.setf(std::ios::internal, std::ios::adjustfield);
                }
                continue;
            case '-':
                out.fill(' ');
                out.setf(std::ios::left, std::ios::adjustfield);
                continue;
            case ' ':
                // overridden by show positive sign, '+' flag.
                if(!(out.flags() & std::ios::showpos))
                    spacePadPositive = true;
                continue;
            case '+':
                out.setf(std::ios::showpos);
                spacePadPositive = false;
                widthExtra = 1;
                continue;
        }
        break;
    }
    // 2) Parse width
    if(*c >= '0' && *c <= '9')
    {
        widthSet = true;
        out.width(parseIntAndAdvance(c));
    }
    if(*c == '*')
    {
        widthSet = true;
        int width = 0;
        if(argIndex < numFormatters)
            width = formatters[argIndex++].toInt();
        else
            TINYFORMAT_ERROR("tinyformat: Not enough arguments to read variable width");
        if(width < 0)
        {
            // negative widths correspond to '-' flag set
            out.fill(' ');
            out.setf(std::ios::left, std::ios::adjustfield);
            width = -width;
        }
        out.width(width);
        ++c;
    }
    // 3) Parse precision
    if(*c == '.')
    {
        ++c;
        int precision = 0;
        if(*c == '*')
        {
            ++c;
            if(argIndex < numFormatters)
                precision = formatters[argIndex++].toInt();
            else
                TINYFORMAT_ERROR("tinyformat: Not enough arguments to read variable precision");
        }
        else
        {
            if(*c >= '0' && *c <= '9')
                precision = parseIntAndAdvance(c);
            else if(*c == '-') // negative precisions ignored, treated as zero.
                parseIntAndAdvance(++c);
        }
        out.precision(precision);
        precisionSet = true;
    }
    // 4) Ignore any C99 length modifier
    while(*c == 'l' || *c == 'h' || *c == 'L' ||
          *c == 'j' || *c == 'z' || *c == 't')
        ++c;
    // 5) We're up to the conversion specifier character.
    // Set stream flags based on conversion specifier (thanks to the
    // boost::format class for forging the way here).
    bool intConversion = false;
    switch(*c)
    {
        case 'u': case 'd': case 'i':
            out.setf(std::ios::dec, std::ios::basefield);
            intConversion = true;
            break;
        case 'o':
            out.setf(std::ios::oct, std::ios::basefield);
            intConversion = true;
            break;
        case 'X':
            out.setf(std::ios::uppercase);
        case 'x': case 'p':
            out.setf(std::ios::hex, std::ios::basefield);
            intConversion = true;
            break;
        case 'E':
            out.setf(std::ios::uppercase);
        case 'e':
            out.setf(std::ios::scientific, std::ios::floatfield);
            out.setf(std::ios::dec, std::ios::basefield);
            break;
        case 'F':
            out.setf(std::ios::uppercase);
        case 'f':
            out.setf(std::ios::fixed, std::ios::floatfield);
            break;
        case 'G':
            out.setf(std::ios::uppercase);
        case 'g':
            out.setf(std::ios::dec, std::ios::basefield);
            // As in boost::format, let stream decide float format.
            out.flags(out.flags() & ~std::ios::floatfield);
            break;
        case 'a': case 'A':
            TINYFORMAT_ERROR("tinyformat: the %a and %A conversion specs "
                             "are not supported");
            break;
        case 'c':
            // Handled as special case inside formatValue()
            break;
        case 's':
            if(precisionSet)
                ntrunc = static_cast<int>(out.precision());
            // Make %s print booleans as "true" and "false"
            out.setf(std::ios::boolalpha);
            break;
        case 'n':
            // Not supported - will cause problems!
            TINYFORMAT_ERROR("tinyformat: %n conversion spec not supported");
            break;
        case '\0':
            TINYFORMAT_ERROR("tinyformat: Conversion spec incorrectly "
                             "terminated by end of string");
            return c;
    }
    if(intConversion && precisionSet && !widthSet)
    {
        // "precision" for integers gives the minimum number of digits (to be
        // padded with zeros on the left).  This isn't really supported by the
        // iostreams, but we can approximately simulate it with the width if
        // the width isn't otherwise used.
        out.width(out.precision() + widthExtra);
        out.setf(std::ios::internal, std::ios::adjustfield);
        out.fill('0');
    }
    return c+1;
}


//------------------------------------------------------------------------------
inline void formatImpl(std::ostream& out, const char* fmt,
                       const detail::FormatArg* formatters,
                       int numFormatters)
{
    // Saved stream state
    std::streamsize origWidth = out.width();
    std::streamsize origPrecision = out.precision();
    std::ios::fmtflags origFlags = out.flags();
    char origFill = out.fill();

    for (int argIndex = 0; argIndex < numFormatters; ++argIndex)
    {
        // Parse the format string
        fmt = printFormatStringLiteral(out, fmt);
        bool spacePadPositive = false;
        int ntrunc = -1;
        const char* fmtEnd = streamStateFromFormat(out, spacePadPositive, ntrunc, fmt,
                                                   formatters, argIndex, numFormatters);
        if (argIndex >= numFormatters)
        {
            // Check args remain after reading any variable width/precision
            TINYFORMAT_ERROR("tinyformat: Not enough format arguments");
            return;
        }
        const FormatArg& arg = formatters[argIndex];
        // Format the arg into the stream.
        if(!spacePadPositive)
            arg.format(out, fmt, fmtEnd, ntrunc);
        else
        {
            // The following is a special case with no direct correspondence
            // between stream formatting and the printf() behaviour.  Simulate
            // it crudely by formatting into a temporary string stream and
            // munging the resulting string.
            std::ostringstream tmpStream;
            tmpStream.copyfmt(out);
            tmpStream.setf(std::ios::showpos);
            arg.format(tmpStream, fmt, fmtEnd, ntrunc);
            std::string result = tmpStream.str(); // allocates... yuck.
            for(size_t i = 0, iend = result.size(); i < iend; ++i)
                if(result[i] == '+') result[i] = ' ';
            out << result;
        }
        fmt = fmtEnd;
    }

    // Print remaining part of format string.
    fmt = printFormatStringLiteral(out, fmt);
    if(*fmt != '\0')
        TINYFORMAT_ERROR("tinyformat: Too many conversion specifiers in format string");

    // Restore stream state
    out.width(origWidth);
    out.precision(origPrecision);
    out.flags(origFlags);
    out.fill(origFill);
}

} // namespace detail


/// List of template arguments format(), held in a type-opaque way.
///
/// A const reference to FormatList (typedef'd as FormatListRef) may be
/// conveniently used to pass arguments to non-template functions: All type
/// information has been stripped from the arguments, leaving just enough of a
/// common interface to perform formatting as required.
class FormatList
{
    public:
        FormatList(detail::FormatArg* formatters, int N)
            : m_formatters(formatters), m_N(N) { }

        friend void vformat(std::ostream& out, const char* fmt,
                            const FormatList& list);

    private:
        const detail::FormatArg* m_formatters;
        int m_N;
};

/// Reference to type-opaque format list for passing to vformat()
typedef const FormatList& FormatListRef;


namespace detail {

// Format list subclass with fixed storage to avoid dynamic allocation
template<int N>
class FormatListN : public FormatList
{
    public:
#ifdef TINYFORMAT_USE_VARIADIC_TEMPLATES
        template<typename... Args>
        FormatListN(const Args&... args)
            : FormatList(&m_formatterStore[0], N),
            m_formatterStore TINYFORMAT_BRACED_INIT_WORKAROUND({ FormatArg(args)... })
        { static_assert(sizeof...(args) == N, "Number of args must be N"); }
#else // C++98 version
        void init(int) {}
#       define TINYFORMAT_MAKE_FORMATLIST_CONSTRUCTOR(n)       \
                                                               \
        template<TINYFORMAT_ARGTYPES(n)>                       \
        FormatListN(TINYFORMAT_VARARGS(n))                     \
            : FormatList(&m_formatterStore[0], n)              \
        { assert(n == N); init(0, TINYFORMAT_PASSARGS(n)); }   \
                                                               \
        template<TINYFORMAT_ARGTYPES(n)>                       \
        void init(int i, TINYFORMAT_VARARGS(n))                \
        {                                                      \
            m_formatterStore[i] = FormatArg(v1);               \
            init(i+1 TINYFORMAT_PASSARGS_TAIL(n));             \
        }

        TINYFORMAT_FOREACH_ARGNUM(TINYFORMAT_MAKE_FORMATLIST_CONSTRUCTOR)
#       undef TINYFORMAT_MAKE_FORMATLIST_CONSTRUCTOR
#endif

    private:
#ifdef TINYFORMAT_USE_VARIADIC_TEMPLATES
        std::array<FormatArg, N> m_formatterStore;
#else // C++98 version
        FormatArg m_formatterStore[N];
#endif
};

// Special 0-arg version - MSVC says zero-sized C array in struct is nonstandard
template<> class FormatListN<0> : public FormatList
{
    public: FormatListN() : FormatList(0, 0) {}
};

} // namespace detail


//------------------------------------------------------------------------------
// Primary API functions

#ifdef TINYFORMAT_USE_VARIADIC_TEMPLATES

/// Make type-agnostic format list from list of template arguments.
///
/// The exact return type of this function is an implementation detail and
/// shouldn't be relied upon.  Instead it should be stored as a FormatListRef:
///
///   FormatListRef formatList = makeFormatList( /*...*/ );
template<typename... Args>
detail::FormatListN<sizeof...(Args)> makeFormatList(const Args&... args)
{
    return detail::FormatListN<sizeof...(args)>(args...);
}

#else // C++98 version

inline detail::FormatListN<0> makeFormatList()
{
    return detail::FormatListN<0>();
}
#define TINYFORMAT_MAKE_MAKEFORMATLIST(n)                     \
template<TINYFORMAT_ARGTYPES(n)>                              \
detail::FormatListN<n> makeFormatList(TINYFORMAT_VARARGS(n))  \
{                                                             \
    return detail::FormatListN<n>(TINYFORMAT_PASSARGS(n));    \
}
TINYFORMAT_FOREACH_ARGNUM(TINYFORMAT_MAKE_MAKEFORMATLIST)
#undef TINYFORMAT_MAKE_MAKEFORMATLIST

#endif

/// Format list of arguments to the stream according to the given format string.
///
/// The name vformat() is chosen for the semantic similarity to vprintf(): the
/// list of format arguments is held in a single function argument.
inline void vformat(std::ostream& out, const char* fmt, FormatListRef list)
{
    detail::formatImpl(out, fmt, list.m_formatters, list.m_N);
}


#ifdef TINYFORMAT_USE_VARIADIC_TEMPLATES

/// Format list of arguments to the stream according to given format string.
template<typename... Args>
void format(std::ostream& out, const char* fmt, const Args&... args)
{
    vformat(out, fmt, makeFormatList(args...));
}

/// Format list of arguments according to the given format string and return
/// the result as a string.
template<typename... Args>
std::string format(const char* fmt, const Args&... args)
{
    std::ostringstream oss;
    format(oss, fmt, args...);
    return oss.str();
}

/// Format list of arguments to std::cout, according to the given format string
template<typename... Args>
void printf(const char* fmt, const Args&... args)
{
    format(std::cout, fmt, args...);
}

template<typename... Args>
void printfln(const char* fmt, const Args&... args)
{
    format(std::cout, fmt, args...);
    std::cout << '\n';
}


#else // C++98 version

inline void format(std::ostream& out, const char* fmt)
{
    vformat(out, fmt, makeFormatList());
}

inline std::string format(const char* fmt)
{
    std::ostringstream oss;
    format(oss, fmt);
    return oss.str();
}

inline void printf(const char* fmt)
{
    format(std::cout, fmt);
}

inline void printfln(const char* fmt)
{
    format(std::cout, fmt);
    std::cout << '\n';
}

#define TINYFORMAT_MAKE_FORMAT_FUNCS(n)                                   \
                                                                          \
template<TINYFORMAT_ARGTYPES(n)>                                          \
void format(std::ostream& out, const char* fmt, TINYFORMAT_VARARGS(n))    \
{                                                                         \
    vformat(out, fmt, makeFormatList(TINYFORMAT_PASSARGS(n)));            \
}                                                                         \
                                                                          \
template<TINYFORMAT_ARGTYPES(n)>                                          \
std::string format(const char* fmt, TINYFORMAT_VARARGS(n))                \
{                                                                         \
    std::ostringstream oss;                                               \
    format(oss, fmt, TINYFORMAT_PASSARGS(n));                             \
    return oss.str();                                                     \
}                                                                         \
                                                                          \
template<TINYFORMAT_ARGTYPES(n)>                                          \
void printf(const char* fmt, TINYFORMAT_VARARGS(n))                       \
{                                                                         \
    format(std::cout, fmt, TINYFORMAT_PASSARGS(n));                       \
}                                                                         \
                                                                          \
template<TINYFORMAT_ARGTYPES(n)>                                          \
void printfln(const char* fmt, TINYFORMAT_VARARGS(n))                     \
{                                                                         \
    format(std::cout, fmt, TINYFORMAT_PASSARGS(n));                       \
    std::cout << '\n';                                                    \
}

TINYFORMAT_FOREACH_ARGNUM(TINYFORMAT_MAKE_FORMAT_FUNCS)
#undef TINYFORMAT_MAKE_FORMAT_FUNCS

#endif


} // namespace tinyformat

#endif // TINYFORMAT_H_INCLUDED

```

`UnrealFinderTool/SdkGen/EngineClasses.h`:

```h
#pragma once
#pragma warning(disable: 4302)
#pragma warning(disable: 4311)

#include <string>
#include <windows.h>
#include "../Utils.h"
#include "Memory.h"
#include "../JsonReflector.h"

// #define OFFSET(s, m) ((size_t)&reinterpret_cast<char const volatile&>((((s*)0)->m)))
#define OFFSET(m) ((int)&reinterpret_cast<char const volatile&>((((decltype(this))0)->m)))
#define FILL_DATA(pData, var, offset) var = *reinterpret_cast<decltype(var)*>(&pData[offset])
#define SIZE_OF_ME sizeof(decltype(*this))

class UClass;
class UObject;

#pragma region Same Size As Engine
struct FPointer
{
	uintptr_t Dummy;

	void FixPointers(const size_t fullCppStructSize)
	{
		Utils::FixPointers(this, fullCppStructSize, { OFFSET(Dummy) });
	}
};

struct FQWord
{
	int32_t A;
	int32_t B;
};

struct FName
{
	int32_t ComparisonIndex;
	int32_t Number;
};

struct TArray
{
	uintptr_t Data = NULL;
	int32_t Count = 0;
	int32_t Max = 0;

	friend struct FString;

	bool IsValidIndex(const int i) const
	{
		return i < Count;
	}

	void FixPointers(const size_t fullCppStructSize)
	{
		Utils::FixPointers(this, fullCppStructSize, { OFFSET(Data) });
	}
};

struct FString : TArray // <wchar_t>
{
	/*std::string ToString() const
	{
		int size = WideCharToMultiByte(CP_UTF8, 0, Data, Count, nullptr, 0, nullptr, nullptr);
		std::string str(size, 0);
		WideCharToMultiByte(CP_UTF8, 0, Data, Count, &str[0], size, nullptr, nullptr);
		return str;
	}*/

	void FixPointers(const size_t fullCppStructSize)
	{
		TArray::FixPointers(fullCppStructSize);
	}
};

struct FText
{
	char UnknownData[0x18];
};

struct FWeakObjectPtr
{
	int32_t ObjectIndex;
	int32_t ObjectSerialNumber;
};

struct FStringAssetReference
{
	FString AssetLongPathname;
};

struct FGuid
{
	uint32_t A;
	uint32_t B;
	uint32_t C;
	uint32_t D;
};

struct FUniqueObjectGuid
{
	FGuid Guid;
};

struct FScriptDelegate
{
	unsigned char UnknownData[20];
};

struct FScriptMulticastDelegate
{
	unsigned char UnknownData[16];
};

struct FUEnumItem // Same As TPair
{
	FName Key;
	uint64_t Value = 0;
};

#pragma endregion

class FScriptInterface
{
	bool init = false;
	Memory* m = Utils::MemoryObj;
	PBYTE pData = nullptr;

public:
	// Object remote address
	uintptr_t ObjAddress = NULL;

	uintptr_t ObjectPointer = NULL;
	uintptr_t InterfacePointer = NULL;

	uintptr_t GetObj() const
	{
		return ObjectPointer;
	}

	uintptr_t GetInterface() const
	{
		return ObjectPointer != NULL ? InterfacePointer : NULL;
	}

	std::string TypeName() { return "FScriptInterface"; }

	void FixPointers(const size_t fullCppStructSize)
	{
		Utils::FixPointers(this, fullCppStructSize, {
			OFFSET(ObjectPointer),
			OFFSET(InterfacePointer)
		});
	}

	bool ReadData(const uintptr_t objAddress)
	{
		ObjAddress = objAddress;

		if (ObjAddress == NULL)
			return false;

		// Read this struct
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		static size_t jSize = jStruct.GetSize();
		static int offsets[] =
		{
			jStruct["ObjectPointer"].Offset,
			jStruct["InterfacePointer"].Offset
		};

		// Read Remote Memory
		bool dataAllocer = false;
		if (pData == nullptr)
		{
			dataAllocer = true;
			pData = new BYTE[jSize];

			// Read this struct
			if (m->ReadBytes(ObjAddress, pData, jSize) != jSize) return false;
		}

		FILL_DATA(pData, ObjectPointer, offsets[0]);
		FILL_DATA(pData, InterfacePointer, offsets[1]);

		// It's Initialized
		init = true;

		if (dataAllocer)
		{
			// Fix pointers for x32 games
			FixPointers(SIZE_OF_ME);

			delete pData;
			pData = nullptr;
		}

		return true;
	}

	bool ReadData()
	{
		return ReadData(ObjAddress);
	}

	int StructSize()
	{
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		return jStruct.GetSize();
	}

	bool IsInit()
	{
		return init;
	}
};

template<typename TObjectId>
class TPersistentObjectPtr
{
public:
	FWeakObjectPtr WeakPtr;
	int32_t TagAtLastTest;
	TObjectId ObjectId;

	void FixPointers(const size_t fullCppStructSize)
	{
		// FScriptInterface::FixPointers();
		// Utils::FixPointers(this, fullCppStructSize, { OFFSET(Data) });
	}
};

class FAssetPtr : public TPersistentObjectPtr<FStringAssetReference>
{
public:
	void FixPointers(const size_t fullCppStructSize)
	{
		TPersistentObjectPtr::FixPointers(fullCppStructSize);
	}
};

class FLazyObjectPtr : public TPersistentObjectPtr<FUniqueObjectGuid>
{
public:
	void FixPointers(const size_t fullCppStructSize)
	{
		TPersistentObjectPtr::FixPointers(fullCppStructSize);
	}
};

class FUObjectItem
{
	bool init = false;
	Memory* m = Utils::MemoryObj;
	PBYTE pData = nullptr;

public:
	// Object remote address
	uintptr_t ObjAddress = NULL;

	uintptr_t Object = NULL;

	std::string TypeName() { return "FUObjectItem"; }

	void FixPointers(const size_t fullCppStructSize)
	{
		Utils::FixPointers(this, fullCppStructSize, { OFFSET(Object) });
	}

	bool ReadData(const uintptr_t objAddress)
	{
		ObjAddress = objAddress;

		if (ObjAddress == NULL)
			return false;

		// Read this struct
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		static size_t jSize = jStruct.GetSize();
		static int offsets[] =
		{
			jStruct["Object"].Offset
		};

		// Read Remote Memory
		bool dataAllocer = false;
		if (pData == nullptr)
		{
			dataAllocer = true;
			pData = new BYTE[jSize];

			// Read this struct
			if (m->ReadBytes(ObjAddress, pData, jSize) != jSize) return false;
		}

		// Read this struct, support EngineJson
		FILL_DATA(pData, Object, offsets[0]);

		// It's Initialized
		init = true;

		if (dataAllocer)
		{
			// Fix pointers for x32 games
			FixPointers(SIZE_OF_ME);

			delete pData;
			pData = nullptr;
		}
		
		return true;
	}

	bool ReadData()
	{
		return ReadData(ObjAddress);
	}

	int StructSize()
	{
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		return jStruct.GetSize();
	}

	bool IsInit()
	{
		return init;
	}
};

class FNameEntity
{
	bool init = false;
	Memory* m = Utils::MemoryObj;
	PBYTE pData = nullptr;

public:
	// Object remote address
	uintptr_t ObjAddress = NULL;

	int Index;
	std::string AnsiName;

	FNameEntity() = default;
	explicit FNameEntity(const int index, const std::string& ansiName) : Index(index), AnsiName(ansiName) { }

	std::string TypeName() { return "FNameEntity"; }

	void FixPointers(const size_t fullCppStructSize)
	{
		// 
	}

	bool ReadData(const uintptr_t objAddress, const size_t ansiNameOffset)
	{
		ObjAddress = objAddress;

		if (ObjAddress == NULL)
			return false;

		// Read this struct
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		static size_t jSize = jStruct.GetSize();
		static int offsets[] = { jStruct["Index"].Offset };

		// Read Remote Memory
		bool dataAllocer = false;
		if (pData == nullptr)
		{
			dataAllocer = true;
			pData = new BYTE[jSize];

			// Read this struct
			if (m->ReadBytes(ObjAddress, pData, jSize) != jSize) return false;
		}

		FILL_DATA(pData, Index, offsets[0]);
		AnsiName = m->ReadText(objAddress + ansiNameOffset);

		if (dataAllocer)
		{
			// Fix pointers for x32 games
			FixPointers(SIZE_OF_ME);

			delete pData;
			pData = nullptr;
		}
		return true;
	}

	bool ReadData(const size_t ansiNameOffset)
	{
		return ReadData(ObjAddress, ansiNameOffset);
	}

	bool IsInit()
	{
		return init;
	}
};

class UObject
{
	bool init = false;

protected:
	Memory* m = Utils::MemoryObj;
	PBYTE pData = nullptr;

public:
	// Object remote address
	uintptr_t ObjAddress = 0;

	uintptr_t VfTable = 0;
	int Flags = 0;
	int InternalIndex = 0;
	uintptr_t Class = 0;
	FName Name{};
	uintptr_t Outer = 0;

	std::string TypeName() { return "UObject"; }

	void FixPointers(const size_t fullCppStructSize)
	{
		Utils::FixPointers(this, fullCppStructSize, {
			OFFSET(VfTable),
			OFFSET(Class),
			OFFSET(Outer),
		});
	}

	bool ReadData(const uintptr_t objAddress)
	{
		// Set object remote address
		ObjAddress = objAddress;

		if (ObjAddress == NULL)
			return false;

		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		static size_t jSize = jStruct.GetSize();
		static int offsets[] =
		{
			jStruct["VfTable"].Offset,
			jStruct["Flags"].Offset,
			jStruct["InternalIndex"].Offset,
			jStruct["Class"].Offset,
			jStruct["Name"].Offset,
			jStruct["Outer"].Offset
		};

		bool dataAllocer = false;
		if (pData == nullptr)
		{
			dataAllocer = true;
			pData = new BYTE[jSize];

			// Read this struct
			if (m->ReadBytes(ObjAddress, pData, jSize) != jSize) return false;
		}

		FILL_DATA(pData, VfTable, offsets[0]);
		FILL_DATA(pData, Flags, offsets[1]);
		FILL_DATA(pData, InternalIndex, offsets[2]);
		FILL_DATA(pData, Class, offsets[3]);
		FILL_DATA(pData, Name, offsets[4]);
		FILL_DATA(pData, Outer, offsets[5]);

		// It's initialized
		init = true;

		if (dataAllocer)
		{
			// Fix pointers for x32 games
			FixPointers(SIZE_OF_ME);

			delete pData;
			pData = nullptr;
		}
		return true;
	}

	bool ReadData()
	{
		return ReadData(ObjAddress);
	}

	int StructSize()
	{
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		return jStruct.GetSize();
	}

	bool IsEqual(const UObject& toCheck) const
	{
		return toCheck.InternalIndex == this->InternalIndex && toCheck.Name.ComparisonIndex == this->Name.ComparisonIndex;
	}

	bool IsInit()
	{
		return init;
	}

	bool Empty() const
	{
		return ObjAddress == NULL && VfTable == NULL;
	}

	template <typename USdkStruct>
	USdkStruct Cast() const
	{
		// it's like internal cast, but for remote process
		USdkStruct castType;

		// it's just to solve start up problem, for really Utils::MemoryObj will never == nullptr
		if (Utils::MemoryObj != nullptr)
			castType.ReadData(ObjAddress);

		return castType;
	}
};

class UField : public UObject
{
public:
	uintptr_t Next = 0;

	std::string TypeName() { return "UField"; }

	void FixPointers(const size_t fullCppStructSize)
	{
		UObject::FixPointers(fullCppStructSize);
		Utils::FixPointers(this, fullCppStructSize, { OFFSET(Next) });
	}

	bool ReadData(const uintptr_t objAddress)
	{
		// Set object remote address
		ObjAddress = objAddress;

		// Read this struct
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		static size_t jSize = jStruct.GetSize();
		static int offsets[] = { jStruct["Next"].Offset };

		// Read Remote Memory
		bool dataAllocer = false;
		if (pData == nullptr)
		{
			dataAllocer = true;
			pData = new BYTE[jSize];

			// Read this struct
			if (m->ReadBytes(ObjAddress, pData, jSize) != jSize) return false;
		}

		// Init super variables first
		UObject::ReadData(objAddress);

		// Init `this` variables
		FILL_DATA(pData, Next, offsets[0]);

		if (dataAllocer)
		{
			// Fix pointers for x32 games
			FixPointers(SIZE_OF_ME);

			delete pData;
			pData = nullptr;
		}
		return true;
	}

	bool ReadData()
	{
		return ReadData(ObjAddress);
	}

	int StructSize()
	{
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		return jStruct.GetSize();
	}
};

class UEnum : public UField
{
public:
	FString CppType;
	TArray Names; /*TArray<TPair<FName, uint64_t>> */
	int64_t CppForm = 0;

	std::string TypeName() { return "UEnum"; }

	void FixPointers(const size_t fullCppStructSize)
	{
		UField::FixPointers(fullCppStructSize);
		Utils::FixPointers(this, fullCppStructSize, {
			OFFSET(CppType.Data),
			OFFSET(Names.Data)
		});
	}

	bool ReadData(const uintptr_t objAddress)
	{
		// Set object remote address
		ObjAddress = objAddress;

		// Read this struct
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		static size_t jSize = jStruct.GetSize();
		static int offsets[] =
		{
			jStruct["CppType"].Offset,
			jStruct["Names"].Offset,
			jStruct["CppForm"].Offset
		};

		// Read Remote Memory
		bool dataAllocer = false;
		if (pData == nullptr)
		{
			dataAllocer = true;
			pData = new BYTE[jSize];

			// Read this struct
			if (m->ReadBytes(ObjAddress, pData, jSize) != jSize) return false;
		}

		// Init super variables first
		UField::ReadData(objAddress);

		// Init `this` variables
		FILL_DATA(pData, CppType, offsets[0]);
		FILL_DATA(pData, Names, offsets[1]);
		FILL_DATA(pData, CppForm, offsets[2]);

		if (dataAllocer)
		{
			// Fix pointers for x32 games
			FixPointers(SIZE_OF_ME);

			delete pData;
			pData = nullptr;
		}
		return true;
	}

	bool ReadData()
	{
		return ReadData(ObjAddress);
	}

	int StructSize()
	{
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		return jStruct.GetSize();
	}
};

class UStruct : public UField
{
public:
	uintptr_t SuperField = 0;
	uintptr_t Children = 0;
	int32_t PropertySize = 0;
	int32_t MinAlignment = 0;

	std::string TypeName() { return "UStruct"; }

	void FixPointers(const size_t fullCppStructSize)
	{
		UField::FixPointers(fullCppStructSize);
		Utils::FixPointers(this, fullCppStructSize, {
			OFFSET(SuperField),
			OFFSET(Children)
		});
	}

	bool ReadData(const uintptr_t objAddress)
	{
		// Set object remote address
		ObjAddress = objAddress;

		// Read this struct
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		static size_t jSize = jStruct.GetSize();
		static int offsets[] =
		{
			jStruct["SuperField"].Offset,
			jStruct["Children"].Offset,
			jStruct["PropertySize"].Offset,
			jStruct["MinAlignment"].Offset
		};

		// Read Remote Memory
		bool dataAllocer = false;
		if (pData == nullptr)
		{
			dataAllocer = true;
			pData = new BYTE[jSize];

			// Read this struct
			if (m->ReadBytes(ObjAddress, pData, jSize) != jSize) return false;
		}

		// Init super variables first
		UField::ReadData(objAddress);

		// Init `this` variables
		FILL_DATA(pData, SuperField, offsets[0]);
		FILL_DATA(pData, Children, offsets[1]);
		FILL_DATA(pData, PropertySize, offsets[2]);
		FILL_DATA(pData, MinAlignment, offsets[3]);

		if (dataAllocer)
		{
			// Fix pointers for x32 games
			FixPointers(SIZE_OF_ME);

			delete pData;
			pData = nullptr;
		}
		return true;
	}

	bool ReadData()
	{
		return ReadData(ObjAddress);
	}

	int StructSize()
	{
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		return jStruct.GetSize();
	}
};

class UScriptStruct : public UStruct
{
public:
	std::string TypeName() { return "UScriptStruct"; }

	void FixPointers(const size_t fullCppStructSize)
	{
		UStruct::FixPointers(fullCppStructSize);
	}

	bool ReadData(const uintptr_t objAddress)
	{
		// Set object remote address
		ObjAddress = objAddress;

		// Read this struct
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		static size_t jSize = jStruct.GetSize();

		// Read Remote Memory
		bool dataAllocer = false;
		if (pData == nullptr)
		{
			dataAllocer = true;
			pData = new BYTE[jSize];

			// Read this struct
			if (m->ReadBytes(ObjAddress, pData, jSize) != jSize) return false;
		}

		// Init super variables first
		UStruct::ReadData(objAddress);

		if (dataAllocer)
		{
			// Fix pointers for x32 games
			FixPointers(SIZE_OF_ME);

			delete pData;
			pData = nullptr;
		}
		return true;
	}

	bool ReadData()
	{
		return ReadData(ObjAddress);
	}

	int StructSize()
	{
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		return jStruct.GetSize();
	}
};

class UFunction : public UStruct
{
public:
	int32_t FunctionFlags = 0;
	uintptr_t FirstPropertyToInit = 0;
	uintptr_t EventGraphFunction = 0;
	uintptr_t Func = 0;

	std::string TypeName() { return "UFunction"; }

	void FixPointers(const size_t fullCppStructSize)
	{
		UStruct::FixPointers(fullCppStructSize);
		Utils::FixPointers(this, fullCppStructSize, {
			OFFSET(FirstPropertyToInit),
			OFFSET(EventGraphFunction),
			OFFSET(Func)
		});
	}

	bool ReadData(const uintptr_t objAddress)
	{
		// Set object remote address
		ObjAddress = objAddress;

		// Read this struct
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		static size_t jSize = jStruct.GetSize();
		static int offsets[] =
		{
			jStruct["FunctionFlags"].Offset,
			jStruct["FirstPropertyToInit"].Offset,
			jStruct["EventGraphFunction"].Offset,
			jStruct["Func"].Offset
		};

		// Read Remote Memory
		bool dataAllocer = false;
		if (pData == nullptr)
		{
			dataAllocer = true;
			pData = new BYTE[jSize];

			// Read this struct
			if (m->ReadBytes(ObjAddress, pData, jSize) != jSize) return false;
			FILL_DATA(pData, Func, jStruct["Func"].Offset);
		}

		// Init super variables first
		UStruct::ReadData(objAddress);

		// Init `this` variables
		FILL_DATA(pData, FunctionFlags, offsets[0]);
		FILL_DATA(pData, FirstPropertyToInit, offsets[1]);
		FILL_DATA(pData, EventGraphFunction, offsets[2]);
		FILL_DATA(pData, Func, offsets[3]);

		if (dataAllocer)
		{
			// Fix pointers for x32 games
			FixPointers(SIZE_OF_ME);

			delete pData;
			pData = nullptr;
		}
		return true;
	}

	bool ReadData()
	{
		return ReadData(ObjAddress);
	}

	int StructSize()
	{
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		return jStruct.GetSize();
	}
};

class UClass : public UStruct
{
public:
	std::string TypeName() { return "UClass"; }

	void FixPointers(const size_t fullCppStructSize)
	{
		UStruct::FixPointers(fullCppStructSize);
	}

	bool ReadData(const uintptr_t objAddress)
	{
		// Set object remote address
		ObjAddress = objAddress;

		// Read this struct
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		static size_t jSize = jStruct.GetSize();

		// Read Remote Memory
		bool dataAllocer = false;
		if (pData == nullptr)
		{
			dataAllocer = true;
			pData = new BYTE[jSize];

			// Read this struct
			if (m->ReadBytes(ObjAddress, pData, jSize) != jSize) return false;
		}

		// Init super variables first
		UStruct::ReadData(objAddress);

		if (dataAllocer)
		{
			// Fix pointers for x32 games
			FixPointers(SIZE_OF_ME);

			delete pData;
			pData = nullptr;
		}
		return true;
	}

	bool ReadData()
	{
		return ReadData(ObjAddress);
	}

	int StructSize()
	{
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		return jStruct.GetSize();
	}
};

class UProperty : public UField
{
public:
	int32_t ArrayDim = 0;
	int32_t ElementSize = 0;
	FQWord PropertyFlags;
	int32_t Offset = 0;
	uintptr_t PropertyLinkNext = 0;
	uintptr_t NextRef = 0;
	uintptr_t DestructorLinkNext = 0;
	uintptr_t PostConstructLinkNext = 0;

	std::string TypeName() { return "UProperty"; }

	void FixPointers(const size_t fullCppStructSize)
	{
		UField::FixPointers(fullCppStructSize);
		Utils::FixPointers(this, fullCppStructSize, {
			OFFSET(PropertyLinkNext),
			OFFSET(NextRef),
			OFFSET(DestructorLinkNext),
			OFFSET(PostConstructLinkNext)
		});
	}

	bool ReadData(const uintptr_t objAddress)
	{
		// Set object remote address
		ObjAddress = objAddress;

		// Read this struct
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		static size_t jSize = jStruct.GetSize();
		static int offsets[] =
		{
			jStruct["ArrayDim"].Offset,
			jStruct["ElementSize"].Offset,
			jStruct["PropertyFlags"].Offset,
			jStruct["Offset"].Offset,
			jStruct["PropertyLinkNext"].Offset,
			jStruct["NextRef"].Offset,
			jStruct["DestructorLinkNext"].Offset,
			jStruct["PostConstructLinkNext"].Offset
		};

		// Read Remote Memory
		bool dataAllocer = false;
		if (pData == nullptr)
		{
			dataAllocer = true;
			pData = new BYTE[jSize];

			// Read this struct
			if (m->ReadBytes(ObjAddress, pData, jSize) != jSize) return false;
		}

		// Init super variables first
		UField::ReadData(objAddress);

		// Init `this` variables
		FILL_DATA(pData, ArrayDim, offsets[0]);
		FILL_DATA(pData, ElementSize, offsets[1]);
		FILL_DATA(pData, PropertyFlags, offsets[2]);
		FILL_DATA(pData, Offset, offsets[3]);
		FILL_DATA(pData, PropertyLinkNext, offsets[4]);
		FILL_DATA(pData, NextRef, offsets[5]);
		FILL_DATA(pData, DestructorLinkNext, offsets[6]);
		FILL_DATA(pData, PostConstructLinkNext, offsets[7]);

		if (dataAllocer)
		{
			// Fix pointers for x32 games
			FixPointers(SIZE_OF_ME);

			delete pData;
			pData = nullptr;
		}
		return true;
	}

	bool ReadData()
	{
		return ReadData(ObjAddress);
	}

	int StructSize()
	{
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		return jStruct.GetSize();
	}
};

class UNumericProperty : public UProperty
{
public:
	std::string TypeName() { return "UNumericProperty"; }

	void FixPointers(const size_t fullCppStructSize)
	{
		UProperty::FixPointers(fullCppStructSize);
	}

	bool ReadData(const uintptr_t objAddress)
	{
		// Set object remote address
		ObjAddress = objAddress;

		// Read this struct
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		static size_t jSize = jStruct.GetSize();

		// Read Remote Memory
		bool dataAllocer = false;
		if (pData == nullptr)
		{
			dataAllocer = true;
			pData = new BYTE[jSize];

			// Read this struct
			if (m->ReadBytes(ObjAddress, pData, jSize) != jSize) return false;
		}

		// Init super variables first
		UProperty::ReadData(objAddress);

		if (dataAllocer)
		{
			// Fix pointers for x32 games
			FixPointers(SIZE_OF_ME);

			delete pData;
			pData = nullptr;
		}
		return true;
	}

	bool ReadData()
	{
		return ReadData(ObjAddress);
	}

	int StructSize()
	{
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		return jStruct.GetSize();
	}
};

class UByteProperty : public UNumericProperty
{
public:
	uintptr_t Enum = 0;

	std::string TypeName() { return "UByteProperty"; }

	void FixPointers(const size_t fullCppStructSize)
	{
		UNumericProperty::FixPointers(fullCppStructSize);
		Utils::FixPointers(this, fullCppStructSize, { OFFSET(Enum) });
	}

	bool ReadData(const uintptr_t objAddress)
	{
		// Set object remote address
		ObjAddress = objAddress;

		// Read this struct
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		static size_t jSize = jStruct.GetSize();
		static int offsets[] = { jStruct["Enum"].Offset };

		// Read Remote Memory
		bool dataAllocer = false;
		if (pData == nullptr)
		{
			dataAllocer = true;
			pData = new BYTE[jSize];

			// Read this struct
			if (m->ReadBytes(ObjAddress, pData, jSize) != jSize) return false;
		}

		// Init super variables first
		UNumericProperty::ReadData(objAddress);

		// Init `this` variables
		FILL_DATA(pData, Enum, offsets[0]);

		if (dataAllocer)
		{
			// Fix pointers for x32 games
			FixPointers(SIZE_OF_ME);

			delete pData;
			pData = nullptr;
		}
		return true;
	}

	bool ReadData()
	{
		return ReadData(ObjAddress);
	}

	int StructSize()
	{
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		return jStruct.GetSize();
	}
};

class UUInt16Property : public UNumericProperty
{
public:
	std::string TypeName() { return "UUInt16Property"; }

	void FixPointers(const size_t fullCppStructSize)
	{
		UNumericProperty::FixPointers(fullCppStructSize);
	}

	bool ReadData(const uintptr_t objAddress)
	{
		// Set object remote address
		ObjAddress = objAddress;

		// Read this struct
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		static size_t jSize = jStruct.GetSize();

		// Read Remote Memory
		bool dataAllocer = false;
		if (pData == nullptr)
		{
			dataAllocer = true;
			pData = new BYTE[jSize];

			// Read this struct
			if (m->ReadBytes(ObjAddress, pData, jSize) != jSize) return false;
		}

		// Init super variables first
		UNumericProperty::ReadData(objAddress);

		if (dataAllocer)
		{
			// Fix pointers for x32 games
			FixPointers(SIZE_OF_ME);

			delete pData;
			pData = nullptr;
		}
		return true;
	}

	bool ReadData()
	{
		return ReadData(ObjAddress);
	}

	int StructSize()
	{
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		return jStruct.GetSize();
	}
};

class UUInt32Property : public UNumericProperty
{
public:
	std::string TypeName() { return "UUInt32Property"; }

	void FixPointers(const size_t fullCppStructSize)
	{
		UNumericProperty::FixPointers(fullCppStructSize);
	}

	bool ReadData(const uintptr_t objAddress)
	{
		// Set object remote address
		ObjAddress = objAddress;

		// Read this struct
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		static size_t jSize = jStruct.GetSize();

		// Read Remote Memory
		bool dataAllocer = false;
		if (pData == nullptr)
		{
			dataAllocer = true;
			pData = new BYTE[jSize];

			// Read this struct
			if (m->ReadBytes(ObjAddress, pData, jSize) != jSize) return false;
		}

		// Init super variables first
		UNumericProperty::ReadData(objAddress);

		if (dataAllocer)
		{
			// Fix pointers for x32 games
			FixPointers(SIZE_OF_ME);

			delete pData;
			pData = nullptr;
		}
		return true;
	}

	bool ReadData()
	{
		return ReadData(ObjAddress);
	}

	int StructSize()
	{
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		return jStruct.GetSize();
	}
};

class UUInt64Property : public UNumericProperty
{
public:
	std::string TypeName() { return "UUInt64Property"; }

	void FixPointers(const size_t fullCppStructSize)
	{
		UNumericProperty::FixPointers(fullCppStructSize);
	}

	bool ReadData(const uintptr_t objAddress)
	{
		// Set object remote address
		ObjAddress = objAddress;

		// Read this struct
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		static size_t jSize = jStruct.GetSize();

		// Read Remote Memory
		bool dataAllocer = false;
		if (pData == nullptr)
		{
			dataAllocer = true;
			pData = new BYTE[jSize];

			// Read this struct
			if (m->ReadBytes(ObjAddress, pData, jSize) != jSize) return false;
		}

		// Init super variables first
		UNumericProperty::ReadData(objAddress);

		if (dataAllocer)
		{
			// Fix pointers for x32 games
			FixPointers(SIZE_OF_ME);

			delete pData;
			pData = nullptr;
		}
		return true;
	}

	bool ReadData()
	{
		return ReadData(ObjAddress);
	}

	int StructSize()
	{
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		return jStruct.GetSize();
	}
};

class UInt8Property : public UNumericProperty
{
public:
	std::string TypeName() { return "UInt8Property"; }

	void FixPointers(const size_t fullCppStructSize)
	{
		UNumericProperty::FixPointers(fullCppStructSize);
	}

	bool ReadData(const uintptr_t objAddress)
	{
		// Set object remote address
		ObjAddress = objAddress;

		// Read this struct
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		static size_t jSize = jStruct.GetSize();

		// Read Remote Memory
		bool dataAllocer = false;
		if (pData == nullptr)
		{
			dataAllocer = true;
			pData = new BYTE[jSize];

			// Read this struct
			if (m->ReadBytes(ObjAddress, pData, jSize) != jSize) return false;
		}

		// Init super variables first
		UNumericProperty::ReadData(objAddress);

		if (dataAllocer)
		{
			// Fix pointers for x32 games
			FixPointers(SIZE_OF_ME);

			delete pData;
			pData = nullptr;
		}
		return true;
	}

	bool ReadData()
	{
		return ReadData(ObjAddress);
	}

	int StructSize()
	{
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		return jStruct.GetSize();
	}
};

class UInt16Property : public UNumericProperty
{
public:
	std::string TypeName() { return "UInt16Property"; }

	void FixPointers(const size_t fullCppStructSize)
	{
		UNumericProperty::FixPointers(fullCppStructSize);
	}

	bool ReadData(const uintptr_t objAddress)
	{
		// Set object remote address
		ObjAddress = objAddress;

		// Read this struct
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		static size_t jSize = jStruct.GetSize();

		// Read Remote Memory
		bool dataAllocer = false;
		if (pData == nullptr)
		{
			dataAllocer = true;
			pData = new BYTE[jSize];

			// Read this struct
			if (m->ReadBytes(ObjAddress, pData, jSize) != jSize) return false;
		}

		// Init super variables first
		UNumericProperty::ReadData(objAddress);

		if (dataAllocer)
		{
			// Fix pointers for x32 games
			FixPointers(SIZE_OF_ME);

			delete pData;
			pData = nullptr;
		}
		return true;
	}

	bool ReadData()
	{
		return ReadData(ObjAddress);
	}

	int StructSize()
	{
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		return jStruct.GetSize();
	}
};

class UIntProperty : public UNumericProperty
{
public:
	std::string TypeName() { return "UIntProperty"; }

	void FixPointers(const size_t fullCppStructSize)
	{
		UNumericProperty::FixPointers(fullCppStructSize);
	}

	bool ReadData(const uintptr_t objAddress)
	{
		// Set object remote address
		ObjAddress = objAddress;

		// Read this struct
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		static size_t jSize = jStruct.GetSize();

		// Read Remote Memory
		bool dataAllocer = false;
		if (pData == nullptr)
		{
			dataAllocer = true;
			pData = new BYTE[jSize];

			// Read this struct
			if (m->ReadBytes(ObjAddress, pData, jSize) != jSize) return false;
		}

		// Init super variables first
		UNumericProperty::ReadData(objAddress);

		if (dataAllocer)
		{
			// Fix pointers for x32 games
			FixPointers(SIZE_OF_ME);

			delete pData;
			pData = nullptr;
		}
		return true;
	}

	bool ReadData()
	{
		return ReadData(ObjAddress);
	}

	int StructSize()
	{
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		return jStruct.GetSize();
	}
};

class UInt64Property : public UNumericProperty
{
public:
	std::string TypeName() { return "UInt64Property"; }

	void FixPointers(const size_t fullCppStructSize)
	{
		UNumericProperty::FixPointers(fullCppStructSize);
	}

	bool ReadData(const uintptr_t objAddress)
	{
		// Set object remote address
		ObjAddress = objAddress;

		// Read this struct
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		static size_t jSize = jStruct.GetSize();

		// Read Remote Memory
		bool dataAllocer = false;
		if (pData == nullptr)
		{
			dataAllocer = true;
			pData = new BYTE[jSize];

			// Read this struct
			if (m->ReadBytes(ObjAddress, pData, jSize) != jSize) return false;
		}

		// Init super variables first
		UNumericProperty::ReadData(objAddress);

		if (dataAllocer)
		{
			// Fix pointers for x32 games
			FixPointers(SIZE_OF_ME);

			delete pData;
			pData = nullptr;
		}
		return true;
	}

	bool ReadData()
	{
		return ReadData(ObjAddress);
	}

	int StructSize()
	{
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		return jStruct.GetSize();
	}
};

class UFloatProperty : public UNumericProperty
{
public:
	std::string TypeName() { return "UFloatProperty"; }

	void FixPointers(const size_t fullCppStructSize)
	{
		UNumericProperty::FixPointers(fullCppStructSize);
	}

	bool ReadData(const uintptr_t objAddress)
	{
		// Set object remote address
		ObjAddress = objAddress;

		// Read this struct
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		static size_t jSize = jStruct.GetSize();

		// Read Remote Memory
		bool dataAllocer = false;
		if (pData == nullptr)
		{
			dataAllocer = true;
			pData = new BYTE[jSize];

			// Read this struct
			if (m->ReadBytes(ObjAddress, pData, jSize) != jSize) return false;
		}

		// Init super variables first
		UNumericProperty::ReadData(objAddress);

		if (dataAllocer)
		{
			// Fix pointers for x32 games
			FixPointers(SIZE_OF_ME);

			delete pData;
			pData = nullptr;
		}
		return true;
	}

	bool ReadData()
	{
		return ReadData(ObjAddress);
	}

	int StructSize()
	{
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		return jStruct.GetSize();
	}
};

class UDoubleProperty : public UNumericProperty
{
public:
	std::string TypeName() { return "UDoubleProperty"; }

	void FixPointers(const size_t fullCppStructSize)
	{
		UNumericProperty::FixPointers(fullCppStructSize);
	}

	bool ReadData(const uintptr_t objAddress)
	{
		// Set object remote address
		ObjAddress = objAddress;

		// Read this struct
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		static size_t jSize = jStruct.GetSize();

		// Read Remote Memory
		bool dataAllocer = false;
		if (pData == nullptr)
		{
			dataAllocer = true;
			pData = new BYTE[jSize];

			// Read this struct
			if (m->ReadBytes(ObjAddress, pData, jSize) != jSize) return false;
		}

		// Init super variables first
		UNumericProperty::ReadData(objAddress);

		if (dataAllocer)
		{
			// Fix pointers for x32 games
			FixPointers(SIZE_OF_ME);

			delete pData;
			pData = nullptr;
		}
		return true;
	}

	bool ReadData()
	{
		return ReadData(ObjAddress);
	}

	int StructSize()
	{
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		return jStruct.GetSize();
	}
};

class UBoolProperty : public UProperty
{
public:
	uint8_t FieldSize = 0;
	uint8_t ByteOffset = 0;
	uint8_t ByteMask = 0;
	uint8_t FieldMask = 0;

	std::string TypeName() { return "UBoolProperty"; }

	void FixPointers(const size_t fullCppStructSize)
	{
		UProperty::FixPointers(fullCppStructSize);
	}

	bool ReadData(const uintptr_t objAddress)
	{
		// Set object remote address
		ObjAddress = objAddress;

		// Read this struct
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		static size_t jSize = jStruct.GetSize();
		static int offsets[] =
		{
			jStruct["FieldSize"].Offset,
			jStruct["ByteOffset"].Offset,
			jStruct["ByteMask"].Offset,
			jStruct["FieldMask"].Offset
		};

		// Read Remote Memory
		bool dataAllocer = false;
		if (pData == nullptr)
		{
			dataAllocer = true;
			pData = new BYTE[jSize];

			// Read this struct
			if (m->ReadBytes(ObjAddress, pData, jSize) != jSize) return false;
		}

		// Init super variables first
		UProperty::ReadData(objAddress);

		// Init `this` variables
		FILL_DATA(pData, FieldSize, offsets[0]);
		FILL_DATA(pData, ByteOffset, offsets[1]);
		FILL_DATA(pData, ByteMask, offsets[2]);
		FILL_DATA(pData, FieldMask, offsets[3]);

		if (dataAllocer)
		{
			// Fix pointers for x32 games
			FixPointers(SIZE_OF_ME);

			delete pData;
			pData = nullptr;
		}
		return true;
	}

	bool ReadData()
	{
		return ReadData(ObjAddress);
	}

	int StructSize()
	{
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		return jStruct.GetSize();
	}
};

class UObjectPropertyBase : public UProperty
{
public:
	uintptr_t PropertyClass = 0;

	std::string TypeName() { return "UObjectPropertyBase"; }

	void FixPointers(const size_t fullCppStructSize)
	{
		UProperty::FixPointers(fullCppStructSize);
		Utils::FixPointers(this, fullCppStructSize, { OFFSET(PropertyClass) });
	}

	bool ReadData(const uintptr_t objAddress)
	{
		// Set object remote address
		ObjAddress = objAddress;

		// Read this struct
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		static size_t jSize = jStruct.GetSize();
		static int offsets[] = { jStruct["PropertyClass"].Offset };

		// Read Remote Memory
		bool dataAllocer = false;
		if (pData == nullptr)
		{
			dataAllocer = true;
			pData = new BYTE[jSize];

			// Read this struct
			if (m->ReadBytes(ObjAddress, pData, jSize) != jSize) return false;
		}

		// Init super variables first
		UProperty::ReadData(objAddress);

		// Init `this` variables
		FILL_DATA(pData, PropertyClass, offsets[0]);

		if (dataAllocer)
		{
			// Fix pointers for x32 games
			FixPointers(SIZE_OF_ME);

			delete pData;
			pData = nullptr;
		}
		return true;
	}

	bool ReadData()
	{
		return ReadData(ObjAddress);
	}

	int StructSize()
	{
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		return jStruct.GetSize();
	}
};

class UObjectProperty : public UObjectPropertyBase
{
public:
	std::string TypeName() { return "UObjectProperty"; }

	void FixPointers(const size_t fullCppStructSize)
	{
		UObjectPropertyBase::FixPointers(fullCppStructSize);
	}

	bool ReadData(const uintptr_t objAddress)
	{
		// Set object remote address
		ObjAddress = objAddress;

		// Read this struct
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		static size_t jSize = jStruct.GetSize();

		// Read Remote Memory
		bool dataAllocer = false;
		if (pData == nullptr)
		{
			dataAllocer = true;
			pData = new BYTE[jSize];

			// Read this struct
			if (m->ReadBytes(ObjAddress, pData, jSize) != jSize) return false;
		}

		// Init super variables first
		UObjectPropertyBase::ReadData(objAddress);

		if (dataAllocer)
		{
			// Fix pointers for x32 games
			FixPointers(SIZE_OF_ME);

			delete pData;
			pData = nullptr;
		}
		return true;
	}

	bool ReadData()
	{
		return ReadData(ObjAddress);
	}

	int StructSize()
	{
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		return jStruct.GetSize();
	}
};

class UClassProperty : public UObjectProperty
{
public:
	uintptr_t MetaClass = 0;

	std::string TypeName() { return "UClassProperty"; }

	void FixPointers(const size_t fullCppStructSize)
	{
		UObjectProperty::FixPointers(fullCppStructSize);
		Utils::FixPointers(this, fullCppStructSize, { OFFSET(MetaClass) });
	}

	bool ReadData(const uintptr_t objAddress)
	{
		// Set object remote address
		ObjAddress = objAddress;

		// Read this struct
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		static size_t jSize = jStruct.GetSize();
		static int offsets[] = { jStruct["MetaClass"].Offset };

		// Read Remote Memory
		bool dataAllocer = false;
		if (pData == nullptr)
		{
			dataAllocer = true;
			pData = new BYTE[jSize];

			// Read this struct
			if (m->ReadBytes(ObjAddress, pData, jSize) != jSize) return false;
		}

		// Init super variables first
		UObjectProperty::ReadData(objAddress);

		// Init `this` variables
		FILL_DATA(pData, MetaClass, offsets[0]);

		if (dataAllocer)
		{
			// Fix pointers for x32 games
			FixPointers(SIZE_OF_ME);

			delete pData;
			pData = nullptr;
		}
		return true;
	}

	bool ReadData()
	{
		return ReadData(ObjAddress);
	}

	int StructSize()
	{
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		return jStruct.GetSize();
	}
};

class UInterfaceProperty : public UProperty
{
public:
	uintptr_t InterfaceClass = 0;

	std::string TypeName() { return "UInterfaceProperty"; }

	void FixPointers(const size_t fullCppStructSize)
	{
		UProperty::FixPointers(fullCppStructSize);
		Utils::FixPointers(this, fullCppStructSize, { OFFSET(InterfaceClass) });
	}

	bool ReadData(const uintptr_t objAddress)
	{
		// Set object remote address
		ObjAddress = objAddress;

		// Read this struct
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		static size_t jSize = jStruct.GetSize();
		static int offsets[] = { jStruct["InterfaceClass"].Offset };

		// Read Remote Memory
		bool dataAllocer = false;
		if (pData == nullptr)
		{
			dataAllocer = true;
			pData = new BYTE[jSize];

			// Read this struct
			if (m->ReadBytes(ObjAddress, pData, jSize) != jSize) return false;
		}

		// Init super variables first
		UProperty::ReadData(objAddress);

		// Init `this` variables
		FILL_DATA(pData, InterfaceClass, offsets[0]);

		if (dataAllocer)
		{
			// Fix pointers for x32 games
			FixPointers(SIZE_OF_ME);

			delete pData;
			pData = nullptr;
		}
		return true;
	}

	bool ReadData()
	{
		return ReadData(ObjAddress);
	}

	int StructSize()
	{
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		return jStruct.GetSize();
	}
};

class UWeakObjectProperty : public UObjectPropertyBase
{
public:
	std::string TypeName() { return "UWeakObjectProperty"; }

	void FixPointers(const size_t fullCppStructSize)
	{
		UObjectPropertyBase::FixPointers(fullCppStructSize);
	}

	bool ReadData(const uintptr_t objAddress)
	{
		// Set object remote address
		ObjAddress = objAddress;

		// Read this struct
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		static size_t jSize = jStruct.GetSize();

		// Read Remote Memory
		bool dataAllocer = false;
		if (pData == nullptr)
		{
			dataAllocer = true;
			pData = new BYTE[jSize];

			// Read this struct
			if (m->ReadBytes(ObjAddress, pData, jSize) != jSize) return false;
		}

		// Init super variables first
		UObjectPropertyBase::ReadData(objAddress);

		if (dataAllocer)
		{
			// Fix pointers for x32 games
			FixPointers(SIZE_OF_ME);

			delete pData;
			pData = nullptr;
		}
		return true;
	}

	bool ReadData()
	{
		return ReadData(ObjAddress);
	}

	int StructSize()
	{
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		return jStruct.GetSize();
	}
};

class ULazyObjectProperty : public UObjectPropertyBase
{
public:
	std::string TypeName() { return "ULazyObjectProperty"; }

	void FixPointers(const size_t fullCppStructSize)
	{
		UObjectPropertyBase::FixPointers(fullCppStructSize);
	}

	bool ReadData(const uintptr_t objAddress)
	{
		// Set object remote address
		ObjAddress = objAddress;

		// Read this struct
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		static size_t jSize = jStruct.GetSize();

		// Read Remote Memory
		bool dataAllocer = false;
		if (pData == nullptr)
		{
			dataAllocer = true;
			pData = new BYTE[jSize];

			// Read this struct
			if (m->ReadBytes(ObjAddress, pData, jSize) != jSize) return false;
		}

		// Init super variables first
		UObjectPropertyBase::ReadData(objAddress);

		if (dataAllocer)
		{
			// Fix pointers for x32 games
			FixPointers(SIZE_OF_ME);

			delete pData;
			pData = nullptr;
		}
		return true;
	}

	bool ReadData()
	{
		return ReadData(ObjAddress);
	}

	int StructSize()
	{
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		return jStruct.GetSize();
	}
};

class UAssetObjectProperty : public UObjectPropertyBase
{
public:
	std::string TypeName() { return "UAssetObjectProperty"; }

	void FixPointers(const size_t fullCppStructSize)
	{
		UObjectPropertyBase::FixPointers(fullCppStructSize);
	}

	bool ReadData(const uintptr_t objAddress)
	{
		// Set object remote address
		ObjAddress = objAddress;

		// Read this struct
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		static size_t jSize = jStruct.GetSize();

		// Read Remote Memory
		bool dataAllocer = false;
		if (pData == nullptr)
		{
			dataAllocer = true;
			pData = new BYTE[jSize];

			// Read this struct
			if (m->ReadBytes(ObjAddress, pData, jSize) != jSize) return false;
		}

		// Init super variables first
		UObjectPropertyBase::ReadData(objAddress);

		if (dataAllocer)
		{
			// Fix pointers for x32 games
			FixPointers(SIZE_OF_ME);

			delete pData;
			pData = nullptr;
		}
		return true;
	}

	bool ReadData()
	{
		return ReadData(ObjAddress);
	}

	int StructSize()
	{
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		return jStruct.GetSize();
	}
};

class UAssetClassProperty : public UAssetObjectProperty
{
public:
	uintptr_t MetaClass = 0;

	std::string TypeName() { return "UAssetClassProperty"; }

	void FixPointers(const size_t fullCppStructSize)
	{
		UAssetObjectProperty::FixPointers(fullCppStructSize);
		Utils::FixPointers(this, fullCppStructSize, { OFFSET(MetaClass) });
	}

	bool ReadData(const uintptr_t objAddress)
	{
		// Set object remote address
		ObjAddress = objAddress;

		// Read this struct
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		static size_t jSize = jStruct.GetSize();
		static int offsets[] = { jStruct["MetaClass"].Offset };

		// Read Remote Memory
		bool dataAllocer = false;
		if (pData == nullptr)
		{
			dataAllocer = true;
			pData = new BYTE[jSize];

			// Read this struct
			if (m->ReadBytes(ObjAddress, pData, jSize) != jSize) return false;
		}

		// Init super variables first
		UAssetObjectProperty::ReadData(objAddress);

		// Init `this` variables
		FILL_DATA(pData, MetaClass, offsets[0]);

		if (dataAllocer)
		{
			// Fix pointers for x32 games
			FixPointers(SIZE_OF_ME);

			delete pData;
			pData = nullptr;
		}
		return true;
	}

	bool ReadData()
	{
		return ReadData(ObjAddress);
	}

	int StructSize()
	{
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		return jStruct.GetSize();
	}
};

class UNameProperty : public UProperty
{
public:
	std::string TypeName() { return "UNameProperty"; }

	void FixPointers(const size_t fullCppStructSize)
	{
		UProperty::FixPointers(fullCppStructSize);
	}

	bool ReadData(const uintptr_t objAddress)
	{
		// Set object remote address
		ObjAddress = objAddress;

		// Read this struct
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		static size_t jSize = jStruct.GetSize();

		// Read Remote Memory
		bool dataAllocer = false;
		if (pData == nullptr)
		{
			dataAllocer = true;
			pData = new BYTE[jSize];

			// Read this struct
			if (m->ReadBytes(ObjAddress, pData, jSize) != jSize) return false;
		}

		// Init super variables first
		UProperty::ReadData(objAddress);

		if (dataAllocer)
		{
			// Fix pointers for x32 games
			FixPointers(SIZE_OF_ME);

			delete pData;
			pData = nullptr;
		}
		return true;
	}

	bool ReadData()
	{
		return ReadData(ObjAddress);
	}

	int StructSize()
	{
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		return jStruct.GetSize();
	}
};

class UStructProperty : public UProperty
{
public:
	uintptr_t Struct = 0;

	std::string TypeName() { return "UStructProperty"; }

	void FixPointers(const size_t fullCppStructSize)
	{
		UProperty::FixPointers(fullCppStructSize);
		Utils::FixPointers(this, fullCppStructSize, { OFFSET(Struct) });
	}

	bool ReadData(const uintptr_t objAddress)
	{
		// Set object remote address
		ObjAddress = objAddress;

		// Read this struct
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		static size_t jSize = jStruct.GetSize();
		static int offsets[] = { jStruct["Struct"].Offset };

		// Read Remote Memory
		bool dataAllocer = false;
		if (pData == nullptr)
		{
			dataAllocer = true;
			pData = new BYTE[jSize];

			// Read this struct
			if (m->ReadBytes(ObjAddress, pData, jSize) != jSize) return false;
		}

		// Init super variables first
		UProperty::ReadData(objAddress);

		// Init `this` variables
		FILL_DATA(pData, Struct, offsets[0]);

		if (dataAllocer)
		{
			// Fix pointers for x32 games
			FixPointers(SIZE_OF_ME);

			delete pData;
			pData = nullptr;
		}
		return true;
	}

	bool ReadData()
	{
		return ReadData(ObjAddress);
	}

	int StructSize()
	{
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		return jStruct.GetSize();
	}
};

class UStrProperty : public UProperty
{
public:
	std::string TypeName() { return "UStrProperty"; }

	void FixPointers(const size_t fullCppStructSize)
	{
		UProperty::FixPointers(fullCppStructSize);
	}

	bool ReadData(const uintptr_t objAddress)
	{
		// Set object remote address
		ObjAddress = objAddress;

		// Read this struct
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		static size_t jSize = jStruct.GetSize();

		// Read Remote Memory
		bool dataAllocer = false;
		if (pData == nullptr)
		{
			dataAllocer = true;
			pData = new BYTE[jSize];

			// Read this struct
			if (m->ReadBytes(ObjAddress, pData, jSize) != jSize) return false;
		}

		// Init super variables first
		UProperty::ReadData(objAddress);

		if (dataAllocer)
		{
			// Fix pointers for x32 games
			FixPointers(SIZE_OF_ME);

			delete pData;
			pData = nullptr;
		}
		return true;
	}

	bool ReadData()
	{
		return ReadData(ObjAddress);
	}

	int StructSize()
	{
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		return jStruct.GetSize();
	}
};

class UTextProperty : public UProperty
{
public:
	std::string TypeName() { return "UTextProperty"; }

	void FixPointers(const size_t fullCppStructSize)
	{
		UProperty::FixPointers(fullCppStructSize);
	}

	bool ReadData(const uintptr_t objAddress)
	{
		// Set object remote address
		ObjAddress = objAddress;

		// Read this struct
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		static size_t jSize = jStruct.GetSize();

		// Read Remote Memory
		bool dataAllocer = false;
		if (pData == nullptr)
		{
			dataAllocer = true;
			pData = new BYTE[jSize];

			// Read this struct
			if (m->ReadBytes(ObjAddress, pData, jSize) != jSize) return false;
		}

		// Init super variables first
		UProperty::ReadData(objAddress);

		if (dataAllocer)
		{
			// Fix pointers for x32 games
			FixPointers(SIZE_OF_ME);

			delete pData;
			pData = nullptr;
		}
		return true;
	}

	bool ReadData()
	{
		return ReadData(ObjAddress);
	}

	int StructSize()
	{
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		return jStruct.GetSize();
	}
};

class UArrayProperty : public UProperty
{
public:
	uintptr_t Inner = 0;

	std::string TypeName() { return "UArrayProperty"; }

	void FixPointers(const size_t fullCppStructSize)
	{
		UProperty::FixPointers(fullCppStructSize);
		Utils::FixPointers(this, fullCppStructSize, { OFFSET(Inner) });
	}

	bool ReadData(const uintptr_t objAddress)
	{
		// Set object remote address
		ObjAddress = objAddress;

		// Read this struct
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		static size_t jSize = jStruct.GetSize();
		static int offsets[] = { jStruct["Inner"].Offset };

		// Read Remote Memory
		bool dataAllocer = false;
		if (pData == nullptr)
		{
			dataAllocer = true;
			pData = new BYTE[jSize];

			// Read this struct
			if (m->ReadBytes(ObjAddress, pData, jSize) != jSize) return false;
		}

		// Init super variables first
		UProperty::ReadData(objAddress);

		// Init `this` variables
		FILL_DATA(pData, Inner, offsets[0]);

		if (dataAllocer)
		{
			// Fix pointers for x32 games
			FixPointers(SIZE_OF_ME);

			delete pData;
			pData = nullptr;
		}
		return true;
	}

	bool ReadData()
	{
		return ReadData(ObjAddress);
	}

	int StructSize()
	{
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		return jStruct.GetSize();
	}
};

class UMapProperty : public UProperty
{
public:
	uintptr_t KeyProp = 0;
	uintptr_t ValueProp = 0;

	std::string TypeName() { return "UMapProperty"; }

	void FixPointers(const size_t fullCppStructSize)
	{
		UProperty::FixPointers(fullCppStructSize);
		Utils::FixPointers(this, fullCppStructSize, {
			OFFSET(KeyProp),
			OFFSET(ValueProp)
		});
	}

	bool ReadData(const uintptr_t objAddress)
	{
		// Set object remote address
		ObjAddress = objAddress;

		// Read this struct
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		static size_t jSize = jStruct.GetSize();
		static int offsets[] =
		{
			jStruct["KeyProp"].Offset,
			jStruct["ValueProp"].Offset
		};

		// Read Remote Memory
		bool dataAllocer = false;
		if (pData == nullptr)
		{
			dataAllocer = true;
			pData = new BYTE[jSize];

			// Read this struct
			if (m->ReadBytes(ObjAddress, pData, jSize) != jSize) return false;
		}

		// Init super variables first
		UProperty::ReadData(objAddress);

		// Init `this` variables
		FILL_DATA(pData, KeyProp, offsets[0]);
		FILL_DATA(pData, ValueProp, offsets[1]);

		if (dataAllocer)
		{
			// Fix pointers for x32 games
			FixPointers(SIZE_OF_ME);

			delete pData;
			pData = nullptr;
		}
		return true;
	}

	bool ReadData()
	{
		return ReadData(ObjAddress);
	}

	int StructSize()
	{
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		return jStruct.GetSize();
	}
};

class UDelegateProperty : public UProperty
{
public:
	uintptr_t SignatureFunction = 0;

	std::string TypeName() { return "UDelegateProperty"; }

	void FixPointers(const size_t fullCppStructSize)
	{
		UProperty::FixPointers(fullCppStructSize);
		Utils::FixPointers(this, fullCppStructSize, { OFFSET(SignatureFunction) });
	}

	bool ReadData(const uintptr_t objAddress)
	{
		// Set object remote address
		ObjAddress = objAddress;

		// Read this struct
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		static size_t jSize = jStruct.GetSize();
		static int offsets[] = { jStruct["SignatureFunction"].Offset };

		// Read Remote Memory
		bool dataAllocer = false;
		if (pData == nullptr)
		{
			dataAllocer = true;
			pData = new BYTE[jSize];

			// Read this struct
			if (m->ReadBytes(ObjAddress, pData, jSize) != jSize) return false;
		}

		// Init super variables first
		UProperty::ReadData(objAddress);

		// Init `this` variables
		FILL_DATA(pData, SignatureFunction, offsets[0]);

		if (dataAllocer)
		{
			// Fix pointers for x32 games
			FixPointers(SIZE_OF_ME);

			delete pData;
			pData = nullptr;
		}
		return true;
	}

	bool ReadData()
	{
		return ReadData(ObjAddress);
	}

	int StructSize()
	{
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		return jStruct.GetSize();
	}
};

class UMulticastDelegateProperty : public UProperty
{
public:
	uintptr_t SignatureFunction = 0;

	std::string TypeName() { return "UMulticastDelegateProperty"; }

	void FixPointers(const size_t fullCppStructSize)
	{
		UProperty::FixPointers(fullCppStructSize);
		Utils::FixPointers(this, fullCppStructSize, { OFFSET(SignatureFunction) });
	}

	bool ReadData(const uintptr_t objAddress)
	{
		// Set object remote address
		ObjAddress = objAddress;

		// Read this struct
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		static size_t jSize = jStruct.GetSize();
		static int offsets[] = { jStruct["SignatureFunction"].Offset };

		// Read Remote Memory
		bool dataAllocer = false;
		if (pData == nullptr)
		{
			dataAllocer = true;
			pData = new BYTE[jSize];

			// Read this struct
			if (m->ReadBytes(ObjAddress, pData, jSize) != jSize) return false;
		}

		// Init super variables first
		UProperty::ReadData(objAddress);

		// Init `this` variables
		FILL_DATA(pData, SignatureFunction, offsets[0]);

		if (dataAllocer)
		{
			// Fix pointers for x32 games
			FixPointers(SIZE_OF_ME);

			delete pData;
			pData = nullptr;
		}
		return true;
	}

	bool ReadData()
	{
		return ReadData(ObjAddress);
	}

	int StructSize()
	{
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		return jStruct.GetSize();
	}
};

class UEnumProperty : public UProperty
{
public:
	uintptr_t UnderlyingProp = 0;
	uintptr_t Enum = 0;

	std::string TypeName() { return "UEnumProperty"; }

	void FixPointers(const size_t fullCppStructSize)
	{
		UProperty::FixPointers(fullCppStructSize);
		Utils::FixPointers(this, fullCppStructSize, {
			OFFSET(UnderlyingProp),
			OFFSET(Enum)
		});
	}

	bool ReadData(const uintptr_t objAddress)
	{
		// Set object remote address
		ObjAddress = objAddress;

		// Read this struct
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		static size_t jSize = jStruct.GetSize();
		static int offsets[] =
		{
			jStruct["UnderlyingProp"].Offset,
			jStruct["Enum"].Offset
		};

		// Read Remote Memory
		bool dataAllocer = false;
		if (pData == nullptr)
		{
			dataAllocer = true;
			pData = new BYTE[jSize];

			// Read this struct
			if (m->ReadBytes(ObjAddress, pData, jSize) != jSize) return false;
		}

		// Init super variables first
		UProperty::ReadData(objAddress);

		// Init `this` variables
		FILL_DATA(pData, UnderlyingProp, offsets[0]);
		FILL_DATA(pData, Enum, offsets[1]);

		if (dataAllocer)
		{
			// Fix pointers for x32 games
			FixPointers(SIZE_OF_ME);

			delete pData;
			pData = nullptr;
		}

		return true;
	}

	bool ReadData()
	{
		return ReadData(ObjAddress);
	}

	int StructSize()
	{
		static JsonStruct jStruct = JsonReflector::GetStruct(TypeName());
		return jStruct.GetSize();
	}
};
```

`UnrealFinderTool/SdkGen/MainGenerator.cpp`:

```cpp
#include "pch.h"
#include "IGenerator.h"
#include "ObjectsStore.h"

class Generator final : public IGenerator
{
	mutable std::string gameName;
	mutable std::string gameVersion;
	mutable bool isGObjectsChunks = false;
	mutable SdkType sdkType = SdkType::Internal;

public:
	bool Initialize() override
	{
		keywordsName =
		{
			{"return", "returnValue"},
			{"continue", "continueValue"},
			{"break", "breakValue"},
			{"int", "intValue"}
		};

		badChars =
		{
			{",", ""},
			{"!", ""}
		};

		alignasClasses =
		{
			{ "ScriptStruct CoreUObject.Plane", 16 },
			{ "ScriptStruct CoreUObject.Quat", 16 },
			{ "ScriptStruct CoreUObject.Transform", 16 },
			{ "ScriptStruct CoreUObject.Vector4", 16 },

			{ "ScriptStruct Engine.RootMotionSourceGroup", 8 }
		};

		virtualFunctionPattern["Class CoreUObject.Object"] =
		{
			{ 
				PatternScan::Parse("ProcessEvent", 0, "FF FF FF FF FF", 0xFE),
				R"(	inline void ProcessEvent(class UFunction* function, void* parms)
	{
		return GetVFunction<void(*)(UObject*, class UFunction*, void*)>(this, %d)(this, function, parms);
	})" 
			}
		};
		virtualFunctionPattern["Class CoreUObject.Class"] =
		{
			{
				PatternScan::Parse("CreateDefaultObject", 0, "4C 8B DC 57 48 81 EC", 0xFF),
				R"(	inline UObject* CreateDefaultObject()
	{
		return GetVFunction<UObject*(*)(UClass*)>(this, %d)(this);
	})"		}
		};

		predefinedMembers["Class CoreUObject.Object"] =
		{
			{ "void*", "Vtable" },
			{ "int32_t", "ObjectFlags" },
			{ "int32_t", "InternalIndex" },
			{ "class UClass*", "Class" },
			{ "FName", "Name" },
			{ "class UObject*", "Outer" }
		};
		predefinedStaticMembers["Class CoreUObject.Object"] =
		{
			{ "FUObjectArray*", "GObjects" }
		};
		predefinedMembers["Class CoreUObject.Field"] =
		{
			{ "class UField*", "Next" }
		};
		predefinedMembers["Class CoreUObject.Struct"] =
		{
			{ "class UStruct*", "SuperField" },
			{ "class UField*", "Children" },
			{ "int32_t", "PropertySize" },
			{ "int32_t", "MinAlignment" },
			{ "unsigned char", "UnknownData0x0048[0x40]" }
		};
		predefinedMembers["Class CoreUObject.Function"] =
		{
			{ "int32_t", "FunctionFlags" },
			{ "int16_t", "RepOffset" },
			{ "int8_t", "NumParms" },
			{ "int16_t", "ParmsSize" },
			{ "int16_t", "ReturnValueOffset" },
			{ "int16_t", "RPCId" },
			{ "int16_t", "RPCResponseId" },
			{ "class UProperty*", "FirstPropertyToInit" },
			{ "class UFunction*", "EventGraphFunction" },
			{ "int32_t", "EventGraphCallOffset" },
			{ "void*", "Func" }
		};

		predefinedMethods["ScriptStruct CoreUObject.Vector2D"] =
		{
			PredefinedMethod::Inline(R"(	inline FVector2D()
		: X(0), Y(0)
	{ })"),
			PredefinedMethod::Inline(R"(	inline FVector2D(float x, float y)
		: X(x),
		  Y(y)
	{ })")
		};
		predefinedMethods["ScriptStruct CoreUObject.LinearColor"] =
		{
			PredefinedMethod::Inline(R"(	inline FLinearColor()
		: R(0), G(0), B(0), A(0)
	{ })"),
			PredefinedMethod::Inline(R"(	inline FLinearColor(float r, float g, float b, float a)
		: R(r),
		  G(g),
		  B(b),
		  A(a)
	{ })")
		};

		predefinedMethods["Class CoreUObject.Object"] =
		{
			PredefinedMethod::Inline(R"(	static inline TUObjectArray& GetGlobalObjects()
	{
		return GObjects->ObjObjects;
	})"),
			PredefinedMethod::Default("std::string GetName() const", R"(std::string UObject::GetName() const
{
	std::string name(Name.GetName());
	if (Name.Number > 0)
	{
		name += '_' + std::to_string(Name.Number);
	}

	auto pos = name.rfind('/');
	if (pos == std::string::npos)
	{
		return name;
	}
	
	return name.substr(pos + 1);
})"),
			PredefinedMethod::Default("std::string GetFullName() const", R"(std::string UObject::GetFullName() const
{
	std::string name;

	if (Class != nullptr)
	{
		std::string temp;
		for (auto p = Outer; p; p = p->Outer)
		{
			temp = p->GetName() + "." + temp;
		}

		name = Class->GetName();
		name += " ";
		name += temp;
		name += GetName();
	}

	return name;
})"),
			PredefinedMethod::Inline(R"(	template<typename T>
	static T* FindObject(const std::string& name)
	{
		for (int i = 0; i < GetGlobalObjects().Num(); ++i)
		{
			auto object = GetGlobalObjects().GetByIndex(i);
	
			if (object == nullptr)
			{
				continue;
			}
	
			if (object->GetFullName() == name)
			{
				return static_cast<T*>(object);
			}
		}
		return nullptr;
	})"),
			PredefinedMethod::Inline(R"(	template<typename T>
	static T* FindObject()
	{
		auto v = T::StaticClass();
		for (int i = 0; i < SDK::UObject::GetGlobalObjects().Num(); ++i)
		{
			auto object = SDK::UObject::GetGlobalObjects().GetByIndex(i);

			if (object == nullptr)
			{
				continue;
			}

			if (object->IsA(v))
			{
				return static_cast<T*>(object);
			}
		}
		return nullptr;
	})"),
			PredefinedMethod::Inline(R"(	template<typename T>
	static std::vector<T*> FindObjects(const std::string& name)
	{
		std::vector<T*> ret;
		for (int i = 0; i < GetGlobalObjects().Num(); ++i)
		{
			auto object = GetGlobalObjects().GetByIndex(i);

			if (object == nullptr)
			{
				continue;
			}

			if (object->GetFullName() == name)
			{
				ret.push_back(static_cast<T*>(object));
			}
		}
		return ret;
	})"),
			PredefinedMethod::Inline(R"(	template<typename T>
	static std::vector<T*> FindObjects()
	{
		std::vector<T*> ret;
		auto v = T::StaticClass();
		for (int i = 0; i < SDK::UObject::GetGlobalObjects().Num(); ++i)
		{
			auto object = SDK::UObject::GetGlobalObjects().GetByIndex(i);

			if (object == nullptr)
			{
				continue;
			}

			if (object->IsA(v))
			{
				ret.push_back(static_cast<T*>(object));
			}
		}
		return ret;
	})"),
			PredefinedMethod::Inline(R"(	static UClass* FindClass(const std::string& name)
	{
		return FindObject<UClass>(name);
	})"),
			PredefinedMethod::Inline(R"(	template<typename T>
	static T* GetObjectCasted(std::size_t index)
	{
		return static_cast<T*>(GetGlobalObjects().GetByIndex(index));
	})"),
			PredefinedMethod::Default("bool IsA(UClass* cmp) const", R"(bool UObject::IsA(UClass* cmp) const
{
	for (auto super = Class; super; super = static_cast<UClass*>(super->SuperField))
	{
		if (super == cmp)
		{
			return true;
		}
	}

	return false;
})")
		};
		predefinedMethods["Class CoreUObject.Class"] =
		{
			PredefinedMethod::Inline(R"(	template<typename T>
	inline T* CreateDefaultObject()
	{
		return static_cast<T*>(CreateDefaultObject());
	})")
		};

		/*
		predefinedMethods["Class Engine.GameViewportClient"] =
		{
			PredefinedMethod::Inline(R"(	inline void PostRender(UCanvas* Canvas)
	{
		return GetVFunction<void(*)(UGameViewportClient*, UCanvas*)>(this, %d)(this, Canvas);
	})")
		};
		*/
		return true;
	}

	std::string GetGameName() const override
	{
		return gameName;
	}

	void SetGameName(const std::string& gameName) const override
	{
		this->gameName = gameName;
	}

	std::string GetGameVersion() const override
	{
		return this->gameVersion;
	}

	void SetGameVersion(const std::string& gameVersion) const override
	{
		this->gameVersion = gameVersion;
	}

	SdkType GetSdkType() const override
	{
		return this->sdkType;
	}

	void SetSdkType(const SdkType sdkType) const override
	{
		this->sdkType = sdkType;
	}

	std::string GetNamespaceName() const override
	{
		return "SDK";
	}

	std::vector<std::string> GetIncludes() const override
	{
		return { };
	}

	std::string GetBasicDeclarations() const override
	{
		std::string basic_str = R"(
void InitSdk(const std::string& moduleName, size_t gObjectsOffset, size_t gNamesOffset);

template<typename Fn>
inline Fn GetVFunction(const void* instance, std::size_t index)
{
	auto vtable = *reinterpret_cast<const void***>(const_cast<void*>(instance));
	return reinterpret_cast<Fn>(vtable[index]);
}

class UObject;

class FUObjectItem
{
public:
)";
		static JsonStruct jStruct = JsonReflector::GetStruct("FUObjectItem");
		for (const auto& varContainer : jStruct.Vars)
		{
			auto var = varContainer.second;
			std::string type = var.Type;
			if (Utils::IsNumber(type))
				basic_str += "\t" + std::string("unsigned char ") + var.Name + "[" + type + "]" + ";\n";
			else
				basic_str += "\t" + var.Type + " " + var.Name + ";\n";
		}
		basic_str += "\n";

		basic_str += R"(
	enum class ObjectFlags : int32_t
	{
		None = 0,
		Native = 1 << 25,
		Async = 1 << 26,
		AsyncLoading = 1 << 27,
		Unreachable = 1 << 28,
		PendingKill = 1 << 29,
		RootSet = 1 << 30,
		NoStrongReference = 1 << 31
	};

	inline bool IsUnreachable() const
	{
		return !!(Flags & static_cast<std::underlying_type_t<ObjectFlags>>(ObjectFlags::Unreachable));
	}
	inline bool IsPendingKill() const
	{
		return !!(Flags & static_cast<std::underlying_type_t<ObjectFlags>>(ObjectFlags::PendingKill));
	}
};)";
		if (!isGObjectsChunks)
		{
			basic_str += R"(
class TUObjectArray
{
public:
	inline int32_t Num() const
	{
		return NumElements;
	}

	inline UObject* GetByIndex(int32_t index) const
	{
		return Objects[index].Object;
	}

	inline FUObjectItem* GetItemByIndex(int32_t index) const
	{
		if (index < NumElements)
		{
			return &Objects[index];
		}
		return nullptr;
	}

private:
	FUObjectItem* Objects;
	int32_t MaxElements;
	int32_t NumElements;
};
)";
		}
		else
		{
			basic_str += R"(
class TUObjectArray
{
	enum
	{
		NumElementsPerChunk = 64 * 1024,
	};
public:
	inline int32_t Num() const
	{
		return NumElements;
	}

	inline int32_t Max() const
	{
		return MaxElements;
	}

	inline bool IsValidIndex(int32_t Index) const
	{
		return Index < Num() && Index >= 0;
	}

	inline FUObjectItem* GetObjectPtr(int32_t Index) const
	{
		const int32_t ChunkIndex = Index / NumElementsPerChunk;
		const int32_t WithinChunkIndex = Index % NumElementsPerChunk;
		if (!IsValidIndex(Index)) return nullptr;
		if (ChunkIndex > NumChunks) return nullptr;
		if (Index > MaxElements) return nullptr;
		FUObjectItem* Chunk = Objects[ChunkIndex];
		if (!Chunk) return nullptr;
		return Chunk + WithinChunkIndex;
	}

	inline UObject* GetByIndex(int32_t index) const
	{
		FUObjectItem* ItemPtr = GetObjectPtr(index);
		if (!ItemPtr) return nullptr;

		return (*ItemPtr).Object;
	}

	inline FUObjectItem* GetItemByIndex(int32_t index) const
	{
		FUObjectItem* ItemPtr = GetObjectPtr(index);
		if (!ItemPtr) return nullptr;
		return ItemPtr;
	}

private:
	FUObjectItem** Objects;
	FUObjectItem* PreAllocatedObjects;
	int32_t MaxElements;
	int32_t NumElements;
	int32_t MaxChunks;
	int32_t NumChunks;
};
)";
		}
		basic_str += R"(
class FUObjectArray
{
public:
	int32_t ObjFirstGCIndex;
	int32_t ObjLastNonGCIndex;
	int32_t MaxObjectsNotConsideredByGC;
	int32_t OpenForDisregardForGC;
	TUObjectArray ObjObjects;
};

template<class T>
struct TArray
{
	friend struct FString;

public:
	inline TArray()
	{
		Data = nullptr;
		Count = Max = 0;
	};

	inline int Num() const
	{
		return Count;
	};

	inline T& operator[](int i)
	{
		return Data[i];
	};

	inline const T& operator[](int i) const
	{
		return Data[i];
	};

	inline bool IsValidIndex(int i) const
	{
		return i < Num();
	}

private:
	T* Data;
	int32_t Count;
	int32_t Max;
};

class FNameEntry
{
public:
	static const auto NAME_WIDE_MASK = 0x1;
	static const auto NAME_INDEX_SHIFT = 1;

	int32_t Index;
	char UnknownData00[0x04];
	FNameEntry* HashNext;
	union
	{
		char AnsiName[1024];
		wchar_t WideName[1024];
	};

	inline const int32_t GetIndex() const
	{
		return Index >> NAME_INDEX_SHIFT;
	}

	inline bool IsWide() const
	{
		return Index & NAME_WIDE_MASK;
	}

	inline const char* GetAnsiName() const
	{
		return AnsiName;
	}

	inline const wchar_t* GetWideName() const
	{
		return WideName;
	}
};

template<typename ElementType, int32_t MaxTotalElements, int32_t ElementsPerChunk>
class TStaticIndirectArrayThreadSafeRead
{
public:
	inline size_t Num() const
	{
		return NumElements;
	}

	inline bool IsValidIndex(int32_t index) const
	{
		return index < Num() && index >= 0;
	}

	inline ElementType* operator[](int32_t index) const
	{
		ElementType* ItemPtr = GetItemPtr(index);
		return ItemPtr;
	}

private:
	inline ElementType* GetItemPtr(int32_t Index) const
	{
		int32_t ChunkIndex = Index / ElementsPerChunk;
		int32_t WithinChunkIndex = Index % ElementsPerChunk;
		ElementType* Chunk = (*Chunks)[ChunkIndex];
		int offset = WithinChunkIndex * )";
		basic_str += std::to_string(Utils::MemoryObj->Is64Bit ? 0x8 : 0x4) + R"(;
		uintptr_t ptrAddress = *reinterpret_cast<uintptr_t*>(reinterpret_cast<unsigned char*>(Chunk) + offset);
		ElementType* ItemPtr = reinterpret_cast<ElementType*>(ptrAddress);
		return ItemPtr;
	}

	enum
	{
		ChunkTableSize = (MaxTotalElements + ElementsPerChunk - 1) / ElementsPerChunk
	};

	ElementType** Chunks[ChunkTableSize];
	int32_t NumElements;
	int32_t NumChunks;
};

using TNameEntryArray = TStaticIndirectArrayThreadSafeRead<FNameEntry, 4 * 1024 * 1024, 16384>;

struct FName
{
	union
	{
		struct
		{
			int32_t ComparisonIndex;
			int32_t Number;
		};

		uint64_t CompositeComparisonValue;
	};

	inline FName()
		: ComparisonIndex(0),
		  Number(0)
	{
	};

	inline FName(int32_t i)
		: ComparisonIndex(i),
		  Number(0)
	{
	};

	FName(const char* nameToFind)
		: ComparisonIndex(0),
		  Number(0)
	{
		static std::set<int> cache;

		for (auto i : cache)
		{
			if (!std::strcmp(GetGlobalNames()[i]->GetAnsiName(), nameToFind))
			{
				ComparisonIndex = i;
				
				return;
			}
		}

		for (size_t i = 0; i < GetGlobalNames().Num(); ++i)
		{
			if (GetGlobalNames()[i] != nullptr)
			{
				if (!std::strcmp(GetGlobalNames()[i]->GetAnsiName(), nameToFind))
				{
					cache.insert(i);

					ComparisonIndex = i;

					return;
				}
			}
		}
	};

	static TNameEntryArray *GNames;
	static inline TNameEntryArray& GetGlobalNames()
	{
		return *GNames;
	};

	inline const char* GetName() const
	{
		return GetGlobalNames()[ComparisonIndex]->GetAnsiName();
	};

	inline bool operator==(const FName &other) const
	{
		return ComparisonIndex == other.ComparisonIndex;
	};
};

struct FString : private TArray<wchar_t>
{
	inline FString()
	{
	};

	FString(const wchar_t* other)
	{
		Max = Count = *other ? std::wcslen(other) + 1 : 0;

		if (Count)
		{
			Data = const_cast<wchar_t*>(other);
		}
	};

	inline bool IsValid() const
	{
		return Data != nullptr;
	}

	inline const wchar_t* c_str() const
	{
		return Data;
	}

	std::string ToString() const
	{
		auto length = std::wcslen(Data);

		std::string str(length, '\0');

		std::use_facet<std::ctype<wchar_t>>(std::locale()).narrow(Data, Data + length, '?', &str[0]);

		return str;
	}
};

template<class TEnum>
class TEnumAsByte
{
public:
	inline TEnumAsByte()
	{
	}

	inline TEnumAsByte(TEnum _value)
		: value(static_cast<uint8_t>(_value))
	{
	}

	explicit inline TEnumAsByte(int32_t _value)
		: value(static_cast<uint8_t>(_value))
	{
	}

	explicit inline TEnumAsByte(uint8_t _value)
		: value(_value)
	{
	}

	inline operator TEnum() const
	{
		return (TEnum)value;
	}

	inline TEnum GetValue() const
	{
		return (TEnum)value;
	}

private:
	uint8_t value;
};

class FScriptInterface
{
private:
	UObject* ObjectPointer;
	void* InterfacePointer;

public:
	inline UObject* GetObject() const
	{
		return ObjectPointer;
	}

	inline UObject*& GetObjectRef()
	{
		return ObjectPointer;
	}

	inline void* GetInterface() const
	{
		return ObjectPointer != nullptr ? InterfacePointer : nullptr;
	}
};

template<class InterfaceType>
class TScriptInterface : public FScriptInterface
{
public:
	inline InterfaceType* operator->() const
	{
		return (InterfaceType*)GetInterface();
	}

	inline InterfaceType& operator*() const
	{
		return *((InterfaceType*)GetInterface());
	}

	inline operator bool() const
	{
		return GetInterface() != nullptr;
	}
};

struct FText
{
	char UnknownData[0x18];
};

struct FScriptDelegate
{
	char UnknownData[14];
};

struct FScriptMulticastDelegate
{
	char UnknownData[16];
};

template<typename Key, typename Value>
class TMap
{
	char UnknownData[0x50];
};

struct FWeakObjectPtr
{
public:
	inline bool SerialNumbersMatch(FUObjectItem* ObjectItem) const
	{
		return ObjectItem->SerialNumber == ObjectSerialNumber;
	}

	bool IsValid() const;

	UObject* Get() const;

	int32_t ObjectIndex;
	int32_t ObjectSerialNumber;
};

template<class T, class TWeakObjectPtrBase = FWeakObjectPtr>
struct TWeakObjectPtr : private TWeakObjectPtrBase
{
public:
	inline T* Get() const
	{
		return (T*)TWeakObjectPtrBase::Get();
	}

	inline T& operator*() const
	{
		return *Get();
	}

	inline T* operator->() const
	{
		return Get();
	}

	inline bool IsValid() const
	{
		return TWeakObjectPtrBase::IsValid();
	}
};

template<class T, class TBASE>
class TAutoPointer : public TBASE
{
public:
	inline operator T*() const
	{
		return TBASE::Get();
	}

	inline operator const T*() const
	{
		return (const T*)TBASE::Get();
	}

	explicit inline operator bool() const
	{
		return TBASE::Get() != nullptr;
	}
};

template<class T>
class TAutoWeakObjectPtr : public TAutoPointer<T, TWeakObjectPtr<T>>
{
public:
};

template<typename TObjectID>
class TPersistentObjectPtr
{
public:
	FWeakObjectPtr WeakPtr;
	int32_t TagAtLastTest;
	TObjectID ObjectID;
};

struct FStringAssetReference_
{
	char UnknownData[0x10];
};

class FAssetPtr : public TPersistentObjectPtr<FStringAssetReference_>
{

};

template<typename ObjectType>
class TAssetPtr : FAssetPtr
{

};

struct FUniqueObjectGuid_
{
	char UnknownData[0x10];
};

class FLazyObjectPtr : public TPersistentObjectPtr<FUniqueObjectGuid_>
{

};

template<typename ObjectType>
class TLazyObjectPtr : FLazyObjectPtr
{

};)";
		return basic_str;
	}

	std::string GetBasicDefinitions() const override
	{
		return R"(
TNameEntryArray* FName::GNames = nullptr;
FUObjectArray* UObject::GObjects = nullptr;

//---------------------------------------------------------------------------
void InitSdk(const std::string& moduleName, const size_t gObjectsOffset, const size_t gNamesOffset)
{
	auto mBaseAddress = reinterpret_cast<uintptr_t>(GetModuleHandleA(moduleName.c_str()));

	UObject::GObjects = reinterpret_cast<SDK::FUObjectArray*>(mBaseAddress + gObjectsOffset);
	FName::GNames = reinterpret_cast<SDK::TNameEntryArray*>(mBaseAddress + gNamesOffset);
}
//---------------------------------------------------------------------------
bool FWeakObjectPtr::IsValid() const
{
	if (ObjectSerialNumber == 0)
	{
		return false;
	}
	if (ObjectIndex < 0)
	{
		return false;
	}
	auto ObjectItem = UObject::GetGlobalObjects().GetItemByIndex(ObjectIndex);
	if (!ObjectItem)
	{
		return false;
	}
	if (!SerialNumbersMatch(ObjectItem))
	{
		return false;
	}
	return !(ObjectItem->IsUnreachable() || ObjectItem->IsPendingKill());
}
//---------------------------------------------------------------------------
UObject* FWeakObjectPtr::Get() const
{
	if (IsValid())
	{
		auto ObjectItem = UObject::GetGlobalObjects().GetItemByIndex(ObjectIndex);
		if (ObjectItem)
		{
			return ObjectItem->Object;
		}
	}
	return nullptr;
}
//---------------------------------------------------------------------------)";
	}

	bool ShouldGenerateFunctionParametersFile() const override
	{
		return sdkType == SdkType::Internal;
	}

	void SetIsGObjectsChunks(const bool isChunks) const override
	{
		isGObjectsChunks = isChunks;
	}
};

Generator _generator;
IGenerator* generator = &_generator;
```

`UnrealFinderTool/SdkGen/MainGenericTypes.cpp`:

```cpp
#include "pch.h"
#include "../IGenerator.h"
#include "GenericTypes.h"
#include "ObjectsStore.h"
#include "NamesStore.h"
#include "NameValidator.h"
#include "MainEngineClasses.h"
#include "Utils.h"

//---------------------------------------------------------------------------
//UEObject
//---------------------------------------------------------------------------
bool UEObject::IsValid() const
{
	return Object.ObjAddress != NULL && Object.VfTable != NULL && (Object.Name.ComparisonIndex > 0 && size_t(Object.Name.ComparisonIndex) <= NamesStore().GetNamesNum());
}
size_t UEObject::GetIndex() const
{
	return Object.InternalIndex;
}
UEClass UEObject::GetClass() const
{
	if (objClass.Empty())
	{
		if (INVALID_POINTER_VALUE(Object.Class))
			return UEClass();

		objClass.ObjAddress = Object.Class;
		Utils::MemoryObj->Read<UClass>(objClass.ObjAddress, objClass, sizeof(uintptr_t)); // Skip ObjAddress in SdkUObject
		objClass.FixPointers(sizeof UClass);
	}

	return UEClass(objClass);
}
UEObject UEObject::GetOuter() const
{
	/*
	if (objObject.Empty())
	{
		// Init
		JsonStruct uObject;

		// Read as UObject
		uObject.ReadData(Object.Outer, "UObject");

		// Fill Data into obj
		objObject.ObjAddress = Object.Outer;
		objObject = uObject;
	}
	*/
	if (objOuter.Empty())
	{
		if (INVALID_POINTER_VALUE(Object.Outer))
			return UEObject();

		objOuter.ObjAddress = Object.Outer;
		Utils::MemoryObj->Read<UObject>(objOuter.ObjAddress, objOuter, sizeof(uintptr_t)); // Skip ObjAddress in SdkUObject
		objOuter.FixPointers(sizeof UObject);
	}

	return UEObject(objOuter);
}
std::string UEObject::GetName() const
{
	if (!objName.empty())
		return objName;

	auto name = NamesStore().GetById(Object.Name.ComparisonIndex);
	if (!name.empty() && Object.Name.Number > 0)
	{
		name += '_' + std::to_string(Object.Name.Number);
	}

	auto pos = name.rfind('/');
	if (pos == std::string::npos)
	{
		objName = name;
		return name;
	}

	objName = name.substr(pos + 1);
	return objName;
}
UEClass UEObject::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class "+ Utils::Settings.SdkGen.CorePackageName + ".Object");
	return c;
}

//---------------------------------------------------------------------------
//UEField
//---------------------------------------------------------------------------
UEField UEField::GetNext() const
{
	if (objField.Empty())
		objField = Object.Cast<UField>();

	if (next.Empty())
	{
		if (INVALID_POINTER_VALUE(objField.Next))
			return UEField();

		next.ObjAddress = objField.Next;
		Utils::MemoryObj->Read<UField>(next.ObjAddress, next, sizeof(uintptr_t)); // Skip ObjAddress in SdkUObject
		next.FixPointers(sizeof UField);
	}

	return UEField(next);
}
UEClass UEField::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".Field");
	return c;
}

//---------------------------------------------------------------------------
//UEEnum
//---------------------------------------------------------------------------
std::vector<std::string> UEEnum::GetNames() const
{
	std::vector<std::string> buffer;
	if (objEnum.Empty())
		objEnum = Object.Cast<UEnum>();

	// Get Names
	uintptr_t dataAddress = objEnum.Names.Data;
	auto cls = new FUEnumItem[objEnum.Names.Num];
	Utils::MemoryObj->ReadBytes(dataAddress, cls, sizeof(FUEnumItem) * objEnum.Names.Num);

	buffer.reserve(objEnum.Names.Num);
	for (auto i = 0; i < objEnum.Names.Num; ++i)
	{
		size_t index = cls[i].Key.ComparisonIndex;
		if (index > NamesStore().GetNamesNum() || index == 0)
			continue;

		buffer.push_back(NamesStore().GetById(index));
	}

	delete[] cls;
	return buffer;
}
UEClass UEEnum::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".Enum");
	return c;
}

//---------------------------------------------------------------------------
//UEConst
//---------------------------------------------------------------------------
std::string UEConst::GetValue() const
{
	throw;
}
UEClass UEConst::StaticClass()
{
	//not supported by UE4
	return UEClass();
}

//---------------------------------------------------------------------------
//UEStruct
//---------------------------------------------------------------------------
UEStruct UEStruct::GetSuper() const
{
	if (objStruct.Empty())
		objStruct = Object.Cast<UStruct>();

	if (superField.Empty())
	{
		if (INVALID_POINTER_VALUE(objStruct.SuperField))
			return UEStruct();

		superField.ObjAddress = objStruct.SuperField;
		Utils::MemoryObj->Read<UStruct>(superField.ObjAddress, superField, sizeof(uintptr_t)); // Skip ObjAddress in SdkUObject
		superField.FixPointers(sizeof UStruct);
	}

	//Sleep(1);
	return UEStruct(superField);
}
UEField UEStruct::GetChildren() const
{
	if (objStruct.Empty())
		objStruct = Object.Cast<UStruct>();

	if (children.Empty())
	{
		if (INVALID_POINTER_VALUE(objStruct.Children))
			return UEField();

		children.ObjAddress = objStruct.Children;
		Utils::MemoryObj->Read<UField>(children.ObjAddress, children, sizeof(uintptr_t)); // Skip ObjAddress in SdkUObject
		children.FixPointers(sizeof UField);
	}

	return UEField(children);
}
size_t UEStruct::GetPropertySize() const
{
	if (objStruct.Empty())
		objStruct = Object.Cast<UStruct>();

	return objStruct.PropertySize;
}
UEClass UEStruct::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".Struct");
	return c;
}

//---------------------------------------------------------------------------
//UEScriptStruct
//---------------------------------------------------------------------------
UEClass UEScriptStruct::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".ScriptStruct");
	return c;
}

//---------------------------------------------------------------------------
//UEFunction
//---------------------------------------------------------------------------
UEFunctionFlags UEFunction::GetFunctionFlags() const
{
	if (objFunction.Empty())
		objFunction = Object.Cast<UFunction>();

	return static_cast<UEFunctionFlags>(objFunction.FunctionFlags);
}
UEClass UEFunction::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".Function");
	return c;
}

//---------------------------------------------------------------------------
//UEClass
//---------------------------------------------------------------------------
UEClass UEClass::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".Class");
	return c;
}

//---------------------------------------------------------------------------
//UEProperty
//---------------------------------------------------------------------------
size_t UEProperty::GetArrayDim() const
{
	if (objProperty.Empty())
		objProperty = Object.Cast<UProperty>();

	return objProperty.ArrayDim;
}
size_t UEProperty::GetElementSize() const
{
	if (objProperty.Empty())
		objProperty = Object.Cast<UProperty>();

	return objProperty.ElementSize;
}
UEPropertyFlags UEProperty::GetPropertyFlags() const
{
	if (objProperty.Empty())
		objProperty = Object.Cast<UProperty>();

	return static_cast<UEPropertyFlags>(objProperty.PropertyFlags.A);
}
size_t UEProperty::GetOffset() const
{
	if (objProperty.Empty())
		objProperty = Object.Cast<UProperty>();

	return objProperty.Offset;
}
UEClass UEProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".Property");
	return c;
}

//---------------------------------------------------------------------------
//UENumericProperty
//---------------------------------------------------------------------------
UEClass UENumericProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".NumericProperty");
	return c;
}

//---------------------------------------------------------------------------
//UEByteProperty
//---------------------------------------------------------------------------
UEEnum UEByteProperty::GetEnum() const
{
	if (objByteProperty.Empty())
		objByteProperty = Object.Cast<UByteProperty>();

	if (enumProperty.Empty())
	{
		if (INVALID_POINTER_VALUE(objByteProperty.Enum))
			return UEEnum();

		enumProperty.ObjAddress = objByteProperty.Enum;
		Utils::MemoryObj->Read<UEnum>(enumProperty.ObjAddress, enumProperty, sizeof(uintptr_t)); // Skip ObjAddress in SdkUObject
		enumProperty.FixPointers(sizeof UEnum);
	}

	return UEEnum(enumProperty);
}
UEProperty::Info UEByteProperty::GetInfo() const
{
	if (IsEnum())
	{
		return Info::Create(PropertyType::Primitive, sizeof(uint8_t), false, "TEnumAsByte<" + MakeUniqueCppName(GetEnum()) + ">");
	}
	return Info::Create(PropertyType::Primitive, sizeof(uint8_t), false, "unsigned char");
}
UEClass UEByteProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".ByteProperty");
	return c;
}

//---------------------------------------------------------------------------
//UEUInt16Property
//---------------------------------------------------------------------------
UEProperty::Info UEUInt16Property::GetInfo() const
{
	return Info::Create(PropertyType::Primitive, sizeof(uint16_t), false, "uint16_t");
}
UEClass UEUInt16Property::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".UInt16Property");
	return c;
}

//---------------------------------------------------------------------------
//UEUInt32Property
//---------------------------------------------------------------------------
UEProperty::Info UEUInt32Property::GetInfo() const
{
	return Info::Create(PropertyType::Primitive, sizeof(uint32_t), false, "uint32_t");
}
UEClass UEUInt32Property::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".UInt32Property");
	return c;
}

//---------------------------------------------------------------------------
//UEUInt64Property
//---------------------------------------------------------------------------
UEProperty::Info UEUInt64Property::GetInfo() const
{
	return Info::Create(PropertyType::Primitive, sizeof(uint64_t), false, "uint64_t");
}
UEClass UEUInt64Property::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".UInt64Property");
	return c;
}

//---------------------------------------------------------------------------
//UEInt8Property
//---------------------------------------------------------------------------
UEProperty::Info UEInt8Property::GetInfo() const
{
	return Info::Create(PropertyType::Primitive, sizeof(int8_t), false, "int8_t");
}
UEClass UEInt8Property::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".Int8Property");
	return c;
}

//---------------------------------------------------------------------------
//UEInt16Property
//---------------------------------------------------------------------------
UEProperty::Info UEInt16Property::GetInfo() const
{
	return Info::Create(PropertyType::Primitive, sizeof(int16_t), false, "int16_t");
}
UEClass UEInt16Property::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".Int16Property");
	return c;
}

//---------------------------------------------------------------------------
//UEIntProperty
//---------------------------------------------------------------------------
UEProperty::Info UEIntProperty::GetInfo() const
{
	return Info::Create(PropertyType::Primitive, sizeof(int), false, "int");
}
UEClass UEIntProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".IntProperty");
	return c;
}

//---------------------------------------------------------------------------
//UEInt64Property
//---------------------------------------------------------------------------
UEProperty::Info UEInt64Property::GetInfo() const
{
	return Info::Create(PropertyType::Primitive, sizeof(int64_t), false, "int64_t");
}
UEClass UEInt64Property::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".Int64Property");
	return c;
}

//---------------------------------------------------------------------------
//UEFloatProperty
//---------------------------------------------------------------------------
UEProperty::Info UEFloatProperty::GetInfo() const
{
	return Info::Create(PropertyType::Primitive, sizeof(float), false, "float");
}
UEClass UEFloatProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".FloatProperty");
	return c;
}

//---------------------------------------------------------------------------
//UEDoubleProperty
//---------------------------------------------------------------------------
UEProperty::Info UEDoubleProperty::GetInfo() const
{
	return Info::Create(PropertyType::Primitive, sizeof(double), false, "double");
}
UEClass UEDoubleProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".DoubleProperty");
	return c;
}

//---------------------------------------------------------------------------
//UEBoolProperty
//---------------------------------------------------------------------------
uint8_t UEBoolProperty::GetFieldSize() const
{
	if (objBoolProperty.Empty())
		objBoolProperty = Object.Cast<UBoolProperty>();

	return objBoolProperty.FieldSize;
}
uint8_t UEBoolProperty::GetByteOffset() const
{
	if (objBoolProperty.Empty())
		objBoolProperty = Object.Cast<UBoolProperty>();

	return objBoolProperty.ByteOffset;
}
uint8_t UEBoolProperty::GetByteMask() const
{
	if (objBoolProperty.Empty())
		objBoolProperty = Object.Cast<UBoolProperty>();

	return objBoolProperty.ByteMask;
}
uint8_t UEBoolProperty::GetFieldMask() const
{
	if (objBoolProperty.Empty())
		objBoolProperty = Object.Cast<UBoolProperty>();

	return objBoolProperty.FieldMask;
}
UEProperty::Info UEBoolProperty::GetInfo() const
{
	if (IsNativeBool())
	{
		return Info::Create(PropertyType::Primitive, sizeof(bool), false, "bool");
	}
	return Info::Create(PropertyType::Primitive, sizeof(unsigned char), false, "unsigned char");
}
UEClass UEBoolProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".BoolProperty");
	return c;
}

//---------------------------------------------------------------------------
//UEObjectPropertyBase
//---------------------------------------------------------------------------
UEClass UEObjectPropertyBase::GetPropertyClass() const
{
	if (objObjectPropertyBase.Empty())
		objObjectPropertyBase = Object.Cast<UObjectPropertyBase>();

	if (propertyClass.Empty())
	{
		if (INVALID_POINTER_VALUE(objObjectPropertyBase.PropertyClass))
			return UEClass();

		propertyClass.ObjAddress = objObjectPropertyBase.PropertyClass;
		Utils::MemoryObj->Read<UObjectPropertyBase>(propertyClass.ObjAddress, propertyClass, sizeof(uintptr_t)); // Skip ObjAddress in SdkUObject
		propertyClass.FixPointers(sizeof UObjectPropertyBase);
	}

	return UEClass(propertyClass);
}
UEClass UEObjectPropertyBase::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".ObjectPropertyBase");
	return c;
}

//---------------------------------------------------------------------------
//UEObjectProperty
//---------------------------------------------------------------------------
UEProperty::Info UEObjectProperty::GetInfo() const
{
	return Info::Create(PropertyType::Primitive, sizeof(void*), false, "class " + MakeValidName(GetPropertyClass().GetNameCPP()) + "*");
}
UEClass UEObjectProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".ObjectProperty");
	return c;
}

//---------------------------------------------------------------------------
//UEClassProperty
//---------------------------------------------------------------------------
UEClass UEClassProperty::GetMetaClass() const
{
	if (objClassProperty.Empty())
		objClassProperty = Object.Cast<UClassProperty>();

	if (metaClass.Empty())
	{
		if (INVALID_POINTER_VALUE(objClassProperty.MetaClass))
			return UEClass();

		metaClass.ObjAddress = objClassProperty.MetaClass;
		Utils::MemoryObj->Read<UClassProperty>(metaClass.ObjAddress, metaClass, sizeof(uintptr_t)); // Skip ObjAddress in SdkUObject
		metaClass.FixPointers(sizeof UClassProperty);
	}

	return UEClass(metaClass);
}
UEProperty::Info UEClassProperty::GetInfo() const
{
	return Info::Create(PropertyType::Primitive, sizeof(void*), false, "class " + MakeValidName(GetMetaClass().GetNameCPP()) + "*");
}
UEClass UEClassProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".ClassProperty");
	return c;
}

//---------------------------------------------------------------------------
//UEInterfaceProperty
//---------------------------------------------------------------------------
UEClass UEInterfaceProperty::GetInterfaceClass() const
{
	if (objInterfaceProperty.Empty())
		objInterfaceProperty = Object.Cast<UInterfaceProperty>();

	if (interfaceClass.Empty())
	{
		if (INVALID_POINTER_VALUE(objInterfaceProperty.InterfaceClass))
			return UEClass();

		interfaceClass.ObjAddress = objInterfaceProperty.InterfaceClass;
		Utils::MemoryObj->Read<UInterfaceProperty>(interfaceClass.ObjAddress, interfaceClass, sizeof(uintptr_t)); // Skip ObjAddress in SdkUObject
		interfaceClass.FixPointers(sizeof UInterfaceProperty);
	}

	return UEClass(interfaceClass);
}
UEProperty::Info UEInterfaceProperty::GetInfo() const
{
	return Info::Create(PropertyType::PredefinedStruct, sizeof(FScriptInterface), true, "TScriptInterface<class " + MakeValidName(GetInterfaceClass().GetNameCPP()) + ">");
}
UEClass UEInterfaceProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".InterfaceProperty");
	return c;
}

//---------------------------------------------------------------------------
//UEWeakObjectProperty
//---------------------------------------------------------------------------
UEProperty::Info UEWeakObjectProperty::GetInfo() const
{
	return Info::Create(PropertyType::Container, sizeof(FWeakObjectPtr), false, "TWeakObjectPtr<class " + MakeValidName(GetPropertyClass().GetNameCPP()) + ">");
}
UEClass UEWeakObjectProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".WeakObjectProperty");
	return c;
}

//---------------------------------------------------------------------------
//UELazyObjectProperty
//---------------------------------------------------------------------------
UEProperty::Info UELazyObjectProperty::GetInfo() const
{
	return Info::Create(PropertyType::Container, sizeof(FLazyObjectPtr), false, "TLazyObjectPtr<class " + MakeValidName(GetPropertyClass().GetNameCPP()) + ">");
}
UEClass UELazyObjectProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".LazyObjectProperty");
	return c;
}

//---------------------------------------------------------------------------
//UEAssetObjectProperty
//---------------------------------------------------------------------------
UEProperty::Info UEAssetObjectProperty::GetInfo() const
{
	return Info::Create(PropertyType::Container, sizeof(FAssetPtr), false, "TAssetPtr<class " + MakeValidName(GetPropertyClass().GetNameCPP()) + ">");
}
UEClass UEAssetObjectProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".AssetObjectProperty");
	return c;
}

//---------------------------------------------------------------------------
//UEAssetClassProperty
//---------------------------------------------------------------------------
UEClass UEAssetClassProperty::GetMetaClass() const
{
	if (objAssetClassProperty.Empty())
		objAssetClassProperty = Object.Cast<UAssetClassProperty>();

	if (metaClass.Empty())
	{
		if (INVALID_POINTER_VALUE(objAssetClassProperty.MetaClass))
			return UEClass();

		metaClass.ObjAddress = objAssetClassProperty.MetaClass;
		Utils::MemoryObj->Read<UClass>(metaClass.ObjAddress, metaClass, sizeof(uintptr_t)); // Skip ObjAddress in SdkUObject
		metaClass.FixPointers(sizeof UClass);
	}

	return UEClass(metaClass);
}
UEProperty::Info UEAssetClassProperty::GetInfo() const
{
	return Info::Create(PropertyType::Primitive, sizeof(uint8_t), false, "");
}
UEClass UEAssetClassProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".AssetClassProperty");
	return c;
}

//---------------------------------------------------------------------------
//UENameProperty
//---------------------------------------------------------------------------
UEProperty::Info UENameProperty::GetInfo() const
{
	return Info::Create(PropertyType::PredefinedStruct, sizeof(FName), true, "struct FName");
}
UEClass UENameProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".NameProperty");
	return c;
}

//---------------------------------------------------------------------------
//UEStructProperty
//---------------------------------------------------------------------------
UEScriptStruct UEStructProperty::GetStruct() const
{
	if (objStructProperty.Empty())
		objStructProperty = Object.Cast<UStructProperty>();

	if (objStruct.Empty())
	{
		if (INVALID_POINTER_VALUE(objStructProperty.Struct))
			return UEScriptStruct();

		objStruct.ObjAddress = objStructProperty.Struct;
		Utils::MemoryObj->Read<UStructProperty>(objStruct.ObjAddress, objStruct, sizeof(uintptr_t)); // Skip ObjAddress in SdkUObject
		objStruct.FixPointers(sizeof UStructProperty);
	}

	return UEScriptStruct(objStruct);
}
UEProperty::Info UEStructProperty::GetInfo() const
{
	return Info::Create(PropertyType::CustomStruct, GetElementSize(), true, "struct " + MakeUniqueCppName(GetStruct()));
}
UEClass UEStructProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".StructProperty");
	return c;
}

//---------------------------------------------------------------------------
//UEStrProperty
//---------------------------------------------------------------------------
UEProperty::Info UEStrProperty::GetInfo() const
{
	return Info::Create(PropertyType::PredefinedStruct, sizeof(FString), true, "struct FString");
}
UEClass UEStrProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".StrProperty");
	return c;
}

//---------------------------------------------------------------------------
//UETextProperty
//---------------------------------------------------------------------------
UEProperty::Info UETextProperty::GetInfo() const
{
	return Info::Create(PropertyType::PredefinedStruct, sizeof(FText), true, "struct FText");
}
UEClass UETextProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".TextProperty");
	return c;
}

//---------------------------------------------------------------------------
//UEArrayProperty
//---------------------------------------------------------------------------
UEProperty UEArrayProperty::GetInner() const
{
	if (objArrayProperty.Empty())
		objArrayProperty = Object.Cast<UArrayProperty>();

	if (inner.Empty())
	{
		if (INVALID_POINTER_VALUE(objArrayProperty.Inner))
			return UEProperty();

		inner.ObjAddress = objArrayProperty.Inner;
		Utils::MemoryObj->Read<UArrayProperty>(inner.ObjAddress, inner, sizeof(uintptr_t)); // Skip ObjAddress in SdkUObject
		inner.FixPointers(sizeof UArrayProperty);
	}

	return UEProperty(inner);
}
UEProperty::Info UEArrayProperty::GetInfo() const
{
	auto inner = GetInner().GetInfo();
	if (inner.Type != PropertyType::Unknown)
	{
		extern IGenerator* generator;

		return Info::Create(PropertyType::Container, sizeof(TArray<void*>), false, "TArray<" + generator->GetOverrideType(inner.CppType) + ">");
	}

	return { PropertyType::Unknown };
}
UEClass UEArrayProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".ArrayProperty");
	return c;
}

//---------------------------------------------------------------------------
//UEMapProperty
//---------------------------------------------------------------------------
UEProperty UEMapProperty::GetKeyProperty() const
{
	if (objMapProperty.Empty())
		objMapProperty = Object.Cast<UMapProperty>();

	if (keyProp.Empty())
	{
		if (INVALID_POINTER_VALUE(objMapProperty.KeyProp))
			return UEProperty();

		keyProp.ObjAddress = objMapProperty.KeyProp;
		Utils::MemoryObj->Read<UMapProperty>(keyProp.ObjAddress, keyProp, sizeof(uintptr_t)); // Skip ObjAddress in SdkUObject
		keyProp.FixPointers(sizeof UMapProperty);
	}

	return UEProperty(keyProp);
}
UEProperty UEMapProperty::GetValueProperty() const
{
	if (objMapProperty.Empty())
		objMapProperty = Object.Cast<UMapProperty>();

	if (valueProp.Empty())
	{
		if (INVALID_POINTER_VALUE(objMapProperty.ValueProp))
			return UEProperty();

		valueProp.ObjAddress = objMapProperty.ValueProp;
		Utils::MemoryObj->Read<UMapProperty>(valueProp.ObjAddress, valueProp, sizeof(uintptr_t)); // Skip ObjAddress in SdkUObject
		valueProp.FixPointers(sizeof UMapProperty);
	}

	return UEProperty(valueProp);
}
UEProperty::Info UEMapProperty::GetInfo() const
{
	auto key = GetKeyProperty().GetInfo();
	auto value = GetValueProperty().GetInfo();
	if (key.Type != PropertyType::Unknown && value.Type != PropertyType::Unknown)
	{
		extern IGenerator* generator;

		return Info::Create(PropertyType::Container, 0x50, false, "TMap<" + generator->GetOverrideType(key.CppType) + ", " + generator->GetOverrideType(value.CppType) + ">");
	}

	return { PropertyType::Unknown };
}
UEClass UEMapProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".MapProperty");
	return c;
}

//---------------------------------------------------------------------------
//UEDelegateProperty
//---------------------------------------------------------------------------
UEFunction UEDelegateProperty::GetSignatureFunction() const
{
	if (objDelegateProperty.Empty())
		objDelegateProperty = Object.Cast<UDelegateProperty>();

	if (signatureFunction.Empty())
	{
		if (INVALID_POINTER_VALUE(objDelegateProperty.SignatureFunction))
			return UEFunction();

		signatureFunction.ObjAddress = objDelegateProperty.SignatureFunction;
		Utils::MemoryObj->Read<UDelegateProperty>(signatureFunction.ObjAddress, signatureFunction, sizeof(uintptr_t)); // Skip ObjAddress in SdkUObject
		signatureFunction.FixPointers(sizeof UDelegateProperty);
	}

	return UEFunction(signatureFunction);
}
UEProperty::Info UEDelegateProperty::GetInfo() const
{
	return Info::Create(PropertyType::PredefinedStruct, sizeof(FScriptDelegate), true, "struct FScriptDelegate");
}
UEClass UEDelegateProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".DelegateProperty");
	return c;
}

//---------------------------------------------------------------------------
//UEMulticastDelegateProperty
//---------------------------------------------------------------------------
UEFunction UEMulticastDelegateProperty::GetSignatureFunction() const
{
	if (objDelegateProperty.Empty())
		objDelegateProperty = Object.Cast<UDelegateProperty>();

	if (signatureFunction.Empty())
	{
		if (INVALID_POINTER_VALUE(objDelegateProperty.SignatureFunction))
			return UEFunction();

		signatureFunction.ObjAddress = objDelegateProperty.SignatureFunction;
		Utils::MemoryObj->Read<UDelegateProperty>(signatureFunction.ObjAddress, signatureFunction, sizeof(uintptr_t)); // Skip ObjAddress in SdkUObject
		signatureFunction.FixPointers(sizeof UDelegateProperty);
	}

	return UEFunction(signatureFunction);
}
UEProperty::Info UEMulticastDelegateProperty::GetInfo() const
{
	return Info::Create(PropertyType::PredefinedStruct, sizeof(FScriptMulticastDelegate), true, "struct FScriptMulticastDelegate");
}
UEClass UEMulticastDelegateProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".MulticastDelegateProperty");
	return c;
}

//---------------------------------------------------------------------------
//UEEnumProperty
//---------------------------------------------------------------------------
UENumericProperty UEEnumProperty::GetUnderlyingProperty() const
{
	if (objEnumProperty.Empty())
		objEnumProperty = Object.Cast<UEnumProperty>();

	if (underlyingProp.Empty())
	{
		if (INVALID_POINTER_VALUE(objEnumProperty.UnderlyingProp))
			return UENumericProperty();

		underlyingProp.ObjAddress = objEnumProperty.UnderlyingProp;
		Utils::MemoryObj->Read<UEnumProperty>(underlyingProp.ObjAddress, underlyingProp, sizeof(uintptr_t)); // Skip ObjAddress in SdkUObject
		underlyingProp.FixPointers(sizeof UEnumProperty);
	}

	return UENumericProperty(underlyingProp);
}
UEEnum UEEnumProperty::GetEnum() const
{
	if (objEnumProperty.Empty())
		objEnumProperty = Object.Cast<UEnumProperty>();

	if (Enum.Empty())
	{
		if (INVALID_POINTER_VALUE(objEnumProperty.Enum))
			return UEEnum();

		Enum.ObjAddress = objEnumProperty.Enum;
		Utils::MemoryObj->Read<UEnumProperty>(Enum.ObjAddress, Enum, sizeof(uintptr_t)); // Skip ObjAddress in SdkUObject
		Enum.FixPointers(sizeof UEnumProperty);
	}

	return UEEnum(Enum);
}
UEProperty::Info UEEnumProperty::GetInfo() const
{
	return Info::Create(PropertyType::Primitive, sizeof(uint8_t), false, MakeUniqueCppName(GetEnum()));
}
UEClass UEEnumProperty::StaticClass()
{
	static auto c = ObjectsStore().FindClass("Class " + Utils::Settings.SdkGen.CorePackageName + ".EnumProperty");
	return c;
}

```

`UnrealFinderTool/SdkGenerator.cpp`:

```cpp
#include "pch.h"
#include "cpplinq.hpp"
#include "NameValidator.h"
#include "PrintHelper.h"
#include "Logger.h"
#include "ObjectsStore.h"
#include "NamesStore.h"
#include "SdkGenerator.h"

#include <cinttypes>
#include <fstream>
#include <chrono>
#include <bitset>
#include <unordered_set>
#include <tlhelp32.h>
#include "ParallelWorker.h"

extern IGenerator* generator;

// ToDo: Instated of crash just popup a msg that's tell the user to use another GObjects address

SdkGenerator::SdkGenerator(const uintptr_t gObjAddress, const uintptr_t gNamesAddress) :
	gObjAddress(gObjAddress),
	gNamesAddress(gNamesAddress)
{
}

SdkInfo SdkGenerator::Start(size_t* pObjCount, size_t* pNamesCount, size_t* pPackagesCount, size_t* pPackagesDone,
								   const std::string& gameName, const std::string& gameVersion, const SdkType sdkType,
								   std::string& state, std::vector<std::string>& packagesDone)
{
	// Check Address
	if (!Utils::IsValidGNamesAddress(gNamesAddress))
		return { GeneratorState::BadGName };
	if (!Utils::IsValidGObjectsAddress(gObjAddress))
		return { GeneratorState::BadGObject };

	// Dump GNames
	if (!NamesStore::Initialize(gNamesAddress))
		return { GeneratorState::BadGName };
	*pNamesCount = NamesStore().GetNamesNum();

	// Dump GObjects
	if (!ObjectsStore::Initialize(gObjAddress))
		return { GeneratorState::BadGObject };
	*pObjCount = ObjectsStore().GetObjectsNum();

	// Init Generator Settings
	if (!generator->Initialize())
	{
		MessageBoxA(nullptr, "Initialize failed", "Error", 0);
		return { GeneratorState::Bad };
	}
	generator->SetGameName(gameName);
	generator->SetGameVersion(gameVersion);
	generator->SetSdkType(sdkType);
	generator->SetIsGObjectsChunks(ObjectsStore::GInfo.IsChunksAddress);

	// Get Current Dir
	fs::path outputDirectory = fs::path(Utils::GetWorkingDirectory());

	outputDirectory /= "Results";
	fs::create_directories(outputDirectory);
	
	std::ofstream log(outputDirectory / "Generator.log");
	Logger::SetStream(&log);

	fs::create_directories(outputDirectory);
	state = "Dumping (GNames/GObjects).";

	// Dump To Files
	if (generator->ShouldDumpArrays())
	{
		Dump(outputDirectory, state);
		state = "Dump (GNames/GObjects) Done.";
		Sleep(2 * 1000);
	}

	// Dump Packages
	const auto begin = std::chrono::system_clock::now();
	ProcessPackages(outputDirectory, pPackagesCount, pPackagesDone, state, packagesDone);

	// Get Time
	std::time_t took_seconds = std::time_t(std::chrono::duration_cast<std::chrono::seconds>(std::chrono::system_clock::now() - begin).count());
	std::tm took_time;
	gmtime_s(&took_time, &took_seconds);

	Logger::Log("Finished, took %d seconds.", took_seconds);
	Logger::SetStream(nullptr);

	return { GeneratorState::Good, took_time };
}

/// <summary>
/// Dumps the objects and names to files.
/// </summary>
/// <param name="path">The path where to create the dumps.</param>
/// <param name="state"></param>
void SdkGenerator::Dump(const fs::path& path, std::string& state)
{
	if (Utils::Settings.SdkGen.DumpNames)
	{
		state = "Dumping Names.";

		std::ofstream o(path / "NamesDump.txt");
		tfm::format(o, "Address: 0x%" PRIXPTR "\n\n", NamesStore::GetAddress());

		size_t vecSize = NamesStore().GetNamesNum();
		for (size_t i = 0; i < vecSize; ++i)
		{
			std::string str = NamesStore().GetByIndex(i);
			if (!str.empty())
				tfm::format(o, "[%06i] %s\n", int(i), NamesStore().GetByIndex(i).c_str());
			state = "Names [ " + std::to_string(i) + " / " + std::to_string(vecSize) + " ].";
		}
	}

	if (Utils::Settings.SdkGen.DumpObjects)
	{
		state = "Dumping Objects.";

		std::ofstream o(path / "ObjectsDump.txt");
		tfm::format(o, "Address: 0x%" PRIXPTR "\n\n", ObjectsStore::GInfo.GObjAddress);

		size_t vecSize = ObjectsStore().GetObjectsNum();
		for (size_t i = 0; i < vecSize; ++i)
		{
			if (ObjectsStore().GetByIndex(i)->IsValid())
			{
				const UEObject* obj = ObjectsStore().GetByIndex(i);
				tfm::format(o, "[%06i] %-100s 0x%" PRIXPTR "\n", obj->GetIndex(), obj->GetFullName(), obj->GetAddress());
			}
			state = "Objects [ " + std::to_string(i) + " / " + std::to_string(vecSize) + " ].";
		}
	}
}

/// <summary>
/// Process the packages.
/// </summary>
/// <param name="path">The path where to create the package files.</param>
/// <param name="pPackagesCount"></param>
/// <param name="pPackagesDone"></param>
/// <param name="state"></param>
/// <param name="packagesDone"></param>
void SdkGenerator::ProcessPackages(const fs::path& path, size_t* pPackagesCount, size_t* pPackagesDone, std::string& state, std::vector<std::string>& packagesDone)
{
	int threadCount = Utils::Settings.SdkGen.Threads;
	const auto sdkPath = path / "SDK";
	fs::create_directories(sdkPath);
	
	std::vector<std::unique_ptr<Package>> packages;
	std::unordered_map<uintptr_t, bool> processedObjects;

	state = "Start Collecting Packages.";
	std::vector<UEObject*> packageObjects;

	// Collecting Packages
	{
		size_t index = 0;
		ParallelSingleShot worker(threadCount, [&](ParallelOptions& options)
		{
			size_t vecSize = ObjectsStore::GObjObjects.size();
			while (vecSize > index)
			{
				UEObject* curObj;
				// Get current object
				{
					std::lock_guard lock(options.Locker);
					curObj = ObjectsStore::GObjObjects[index].second.get();
					++index;
				}

				if (!curObj)
					continue;

				UEObject* package = curObj->GetPackageObject();
				if (package->IsValid())
				{
					std::lock_guard lock(options.Locker);
					packageObjects.push_back(package);
					state = "Progress [ " + std::to_string(index) + " / " + std::to_string(vecSize) + " ].";
				}
			}
		});
		worker.Start();
		worker.WaitAll();

		// Make vector distinct
		std::sort(packageObjects.begin(), packageObjects.end());
		packageObjects.erase(std::unique(packageObjects.begin(), packageObjects.end()), packageObjects.end());
	}

	state = "Getting Packages Done.";
	*pPackagesCount = packageObjects.size();

	/*
	 * First we must complete Core Package.
	 * it's contains all important stuff, (like we need it in 'StaticClass' function)
	 * so before go parallel we must get 'CoreUObject'
	 * it's the first package always (packageObjects[0])
	*/
	{
		state = "Dumping '" + Utils::Settings.SdkGen.CorePackageName + "'.";

		// Get CoreUObject, Some times CoreUObject not the first Package
		UEObject* coreUObject;
		int coreUObjectIndex = 0;
		for (auto i = 0; i < packageObjects.size(); i++)
		{
			auto pack = packageObjects[i];

			if(pack->GetName() == Utils::Settings.SdkGen.CorePackageName)
			{
				coreUObject = pack;
				coreUObjectIndex = i;
				break;
			}
		}

		auto package = std::make_unique<Package>(coreUObject);
		std::mutex tmp_lock;
		package->Process(processedObjects, tmp_lock);
		if (package->Save(sdkPath))
		{
			packagesDone.emplace_back(std::string("(") + std::to_string(1) + ") " + package->GetName() + " [ "
				"C: " + std::to_string(package->Classes.size()) + ", " +
				"S: " + std::to_string(package->ScriptStructs.size()) + ", " +
				"E: " + std::to_string(package->Enums.size()) + " ]"
			);

			Package::PackageMap[*coreUObject] = package.get();
			packages.emplace_back(std::move(package));
		}

		// Set Sleep Every
		Utils::Settings.Parallel.SleepEvery = 30;

		// Remove CoreUObject Package to not dump it twice
		packageObjects.erase(packageObjects.begin() + coreUObjectIndex);
	}

	++*pPackagesDone;
	state = "Dumping with " + std::to_string(threadCount) + " Threads.";

	// Start From 1 because core package is already done
	ParallelQueue<std::vector<UEObject*>, UEObject*>packageProcess(packageObjects, 0, threadCount, [&](UEObject* obj, ParallelOptions& options)
	{
		auto package = std::make_unique<Package>(obj);
		package->Process(processedObjects, Utils::MainMutex);
		
		std::lock_guard lock(Utils::MainMutex);
		++*pPackagesDone;

		packagesDone.emplace_back(std::string("(") + std::to_string(*pPackagesDone) + ") " + package->GetName() + " [ "
			"C: " + std::to_string(package->Classes.size()) + ", " +
			"S: " + std::to_string(package->ScriptStructs.size()) + ", " +
			"E: " + std::to_string(package->Enums.size()) + " ]"
		);

		if (package->Save(sdkPath))
		{
			Package::PackageMap[*obj] = package.get();
			packages.emplace_back(std::move(package));
		}
	});
	packageProcess.Start();
	packageProcess.WaitAll();

	if (!packages.empty())
	{
		// std::sort doesn't work, so use a simple bubble sort
		//std::sort(std::begin(packages), std::end(packages), PackageDependencyComparer());
		const PackageDependencyComparer comparer;
		for (auto i = 0u; i < packages.size() - 1; ++i)
		{
			for (auto j = 0u; j < packages.size() - i - 1; ++j)
			{
				if (!comparer(packages[j], packages[j + 1]))
				{
					std::swap(packages[j], packages[j + 1]);
				}
			}
		}
	}

	SaveSdkHeader(path, processedObjects, packages);
}

/// <summary>
/// Generates the sdk header.
/// </summary>
/// <param name="path">The path where to create the sdk header.</param>
/// <param name="processedObjects">The list of processed objects.</param>
/// <param name="packages">The package order info.</param>
void SdkGenerator::SaveSdkHeader(const fs::path& path, const std::unordered_map<uintptr_t, bool>& processedObjects, const std::vector<std::unique_ptr<Package>>& packages)
{
	std::ofstream os(path / "SDK.h");
	os << "// ------------------------------------------------\n";
	os << "// Sdk Generated By ( Unreal Finder Tool By CorrM )\n";
	os << "// ------------------------------------------------\n";

	os << "#pragma once\n\n"
		<< tfm::format("// Name: %s, Version: %s\n\n", generator->GetGameName(), generator->GetGameVersion());

	//Includes
	os << "#include <set>\n";
	os << "#include <string>\n";
	for (auto&& i : generator->GetIncludes())
	{
		os << "#include " << i << "\n";
	}

	//include the basics
	{
		{
			std::ofstream os2(path / "SDK" / tfm::format("Basic.h"));
			PrintFileHeader(os2, { "warning(disable: 4267)" }, { "<vector>", "<locale>", "<set>" }, true);
			os2 << generator->GetBasicDeclarations() << "\n";
			PrintFileFooter(os2);

			// Add basics to SDK.h
			os << "\n#include \"SDK/" << tfm::format("Basic.h") << "\"\n";
		}
		{
			std::ofstream os2(path / "SDK" / tfm::format("Basic.cpp"));

			PrintFileHeader(os2, { "\"../SDK.h\"", "<Windows.h>" }, false);

			os2 << generator->GetBasicDefinitions() << "\n";

			PrintFileFooter(os2);
		}
	}

	using namespace cpplinq;

	//check for missing structs
	const auto missing = from(processedObjects) >> where([](std::pair<uintptr_t, bool>&& kv) { return !kv.second; });
	if (missing >> any())
	{
		std::ofstream os2(path / "SDK" / tfm::format("MISSING.h"));

		PrintFileHeader(os2, true);

		for (UEStruct&& s : missing >> select([](std::pair<uintptr_t, bool>&& kv) { return ObjectsStore::GetByAddress(kv.first)->Cast<UEStruct>(); }) >> experimental::container())
		{
			os2 << "// " << s.GetFullName() << "\n// ";
			os2 << tfm::format("0x%04X\n", s.GetPropertySize());

			os2 << "struct " << MakeValidName(s.GetNameCpp()) << "\n{\n";
			os2 << "\tunsigned char UnknownData[0x" << tfm::format("%X", s.GetPropertySize()) << "];\n};\n\n";
		}

		PrintFileFooter(os2);

		os << "\n#include \"SDK/" << tfm::format("MISSING.h") << "\"\n";
	}

	os << "\n";

	for (auto&& package : packages)
	{
		os << R"(#include "SDK/)" << GenerateFileName(FileContentType::Structs, *package) << "\"\n";
		os << R"(#include "SDK/)" << GenerateFileName(FileContentType::Classes, *package) << "\"\n";
		if (generator->ShouldGenerateFunctionParametersFile())
		{
			os << R"(#include "SDK/)" << GenerateFileName(FileContentType::FunctionParameters, *package) << "\"\n";
		}
	}
}

```

`UnrealFinderTool/SdkGenerator.h`:

```h
#pragma once
#include "Package.h"

enum class GeneratorState
{
	Bad,
	Good,
	BadGObject,
	BadGName
};

struct SdkInfo
{
	GeneratorState State;
	std::tm TookTime;
};

class SdkGenerator
{
	uintptr_t gObjAddress, gNamesAddress;
public:
	SdkGenerator(uintptr_t gObjAddress, uintptr_t gNamesAddress);
	SdkInfo Start(size_t* pObjCount, size_t* pNamesCount, size_t* pPackagesCount, size_t* pPackagesDone,
					const std::string& gameName, const std::string& gameVersion, SdkType sdkType,
					std::string& state, std::vector<std::string>& packagesDone);
private:
	void Dump(const fs::path& path, std::string& state);
	void ProcessPackages(const fs::path& path, size_t* pPackagesCount, size_t* pPackagesDone, std::string& state, std::vector<std::string>& packagesDone);
	void SaveSdkHeader(const fs::path& path, const std::unordered_map<uintptr_t, bool>& processedObjects, const std::vector<std::unique_ptr<Package>>& packages);
};
```

`UnrealFinderTool/Tools.cpp`:

```cpp
#include "pch.h"
#include <Windows.h>
#include "Tools.h"

std::wstring str2wstr(std::string  in) { std::wstring out; out.assign(in.begin(), in.end()); return out; }
std::string  wstr2str(std::wstring in) { std::string  out; out.assign(in.begin(), in.end()); return out; }

bool CustomSetPrivilegeW(const LPCWSTR lpszPrivilege, const BOOL bEnablePrivilege) {
	TOKEN_PRIVILEGES priv = { 0,0,0,0 };
	HANDLE hToken = nullptr;
	LUID luid = { 0,0 };
	if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hToken)) {
		if (hToken)
			CloseHandle(hToken);
		return false;
	}
	if (!LookupPrivilegeValueW(nullptr, lpszPrivilege, &luid)) {
		if (hToken)
			CloseHandle(hToken);
		return false;
	}
	priv.PrivilegeCount = 1;
	priv.Privileges[0].Luid = luid;
	priv.Privileges[0].Attributes = bEnablePrivilege ? SE_PRIVILEGE_ENABLED : SE_PRIVILEGE_REMOVED;
	if (!AdjustTokenPrivileges(hToken, false, &priv, 0, nullptr, nullptr)) {
		if (hToken)
			CloseHandle(hToken);
		return false;
	}
	if (hToken)
		CloseHandle(hToken);
	return true;
}

bool CustomSetPrivilegeA(const LPCSTR lpszPrivilege, const BOOL bEnablePrivilege) {
	TOKEN_PRIVILEGES priv = { 0,0,0,0 };
	HANDLE hToken = nullptr;
	LUID luid = { 0,0 };
	if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hToken)) {
		if (hToken)
			CloseHandle(hToken);
		return false;
	}
	if (!LookupPrivilegeValueA(nullptr, lpszPrivilege, &luid)) {
		if (hToken)
			CloseHandle(hToken);
		return false;
	}
	priv.PrivilegeCount = 1;
	priv.Privileges[0].Luid = luid;
	priv.Privileges[0].Attributes = bEnablePrivilege ? SE_PRIVILEGE_ENABLED : SE_PRIVILEGE_REMOVED;
	if (!AdjustTokenPrivileges(hToken, false, &priv, 0, nullptr, nullptr)) {
		if (hToken)
			CloseHandle(hToken);
		return false;
	}
	if (hToken)
		CloseHandle(hToken);
	return true;
}

bool WriteDataToFile(const UCHAR pBuffer[], const size_t dwSize, const std::string& strFileName, const DWORD dwCreationDisposition)
{
	const auto hFile = CreateFileA(strFileName.c_str(), GENERIC_READ | GENERIC_WRITE, 0, nullptr, dwCreationDisposition, FILE_ATTRIBUTE_NORMAL, nullptr);
	if (hFile == INVALID_HANDLE_VALUE) return false;
	DWORD dwNumberOfBytesWritten = NULL;
	const auto bWriteFile = WriteFile(hFile, pBuffer, dwSize, &dwNumberOfBytesWritten, nullptr);
	CloseHandle(hFile);
	return !(!bWriteFile || dwNumberOfBytesWritten != dwSize);
}
```

`UnrealFinderTool/Tools.h`:

```h
#pragma once
#include <Windows.h>
#include <string>

#ifdef UNICODE
#define CustomSetPrivilege  CustomSetPrivilegeW
#else
#define CustomSetPrivilege  CustomSetPrivilegeA
#endif

std::wstring str2wstr(std::string  in);
std::string  wstr2str(std::wstring in);

bool CustomSetPrivilegeW(LPCWSTR lpszPrivilege, BOOL bEnablePrivilege);

bool CustomSetPrivilegeA(LPCSTR lpszPrivilege, BOOL bEnablePrivilege);

bool WriteDataToFile(const UCHAR pBuffer[], size_t dwSize, const std::string& strFileName, DWORD dwCreationDisposition = CREATE_NEW);
```

`UnrealFinderTool/UiWindow.cpp`:

```cpp
#include "pch.h"
#include "UiWindow.h"
#include "ImGUI/imgui_internal.h"
#include "ImGUI/imgui_impl_win32.h"
#include "ImGUI/imgui_impl_dx11.h"
#include "IconsFontAwesome.h"

#include <tchar.h>
#include "resource.h"
#include <functional>
#include <utility>

ID3D11Device* UiWindow::gPd3dDevice = nullptr;
ID3D11DeviceContext* UiWindow::gPd3dDeviceContext = nullptr;
IDXGISwapChain* UiWindow::gPSwapChain = nullptr;
ID3D11RenderTargetView* UiWindow::gMainRenderTargetView = nullptr;

// Win32 message handler
extern LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

LRESULT WINAPI UiWindow::WndProc(const HWND hWnd, const UINT msg, const WPARAM wParam, const LPARAM lParam)
{
	if (ImGui_ImplWin32_WndProcHandler(hWnd, msg, wParam, lParam))
		return true;

	// Get UiWindow Pointer
	RECT rect;
	auto pUiWindow = reinterpret_cast<UiWindow*>(GetWindowLongPtr(hWnd, GWLP_USERDATA));
	if (pUiWindow == nullptr)
		return DefWindowProc(hWnd, msg, wParam, lParam);

	switch (msg)
	{
	case WM_SIZE:
		if (wParam == SIZE_MINIMIZED)
			pUiWindow->render = false;
		if (gPd3dDevice != nullptr && wParam != SIZE_MINIMIZED)
		{
			pUiWindow->render = true;
			pUiWindow->CleanupRenderTarget();
			gPSwapChain->ResizeBuffers(0, static_cast<UINT>(LOWORD(lParam)), static_cast<UINT>(HIWORD(lParam)), DXGI_FORMAT_UNKNOWN, 0);
			pUiWindow->CreateRenderTarget();
		}
		if (GetWindowRect(pUiWindow->hWindow, &rect))
		{
			pUiWindow->settings.Width = rect.right - rect.left;
			pUiWindow->settings.Height = rect.bottom - rect.top;
		}
		return 0;

	case WM_SYSCOMMAND:
		if ((wParam & 0xfff0) == SC_KEYMENU) // Disable ALT application menu
			return 0;
		break;

	case WM_DESTROY:
		PostQuitMessage(0);
		return 0;

	case WM_CLOSE:
		if (Utils::WorkingNow.AnyRunningTool())
		{
			MessageBox(nullptr, "Wait for current task finish first.", "", MB_OK | MB_ICONWARNING);
			return 0;
		}
	}
	return DefWindowProc(hWnd, msg, wParam, lParam);
}

UiWindow::UiWindow(const char* title, const char* className, const int width, const int height) :
	hWindow(nullptr),
	wc(), closed(false), render(true),
	loopThreadHandle(nullptr),
	uiStyle(nullptr)
{
	settings.Title = title;
	settings.ClassName = className;
	settings.Width = width;
	settings.Height = height;
}

UiWindow::~UiWindow()
{
	WaitForSingleObject(loopThreadHandle, 0);
}

void UiWindow::Show(UiFunc uiForm)
{
	// Start thread, create window and show it
	if (hWindow == nullptr)
	{
		uiFunc = std::move(uiForm);
		loopThread = std::thread(&UiWindow::WinLoop, this);
		auto ht = static_cast<HANDLE>(loopThread.native_handle());
		SetThreadPriority(ht, THREAD_PRIORITY_ABOVE_NORMAL);
		loopThreadHandle = ht;
		loopThread.detach();
	}
}

bool UiWindow::Closed()
{
	return closed;
}

void UiWindow::CenterPos()
{
	RECT rectScreen;
	HWND hwndScreen = GetDesktopWindow();
	GetWindowRect(hwndScreen, &rectScreen);

	int wPosX = ((rectScreen.right - rectScreen.left) / 2 - settings.Width / 2);
	int wPosY = ((rectScreen.bottom - rectScreen.top) / 2 - settings.Height / 2);
	SetWindowPos(hWindow, nullptr, wPosX, wPosY, settings.Width, settings.Height, SWP_SHOWWINDOW | SWP_NOSIZE);
}

void UiWindow::SetSize(const int newWidth, const int newHeight)
{
	settings.Width = newWidth;
	settings.Height = newHeight;
	SetWindowPos(hWindow, nullptr, 0, 0, settings.Width, settings.Height, SWP_SHOWWINDOW | SWP_NOMOVE | SWP_NOREDRAW);
}

ImVec2 UiWindow::GetSize()
{
	return { static_cast<float>(settings.Width), static_cast<float>(settings.Height) };
}

bool UiWindow::CreateUiWindow(std::string& title, std::string& className, const int width, const int height)
{
	// Create application window
	wc = { sizeof(WNDCLASSEX), CS_CLASSDC, &UiWindow::WndProc, 0L, 0L, GetModuleHandle(nullptr), nullptr, nullptr, nullptr, nullptr, className.c_str(), nullptr };
	RegisterClassEx(&wc);
	hWindow = CreateWindow(wc.lpszClassName, title.c_str(), WS_OVERLAPPED | WS_SYSMENU  | WS_MINIMIZEBOX , 100, 100, width, height, NULL, NULL, wc.hInstance, NULL);
	if (!hWindow) {
		UnregisterClass(wc.lpszClassName, wc.hInstance);
		MessageBox(HWND_DESKTOP, "Unable to create main window!", "CorrM Finder", MB_ICONERROR | MB_OK);
		return false;
	}

	HINSTANCE hInstance = wc.hInstance;
	HICON hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICON1));
	_ASSERTE(hIcon != nullptr);
	SendMessage(hWindow, WM_SETICON, ICON_BIG, reinterpret_cast<LPARAM>(hIcon));

	// Initialize Direct3D
	if (!CreateDeviceD3D(hWindow))
	{
		CleanupDeviceD3D();
		UnregisterClass(wc.lpszClassName, wc.hInstance);
		return false;
	}

	// Trick to get the class inside static func
	SetWindowLongPtr(hWindow, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(this));

	// Show the window
	ShowWindow(hWindow, SW_SHOWDEFAULT);
	UpdateWindow(hWindow);

	CenterPos();
	return true;
}

bool UiWindow::CreateDeviceD3D(const HWND hWnd)
{
	// Setup swap chain
	DXGI_SWAP_CHAIN_DESC sd;
	ZeroMemory(&sd, sizeof(sd));
	sd.BufferCount = 2;
	sd.BufferDesc.Width = 0;
	sd.BufferDesc.Height = 0;
	sd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
	sd.BufferDesc.RefreshRate.Numerator = 60;
	sd.BufferDesc.RefreshRate.Denominator = 1;
	sd.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;
	sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
	sd.OutputWindow = hWnd;
	sd.SampleDesc.Count = 1;
	sd.SampleDesc.Quality = 0;
	sd.Windowed = TRUE;
	sd.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;

	UINT createDeviceFlags = 0;
	//createDeviceFlags |= D3D11_CREATE_DEVICE_DEBUG;
	D3D_FEATURE_LEVEL featureLevel;
	const D3D_FEATURE_LEVEL featureLevelArray[2] = { D3D_FEATURE_LEVEL_11_0, D3D_FEATURE_LEVEL_10_0, };
	if (D3D11CreateDeviceAndSwapChain(nullptr, D3D_DRIVER_TYPE_HARDWARE, nullptr, createDeviceFlags, featureLevelArray, 2, D3D11_SDK_VERSION, &sd, &gPSwapChain, &gPd3dDevice, &featureLevel, &gPd3dDeviceContext) != S_OK)
		return false;

	CreateRenderTarget();
	return true;
}

void UiWindow::CreateRenderTarget()
{
	ID3D11Texture2D* pBackBuffer;
	gPSwapChain->GetBuffer(0, IID_PPV_ARGS(&pBackBuffer));
	gPd3dDevice->CreateRenderTargetView(pBackBuffer, nullptr, &gMainRenderTargetView);
	pBackBuffer->Release();
}

void UiWindow::SetupImGui()
{
	IMGUI_CHECKVERSION();
	ImGui::CreateContext();
	ImGuiIO& io = ui::GetIO();
	uiStyle = &ui::GetStyle();
	SetStyle();

	// Setup Platform/Renderer bindings
	ImGui_ImplWin32_Init(hWindow);
	ImGui_ImplDX11_Init(gPd3dDevice, gPd3dDeviceContext);

	// merge in icons from Font Awesome
	io.Fonts->AddFontDefault();
	static const ImWchar icons_ranges[] = { ICON_MIN_FA, ICON_MAX_FA, 0 };
	ImFontConfig icons_config;
	icons_config.MergeMode = true; icons_config.PixelSnapH = true;
	auto fontAwesome = io.Fonts->AddFontFromFileTTF(FONT_ICON_FILE_NAME_FAS, 11.0f, &icons_config, icons_ranges);

	if (fontAwesome == nullptr)
	{
		std::string msg = "Unable to load " + std::string(FONT_ICON_FILE_NAME_FAS) + ".";
		ShowWindow(hWindow, SW_HIDE);
		MessageBox(HWND_DESKTOP, msg.c_str(), "Error!", MB_OK | MB_ICONERROR);
		PostQuitMessage(-1);
	}
	settings.ClearColor = ImVec4(0.45f, 0.55f, 0.60f, 1.00f);
}

void UiWindow::CleanupDeviceD3D()
{
	CleanupRenderTarget();
	if (gPSwapChain) { gPSwapChain->Release(); gPSwapChain = nullptr; }
	if (gPd3dDeviceContext) { gPd3dDeviceContext->Release(); gPd3dDeviceContext = nullptr; }
	if (gPd3dDevice) { gPd3dDevice->Release(); gPd3dDevice = nullptr; }
}

void UiWindow::CleanupRenderTarget()
{
	if (gMainRenderTargetView) { gMainRenderTargetView->Release(); gMainRenderTargetView = nullptr; }
}

void UiWindow::WinLoop()
{
	CreateUiWindow(settings.Title, settings.ClassName, settings.Width, settings.Height);
	SetupImGui();

	// Main loop
	MSG msg;
	ZeroMemory(&msg, sizeof(msg));
	while (msg.message != WM_QUIT)
	{
		if (PeekMessage(&msg, nullptr, 0U, 0U, PM_REMOVE))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
			continue;
		}

		if (render)
			RenderFrame();
	}

	ImGui_ImplDX11_Shutdown();
	ImGui_ImplWin32_Shutdown();
	ImGui::DestroyContext();

	CleanupDeviceD3D();
	DestroyWindow(hWindow);
	UnregisterClass(wc.lpszClassName, wc.hInstance);
	closed = true;
}

void UiWindow::RenderFrame()
{
	// Start the Dear ImGui frame
	ImGui_ImplDX11_NewFrame();
	ImGui_ImplWin32_NewFrame();
	ImGui::NewFrame();

	ImGui::SetNextWindowPos({ 0, 0 });
	ImGui::SetNextWindowSize({ static_cast<float>(settings.Width - 15), static_cast<float>(settings.Height - 38) });
	ImGui::SetNextWindowContentSize({ static_cast<float>(settings.Width - 15), static_cast<float>(settings.Height - 38) });
	ImGui::Begin("Main", &settings.IsOpen, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse);
	uiFunc(this);
	ImGui::End();

	// Rendering
	ImGui::Render();
	gPd3dDeviceContext->OMSetRenderTargets(1, &gMainRenderTargetView, nullptr);
	gPd3dDeviceContext->ClearRenderTargetView(gMainRenderTargetView, reinterpret_cast<float*>(&settings.ClearColor));
	ImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData());

	gPSwapChain->Present(1, 0); // Present with vsync
	//g_pSwapChain->Present(0, 0); // Present without vsync
}

void UiWindow::SetStyle()
{
	ImGuiStyle* style = &ImGui::GetStyle();

	style->WindowPadding = ImVec2(7, 7);
	style->WindowRounding = 0.0f;
	style->FramePadding = ImVec2(5, 5);
	style->FrameRounding = 4.0f;
	style->ItemSpacing = ImVec2(12, 8);
	style->ItemInnerSpacing = ImVec2(8, 6);
	style->IndentSpacing = 25.0f;
	style->ScrollbarSize = 15.0f;
	style->ScrollbarRounding = 9.0f;
	style->GrabMinSize = 5.0f;
	style->GrabRounding = 3.0f;
	style->WindowBorderSize = 0.0f;

	style->Colors[ImGuiCol_Text] = ImVec4(0.80f, 0.80f, 0.83f, 1.00f);
	style->Colors[ImGuiCol_TextDisabled] = ImVec4(0.24f, 0.23f, 0.29f, 1.00f);
	style->Colors[ImGuiCol_WindowBg] = ImVec4(0.06f, 0.05f, 0.07f, 1.00f);
	style->Colors[ImGuiCol_ChildWindowBg] = ImVec4(0.07f, 0.07f, 0.09f, 1.00f);
	style->Colors[ImGuiCol_PopupBg] = ImVec4(0.07f, 0.07f, 0.09f, 1.00f);
	style->Colors[ImGuiCol_Border] = ImVec4(0.80f, 0.80f, 0.83f, 0.88f);
	style->Colors[ImGuiCol_BorderShadow] = ImVec4(0.92f, 0.91f, 0.88f, 0.00f);
	style->Colors[ImGuiCol_FrameBg] = ImVec4(0.10f, 0.09f, 0.12f, 1.00f);
	style->Colors[ImGuiCol_FrameBgHovered] = ImVec4(0.24f, 0.23f, 0.29f, 1.00f);
	style->Colors[ImGuiCol_FrameBgActive] = ImVec4(0.56f, 0.56f, 0.58f, 1.00f);
	style->Colors[ImGuiCol_TitleBg] = ImVec4(0.10f, 0.09f, 0.12f, 1.00f);
	style->Colors[ImGuiCol_TitleBgCollapsed] = ImVec4(1.00f, 0.98f, 0.95f, 0.75f);
	style->Colors[ImGuiCol_TitleBgActive] = ImVec4(0.07f, 0.07f, 0.09f, 1.00f);
	style->Colors[ImGuiCol_MenuBarBg] = ImVec4(0.10f, 0.09f, 0.12f, 1.00f);
	style->Colors[ImGuiCol_ScrollbarBg] = ImVec4(0.10f, 0.09f, 0.12f, 1.00f);
	style->Colors[ImGuiCol_ScrollbarGrab] = ImVec4(0.80f, 0.80f, 0.83f, 0.31f);
	style->Colors[ImGuiCol_ScrollbarGrabHovered] = ImVec4(0.56f, 0.56f, 0.58f, 1.00f);
	style->Colors[ImGuiCol_ScrollbarGrabActive] = ImVec4(0.06f, 0.05f, 0.07f, 1.00f);
	style->Colors[ImGuiCol_PopupBg] = ImVec4(0.19f, 0.18f, 0.21f, 1.00f);
	style->Colors[ImGuiCol_CheckMark] = ImVec4(0.80f, 0.80f, 0.83f, 0.31f);
	style->Colors[ImGuiCol_SliderGrab] = ImVec4(0.80f, 0.80f, 0.83f, 0.31f);
	style->Colors[ImGuiCol_SliderGrabActive] = ImVec4(0.06f, 0.05f, 0.07f, 1.00f);
	style->Colors[ImGuiCol_Button] = ImVec4(0.10f, 0.09f, 0.12f, 1.00f);
	style->Colors[ImGuiCol_ButtonHovered] = ImVec4(0.24f, 0.23f, 0.29f, 1.00f);
	style->Colors[ImGuiCol_ButtonActive] = ImVec4(0.56f, 0.56f, 0.58f, 1.00f);

	style->Colors[ImGuiCol_Header] = ImVec4(0.10f, 0.14f, 0.12f, 1.00f);
	style->Colors[ImGuiCol_HeaderHovered] = ImVec4(0.44f, 0.50f, 0.57f, 1.00f);
	style->Colors[ImGuiCol_HeaderActive] = ImVec4(0.06f, 0.05f, 0.07f, 1.00f);

	style->Colors[ImGuiCol_Column] = ImVec4(0.56f, 0.56f, 0.58f, 1.00f);
	style->Colors[ImGuiCol_ColumnHovered] = ImVec4(0.24f, 0.23f, 0.29f, 1.00f);
	style->Colors[ImGuiCol_ColumnActive] = ImVec4(0.56f, 0.56f, 0.58f, 1.00f);
	style->Colors[ImGuiCol_ResizeGrip] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
	style->Colors[ImGuiCol_ResizeGripHovered] = ImVec4(0.56f, 0.56f, 0.58f, 1.00f);
	style->Colors[ImGuiCol_ResizeGripActive] = ImVec4(0.06f, 0.05f, 0.07f, 1.00f);
	style->Colors[ImGuiCol_PlotLines] = ImVec4(0.40f, 0.39f, 0.38f, 0.63f);
	style->Colors[ImGuiCol_PlotLinesHovered] = ImVec4(0.25f, 1.00f, 0.00f, 1.00f);
	style->Colors[ImGuiCol_PlotHistogram] = ImVec4(0.40f, 0.39f, 0.38f, 0.63f);
	style->Colors[ImGuiCol_PlotHistogramHovered] = ImVec4(0.25f, 1.00f, 0.00f, 1.00f);
	style->Colors[ImGuiCol_TextSelectedBg] = ImVec4(0.25f, 1.00f, 0.00f, 0.43f);
	style->Colors[ImGuiCol_ModalWindowDarkening] = ImVec4(1.00f, 0.98f, 0.95f, 0.73f);
	style->Colors[ImGuiCol_Tab] = ImVec4(0.17f, 0.24f, 0.31f, 1.00f);
	style->Colors[ImGuiCol_TabActive] = ImVec4(0.90f, 0.29f, 0.23f, 1.00f);
	style->Colors[ImGuiCol_TabHovered] = ImVec4(0.16f, 0.50f, 0.72f, 1.00f);

	/*
	io.Fonts->AddFontFromFileTTF("C:\\Windows\\Fonts\\Ruda-Bold.ttf", 12);
	io.Fonts->AddFontFromFileTTF("C:\\Windows\\Fonts\\Ruda-Bold.ttf", 10);
	io.Fonts->AddFontFromFileTTF("C:\\Windows\\Fonts\\Ruda-Bold.ttf", 14);
	io.Fonts->AddFontFromFileTTF("C:\\Windows\\Fonts\\Ruda-Bold.ttf", 18);
	*/
}

ImGuiStyle& UiWindow::GetUiStyle()
{
	return *uiStyle;
}

HWND UiWindow::GetWindowHandle()
{
	return hWindow;
}

void UiWindow::FlashWindow()
{
	::FlashWindow(hWindow, TRUE);
}
```

`UnrealFinderTool/UiWindow.h`:

```h
#pragma once
#include <d3d11.h>
#include <thread>
#include <functional>

#include "ImGUI/imgui.h"
#include "ImGUI/imgui_internal.h"

#define DIRECTINPUT_VERSION 0x0800

class UiWindow;
namespace ui = ImGui;
using UiFunc = std::function<void(UiWindow*)>;

struct WindowSettings
{
	// Window
	std::string Title;
	std::string ClassName;
	int Width;
	int Height;

	// Ui
	ImVec4 ClearColor;
	bool IsOpen;
};

class UiWindow
{
	HWND hWindow;
	WNDCLASSEX wc;
	bool closed, render;
	UiFunc uiFunc;
	HANDLE loopThreadHandle;
	std::thread loopThread;
	WindowSettings settings;
	ImGuiStyle* uiStyle;

	static ID3D11Device* gPd3dDevice;
	static ID3D11DeviceContext* gPd3dDeviceContext;
	static IDXGISwapChain* gPSwapChain;
	static ID3D11RenderTargetView* gMainRenderTargetView;

	bool CreateUiWindow(std::string& title, std::string& className, int width, int height);
	bool CreateDeviceD3D(HWND hWnd);
	void CreateRenderTarget();
	void SetupImGui();
	void CleanupDeviceD3D();
	void CleanupRenderTarget();
	void WinLoop();
	void RenderFrame();
	void SetStyle();


	static LRESULT WINAPI WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
public:
	UiWindow(const char* title, const char* className, int width, int height);
	~UiWindow();
	void Show(UiFunc uiForm);
	bool Closed();
	void CenterPos();
	void SetSize(int newWidth, int newHeight);
	ImVec2 GetSize();
	ImGuiStyle& GetUiStyle();

	HWND GetWindowHandle();
	void FlashWindow();
};


```

`UnrealFinderTool/UnrealFinderTool.cpp`:

```cpp
#include "pch.h"
#include "GnamesFinder.h"
#include "GObjectsFinder.h"
#include "ClassFinder.h"
#include "InstanceLogger.h"
#include "SdkGenerator.h"

#include "UiWindow.h"
#include "ImControl.h"
#include "IconsFontAwesome.h"
#include "MemoryEditor.h"

#include "Memory.h"
#include "Debug.h"
#include "Scanner.h"

#include "Midi/MIDI.h"
#include "Midi/MIDI_Resource.h"

#include <sstream>
#include <shellapi.h>

MemoryEditor mem_edit;
bool memory_init = false;
bool override_engine = false;
bool donate_show = true;
float LeftWidth, RightWidth;

#ifdef MIDI_h
CMIDI* MidiPlayer = nullptr;
#endif

void BeforeWork()
{
	DisabledAll();
}

void AfterWork()
{
	EnabledAll();
}

std::string GetTookTime(const std::tm take_time)
{
	return std::to_string(take_time.tm_hour) + "h " + std::to_string(take_time.tm_min) + "m " + std::to_string(take_time.tm_sec) + "s";
}

void LoadOverrideEngine()
{
	if (override_engine)
		return;

	override_engine = true;
	game_ue_disabled = true;

	// Override UE4 Engine Structs
	Utils::OverrideLoadedEngineCore(unreal_versions[ue_selected_version]);
}

void CheckLastVer()
{
	std::string lastVer;

	auto requestTask = HttpWorker::Get(L"https://github.com/CorrM/Unreal-Finder-Tool/releases/latest")
	.then([&](http_response response)
	{
		std::wstring locationHeader = response.headers()[L"Location"];
		size_t pos;
		if ((pos = locationHeader.rfind(L'/')) != std::wstring::npos)
			lastVer.assign(locationHeader.begin() + pos + 1, locationHeader.end());
	});

	try
	{
		requestTask.wait();
		if (lastVer != TOOL_VERSION)
		{
			MessageBox(Utils::UiMainWindow->GetWindowHandle(),
				(
					"There is a new version of this tool.\n"s
					"Your Version : " TOOL_VERSION + ".\n"
					"New Version : " + lastVer + ".\n\n"
					"Recommended to use last version.\nTo download :\nMenuButton->Help->Last version."
					).c_str(),
				"New Version",
				MB_OK | MB_ICONINFORMATION);
		}
	}
	catch (const std::exception&)
	{
		// MessageBox(nullptr, ("Error exception: "s + e.what()).c_str(), "", MB_OK | MB_ICONERROR);
	}
}

#pragma region Memory
void SetupMemoryStuff(const HANDLE pHandle)
{
	// Setup Memory Stuff
	if (!memory_init)
	{
		memory_init = true;
		Utils::MemoryObj = new Memory(pHandle, use_kernal);
		if (!use_kernal) Utils::MemoryObj->GetDebugPrivileges();

		// Grab engine version information
		Utils::UnrealEngineVersion(game_ue_version);

		// Setup memory editor
		mem_edit.OptMidColsCount = Utils::PointerSize();
		mem_edit.PreviewDataType = Utils::MemoryObj->Is64Bit ? MemoryEditor::DataType_S64 : MemoryEditor::DataType_S32;
	}
}

bool IsReadyToGo()
{
	HANDLE pHandle;
	if (Memory::IsValidProcess(process_id, &pHandle))
	{
		SetupMemoryStuff(pHandle);

		for (size_t i = 0; i < unreal_versions.size(); i++)
		{
			std::string toLowerTitle = window_title;
			std::string toLowerJson = unreal_versions[i];

			std::transform(toLowerTitle.begin(), toLowerTitle.end(), toLowerTitle.begin(), ::tolower);
			std::transform(toLowerJson.begin(), toLowerJson.end(), toLowerJson.begin(), ::tolower);

			if (Utils::ContainsString(unreal_versions[i], game_ue_version) ||
				Utils::ContainsString(toLowerTitle, toLowerJson))
			{
				ue_selected_version = i;
				break;
			}
		}
		return true;
	}
	return false;
}
#pragma endregion

#pragma region Address Viewer
PBYTE PCurrentAddressData = nullptr;
int BufSize = 0x200;
uintptr_t CurrentViewerAddress = uintptr_t(0x0);

MemoryEditor::u8 AddressViewerReadFn(const MemoryEditor::u8* data, const size_t off)
{
	if (!PCurrentAddressData)
		return 0;

	return PCurrentAddressData[off];
}

void GoToAddress(const uintptr_t address)
{
	if (Utils::MemoryObj)
	{
		// Only alloc once
		if (!PCurrentAddressData)
			PCurrentAddressData = new BYTE[BufSize];

		Utils::MemoryObj->ReadBytes(address, PCurrentAddressData, BufSize);
		CurrentViewerAddress = address;
	}
}
#pragma endregion

#pragma region Work Functions
void StartGObjFinder(const bool easyMethod)
{
	g_obj_listbox_items.clear();
	BeforeWork();
	g_objects_find_disabled = true;
	g_objects_disabled = false;
	g_names_disabled = false;
	g_obj_listbox_items.emplace_back("Searching...");
	g_obj_listbox_item_current = 0;
	Utils::WorkingNow.GObjectsFinder = true;

	std::thread t([=]()
	{
		GObjectsFinder taf(easyMethod);
		std::vector<uintptr_t> ret = taf.Find();
		g_obj_listbox_items.clear();

		for (auto v : ret)
		{
			std::stringstream ss;
			ss << std::hex << v;

			std::string tmpUpper = ss.str();
			std::transform(tmpUpper.begin(), tmpUpper.end(), tmpUpper.begin(), ::toupper);

			g_obj_listbox_items.push_back(tmpUpper);
		}

		if (ret.size() == 1)
			strcpy_s(g_objects_buf, sizeof g_objects_buf, g_obj_listbox_items[0].data());

		Utils::WorkingNow.GObjectsFinder = false;
		g_objects_find_disabled = false;
		AfterWork();
	});
	t.detach();
}

void StartGNamesFinder()
{
	g_names_listbox_items.clear();
	g_names_listbox_items.emplace_back("Searching...");

	BeforeWork();
	g_names_find_disabled = true;
	g_objects_disabled = false;
	g_names_disabled = false;
	Utils::WorkingNow.GNamesFinder = true;

	std::thread t([&]()
	{
		GNamesFinder gf;
		uintptr_t gname_address = gf.Find()[0]; // always return one address

		g_names_listbox_items.clear();

		if (gname_address != NULL)
		{
			// Convert to hex string
			std::stringstream ss; ss << std::hex << gname_address;

			// Make hex char is Upper
			std::string tmpUpper = ss.str();
			std::transform(tmpUpper.begin(), tmpUpper.end(), tmpUpper.begin(), ::toupper);

			// Set value for UI
			g_names_listbox_items.push_back(tmpUpper);
			strcpy_s(g_names_buf, sizeof g_names_buf, g_names_listbox_items[0].data());
		}

		Utils::WorkingNow.GNamesFinder = false;
		g_names_find_disabled = false;
		AfterWork();
	});
	t.detach();
}

void StartClassFinder()
{
	bool contin = false;
	// Check Address
	if (!Utils::IsValidGNamesAddress(g_names_address))
		popup_not_valid_gnames = true;
	else if (!Utils::IsValidGObjectsAddress(g_objects_address))
		popup_not_valid_gobjects = true;
	else
		contin = true;

	if (!contin || std::string(class_find_buf).empty())
		return;

	LoadOverrideEngine();
	Utils::WorkingNow.ClassesFinder = true;
	class_listbox_items.clear();

	std::thread t([&]()
	{
		BeforeWork();
		class_find_disabled = true;

		ClassFinder cf;
		class_listbox_items = cf.Find(g_objects_address, g_names_address, class_find_buf);

		Utils::WorkingNow.ClassesFinder = false;
		class_find_disabled = false;
		AfterWork();
	});
	t.detach();
}

void StartInstanceLogger()
{
	BeforeWork();
	il_objects_count = 0;
	il_names_count = 0;
	il_state = "Running . . .";
	Utils::WorkingNow.InstanceLogger = true;
	LoadOverrideEngine();

	std::thread t([&]()
	{
		InstanceLogger il(g_objects_address, g_names_address);
		auto retState = il.Start();

		switch (retState.State)
		{
		case LoggerState::Good:
			il_state = "Finished.!!";
			break;
		case LoggerState::BadGObject:
		case LoggerState::BadGObjectAddress:
			il_state = "Wrong (GObjects) Address.!!";
			break;
		case LoggerState::BadGName:
		case LoggerState::BadGNameAddress:
			il_state = "Wrong (GNames) Address.!!";
			break;
		}

		Utils::WorkingNow.InstanceLogger = false;
		il_objects_count = retState.GObjectsCount;
		il_names_count = retState.GNamesCount;
		AfterWork();
	});
	t.detach();
}

void StartSdkGenerator()
{
	BeforeWork();
	g_objects_find_disabled = true;
	g_names_find_disabled = true;

	sg_objects_count = 0;
	sg_names_count = 0;
	sg_packages_count = 0;
	sg_packages_done_count = 0;
	sg_state = "Running . . .";
	Utils::WorkingNow.SdkGenerator = true;

	std::thread t([&]()
	{
		LoadOverrideEngine();

		SdkGenerator sg(g_objects_address, g_names_address);
		SdkInfo ret = sg.Start(&sg_objects_count,
		                              &sg_names_count,
		                              &sg_packages_count,
		                              &sg_packages_done_count,
		                              sg_game_name_buf,
		                              std::to_string(sg_game_version[0]) + "." + std::to_string(sg_game_version[1]) +
		                              "." + std::to_string(sg_game_version[2]),
		                              static_cast<SdkType>(sg_type_item_current),
		                              sg_state, sg_packages_items);

		if (ret.State == GeneratorState::Good)
		{
			sg_finished = true;
			sg_state = "Finished.!!";
			sg_finished_time = ret.TookTime;
			Utils::UiMainWindow->FlashWindow();
		}
		else if (ret.State == GeneratorState::BadGObject)
		{
			sg_state = "Wrong (GObjects) Address.!!";
		}
		else if (ret.State == GeneratorState::BadGName)
		{
			sg_state = "Wrong (GNames) Address.!!";
		}

		Utils::WorkingNow.SdkGenerator = false;
		AfterWork();
	});
	t.detach();
}
#pragma endregion

#pragma region User Interface
void DonationUi(UiWindow* thiz)
{
#ifndef _DEBUG
	if (donate_show)
		ui::OpenPopup("Donate?");

	// Popup
	if (ui::BeginPopupModal("Donate?", nullptr, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoMove))
	{
		ui::TextColored(ImVec4(0.92f, 0.30f, 0.29f, 1.0f), "Welcome on Unreal Finder Tool");
		ui::Text(R"(
To code this tool it take a BIG time.
With your support i can give it more time.
Any help, even small, make a difference.

)");
		ui::TextColored(IM_COL4(230, 126, 34, 255), "On Patreon:\nYou will open future Exclusive articles and tutorial");
		ui::Separator();

		ui::PushStyleColor(ImGuiCol_Text, ImVec4(0.92f, 0.30f, 0.29f, 1.0f));
		if (ui::Button("Patreon", ImVec2(120, 0)))
		{
			ShellExecute(nullptr,
				"open",
				"https://www.patreon.com/bePatron?u=16013498",
				nullptr,
				nullptr,
				SW_SHOWDEFAULT);
			donate_show = false;
			ui::CloseCurrentPopup();
		}
		ui::PopStyleColor();

		ui::SetItemDefaultFocus();
		ui::SameLine();
		ui::PushStyleColor(ImGuiCol_Text, ImVec4(0.28f, 0.20f, 0.83f, 1.0f));
		if (ui::Button("PayPal", ImVec2(120, 0)))
		{
			ShellExecute(nullptr,
				"open",
				"http://paypal.me/IslamNofl",
				nullptr,
				nullptr,
				SW_SHOWDEFAULT);
			donate_show = false;
			ui::CloseCurrentPopup();
		}
		ui::PopStyleColor();

		ui::SameLine();
		ui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 0.0f, 0.0f, 1.0f));
		if (ui::Button("Cancel", ImVec2(120, 0)))
		{
			donate_show = false;
			ui::CloseCurrentPopup();
		}
		ui::PopStyleColor();

		ui::EndPopup();
	}
#endif
}

void TitleBarUi(UiWindow* thiz)
{
	// ui::ShowDemoWindow();

	// Settings Button
	{
		if (ui::Button(ICON_FA_COG))
			ui::OpenPopup("SettingsMenu");

		if (ui::BeginPopup("SettingsMenu"))
		{
			if (ImGui::BeginMenu("Process##menu"))
			{
				if (ui::MenuItem("Pause Process", "", &process_controller_toggles[0]))
				{
					if (!IsReadyToGo())
					{
						process_controller_toggles[0] = false;
						popup_not_valid_process = true;
					}
					else
					{
						if (process_controller_toggles[0])
							Utils::MemoryObj->SuspendProcess();
						else
							Utils::MemoryObj->ResumeProcess();
					}
				}

				ui::EndMenu();
			}

			ui::Separator();

			if (ImGui::BeginMenu("Locator##menu"))
			{
				if (ui::MenuItem("Tool Folder"))
				{
					ShellExecute(nullptr,
						"open",
						Utils::GetWorkingDirectory().c_str(),
						nullptr,
						nullptr,
						SW_SHOWDEFAULT);
				}
				ui::Separator();

				if (ui::MenuItem("SDK Folder"))
				{
					ShellExecute(nullptr,
						"open",
						(Utils::GetWorkingDirectory() + "\\Results").c_str(), 
						nullptr,
						nullptr,
						SW_SHOWDEFAULT);
				}
				ui::Separator();

				if (ui::MenuItem("Config Folder"))
				{
					ShellExecute(nullptr,
						"open",
						(Utils::GetWorkingDirectory() + "\\Config").c_str(),
						nullptr,
						nullptr,
						SW_SHOWDEFAULT);
				}

				ui::EndMenu();
			}

			ui::Separator();

			if (ImGui::BeginMenu("Help##menu"))
			{
				if (ui::MenuItem("GitHub"))
				{
					ShellExecute(nullptr,
						"open",
						"https://github.com/CorrM/Unreal-Finder-Tool",
						nullptr,
						nullptr,
						SW_SHOWDEFAULT);
				}
				ui::Separator();

				if (ui::MenuItem("Wiki"))
				{
					ShellExecute(nullptr,
						"open",
						"https://github.com/CorrM/Unreal-Finder-Tool/wiki",
						nullptr,
						nullptr,
						SW_SHOWDEFAULT);
				}
				ui::Separator();

				if (ui::MenuItem("Report issue"))
				{
					ShellExecute(nullptr,
						"open",
						"https://github.com/CorrM/Unreal-Finder-Tool/issues/new",
						nullptr,
						nullptr,
						SW_SHOWDEFAULT);
				}
				ui::Separator();

				if (ui::MenuItem("Last version"))
				{
					ShellExecute(nullptr,
						"open",
						"https://github.com/CorrM/Unreal-Finder-Tool/releases/latest",
						nullptr,
						nullptr,
						SW_SHOWDEFAULT);
				}
				ui::Separator();

				if (ui::MenuItem("Version note"))
				{
					ShellExecute(nullptr,
						"open",
						"https://github.com/CorrM/Unreal-Finder-Tool/releases/tag/" TOOL_VERSION,
						nullptr,
						nullptr,
						SW_SHOWDEFAULT);
				}

				ui::EndMenu();
			}

#ifndef _DEBUG
			ui::Separator();

			ui::PushStyleColor(ImGuiCol_Text, ImVec4(0.0f, 1.0f, 0.0f, 1.0f));
			if (ui::MenuItem("DONATE")) donate_show = true;
			ui::PopStyleColor();
#endif
			ui::EndPopup();
		}
	}

	// Title
	{
		ui::SameLine();
		ui::SetCursorPosX(abs(ui::CalcTextSize("Unreal Finder Tool By CorrM").x - ui::GetWindowWidth()) / 2);
		ui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "Unreal Finder Tool By CorrM");

#ifdef MIDI_h
		ui::SameLine();
		ui::SetCursorPosX(abs(ui::GetWindowWidth() - 65));
		
		if (ui::Button(!MidiPlayer || (MidiPlayer->IsPaused() || !MidiPlayer->IsPlaying()) ? ICON_FA_PLAY : ICON_FA_PAUSE))
		{
			if (MidiPlayer)
			{
				MidiPlayer->Rewind();
			}
			else
			{
				MidiPlayer = new CMIDI();
				MidiPlayer->Create(const_cast<LPBYTE>(midi_track1), sizeof(midi_track1));
			}

			if (MidiPlayer->IsPaused())
				MidiPlayer->Continue();
			else if (MidiPlayer->IsPlaying())
				MidiPlayer->Pause();
			else
				MidiPlayer->Play(true);
		}
		ui::SameLine();
		if (ui::Button(ICON_FA_STOP))
		{
			if (MidiPlayer && MidiPlayer->IsPlaying())
				MidiPlayer->Stop();
		}
#endif
	}
}

void InformationSectionUi(UiWindow* thiz)
{
	// Process ID
	{
		ui::AlignTextToFramePadding();
		ui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "Process ID : ");
		ui::SameLine();
		ui::SetNextItemWidth(LeftWidth / 2.f);
		ENABLE_DISABLE_WIDGET(ui::InputInt("##ProcessID", &process_id), process_id_disabled);
		ui::SameLine();

		ENABLE_DISABLE_WIDGET_IF(ui::Button(ICON_FA_SEARCH "##ProcessAutoDetector"), process_detector_disabled,
		{
			process_id = Utils::DetectUnrealGame();
		});
	}

	// Use Kernel
	{
		ui::AlignTextToFramePadding();
		ui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "Use Kernel : ");
		ui::SameLine();
		ENABLE_DISABLE_WIDGET(ui::Checkbox("##UseKernal", &use_kernal), use_kernal_disabled);
	}

	// GObjects Address
	{
		ui::AlignTextToFramePadding();
		ui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "GObjects   : ");
		ui::SameLine();
		ui::SetNextItemWidth(LeftWidth / 2.4f);

		bool style_pushed = false;
		bool isChunks;
		if (!g_objects_disabled && g_objects_address != 0)
		{
			style_pushed = true;
			bool isValid = Utils::IsValidGObjectsAddress(g_objects_address, &isChunks);
			if (isValid && isChunks)
				ui::PushStyleColor(ImGuiCol_Text, ImVec4(0.0f, 1.0f, 0.0f, 1.0f));
			else if (isValid)
				ui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 1.0f, 0.0f, 1.0f));
			else
				ui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 0.0f, 0.0f, 1.0f));
		}

		ENABLE_DISABLE_WIDGET(ui::InputText("##GObjects", g_objects_buf, IM_ARRAYSIZE(g_objects_buf), ImGuiInputTextFlags_CharsHexadecimal), g_objects_disabled);
		
		if (style_pushed)
			ui::PopStyleColor();

		ui::SameLine();
		HelpMarker("What you can put here .?\n- First UObject address.\n- First GObjects chunk address.\n\n* Not GObjects pointer.\n* It's the address you get from this tool.");
		g_objects_address = Utils::CharArrayToUintptr(g_objects_buf);
		ui::SameLine();
		if (ui::Button(ICON_FA_EYE"##view address gobjects") && g_objects_address != NULL)
			GoToAddress(g_objects_address);
	}

	// GNames Address
	{
		ui::AlignTextToFramePadding();
		ui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "GNames     : ");
		ui::SameLine();


		bool style_pushed = false;
		if (!g_names_disabled && g_names_address != 0)
		{
			style_pushed = true;
			if (Utils::IsValidGNamesAddress(g_names_address))
				ui::PushStyleColor(ImGuiCol_Text, ImVec4(0.0f, 1.0f, 0.0f, 1.0f));
			else
				ui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 0.0f, 0.0f, 1.0f));
		}

		ui::SetNextItemWidth(LeftWidth / 2.4f);
		ENABLE_DISABLE_WIDGET(ui::InputText("##GNames", g_names_buf, IM_ARRAYSIZE(g_names_buf), ImGuiInputTextFlags_CharsHexadecimal), g_names_disabled);
		g_names_address = Utils::CharArrayToUintptr(g_names_buf);

		if (style_pushed)
			ui::PopStyleColor();

		ui::SameLine();
		HelpMarker("What you can put here .?\n- GNames chunk array address.\n\n* Not GNames pointer.\n* It's the address you get from this tool.");
		ui::SameLine();
		if (ui::Button(ICON_FA_EYE"##view address gnames") && g_names_address != NULL)
			GoToAddress(g_names_address);
	}

	// Unreal version
	{
		ui::AlignTextToFramePadding();
		ui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "UE Version : ");
		if (ui::IsItemHovered())
		{
			ui::BeginTooltip();
			ui::PushTextWrapPos(ui::GetFontSize() * 35.0f);
			ui::Text("%s", game_ue_version.c_str());
			ui::PopTextWrapPos();
			ui::EndTooltip();
		}
		ui::SameLine();
		ui::SetNextItemWidth(LeftWidth / 1.57f);
		ENABLE_DISABLE_WIDGET_IF(ui::BeginCombo("##UnrealVersion", unreal_versions[ue_selected_version].c_str()), game_ue_disabled,
		{
			for (size_t i = 0; i < unreal_versions.size(); ++i)
				if (ui::Selectable(unreal_versions[i].c_str())) ue_selected_version = i;

			ui::EndCombo();
		});
	}

	// Window Title
	{
		ui::AlignTextToFramePadding();
		ui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "Win Title  : ");
		ui::SameLine();

		if (process_id != NULL && Memory::IsValidProcess(process_id))
		{
			Utils::DetectUnrealGame(window_title);
		}

		if (window_title.empty())
			window_title = "NONE";

		ui::TextUnformatted(window_title.c_str());
	}
}

void MemoryInterfaceUi(UiWindow* thiz)
{
	ui::PushStyleColor(ImGuiCol_ChildBg, ImGui::GetColorU32(ImGuiCol_WindowBg));
	if (ui::BeginChild("AddressViewer", { 0, 210 }, false, ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse))
	{
		mem_edit.DrawContents(nullptr, BufSize, CurrentViewerAddress);
		ui::EndChild();
	}
	ui::PopStyleColor();
}

void FinderUi(UiWindow* thiz)
{
	if (ui::BeginTabItem("Finder"))
	{
		if (cur_tap_id != 1)
		{
			//thiz.SetSize(380, 620);
			cur_tap_id = 1;
		}

		// ## GObjects
		{
			ui::BeginGroup();

			// Label
			ui::AlignTextToFramePadding();
			static float gobj_label_pos = ui::GetCursorPosX() + abs(ui::CalcTextSize("!~[ GObjects ]~!").x - (RightWidth / 2.3f)) / 2 - 5.f;
			ui::SetCursorPosX(gobj_label_pos);
			ui::TextColored(ImVec4(0.16f, 0.50f, 72.0f, 1.0f), "!~[ GObjects ]~!");

			// Finder
			ENABLE_DISABLE_WIDGET_IF(ui::Button("Find##GObjects", { RightWidth / 5.4f, 0.0f }), g_objects_find_disabled,
			{
				if (IsReadyToGo())
					ui::OpenPopup("Easy?");
				else
					popup_not_valid_process = true;
			});

			ui::SameLine();
			if (ui::Button("Use##Objects", { RightWidth / 5.4f, 0.0f }))
			{
				if (size_t(g_obj_listbox_item_current) < g_obj_listbox_items.size())
				{
					if (!g_objects_disabled)
						strcpy_s(g_objects_buf, sizeof g_objects_buf, g_obj_listbox_items[g_obj_listbox_item_current].data());

					if (Utils::MemoryObj)
					{
						uintptr_t address = Utils::CharArrayToUintptr(g_obj_listbox_items[g_obj_listbox_item_current]);

						// Only alloc once
						if (!PCurrentAddressData)
							PCurrentAddressData = new BYTE[BufSize];

						Utils::MemoryObj->ReadBytes(address, PCurrentAddressData, BufSize);
						GoToAddress(address);
						
					}
				}
			}

			ui::SetNextItemWidth(RightWidth / 2.5f);
			ui::ListBox("##Obj_listbox",
				&g_obj_listbox_item_current,
				VectorGetter,
				static_cast<void*>(&g_obj_listbox_items), static_cast<int>(g_obj_listbox_items.size()),
				4);

			// Popup
			if (ui::BeginPopupModal("Easy?", nullptr, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoMove))
			{
				ui::Text("First try EASY method. not work.?\nUse HARD method and wait some time.!\nUse Easy Method .?\n\n");
				ui::Separator();

				if (ui::Button("Yes", ImVec2(75, 0)))
				{
					ui::CloseCurrentPopup();
					StartGObjFinder(true);
				}

				ui::SetItemDefaultFocus();
				ui::SameLine();
				if (ui::Button("No", ImVec2(75, 0)))
				{
					ui::CloseCurrentPopup();
					StartGObjFinder(false);
				}

				ui::SameLine();
				if (ui::Button("Cancel", ImVec2(75, 0)))
					ui::CloseCurrentPopup();

				ui::EndPopup();
			}

			ui::EndGroup();
		}

		ui::SameLine();
		ui::VerticalSeparator();
		ui::SameLine();

		// ## GNames
		{
			ui::BeginGroup();
			ui::AlignTextToFramePadding();
			static float gnames_label_pos = RightWidth / 2 + (abs(ui::CalcTextSize("!~[ GNames ]~!").x - RightWidth / 2.3f) / 2.f) - 15.f;
			ui::SetCursorPosX(gnames_label_pos);
			ui::TextColored(ImVec4(0.16f, 0.50f, 72.0f, 1.0f), "!~[ GNames ]~!");

			// Start Finder
			ENABLE_DISABLE_WIDGET_IF(ui::Button("Find##GNames", { RightWidth / 5.4f, 0.0f }), g_names_find_disabled,
				{
					if (IsReadyToGo())
						StartGNamesFinder();
				else
					popup_not_valid_process = true;
			});

			ui::SameLine();

			// Set to input box
			if (ui::Button("Use##Names", { RightWidth / 5.4f, 0.0f }))
			{
				if (size_t(g_names_listbox_item_current) < g_names_listbox_items.size())
				{
					if (!g_names_disabled)
						strcpy_s(g_names_buf, sizeof g_names_buf, g_names_listbox_items[g_names_listbox_item_current].data());

					if (Utils::MemoryObj)
					{
						uintptr_t address = Utils::CharArrayToUintptr(g_names_listbox_items[g_names_listbox_item_current]);

						// Only alloc once
						if (!PCurrentAddressData)
							PCurrentAddressData = new BYTE[BufSize];

						Utils::MemoryObj->ReadBytes(address, PCurrentAddressData, BufSize);
						GoToAddress(address);
					}
				}
			}

			ui::SetNextItemWidth(RightWidth / 2.5f);
			ui::ListBox("##Names_listbox",
				&g_names_listbox_item_current,
				VectorGetter,
				static_cast<void*>(&g_names_listbox_items),
				static_cast<int>(g_names_listbox_items.size()),
				4);
			ui::EndGroup();
		}

		ui::Separator();

		// ## Class
		{
			ui::BeginGroup();

			// Label
			ui::AlignTextToFramePadding();
			static float class_label_pos = ui::GetCursorPosX() + abs(ui::CalcTextSize("!~[ Classes ]~!").x - RightWidth) / 2.f - 20.f;
			ui::SetCursorPosX(class_label_pos);
			ui::TextColored(ImVec4(0.16f, 0.50f, 72.0f, 1.0f), "!~[ Classes ]~!");

			ui::AlignTextToFramePadding();
			ui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "Class   :");
			ui::SameLine();

			// Class Input
			ui::SetNextItemWidth(RightWidth / 1.75f);
			ENABLE_DISABLE_WIDGET(ui::InputTextWithHint("##FindClass", "LocalPlayer, 0x0000000000", class_find_buf, IM_ARRAYSIZE(class_find_buf)), class_find_input_disabled);
			ui::SameLine();
			HelpMarker("What you can put here.?\n- Class Name:\n  - LocalPlayer or ULocalPlayer.\n  - MyGameInstance_C or UMyGameInstance_C.\n  - PlayerController or APlayerController.\n\n- Instance address:\n  - 0x0000000000.\n  - 0000000000.");

			ui::AlignTextToFramePadding();
			ui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "Buttons :");
			ui::SameLine();

			// Start Finder
			ENABLE_DISABLE_WIDGET_IF(ui::Button(" Find Class "), class_find_disabled,
			{
				if (IsReadyToGo())
					StartClassFinder();
				else
					popup_not_valid_process = true;
			});

			ui::SameLine();

			// Copy to clipboard
			if (ui::Button(" Copy Selected "))
			{
				if (size_t(class_listbox_item_current) < class_listbox_items.size())
				{
					std::string curStr = class_listbox_items[class_listbox_item_current];
					size_t position;
					if ((position = curStr.find(' ')) != std::string::npos)
						ui::SetClipboardText(curStr.substr(0, position).c_str());
				}
			}

			ui::SetNextItemWidth(RightWidth - 45.f);
			ui::ListBox("##Class_listbox",
				&class_listbox_item_current,
				VectorGetter,
				static_cast<void*>(&class_listbox_items),
				static_cast<int>(class_listbox_items.size()),
				6);
			ui::EndGroup();
		}

		ui::EndTabItem();
	}
}

void InstanceLoggerUi(UiWindow* thiz)
{
	if (ui::BeginTabItem("Instance"))
	{
		if (cur_tap_id != 2)
		{
			//thiz.SetSize(380, 407);
			cur_tap_id = 2;
		}

		ui::AlignTextToFramePadding();
		ui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "Objects Count : ");
		ui::SameLine();
		ui::Text("%d", il_objects_count);

		ui::AlignTextToFramePadding();
		ui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "Names Count   : ");
		ui::SameLine();
		ui::Text("%d", il_names_count);

		ui::AlignTextToFramePadding();
		ui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "State         : ");
		ui::SameLine();
		ui::Text("%s", il_state.c_str());

		// Start Logger
		ENABLE_DISABLE_WIDGET_IF(ui::Button("Start##InstanceLogger", { RightWidth - 45.f, 0.0f }), il_start_disabled,
		{
			if (IsReadyToGo())
				StartInstanceLogger();
			else
				popup_not_valid_process = true;
		});

		ui::EndTabItem();
	}
}

void SdkGeneratorUi(UiWindow* thiz)
{
	if (ui::BeginTabItem("S-D-K"))
	{
		if (cur_tap_id != 3)
		{
			//thiz.SetSize(380, 622);
			cur_tap_id = 3;
		}

		ui::AlignTextToFramePadding();
		ui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "Objects/Names : ");
		ui::SameLine();
		ui::Text("%d / %d", sg_objects_count, sg_names_count);

		ui::AlignTextToFramePadding();
		ui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "Packages      : ");
		ui::SameLine();
		ui::Text("%d / %d", sg_packages_done_count, sg_packages_count);

		ui::AlignTextToFramePadding();
		ui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "Sdk Type      : ");
		ui::SameLine();
		ui::SetNextItemWidth(100);
		ENABLE_DISABLE_WIDGET(ui::Combo("##SdkType", &sg_type_item_current, VectorGetter, static_cast<void*>(&sg_type_items), static_cast<int>(sg_type_items.size()), 4), sg_type_disabled);
		ui::SameLine();
		HelpMarker("- Internal: Generate functions for class/struct.\n- External: Don't gen functions for class/struct,\n    But generate ReadAsMe for every class/struct.");

		ui::AlignTextToFramePadding();
		ui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "Game Name     : ");
		ui::SameLine();
		ui::SetNextItemWidth(RightWidth / 1.9f);
		ENABLE_DISABLE_WIDGET(ui::InputTextWithHint("##GameName", "PUBG, Fortnite", sg_game_name_buf, IM_ARRAYSIZE(sg_game_name_buf)), sg_game_name_disabled);

		ui::AlignTextToFramePadding();
		ui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "Game Version  : ");
		ui::SameLine();
		ui::SetNextItemWidth(RightWidth / 1.9f);
		ENABLE_DISABLE_WIDGET(ui::InputInt3("##GameVersion", sg_game_version), sg_game_version_disabled);

		ui::AlignTextToFramePadding();
		ui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "State         : ");
		ui::SameLine();
		ui::Text("%s", sg_state.c_str());

		// Packages Box
		ui::SetNextItemWidth(RightWidth - 45.f);
		ui::ListBoxA("##Packages_listbox",
			&sg_packages_item_current,
			VectorGetter,
			static_cast<void*>(&sg_packages_items),
			static_cast<int>(sg_packages_items.size()), 8, true);

		// Start Generator
		ENABLE_DISABLE_WIDGET_IF(ui::Button("Start##SdkGenerator", { RightWidth - 45.f, 0.0f }), sg_start_disabled,
		{
			if (Utils::FileExists(Utils::GetWorkingDirectory() + "\\Results"))
			{
				ui::OpenPopup("Delete Old SDK?");
			}
			else
			{
				if (IsReadyToGo())
					StartSdkGenerator();
				else
					popup_not_valid_process = true;
			}
		});

		// Popup
		if (ui::BeginPopupModal("Delete Old SDK?", nullptr, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoMove))
		{
			ui::Text("There is an old sdk !, Delete it .?\n\n");
			ui::Separator();

			if (ui::Button("Yes", ImVec2(75, 0)))
			{
				ui::CloseCurrentPopup();
				Utils::DirectoryDelete(Utils::GetWorkingDirectory() + "\\Results");
				if (IsReadyToGo())
					StartSdkGenerator();
				else
					popup_not_valid_process = true;
			}

			ui::SetItemDefaultFocus();
			ui::SameLine();
			if (ui::Button("No", ImVec2(75, 0)))
			{
				ui::CloseCurrentPopup();
				if (IsReadyToGo())
					StartSdkGenerator();
				else
					popup_not_valid_process = true;
			}

			ui::SameLine();
			if (ui::Button("Cancel", ImVec2(75, 0)))
				ui::CloseCurrentPopup();

			ui::EndPopup();
		}

		ui::EndTabItem();
	}
}

void MainUi(UiWindow* thiz)
{
	DonationUi(thiz);

	TitleBarUi(thiz);
	ui::Separator();

	// left-group
	{
		ui::PushStyleColor(ImGuiCol_ChildBg, ImGui::GetColorU32(ImGuiCol_WindowBg));
		if (ui::BeginChild("##left-group", { 320.f - thiz->GetUiStyle().ItemSpacing.x, 0 }, false))
		{
			LeftWidth = ui::GetWindowWidth();

			InformationSectionUi(thiz);
			ui::Separator();

			// Tabs
			{
				if (ui::BeginTabBar("ToolsTabBar", ImGuiTabBarFlags_NoTooltip))
				{
					if (ui::BeginTabItem("Address Viewer"))
					{
						MemoryInterfaceUi(thiz);
						ui::EndTabItem();
					}

					ui::EndTabBar();
				}
			}

			ui::EndChild();
		}
		ui::PopStyleColor();

		ui::SameLine();
		ui::VerticalSeparator();
		ui::SameLine();
	}
	
	// right-group
	{
		ui::PushStyleColor(ImGuiCol_ChildBg, ImGui::GetColorU32(ImGuiCol_WindowBg));
		if (ui::BeginChild("##right-group", {Utils::UiMainWindow->GetSize().x - LeftWidth - thiz->GetUiStyle().ItemSpacing.x, 0 }, false))
		{
			RightWidth = ui::GetWindowWidth();

			// Tabs
			{
				if (ui::BeginTabBar("Debug", ImGuiTabBarFlags_NoTooltip))
				{
					FinderUi(thiz);
					InstanceLoggerUi(thiz);
					SdkGeneratorUi(thiz);

					ui::EndTabBar();
				}
			}

			ui::EndChild();
		}
		ui::PopStyleColor();
	}

	// Popups
	{
		WarningPopup("Note", std::string("") + "SDK Generation complete. !!" + "\n" + "Took: " + GetTookTime(sg_finished_time), sg_finished);
		WarningPopup("Warning", "Not Valid Process ID. !!", popup_not_valid_process);
		WarningPopup("Warning", "Not Valid GNames Address. !!", popup_not_valid_gnames);
		WarningPopup("Warning", "Not Valid GObjects Address. !!", popup_not_valid_gobjects);
	}

}
#pragma endregion

// Fix vs2019 Problem [wWinMain instead of WinMain]
// ReSharper disable once CppInconsistentNaming
int APIENTRY wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nShowCmd)  // NOLINT(readability-non-const-parameter)
{
	// Remove unneeded variables
	UNREFERENCED_PARAMETER(hInstance);
	UNREFERENCED_PARAMETER(hPrevInstance);
	UNREFERENCED_PARAMETER(lpCmdLine);
	UNREFERENCED_PARAMETER(nShowCmd);

	// Load Settings / Json Core
	if (!Utils::LoadSettings()) return 0;
	if (!Utils::LoadEngineCore(unreal_versions)) return 0;

	// Autodetect in case game already open
	process_id = Utils::DetectUnrealGame();

	// Setup Address Viewer
	mem_edit.Cols = 8;
	mem_edit.OptMidColsCount = 4;
	mem_edit.OptAddrDigitsCount = 12;
	mem_edit.OptUpperCaseHex = true;
	mem_edit.OptShowAscii = false;
	mem_edit.OptShowHexIi = false;
	mem_edit.OptShowOptions = false;
	mem_edit.OptShowDataPreview = true;
	mem_edit.OptShowDataPreviewAs = false;
	mem_edit.OptShowDataPreviewDec = false;
	mem_edit.OptShowDataPreviewBin = false;
	mem_edit.OptShowDataPreviewHex = true;
	mem_edit.OptGreyOutZeroes = true;
	mem_edit.HighlightColor = IM_COL32(0, 0, 200, 200);
	mem_edit.ReadOnly = true;
	mem_edit.ReadFn = &AddressViewerReadFn;

	// Run the new debugging tools
	Debugging d;
	d.EnterDebugMode();

	// Launch the main window
	Utils::UiMainWindow = new UiWindow("Unreal Finder Tool. Version: " TOOL_VERSION " - " TOOL_VERSION_TITLE, "CorrMFinder", 680, 530);
	Utils::UiMainWindow->Show(MainUi);

	// Check New Version
	CheckLastVer();

	while (!Utils::UiMainWindow->Closed())
		Sleep(1);

	// Cleanup
	if (Utils::MemoryObj)
	{
		Utils::MemoryObj->ResumeProcess();
		CloseHandle(Utils::MemoryObj->ProcessHandle);
		delete Utils::MemoryObj;
	}

	return ERROR_SUCCESS;
}

```

`UnrealFinderTool/UnrealFinderTool.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_ICON1               ICON                    "..\\Resources\\win.ico"

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`UnrealFinderTool/UnrealFinderTool.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{FE73D2A7-562C-4B4D-B740-162D1DDDFFAB}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>UnrealFinderTool</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)Build\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)Build\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)Build\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)Build\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;NOMINMAX;WIN32_LEAN_AND_MEAN;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <AdditionalIncludeDirectories>$(ProjectDir);.\SDKGen\;.\SDKGen\Engine\;.\SDKGen\Engine\UE4\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <OpenMPSupport>false</OpenMPSupport>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>d3d11.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;NOMINMAX;WIN32_LEAN_AND_MEAN;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>false</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <OpenMPSupport>false</OpenMPSupport>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
      <AdditionalIncludeDirectories>$(ProjectDir);.\SDKGen\;.\SDKGen\Engine;.\SDKGen\Engine\UE4;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <ShowIncludes>false</ShowIncludes>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>d3d11.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;NOMINMAX;WIN32_LEAN_AND_MEAN;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <AdditionalIncludeDirectories>$(ProjectDir);.\SDKGen\;.\SDKGen\Engine\;.\SDKGen\Engine\UE4\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <OpenMPSupport>false</OpenMPSupport>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>d3d11.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;NOMINMAX;WIN32_LEAN_AND_MEAN;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>false</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <AdditionalIncludeDirectories>$(ProjectDir);.\SDKGen\;.\SDKGen\Engine\;.\SDKGen\Engine\UE4\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <OpenMPSupport>false</OpenMPSupport>
      <FavorSizeOrSpeed>Neither</FavorSizeOrSpeed>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>d3d11.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="BypaPH.h" />
    <ClInclude Include="Debug.h" />
    <ClInclude Include="Driver.h" />
    <ClInclude Include="GnamesFinder.h" />
    <ClInclude Include="HttpWorker.h" />
    <ClInclude Include="IconsFontAwesome.h" />
    <ClInclude Include="ImControl.h" />
    <ClInclude Include="ImGUI\imconfig.h" />
    <ClInclude Include="imGUI\imgui.h" />
    <ClInclude Include="imGUI\imgui_impl_dx11.h" />
    <ClInclude Include="imGUI\imgui_impl_win32.h" />
    <ClInclude Include="imGUI\imgui_internal.h" />
    <ClInclude Include="imGUI\imstb_rectpack.h" />
    <ClInclude Include="imGUI\imstb_textedit.h" />
    <ClInclude Include="imGUI\imstb_truetype.h" />
    <ClInclude Include="InstanceLogger.h" />
    <ClInclude Include="JsonReflector.h" />
    <ClInclude Include="json.hpp" />
    <ClInclude Include="KProcessHacker.h" />
    <ClInclude Include="Logger.h" />
    <ClInclude Include="Memory.h" />
    <ClInclude Include="MemoryEditor.h" />
    <ClInclude Include="Midi\MIDI.h" />
    <ClInclude Include="Midi\MIDI_Resource.h" />
    <ClInclude Include="ParallelWorker.h" />
    <ClInclude Include="PatternScan.h" />
    <ClInclude Include="Logger.h" />
    <ClInclude Include="pch.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="Scanner.h" />
    <ClInclude Include="SdkGenerator.h" />
    <ClInclude Include="SdkGen\EngineClasses.h" />
    <ClInclude Include="SdkGen\Engine\cpplinq.hpp" />
    <ClInclude Include="SdkGen\Engine\IGenerator.h" />
    <ClInclude Include="SdkGen\Engine\NamesStore.h" />
    <ClInclude Include="SdkGen\Engine\NameValidator.h" />
    <ClInclude Include="SdkGen\Engine\ObjectsStore.h" />
    <ClInclude Include="SdkGen\Engine\Package.h" />
    <ClInclude Include="SdkGen\Engine\PrintHelper.h" />
    <ClInclude Include="SdkGen\Engine\tinyformat.h" />
    <ClInclude Include="SdkGen\Engine\UE4\FunctionFlags.h" />
    <ClInclude Include="SdkGen\Engine\UE4\GenericTypes.h" />
    <ClInclude Include="SdkGen\Engine\UE4\PropertyFlags.h" />
    <ClInclude Include="GObjectsFinder.h" />
    <ClInclude Include="Tools.h" />
    <ClInclude Include="UiWindow.h" />
    <ClInclude Include="UnsortedMap.h" />
    <ClInclude Include="Utils.h" />
    <ClInclude Include="ClassFinder.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Debug.cpp" />
    <ClCompile Include="Driver.cpp" />
    <ClCompile Include="GnamesFinder.cpp" />
    <ClCompile Include="HttpWorker.cpp" />
    <ClCompile Include="imGUI\imgui.cpp" />
    <ClCompile Include="ImGUI\imgui_demo.cpp" />
    <ClCompile Include="imGUI\imgui_draw.cpp" />
    <ClCompile Include="imGUI\imgui_impl_dx11.cpp" />
    <ClCompile Include="imGUI\imgui_impl_win32.cpp" />
    <ClCompile Include="imGUI\imgui_widgets.cpp" />
    <ClCompile Include="InstanceLogger.cpp" />
    <ClCompile Include="JsonReflector.cpp" />
    <ClCompile Include="Logger.cpp" />
    <ClCompile Include="Memory.cpp" />
    <ClCompile Include="Midi\MIDI.cpp" />
    <ClCompile Include="PatternScan.cpp" />
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="Scanner.cpp" />
    <ClCompile Include="GObjectsFinder.cpp" />
    <ClCompile Include="SdkGenerator.cpp" />
    <ClCompile Include="SdkGen\Engine\NamesStore.cpp" />
    <ClCompile Include="SdkGen\Engine\NameValidator.cpp" />
    <ClCompile Include="SdkGen\Engine\ObjectsStore.cpp" />
    <ClCompile Include="SdkGen\Engine\Package.cpp" />
    <ClCompile Include="SdkGen\Engine\PrintHelper.cpp" />
    <ClCompile Include="SdkGen\Engine\UE4\FunctionFlags.cpp" />
    <ClCompile Include="SdkGen\Engine\UE4\GenericTypes.cpp" />
    <ClCompile Include="SdkGen\Engine\UE4\PackageCore.cpp" />
    <ClCompile Include="SdkGen\Engine\UE4\PropertyFlags.cpp" />
    <ClCompile Include="SdkGen\MainGenerator.cpp" />
    <ClCompile Include="Tools.cpp" />
    <ClCompile Include="UiWindow.cpp" />
    <ClCompile Include="UnrealFinderTool.cpp" />
    <ClCompile Include="Utils.cpp" />
    <ClCompile Include="ClassFinder.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="UnrealFinderTool.rc" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="..\Resources\win.ico" />
  </ItemGroup>
  <ItemGroup>
    <None Include="packages.config" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="..\packages\cpprestsdk.v141.2.10.12.1\build\native\cpprestsdk.v141.targets" Condition="Exists('..\packages\cpprestsdk.v141.2.10.12.1\build\native\cpprestsdk.v141.targets')" />
  </ImportGroup>
  <Target Name="EnsureNuGetPackageBuildImports" BeforeTargets="PrepareForBuild">
    <PropertyGroup>
      <ErrorText>This project references NuGet package(s) that are missing on this computer. Use NuGet Package Restore to download them.  For more information, see http://go.microsoft.com/fwlink/?LinkID=322105. The missing file is {0}.</ErrorText>
    </PropertyGroup>
    <Error Condition="!Exists('..\packages\cpprestsdk.v141.2.10.12.1\build\native\cpprestsdk.v141.targets')" Text="$([System.String]::Format('$(ErrorText)', '..\packages\cpprestsdk.v141.2.10.12.1\build\native\cpprestsdk.v141.targets'))" />
  </Target>
</Project>
```

`UnrealFinderTool/UnsortedMap.h`:

```h
#ifndef UNSORTED_MAP
#define UNSORTED_MAP

#pragma once
#include <algorithm>
#include <vector>


template <typename K, typename V>
class UnsortedMap : public std::vector<std::pair<K, V>>
{
	using UnsortedMapItem = std::pair<K, V>;
	using UnsortedMapIt = typename std::vector<std::pair<K, V>>::iterator;
public:
	UnsortedMap() = default;
	UnsortedMap(const UnsortedMapIt& begin, const UnsortedMapIt& end)
	{
		this->assign(begin, end);
	}

	UnsortedMapIt find(const K& ref)
	{
		return std::find_if(this->begin(), this->end(), [&ref](const std::pair<K, V>& vecItem)
		{
			return vecItem.first == ref;
		});
	}

	V* Find(const K& ref, bool& success)
	{
		auto it = std::find_if(this->begin(), this->end(), [&](const std::pair<K, V>& vecItem) -> bool
		{
			return vecItem.first == ref;
		});

		success = it != this->end();
		if (success)
			return &it->second;
		return nullptr; // if code hit this point then maybe there a problem need to solve :D
	}

	V* Find(const K& ref)
	{
		bool tmp;
		return Find(ref, tmp);
	}
};
#endif // !UnsortedMap

```

`UnrealFinderTool/Utils.cpp`:

```cpp
#include "pch.h"
#include "JsonReflector.h"
#include "PatternScan.h"
#include "Memory.h"
#include "UiWindow.h"
#include "Utils.h"

#include <vector>
#include <sstream>
#include <algorithm>
#include <cctype>
#include <tchar.h>

Memory* Utils::MemoryObj = nullptr;
UiWindow* Utils::UiMainWindow = nullptr;
MySettings Utils::Settings;
WorkingTools Utils::WorkingNow;
std::mutex Utils::MainMutex;

#pragma region Json
bool Utils::LoadEngineCore(std::vector<std::string>& ue_versions_container)
{
	// Get all engine files and load it's structs
	if (!JsonReflector::ReadAndLoadFile("Config\\EngineCore\\EngineBase.json", &JsonReflector::JsonBaseObj))
	{
		MessageBox(nullptr, "Can't read EngineBase file.", "Error", MB_OK);
		ExitProcess(-1);
		// return false;
	}
	ue_versions_container.emplace_back("EngineBase");

	for (auto& file : fs::directory_iterator("Config\\EngineCore\\"))
	{
		std::string ue_ver = file.path().filename().string();
		auto pos = ue_ver.rfind('.');
		ue_ver = ue_ver.substr(0, pos);
		if (ue_ver != "EngineBase")
			ue_versions_container.push_back(ue_ver);
	}

	return true;
}

void Utils::OverrideLoadedEngineCore(const std::string& engineVersion)
{
	// Get engine files and Override it's structs on EngineBase, if return false then there is no override for target engine and use the EngineBase
	try
	{
		if (engineVersion != "EngineBase")
			JsonReflector::ReadAndLoadFile("Config\\EngineCore\\" + engineVersion + ".json", true);
	}
	catch (...)
	{
		std::string error = "Can't find/parse json file '" + engineVersion + ".json'.";
		MessageBoxA(nullptr, error.c_str(), "Critical Problem", MB_OK | MB_ICONERROR);
		ExitProcess(-1);
	}
}

bool Utils::LoadSettings()
{
	if (!JsonReflector::ReadJsonFile("Config\\Settings.json"))
	{
		MessageBox(nullptr, "Can't read Settings file.", "Error", MB_OK);
		return false;
	}

	auto j = JsonReflector::JsonObj;

	// Sdk Generator Settings
	auto sdkParas = j.at("sdkGenerator");
	Settings.SdkGen.CorePackageName = sdkParas["core Name"];
	Settings.SdkGen.MemoryHeader = sdkParas["memory header"];
	Settings.SdkGen.MemoryRead = sdkParas["memory read"];
	Settings.SdkGen.MemoryWrite = sdkParas["memory write"];
	Settings.SdkGen.MemoryWriteType = sdkParas["memory write type"];
	Settings.SdkGen.Threads = sdkParas["threads"];

	Settings.SdkGen.DumpObjects = sdkParas["dump Objects"];
	Settings.SdkGen.DumpNames = sdkParas["dump Names"];

	Settings.SdkGen.LoggerShowSkip = sdkParas["logger ShowSkip"];
	Settings.SdkGen.LoggerShowClassSaveFileName = sdkParas["logger ShowClassSaveFileName"];
	Settings.SdkGen.LoggerShowStructSaveFileName = sdkParas["logger ShowStructSaveFileName"];
	Settings.SdkGen.LoggerSpaceCount = sdkParas["logger SpaceCount"];
	return true;
}
#pragma endregion

#pragma region FileManager
bool Utils::FileExists(const std::string& filePath)
{
	fs::path path(std::wstring(filePath.begin(), filePath.end()));
	return fs::exists(path);
}

bool Utils::FileDelete(const std::string& filePath)
{
	if (!FileExists(filePath))
		return false;
	
	fs::path path(std::wstring(filePath.begin(), filePath.end()));
	return fs::remove(path);
}

bool Utils::DirectoryDelete(const std::string& dirPath)
{
	if (!FileExists(dirPath))
		return false;

	fs::path path(std::wstring(dirPath.begin(), dirPath.end()));
	return fs::remove_all(path) > 0;
}

std::string Utils::GetWorkingDirectory()
{
	// Returned cached copy of path
	static std::string curDir(260, '\0');
	if (curDir[0] != '\0')
		return curDir;

	// Get working directory path
	GetModuleFileName(nullptr, curDir.data(), static_cast<DWORD>(curDir.length()));

	fs::path curPath(curDir);
	curDir = curPath.parent_path().string();

	return curDir;
}
#pragma endregion

#pragma region String
std::vector<std::string> Utils::SplitString(const std::string& str, const std::string& delimiter)
{
	std::vector<std::string> strings;

	std::string::size_type pos;
	std::string::size_type prev = 0;
	while ((pos = str.find(delimiter, prev)) != std::string::npos)
	{
		strings.push_back(str.substr(prev, pos - prev));
		prev = pos + 1;
	}

	// To get the last substring (or only, if delimiter is not found)
	strings.push_back(str.substr(prev));

	return strings;
}

std::string Utils::ReplaceString(std::string str, const std::string& to_find, const std::string& to_replace)
{
	if (to_find.empty())
		return str;

	for (size_t position = str.find(to_find); position != std::string::npos; position = str.find(to_find, position))
		str.replace(position, to_find.length(), to_replace);
	return str;
}

bool Utils::ContainsString(const std::string& str, const std::string& strToFind)
{
	return str.find(strToFind) != std::string::npos;
}

bool Utils::EndsWith(const std::string& value, const std::string& ending)
{
	if (ending.size() > value.size()) return false;
	return std::equal(ending.rbegin(), ending.rend(), value.rbegin());
}

bool Utils::IsNumber(const std::string& s)
{
	return !s.empty() && std::find_if(s.begin(),
	                                  s.end(), [](const char c) { return !std::isdigit(c); }) == s.end();
}

bool Utils::IsHexNumber(const std::string& s)
{
	return std::all_of(s.begin(), s.end(), [](const unsigned char c) { return std::isxdigit(c); });
}
#pragma endregion

#pragma region Types Converter
int Utils::BufToInteger(void* buffer)
{
	return *reinterpret_cast<DWORD*>(buffer);
}

int64_t Utils::BufToInteger64(void* buffer)
{
	return *reinterpret_cast<DWORD64*>(buffer);
}

uintptr_t Utils::CharArrayToUintptr(const std::string& str)
{
	if (str.empty())
		return 0;

	uintptr_t retVal;
	std::stringstream ss;
	ss << std::hex << str;
	ss >> retVal;

	return retVal;
}

std::string Utils::AddressToHex(const uintptr_t address)
{
	std::stringstream ss;
	ss << std::hex << address;
	return ss.str();
}
#pragma endregion

#pragma region Address stuff
bool Utils::IsValidRemoteAddress(Memory* mem, const uintptr_t address)
{
	if (INVALID_POINTER_VALUE(address))
		return false;

	// Check memory state, type and permission
	MEMORY_BASIC_INFORMATION info;

	//const uintptr_t pointerVal = _memory->ReadInt(pointer);
	if (VirtualQueryEx(mem->ProcessHandle, LPVOID(address), &info, sizeof info) == sizeof info)
	{
		// Bad Memory
		return !(info.Protect & PAGE_NOACCESS);
	}

	return false;
}

bool Utils::IsValidLocalAddress(const uintptr_t address)
{
	if (INVALID_POINTER_VALUE(address))
		return false;

	// Check memory state, type and permission
	MEMORY_BASIC_INFORMATION info;

	//const uintptr_t pointerVal = _memory->ReadInt(pointer);
	if (VirtualQuery(LPVOID(address), &info, sizeof info) == sizeof info)
	{
		// Bad Memory
		return /*(info.State & MEM_COMMIT) && */!(info.Protect & PAGE_NOACCESS);
	}

	return false;
}

bool Utils::IsValidRemotePointer(const uintptr_t pointer, uintptr_t *address)
{
	uintptr_t tmp;
	if (!address) address = &tmp;

	*address = MemoryObj->ReadAddress(pointer);
	if (INVALID_POINTER_VALUE(*address))
		return false;

	// Check memory state, type and permission
	MEMORY_BASIC_INFORMATION info;

	//const uintptr_t pointerVal = _memory->ReadInt(pointer);
	if (VirtualQueryEx(MemoryObj->ProcessHandle, LPVOID(pointer), &info, sizeof info) == sizeof info)
	{
		return (info.State & MEM_COMMIT) && !(info.Protect & PAGE_NOACCESS);
	}

	return false;
}

bool Utils::IsValidGNamesAddress(const uintptr_t address)
{
	if (MemoryObj == nullptr || !IsValidRemoteAddress(MemoryObj, address))
		return false;

	int null_count = 0;

	// Chunks array must have null pointers, if not then it's not valid
	for (int read_address = 0; read_address <= 50; ++read_address)
	{
		// Read Chunk Address
		auto offset = size_t(read_address * PointerSize());
		uintptr_t chunk_address = MemoryObj->ReadAddress(address + offset);
		if (chunk_address == NULL)
			++null_count;
	}

	if (null_count <= 3)
		return false;

	// Read First FName Address
	uintptr_t noneFName = MemoryObj->ReadAddress(MemoryObj->ReadAddress(address));
	if (!IsValidRemoteAddress(MemoryObj, noneFName)) return false;

	// Search for none FName
	auto pattern = PatternScan::Parse("NoneSig", 0, "4E 6F 6E 65 00", 0xFF);
	auto result = PatternScan::FindPattern(MemoryObj, noneFName, noneFName + 0x50, { pattern }, true);
	auto resVec = result.find("NoneSig")->second;
	return !resVec.empty();
}

bool Utils::IsValidGObjectsAddress(const uintptr_t address, bool* isChunks)
{
	uintptr_t addressHolder = address;
	if (isChunks)
		*isChunks = false;

	if (MemoryObj == nullptr || !IsValidRemoteAddress(MemoryObj, addressHolder))
		return false;

	bool firstCheck = true;
	uintptr_t ptrUObject0, ptrUObject1, ptrUObject2, ptrUObject3, ptrUObject4, ptrUObject5;
	uintptr_t ptrVfTableObject0, ptrVfTableObject1, ptrVfTableObject2, ptrVfTableObject3, ptrVfTableObject4,
	          ptrVfTableObject5;

CheckAgian:
	for (int i = 0x0; i <= 0x20; i += 0x4)
	{
		// Check (UObject*) Is Valid Pointer
		if (!IsValidRemotePointer(addressHolder + (i * 0), &ptrUObject0)) continue;
		if (!IsValidRemotePointer(addressHolder + (i * 1), &ptrUObject1)) continue;
		if (!IsValidRemotePointer(addressHolder + (i * 2), &ptrUObject2)) continue;
		if (!IsValidRemotePointer(addressHolder + (i * 3), &ptrUObject3)) continue;
		if (!IsValidRemotePointer(addressHolder + (i * 4), &ptrUObject4)) continue;
		if (!IsValidRemotePointer(addressHolder + (i * 5), &ptrUObject5)) continue;

		// Check vfTableObject Is Valid Pointer
		if (!IsValidRemotePointer(ptrUObject0, &ptrVfTableObject0)) continue;
		if (!IsValidRemotePointer(ptrUObject1, &ptrVfTableObject1)) continue;
		if (!IsValidRemotePointer(ptrUObject2, &ptrVfTableObject2)) continue;
		if (!IsValidRemotePointer(ptrUObject3, &ptrVfTableObject3)) continue;
		if (!IsValidRemotePointer(ptrUObject4, &ptrVfTableObject4)) continue;
		if (!IsValidRemotePointer(ptrUObject5, &ptrVfTableObject5)) continue;

		// Check Objects (InternalIndex)
		for (int io = 0x0; io < 0x1C; io += 0x4)
		{
			const int uObject0InternalIndex = MemoryObj->ReadInt(ptrUObject0 + io);
			const int uObject1InternalIndex = MemoryObj->ReadInt(ptrUObject1 + io);
			const int uObject2InternalIndex = MemoryObj->ReadInt(ptrUObject2 + io);
			const int uObject3InternalIndex = MemoryObj->ReadInt(ptrUObject3 + io);
			const int uObject4InternalIndex = MemoryObj->ReadInt(ptrUObject4 + io);
			const int uObject5InternalIndex = MemoryObj->ReadInt(ptrUObject5 + io);

			if (uObject0InternalIndex != 0) continue;
			if (!(uObject1InternalIndex == 1 || uObject1InternalIndex == 3)) continue;
			if (!(uObject2InternalIndex == 2 || uObject2InternalIndex == 6)) continue;
			if (!(uObject3InternalIndex == 3 || uObject3InternalIndex == 9)) continue;
			if (!(uObject4InternalIndex == 4 || uObject4InternalIndex == 12)) continue;
			if (!(uObject5InternalIndex == 5 || uObject5InternalIndex == 15)) continue;

			// Check if 2nd UObject have FName_Index == 100
			bool bFoundNameIndex = false;
			for (int j = 0x4; j < 0x1C; j += 0x4)
			{
				const int uFNameIndex = MemoryObj->ReadInt(ptrUObject1 + j);
				if (uFNameIndex == 100)
				{
					bFoundNameIndex = true;
					break;
				}
			}

			// Check if it's chunks address
			if (isChunks && !firstCheck)
			{
				int skipCount = 0;
				for (size_t uIndex = 0; uIndex <= 20 && skipCount <= 5; ++uIndex)
				{
					uintptr_t curAddress = address + uIndex * PointerSize();
					uintptr_t chunk = MemoryObj->ReadAddress(curAddress);

					// Skip null address and bad address
					if (chunk == 0)
					{
						++skipCount;
						continue;
					}
					if (!IsValidRemoteAddress(MemoryObj, chunk)) break;

					skipCount = 0;
				}

				if (skipCount >= 5)
				{
					*isChunks = true;
				}
				else
				{
					*isChunks = false;
				}
			}

			return bFoundNameIndex;
		}
	}

	// If it's GObjects Chunks
	if (firstCheck)
	{
		firstCheck = false;
		addressHolder = MemoryObj->ReadAddress(addressHolder);
		goto CheckAgian;
	}

	if (isChunks)
		*isChunks = !firstCheck;

	return false;
}

void Utils::FixStructPointer(void* structBase, const int varOffset, const size_t structSize)
{
	{
		// Check next 4byte of pointer equal 0 in local tool memory
		// in 32bit game pointer is 4byte so i must zero the second part of uintptr_t in the tool memory
		// so here i check if second part of uintptr_t is zero so it's didn't need fix
		// this check is good for solve some problem when cast UObject to something like UEnum
		// the base (UObject) is fixed but the other (UEnum members) not fixed so, this wil fix really members need to fix
		// That's it :D
		//bool needFix = *reinterpret_cast<int*>(reinterpret_cast<uintptr_t>(structBase) + varOffset + 0x4) != 0;
		//if (!needFix) return;
	}

	if (ProgramIs64() && MemoryObj->Is64Bit)
		throw std::exception("FixStructPointer only work for 32bit games with 64bit tool version.");

	const size_t destSize = abs(varOffset - static_cast<long long>(structSize));
	const size_t srcSize = abs(varOffset - static_cast<long long>(structSize)) - 0x4;

	char* src = static_cast<char*>(structBase) + varOffset;
	char* dest = src + 0x4;

	memcpy_s(dest, destSize, src, srcSize);
	memset(dest, 0x0, 0x4);
}

int Utils::PointerSize()
{
	return MemoryObj->Is64Bit ? 0x8 : 0x4;
}
#pragma endregion

#pragma region Tool stuff
bool Utils::ProgramIs64()
{
#if _WIN64
	return true;
#else
		return false;
#endif
}

void Utils::SleepEvery(const int ms, int& counter, const int every)
{
	if (every == 0)
	{
		counter = 0;
		return;
	}

	if (counter >= every)
	{
		Sleep(ms);
		counter = 0;
	}
	else
	{
		++counter;
	}
}
#pragma endregion

#pragma region UnrealEngine
DWORD Utils::DetectUnrealGame(HWND* windowHandle, std::string& windowTitle)
{
	HWND childControl = FindWindowEx(HWND_DESKTOP, nullptr, UNREAL_WINDOW_CLASS, nullptr);
	retry:
	if (childControl != nullptr)
	{
		DWORD pId;
		GetWindowThreadProcessId(childControl, &pId);

		if (Memory::GetProcessNameById(pId) == "EpicGamesLauncher.exe")
		{
			childControl = FindWindowEx(HWND_DESKTOP, childControl, UNREAL_WINDOW_CLASS, nullptr);
			goto retry;
		}

		if (windowHandle != nullptr)
			*windowHandle = childControl;

		windowTitle.resize(27);
		GetWindowText(childControl, windowTitle.data(), 27);
		return pId;
	}

	return 0;
}

DWORD Utils::DetectUnrealGame(std::string& windowTitle)
{
	return DetectUnrealGame(nullptr, windowTitle);
}

DWORD Utils::DetectUnrealGame()
{
	std::string tmp;
	return DetectUnrealGame(nullptr, tmp);
}

bool Utils::UnrealEngineVersion(std::string& ver)
{
	auto ret = false;

	auto process = MemoryObj->ProcessHandle;
	if (!process)
		return ret;

	std::string path;
	path.resize(MAX_PATH, '\0');

	DWORD path_size = MAX_PATH;
	if (!QueryFullProcessImageName(process, 0, path.data(), &path_size))
		return ret;

	unsigned long version_size = GetFileVersionInfoSize(path.c_str(), &version_size);
	if (version_size > 0)
	{
		auto pData = new BYTE[version_size];
		GetFileVersionInfo(path.c_str(), 0, version_size, static_cast<LPVOID>(pData));

		void* fixed = nullptr;
		unsigned int size = 0;

		VerQueryValue(pData, _T("\\"), &fixed, &size);
		if (fixed)
		{
			auto ffi = static_cast<VS_FIXEDFILEINFO*>(fixed);

			auto v1 = HIWORD(ffi->dwFileVersionMS);
			auto v2 = LOWORD(ffi->dwFileVersionMS);
			auto v3 = HIWORD(ffi->dwFileVersionLS);

			std::string engine_version = std::to_string(v1) + "." + std::to_string(v2) + "." + std::to_string(v3);
			ver = engine_version;
			ret = true;
		}
		delete[] pData;
	}
	return ret;
}
#pragma endregion

```

`UnrealFinderTool/Utils.h`:

```h
#pragma once
#include "Memory.h"

#include <string>
#include <vector>
#include <filesystem>
#include <mutex>

namespace fs = std::filesystem;
#define UNREAL_WINDOW_CLASS "UnrealWindow"
class UiWindow;

struct MySettings
{
	struct _SdkGenSettings
	{
		std::string CorePackageName;

		std::string MemoryHeader;
		std::string MemoryRead;
		std::string MemoryWrite;
		std::string MemoryWriteType;

		int Threads = 0;
		bool DumpObjects = false;
		bool DumpNames = false;
		bool LoggerShowSkip = true;
		bool LoggerShowClassSaveFileName = true;
		bool LoggerShowStructSaveFileName = true;
		int LoggerSpaceCount = 85;
	};

	struct _Parallel
	{
		int SleepEvery = 0;
	};

	_SdkGenSettings SdkGen;
	_Parallel Parallel;
};

struct WorkingTools
{
	bool GNamesFinder;
	bool GObjectsFinder;
	bool ClassesFinder;
	bool InstanceLogger;
	bool SdkGenerator;

	bool AnyRunningTool() const
	{
		return GNamesFinder || GObjectsFinder || ClassesFinder || InstanceLogger || SdkGenerator;
	}
};

class Utils
{
public:
	// Package Process Mutex
	static std::mutex MainMutex;
	// Main Window
	static UiWindow* UiMainWindow;
	// Tool settings container
	static MySettings Settings;
	// Main Memory reader for read game memory props
	static Memory* MemoryObj;
	// Store information about which tools working
	static WorkingTools WorkingNow;

	// Load settings form the file
	static bool LoadSettings();
	// Check file Exists
	static bool FileExists(const std::string& filePath);
	// Delete file
	static bool FileDelete(const std::string& filePath);
	// Delete Directory
	static bool DirectoryDelete(const std::string& dirPath);
	// Get Current Directory
	static std::string GetWorkingDirectory();
	// Load engine structs from `EngineBase.json`
	static bool LoadEngineCore(std::vector<std::string>& ue_versions_container);
	// Override engine structs that load form another engine structs, `engineVersion` must look like '4.0.0'
	static void OverrideLoadedEngineCore(const std::string& engineVersion);
	// Split string by other string
	static std::vector<std::string> SplitString(const std::string& str, const std::string& delimiter);
	// Replace string
	static std::string ReplaceString(std::string str, const std::string& to_find, const std::string& to_replace);
	// Check if string contains another string
	static bool ContainsString(const std::string& str, const std::string& strToFind);
	// Check if string ends with other string
	static bool EndsWith(const std::string& value, const std::string& ending);
	// Determine if tool is working on x64 version. (Not Target game version)
	static bool ProgramIs64();
	// Convert Bytes to Int
	static int BufToInteger(void* buffer);
	// Convert Bytes to Int64
	static int64_t BufToInteger64(void* buffer);
	// Convert string to uintptr_t
	static uintptr_t CharArrayToUintptr(const std::string& str);
	// Convert uintptr_t to Hex string
	static std::string AddressToHex(uintptr_t address);
	// Determine if string is number
	static bool IsNumber(const std::string& s);
	// Determine if string is HEX number
	static bool IsHexNumber(const std::string& s);
	// Return size of pointer in target game
	static int PointerSize();
	// Check valid address in remote process
	static bool IsValidRemoteAddress(Memory* mem, uintptr_t address);
	// Check valid address in local process
	static bool IsValidLocalAddress(uintptr_t address);
	// Check valid pointer in remote process, (Read address and check it's value is valid address)
	static bool IsValidRemotePointer(uintptr_t pointer, uintptr_t *address = nullptr);
	// Check if Address is point GNames Array
	static bool IsValidGNamesAddress(uintptr_t address);
	// Check if Address is point GObjects Array
	static bool IsValidGObjectsAddress(uintptr_t address, bool* isChunks = nullptr);
	// Sleep when counter hit each selected ms
	static void SleepEvery(int ms, int& counter, int every);

	/// <summary>
	/// Fix pointer size in struct or class. used for convert 64bit to 32bit pointer.
	/// </summary>
	/// <param name="structBase">Pointer to instance of `ElementType`</param>
	/// <param name="varOffset">Offset to variable based on `ElementType`</param>
	template <typename ElementType> static void FixPointer(ElementType* structBase, const int varOffset);
	/// <summary>
	/// Fix pointers size in struct or class. used for convert 64bit to 32bit pointer.
	/// </summary>
	/// <param name="structBase">Pointer to instance of `ElementType`</param>
	/// <param name="fullCppStructSize">Full size of struct => (Base Structs + Target struct)</param>
	/// <param name="varsOffsets">Offsets to variables based on `ElementType`</param>
	template <typename ElementType> static void FixPointers(ElementType* structBase, size_t fullCppStructSize, std::vector<int> varsOffsets);

	static DWORD DetectUnrealGame(HWND* windowHandle, std::string& windowTitle);
	static DWORD DetectUnrealGame(std::string& windowTitle);
	static DWORD DetectUnrealGame();
	static bool UnrealEngineVersion(std::string& ver);

private:
	/// <summary>
	/// Fix pointer size in struct or class. used for convert 64bit to 32bit pointer.
	/// Must pick the right struct Size, else will case some memory problems in the hole program
	/// </summary>
	/// <param name="structBase">Pointer to instance of struct</param>
	/// <param name="varOffset">Offset to variable based on `structBase`</param>
	/// <param name="structSize">Size of struct</param>
	static void FixStructPointer(void* structBase, int varOffset, size_t structSize);
};

template <typename ElementType>
void Utils::FixPointer(ElementType* structBase, const int varOffset)
{
	if (ProgramIs64() && MemoryObj->Is64Bit)
		return;
	FixStructPointer(structBase, varOffset, sizeof(ElementType));
}

template <typename ElementType>
void Utils::FixPointers(ElementType* structBase, const size_t fullCppStructSize, std::vector<int> varsOffsets)
{
	if (ProgramIs64() && MemoryObj->Is64Bit)
		return;

	for (int varOff : varsOffsets)
		FixStructPointer(structBase, varOff, fullCppStructSize);
}

```

`UnrealFinderTool/json.hpp`:

```hpp
/*
    __ _____ _____ _____
 __|  |   __|     |   | |  JSON for Modern C++
|  |  |__   |  |  | | | |  version 3.6.1
|_____|_____|_____|_|___|  https://github.com/nlohmann/json

Licensed under the MIT License <http://opensource.org/licenses/MIT>.
SPDX-License-Identifier: MIT
Copyright (c) 2013-2019 Niels Lohmann <http://nlohmann.me>.

Permission is hereby  granted, free of charge, to any  person obtaining a copy
of this software and associated  documentation files (the "Software"), to deal
in the Software  without restriction, including without  limitation the rights
to  use, copy,  modify, merge,  publish, distribute,  sublicense, and/or  sell
copies  of  the Software,  and  to  permit persons  to  whom  the Software  is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE  IS PROVIDED "AS  IS", WITHOUT WARRANTY  OF ANY KIND,  EXPRESS OR
IMPLIED,  INCLUDING BUT  NOT  LIMITED TO  THE  WARRANTIES OF  MERCHANTABILITY,
FITNESS FOR  A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT  SHALL THE
AUTHORS  OR COPYRIGHT  HOLDERS  BE  LIABLE FOR  ANY  CLAIM,  DAMAGES OR  OTHER
LIABILITY, WHETHER IN AN ACTION OF  CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE  OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#ifndef INCLUDE_NLOHMANN_JSON_HPP_
#define INCLUDE_NLOHMANN_JSON_HPP_

#define NLOHMANN_JSON_VERSION_MAJOR 3
#define NLOHMANN_JSON_VERSION_MINOR 6
#define NLOHMANN_JSON_VERSION_PATCH 1

#include <algorithm> // all_of, find, for_each
#include <cassert> // assert
#include <ciso646> // and, not, or
#include <cstddef> // nullptr_t, ptrdiff_t, size_t
#include <functional> // hash, less
#include <initializer_list> // initializer_list
#include <iosfwd> // istream, ostream
#include <iterator> // random_access_iterator_tag
#include <memory> // unique_ptr
#include <numeric> // accumulate
#include <string> // string, stoi, to_string
#include <utility> // declval, forward, move, pair, swap
#include <vector> // vector

// #include <nlohmann/adl_serializer.hpp>


#include <utility>

// #include <nlohmann/detail/conversions/from_json.hpp>


#include <algorithm> // transform
#include <array> // array
#include <ciso646> // and, not
#include <forward_list> // forward_list
#include <iterator> // inserter, front_inserter, end
#include <map> // map
#include <string> // string
#include <tuple> // tuple, make_tuple
#include <type_traits> // is_arithmetic, is_same, is_enum, underlying_type, is_convertible
#include <unordered_map> // unordered_map
#include <utility> // pair, declval
#include <valarray> // valarray

// #include <nlohmann/detail/exceptions.hpp>


#include <exception> // exception
#include <stdexcept> // runtime_error
#include <string> // to_string

// #include <nlohmann/detail/input/position_t.hpp>


#include <cstddef> // size_t

namespace nlohmann
{
namespace detail
{
/// struct to capture the start position of the current token
struct position_t
{
    /// the total number of characters read
    std::size_t chars_read_total = 0;
    /// the number of characters read in the current line
    std::size_t chars_read_current_line = 0;
    /// the number of lines read
    std::size_t lines_read = 0;

    /// conversion to size_t to preserve SAX interface
    constexpr operator size_t() const
    {
        return chars_read_total;
    }
};

} // namespace detail
} // namespace nlohmann


namespace nlohmann
{
namespace detail
{
////////////////
// exceptions //
////////////////

/*!
@brief general exception of the @ref basic_json class

This class is an extension of `std::exception` objects with a member @a id for
exception ids. It is used as the base class for all exceptions thrown by the
@ref basic_json class. This class can hence be used as "wildcard" to catch
exceptions.

Subclasses:
- @ref parse_error for exceptions indicating a parse error
- @ref invalid_iterator for exceptions indicating errors with iterators
- @ref type_error for exceptions indicating executing a member function with
                  a wrong type
- @ref out_of_range for exceptions indicating access out of the defined range
- @ref other_error for exceptions indicating other library errors

@internal
@note To have nothrow-copy-constructible exceptions, we internally use
      `std::runtime_error` which can cope with arbitrary-length error messages.
      Intermediate strings are built with static functions and then passed to
      the actual constructor.
@endinternal

@liveexample{The following code shows how arbitrary library exceptions can be
caught.,exception}

@since version 3.0.0
*/
class exception : public std::exception
{
  public:
    /// returns the explanatory string
    const char* what() const noexcept override
    {
        return m.what();
    }

    /// the id of the exception
    const int id;

  protected:
    exception(int id_, const char* what_arg) : id(id_), m(what_arg) {}

    static std::string name(const std::string& ename, int id_)
    {
        return "[json.exception." + ename + "." + std::to_string(id_) + "] ";
    }

  private:
    /// an exception object as storage for error messages
    std::runtime_error m;
};

/*!
@brief exception indicating a parse error

This exception is thrown by the library when a parse error occurs. Parse errors
can occur during the deserialization of JSON text, CBOR, MessagePack, as well
as when using JSON Patch.

Member @a byte holds the byte index of the last read character in the input
file.

Exceptions have ids 1xx.

name / id                      | example message | description
------------------------------ | --------------- | -------------------------
json.exception.parse_error.101 | parse error at 2: unexpected end of input; expected string literal | This error indicates a syntax error while deserializing a JSON text. The error message describes that an unexpected token (character) was encountered, and the member @a byte indicates the error position.
json.exception.parse_error.102 | parse error at 14: missing or wrong low surrogate | JSON uses the `\uxxxx` format to describe Unicode characters. Code points above above 0xFFFF are split into two `\uxxxx` entries ("surrogate pairs"). This error indicates that the surrogate pair is incomplete or contains an invalid code point.
json.exception.parse_error.103 | parse error: code points above 0x10FFFF are invalid | Unicode supports code points up to 0x10FFFF. Code points above 0x10FFFF are invalid.
json.exception.parse_error.104 | parse error: JSON patch must be an array of objects | [RFC 6902](https://tools.ietf.org/html/rfc6902) requires a JSON Patch document to be a JSON document that represents an array of objects.
json.exception.parse_error.105 | parse error: operation must have string member 'op' | An operation of a JSON Patch document must contain exactly one "op" member, whose value indicates the operation to perform. Its value must be one of "add", "remove", "replace", "move", "copy", or "test"; other values are errors.
json.exception.parse_error.106 | parse error: array index '01' must not begin with '0' | An array index in a JSON Pointer ([RFC 6901](https://tools.ietf.org/html/rfc6901)) may be `0` or any number without a leading `0`.
json.exception.parse_error.107 | parse error: JSON pointer must be empty or begin with '/' - was: 'foo' | A JSON Pointer must be a Unicode string containing a sequence of zero or more reference tokens, each prefixed by a `/` character.
json.exception.parse_error.108 | parse error: escape character '~' must be followed with '0' or '1' | In a JSON Pointer, only `~0` and `~1` are valid escape sequences.
json.exception.parse_error.109 | parse error: array index 'one' is not a number | A JSON Pointer array index must be a number.
json.exception.parse_error.110 | parse error at 1: cannot read 2 bytes from vector | When parsing CBOR or MessagePack, the byte vector ends before the complete value has been read.
json.exception.parse_error.112 | parse error at 1: error reading CBOR; last byte: 0xF8 | Not all types of CBOR or MessagePack are supported. This exception occurs if an unsupported byte was read.
json.exception.parse_error.113 | parse error at 2: expected a CBOR string; last byte: 0x98 | While parsing a map key, a value that is not a string has been read.
json.exception.parse_error.114 | parse error: Unsupported BSON record type 0x0F | The parsing of the corresponding BSON record type is not implemented (yet).

@note For an input with n bytes, 1 is the index of the first character and n+1
      is the index of the terminating null byte or the end of file. This also
      holds true when reading a byte vector (CBOR or MessagePack).

@liveexample{The following code shows how a `parse_error` exception can be
caught.,parse_error}

@sa - @ref exception for the base class of the library exceptions
@sa - @ref invalid_iterator for exceptions indicating errors with iterators
@sa - @ref type_error for exceptions indicating executing a member function with
                    a wrong type
@sa - @ref out_of_range for exceptions indicating access out of the defined range
@sa - @ref other_error for exceptions indicating other library errors

@since version 3.0.0
*/
class parse_error : public exception
{
  public:
    /*!
    @brief create a parse error exception
    @param[in] id_       the id of the exception
    @param[in] pos       the position where the error occurred (or with
                         chars_read_total=0 if the position cannot be
                         determined)
    @param[in] what_arg  the explanatory string
    @return parse_error object
    */
    static parse_error create(int id_, const position_t& pos, const std::string& what_arg)
    {
        std::string w = exception::name("parse_error", id_) + "parse error" +
                        position_string(pos) + ": " + what_arg;
        return parse_error(id_, pos.chars_read_total, w.c_str());
    }

    static parse_error create(int id_, std::size_t byte_, const std::string& what_arg)
    {
        std::string w = exception::name("parse_error", id_) + "parse error" +
                        (byte_ != 0 ? (" at byte " + std::to_string(byte_)) : "") +
                        ": " + what_arg;
        return parse_error(id_, byte_, w.c_str());
    }

    /*!
    @brief byte index of the parse error

    The byte index of the last read character in the input file.

    @note For an input with n bytes, 1 is the index of the first character and
          n+1 is the index of the terminating null byte or the end of file.
          This also holds true when reading a byte vector (CBOR or MessagePack).
    */
    const std::size_t byte;

  private:
    parse_error(int id_, std::size_t byte_, const char* what_arg)
        : exception(id_, what_arg), byte(byte_) {}

    static std::string position_string(const position_t& pos)
    {
        return " at line " + std::to_string(pos.lines_read + 1) +
               ", column " + std::to_string(pos.chars_read_current_line);
    }
};

/*!
@brief exception indicating errors with iterators

This exception is thrown if iterators passed to a library function do not match
the expected semantics.

Exceptions have ids 2xx.

name / id                           | example message | description
----------------------------------- | --------------- | -------------------------
json.exception.invalid_iterator.201 | iterators are not compatible | The iterators passed to constructor @ref basic_json(InputIT first, InputIT last) are not compatible, meaning they do not belong to the same container. Therefore, the range (@a first, @a last) is invalid.
json.exception.invalid_iterator.202 | iterator does not fit current value | In an erase or insert function, the passed iterator @a pos does not belong to the JSON value for which the function was called. It hence does not define a valid position for the deletion/insertion.
json.exception.invalid_iterator.203 | iterators do not fit current value | Either iterator passed to function @ref erase(IteratorType first, IteratorType last) does not belong to the JSON value from which values shall be erased. It hence does not define a valid range to delete values from.
json.exception.invalid_iterator.204 | iterators out of range | When an iterator range for a primitive type (number, boolean, or string) is passed to a constructor or an erase function, this range has to be exactly (@ref begin(), @ref end()), because this is the only way the single stored value is expressed. All other ranges are invalid.
json.exception.invalid_iterator.205 | iterator out of range | When an iterator for a primitive type (number, boolean, or string) is passed to an erase function, the iterator has to be the @ref begin() iterator, because it is the only way to address the stored value. All other iterators are invalid.
json.exception.invalid_iterator.206 | cannot construct with iterators from null | The iterators passed to constructor @ref basic_json(InputIT first, InputIT last) belong to a JSON null value and hence to not define a valid range.
json.exception.invalid_iterator.207 | cannot use key() for non-object iterators | The key() member function can only be used on iterators belonging to a JSON object, because other types do not have a concept of a key.
json.exception.invalid_iterator.208 | cannot use operator[] for object iterators | The operator[] to specify a concrete offset cannot be used on iterators belonging to a JSON object, because JSON objects are unordered.
json.exception.invalid_iterator.209 | cannot use offsets with object iterators | The offset operators (+, -, +=, -=) cannot be used on iterators belonging to a JSON object, because JSON objects are unordered.
json.exception.invalid_iterator.210 | iterators do not fit | The iterator range passed to the insert function are not compatible, meaning they do not belong to the same container. Therefore, the range (@a first, @a last) is invalid.
json.exception.invalid_iterator.211 | passed iterators may not belong to container | The iterator range passed to the insert function must not be a subrange of the container to insert to.
json.exception.invalid_iterator.212 | cannot compare iterators of different containers | When two iterators are compared, they must belong to the same container.
json.exception.invalid_iterator.213 | cannot compare order of object iterators | The order of object iterators cannot be compared, because JSON objects are unordered.
json.exception.invalid_iterator.214 | cannot get value | Cannot get value for iterator: Either the iterator belongs to a null value or it is an iterator to a primitive type (number, boolean, or string), but the iterator is different to @ref begin().

@liveexample{The following code shows how an `invalid_iterator` exception can be
caught.,invalid_iterator}

@sa - @ref exception for the base class of the library exceptions
@sa - @ref parse_error for exceptions indicating a parse error
@sa - @ref type_error for exceptions indicating executing a member function with
                    a wrong type
@sa - @ref out_of_range for exceptions indicating access out of the defined range
@sa - @ref other_error for exceptions indicating other library errors

@since version 3.0.0
*/
class invalid_iterator : public exception
{
  public:
    static invalid_iterator create(int id_, const std::string& what_arg)
    {
        std::string w = exception::name("invalid_iterator", id_) + what_arg;
        return invalid_iterator(id_, w.c_str());
    }

  private:
    invalid_iterator(int id_, const char* what_arg)
        : exception(id_, what_arg) {}
};

/*!
@brief exception indicating executing a member function with a wrong type

This exception is thrown in case of a type error; that is, a library function is
executed on a JSON value whose type does not match the expected semantics.

Exceptions have ids 3xx.

name / id                     | example message | description
----------------------------- | --------------- | -------------------------
json.exception.type_error.301 | cannot create object from initializer list | To create an object from an initializer list, the initializer list must consist only of a list of pairs whose first element is a string. When this constraint is violated, an array is created instead.
json.exception.type_error.302 | type must be object, but is array | During implicit or explicit value conversion, the JSON type must be compatible to the target type. For instance, a JSON string can only be converted into string types, but not into numbers or boolean types.
json.exception.type_error.303 | incompatible ReferenceType for get_ref, actual type is object | To retrieve a reference to a value stored in a @ref basic_json object with @ref get_ref, the type of the reference must match the value type. For instance, for a JSON array, the @a ReferenceType must be @ref array_t &.
json.exception.type_error.304 | cannot use at() with string | The @ref at() member functions can only be executed for certain JSON types.
json.exception.type_error.305 | cannot use operator[] with string | The @ref operator[] member functions can only be executed for certain JSON types.
json.exception.type_error.306 | cannot use value() with string | The @ref value() member functions can only be executed for certain JSON types.
json.exception.type_error.307 | cannot use erase() with string | The @ref erase() member functions can only be executed for certain JSON types.
json.exception.type_error.308 | cannot use push_back() with string | The @ref push_back() and @ref operator+= member functions can only be executed for certain JSON types.
json.exception.type_error.309 | cannot use insert() with | The @ref insert() member functions can only be executed for certain JSON types.
json.exception.type_error.310 | cannot use swap() with number | The @ref swap() member functions can only be executed for certain JSON types.
json.exception.type_error.311 | cannot use emplace_back() with string | The @ref emplace_back() member function can only be executed for certain JSON types.
json.exception.type_error.312 | cannot use update() with string | The @ref update() member functions can only be executed for certain JSON types.
json.exception.type_error.313 | invalid value to unflatten | The @ref unflatten function converts an object whose keys are JSON Pointers back into an arbitrary nested JSON value. The JSON Pointers must not overlap, because then the resulting value would not be well defined.
json.exception.type_error.314 | only objects can be unflattened | The @ref unflatten function only works for an object whose keys are JSON Pointers.
json.exception.type_error.315 | values in object must be primitive | The @ref unflatten function only works for an object whose keys are JSON Pointers and whose values are primitive.
json.exception.type_error.316 | invalid UTF-8 byte at index 10: 0x7E | The @ref dump function only works with UTF-8 encoded strings; that is, if you assign a `std::string` to a JSON value, make sure it is UTF-8 encoded. |
json.exception.type_error.317 | JSON value cannot be serialized to requested format | The dynamic type of the object cannot be represented in the requested serialization format (e.g. a raw `true` or `null` JSON object cannot be serialized to BSON) |

@liveexample{The following code shows how a `type_error` exception can be
caught.,type_error}

@sa - @ref exception for the base class of the library exceptions
@sa - @ref parse_error for exceptions indicating a parse error
@sa - @ref invalid_iterator for exceptions indicating errors with iterators
@sa - @ref out_of_range for exceptions indicating access out of the defined range
@sa - @ref other_error for exceptions indicating other library errors

@since version 3.0.0
*/
class type_error : public exception
{
  public:
    static type_error create(int id_, const std::string& what_arg)
    {
        std::string w = exception::name("type_error", id_) + what_arg;
        return type_error(id_, w.c_str());
    }

  private:
    type_error(int id_, const char* what_arg) : exception(id_, what_arg) {}
};

/*!
@brief exception indicating access out of the defined range

This exception is thrown in case a library function is called on an input
parameter that exceeds the expected range, for instance in case of array
indices or nonexisting object keys.

Exceptions have ids 4xx.

name / id                       | example message | description
------------------------------- | --------------- | -------------------------
json.exception.out_of_range.401 | array index 3 is out of range | The provided array index @a i is larger than @a size-1.
json.exception.out_of_range.402 | array index '-' (3) is out of range | The special array index `-` in a JSON Pointer never describes a valid element of the array, but the index past the end. That is, it can only be used to add elements at this position, but not to read it.
json.exception.out_of_range.403 | key 'foo' not found | The provided key was not found in the JSON object.
json.exception.out_of_range.404 | unresolved reference token 'foo' | A reference token in a JSON Pointer could not be resolved.
json.exception.out_of_range.405 | JSON pointer has no parent | The JSON Patch operations 'remove' and 'add' can not be applied to the root element of the JSON value.
json.exception.out_of_range.406 | number overflow parsing '10E1000' | A parsed number could not be stored as without changing it to NaN or INF.
json.exception.out_of_range.407 | number overflow serializing '9223372036854775808' | UBJSON and BSON only support integer numbers up to 9223372036854775807. |
json.exception.out_of_range.408 | excessive array size: 8658170730974374167 | The size (following `#`) of an UBJSON array or object exceeds the maximal capacity. |
json.exception.out_of_range.409 | BSON key cannot contain code point U+0000 (at byte 2) | Key identifiers to be serialized to BSON cannot contain code point U+0000, since the key is stored as zero-terminated c-string |

@liveexample{The following code shows how an `out_of_range` exception can be
caught.,out_of_range}

@sa - @ref exception for the base class of the library exceptions
@sa - @ref parse_error for exceptions indicating a parse error
@sa - @ref invalid_iterator for exceptions indicating errors with iterators
@sa - @ref type_error for exceptions indicating executing a member function with
                    a wrong type
@sa - @ref other_error for exceptions indicating other library errors

@since version 3.0.0
*/
class out_of_range : public exception
{
  public:
    static out_of_range create(int id_, const std::string& what_arg)
    {
        std::string w = exception::name("out_of_range", id_) + what_arg;
        return out_of_range(id_, w.c_str());
    }

  private:
    out_of_range(int id_, const char* what_arg) : exception(id_, what_arg) {}
};

/*!
@brief exception indicating other library errors

This exception is thrown in case of errors that cannot be classified with the
other exception types.

Exceptions have ids 5xx.

name / id                      | example message | description
------------------------------ | --------------- | -------------------------
json.exception.other_error.501 | unsuccessful: {"op":"test","path":"/baz", "value":"bar"} | A JSON Patch operation 'test' failed. The unsuccessful operation is also printed.

@sa - @ref exception for the base class of the library exceptions
@sa - @ref parse_error for exceptions indicating a parse error
@sa - @ref invalid_iterator for exceptions indicating errors with iterators
@sa - @ref type_error for exceptions indicating executing a member function with
                    a wrong type
@sa - @ref out_of_range for exceptions indicating access out of the defined range

@liveexample{The following code shows how an `other_error` exception can be
caught.,other_error}

@since version 3.0.0
*/
class other_error : public exception
{
  public:
    static other_error create(int id_, const std::string& what_arg)
    {
        std::string w = exception::name("other_error", id_) + what_arg;
        return other_error(id_, w.c_str());
    }

  private:
    other_error(int id_, const char* what_arg) : exception(id_, what_arg) {}
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/macro_scope.hpp>


#include <utility> // pair

// This file contains all internal macro definitions
// You MUST include macro_unscope.hpp at the end of json.hpp to undef all of them

// exclude unsupported compilers
#if !defined(JSON_SKIP_UNSUPPORTED_COMPILER_CHECK)
    #if defined(__clang__)
        #if (__clang_major__ * 10000 + __clang_minor__ * 100 + __clang_patchlevel__) < 30400
            #error "unsupported Clang version - see https://github.com/nlohmann/json#supported-compilers"
        #endif
    #elif defined(__GNUC__) && !(defined(__ICC) || defined(__INTEL_COMPILER))
        #if (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__) < 40800
            #error "unsupported GCC version - see https://github.com/nlohmann/json#supported-compilers"
        #endif
    #endif
#endif

// disable float-equal warnings on GCC/clang
#if defined(__clang__) || defined(__GNUC__) || defined(__GNUG__)
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wfloat-equal"
#endif

// disable documentation warnings on clang
#if defined(__clang__)
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wdocumentation"
#endif

// allow for portable deprecation warnings
#if defined(__clang__) || defined(__GNUC__) || defined(__GNUG__)
    #define JSON_DEPRECATED __attribute__((deprecated))
#elif defined(_MSC_VER)
    #define JSON_DEPRECATED __declspec(deprecated)
#else
    #define JSON_DEPRECATED
#endif

// allow for portable nodiscard warnings
#if defined(__has_cpp_attribute)
    #if __has_cpp_attribute(nodiscard)
        #define JSON_NODISCARD [[nodiscard]]
    #elif __has_cpp_attribute(gnu::warn_unused_result)
        #define JSON_NODISCARD [[gnu::warn_unused_result]]
    #else
        #define JSON_NODISCARD
    #endif
#else
    #define JSON_NODISCARD
#endif

// allow to disable exceptions
#if (defined(__cpp_exceptions) || defined(__EXCEPTIONS) || defined(_CPPUNWIND)) && !defined(JSON_NOEXCEPTION)
    #define JSON_THROW(exception) throw exception
    #define JSON_TRY try
    #define JSON_CATCH(exception) catch(exception)
    #define JSON_INTERNAL_CATCH(exception) catch(exception)
#else
    #include <cstdlib>
    #define JSON_THROW(exception) std::abort()
    #define JSON_TRY if(true)
    #define JSON_CATCH(exception) if(false)
    #define JSON_INTERNAL_CATCH(exception) if(false)
#endif

// override exception macros
#if defined(JSON_THROW_USER)
    #undef JSON_THROW
    #define JSON_THROW JSON_THROW_USER
#endif
#if defined(JSON_TRY_USER)
    #undef JSON_TRY
    #define JSON_TRY JSON_TRY_USER
#endif
#if defined(JSON_CATCH_USER)
    #undef JSON_CATCH
    #define JSON_CATCH JSON_CATCH_USER
    #undef JSON_INTERNAL_CATCH
    #define JSON_INTERNAL_CATCH JSON_CATCH_USER
#endif
#if defined(JSON_INTERNAL_CATCH_USER)
    #undef JSON_INTERNAL_CATCH
    #define JSON_INTERNAL_CATCH JSON_INTERNAL_CATCH_USER
#endif

// manual branch prediction
#if defined(__clang__) || defined(__GNUC__) || defined(__GNUG__)
    #define JSON_LIKELY(x)      __builtin_expect(x, 1)
    #define JSON_UNLIKELY(x)    __builtin_expect(x, 0)
#else
    #define JSON_LIKELY(x)      x
    #define JSON_UNLIKELY(x)    x
#endif

// C++ language standard detection
#if (defined(__cplusplus) && __cplusplus >= 201703L) || (defined(_HAS_CXX17) && _HAS_CXX17 == 1) // fix for issue #464
    #define JSON_HAS_CPP_17
    #define JSON_HAS_CPP_14
#elif (defined(__cplusplus) && __cplusplus >= 201402L) || (defined(_HAS_CXX14) && _HAS_CXX14 == 1)
    #define JSON_HAS_CPP_14
#endif

/*!
@brief macro to briefly define a mapping between an enum and JSON
@def NLOHMANN_JSON_SERIALIZE_ENUM
@since version 3.4.0
*/
#define NLOHMANN_JSON_SERIALIZE_ENUM(ENUM_TYPE, ...)                                           \
    template<typename BasicJsonType>                                                           \
    inline void to_json(BasicJsonType& j, const ENUM_TYPE& e)                                  \
    {                                                                                          \
        static_assert(std::is_enum<ENUM_TYPE>::value, #ENUM_TYPE " must be an enum!");         \
        static const std::pair<ENUM_TYPE, BasicJsonType> m[] = __VA_ARGS__;                    \
        auto it = std::find_if(std::begin(m), std::end(m),                                     \
                               [e](const std::pair<ENUM_TYPE, BasicJsonType>& ej_pair) -> bool \
        {                                                                                      \
            return ej_pair.first == e;                                                         \
        });                                                                                    \
        j = ((it != std::end(m)) ? it : std::begin(m))->second;                                \
    }                                                                                          \
    template<typename BasicJsonType>                                                           \
    inline void from_json(const BasicJsonType& j, ENUM_TYPE& e)                                \
    {                                                                                          \
        static_assert(std::is_enum<ENUM_TYPE>::value, #ENUM_TYPE " must be an enum!");         \
        static const std::pair<ENUM_TYPE, BasicJsonType> m[] = __VA_ARGS__;                    \
        auto it = std::find_if(std::begin(m), std::end(m),                                     \
                               [j](const std::pair<ENUM_TYPE, BasicJsonType>& ej_pair) -> bool \
        {                                                                                      \
            return ej_pair.second == j;                                                        \
        });                                                                                    \
        e = ((it != std::end(m)) ? it : std::begin(m))->first;                                 \
    }

// Ugly macros to avoid uglier copy-paste when specializing basic_json. They
// may be removed in the future once the class is split.

#define NLOHMANN_BASIC_JSON_TPL_DECLARATION                                \
    template<template<typename, typename, typename...> class ObjectType,   \
             template<typename, typename...> class ArrayType,              \
             class StringType, class BooleanType, class NumberIntegerType, \
             class NumberUnsignedType, class NumberFloatType,              \
             template<typename> class AllocatorType,                       \
             template<typename, typename = void> class JSONSerializer>

#define NLOHMANN_BASIC_JSON_TPL                                            \
    basic_json<ObjectType, ArrayType, StringType, BooleanType,             \
    NumberIntegerType, NumberUnsignedType, NumberFloatType,                \
    AllocatorType, JSONSerializer>

// #include <nlohmann/detail/meta/cpp_future.hpp>


#include <ciso646> // not
#include <cstddef> // size_t
#include <type_traits> // conditional, enable_if, false_type, integral_constant, is_constructible, is_integral, is_same, remove_cv, remove_reference, true_type

namespace nlohmann
{
namespace detail
{
// alias templates to reduce boilerplate
template<bool B, typename T = void>
using enable_if_t = typename std::enable_if<B, T>::type;

template<typename T>
using uncvref_t = typename std::remove_cv<typename std::remove_reference<T>::type>::type;

// implementation of C++14 index_sequence and affiliates
// source: https://stackoverflow.com/a/32223343
template<std::size_t... Ints>
struct index_sequence
{
    using type = index_sequence;
    using value_type = std::size_t;
    static constexpr std::size_t size() noexcept
    {
        return sizeof...(Ints);
    }
};

template<class Sequence1, class Sequence2>
struct merge_and_renumber;

template<std::size_t... I1, std::size_t... I2>
struct merge_and_renumber<index_sequence<I1...>, index_sequence<I2...>>
        : index_sequence < I1..., (sizeof...(I1) + I2)... > {};

template<std::size_t N>
struct make_index_sequence
    : merge_and_renumber < typename make_index_sequence < N / 2 >::type,
      typename make_index_sequence < N - N / 2 >::type > {};

template<> struct make_index_sequence<0> : index_sequence<> {};
template<> struct make_index_sequence<1> : index_sequence<0> {};

template<typename... Ts>
using index_sequence_for = make_index_sequence<sizeof...(Ts)>;

// dispatch utility (taken from ranges-v3)
template<unsigned N> struct priority_tag : priority_tag < N - 1 > {};
template<> struct priority_tag<0> {};

// taken from ranges-v3
template<typename T>
struct static_const
{
    static constexpr T value{};
};

template<typename T>
constexpr T static_const<T>::value;
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/meta/type_traits.hpp>


#include <ciso646> // not
#include <limits> // numeric_limits
#include <type_traits> // false_type, is_constructible, is_integral, is_same, true_type
#include <utility> // declval

// #include <nlohmann/detail/iterators/iterator_traits.hpp>


#include <iterator> // random_access_iterator_tag

// #include <nlohmann/detail/meta/void_t.hpp>


namespace nlohmann
{
namespace detail
{
template <typename ...Ts> struct make_void
{
    using type = void;
};
template <typename ...Ts> using void_t = typename make_void<Ts...>::type;
} // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/meta/cpp_future.hpp>


namespace nlohmann
{
namespace detail
{
template <typename It, typename = void>
struct iterator_types {};

template <typename It>
struct iterator_types <
    It,
    void_t<typename It::difference_type, typename It::value_type, typename It::pointer,
    typename It::reference, typename It::iterator_category >>
{
    using difference_type = typename It::difference_type;
    using value_type = typename It::value_type;
    using pointer = typename It::pointer;
    using reference = typename It::reference;
    using iterator_category = typename It::iterator_category;
};

// This is required as some compilers implement std::iterator_traits in a way that
// doesn't work with SFINAE. See https://github.com/nlohmann/json/issues/1341.
template <typename T, typename = void>
struct iterator_traits
{
};

template <typename T>
struct iterator_traits < T, enable_if_t < !std::is_pointer<T>::value >>
            : iterator_types<T>
{
};

template <typename T>
struct iterator_traits<T*, enable_if_t<std::is_object<T>::value>>
{
    using iterator_category = std::random_access_iterator_tag;
    using value_type = T;
    using difference_type = ptrdiff_t;
    using pointer = T*;
    using reference = T&;
};
} // namespace detail
} // namespace nlohmann

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/meta/detected.hpp>


#include <type_traits>

// #include <nlohmann/detail/meta/void_t.hpp>


// http://en.cppreference.com/w/cpp/experimental/is_detected
namespace nlohmann
{
namespace detail
{
struct nonesuch
{
    nonesuch() = delete;
    ~nonesuch() = delete;
    nonesuch(nonesuch const&) = delete;
    nonesuch(nonesuch const&&) = delete;
    void operator=(nonesuch const&) = delete;
    void operator=(nonesuch&&) = delete;
};

template <class Default,
          class AlwaysVoid,
          template <class...> class Op,
          class... Args>
struct detector
{
    using value_t = std::false_type;
    using type = Default;
};

template <class Default, template <class...> class Op, class... Args>
struct detector<Default, void_t<Op<Args...>>, Op, Args...>
{
    using value_t = std::true_type;
    using type = Op<Args...>;
};

template <template <class...> class Op, class... Args>
using is_detected = typename detector<nonesuch, void, Op, Args...>::value_t;

template <template <class...> class Op, class... Args>
using detected_t = typename detector<nonesuch, void, Op, Args...>::type;

template <class Default, template <class...> class Op, class... Args>
using detected_or = detector<Default, void, Op, Args...>;

template <class Default, template <class...> class Op, class... Args>
using detected_or_t = typename detected_or<Default, Op, Args...>::type;

template <class Expected, template <class...> class Op, class... Args>
using is_detected_exact = std::is_same<Expected, detected_t<Op, Args...>>;

template <class To, template <class...> class Op, class... Args>
using is_detected_convertible =
    std::is_convertible<detected_t<Op, Args...>, To>;
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/json_fwd.hpp>
#ifndef INCLUDE_NLOHMANN_JSON_FWD_HPP_
#define INCLUDE_NLOHMANN_JSON_FWD_HPP_

#include <cstdint> // int64_t, uint64_t
#include <map> // map
#include <memory> // allocator
#include <string> // string
#include <vector> // vector

/*!
@brief namespace for Niels Lohmann
@see https://github.com/nlohmann
@since version 1.0.0
*/
namespace nlohmann
{
/*!
@brief default JSONSerializer template argument

This serializer ignores the template arguments and uses ADL
([argument-dependent lookup](https://en.cppreference.com/w/cpp/language/adl))
for serialization.
*/
template<typename T = void, typename SFINAE = void>
struct adl_serializer;

template<template<typename U, typename V, typename... Args> class ObjectType =
         std::map,
         template<typename U, typename... Args> class ArrayType = std::vector,
         class StringType = std::string, class BooleanType = bool,
         class NumberIntegerType = std::int64_t,
         class NumberUnsignedType = std::uint64_t,
         class NumberFloatType = double,
         template<typename U> class AllocatorType = std::allocator,
         template<typename T, typename SFINAE = void> class JSONSerializer =
         adl_serializer>
class basic_json;

/*!
@brief JSON Pointer

A JSON pointer defines a string syntax for identifying a specific value
within a JSON document. It can be used with functions `at` and
`operator[]`. Furthermore, JSON pointers are the base for JSON patches.

@sa [RFC 6901](https://tools.ietf.org/html/rfc6901)

@since version 2.0.0
*/
template<typename BasicJsonType>
class json_pointer;

/*!
@brief default JSON class

This type is the default specialization of the @ref basic_json class which
uses the standard template types.

@since version 1.0.0
*/
using json = basic_json<>;
}  // namespace nlohmann

#endif  // INCLUDE_NLOHMANN_JSON_FWD_HPP_


namespace nlohmann
{
/*!
@brief detail namespace with internal helper functions

This namespace collects functions that should not be exposed,
implementations of some @ref basic_json methods, and meta-programming helpers.

@since version 2.1.0
*/
namespace detail
{
/////////////
// helpers //
/////////////

// Note to maintainers:
//
// Every trait in this file expects a non CV-qualified type.
// The only exceptions are in the 'aliases for detected' section
// (i.e. those of the form: decltype(T::member_function(std::declval<T>())))
//
// In this case, T has to be properly CV-qualified to constraint the function arguments
// (e.g. to_json(BasicJsonType&, const T&))

template<typename> struct is_basic_json : std::false_type {};

NLOHMANN_BASIC_JSON_TPL_DECLARATION
struct is_basic_json<NLOHMANN_BASIC_JSON_TPL> : std::true_type {};

//////////////////////////
// aliases for detected //
//////////////////////////

template <typename T>
using mapped_type_t = typename T::mapped_type;

template <typename T>
using key_type_t = typename T::key_type;

template <typename T>
using value_type_t = typename T::value_type;

template <typename T>
using difference_type_t = typename T::difference_type;

template <typename T>
using pointer_t = typename T::pointer;

template <typename T>
using reference_t = typename T::reference;

template <typename T>
using iterator_category_t = typename T::iterator_category;

template <typename T>
using iterator_t = typename T::iterator;

template <typename T, typename... Args>
using to_json_function = decltype(T::to_json(std::declval<Args>()...));

template <typename T, typename... Args>
using from_json_function = decltype(T::from_json(std::declval<Args>()...));

template <typename T, typename U>
using get_template_function = decltype(std::declval<T>().template get<U>());

// trait checking if JSONSerializer<T>::from_json(json const&, udt&) exists
template <typename BasicJsonType, typename T, typename = void>
struct has_from_json : std::false_type {};

template <typename BasicJsonType, typename T>
struct has_from_json<BasicJsonType, T,
           enable_if_t<not is_basic_json<T>::value>>
{
    using serializer = typename BasicJsonType::template json_serializer<T, void>;

    static constexpr bool value =
        is_detected_exact<void, from_json_function, serializer,
        const BasicJsonType&, T&>::value;
};

// This trait checks if JSONSerializer<T>::from_json(json const&) exists
// this overload is used for non-default-constructible user-defined-types
template <typename BasicJsonType, typename T, typename = void>
struct has_non_default_from_json : std::false_type {};

template<typename BasicJsonType, typename T>
struct has_non_default_from_json<BasicJsonType, T, enable_if_t<not is_basic_json<T>::value>>
{
    using serializer = typename BasicJsonType::template json_serializer<T, void>;

    static constexpr bool value =
        is_detected_exact<T, from_json_function, serializer,
        const BasicJsonType&>::value;
};

// This trait checks if BasicJsonType::json_serializer<T>::to_json exists
// Do not evaluate the trait when T is a basic_json type, to avoid template instantiation infinite recursion.
template <typename BasicJsonType, typename T, typename = void>
struct has_to_json : std::false_type {};

template <typename BasicJsonType, typename T>
struct has_to_json<BasicJsonType, T, enable_if_t<not is_basic_json<T>::value>>
{
    using serializer = typename BasicJsonType::template json_serializer<T, void>;

    static constexpr bool value =
        is_detected_exact<void, to_json_function, serializer, BasicJsonType&,
        T>::value;
};


///////////////////
// is_ functions //
///////////////////

template <typename T, typename = void>
struct is_iterator_traits : std::false_type {};

template <typename T>
struct is_iterator_traits<iterator_traits<T>>
{
  private:
    using traits = iterator_traits<T>;

  public:
    static constexpr auto value =
        is_detected<value_type_t, traits>::value &&
        is_detected<difference_type_t, traits>::value &&
        is_detected<pointer_t, traits>::value &&
        is_detected<iterator_category_t, traits>::value &&
        is_detected<reference_t, traits>::value;
};

// source: https://stackoverflow.com/a/37193089/4116453

template <typename T, typename = void>
struct is_complete_type : std::false_type {};

template <typename T>
struct is_complete_type<T, decltype(void(sizeof(T)))> : std::true_type {};

template <typename BasicJsonType, typename CompatibleObjectType,
          typename = void>
struct is_compatible_object_type_impl : std::false_type {};

template <typename BasicJsonType, typename CompatibleObjectType>
struct is_compatible_object_type_impl <
    BasicJsonType, CompatibleObjectType,
    enable_if_t<is_detected<mapped_type_t, CompatibleObjectType>::value and
    is_detected<key_type_t, CompatibleObjectType>::value >>
{

    using object_t = typename BasicJsonType::object_t;

    // macOS's is_constructible does not play well with nonesuch...
    static constexpr bool value =
        std::is_constructible<typename object_t::key_type,
        typename CompatibleObjectType::key_type>::value and
        std::is_constructible<typename object_t::mapped_type,
        typename CompatibleObjectType::mapped_type>::value;
};

template <typename BasicJsonType, typename CompatibleObjectType>
struct is_compatible_object_type
    : is_compatible_object_type_impl<BasicJsonType, CompatibleObjectType> {};

template <typename BasicJsonType, typename ConstructibleObjectType,
          typename = void>
struct is_constructible_object_type_impl : std::false_type {};

template <typename BasicJsonType, typename ConstructibleObjectType>
struct is_constructible_object_type_impl <
    BasicJsonType, ConstructibleObjectType,
    enable_if_t<is_detected<mapped_type_t, ConstructibleObjectType>::value and
    is_detected<key_type_t, ConstructibleObjectType>::value >>
{
    using object_t = typename BasicJsonType::object_t;

    static constexpr bool value =
        (std::is_constructible<typename ConstructibleObjectType::key_type, typename object_t::key_type>::value and
         std::is_same<typename object_t::mapped_type, typename ConstructibleObjectType::mapped_type>::value) or
        (has_from_json<BasicJsonType, typename ConstructibleObjectType::mapped_type>::value or
         has_non_default_from_json<BasicJsonType, typename ConstructibleObjectType::mapped_type >::value);
};

template <typename BasicJsonType, typename ConstructibleObjectType>
struct is_constructible_object_type
    : is_constructible_object_type_impl<BasicJsonType,
      ConstructibleObjectType> {};

template <typename BasicJsonType, typename CompatibleStringType,
          typename = void>
struct is_compatible_string_type_impl : std::false_type {};

template <typename BasicJsonType, typename CompatibleStringType>
struct is_compatible_string_type_impl <
    BasicJsonType, CompatibleStringType,
    enable_if_t<is_detected_exact<typename BasicJsonType::string_t::value_type,
    value_type_t, CompatibleStringType>::value >>
{
    static constexpr auto value =
        std::is_constructible<typename BasicJsonType::string_t, CompatibleStringType>::value;
};

template <typename BasicJsonType, typename ConstructibleStringType>
struct is_compatible_string_type
    : is_compatible_string_type_impl<BasicJsonType, ConstructibleStringType> {};

template <typename BasicJsonType, typename ConstructibleStringType,
          typename = void>
struct is_constructible_string_type_impl : std::false_type {};

template <typename BasicJsonType, typename ConstructibleStringType>
struct is_constructible_string_type_impl <
    BasicJsonType, ConstructibleStringType,
    enable_if_t<is_detected_exact<typename BasicJsonType::string_t::value_type,
    value_type_t, ConstructibleStringType>::value >>
{
    static constexpr auto value =
        std::is_constructible<ConstructibleStringType,
        typename BasicJsonType::string_t>::value;
};

template <typename BasicJsonType, typename ConstructibleStringType>
struct is_constructible_string_type
    : is_constructible_string_type_impl<BasicJsonType, ConstructibleStringType> {};

template <typename BasicJsonType, typename CompatibleArrayType, typename = void>
struct is_compatible_array_type_impl : std::false_type {};

template <typename BasicJsonType, typename CompatibleArrayType>
struct is_compatible_array_type_impl <
    BasicJsonType, CompatibleArrayType,
    enable_if_t<is_detected<value_type_t, CompatibleArrayType>::value and
    is_detected<iterator_t, CompatibleArrayType>::value and
// This is needed because json_reverse_iterator has a ::iterator type...
// Therefore it is detected as a CompatibleArrayType.
// The real fix would be to have an Iterable concept.
    not is_iterator_traits<
    iterator_traits<CompatibleArrayType>>::value >>
{
    static constexpr bool value =
        std::is_constructible<BasicJsonType,
        typename CompatibleArrayType::value_type>::value;
};

template <typename BasicJsonType, typename CompatibleArrayType>
struct is_compatible_array_type
    : is_compatible_array_type_impl<BasicJsonType, CompatibleArrayType> {};

template <typename BasicJsonType, typename ConstructibleArrayType, typename = void>
struct is_constructible_array_type_impl : std::false_type {};

template <typename BasicJsonType, typename ConstructibleArrayType>
struct is_constructible_array_type_impl <
    BasicJsonType, ConstructibleArrayType,
    enable_if_t<std::is_same<ConstructibleArrayType,
    typename BasicJsonType::value_type>::value >>
            : std::true_type {};

template <typename BasicJsonType, typename ConstructibleArrayType>
struct is_constructible_array_type_impl <
    BasicJsonType, ConstructibleArrayType,
    enable_if_t<not std::is_same<ConstructibleArrayType,
    typename BasicJsonType::value_type>::value and
    is_detected<value_type_t, ConstructibleArrayType>::value and
    is_detected<iterator_t, ConstructibleArrayType>::value and
    is_complete_type<
    detected_t<value_type_t, ConstructibleArrayType>>::value >>
{
    static constexpr bool value =
        // This is needed because json_reverse_iterator has a ::iterator type,
        // furthermore, std::back_insert_iterator (and other iterators) have a base class `iterator`...
        // Therefore it is detected as a ConstructibleArrayType.
        // The real fix would be to have an Iterable concept.
        not is_iterator_traits <
        iterator_traits<ConstructibleArrayType >>::value and

        (std::is_same<typename ConstructibleArrayType::value_type, typename BasicJsonType::array_t::value_type>::value or
         has_from_json<BasicJsonType,
         typename ConstructibleArrayType::value_type>::value or
         has_non_default_from_json <
         BasicJsonType, typename ConstructibleArrayType::value_type >::value);
};

template <typename BasicJsonType, typename ConstructibleArrayType>
struct is_constructible_array_type
    : is_constructible_array_type_impl<BasicJsonType, ConstructibleArrayType> {};

template <typename RealIntegerType, typename CompatibleNumberIntegerType,
          typename = void>
struct is_compatible_integer_type_impl : std::false_type {};

template <typename RealIntegerType, typename CompatibleNumberIntegerType>
struct is_compatible_integer_type_impl <
    RealIntegerType, CompatibleNumberIntegerType,
    enable_if_t<std::is_integral<RealIntegerType>::value and
    std::is_integral<CompatibleNumberIntegerType>::value and
    not std::is_same<bool, CompatibleNumberIntegerType>::value >>
{
    // is there an assert somewhere on overflows?
    using RealLimits = std::numeric_limits<RealIntegerType>;
    using CompatibleLimits = std::numeric_limits<CompatibleNumberIntegerType>;

    static constexpr auto value =
        std::is_constructible<RealIntegerType,
        CompatibleNumberIntegerType>::value and
        CompatibleLimits::is_integer and
        RealLimits::is_signed == CompatibleLimits::is_signed;
};

template <typename RealIntegerType, typename CompatibleNumberIntegerType>
struct is_compatible_integer_type
    : is_compatible_integer_type_impl<RealIntegerType,
      CompatibleNumberIntegerType> {};

template <typename BasicJsonType, typename CompatibleType, typename = void>
struct is_compatible_type_impl: std::false_type {};

template <typename BasicJsonType, typename CompatibleType>
struct is_compatible_type_impl <
    BasicJsonType, CompatibleType,
    enable_if_t<is_complete_type<CompatibleType>::value >>
{
    static constexpr bool value =
        has_to_json<BasicJsonType, CompatibleType>::value;
};

template <typename BasicJsonType, typename CompatibleType>
struct is_compatible_type
    : is_compatible_type_impl<BasicJsonType, CompatibleType> {};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/value_t.hpp>


#include <array> // array
#include <ciso646> // and
#include <cstddef> // size_t
#include <cstdint> // uint8_t
#include <string> // string

namespace nlohmann
{
namespace detail
{
///////////////////////////
// JSON type enumeration //
///////////////////////////

/*!
@brief the JSON type enumeration

This enumeration collects the different JSON types. It is internally used to
distinguish the stored values, and the functions @ref basic_json::is_null(),
@ref basic_json::is_object(), @ref basic_json::is_array(),
@ref basic_json::is_string(), @ref basic_json::is_boolean(),
@ref basic_json::is_number() (with @ref basic_json::is_number_integer(),
@ref basic_json::is_number_unsigned(), and @ref basic_json::is_number_float()),
@ref basic_json::is_discarded(), @ref basic_json::is_primitive(), and
@ref basic_json::is_structured() rely on it.

@note There are three enumeration entries (number_integer, number_unsigned, and
number_float), because the library distinguishes these three types for numbers:
@ref basic_json::number_unsigned_t is used for unsigned integers,
@ref basic_json::number_integer_t is used for signed integers, and
@ref basic_json::number_float_t is used for floating-point numbers or to
approximate integers which do not fit in the limits of their respective type.

@sa @ref basic_json::basic_json(const value_t value_type) -- create a JSON
value with the default value for a given type

@since version 1.0.0
*/
enum class value_t : std::uint8_t
{
    null,             ///< null value
    object,           ///< object (unordered set of name/value pairs)
    array,            ///< array (ordered collection of values)
    string,           ///< string value
    boolean,          ///< boolean value
    number_integer,   ///< number value (signed integer)
    number_unsigned,  ///< number value (unsigned integer)
    number_float,     ///< number value (floating-point)
    discarded         ///< discarded by the the parser callback function
};

/*!
@brief comparison operator for JSON types

Returns an ordering that is similar to Python:
- order: null < boolean < number < object < array < string
- furthermore, each type is not smaller than itself
- discarded values are not comparable

@since version 1.0.0
*/
inline bool operator<(const value_t lhs, const value_t rhs) noexcept
{
    static constexpr std::array<std::uint8_t, 8> order = {{
            0 /* null */, 3 /* object */, 4 /* array */, 5 /* string */,
            1 /* boolean */, 2 /* integer */, 2 /* unsigned */, 2 /* float */
        }
    };

    const auto l_index = static_cast<std::size_t>(lhs);
    const auto r_index = static_cast<std::size_t>(rhs);
    return l_index < order.size() and r_index < order.size() and order[l_index] < order[r_index];
}
}  // namespace detail
}  // namespace nlohmann


namespace nlohmann
{
namespace detail
{
template<typename BasicJsonType>
void from_json(const BasicJsonType& j, typename std::nullptr_t& n)
{
    if (JSON_UNLIKELY(not j.is_null()))
    {
        JSON_THROW(type_error::create(302, "type must be null, but is " + std::string(j.type_name())));
    }
    n = nullptr;
}

// overloads for basic_json template parameters
template<typename BasicJsonType, typename ArithmeticType,
         enable_if_t<std::is_arithmetic<ArithmeticType>::value and
                     not std::is_same<ArithmeticType, typename BasicJsonType::boolean_t>::value,
                     int> = 0>
void get_arithmetic_value(const BasicJsonType& j, ArithmeticType& val)
{
    switch (static_cast<value_t>(j))
    {
        case value_t::number_unsigned:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_unsigned_t*>());
            break;
        }
        case value_t::number_integer:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_integer_t*>());
            break;
        }
        case value_t::number_float:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_float_t*>());
            break;
        }

        default:
            JSON_THROW(type_error::create(302, "type must be number, but is " + std::string(j.type_name())));
    }
}

template<typename BasicJsonType>
void from_json(const BasicJsonType& j, typename BasicJsonType::boolean_t& b)
{
    if (JSON_UNLIKELY(not j.is_boolean()))
    {
        JSON_THROW(type_error::create(302, "type must be boolean, but is " + std::string(j.type_name())));
    }
    b = *j.template get_ptr<const typename BasicJsonType::boolean_t*>();
}

template<typename BasicJsonType>
void from_json(const BasicJsonType& j, typename BasicJsonType::string_t& s)
{
    if (JSON_UNLIKELY(not j.is_string()))
    {
        JSON_THROW(type_error::create(302, "type must be string, but is " + std::string(j.type_name())));
    }
    s = *j.template get_ptr<const typename BasicJsonType::string_t*>();
}

template <
    typename BasicJsonType, typename ConstructibleStringType,
    enable_if_t <
        is_constructible_string_type<BasicJsonType, ConstructibleStringType>::value and
        not std::is_same<typename BasicJsonType::string_t,
                         ConstructibleStringType>::value,
        int > = 0 >
void from_json(const BasicJsonType& j, ConstructibleStringType& s)
{
    if (JSON_UNLIKELY(not j.is_string()))
    {
        JSON_THROW(type_error::create(302, "type must be string, but is " + std::string(j.type_name())));
    }

    s = *j.template get_ptr<const typename BasicJsonType::string_t*>();
}

template<typename BasicJsonType>
void from_json(const BasicJsonType& j, typename BasicJsonType::number_float_t& val)
{
    get_arithmetic_value(j, val);
}

template<typename BasicJsonType>
void from_json(const BasicJsonType& j, typename BasicJsonType::number_unsigned_t& val)
{
    get_arithmetic_value(j, val);
}

template<typename BasicJsonType>
void from_json(const BasicJsonType& j, typename BasicJsonType::number_integer_t& val)
{
    get_arithmetic_value(j, val);
}

template<typename BasicJsonType, typename EnumType,
         enable_if_t<std::is_enum<EnumType>::value, int> = 0>
void from_json(const BasicJsonType& j, EnumType& e)
{
    typename std::underlying_type<EnumType>::type val;
    get_arithmetic_value(j, val);
    e = static_cast<EnumType>(val);
}

// forward_list doesn't have an insert method
template<typename BasicJsonType, typename T, typename Allocator,
         enable_if_t<std::is_convertible<BasicJsonType, T>::value, int> = 0>
void from_json(const BasicJsonType& j, std::forward_list<T, Allocator>& l)
{
    if (JSON_UNLIKELY(not j.is_array()))
    {
        JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(j.type_name())));
    }
    std::transform(j.rbegin(), j.rend(),
                   std::front_inserter(l), [](const BasicJsonType & i)
    {
        return i.template get<T>();
    });
}

// valarray doesn't have an insert method
template<typename BasicJsonType, typename T,
         enable_if_t<std::is_convertible<BasicJsonType, T>::value, int> = 0>
void from_json(const BasicJsonType& j, std::valarray<T>& l)
{
    if (JSON_UNLIKELY(not j.is_array()))
    {
        JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(j.type_name())));
    }
    l.resize(j.size());
    std::copy(j.m_value.array->begin(), j.m_value.array->end(), std::begin(l));
}

template<typename BasicJsonType>
void from_json_array_impl(const BasicJsonType& j, typename BasicJsonType::array_t& arr, priority_tag<3> /*unused*/)
{
    arr = *j.template get_ptr<const typename BasicJsonType::array_t*>();
}

template <typename BasicJsonType, typename T, std::size_t N>
auto from_json_array_impl(const BasicJsonType& j, std::array<T, N>& arr,
                          priority_tag<2> /*unused*/)
-> decltype(j.template get<T>(), void())
{
    for (std::size_t i = 0; i < N; ++i)
    {
        arr[i] = j.at(i).template get<T>();
    }
}

template<typename BasicJsonType, typename ConstructibleArrayType>
auto from_json_array_impl(const BasicJsonType& j, ConstructibleArrayType& arr, priority_tag<1> /*unused*/)
-> decltype(
    arr.reserve(std::declval<typename ConstructibleArrayType::size_type>()),
    j.template get<typename ConstructibleArrayType::value_type>(),
    void())
{
    using std::end;

    arr.reserve(j.size());
    std::transform(j.begin(), j.end(),
                   std::inserter(arr, end(arr)), [](const BasicJsonType & i)
    {
        // get<BasicJsonType>() returns *this, this won't call a from_json
        // method when value_type is BasicJsonType
        return i.template get<typename ConstructibleArrayType::value_type>();
    });
}

template <typename BasicJsonType, typename ConstructibleArrayType>
void from_json_array_impl(const BasicJsonType& j, ConstructibleArrayType& arr,
                          priority_tag<0> /*unused*/)
{
    using std::end;

    std::transform(
        j.begin(), j.end(), std::inserter(arr, end(arr)),
        [](const BasicJsonType & i)
    {
        // get<BasicJsonType>() returns *this, this won't call a from_json
        // method when value_type is BasicJsonType
        return i.template get<typename ConstructibleArrayType::value_type>();
    });
}

template <typename BasicJsonType, typename ConstructibleArrayType,
          enable_if_t <
              is_constructible_array_type<BasicJsonType, ConstructibleArrayType>::value and
              not is_constructible_object_type<BasicJsonType, ConstructibleArrayType>::value and
              not is_constructible_string_type<BasicJsonType, ConstructibleArrayType>::value and
              not is_basic_json<ConstructibleArrayType>::value,
              int > = 0 >

auto from_json(const BasicJsonType& j, ConstructibleArrayType& arr)
-> decltype(from_json_array_impl(j, arr, priority_tag<3> {}),
j.template get<typename ConstructibleArrayType::value_type>(),
void())
{
    if (JSON_UNLIKELY(not j.is_array()))
    {
        JSON_THROW(type_error::create(302, "type must be array, but is " +
                                      std::string(j.type_name())));
    }

    from_json_array_impl(j, arr, priority_tag<3> {});
}

template<typename BasicJsonType, typename ConstructibleObjectType,
         enable_if_t<is_constructible_object_type<BasicJsonType, ConstructibleObjectType>::value, int> = 0>
void from_json(const BasicJsonType& j, ConstructibleObjectType& obj)
{
    if (JSON_UNLIKELY(not j.is_object()))
    {
        JSON_THROW(type_error::create(302, "type must be object, but is " + std::string(j.type_name())));
    }

    auto inner_object = j.template get_ptr<const typename BasicJsonType::object_t*>();
    using value_type = typename ConstructibleObjectType::value_type;
    std::transform(
        inner_object->begin(), inner_object->end(),
        std::inserter(obj, obj.begin()),
        [](typename BasicJsonType::object_t::value_type const & p)
    {
        return value_type(p.first, p.second.template get<typename ConstructibleObjectType::mapped_type>());
    });
}

// overload for arithmetic types, not chosen for basic_json template arguments
// (BooleanType, etc..); note: Is it really necessary to provide explicit
// overloads for boolean_t etc. in case of a custom BooleanType which is not
// an arithmetic type?
template<typename BasicJsonType, typename ArithmeticType,
         enable_if_t <
             std::is_arithmetic<ArithmeticType>::value and
             not std::is_same<ArithmeticType, typename BasicJsonType::number_unsigned_t>::value and
             not std::is_same<ArithmeticType, typename BasicJsonType::number_integer_t>::value and
             not std::is_same<ArithmeticType, typename BasicJsonType::number_float_t>::value and
             not std::is_same<ArithmeticType, typename BasicJsonType::boolean_t>::value,
             int> = 0>
void from_json(const BasicJsonType& j, ArithmeticType& val)
{
    switch (static_cast<value_t>(j))
    {
        case value_t::number_unsigned:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_unsigned_t*>());
            break;
        }
        case value_t::number_integer:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_integer_t*>());
            break;
        }
        case value_t::number_float:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_float_t*>());
            break;
        }
        case value_t::boolean:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::boolean_t*>());
            break;
        }

        default:
            JSON_THROW(type_error::create(302, "type must be number, but is " + std::string(j.type_name())));
    }
}

template<typename BasicJsonType, typename A1, typename A2>
void from_json(const BasicJsonType& j, std::pair<A1, A2>& p)
{
    p = {j.at(0).template get<A1>(), j.at(1).template get<A2>()};
}

template<typename BasicJsonType, typename Tuple, std::size_t... Idx>
void from_json_tuple_impl(const BasicJsonType& j, Tuple& t, index_sequence<Idx...> /*unused*/)
{
    t = std::make_tuple(j.at(Idx).template get<typename std::tuple_element<Idx, Tuple>::type>()...);
}

template<typename BasicJsonType, typename... Args>
void from_json(const BasicJsonType& j, std::tuple<Args...>& t)
{
    from_json_tuple_impl(j, t, index_sequence_for<Args...> {});
}

template <typename BasicJsonType, typename Key, typename Value, typename Compare, typename Allocator,
          typename = enable_if_t<not std::is_constructible<
                                     typename BasicJsonType::string_t, Key>::value>>
void from_json(const BasicJsonType& j, std::map<Key, Value, Compare, Allocator>& m)
{
    if (JSON_UNLIKELY(not j.is_array()))
    {
        JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(j.type_name())));
    }
    for (const auto& p : j)
    {
        if (JSON_UNLIKELY(not p.is_array()))
        {
            JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(p.type_name())));
        }
        m.emplace(p.at(0).template get<Key>(), p.at(1).template get<Value>());
    }
}

template <typename BasicJsonType, typename Key, typename Value, typename Hash, typename KeyEqual, typename Allocator,
          typename = enable_if_t<not std::is_constructible<
                                     typename BasicJsonType::string_t, Key>::value>>
void from_json(const BasicJsonType& j, std::unordered_map<Key, Value, Hash, KeyEqual, Allocator>& m)
{
    if (JSON_UNLIKELY(not j.is_array()))
    {
        JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(j.type_name())));
    }
    for (const auto& p : j)
    {
        if (JSON_UNLIKELY(not p.is_array()))
        {
            JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(p.type_name())));
        }
        m.emplace(p.at(0).template get<Key>(), p.at(1).template get<Value>());
    }
}

struct from_json_fn
{
    template<typename BasicJsonType, typename T>
    auto operator()(const BasicJsonType& j, T& val) const
    noexcept(noexcept(from_json(j, val)))
    -> decltype(from_json(j, val), void())
    {
        return from_json(j, val);
    }
};
}  // namespace detail

/// namespace to hold default `from_json` function
/// to see why this is required:
/// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4381.html
namespace
{
constexpr const auto& from_json = detail::static_const<detail::from_json_fn>::value;
} // namespace
}  // namespace nlohmann

// #include <nlohmann/detail/conversions/to_json.hpp>


#include <algorithm> // copy
#include <ciso646> // or, and, not
#include <iterator> // begin, end
#include <string> // string
#include <tuple> // tuple, get
#include <type_traits> // is_same, is_constructible, is_floating_point, is_enum, underlying_type
#include <utility> // move, forward, declval, pair
#include <valarray> // valarray
#include <vector> // vector

// #include <nlohmann/detail/iterators/iteration_proxy.hpp>


#include <cstddef> // size_t
#include <iterator> // input_iterator_tag
#include <string> // string, to_string
#include <tuple> // tuple_size, get, tuple_element

// #include <nlohmann/detail/meta/type_traits.hpp>

// #include <nlohmann/detail/value_t.hpp>


namespace nlohmann
{
namespace detail
{
template <typename IteratorType> class iteration_proxy_value
{
  public:
    using difference_type = std::ptrdiff_t;
    using value_type = iteration_proxy_value;
    using pointer = value_type * ;
    using reference = value_type & ;
    using iterator_category = std::input_iterator_tag;

  private:
    /// the iterator
    IteratorType anchor;
    /// an index for arrays (used to create key names)
    std::size_t array_index = 0;
    /// last stringified array index
    mutable std::size_t array_index_last = 0;
    /// a string representation of the array index
    mutable std::string array_index_str = "0";
    /// an empty string (to return a reference for primitive values)
    const std::string empty_str = "";

  public:
    explicit iteration_proxy_value(IteratorType it) noexcept : anchor(it) {}

    /// dereference operator (needed for range-based for)
    iteration_proxy_value& operator*()
    {
        return *this;
    }

    /// increment operator (needed for range-based for)
    iteration_proxy_value& operator++()
    {
        ++anchor;
        ++array_index;

        return *this;
    }

    /// equality operator (needed for InputIterator)
    bool operator==(const iteration_proxy_value& o) const
    {
        return anchor == o.anchor;
    }

    /// inequality operator (needed for range-based for)
    bool operator!=(const iteration_proxy_value& o) const
    {
        return anchor != o.anchor;
    }

    /// return key of the iterator
    const std::string& key() const
    {
        assert(anchor.m_object != nullptr);

        switch (anchor.m_object->type())
        {
            // use integer array index as key
            case value_t::array:
            {
                if (array_index != array_index_last)
                {
                    array_index_str = std::to_string(array_index);
                    array_index_last = array_index;
                }
                return array_index_str;
            }

            // use key from the object
            case value_t::object:
                return anchor.key();

            // use an empty key for all primitive types
            default:
                return empty_str;
        }
    }

    /// return value of the iterator
    typename IteratorType::reference value() const
    {
        return anchor.value();
    }
};

/// proxy class for the items() function
template<typename IteratorType> class iteration_proxy
{
  private:
    /// the container to iterate
    typename IteratorType::reference container;

  public:
    /// construct iteration proxy from a container
    explicit iteration_proxy(typename IteratorType::reference cont) noexcept
        : container(cont) {}

    /// return iterator begin (needed for range-based for)
    iteration_proxy_value<IteratorType> begin() noexcept
    {
        return iteration_proxy_value<IteratorType>(container.begin());
    }

    /// return iterator end (needed for range-based for)
    iteration_proxy_value<IteratorType> end() noexcept
    {
        return iteration_proxy_value<IteratorType>(container.end());
    }
};
// Structured Bindings Support
// For further reference see https://blog.tartanllama.xyz/structured-bindings/
// And see https://github.com/nlohmann/json/pull/1391
template <std::size_t N, typename IteratorType, enable_if_t<N == 0, int> = 0>
auto get(const nlohmann::detail::iteration_proxy_value<IteratorType>& i) -> decltype(i.key())
{
    return i.key();
}
// Structured Bindings Support
// For further reference see https://blog.tartanllama.xyz/structured-bindings/
// And see https://github.com/nlohmann/json/pull/1391
template <std::size_t N, typename IteratorType, enable_if_t<N == 1, int> = 0>
auto get(const nlohmann::detail::iteration_proxy_value<IteratorType>& i) -> decltype(i.value())
{
    return i.value();
}
}  // namespace detail
}  // namespace nlohmann

// The Addition to the STD Namespace is required to add
// Structured Bindings Support to the iteration_proxy_value class
// For further reference see https://blog.tartanllama.xyz/structured-bindings/
// And see https://github.com/nlohmann/json/pull/1391
namespace std
{
#if defined(__clang__)
    // Fix: https://github.com/nlohmann/json/issues/1401
    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Wmismatched-tags"
#endif
template <typename IteratorType>
class tuple_size<::nlohmann::detail::iteration_proxy_value<IteratorType>>
            : public std::integral_constant<std::size_t, 2> {};

template <std::size_t N, typename IteratorType>
class tuple_element<N, ::nlohmann::detail::iteration_proxy_value<IteratorType >>
{
  public:
    using type = decltype(
                     get<N>(std::declval <
                            ::nlohmann::detail::iteration_proxy_value<IteratorType >> ()));
};
#if defined(__clang__)
    #pragma clang diagnostic pop
#endif
} // namespace std

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/meta/type_traits.hpp>

// #include <nlohmann/detail/value_t.hpp>


namespace nlohmann
{
namespace detail
{
//////////////////
// constructors //
//////////////////

template<value_t> struct external_constructor;

template<>
struct external_constructor<value_t::boolean>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::boolean_t b) noexcept
    {
        j.m_type = value_t::boolean;
        j.m_value = b;
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::string>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, const typename BasicJsonType::string_t& s)
    {
        j.m_type = value_t::string;
        j.m_value = s;
        j.assert_invariant();
    }

    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::string_t&& s)
    {
        j.m_type = value_t::string;
        j.m_value = std::move(s);
        j.assert_invariant();
    }

    template<typename BasicJsonType, typename CompatibleStringType,
             enable_if_t<not std::is_same<CompatibleStringType, typename BasicJsonType::string_t>::value,
                         int> = 0>
    static void construct(BasicJsonType& j, const CompatibleStringType& str)
    {
        j.m_type = value_t::string;
        j.m_value.string = j.template create<typename BasicJsonType::string_t>(str);
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::number_float>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::number_float_t val) noexcept
    {
        j.m_type = value_t::number_float;
        j.m_value = val;
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::number_unsigned>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::number_unsigned_t val) noexcept
    {
        j.m_type = value_t::number_unsigned;
        j.m_value = val;
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::number_integer>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::number_integer_t val) noexcept
    {
        j.m_type = value_t::number_integer;
        j.m_value = val;
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::array>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, const typename BasicJsonType::array_t& arr)
    {
        j.m_type = value_t::array;
        j.m_value = arr;
        j.assert_invariant();
    }

    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::array_t&& arr)
    {
        j.m_type = value_t::array;
        j.m_value = std::move(arr);
        j.assert_invariant();
    }

    template<typename BasicJsonType, typename CompatibleArrayType,
             enable_if_t<not std::is_same<CompatibleArrayType, typename BasicJsonType::array_t>::value,
                         int> = 0>
    static void construct(BasicJsonType& j, const CompatibleArrayType& arr)
    {
        using std::begin;
        using std::end;
        j.m_type = value_t::array;
        j.m_value.array = j.template create<typename BasicJsonType::array_t>(begin(arr), end(arr));
        j.assert_invariant();
    }

    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, const std::vector<bool>& arr)
    {
        j.m_type = value_t::array;
        j.m_value = value_t::array;
        j.m_value.array->reserve(arr.size());
        for (const bool x : arr)
        {
            j.m_value.array->push_back(x);
        }
        j.assert_invariant();
    }

    template<typename BasicJsonType, typename T,
             enable_if_t<std::is_convertible<T, BasicJsonType>::value, int> = 0>
    static void construct(BasicJsonType& j, const std::valarray<T>& arr)
    {
        j.m_type = value_t::array;
        j.m_value = value_t::array;
        j.m_value.array->resize(arr.size());
        std::copy(std::begin(arr), std::end(arr), j.m_value.array->begin());
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::object>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, const typename BasicJsonType::object_t& obj)
    {
        j.m_type = value_t::object;
        j.m_value = obj;
        j.assert_invariant();
    }

    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::object_t&& obj)
    {
        j.m_type = value_t::object;
        j.m_value = std::move(obj);
        j.assert_invariant();
    }

    template<typename BasicJsonType, typename CompatibleObjectType,
             enable_if_t<not std::is_same<CompatibleObjectType, typename BasicJsonType::object_t>::value, int> = 0>
    static void construct(BasicJsonType& j, const CompatibleObjectType& obj)
    {
        using std::begin;
        using std::end;

        j.m_type = value_t::object;
        j.m_value.object = j.template create<typename BasicJsonType::object_t>(begin(obj), end(obj));
        j.assert_invariant();
    }
};

/////////////
// to_json //
/////////////

template<typename BasicJsonType, typename T,
         enable_if_t<std::is_same<T, typename BasicJsonType::boolean_t>::value, int> = 0>
void to_json(BasicJsonType& j, T b) noexcept
{
    external_constructor<value_t::boolean>::construct(j, b);
}

template<typename BasicJsonType, typename CompatibleString,
         enable_if_t<std::is_constructible<typename BasicJsonType::string_t, CompatibleString>::value, int> = 0>
void to_json(BasicJsonType& j, const CompatibleString& s)
{
    external_constructor<value_t::string>::construct(j, s);
}

template<typename BasicJsonType>
void to_json(BasicJsonType& j, typename BasicJsonType::string_t&& s)
{
    external_constructor<value_t::string>::construct(j, std::move(s));
}

template<typename BasicJsonType, typename FloatType,
         enable_if_t<std::is_floating_point<FloatType>::value, int> = 0>
void to_json(BasicJsonType& j, FloatType val) noexcept
{
    external_constructor<value_t::number_float>::construct(j, static_cast<typename BasicJsonType::number_float_t>(val));
}

template<typename BasicJsonType, typename CompatibleNumberUnsignedType,
         enable_if_t<is_compatible_integer_type<typename BasicJsonType::number_unsigned_t, CompatibleNumberUnsignedType>::value, int> = 0>
void to_json(BasicJsonType& j, CompatibleNumberUnsignedType val) noexcept
{
    external_constructor<value_t::number_unsigned>::construct(j, static_cast<typename BasicJsonType::number_unsigned_t>(val));
}

template<typename BasicJsonType, typename CompatibleNumberIntegerType,
         enable_if_t<is_compatible_integer_type<typename BasicJsonType::number_integer_t, CompatibleNumberIntegerType>::value, int> = 0>
void to_json(BasicJsonType& j, CompatibleNumberIntegerType val) noexcept
{
    external_constructor<value_t::number_integer>::construct(j, static_cast<typename BasicJsonType::number_integer_t>(val));
}

template<typename BasicJsonType, typename EnumType,
         enable_if_t<std::is_enum<EnumType>::value, int> = 0>
void to_json(BasicJsonType& j, EnumType e) noexcept
{
    using underlying_type = typename std::underlying_type<EnumType>::type;
    external_constructor<value_t::number_integer>::construct(j, static_cast<underlying_type>(e));
}

template<typename BasicJsonType>
void to_json(BasicJsonType& j, const std::vector<bool>& e)
{
    external_constructor<value_t::array>::construct(j, e);
}

template <typename BasicJsonType, typename CompatibleArrayType,
          enable_if_t<is_compatible_array_type<BasicJsonType,
                      CompatibleArrayType>::value and
                      not is_compatible_object_type<
                          BasicJsonType, CompatibleArrayType>::value and
                      not is_compatible_string_type<BasicJsonType, CompatibleArrayType>::value and
                      not is_basic_json<CompatibleArrayType>::value,
                      int> = 0>
void to_json(BasicJsonType& j, const CompatibleArrayType& arr)
{
    external_constructor<value_t::array>::construct(j, arr);
}

template<typename BasicJsonType, typename T,
         enable_if_t<std::is_convertible<T, BasicJsonType>::value, int> = 0>
void to_json(BasicJsonType& j, const std::valarray<T>& arr)
{
    external_constructor<value_t::array>::construct(j, std::move(arr));
}

template<typename BasicJsonType>
void to_json(BasicJsonType& j, typename BasicJsonType::array_t&& arr)
{
    external_constructor<value_t::array>::construct(j, std::move(arr));
}

template<typename BasicJsonType, typename CompatibleObjectType,
         enable_if_t<is_compatible_object_type<BasicJsonType, CompatibleObjectType>::value and not is_basic_json<CompatibleObjectType>::value, int> = 0>
void to_json(BasicJsonType& j, const CompatibleObjectType& obj)
{
    external_constructor<value_t::object>::construct(j, obj);
}

template<typename BasicJsonType>
void to_json(BasicJsonType& j, typename BasicJsonType::object_t&& obj)
{
    external_constructor<value_t::object>::construct(j, std::move(obj));
}

template <
    typename BasicJsonType, typename T, std::size_t N,
    enable_if_t<not std::is_constructible<typename BasicJsonType::string_t,
                const T(&)[N]>::value,
                int> = 0 >
void to_json(BasicJsonType& j, const T(&arr)[N])
{
    external_constructor<value_t::array>::construct(j, arr);
}

template<typename BasicJsonType, typename... Args>
void to_json(BasicJsonType& j, const std::pair<Args...>& p)
{
    j = { p.first, p.second };
}

// for https://github.com/nlohmann/json/pull/1134
template < typename BasicJsonType, typename T,
           enable_if_t<std::is_same<T, iteration_proxy_value<typename BasicJsonType::iterator>>::value, int> = 0>
void to_json(BasicJsonType& j, const T& b)
{
    j = { {b.key(), b.value()} };
}

template<typename BasicJsonType, typename Tuple, std::size_t... Idx>
void to_json_tuple_impl(BasicJsonType& j, const Tuple& t, index_sequence<Idx...> /*unused*/)
{
    j = { std::get<Idx>(t)... };
}

template<typename BasicJsonType, typename... Args>
void to_json(BasicJsonType& j, const std::tuple<Args...>& t)
{
    to_json_tuple_impl(j, t, index_sequence_for<Args...> {});
}

struct to_json_fn
{
    template<typename BasicJsonType, typename T>
    auto operator()(BasicJsonType& j, T&& val) const noexcept(noexcept(to_json(j, std::forward<T>(val))))
    -> decltype(to_json(j, std::forward<T>(val)), void())
    {
        return to_json(j, std::forward<T>(val));
    }
};
}  // namespace detail

/// namespace to hold default `to_json` function
namespace
{
constexpr const auto& to_json = detail::static_const<detail::to_json_fn>::value;
} // namespace
}  // namespace nlohmann


namespace nlohmann
{

template<typename, typename>
struct adl_serializer
{
    /*!
    @brief convert a JSON value to any value type

    This function is usually called by the `get()` function of the
    @ref basic_json class (either explicit or via conversion operators).

    @param[in] j        JSON value to read from
    @param[in,out] val  value to write to
    */
    template<typename BasicJsonType, typename ValueType>
    static auto from_json(BasicJsonType&& j, ValueType& val) noexcept(
        noexcept(::nlohmann::from_json(std::forward<BasicJsonType>(j), val)))
    -> decltype(::nlohmann::from_json(std::forward<BasicJsonType>(j), val), void())
    {
        ::nlohmann::from_json(std::forward<BasicJsonType>(j), val);
    }

    /*!
    @brief convert any value type to a JSON value

    This function is usually called by the constructors of the @ref basic_json
    class.

    @param[in,out] j  JSON value to write to
    @param[in] val    value to read from
    */
    template <typename BasicJsonType, typename ValueType>
    static auto to_json(BasicJsonType& j, ValueType&& val) noexcept(
        noexcept(::nlohmann::to_json(j, std::forward<ValueType>(val))))
    -> decltype(::nlohmann::to_json(j, std::forward<ValueType>(val)), void())
    {
        ::nlohmann::to_json(j, std::forward<ValueType>(val));
    }
};

}  // namespace nlohmann

// #include <nlohmann/detail/conversions/from_json.hpp>

// #include <nlohmann/detail/conversions/to_json.hpp>

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/input/binary_reader.hpp>


#include <algorithm> // generate_n
#include <array> // array
#include <cassert> // assert
#include <cmath> // ldexp
#include <cstddef> // size_t
#include <cstdint> // uint8_t, uint16_t, uint32_t, uint64_t
#include <cstdio> // snprintf
#include <cstring> // memcpy
#include <iterator> // back_inserter
#include <limits> // numeric_limits
#include <string> // char_traits, string
#include <utility> // make_pair, move

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/input/input_adapters.hpp>


#include <array> // array
#include <cassert> // assert
#include <cstddef> // size_t
#include <cstdio> //FILE *
#include <cstring> // strlen
#include <istream> // istream
#include <iterator> // begin, end, iterator_traits, random_access_iterator_tag, distance, next
#include <memory> // shared_ptr, make_shared, addressof
#include <numeric> // accumulate
#include <string> // string, char_traits
#include <type_traits> // enable_if, is_base_of, is_pointer, is_integral, remove_pointer
#include <utility> // pair, declval

// #include <nlohmann/detail/iterators/iterator_traits.hpp>

// #include <nlohmann/detail/macro_scope.hpp>


namespace nlohmann
{
namespace detail
{
/// the supported input formats
enum class input_format_t { json, cbor, msgpack, ubjson, bson };

////////////////////
// input adapters //
////////////////////

/*!
@brief abstract input adapter interface

Produces a stream of std::char_traits<char>::int_type characters from a
std::istream, a buffer, or some other input type. Accepts the return of
exactly one non-EOF character for future input. The int_type characters
returned consist of all valid char values as positive values (typically
unsigned char), plus an EOF value outside that range, specified by the value
of the function std::char_traits<char>::eof(). This value is typically -1, but
could be any arbitrary value which is not a valid char value.
*/
struct input_adapter_protocol
{
    /// get a character [0,255] or std::char_traits<char>::eof().
    virtual std::char_traits<char>::int_type get_character() = 0;
    virtual ~input_adapter_protocol() = default;
};

/// a type to simplify interfaces
using input_adapter_t = std::shared_ptr<input_adapter_protocol>;

/*!
Input adapter for stdio file access. This adapter read only 1 byte and do not use any
 buffer. This adapter is a very low level adapter.
*/
class file_input_adapter : public input_adapter_protocol
{
  public:
    explicit file_input_adapter(std::FILE* f)  noexcept
        : m_file(f)
    {}

    // make class move-only
    file_input_adapter(const file_input_adapter&) = delete;
    file_input_adapter(file_input_adapter&&) = default;
    file_input_adapter& operator=(const file_input_adapter&) = delete;
    file_input_adapter& operator=(file_input_adapter&&) = default;
    ~file_input_adapter() override = default;

    std::char_traits<char>::int_type get_character() noexcept override
    {
        return std::fgetc(m_file);
    }

  private:
    /// the file pointer to read from
    std::FILE* m_file;
};


/*!
Input adapter for a (caching) istream. Ignores a UFT Byte Order Mark at
beginning of input. Does not support changing the underlying std::streambuf
in mid-input. Maintains underlying std::istream and std::streambuf to support
subsequent use of standard std::istream operations to process any input
characters following those used in parsing the JSON input.  Clears the
std::istream flags; any input errors (e.g., EOF) will be detected by the first
subsequent call for input from the std::istream.
*/
class input_stream_adapter : public input_adapter_protocol
{
  public:
    ~input_stream_adapter() override
    {
        // clear stream flags; we use underlying streambuf I/O, do not
        // maintain ifstream flags, except eof
        is.clear(is.rdstate() & std::ios::eofbit);
    }

    explicit input_stream_adapter(std::istream& i)
        : is(i), sb(*i.rdbuf())
    {}

    // delete because of pointer members
    input_stream_adapter(const input_stream_adapter&) = delete;
    input_stream_adapter& operator=(input_stream_adapter&) = delete;
    input_stream_adapter(input_stream_adapter&&) = delete;
    input_stream_adapter& operator=(input_stream_adapter&&) = delete;

    // std::istream/std::streambuf use std::char_traits<char>::to_int_type, to
    // ensure that std::char_traits<char>::eof() and the character 0xFF do not
    // end up as the same value, eg. 0xFFFFFFFF.
    std::char_traits<char>::int_type get_character() override
    {
        auto res = sb.sbumpc();
        // set eof manually, as we don't use the istream interface.
        if (res == EOF)
        {
            is.clear(is.rdstate() | std::ios::eofbit);
        }
        return res;
    }

  private:
    /// the associated input stream
    std::istream& is;
    std::streambuf& sb;
};

/// input adapter for buffer input
class input_buffer_adapter : public input_adapter_protocol
{
  public:
    input_buffer_adapter(const char* b, const std::size_t l) noexcept
        : cursor(b), limit(b + l)
    {}

    // delete because of pointer members
    input_buffer_adapter(const input_buffer_adapter&) = delete;
    input_buffer_adapter& operator=(input_buffer_adapter&) = delete;
    input_buffer_adapter(input_buffer_adapter&&) = delete;
    input_buffer_adapter& operator=(input_buffer_adapter&&) = delete;
    ~input_buffer_adapter() override = default;

    std::char_traits<char>::int_type get_character() noexcept override
    {
        if (JSON_LIKELY(cursor < limit))
        {
            return std::char_traits<char>::to_int_type(*(cursor++));
        }

        return std::char_traits<char>::eof();
    }

  private:
    /// pointer to the current character
    const char* cursor;
    /// pointer past the last character
    const char* const limit;
};

template<typename WideStringType, size_t T>
struct wide_string_input_helper
{
    // UTF-32
    static void fill_buffer(const WideStringType& str,
                            size_t& current_wchar,
                            std::array<std::char_traits<char>::int_type, 4>& utf8_bytes,
                            size_t& utf8_bytes_index,
                            size_t& utf8_bytes_filled)
    {
        utf8_bytes_index = 0;

        if (current_wchar == str.size())
        {
            utf8_bytes[0] = std::char_traits<char>::eof();
            utf8_bytes_filled = 1;
        }
        else
        {
            // get the current character
            const auto wc = static_cast<unsigned int>(str[current_wchar++]);

            // UTF-32 to UTF-8 encoding
            if (wc < 0x80)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);
                utf8_bytes_filled = 1;
            }
            else if (wc <= 0x7FF)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xC0u | ((wc >> 6u) & 0x1Fu));
                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | (wc & 0x3Fu));
                utf8_bytes_filled = 2;
            }
            else if (wc <= 0xFFFF)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xE0u | ((wc >> 12u) & 0x0Fu));
                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((wc >> 6u) & 0x3Fu));
                utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | (wc & 0x3Fu));
                utf8_bytes_filled = 3;
            }
            else if (wc <= 0x10FFFF)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xF0u | ((wc >> 18u) & 0x07u));
                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((wc >> 12u) & 0x3Fu));
                utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | ((wc >> 6u) & 0x3Fu));
                utf8_bytes[3] = static_cast<std::char_traits<char>::int_type>(0x80u | (wc & 0x3Fu));
                utf8_bytes_filled = 4;
            }
            else
            {
                // unknown character
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);
                utf8_bytes_filled = 1;
            }
        }
    }
};

template<typename WideStringType>
struct wide_string_input_helper<WideStringType, 2>
{
    // UTF-16
    static void fill_buffer(const WideStringType& str,
                            size_t& current_wchar,
                            std::array<std::char_traits<char>::int_type, 4>& utf8_bytes,
                            size_t& utf8_bytes_index,
                            size_t& utf8_bytes_filled)
    {
        utf8_bytes_index = 0;

        if (current_wchar == str.size())
        {
            utf8_bytes[0] = std::char_traits<char>::eof();
            utf8_bytes_filled = 1;
        }
        else
        {
            // get the current character
            const auto wc = static_cast<unsigned int>(str[current_wchar++]);

            // UTF-16 to UTF-8 encoding
            if (wc < 0x80)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);
                utf8_bytes_filled = 1;
            }
            else if (wc <= 0x7FF)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xC0u | ((wc >> 6u)));
                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | (wc & 0x3Fu));
                utf8_bytes_filled = 2;
            }
            else if (0xD800 > wc or wc >= 0xE000)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xE0u | ((wc >> 12u)));
                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((wc >> 6u) & 0x3Fu));
                utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | (wc & 0x3Fu));
                utf8_bytes_filled = 3;
            }
            else
            {
                if (current_wchar < str.size())
                {
                    const auto wc2 = static_cast<unsigned int>(str[current_wchar++]);
                    const auto charcode = 0x10000u + (((wc & 0x3FFu) << 10u) | (wc2 & 0x3FFu));
                    utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xF0u | (charcode >> 18u));
                    utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((charcode >> 12u) & 0x3Fu));
                    utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | ((charcode >> 6u) & 0x3Fu));
                    utf8_bytes[3] = static_cast<std::char_traits<char>::int_type>(0x80u | (charcode & 0x3Fu));
                    utf8_bytes_filled = 4;
                }
                else
                {
                    // unknown character
                    ++current_wchar;
                    utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);
                    utf8_bytes_filled = 1;
                }
            }
        }
    }
};

template<typename WideStringType>
class wide_string_input_adapter : public input_adapter_protocol
{
  public:
    explicit wide_string_input_adapter(const WideStringType& w) noexcept
        : str(w)
    {}

    std::char_traits<char>::int_type get_character() noexcept override
    {
        // check if buffer needs to be filled
        if (utf8_bytes_index == utf8_bytes_filled)
        {
            fill_buffer<sizeof(typename WideStringType::value_type)>();

            assert(utf8_bytes_filled > 0);
            assert(utf8_bytes_index == 0);
        }

        // use buffer
        assert(utf8_bytes_filled > 0);
        assert(utf8_bytes_index < utf8_bytes_filled);
        return utf8_bytes[utf8_bytes_index++];
    }

  private:
    template<size_t T>
    void fill_buffer()
    {
        wide_string_input_helper<WideStringType, T>::fill_buffer(str, current_wchar, utf8_bytes, utf8_bytes_index, utf8_bytes_filled);
    }

    /// the wstring to process
    const WideStringType& str;

    /// index of the current wchar in str
    std::size_t current_wchar = 0;

    /// a buffer for UTF-8 bytes
    std::array<std::char_traits<char>::int_type, 4> utf8_bytes = {{0, 0, 0, 0}};

    /// index to the utf8_codes array for the next valid byte
    std::size_t utf8_bytes_index = 0;
    /// number of valid bytes in the utf8_codes array
    std::size_t utf8_bytes_filled = 0;
};

class input_adapter
{
  public:
    // native support
    input_adapter(std::FILE* file)
        : ia(std::make_shared<file_input_adapter>(file)) {}
    /// input adapter for input stream
    input_adapter(std::istream& i)
        : ia(std::make_shared<input_stream_adapter>(i)) {}

    /// input adapter for input stream
    input_adapter(std::istream&& i)
        : ia(std::make_shared<input_stream_adapter>(i)) {}

    input_adapter(const std::wstring& ws)
        : ia(std::make_shared<wide_string_input_adapter<std::wstring>>(ws)) {}

    input_adapter(const std::u16string& ws)
        : ia(std::make_shared<wide_string_input_adapter<std::u16string>>(ws)) {}

    input_adapter(const std::u32string& ws)
        : ia(std::make_shared<wide_string_input_adapter<std::u32string>>(ws)) {}

    /// input adapter for buffer
    template<typename CharT,
             typename std::enable_if<
                 std::is_pointer<CharT>::value and
                 std::is_integral<typename std::remove_pointer<CharT>::type>::value and
                 sizeof(typename std::remove_pointer<CharT>::type) == 1,
                 int>::type = 0>
    input_adapter(CharT b, std::size_t l)
        : ia(std::make_shared<input_buffer_adapter>(reinterpret_cast<const char*>(b), l)) {}

    // derived support

    /// input adapter for string literal
    template<typename CharT,
             typename std::enable_if<
                 std::is_pointer<CharT>::value and
                 std::is_integral<typename std::remove_pointer<CharT>::type>::value and
                 sizeof(typename std::remove_pointer<CharT>::type) == 1,
                 int>::type = 0>
    input_adapter(CharT b)
        : input_adapter(reinterpret_cast<const char*>(b),
                        std::strlen(reinterpret_cast<const char*>(b))) {}

    /// input adapter for iterator range with contiguous storage
    template<class IteratorType,
             typename std::enable_if<
                 std::is_same<typename iterator_traits<IteratorType>::iterator_category, std::random_access_iterator_tag>::value,
                 int>::type = 0>
    input_adapter(IteratorType first, IteratorType last)
    {
#ifndef NDEBUG
        // assertion to check that the iterator range is indeed contiguous,
        // see http://stackoverflow.com/a/35008842/266378 for more discussion
        const auto is_contiguous = std::accumulate(
                                       first, last, std::pair<bool, int>(true, 0),
                                       [&first](std::pair<bool, int> res, decltype(*first) val)
        {
            res.first &= (val == *(std::next(std::addressof(*first), res.second++)));
            return res;
        }).first;
        assert(is_contiguous);
#endif

        // assertion to check that each element is 1 byte long
        static_assert(
            sizeof(typename iterator_traits<IteratorType>::value_type) == 1,
            "each element in the iterator range must have the size of 1 byte");

        const auto len = static_cast<size_t>(std::distance(first, last));
        if (JSON_LIKELY(len > 0))
        {
            // there is at least one element: use the address of first
            ia = std::make_shared<input_buffer_adapter>(reinterpret_cast<const char*>(&(*first)), len);
        }
        else
        {
            // the address of first cannot be used: use nullptr
            ia = std::make_shared<input_buffer_adapter>(nullptr, len);
        }
    }

    /// input adapter for array
    template<class T, std::size_t N>
    input_adapter(T (&array)[N])
        : input_adapter(std::begin(array), std::end(array)) {}

    /// input adapter for contiguous container
    template<class ContiguousContainer, typename
             std::enable_if<not std::is_pointer<ContiguousContainer>::value and
                            std::is_base_of<std::random_access_iterator_tag, typename iterator_traits<decltype(std::begin(std::declval<ContiguousContainer const>()))>::iterator_category>::value,
                            int>::type = 0>
    input_adapter(const ContiguousContainer& c)
        : input_adapter(std::begin(c), std::end(c)) {}

    operator input_adapter_t()
    {
        return ia;
    }

  private:
    /// the actual adapter
    input_adapter_t ia = nullptr;
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/input/json_sax.hpp>


#include <cassert> // assert
#include <cstddef>
#include <string> // string
#include <utility> // move
#include <vector> // vector

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/macro_scope.hpp>


namespace nlohmann
{

/*!
@brief SAX interface

This class describes the SAX interface used by @ref nlohmann::json::sax_parse.
Each function is called in different situations while the input is parsed. The
boolean return value informs the parser whether to continue processing the
input.
*/
template<typename BasicJsonType>
struct json_sax
{
    /// type for (signed) integers
    using number_integer_t = typename BasicJsonType::number_integer_t;
    /// type for unsigned integers
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    /// type for floating-point numbers
    using number_float_t = typename BasicJsonType::number_float_t;
    /// type for strings
    using string_t = typename BasicJsonType::string_t;

    /*!
    @brief a null value was read
    @return whether parsing should proceed
    */
    virtual bool null() = 0;

    /*!
    @brief a boolean value was read
    @param[in] val  boolean value
    @return whether parsing should proceed
    */
    virtual bool boolean(bool val) = 0;

    /*!
    @brief an integer number was read
    @param[in] val  integer value
    @return whether parsing should proceed
    */
    virtual bool number_integer(number_integer_t val) = 0;

    /*!
    @brief an unsigned integer number was read
    @param[in] val  unsigned integer value
    @return whether parsing should proceed
    */
    virtual bool number_unsigned(number_unsigned_t val) = 0;

    /*!
    @brief an floating-point number was read
    @param[in] val  floating-point value
    @param[in] s    raw token value
    @return whether parsing should proceed
    */
    virtual bool number_float(number_float_t val, const string_t& s) = 0;

    /*!
    @brief a string was read
    @param[in] val  string value
    @return whether parsing should proceed
    @note It is safe to move the passed string.
    */
    virtual bool string(string_t& val) = 0;

    /*!
    @brief the beginning of an object was read
    @param[in] elements  number of object elements or -1 if unknown
    @return whether parsing should proceed
    @note binary formats may report the number of elements
    */
    virtual bool start_object(std::size_t elements) = 0;

    /*!
    @brief an object key was read
    @param[in] val  object key
    @return whether parsing should proceed
    @note It is safe to move the passed string.
    */
    virtual bool key(string_t& val) = 0;

    /*!
    @brief the end of an object was read
    @return whether parsing should proceed
    */
    virtual bool end_object() = 0;

    /*!
    @brief the beginning of an array was read
    @param[in] elements  number of array elements or -1 if unknown
    @return whether parsing should proceed
    @note binary formats may report the number of elements
    */
    virtual bool start_array(std::size_t elements) = 0;

    /*!
    @brief the end of an array was read
    @return whether parsing should proceed
    */
    virtual bool end_array() = 0;

    /*!
    @brief a parse error occurred
    @param[in] position    the position in the input where the error occurs
    @param[in] last_token  the last read token
    @param[in] ex          an exception object describing the error
    @return whether parsing should proceed (must return false)
    */
    virtual bool parse_error(std::size_t position,
                             const std::string& last_token,
                             const detail::exception& ex) = 0;

    virtual ~json_sax() = default;
};


namespace detail
{
/*!
@brief SAX implementation to create a JSON value from SAX events

This class implements the @ref json_sax interface and processes the SAX events
to create a JSON value which makes it basically a DOM parser. The structure or
hierarchy of the JSON value is managed by the stack `ref_stack` which contains
a pointer to the respective array or object for each recursion depth.

After successful parsing, the value that is passed by reference to the
constructor contains the parsed value.

@tparam BasicJsonType  the JSON type
*/
template<typename BasicJsonType>
class json_sax_dom_parser
{
  public:
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;

    /*!
    @param[in, out] r  reference to a JSON value that is manipulated while
                       parsing
    @param[in] allow_exceptions_  whether parse errors yield exceptions
    */
    explicit json_sax_dom_parser(BasicJsonType& r, const bool allow_exceptions_ = true)
        : root(r), allow_exceptions(allow_exceptions_)
    {}

    // make class move-only
    json_sax_dom_parser(const json_sax_dom_parser&) = delete;
    json_sax_dom_parser(json_sax_dom_parser&&) = default;
    json_sax_dom_parser& operator=(const json_sax_dom_parser&) = delete;
    json_sax_dom_parser& operator=(json_sax_dom_parser&&) = default;
    ~json_sax_dom_parser() = default;

    bool null()
    {
        handle_value(nullptr);
        return true;
    }

    bool boolean(bool val)
    {
        handle_value(val);
        return true;
    }

    bool number_integer(number_integer_t val)
    {
        handle_value(val);
        return true;
    }

    bool number_unsigned(number_unsigned_t val)
    {
        handle_value(val);
        return true;
    }

    bool number_float(number_float_t val, const string_t& /*unused*/)
    {
        handle_value(val);
        return true;
    }

    bool string(string_t& val)
    {
        handle_value(val);
        return true;
    }

    bool start_object(std::size_t len)
    {
        ref_stack.push_back(handle_value(BasicJsonType::value_t::object));

        if (JSON_UNLIKELY(len != std::size_t(-1) and len > ref_stack.back()->max_size()))
        {
            JSON_THROW(out_of_range::create(408,
                                            "excessive object size: " + std::to_string(len)));
        }

        return true;
    }

    bool key(string_t& val)
    {
        // add null at given key and store the reference for later
        object_element = &(ref_stack.back()->m_value.object->operator[](val));
        return true;
    }

    bool end_object()
    {
        ref_stack.pop_back();
        return true;
    }

    bool start_array(std::size_t len)
    {
        ref_stack.push_back(handle_value(BasicJsonType::value_t::array));

        if (JSON_UNLIKELY(len != std::size_t(-1) and len > ref_stack.back()->max_size()))
        {
            JSON_THROW(out_of_range::create(408,
                                            "excessive array size: " + std::to_string(len)));
        }

        return true;
    }

    bool end_array()
    {
        ref_stack.pop_back();
        return true;
    }

    bool parse_error(std::size_t /*unused*/, const std::string& /*unused*/,
                     const detail::exception& ex)
    {
        errored = true;
        if (allow_exceptions)
        {
            // determine the proper exception type from the id
            switch ((ex.id / 100) % 100)
            {
                case 1:
                    JSON_THROW(*static_cast<const detail::parse_error*>(&ex));
                case 4:
                    JSON_THROW(*static_cast<const detail::out_of_range*>(&ex));
                // LCOV_EXCL_START
                case 2:
                    JSON_THROW(*static_cast<const detail::invalid_iterator*>(&ex));
                case 3:
                    JSON_THROW(*static_cast<const detail::type_error*>(&ex));
                case 5:
                    JSON_THROW(*static_cast<const detail::other_error*>(&ex));
                default:
                    assert(false);
                    // LCOV_EXCL_STOP
            }
        }
        return false;
    }

    constexpr bool is_errored() const
    {
        return errored;
    }

  private:
    /*!
    @invariant If the ref stack is empty, then the passed value will be the new
               root.
    @invariant If the ref stack contains a value, then it is an array or an
               object to which we can add elements
    */
    template<typename Value>
    BasicJsonType* handle_value(Value&& v)
    {
        if (ref_stack.empty())
        {
            root = BasicJsonType(std::forward<Value>(v));
            return &root;
        }

        assert(ref_stack.back()->is_array() or ref_stack.back()->is_object());

        if (ref_stack.back()->is_array())
        {
            ref_stack.back()->m_value.array->emplace_back(std::forward<Value>(v));
            return &(ref_stack.back()->m_value.array->back());
        }

        assert(ref_stack.back()->is_object());
        assert(object_element);
        *object_element = BasicJsonType(std::forward<Value>(v));
        return object_element;
    }

    /// the parsed JSON value
    BasicJsonType& root;
    /// stack to model hierarchy of values
    std::vector<BasicJsonType*> ref_stack {};
    /// helper to hold the reference for the next object element
    BasicJsonType* object_element = nullptr;
    /// whether a syntax error occurred
    bool errored = false;
    /// whether to throw exceptions in case of errors
    const bool allow_exceptions = true;
};

template<typename BasicJsonType>
class json_sax_dom_callback_parser
{
  public:
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using parser_callback_t = typename BasicJsonType::parser_callback_t;
    using parse_event_t = typename BasicJsonType::parse_event_t;

    json_sax_dom_callback_parser(BasicJsonType& r,
                                 const parser_callback_t cb,
                                 const bool allow_exceptions_ = true)
        : root(r), callback(cb), allow_exceptions(allow_exceptions_)
    {
        keep_stack.push_back(true);
    }

    // make class move-only
    json_sax_dom_callback_parser(const json_sax_dom_callback_parser&) = delete;
    json_sax_dom_callback_parser(json_sax_dom_callback_parser&&) = default;
    json_sax_dom_callback_parser& operator=(const json_sax_dom_callback_parser&) = delete;
    json_sax_dom_callback_parser& operator=(json_sax_dom_callback_parser&&) = default;
    ~json_sax_dom_callback_parser() = default;

    bool null()
    {
        handle_value(nullptr);
        return true;
    }

    bool boolean(bool val)
    {
        handle_value(val);
        return true;
    }

    bool number_integer(number_integer_t val)
    {
        handle_value(val);
        return true;
    }

    bool number_unsigned(number_unsigned_t val)
    {
        handle_value(val);
        return true;
    }

    bool number_float(number_float_t val, const string_t& /*unused*/)
    {
        handle_value(val);
        return true;
    }

    bool string(string_t& val)
    {
        handle_value(val);
        return true;
    }

    bool start_object(std::size_t len)
    {
        // check callback for object start
        const bool keep = callback(static_cast<int>(ref_stack.size()), parse_event_t::object_start, discarded);
        keep_stack.push_back(keep);

        auto val = handle_value(BasicJsonType::value_t::object, true);
        ref_stack.push_back(val.second);

        // check object limit
        if (ref_stack.back() and JSON_UNLIKELY(len != std::size_t(-1) and len > ref_stack.back()->max_size()))
        {
            JSON_THROW(out_of_range::create(408, "excessive object size: " + std::to_string(len)));
        }

        return true;
    }

    bool key(string_t& val)
    {
        BasicJsonType k = BasicJsonType(val);

        // check callback for key
        const bool keep = callback(static_cast<int>(ref_stack.size()), parse_event_t::key, k);
        key_keep_stack.push_back(keep);

        // add discarded value at given key and store the reference for later
        if (keep and ref_stack.back())
        {
            object_element = &(ref_stack.back()->m_value.object->operator[](val) = discarded);
        }

        return true;
    }

    bool end_object()
    {
        if (ref_stack.back() and not callback(static_cast<int>(ref_stack.size()) - 1, parse_event_t::object_end, *ref_stack.back()))
        {
            // discard object
            *ref_stack.back() = discarded;
        }

        assert(not ref_stack.empty());
        assert(not keep_stack.empty());
        ref_stack.pop_back();
        keep_stack.pop_back();

        if (not ref_stack.empty() and ref_stack.back() and ref_stack.back()->is_object())
        {
            // remove discarded value
            for (auto it = ref_stack.back()->begin(); it != ref_stack.back()->end(); ++it)
            {
                if (it->is_discarded())
                {
                    ref_stack.back()->erase(it);
                    break;
                }
            }
        }

        return true;
    }

    bool start_array(std::size_t len)
    {
        const bool keep = callback(static_cast<int>(ref_stack.size()), parse_event_t::array_start, discarded);
        keep_stack.push_back(keep);

        auto val = handle_value(BasicJsonType::value_t::array, true);
        ref_stack.push_back(val.second);

        // check array limit
        if (ref_stack.back() and JSON_UNLIKELY(len != std::size_t(-1) and len > ref_stack.back()->max_size()))
        {
            JSON_THROW(out_of_range::create(408, "excessive array size: " + std::to_string(len)));
        }

        return true;
    }

    bool end_array()
    {
        bool keep = true;

        if (ref_stack.back())
        {
            keep = callback(static_cast<int>(ref_stack.size()) - 1, parse_event_t::array_end, *ref_stack.back());
            if (not keep)
            {
                // discard array
                *ref_stack.back() = discarded;
            }
        }

        assert(not ref_stack.empty());
        assert(not keep_stack.empty());
        ref_stack.pop_back();
        keep_stack.pop_back();

        // remove discarded value
        if (not keep and not ref_stack.empty() and ref_stack.back()->is_array())
        {
            ref_stack.back()->m_value.array->pop_back();
        }

        return true;
    }

    bool parse_error(std::size_t /*unused*/, const std::string& /*unused*/,
                     const detail::exception& ex)
    {
        errored = true;
        if (allow_exceptions)
        {
            // determine the proper exception type from the id
            switch ((ex.id / 100) % 100)
            {
                case 1:
                    JSON_THROW(*static_cast<const detail::parse_error*>(&ex));
                case 4:
                    JSON_THROW(*static_cast<const detail::out_of_range*>(&ex));
                // LCOV_EXCL_START
                case 2:
                    JSON_THROW(*static_cast<const detail::invalid_iterator*>(&ex));
                case 3:
                    JSON_THROW(*static_cast<const detail::type_error*>(&ex));
                case 5:
                    JSON_THROW(*static_cast<const detail::other_error*>(&ex));
                default:
                    assert(false);
                    // LCOV_EXCL_STOP
            }
        }
        return false;
    }

    constexpr bool is_errored() const
    {
        return errored;
    }

  private:
    /*!
    @param[in] v  value to add to the JSON value we build during parsing
    @param[in] skip_callback  whether we should skip calling the callback
               function; this is required after start_array() and
               start_object() SAX events, because otherwise we would call the
               callback function with an empty array or object, respectively.

    @invariant If the ref stack is empty, then the passed value will be the new
               root.
    @invariant If the ref stack contains a value, then it is an array or an
               object to which we can add elements

    @return pair of boolean (whether value should be kept) and pointer (to the
            passed value in the ref_stack hierarchy; nullptr if not kept)
    */
    template<typename Value>
    std::pair<bool, BasicJsonType*> handle_value(Value&& v, const bool skip_callback = false)
    {
        assert(not keep_stack.empty());

        // do not handle this value if we know it would be added to a discarded
        // container
        if (not keep_stack.back())
        {
            return {false, nullptr};
        }

        // create value
        auto value = BasicJsonType(std::forward<Value>(v));

        // check callback
        const bool keep = skip_callback or callback(static_cast<int>(ref_stack.size()), parse_event_t::value, value);

        // do not handle this value if we just learnt it shall be discarded
        if (not keep)
        {
            return {false, nullptr};
        }

        if (ref_stack.empty())
        {
            root = std::move(value);
            return {true, &root};
        }

        // skip this value if we already decided to skip the parent
        // (https://github.com/nlohmann/json/issues/971#issuecomment-413678360)
        if (not ref_stack.back())
        {
            return {false, nullptr};
        }

        // we now only expect arrays and objects
        assert(ref_stack.back()->is_array() or ref_stack.back()->is_object());

        // array
        if (ref_stack.back()->is_array())
        {
            ref_stack.back()->m_value.array->push_back(std::move(value));
            return {true, &(ref_stack.back()->m_value.array->back())};
        }

        // object
        assert(ref_stack.back()->is_object());
        // check if we should store an element for the current key
        assert(not key_keep_stack.empty());
        const bool store_element = key_keep_stack.back();
        key_keep_stack.pop_back();

        if (not store_element)
        {
            return {false, nullptr};
        }

        assert(object_element);
        *object_element = std::move(value);
        return {true, object_element};
    }

    /// the parsed JSON value
    BasicJsonType& root;
    /// stack to model hierarchy of values
    std::vector<BasicJsonType*> ref_stack {};
    /// stack to manage which values to keep
    std::vector<bool> keep_stack {};
    /// stack to manage which object keys to keep
    std::vector<bool> key_keep_stack {};
    /// helper to hold the reference for the next object element
    BasicJsonType* object_element = nullptr;
    /// whether a syntax error occurred
    bool errored = false;
    /// callback function
    const parser_callback_t callback = nullptr;
    /// whether to throw exceptions in case of errors
    const bool allow_exceptions = true;
    /// a discarded value for the callback
    BasicJsonType discarded = BasicJsonType::value_t::discarded;
};

template<typename BasicJsonType>
class json_sax_acceptor
{
  public:
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;

    bool null()
    {
        return true;
    }

    bool boolean(bool /*unused*/)
    {
        return true;
    }

    bool number_integer(number_integer_t /*unused*/)
    {
        return true;
    }

    bool number_unsigned(number_unsigned_t /*unused*/)
    {
        return true;
    }

    bool number_float(number_float_t /*unused*/, const string_t& /*unused*/)
    {
        return true;
    }

    bool string(string_t& /*unused*/)
    {
        return true;
    }

    bool start_object(std::size_t  /*unused*/ = std::size_t(-1))
    {
        return true;
    }

    bool key(string_t& /*unused*/)
    {
        return true;
    }

    bool end_object()
    {
        return true;
    }

    bool start_array(std::size_t  /*unused*/ = std::size_t(-1))
    {
        return true;
    }

    bool end_array()
    {
        return true;
    }

    bool parse_error(std::size_t /*unused*/, const std::string& /*unused*/, const detail::exception& /*unused*/)
    {
        return false;
    }
};
}  // namespace detail

}  // namespace nlohmann

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/is_sax.hpp>


#include <cstdint> // size_t
#include <utility> // declval
#include <string> // string

// #include <nlohmann/detail/meta/detected.hpp>

// #include <nlohmann/detail/meta/type_traits.hpp>


namespace nlohmann
{
namespace detail
{
template <typename T>
using null_function_t = decltype(std::declval<T&>().null());

template <typename T>
using boolean_function_t =
    decltype(std::declval<T&>().boolean(std::declval<bool>()));

template <typename T, typename Integer>
using number_integer_function_t =
    decltype(std::declval<T&>().number_integer(std::declval<Integer>()));

template <typename T, typename Unsigned>
using number_unsigned_function_t =
    decltype(std::declval<T&>().number_unsigned(std::declval<Unsigned>()));

template <typename T, typename Float, typename String>
using number_float_function_t = decltype(std::declval<T&>().number_float(
                                    std::declval<Float>(), std::declval<const String&>()));

template <typename T, typename String>
using string_function_t =
    decltype(std::declval<T&>().string(std::declval<String&>()));

template <typename T>
using start_object_function_t =
    decltype(std::declval<T&>().start_object(std::declval<std::size_t>()));

template <typename T, typename String>
using key_function_t =
    decltype(std::declval<T&>().key(std::declval<String&>()));

template <typename T>
using end_object_function_t = decltype(std::declval<T&>().end_object());

template <typename T>
using start_array_function_t =
    decltype(std::declval<T&>().start_array(std::declval<std::size_t>()));

template <typename T>
using end_array_function_t = decltype(std::declval<T&>().end_array());

template <typename T, typename Exception>
using parse_error_function_t = decltype(std::declval<T&>().parse_error(
        std::declval<std::size_t>(), std::declval<const std::string&>(),
        std::declval<const Exception&>()));

template <typename SAX, typename BasicJsonType>
struct is_sax
{
  private:
    static_assert(is_basic_json<BasicJsonType>::value,
                  "BasicJsonType must be of type basic_json<...>");

    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using exception_t = typename BasicJsonType::exception;

  public:
    static constexpr bool value =
        is_detected_exact<bool, null_function_t, SAX>::value &&
        is_detected_exact<bool, boolean_function_t, SAX>::value &&
        is_detected_exact<bool, number_integer_function_t, SAX,
        number_integer_t>::value &&
        is_detected_exact<bool, number_unsigned_function_t, SAX,
        number_unsigned_t>::value &&
        is_detected_exact<bool, number_float_function_t, SAX, number_float_t,
        string_t>::value &&
        is_detected_exact<bool, string_function_t, SAX, string_t>::value &&
        is_detected_exact<bool, start_object_function_t, SAX>::value &&
        is_detected_exact<bool, key_function_t, SAX, string_t>::value &&
        is_detected_exact<bool, end_object_function_t, SAX>::value &&
        is_detected_exact<bool, start_array_function_t, SAX>::value &&
        is_detected_exact<bool, end_array_function_t, SAX>::value &&
        is_detected_exact<bool, parse_error_function_t, SAX, exception_t>::value;
};

template <typename SAX, typename BasicJsonType>
struct is_sax_static_asserts
{
  private:
    static_assert(is_basic_json<BasicJsonType>::value,
                  "BasicJsonType must be of type basic_json<...>");

    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using exception_t = typename BasicJsonType::exception;

  public:
    static_assert(is_detected_exact<bool, null_function_t, SAX>::value,
                  "Missing/invalid function: bool null()");
    static_assert(is_detected_exact<bool, boolean_function_t, SAX>::value,
                  "Missing/invalid function: bool boolean(bool)");
    static_assert(is_detected_exact<bool, boolean_function_t, SAX>::value,
                  "Missing/invalid function: bool boolean(bool)");
    static_assert(
        is_detected_exact<bool, number_integer_function_t, SAX,
        number_integer_t>::value,
        "Missing/invalid function: bool number_integer(number_integer_t)");
    static_assert(
        is_detected_exact<bool, number_unsigned_function_t, SAX,
        number_unsigned_t>::value,
        "Missing/invalid function: bool number_unsigned(number_unsigned_t)");
    static_assert(is_detected_exact<bool, number_float_function_t, SAX,
                  number_float_t, string_t>::value,
                  "Missing/invalid function: bool number_float(number_float_t, const string_t&)");
    static_assert(
        is_detected_exact<bool, string_function_t, SAX, string_t>::value,
        "Missing/invalid function: bool string(string_t&)");
    static_assert(is_detected_exact<bool, start_object_function_t, SAX>::value,
                  "Missing/invalid function: bool start_object(std::size_t)");
    static_assert(is_detected_exact<bool, key_function_t, SAX, string_t>::value,
                  "Missing/invalid function: bool key(string_t&)");
    static_assert(is_detected_exact<bool, end_object_function_t, SAX>::value,
                  "Missing/invalid function: bool end_object()");
    static_assert(is_detected_exact<bool, start_array_function_t, SAX>::value,
                  "Missing/invalid function: bool start_array(std::size_t)");
    static_assert(is_detected_exact<bool, end_array_function_t, SAX>::value,
                  "Missing/invalid function: bool end_array()");
    static_assert(
        is_detected_exact<bool, parse_error_function_t, SAX, exception_t>::value,
        "Missing/invalid function: bool parse_error(std::size_t, const "
        "std::string&, const exception&)");
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/value_t.hpp>


namespace nlohmann
{
namespace detail
{
///////////////////
// binary reader //
///////////////////

/*!
@brief deserialization of CBOR, MessagePack, and UBJSON values
*/
template<typename BasicJsonType, typename SAX = json_sax_dom_parser<BasicJsonType>>
class binary_reader
{
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using json_sax_t = SAX;

  public:
    /*!
    @brief create a binary reader

    @param[in] adapter  input adapter to read from
    */
    explicit binary_reader(input_adapter_t adapter) : ia(std::move(adapter))
    {
        (void)detail::is_sax_static_asserts<SAX, BasicJsonType> {};
        assert(ia);
    }

    // make class move-only
    binary_reader(const binary_reader&) = delete;
    binary_reader(binary_reader&&) = default;
    binary_reader& operator=(const binary_reader&) = delete;
    binary_reader& operator=(binary_reader&&) = default;
    ~binary_reader() = default;

    /*!
    @param[in] format  the binary format to parse
    @param[in] sax_    a SAX event processor
    @param[in] strict  whether to expect the input to be consumed completed

    @return
    */
    bool sax_parse(const input_format_t format,
                   json_sax_t* sax_,
                   const bool strict = true)
    {
        sax = sax_;
        bool result = false;

        switch (format)
        {
            case input_format_t::bson:
                result = parse_bson_internal();
                break;

            case input_format_t::cbor:
                result = parse_cbor_internal();
                break;

            case input_format_t::msgpack:
                result = parse_msgpack_internal();
                break;

            case input_format_t::ubjson:
                result = parse_ubjson_internal();
                break;

            default:            // LCOV_EXCL_LINE
                assert(false);  // LCOV_EXCL_LINE
        }

        // strict mode: next byte must be EOF
        if (result and strict)
        {
            if (format == input_format_t::ubjson)
            {
                get_ignore_noop();
            }
            else
            {
                get();
            }

            if (JSON_UNLIKELY(current != std::char_traits<char>::eof()))
            {
                return sax->parse_error(chars_read, get_token_string(),
                                        parse_error::create(110, chars_read, exception_message(format, "expected end of input; last byte: 0x" + get_token_string(), "value")));
            }
        }

        return result;
    }

    /*!
    @brief determine system byte order

    @return true if and only if system's byte order is little endian

    @note from http://stackoverflow.com/a/1001328/266378
    */
    static constexpr bool little_endianess(int num = 1) noexcept
    {
        return *reinterpret_cast<char*>(&num) == 1;
    }

  private:
    //////////
    // BSON //
    //////////

    /*!
    @brief Reads in a BSON-object and passes it to the SAX-parser.
    @return whether a valid BSON-value was passed to the SAX parser
    */
    bool parse_bson_internal()
    {
        std::int32_t document_size;
        get_number<std::int32_t, true>(input_format_t::bson, document_size);

        if (JSON_UNLIKELY(not sax->start_object(std::size_t(-1))))
        {
            return false;
        }

        if (JSON_UNLIKELY(not parse_bson_element_list(/*is_array*/false)))
        {
            return false;
        }

        return sax->end_object();
    }

    /*!
    @brief Parses a C-style string from the BSON input.
    @param[in, out] result  A reference to the string variable where the read
                            string is to be stored.
    @return `true` if the \x00-byte indicating the end of the string was
             encountered before the EOF; false` indicates an unexpected EOF.
    */
    bool get_bson_cstr(string_t& result)
    {
        auto out = std::back_inserter(result);
        while (true)
        {
            get();
            if (JSON_UNLIKELY(not unexpect_eof(input_format_t::bson, "cstring")))
            {
                return false;
            }
            if (current == 0x00)
            {
                return true;
            }
            *out++ = static_cast<char>(current);
        }

        return true;
    }

    /*!
    @brief Parses a zero-terminated string of length @a len from the BSON
           input.
    @param[in] len  The length (including the zero-byte at the end) of the
                    string to be read.
    @param[in, out] result  A reference to the string variable where the read
                            string is to be stored.
    @tparam NumberType The type of the length @a len
    @pre len >= 1
    @return `true` if the string was successfully parsed
    */
    template<typename NumberType>
    bool get_bson_string(const NumberType len, string_t& result)
    {
        if (JSON_UNLIKELY(len < 1))
        {
            auto last_token = get_token_string();
            return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::bson, "string length must be at least 1, is " + std::to_string(len), "string")));
        }

        return get_string(input_format_t::bson, len - static_cast<NumberType>(1), result) and get() != std::char_traits<char>::eof();
    }

    /*!
    @brief Read a BSON document element of the given @a element_type.
    @param[in] element_type The BSON element type, c.f. http://bsonspec.org/spec.html
    @param[in] element_type_parse_position The position in the input stream,
               where the `element_type` was read.
    @warning Not all BSON element types are supported yet. An unsupported
             @a element_type will give rise to a parse_error.114:
             Unsupported BSON record type 0x...
    @return whether a valid BSON-object/array was passed to the SAX parser
    */
    bool parse_bson_element_internal(const int element_type,
                                     const std::size_t element_type_parse_position)
    {
        switch (element_type)
        {
            case 0x01: // double
            {
                double number;
                return get_number<double, true>(input_format_t::bson, number) and sax->number_float(static_cast<number_float_t>(number), "");
            }

            case 0x02: // string
            {
                std::int32_t len;
                string_t value;
                return get_number<std::int32_t, true>(input_format_t::bson, len) and get_bson_string(len, value) and sax->string(value);
            }

            case 0x03: // object
            {
                return parse_bson_internal();
            }

            case 0x04: // array
            {
                return parse_bson_array();
            }

            case 0x08: // boolean
            {
                return sax->boolean(get() != 0);
            }

            case 0x0A: // null
            {
                return sax->null();
            }

            case 0x10: // int32
            {
                std::int32_t value;
                return get_number<std::int32_t, true>(input_format_t::bson, value) and sax->number_integer(value);
            }

            case 0x12: // int64
            {
                std::int64_t value;
                return get_number<std::int64_t, true>(input_format_t::bson, value) and sax->number_integer(value);
            }

            default: // anything else not supported (yet)
            {
                std::array<char, 3> cr{{}};
                (std::snprintf)(cr.data(), cr.size(), "%.2hhX", static_cast<unsigned char>(element_type));
                return sax->parse_error(element_type_parse_position, std::string(cr.data()), parse_error::create(114, element_type_parse_position, "Unsupported BSON record type 0x" + std::string(cr.data())));
            }
        }
    }

    /*!
    @brief Read a BSON element list (as specified in the BSON-spec)

    The same binary layout is used for objects and arrays, hence it must be
    indicated with the argument @a is_array which one is expected
    (true --> array, false --> object).

    @param[in] is_array Determines if the element list being read is to be
                        treated as an object (@a is_array == false), or as an
                        array (@a is_array == true).
    @return whether a valid BSON-object/array was passed to the SAX parser
    */
    bool parse_bson_element_list(const bool is_array)
    {
        string_t key;
        while (int element_type = get())
        {
            if (JSON_UNLIKELY(not unexpect_eof(input_format_t::bson, "element list")))
            {
                return false;
            }

            const std::size_t element_type_parse_position = chars_read;
            if (JSON_UNLIKELY(not get_bson_cstr(key)))
            {
                return false;
            }

            if (not is_array and not sax->key(key))
            {
                return false;
            }

            if (JSON_UNLIKELY(not parse_bson_element_internal(element_type, element_type_parse_position)))
            {
                return false;
            }

            // get_bson_cstr only appends
            key.clear();
        }

        return true;
    }

    /*!
    @brief Reads an array from the BSON input and passes it to the SAX-parser.
    @return whether a valid BSON-array was passed to the SAX parser
    */
    bool parse_bson_array()
    {
        std::int32_t document_size;
        get_number<std::int32_t, true>(input_format_t::bson, document_size);

        if (JSON_UNLIKELY(not sax->start_array(std::size_t(-1))))
        {
            return false;
        }

        if (JSON_UNLIKELY(not parse_bson_element_list(/*is_array*/true)))
        {
            return false;
        }

        return sax->end_array();
    }

    //////////
    // CBOR //
    //////////

    /*!
    @param[in] get_char  whether a new character should be retrieved from the
                         input (true, default) or whether the last read
                         character should be considered instead

    @return whether a valid CBOR value was passed to the SAX parser
    */
    bool parse_cbor_internal(const bool get_char = true)
    {
        switch (get_char ? get() : current)
        {
            // EOF
            case std::char_traits<char>::eof():
                return unexpect_eof(input_format_t::cbor, "value");

            // Integer 0x00..0x17 (0..23)
            case 0x00:
            case 0x01:
            case 0x02:
            case 0x03:
            case 0x04:
            case 0x05:
            case 0x06:
            case 0x07:
            case 0x08:
            case 0x09:
            case 0x0A:
            case 0x0B:
            case 0x0C:
            case 0x0D:
            case 0x0E:
            case 0x0F:
            case 0x10:
            case 0x11:
            case 0x12:
            case 0x13:
            case 0x14:
            case 0x15:
            case 0x16:
            case 0x17:
                return sax->number_unsigned(static_cast<number_unsigned_t>(current));

            case 0x18: // Unsigned integer (one-byte uint8_t follows)
            {
                std::uint8_t number;
                return get_number(input_format_t::cbor, number) and sax->number_unsigned(number);
            }

            case 0x19: // Unsigned integer (two-byte uint16_t follows)
            {
                std::uint16_t number;
                return get_number(input_format_t::cbor, number) and sax->number_unsigned(number);
            }

            case 0x1A: // Unsigned integer (four-byte uint32_t follows)
            {
                std::uint32_t number;
                return get_number(input_format_t::cbor, number) and sax->number_unsigned(number);
            }

            case 0x1B: // Unsigned integer (eight-byte uint64_t follows)
            {
                std::uint64_t number;
                return get_number(input_format_t::cbor, number) and sax->number_unsigned(number);
            }

            // Negative integer -1-0x00..-1-0x17 (-1..-24)
            case 0x20:
            case 0x21:
            case 0x22:
            case 0x23:
            case 0x24:
            case 0x25:
            case 0x26:
            case 0x27:
            case 0x28:
            case 0x29:
            case 0x2A:
            case 0x2B:
            case 0x2C:
            case 0x2D:
            case 0x2E:
            case 0x2F:
            case 0x30:
            case 0x31:
            case 0x32:
            case 0x33:
            case 0x34:
            case 0x35:
            case 0x36:
            case 0x37:
                return sax->number_integer(static_cast<std::int8_t>(0x20 - 1 - current));

            case 0x38: // Negative integer (one-byte uint8_t follows)
            {
                std::uint8_t number;
                return get_number(input_format_t::cbor, number) and sax->number_integer(static_cast<number_integer_t>(-1) - number);
            }

            case 0x39: // Negative integer -1-n (two-byte uint16_t follows)
            {
                std::uint16_t number;
                return get_number(input_format_t::cbor, number) and sax->number_integer(static_cast<number_integer_t>(-1) - number);
            }

            case 0x3A: // Negative integer -1-n (four-byte uint32_t follows)
            {
                std::uint32_t number;
                return get_number(input_format_t::cbor, number) and sax->number_integer(static_cast<number_integer_t>(-1) - number);
            }

            case 0x3B: // Negative integer -1-n (eight-byte uint64_t follows)
            {
                std::uint64_t number;
                return get_number(input_format_t::cbor, number) and sax->number_integer(static_cast<number_integer_t>(-1)
                        - static_cast<number_integer_t>(number));
            }

            // UTF-8 string (0x00..0x17 bytes follow)
            case 0x60:
            case 0x61:
            case 0x62:
            case 0x63:
            case 0x64:
            case 0x65:
            case 0x66:
            case 0x67:
            case 0x68:
            case 0x69:
            case 0x6A:
            case 0x6B:
            case 0x6C:
            case 0x6D:
            case 0x6E:
            case 0x6F:
            case 0x70:
            case 0x71:
            case 0x72:
            case 0x73:
            case 0x74:
            case 0x75:
            case 0x76:
            case 0x77:
            case 0x78: // UTF-8 string (one-byte uint8_t for n follows)
            case 0x79: // UTF-8 string (two-byte uint16_t for n follow)
            case 0x7A: // UTF-8 string (four-byte uint32_t for n follow)
            case 0x7B: // UTF-8 string (eight-byte uint64_t for n follow)
            case 0x7F: // UTF-8 string (indefinite length)
            {
                string_t s;
                return get_cbor_string(s) and sax->string(s);
            }

            // array (0x00..0x17 data items follow)
            case 0x80:
            case 0x81:
            case 0x82:
            case 0x83:
            case 0x84:
            case 0x85:
            case 0x86:
            case 0x87:
            case 0x88:
            case 0x89:
            case 0x8A:
            case 0x8B:
            case 0x8C:
            case 0x8D:
            case 0x8E:
            case 0x8F:
            case 0x90:
            case 0x91:
            case 0x92:
            case 0x93:
            case 0x94:
            case 0x95:
            case 0x96:
            case 0x97:
                return get_cbor_array(static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x1Fu));

            case 0x98: // array (one-byte uint8_t for n follows)
            {
                std::uint8_t len;
                return get_number(input_format_t::cbor, len) and get_cbor_array(static_cast<std::size_t>(len));
            }

            case 0x99: // array (two-byte uint16_t for n follow)
            {
                std::uint16_t len;
                return get_number(input_format_t::cbor, len) and get_cbor_array(static_cast<std::size_t>(len));
            }

            case 0x9A: // array (four-byte uint32_t for n follow)
            {
                std::uint32_t len;
                return get_number(input_format_t::cbor, len) and get_cbor_array(static_cast<std::size_t>(len));
            }

            case 0x9B: // array (eight-byte uint64_t for n follow)
            {
                std::uint64_t len;
                return get_number(input_format_t::cbor, len) and get_cbor_array(static_cast<std::size_t>(len));
            }

            case 0x9F: // array (indefinite length)
                return get_cbor_array(std::size_t(-1));

            // map (0x00..0x17 pairs of data items follow)
            case 0xA0:
            case 0xA1:
            case 0xA2:
            case 0xA3:
            case 0xA4:
            case 0xA5:
            case 0xA6:
            case 0xA7:
            case 0xA8:
            case 0xA9:
            case 0xAA:
            case 0xAB:
            case 0xAC:
            case 0xAD:
            case 0xAE:
            case 0xAF:
            case 0xB0:
            case 0xB1:
            case 0xB2:
            case 0xB3:
            case 0xB4:
            case 0xB5:
            case 0xB6:
            case 0xB7:
                return get_cbor_object(static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x1Fu));

            case 0xB8: // map (one-byte uint8_t for n follows)
            {
                std::uint8_t len;
                return get_number(input_format_t::cbor, len) and get_cbor_object(static_cast<std::size_t>(len));
            }

            case 0xB9: // map (two-byte uint16_t for n follow)
            {
                std::uint16_t len;
                return get_number(input_format_t::cbor, len) and get_cbor_object(static_cast<std::size_t>(len));
            }

            case 0xBA: // map (four-byte uint32_t for n follow)
            {
                std::uint32_t len;
                return get_number(input_format_t::cbor, len) and get_cbor_object(static_cast<std::size_t>(len));
            }

            case 0xBB: // map (eight-byte uint64_t for n follow)
            {
                std::uint64_t len;
                return get_number(input_format_t::cbor, len) and get_cbor_object(static_cast<std::size_t>(len));
            }

            case 0xBF: // map (indefinite length)
                return get_cbor_object(std::size_t(-1));

            case 0xF4: // false
                return sax->boolean(false);

            case 0xF5: // true
                return sax->boolean(true);

            case 0xF6: // null
                return sax->null();

            case 0xF9: // Half-Precision Float (two-byte IEEE 754)
            {
                const int byte1_raw = get();
                if (JSON_UNLIKELY(not unexpect_eof(input_format_t::cbor, "number")))
                {
                    return false;
                }
                const int byte2_raw = get();
                if (JSON_UNLIKELY(not unexpect_eof(input_format_t::cbor, "number")))
                {
                    return false;
                }

                const auto byte1 = static_cast<unsigned char>(byte1_raw);
                const auto byte2 = static_cast<unsigned char>(byte2_raw);

                // code from RFC 7049, Appendix D, Figure 3:
                // As half-precision floating-point numbers were only added
                // to IEEE 754 in 2008, today's programming platforms often
                // still only have limited support for them. It is very
                // easy to include at least decoding support for them even
                // without such support. An example of a small decoder for
                // half-precision floating-point numbers in the C language
                // is shown in Fig. 3.
                const auto half = static_cast<unsigned int>((byte1 << 8u) + byte2);
                const double val = [&half]
                {
                    const int exp = (half >> 10u) & 0x1Fu;
                    const unsigned int mant = half & 0x3FFu;
                    assert(0 <= exp and exp <= 32);
                    assert(0 <= mant and mant <= 1024);
                    switch (exp)
                    {
                        case 0:
                            return std::ldexp(mant, -24);
                        case 31:
                            return (mant == 0)
                            ? std::numeric_limits<double>::infinity()
                            : std::numeric_limits<double>::quiet_NaN();
                        default:
                            return std::ldexp(mant + 1024, exp - 25);
                    }
                }();
                return sax->number_float((half & 0x8000u) != 0
                                         ? static_cast<number_float_t>(-val)
                                         : static_cast<number_float_t>(val), "");
            }

            case 0xFA: // Single-Precision Float (four-byte IEEE 754)
            {
                float number;
                return get_number(input_format_t::cbor, number) and sax->number_float(static_cast<number_float_t>(number), "");
            }

            case 0xFB: // Double-Precision Float (eight-byte IEEE 754)
            {
                double number;
                return get_number(input_format_t::cbor, number) and sax->number_float(static_cast<number_float_t>(number), "");
            }

            default: // anything else (0xFF is handled inside the other types)
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::cbor, "invalid byte: 0x" + last_token, "value")));
            }
        }
    }

    /*!
    @brief reads a CBOR string

    This function first reads starting bytes to determine the expected
    string length and then copies this number of bytes into a string.
    Additionally, CBOR's strings with indefinite lengths are supported.

    @param[out] result  created string

    @return whether string creation completed
    */
    bool get_cbor_string(string_t& result)
    {
        if (JSON_UNLIKELY(not unexpect_eof(input_format_t::cbor, "string")))
        {
            return false;
        }

        switch (current)
        {
            // UTF-8 string (0x00..0x17 bytes follow)
            case 0x60:
            case 0x61:
            case 0x62:
            case 0x63:
            case 0x64:
            case 0x65:
            case 0x66:
            case 0x67:
            case 0x68:
            case 0x69:
            case 0x6A:
            case 0x6B:
            case 0x6C:
            case 0x6D:
            case 0x6E:
            case 0x6F:
            case 0x70:
            case 0x71:
            case 0x72:
            case 0x73:
            case 0x74:
            case 0x75:
            case 0x76:
            case 0x77:
            {
                return get_string(input_format_t::cbor, static_cast<unsigned int>(current) & 0x1Fu, result);
            }

            case 0x78: // UTF-8 string (one-byte uint8_t for n follows)
            {
                std::uint8_t len;
                return get_number(input_format_t::cbor, len) and get_string(input_format_t::cbor, len, result);
            }

            case 0x79: // UTF-8 string (two-byte uint16_t for n follow)
            {
                std::uint16_t len;
                return get_number(input_format_t::cbor, len) and get_string(input_format_t::cbor, len, result);
            }

            case 0x7A: // UTF-8 string (four-byte uint32_t for n follow)
            {
                std::uint32_t len;
                return get_number(input_format_t::cbor, len) and get_string(input_format_t::cbor, len, result);
            }

            case 0x7B: // UTF-8 string (eight-byte uint64_t for n follow)
            {
                std::uint64_t len;
                return get_number(input_format_t::cbor, len) and get_string(input_format_t::cbor, len, result);
            }

            case 0x7F: // UTF-8 string (indefinite length)
            {
                while (get() != 0xFF)
                {
                    string_t chunk;
                    if (not get_cbor_string(chunk))
                    {
                        return false;
                    }
                    result.append(chunk);
                }
                return true;
            }

            default:
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::cbor, "expected length specification (0x60-0x7B) or indefinite string type (0x7F); last byte: 0x" + last_token, "string")));
            }
        }
    }

    /*!
    @param[in] len  the length of the array or std::size_t(-1) for an
                    array of indefinite size
    @return whether array creation completed
    */
    bool get_cbor_array(const std::size_t len)
    {
        if (JSON_UNLIKELY(not sax->start_array(len)))
        {
            return false;
        }

        if (len != std::size_t(-1))
        {
            for (std::size_t i = 0; i < len; ++i)
            {
                if (JSON_UNLIKELY(not parse_cbor_internal()))
                {
                    return false;
                }
            }
        }
        else
        {
            while (get() != 0xFF)
            {
                if (JSON_UNLIKELY(not parse_cbor_internal(false)))
                {
                    return false;
                }
            }
        }

        return sax->end_array();
    }

    /*!
    @param[in] len  the length of the object or std::size_t(-1) for an
                    object of indefinite size
    @return whether object creation completed
    */
    bool get_cbor_object(const std::size_t len)
    {
        if (JSON_UNLIKELY(not sax->start_object(len)))
        {
            return false;
        }

        string_t key;
        if (len != std::size_t(-1))
        {
            for (std::size_t i = 0; i < len; ++i)
            {
                get();
                if (JSON_UNLIKELY(not get_cbor_string(key) or not sax->key(key)))
                {
                    return false;
                }

                if (JSON_UNLIKELY(not parse_cbor_internal()))
                {
                    return false;
                }
                key.clear();
            }
        }
        else
        {
            while (get() != 0xFF)
            {
                if (JSON_UNLIKELY(not get_cbor_string(key) or not sax->key(key)))
                {
                    return false;
                }

                if (JSON_UNLIKELY(not parse_cbor_internal()))
                {
                    return false;
                }
                key.clear();
            }
        }

        return sax->end_object();
    }

    /////////////
    // MsgPack //
    /////////////

    /*!
    @return whether a valid MessagePack value was passed to the SAX parser
    */
    bool parse_msgpack_internal()
    {
        switch (get())
        {
            // EOF
            case std::char_traits<char>::eof():
                return unexpect_eof(input_format_t::msgpack, "value");

            // positive fixint
            case 0x00:
            case 0x01:
            case 0x02:
            case 0x03:
            case 0x04:
            case 0x05:
            case 0x06:
            case 0x07:
            case 0x08:
            case 0x09:
            case 0x0A:
            case 0x0B:
            case 0x0C:
            case 0x0D:
            case 0x0E:
            case 0x0F:
            case 0x10:
            case 0x11:
            case 0x12:
            case 0x13:
            case 0x14:
            case 0x15:
            case 0x16:
            case 0x17:
            case 0x18:
            case 0x19:
            case 0x1A:
            case 0x1B:
            case 0x1C:
            case 0x1D:
            case 0x1E:
            case 0x1F:
            case 0x20:
            case 0x21:
            case 0x22:
            case 0x23:
            case 0x24:
            case 0x25:
            case 0x26:
            case 0x27:
            case 0x28:
            case 0x29:
            case 0x2A:
            case 0x2B:
            case 0x2C:
            case 0x2D:
            case 0x2E:
            case 0x2F:
            case 0x30:
            case 0x31:
            case 0x32:
            case 0x33:
            case 0x34:
            case 0x35:
            case 0x36:
            case 0x37:
            case 0x38:
            case 0x39:
            case 0x3A:
            case 0x3B:
            case 0x3C:
            case 0x3D:
            case 0x3E:
            case 0x3F:
            case 0x40:
            case 0x41:
            case 0x42:
            case 0x43:
            case 0x44:
            case 0x45:
            case 0x46:
            case 0x47:
            case 0x48:
            case 0x49:
            case 0x4A:
            case 0x4B:
            case 0x4C:
            case 0x4D:
            case 0x4E:
            case 0x4F:
            case 0x50:
            case 0x51:
            case 0x52:
            case 0x53:
            case 0x54:
            case 0x55:
            case 0x56:
            case 0x57:
            case 0x58:
            case 0x59:
            case 0x5A:
            case 0x5B:
            case 0x5C:
            case 0x5D:
            case 0x5E:
            case 0x5F:
            case 0x60:
            case 0x61:
            case 0x62:
            case 0x63:
            case 0x64:
            case 0x65:
            case 0x66:
            case 0x67:
            case 0x68:
            case 0x69:
            case 0x6A:
            case 0x6B:
            case 0x6C:
            case 0x6D:
            case 0x6E:
            case 0x6F:
            case 0x70:
            case 0x71:
            case 0x72:
            case 0x73:
            case 0x74:
            case 0x75:
            case 0x76:
            case 0x77:
            case 0x78:
            case 0x79:
            case 0x7A:
            case 0x7B:
            case 0x7C:
            case 0x7D:
            case 0x7E:
            case 0x7F:
                return sax->number_unsigned(static_cast<number_unsigned_t>(current));

            // fixmap
            case 0x80:
            case 0x81:
            case 0x82:
            case 0x83:
            case 0x84:
            case 0x85:
            case 0x86:
            case 0x87:
            case 0x88:
            case 0x89:
            case 0x8A:
            case 0x8B:
            case 0x8C:
            case 0x8D:
            case 0x8E:
            case 0x8F:
                return get_msgpack_object(static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x0Fu));

            // fixarray
            case 0x90:
            case 0x91:
            case 0x92:
            case 0x93:
            case 0x94:
            case 0x95:
            case 0x96:
            case 0x97:
            case 0x98:
            case 0x99:
            case 0x9A:
            case 0x9B:
            case 0x9C:
            case 0x9D:
            case 0x9E:
            case 0x9F:
                return get_msgpack_array(static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x0Fu));

            // fixstr
            case 0xA0:
            case 0xA1:
            case 0xA2:
            case 0xA3:
            case 0xA4:
            case 0xA5:
            case 0xA6:
            case 0xA7:
            case 0xA8:
            case 0xA9:
            case 0xAA:
            case 0xAB:
            case 0xAC:
            case 0xAD:
            case 0xAE:
            case 0xAF:
            case 0xB0:
            case 0xB1:
            case 0xB2:
            case 0xB3:
            case 0xB4:
            case 0xB5:
            case 0xB6:
            case 0xB7:
            case 0xB8:
            case 0xB9:
            case 0xBA:
            case 0xBB:
            case 0xBC:
            case 0xBD:
            case 0xBE:
            case 0xBF:
            {
                string_t s;
                return get_msgpack_string(s) and sax->string(s);
            }

            case 0xC0: // nil
                return sax->null();

            case 0xC2: // false
                return sax->boolean(false);

            case 0xC3: // true
                return sax->boolean(true);

            case 0xCA: // float 32
            {
                float number;
                return get_number(input_format_t::msgpack, number) and sax->number_float(static_cast<number_float_t>(number), "");
            }

            case 0xCB: // float 64
            {
                double number;
                return get_number(input_format_t::msgpack, number) and sax->number_float(static_cast<number_float_t>(number), "");
            }

            case 0xCC: // uint 8
            {
                std::uint8_t number;
                return get_number(input_format_t::msgpack, number) and sax->number_unsigned(number);
            }

            case 0xCD: // uint 16
            {
                std::uint16_t number;
                return get_number(input_format_t::msgpack, number) and sax->number_unsigned(number);
            }

            case 0xCE: // uint 32
            {
                std::uint32_t number;
                return get_number(input_format_t::msgpack, number) and sax->number_unsigned(number);
            }

            case 0xCF: // uint 64
            {
                std::uint64_t number;
                return get_number(input_format_t::msgpack, number) and sax->number_unsigned(number);
            }

            case 0xD0: // int 8
            {
                std::int8_t number;
                return get_number(input_format_t::msgpack, number) and sax->number_integer(number);
            }

            case 0xD1: // int 16
            {
                std::int16_t number;
                return get_number(input_format_t::msgpack, number) and sax->number_integer(number);
            }

            case 0xD2: // int 32
            {
                std::int32_t number;
                return get_number(input_format_t::msgpack, number) and sax->number_integer(number);
            }

            case 0xD3: // int 64
            {
                std::int64_t number;
                return get_number(input_format_t::msgpack, number) and sax->number_integer(number);
            }

            case 0xD9: // str 8
            case 0xDA: // str 16
            case 0xDB: // str 32
            {
                string_t s;
                return get_msgpack_string(s) and sax->string(s);
            }

            case 0xDC: // array 16
            {
                std::uint16_t len;
                return get_number(input_format_t::msgpack, len) and get_msgpack_array(static_cast<std::size_t>(len));
            }

            case 0xDD: // array 32
            {
                std::uint32_t len;
                return get_number(input_format_t::msgpack, len) and get_msgpack_array(static_cast<std::size_t>(len));
            }

            case 0xDE: // map 16
            {
                std::uint16_t len;
                return get_number(input_format_t::msgpack, len) and get_msgpack_object(static_cast<std::size_t>(len));
            }

            case 0xDF: // map 32
            {
                std::uint32_t len;
                return get_number(input_format_t::msgpack, len) and get_msgpack_object(static_cast<std::size_t>(len));
            }

            // negative fixint
            case 0xE0:
            case 0xE1:
            case 0xE2:
            case 0xE3:
            case 0xE4:
            case 0xE5:
            case 0xE6:
            case 0xE7:
            case 0xE8:
            case 0xE9:
            case 0xEA:
            case 0xEB:
            case 0xEC:
            case 0xED:
            case 0xEE:
            case 0xEF:
            case 0xF0:
            case 0xF1:
            case 0xF2:
            case 0xF3:
            case 0xF4:
            case 0xF5:
            case 0xF6:
            case 0xF7:
            case 0xF8:
            case 0xF9:
            case 0xFA:
            case 0xFB:
            case 0xFC:
            case 0xFD:
            case 0xFE:
            case 0xFF:
                return sax->number_integer(static_cast<std::int8_t>(current));

            default: // anything else
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::msgpack, "invalid byte: 0x" + last_token, "value")));
            }
        }
    }

    /*!
    @brief reads a MessagePack string

    This function first reads starting bytes to determine the expected
    string length and then copies this number of bytes into a string.

    @param[out] result  created string

    @return whether string creation completed
    */
    bool get_msgpack_string(string_t& result)
    {
        if (JSON_UNLIKELY(not unexpect_eof(input_format_t::msgpack, "string")))
        {
            return false;
        }

        switch (current)
        {
            // fixstr
            case 0xA0:
            case 0xA1:
            case 0xA2:
            case 0xA3:
            case 0xA4:
            case 0xA5:
            case 0xA6:
            case 0xA7:
            case 0xA8:
            case 0xA9:
            case 0xAA:
            case 0xAB:
            case 0xAC:
            case 0xAD:
            case 0xAE:
            case 0xAF:
            case 0xB0:
            case 0xB1:
            case 0xB2:
            case 0xB3:
            case 0xB4:
            case 0xB5:
            case 0xB6:
            case 0xB7:
            case 0xB8:
            case 0xB9:
            case 0xBA:
            case 0xBB:
            case 0xBC:
            case 0xBD:
            case 0xBE:
            case 0xBF:
            {
                return get_string(input_format_t::msgpack, static_cast<unsigned int>(current) & 0x1Fu, result);
            }

            case 0xD9: // str 8
            {
                std::uint8_t len;
                return get_number(input_format_t::msgpack, len) and get_string(input_format_t::msgpack, len, result);
            }

            case 0xDA: // str 16
            {
                std::uint16_t len;
                return get_number(input_format_t::msgpack, len) and get_string(input_format_t::msgpack, len, result);
            }

            case 0xDB: // str 32
            {
                std::uint32_t len;
                return get_number(input_format_t::msgpack, len) and get_string(input_format_t::msgpack, len, result);
            }

            default:
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::msgpack, "expected length specification (0xA0-0xBF, 0xD9-0xDB); last byte: 0x" + last_token, "string")));
            }
        }
    }

    /*!
    @param[in] len  the length of the array
    @return whether array creation completed
    */
    bool get_msgpack_array(const std::size_t len)
    {
        if (JSON_UNLIKELY(not sax->start_array(len)))
        {
            return false;
        }

        for (std::size_t i = 0; i < len; ++i)
        {
            if (JSON_UNLIKELY(not parse_msgpack_internal()))
            {
                return false;
            }
        }

        return sax->end_array();
    }

    /*!
    @param[in] len  the length of the object
    @return whether object creation completed
    */
    bool get_msgpack_object(const std::size_t len)
    {
        if (JSON_UNLIKELY(not sax->start_object(len)))
        {
            return false;
        }

        string_t key;
        for (std::size_t i = 0; i < len; ++i)
        {
            get();
            if (JSON_UNLIKELY(not get_msgpack_string(key) or not sax->key(key)))
            {
                return false;
            }

            if (JSON_UNLIKELY(not parse_msgpack_internal()))
            {
                return false;
            }
            key.clear();
        }

        return sax->end_object();
    }

    ////////////
    // UBJSON //
    ////////////

    /*!
    @param[in] get_char  whether a new character should be retrieved from the
                         input (true, default) or whether the last read
                         character should be considered instead

    @return whether a valid UBJSON value was passed to the SAX parser
    */
    bool parse_ubjson_internal(const bool get_char = true)
    {
        return get_ubjson_value(get_char ? get_ignore_noop() : current);
    }

    /*!
    @brief reads a UBJSON string

    This function is either called after reading the 'S' byte explicitly
    indicating a string, or in case of an object key where the 'S' byte can be
    left out.

    @param[out] result   created string
    @param[in] get_char  whether a new character should be retrieved from the
                         input (true, default) or whether the last read
                         character should be considered instead

    @return whether string creation completed
    */
    bool get_ubjson_string(string_t& result, const bool get_char = true)
    {
        if (get_char)
        {
            get();  // TODO(niels): may we ignore N here?
        }

        if (JSON_UNLIKELY(not unexpect_eof(input_format_t::ubjson, "value")))
        {
            return false;
        }

        switch (current)
        {
            case 'U':
            {
                std::uint8_t len;
                return get_number(input_format_t::ubjson, len) and get_string(input_format_t::ubjson, len, result);
            }

            case 'i':
            {
                std::int8_t len;
                return get_number(input_format_t::ubjson, len) and get_string(input_format_t::ubjson, len, result);
            }

            case 'I':
            {
                std::int16_t len;
                return get_number(input_format_t::ubjson, len) and get_string(input_format_t::ubjson, len, result);
            }

            case 'l':
            {
                std::int32_t len;
                return get_number(input_format_t::ubjson, len) and get_string(input_format_t::ubjson, len, result);
            }

            case 'L':
            {
                std::int64_t len;
                return get_number(input_format_t::ubjson, len) and get_string(input_format_t::ubjson, len, result);
            }

            default:
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::ubjson, "expected length type specification (U, i, I, l, L); last byte: 0x" + last_token, "string")));
        }
    }

    /*!
    @param[out] result  determined size
    @return whether size determination completed
    */
    bool get_ubjson_size_value(std::size_t& result)
    {
        switch (get_ignore_noop())
        {
            case 'U':
            {
                std::uint8_t number;
                if (JSON_UNLIKELY(not get_number(input_format_t::ubjson, number)))
                {
                    return false;
                }
                result = static_cast<std::size_t>(number);
                return true;
            }

            case 'i':
            {
                std::int8_t number;
                if (JSON_UNLIKELY(not get_number(input_format_t::ubjson, number)))
                {
                    return false;
                }
                result = static_cast<std::size_t>(number);
                return true;
            }

            case 'I':
            {
                std::int16_t number;
                if (JSON_UNLIKELY(not get_number(input_format_t::ubjson, number)))
                {
                    return false;
                }
                result = static_cast<std::size_t>(number);
                return true;
            }

            case 'l':
            {
                std::int32_t number;
                if (JSON_UNLIKELY(not get_number(input_format_t::ubjson, number)))
                {
                    return false;
                }
                result = static_cast<std::size_t>(number);
                return true;
            }

            case 'L':
            {
                std::int64_t number;
                if (JSON_UNLIKELY(not get_number(input_format_t::ubjson, number)))
                {
                    return false;
                }
                result = static_cast<std::size_t>(number);
                return true;
            }

            default:
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::ubjson, "expected length type specification (U, i, I, l, L) after '#'; last byte: 0x" + last_token, "size")));
            }
        }
    }

    /*!
    @brief determine the type and size for a container

    In the optimized UBJSON format, a type and a size can be provided to allow
    for a more compact representation.

    @param[out] result  pair of the size and the type

    @return whether pair creation completed
    */
    bool get_ubjson_size_type(std::pair<std::size_t, int>& result)
    {
        result.first = string_t::npos; // size
        result.second = 0; // type

        get_ignore_noop();

        if (current == '$')
        {
            result.second = get();  // must not ignore 'N', because 'N' maybe the type
            if (JSON_UNLIKELY(not unexpect_eof(input_format_t::ubjson, "type")))
            {
                return false;
            }

            get_ignore_noop();
            if (JSON_UNLIKELY(current != '#'))
            {
                if (JSON_UNLIKELY(not unexpect_eof(input_format_t::ubjson, "value")))
                {
                    return false;
                }
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::ubjson, "expected '#' after type information; last byte: 0x" + last_token, "size")));
            }

            return get_ubjson_size_value(result.first);
        }

        if (current == '#')
        {
            return get_ubjson_size_value(result.first);
        }

        return true;
    }

    /*!
    @param prefix  the previously read or set type prefix
    @return whether value creation completed
    */
    bool get_ubjson_value(const int prefix)
    {
        switch (prefix)
        {
            case std::char_traits<char>::eof():  // EOF
                return unexpect_eof(input_format_t::ubjson, "value");

            case 'T':  // true
                return sax->boolean(true);
            case 'F':  // false
                return sax->boolean(false);

            case 'Z':  // null
                return sax->null();

            case 'U':
            {
                std::uint8_t number;
                return get_number(input_format_t::ubjson, number) and sax->number_unsigned(number);
            }

            case 'i':
            {
                std::int8_t number;
                return get_number(input_format_t::ubjson, number) and sax->number_integer(number);
            }

            case 'I':
            {
                std::int16_t number;
                return get_number(input_format_t::ubjson, number) and sax->number_integer(number);
            }

            case 'l':
            {
                std::int32_t number;
                return get_number(input_format_t::ubjson, number) and sax->number_integer(number);
            }

            case 'L':
            {
                std::int64_t number;
                return get_number(input_format_t::ubjson, number) and sax->number_integer(number);
            }

            case 'd':
            {
                float number;
                return get_number(input_format_t::ubjson, number) and sax->number_float(static_cast<number_float_t>(number), "");
            }

            case 'D':
            {
                double number;
                return get_number(input_format_t::ubjson, number) and sax->number_float(static_cast<number_float_t>(number), "");
            }

            case 'C':  // char
            {
                get();
                if (JSON_UNLIKELY(not unexpect_eof(input_format_t::ubjson, "char")))
                {
                    return false;
                }
                if (JSON_UNLIKELY(current > 127))
                {
                    auto last_token = get_token_string();
                    return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::ubjson, "byte after 'C' must be in range 0x00..0x7F; last byte: 0x" + last_token, "char")));
                }
                string_t s(1, static_cast<char>(current));
                return sax->string(s);
            }

            case 'S':  // string
            {
                string_t s;
                return get_ubjson_string(s) and sax->string(s);
            }

            case '[':  // array
                return get_ubjson_array();

            case '{':  // object
                return get_ubjson_object();

            default: // anything else
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::ubjson, "invalid byte: 0x" + last_token, "value")));
            }
        }
    }

    /*!
    @return whether array creation completed
    */
    bool get_ubjson_array()
    {
        std::pair<std::size_t, int> size_and_type;
        if (JSON_UNLIKELY(not get_ubjson_size_type(size_and_type)))
        {
            return false;
        }

        if (size_and_type.first != string_t::npos)
        {
            if (JSON_UNLIKELY(not sax->start_array(size_and_type.first)))
            {
                return false;
            }

            if (size_and_type.second != 0)
            {
                if (size_and_type.second != 'N')
                {
                    for (std::size_t i = 0; i < size_and_type.first; ++i)
                    {
                        if (JSON_UNLIKELY(not get_ubjson_value(size_and_type.second)))
                        {
                            return false;
                        }
                    }
                }
            }
            else
            {
                for (std::size_t i = 0; i < size_and_type.first; ++i)
                {
                    if (JSON_UNLIKELY(not parse_ubjson_internal()))
                    {
                        return false;
                    }
                }
            }
        }
        else
        {
            if (JSON_UNLIKELY(not sax->start_array(std::size_t(-1))))
            {
                return false;
            }

            while (current != ']')
            {
                if (JSON_UNLIKELY(not parse_ubjson_internal(false)))
                {
                    return false;
                }
                get_ignore_noop();
            }
        }

        return sax->end_array();
    }

    /*!
    @return whether object creation completed
    */
    bool get_ubjson_object()
    {
        std::pair<std::size_t, int> size_and_type;
        if (JSON_UNLIKELY(not get_ubjson_size_type(size_and_type)))
        {
            return false;
        }

        string_t key;
        if (size_and_type.first != string_t::npos)
        {
            if (JSON_UNLIKELY(not sax->start_object(size_and_type.first)))
            {
                return false;
            }

            if (size_and_type.second != 0)
            {
                for (std::size_t i = 0; i < size_and_type.first; ++i)
                {
                    if (JSON_UNLIKELY(not get_ubjson_string(key) or not sax->key(key)))
                    {
                        return false;
                    }
                    if (JSON_UNLIKELY(not get_ubjson_value(size_and_type.second)))
                    {
                        return false;
                    }
                    key.clear();
                }
            }
            else
            {
                for (std::size_t i = 0; i < size_and_type.first; ++i)
                {
                    if (JSON_UNLIKELY(not get_ubjson_string(key) or not sax->key(key)))
                    {
                        return false;
                    }
                    if (JSON_UNLIKELY(not parse_ubjson_internal()))
                    {
                        return false;
                    }
                    key.clear();
                }
            }
        }
        else
        {
            if (JSON_UNLIKELY(not sax->start_object(std::size_t(-1))))
            {
                return false;
            }

            while (current != '}')
            {
                if (JSON_UNLIKELY(not get_ubjson_string(key, false) or not sax->key(key)))
                {
                    return false;
                }
                if (JSON_UNLIKELY(not parse_ubjson_internal()))
                {
                    return false;
                }
                get_ignore_noop();
                key.clear();
            }
        }

        return sax->end_object();
    }

    ///////////////////////
    // Utility functions //
    ///////////////////////

    /*!
    @brief get next character from the input

    This function provides the interface to the used input adapter. It does
    not throw in case the input reached EOF, but returns a -'ve valued
    `std::char_traits<char>::eof()` in that case.

    @return character read from the input
    */
    int get()
    {
        ++chars_read;
        return current = ia->get_character();
    }

    /*!
    @return character read from the input after ignoring all 'N' entries
    */
    int get_ignore_noop()
    {
        do
        {
            get();
        }
        while (current == 'N');

        return current;
    }

    /*
    @brief read a number from the input

    @tparam NumberType the type of the number
    @param[in] format   the current format (for diagnostics)
    @param[out] result  number of type @a NumberType

    @return whether conversion completed

    @note This function needs to respect the system's endianess, because
          bytes in CBOR, MessagePack, and UBJSON are stored in network order
          (big endian) and therefore need reordering on little endian systems.
    */
    template<typename NumberType, bool InputIsLittleEndian = false>
    bool get_number(const input_format_t format, NumberType& result)
    {
        // step 1: read input into array with system's byte order
        std::array<std::uint8_t, sizeof(NumberType)> vec;
        for (std::size_t i = 0; i < sizeof(NumberType); ++i)
        {
            get();
            if (JSON_UNLIKELY(not unexpect_eof(format, "number")))
            {
                return false;
            }

            // reverse byte order prior to conversion if necessary
            if (is_little_endian != InputIsLittleEndian)
            {
                vec[sizeof(NumberType) - i - 1] = static_cast<std::uint8_t>(current);
            }
            else
            {
                vec[i] = static_cast<std::uint8_t>(current); // LCOV_EXCL_LINE
            }
        }

        // step 2: convert array into number of type T and return
        std::memcpy(&result, vec.data(), sizeof(NumberType));
        return true;
    }

    /*!
    @brief create a string by reading characters from the input

    @tparam NumberType the type of the number
    @param[in] format the current format (for diagnostics)
    @param[in] len number of characters to read
    @param[out] result string created by reading @a len bytes

    @return whether string creation completed

    @note We can not reserve @a len bytes for the result, because @a len
          may be too large. Usually, @ref unexpect_eof() detects the end of
          the input before we run out of string memory.
    */
    template<typename NumberType>
    bool get_string(const input_format_t format,
                    const NumberType len,
                    string_t& result)
    {
        bool success = true;
        std::generate_n(std::back_inserter(result), len, [this, &success, &format]()
        {
            get();
            if (JSON_UNLIKELY(not unexpect_eof(format, "string")))
            {
                success = false;
            }
            return static_cast<char>(current);
        });
        return success;
    }

    /*!
    @param[in] format   the current format (for diagnostics)
    @param[in] context  further context information (for diagnostics)
    @return whether the last read character is not EOF
    */
    bool unexpect_eof(const input_format_t format, const char* context) const
    {
        if (JSON_UNLIKELY(current == std::char_traits<char>::eof()))
        {
            return sax->parse_error(chars_read, "<end of file>",
                                    parse_error::create(110, chars_read, exception_message(format, "unexpected end of input", context)));
        }
        return true;
    }

    /*!
    @return a string representation of the last read byte
    */
    std::string get_token_string() const
    {
        std::array<char, 3> cr{{}};
        (std::snprintf)(cr.data(), cr.size(), "%.2hhX", static_cast<unsigned char>(current));
        return std::string{cr.data()};
    }

    /*!
    @param[in] format   the current format
    @param[in] detail   a detailed error message
    @param[in] context  further contect information
    @return a message string to use in the parse_error exceptions
    */
    std::string exception_message(const input_format_t format,
                                  const std::string& detail,
                                  const std::string& context) const
    {
        std::string error_msg = "syntax error while parsing ";

        switch (format)
        {
            case input_format_t::cbor:
                error_msg += "CBOR";
                break;

            case input_format_t::msgpack:
                error_msg += "MessagePack";
                break;

            case input_format_t::ubjson:
                error_msg += "UBJSON";
                break;

            case input_format_t::bson:
                error_msg += "BSON";
                break;

            default:            // LCOV_EXCL_LINE
                assert(false);  // LCOV_EXCL_LINE
        }

        return error_msg + " " + context + ": " + detail;
    }

  private:
    /// input adapter
    input_adapter_t ia = nullptr;

    /// the current character
    int current = std::char_traits<char>::eof();

    /// the number of characters read
    std::size_t chars_read = 0;

    /// whether we can assume little endianess
    const bool is_little_endian = little_endianess();

    /// the SAX parser
    json_sax_t* sax = nullptr;
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/input/input_adapters.hpp>

// #include <nlohmann/detail/input/lexer.hpp>


#include <array> // array
#include <clocale> // localeconv
#include <cstddef> // size_t
#include <cstdio> // snprintf
#include <cstdlib> // strtof, strtod, strtold, strtoll, strtoull
#include <initializer_list> // initializer_list
#include <string> // char_traits, string
#include <utility> // move
#include <vector> // vector

// #include <nlohmann/detail/input/input_adapters.hpp>

// #include <nlohmann/detail/input/position_t.hpp>

// #include <nlohmann/detail/macro_scope.hpp>


namespace nlohmann
{
namespace detail
{
///////////
// lexer //
///////////

/*!
@brief lexical analysis

This class organizes the lexical analysis during JSON deserialization.
*/
template<typename BasicJsonType>
class lexer
{
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;

  public:
    /// token types for the parser
    enum class token_type
    {
        uninitialized,    ///< indicating the scanner is uninitialized
        literal_true,     ///< the `true` literal
        literal_false,    ///< the `false` literal
        literal_null,     ///< the `null` literal
        value_string,     ///< a string -- use get_string() for actual value
        value_unsigned,   ///< an unsigned integer -- use get_number_unsigned() for actual value
        value_integer,    ///< a signed integer -- use get_number_integer() for actual value
        value_float,      ///< an floating point number -- use get_number_float() for actual value
        begin_array,      ///< the character for array begin `[`
        begin_object,     ///< the character for object begin `{`
        end_array,        ///< the character for array end `]`
        end_object,       ///< the character for object end `}`
        name_separator,   ///< the name separator `:`
        value_separator,  ///< the value separator `,`
        parse_error,      ///< indicating a parse error
        end_of_input,     ///< indicating the end of the input buffer
        literal_or_value  ///< a literal or the begin of a value (only for diagnostics)
    };

    /// return name of values of type token_type (only used for errors)
    static const char* token_type_name(const token_type t) noexcept
    {
        switch (t)
        {
            case token_type::uninitialized:
                return "<uninitialized>";
            case token_type::literal_true:
                return "true literal";
            case token_type::literal_false:
                return "false literal";
            case token_type::literal_null:
                return "null literal";
            case token_type::value_string:
                return "string literal";
            case lexer::token_type::value_unsigned:
            case lexer::token_type::value_integer:
            case lexer::token_type::value_float:
                return "number literal";
            case token_type::begin_array:
                return "'['";
            case token_type::begin_object:
                return "'{'";
            case token_type::end_array:
                return "']'";
            case token_type::end_object:
                return "'}'";
            case token_type::name_separator:
                return "':'";
            case token_type::value_separator:
                return "','";
            case token_type::parse_error:
                return "<parse error>";
            case token_type::end_of_input:
                return "end of input";
            case token_type::literal_or_value:
                return "'[', '{', or a literal";
            // LCOV_EXCL_START
            default: // catch non-enum values
                return "unknown token";
                // LCOV_EXCL_STOP
        }
    }

    explicit lexer(detail::input_adapter_t&& adapter)
        : ia(std::move(adapter)), decimal_point_char(get_decimal_point()) {}

    // delete because of pointer members
    lexer(const lexer&) = delete;
    lexer(lexer&&) = delete;
    lexer& operator=(lexer&) = delete;
    lexer& operator=(lexer&&) = delete;
    ~lexer() = default;

  private:
    /////////////////////
    // locales
    /////////////////////

    /// return the locale-dependent decimal point
    static char get_decimal_point() noexcept
    {
        const auto loc = localeconv();
        assert(loc != nullptr);
        return (loc->decimal_point == nullptr) ? '.' : *(loc->decimal_point);
    }

    /////////////////////
    // scan functions
    /////////////////////

    /*!
    @brief get codepoint from 4 hex characters following `\u`

    For input "\u c1 c2 c3 c4" the codepoint is:
      (c1 * 0x1000) + (c2 * 0x0100) + (c3 * 0x0010) + c4
    = (c1 << 12) + (c2 << 8) + (c3 << 4) + (c4 << 0)

    Furthermore, the possible characters '0'..'9', 'A'..'F', and 'a'..'f'
    must be converted to the integers 0x0..0x9, 0xA..0xF, 0xA..0xF, resp. The
    conversion is done by subtracting the offset (0x30, 0x37, and 0x57)
    between the ASCII value of the character and the desired integer value.

    @return codepoint (0x0000..0xFFFF) or -1 in case of an error (e.g. EOF or
            non-hex character)
    */
    int get_codepoint()
    {
        // this function only makes sense after reading `\u`
        assert(current == 'u');
        int codepoint = 0;

        const auto factors = { 12u, 8u, 4u, 0u };
        for (const auto factor : factors)
        {
            get();

            if (current >= '0' and current <= '9')
            {
                codepoint += static_cast<int>((static_cast<unsigned int>(current) - 0x30u) << factor);
            }
            else if (current >= 'A' and current <= 'F')
            {
                codepoint += static_cast<int>((static_cast<unsigned int>(current) - 0x37u) << factor);
            }
            else if (current >= 'a' and current <= 'f')
            {
                codepoint += static_cast<int>((static_cast<unsigned int>(current) - 0x57u) << factor);
            }
            else
            {
                return -1;
            }
        }

        assert(0x0000 <= codepoint and codepoint <= 0xFFFF);
        return codepoint;
    }

    /*!
    @brief check if the next byte(s) are inside a given range

    Adds the current byte and, for each passed range, reads a new byte and
    checks if it is inside the range. If a violation was detected, set up an
    error message and return false. Otherwise, return true.

    @param[in] ranges  list of integers; interpreted as list of pairs of
                       inclusive lower and upper bound, respectively

    @pre The passed list @a ranges must have 2, 4, or 6 elements; that is,
         1, 2, or 3 pairs. This precondition is enforced by an assertion.

    @return true if and only if no range violation was detected
    */
    bool next_byte_in_range(std::initializer_list<int> ranges)
    {
        assert(ranges.size() == 2 or ranges.size() == 4 or ranges.size() == 6);
        add(current);

        for (auto range = ranges.begin(); range != ranges.end(); ++range)
        {
            get();
            if (JSON_LIKELY(*range <= current and current <= *(++range)))
            {
                add(current);
            }
            else
            {
                error_message = "invalid string: ill-formed UTF-8 byte";
                return false;
            }
        }

        return true;
    }

    /*!
    @brief scan a string literal

    This function scans a string according to Sect. 7 of RFC 7159. While
    scanning, bytes are escaped and copied into buffer token_buffer. Then the
    function returns successfully, token_buffer is *not* null-terminated (as it
    may contain \0 bytes), and token_buffer.size() is the number of bytes in the
    string.

    @return token_type::value_string if string could be successfully scanned,
            token_type::parse_error otherwise

    @note In case of errors, variable error_message contains a textual
          description.
    */
    token_type scan_string()
    {
        // reset token_buffer (ignore opening quote)
        reset();

        // we entered the function by reading an open quote
        assert(current == '\"');

        while (true)
        {
            // get next character
            switch (get())
            {
                // end of file while parsing string
                case std::char_traits<char>::eof():
                {
                    error_message = "invalid string: missing closing quote";
                    return token_type::parse_error;
                }

                // closing quote
                case '\"':
                {
                    return token_type::value_string;
                }

                // escapes
                case '\\':
                {
                    switch (get())
                    {
                        // quotation mark
                        case '\"':
                            add('\"');
                            break;
                        // reverse solidus
                        case '\\':
                            add('\\');
                            break;
                        // solidus
                        case '/':
                            add('/');
                            break;
                        // backspace
                        case 'b':
                            add('\b');
                            break;
                        // form feed
                        case 'f':
                            add('\f');
                            break;
                        // line feed
                        case 'n':
                            add('\n');
                            break;
                        // carriage return
                        case 'r':
                            add('\r');
                            break;
                        // tab
                        case 't':
                            add('\t');
                            break;

                        // unicode escapes
                        case 'u':
                        {
                            const int codepoint1 = get_codepoint();
                            int codepoint = codepoint1; // start with codepoint1

                            if (JSON_UNLIKELY(codepoint1 == -1))
                            {
                                error_message = "invalid string: '\\u' must be followed by 4 hex digits";
                                return token_type::parse_error;
                            }

                            // check if code point is a high surrogate
                            if (0xD800 <= codepoint1 and codepoint1 <= 0xDBFF)
                            {
                                // expect next \uxxxx entry
                                if (JSON_LIKELY(get() == '\\' and get() == 'u'))
                                {
                                    const int codepoint2 = get_codepoint();

                                    if (JSON_UNLIKELY(codepoint2 == -1))
                                    {
                                        error_message = "invalid string: '\\u' must be followed by 4 hex digits";
                                        return token_type::parse_error;
                                    }

                                    // check if codepoint2 is a low surrogate
                                    if (JSON_LIKELY(0xDC00 <= codepoint2 and codepoint2 <= 0xDFFF))
                                    {
                                        // overwrite codepoint
                                        codepoint = static_cast<int>(
                                                        // high surrogate occupies the most significant 22 bits
                                                        (static_cast<unsigned int>(codepoint1) << 10u)
                                                        // low surrogate occupies the least significant 15 bits
                                                        + static_cast<unsigned int>(codepoint2)
                                                        // there is still the 0xD800, 0xDC00 and 0x10000 noise
                                                        // in the result so we have to subtract with:
                                                        // (0xD800 << 10) + DC00 - 0x10000 = 0x35FDC00
                                                        - 0x35FDC00u);
                                    }
                                    else
                                    {
                                        error_message = "invalid string: surrogate U+DC00..U+DFFF must be followed by U+DC00..U+DFFF";
                                        return token_type::parse_error;
                                    }
                                }
                                else
                                {
                                    error_message = "invalid string: surrogate U+DC00..U+DFFF must be followed by U+DC00..U+DFFF";
                                    return token_type::parse_error;
                                }
                            }
                            else
                            {
                                if (JSON_UNLIKELY(0xDC00 <= codepoint1 and codepoint1 <= 0xDFFF))
                                {
                                    error_message = "invalid string: surrogate U+DC00..U+DFFF must follow U+D800..U+DBFF";
                                    return token_type::parse_error;
                                }
                            }

                            // result of the above calculation yields a proper codepoint
                            assert(0x00 <= codepoint and codepoint <= 0x10FFFF);

                            // translate codepoint into bytes
                            if (codepoint < 0x80)
                            {
                                // 1-byte characters: 0xxxxxxx (ASCII)
                                add(codepoint);
                            }
                            else if (codepoint <= 0x7FF)
                            {
                                // 2-byte characters: 110xxxxx 10xxxxxx
                                add(static_cast<int>(0xC0u | (static_cast<unsigned int>(codepoint) >> 6u)));
                                add(static_cast<int>(0x80u | (static_cast<unsigned int>(codepoint) & 0x3Fu)));
                            }
                            else if (codepoint <= 0xFFFF)
                            {
                                // 3-byte characters: 1110xxxx 10xxxxxx 10xxxxxx
                                add(static_cast<int>(0xE0u | (static_cast<unsigned int>(codepoint) >> 12u)));
                                add(static_cast<int>(0x80u | ((static_cast<unsigned int>(codepoint) >> 6u) & 0x3Fu)));
                                add(static_cast<int>(0x80u | (static_cast<unsigned int>(codepoint) & 0x3Fu)));
                            }
                            else
                            {
                                // 4-byte characters: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
                                add(static_cast<int>(0xF0u | (static_cast<unsigned int>(codepoint) >> 18u)));
                                add(static_cast<int>(0x80u | ((static_cast<unsigned int>(codepoint) >> 12u) & 0x3Fu)));
                                add(static_cast<int>(0x80u | ((static_cast<unsigned int>(codepoint) >> 6u) & 0x3Fu)));
                                add(static_cast<int>(0x80u | (static_cast<unsigned int>(codepoint) & 0x3Fu)));
                            }

                            break;
                        }

                        // other characters after escape
                        default:
                            error_message = "invalid string: forbidden character after backslash";
                            return token_type::parse_error;
                    }

                    break;
                }

                // invalid control characters
                case 0x00:
                {
                    error_message = "invalid string: control character U+0000 (NUL) must be escaped to \\u0000";
                    return token_type::parse_error;
                }

                case 0x01:
                {
                    error_message = "invalid string: control character U+0001 (SOH) must be escaped to \\u0001";
                    return token_type::parse_error;
                }

                case 0x02:
                {
                    error_message = "invalid string: control character U+0002 (STX) must be escaped to \\u0002";
                    return token_type::parse_error;
                }

                case 0x03:
                {
                    error_message = "invalid string: control character U+0003 (ETX) must be escaped to \\u0003";
                    return token_type::parse_error;
                }

                case 0x04:
                {
                    error_message = "invalid string: control character U+0004 (EOT) must be escaped to \\u0004";
                    return token_type::parse_error;
                }

                case 0x05:
                {
                    error_message = "invalid string: control character U+0005 (ENQ) must be escaped to \\u0005";
                    return token_type::parse_error;
                }

                case 0x06:
                {
                    error_message = "invalid string: control character U+0006 (ACK) must be escaped to \\u0006";
                    return token_type::parse_error;
                }

                case 0x07:
                {
                    error_message = "invalid string: control character U+0007 (BEL) must be escaped to \\u0007";
                    return token_type::parse_error;
                }

                case 0x08:
                {
                    error_message = "invalid string: control character U+0008 (BS) must be escaped to \\u0008 or \\b";
                    return token_type::parse_error;
                }

                case 0x09:
                {
                    error_message = "invalid string: control character U+0009 (HT) must be escaped to \\u0009 or \\t";
                    return token_type::parse_error;
                }

                case 0x0A:
                {
                    error_message = "invalid string: control character U+000A (LF) must be escaped to \\u000A or \\n";
                    return token_type::parse_error;
                }

                case 0x0B:
                {
                    error_message = "invalid string: control character U+000B (VT) must be escaped to \\u000B";
                    return token_type::parse_error;
                }

                case 0x0C:
                {
                    error_message = "invalid string: control character U+000C (FF) must be escaped to \\u000C or \\f";
                    return token_type::parse_error;
                }

                case 0x0D:
                {
                    error_message = "invalid string: control character U+000D (CR) must be escaped to \\u000D or \\r";
                    return token_type::parse_error;
                }

                case 0x0E:
                {
                    error_message = "invalid string: control character U+000E (SO) must be escaped to \\u000E";
                    return token_type::parse_error;
                }

                case 0x0F:
                {
                    error_message = "invalid string: control character U+000F (SI) must be escaped to \\u000F";
                    return token_type::parse_error;
                }

                case 0x10:
                {
                    error_message = "invalid string: control character U+0010 (DLE) must be escaped to \\u0010";
                    return token_type::parse_error;
                }

                case 0x11:
                {
                    error_message = "invalid string: control character U+0011 (DC1) must be escaped to \\u0011";
                    return token_type::parse_error;
                }

                case 0x12:
                {
                    error_message = "invalid string: control character U+0012 (DC2) must be escaped to \\u0012";
                    return token_type::parse_error;
                }

                case 0x13:
                {
                    error_message = "invalid string: control character U+0013 (DC3) must be escaped to \\u0013";
                    return token_type::parse_error;
                }

                case 0x14:
                {
                    error_message = "invalid string: control character U+0014 (DC4) must be escaped to \\u0014";
                    return token_type::parse_error;
                }

                case 0x15:
                {
                    error_message = "invalid string: control character U+0015 (NAK) must be escaped to \\u0015";
                    return token_type::parse_error;
                }

                case 0x16:
                {
                    error_message = "invalid string: control character U+0016 (SYN) must be escaped to \\u0016";
                    return token_type::parse_error;
                }

                case 0x17:
                {
                    error_message = "invalid string: control character U+0017 (ETB) must be escaped to \\u0017";
                    return token_type::parse_error;
                }

                case 0x18:
                {
                    error_message = "invalid string: control character U+0018 (CAN) must be escaped to \\u0018";
                    return token_type::parse_error;
                }

                case 0x19:
                {
                    error_message = "invalid string: control character U+0019 (EM) must be escaped to \\u0019";
                    return token_type::parse_error;
                }

                case 0x1A:
                {
                    error_message = "invalid string: control character U+001A (SUB) must be escaped to \\u001A";
                    return token_type::parse_error;
                }

                case 0x1B:
                {
                    error_message = "invalid string: control character U+001B (ESC) must be escaped to \\u001B";
                    return token_type::parse_error;
                }

                case 0x1C:
                {
                    error_message = "invalid string: control character U+001C (FS) must be escaped to \\u001C";
                    return token_type::parse_error;
                }

                case 0x1D:
                {
                    error_message = "invalid string: control character U+001D (GS) must be escaped to \\u001D";
                    return token_type::parse_error;
                }

                case 0x1E:
                {
                    error_message = "invalid string: control character U+001E (RS) must be escaped to \\u001E";
                    return token_type::parse_error;
                }

                case 0x1F:
                {
                    error_message = "invalid string: control character U+001F (US) must be escaped to \\u001F";
                    return token_type::parse_error;
                }

                // U+0020..U+007F (except U+0022 (quote) and U+005C (backspace))
                case 0x20:
                case 0x21:
                case 0x23:
                case 0x24:
                case 0x25:
                case 0x26:
                case 0x27:
                case 0x28:
                case 0x29:
                case 0x2A:
                case 0x2B:
                case 0x2C:
                case 0x2D:
                case 0x2E:
                case 0x2F:
                case 0x30:
                case 0x31:
                case 0x32:
                case 0x33:
                case 0x34:
                case 0x35:
                case 0x36:
                case 0x37:
                case 0x38:
                case 0x39:
                case 0x3A:
                case 0x3B:
                case 0x3C:
                case 0x3D:
                case 0x3E:
                case 0x3F:
                case 0x40:
                case 0x41:
                case 0x42:
                case 0x43:
                case 0x44:
                case 0x45:
                case 0x46:
                case 0x47:
                case 0x48:
                case 0x49:
                case 0x4A:
                case 0x4B:
                case 0x4C:
                case 0x4D:
                case 0x4E:
                case 0x4F:
                case 0x50:
                case 0x51:
                case 0x52:
                case 0x53:
                case 0x54:
                case 0x55:
                case 0x56:
                case 0x57:
                case 0x58:
                case 0x59:
                case 0x5A:
                case 0x5B:
                case 0x5D:
                case 0x5E:
                case 0x5F:
                case 0x60:
                case 0x61:
                case 0x62:
                case 0x63:
                case 0x64:
                case 0x65:
                case 0x66:
                case 0x67:
                case 0x68:
                case 0x69:
                case 0x6A:
                case 0x6B:
                case 0x6C:
                case 0x6D:
                case 0x6E:
                case 0x6F:
                case 0x70:
                case 0x71:
                case 0x72:
                case 0x73:
                case 0x74:
                case 0x75:
                case 0x76:
                case 0x77:
                case 0x78:
                case 0x79:
                case 0x7A:
                case 0x7B:
                case 0x7C:
                case 0x7D:
                case 0x7E:
                case 0x7F:
                {
                    add(current);
                    break;
                }

                // U+0080..U+07FF: bytes C2..DF 80..BF
                case 0xC2:
                case 0xC3:
                case 0xC4:
                case 0xC5:
                case 0xC6:
                case 0xC7:
                case 0xC8:
                case 0xC9:
                case 0xCA:
                case 0xCB:
                case 0xCC:
                case 0xCD:
                case 0xCE:
                case 0xCF:
                case 0xD0:
                case 0xD1:
                case 0xD2:
                case 0xD3:
                case 0xD4:
                case 0xD5:
                case 0xD6:
                case 0xD7:
                case 0xD8:
                case 0xD9:
                case 0xDA:
                case 0xDB:
                case 0xDC:
                case 0xDD:
                case 0xDE:
                case 0xDF:
                {
                    if (JSON_UNLIKELY(not next_byte_in_range({0x80, 0xBF})))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+0800..U+0FFF: bytes E0 A0..BF 80..BF
                case 0xE0:
                {
                    if (JSON_UNLIKELY(not (next_byte_in_range({0xA0, 0xBF, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+1000..U+CFFF: bytes E1..EC 80..BF 80..BF
                // U+E000..U+FFFF: bytes EE..EF 80..BF 80..BF
                case 0xE1:
                case 0xE2:
                case 0xE3:
                case 0xE4:
                case 0xE5:
                case 0xE6:
                case 0xE7:
                case 0xE8:
                case 0xE9:
                case 0xEA:
                case 0xEB:
                case 0xEC:
                case 0xEE:
                case 0xEF:
                {
                    if (JSON_UNLIKELY(not (next_byte_in_range({0x80, 0xBF, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+D000..U+D7FF: bytes ED 80..9F 80..BF
                case 0xED:
                {
                    if (JSON_UNLIKELY(not (next_byte_in_range({0x80, 0x9F, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+10000..U+3FFFF F0 90..BF 80..BF 80..BF
                case 0xF0:
                {
                    if (JSON_UNLIKELY(not (next_byte_in_range({0x90, 0xBF, 0x80, 0xBF, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+40000..U+FFFFF F1..F3 80..BF 80..BF 80..BF
                case 0xF1:
                case 0xF2:
                case 0xF3:
                {
                    if (JSON_UNLIKELY(not (next_byte_in_range({0x80, 0xBF, 0x80, 0xBF, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+100000..U+10FFFF F4 80..8F 80..BF 80..BF
                case 0xF4:
                {
                    if (JSON_UNLIKELY(not (next_byte_in_range({0x80, 0x8F, 0x80, 0xBF, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // remaining bytes (80..C1 and F5..FF) are ill-formed
                default:
                {
                    error_message = "invalid string: ill-formed UTF-8 byte";
                    return token_type::parse_error;
                }
            }
        }
    }

    static void strtof(float& f, const char* str, char** endptr) noexcept
    {
        f = std::strtof(str, endptr);
    }

    static void strtof(double& f, const char* str, char** endptr) noexcept
    {
        f = std::strtod(str, endptr);
    }

    static void strtof(long double& f, const char* str, char** endptr) noexcept
    {
        f = std::strtold(str, endptr);
    }

    /*!
    @brief scan a number literal

    This function scans a string according to Sect. 6 of RFC 7159.

    The function is realized with a deterministic finite state machine derived
    from the grammar described in RFC 7159. Starting in state "init", the
    input is read and used to determined the next state. Only state "done"
    accepts the number. State "error" is a trap state to model errors. In the
    table below, "anything" means any character but the ones listed before.

    state    | 0        | 1-9      | e E      | +       | -       | .        | anything
    ---------|----------|----------|----------|---------|---------|----------|-----------
    init     | zero     | any1     | [error]  | [error] | minus   | [error]  | [error]
    minus    | zero     | any1     | [error]  | [error] | [error] | [error]  | [error]
    zero     | done     | done     | exponent | done    | done    | decimal1 | done
    any1     | any1     | any1     | exponent | done    | done    | decimal1 | done
    decimal1 | decimal2 | [error]  | [error]  | [error] | [error] | [error]  | [error]
    decimal2 | decimal2 | decimal2 | exponent | done    | done    | done     | done
    exponent | any2     | any2     | [error]  | sign    | sign    | [error]  | [error]
    sign     | any2     | any2     | [error]  | [error] | [error] | [error]  | [error]
    any2     | any2     | any2     | done     | done    | done    | done     | done

    The state machine is realized with one label per state (prefixed with
    "scan_number_") and `goto` statements between them. The state machine
    contains cycles, but any cycle can be left when EOF is read. Therefore,
    the function is guaranteed to terminate.

    During scanning, the read bytes are stored in token_buffer. This string is
    then converted to a signed integer, an unsigned integer, or a
    floating-point number.

    @return token_type::value_unsigned, token_type::value_integer, or
            token_type::value_float if number could be successfully scanned,
            token_type::parse_error otherwise

    @note The scanner is independent of the current locale. Internally, the
          locale's decimal point is used instead of `.` to work with the
          locale-dependent converters.
    */
    token_type scan_number()  // lgtm [cpp/use-of-goto]
    {
        // reset token_buffer to store the number's bytes
        reset();

        // the type of the parsed number; initially set to unsigned; will be
        // changed if minus sign, decimal point or exponent is read
        token_type number_type = token_type::value_unsigned;

        // state (init): we just found out we need to scan a number
        switch (current)
        {
            case '-':
            {
                add(current);
                goto scan_number_minus;
            }

            case '0':
            {
                add(current);
                goto scan_number_zero;
            }

            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any1;
            }

            // all other characters are rejected outside scan_number()
            default:            // LCOV_EXCL_LINE
                assert(false);  // LCOV_EXCL_LINE
        }

scan_number_minus:
        // state: we just parsed a leading minus sign
        number_type = token_type::value_integer;
        switch (get())
        {
            case '0':
            {
                add(current);
                goto scan_number_zero;
            }

            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any1;
            }

            default:
            {
                error_message = "invalid number; expected digit after '-'";
                return token_type::parse_error;
            }
        }

scan_number_zero:
        // state: we just parse a zero (maybe with a leading minus sign)
        switch (get())
        {
            case '.':
            {
                add(decimal_point_char);
                goto scan_number_decimal1;
            }

            case 'e':
            case 'E':
            {
                add(current);
                goto scan_number_exponent;
            }

            default:
                goto scan_number_done;
        }

scan_number_any1:
        // state: we just parsed a number 0-9 (maybe with a leading minus sign)
        switch (get())
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any1;
            }

            case '.':
            {
                add(decimal_point_char);
                goto scan_number_decimal1;
            }

            case 'e':
            case 'E':
            {
                add(current);
                goto scan_number_exponent;
            }

            default:
                goto scan_number_done;
        }

scan_number_decimal1:
        // state: we just parsed a decimal point
        number_type = token_type::value_float;
        switch (get())
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_decimal2;
            }

            default:
            {
                error_message = "invalid number; expected digit after '.'";
                return token_type::parse_error;
            }
        }

scan_number_decimal2:
        // we just parsed at least one number after a decimal point
        switch (get())
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_decimal2;
            }

            case 'e':
            case 'E':
            {
                add(current);
                goto scan_number_exponent;
            }

            default:
                goto scan_number_done;
        }

scan_number_exponent:
        // we just parsed an exponent
        number_type = token_type::value_float;
        switch (get())
        {
            case '+':
            case '-':
            {
                add(current);
                goto scan_number_sign;
            }

            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any2;
            }

            default:
            {
                error_message =
                    "invalid number; expected '+', '-', or digit after exponent";
                return token_type::parse_error;
            }
        }

scan_number_sign:
        // we just parsed an exponent sign
        switch (get())
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any2;
            }

            default:
            {
                error_message = "invalid number; expected digit after exponent sign";
                return token_type::parse_error;
            }
        }

scan_number_any2:
        // we just parsed a number after the exponent or exponent sign
        switch (get())
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any2;
            }

            default:
                goto scan_number_done;
        }

scan_number_done:
        // unget the character after the number (we only read it to know that
        // we are done scanning a number)
        unget();

        char* endptr = nullptr;
        errno = 0;

        // try to parse integers first and fall back to floats
        if (number_type == token_type::value_unsigned)
        {
            const auto x = std::strtoull(token_buffer.data(), &endptr, 10);

            // we checked the number format before
            assert(endptr == token_buffer.data() + token_buffer.size());

            if (errno == 0)
            {
                value_unsigned = static_cast<number_unsigned_t>(x);
                if (value_unsigned == x)
                {
                    return token_type::value_unsigned;
                }
            }
        }
        else if (number_type == token_type::value_integer)
        {
            const auto x = std::strtoll(token_buffer.data(), &endptr, 10);

            // we checked the number format before
            assert(endptr == token_buffer.data() + token_buffer.size());

            if (errno == 0)
            {
                value_integer = static_cast<number_integer_t>(x);
                if (value_integer == x)
                {
                    return token_type::value_integer;
                }
            }
        }

        // this code is reached if we parse a floating-point number or if an
        // integer conversion above failed
        strtof(value_float, token_buffer.data(), &endptr);

        // we checked the number format before
        assert(endptr == token_buffer.data() + token_buffer.size());

        return token_type::value_float;
    }

    /*!
    @param[in] literal_text  the literal text to expect
    @param[in] length        the length of the passed literal text
    @param[in] return_type   the token type to return on success
    */
    token_type scan_literal(const char* literal_text, const std::size_t length,
                            token_type return_type)
    {
        assert(current == literal_text[0]);
        for (std::size_t i = 1; i < length; ++i)
        {
            if (JSON_UNLIKELY(get() != literal_text[i]))
            {
                error_message = "invalid literal";
                return token_type::parse_error;
            }
        }
        return return_type;
    }

    /////////////////////
    // input management
    /////////////////////

    /// reset token_buffer; current character is beginning of token
    void reset() noexcept
    {
        token_buffer.clear();
        token_string.clear();
        token_string.push_back(std::char_traits<char>::to_char_type(current));
    }

    /*
    @brief get next character from the input

    This function provides the interface to the used input adapter. It does
    not throw in case the input reached EOF, but returns a
    `std::char_traits<char>::eof()` in that case.  Stores the scanned characters
    for use in error messages.

    @return character read from the input
    */
    std::char_traits<char>::int_type get()
    {
        ++position.chars_read_total;
        ++position.chars_read_current_line;

        if (next_unget)
        {
            // just reset the next_unget variable and work with current
            next_unget = false;
        }
        else
        {
            current = ia->get_character();
        }

        if (JSON_LIKELY(current != std::char_traits<char>::eof()))
        {
            token_string.push_back(std::char_traits<char>::to_char_type(current));
        }

        if (current == '\n')
        {
            ++position.lines_read;
            position.chars_read_current_line = 0;
        }

        return current;
    }

    /*!
    @brief unget current character (read it again on next get)

    We implement unget by setting variable next_unget to true. The input is not
    changed - we just simulate ungetting by modifying chars_read_total,
    chars_read_current_line, and token_string. The next call to get() will
    behave as if the unget character is read again.
    */
    void unget()
    {
        next_unget = true;

        --position.chars_read_total;

        // in case we "unget" a newline, we have to also decrement the lines_read
        if (position.chars_read_current_line == 0)
        {
            if (position.lines_read > 0)
            {
                --position.lines_read;
            }
        }
        else
        {
            --position.chars_read_current_line;
        }

        if (JSON_LIKELY(current != std::char_traits<char>::eof()))
        {
            assert(not token_string.empty());
            token_string.pop_back();
        }
    }

    /// add a character to token_buffer
    void add(int c)
    {
        token_buffer.push_back(std::char_traits<char>::to_char_type(c));
    }

  public:
    /////////////////////
    // value getters
    /////////////////////

    /// return integer value
    constexpr number_integer_t get_number_integer() const noexcept
    {
        return value_integer;
    }

    /// return unsigned integer value
    constexpr number_unsigned_t get_number_unsigned() const noexcept
    {
        return value_unsigned;
    }

    /// return floating-point value
    constexpr number_float_t get_number_float() const noexcept
    {
        return value_float;
    }

    /// return current string value (implicitly resets the token; useful only once)
    string_t& get_string()
    {
        return token_buffer;
    }

    /////////////////////
    // diagnostics
    /////////////////////

    /// return position of last read token
    constexpr position_t get_position() const noexcept
    {
        return position;
    }

    /// return the last read token (for errors only).  Will never contain EOF
    /// (an arbitrary value that is not a valid char value, often -1), because
    /// 255 may legitimately occur.  May contain NUL, which should be escaped.
    std::string get_token_string() const
    {
        // escape control characters
        std::string result;
        for (const auto c : token_string)
        {
            if ('\x00' <= c and c <= '\x1F')
            {
                // escape control characters
                std::array<char, 9> cs{{}};
                (std::snprintf)(cs.data(), cs.size(), "<U+%.4X>", static_cast<unsigned char>(c));
                result += cs.data();
            }
            else
            {
                // add character as is
                result.push_back(c);
            }
        }

        return result;
    }

    /// return syntax error message
    constexpr const char* get_error_message() const noexcept
    {
        return error_message;
    }

    /////////////////////
    // actual scanner
    /////////////////////

    /*!
    @brief skip the UTF-8 byte order mark
    @return true iff there is no BOM or the correct BOM has been skipped
    */
    bool skip_bom()
    {
        if (get() == 0xEF)
        {
            // check if we completely parse the BOM
            return get() == 0xBB and get() == 0xBF;
        }

        // the first character is not the beginning of the BOM; unget it to
        // process is later
        unget();
        return true;
    }

    token_type scan()
    {
        // initially, skip the BOM
        if (position.chars_read_total == 0 and not skip_bom())
        {
            error_message = "invalid BOM; must be 0xEF 0xBB 0xBF if given";
            return token_type::parse_error;
        }

        // read next character and ignore whitespace
        do
        {
            get();
        }
        while (current == ' ' or current == '\t' or current == '\n' or current == '\r');

        switch (current)
        {
            // structural characters
            case '[':
                return token_type::begin_array;
            case ']':
                return token_type::end_array;
            case '{':
                return token_type::begin_object;
            case '}':
                return token_type::end_object;
            case ':':
                return token_type::name_separator;
            case ',':
                return token_type::value_separator;

            // literals
            case 't':
                return scan_literal("true", 4, token_type::literal_true);
            case 'f':
                return scan_literal("false", 5, token_type::literal_false);
            case 'n':
                return scan_literal("null", 4, token_type::literal_null);

            // string
            case '\"':
                return scan_string();

            // number
            case '-':
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
                return scan_number();

            // end of input (the null byte is needed when parsing from
            // string literals)
            case '\0':
            case std::char_traits<char>::eof():
                return token_type::end_of_input;

            // error
            default:
                error_message = "invalid literal";
                return token_type::parse_error;
        }
    }

  private:
    /// input adapter
    detail::input_adapter_t ia = nullptr;

    /// the current character
    std::char_traits<char>::int_type current = std::char_traits<char>::eof();

    /// whether the next get() call should just return current
    bool next_unget = false;

    /// the start position of the current token
    position_t position {};

    /// raw input token string (for error messages)
    std::vector<char> token_string {};

    /// buffer for variable-length tokens (numbers, strings)
    string_t token_buffer {};

    /// a description of occurred lexer errors
    const char* error_message = "";

    // number values
    number_integer_t value_integer = 0;
    number_unsigned_t value_unsigned = 0;
    number_float_t value_float = 0;

    /// the decimal point
    const char decimal_point_char = '.';
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/input/parser.hpp>


#include <cassert> // assert
#include <cmath> // isfinite
#include <cstdint> // uint8_t
#include <functional> // function
#include <string> // string
#include <utility> // move
#include <vector> // vector

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/input/input_adapters.hpp>

// #include <nlohmann/detail/input/json_sax.hpp>

// #include <nlohmann/detail/input/lexer.hpp>

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/is_sax.hpp>

// #include <nlohmann/detail/value_t.hpp>


namespace nlohmann
{
namespace detail
{
////////////
// parser //
////////////

/*!
@brief syntax analysis

This class implements a recursive decent parser.
*/
template<typename BasicJsonType>
class parser
{
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using lexer_t = lexer<BasicJsonType>;
    using token_type = typename lexer_t::token_type;

  public:
    enum class parse_event_t : uint8_t
    {
        /// the parser read `{` and started to process a JSON object
        object_start,
        /// the parser read `}` and finished processing a JSON object
        object_end,
        /// the parser read `[` and started to process a JSON array
        array_start,
        /// the parser read `]` and finished processing a JSON array
        array_end,
        /// the parser read a key of a value in an object
        key,
        /// the parser finished reading a JSON value
        value
    };

    using parser_callback_t =
        std::function<bool(int depth, parse_event_t event, BasicJsonType& parsed)>;

    /// a parser reading from an input adapter
    explicit parser(detail::input_adapter_t&& adapter,
                    const parser_callback_t cb = nullptr,
                    const bool allow_exceptions_ = true)
        : callback(cb), m_lexer(std::move(adapter)), allow_exceptions(allow_exceptions_)
    {
        // read first token
        get_token();
    }

    /*!
    @brief public parser interface

    @param[in] strict      whether to expect the last token to be EOF
    @param[in,out] result  parsed JSON value

    @throw parse_error.101 in case of an unexpected token
    @throw parse_error.102 if to_unicode fails or surrogate error
    @throw parse_error.103 if to_unicode fails
    */
    void parse(const bool strict, BasicJsonType& result)
    {
        if (callback)
        {
            json_sax_dom_callback_parser<BasicJsonType> sdp(result, callback, allow_exceptions);
            sax_parse_internal(&sdp);
            result.assert_invariant();

            // in strict mode, input must be completely read
            if (strict and (get_token() != token_type::end_of_input))
            {
                sdp.parse_error(m_lexer.get_position(),
                                m_lexer.get_token_string(),
                                parse_error::create(101, m_lexer.get_position(),
                                                    exception_message(token_type::end_of_input, "value")));
            }

            // in case of an error, return discarded value
            if (sdp.is_errored())
            {
                result = value_t::discarded;
                return;
            }

            // set top-level value to null if it was discarded by the callback
            // function
            if (result.is_discarded())
            {
                result = nullptr;
            }
        }
        else
        {
            json_sax_dom_parser<BasicJsonType> sdp(result, allow_exceptions);
            sax_parse_internal(&sdp);
            result.assert_invariant();

            // in strict mode, input must be completely read
            if (strict and (get_token() != token_type::end_of_input))
            {
                sdp.parse_error(m_lexer.get_position(),
                                m_lexer.get_token_string(),
                                parse_error::create(101, m_lexer.get_position(),
                                                    exception_message(token_type::end_of_input, "value")));
            }

            // in case of an error, return discarded value
            if (sdp.is_errored())
            {
                result = value_t::discarded;
                return;
            }
        }
    }

    /*!
    @brief public accept interface

    @param[in] strict  whether to expect the last token to be EOF
    @return whether the input is a proper JSON text
    */
    bool accept(const bool strict = true)
    {
        json_sax_acceptor<BasicJsonType> sax_acceptor;
        return sax_parse(&sax_acceptor, strict);
    }

    template <typename SAX>
    bool sax_parse(SAX* sax, const bool strict = true)
    {
        (void)detail::is_sax_static_asserts<SAX, BasicJsonType> {};
        const bool result = sax_parse_internal(sax);

        // strict mode: next byte must be EOF
        if (result and strict and (get_token() != token_type::end_of_input))
        {
            return sax->parse_error(m_lexer.get_position(),
                                    m_lexer.get_token_string(),
                                    parse_error::create(101, m_lexer.get_position(),
                                            exception_message(token_type::end_of_input, "value")));
        }

        return result;
    }

  private:
    template <typename SAX>
    bool sax_parse_internal(SAX* sax)
    {
        // stack to remember the hierarchy of structured values we are parsing
        // true = array; false = object
        std::vector<bool> states;
        // value to avoid a goto (see comment where set to true)
        bool skip_to_state_evaluation = false;

        while (true)
        {
            if (not skip_to_state_evaluation)
            {
                // invariant: get_token() was called before each iteration
                switch (last_token)
                {
                    case token_type::begin_object:
                    {
                        if (JSON_UNLIKELY(not sax->start_object(std::size_t(-1))))
                        {
                            return false;
                        }

                        // closing } -> we are done
                        if (get_token() == token_type::end_object)
                        {
                            if (JSON_UNLIKELY(not sax->end_object()))
                            {
                                return false;
                            }
                            break;
                        }

                        // parse key
                        if (JSON_UNLIKELY(last_token != token_type::value_string))
                        {
                            return sax->parse_error(m_lexer.get_position(),
                                                    m_lexer.get_token_string(),
                                                    parse_error::create(101, m_lexer.get_position(),
                                                            exception_message(token_type::value_string, "object key")));
                        }
                        if (JSON_UNLIKELY(not sax->key(m_lexer.get_string())))
                        {
                            return false;
                        }

                        // parse separator (:)
                        if (JSON_UNLIKELY(get_token() != token_type::name_separator))
                        {
                            return sax->parse_error(m_lexer.get_position(),
                                                    m_lexer.get_token_string(),
                                                    parse_error::create(101, m_lexer.get_position(),
                                                            exception_message(token_type::name_separator, "object separator")));
                        }

                        // remember we are now inside an object
                        states.push_back(false);

                        // parse values
                        get_token();
                        continue;
                    }

                    case token_type::begin_array:
                    {
                        if (JSON_UNLIKELY(not sax->start_array(std::size_t(-1))))
                        {
                            return false;
                        }

                        // closing ] -> we are done
                        if (get_token() == token_type::end_array)
                        {
                            if (JSON_UNLIKELY(not sax->end_array()))
                            {
                                return false;
                            }
                            break;
                        }

                        // remember we are now inside an array
                        states.push_back(true);

                        // parse values (no need to call get_token)
                        continue;
                    }

                    case token_type::value_float:
                    {
                        const auto res = m_lexer.get_number_float();

                        if (JSON_UNLIKELY(not std::isfinite(res)))
                        {
                            return sax->parse_error(m_lexer.get_position(),
                                                    m_lexer.get_token_string(),
                                                    out_of_range::create(406, "number overflow parsing '" + m_lexer.get_token_string() + "'"));
                        }

                        if (JSON_UNLIKELY(not sax->number_float(res, m_lexer.get_string())))
                        {
                            return false;
                        }

                        break;
                    }

                    case token_type::literal_false:
                    {
                        if (JSON_UNLIKELY(not sax->boolean(false)))
                        {
                            return false;
                        }
                        break;
                    }

                    case token_type::literal_null:
                    {
                        if (JSON_UNLIKELY(not sax->null()))
                        {
                            return false;
                        }
                        break;
                    }

                    case token_type::literal_true:
                    {
                        if (JSON_UNLIKELY(not sax->boolean(true)))
                        {
                            return false;
                        }
                        break;
                    }

                    case token_type::value_integer:
                    {
                        if (JSON_UNLIKELY(not sax->number_integer(m_lexer.get_number_integer())))
                        {
                            return false;
                        }
                        break;
                    }

                    case token_type::value_string:
                    {
                        if (JSON_UNLIKELY(not sax->string(m_lexer.get_string())))
                        {
                            return false;
                        }
                        break;
                    }

                    case token_type::value_unsigned:
                    {
                        if (JSON_UNLIKELY(not sax->number_unsigned(m_lexer.get_number_unsigned())))
                        {
                            return false;
                        }
                        break;
                    }

                    case token_type::parse_error:
                    {
                        // using "uninitialized" to avoid "expected" message
                        return sax->parse_error(m_lexer.get_position(),
                                                m_lexer.get_token_string(),
                                                parse_error::create(101, m_lexer.get_position(),
                                                        exception_message(token_type::uninitialized, "value")));
                    }

                    default: // the last token was unexpected
                    {
                        return sax->parse_error(m_lexer.get_position(),
                                                m_lexer.get_token_string(),
                                                parse_error::create(101, m_lexer.get_position(),
                                                        exception_message(token_type::literal_or_value, "value")));
                    }
                }
            }
            else
            {
                skip_to_state_evaluation = false;
            }

            // we reached this line after we successfully parsed a value
            if (states.empty())
            {
                // empty stack: we reached the end of the hierarchy: done
                return true;
            }

            if (states.back())  // array
            {
                // comma -> next value
                if (get_token() == token_type::value_separator)
                {
                    // parse a new value
                    get_token();
                    continue;
                }

                // closing ]
                if (JSON_LIKELY(last_token == token_type::end_array))
                {
                    if (JSON_UNLIKELY(not sax->end_array()))
                    {
                        return false;
                    }

                    // We are done with this array. Before we can parse a
                    // new value, we need to evaluate the new state first.
                    // By setting skip_to_state_evaluation to false, we
                    // are effectively jumping to the beginning of this if.
                    assert(not states.empty());
                    states.pop_back();
                    skip_to_state_evaluation = true;
                    continue;
                }

                return sax->parse_error(m_lexer.get_position(),
                                        m_lexer.get_token_string(),
                                        parse_error::create(101, m_lexer.get_position(),
                                                exception_message(token_type::end_array, "array")));
            }
            else  // object
            {
                // comma -> next value
                if (get_token() == token_type::value_separator)
                {
                    // parse key
                    if (JSON_UNLIKELY(get_token() != token_type::value_string))
                    {
                        return sax->parse_error(m_lexer.get_position(),
                                                m_lexer.get_token_string(),
                                                parse_error::create(101, m_lexer.get_position(),
                                                        exception_message(token_type::value_string, "object key")));
                    }

                    if (JSON_UNLIKELY(not sax->key(m_lexer.get_string())))
                    {
                        return false;
                    }

                    // parse separator (:)
                    if (JSON_UNLIKELY(get_token() != token_type::name_separator))
                    {
                        return sax->parse_error(m_lexer.get_position(),
                                                m_lexer.get_token_string(),
                                                parse_error::create(101, m_lexer.get_position(),
                                                        exception_message(token_type::name_separator, "object separator")));
                    }

                    // parse values
                    get_token();
                    continue;
                }

                // closing }
                if (JSON_LIKELY(last_token == token_type::end_object))
                {
                    if (JSON_UNLIKELY(not sax->end_object()))
                    {
                        return false;
                    }

                    // We are done with this object. Before we can parse a
                    // new value, we need to evaluate the new state first.
                    // By setting skip_to_state_evaluation to false, we
                    // are effectively jumping to the beginning of this if.
                    assert(not states.empty());
                    states.pop_back();
                    skip_to_state_evaluation = true;
                    continue;
                }

                return sax->parse_error(m_lexer.get_position(),
                                        m_lexer.get_token_string(),
                                        parse_error::create(101, m_lexer.get_position(),
                                                exception_message(token_type::end_object, "object")));
            }
        }
    }

    /// get next token from lexer
    token_type get_token()
    {
        return last_token = m_lexer.scan();
    }

    std::string exception_message(const token_type expected, const std::string& context)
    {
        std::string error_msg = "syntax error ";

        if (not context.empty())
        {
            error_msg += "while parsing " + context + " ";
        }

        error_msg += "- ";

        if (last_token == token_type::parse_error)
        {
            error_msg += std::string(m_lexer.get_error_message()) + "; last read: '" +
                         m_lexer.get_token_string() + "'";
        }
        else
        {
            error_msg += "unexpected " + std::string(lexer_t::token_type_name(last_token));
        }

        if (expected != token_type::uninitialized)
        {
            error_msg += "; expected " + std::string(lexer_t::token_type_name(expected));
        }

        return error_msg;
    }

  private:
    /// callback function
    const parser_callback_t callback = nullptr;
    /// the type of the last read token
    token_type last_token = token_type::uninitialized;
    /// the lexer
    lexer_t m_lexer;
    /// whether to throw exceptions in case of errors
    const bool allow_exceptions = true;
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/iterators/internal_iterator.hpp>


// #include <nlohmann/detail/iterators/primitive_iterator.hpp>


#include <cstddef> // ptrdiff_t
#include <limits>  // numeric_limits

namespace nlohmann
{
namespace detail
{
/*
@brief an iterator for primitive JSON types

This class models an iterator for primitive JSON types (boolean, number,
string). It's only purpose is to allow the iterator/const_iterator classes
to "iterate" over primitive values. Internally, the iterator is modeled by
a `difference_type` variable. Value begin_value (`0`) models the begin,
end_value (`1`) models past the end.
*/
class primitive_iterator_t
{
  private:
    using difference_type = std::ptrdiff_t;
    static constexpr difference_type begin_value = 0;
    static constexpr difference_type end_value = begin_value + 1;

    /// iterator as signed integer type
    difference_type m_it = (std::numeric_limits<std::ptrdiff_t>::min)();

  public:
    constexpr difference_type get_value() const noexcept
    {
        return m_it;
    }

    /// set iterator to a defined beginning
    void set_begin() noexcept
    {
        m_it = begin_value;
    }

    /// set iterator to a defined past the end
    void set_end() noexcept
    {
        m_it = end_value;
    }

    /// return whether the iterator can be dereferenced
    constexpr bool is_begin() const noexcept
    {
        return m_it == begin_value;
    }

    /// return whether the iterator is at end
    constexpr bool is_end() const noexcept
    {
        return m_it == end_value;
    }

    friend constexpr bool operator==(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
    {
        return lhs.m_it == rhs.m_it;
    }

    friend constexpr bool operator<(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
    {
        return lhs.m_it < rhs.m_it;
    }

    primitive_iterator_t operator+(difference_type n) noexcept
    {
        auto result = *this;
        result += n;
        return result;
    }

    friend constexpr difference_type operator-(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
    {
        return lhs.m_it - rhs.m_it;
    }

    primitive_iterator_t& operator++() noexcept
    {
        ++m_it;
        return *this;
    }

    primitive_iterator_t const operator++(int) noexcept
    {
        auto result = *this;
        ++m_it;
        return result;
    }

    primitive_iterator_t& operator--() noexcept
    {
        --m_it;
        return *this;
    }

    primitive_iterator_t const operator--(int) noexcept
    {
        auto result = *this;
        --m_it;
        return result;
    }

    primitive_iterator_t& operator+=(difference_type n) noexcept
    {
        m_it += n;
        return *this;
    }

    primitive_iterator_t& operator-=(difference_type n) noexcept
    {
        m_it -= n;
        return *this;
    }
};
}  // namespace detail
}  // namespace nlohmann


namespace nlohmann
{
namespace detail
{
/*!
@brief an iterator value

@note This structure could easily be a union, but MSVC currently does not allow
unions members with complex constructors, see https://github.com/nlohmann/json/pull/105.
*/
template<typename BasicJsonType> struct internal_iterator
{
    /// iterator for JSON objects
    typename BasicJsonType::object_t::iterator object_iterator {};
    /// iterator for JSON arrays
    typename BasicJsonType::array_t::iterator array_iterator {};
    /// generic iterator for all other types
    primitive_iterator_t primitive_iterator {};
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/iterators/iter_impl.hpp>


#include <ciso646> // not
#include <iterator> // iterator, random_access_iterator_tag, bidirectional_iterator_tag, advance, next
#include <type_traits> // conditional, is_const, remove_const

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/iterators/internal_iterator.hpp>

// #include <nlohmann/detail/iterators/primitive_iterator.hpp>

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/meta/type_traits.hpp>

// #include <nlohmann/detail/value_t.hpp>


namespace nlohmann
{
namespace detail
{
// forward declare, to be able to friend it later on
template<typename IteratorType> class iteration_proxy;
template<typename IteratorType> class iteration_proxy_value;

/*!
@brief a template for a bidirectional iterator for the @ref basic_json class
This class implements a both iterators (iterator and const_iterator) for the
@ref basic_json class.
@note An iterator is called *initialized* when a pointer to a JSON value has
      been set (e.g., by a constructor or a copy assignment). If the iterator is
      default-constructed, it is *uninitialized* and most methods are undefined.
      **The library uses assertions to detect calls on uninitialized iterators.**
@requirement The class satisfies the following concept requirements:
-
[BidirectionalIterator](https://en.cppreference.com/w/cpp/named_req/BidirectionalIterator):
  The iterator that can be moved can be moved in both directions (i.e.
  incremented and decremented).
@since version 1.0.0, simplified in version 2.0.9, change to bidirectional
       iterators in version 3.0.0 (see https://github.com/nlohmann/json/issues/593)
*/
template<typename BasicJsonType>
class iter_impl
{
    /// allow basic_json to access private members
    friend iter_impl<typename std::conditional<std::is_const<BasicJsonType>::value, typename std::remove_const<BasicJsonType>::type, const BasicJsonType>::type>;
    friend BasicJsonType;
    friend iteration_proxy<iter_impl>;
    friend iteration_proxy_value<iter_impl>;

    using object_t = typename BasicJsonType::object_t;
    using array_t = typename BasicJsonType::array_t;
    // make sure BasicJsonType is basic_json or const basic_json
    static_assert(is_basic_json<typename std::remove_const<BasicJsonType>::type>::value,
                  "iter_impl only accepts (const) basic_json");

  public:

    /// The std::iterator class template (used as a base class to provide typedefs) is deprecated in C++17.
    /// The C++ Standard has never required user-defined iterators to derive from std::iterator.
    /// A user-defined iterator should provide publicly accessible typedefs named
    /// iterator_category, value_type, difference_type, pointer, and reference.
    /// Note that value_type is required to be non-const, even for constant iterators.
    using iterator_category = std::bidirectional_iterator_tag;

    /// the type of the values when the iterator is dereferenced
    using value_type = typename BasicJsonType::value_type;
    /// a type to represent differences between iterators
    using difference_type = typename BasicJsonType::difference_type;
    /// defines a pointer to the type iterated over (value_type)
    using pointer = typename std::conditional<std::is_const<BasicJsonType>::value,
          typename BasicJsonType::const_pointer,
          typename BasicJsonType::pointer>::type;
    /// defines a reference to the type iterated over (value_type)
    using reference =
        typename std::conditional<std::is_const<BasicJsonType>::value,
        typename BasicJsonType::const_reference,
        typename BasicJsonType::reference>::type;

    /// default constructor
    iter_impl() = default;

    /*!
    @brief constructor for a given JSON instance
    @param[in] object  pointer to a JSON object for this iterator
    @pre object != nullptr
    @post The iterator is initialized; i.e. `m_object != nullptr`.
    */
    explicit iter_impl(pointer object) noexcept : m_object(object)
    {
        assert(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
            {
                m_it.object_iterator = typename object_t::iterator();
                break;
            }

            case value_t::array:
            {
                m_it.array_iterator = typename array_t::iterator();
                break;
            }

            default:
            {
                m_it.primitive_iterator = primitive_iterator_t();
                break;
            }
        }
    }

    /*!
    @note The conventional copy constructor and copy assignment are implicitly
          defined. Combined with the following converting constructor and
          assignment, they support: (1) copy from iterator to iterator, (2)
          copy from const iterator to const iterator, and (3) conversion from
          iterator to const iterator. However conversion from const iterator
          to iterator is not defined.
    */

    /*!
    @brief converting constructor
    @param[in] other  non-const iterator to copy from
    @note It is not checked whether @a other is initialized.
    */
    iter_impl(const iter_impl<typename std::remove_const<BasicJsonType>::type>& other) noexcept
        : m_object(other.m_object), m_it(other.m_it) {}

    /*!
    @brief converting assignment
    @param[in,out] other  non-const iterator to copy from
    @return const/non-const iterator
    @note It is not checked whether @a other is initialized.
    */
    iter_impl& operator=(const iter_impl<typename std::remove_const<BasicJsonType>::type>& other) noexcept
    {
        m_object = other.m_object;
        m_it = other.m_it;
        return *this;
    }

  private:
    /*!
    @brief set the iterator to the first value
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    void set_begin() noexcept
    {
        assert(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
            {
                m_it.object_iterator = m_object->m_value.object->begin();
                break;
            }

            case value_t::array:
            {
                m_it.array_iterator = m_object->m_value.array->begin();
                break;
            }

            case value_t::null:
            {
                // set to end so begin()==end() is true: null is empty
                m_it.primitive_iterator.set_end();
                break;
            }

            default:
            {
                m_it.primitive_iterator.set_begin();
                break;
            }
        }
    }

    /*!
    @brief set the iterator past the last value
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    void set_end() noexcept
    {
        assert(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
            {
                m_it.object_iterator = m_object->m_value.object->end();
                break;
            }

            case value_t::array:
            {
                m_it.array_iterator = m_object->m_value.array->end();
                break;
            }

            default:
            {
                m_it.primitive_iterator.set_end();
                break;
            }
        }
    }

  public:
    /*!
    @brief return a reference to the value pointed to by the iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    reference operator*() const
    {
        assert(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
            {
                assert(m_it.object_iterator != m_object->m_value.object->end());
                return m_it.object_iterator->second;
            }

            case value_t::array:
            {
                assert(m_it.array_iterator != m_object->m_value.array->end());
                return *m_it.array_iterator;
            }

            case value_t::null:
                JSON_THROW(invalid_iterator::create(214, "cannot get value"));

            default:
            {
                if (JSON_LIKELY(m_it.primitive_iterator.is_begin()))
                {
                    return *m_object;
                }

                JSON_THROW(invalid_iterator::create(214, "cannot get value"));
            }
        }
    }

    /*!
    @brief dereference the iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    pointer operator->() const
    {
        assert(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
            {
                assert(m_it.object_iterator != m_object->m_value.object->end());
                return &(m_it.object_iterator->second);
            }

            case value_t::array:
            {
                assert(m_it.array_iterator != m_object->m_value.array->end());
                return &*m_it.array_iterator;
            }

            default:
            {
                if (JSON_LIKELY(m_it.primitive_iterator.is_begin()))
                {
                    return m_object;
                }

                JSON_THROW(invalid_iterator::create(214, "cannot get value"));
            }
        }
    }

    /*!
    @brief post-increment (it++)
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl const operator++(int)
    {
        auto result = *this;
        ++(*this);
        return result;
    }

    /*!
    @brief pre-increment (++it)
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl& operator++()
    {
        assert(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
            {
                std::advance(m_it.object_iterator, 1);
                break;
            }

            case value_t::array:
            {
                std::advance(m_it.array_iterator, 1);
                break;
            }

            default:
            {
                ++m_it.primitive_iterator;
                break;
            }
        }

        return *this;
    }

    /*!
    @brief post-decrement (it--)
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl const operator--(int)
    {
        auto result = *this;
        --(*this);
        return result;
    }

    /*!
    @brief pre-decrement (--it)
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl& operator--()
    {
        assert(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
            {
                std::advance(m_it.object_iterator, -1);
                break;
            }

            case value_t::array:
            {
                std::advance(m_it.array_iterator, -1);
                break;
            }

            default:
            {
                --m_it.primitive_iterator;
                break;
            }
        }

        return *this;
    }

    /*!
    @brief  comparison: equal
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    bool operator==(const iter_impl& other) const
    {
        // if objects are not the same, the comparison is undefined
        if (JSON_UNLIKELY(m_object != other.m_object))
        {
            JSON_THROW(invalid_iterator::create(212, "cannot compare iterators of different containers"));
        }

        assert(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
                return (m_it.object_iterator == other.m_it.object_iterator);

            case value_t::array:
                return (m_it.array_iterator == other.m_it.array_iterator);

            default:
                return (m_it.primitive_iterator == other.m_it.primitive_iterator);
        }
    }

    /*!
    @brief  comparison: not equal
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    bool operator!=(const iter_impl& other) const
    {
        return not operator==(other);
    }

    /*!
    @brief  comparison: smaller
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    bool operator<(const iter_impl& other) const
    {
        // if objects are not the same, the comparison is undefined
        if (JSON_UNLIKELY(m_object != other.m_object))
        {
            JSON_THROW(invalid_iterator::create(212, "cannot compare iterators of different containers"));
        }

        assert(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
                JSON_THROW(invalid_iterator::create(213, "cannot compare order of object iterators"));

            case value_t::array:
                return (m_it.array_iterator < other.m_it.array_iterator);

            default:
                return (m_it.primitive_iterator < other.m_it.primitive_iterator);
        }
    }

    /*!
    @brief  comparison: less than or equal
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    bool operator<=(const iter_impl& other) const
    {
        return not other.operator < (*this);
    }

    /*!
    @brief  comparison: greater than
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    bool operator>(const iter_impl& other) const
    {
        return not operator<=(other);
    }

    /*!
    @brief  comparison: greater than or equal
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    bool operator>=(const iter_impl& other) const
    {
        return not operator<(other);
    }

    /*!
    @brief  add to iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl& operator+=(difference_type i)
    {
        assert(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
                JSON_THROW(invalid_iterator::create(209, "cannot use offsets with object iterators"));

            case value_t::array:
            {
                std::advance(m_it.array_iterator, i);
                break;
            }

            default:
            {
                m_it.primitive_iterator += i;
                break;
            }
        }

        return *this;
    }

    /*!
    @brief  subtract from iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl& operator-=(difference_type i)
    {
        return operator+=(-i);
    }

    /*!
    @brief  add to iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl operator+(difference_type i) const
    {
        auto result = *this;
        result += i;
        return result;
    }

    /*!
    @brief  addition of distance and iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    friend iter_impl operator+(difference_type i, const iter_impl& it)
    {
        auto result = it;
        result += i;
        return result;
    }

    /*!
    @brief  subtract from iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl operator-(difference_type i) const
    {
        auto result = *this;
        result -= i;
        return result;
    }

    /*!
    @brief  return difference
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    difference_type operator-(const iter_impl& other) const
    {
        assert(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
                JSON_THROW(invalid_iterator::create(209, "cannot use offsets with object iterators"));

            case value_t::array:
                return m_it.array_iterator - other.m_it.array_iterator;

            default:
                return m_it.primitive_iterator - other.m_it.primitive_iterator;
        }
    }

    /*!
    @brief  access to successor
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    reference operator[](difference_type n) const
    {
        assert(m_object != nullptr);

        switch (m_object->m_type)
        {
            case value_t::object:
                JSON_THROW(invalid_iterator::create(208, "cannot use operator[] for object iterators"));

            case value_t::array:
                return *std::next(m_it.array_iterator, n);

            case value_t::null:
                JSON_THROW(invalid_iterator::create(214, "cannot get value"));

            default:
            {
                if (JSON_LIKELY(m_it.primitive_iterator.get_value() == -n))
                {
                    return *m_object;
                }

                JSON_THROW(invalid_iterator::create(214, "cannot get value"));
            }
        }
    }

    /*!
    @brief  return the key of an object iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    const typename object_t::key_type& key() const
    {
        assert(m_object != nullptr);

        if (JSON_LIKELY(m_object->is_object()))
        {
            return m_it.object_iterator->first;
        }

        JSON_THROW(invalid_iterator::create(207, "cannot use key() for non-object iterators"));
    }

    /*!
    @brief  return the value of an iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    reference value() const
    {
        return operator*();
    }

  private:
    /// associated JSON instance
    pointer m_object = nullptr;
    /// the actual iterator of the associated instance
    internal_iterator<typename std::remove_const<BasicJsonType>::type> m_it {};
};
}  // namespace detail
} // namespace nlohmann

// #include <nlohmann/detail/iterators/iteration_proxy.hpp>

// #include <nlohmann/detail/iterators/json_reverse_iterator.hpp>


#include <cstddef> // ptrdiff_t
#include <iterator> // reverse_iterator
#include <utility> // declval

namespace nlohmann
{
namespace detail
{
//////////////////////
// reverse_iterator //
//////////////////////

/*!
@brief a template for a reverse iterator class

@tparam Base the base iterator type to reverse. Valid types are @ref
iterator (to create @ref reverse_iterator) and @ref const_iterator (to
create @ref const_reverse_iterator).

@requirement The class satisfies the following concept requirements:
-
[BidirectionalIterator](https://en.cppreference.com/w/cpp/named_req/BidirectionalIterator):
  The iterator that can be moved can be moved in both directions (i.e.
  incremented and decremented).
- [OutputIterator](https://en.cppreference.com/w/cpp/named_req/OutputIterator):
  It is possible to write to the pointed-to element (only if @a Base is
  @ref iterator).

@since version 1.0.0
*/
template<typename Base>
class json_reverse_iterator : public std::reverse_iterator<Base>
{
  public:
    using difference_type = std::ptrdiff_t;
    /// shortcut to the reverse iterator adapter
    using base_iterator = std::reverse_iterator<Base>;
    /// the reference type for the pointed-to element
    using reference = typename Base::reference;

    /// create reverse iterator from iterator
    explicit json_reverse_iterator(const typename base_iterator::iterator_type& it) noexcept
        : base_iterator(it) {}

    /// create reverse iterator from base class
    explicit json_reverse_iterator(const base_iterator& it) noexcept : base_iterator(it) {}

    /// post-increment (it++)
    json_reverse_iterator const operator++(int)
    {
        return static_cast<json_reverse_iterator>(base_iterator::operator++(1));
    }

    /// pre-increment (++it)
    json_reverse_iterator& operator++()
    {
        return static_cast<json_reverse_iterator&>(base_iterator::operator++());
    }

    /// post-decrement (it--)
    json_reverse_iterator const operator--(int)
    {
        return static_cast<json_reverse_iterator>(base_iterator::operator--(1));
    }

    /// pre-decrement (--it)
    json_reverse_iterator& operator--()
    {
        return static_cast<json_reverse_iterator&>(base_iterator::operator--());
    }

    /// add to iterator
    json_reverse_iterator& operator+=(difference_type i)
    {
        return static_cast<json_reverse_iterator&>(base_iterator::operator+=(i));
    }

    /// add to iterator
    json_reverse_iterator operator+(difference_type i) const
    {
        return static_cast<json_reverse_iterator>(base_iterator::operator+(i));
    }

    /// subtract from iterator
    json_reverse_iterator operator-(difference_type i) const
    {
        return static_cast<json_reverse_iterator>(base_iterator::operator-(i));
    }

    /// return difference
    difference_type operator-(const json_reverse_iterator& other) const
    {
        return base_iterator(*this) - base_iterator(other);
    }

    /// access to successor
    reference operator[](difference_type n) const
    {
        return *(this->operator+(n));
    }

    /// return the key of an object iterator
    auto key() const -> decltype(std::declval<Base>().key())
    {
        auto it = --this->base();
        return it.key();
    }

    /// return the value of an iterator
    reference value() const
    {
        auto it = --this->base();
        return it.operator * ();
    }
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/iterators/primitive_iterator.hpp>

// #include <nlohmann/detail/json_pointer.hpp>


#include <algorithm> // all_of
#include <cassert> // assert
#include <numeric> // accumulate
#include <string> // string
#include <utility> // move
#include <vector> // vector

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/value_t.hpp>


namespace nlohmann
{
template<typename BasicJsonType>
class json_pointer
{
    // allow basic_json to access private members
    NLOHMANN_BASIC_JSON_TPL_DECLARATION
    friend class basic_json;

  public:
    /*!
    @brief create JSON pointer

    Create a JSON pointer according to the syntax described in
    [Section 3 of RFC6901](https://tools.ietf.org/html/rfc6901#section-3).

    @param[in] s  string representing the JSON pointer; if omitted, the empty
                  string is assumed which references the whole JSON value

    @throw parse_error.107 if the given JSON pointer @a s is nonempty and does
                           not begin with a slash (`/`); see example below

    @throw parse_error.108 if a tilde (`~`) in the given JSON pointer @a s is
    not followed by `0` (representing `~`) or `1` (representing `/`); see
    example below

    @liveexample{The example shows the construction several valid JSON pointers
    as well as the exceptional behavior.,json_pointer}

    @since version 2.0.0
    */
    explicit json_pointer(const std::string& s = "")
        : reference_tokens(split(s))
    {}

    /*!
    @brief return a string representation of the JSON pointer

    @invariant For each JSON pointer `ptr`, it holds:
    @code {.cpp}
    ptr == json_pointer(ptr.to_string());
    @endcode

    @return a string representation of the JSON pointer

    @liveexample{The example shows the result of `to_string`.,json_pointer__to_string}

    @since version 2.0.0
    */
    std::string to_string() const
    {
        return std::accumulate(reference_tokens.begin(), reference_tokens.end(),
                               std::string{},
                               [](const std::string & a, const std::string & b)
        {
            return a + "/" + escape(b);
        });
    }

    /// @copydoc to_string()
    operator std::string() const
    {
        return to_string();
    }

    /*!
    @brief append another JSON pointer at the end of this JSON pointer

    @param[in] ptr  JSON pointer to append
    @return JSON pointer with @a ptr appended

    @liveexample{The example shows the usage of `operator/=`.,json_pointer__operator_add}

    @complexity Linear in the length of @a ptr.

    @sa @ref operator/=(std::string) to append a reference token
    @sa @ref operator/=(std::size_t) to append an array index
    @sa @ref operator/(const json_pointer&, const json_pointer&) for a binary operator

    @since version 3.6.0
    */
    json_pointer& operator/=(const json_pointer& ptr)
    {
        reference_tokens.insert(reference_tokens.end(),
                                ptr.reference_tokens.begin(),
                                ptr.reference_tokens.end());
        return *this;
    }

    /*!
    @brief append an unescaped reference token at the end of this JSON pointer

    @param[in] token  reference token to append
    @return JSON pointer with @a token appended without escaping @a token

    @liveexample{The example shows the usage of `operator/=`.,json_pointer__operator_add}

    @complexity Amortized constant.

    @sa @ref operator/=(const json_pointer&) to append a JSON pointer
    @sa @ref operator/=(std::size_t) to append an array index
    @sa @ref operator/(const json_pointer&, std::size_t) for a binary operator

    @since version 3.6.0
    */
    json_pointer& operator/=(std::string token)
    {
        push_back(std::move(token));
        return *this;
    }

    /*!
    @brief append an array index at the end of this JSON pointer

    @param[in] array_index  array index ot append
    @return JSON pointer with @a array_index appended

    @liveexample{The example shows the usage of `operator/=`.,json_pointer__operator_add}

    @complexity Amortized constant.

    @sa @ref operator/=(const json_pointer&) to append a JSON pointer
    @sa @ref operator/=(std::string) to append a reference token
    @sa @ref operator/(const json_pointer&, std::string) for a binary operator

    @since version 3.6.0
    */
    json_pointer& operator/=(std::size_t array_index)
    {
        return *this /= std::to_string(array_index);
    }

    /*!
    @brief create a new JSON pointer by appending the right JSON pointer at the end of the left JSON pointer

    @param[in] lhs  JSON pointer
    @param[in] rhs  JSON pointer
    @return a new JSON pointer with @a rhs appended to @a lhs

    @liveexample{The example shows the usage of `operator/`.,json_pointer__operator_add_binary}

    @complexity Linear in the length of @a lhs and @a rhs.

    @sa @ref operator/=(const json_pointer&) to append a JSON pointer

    @since version 3.6.0
    */
    friend json_pointer operator/(const json_pointer& lhs,
                                  const json_pointer& rhs)
    {
        return json_pointer(lhs) /= rhs;
    }

    /*!
    @brief create a new JSON pointer by appending the unescaped token at the end of the JSON pointer

    @param[in] ptr  JSON pointer
    @param[in] token  reference token
    @return a new JSON pointer with unescaped @a token appended to @a ptr

    @liveexample{The example shows the usage of `operator/`.,json_pointer__operator_add_binary}

    @complexity Linear in the length of @a ptr.

    @sa @ref operator/=(std::string) to append a reference token

    @since version 3.6.0
    */
    friend json_pointer operator/(const json_pointer& ptr, std::string token)
    {
        return json_pointer(ptr) /= std::move(token);
    }

    /*!
    @brief create a new JSON pointer by appending the array-index-token at the end of the JSON pointer

    @param[in] ptr  JSON pointer
    @param[in] array_index  array index
    @return a new JSON pointer with @a array_index appended to @a ptr

    @liveexample{The example shows the usage of `operator/`.,json_pointer__operator_add_binary}

    @complexity Linear in the length of @a ptr.

    @sa @ref operator/=(std::size_t) to append an array index

    @since version 3.6.0
    */
    friend json_pointer operator/(const json_pointer& ptr, std::size_t array_index)
    {
        return json_pointer(ptr) /= array_index;
    }

    /*!
    @brief returns the parent of this JSON pointer

    @return parent of this JSON pointer; in case this JSON pointer is the root,
            the root itself is returned

    @complexity Linear in the length of the JSON pointer.

    @liveexample{The example shows the result of `parent_pointer` for different
    JSON Pointers.,json_pointer__parent_pointer}

    @since version 3.6.0
    */
    json_pointer parent_pointer() const
    {
        if (empty())
        {
            return *this;
        }

        json_pointer res = *this;
        res.pop_back();
        return res;
    }

    /*!
    @brief remove last reference token

    @pre not `empty()`

    @liveexample{The example shows the usage of `pop_back`.,json_pointer__pop_back}

    @complexity Constant.

    @throw out_of_range.405 if JSON pointer has no parent

    @since version 3.6.0
    */
    void pop_back()
    {
        if (JSON_UNLIKELY(empty()))
        {
            JSON_THROW(detail::out_of_range::create(405, "JSON pointer has no parent"));
        }

        reference_tokens.pop_back();
    }

    /*!
    @brief return last reference token

    @pre not `empty()`
    @return last reference token

    @liveexample{The example shows the usage of `back`.,json_pointer__back}

    @complexity Constant.

    @throw out_of_range.405 if JSON pointer has no parent

    @since version 3.6.0
    */
    const std::string& back()
    {
        if (JSON_UNLIKELY(empty()))
        {
            JSON_THROW(detail::out_of_range::create(405, "JSON pointer has no parent"));
        }

        return reference_tokens.back();
    }

    /*!
    @brief append an unescaped token at the end of the reference pointer

    @param[in] token  token to add

    @complexity Amortized constant.

    @liveexample{The example shows the result of `push_back` for different
    JSON Pointers.,json_pointer__push_back}

    @since version 3.6.0
    */
    void push_back(const std::string& token)
    {
        reference_tokens.push_back(token);
    }

    /// @copydoc push_back(const std::string&)
    void push_back(std::string&& token)
    {
        reference_tokens.push_back(std::move(token));
    }

    /*!
    @brief return whether pointer points to the root document

    @return true iff the JSON pointer points to the root document

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @liveexample{The example shows the result of `empty` for different JSON
    Pointers.,json_pointer__empty}

    @since version 3.6.0
    */
    bool empty() const noexcept
    {
        return reference_tokens.empty();
    }

  private:
    /*!
    @param[in] s  reference token to be converted into an array index

    @return integer representation of @a s

    @throw out_of_range.404 if string @a s could not be converted to an integer
    */
    static int array_index(const std::string& s)
    {
        std::size_t processed_chars = 0;
        const int res = std::stoi(s, &processed_chars);

        // check if the string was completely read
        if (JSON_UNLIKELY(processed_chars != s.size()))
        {
            JSON_THROW(detail::out_of_range::create(404, "unresolved reference token '" + s + "'"));
        }

        return res;
    }

    json_pointer top() const
    {
        if (JSON_UNLIKELY(empty()))
        {
            JSON_THROW(detail::out_of_range::create(405, "JSON pointer has no parent"));
        }

        json_pointer result = *this;
        result.reference_tokens = {reference_tokens[0]};
        return result;
    }

    /*!
    @brief create and return a reference to the pointed to value

    @complexity Linear in the number of reference tokens.

    @throw parse_error.109 if array index is not a number
    @throw type_error.313 if value cannot be unflattened
    */
    BasicJsonType& get_and_create(BasicJsonType& j) const
    {
        using size_type = typename BasicJsonType::size_type;
        auto result = &j;

        // in case no reference tokens exist, return a reference to the JSON value
        // j which will be overwritten by a primitive value
        for (const auto& reference_token : reference_tokens)
        {
            switch (result->m_type)
            {
                case detail::value_t::null:
                {
                    if (reference_token == "0")
                    {
                        // start a new array if reference token is 0
                        result = &result->operator[](0);
                    }
                    else
                    {
                        // start a new object otherwise
                        result = &result->operator[](reference_token);
                    }
                    break;
                }

                case detail::value_t::object:
                {
                    // create an entry in the object
                    result = &result->operator[](reference_token);
                    break;
                }

                case detail::value_t::array:
                {
                    // create an entry in the array
                    JSON_TRY
                    {
                        result = &result->operator[](static_cast<size_type>(array_index(reference_token)));
                    }
                    JSON_CATCH(std::invalid_argument&)
                    {
                        JSON_THROW(detail::parse_error::create(109, 0, "array index '" + reference_token + "' is not a number"));
                    }
                    break;
                }

                /*
                The following code is only reached if there exists a reference
                token _and_ the current value is primitive. In this case, we have
                an error situation, because primitive values may only occur as
                single value; that is, with an empty list of reference tokens.
                */
                default:
                    JSON_THROW(detail::type_error::create(313, "invalid value to unflatten"));
            }
        }

        return *result;
    }

    /*!
    @brief return a reference to the pointed to value

    @note This version does not throw if a value is not present, but tries to
          create nested values instead. For instance, calling this function
          with pointer `"/this/that"` on a null value is equivalent to calling
          `operator[]("this").operator[]("that")` on that value, effectively
          changing the null value to an object.

    @param[in] ptr  a JSON value

    @return reference to the JSON value pointed to by the JSON pointer

    @complexity Linear in the length of the JSON pointer.

    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    @throw out_of_range.404  if the JSON pointer can not be resolved
    */
    BasicJsonType& get_unchecked(BasicJsonType* ptr) const
    {
        using size_type = typename BasicJsonType::size_type;
        for (const auto& reference_token : reference_tokens)
        {
            // convert null values to arrays or objects before continuing
            if (ptr->m_type == detail::value_t::null)
            {
                // check if reference token is a number
                const bool nums =
                    std::all_of(reference_token.begin(), reference_token.end(),
                                [](const char x)
                {
                    return x >= '0' and x <= '9';
                });

                // change value to array for numbers or "-" or to object otherwise
                *ptr = (nums or reference_token == "-")
                       ? detail::value_t::array
                       : detail::value_t::object;
            }

            switch (ptr->m_type)
            {
                case detail::value_t::object:
                {
                    // use unchecked object access
                    ptr = &ptr->operator[](reference_token);
                    break;
                }

                case detail::value_t::array:
                {
                    // error condition (cf. RFC 6901, Sect. 4)
                    if (JSON_UNLIKELY(reference_token.size() > 1 and reference_token[0] == '0'))
                    {
                        JSON_THROW(detail::parse_error::create(106, 0,
                                                               "array index '" + reference_token +
                                                               "' must not begin with '0'"));
                    }

                    if (reference_token == "-")
                    {
                        // explicitly treat "-" as index beyond the end
                        ptr = &ptr->operator[](ptr->m_value.array->size());
                    }
                    else
                    {
                        // convert array index to number; unchecked access
                        JSON_TRY
                        {
                            ptr = &ptr->operator[](
                                static_cast<size_type>(array_index(reference_token)));
                        }
                        JSON_CATCH(std::invalid_argument&)
                        {
                            JSON_THROW(detail::parse_error::create(109, 0, "array index '" + reference_token + "' is not a number"));
                        }
                    }
                    break;
                }

                default:
                    JSON_THROW(detail::out_of_range::create(404, "unresolved reference token '" + reference_token + "'"));
            }
        }

        return *ptr;
    }

    /*!
    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    @throw out_of_range.402  if the array index '-' is used
    @throw out_of_range.404  if the JSON pointer can not be resolved
    */
    BasicJsonType& get_checked(BasicJsonType* ptr) const
    {
        using size_type = typename BasicJsonType::size_type;
        for (const auto& reference_token : reference_tokens)
        {
            switch (ptr->m_type)
            {
                case detail::value_t::object:
                {
                    // note: at performs range check
                    ptr = &ptr->at(reference_token);
                    break;
                }

                case detail::value_t::array:
                {
                    if (JSON_UNLIKELY(reference_token == "-"))
                    {
                        // "-" always fails the range check
                        JSON_THROW(detail::out_of_range::create(402,
                                                                "array index '-' (" + std::to_string(ptr->m_value.array->size()) +
                                                                ") is out of range"));
                    }

                    // error condition (cf. RFC 6901, Sect. 4)
                    if (JSON_UNLIKELY(reference_token.size() > 1 and reference_token[0] == '0'))
                    {
                        JSON_THROW(detail::parse_error::create(106, 0,
                                                               "array index '" + reference_token +
                                                               "' must not begin with '0'"));
                    }

                    // note: at performs range check
                    JSON_TRY
                    {
                        ptr = &ptr->at(static_cast<size_type>(array_index(reference_token)));
                    }
                    JSON_CATCH(std::invalid_argument&)
                    {
                        JSON_THROW(detail::parse_error::create(109, 0, "array index '" + reference_token + "' is not a number"));
                    }
                    break;
                }

                default:
                    JSON_THROW(detail::out_of_range::create(404, "unresolved reference token '" + reference_token + "'"));
            }
        }

        return *ptr;
    }

    /*!
    @brief return a const reference to the pointed to value

    @param[in] ptr  a JSON value

    @return const reference to the JSON value pointed to by the JSON
    pointer

    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    @throw out_of_range.402  if the array index '-' is used
    @throw out_of_range.404  if the JSON pointer can not be resolved
    */
    const BasicJsonType& get_unchecked(const BasicJsonType* ptr) const
    {
        using size_type = typename BasicJsonType::size_type;
        for (const auto& reference_token : reference_tokens)
        {
            switch (ptr->m_type)
            {
                case detail::value_t::object:
                {
                    // use unchecked object access
                    ptr = &ptr->operator[](reference_token);
                    break;
                }

                case detail::value_t::array:
                {
                    if (JSON_UNLIKELY(reference_token == "-"))
                    {
                        // "-" cannot be used for const access
                        JSON_THROW(detail::out_of_range::create(402,
                                                                "array index '-' (" + std::to_string(ptr->m_value.array->size()) +
                                                                ") is out of range"));
                    }

                    // error condition (cf. RFC 6901, Sect. 4)
                    if (JSON_UNLIKELY(reference_token.size() > 1 and reference_token[0] == '0'))
                    {
                        JSON_THROW(detail::parse_error::create(106, 0,
                                                               "array index '" + reference_token +
                                                               "' must not begin with '0'"));
                    }

                    // use unchecked array access
                    JSON_TRY
                    {
                        ptr = &ptr->operator[](
                            static_cast<size_type>(array_index(reference_token)));
                    }
                    JSON_CATCH(std::invalid_argument&)
                    {
                        JSON_THROW(detail::parse_error::create(109, 0, "array index '" + reference_token + "' is not a number"));
                    }
                    break;
                }

                default:
                    JSON_THROW(detail::out_of_range::create(404, "unresolved reference token '" + reference_token + "'"));
            }
        }

        return *ptr;
    }

    /*!
    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    @throw out_of_range.402  if the array index '-' is used
    @throw out_of_range.404  if the JSON pointer can not be resolved
    */
    const BasicJsonType& get_checked(const BasicJsonType* ptr) const
    {
        using size_type = typename BasicJsonType::size_type;
        for (const auto& reference_token : reference_tokens)
        {
            switch (ptr->m_type)
            {
                case detail::value_t::object:
                {
                    // note: at performs range check
                    ptr = &ptr->at(reference_token);
                    break;
                }

                case detail::value_t::array:
                {
                    if (JSON_UNLIKELY(reference_token == "-"))
                    {
                        // "-" always fails the range check
                        JSON_THROW(detail::out_of_range::create(402,
                                                                "array index '-' (" + std::to_string(ptr->m_value.array->size()) +
                                                                ") is out of range"));
                    }

                    // error condition (cf. RFC 6901, Sect. 4)
                    if (JSON_UNLIKELY(reference_token.size() > 1 and reference_token[0] == '0'))
                    {
                        JSON_THROW(detail::parse_error::create(106, 0,
                                                               "array index '" + reference_token +
                                                               "' must not begin with '0'"));
                    }

                    // note: at performs range check
                    JSON_TRY
                    {
                        ptr = &ptr->at(static_cast<size_type>(array_index(reference_token)));
                    }
                    JSON_CATCH(std::invalid_argument&)
                    {
                        JSON_THROW(detail::parse_error::create(109, 0, "array index '" + reference_token + "' is not a number"));
                    }
                    break;
                }

                default:
                    JSON_THROW(detail::out_of_range::create(404, "unresolved reference token '" + reference_token + "'"));
            }
        }

        return *ptr;
    }

    /*!
    @brief split the string input to reference tokens

    @note This function is only called by the json_pointer constructor.
          All exceptions below are documented there.

    @throw parse_error.107  if the pointer is not empty or begins with '/'
    @throw parse_error.108  if character '~' is not followed by '0' or '1'
    */
    static std::vector<std::string> split(const std::string& reference_string)
    {
        std::vector<std::string> result;

        // special case: empty reference string -> no reference tokens
        if (reference_string.empty())
        {
            return result;
        }

        // check if nonempty reference string begins with slash
        if (JSON_UNLIKELY(reference_string[0] != '/'))
        {
            JSON_THROW(detail::parse_error::create(107, 1,
                                                   "JSON pointer must be empty or begin with '/' - was: '" +
                                                   reference_string + "'"));
        }

        // extract the reference tokens:
        // - slash: position of the last read slash (or end of string)
        // - start: position after the previous slash
        for (
            // search for the first slash after the first character
            std::size_t slash = reference_string.find_first_of('/', 1),
            // set the beginning of the first reference token
            start = 1;
            // we can stop if start == 0 (if slash == std::string::npos)
            start != 0;
            // set the beginning of the next reference token
            // (will eventually be 0 if slash == std::string::npos)
            start = (slash == std::string::npos) ? 0 : slash + 1,
            // find next slash
            slash = reference_string.find_first_of('/', start))
        {
            // use the text between the beginning of the reference token
            // (start) and the last slash (slash).
            auto reference_token = reference_string.substr(start, slash - start);

            // check reference tokens are properly escaped
            for (std::size_t pos = reference_token.find_first_of('~');
                    pos != std::string::npos;
                    pos = reference_token.find_first_of('~', pos + 1))
            {
                assert(reference_token[pos] == '~');

                // ~ must be followed by 0 or 1
                if (JSON_UNLIKELY(pos == reference_token.size() - 1 or
                                  (reference_token[pos + 1] != '0' and
                                   reference_token[pos + 1] != '1')))
                {
                    JSON_THROW(detail::parse_error::create(108, 0, "escape character '~' must be followed with '0' or '1'"));
                }
            }

            // finally, store the reference token
            unescape(reference_token);
            result.push_back(reference_token);
        }

        return result;
    }

    /*!
    @brief replace all occurrences of a substring by another string

    @param[in,out] s  the string to manipulate; changed so that all
                   occurrences of @a f are replaced with @a t
    @param[in]     f  the substring to replace with @a t
    @param[in]     t  the string to replace @a f

    @pre The search string @a f must not be empty. **This precondition is
    enforced with an assertion.**

    @since version 2.0.0
    */
    static void replace_substring(std::string& s, const std::string& f,
                                  const std::string& t)
    {
        assert(not f.empty());
        for (auto pos = s.find(f);                // find first occurrence of f
                pos != std::string::npos;         // make sure f was found
                s.replace(pos, f.size(), t),      // replace with t, and
                pos = s.find(f, pos + t.size()))  // find next occurrence of f
        {}
    }

    /// escape "~" to "~0" and "/" to "~1"
    static std::string escape(std::string s)
    {
        replace_substring(s, "~", "~0");
        replace_substring(s, "/", "~1");
        return s;
    }

    /// unescape "~1" to tilde and "~0" to slash (order is important!)
    static void unescape(std::string& s)
    {
        replace_substring(s, "~1", "/");
        replace_substring(s, "~0", "~");
    }

    /*!
    @param[in] reference_string  the reference string to the current value
    @param[in] value             the value to consider
    @param[in,out] result        the result object to insert values to

    @note Empty objects or arrays are flattened to `null`.
    */
    static void flatten(const std::string& reference_string,
                        const BasicJsonType& value,
                        BasicJsonType& result)
    {
        switch (value.m_type)
        {
            case detail::value_t::array:
            {
                if (value.m_value.array->empty())
                {
                    // flatten empty array as null
                    result[reference_string] = nullptr;
                }
                else
                {
                    // iterate array and use index as reference string
                    for (std::size_t i = 0; i < value.m_value.array->size(); ++i)
                    {
                        flatten(reference_string + "/" + std::to_string(i),
                                value.m_value.array->operator[](i), result);
                    }
                }
                break;
            }

            case detail::value_t::object:
            {
                if (value.m_value.object->empty())
                {
                    // flatten empty object as null
                    result[reference_string] = nullptr;
                }
                else
                {
                    // iterate object and use keys as reference string
                    for (const auto& element : *value.m_value.object)
                    {
                        flatten(reference_string + "/" + escape(element.first), element.second, result);
                    }
                }
                break;
            }

            default:
            {
                // add primitive value with its reference string
                result[reference_string] = value;
                break;
            }
        }
    }

    /*!
    @param[in] value  flattened JSON

    @return unflattened JSON

    @throw parse_error.109 if array index is not a number
    @throw type_error.314  if value is not an object
    @throw type_error.315  if object values are not primitive
    @throw type_error.313  if value cannot be unflattened
    */
    static BasicJsonType
    unflatten(const BasicJsonType& value)
    {
        if (JSON_UNLIKELY(not value.is_object()))
        {
            JSON_THROW(detail::type_error::create(314, "only objects can be unflattened"));
        }

        BasicJsonType result;

        // iterate the JSON object values
        for (const auto& element : *value.m_value.object)
        {
            if (JSON_UNLIKELY(not element.second.is_primitive()))
            {
                JSON_THROW(detail::type_error::create(315, "values in object must be primitive"));
            }

            // assign value to reference pointed to by JSON pointer; Note that if
            // the JSON pointer is "" (i.e., points to the whole value), function
            // get_and_create returns a reference to result itself. An assignment
            // will then create a primitive value.
            json_pointer(element.first).get_and_create(result) = element.second;
        }

        return result;
    }

    /*!
    @brief compares two JSON pointers for equality

    @param[in] lhs  JSON pointer to compare
    @param[in] rhs  JSON pointer to compare
    @return whether @a lhs is equal to @a rhs

    @complexity Linear in the length of the JSON pointer

    @exceptionsafety No-throw guarantee: this function never throws exceptions.
    */
    friend bool operator==(json_pointer const& lhs,
                           json_pointer const& rhs) noexcept
    {
        return lhs.reference_tokens == rhs.reference_tokens;
    }

    /*!
    @brief compares two JSON pointers for inequality

    @param[in] lhs  JSON pointer to compare
    @param[in] rhs  JSON pointer to compare
    @return whether @a lhs is not equal @a rhs

    @complexity Linear in the length of the JSON pointer

    @exceptionsafety No-throw guarantee: this function never throws exceptions.
    */
    friend bool operator!=(json_pointer const& lhs,
                           json_pointer const& rhs) noexcept
    {
        return not (lhs == rhs);
    }

    /// the reference tokens
    std::vector<std::string> reference_tokens;
};
}  // namespace nlohmann

// #include <nlohmann/detail/json_ref.hpp>


#include <initializer_list>
#include <utility>

// #include <nlohmann/detail/meta/type_traits.hpp>


namespace nlohmann
{
namespace detail
{
template<typename BasicJsonType>
class json_ref
{
  public:
    using value_type = BasicJsonType;

    json_ref(value_type&& value)
        : owned_value(std::move(value)), value_ref(&owned_value), is_rvalue(true)
    {}

    json_ref(const value_type& value)
        : value_ref(const_cast<value_type*>(&value)), is_rvalue(false)
    {}

    json_ref(std::initializer_list<json_ref> init)
        : owned_value(init), value_ref(&owned_value), is_rvalue(true)
    {}

    template <
        class... Args,
        enable_if_t<std::is_constructible<value_type, Args...>::value, int> = 0 >
    json_ref(Args && ... args)
        : owned_value(std::forward<Args>(args)...), value_ref(&owned_value),
          is_rvalue(true) {}

    // class should be movable only
    json_ref(json_ref&&) = default;
    json_ref(const json_ref&) = delete;
    json_ref& operator=(const json_ref&) = delete;
    json_ref& operator=(json_ref&&) = delete;
    ~json_ref() = default;

    value_type moved_or_copied() const
    {
        if (is_rvalue)
        {
            return std::move(*value_ref);
        }
        return *value_ref;
    }

    value_type const& operator*() const
    {
        return *static_cast<value_type const*>(value_ref);
    }

    value_type const* operator->() const
    {
        return static_cast<value_type const*>(value_ref);
    }

  private:
    mutable value_type owned_value = nullptr;
    value_type* value_ref = nullptr;
    const bool is_rvalue;
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/meta/type_traits.hpp>

// #include <nlohmann/detail/output/binary_writer.hpp>


#include <algorithm> // reverse
#include <array> // array
#include <cstdint> // uint8_t, uint16_t, uint32_t, uint64_t
#include <cstring> // memcpy
#include <limits> // numeric_limits
#include <string> // string

// #include <nlohmann/detail/input/binary_reader.hpp>

// #include <nlohmann/detail/output/output_adapters.hpp>


#include <algorithm> // copy
#include <cstddef> // size_t
#include <ios> // streamsize
#include <iterator> // back_inserter
#include <memory> // shared_ptr, make_shared
#include <ostream> // basic_ostream
#include <string> // basic_string
#include <vector> // vector

namespace nlohmann
{
namespace detail
{
/// abstract output adapter interface
template<typename CharType> struct output_adapter_protocol
{
    virtual void write_character(CharType c) = 0;
    virtual void write_characters(const CharType* s, std::size_t length) = 0;
    virtual ~output_adapter_protocol() = default;
};

/// a type to simplify interfaces
template<typename CharType>
using output_adapter_t = std::shared_ptr<output_adapter_protocol<CharType>>;

/// output adapter for byte vectors
template<typename CharType>
class output_vector_adapter : public output_adapter_protocol<CharType>
{
  public:
    explicit output_vector_adapter(std::vector<CharType>& vec) noexcept
        : v(vec)
    {}

    void write_character(CharType c) override
    {
        v.push_back(c);
    }

    void write_characters(const CharType* s, std::size_t length) override
    {
        std::copy(s, s + length, std::back_inserter(v));
    }

  private:
    std::vector<CharType>& v;
};

/// output adapter for output streams
template<typename CharType>
class output_stream_adapter : public output_adapter_protocol<CharType>
{
  public:
    explicit output_stream_adapter(std::basic_ostream<CharType>& s) noexcept
        : stream(s)
    {}

    void write_character(CharType c) override
    {
        stream.put(c);
    }

    void write_characters(const CharType* s, std::size_t length) override
    {
        stream.write(s, static_cast<std::streamsize>(length));
    }

  private:
    std::basic_ostream<CharType>& stream;
};

/// output adapter for basic_string
template<typename CharType, typename StringType = std::basic_string<CharType>>
class output_string_adapter : public output_adapter_protocol<CharType>
{
  public:
    explicit output_string_adapter(StringType& s) noexcept
        : str(s)
    {}

    void write_character(CharType c) override
    {
        str.push_back(c);
    }

    void write_characters(const CharType* s, std::size_t length) override
    {
        str.append(s, length);
    }

  private:
    StringType& str;
};

template<typename CharType, typename StringType = std::basic_string<CharType>>
class output_adapter
{
  public:
    output_adapter(std::vector<CharType>& vec)
        : oa(std::make_shared<output_vector_adapter<CharType>>(vec)) {}

    output_adapter(std::basic_ostream<CharType>& s)
        : oa(std::make_shared<output_stream_adapter<CharType>>(s)) {}

    output_adapter(StringType& s)
        : oa(std::make_shared<output_string_adapter<CharType, StringType>>(s)) {}

    operator output_adapter_t<CharType>()
    {
        return oa;
    }

  private:
    output_adapter_t<CharType> oa = nullptr;
};
}  // namespace detail
}  // namespace nlohmann


namespace nlohmann
{
namespace detail
{
///////////////////
// binary writer //
///////////////////

/*!
@brief serialization to CBOR and MessagePack values
*/
template<typename BasicJsonType, typename CharType>
class binary_writer
{
    using string_t = typename BasicJsonType::string_t;

  public:
    /*!
    @brief create a binary writer

    @param[in] adapter  output adapter to write to
    */
    explicit binary_writer(output_adapter_t<CharType> adapter) : oa(adapter)
    {
        assert(oa);
    }

    /*!
    @param[in] j  JSON value to serialize
    @pre       j.type() == value_t::object
    */
    void write_bson(const BasicJsonType& j)
    {
        switch (j.type())
        {
            case value_t::object:
            {
                write_bson_object(*j.m_value.object);
                break;
            }

            default:
            {
                JSON_THROW(type_error::create(317, "to serialize to BSON, top-level type must be object, but is " + std::string(j.type_name())));
            }
        }
    }

    /*!
    @param[in] j  JSON value to serialize
    */
    void write_cbor(const BasicJsonType& j)
    {
        switch (j.type())
        {
            case value_t::null:
            {
                oa->write_character(to_char_type(0xF6));
                break;
            }

            case value_t::boolean:
            {
                oa->write_character(j.m_value.boolean
                                    ? to_char_type(0xF5)
                                    : to_char_type(0xF4));
                break;
            }

            case value_t::number_integer:
            {
                if (j.m_value.number_integer >= 0)
                {
                    // CBOR does not differentiate between positive signed
                    // integers and unsigned integers. Therefore, we used the
                    // code from the value_t::number_unsigned case here.
                    if (j.m_value.number_integer <= 0x17)
                    {
                        write_number(static_cast<std::uint8_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_integer <= (std::numeric_limits<std::uint8_t>::max)())
                    {
                        oa->write_character(to_char_type(0x18));
                        write_number(static_cast<std::uint8_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_integer <= (std::numeric_limits<std::uint16_t>::max)())
                    {
                        oa->write_character(to_char_type(0x19));
                        write_number(static_cast<std::uint16_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_integer <= (std::numeric_limits<std::uint32_t>::max)())
                    {
                        oa->write_character(to_char_type(0x1A));
                        write_number(static_cast<std::uint32_t>(j.m_value.number_integer));
                    }
                    else
                    {
                        oa->write_character(to_char_type(0x1B));
                        write_number(static_cast<std::uint64_t>(j.m_value.number_integer));
                    }
                }
                else
                {
                    // The conversions below encode the sign in the first
                    // byte, and the value is converted to a positive number.
                    const auto positive_number = -1 - j.m_value.number_integer;
                    if (j.m_value.number_integer >= -24)
                    {
                        write_number(static_cast<std::uint8_t>(0x20 + positive_number));
                    }
                    else if (positive_number <= (std::numeric_limits<std::uint8_t>::max)())
                    {
                        oa->write_character(to_char_type(0x38));
                        write_number(static_cast<std::uint8_t>(positive_number));
                    }
                    else if (positive_number <= (std::numeric_limits<std::uint16_t>::max)())
                    {
                        oa->write_character(to_char_type(0x39));
                        write_number(static_cast<std::uint16_t>(positive_number));
                    }
                    else if (positive_number <= (std::numeric_limits<std::uint32_t>::max)())
                    {
                        oa->write_character(to_char_type(0x3A));
                        write_number(static_cast<std::uint32_t>(positive_number));
                    }
                    else
                    {
                        oa->write_character(to_char_type(0x3B));
                        write_number(static_cast<std::uint64_t>(positive_number));
                    }
                }
                break;
            }

            case value_t::number_unsigned:
            {
                if (j.m_value.number_unsigned <= 0x17)
                {
                    write_number(static_cast<std::uint8_t>(j.m_value.number_unsigned));
                }
                else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    oa->write_character(to_char_type(0x18));
                    write_number(static_cast<std::uint8_t>(j.m_value.number_unsigned));
                }
                else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    oa->write_character(to_char_type(0x19));
                    write_number(static_cast<std::uint16_t>(j.m_value.number_unsigned));
                }
                else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    oa->write_character(to_char_type(0x1A));
                    write_number(static_cast<std::uint32_t>(j.m_value.number_unsigned));
                }
                else
                {
                    oa->write_character(to_char_type(0x1B));
                    write_number(static_cast<std::uint64_t>(j.m_value.number_unsigned));
                }
                break;
            }

            case value_t::number_float:
            {
                oa->write_character(get_cbor_float_prefix(j.m_value.number_float));
                write_number(j.m_value.number_float);
                break;
            }

            case value_t::string:
            {
                // step 1: write control byte and the string length
                const auto N = j.m_value.string->size();
                if (N <= 0x17)
                {
                    write_number(static_cast<std::uint8_t>(0x60 + N));
                }
                else if (N <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    oa->write_character(to_char_type(0x78));
                    write_number(static_cast<std::uint8_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    oa->write_character(to_char_type(0x79));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    oa->write_character(to_char_type(0x7A));
                    write_number(static_cast<std::uint32_t>(N));
                }
                // LCOV_EXCL_START
                else if (N <= (std::numeric_limits<std::uint64_t>::max)())
                {
                    oa->write_character(to_char_type(0x7B));
                    write_number(static_cast<std::uint64_t>(N));
                }
                // LCOV_EXCL_STOP

                // step 2: write the string
                oa->write_characters(
                    reinterpret_cast<const CharType*>(j.m_value.string->c_str()),
                    j.m_value.string->size());
                break;
            }

            case value_t::array:
            {
                // step 1: write control byte and the array size
                const auto N = j.m_value.array->size();
                if (N <= 0x17)
                {
                    write_number(static_cast<std::uint8_t>(0x80 + N));
                }
                else if (N <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    oa->write_character(to_char_type(0x98));
                    write_number(static_cast<std::uint8_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    oa->write_character(to_char_type(0x99));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    oa->write_character(to_char_type(0x9A));
                    write_number(static_cast<std::uint32_t>(N));
                }
                // LCOV_EXCL_START
                else if (N <= (std::numeric_limits<std::uint64_t>::max)())
                {
                    oa->write_character(to_char_type(0x9B));
                    write_number(static_cast<std::uint64_t>(N));
                }
                // LCOV_EXCL_STOP

                // step 2: write each element
                for (const auto& el : *j.m_value.array)
                {
                    write_cbor(el);
                }
                break;
            }

            case value_t::object:
            {
                // step 1: write control byte and the object size
                const auto N = j.m_value.object->size();
                if (N <= 0x17)
                {
                    write_number(static_cast<std::uint8_t>(0xA0 + N));
                }
                else if (N <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    oa->write_character(to_char_type(0xB8));
                    write_number(static_cast<std::uint8_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    oa->write_character(to_char_type(0xB9));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    oa->write_character(to_char_type(0xBA));
                    write_number(static_cast<std::uint32_t>(N));
                }
                // LCOV_EXCL_START
                else if (N <= (std::numeric_limits<std::uint64_t>::max)())
                {
                    oa->write_character(to_char_type(0xBB));
                    write_number(static_cast<std::uint64_t>(N));
                }
                // LCOV_EXCL_STOP

                // step 2: write each element
                for (const auto& el : *j.m_value.object)
                {
                    write_cbor(el.first);
                    write_cbor(el.second);
                }
                break;
            }

            default:
                break;
        }
    }

    /*!
    @param[in] j  JSON value to serialize
    */
    void write_msgpack(const BasicJsonType& j)
    {
        switch (j.type())
        {
            case value_t::null: // nil
            {
                oa->write_character(to_char_type(0xC0));
                break;
            }

            case value_t::boolean: // true and false
            {
                oa->write_character(j.m_value.boolean
                                    ? to_char_type(0xC3)
                                    : to_char_type(0xC2));
                break;
            }

            case value_t::number_integer:
            {
                if (j.m_value.number_integer >= 0)
                {
                    // MessagePack does not differentiate between positive
                    // signed integers and unsigned integers. Therefore, we used
                    // the code from the value_t::number_unsigned case here.
                    if (j.m_value.number_unsigned < 128)
                    {
                        // positive fixnum
                        write_number(static_cast<std::uint8_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint8_t>::max)())
                    {
                        // uint 8
                        oa->write_character(to_char_type(0xCC));
                        write_number(static_cast<std::uint8_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint16_t>::max)())
                    {
                        // uint 16
                        oa->write_character(to_char_type(0xCD));
                        write_number(static_cast<std::uint16_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint32_t>::max)())
                    {
                        // uint 32
                        oa->write_character(to_char_type(0xCE));
                        write_number(static_cast<std::uint32_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint64_t>::max)())
                    {
                        // uint 64
                        oa->write_character(to_char_type(0xCF));
                        write_number(static_cast<std::uint64_t>(j.m_value.number_integer));
                    }
                }
                else
                {
                    if (j.m_value.number_integer >= -32)
                    {
                        // negative fixnum
                        write_number(static_cast<std::int8_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_integer >= (std::numeric_limits<std::int8_t>::min)() and
                             j.m_value.number_integer <= (std::numeric_limits<std::int8_t>::max)())
                    {
                        // int 8
                        oa->write_character(to_char_type(0xD0));
                        write_number(static_cast<std::int8_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_integer >= (std::numeric_limits<std::int16_t>::min)() and
                             j.m_value.number_integer <= (std::numeric_limits<std::int16_t>::max)())
                    {
                        // int 16
                        oa->write_character(to_char_type(0xD1));
                        write_number(static_cast<std::int16_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_integer >= (std::numeric_limits<std::int32_t>::min)() and
                             j.m_value.number_integer <= (std::numeric_limits<std::int32_t>::max)())
                    {
                        // int 32
                        oa->write_character(to_char_type(0xD2));
                        write_number(static_cast<std::int32_t>(j.m_value.number_integer));
                    }
                    else if (j.m_value.number_integer >= (std::numeric_limits<std::int64_t>::min)() and
                             j.m_value.number_integer <= (std::numeric_limits<std::int64_t>::max)())
                    {
                        // int 64
                        oa->write_character(to_char_type(0xD3));
                        write_number(static_cast<std::int64_t>(j.m_value.number_integer));
                    }
                }
                break;
            }

            case value_t::number_unsigned:
            {
                if (j.m_value.number_unsigned < 128)
                {
                    // positive fixnum
                    write_number(static_cast<std::uint8_t>(j.m_value.number_integer));
                }
                else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    // uint 8
                    oa->write_character(to_char_type(0xCC));
                    write_number(static_cast<std::uint8_t>(j.m_value.number_integer));
                }
                else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    // uint 16
                    oa->write_character(to_char_type(0xCD));
                    write_number(static_cast<std::uint16_t>(j.m_value.number_integer));
                }
                else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    // uint 32
                    oa->write_character(to_char_type(0xCE));
                    write_number(static_cast<std::uint32_t>(j.m_value.number_integer));
                }
                else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint64_t>::max)())
                {
                    // uint 64
                    oa->write_character(to_char_type(0xCF));
                    write_number(static_cast<std::uint64_t>(j.m_value.number_integer));
                }
                break;
            }

            case value_t::number_float:
            {
                oa->write_character(get_msgpack_float_prefix(j.m_value.number_float));
                write_number(j.m_value.number_float);
                break;
            }

            case value_t::string:
            {
                // step 1: write control byte and the string length
                const auto N = j.m_value.string->size();
                if (N <= 31)
                {
                    // fixstr
                    write_number(static_cast<std::uint8_t>(0xA0 | N));
                }
                else if (N <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    // str 8
                    oa->write_character(to_char_type(0xD9));
                    write_number(static_cast<std::uint8_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    // str 16
                    oa->write_character(to_char_type(0xDA));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    // str 32
                    oa->write_character(to_char_type(0xDB));
                    write_number(static_cast<std::uint32_t>(N));
                }

                // step 2: write the string
                oa->write_characters(
                    reinterpret_cast<const CharType*>(j.m_value.string->c_str()),
                    j.m_value.string->size());
                break;
            }

            case value_t::array:
            {
                // step 1: write control byte and the array size
                const auto N = j.m_value.array->size();
                if (N <= 15)
                {
                    // fixarray
                    write_number(static_cast<std::uint8_t>(0x90 | N));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    // array 16
                    oa->write_character(to_char_type(0xDC));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    // array 32
                    oa->write_character(to_char_type(0xDD));
                    write_number(static_cast<std::uint32_t>(N));
                }

                // step 2: write each element
                for (const auto& el : *j.m_value.array)
                {
                    write_msgpack(el);
                }
                break;
            }

            case value_t::object:
            {
                // step 1: write control byte and the object size
                const auto N = j.m_value.object->size();
                if (N <= 15)
                {
                    // fixmap
                    write_number(static_cast<std::uint8_t>(0x80 | (N & 0xF)));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    // map 16
                    oa->write_character(to_char_type(0xDE));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    // map 32
                    oa->write_character(to_char_type(0xDF));
                    write_number(static_cast<std::uint32_t>(N));
                }

                // step 2: write each element
                for (const auto& el : *j.m_value.object)
                {
                    write_msgpack(el.first);
                    write_msgpack(el.second);
                }
                break;
            }

            default:
                break;
        }
    }

    /*!
    @param[in] j  JSON value to serialize
    @param[in] use_count   whether to use '#' prefixes (optimized format)
    @param[in] use_type    whether to use '$' prefixes (optimized format)
    @param[in] add_prefix  whether prefixes need to be used for this value
    */
    void write_ubjson(const BasicJsonType& j, const bool use_count,
                      const bool use_type, const bool add_prefix = true)
    {
        switch (j.type())
        {
            case value_t::null:
            {
                if (add_prefix)
                {
                    oa->write_character(to_char_type('Z'));
                }
                break;
            }

            case value_t::boolean:
            {
                if (add_prefix)
                {
                    oa->write_character(j.m_value.boolean
                                        ? to_char_type('T')
                                        : to_char_type('F'));
                }
                break;
            }

            case value_t::number_integer:
            {
                write_number_with_ubjson_prefix(j.m_value.number_integer, add_prefix);
                break;
            }

            case value_t::number_unsigned:
            {
                write_number_with_ubjson_prefix(j.m_value.number_unsigned, add_prefix);
                break;
            }

            case value_t::number_float:
            {
                write_number_with_ubjson_prefix(j.m_value.number_float, add_prefix);
                break;
            }

            case value_t::string:
            {
                if (add_prefix)
                {
                    oa->write_character(to_char_type('S'));
                }
                write_number_with_ubjson_prefix(j.m_value.string->size(), true);
                oa->write_characters(
                    reinterpret_cast<const CharType*>(j.m_value.string->c_str()),
                    j.m_value.string->size());
                break;
            }

            case value_t::array:
            {
                if (add_prefix)
                {
                    oa->write_character(to_char_type('['));
                }

                bool prefix_required = true;
                if (use_type and not j.m_value.array->empty())
                {
                    assert(use_count);
                    const CharType first_prefix = ubjson_prefix(j.front());
                    const bool same_prefix = std::all_of(j.begin() + 1, j.end(),
                                                         [this, first_prefix](const BasicJsonType & v)
                    {
                        return ubjson_prefix(v) == first_prefix;
                    });

                    if (same_prefix)
                    {
                        prefix_required = false;
                        oa->write_character(to_char_type('$'));
                        oa->write_character(first_prefix);
                    }
                }

                if (use_count)
                {
                    oa->write_character(to_char_type('#'));
                    write_number_with_ubjson_prefix(j.m_value.array->size(), true);
                }

                for (const auto& el : *j.m_value.array)
                {
                    write_ubjson(el, use_count, use_type, prefix_required);
                }

                if (not use_count)
                {
                    oa->write_character(to_char_type(']'));
                }

                break;
            }

            case value_t::object:
            {
                if (add_prefix)
                {
                    oa->write_character(to_char_type('{'));
                }

                bool prefix_required = true;
                if (use_type and not j.m_value.object->empty())
                {
                    assert(use_count);
                    const CharType first_prefix = ubjson_prefix(j.front());
                    const bool same_prefix = std::all_of(j.begin(), j.end(),
                                                         [this, first_prefix](const BasicJsonType & v)
                    {
                        return ubjson_prefix(v) == first_prefix;
                    });

                    if (same_prefix)
                    {
                        prefix_required = false;
                        oa->write_character(to_char_type('$'));
                        oa->write_character(first_prefix);
                    }
                }

                if (use_count)
                {
                    oa->write_character(to_char_type('#'));
                    write_number_with_ubjson_prefix(j.m_value.object->size(), true);
                }

                for (const auto& el : *j.m_value.object)
                {
                    write_number_with_ubjson_prefix(el.first.size(), true);
                    oa->write_characters(
                        reinterpret_cast<const CharType*>(el.first.c_str()),
                        el.first.size());
                    write_ubjson(el.second, use_count, use_type, prefix_required);
                }

                if (not use_count)
                {
                    oa->write_character(to_char_type('}'));
                }

                break;
            }

            default:
                break;
        }
    }

  private:
    //////////
    // BSON //
    //////////

    /*!
    @return The size of a BSON document entry header, including the id marker
            and the entry name size (and its null-terminator).
    */
    static std::size_t calc_bson_entry_header_size(const string_t& name)
    {
        const auto it = name.find(static_cast<typename string_t::value_type>(0));
        if (JSON_UNLIKELY(it != BasicJsonType::string_t::npos))
        {
            JSON_THROW(out_of_range::create(409,
                                            "BSON key cannot contain code point U+0000 (at byte " + std::to_string(it) + ")"));
        }

        return /*id*/ 1ul + name.size() + /*zero-terminator*/1u;
    }

    /*!
    @brief Writes the given @a element_type and @a name to the output adapter
    */
    void write_bson_entry_header(const string_t& name,
                                 const std::uint8_t element_type)
    {
        oa->write_character(to_char_type(element_type)); // boolean
        oa->write_characters(
            reinterpret_cast<const CharType*>(name.c_str()),
            name.size() + 1u);
    }

    /*!
    @brief Writes a BSON element with key @a name and boolean value @a value
    */
    void write_bson_boolean(const string_t& name,
                            const bool value)
    {
        write_bson_entry_header(name, 0x08);
        oa->write_character(value ? to_char_type(0x01) : to_char_type(0x00));
    }

    /*!
    @brief Writes a BSON element with key @a name and double value @a value
    */
    void write_bson_double(const string_t& name,
                           const double value)
    {
        write_bson_entry_header(name, 0x01);
        write_number<double, true>(value);
    }

    /*!
    @return The size of the BSON-encoded string in @a value
    */
    static std::size_t calc_bson_string_size(const string_t& value)
    {
        return sizeof(std::int32_t) + value.size() + 1ul;
    }

    /*!
    @brief Writes a BSON element with key @a name and string value @a value
    */
    void write_bson_string(const string_t& name,
                           const string_t& value)
    {
        write_bson_entry_header(name, 0x02);

        write_number<std::int32_t, true>(static_cast<std::int32_t>(value.size() + 1ul));
        oa->write_characters(
            reinterpret_cast<const CharType*>(value.c_str()),
            value.size() + 1);
    }

    /*!
    @brief Writes a BSON element with key @a name and null value
    */
    void write_bson_null(const string_t& name)
    {
        write_bson_entry_header(name, 0x0A);
    }

    /*!
    @return The size of the BSON-encoded integer @a value
    */
    static std::size_t calc_bson_integer_size(const std::int64_t value)
    {
        return (std::numeric_limits<std::int32_t>::min)() <= value and value <= (std::numeric_limits<std::int32_t>::max)()
               ? sizeof(std::int32_t)
               : sizeof(std::int64_t);
    }

    /*!
    @brief Writes a BSON element with key @a name and integer @a value
    */
    void write_bson_integer(const string_t& name,
                            const std::int64_t value)
    {
        if ((std::numeric_limits<std::int32_t>::min)() <= value and value <= (std::numeric_limits<std::int32_t>::max)())
        {
            write_bson_entry_header(name, 0x10); // int32
            write_number<std::int32_t, true>(static_cast<std::int32_t>(value));
        }
        else
        {
            write_bson_entry_header(name, 0x12); // int64
            write_number<std::int64_t, true>(static_cast<std::int64_t>(value));
        }
    }

    /*!
    @return The size of the BSON-encoded unsigned integer in @a j
    */
    static constexpr std::size_t calc_bson_unsigned_size(const std::uint64_t value) noexcept
    {
        return (value <= static_cast<std::uint64_t>((std::numeric_limits<std::int32_t>::max)()))
               ? sizeof(std::int32_t)
               : sizeof(std::int64_t);
    }

    /*!
    @brief Writes a BSON element with key @a name and unsigned @a value
    */
    void write_bson_unsigned(const string_t& name,
                             const std::uint64_t value)
    {
        if (value <= static_cast<std::uint64_t>((std::numeric_limits<std::int32_t>::max)()))
        {
            write_bson_entry_header(name, 0x10 /* int32 */);
            write_number<std::int32_t, true>(static_cast<std::int32_t>(value));
        }
        else if (value <= static_cast<std::uint64_t>((std::numeric_limits<std::int64_t>::max)()))
        {
            write_bson_entry_header(name, 0x12 /* int64 */);
            write_number<std::int64_t, true>(static_cast<std::int64_t>(value));
        }
        else
        {
            JSON_THROW(out_of_range::create(407, "integer number " + std::to_string(value) + " cannot be represented by BSON as it does not fit int64"));
        }
    }

    /*!
    @brief Writes a BSON element with key @a name and object @a value
    */
    void write_bson_object_entry(const string_t& name,
                                 const typename BasicJsonType::object_t& value)
    {
        write_bson_entry_header(name, 0x03); // object
        write_bson_object(value);
    }

    /*!
    @return The size of the BSON-encoded array @a value
    */
    static std::size_t calc_bson_array_size(const typename BasicJsonType::array_t& value)
    {
        std::size_t embedded_document_size = 0ul;
        std::size_t array_index = 0ul;

        for (const auto& el : value)
        {
            embedded_document_size += calc_bson_element_size(std::to_string(array_index++), el);
        }

        return sizeof(std::int32_t) + embedded_document_size + 1ul;
    }

    /*!
    @brief Writes a BSON element with key @a name and array @a value
    */
    void write_bson_array(const string_t& name,
                          const typename BasicJsonType::array_t& value)
    {
        write_bson_entry_header(name, 0x04); // array
        write_number<std::int32_t, true>(static_cast<std::int32_t>(calc_bson_array_size(value)));

        std::size_t array_index = 0ul;

        for (const auto& el : value)
        {
            write_bson_element(std::to_string(array_index++), el);
        }

        oa->write_character(to_char_type(0x00));
    }

    /*!
    @brief Calculates the size necessary to serialize the JSON value @a j with its @a name
    @return The calculated size for the BSON document entry for @a j with the given @a name.
    */
    static std::size_t calc_bson_element_size(const string_t& name,
            const BasicJsonType& j)
    {
        const auto header_size = calc_bson_entry_header_size(name);
        switch (j.type())
        {
            case value_t::object:
                return header_size + calc_bson_object_size(*j.m_value.object);

            case value_t::array:
                return header_size + calc_bson_array_size(*j.m_value.array);

            case value_t::boolean:
                return header_size + 1ul;

            case value_t::number_float:
                return header_size + 8ul;

            case value_t::number_integer:
                return header_size + calc_bson_integer_size(j.m_value.number_integer);

            case value_t::number_unsigned:
                return header_size + calc_bson_unsigned_size(j.m_value.number_unsigned);

            case value_t::string:
                return header_size + calc_bson_string_size(*j.m_value.string);

            case value_t::null:
                return header_size + 0ul;

            // LCOV_EXCL_START
            default:
                assert(false);
                return 0ul;
                // LCOV_EXCL_STOP
        }
    }

    /*!
    @brief Serializes the JSON value @a j to BSON and associates it with the
           key @a name.
    @param name The name to associate with the JSON entity @a j within the
                current BSON document
    @return The size of the BSON entry
    */
    void write_bson_element(const string_t& name,
                            const BasicJsonType& j)
    {
        switch (j.type())
        {
            case value_t::object:
                return write_bson_object_entry(name, *j.m_value.object);

            case value_t::array:
                return write_bson_array(name, *j.m_value.array);

            case value_t::boolean:
                return write_bson_boolean(name, j.m_value.boolean);

            case value_t::number_float:
                return write_bson_double(name, j.m_value.number_float);

            case value_t::number_integer:
                return write_bson_integer(name, j.m_value.number_integer);

            case value_t::number_unsigned:
                return write_bson_unsigned(name, j.m_value.number_unsigned);

            case value_t::string:
                return write_bson_string(name, *j.m_value.string);

            case value_t::null:
                return write_bson_null(name);

            // LCOV_EXCL_START
            default:
                assert(false);
                return;
                // LCOV_EXCL_STOP
        }
    }

    /*!
    @brief Calculates the size of the BSON serialization of the given
           JSON-object @a j.
    @param[in] j  JSON value to serialize
    @pre       j.type() == value_t::object
    */
    static std::size_t calc_bson_object_size(const typename BasicJsonType::object_t& value)
    {
        std::size_t document_size = std::accumulate(value.begin(), value.end(), 0ul,
                                    [](size_t result, const typename BasicJsonType::object_t::value_type & el)
        {
            return result += calc_bson_element_size(el.first, el.second);
        });

        return sizeof(std::int32_t) + document_size + 1ul;
    }

    /*!
    @param[in] j  JSON value to serialize
    @pre       j.type() == value_t::object
    */
    void write_bson_object(const typename BasicJsonType::object_t& value)
    {
        write_number<std::int32_t, true>(static_cast<std::int32_t>(calc_bson_object_size(value)));

        for (const auto& el : value)
        {
            write_bson_element(el.first, el.second);
        }

        oa->write_character(to_char_type(0x00));
    }

    //////////
    // CBOR //
    //////////

    static constexpr CharType get_cbor_float_prefix(float /*unused*/)
    {
        return to_char_type(0xFA);  // Single-Precision Float
    }

    static constexpr CharType get_cbor_float_prefix(double /*unused*/)
    {
        return to_char_type(0xFB);  // Double-Precision Float
    }

    /////////////
    // MsgPack //
    /////////////

    static constexpr CharType get_msgpack_float_prefix(float /*unused*/)
    {
        return to_char_type(0xCA);  // float 32
    }

    static constexpr CharType get_msgpack_float_prefix(double /*unused*/)
    {
        return to_char_type(0xCB);  // float 64
    }

    ////////////
    // UBJSON //
    ////////////

    // UBJSON: write number (floating point)
    template<typename NumberType, typename std::enable_if<
                 std::is_floating_point<NumberType>::value, int>::type = 0>
    void write_number_with_ubjson_prefix(const NumberType n,
                                         const bool add_prefix)
    {
        if (add_prefix)
        {
            oa->write_character(get_ubjson_float_prefix(n));
        }
        write_number(n);
    }

    // UBJSON: write number (unsigned integer)
    template<typename NumberType, typename std::enable_if<
                 std::is_unsigned<NumberType>::value, int>::type = 0>
    void write_number_with_ubjson_prefix(const NumberType n,
                                         const bool add_prefix)
    {
        if (n <= static_cast<std::uint64_t>((std::numeric_limits<std::int8_t>::max)()))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('i'));  // int8
            }
            write_number(static_cast<std::uint8_t>(n));
        }
        else if (n <= (std::numeric_limits<std::uint8_t>::max)())
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('U'));  // uint8
            }
            write_number(static_cast<std::uint8_t>(n));
        }
        else if (n <= static_cast<std::uint64_t>((std::numeric_limits<std::int16_t>::max)()))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('I'));  // int16
            }
            write_number(static_cast<std::int16_t>(n));
        }
        else if (n <= static_cast<std::uint64_t>((std::numeric_limits<std::int32_t>::max)()))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('l'));  // int32
            }
            write_number(static_cast<std::int32_t>(n));
        }
        else if (n <= static_cast<std::uint64_t>((std::numeric_limits<std::int64_t>::max)()))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('L'));  // int64
            }
            write_number(static_cast<std::int64_t>(n));
        }
        else
        {
            JSON_THROW(out_of_range::create(407, "integer number " + std::to_string(n) + " cannot be represented by UBJSON as it does not fit int64"));
        }
    }

    // UBJSON: write number (signed integer)
    template<typename NumberType, typename std::enable_if<
                 std::is_signed<NumberType>::value and
                 not std::is_floating_point<NumberType>::value, int>::type = 0>
    void write_number_with_ubjson_prefix(const NumberType n,
                                         const bool add_prefix)
    {
        if ((std::numeric_limits<std::int8_t>::min)() <= n and n <= (std::numeric_limits<std::int8_t>::max)())
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('i'));  // int8
            }
            write_number(static_cast<std::int8_t>(n));
        }
        else if (static_cast<std::int64_t>((std::numeric_limits<std::uint8_t>::min)()) <= n and n <= static_cast<std::int64_t>((std::numeric_limits<std::uint8_t>::max)()))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('U'));  // uint8
            }
            write_number(static_cast<std::uint8_t>(n));
        }
        else if ((std::numeric_limits<std::int16_t>::min)() <= n and n <= (std::numeric_limits<std::int16_t>::max)())
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('I'));  // int16
            }
            write_number(static_cast<std::int16_t>(n));
        }
        else if ((std::numeric_limits<std::int32_t>::min)() <= n and n <= (std::numeric_limits<std::int32_t>::max)())
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('l'));  // int32
            }
            write_number(static_cast<std::int32_t>(n));
        }
        else if ((std::numeric_limits<std::int64_t>::min)() <= n and n <= (std::numeric_limits<std::int64_t>::max)())
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('L'));  // int64
            }
            write_number(static_cast<std::int64_t>(n));
        }
        // LCOV_EXCL_START
        else
        {
            JSON_THROW(out_of_range::create(407, "integer number " + std::to_string(n) + " cannot be represented by UBJSON as it does not fit int64"));
        }
        // LCOV_EXCL_STOP
    }

    /*!
    @brief determine the type prefix of container values

    @note This function does not need to be 100% accurate when it comes to
          integer limits. In case a number exceeds the limits of int64_t,
          this will be detected by a later call to function
          write_number_with_ubjson_prefix. Therefore, we return 'L' for any
          value that does not fit the previous limits.
    */
    CharType ubjson_prefix(const BasicJsonType& j) const noexcept
    {
        switch (j.type())
        {
            case value_t::null:
                return 'Z';

            case value_t::boolean:
                return j.m_value.boolean ? 'T' : 'F';

            case value_t::number_integer:
            {
                if ((std::numeric_limits<std::int8_t>::min)() <= j.m_value.number_integer and j.m_value.number_integer <= (std::numeric_limits<std::int8_t>::max)())
                {
                    return 'i';
                }
                if ((std::numeric_limits<std::uint8_t>::min)() <= j.m_value.number_integer and j.m_value.number_integer <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    return 'U';
                }
                if ((std::numeric_limits<std::int16_t>::min)() <= j.m_value.number_integer and j.m_value.number_integer <= (std::numeric_limits<std::int16_t>::max)())
                {
                    return 'I';
                }
                if ((std::numeric_limits<std::int32_t>::min)() <= j.m_value.number_integer and j.m_value.number_integer <= (std::numeric_limits<std::int32_t>::max)())
                {
                    return 'l';
                }
                // no check and assume int64_t (see note above)
                return 'L';
            }

            case value_t::number_unsigned:
            {
                if (j.m_value.number_unsigned <= (std::numeric_limits<std::int8_t>::max)())
                {
                    return 'i';
                }
                if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    return 'U';
                }
                if (j.m_value.number_unsigned <= (std::numeric_limits<std::int16_t>::max)())
                {
                    return 'I';
                }
                if (j.m_value.number_unsigned <= (std::numeric_limits<std::int32_t>::max)())
                {
                    return 'l';
                }
                // no check and assume int64_t (see note above)
                return 'L';
            }

            case value_t::number_float:
                return get_ubjson_float_prefix(j.m_value.number_float);

            case value_t::string:
                return 'S';

            case value_t::array:
                return '[';

            case value_t::object:
                return '{';

            default:  // discarded values
                return 'N';
        }
    }

    static constexpr CharType get_ubjson_float_prefix(float /*unused*/)
    {
        return 'd';  // float 32
    }

    static constexpr CharType get_ubjson_float_prefix(double /*unused*/)
    {
        return 'D';  // float 64
    }

    ///////////////////////
    // Utility functions //
    ///////////////////////

    /*
    @brief write a number to output input
    @param[in] n number of type @a NumberType
    @tparam NumberType the type of the number
    @tparam OutputIsLittleEndian Set to true if output data is
                                 required to be little endian

    @note This function needs to respect the system's endianess, because bytes
          in CBOR, MessagePack, and UBJSON are stored in network order (big
          endian) and therefore need reordering on little endian systems.
    */
    template<typename NumberType, bool OutputIsLittleEndian = false>
    void write_number(const NumberType n)
    {
        // step 1: write number to array of length NumberType
        std::array<CharType, sizeof(NumberType)> vec;
        std::memcpy(vec.data(), &n, sizeof(NumberType));

        // step 2: write array to output (with possible reordering)
        if (is_little_endian != OutputIsLittleEndian)
        {
            // reverse byte order prior to conversion if necessary
            std::reverse(vec.begin(), vec.end());
        }

        oa->write_characters(vec.data(), sizeof(NumberType));
    }

  public:
    // The following to_char_type functions are implement the conversion
    // between uint8_t and CharType. In case CharType is not unsigned,
    // such a conversion is required to allow values greater than 128.
    // See <https://github.com/nlohmann/json/issues/1286> for a discussion.
    template < typename C = CharType,
               enable_if_t < std::is_signed<C>::value and std::is_signed<char>::value > * = nullptr >
    static constexpr CharType to_char_type(std::uint8_t x) noexcept
    {
        return *reinterpret_cast<char*>(&x);
    }

    template < typename C = CharType,
               enable_if_t < std::is_signed<C>::value and std::is_unsigned<char>::value > * = nullptr >
    static CharType to_char_type(std::uint8_t x) noexcept
    {
        static_assert(sizeof(std::uint8_t) == sizeof(CharType), "size of CharType must be equal to std::uint8_t");
        static_assert(std::is_pod<CharType>::value, "CharType must be POD");
        CharType result;
        std::memcpy(&result, &x, sizeof(x));
        return result;
    }

    template<typename C = CharType,
             enable_if_t<std::is_unsigned<C>::value>* = nullptr>
    static constexpr CharType to_char_type(std::uint8_t x) noexcept
    {
        return x;
    }

    template < typename InputCharType, typename C = CharType,
               enable_if_t <
                   std::is_signed<C>::value and
                   std::is_signed<char>::value and
                   std::is_same<char, typename std::remove_cv<InputCharType>::type>::value
                   > * = nullptr >
    static constexpr CharType to_char_type(InputCharType x) noexcept
    {
        return x;
    }

  private:
    /// whether we can assume little endianess
    const bool is_little_endian = binary_reader<BasicJsonType>::little_endianess();

    /// the output
    output_adapter_t<CharType> oa = nullptr;
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/output/output_adapters.hpp>

// #include <nlohmann/detail/output/serializer.hpp>


#include <algorithm> // reverse, remove, fill, find, none_of
#include <array> // array
#include <cassert> // assert
#include <ciso646> // and, or
#include <clocale> // localeconv, lconv
#include <cmath> // labs, isfinite, isnan, signbit
#include <cstddef> // size_t, ptrdiff_t
#include <cstdint> // uint8_t
#include <cstdio> // snprintf
#include <limits> // numeric_limits
#include <string> // string
#include <type_traits> // is_same
#include <utility> // move

// #include <nlohmann/detail/conversions/to_chars.hpp>


#include <array> // array
#include <cassert> // assert
#include <ciso646> // or, and, not
#include <cmath>   // signbit, isfinite
#include <cstdint> // intN_t, uintN_t
#include <cstring> // memcpy, memmove
#include <limits> // numeric_limits
#include <type_traits> // conditional

namespace nlohmann
{
namespace detail
{

/*!
@brief implements the Grisu2 algorithm for binary to decimal floating-point
conversion.

This implementation is a slightly modified version of the reference
implementation which may be obtained from
http://florian.loitsch.com/publications (bench.tar.gz).

The code is distributed under the MIT license, Copyright (c) 2009 Florian Loitsch.

For a detailed description of the algorithm see:

[1] Loitsch, "Printing Floating-Point Numbers Quickly and Accurately with
    Integers", Proceedings of the ACM SIGPLAN 2010 Conference on Programming
    Language Design and Implementation, PLDI 2010
[2] Burger, Dybvig, "Printing Floating-Point Numbers Quickly and Accurately",
    Proceedings of the ACM SIGPLAN 1996 Conference on Programming Language
    Design and Implementation, PLDI 1996
*/
namespace dtoa_impl
{

template <typename Target, typename Source>
Target reinterpret_bits(const Source source)
{
    static_assert(sizeof(Target) == sizeof(Source), "size mismatch");

    Target target;
    std::memcpy(&target, &source, sizeof(Source));
    return target;
}

struct diyfp // f * 2^e
{
    static constexpr int kPrecision = 64; // = q

    std::uint64_t f = 0;
    int e = 0;

    constexpr diyfp(std::uint64_t f_, int e_) noexcept : f(f_), e(e_) {}

    /*!
    @brief returns x - y
    @pre x.e == y.e and x.f >= y.f
    */
    static diyfp sub(const diyfp& x, const diyfp& y) noexcept
    {
        assert(x.e == y.e);
        assert(x.f >= y.f);

        return {x.f - y.f, x.e};
    }

    /*!
    @brief returns x * y
    @note The result is rounded. (Only the upper q bits are returned.)
    */
    static diyfp mul(const diyfp& x, const diyfp& y) noexcept
    {
        static_assert(kPrecision == 64, "internal error");

        // Computes:
        //  f = round((x.f * y.f) / 2^q)
        //  e = x.e + y.e + q

        // Emulate the 64-bit * 64-bit multiplication:
        //
        // p = u * v
        //   = (u_lo + 2^32 u_hi) (v_lo + 2^32 v_hi)
        //   = (u_lo v_lo         ) + 2^32 ((u_lo v_hi         ) + (u_hi v_lo         )) + 2^64 (u_hi v_hi         )
        //   = (p0                ) + 2^32 ((p1                ) + (p2                )) + 2^64 (p3                )
        //   = (p0_lo + 2^32 p0_hi) + 2^32 ((p1_lo + 2^32 p1_hi) + (p2_lo + 2^32 p2_hi)) + 2^64 (p3                )
        //   = (p0_lo             ) + 2^32 (p0_hi + p1_lo + p2_lo                      ) + 2^64 (p1_hi + p2_hi + p3)
        //   = (p0_lo             ) + 2^32 (Q                                          ) + 2^64 (H                 )
        //   = (p0_lo             ) + 2^32 (Q_lo + 2^32 Q_hi                           ) + 2^64 (H                 )
        //
        // (Since Q might be larger than 2^32 - 1)
        //
        //   = (p0_lo + 2^32 Q_lo) + 2^64 (Q_hi + H)
        //
        // (Q_hi + H does not overflow a 64-bit int)
        //
        //   = p_lo + 2^64 p_hi

        const std::uint64_t u_lo = x.f & 0xFFFFFFFFu;
        const std::uint64_t u_hi = x.f >> 32u;
        const std::uint64_t v_lo = y.f & 0xFFFFFFFFu;
        const std::uint64_t v_hi = y.f >> 32u;

        const std::uint64_t p0 = u_lo * v_lo;
        const std::uint64_t p1 = u_lo * v_hi;
        const std::uint64_t p2 = u_hi * v_lo;
        const std::uint64_t p3 = u_hi * v_hi;

        const std::uint64_t p0_hi = p0 >> 32u;
        const std::uint64_t p1_lo = p1 & 0xFFFFFFFFu;
        const std::uint64_t p1_hi = p1 >> 32u;
        const std::uint64_t p2_lo = p2 & 0xFFFFFFFFu;
        const std::uint64_t p2_hi = p2 >> 32u;

        std::uint64_t Q = p0_hi + p1_lo + p2_lo;

        // The full product might now be computed as
        //
        // p_hi = p3 + p2_hi + p1_hi + (Q >> 32)
        // p_lo = p0_lo + (Q << 32)
        //
        // But in this particular case here, the full p_lo is not required.
        // Effectively we only need to add the highest bit in p_lo to p_hi (and
        // Q_hi + 1 does not overflow).

        Q += std::uint64_t{1} << (64u - 32u - 1u); // round, ties up

        const std::uint64_t h = p3 + p2_hi + p1_hi + (Q >> 32u);

        return {h, x.e + y.e + 64};
    }

    /*!
    @brief normalize x such that the significand is >= 2^(q-1)
    @pre x.f != 0
    */
    static diyfp normalize(diyfp x) noexcept
    {
        assert(x.f != 0);

        while ((x.f >> 63u) == 0)
        {
            x.f <<= 1u;
            x.e--;
        }

        return x;
    }

    /*!
    @brief normalize x such that the result has the exponent E
    @pre e >= x.e and the upper e - x.e bits of x.f must be zero.
    */
    static diyfp normalize_to(const diyfp& x, const int target_exponent) noexcept
    {
        const int delta = x.e - target_exponent;

        assert(delta >= 0);
        assert(((x.f << delta) >> delta) == x.f);

        return {x.f << delta, target_exponent};
    }
};

struct boundaries
{
    diyfp w;
    diyfp minus;
    diyfp plus;
};

/*!
Compute the (normalized) diyfp representing the input number 'value' and its
boundaries.

@pre value must be finite and positive
*/
template <typename FloatType>
boundaries compute_boundaries(FloatType value)
{
    assert(std::isfinite(value));
    assert(value > 0);

    // Convert the IEEE representation into a diyfp.
    //
    // If v is denormal:
    //      value = 0.F * 2^(1 - bias) = (          F) * 2^(1 - bias - (p-1))
    // If v is normalized:
    //      value = 1.F * 2^(E - bias) = (2^(p-1) + F) * 2^(E - bias - (p-1))

    static_assert(std::numeric_limits<FloatType>::is_iec559,
                  "internal error: dtoa_short requires an IEEE-754 floating-point implementation");

    constexpr int      kPrecision = std::numeric_limits<FloatType>::digits; // = p (includes the hidden bit)
    constexpr int      kBias      = std::numeric_limits<FloatType>::max_exponent - 1 + (kPrecision - 1);
    constexpr int      kMinExp    = 1 - kBias;
    constexpr std::uint64_t kHiddenBit = std::uint64_t{1} << (kPrecision - 1); // = 2^(p-1)

    using bits_type = typename std::conditional<kPrecision == 24, std::uint32_t, std::uint64_t >::type;

    const std::uint64_t bits = reinterpret_bits<bits_type>(value);
    const std::uint64_t E = bits >> (kPrecision - 1);
    const std::uint64_t F = bits & (kHiddenBit - 1);

    const bool is_denormal = E == 0;
    const diyfp v = is_denormal
                    ? diyfp(F, kMinExp)
                    : diyfp(F + kHiddenBit, static_cast<int>(E) - kBias);

    // Compute the boundaries m- and m+ of the floating-point value
    // v = f * 2^e.
    //
    // Determine v- and v+, the floating-point predecessor and successor if v,
    // respectively.
    //
    //      v- = v - 2^e        if f != 2^(p-1) or e == e_min                (A)
    //         = v - 2^(e-1)    if f == 2^(p-1) and e > e_min                (B)
    //
    //      v+ = v + 2^e
    //
    // Let m- = (v- + v) / 2 and m+ = (v + v+) / 2. All real numbers _strictly_
    // between m- and m+ round to v, regardless of how the input rounding
    // algorithm breaks ties.
    //
    //      ---+-------------+-------------+-------------+-------------+---  (A)
    //         v-            m-            v             m+            v+
    //
    //      -----------------+------+------+-------------+-------------+---  (B)
    //                       v-     m-     v             m+            v+

    const bool lower_boundary_is_closer = F == 0 and E > 1;
    const diyfp m_plus = diyfp(2 * v.f + 1, v.e - 1);
    const diyfp m_minus = lower_boundary_is_closer
                          ? diyfp(4 * v.f - 1, v.e - 2)  // (B)
                          : diyfp(2 * v.f - 1, v.e - 1); // (A)

    // Determine the normalized w+ = m+.
    const diyfp w_plus = diyfp::normalize(m_plus);

    // Determine w- = m- such that e_(w-) = e_(w+).
    const diyfp w_minus = diyfp::normalize_to(m_minus, w_plus.e);

    return {diyfp::normalize(v), w_minus, w_plus};
}

// Given normalized diyfp w, Grisu needs to find a (normalized) cached
// power-of-ten c, such that the exponent of the product c * w = f * 2^e lies
// within a certain range [alpha, gamma] (Definition 3.2 from [1])
//
//      alpha <= e = e_c + e_w + q <= gamma
//
// or
//
//      f_c * f_w * 2^alpha <= f_c 2^(e_c) * f_w 2^(e_w) * 2^q
//                          <= f_c * f_w * 2^gamma
//
// Since c and w are normalized, i.e. 2^(q-1) <= f < 2^q, this implies
//
//      2^(q-1) * 2^(q-1) * 2^alpha <= c * w * 2^q < 2^q * 2^q * 2^gamma
//
// or
//
//      2^(q - 2 + alpha) <= c * w < 2^(q + gamma)
//
// The choice of (alpha,gamma) determines the size of the table and the form of
// the digit generation procedure. Using (alpha,gamma)=(-60,-32) works out well
// in practice:
//
// The idea is to cut the number c * w = f * 2^e into two parts, which can be
// processed independently: An integral part p1, and a fractional part p2:
//
//      f * 2^e = ( (f div 2^-e) * 2^-e + (f mod 2^-e) ) * 2^e
//              = (f div 2^-e) + (f mod 2^-e) * 2^e
//              = p1 + p2 * 2^e
//
// The conversion of p1 into decimal form requires a series of divisions and
// modulos by (a power of) 10. These operations are faster for 32-bit than for
// 64-bit integers, so p1 should ideally fit into a 32-bit integer. This can be
// achieved by choosing
//
//      -e >= 32   or   e <= -32 := gamma
//
// In order to convert the fractional part
//
//      p2 * 2^e = p2 / 2^-e = d[-1] / 10^1 + d[-2] / 10^2 + ...
//
// into decimal form, the fraction is repeatedly multiplied by 10 and the digits
// d[-i] are extracted in order:
//
//      (10 * p2) div 2^-e = d[-1]
//      (10 * p2) mod 2^-e = d[-2] / 10^1 + ...
//
// The multiplication by 10 must not overflow. It is sufficient to choose
//
//      10 * p2 < 16 * p2 = 2^4 * p2 <= 2^64.
//
// Since p2 = f mod 2^-e < 2^-e,
//
//      -e <= 60   or   e >= -60 := alpha

constexpr int kAlpha = -60;
constexpr int kGamma = -32;

struct cached_power // c = f * 2^e ~= 10^k
{
    std::uint64_t f;
    int e;
    int k;
};

/*!
For a normalized diyfp w = f * 2^e, this function returns a (normalized) cached
power-of-ten c = f_c * 2^e_c, such that the exponent of the product w * c
satisfies (Definition 3.2 from [1])

     alpha <= e_c + e + q <= gamma.
*/
inline cached_power get_cached_power_for_binary_exponent(int e)
{
    // Now
    //
    //      alpha <= e_c + e + q <= gamma                                    (1)
    //      ==> f_c * 2^alpha <= c * 2^e * 2^q
    //
    // and since the c's are normalized, 2^(q-1) <= f_c,
    //
    //      ==> 2^(q - 1 + alpha) <= c * 2^(e + q)
    //      ==> 2^(alpha - e - 1) <= c
    //
    // If c were an exakt power of ten, i.e. c = 10^k, one may determine k as
    //
    //      k = ceil( log_10( 2^(alpha - e - 1) ) )
    //        = ceil( (alpha - e - 1) * log_10(2) )
    //
    // From the paper:
    // "In theory the result of the procedure could be wrong since c is rounded,
    //  and the computation itself is approximated [...]. In practice, however,
    //  this simple function is sufficient."
    //
    // For IEEE double precision floating-point numbers converted into
    // normalized diyfp's w = f * 2^e, with q = 64,
    //
    //      e >= -1022      (min IEEE exponent)
    //           -52        (p - 1)
    //           -52        (p - 1, possibly normalize denormal IEEE numbers)
    //           -11        (normalize the diyfp)
    //         = -1137
    //
    // and
    //
    //      e <= +1023      (max IEEE exponent)
    //           -52        (p - 1)
    //           -11        (normalize the diyfp)
    //         = 960
    //
    // This binary exponent range [-1137,960] results in a decimal exponent
    // range [-307,324]. One does not need to store a cached power for each
    // k in this range. For each such k it suffices to find a cached power
    // such that the exponent of the product lies in [alpha,gamma].
    // This implies that the difference of the decimal exponents of adjacent
    // table entries must be less than or equal to
    //
    //      floor( (gamma - alpha) * log_10(2) ) = 8.
    //
    // (A smaller distance gamma-alpha would require a larger table.)

    // NB:
    // Actually this function returns c, such that -60 <= e_c + e + 64 <= -34.

    constexpr int kCachedPowersMinDecExp = -300;
    constexpr int kCachedPowersDecStep = 8;

    static constexpr std::array<cached_power, 79> kCachedPowers =
    {
        {
            { 0xAB70FE17C79AC6CA, -1060, -300 },
            { 0xFF77B1FCBEBCDC4F, -1034, -292 },
            { 0xBE5691EF416BD60C, -1007, -284 },
            { 0x8DD01FAD907FFC3C,  -980, -276 },
            { 0xD3515C2831559A83,  -954, -268 },
            { 0x9D71AC8FADA6C9B5,  -927, -260 },
            { 0xEA9C227723EE8BCB,  -901, -252 },
            { 0xAECC49914078536D,  -874, -244 },
            { 0x823C12795DB6CE57,  -847, -236 },
            { 0xC21094364DFB5637,  -821, -228 },
            { 0x9096EA6F3848984F,  -794, -220 },
            { 0xD77485CB25823AC7,  -768, -212 },
            { 0xA086CFCD97BF97F4,  -741, -204 },
            { 0xEF340A98172AACE5,  -715, -196 },
            { 0xB23867FB2A35B28E,  -688, -188 },
            { 0x84C8D4DFD2C63F3B,  -661, -180 },
            { 0xC5DD44271AD3CDBA,  -635, -172 },
            { 0x936B9FCEBB25C996,  -608, -164 },
            { 0xDBAC6C247D62A584,  -582, -156 },
            { 0xA3AB66580D5FDAF6,  -555, -148 },
            { 0xF3E2F893DEC3F126,  -529, -140 },
            { 0xB5B5ADA8AAFF80B8,  -502, -132 },
            { 0x87625F056C7C4A8B,  -475, -124 },
            { 0xC9BCFF6034C13053,  -449, -116 },
            { 0x964E858C91BA2655,  -422, -108 },
            { 0xDFF9772470297EBD,  -396, -100 },
            { 0xA6DFBD9FB8E5B88F,  -369,  -92 },
            { 0xF8A95FCF88747D94,  -343,  -84 },
            { 0xB94470938FA89BCF,  -316,  -76 },
            { 0x8A08F0F8BF0F156B,  -289,  -68 },
            { 0xCDB02555653131B6,  -263,  -60 },
            { 0x993FE2C6D07B7FAC,  -236,  -52 },
            { 0xE45C10C42A2B3B06,  -210,  -44 },
            { 0xAA242499697392D3,  -183,  -36 },
            { 0xFD87B5F28300CA0E,  -157,  -28 },
            { 0xBCE5086492111AEB,  -130,  -20 },
            { 0x8CBCCC096F5088CC,  -103,  -12 },
            { 0xD1B71758E219652C,   -77,   -4 },
            { 0x9C40000000000000,   -50,    4 },
            { 0xE8D4A51000000000,   -24,   12 },
            { 0xAD78EBC5AC620000,     3,   20 },
            { 0x813F3978F8940984,    30,   28 },
            { 0xC097CE7BC90715B3,    56,   36 },
            { 0x8F7E32CE7BEA5C70,    83,   44 },
            { 0xD5D238A4ABE98068,   109,   52 },
            { 0x9F4F2726179A2245,   136,   60 },
            { 0xED63A231D4C4FB27,   162,   68 },
            { 0xB0DE65388CC8ADA8,   189,   76 },
            { 0x83C7088E1AAB65DB,   216,   84 },
            { 0xC45D1DF942711D9A,   242,   92 },
            { 0x924D692CA61BE758,   269,  100 },
            { 0xDA01EE641A708DEA,   295,  108 },
            { 0xA26DA3999AEF774A,   322,  116 },
            { 0xF209787BB47D6B85,   348,  124 },
            { 0xB454E4A179DD1877,   375,  132 },
            { 0x865B86925B9BC5C2,   402,  140 },
            { 0xC83553C5C8965D3D,   428,  148 },
            { 0x952AB45CFA97A0B3,   455,  156 },
            { 0xDE469FBD99A05FE3,   481,  164 },
            { 0xA59BC234DB398C25,   508,  172 },
            { 0xF6C69A72A3989F5C,   534,  180 },
            { 0xB7DCBF5354E9BECE,   561,  188 },
            { 0x88FCF317F22241E2,   588,  196 },
            { 0xCC20CE9BD35C78A5,   614,  204 },
            { 0x98165AF37B2153DF,   641,  212 },
            { 0xE2A0B5DC971F303A,   667,  220 },
            { 0xA8D9D1535CE3B396,   694,  228 },
            { 0xFB9B7CD9A4A7443C,   720,  236 },
            { 0xBB764C4CA7A44410,   747,  244 },
            { 0x8BAB8EEFB6409C1A,   774,  252 },
            { 0xD01FEF10A657842C,   800,  260 },
            { 0x9B10A4E5E9913129,   827,  268 },
            { 0xE7109BFBA19C0C9D,   853,  276 },
            { 0xAC2820D9623BF429,   880,  284 },
            { 0x80444B5E7AA7CF85,   907,  292 },
            { 0xBF21E44003ACDD2D,   933,  300 },
            { 0x8E679C2F5E44FF8F,   960,  308 },
            { 0xD433179D9C8CB841,   986,  316 },
            { 0x9E19DB92B4E31BA9,  1013,  324 },
        }
    };

    // This computation gives exactly the same results for k as
    //      k = ceil((kAlpha - e - 1) * 0.30102999566398114)
    // for |e| <= 1500, but doesn't require floating-point operations.
    // NB: log_10(2) ~= 78913 / 2^18
    assert(e >= -1500);
    assert(e <=  1500);
    const int f = kAlpha - e - 1;
    const int k = (f * 78913) / (1 << 18) + static_cast<int>(f > 0);

    const int index = (-kCachedPowersMinDecExp + k + (kCachedPowersDecStep - 1)) / kCachedPowersDecStep;
    assert(index >= 0);
    assert(static_cast<std::size_t>(index) < kCachedPowers.size());

    const cached_power cached = kCachedPowers[static_cast<std::size_t>(index)];
    assert(kAlpha <= cached.e + e + 64);
    assert(kGamma >= cached.e + e + 64);

    return cached;
}

/*!
For n != 0, returns k, such that pow10 := 10^(k-1) <= n < 10^k.
For n == 0, returns 1 and sets pow10 := 1.
*/
inline int find_largest_pow10(const std::uint32_t n, std::uint32_t& pow10)
{
    // LCOV_EXCL_START
    if (n >= 1000000000)
    {
        pow10 = 1000000000;
        return 10;
    }
    // LCOV_EXCL_STOP
    else if (n >= 100000000)
    {
        pow10 = 100000000;
        return  9;
    }
    else if (n >= 10000000)
    {
        pow10 = 10000000;
        return  8;
    }
    else if (n >= 1000000)
    {
        pow10 = 1000000;
        return  7;
    }
    else if (n >= 100000)
    {
        pow10 = 100000;
        return  6;
    }
    else if (n >= 10000)
    {
        pow10 = 10000;
        return  5;
    }
    else if (n >= 1000)
    {
        pow10 = 1000;
        return  4;
    }
    else if (n >= 100)
    {
        pow10 = 100;
        return  3;
    }
    else if (n >= 10)
    {
        pow10 = 10;
        return  2;
    }
    else
    {
        pow10 = 1;
        return 1;
    }
}

inline void grisu2_round(char* buf, int len, std::uint64_t dist, std::uint64_t delta,
                         std::uint64_t rest, std::uint64_t ten_k)
{
    assert(len >= 1);
    assert(dist <= delta);
    assert(rest <= delta);
    assert(ten_k > 0);

    //               <--------------------------- delta ---->
    //                                  <---- dist --------->
    // --------------[------------------+-------------------]--------------
    //               M-                 w                   M+
    //
    //                                  ten_k
    //                                <------>
    //                                       <---- rest ---->
    // --------------[------------------+----+--------------]--------------
    //                                  w    V
    //                                       = buf * 10^k
    //
    // ten_k represents a unit-in-the-last-place in the decimal representation
    // stored in buf.
    // Decrement buf by ten_k while this takes buf closer to w.

    // The tests are written in this order to avoid overflow in unsigned
    // integer arithmetic.

    while (rest < dist
            and delta - rest >= ten_k
            and (rest + ten_k < dist or dist - rest > rest + ten_k - dist))
    {
        assert(buf[len - 1] != '0');
        buf[len - 1]--;
        rest += ten_k;
    }
}

/*!
Generates V = buffer * 10^decimal_exponent, such that M- <= V <= M+.
M- and M+ must be normalized and share the same exponent -60 <= e <= -32.
*/
inline void grisu2_digit_gen(char* buffer, int& length, int& decimal_exponent,
                             diyfp M_minus, diyfp w, diyfp M_plus)
{
    static_assert(kAlpha >= -60, "internal error");
    static_assert(kGamma <= -32, "internal error");

    // Generates the digits (and the exponent) of a decimal floating-point
    // number V = buffer * 10^decimal_exponent in the range [M-, M+]. The diyfp's
    // w, M- and M+ share the same exponent e, which satisfies alpha <= e <= gamma.
    //
    //               <--------------------------- delta ---->
    //                                  <---- dist --------->
    // --------------[------------------+-------------------]--------------
    //               M-                 w                   M+
    //
    // Grisu2 generates the digits of M+ from left to right and stops as soon as
    // V is in [M-,M+].

    assert(M_plus.e >= kAlpha);
    assert(M_plus.e <= kGamma);

    std::uint64_t delta = diyfp::sub(M_plus, M_minus).f; // (significand of (M+ - M-), implicit exponent is e)
    std::uint64_t dist  = diyfp::sub(M_plus, w      ).f; // (significand of (M+ - w ), implicit exponent is e)

    // Split M+ = f * 2^e into two parts p1 and p2 (note: e < 0):
    //
    //      M+ = f * 2^e
    //         = ((f div 2^-e) * 2^-e + (f mod 2^-e)) * 2^e
    //         = ((p1        ) * 2^-e + (p2        )) * 2^e
    //         = p1 + p2 * 2^e

    const diyfp one(std::uint64_t{1} << -M_plus.e, M_plus.e);

    auto p1 = static_cast<std::uint32_t>(M_plus.f >> -one.e); // p1 = f div 2^-e (Since -e >= 32, p1 fits into a 32-bit int.)
    std::uint64_t p2 = M_plus.f & (one.f - 1);                    // p2 = f mod 2^-e

    // 1)
    //
    // Generate the digits of the integral part p1 = d[n-1]...d[1]d[0]

    assert(p1 > 0);

    std::uint32_t pow10;
    const int k = find_largest_pow10(p1, pow10);

    //      10^(k-1) <= p1 < 10^k, pow10 = 10^(k-1)
    //
    //      p1 = (p1 div 10^(k-1)) * 10^(k-1) + (p1 mod 10^(k-1))
    //         = (d[k-1]         ) * 10^(k-1) + (p1 mod 10^(k-1))
    //
    //      M+ = p1                                             + p2 * 2^e
    //         = d[k-1] * 10^(k-1) + (p1 mod 10^(k-1))          + p2 * 2^e
    //         = d[k-1] * 10^(k-1) + ((p1 mod 10^(k-1)) * 2^-e + p2) * 2^e
    //         = d[k-1] * 10^(k-1) + (                         rest) * 2^e
    //
    // Now generate the digits d[n] of p1 from left to right (n = k-1,...,0)
    //
    //      p1 = d[k-1]...d[n] * 10^n + d[n-1]...d[0]
    //
    // but stop as soon as
    //
    //      rest * 2^e = (d[n-1]...d[0] * 2^-e + p2) * 2^e <= delta * 2^e

    int n = k;
    while (n > 0)
    {
        // Invariants:
        //      M+ = buffer * 10^n + (p1 + p2 * 2^e)    (buffer = 0 for n = k)
        //      pow10 = 10^(n-1) <= p1 < 10^n
        //
        const std::uint32_t d = p1 / pow10;  // d = p1 div 10^(n-1)
        const std::uint32_t r = p1 % pow10;  // r = p1 mod 10^(n-1)
        //
        //      M+ = buffer * 10^n + (d * 10^(n-1) + r) + p2 * 2^e
        //         = (buffer * 10 + d) * 10^(n-1) + (r + p2 * 2^e)
        //
        assert(d <= 9);
        buffer[length++] = static_cast<char>('0' + d); // buffer := buffer * 10 + d
        //
        //      M+ = buffer * 10^(n-1) + (r + p2 * 2^e)
        //
        p1 = r;
        n--;
        //
        //      M+ = buffer * 10^n + (p1 + p2 * 2^e)
        //      pow10 = 10^n
        //

        // Now check if enough digits have been generated.
        // Compute
        //
        //      p1 + p2 * 2^e = (p1 * 2^-e + p2) * 2^e = rest * 2^e
        //
        // Note:
        // Since rest and delta share the same exponent e, it suffices to
        // compare the significands.
        const std::uint64_t rest = (std::uint64_t{p1} << -one.e) + p2;
        if (rest <= delta)
        {
            // V = buffer * 10^n, with M- <= V <= M+.

            decimal_exponent += n;

            // We may now just stop. But instead look if the buffer could be
            // decremented to bring V closer to w.
            //
            // pow10 = 10^n is now 1 ulp in the decimal representation V.
            // The rounding procedure works with diyfp's with an implicit
            // exponent of e.
            //
            //      10^n = (10^n * 2^-e) * 2^e = ulp * 2^e
            //
            const std::uint64_t ten_n = std::uint64_t{pow10} << -one.e;
            grisu2_round(buffer, length, dist, delta, rest, ten_n);

            return;
        }

        pow10 /= 10;
        //
        //      pow10 = 10^(n-1) <= p1 < 10^n
        // Invariants restored.
    }

    // 2)
    //
    // The digits of the integral part have been generated:
    //
    //      M+ = d[k-1]...d[1]d[0] + p2 * 2^e
    //         = buffer            + p2 * 2^e
    //
    // Now generate the digits of the fractional part p2 * 2^e.
    //
    // Note:
    // No decimal point is generated: the exponent is adjusted instead.
    //
    // p2 actually represents the fraction
    //
    //      p2 * 2^e
    //          = p2 / 2^-e
    //          = d[-1] / 10^1 + d[-2] / 10^2 + ...
    //
    // Now generate the digits d[-m] of p1 from left to right (m = 1,2,...)
    //
    //      p2 * 2^e = d[-1]d[-2]...d[-m] * 10^-m
    //                      + 10^-m * (d[-m-1] / 10^1 + d[-m-2] / 10^2 + ...)
    //
    // using
    //
    //      10^m * p2 = ((10^m * p2) div 2^-e) * 2^-e + ((10^m * p2) mod 2^-e)
    //                = (                   d) * 2^-e + (                   r)
    //
    // or
    //      10^m * p2 * 2^e = d + r * 2^e
    //
    // i.e.
    //
    //      M+ = buffer + p2 * 2^e
    //         = buffer + 10^-m * (d + r * 2^e)
    //         = (buffer * 10^m + d) * 10^-m + 10^-m * r * 2^e
    //
    // and stop as soon as 10^-m * r * 2^e <= delta * 2^e

    assert(p2 > delta);

    int m = 0;
    for (;;)
    {
        // Invariant:
        //      M+ = buffer * 10^-m + 10^-m * (d[-m-1] / 10 + d[-m-2] / 10^2 + ...) * 2^e
        //         = buffer * 10^-m + 10^-m * (p2                                 ) * 2^e
        //         = buffer * 10^-m + 10^-m * (1/10 * (10 * p2)                   ) * 2^e
        //         = buffer * 10^-m + 10^-m * (1/10 * ((10*p2 div 2^-e) * 2^-e + (10*p2 mod 2^-e)) * 2^e
        //
        assert(p2 <= (std::numeric_limits<std::uint64_t>::max)() / 10);
        p2 *= 10;
        const std::uint64_t d = p2 >> -one.e;     // d = (10 * p2) div 2^-e
        const std::uint64_t r = p2 & (one.f - 1); // r = (10 * p2) mod 2^-e
        //
        //      M+ = buffer * 10^-m + 10^-m * (1/10 * (d * 2^-e + r) * 2^e
        //         = buffer * 10^-m + 10^-m * (1/10 * (d + r * 2^e))
        //         = (buffer * 10 + d) * 10^(-m-1) + 10^(-m-1) * r * 2^e
        //
        assert(d <= 9);
        buffer[length++] = static_cast<char>('0' + d); // buffer := buffer * 10 + d
        //
        //      M+ = buffer * 10^(-m-1) + 10^(-m-1) * r * 2^e
        //
        p2 = r;
        m++;
        //
        //      M+ = buffer * 10^-m + 10^-m * p2 * 2^e
        // Invariant restored.

        // Check if enough digits have been generated.
        //
        //      10^-m * p2 * 2^e <= delta * 2^e
        //              p2 * 2^e <= 10^m * delta * 2^e
        //                    p2 <= 10^m * delta
        delta *= 10;
        dist  *= 10;
        if (p2 <= delta)
        {
            break;
        }
    }

    // V = buffer * 10^-m, with M- <= V <= M+.

    decimal_exponent -= m;

    // 1 ulp in the decimal representation is now 10^-m.
    // Since delta and dist are now scaled by 10^m, we need to do the
    // same with ulp in order to keep the units in sync.
    //
    //      10^m * 10^-m = 1 = 2^-e * 2^e = ten_m * 2^e
    //
    const std::uint64_t ten_m = one.f;
    grisu2_round(buffer, length, dist, delta, p2, ten_m);

    // By construction this algorithm generates the shortest possible decimal
    // number (Loitsch, Theorem 6.2) which rounds back to w.
    // For an input number of precision p, at least
    //
    //      N = 1 + ceil(p * log_10(2))
    //
    // decimal digits are sufficient to identify all binary floating-point
    // numbers (Matula, "In-and-Out conversions").
    // This implies that the algorithm does not produce more than N decimal
    // digits.
    //
    //      N = 17 for p = 53 (IEEE double precision)
    //      N = 9  for p = 24 (IEEE single precision)
}

/*!
v = buf * 10^decimal_exponent
len is the length of the buffer (number of decimal digits)
The buffer must be large enough, i.e. >= max_digits10.
*/
inline void grisu2(char* buf, int& len, int& decimal_exponent,
                   diyfp m_minus, diyfp v, diyfp m_plus)
{
    assert(m_plus.e == m_minus.e);
    assert(m_plus.e == v.e);

    //  --------(-----------------------+-----------------------)--------    (A)
    //          m-                      v                       m+
    //
    //  --------------------(-----------+-----------------------)--------    (B)
    //                      m-          v                       m+
    //
    // First scale v (and m- and m+) such that the exponent is in the range
    // [alpha, gamma].

    const cached_power cached = get_cached_power_for_binary_exponent(m_plus.e);

    const diyfp c_minus_k(cached.f, cached.e); // = c ~= 10^-k

    // The exponent of the products is = v.e + c_minus_k.e + q and is in the range [alpha,gamma]
    const diyfp w       = diyfp::mul(v,       c_minus_k);
    const diyfp w_minus = diyfp::mul(m_minus, c_minus_k);
    const diyfp w_plus  = diyfp::mul(m_plus,  c_minus_k);

    //  ----(---+---)---------------(---+---)---------------(---+---)----
    //          w-                      w                       w+
    //          = c*m-                  = c*v                   = c*m+
    //
    // diyfp::mul rounds its result and c_minus_k is approximated too. w, w- and
    // w+ are now off by a small amount.
    // In fact:
    //
    //      w - v * 10^k < 1 ulp
    //
    // To account for this inaccuracy, add resp. subtract 1 ulp.
    //
    //  --------+---[---------------(---+---)---------------]---+--------
    //          w-  M-                  w                   M+  w+
    //
    // Now any number in [M-, M+] (bounds included) will round to w when input,
    // regardless of how the input rounding algorithm breaks ties.
    //
    // And digit_gen generates the shortest possible such number in [M-, M+].
    // Note that this does not mean that Grisu2 always generates the shortest
    // possible number in the interval (m-, m+).
    const diyfp M_minus(w_minus.f + 1, w_minus.e);
    const diyfp M_plus (w_plus.f  - 1, w_plus.e );

    decimal_exponent = -cached.k; // = -(-k) = k

    grisu2_digit_gen(buf, len, decimal_exponent, M_minus, w, M_plus);
}

/*!
v = buf * 10^decimal_exponent
len is the length of the buffer (number of decimal digits)
The buffer must be large enough, i.e. >= max_digits10.
*/
template <typename FloatType>
void grisu2(char* buf, int& len, int& decimal_exponent, FloatType value)
{
    static_assert(diyfp::kPrecision >= std::numeric_limits<FloatType>::digits + 3,
                  "internal error: not enough precision");

    assert(std::isfinite(value));
    assert(value > 0);

    // If the neighbors (and boundaries) of 'value' are always computed for double-precision
    // numbers, all float's can be recovered using strtod (and strtof). However, the resulting
    // decimal representations are not exactly "short".
    //
    // The documentation for 'std::to_chars' (https://en.cppreference.com/w/cpp/utility/to_chars)
    // says "value is converted to a string as if by std::sprintf in the default ("C") locale"
    // and since sprintf promotes float's to double's, I think this is exactly what 'std::to_chars'
    // does.
    // On the other hand, the documentation for 'std::to_chars' requires that "parsing the
    // representation using the corresponding std::from_chars function recovers value exactly". That
    // indicates that single precision floating-point numbers should be recovered using
    // 'std::strtof'.
    //
    // NB: If the neighbors are computed for single-precision numbers, there is a single float
    //     (7.0385307e-26f) which can't be recovered using strtod. The resulting double precision
    //     value is off by 1 ulp.
#if 0
    const boundaries w = compute_boundaries(static_cast<double>(value));
#else
    const boundaries w = compute_boundaries(value);
#endif

    grisu2(buf, len, decimal_exponent, w.minus, w.w, w.plus);
}

/*!
@brief appends a decimal representation of e to buf
@return a pointer to the element following the exponent.
@pre -1000 < e < 1000
*/
inline char* append_exponent(char* buf, int e)
{
    assert(e > -1000);
    assert(e <  1000);

    if (e < 0)
    {
        e = -e;
        *buf++ = '-';
    }
    else
    {
        *buf++ = '+';
    }

    auto k = static_cast<std::uint32_t>(e);
    if (k < 10)
    {
        // Always print at least two digits in the exponent.
        // This is for compatibility with printf("%g").
        *buf++ = '0';
        *buf++ = static_cast<char>('0' + k);
    }
    else if (k < 100)
    {
        *buf++ = static_cast<char>('0' + k / 10);
        k %= 10;
        *buf++ = static_cast<char>('0' + k);
    }
    else
    {
        *buf++ = static_cast<char>('0' + k / 100);
        k %= 100;
        *buf++ = static_cast<char>('0' + k / 10);
        k %= 10;
        *buf++ = static_cast<char>('0' + k);
    }

    return buf;
}

/*!
@brief prettify v = buf * 10^decimal_exponent

If v is in the range [10^min_exp, 10^max_exp) it will be printed in fixed-point
notation. Otherwise it will be printed in exponential notation.

@pre min_exp < 0
@pre max_exp > 0
*/
inline char* format_buffer(char* buf, int len, int decimal_exponent,
                           int min_exp, int max_exp)
{
    assert(min_exp < 0);
    assert(max_exp > 0);

    const int k = len;
    const int n = len + decimal_exponent;

    // v = buf * 10^(n-k)
    // k is the length of the buffer (number of decimal digits)
    // n is the position of the decimal point relative to the start of the buffer.

    if (k <= n and n <= max_exp)
    {
        // digits[000]
        // len <= max_exp + 2

        std::memset(buf + k, '0', static_cast<size_t>(n - k));
        // Make it look like a floating-point number (#362, #378)
        buf[n + 0] = '.';
        buf[n + 1] = '0';
        return buf + (n + 2);
    }

    if (0 < n and n <= max_exp)
    {
        // dig.its
        // len <= max_digits10 + 1

        assert(k > n);

        std::memmove(buf + (n + 1), buf + n, static_cast<size_t>(k - n));
        buf[n] = '.';
        return buf + (k + 1);
    }

    if (min_exp < n and n <= 0)
    {
        // 0.[000]digits
        // len <= 2 + (-min_exp - 1) + max_digits10

        std::memmove(buf + (2 + -n), buf, static_cast<size_t>(k));
        buf[0] = '0';
        buf[1] = '.';
        std::memset(buf + 2, '0', static_cast<size_t>(-n));
        return buf + (2 + (-n) + k);
    }

    if (k == 1)
    {
        // dE+123
        // len <= 1 + 5

        buf += 1;
    }
    else
    {
        // d.igitsE+123
        // len <= max_digits10 + 1 + 5

        std::memmove(buf + 2, buf + 1, static_cast<size_t>(k - 1));
        buf[1] = '.';
        buf += 1 + k;
    }

    *buf++ = 'e';
    return append_exponent(buf, n - 1);
}

} // namespace dtoa_impl

/*!
@brief generates a decimal representation of the floating-point number value in [first, last).

The format of the resulting decimal representation is similar to printf's %g
format. Returns an iterator pointing past-the-end of the decimal representation.

@note The input number must be finite, i.e. NaN's and Inf's are not supported.
@note The buffer must be large enough.
@note The result is NOT null-terminated.
*/
template <typename FloatType>
char* to_chars(char* first, const char* last, FloatType value)
{
    static_cast<void>(last); // maybe unused - fix warning
    assert(std::isfinite(value));

    // Use signbit(value) instead of (value < 0) since signbit works for -0.
    if (std::signbit(value))
    {
        value = -value;
        *first++ = '-';
    }

    if (value == 0) // +-0
    {
        *first++ = '0';
        // Make it look like a floating-point number (#362, #378)
        *first++ = '.';
        *first++ = '0';
        return first;
    }

    assert(last - first >= std::numeric_limits<FloatType>::max_digits10);

    // Compute v = buffer * 10^decimal_exponent.
    // The decimal digits are stored in the buffer, which needs to be interpreted
    // as an unsigned decimal integer.
    // len is the length of the buffer, i.e. the number of decimal digits.
    int len = 0;
    int decimal_exponent = 0;
    dtoa_impl::grisu2(first, len, decimal_exponent, value);

    assert(len <= std::numeric_limits<FloatType>::max_digits10);

    // Format the buffer like printf("%.*g", prec, value)
    constexpr int kMinExp = -4;
    // Use digits10 here to increase compatibility with version 2.
    constexpr int kMaxExp = std::numeric_limits<FloatType>::digits10;

    assert(last - first >= kMaxExp + 2);
    assert(last - first >= 2 + (-kMinExp - 1) + std::numeric_limits<FloatType>::max_digits10);
    assert(last - first >= std::numeric_limits<FloatType>::max_digits10 + 6);

    return dtoa_impl::format_buffer(first, len, decimal_exponent, kMinExp, kMaxExp);
}

} // namespace detail
} // namespace nlohmann

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/output/binary_writer.hpp>

// #include <nlohmann/detail/output/output_adapters.hpp>

// #include <nlohmann/detail/value_t.hpp>


namespace nlohmann
{
namespace detail
{
///////////////////
// serialization //
///////////////////

/// how to treat decoding errors
enum class error_handler_t
{
    strict,  ///< throw a type_error exception in case of invalid UTF-8
    replace, ///< replace invalid UTF-8 sequences with U+FFFD
    ignore   ///< ignore invalid UTF-8 sequences
};

template<typename BasicJsonType>
class serializer
{
    using string_t = typename BasicJsonType::string_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    static constexpr std::uint8_t UTF8_ACCEPT = 0;
    static constexpr std::uint8_t UTF8_REJECT = 1;

  public:
    /*!
    @param[in] s  output stream to serialize to
    @param[in] ichar  indentation character to use
    @param[in] error_handler_  how to react on decoding errors
    */
    serializer(output_adapter_t<char> s, const char ichar,
               error_handler_t error_handler_ = error_handler_t::strict)
        : o(std::move(s))
        , loc(std::localeconv())
        , thousands_sep(loc->thousands_sep == nullptr ? '\0' : * (loc->thousands_sep))
        , decimal_point(loc->decimal_point == nullptr ? '\0' : * (loc->decimal_point))
        , indent_char(ichar)
        , indent_string(512, indent_char)
        , error_handler(error_handler_)
    {}

    // delete because of pointer members
    serializer(const serializer&) = delete;
    serializer& operator=(const serializer&) = delete;
    serializer(serializer&&) = delete;
    serializer& operator=(serializer&&) = delete;
    ~serializer() = default;

    /*!
    @brief internal implementation of the serialization function

    This function is called by the public member function dump and organizes
    the serialization internally. The indentation level is propagated as
    additional parameter. In case of arrays and objects, the function is
    called recursively.

    - strings and object keys are escaped using `escape_string()`
    - integer numbers are converted implicitly via `operator<<`
    - floating-point numbers are converted to a string using `"%g"` format

    @param[in] val             value to serialize
    @param[in] pretty_print    whether the output shall be pretty-printed
    @param[in] indent_step     the indent level
    @param[in] current_indent  the current indent level (only used internally)
    */
    void dump(const BasicJsonType& val, const bool pretty_print,
              const bool ensure_ascii,
              const unsigned int indent_step,
              const unsigned int current_indent = 0)
    {
        switch (val.m_type)
        {
            case value_t::object:
            {
                if (val.m_value.object->empty())
                {
                    o->write_characters("{}", 2);
                    return;
                }

                if (pretty_print)
                {
                    o->write_characters("{\n", 2);

                    // variable to hold indentation for recursive calls
                    const auto new_indent = current_indent + indent_step;
                    if (JSON_UNLIKELY(indent_string.size() < new_indent))
                    {
                        indent_string.resize(indent_string.size() * 2, ' ');
                    }

                    // first n-1 elements
                    auto i = val.m_value.object->cbegin();
                    for (std::size_t cnt = 0; cnt < val.m_value.object->size() - 1; ++cnt, ++i)
                    {
                        o->write_characters(indent_string.c_str(), new_indent);
                        o->write_character('\"');
                        dump_escaped(i->first, ensure_ascii);
                        o->write_characters("\": ", 3);
                        dump(i->second, true, ensure_ascii, indent_step, new_indent);
                        o->write_characters(",\n", 2);
                    }

                    // last element
                    assert(i != val.m_value.object->cend());
                    assert(std::next(i) == val.m_value.object->cend());
                    o->write_characters(indent_string.c_str(), new_indent);
                    o->write_character('\"');
                    dump_escaped(i->first, ensure_ascii);
                    o->write_characters("\": ", 3);
                    dump(i->second, true, ensure_ascii, indent_step, new_indent);

                    o->write_character('\n');
                    o->write_characters(indent_string.c_str(), current_indent);
                    o->write_character('}');
                }
                else
                {
                    o->write_character('{');

                    // first n-1 elements
                    auto i = val.m_value.object->cbegin();
                    for (std::size_t cnt = 0; cnt < val.m_value.object->size() - 1; ++cnt, ++i)
                    {
                        o->write_character('\"');
                        dump_escaped(i->first, ensure_ascii);
                        o->write_characters("\":", 2);
                        dump(i->second, false, ensure_ascii, indent_step, current_indent);
                        o->write_character(',');
                    }

                    // last element
                    assert(i != val.m_value.object->cend());
                    assert(std::next(i) == val.m_value.object->cend());
                    o->write_character('\"');
                    dump_escaped(i->first, ensure_ascii);
                    o->write_characters("\":", 2);
                    dump(i->second, false, ensure_ascii, indent_step, current_indent);

                    o->write_character('}');
                }

                return;
            }

            case value_t::array:
            {
                if (val.m_value.array->empty())
                {
                    o->write_characters("[]", 2);
                    return;
                }

                if (pretty_print)
                {
                    o->write_characters("[\n", 2);

                    // variable to hold indentation for recursive calls
                    const auto new_indent = current_indent + indent_step;
                    if (JSON_UNLIKELY(indent_string.size() < new_indent))
                    {
                        indent_string.resize(indent_string.size() * 2, ' ');
                    }

                    // first n-1 elements
                    for (auto i = val.m_value.array->cbegin();
                            i != val.m_value.array->cend() - 1; ++i)
                    {
                        o->write_characters(indent_string.c_str(), new_indent);
                        dump(*i, true, ensure_ascii, indent_step, new_indent);
                        o->write_characters(",\n", 2);
                    }

                    // last element
                    assert(not val.m_value.array->empty());
                    o->write_characters(indent_string.c_str(), new_indent);
                    dump(val.m_value.array->back(), true, ensure_ascii, indent_step, new_indent);

                    o->write_character('\n');
                    o->write_characters(indent_string.c_str(), current_indent);
                    o->write_character(']');
                }
                else
                {
                    o->write_character('[');

                    // first n-1 elements
                    for (auto i = val.m_value.array->cbegin();
                            i != val.m_value.array->cend() - 1; ++i)
                    {
                        dump(*i, false, ensure_ascii, indent_step, current_indent);
                        o->write_character(',');
                    }

                    // last element
                    assert(not val.m_value.array->empty());
                    dump(val.m_value.array->back(), false, ensure_ascii, indent_step, current_indent);

                    o->write_character(']');
                }

                return;
            }

            case value_t::string:
            {
                o->write_character('\"');
                dump_escaped(*val.m_value.string, ensure_ascii);
                o->write_character('\"');
                return;
            }

            case value_t::boolean:
            {
                if (val.m_value.boolean)
                {
                    o->write_characters("true", 4);
                }
                else
                {
                    o->write_characters("false", 5);
                }
                return;
            }

            case value_t::number_integer:
            {
                dump_integer(val.m_value.number_integer);
                return;
            }

            case value_t::number_unsigned:
            {
                dump_integer(val.m_value.number_unsigned);
                return;
            }

            case value_t::number_float:
            {
                dump_float(val.m_value.number_float);
                return;
            }

            case value_t::discarded:
            {
                o->write_characters("<discarded>", 11);
                return;
            }

            case value_t::null:
            {
                o->write_characters("null", 4);
                return;
            }

            default:            // LCOV_EXCL_LINE
                assert(false);  // LCOV_EXCL_LINE
        }
    }

  private:
    /*!
    @brief dump escaped string

    Escape a string by replacing certain special characters by a sequence of an
    escape character (backslash) and another character and other control
    characters by a sequence of "\u" followed by a four-digit hex
    representation. The escaped string is written to output stream @a o.

    @param[in] s  the string to escape
    @param[in] ensure_ascii  whether to escape non-ASCII characters with
                             \uXXXX sequences

    @complexity Linear in the length of string @a s.
    */
    void dump_escaped(const string_t& s, const bool ensure_ascii)
    {
        std::uint32_t codepoint;
        std::uint8_t state = UTF8_ACCEPT;
        std::size_t bytes = 0;  // number of bytes written to string_buffer

        // number of bytes written at the point of the last valid byte
        std::size_t bytes_after_last_accept = 0;
        std::size_t undumped_chars = 0;

        for (std::size_t i = 0; i < s.size(); ++i)
        {
            const auto byte = static_cast<uint8_t>(s[i]);

            switch (decode(state, codepoint, byte))
            {
                case UTF8_ACCEPT:  // decode found a new code point
                {
                    switch (codepoint)
                    {
                        case 0x08: // backspace
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = 'b';
                            break;
                        }

                        case 0x09: // horizontal tab
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = 't';
                            break;
                        }

                        case 0x0A: // newline
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = 'n';
                            break;
                        }

                        case 0x0C: // formfeed
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = 'f';
                            break;
                        }

                        case 0x0D: // carriage return
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = 'r';
                            break;
                        }

                        case 0x22: // quotation mark
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = '\"';
                            break;
                        }

                        case 0x5C: // reverse solidus
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = '\\';
                            break;
                        }

                        default:
                        {
                            // escape control characters (0x00..0x1F) or, if
                            // ensure_ascii parameter is used, non-ASCII characters
                            if ((codepoint <= 0x1F) or (ensure_ascii and (codepoint >= 0x7F)))
                            {
                                if (codepoint <= 0xFFFF)
                                {
                                    (std::snprintf)(string_buffer.data() + bytes, 7, "\\u%04x",
                                                    static_cast<std::uint16_t>(codepoint));
                                    bytes += 6;
                                }
                                else
                                {
                                    (std::snprintf)(string_buffer.data() + bytes, 13, "\\u%04x\\u%04x",
                                                    static_cast<std::uint16_t>(0xD7C0u + (codepoint >> 10u)),
                                                    static_cast<std::uint16_t>(0xDC00u + (codepoint & 0x3FFu)));
                                    bytes += 12;
                                }
                            }
                            else
                            {
                                // copy byte to buffer (all previous bytes
                                // been copied have in default case above)
                                string_buffer[bytes++] = s[i];
                            }
                            break;
                        }
                    }

                    // write buffer and reset index; there must be 13 bytes
                    // left, as this is the maximal number of bytes to be
                    // written ("\uxxxx\uxxxx\0") for one code point
                    if (string_buffer.size() - bytes < 13)
                    {
                        o->write_characters(string_buffer.data(), bytes);
                        bytes = 0;
                    }

                    // remember the byte position of this accept
                    bytes_after_last_accept = bytes;
                    undumped_chars = 0;
                    break;
                }

                case UTF8_REJECT:  // decode found invalid UTF-8 byte
                {
                    switch (error_handler)
                    {
                        case error_handler_t::strict:
                        {
                            std::string sn(3, '\0');
                            (std::snprintf)(&sn[0], sn.size(), "%.2X", byte);
                            JSON_THROW(type_error::create(316, "invalid UTF-8 byte at index " + std::to_string(i) + ": 0x" + sn));
                        }

                        case error_handler_t::ignore:
                        case error_handler_t::replace:
                        {
                            // in case we saw this character the first time, we
                            // would like to read it again, because the byte
                            // may be OK for itself, but just not OK for the
                            // previous sequence
                            if (undumped_chars > 0)
                            {
                                --i;
                            }

                            // reset length buffer to the last accepted index;
                            // thus removing/ignoring the invalid characters
                            bytes = bytes_after_last_accept;

                            if (error_handler == error_handler_t::replace)
                            {
                                // add a replacement character
                                if (ensure_ascii)
                                {
                                    string_buffer[bytes++] = '\\';
                                    string_buffer[bytes++] = 'u';
                                    string_buffer[bytes++] = 'f';
                                    string_buffer[bytes++] = 'f';
                                    string_buffer[bytes++] = 'f';
                                    string_buffer[bytes++] = 'd';
                                }
                                else
                                {
                                    string_buffer[bytes++] = detail::binary_writer<BasicJsonType, char>::to_char_type('\xEF');
                                    string_buffer[bytes++] = detail::binary_writer<BasicJsonType, char>::to_char_type('\xBF');
                                    string_buffer[bytes++] = detail::binary_writer<BasicJsonType, char>::to_char_type('\xBD');
                                }

                                // write buffer and reset index; there must be 13 bytes
                                // left, as this is the maximal number of bytes to be
                                // written ("\uxxxx\uxxxx\0") for one code point
                                if (string_buffer.size() - bytes < 13)
                                {
                                    o->write_characters(string_buffer.data(), bytes);
                                    bytes = 0;
                                }

                                bytes_after_last_accept = bytes;
                            }

                            undumped_chars = 0;

                            // continue processing the string
                            state = UTF8_ACCEPT;
                            break;
                        }

                        default:            // LCOV_EXCL_LINE
                            assert(false);  // LCOV_EXCL_LINE
                    }
                    break;
                }

                default:  // decode found yet incomplete multi-byte code point
                {
                    if (not ensure_ascii)
                    {
                        // code point will not be escaped - copy byte to buffer
                        string_buffer[bytes++] = s[i];
                    }
                    ++undumped_chars;
                    break;
                }
            }
        }

        // we finished processing the string
        if (JSON_LIKELY(state == UTF8_ACCEPT))
        {
            // write buffer
            if (bytes > 0)
            {
                o->write_characters(string_buffer.data(), bytes);
            }
        }
        else
        {
            // we finish reading, but do not accept: string was incomplete
            switch (error_handler)
            {
                case error_handler_t::strict:
                {
                    std::string sn(3, '\0');
                    (std::snprintf)(&sn[0], sn.size(), "%.2X", static_cast<std::uint8_t>(s.back()));
                    JSON_THROW(type_error::create(316, "incomplete UTF-8 string; last byte: 0x" + sn));
                }

                case error_handler_t::ignore:
                {
                    // write all accepted bytes
                    o->write_characters(string_buffer.data(), bytes_after_last_accept);
                    break;
                }

                case error_handler_t::replace:
                {
                    // write all accepted bytes
                    o->write_characters(string_buffer.data(), bytes_after_last_accept);
                    // add a replacement character
                    if (ensure_ascii)
                    {
                        o->write_characters("\\ufffd", 6);
                    }
                    else
                    {
                        o->write_characters("\xEF\xBF\xBD", 3);
                    }
                    break;
                }

                default:            // LCOV_EXCL_LINE
                    assert(false);  // LCOV_EXCL_LINE
            }
        }
    }

    /*!
    @brief count digits

    Count the number of decimal (base 10) digits for an input unsigned integer.

    @param[in] x  unsigned integer number to count its digits
    @return    number of decimal digits
    */
    inline unsigned int count_digits(number_unsigned_t x) noexcept
    {
        unsigned int n_digits = 1;
        for (;;)
        {
            if (x < 10)
            {
                return n_digits;
            }
            if (x < 100)
            {
                return n_digits + 1;
            }
            if (x < 1000)
            {
                return n_digits + 2;
            }
            if (x < 10000)
            {
                return n_digits + 3;
            }
            x = x / 10000u;
            n_digits += 4;
        }
    }

    /*!
    @brief dump an integer

    Dump a given integer to output stream @a o. Works internally with
    @a number_buffer.

    @param[in] x  integer number (signed or unsigned) to dump
    @tparam NumberType either @a number_integer_t or @a number_unsigned_t
    */
    template<typename NumberType, detail::enable_if_t<
                 std::is_same<NumberType, number_unsigned_t>::value or
                 std::is_same<NumberType, number_integer_t>::value,
                 int> = 0>
    void dump_integer(NumberType x)
    {
        static constexpr std::array<std::array<char, 2>, 100> digits_to_99
        {
            {
                {{'0', '0'}}, {{'0', '1'}}, {{'0', '2'}}, {{'0', '3'}}, {{'0', '4'}}, {{'0', '5'}}, {{'0', '6'}}, {{'0', '7'}}, {{'0', '8'}}, {{'0', '9'}},
                {{'1', '0'}}, {{'1', '1'}}, {{'1', '2'}}, {{'1', '3'}}, {{'1', '4'}}, {{'1', '5'}}, {{'1', '6'}}, {{'1', '7'}}, {{'1', '8'}}, {{'1', '9'}},
                {{'2', '0'}}, {{'2', '1'}}, {{'2', '2'}}, {{'2', '3'}}, {{'2', '4'}}, {{'2', '5'}}, {{'2', '6'}}, {{'2', '7'}}, {{'2', '8'}}, {{'2', '9'}},
                {{'3', '0'}}, {{'3', '1'}}, {{'3', '2'}}, {{'3', '3'}}, {{'3', '4'}}, {{'3', '5'}}, {{'3', '6'}}, {{'3', '7'}}, {{'3', '8'}}, {{'3', '9'}},
                {{'4', '0'}}, {{'4', '1'}}, {{'4', '2'}}, {{'4', '3'}}, {{'4', '4'}}, {{'4', '5'}}, {{'4', '6'}}, {{'4', '7'}}, {{'4', '8'}}, {{'4', '9'}},
                {{'5', '0'}}, {{'5', '1'}}, {{'5', '2'}}, {{'5', '3'}}, {{'5', '4'}}, {{'5', '5'}}, {{'5', '6'}}, {{'5', '7'}}, {{'5', '8'}}, {{'5', '9'}},
                {{'6', '0'}}, {{'6', '1'}}, {{'6', '2'}}, {{'6', '3'}}, {{'6', '4'}}, {{'6', '5'}}, {{'6', '6'}}, {{'6', '7'}}, {{'6', '8'}}, {{'6', '9'}},
                {{'7', '0'}}, {{'7', '1'}}, {{'7', '2'}}, {{'7', '3'}}, {{'7', '4'}}, {{'7', '5'}}, {{'7', '6'}}, {{'7', '7'}}, {{'7', '8'}}, {{'7', '9'}},
                {{'8', '0'}}, {{'8', '1'}}, {{'8', '2'}}, {{'8', '3'}}, {{'8', '4'}}, {{'8', '5'}}, {{'8', '6'}}, {{'8', '7'}}, {{'8', '8'}}, {{'8', '9'}},
                {{'9', '0'}}, {{'9', '1'}}, {{'9', '2'}}, {{'9', '3'}}, {{'9', '4'}}, {{'9', '5'}}, {{'9', '6'}}, {{'9', '7'}}, {{'9', '8'}}, {{'9', '9'}},
            }
        };

        // special case for "0"
        if (x == 0)
        {
            o->write_character('0');
            return;
        }

        // use a pointer to fill the buffer
        auto buffer_ptr = number_buffer.begin();

        const bool is_negative = std::is_same<NumberType, number_integer_t>::value and not(x >= 0); // see issue #755
        number_unsigned_t abs_value;

        unsigned int n_chars;

        if (is_negative)
        {
            *buffer_ptr = '-';
            abs_value = static_cast<number_unsigned_t>(std::abs(static_cast<std::intmax_t>(x)));

            // account one more byte for the minus sign
            n_chars = 1 + count_digits(abs_value);
        }
        else
        {
            abs_value = static_cast<number_unsigned_t>(x);
            n_chars = count_digits(abs_value);
        }

        // spare 1 byte for '\0'
        assert(n_chars < number_buffer.size() - 1);

        // jump to the end to generate the string from backward
        // so we later avoid reversing the result
        buffer_ptr += n_chars;

        // Fast int2ascii implementation inspired by "Fastware" talk by Andrei Alexandrescu
        // See: https://www.youtube.com/watch?v=o4-CwDo2zpg
        while (abs_value >= 100)
        {
            const auto digits_index = static_cast<unsigned>((abs_value % 100));
            abs_value /= 100;
            *(--buffer_ptr) = digits_to_99[digits_index][1];
            *(--buffer_ptr) = digits_to_99[digits_index][0];
        }

        if (abs_value >= 10)
        {
            const auto digits_index = static_cast<unsigned>(abs_value);
            *(--buffer_ptr) = digits_to_99[digits_index][1];
            *(--buffer_ptr) = digits_to_99[digits_index][0];
        }
        else
        {
            *(--buffer_ptr) = static_cast<char>('0' + abs_value);
        }

        o->write_characters(number_buffer.data(), n_chars);
    }

    /*!
    @brief dump a floating-point number

    Dump a given floating-point number to output stream @a o. Works internally
    with @a number_buffer.

    @param[in] x  floating-point number to dump
    */
    void dump_float(number_float_t x)
    {
        // NaN / inf
        if (not std::isfinite(x))
        {
            o->write_characters("null", 4);
            return;
        }

        // If number_float_t is an IEEE-754 single or double precision number,
        // use the Grisu2 algorithm to produce short numbers which are
        // guaranteed to round-trip, using strtof and strtod, resp.
        //
        // NB: The test below works if <long double> == <double>.
        static constexpr bool is_ieee_single_or_double
            = (std::numeric_limits<number_float_t>::is_iec559 and std::numeric_limits<number_float_t>::digits == 24 and std::numeric_limits<number_float_t>::max_exponent == 128) or
              (std::numeric_limits<number_float_t>::is_iec559 and std::numeric_limits<number_float_t>::digits == 53 and std::numeric_limits<number_float_t>::max_exponent == 1024);

        dump_float(x, std::integral_constant<bool, is_ieee_single_or_double>());
    }

    void dump_float(number_float_t x, std::true_type /*is_ieee_single_or_double*/)
    {
        char* begin = number_buffer.data();
        char* end = ::nlohmann::detail::to_chars(begin, begin + number_buffer.size(), x);

        o->write_characters(begin, static_cast<size_t>(end - begin));
    }

    void dump_float(number_float_t x, std::false_type /*is_ieee_single_or_double*/)
    {
        // get number of digits for a float -> text -> float round-trip
        static constexpr auto d = std::numeric_limits<number_float_t>::max_digits10;

        // the actual conversion
        std::ptrdiff_t len = (std::snprintf)(number_buffer.data(), number_buffer.size(), "%.*g", d, x);

        // negative value indicates an error
        assert(len > 0);
        // check if buffer was large enough
        assert(static_cast<std::size_t>(len) < number_buffer.size());

        // erase thousands separator
        if (thousands_sep != '\0')
        {
            const auto end = std::remove(number_buffer.begin(),
                                         number_buffer.begin() + len, thousands_sep);
            std::fill(end, number_buffer.end(), '\0');
            assert((end - number_buffer.begin()) <= len);
            len = (end - number_buffer.begin());
        }

        // convert decimal point to '.'
        if (decimal_point != '\0' and decimal_point != '.')
        {
            const auto dec_pos = std::find(number_buffer.begin(), number_buffer.end(), decimal_point);
            if (dec_pos != number_buffer.end())
            {
                *dec_pos = '.';
            }
        }

        o->write_characters(number_buffer.data(), static_cast<std::size_t>(len));

        // determine if need to append ".0"
        const bool value_is_int_like =
            std::none_of(number_buffer.begin(), number_buffer.begin() + len + 1,
                         [](char c)
        {
            return c == '.' or c == 'e';
        });

        if (value_is_int_like)
        {
            o->write_characters(".0", 2);
        }
    }

    /*!
    @brief check whether a string is UTF-8 encoded

    The function checks each byte of a string whether it is UTF-8 encoded. The
    result of the check is stored in the @a state parameter. The function must
    be called initially with state 0 (accept). State 1 means the string must
    be rejected, because the current byte is not allowed. If the string is
    completely processed, but the state is non-zero, the string ended
    prematurely; that is, the last byte indicated more bytes should have
    followed.

    @param[in,out] state  the state of the decoding
    @param[in,out] codep  codepoint (valid only if resulting state is UTF8_ACCEPT)
    @param[in] byte       next byte to decode
    @return               new state

    @note The function has been edited: a std::array is used.

    @copyright Copyright (c) 2008-2009 Bjoern Hoehrmann <bjoern@hoehrmann.de>
    @sa http://bjoern.hoehrmann.de/utf-8/decoder/dfa/
    */
    static std::uint8_t decode(std::uint8_t& state, std::uint32_t& codep, const std::uint8_t byte) noexcept
    {
        static const std::array<std::uint8_t, 400> utf8d =
        {
            {
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 00..1F
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 20..3F
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 40..5F
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 60..7F
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, // 80..9F
                7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, // A0..BF
                8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, // C0..DF
                0xA, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x4, 0x3, 0x3, // E0..EF
                0xB, 0x6, 0x6, 0x6, 0x5, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, // F0..FF
                0x0, 0x1, 0x2, 0x3, 0x5, 0x8, 0x7, 0x1, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x1, 0x1, // s0..s0
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, // s1..s2
                1, 2, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, // s3..s4
                1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, // s5..s6
                1, 3, 1, 1, 1, 1, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 // s7..s8
            }
        };

        const std::uint8_t type = utf8d[byte];

        codep = (state != UTF8_ACCEPT)
                ? (byte & 0x3fu) | (codep << 6u)
                : (0xFFu >> type) & (byte);

        state = utf8d[256u + state * 16u + type];
        return state;
    }

  private:
    /// the output of the serializer
    output_adapter_t<char> o = nullptr;

    /// a (hopefully) large enough character buffer
    std::array<char, 64> number_buffer{{}};

    /// the locale
    const std::lconv* loc = nullptr;
    /// the locale's thousand separator character
    const char thousands_sep = '\0';
    /// the locale's decimal point character
    const char decimal_point = '\0';

    /// string buffer
    std::array<char, 512> string_buffer{{}};

    /// the indentation character
    const char indent_char;
    /// the indentation string
    string_t indent_string;

    /// error_handler how to react on decoding errors
    const error_handler_t error_handler;
};
}  // namespace detail
}  // namespace nlohmann

// #include <nlohmann/detail/value_t.hpp>

// #include <nlohmann/json_fwd.hpp>


/*!
@brief namespace for Niels Lohmann
@see https://github.com/nlohmann
@since version 1.0.0
*/
namespace nlohmann
{

/*!
@brief a class to store JSON values

@tparam ObjectType type for JSON objects (`std::map` by default; will be used
in @ref object_t)
@tparam ArrayType type for JSON arrays (`std::vector` by default; will be used
in @ref array_t)
@tparam StringType type for JSON strings and object keys (`std::string` by
default; will be used in @ref string_t)
@tparam BooleanType type for JSON booleans (`bool` by default; will be used
in @ref boolean_t)
@tparam NumberIntegerType type for JSON integer numbers (`int64_t` by
default; will be used in @ref number_integer_t)
@tparam NumberUnsignedType type for JSON unsigned integer numbers (@c
`uint64_t` by default; will be used in @ref number_unsigned_t)
@tparam NumberFloatType type for JSON floating-point numbers (`double` by
default; will be used in @ref number_float_t)
@tparam AllocatorType type of the allocator to use (`std::allocator` by
default)
@tparam JSONSerializer the serializer to resolve internal calls to `to_json()`
and `from_json()` (@ref adl_serializer by default)

@requirement The class satisfies the following concept requirements:
- Basic
 - [DefaultConstructible](https://en.cppreference.com/w/cpp/named_req/DefaultConstructible):
   JSON values can be default constructed. The result will be a JSON null
   value.
 - [MoveConstructible](https://en.cppreference.com/w/cpp/named_req/MoveConstructible):
   A JSON value can be constructed from an rvalue argument.
 - [CopyConstructible](https://en.cppreference.com/w/cpp/named_req/CopyConstructible):
   A JSON value can be copy-constructed from an lvalue expression.
 - [MoveAssignable](https://en.cppreference.com/w/cpp/named_req/MoveAssignable):
   A JSON value van be assigned from an rvalue argument.
 - [CopyAssignable](https://en.cppreference.com/w/cpp/named_req/CopyAssignable):
   A JSON value can be copy-assigned from an lvalue expression.
 - [Destructible](https://en.cppreference.com/w/cpp/named_req/Destructible):
   JSON values can be destructed.
- Layout
 - [StandardLayoutType](https://en.cppreference.com/w/cpp/named_req/StandardLayoutType):
   JSON values have
   [standard layout](https://en.cppreference.com/w/cpp/language/data_members#Standard_layout):
   All non-static data members are private and standard layout types, the
   class has no virtual functions or (virtual) base classes.
- Library-wide
 - [EqualityComparable](https://en.cppreference.com/w/cpp/named_req/EqualityComparable):
   JSON values can be compared with `==`, see @ref
   operator==(const_reference,const_reference).
 - [LessThanComparable](https://en.cppreference.com/w/cpp/named_req/LessThanComparable):
   JSON values can be compared with `<`, see @ref
   operator<(const_reference,const_reference).
 - [Swappable](https://en.cppreference.com/w/cpp/named_req/Swappable):
   Any JSON lvalue or rvalue of can be swapped with any lvalue or rvalue of
   other compatible types, using unqualified function call @ref swap().
 - [NullablePointer](https://en.cppreference.com/w/cpp/named_req/NullablePointer):
   JSON values can be compared against `std::nullptr_t` objects which are used
   to model the `null` value.
- Container
 - [Container](https://en.cppreference.com/w/cpp/named_req/Container):
   JSON values can be used like STL containers and provide iterator access.
 - [ReversibleContainer](https://en.cppreference.com/w/cpp/named_req/ReversibleContainer);
   JSON values can be used like STL containers and provide reverse iterator
   access.

@invariant The member variables @a m_value and @a m_type have the following
relationship:
- If `m_type == value_t::object`, then `m_value.object != nullptr`.
- If `m_type == value_t::array`, then `m_value.array != nullptr`.
- If `m_type == value_t::string`, then `m_value.string != nullptr`.
The invariants are checked by member function assert_invariant().

@internal
@note ObjectType trick from http://stackoverflow.com/a/9860911
@endinternal

@see [RFC 7159: The JavaScript Object Notation (JSON) Data Interchange
Format](http://rfc7159.net/rfc7159)

@since version 1.0.0

@nosubgrouping
*/
NLOHMANN_BASIC_JSON_TPL_DECLARATION
class basic_json
{
  private:
    template<detail::value_t> friend struct detail::external_constructor;
    friend ::nlohmann::json_pointer<basic_json>;
    friend ::nlohmann::detail::parser<basic_json>;
    friend ::nlohmann::detail::serializer<basic_json>;
    template<typename BasicJsonType>
    friend class ::nlohmann::detail::iter_impl;
    template<typename BasicJsonType, typename CharType>
    friend class ::nlohmann::detail::binary_writer;
    template<typename BasicJsonType, typename SAX>
    friend class ::nlohmann::detail::binary_reader;
    template<typename BasicJsonType>
    friend class ::nlohmann::detail::json_sax_dom_parser;
    template<typename BasicJsonType>
    friend class ::nlohmann::detail::json_sax_dom_callback_parser;

    /// workaround type for MSVC
    using basic_json_t = NLOHMANN_BASIC_JSON_TPL;

    // convenience aliases for types residing in namespace detail;
    using lexer = ::nlohmann::detail::lexer<basic_json>;
    using parser = ::nlohmann::detail::parser<basic_json>;

    using primitive_iterator_t = ::nlohmann::detail::primitive_iterator_t;
    template<typename BasicJsonType>
    using internal_iterator = ::nlohmann::detail::internal_iterator<BasicJsonType>;
    template<typename BasicJsonType>
    using iter_impl = ::nlohmann::detail::iter_impl<BasicJsonType>;
    template<typename Iterator>
    using iteration_proxy = ::nlohmann::detail::iteration_proxy<Iterator>;
    template<typename Base> using json_reverse_iterator = ::nlohmann::detail::json_reverse_iterator<Base>;

    template<typename CharType>
    using output_adapter_t = ::nlohmann::detail::output_adapter_t<CharType>;

    using binary_reader = ::nlohmann::detail::binary_reader<basic_json>;
    template<typename CharType> using binary_writer = ::nlohmann::detail::binary_writer<basic_json, CharType>;

    using serializer = ::nlohmann::detail::serializer<basic_json>;

  public:
    using value_t = detail::value_t;
    /// JSON Pointer, see @ref nlohmann::json_pointer
    using json_pointer = ::nlohmann::json_pointer<basic_json>;
    template<typename T, typename SFINAE>
    using json_serializer = JSONSerializer<T, SFINAE>;
    /// how to treat decoding errors
    using error_handler_t = detail::error_handler_t;
    /// helper type for initializer lists of basic_json values
    using initializer_list_t = std::initializer_list<detail::json_ref<basic_json>>;

    using input_format_t = detail::input_format_t;
    /// SAX interface type, see @ref nlohmann::json_sax
    using json_sax_t = json_sax<basic_json>;

    ////////////////
    // exceptions //
    ////////////////

    /// @name exceptions
    /// Classes to implement user-defined exceptions.
    /// @{

    /// @copydoc detail::exception
    using exception = detail::exception;
    /// @copydoc detail::parse_error
    using parse_error = detail::parse_error;
    /// @copydoc detail::invalid_iterator
    using invalid_iterator = detail::invalid_iterator;
    /// @copydoc detail::type_error
    using type_error = detail::type_error;
    /// @copydoc detail::out_of_range
    using out_of_range = detail::out_of_range;
    /// @copydoc detail::other_error
    using other_error = detail::other_error;

    /// @}


    /////////////////////
    // container types //
    /////////////////////

    /// @name container types
    /// The canonic container types to use @ref basic_json like any other STL
    /// container.
    /// @{

    /// the type of elements in a basic_json container
    using value_type = basic_json;

    /// the type of an element reference
    using reference = value_type&;
    /// the type of an element const reference
    using const_reference = const value_type&;

    /// a type to represent differences between iterators
    using difference_type = std::ptrdiff_t;
    /// a type to represent container sizes
    using size_type = std::size_t;

    /// the allocator type
    using allocator_type = AllocatorType<basic_json>;

    /// the type of an element pointer
    using pointer = typename std::allocator_traits<allocator_type>::pointer;
    /// the type of an element const pointer
    using const_pointer = typename std::allocator_traits<allocator_type>::const_pointer;

    /// an iterator for a basic_json container
    using iterator = iter_impl<basic_json>;
    /// a const iterator for a basic_json container
    using const_iterator = iter_impl<const basic_json>;
    /// a reverse iterator for a basic_json container
    using reverse_iterator = json_reverse_iterator<typename basic_json::iterator>;
    /// a const reverse iterator for a basic_json container
    using const_reverse_iterator = json_reverse_iterator<typename basic_json::const_iterator>;

    /// @}


    /*!
    @brief returns the allocator associated with the container
    */
    static allocator_type get_allocator()
    {
        return allocator_type();
    }

    /*!
    @brief returns version information on the library

    This function returns a JSON object with information about the library,
    including the version number and information on the platform and compiler.

    @return JSON object holding version information
    key         | description
    ----------- | ---------------
    `compiler`  | Information on the used compiler. It is an object with the following keys: `c++` (the used C++ standard), `family` (the compiler family; possible values are `clang`, `icc`, `gcc`, `ilecpp`, `msvc`, `pgcpp`, `sunpro`, and `unknown`), and `version` (the compiler version).
    `copyright` | The copyright line for the library as string.
    `name`      | The name of the library as string.
    `platform`  | The used platform as string. Possible values are `win32`, `linux`, `apple`, `unix`, and `unknown`.
    `url`       | The URL of the project as string.
    `version`   | The version of the library. It is an object with the following keys: `major`, `minor`, and `patch` as defined by [Semantic Versioning](http://semver.org), and `string` (the version string).

    @liveexample{The following code shows an example output of the `meta()`
    function.,meta}

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @complexity Constant.

    @since 2.1.0
    */
    JSON_NODISCARD
    static basic_json meta()
    {
        basic_json result;

        result["copyright"] = "(C) 2013-2017 Niels Lohmann";
        result["name"] = "JSON for Modern C++";
        result["url"] = "https://github.com/nlohmann/json";
        result["version"]["string"] =
            std::to_string(NLOHMANN_JSON_VERSION_MAJOR) + "." +
            std::to_string(NLOHMANN_JSON_VERSION_MINOR) + "." +
            std::to_string(NLOHMANN_JSON_VERSION_PATCH);
        result["version"]["major"] = NLOHMANN_JSON_VERSION_MAJOR;
        result["version"]["minor"] = NLOHMANN_JSON_VERSION_MINOR;
        result["version"]["patch"] = NLOHMANN_JSON_VERSION_PATCH;

#ifdef _WIN32
        result["platform"] = "win32";
#elif defined __linux__
        result["platform"] = "linux";
#elif defined __APPLE__
        result["platform"] = "apple";
#elif defined __unix__
        result["platform"] = "unix";
#else
        result["platform"] = "unknown";
#endif

#if defined(__ICC) || defined(__INTEL_COMPILER)
        result["compiler"] = {{"family", "icc"}, {"version", __INTEL_COMPILER}};
#elif defined(__clang__)
        result["compiler"] = {{"family", "clang"}, {"version", __clang_version__}};
#elif defined(__GNUC__) || defined(__GNUG__)
        result["compiler"] = {{"family", "gcc"}, {"version", std::to_string(__GNUC__) + "." + std::to_string(__GNUC_MINOR__) + "." + std::to_string(__GNUC_PATCHLEVEL__)}};
#elif defined(__HP_cc) || defined(__HP_aCC)
        result["compiler"] = "hp"
#elif defined(__IBMCPP__)
        result["compiler"] = {{"family", "ilecpp"}, {"version", __IBMCPP__}};
#elif defined(_MSC_VER)
        result["compiler"] = {{"family", "msvc"}, {"version", _MSC_VER}};
#elif defined(__PGI)
        result["compiler"] = {{"family", "pgcpp"}, {"version", __PGI}};
#elif defined(__SUNPRO_CC)
        result["compiler"] = {{"family", "sunpro"}, {"version", __SUNPRO_CC}};
#else
        result["compiler"] = {{"family", "unknown"}, {"version", "unknown"}};
#endif

#ifdef __cplusplus
        result["compiler"]["c++"] = std::to_string(__cplusplus);
#else
        result["compiler"]["c++"] = "unknown";
#endif
        return result;
    }


    ///////////////////////////
    // JSON value data types //
    ///////////////////////////

    /// @name JSON value data types
    /// The data types to store a JSON value. These types are derived from
    /// the template arguments passed to class @ref basic_json.
    /// @{

#if defined(JSON_HAS_CPP_14)
    // Use transparent comparator if possible, combined with perfect forwarding
    // on find() and count() calls prevents unnecessary string construction.
    using object_comparator_t = std::less<>;
#else
    using object_comparator_t = std::less<StringType>;
#endif

    /*!
    @brief a type for an object

    [RFC 7159](http://rfc7159.net/rfc7159) describes JSON objects as follows:
    > An object is an unordered collection of zero or more name/value pairs,
    > where a name is a string and a value is a string, number, boolean, null,
    > object, or array.

    To store objects in C++, a type is defined by the template parameters
    described below.

    @tparam ObjectType  the container to store objects (e.g., `std::map` or
    `std::unordered_map`)
    @tparam StringType the type of the keys or names (e.g., `std::string`).
    The comparison function `std::less<StringType>` is used to order elements
    inside the container.
    @tparam AllocatorType the allocator to use for objects (e.g.,
    `std::allocator`)

    #### Default type

    With the default values for @a ObjectType (`std::map`), @a StringType
    (`std::string`), and @a AllocatorType (`std::allocator`), the default
    value for @a object_t is:

    @code {.cpp}
    std::map<
      std::string, // key_type
      basic_json, // value_type
      std::less<std::string>, // key_compare
      std::allocator<std::pair<const std::string, basic_json>> // allocator_type
    >
    @endcode

    #### Behavior

    The choice of @a object_t influences the behavior of the JSON class. With
    the default type, objects have the following behavior:

    - When all names are unique, objects will be interoperable in the sense
      that all software implementations receiving that object will agree on
      the name-value mappings.
    - When the names within an object are not unique, it is unspecified which
      one of the values for a given key will be chosen. For instance,
      `{"key": 2, "key": 1}` could be equal to either `{"key": 1}` or
      `{"key": 2}`.
    - Internally, name/value pairs are stored in lexicographical order of the
      names. Objects will also be serialized (see @ref dump) in this order.
      For instance, `{"b": 1, "a": 2}` and `{"a": 2, "b": 1}` will be stored
      and serialized as `{"a": 2, "b": 1}`.
    - When comparing objects, the order of the name/value pairs is irrelevant.
      This makes objects interoperable in the sense that they will not be
      affected by these differences. For instance, `{"b": 1, "a": 2}` and
      `{"a": 2, "b": 1}` will be treated as equal.

    #### Limits

    [RFC 7159](http://rfc7159.net/rfc7159) specifies:
    > An implementation may set limits on the maximum depth of nesting.

    In this class, the object's limit of nesting is not explicitly constrained.
    However, a maximum depth of nesting may be introduced by the compiler or
    runtime environment. A theoretical limit can be queried by calling the
    @ref max_size function of a JSON object.

    #### Storage

    Objects are stored as pointers in a @ref basic_json type. That is, for any
    access to object values, a pointer of type `object_t*` must be
    dereferenced.

    @sa @ref array_t -- type for an array value

    @since version 1.0.0

    @note The order name/value pairs are added to the object is *not*
    preserved by the library. Therefore, iterating an object may return
    name/value pairs in a different order than they were originally stored. In
    fact, keys will be traversed in alphabetical order as `std::map` with
    `std::less` is used by default. Please note this behavior conforms to [RFC
    7159](http://rfc7159.net/rfc7159), because any order implements the
    specified "unordered" nature of JSON objects.
    */
    using object_t = ObjectType<StringType,
          basic_json,
          object_comparator_t,
          AllocatorType<std::pair<const StringType,
          basic_json>>>;

    /*!
    @brief a type for an array

    [RFC 7159](http://rfc7159.net/rfc7159) describes JSON arrays as follows:
    > An array is an ordered sequence of zero or more values.

    To store objects in C++, a type is defined by the template parameters
    explained below.

    @tparam ArrayType  container type to store arrays (e.g., `std::vector` or
    `std::list`)
    @tparam AllocatorType allocator to use for arrays (e.g., `std::allocator`)

    #### Default type

    With the default values for @a ArrayType (`std::vector`) and @a
    AllocatorType (`std::allocator`), the default value for @a array_t is:

    @code {.cpp}
    std::vector<
      basic_json, // value_type
      std::allocator<basic_json> // allocator_type
    >
    @endcode

    #### Limits

    [RFC 7159](http://rfc7159.net/rfc7159) specifies:
    > An implementation may set limits on the maximum depth of nesting.

    In this class, the array's limit of nesting is not explicitly constrained.
    However, a maximum depth of nesting may be introduced by the compiler or
    runtime environment. A theoretical limit can be queried by calling the
    @ref max_size function of a JSON array.

    #### Storage

    Arrays are stored as pointers in a @ref basic_json type. That is, for any
    access to array values, a pointer of type `array_t*` must be dereferenced.

    @sa @ref object_t -- type for an object value

    @since version 1.0.0
    */
    using array_t = ArrayType<basic_json, AllocatorType<basic_json>>;

    /*!
    @brief a type for a string

    [RFC 7159](http://rfc7159.net/rfc7159) describes JSON strings as follows:
    > A string is a sequence of zero or more Unicode characters.

    To store objects in C++, a type is defined by the template parameter
    described below. Unicode values are split by the JSON class into
    byte-sized characters during deserialization.

    @tparam StringType  the container to store strings (e.g., `std::string`).
    Note this container is used for keys/names in objects, see @ref object_t.

    #### Default type

    With the default values for @a StringType (`std::string`), the default
    value for @a string_t is:

    @code {.cpp}
    std::string
    @endcode

    #### Encoding

    Strings are stored in UTF-8 encoding. Therefore, functions like
    `std::string::size()` or `std::string::length()` return the number of
    bytes in the string rather than the number of characters or glyphs.

    #### String comparison

    [RFC 7159](http://rfc7159.net/rfc7159) states:
    > Software implementations are typically required to test names of object
    > members for equality. Implementations that transform the textual
    > representation into sequences of Unicode code units and then perform the
    > comparison numerically, code unit by code unit, are interoperable in the
    > sense that implementations will agree in all cases on equality or
    > inequality of two strings. For example, implementations that compare
    > strings with escaped characters unconverted may incorrectly find that
    > `"a\\b"` and `"a\u005Cb"` are not equal.

    This implementation is interoperable as it does compare strings code unit
    by code unit.

    #### Storage

    String values are stored as pointers in a @ref basic_json type. That is,
    for any access to string values, a pointer of type `string_t*` must be
    dereferenced.

    @since version 1.0.0
    */
    using string_t = StringType;

    /*!
    @brief a type for a boolean

    [RFC 7159](http://rfc7159.net/rfc7159) implicitly describes a boolean as a
    type which differentiates the two literals `true` and `false`.

    To store objects in C++, a type is defined by the template parameter @a
    BooleanType which chooses the type to use.

    #### Default type

    With the default values for @a BooleanType (`bool`), the default value for
    @a boolean_t is:

    @code {.cpp}
    bool
    @endcode

    #### Storage

    Boolean values are stored directly inside a @ref basic_json type.

    @since version 1.0.0
    */
    using boolean_t = BooleanType;

    /*!
    @brief a type for a number (integer)

    [RFC 7159](http://rfc7159.net/rfc7159) describes numbers as follows:
    > The representation of numbers is similar to that used in most
    > programming languages. A number is represented in base 10 using decimal
    > digits. It contains an integer component that may be prefixed with an
    > optional minus sign, which may be followed by a fraction part and/or an
    > exponent part. Leading zeros are not allowed. (...) Numeric values that
    > cannot be represented in the grammar below (such as Infinity and NaN)
    > are not permitted.

    This description includes both integer and floating-point numbers.
    However, C++ allows more precise storage if it is known whether the number
    is a signed integer, an unsigned integer or a floating-point number.
    Therefore, three different types, @ref number_integer_t, @ref
    number_unsigned_t and @ref number_float_t are used.

    To store integer numbers in C++, a type is defined by the template
    parameter @a NumberIntegerType which chooses the type to use.

    #### Default type

    With the default values for @a NumberIntegerType (`int64_t`), the default
    value for @a number_integer_t is:

    @code {.cpp}
    int64_t
    @endcode

    #### Default behavior

    - The restrictions about leading zeros is not enforced in C++. Instead,
      leading zeros in integer literals lead to an interpretation as octal
      number. Internally, the value will be stored as decimal number. For
      instance, the C++ integer literal `010` will be serialized to `8`.
      During deserialization, leading zeros yield an error.
    - Not-a-number (NaN) values will be serialized to `null`.

    #### Limits

    [RFC 7159](http://rfc7159.net/rfc7159) specifies:
    > An implementation may set limits on the range and precision of numbers.

    When the default type is used, the maximal integer number that can be
    stored is `9223372036854775807` (INT64_MAX) and the minimal integer number
    that can be stored is `-9223372036854775808` (INT64_MIN). Integer numbers
    that are out of range will yield over/underflow when used in a
    constructor. During deserialization, too large or small integer numbers
    will be automatically be stored as @ref number_unsigned_t or @ref
    number_float_t.

    [RFC 7159](http://rfc7159.net/rfc7159) further states:
    > Note that when such software is used, numbers that are integers and are
    > in the range \f$[-2^{53}+1, 2^{53}-1]\f$ are interoperable in the sense
    > that implementations will agree exactly on their numeric values.

    As this range is a subrange of the exactly supported range [INT64_MIN,
    INT64_MAX], this class's integer type is interoperable.

    #### Storage

    Integer number values are stored directly inside a @ref basic_json type.

    @sa @ref number_float_t -- type for number values (floating-point)

    @sa @ref number_unsigned_t -- type for number values (unsigned integer)

    @since version 1.0.0
    */
    using number_integer_t = NumberIntegerType;

    /*!
    @brief a type for a number (unsigned)

    [RFC 7159](http://rfc7159.net/rfc7159) describes numbers as follows:
    > The representation of numbers is similar to that used in most
    > programming languages. A number is represented in base 10 using decimal
    > digits. It contains an integer component that may be prefixed with an
    > optional minus sign, which may be followed by a fraction part and/or an
    > exponent part. Leading zeros are not allowed. (...) Numeric values that
    > cannot be represented in the grammar below (such as Infinity and NaN)
    > are not permitted.

    This description includes both integer and floating-point numbers.
    However, C++ allows more precise storage if it is known whether the number
    is a signed integer, an unsigned integer or a floating-point number.
    Therefore, three different types, @ref number_integer_t, @ref
    number_unsigned_t and @ref number_float_t are used.

    To store unsigned integer numbers in C++, a type is defined by the
    template parameter @a NumberUnsignedType which chooses the type to use.

    #### Default type

    With the default values for @a NumberUnsignedType (`uint64_t`), the
    default value for @a number_unsigned_t is:

    @code {.cpp}
    uint64_t
    @endcode

    #### Default behavior

    - The restrictions about leading zeros is not enforced in C++. Instead,
      leading zeros in integer literals lead to an interpretation as octal
      number. Internally, the value will be stored as decimal number. For
      instance, the C++ integer literal `010` will be serialized to `8`.
      During deserialization, leading zeros yield an error.
    - Not-a-number (NaN) values will be serialized to `null`.

    #### Limits

    [RFC 7159](http://rfc7159.net/rfc7159) specifies:
    > An implementation may set limits on the range and precision of numbers.

    When the default type is used, the maximal integer number that can be
    stored is `18446744073709551615` (UINT64_MAX) and the minimal integer
    number that can be stored is `0`. Integer numbers that are out of range
    will yield over/underflow when used in a constructor. During
    deserialization, too large or small integer numbers will be automatically
    be stored as @ref number_integer_t or @ref number_float_t.

    [RFC 7159](http://rfc7159.net/rfc7159) further states:
    > Note that when such software is used, numbers that are integers and are
    > in the range \f$[-2^{53}+1, 2^{53}-1]\f$ are interoperable in the sense
    > that implementations will agree exactly on their numeric values.

    As this range is a subrange (when considered in conjunction with the
    number_integer_t type) of the exactly supported range [0, UINT64_MAX],
    this class's integer type is interoperable.

    #### Storage

    Integer number values are stored directly inside a @ref basic_json type.

    @sa @ref number_float_t -- type for number values (floating-point)
    @sa @ref number_integer_t -- type for number values (integer)

    @since version 2.0.0
    */
    using number_unsigned_t = NumberUnsignedType;

    /*!
    @brief a type for a number (floating-point)

    [RFC 7159](http://rfc7159.net/rfc7159) describes numbers as follows:
    > The representation of numbers is similar to that used in most
    > programming languages. A number is represented in base 10 using decimal
    > digits. It contains an integer component that may be prefixed with an
    > optional minus sign, which may be followed by a fraction part and/or an
    > exponent part. Leading zeros are not allowed. (...) Numeric values that
    > cannot be represented in the grammar below (such as Infinity and NaN)
    > are not permitted.

    This description includes both integer and floating-point numbers.
    However, C++ allows more precise storage if it is known whether the number
    is a signed integer, an unsigned integer or a floating-point number.
    Therefore, three different types, @ref number_integer_t, @ref
    number_unsigned_t and @ref number_float_t are used.

    To store floating-point numbers in C++, a type is defined by the template
    parameter @a NumberFloatType which chooses the type to use.

    #### Default type

    With the default values for @a NumberFloatType (`double`), the default
    value for @a number_float_t is:

    @code {.cpp}
    double
    @endcode

    #### Default behavior

    - The restrictions about leading zeros is not enforced in C++. Instead,
      leading zeros in floating-point literals will be ignored. Internally,
      the value will be stored as decimal number. For instance, the C++
      floating-point literal `01.2` will be serialized to `1.2`. During
      deserialization, leading zeros yield an error.
    - Not-a-number (NaN) values will be serialized to `null`.

    #### Limits

    [RFC 7159](http://rfc7159.net/rfc7159) states:
    > This specification allows implementations to set limits on the range and
    > precision of numbers accepted. Since software that implements IEEE
    > 754-2008 binary64 (double precision) numbers is generally available and
    > widely used, good interoperability can be achieved by implementations
    > that expect no more precision or range than these provide, in the sense
    > that implementations will approximate JSON numbers within the expected
    > precision.

    This implementation does exactly follow this approach, as it uses double
    precision floating-point numbers. Note values smaller than
    `-1.79769313486232e+308` and values greater than `1.79769313486232e+308`
    will be stored as NaN internally and be serialized to `null`.

    #### Storage

    Floating-point number values are stored directly inside a @ref basic_json
    type.

    @sa @ref number_integer_t -- type for number values (integer)

    @sa @ref number_unsigned_t -- type for number values (unsigned integer)

    @since version 1.0.0
    */
    using number_float_t = NumberFloatType;

    /// @}

  private:

    /// helper for exception-safe object creation
    template<typename T, typename... Args>
    static T* create(Args&& ... args)
    {
        AllocatorType<T> alloc;
        using AllocatorTraits = std::allocator_traits<AllocatorType<T>>;

        auto deleter = [&](T * object)
        {
            AllocatorTraits::deallocate(alloc, object, 1);
        };
        std::unique_ptr<T, decltype(deleter)> object(AllocatorTraits::allocate(alloc, 1), deleter);
        AllocatorTraits::construct(alloc, object.get(), std::forward<Args>(args)...);
        assert(object != nullptr);
        return object.release();
    }

    ////////////////////////
    // JSON value storage //
    ////////////////////////

    /*!
    @brief a JSON value

    The actual storage for a JSON value of the @ref basic_json class. This
    union combines the different storage types for the JSON value types
    defined in @ref value_t.

    JSON type | value_t type    | used type
    --------- | --------------- | ------------------------
    object    | object          | pointer to @ref object_t
    array     | array           | pointer to @ref array_t
    string    | string          | pointer to @ref string_t
    boolean   | boolean         | @ref boolean_t
    number    | number_integer  | @ref number_integer_t
    number    | number_unsigned | @ref number_unsigned_t
    number    | number_float    | @ref number_float_t
    null      | null            | *no value is stored*

    @note Variable-length types (objects, arrays, and strings) are stored as
    pointers. The size of the union should not exceed 64 bits if the default
    value types are used.

    @since version 1.0.0
    */
    union json_value
    {
        /// object (stored with pointer to save storage)
        object_t* object;
        /// array (stored with pointer to save storage)
        array_t* array;
        /// string (stored with pointer to save storage)
        string_t* string;
        /// boolean
        boolean_t boolean;
        /// number (integer)
        number_integer_t number_integer;
        /// number (unsigned integer)
        number_unsigned_t number_unsigned;
        /// number (floating-point)
        number_float_t number_float;

        /// default constructor (for null values)
        json_value() = default;
        /// constructor for booleans
        json_value(boolean_t v) noexcept : boolean(v) {}
        /// constructor for numbers (integer)
        json_value(number_integer_t v) noexcept : number_integer(v) {}
        /// constructor for numbers (unsigned)
        json_value(number_unsigned_t v) noexcept : number_unsigned(v) {}
        /// constructor for numbers (floating-point)
        json_value(number_float_t v) noexcept : number_float(v) {}
        /// constructor for empty values of a given type
        json_value(value_t t)
        {
            switch (t)
            {
                case value_t::object:
                {
                    object = create<object_t>();
                    break;
                }

                case value_t::array:
                {
                    array = create<array_t>();
                    break;
                }

                case value_t::string:
                {
                    string = create<string_t>("");
                    break;
                }

                case value_t::boolean:
                {
                    boolean = boolean_t(false);
                    break;
                }

                case value_t::number_integer:
                {
                    number_integer = number_integer_t(0);
                    break;
                }

                case value_t::number_unsigned:
                {
                    number_unsigned = number_unsigned_t(0);
                    break;
                }

                case value_t::number_float:
                {
                    number_float = number_float_t(0.0);
                    break;
                }

                case value_t::null:
                {
                    object = nullptr;  // silence warning, see #821
                    break;
                }

                default:
                {
                    object = nullptr;  // silence warning, see #821
                    if (JSON_UNLIKELY(t == value_t::null))
                    {
                        JSON_THROW(other_error::create(500, "961c151d2e87f2686a955a9be24d316f1362bf21 3.6.1")); // LCOV_EXCL_LINE
                    }
                    break;
                }
            }
        }

        /// constructor for strings
        json_value(const string_t& value)
        {
            string = create<string_t>(value);
        }

        /// constructor for rvalue strings
        json_value(string_t&& value)
        {
            string = create<string_t>(std::move(value));
        }

        /// constructor for objects
        json_value(const object_t& value)
        {
            object = create<object_t>(value);
        }

        /// constructor for rvalue objects
        json_value(object_t&& value)
        {
            object = create<object_t>(std::move(value));
        }

        /// constructor for arrays
        json_value(const array_t& value)
        {
            array = create<array_t>(value);
        }

        /// constructor for rvalue arrays
        json_value(array_t&& value)
        {
            array = create<array_t>(std::move(value));
        }

        void destroy(value_t t) noexcept
        {
            switch (t)
            {
                case value_t::object:
                {
                    AllocatorType<object_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, object);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, object, 1);
                    break;
                }

                case value_t::array:
                {
                    AllocatorType<array_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, array);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, array, 1);
                    break;
                }

                case value_t::string:
                {
                    AllocatorType<string_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, string);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, string, 1);
                    break;
                }

                default:
                {
                    break;
                }
            }
        }
    };

    /*!
    @brief checks the class invariants

    This function asserts the class invariants. It needs to be called at the
    end of every constructor to make sure that created objects respect the
    invariant. Furthermore, it has to be called each time the type of a JSON
    value is changed, because the invariant expresses a relationship between
    @a m_type and @a m_value.
    */
    void assert_invariant() const noexcept
    {
        assert(m_type != value_t::object or m_value.object != nullptr);
        assert(m_type != value_t::array or m_value.array != nullptr);
        assert(m_type != value_t::string or m_value.string != nullptr);
    }

  public:
    //////////////////////////
    // JSON parser callback //
    //////////////////////////

    /*!
    @brief parser event types

    The parser callback distinguishes the following events:
    - `object_start`: the parser read `{` and started to process a JSON object
    - `key`: the parser read a key of a value in an object
    - `object_end`: the parser read `}` and finished processing a JSON object
    - `array_start`: the parser read `[` and started to process a JSON array
    - `array_end`: the parser read `]` and finished processing a JSON array
    - `value`: the parser finished reading a JSON value

    @image html callback_events.png "Example when certain parse events are triggered"

    @sa @ref parser_callback_t for more information and examples
    */
    using parse_event_t = typename parser::parse_event_t;

    /*!
    @brief per-element parser callback type

    With a parser callback function, the result of parsing a JSON text can be
    influenced. When passed to @ref parse, it is called on certain events
    (passed as @ref parse_event_t via parameter @a event) with a set recursion
    depth @a depth and context JSON value @a parsed. The return value of the
    callback function is a boolean indicating whether the element that emitted
    the callback shall be kept or not.

    We distinguish six scenarios (determined by the event type) in which the
    callback function can be called. The following table describes the values
    of the parameters @a depth, @a event, and @a parsed.

    parameter @a event | description | parameter @a depth | parameter @a parsed
    ------------------ | ----------- | ------------------ | -------------------
    parse_event_t::object_start | the parser read `{` and started to process a JSON object | depth of the parent of the JSON object | a JSON value with type discarded
    parse_event_t::key | the parser read a key of a value in an object | depth of the currently parsed JSON object | a JSON string containing the key
    parse_event_t::object_end | the parser read `}` and finished processing a JSON object | depth of the parent of the JSON object | the parsed JSON object
    parse_event_t::array_start | the parser read `[` and started to process a JSON array | depth of the parent of the JSON array | a JSON value with type discarded
    parse_event_t::array_end | the parser read `]` and finished processing a JSON array | depth of the parent of the JSON array | the parsed JSON array
    parse_event_t::value | the parser finished reading a JSON value | depth of the value | the parsed JSON value

    @image html callback_events.png "Example when certain parse events are triggered"

    Discarding a value (i.e., returning `false`) has different effects
    depending on the context in which function was called:

    - Discarded values in structured types are skipped. That is, the parser
      will behave as if the discarded value was never read.
    - In case a value outside a structured type is skipped, it is replaced
      with `null`. This case happens if the top-level element is skipped.

    @param[in] depth  the depth of the recursion during parsing

    @param[in] event  an event of type parse_event_t indicating the context in
    the callback function has been called

    @param[in,out] parsed  the current intermediate parse result; note that
    writing to this value has no effect for parse_event_t::key events

    @return Whether the JSON value which called the function during parsing
    should be kept (`true`) or not (`false`). In the latter case, it is either
    skipped completely or replaced by an empty discarded object.

    @sa @ref parse for examples

    @since version 1.0.0
    */
    using parser_callback_t = typename parser::parser_callback_t;

    //////////////////
    // constructors //
    //////////////////

    /// @name constructors and destructors
    /// Constructors of class @ref basic_json, copy/move constructor, copy
    /// assignment, static functions creating objects, and the destructor.
    /// @{

    /*!
    @brief create an empty value with a given type

    Create an empty JSON value with a given type. The value will be default
    initialized with an empty value which depends on the type:

    Value type  | initial value
    ----------- | -------------
    null        | `null`
    boolean     | `false`
    string      | `""`
    number      | `0`
    object      | `{}`
    array       | `[]`

    @param[in] v  the type of the value to create

    @complexity Constant.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @liveexample{The following code shows the constructor for different @ref
    value_t values,basic_json__value_t}

    @sa @ref clear() -- restores the postcondition of this constructor

    @since version 1.0.0
    */
    basic_json(const value_t v)
        : m_type(v), m_value(v)
    {
        assert_invariant();
    }

    /*!
    @brief create a null object

    Create a `null` JSON value. It either takes a null pointer as parameter
    (explicitly creating `null`) or no parameter (implicitly creating `null`).
    The passed null pointer itself is not read -- it is only used to choose
    the right constructor.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this constructor never throws
    exceptions.

    @liveexample{The following code shows the constructor with and without a
    null pointer parameter.,basic_json__nullptr_t}

    @since version 1.0.0
    */
    basic_json(std::nullptr_t = nullptr) noexcept
        : basic_json(value_t::null)
    {
        assert_invariant();
    }

    /*!
    @brief create a JSON value

    This is a "catch all" constructor for all compatible JSON types; that is,
    types for which a `to_json()` method exists. The constructor forwards the
    parameter @a val to that method (to `json_serializer<U>::to_json` method
    with `U = uncvref_t<CompatibleType>`, to be exact).

    Template type @a CompatibleType includes, but is not limited to, the
    following types:
    - **arrays**: @ref array_t and all kinds of compatible containers such as
      `std::vector`, `std::deque`, `std::list`, `std::forward_list`,
      `std::array`, `std::valarray`, `std::set`, `std::unordered_set`,
      `std::multiset`, and `std::unordered_multiset` with a `value_type` from
      which a @ref basic_json value can be constructed.
    - **objects**: @ref object_t and all kinds of compatible associative
      containers such as `std::map`, `std::unordered_map`, `std::multimap`,
      and `std::unordered_multimap` with a `key_type` compatible to
      @ref string_t and a `value_type` from which a @ref basic_json value can
      be constructed.
    - **strings**: @ref string_t, string literals, and all compatible string
      containers can be used.
    - **numbers**: @ref number_integer_t, @ref number_unsigned_t,
      @ref number_float_t, and all convertible number types such as `int`,
      `size_t`, `int64_t`, `float` or `double` can be used.
    - **boolean**: @ref boolean_t / `bool` can be used.

    See the examples below.

    @tparam CompatibleType a type such that:
    - @a CompatibleType is not derived from `std::istream`,
    - @a CompatibleType is not @ref basic_json (to avoid hijacking copy/move
         constructors),
    - @a CompatibleType is not a different @ref basic_json type (i.e. with different template arguments)
    - @a CompatibleType is not a @ref basic_json nested type (e.g.,
         @ref json_pointer, @ref iterator, etc ...)
    - @ref @ref json_serializer<U> has a
         `to_json(basic_json_t&, CompatibleType&&)` method

    @tparam U = `uncvref_t<CompatibleType>`

    @param[in] val the value to be forwarded to the respective constructor

    @complexity Usually linear in the size of the passed @a val, also
                depending on the implementation of the called `to_json()`
                method.

    @exceptionsafety Depends on the called constructor. For types directly
    supported by the library (i.e., all types for which no `to_json()` function
    was provided), strong guarantee holds: if an exception is thrown, there are
    no changes to any JSON value.

    @liveexample{The following code shows the constructor with several
    compatible types.,basic_json__CompatibleType}

    @since version 2.1.0
    */
    template <typename CompatibleType,
              typename U = detail::uncvref_t<CompatibleType>,
              detail::enable_if_t<
                  not detail::is_basic_json<U>::value and detail::is_compatible_type<basic_json_t, U>::value, int> = 0>
    basic_json(CompatibleType && val) noexcept(noexcept(
                JSONSerializer<U>::to_json(std::declval<basic_json_t&>(),
                                           std::forward<CompatibleType>(val))))
    {
        JSONSerializer<U>::to_json(*this, std::forward<CompatibleType>(val));
        assert_invariant();
    }

    /*!
    @brief create a JSON value from an existing one

    This is a constructor for existing @ref basic_json types.
    It does not hijack copy/move constructors, since the parameter has different
    template arguments than the current ones.

    The constructor tries to convert the internal @ref m_value of the parameter.

    @tparam BasicJsonType a type such that:
    - @a BasicJsonType is a @ref basic_json type.
    - @a BasicJsonType has different template arguments than @ref basic_json_t.

    @param[in] val the @ref basic_json value to be converted.

    @complexity Usually linear in the size of the passed @a val, also
                depending on the implementation of the called `to_json()`
                method.

    @exceptionsafety Depends on the called constructor. For types directly
    supported by the library (i.e., all types for which no `to_json()` function
    was provided), strong guarantee holds: if an exception is thrown, there are
    no changes to any JSON value.

    @since version 3.2.0
    */
    template <typename BasicJsonType,
              detail::enable_if_t<
                  detail::is_basic_json<BasicJsonType>::value and not std::is_same<basic_json, BasicJsonType>::value, int> = 0>
    basic_json(const BasicJsonType& val)
    {
        using other_boolean_t = typename BasicJsonType::boolean_t;
        using other_number_float_t = typename BasicJsonType::number_float_t;
        using other_number_integer_t = typename BasicJsonType::number_integer_t;
        using other_number_unsigned_t = typename BasicJsonType::number_unsigned_t;
        using other_string_t = typename BasicJsonType::string_t;
        using other_object_t = typename BasicJsonType::object_t;
        using other_array_t = typename BasicJsonType::array_t;

        switch (val.type())
        {
            case value_t::boolean:
                JSONSerializer<other_boolean_t>::to_json(*this, val.template get<other_boolean_t>());
                break;
            case value_t::number_float:
                JSONSerializer<other_number_float_t>::to_json(*this, val.template get<other_number_float_t>());
                break;
            case value_t::number_integer:
                JSONSerializer<other_number_integer_t>::to_json(*this, val.template get<other_number_integer_t>());
                break;
            case value_t::number_unsigned:
                JSONSerializer<other_number_unsigned_t>::to_json(*this, val.template get<other_number_unsigned_t>());
                break;
            case value_t::string:
                JSONSerializer<other_string_t>::to_json(*this, val.template get_ref<const other_string_t&>());
                break;
            case value_t::object:
                JSONSerializer<other_object_t>::to_json(*this, val.template get_ref<const other_object_t&>());
                break;
            case value_t::array:
                JSONSerializer<other_array_t>::to_json(*this, val.template get_ref<const other_array_t&>());
                break;
            case value_t::null:
                *this = nullptr;
                break;
            case value_t::discarded:
                m_type = value_t::discarded;
                break;
            default:            // LCOV_EXCL_LINE
                assert(false);  // LCOV_EXCL_LINE
        }
        assert_invariant();
    }

    /*!
    @brief create a container (array or object) from an initializer list

    Creates a JSON value of type array or object from the passed initializer
    list @a init. In case @a type_deduction is `true` (default), the type of
    the JSON value to be created is deducted from the initializer list @a init
    according to the following rules:

    1. If the list is empty, an empty JSON object value `{}` is created.
    2. If the list consists of pairs whose first element is a string, a JSON
       object value is created where the first elements of the pairs are
       treated as keys and the second elements are as values.
    3. In all other cases, an array is created.

    The rules aim to create the best fit between a C++ initializer list and
    JSON values. The rationale is as follows:

    1. The empty initializer list is written as `{}` which is exactly an empty
       JSON object.
    2. C++ has no way of describing mapped types other than to list a list of
       pairs. As JSON requires that keys must be of type string, rule 2 is the
       weakest constraint one can pose on initializer lists to interpret them
       as an object.
    3. In all other cases, the initializer list could not be interpreted as
       JSON object type, so interpreting it as JSON array type is safe.

    With the rules described above, the following JSON values cannot be
    expressed by an initializer list:

    - the empty array (`[]`): use @ref array(initializer_list_t)
      with an empty initializer list in this case
    - arrays whose elements satisfy rule 2: use @ref
      array(initializer_list_t) with the same initializer list
      in this case

    @note When used without parentheses around an empty initializer list, @ref
    basic_json() is called instead of this function, yielding the JSON null
    value.

    @param[in] init  initializer list with JSON values

    @param[in] type_deduction internal parameter; when set to `true`, the type
    of the JSON value is deducted from the initializer list @a init; when set
    to `false`, the type provided via @a manual_type is forced. This mode is
    used by the functions @ref array(initializer_list_t) and
    @ref object(initializer_list_t).

    @param[in] manual_type internal parameter; when @a type_deduction is set
    to `false`, the created JSON value will use the provided type (only @ref
    value_t::array and @ref value_t::object are valid); when @a type_deduction
    is set to `true`, this parameter has no effect

    @throw type_error.301 if @a type_deduction is `false`, @a manual_type is
    `value_t::object`, but @a init contains an element which is not a pair
    whose first element is a string. In this case, the constructor could not
    create an object. If @a type_deduction would have be `true`, an array
    would have been created. See @ref object(initializer_list_t)
    for an example.

    @complexity Linear in the size of the initializer list @a init.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @liveexample{The example below shows how JSON values are created from
    initializer lists.,basic_json__list_init_t}

    @sa @ref array(initializer_list_t) -- create a JSON array
    value from an initializer list
    @sa @ref object(initializer_list_t) -- create a JSON object
    value from an initializer list

    @since version 1.0.0
    */
    basic_json(initializer_list_t init,
               bool type_deduction = true,
               value_t manual_type = value_t::array)
    {
        // check if each element is an array with two elements whose first
        // element is a string
        bool is_an_object = std::all_of(init.begin(), init.end(),
                                        [](const detail::json_ref<basic_json>& element_ref)
        {
            return element_ref->is_array() and element_ref->size() == 2 and (*element_ref)[0].is_string();
        });

        // adjust type if type deduction is not wanted
        if (not type_deduction)
        {
            // if array is wanted, do not create an object though possible
            if (manual_type == value_t::array)
            {
                is_an_object = false;
            }

            // if object is wanted but impossible, throw an exception
            if (JSON_UNLIKELY(manual_type == value_t::object and not is_an_object))
            {
                JSON_THROW(type_error::create(301, "cannot create object from initializer list"));
            }
        }

        if (is_an_object)
        {
            // the initializer list is a list of pairs -> create object
            m_type = value_t::object;
            m_value = value_t::object;

            std::for_each(init.begin(), init.end(), [this](const detail::json_ref<basic_json>& element_ref)
            {
                auto element = element_ref.moved_or_copied();
                m_value.object->emplace(
                    std::move(*((*element.m_value.array)[0].m_value.string)),
                    std::move((*element.m_value.array)[1]));
            });
        }
        else
        {
            // the initializer list describes an array -> create array
            m_type = value_t::array;
            m_value.array = create<array_t>(init.begin(), init.end());
        }

        assert_invariant();
    }

    /*!
    @brief explicitly create an array from an initializer list

    Creates a JSON array value from a given initializer list. That is, given a
    list of values `a, b, c`, creates the JSON value `[a, b, c]`. If the
    initializer list is empty, the empty array `[]` is created.

    @note This function is only needed to express two edge cases that cannot
    be realized with the initializer list constructor (@ref
    basic_json(initializer_list_t, bool, value_t)). These cases
    are:
    1. creating an array whose elements are all pairs whose first element is a
    string -- in this case, the initializer list constructor would create an
    object, taking the first elements as keys
    2. creating an empty array -- passing the empty initializer list to the
    initializer list constructor yields an empty object

    @param[in] init  initializer list with JSON values to create an array from
    (optional)

    @return JSON array value

    @complexity Linear in the size of @a init.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @liveexample{The following code shows an example for the `array`
    function.,array}

    @sa @ref basic_json(initializer_list_t, bool, value_t) --
    create a JSON value from an initializer list
    @sa @ref object(initializer_list_t) -- create a JSON object
    value from an initializer list

    @since version 1.0.0
    */
    JSON_NODISCARD
    static basic_json array(initializer_list_t init = {})
    {
        return basic_json(init, false, value_t::array);
    }

    /*!
    @brief explicitly create an object from an initializer list

    Creates a JSON object value from a given initializer list. The initializer
    lists elements must be pairs, and their first elements must be strings. If
    the initializer list is empty, the empty object `{}` is created.

    @note This function is only added for symmetry reasons. In contrast to the
    related function @ref array(initializer_list_t), there are
    no cases which can only be expressed by this function. That is, any
    initializer list @a init can also be passed to the initializer list
    constructor @ref basic_json(initializer_list_t, bool, value_t).

    @param[in] init  initializer list to create an object from (optional)

    @return JSON object value

    @throw type_error.301 if @a init is not a list of pairs whose first
    elements are strings. In this case, no object can be created. When such a
    value is passed to @ref basic_json(initializer_list_t, bool, value_t),
    an array would have been created from the passed initializer list @a init.
    See example below.

    @complexity Linear in the size of @a init.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @liveexample{The following code shows an example for the `object`
    function.,object}

    @sa @ref basic_json(initializer_list_t, bool, value_t) --
    create a JSON value from an initializer list
    @sa @ref array(initializer_list_t) -- create a JSON array
    value from an initializer list

    @since version 1.0.0
    */
    JSON_NODISCARD
    static basic_json object(initializer_list_t init = {})
    {
        return basic_json(init, false, value_t::object);
    }

    /*!
    @brief construct an array with count copies of given value

    Constructs a JSON array value by creating @a cnt copies of a passed value.
    In case @a cnt is `0`, an empty array is created.

    @param[in] cnt  the number of JSON copies of @a val to create
    @param[in] val  the JSON value to copy

    @post `std::distance(begin(),end()) == cnt` holds.

    @complexity Linear in @a cnt.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @liveexample{The following code shows examples for the @ref
    basic_json(size_type\, const basic_json&)
    constructor.,basic_json__size_type_basic_json}

    @since version 1.0.0
    */
    basic_json(size_type cnt, const basic_json& val)
        : m_type(value_t::array)
    {
        m_value.array = create<array_t>(cnt, val);
        assert_invariant();
    }

    /*!
    @brief construct a JSON container given an iterator range

    Constructs the JSON value with the contents of the range `[first, last)`.
    The semantics depends on the different types a JSON value can have:
    - In case of a null type, invalid_iterator.206 is thrown.
    - In case of other primitive types (number, boolean, or string), @a first
      must be `begin()` and @a last must be `end()`. In this case, the value is
      copied. Otherwise, invalid_iterator.204 is thrown.
    - In case of structured types (array, object), the constructor behaves as
      similar versions for `std::vector` or `std::map`; that is, a JSON array
      or object is constructed from the values in the range.

    @tparam InputIT an input iterator type (@ref iterator or @ref
    const_iterator)

    @param[in] first begin of the range to copy from (included)
    @param[in] last end of the range to copy from (excluded)

    @pre Iterators @a first and @a last must be initialized. **This
         precondition is enforced with an assertion (see warning).** If
         assertions are switched off, a violation of this precondition yields
         undefined behavior.

    @pre Range `[first, last)` is valid. Usually, this precondition cannot be
         checked efficiently. Only certain edge cases are detected; see the
         description of the exceptions below. A violation of this precondition
         yields undefined behavior.

    @warning A precondition is enforced with a runtime assertion that will
             result in calling `std::abort` if this precondition is not met.
             Assertions can be disabled by defining `NDEBUG` at compile time.
             See https://en.cppreference.com/w/cpp/error/assert for more
             information.

    @throw invalid_iterator.201 if iterators @a first and @a last are not
    compatible (i.e., do not belong to the same JSON value). In this case,
    the range `[first, last)` is undefined.
    @throw invalid_iterator.204 if iterators @a first and @a last belong to a
    primitive type (number, boolean, or string), but @a first does not point
    to the first element any more. In this case, the range `[first, last)` is
    undefined. See example code below.
    @throw invalid_iterator.206 if iterators @a first and @a last belong to a
    null value. In this case, the range `[first, last)` is undefined.

    @complexity Linear in distance between @a first and @a last.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @liveexample{The example below shows several ways to create JSON values by
    specifying a subrange with iterators.,basic_json__InputIt_InputIt}

    @since version 1.0.0
    */
    template<class InputIT, typename std::enable_if<
                 std::is_same<InputIT, typename basic_json_t::iterator>::value or
                 std::is_same<InputIT, typename basic_json_t::const_iterator>::value, int>::type = 0>
    basic_json(InputIT first, InputIT last)
    {
        assert(first.m_object != nullptr);
        assert(last.m_object != nullptr);

        // make sure iterator fits the current value
        if (JSON_UNLIKELY(first.m_object != last.m_object))
        {
            JSON_THROW(invalid_iterator::create(201, "iterators are not compatible"));
        }

        // copy type from first iterator
        m_type = first.m_object->m_type;

        // check if iterator range is complete for primitive values
        switch (m_type)
        {
            case value_t::boolean:
            case value_t::number_float:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::string:
            {
                if (JSON_UNLIKELY(not first.m_it.primitive_iterator.is_begin()
                                  or not last.m_it.primitive_iterator.is_end()))
                {
                    JSON_THROW(invalid_iterator::create(204, "iterators out of range"));
                }
                break;
            }

            default:
                break;
        }

        switch (m_type)
        {
            case value_t::number_integer:
            {
                m_value.number_integer = first.m_object->m_value.number_integer;
                break;
            }

            case value_t::number_unsigned:
            {
                m_value.number_unsigned = first.m_object->m_value.number_unsigned;
                break;
            }

            case value_t::number_float:
            {
                m_value.number_float = first.m_object->m_value.number_float;
                break;
            }

            case value_t::boolean:
            {
                m_value.boolean = first.m_object->m_value.boolean;
                break;
            }

            case value_t::string:
            {
                m_value = *first.m_object->m_value.string;
                break;
            }

            case value_t::object:
            {
                m_value.object = create<object_t>(first.m_it.object_iterator,
                                                  last.m_it.object_iterator);
                break;
            }

            case value_t::array:
            {
                m_value.array = create<array_t>(first.m_it.array_iterator,
                                                last.m_it.array_iterator);
                break;
            }

            default:
                JSON_THROW(invalid_iterator::create(206, "cannot construct with iterators from " +
                                                    std::string(first.m_object->type_name())));
        }

        assert_invariant();
    }


    ///////////////////////////////////////
    // other constructors and destructor //
    ///////////////////////////////////////

    /// @private
    basic_json(const detail::json_ref<basic_json>& ref)
        : basic_json(ref.moved_or_copied())
    {}

    /*!
    @brief copy constructor

    Creates a copy of a given JSON value.

    @param[in] other  the JSON value to copy

    @post `*this == other`

    @complexity Linear in the size of @a other.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes to any JSON value.

    @requirement This function helps `basic_json` satisfying the
    [Container](https://en.cppreference.com/w/cpp/named_req/Container)
    requirements:
    - The complexity is linear.
    - As postcondition, it holds: `other == basic_json(other)`.

    @liveexample{The following code shows an example for the copy
    constructor.,basic_json__basic_json}

    @since version 1.0.0
    */
    basic_json(const basic_json& other)
        : m_type(other.m_type)
    {
        // check of passed value is valid
        other.assert_invariant();

        switch (m_type)
        {
            case value_t::object:
            {
                m_value = *other.m_value.object;
                break;
            }

            case value_t::array:
            {
                m_value = *other.m_value.array;
                break;
            }

            case value_t::string:
            {
                m_value = *other.m_value.string;
                break;
            }

            case value_t::boolean:
            {
                m_value = other.m_value.boolean;
                break;
            }

            case value_t::number_integer:
            {
                m_value = other.m_value.number_integer;
                break;
            }

            case value_t::number_unsigned:
            {
                m_value = other.m_value.number_unsigned;
                break;
            }

            case value_t::number_float:
            {
                m_value = other.m_value.number_float;
                break;
            }

            default:
                break;
        }

        assert_invariant();
    }

    /*!
    @brief move constructor

    Move constructor. Constructs a JSON value with the contents of the given
    value @a other using move semantics. It "steals" the resources from @a
    other and leaves it as JSON null value.

    @param[in,out] other  value to move to this object

    @post `*this` has the same value as @a other before the call.
    @post @a other is a JSON null value.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this constructor never throws
    exceptions.

    @requirement This function helps `basic_json` satisfying the
    [MoveConstructible](https://en.cppreference.com/w/cpp/named_req/MoveConstructible)
    requirements.

    @liveexample{The code below shows the move constructor explicitly called
    via std::move.,basic_json__moveconstructor}

    @since version 1.0.0
    */
    basic_json(basic_json&& other) noexcept
        : m_type(std::move(other.m_type)),
          m_value(std::move(other.m_value))
    {
        // check that passed value is valid
        other.assert_invariant();

        // invalidate payload
        other.m_type = value_t::null;
        other.m_value = {};

        assert_invariant();
    }

    /*!
    @brief copy assignment

    Copy assignment operator. Copies a JSON value via the "copy and swap"
    strategy: It is expressed in terms of the copy constructor, destructor,
    and the `swap()` member function.

    @param[in] other  value to copy from

    @complexity Linear.

    @requirement This function helps `basic_json` satisfying the
    [Container](https://en.cppreference.com/w/cpp/named_req/Container)
    requirements:
    - The complexity is linear.

    @liveexample{The code below shows and example for the copy assignment. It
    creates a copy of value `a` which is then swapped with `b`. Finally\, the
    copy of `a` (which is the null value after the swap) is
    destroyed.,basic_json__copyassignment}

    @since version 1.0.0
    */
    basic_json& operator=(basic_json other) noexcept (
        std::is_nothrow_move_constructible<value_t>::value and
        std::is_nothrow_move_assignable<value_t>::value and
        std::is_nothrow_move_constructible<json_value>::value and
        std::is_nothrow_move_assignable<json_value>::value
    )
    {
        // check that passed value is valid
        other.assert_invariant();

        using std::swap;
        swap(m_type, other.m_type);
        swap(m_value, other.m_value);

        assert_invariant();
        return *this;
    }

    /*!
    @brief destructor

    Destroys the JSON value and frees all allocated memory.

    @complexity Linear.

    @requirement This function helps `basic_json` satisfying the
    [Container](https://en.cppreference.com/w/cpp/named_req/Container)
    requirements:
    - The complexity is linear.
    - All stored elements are destroyed and all memory is freed.

    @since version 1.0.0
    */
    ~basic_json() noexcept
    {
        assert_invariant();
        m_value.destroy(m_type);
    }

    /// @}

  public:
    ///////////////////////
    // object inspection //
    ///////////////////////

    /// @name object inspection
    /// Functions to inspect the type of a JSON value.
    /// @{

    /*!
    @brief serialization

    Serialization function for JSON values. The function tries to mimic
    Python's `json.dumps()` function, and currently supports its @a indent
    and @a ensure_ascii parameters.

    @param[in] indent If indent is nonnegative, then array elements and object
    members will be pretty-printed with that indent level. An indent level of
    `0` will only insert newlines. `-1` (the default) selects the most compact
    representation.
    @param[in] indent_char The character to use for indentation if @a indent is
    greater than `0`. The default is ` ` (space).
    @param[in] ensure_ascii If @a ensure_ascii is true, all non-ASCII characters
    in the output are escaped with `\uXXXX` sequences, and the result consists
    of ASCII characters only.
    @param[in] error_handler  how to react on decoding errors; there are three
    possible values: `strict` (throws and exception in case a decoding error
    occurs; default), `replace` (replace invalid UTF-8 sequences with U+FFFD),
    and `ignore` (ignore invalid UTF-8 sequences during serialization).

    @return string containing the serialization of the JSON value

    @throw type_error.316 if a string stored inside the JSON value is not
                          UTF-8 encoded

    @complexity Linear.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @liveexample{The following example shows the effect of different @a indent\,
    @a indent_char\, and @a ensure_ascii parameters to the result of the
    serialization.,dump}

    @see https://docs.python.org/2/library/json.html#json.dump

    @since version 1.0.0; indentation character @a indent_char, option
           @a ensure_ascii and exceptions added in version 3.0.0; error
           handlers added in version 3.4.0.
    */
    string_t dump(const int indent = -1,
                  const char indent_char = ' ',
                  const bool ensure_ascii = false,
                  const error_handler_t error_handler = error_handler_t::strict) const
    {
        string_t result;
        serializer s(detail::output_adapter<char, string_t>(result), indent_char, error_handler);

        if (indent >= 0)
        {
            s.dump(*this, true, ensure_ascii, static_cast<unsigned int>(indent));
        }
        else
        {
            s.dump(*this, false, ensure_ascii, 0);
        }

        return result;
    }

    /*!
    @brief return the type of the JSON value (explicit)

    Return the type of the JSON value as a value from the @ref value_t
    enumeration.

    @return the type of the JSON value
            Value type                | return value
            ------------------------- | -------------------------
            null                      | value_t::null
            boolean                   | value_t::boolean
            string                    | value_t::string
            number (integer)          | value_t::number_integer
            number (unsigned integer) | value_t::number_unsigned
            number (floating-point)   | value_t::number_float
            object                    | value_t::object
            array                     | value_t::array
            discarded                 | value_t::discarded

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `type()` for all JSON
    types.,type}

    @sa @ref operator value_t() -- return the type of the JSON value (implicit)
    @sa @ref type_name() -- return the type as string

    @since version 1.0.0
    */
    constexpr value_t type() const noexcept
    {
        return m_type;
    }

    /*!
    @brief return whether type is primitive

    This function returns true if and only if the JSON type is primitive
    (string, number, boolean, or null).

    @return `true` if type is primitive (string, number, boolean, or null),
    `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_primitive()` for all JSON
    types.,is_primitive}

    @sa @ref is_structured() -- returns whether JSON value is structured
    @sa @ref is_null() -- returns whether JSON value is `null`
    @sa @ref is_string() -- returns whether JSON value is a string
    @sa @ref is_boolean() -- returns whether JSON value is a boolean
    @sa @ref is_number() -- returns whether JSON value is a number

    @since version 1.0.0
    */
    constexpr bool is_primitive() const noexcept
    {
        return is_null() or is_string() or is_boolean() or is_number();
    }

    /*!
    @brief return whether type is structured

    This function returns true if and only if the JSON type is structured
    (array or object).

    @return `true` if type is structured (array or object), `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_structured()` for all JSON
    types.,is_structured}

    @sa @ref is_primitive() -- returns whether value is primitive
    @sa @ref is_array() -- returns whether value is an array
    @sa @ref is_object() -- returns whether value is an object

    @since version 1.0.0
    */
    constexpr bool is_structured() const noexcept
    {
        return is_array() or is_object();
    }

    /*!
    @brief return whether value is null

    This function returns true if and only if the JSON value is null.

    @return `true` if type is null, `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_null()` for all JSON
    types.,is_null}

    @since version 1.0.0
    */
    constexpr bool is_null() const noexcept
    {
        return m_type == value_t::null;
    }

    /*!
    @brief return whether value is a boolean

    This function returns true if and only if the JSON value is a boolean.

    @return `true` if type is boolean, `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_boolean()` for all JSON
    types.,is_boolean}

    @since version 1.0.0
    */
    constexpr bool is_boolean() const noexcept
    {
        return m_type == value_t::boolean;
    }

    /*!
    @brief return whether value is a number

    This function returns true if and only if the JSON value is a number. This
    includes both integer (signed and unsigned) and floating-point values.

    @return `true` if type is number (regardless whether integer, unsigned
    integer or floating-type), `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_number()` for all JSON
    types.,is_number}

    @sa @ref is_number_integer() -- check if value is an integer or unsigned
    integer number
    @sa @ref is_number_unsigned() -- check if value is an unsigned integer
    number
    @sa @ref is_number_float() -- check if value is a floating-point number

    @since version 1.0.0
    */
    constexpr bool is_number() const noexcept
    {
        return is_number_integer() or is_number_float();
    }

    /*!
    @brief return whether value is an integer number

    This function returns true if and only if the JSON value is a signed or
    unsigned integer number. This excludes floating-point values.

    @return `true` if type is an integer or unsigned integer number, `false`
    otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_number_integer()` for all
    JSON types.,is_number_integer}

    @sa @ref is_number() -- check if value is a number
    @sa @ref is_number_unsigned() -- check if value is an unsigned integer
    number
    @sa @ref is_number_float() -- check if value is a floating-point number

    @since version 1.0.0
    */
    constexpr bool is_number_integer() const noexcept
    {
        return m_type == value_t::number_integer or m_type == value_t::number_unsigned;
    }

    /*!
    @brief return whether value is an unsigned integer number

    This function returns true if and only if the JSON value is an unsigned
    integer number. This excludes floating-point and signed integer values.

    @return `true` if type is an unsigned integer number, `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_number_unsigned()` for all
    JSON types.,is_number_unsigned}

    @sa @ref is_number() -- check if value is a number
    @sa @ref is_number_integer() -- check if value is an integer or unsigned
    integer number
    @sa @ref is_number_float() -- check if value is a floating-point number

    @since version 2.0.0
    */
    constexpr bool is_number_unsigned() const noexcept
    {
        return m_type == value_t::number_unsigned;
    }

    /*!
    @brief return whether value is a floating-point number

    This function returns true if and only if the JSON value is a
    floating-point number. This excludes signed and unsigned integer values.

    @return `true` if type is a floating-point number, `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_number_float()` for all
    JSON types.,is_number_float}

    @sa @ref is_number() -- check if value is number
    @sa @ref is_number_integer() -- check if value is an integer number
    @sa @ref is_number_unsigned() -- check if value is an unsigned integer
    number

    @since version 1.0.0
    */
    constexpr bool is_number_float() const noexcept
    {
        return m_type == value_t::number_float;
    }

    /*!
    @brief return whether value is an object

    This function returns true if and only if the JSON value is an object.

    @return `true` if type is object, `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_object()` for all JSON
    types.,is_object}

    @since version 1.0.0
    */
    constexpr bool is_object() const noexcept
    {
        return m_type == value_t::object;
    }

    /*!
    @brief return whether value is an array

    This function returns true if and only if the JSON value is an array.

    @return `true` if type is array, `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_array()` for all JSON
    types.,is_array}

    @since version 1.0.0
    */
    constexpr bool is_array() const noexcept
    {
        return m_type == value_t::array;
    }

    /*!
    @brief return whether value is a string

    This function returns true if and only if the JSON value is a string.

    @return `true` if type is string, `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_string()` for all JSON
    types.,is_string}

    @since version 1.0.0
    */
    constexpr bool is_string() const noexcept
    {
        return m_type == value_t::string;
    }

    /*!
    @brief return whether value is discarded

    This function returns true if and only if the JSON value was discarded
    during parsing with a callback function (see @ref parser_callback_t).

    @note This function will always be `false` for JSON values after parsing.
    That is, discarded values can only occur during parsing, but will be
    removed when inside a structured value or replaced by null in other cases.

    @return `true` if type is discarded, `false` otherwise.

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies `is_discarded()` for all JSON
    types.,is_discarded}

    @since version 1.0.0
    */
    constexpr bool is_discarded() const noexcept
    {
        return m_type == value_t::discarded;
    }

    /*!
    @brief return the type of the JSON value (implicit)

    Implicitly return the type of the JSON value as a value from the @ref
    value_t enumeration.

    @return the type of the JSON value

    @complexity Constant.

    @exceptionsafety No-throw guarantee: this member function never throws
    exceptions.

    @liveexample{The following code exemplifies the @ref value_t operator for
    all JSON types.,operator__value_t}

    @sa @ref type() -- return the type of the JSON value (explicit)
    @sa @ref type_name() -- return the type as string

    @since version 1.0.0
    */
    constexpr operator value_t() const noexcept
    {
        return m_type;
    }

    /// @}

  private:
    //////////////////
    // value access //
    //////////////////

    /// get a boolean (explicit)
    boolean_t get_impl(boolean_t* /*unused*/) const
    {
        if (JSON_LIKELY(is_boolean()))
        {
            return m_value.boolean;
        }

        JSON_THROW(type_error::create(302, "type must be boolean, but is " + std::string(type_name())));
    }

    /// get a pointer to the value (object)
    object_t* get_impl_ptr(object_t* /*unused*/) noexcept
    {
        return is_object() ? m_value.object : nullptr;
    }

    /// get a pointer to the value (object)
    constexpr const object_t* get_impl_ptr(const object_t* /*unused*/) const noexcept
    {
        return is_object() ? m_value.object : nullptr;
    }

    /// get a pointer to the value (array)
    array_t* get_impl_ptr(array_t* /*unused*/) noexcept
    {
        return is_array() ? m_value.array : nullptr;
    }

    /// get a pointer to the value (array)
    constexpr const array_t* get_impl_ptr(const array_t* /*unused*/) const noexcept
    {
        return is_array() ? m_value.array : nullptr;
    }

    /// get a pointer to the value (string)
    string_t* get_impl_ptr(string_t* /*unused*/) noexcept
    {
        return is_string() ? m_value.string : nullptr;
    }

    /// get a pointer to the value (string)
    constexpr const string_t* get_impl_ptr(const string_t* /*unused*/) const noexcept
    {
        return is_string() ? m_value.string : nullptr;
    }

    /// get a pointer to the value (boolean)
    boolean_t* get_impl_ptr(boolean_t* /*unused*/) noexcept
    {
        return is_boolean() ? &m_value.boolean : nullptr;
    }

    /// get a pointer to the value (boolean)
    constexpr const boolean_t* get_impl_ptr(const boolean_t* /*unused*/) const noexcept
    {
        return is_boolean() ? &m_value.boolean : nullptr;
    }

    /// get a pointer to the value (integer number)
    number_integer_t* get_impl_ptr(number_integer_t* /*unused*/) noexcept
    {
        return is_number_integer() ? &m_value.number_integer : nullptr;
    }

    /// get a pointer to the value (integer number)
    constexpr const number_integer_t* get_impl_ptr(const number_integer_t* /*unused*/) const noexcept
    {
        return is_number_integer() ? &m_value.number_integer : nullptr;
    }

    /// get a pointer to the value (unsigned number)
    number_unsigned_t* get_impl_ptr(number_unsigned_t* /*unused*/) noexcept
    {
        return is_number_unsigned() ? &m_value.number_unsigned : nullptr;
    }

    /// get a pointer to the value (unsigned number)
    constexpr const number_unsigned_t* get_impl_ptr(const number_unsigned_t* /*unused*/) const noexcept
    {
        return is_number_unsigned() ? &m_value.number_unsigned : nullptr;
    }

    /// get a pointer to the value (floating-point number)
    number_float_t* get_impl_ptr(number_float_t* /*unused*/) noexcept
    {
        return is_number_float() ? &m_value.number_float : nullptr;
    }

    /// get a pointer to the value (floating-point number)
    constexpr const number_float_t* get_impl_ptr(const number_float_t* /*unused*/) const noexcept
    {
        return is_number_float() ? &m_value.number_float : nullptr;
    }

    /*!
    @brief helper function to implement get_ref()

    This function helps to implement get_ref() without code duplication for
    const and non-const overloads

    @tparam ThisType will be deduced as `basic_json` or `const basic_json`

    @throw type_error.303 if ReferenceType does not match underlying value
    type of the current JSON
    */
    template<typename ReferenceType, typename ThisType>
    static ReferenceType get_ref_impl(ThisType& obj)
    {
        // delegate the call to get_ptr<>()
        auto ptr = obj.template get_ptr<typename std::add_pointer<ReferenceType>::type>();

        if (JSON_LIKELY(ptr != nullptr))
        {
            return *ptr;
        }

        JSON_THROW(type_error::create(303, "incompatible ReferenceType for get_ref, actual type is " + std::string(obj.type_name())));
    }

  public:
    /// @name value access
    /// Direct access to the stored value of a JSON value.
    /// @{

    /*!
    @brief get special-case overload

    This overloads avoids a lot of template boilerplate, it can be seen as the
    identity method

    @tparam BasicJsonType == @ref basic_json

    @return a copy of *this

    @complexity Constant.

    @since version 2.1.0
    */
    template<typename BasicJsonType, detail::enable_if_t<
                 std::is_same<typename std::remove_const<BasicJsonType>::type, basic_json_t>::value,
                 int> = 0>
    basic_json get() const
    {
        return *this;
    }

    /*!
    @brief get special-case overload

    This overloads converts the current @ref basic_json in a different
    @ref basic_json type

    @tparam BasicJsonType == @ref basic_json

    @return a copy of *this, converted into @tparam BasicJsonType

    @complexity Depending on the implementation of the called `from_json()`
                method.

    @since version 3.2.0
    */
    template<typename BasicJsonType, detail::enable_if_t<
                 not std::is_same<BasicJsonType, basic_json>::value and
                 detail::is_basic_json<BasicJsonType>::value, int> = 0>
    BasicJsonType get() const
    {
        return *this;
    }

    /*!
    @brief get a value (explicit)

    Explicit type conversion between the JSON value and a compatible value
    which is [CopyConstructible](https://en.cppreference.com/w/cpp/named_req/CopyConstructible)
    and [DefaultConstructible](https://en.cppreference.com/w/cpp/named_req/DefaultConstructible).
    The value is converted by calling the @ref json_serializer<ValueType>
    `from_json()` method.

    The function is equivalent to executing
    @code {.cpp}
    ValueType ret;
    JSONSerializer<ValueType>::from_json(*this, ret);
    return ret;
    @endcode

    This overloads is chosen if:
    - @a ValueType is not @ref basic_json,
    - @ref json_serializer<ValueType> has a `from_json()` method of the form
      `void from_json(const basic_json&, ValueType&)`, and
    - @ref json_serializer<ValueType> does not have a `from_json()` method of
      the form `ValueType from_json(const basic_json&)`

    @tparam ValueTypeCV the provided value type
    @tparam ValueType the returned value type

    @return copy of the JSON value, converted to @a ValueType

    @throw what @ref json_serializer<ValueType> `from_json()` method throws

    @liveexample{The example below shows several conversions from JSON values
    to other types. There a few things to note: (1) Floating-point numbers can
    be converted to integers\, (2) A JSON array can be converted to a standard
    `std::vector<short>`\, (3) A JSON object can be converted to C++
    associative containers such as `std::unordered_map<std::string\,
    json>`.,get__ValueType_const}

    @since version 2.1.0
    */
    template<typename ValueTypeCV, typename ValueType = detail::uncvref_t<ValueTypeCV>,
             detail::enable_if_t <
                 not detail::is_basic_json<ValueType>::value and
                 detail::has_from_json<basic_json_t, ValueType>::value and
                 not detail::has_non_default_from_json<basic_json_t, ValueType>::value,
                 int> = 0>
    ValueType get() const noexcept(noexcept(
                                       JSONSerializer<ValueType>::from_json(std::declval<const basic_json_t&>(), std::declval<ValueType&>())))
    {
        // we cannot static_assert on ValueTypeCV being non-const, because
        // there is support for get<const basic_json_t>(), which is why we
        // still need the uncvref
        static_assert(not std::is_reference<ValueTypeCV>::value,
                      "get() cannot be used with reference types, you might want to use get_ref()");
        static_assert(std::is_default_constructible<ValueType>::value,
                      "types must be DefaultConstructible when used with get()");

        ValueType ret;
        JSONSerializer<ValueType>::from_json(*this, ret);
        return ret;
    }

    /*!
    @brief get a value (explicit); special case

    Explicit type conversion between the JSON value and a compatible value
    which is **not** [CopyConstructible](https://en.cppreference.com/w/cpp/named_req/CopyConstructible)
    and **not** [DefaultConstructible](https://en.cppreference.com/w/cpp/named_req/DefaultConstructible).
    The value is converted by calling the @ref json_serializer<ValueType>
    `from_json()` method.

    The function is equivalent to executing
    @code {.cpp}
    return JSONSerializer<ValueTypeCV>::from_json(*this);
    @endcode

    This overloads is chosen if:
    - @a ValueType is not @ref basic_json and
    - @ref json_serializer<ValueType> has a `from_json()` method of the form
      `ValueType from_json(const basic_json&)`

    @note If @ref json_serializer<ValueType> has both overloads of
    `from_json()`, this one is chosen.

    @tparam ValueTypeCV the provided value type
    @tparam ValueType the returned value type

    @return copy of the JSON value, converted to @a ValueType

    @throw what @ref json_serializer<ValueType> `from_json()` method throws

    @since version 2.1.0
    */
    template<typename ValueTypeCV, typename ValueType = detail::uncvref_t<ValueTypeCV>,
             detail::enable_if_t<not std::is_same<basic_json_t, ValueType>::value and
                                 detail::has_non_default_from_json<basic_json_t, ValueType>::value,
                                 int> = 0>
    ValueType get() const noexcept(noexcept(
                                       JSONSerializer<ValueTypeCV>::from_json(std::declval<const basic_json_t&>())))
    {
        static_assert(not std::is_reference<ValueTypeCV>::value,
                      "get() cannot be used with reference types, you might want to use get_ref()");
        return JSONSerializer<ValueTypeCV>::from_json(*this);
    }

    /*!
    @brief get a value (explicit)

    Explicit type conversion between the JSON value and a compatible value.
    The value is filled into the input parameter by calling the @ref json_serializer<ValueType>
    `from_json()` method.

    The function is equivalent to executing
    @code {.cpp}
    ValueType v;
    JSONSerializer<ValueType>::from_json(*this, v);
    @endcode

    This overloads is chosen if:
    - @a ValueType is not @ref basic_json,
    - @ref json_serializer<ValueType> has a `from_json()` method of the form
      `void from_json(const basic_json&, ValueType&)`, and

    @tparam ValueType the input parameter type.

    @return the input parameter, allowing chaining calls.

    @throw what @ref json_serializer<ValueType> `from_json()` method throws

    @liveexample{The example below shows several conversions from JSON values
    to other types. There a few things to note: (1) Floating-point numbers can
    be converted to integers\, (2) A JSON array can be converted to a standard
    `std::vector<short>`\, (3) A JSON object can be converted to C++
    associative containers such as `std::unordered_map<std::string\,
    json>`.,get_to}

    @since version 3.3.0
    */
    template<typename ValueType,
             detail::enable_if_t <
                 not detail::is_basic_json<ValueType>::value and
                 detail::has_from_json<basic_json_t, ValueType>::value,
                 int> = 0>
    ValueType & get_to(ValueType& v) const noexcept(noexcept(
                JSONSerializer<ValueType>::from_json(std::declval<const basic_json_t&>(), v)))
    {
        JSONSerializer<ValueType>::from_json(*this, v);
        return v;
    }


    /*!
    @brief get a pointer value (implicit)

    Implicit pointer access to the internally stored JSON value. No copies are
    made.

    @warning Writing data to the pointee of the result yields an undefined
    state.

    @tparam PointerType pointer type; must be a pointer to @ref array_t, @ref
    object_t, @ref string_t, @ref boolean_t, @ref number_integer_t,
    @ref number_unsigned_t, or @ref number_float_t. Enforced by a static
    assertion.

    @return pointer to the internally stored JSON value if the requested
    pointer type @a PointerType fits to the JSON value; `nullptr` otherwise

    @complexity Constant.

    @liveexample{The example below shows how pointers to internal values of a
    JSON value can be requested. Note that no type conversions are made and a
    `nullptr` is returned if the value and the requested pointer type does not
    match.,get_ptr}

    @since version 1.0.0
    */
    template<typename PointerType, typename std::enable_if<
                 std::is_pointer<PointerType>::value, int>::type = 0>
    auto get_ptr() noexcept -> decltype(std::declval<basic_json_t&>().get_impl_ptr(std::declval<PointerType>()))
    {
        // delegate the call to get_impl_ptr<>()
        return get_impl_ptr(static_cast<PointerType>(nullptr));
    }

    /*!
    @brief get a pointer value (implicit)
    @copydoc get_ptr()
    */
    template<typename PointerType, typename std::enable_if<
                 std::is_pointer<PointerType>::value and
                 std::is_const<typename std::remove_pointer<PointerType>::type>::value, int>::type = 0>
    constexpr auto get_ptr() const noexcept -> decltype(std::declval<const basic_json_t&>().get_impl_ptr(std::declval<PointerType>()))
    {
        // delegate the call to get_impl_ptr<>() const
        return get_impl_ptr(static_cast<PointerType>(nullptr));
    }

    /*!
    @brief get a pointer value (explicit)

    Explicit pointer access to the internally stored JSON value. No copies are
    made.

    @warning The pointer becomes invalid if the underlying JSON object
    changes.

    @tparam PointerType pointer type; must be a pointer to @ref array_t, @ref
    object_t, @ref string_t, @ref boolean_t, @ref number_integer_t,
    @ref number_unsigned_t, or @ref number_float_t.

    @return pointer to the internally stored JSON value if the requested
    pointer type @a PointerType fits to the JSON value; `nullptr` otherwise

    @complexity Constant.

    @liveexample{The example below shows how pointers to internal values of a
    JSON value can be requested. Note that no type conversions are made and a
    `nullptr` is returned if the value and the requested pointer type does not
    match.,get__PointerType}

    @sa @ref get_ptr() for explicit pointer-member access

    @since version 1.0.0
    */
    template<typename PointerType, typename std::enable_if<
                 std::is_pointer<PointerType>::value, int>::type = 0>
    auto get() noexcept -> decltype(std::declval<basic_json_t&>().template get_ptr<PointerType>())
    {
        // delegate the call to get_ptr
        return get_ptr<PointerType>();
    }

    /*!
    @brief get a pointer value (explicit)
    @copydoc get()
    */
    template<typename PointerType, typename std::enable_if<
                 std::is_pointer<PointerType>::value, int>::type = 0>
    constexpr auto get() const noexcept -> decltype(std::declval<const basic_json_t&>().template get_ptr<PointerType>())
    {
        // delegate the call to get_ptr
        return get_ptr<PointerType>();
    }

    /*!
    @brief get a reference value (implicit)

    Implicit reference access to the internally stored JSON value. No copies
    are made.

    @warning Writing data to the referee of the result yields an undefined
    state.

    @tparam ReferenceType reference type; must be a reference to @ref array_t,
    @ref object_t, @ref string_t, @ref boolean_t, @ref number_integer_t, or
    @ref number_float_t. Enforced by static assertion.

    @return reference to the internally stored JSON value if the requested
    reference type @a ReferenceType fits to the JSON value; throws
    type_error.303 otherwise

    @throw type_error.303 in case passed type @a ReferenceType is incompatible
    with the stored JSON value; see example below

    @complexity Constant.

    @liveexample{The example shows several calls to `get_ref()`.,get_ref}

    @since version 1.1.0
    */
    template<typename ReferenceType, typename std::enable_if<
                 std::is_reference<ReferenceType>::value, int>::type = 0>
    ReferenceType get_ref()
    {
        // delegate call to get_ref_impl
        return get_ref_impl<ReferenceType>(*this);
    }

    /*!
    @brief get a reference value (implicit)
    @copydoc get_ref()
    */
    template<typename ReferenceType, typename std::enable_if<
                 std::is_reference<ReferenceType>::value and
                 std::is_const<typename std::remove_reference<ReferenceType>::type>::value, int>::type = 0>
    ReferenceType get_ref() const
    {
        // delegate call to get_ref_impl
        return get_ref_impl<ReferenceType>(*this);
    }

    /*!
    @brief get a value (implicit)

    Implicit type conversion between the JSON value and a compatible value.
    The call is realized by calling @ref get() const.

    @tparam ValueType non-pointer type compatible to the JSON value, for
    instance `int` for JSON integer numbers, `bool` for JSON booleans, or
    `std::vector` types for JSON arrays. The character type of @ref string_t
    as well as an initializer list of this type is excluded to avoid
    ambiguities as these types implicitly convert to `std::string`.

    @return copy of the JSON value, converted to type @a ValueType

    @throw type_error.302 in case passed type @a ValueType is incompatible
    to the JSON value type (e.g., the JSON value is of type boolean, but a
    string is requested); see example below

    @complexity Linear in the size of the JSON value.

    @liveexample{The example below shows several conversions from JSON values
    to other types. There a few things to note: (1) Floating-point numbers can
    be converted to integers\, (2) A JSON array can be converted to a standard
    `std::vector<short>`\, (3) A JSON object can be converted to C++
    associative containers such as `std::unordered_map<std::string\,
    json>`.,operator__ValueType}

    @since version 1.0.0
    */
    template < typename ValueType, typename std::enable_if <
                   not std::is_pointer<ValueType>::value and
                   not std::is_same<ValueType, detail::json_ref<basic_json>>::value and
                   not std::is_same<ValueType, typename string_t::value_type>::value and
                   not detail::is_basic_json<ValueType>::value

#ifndef _MSC_VER  // fix for issue #167 operator<< ambiguity under VS2015
                   and not std::is_same<ValueType, std::initializer_list<typename string_t::value_type>>::value
#if defined(JSON_HAS_CPP_17) && (defined(__GNUC__) || (defined(_MSC_VER) and _MSC_VER <= 1914))
                   and not std::is_same<ValueType, typename std::string_view>::value
#endif
#endif
                   and detail::is_detected<detail::get_template_function, const basic_json_t&, ValueType>::value
                   , int >::type = 0 >
    operator ValueType() const
    {
        // delegate the call to get<>() const
        return get<ValueType>();
    }

    /// @}


    ////////////////////
    // element access //
    ////////////////////

    /// @name element access
    /// Access to the JSON value.
    /// @{

    /*!
    @brief access specified array element with bounds checking

    Returns a reference to the element at specified location @a idx, with
    bounds checking.

    @param[in] idx  index of the element to access

    @return reference to the element at index @a idx

    @throw type_error.304 if the JSON value is not an array; in this case,
    calling `at` with an index makes no sense. See example below.
    @throw out_of_range.401 if the index @a idx is out of range of the array;
    that is, `idx >= size()`. See example below.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @complexity Constant.

    @since version 1.0.0

    @liveexample{The example below shows how array elements can be read and
    written using `at()`. It also demonstrates the different exceptions that
    can be thrown.,at__size_type}
    */
    reference at(size_type idx)
    {
        // at only works for arrays
        if (JSON_LIKELY(is_array()))
        {
            JSON_TRY
            {
                return m_value.array->at(idx);
            }
            JSON_CATCH (std::out_of_range&)
            {
                // create better exception explanation
                JSON_THROW(out_of_range::create(401, "array index " + std::to_string(idx) + " is out of range"));
            }
        }
        else
        {
            JSON_THROW(type_error::create(304, "cannot use at() with " + std::string(type_name())));
        }
    }

    /*!
    @brief access specified array element with bounds checking

    Returns a const reference to the element at specified location @a idx,
    with bounds checking.

    @param[in] idx  index of the element to access

    @return const reference to the element at index @a idx

    @throw type_error.304 if the JSON value is not an array; in this case,
    calling `at` with an index makes no sense. See example below.
    @throw out_of_range.401 if the index @a idx is out of range of the array;
    that is, `idx >= size()`. See example below.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @complexity Constant.

    @since version 1.0.0

    @liveexample{The example below shows how array elements can be read using
    `at()`. It also demonstrates the different exceptions that can be thrown.,
    at__size_type_const}
    */
    const_reference at(size_type idx) const
    {
        // at only works for arrays
        if (JSON_LIKELY(is_array()))
        {
            JSON_TRY
            {
                return m_value.array->at(idx);
            }
            JSON_CATCH (std::out_of_range&)
            {
                // create better exception explanation
                JSON_THROW(out_of_range::create(401, "array index " + std::to_string(idx) + " is out of range"));
            }
        }
        else
        {
            JSON_THROW(type_error::create(304, "cannot use at() with " + std::string(type_name())));
        }
    }

    /*!
    @brief access specified object element with bounds checking

    Returns a reference to the element at with specified key @a key, with
    bounds checking.

    @param[in] key  key of the element to access

    @return reference to the element at key @a key

    @throw type_error.304 if the JSON value is not an object; in this case,
    calling `at` with a key makes no sense. See example below.
    @throw out_of_range.403 if the key @a key is is not stored in the object;
    that is, `find(key) == end()`. See example below.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @complexity Logarithmic in the size of the container.

    @sa @ref operator[](const typename object_t::key_type&) for unchecked
    access by reference
    @sa @ref value() for access by value with a default value

    @since version 1.0.0

    @liveexample{The example below shows how object elements can be read and
    written using `at()`. It also demonstrates the different exceptions that
    can be thrown.,at__object_t_key_type}
    */
    reference at(const typename object_t::key_type& key)
    {
        // at only works for objects
        if (JSON_LIKELY(is_object()))
        {
            JSON_TRY
            {
                return m_value.object->at(key);
            }
            JSON_CATCH (std::out_of_range&)
            {
                // create better exception explanation
                JSON_THROW(out_of_range::create(403, "key '" + key + "' not found"));
            }
        }
        else
        {
            JSON_THROW(type_error::create(304, "cannot use at() with " + std::string(type_name())));
        }
    }

    /*!
    @brief access specified object element with bounds checking

    Returns a const reference to the element at with specified key @a key,
    with bounds checking.

    @param[in] key  key of the element to access

    @return const reference to the element at key @a key

    @throw type_error.304 if the JSON value is not an object; in this case,
    calling `at` with a key makes no sense. See example below.
    @throw out_of_range.403 if the key @a key is is not stored in the object;
    that is, `find(key) == end()`. See example below.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @complexity Logarithmic in the size of the container.

    @sa @ref operator[](const typename object_t::key_type&) for unchecked
    access by reference
    @sa @ref value() for access by value with a default value

    @since version 1.0.0

    @liveexample{The example below shows how object elements can be read using
    `at()`. It also demonstrates the different exceptions that can be thrown.,
    at__object_t_key_type_const}
    */
    const_reference at(const typename object_t::key_type& key) const
    {
        // at only works for objects
        if (JSON_LIKELY(is_object()))
        {
            JSON_TRY
            {
                return m_value.object->at(key);
            }
            JSON_CATCH (std::out_of_range&)
            {
                // create better exception explanation
                JSON_THROW(out_of_range::create(403, "key '" + key + "' not found"));
            }
        }
        else
        {
            JSON_THROW(type_error::create(304, "cannot use at() with " + std::string(type_name())));
        }
    }

    /*!
    @brief access specified array element

    Returns a reference to the element at specified location @a idx.

    @note If @a idx is beyond the range of the array (i.e., `idx >= size()`),
    then the array is silently filled up with `null` values to make `idx` a
    valid reference to the last stored element.

    @param[in] idx  index of the element to access

    @return reference to the element at index @a idx

    @throw type_error.305 if the JSON value is not an array or null; in that
    cases, using the [] operator with an index makes no sense.

    @complexity Constant if @a idx is in the range of the array. Otherwise
    linear in `idx - size()`.

    @liveexample{The example below shows how array elements can be read and
    written using `[]` operator. Note the addition of `null`
    values.,operatorarray__size_type}

    @since version 1.0.0
    */
    reference operator[](size_type idx)
    {
        // implicitly convert null value to an empty array
        if (is_null())
        {
            m_type = value_t::array;
            m_value.array = create<array_t>();
            assert_invariant();
        }

        // operator[] only works for arrays
        if (JSON_LIKELY(is_array()))
        {
            // fill up array with null values if given idx is outside range
            if (idx >= m_value.array->size())
            {
                m_value.array->insert(m_value.array->end(),
                                      idx - m_value.array->size() + 1,
                                      basic_json());
            }

            return m_value.array->operator[](idx);
        }

        JSON_THROW(type_error::create(305, "cannot use operator[] with a numeric argument with " + std::string(type_name())));
    }

    /*!
    @brief access specified array element

    Returns a const reference to the element at specified location @a idx.

    @param[in] idx  index of the element to access

    @return const reference to the element at index @a idx

    @throw type_error.305 if the JSON value is not an array; in that case,
    using the [] operator with an index makes no sense.

    @complexity Constant.

    @liveexample{The example below shows how array elements can be read using
    the `[]` operator.,operatorarray__size_type_const}

    @since version 1.0.0
    */
    const_reference operator[](size_type idx) const
    {
        // const operator[] only works for arrays
        if (JSON_LIKELY(is_array()))
        {
            return m_value.array->operator[](idx);
        }

        JSON_THROW(type_error::create(305, "cannot use operator[] with a numeric argument with " + std::string(type_name())));
    }

    /*!
    @brief access specified object element

    Returns a reference to the element at with specified key @a key.

    @note If @a key is not found in the object, then it is silently added to
    the object and filled with a `null` value to make `key` a valid reference.
    In case the value was `null` before, it is converted to an object.

    @param[in] key  key of the element to access

    @return reference to the element at key @a key

    @throw type_error.305 if the JSON value is not an object or null; in that
    cases, using the [] operator with a key makes no sense.

    @complexity Logarithmic in the size of the container.

    @liveexample{The example below shows how object elements can be read and
    written using the `[]` operator.,operatorarray__key_type}

    @sa @ref at(const typename object_t::key_type&) for access by reference
    with range checking
    @sa @ref value() for access by value with a default value

    @since version 1.0.0
    */
    reference operator[](const typename object_t::key_type& key)
    {
        // implicitly convert null value to an empty object
        if (is_null())
        {
            m_type = value_t::object;
            m_value.object = create<object_t>();
            assert_invariant();
        }

        // operator[] only works for objects
        if (JSON_LIKELY(is_object()))
        {
            return m_value.object->operator[](key);
        }

        JSON_THROW(type_error::create(305, "cannot use operator[] with a string argument with " + std::string(type_name())));
    }

    /*!
    @brief read-only access specified object element

    Returns a const reference to the element at with specified key @a key. No
    bounds checking is performed.

    @warning If the element with key @a key does not exist, the behavior is
    undefined.

    @param[in] key  key of the element to access

    @return const reference to the element at key @a key

    @pre The element with key @a key must exist. **This precondition is
         enforced with an assertion.**

    @throw type_error.305 if the JSON value is not an object; in that case,
    using the [] operator with a key makes no sense.

    @complexity Logarithmic in the size of the container.

    @liveexample{The example below shows how object elements can be read using
    the `[]` operator.,operatorarray__key_type_const}

    @sa @ref at(const typename object_t::key_type&) for access by reference
    with range checking
    @sa @ref value() for access by value with a default value

    @since version 1.0.0
    */
    const_reference operator[](const typename object_t::key_type& key) const
    {
        // const operator[] only works for objects
        if (JSON_LIKELY(is_object()))
        {
            assert(m_value.object->find(key) != m_value.object->end());
            return m_value.object->find(key)->second;
        }

        JSON_THROW(type_error::create(305, "cannot use operator[] with a string argument with " + std::string(type_name())));
    }

    /*!
    @brief access specified object element

    Returns a reference to the element at with specified key @a key.

    @note If @a key is not found in the object, then it is silently added to
    the object and filled with a `null` value to make `key` a valid reference.
    In case the value was `null` before, it is converted to an object.

    @param[in] key  key of the element to access

    @return reference to the element at key @a key

    @throw type_error.305 if the JSON value is not an object or null; in that
    cases, using the [] operator with a key makes no sense.

    @complexity Logarithmic in the size of the container.

    @liveexample{The example below shows how object elements can be read and
    written using the `[]` operator.,operatorarray__key_type}

    @sa @ref at(const typename object_t::key_type&) for access by reference
    with range checking
    @sa @ref value() for access by value with a default value

    @since version 1.1.0
    */
    template<typename T>
    reference operator[](T* key)
    {
        // implicitly convert null to object
        if (is_null())
        {
            m_type = value_t::object;
            m_value = value_t::object;
            assert_invariant();
        }

        // at only works for objects
        if (JSON_LIKELY(is_object()))
        {
            return m_value.object->operator[](key);
        }

        JSON_THROW(type_error::create(305, "cannot use operator[] with a string argument with " + std::string(type_name())));
    }

    /*!
    @brief read-only access specified object element

    Returns a const reference to the element at with specified key @a key. No
    bounds checking is performed.

    @warning If the element with key @a key does not exist, the behavior is
    undefined.

    @param[in] key  key of the element to access

    @return const reference to the element at key @a key

    @pre The element with key @a key must exist. **This precondition is
         enforced with an assertion.**

    @throw type_error.305 if the JSON value is not an object; in that case,
    using the [] operator with a key makes no sense.

    @complexity Logarithmic in the size of the container.

    @liveexample{The example below shows how object elements can be read using
    the `[]` operator.,operatorarray__key_type_const}

    @sa @ref at(const typename object_t::key_type&) for access by reference
    with range checking
    @sa @ref value() for access by value with a default value

    @since version 1.1.0
    */
    template<typename T>
    const_reference operator[](T* key) const
    {
        // at only works for objects
        if (JSON_LIKELY(is_object()))
        {
            assert(m_value.object->find(key) != m_value.object->end());
            return m_value.object->find(key)->second;
        }

        JSON_THROW(type_error::create(305, "cannot use operator[] with a string argument with " + std::string(type_name())));
    }

    /*!
    @brief access specified object element with default value

    Returns either a copy of an object's element at the specified key @a key
    or a given default value if no element with key @a key exists.

    The function is basically equivalent to executing
    @code {.cpp}
    try {
        return at(key);
    } catch(out_of_range) {
        return default_value;
    }
    @endcode

    @note Unlike @ref at(const typename object_t::key_type&), this function
    does not throw if the given key @a key was not found.

    @note Unlike @ref operator[](const typename object_t::key_type& key), this
    function does not implicitly add an element to the position defined by @a
    key. This function is furthermore also applicable to const objects.

    @param[in] key  key of the element to access
    @param[in] default_value  the value to return if @a key is not found

    @tparam ValueType type compatible to JSON values, for instance `int` for
    JSON integer numbers, `bool` for JSON booleans, or `std::vector` types for
    JSON arrays. Note the type of the expected value at @a key and the default
    value @a default_value must be compatible.

    @return copy of the element at key @a key or @a default_value if @a key
    is not found

    @throw type_error.306 if the JSON value is not an object; in that case,
    using `value()` with a key makes no sense.

    @complexity Logarithmic in the size of the container.

    @liveexample{The example below shows how object elements can be queried
    with a default value.,basic_json__value}

    @sa @ref at(const typename object_t::key_type&) for access by reference
    with range checking
    @sa @ref operator[](const typename object_t::key_type&) for unchecked
    access by reference

    @since version 1.0.0
    */
    template<class ValueType, typename std::enable_if<
                 std::is_convertible<basic_json_t, ValueType>::value, int>::type = 0>
    ValueType value(const typename object_t::key_type& key, const ValueType& default_value) const
    {
        // at only works for objects
        if (JSON_LIKELY(is_object()))
        {
            // if key is found, return value and given default value otherwise
            const auto it = find(key);
            if (it != end())
            {
                return *it;
            }

            return default_value;
        }

        JSON_THROW(type_error::create(306, "cannot use value() with " + std::string(type_name())));
    }

    /*!
    @brief overload for a default value of type const char*
    @copydoc basic_json::value(const typename object_t::key_type&, const ValueType&) const
    */
    string_t value(const typename object_t::key_type& key, const char* default_value) const
    {
        return value(key, string_t(default_value));
    }

    /*!
    @brief access specified object element via JSON Pointer with default value

    Returns either a copy of an object's element at the specified key @a key
    or a given default value if no element with key @a key exists.

    The function is basically equivalent to executing
    @code {.cpp}
    try {
        return at(ptr);
    } catch(out_of_range) {
        return default_value;
    }
    @endcode

    @note Unlike @ref at(const json_pointer&), this function does not throw
    if the given key @a key was not found.

    @param[in] ptr  a JSON pointer to the element to access
    @param[in] default_value  the value to return if @a ptr found no value

    @tparam ValueType type compatible to JSON values, for instance `int` for
    JSON integer numbers, `bool` for JSON booleans, or `std::vector` types for
    JSON arrays. Note the type of the expected value at @a key and the default
    value @a default_value must be compatible.

    @return copy of the element at key @a key or @a default_value if @a key
    is not found

    @throw type_error.306 if the JSON value is not an object; in that case,
    using `value()` with a key makes no sense.

    @complexity Logarithmic in the size of the container.

    @liveexample{The example below shows how object elements can be queried
    with a default value.,basic_json__value_ptr}

    @sa @ref operator[](const json_pointer&) for unchecked access by reference

    @since version 2.0.2
    */
    template<class ValueType, typename std::enable_if<
                 std::is_convertible<basic_json_t, ValueType>::value, int>::type = 0>
    ValueType value(const json_pointer& ptr, const ValueType& default_value) const
    {
        // at only works for objects
        if (JSON_LIKELY(is_object()))
        {
            // if pointer resolves a value, return it or use default value
            JSON_TRY
            {
                return ptr.get_checked(this);
            }
            JSON_INTERNAL_CATCH (out_of_range&)
            {
                return default_value;
            }
        }

        JSON_THROW(type_error::create(306, "cannot use value() with " + std::string(type_name())));
    }

    /*!
    @brief overload for a default value of type const char*
    @copydoc basic_json::value(const json_pointer&, ValueType) const
    */
    string_t value(const json_pointer& ptr, const char* default_value) const
    {
        return value(ptr, string_t(default_value));
    }

    /*!
    @brief access the first element

    Returns a reference to the first element in the container. For a JSON
    container `c`, the expression `c.front()` is equivalent to `*c.begin()`.

    @return In case of a structured type (array or object), a reference to the
    first element is returned. In case of number, string, or boolean values, a
    reference to the value is returned.

    @complexity Constant.

    @pre The JSON value must not be `null` (would throw `std::out_of_range`)
    or an empty array or object (undefined behavior, **guarded by
    assertions**).
    @post The JSON value remains unchanged.

    @throw invalid_iterator.214 when called on `null` value

    @liveexample{The following code shows an example for `front()`.,front}

    @sa @ref back() -- access the last element

    @since version 1.0.0
    */
    reference front()
    {
        return *begin();
    }

    /*!
    @copydoc basic_json::front()
    */
    const_reference front() const
    {
        return *cbegin();
    }

    /*!
    @brief access the last element

    Returns a reference to the last element in the container. For a JSON
    container `c`, the expression `c.back()` is equivalent to
    @code {.cpp}
    auto tmp = c.end();
    --tmp;
    return *tmp;
    @endcode

    @return In case of a structured type (array or object), a reference to the
    last element is returned. In case of number, string, or boolean values, a
    reference to the value is returned.

    @complexity Constant.

    @pre The JSON value must not be `null` (would throw `std::out_of_range`)
    or an empty array or object (undefined behavior, **guarded by
    assertions**).
    @post The JSON value remains unchanged.

    @throw invalid_iterator.214 when called on a `null` value. See example
    below.

    @liveexample{The following code shows an example for `back()`.,back}

    @sa @ref front() -- access the first element

    @since version 1.0.0
    */
    reference back()
    {
        auto tmp = end();
        --tmp;
        return *tmp;
    }

    /*!
    @copydoc basic_json::back()
    */
    const_reference back() const
    {
        auto tmp = cend();
        --tmp;
        return *tmp;
    }

    /*!
    @brief remove element given an iterator

    Removes the element specified by iterator @a pos. The iterator @a pos must
    be valid and dereferenceable. Thus the `end()` iterator (which is valid,
    but is not dereferenceable) cannot be used as a value for @a pos.

    If called on a primitive type other than `null`, the resulting JSON value
    will be `null`.

    @param[in] pos iterator to the element to remove
    @return Iterator following the last removed element. If the iterator @a
    pos refers to the last element, the `end()` iterator is returned.

    @tparam IteratorType an @ref iterator or @ref const_iterator

    @post Invalidates iterators and references at or after the point of the
    erase, including the `end()` iterator.

    @throw type_error.307 if called on a `null` value; example: `"cannot use
    erase() with null"`
    @throw invalid_iterator.202 if called on an iterator which does not belong
    to the current JSON value; example: `"iterator does not fit current
    value"`
    @throw invalid_iterator.205 if called on a primitive type with invalid
    iterator (i.e., any iterator which is not `begin()`); example: `"iterator
    out of range"`

    @complexity The complexity depends on the type:
    - objects: amortized constant
    - arrays: linear in distance between @a pos and the end of the container
    - strings: linear in the length of the string
    - other types: constant

    @liveexample{The example shows the result of `erase()` for different JSON
    types.,erase__IteratorType}

    @sa @ref erase(IteratorType, IteratorType) -- removes the elements in
    the given range
    @sa @ref erase(const typename object_t::key_type&) -- removes the element
    from an object at the given key
    @sa @ref erase(const size_type) -- removes the element from an array at
    the given index

    @since version 1.0.0
    */
    template<class IteratorType, typename std::enable_if<
                 std::is_same<IteratorType, typename basic_json_t::iterator>::value or
                 std::is_same<IteratorType, typename basic_json_t::const_iterator>::value, int>::type
             = 0>
    IteratorType erase(IteratorType pos)
    {
        // make sure iterator fits the current value
        if (JSON_UNLIKELY(this != pos.m_object))
        {
            JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value"));
        }

        IteratorType result = end();

        switch (m_type)
        {
            case value_t::boolean:
            case value_t::number_float:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::string:
            {
                if (JSON_UNLIKELY(not pos.m_it.primitive_iterator.is_begin()))
                {
                    JSON_THROW(invalid_iterator::create(205, "iterator out of range"));
                }

                if (is_string())
                {
                    AllocatorType<string_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, m_value.string);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, m_value.string, 1);
                    m_value.string = nullptr;
                }

                m_type = value_t::null;
                assert_invariant();
                break;
            }

            case value_t::object:
            {
                result.m_it.object_iterator = m_value.object->erase(pos.m_it.object_iterator);
                break;
            }

            case value_t::array:
            {
                result.m_it.array_iterator = m_value.array->erase(pos.m_it.array_iterator);
                break;
            }

            default:
                JSON_THROW(type_error::create(307, "cannot use erase() with " + std::string(type_name())));
        }

        return result;
    }

    /*!
    @brief remove elements given an iterator range

    Removes the element specified by the range `[first; last)`. The iterator
    @a first does not need to be dereferenceable if `first == last`: erasing
    an empty range is a no-op.

    If called on a primitive type other than `null`, the resulting JSON value
    will be `null`.

    @param[in] first iterator to the beginning of the range to remove
    @param[in] last iterator past the end of the range to remove
    @return Iterator following the last removed element. If the iterator @a
    second refers to the last element, the `end()` iterator is returned.

    @tparam IteratorType an @ref iterator or @ref const_iterator

    @post Invalidates iterators and references at or after the point of the
    erase, including the `end()` iterator.

    @throw type_error.307 if called on a `null` value; example: `"cannot use
    erase() with null"`
    @throw invalid_iterator.203 if called on iterators which does not belong
    to the current JSON value; example: `"iterators do not fit current value"`
    @throw invalid_iterator.204 if called on a primitive type with invalid
    iterators (i.e., if `first != begin()` and `last != end()`); example:
    `"iterators out of range"`

    @complexity The complexity depends on the type:
    - objects: `log(size()) + std::distance(first, last)`
    - arrays: linear in the distance between @a first and @a last, plus linear
      in the distance between @a last and end of the container
    - strings: linear in the length of the string
    - other types: constant

    @liveexample{The example shows the result of `erase()` for different JSON
    types.,erase__IteratorType_IteratorType}

    @sa @ref erase(IteratorType) -- removes the element at a given position
    @sa @ref erase(const typename object_t::key_type&) -- removes the element
    from an object at the given key
    @sa @ref erase(const size_type) -- removes the element from an array at
    the given index

    @since version 1.0.0
    */
    template<class IteratorType, typename std::enable_if<
                 std::is_same<IteratorType, typename basic_json_t::iterator>::value or
                 std::is_same<IteratorType, typename basic_json_t::const_iterator>::value, int>::type
             = 0>
    IteratorType erase(IteratorType first, IteratorType last)
    {
        // make sure iterator fits the current value
        if (JSON_UNLIKELY(this != first.m_object or this != last.m_object))
        {
            JSON_THROW(invalid_iterator::create(203, "iterators do not fit current value"));
        }

        IteratorType result = end();

        switch (m_type)
        {
            case value_t::boolean:
            case value_t::number_float:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::string:
            {
                if (JSON_LIKELY(not first.m_it.primitive_iterator.is_begin()
                                or not last.m_it.primitive_iterator.is_end()))
                {
                    JSON_THROW(invalid_iterator::create(204, "iterators out of range"));
                }

                if (is_string())
                {
                    AllocatorType<string_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, m_value.string);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, m_value.string, 1);
                    m_value.string = nullptr;
                }

                m_type = value_t::null;
                assert_invariant();
                break;
            }

            case value_t::object:
            {
                result.m_it.object_iterator = m_value.object->erase(first.m_it.object_iterator,
                                              last.m_it.object_iterator);
                break;
            }

            case value_t::array:
            {
                result.m_it.array_iterator = m_value.array->erase(first.m_it.array_iterator,
                                             last.m_it.array_iterator);
                break;
            }

            default:
                JSON_THROW(type_error::create(307, "cannot use erase() with " + std::string(type_name())));
        }

        return result;
    }

    /*!
    @brief remove element from a JSON object given a key

    Removes elements from a JSON object with the key value @a key.

    @param[in] key value of the elements to remove

    @return Number of elements removed. If @a ObjectType is the default
    `std::map` type, the return value will always be `0` (@a key was not
    found) or `1` (@a key was found).

    @post References and iterators to the erased elements are invalidated.
    Other references and iterators are not affected.

    @throw type_error.307 when called on a type other than JSON object;
    example: `"cannot use erase() with null"`

    @complexity `log(size()) + count(key)`

    @liveexample{The example shows the effect of `erase()`.,erase__key_type}

    @sa @ref erase(IteratorType) -- removes the element at a given position
    @sa @ref erase(IteratorType, IteratorType) -- removes the elements in
    the given range
    @sa @ref erase(const size_type) -- removes the element from an array at
    the given index

    @since version 1.0.0
    */
    size_type erase(const typename object_t::key_type& key)
    {
        // this erase only works for objects
        if (JSON_LIKELY(is_object()))
        {
            return m_value.object->erase(key);
        }

        JSON_THROW(type_error::create(307, "cannot use erase() with " + std::string(type_name())));
    }

    /*!
    @brief remove element from a JSON array given an index

    Removes element from a JSON array at the index @a idx.

    @param[in] idx index of the element to remove

    @throw type_error.307 when called on a type other than JSON object;
    example: `"cannot use erase() with null"`
    @throw out_of_range.401 when `idx >= size()`; example: `"array index 17
    is out of range"`

    @complexity Linear in distance between @a idx and the end of the container.

    @liveexample{The example shows the effect of `erase()`.,erase__size_type}

    @sa @ref erase(IteratorType) -- removes the element at a given position
    @sa @ref erase(IteratorType, IteratorType) -- removes the elements in
    the given range
    @sa @ref erase(const typename object_t::key_type&) -- removes the element
    from an object at the given key

    @since version 1.0.0
    */
    void erase(const size_type idx)
    {
        // this erase only works for arrays
        if (JSON_LIKELY(is_array()))
        {
            if (JSON_UNLIKELY(idx >= size()))
            {
                JSON_THROW(out_of_range::create(401, "array index " + std::to_string(idx) + " is out of range"));
            }

            m_value.array->erase(m_value.array->begin() + static_cast<difference_type>(idx));
        }
        else
        {
            JSON_THROW(type_error::create(307, "cannot use erase() with " + std::string(type_name())));
        }
    }

    /// @}


    ////////////
    // lookup //
    ////////////

    /// @name lookup
    /// @{

    /*!
    @brief find an element in a JSON object

    Finds an element in a JSON object with key equivalent to @a key. If the
    element is not found or the JSON value is not an object, end() is
    returned.

    @note This method always returns @ref end() when executed on a JSON type
          that is not an object.

    @param[in] key key value of the element to search for.

    @return Iterator to an element with key equivalent to @a key. If no such
    element is found or the JSON value is not an object, past-the-end (see
    @ref end()) iterator is returned.

    @complexity Logarithmic in the size of the JSON object.

    @liveexample{The example shows how `find()` is used.,find__key_type}

    @sa @ref contains(KeyT&&) const -- checks whether a key exists

    @since version 1.0.0
    */
    template<typename KeyT>
    iterator find(KeyT&& key)
    {
        auto result = end();

        if (is_object())
        {
            result.m_it.object_iterator = m_value.object->find(std::forward<KeyT>(key));
        }

        return result;
    }

    /*!
    @brief find an element in a JSON object
    @copydoc find(KeyT&&)
    */
    template<typename KeyT>
    const_iterator find(KeyT&& key) const
    {
        auto result = cend();

        if (is_object())
        {
            result.m_it.object_iterator = m_value.object->find(std::forward<KeyT>(key));
        }

        return result;
    }

    /*!
    @brief returns the number of occurrences of a key in a JSON object

    Returns the number of elements with key @a key. If ObjectType is the
    default `std::map` type, the return value will always be `0` (@a key was
    not found) or `1` (@a key was found).

    @note This method always returns `0` when executed on a JSON type that is
          not an object.

    @param[in] key key value of the element to count

    @return Number of elements with key @a key. If the JSON value is not an
    object, the return value will be `0`.

    @complexity Logarithmic in the size of the JSON object.

    @liveexample{The example shows how `count()` is used.,count}

    @since version 1.0.0
    */
    template<typename KeyT>
    size_type count(KeyT&& key) const
    {
        // return 0 for all nonobject types
        return is_object() ? m_value.object->count(std::forward<KeyT>(key)) : 0;
    }

    /*!
    @brief check the existence of an element in a JSON object

    Check whether an element exists in a JSON object with key equivalent to
    @a key. If the element is not found or the JSON value is not an object,
    false is returned.

    @note This method always returns false when executed on a JSON type
          that is not an object.

    @param[in] key key value to check its existence.

    @return true if an element with specified @a key exists. If no such
    element with such key is found or the JSON value is not an object,
    false is returned.

    @complexity Logarithmic in the size of the JSON object.

    @liveexample{The following code shows an example for `contains()`.,contains}

    @sa @ref find(KeyT&&) -- returns an iterator to an object element

    @since version 3.6.0
    */
    template<typename KeyT>
    bool contains(KeyT&& key) const
    {
        return is_object() and m_value.object->find(std::forward<KeyT>(key)) != m_value.object->end();
    }

    /// @}


    ///////////////
    // iterators //
    ///////////////

    /// @name iterators
    /// @{

    /*!
    @brief returns an iterator to the first element

    Returns an iterator to the first element.

    @image html range-begin-end.svg "Illustration from cppreference.com"

    @return iterator to the first element

    @complexity Constant.

    @requirement This function helps `basic_json` satisfying the
    [Container](https://en.cppreference.com/w/cpp/named_req/Container)
    requirements:
    - The complexity is constant.

    @liveexample{The following code shows an example for `begin()`.,begin}

    @sa @ref cbegin() -- returns a const iterator to the beginning
    @sa @ref end() -- returns an iterator to the end
    @sa @ref cend() -- returns a const iterator to the end

    @since version 1.0.0
    */
    iterator begin() noexcept
    {
        iterator result(this);
        result.set_begin();
        return result;
    }

    /*!
    @copydoc basic_json::cbegin()
    */
    const_iterator begin() const noexcept
    {
        return cbegin();
    }

    /*!
    @brief returns a const iterator to the first element

    Returns a const iterator to the first element.

    @image html range-begin-end.svg "Illustration from cppreference.com"

    @return const iterator to the first element

    @complexity Constant.

    @requirement This function helps `basic_json` satisfying the
    [Container](https://en.cppreference.com/w/cpp/named_req/Container)
    requirements:
    - The complexity is constant.
    - Has the semantics of `const_cast<const basic_json&>(*this).begin()`.

    @liveexample{The following code shows an example for `cbegin()`.,cbegin}

    @sa @ref begin() -- returns an iterator to the beginning
    @sa @ref end() -- returns an iterator to the end
    @sa @ref cend() -- returns a const iterator to the end

    @since version 1.0.0
    */
    const_iterator cbegin() const noexcept
    {
        const_iterator result(this);
        result.set_begin();
        return result;
    }

    /*!
    @brief returns an iterator to one past the last element

    Returns an iterator to one past the last element.

    @image html range-begin-end.svg "Illustration from cppreference.com"

    @return iterator one past the last element

    @complexity Constant.

    @requirement This function helps `basic_json` satisfying the
    [Container](https://en.cppreference.com/w/cpp/named_req/Container)
    requirements:
    - The complexity is constant.

    @liveexample{The following code shows an example for `end()`.,end}

    @sa @ref cend() -- returns a const iterator to the end
    @sa @ref begin() -- returns an iterator to the beginning
    @sa @ref cbegin() -- returns a const iterator to the beginning

    @since version 1.0.0
    */
    iterator end() noexcept
    {
        iterator result(this);
        result.set_end();
        return result;
    }

    /*!
    @copydoc basic_json::cend()
    */
    const_iterator end() const noexcept
    {
        return cend();
    }

    /*!
    @brief returns a const iterator to one past the last element

    Returns a const iterator to one past the last element.

    @image html range-begin-end.svg "Illustration from cppreference.com"

    @return const iterator one past the last element

    @complexity Constant.

    @requirement This function helps `basic_json` satisfying the
    [Container](https://en.cppreference.com/w/cpp/named_req/Container)
    requirements:
    - The complexity is constant.
    - Has the semantics of `const_cast<const basic_json&>(*this).end()`.

    @liveexample{The following code shows an example for `cend()`.,cend}

    @sa @ref end() -- returns an iterator to the end
    @sa @ref begin() -- returns an iterator to the beginning
    @sa @ref cbegin() -- returns a const iterator to the beginning

    @since version 1.0.0
    */
    const_iterator cend() const noexcept
    {
        const_iterator result(this);
        result.set_end();
        return result;
    }

    /*!
    @brief returns an iterator to the reverse-beginning

    Returns an iterator to the reverse-beginning; that is, the last element.

    @image html range-rbegin-rend.svg "Illustration from cppreference.com"

    @complexity Constant.

    @requirement This function helps `basic_json` satisfying the
    [ReversibleContainer](https://en.cppreference.com/w/cpp/named_req/ReversibleContainer)
    requirements:
    - The complexity is constant.
    - Has the semantics of `reverse_iterator(end())`.

    @liveexample{The following code shows an example for `rbegin()`.,rbegin}

    @sa @ref crbegin() -- returns a const reverse iterator to the beginning
    @sa @ref rend() -- returns a reverse iterator to the end
    @sa @ref crend() -- returns a const reverse iterator to the end

    @since version 1.0.0
    */
    reverse_iterator rbegin() noexcept
    {
        return reverse_iterator(end());
    }

    /*!
    @copydoc basic_json::crbegin()
    */
    const_reverse_iterator rbegin() const noexcept
    {
        return crbegin();
    }

    /*!
    @brief returns an iterator to the reverse-end

    Returns an iterator to the reverse-end; that is, one before the first
    element.

    @image html range-rbegin-rend.svg "Illustration from cppreference.com"

    @complexity Constant.

    @requirement This function helps `basic_json` satisfying the
    [ReversibleContainer](https://en.cppreference.com/w/cpp/named_req/ReversibleContainer)
    requirements:
    - The complexity is constant.
    - Has the semantics of `reverse_iterator(begin())`.

    @liveexample{The following code shows an example for `rend()`.,rend}

    @sa @ref crend() -- returns a const reverse iterator to the end
    @sa @ref rbegin() -- returns a reverse iterator to the beginning
    @sa @ref crbegin() -- returns a const reverse iterator to the beginning

    @since version 1.0.0
    */
    reverse_iterator rend() noexcept
    {
        return reverse_iterator(begin());
    }

    /*!
    @copydoc basic_json::crend()
    */
    const_reverse_iterator rend() const noexcept
    {
        return crend();
    }

    /*!
    @brief returns a const reverse iterator to the last element

    Returns a const iterator to the reverse-beginning; that is, the last
    element.

    @image html range-rbegin-rend.svg "Illustration from cppreference.com"

    @complexity Constant.

    @requirement This function helps `basic_json` satisfying the
    [ReversibleContainer](https://en.cppreference.com/w/cpp/named_req/ReversibleContainer)
    requirements:
    - The complexity is constant.
    - Has the semantics of `const_cast<const basic_json&>(*this).rbegin()`.

    @liveexample{The following code shows an example for `crbegin()`.,crbegin}

    @sa @ref rbegin() -- returns a reverse iterator to the beginning
    @sa @ref rend() -- returns a reverse iterator to the end
    @sa @ref crend() -- returns a const reverse iterator to the end

    @since version 1.0.0
    */
    const_reverse_iterator crbegin() const noexcept
    {
        return const_reverse_iterator(cend());
    }

    /*!
    @brief returns a const reverse iterator to one before the first

    Returns a const reverse iterator to the reverse-end; that is, one before
    the first element.

    @image html range-rbegin-rend.svg "Illustration from cppreference.com"

    @complexity Constant.

    @requirement This function helps `basic_json` satisfying the
    [ReversibleContainer](https://en.cppreference.com/w/cpp/named_req/ReversibleContainer)
    requirements:
    - The complexity is constant.
    - Has the semantics of `const_cast<const basic_json&>(*this).rend()`.

    @liveexample{The following code shows an example for `crend()`.,crend}

    @sa @ref rend() -- returns a reverse iterator to the end
    @sa @ref rbegin() -- returns a reverse iterator to the beginning
    @sa @ref crbegin() -- returns a const reverse iterator to the beginning

    @since version 1.0.0
    */
    const_reverse_iterator crend() const noexcept
    {
        return const_reverse_iterator(cbegin());
    }

  public:
    /*!
    @brief wrapper to access iterator member functions in range-based for

    This function allows to access @ref iterator::key() and @ref
    iterator::value() during range-based for loops. In these loops, a
    reference to the JSON values is returned, so there is no access to the
    underlying iterator.

    For loop without iterator_wrapper:

    @code{cpp}
    for (auto it = j_object.begin(); it != j_object.end(); ++it)
    {
        std::cout << "key: " << it.key() << ", value:" << it.value() << '\n';
    }
    @endcode

    Range-based for loop without iterator proxy:

    @code{cpp}
    for (auto it : j_object)
    {
        // "it" is of type json::reference and has no key() member
        std::cout << "value: " << it << '\n';
    }
    @endcode

    Range-based for loop with iterator proxy:

    @code{cpp}
    for (auto it : json::iterator_wrapper(j_object))
    {
        std::cout << "key: " << it.key() << ", value:" << it.value() << '\n';
    }
    @endcode

    @note When iterating over an array, `key()` will return the index of the
          element as string (see example).

    @param[in] ref  reference to a JSON value
    @return iteration proxy object wrapping @a ref with an interface to use in
            range-based for loops

    @liveexample{The following code shows how the wrapper is used,iterator_wrapper}

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @complexity Constant.

    @note The name of this function is not yet final and may change in the
    future.

    @deprecated This stream operator is deprecated and will be removed in
                future 4.0.0 of the library. Please use @ref items() instead;
                that is, replace `json::iterator_wrapper(j)` with `j.items()`.
    */
    JSON_DEPRECATED
    static iteration_proxy<iterator> iterator_wrapper(reference ref) noexcept
    {
        return ref.items();
    }

    /*!
    @copydoc iterator_wrapper(reference)
    */
    JSON_DEPRECATED
    static iteration_proxy<const_iterator> iterator_wrapper(const_reference ref) noexcept
    {
        return ref.items();
    }

    /*!
    @brief helper to access iterator member functions in range-based for

    This function allows to access @ref iterator::key() and @ref
    iterator::value() during range-based for loops. In these loops, a
    reference to the JSON values is returned, so there is no access to the
    underlying iterator.

    For loop without `items()` function:

    @code{cpp}
    for (auto it = j_object.begin(); it != j_object.end(); ++it)
    {
        std::cout << "key: " << it.key() << ", value:" << it.value() << '\n';
    }
    @endcode

    Range-based for loop without `items()` function:

    @code{cpp}
    for (auto it : j_object)
    {
        // "it" is of type json::reference and has no key() member
        std::cout << "value: " << it << '\n';
    }
    @endcode

    Range-based for loop with `items()` function:

    @code{cpp}
    for (auto& el : j_object.items())
    {
        std::cout << "key: " << el.key() << ", value:" << el.value() << '\n';
    }
    @endcode

    The `items()` function also allows to use
    [structured bindings](https://en.cppreference.com/w/cpp/language/structured_binding)
    (C++17):

    @code{cpp}
    for (auto& [key, val] : j_object.items())
    {
        std::cout << "key: " << key << ", value:" << val << '\n';
    }
    @endcode

    @note When iterating over an array, `key()` will return the index of the
          element as string (see example). For primitive types (e.g., numbers),
          `key()` returns an empty string.

    @return iteration proxy object wrapping @a ref with an interface to use in
            range-based for loops

    @liveexample{The following code shows how the function is used.,items}

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @complexity Constant.

    @since version 3.1.0, structured bindings support since 3.5.0.
    */
    iteration_proxy<iterator> items() noexcept
    {
        return iteration_proxy<iterator>(*this);
    }

    /*!
    @copydoc items()
    */
    iteration_proxy<const_iterator> items() const noexcept
    {
        return iteration_proxy<const_iterator>(*this);
    }

    /// @}


    //////////////
    // capacity //
    //////////////

    /// @name capacity
    /// @{

    /*!
    @brief checks whether the container is empty.

    Checks if a JSON value has no elements (i.e. whether its @ref size is `0`).

    @return The return value depends on the different types and is
            defined as follows:
            Value type  | return value
            ----------- | -------------
            null        | `true`
            boolean     | `false`
            string      | `false`
            number      | `false`
            object      | result of function `object_t::empty()`
            array       | result of function `array_t::empty()`

    @liveexample{The following code uses `empty()` to check if a JSON
    object contains any elements.,empty}

    @complexity Constant, as long as @ref array_t and @ref object_t satisfy
    the Container concept; that is, their `empty()` functions have constant
    complexity.

    @iterators No changes.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @note This function does not return whether a string stored as JSON value
    is empty - it returns whether the JSON container itself is empty which is
    false in the case of a string.

    @requirement This function helps `basic_json` satisfying the
    [Container](https://en.cppreference.com/w/cpp/named_req/Container)
    requirements:
    - The complexity is constant.
    - Has the semantics of `begin() == end()`.

    @sa @ref size() -- returns the number of elements

    @since version 1.0.0
    */
    bool empty() const noexcept
    {
        switch (m_type)
        {
            case value_t::null:
            {
                // null values are empty
                return true;
            }

            case value_t::array:
            {
                // delegate call to array_t::empty()
                return m_value.array->empty();
            }

            case value_t::object:
            {
                // delegate call to object_t::empty()
                return m_value.object->empty();
            }

            default:
            {
                // all other types are nonempty
                return false;
            }
        }
    }

    /*!
    @brief returns the number of elements

    Returns the number of elements in a JSON value.

    @return The return value depends on the different types and is
            defined as follows:
            Value type  | return value
            ----------- | -------------
            null        | `0`
            boolean     | `1`
            string      | `1`
            number      | `1`
            object      | result of function object_t::size()
            array       | result of function array_t::size()

    @liveexample{The following code calls `size()` on the different value
    types.,size}

    @complexity Constant, as long as @ref array_t and @ref object_t satisfy
    the Container concept; that is, their size() functions have constant
    complexity.

    @iterators No changes.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @note This function does not return the length of a string stored as JSON
    value - it returns the number of elements in the JSON value which is 1 in
    the case of a string.

    @requirement This function helps `basic_json` satisfying the
    [Container](https://en.cppreference.com/w/cpp/named_req/Container)
    requirements:
    - The complexity is constant.
    - Has the semantics of `std::distance(begin(), end())`.

    @sa @ref empty() -- checks whether the container is empty
    @sa @ref max_size() -- returns the maximal number of elements

    @since version 1.0.0
    */
    size_type size() const noexcept
    {
        switch (m_type)
        {
            case value_t::null:
            {
                // null values are empty
                return 0;
            }

            case value_t::array:
            {
                // delegate call to array_t::size()
                return m_value.array->size();
            }

            case value_t::object:
            {
                // delegate call to object_t::size()
                return m_value.object->size();
            }

            default:
            {
                // all other types have size 1
                return 1;
            }
        }
    }

    /*!
    @brief returns the maximum possible number of elements

    Returns the maximum number of elements a JSON value is able to hold due to
    system or library implementation limitations, i.e. `std::distance(begin(),
    end())` for the JSON value.

    @return The return value depends on the different types and is
            defined as follows:
            Value type  | return value
            ----------- | -------------
            null        | `0` (same as `size()`)
            boolean     | `1` (same as `size()`)
            string      | `1` (same as `size()`)
            number      | `1` (same as `size()`)
            object      | result of function `object_t::max_size()`
            array       | result of function `array_t::max_size()`

    @liveexample{The following code calls `max_size()` on the different value
    types. Note the output is implementation specific.,max_size}

    @complexity Constant, as long as @ref array_t and @ref object_t satisfy
    the Container concept; that is, their `max_size()` functions have constant
    complexity.

    @iterators No changes.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @requirement This function helps `basic_json` satisfying the
    [Container](https://en.cppreference.com/w/cpp/named_req/Container)
    requirements:
    - The complexity is constant.
    - Has the semantics of returning `b.size()` where `b` is the largest
      possible JSON value.

    @sa @ref size() -- returns the number of elements

    @since version 1.0.0
    */
    size_type max_size() const noexcept
    {
        switch (m_type)
        {
            case value_t::array:
            {
                // delegate call to array_t::max_size()
                return m_value.array->max_size();
            }

            case value_t::object:
            {
                // delegate call to object_t::max_size()
                return m_value.object->max_size();
            }

            default:
            {
                // all other types have max_size() == size()
                return size();
            }
        }
    }

    /// @}


    ///////////////
    // modifiers //
    ///////////////

    /// @name modifiers
    /// @{

    /*!
    @brief clears the contents

    Clears the content of a JSON value and resets it to the default value as
    if @ref basic_json(value_t) would have been called with the current value
    type from @ref type():

    Value type  | initial value
    ----------- | -------------
    null        | `null`
    boolean     | `false`
    string      | `""`
    number      | `0`
    object      | `{}`
    array       | `[]`

    @post Has the same effect as calling
    @code {.cpp}
    *this = basic_json(type());
    @endcode

    @liveexample{The example below shows the effect of `clear()` to different
    JSON types.,clear}

    @complexity Linear in the size of the JSON value.

    @iterators All iterators, pointers and references related to this container
               are invalidated.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @sa @ref basic_json(value_t) -- constructor that creates an object with the
        same value than calling `clear()`

    @since version 1.0.0
    */
    void clear() noexcept
    {
        switch (m_type)
        {
            case value_t::number_integer:
            {
                m_value.number_integer = 0;
                break;
            }

            case value_t::number_unsigned:
            {
                m_value.number_unsigned = 0;
                break;
            }

            case value_t::number_float:
            {
                m_value.number_float = 0.0;
                break;
            }

            case value_t::boolean:
            {
                m_value.boolean = false;
                break;
            }

            case value_t::string:
            {
                m_value.string->clear();
                break;
            }

            case value_t::array:
            {
                m_value.array->clear();
                break;
            }

            case value_t::object:
            {
                m_value.object->clear();
                break;
            }

            default:
                break;
        }
    }

    /*!
    @brief add an object to an array

    Appends the given element @a val to the end of the JSON value. If the
    function is called on a JSON null value, an empty array is created before
    appending @a val.

    @param[in] val the value to add to the JSON array

    @throw type_error.308 when called on a type other than JSON array or
    null; example: `"cannot use push_back() with number"`

    @complexity Amortized constant.

    @liveexample{The example shows how `push_back()` and `+=` can be used to
    add elements to a JSON array. Note how the `null` value was silently
    converted to a JSON array.,push_back}

    @since version 1.0.0
    */
    void push_back(basic_json&& val)
    {
        // push_back only works for null objects or arrays
        if (JSON_UNLIKELY(not(is_null() or is_array())))
        {
            JSON_THROW(type_error::create(308, "cannot use push_back() with " + std::string(type_name())));
        }

        // transform null object into an array
        if (is_null())
        {
            m_type = value_t::array;
            m_value = value_t::array;
            assert_invariant();
        }

        // add element to array (move semantics)
        m_value.array->push_back(std::move(val));
        // invalidate object: mark it null so we do not call the destructor
        // cppcheck-suppress accessMoved
        val.m_type = value_t::null;
    }

    /*!
    @brief add an object to an array
    @copydoc push_back(basic_json&&)
    */
    reference operator+=(basic_json&& val)
    {
        push_back(std::move(val));
        return *this;
    }

    /*!
    @brief add an object to an array
    @copydoc push_back(basic_json&&)
    */
    void push_back(const basic_json& val)
    {
        // push_back only works for null objects or arrays
        if (JSON_UNLIKELY(not(is_null() or is_array())))
        {
            JSON_THROW(type_error::create(308, "cannot use push_back() with " + std::string(type_name())));
        }

        // transform null object into an array
        if (is_null())
        {
            m_type = value_t::array;
            m_value = value_t::array;
            assert_invariant();
        }

        // add element to array
        m_value.array->push_back(val);
    }

    /*!
    @brief add an object to an array
    @copydoc push_back(basic_json&&)
    */
    reference operator+=(const basic_json& val)
    {
        push_back(val);
        return *this;
    }

    /*!
    @brief add an object to an object

    Inserts the given element @a val to the JSON object. If the function is
    called on a JSON null value, an empty object is created before inserting
    @a val.

    @param[in] val the value to add to the JSON object

    @throw type_error.308 when called on a type other than JSON object or
    null; example: `"cannot use push_back() with number"`

    @complexity Logarithmic in the size of the container, O(log(`size()`)).

    @liveexample{The example shows how `push_back()` and `+=` can be used to
    add elements to a JSON object. Note how the `null` value was silently
    converted to a JSON object.,push_back__object_t__value}

    @since version 1.0.0
    */
    void push_back(const typename object_t::value_type& val)
    {
        // push_back only works for null objects or objects
        if (JSON_UNLIKELY(not(is_null() or is_object())))
        {
            JSON_THROW(type_error::create(308, "cannot use push_back() with " + std::string(type_name())));
        }

        // transform null object into an object
        if (is_null())
        {
            m_type = value_t::object;
            m_value = value_t::object;
            assert_invariant();
        }

        // add element to array
        m_value.object->insert(val);
    }

    /*!
    @brief add an object to an object
    @copydoc push_back(const typename object_t::value_type&)
    */
    reference operator+=(const typename object_t::value_type& val)
    {
        push_back(val);
        return *this;
    }

    /*!
    @brief add an object to an object

    This function allows to use `push_back` with an initializer list. In case

    1. the current value is an object,
    2. the initializer list @a init contains only two elements, and
    3. the first element of @a init is a string,

    @a init is converted into an object element and added using
    @ref push_back(const typename object_t::value_type&). Otherwise, @a init
    is converted to a JSON value and added using @ref push_back(basic_json&&).

    @param[in] init  an initializer list

    @complexity Linear in the size of the initializer list @a init.

    @note This function is required to resolve an ambiguous overload error,
          because pairs like `{"key", "value"}` can be both interpreted as
          `object_t::value_type` or `std::initializer_list<basic_json>`, see
          https://github.com/nlohmann/json/issues/235 for more information.

    @liveexample{The example shows how initializer lists are treated as
    objects when possible.,push_back__initializer_list}
    */
    void push_back(initializer_list_t init)
    {
        if (is_object() and init.size() == 2 and (*init.begin())->is_string())
        {
            basic_json&& key = init.begin()->moved_or_copied();
            push_back(typename object_t::value_type(
                          std::move(key.get_ref<string_t&>()), (init.begin() + 1)->moved_or_copied()));
        }
        else
        {
            push_back(basic_json(init));
        }
    }

    /*!
    @brief add an object to an object
    @copydoc push_back(initializer_list_t)
    */
    reference operator+=(initializer_list_t init)
    {
        push_back(init);
        return *this;
    }

    /*!
    @brief add an object to an array

    Creates a JSON value from the passed parameters @a args to the end of the
    JSON value. If the function is called on a JSON null value, an empty array
    is created before appending the value created from @a args.

    @param[in] args arguments to forward to a constructor of @ref basic_json
    @tparam Args compatible types to create a @ref basic_json object

    @throw type_error.311 when called on a type other than JSON array or
    null; example: `"cannot use emplace_back() with number"`

    @complexity Amortized constant.

    @liveexample{The example shows how `push_back()` can be used to add
    elements to a JSON array. Note how the `null` value was silently converted
    to a JSON array.,emplace_back}

    @since version 2.0.8
    */
    template<class... Args>
    void emplace_back(Args&& ... args)
    {
        // emplace_back only works for null objects or arrays
        if (JSON_UNLIKELY(not(is_null() or is_array())))
        {
            JSON_THROW(type_error::create(311, "cannot use emplace_back() with " + std::string(type_name())));
        }

        // transform null object into an array
        if (is_null())
        {
            m_type = value_t::array;
            m_value = value_t::array;
            assert_invariant();
        }

        // add element to array (perfect forwarding)
        m_value.array->emplace_back(std::forward<Args>(args)...);
    }

    /*!
    @brief add an object to an object if key does not exist

    Inserts a new element into a JSON object constructed in-place with the
    given @a args if there is no element with the key in the container. If the
    function is called on a JSON null value, an empty object is created before
    appending the value created from @a args.

    @param[in] args arguments to forward to a constructor of @ref basic_json
    @tparam Args compatible types to create a @ref basic_json object

    @return a pair consisting of an iterator to the inserted element, or the
            already-existing element if no insertion happened, and a bool
            denoting whether the insertion took place.

    @throw type_error.311 when called on a type other than JSON object or
    null; example: `"cannot use emplace() with number"`

    @complexity Logarithmic in the size of the container, O(log(`size()`)).

    @liveexample{The example shows how `emplace()` can be used to add elements
    to a JSON object. Note how the `null` value was silently converted to a
    JSON object. Further note how no value is added if there was already one
    value stored with the same key.,emplace}

    @since version 2.0.8
    */
    template<class... Args>
    std::pair<iterator, bool> emplace(Args&& ... args)
    {
        // emplace only works for null objects or arrays
        if (JSON_UNLIKELY(not(is_null() or is_object())))
        {
            JSON_THROW(type_error::create(311, "cannot use emplace() with " + std::string(type_name())));
        }

        // transform null object into an object
        if (is_null())
        {
            m_type = value_t::object;
            m_value = value_t::object;
            assert_invariant();
        }

        // add element to array (perfect forwarding)
        auto res = m_value.object->emplace(std::forward<Args>(args)...);
        // create result iterator and set iterator to the result of emplace
        auto it = begin();
        it.m_it.object_iterator = res.first;

        // return pair of iterator and boolean
        return {it, res.second};
    }

    /// Helper for insertion of an iterator
    /// @note: This uses std::distance to support GCC 4.8,
    ///        see https://github.com/nlohmann/json/pull/1257
    template<typename... Args>
    iterator insert_iterator(const_iterator pos, Args&& ... args)
    {
        iterator result(this);
        assert(m_value.array != nullptr);

        auto insert_pos = std::distance(m_value.array->begin(), pos.m_it.array_iterator);
        m_value.array->insert(pos.m_it.array_iterator, std::forward<Args>(args)...);
        result.m_it.array_iterator = m_value.array->begin() + insert_pos;

        // This could have been written as:
        // result.m_it.array_iterator = m_value.array->insert(pos.m_it.array_iterator, cnt, val);
        // but the return value of insert is missing in GCC 4.8, so it is written this way instead.

        return result;
    }

    /*!
    @brief inserts element

    Inserts element @a val before iterator @a pos.

    @param[in] pos iterator before which the content will be inserted; may be
    the end() iterator
    @param[in] val element to insert
    @return iterator pointing to the inserted @a val.

    @throw type_error.309 if called on JSON values other than arrays;
    example: `"cannot use insert() with string"`
    @throw invalid_iterator.202 if @a pos is not an iterator of *this;
    example: `"iterator does not fit current value"`

    @complexity Constant plus linear in the distance between @a pos and end of
    the container.

    @liveexample{The example shows how `insert()` is used.,insert}

    @since version 1.0.0
    */
    iterator insert(const_iterator pos, const basic_json& val)
    {
        // insert only works for arrays
        if (JSON_LIKELY(is_array()))
        {
            // check if iterator pos fits to this JSON value
            if (JSON_UNLIKELY(pos.m_object != this))
            {
                JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value"));
            }

            // insert to array and return iterator
            return insert_iterator(pos, val);
        }

        JSON_THROW(type_error::create(309, "cannot use insert() with " + std::string(type_name())));
    }

    /*!
    @brief inserts element
    @copydoc insert(const_iterator, const basic_json&)
    */
    iterator insert(const_iterator pos, basic_json&& val)
    {
        return insert(pos, val);
    }

    /*!
    @brief inserts elements

    Inserts @a cnt copies of @a val before iterator @a pos.

    @param[in] pos iterator before which the content will be inserted; may be
    the end() iterator
    @param[in] cnt number of copies of @a val to insert
    @param[in] val element to insert
    @return iterator pointing to the first element inserted, or @a pos if
    `cnt==0`

    @throw type_error.309 if called on JSON values other than arrays; example:
    `"cannot use insert() with string"`
    @throw invalid_iterator.202 if @a pos is not an iterator of *this;
    example: `"iterator does not fit current value"`

    @complexity Linear in @a cnt plus linear in the distance between @a pos
    and end of the container.

    @liveexample{The example shows how `insert()` is used.,insert__count}

    @since version 1.0.0
    */
    iterator insert(const_iterator pos, size_type cnt, const basic_json& val)
    {
        // insert only works for arrays
        if (JSON_LIKELY(is_array()))
        {
            // check if iterator pos fits to this JSON value
            if (JSON_UNLIKELY(pos.m_object != this))
            {
                JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value"));
            }

            // insert to array and return iterator
            return insert_iterator(pos, cnt, val);
        }

        JSON_THROW(type_error::create(309, "cannot use insert() with " + std::string(type_name())));
    }

    /*!
    @brief inserts elements

    Inserts elements from range `[first, last)` before iterator @a pos.

    @param[in] pos iterator before which the content will be inserted; may be
    the end() iterator
    @param[in] first begin of the range of elements to insert
    @param[in] last end of the range of elements to insert

    @throw type_error.309 if called on JSON values other than arrays; example:
    `"cannot use insert() with string"`
    @throw invalid_iterator.202 if @a pos is not an iterator of *this;
    example: `"iterator does not fit current value"`
    @throw invalid_iterator.210 if @a first and @a last do not belong to the
    same JSON value; example: `"iterators do not fit"`
    @throw invalid_iterator.211 if @a first or @a last are iterators into
    container for which insert is called; example: `"passed iterators may not
    belong to container"`

    @return iterator pointing to the first element inserted, or @a pos if
    `first==last`

    @complexity Linear in `std::distance(first, last)` plus linear in the
    distance between @a pos and end of the container.

    @liveexample{The example shows how `insert()` is used.,insert__range}

    @since version 1.0.0
    */
    iterator insert(const_iterator pos, const_iterator first, const_iterator last)
    {
        // insert only works for arrays
        if (JSON_UNLIKELY(not is_array()))
        {
            JSON_THROW(type_error::create(309, "cannot use insert() with " + std::string(type_name())));
        }

        // check if iterator pos fits to this JSON value
        if (JSON_UNLIKELY(pos.m_object != this))
        {
            JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value"));
        }

        // check if range iterators belong to the same JSON object
        if (JSON_UNLIKELY(first.m_object != last.m_object))
        {
            JSON_THROW(invalid_iterator::create(210, "iterators do not fit"));
        }

        if (JSON_UNLIKELY(first.m_object == this))
        {
            JSON_THROW(invalid_iterator::create(211, "passed iterators may not belong to container"));
        }

        // insert to array and return iterator
        return insert_iterator(pos, first.m_it.array_iterator, last.m_it.array_iterator);
    }

    /*!
    @brief inserts elements

    Inserts elements from initializer list @a ilist before iterator @a pos.

    @param[in] pos iterator before which the content will be inserted; may be
    the end() iterator
    @param[in] ilist initializer list to insert the values from

    @throw type_error.309 if called on JSON values other than arrays; example:
    `"cannot use insert() with string"`
    @throw invalid_iterator.202 if @a pos is not an iterator of *this;
    example: `"iterator does not fit current value"`

    @return iterator pointing to the first element inserted, or @a pos if
    `ilist` is empty

    @complexity Linear in `ilist.size()` plus linear in the distance between
    @a pos and end of the container.

    @liveexample{The example shows how `insert()` is used.,insert__ilist}

    @since version 1.0.0
    */
    iterator insert(const_iterator pos, initializer_list_t ilist)
    {
        // insert only works for arrays
        if (JSON_UNLIKELY(not is_array()))
        {
            JSON_THROW(type_error::create(309, "cannot use insert() with " + std::string(type_name())));
        }

        // check if iterator pos fits to this JSON value
        if (JSON_UNLIKELY(pos.m_object != this))
        {
            JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value"));
        }

        // insert to array and return iterator
        return insert_iterator(pos, ilist.begin(), ilist.end());
    }

    /*!
    @brief inserts elements

    Inserts elements from range `[first, last)`.

    @param[in] first begin of the range of elements to insert
    @param[in] last end of the range of elements to insert

    @throw type_error.309 if called on JSON values other than objects; example:
    `"cannot use insert() with string"`
    @throw invalid_iterator.202 if iterator @a first or @a last does does not
    point to an object; example: `"iterators first and last must point to
    objects"`
    @throw invalid_iterator.210 if @a first and @a last do not belong to the
    same JSON value; example: `"iterators do not fit"`

    @complexity Logarithmic: `O(N*log(size() + N))`, where `N` is the number
    of elements to insert.

    @liveexample{The example shows how `insert()` is used.,insert__range_object}

    @since version 3.0.0
    */
    void insert(const_iterator first, const_iterator last)
    {
        // insert only works for objects
        if (JSON_UNLIKELY(not is_object()))
        {
            JSON_THROW(type_error::create(309, "cannot use insert() with " + std::string(type_name())));
        }

        // check if range iterators belong to the same JSON object
        if (JSON_UNLIKELY(first.m_object != last.m_object))
        {
            JSON_THROW(invalid_iterator::create(210, "iterators do not fit"));
        }

        // passed iterators must belong to objects
        if (JSON_UNLIKELY(not first.m_object->is_object()))
        {
            JSON_THROW(invalid_iterator::create(202, "iterators first and last must point to objects"));
        }

        m_value.object->insert(first.m_it.object_iterator, last.m_it.object_iterator);
    }

    /*!
    @brief updates a JSON object from another object, overwriting existing keys

    Inserts all values from JSON object @a j and overwrites existing keys.

    @param[in] j  JSON object to read values from

    @throw type_error.312 if called on JSON values other than objects; example:
    `"cannot use update() with string"`

    @complexity O(N*log(size() + N)), where N is the number of elements to
                insert.

    @liveexample{The example shows how `update()` is used.,update}

    @sa https://docs.python.org/3.6/library/stdtypes.html#dict.update

    @since version 3.0.0
    */
    void update(const_reference j)
    {
        // implicitly convert null value to an empty object
        if (is_null())
        {
            m_type = value_t::object;
            m_value.object = create<object_t>();
            assert_invariant();
        }

        if (JSON_UNLIKELY(not is_object()))
        {
            JSON_THROW(type_error::create(312, "cannot use update() with " + std::string(type_name())));
        }
        if (JSON_UNLIKELY(not j.is_object()))
        {
            JSON_THROW(type_error::create(312, "cannot use update() with " + std::string(j.type_name())));
        }

        for (auto it = j.cbegin(); it != j.cend(); ++it)
        {
            m_value.object->operator[](it.key()) = it.value();
        }
    }

    /*!
    @brief updates a JSON object from another object, overwriting existing keys

    Inserts all values from from range `[first, last)` and overwrites existing
    keys.

    @param[in] first begin of the range of elements to insert
    @param[in] last end of the range of elements to insert

    @throw type_error.312 if called on JSON values other than objects; example:
    `"cannot use update() with string"`
    @throw invalid_iterator.202 if iterator @a first or @a last does does not
    point to an object; example: `"iterators first and last must point to
    objects"`
    @throw invalid_iterator.210 if @a first and @a last do not belong to the
    same JSON value; example: `"iterators do not fit"`

    @complexity O(N*log(size() + N)), where N is the number of elements to
                insert.

    @liveexample{The example shows how `update()` is used__range.,update}

    @sa https://docs.python.org/3.6/library/stdtypes.html#dict.update

    @since version 3.0.0
    */
    void update(const_iterator first, const_iterator last)
    {
        // implicitly convert null value to an empty object
        if (is_null())
        {
            m_type = value_t::object;
            m_value.object = create<object_t>();
            assert_invariant();
        }

        if (JSON_UNLIKELY(not is_object()))
        {
            JSON_THROW(type_error::create(312, "cannot use update() with " + std::string(type_name())));
        }

        // check if range iterators belong to the same JSON object
        if (JSON_UNLIKELY(first.m_object != last.m_object))
        {
            JSON_THROW(invalid_iterator::create(210, "iterators do not fit"));
        }

        // passed iterators must belong to objects
        if (JSON_UNLIKELY(not first.m_object->is_object()
                          or not last.m_object->is_object()))
        {
            JSON_THROW(invalid_iterator::create(202, "iterators first and last must point to objects"));
        }

        for (auto it = first; it != last; ++it)
        {
            m_value.object->operator[](it.key()) = it.value();
        }
    }

    /*!
    @brief exchanges the values

    Exchanges the contents of the JSON value with those of @a other. Does not
    invoke any move, copy, or swap operations on individual elements. All
    iterators and references remain valid. The past-the-end iterator is
    invalidated.

    @param[in,out] other JSON value to exchange the contents with

    @complexity Constant.

    @liveexample{The example below shows how JSON values can be swapped with
    `swap()`.,swap__reference}

    @since version 1.0.0
    */
    void swap(reference other) noexcept (
        std::is_nothrow_move_constructible<value_t>::value and
        std::is_nothrow_move_assignable<value_t>::value and
        std::is_nothrow_move_constructible<json_value>::value and
        std::is_nothrow_move_assignable<json_value>::value
    )
    {
        std::swap(m_type, other.m_type);
        std::swap(m_value, other.m_value);
        assert_invariant();
    }

    /*!
    @brief exchanges the values

    Exchanges the contents of a JSON array with those of @a other. Does not
    invoke any move, copy, or swap operations on individual elements. All
    iterators and references remain valid. The past-the-end iterator is
    invalidated.

    @param[in,out] other array to exchange the contents with

    @throw type_error.310 when JSON value is not an array; example: `"cannot
    use swap() with string"`

    @complexity Constant.

    @liveexample{The example below shows how arrays can be swapped with
    `swap()`.,swap__array_t}

    @since version 1.0.0
    */
    void swap(array_t& other)
    {
        // swap only works for arrays
        if (JSON_LIKELY(is_array()))
        {
            std::swap(*(m_value.array), other);
        }
        else
        {
            JSON_THROW(type_error::create(310, "cannot use swap() with " + std::string(type_name())));
        }
    }

    /*!
    @brief exchanges the values

    Exchanges the contents of a JSON object with those of @a other. Does not
    invoke any move, copy, or swap operations on individual elements. All
    iterators and references remain valid. The past-the-end iterator is
    invalidated.

    @param[in,out] other object to exchange the contents with

    @throw type_error.310 when JSON value is not an object; example:
    `"cannot use swap() with string"`

    @complexity Constant.

    @liveexample{The example below shows how objects can be swapped with
    `swap()`.,swap__object_t}

    @since version 1.0.0
    */
    void swap(object_t& other)
    {
        // swap only works for objects
        if (JSON_LIKELY(is_object()))
        {
            std::swap(*(m_value.object), other);
        }
        else
        {
            JSON_THROW(type_error::create(310, "cannot use swap() with " + std::string(type_name())));
        }
    }

    /*!
    @brief exchanges the values

    Exchanges the contents of a JSON string with those of @a other. Does not
    invoke any move, copy, or swap operations on individual elements. All
    iterators and references remain valid. The past-the-end iterator is
    invalidated.

    @param[in,out] other string to exchange the contents with

    @throw type_error.310 when JSON value is not a string; example: `"cannot
    use swap() with boolean"`

    @complexity Constant.

    @liveexample{The example below shows how strings can be swapped with
    `swap()`.,swap__string_t}

    @since version 1.0.0
    */
    void swap(string_t& other)
    {
        // swap only works for strings
        if (JSON_LIKELY(is_string()))
        {
            std::swap(*(m_value.string), other);
        }
        else
        {
            JSON_THROW(type_error::create(310, "cannot use swap() with " + std::string(type_name())));
        }
    }

    /// @}

  public:
    //////////////////////////////////////////
    // lexicographical comparison operators //
    //////////////////////////////////////////

    /// @name lexicographical comparison operators
    /// @{

    /*!
    @brief comparison: equal

    Compares two JSON values for equality according to the following rules:
    - Two JSON values are equal if (1) they are from the same type and (2)
      their stored values are the same according to their respective
      `operator==`.
    - Integer and floating-point numbers are automatically converted before
      comparison. Note than two NaN values are always treated as unequal.
    - Two JSON null values are equal.

    @note Floating-point inside JSON values numbers are compared with
    `json::number_float_t::operator==` which is `double::operator==` by
    default. To compare floating-point while respecting an epsilon, an alternative
    [comparison function](https://github.com/mariokonrad/marnav/blob/master/src/marnav/math/floatingpoint.hpp#L34-#L39)
    could be used, for instance
    @code {.cpp}
    template<typename T, typename = typename std::enable_if<std::is_floating_point<T>::value, T>::type>
    inline bool is_same(T a, T b, T epsilon = std::numeric_limits<T>::epsilon()) noexcept
    {
        return std::abs(a - b) <= epsilon;
    }
    @endcode

    @note NaN values never compare equal to themselves or to other NaN values.

    @param[in] lhs  first JSON value to consider
    @param[in] rhs  second JSON value to consider
    @return whether the values @a lhs and @a rhs are equal

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @complexity Linear.

    @liveexample{The example demonstrates comparing several JSON
    types.,operator__equal}

    @since version 1.0.0
    */
    friend bool operator==(const_reference lhs, const_reference rhs) noexcept
    {
        const auto lhs_type = lhs.type();
        const auto rhs_type = rhs.type();

        if (lhs_type == rhs_type)
        {
            switch (lhs_type)
            {
                case value_t::array:
                    return *lhs.m_value.array == *rhs.m_value.array;

                case value_t::object:
                    return *lhs.m_value.object == *rhs.m_value.object;

                case value_t::null:
                    return true;

                case value_t::string:
                    return *lhs.m_value.string == *rhs.m_value.string;

                case value_t::boolean:
                    return lhs.m_value.boolean == rhs.m_value.boolean;

                case value_t::number_integer:
                    return lhs.m_value.number_integer == rhs.m_value.number_integer;

                case value_t::number_unsigned:
                    return lhs.m_value.number_unsigned == rhs.m_value.number_unsigned;

                case value_t::number_float:
                    return lhs.m_value.number_float == rhs.m_value.number_float;

                default:
                    return false;
            }
        }
        else if (lhs_type == value_t::number_integer and rhs_type == value_t::number_float)
        {
            return static_cast<number_float_t>(lhs.m_value.number_integer) == rhs.m_value.number_float;
        }
        else if (lhs_type == value_t::number_float and rhs_type == value_t::number_integer)
        {
            return lhs.m_value.number_float == static_cast<number_float_t>(rhs.m_value.number_integer);
        }
        else if (lhs_type == value_t::number_unsigned and rhs_type == value_t::number_float)
        {
            return static_cast<number_float_t>(lhs.m_value.number_unsigned) == rhs.m_value.number_float;
        }
        else if (lhs_type == value_t::number_float and rhs_type == value_t::number_unsigned)
        {
            return lhs.m_value.number_float == static_cast<number_float_t>(rhs.m_value.number_unsigned);
        }
        else if (lhs_type == value_t::number_unsigned and rhs_type == value_t::number_integer)
        {
            return static_cast<number_integer_t>(lhs.m_value.number_unsigned) == rhs.m_value.number_integer;
        }
        else if (lhs_type == value_t::number_integer and rhs_type == value_t::number_unsigned)
        {
            return lhs.m_value.number_integer == static_cast<number_integer_t>(rhs.m_value.number_unsigned);
        }

        return false;
    }

    /*!
    @brief comparison: equal
    @copydoc operator==(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator==(const_reference lhs, const ScalarType rhs) noexcept
    {
        return lhs == basic_json(rhs);
    }

    /*!
    @brief comparison: equal
    @copydoc operator==(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator==(const ScalarType lhs, const_reference rhs) noexcept
    {
        return basic_json(lhs) == rhs;
    }

    /*!
    @brief comparison: not equal

    Compares two JSON values for inequality by calculating `not (lhs == rhs)`.

    @param[in] lhs  first JSON value to consider
    @param[in] rhs  second JSON value to consider
    @return whether the values @a lhs and @a rhs are not equal

    @complexity Linear.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @liveexample{The example demonstrates comparing several JSON
    types.,operator__notequal}

    @since version 1.0.0
    */
    friend bool operator!=(const_reference lhs, const_reference rhs) noexcept
    {
        return not (lhs == rhs);
    }

    /*!
    @brief comparison: not equal
    @copydoc operator!=(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator!=(const_reference lhs, const ScalarType rhs) noexcept
    {
        return lhs != basic_json(rhs);
    }

    /*!
    @brief comparison: not equal
    @copydoc operator!=(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator!=(const ScalarType lhs, const_reference rhs) noexcept
    {
        return basic_json(lhs) != rhs;
    }

    /*!
    @brief comparison: less than

    Compares whether one JSON value @a lhs is less than another JSON value @a
    rhs according to the following rules:
    - If @a lhs and @a rhs have the same type, the values are compared using
      the default `<` operator.
    - Integer and floating-point numbers are automatically converted before
      comparison
    - In case @a lhs and @a rhs have different types, the values are ignored
      and the order of the types is considered, see
      @ref operator<(const value_t, const value_t).

    @param[in] lhs  first JSON value to consider
    @param[in] rhs  second JSON value to consider
    @return whether @a lhs is less than @a rhs

    @complexity Linear.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @liveexample{The example demonstrates comparing several JSON
    types.,operator__less}

    @since version 1.0.0
    */
    friend bool operator<(const_reference lhs, const_reference rhs) noexcept
    {
        const auto lhs_type = lhs.type();
        const auto rhs_type = rhs.type();

        if (lhs_type == rhs_type)
        {
            switch (lhs_type)
            {
                case value_t::array:
                    // note parentheses are necessary, see
                    // https://github.com/nlohmann/json/issues/1530
                    return (*lhs.m_value.array) < (*rhs.m_value.array);

                case value_t::object:
                    return *lhs.m_value.object < *rhs.m_value.object;

                case value_t::null:
                    return false;

                case value_t::string:
                    return *lhs.m_value.string < *rhs.m_value.string;

                case value_t::boolean:
                    return lhs.m_value.boolean < rhs.m_value.boolean;

                case value_t::number_integer:
                    return lhs.m_value.number_integer < rhs.m_value.number_integer;

                case value_t::number_unsigned:
                    return lhs.m_value.number_unsigned < rhs.m_value.number_unsigned;

                case value_t::number_float:
                    return lhs.m_value.number_float < rhs.m_value.number_float;

                default:
                    return false;
            }
        }
        else if (lhs_type == value_t::number_integer and rhs_type == value_t::number_float)
        {
            return static_cast<number_float_t>(lhs.m_value.number_integer) < rhs.m_value.number_float;
        }
        else if (lhs_type == value_t::number_float and rhs_type == value_t::number_integer)
        {
            return lhs.m_value.number_float < static_cast<number_float_t>(rhs.m_value.number_integer);
        }
        else if (lhs_type == value_t::number_unsigned and rhs_type == value_t::number_float)
        {
            return static_cast<number_float_t>(lhs.m_value.number_unsigned) < rhs.m_value.number_float;
        }
        else if (lhs_type == value_t::number_float and rhs_type == value_t::number_unsigned)
        {
            return lhs.m_value.number_float < static_cast<number_float_t>(rhs.m_value.number_unsigned);
        }
        else if (lhs_type == value_t::number_integer and rhs_type == value_t::number_unsigned)
        {
            return lhs.m_value.number_integer < static_cast<number_integer_t>(rhs.m_value.number_unsigned);
        }
        else if (lhs_type == value_t::number_unsigned and rhs_type == value_t::number_integer)
        {
            return static_cast<number_integer_t>(lhs.m_value.number_unsigned) < rhs.m_value.number_integer;
        }

        // We only reach this line if we cannot compare values. In that case,
        // we compare types. Note we have to call the operator explicitly,
        // because MSVC has problems otherwise.
        return operator<(lhs_type, rhs_type);
    }

    /*!
    @brief comparison: less than
    @copydoc operator<(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator<(const_reference lhs, const ScalarType rhs) noexcept
    {
        return lhs < basic_json(rhs);
    }

    /*!
    @brief comparison: less than
    @copydoc operator<(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator<(const ScalarType lhs, const_reference rhs) noexcept
    {
        return basic_json(lhs) < rhs;
    }

    /*!
    @brief comparison: less than or equal

    Compares whether one JSON value @a lhs is less than or equal to another
    JSON value by calculating `not (rhs < lhs)`.

    @param[in] lhs  first JSON value to consider
    @param[in] rhs  second JSON value to consider
    @return whether @a lhs is less than or equal to @a rhs

    @complexity Linear.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @liveexample{The example demonstrates comparing several JSON
    types.,operator__greater}

    @since version 1.0.0
    */
    friend bool operator<=(const_reference lhs, const_reference rhs) noexcept
    {
        return not (rhs < lhs);
    }

    /*!
    @brief comparison: less than or equal
    @copydoc operator<=(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator<=(const_reference lhs, const ScalarType rhs) noexcept
    {
        return lhs <= basic_json(rhs);
    }

    /*!
    @brief comparison: less than or equal
    @copydoc operator<=(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator<=(const ScalarType lhs, const_reference rhs) noexcept
    {
        return basic_json(lhs) <= rhs;
    }

    /*!
    @brief comparison: greater than

    Compares whether one JSON value @a lhs is greater than another
    JSON value by calculating `not (lhs <= rhs)`.

    @param[in] lhs  first JSON value to consider
    @param[in] rhs  second JSON value to consider
    @return whether @a lhs is greater than to @a rhs

    @complexity Linear.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @liveexample{The example demonstrates comparing several JSON
    types.,operator__lessequal}

    @since version 1.0.0
    */
    friend bool operator>(const_reference lhs, const_reference rhs) noexcept
    {
        return not (lhs <= rhs);
    }

    /*!
    @brief comparison: greater than
    @copydoc operator>(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator>(const_reference lhs, const ScalarType rhs) noexcept
    {
        return lhs > basic_json(rhs);
    }

    /*!
    @brief comparison: greater than
    @copydoc operator>(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator>(const ScalarType lhs, const_reference rhs) noexcept
    {
        return basic_json(lhs) > rhs;
    }

    /*!
    @brief comparison: greater than or equal

    Compares whether one JSON value @a lhs is greater than or equal to another
    JSON value by calculating `not (lhs < rhs)`.

    @param[in] lhs  first JSON value to consider
    @param[in] rhs  second JSON value to consider
    @return whether @a lhs is greater than or equal to @a rhs

    @complexity Linear.

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @liveexample{The example demonstrates comparing several JSON
    types.,operator__greaterequal}

    @since version 1.0.0
    */
    friend bool operator>=(const_reference lhs, const_reference rhs) noexcept
    {
        return not (lhs < rhs);
    }

    /*!
    @brief comparison: greater than or equal
    @copydoc operator>=(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator>=(const_reference lhs, const ScalarType rhs) noexcept
    {
        return lhs >= basic_json(rhs);
    }

    /*!
    @brief comparison: greater than or equal
    @copydoc operator>=(const_reference, const_reference)
    */
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator>=(const ScalarType lhs, const_reference rhs) noexcept
    {
        return basic_json(lhs) >= rhs;
    }

    /// @}

    ///////////////////
    // serialization //
    ///////////////////

    /// @name serialization
    /// @{

    /*!
    @brief serialize to stream

    Serialize the given JSON value @a j to the output stream @a o. The JSON
    value will be serialized using the @ref dump member function.

    - The indentation of the output can be controlled with the member variable
      `width` of the output stream @a o. For instance, using the manipulator
      `std::setw(4)` on @a o sets the indentation level to `4` and the
      serialization result is the same as calling `dump(4)`.

    - The indentation character can be controlled with the member variable
      `fill` of the output stream @a o. For instance, the manipulator
      `std::setfill('\\t')` sets indentation to use a tab character rather than
      the default space character.

    @param[in,out] o  stream to serialize to
    @param[in] j  JSON value to serialize

    @return the stream @a o

    @throw type_error.316 if a string stored inside the JSON value is not
                          UTF-8 encoded

    @complexity Linear.

    @liveexample{The example below shows the serialization with different
    parameters to `width` to adjust the indentation level.,operator_serialize}

    @since version 1.0.0; indentation character added in version 3.0.0
    */
    friend std::ostream& operator<<(std::ostream& o, const basic_json& j)
    {
        // read width member and use it as indentation parameter if nonzero
        const bool pretty_print = o.width() > 0;
        const auto indentation = pretty_print ? o.width() : 0;

        // reset width to 0 for subsequent calls to this stream
        o.width(0);

        // do the actual serialization
        serializer s(detail::output_adapter<char>(o), o.fill());
        s.dump(j, pretty_print, false, static_cast<unsigned int>(indentation));
        return o;
    }

    /*!
    @brief serialize to stream
    @deprecated This stream operator is deprecated and will be removed in
                future 4.0.0 of the library. Please use
                @ref operator<<(std::ostream&, const basic_json&)
                instead; that is, replace calls like `j >> o;` with `o << j;`.
    @since version 1.0.0; deprecated since version 3.0.0
    */
    JSON_DEPRECATED
    friend std::ostream& operator>>(const basic_json& j, std::ostream& o)
    {
        return o << j;
    }

    /// @}


    /////////////////////
    // deserialization //
    /////////////////////

    /// @name deserialization
    /// @{

    /*!
    @brief deserialize from a compatible input

    This function reads from a compatible input. Examples are:
    - an array of 1-byte values
    - strings with character/literal type with size of 1 byte
    - input streams
    - container with contiguous storage of 1-byte values. Compatible container
      types include `std::vector`, `std::string`, `std::array`,
      `std::valarray`, and `std::initializer_list`. Furthermore, C-style
      arrays can be used with `std::begin()`/`std::end()`. User-defined
      containers can be used as long as they implement random-access iterators
      and a contiguous storage.

    @pre Each element of the container has a size of 1 byte. Violating this
    precondition yields undefined behavior. **This precondition is enforced
    with a static assertion.**

    @pre The container storage is contiguous. Violating this precondition
    yields undefined behavior. **This precondition is enforced with an
    assertion.**

    @warning There is no way to enforce all preconditions at compile-time. If
             the function is called with a noncompliant container and with
             assertions switched off, the behavior is undefined and will most
             likely yield segmentation violation.

    @param[in] i  input to read from
    @param[in] cb  a parser callback function of type @ref parser_callback_t
    which is used to control the deserialization by filtering unwanted values
    (optional)
    @param[in] allow_exceptions  whether to throw exceptions in case of a
    parse error (optional, true by default)

    @return deserialized JSON value; in case of a parse error and
            @a allow_exceptions set to `false`, the return value will be
            value_t::discarded.

    @throw parse_error.101 if a parse error occurs; example: `""unexpected end
    of input; expected string literal""`
    @throw parse_error.102 if to_unicode fails or surrogate error
    @throw parse_error.103 if to_unicode fails

    @complexity Linear in the length of the input. The parser is a predictive
    LL(1) parser. The complexity can be higher if the parser callback function
    @a cb has a super-linear complexity.

    @note A UTF-8 byte order mark is silently ignored.

    @liveexample{The example below demonstrates the `parse()` function reading
    from an array.,parse__array__parser_callback_t}

    @liveexample{The example below demonstrates the `parse()` function with
    and without callback function.,parse__string__parser_callback_t}

    @liveexample{The example below demonstrates the `parse()` function with
    and without callback function.,parse__istream__parser_callback_t}

    @liveexample{The example below demonstrates the `parse()` function reading
    from a contiguous container.,parse__contiguouscontainer__parser_callback_t}

    @since version 2.0.3 (contiguous containers)
    */
    JSON_NODISCARD
    static basic_json parse(detail::input_adapter&& i,
                            const parser_callback_t cb = nullptr,
                            const bool allow_exceptions = true)
    {
        basic_json result;
        parser(i, cb, allow_exceptions).parse(true, result);
        return result;
    }

    static bool accept(detail::input_adapter&& i)
    {
        return parser(i).accept(true);
    }

    /*!
    @brief generate SAX events

    The SAX event lister must follow the interface of @ref json_sax.

    This function reads from a compatible input. Examples are:
    - an array of 1-byte values
    - strings with character/literal type with size of 1 byte
    - input streams
    - container with contiguous storage of 1-byte values. Compatible container
      types include `std::vector`, `std::string`, `std::array`,
      `std::valarray`, and `std::initializer_list`. Furthermore, C-style
      arrays can be used with `std::begin()`/`std::end()`. User-defined
      containers can be used as long as they implement random-access iterators
      and a contiguous storage.

    @pre Each element of the container has a size of 1 byte. Violating this
    precondition yields undefined behavior. **This precondition is enforced
    with a static assertion.**

    @pre The container storage is contiguous. Violating this precondition
    yields undefined behavior. **This precondition is enforced with an
    assertion.**

    @warning There is no way to enforce all preconditions at compile-time. If
             the function is called with a noncompliant container and with
             assertions switched off, the behavior is undefined and will most
             likely yield segmentation violation.

    @param[in] i  input to read from
    @param[in,out] sax  SAX event listener
    @param[in] format  the format to parse (JSON, CBOR, MessagePack, or UBJSON)
    @param[in] strict  whether the input has to be consumed completely

    @return return value of the last processed SAX event

    @throw parse_error.101 if a parse error occurs; example: `""unexpected end
    of input; expected string literal""`
    @throw parse_error.102 if to_unicode fails or surrogate error
    @throw parse_error.103 if to_unicode fails

    @complexity Linear in the length of the input. The parser is a predictive
    LL(1) parser. The complexity can be higher if the SAX consumer @a sax has
    a super-linear complexity.

    @note A UTF-8 byte order mark is silently ignored.

    @liveexample{The example below demonstrates the `sax_parse()` function
    reading from string and processing the events with a user-defined SAX
    event consumer.,sax_parse}

    @since version 3.2.0
    */
    template <typename SAX>
    static bool sax_parse(detail::input_adapter&& i, SAX* sax,
                          input_format_t format = input_format_t::json,
                          const bool strict = true)
    {
        assert(sax);
        return format == input_format_t::json
               ? parser(std::move(i)).sax_parse(sax, strict)
               : detail::binary_reader<basic_json, SAX>(std::move(i)).sax_parse(format, sax, strict);
    }

    /*!
    @brief deserialize from an iterator range with contiguous storage

    This function reads from an iterator range of a container with contiguous
    storage of 1-byte values. Compatible container types include
    `std::vector`, `std::string`, `std::array`, `std::valarray`, and
    `std::initializer_list`. Furthermore, C-style arrays can be used with
    `std::begin()`/`std::end()`. User-defined containers can be used as long
    as they implement random-access iterators and a contiguous storage.

    @pre The iterator range is contiguous. Violating this precondition yields
    undefined behavior. **This precondition is enforced with an assertion.**
    @pre Each element in the range has a size of 1 byte. Violating this
    precondition yields undefined behavior. **This precondition is enforced
    with a static assertion.**

    @warning There is no way to enforce all preconditions at compile-time. If
             the function is called with noncompliant iterators and with
             assertions switched off, the behavior is undefined and will most
             likely yield segmentation violation.

    @tparam IteratorType iterator of container with contiguous storage
    @param[in] first  begin of the range to parse (included)
    @param[in] last  end of the range to parse (excluded)
    @param[in] cb  a parser callback function of type @ref parser_callback_t
    which is used to control the deserialization by filtering unwanted values
    (optional)
    @param[in] allow_exceptions  whether to throw exceptions in case of a
    parse error (optional, true by default)

    @return deserialized JSON value; in case of a parse error and
            @a allow_exceptions set to `false`, the return value will be
            value_t::discarded.

    @throw parse_error.101 in case of an unexpected token
    @throw parse_error.102 if to_unicode fails or surrogate error
    @throw parse_error.103 if to_unicode fails

    @complexity Linear in the length of the input. The parser is a predictive
    LL(1) parser. The complexity can be higher if the parser callback function
    @a cb has a super-linear complexity.

    @note A UTF-8 byte order mark is silently ignored.

    @liveexample{The example below demonstrates the `parse()` function reading
    from an iterator range.,parse__iteratortype__parser_callback_t}

    @since version 2.0.3
    */
    template<class IteratorType, typename std::enable_if<
                 std::is_base_of<
                     std::random_access_iterator_tag,
                     typename std::iterator_traits<IteratorType>::iterator_category>::value, int>::type = 0>
    static basic_json parse(IteratorType first, IteratorType last,
                            const parser_callback_t cb = nullptr,
                            const bool allow_exceptions = true)
    {
        basic_json result;
        parser(detail::input_adapter(first, last), cb, allow_exceptions).parse(true, result);
        return result;
    }

    template<class IteratorType, typename std::enable_if<
                 std::is_base_of<
                     std::random_access_iterator_tag,
                     typename std::iterator_traits<IteratorType>::iterator_category>::value, int>::type = 0>
    static bool accept(IteratorType first, IteratorType last)
    {
        return parser(detail::input_adapter(first, last)).accept(true);
    }

    template<class IteratorType, class SAX, typename std::enable_if<
                 std::is_base_of<
                     std::random_access_iterator_tag,
                     typename std::iterator_traits<IteratorType>::iterator_category>::value, int>::type = 0>
    static bool sax_parse(IteratorType first, IteratorType last, SAX* sax)
    {
        return parser(detail::input_adapter(first, last)).sax_parse(sax);
    }

    /*!
    @brief deserialize from stream
    @deprecated This stream operator is deprecated and will be removed in
                version 4.0.0 of the library. Please use
                @ref operator>>(std::istream&, basic_json&)
                instead; that is, replace calls like `j << i;` with `i >> j;`.
    @since version 1.0.0; deprecated since version 3.0.0
    */
    JSON_DEPRECATED
    friend std::istream& operator<<(basic_json& j, std::istream& i)
    {
        return operator>>(i, j);
    }

    /*!
    @brief deserialize from stream

    Deserializes an input stream to a JSON value.

    @param[in,out] i  input stream to read a serialized JSON value from
    @param[in,out] j  JSON value to write the deserialized input to

    @throw parse_error.101 in case of an unexpected token
    @throw parse_error.102 if to_unicode fails or surrogate error
    @throw parse_error.103 if to_unicode fails

    @complexity Linear in the length of the input. The parser is a predictive
    LL(1) parser.

    @note A UTF-8 byte order mark is silently ignored.

    @liveexample{The example below shows how a JSON value is constructed by
    reading a serialization from a stream.,operator_deserialize}

    @sa parse(std::istream&, const parser_callback_t) for a variant with a
    parser callback function to filter values while parsing

    @since version 1.0.0
    */
    friend std::istream& operator>>(std::istream& i, basic_json& j)
    {
        parser(detail::input_adapter(i)).parse(false, j);
        return i;
    }

    /// @}

    ///////////////////////////
    // convenience functions //
    ///////////////////////////

    /*!
    @brief return the type as string

    Returns the type name as string to be used in error messages - usually to
    indicate that a function was called on a wrong JSON type.

    @return a string representation of a the @a m_type member:
            Value type  | return value
            ----------- | -------------
            null        | `"null"`
            boolean     | `"boolean"`
            string      | `"string"`
            number      | `"number"` (for all number types)
            object      | `"object"`
            array       | `"array"`
            discarded   | `"discarded"`

    @exceptionsafety No-throw guarantee: this function never throws exceptions.

    @complexity Constant.

    @liveexample{The following code exemplifies `type_name()` for all JSON
    types.,type_name}

    @sa @ref type() -- return the type of the JSON value
    @sa @ref operator value_t() -- return the type of the JSON value (implicit)

    @since version 1.0.0, public since 2.1.0, `const char*` and `noexcept`
    since 3.0.0
    */
    const char* type_name() const noexcept
    {
        {
            switch (m_type)
            {
                case value_t::null:
                    return "null";
                case value_t::object:
                    return "object";
                case value_t::array:
                    return "array";
                case value_t::string:
                    return "string";
                case value_t::boolean:
                    return "boolean";
                case value_t::discarded:
                    return "discarded";
                default:
                    return "number";
            }
        }
    }


  private:
    //////////////////////
    // member variables //
    //////////////////////

    /// the type of the current element
    value_t m_type = value_t::null;

    /// the value of the current element
    json_value m_value = {};

    //////////////////////////////////////////
    // binary serialization/deserialization //
    //////////////////////////////////////////

    /// @name binary serialization/deserialization support
    /// @{

  public:
    /*!
    @brief create a CBOR serialization of a given JSON value

    Serializes a given JSON value @a j to a byte vector using the CBOR (Concise
    Binary Object Representation) serialization format. CBOR is a binary
    serialization format which aims to be more compact than JSON itself, yet
    more efficient to parse.

    The library uses the following mapping from JSON values types to
    CBOR types according to the CBOR specification (RFC 7049):

    JSON value type | value/range                                | CBOR type                          | first byte
    --------------- | ------------------------------------------ | ---------------------------------- | ---------------
    null            | `null`                                     | Null                               | 0xF6
    boolean         | `true`                                     | True                               | 0xF5
    boolean         | `false`                                    | False                              | 0xF4
    number_integer  | -9223372036854775808..-2147483649          | Negative integer (8 bytes follow)  | 0x3B
    number_integer  | -2147483648..-32769                        | Negative integer (4 bytes follow)  | 0x3A
    number_integer  | -32768..-129                               | Negative integer (2 bytes follow)  | 0x39
    number_integer  | -128..-25                                  | Negative integer (1 byte follow)   | 0x38
    number_integer  | -24..-1                                    | Negative integer                   | 0x20..0x37
    number_integer  | 0..23                                      | Integer                            | 0x00..0x17
    number_integer  | 24..255                                    | Unsigned integer (1 byte follow)   | 0x18
    number_integer  | 256..65535                                 | Unsigned integer (2 bytes follow)  | 0x19
    number_integer  | 65536..4294967295                          | Unsigned integer (4 bytes follow)  | 0x1A
    number_integer  | 4294967296..18446744073709551615           | Unsigned integer (8 bytes follow)  | 0x1B
    number_unsigned | 0..23                                      | Integer                            | 0x00..0x17
    number_unsigned | 24..255                                    | Unsigned integer (1 byte follow)   | 0x18
    number_unsigned | 256..65535                                 | Unsigned integer (2 bytes follow)  | 0x19
    number_unsigned | 65536..4294967295                          | Unsigned integer (4 bytes follow)  | 0x1A
    number_unsigned | 4294967296..18446744073709551615           | Unsigned integer (8 bytes follow)  | 0x1B
    number_float    | *any value*                                | Double-Precision Float             | 0xFB
    string          | *length*: 0..23                            | UTF-8 string                       | 0x60..0x77
    string          | *length*: 23..255                          | UTF-8 string (1 byte follow)       | 0x78
    string          | *length*: 256..65535                       | UTF-8 string (2 bytes follow)      | 0x79
    string          | *length*: 65536..4294967295                | UTF-8 string (4 bytes follow)      | 0x7A
    string          | *length*: 4294967296..18446744073709551615 | UTF-8 string (8 bytes follow)      | 0x7B
    array           | *size*: 0..23                              | array                              | 0x80..0x97
    array           | *size*: 23..255                            | array (1 byte follow)              | 0x98
    array           | *size*: 256..65535                         | array (2 bytes follow)             | 0x99
    array           | *size*: 65536..4294967295                  | array (4 bytes follow)             | 0x9A
    array           | *size*: 4294967296..18446744073709551615   | array (8 bytes follow)             | 0x9B
    object          | *size*: 0..23                              | map                                | 0xA0..0xB7
    object          | *size*: 23..255                            | map (1 byte follow)                | 0xB8
    object          | *size*: 256..65535                         | map (2 bytes follow)               | 0xB9
    object          | *size*: 65536..4294967295                  | map (4 bytes follow)               | 0xBA
    object          | *size*: 4294967296..18446744073709551615   | map (8 bytes follow)               | 0xBB

    @note The mapping is **complete** in the sense that any JSON value type
          can be converted to a CBOR value.

    @note If NaN or Infinity are stored inside a JSON number, they are
          serialized properly. This behavior differs from the @ref dump()
          function which serializes NaN or Infinity to `null`.

    @note The following CBOR types are not used in the conversion:
          - byte strings (0x40..0x5F)
          - UTF-8 strings terminated by "break" (0x7F)
          - arrays terminated by "break" (0x9F)
          - maps terminated by "break" (0xBF)
          - date/time (0xC0..0xC1)
          - bignum (0xC2..0xC3)
          - decimal fraction (0xC4)
          - bigfloat (0xC5)
          - tagged items (0xC6..0xD4, 0xD8..0xDB)
          - expected conversions (0xD5..0xD7)
          - simple values (0xE0..0xF3, 0xF8)
          - undefined (0xF7)
          - half and single-precision floats (0xF9-0xFA)
          - break (0xFF)

    @param[in] j  JSON value to serialize
    @return MessagePack serialization as byte vector

    @complexity Linear in the size of the JSON value @a j.

    @liveexample{The example shows the serialization of a JSON value to a byte
    vector in CBOR format.,to_cbor}

    @sa http://cbor.io
    @sa @ref from_cbor(detail::input_adapter&&, const bool, const bool) for the
        analogous deserialization
    @sa @ref to_msgpack(const basic_json&) for the related MessagePack format
    @sa @ref to_ubjson(const basic_json&, const bool, const bool) for the
             related UBJSON format

    @since version 2.0.9
    */
    static std::vector<uint8_t> to_cbor(const basic_json& j)
    {
        std::vector<uint8_t> result;
        to_cbor(j, result);
        return result;
    }

    static void to_cbor(const basic_json& j, detail::output_adapter<uint8_t> o)
    {
        binary_writer<uint8_t>(o).write_cbor(j);
    }

    static void to_cbor(const basic_json& j, detail::output_adapter<char> o)
    {
        binary_writer<char>(o).write_cbor(j);
    }

    /*!
    @brief create a MessagePack serialization of a given JSON value

    Serializes a given JSON value @a j to a byte vector using the MessagePack
    serialization format. MessagePack is a binary serialization format which
    aims to be more compact than JSON itself, yet more efficient to parse.

    The library uses the following mapping from JSON values types to
    MessagePack types according to the MessagePack specification:

    JSON value type | value/range                       | MessagePack type | first byte
    --------------- | --------------------------------- | ---------------- | ----------
    null            | `null`                            | nil              | 0xC0
    boolean         | `true`                            | true             | 0xC3
    boolean         | `false`                           | false            | 0xC2
    number_integer  | -9223372036854775808..-2147483649 | int64            | 0xD3
    number_integer  | -2147483648..-32769               | int32            | 0xD2
    number_integer  | -32768..-129                      | int16            | 0xD1
    number_integer  | -128..-33                         | int8             | 0xD0
    number_integer  | -32..-1                           | negative fixint  | 0xE0..0xFF
    number_integer  | 0..127                            | positive fixint  | 0x00..0x7F
    number_integer  | 128..255                          | uint 8           | 0xCC
    number_integer  | 256..65535                        | uint 16          | 0xCD
    number_integer  | 65536..4294967295                 | uint 32          | 0xCE
    number_integer  | 4294967296..18446744073709551615  | uint 64          | 0xCF
    number_unsigned | 0..127                            | positive fixint  | 0x00..0x7F
    number_unsigned | 128..255                          | uint 8           | 0xCC
    number_unsigned | 256..65535                        | uint 16          | 0xCD
    number_unsigned | 65536..4294967295                 | uint 32          | 0xCE
    number_unsigned | 4294967296..18446744073709551615  | uint 64          | 0xCF
    number_float    | *any value*                       | float 64         | 0xCB
    string          | *length*: 0..31                   | fixstr           | 0xA0..0xBF
    string          | *length*: 32..255                 | str 8            | 0xD9
    string          | *length*: 256..65535              | str 16           | 0xDA
    string          | *length*: 65536..4294967295       | str 32           | 0xDB
    array           | *size*: 0..15                     | fixarray         | 0x90..0x9F
    array           | *size*: 16..65535                 | array 16         | 0xDC
    array           | *size*: 65536..4294967295         | array 32         | 0xDD
    object          | *size*: 0..15                     | fix map          | 0x80..0x8F
    object          | *size*: 16..65535                 | map 16           | 0xDE
    object          | *size*: 65536..4294967295         | map 32           | 0xDF

    @note The mapping is **complete** in the sense that any JSON value type
          can be converted to a MessagePack value.

    @note The following values can **not** be converted to a MessagePack value:
          - strings with more than 4294967295 bytes
          - arrays with more than 4294967295 elements
          - objects with more than 4294967295 elements

    @note The following MessagePack types are not used in the conversion:
          - bin 8 - bin 32 (0xC4..0xC6)
          - ext 8 - ext 32 (0xC7..0xC9)
          - float 32 (0xCA)
          - fixext 1 - fixext 16 (0xD4..0xD8)

    @note Any MessagePack output created @ref to_msgpack can be successfully
          parsed by @ref from_msgpack.

    @note If NaN or Infinity are stored inside a JSON number, they are
          serialized properly. This behavior differs from the @ref dump()
          function which serializes NaN or Infinity to `null`.

    @param[in] j  JSON value to serialize
    @return MessagePack serialization as byte vector

    @complexity Linear in the size of the JSON value @a j.

    @liveexample{The example shows the serialization of a JSON value to a byte
    vector in MessagePack format.,to_msgpack}

    @sa http://msgpack.org
    @sa @ref from_msgpack for the analogous deserialization
    @sa @ref to_cbor(const basic_json& for the related CBOR format
    @sa @ref to_ubjson(const basic_json&, const bool, const bool) for the
             related UBJSON format

    @since version 2.0.9
    */
    static std::vector<uint8_t> to_msgpack(const basic_json& j)
    {
        std::vector<uint8_t> result;
        to_msgpack(j, result);
        return result;
    }

    static void to_msgpack(const basic_json& j, detail::output_adapter<uint8_t> o)
    {
        binary_writer<uint8_t>(o).write_msgpack(j);
    }

    static void to_msgpack(const basic_json& j, detail::output_adapter<char> o)
    {
        binary_writer<char>(o).write_msgpack(j);
    }

    /*!
    @brief create a UBJSON serialization of a given JSON value

    Serializes a given JSON value @a j to a byte vector using the UBJSON
    (Universal Binary JSON) serialization format. UBJSON aims to be more compact
    than JSON itself, yet more efficient to parse.

    The library uses the following mapping from JSON values types to
    UBJSON types according to the UBJSON specification:

    JSON value type | value/range                       | UBJSON type | marker
    --------------- | --------------------------------- | ----------- | ------
    null            | `null`                            | null        | `Z`
    boolean         | `true`                            | true        | `T`
    boolean         | `false`                           | false       | `F`
    number_integer  | -9223372036854775808..-2147483649 | int64       | `L`
    number_integer  | -2147483648..-32769               | int32       | `l`
    number_integer  | -32768..-129                      | int16       | `I`
    number_integer  | -128..127                         | int8        | `i`
    number_integer  | 128..255                          | uint8       | `U`
    number_integer  | 256..32767                        | int16       | `I`
    number_integer  | 32768..2147483647                 | int32       | `l`
    number_integer  | 2147483648..9223372036854775807   | int64       | `L`
    number_unsigned | 0..127                            | int8        | `i`
    number_unsigned | 128..255                          | uint8       | `U`
    number_unsigned | 256..32767                        | int16       | `I`
    number_unsigned | 32768..2147483647                 | int32       | `l`
    number_unsigned | 2147483648..9223372036854775807   | int64       | `L`
    number_float    | *any value*                       | float64     | `D`
    string          | *with shortest length indicator*  | string      | `S`
    array           | *see notes on optimized format*   | array       | `[`
    object          | *see notes on optimized format*   | map         | `{`

    @note The mapping is **complete** in the sense that any JSON value type
          can be converted to a UBJSON value.

    @note The following values can **not** be converted to a UBJSON value:
          - strings with more than 9223372036854775807 bytes (theoretical)
          - unsigned integer numbers above 9223372036854775807

    @note The following markers are not used in the conversion:
          - `Z`: no-op values are not created.
          - `C`: single-byte strings are serialized with `S` markers.

    @note Any UBJSON output created @ref to_ubjson can be successfully parsed
          by @ref from_ubjson.

    @note If NaN or Infinity are stored inside a JSON number, they are
          serialized properly. This behavior differs from the @ref dump()
          function which serializes NaN or Infinity to `null`.

    @note The optimized formats for containers are supported: Parameter
          @a use_size adds size information to the beginning of a container and
          removes the closing marker. Parameter @a use_type further checks
          whether all elements of a container have the same type and adds the
          type marker to the beginning of the container. The @a use_type
          parameter must only be used together with @a use_size = true. Note
          that @a use_size = true alone may result in larger representations -
          the benefit of this parameter is that the receiving side is
          immediately informed on the number of elements of the container.

    @param[in] j  JSON value to serialize
    @param[in] use_size  whether to add size annotations to container types
    @param[in] use_type  whether to add type annotations to container types
                         (must be combined with @a use_size = true)
    @return UBJSON serialization as byte vector

    @complexity Linear in the size of the JSON value @a j.

    @liveexample{The example shows the serialization of a JSON value to a byte
    vector in UBJSON format.,to_ubjson}

    @sa http://ubjson.org
    @sa @ref from_ubjson(detail::input_adapter&&, const bool, const bool) for the
        analogous deserialization
    @sa @ref to_cbor(const basic_json& for the related CBOR format
    @sa @ref to_msgpack(const basic_json&) for the related MessagePack format

    @since version 3.1.0
    */
    static std::vector<uint8_t> to_ubjson(const basic_json& j,
                                          const bool use_size = false,
                                          const bool use_type = false)
    {
        std::vector<uint8_t> result;
        to_ubjson(j, result, use_size, use_type);
        return result;
    }

    static void to_ubjson(const basic_json& j, detail::output_adapter<uint8_t> o,
                          const bool use_size = false, const bool use_type = false)
    {
        binary_writer<uint8_t>(o).write_ubjson(j, use_size, use_type);
    }

    static void to_ubjson(const basic_json& j, detail::output_adapter<char> o,
                          const bool use_size = false, const bool use_type = false)
    {
        binary_writer<char>(o).write_ubjson(j, use_size, use_type);
    }


    /*!
    @brief Serializes the given JSON object `j` to BSON and returns a vector
           containing the corresponding BSON-representation.

    BSON (Binary JSON) is a binary format in which zero or more ordered key/value pairs are
    stored as a single entity (a so-called document).

    The library uses the following mapping from JSON values types to BSON types:

    JSON value type | value/range                       | BSON type   | marker
    --------------- | --------------------------------- | ----------- | ------
    null            | `null`                            | null        | 0x0A
    boolean         | `true`, `false`                   | boolean     | 0x08
    number_integer  | -9223372036854775808..-2147483649 | int64       | 0x12
    number_integer  | -2147483648..2147483647           | int32       | 0x10
    number_integer  | 2147483648..9223372036854775807   | int64       | 0x12
    number_unsigned | 0..2147483647                     | int32       | 0x10
    number_unsigned | 2147483648..9223372036854775807   | int64       | 0x12
    number_unsigned | 9223372036854775808..18446744073709551615| --   | --
    number_float    | *any value*                       | double      | 0x01
    string          | *any value*                       | string      | 0x02
    array           | *any value*                       | document    | 0x04
    object          | *any value*                       | document    | 0x03

    @warning The mapping is **incomplete**, since only JSON-objects (and things
    contained therein) can be serialized to BSON.
    Also, integers larger than 9223372036854775807 cannot be serialized to BSON,
    and the keys may not contain U+0000, since they are serialized a
    zero-terminated c-strings.

    @throw out_of_range.407  if `j.is_number_unsigned() && j.get<std::uint64_t>() > 9223372036854775807`
    @throw out_of_range.409  if a key in `j` contains a NULL (U+0000)
    @throw type_error.317    if `!j.is_object()`

    @pre The input `j` is required to be an object: `j.is_object() == true`.

    @note Any BSON output created via @ref to_bson can be successfully parsed
          by @ref from_bson.

    @param[in] j  JSON value to serialize
    @return BSON serialization as byte vector

    @complexity Linear in the size of the JSON value @a j.

    @liveexample{The example shows the serialization of a JSON value to a byte
    vector in BSON format.,to_bson}

    @sa http://bsonspec.org/spec.html
    @sa @ref from_bson(detail::input_adapter&&, const bool strict) for the
        analogous deserialization
    @sa @ref to_ubjson(const basic_json&, const bool, const bool) for the
             related UBJSON format
    @sa @ref to_cbor(const basic_json&) for the related CBOR format
    @sa @ref to_msgpack(const basic_json&) for the related MessagePack format
    */
    static std::vector<uint8_t> to_bson(const basic_json& j)
    {
        std::vector<uint8_t> result;
        to_bson(j, result);
        return result;
    }

    /*!
    @brief Serializes the given JSON object `j` to BSON and forwards the
           corresponding BSON-representation to the given output_adapter `o`.
    @param j The JSON object to convert to BSON.
    @param o The output adapter that receives the binary BSON representation.
    @pre The input `j` shall be an object: `j.is_object() == true`
    @sa @ref to_bson(const basic_json&)
    */
    static void to_bson(const basic_json& j, detail::output_adapter<uint8_t> o)
    {
        binary_writer<uint8_t>(o).write_bson(j);
    }

    /*!
    @copydoc to_bson(const basic_json&, detail::output_adapter<uint8_t>)
    */
    static void to_bson(const basic_json& j, detail::output_adapter<char> o)
    {
        binary_writer<char>(o).write_bson(j);
    }


    /*!
    @brief create a JSON value from an input in CBOR format

    Deserializes a given input @a i to a JSON value using the CBOR (Concise
    Binary Object Representation) serialization format.

    The library maps CBOR types to JSON value types as follows:

    CBOR type              | JSON value type | first byte
    ---------------------- | --------------- | ----------
    Integer                | number_unsigned | 0x00..0x17
    Unsigned integer       | number_unsigned | 0x18
    Unsigned integer       | number_unsigned | 0x19
    Unsigned integer       | number_unsigned | 0x1A
    Unsigned integer       | number_unsigned | 0x1B
    Negative integer       | number_integer  | 0x20..0x37
    Negative integer       | number_integer  | 0x38
    Negative integer       | number_integer  | 0x39
    Negative integer       | number_integer  | 0x3A
    Negative integer       | number_integer  | 0x3B
    Negative integer       | number_integer  | 0x40..0x57
    UTF-8 string           | string          | 0x60..0x77
    UTF-8 string           | string          | 0x78
    UTF-8 string           | string          | 0x79
    UTF-8 string           | string          | 0x7A
    UTF-8 string           | string          | 0x7B
    UTF-8 string           | string          | 0x7F
    array                  | array           | 0x80..0x97
    array                  | array           | 0x98
    array                  | array           | 0x99
    array                  | array           | 0x9A
    array                  | array           | 0x9B
    array                  | array           | 0x9F
    map                    | object          | 0xA0..0xB7
    map                    | object          | 0xB8
    map                    | object          | 0xB9
    map                    | object          | 0xBA
    map                    | object          | 0xBB
    map                    | object          | 0xBF
    False                  | `false`         | 0xF4
    True                   | `true`          | 0xF5
    Null                   | `null`          | 0xF6
    Half-Precision Float   | number_float    | 0xF9
    Single-Precision Float | number_float    | 0xFA
    Double-Precision Float | number_float    | 0xFB

    @warning The mapping is **incomplete** in the sense that not all CBOR
             types can be converted to a JSON value. The following CBOR types
             are not supported and will yield parse errors (parse_error.112):
             - byte strings (0x40..0x5F)
             - date/time (0xC0..0xC1)
             - bignum (0xC2..0xC3)
             - decimal fraction (0xC4)
             - bigfloat (0xC5)
             - tagged items (0xC6..0xD4, 0xD8..0xDB)
             - expected conversions (0xD5..0xD7)
             - simple values (0xE0..0xF3, 0xF8)
             - undefined (0xF7)

    @warning CBOR allows map keys of any type, whereas JSON only allows
             strings as keys in object values. Therefore, CBOR maps with keys
             other than UTF-8 strings are rejected (parse_error.113).

    @note Any CBOR output created @ref to_cbor can be successfully parsed by
          @ref from_cbor.

    @param[in] i  an input in CBOR format convertible to an input adapter
    @param[in] strict  whether to expect the input to be consumed until EOF
                       (true by default)
    @param[in] allow_exceptions  whether to throw exceptions in case of a
    parse error (optional, true by default)

    @return deserialized JSON value; in case of a parse error and
            @a allow_exceptions set to `false`, the return value will be
            value_t::discarded.

    @throw parse_error.110 if the given input ends prematurely or the end of
    file was not reached when @a strict was set to true
    @throw parse_error.112 if unsupported features from CBOR were
    used in the given input @a v or if the input is not valid CBOR
    @throw parse_error.113 if a string was expected as map key, but not found

    @complexity Linear in the size of the input @a i.

    @liveexample{The example shows the deserialization of a byte vector in CBOR
    format to a JSON value.,from_cbor}

    @sa http://cbor.io
    @sa @ref to_cbor(const basic_json&) for the analogous serialization
    @sa @ref from_msgpack(detail::input_adapter&&, const bool, const bool) for the
        related MessagePack format
    @sa @ref from_ubjson(detail::input_adapter&&, const bool, const bool) for the
        related UBJSON format

    @since version 2.0.9; parameter @a start_index since 2.1.1; changed to
           consume input adapters, removed start_index parameter, and added
           @a strict parameter since 3.0.0; added @a allow_exceptions parameter
           since 3.2.0
    */
    JSON_NODISCARD
    static basic_json from_cbor(detail::input_adapter&& i,
                                const bool strict = true,
                                const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        const bool res = binary_reader(detail::input_adapter(i)).sax_parse(input_format_t::cbor, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }

    /*!
    @copydoc from_cbor(detail::input_adapter&&, const bool, const bool)
    */
    template<typename A1, typename A2,
             detail::enable_if_t<std::is_constructible<detail::input_adapter, A1, A2>::value, int> = 0>
    JSON_NODISCARD
    static basic_json from_cbor(A1 && a1, A2 && a2,
                                const bool strict = true,
                                const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        const bool res = binary_reader(detail::input_adapter(std::forward<A1>(a1), std::forward<A2>(a2))).sax_parse(input_format_t::cbor, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }

    /*!
    @brief create a JSON value from an input in MessagePack format

    Deserializes a given input @a i to a JSON value using the MessagePack
    serialization format.

    The library maps MessagePack types to JSON value types as follows:

    MessagePack type | JSON value type | first byte
    ---------------- | --------------- | ----------
    positive fixint  | number_unsigned | 0x00..0x7F
    fixmap           | object          | 0x80..0x8F
    fixarray         | array           | 0x90..0x9F
    fixstr           | string          | 0xA0..0xBF
    nil              | `null`          | 0xC0
    false            | `false`         | 0xC2
    true             | `true`          | 0xC3
    float 32         | number_float    | 0xCA
    float 64         | number_float    | 0xCB
    uint 8           | number_unsigned | 0xCC
    uint 16          | number_unsigned | 0xCD
    uint 32          | number_unsigned | 0xCE
    uint 64          | number_unsigned | 0xCF
    int 8            | number_integer  | 0xD0
    int 16           | number_integer  | 0xD1
    int 32           | number_integer  | 0xD2
    int 64           | number_integer  | 0xD3
    str 8            | string          | 0xD9
    str 16           | string          | 0xDA
    str 32           | string          | 0xDB
    array 16         | array           | 0xDC
    array 32         | array           | 0xDD
    map 16           | object          | 0xDE
    map 32           | object          | 0xDF
    negative fixint  | number_integer  | 0xE0-0xFF

    @warning The mapping is **incomplete** in the sense that not all
             MessagePack types can be converted to a JSON value. The following
             MessagePack types are not supported and will yield parse errors:
              - bin 8 - bin 32 (0xC4..0xC6)
              - ext 8 - ext 32 (0xC7..0xC9)
              - fixext 1 - fixext 16 (0xD4..0xD8)

    @note Any MessagePack output created @ref to_msgpack can be successfully
          parsed by @ref from_msgpack.

    @param[in] i  an input in MessagePack format convertible to an input
                  adapter
    @param[in] strict  whether to expect the input to be consumed until EOF
                       (true by default)
    @param[in] allow_exceptions  whether to throw exceptions in case of a
    parse error (optional, true by default)

    @return deserialized JSON value; in case of a parse error and
            @a allow_exceptions set to `false`, the return value will be
            value_t::discarded.

    @throw parse_error.110 if the given input ends prematurely or the end of
    file was not reached when @a strict was set to true
    @throw parse_error.112 if unsupported features from MessagePack were
    used in the given input @a i or if the input is not valid MessagePack
    @throw parse_error.113 if a string was expected as map key, but not found

    @complexity Linear in the size of the input @a i.

    @liveexample{The example shows the deserialization of a byte vector in
    MessagePack format to a JSON value.,from_msgpack}

    @sa http://msgpack.org
    @sa @ref to_msgpack(const basic_json&) for the analogous serialization
    @sa @ref from_cbor(detail::input_adapter&&, const bool, const bool) for the
        related CBOR format
    @sa @ref from_ubjson(detail::input_adapter&&, const bool, const bool) for
        the related UBJSON format
    @sa @ref from_bson(detail::input_adapter&&, const bool, const bool) for
        the related BSON format

    @since version 2.0.9; parameter @a start_index since 2.1.1; changed to
           consume input adapters, removed start_index parameter, and added
           @a strict parameter since 3.0.0; added @a allow_exceptions parameter
           since 3.2.0
    */
    JSON_NODISCARD
    static basic_json from_msgpack(detail::input_adapter&& i,
                                   const bool strict = true,
                                   const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        const bool res = binary_reader(detail::input_adapter(i)).sax_parse(input_format_t::msgpack, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }

    /*!
    @copydoc from_msgpack(detail::input_adapter&&, const bool, const bool)
    */
    template<typename A1, typename A2,
             detail::enable_if_t<std::is_constructible<detail::input_adapter, A1, A2>::value, int> = 0>
    JSON_NODISCARD
    static basic_json from_msgpack(A1 && a1, A2 && a2,
                                   const bool strict = true,
                                   const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        const bool res = binary_reader(detail::input_adapter(std::forward<A1>(a1), std::forward<A2>(a2))).sax_parse(input_format_t::msgpack, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }

    /*!
    @brief create a JSON value from an input in UBJSON format

    Deserializes a given input @a i to a JSON value using the UBJSON (Universal
    Binary JSON) serialization format.

    The library maps UBJSON types to JSON value types as follows:

    UBJSON type | JSON value type                         | marker
    ----------- | --------------------------------------- | ------
    no-op       | *no value, next value is read*          | `N`
    null        | `null`                                  | `Z`
    false       | `false`                                 | `F`
    true        | `true`                                  | `T`
    float32     | number_float                            | `d`
    float64     | number_float                            | `D`
    uint8       | number_unsigned                         | `U`
    int8        | number_integer                          | `i`
    int16       | number_integer                          | `I`
    int32       | number_integer                          | `l`
    int64       | number_integer                          | `L`
    string      | string                                  | `S`
    char        | string                                  | `C`
    array       | array (optimized values are supported)  | `[`
    object      | object (optimized values are supported) | `{`

    @note The mapping is **complete** in the sense that any UBJSON value can
          be converted to a JSON value.

    @param[in] i  an input in UBJSON format convertible to an input adapter
    @param[in] strict  whether to expect the input to be consumed until EOF
                       (true by default)
    @param[in] allow_exceptions  whether to throw exceptions in case of a
    parse error (optional, true by default)

    @return deserialized JSON value; in case of a parse error and
            @a allow_exceptions set to `false`, the return value will be
            value_t::discarded.

    @throw parse_error.110 if the given input ends prematurely or the end of
    file was not reached when @a strict was set to true
    @throw parse_error.112 if a parse error occurs
    @throw parse_error.113 if a string could not be parsed successfully

    @complexity Linear in the size of the input @a i.

    @liveexample{The example shows the deserialization of a byte vector in
    UBJSON format to a JSON value.,from_ubjson}

    @sa http://ubjson.org
    @sa @ref to_ubjson(const basic_json&, const bool, const bool) for the
             analogous serialization
    @sa @ref from_cbor(detail::input_adapter&&, const bool, const bool) for the
        related CBOR format
    @sa @ref from_msgpack(detail::input_adapter&&, const bool, const bool) for
        the related MessagePack format
    @sa @ref from_bson(detail::input_adapter&&, const bool, const bool) for
        the related BSON format

    @since version 3.1.0; added @a allow_exceptions parameter since 3.2.0
    */
    JSON_NODISCARD
    static basic_json from_ubjson(detail::input_adapter&& i,
                                  const bool strict = true,
                                  const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        const bool res = binary_reader(detail::input_adapter(i)).sax_parse(input_format_t::ubjson, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }

    /*!
    @copydoc from_ubjson(detail::input_adapter&&, const bool, const bool)
    */
    template<typename A1, typename A2,
             detail::enable_if_t<std::is_constructible<detail::input_adapter, A1, A2>::value, int> = 0>
    JSON_NODISCARD
    static basic_json from_ubjson(A1 && a1, A2 && a2,
                                  const bool strict = true,
                                  const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        const bool res = binary_reader(detail::input_adapter(std::forward<A1>(a1), std::forward<A2>(a2))).sax_parse(input_format_t::ubjson, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }

    /*!
    @brief Create a JSON value from an input in BSON format

    Deserializes a given input @a i to a JSON value using the BSON (Binary JSON)
    serialization format.

    The library maps BSON record types to JSON value types as follows:

    BSON type       | BSON marker byte | JSON value type
    --------------- | ---------------- | ---------------------------
    double          | 0x01             | number_float
    string          | 0x02             | string
    document        | 0x03             | object
    array           | 0x04             | array
    binary          | 0x05             | still unsupported
    undefined       | 0x06             | still unsupported
    ObjectId        | 0x07             | still unsupported
    boolean         | 0x08             | boolean
    UTC Date-Time   | 0x09             | still unsupported
    null            | 0x0A             | null
    Regular Expr.   | 0x0B             | still unsupported
    DB Pointer      | 0x0C             | still unsupported
    JavaScript Code | 0x0D             | still unsupported
    Symbol          | 0x0E             | still unsupported
    JavaScript Code | 0x0F             | still unsupported
    int32           | 0x10             | number_integer
    Timestamp       | 0x11             | still unsupported
    128-bit decimal float | 0x13       | still unsupported
    Max Key         | 0x7F             | still unsupported
    Min Key         | 0xFF             | still unsupported

    @warning The mapping is **incomplete**. The unsupported mappings
             are indicated in the table above.

    @param[in] i  an input in BSON format convertible to an input adapter
    @param[in] strict  whether to expect the input to be consumed until EOF
                       (true by default)
    @param[in] allow_exceptions  whether to throw exceptions in case of a
    parse error (optional, true by default)

    @return deserialized JSON value; in case of a parse error and
            @a allow_exceptions set to `false`, the return value will be
            value_t::discarded.

    @throw parse_error.114 if an unsupported BSON record type is encountered

    @complexity Linear in the size of the input @a i.

    @liveexample{The example shows the deserialization of a byte vector in
    BSON format to a JSON value.,from_bson}

    @sa http://bsonspec.org/spec.html
    @sa @ref to_bson(const basic_json&) for the analogous serialization
    @sa @ref from_cbor(detail::input_adapter&&, const bool, const bool) for the
        related CBOR format
    @sa @ref from_msgpack(detail::input_adapter&&, const bool, const bool) for
        the related MessagePack format
    @sa @ref from_ubjson(detail::input_adapter&&, const bool, const bool) for the
        related UBJSON format
    */
    JSON_NODISCARD
    static basic_json from_bson(detail::input_adapter&& i,
                                const bool strict = true,
                                const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        const bool res = binary_reader(detail::input_adapter(i)).sax_parse(input_format_t::bson, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }

    /*!
    @copydoc from_bson(detail::input_adapter&&, const bool, const bool)
    */
    template<typename A1, typename A2,
             detail::enable_if_t<std::is_constructible<detail::input_adapter, A1, A2>::value, int> = 0>
    JSON_NODISCARD
    static basic_json from_bson(A1 && a1, A2 && a2,
                                const bool strict = true,
                                const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        const bool res = binary_reader(detail::input_adapter(std::forward<A1>(a1), std::forward<A2>(a2))).sax_parse(input_format_t::bson, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }



    /// @}

    //////////////////////////
    // JSON Pointer support //
    //////////////////////////

    /// @name JSON Pointer functions
    /// @{

    /*!
    @brief access specified element via JSON Pointer

    Uses a JSON pointer to retrieve a reference to the respective JSON value.
    No bound checking is performed. Similar to @ref operator[](const typename
    object_t::key_type&), `null` values are created in arrays and objects if
    necessary.

    In particular:
    - If the JSON pointer points to an object key that does not exist, it
      is created an filled with a `null` value before a reference to it
      is returned.
    - If the JSON pointer points to an array index that does not exist, it
      is created an filled with a `null` value before a reference to it
      is returned. All indices between the current maximum and the given
      index are also filled with `null`.
    - The special value `-` is treated as a synonym for the index past the
      end.

    @param[in] ptr  a JSON pointer

    @return reference to the element pointed to by @a ptr

    @complexity Constant.

    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    @throw out_of_range.404  if the JSON pointer can not be resolved

    @liveexample{The behavior is shown in the example.,operatorjson_pointer}

    @since version 2.0.0
    */
    reference operator[](const json_pointer& ptr)
    {
        return ptr.get_unchecked(this);
    }

    /*!
    @brief access specified element via JSON Pointer

    Uses a JSON pointer to retrieve a reference to the respective JSON value.
    No bound checking is performed. The function does not change the JSON
    value; no `null` values are created. In particular, the the special value
    `-` yields an exception.

    @param[in] ptr  JSON pointer to the desired element

    @return const reference to the element pointed to by @a ptr

    @complexity Constant.

    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    @throw out_of_range.402  if the array index '-' is used
    @throw out_of_range.404  if the JSON pointer can not be resolved

    @liveexample{The behavior is shown in the example.,operatorjson_pointer_const}

    @since version 2.0.0
    */
    const_reference operator[](const json_pointer& ptr) const
    {
        return ptr.get_unchecked(this);
    }

    /*!
    @brief access specified element via JSON Pointer

    Returns a reference to the element at with specified JSON pointer @a ptr,
    with bounds checking.

    @param[in] ptr  JSON pointer to the desired element

    @return reference to the element pointed to by @a ptr

    @throw parse_error.106 if an array index in the passed JSON pointer @a ptr
    begins with '0'. See example below.

    @throw parse_error.109 if an array index in the passed JSON pointer @a ptr
    is not a number. See example below.

    @throw out_of_range.401 if an array index in the passed JSON pointer @a ptr
    is out of range. See example below.

    @throw out_of_range.402 if the array index '-' is used in the passed JSON
    pointer @a ptr. As `at` provides checked access (and no elements are
    implicitly inserted), the index '-' is always invalid. See example below.

    @throw out_of_range.403 if the JSON pointer describes a key of an object
    which cannot be found. See example below.

    @throw out_of_range.404 if the JSON pointer @a ptr can not be resolved.
    See example below.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @complexity Constant.

    @since version 2.0.0

    @liveexample{The behavior is shown in the example.,at_json_pointer}
    */
    reference at(const json_pointer& ptr)
    {
        return ptr.get_checked(this);
    }

    /*!
    @brief access specified element via JSON Pointer

    Returns a const reference to the element at with specified JSON pointer @a
    ptr, with bounds checking.

    @param[in] ptr  JSON pointer to the desired element

    @return reference to the element pointed to by @a ptr

    @throw parse_error.106 if an array index in the passed JSON pointer @a ptr
    begins with '0'. See example below.

    @throw parse_error.109 if an array index in the passed JSON pointer @a ptr
    is not a number. See example below.

    @throw out_of_range.401 if an array index in the passed JSON pointer @a ptr
    is out of range. See example below.

    @throw out_of_range.402 if the array index '-' is used in the passed JSON
    pointer @a ptr. As `at` provides checked access (and no elements are
    implicitly inserted), the index '-' is always invalid. See example below.

    @throw out_of_range.403 if the JSON pointer describes a key of an object
    which cannot be found. See example below.

    @throw out_of_range.404 if the JSON pointer @a ptr can not be resolved.
    See example below.

    @exceptionsafety Strong guarantee: if an exception is thrown, there are no
    changes in the JSON value.

    @complexity Constant.

    @since version 2.0.0

    @liveexample{The behavior is shown in the example.,at_json_pointer_const}
    */
    const_reference at(const json_pointer& ptr) const
    {
        return ptr.get_checked(this);
    }

    /*!
    @brief return flattened JSON value

    The function creates a JSON object whose keys are JSON pointers (see [RFC
    6901](https://tools.ietf.org/html/rfc6901)) and whose values are all
    primitive. The original JSON value can be restored using the @ref
    unflatten() function.

    @return an object that maps JSON pointers to primitive values

    @note Empty objects and arrays are flattened to `null` and will not be
          reconstructed correctly by the @ref unflatten() function.

    @complexity Linear in the size the JSON value.

    @liveexample{The following code shows how a JSON object is flattened to an
    object whose keys consist of JSON pointers.,flatten}

    @sa @ref unflatten() for the reverse function

    @since version 2.0.0
    */
    basic_json flatten() const
    {
        basic_json result(value_t::object);
        json_pointer::flatten("", *this, result);
        return result;
    }

    /*!
    @brief unflatten a previously flattened JSON value

    The function restores the arbitrary nesting of a JSON value that has been
    flattened before using the @ref flatten() function. The JSON value must
    meet certain constraints:
    1. The value must be an object.
    2. The keys must be JSON pointers (see
       [RFC 6901](https://tools.ietf.org/html/rfc6901))
    3. The mapped values must be primitive JSON types.

    @return the original JSON from a flattened version

    @note Empty objects and arrays are flattened by @ref flatten() to `null`
          values and can not unflattened to their original type. Apart from
          this example, for a JSON value `j`, the following is always true:
          `j == j.flatten().unflatten()`.

    @complexity Linear in the size the JSON value.

    @throw type_error.314  if value is not an object
    @throw type_error.315  if object values are not primitive

    @liveexample{The following code shows how a flattened JSON object is
    unflattened into the original nested JSON object.,unflatten}

    @sa @ref flatten() for the reverse function

    @since version 2.0.0
    */
    basic_json unflatten() const
    {
        return json_pointer::unflatten(*this);
    }

    /// @}

    //////////////////////////
    // JSON Patch functions //
    //////////////////////////

    /// @name JSON Patch functions
    /// @{

    /*!
    @brief applies a JSON patch

    [JSON Patch](http://jsonpatch.com) defines a JSON document structure for
    expressing a sequence of operations to apply to a JSON) document. With
    this function, a JSON Patch is applied to the current JSON value by
    executing all operations from the patch.

    @param[in] json_patch  JSON patch document
    @return patched document

    @note The application of a patch is atomic: Either all operations succeed
          and the patched document is returned or an exception is thrown. In
          any case, the original value is not changed: the patch is applied
          to a copy of the value.

    @throw parse_error.104 if the JSON patch does not consist of an array of
    objects

    @throw parse_error.105 if the JSON patch is malformed (e.g., mandatory
    attributes are missing); example: `"operation add must have member path"`

    @throw out_of_range.401 if an array index is out of range.

    @throw out_of_range.403 if a JSON pointer inside the patch could not be
    resolved successfully in the current JSON value; example: `"key baz not
    found"`

    @throw out_of_range.405 if JSON pointer has no parent ("add", "remove",
    "move")

    @throw other_error.501 if "test" operation was unsuccessful

    @complexity Linear in the size of the JSON value and the length of the
    JSON patch. As usually only a fraction of the JSON value is affected by
    the patch, the complexity can usually be neglected.

    @liveexample{The following code shows how a JSON patch is applied to a
    value.,patch}

    @sa @ref diff -- create a JSON patch by comparing two JSON values

    @sa [RFC 6902 (JSON Patch)](https://tools.ietf.org/html/rfc6902)
    @sa [RFC 6901 (JSON Pointer)](https://tools.ietf.org/html/rfc6901)

    @since version 2.0.0
    */
    basic_json patch(const basic_json& json_patch) const
    {
        // make a working copy to apply the patch to
        basic_json result = *this;

        // the valid JSON Patch operations
        enum class patch_operations {add, remove, replace, move, copy, test, invalid};

        const auto get_op = [](const std::string & op)
        {
            if (op == "add")
            {
                return patch_operations::add;
            }
            if (op == "remove")
            {
                return patch_operations::remove;
            }
            if (op == "replace")
            {
                return patch_operations::replace;
            }
            if (op == "move")
            {
                return patch_operations::move;
            }
            if (op == "copy")
            {
                return patch_operations::copy;
            }
            if (op == "test")
            {
                return patch_operations::test;
            }

            return patch_operations::invalid;
        };

        // wrapper for "add" operation; add value at ptr
        const auto operation_add = [&result](json_pointer & ptr, basic_json val)
        {
            // adding to the root of the target document means replacing it
            if (ptr.empty())
            {
                result = val;
                return;
            }

            // make sure the top element of the pointer exists
            json_pointer top_pointer = ptr.top();
            if (top_pointer != ptr)
            {
                result.at(top_pointer);
            }

            // get reference to parent of JSON pointer ptr
            const auto last_path = ptr.back();
            ptr.pop_back();
            basic_json& parent = result[ptr];

            switch (parent.m_type)
            {
                case value_t::null:
                case value_t::object:
                {
                    // use operator[] to add value
                    parent[last_path] = val;
                    break;
                }

                case value_t::array:
                {
                    if (last_path == "-")
                    {
                        // special case: append to back
                        parent.push_back(val);
                    }
                    else
                    {
                        const auto idx = json_pointer::array_index(last_path);
                        if (JSON_UNLIKELY(static_cast<size_type>(idx) > parent.size()))
                        {
                            // avoid undefined behavior
                            JSON_THROW(out_of_range::create(401, "array index " + std::to_string(idx) + " is out of range"));
                        }

                        // default case: insert add offset
                        parent.insert(parent.begin() + static_cast<difference_type>(idx), val);
                    }
                    break;
                }

                // if there exists a parent it cannot be primitive
                default:            // LCOV_EXCL_LINE
                    assert(false);  // LCOV_EXCL_LINE
            }
        };

        // wrapper for "remove" operation; remove value at ptr
        const auto operation_remove = [&result](json_pointer & ptr)
        {
            // get reference to parent of JSON pointer ptr
            const auto last_path = ptr.back();
            ptr.pop_back();
            basic_json& parent = result.at(ptr);

            // remove child
            if (parent.is_object())
            {
                // perform range check
                auto it = parent.find(last_path);
                if (JSON_LIKELY(it != parent.end()))
                {
                    parent.erase(it);
                }
                else
                {
                    JSON_THROW(out_of_range::create(403, "key '" + last_path + "' not found"));
                }
            }
            else if (parent.is_array())
            {
                // note erase performs range check
                parent.erase(static_cast<size_type>(json_pointer::array_index(last_path)));
            }
        };

        // type check: top level value must be an array
        if (JSON_UNLIKELY(not json_patch.is_array()))
        {
            JSON_THROW(parse_error::create(104, 0, "JSON patch must be an array of objects"));
        }

        // iterate and apply the operations
        for (const auto& val : json_patch)
        {
            // wrapper to get a value for an operation
            const auto get_value = [&val](const std::string & op,
                                          const std::string & member,
                                          bool string_type) -> basic_json &
            {
                // find value
                auto it = val.m_value.object->find(member);

                // context-sensitive error message
                const auto error_msg = (op == "op") ? "operation" : "operation '" + op + "'";

                // check if desired value is present
                if (JSON_UNLIKELY(it == val.m_value.object->end()))
                {
                    JSON_THROW(parse_error::create(105, 0, error_msg + " must have member '" + member + "'"));
                }

                // check if result is of type string
                if (JSON_UNLIKELY(string_type and not it->second.is_string()))
                {
                    JSON_THROW(parse_error::create(105, 0, error_msg + " must have string member '" + member + "'"));
                }

                // no error: return value
                return it->second;
            };

            // type check: every element of the array must be an object
            if (JSON_UNLIKELY(not val.is_object()))
            {
                JSON_THROW(parse_error::create(104, 0, "JSON patch must be an array of objects"));
            }

            // collect mandatory members
            const std::string op = get_value("op", "op", true);
            const std::string path = get_value(op, "path", true);
            json_pointer ptr(path);

            switch (get_op(op))
            {
                case patch_operations::add:
                {
                    operation_add(ptr, get_value("add", "value", false));
                    break;
                }

                case patch_operations::remove:
                {
                    operation_remove(ptr);
                    break;
                }

                case patch_operations::replace:
                {
                    // the "path" location must exist - use at()
                    result.at(ptr) = get_value("replace", "value", false);
                    break;
                }

                case patch_operations::move:
                {
                    const std::string from_path = get_value("move", "from", true);
                    json_pointer from_ptr(from_path);

                    // the "from" location must exist - use at()
                    basic_json v = result.at(from_ptr);

                    // The move operation is functionally identical to a
                    // "remove" operation on the "from" location, followed
                    // immediately by an "add" operation at the target
                    // location with the value that was just removed.
                    operation_remove(from_ptr);
                    operation_add(ptr, v);
                    break;
                }

                case patch_operations::copy:
                {
                    const std::string from_path = get_value("copy", "from", true);
                    const json_pointer from_ptr(from_path);

                    // the "from" location must exist - use at()
                    basic_json v = result.at(from_ptr);

                    // The copy is functionally identical to an "add"
                    // operation at the target location using the value
                    // specified in the "from" member.
                    operation_add(ptr, v);
                    break;
                }

                case patch_operations::test:
                {
                    bool success = false;
                    JSON_TRY
                    {
                        // check if "value" matches the one at "path"
                        // the "path" location must exist - use at()
                        success = (result.at(ptr) == get_value("test", "value", false));
                    }
                    JSON_INTERNAL_CATCH (out_of_range&)
                    {
                        // ignore out of range errors: success remains false
                    }

                    // throw an exception if test fails
                    if (JSON_UNLIKELY(not success))
                    {
                        JSON_THROW(other_error::create(501, "unsuccessful: " + val.dump()));
                    }

                    break;
                }

                default:
                {
                    // op must be "add", "remove", "replace", "move", "copy", or
                    // "test"
                    JSON_THROW(parse_error::create(105, 0, "operation value '" + op + "' is invalid"));
                }
            }
        }

        return result;
    }

    /*!
    @brief creates a diff as a JSON patch

    Creates a [JSON Patch](http://jsonpatch.com) so that value @a source can
    be changed into the value @a target by calling @ref patch function.

    @invariant For two JSON values @a source and @a target, the following code
    yields always `true`:
    @code {.cpp}
    source.patch(diff(source, target)) == target;
    @endcode

    @note Currently, only `remove`, `add`, and `replace` operations are
          generated.

    @param[in] source  JSON value to compare from
    @param[in] target  JSON value to compare against
    @param[in] path    helper value to create JSON pointers

    @return a JSON patch to convert the @a source to @a target

    @complexity Linear in the lengths of @a source and @a target.

    @liveexample{The following code shows how a JSON patch is created as a
    diff for two JSON values.,diff}

    @sa @ref patch -- apply a JSON patch
    @sa @ref merge_patch -- apply a JSON Merge Patch

    @sa [RFC 6902 (JSON Patch)](https://tools.ietf.org/html/rfc6902)

    @since version 2.0.0
    */
    JSON_NODISCARD
    static basic_json diff(const basic_json& source, const basic_json& target,
                           const std::string& path = "")
    {
        // the patch
        basic_json result(value_t::array);

        // if the values are the same, return empty patch
        if (source == target)
        {
            return result;
        }

        if (source.type() != target.type())
        {
            // different types: replace value
            result.push_back(
            {
                {"op", "replace"}, {"path", path}, {"value", target}
            });
            return result;
        }

        switch (source.type())
        {
            case value_t::array:
            {
                // first pass: traverse common elements
                std::size_t i = 0;
                while (i < source.size() and i < target.size())
                {
                    // recursive call to compare array values at index i
                    auto temp_diff = diff(source[i], target[i], path + "/" + std::to_string(i));
                    result.insert(result.end(), temp_diff.begin(), temp_diff.end());
                    ++i;
                }

                // i now reached the end of at least one array
                // in a second pass, traverse the remaining elements

                // remove my remaining elements
                const auto end_index = static_cast<difference_type>(result.size());
                while (i < source.size())
                {
                    // add operations in reverse order to avoid invalid
                    // indices
                    result.insert(result.begin() + end_index, object(
                    {
                        {"op", "remove"},
                        {"path", path + "/" + std::to_string(i)}
                    }));
                    ++i;
                }

                // add other remaining elements
                while (i < target.size())
                {
                    result.push_back(
                    {
                        {"op", "add"},
                        {"path", path + "/" + std::to_string(i)},
                        {"value", target[i]}
                    });
                    ++i;
                }

                break;
            }

            case value_t::object:
            {
                // first pass: traverse this object's elements
                for (auto it = source.cbegin(); it != source.cend(); ++it)
                {
                    // escape the key name to be used in a JSON patch
                    const auto key = json_pointer::escape(it.key());

                    if (target.find(it.key()) != target.end())
                    {
                        // recursive call to compare object values at key it
                        auto temp_diff = diff(it.value(), target[it.key()], path + "/" + key);
                        result.insert(result.end(), temp_diff.begin(), temp_diff.end());
                    }
                    else
                    {
                        // found a key that is not in o -> remove it
                        result.push_back(object(
                        {
                            {"op", "remove"}, {"path", path + "/" + key}
                        }));
                    }
                }

                // second pass: traverse other object's elements
                for (auto it = target.cbegin(); it != target.cend(); ++it)
                {
                    if (source.find(it.key()) == source.end())
                    {
                        // found a key that is not in this -> add it
                        const auto key = json_pointer::escape(it.key());
                        result.push_back(
                        {
                            {"op", "add"}, {"path", path + "/" + key},
                            {"value", it.value()}
                        });
                    }
                }

                break;
            }

            default:
            {
                // both primitive type: replace value
                result.push_back(
                {
                    {"op", "replace"}, {"path", path}, {"value", target}
                });
                break;
            }
        }

        return result;
    }

    /// @}

    ////////////////////////////////
    // JSON Merge Patch functions //
    ////////////////////////////////

    /// @name JSON Merge Patch functions
    /// @{

    /*!
    @brief applies a JSON Merge Patch

    The merge patch format is primarily intended for use with the HTTP PATCH
    method as a means of describing a set of modifications to a target
    resource's content. This function applies a merge patch to the current
    JSON value.

    The function implements the following algorithm from Section 2 of
    [RFC 7396 (JSON Merge Patch)](https://tools.ietf.org/html/rfc7396):

    ```
    define MergePatch(Target, Patch):
      if Patch is an Object:
        if Target is not an Object:
          Target = {} // Ignore the contents and set it to an empty Object
        for each Name/Value pair in Patch:
          if Value is null:
            if Name exists in Target:
              remove the Name/Value pair from Target
          else:
            Target[Name] = MergePatch(Target[Name], Value)
        return Target
      else:
        return Patch
    ```

    Thereby, `Target` is the current object; that is, the patch is applied to
    the current value.

    @param[in] apply_patch  the patch to apply

    @complexity Linear in the lengths of @a patch.

    @liveexample{The following code shows how a JSON Merge Patch is applied to
    a JSON document.,merge_patch}

    @sa @ref patch -- apply a JSON patch
    @sa [RFC 7396 (JSON Merge Patch)](https://tools.ietf.org/html/rfc7396)

    @since version 3.0.0
    */
    void merge_patch(const basic_json& apply_patch)
    {
        if (apply_patch.is_object())
        {
            if (not is_object())
            {
                *this = object();
            }
            for (auto it = apply_patch.begin(); it != apply_patch.end(); ++it)
            {
                if (it.value().is_null())
                {
                    erase(it.key());
                }
                else
                {
                    operator[](it.key()).merge_patch(it.value());
                }
            }
        }
        else
        {
            *this = apply_patch;
        }
    }

    /// @}
};
} // namespace nlohmann

///////////////////////
// nonmember support //
///////////////////////

// specialization of std::swap, and std::hash
namespace std
{

/// hash value for JSON objects
template<>
struct hash<nlohmann::json>
{
    /*!
    @brief return a hash value for a JSON object

    @since version 1.0.0
    */
    std::size_t operator()(const nlohmann::json& j) const
    {
        // a naive hashing via the string representation
        const auto& h = hash<nlohmann::json::string_t>();
        return h(j.dump());
    }
};

/// specialization for std::less<value_t>
/// @note: do not remove the space after '<',
///        see https://github.com/nlohmann/json/pull/679
template<>
struct less< ::nlohmann::detail::value_t>
{
    /*!
    @brief compare two value_t enum values
    @since version 3.0.0
    */
    bool operator()(nlohmann::detail::value_t lhs,
                    nlohmann::detail::value_t rhs) const noexcept
    {
        return nlohmann::detail::operator<(lhs, rhs);
    }
};

/*!
@brief exchanges the values of two JSON objects

@since version 1.0.0
*/
template<>
inline void swap<nlohmann::json>(nlohmann::json& j1, nlohmann::json& j2) noexcept(
    is_nothrow_move_constructible<nlohmann::json>::value and
    is_nothrow_move_assignable<nlohmann::json>::value
)
{
    j1.swap(j2);
}

} // namespace std

/*!
@brief user-defined string literal for JSON values

This operator implements a user-defined string literal for JSON objects. It
can be used by adding `"_json"` to a string literal and returns a JSON object
if no parse error occurred.

@param[in] s  a string representation of a JSON object
@param[in] n  the length of string @a s
@return a JSON object

@since version 1.0.0
*/
inline nlohmann::json operator "" _json(const char* s, std::size_t n)
{
    return nlohmann::json::parse(s, s + n);
}

/*!
@brief user-defined string literal for JSON pointer

This operator implements a user-defined string literal for JSON Pointers. It
can be used by adding `"_json_pointer"` to a string literal and returns a JSON pointer
object if no parse error occurred.

@param[in] s  a string representation of a JSON Pointer
@param[in] n  the length of string @a s
@return a JSON pointer object

@since version 2.0.0
*/
inline nlohmann::json::json_pointer operator "" _json_pointer(const char* s, std::size_t n)
{
    return nlohmann::json::json_pointer(std::string(s, n));
}

// #include <nlohmann/detail/macro_unscope.hpp>


// restore GCC/clang diagnostic settings
#if defined(__clang__) || defined(__GNUC__) || defined(__GNUG__)
    #pragma GCC diagnostic pop
#endif
#if defined(__clang__)
    #pragma GCC diagnostic pop
#endif

// clean up
#undef JSON_INTERNAL_CATCH
#undef JSON_CATCH
#undef JSON_THROW
#undef JSON_TRY
#undef JSON_LIKELY
#undef JSON_UNLIKELY
#undef JSON_DEPRECATED
#undef JSON_NODISCARD
#undef JSON_HAS_CPP_14
#undef JSON_HAS_CPP_17
#undef NLOHMANN_BASIC_JSON_TPL_DECLARATION
#undef NLOHMANN_BASIC_JSON_TPL


#endif  // INCLUDE_NLOHMANN_JSON_HPP_

```

`UnrealFinderTool/packages.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<packages>
  <package id="cpprestsdk.v141" version="2.10.12.1" targetFramework="native" />
</packages>
```

`UnrealFinderTool/pch.cpp`:

```cpp
// pch.cpp: source file corresponding to pre-compiled header; necessary for compilation to succeed

#include "pch.h"

// In general, ignore this file, but keep it around if you are using pre-compiled headers.

```

`UnrealFinderTool/pch.h`:

```h
// Tips for Getting Started: 
//   1. Use the Solution Explorer window to add/manage files
//   2. Use the Team Explorer window to connect to source control
//   3. Use the Output window to see build output and other messages
//   4. Use the Error List window to view errors
//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project
//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file

#ifndef PCH_H
#define PCH_H

#pragma comment(lib, "version")
#pragma comment(lib, "mincore")

#include <Windows.h>
#include "BypaPH.h"
#include "Utils.h"
#include "ImGUI/imgui.h"
#include "HttpWorker.h"

#define INVALID_POINTER_VALUE(x) ((x == (uintptr_t)-1) || x == NULL)
#endif //PCH_H

```

`UnrealFinderTool/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by UnrealFinderTool.rc
//
#define IDI_ICON1                       104

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`docs/_config.yml`:

```yml
theme: jekyll-theme-cayman
```