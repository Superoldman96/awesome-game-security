Project Path: arc_gmh5225_CS2-external-base_mrubaf8d

Source Tree:

```txt
arc_gmh5225_CS2-external-base_mrubaf8d
├── README.md
├── image.jpg
├── image1.jpg
├── image2.jpg
└── source
    ├── CSSPlayer.hpp
    ├── Source.cpp
    ├── overlay.cpp
    ├── overlay.hpp
    └── utils.hpp

```

`README.md`:

```md
# CS2-external-base
## A simple CS2 base made by me. Pay attention to the reasoning and not to the way I draw, nor to the messy structure of the code.
### UC link : [HERE](https://www.unknowncheats.me/forum/counter-strike-2-a/599932-cs2-external-base-source-code.html#post3847411)
#### Features :

- [x] Team Check
- [x] ESP box
- [x] ESP Health
- [x] ESP Distance
- [x] ESP Skeleton
- [x] ESP Text Health

(The memory and driver parts have been removed because I don't want to publicize my writing and reading methods. Consequently, you'll have to implement your own. NVIDIA Overlay is required)

**Thanks to :**

- **IRAIZO : https://github.com/iraizo/nvidia-overlay-hijack (For the overlay)**

![alt text](https://github.com/UnnamedZ03/CS2-external-base/blob/main/image.jpg)

![alt text](https://github.com/UnnamedZ03/CS2-external-base/blob/main/image1.jpg)

![alt text](https://github.com/UnnamedZ03/CS2-external-base/blob/main/image2.jpg)


```

`source/CSSPlayer.hpp`:

```hpp
#pragma once

/* @NOTE: I retrieved this with a little reversing, nothing complicated and I regularly post new ones. */
constexpr DWORD64 s_dwEntityList_Offset = 0x167BCC8;
constexpr DWORD64 viewmatrix_Offset = 0x1715D90;
constexpr DWORD64 localplayer_Offset = 0x17153E8;

/* @NOTE: You can obtain such offsets by using source2gen */
constexpr DWORD64 s_dwPawnIsAlive_Offset = 0x804;
constexpr DWORD64 s_dwPawnHealth_Offset = 0x808;
constexpr DWORD64 s_dwPlayerPawn_Offset = 0x5dc;
constexpr DWORD64 s_dwSanitizedName_Offset = 0x720;
constexpr DWORD64 s_Position_Offset = 0x12AC;
constexpr DWORD64 s_teamnum_Offset = 0x3bf;
constexpr DWORD64 s_bIsLocalPlayerController_Offset = 0x6A0; //
constexpr DWORD64 cs2_gameSceneMode = 0x310; //C_BaseEntity.m_pGameSceneNode //
constexpr DWORD64 cs2_modelState = 0x160;  //CSkeletonInstance : CGameSceneNode -> m_modelState // 
constexpr DWORD64 cs2_boneArray = 0x80; //CModelState.m_boneArray // 

inline DWORD64 g_dwEntList = 0;
inline DWORD64 client = 0;

class C_BaseEntity;
class CEntityIdentity
{
public:
    C_BaseEntity* m_pPrevByClass()
    {
        C_BaseEntity* pPrevByClass1 = driver::read<C_BaseEntity*>((DWORD64)(this) + 0x68);
        C_BaseEntity* pPrevByClass = driver::read<C_BaseEntity*>((DWORD64)pPrevByClass1);
        
        return pPrevByClass;
    }

    C_BaseEntity* m_pNextByClass()
    {
        C_BaseEntity* pNextByClass1 = driver::read<C_BaseEntity*>((DWORD64)(this) + 0x70);
        C_BaseEntity* pNextByClass = driver::read<C_BaseEntity*>((DWORD64)pNextByClass1);

        return pNextByClass;
    }

    std::string m_designerName()
    {
        std::string sBuffer = { };
        sBuffer.resize(32);

        DWORD64 pDesignerName = driver::read<DWORD64>((DWORD64)(this) + 0x20);
        if (!pDesignerName)
            return { };

        sBuffer = driver::read_str(pDesignerName);

        return sBuffer;
    }
};

class C_BaseEntity
{
public:
    static C_BaseEntity* GetBaseEntity(int nIdx)
    {
        std::uint64_t ListEntry = driver::read<std::uint64_t>(g_dwEntList + (8 * (nIdx & 0x7FFF) >> 9) + 16);
        if (!ListEntry)
            return 0;
        C_BaseEntity* ListEntry2 = driver::read<C_BaseEntity*>((ListEntry + 120 * (nIdx & 0x1FF)));

        return ListEntry2;
    }
public:
    CEntityIdentity* m_pEntityIdentity()
    {
        CEntityIdentity* a = driver::read<CEntityIdentity*>((DWORD64)(this) + 0x10);
        return a;
    }
};

class C_CSPlayerPawn
{
public:
    static C_CSPlayerPawn* GetPlayerPawn(std::uint32_t uHandle)
    {
        std::uint64_t ListEntry = driver::read<std::uint64_t>(g_dwEntList + 0x8 * ((uHandle & 0x7FFF) >> 9) + 16);
        if (!ListEntry)
            return 0;

        C_CSPlayerPawn* pCSPlayerPawn = driver::read<C_CSPlayerPawn*>(ListEntry + 120 * (uHandle & 0x1FF));

        return pCSPlayerPawn;
    }
};

class CCSPlayerController : public C_BaseEntity
{
public:
    std::string m_sSanitizedPlayerName()
    {
        std::string sBuffer = { };
        sBuffer.resize(32);

        DWORD64 SanitizedPlayerName = driver::read<DWORD64>(((DWORD64)(this) + 0x720));
        if (!SanitizedPlayerName)
            return { };

        sBuffer = driver::read_str(SanitizedPlayerName);
        return sBuffer;
    }

    int Teamnum()
    {
        int team = driver::read<int>((DWORD64)(this) + s_teamnum_Offset);
        return team;
    }

    int m_iPawnHealth()
    {
        DWORD64 health = driver::read<DWORD64>((DWORD64)(this) + s_dwPawnHealth_Offset);
        return health;
    }

    vec3 pos(C_CSPlayerPawn* pawn)
    {
        return driver::read<vec3>((DWORD64)pawn + 0x12AC);
    }


    bool m_bIsLocalPlayerController()
    {
        return driver::read<bool>((DWORD64)(this) + s_bIsLocalPlayerController_Offset);
    }

    C_CSPlayerPawn* m_hPlayerPawn()
    {
        std::uint32_t playerpawn = driver::read<std::uint32_t>((DWORD64)(this) + s_dwPlayerPawn_Offset);
        return C_CSPlayerPawn::GetPlayerPawn(playerpawn);
    }
};

```

`source/Source.cpp`:

```cpp
#include "overlay.hpp"
#include "CSSPlayer.hpp"
#include "utils.hpp"

void ESPLoop() {

    hwnd = FindWindowA(NULL, "Counter-Strike 2"); // Target Window With his lpClassName ( UnrealWindow )
    OverlayWindow = FindWindow("CEF-OSC-WIDGET", "NVIDIA GeForce Overlay");
    hwnd_active = GetForegroundWindow();

    if (hwnd_active == hwnd) {

        ShowWindow(OverlayWindow, SW_SHOW);
    }
    else
    {
        ShowWindow(OverlayWindow, SW_HIDE);
    }

    if (esp::crosshair)
    {
        g_overlay->draw_line(ScreenCenterX, ScreenCenterY - 5, ScreenCenterX, ScreenCenterY + 5, CrosshairColor);
        g_overlay->draw_line(ScreenCenterX - 5, ScreenCenterY, ScreenCenterX + 5, ScreenCenterY, CrosshairColor);
        g_overlay->draw_line(ScreenCenterX, ScreenCenterY - 5, ScreenCenterX, ScreenCenterY + 5, CrosshairColor);
        g_overlay->draw_line(ScreenCenterX - 5, ScreenCenterY, ScreenCenterX + 5, ScreenCenterY, CrosshairColor);
    }

    ImVec2 size = ImVec2(ScreenCenterX * 2, ScreenCenterY * 2);
    ImVec2 center = ImVec2(ScreenCenterX, ScreenCenterY);

    view_matrix_t viewmatrix = driver::read<view_matrix_t>(client + viewmatrix_Offset);
    uint64_t localplayer = driver::read<uint64_t>(client + localplayer_Offset);
    vec3 localpos = driver::read<vec3>(localplayer + s_Position_Offset);
    int localteam = driver::read<int>(localplayer + s_teamnum_Offset);
    g_dwEntList = driver::read<uint64_t>(client + s_dwEntityList_Offset);
    CCSPlayerController* pPlayerController = nullptr;

    /* @NOTE: Iterate player controllers until we get the first one in the list */
    for (int nId = 0; nId < 32; nId++)
    {
        C_BaseEntity* pBaseEntity = C_BaseEntity::GetBaseEntity(nId);
        if (!pBaseEntity || strcmp(pBaseEntity->m_pEntityIdentity()->m_designerName().c_str(), "cs_player_controller"))
            continue;

        while (pBaseEntity->m_pEntityIdentity()->m_pPrevByClass())
            pBaseEntity = pBaseEntity->m_pEntityIdentity()->m_pPrevByClass();

        pPlayerController = reinterpret_cast<CCSPlayerController*>(pBaseEntity);
        break;
    }

    /* @NOTE: This one controller is first in the entity list, iterate them forward until m_pNextByClass become nullptr */
    for (; pPlayerController; pPlayerController = reinterpret_cast<CCSPlayerController*>(pPlayerController->m_pEntityIdentity()->m_pNextByClass()))
    {
        if (pPlayerController->m_bIsLocalPlayerController())
            continue;

        if (pPlayerController->m_iPawnHealth() <= 0 || pPlayerController->m_iPawnHealth() > 100)
            continue;

        if (pPlayerController->Teamnum() == localteam) 
            continue;

        uint64_t pawn = (uint64_t)pPlayerController->m_hPlayerPawn();
        uint64_t gamescene = driver::read<uint64_t>(pawn + cs2_gameSceneMode);
        uint64_t bonearray = driver::read<uint64_t>(gamescene + cs2_modelState + cs2_boneArray);

        vec3 playerpos = pPlayerController->pos(pPlayerController->m_hPlayerPawn());
        vec3 pos;

        vec3 head_pos = driver::read<vec3>(bonearray + 6 * 32);
        vec3 head;

        if (!world_to_screen(screensize, playerpos, pos, viewmatrix))
            continue;

        if (!world_to_screen(screensize, head_pos, head, viewmatrix))
            continue;

        int distance = static_cast<int>(localpos.distance_to(playerpos) / 100);

        if (esp::skeleton)
        {

            vec3 head = driver::read<vec3>(bonearray + 6 * 32);
            vec3 cou = driver::read<vec3>(bonearray + 5 * 32);
            vec3 shoulderR = driver::read<vec3>(bonearray + 8 * 32);
            vec3 shoulderL = driver::read<vec3>(bonearray + 13 * 32);
            vec3 brasR = driver::read<vec3>(bonearray + 9 * 32);
            vec3 brasL = driver::read<vec3>(bonearray + 14 * 32);
            vec3 handR = driver::read<vec3>(bonearray + 11 * 32);
            vec3 handL = driver::read<vec3>(bonearray + 16 * 32);
            vec3 cock = driver::read<vec3>(bonearray + 0 * 32);
            vec3 kneesR = driver::read<vec3>(bonearray + 23 * 32);
            vec3 kneesL = driver::read<vec3>(bonearray + 26 * 32);
            vec3 feetR = driver::read<vec3>(bonearray + 24 * 32);
            vec3 feetL = driver::read<vec3>(bonearray + 27 * 32);

            vec3 Ahead;
            vec3 Acou;
            vec3 AshoulderR;
            vec3 AshoulderL;
            vec3 AbrasR;
            vec3 AbrasL;
            vec3 AhandR;
            vec3 AhandL;
            vec3 Acock;
            vec3 AkneesR;
            vec3 AkneesL;
            vec3 AfeetR;
            vec3 AfeetL;

            if (!world_to_screen(screensize, head, Ahead, viewmatrix))
                continue;
            if (!world_to_screen(screensize, cou, Acou, viewmatrix))
                continue;
            if (!world_to_screen(screensize, shoulderR, AshoulderR, viewmatrix))
                continue;
            if (!world_to_screen(screensize, shoulderL, AshoulderL, viewmatrix))
                continue;
            if (!world_to_screen(screensize, brasR, AbrasR, viewmatrix))
                continue;
            if (!world_to_screen(screensize, brasL, AbrasL, viewmatrix))
                continue;
            if (!world_to_screen(screensize, handL, AhandL, viewmatrix))
                continue;
            if (!world_to_screen(screensize, handR, AhandR, viewmatrix))
                continue;
            if (!world_to_screen(screensize, cock, Acock, viewmatrix))
                continue;
            if (!world_to_screen(screensize, kneesR, AkneesR, viewmatrix))
                continue;
            if (!world_to_screen(screensize, kneesL, AkneesL, viewmatrix))
                continue;
            if (!world_to_screen(screensize, feetR, AfeetR, viewmatrix))
                continue;
            if (!world_to_screen(screensize, feetL, AfeetL, viewmatrix))
                continue;

            g_overlay->draw_line(Acou.x, Acou.y, Ahead.x, Ahead.y, D2D1::ColorF(255, 255, 255, 255));
            g_overlay->draw_line(Acou.x,Acou.y,AshoulderR.x, AshoulderR.y, D2D1::ColorF(255, 255, 255, 255));
            g_overlay->draw_line(Acou.x,Acou.y,AshoulderL.x, AshoulderL.y, D2D1::ColorF(255, 255, 255, 255));
            g_overlay->draw_line(AbrasL.x,AbrasL.y,AshoulderL.x, AshoulderL.y, D2D1::ColorF(255, 255, 255, 255));
            g_overlay->draw_line(AbrasR.x,AbrasR.y,AshoulderR.x, AshoulderR.y, D2D1::ColorF(255, 255, 255, 255));
            g_overlay->draw_line(AbrasR.x,AbrasR.y,AhandR.x, AhandR.y, D2D1::ColorF(255, 255, 255, 255));
            g_overlay->draw_line(AbrasL.x,AbrasL.y,AhandL.x, AhandL.y, D2D1::ColorF(255, 255, 255, 255));
            g_overlay->draw_line(Acou.x,Acou.y,Acock.x, Acock.y, D2D1::ColorF(255, 255, 255, 255));
            g_overlay->draw_line(AkneesR.x,AkneesR.y,Acock.x, Acock.y, D2D1::ColorF(255, 255, 255, 255));
            g_overlay->draw_line(AkneesL.x,AkneesL.y,Acock.x, Acock.y, D2D1::ColorF(255, 255, 255, 255));
            g_overlay->draw_line(AkneesL.x,AkneesL.y,AfeetL.x,AfeetL.y, D2D1::ColorF(255, 255, 255, 255));
            g_overlay->draw_line(AkneesR.x,AkneesR.y,AfeetR.x,AfeetR.y, D2D1::ColorF(255, 255, 255, 255));

        }


        /* @NOTE : don't judge all these calculations, I did it very quickly, get inspired by the reasoning but especially not by my way of drawing... sorry lol*/
        float top = head.y;
        float bottom = pos.y;
        float width = abs(top - bottom) / 2.f;
        float left = pos.x - width / 2.f - 1.5f;
        float right = pos.x + width / 2.f + 1.5f;
        float height = abs(abs(pos.y) - abs(pos.y));
        auto extend = +5;

        if (esp::health)
        {
            float Height = abs(abs(head.y) - abs(pos.y));
            float Width = height / 2.f;
            float Middle = pos.x - (width / 2.f);

            DrawHealthbars(Middle, top - 5, Width, Height, 2, pPlayerController->m_iPawnHealth());
        }

        if (esp::distance)
        {
            char buffer[0x48];
            sprintf_s(buffer, xorstr_("[%im]"), distance);
            g_overlay->draw_text(pos.x - 12, pos.y, D2D1::ColorF(255, 255, 255, 255), buffer);
        }

        if (esp::box)
        {
            auto extend = +5;
            g_overlay->draw_line(left, top - extend, right, top - extend, D2D1::ColorF(0, 0, 0, 255)); // bottom
            g_overlay->draw_line(left, bottom, right, bottom, D2D1::ColorF(0, 0, 0, 255)); // up
            g_overlay->draw_line(left, top - extend, left, bottom, D2D1::ColorF(0, 0, 0, 255)); // left
            g_overlay->draw_line(right, top - extend, right, bottom, D2D1::ColorF(0, 0, 0, 255)); // right

            auto rect = D2D1_RECT_F();
            rect.bottom = bottom;
            rect.top = top - extend;
            rect.right = right;
            rect.left = left;
            g_overlay->draw_box(rect, D2D1::ColorF(0, 0, 0, 0.2));
        }

        if (esp::healthT)
        {
            float r = 1 - pPlayerController->m_iPawnHealth() * 0.01f;
            float g = pPlayerController->m_iPawnHealth() * 0.01f;

            g_overlay->draw_text(head.x - 15, head.y - 20, D2D1::ColorF(r, g, 0, 255), std::to_string(int(pPlayerController->m_iPawnHealth())).c_str());
        }
    }

}

void RenderMenu()
{
    if (showmenu && rendering)
    {
        g_overlay->draw_text(5, 5, D2D1::ColorF(255, 20, 20, 255), "SHOW/HIDE [INSERT]");

        if (esp::crosshair)
            g_overlay->draw_text(5, 20, D2D1::ColorF(0, 255, 0, 255), "F1 Crosshair : ON");
        else
            g_overlay->draw_text(5, 20, D2D1::ColorF(255, 0, 0, 255), "F1 Crosshair : OFF");

        if (esp::health)
            g_overlay->draw_text(5, 40, D2D1::ColorF(0, 255, 0, 255), "F2 Health : ON");
        else
            g_overlay->draw_text(5, 40, D2D1::ColorF(255, 0, 0, 255), "F2 Health : OFF");

        if (esp::box)
            g_overlay->draw_text(5, 60, D2D1::ColorF(0, 255, 0, 255), "F4 Box : ON");
        else
            g_overlay->draw_text(5, 60, D2D1::ColorF(255, 0, 0, 255), "F4 Box : OFF");

        if (esp::distance)
            g_overlay->draw_text(5, 80, D2D1::ColorF(0, 255, 0, 255), "F5 Distance : ON");
        else
            g_overlay->draw_text(5, 80, D2D1::ColorF(255, 0, 0, 255), "F5 Distance : OFF");

        if (esp::healthT)
            g_overlay->draw_text(5, 100, D2D1::ColorF(0, 255, 0, 255), "F6 Health Text : ON");
        else
            g_overlay->draw_text(5, 100, D2D1::ColorF(255, 0, 0, 255), "F6 Health Text : OFF");

        if (esp::skeleton)
            g_overlay->draw_text(5, 120, D2D1::ColorF(0, 255, 0, 255), "F7 Skeleton : ON");
        else
            g_overlay->draw_text(5, 120, D2D1::ColorF(255, 0, 0, 255), "F7 Skeleton : OFF");
    }
}

void Update() {
    while (true)
    {
        if (rendering)
        {
            if (GetAsyncKeyState(VK_F1) & 1)
                if (showmenu)
                    esp::crosshair = !esp::crosshair;

            if (GetAsyncKeyState(VK_F2) & 1)
                if (showmenu)
                    esp::health = !esp::health;

            if (GetAsyncKeyState(VK_F4) & 1)
                if (showmenu)
                    esp::box = !esp::box;

            if (GetAsyncKeyState(VK_F5) & 1)
                if (showmenu)
                    esp::distance = !esp::distance;

            if (GetAsyncKeyState(VK_F6) & 1)
                if (showmenu)
                    esp::healthT = !esp::healthT;

            if (GetAsyncKeyState(VK_F7) & 1)
                if (showmenu)
                    esp::skeleton = !esp::skeleton;

        }
        if (GetAsyncKeyState(VK_INSERT) & 1)
            showmenu = !showmenu;
    }
}

static void render(FOverlay* overlay) {
    while (true) {
        std::this_thread::sleep_for(std::chrono::milliseconds(5));
        overlay->begin_scene();
        overlay->clear_scene();
        frame++;
        RenderMenu();
        ESPLoop();
        overlay->end_scene();
    }
}

static void _init(FOverlay* overlay) {
    if (!overlay->window_init()) {
        printf("[!] Error init overlay window\n");
        Sleep(5000);
        return;
    }
    else {
        printf("[+] init overlay window\n");

    }

    if (!overlay->init_d2d())
        return;

    std::thread r(render, overlay);
    std::thread up(Update);

    r.join();
    up.detach();
    overlay->d2d_shutdown();
    return;
}

int main()
{
    /* @NOTE: not really useful for you this part*/
    std::string brand = xorstr_("Unnamed");

    if (!memory::initialize())
    {
        printf(xorstr_("[-] memory init failed\n"));
        system(xorstr_("pause"));
        return 1;
    }

    memory::call<void>(xorstr_("kernel32.dll"), xorstr_("SetConsoleTitleA"), xorstr_("I LOVE UC <3"));
    /* @NOTE: not really useful for you this part*/

    /* @NOTE: the driver has been removed, implement yours :)*/
    if (!driver::load())
    {
        printf(xorstr_("[-] driver init failed\n"));
        system(xorstr_("pause"));
        return 1;
    }
    /* @NOTE: the driver has been removed, implement yours :)*/

    /* @NOTE: I collect everything that's useful for what comes next.*/
    driver::detail::process = xorstr_("cs2.exe");

    while (!driver::detail::pid)
        driver::detail::pid = memory::get_pid(xorstr_("cs2.exe"));

    uint64_t base = driver::get_process_exe_base();
    if (!base)
    {
        printf(xorstr_("[-] base addr not found\n"));
        system(xorstr_("pause"));
        return 1;
    }
    std::cout << xorstr_("[+] Found CS2 Base ---> ") << xorstr_("0x") << std::hex << base << std::dec << std::endl;

    client = driver::module(L"client.dll");
    if (!client)
    {
        printf(xorstr_("[-] base addr not found\n"));
        system(xorstr_("pause"));
        return 1;
    }
    std::cout << xorstr_("[+] Found client Base ---> ") << xorstr_("0x") << std::hex << client << std::dec << std::endl;
    /* @NOTE: I collect everything that's useful for what comes next.*/

    RECT desktop;
    const HWND hDesktop = GetDesktopWindow();
    GetWindowRect(hDesktop, &desktop);
    HDC monitor = GetDC(hDesktop);
    int current = GetDeviceCaps(monitor, VERTRES);
    int total = GetDeviceCaps(monitor, DESKTOPVERTRES);
    ScreenCenterX = GetSystemMetrics(SM_CXSCREEN) / 2;
    ScreenCenterY = GetSystemMetrics(SM_CYSCREEN) / 2;
    screensize = { (float)GetSystemMetrics(SM_CXSCREEN),(float)GetSystemMetrics(SM_CYSCREEN),0 };
    g_overlay = { 0 };
    _init(g_overlay);
    
}

```

`source/overlay.cpp`:

```cpp
#include "overlay.hpp"

static HWND win;
int FOverlay::ScreenHeight = 0;
int FOverlay::ScreenWidth = 0;

auto FOverlay::window_set_style() -> void {
	int i = 0;

	i = (int)GetWindowLong(win, -20);

	SetWindowLongPtr(win, -20, (LONG_PTR)(i | 0x20));
}


std::string RandomString(const int len)
{
	const std::string alpha_numeric("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890");

	std::default_random_engine generator{ std::random_device{}() };
	const std::uniform_int_distribution< std::string::size_type > distribution{ 0, alpha_numeric.size() - 1 };

	std::string str(len, 0);
	for (auto& it : str) {
		it = alpha_numeric[distribution(generator)];
	}

	return str;
}

auto FOverlay::window_set_transparency() -> void {
	MARGINS margin;
	UINT opacity_flag, color_key_flag, color_key = 0;
	UINT opacity = 0;

	margin.cyBottomHeight = -1;
	margin.cxLeftWidth = -1;
	margin.cxRightWidth = -1;
	margin.cyTopHeight = -1;

	DwmExtendFrameIntoClientArea(win, &margin);

	opacity_flag = 0x02;
	color_key_flag = 0x01;
	color_key = 0x000000;
	opacity = 0xFF;

	SetLayeredWindowAttributes(win, color_key, opacity, opacity_flag);
}

auto FOverlay::window_set_top_most() -> void {
	SetWindowPos(win, HWND_TOPMOST, 0, 0, 0, 0, 0x0002 | 0x0001);
}

auto FOverlay::retrieve_window() -> HWND { return win; }

const MARGINS margin = { 0, 0, 0, 0 };
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
	{
	case (WM_PAINT):
		DwmExtendFrameIntoClientArea(win, &margin);
		break;
	}

	return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

std::string overlay1 = RandomString(7);
std::string overlay2 = RandomString(7);


void FOverlay::create_window() {
	LPCSTR lpClassName = overlay1.c_str();
	LPCSTR lpWindowName = overlay2.c_str();

	WNDCLASSEX wc;
	ZeroMemory(&wc, sizeof(WNDCLASSEX));

	wc.cbSize = sizeof(WNDCLASSEX);
	wc.style = CS_HREDRAW | CS_VREDRAW;
	wc.lpfnWndProc = WindowProc;
	wc.hInstance = GetModuleHandleA(NULL);
	wc.hCursor = LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground = (HBRUSH)RGB(0, 0, 0);
	wc.lpszClassName = lpClassName;
	wc.lpszMenuName = lpWindowName;

	RegisterClassEx(&wc);

	win = CreateWindowExA(WS_EX_TOPMOST | WS_EX_LAYERED | WS_EX_TRANSPARENT, lpClassName, lpWindowName, WS_POPUP, 0, 0, ScreenWidth, ScreenHeight, NULL, NULL, wc.hInstance, NULL);
}

// Hijacking method down here.
auto FOverlay::window_init() -> BOOL {
	win = FindWindow("CEF-OSC-WIDGET", "NVIDIA GeForce Overlay"); // "CEF-OSC-WIDGET" "NVIDIA GeForce Overlay"
	if (!win)
		create_window();

	if (!win)
		return FALSE;

	FOverlay::window_set_style();
	FOverlay::window_set_transparency();
	FOverlay::window_set_top_most();

	ShowWindow(win, SW_SHOW);

	return TRUE;
}

/*
Overlay functions
*/

ID2D1Factory* d2d_factory;
ID2D1HwndRenderTarget* tar;
IDWriteFactory* write_factory;
ID2D1SolidColorBrush* brush;
ID2D1SolidColorBrush* red_brush;
ID2D1SolidColorBrush* green_brush;
IDWriteTextFormat* format;

auto FOverlay::d2d_shutdown() -> void {
	// Release
	tar->Release();
	write_factory->Release();
	brush->Release();
	red_brush->Release();
	green_brush->Release();
	d2d_factory->Release();
}

auto FOverlay::init_d2d() -> BOOL {
	HRESULT ret;
	RECT rc;

	// Initialize D2D here
	ret = D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, &d2d_factory);
	if (FAILED(ret))
		return FALSE;

	ret =
		DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory),
			(IUnknown**)(&write_factory));
	if (FAILED(ret))
		return FALSE;

	write_factory->CreateTextFormat(
		L"Consolas", NULL, DWRITE_FONT_WEIGHT_REGULAR, DWRITE_FONT_STYLE_NORMAL,
		DWRITE_FONT_STRETCH_NORMAL, 13.0, L"en-us", &format);

	GetClientRect(FOverlay::retrieve_window(), &rc);

	ret = d2d_factory->CreateHwndRenderTarget(
		D2D1::RenderTargetProperties(
			D2D1_RENDER_TARGET_TYPE_DEFAULT,
			D2D1::PixelFormat(DXGI_FORMAT_UNKNOWN,
				D2D1_ALPHA_MODE_PREMULTIPLIED)),
		D2D1::HwndRenderTargetProperties(
			FOverlay::retrieve_window(),
			D2D1::SizeU(rc.right - rc.left, rc.bottom - rc.top)),
		&tar);
	if (FAILED(ret))
		return FALSE;

	tar->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &brush);
	tar->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Red), &red_brush);
	tar->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Green), &green_brush);

	return TRUE;
}

auto FOverlay::begin_scene() -> void { tar->BeginDraw(); }

auto FOverlay::end_scene() -> void { tar->EndDraw(); }

auto FOverlay::clear_scene() -> void { tar->Clear(); }

auto FOverlay::draw_line(int x1, int y1, int x2, int y2, D2D1::ColorF color) -> void {
	auto point1 = D2D1_POINT_2F();
	point1.x = x1;
	point1.y = y1;

	auto point2 = D2D1_POINT_2F();
	point2.x = x2;
	point2.y = y2;

	ID2D1SolidColorBrush* temp;

	tar->CreateSolidColorBrush(color, &temp);
	tar->DrawLine(point1, point2, temp);
	temp->Release();
}

auto FOverlay::draw_boxnew(int x, int y, float width, float height, D2D1::ColorF color) -> void {
	auto rect = D2D1_RECT_F();
	rect.bottom = y - height / 2;
	rect.top = y + height / 2;
	rect.right = x + width / 2;
	rect.left = x - width / 2;

	draw_box(rect, color);
}

auto FOverlay::draw_box(D2D1_RECT_F rect, D2D1::ColorF color) -> void {
	ID2D1SolidColorBrush* temp;

	tar->CreateSolidColorBrush(color, &temp);

	tar->FillRectangle(rect, temp);
	temp->Release();
}


auto FOverlay::draw_text(int x, int y, D2D1::ColorF color, const char* str, ...) -> void {
	char buf[4096];
	int len = 0;
	wchar_t b[256];

	va_list arg_list;
	va_start(arg_list, str);
	vsnprintf(buf, sizeof(buf), str, arg_list);
	va_end(arg_list);

	len = strlen(buf);
	mbstowcs(b, buf, len);
	ID2D1SolidColorBrush* temp;

	tar->CreateSolidColorBrush(color, &temp);

	tar->DrawText(b, len, format, D2D1::RectF(x, y, 1920, 1080), temp,
		D2D1_DRAW_TEXT_OPTIONS_NONE, DWRITE_MEASURING_MODE_NATURAL);
	temp->Release();
}

auto FOverlay::draw_circle(float x, float y, float r, float s, D2D1::ColorF color) -> void
{
	float Step = M_PI * 2.0 / s;
	for (float a = 0; a < (M_PI * 2.0); a += Step)
	{
		float x1 = r * cos(a) + x;
		float y1 = r * sin(a) + y;
		float x2 = r * cos(a + Step) + x;
		float y2 = r * sin(a + Step) + y;
		draw_line(x1, y1, x2, y2, color);
	}
}


auto FOverlay::clear_screen() -> void {
	FOverlay::begin_scene();
	FOverlay::clear_scene();
	FOverlay::end_scene();
}
```

`source/overlay.hpp`:

```hpp
#define _CRT_SECURE_NO_WARNINGS

#ifndef FOverlay_H
#define FOverlay_H
#define M_PI 3.14159265
#include <windows.h>
#include <stdio.h>
#include <dwmapi.h> 
#include <d2d1.h>
#include <dwrite.h>
#include <string>
#include <random>
#pragma comment(lib, "Dwrite")

#pragma comment(lib, "Dwmapi.lib") 
#pragma comment(lib, "d2d1.lib")

#define _CRT_SECURE_NO_DEPRECATE
#define _CRT_SECURE_NO_WARNINGS

class FOverlay
{
public:
	static int ScreenHeight;
	static int ScreenWidth;
	auto window_set_style()-> void;
	auto window_set_transparency()-> void;
	auto window_set_top_most()-> void;
	auto retrieve_window()->HWND;
	void create_window();
	auto window_init()->BOOL;
	auto d2d_shutdown()-> void;
	auto init_d2d()->BOOL;
	auto begin_scene()-> void;
	auto end_scene()-> void;
	auto clear_scene()-> void;
	auto clear_screen()-> void;
	auto draw_text(int x, int y, D2D1::ColorF color, const char* str, ...) -> void;
	auto draw_line(int x1, int y1, int x2, int y2, D2D1::ColorF color) -> void;
	auto draw_box(D2D1_RECT_F rect, D2D1::ColorF color) -> void;
	auto draw_boxnew(int x, int y, float width, float height, D2D1::ColorF color) -> void;
	auto draw_circle(float x, float y, float r, float s, D2D1::ColorF color) -> void;

};

#endif
```

`source/utils.hpp`:

```hpp
#pragma once
/* @NOTE: Sorry if it's a mess, I don't really feel like doing something hyper-structured and clean, again I share for those who want to understand the reasoning. Use what I've done as you wish no matter what. */

HWND hwnd = NULL;
HWND hwnd_active = NULL;
HWND OverlayWindow = NULL;
bool showmenu = true;
bool rendering = true;
int frame = 0;
FOverlay* g_overlay;

vec3 screensize;
float ScreenCenterX;
float ScreenCenterY;

auto CrosshairColor = D2D1::ColorF(0, 100, 255, 255);

struct view_matrix_t {
    float* operator[ ](int index) {
        return matrix[index];
    }

    float matrix[4][4];
};

bool world_to_screen(const vec3& screen_size, const vec3& pos, vec3& out, view_matrix_t matrix) {
    out.x = matrix[0][0] * pos.x + matrix[0][1] * pos.y + matrix[0][2] * pos.z + matrix[0][3];
    out.y = matrix[1][0] * pos.x + matrix[1][1] * pos.y + matrix[1][2] * pos.z + matrix[1][3];

    float w = matrix[3][0] * pos.x + matrix[3][1] * pos.y + matrix[3][2] * pos.z + matrix[3][3];

    if (w < 0.01f)
        return false;

    float inv_w = 1.f / w;
    out.x *= inv_w;
    out.y *= inv_w;

    float x = screen_size.x * .5f;
    float y = screen_size.y * .5f;

    x += 0.5f * out.x * screen_size.x + 0.5f;
    y -= 0.5f * out.y * screen_size.y + 0.5f;

    out.x = x;
    out.y = y;

    return true;
}

namespace detail
{
    inline HWND window = 0;

    BOOL CALLBACK enum_windows(HWND hwnd, LPARAM param)
    {
        DWORD process_id;
        GetWindowThreadProcessId(hwnd, &process_id);
        if (process_id == param)
        {
            window = hwnd;
            return false;
        }
        return true;
    }
}

namespace esp
{
    inline bool box = true;

    inline bool health = true;
    inline bool healthT = true;

    inline bool distance = true;

    inline bool skeleton = true;

    inline bool team = true;

    inline bool crosshair = true;

    inline bool FPS = true;
}
void DrawFilledRectangle(int x, int y, int w, int h, D2D1::ColorF color)
{
    D2D1_RECT_F rect = { x, y, x + w, y + h };
    g_overlay->draw_box(rect, color);
}


void DrawBorderBox(int x, int y, int x2, int y2, int thickness, D2D1::ColorF color)
{
    DrawFilledRectangle(x, y, x2, thickness, color); // top
    DrawFilledRectangle(x, y + y2, x2, thickness, color); // bottom
    DrawFilledRectangle(x, y, thickness, y2, color); // left
    DrawFilledRectangle(x + x2, y, thickness, y2 + thickness, color); // right
}


void DrawHealthbars(float x, float y, float width, float height, int thickness, int health)
{
    DrawFilledRectangle(x - (thickness + 5), y, thickness, height, D2D1::ColorF(0, 255, 0, 255));
    DrawFilledRectangle(x - (thickness + 5), y, thickness, height - ((height / 100) * health), D2D1::ColorF(255, 0, 0, 120));
    DrawBorderBox(x - (thickness + 5) - 1, y - 1, thickness + 1, height + 1, 1, D2D1::ColorF(0, 0, 0, 255));
}

```