Project Path: arc_gmh5225_EAC-Extractor-Utility_ltat32o9

Source Tree:

```txt
arc_gmh5225_EAC-Extractor-Utility_ltat32o9
├── DecryptEACPayload.cpp
├── DecryptEACPayload.sln
├── DecryptEACPayload.vcxproj
├── DecryptEACPayload.vcxproj.filters
├── DecryptEACPayload.vcxproj.user
├── LICENSE
├── README.md
└── logo.png

```

`DecryptEACPayload.cpp`:

```cpp
/**
 * Document Name: EAC_Decrypt_Extract.cpp
 * Author: Lucas Guilherme
 * Description: This C++ program decrypts and extracts files from an EAC (Easy Anti-Cheat) binary.
 *              It performs a sequence of operations such as loading an encrypted file, decrypting the file,
 *              searching for specific patterns within the loaded library, copying encrypted data into separate vectors,
 *              and decrypting the data, followed by saving them as separate files.
 * Date: 22/05/2023
 *
 * This program performs the following steps:
 * 1. Loads an encrypted file specified as a command-line argument.
 * 2. Decrypts the loaded file using a custom decryption algorithm.
 * 3. Retrieves the current directory path.
 * 4. Saves the decrypted file with a specific name in the current directory.
 * 5. Loads the decrypted file as a library.
 * 6. Searches for specific patterns within the loaded library to determine the start and size of data.
 * 7. Copies encrypted data based on the identified patterns into separate vectors.
 * 8. Decrypts the data in the vectors.
 * 9. Saves the decrypted data as separate files in the current directory.
 *
 * Command-line usage: EAC_Decrypt_Extract.exe <EAC.Bin>
 *
 * Dependencies: Windows.h, fstream, format
 *
 */

#include <iostream>
#include <vector>
#include <Windows.h>
#include <fstream>
#include <format>

uintptr_t ResolveRelative(const uintptr_t adressPointer, const ULONG offsetCount,
                          const ULONG     sizeOfInstruction)
{
    const ULONG_PTR adressToResolve               = adressPointer;
    const LONG      totalBytesFromSpecifiedAdress = *(PLONG)(adressToResolve + offsetCount);
    const uintptr_t resultFinal                   = (adressToResolve + sizeOfInstruction + totalBytesFromSpecifiedAdress
    );

    return resultFinal;
}

std::vector<uintptr_t> PatternScan(const uintptr_t moduleAdress, const char* signature)
{
    std::vector<uintptr_t> tmp;

    if (!moduleAdress)
        return tmp;

    static auto patternToByte = [](const char* pattern)
    {
        auto       bytes = std::vector<int>{};
        const auto start = const_cast<char*>(pattern);
        const auto end   = const_cast<char*>(pattern) + strlen(pattern);

        for (auto current = start; current < end; ++current)
        {
            if (*current == '?')
            {
                ++current;
                if (*current == '?')
                    ++current;
                bytes.push_back(-1);
            }
            else { bytes.push_back(strtoul(current, &current, 16)); }
        }
        return bytes;
    };

    const auto dosHeader = (PIMAGE_DOS_HEADER)moduleAdress;
    const auto ntHeaders = (PIMAGE_NT_HEADERS)((std::uint8_t*)moduleAdress + dosHeader->e_lfanew);

    const auto sizeOfImage  = ntHeaders->OptionalHeader.SizeOfImage;
    auto       patternBytes = patternToByte(signature);
    const auto scanBytes    = reinterpret_cast<std::uint8_t*>(moduleAdress);

    const auto s = patternBytes.size();
    const auto d = patternBytes.data();

    for (auto i = 0ul; i < sizeOfImage - s; ++i)
    {
        bool found = true;
        for (auto j = 0ul; j < s; ++j)
        {
            if (scanBytes[i + j] != d[j] && d[j] != -1)
            {
                found = false;
                break;
            }
        }
        if (found)
        {
            tmp.push_back(reinterpret_cast<uintptr_t>(&scanBytes[i]));
        }
    }
    return tmp;
}

std::vector<uint8_t> LoadBinaryFile(const std::string& filePath)
{
    std::ifstream file(filePath, std::ios::binary);
    if (!file)
    {
        std::cerr << "Failed to open the file: " << filePath << std::endl;
        return {};
    }

    // Determine the size of the file
    file.seekg(0, std::ios::end);
    std::streampos fileSize = file.tellg();
    file.seekg(0, std::ios::beg);

    // Create a vector with the appropriate size
    std::vector<uint8_t> buffer(fileSize);

    // Read the file into the vector
    if (!file.read(reinterpret_cast<char*>(buffer.data()), fileSize))
    {
        std::cerr << "Failed to read the file: " << filePath << std::endl;
        return {};
    }

    return buffer;
}

bool SaveBinaryFile(const std::string& filePath, const std::vector<uint8_t>& data)
{
    std::ofstream file(filePath, std::ios::binary);
    if (!file)
    {
        std::cerr << "Failed to create the file: " << filePath << std::endl;
        return false;
    }

    file.write(reinterpret_cast<const char*>(data.data()), data.size());
    if (!file)
    {
        std::cerr << "Failed to write the data to the file: " << filePath << std::endl;
        return false;
    }

    return true;
}


std::vector<uint8_t> DecryptBuffer(const std::vector<uint8_t>* encryptedVector)
{
    // Copy the buffer to a temporary vector
    std::vector<uint8_t> tmp = *encryptedVector;

    // Begin
    auto beginBuffer = tmp.data();

    // End
    auto endBuffer = beginBuffer + tmp.size();

    // Pointer to the current byte in the buffer
    uint8_t* pCurrentByte = tmp.data();

    // Calculate the size of the module
    size_t moduleSize = endBuffer - beginBuffer;

    // Ensure the module size is at least 2
    if (moduleSize >= 2)
    {
        // Adjust the last byte in the buffer
        endBuffer[-1] += 3 - 3 * (LOBYTE(endBuffer) - LOBYTE(beginBuffer));

        // Iterate over the buffer in reverse order, starting from the second last byte
        for (size_t i = moduleSize - 2; i; --i)
            pCurrentByte[i] += -3 * i - pCurrentByte[i + 1];

        // Adjust the first byte in the buffer
        *pCurrentByte -= pCurrentByte[1];
    }

    return tmp;
}


int main(int argc, char* argv[])
{
    if (argc < 2)
    {
        std::printf("Usage: %s <EAC.Bin>\n", argv[0]);
        return 1;
    }

    std::printf("[-] Decrypting files...\n");

    std::string filePath = argv[1];

    // 1. Load the file
    auto encryptedfile = LoadBinaryFile(filePath);

    // 2. Decrypt the file
    auto decryptedBuffer = DecryptBuffer(&encryptedfile);


    char currentDir[MAX_PATH];
    GetCurrentDirectoryA(MAX_PATH, currentDir);

    // 3. Save the decrypted file
    SaveBinaryFile(std::format("{}\\EAC_Launcher.dll", currentDir), decryptedBuffer);

    // 4. Load the EAC_Launcher
    auto launcherData = LoadLibraryA(std::format("{}\\EAC_Launcher.dll", currentDir).c_str());

    // 5. Find the Pattern of start data and the size of the data
    auto result = PatternScan((uintptr_t)launcherData, "A7 ED 96 0C 0F");

    auto size1 = *(uint32_t*)ResolveRelative(
        PatternScan((uintptr_t)launcherData, "BE ? ? ? ? E9 ? ? ? ? 8B 3D").at(0) + 0xA, 2, 6);
    auto size2 = *(uint32_t*)ResolveRelative(PatternScan((uintptr_t)launcherData, "8B 15 ? ? ? ? 48 89 7C 24").at(0), 2,
                                             6);

    // 6. Copy to an Vector
    auto driverDataEncrypted     = std::vector<uint8_t>((uint8_t*)result.at(0), (uint8_t*)result.at(0) + size1);
    auto userModeDriverEncrypted = std::vector<uint8_t>((uint8_t*)result.at(1), (uint8_t*)result.at(1) + size2);

    // 7. Decrypt the data
    auto driverDataDecrypted   = DecryptBuffer(&driverDataEncrypted);
    auto usermodeDataDecrypted = DecryptBuffer(&userModeDriverEncrypted);

    // 8. Save the data
    SaveBinaryFile(std::format("{}\\EAC_Driver.sys", currentDir), driverDataDecrypted);
    SaveBinaryFile(std::format("{}\\EAC_UserMode.dll", currentDir), usermodeDataDecrypted);

    // 9. Print the result
    std::printf("[-] All files successfully generated! \n");
    Sleep(1000);


    return 0;
}

```

`DecryptEACPayload.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.4.33213.308
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DecryptEACPayload", "DecryptEACPayload.vcxproj", "{84195FF5-295B-412A-9614-9CCB44A9DCF4}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{84195FF5-295B-412A-9614-9CCB44A9DCF4}.Debug|x64.ActiveCfg = Debug|x64
		{84195FF5-295B-412A-9614-9CCB44A9DCF4}.Debug|x64.Build.0 = Debug|x64
		{84195FF5-295B-412A-9614-9CCB44A9DCF4}.Debug|x86.ActiveCfg = Debug|Win32
		{84195FF5-295B-412A-9614-9CCB44A9DCF4}.Debug|x86.Build.0 = Debug|Win32
		{84195FF5-295B-412A-9614-9CCB44A9DCF4}.Release|x64.ActiveCfg = Release|x64
		{84195FF5-295B-412A-9614-9CCB44A9DCF4}.Release|x64.Build.0 = Release|x64
		{84195FF5-295B-412A-9614-9CCB44A9DCF4}.Release|x86.ActiveCfg = Release|Win32
		{84195FF5-295B-412A-9614-9CCB44A9DCF4}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {FBDA31DE-1327-475E-91C3-AE194CD2FFC2}
	EndGlobalSection
EndGlobal

```

`DecryptEACPayload.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{84195ff5-295b-412a-9614-9ccb44a9dcf4}</ProjectGuid>
    <RootNamespace>DecryptEACPayload</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="DecryptEACPayload.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`DecryptEACPayload.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="DecryptEACPayload.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`DecryptEACPayload.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
</Project>
```

`LICENSE`:

```
MIT License

Copyright (c) 2023 Lucas Guilherme

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
![EAC Decrypt and Extract Utility](https://github.com/lguilhermee/EAC-Extractor-Utility/blob/main/logo.png)
# EAC Decrypt and Extract Utility


This project provides a utility to decrypt and extract files from an EAC (Easy Anti-Cheat) binary. The utility is designed to run on Windows.

## Requirements

- Windows Operating System
- Download EAC.Bin from EAC

## Description

This utility performs the following steps:

1. Loads an encrypted file specified as a command-line argument.
2. Decrypts the loaded file using a custom decryption algorithm.
3. Retrieves the current directory path.
4. Saves the decrypted file with a specific name in the current directory.
5. Loads the decrypted file as a library.
6. Searches for specific patterns within the loaded library to determine the start and size of data.
7. Copies encrypted data based on the identified patterns into separate vectors.
8. Decrypts the data in the vectors.
9. Saves the decrypted data as separate files in the current directory.

## Usage

Command-line usage: `EAC_Decrypt_Extract.exe <EAC.Bin>`

## Obtaining the EAC.Bin

You can download the EAC.Bin from the EAC servers. To do this, you will need to use an HTTP Debugger to acquire the link. The link format typically looks like this:

`https://modules-cdn.eac-prod.on.epicgames.com/modules/67d7e4253ad3477497a2ff44ddbd3f98/0ccb68be6228412ab45962992f0f6e7e/`


In this example:
- `67d7e4253ad3477497a2ff44ddbd3f98` is the gameid
- `0ccb68be6228412ab45962992f0f6e7e` is the uuid

Please note that these ids will differ for each game.

## Overview of EAC Operation

Easy Anti-Cheat (EAC) operates through a series of sequential steps:

1. EAC begins by executing the Launcher, whose primary responsibility is downloading and decrypting the EAC.Bin. It's important to note that the EAC.Bin already contains the Launcher, the usermode DLL, and the driver.sys.
2. The decrypted binary is loaded into memory where it performs several initialization checks. During this stage, EAC decrypts both the EAC_Usermode.dll and EAC_Driver.sys.
3. Following this, the usermode launcher loads the driver.sys.
4. The driver performs additional checks. If these checks pass, the driver loads the usermode DLL into the process by mapping it.
5. EAC continues to run until it is terminated.

This simplified description is intended to provide a general understanding of the process. The actual operation of EAC involves complex and advanced measures.

## Results

The utility generates the following files as a result of its operation:

1. EAC_Launcher.dll
2. EAC_Driver.sys
3. EAC_UserMode.dll

## Acknowledgments

Special thanks to [iPower](https://github.com/iPower) for their valuable insights.

---

Remember to always use this tool responsibly and respect the Terms Of Service of the games and services you are interacting with.

```