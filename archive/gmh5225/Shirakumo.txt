Project Path: arc_gmh5225_Shirakumo_e98fptrh

Source Tree:

```txt
arc_gmh5225_Shirakumo_e98fptrh
├── FIFO.vcxproj
├── FIFO.vcxproj.filters
├── FIFOdll
│   ├── FIFOdll.vcxproj
│   ├── FIFOdll.vcxproj.filters
│   └── dllmain.cc
├── LICENSE
├── README.md
├── Shirakumo.sln
├── examples
│   ├── CallPipe.cc
│   ├── Target.cc
│   └── build.bat
└── main.cc

```

`FIFO.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{30098c41-8078-4fa1-b38b-1113de8ea21d}</ProjectGuid>
    <RootNamespace>FIFO</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>FIFOexe</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`FIFO.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cc">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`FIFOdll/FIFOdll.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{98df96cf-7fda-4960-9484-792528242380}</ProjectGuid>
    <RootNamespace>FIFOdll</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;FIFODLL_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;FIFODLL_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;FIFODLL_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>
      </PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;FIFODLL_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>
      </PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`FIFOdll/FIFOdll.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cc">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`FIFOdll/dllmain.cc`:

```cc
#include <Windows.h>
#include <tlhelp32.h>

#include <cstdint>
#include <cstdio>
#include <cstring>
#include <string>

#define kInitFifo 0xF1F0
#define kFifoReadVm 0xF1F01
#define kFifoWriteVm 0xF1F02
#define kFifoDllBase 0xF1F04

#pragma pack(push, 1)
struct FixedStr64 {
  uint64_t blocks[4];
};
#pragma pack(pop)

#pragma pack(push, 1)
struct Requests {
  int request_key;

  uint64_t src_pid;
  uint64_t src_addr;
  uint64_t dst_pid;
  uint64_t dst_addr;
  size_t size;

  DWORD dwFlags;
  DWORD dx;
  DWORD dy;
  DWORD dwData;
  ULONG_PTR dwExtraInfo;

  uint64_t dll_base;

  FixedStr64 dll_name;
  size_t dll_name_length;
};
#pragma pack(pop)

HANDLE hSrcProcess = 0;
HANDLE hDstProcess = 0;

std::string decodeFixedStr64(const FixedStr64& fs) {
  std::string result;
  for (int i = 0; i < 4; ++i) {
    uint64_t block = fs.blocks[i];
    for (int j = 0; j < 8; ++j) {
      char c = static_cast<char>((block >> (56 - j * 8)) & 0xFF);
      if (c == '\0') break;
      result += c;
    }
  }
  return result;
}

uint64_t getDllBase(DWORD pid, const std::string& dllName) {
  HANDLE hSnapshot =
      CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, pid);
  if (hSnapshot == INVALID_HANDLE_VALUE) return 0;

  MODULEENTRY32 me;
  me.dwSize = sizeof(me);
  uint64_t base = 0;

  if (Module32First(hSnapshot, &me)) {
    do {
      std::wstring modName(me.szModule);
      std::string narrowModName(modName.begin(), modName.end());

      if (_stricmp(narrowModName.c_str(), dllName.c_str()) == 0) {
        base = reinterpret_cast<uint64_t>(me.modBaseAddr);
        break;
      }
    } while (Module32Next(hSnapshot, &me));
  }

  CloseHandle(hSnapshot);
  return base;
}

static inline void handleReadVm(Requests* req) noexcept {
  if (!hSrcProcess || !hDstProcess) {
    return;
  }
  thread_local static char buffer[0xCAFE];

  SIZE_T bytesRead = 0;
  if (ReadProcessMemory(hSrcProcess, reinterpret_cast<LPCVOID>(req->src_addr),
                        buffer, req->size, &bytesRead)) {
    WriteProcessMemory(hDstProcess, reinterpret_cast<LPVOID>(req->dst_addr),
                       buffer, bytesRead, nullptr);
  }
}

static inline void handleWriteVm(Requests* req) noexcept {
  if (!hSrcProcess || !hDstProcess) {
    return;
  }
  thread_local static char buffer[0xCAFE];

  SIZE_T bytesRead = 0;
  if (ReadProcessMemory(hSrcProcess, reinterpret_cast<LPCVOID>(req->dst_addr),
                        buffer, req->size, &bytesRead)) {
    WriteProcessMemory(hDstProcess, reinterpret_cast<LPVOID>(req->src_addr),
                       buffer, bytesRead, nullptr);
  }
}

DWORD WINAPI FIFOThread(LPVOID) {
  const char* PIPE_NAME = "\\\\.\\pipe\\Shirakumo";

  while (true) {
    printf("[+] Create Named Pipe: %s\n", PIPE_NAME);
    HANDLE hPipe = CreateNamedPipeA(
        PIPE_NAME, PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,
        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,
        PIPE_UNLIMITED_INSTANCES, sizeof(Requests), sizeof(Requests), 0, NULL);

    if (hPipe == INVALID_HANDLE_VALUE) {
      printf("[-] Create Pipe Failed (Err: %lu)\n", GetLastError());
      return 1;
    }

    printf("[+] Waiting Client...\n");
    if (!ConnectNamedPipe(hPipe, NULL)) {
      printf("[-] Connect Failed (Err: %lu)\n", GetLastError());
      CloseHandle(hPipe);
      continue;
    }

    printf("[+] Client Connected\n");

    Requests req;
    DWORD bytesRead;
    while (true) {
      if (!ReadFile(hPipe, &req, sizeof(req), &bytesRead, NULL)) {
        printf("[-] Read Failed (Err: %lu)\n", GetLastError());
        break;
      }

      if (bytesRead != sizeof(req)) {
        printf("[-] Request Packet Size Err: %lu/%zu\n", bytesRead,
               sizeof(req));
        break;
      }

      switch (req.request_key) {
        case kInitFifo:

          printf("[+] Init: PID=%llu fromPID=%llu\n", req.src_pid, req.dst_pid);
          CloseHandle(hSrcProcess);
          CloseHandle(hDstProcess);
          hSrcProcess = OpenProcess(PROCESS_VM_READ, FALSE,
                                    static_cast<DWORD>(req.src_pid));
          hDstProcess = OpenProcess(PROCESS_VM_WRITE | PROCESS_VM_OPERATION,
                                    FALSE, static_cast<DWORD>(req.dst_pid));
          break;

        case kFifoReadVm:
#ifndef NDEBUG
          printf("[+] Read: SRC_PID=%llu, ADDR=0x%p, SIZE=%zu\n", req.src_pid,
                 (void*)req.src_addr, req.size);
#endif  // !NDEBUG

          handleReadVm(&req);
          break;

        case kFifoWriteVm:
#ifndef NDEBUG
          printf("[+] Write: DST_PID=%llu, ADDR=0x%p, SIZE=%zu\n", req.src_pid,
                 (void*)req.src_addr, req.size);
#endif  // !NDEBUG
          handleWriteVm(&req);
          break;

        case kFifoDllBase: {
          std::string dllName = decodeFixedStr64(req.dll_name);
          printf("[+] Get DLL Base: PID=%llu, DLL='%s'\n", req.src_pid,
                 dllName.c_str());
          req.dll_base = getDllBase(static_cast<DWORD>(req.src_pid), dllName);
          printf("   Base Addr: 0x%p\n", (void*)req.dll_base);
          break;
        }

        default:
          printf("[-] Unk Request: 0x%X\n", req.request_key);
      }

      DWORD bytesWritten;
      if (!WriteFile(hPipe, &req, sizeof(req), &bytesWritten, NULL)) {
        printf("[-] Write Failed (Err: %lu)\n", GetLastError());
        break;
      }
    }

    DisconnectNamedPipe(hPipe);
    CloseHandle(hPipe);
    CloseHandle(hSrcProcess);
    CloseHandle(hDstProcess);
    printf("[+] Connection Closed\n\n");
  }

  return 0;
}

BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call,
                      LPVOID lpReserved) {
  switch (ul_reason_for_call) {
    case DLL_PROCESS_ATTACH:
      DisableThreadLibraryCalls(hModule);
      CreateThread(nullptr, 0, FIFOThread, nullptr, 0, nullptr);
      break;
  }
  return TRUE;
}

```

`LICENSE`:

```
TOSSUCU License

Copyright (c) 2025 渟雲

Any first-person pronouns (such as "I", "Me"), "right holder", and "Author" in this license refer to the above-mentioned right holder (in this copy of license, specifically 渟雲)

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.



Don’t think of the author as your waifu, otherwise the author has the right to be shy.

YOU MUST NOT CALL ME "33" IF U DO NOT WANT TO CALL ME "33".

You must agree that Ukia is pronounced as "Укия".

You must agree that ptr is pronounced as "Pa To Ra".

WITHOUT THE CONSENT OF YOUR LOCAL GOVERNMENT AND THE RIGHTS HOLDER, YOU MAY NOT PRINT THE CODE OF THIS SOFTWARE ON 80 LB A4 PAPER AND MIX IT WITH PASTA USING NO. 42 CONCRETE AND FEED IT TO MALE UNDERAGE VIETNAMESE CITIZENS UNDER THE AGE OF 3. OTHERWISE, YOU WILL BE RESPONSIBLE FOR THE CONSEQUENCES OF THE EXCAVATOR TORQUE AFFECTED BY THE SCREWS CAUSING THE PRODUCTION OF HIGH-ENERGY PROTEINS, INCLUDING BUT NOT LIMITED TO BEING CAPTURED BY WILD TOJO HIDEKI IN THE SENSE OF THE PYTHAGOREAN THEOREM, THEREBY AFFECTING ECONOMIC DEVELOPMENT, RADIOACTIVE CONTAMINATION CAUSED BY TRUMP'S N-TH POWER CUT SURFACE IN UFOS, AND DEPRIVATION OF THE RIGHT TO WATCH THE CONFLUENCE OF QIN SHIHUANG'S WALMART AND THE PACIFIC MOBILE PHONE CHARGER IN ANTARCTICA.

The right to interpret this license belongs to the right holder.

```

`README.md`:

```md
# Shirakumo
A RPM/WPM proxy with named pipe
---

## Features

- Implement RPM/WPM in separate processes and communicate via FIFO (named pipes) to handle requests
- Allows you load it as .dll into an existing process to implement RPM/WPM proxying in another process

## KnownIssues

- Currently only works on x64 processes
- Current implementation directly calls the Win API, so that just as a PoC
- Processing cycle for each RPM/WPM request is long, which is not suitable for high-frequency/concurrent RPM/WPM requests.
- Current implementation is not thread-safe

## License

This project is licensed under [**TOSSRCU**](LICENSE).
```diff
+ You are free to:
	• Use: Utilize the software for any purpose not explicitly restricted
	• Copy: Reproduce the software without limitation
	• Modify: Create derivative works through remixing/transforming
	• Merge: Combine with other materials
	• Publish: Display/communicate the software publicly
	• Distribute: Share copies of the software

+ Under the following terms:
	• Attribution: Must include copyright notice and this license in all copies
	• Waifu Clause: Don't consider the author as your waifu

- You are not allowed to:
	• Sublicense: Cannot grant sublicenses for original/modified material

```

```

`Shirakumo.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.14.36121.58
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "FIFOexe", "FIFO.vcxproj", "{30098C41-8078-4FA1-B38B-1113DE8EA21D}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "FIFOdll", "FIFOdll\FIFOdll.vcxproj", "{98DF96CF-7FDA-4960-9484-792528242380}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{30098C41-8078-4FA1-B38B-1113DE8EA21D}.Debug|x64.ActiveCfg = Debug|x64
		{30098C41-8078-4FA1-B38B-1113DE8EA21D}.Debug|x64.Build.0 = Debug|x64
		{30098C41-8078-4FA1-B38B-1113DE8EA21D}.Debug|x86.ActiveCfg = Debug|Win32
		{30098C41-8078-4FA1-B38B-1113DE8EA21D}.Debug|x86.Build.0 = Debug|Win32
		{30098C41-8078-4FA1-B38B-1113DE8EA21D}.Release|x64.ActiveCfg = Release|x64
		{30098C41-8078-4FA1-B38B-1113DE8EA21D}.Release|x64.Build.0 = Release|x64
		{30098C41-8078-4FA1-B38B-1113DE8EA21D}.Release|x86.ActiveCfg = Release|Win32
		{30098C41-8078-4FA1-B38B-1113DE8EA21D}.Release|x86.Build.0 = Release|Win32
		{98DF96CF-7FDA-4960-9484-792528242380}.Debug|x64.ActiveCfg = Debug|x64
		{98DF96CF-7FDA-4960-9484-792528242380}.Debug|x64.Build.0 = Debug|x64
		{98DF96CF-7FDA-4960-9484-792528242380}.Debug|x86.ActiveCfg = Debug|Win32
		{98DF96CF-7FDA-4960-9484-792528242380}.Debug|x86.Build.0 = Debug|Win32
		{98DF96CF-7FDA-4960-9484-792528242380}.Release|x64.ActiveCfg = Release|x64
		{98DF96CF-7FDA-4960-9484-792528242380}.Release|x64.Build.0 = Release|x64
		{98DF96CF-7FDA-4960-9484-792528242380}.Release|x86.ActiveCfg = Release|Win32
		{98DF96CF-7FDA-4960-9484-792528242380}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {1FBF84B0-2323-43DF-AD86-A34AC99C3CCD}
	EndGlobalSection
EndGlobal

```

`examples/CallPipe.cc`:

```cc

#include <Windows.h>
#include <TlHelp32.h>
#include <fileapi.h>
#include <handleapi.h>
#include <windows.h>

#include <cstdint>
#include <cstdio>
#include <cstring>
#include <mutex>
#include <string>

#define kInitFifo 0xF1F0
#define kFifoReadVm 0xF1F01
#define kFifoWriteVm 0xF1F02
#define kFifoDllBase 0xF1F04

#pragma pack(push, 1)
struct FixedStr64 {
  uint64_t blocks[4];
};
#pragma pack(pop)

inline void encodeFixedStr64(const char* str, FixedStr64* fs) {
  size_t len = strlen(str);
  if (len > 32) {
    len = 32;
  }
  memset(fs->blocks, 0, sizeof(fs->blocks));
  for (size_t i = 0; i < len; i++) {
    size_t blockIndex = i / 8;
    size_t posInBlock = i % 8;
    int shift = 8 * (7 - posInBlock);
    fs->blocks[blockIndex] |=
        (static_cast<uint64_t>(static_cast<unsigned char>(str[i])) << shift);
  }
}

#pragma pack(push, 1)
struct Requests {
  int request_key;

  uint64_t src_pid;
  uint64_t src_addr;
  uint64_t dst_pid;
  uint64_t dst_addr;
  size_t size;

  DWORD dwFlags;
  DWORD dx;
  DWORD dy;
  DWORD dwData;
  ULONG_PTR dwExtraInfo;

  uint64_t dll_base;

  FixedStr64 dll_name;
  size_t dll_name_length;
};
#pragma pack(pop)

inline bool pipeRequest(HANDLE pipe_handle, Requests* req) {
  DWORD bytes_written = 0;
  if (!WriteFile(pipe_handle, req, sizeof(Requests), &bytes_written, nullptr) ||
      bytes_written != sizeof(Requests)) {
    return false;
  }

  DWORD bytes_read = 0;
  if (!ReadFile(pipe_handle, req, sizeof(Requests), &bytes_read, nullptr) ||
      bytes_read != sizeof(Requests)) {
    return false;
  }
  return true;
}

class Fifo {
 public:
  void initPipe(int process_id) {
    pipe_handle_ =
        CreateFileA("\\\\.\\pipe\\Shirakumo", GENERIC_READ | GENERIC_WRITE, 0,
                    nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);

    if (pipe_handle_ != INVALID_HANDLE_VALUE) {
      process_id_ = process_id;
    } else {
      return;
    }
    Requests out = {0};
    out.request_key = kInitFifo;
    out.src_pid = process_id_;
    out.dst_pid = static_cast<uint64_t>(GetCurrentProcessId());
    {
      std::lock_guard<std::mutex> lock(pipe_mutex_);
      if (!pipeRequest(pipe_handle_, &out)) {
        return;
      }
    }
  }

  void readSize(const uintptr_t address, const void* buffer,
                const size_t size) {
    readVm(process_id_, address, reinterpret_cast<uint64_t>(buffer), size);
  }

  template <typename T>
  void write(uintptr_t address, const T& buffer, int size) {
    writeVm(process_id_, address, reinterpret_cast<uint64_t>(&buffer), size);
  }

  ULONG64 dllAddress(const char* dll_name) {
    Requests out = {};
    out.request_key = kFifoDllBase;
    out.src_pid = process_id_;

    size_t original_len = strlen(dll_name);
    if (original_len > 32) {
      original_len = 32;
    }
    out.dll_name_length = original_len;
    FixedStr64 fs;
    encodeFixedStr64(dll_name, &fs);
    out.dll_name = fs;

    {
      std::lock_guard<std::mutex> lock(pipe_mutex_);
      if (!pipeRequest(pipe_handle_, &out)) {
        return 0;
      }
    }
    return static_cast<ULONG64>(out.dll_base);
  }

 private:
  HANDLE pipe_handle_;
  int process_id_;
  std::mutex pipe_mutex_;

  void readVm(uint32_t src_pid, uint64_t src_addr, uint64_t dst_addr,
              size_t size) {
    if (src_pid == 0 || src_addr == 0) return;

    Requests out = {kFifoReadVm, src_pid,
                    src_addr,    static_cast<uint64_t>(GetCurrentProcessId()),
                    dst_addr,    size};

    {
      std::lock_guard<std::mutex> lock(pipe_mutex_);
      if (!pipeRequest(pipe_handle_, &out)) {
      }
    }
  }

  void writeVm(uint32_t src_pid, uint64_t src_addr, uint64_t dst_addr,
               size_t size) {
    if (src_pid == 0 || dst_addr == 0) return;

    Requests out = {kFifoWriteVm, src_pid,
                    src_addr,     static_cast<uint64_t>(GetCurrentProcessId()),
                    dst_addr,     size};

    {
      std::lock_guard<std::mutex> lock(pipe_mutex_);
      if (!pipeRequest(pipe_handle_, &out)) {
      }
    }
  }
};

inline Fifo fifo;

DWORD GetProcessIdByName(const wchar_t* processName) {
    PROCESSENTRY32W pe32;
    pe32.dwSize = sizeof(PROCESSENTRY32W);
    
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot == INVALID_HANDLE_VALUE) {
        return 0;
    }
    
    if (!Process32FirstW(hSnapshot, &pe32)) {
        CloseHandle(hSnapshot);
        return 0;
    }
    
    DWORD pid = 0;
    do {
        if (_wcsicmp(pe32.szExeFile, processName) == 0) {
            pid = pe32.th32ProcessID;
            break;
        }
    } while (Process32NextW(hSnapshot, &pe32));
    
    CloseHandle(hSnapshot);
    return pid;
}

int main(void){
    fifo.initPipe(GetProcessIdByName(L"Target.exe"));
    if (fifo.dllAddress("Target.exe") == 0) {
        printf("Failed init\n");
        system("pause");
        return 1;
    }
    DWORD64 target_var;
    fifo.readSize(0xDEAD0000, &target_var, sizeof(target_var));
    printf ("readed target_var = 0x%X at 0x%llX\n", 
        target_var, 0xDEAD0000);
    printf ("done\n");
    system("pause");
    return 0;
}
```

`examples/Target.cc`:

```cc
#include <windows.h>
#include <iostream>
#include <iomanip>

const DWORD64 TARGET_BASE_ADDRESS = 0xDEAD0000;

int main() {
    LPVOID allocated = VirtualAlloc(
        (LPVOID)TARGET_BASE_ADDRESS,
        sizeof(DWORD64),
        MEM_COMMIT | MEM_RESERVE,
        PAGE_READWRITE
    );

    if (!allocated) {
        return 1;
    }

    volatile DWORD64* fixedVar = (volatile DWORD64*)allocated;
    
    *fixedVar = 0x114514;

    std::cout << "\nTarget var at 0x" << std::hex << (DWORD64)fixedVar 
              << " = 0x" << std::hex << *fixedVar << std::dec << "\n";

    system("pause");

    VirtualFree(allocated, 0, MEM_RELEASE);
    return 0;
}
```

`examples/build.bat`:

```bat
call g++ Target.cc -o Target.exe
call g++ CallPipe.cc -o CallPipe.exe -pthread
```

`main.cc`:

```cc
#include <Windows.h>
#include <tlhelp32.h>

#include <cstdint>
#include <cstdio>
#include <cstring>
#include <string>

#define kInitFifo 0xF1F0
#define kFifoReadVm 0xF1F01
#define kFifoWriteVm 0xF1F02
#define kFifoDllBase 0xF1F04

#pragma pack(push, 1)
struct FixedStr64 {
  uint64_t blocks[4];
};
#pragma pack(pop)

#pragma pack(push, 1)
struct Requests {
  int request_key;

  uint64_t src_pid;
  uint64_t src_addr;
  uint64_t dst_pid;
  uint64_t dst_addr;
  size_t size;

  DWORD dwFlags;
  DWORD dx;
  DWORD dy;
  DWORD dwData;
  ULONG_PTR dwExtraInfo;

  uint64_t dll_base;

  FixedStr64 dll_name;
  size_t dll_name_length;
};
#pragma pack(pop)

HANDLE hSrcProcess = 0;
HANDLE hDstProcess = 0;

std::string decodeFixedStr64(const FixedStr64& fs) {
  std::string result;
  for (int i = 0; i < 4; ++i) {
    uint64_t block = fs.blocks[i];
    for (int j = 0; j < 8; ++j) {
      char c = static_cast<char>((block >> (56 - j * 8)) & 0xFF);
      if (c == '\0') break;
      result += c;
    }
  }
  return result;
}

uint64_t getDllBase(DWORD pid, const std::string& dllName) {
  HANDLE hSnapshot =
      CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, pid);
  if (hSnapshot == INVALID_HANDLE_VALUE) return 0;

  MODULEENTRY32 me;
  me.dwSize = sizeof(me);
  uint64_t base = 0;

  if (Module32First(hSnapshot, &me)) {
    do {
      std::wstring modName(me.szModule);
      std::string narrowModName(modName.begin(), modName.end());

      if (_stricmp(narrowModName.c_str(), dllName.c_str()) == 0) {
        base = reinterpret_cast<uint64_t>(me.modBaseAddr);
        break;
      }
    } while (Module32Next(hSnapshot, &me));
  }

  CloseHandle(hSnapshot);
  return base;
}

static inline void handleReadVm(Requests* req) noexcept {
  if (!hSrcProcess || !hDstProcess) {
    return;
  }
  thread_local static char buffer[0xCAFE];

  SIZE_T bytesRead = 0;
  if (ReadProcessMemory(hSrcProcess, reinterpret_cast<LPCVOID>(req->src_addr),
                        buffer, req->size, &bytesRead)) {
    WriteProcessMemory(hDstProcess, reinterpret_cast<LPVOID>(req->dst_addr),
                       buffer, bytesRead, nullptr);
  }
}

static inline void handleWriteVm(Requests* req) noexcept {
  if (!hSrcProcess || !hDstProcess) {
    return;
  }
  thread_local static char buffer[0xCAFE];

  SIZE_T bytesRead = 0;
  if (ReadProcessMemory(hSrcProcess, reinterpret_cast<LPCVOID>(req->dst_addr),
                        buffer, req->size, &bytesRead)) {
    WriteProcessMemory(hDstProcess, reinterpret_cast<LPVOID>(req->src_addr),
                       buffer, bytesRead, nullptr);
  }
}

int main() {
  const char* PIPE_NAME = "\\\\.\\pipe\\Shirakumo";

  while (true) {
    printf("[+] Create Named Pipe: %s\n", PIPE_NAME);
    HANDLE hPipe = CreateNamedPipeA(
        PIPE_NAME, PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,
        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,
        PIPE_UNLIMITED_INSTANCES, sizeof(Requests), sizeof(Requests), 0, NULL);

    if (hPipe == INVALID_HANDLE_VALUE) {
      printf("[-] Create Pipe Failed (Err: %lu)\n", GetLastError());
      return 1;
    }

    printf("[+] Waiting Client...\n");
    if (!ConnectNamedPipe(hPipe, NULL)) {
      printf("[-] Connect Failed (Err: %lu)\n", GetLastError());
      CloseHandle(hPipe);
      continue;
    }

    printf("[+] Client Connected\n");

    Requests req;
    DWORD bytesRead;
    while (true) {
      if (!ReadFile(hPipe, &req, sizeof(req), &bytesRead, NULL)) {
        printf("[-] Read Failed (Err: %lu)\n", GetLastError());
        break;
      }

      if (bytesRead != sizeof(req)) {
        printf("[-] Request Packet Size Err: %lu/%zu\n", bytesRead,
               sizeof(req));
        break;
      }

      switch (req.request_key) {
        case kInitFifo:

          printf("[+] Init: PID=%llu fromPID=%llu\n", req.src_pid, req.dst_pid);
          CloseHandle(hSrcProcess);
          CloseHandle(hDstProcess);
          hSrcProcess = OpenProcess(PROCESS_VM_READ, FALSE,
                                    static_cast<DWORD>(req.src_pid));
          hDstProcess = OpenProcess(PROCESS_VM_WRITE | PROCESS_VM_OPERATION,
                                    FALSE, static_cast<DWORD>(req.dst_pid));
          break;

        case kFifoReadVm:
#ifndef NDEBUG
          printf("[+] Read: SRC_PID=%llu, ADDR=0x%p, SIZE=%zu\n", req.src_pid,
                 (void*)req.src_addr, req.size);
#endif  // !NDEBUG

          handleReadVm(&req);
          break;

        case kFifoWriteVm:
#ifndef NDEBUG
          printf("[+] Write: DST_PID=%llu, ADDR=0x%p, SIZE=%zu\n", req.src_pid,
                 (void*)req.src_addr, req.size);
#endif  // !NDEBUG
          handleWriteVm(&req);
          break;

        case kFifoDllBase: {
          std::string dllName = decodeFixedStr64(req.dll_name);
          printf("[+] Get DLL Base: PID=%llu, DLL='%s'\n", req.src_pid,
                 dllName.c_str());
          req.dll_base = getDllBase(static_cast<DWORD>(req.src_pid), dllName);
          printf("   Base Addr: 0x%p\n", (void*)req.dll_base);
          break;
        }

        default:
          printf("[-] Unk Request: 0x%X\n", req.request_key);
      }

      DWORD bytesWritten;
      if (!WriteFile(hPipe, &req, sizeof(req), &bytesWritten, NULL)) {
        printf("[-] Write Failed (Err: %lu)\n", GetLastError());
        break;
      }
    }

    DisconnectNamedPipe(hPipe);
    CloseHandle(hPipe);
    CloseHandle(hSrcProcess);
    CloseHandle(hDstProcess);
    printf("[+] Connection Closed\n\n");
  }

  return 0;
}
```