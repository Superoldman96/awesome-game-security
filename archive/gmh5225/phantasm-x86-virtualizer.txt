Project Path: arc_gmh5225_phantasm-x86-virtualizer_zk43r_84

Source Tree:

```txt
arc_gmh5225_phantasm-x86-virtualizer_zk43r_84
├── .git
│   ├── hooks
│   ├── info
│   ├── objects
│   │   ├── info
│   │   └── pack
│   └── refs
│       ├── heads
│       ├── remotes
│       │   └── origin
│       └── tags
├── .gitignore
├── README.md
├── chvrn_vm
│   ├── ArgsParser.cpp
│   ├── ArgsParser.h
│   ├── CodeChunk.cpp
│   ├── CodeChunk.h
│   ├── MappedFile.cpp
│   ├── MappedFile.h
│   ├── MappedPeFile.cpp
│   ├── MappedPeFile.h
│   ├── SettingsManager.cpp
│   ├── SettingsManager.h
│   ├── StackMutator.cpp
│   ├── StackMutator.h
│   ├── Utils.cpp
│   ├── Utils.h
│   ├── VirtualizerList.cpp
│   ├── VirtualizerList.h
│   ├── Vm.cpp
│   ├── Vm.h
│   ├── VmInstruction.cpp
│   ├── VmInstruction.h
│   ├── beaengine
│   │   ├── BeaEngine.h
│   │   ├── basic_types.h
│   │   ├── export.h
│   │   └── macros.h
│   ├── build.h
│   ├── cli.cpp
│   ├── cli.h
│   ├── control.cpp
│   ├── control.h
│   ├── data.cpp
│   ├── data.h
│   ├── environment.cpp
│   ├── environment.h
│   ├── install.cpp
│   ├── install.h
│   ├── log.cpp
│   ├── log.h
│   ├── logic.cpp
│   ├── logic.h
│   ├── main.cpp
│   ├── markers.cpp
│   ├── markers.h
│   ├── patterns.cpp
│   ├── patterns.h
│   ├── registerswap.cpp
│   ├── registerswap.h
│   ├── relocations.cpp
│   ├── relocations.h
│   ├── settings.cpp
│   ├── settings.h
│   ├── stack.cpp
│   ├── stack.h
│   ├── stdafx.cpp
│   ├── stdafx.h
│   ├── targetver.h
│   ├── x86.cpp
│   ├── x86.h
│   ├── x86Instruction.cpp
│   ├── x86Instruction.h
│   ├── x86vm.cpp
│   └── x86vm.h
├── example.md
├── libphant
│   └── ReadMe.txt
├── libphant_debug
│   └── ReadMe.txt
├── sdk_example
│   ├── phant.h
│   ├── sdk_example.cpp
│   ├── stdafx.cpp
│   ├── stdafx.h
│   └── targetver.h
├── sdk_example_two
│   ├── phant.h
│   ├── sdk_example_two.cpp
│   ├── stdafx.cpp
│   ├── stdafx.h
│   └── targetver.h
└── vm
    ├── libphant.asm
    └── libphant_obf.asm

```

`.gitignore`:

```
*
!*/
!.gitignore

Debug/
Release/

logs/
temp/

!*.asm
!*.c
!*.cpp
!*.h
!*.txt
!*.md
```

`README.md`:

```md
# x86 virtualizer
This is a simple virtualization-based obfuscator for x86 code. 

A quick run-down of how it works:
- Each input instruction (native, x86) is assigned one or more bytecode instructions mapped to handlers implemented in the VM.
- Bytecode instruction set is intended to be RISC and very stack-oriented
- Input instructions are thus if needed broken down into more atomical operations. For instance, instructions using scaled addressing (i.e. has an operand in the form [base_reg+index_reg*scalar+displacement]) are converted. The value of the operands of such an instruction are calculated at run-time using a sequence of virtual instructions. Move instructions are all push and pops.
- Many instructions share a common handler. For instance, the bitwise logical operations are all implemented using a single NAND handler (they all set the same flags, just use DeMorgan's laws to change things around). Likewise, CMP can be implemented as a SUB where the result (bar the flags) is discarded.
- Instructions that do not have an implementation in the VM are executed as-is in an executable buffer by doing a temporary context switch out of the VM. Certain instructions cannot be executed in this manner (any instruction changing the IP) and most of these have implementations.
- Jumps and calls need special treatment depending on whether the destination is inside a virtualized region or not.
- The destinations for indirect absolute jumps and calls (i.e. through a register or value at address) are not inferred by the virtualizer and must be manually specified by the user.

## Example usage
### Protecting the program
The VM implementation is either included in the target program by statically linking to it, or by having the virtualizer manually copy it into the executable. The code to be protected is either specified as input arguments or by using the markers defined in the header file. Using the input arguments, the regions to protect are specified by their starting virtual address (in the executable's preferred base) and the length in bytes. Using the markers, they are to be placed within a function: 

```c++
#include "libphant.h"
int main(int argc, const char *argv[])
{
    BeginProtect;
    // code to protect here
    EndProtect;
}
```
Markers need to appear in pairs and may not be nested (could accidentally happen if a function called inside a protected area is instead inlined by the compiler).

See a more complete example [here](example.md) (called "SDK example two" in the source).

## Command-line arguments
```
input_file="path to the input exe"
```
Path to input filename
```
output_file="path to the output exe"
```
Path to output file. Will be created/overwritten. 
```
va_target="virtual address"
```
Inform of a VA used in an absolute jump or call leading inside a virtualized region. Hexadecimal in preferred base, no prefix or suffix.
```
unfold_constants="<0/1>"
```
Simple unfolding of constants (as n=q*d+r)

```
swap_registers="<0/1>"
```
Adds prologue/epilogue code to swap every register in the context structure.

## Needed improvements
Just a few glaring ones
- Control flow obfuscation. Using the VM IP the control flow can easily be mapped out in order to defeat protection against patching etc. with little hassle.
- Obufscation of the VM itself. Handlers are easy to map to each instructions, and the meaning of each handler is easy to figure out.
- Relocatable executable. Relocations are currently not implemented. There are some stubs for this.
- Proper register swapping interleaved with the rest of the code

```

`chvrn_vm/ArgsParser.cpp`:

```cpp
#include "stdafx.h"
#include "ArgsParser.h"

using namespace std;

bool ArgsParser::parseMainArgs(int argc, char **argv) {
	for (int i = 0; i < argc; i++) {
		char *valuePtr = strchr(argv[i], '=');
		if (!valuePtr) {
			addArg(argv[i], "");
			continue;
		}
		valuePtr++;
		int nameLen = valuePtr-argv[i]-1;

		string name(argv[i], nameLen);
		string value(valuePtr);

		addArg(name, value);
	}

	return true;
}

void ArgsParser::addArg(string name, string value) {
	if (m_arguments.find(name) == m_arguments.end()) {
		m_arguments[name] = vector<string>();
	}
	m_arguments[name].push_back(value);
}

vector<string> *ArgsParser::getArgs(string name) {
	if (m_arguments.find(name) == m_arguments.end()) {
		return nullptr;
	}
	return &m_arguments[name];
}

int ArgsParser::getArgCount() {
	return m_arguments.size();
}

int ArgsParser::getArgCount(string name) {
	if (!getArgs(name)) {
		return 0; 
	} else {
		return getArgs(name)->size();
	}
}

string ArgsParser::getArgStringOccurrence(string name, int idx) {
	if (!getArgs(name)) {
		return "";
	} else {
		return (*getArgs(name))[idx];
	}
}

int ArgsParser::getArgIntOccurrence(string name, int idx, int base) {
	if (!getArgs(name)) {
		return 0;
	} else {
		try {
		return stoi((*getArgs(name))[idx], 0, base);
		} catch (exception e) {
			logger.write(LOG_WARN, "Unexpected format for integer argument\n");
			return 0;
		}
	}
}

string ArgsParser::getArgString(string name) {
	return getArgStringOccurrence(name, 0);
}

int ArgsParser::getArgInt(string name, int base) {
	return getArgIntOccurrence(name, 0, base);
}

void ArgsParser::print() const {
	for (auto& it0 : m_arguments) {
		logger.write(LOG_MSG, "%s\n", it0.first.c_str());
		for (auto& it1 : it0.second) {
			if (it1.length()) {
				logger.write(LOG_MSG, "\t%s\n", it1.c_str());
			}
		}
	}
}
```

`chvrn_vm/ArgsParser.h`:

```h
#include "stdafx.h"

class ArgsParser {
public:
	bool parseMainArgs(int argc, char **argv);

	int getArgCount();
	int getArgCount(std::string name);
	std::string getArgStringOccurrence(std::string name, int idx);
	int getArgIntOccurrence(std::string name, int idx, int base=10);

	std::string getArgString(std::string name);
	int getArgInt(std::string name, int base=10);

	void print() const;
private:
	void addArg(std::string name, std::string value);
	std::vector<std::string> *getArgs(std::string name);
	std::map<std::string, std::vector<std::string>> m_arguments;
};
```

`chvrn_vm/CodeChunk.cpp`:

```cpp
#include "stdafx.h"
#include "CodeChunk.h"

CodeChunk::CodeChunk(DWORD base)
	: m_base(base), m_ip(0), m_size(0), m_bytes(nullptr) {
}

CodeChunk::CodeChunk(const CodeChunk& code)
	: m_base(code.m_base), m_ip(code.m_ip), m_size(code.m_size) {
	m_vmInstructions = std::vector<VmInstruction*>(code.m_vmInstructions.size());
	for (std::size_t i = 0; i < code.m_vmInstructions.size(); i++) {
		m_vmInstructions[i] = new VmInstruction(*code.m_vmInstructions[i]);
	}
	m_x86Instructions = std::vector<x86Instruction*>(code.m_x86Instructions.size());
	for (std::size_t i = 0; i < code.m_x86Instructions.size(); i++) {
		m_x86Instructions[i] = code.m_x86Instructions[i] ? new x86Instruction(*code.m_x86Instructions[i]) : nullptr;
	}
	m_bytes = new BYTE[code.m_size];
	memcpy(m_bytes, code.m_bytes, code.m_size);
}

CodeChunk::~CodeChunk() {
	if (m_bytes) {
		delete[] m_bytes;
		m_bytes = nullptr;
	}
	for (auto it : m_vmInstructions) {
		delete it;
	}
	for (auto it : m_x86Instructions) {
		if (it) {
			delete it;
		}
	}
}

VmInstruction *CodeChunk::addInstruction(const VmInstruction& instruction, DISASM *disasm, bool vaDependent) {
	DWORD newVa = getLastVa();
	VmInstruction *newInstr = new VmInstruction(instruction);
	
	newInstr->setVirtualAddress(newVa);
	m_vmInstructions.push_back(newInstr);
	m_size += newInstr->getLength();

	x86Instruction *instr = nullptr;
	if (disasm) {
		instr = new x86Instruction(disasm, disasm->SecurityBlock, vaDependent);
	}
	
	m_x86Instructions.push_back(instr);

	return newInstr;
}

DWORD CodeChunk::getBaseVa() const {
	return m_base;
}

DWORD CodeChunk::getSize() const {
	return m_size;
}

unsigned int CodeChunk::getCount() const {
	return m_vmInstructions.size();
}

DWORD CodeChunk::getLastVa() const {
	return m_base + m_size;
}

DWORD CodeChunk::getNewVa(DWORD va) const {
	for (unsigned int i = 0; i < m_x86Instructions.size(); i++) {
		if (!m_x86Instructions[i]) {
			continue;
		}
		if (m_x86Instructions[i]->getVirtualAddress() == va) {
			return m_vmInstructions[i]->getVirtualAddress();
		}
	}
	return -1;
}
bool CodeChunk::recalculateRelativeOperands() {
	for (unsigned int i = 0; i < m_vmInstructions.size(); i++) {
		// operand needs recalculating
		if (!m_x86Instructions[i]) {	// native instruction has no coupling with a virtual one
			continue;
		}
		if (m_x86Instructions[i]->isVaDependent()) {
			if (m_vmInstructions[i]->getLength() == 5) {
				DWORD oldDest = m_vmInstructions[i]->getOperand32();
				DWORD newDest = getNewVa(oldDest);

				if (newDest == -1) {
					logger.write(LOG_ERROR, "Could not look up VA: %x. Jump outside virtualized chunk?\n", newDest);

					newDest = getBaseVa() + getSize();
					logger.write(LOG_MSG, "-> Setting jmp to end of chunk, %x\n", newDest);
				}

				DWORD newDistance = newDest-(m_vmInstructions[i]->getVirtualAddress() + m_vmInstructions[i]->getLength());
				m_vmInstructions[i]->setOperand32(newDistance);

			} else {
				logger.write(LOG_ERROR, "Non-DWORD lengths not supported yet\n");
				return false;
			}
		}
	}
	return true;
}

bool CodeChunk::finalize() {
	return false;
}

const BYTE *CodeChunk::createByteBuffer() {
	if (m_bytes) {
		delete[] m_bytes;
	}
	m_bytes = new BYTE[m_size];

	DWORD numWritten = 0;
	for (unsigned int i = 0; i < m_vmInstructions.size(); i++) {
		memcpy(m_bytes+numWritten, m_vmInstructions[i]->getBytes(), m_vmInstructions[i]->getLength());
		numWritten += m_vmInstructions[i]->getLength();
	}

	return m_bytes;
}

void CodeChunk::print() const {
	for (unsigned int i = 0; i < m_vmInstructions.size(); i++) {
		logger.write(LOG_MSG, "%08x->%08x %s\n", m_x86Instructions[i] != 0 ? m_x86Instructions[i]->getVirtualAddress() : 0, m_vmInstructions[i]->getVirtualAddress(), m_vmInstructions[i]->toString());
	}
}

VmInstruction*& CodeChunk::operator[](const int idx) {
	return m_vmInstructions[idx];
}

DWORD CodeChunk::getIp() const {
	return m_ip;
}

void CodeChunk::setIp(DWORD ip) {
	m_ip = ip;
}

DWORD CodeChunk::getInstructionAddress(DWORD va) const {
	DWORD newVa = getNewVa(va);
	if (newVa == -1) {
		return (DWORD)-1;
	}

	return newVa+getIp();
}
```

`chvrn_vm/CodeChunk.h`:

```h
#pragma once
#include "stdafx.h"
#include "VmInstruction.h"
#include "x86Instruction.h"

class CodeChunk {
public:
	CodeChunk(DWORD base);
	CodeChunk(const CodeChunk& code);
	virtual ~CodeChunk();
	VmInstruction *addInstruction(const VmInstruction &instruction, DISASM *disasm, bool vaDependent=false);
	DWORD getBaseVa() const;
	DWORD getSize() const;
	unsigned int getCount() const;
	DWORD getLastVa() const;

	DWORD getNewVa(DWORD va) const;
	bool recalculateRelativeOperands();

	bool finalize();

	const BYTE *createByteBuffer();
	void print() const;

	VmInstruction*& operator[](const int idx);

	void addAbsoluteMapping(DWORD va);
	BYTE *getAddressLookupTable(DWORD *size);
	BYTE *getAddressValuesTable(DWORD *size);

	DWORD getIp() const;
	void setIp(DWORD ip);
	DWORD getInstructionAddress(DWORD va) const;

protected:
	std::vector<VmInstruction*> m_vmInstructions;
	std::vector<x86Instruction*> m_x86Instructions;
	std::vector<DWORD> m_newVas;
	DWORD m_base;
	DWORD m_size;
	BYTE *m_bytes;
	DWORD m_ip;
};
```

`chvrn_vm/MappedFile.cpp`:

```cpp
#include "stdafx.h"
#include "MappedFile.h"

MappedFile::MappedFile(const char *filename) {
	m_isMapped = false;
	m_filename = filename;
}

MappedFile::~MappedFile() {
	unmap();
}

bool MappedFile::map(DWORD extensionSize) {
	m_extensionSize = extensionSize;

	m_fileHandle = CreateFileA(m_filename, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (m_fileHandle == INVALID_HANDLE_VALUE) {
		logger.write(LOG_ERROR, "CreateFile failed: %d\n", GetLastError());
		return false;
	}

	m_fileSize = GetFileSize(m_fileHandle, NULL);
	if (m_fileSize == -1) {
		logger.write(LOG_ERROR, "GetFileSize failed: %d\n", GetLastError());
		CloseHandle(m_fileHandle);
		return false;
	}
	
	m_fileMappingObject = CreateFileMappingA(m_fileHandle, NULL, PAGE_READWRITE, 0, m_fileSize + m_extensionSize, NULL);
	if (m_fileMappingObject == NULL) {
		logger.write(LOG_ERROR, "CreateFileMappingA failed: %d\n", GetLastError());

		CloseHandle(m_fileHandle);
		return false;
	}

	m_fileBuf = (BYTE*)MapViewOfFile(m_fileMappingObject, FILE_MAP_ALL_ACCESS, 0, 0, 0);
	if (m_fileBuf == NULL) {
		logger.write(LOG_ERROR, "MapViewOfFile failed: %d\n", GetLastError());

		CloseHandle(m_fileHandle);
		return false;
	}

	m_isMapped = true;
	return true;
}

void MappedFile::unmap() {
	if (m_isMapped) {
		FlushViewOfFile(m_fileBuf, 0);
		UnmapViewOfFile(m_fileBuf);
		CloseHandle(m_fileMappingObject);
		CloseHandle(m_fileHandle);
		m_isMapped = false;
	}
}

bool MappedFile::remap(DWORD extensionSize) {
	unmap();
	return map(extensionSize);
}

BYTE *MappedFile::getFileBuffer() const {
	return m_fileBuf;
}

DWORD MappedFile::getTotalSize() const {
	return m_fileSize + m_extensionSize;
};
```

`chvrn_vm/MappedFile.h`:

```h
#pragma once
#include "stdafx.h"

class MappedFile {
public:
	MappedFile(const char *filename);
	~MappedFile();
	virtual bool map(DWORD extensionSize=0);
	virtual void unmap();
	bool remap(DWORD extensionSize=0);
	BYTE *getFileBuffer() const;
	DWORD getTotalSize() const;
protected:
	bool m_isMapped;
	const char *m_filename;
	DWORD m_extensionSize;
	BYTE *m_fileBuf;
	DWORD m_fileSize;
	HANDLE m_fileHandle;
	HANDLE m_fileMappingObject;
};

MappedFile* File_Map(const char *szFileName, DWORD dwExtensionSize);
void File_Unmap(MappedFile **file);
```

`chvrn_vm/MappedPeFile.cpp`:

```cpp
#include "stdafx.h"
#include "MappedPeFile.h"
#include "Utils.h"
#include "cli.h"

MappedPeFile::MappedPeFile(const char *filename) : MappedFile(filename) {

}

bool MappedPeFile::map(DWORD extensionSize)
{
	if (!MappedFile::map(extensionSize)) {
		return false;
	}

	m_pDOS = (PIMAGE_DOS_HEADER)m_fileBuf;
	if (m_pDOS->e_magic != IMAGE_DOS_SIGNATURE) {
		printf("invalid DOS signature\n");
		return false;
	}

	m_pNT = (PIMAGE_NT_HEADERS)(m_fileBuf + m_pDOS->e_lfanew);
	if (m_pNT->Signature != IMAGE_NT_SIGNATURE) {
		printf("invalid PE signature\n");
		return false;
	}
	
	m_pSectionTable = (PIMAGE_SECTION_HEADER)((DWORD)&m_pNT->OptionalHeader + m_pNT->FileHeader.SizeOfOptionalHeader);
	m_pImportDataDirectory = &m_pNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];

	parseRelocations();

	return true;
}

PIMAGE_DOS_HEADER MappedPeFile::getDosHeader() {
	return m_pDOS;
}

PIMAGE_NT_HEADERS MappedPeFile::getNtHeaders() {
	return m_pNT;
}

PIMAGE_SECTION_HEADER MappedPeFile::getSectionTable() {
	return m_pSectionTable;
}

DWORD MappedPeFile::rva2FileOffset(DWORD rva) const
{
	for (int i = 0; i < m_pNT->FileHeader.NumberOfSections; i++)
	{
		if (m_pSectionTable[i].VirtualAddress <= rva && rva < m_pSectionTable[i].VirtualAddress +m_pSectionTable[i].SizeOfRawData) {
			return (rva - m_pSectionTable[i].VirtualAddress) + m_pSectionTable[i].PointerToRawData;
		}
	}
	return 0;
}

DWORD MappedPeFile::va2FileOffset(DWORD va) const
{
	return rva2FileOffset(va-m_pNT->OptionalHeader.ImageBase);
}

void *MappedPeFile::va2ptr(DWORD va) const {
	return (void*)(getFileBuffer() + va2FileOffset(va));
}

DWORD MappedPeFile::fileOffset2Rva(DWORD offset) const
{
	for (int i = 0; i < m_pNT->FileHeader.NumberOfSections; i++)
	{
		if (m_pSectionTable[i].PointerToRawData <= offset && offset < m_pSectionTable[i].PointerToRawData + m_pSectionTable[i].SizeOfRawData) {
			return (offset - m_pSectionTable[i].PointerToRawData) + m_pSectionTable[i].VirtualAddress;
		}
	}
	return 0;
}

DWORD MappedPeFile::fileOffset2Va(DWORD offset) const
{
	return fileOffset2Rva(offset) + m_pNT->OptionalHeader.ImageBase;
}


DWORD MappedPeFile::ptr2offset(void *ptr) {
	return (DWORD)ptr - (DWORD)getFileBuffer();
}

DWORD MappedPeFile::ptr2va(void *ptr) {
	return fileOffset2Va(ptr2offset(ptr));
}

// Returns the offset to the current EOF, which should be a multiple of FileAlignment.
// Unlike using the file size, this will not count any bytes appended to the end of the file that are located past the last section
DWORD MappedPeFile::getOffsetToEof()
{
	return m_pSectionTable[m_pNT->FileHeader.NumberOfSections - 1].PointerToRawData + m_pSectionTable[m_pNT->FileHeader.NumberOfSections - 1].SizeOfRawData;
}

DWORD MappedPeFile::getNextSectionAlignedVa()
{
	PIMAGE_SECTION_HEADER lastSection = &m_pSectionTable[m_pNT->FileHeader.NumberOfSections - 1];
	return roundSectionVa(lastSection->VirtualAddress + lastSection->SizeOfRawData);
}

// Create a new section
// the section won't be valid until data is added to it using AddToSection
DWORD MappedPeFile::createSection(char *szName, DWORD dwCharacteristics)
{
	IMAGE_SECTION_HEADER section;
	ZeroMemory(&section, sizeof(IMAGE_SECTION_HEADER));

	section.Characteristics = dwCharacteristics;
	section.Misc.VirtualSize = 0x0;
	strncpy((char*)section.Name, szName, 8);
	section.PointerToRawData = getOffsetToEof(); 
	section.SizeOfRawData = roundFileOffset(0x0);
	section.VirtualAddress = getNextSectionAlignedVa(); 

	memcpy(&m_pSectionTable[m_pNT->FileHeader.NumberOfSections++], &section, sizeof(IMAGE_SECTION_HEADER));

	return m_pNT->FileHeader.NumberOfSections-1;
}


DWORD MappedPeFile::addToLastSection(const BYTE* pbData, DWORD dwSize)
{
	PIMAGE_SECTION_HEADER pSection = &m_pSectionTable[m_pNT->FileHeader.NumberOfSections - 1];

	memcpy((void*)(m_fileBuf + pSection->PointerToRawData + pSection->Misc.VirtualSize), pbData, dwSize);

	DWORD va = m_pNT->OptionalHeader.ImageBase + pSection->VirtualAddress + pSection->Misc.VirtualSize;

	// Update size
	pSection->Misc.VirtualSize += dwSize;
	pSection->SizeOfRawData = roundFileOffset(pSection->Misc.VirtualSize);
	m_pNT->OptionalHeader.SizeOfImage = pSection->VirtualAddress + pSection->Misc.VirtualSize;

	return va;
}

/*
PIMAGE_SECTION_HEADER MappedPeFile::getLastSection(PE_File *pe_file) {
	return &m_pSectionTable[g_dwLastSectionId];
}
*/

// Includes image base
DWORD MappedPeFile::getCurrentVa()
{
	PIMAGE_SECTION_HEADER pSection = &m_pSectionTable[m_pNT->FileHeader.NumberOfSections-1];
	return m_pNT->OptionalHeader.ImageBase + pSection->VirtualAddress + pSection->Misc.VirtualSize;
}

/*
DWORD MappedPeFile::getCurrentFileOffset(PE_File *pe_file, DWORD dwAlignment = 0)
{
	PIMAGE_SECTION_HEADER pSection = &m_pSectionTable[m_pNT->FileHeader.NumberOfSections-1];

	return RoundUpMultiple(pSection->PointerToRawData + pSection->Misc.VirtualSize, dwAlignment);
}
*/

DWORD MappedPeFile::roundSectionVa(DWORD rva) {
	return Utils::roundUpMultiple(rva, m_pNT->OptionalHeader.SectionAlignment);
}

DWORD MappedPeFile::roundFileOffset(DWORD offset) {
	return Utils::roundUpMultiple(offset, m_pNT->OptionalHeader.FileAlignment);
}

void MappedPeFile::parseRelocations()
{
	if ((getNtHeaders()->FileHeader.Characteristics & IMAGE_FILE_RELOCS_STRIPPED) == 1) {
		return;
	}

	DWORD relocsRva = getNtHeaders()->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;
	DWORD relocsSize = getNtHeaders()->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;

	PIMAGE_BASE_RELOCATION pBaseReloc = (PIMAGE_BASE_RELOCATION)(va2ptr(getNtHeaders()->OptionalHeader.ImageBase + relocsRva));
	PIMAGE_BASE_RELOCATION reloc = pBaseReloc;

	unsigned int numBytes = 0;
	unsigned int count = 0;

	do {
		if (numBytes >= relocsSize) {
			break;
		}

		WORD *pRelocData = (WORD*)((DWORD)reloc + sizeof(IMAGE_BASE_RELOCATION));
		for (DWORD i = 0; i < (reloc->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD); i++)
		{

			int type = pRelocData[i] >> 12; // top 4
			int offset = pRelocData[i] & 0xFFF; // bottom 12

			if (type == IMAGE_REL_BASED_HIGHLOW) {
				DWORD dwRVA = reloc->VirtualAddress + offset;
				DWORD dwVA = (DWORD)getNtHeaders()->OptionalHeader.ImageBase + dwRVA;

				m_relocations.push_back(dwVA);
				count++;
			}
		}
		numBytes += reloc->SizeOfBlock;
		reloc = (PIMAGE_BASE_RELOCATION)((DWORD)reloc + (DWORD)reloc->SizeOfBlock);
	} while (reloc->VirtualAddress != 0);

	return;
}

PIMAGE_SECTION_HEADER MappedPeFile::getSectionFromName(const char *name) {
	for (int i = 0; i < m_pNT->FileHeader.NumberOfSections; i++)
	{
		if (!strcmp((const char*)m_pSectionTable[i].Name, name)) {
			return &m_pSectionTable[i];
		}
	}

	return NULL;
}

// VA as given by the image base, not wherever the file is mapped
PIMAGE_SECTION_HEADER MappedPeFile::getSectionFromVa(DWORD va) {
	for (int i = 0; i < m_pNT->FileHeader.NumberOfSections; i++)
	{
		if (m_pNT->OptionalHeader.ImageBase + m_pSectionTable[i].VirtualAddress <= va && va < m_pNT->OptionalHeader.ImageBase + m_pSectionTable[i].VirtualAddress + m_pSectionTable[i].Misc.VirtualSize)
			return &m_pSectionTable[i];
	}

	return NULL;
}

DWORD MappedPeFile::getIatVa(const char *module, DWORD ordinal)
{
	return getIatVa(module, (const char*)ordinal);
}

DWORD MappedPeFile::getIatVa(const char *module, const char *name)
{
	for (PIMAGE_IMPORT_DESCRIPTOR imp = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)m_pDOS + rva2FileOffset(m_pNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress)); 
		imp->Characteristics != 0; 
		imp++) {

		const char *szModule = (const char*)((DWORD)m_pDOS + rva2FileOffset(imp->Name));
		if (stricmp(module, szModule) != 0) {
			continue;
		}

		for (PIMAGE_THUNK_DATA originalThunk = (PIMAGE_THUNK_DATA)((DWORD)m_pDOS + rva2FileOffset(imp->OriginalFirstThunk)),
			firstThunk = (PIMAGE_THUNK_DATA)((DWORD)m_pDOS + rva2FileOffset(imp->FirstThunk));
			originalThunk->u1.Function != 0;
			originalThunk++, firstThunk++) {
				if (originalThunk->u1.Function & IMAGE_ORDINAL_FLAG32) {
					if ((DWORD)name == IMAGE_ORDINAL32(originalThunk->u1.Function)) {
						return ptr2va(&firstThunk->u1.Function);
					}
				} else {
					const char *importName = (const char*)((PIMAGE_IMPORT_BY_NAME)((DWORD)m_pDOS + rva2FileOffset(originalThunk->u1.AddressOfData)))->Name;
					if (!stricmp(name, importName)) {
						return ptr2va(&firstThunk->u1.Function);
					}
				}
			}
	}

	return 0;
}

DWORD MappedPeFile::patchVa(DWORD va, DWORD value) {
	DWORD *ptr = (DWORD*)(getFileBuffer()+va2FileOffset(va));
	DWORD oldValue = *ptr;
	*ptr = value;

	logger.write(LOG_MSG, "Patching [%08x] = %08x => %08x (ptr: %x)\n", va, oldValue, value, ptr);

	return oldValue;
}

bool MappedPeFile::hasRelocations()
{
	return m_relocations.size() != 0;
}

bool MappedPeFile::isRelocatableVa(DWORD va)
{
	for (unsigned int i = 0; i < m_relocations.size(); i++) {
		if (m_relocations[i] == va) {
			return true;
		}
	}
	return false;
}

```

`chvrn_vm/MappedPeFile.h`:

```h
#pragma once
#include "stdafx.h"
#include "MappedFile.h"

class MappedPeFile : public MappedFile {
public:
	MappedPeFile(const char *filename);
	bool map(DWORD extensionSize=0);

	PIMAGE_DOS_HEADER getDosHeader();
	PIMAGE_NT_HEADERS getNtHeaders();

	// Section handling:
	PIMAGE_SECTION_HEADER getSectionTable();

	DWORD rva2FileOffset(DWORD rva) const;
	DWORD va2FileOffset(DWORD va) const;
	void *va2ptr(DWORD va) const;
	
	DWORD fileOffset2Rva(DWORD offset) const;
	DWORD fileOffset2Va(DWORD offset) const;
	
	DWORD ptr2offset(void *ptr);
	DWORD ptr2va(void *ptr);

	DWORD getOffsetToEof();
	DWORD getNextSectionAlignedVa();
	DWORD createSection(char *szName, DWORD dwCharacteristics);
	DWORD addToLastSection(const BYTE* pbData, DWORD dwSize);

	DWORD getCurrentVa();
	PIMAGE_SECTION_HEADER getSectionFromName(const char *name);
	PIMAGE_SECTION_HEADER getSectionFromVa(DWORD va);

	DWORD getIatVa(const char *module, DWORD ordinal);
	DWORD getIatVa(const char *module, const char *name);

	DWORD patchVa(DWORD va, DWORD value);

	bool hasRelocations();
	bool isRelocatableVa(DWORD va);
protected:
	DWORD roundSectionVa(DWORD rva);
	DWORD roundFileOffset(DWORD offset);

	void parseRelocations();

	PIMAGE_DOS_HEADER m_pDOS;
	PIMAGE_NT_HEADERS m_pNT;
	PIMAGE_SECTION_HEADER m_pSectionTable;
	PIMAGE_DATA_DIRECTORY m_pImportDataDirectory;
	std::vector<DWORD> m_relocations;
};
```

`chvrn_vm/SettingsManager.cpp`:

```cpp
#include "stdafx.h"
#include "SettingsManager.h"

// Input is of the form "variable=value"
bool SettingsManager::setVariableValuePair(const char *szStr) {
		const char* szValue = strchr(szStr, '=');
		if (!szValue) {
			printf("Missing value for command %s\n", szStr);
			return false;
		}
		
		char *szVariable = strncpy(new char[szValue - szStr + 1], szStr, szValue - szStr);
		szVariable[szValue - szStr] = '\0';
		szValue++;	
		
		if (!setVariable(szVariable, szValue)) {
			printf("Unknown variable \"%s\" - ignoring\n", szVariable); 
		}
		
		delete[] szVariable;
		return true;
}

bool SettingsManager::parseFile(const char *szFile) {
	bool success = true;
	return success;
}

bool SettingsManager::parseMainArgs(int argc, const char **argv) {
	bool success = true;
	for (int i = 1; i < argc; i++) {
		if (!setVariableValuePair(argv[i]))
			success = false;
	}
	return success;
}

SettingsManager::~SettingsManager() {
	for (unsigned int i = 0; i < m_vVariables.size(); i++)
		delete m_vVariables[i];
}

const SettingsVariable* SettingsManager::getVariable(const char *szName) {
	for (unsigned int i = 0; i < m_vVariables.size(); i++) {
		if (strcmp(m_vVariables[i]->szName, szName) == 0) {
				return m_vVariables[i];
			}
	}
	return NULL;
}

const char* SettingsManager::getVariableAsString(const char *szName) {
	const SettingsVariable *var = getVariable(szName);
	return var != NULL ? var->szValue : NULL;
}

int SettingsManager::getVariableAsInteger(const char *szName) {
	const SettingsVariable *var = getVariable(szName);
	return var != NULL ? var->iValue : 0;
}

bool SettingsManager::setVariable(const char *szName, const char *szValue) {
	std::cout << "Setting variable " << szName << " to " << szValue << std::endl;
	
	if (SettingsVariable *variable = (SettingsVariable*)getVariable(szName)) {
		
		if (variable->kType == VAR_STRING) {
			delete[] variable->szValue;
			variable->szValue = strcpy(new char[strlen(szValue) + 1], szValue);
		}
		if (variable->kType == VAR_INTEGER) {
			std::stringstream ss;
			ss << std::hex << szValue;
			ss >> variable->iValue;
		}
		return true;
	}
	return false;
}

SettingsVariable* SettingsManager::addVariable(SettingsVariable *variable) {
	m_vVariables.push_back(variable);
	return variable;
}

SettingsVariable* SettingsManager::addVariable(const char *szName, const char *szDescription, const char *szValue) {
	
	SettingsVariable *variable = new SettingsVariable;
	variable->szName = szName;
	variable->szDescription = szDescription;
	variable->kType = VAR_STRING;
	variable->szValue = strcpy(new char[strlen(szValue) + 1], szValue);
	
	return addVariable(variable);
}

SettingsVariable* SettingsManager::addVariable(const char *szName, const char *szDescription, int iValue) {
	
	SettingsVariable *variable = new SettingsVariable;
	variable->szName = szName;
	variable->szDescription = szDescription;
	variable->kType = VAR_INTEGER;
	variable->szValue = itoa(iValue, new char[11], 10);
	variable->iValue = iValue;
	
	return addVariable(variable);
}

void SettingsManager::printHelp() {
	if (m_vVariables.size() == 0) {
		printf("No settings available\n");
		return;
	}

	std::cout << "Available settings and their values: " << std::endl;
	
	for (unsigned int i = 0; i < m_vVariables.size(); i++)
	{
		std::cout << m_vVariables[i]->szName << "=";
		
		if (m_vVariables[i]->kType == VAR_STRING) {
			std::cout << "[String]";
		} else {
			std::cout << "[Integer]" ;
		}
		
		std::cout << " (" << m_vVariables[i]->szValue << ")" << " - " << m_vVariables[i]->szDescription << std::endl;
	}
}
```

`chvrn_vm/SettingsManager.h`:

```h
#include "stdafx.h"

enum VariableType {
	VAR_STRING,
	VAR_INTEGER
};

struct SettingsVariable {
	~SettingsVariable() { delete[] szValue; }
	const char *szName;
	const char *szDescription;
	VariableType kType;
	const char *szValue;
	int iValue;
};

class SettingsManager {
public:
	~SettingsManager();
	bool parseMainArgs(int argc, const char **argv);
	bool parseFile(const char *szFile);
	SettingsVariable* addVariable(const char *szName, const char *szDescription, const char *szValue);
	SettingsVariable* addVariable(const char *szName, const char *szDescription, int iValue);
	const SettingsVariable* getVariable(const char *szName);
	const char *getVariableAsString(const char *szName);
	int getVariableAsInteger(const char *szName);
	bool setVariable(const char *szName, const char *szValue);
	void printHelp();
private:
	SettingsVariable* addVariable(SettingsVariable *variable);
	bool setVariableValuePair(const char *szStr);
	std::vector<SettingsVariable*> m_vVariables;
};
```

`chvrn_vm/StackMutator.cpp`:

```cpp
#include "stdafx.h"
#include "StackMutator.h"

// omitted
```

`chvrn_vm/StackMutator.h`:

```h
#pragma once
#include "stdafx.h"
#include "MappedPeFile.h"
#include "Vm.h"

void mutate(MappedPeFile *target, VmFile *vm);
```

`chvrn_vm/Utils.cpp`:

```cpp
#include "stdafx.h"
#include "Utils.h"

DWORD Utils::hexStr(const BYTE *bytes, DWORD len, char *buf, DWORD bufLen, DWORD padLen, char padChar) {
	static const char *digits = "0123456789abcdef";
	unsigned int i = 0;
	unsigned int j = 0;
	while (i < len && j + 3 < bufLen) {
		BYTE hi = (bytes[i] >> 4) & 0x0f;
		BYTE lo = bytes[i] & 0x0f;
		buf[j] = digits[hi];
		buf[j+1] = digits[lo];
		i++;
		j+=2;
	}
	buf[j] = '\0';

	if (j < padLen) {
		return Utils::padStr(buf, j, padLen, padChar);
	}

	return j;
}

DWORD Utils::padStr(char *str, DWORD strLen, DWORD padLen, char padChar) {
	for (unsigned int i = strLen; i < padLen; i++) {
		if (i == padLen - 1) {
			str[i] = '\0';
		} else {
			str[i] = padChar;
		}
	}

	return padLen;
}

DWORD Utils::roundUpMultiple(DWORD value, DWORD multiple) {
	return ((value + multiple - 1) / multiple) * multiple;
}
```

`chvrn_vm/Utils.h`:

```h
#pragma once
#include "stdafx.h"

namespace Utils {
	DWORD hexStr(const BYTE *bytes, DWORD len, char *buf, DWORD bufLen, DWORD padLen=0, char padChar=' ') ;
	DWORD padStr(char *buf, DWORD strLen, DWORD padLen, char padChar=' ');
	DWORD roundUpMultiple(DWORD value, DWORD mult);
};
```

`chvrn_vm/VirtualizerList.cpp`:

```cpp
#include "stdafx.h"
#include "VirtualizerList.h"

VirtualizerList::VirtualizerList() {
	m_virtualizers = new pfnVirtualize[0xff*2];
	ZeroMemory(m_virtualizers, 0xff*2*sizeof(pfnVirtualize));
	m_count = 0;
}

VirtualizerList::~VirtualizerList() {
	delete[] m_virtualizers;
}

bool VirtualizerList::addVirtualizer(pfnVirtualize virtualizer, DWORD opcode) {

	BYTE hiByte = (opcode & 0xff00) >> 8;
	BYTE loByte = opcode & 0xff;

	pfnVirtualize *location;
	if (hiByte == 0x0f) {
		location = &m_virtualizers[0xff+loByte];
	} else {
		location = &m_virtualizers[loByte];
	}
	bool duplicate = false;
	if (*location != 0) {
		duplicate = true;
		logger.write(LOG_WARN, "A virtualizer for opcode %x is already registered\n", opcode);
	}
	*location = virtualizer;
	return duplicate;
}

bool VirtualizerList::addVirtualizer(pfnVirtualize virtualizer, DWORD *opcodes, DWORD count) {
	bool duplicate = false;
	for (unsigned int i = 0; i < count; i++) {
		if (addVirtualizer(virtualizer, opcodes[i])) {
			duplicate = true;
		}
	}
	return duplicate;
}

bool VirtualizerList::virtualize(CodeChunk *code, DISASM *disasm) const {
	DWORD opcode = disasm->Instruction.Opcode;

	BYTE hiByte = (opcode & 0xff00) >> 8;
	BYTE loByte = opcode & 0xff;

	pfnVirtualize virtualizer;
	if (hiByte == 0x0f) {
		virtualizer = m_virtualizers[0xff+loByte];
	} else {
		virtualizer = m_virtualizers[loByte];
	}

	if (!virtualizer) {
		return false;
	} else {
		return virtualizer(code, disasm);
	}
}

void VirtualizerList::print() const {
	logger.write(LOG_MSG, "Supported opcodes:\n");
	for (unsigned int i = 0; i < 0xff*2; i++) {
		if (!m_virtualizers[i]) {
			continue;
		}

		if (i < 0xff) {
			logger.write(LOG_MSG, "%02x ", i);
		} else {
			logger.write(LOG_MSG, "0f%02x ", i);
		}
	}
	logger.write(LOG_MSG, "\n");
}
```

`chvrn_vm/VirtualizerList.h`:

```h
#include "stdafx.h"
#include "CodeChunk.h"

typedef bool (*pfnVirtualize)(CodeChunk *code, DISASM *disasm);

class VirtualizerList {
public:
	VirtualizerList();
	~VirtualizerList();
	bool addVirtualizer(pfnVirtualize virtualizer, DWORD opcode);
	bool addVirtualizer(pfnVirtualize virtualizer, DWORD *opcodes, DWORD count);
	bool virtualize(CodeChunk *code, DISASM *disasm) const;

	void print() const;
private:
	DWORD m_count;
	pfnVirtualize *m_virtualizers;
};
```

`chvrn_vm/Vm.cpp`:

```cpp
#include "stdafx.h"
#include "Vm.h"
#include "patterns.h"

#ifndef STRIPPED_BUILD
const char *g_InstructionNames[] = {
	"VmNativeDispatch",
	"VmExit",
	"VmPush",
	"VmRepush",
	"VmPushReg",
	"PushDword",
	"VmPopReg",
	"PushFlag",
	"Move",
	"Nand",
	"JumpRel",
	"JumpAbs",
	"JumpRelCond",
	"PopMem",
	"Deref",
	"Add",
	"Sub",
	"Mul",
	"Xor",
	"CallRel",
	"Nop",
	"VmRebase",
	"VmReturn",
	"VmPopRemove",
	"VmAdd",
	"VmSub",
	"PushReg",
	"PopReg",
};
#else
const char *g_InstructionNames[] = { // lel
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
};
#endif


VmFile::VmFile(MappedPeFile *container)
	: m_container(container), m_header(nullptr), m_opcodes(nullptr), m_indices(nullptr) {

}

VmFile::~VmFile() {
	if (m_opcodes) {
		delete[] m_opcodes;
	}
	if (m_indices) {
		delete[] m_indices;
	}
}

bool VmFile::findVm(BYTE *data, DWORD size) {
	static DWORD pattern[] = { VM_SIGNATURE_1, VM_SIGNATURE_2, VM_SIGNATURE_3 };
	DWORD vmOffset = findBytePattern(data, size, (BYTE*)pattern, sizeof(pattern));
	if (vmOffset == -1) {
		logger.write(LOG_ERROR, "VM not found inside target\n");
		return false;
	}

	m_header = (VmHeader*)(data + vmOffset);

	return true;
}

bool VmFile::load() {
	PIMAGE_SECTION_HEADER pData = m_container->getSectionFromName(".data");

	BYTE *data = m_container->getFileBuffer() + pData->PointerToRawData;
	DWORD dataSize = pData->SizeOfRawData;
	
	if (!findVm(data, dataSize)) {
		return false;
	}

	// not really necessary unless the implementation of findVm is wrong
	if ((m_header->signature1 != VM_SIGNATURE_1)
		|| (m_header->signature2 != VM_SIGNATURE_2)
		|| (m_header->signature3 != VM_SIGNATURE_3)) {
		logger.write(LOG_ERROR, "VM signature mismatch\n");
		return false;
	}

	m_opcodes = new DWORD[m_header->vmHandlerCount];
	m_indices = new unsigned int[m_header->vmHandlerCount];
	for (unsigned int i = 0; i < m_header->vmHandlerCount; i++) {
		m_opcodes[i] = i;
		m_indices[i] = i;
	}

	return true;
}

VmFile::VmHeader *VmFile::getVmHeader() {
	return m_header;
}

DWORD VmFile::getVirtualAddress() const
{
	return m_container->ptr2va(m_header);
}

BYTE *VmFile::getHandlers() {
	return (BYTE*)m_container->va2ptr(m_header->vmHandlersVa);
}

DWORD VmFile::getHandlerCount() {
	return m_header->vmHandlerCount;
}

BYTE *VmFile::getVmCodeBytes() {
	return  (BYTE*)m_container->va2ptr(m_header->vmBaseVa);
}

DWORD VmFile::getVmSize() const {
	return m_header->vmCodeSize;
}

typedef int (__cdecl *pfnName)(int);

void VmFile::rebase(DWORD newBase) {
	return; // not needed for lib version, for non-lib only relocations are imports
}

void VmFile::randomizeOpcodes() {
	DWORD *handlers = (DWORD*)(m_container->getFileBuffer() + m_container->va2FileOffset(m_header->vmHandlersVa));

	srand(time(NULL));
	for (unsigned int i = m_header->vmHandlerCount - 1; i > 0; i--) {
		unsigned int j = rand() % (i + 1);

		DWORD temp = m_opcodes[i];
		m_opcodes[i] = m_opcodes[j];
		m_opcodes[j] = temp;

		temp = handlers[i];
		handlers[i] = handlers[j];
		handlers[j] = temp;
	}
}

void VmFile::generateOpcodes(CodeChunk *code) {
	DWORD *handlers = (DWORD*)(m_container->getFileBuffer() + m_container->va2FileOffset(m_header->vmHandlersVa));

	logger.write(LOG_MSG, "Generating opcodes and handler table...\n");

	// Update opcodes for the code chunk
	for (unsigned int i = 0; i < code->getCount(); i++) {
		
		BYTE oldOpcode = (*code)[i]->getOpcode();
		BYTE newOpcode;
		for (unsigned int j = 0; j < m_header->vmHandlerCount; j++) {
			if (m_opcodes[j] == oldOpcode) {
				newOpcode = j;
			}
		}
		(*code)[i]->setOpcode(newOpcode);
	}
}

DWORD VmFile::getOpcode(DWORD instructionId) {
	return m_opcodes[instructionId];
}

void VmFile::patchBeginProtect() {
	(getVmCodeBytes() + m_header->vmBeginProtectOffset)[0] = 0x90;
	(getVmCodeBytes() + m_header->vmBeginProtectOffset)[1] = 0x90;
	(getVmCodeBytes() + m_header->vmBeginProtectOffset)[2] = 0x90;
}
```

`chvrn_vm/Vm.h`:

```h
#pragma once
#include "stdafx.h"
#include "MappedPeFile.h"
#include "CodeChunk.h"

#define VM_SIGNATURE_1 0xb0fa3d74 
#define VM_SIGNATURE_2 0xa53bcf98 
#define VM_SIGNATURE_3 0xee02930e 

extern const char *g_InstructionNames[];

class VmFile {
public:
	// NOTE: must be synchronized with the VM header in the VM file
#pragma pack(1)
	struct VmHeader {
		DWORD signature1;
		DWORD signature2;
		DWORD signature3;
		DWORD majorVersion;
		DWORD minorVersion;
		//
		DWORD moduleBase;
		DWORD addressLookupTable;
		DWORD addressValueTable;
		//
		DWORD vmBaseVa;
		DWORD vmCodeSize;
		DWORD vmInitOffset;
		DWORD vmFetchDecodeOffset;
		DWORD vmReenterOffset;
		DWORD vmExitOffset;
		DWORD vmVirtualAllocPatchOffset1;
		DWORD vmVirtualAllocPatchOffset2;
		DWORD vmVirtualFreePatchOffset1;
		DWORD vmVirtualFreePatchOffset2;
		DWORD vmHandlerPatchOffset;
		DWORD vmReenterPatchOffset;
		DWORD vmExitPatchOffset;
		DWORD vmExitNativeOffset;
		DWORD vmVaTablePatchOffset;
		DWORD vmVaTableValuesPatchOffset;
		DWORD vmHandlersVa;
		DWORD vmHandlerCount;
		DWORD vmBeginProtectOffset;
		DWORD vmEndProtectOffset;
		//
	};
#pragma pack()
	// must be synchronized with the handler table in the VM file
	enum OriginalOpcodes {
		VmNativeDispatch = 0,
		VmExit,
		VmPush,
		VmRepush,
		VmPushReg,
		PushDword,
		VmPopReg,
		PushFlag,
		Move,
		Nand,
		JumpRel,
		JumpAbs,
		JumpRelCond,
		PopMem,
		Deref,
		Add,
		Sub,
		Mul,
		VmXor,
		CallRel,
		Nop,
		VmRebase,
		VmReturn,
		VmPopRemove,
		VmAdd,
		VmSub,
		PushReg,
		PopReg,
	};

	bool load();
	VmFile(MappedPeFile *container);
	~VmFile();

	VmHeader *getVmHeader();

	DWORD getVirtualAddress() const;

	BYTE *getHandlers();
	DWORD getHandlerCount();
	BYTE *getVmCodeBytes();
	DWORD getVmSize() const;

	void rebase(DWORD newBase);
	
	void randomizeOpcodes();
	void generateOpcodes(CodeChunk *code);
	DWORD getOpcode(DWORD instructionId);

	void patchBeginProtect();
private:
	bool findVm(BYTE *data, DWORD size);
	VmHeader *m_header;
	DWORD m_virtualAddress;
	MappedPeFile *m_container;
	std::vector<DWORD> m_nativeHandlerVas;
	DWORD *m_opcodes;
	unsigned int *m_indices;
};
```

`chvrn_vm/VmInstruction.cpp`:

```cpp
#include "stdafx.h"
#include "VmInstruction.h"
#include "Utils.h"

VmInstruction::VmInstruction(BYTE opcode, const char *mnemonic) {
	m_bytes[0] = opcode;
	m_length = 1;
	strcpy(m_mnemonic, mnemonic);
	m_virtualAddress = 0;
}

VmInstruction::VmInstruction(BYTE opcode, const char *mnemonic, BYTE operand) {
	m_bytes[0] = opcode;
	strcpy(m_mnemonic, mnemonic);
	setOperand8(operand);
	m_virtualAddress = 0;
}

VmInstruction::VmInstruction(BYTE opcode, const char *mnemonic, DWORD operand) {
	m_bytes[0] = opcode;
	strcpy(m_mnemonic, mnemonic);
	setOperand32(operand);
	m_virtualAddress = 0;
}

// Variable length, only used for native dispatch
VmInstruction::VmInstruction(BYTE opcode, const char *mnemonic, BYTE *operand, DWORD length) {
	m_bytes[0] = opcode;
	strcpy(m_mnemonic, mnemonic);
	memcpy(&m_bytes[1], operand, length);
	m_length = sizeof(BYTE)+length;
	m_virtualAddress = 0;
}

BYTE VmInstruction::getOpcode() const {
	return m_bytes[0];
}

void VmInstruction::setOpcode(BYTE opcode) {
	m_bytes[0] = opcode;
}

BYTE VmInstruction::getOperand8() const {
	return m_bytes[1];
}

DWORD VmInstruction::getOperand32() const {
	return (m_length < 4) ? (DWORD)getOperand8() : *(DWORD*)&m_bytes[1];
}

const char *VmInstruction::toString() const {
	// byte str
	Utils::padStr(m_byteStr, Utils::hexStr(m_bytes, m_length, m_byteStr, sizeof(m_byteStr)), 32);

	// assembly string
	sprintf(m_assemblyStr, "%s", m_mnemonic);
	if (m_length == 2) {
		sprintf(m_assemblyStr, "%s %02x", m_mnemonic, m_bytes[1]);
	} else if (m_length == 5) {
		sprintf(m_assemblyStr, "%s %08x", m_mnemonic, *(DWORD*)&m_bytes[1]);
	}

	sprintf(m_fullInstr, "%s | %s", m_byteStr, m_assemblyStr);

	return m_fullInstr;
}

BYTE *VmInstruction::getBytes() const {
	return (BYTE*)&m_bytes;
}

DWORD VmInstruction::getLength() const {
	return m_length;
}

void VmInstruction::setOperand8(BYTE operand) {
	m_bytes[1] = operand;
	m_length = sizeof(BYTE) + sizeof(operand);
}

void VmInstruction::setOperand32(DWORD operand) {
	*(DWORD*)&m_bytes[1] = operand;
	m_length = sizeof(BYTE) + sizeof(operand);
}

void VmInstruction::setVirtualAddress(DWORD virtualAddress) {
	m_virtualAddress = virtualAddress;
}

DWORD VmInstruction::getVirtualAddress() const {
	return m_virtualAddress;
}

bool VmInstruction::isRelocatable() const {
	return m_isRelocatable;
}

void VmInstruction::setRelocationOffset(DWORD offset) {
	m_relocationOffset = offset;
	m_isRelocatable = true;
}
```

`chvrn_vm/VmInstruction.h`:

```h
#pragma once
#include "stdafx.h"

class VmInstruction {
public:
	VmInstruction(BYTE opcode, const char *mnemonic);
	VmInstruction(BYTE opcode, const char *mnemonic, BYTE operand);
	VmInstruction(BYTE opcode, const char *mnemonic, DWORD operand);
	VmInstruction(BYTE opcode, const char *mnemonic, BYTE* operand, DWORD length);

	BYTE getOpcode() const;
	void setOpcode(BYTE opcode);

	BYTE getOperand8() const;
	DWORD getOperand32() const;

	void setOperand8(BYTE operand);
	void setOperand32(DWORD operand);

	void setVirtualAddress(DWORD virtualAddress);
	DWORD getVirtualAddress() const;

	const char *toString() const;
	BYTE *getBytes() const;
	DWORD getLength() const;

	bool isRelocatable() const;
	void setRelocationOffset(DWORD offset);
protected:
	char m_mnemonic[16];
	mutable char m_byteStr[32];
	mutable char m_assemblyStr[32];
	mutable char m_fullInstr[64];
	DWORD m_length;
	BYTE m_bytes[16];
	DWORD m_virtualAddress;

	bool m_isRelocatable;
	DWORD m_relocationOffset;
};
```

`chvrn_vm/beaengine/BeaEngine.h`:

```h
#ifndef _BEA_ENGINE_
#define _BEA_ENGINE_
#if  defined(__cplusplus) && defined(__BORLANDC__)
namespace BeaEngine {
#endif

#include "beaengine/macros.h"
#include "beaengine/export.h"
#include "beaengine/basic_types.h"

#if !defined(BEA_ENGINE_STATIC)
	#if defined(BUILD_BEA_ENGINE_DLL)
		#define BEA_API bea__api_export__
	#else
		#define BEA_API bea__api_import__
	#endif
#else
	#define BEA_API
#endif


#define INSTRUCT_LENGTH 64

#pragma pack(1)
typedef struct {
   UInt8 W_;
   UInt8 R_;
   UInt8 X_;
   UInt8 B_;
   UInt8 state;
} REX_Struct  ;
#pragma pack()

#pragma pack(1)
typedef struct {
   int Number;
   int NbUndefined;
   UInt8 LockPrefix;
   UInt8 OperandSize;
   UInt8 AddressSize;
   UInt8 RepnePrefix;
   UInt8 RepPrefix;
   UInt8 FSPrefix;
   UInt8 SSPrefix;
   UInt8 GSPrefix;
   UInt8 ESPrefix;
   UInt8 CSPrefix;
   UInt8 DSPrefix;
   UInt8 BranchTaken;
   UInt8 BranchNotTaken;
   REX_Struct REX;
   char alignment[2];
} PREFIXINFO  ;
#pragma pack()

#pragma pack(1)
typedef struct {
   UInt8 OF_;
   UInt8 SF_;
   UInt8 ZF_;
   UInt8 AF_;
   UInt8 PF_;
   UInt8 CF_;
   UInt8 TF_;
   UInt8 IF_;
   UInt8 DF_;
   UInt8 NT_;
   UInt8 RF_;
   UInt8 alignment;
} EFLStruct  ;
#pragma pack()

#pragma pack(4)
typedef struct {
   Int32 BaseRegister;
   Int32 IndexRegister;
   Int32 Scale;
   Int64 Displacement;
} MEMORYTYPE ;
#pragma pack()


#pragma pack(1)
typedef struct  {
   Int32 Category;
   Int32 Opcode;
   char Mnemonic[16];
   Int32 BranchType;
   EFLStruct Flags;
   UInt64 AddrValue;
   Int64 Immediat;
   UInt32 ImplicitModifiedRegs;
} INSTRTYPE;
#pragma pack()

#pragma pack(1)
typedef struct  {
   char ArgMnemonic[64];
   Int32 ArgType;
   Int32 ArgSize;
   Int32 ArgPosition;
   UInt32 AccessMode;
   MEMORYTYPE Memory;
   UInt32 SegmentReg;
} ARGTYPE;
#pragma pack()

/* reserved structure used for thread-safety */
/* unusable by customer */
#pragma pack(1)
typedef struct {
   UIntPtr EIP_;
   UInt64 EIP_VA;
   UIntPtr EIP_REAL;
   Int32 OriginalOperandSize;
   Int32 OperandSize;
   Int32 MemDecoration;
   Int32 AddressSize;
   Int32 MOD_;
   Int32 RM_;
   Int32 INDEX_;
   Int32 SCALE_;
   Int32 BASE_;
   Int32 MMX_;
   Int32 SSE_;
   Int32 CR_;
   Int32 DR_;
   Int32 SEG_;
   Int32 REGOPCODE;
   UInt32 DECALAGE_EIP;
   Int32 FORMATNUMBER;
   Int32 SYNTAX_;
   UInt64 EndOfBlock;
   Int32 RelativeAddress;
   UInt32 Architecture;
   Int32 ImmediatSize;
   Int32 NB_PREFIX;
   Int32 PrefRepe;
   Int32 PrefRepne;
   UInt32 SEGMENTREGS;
   UInt32 SEGMENTFS;
   Int32 third_arg;
   Int32 TAB_;
   Int32 ERROR_OPCODE;
   REX_Struct REX;
   Int32 OutOfBlock;
} InternalDatas;
#pragma pack()

/* ************** main structure ************ */
#pragma pack(1)
typedef struct _Disasm {
   UIntPtr EIP;
   UInt64 VirtualAddr;
   UInt32 SecurityBlock;
   char CompleteInstr[INSTRUCT_LENGTH];
   UInt32 Archi;
   UInt64 Options;
   INSTRTYPE Instruction;
   ARGTYPE Argument1;
   ARGTYPE Argument2;
   ARGTYPE Argument3;
   PREFIXINFO Prefix;
   InternalDatas Reserved_;
} DISASM, *PDISASM, *LPDISASM;
#pragma pack()

#define ESReg 1
#define DSReg 2
#define FSReg 3
#define GSReg 4
#define CSReg 5
#define SSReg 6

#define InvalidPrefix 4
#define SuperfluousPrefix 2
#define NotUsedPrefix 0
#define MandatoryPrefix 8
#define InUsePrefix 1

#define LowPosition 0
#define HighPosition 1

enum INSTRUCTION_TYPE
{
  GENERAL_PURPOSE_INSTRUCTION   =    0x10000,
  FPU_INSTRUCTION               =    0x20000,
  MMX_INSTRUCTION               =    0x40000,
  SSE_INSTRUCTION               =    0x80000,
  SSE2_INSTRUCTION              =   0x100000,
  SSE3_INSTRUCTION              =   0x200000,
  SSSE3_INSTRUCTION             =   0x400000,
  SSE41_INSTRUCTION             =   0x800000,
  SSE42_INSTRUCTION             =  0x1000000,
  SYSTEM_INSTRUCTION            =  0x2000000,
  VM_INSTRUCTION                =  0x4000000,
  UNDOCUMENTED_INSTRUCTION      =  0x8000000,
  AMD_INSTRUCTION               = 0x10000000,
  ILLEGAL_INSTRUCTION           = 0x20000000,
  AES_INSTRUCTION               = 0x40000000,
  CLMUL_INSTRUCTION             = (int)0x80000000,


    DATA_TRANSFER = 0x1,
    ARITHMETIC_INSTRUCTION,
    LOGICAL_INSTRUCTION,
    SHIFT_ROTATE,
    BIT_UInt8,
    CONTROL_TRANSFER,
    STRING_INSTRUCTION,
    InOutINSTRUCTION,
    ENTER_LEAVE_INSTRUCTION,
    FLAG_CONTROL_INSTRUCTION,
    SEGMENT_REGISTER,
    MISCELLANEOUS_INSTRUCTION,
    COMPARISON_INSTRUCTION,
    LOGARITHMIC_INSTRUCTION,
    TRIGONOMETRIC_INSTRUCTION,
    UNSUPPORTED_INSTRUCTION,
    LOAD_CONSTANTS,
    FPUCONTROL,
    STATE_MANAGEMENT,
    CONVERSION_INSTRUCTION,
    SHUFFLE_UNPACK,
    PACKED_SINGLE_PRECISION,
    SIMD128bits,
    SIMD64bits,
    CACHEABILITY_CONTROL,
    FP_INTEGER_CONVERSION,
    SPECIALIZED_128bits,
    SIMD_FP_PACKED,
    SIMD_FP_HORIZONTAL ,
    AGENT_SYNCHRONISATION,
    PACKED_ALIGN_RIGHT  ,
    PACKED_SIGN,
    PACKED_BLENDING_INSTRUCTION,
    PACKED_TEST,
    PACKED_MINMAX,
    HORIZONTAL_SEARCH,
    PACKED_EQUALITY,
    STREAMING_LOAD,
    INSERTION_EXTRACTION,
    DOT_PRODUCT,
    SAD_INSTRUCTION,
    ACCELERATOR_INSTRUCTION,    /* crc32, popcnt (sse4.2) */
    ROUND_INSTRUCTION

};

enum EFLAGS_STATES
{
  TE_ = 1,
  MO_ = 2,
  RE_ = 4,
  SE_ = 8,
  UN_ = 0x10,
  PR_ = 0x20
};

enum BRANCH_TYPE
{
  JO = 1,
  JC = 2,
  JE = 3,
  JA = 4,
  JS = 5,
  JP = 6,
  JL = 7,
  JG = 8,
  JB = 2,       // JC == JB
  JECXZ = 10,
  JmpType = 11,
  CallType = 12,
  RetType = 13,
  JNO = -1,
  JNC = -2,
  JNE = -3,
  JNA = -4,
  JNS = -5,
  JNP = -6,
  JNL = -7,
  JNG = -8,
  JNB = -2      // JNC == JNB
};

enum ARGUMENTS_TYPE
{
  NO_ARGUMENT = 0x10000000,
  REGISTER_TYPE = 0x20000000,
  MEMORY_TYPE = 0x40000000,
  CONSTANT_TYPE = (int)0x80000000,

  MMX_REG = 0x10000,
  GENERAL_REG = 0x20000,
  FPU_REG = 0x40000,
  SSE_REG = 0x80000,
  CR_REG = 0x100000,
  DR_REG = 0x200000,
  SPECIAL_REG = 0x400000,
  MEMORY_MANAGEMENT_REG = 0x800000,
  SEGMENT_REG = 0x1000000,

  RELATIVE_ = 0x4000000,
  ABSOLUTE_ = 0x8000000,

  READ = 0x1,
  WRITE = 0x2,

  REG0 = 0x1,
  REG1 = 0x2,
  REG2 = 0x4,
  REG3 = 0x8,
  REG4 = 0x10,
  REG5 = 0x20,
  REG6 = 0x40,
  REG7 = 0x80,
  REG8 = 0x100,
  REG9 = 0x200,
  REG10 = 0x400,
  REG11 = 0x800,
  REG12 = 0x1000,
  REG13 = 0x2000,
  REG14 = 0x4000,
  REG15 = 0x8000
};

enum SPECIAL_INFO
{
  UNKNOWN_OPCODE = -1,
  OUT_OF_BLOCK = 0,

  /* === mask = 0xff */
  NoTabulation      = 0x00000000,
  Tabulation        = 0x00000001,

  /* === mask = 0xff00 */
  MasmSyntax        = 0x00000000,
  GoAsmSyntax       = 0x00000100,
  NasmSyntax        = 0x00000200,
  ATSyntax          = 0x00000400,

  /* === mask = 0xff0000 */
  PrefixedNumeral   = 0x00010000,
  SuffixedNumeral   = 0x00000000,

  /* === mask = 0xff000000 */
  ShowSegmentRegs   = 0x01000000
};


#ifdef __cplusplus
extern "C"
#endif

BEA_API int __bea_callspec__ Disasm (LPDISASM pDisAsm);
BEA_API const__ char* __bea_callspec__ BeaEngineVersion (void);
BEA_API const__ char* __bea_callspec__ BeaEngineRevision (void);
#if  defined(__cplusplus) && defined(__BORLANDC__)
};
using namespace BeaEngine;
#endif
#endif

```

`chvrn_vm/beaengine/basic_types.h`:

```h
/**
 * @file   basic_types.h
 * @author  <igor.gutnik@gmail.com>
 * @date   Thu Dec 24 19:31:22 2009
 *
 * @brief  Definitions of fixed-size integer types for various platforms
 *
 * This file is part of BeaEngine.
 *
 *    BeaEngine is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU Lesser General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    BeaEngine is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU Lesser General Public License for more details.
 *
 *    You should have received a copy of the GNU Lesser General Public License
 *    along with BeaEngine.  If not, see <http://www.gnu.org/licenses/>. */

#ifndef __BEA_BASIC_TYPES_HPP__
#define __BEA_BASIC_TYPES_HPP__

#include <stddef.h>

#if defined(__GNUC__) || defined (__INTEL_COMPILER) || defined(__LCC__) || defined(__POCC__)
#include <stdint.h>
#endif

#if defined(_MSC_VER) && !defined(__BORLANDC__)
	/*
	* Windows/Visual C++
	*/
	typedef signed char            Int8;
	typedef unsigned char          UInt8;
	typedef signed short           Int16;
	typedef unsigned short         UInt16;
	typedef signed int             Int32;
	typedef unsigned int           UInt32;
	typedef signed __int64         Int64;
	typedef unsigned __int64       UInt64;
	#if defined(_WIN64)
		#define BEA_PTR_IS_64_BIT 1
		typedef signed __int64     IntPtr;
		typedef unsigned __int64   UIntPtr;
	#else
		typedef signed long        IntPtr;
		typedef size_t             UIntPtr;
	#endif
	#define BEA_HAVE_INT64 1
#elif defined(__POCC__)
	/*
	* PellesC
	*/
	typedef signed char            Int8;
	typedef unsigned char          UInt8;
	typedef signed short           Int16;
	typedef unsigned short         UInt16;
	typedef signed int             Int32;
	typedef unsigned int           UInt32;
	typedef signed long long       Int64;
	typedef unsigned long long     UInt64;
	#if defined(_WIN64)
		#define BEA_PTR_IS_64_BIT 1
		typedef signed long long   IntPtr;
		typedef unsigned long long UIntPtr;
	#else
		typedef signed long        IntPtr;
		typedef size_t             UIntPtr;
	#endif
	#define BEA_HAVE_INT64 1
#elif defined(__GNUC__) || defined(__LCC__)
	/*
	* Unix/GCC
	*/
	typedef signed char            Int8;
	typedef unsigned char          UInt8;
	typedef signed short           Int16;
	typedef unsigned short         UInt16;
	typedef signed int             Int32;
	typedef unsigned int           UInt32;
	typedef intptr_t               IntPtr;
	typedef uintptr_t              UIntPtr;
	#if defined(__LP64__)
		#define BEA_PTR_IS_64_BIT 1
		#define BEA_LONG_IS_64_BIT 1
		typedef signed long        Int64;
		typedef unsigned long      UInt64;
	#else
             #if defined (__INTEL_COMPILER) || defined (__ICC) || defined (_ICC)
		typedef __int64           Int64;
		typedef unsigned __int64  UInt64;
             #else
		typedef signed long long   Int64;
		typedef unsigned long long UInt64;
             #endif
	#endif
	#define BEA_HAVE_INT64 1
#elif defined(__DECCXX)
	/*
	* Compaq C++
	*/
	typedef signed char            Int8;
	typedef unsigned char          UInt8;
	typedef signed short           Int16;
	typedef unsigned short         UInt16;
	typedef signed int             Int32;
	typedef unsigned int           UInt32;
	typedef signed __int64         Int64;
	typedef unsigned __int64       UInt64;
	#if defined(__VMS)
		#if defined(__32BITS)
			typedef signed long    IntPtr;
			typedef unsigned long  UIntPtr;
		#else
			typedef Int64          IntPtr;
			typedef UInt64         UIntPtr;
			#define BEA_PTR_IS_64_BIT 1
		#endif
	#else
		typedef signed long        IntPtr;
		typedef unsigned long      UIntPtr;
		#define BEA_PTR_IS_64_BIT 1
		#define BEA_LONG_IS_64_BIT 1
	#endif
	#define BEA_HAVE_INT64 1
#elif defined(__HP_aCC)
	/*
	* HP Ansi C++
	*/
	typedef signed char            Int8;
	typedef unsigned char          UInt8;
	typedef signed short           Int16;
	typedef unsigned short         UInt16;
	typedef signed int             Int32;
	typedef unsigned int           UInt32;
	typedef signed long            IntPtr;
	typedef unsigned long          UIntPtr;
	#if defined(__LP64__)
		#define BEA_PTR_IS_64_BIT 1
		#define BEA_LONG_IS_64_BIT 1
		typedef signed long        Int64;
		typedef unsigned long      UInt64;
	#else
		typedef signed long long   Int64;
		typedef unsigned long long UInt64;
	#endif
	#define BEA_HAVE_INT64 1
#elif defined(__SUNPRO_CC) || defined(__SUNPRO_C)
	/*
	* SUN Forte C++
	*/
	typedef signed char            Int8;
	typedef unsigned char          UInt8;
	typedef signed short           Int16;
	typedef unsigned short         UInt16;
	typedef signed int             Int32;
	typedef unsigned int           UInt32;
	typedef signed long            IntPtr;
	typedef unsigned long          UIntPtr;
	#if defined(__sparcv9)
		#define BEA_PTR_IS_64_BIT 1
		#define BEA_LONG_IS_64_BIT 1
		typedef signed long        Int64;
		typedef unsigned long      UInt64;
	#else
		typedef signed long long   Int64;
		typedef unsigned long long UInt64;
	#endif
	#define BEA_HAVE_INT64 1
#elif defined(__IBMCPP__)
	/*
	* IBM XL C++
	*/
	typedef signed char            Int8;
	typedef unsigned char          UInt8;
	typedef signed short           Int16;
	typedef unsigned short         UInt16;
	typedef signed int             Int32;
	typedef unsigned int           UInt32;
	typedef signed long            IntPtr;
	typedef unsigned long          UIntPtr;
	#if defined(__64BIT__)
		#define BEA_PTR_IS_64_BIT 1
		#define BEA_LONG_IS_64_BIT 1
		typedef signed long        Int64;
		typedef unsigned long      UInt64;
	#else
		typedef signed long long   Int64;
		typedef unsigned long long UInt64;
	#endif
	#define BEA_HAVE_INT64 1
#elif defined(__BORLANDC__)
       /*
	* Borland C/C++
	*/
	typedef signed char            Int8;
	typedef unsigned char          UInt8;
	typedef signed short           Int16;
	typedef unsigned short         UInt16;
	typedef signed int             Int32;
	typedef unsigned int           UInt32;
    typedef unsigned __int64       Int64;
    typedef signed __int64         UInt64;
	typedef signed long            IntPtr;
	typedef unsigned long          UIntPtr;
    #define BEA_HAVE_INT64 1
#elif defined(__WATCOMC__)
       /*
	* Watcom C/C++
	*/
	typedef signed char            Int8;
	typedef unsigned char          UInt8;
	typedef signed short           Int16;
	typedef unsigned short         UInt16;
	typedef signed int             Int32;
	typedef unsigned int           UInt32;
    typedef unsigned __int64       Int64;
    typedef signed __int64         UInt64;
    #define BEA_HAVE_INT64 1
	typedef size_t                 UIntPtr;
#elif defined(__sgi)
	/*
	* MIPSpro C++
	*/
	typedef signed char            Int8;
	typedef unsigned char          UInt8;
	typedef signed short           Int16;
	typedef unsigned short         UInt16;
	typedef signed int             Int32;
	typedef unsigned int           UInt32;
	typedef signed long            IntPtr;
	typedef unsigned long          UIntPtr;
	#if _MIPS_SZLONG == 64
		#define BEA_PTR_IS_64_BIT 1
		#define BEA_LONG_IS_64_BIT 1
		typedef signed long        Int64;
		typedef unsigned long      UInt64;
	#else
		typedef signed long long   Int64;
		typedef unsigned long long UInt64;
	#endif
	#define BEA_HAVE_INT64 1
#endif

#if defined(_MSC_VER) || defined(__BORLANDC__)
	#define W64LIT(x) x##ui64
#else
	#define W64LIT(x) x##ULL
#endif


#ifndef C_STATIC_ASSERT
#define C_STATIC_ASSERT(tag_name, x)            \
       typedef int cache_static_assert_ ## tag_name[(x) * 2-1]
#endif

C_STATIC_ASSERT(sizeof_Int8 , (sizeof(Int8)  == 1));
C_STATIC_ASSERT(sizeof_UInt8, (sizeof(UInt8) == 1));

C_STATIC_ASSERT(sizeof_Int16 , (sizeof(Int16)  == 2));
C_STATIC_ASSERT(sizeof_UInt16, (sizeof(UInt16) == 2));

C_STATIC_ASSERT(sizeof_Int32 , (sizeof(Int32)  == 4));
C_STATIC_ASSERT(sizeof_UInt32, (sizeof(UInt32) == 4));

C_STATIC_ASSERT(sizeof_Int64 , (sizeof(Int64)  == 8));
C_STATIC_ASSERT(sizeof_UInt64, (sizeof(UInt64) == 8));

#endif

```

`chvrn_vm/beaengine/export.h`:

```h
/**
 * @file   export.h
 * @author igor.gutnik@gmail.com
 * @date   Mon Sep 22 09:28:54 2008
 *
 * @brief  This file sets things up for C dynamic library function definitions and
 *         static inlined functions
 *
 * This file is part of BeaEngine.
 *
 *    BeaEngine is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU Lesser General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    BeaEngine is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU Lesser General Public License for more details.
 *
 *    You should have received a copy of the GNU Lesser General Public License
 *    along with BeaEngine.  If not, see <http://www.gnu.org/licenses/>. */

#ifndef __BEA_EXPORT_H__
#define __BEA_EXPORT_H__


/*  Set up for C function definitions, even when using C++ */

#ifdef __cplusplus
#define CPP_VISIBLE_BEGIN extern "C" {
#define CPP_VISIBLE_END }
#else
#define CPP_VISIBLE_BEGIN
#define CPP_VISIBLE_END
#endif

#if defined(_MSC_VER)
#pragma warning( disable: 4251 )
#endif

/* Some compilers use a special export keyword */
#ifndef bea__api_export__
# if defined(__BEOS__)
#  if defined(__GNUC__)
#   define bea__api_export__		__declspec(dllexport)
#  else
#   define bea__api_export__		__declspec(export)
#  endif
# elif defined(_WIN32) || defined(_WIN64)
#  ifdef __BORLANDC__
#    define bea__api_export__   __declspec(dllexport)
#    define bea__api_import__ 	__declspec(dllimport)
#  elif defined(__WATCOMC__)
#    define bea__api_export__	__declspec(dllexport)
#    define bea__api_import__
#  else
#   define bea__api_export__		__declspec(dllexport)
#   define bea__api_import__		__declspec(dllimport)
#  endif
# elif defined(__OS2__)
#  ifdef __WATCOMC__
#    define bea__api_export__	__declspec(dllexport)
#    define bea__api_import__
#  else
#   define bea__api_export__
#   define bea__api_import__
#  endif
# else
#  if defined(_WIN32) && defined(__GNUC__) && __GNUC__ >= 4
#   define bea__api_export__		__attribubea__ ((visibility("default")))
#   define bea__api_import__		__attribubea__ ((visibility("default")))
#  else
#   define bea__api_export__
#   define bea__api_import__
#  endif
# endif
#endif

/* Use C calling convention by default*/

#ifndef __bea_callspec__
#if defined(BEA_USE_STDCALL)
    #if defined(__WIN32__) || defined(WIN32) || defined(_WIN32) || defined(_WIN64)
        #if defined(__BORLANDC__) || defined(__WATCOMC__) || defined(_MSC_VER) || defined(__MINGW32__) || defined(__POCC__)
            #define __bea_callspec__	 __stdcall
        #else
            #define __bea_callspec__
        #endif
    #else
       #ifdef __OS2__
          #define __bea_callspec__ _System
       #else
          #define __bea_callspec__
       #endif
    #endif
#else
    #define __bea_callspec__
#endif
#endif

#ifdef __SYMBIAN32__
#	ifndef EKA2
#		undef bea__api_export__
#		undef bea__api_import__
#		define bea__api_export__
#		define bea__api_import__
#	elif !defined(__WINS__)
#		undef bea__api_export__
#		undef bea__api_import__
#		define bea__api_export__ __declspec(dllexport)
#		define bea__api_import__ __declspec(dllexport)
#	endif /* !EKA2 */
#endif /* __SYMBIAN32__ */


#if defined(__GNUC__) && (__GNUC__ > 2)
#define BEA_EXPECT_CONDITIONAL(c)    (__builtin_expect((c), 1))
#define BEA_UNEXPECT_CONDITIONAL(c)  (__builtin_expect((c), 0))
#else
#define BEA_EXPECT_CONDITIONAL(c)    (c)
#define BEA_UNEXPECT_CONDITIONAL(c)  (c)
#endif


/* Set up compiler-specific options for inlining functions */
#ifndef BEA_HAS_INLINE
#if defined(__GNUC__) || defined(__POCC__) || defined(__WATCOMC__) || defined(__SUNPRO_C)
#define BEA_HAS_INLINE
#else
/* Add any special compiler-specific cases here */
#if defined(_MSC_VER) || defined(__BORLANDC__) ||	\
  defined(__DMC__) || defined(__SC__) ||		\
  defined(__WATCOMC__) || defined(__LCC__) ||		\
  defined(__DECC) || defined(__EABI__)
#ifndef __inline__
#define __inline__	__inline
#endif
#define BEA_HAS_INLINE
#else
#if !defined(__MRC__) && !defined(_SGI_SOURCE)
#ifndef __inline__
#define __inline__ inline
#endif
#define BEA_HAS_INLINE
#endif /* Not a funky compiler */
#endif /* Visual C++ */
#endif /* GNU C */
#endif /* CACHE_HAS_INLINE */

/* If inlining isn't supported, remove "__inline__", turning static
   inlined functions into static functions (resulting in code bloat
   in all files which include the offending header files)
*/
#ifndef BEA_HAS_INLINE
#define __inline__
#endif

/* fix a bug with gcc under windows */

#if defined(__WIN32__) || defined(WIN32) || defined(_WIN32) || defined(_WIN64)
	#if defined(__MINGW32__)
		#define const__	 
	#else
		#define const__ const
	#endif
#else
		#define const__ const
#endif



#endif

```

`chvrn_vm/beaengine/macros.h`:

```h
#ifndef __BEAENGINE_MACROS_H__
#define __BEAENGINE_MACROS_H__
/* 
============================================================================
 Compiler Silencing macros

 Some compilers complain about parameters that are not used.  This macro
 should keep them quiet.
 ============================================================================
 */

# if defined (__GNUC__) && ((__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 2)))
#   define BEA_UNUSED_ARG(a) (void) (a)
#elif defined (ghs) || defined (__GNUC__) || defined (__hpux) || defined (__sgi) || defined (__DECCXX) || defined (__rational__) || defined (__USLC__) || defined (BEA__RM544) || defined (__DCC__) || defined (__PGI) || defined (__TANDEM) || defined(__BORLANDC__)
/*
 Some compilers complain about "statement with no effect" with (a).
 This eliminates the warnings, and no code is generated for the null
 conditional statement.  Note, that may only be true if -O is enabled,
 such as with GreenHills (ghs) 1.8.8.
 */
 
# define BEA_UNUSED_ARG(a) do {/* null */} while (&a == 0)
#elif defined (__DMC__)
	#if defined(__cplusplus)
		#define BEA_UNUSED_ID(identifier)
		template <class T>
		inline void BEA_UNUSED_ARG(const T& BEA_UNUSED_ID(t)) { }
	#else
		#define BEA_UNUSED_ARG(a) 
	#endif
#else /* ghs || __GNUC__ || ..... */
# define BEA_UNUSED_ARG(a) (a)
#endif /* ghs || __GNUC__ || ..... */

#if defined (_MSC_VER) || defined(__sgi) || defined (ghs) || defined (__DECCXX) || defined(__BORLANDC__) || defined (BEA_RM544) || defined (__USLC__) || defined (__DCC__) || defined (__PGI) || defined (__TANDEM) || (defined (__HP_aCC) && (__HP_aCC >= 60500))
# define BEA_NOTREACHED(a)
#else  /* __sgi || ghs || ..... */
# define BEA_NOTREACHED(a) a
#endif /* __sgi || ghs || ..... */ 

#endif /* __BEAENGINE_MACROS_H__ */

```

`chvrn_vm/build.h`:

```h
#pragma once
#include "stdafx.h"

//#define STRIPPED_BUILD
```

`chvrn_vm/cli.cpp`:

```cpp
#include "stdafx.h"
#include "ArgsParser.h"
#include "install.h"
#include "settings.h"
#include "environment.h"

ArgsParser g_Args;

MappedPeFile *g_TargetPe;

bool RunCli(int argc, char** argv) {
	g_Args.parseMainArgs(argc, argv);

	if (!g_Args.getArgCount("input_file")) {
		logger.write(LOG_ERROR, "Missing required argument input_file\n");
		return false;
	}

	if (!g_Args.getArgCount("output_file")) {
		logger.write(LOG_ERROR, "Missing required argument output_file\n");
		return false;
	}

	std::string inputFilePath = g_Args.getArgString("input_file");
	std::string outputFilePath = g_Args.getArgString("output_file");

	LoadDefaultSettings();
	if (g_Args.getArgCount("randomize_registers")) {
		g_Settings.randomizeRegisters = (bool)g_Args.getArgInt("randomize_registers");
	}
	if (g_Args.getArgCount("unfold_constants")) {
		g_Settings.unfoldConstants = (bool)g_Args.getArgInt("unfold_constants");
	}
	if (g_Args.getArgCount("insert_junk")) {
		g_Settings.insertJunkCode = (bool)g_Args.getArgInt("insert_junk");
	}
	if (g_Args.getArgCount("fixed_base")) {
		g_Settings.fixedBase = (bool)g_Args.getArgInt("fixed_base");
	}
	if (g_Args.getArgCount("display_disasm")) {
		g_Settings.displayDisasm = (bool)g_Args.getArgInt("display_disasm");
	}

	logger.write(LOG_MSG, "Copying %s to %s\n", inputFilePath.c_str(), outputFilePath.c_str());

	if (!CopyFileA(inputFilePath.c_str(), outputFilePath.c_str(), FALSE)) {
		logger.write(LOG_MSG, "Could not create output file: %d\n", GetLastError());
		return false;
	}
	
	// VA targets for absolute jumps, calls
	std::vector<DWORD> vas;
	int vaCount = g_Args.getArgCount("va_target");
	if (vaCount == 0) {
		logger.write(LOG_MSG, "No absolute address fix-ups specified\n");
	}
	else {
		for (int i = 0; i < vaCount; i++) {
			DWORD va = g_Args.getArgIntOccurrence("va_target", i, 16);
			vas.push_back(va);
		}
	}

	MappedPeFile outputFile(outputFilePath.c_str());
	outputFile.map(0x1000); 
	// TODO: rather use 0, then in install.cpp remap with the actual size needed 
	// (which is known after the VirtualizeRegions function is called)

	g_TargetPe = &outputFile;

	// General PE changes
	if (g_Settings.fixedBase) {
		logger.write(LOG_ERROR, "Setting fixed base\n");
		outputFile.getNtHeaders()->FileHeader.Characteristics |= IMAGE_FILE_RELOCS_STRIPPED;
	}

	bool isStandalone = (bool)g_Args.getArgInt("standalone");
	if (!isStandalone) {	
		// Library mode - VM is contained within the target executable
		VmFile vm(&outputFile);
		if (!vm.load()) {
			logger.write(LOG_ERROR, "Vm::Load failed\n");
			return false;
		}

		return InstallVmLib(&outputFile, &vm, vas);
	} else {	
		//	Stand-alone mode, VM needs to be copied into the target,
		//	and regions to protect need to be specified manually

		char originalVmPath[MAX_PATH];
		sprintf(originalVmPath, "%s/%s", GetRootDirectory(), "phant.exe");

		char tempVmPath[MAX_PATH];
		sprintf(tempVmPath, "%s/%s", GetTempDirectory(), "phant_temp.bin");

		// Make a working copy of the VM file
		if (!CopyFileA(originalVmPath, tempVmPath, FALSE)) {
			logger.write(LOG_ERROR, "Could not make a copy of the VM\n");
			logger.write(LOG_MSG, "CopyFile failed: %d\n", GetLastError());
			return false;
		}

		// Map it
		MappedPeFile vmFile(tempVmPath);
		vmFile.map(0x1000);

		VmFile vm(&vmFile);
		if (!vm.load()) {
			logger.write(LOG_ERROR, "Vm::Load failed\n");
			return false;
		}

		// Protected sections
		std::vector<std::pair<DWORD, DWORD>> targets;
		int protectedCount = g_Args.getArgCount("protected_section");
		for (int i = 0; i < protectedCount; i++) {
			DWORD va = g_Args.getArgIntOccurrence("protected_section", i, 16);
			DWORD length = g_Args.getArgIntOccurrence("protected_section_size", i, 10);
			targets.push_back(std::make_pair(va, length));
		}

		if (targets.size() == 0) {
			logger.write(LOG_ERROR, "No code regions to protect\n");
			return false;
		}

		bool success = InstallVmStandalone(&outputFile, &vm, targets, vas);
		logger.write(LOG_MSG, "VM installed, saving and unmapping file\n");
		outputFile.unmap();
		vmFile.unmap();

		DeleteFile(tempVmPath);

		return success;
	}
}


```

`chvrn_vm/cli.h`:

```h
#include "stdafx.h"
#include "ArgsParser.h"
#include "MappedPeFile.h"

extern ArgsParser g_Args;

// Global assigned in RunCli, alive until it returns
extern MappedPeFile *g_TargetPe;

bool RunCli(int argc, char** argv);


```

`chvrn_vm/control.cpp`:

```cpp
/*
	Control flow instructions
	jmp, call, retn
*/
#include "stdafx.h"
#include "x86vm.h"

bool VirtualizeNop(CodeChunk *code, DISASM *disasm) {
	doNop(code, disasm);
	return false;
}

bool VirtualizeRetn(CodeChunk *code, DISASM *disasm) {
	if (disasm->Instruction.Opcode == 0xc3) {	// retn with no size
		doVmPush(code, disasm, 0);
	}
	else if (disasm->Instruction.Opcode == 0xc2) {	// retn with size
		DWORD n = MAKELONG(*(WORD*)(disasm->EIP + 1),0);
		doVmPush(code, disasm, n);
	}
	else {
		return false;
	}

	doVmReturn(code, disasm);
	return true;
}

bool VirtualizeCallRel(CodeChunk *code, DISASM *disasm) {

	BYTE instr[] = 
	{
		0xc7, 0x44, 0x24, 0xfc, 0x00, 0x00, 0x00, 0x00,		// mov dword [esp-4], 0x00000000
		0xff, 0x54, 0x24, 0xfc,								// jmp dword [esp-4]
	};

	*(DWORD*)&instr[4] = disasm->Instruction.AddrValue;

	doNativeHandler(code, disasm, instr, sizeof(instr));

	return true;
}

bool VirtualizeFf(CodeChunk *code, DISASM *disasm) {
	// Reg/opcode byte: 0 = INC, 1 = DEC, 2 = CALL, 3 = CALLF, 4 = JMP, 5 = JMPF, 6 = PUSH
	switch (getReg(disasm)) {
	case 0:
		//logger.write(LOG_MSG, "INC -> native\n");
		return false;
	case 1:
		//logger.write(LOG_MSG, "DEC -> native\n");
		return false;
	case 2:
		// TODO
		// Call into virtualized code vs. call into native
		return false;
	case 3:
		//logger.write(LOG_MSG, "CALLF -> native\n");
		return false;
	case 4: // JMP
		pushCalculateScaledAddress(code, disasm, &disasm->Argument1);
		doDeref(code, disasm);
		doJumpAbs(code, disasm);
		return true;
	case 5: // JMPF
		//logger.write(LOG_MSG, "JMPF -> native\n");
		return false;
	case 6: // PUSH
		pushCalculateScaledAddress(code, disasm, &disasm->Argument2);
		doDeref(code, disasm);
		doPushDword(code, disasm);
		return true;
	default:
		logger.write(LOG_ERROR, "Fix this - unimplemented ff case\n");
		return false;
	}
	return false;
}

bool VirtualizeJmpRel(CodeChunk *code, DISASM *disasm) {
	doVmPush(code, disasm, 1);
	doJumpRelCond(code, disasm, disasm->Instruction.AddrValue);
	return true;
}

bool VirtualizeJcc(CodeChunk *code, DISASM *disasm) {
	// The older beaengine doesn't set the flags correctly for these, so use opcodes instead

	switch (disasm->Instruction.Opcode) {
	case 0x70:	// JO,	OF = 1
	case 0x0f80:
		doPushFlag(code, disasm, Flags::OF);
		break;
	case 0x71:	// JNO,	OF = 0
	case 0x0f81:
		doPushFlag(code, disasm, Flags::OF);
		doVmPush(code, disasm, 1);
		doXor(code, disasm);
		break;
	case 0x72:	// JB/JNAE/JC, CF = 1 
	case 0x0f82:
		doPushFlag(code, disasm, Flags::CF);
		break;
	case 0x73:	// JNB/JNAE/JC, CF = 0
	case 0x0f83:
		doPushFlag(code, disasm, Flags::CF);
		doVmPush(code, disasm, 1);
		doXor(code, disasm);
		break;
	case 0x74:	// JE/JZ, ZF = 1
	case 0x0f84:
		doPushFlag(code, disasm, Flags::ZF);
		break;
	case 0x75:	// JNE/JNZ, ZF = 0
	case 0x0f85:
		doPushFlag(code, disasm, Flags::ZF);
		doVmPush(code, disasm, Flags::ZF);
		doXor(code, disasm);
		break;
	case 0x76:	// JBE/JNA, CF = 1 or ZF = 1
	case 0x0f86:
		doPushFlag(code, disasm, Flags::CF);
		doPushFlag(code, disasm, Flags::ZF);
		//doOr(code, disasm); //TODO
		break;
	case 0x77:	// JA/JNBE, CF = 0 and ZF = 0
	case 0x0f87:
		doPushFlag(code, disasm, Flags::CF);
		doVmPush(code, disasm, 1);
		doXor(code, disasm);
		doPushFlag(code, disasm, Flags::ZF);
		doVmPush(code, disasm, 1);
		doXor(code, disasm);
		//doAnd(code, disasm); //TODO
		break;
	case 0x78:	// JS, SF = 1
	case 0x0f88:
		doPushFlag(code, disasm, Flags::SF);
		break;
	case 0x79:	// JNS, SF = 0
	case 0x0f89:
		doPushFlag(code, disasm, Flags::SF);
		doVmPush(code, disasm, 1);
		doXor(code, disasm);
		break;
	case 0x7A:	// JP/JPE, PF = 1
	case 0x0f8A:
		doPushFlag(code, disasm, Flags::PF);
		break;
	case 0x7B:	// JNP/JPO, PF = 0
	case 0x0f8B:
		doPushFlag(code, disasm, Flags::PF);
		doVmPush(code, disasm, 1);
		doXor(code, disasm);
		break;
	case 0x7C:	// JL/JNGE, SF != OF
	case 0x0f8C:
		doPushFlag(code, disasm, Flags::SF);
		doPushFlag(code, disasm, Flags::OF);
		doXor(code, disasm);
		break;
	case 0x7D:	// JGE/JNL, SF = OF
	case 0x0f8D:
		doPushFlag(code, disasm, Flags::SF);
		doPushFlag(code, disasm, Flags::OF);
		doXor(code, disasm);
		doVmPush(code, disasm, 1);
		doXor(code, disasm);
		break;
	case 0x7E:	// JLE/JNG, ZF = 1 or SF != OF
	case 0x0f8E:
		// eh, later. Debug the others first
		logger.write(LOG_ERROR, "Fix this - unimplemented JCC (JLE)\n");
		return false;
	case 0x7F:	// JG/JNLE, ZF = 0 and SF = OF
	case 0x0f8F:
		logger.write(LOG_ERROR, "Fix this - unimplemented JCC (JG)\n");
		// eh, later. Debug the others first
		return false;
	}

	doJumpRelCond(code, disasm, disasm->Instruction.AddrValue);
	return true;
}
```

`chvrn_vm/control.h`:

```h
#pragma once
#include "stdafx.h"
#include "CodeChunk.h"

bool VirtualizeNop(CodeChunk *code, DISASM *disasm);
bool VirtualizeCallRel(CodeChunk *code, DISASM *disasm);
bool VirtualizeRetn(CodeChunk *code, DISASM *disasm);
bool VirtualizeJcc(CodeChunk *code, DISASM *disasm);
bool VirtualizeJmpRel(CodeChunk *code, DISASM *disasm);
bool VirtualizeFf(CodeChunk *code, DISASM *disasm);
```

`chvrn_vm/data.cpp`:

```cpp
/*
	Data transfer instructions
	mov, lea
*/
#include "stdafx.h"
#include "x86vm.h"
#include "cli.h"

// MOV (+ LEA) virtualizer
bool VirtualizeMov(CodeChunk *code, DISASM *disasm) {
	if ((disasm->Argument1.ArgType & MEMORY_TYPE) != 0) {	// first arg is mem, second is reg or constant
		if ((disasm->Argument2.ArgType & CONSTANT_TYPE) != 0) {	// second arg is constant
			if (g_TargetPe->isRelocatableVa(disasm->Instruction.Immediat)) {
				doVmPush(code, disasm, disasm->Instruction.Immediat-g_TargetPe->getNtHeaders()->OptionalHeader.ImageBase);
				//doVmRebase(code, disasm);
			}
			else {
				doVmPush(code, disasm, disasm->Instruction.Immediat);
			}
		}
		else { // second arg is a reg
			doVmPushReg(code, disasm, getSingleRegister(disasm->Argument2.ArgType));
		}

		pushCalculateScaledAddress(code, disasm, &disasm->Argument1);
		doMove(code, disasm);
	}
	else if ((disasm->Argument2.ArgType & MEMORY_TYPE) != 0) {	// first arg reg, second mem
																// First argument can only be a register
		pushCalculateScaledAddress(code, disasm, &disasm->Argument2);

		if (disasm->Instruction.Opcode != 0x8d) { // no deref for the special snowflake LEA...
			doDeref(code, disasm);
		}

		doVmPopReg(code, disasm, getSingleRegister(disasm->Argument1.ArgType));
	}
	else {	// first arg reg, second constant, or both args reg
		if (disasm->Argument2.ArgType & REGISTER_TYPE) { // second is reg
			doVmPushReg(code, disasm, getSingleRegister(disasm->Argument2.ArgType));
		}
		else { // second is constant
			doVmPush(code, disasm, disasm->Instruction.Immediat);
			if (g_TargetPe->isRelocatableVa(disasm->Instruction.Immediat)) {
				//doVmRebase(code, disasm);
			}
		}

		doVmPopReg(code, disasm, getSingleRegister(disasm->Argument1.ArgType));
	}
	return true;
}
```

`chvrn_vm/data.h`:

```h
#pragma once
#include "stdafx.h"

bool VirtualizeMov(CodeChunk *code, DISASM *disasm);
```

`chvrn_vm/environment.cpp`:

```cpp
#include "stdafx.h"

static char g_rootDirectory[MAX_PATH];
static char g_logDirectory[MAX_PATH];
static char g_tempDirectory[MAX_PATH];

const char *GetRootDirectory() {
	return g_rootDirectory;
}

const char *GetLogDirectory() {
	return g_logDirectory;
}

const char *GetTempDirectory() {
	return g_tempDirectory;
}

bool CreateDirectoryIfNotExists(const char *path) {
	if (!CreateDirectory(path, NULL)) {
		if (GetLastError() != ERROR_ALREADY_EXISTS) {
			return false;
		}
	}
	return true;
}

bool SetupDirectories() {
	DWORD length = GetCurrentDirectory(MAX_PATH, g_rootDirectory);
	if (length == 0) {
		return false;
	}

	sprintf(g_logDirectory, "%s/%s", g_rootDirectory, "logs");
	sprintf(g_tempDirectory, "%s/%s", g_rootDirectory, "temp");

	if (!CreateDirectoryIfNotExists(g_logDirectory)) {
		return false;
	}
	if (!CreateDirectoryIfNotExists(g_tempDirectory)) {
		return false;
	}

	return true;
}
```

`chvrn_vm/environment.h`:

```h
#pragma once
#include "stdafx.h"


const char *GetRootDirectory();
const char *GetLogDirectory();
const char *GetTempDirectory();
bool SetupDirectories();



```

`chvrn_vm/install.cpp`:

```cpp
#include "stdafx.h"
#include "MappedPeFile.h"
#include "Vm.h"
#include "x86.h"
#include "x86vm.h"
#include "patterns.h"
#include "registerswap.h"
#include "settings.h"
#include "markers.h"

bool createVaLookupTable(MappedPeFile *target, VmFile *vm, std::vector<CodeChunk> *chunks, std::vector<DWORD> vas) {
	logger.write(LOG_MSG, "Creating VA table\n");
	std::vector<std::pair<DWORD, DWORD>> vaTable;
	for (unsigned int j = 0; j < vas.size(); j++) {
		DWORD newVa = -1;
		for (unsigned int k = 0; k < chunks->size(); k++) {
			newVa = (*chunks)[k].getInstructionAddress(vas[j]);
			if (newVa != 1) {
				vaTable.push_back(std::make_pair(vas[j]-target->getNtHeaders()->OptionalHeader.ImageBase, newVa-target->getNtHeaders()->OptionalHeader.ImageBase));
				break;
			}
		}

		if (!newVa) {
			logger.write(LOG_WARN, "VA %08x was not found, skipping\n", vas[j]);
		}
	}

	// Create the table
	logger.write(LOG_MSG, "Address lookup table has %d entries\n", vaTable.size());
	if (vaTable.size() > 0) {
		DWORD vaAddressLookupTable = target->getCurrentVa();
		for (unsigned int i = 0; i < vaTable.size(); i++) {
			target->addToLastSection((BYTE*)&vaTable[i].first, sizeof(DWORD));
		}
		DWORD vaAddressValuesTable = target->getCurrentVa();
		for (unsigned int i = 0; i < vaTable.size(); i++) {
			target->addToLastSection((BYTE*)&vaTable[i].second, sizeof(DWORD));
		}

		for (unsigned int i = 0; i < vaTable.size(); i++) {
			logger.write(LOG_MSG, "%08x | %08x \n", vaTable[i].first, vaTable[i].second);
		}

		vm->getVmHeader()->addressLookupTable = vaAddressLookupTable;
		vm->getVmHeader()->addressValueTable = vaAddressValuesTable;
		logger.write(LOG_MSG, "LookupTable: %08x\nValueTable: %08x\n", vaAddressLookupTable, vaAddressValuesTable);
	}
	else {
		logger.write(LOG_MSG, "Lookup table empty, not adding/patching\n");
	}
	return true;
}

std::vector<CodeChunk> VirtualizeRegions(MappedPeFile *target, VmFile *vm, std::vector<std::pair<DWORD, DWORD>> regions) {
	std::vector<CodeChunk> chunks;

	for (unsigned int i = 0; i < regions.size(); i++) {
		logger.write(LOG_MSG, "Analyzing code at %08x (%d bytes)\n", regions[i].first, regions[i].second);

		BYTE *buf = target->getFileBuffer() + target->va2FileOffset(regions[i].first);

		CodeChunk code(regions[i].first);

		if (g_Settings.randomizeRegisters) {
			obfRandomizeRegisterMapping();
			doObfSwapRegisters(&code, 0);
		}

		DWORD originalLen = Virtualize(&code, buf, regions[i].second);

		logger.write(LOG_MSG, "Recalculating relative operands...\n");
		if (!code.recalculateRelativeOperands()) {
			logger.write(LOG_WARN, "Recalculating relative operands failed\n");
			break;
		}

		// Restore registers
		if (g_Settings.randomizeRegisters) {
			doObfSwapRegisters(&code, 0);
		}

		// Add VmExit to the end of the chunk
		// Must be done AFTER recalculateRelativeOperands
		doVmPush(&code, 0, (DWORD)code.getBaseVa() + 5 + 5); // +5 to skip the push, +5 to skip the jmp
		doVmExit(&code, 0);

		// Apply opcode mapping
		vm->generateOpcodes(&code);

#ifndef STRIPPED_BUILD
		logger.write(LOG_MSG, "Result:\n");
		code.print();
#endif
		logger.write(LOG_MSG,  "-> %d VM instructions (%d bytes)\n", code.getCount(), code.getSize());
		logger.write(LOG_MSG, "Size overhead: %d%%\n", (unsigned int)(100*(originalLen + code.getSize()) / (float)originalLen));
		logger.write(LOG_MSG, "Appending VM bytecode to %08x (offset %d)\n", target->getCurrentVa(), target->va2FileOffset(target->getCurrentVa()));
		
		DWORD vmIp = target->addToLastSection(code.createByteBuffer(), code.getSize());

		// TEMP
		vmIp -= target->getNtHeaders()->OptionalHeader.ImageBase;

		code.setIp(vmIp);
		chunks.push_back(code);

		// NOP out all bytes
		logger.write(LOG_MSG, "Removing original code\n");
		for (unsigned int i = 0; i < originalLen; i++) {
			buf[i] = 0x90;
		}
	}
	return chunks;
}

bool InstallVmLib(MappedPeFile *target, VmFile *vm, std::vector<DWORD> fixups) {
	logger.write(LOG_MSG, "Registering virtualizers\n");
	RegisterVirtualizers();

	BYTE *code = target->getFileBuffer() + target->getSectionFromName(".text")->PointerToRawData;
	DWORD size = target->getSectionFromName(".text")->SizeOfRawData;

	std::vector<std::pair<DWORD, DWORD>> vas = scanForMarkers(code, size);

	if (vas.size() == 0) {
		logger.write(LOG_ERROR, "No markers found. Exiting\n");
		return false;
	}

	logger.write(LOG_MSG, "Detected markers inside target:\n");
	for (unsigned int i = 0; i < vas.size(); i++) {
		vas[i].first += target->getNtHeaders()->OptionalHeader.ImageBase + target->getSectionFromName(".text")->VirtualAddress;
		logger.write(LOG_MSG, "%08x -> %08x (%d bytes)\n", vas[i].first, vas[i].first + vas[i].second, vas[i].second);
	}

	// Patch BeginProtect stub
	logger.write(LOG_MSG, "Patching BeginProtect...\n");
	vm->patchBeginProtect();

	logger.write(LOG_MSG, "Generating opcodes\n");
	if (g_Settings.randomizeOpcodes) {
		vm->randomizeOpcodes();
	}

	std::vector<CodeChunk> chunks;
	chunks = VirtualizeRegions(target, vm, vas);

	logger.write(LOG_MSG, "Patching markers\n");
	for (unsigned int i = 0; i < vas.size(); i++) {
		// Patch in correct VM IP
		target->patchVa(vas[i].first - 10 + 1, chunks[i].getIp());

		// NOP out the end marker 
		for (unsigned int j = 0; j < 10; j++) {
			(target->getFileBuffer() + target->va2FileOffset(vas[i].first + vas[i].second))[j] = 0x90;
		}
	}

	createVaLookupTable(target, vm, &chunks, fixups);

	return true;
}

bool InstallVmStandalone(MappedPeFile *target, VmFile *vm, std::vector<std::pair<DWORD,DWORD>> targets, std::vector<DWORD> vas) {
	//	This function is not up to date with the current VM implementation!
	//	(the patch offsets are fewer and need updating)

	// Must be done first (!)
	logger.write(LOG_MSG, "Registering virtualizers\n");
	RegisterVirtualizers();

	logger.write(LOG_MSG, "Installing VM as standalone\n");

	// Make sure the target file has the needed imports to patch the VM
	DWORD vaVirtualAlloc = target->getIatVa("kernel32.dll", "VirtualAlloc");
	DWORD vaVirtualFree = target->getIatVa("kernel32.dll", "VirtualFree");

	if (!vaVirtualAlloc || !vaVirtualFree) {
		logger.write(LOG_ERROR, "Target has missing imports\n");
		logger.write(LOG_MSG, "VirtualAlloc: %08x, VirtualFree: %08x\n", vaVirtualAlloc, vaVirtualFree);
		return false;
	}
	// VM assembling is done: add it to the file
	//target->createSection(".vm", IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ); // TODO: when no space...
	DWORD vmVa = target->addToLastSection(vm->getVmCodeBytes(), vm->getVmSize());
	logger.write(LOG_MSG, "VM added at %08x (%d bytes)\n", vmVa, vm->getVmSize());
	logger.write(LOG_MSG, "Old VM base was: %08x\n", vm->getVmHeader()->vmBaseVa);

	logger.write(LOG_MSG, "Patching API calls\n"); // TODO
	target->patchVa(vmVa + vm->getVmHeader()->vmVirtualAllocPatchOffset1, vaVirtualAlloc);
	target->patchVa(vmVa + vm->getVmHeader()->vmVirtualAllocPatchOffset2, vaVirtualAlloc);

	target->patchVa(vmVa + vm->getVmHeader()->vmVirtualFreePatchOffset1, vaVirtualFree);
	target->patchVa(vmVa + vm->getVmHeader()->vmVirtualFreePatchOffset2, vaVirtualFree);

	printf("Recalculating jumps\n");
	target->patchVa(vmVa + vm->getVmHeader()->vmReenterPatchOffset, vmVa + vm->getVmHeader()->vmReenterOffset);
	target->patchVa(vmVa + vm->getVmHeader()->vmExitPatchOffset, vmVa + vm->getVmHeader()->vmExitNativeOffset);

	// TODO: scrambling måste ske här, inte i generate opcodes
	// vm->getHandlerTable() efter generateOpcodes() skett
	logger.write(LOG_MSG, "Copying handlers\n");
	logger.write(LOG_MSG, "%d handlers found\n", vm->getVmHeader()->vmHandlerCount);
	DWORD vaHandlerTable = target->addToLastSection(vm->getHandlers(), sizeof(DWORD)*vm->getHandlerCount());
	DWORD *handlerTable = (DWORD*)target->va2ptr(vaHandlerTable);

	logger.write(LOG_MSG, "Patching handler VA to: %08x\n", vaHandlerTable);
	*(DWORD*)target->va2ptr(vmVa + vm->getVmHeader()->vmHandlerPatchOffset) = vaHandlerTable;

	logger.write(LOG_MSG, "Rebasing handler table\n");
	for (unsigned int i = 0; i < vm->getVmHeader()->vmHandlerCount; i++) {
		logger.write(LOG_MSG, "%08x->%08x\n", handlerTable[i], handlerTable[i] - vm->getVmHeader()->vmBaseVa + vmVa);
		handlerTable[i] = handlerTable[i] - vm->getVmHeader()->vmBaseVa + vmVa;
	}

	// 4. 
	DWORD vmInitVa = vmVa + vm->getVmHeader()->vmInitOffset;
	logger.write(LOG_MSG, "New VmInit va: %08x\n", vmInitVa);

	std::vector<CodeChunk> chunks;
	chunks = VirtualizeRegions(target, vm, targets);

	logger.write(LOG_MSG, "Patching call stubs\n");
	for (unsigned int i = 0; i < chunks.size(); i++) {
		BYTE *buf = target->getFileBuffer() + target->va2FileOffset(targets[i].first);
		logger.write(LOG_MSG, "Patching bytes...\n");
		unsigned int idx = 0;
		buf[idx] = 0x68;
		*(DWORD*)&buf[idx + 1] = chunks[i].getIp();	// push IP to VM init
		idx += 5;

		buf[idx] = 0xe9;
		*(DWORD*)&buf[idx + 1] = vmInitVa - (targets[i].first + idx) - 5;	// jmp to VM init
		idx += 5;
	}

	createVaLookupTable(target, vm, &chunks, vas);

	return true;
}
```

`chvrn_vm/install.h`:

```h
#pragma once
#include "stdafx.h"
#include "MappedPeFile.h"
#include "Vm.h"
#include "x86.h"

bool InstallVm();
bool InstallVmLib(MappedPeFile *target, VmFile *vm, std::vector<DWORD> fixups);
bool InstallVmStandalone(MappedPeFile *target, VmFile *vm, std::vector<std::pair<DWORD,DWORD>> targets, std::vector<DWORD> vas);
```

`chvrn_vm/log.cpp`:

```cpp
#include "stdafx.h"

// Global instance
Logger logger;

Logger::Logger()
	: m_verbosityLevel(3), m_outputFile(INVALID_HANDLE_VALUE) {

}

Logger::~Logger() {
	CloseHandle(m_outputFile);
}

bool Logger::setLogFile(const char *filename) {

	if (m_outputFile != INVALID_HANDLE_VALUE) {
		CloseHandle(m_outputFile);
	}

	m_outputFile = INVALID_HANDLE_VALUE;
	if ((m_outputFile = CreateFile(filename, GENERIC_WRITE, FILE_SHARE_READ, nullptr, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr)) == INVALID_HANDLE_VALUE) {
		return false;
	}

	return true;
}

void Logger::setVerbosity(int level) {
	m_verbosityLevel = level;
}

void Logger::write(int level, const char *fmt, ...) {
	char buffer[256];
	va_list args;
	va_start(args, fmt);
	int length = vsprintf(buffer, fmt, args); // TODO: check length
	va_end(args);

	const char *fmts[] = { "Error: %s", "Warning: %s", "%s", "%s" };

	if (level < m_verbosityLevel) {
		if (level < 4) {
			printf(fmts[level], buffer);
		}
		else {
			printf("%s", buffer);
		}
	}

	DWORD written;
	if (m_outputFile != INVALID_HANDLE_VALUE) {
		if (!WriteFile(m_outputFile, buffer, length, &written, NULL)) {
			printf("ERROR: could not write to log file\n");
		}
	}
}
```

`chvrn_vm/log.h`:

```h
#include "stdafx.h"

class Logger {
public:
	Logger();
	~Logger();
	bool setLogFile(const char *filename);
	void setVerbosity(int level);
	void write(int verbosity, const char *fmt, ...);
private:
	int m_verbosityLevel;
	HANDLE m_outputFile;
};

#define LOG_ERROR		0
#define LOG_WARN		1
#define LOG_MSG			2
#define LOG_VERBOSE		3

extern Logger logger;
```

`chvrn_vm/logic.cpp`:

```cpp
/*
	Logical and bitwise instructions
	not, and, or, xor
*/
#include "stdafx.h"
#include "Vm.h"
#include "VmInstruction.h"
#include "CodeChunk.h"
#include "x86vm.h"
#include "logic.h"

bool Virtualize81(CodeChunk *code, DISASM *disasm) {
	BYTE reg = getReg(disasm);

	switch (reg) {
	case 0:	// ADD
		return VirtualizeAdd(code, disasm);
	case 1:	// OR
		return VirtualizeOr(code, disasm);
	case 2:	// ADC
		break;
	case 3:	// SBB
		break;
	case 4:	// AND
		return VirtualizeAnd(code, disasm);
	case 5:	// SUB
		return VirtualizeSub(code, disasm);
	case 6:	// XOR
		return VirtualizeXor(code, disasm);
	case 7:	// CMP
		return VirtualizeCmp(code, disasm);
	default:
		return false;
	}

	return false;
}

// Opcodes: 83
bool Virtualize83(CodeChunk *code, DISASM *disasm) {

	//DWORD opcode = disasm->Instruction.Opcode;
	BYTE reg = getReg(disasm);

	switch (reg) {
	case 0:	// ADD
		return VirtualizeAdd(code, disasm);
	case 1:	// OR
		return VirtualizeOr(code, disasm);
	case 2:	// ADC
	case 3:	// SBB
		return false;
	case 4:	// AND
		return VirtualizeAnd(code, disasm);
	case 5:	// SUB
		return VirtualizeSub(code, disasm);
	case 6:	// XOR
		return VirtualizeXor(code, disasm);
	case 7:	// CMP
		return VirtualizeCmp(code, disasm);
	default:
		return false;
	}
}

bool VirtualizeAnd(CodeChunk *code, DISASM *disasm) {
	pushCalculateScaledAddress(code, disasm, &disasm->Argument1);
	pushCalculateScaledAddress(code, disasm, &disasm->Argument2);
	doNand(code, disasm);
	doRepush(code, disasm);
	doNand(code, disasm);

	if ((disasm->Argument1.ArgType & MEMORY_TYPE) != 0) {
		doMove(code, disasm);
	}
	else if ((disasm->Argument1.ArgType & REGISTER_TYPE) != 0) {
		doVmPopReg(code, disasm, getSingleRegister(disasm->Argument1.ArgType));
	}
	return true;
}

bool VirtualizeOr(CodeChunk *code, DISASM *disasm) {
	pushCalculateScaledAddress(code, disasm, &disasm->Argument1);
	doRepush(code, disasm);
	doNand(code, disasm);

	pushCalculateScaledAddress(code, disasm, &disasm->Argument2);
	doRepush(code, disasm);
	doNand(code, disasm);

	doNand(code, disasm);

	if ((disasm->Argument1.ArgType & MEMORY_TYPE) != 0) {
		doMove(code, disasm);
	}
	else if ((disasm->Argument1.ArgType & REGISTER_TYPE) != 0) {
		doVmPopReg(code, disasm, getSingleRegister(disasm->Argument1.ArgType));
	}
	return true;
}

bool VirtualizeXor(CodeChunk *code, DISASM *disasm) {
	
	pushCalculateScaledAddress(code, disasm, &disasm->Argument1);
	pushCalculateScaledAddress(code, disasm, &disasm->Argument2);

	doNand(code, disasm);

	pushCalculateScaledAddress(code, disasm, &disasm->Argument1);
	doNand(code, disasm);

	pushCalculateScaledAddress(code, disasm, &disasm->Argument1);
	pushCalculateScaledAddress(code, disasm, &disasm->Argument2);
	doNand(code, disasm);

	pushCalculateScaledAddress(code, disasm, &disasm->Argument2);
	doNand(code, disasm);

	doNand(code, disasm);

	if ((disasm->Argument1.ArgType & MEMORY_TYPE) != 0) {
		doMove(code, disasm);
	}
	else if ((disasm->Argument1.ArgType & REGISTER_TYPE) != 0) {
		doVmPopReg(code, disasm, getSingleRegister(disasm->Argument1.ArgType));
	}

	return true;
}

bool VirtualizeAddSub(CodeChunk *code, DISASM *disasm, bool isAdd) {

	pushCalculateScaledAddress(code, disasm, &disasm->Argument2);
	if ((disasm->Argument2.ArgType & MEMORY_TYPE) != 0) {
		doDeref(code, disasm);
	}

	pushCalculateScaledAddress(code, disasm, &disasm->Argument1);
	if ((disasm->Argument1.ArgType & MEMORY_TYPE) != 0) {
		doDeref(code, disasm);
	}

	if (isAdd) {
		doAdd(code, disasm);
	}
	else {
		doSub(code, disasm);
	}

	if ((disasm->Argument1.ArgType & MEMORY_TYPE) != 0) {
		pushCalculateScaledAddress(code, disasm, &disasm->Argument1);
		doMove(code, disasm);
	}
	else if ((disasm->Argument1.ArgType & REGISTER_TYPE) != 0) {
		doVmPopReg(code, disasm, getSingleRegister(disasm->Argument1.ArgType));
	}

	return true;
}

bool VirtualizeAdd(CodeChunk *code, DISASM *disasm) {
	return VirtualizeAddSub(code, disasm, true);
}

bool VirtualizeSub(CodeChunk *code, DISASM *disasm) {
	return VirtualizeAddSub(code, disasm, false);
}

// 0xf7
bool VirtualizeNeg(CodeChunk *code, DISASM *disasm) {
	pushCalculateScaledAddress(code, disasm, &disasm->Argument1);
	doVmPush(code, disasm, 0);
	doSub(code, disasm);

	if ((disasm->Argument1.ArgType & MEMORY_TYPE) != 0) {
		doMove(code, disasm);
	}
	else if ((disasm->Argument1.ArgType & REGISTER_TYPE) != 0) {
		doVmPopReg(code, disasm, getSingleRegister(disasm->Argument1.ArgType));
	}

	return true;
}

bool VirtualizeCmp(CodeChunk *code, DISASM *disasm) {
	pushCalculateScaledAddress(code, disasm, &disasm->Argument2);
	if ((disasm->Argument2.ArgType & MEMORY_TYPE) != 0) {
		doDeref(code, disasm);
	}

	pushCalculateScaledAddress(code, disasm, &disasm->Argument1);
	if ((disasm->Argument1.ArgType & MEMORY_TYPE) != 0) {
		doDeref(code, disasm);
	}

	doSub(code, disasm);

	doVmPopRemove(code, disasm);

	return true;
}
```

`chvrn_vm/logic.h`:

```h
#pragma once
#include "stdafx.h"

bool Virtualize81(CodeChunk *code, DISASM *disasm);
bool Virtualize83(CodeChunk *code, DISASM *disasm);
bool VirtualizeAnd(CodeChunk *code, DISASM *disasm);
bool VirtualizeOr(CodeChunk *code, DISASM *disasm);
bool VirtualizeXor(CodeChunk *code, DISASM *disasm);

bool VirtualizeAdd(CodeChunk *code, DISASM *disasm);
bool VirtualizeSub(CodeChunk *code, DISASM *disasm);
bool VirtualizeNeg(CodeChunk *code, DISASM *disasm);

bool VirtualizeCmp(CodeChunk *code, DISASM *disasm);
```

`chvrn_vm/main.cpp`:

```cpp
#include "stdafx.h"
#include "cli.h"
#include "environment.h"

int _tmain(int argc, _TCHAR* argv[])
{
	if (!SetupDirectories()) {
		logger.write(LOG_ERROR, "Could not create directories");
		return 1;
	}

	SYSTEMTIME lt;
	GetLocalTime(&lt);

	char filename[MAX_PATH];
	sprintf(filename, "%s/%04d-%02d-%02d_%02d%02d.txt", 
		GetLogDirectory(), lt.wYear, lt.wMonth, lt.wDay, lt.wHour, lt.wMinute);
	
	if (!logger.setLogFile(filename)) {
		logger.write(LOG_WARN, "Could not create log file: %s\n", filename);
	}

	logger.setVerbosity(3);
	
	if (!RunCli(argc, argv)) {
		logger.write(LOG_WARN, "There were errors - see above\n");
		return 1;
	}
	
	logger.write(LOG_WARN, "All operations successful\n");
	return 0;
}


```

`chvrn_vm/markers.cpp`:

```cpp
#include "stdafx.h"
#include "patterns.h"

static DWORD g_markerSize = 5 + 5; // push <dword>, jmp <dword rel offset>

DWORD findBeginProtectMarker(BYTE *data, DWORD length) {
	static BYTE pattern[] = { 0x68, 0x57, 0x20, 0xf1, 0xb1 };
	return findBytePattern(data, length, pattern, sizeof(pattern));
}

DWORD findEndProtectMarker(BYTE *data, DWORD length) {
	static BYTE pattern[] = { 0x68, 0xb1, 0xf1, 0x20, 0x57 };
	return findBytePattern(data, length, pattern, sizeof(pattern));
}

// Scan for pairs of BeginProtect and EndProtect markers
std::vector<std::pair<DWORD, DWORD>> scanForMarkers(BYTE *data, DWORD length) {
	logger.write(LOG_VERBOSE, "Scanning for markers...\n");
	std::vector<std::pair<DWORD, DWORD>> regions;

	DWORD bufferOffset = 0;
	while (true) {
		DWORD beginMarkerOffset = findBeginProtectMarker(data + bufferOffset, length);
		DWORD endMarkerOffset = findEndProtectMarker(data + bufferOffset, length);

		if (beginMarkerOffset == -1) {	// done
			break;
		}

		if (endMarkerOffset == -1) {
			logger.write(LOG_ERROR, "Missing EndProtect marker\n");
			break;
		}
		if (beginMarkerOffset > endMarkerOffset) {
			logger.write(LOG_ERROR, "BeginProtect/EndProtect markers in incorrect order\n");
			break;
		}

		length -= endMarkerOffset + g_markerSize;

		beginMarkerOffset += bufferOffset;
		endMarkerOffset += bufferOffset;

		bufferOffset += endMarkerOffset + g_markerSize;

		logger.write(LOG_VERBOSE, "BeginMarkerOffset: %x\n", beginMarkerOffset);
		logger.write(LOG_VERBOSE, "EndMarkerOffset: %x\n", endMarkerOffset);

		regions.push_back(std::make_pair(beginMarkerOffset + g_markerSize, endMarkerOffset - (beginMarkerOffset + g_markerSize)));
	}

	return regions;
}
```

`chvrn_vm/markers.h`:

```h
#pragma once
#include "stdafx.h"

DWORD findBeginProtectMarker(BYTE *data, DWORD length);
DWORD findEndProtectMarker(BYTE *data, DWORD length);
std::vector<std::pair<DWORD, DWORD>> scanForMarkers(BYTE *data, DWORD length);
```

`chvrn_vm/patterns.cpp`:

```cpp
#include "stdafx.h"

// just a "strstr", no wildcards used
DWORD findBytePattern(BYTE *data, DWORD length, BYTE *pattern, DWORD patternLength) {
	DWORD matchCount = 0;
	for (DWORD i = 0; i < length; i++) {
		if (data[i] == pattern[matchCount]) {
			matchCount++;
		}
		else {
			matchCount = 0;
		}
		if (matchCount == patternLength) {
			return i - (patternLength - 1);
		}
	}
	return (DWORD)-1;
}
```

`chvrn_vm/patterns.h`:

```h
#pragma once
#include "stdafx.h"

DWORD findBytePattern(BYTE *data, DWORD length, BYTE *pattern, DWORD patternLength);
```

`chvrn_vm/registerswap.cpp`:

```cpp
#include "stdafx.h"
#include "CodeChunk.h"
#include "x86vm.h"

int regOriginalCodes[8] = { 0, 1, 2, 3, 4, 5, 6, 7 };
int regCodes[8] = { 0, 1, 2, 3, 4, 5, 6, 7 };

void obfRandomizeRegisterMapping() {
	srand(time(NULL));

	for (unsigned int i = sizeof(regCodes)/sizeof(regCodes[0]) - 1; i > 0; i--) {
		unsigned int j = rand() % (i+1);
		int temp = regCodes[i];
		regCodes[i] = regCodes[j];
		regCodes[j] = temp;
	}
}

BYTE getRegisterCode(int idx) {
	return regCodes[idx];
}

void doObfSwapRegisters(CodeChunk *code, DISASM *disasm) {
	_doVmPushReg(code, disasm, regCodes[0]);
	_doVmPushReg(code, disasm, regCodes[1]);
	_doVmPushReg(code, disasm, regCodes[2]);
	_doVmPushReg(code, disasm, regCodes[3]);
	_doVmPushReg(code, disasm, regCodes[4]);
	_doVmPushReg(code, disasm, regCodes[5]);
	_doVmPushReg(code, disasm, regCodes[6]);
	_doVmPushReg(code, disasm, regCodes[7]);

	_doVmPopReg(code, disasm, 7);
	_doVmPopReg(code, disasm, 6);
	_doVmPopReg(code, disasm, 5);
	_doVmPopReg(code, disasm, 4);
	_doVmPopReg(code, disasm, 3);
	_doVmPopReg(code, disasm, 2);
	_doVmPopReg(code, disasm, 1);
	_doVmPopReg(code, disasm, 0);
}
```

`chvrn_vm/registerswap.h`:

```h
#include "stdafx.h"
#include "CodeChunk.h"

BYTE getRegisterCode(int idx);
void obfRandomizeRegisterMapping();
void doObfSwapRegisters(CodeChunk *code, DISASM *disasm);	// inserts VM instructions for randomization/reset
```

`chvrn_vm/relocations.cpp`:

```cpp
#include "stdafx.h"
#include "MappedPeFile.h"
#include "CodeChunk.h"

/*
	Thought of doing relocations via a handler like so:
	doVmPush
	doVmRebase
	doPushDword
	...
	Pro: possible to add more crap on top of instructions, like XOR:ing before decoding
	Con: the native dispatch handler then needs fixing
*/
unsigned int getRelocationOffset(MappedPeFile *target, DISASM *disasm) {
	for (unsigned int i = disasm->VirtualAddr; i < disasm->VirtualAddr + disasm->SecurityBlock; i++) {
		if (target->isRelocatableVa(i)) {
			return i;
		}
	}
	return (unsigned int)-1;
}

void test_f() {

}

```

`chvrn_vm/relocations.h`:

```h
#pragma once
#include "stdafx.h"

void test_f();
```

`chvrn_vm/settings.cpp`:

```cpp
#include "stdafx.h"
#include "settings.h"

Settings g_Settings;

void LoadDefaultSettings() {
	g_Settings.insertJunkCode = true;
	g_Settings.randomizeOpcodes = true;
	g_Settings.randomizeRegisters = false;
	g_Settings.unfoldConstants = true;
	g_Settings.fixedBase = true;
	g_Settings.displayDisasm = true;
}
```

`chvrn_vm/settings.h`:

```h
#pragma once
#include "stdafx.h"

// Settings
struct Settings {
	// Virtualization settings
	bool randomizeOpcodes;
	bool randomizeRegisters;
	bool unfoldConstants;
	bool insertJunkCode;
	// General settings
	bool fixedBase;
	bool displayDisasm;
};

extern Settings g_Settings;
void LoadDefaultSettings();
// /Settings
```

`chvrn_vm/stack.cpp`:

```cpp
/*
	Stack operations
	push, pop
*/
#include "stdafx.h"
#include "x86vm.h"
#include "cli.h"


// PUSH and POP register virtualizer
// Supports opcodes: 50-5F, 68
// 50-57 are PUSH 32-bit reg, 58-5F are POP 32-bit reg
bool VirtualizePushPopRegister(CodeChunk *code, DISASM *disasm) {

	// push DWORD or push BYTE extended to DWORD (!= push with prefix BYTE)
	if (disasm->Instruction.Opcode == 0x68 || disasm->Instruction.Opcode == 0x6A) {
		DWORD value = disasm->Instruction.Immediat;
		doVmPush(code, disasm, value);
		doPushDword(code, disasm);
		return true;
	}

	BYTE reg;
	// PUSH reg
	if (0x50 <= disasm->Instruction.Opcode && disasm->Instruction.Opcode <= 0x57) {
		reg = disasm->Instruction.Opcode & 0x07;
		doPushReg(code, disasm, reg);
		return true;
	}

	// POP reg
	if (0x58 <= disasm->Instruction.Opcode && disasm->Instruction.Opcode <= 0x5f) {
		reg = (disasm->Instruction.Opcode - 0x08) & 0x07;
		doPopReg(code, disasm, reg);
		return true;
	}
	
	return false;
}
```

`chvrn_vm/stack.h`:

```h
#pragma once
#include "stdafx.h"
#include "CodeChunk.h"

bool VirtualizePushPopRegister(CodeChunk *code, DISASM *disasm);
```

`chvrn_vm/stdafx.cpp`:

```cpp
// stdafx.cpp : source file that includes just the standard includes
// chvrn_vm.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

```

`chvrn_vm/stdafx.h`:

```h
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#include "targetver.h"

#include <stdio.h>
#include <tchar.h>



// TODO: reference additional headers your program requires here


#pragma warning(disable:4244 4996)

#include "beaengine\BeaEngine.h"

#include <Windows.h>
#include <vector>
#include <WinNT.h>
#include <iostream>
#include <sstream>
#include <utility>
#include <initializer_list>
#include <time.h>
#include <map>
#include <string>

#include "build.h"
#include "log.h"


```

`chvrn_vm/targetver.h`:

```h
#pragma once

// Including SDKDDKVer.h defines the highest available Windows platform.

// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.

#include <SDKDDKVer.h>
#define WINVER _WIN32_WINNT_WINXP
#define _WIN32_WINNT _WIN32_WINNT_WINXP
```

`chvrn_vm/x86.cpp`:

```cpp
#include "stdafx.h"
#include "settings.h"
#include "Utils.h"
#include "VirtualizerList.h"
#include "x86vm.h"
#include "x86.h"

#include "control.h"
#include "data.h"
#include "logic.h"
#include "stack.h"
#include "registerswap.h"

VirtualizerList virtualizers;

void RegisterVirtualizers() { 

	DWORD movOpcodes[] = 
	{ 
		0xA1, 0x89, 0x8B, 0x8D, 0xA3, 0xB8, 0xB9, 0xBA, 0xBB, 
		0xBC, 0xBD, 0xBE, 0xBF, 0xC7
	};
	virtualizers.addVirtualizer((pfnVirtualize)VirtualizeMov, movOpcodes, sizeof(movOpcodes) / sizeof(DWORD));

	DWORD pushPopOpcodes[] = 
	{ 
		0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 
		0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
		0x68, 0x6A
	};
	virtualizers.addVirtualizer((pfnVirtualize)VirtualizePushPopRegister, pushPopOpcodes, sizeof(pushPopOpcodes) / sizeof(DWORD));

	DWORD jmpRelOpcodes[] = {
		0xeb, 0xe9
	};
	virtualizers.addVirtualizer((pfnVirtualize)VirtualizeJmpRel, jmpRelOpcodes, sizeof(jmpRelOpcodes) / sizeof(DWORD));

	DWORD jccOpcodes[] = {
		// one byte for short versions
		0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
		0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,
		// two byte for near versions
		0x0f80, 0x0f81, 0x0f82, 0x0f83, 0x0f84, 0x0f85, 0x0f86, 0x0f87, 
		0x0f88, 0x0f89, 0x0f8A, 0x0f8B, 0x0f8C, 0x0f8D, 0x0f8E, 0x0f8F, 
	};
	virtualizers.addVirtualizer((pfnVirtualize)VirtualizeJcc, jccOpcodes, sizeof(jccOpcodes) / sizeof(DWORD));

	DWORD retnOpcodes[] = {
		0xc2, 0xc3,
	};
	virtualizers.addVirtualizer((pfnVirtualize)VirtualizeRetn, retnOpcodes, sizeof(retnOpcodes) / sizeof(DWORD));

	DWORD ffOpcodes[] = {
		0xff,
	};
	virtualizers.addVirtualizer((pfnVirtualize)VirtualizeFf, ffOpcodes, sizeof(ffOpcodes) / sizeof(DWORD));

	DWORD nopOpcodes[] = {
		0x90,
	};
	virtualizers.addVirtualizer((pfnVirtualize)VirtualizeNop, nopOpcodes, sizeof(nopOpcodes) / sizeof(DWORD));

	DWORD andOpcodes[] = {
		0x21, 0x23
	};
	virtualizers.addVirtualizer((pfnVirtualize)VirtualizeAnd, andOpcodes, sizeof(andOpcodes) / sizeof(DWORD));

	DWORD orOpcodes[] = {
		0x09,
	};
	virtualizers.addVirtualizer((pfnVirtualize)VirtualizeOr, orOpcodes, sizeof(orOpcodes) / sizeof(DWORD));

	DWORD xorOpcodes[] = {
		0x30, 0x31, 0x32, 0x33, 0x34, 0x35
	};
	virtualizers.addVirtualizer((pfnVirtualize)VirtualizeXor, xorOpcodes, sizeof(xorOpcodes) / sizeof(DWORD));

	// This needs priority over overlapping ones
	DWORD b81Opcodes[] = {
		0x81,
	};
	virtualizers.addVirtualizer((pfnVirtualize)Virtualize81, b81Opcodes, sizeof(b81Opcodes) / sizeof(DWORD));

	DWORD b83Opcodes[] = {
		0x83,
	};
	virtualizers.addVirtualizer((pfnVirtualize)Virtualize83, b83Opcodes, sizeof(b83Opcodes) / sizeof(DWORD));

	DWORD callRelOpcodes[] = {
		0xe8,
	};
	virtualizers.addVirtualizer((pfnVirtualize)VirtualizeCallRel, callRelOpcodes, sizeof(callRelOpcodes) / sizeof(DWORD));

	DWORD addOpcodes[] = {
		0x01, 0x03,
	};
	virtualizers.addVirtualizer((pfnVirtualize)VirtualizeAdd, addOpcodes, sizeof(addOpcodes) / sizeof(DWORD));

	DWORD subOpcodes[] = {
		0x29,
	};
	virtualizers.addVirtualizer((pfnVirtualize)VirtualizeSub, subOpcodes, sizeof(subOpcodes) / sizeof(DWORD));

	DWORD negOpcodes[] = {
		0xf7,
	};
	virtualizers.addVirtualizer((pfnVirtualize)VirtualizeNeg, negOpcodes, sizeof(negOpcodes) / sizeof(DWORD));

	DWORD cmpOpcodes[] = {
		0x39, 0x3b,
	};
	virtualizers.addVirtualizer((pfnVirtualize)VirtualizeCmp, cmpOpcodes, sizeof(cmpOpcodes) / sizeof(DWORD));


	/*
	CMP
	0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d
	*/

	virtualizers.print();
}


DWORD Virtualize(CodeChunk *code, void *addr, DWORD maxBytes) {
	srand(time(0)); // TODO: flytta in i separat funktion, använd WinAPI istället

	DISASM disasm;
	ZeroMemory(&disasm, sizeof(disasm));

	disasm.EIP = (UIntPtr)addr;

	disasm.VirtualAddr = code->getBaseVa();

	// Stats
	unsigned int virtualizedCount = 0;
	unsigned int nativeCount = 0;
	unsigned int totalInstructions = 0;

	unsigned int totalLen = 0;
	while (1) {
		disasm.SecurityBlock = 0;
		int instrLen = Disasm(&disasm);

		if (instrLen == -1) {
			logger.write(LOG_ERROR, "Disassembling failed\n");
			break;
		}

		// temp, break on NOP
		//if (disasm.Instruction.Opcode == 0x90) {
		//	break;
		//}

		
		if (maxBytes != 0 && (totalLen + instrLen > maxBytes)) {
			break;
		}

		totalInstructions++;
		disasm.SecurityBlock = instrLen; // TEMP

		//
		if (g_Settings.displayDisasm) {
			char hex[32];
			Utils::hexStr((BYTE*)disasm.EIP, instrLen, hex, sizeof(hex), 16, ' ');
			logger.write(LOG_MSG, "%08x %s | %s\n", (DWORD)disasm.VirtualAddr, hex, disasm.CompleteInstr);
		}
		// Attempt to virtualize
		if (virtualizers.virtualize(code, &disasm)) {
			virtualizedCount++;
		} else {
			// Create native handler for it
			//logger.write(LOG_MSG, "TEMP Native: [%s]\n", disasm.CompleteInstr);
			doNativeHandler(code, &disasm, (BYTE*)disasm.EIP, instrLen);
			nativeCount++;
		}
		//

		totalLen += instrLen;
		disasm.VirtualAddr += instrLen;
		disasm.EIP += instrLen;
	}

	logger.write(LOG_MSG,"%d bytes disassembled\n", totalLen);
	logger.write(LOG_MSG, "%d of %d instructions were virtualized (~%d%%)\n", virtualizedCount, totalInstructions, (int)(100 * (virtualizedCount / (float)totalInstructions)));

	return totalLen;
}
```

`chvrn_vm/x86.h`:

```h
#pragma once
#include "stdafx.h"
#include "CodeChunk.h"

void RegisterVirtualizers();
DWORD Virtualize(CodeChunk *code, void *addr, DWORD maxBytes);

extern int g_regCodes[8];
int getRegCode(int reg);
```

`chvrn_vm/x86Instruction.cpp`:

```cpp
#include "stdafx.h"
#include "x86Instruction.h"

x86Instruction::x86Instruction(DISASM *disasm) {
	m_opcode = disasm->Instruction.Opcode;
	m_virtualAddress = (DWORD)disasm->VirtualAddr;
	m_length = disasm->SecurityBlock;
	strncpy(m_string, disasm->CompleteInstr, 64);
	m_vaDependent = false;
}

x86Instruction::x86Instruction(DISASM *disasm, DWORD length, bool vaDependent) {
	m_opcode = disasm->Instruction.Opcode;
	m_virtualAddress = (DWORD)disasm->VirtualAddr;
	m_length = length;
	strncpy(m_string, disasm->CompleteInstr, 64);
	m_vaDependent = vaDependent;
}

DWORD x86Instruction::getOpcode() const {
	return m_opcode;
}

DWORD x86Instruction::getVirtualAddress() const {
	return m_virtualAddress;
}

DWORD x86Instruction::getLength() const {
	return m_length;
}

const char *x86Instruction::getString() const {
	return m_string;
}

bool x86Instruction::isVaDependent() const {
	return m_vaDependent;
}
```

`chvrn_vm/x86Instruction.h`:

```h
#pragma once
#include "stdafx.h"


class x86Instruction {
public:
	x86Instruction(DISASM *disasm);
	x86Instruction(DISASM *disasm, DWORD length, bool vaDependent);

	DWORD getOpcode() const;
	DWORD getVirtualAddress() const;
	DWORD getLength() const;
	const char *getString() const;
	bool isVaDependent() const;

private:
	DWORD m_opcode;
	DWORD m_virtualAddress;
	DWORD m_length;
	char m_string[64];
	bool m_vaDependent;
};
```

`chvrn_vm/x86vm.cpp`:

```cpp
#include "stdafx.h"
#include "settings.h"
#include "CodeChunk.h"
#include "Vm.h"
#include "Utils.h"
#include "registerswap.h"
#include "x86.h"
#include "x86vm.h"


BYTE getMod(BYTE opcode) {
	return (opcode & 0xc0) >> 6;
}

BYTE getReg(BYTE opcode) {
	return (opcode & 0x38) >> 3;
}

BYTE getRm(BYTE opcode) {
	return opcode & 0x07;
}

BYTE getMod(DISASM *disasm) {
	if (disasm->Prefix.Number == 0) {
		return getMod(*(BYTE*)(disasm->EIP + 1));
	}
	else {
		return getMod(*(BYTE*)(disasm->EIP + 2));
	}
}

BYTE getReg(DISASM *disasm) {
	if (disasm->Prefix.Number == 0) {
		return getReg(*(BYTE*)(disasm->EIP + 1));
	}
	else {
		return getReg(*(BYTE*)(disasm->EIP + 2));
	}
}

BYTE getRm(DISASM *disasm) {
	if (disasm->Prefix.Number == 0) {
		return getRm(*(BYTE*)(disasm->EIP + 1));
	}
	else {
		return getRm(*(BYTE*)(disasm->EIP + 2));
	}
}

const char *registerNames[] = { "EAX", "ECX", "EDX", "EBX", "ESP", "EBP", "ESI", "EDI" };
int getSingleRegister(Int32 regs) {
	if (regs & REG0)
		return 0;
	if (regs & REG1)
		return 1;
	if (regs & REG2)
		return 2;
	if (regs & REG3)
		return 3;
	if (regs & REG4)
		return 4;
	if (regs & REG5)
		return 5;
	if (regs & REG6)
		return 6;
	if (regs & REG7)
		return 7;
	return -1;
}

void doVmPopRemove(CodeChunk *code, DISASM *disasm) {
	code->addInstruction(VmInstruction(VmFile::VmPopRemove, g_InstructionNames[VmFile::VmPopRemove]), disasm);
}

void doVmReturn(CodeChunk *code, DISASM *disasm) {
	code->addInstruction(VmInstruction(VmFile::VmReturn, g_InstructionNames[VmFile::VmReturn]), disasm);
}

void doRebase(CodeChunk *code, DISASM *disasm) {
	code->addInstruction(VmInstruction(VmFile::VmRebase, g_InstructionNames[VmFile::VmRebase]), disasm);
}

void doNop(CodeChunk *code, DISASM *disasm) {
	code->addInstruction(VmInstruction(VmFile::Nop, g_InstructionNames[VmFile::Nop]), disasm);
}

// samma som popmem fast adressen finns på stacken och inte kodad i instruktionen
void doMove(CodeChunk *code, DISASM *disasm) {
	code->addInstruction(VmInstruction(VmFile::Move, g_InstructionNames[VmFile::Move]), disasm);
}

void doDeref(CodeChunk *code, DISASM *disasm) {
	code->addInstruction(VmInstruction(VmFile::Deref, g_InstructionNames[VmFile::Deref]), disasm);
}

void doNand(CodeChunk *code, DISASM *disasm) {
	code->addInstruction(VmInstruction(VmFile::Nand, g_InstructionNames[VmFile::Nand]), disasm);
}

// Stack operations
void doRepush(CodeChunk *code, DISASM *disasm) {
	code->addInstruction(VmInstruction(VmFile::VmRepush, g_InstructionNames[VmFile::VmRepush]), disasm);
}

void doNativeDispatch(CodeChunk *code, DISASM *disasm, BYTE *instr, DWORD length) {
	code->addInstruction(VmInstruction(VmFile::VmNativeDispatch, "native", instr, length), disasm);
}

void doNativeHandler(CodeChunk *code, DISASM *disasm, BYTE *instr, DWORD length) {
	BYTE buf[32];
	// pad with NOPs to align to 4 bytes
	DWORD alignedLength = Utils::roundUpMultiple(length, 4);

	buf[0] = (BYTE)alignedLength;	// first encode length
	memcpy(&buf[1], instr, length);	// then the native instruction

									// if length differed, add the alignment NOPs
	if (length < alignedLength) {
		memset(&buf[length + 1], 0x90, alignedLength - length);
	}

	code->addInstruction(VmInstruction(VmFile::VmNativeDispatch, "native", buf, 1 + alignedLength), disasm);
}

void doVmExit(CodeChunk *code, DISASM *disasm) {
	code->addInstruction(VmInstruction(VmFile::VmExit, g_InstructionNames[VmFile::VmExit]), disasm);
}

void _doVmPush(CodeChunk *code, DISASM *disasm, DWORD value) {
	code->addInstruction(VmInstruction(VmFile::VmPush, g_InstructionNames[VmFile::VmPush], value), disasm);
}

void doAdd(CodeChunk *code, DISASM *disasm) {
	code->addInstruction(VmInstruction(VmFile::Add, g_InstructionNames[VmFile::Add]), disasm);
}

void doSub(CodeChunk *code, DISASM *disasm) {
	code->addInstruction(VmInstruction(VmFile::Sub, g_InstructionNames[VmFile::Sub]), disasm);
}

void doVmAdd(CodeChunk *code, DISASM *disasm) {
	code->addInstruction(VmInstruction(VmFile::VmAdd, g_InstructionNames[VmFile::VmAdd]), disasm);
}

void doVmSub(CodeChunk *code, DISASM *disasm) {
	code->addInstruction(VmInstruction(VmFile::VmSub, g_InstructionNames[VmFile::VmSub]), disasm);
}

void doMul(CodeChunk *code, DISASM *disasm) {
	code->addInstruction(VmInstruction(VmFile::Mul, g_InstructionNames[VmFile::Mul]), disasm);
}

void doVmRebase(CodeChunk *code, DISASM *disasm) {
	code->addInstruction(VmInstruction(VmFile::VmRebase, g_InstructionNames[VmFile::VmRebase]), disasm);
}

// Constant obfuscation
void doObfVmPush(CodeChunk *code, DISASM *disasm, DWORD value) {
	
	if (value == 0) { 
		unsigned int val = rand();
		_doVmPush(code, disasm, value);
		return;
	}

	unsigned int d = rand() % value + 1;
	unsigned int q = value / d;
	unsigned int r = value - d*q;

	if (d == 1 || q == 1) {
		if (r == 0) {
			_doVmPush(code, disasm, value);
			return;
		}

		// add(d, r)
		_doVmPush(code, disasm, d);
		_doVmPush(code, disasm, r);
		doVmAdd(code, disasm);
	}
	else if (r == 0) {
		// mul(d, q)
		_doVmPush(code, disasm, d);
		_doVmPush(code, disasm, q);
		doMul(code, disasm);
	}
	else {
		// add(mul(d, q), r)
		_doVmPush(code, disasm, d);
		_doVmPush(code, disasm, q);
		doMul(code, disasm);
		_doVmPush(code, disasm, r);
		doVmAdd(code, disasm);
	}
}

void doVmPush(CodeChunk *code, DISASM *disasm, DWORD value) {
	void (*pfnPush)(CodeChunk *code, DISASM *disasm, DWORD value) = NULL;
	if (g_Settings.unfoldConstants) {
		pfnPush = &doObfVmPush;
	}
	else {
		pfnPush = &_doVmPush;
	}

	pfnPush(code, disasm, value);
}

void doPushDword(CodeChunk *code, DISASM *disasm) {
	code->addInstruction(VmInstruction(VmFile::PushDword, g_InstructionNames[VmFile::PushDword]), disasm);
}

void _doVmPushReg(CodeChunk *code, DISASM *disasm, BYTE reg) {
	code->addInstruction(VmInstruction(VmFile::VmPushReg, g_InstructionNames[VmFile::VmPushReg], reg), disasm);
}

void _doVmPopReg(CodeChunk *code, DISASM *disasm, BYTE reg) {
	code->addInstruction(VmInstruction(VmFile::VmPopReg, g_InstructionNames[VmFile::VmPopReg], reg), disasm);
}

void doVmPushReg(CodeChunk *code, DISASM *disasm, BYTE reg) {
	BYTE newReg = getRegisterCode(reg);
	_doVmPushReg(code, disasm, newReg);
}

void doVmPopReg(CodeChunk *code, DISASM *disasm, BYTE reg) {
	BYTE newReg = getRegisterCode(reg);
	_doVmPopReg(code, disasm, newReg);
}

void doPushReg(CodeChunk *code, DISASM *disasm, BYTE reg) {
	BYTE newReg = getRegisterCode(reg);
	code->addInstruction(VmInstruction(VmFile::PushReg, g_InstructionNames[VmFile::PushReg], reg), disasm);
}

void doPopReg(CodeChunk *code, DISASM *disasm, BYTE reg) {
	BYTE newReg = getRegisterCode(reg);
	code->addInstruction(VmInstruction(VmFile::PopReg, g_InstructionNames[VmFile::PopReg], reg), disasm);
}

void doPopMem(CodeChunk *code, DISASM *disasm, DWORD dest) {
	code->addInstruction(VmInstruction(VmFile::PopMem, g_InstructionNames[VmFile::PopMem], dest), disasm, true);
}

void doPushFlag(CodeChunk *code, DISASM *disasm, DWORD flag) {
	code->addInstruction(VmInstruction(VmFile::PushFlag, g_InstructionNames[VmFile::PushFlag], flag), disasm);
}

void doJumpRelCond(CodeChunk *code, DISASM *disasm, DWORD dest) {
	code->addInstruction(VmInstruction(VmFile::JumpRelCond, g_InstructionNames[VmFile::JumpRelCond], dest), disasm, true);
}

void doJumpAbs(CodeChunk *code, DISASM *disasm) {
	code->addInstruction(VmInstruction(VmFile::JumpAbs, g_InstructionNames[VmFile::JumpAbs]), disasm);
}

// only used as a helper by the VM, not to virtualize XOR
void doXor(CodeChunk *code, DISASM *disasm) {
	code->addInstruction(VmInstruction(VmFile::VmXor, g_InstructionNames[VmFile::VmXor]), disasm);
}

void doCallRel(CodeChunk *code, DISASM *disasm) {
	code->addInstruction(VmInstruction(VmFile::CallRel, g_InstructionNames[VmFile::CallRel]), disasm);
}

// calculate a value in scaled address form ([disp+base+index*scale]) and push onto stack
void pushCalculateScaledAddress(CodeChunk *code, DISASM *disasm, ARGTYPE *arg) {
	if ((arg->ArgType & MEMORY_TYPE) != 0) {
		if (arg->Memory.IndexRegister != 0) {
			doVmPushReg(code, disasm, getSingleRegister(arg->Memory.IndexRegister));
			doVmPush(code, disasm, arg->Memory.Scale);
			doMul(code, disasm);
		}
		if (arg->Memory.BaseRegister != 0) {
			doVmPushReg(code, disasm, getSingleRegister(arg->Memory.BaseRegister));
			if (arg->Memory.IndexRegister != 0) {
				doVmAdd(code, disasm);
			}
		}
		if (arg->Memory.Displacement != 0) {
			doVmPush(code, disasm, arg->Memory.Displacement);
			if (arg->Memory.Scale != 0 || arg->Memory.BaseRegister != 0) {
				doVmAdd(code, disasm);
			}
		}
	}
	else if ((arg->ArgType & CONSTANT_TYPE) != 0) {		
		DWORD imm;
		if (arg->ArgSize == 8) {
			imm = (Int8)disasm->Instruction.Immediat;
		}
		else {
			imm = (DWORD)disasm->Instruction.Immediat;
		}
		doVmPush(code, disasm, imm);
	}
	else if ((arg->ArgType & REGISTER_TYPE) != 0) {
		doVmPushReg(code, disasm, getSingleRegister(arg->ArgType));
	}
	else { // presumed to be NO_ARGUMENT
		logger.write(LOG_ERROR, "invalid argument in expected scaled address\n");
	}
}

```

`chvrn_vm/x86vm.h`:

```h
#pragma once
#include "stdafx.h"
#include "CodeChunk.h"
#include "x86Instruction.h"

void doVmPopRemove(CodeChunk *code, DISASM *disasm);
void doVmReturn(CodeChunk *code, DISASM *disasm);
void doNop(CodeChunk *code, DISASM *disasm);
void doMove(CodeChunk *code, DISASM *disasm);
void doDeref(CodeChunk *code, DISASM *disasm);
void doNand(CodeChunk *code, DISASM *disasm);
void doRepush(CodeChunk *code, DISASM *disasm);
void doNativeHandler(CodeChunk *code, DISASM *disasm, BYTE *instr, DWORD length);
void doVmExit(CodeChunk *code, DISASM *disasm);
void _doVmPush(CodeChunk *code, DISASM *disasm, DWORD value);
void doAdd(CodeChunk *code, DISASM *disasm);
void doSub(CodeChunk *code, DISASM *disasm);
void doMul(CodeChunk *code, DISASM *disasm);
void doVmRebase(CodeChunk *code, DISASM *disasm);
void doVmPush(CodeChunk *code, DISASM *disasm, DWORD value);
void doPushDword(CodeChunk *code, DISASM *disasm);
void _doVmPushReg(CodeChunk *code, DISASM *disasm, BYTE reg);
void _doVmPopReg(CodeChunk *code, DISASM *disasm, BYTE reg);
void doVmPushReg(CodeChunk *code, DISASM *disasm, BYTE reg);
void doVmPopReg(CodeChunk *code, DISASM *disasm, BYTE reg);
void doPushReg(CodeChunk *code, DISASM *disasm, BYTE reg);
void doPopReg(CodeChunk *code, DISASM *disasm, BYTE reg);
void doPopMem(CodeChunk *code, DISASM *disasm, DWORD dest);
void doPushFlag(CodeChunk *code, DISASM *disasm, DWORD flag);
void doJumpRelCond(CodeChunk *code, DISASM *disasm, DWORD dest);
void doJumpAbs(CodeChunk *code, DISASM *disasm);
void doXor(CodeChunk *code, DISASM *disasm);	
void doCallRel(CodeChunk *code, DISASM *disasm);

// Helper functions
BYTE getMod(BYTE opcode);
BYTE getReg(BYTE opcode);
BYTE getRm(BYTE opcode);
BYTE getMod(DISASM *disasm);
BYTE getReg(DISASM *disasm);
BYTE getRm(DISASM *disasm);

int getSingleRegister(Int32 regs);
void pushCalculateScaledAddress(CodeChunk *code, DISASM *disasm, ARGTYPE *arg);

namespace Flags {
	enum {
		CF = 1 << 0,
		Reserved1 = 1 << 1,
		PF = 1 << 2,
		Reserved2 = 1 << 3,
		AF = 1 << 4,
		Reserved3 = 1 << 5,
		ZF = 1 << 6,
		SF = 1 << 7,
		TF = 1 << 8,
		IF = 1 << 9,
		DF = 1 << 10,
		OF = 1 << 11,
		IOPL = 1 << 12,
		IOPL2 = 1 << 13,
		NT = 1 << 14,
		Reserved4 = 1 << 15,
	};
};

extern const char *registerNames[];
```

`example.md`:

```md
#### Example program
```c++
#include "stdafx.h"
#include "phant.h"

DWORD hashFile(const char *filename) {
	BeginProtect;

	HANDLE file = CreateFileA(filename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	
	DWORD hash = 0;
	if (file == INVALID_HANDLE_VALUE) {
		printf("could not open file for reading (error: %d)\n", GetLastError());
		return 0;
	}
	else {

		DWORD fileSize = GetFileSize(file, NULL);

		DWORD buf = 0;
		DWORD numRead;

		hash = 0x811c9dc5;
		while (ReadFile(file, &buf, sizeof(buf), &numRead, NULL)) {
			if (!numRead) {
				break;
			}
			hash = (hash ^ buf) * 0x1000193;
			buf = 0;
		}
		CloseHandle(file);

	}

	EndProtect;

	return hash;
}

int main(int argc, const char *argv[])
{
	BeginProtect;

	if (argc != 2) {
		printf("no filename specified\n");
		return 1;
	}

	DWORD hash = hashFile(argv[1]);
	printf("result: 0x%08x\n", hash);

	EndProtect;

    return 0;
}
```

The disassembly of the hashFile function looks like so:
```
CPU Disasm
Address   Hex dump          Command                                  Comments
00401B90  /$  55            PUSH EBP                                 ; UINT sdk_example_two.hashFile(void)
00401B91  |.  8BEC          MOV EBP,ESP
00401B93  |.  83EC 0C       SUB ESP,0C
00401B96  |.  A1 F8404000   MOV EAX,DWORD PTR DS:[__security_cookie]
00401B9B  |.  33C5          XOR EAX,EBP
00401B9D  |.  8945 FC       MOV DWORD PTR SS:[LOCAL.1],EAX
00401BA0  |.  53            PUSH EBX
00401BA1  |.  56            PUSH ESI
00401BA2  |.  57            PUSH EDI
00401BA3  |.  8BF1          MOV ESI,ECX
00401BA5  |.  68 5720F1B1   PUSH B1F12057                            ; /Arg1 = B1F12057
00401BAA  |.  E8 59F4FFFF   CALL _BeginProtect@4                     ; \sdk_example_two._BeginProtect@4
00401BAF  |.  6A 00         PUSH 0                                   ; /hTemplate = NULL
00401BB1  |.  68 80000000   PUSH 80                                  ; |Attributes = FILE_ATTRIBUTE_NORMAL
00401BB6  |.  6A 03         PUSH 3                                   ; |CreationDistribution = OPEN_EXISTING
00401BB8  |.  6A 00         PUSH 0                                   ; |pSecurity = NULL
00401BBA  |.  6A 01         PUSH 1                                   ; |ShareMode = FILE_SHARE_READ
00401BBC  |.  68 00000080   PUSH 80000000                            ; |DesiredAccess = GENERIC_READ
00401BC1  |.  56            PUSH ESI                                 ; |FileName => ARG.ECX
00401BC2  |.  FF15 00304000 CALL DWORD PTR DS:[<&KERNEL32.CreateFile ; \KERNEL32.CreateFileA
00401BC8  |.  8BF0          MOV ESI,EAX
00401BCA  |.  83FE FF       CMP ESI,-1
00401BCD  |.  75 27         JNE SHORT 00401BF6
00401BCF  |.  FF15 04304000 CALL DWORD PTR DS:[<&KERNEL32.GetLastErr ; [KERNEL32.GetLastError
00401BD5  |.  50            PUSH EAX
00401BD6  |.  68 28314000   PUSH OFFSET 00403128                     ; /_Format = "could not open file for reading (error: %d)\n"
00401BDB  |.  E8 00010000   CALL printf                              ; \printf
00401BE0  |.  83C4 08       ADD ESP,8
00401BE3  |.  33C0          XOR EAX,EAX
00401BE5  |.  5F            POP EDI
00401BE6  |.  5E            POP ESI
00401BE7  |.  5B            POP EBX
00401BE8  |.  8B4D FC       MOV ECX,DWORD PTR SS:[LOCAL.1]
00401BEB  |.  33CD          XOR ECX,EBP
00401BED  |.  E8 1E010000   CALL __security_check_cookie             ; [__security_check_cookie
00401BF2  |.  8BE5          MOV ESP,EBP
00401BF4  |.  5D            POP EBP
00401BF5  |.  C3            RETN
00401BF6  |>  6A 00         PUSH 0                                   ; /SizeHigh = NULL
00401BF8  |.  56            PUSH ESI                                 ; |hFile
00401BF9  |.  FF15 08304000 CALL DWORD PTR DS:[<&KERNEL32.GetFileSiz ; \KERNEL32.GetFileSize
00401BFF  |.  8B1D 0C304000 MOV EBX,DWORD PTR DS:[<&KERNEL32.ReadFil ; Jump to KERNELBASE.ReadFile
00401C05  |.  8D45 F4       LEA EAX,[LOCAL.3]
00401C08  |.  6A 00         PUSH 0                                   ; /pOverlapped = NULL
00401C0A  |.  50            PUSH EAX                                 ; |pBytesRead => OFFSET LOCAL.3
00401C0B  |.  6A 04         PUSH 4                                   ; |Size = 4
00401C0D  |.  8D45 F8       LEA EAX,[LOCAL.2]                        ; |
00401C10  |.  C745 F8 00000 MOV DWORD PTR SS:[LOCAL.2],0             ; |
00401C17  |.  50            PUSH EAX                                 ; |Buffer => OFFSET LOCAL.2
00401C18  |.  56            PUSH ESI                                 ; |hFile
00401C19  |.  BF C59D1C81   MOV EDI,811C9DC5                         ; |
00401C1E  |.  FFD3          CALL EBX                                 ; \KERNEL32.ReadFile
00401C20  |.  85C0          TEST EAX,EAX
00401C22  |.  74 2B         JZ SHORT 00401C4F
00401C24  |>  837D F4 00    /CMP DWORD PTR SS:[LOCAL.3],0
00401C28  |.  74 25         |JE SHORT 00401C4F
00401C2A  |.  8B45 F8       |MOV EAX,DWORD PTR SS:[LOCAL.2]
00401C2D  |.  33C7          |XOR EAX,EDI
00401C2F  |.  C745 F8 00000 |MOV DWORD PTR SS:[LOCAL.2],0
00401C36  |.  6A 00         |PUSH 0                                  ; /pOverlapped = NULL
00401C38  |.  69F8 93010001 |IMUL EDI,EAX,1000193                    ; |
00401C3E  |.  8D45 F4       |LEA EAX,[LOCAL.3]                       ; |
00401C41  |.  50            |PUSH EAX                                ; |pBytesRead => OFFSET LOCAL.3
00401C42  |.  6A 04         |PUSH 4                                  ; |Size = 4
00401C44  |.  8D45 F8       |LEA EAX,[LOCAL.2]                       ; |
00401C47  |.  50            |PUSH EAX                                ; |Buffer => OFFSET LOCAL.2
00401C48  |.  56            |PUSH ESI                                ; |hFile
00401C49  |.  FFD3          |CALL EBX                                ; \KERNEL32.ReadFile
00401C4B  |.  85C0          |TEST EAX,EAX
00401C4D  |.^ 75 D5         \JNZ SHORT 00401C24
00401C4F  |>  56            PUSH ESI                                 ; /hObject
00401C50  |.  FF15 10304000 CALL DWORD PTR DS:[<&KERNEL32.CloseHandl ; \KERNEL32.CloseHandle
00401C56  |.  68 B1F12057   PUSH 5720F1B1                            ; /Arg1 = 5720F1B1
00401C5B  |.  E8 A5F3FFFF   CALL _EndProtect@4                       ; \sdk_example_two._EndProtect@4
00401C60  |.  8B4D FC       MOV ECX,DWORD PTR SS:[LOCAL.1]
00401C63  |.  8BC7          MOV EAX,EDI
00401C65  |.  33CD          XOR ECX,EBP
00401C67  |.  5F            POP EDI
00401C68  |.  5E            POP ESI
00401C69  |.  5B            POP EBX
00401C6A  |.  E8 A1000000   CALL __security_check_cookie             ; [__security_check_cookie
00401C6F  |.  8BE5          MOV ESP,EBP
00401C71  |.  5D            POP EBP
00401C72  \.  C3            RETN
```

### Output
The generated bytecode for the hashFile function is:
```
VmPush 00000000
PushDword
VmPush 0000003e
VmPush 00000002
Mul
VmPush 00000004
VmAdd
PushDword
VmPush 00000002
VmPush 00000001
VmAdd
PushDword
VmPush 00000000
PushDword
VmPush 00000001
PushDword
VmPush 00002745
VmPush 00034270
Mul
VmPush 000007d0
VmAdd
PushDword
PushReg 06
native
VmPushReg 00
VmPopReg 06
VmPush 00004089
VmPush 0003f782
Mul
VmPush 00000b6d
VmAdd
VmPushReg 06
Sub
VmPopRemove
PushFlag 00000040
VmPush 00000036
VmPush 0000000a
VmAdd
Xor
JumpRelCond 00000093
native
PushReg 00
VmPush 00005d36
VmPush 000000b0
Mul
VmPush 00001c08
VmAdd
PushDword
native
VmPush 00000008
VmPushReg 04
Add
VmPopReg 04
VmPushReg 00
VmPushReg 00
Nand
VmPushReg 00
Nand
VmPushReg 00
VmPushReg 00
Nand
VmPushReg 00
Nand
Nand
VmPopReg 00
PopReg 07
PopReg 06
PopReg 03
VmPushReg 05
VmPush 0000161f
VmPush 000b929a
Mul
VmPush 00000356
VmAdd
VmAdd
Deref
VmPopReg 01
VmPushReg 01
VmPushReg 05
Nand
VmPushReg 01
Nand
VmPushReg 01
VmPushReg 05
Nand
VmPushReg 05
Nand
Nand
VmPopReg 01
native
VmPushReg 05
VmPopReg 04
PopReg 05
VmPush 00000000
VmReturn
VmPush 00000000
PushDword
PushReg 06
native
VmPush 00000a21
VmPush 00000656
Mul
VmPush 000002f6
VmAdd
Deref
VmPopReg 03
VmPushReg 05
VmPush 0000268f
VmPush 0006a3a5
Mul
VmPush 000018c9
VmAdd
VmAdd
VmPopReg 00
VmPush 00000000
PushDword
PushReg 00
VmPush 00000003
VmPush 00000001
VmAdd
PushDword
VmPushReg 05
VmPush 00000f31
VmPush 0010da04
Mul
VmPush 00000934
VmAdd
VmAdd
VmPopReg 00
VmPush 00000000
VmPushReg 05
VmPush 000015f5
VmPush 000ba8bd
Mul
VmPush 00000217
VmAdd
VmAdd
Move
PushReg 00
PushReg 06
VmPush 0000354e
VmPush 00026c11
Mul
VmPush 00002b97
VmAdd
VmPopReg 07
native
native
PushFlag 00000040
JumpRelCond 000000e0
VmPush 00000000
VmPushReg 05
VmPush 00002dd2
VmPush 00059648
Mul
VmPush 000010e4
VmAdd
VmAdd
Deref
Sub
VmPopRemove
PushFlag 00000040
JumpRelCond 000000ba
VmPushReg 05
VmPush 00001108
VmPush 000f07fc
Mul
VmPush 00000418
VmAdd
VmAdd
Deref
VmPopReg 00
VmPushReg 00
VmPushReg 07
Nand
VmPushReg 00
Nand
VmPushReg 00
VmPushReg 07
Nand
VmPushReg 07
Nand
Nand
VmPopReg 00
VmPush 00000000
VmPushReg 05
VmPush 000075a1
VmPush 00022d24
Mul
VmPush 00002854
VmAdd
VmAdd
Move
VmPush 00000000
PushDword
native
VmPushReg 05
VmPush 00000538
VmPush 00310dcb
Mul
VmPush 0000048c
VmAdd
VmAdd
VmPopReg 00
PushReg 00
VmPush 00000002
VmPush 00000002
Mul
PushDword
VmPushReg 05
VmPush 00002fdc
VmPush 00055958
Mul
VmPush 00001058
VmAdd
VmAdd
VmPopReg 00
PushReg 00
PushReg 06
native
native
PushFlag 00000040
VmPush 0000000c
VmPush 00000005
Mul
VmPush 00000004
VmAdd
Xor
JumpRelCond ffffff20
PushReg 06
native
VmPush 00005b14
VmPush 000000b4
Mul
VmPush 000011a9
VmAdd
VmExit
```
```

`libphant/ReadMe.txt`:

```txt
"Dummy" project to add the VM obj to a lib file
```

`libphant_debug/ReadMe.txt`:

```txt
"Dummy" project to add the VM obj to a lib file
```

`sdk_example/phant.h`:

```h
#pragma once
#pragma comment(lib, "../Release/libphant.lib")

extern "C" {
	void __stdcall BeginProtect(unsigned int);
	void __stdcall EndProtect(unsigned int);
}

//BeginProtect(0xb1f12057)
//EndProtect(0x5720f1b1);
#define BeginProtect __asm {\
	__asm push 0xb1f12057\
	__asm call BeginProtect\
}
#define EndProtect __asm {\
	__asm push 0x5720f1b1\
	__asm call EndProtect\
}
```

`sdk_example/sdk_example.cpp`:

```cpp
// sdk_example.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "phant.h"

__forceinline unsigned int fnv32(unsigned char *data, unsigned int size) {
	unsigned int hash = 0x0ce942fa;
	for (unsigned int i = 0; i < size; i++) {
		hash *= 0x01000193;
		hash ^= data[i];
	}
	return hash;
}

/*
	Suggested solution:
	BP the VM IP and observe the control flow for a clean run vs. patched run,
	this lets you find the good conditional jumps. 
	Patch the first DWORD to make the bad jump land at the destination of the last good jump.
*/
int main() 
{
	BeginProtect;
	char buffer[MAX_PATH];
	printf("Enter a string:\n");
	scanf_s("%s", buffer);

	const char *caption = "Evaluation expired";
	const char *text = "Please register the software";

	__asm {
		mov dword ptr[esp - 32], 0x38af1fad	// bad cookie #1
			push esp
			mov dword ptr[esp - 52 + 4], 0x38af1fad	// bad cookie #2
			push MB_OK
			push caption
			push text
			push NULL
			xor dword ptr[esp - 32 + 4 + 16], 0x7f338f5d	// => 479c90f0
			call dword ptr[MessageBoxA]
			pop eax
			xor eax, esp
			jnz do_nothing
			mov eax, dword ptr[esp - 68 - 4]
			mov ebx, caption
			xor eax, ebx
			jnz do_nothing
			mov eax, dword ptr[esp - 32]
			xor eax, 0x479c90f0
			jnz second_check
		access_violation :
			mov dword ptr ds : [0x40100], 0
			second_check :
			mov eax, dword ptr[esp - 52]
			xor eax, 0x38af1fad
			jz do_nothing
	}

	printf("Hash: 0x%x\n", fnv32((unsigned char*)buffer, strlen(buffer)));

do_nothing:
	printf("Done.\n");

	EndProtect;
	
	return 0;
}


```

`sdk_example/stdafx.cpp`:

```cpp
// stdafx.cpp : source file that includes just the standard includes
// sdk_example.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

```

`sdk_example/stdafx.h`:

```h
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#include "targetver.h"

#include <stdio.h>
#include <tchar.h>



// TODO: reference additional headers your program requires here
#include <Windows.h>
```

`sdk_example/targetver.h`:

```h
#pragma once

// Including SDKDDKVer.h defines the highest available Windows platform.

// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.

#include <SDKDDKVer.h>

```

`sdk_example_two/phant.h`:

```h
#pragma once
#pragma comment(lib, "../Release/libphant.lib")

extern "C" {
	void __stdcall BeginProtect(unsigned int);
	void __stdcall EndProtect(unsigned int);
}

//BeginProtect(0xb1f12057)
//EndProtect(0x5720f1b1);
#define BeginProtect __asm {\
	__asm push 0xb1f12057\
	__asm call BeginProtect\
}
#define EndProtect __asm {\
	__asm push 0x5720f1b1\
	__asm call EndProtect\
}
```

`sdk_example_two/sdk_example_two.cpp`:

```cpp
// sdk_example_two.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "phant.h"

DWORD hashFile(const char *filename) {
	BeginProtect;

	HANDLE file = CreateFileA(filename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	
	DWORD hash = 0;
	if (file == INVALID_HANDLE_VALUE) {
		printf("could not open file for reading (error: %d)\n", GetLastError());
		return 0;
	}
	else {

		DWORD fileSize = GetFileSize(file, NULL);

		DWORD buf = 0;
		DWORD numRead;

		hash = 0x811c9dc5;
		while (ReadFile(file, &buf, sizeof(buf), &numRead, NULL)) {
			if (!numRead) {
				break;
			}
			hash = (hash ^ buf) * 0x1000193;
			buf = 0;
		}
		CloseHandle(file);

	}

	EndProtect;

	return hash;
}


int main(int argc, const char *argv[])
{
	BeginProtect;

	if (argc != 2) {
		printf("no filename specified\n");
		return 1;
	}

	DWORD hash = hashFile(argv[1]);
	printf("result: 0x%08x\n", hash);

	EndProtect;

    return 0;
}


```

`sdk_example_two/stdafx.cpp`:

```cpp
// stdafx.cpp : source file that includes just the standard includes
// sdk_example_two.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

```

`sdk_example_two/stdafx.h`:

```h
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#include "targetver.h"

#include <stdio.h>
#include <tchar.h>



// TODO: reference additional headers your program requires here
#include <Windows.h>
```

`sdk_example_two/targetver.h`:

```h
#pragma once

// Including SDKDDKVer.h defines the highest available Windows platform.

// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.

#include <SDKDDKVer.h>

```

`vm/libphant.asm`:

```asm
format MS COFF

include 'INCLUDE/win32a.inc'

extrn '__imp__VirtualAlloc@16' as VirtualAlloc:dword
extrn '__imp__VirtualFree@12' as VirtualFree:dword
extrn '__imp__GetModuleHandleA@4' as GetModuleHandleA:dword

public GetBuild as "_GetBuild@0"
public BeginProtect as "_BeginProtect@4"
public EndProtect as "_EndProtect@4"
	
section '.data' data readable writeable
begin_data:
; VM header table
vm_header:
; signatures (used to find the VM)
dd 0xb0fa3d74								; VM signature 1
dd 0xa53bcf98								; VM signature 2
dd 0xee02930e								; VM signature 3
dd 0										; VM major version
dd 2										; VM minor version
; --------------------------------
; File header
; --------------------------------
VM_FILEHEADER:
VM_FILEHEADER_BASE:
dd 0
VM_FILEHEADER_VA_TABLE:
dd 0
VM_FILEHEADER_VA_TABLE_VALUES:
dd 0
; --------------------------------
dd vm_code_start							; VM base
dd vm_code_end-vm_code_start				; VM total size
dd vm_init-vm_code_start					; Init offset
dd vm_fetch_decode-vm_code_start			; Fetch decode offset
dd vm_reenter-vm_code_start					; Reenter offset
dd vm_exit-vm_code_start					; Exit offset
dd vm_virtualalloc_patch_location_1+2-vm_code_start	; VirtualAlloc patch offset 1
dd vm_virtualalloc_patch_location_2+2-vm_code_start	; VirtualAlloc patch offset 2
dd vm_virtualfree_patch_location_1+2-vm_code_start	; VirtualFree patch offset 1
dd vm_virtualfree_patch_location_2+2-vm_code_start	; VirtualFree patch offset 2
dd vm_handlers_patch_instruction+1-vm_code_start	; Handlers patch location
dd vm_reenter_patch_location+1-vm_code_start
dd vm_exit_patch_location+1-vm_code_start
dd vm_exit_native-vm_code_start
dd vm_va_table_patch_location+1-vm_code_start
dd vm_va_table_values_patch_location+1-vm_code_start
dd vm_handlers
dd VM_HANDLER_COUNT
dd BeginProtect-vm_code_start
dd EndProtect-vm_code_start
; End

build_id:
dq 0x1450902833

_code:
dd 0
db 1 ; exit

; ================ Handlers ================
VM_HANDLER_COUNT = 28
vm_handlers:
dd vm_native_dispatch				; 0
dd vm_exit							; 1
dd vm_push							; 2
dd vm_repush
dd vm_push_reg						; 3
dd _push_dword						; 4
dd vm_pop_reg							; 5
dd _push_flag 						; 6
dd _move							; 7
dd _nand							; 8
dd _jump_rel						; 9
dd _jump_abs						; 10
dd _jump_rel_cond					; 11
dd 0 								; popmem, 12
dd _deref 							; deref, 13
dd _add 							; add, 14
dd _sub								; sub, 15
dd _mul 							; mul, 16
dd _xor								; xor, 17
dd _call_rel
dd _nop
dd vm_rebase						;
dd vm_retn
dd vm_pop_remove
dd vm_add
dd vm_sub
dd _push_reg
dd _pop_reg
dd 0
; ========================================

section '.text' code readable executable
text_start:
; VM context structure as pointed to through the context register
CONTEXT_VM_ESP			= 0
CONTEXT_FLAGS			= CONTEXT_VM_ESP		+ 4
CONTEXT_EDI				= CONTEXT_FLAGS			+ 4
CONTEXT_ESI				= CONTEXT_EDI			+ 4
CONTEXT_EBP				= CONTEXT_ESI			+ 4
CONTEXT_ESP				= CONTEXT_EBP			+ 4		
CONTEXT_EBX				= CONTEXT_ESP			+ 4		; do not use, use CONTEXT_NATIVE_ESP instead
CONTEXT_EDX				= CONTEXT_EBX			+ 4
CONTEXT_ECX				= CONTEXT_EDX			+ 4
CONTEXT_EAX				= CONTEXT_ECX			+ 4
CONTEXT_NATIVE_ESP		= CONTEXT_EAX			+ 4
CONTEXT_SCRATCH			= CONTEXT_NATIVE_ESP	+ 4

CONTEXT_SIZE = 0x30

; Stack size
VM_SCRATCH_SIZE	=	0x100
VM_STACK_SIZE	=	0x4000


vm_code_start:
GetBuild:
	mov eax, build_id
EndProtect:
	retn 4
BeginProtect:
	retn 4
vm_init:
; begin_obfuscate
; begin_shuffle
	lea esp, [esp+4]	; throw away the return value from the BeginProtect call
	pushad
	pushfd
	; Allocate scratch space
	push 0x40						; protection: PAGE_EXECUTE_READWRITE
	push 0x1000						; allocation: MEM_COMMIT
	push VM_SCRATCH_SIZE			; allocation size
	push 0							; desired address
vm_virtualalloc_patch_location_1:
	call dword [VirtualAlloc]
	push eax
	
	; Allocate stack
	push 0x04						; protection: PAGE_READWRITE
	push 0x1000						; allocation: MEM_COMMIT
	push VM_STACK_SIZE				; allocation size
	push 0							; desired address
vm_virtualalloc_patch_location_2:
	call dword [VirtualAlloc]

	add eax, VM_STACK_SIZE
	
	pop ebx						; VM scratch 
	
	; Copy flags and registers to VM stack
	pop dword [eax-0x2c]		; registers
	pop dword [eax-0x28]		
	pop dword [eax-0x24]
	pop dword [eax-0x20]
	pop dword [eax-0x1c]
	pop dword [eax-0x18]
	pop dword [eax-0x14]
	pop dword [eax-0x10]
	pop dword [eax-0x0c]		; flags
	
	pop edx						; VM IP
; end_obfuscate
	mov dword [eax-0x08], esp
; begin_obfuscate
	mov dword [eax-0x04], ebx	; VM scratch
	sub eax, CONTEXT_SIZE
	mov dword [eax], eax		; VM ESP
	mov ebx, eax
	mov esp, eax
	
	; Save current base address
	push 0
	call dword [GetModuleHandleA]
	mov dword [VM_FILEHEADER_BASE], eax
	add edx, eax	; add image base to VM IP
	
	jmp vm_fetch_decode
vm_native_dispatch:
	;int3
	mov eax, [ebx+CONTEXT_SCRATCH]
	mov ecx, [edx]
	inc edx
	and ecx, 0xff	; length
	xor esi,esi
	@@:
	cmp ecx,esi
	je @f
	push dword [edx+esi]
	pop dword [eax+esi]
	add esi,4
	jmp @b
	@@:
	add edx, ecx	; increase VM IP
	
	push edx
	push ebx
	
	; Save VM ESP at this state (don't push anything past this point)
; end_obfuscate
	mov dword [ebx+CONTEXT_VM_ESP], esp
; begin_obfuscate
	lea edi, [ebx+CONTEXT_NATIVE_ESP]
	
	; Add mov [<VM context>], esp
	mov dword [eax+esi+0], 0x25899090
	mov dword [eax+esi+4], edi
	
	add esi, 8
	
	; Add mov esp, <VM context> at end of code
	mov dword [eax+esi+0], 0xbc909090
	mov [eax+esi+4], edi
	add esi, 8
	
	; Add jump at end of code
	; (jmp  = vm_reenter - scratch - esi - 5)
	mov dword [eax+esi], 0xe9909090
	add esi, 4
vm_reenter_patch_location:
	mov edi, vm_reenter
	sub edi, eax
	sub edi, esi
	sub edi, 4
	mov dword [eax+esi], edi
	mov ecx, [ebx+CONTEXT_SCRATCH]
	push ecx
vm_native_dispatch_2:
	; Push address onto native stack
	pop ecx
	sub dword [ebx+CONTEXT_NATIVE_ESP], 4
	mov eax, [ebx+CONTEXT_NATIVE_ESP]
	mov [eax], ecx
; end_obfuscate
	lea esp, [ebx+CONTEXT_FLAGS]	; since we want offset 0, otherwise use lea
	popfd
	popad
	pop esp	
	retn
vm_reenter:
	pushad
	pushfd
	sub esp, 4
	pop esp
	pop ebx
	pop edx
	mov dword [ebx+CONTEXT_VM_ESP], esp	; update VM ESP (removing the pushed dispatched address etc.)
	jmp vm_fetch_decode
; begin_obfuscate
vm_exit:
	; Push the VM exit operand onto the native stack 
	sub dword [ebx+CONTEXT_NATIVE_ESP], 12
	mov eax, [ebx+CONTEXT_NATIVE_ESP]
		
	push dword [ebx+CONTEXT_SCRATCH]
	
	mov dword [eax+0], ebx				; move context pointer to native stack
	pop dword [eax+4]					; move scratch pointer to native stack
	pop dword [eax+8]					; vm exit return value?
vm_exit_patch_location:
	push vm_exit_native
	jmp vm_native_dispatch_2
vm_exit_native:
	pushad							;
	pushfd							; subtracts 36 from ESP
	
	push 0x8000						; free type: MEM_RELEASE
	push 0							; memory size
	push dword [esp+36+4+4]			; pointer to memory
vm_virtualfree_patch_location_1:
	call dword [VirtualFree]
	
	push 0x8000						; free type: MEM_RELEASE
	push 0							; memory size
	push dword [esp+40+4+4]			; pointer to memory
vm_virtualfree_patch_location_2:
	call dword [VirtualFree]
	
	popfd
	popad
	
	lea esp, [esp+8]				; remove the two VirtualFree addresses
	
	retn ; jump to vm_exit operand
vm_fetch_decode:
	mov eax, [edx]
	and eax, 0xff
	imul eax, 4
	inc edx
vm_handlers_patch_instruction:
	mov ebp, vm_handlers
	jmp dword [ebp+eax]
vm_int3:	; (used to inspect the native state by dispatching to this as a handler)
	int3
	jmp vm_fetch_decode
vm_retn:
	pop eax
	add eax, 4
	mov ecx, [ebx+CONTEXT_NATIVE_ESP]
	push dword [ecx]
	add dword [ebx+CONTEXT_NATIVE_ESP], eax
	jmp vm_exit
vm_push:
	push dword [edx]
	add edx, 4
	jmp vm_fetch_decode
vm_pop_remove:
	lea esp, [esp+4]
	jmp vm_fetch_decode
_push_dword:
	;int3
	sub dword [ebx+CONTEXT_NATIVE_ESP], 4
	mov eax, [ebx+CONTEXT_NATIVE_ESP]
	pop dword [eax]
	jmp vm_fetch_decode
vm_repush:
	push dword [esp+00]
	jmp vm_fetch_decode
vm_push_reg:
	;int3
	mov eax, [edx]
	inc edx
	and eax, 0xff
	cmp eax, 4
	jne @f
	push dword [ebx+CONTEXT_NATIVE_ESP]		; special case for now
	jmp vm_fetch_decode
	@@:
	neg eax
	shl eax, 2
	push dword [ebx+CONTEXT_EAX+eax]
	jmp vm_fetch_decode
vm_pop_reg:
	;int3
	mov eax, [edx]
	inc edx
	and eax, 0xff
	cmp eax, 4
	jne @f
	pop dword [ebx+CONTEXT_NATIVE_ESP]		; special case for now
	jmp vm_fetch_decode
	@@:
	neg eax
	shl eax, 2
	pop dword [ebx+CONTEXT_EAX+eax]
	jmp vm_fetch_decode
_push_reg:
	;int3
	mov eax, [edx]
	inc edx
	and eax, 0xff
	sub dword [ebx+CONTEXT_NATIVE_ESP], 4
	mov ecx, [ebx+CONTEXT_NATIVE_ESP]
	cmp eax, 4
	jne @f
	push dword [ebx+CONTEXT_NATIVE_ESP]		; special case for now
	pop dword [ecx]
	jmp vm_fetch_decode
	@@:
	neg eax
	shl eax, 2
	push dword [ebx+CONTEXT_EAX+eax]
	pop dword [ecx]
	jmp vm_fetch_decode
_pop_reg:
	;int3
	mov eax, [edx]
	inc edx
	and eax, 0xff
	mov ecx, [ebx+CONTEXT_NATIVE_ESP]
	mov ecx, [ecx]
	cmp eax, 4
	jne @f
	mov [ebx+CONTEXT_NATIVE_ESP], ecx		; special case for now
	add dword [ebx+CONTEXT_NATIVE_ESP], 4
	jmp vm_fetch_decode
	@@:
	neg eax
	shl eax, 2
	mov [ebx+CONTEXT_EAX+eax], ecx
	add dword [ebx+CONTEXT_NATIVE_ESP], 4
	jmp vm_fetch_decode
_move:
	pop eax
	pop dword [eax]
	jmp vm_fetch_decode
_nand:
	pop eax
	pop ecx
	push dword [ebx+CONTEXT_FLAGS]
	popf
	and eax, ecx
	not eax
	and eax, 0xffffffff; hack to update flags according to NOT result (prior state not needed)
	pushf
	pop dword [ebx+CONTEXT_FLAGS]
	push eax
	jmp vm_fetch_decode
_jump_rel_cond:
	pop eax
	cmp eax, 0
	jnz _jump_rel
	add edx, 4
	jmp vm_fetch_decode
_jump_rel:
	;int3
	nop
	nop
	nop
	mov eax, [edx]
	add edx, 4
	add edx, eax
	jmp vm_fetch_decode
_jump_abs:
	pop eax
vm_va_table_patch_location:
	mov ecx, [VM_FILEHEADER_VA_TABLE]
vm_va_table_values_patch_location:
	mov edx, [VM_FILEHEADER_VA_TABLE_VALUES]
	mov esi, ecx
	@@:
	cmp dword [esi], -1
	je no_va_found
	cmp [esi], eax
	je @f
	add esi, 4
	jmp @b
	@@:
	sub esi, ecx
	mov edi, [edx + esi]
	add edi, [VM_FILEHEADER_BASE]
	; and that the jump does not lead out of a virtualized chunk
	mov edx, edi
	jmp vm_fetch_decode
vm_rebase:
	mov eax, [VM_FILEHEADER_BASE]
	add [esp], eax
	jmp vm_fetch_decode
no_va_found:
	mov edx, eax	; use original VA
	jmp vm_fetch_decode
_push_flag:
	mov eax, [edx]
	add edx, 4
	mov ecx, [ebx+CONTEXT_FLAGS]
	and eax, ecx
	push eax
	jmp vm_fetch_decode
_deref:
	pop eax
	push dword [eax]
	jmp vm_fetch_decode
vm_add:
	pop eax
	pop ecx
	add eax, ecx
	push eax
	jmp vm_fetch_decode
vm_sub:
	pop eax
	pop ecx
	sub eax, ecx
	push eax
	jmp vm_fetch_decode
_add:
	pop eax
	pop ecx
	push dword [ebx+CONTEXT_FLAGS]
	popf
	add eax, ecx
	pushf
	pop dword [ebx+CONTEXT_FLAGS]
	push eax
	jmp vm_fetch_decode
_sub:
	pop eax
	pop ecx
	push dword [ebx+CONTEXT_FLAGS]
	popf
	sub eax, ecx
	pushf
	pop dword [ebx+CONTEXT_FLAGS]
	push eax
	jmp vm_fetch_decode
_mul:
	pop eax
	pop ecx
	imul eax, ecx
	push eax
	jmp vm_fetch_decode
_xor:	; no flags...
	pop eax
	pop ecx
	xor eax, ecx
	push eax
	jmp vm_fetch_decode
_call_rel:	; oh dear
	int3
_nop:
	nop
	jmp vm_fetch_decode
; 32 bit Fowler-Noll-Vo hashing
fnv_32:
	mov esi, [esp + 0x04]			; buffer
	mov ecx, [esp + 0x08]			; length
	mov eax, 0x0ce942fa			; basis
	mov edi, 0x01000193			; fnv_32_prime
@@:
   mul edi
   xor al, [esi]
   inc esi
   dec ecx
   jnz @b
   retn 8
vm_code_end:
; end_obfuscate
; end_shuffle
; Lookup table for VAs that have been manually added as jump targets
; These are placeholders only, the actual tables are patched in at runtime
va_table:
va_table_values:

```

`vm/libphant_obf.asm`:

```asm
format MS COFF
include 'INCLUDE/win32a.inc'
extrn '__imp__VirtualAlloc@16' as VirtualAlloc:dword
extrn '__imp__VirtualFree@12' as VirtualFree:dword
extrn '__imp__GetModuleHandleA@4' as GetModuleHandleA:dword
public GetBuild as "_GetBuild@0"
public BeginProtect as "_BeginProtect@4"
public EndProtect as "_EndProtect@4"
section '.data' data readable writeable
begin_data:
; VM header table
vm_header:
; signatures (used to find the VM)
dd 0xb0fa3d74								; VM signature 1
dd 0xa53bcf98								; VM signature 2
dd 0xee02930e								; VM signature 3
dd 0										; VM major version
dd 2										; VM minor version
; --------------------------------
; File header
; --------------------------------
VM_FILEHEADER:
VM_FILEHEADER_BASE:
dd 0
VM_FILEHEADER_VA_TABLE:
dd 0
VM_FILEHEADER_VA_TABLE_VALUES:
dd 0
; --------------------------------
dd vm_code_start							; VM base
dd vm_code_end-vm_code_start				; VM total size
dd vm_init-vm_code_start					; Init offset
dd vm_fetch_decode-vm_code_start			; Fetch decode offset
dd vm_reenter-vm_code_start					; Reenter offset
dd vm_exit-vm_code_start					; Exit offset
dd vm_virtualalloc_patch_location_1+2-vm_code_start	; VirtualAlloc patch offset 1
dd vm_virtualalloc_patch_location_2+2-vm_code_start	; VirtualAlloc patch offset 2
dd vm_virtualfree_patch_location_1+2-vm_code_start	; VirtualFree patch offset 1
dd vm_virtualfree_patch_location_2+2-vm_code_start	; VirtualFree patch offset 2
dd vm_handlers_patch_instruction+1-vm_code_start	; Handlers patch location
dd vm_reenter_patch_location+1-vm_code_start
dd vm_exit_patch_location+1-vm_code_start
dd vm_exit_native-vm_code_start
dd vm_va_table_patch_location+1-vm_code_start
dd vm_va_table_values_patch_location+1-vm_code_start
dd vm_handlers
dd VM_HANDLER_COUNT
dd BeginProtect-vm_code_start
dd EndProtect-vm_code_start
; End
build_id:
dq 0x1450902833
_code:
dd 0
db 1 ; exit
; ================ Handlers ================
VM_HANDLER_COUNT = 28
vm_handlers:
dd vm_native_dispatch				; 0
dd vm_exit							; 1
dd vm_push							; 2
dd vm_repush
dd vm_push_reg						; 3
dd _push_dword						; 4
dd vm_pop_reg							; 5
dd _push_flag 						; 6
dd _move							; 7
dd _nand							; 8
dd _jump_rel						; 9
dd _jump_abs						; 10
dd _jump_rel_cond					; 11
dd 0 								; popmem, 12
dd _deref 							; deref, 13
dd _add 							; add, 14
dd _sub								; sub, 15
dd _mul 							; mul, 16
dd _xor								; xor, 17
dd _call_rel
dd _nop
dd vm_rebase						;
dd vm_retn
dd vm_pop_remove
dd vm_add
dd vm_sub
dd _push_reg
dd _pop_reg
dd 0
; ========================================
section '.text' code readable executable
text_start:
; VM context structure as pointed to through the context register
CONTEXT_VM_ESP			= 0
CONTEXT_FLAGS			= CONTEXT_VM_ESP		+ 4
CONTEXT_EDI				= CONTEXT_FLAGS			+ 4
CONTEXT_ESI				= CONTEXT_EDI			+ 4
CONTEXT_EBP				= CONTEXT_ESI			+ 4
CONTEXT_ESP				= CONTEXT_EBP			+ 4
CONTEXT_EBX				= CONTEXT_ESP			+ 4		; do not use, use CONTEXT_NATIVE_ESP instead
CONTEXT_EDX				= CONTEXT_EBX			+ 4
CONTEXT_ECX				= CONTEXT_EDX			+ 4
CONTEXT_EAX				= CONTEXT_ECX			+ 4
CONTEXT_NATIVE_ESP		= CONTEXT_EAX			+ 4
CONTEXT_SCRATCH			= CONTEXT_NATIVE_ESP	+ 4
CONTEXT_SIZE = 0x30
; Stack size
VM_SCRATCH_SIZE	=	0x100
VM_STACK_SIZE	=	0x4000
vm_code_start:
GetBuild:
mov eax, build_id
EndProtect:
retn 4
BeginProtect:
retn 4
vm_init:
; begin_shuffle
jmp lbl_2a446f0d_5290_4b56_8fd2_5696af059826

lbl_dc9f7f7b_96ee_405e_a536_14558dc39b2a:

push esi
sub dword [ebx++CONTEXT_NATIVE_ESP], 4
push 803
mov eax, [ebx++CONTEXT_NATIVE_ESP]
lea esp, [esp+12]	; increment junk SP
push 5988
mov [eax], ecx
lea esp, [esp+56]	; reset
lea esp, [ebx+CONTEXT_FLAGS]	; since we want offset 0, otherwise use lea
popfd
jmp lbl_83a04d58_c5c8_4eae_851a_29bf4845a173

lbl_d27a8aca_560d_4388_8748_db3299b2f1a2:

_call_rel:	;control flow -> resetting SP
int3 
lea esp, [esp+0]	; reset
_nop:	;control flow -> resetting SP
nop 
lea esp, [esp+-44]	; new junk SP
push ebx
lea esp, [esp+48]	; reset
jmp vm_fetch_decode	;control flow -> resetting SP
lea esp, [esp+-36]	; new junk SP
jmp lbl_c51338c6_c6e9_4a0c_a679_62ece01480c7

lbl_8a3fda83_3d7a_491f_8e37_133537ebeabe:

shl eax, 2
lea esp, [esp+52]	; reset
push dword [ebx+eax+CONTEXT_EAX]
lea esp, [esp+-40]	; new junk SP
lea esp, [esp+40]	; reset
jmp vm_fetch_decode	;control flow -> resetting SP
lea esp, [esp+-56]	; new junk SP
lea esp, [esp+56]	; reset
vm_pop_reg:	;control flow -> resetting SP
; int3
jmp lbl_64ebe533_b05a_48e5_aacf_8077a13d17e1

lbl_310dea17_2262_4229_9f1b_23ab7c5e688e:

jmp vm_fetch_decode	;control flow -> resetting SP
lea esp, [esp+0]	; reset
lbl_c64ec0c1_0325_4e6e_8be5_985de65e5c59:	;control flow -> resetting SP
lea esp, [esp+-36]	; new junk SP
push ecx
neg eax
lea esp, [esp+-8]	; decrement junk SP
push 7660
shl eax, 2
push dword [esp+52]
jmp lbl_18048634_d2c8_4553_9f73_d23c1d28455f

lbl_d3e48e63_5c5c_4b78_a8b0_1f6301699d38:

mov dword [esp+36], eax
lea esp, [esp+20]	; increment junk SP
push 1154
lea esp, [esp+20]	; reset
jmp vm_fetch_decode	;control flow -> resetting SP
lea esp, [esp+-36]	; new junk SP
push 751
lea esp, [esp+40]	; reset
_jump_rel_cond:	;control flow -> resetting SP
pop eax
jmp lbl_ad148190_7e37_4577_b49d_0daf2c33a1dc

lbl_68447c21_9141_40f1_a4fd_322c70d7d295:

lea esp, [esp+-60]	; new junk SP
add edi, [+VM_FILEHEADER_BASE]
; and that the jump does not lead out of a virtualized chunk
mov edx, edi
lea esp, [esp+60]	; reset
jmp vm_fetch_decode	;control flow -> resetting SP
lea esp, [esp+-44]	; new junk SP
lea esp, [esp+44]	; reset
vm_rebase:	;control flow -> resetting SP
lea esp, [esp+-64]	; new junk SP
jmp lbl_8f6ca9af_5127_4797_b164_e4fcbc766456

lbl_0986d64a_cdb0_4e11_aa87_3c01f6345310:

push dword [ebx++CONTEXT_FLAGS]
lea esp, [esp+0]	; reset
popf 	;control flow -> resetting SP
lea esp, [esp+-64]	; new junk SP
push 3680
add eax, ecx
lea esp, [esp+68]	; reset
pushf 	;control flow -> resetting SP
lea esp, [esp+-56]	; new junk SP
push dword [esp+56]
jmp lbl_8c126541_a9b0_4e87_b87b_d8dd87fbff40

lbl_6ffdc82f_4b0c_4ed0_b622_9587bcdd6c24:

call dword [+VirtualAlloc]	;control flow -> resetting SP
lea esp, [esp+-36]	; new junk SP
push ecx
mov dword [esp+36], eax
push 7550
; Allocate stack
lea esp, [esp+32]	; increment junk SP
mov dword [esp+4], 0x04
push edi
mov dword [esp+4], 0x1000
jmp lbl_9d595953_a8d9_4e9d_bda4_8c13c9a67371

lbl_abc217b3_fb47_4802_bc0c_2291ff43b424:

push 6209
lea esp, [esp+40]	; reset
jmp vm_fetch_decode	;control flow -> resetting SP
lea esp, [esp+0]	; reset
vm_repush:	;control flow -> resetting SP
lea esp, [esp+-48]	; new junk SP
lea esp, [esp+48]	; reset
push dword [esp++00]
lea esp, [esp+-56]	; new junk SP
lea esp, [esp+56]	; reset
jmp lbl_27c19fdc_174b_41d0_b116_903fdb2827d6

lbl_f577dd3f_9653_45f5_abd4_3d9178988ce1:

lea esp, [esp+-60]	; new junk SP
mov eax, [esp+60]
push dword [esp+64]
pop dword [eax]
push 1543
lea esp, [esp+72]	; reset
jmp vm_fetch_decode	;control flow -> resetting SP
lea esp, [esp+-48]	; new junk SP
lea esp, [esp+48]	; reset
_nand:	;control flow -> resetting SP
jmp lbl_c7b010ed_77f1_4b59_9f05_e4e77c8561eb

lbl_9376ae38_32e2_4b88_83f8_d2339fd87709:

lea esp, [esp+-48]	; new junk SP
lea esp, [esp+48]	; reset
lbl_e78feab4_f082_4605_8a20_67a49ff579d4:	;control flow -> resetting SP
lea esp, [esp+-40]	; new junk SP
push 6264
neg eax
lea esp, [esp+36]	; increment junk SP
push esi
shl eax, 2
mov [ebx+eax+CONTEXT_EAX], ecx
jmp lbl_7ad23270_5202_4250_8203_d8bcdf3a9ecc

lbl_e7bebe28_d6e3_4016_bdd9_b2d666a93b03:

push 8153
add eax, VM_STACK_SIZE
lea esp, [esp+40]	; increment junk SP
mov ebx, [esp+16]
push ebx
; Copy flags and registers to VM stack
push dword [esp+24]
pop dword [eax++0x2c]	;registers
lea esp, [esp+24]	; increment junk SP
push dword [esp+4]
jmp lbl_3fcea45c_b7c7_45af_ab88_de15c98d470a

lbl_01f1c837_0bbb_408d_984b_58c8e9401004:

mov dword [eax++0x04], ebx	;VM scratch
sub eax, CONTEXT_SIZE
mov dword [eax], eax	;VM ESP
mov ebx, eax
mov esp, eax
; Save current base address
lea esp, [esp+-52]	; new junk SP
mov dword [esp+48], 0
lea esp, [esp+48]	; reset
call dword [+GetModuleHandleA]	;control flow -> resetting SP
jmp lbl_28924539_afee_4f71_97c4_cf004ac35820

lbl_6fa600a0_6804_4aa7_bb7d_48f3812517bb:

push esi
mov eax, [ebx++CONTEXT_SCRATCH]
lea esp, [esp+-28]	; decrement junk SP
mov ecx, [edx]
push 2856
inc edx
lea esp, [esp+32]	; increment junk SP
push edx
and ecx, 0xff	;length
xor esi, esi
jmp lbl_bbbce1bd_a3db_4c08_a31c_532a8980b604

lbl_283581fd_7d8b_4f64_bf95_463c54ef3f0c:

and eax, 0xff
lea esp, [esp+-64]	; new junk SP
push 7189
sub dword [ebx++CONTEXT_NATIVE_ESP], 4
push 2793
mov ecx, [ebx++CONTEXT_NATIVE_ESP]
lea esp, [esp+-8]	; decrement junk SP
push 3507
cmp eax, 4
lea esp, [esp+-20]	; decrement junk SP
jmp lbl_02288d6e_8241_4dc4_a579_038b4adcc913

lbl_daef9012_aa83_42aa_add3_b0087223bb50:

_mul:	;control flow -> resetting SP
pop eax
lea esp, [esp+-48]	; new junk SP
push 2714
mov ecx, [esp+52]
imul eax, ecx
lea esp, [esp+0]	; increment junk SP
push ebx
mov dword [esp+56], eax
lea esp, [esp+56]	; reset
jmp lbl_1d73c25a_3a35_47bc_8f0e_596659da6678

lbl_d034b97c_2db0_416a_b4d7_ba3ccd79d750:

mov ecx, [ebx++CONTEXT_FLAGS]
push ebx
and eax, ecx
push 7763
mov dword [esp+44], eax
lea esp, [esp+44]	; reset
jmp vm_fetch_decode	;control flow -> resetting SP
lea esp, [esp+0]	; reset
_deref:	;control flow -> resetting SP
pop eax
jmp lbl_748c7fdf_a7ba_467c_9ec7_0df69dfd69f0

lbl_72d1523d_c1f5_4ef0_81b1_4e62df0f6479:

nop 
nop 
nop 
mov eax, [edx]
push esi
add edx, 4
push 409
add edx, eax
lea esp, [esp+72]	; reset
jmp vm_fetch_decode	;control flow -> resetting SP
jmp lbl_cdbf58e7_2f82_4d0f_96b0_9101f156ad0a

lbl_652506df_d790_4e1a_b338_41dc55fa2837:

push edx
mov eax, [esp+48]
mov ecx, [esp+52]
add eax, ecx
lea esp, [esp+-32]	; decrement junk SP
push 5901
mov dword [esp+88], eax
push 1871
lea esp, [esp+92]	; reset
jmp vm_fetch_decode	;control flow -> resetting SP
jmp lbl_cd207c0e_e74f_4cf4_b8fb_582a463f4e05

lbl_dc522ecc_e6b8_4b32_8a8b_c73ada0d7e97:

xor eax, ecx
lea esp, [esp+8]	; increment junk SP
push edi
mov dword [esp+40], eax
lea esp, [esp+-4]	; decrement junk SP
lea esp, [esp+44]	; reset
jmp vm_fetch_decode	;control flow -> resetting SP
lea esp, [esp+-60]	; new junk SP
push eax
lea esp, [esp+64]	; reset
jmp lbl_d27a8aca_560d_4388_8748_db3299b2f1a2

lbl_4c4d6a3d_3709_4999_aa7f_ba7f0c794a2c:

lea esp, [esp+52]	; reset
push dword [esp++40+4+4]	;pointer to memory
lea esp, [esp+-40]	; new junk SP
push ebp
lea esp, [esp+44]	; reset
vm_virtualfree_patch_location_2:	;control flow -> resetting SP
lea esp, [esp+0]	; reset
call dword [+VirtualFree]	;control flow -> resetting SP
lea esp, [esp+-48]	; new junk SP
push edx
jmp lbl_c82581a4_4235_48e3_9c66_f4a8356f3dc3

lbl_cd207c0e_e74f_4cf4_b8fb_582a463f4e05:

lea esp, [esp+-40]	; new junk SP
lea esp, [esp+40]	; reset
vm_sub:	;control flow -> resetting SP
pop eax
pop ecx
sub eax, ecx
lea esp, [esp+-60]	; new junk SP
push 247
mov dword [esp+60], eax
lea esp, [esp+4]	; increment junk SP
jmp lbl_3d9ac79d_dcce_4e39_95bf_794f94edc7e2

lbl_d31a5404_9af1_4d75_91ae_2853c3d61d2c:

pop dword [eax++0x14]
push 4927
push dword [esp+32]
pop dword [eax++0x10]
lea esp, [esp+-4]	; decrement junk SP
push dword [esp+40]
pop dword [eax++0x0c]	;flags
mov edx, [esp+44]
lea esp, [esp+48]	; reset
mov dword [eax-0x08], esp
jmp lbl_01f1c837_0bbb_408d_984b_58c8e9401004

lbl_e720a360_a3e0_4338_a131_6d41157f1184:

push edi
; Add mov esp, <VM context> at end of code
push 1795
mov dword [eax+esi+0], 0xbc909090
lea esp, [esp+-24]	; decrement junk SP
mov [eax+esi+4], edi
add esi, 8
; Add jump at end of code
push 5801
; (jmp  = vm_reenter - scratch - esi - 5)
jmp lbl_eceac388_c7b6_4604_a0eb_d79e6e88c32f

lbl_4aeedcae_ab05_4aa2_ae64_96a0a47a032c:

and eax, ecx
lea esp, [esp+-52]	; new junk SP
not eax
and eax, 0xffffffff	;hack to update flags according to NOT result (prior state not needed)
lea esp, [esp+52]	; reset
pushf 	;control flow -> resetting SP
lea esp, [esp+-32]	; new junk SP
push esp
push dword [esp+36]
pop dword [ebx++CONTEXT_FLAGS]
jmp lbl_d3e48e63_5c5c_4b78_a8b0_1f6301699d38

lbl_0818c88d_29de_4d05_935c_bc588e481a8e:

push 2706
add esi, 4
lea esp, [esp+44]	; reset
jmp lbl_391d6e73_00a5_422a_99ca_2b8eef0c52e3	;control flow -> resetting SP
lea esp, [esp+-60]	; new junk SP
push 3433
lea esp, [esp+64]	; reset
lbl_6b3e907e_121d_4476_b504_581199cf26ec:	;control flow -> resetting SP
sub esi, ecx
mov edi, [edx+esi]
jmp lbl_68447c21_9141_40f1_a4fd_322c70d7d295

lbl_9d595953_a8d9_4e9d_bda4_8c13c9a67371:

lea esp, [esp+0]	; decrement junk SP
mov dword [esp+0], VM_STACK_SIZE
lea esp, [esp+-48]	; new junk SP
push ebp
mov dword [esp+48], 0
lea esp, [esp+48]	; reset
vm_virtualalloc_patch_location_2:	;control flow -> resetting SP
lea esp, [esp+0]	; reset
call dword [+VirtualAlloc]	;control flow -> resetting SP
lea esp, [esp+-52]	; new junk SP
jmp lbl_e7bebe28_d6e3_4016_bdd9_b2d666a93b03

lbl_b4cfd62e_61e4_4635_8bc8_a112fed0389d:

add eax, 4
mov ecx, [ebx++CONTEXT_NATIVE_ESP]
lea esp, [esp+-44]	; new junk SP
push 4961
lea esp, [esp+48]	; reset
push dword [ecx]
add dword [ebx++CONTEXT_NATIVE_ESP], eax
lea esp, [esp+-52]	; new junk SP
push edx
lea esp, [esp+56]	; reset
jmp lbl_3882c3d5_fc07_4d6f_9671_6ca9b58db7e9

lbl_b2db32a5_30ad_40f8_a247_cf76ebfae33f:

lea esp, [esp+-36]	; new junk SP
mov ecx, [esp+36]
lea esp, [esp+40]	; reset
push dword [ebx++CONTEXT_FLAGS]
lea esp, [esp+0]	; reset
popf 	;control flow -> resetting SP
sub eax, ecx
lea esp, [esp+-60]	; new junk SP
lea esp, [esp+60]	; reset
pushf 	;control flow -> resetting SP
jmp lbl_f148519a_11c1_4b04_b344_417dfe6159ef

lbl_18048634_d2c8_4553_9f73_d23c1d28455f:

pop dword [ebx+eax+CONTEXT_EAX]
lea esp, [esp+40]	; increment junk SP
push eax
lea esp, [esp+20]	; reset
jmp vm_fetch_decode	;control flow -> resetting SP
lea esp, [esp+0]	; reset
_push_reg:	;control flow -> resetting SP
; int3
mov eax, [edx]
inc edx
jmp lbl_283581fd_7d8b_4f64_bf95_463c54ef3f0c

lbl_35325125_f973_48db_8d54_7052adc93e52:

lea esp, [esp+36]	; reset
jmp vm_fetch_decode	;control flow -> resetting SP
lea esp, [esp+0]	; reset
_push_dword:	;control flow -> resetting SP
; int3
sub dword [ebx++CONTEXT_NATIVE_ESP], 4
lea esp, [esp+-32]	; new junk SP
mov eax, [ebx++CONTEXT_NATIVE_ESP]
push dword [esp+32]
pop dword [eax]
jmp lbl_abc217b3_fb47_4802_bc0c_2291ff43b424

lbl_83a04d58_c5c8_4eae_851a_29bf4845a173:

popad
pop esp
retn
vm_reenter:
pushad
pushfd
sub esp, 4
pop esp
pop ebx
pop edx
jmp lbl_e228a2ab_e9fc_40fe_8bf8_40df69793791

lbl_c7b010ed_77f1_4b59_9f05_e4e77c8561eb:

lea esp, [esp+-44]	; new junk SP
push eax
mov eax, [esp+48]
mov ecx, [esp+52]
push edi
lea esp, [esp+60]	; reset
push dword [ebx++CONTEXT_FLAGS]
lea esp, [esp+-52]	; new junk SP
lea esp, [esp+52]	; reset
popf 	;control flow -> resetting SP
jmp lbl_4aeedcae_ab05_4aa2_ae64_96a0a47a032c

lbl_490407f5_121b_492c_9029_411998c2648b:

push 302
lea esp, [esp+48]	; reset
lbl_f46ee2ae_b72a_4138_891b_3b47467a78c9:	;control flow -> resetting SP
add edx, ecx	;increase VM IP
lea esp, [esp+-64]	; new junk SP
push 1239
mov dword [esp+64], edx
lea esp, [esp+24]	; increment junk SP
push esi
mov dword [esp+40], ebx
jmp lbl_88466859_41a7_4db0_8759_4ac4f7027479

lbl_d1ba9bff_36a0_4e0f_9553_2168b3fa088c:

lea esp, [esp+32]	; increment junk SP
push edi
mov eax, [edx]
lea esp, [esp+-28]	; decrement junk SP
inc edx
push 6529
and eax, 0xff
push esp
mov ecx, [ebx++CONTEXT_NATIVE_ESP]
push eax
jmp lbl_fc76fc56_683c_4419_b8c7_4fc3ee8aff02

lbl_65a57896_cc5e_4fec_8a21_52822514c323:

mov eax, [edx]
lea esp, [esp+-12]	; decrement junk SP
inc edx
and eax, 0xff
push 2356
cmp eax, 4
lea esp, [esp+-16]	; decrement junk SP
push 6809
lea esp, [esp+52]	; reset
jne lbl_fe1e5aa0_5781_4a05_a514_3e20f155a315	;control flow -> resetting SP
jmp lbl_084ac380_2e05_476b_813e_8c59fbfd0b9a

lbl_78d6c8a9_05bb_45aa_88da_87fca7034763:

pop dword [ecx]
push eax
lea esp, [esp+68]	; reset
jmp vm_fetch_decode	;control flow -> resetting SP
lea esp, [esp+-44]	; new junk SP
lea esp, [esp+44]	; reset
_pop_reg:	;control flow -> resetting SP
lea esp, [esp+-56]	; new junk SP
push 7994
; int3
jmp lbl_d1ba9bff_36a0_4e0f_9553_2168b3fa088c

lbl_e8053b5e_5d4e_4ac6_a991_73b7f9d9637d:

lea esp, [esp+-40]	; new junk SP
push 3015
int3 
lea esp, [esp+44]	; reset
jmp vm_fetch_decode	;control flow -> resetting SP
lea esp, [esp+-64]	; new junk SP
push 739
lea esp, [esp+68]	; reset
vm_retn:	;control flow -> resetting SP
pop eax
jmp lbl_b4cfd62e_61e4_4635_8bc8_a112fed0389d

lbl_7ad23270_5202_4250_8203_d8bcdf3a9ecc:

lea esp, [esp+8]	; increment junk SP
push eax
add dword [ebx++CONTEXT_NATIVE_ESP], 4
lea esp, [esp+0]	; decrement junk SP
lea esp, [esp+8]	; reset
jmp vm_fetch_decode	;control flow -> resetting SP
lea esp, [esp+-32]	; new junk SP
push edx
lea esp, [esp+36]	; reset
_move:	;control flow -> resetting SP
jmp lbl_f577dd3f_9653_45f5_abd4_3d9178988ce1

lbl_1d73c25a_3a35_47bc_8f0e_596659da6678:

jmp vm_fetch_decode	;control flow -> resetting SP
lea esp, [esp+-56]	; new junk SP
push edx
lea esp, [esp+60]	; reset
_xor:	;control flow -> resetting SP
lea esp, [esp+-32]	; new junk SP
push esi
mov eax, [esp+36]
push 5130
mov ecx, [esp+44]
jmp lbl_dc522ecc_e6b8_4b32_8a8b_c73ada0d7e97

lbl_aa64cc4a_a3ae_4bc6_90cc_8fc348a94b7c:

lea esp, [esp+-28]	; decrement junk SP
push 7288
lea esp, [esp+80]	; reset
vm_handlers_patch_instruction:	;control flow -> resetting SP
mov ebp, vm_handlers
lea esp, [esp+0]	; reset
jmp dword [ebp+eax]	;control flow -> resetting SP
lea esp, [esp+-56]	; new junk SP
lea esp, [esp+56]	; reset
vm_int3:	;control flow -> resetting SP
jmp lbl_e8053b5e_5d4e_4ac6_a991_73b7f9d9637d

lbl_b7471e70_b193_4dcb_b604_cfdcea851fd3:

pushfd 	;control flow -> resetting SP
lea esp, [esp+-36]	; new junk SP
push esi
; Allocate scratch space
lea esp, [esp+-20]	; decrement junk SP
mov dword [esp+56], 0x40
push edi
mov dword [esp+56], 0x1000
lea esp, [esp+-48]	; decrement junk SP
push ebp
jmp lbl_760caa0a_0c60_4e4c_8f4d_3cf1691bd120

lbl_1e9f5133_3483_41c3_935f_f06700fb3b6c:

push 1638
lea esp, [esp+72]	; reset
jne lbl_c64ec0c1_0325_4e6e_8be5_985de65e5c59	;control flow -> resetting SP
lea esp, [esp+-40]	; new junk SP
push 2405
push dword [esp+44]
pop dword [ebx++CONTEXT_NATIVE_ESP]	;special case for now
lea esp, [esp+-28]	; decrement junk SP
push ebp
lea esp, [esp+80]	; reset
jmp lbl_310dea17_2262_4229_9f1b_23ab7c5e688e

lbl_551bc3ce_f5fc_4506_8620_dc125dd326d9:

jmp vm_fetch_decode	;control flow -> resetting SP
lea esp, [esp+-36]	; new junk SP
push 955
lea esp, [esp+40]	; reset
vm_pop_remove:	;control flow -> resetting SP
lea esp, [esp+-44]	; new junk SP
push 6738
lea esp, [esp+48]	; reset
lea esp, [esp++4]
lea esp, [esp+-36]	; new junk SP
jmp lbl_35325125_f973_48db_8d54_7052adc93e52

lbl_02288d6e_8241_4dc4_a579_038b4adcc913:

lea esp, [esp+104]	; reset
jne lbl_7c5c7bd4_6cfa_4c1d_bcc5_7413c19c05fc	;control flow -> resetting SP
push dword [ebx++CONTEXT_NATIVE_ESP]	;special case for now
pop dword [ecx]
lea esp, [esp+-60]	; new junk SP
lea esp, [esp+60]	; reset
jmp vm_fetch_decode	;control flow -> resetting SP
lea esp, [esp+-36]	; new junk SP
push 3278
lea esp, [esp+40]	; reset
jmp lbl_8064d5d6_2036_403e_9e78_e42b92aa4048

lbl_218a9c20_4188_4360_aeaa_1e7bd48544a8:

lea esp, [esp+-92]	; decrement junk SP
mov dword [esp+216], ecx
push 3841
lea esp, [esp+220]	; reset
vm_native_dispatch_2:	;control flow -> resetting SP
; Push address onto native stack
lea esp, [esp+-40]	; new junk SP
push 4288
mov ecx, [esp+44]
lea esp, [esp+-8]	; decrement junk SP
jmp lbl_dc9f7f7b_96ee_405e_a536_14558dc39b2a

lbl_3227dd4a_a430_49ac_a640_7c0a300312db:

lea esp, [esp+0]	; reset
lbl_a1b97a5e_275a_45ba_b306_9b6eb4303421:	;control flow -> resetting SP
mul edi
lea esp, [esp+-60]	; new junk SP
push 2171
xor al, [esi]
inc esi
dec ecx
lea esp, [esp+64]	; reset
jnz lbl_a1b97a5e_275a_45ba_b306_9b6eb4303421	;control flow -> resetting SP
jmp lbl_0fb57007_bce2_4b08_87d4_ae9839973bb6

lbl_67bdaa4d_c95f_4061_8d48_dc71b333bca9:

lea esp, [esp+-40]	; new junk SP
push 3694
push dword [esp+44]
pop dword [eax+esi]
push esi
add esi, 4
push esp
lea esp, [esp+56]	; reset
jmp lbl_95eca7d8_6b5b_4f5a_9d54_ba34e3578126	;control flow -> resetting SP
lea esp, [esp+-44]	; new junk SP
jmp lbl_490407f5_121b_492c_9029_411998c2648b

lbl_2a446f0d_5290_4b56_8fd2_5696af059826:

lea esp, [esp+-40]	; new junk SP
lea esp, [esp+40]	; reset
lea esp, [esp++4]	;throw away the return value from the BeginProtect call
lea esp, [esp+-56]	; new junk SP
push 1804
lea esp, [esp+60]	; reset
pushad 	;control flow -> resetting SP
lea esp, [esp+-40]	; new junk SP
push ebx
lea esp, [esp+44]	; reset
jmp lbl_b7471e70_b193_4dcb_b604_cfdcea851fd3

lbl_748c7fdf_a7ba_467c_9ec7_0df69dfd69f0:

lea esp, [esp+-36]	; new junk SP
push esi
lea esp, [esp+40]	; reset
push dword [eax]
lea esp, [esp+-52]	; new junk SP
lea esp, [esp+52]	; reset
jmp vm_fetch_decode	;control flow -> resetting SP
lea esp, [esp+0]	; reset
vm_add:	;control flow -> resetting SP
lea esp, [esp+-44]	; new junk SP
jmp lbl_652506df_d790_4e1a_b338_41dc55fa2837

lbl_ad148190_7e37_4577_b49d_0daf2c33a1dc:

cmp eax, 0
lea esp, [esp+0]	; reset
jnz _jump_rel	;control flow -> resetting SP
add edx, 4
lea esp, [esp+0]	; reset
jmp vm_fetch_decode	;control flow -> resetting SP
lea esp, [esp+0]	; reset
_jump_rel:	;control flow -> resetting SP
lea esp, [esp+-64]	; new junk SP
; int3
jmp lbl_72d1523d_c1f5_4ef0_81b1_4e62df0f6479

lbl_5639e86b_851c_4b83_a4be_7e82d7eedb12:

push dword [esp++36+4+4]	;pointer to memory
lea esp, [esp+0]	; reset
vm_virtualfree_patch_location_1:	;control flow -> resetting SP
lea esp, [esp+-36]	; new junk SP
lea esp, [esp+36]	; reset
call dword [+VirtualFree]	;control flow -> resetting SP
push 0x8000	;free type: MEM_RELEASE
lea esp, [esp+-52]	; new junk SP
mov dword [esp+48], 0
push 5155
jmp lbl_4c4d6a3d_3709_4999_aa7f_ba7f0c794a2c

lbl_8f6ca9af_5127_4797_b164_e4fcbc766456:

mov eax, [+VM_FILEHEADER_BASE]
add [esp], eax
push 4259
lea esp, [esp+68]	; reset
jmp vm_fetch_decode	;control flow -> resetting SP
lea esp, [esp+0]	; reset
no_va_found:	;control flow -> resetting SP
lea esp, [esp+-40]	; new junk SP
push ecx
mov edx, eax	;use original VA
jmp lbl_7a5dc999_dc22_4283_a210_775112b0a723

lbl_910eec8d_a63a_47c2_b130_7dcc7e0f2fc7:

pushad 	;control flow -> resetting SP
lea esp, [esp+-40]	; new junk SP
lea esp, [esp+40]	; reset
pushfd 	;control flow -> resetting SP
push 0x8000	;free type: MEM_RELEASE
lea esp, [esp+-44]	; new junk SP
push 5979
mov dword [esp+44], 0
push edi
lea esp, [esp+48]	; reset
jmp lbl_5639e86b_851c_4b83_a4be_7e82d7eedb12

lbl_e228a2ab_e9fc_40fe_8bf8_40df69793791:

mov dword [ebx+CONTEXT_VM_ESP], esp	; update VM ESP (removing the pushed dispatched address etc.)
jmp vm_fetch_decode
lea esp, [esp+0]	; reset
vm_exit:	;control flow -> resetting SP
lea esp, [esp+-48]	; new junk SP
; Push the VM exit operand onto the native stack
sub dword [ebx++CONTEXT_NATIVE_ESP], 12
mov eax, [ebx++CONTEXT_NATIVE_ESP]
lea esp, [esp+48]	; reset
push dword [ebx++CONTEXT_SCRATCH]
jmp lbl_1553c355_b7fd_4c55_9726_ac77ed765caa

lea esp, [esp+-36]	; new junk SP
lea esp, [esp+36]	; reset
retn 8	;control flow -> resetting SP
lea esp, [esp+0]	; reset
vm_code_end:	;control flow -> resetting SP
lea esp, [esp+0]	; reset
lbl_eceac388_c7b6_4604_a0eb_d79e6e88c32f:

lea esp, [esp+-84]	; decrement junk SP
push edx
mov dword [eax+esi], 0xe9909090
push ebx
add esi, 4
lea esp, [esp+192]	; reset
vm_reenter_patch_location:	;control flow -> resetting SP
lea esp, [esp+-52]	; new junk SP
mov edi, vm_reenter
sub edi, eax
jmp lbl_4cbaf66e_044b_48be_b44e_569147061020

lbl_88466859_41a7_4db0_8759_4ac4f7027479:

lea esp, [esp+-28]	; decrement junk SP
; Save VM ESP at this state (don't push anything past this point)
lea esp, [esp+68]	; reset
mov dword [ebx+CONTEXT_VM_ESP], esp
lea edi, [ebx++CONTEXT_NATIVE_ESP]
; Add mov [<VM context>], esp
mov dword [eax+esi+0], 0x25899090
lea esp, [esp+-64]	; new junk SP
mov dword [eax+esi+4], edi
add esi, 8
jmp lbl_e720a360_a3e0_4338_a131_6d41157f1184

lbl_7a5dc999_dc22_4283_a210_775112b0a723:

lea esp, [esp+-12]	; decrement junk SP
lea esp, [esp+56]	; reset
jmp vm_fetch_decode	;control flow -> resetting SP
lea esp, [esp+-44]	; new junk SP
lea esp, [esp+44]	; reset
_push_flag:	;control flow -> resetting SP
mov eax, [edx]
lea esp, [esp+-36]	; new junk SP
push ecx
add edx, 4
jmp lbl_d034b97c_2db0_416a_b4d7_ba3ccd79d750

lbl_27c19fdc_174b_41d0_b116_903fdb2827d6:

jmp vm_fetch_decode	;control flow -> resetting SP
lea esp, [esp+-48]	; new junk SP
push 2121
lea esp, [esp+52]	; reset
vm_push_reg:	;control flow -> resetting SP
lea esp, [esp+-36]	; new junk SP
push ebp
; int3
lea esp, [esp+28]	; increment junk SP
push edi
jmp lbl_65a57896_cc5e_4fec_8a21_52822514c323

lbl_f148519a_11c1_4b04_b344_417dfe6159ef:

lea esp, [esp+-40]	; new junk SP
push dword [esp+40]
pop dword [ebx++CONTEXT_FLAGS]
push 7740
mov dword [esp+44], eax
lea esp, [esp+44]	; reset
jmp vm_fetch_decode	;control flow -> resetting SP
lea esp, [esp+-44]	; new junk SP
push 2048
lea esp, [esp+48]	; reset
jmp lbl_daef9012_aa83_42aa_add3_b0087223bb50

lbl_1553c355_b7fd_4c55_9726_ac77ed765caa:

lea esp, [esp+-60]	; new junk SP
push eax
mov dword [eax++0], ebx	;move context pointer to native stack
lea esp, [esp+20]	; increment junk SP
push eax
push dword [esp+48]
pop dword [eax++4]	;move scratch pointer to native stack
lea esp, [esp+-4]	; decrement junk SP
push dword [esp+56]
pop dword [eax++8]	;vm exit return value?
jmp lbl_1aec8077_0bdc_4d4b_adfc_52039f0410e8

lbl_64ebe533_b05a_48e5_aacf_8077a13d17e1:

lea esp, [esp+-60]	; new junk SP
mov eax, [edx]
push edi
inc edx
lea esp, [esp+16]	; increment junk SP
push 5449
and eax, 0xff
push 3000
cmp eax, 4
lea esp, [esp+-12]	; decrement junk SP
jmp lbl_1e9f5133_3483_41c3_935f_f06700fb3b6c

lbl_cdbf58e7_2f82_4d0f_96b0_9101f156ad0a:

lea esp, [esp+0]	; reset
_jump_abs:	;control flow -> resetting SP
lea esp, [esp+-40]	; new junk SP
push 6648
mov eax, [esp+44]
lea esp, [esp+48]	; reset
vm_va_table_patch_location:	;control flow -> resetting SP
lea esp, [esp+-48]	; new junk SP
mov ecx, [+VM_FILEHEADER_VA_TABLE]
push ebp
jmp lbl_e35642e2_7fc5_405e_bcb6_45110077d809

lbl_c82581a4_4235_48e3_9c66_f4a8356f3dc3:

lea esp, [esp+52]	; reset
popfd 	;control flow -> resetting SP
lea esp, [esp+-48]	; new junk SP
push esi
lea esp, [esp+52]	; reset
popad 	;control flow -> resetting SP
lea esp, [esp++8]	;remove the two VirtualFree addresses
lea esp, [esp+0]	; reset
retn 	;control flow -> resetting SP
lea esp, [esp+-60]	; new junk SP
jmp lbl_1db9a8a0_eefc_417c_81e3_34d97eb972e9

lbl_fc76fc56_683c_4419_b8c7_4fc3ee8aff02:

mov ecx, [ecx]
lea esp, [esp+48]	; increment junk SP
cmp eax, 4
lea esp, [esp+24]	; reset
jne lbl_e78feab4_f082_4605_8a20_67a49ff579d4	;control flow -> resetting SP
lea esp, [esp+-40]	; new junk SP
mov [ebx++CONTEXT_NATIVE_ESP], ecx	;special case for now
add dword [ebx++CONTEXT_NATIVE_ESP], 4
lea esp, [esp+40]	; reset
jmp vm_fetch_decode	;control flow -> resetting SP
jmp lbl_9376ae38_32e2_4b88_83f8_d2339fd87709

lbl_8c126541_a9b0_4e87_b87b_d8dd87fbff40:

pop dword [ebx++CONTEXT_FLAGS]
mov dword [esp+56], eax
push ebx
lea esp, [esp+60]	; reset
jmp vm_fetch_decode	;control flow -> resetting SP
lea esp, [esp+-56]	; new junk SP
push ebp
lea esp, [esp+60]	; reset
_sub:	;control flow -> resetting SP
pop eax
jmp lbl_b2db32a5_30ad_40f8_a247_cf76ebfae33f

lbl_1db9a8a0_eefc_417c_81e3_34d97eb972e9:

lea esp, [esp+60]	; reset
vm_fetch_decode:	;control flow -> resetting SP
lea esp, [esp+-52]	; new junk SP
mov eax, [edx]
and eax, 0xff
push esi
imul eax, 4
lea esp, [esp+12]	; increment junk SP
push ebp
inc edx
jmp lbl_aa64cc4a_a3ae_4bc6_90cc_8fc348a94b7c

lbl_e35642e2_7fc5_405e_bcb6_45110077d809:

lea esp, [esp+52]	; reset
vm_va_table_values_patch_location:	;control flow -> resetting SP
mov edx, [+VM_FILEHEADER_VA_TABLE_VALUES]
lea esp, [esp+-56]	; new junk SP
push 7984
mov esi, ecx
lea esp, [esp+60]	; reset
lbl_391d6e73_00a5_422a_99ca_2b8eef0c52e3:	;control flow -> resetting SP
cmp dword [esi], -1
lea esp, [esp+-56]	; new junk SP
jmp lbl_d741e7a5_d287_45bd_b60b_da2d4064016d

lbl_3d9ac79d_dcce_4e39_95bf_794f94edc7e2:

push 2947
lea esp, [esp+60]	; reset
jmp vm_fetch_decode	;control flow -> resetting SP
lea esp, [esp+0]	; reset
_add:	;control flow -> resetting SP
pop eax
lea esp, [esp+-36]	; new junk SP
mov ecx, [esp+36]
push ebx
lea esp, [esp+44]	; reset
jmp lbl_0986d64a_cdb0_4e11_aa87_3c01f6345310

lbl_760caa0a_0c60_4e4c_8f4d_3cf1691bd120:

mov dword [esp+104], VM_SCRATCH_SIZE
push 8147
mov dword [esp+104], 0
lea esp, [esp+60]	; increment junk SP
push ebx
lea esp, [esp+48]	; reset
vm_virtualalloc_patch_location_1:	;control flow -> resetting SP
lea esp, [esp+-56]	; new junk SP
push edx
lea esp, [esp+60]	; reset
jmp lbl_6ffdc82f_4b0c_4ed0_b622_9587bcdd6c24

lbl_28924539_afee_4f71_97c4_cf004ac35820:

mov dword [+VM_FILEHEADER_BASE], eax
lea esp, [esp+-60]	; new junk SP
add edx, eax	;add image base to VM IP
push 2063
lea esp, [esp+64]	; reset
jmp vm_fetch_decode	;control flow -> resetting SP
lea esp, [esp+0]	; reset
vm_native_dispatch:	;control flow -> resetting SP
; int3
lea esp, [esp+-48]	; new junk SP
jmp lbl_6fa600a0_6804_4aa7_bb7d_48f3812517bb

lbl_8064d5d6_2036_403e_9e78_e42b92aa4048:

lbl_7c5c7bd4_6cfa_4c1d_bcc5_7413c19c05fc:	;control flow -> resetting SP
lea esp, [esp+-60]	; new junk SP
push ebp
neg eax
shl eax, 2
push esi
lea esp, [esp+68]	; reset
push dword [ebx+eax+CONTEXT_EAX]
lea esp, [esp+-60]	; new junk SP
push dword [esp+60]
jmp lbl_78d6c8a9_05bb_45aa_88da_87fca7034763

lbl_3882c3d5_fc07_4d6f_9671_6ca9b58db7e9:

jmp vm_exit	;control flow -> resetting SP
lea esp, [esp+0]	; reset
vm_push:	;control flow -> resetting SP
lea esp, [esp+-64]	; new junk SP
push 3607
lea esp, [esp+68]	; reset
push dword [edx]
lea esp, [esp+-40]	; new junk SP
add edx, 4
lea esp, [esp+40]	; reset
jmp lbl_551bc3ce_f5fc_4506_8620_dc125dd326d9

lbl_4cbaf66e_044b_48be_b44e_569147061020:

push 7800
sub edi, esi
lea esp, [esp+-16]	; decrement junk SP
push ebp
sub edi, 4
push 5287
mov dword [eax+esi], edi
lea esp, [esp+-44]	; decrement junk SP
push eax
mov ecx, [ebx++CONTEXT_SCRATCH]
jmp lbl_218a9c20_4188_4360_aeaa_1e7bd48544a8

lbl_3fcea45c_b7c7_45af_ab88_de15c98d470a:

pop dword [eax++0x28]
push dword [esp+8]
pop dword [eax++0x24]
push dword [esp+12]
pop dword [eax++0x20]
push dword [esp+16]
pop dword [eax++0x1c]
push dword [esp+20]
pop dword [eax++0x18]
push dword [esp+24]
jmp lbl_d31a5404_9af1_4d75_91ae_2853c3d61d2c

lbl_d741e7a5_d287_45bd_b60b_da2d4064016d:

push 6896
lea esp, [esp+60]	; reset
je no_va_found	;control flow -> resetting SP
lea esp, [esp+-44]	; new junk SP
push 4807
cmp [esi], eax
lea esp, [esp+12]	; increment junk SP
lea esp, [esp+36]	; reset
je lbl_6b3e907e_121d_4476_b504_581199cf26ec	;control flow -> resetting SP
lea esp, [esp+-40]	; new junk SP
jmp lbl_0818c88d_29de_4d05_935c_bc588e481a8e

lbl_bbbce1bd_a3db_4c08_a31c_532a8980b604:

lea esp, [esp+56]	; increment junk SP
lea esp, [esp+0]	; reset
lbl_95eca7d8_6b5b_4f5a_9d54_ba34e3578126:	;control flow -> resetting SP
lea esp, [esp+-56]	; new junk SP
cmp ecx, esi
lea esp, [esp+56]	; reset
je lbl_f46ee2ae_b72a_4138_891b_3b47467a78c9	;control flow -> resetting SP
lea esp, [esp+-48]	; new junk SP
lea esp, [esp+48]	; reset
push dword [edx+esi]
jmp lbl_67bdaa4d_c95f_4061_8d48_dc71b333bca9

lbl_084ac380_2e05_476b_813e_8c59fbfd0b9a:

push dword [ebx++CONTEXT_NATIVE_ESP]	;special case for now
lea esp, [esp+-40]	; new junk SP
push 6470
lea esp, [esp+44]	; reset
jmp vm_fetch_decode	;control flow -> resetting SP
lea esp, [esp+0]	; reset
lbl_fe1e5aa0_5781_4a05_a514_3e20f155a315:	;control flow -> resetting SP
neg eax
lea esp, [esp+-48]	; new junk SP
push ebp
jmp lbl_8a3fda83_3d7a_491f_8e37_133537ebeabe

lbl_1aec8077_0bdc_4d4b_adfc_52039f0410e8:

push esp
lea esp, [esp+64]	; reset
vm_exit_patch_location:	;control flow -> resetting SP
push vm_exit_native
lea esp, [esp+0]	; reset
jmp vm_native_dispatch_2	;control flow -> resetting SP
lea esp, [esp+-60]	; new junk SP
lea esp, [esp+60]	; reset
vm_exit_native:	;control flow -> resetting SP
lea esp, [esp+0]	; reset
jmp lbl_910eec8d_a63a_47c2_b130_7dcc7e0f2fc7

lbl_c51338c6_c6e9_4a0c_a679_62ece01480c7:

push esp
; 32 bit Fowler-Noll-Vo hashing
lea esp, [esp+0]	; increment junk SP
push edi
lea esp, [esp+44]	; reset
fnv_32:	;control flow -> resetting SP
mov esi, [esp++0x04]	;buffer
mov ecx, [esp++0x08]	;length
mov eax, 0x0ce942fa	;basis
mov edi, 0x01000193	;fnv_32_prime
jmp lbl_3227dd4a_a430_49ac_a640_7c0a300312db

lbl_0fb57007_bce2_4b08_87d4_ae9839973bb6:

; end_shuffle
; Lookup table for VAs that have been manually added as jump targets
; These are placeholders only, the actual tables are patched in at runtime
va_table:
va_table_values:

```