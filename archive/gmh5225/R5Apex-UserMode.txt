Project Path: arc_gmh5225_R5Apex-UserMode_lnl8ztcy

Source Tree:

```txt
arc_gmh5225_R5Apex-UserMode_lnl8ztcy
├── Aimbot.cpp
├── ConsoleApplication1.vcxproj
├── ConsoleApplication1.vcxproj.filters
├── Driver.hpp
├── EntityLoop.cpp
├── Global.hpp
├── Includes.hpp
├── LocalPlayer.hpp
├── Main.cpp
├── Offsets.hpp
├── Players.hpp
├── R5 -UserMode.sln
└── README.md

```

`ConsoleApplication1.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{1e69c359-1524-48f9-b3e5-bc9fd067f390}</ProjectGuid>
    <RootNamespace>ConsoleApplication1</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>Reaper-Client</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <IntrinsicFunctions>true</IntrinsicFunctions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>false</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <DisableSpecificWarnings>4996;4838;4552;4005;4311;4302;26451;4556;26495;6387;6011;6054;4244;4312;4309;%(DisableSpecificWarnings)</DisableSpecificWarnings>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>winmm.lib;d3d11.lib;d3dcompiler.lib;dxgi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
      <TreatLinkerWarningAsErrors>false</TreatLinkerWarningAsErrors>
      <AdditionalOptions>/FORCE:MULTIPLE /ignore:4006 /ignore:4099 /ignore:4088 %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Aimbot.cpp" />
    <ClCompile Include="EntityLoop.cpp" />
    <ClCompile Include="intel_driver.cpp" />
    <ClCompile Include="kdmapper.cpp" />
    <ClCompile Include="Main.cpp" />
    <ClCompile Include="portable_executable.cpp" />
    <ClCompile Include="service.cpp" />
    <ClCompile Include="utils.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Driver.hpp" />
    <ClInclude Include="driver_image.hpp" />
    <ClInclude Include="Global.hpp" />
    <ClInclude Include="Includes.hpp" />
    <ClInclude Include="intel_driver.hpp" />
    <ClInclude Include="intel_driver_resource.hpp" />
    <ClInclude Include="kdmapper.hpp" />
    <ClInclude Include="LocalPlayer.hpp" />
    <ClInclude Include="nt.hpp" />
    <ClInclude Include="Players.hpp" />
    <ClInclude Include="portable_executable.hpp" />
    <ClInclude Include="service.hpp" />
    <ClInclude Include="Offsets.hpp" />
    <ClInclude Include="utils.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`ConsoleApplication1.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Libraries">
      <UniqueIdentifier>{9dd1de55-8c48-4d47-8c2c-50ac216f774c}</UniqueIdentifier>
    </Filter>
    <Filter Include="SDK">
      <UniqueIdentifier>{7296e2d5-c289-45c6-b388-f0565ae19d9e}</UniqueIdentifier>
    </Filter>
    <Filter Include="SDK\Classes">
      <UniqueIdentifier>{84da7db9-3011-44a7-a7d4-bfcb7d3a7d20}</UniqueIdentifier>
    </Filter>
    <Filter Include="Libraries\KdMapper">
      <UniqueIdentifier>{32796389-28c1-4744-9998-98414d5b9c83}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="EntityLoop.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Aimbot.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="kdmapper.cpp">
      <Filter>Libraries\KdMapper</Filter>
    </ClCompile>
    <ClCompile Include="intel_driver.cpp">
      <Filter>Libraries\KdMapper</Filter>
    </ClCompile>
    <ClCompile Include="portable_executable.cpp">
      <Filter>Libraries\KdMapper</Filter>
    </ClCompile>
    <ClCompile Include="service.cpp">
      <Filter>Libraries\KdMapper</Filter>
    </ClCompile>
    <ClCompile Include="utils.cpp">
      <Filter>Libraries\KdMapper</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Includes.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Players.hpp">
      <Filter>SDK\Classes</Filter>
    </ClInclude>
    <ClInclude Include="Global.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="driver_image.hpp">
      <Filter>Libraries\KdMapper</Filter>
    </ClInclude>
    <ClInclude Include="utils.hpp">
      <Filter>Libraries\KdMapper</Filter>
    </ClInclude>
    <ClInclude Include="service.hpp">
      <Filter>Libraries\KdMapper</Filter>
    </ClInclude>
    <ClInclude Include="portable_executable.hpp">
      <Filter>Libraries\KdMapper</Filter>
    </ClInclude>
    <ClInclude Include="nt.hpp">
      <Filter>Libraries\KdMapper</Filter>
    </ClInclude>
    <ClInclude Include="kdmapper.hpp">
      <Filter>Libraries\KdMapper</Filter>
    </ClInclude>
    <ClInclude Include="intel_driver_resource.hpp">
      <Filter>Libraries\KdMapper</Filter>
    </ClInclude>
    <ClInclude Include="intel_driver.hpp">
      <Filter>Libraries\KdMapper</Filter>
    </ClInclude>
    <ClInclude Include="Driver.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="LocalPlayer.hpp">
      <Filter>SDK\Classes</Filter>
    </ClInclude>
    <ClInclude Include="Offsets.hpp">
      <Filter>SDK</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Driver.hpp`:

```hpp

PVOID(NTAPI* NtConvertBetweenAuxiliaryCounterAndPerformanceCounter)(PVOID, PVOID, PVOID, PVOID);

enum Code {
	Complete,
	BaseRequest,
	SizeRequest,
	PebRequest,
	QIPRequest,
	CopyRequest,
	AVMRequest,
	FVMRequest,
	PVMRequest,
	QVMRequest,
	ModuleRequest,
	IndexRequest,
};

enum Status {
	Inactive,
	Active,
	Waiting,
	Exit
};

typedef struct OperationData {

	struct {
		char* Name;
		DWORD	Id;
		PVOID	BaseAddress;
		SIZE_T  Size;
		PPEB	Peb;
		PROCESS_BASIC_INFORMATION PBI;
	} Process;

	struct {
		SIZE_T Size;
		SIZE_T ReturnLength;

		struct {
			ULONG64 Address;
			PVOID Buffer;
			BOOLEAN	ReadOperation;
		} Copy;

		struct {
			ULONG64 Address;
			ULONG64 Buffer;
			BOOLEAN	ReadOperation;
		} Copy2;

		PVOID Base;
		DWORD AllocType;
		DWORD FreeType;
		DWORD Protect;
		DWORD OldProtect;
		MEMORY_BASIC_INFORMATION MBI;
	} Memory;

	struct {
		PVOID BaseAddress;
		SIZE_T SizeOfImage;
		int Index;
	} Module;
};

typedef struct CommunicationData {

	DWORD	ProcessId;
	PVOID	SharedMemory;
	DWORD* pCode;
	SHORT* pStatus;
	DWORD	Magic;
};

namespace SharedMemory {

	CommunicationData Data{ 0 };
	INT Queue{ 0 };


	void PushQueue() {
		Queue += 1;
	}

	void PopQueue() {
		Queue -= 1;
	}

	BOOL WriteSharedMemory(PVOID Address, PVOID Value, SIZE_T Size) {
		return reinterpret_cast<BOOL>(memcpy(Address, Value, Size));
	}

	template <typename T>
	T ReadSharedMemory(PVOID Address, SIZE_T Size = sizeof(T)) {
		T Ret{ 0 };
		memcpy(static_cast<PVOID>(&Ret), Address, Size);
		return Ret;
	}

	BOOL SetStatus(Status Status) {
		return WriteSharedMemory(Data.pStatus, &Status, sizeof(SHORT));
	}

	BOOL SetCode(DWORD Code) {
		return WriteSharedMemory(Data.pCode, &Code, sizeof(DWORD));
	}

	BOOL SetBuffer(OperationData Buffer) {
		return WriteSharedMemory(Data.SharedMemory, &Buffer, sizeof(OperationData));
	}

	Status GetStatus() {
		return static_cast<Status>(ReadSharedMemory<SHORT>(Data.pStatus));
	}

	DWORD GetCode() {
		return ReadSharedMemory<DWORD>(Data.pCode);
	}

	OperationData GetBuffer() {
		return ReadSharedMemory<OperationData>(Data.SharedMemory);
	}

	BOOL SendRequest(Code Request, OperationData Data) {

		do {
			Sleep(10);
		} while (GetCode() != Complete
			|| GetStatus() != Active
			|| Queue >= 1);

		PushQueue();

		if (SetBuffer(Data)) {
			if (SetCode(Request)) {
				if (SetStatus(Waiting)) {

					do {
						Sleep(10);
					} while (GetCode() != Complete || GetStatus() != Active);

					PopQueue();
					return true;
				}
			}
		}

		PopQueue();
		return false;
	}

	void Connect(CommunicationData InitData) {
		Data = InitData;
		SetStatus(Active);
		SetCode(Complete);
	}

	void Disconnect() {
		SetStatus(Exit);
	}
};

namespace Client {
	bool ErrorFlag{ false };

	void KernelThread(PVOID LParam) {
		INT64 Status{ 0 };

		CommunicationData Data{ *(CommunicationData*)LParam };
		PVOID pData{ &Data };

		HMODULE Module{ LoadLibrary("ntdll.dll") };

		if (!Module) {
			return;
		}

		*(PVOID*)&NtConvertBetweenAuxiliaryCounterAndPerformanceCounter = GetProcAddress(Module, "NtConvertBetweenAuxiliaryCounterAndPerformanceCounter");

		if (!NtConvertBetweenAuxiliaryCounterAndPerformanceCounter) {
			ErrorFlag = true;
			return;
		}
		
		NtConvertBetweenAuxiliaryCounterAndPerformanceCounter((PVOID)1, &pData, &Status, nullptr);

	}

	void Connect() {
		CommunicationData Data{ 0 };

		PVOID Memory{ VirtualAlloc(nullptr,
					   sizeof(OperationData) * 2,
					   MEM_COMMIT | MEM_RESERVE,
					   PAGE_READWRITE) };

		if (!Memory) {
			return;
		}

		Data.ProcessId = GetCurrentProcessId();
		Data.SharedMemory = Memory;
		Data.pCode = (DWORD*)Memory + sizeof(OperationData);
		Data.pStatus = (SHORT*)Data.pCode + 8;
		Data.Magic = 0x999;

		CreateThread(nullptr, 0, (LPTHREAD_START_ROUTINE)KernelThread, &Data, 0, nullptr);

		Sleep(500);

		if (ErrorFlag) {
			printf(("[!] Error Connecting\n"));
			getchar();
			exit(0);
		}

		SharedMemory::Connect(Data);
		printf(("[+] Driver connection established\n"));
	}

	void Disconnect() {
		SharedMemory::Disconnect();
	}
}

class Driver
{
public:
	DWORD PID;
	DWORD GetProcessID(LPCWSTR process_name)
	{
		HANDLE handle = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
		DWORD process_id = NULL;

		if (handle == INVALID_HANDLE_VALUE)
			return process_id;

		PROCESSENTRY32W entry = { 0 };
		entry.dwSize = sizeof(PROCESSENTRY32W);

		if (Process32FirstW(handle, &entry)) {
			if (!_wcsicmp(process_name, entry.szExeFile))
			{
				process_id = entry.th32ProcessID;
			}
			else while (Process32NextW(handle, &entry))
			{
				if (!_wcsicmp(process_name, entry.szExeFile))
				{
					process_id = entry.th32ProcessID;
				}
			}
		}
		CloseHandle(handle);
		return process_id;
	}

	template <typename T>
	void Write(UINT_PTR dwAddress, T value)
	{
		OperationData opData = {};
		opData.Memory.Size = sizeof(T);
		opData.Memory.Copy.Address = dwAddress;
		opData.Memory.Copy.Buffer = &value;
		opData.Memory.Copy.ReadOperation = false;

		if (!SharedMemory::SendRequest(CopyRequest, opData))
		{
			printf("[!] Error writing memory\n");
		}

	}

	template <typename T>
	T Read(UINT_PTR dwAddress)
	{
		OperationData opData = {};
		opData.Memory.Size = sizeof(T);
		opData.Memory.Copy.Address = dwAddress;
		opData.Memory.Copy.Buffer = &opData.Memory.Copy.Buffer;
		opData.Memory.Copy.ReadOperation = true;

		if (SharedMemory::SendRequest(CopyRequest, opData))
		{

			return*(T*)opData.Memory.Copy.Buffer;
		}
		else
		{
			printf(("[!] Error reading memory\n"));
			return T{};
		}

	}

	ULONG64 GetBaseAddress(LPCSTR module_name)
	{
		if (module_name && PID)
		{
			OperationData Data{ 0 };
			Data.Process.Id = PID;

			if (SharedMemory::SendRequest(BaseRequest, Data)) {
				return reinterpret_cast<ULONG64>(SharedMemory::GetBuffer().Process.BaseAddress);
			}
		}
		return 0;
	}

	bool readEx(ULONG64 read_address, ULONG64 target_address, ULONG64 size)
	{
		OperationData Data{};
		Data.Process.Id = PID;
		Data.Memory.Copy2.Address = read_address;
		Data.Memory.Copy2.Buffer = (ULONG64)target_address;
		Data.Memory.Size = size;
		Data.Memory.Copy2.ReadOperation = true;

		SharedMemory::SendRequest(CopyRequest, Data);

		return true;
	}

	template<typename t> t
		readChain(uintptr_t address, std::vector<uint64_t> chain)
	{
		uintptr_t current = address;

		for (int i = 0; i < chain.size() - 1; i++)
		{
			current = Read<uintptr_t>(current + chain[i]);
		}

		return Read<t>(current + chain[chain.size() - 1]);
	}

	std::string ReadString(DWORD64 address)
	{
		std::string str;
		char c = '\0';
		do {
			c = Read<char>(address);
			if (c != '\0') {
				str += c;
			}
			address++;
		} while (c != '\0');

		return str;
	}

	

}rDriver;

```

`EntityLoop.cpp`:

```cpp
#include "Includes.hpp"

int EntityLoop()
{
	std::mutex thread_lock;

	thread_lock.lock();
	while (true)
	{
		

		if (ValidPointer(globals.LocalPlayer))
			continue;

		for (int i = 0; i < 100; i++) { 
			DWORD64 Entity = Aplayers.GetEntityById(i, globals.BaseAddress);
			if (Entity == 0) 
				continue;
			DWORD64 EntityHandle = rDriver.Read<DWORD64>(Entity + 0x500);

			std::string Identifier = rDriver.ReadString(EntityHandle);
			LPCSTR IdentifierC = Identifier.c_str();

			if (strcmp(IdentifierC, "player")) 
				Aplayers.HighlightEnable(Entity, 120.f, 0.f, 0.f);
		}
		
		std::this_thread::sleep_for(std::chrono::milliseconds(1500));
	}
	thread_lock.unlock();

	return -1;
}
```

`Global.hpp`:

```hpp

class Globals
{
public:
	DWORD PID;
	uint64_t BaseAddress;
	uint64_t LocalPlayer;
	DWORD64 EntityList;


}globals;


int EntityLoop();
```

`Includes.hpp`:

```hpp
#pragma once
#define WIN32_LEAN_AND_MEAN

/*-------Windows-------*/
#include <windows.h>
#include <winternl.h>
#include <iostream>
#include <TlHelp32.h>
#include <thread>
#include <vector>
#include <array>
#include <mutex>
#include <string>
#include <fstream>
#include <filesystem>
#include <cstdlib>
#include <codecvt>
#include <algorithm>
#include <xmmintrin.h>
#include <emmintrin.h>
#include <urlmon.h>
#include <mmsystem.h>

#pragma comment(lib, "urlmon.lib")

inline auto ValidPointer(uintptr_t pointer) -> bool
{
    return (pointer && pointer > 0xFFFFFF && pointer < 0x7FFFFFFFFFFF);
}


/*-----Driver-----*/

/*-------KdMapper-------*/
#include "kdmapper.hpp"

/*-----Misc-----*/
#include "Driver.hpp"
#include "Offsets.hpp"
#include "Global.hpp"
#include "Players.hpp"















```

`LocalPlayer.hpp`:

```hpp
#pragma once

class LocalPlayer
{
public:

	void NoRecoil(bool on)
	{
		if (on)
		{
			//Do No Recoil
		}
		else if (!on)
		{
			
		}
	}
	


}localplayer;
```

`Main.cpp`:

```cpp
#include "Includes.hpp"

bool DriverInit()
{
    for (int i = 0; i < 2; i++)
    {
        SetUnhandledExceptionFilter(kdmapper::SimplestCrashHandler);

        kdmapper::iqvw64e_device_handle = intel_driver::Load();

        if (kdmapper::iqvw64e_device_handle == INVALID_HANDLE_VALUE) return -1;

        if (!kdmapper::MapDriver(kdmapper::iqvw64e_device_handle, raw_image.data(), 0, 0, false, true, false, false, kdmapper::callbackExample, 0))
        {
            intel_driver::Unload(kdmapper::iqvw64e_device_handle);
            return -1;
        }
        intel_driver::Unload(kdmapper::iqvw64e_device_handle);
        return 1;
    }
}

int main()
{
    std::mutex thread_lock;
    thread_lock.lock();
   
    if (!FindWindow(NULL, L"Apex Legends") && DriverInit())
    {
        Client::Connect();
        Sleep(15000); //Sleeping for 15seconds

    }
    else
    {
        printf("[!] APEX FOUND OPEN WHILE MAPPING DRIVER CLOSE APEX BEFORE\n");
        Sleep(2500);

    }

    globals.PID = rDriver.GetProcessID(L"r5apex.exe");
    globals.BaseAddress = rDriver.GetBaseAddress("r5apex.exe");
    globals.LocalPlayer = rDriver.Read<uintptr_t>(globals.BaseAddress + Offsets::main.local_player);

    
     printf("[+] PID FOUND -> %d", globals.PID);
     printf("[+] PID FOUND -> %p", globals.BaseAddress);
     printf("[+] PID FOUND -> %p", globals.BaseAddress);
    
   

    if (globals.BaseAddress)
    {
        EntityLoop();
    }
   
    
    thread_lock.unlock();
    Client::Disconnect();
    return -1;
}



```

`Offsets.hpp`:

```hpp
#pragma once

namespace Offsets
{
	struct Main
	{
		uintptr_t client_render_targets = 0x1dae758;
		uintptr_t ibase_client_dll =      0x1b13f90;
		uintptr_t iclient_entity_list =   0x1b2e707;
		uintptr_t cprediction =                 0x0;
		uintptr_t iv_model_render =             0x0;
		uintptr_t vgui_system =                 0x0;
		uintptr_t iv_render_view =        0x1357d28;
		uintptr_t iv_debug_overlay =            0x0;
		uintptr_t iv_model_info_client =        0x0;
		uintptr_t iv_engine_client =            0x0;
		uintptr_t iv_engine_trace =             0x0;
		uintptr_t inetwork_string_table =       0x0;
		uintptr_t cinput =                      0x0;
		uintptr_t cengine =                     0x0;
		uintptr_t iswapchain =            0xbaf8438;
		uintptr_t cl_entitylist =               0x0;
		uintptr_t local_entity_handle =         0x0;
		uintptr_t local_player =          0x7736b40;
		uintptr_t global_vars =           0x134c768;
		uintptr_t name_list =             0xbbde7b0;
		uintptr_t view_render =            0x5472a3;
		uintptr_t view_matrix =                 0x0;
		uintptr_t client_state =          0x144dd80;
		uintptr_t sign_on_state =         0x144de18;
		uintptr_t level_name =            0x144df40;
		uintptr_t glow_enable =               0x480;
		uintptr_t glow_type =                 0x2c0;
		uintptr_t glow_color =                0x1d0;
	}main;



}
```

`Players.hpp`:

```hpp
#pragma once

//using namespace Offsets;

class ApexPlayers
{
public:

	

	DWORD64 GetEntityById(int Ent, DWORD64 Base)
	{

		DWORD64 EntityList = Base + 0x1b2e708; //Testing
		DWORD64 BaseEntity = rDriver.Read<DWORD64>(EntityList); 
		if (!BaseEntity) 
			return NULL;

		return rDriver.Read<DWORD64>(EntityList + (Ent << 5));
	}
	void HighlightEnable(DWORD64 Entity, float r, float g, float b) {

		

		rDriver.Write<bool>(Entity + Offsets::main.glow_enable, true);
		rDriver.Write<int>(Entity + Offsets::main.glow_type + 4, 1);
		rDriver.Write<float>(Entity + Offsets::main.glow_color, r);
		rDriver.Write<float>(Entity + Offsets::main.glow_color + 4, g);
		rDriver.Write<float>(Entity + Offsets::main.glow_color + 8, b); 

		for (int offset = 0x2B0; offset <= 0x2C8; offset += 0x4)
			rDriver.Write<float>(Entity + offset, FLT_MAX);
		
		rDriver.Write<float>(Entity + 0x2DC, FLT_MAX);
	}

	
}Aplayers;
```

`R5 -UserMode.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.4.33213.308
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Reaper-Client", "ConsoleApplication1.vcxproj", "{1E69C359-1524-48F9-B3E5-BC9FD067F390}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{1E69C359-1524-48F9-B3E5-BC9FD067F390}.Debug|x64.ActiveCfg = Debug|x64
		{1E69C359-1524-48F9-B3E5-BC9FD067F390}.Debug|x64.Build.0 = Debug|x64
		{1E69C359-1524-48F9-B3E5-BC9FD067F390}.Debug|x86.ActiveCfg = Debug|Win32
		{1E69C359-1524-48F9-B3E5-BC9FD067F390}.Debug|x86.Build.0 = Debug|Win32
		{1E69C359-1524-48F9-B3E5-BC9FD067F390}.Release|x64.ActiveCfg = Release|x64
		{1E69C359-1524-48F9-B3E5-BC9FD067F390}.Release|x64.Build.0 = Release|x64
		{1E69C359-1524-48F9-B3E5-BC9FD067F390}.Release|x86.ActiveCfg = Release|Win32
		{1E69C359-1524-48F9-B3E5-BC9FD067F390}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {0C180CDA-1222-4FFB-B987-A9EC13EA8564}
	EndGlobalSection
EndGlobal

```

`README.md`:

```md
# R5Apex-Usermode External Made by ME if you have any question DISCORD: KIZZY#2684                

IF THIS DOES GOOD ILL PUBLISH THE SHARED MEMORY SOURCE ASWELL

!THIS IS FOR EDUCATIONAL USE ONLY!

#Notes
You will need to map your own driver and if you want to use 
my DriverInit() you will have to use ur own kdMapper

#FEATURES
Shared Memory Driver Communication
Basic Reading and writing with shared Memory
Good Clean Code
Glow Cheat by manipulating bloodhounds glow
we also enable highlights for the glow so it can be brighter



```