Project Path: arc_gmh5225_cstrike2-hack_vx4v3tdw

Source Tree:

```txt
arc_gmh5225_cstrike2-hack_vx4v3tdw
├── Cargo.toml
├── LICENSE
├── README.md
├── cheat
│   ├── Cargo.toml
│   └── src
│       ├── common.rs
│       ├── core
│       │   ├── bootstrap
│       │   │   └── mod.rs
│       │   ├── hooks
│       │   │   └── mod.rs
│       │   ├── mod.rs
│       │   ├── settings
│       │   │   └── mod.rs
│       │   └── ui
│       │       └── mod.rs
│       ├── cs2
│       │   ├── interfaces
│       │   │   ├── engine_client.rs
│       │   │   └── mod.rs
│       │   ├── mod.rs
│       │   └── modules
│       │       └── mod.rs
│       ├── entry_point.rs
│       └── utils
│           ├── hook_system
│           │   └── mod.rs
│           ├── mod.rs
│           ├── module_handler
│           │   └── mod.rs
│           └── render
│               ├── dx11
│               │   └── mod.rs
│               ├── fonts
│               │   ├── mod.rs
│               │   └── tahoma.ttf
│               ├── mod.rs
│               └── win32
│                   └── mod.rs
├── egui
│   ├── egui-directx11
│   │   ├── Cargo.toml
│   │   ├── README.md
│   │   └── src
│   │       ├── backup.rs
│   │       ├── lib.rs
│   │       ├── mesh.rs
│   │       ├── painter.rs
│   │       ├── shader
│   │       │   ├── mod.rs
│   │       │   ├── pixel.bin
│   │       │   ├── shader.hlsl
│   │       │   └── vertex.bin
│   │       └── texture.rs
│   └── egui-win32
│       ├── Cargo.toml
│       ├── README.md
│       └── src
│           └── lib.rs
├── macros
│   └── memory
│       ├── Cargo.toml
│       └── src
│           ├── lib.rs
│           ├── vfunc.rs
│           └── vmt.rs
└── rustfmt.toml

```

`Cargo.toml`:

```toml
[workspace]
resolver = "2"
members = ["cheat", "egui/egui-directx11", "egui/egui-win32", "macros/memory"]

[workspace.dependencies]
windows = "0.51.1"

[workspace.lints.clippy]

```

`LICENSE`:

```
MIT License

Copyright (c) 2024 William

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# CS2 Internal Cheat Base ![CS2](https://img.shields.io/badge/game-CS2-blue) ![LIC](https://img.shields.io/github/license/W1lliam1337/digital-sdk) ![LANG](https://img.shields.io/badge/language-rust-orange)
![App menu](https://i.imgur.com/1zwp21N.png)

## Overview
CS2 Internal Cheat Base is a Rust-based internal cheat framework for Counter-Strike 2 (CS2). Designed with modularity and performance in mind, this project provides a solid foundation for developing various cheat features. The framework supports dynamic interface access and module management, making it an ideal starting point for internal cheat development.

## Features
- **Rust Implementation:** Utilizes Rust for its performance and safety features, ensuring a reliable codebase.
- **Modular Design:** Organizes game interfaces and components into separate modules for easy management and extension.
- **Interface Handling:** Automates the creation and access of game interfaces with macros, reducing boilerplate code.
- **Pattern Searching:** Implements dynamic pattern searching for locating functions and data structures in memory.
- **DirectX11 Integration**: Built-in support for rendering overlays using DirectX11.
- **MinHook Integration**: Uses the MinHook library for function hooking.

## Getting Started
- **Clone the repository**:
```
git clone https://github.com/W1lliam1337/cstrike2-hack.git
cd cstrike2-hack
```
- **Install Rust**: Ensure you have Rust installed. If not, install it from rust-lang.org.
- **Build the project:**
```
cargo build --release
```
- **Run the project**:
Inject the compiled binary into the CS2 process using your preferred DLL injector.

## Usage:
- The in-game menu can be toggled with the `Insert` key.
- Extend the project by implementing additional features using the provided hooks and patterns.

## Contributions:
We welcome contributions! Feel free to open issues or submit pull requests for improvements and new features.

## Contact:
For any inquiries, contact https://en1gma.tech/ & https://t.me/animstate.

## License
This project is licensed under the **MIT License**. See the LICENSE file for more details.

```

`cheat/Cargo.toml`:

```toml
[package]
name = "cs2_internal"
version = "0.1.0"
edition = "2021"
description = "An internal cheat base for Counter-Strike 2 (CS2) written in Rust."
license = "MIT"
repository = "https://github.com/W1lliam1337/cstrike2-hack"
homepage = "https://github.com/W1lliam1337/cstrike2-hack"
readme = "README.md"
keywords = ["cs2", "cheat", "rust", "internal"]
categories = ["game-development", "graphics"]

[lints]
workspace = true

[lib]
crate-type = ["cdylib"]
path = "src/entry_point.rs"

[dependencies]
minhook-sys = "0.1.1"
lazy_static = "1.5"
once_cell = "1.19"
paste = "1.0"
egui = { version = "0.22.0", features = ["mint"] }
egui-directx11 = { path = "../egui/egui-directx11" }
egui-win32 = { path = "../egui/egui-win32" }
memory_macros = { path = "../macros/memory" }
anyhow = "1.0.75"
parking_lot = "0.12.1"
tracing = "0.1.40"
tracing-subscriber = "0.3.18"
thiserror = "1.0.63"
iced-x86 = "1.21.0"

[dependencies.windows]
version = "0.51.0"
features = [
    "Win32_Foundation",
    "Win32_System_SystemServices",
    "Win32_UI_WindowsAndMessaging",
    "Win32_System_Console",
    "Win32_System_LibraryLoader",
    "Win32_System_Threading",
    "Win32_Graphics_Direct3D11",
    "Win32_Graphics_Direct3D",
    "Win32_Graphics_Dxgi",
    "Win32_Graphics_Dxgi_Common",
    "Win32_System_ProcessStatus",
    "Win32_Security",
]

```

`cheat/src/common.rs`:

```rs
pub use std::{
    ffi::{c_char, c_int, c_void, CString},
    mem::{size_of, transmute},
    slice,
    sync::Once,
    sync::OnceLock,
};

pub use parking_lot::Mutex;
pub use std::ptr::{from_mut, null_mut};

/// A macro to cast a raw pointer to a specific type.
///
/// This macro provides a convenient way to cast a raw pointer to either a mutable or immutable type.
/// It supports two forms:
///
/// 1. `(mut $address:expr, $type:ident)`: This form casts the mutable raw pointer `$address` to a mutable pointer of type `$type`.
/// 2. `($address:expr, $type:ident)`: This form casts the immutable raw pointer `$address` to a const pointer of type `$type`.
///
/// # Examples
///
/// ```rust
/// let mut int_ptr = 0x12345678 as *mut i32;
/// let float_ptr = cast!(int_ptr, f32);
///
/// let const_int_ptr = 0x87654321 as *const i32;
/// let const_float_ptr = cast!(const_int_ptr, f32);
/// ```
#[macro_export]
macro_rules! cast {
    // Value cast
    (mut $address:expr, $type:ident) => {
        $address as *mut $type
    };
    ($address:expr, $type:ident) => {
        $address as *const $type
    };
}

```

`cheat/src/core/bootstrap/mod.rs`:

```rs
use anyhow::Context;
use tracing::Level;
use tracing_subscriber::FmtSubscriber;

use crate::{
    core::hooks,
    cs2::{self},
    utils::render,
};

fn init_tracing() -> anyhow::Result<()> {
    let subscriber =
        FmtSubscriber::builder().with_max_level(Level::TRACE).with_ansi(false).finish();

    tracing::subscriber::set_global_default(subscriber)
        .context("failed to set global default tracing subscriber")?;

    Ok(())
}

/// Initializes the core components of the cheat.
///
/// This function sets up the necessary modules, rendering, and hooks for the cheat to function.
///
/// # Parameters
///
/// None.
///
/// # Returns
///
/// * `Result<(), anyhow::Error>`:
///   - `Ok(())`: Indicates that the initialization was successful.
///   - `Err(e)`: Returns an error if any of the initialization steps fail. The error type is `anyhow::Error`.
///
/// # Errors
///
/// This function may return the following errors:
///
/// * `anyhow::Error`: If any of the initialization steps (`initialize_modules`, `setup`, `initialize_hooks`) fail.
pub fn initialize() -> anyhow::Result<()> {
    tracing::info!("initializing core components...");

    init_tracing().context("failed to initialize tracing")?;

    cs2::modules::initialize_modules(&["client.dll", "engine2.dll", "gameoverlayrenderer64.dll"])
        .context("failed to initialize modules")?;

    render::setup().context("failed to setup renderer")?;

    hooks::initialize_hooks().context("failed to initialize hooks")?;

    Ok(())
}

```

`cheat/src/core/hooks/mod.rs`:

```rs
use crate::{
    create_hook,
    cs2::{self},
    get_original_fn,
    utils::{self, hook_system, render},
};

use anyhow::{bail, Context};

use windows::{
    core::HRESULT,
    Win32::Graphics::Dxgi::{Common::DXGI_FORMAT, IDXGISwapChain},
};

extern "system" fn hk_present(
    swapchain: IDXGISwapChain,
    sync_interval: u32,
    flags: u32,
) -> HRESULT {
    get_original_fn!(hk_present, original_fn, (IDXGISwapChain, u32, u32), HRESULT);

    render::dx11::init_from_swapchain(&swapchain);

    original_fn(swapchain, sync_interval, flags)
}

extern "system" fn hk_resize_buffers(
    swapchain: IDXGISwapChain,
    buffer_count: u32,
    width: u32,
    height: u32,
    new_format: DXGI_FORMAT,
    swapchain_flags: u32,
) -> HRESULT {
    get_original_fn!(
        hk_resize_buffers,
        original_fn,
        (IDXGISwapChain, u32, u32, u32, DXGI_FORMAT, u32),
        HRESULT
    );

    let mut renderer = render::dx11::DX11
        .get()
        .expect("dx11 renderer is not initialized while resizing buffers")
        .lock();

    renderer
        .resize_buffers(&swapchain, || {
            original_fn(swapchain.clone(), buffer_count, width, height, new_format, swapchain_flags)
        })
        .expect("could not resize buffers")
}

unsafe extern "system" fn hk_create_move(
    a1: *mut f32,
    a2: u64,
    a3: i8,
    a4: u64,
    a5: u64,
    a6: u64,
) -> u64 {
    get_original_fn!(hk_create_move, original_fn, (*mut f32, u64, i8, u64, u64, u64), u64);

    tracing::info!("create move called");

    original_fn(a1, a2, a3, a4, a5, a6)
}

/// Initializes hooks for various game functions.
///
/// This function initializes `MinHook` and sets up hooks for the following game functions:
/// - `hk_create_move`: A hook for the game's create move function.
/// - `hk_present`: A hook for the game's present function.
/// - `hk_resize_buffers`: A hook for the game's resize buffers function.
///
/// # Errors
///
/// If `MinHook` fails to initialize, an error is returned with a message indicating the failure.
pub fn initialize_hooks() -> anyhow::Result<()> {
    // Initialize MinHook
    if let Err(status) = utils::hook_system::initialize_minhook() {
        bail!("failed to initialize MinHook: {status}");
    }

    // Find the target addresses for the game functions
    let create_move_target = cs2::modules::client()
        .find_seq_of_bytes("48 8B C4 4C 89 48 20 55")
        .context("failed to find create move pattern")?;

    let present_target = cs2::modules::gameoverlayrenderer64()
        .find_seq_of_bytes(
            "48 89 5C 24 ?? 48 89 6C 24 ?? 48 89 74 24 ?? 57 41 56 41 57 48 83 EC 20 41 8B E8",
        )
        .context("failed to find present pattern")?;

    let resize_buffers_target = cs2::modules::gameoverlayrenderer64()
        .find_seq_of_bytes(
            "48 89 5C 24 08 48 89 6C 24 10 48 89 74 24 18 57 41 56 41 57 48 83 EC 30 44",
        )
        .context("failed to find resize buffers pattern")?;

    // Create hooks for the game functions
    create_hook!(create_move_target, hk_create_move);
    create_hook!(present_target, hk_present);
    create_hook!(resize_buffers_target, hk_resize_buffers);

    Ok(())
}

```

`cheat/src/core/mod.rs`:

```rs
pub mod bootstrap;
pub mod hooks;
pub mod settings;
pub mod ui;

```

`cheat/src/core/settings/mod.rs`:

```rs
use egui::Color32;
use lazy_static::lazy_static;
use parking_lot::Mutex;

lazy_static! {
    pub static ref SETTINGS: Mutex<Settings> = Mutex::new(Settings::default());
}

#[derive(PartialEq, Eq)]
pub enum Tab {
    Visuals,
    Misc,
}

pub struct Settings {
    pub tab: Tab,

    pub visuals: VisualsSettings,
    pub misc: MiscSettings,
}

impl Default for Settings {
    fn default() -> Self {
        Self { tab: Tab::Visuals, visuals: Default::default(), misc: Default::default() }
    }
}

#[derive(Default)]
pub struct VisualsSettings {
    pub esp: EspSettings,
}

pub struct EspSettings {
    pub enabled: bool,
    pub draw_boxes: bool,
    pub box_color: Color32,
    pub draw_nametags: bool,
    pub draw_money: bool,
    pub draw_health: bool,
}

impl Default for EspSettings {
    fn default() -> Self {
        Self {
            enabled: true,
            draw_boxes: true,
            box_color: Color32::from_rgb(237, 135, 150),
            draw_nametags: true,
            draw_money: true,
            draw_health: true,
        }
    }
}

#[derive(Default)]
pub struct MiscSettings {}

```

`cheat/src/core/ui/mod.rs`:

```rs
use crate::core::settings::{Settings, Tab, VisualsSettings};

#[allow(unused_imports)]
use egui::{
    Color32, Context, Pos2, Rect, RichText, ScrollArea, Slider, Stroke, Ui, Widget, Window,
};

use std::sync::atomic::{AtomicBool, Ordering};
use windows::Win32::UI::WindowsAndMessaging::{
    WM_CHAR, WM_DEVICECHANGE, WM_KEYDOWN, WM_KEYUP, WM_KILLFOCUS, WM_LBUTTONDBLCLK, WM_LBUTTONDOWN,
    WM_LBUTTONUP, WM_MBUTTONDBLCLK, WM_MBUTTONDOWN, WM_MBUTTONUP, WM_MOUSEHWHEEL, WM_MOUSEMOVE,
    WM_MOUSEWHEEL, WM_NCMOUSELEAVE, WM_NCMOUSEMOVE, WM_RBUTTONDBLCLK, WM_RBUTTONDOWN, WM_RBUTTONUP,
    WM_SETCURSOR, WM_SETFOCUS, WM_SYSKEYDOWN, WM_SYSKEYUP, WM_XBUTTONDBLCLK, WM_XBUTTONDOWN,
    WM_XBUTTONUP,
};

static SHOW_MENU: AtomicBool = AtomicBool::new(true);

/// Toggles the visibility of the menu.
///
/// This function toggles the visibility state of the menu by reading the current value of the
/// `SHOW_MENU` atomic boolean variable and negating it. The function then updates the value of
/// `SHOW_MENU` with the new visibility state.
///
/// # Parameters
///
/// None.
///
/// # Return
///
/// None.
pub fn toggle_menu() {
    _ = SHOW_MENU.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |show_menu| Some(!show_menu));
}

/// Checks if the menu is currently visible.
///
/// This function retrieves the current visibility state of the menu by reading the value of the
/// `SHOW_MENU` atomic boolean variable. The function returns `true` if the menu is visible, and
/// `false` otherwise.
///
/// # Parameters
///
/// None.
///
/// # Return
///
/// * `bool`: A boolean value indicating the visibility state of the menu.
pub fn is_menu_visible() -> bool {
    SHOW_MENU.load(Ordering::SeqCst)
}

/// Draws the main menu window with various settings options.
///
/// This function checks if the menu is currently visible using the `is_menu_visible` function. If the menu is
/// not visible, the function returns early without drawing anything. Otherwise, it creates a new window with
/// the title "enigma euphoria" and displays it using the provided `Context`. The window contains a label
/// with a contact link, a separator, and two tabs: "visuals" and "misc". Depending on the current tab
/// selected in the `Settings` struct, the corresponding tab function (`visuals_tab` or `misc_tab`) is
/// called to draw the specific settings options for that tab.
///
/// # Parameters
///
/// * `ctx`: A reference to the `Context` struct used for drawing UI elements.
/// * `settings`: A mutable reference to the `Settings` struct containing the current settings and tab
///               selection.
pub fn draw_menu(ctx: &Context, settings: &mut Settings) {
    if !is_menu_visible() {
        return;
    }

    Window::new("enigma euphoria").show(ctx, |ui| {
        ui.label(RichText::new("contact dev: t.me/animstate").color(Color32::WHITE));
        ui.separator();

        tabs(ui, settings);

        match settings.tab {
            Tab::Visuals => visuals_tab(ui, &mut settings.visuals),
            Tab::Misc => visuals_tab(ui, &mut settings.visuals),
        }
    });
}

fn tabs(ui: &mut Ui, settings: &mut Settings) {
    ui.horizontal(|ui| {
        if ui.selectable_label(settings.tab == Tab::Visuals, "visuals").clicked() {
            settings.tab = Tab::Visuals;
        }

        if ui.selectable_label(settings.tab == Tab::Misc, "misc").clicked() {
            settings.tab = Tab::Misc;
        }
    });
}

fn visuals_tab(ui: &mut Ui, settings: &mut VisualsSettings) {
    ui.label("esp");

    ui.checkbox(&mut settings.esp.enabled, "enable");

    ui.horizontal(|ui| {
        ui.checkbox(&mut settings.esp.draw_boxes, "box");
        ui.color_edit_button_srgba(&mut settings.esp.box_color);
    });

    ui.checkbox(&mut settings.esp.draw_nametags, "name");
    ui.checkbox(&mut settings.esp.draw_health, "health");
    ui.checkbox(&mut settings.esp.draw_money, "money");
}

/// Determines whether input events should be blocked for a specific window message.
///
/// This function checks if the given window message `msg` corresponds to any of the input events
/// that should be blocked. The function returns `true` if the input event should be blocked,
/// and `false` otherwise.
///
/// # Parameters
///
/// * `msg`: A `u32` representing the window message to be checked.
///
/// # Return
///
/// * `bool`: A boolean value indicating whether the input event corresponding to the given window message
///           should be blocked.
pub fn should_block_input(msg: u32) -> bool {
    let menu_visible = SHOW_MENU.load(Ordering::SeqCst);

    menu_visible
        && matches!(
            msg,
            WM_MOUSEMOVE
                | WM_NCMOUSEMOVE
                | WM_NCMOUSELEAVE
                | WM_LBUTTONDOWN
                | WM_LBUTTONDBLCLK
                | WM_RBUTTONDOWN
                | WM_RBUTTONDBLCLK
                | WM_MBUTTONDOWN
                | WM_MBUTTONDBLCLK
                | WM_XBUTTONDOWN
                | WM_XBUTTONDBLCLK
                | WM_LBUTTONUP
                | WM_RBUTTONUP
                | WM_MBUTTONUP
                | WM_XBUTTONUP
                | WM_MOUSEWHEEL
                | WM_MOUSEHWHEEL
                | WM_KEYDOWN
                | WM_KEYUP
                | WM_SYSKEYDOWN
                | WM_SYSKEYUP
                | WM_SETFOCUS
                | WM_KILLFOCUS
                | WM_CHAR
                | WM_SETCURSOR
                | WM_DEVICECHANGE
        )
}

```

`cheat/src/cs2/interfaces/engine_client.rs`:

```rs
use memory_macros::vfunc;

pub struct EngineClient {}

impl EngineClient {
    #[vfunc(35)]
    pub fn is_in_game(&self) -> bool {}
}

```

`cheat/src/cs2/interfaces/mod.rs`:

```rs
pub mod engine_client;

use std::sync::atomic::{AtomicPtr, Ordering};

/// This macro is used to define a static reference to a specific interface provided by the game engine.
/// It initializes the interface lazily, meaning it will only be created when the function is first called.
///
/// # Parameters
///
/// - `$name`: The identifier for the interface. This will be used to name the static reference and the function.
/// - `$module_fn`: The name of the function in the `crate::cs2::modules` module that returns the game engine module.
/// - `$interface_name`: The name of the interface to be retrieved from the game engine module.
///
/// # Return
///
/// This macro does not return a value. Instead, it defines a static reference and a function as per the provided parameters.
///
/// The static reference is named `INTERFACE_$name:upper` and is of type `once_cell::sync::Lazy<super::interfaces::$name::Interface>`.
/// It is initialized using the `once_cell::sync::Lazy::new` function, which creates a new lazy-initialized value.
/// Inside the closure, the interface pointer is obtained by calling the `$module_fn` function, retrieving the interface using the `$interface_name`,
/// and then creating a new instance of `super::interfaces::$name::Interface` using the obtained interface pointer.
///
/// The function named `$name` is also defined, which returns a reference to the static reference `INTERFACE_$name:upper`.
#[macro_export]
macro_rules! define_interface {
    ($name:ident, $module_fn:ident, $interface_name:expr, $type:ty) => {
        paste::paste! {
            static [<INTERFACE_ $name:upper>]: once_cell::sync::Lazy<AtomicPtr<$type>> = once_cell::sync::Lazy::new(|| {
                let interface_ptr = $crate::cs2::modules::$module_fn()
                    .get_interface($interface_name)
                    .expect(concat!("failed to find ", $interface_name)) as *mut $type;
                AtomicPtr::new(interface_ptr)
            });

            pub fn $name() -> &'static $type {
                unsafe { &*([<INTERFACE_ $name:upper>].load(Ordering::SeqCst)) }
            }
        }
    };
}

define_interface!(engine_client, engine2, "Source2EngineToClient001", engine_client::EngineClient);

```

`cheat/src/cs2/mod.rs`:

```rs
pub mod interfaces;
pub mod modules;
pub use modules::{client, engine2, gameoverlayrenderer64, initialize_modules};

```

`cheat/src/cs2/modules/mod.rs`:

```rs
use crate::{common, utils::module_handler};
use anyhow::bail;
use common::{c_void, Mutex};

use once_cell::sync::OnceCell;
use windows::Win32::Foundation::HMODULE;

/// A `Module` represents a dynamically loaded module.
///
/// This struct provides methods to interact with the module, such as finding sequences of bytes,
/// retrieving exported functions, and obtaining interfaces.
///
/// # Fields
/// - `name`: The name of the module.
/// - `handle`: The handle to the loaded module.
#[derive(Clone, Debug)]
pub struct Module {
    /// The name of the module.
    name: &'static str,

    /// The handle to the loaded module.
    handle: HMODULE,
}

impl Module {
    /// Creates a new `Module` by loading the module with the given name.
    ///
    /// # Parameters
    /// - `name`: The name of the module to load.
    ///
    /// # Returns
    /// A new `Module` instance.
    ///
    /// # Panics
    /// This function will panic if the module cannot be loaded.
    /// The panic occurs if `module_handler::get_module_handle(name)` returns `None`.
    ///
    /// # Examples
    /// ```
    /// let module = Module::new("example.dll");
    /// ```
    #[must_use]
    pub fn new(name: &'static str) -> Self {
        let handle = module_handler::get_module_handle(name).expect("failed to get module handle");
        Self { name, handle }
    }

    /// Searches for a sequence of bytes in the module.
    ///
    /// # Parameters
    /// - `pattern`: The byte pattern to search for.
    ///
    /// # Returns
    /// The offset of the pattern if found, otherwise `None`.
    ///
    /// # Examples
    /// ```
    /// let offset = module.find_seq_of_bytes("pattern").unwrap_or(0);
    /// ```
    #[must_use]
    pub fn find_seq_of_bytes<T>(&self, pattern: &str) -> anyhow::Result<*const T> {
        module_handler::pattern_search(self.handle, pattern)
    }

    /// Retrieves the address of an exported function from the module.
    ///
    /// # Parameters
    /// - `function_name`: The name of the function to retrieve.
    ///
    /// # Returns
    /// A pointer to the function if found, otherwise `None`.
    ///
    /// # Examples
    /// ```
    /// let func_ptr = module.get_export("function_name");
    /// ```
    #[must_use]
    pub fn get_export(&self, function_name: &str) -> Option<*mut c_void> {
        module_handler::get_proc_address(self.handle, function_name)
    }

    /// Retrieves an interface from the module.
    ///
    /// # Parameters
    /// - `interface_name`: The name of the interface to retrieve.
    ///
    /// # Returns
    /// A pointer to the interface if found, otherwise `None`.
    ///
    /// # Examples
    /// ```
    /// let interface_ptr = module.get_interface("interface_name");
    /// ```
    #[must_use]
    pub fn get_interface(&self, interface_name: &str) -> Option<*const usize> {
        module_handler::get_interface(self.handle, interface_name)
    }

    /// Returns the name of the module.
    ///
    /// # Returns
    /// The name of the module.
    ///
    /// # Examples
    /// ```
    /// let module_name = module.name();
    /// ```
    #[must_use]
    pub const fn name(&self) -> &str {
        self.name
    }
}

/// A global static variable holding the list of initialized modules.
///
/// This variable is initialized only once and protected by a `Mutex` to ensure thread safety.
static MODULES: OnceCell<Mutex<Vec<Module>>> = OnceCell::new();

/// Initializes the global `MODULES` with the provided module names.
///
/// # Parameters
/// - `names`: A slice of module names to initialize.
///
/// # Returns
/// A `Result` indicating success or failure. If the initialization fails, it returns an error.
///
/// # Errors
/// - Returns an error if modules are already initialized.
/// - Panics if setting the global `MODULES` fails.
///
/// # Panics
/// This function will panic if `MODULES.set(...)` fails or if `MODULES.get()` returns `None`
/// while trying to access the modules. This can happen if the modules were not properly initialized.
///
/// # Examples
/// ```no_run
/// let result = initialize_modules(&["module1.dll", "module2.dll"]);
/// match result {
///     Ok(_) => println!("Modules initialized successfully"),
///     Err(e) => eprintln!("Failed to initialize modules: {:?}", e),
/// }
/// ```
pub fn initialize_modules(names: &[&'static str]) -> anyhow::Result<()> {
    if MODULES.get().is_some() {
        bail!("modules are already initialized");
    }

    let modules = names
        .iter()
        .map(|&name| {
            let module = Module::new(name);

            tracing::info!(
                "initialized module: {} {:p}",
                module.name,
                module.handle.0 as *const c_void
            );

            module
        })
        .collect();

    match MODULES.set(Mutex::new(modules)) {
        Ok(_) => {}
        Err(e) => bail!("failed to initialize MODULES: {e:?}"),
    }

    Ok(())
}

/// This macro generates accessor functions for static instances of the `Module` struct.
/// These functions allow easy access to the initialized modules without needing to manually manage their lifetimes.
///
/// # Arguments
///
/// * `$($name:ident),*` - A list of module names (without the ".dll" extension) for which accessor functions will be generated.
///
/// # Example
///
macro_rules! define_module_accessors {
    ($($name:ident),*) => {
        $(
            /// Accessor function for the module.
            ///
            /// # Panics
            /// Panics if the module is not initialized or if the module is not found.
            pub fn $name() -> &'static Module {
                let module_name = concat!(stringify!($name), ".dll");
                let modules_guard = MODULES.get().expect("modules are not initialized").lock();
                let module = modules_guard.iter()
                    .find(|module| module.name() == module_name)
                    .unwrap_or_else(|| {
                        panic!("module {} is not found", module_name);
                    });

                Box::leak(Box::new(module.clone()))
            }
        )*
    };
}

define_module_accessors!(client, engine2, gameoverlayrenderer64);

```

`cheat/src/entry_point.rs`:

```rs
pub mod common;
pub mod core;
pub mod cs2;
pub mod utils;

use common::{c_void, null_mut, Once};

use windows::Win32::{
    Foundation::HMODULE,
    System::{
        Console::AllocConsole,
        Threading::{CreateThread, THREAD_CREATION_FLAGS},
    },
};

/// This function is responsible for initializing the cheat.
/// It is called as a thread function when the DLL is loaded into a process.
///
/// # Parameters
///
/// None.
///
/// # Return Value
///
/// Returns a `u32` value of 0. This value is not used by the operating system.
extern "system" fn thread_startup(_: *mut c_void) -> u32 {
    match core::bootstrap::initialize() {
        Err(e) => {
            tracing::error!("init failed: {e}");
        }
        Ok(()) => {
            tracing::info!("initialized cheat successfully!");
        }
    }

    0
}

/// The `dll_main` function is the entry point for a dynamic-link library (DLL) and is called by the operating system
/// when the DLL is loaded or unloaded. It is responsible for initializing and cleaning up the DLL.
///
/// # Parameters
///
/// - `module`: A pointer to the module handle for the DLL.
/// - `reason_for_call`: An unsigned integer representing the reason for calling the function.
///   The possible values are:
///   - `1`: `DLL_PROCESS_ATTACH`: The DLL is being loaded into a process.
///   - `0`: `DLL_PROCESS_DETACH`: The DLL is being unloaded from a process.
/// - `_reserved`: A pointer to reserved data. This parameter is not used and should be ignored.
///
/// # Return Value
///
/// The function should return a boolean value indicating success. If the function returns `1`, the DLL load is
/// successful. If the function returns `0`, the DLL load is unsuccessful.
///
/// # Panics
///
/// This function will panic if creating a thread fails.
#[export_name = "DllMain"]
pub extern "system" fn dll_main(
    _module: HMODULE,
    reason_for_call: u32,
    _reserved: *mut c_void,
) -> i32 {
    match reason_for_call {
        1 => {
            /// A static initializer to ensure one-time initialization.
            static INIT: Once = Once::new();

            INIT.call_once(|| {
                // Create a thread to initialize the cheat
                // SAFETY: AllocConsole is unsafe because it involves system-level operations that can fail.
                unsafe {
                    if AllocConsole().is_err() {
                        return;
                    }
                }

                // SAFETY: CreateThread is unsafe because it involves creating a new thread at the OS level.
                match unsafe {
                    CreateThread(
                        None,                     // Security attributes
                        0,                        // Stack size
                        Some(thread_startup),     // Thread function
                        Some(null_mut()),         // Parameter to thread function
                        THREAD_CREATION_FLAGS(0), // Creation flags
                        None,                     // Thread identifier
                    )
                } {
                    Ok(_) => {
                        tracing::info!("successfully created a new thread");
                    }
                    Err(e) => {
                        tracing::error!("failed to create thread: {:?}", e);
                    }
                }
            });
        }
        0 => {
            tracing::info!("DLL unloaded");

            // TODO: Unload cheat and free resources
        }
        _ => {}
    }
    1 // TRUE
}

```

`cheat/src/utils/hook_system/mod.rs`:

```rs
use crate::common;
use anyhow::bail;
use common::{c_void, from_mut, null_mut};
use lazy_static::lazy_static;

use std::{
    collections::VecDeque,
    sync::{Arc, Mutex},
};

/// Represents a function hook.
pub struct Hook {
    /// A pointer to the target function to be hooked.
    target: *mut c_void,
    /// A pointer to the detour function.
    detour: *mut c_void,
    /// A pointer to the original function.
    original: *mut c_void,
}

lazy_static! {
    static ref TARGETS: Arc<Mutex<VecDeque<Hook>>> = Arc::new(Mutex::new(VecDeque::new()));
}

unsafe impl Send for Hook {}

impl Hook {
    /// Retrieves the original function pointer for a given detour function.
    ///
    /// # Parameters
    ///
    /// - `func`: A function that returns the detour function pointer.
    ///
    /// # Returns
    ///
    /// An optional original function pointer wrapped in `Option<R>`.
    ///
    /// # Panics
    ///
    /// This function will panic if the `TARGETS` mutex is poisoned when locked. This might occur
    /// if another thread panics while holding the lock, which is an exceptional case in normal use.
    ///
    /// # Errors
    ///
    /// No errors are returned by this function, but note that the presence of `None` in the return type
    /// indicates that the original function was not found.
    pub fn get_proto_original<F, R>(func: F) -> Option<R>
    where
        F: Fn() -> *mut c_void,
        R: From<*mut c_void>,
    {
        let targets =
            TARGETS.lock().inspect_err(|err| tracing::error!("TARGETS is poisoned: {err}")).ok()?;

        targets.iter().find(|hook| hook.detour == func()).map(|hook| R::from(hook.original))
    }

    /// Hooks a target function with a detour function.
    ///
    /// # Parameters
    ///
    /// - `target`: A pointer to the target function.
    /// - `detour`: A pointer to the detour function.
    ///
    /// # Returns
    ///
    /// `true` if the hook was successfully created and enabled, `false` otherwise.
    ///
    /// # Panics
    ///
    /// Panics if it fails to lock the `TARGETS` mutex.
    #[must_use]
    pub fn hook(target: *const c_void, detour: *const c_void) -> bool {
        let Ok(mut targets) = TARGETS.lock() else {
            tracing::error!("failed to lock TARGETS");
            return false;
        };

        let mut hk =
            Self { target: target.cast_mut(), detour: detour.cast_mut(), original: null_mut() };

        // SAFETY: Creating the hook with MinHook library.
        let create_hook_result =
            unsafe { minhook_sys::MH_CreateHook(hk.target, hk.detour, from_mut(&mut hk.original)) };

        if create_hook_result == 0 {
            // SAFETY: Enabling the hook with MinHook library.
            unsafe {
                minhook_sys::MH_EnableHook(hk.target);
            }

            targets.push_back(hk);

            true
        } else {
            false
        }
    }
}

/// Initializes the `MinHook` library.
///
/// # Returns
///
/// Returns an `anyhow::Result` indicating success or failure. On success, it returns `Ok(())`. On failure, it returns an `Err` with a description of the error.
///
/// # Errors
///
/// - Returns an `Err` with a description if `MinHook` fails to initialize.
///
/// # Panics
///
/// This function does not panic, but it relies on `minhook_sys::MH_Initialize`, which may potentially fail.
pub fn initialize_minhook() -> anyhow::Result<()> {
    // Safety: We are calling an external C library function that initializes MinHook.
    // The function `MH_Initialize` is expected to return 0 on success and a non-zero value on failure.
    // We assume the library's documentation and contract are correct, and we handle the error accordingly.
    if unsafe { minhook_sys::MH_Initialize() } != 0 {
        bail!("failed to initialize MinHook");
    }

    tracing::info!("MinHook initialized successfully");

    Ok(())
}

#[macro_export]
macro_rules! create_hook {
    ($target_function:ident, $detour_function:ident) => {
        let target_function = $target_function as *const std::ffi::c_void;
        let detour_function_ptr = $detour_function as *const std::ffi::c_void;

        tracing::info!("hooking target function: {target_function:p}");

        if !hook_system::Hook::hook(target_function, detour_function_ptr) {
            bail!("failed to enable hook");
        }
    };
}

/// This macro is used to generate a function that retrieves the original function pointer of a hooked function.
///
/// # Parameters
///
/// * `$hook_name:ident` - The identifier of the hook to retrieve the original function pointer from.
/// * `$fn_name:ident` - The identifier of the generated function that will hold the original function pointer.
/// * `($($arg:ty),*)` - The types and names of the function's parameters.
/// * `$ret:ty` - The return type of the function.
///
/// # Return
///
/// The macro generates a function named `$fn_name` that takes the same parameters and return type as the original function.
/// This function retrieves the original function pointer from the specified hook and transmutes it to the appropriate function type.
/// The original function pointer is then returned.
#[macro_export]
macro_rules! get_original_fn {
    ($hook_name:ident, $fn_name:ident, ($($arg:ty),*), $ret:ty) => {
        // Safety: The `hook_system::Hook::get_proto_original` function is assumed to return a valid function pointer
        // for the specified hook. The `transmute` operation is safe here because the pointer is expected to be valid
        // and the type of the function signature matches the expected type.
        // The correctness of this operation depends on the implementation of `Hook::get_proto_original` and
        // the assumption that the function pointer returned is correctly typed and valid.
        let $fn_name: extern "system" fn($($arg),*) -> $ret = unsafe {
            std::mem::transmute::<
                *mut std::ffi::c_void,
                extern "system" fn($($arg),*) -> $ret,
            >(hook_system::Hook::get_proto_original(|| $hook_name as *mut std::ffi::c_void).unwrap())
        };
    };
}

```

`cheat/src/utils/mod.rs`:

```rs
pub mod hook_system;
pub mod module_handler;
pub mod render;

use windows::Win32::{
    Foundation::{BOOL, FALSE, HWND, LPARAM, TRUE},
    System::{Console::GetConsoleWindow, Threading::GetCurrentProcessId},
    UI::WindowsAndMessaging::{
        EnumWindows, GetWindow, GetWindowThreadProcessId, IsWindowVisible, GW_OWNER,
    },
};

/// Determines whether a given window is the main window of the current process.
///
/// This function checks if the specified window is a top-level window, has no owner, and is visible.
/// It is intended to be used as a helper function for identifying the main window of the current process.
///
/// # Parameters
///
/// * `window`: A handle to the window to be checked.
///
/// # Returns
///
/// * `true` if the specified window is the main window of the current process.
/// * `false` if the specified window is not the main window of the current process.
unsafe fn is_main_window(window: HWND) -> bool {
    GetWindow(window, GW_OWNER).0 == 0 && IsWindowVisible(window).into()
}

/// An unsafe extern "system" function used as a callback for the `EnumWindows` function.
/// This function is intended to identify the main window of the current process.
///
/// # Parameters
///
/// * `window`: A handle to the window being enumerated.
/// * `lparam`: A pointer to a mutable memory location where the function can store the handle to the main window.
///
/// # Returns
///
/// * `BOOL`: A boolean value indicating whether the enumeration should continue.
///   - `TRUE`: The enumeration should continue.
///   - `FALSE`: The enumeration should stop. In this case, the function has found the main window and stored its handle in `lparam`.
unsafe extern "system" fn enum_window(window: HWND, lparam: LPARAM) -> BOOL {
    let mut window_proc_id = 0;
    let _ = GetWindowThreadProcessId(window, Some(&mut window_proc_id));

    if GetCurrentProcessId() != window_proc_id
        || !is_main_window(window)
        || window == GetConsoleWindow()
    {
        return TRUE;
    }

    let lparam_ptr = lparam.0 as *mut HWND;

    std::ptr::write(lparam_ptr, window);

    FALSE
}

/// Finds the main window of the current process.
///
/// This function uses the `EnumWindows` function to iterate through all top-level windows in the system.
/// It then checks each window to determine if it is the main window of the current process.
/// The main window is defined as a visible window without an owner and is not the console window.
///
/// # Returns
///
/// * `Some(HWND)` - If a main window is found, the function returns the handle to the main window.
/// * `None` - If no main window is found, the function returns `None`.
pub fn find_window() -> Option<HWND> {
    let mut hwnd: HWND = Default::default();

    let _ = unsafe {
        EnumWindows(Some(enum_window), LPARAM(std::ptr::from_mut::<HWND>(&mut hwnd) as isize))
    };

    if hwnd.0 == 0 {
        None
    } else {
        Some(hwnd)
    }
}

```

`cheat/src/utils/module_handler/mod.rs`:

```rs
use std::num::ParseIntError;

use crate::common;
use anyhow::{bail, Context};
use common::*;

use windows::Win32::{
    Foundation::HMODULE,
    System::{
        LibraryLoader::{GetModuleHandleW, GetProcAddress},
        ProcessStatus::{GetModuleInformation, MODULEINFO},
        Threading::GetCurrentProcess,
    },
};

use windows::core::{PCSTR, PCWSTR};

/// Obtains a module handle by its name.
///
/// This function uses the `GetModuleHandleW` function from the Windows API to retrieve a handle to a
/// module by its name. The module name is specified as a UTF-8 encoded string, which is then converted
/// to UTF-16 for use with the Windows API.
///
/// # Parameters
///
/// * `module_name`: A string representing the name of the module to retrieve. The name should be the
///   base name of the module, without any path information.
///
/// # Return Value
///
/// Returns a raw pointer to the module handle if the module is found. If the module is not found,
/// the function returns `null`. The returned handle can be used with other Windows API functions to
/// interact with the module.
#[must_use]
pub fn get_module_handle(module_name: &str) -> Option<HMODULE> {
    // Convert the module name to a UTF-16 string with a null terminator
    let module_name_wide: Vec<u16> = module_name.encode_utf16().chain(std::iter::once(0)).collect();

    // SAFETY: The `module_name_wide` vector is valid and null-terminated. The call to `GetModuleHandleW`
    // expects a valid UTF-16 string and will return a handle to the module if it is loaded.
    // The result of `GetModuleHandleW` is converted to an `Option` using `.ok()`, handling `null` properly.
    unsafe { GetModuleHandleW(PCWSTR(module_name_wide.as_ptr())).ok() }
}

/// Retrieves the address of an exported function or variable from the specified module.
///
/// # Parameters
///
/// * `module_handle`: A handle to the module containing the function or variable.
/// * `proc_name`: The name of the function or variable to retrieve.
///
/// # Returns
///
/// * `Option<*mut c_void>`: The address of the function or variable if found, otherwise `None`.
///
/// # Panics
///
/// This function may panic if:
///
/// * `proc_name` contains a null byte or other invalid characters for a C string, which would cause
///   `CString::new` to panic.
///
/// # Note
///
/// The return value should be checked before use to avoid dereferencing null pointers.
#[must_use]
pub fn get_proc_address(module_handle: HMODULE, proc_name: &str) -> Option<*mut c_void> {
    let proc_name_cstr = CString::new(proc_name).ok()?;
    // SAFETY: The caller must ensure that `module_handle` is a valid module handle and
    // `proc_name` is a valid function name. The external `GetProcAddress` function is
    // used to retrieve the function address. The result is cast to `*mut c_void`.
    unsafe {
        GetProcAddress(module_handle, PCSTR(proc_name_cstr.as_ptr().cast::<u8>()))
            .map(|addr| addr as *mut _)
    }
}

/// Retrieves module information for a given module handle.
///
/// This function uses the `GetModuleInformation` function from the Windows API to obtain detailed
/// information about a module, such as the base address, size of the image, and entry point.
///
/// # Parameters
///
/// * `module_handle`: A raw pointer to the module's handle. This can be obtained using the
///   `get_module_handle` function.
///
/// # Return Value
///
/// Returns `Some(module_info)` if the module information is successfully obtained.
/// The `module_info` is a `MODULEINFO` struct containing the base address, size of the image,
/// and entry point of the module.
///
/// Returns `None` if the module information cannot be obtained or if an error occurs.
#[must_use]
pub fn get_module_info(module_handle: HMODULE) -> Option<MODULEINFO> {
    let mut module_info =
        MODULEINFO { lpBaseOfDll: null_mut(), SizeOfImage: 0, EntryPoint: null_mut() };

    let size_of_module_info = u32::try_from(size_of::<MODULEINFO>()).ok()?;

    // SAFETY: The caller must ensure that `module_handle` is a valid handle to a loaded module.
    unsafe {
        GetModuleInformation(
            GetCurrentProcess(),
            module_handle,
            &mut module_info,
            size_of_module_info,
        )
        .is_ok()
        .then_some(module_info) // Use `then_some` to simplify the return logic
    }
}

/// Searches for a pattern within the memory of a specified module.
///
/// This function uses a simple byte-by-byte comparison to find a pattern within the memory of a module.
/// The pattern is specified as a space-separated sequence of hexadecimal bytes, with "??" representing
/// a wildcard that matches any byte.
///
/// # Parameters
///
/// * `module_handle`: A handle to the module within which to search for the pattern.
///   This can be obtained using the `get_module_handle` function.
///
/// * `pattern`: A string representing the pattern to search for. The pattern should be a space-separated
///   sequence of hexadecimal bytes, with "??" representing a wildcard.
///
/// # Return Value
///
/// Returns `Some(address_offset)` if the pattern is found within the module's memory.
/// The `address_offset` is the memory address of the first byte of the pattern, relative to the base
/// address of the module.
///
/// Returns `None` if the pattern is not found within the module's memory.
///
/// # Panics
///
/// This function may panic if:
///
/// * The `pattern` string contains invalid hexadecimal characters.
/// * The `pattern` string contains a null byte or other invalid characters for a C string.
/// * The `address_offset` calculation overflows.
#[must_use]
pub fn pattern_search<T>(module_handle: HMODULE, pattern: &str) -> anyhow::Result<*const T> {
    // Parse the pattern string into bytes and handle wildcards
    let parsed_pattern_bytes: Result<Vec<Option<u8>>, ParseIntError> =
        pattern
            .split_whitespace()
            .map(|byte_str| {
                if byte_str == "??" {
                    Ok(None)
                } else {
                    u8::from_str_radix(byte_str, 16).map(Some)
                }
            })
            .collect();

    // Handle parsing errors and continue if successful
    let pattern_bytes = parsed_pattern_bytes.context("failed to parse pattern: {err}")?;

    // Retrieve module information
    let module_info = get_module_info(module_handle).context("failed to get module info")?;

    let base_address = module_info.lpBaseOfDll;
    let size = usize::try_from(module_info.SizeOfImage)
        .context("failed to convert `SizeOfImage` to usize")?;

    // SAFETY: Convert base_address to a raw pointer for memory access
    let module_memory = unsafe {
        // Ensure the pointer and size are valid before creating a slice
        slice::from_raw_parts(base_address as *const u8, size)
    };

    for i in 0..module_memory.len().saturating_sub(pattern_bytes.len()) {
        if pattern_bytes
            .iter()
            .enumerate()
            .all(|(j, &b)| b.map_or(true, |b| module_memory[i + j] == b))
        {
            let address_offset = (base_address as usize)
                .checked_add(i)
                .ok_or_else(|| {
                    tracing::error!("address calculation overflowed");
                    None::<usize>
                })
                .expect("failed to calculate address");

            return Ok(address_offset as *const T);
        }
    }

    bail!("pattern not found")
}

/// Retrieves a pointer to a specific interface from a module.
///
/// This function uses the `CreateInterface` function from the specified module to obtain a pointer to
/// a requested interface. The interface is identified by its name, which is passed as a parameter to
/// the function.
///
/// # Parameters
///
/// * `module_handle`: A handle to the module containing the `CreateInterface` function.
///   This can be obtained using the `get_module_handle` function.
///
/// * `interface_name`: A string representing the name of the interface to retrieve.
///   The name should match the name used by the module to identify the interface.
///
/// # Returns
///
/// * `Some(interface_ptr)`: If the interface is successfully retrieved. The `interface_ptr` is a raw pointer
///   to the requested interface.
///
/// * `None`: If the interface cannot be retrieved or if an error occurs.
///
/// # Panics
///
/// This function may panic if:
///
/// * `get_proc_address` returns `None`, which will cause `expect` to panic.
/// * `CString::new` fails to create a C-style string, which will also cause `expect` to panic.
///
/// # Note
///
/// The returned pointer is raw and should be used with caution. Ensure that the pointer is valid before
/// dereferencing or using it.
#[must_use]
pub fn get_interface(module_handle: HMODULE, interface_name: &str) -> Option<*const usize> {
    // SAFETY: We assume that `get_proc_address` returns a valid function pointer.
    let function: unsafe extern "C" fn(*const c_char, *const c_int) -> *const c_void = unsafe {
        get_proc_address(module_handle, "CreateInterface")
            .map(|addr| transmute(addr))
            .ok_or_else(|| {
                tracing::error!("failed to get function address for CreateInterface");
                None::<usize>
            })
            .expect("failed to cast CreateInterface to a function pointer")
    };

    let interface_name_cstr = CString::new(interface_name)
        .inspect_err(|err| tracing::error!("failed to create CString from interface_name: {err}"))
        .ok()?;

    // SAFETY: We assume that `function` is a valid function pointer and `interface_name_cstr` is valid.
    Some(unsafe { function(interface_name_cstr.as_ptr(), null_mut()) as *const usize })
}

```

`cheat/src/utils/render/dx11/mod.rs`:

```rs
use crate::{
    common,
    core::{settings, ui},
};

use common::{Mutex, OnceLock};

use anyhow::Context;
use egui_directx11::DirectX11Renderer;

use windows::Win32::{
    Foundation::{HMODULE, HWND, TRUE},
    Graphics::{
        Direct3D::{D3D_DRIVER_TYPE_NULL, D3D_FEATURE_LEVEL_10_0, D3D_FEATURE_LEVEL_11_1},
        Direct3D11::{
            D3D11CreateDeviceAndSwapChain, D3D11_CREATE_DEVICE_BGRA_SUPPORT, D3D11_SDK_VERSION,
        },
        Dxgi::{
            Common::{DXGI_FORMAT_R8G8B8A8_UNORM, DXGI_MODE_DESC, DXGI_SAMPLE_DESC},
            IDXGISwapChain, DXGI_SWAP_CHAIN_DESC, DXGI_USAGE_RENDER_TARGET_OUTPUT,
        },
    },
};

use super::{fonts, win32};

pub static DX11: OnceLock<Mutex<DirectX11Renderer>> = OnceLock::new();

/// Creates a DirectX 11 swap chain for the given window handle.
///
/// # Parameters
///
/// * `window`: A handle to the window where the swap chain will be displayed.
///
/// # Returns
///
/// * `Result<IDXGISwapChain>`: On success, returns the created swap chain.
///   On error, returns an `anyhow::Result` containing the error.
#[allow(dead_code)]
fn create_swapchain(window: HWND) -> anyhow::Result<IDXGISwapChain> {
    let flags = D3D11_CREATE_DEVICE_BGRA_SUPPORT;
    let feature_levels = [D3D_FEATURE_LEVEL_11_1, D3D_FEATURE_LEVEL_10_0];

    let swapchain_description = DXGI_SWAP_CHAIN_DESC {
        BufferDesc: DXGI_MODE_DESC { Format: DXGI_FORMAT_R8G8B8A8_UNORM, ..Default::default() },
        SampleDesc: DXGI_SAMPLE_DESC { Count: 1, ..Default::default() },
        BufferUsage: DXGI_USAGE_RENDER_TARGET_OUTPUT,
        BufferCount: 2,
        OutputWindow: window,
        Windowed: TRUE,
        ..Default::default()
    };

    let mut device = None;
    let mut swapchain: Option<IDXGISwapChain> = None;

    // SAFETY:
    // - The pointers passed to `D3D11CreateDeviceAndSwapChain` must be valid and correctly set up.
    // - All parameters should be properly initialized before calling this function.
    // - Proper error handling is in place to manage any issues from the FFI call.
    unsafe {
        D3D11CreateDeviceAndSwapChain(
            None,
            D3D_DRIVER_TYPE_NULL,
            HMODULE::default(),
            flags,
            Some(&feature_levels),
            D3D11_SDK_VERSION,
            Some(&swapchain_description),
            Some(&mut swapchain),
            Some(&mut device),
            None,
            None,
        )
        .context("D3D11CreateDeviceAndSwapChain failed")?;
    };

    swapchain.context("could not create d3d11 swapchain")
}

/// Initializes the DirectX 11 renderer from the given swap chain.
///
/// This function sets up the DirectX 11 renderer, collects input from the `win32::INPUT` module,
/// and locks the `settings::SETTINGS` mutex. It then attempts to paint the UI using the provided
/// closure, which includes setting fonts, modifying tessellation options, and drawing the menu.
/// If an error occurs during rendering, it logs the error message.
///
/// # Parameters
///
/// * `swapchain`: A reference to the DirectX 11 swap chain used for rendering.
///
/// # Panics
///
/// This function will panic if:
/// - The DirectX 11 renderer could not be initialized (`expect("could not create dx11 renderer")`).
/// - The `win32::INPUT` is not initialized (`expect("win32::INPUT is not initialized")`).
/// - The input collection failed (`expect("could not collect input")`).
/// - An error occurs during the `renderer.paint` call (`eprintln!("Rendering error: {e}")`).
///
/// # Return
///
/// This function does not return a value.
pub fn init_from_swapchain(swapchain: &IDXGISwapChain) {
    let mut renderer = DX11
        .get_or_init(|| {
            Mutex::new(
                DirectX11Renderer::init_from_swapchain(swapchain, egui::Context::default())
                    .expect("could not create dx11 renderer"),
            )
        })
        .lock();

    let input = win32::INPUT
        .get()
        .expect("win32::INPUT is not initialized")
        .lock()
        .collect_input()
        .expect("could not collect input");

    let mut settings = settings::SETTINGS.lock();

    if let Err(e) = renderer.paint(swapchain, &mut settings, input, |ctx, settings| {
        match fonts::FONTS.lock().as_ref() {
            Some(fonts) => {
                ctx.set_fonts(fonts.clone());
                ctx.tessellation_options_mut(|options| {
                    options.feathering = false;
                });
                ui::draw_menu(ctx, settings);
            }
            None => {
                tracing::warn!("fonts are not set up");
            }
        }
    }) {
        tracing::warn!("rendering error: {e}");
    }
}

```

`cheat/src/utils/render/fonts/mod.rs`:

```rs
use anyhow::Context;
use egui::{FontData, FontDefinitions, FontFamily};
use parking_lot::Mutex;

pub static FONTS: Mutex<Option<FontDefinitions>> = Mutex::new(None);

/// This function sets up the default fonts for the application.
/// It initializes a `FontDefinitions` struct, adds a custom font "Tahoma" from a file,
/// and sets it as the default proportional and monospace font.
///
/// # Errors
///
/// This function returns an `anyhow::Result<()>`, which means it can return an error
/// of type `anyhow::Error` if any of the operations fail.
pub fn setup() -> anyhow::Result<()> {
    let mut fonts = FontDefinitions::default();

    fonts
        .font_data
        .insert("Tahoma".to_owned(), FontData::from_static(include_bytes!("./tahoma.ttf")));

    fonts
        .families
        .get_mut(&FontFamily::Proportional)
        .context("could not setup proportional fonts")?
        .insert(0, "Tahoma".to_owned());

    fonts
        .families
        .get_mut(&FontFamily::Monospace)
        .context("could not setup monospace fonts")?
        .insert(0, "Tahoma".to_owned());

    *FONTS.lock() = Some(fonts);

    Ok(())
}

```

`cheat/src/utils/render/mod.rs`:

```rs
use crate::utils::find_window;
use anyhow::Context;

pub mod dx11;
pub mod fonts;
pub mod win32;

pub fn setup() -> anyhow::Result<()> {
    let window = find_window().context("could not find window")?;

    fonts::setup().context("failed to setup fonts")?;
    win32::setup(window).context("failed to setup WNDPROC hook")?;

    Ok(())
}

```

`cheat/src/utils/render/win32/mod.rs`:

```rs
use crate::common;
use common::{transmute, Mutex, OnceLock};

use crate::{core::ui, utils::find_window};
use anyhow::{bail, Context};

use egui_win32::InputManager;
use windows::Win32::{
    Foundation::{HWND, LPARAM, LRESULT, WPARAM},
    UI::WindowsAndMessaging::{
        CallWindowProcW, SetWindowLongPtrA, GWLP_WNDPROC, WM_KEYDOWN, WNDPROC,
    },
};

static WNDPROC: OnceLock<WNDPROC> = OnceLock::new();
pub static INPUT: OnceLock<Mutex<InputManager>> = OnceLock::new();

/// Sets up window procedure hooking and initializes the input manager.
///
/// # Parameters
///
/// - `window`: The handle to the window for which the procedure is set up.
///
/// # Returns
///
/// Returns an `anyhow::Result` which is `Ok(())` on success or an `Err` if any of the operations fail.
///
/// # Errors
///
/// - Returns an error if the window procedure (`WNDPROC`) is already initialized.
/// - Returns an error if the input manager (`INPUT`) is already initialized.
///
/// # Panics
///
/// This function does not panic. However, if the `SetWindowLongPtrA` function fails, it may cause undefined behavior.
pub fn setup(window: HWND) -> anyhow::Result<()> {
    // SAFETY:
    // - `wndproc_hk` is a valid function pointer with the correct signature.
    // - `SetWindowLongPtrA` expects a pointer to a window procedure, which is provided as `wndproc_hk` cast to `isize`.
    // - The returned `old_proc_ptr` from `SetWindowLongPtrA` is a valid pointer or `0` if the function fails.
    #[allow(clippy::fn_to_numeric_cast)]
    let old_proc_ptr = unsafe { SetWindowLongPtrA(window, GWLP_WNDPROC, wndproc_hk as isize) };

    // SAFETY: The cast to `isize` and back to a function pointer is managed by the API and is safe here.
    // We use `old_proc_ptr` to verify that the window procedure was successfully set.
    let wndproc_fn = unsafe {
        transmute::<isize, Option<unsafe extern "system" fn(HWND, u32, WPARAM, LPARAM) -> LRESULT>>(
            old_proc_ptr,
        )
    };

    if WNDPROC.set(wndproc_fn).is_err() {
        bail!("WNDPROC is already initialized");
    }

    // Initialize the input manager
    if INPUT.set(Mutex::new(InputManager::new(window))).is_err() {
        bail!("INPUT is already initialized");
    }

    Ok(())
}

/// Destroys the input handling and menu system for the application.
///
/// This function retrieves the window handle, checks if the `WNDPROC` and `INPUT` are initialized,
/// and then restores the original `WNDPROC` to the window.
///
/// # Returns
///
/// * `Result<(), anyhow::Error>`: Returns `Ok(())` if the destruction is successful.
///   Returns an error if the `WNDPROC` or `INPUT` is not initialized.
pub fn destroy() -> anyhow::Result<()> {
    let window = find_window().context("could not find window")?;

    let Some(Some(wndproc)) = WNDPROC.get() else {
        bail!("WNDPROC is not initialized");
    };

    // SAFETY: The `SetWindowLongPtrA` function is used here to set the window procedure, which requires a valid function pointer.
    #[allow(clippy::fn_to_numeric_cast)]
    unsafe {
        SetWindowLongPtrA(window, GWLP_WNDPROC, *wndproc as isize);
    };

    Ok(())
}

unsafe extern "system" fn wndproc_hk(
    window: HWND,
    msg: u32,
    wparam: WPARAM,
    lparam: LPARAM,
) -> LRESULT {
    INPUT.get().expect("INPUT is not initialized").lock().process(msg, wparam.0, lparam.0);

    let wndproc = WNDPROC.get().expect("WNDPROC is not initialized");

    match msg {
        WM_KEYDOWN if wparam.0 == 0x2D => {
            ui::toggle_menu(); // Toggle menu visibility
        }
        _ => (),
    }

    // Check if the menu is open and block input if necessary
    if ui::should_block_input(msg) {
        return LRESULT(1);
    }

    CallWindowProcW(*wndproc, window, msg, wparam, lparam)
}

```

`egui/egui-directx11/Cargo.toml`:

```toml
[package]
name = "egui-directx11"
version = "0.1.0"
edition = "2021"
license = "MIT"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
thiserror = "1.0.49"
egui = "0.22.0"
windows = { version = "0.51.1", features = [
    "Win32_Foundation",
    "Foundation_Numerics",
    "Win32_Graphics_Direct3D",
    "Win32_Graphics_Direct3D11",
    "Win32_Graphics_Dxgi",
    "Win32_System_SystemServices",
    "Win32_Graphics_Dxgi_Common",
    "Win32_Graphics_Direct3D_Fxc",
    "Win32_UI_WindowsAndMessaging",
] }

[dev-dependencies]
winit = "0.26"

```

`egui/egui-directx11/README.md`:

```md
# Egui Direct X11

Renderer backend for Direct X11 for Egui

Initial Source: https://crates.io/crates/egui-d3d11
```

`egui/egui-directx11/src/backup.rs`:

```rs
use std::{cell::RefCell, mem::zeroed};
use windows::Win32::{
    Foundation::RECT,
    Graphics::{
        Direct3D::D3D_PRIMITIVE_TOPOLOGY,
        Direct3D11::{
            ID3D11BlendState, ID3D11Buffer, ID3D11ClassInstance, ID3D11DepthStencilState,
            ID3D11DeviceContext, ID3D11GeometryShader, ID3D11InputLayout, ID3D11PixelShader,
            ID3D11RasterizerState, ID3D11SamplerState, ID3D11ShaderResourceView,
            ID3D11VertexShader, D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT,
            D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT, D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT,
            D3D11_VIEWPORT, D3D11_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE,
        },
        Dxgi::Common::DXGI_FORMAT,
    },
};

/// Structe used to backup all data from directx context.
/// Thanks ImGui.
#[derive(Default)]
pub struct BackupState(RefCell<InnerState>);

impl BackupState {
    #[inline]
    pub fn save(&self, context: &ID3D11DeviceContext) {
        unsafe {
            self.0.borrow_mut().save(context);
        }
    }

    #[inline]
    pub fn restore(&self, context: &ID3D11DeviceContext) {
        unsafe {
            self.0.borrow_mut().restore(context);
        }
    }
}

#[derive(Default)]
struct InnerState {
    scissor_rects: [RECT; D3D11_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE as _],
    scissor_count: u32,

    viewports: [D3D11_VIEWPORT; D3D11_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE as _],
    viewport_count: u32,

    raster_state: Option<ID3D11RasterizerState>,

    blend_state: Option<ID3D11BlendState>,
    blend_factor: [f32; 4],
    blend_mask: u32,

    depth_stencil_state: Option<ID3D11DepthStencilState>,
    stencil_ref: u32,

    pixel_shader_resources: Array<
        { (D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - 1) as usize },
        ID3D11ShaderResourceView,
    >,
    samplers: Array<{ (D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT - 1) as usize }, ID3D11SamplerState>,

    vertex_shader: Option<ID3D11VertexShader>,
    vertex_shader_instances: Array<256, ID3D11ClassInstance>,
    vertex_shader_instances_count: u32,

    geometry_shader: Option<ID3D11GeometryShader>,
    geometry_shader_instances: Array<256, ID3D11ClassInstance>,
    geomentry_shader_instances_count: u32,

    pixel_shader: Option<ID3D11PixelShader>,
    pixel_shader_instances: Array<256, ID3D11ClassInstance>,
    pixel_shader_instances_count: u32,

    constant_buffers:
        Array<{ (D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT - 1) as usize }, ID3D11Buffer>,
    primitive_topology: D3D_PRIMITIVE_TOPOLOGY,

    index_buffer: Option<ID3D11Buffer>,
    index_buffer_format: DXGI_FORMAT,
    index_buffer_offest: u32,

    vertex_buffer: Option<ID3D11Buffer>,
    vertex_buffer_strides: u32,
    vertex_buffer_offsets: u32,

    input_layout: Option<ID3D11InputLayout>,
}

impl InnerState {
    #[inline]
    pub unsafe fn save(&mut self, ctx: &ID3D11DeviceContext) {
        ctx.RSGetScissorRects(&mut self.scissor_count, Some(self.scissor_rects.as_mut_ptr()));
        ctx.RSGetViewports(&mut self.viewport_count, Some(self.viewports.as_mut_ptr()));
        self.raster_state = ctx.RSGetState().ok();
        ctx.OMGetBlendState(
            Some(&mut self.blend_state),
            Some(&mut self.blend_factor),
            Some(&mut self.blend_mask),
        );
        ctx.OMGetDepthStencilState(
            Some(&mut self.depth_stencil_state),
            Some(&mut self.stencil_ref),
        );
        ctx.PSGetShaderResources(0, Some(self.pixel_shader_resources.as_mut_slice()));
        ctx.PSGetSamplers(0, Some(self.samplers.as_mut_slice()));
        self.pixel_shader_instances_count = 256;
        self.vertex_shader_instances_count = 256;
        self.geomentry_shader_instances_count = 256;

        ctx.PSGetShader(
            &mut self.pixel_shader,
            Some(self.pixel_shader_instances.as_mut_ptr()),
            Some(&mut self.pixel_shader_instances_count),
        );
        ctx.VSGetShader(
            &mut self.vertex_shader,
            Some(self.vertex_shader_instances.as_mut_ptr()),
            Some(&mut self.vertex_shader_instances_count),
        );
        ctx.GSGetShader(
            &mut self.geometry_shader,
            Some(self.geometry_shader_instances.as_mut_ptr()),
            Some(&mut self.geomentry_shader_instances_count),
        );

        ctx.VSGetConstantBuffers(0, Some(self.constant_buffers.as_mut_slice()));
        self.primitive_topology = ctx.IAGetPrimitiveTopology();
        ctx.IAGetIndexBuffer(
            Some(&mut self.index_buffer),
            Some(&mut self.index_buffer_format),
            Some(&mut self.index_buffer_offest),
        );
        ctx.IAGetVertexBuffers(
            0,
            1,
            Some(&mut self.vertex_buffer),
            Some(&mut self.vertex_buffer_strides),
            Some(&mut self.vertex_buffer_offsets),
        );
        self.input_layout = ctx.IAGetInputLayout().ok();
    }

    #[inline]
    pub unsafe fn restore(&mut self, ctx: &ID3D11DeviceContext) {
        ctx.RSSetScissorRects(Some(&self.scissor_rects.as_slice()[..self.scissor_count as usize]));
        ctx.RSSetViewports(Some(&self.viewports.as_slice()[..self.viewport_count as usize]));
        ctx.RSSetState(self.raster_state.take().as_ref());
        ctx.OMSetBlendState(
            self.blend_state.take().as_ref(),
            Some(&self.blend_factor),
            self.blend_mask,
        );
        ctx.OMSetDepthStencilState(self.depth_stencil_state.take().as_ref(), self.stencil_ref);
        ctx.PSSetShaderResources(0, Some(self.pixel_shader_resources.as_slice()));
        ctx.PSSetSamplers(0, Some(self.samplers.as_slice()));
        ctx.PSSetShader(
            self.pixel_shader.take().as_ref(),
            Some(
                &self.pixel_shader_instances.as_slice()
                    [..self.pixel_shader_instances_count as usize],
            ),
        );
        self.pixel_shader_instances.release();

        ctx.VSSetShader(
            self.vertex_shader.take().as_ref(),
            Some(
                &self.vertex_shader_instances.as_slice()
                    [..self.vertex_shader_instances_count as usize],
            ),
        );
        self.vertex_shader_instances.release();

        ctx.GSSetShader(
            self.geometry_shader.take().as_ref(),
            Some(
                &self.geometry_shader_instances.as_slice()
                    [..self.geomentry_shader_instances_count as usize],
            ),
        );
        self.geometry_shader_instances.release();

        ctx.VSSetConstantBuffers(0, Some(self.constant_buffers.as_slice()));
        ctx.IASetPrimitiveTopology(self.primitive_topology);
        ctx.IASetIndexBuffer(
            self.index_buffer.take().as_ref(),
            self.index_buffer_format,
            self.index_buffer_offest,
        );
        ctx.IASetVertexBuffers(
            0,
            1,
            Some(&self.vertex_buffer.take()),
            Some(&self.vertex_buffer_strides),
            Some(&self.vertex_buffer_offsets),
        );
        ctx.IASetInputLayout(self.input_layout.take().as_ref());
    }
}

struct Array<const N: usize, T>([Option<T>; N]);
impl<const N: usize, T> Array<N, T> {
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut Option<T> {
        &mut self.0[0]
    }

    #[inline]
    pub fn as_slice(&self) -> &[Option<T>] {
        self.0.as_slice()
    }

    #[inline]
    pub fn as_mut_slice(&mut self) -> &mut [Option<T>] {
        self.0.as_mut_slice()
    }

    #[inline]
    pub fn release(&mut self) {
        self.0.iter().for_each(drop);
    }
}

impl<const N: usize, T> Default for Array<N, T> {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

```

`egui/egui-directx11/src/lib.rs`:

```rs
mod backup;
mod mesh;
mod painter;
mod shader;
mod texture;

pub use painter::*;

#[derive(Debug, thiserror::Error)]
pub enum RenderError {
    #[error("Unrecoverable error occured {0}")]
    General(&'static str),

    #[error("Windows error {0}")]
    Win(#[from] windows::core::Error),
}

```

`egui/egui-directx11/src/mesh.rs`:

```rs
use egui::{epaint::Vertex, Mesh, Pos2, Rect, Rgba, TextureId};
use std::mem::size_of;
use windows::Win32::Graphics::Direct3D11::{
    ID3D11Buffer, ID3D11Device, D3D11_BIND_INDEX_BUFFER, D3D11_BIND_VERTEX_BUFFER,
    D3D11_BUFFER_DESC, D3D11_SUBRESOURCE_DATA, D3D11_USAGE_DEFAULT,
};

use crate::RenderError;

pub struct GpuMesh {
    pub indices: Vec<u32>,
    pub vertices: Vec<GpuVertex>,
    pub clip: Rect,
    pub texture_id: TextureId,
}

impl GpuMesh {
    pub fn from_mesh((w, h): (f32, f32), mesh: Mesh, scissors: Rect) -> Option<Self> {
        if mesh.indices.is_empty() || mesh.indices.len() % 3 != 0 {
            None
        } else {
            let vertices = mesh
                .vertices
                .into_iter()
                .map(|v| GpuVertex {
                    pos: Pos2::new((v.pos.x - w / 2.) / (w / 2.), (v.pos.y - h / 2.) / -(h / 2.)),
                    uv: v.uv,
                    color: v.color.into(),
                })
                .collect();

            Some(Self {
                texture_id: mesh.texture_id,
                indices: mesh.indices,
                clip: scissors,
                vertices,
            })
        }
    }
}

#[repr(C)]
pub struct GpuVertex {
    pos: Pos2,
    uv: Pos2,
    color: Rgba,
}

impl From<Vertex> for GpuVertex {
    fn from(v: Vertex) -> Self {
        Self { pos: v.pos, uv: v.uv, color: v.color.into() }
    }
}

pub fn create_vertex_buffer(
    device: &ID3D11Device,
    mesh: &GpuMesh,
) -> Result<ID3D11Buffer, RenderError> {
    let desc = D3D11_BUFFER_DESC {
        ByteWidth: (mesh.vertices.len() * size_of::<GpuVertex>()) as u32,
        Usage: D3D11_USAGE_DEFAULT,
        BindFlags: D3D11_BIND_VERTEX_BUFFER.0 as u32,
        ..Default::default()
    };

    let init =
        D3D11_SUBRESOURCE_DATA { pSysMem: mesh.vertices.as_ptr() as _, ..Default::default() };

    unsafe {
        let mut output = None;
        device.CreateBuffer(&desc, Some(&init), Some(&mut output))?;
        output.ok_or(RenderError::General("Failed to create vertex buffer"))
    }
}

pub fn create_index_buffer(
    device: &ID3D11Device,
    mesh: &GpuMesh,
) -> Result<ID3D11Buffer, RenderError> {
    let desc = D3D11_BUFFER_DESC {
        ByteWidth: (mesh.indices.len() * size_of::<u32>()) as u32,
        Usage: D3D11_USAGE_DEFAULT,
        BindFlags: D3D11_BIND_INDEX_BUFFER.0 as u32,
        ..Default::default()
    };

    let init = D3D11_SUBRESOURCE_DATA { pSysMem: mesh.indices.as_ptr() as _, ..Default::default() };

    unsafe {
        let mut output = None;
        device.CreateBuffer(&desc, Some(&init), Some(&mut output))?;
        output.ok_or(RenderError::General("Failed to create index buffer"))
    }
}

```

`egui/egui-directx11/src/painter.rs`:

```rs
use crate::{
    backup::BackupState,
    mesh::{create_index_buffer, create_vertex_buffer, GpuMesh, GpuVertex},
    shader::CompiledShaders,
    texture::TextureAllocator,
    RenderError,
};
use egui::{epaint::Primitive, Context};
use std::mem::size_of;
use windows::{
    core::{s, HRESULT},
    Win32::{
        Foundation::{HWND, RECT},
        Graphics::{
            Direct3D::D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST,
            Direct3D11::{
                ID3D11Device, ID3D11DeviceContext, ID3D11InputLayout, ID3D11RenderTargetView,
                ID3D11Texture2D, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_BLEND_DESC,
                D3D11_BLEND_INV_SRC_ALPHA, D3D11_BLEND_ONE, D3D11_BLEND_OP_ADD,
                D3D11_BLEND_SRC_ALPHA, D3D11_COLOR_WRITE_ENABLE_ALL, D3D11_COMPARISON_ALWAYS,
                D3D11_CULL_NONE, D3D11_FILL_SOLID, D3D11_FILTER_MIN_MAG_MIP_LINEAR,
                D3D11_INPUT_ELEMENT_DESC, D3D11_INPUT_PER_VERTEX_DATA, D3D11_RASTERIZER_DESC,
                D3D11_RENDER_TARGET_BLEND_DESC, D3D11_SAMPLER_DESC, D3D11_TEXTURE_ADDRESS_BORDER,
                D3D11_VIEWPORT,
            },
            Dxgi::{
                Common::{
                    DXGI_FORMAT_R32G32B32A32_FLOAT, DXGI_FORMAT_R32G32_FLOAT, DXGI_FORMAT_R32_UINT,
                },
                IDXGISwapChain, DXGI_SWAP_CHAIN_DESC,
            },
        },
        UI::WindowsAndMessaging::GetClientRect,
    },
};

/// Heart and soul of this integration.
/// Main methods you are going to use are:
/// * [`Self::present`] - Should be called inside of hook or before present.
/// * [`Self::resize_buffers`] - Should be called **INSTEAD** of swapchain's `ResizeBuffers`.
/// * [`Self::wnd_proc`] - Should be called on each `WndProc`.
pub struct DirectX11Renderer {
    render_view: Option<ID3D11RenderTargetView>,
    tex_alloc: TextureAllocator,
    input_layout: ID3D11InputLayout,
    shaders: CompiledShaders,
    backup: BackupState,
    hwnd: HWND,
    context: egui::Context,
}

impl DirectX11Renderer {
    const INPUT_ELEMENTS_DESC: [D3D11_INPUT_ELEMENT_DESC; 3] = [
        D3D11_INPUT_ELEMENT_DESC {
            SemanticName: s!("POSITION"),
            SemanticIndex: 0,
            Format: DXGI_FORMAT_R32G32_FLOAT,
            InputSlot: 0,
            AlignedByteOffset: 0,
            InputSlotClass: D3D11_INPUT_PER_VERTEX_DATA,
            InstanceDataStepRate: 0,
        },
        D3D11_INPUT_ELEMENT_DESC {
            SemanticName: s!("TEXCOORD"),
            SemanticIndex: 0,
            Format: DXGI_FORMAT_R32G32_FLOAT,
            InputSlot: 0,
            AlignedByteOffset: D3D11_APPEND_ALIGNED_ELEMENT,
            InputSlotClass: D3D11_INPUT_PER_VERTEX_DATA,
            InstanceDataStepRate: 0,
        },
        D3D11_INPUT_ELEMENT_DESC {
            SemanticName: s!("COLOR"),
            SemanticIndex: 0,
            Format: DXGI_FORMAT_R32G32B32A32_FLOAT,
            InputSlot: 0,
            AlignedByteOffset: D3D11_APPEND_ALIGNED_ELEMENT,
            InputSlotClass: D3D11_INPUT_PER_VERTEX_DATA,
            InstanceDataStepRate: 0,
        },
    ];
}

impl DirectX11Renderer {
    /// Create a new directx11 renderer from a swapchain
    pub fn init_from_swapchain(
        swapchain: &IDXGISwapChain,
        context: egui::Context,
    ) -> Result<Self, RenderError> {
        unsafe {
            let mut swap_chain_desc = DXGI_SWAP_CHAIN_DESC::default();
            swapchain.GetDesc(&mut swap_chain_desc)?;

            let hwnd = swap_chain_desc.OutputWindow;
            if hwnd.0 == -1 {
                return Err(RenderError::General(
                    "Trying to initialize from a swapchain with an invalid hwnd",
                ));
            }
            let dev: ID3D11Device = swapchain.GetDevice()?;
            let backbuffer: ID3D11Texture2D = swapchain.GetBuffer(0)?;

            let mut render_view = None;
            dev.CreateRenderTargetView(&backbuffer, None, Some(&mut render_view))?;

            let shaders = CompiledShaders::new(&dev)?;
            let mut input_layout = None;
            dev.CreateInputLayout(
                &Self::INPUT_ELEMENTS_DESC,
                shaders.bytecode(),
                Some(&mut input_layout),
            )?;
            let input_layout =
                input_layout.ok_or(RenderError::General("failed to initialize input layout"))?;

            Ok(Self {
                tex_alloc: TextureAllocator::default(),
                backup: BackupState::default(),
                input_layout,
                render_view,
                shaders,
                hwnd,
                context,
            })
        }
    }
}

impl DirectX11Renderer {
    /// Present call. Should be called once per original present call, before or inside of hook.
    #[allow(invalid_reference_casting)]
    pub fn paint<PaintFn, State>(
        &mut self,
        swap_chain: &IDXGISwapChain,
        shared_state: &mut State,
        input: egui::RawInput,
        paint: PaintFn,
    ) -> Result<(), RenderError>
    where
        PaintFn: Fn(&Context, &mut State) + 'static,
    {
        unsafe {
            let (dev, ctx) = &get_device_and_context(swap_chain)?;
            self.backup.save(ctx);
            let screen = self.get_screen_size();
            let output = self.context.run(input, |ctx| paint(ctx, shared_state));

            if !output.textures_delta.is_empty() {
                self.tex_alloc.process_deltas(dev, ctx, output.textures_delta)?;
            }

            if output.shapes.is_empty() {
                self.backup.restore(ctx);
                return Ok(());
            }

            let primitives = self
                .context
                .tessellate(output.shapes)
                .into_iter()
                .filter_map(|prim| {
                    if let Primitive::Mesh(mesh) = prim.primitive {
                        GpuMesh::from_mesh(screen, mesh, prim.clip_rect)
                    } else {
                        panic!("Paint callbacks are not yet supported")
                    }
                })
                .collect::<Vec<_>>();

            self.set_blend_state(dev, ctx)?;
            self.set_raster_options(dev, ctx)?;
            self.set_sampler_state(dev, ctx)?;

            ctx.RSSetViewports(Some(&[self.get_viewport()]));
            ctx.OMSetRenderTargets(Some(&[self.render_view.clone()]), None);
            ctx.IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
            ctx.IASetInputLayout(&self.input_layout);

            for mesh in primitives {
                let idx = create_index_buffer(dev, &mesh)?;
                let vtx = create_vertex_buffer(dev, &mesh)?;

                let texture = self.tex_alloc.get_by_id(mesh.texture_id);

                ctx.RSSetScissorRects(Some(&[RECT {
                    left: mesh.clip.left() as _,
                    top: mesh.clip.top() as _,
                    right: mesh.clip.right() as _,
                    bottom: mesh.clip.bottom() as _,
                }]));

                if texture.is_some() {
                    ctx.PSSetShaderResources(0, Some(&[texture]));
                }

                ctx.IASetVertexBuffers(
                    0,
                    1,
                    Some(&Some(vtx)),
                    Some(&(size_of::<GpuVertex>() as _)),
                    Some(&0),
                );
                ctx.IASetIndexBuffer(&idx, DXGI_FORMAT_R32_UINT, 0);
                ctx.VSSetShader(&self.shaders.vertex, Some(&[]));
                ctx.PSSetShader(&self.shaders.pixel, Some(&[]));

                ctx.DrawIndexed(mesh.indices.len() as _, 0, 0);
            }

            self.backup.restore(ctx);
        }

        Ok(())
    }

    /// Call when resizing buffers.
    /// Do not call the original function before it, instead call it inside of the `original` closure.
    /// # Behavior
    /// In `origin` closure make sure to call the original `ResizeBuffers`.
    pub fn resize_buffers(
        &mut self,
        swap_chain: &IDXGISwapChain,
        original: impl FnOnce() -> HRESULT,
    ) -> Result<HRESULT, RenderError> {
        unsafe {
            drop(self.render_view.take());
            let result = original();
            let backbuffer: ID3D11Texture2D = swap_chain.GetBuffer(0)?;
            let device: ID3D11Device = swap_chain.GetDevice()?;
            device.CreateRenderTargetView(&backbuffer, None, Some(&mut self.render_view))?;
            Ok(result)
        }
    }
}

impl DirectX11Renderer {
    #[inline]
    fn get_screen_size(&self) -> (f32, f32) {
        let mut rect = RECT::default();
        unsafe {
            GetClientRect(self.hwnd, &mut rect).unwrap();
        }
        ((rect.right - rect.left) as f32, (rect.bottom - rect.top) as f32)
    }

    #[inline]
    fn get_viewport(&self) -> D3D11_VIEWPORT {
        let (w, h) = self.get_screen_size();
        D3D11_VIEWPORT {
            TopLeftX: 0.,
            TopLeftY: 0.,
            Width: w,
            Height: h,
            MinDepth: 0.,
            MaxDepth: 1.,
        }
    }

    fn set_blend_state(
        &self,
        dev: &ID3D11Device,
        ctx: &ID3D11DeviceContext,
    ) -> Result<(), RenderError> {
        let mut targets: [D3D11_RENDER_TARGET_BLEND_DESC; 8] = Default::default();
        targets[0].BlendEnable = true.into();
        targets[0].SrcBlend = D3D11_BLEND_SRC_ALPHA;
        targets[0].DestBlend = D3D11_BLEND_INV_SRC_ALPHA;
        targets[0].BlendOp = D3D11_BLEND_OP_ADD;
        targets[0].SrcBlendAlpha = D3D11_BLEND_ONE;
        targets[0].DestBlendAlpha = D3D11_BLEND_INV_SRC_ALPHA;
        targets[0].BlendOpAlpha = D3D11_BLEND_OP_ADD;
        targets[0].RenderTargetWriteMask = D3D11_COLOR_WRITE_ENABLE_ALL.0 as _;

        let blend_desc = D3D11_BLEND_DESC {
            AlphaToCoverageEnable: false.into(),
            IndependentBlendEnable: false.into(),
            RenderTarget: targets,
        };

        unsafe {
            let mut blend_state = None;
            dev.CreateBlendState(&blend_desc, Some(&mut blend_state))?;
            let blend_state =
                blend_state.ok_or(RenderError::General("Unable to set blend state"))?;
            ctx.OMSetBlendState(&blend_state, Some(&[0f32, 0f32, 0f32, 0f32]), 0xffffffff);
        }

        Ok(())
    }

    fn set_raster_options(
        &self,
        dev: &ID3D11Device,
        ctx: &ID3D11DeviceContext,
    ) -> Result<(), RenderError> {
        let raster_desc = D3D11_RASTERIZER_DESC {
            FillMode: D3D11_FILL_SOLID,
            CullMode: D3D11_CULL_NONE,
            FrontCounterClockwise: false.into(),
            DepthBias: false.into(),
            DepthBiasClamp: 0.,
            SlopeScaledDepthBias: 0.,
            DepthClipEnable: false.into(),
            ScissorEnable: true.into(),
            MultisampleEnable: false.into(),
            AntialiasedLineEnable: false.into(),
        };

        unsafe {
            let mut options = None;
            dev.CreateRasterizerState(&raster_desc, Some(&mut options))?;
            let options = options.ok_or(RenderError::General("Unable to set options"))?;
            ctx.RSSetState(&options);
            Ok(())
        }
    }

    fn set_sampler_state(
        &self,
        dev: &ID3D11Device,
        ctx: &ID3D11DeviceContext,
    ) -> Result<(), RenderError> {
        let desc = D3D11_SAMPLER_DESC {
            Filter: D3D11_FILTER_MIN_MAG_MIP_LINEAR,
            AddressU: D3D11_TEXTURE_ADDRESS_BORDER,
            AddressV: D3D11_TEXTURE_ADDRESS_BORDER,
            AddressW: D3D11_TEXTURE_ADDRESS_BORDER,
            MipLODBias: 0.,
            ComparisonFunc: D3D11_COMPARISON_ALWAYS,
            MinLOD: 0.,
            MaxLOD: 0.,
            BorderColor: [1., 1., 1., 1.],
            ..Default::default()
        };

        unsafe {
            let mut sampler = None;
            dev.CreateSamplerState(&desc, Some(&mut sampler))?;
            ctx.PSSetSamplers(0, Some(&[sampler]));
            Ok(())
        }
    }
}

unsafe fn get_device_and_context(
    swap: &IDXGISwapChain,
) -> Result<(ID3D11Device, ID3D11DeviceContext), RenderError> {
    let device: ID3D11Device = swap.GetDevice()?;
    let context = device.GetImmediateContext()?;
    Ok((device, context))
}

```

`egui/egui-directx11/src/shader/mod.rs`:

```rs
use std::{io::Write, slice::from_raw_parts};

use windows::{
    core::{s, PCSTR},
    Win32::Graphics::{
        Direct3D::{
            Fxc::{D3DCompile, D3DCOMPILE_DEBUG, D3DCOMPILE_ENABLE_STRICTNESS},
            ID3DBlob,
        },
        Direct3D11::{ID3D11Device, ID3D11PixelShader, ID3D11VertexShader},
    },
};

use crate::RenderError;

trait Shader: Sized {
    const ENTRY: PCSTR;
    const TARGET: PCSTR;

    unsafe fn create_shader(device: &ID3D11Device, blob: &ShaderData) -> Result<Self, RenderError>;
}

impl Shader for ID3D11VertexShader {
    const ENTRY: PCSTR = s!("vs_main");
    const TARGET: PCSTR = s!("vs_5_0");

    unsafe fn create_shader(device: &ID3D11Device, blob: &ShaderData) -> Result<Self, RenderError> {
        let mut output = None;
        match blob {
            ShaderData::EmbeddedData(arr) => {
                device.CreateVertexShader(arr, None, Some(&mut output))?;
                output
                    .ok_or(RenderError::General("Unable to create vertex shader for embedded data"))
            }
            ShaderData::CompiledBlob(blob) => {
                device.CreateVertexShader(
                    from_raw_parts(blob.GetBufferPointer() as _, blob.GetBufferSize()),
                    None,
                    Some(&mut output),
                )?;
                output
                    .ok_or(RenderError::General("Unable to create vertex shader for compiled blob"))
            }
        }
    }
}

impl Shader for ID3D11PixelShader {
    const ENTRY: PCSTR = s!("ps_main");
    const TARGET: PCSTR = s!("ps_5_0");

    unsafe fn create_shader(device: &ID3D11Device, blob: &ShaderData) -> Result<Self, RenderError> {
        let mut output = None;
        match blob {
            ShaderData::EmbeddedData(arr) => {
                device.CreatePixelShader(arr, None, Some(&mut output))?;
                output
                    .ok_or(RenderError::General("Unable to create pixel shader for embedded data"))
            }
            ShaderData::CompiledBlob(blob) => {
                device.CreatePixelShader(
                    from_raw_parts(blob.GetBufferPointer() as _, blob.GetBufferSize()),
                    None,
                    Some(&mut output),
                )?;
                output
                    .ok_or(RenderError::General("Unable to create pixel shader for compiled blob"))
            }
        }
    }
}

pub enum ShaderData {
    EmbeddedData(&'static [u8]),
    CompiledBlob(ID3DBlob),
}

pub struct CompiledShaders {
    pub vertex: ID3D11VertexShader,
    pub pixel: ID3D11PixelShader,
    cache: ShaderData,
}

impl CompiledShaders {
    pub fn new(device: &ID3D11Device) -> Result<Self, RenderError> {
        if cfg!(feature = "force-compile") {
            let (vcache, vertex) = Self::compile_shader::<ID3D11VertexShader>(device)?;
            let (_pcache, pixel) = Self::compile_shader::<ID3D11PixelShader>(device)?;

            if cfg!(feature = "save-blob") {
                unsafe {
                    std::fs::OpenOptions::new()
                        .write(true)
                        .read(true)
                        .create(true)
                        .open("vertex.bin")
                        .unwrap()
                        .write_all(std::slice::from_raw_parts(
                            vcache.GetBufferPointer() as *mut u8,
                            vcache.GetBufferSize(),
                        ))
                        .unwrap();

                    std::fs::OpenOptions::new()
                        .write(true)
                        .read(true)
                        .create(true)
                        .open("pixel.bin")
                        .unwrap()
                        .write_all(std::slice::from_raw_parts(
                            _pcache.GetBufferPointer() as *mut u8,
                            _pcache.GetBufferSize(),
                        ))
                        .unwrap();
                }
            }

            Ok(Self { vertex, pixel, cache: ShaderData::CompiledBlob(vcache) })
        } else {
            unsafe {
                let cache = ShaderData::EmbeddedData(include_bytes!("vertex.bin"));
                let vertex = ID3D11VertexShader::create_shader(device, &cache)?;
                let pixel = ID3D11PixelShader::create_shader(
                    device,
                    &ShaderData::EmbeddedData(include_bytes!("pixel.bin")),
                )?;

                Ok(Self { cache, vertex, pixel })
            }
        }
    }

    pub fn bytecode(&self) -> &[u8] {
        match &self.cache {
            ShaderData::EmbeddedData(arr) => arr,
            ShaderData::CompiledBlob(blob) => unsafe {
                from_raw_parts(blob.GetBufferPointer() as _, blob.GetBufferSize())
            },
        }
    }

    fn compile_shader<S: Shader>(device: &ID3D11Device) -> Result<(ID3DBlob, S), RenderError> {
        const SHADER_TEXT: &str = include_str!("shader.hlsl");

        let mut flags = D3DCOMPILE_ENABLE_STRICTNESS;
        if cfg!(debug_assertions) {
            flags |= D3DCOMPILE_DEBUG;
        }

        let mut code = None;
        let mut error = None;

        unsafe {
            if D3DCompile(
                SHADER_TEXT.as_ptr() as _,
                SHADER_TEXT.len(),
                None,
                None,
                None,
                S::ENTRY,
                S::TARGET,
                flags,
                0,
                &mut code,
                Some(&mut error),
            )
            .is_err()
            {
                if !cfg!(feature = "no-msgs") {
                    panic!(
                        "{}",
                        std::str::from_utf8_unchecked(std::slice::from_raw_parts(
                            error.as_ref().unwrap().GetBufferPointer() as *const u8,
                            error.as_ref().unwrap().GetBufferSize(),
                        ))
                    );
                } else {
                    panic!();
                }
            } else {
                Ok((
                    code.clone().unwrap(),
                    S::create_shader(device, &ShaderData::CompiledBlob(code.unwrap()))?,
                ))
            }
        }
    }
}

```

`egui/egui-directx11/src/shader/shader.hlsl`:

```hlsl
struct vs_in {
  float2 position : POSITION;
  float2 uv : TEXCOORD;
  float4 color : COLOR;
};

struct vs_out {
  float4 clip : SV_POSITION;
  float2 uv : TEXCOORD;
  float4 color : COLOR;
};

vs_out vs_main(vs_in input) {
  vs_out output;
  output.clip = float4(input.position, 0.0, 1.0);
  output.uv = input.uv;
  output.color = input.color;

  return output;
}

sampler sampler0;
Texture2D texture0;

float4 ps_main(vs_out input) : SV_TARGET {
  return pow(input.color, 1.0 / 2.2) * texture0.Sample(sampler0, input.uv);
}
```

`egui/egui-directx11/src/texture.rs`:

```rs
use egui::{Color32, ImageData, TextureId, TexturesDelta};
use std::{collections::HashMap, mem::size_of, slice::from_raw_parts_mut};
use windows::Win32::Graphics::{
    Direct3D::D3D11_SRV_DIMENSION_TEXTURE2D,
    Direct3D11::{
        ID3D11Device, ID3D11DeviceContext, ID3D11ShaderResourceView, ID3D11Texture2D,
        D3D11_BIND_SHADER_RESOURCE, D3D11_CPU_ACCESS_WRITE, D3D11_MAPPED_SUBRESOURCE,
        D3D11_MAP_WRITE_DISCARD, D3D11_SHADER_RESOURCE_VIEW_DESC,
        D3D11_SHADER_RESOURCE_VIEW_DESC_0, D3D11_SUBRESOURCE_DATA, D3D11_TEX2D_SRV,
        D3D11_TEXTURE2D_DESC, D3D11_USAGE_DYNAMIC,
    },
    Dxgi::Common::{DXGI_FORMAT_R8G8B8A8_UNORM, DXGI_SAMPLE_DESC},
};

use crate::RenderError;

struct ManagedTexture {
    resource: ID3D11ShaderResourceView,
    texture: ID3D11Texture2D,
    pixels: Vec<Color32>,
    width: usize,
}

#[derive(Default)]
pub struct TextureAllocator {
    allocated: HashMap<TextureId, ManagedTexture>,
}

impl TextureAllocator {
    pub fn process_deltas(
        &mut self,
        dev: &ID3D11Device,
        ctx: &ID3D11DeviceContext,
        delta: TexturesDelta,
    ) -> Result<(), RenderError> {
        for (tid, delta) in delta.set {
            if delta.is_whole() {
                self.allocate_new(dev, tid, delta.image)?;
            } else {
                let _did_update = self.update_partial(ctx, tid, delta.image, delta.pos.unwrap())?;
            }
        }

        for tid in delta.free {
            self.free(tid);
        }

        Ok(())
    }

    pub fn get_by_id(&self, tid: TextureId) -> Option<ID3D11ShaderResourceView> {
        self.allocated.get(&tid).map(|t| t.resource.clone())
    }
}

impl TextureAllocator {
    fn allocate_new(
        &mut self,
        dev: &ID3D11Device,
        tid: TextureId,
        image: ImageData,
    ) -> Result<(), RenderError> {
        let tex = Self::allocate_texture(dev, image)?;
        self.allocated.insert(tid, tex);
        Ok(())
    }

    fn free(&mut self, tid: TextureId) -> bool {
        self.allocated.remove(&tid).is_some()
    }

    fn update_partial(
        &mut self,
        ctx: &ID3D11DeviceContext,
        tid: TextureId,
        image: ImageData,
        [nx, ny]: [usize; 2],
    ) -> Result<bool, RenderError> {
        if let Some(old) = self.allocated.get_mut(&tid) {
            let subr = unsafe {
                let mut output = D3D11_MAPPED_SUBRESOURCE::default();
                ctx.Map(&old.texture, 0, D3D11_MAP_WRITE_DISCARD, 0, Some(&mut output))?;
                output
            };

            match image {
                ImageData::Font(f) => unsafe {
                    let data = from_raw_parts_mut(subr.pData as *mut Color32, old.pixels.len());
                    data.as_mut_ptr()
                        .copy_from_nonoverlapping(old.pixels.as_ptr(), old.pixels.len());

                    let new: Vec<Color32> = f
                        .pixels
                        .iter()
                        .map(|a| Color32::from_rgba_premultiplied(255, 255, 255, (a * 255.) as u8))
                        .collect();

                    for y in 0..f.height() {
                        for x in 0..f.width() {
                            let whole = (ny + y) * old.width + nx + x;
                            let frac = y * f.width() + x;
                            old.pixels[whole] = new[frac];
                            data[whole] = new[frac];
                        }
                    }
                },
                _ => unreachable!(),
            }

            unsafe {
                ctx.Unmap(&old.texture, 0);
            }

            Ok(true)
        } else {
            Ok(false)
        }
    }

    fn allocate_texture(
        dev: &ID3D11Device,
        image: ImageData,
    ) -> Result<ManagedTexture, RenderError> {
        let desc = D3D11_TEXTURE2D_DESC {
            Width: image.width() as _,
            Height: image.height() as _,
            MipLevels: 1,
            ArraySize: 1,
            Format: DXGI_FORMAT_R8G8B8A8_UNORM,
            SampleDesc: DXGI_SAMPLE_DESC { Count: 1, Quality: 0 },
            Usage: D3D11_USAGE_DYNAMIC,
            BindFlags: D3D11_BIND_SHADER_RESOURCE.0 as u32,
            CPUAccessFlags: D3D11_CPU_ACCESS_WRITE.0 as u32,
            ..Default::default()
        };

        // rust is cringe sometimes
        let width = image.width();
        let pixels = match image {
            ImageData::Color(c) => c.pixels,
            ImageData::Font(f) => f
                .pixels
                .iter()
                .map(|a| Color32::from_rgba_premultiplied(255, 255, 255, (a * 255.) as u8))
                .collect(),
        };

        let data = D3D11_SUBRESOURCE_DATA {
            pSysMem: pixels.as_ptr() as _,
            SysMemPitch: (width * size_of::<Color32>()) as u32,
            SysMemSlicePitch: 0,
        };

        unsafe {
            let texture = {
                let mut output_texture = None;
                dev.CreateTexture2D(&desc, Some(&data), Some(&mut output_texture))?;
                output_texture.ok_or(RenderError::General("Unable to create Texture 2D"))?
            };

            let desc = D3D11_SHADER_RESOURCE_VIEW_DESC {
                Format: DXGI_FORMAT_R8G8B8A8_UNORM,
                ViewDimension: D3D11_SRV_DIMENSION_TEXTURE2D,
                Anonymous: D3D11_SHADER_RESOURCE_VIEW_DESC_0 {
                    Texture2D: D3D11_TEX2D_SRV { MostDetailedMip: 0, MipLevels: desc.MipLevels },
                },
            };

            let resource = {
                let mut output_resource = None;
                dev.CreateShaderResourceView(&texture, Some(&desc), Some(&mut output_resource))?;
                output_resource.ok_or(RenderError::General("Failed to create shader view"))?
            };

            Ok(ManagedTexture { width, resource, pixels, texture })
        }
    }
}

```

`egui/egui-win32/Cargo.toml`:

```toml
[package]
name = "egui-win32"
version = "0.1.0"
edition = "2021"
license = "MIT"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
egui = "0.22.0"
windows = { version = "0.51.1", features = [
    "Win32_System_WindowsProgramming",
    "Win32_Foundation",
    "Win32_UI_Input_KeyboardAndMouse",
    "Wdk_System_SystemInformation"
] }
clipboard-win = "4.5.0"

```

`egui/egui-win32/README.md`:

```md
# Egui Win32

Windows32 input handler for egui;
Takes input from windows api , WndProc and converts it into egui compatible RawInput

## Sources
https://crates.io/crates/egui-d3d9
https://crates.io/crates/egui-d3d11
```

`egui/egui-win32/src/lib.rs`:

```rs
use egui::{Event, Key, Modifiers, PointerButton, Pos2, RawInput, Rect, Vec2};
use windows::{
    Wdk::System::SystemInformation::NtQuerySystemTime,
    Win32::{
        Foundation::{HWND, RECT},
        System::SystemServices::{MK_CONTROL, MK_SHIFT},
        UI::{
            Input::KeyboardAndMouse::{
                GetAsyncKeyState, VIRTUAL_KEY, VK_BACK, VK_CONTROL, VK_DELETE, VK_DOWN, VK_END,
                VK_ESCAPE, VK_HOME, VK_INSERT, VK_LEFT, VK_LSHIFT, VK_NEXT, VK_PRIOR, VK_RETURN,
                VK_RIGHT, VK_SPACE, VK_TAB, VK_UP,
            },
            WindowsAndMessaging::{
                GetClientRect, KF_REPEAT, WHEEL_DELTA, WM_CHAR, WM_KEYDOWN, WM_KEYUP,
                WM_LBUTTONDBLCLK, WM_LBUTTONDOWN, WM_LBUTTONUP, WM_MBUTTONDBLCLK, WM_MBUTTONDOWN,
                WM_MBUTTONUP, WM_MOUSEHWHEEL, WM_MOUSEMOVE, WM_MOUSEWHEEL, WM_RBUTTONDBLCLK,
                WM_RBUTTONDOWN, WM_RBUTTONUP, WM_SYSKEYDOWN, WM_SYSKEYUP, WM_XBUTTONDBLCLK,
                WM_XBUTTONDOWN, WM_XBUTTONUP, XBUTTON1, XBUTTON2,
            },
        },
    },
};

pub struct InputManager {
    hwnd: HWND,
    events: Vec<Event>,
    modifiers: Option<Modifiers>,
}

/// High-level overview of recognized `WndProc` messages.
#[repr(u8)]
pub enum InputResult {
    Unknown,
    MouseMove,
    MouseLeft,
    MouseRight,
    MouseMiddle,
    Character,
    Scroll,
    Zoom,
    Key,
}

type Result<T> = std::result::Result<T, windows::core::Error>;

impl InputResult {
    #[inline]
    pub fn is_valid(&self) -> bool {
        !self.is_unknown()
    }

    #[inline]
    pub fn is_unknown(&self) -> bool {
        matches!(*self, InputResult::Unknown)
    }
}

impl InputManager {
    pub fn new(hwnd: HWND) -> Self {
        Self { hwnd, events: vec![], modifiers: None }
    }

    pub fn process(&mut self, umsg: u32, wparam: usize, lparam: isize) -> InputResult {
        match umsg {
            WM_MOUSEMOVE => {
                self.alter_modifiers(get_mouse_modifiers(wparam));

                self.events.push(Event::PointerMoved(get_pos(lparam)));
                InputResult::MouseMove
            }
            WM_LBUTTONDOWN | WM_LBUTTONDBLCLK => {
                let modifiers = get_mouse_modifiers(wparam);
                self.alter_modifiers(modifiers);

                self.events.push(Event::PointerButton {
                    pos: get_pos(lparam),
                    button: PointerButton::Primary,
                    pressed: true,
                    modifiers,
                });
                InputResult::MouseLeft
            }
            WM_LBUTTONUP => {
                let modifiers = get_mouse_modifiers(wparam);
                self.alter_modifiers(modifiers);

                self.events.push(Event::PointerButton {
                    pos: get_pos(lparam),
                    button: PointerButton::Primary,
                    pressed: false,
                    modifiers,
                });
                InputResult::MouseLeft
            }
            WM_RBUTTONDOWN | WM_RBUTTONDBLCLK => {
                let modifiers = get_mouse_modifiers(wparam);
                self.alter_modifiers(modifiers);

                self.events.push(Event::PointerButton {
                    pos: get_pos(lparam),
                    button: PointerButton::Secondary,
                    pressed: true,
                    modifiers,
                });
                InputResult::MouseRight
            }
            WM_RBUTTONUP => {
                let modifiers = get_mouse_modifiers(wparam);
                self.alter_modifiers(modifiers);

                self.events.push(Event::PointerButton {
                    pos: get_pos(lparam),
                    button: PointerButton::Secondary,
                    pressed: false,
                    modifiers,
                });
                InputResult::MouseRight
            }
            WM_MBUTTONDOWN | WM_MBUTTONDBLCLK => {
                let modifiers = get_mouse_modifiers(wparam);
                self.alter_modifiers(modifiers);

                self.events.push(Event::PointerButton {
                    pos: get_pos(lparam),
                    button: PointerButton::Middle,
                    pressed: true,
                    modifiers,
                });
                InputResult::MouseMiddle
            }
            WM_MBUTTONUP => {
                let modifiers = get_mouse_modifiers(wparam);
                self.alter_modifiers(modifiers);

                self.events.push(Event::PointerButton {
                    pos: get_pos(lparam),
                    button: PointerButton::Middle,
                    pressed: false,
                    modifiers,
                });
                InputResult::MouseMiddle
            }
            WM_XBUTTONDOWN | WM_XBUTTONDBLCLK => {
                let modifiers = get_mouse_modifiers(wparam);
                self.alter_modifiers(modifiers);

                self.events.push(Event::PointerButton {
                    pos: get_pos(lparam),
                    button: if (wparam as u32) >> 16 & (XBUTTON1 as u32) != 0 {
                        PointerButton::Extra1
                    } else if (wparam as u32) >> 16 & (XBUTTON2 as u32) != 0 {
                        PointerButton::Extra2
                    } else {
                        unreachable!()
                    },
                    pressed: true,
                    modifiers,
                });
                InputResult::MouseMiddle
            }
            WM_XBUTTONUP => {
                let modifiers = get_mouse_modifiers(wparam);
                self.alter_modifiers(modifiers);

                self.events.push(Event::PointerButton {
                    pos: get_pos(lparam),
                    button: if (wparam as u32) >> 16 & (XBUTTON1 as u32) != 0 {
                        PointerButton::Extra1
                    } else if (wparam as u32) >> 16 & (XBUTTON2 as u32) != 0 {
                        PointerButton::Extra2
                    } else {
                        unreachable!()
                    },
                    pressed: false,
                    modifiers,
                });
                InputResult::MouseMiddle
            }
            WM_CHAR => {
                if let Some(ch) = char::from_u32(wparam as _) {
                    if !ch.is_control() {
                        self.events.push(Event::Text(ch.into()));
                    }
                }
                InputResult::Character
            }
            WM_MOUSEWHEEL => {
                self.alter_modifiers(get_mouse_modifiers(wparam));

                let delta = (wparam >> 16) as i16 as f32 * 10. / WHEEL_DELTA as f32;

                if wparam & MK_CONTROL.0 as usize != 0 {
                    self.events.push(Event::Zoom(if delta > 0. { 1.5 } else { 0.5 }));
                    InputResult::Zoom
                } else {
                    self.events.push(Event::Scroll(Vec2::new(0., delta)));
                    InputResult::Scroll
                }
            }
            WM_MOUSEHWHEEL => {
                self.alter_modifiers(get_mouse_modifiers(wparam));

                let delta = (wparam >> 16) as i16 as f32 * 10. / WHEEL_DELTA as f32;

                if wparam & MK_CONTROL.0 as usize != 0 {
                    self.events.push(Event::Zoom(if delta > 0. { 1.5 } else { 0.5 }));
                    InputResult::Zoom
                } else {
                    self.events.push(Event::Scroll(Vec2::new(delta, 0.)));
                    InputResult::Scroll
                }
            }
            msg @ (WM_KEYDOWN | WM_SYSKEYDOWN) => {
                let modifiers = get_key_modifiers(msg);
                self.modifiers = Some(modifiers);

                if let Some(key) = get_key(wparam) {
                    if key == Key::V && modifiers.ctrl {
                        if let Some(clipboard) = get_clipboard_text() {
                            self.events.push(Event::Text(clipboard));
                        }
                    }

                    if key == Key::C && modifiers.ctrl {
                        self.events.push(Event::Copy);
                    }

                    if key == Key::X && modifiers.ctrl {
                        self.events.push(Event::Cut);
                    }

                    self.events.push(Event::Key {
                        pressed: true,
                        modifiers,
                        key,
                        repeat: lparam & (KF_REPEAT as isize) > 0,
                    });
                }
                InputResult::Key
            }
            msg @ (WM_KEYUP | WM_SYSKEYUP) => {
                let modifiers = get_key_modifiers(msg);
                self.modifiers = Some(modifiers);

                if let Some(key) = get_key(wparam) {
                    self.events.push(Event::Key { pressed: false, modifiers, key, repeat: false });
                }
                InputResult::Key
            }
            _ => InputResult::Unknown,
        }
    }

    fn alter_modifiers(&mut self, new: Modifiers) {
        if let Some(old) = self.modifiers.as_mut() {
            *old = new;
        }
    }

    pub fn collect_input(&mut self) -> Result<RawInput> {
        Ok(RawInput {
            modifiers: self.modifiers.unwrap_or_default(),
            events: std::mem::take(&mut self.events),
            screen_rect: Some(self.get_screen_rect()),
            time: Some(Self::get_system_time()?),
            pixels_per_point: Some(1.),
            max_texture_side: None,
            predicted_dt: 1. / 60.,
            hovered_files: vec![],
            dropped_files: vec![],
            focused: true,
        })
    }

    /// Returns time in seconds.
    pub fn get_system_time() -> Result<f64> {
        let mut time = 0;
        unsafe {
            NtQuerySystemTime(&mut time)?;
        }

        // dumb ass, read the docs. egui clearly says `in seconds`.
        // Shouldn't have wasted 3 days on this.
        // `NtQuerySystemTime` returns how many 100 nanosecond intervals
        // past since 1st Jan, 1601.
        Ok((time as f64) / 10_000_000.)
    }

    #[inline]
    pub fn get_screen_size(&self) -> Pos2 {
        let mut rect = RECT::default();
        unsafe {
            GetClientRect(self.hwnd, &mut rect).unwrap();
        }

        Pos2::new((rect.right - rect.left) as f32, (rect.bottom - rect.top) as f32)
    }

    #[inline]
    pub fn get_screen_rect(&self) -> Rect {
        Rect { min: Pos2::ZERO, max: self.get_screen_size() }
    }
}

fn get_pos(lparam: isize) -> Pos2 {
    let x = (lparam & 0xFFFF) as i16 as f32;
    let y = (lparam >> 16 & 0xFFFF) as i16 as f32;

    Pos2::new(x, y)
}

fn get_mouse_modifiers(wparam: usize) -> Modifiers {
    Modifiers {
        alt: false,
        ctrl: (wparam & MK_CONTROL.0 as usize) != 0,
        shift: (wparam & MK_SHIFT.0 as usize) != 0,
        mac_cmd: false,
        command: (wparam & MK_CONTROL.0 as usize) != 0,
    }
}

fn get_key_modifiers(msg: u32) -> Modifiers {
    let ctrl = unsafe { GetAsyncKeyState(VK_CONTROL.0 as _) != 0 };
    let shift = unsafe { GetAsyncKeyState(VK_LSHIFT.0 as _) != 0 };

    Modifiers { alt: msg == WM_SYSKEYDOWN, mac_cmd: false, command: ctrl, shift, ctrl }
}

fn get_key(wparam: usize) -> Option<Key> {
    match wparam {
        0x30..=0x39 => unsafe { Some(std::mem::transmute::<_, Key>(wparam as u8 - 0x1F)) },
        0x41..=0x5A => unsafe { Some(std::mem::transmute::<_, Key>(wparam as u8 - 0x26)) },
        0x70..=0x83 => unsafe { Some(std::mem::transmute::<_, Key>(wparam as u8 - 0x3B)) },
        _ => match VIRTUAL_KEY(wparam as u16) {
            VK_DOWN => Some(Key::ArrowDown),
            VK_LEFT => Some(Key::ArrowLeft),
            VK_RIGHT => Some(Key::ArrowRight),
            VK_UP => Some(Key::ArrowUp),
            VK_ESCAPE => Some(Key::Escape),
            VK_TAB => Some(Key::Tab),
            VK_BACK => Some(Key::Backspace),
            VK_RETURN => Some(Key::Enter),
            VK_SPACE => Some(Key::Space),
            VK_INSERT => Some(Key::Insert),
            VK_DELETE => Some(Key::Delete),
            VK_HOME => Some(Key::Home),
            VK_END => Some(Key::End),
            VK_PRIOR => Some(Key::PageUp),
            VK_NEXT => Some(Key::PageDown),
            _ => None,
        },
    }
}

fn get_clipboard_text() -> Option<String> {
    None
    // clipboard_win::get_clipboard(clipboard_win::formats::Unicode).ok()
}

```

`macros/memory/Cargo.toml`:

```toml
[package]
name = "memory_macros"
version = "0.1.0"
edition = "2021"

[lib]
proc-macro = true
path = "src/lib.rs"

[dependencies]
proc-macro2 = "1.0.69"
quote = "1.0.33"
syn = { version = "2.0.38", features = ["full"] }

```

`macros/memory/src/lib.rs`:

```rs
use proc_macro::TokenStream;

mod vfunc;
mod vmt;

#[proc_macro_attribute]
pub fn vmt(_attr: TokenStream, item: TokenStream) -> TokenStream {
    vmt::vmt_impl(item)
}

#[proc_macro_attribute]
pub fn vfunc(attr: TokenStream, item: TokenStream) -> TokenStream {
    vfunc::vfunc_impl(attr, item)
}

```

`macros/memory/src/vfunc.rs`:

```rs
use proc_macro::TokenStream;
use proc_macro2::{Ident, TokenStream as TokenStream2};
use quote::quote;
use syn::{
    parse::{Parse, Parser},
    parse_macro_input,
    punctuated::Punctuated,
    spanned::Spanned,
    token::Comma,
    Expr, ExprLit, FnArg, ItemFn, Lit, ReturnType, Type, TypePath,
};

pub fn vfunc_impl(attr: TokenStream, item: TokenStream) -> TokenStream {
    let index = parse_macro_input!(attr as VirtualFunctionIndex).0;

    let mut func: ItemFn = syn::parse(item.clone()).unwrap();

    let vis = &func.vis;
    let attrs = &func.attrs;

    let sig = &func.sig;

    let inputs = &sig.inputs;
    let output = &sig.output;

    let (arg_idents, arg_types) = get_args(inputs);

    let (converted_args, vfunc_types) = convert_to_c_args(arg_idents, arg_types);

    let vfunc = get_vfunction(index, vfunc_types, output);

    let ret_type = extract_return_type_type(output);

    let vfunc_call = if is_type_ref(&ret_type) {
        func.sig.output = ReturnType::parse
            .parse2(quote! { -> Option<#ret_type> })
            .expect("could not convert reference result type to option");

        Expr::parse
            .parse2(quote! {
                #vfunc(self, #(#converted_args),*).as_ref()
            })
            .expect("could not create vfunction call")
    } else {
        Expr::parse
            .parse2(quote! {
                #vfunc(self, #(#converted_args),*)
            })
            .expect("could not create vfunction call")
    };

    let sig = &func.sig;

    quote! {
        #(#attrs)* #vis #sig {
            unsafe {
                #vfunc_call
            }
        }
    }
    .into()
}

struct VirtualFunctionIndex(isize);

impl Parse for VirtualFunctionIndex {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let index: ExprLit = input.parse()?;

        if let Lit::Int(lit) = &index.lit {
            Ok(Self(lit.base10_parse()?))
        } else {
            Err(syn::Error::new(
                index.span(),
                "invalid virtual function index",
            ))
        }
    }
}

fn get_vfunction(index: isize, types: Vec<Type>, ret_type: &ReturnType) -> TokenStream2 {
    let mut ret_type = extract_return_type_type(ret_type);

    if let Type::Reference(type_ref) = ret_type {
        let elem = type_ref.elem;

        ret_type = Type::parse
            .parse2(quote! { *const #elem })
            .expect("could not convert return type to option");
    }

    quote! {
        std::mem::transmute::<_, extern "fastcall" fn(*const Self, #(#types),*) -> #ret_type> (
           (*std::mem::transmute::<_, *const *const usize>(self)).offset(#index).read()
        )
    }
}

fn extract_return_type_type(ret_type: &ReturnType) -> Type {
    match ret_type {
        ReturnType::Default => Type::parse
            .parse2(quote! { () })
            .expect("could not extract function return type"),
        ReturnType::Type(_, ty) => *ty.clone(),
    }
}

fn get_args(args: &Punctuated<FnArg, Comma>) -> (Vec<Ident>, Vec<Type>) {
    args.iter()
        .filter_map(|arg| match arg {
            FnArg::Receiver(_) => None,
            FnArg::Typed(pat_type) => Some((
                match *pat_type.pat.clone() {
                    syn::Pat::Ident(ident) => ident.ident,
                    _ => return None,
                },
                *pat_type.ty.clone(),
            )),
        })
        .unzip()
}

fn convert_to_c_args(idents: Vec<Ident>, types: Vec<Type>) -> (Vec<Expr>, Vec<Type>) {
    idents
        .iter()
        .zip(types)
        .map(|(ident, ty)| {
            if let Type::Reference(refr) = ty {
                match *refr.elem {
                    Type::Path(path) => {
                        let ref_type = &path
                            .path
                            .segments
                            .last()
                            .expect("could not get reference type")
                            .ident;

                        if ref_type == "str" {
                            convert_to_c_string(ident)
                        } else {
                            convert_to_c_ptr(ident, &path)
                        }
                    }
                    _ => panic!("unexpected reference type"),
                }
            } else {
                (
                    Expr::parse
                        .parse2(quote! { #ident })
                        .expect("could not create arg expression"),
                    ty,
                )
            }
        })
        .unzip()
}

fn convert_to_c_string(ident: &Ident) -> (Expr, Type) {
    (
        Expr::parse
            .parse2(quote! { std::ffi::CString::new(#ident).unwrap().as_ptr() })
            .expect(
                "could not convert create a &str to *const std::ffi::c_char conversion expression",
            ),
        Type::parse
            .parse2(quote! { *const std::ffi::c_char })
            .expect("could not convert &str type to *const std::ffi::c_char"),
    )
}

fn convert_to_c_ptr(ident: &Ident, ref_type: &TypePath) -> (Expr, Type) {
    (
        Expr::parse
            .parse2(quote! { #ident })
            .expect("could not create a c ptr expression"),
        Type::parse
            .parse2(quote! { *const #ref_type })
            .expect("could not convert reference type to c pointer"),
    )
}

fn is_type_ref(ty: &Type) -> bool {
    matches!(ty, Type::Reference(_))
}

```

`macros/memory/src/vmt.rs`:

```rs
use proc_macro::TokenStream;
use quote::{quote, ToTokens};
use syn::{
    parse::Parser, parse_macro_input, Attribute, Field, Fields::Named, FieldsNamed, ItemStruct,
};

pub fn vmt_impl(item: TokenStream) -> TokenStream {
    let mut item = parse_macro_input!(item as ItemStruct);

    add_vmt_field(&mut item);
    add_repr_c(&mut item);

    item.into_token_stream().into()
}

fn add_vmt_field(item: &mut ItemStruct) {
    let fields = match &mut item.fields {
        Named(fields) => fields,
        _ => panic!("#[vmt] can only be applied to structs with named fields"),
    };

    if has_vmt_field(fields) {
        panic!("this struct already has a VMT field")
    }

    let vmt_field = Field::parse_named
        .parse2(quote! {
            __vmt: usize
        })
        .expect("could not add VMT field");

    fields.named.insert(0, vmt_field)
}

fn has_vmt_field(fields: &FieldsNamed) -> bool {
    fields
        .named
        .iter()
        .any(|field| field.ident.clone().map_or(false, |ident| ident == "__vmt"))
}

fn add_repr_c(item: &mut ItemStruct) {
    let mut repr_c = Attribute::parse_outer
        .parse2(quote! {
            #[repr(C)]
        })
        .expect("could not add #[repr(C)]");

    item.attrs.append(&mut repr_c);
}

```

`rustfmt.toml`:

```toml
max_width = 100
use_small_heuristics = "Max"
hard_tabs = false
tab_spaces = 4
newline_style = "Unix"
reorder_imports = true
format_code_in_doc_comments = true
```