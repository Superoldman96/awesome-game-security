Project Path: arc_gmh5225_ritz-amazing-fortnite-internal_d02neb9l

Source Tree:

```txt
arc_gmh5225_ritz-amazing-fortnite-internal_d02neb9l
├── FNTool.cpp
├── FNTool.h
├── Memory.h
├── README.md
├── custom_runtimes.cpp
├── custom_runtimes.h
├── dllmain.cpp
├── includes.h
├── menu.h
├── notes.txt
├── safecall.h
├── sdk.h
├── sdkdefines.h
├── spoof_call.h
├── spoofinternal.asm
├── utils.h
├── vector.h
├── x64
│   └── Release
│       ├── Load Injector.exe
│       ├── inject instructions.txt
│       ├── mmap.exe
│       └── ritz.dll
├── xor.h
├── xxself pasted.filters
├── xxself pasted.sln
├── xxself pasted.user
├── xxself pasted.vcxproj
├── xxself pasted.vcxproj.filters
└── xxself pasted.vcxproj.user

```

`FNTool.cpp`:

```cpp
#include "FNTool.h"
#include "spoof_call.h"
#include "Memory.h"
#include "safecall.h"
#include "xor.h"



bool FNTool::Initialize(uintptr_t GObjects, uintptr_t GetNameByIndex, uintptr_t FnFree)
{

	

	this->ObjectsCount = *(DWORD*)(GObjects + 0x14);
	if (this->ObjectsCount > 0x9000) this->ObjectsCount = 0x9000;

	uintptr_t GObjects_deref = *(uintptr_t*)GObjects;
	if (spoof_call(safe_call(IsBadWritePtr), (const LPVOID)GObjects_deref, (UINT_PTR)8)) { safe_call(MessageBoxA)(0, xorstr("Failed To Initialize"), xorstr("Error"), MB_ICONERROR); return FALSE; }

	uintptr_t GObjects_deref2 = *(uintptr_t*)GObjects_deref;
	if (spoof_call(safe_call(IsBadWritePtr), (const LPVOID)GObjects_deref2, (UINT_PTR)8)) { safe_call(MessageBoxA)(0, xorstr("Failed To Initialize"), xorstr("Error"), MB_ICONERROR); return FALSE; }

	this->UObjectArray = GObjects_deref2;
	this->GetNameByIndex = GetNameByIndex;
	this->FnFree = FnFree;

	return true;
}

BOOLEAN MaskCompare(PVOID buffer, LPCSTR pattern, LPCSTR mask) {
	for (auto b = reinterpret_cast<PBYTE>(buffer); *mask; ++pattern, ++mask, ++b) {
		if (*mask == 'x' && *reinterpret_cast<LPCBYTE>(pattern) != *b) {
			return FALSE;
		}
	}

	return TRUE;
}

PBYTE FindPattern2(LPCSTR pattern, LPCSTR mask) {
	MODULEINFO info = { 0 };
	GetModuleInformation(safe_call(GetCurrentProcess)(), GetModuleHandle(0), &info, sizeof(info));

	info.SizeOfImage -= static_cast<DWORD>(strlen(mask));

	for (auto i = 0UL; i < info.SizeOfImage; ++i) {
		auto addr = reinterpret_cast<PBYTE>(info.lpBaseOfDll) + i;
		if (MaskCompare(addr, pattern, mask)) {
			return addr;
		}
	}
}

uintptr_t FNTool::FindSignature(const char* Signature) {
	uintptr_t SigResult = MemoryHelper::Pattern::PatternScan(Signature);
	return SigResult;
}

VOID FNTool::FindAndLogOffset(const char* Class, const char* OffsetName)
{
	int strlenght = strlen((std::string(xorstr("")) + Class + xorstr(".") + OffsetName).c_str());

	int calculation = 52 - strlenght;

	std::string strspace = "";

	for (int i = 0; i < calculation; i++) {
		strspace = strspace + " ";
	}

	std::cout << "  " << Class << "." << OffsetName << strspace << xorstr(" ->   0x") << std::hex << std::uppercase << this->FindOffset(Class, OffsetName) << std::endl;

}
DWORD FNTool::FindOffset(const char* Class, const char* varName)
{
	for (DWORD i = 0x0; i < this->ObjectsCount; i++)
	{
		auto CurrentObject = *(uintptr_t*)(this->UObjectArray + (i * 0x18));

		if (!CurrentObject) {safe_call(MessageBoxA)(0, xorstr("curobjnull"), 0, 0); return NULL; }
		if (!(*(uintptr_t*)(CurrentObject + 0x50)) || *(DWORD*)(CurrentObject + 0x54) == 0xFFFFFFFF) continue;


		char* CurObjectName = this->fGetObjectName(CurrentObject);

		if (!strcmp(CurObjectName, Class)) //Same class
		{
			for (auto Property = *(uint64_t*)(CurrentObject + 0x50); !spoof_call(safe_call(IsBadWritePtr), (LPVOID)Property, (UINT_PTR)8); Property = *(uint64_t*)(Property + 0x20))
			{
				auto Type = *(uint64_t*)(Property + 0x8);

				if (!spoof_call(safe_call(IsBadWritePtr), (LPVOID)Type, (UINT_PTR)8) && Type)
				{
					auto Property_FName = *(ue::FName*)(Property + 0x28);
					auto Offset = *(DWORD*)(Property + 0x44);

					if (Offset != 0)
					{
						auto Property_idx = Property_FName.ComparisonIndex;

						if (Property_idx)
						{
							char* PropertyName = this->fGetNameByIndex(Property_idx);

							if (!strcmp(PropertyName, varName))
							{
								return Offset;
							}
						}
					}
				}

			}

			return NULL; //Return NULL if checked all properties of the class.
		}
	}
}

VOID FNTool::FindAndLogClass(const char* Class)
{
	std::cout << xorstr("\n");
	for (DWORD i = 0x0; i < this->ObjectsCount; i++)
	{
		auto CurrentObject = *(uintptr_t*)(this->UObjectArray + (i * 0x18));

		if (!CurrentObject) return;
		if (!(*(uintptr_t*)(CurrentObject + 0x50)) || *(DWORD*)(CurrentObject + 0x54) == 0xFFFFFFFF) continue;


		char* CurObjectName = this->fGetObjectName(CurrentObject);

		if (!strcmp(CurObjectName, Class)) //Same class
		{
			for (auto Property = *(uint64_t*)(CurrentObject + 0x50); !safe_call(IsBadWritePtr)((LPVOID)Property, 8); Property = *(uint64_t*)(Property + 0x20))
			{
				auto Type = *(uint64_t*)(Property + 0x8);

				if (!safe_call(IsBadWritePtr)((LPVOID)Type, 8) && Type)
				{
					auto Property_FName = *(ue::FName*)(Property + 0x28);
					auto Offset = *(DWORD*)(Property + 0x44);

					if (Offset != 0)
					{
						auto Property_idx = Property_FName.ComparisonIndex;

						if (Property_idx)
						{
							char* PropertyName = this->fGetNameByIndex(Property_idx);

							int strlenght = strlen((std::string(xorstr("")) + PropertyName).c_str());

							int calculation = 52 - strlenght;

							std::string strspace = "";

							for (int iii = 0; iii < calculation; iii++) {
								strspace = strspace + xorstr(" ");
							}
							int jjjj = 0;

							for (int iiiii = 0; iiiii < strlenght; iiiii++)
								if (PropertyName[iiiii] >= 0 && PropertyName[iiiii] <= 127)
									PropertyName[jjjj++] = PropertyName[iiiii];

							std::cout << xorstr("  ") << PropertyName << strspace << xorstr(" ->   0x") << std::hex << std::uppercase << Offset << std::endl;

						}
					}
				}

			}

			return;
		}

	}
	std::cout << xorstr("  [!] Class doesn't exists\n");
}

void FNTool::cFixName(char* Name)
{
	for (int i = 0; Name[i] != '\0'; i++)
	{
		if (Name[i] == '_')
		{
			if (Name[i + 1] == '0' ||
				Name[i + 1] == '1' ||
				Name[i + 1] == '2' ||
				Name[i + 1] == '3' ||
				Name[i + 1] == '4' ||
				Name[i + 1] == '5' ||
				Name[i + 1] == '6' ||
				Name[i + 1] == '7' ||
				Name[i + 1] == '8' ||
				Name[i + 1] == '9')
				Name[i] = '\0';
		}
	}

	return;
}

void FNTool::FreeObjName(uintptr_t Address)
{
	if (Address == NULL) return;

	auto func = reinterpret_cast<__int64(__fastcall*)(__int64)>(this->FnFree);

	spoof_call( func, (__int64)Address);
}

char* FNTool::fGetObjectName(uintptr_t Object)
{
	if (Object == 0) return (char*)("");

	char* return_string = FNTool::fGetNameByIndex(*(int*)(Object + 0x18));

	if (return_string == NULL) return (char*)"";

	return return_string;
}

char* FNTool::fGetNameByIndex(int Index)
{
	if (Index == 0) return (char*)"";

	auto fGetNameByIdx = reinterpret_cast<ue::FString * (__fastcall*)(int*, ue::FString*)>(this->GetNameByIndex);

	ue::FString result;
	spoof_call( fGetNameByIdx, &Index, &result);

	if (result.c_str() == NULL) return (char*)"";

	auto tmp = result.ToString();

	char return_string[1024];
	spoof_call( memcpy, (void*)return_string, (const void*)std::string(tmp.begin(), tmp.end()).c_str(), (size_t)1024);

	FreeObjName((uintptr_t)result.c_str());

	cFixName(return_string);

	return return_string;
}

```

`FNTool.h`:

```h
#pragma once
#include <Windows.h>

#define RELATIVE(addr, size) ((uintptr_t)((UINT_PTR)(addr) + *(PINT)((UINT_PTR)(addr) + ((size) - sizeof(INT))) + (size)))

static const void* game_rbx_jmp;

class FNTool
{
public:
	bool Initialize(uintptr_t GObjects, uintptr_t GetNameByIndex, uintptr_t FnFree);
	uintptr_t FindSignature(const char* Signature);
	DWORD FindOffset(const char* Class, const char* var);
	VOID FindAndLogOffset(const char* Class, const char* var);
	VOID FindAndLogClass(const char* Class);
	VOID FindAndChangeOffset(const char* Class, const char* var, uintptr_t& offfset);

private:
	uintptr_t UObjectArray = NULL;
	uintptr_t GetNameByIndex = NULL;
	uintptr_t FnFree = NULL;
	DWORD ObjectsCount = 0;

	void cFixName(char* Name);
	void FreeObjName(uintptr_t Address);
	char* fGetObjectName(uintptr_t Object);
	char* fGetNameByIndex(int Index);
};
```

`Memory.h`:

```h
#pragma once
#include <Psapi.h>
#include "safecall.h"

namespace MemoryHelper
{
	namespace Pattern
	{
		uintptr_t PatternScan(uintptr_t pModuleBaseAddress, const char* sSignature, size_t nSelectResultIndex = 0);
		uintptr_t PatternScan(const char* sSignature, size_t nSelectResultIndex = 0);
	}

    void Log(const char* sFilePath, char const* const sFormat, ...);
}

uintptr_t MemoryHelper::Pattern::PatternScan(uintptr_t pModuleBaseAddress, const char* sSignature, size_t nSelectResultIndex)
{
    static auto patternToByte = [](const char* pattern)
    {
        auto       bytes = std::vector<int>{};
        const auto start = const_cast<char*>(pattern);
        const auto end = const_cast<char*>(pattern) + strlen(pattern);

        for (auto current = start; current < end; ++current)
        {
            if (*current == '?')
            {
                ++current;
                if (*current == '?')
                    ++current;
                bytes.push_back(-1);
            }
            else {
                bytes.push_back(strtoul(current, &current, 16));
            }
        }
        return bytes;
    };

    const auto dosHeader = (PIMAGE_DOS_HEADER)pModuleBaseAddress;
    const auto ntHeaders = (PIMAGE_NT_HEADERS)((std::uint8_t*)pModuleBaseAddress + dosHeader->e_lfanew);

    const auto sizeOfImage = ntHeaders->OptionalHeader.SizeOfImage;
    auto       patternBytes = patternToByte(sSignature);
    const auto scanBytes = reinterpret_cast<std::uint8_t*>(pModuleBaseAddress);

    const auto s = patternBytes.size();
    const auto d = patternBytes.data();

    size_t nFoundResults = 0;

    for (auto i = 0ul; i < sizeOfImage - s; ++i)
    {
        bool found = true;

        for (auto j = 0ul; j < s; ++j)
        {
            if (scanBytes[i + j] != d[j] && d[j] != -1)
            {
                found = false;
                break;
            }
        }

        if (found)
        {
            if (nSelectResultIndex != 0)
            {
                if (nFoundResults < nSelectResultIndex)
                {
                    nFoundResults++;                                   // Skip Result To Get nSelectResultIndex.
                    found = false;                                     // Make sure we can loop again.
                }
                else
                {
                    return reinterpret_cast<uintptr_t>(&scanBytes[i]);  // Result By Index.
                }
            }
            else
            {
                return reinterpret_cast<uintptr_t>(&scanBytes[i]);      // Default/First Result.
            }
        }
    }

    return NULL;
}




uintptr_t MemoryHelper::Pattern::PatternScan(const char* sSignature, size_t nSelectResultIndex)
{
    static bool bIsSetted = false;

    static MODULEINFO info = { 0 };

    if (!bIsSetted)
    {
        GetModuleInformation(safe_call(GetCurrentProcess)(), GetModuleHandle(0), &info, sizeof(info));
        bIsSetted = true;
    }

    return PatternScan((uintptr_t)info.lpBaseOfDll, sSignature, nSelectResultIndex);
}

void MemoryHelper::Log(const char* sFilePath, char const* const sFormat, ...)
{
    char sLog[1024];

    va_list _ArgList;
    __crt_va_start(_ArgList, sFormat);
#pragma warning(push)
#pragma warning(disable: 4996) // Deprecation
    _vsprintf_l(sLog, sFormat, NULL, _ArgList);
#pragma warning(pop)
    __crt_va_end(_ArgList);

    std::ofstream ofs;
    ofs.open(sFilePath, std::ofstream::out | std::ofstream::app);
    ofs << sLog << std::endl;
    ofs.close();
}
```

`README.md`:

```md
# ritz-amazing-fortnite-internal
fortnite internal cheat made by ritz

This is the first time I actually sat down and made a cheat from scratch. This source is nothing special but it is special to me (: 
There are many improvments to be made but there are no crashing issues 
I removed the p100 hook and added a shit one 
decided to post to github instead of sell so yea have fun with it 
there is a injector in the x64 release folder btw 

```

`custom_runtimes.cpp`:

```cpp
#pragma once
#include <iostream>
#include <Windows.h>
#include <intrin.h>
#include <sysinfoapi.h>
#include "custom_runtimes.h"

#define NT_SUCCESS(Status)              ((NTSTATUS)(Status) >= 0)
#define NT_ERROR(Status)                ((((ULONG)(Status)) >> 30) == 3)

typedef enum _PROCESSINFOCLASS
{
	ProcessBasicInformation, // q: PROCESS_BASIC_INFORMATION, PROCESS_EXTENDED_BASIC_INFORMATION
	ProcessQuotaLimits, // qs: QUOTA_LIMITS, QUOTA_LIMITS_EX
	ProcessIoCounters, // q: IO_COUNTERS
	ProcessVmCounters, // q: VM_COUNTERS, VM_COUNTERS_EX, VM_COUNTERS_EX2
	ProcessTimes, // q: KERNEL_USER_TIMES
	ProcessBasePriority, // s: KPRIORITY
	ProcessRaisePriority, // s: ULONG
	ProcessDebugPort, // q: HANDLE
	ProcessExceptionPort, // s: HANDLE
	ProcessAccessToken, // s: PROCESS_ACCESS_TOKEN
	ProcessLdtInformation, // qs: PROCESS_LDT_INFORMATION // 10
	ProcessLdtSize, // s: PROCESS_LDT_SIZE
	ProcessDefaultHardErrorMode, // qs: ULONG
	ProcessIoPortHandlers, // (kernel-mode only)
	ProcessPooledUsageAndLimits, // q: POOLED_USAGE_AND_LIMITS
	ProcessWorkingSetWatch, // q: PROCESS_WS_WATCH_INFORMATION[]; s: void
	ProcessUserModeIOPL,
	ProcessEnableAlignmentFaultFixup, // s: BOOLEAN
	ProcessPriorityClass, // qs: PROCESS_PRIORITY_CLASS
	ProcessWx86Information,
	ProcessHandleCount, // q: ULONG, PROCESS_HANDLE_INFORMATION // 20
	ProcessAffinityMask, // s: KAFFINITY
	ProcessPriorityBoost, // qs: ULONG
	ProcessDeviceMap, // qs: PROCESS_DEVICEMAP_INFORMATION, PROCESS_DEVICEMAP_INFORMATION_EX
	ProcessSessionInformation, // q: PROCESS_SESSION_INFORMATION
	ProcessForegroundInformation, // s: PROCESS_FOREGROUND_BACKGROUND
	ProcessWow64Information, // q: ULONG_PTR
	ProcessImageFileName, // q: UNICODE_STRING
	ProcessLUIDDeviceMapsEnabled, // q: ULONG
	ProcessBreakOnTermination, // qs: ULONG
	ProcessDebugObjectHandle, // q: HANDLE // 30
	ProcessDebugFlags, // qs: ULONG
	ProcessHandleTracing, // q: PROCESS_HANDLE_TRACING_QUERY; s: size 0 disables, otherwise enables
	ProcessIoPriority, // qs: IO_PRIORITY_HINT
	ProcessExecuteFlags, // qs: ULONG
	ProcessResourceManagement,
	ProcessCookie, // q: ULONG
	ProcessImageInformation, // q: SECTION_IMAGE_INFORMATION
	ProcessCycleTime, // q: PROCESS_CYCLE_TIME_INFORMATION // since VISTA
	ProcessPagePriority, // q: ULONG
	ProcessInstrumentationCallback, // 40
	ProcessThreadStackAllocation, // s: PROCESS_STACK_ALLOCATION_INFORMATION, PROCESS_STACK_ALLOCATION_INFORMATION_EX
	ProcessWorkingSetWatchEx, // q: PROCESS_WS_WATCH_INFORMATION_EX[]
	ProcessImageFileNameWin32, // q: UNICODE_STRING
	ProcessImageFileMapping, // q: HANDLE (input)
	ProcessAffinityUpdateMode, // qs: PROCESS_AFFINITY_UPDATE_MODE
	ProcessMemoryAllocationMode, // qs: PROCESS_MEMORY_ALLOCATION_MODE
	ProcessGroupInformation, // q: USHORT[]
	ProcessTokenVirtualizationEnabled, // s: ULONG
	ProcessConsoleHostProcess, // q: ULONG_PTR
	ProcessWindowInformation, // q: PROCESS_WINDOW_INFORMATION // 50
	ProcessHandleInformation, // q: PROCESS_HANDLE_SNAPSHOT_INFORMATION // since WIN8
	ProcessMitigationPolicy, // s: PROCESS_MITIGATION_POLICY_INFORMATION
	ProcessDynamicFunctionTableInformation,
	ProcessHandleCheckingMode,
	ProcessKeepAliveCount, // q: PROCESS_KEEPALIVE_COUNT_INFORMATION
	ProcessRevokeFileHandles, // s: PROCESS_REVOKE_FILE_HANDLES_INFORMATION
	ProcessWorkingSetControl, // s: PROCESS_WORKING_SET_CONTROL
	ProcessHandleTable, // since WINBLUE
	ProcessCheckStackExtentsMode,
	ProcessCommandLineInformation, // q: UNICODE_STRING // 60
	ProcessProtectionInformation, // q: PS_PROTECTION
	ProcessMemoryExhaustion, // PROCESS_MEMORY_EXHAUSTION_INFO // since THRESHOLD
	ProcessFaultInformation, // PROCESS_FAULT_INFORMATION
	ProcessTelemetryIdInformation, // PROCESS_TELEMETRY_ID_INFORMATION
	ProcessCommitReleaseInformation, // PROCESS_COMMIT_RELEASE_INFORMATION
	ProcessDefaultCpuSetsInformation,
	ProcessAllowedCpuSetsInformation,
	ProcessSubsystemProcess,
	ProcessJobMemoryInformation, // PROCESS_JOB_MEMORY_INFO
	ProcessInPrivate, // since THRESHOLD2 // 70
	ProcessRaiseUMExceptionOnInvalidHandleClose,
	ProcessIumChallengeResponse,
	ProcessChildProcessInformation, // PROCESS_CHILD_PROCESS_INFORMATION
	ProcessHighGraphicsPriorityInformation,
	ProcessSubsystemInformation, // q: SUBSYSTEM_INFORMATION_TYPE // since REDSTONE2
	ProcessEnergyValues, // PROCESS_ENERGY_VALUES, PROCESS_EXTENDED_ENERGY_VALUES
	ProcessActivityThrottleState, // PROCESS_ACTIVITY_THROTTLE_STATE
	ProcessActivityThrottlePolicy, // PROCESS_ACTIVITY_THROTTLE_POLICY
	ProcessWin32kSyscallFilterInformation,
	ProcessDisableSystemAllowedCpuSets,
	ProcessWakeInformation, // PROCESS_WAKE_INFORMATION
	ProcessEnergyTrackingState, // PROCESS_ENERGY_TRACKING_STATE
	MaxProcessInfoClass
} PROCESSINFOCLASS;

typedef LONG KPRIORITY, * PKPRIORITY;

typedef struct _RTL_BALANCED_NODE
{
	union
	{
		struct _RTL_BALANCED_NODE* Children[2];
		struct
		{
			struct _RTL_BALANCED_NODE* Left;
			struct _RTL_BALANCED_NODE* Right;
		} s;
	};
	union
	{
		UCHAR Red : 1;
		UCHAR Balance : 2;
		ULONG_PTR ParentValue;
	} u;
} RTL_BALANCED_NODE, * PRTL_BALANCED_NODE;

typedef enum _LDR_DLL_LOAD_REASON
{
	LoadReasonStaticDependency,
	LoadReasonStaticForwarderDependency,
	LoadReasonDynamicForwarderDependency,
	LoadReasonDelayloadDependency,
	LoadReasonDynamicLoad,
	LoadReasonAsImageLoad,
	LoadReasonAsDataLoad,
	LoadReasonUnknown = -1
} LDR_DLL_LOAD_REASON, * PLDR_DLL_LOAD_REASON;

typedef struct _LDR_SERVICE_TAG_RECORD
{
	struct _LDR_SERVICE_TAG_RECORD* Next;
	ULONG ServiceTag;
} LDR_SERVICE_TAG_RECORD, * PLDR_SERVICE_TAG_RECORD;

typedef struct _LDRP_CSLIST
{
	PSINGLE_LIST_ENTRY Tail;
} LDRP_CSLIST, * PLDRP_CSLIST;

typedef enum _LDR_DDAG_STATE
{
	LdrModulesMerged = -5,
	LdrModulesInitError = -4,
	LdrModulesSnapError = -3,
	LdrModulesUnloaded = -2,
	LdrModulesUnloading = -1,
	LdrModulesPlaceHolder = 0,
	LdrModulesMapping = 1,
	LdrModulesMapped = 2,
	LdrModulesWaitingForDependencies = 3,
	LdrModulesSnapping = 4,
	LdrModulesSnapped = 5,
	LdrModulesCondensed = 6,
	LdrModulesReadyToInit = 7,
	LdrModulesInitializing = 8,
	LdrModulesReadyToRun = 9
} LDR_DDAG_STATE;

typedef struct _LDR_DDAG_NODE
{
	LIST_ENTRY Modules;
	PLDR_SERVICE_TAG_RECORD ServiceTagList;
	ULONG LoadCount;
	ULONG LoadWhileUnloadingCount;
	ULONG LowestLink;
	union
	{
		LDRP_CSLIST Dependencies;
		SINGLE_LIST_ENTRY RemovalLink;
	};
	LDRP_CSLIST IncomingDependencies;
	LDR_DDAG_STATE State;
	SINGLE_LIST_ENTRY CondenseLink;
	ULONG PreorderNumber;
} LDR_DDAG_NODE, * PLDR_DDAG_NODE;

typedef struct _UNICODE_STRING
{
	USHORT Length;
	USHORT MaximumLength;
	PWSTR Buffer;
} UNICODE_STRING, * PUNICODE_STRING;
typedef const UNICODE_STRING* PCUNICODE_STRING;

typedef struct _PEB_LDR_DATA
{
	ULONG Length;
	BOOLEAN Initialized;
	HANDLE SsHandle;
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
	PVOID EntryInProgress;
	BOOLEAN ShutdownInProgress;
	HANDLE ShutdownThreadId;
} PEB_LDR_DATA, * PPEB_LDR_DATA;

typedef struct _LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	union
	{
		LIST_ENTRY InInitializationOrderLinks;
		LIST_ENTRY InProgressLinks;
	};
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	union
	{
		UCHAR FlagGroup[4];
		ULONG Flags;
		struct
		{
			ULONG PackagedBinary : 1;
			ULONG MarkedForRemoval : 1;
			ULONG ImageDll : 1;
			ULONG LoadNotificationsSent : 1;
			ULONG TelemetryEntryProcessed : 1;
			ULONG ProcessStaticImport : 1;
			ULONG InLegacyLists : 1;
			ULONG InIndexes : 1;
			ULONG ShimDll : 1;
			ULONG InExceptionTable : 1;
			ULONG ReservedFlags1 : 2;
			ULONG LoadInProgress : 1;
			ULONG LoadConfigProcessed : 1;
			ULONG EntryProcessed : 1;
			ULONG ProtectDelayLoad : 1;
			ULONG ReservedFlags3 : 2;
			ULONG DontCallForThreads : 1;
			ULONG ProcessAttachCalled : 1;
			ULONG ProcessAttachFailed : 1;
			ULONG CorDeferredValidate : 1;
			ULONG CorImage : 1;
			ULONG DontRelocate : 1;
			ULONG CorILOnly : 1;
			ULONG ReservedFlags5 : 3;
			ULONG Redirected : 1;
			ULONG ReservedFlags6 : 2;
			ULONG CompatDatabaseProcessed : 1;
		} s;
	} u;
	USHORT ObsoleteLoadCount;
	USHORT TlsIndex;
	LIST_ENTRY HashLinks;
	ULONG TimeDateStamp;
	struct _ACTIVATION_CONTEXT* EntryPointActivationContext;
	PVOID Lock;
	PLDR_DDAG_NODE DdagNode;
	LIST_ENTRY NodeModuleLink;
	struct _LDRP_LOAD_CONTEXT* LoadContext;
	PVOID ParentDllBase;
	PVOID SwitchBackContext;
	RTL_BALANCED_NODE BaseAddressIndexNode;
	RTL_BALANCED_NODE MappingInfoIndexNode;
	ULONG_PTR OriginalBase;
	LARGE_INTEGER LoadTime;
	ULONG BaseNameHashValue;
	LDR_DLL_LOAD_REASON LoadReason;
	ULONG ImplicitPathOptions;
	ULONG ReferenceCount;
	ULONG DependentLoadFlags;
	UCHAR SigningLevel; // Since Windows 10 RS2
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

#define GDI_HANDLE_BUFFER_SIZE32    34
#define GDI_HANDLE_BUFFER_SIZE64    60

#ifndef _WIN64
#define GDI_HANDLE_BUFFER_SIZE GDI_HANDLE_BUFFER_SIZE32
#else
#define GDI_HANDLE_BUFFER_SIZE GDI_HANDLE_BUFFER_SIZE64
#endif

typedef ULONG GDI_HANDLE_BUFFER32[GDI_HANDLE_BUFFER_SIZE32];
typedef ULONG GDI_HANDLE_BUFFER64[GDI_HANDLE_BUFFER_SIZE64];
typedef ULONG GDI_HANDLE_BUFFER[GDI_HANDLE_BUFFER_SIZE];

typedef struct _CURDIR
{
	UNICODE_STRING DosPath;
	HANDLE Handle;
} CURDIR, * PCURDIR;

typedef struct _RTL_DRIVE_LETTER_CURDIR
{
	USHORT Flags;
	USHORT Length;
	ULONG TimeStamp;
	UNICODE_STRING DosPath;
} RTL_DRIVE_LETTER_CURDIR, * PRTL_DRIVE_LETTER_CURDIR;

#define RTL_MAX_DRIVE_LETTERS 32
typedef struct _RTL_USER_PROCESS_PARAMETERS
{
	ULONG MaximumLength;
	ULONG Length;

	ULONG Flags;
	ULONG DebugFlags;

	HANDLE ConsoleHandle;
	ULONG ConsoleFlags;
	HANDLE StandardInput;
	HANDLE StandardOutput;
	HANDLE StandardError;

	CURDIR CurrentDirectory;
	UNICODE_STRING DllPath;
	UNICODE_STRING ImagePathName;
	UNICODE_STRING CommandLine;
	PWCHAR Environment;

	ULONG StartingX;
	ULONG StartingY;
	ULONG CountX;
	ULONG CountY;
	ULONG CountCharsX;
	ULONG CountCharsY;
	ULONG FillAttribute;

	ULONG WindowFlags;
	ULONG ShowWindowFlags;
	UNICODE_STRING WindowTitle;
	UNICODE_STRING DesktopInfo;
	UNICODE_STRING ShellInfo;
	UNICODE_STRING RuntimeData;
	RTL_DRIVE_LETTER_CURDIR CurrentDirectories[RTL_MAX_DRIVE_LETTERS];

	ULONG_PTR EnvironmentSize;
	ULONG_PTR EnvironmentVersion;
	PVOID PackageDependencyData;
	ULONG ProcessGroupId;
	ULONG LoaderThreads;
} RTL_USER_PROCESS_PARAMETERS, * PRTL_USER_PROCESS_PARAMETERS;

typedef struct _PEB
{
	BOOLEAN InheritedAddressSpace;
	BOOLEAN ReadImageFileExecOptions;
	BOOLEAN BeingDebugged;
	union
	{
		BOOLEAN BitField;
		struct
		{
			BOOLEAN ImageUsesLargePages : 1;
			BOOLEAN IsProtectedProcess : 1;
			BOOLEAN IsImageDynamicallyRelocated : 1;
			BOOLEAN SkipPatchingUser32Forwarders : 1;
			BOOLEAN IsPackagedProcess : 1;
			BOOLEAN IsAppContainer : 1;
			BOOLEAN IsProtectedProcessLight : 1;
			BOOLEAN IsLongPathAwareProcess : 1;
		} s1;
	} u1;

	HANDLE Mutant;

	PVOID ImageBaseAddress;
	PPEB_LDR_DATA Ldr;
	PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
	PVOID SubSystemData;
	PVOID ProcessHeap;
	PRTL_CRITICAL_SECTION FastPebLock;
	PVOID AtlThunkSListPtr;
	PVOID IFEOKey;
	union
	{
		ULONG CrossProcessFlags;
		struct
		{
			ULONG ProcessInJob : 1;
			ULONG ProcessInitializing : 1;
			ULONG ProcessUsingVEH : 1;
			ULONG ProcessUsingVCH : 1;
			ULONG ProcessUsingFTH : 1;
			ULONG ProcessPreviouslyThrottled : 1;
			ULONG ProcessCurrentlyThrottled : 1;
			ULONG ReservedBits0 : 25;
		} s2;
	} u2;
	union
	{
		PVOID KernelCallbackTable;
		PVOID UserSharedInfoPtr;
	} u3;
	ULONG SystemReserved[1];
	ULONG AtlThunkSListPtr32;
	PVOID ApiSetMap;
	ULONG TlsExpansionCounter;
	PVOID TlsBitmap;
	ULONG TlsBitmapBits[2];

	PVOID ReadOnlySharedMemoryBase;
	PVOID SharedData; // HotpatchInformation
	PVOID* ReadOnlyStaticServerData;

	PVOID AnsiCodePageData; // PCPTABLEINFO
	PVOID OemCodePageData; // PCPTABLEINFO
	PVOID UnicodeCaseTableData; // PNLSTABLEINFO

	ULONG NumberOfProcessors;
	ULONG NtGlobalFlag;

	LARGE_INTEGER CriticalSectionTimeout;
	SIZE_T HeapSegmentReserve;
	SIZE_T HeapSegmentCommit;
	SIZE_T HeapDeCommitTotalFreeThreshold;
	SIZE_T HeapDeCommitFreeBlockThreshold;

	ULONG NumberOfHeaps;
	ULONG MaximumNumberOfHeaps;
	PVOID* ProcessHeaps; // PHEAP

	PVOID GdiSharedHandleTable;
	PVOID ProcessStarterHelper;
	ULONG GdiDCAttributeList;

	PRTL_CRITICAL_SECTION LoaderLock;

	ULONG OSMajorVersion;
	ULONG OSMinorVersion;
	USHORT OSBuildNumber;
	USHORT OSCSDVersion;
	ULONG OSPlatformId;
	ULONG ImageSubsystem;
	ULONG ImageSubsystemMajorVersion;
	ULONG ImageSubsystemMinorVersion;
	ULONG_PTR ActiveProcessAffinityMask;
	GDI_HANDLE_BUFFER GdiHandleBuffer;
	PVOID PostProcessInitRoutine;

	PVOID TlsExpansionBitmap;
	ULONG TlsExpansionBitmapBits[32];

	ULONG SessionId;

	ULARGE_INTEGER AppCompatFlags;
	ULARGE_INTEGER AppCompatFlagsUser;
	PVOID pShimData;
	PVOID AppCompatInfo; // APPCOMPAT_EXE_DATA

	UNICODE_STRING CSDVersion;

	PVOID ActivationContextData; // ACTIVATION_CONTEXT_DATA
	PVOID ProcessAssemblyStorageMap; // ASSEMBLY_STORAGE_MAP
	PVOID SystemDefaultActivationContextData; // ACTIVATION_CONTEXT_DATA
	PVOID SystemAssemblyStorageMap; // ASSEMBLY_STORAGE_MAP

	SIZE_T MinimumStackCommit;

	PVOID* FlsCallback;
	LIST_ENTRY FlsListHead;
	PVOID FlsBitmap;
	ULONG FlsBitmapBits[FLS_MAXIMUM_AVAILABLE / (sizeof(ULONG) * 8)];
	ULONG FlsHighIndex;

	PVOID WerRegistrationData;
	PVOID WerShipAssertPtr;
	PVOID pUnused; // pContextData
	PVOID pImageHeaderHash;
	union
	{
		ULONG TracingFlags;
		struct
		{
			ULONG HeapTracingEnabled : 1;
			ULONG CritSecTracingEnabled : 1;
			ULONG LibLoaderTracingEnabled : 1;
			ULONG SpareTracingBits : 29;
		} s3;
	} u4;
	ULONGLONG CsrServerReadOnlySharedMemoryBase;
	PVOID TppWorkerpListLock;
	LIST_ENTRY TppWorkerpList;
	PVOID WaitOnAddressHashTable[128];
	PVOID TelemetryCoverageHeader; // REDSTONE3
	ULONG CloudFileFlags;
} PEB, * PPEB;

typedef struct _PROCESS_BASIC_INFORMATION
{
	NTSTATUS ExitStatus;
	PPEB PebBaseAddress;
	ULONG_PTR AffinityMask;
	KPRIORITY BasePriority;
	HANDLE UniqueProcessId;
	HANDLE InheritedFromUniqueProcessId;
} PROCESS_BASIC_INFORMATION, * PPROCESS_BASIC_INFORMATION;

typedef NTSTATUS(__stdcall* tNtQueryInformationProcess)
(
	HANDLE ProcessHandle,
	PROCESSINFOCLASS ProcessInformationClass,
	PVOID ProcessInformation,
	ULONG ProcessInformationLength,
	PULONG ReturnLength
	);


PEB* GetPEB()
{
	PEB* peb = (PEB*)__readgsqword(0x60);

	return peb;
}

uintptr_t crt::GetBaseAddress(const wchar_t* modName)
{
	LDR_DATA_TABLE_ENTRY* modEntry = nullptr;

	PEB* peb = GetPEB();

	LIST_ENTRY head = peb->Ldr->InMemoryOrderModuleList;

	LIST_ENTRY curr = head;

	for (auto curr = head; curr.Flink != &peb->Ldr->InMemoryOrderModuleList; curr = *curr.Flink)
	{
		LDR_DATA_TABLE_ENTRY* mod = (LDR_DATA_TABLE_ENTRY*)CONTAINING_RECORD(curr.Flink, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);

		if (mod->BaseDllName.Buffer)
		{
			if (_wcsicmp((const wchar_t*)modName, (const wchar_t*)mod->BaseDllName.Buffer) == 0)
			{
				modEntry = mod;
				break;
			}
		}
	}

	return (uintptr_t)modEntry->DllBase;
}

float crt::sqrtf(float _X) { return _mm_cvtss_f32(_mm_sqrt_ss(_mm_set_ss(_X))); }
float crt::expf(float _X) { return _mm_cvtss_f32(_mm_exp_ps(_mm_set_ss(_X))); }

float crt::sinf(float _X) { return _mm_cvtss_f32(_mm_sin_ps(_mm_set_ss(_X))); }
float crt::cosf(float _X) { return _mm_cvtss_f32(_mm_cos_ps(_mm_set_ss(_X))); }

float crt::tanf(float _X) { return _mm_cvtss_f32(_mm_tan_ps(_mm_set_ss(_X))); }
float crt::asinf(float _X) { return _mm_cvtss_f32(_mm_asin_ps(_mm_set_ss(_X))); }
float crt::atan2f(float _X, float _Y) { return _mm_cvtss_f32(_mm_atan2_ps(_mm_set_ss(_X), _mm_set_ss(_Y))); }
float crt::acosf(float _X) { return _mm_cvtss_f32(_mm_acos_ps(_mm_set_ss(_X))); }

int crt::toupper(int c)
{
	if (c >= 'a' && c <= 'z') return c - 'a' + 'A';
	return c;
}
int crt::tolower(int c)
{
	if (c >= 'A' && c <= 'Z') return c - 'A' + 'a';
	return c;
}

void* crt::memcpy(void* dest, const void* src, unsigned __int64 count)
{
	char* char_dest = (char*)dest;
	char* char_src = (char*)src;
	if ((char_dest <= char_src) || (char_dest >= (char_src + count)))
	{
		while (count > 0)
		{
			*char_dest = *char_src;
			char_dest++;
			char_src++;
			count--;
		}
	}
	else
	{
		char_dest = (char*)dest + count - 1;
		char_src = (char*)src + count - 1;
		while (count > 0)
		{
			*char_dest = *char_src;
			char_dest--;
			char_src--;
			count--;
		}
	}
	return dest;
}
void* crt::memset(void* src, int val, unsigned __int64 count)
{
	__stosb((unsigned char*)((unsigned long long)(volatile char*)src), val, count);
	return src;
}
void* crt::memccpy(void* to, const void* from, int c, unsigned __int64 count)
{
	char t;
	unsigned __int64 i;
	char* dst = (char*)to;
	const char* src = (const char*)from;
	for (i = 0; i < count; i++)
	{
		dst[i] = t = src[i];
		if (t == 0) break;
		if (t == c) return &dst[i + 1];
	}
	return 0;
}
void* crt::memchr(const void* s, int c, unsigned __int64 n)
{
	if (n)
	{
		const char* p = (const char*)s;
		do
		{
			if (*p++ == c) return (void*)(p - 1);
		} while (--n != 0);
	}
	return 0;
}
int crt::memcmp(const void* s1, const void* s2, unsigned __int64 n)
{
	if (n != 0)
	{
		const unsigned char* p1 = (unsigned char*)s1, * p2 = (unsigned char*)s2;
		do
		{
			if (*p1++ != *p2++) return (*--p1 - *--p2);
		} while (--n != 0);
	}
	return 0;
}
int crt::memicmp(const void* s1, const void* s2, unsigned __int64 n)
{
	if (n != 0)
	{
		const unsigned char* p1 = (unsigned char*)s1, * p2 = (unsigned char*)s2;
		do
		{
			if (crt::toupper(*p1) != crt::toupper(*p2)) return (*p1 - *p2);
			p1++;
			p2++;
		} while (--n != 0);
	}
	return 0;
}
void* crt::memmove(void* dest, const void* src, unsigned __int64 count)
{
	char* char_dest = (char*)dest;
	char* char_src = (char*)src;
	if ((char_dest <= char_src) || (char_dest >= (char_src + count)))
	{
		while (count > 0)
		{
			*char_dest = *char_src;
			char_dest++;
			char_src++;
			count--;
		}
	}
	else
	{
		char_dest = (char*)dest + count - 1;
		char_src = (char*)src + count - 1;
		while (count > 0)
		{
			*char_dest = *char_src;
			char_dest--;
			char_src--;
			count--;
		}
	}
	return dest;
}

char* crt::_cslwr(char* x)
{
	char* y = x;
	while (*y)
	{
		*y = crt::tolower(*y);
		y++;
	}
	return x;
}
char* crt::_csupr(char* x)
{
	char* y = x;
	while (*y)
	{
		*y = crt::tolower(*y);
		y++;
	}
	return x;
}

int crt::strlen(const char* string)
{
	int cnt = 0;
	if (string)
	{
		for (; *string != 0; ++string) ++cnt;
	}
	return cnt;
}

int crt::wcslen(const wchar_t* string)
{
	int cnt = 0;
	if (string)
	{
		for (; *string != 0; ++string) ++cnt;
	}
	return cnt;
}

const char* crt::strcpy(char* buffer, const char* string)
{
	char* ret = buffer;
	while (*string) *buffer++ = *string++;
	*buffer = 0;
	return ret;
}

int crt::strcmp(const char* cs, const char* ct)
{
	if (cs && ct)
	{
		while (*cs == *ct)
		{
			if (*cs == 0 && *ct == 0) return 0;
			if (*cs == 0 || *ct == 0) break;
			cs++;
			ct++;
		}
		return *cs - *ct;
	}
	return -1;
}
int crt::stricmp(const char* cs, const char* ct)
{
	if (cs && ct)
	{
		while (crt::tolower(*cs) == crt::tolower(*ct))
		{
			if (*cs == 0 && *ct == 0) return 0;
			if (*cs == 0 || *ct == 0) break;
			cs++;
			ct++;
		}
		return crt::tolower(*cs) - crt::tolower(*ct);
	}
	return -1;
}
```

`custom_runtimes.h`:

```h
#pragma once

namespace crt {
	uintptr_t GetBaseAddress(const wchar_t* modName);

	//uint64_t rnd();
	float sqrtf(float _X);
	float expf(float _X);
	float sinf(float _X);
	float cosf(float _X);
	float tanf(float _X);
	float asinf(float _X);
	float acosf(float _X);
	float atan2f(float _X, float _Y);
	int toupper(int c);
	int tolower(int c);
	void* memcpy(void* dest, const void* src, unsigned __int64 count);
	void* memset(void* src, int val, unsigned __int64 count);
	void* memccpy(void* to, const void* from, int c, unsigned __int64 count);
	void* memchr(const void* s, int c, unsigned __int64 n);
	int  memcmp(const void* s1, const void* s2, unsigned __int64 n);
	int  memicmp(const void* s1, const void* s2, unsigned __int64 n);


	void* memmove(void* dest, const void* src, unsigned __int64 count);


	char* _cslwr(char* x);
	char* _csupr(char* x);



	int strlen(const char* string);
	int wcslen(const wchar_t* string);
	const char* strcpy(char* buffer, const char* string);
	int strcmp(const char* cs, const char* ct);
	int stricmp(const char* cs, const char* ct);
}
```

`dllmain.cpp`:

```cpp
#include <iostream>
#include "includes.h"
#include "menu.h"
#include "FNTool.h"
#include "spoof_call.h"


float rainbowspeed = 0.0005f;
void DrawMenu() {
	ZeroGUI::SetupCanvas(static_canvas);
	ZeroGUI::Input::Handle();




	static Vector2 pos = Vector2(700, 700);
	if (ZeroGUI::Window("ritz's amazing internal [remove = gay caterpillar]", &pos, Vector2{ 500.0f, 400.0f }, ShowMenu))
	{
		//Simple Tabs
		static int tab = 0;
		if (ZeroGUI::ButtonTab("Aimbot", Vector2{ 110, 25 }, tab == 0)) tab = 0;
		if (ZeroGUI::ButtonTab("Esp", Vector2{ 110, 25 }, tab == 1)) tab = 1;
		if (ZeroGUI::ButtonTab("Exploits", Vector2{ 110, 25 }, tab == 2)) tab = 2;
		if (ZeroGUI::ButtonTab("Misc", Vector2{ 110, 25 }, tab == 3)) tab = 3;
		ZeroGUI::NextColumn(130.0f);
		//
		if (tab == 0) {
			//Some Elements

			ZeroGUI::Checkbox("Memory Aim", &Settings::MemoryAim);
			ZeroGUI::Checkbox("Silent Aim", &Settings::SilentAim);
			ZeroGUI::SliderFloat("Fov Size", &FovSize, 30.0f, 700.f);

			//2 lazy to do :shrug:
			//ZeroGUI::PushNextElementY(50.0f);
			//ZeroGUI::Combobox("Target Bone", Vector2{ 100, 25 }, &Settings::BoneTarget, "Head", "Neck", "Chest", "Pelvis", NULL); 
		}
		if (tab == 1) {
			ZeroGUI::Checkbox("Box Esp", &Settings::BoxESP);
			ZeroGUI::Checkbox("Skeleton Esp", &Settings::SkeletonESP);
			ZeroGUI::Checkbox("Line Esp", &Settings::LinesESP);
			ZeroGUI::Checkbox("Name Esp", &Settings::PlayerNameESP);
			ZeroGUI::Checkbox("Distance Esp", &Settings::PlayerNameESP);
			ZeroGUI::Checkbox("Level Esp", &Settings::PlayerNameESP);
			ZeroGUI::Checkbox("Kills Esp", &Settings::PlayerNameESP);
			ZeroGUI::Checkbox("Platform Esp", &Settings::PlayerNameESP);
			ZeroGUI::Checkbox("Weapon Esp", &Settings::PlayerNameESP);
			ZeroGUI::Checkbox("Ammo Esp", &Settings::PlayerNameESP);

		}
		if (tab == 2) {
			ZeroGUI::Checkbox("Chams", &Settings::Chams);
			ZeroGUI::Checkbox("SniperTp", &Settings::SniperTp);
			ZeroGUI::Checkbox("InstantReload", &Settings::InstantReload);
			ZeroGUI::Checkbox("RapidFire [4snipers]", &Settings::RapidFire); 
			ZeroGUI::Checkbox("Fov Changer", &Settings::FovChanger);
			ZeroGUI::SliderFloat("Fov Value", &Settings::FovChanger_Value, 0.0f, 180.0f);
		}
		if (tab == 3) {
			ZeroGUI::SliderFloat("Rainbow Speed", &rainbowspeed, 0.0001f, 0.005f);
		}
		
		

		
	}
	ZeroGUI::Draw_Cursor(true);
	ZeroGUI::Render();
}




static BOOL IsNotInScreen(int SizeX, int SizeY, Vector2 Pos) {
	if (((Pos.x <= 0 or Pos.x > SizeX) and (Pos.y <= 0 or Pos.y > SizeY)) or ((Pos.x <= 0 or Pos.x > SizeX) or (Pos.y <= 0 or Pos.y > SizeY))) {
		return TRUE;
	}
	else {
		return FALSE;
	}
}

AFortPawn* TargetPawno;
AFortPawn* LocalPawno;
APlayerCameraManager* PlayerCameraManagero;
Vector3 o_CamRot;
Vector3 o_CamLoc;
uintptr_t GlobalPlayerState;
bool initspeed = true;
bool Debuggytest = true;
ue::FString playeraname;
void __forceinline AnsiToWide(char* inAnsi, wchar_t* outWide)
{
	int i = 0;
	for (; inAnsi[i] != '\0'; i++)
		outWide[i] = (wchar_t)(inAnsi)[i];
	outWide[i] = L'\0';
}
#include <cmath>
float color_red;
float color_blue;
float color_green;
float color_speed = -10.0;
static ue::FLinearColor FromHSB(float hue, float saturation, float brightness)
{
	float h = hue == 1.0f ? 0 : hue * 6.0f;
	float f = h - (int)h;
	float p = brightness * (1.0f - saturation);
	float q = brightness * (1.0f - saturation * f);
	float t = brightness * (1.0f - (saturation * (1.0f - f)));

	if (h < 1)
	{
		return ue::FLinearColor(
			(float)(brightness),
			(float)(t),
			(float)(p),
			(float)(0.7f)
		);
	}
	else if (h < 2)
	{
		return ue::FLinearColor(
			(float)(q),
			(float)(brightness),
			(float)(p),
			(float)(0.7f)
		);
	}
	else if (h < 3)
	{
		return ue::FLinearColor(
			(float)(p),
			(float)(brightness),
			(float)(t),
			(float)(0.7f)
		);
	}
	else if (h < 4)
	{
		return ue::FLinearColor(
			(float)(p),
			(float)(q),
			(float)(brightness),
			(float)(0.7f)
		);
	}
	else if (h < 5)
	{
		return ue::FLinearColor(
			(float)(t),
			(float)(p),
			(float)(brightness),
			(float)(0.7f)
		);
	}
	else
	{
		return ue::FLinearColor(
			(float)(brightness),
			(float)(p),
			(float)(q),
			(float)(0.7f)
		);
	}
}
ue::FLinearColor GetItemColor(EFortItemTier tier)
{
	if (tier == EFortItemTier::I)
		return ue::FLinearColor(123 / 255.0f, 123 / 255.0f, 123 / 255.0f, 0.95f);
	else if (tier == EFortItemTier::II)
		return ue::FLinearColor(58 / 255.0f, 121 / 255.0f, 19 / 255.0f, 0.95f);
	else if (tier == EFortItemTier::III)
		return ue::FLinearColor(18 / 255.0f, 88 / 255.0f, 162 / 255.0f, 0.95f);
	else if (tier == EFortItemTier::IV)
		return ue::FLinearColor(189 / 255.0f, 63 / 255.0f, 250 / 255.0f, 0.95f);
	else if (tier == EFortItemTier::V)
		return ue::FLinearColor(255 / 255.0f, 118 / 255.0f, 5 / 255.0f, 0.95f);
	else if (tier == EFortItemTier::VI)
		return ue::FLinearColor(220 / 255.0f, 160 / 255.0f, 30 / 255.0f, 0.95f);
	else if (tier == EFortItemTier::VII)
		return ue::FLinearColor(0 / 255.0f, 225 / 255.0f, 252 / 255.0f, 0.95f);

	return ue::FLinearColor(123, 123, 123, 0.95f);
}

EFortItemTier GetItemEFortTier(float tier)
{
	int tierI = (int)tier;
	switch (tierI)
	{
	case 1:
		return EFortItemTier::I;
	case 2:
		return EFortItemTier::II;
	case 3:
		return EFortItemTier::III;
	case 4:
		return EFortItemTier::IV;
	case 5:
		return EFortItemTier::V;
	case 6:
		return EFortItemTier::VI;
	case 7:
		return EFortItemTier::VII;
	default:
		return EFortItemTier::I;
	}
}

std::string GetItemTierName(EFortItemTier tier)
{
	switch (tier)
	{
	case EFortItemTier::I:
		return xorstr("Common");
	case EFortItemTier::II:
		return xorstr("Uncommon");
	case EFortItemTier::III:
		return xorstr("Rare");
	case EFortItemTier::IV:
		return xorstr("Epic");
	case EFortItemTier::V:
		return xorstr("Legendary");
	case EFortItemTier::VI:
		return xorstr("Mythic");
	case EFortItemTier::VII:
		return xorstr("Exotic");
	default:
		return xorstr("Common");
	}
}


void DrawFilledRect(UCanvas* pCanvas, Vector2 initial_pos, float width, float height, ue::FLinearColor color)
{
	for (float i = 0.0f; i < height; i += 1.0f)
		pCanvas->K2_DrawLine(Vector2(initial_pos.x, initial_pos.y + i), Vector2(initial_pos.x + width, initial_pos.y + i), 1.0f, color);

}
#define mpe 3.14159265358979323846264338327950288419716939937510582f

void DrawCircle(UCanvas* canvas, int x, int y, int radius, int numsides, ue::FLinearColor color)
{
	float Step = mpe * 2.0 / numsides;
	int Count = 0;
	Vector2 V[128];
	for (float a = 0; a < mpe * 2.0; a += Step)
	{
		float X1 = radius * sdkUssage->STATIC_Cos(a) + x;
		float Y1 = radius * sdkUssage->STATIC_Sin(a) + y;
		float X2 = radius * sdkUssage->STATIC_Cos(a + Step) + x;
		float Y2 = radius * sdkUssage->STATIC_Sin(a + Step) + y;
		V[Count].x = X1;
		V[Count].y = Y1;
		V[Count + 1].x = X2;
		V[Count + 1].y = Y2;
		canvas->K2_DrawLine(Vector2({ V[Count].x, V[Count].y }), Vector2({ X2, Y2 }), 1.5f, color);
	}
}

void DrawTriangle(UCanvas* pCanvas, const Vector2& point1, const Vector2& point2, const Vector2& point3, const ue::FLinearColor& color, bool isFilled)
{
	pCanvas->K2_DrawLine(point1, point2, 1.0f, color);
	pCanvas->K2_DrawLine(point1, point3, 1.0f, color);
	pCanvas->K2_DrawLine(point2, point3, 1.0f, color);
	// Fill it
	if (isFilled) {
		float addX = 0.5f;
		float addY = 1;
		for (float i = point1.y; i < point3.y; i++) {
			// draw line
			pCanvas->K2_DrawLine(Vector2(point1.x + addX, point1.y + addY), Vector2(point2.x - addX, point2.y + addY), 1.0f, color);
			addY++;
			addX += 0.5f;
		}
	}
}
void actorloop() {
	AFortPawn* targetpawn = nullptr;
	float closestTocenter = FLT_MAX;
	width = static_canvas->SizeX();
	height = static_canvas->SizeY();
	auto gworld = ((GWorld*)(*(uintptr_t*)(ue::cached::signatures::GWorld)));
	auto OwningGameInstance = gworld->OwningGameInstance();
	PlayerController = OwningGameInstance->LocalPlayers()->LocalPlayer()->PlayerController();
	auto PlayerCameraManager = PlayerController->PlayerCameraManager();
	auto LocalPawn = (AFortPawn*)PlayerController->LocalPawn();
	auto levels = gworld->Levels();
	
	for (int a = 0; a < levels.Num(); a++) {
		auto level = levels[a];
		if (!level) continue;
		auto actors = levels[a]->ActorArray();
		for (int i = 0; i < actors.Num(); i++) {
			auto actor = actors[i];
			if (!actor || actor == LocalPawn)
				continue;
			if (targetpawn)
			{
				if (actor->IsA(ue::cached::objects::FortProjectileBase) && Settings::SniperTp)
				{
					actor->K2_SetActorLocation(targetpawn->GetBone(98), false, true); //68
					
				}
				
			}
			//int dist = PlayerCameraManager->GetCameraLocation().Distance(actor->RootComponent()->RelativeLocation()) / 100;
			//if (dist <= 15) {
			//	auto name = actor->ObjectName();
			//	static_canvas->K2_DrawText(PlayerCameraManager->ProjectWorldLocationToScreen(width, height, actor->RootComponent()->RelativeLocation()), ue::FLinearColor(0, 1, 0, 1), name, false, true);
			//	//printf("%s", name);
			//	//std::cout << name << "\n";
			//}
			
			if (actor->IsA(ue::cached::objects::actor::FortPlayerPawnAthena)) {

				//GlobalPlayerState = *(uintptr_t*)((uintptr_t)actor + 0x290);
				
					
				
				Vector3 head = actor->GetBone(98);
				//std::cout << head.x << " getbone\n";
				Vector2 head_w2s = PlayerCameraManager->ProjectWorldLocationToScreen(width, height, head);
				
				
				//if (Settings::Chams) { actor->ApplyPawnHighlight(ue::FLinearColor(10, 10, 0, 0.5), ue::FLinearColor(10, 10, 0, 0.5)); }
				if (Settings::Chams) {
					static float rainbow;
					rainbow += rainbowspeed;
					if (rainbow > 1.f)
						rainbow = 0.f; actor->ApplyPawnHighlight(FromHSB(rainbow, 1.f, 1.f), FromHSB(rainbow, 1.f, 1.f)); }
			
				if (Settings::FovChanger) { PlayerController->Fov(Settings::FovChanger_Value); }
				if (Settings::RapidFire) { actor->CurrentWeapon()->RapidFire(); }
				
				//int GetAccountLevel();
				

				if (actor != LocalPawn) {

					auto dx = head_w2s.x - (width / 2);
					auto dy = head_w2s.y - (height / 2);
					auto dist = crt::sqrtf(dx * dx + dy * dy);

					if (dist < FovSize && dist < closestTocenter) {
						closestTocenter = dist;
						targetpawn = actor;
					}
					else if (!dist < FovSize && !dist < closestTocenter) {
						TargetPawno = 0;
					}

				}
				TargetPawno = targetpawn;
				LocalPawno = LocalPawn;
				PlayerCameraManagero = PlayerCameraManager;
				
				if (Settings::MemoryAim and targetpawn and PlayerController->IsInputKeyDown(ue::FKey(RBKey))) {
					
					Vector3 headtarget = targetpawn->GetBone(98);
					//std::cout << head.x << " getbone\n";
					Vector2 headtarget_w2s = PlayerCameraManager->ProjectWorldLocationToScreen(width, height, headtarget);

					auto camloc = PlayerCameraManager->GetCameraLocation();
					auto NewRotation = galgan(camloc, headtarget);
					PlayerController->ClientSetRotation(NewRotation, false); //never got around to making ud memory none of my attemps to hook get roation shit worked :shrug:

				

				}
				//PlayerController->TurboBuildInterval();
				
				Vector2 head2_w2s = PlayerCameraManager->ProjectWorldLocationToScreen(width, height, { head.x, head.y, head.z + 20 });
				//std::cout << head2_w2s.x << " w2s head\n";
				Vector3 bottom = actor->GetBone(0);

				Vector2 bottom_w2s = PlayerCameraManager->ProjectWorldLocationToScreen(width, height, { bottom.x, bottom.y, bottom.z });
				//std::cout << bottom_w2s.x << " w2s bottom\n";
				ue::FLinearColor col = ue::FLinearColor(0.f, 1.f, 0.f, 1.f);

				if (IsNotInScreen(width, height, head_w2s)) continue;
				float BoxHeight = (float)(bottom_w2s.y - head2_w2s.y);
				float BoxWidth = BoxHeight * 0.60f;

				float BottomLeftX = (float)head2_w2s.x - BoxWidth / 2;
				float BottomLeftY = (float)bottom_w2s.y;

				float BottomRightX = (float)head2_w2s.x + BoxWidth / 2;
				float BottomRightY = (float)bottom_w2s.y;

				float TopRightX = (float)head2_w2s.x + BoxWidth / 2;
				float TopRightY = (float)head2_w2s.y;

				float TopLeftX = (float)head2_w2s.x - BoxWidth / 2;
				float TopLeftY = (float)head2_w2s.y;

				if (Settings::BoxESP) {
					//Bottom
					static_canvas->K2_DrawLine(Vector2(BottomLeftX, BottomLeftY), Vector2(BottomRightX, BottomRightY), 2.f, col);

					//Right
					static_canvas->K2_DrawLine(Vector2(BottomRightX, BottomRightY), Vector2(TopRightX, TopRightY), 2.f, col);

					//Top
					static_canvas->K2_DrawLine(Vector2(TopRightX, TopRightY), Vector2(TopLeftX, TopLeftY), 2.f, col);

					//Left
					static_canvas->K2_DrawLine(Vector2(TopLeftX, TopLeftY), Vector2(BottomLeftX, BottomLeftY), 2.f, col);
				}
				auto redcol = ue::FLinearColor(1, 0, 0, 1);
				auto bluecol = ue::FLinearColor(0, 0, 1, 1);
				float TextOffset_Y = head2_w2s.y;
				float TextOffset_X = TopRightX + 5;
				Vector2 calculation;
				if (!IsNotInScreen(1920, 1080, head2_w2s)) {
					if (Settings::PlayerNameESP) {
						auto name = actor->PlayerState()->GetPlayerName();
						if (name.c_str()) {

							TextOffset_Y += static_canvas->K2_TextSize(actor->PlayerState()->GetPlayerName()).y + 5;
							calculation = Vector2(TextOffset_X, TextOffset_Y);
							static_canvas->K2_DrawText(calculation, redcol, name.c_str(), false, true);
						}
					}
					if (Settings::DistanceESP) {
						int dist = PlayerCameraManager->GetCameraLocation().Distance(actor->RootComponent()->RelativeLocation()) / 100;
						static char distanceesp[128];
						static wchar_t wdistanceesp[128];
						sprintf(distanceesp, xorstr("Distance: %d[m]"), dist);
						AnsiToWide(distanceesp, wdistanceesp);
						TextOffset_Y += static_canvas->K2_TextSize(ue::FString(wdistanceesp)).y + 10;
						calculation = Vector2(TextOffset_X, TextOffset_Y);
						static_canvas->K2_DrawText(calculation, bluecol, wdistanceesp, false, true);
					}
					if (Settings::LevelESP) {
						auto level = actor->PlayerState()->SeasonLevelUIDisplay();
						static char levelesp[128];
						static wchar_t wlevelesp[128];
						sprintf(levelesp, xorstr("Level: %d"), level);
						AnsiToWide(levelesp, wlevelesp);
						TextOffset_Y += static_canvas->K2_TextSize(ue::FString(wlevelesp)).y + 10;
						calculation = Vector2(TextOffset_X, TextOffset_Y);
						static_canvas->K2_DrawText(calculation, redcol, wlevelesp, false, true);
					}
					if (Settings::KillsESP) {
						auto kills = actor->PlayerState()->GetKillScore();
						static char killesp[128];
						static wchar_t wdkillesp[128];
						sprintf(killesp, xorstr("Kills: %d"), kills);
						AnsiToWide(killesp, wdkillesp);
						TextOffset_Y += static_canvas->K2_TextSize(ue::FString(wdkillesp)).y + 10;
						calculation = Vector2(TextOffset_X, TextOffset_Y);
						static_canvas->K2_DrawText(calculation, bluecol, wdkillesp, false, true);
					}
					if (Settings::PlatformESP) {
						auto platform = actor->PlayerState()->GetPlatform();
						if (!platform.IsValid()) continue;
						auto platform_name = platform.c_str();
						TextOffset_Y += static_canvas->K2_TextSize(ue::FString(platform_name)).y + 10;
						calculation = Vector2(TextOffset_X, TextOffset_Y);

						if (math::custom_wcsstr(platform_name, xorstr(L"PSN"))) {
							static_canvas->K2_DrawText(calculation, redcol, xorstr(L"PlayStation"), false, true);
						}
						else if (math::custom_wcsstr(platform_name, xorstr(L"XBL"))) {
							static_canvas->K2_DrawText(calculation, redcol, xorstr(L"Xbox"), false, true);
						}
						else if (math::custom_wcsstr(platform_name, xorstr(L"XSX"))) {
							static_canvas->K2_DrawText(calculation, redcol, xorstr(L"Xbox Series S"), false, true);
						}
						else if (math::custom_wcsstr(platform_name, xorstr(L"WIN"))) {
							static_canvas->K2_DrawText(calculation, redcol, xorstr(L"Windows"), false, true);
						}
						else if (math::custom_wcsstr(platform_name, xorstr(L"MAC"))) {
							static_canvas->K2_DrawText(calculation, redcol, xorstr(L"MacOS"), false, true);
						}
						else if (math::custom_wcsstr(platform_name, xorstr(L"LNX"))) {
							static_canvas->K2_DrawText(calculation, redcol, xorstr(L"Linux"), false, true);
						}
						else if (math::custom_wcsstr(platform_name, xorstr(L"IOS"))) {
							static_canvas->K2_DrawText(calculation, redcol, xorstr(L"Ios"), false, true);
						}
						else if (math::custom_wcsstr(platform_name, xorstr(L"AND"))) {
							static_canvas->K2_DrawText(calculation, redcol, xorstr(L"Android"), false, true);
						}
						else if (math::custom_wcsstr(platform_name, xorstr(L"SWT"))) {
							static_canvas->K2_DrawText(calculation, redcol, xorstr(L"NintendoSwitch"), false, true);
						}
						else {
							static_canvas->K2_DrawText(calculation, redcol, platform_name, false, true);
						}
					}
					if (actor->CurrentWeapon()) {
					}
					if (Settings::EnemyWeaponESP) {
						if (actor->CurrentWeapon()->WeaponData()) {
							auto weaponname = actor->CurrentWeapon()->WeaponData()->DisplayName().Get();
							if (weaponname) {
								TextOffset_Y += static_canvas->K2_TextSize(weaponname).y + 10;
								calculation = Vector2(TextOffset_X, TextOffset_Y);
								static_canvas->K2_DrawText(calculation, bluecol, weaponname, false, true);
							}
						}
					}
					if (Settings::AmmoESP) {
						auto ammo = actor->CurrentWeapon()->GetMagazineAmmoCount();
						auto clipammo = actor->CurrentWeapon()->GetBulletsPerClip();
						if (ammo && clipammo) {
							static char ammoesp[128];
							static wchar_t wammoesp[128];
							sprintf(ammoesp, xorstr("Ammo: %d/%d"), ammo, clipammo);
							AnsiToWide(ammoesp, wammoesp);
							TextOffset_Y += static_canvas->K2_TextSize(ue::FString(wammoesp)).y + 10;
							calculation = Vector2(TextOffset_X, TextOffset_Y);
							static_canvas->K2_DrawText(calculation, redcol, wammoesp, false, true);
						}
					}
					//not ud
					/*auto tier = actor->CurrentWeapon()->WeaponData()->Tier();
								static char tieresp[128];
								static wchar_t wtieresp[128];
								sprintf(tieresp, xorstr("%s"), tier);
								AnsiToWide(tieresp, wtieresp);
								TextOffset_Y += static_canvas->K2_TextSize(wtieresp).y + 10;
								calculation = Vector2(TextOffset_X, TextOffset_Y);
								static_canvas->K2_DrawText(calculation, GetItemColor(tier), wtieresp, false, true);*/
				}
				
				
				

				Vector2 ChestAtLeft = PlayerController->WorldToScreen(actor->GetBone(37));
				Vector2 ChestAtRight = PlayerController->WorldToScreen(actor->GetBone(8));
				Vector2 Chest = { ChestAtLeft.x + (ChestAtRight.x - ChestAtLeft.x) / 2, ChestAtLeft.y };
				ue::FLinearColor Color = ue::FLinearColor(1.f, 1.f, 0.f, 1.f);
				if (Settings::SkeletonESP) {
					Vector2 Neck = PlayerController->WorldToScreen(actor->GetBone(66));

					Vector2 LeftShoulder = PlayerController->WorldToScreen(actor->GetBone(93));
					Vector2 RightShoulder = PlayerController->WorldToScreen(actor->GetBone(9));
					Vector2 LeftElbow = PlayerController->WorldToScreen(actor->GetBone(94));
					Vector2 RightElbow = PlayerController->WorldToScreen(actor->GetBone(10));
					Vector2 LeftHand = PlayerController->WorldToScreen(actor->GetBone(100));
					Vector2 RightHand = PlayerController->WorldToScreen(actor->GetBone(99));
					Vector2 LeftLeg = PlayerController->WorldToScreen(actor->GetBone(76));
					Vector2 RightLeg = PlayerController->WorldToScreen(actor->GetBone(69));
					Vector2 LeftThigh = PlayerController->WorldToScreen(actor->GetBone(82));
					Vector2 RightThigh = PlayerController->WorldToScreen(actor->GetBone(75));
					Vector2 LeftFoot = PlayerController->WorldToScreen(actor->GetBone(78));
					Vector2 RightFoot = PlayerController->WorldToScreen(actor->GetBone(71));
					Vector2 LeftFeet = PlayerController->WorldToScreen(actor->GetBone(85));
					Vector2 RightFeet = PlayerController->WorldToScreen(actor->GetBone(84));
					Vector2 LeftFeetFinger = PlayerController->WorldToScreen(actor->GetBone(81));
					Vector2 RightFeetFinger = PlayerController->WorldToScreen(actor->GetBone(74));
					Vector2 Bottom = PlayerController->WorldToScreen(actor->GetBone(0));
					Vector2 Pelvis = PlayerController->WorldToScreen(actor->GetBone(2));


					static_canvas->K2_DrawLine(head_w2s, Neck, 2, Color);
					static_canvas->K2_DrawLine(Neck, Chest, 2, Color);
					static_canvas->K2_DrawLine(Chest, Pelvis, 2, Color);
					static_canvas->K2_DrawLine(Chest, LeftShoulder, 2, Color);
					static_canvas->K2_DrawLine(Chest, RightShoulder, 2, Color);
					static_canvas->K2_DrawLine(LeftShoulder, LeftElbow, 2, Color);
					static_canvas->K2_DrawLine(RightShoulder, RightElbow, 2, Color);
					static_canvas->K2_DrawLine(LeftElbow, LeftHand, 2, Color);
					static_canvas->K2_DrawLine(RightElbow, RightHand, 2, Color);
					static_canvas->K2_DrawLine(Pelvis, LeftLeg, 2, Color);
					static_canvas->K2_DrawLine(Pelvis, RightLeg, 2, Color);
					static_canvas->K2_DrawLine(LeftLeg, LeftThigh, 2, Color);
					static_canvas->K2_DrawLine(RightLeg, RightThigh, 2, Color);
					static_canvas->K2_DrawLine(LeftThigh, LeftFoot, 2, Color);
					static_canvas->K2_DrawLine(RightThigh, RightFoot, 2, Color);
					static_canvas->K2_DrawLine(LeftFoot, LeftFeet, 2, Color);
					static_canvas->K2_DrawLine(RightFoot, RightFeet, 2, Color);
					static_canvas->K2_DrawLine(LeftFeet, LeftFeetFinger, 2, Color);
					static_canvas->K2_DrawLine(RightFeet, RightFeetFinger, 2, Color);

				}
				if (Settings::LinesESP) {
					static_canvas->K2_DrawLine(Vector2(width / 2, height), Chest, 2, Color);
				}





			}
		}

	}
}
Vector3 OriginalLocation;
Vector3 OriginalRotation;
bool once = true;
bool once2 = true;
Vector3 rot;
void(*o_GetViewPoint)(uintptr_t, ue::FMinimalViewInfo*, BYTE) = nullptr;
void hk_GetViewPoint(uintptr_t this_LocalPlayer, ue::FMinimalViewInfo* OutViewInfo, BYTE StereoPass)
{
	o_GetViewPoint(this_LocalPlayer, OutViewInfo, StereoPass);
	if (sdkUssage->isValidPointer(uintptr_t(LocalPawno)))
	{
		//static bool GetCameraLocation = true;
		//static Vector3 NewLocation;

		//if (GetCameraLocation) {
		//	// Set our new location to the original spot once
		//	NewLocation = OutViewInfo->Location;
		//	GetCameraLocation = false;
		//}

		if (Settings::SilentAim)
		{
			if (PlayerController->IsInputKeyDown(ue::FKey(RBKey)))
			{
				OutViewInfo->Rotation = OriginalRotation;
				OutViewInfo->Location = OriginalLocation;
				//OutViewInfo->Location = rot;
				
			}

			/*if (safe_call(GetAsyncKeyState)('W')) NewLocation.x += 5.f;
			else if (safe_call(GetAsyncKeyState)('S')) NewLocation.x -= 5.f;
			else if (safe_call(GetAsyncKeyState)('A')) NewLocation.y += 5.f;
			else if (safe_call(GetAsyncKeyState)('D')) NewLocation.y -= 5.f;
			else if (safe_call(GetAsyncKeyState)(VK_SPACE)) NewLocation.z += 5.f;
			else if (safe_call(GetAsyncKeyState)(VK_SHIFT)) NewLocation.z -= 5.f;

			OutViewInfo->Location = NewLocation;*/

			//OutViewInfo->Location = OriginalLocation;
		}
		//OutViewInfo->FOV = 1000;


	}
}
void(*o_GetPlayerViewPoint)(uintptr_t, Vector3*, Vector3*) = nullptr;
void hk_GetPlayerViewPoint(uintptr_t this_PlayerController, Vector3* Location, Vector3* Rotation) {
	
	o_GetPlayerViewPoint(this_PlayerController, Location, Rotation);
	OriginalLocation = *Location;
	OriginalRotation = *Rotation;
	//if (once) { MessageBox(0, L"ud", 0, 0); once = false; }
	if (sdkUssage->isValidPointer(uintptr_t(LocalPawno)))
	{
		

		if (Settings::SilentAim) {
			if (PlayerController->IsInputKeyDown(ue::FKey(RBKey)))
			{
				auto rootHead = TargetPawno->GetBone(68);
				Vector3 camloc = *Location;
				Vector3 VectorPos;
				VectorPos.x = rootHead.x - camloc.x;
				VectorPos.y = rootHead.y - camloc.y;
				VectorPos.z = rootHead.z - camloc.z;
				float distance = (double)(sqrtf(VectorPos.x * VectorPos.x + VectorPos.y * VectorPos.y + VectorPos.z * VectorPos.z));
				
				rot.x = -((acosf(VectorPos.z / distance) * (float)(180.0f / 3.14159265358979323846264338327950288419716939937510)) - 90.f);
				rot.y = atan2f(VectorPos.y, VectorPos.x) * (float)(180.0f / 3.14159265358979323846264338327950288419716939937510);
				rot.z = 0;
				*Rotation = rot;
				
			}
			
		}
	}
	
}
float(*CalculateReloadSpeedOriginal)(AWeapon*, float*) = nullptr;
auto CalculateReloadSpeedHook(AWeapon* Weapon, float* a2) //__m128 __fastcall sub_7FF660B36E80(__int64 a1)
{
	return FLT_MAX;
	return CalculateReloadSpeedOriginal(Weapon, a2);
}
bool oncee = false;
bool onceee = false;
bool temponce = false;
bool initudhooker = true;


static uintptr_t storedPController;
static uintptr_t storedPCurrentWeapon;
static uintptr_t storedPLocalPlayer;
bool hookplayanama = false;
bool calcc = false;
bool hookgetactorrotation = true;
bool hookdis = true;
bool hookdiss = true;
bool hookdisss = true;
bool hookdissss = true;
void VirtualTableFunctionSwap(void* VTable, void* FunctionToSwap, void** pOriginal, int Index)
{
	DWORD Old;

	void* pVTableFunction = (void*)((uint64_t)VTable + Index);
	*pOriginal = *(PVOID*)(pVTableFunction);

	VirtualProtectEx((HANDLE)-1, pVTableFunction, 8, PAGE_EXECUTE_READWRITE, &Old);
	*(PVOID*)pVTableFunction = FunctionToSwap;
	VirtualProtectEx((HANDLE)-1, pVTableFunction, 8, Old, &Old);
}
void DrawTransition(uintptr_t this_, uintptr_t Canvas) {
	if (!Canvas) {
		return DrawTransition(this_, Canvas);
	}
	static_canvas = (UCanvas*)Canvas;

	actorloop();



	auto uworld = ((GWorld*)(*(uintptr_t*)(ue::cached::signatures::GWorld)));
	auto LocalPlayer = uworld->OwningGameInstance()->LocalPlayers()->LocalPlayer();
	
	//GetViewpoint
	if (storedPLocalPlayer != (uintptr_t)LocalPlayer)
	{
		////DO YOUR HOOK
		storedPLocalPlayer = (uintptr_t)LocalPlayer;
		//std::cout << "ud\n";

		hookdisss = true;

	}
	if (storedPLocalPlayer == (uintptr_t)LocalPlayer && hookdisss) {

		if (LocalPlayer) {
			void** LocalPlayer_VTable = *(void***)(LocalPlayer);
			DWORD OldProtection;
			safe_call(VirtualProtect)(&LocalPlayer_VTable[88], 8, PAGE_EXECUTE_READWRITE, &OldProtection);
			o_GetViewPoint = decltype(o_GetViewPoint)(LocalPlayer_VTable[88]);
			LocalPlayer_VTable[88] = &hk_GetViewPoint;
			safe_call(VirtualProtect)(&LocalPlayer_VTable[88], 8, OldProtection, &OldProtection);
			
		}

		hookdisss = false;
	}

	//CalculateReloadSpeed
	if (storedPCurrentWeapon != (uintptr_t)LocalPawno->CurrentWeapon())
	{
		
		storedPCurrentWeapon = (uintptr_t)LocalPawno->CurrentWeapon();
		//std::cout << "ud\n";

		hookdiss = true;

	}
	if (Settings::InstantReload && storedPCurrentWeapon == (uintptr_t)LocalPawno->CurrentWeapon() && hookdiss) {

		if (LocalPawno->CurrentWeapon()) {
			void** CurrentWeapon_VTable = *(void***)(LocalPawno->CurrentWeapon());
			DWORD OldProtection;
			safe_call(VirtualProtect)(&CurrentWeapon_VTable[296], 8, PAGE_EXECUTE_READWRITE, &OldProtection);
			CalculateReloadSpeedOriginal = decltype(CalculateReloadSpeedOriginal)(CurrentWeapon_VTable[296]);
			CurrentWeapon_VTable[296] = &CalculateReloadSpeedHook;
			safe_call(VirtualProtect)(&CurrentWeapon_VTable[296], 8, OldProtection, &OldProtection);
			
		}

		hookdiss = false;
	}

	
	//GetPlayerViewpoint
	if (storedPController != (uintptr_t)LocalPlayer->PlayerController())
	{
		
		storedPController = (uintptr_t)LocalPlayer->PlayerController();
		//std::cout << "ud\n";
		hookdis = true;

	}

	if (Settings::SilentAim && storedPController == (uintptr_t)LocalPlayer->PlayerController() && hookdis) {
		
		
		void** PlayerController_VTable = *(void***)(LocalPlayer->PlayerController());
		DWORD OldProtection;
		safe_call(VirtualProtect)(&PlayerController_VTable[245], 8, PAGE_EXECUTE_READWRITE, &OldProtection);
		o_GetPlayerViewPoint = decltype(o_GetPlayerViewPoint)(PlayerController_VTable[245]);
		PlayerController_VTable[245] = &hk_GetPlayerViewPoint;
		safe_call(VirtualProtect)(&PlayerController_VTable[245], 8, OldProtection, &OldProtection);
		hookdis = false;
	}





	//if (safe_call(GetAsyncKeyState)(VK_INSERT) & 1)
	if (PlayerController->WasInputKeyJustPressed(ue::FKey(InsertKey)))
	{
		ShowMenu = !ShowMenu;
	}

	static_canvas->K2_DrawLine(Vector2(width / 2 + 5, height / 2), Vector2(width / 2 + 10.f, height / 2), 3, { 1.f, 0.f, 0.f, 1.f });
	static_canvas->K2_DrawLine(Vector2(width / 2 - 5, height / 2), Vector2(width / 2 - 10.f, height / 2), 3, { 1.f, 0.f, 0.f, 1.f });
	static_canvas->K2_DrawLine(Vector2(width / 2, height / 2 + 5), Vector2(width / 2, height / 2 + 10.f), 3, { 1.f, 0.f, 0.f, 1.f });
	static_canvas->K2_DrawLine(Vector2(width / 2, height / 2 - 5), Vector2(width / 2, height / 2 - 10.f), 3, { 1.f, 0.f, 0.f, 1.f });

	Pasted_CircleOutline(Vector2(width / 2, height / 2), FovSize, { 0.933333397f, 0.509803951f, 0.933333397f, 1.000000000f });
	DrawCircle(static_canvas, width / 2, height / 2, FovSize, 1450, ue::FLinearColor(0,0,1,1));
	if (ShowMenu) {
		DrawMenu();
	}


	return DrawTransitionOriginal(this_, Canvas);
}
VOID Main()
{
	
	/*AllocConsole();
	freopen("CONIN$", "r", stdin);
	freopen("CONOUT$", "w", stdout);
	freopen("CONOUT$", "w", stderr);*/


	
		ue::cached::Base = sdkUssage->GetGameBase();

		ue::cached::signatures::GWorld = sdkUssage->PatternScan(ue::cached::Base, xorstr("48 89 05 ? ? ? ? 48 8B 4B 78"), 7, true); if (!ue::cached::signatures::GWorld) safe_call(MessageBox)(0, xorstr(L"UWorld"), 0, 0);
		ue::cached::signatures::GetBoneMatrix = sdkUssage->PatternScan(ue::cached::Base, xorstr("E8 ? ? ? ? 0F 10 40 68"), 5, true); if (!ue::cached::signatures::GetBoneMatrix) safe_call(MessageBox)(0, xorstr(L"GetBoneMatrix"), 0, 0);
		ue::cached::signatures::ProjectWorldToScreen = sdkUssage->PatternScan(ue::cached::Base, xorstr("E8 ? ? ? ? 4C 8D 5C 24 ? 41 88 06 49 8B 5B 20 49 8B 73 30 49 8B 7B 38"), 5, true); if (!ue::cached::signatures::ProjectWorldToScreen) safe_call(MessageBox)(0, xorstr(L"ProjectWorldToScreen"), 0, 0);
		ue::cached::signatures::FreeFn = sdkUssage->PatternScan(ue::cached::Base, xorstr("48 85 C9 0F 84 ? ? ? ? 53 48 83 EC 20 48 89 7C 24 30 48 8B D9 48 8B 3D ? ? ? ? 48 85 FF 0F 84 ? ? ? ? 48 8B 07 4C 8B 40 30 48 8D 05 ? ? ? ? 4C 3B C0"), 0, false); if (!ue::cached::signatures::FreeFn) safe_call(MessageBox)(0, xorstr(L"FreeFn"), 0, 0);
		ue::cached::signatures::GetNameByIndex = sdkUssage->PatternScan(ue::cached::Base, xorstr("48 89 5C 24 08 48 89 74 24 18 48 89 7C 24 20 41 56 48 81 EC 30"), 0, false); if (!ue::cached::signatures::GetNameByIndex) safe_call(MessageBox)(0, xorstr(L"GetNameByIndex"), 0, 0);
		ue::classes::objects = (ue::classes::GObjects*)sdkUssage->PatternScan(ue::cached::Base, xorstr("48 8B 05 ? ? ? ? 48 8B 0C C8 48 8B 04 D1"), 7, true); if (!ue::classes::objects) safe_call(MessageBox)(0, xorstr(L"GObjects"), 0, 0);

		ue::cached::objects::camera::GetCameraLocation = (ue::classes::UObject*)find::FindObject(xorstr(L"Engine.PlayerCameraManager.GetCameraLocation")); if (!ue::cached::objects::camera::GetCameraLocation) return;
		ue::cached::objects::camera::GetCameraRotation = (ue::classes::UObject*)find::FindObject(xorstr(L"Engine.PlayerCameraManager.GetCameraRotation")); if (!ue::cached::objects::camera::GetCameraRotation) return;
		ue::cached::objects::camera::GetFOVAngle = (ue::classes::UObject*)find::FindObject(xorstr(L"Engine.PlayerCameraManager.GetFOVAngle")); if (!ue::cached::objects::camera::GetCameraRotation) return;

		ue::cached::objects::render::Font = (ue::classes::UObject*)find::FindObject(xorstr(L"/Engine/EngineFonts/Roboto.Roboto")); if (!ue::cached::objects::render::Font) return;
		ue::cached::objects::render::K2_DrawLine = (ue::classes::UObject*)find::FindObject(xorstr(L"Engine.Canvas.K2_DrawLine")); if (!ue::cached::objects::render::K2_DrawLine) return;
		ue::cached::objects::render::K2_DrawBox = (ue::classes::UObject*)find::FindObject(xorstr(L"Engine.Canvas.K2_DrawBox")); if (!ue::cached::objects::render::K2_DrawBox) return;
		ue::cached::objects::render::K2_DrawText = (ue::classes::UObject*)find::FindObject(xorstr(L"Engine.Canvas.K2_DrawText")); if (!ue::cached::objects::render::K2_DrawText) return;
		ue::cached::objects::render::K2_TextSize = (ue::classes::UObject*)find::FindObject(xorstr(L"Engine.Canvas.K2_TextSize")); if (!ue::cached::objects::render::K2_DrawBox) return;

		ue::cached::objects::actor::FortPlayerPawnAthena = (ue::classes::UObject*)find::FindObject(xorstr(L"FortniteGame.FortPlayerPawnAthena")); if (!ue::cached::objects::actor::FortPlayerPawnAthena) return;
		ue::cached::objects::actor::ClientSetRotation = (ue::classes::UObject*)find::FindObject(xorstr(L"Engine.Controller.ClientSetRotation")); if (!ue::cached::objects::actor::ClientSetRotation) return;
		ue::cached::objects::actor::GetPlayerName = (ue::classes::UObject*)find::FindObject(xorstr(L"Engine.PlayerState.GetPlayerName")); if (!ue::cached::objects::actor::GetPlayerName) return;
		ue::cached::objects::actor::ApplyPawnHighlight = (ue::classes::UObject*)find::FindObject(xorstr(L"PlayerPawn_Athena.PlayerPawn_Athena_C.ApplyPawnHighlight")); if (!ue::cached::objects::actor::ApplyPawnHighlight) return;
		ue::cached::objects::actor::Fov = (ue::classes::UObject*)find::FindObject(xorstr(L"Engine.PlayerController.FOV")); if (!ue::cached::objects::actor::Fov) return;
		ue::cached::objects::actor::SetMouseLocation = (ue::classes::UObject*)find::FindObject(xorstr(L"Engine.PlayerController.SetMouseLocation")); if (!ue::cached::objects::actor::SetMouseLocation) return;
		ue::cached::objects::FortProjectileBase = (ue::classes::UObject*)find::FindObject(xorstr(L"FortniteGame.FortProjectileBase")); if (!ue::cached::objects::FortProjectileBase) return;
		ue::cached::objects::AFortAthenaZipline = (ue::classes::UObject*)find::FindObject(xorstr(L"FortniteGame.FortAthenaZipline")); if (!ue::cached::objects::AFortAthenaZipline) return;
		ue::cached::objects::FortRangedWeaponStats = (ue::classes::UObject*)find::FindObject(xorstr(L"FortniteGame.FortRangedWeaponStats")); if (!ue::cached::objects::FortRangedWeaponStats) return;
		
		ue::cached::objects::K2_GetActorRotation = (ue::classes::UObject*)find::FindObject(xorstr(L"Engine.Actor.K2_GetActorRotation")); if (!ue::cached::objects::K2_GetActorRotation) return;
		
		ue::cached::objects::actor::isHiddingInProp = (ue::classes::UObject*)find::FindObject(xorstr(L"PlayerPawn_Athena.PlayerPawn_Athena_C.isHiddingInProp")); if (!ue::cached::objects::actor::isHiddingInProp) return;
		ue::cached::objects::actor::SetCharacterBodyVisibilityForPossession = (ue::classes::UObject*)find::FindObject(xorstr(L"FortniteGame.FortPlayerPawnAthena.SetCharacterBodyVisibilityForPossession")); if (!ue::cached::objects::actor::SetCharacterBodyVisibilityForPossession) return;
		ue::cached::FortKismetLibrary = (ue::classes::UObject*)find::FindObject(xorstr(L"FortniteGame.FortKismetLibrary")); if (!ue::cached::FortKismetLibrary) return;
		ue::cached::KismetStringLibrary = (ue::classes::UObject*)find::FindObject(xorstr(L"Engine.KismetStringLibrary")); if (!ue::cached::KismetStringLibrary) return;
		ue::cached::KismetMathLibrary = (ue::classes::UObject*)find::FindObject(xorstr(L"Engine.KismetMathLibrary")); if (!ue::cached::KismetMathLibrary) return;
		ue::cached::Conv_StringToName = (ue::classes::UObject*)find::FindObject(xorstr(L"Engine.KismetStringLibrary.Conv_StringToName")); if (!ue::cached::Conv_StringToName) return;
		ue::cached::Cos = (ue::classes::UObject*)find::FindObject(xorstr(L"Engine.KismetMathLibrary.Cos")); if (!ue::cached::Cos) return;
		ue::cached::Sin = (ue::classes::UObject*)find::FindObject(xorstr(L"Engine.KismetMathLibrary.Sin")); if (!ue::cached::Sin) return;

		ue::cached::objects::actor::K2_PayBuildingResourceCost = (ue::classes::UObject*)find::FindObject(xorstr(L"FortniteGame.FortKismetLibrary.K2_PayBuildingResourceCost")); if (!ue::cached::objects::actor::K2_PayBuildingResourceCost) return;
		ue::cached::objects::actor::GetVehicle = (ue::classes::UObject*)find::FindObject(xorstr(L"FortniteGame.FortPlayerPawn.GetVehicle")); if (!ue::cached::objects::actor::GetVehicle) return;
		ue::cached::objects::K2_TeleportTo = (ue::classes::UObject*)find::FindObject(xorstr(L"Engine.Actor.K2_TeleportTo")); if (!ue::cached::objects::K2_TeleportTo) return;
		ue::cached::objects::K2_SetActorLocation = (ue::classes::UObject*)find::FindObject(xorstr(L"Engine.Actor.K2_SetActorLocation")); if (!ue::cached::objects::K2_SetActorLocation) return;

		InsertKey = ue::FKey{ ue::FName{ sdkUssage->Conv_StringToName(xorstr(L"Insert")) }, 0 };
		LBKey = ue::FKey{ ue::FName{ sdkUssage->Conv_StringToName(xorstr(L"LeftMouseButton")) }, 0 };
		RBKey = ue::FKey{ ue::FName{ sdkUssage->Conv_StringToName(xorstr(L"RightMouseButton")) }, 0 };
		F7Key = ue::FKey{ ue::FName{ sdkUssage->Conv_StringToName(xorstr(L"F7")) }, 0 };
		

		
		FNTool* sdk = new FNTool();
		sdk->Initialize((uintptr_t)ue::classes::objects, ue::cached::signatures::GetNameByIndex, ue::cached::signatures::FreeFn);

		ue::cached::offsets::OwningGameInstance = sdk->FindOffset("World", "OwningGameInstance");
		ue::cached::offsets::Levels = sdk->FindOffset("World", "Levels");
		ue::cached::offsets::AcknowledgedPawn = sdk->FindOffset("PlayerController", "AcknowledgedPawn");
		ue::cached::offsets::PlayerCameraManager = sdk->FindOffset("PlayerController", "PlayerCameraManager");
		ue::cached::offsets::PlayerState = sdk->FindOffset("Pawn", "PlayerState");
		ue::cached::offsets::bADSWhileNotOnGround = sdk->FindOffset("FortPlayerPawnAthena", "bADSWhileNotOnGround");
		ue::cached::offsets::CurrentWeapon = sdk->FindOffset("FortPawn", "CurrentWeapon");
		ue::cached::offsets::TeamIndex = sdk->FindOffset("FortPlayerStateAthena", "TeamIndex");
		ue::cached::offsets::WeaponData = sdk->FindOffset("FortWeapon", "WeaponData");
		ue::cached::offsets::DisplayName = sdk->FindOffset("FortItemDefinition", "DisplayName");
		ue::cached::offsets::Mesh = sdk->FindOffset("Character", "Mesh");
		ue::cached::offsets::RootComponent = sdk->FindOffset("Actor", "RootComponent");
		ue::cached::offsets::RelativeLocation = sdk->FindOffset("SceneComponent", "RelativeLocation");
		ue::cached::offsets::LastFireTime = sdk->FindOffset("FortWeapon", "LastFireTime");
		ue::cached::offsets::AmmoCount = sdk->FindOffset("FortWeapon", "AmmoCount");
		ue::cached::offsets::LastFireTimeVerified = sdk->FindOffset("FortWeapon", "LastFireTimeVerified");
		ue::cached::offsets::Tier = sdk->FindOffset("FortItemDefinition", "Tier");

		auto UViewportClient = ((GWorld*)(*(uintptr_t*)(ue::cached::signatures::GWorld)))->OwningGameInstance()->LocalPlayers()->LocalPlayer()->ViewportClient();
	
		void** DrawTransition_VTable = *(void***)(UViewportClient);
		DWORD OldProtection;
		safe_call(VirtualProtect)(&DrawTransition_VTable[110], 8, PAGE_EXECUTE_READWRITE, &OldProtection);
		DrawTransitionOriginal = decltype(DrawTransitionOriginal)(DrawTransition_VTable[110]);
		DrawTransition_VTable[110] = &DrawTransition;
		safe_call(VirtualProtect)(&DrawTransition_VTable[110], 8, OldProtection, &OldProtection);
		
	
}

BOOL APIENTRY DllMain(HMODULE module, DWORD reason, LPVOID reserved) {
	if (reason != DLL_PROCESS_ATTACH) return FALSE;

	Main();

	return TRUE;
}

```

`includes.h`:

```h
#pragma once



//#include <MinHook.h>
//#pragma comment(lib, "minhook.lib")

#include <d3d11.h>
#pragma comment(lib, "d3d11.lib")

#include "sdkdefines.h"
#include "sdk.h"
#include "safecall.h"
```

`menu.h`:

```h
#include "xor.h"
using DrawTransitionOrg = void(*)(uintptr_t _this, uintptr_t canvas);
DrawTransitionOrg DrawTransitionOriginal = 0;
bool fakeunload = false;
UCanvas* static_canvas;
int width;
int height;
#pragma warning(disable : 4996)
//static wchar_t* s2wc(const char* c)
//{
//	const size_t cSize = strlen(c) + 1;
//	wchar_t* wc = new wchar_t[cSize];
//	mbstowcs(wc, c, cSize);
//
//	return wc;
//}
//#define ZeroGUI_MIN(A, B)            (((A) < (B)) ? (A) : (B))
//#define ZeroGUI_MAX(A, B)            (((A) >= (B)) ? (A) : (B))
APlayerController* PlayerController;
ue::FKey InsertKey;
ue::FKey F7Key;
ue::FKey RBKey;
ue::FKey LBKey;
//
//namespace ZeroGUI
//{
//
//	namespace Input
//	{
//		static bool mouseDown[5];
//		static bool mouseDownAlready[256];
//
//		static bool keysDown[256];
//		static bool keysDownAlready[256];
//
//		static bool IsAnyMouseDown()
//		{
//			if (mouseDown[0]) return true;
//			if (mouseDown[1]) return true;
//			if (mouseDown[2]) return true;
//			if (mouseDown[3]) return true;
//			if (mouseDown[4]) return true;
//
//			return false;
//		}
//
//		static bool IsMouseClicked(int button, int element_id, bool repeat)
//		{
//			if (mouseDown[button])
//			{
//				if (!mouseDownAlready[element_id])
//				{
//					mouseDownAlready[element_id] = true;
//					return true;
//				}
//				if (repeat)
//					return true;
//			}
//			else
//			{
//				mouseDownAlready[element_id] = false;
//			}
//			return false;
//		}
//		static bool IsKeyPressed(int key, bool repeat)
//		{
//			if (keysDown[key])
//			{
//				if (!keysDownAlready[key])
//				{
//					keysDownAlready[key] = true;
//					return true;
//				}
//				if (repeat)
//					return true;
//			}
//			else
//			{
//				keysDownAlready[key] = false;
//			}
//			return false;
//		}
//
//		static void Handle()
//		{
//			if (safe_call(safe_call(GetAsyncKeyState))(0x01))
//				mouseDown[0] = true;
//			else
//				mouseDown[0] = false;
//		}
//	}
//
//	namespace Colors
//	{
//		//Text
//		static ue::FLinearColor Text{ 1.0f, 1.0f, 1.0f, 1.0f };
//		static ue::FLinearColor Text_Shadow{ 0.0f, 0.0f, 0.0f, 0.0f };
//		static ue::FLinearColor Text_Outline{ 0.0f, 0.0f, 0.0f, 0.30f };
//
//		//Window
//		static ue::FLinearColor Window_Background{ 0.009f, 0.009f, 0.009f, 1.0f };
//		static ue::FLinearColor Window_Header{ 0.10f, 0.15f, 0.84f, 1.0f };
//
//		//Buttons
//		static ue::FLinearColor Button_Idle{ 5 / 255.f, 5 / 255.f, 5 / 255.f, 1.0f };
//		static ue::FLinearColor Button_Hovered{ 7 / 255.f, 7 / 255.f, 7 / 255.f, 1.0f };
//		static ue::FLinearColor Button_Active{ 8 / 255.f, 8 / 255.f, 8 / 255.f, 1.0f };
//
//		//Combobox
//		static ue::FLinearColor Combobox_Idle{ 5 / 255.f, 5 / 255.f, 5 / 255.f, 1.0f };
//		static ue::FLinearColor Combobox_Hovered{ 7 / 255.f, 7 / 255.f, 7 / 255.f, 1.0f };
//		static ue::FLinearColor Combobox_Elements{ 5 / 255.f, 5 / 255.f, 5 / 255.f, 1.0f };
//
//		//Sliders
//		static ue::FLinearColor Slider_Idle{ 0.17f, 0.16f, 0.23f, 1.0f };
//		static ue::FLinearColor Slider_Hovered{ 0.17f, 0.16f, 0.23f, 1.0f };
//		static ue::FLinearColor Slider_Progress{ 0.22f, 0.30f, 0.72f, 1.0f };
//		static ue::FLinearColor Slider_Button{ 0.10f, 0.15f, 0.84f, 1.0f };
//
//		static ue::FLinearColor ColorPicker_Background{ 0.006f, 0.006f, 0.006f, 1.0f };
//	}
//
//	namespace PostRenderer
//	{
//		struct DrawList
//		{
//			int type = -1; //1 = FilledRect, 2 = TextLeft, 3 = TextCenter, 4 = Draw_Line
//			Vector2 pos;
//			Vector2 size;
//			ue::FLinearColor color;
//			char* name;
//			bool outline;
//
//			Vector2 from;
//			Vector2 to;
//			int thickness;
//		};
//		static DrawList drawlist[128];
//
//		static void drawFilledRect(Vector2 pos, float w, float h, ue::FLinearColor color)
//		{
//			for (int i = 0; i < 128; i++)
//			{
//				if (drawlist[i].type == -1)
//				{
//					drawlist[i].type = 1;
//					drawlist[i].pos = pos;
//					drawlist[i].size = Vector2{ w, h };
//					drawlist[i].color = color;
//					return;
//				}
//			}
//		}
//		static void TextLeft(char* name, Vector2 pos, ue::FLinearColor color, bool outline)
//		{
//			for (int i = 0; i < 128; i++)
//			{
//				if (drawlist[i].type == -1)
//				{
//					drawlist[i].type = 2;
//					drawlist[i].name = name;
//					drawlist[i].pos = pos;
//					drawlist[i].outline = outline;
//					drawlist[i].color = color;
//					return;
//				}
//			}
//		}
//		static void TextCenter(char* name, Vector2 pos, ue::FLinearColor color, bool outline)
//		{
//			for (int i = 0; i < 128; i++)
//			{
//				if (drawlist[i].type == -1)
//				{
//					drawlist[i].type = 3;
//					drawlist[i].name = name;
//					drawlist[i].pos = pos;
//					drawlist[i].outline = outline;
//					drawlist[i].color = color;
//					return;
//				}
//			}
//		}
//		static void Draw_Line(Vector2 from, Vector2 to, int thickness, ue::FLinearColor color)
//		{
//			for (int i = 0; i < 128; i++)
//			{
//				if (drawlist[i].type == -1)
//				{
//					drawlist[i].type = 4;
//					drawlist[i].from = from;
//					drawlist[i].to = to;
//					drawlist[i].thickness = thickness;
//					drawlist[i].color = color;
//					return;
//				}
//			}
//		}
//	}
//
//
//	static bool hover_element = false;
//	static Vector2 menu_pos = Vector2{ 0, 0 };
//	static float offset_x = 0.0f;
//	static float offset_y = 0.0f;
//
//	static Vector2 first_element_pos = Vector2{ 0, 0 };
//
//	static Vector2 last_element_pos = Vector2{ 0, 0 };
//	static Vector2 last_element_size = Vector2{ 0, 0 };
//
//	static int current_element = -1;
//	static Vector2 current_element_pos = Vector2{ 0, 0 };
//	static Vector2 current_element_size = Vector2{ 0, 0 };
//	static int elements_count = 0;
//
//	static bool sameLine = false;
//
//	static bool pushY = false;
//	static float pushYvalue = 0.0f;
//
//
//	static Vector2 CursorPos()
//	{
//		float cursorPosX;
//		float cursorPosY;
//		PlayerController->GetMousePosition(&cursorPosX, &cursorPosY);
//		
//		return Vector2{ cursorPosX, cursorPosY };
//	}
//	static bool MouseInZone(Vector2 pos, Vector2 size)
//	{
//		Vector2 cursor_pos = CursorPos();
//
//		if (cursor_pos.x > pos.x && cursor_pos.y > pos.y)
//			if (cursor_pos.x < pos.x + size.y && cursor_pos.y < pos.y + size.y)
//				return true;
//
//		return false;
//	}
//	
//	static void Draw_Cursor(bool toogle)
//	{
//		if (toogle)
//		{
//			Vector2 cursorPos = CursorPos();
//			//static_canvas->K2_DrawLine(Vector2{ cursorPos.x, cursorPos.x }, Vector2{ cursorPos.x + 35, cursorPos.y + 10 }, 1, ue::FLinearColor{ 0.30f, 0.30f, 0.80f, 1.0f });
//
//
//			int x = 35;
//			int y = 10;
//			while (y != 30) //20 steps
//			{
//				x -= 1; if (x < 15) x = 15;
//				y += 1; if (y > 30) y = 30;
//
//				static_canvas->K2_DrawLine(Vector2{ cursorPos.x, cursorPos.y }, Vector2{ cursorPos.x + x, cursorPos.y + y }, 1, ue::FLinearColor{ 0.30f, 0.30f, 0.80f, 1.0f });
//			}
//
//			static_canvas->K2_DrawLine(Vector2{ cursorPos.x, cursorPos.y }, Vector2{ cursorPos.x + 15, cursorPos.y + 30 }, 1, ue::FLinearColor{ 0.30f, 0.30f, 0.80f, 1.0f });
//			static_canvas->K2_DrawLine(Vector2{ cursorPos.x + 35, cursorPos.y + 10 }, Vector2{ cursorPos.x + 15, cursorPos.y + 30 }, 1, ue::FLinearColor{ 0.30f, 0.30f, 0.80f, 1.0f });
//		}
//	}
//
//	static void SameLine()
//	{
//		sameLine = true;
//	}
//	static void PushNextElementY(float y, bool from_last_element = true)
//	{
//		pushY = true;
//		if (from_last_element)
//			pushYvalue = last_element_pos.y + last_element_size.y + y;
//		else
//			pushYvalue = menu_pos.y + y;
//	}
//	static void NextColumn(float x)
//	{
//		offset_x = x;
//		PushNextElementY(first_element_pos.y, false);
//	}
//	static void PushElementX(float value)
//	{
//		offset_x = value;
//	}
//	static void PushElementY(float value)
//	{
//		pushY = true;
//		pushYvalue = menu_pos.y + value - 10;
//	}
//	static void ClearFirstPos()
//	{
//		first_element_pos = Vector2{ 0, 0 };
//	}
//
//	static void TextLeft(char* name, Vector2 pos, ue::FLinearColor color, bool outline, bool big = false)
//	{
//		if(big)
//			static_canvas->K2_DrawText(pos, color, ue::FString(s2wc(name)), false, true);
//		else
//			static_canvas->K2_DrawText(pos, color, ue::FString(s2wc(name)), false, true);
//			
//	}
//	static void TextCenter(char* name, Vector2 pos, ue::FLinearColor color, bool outline, bool big = false)
//	{
//		if (big)
//			static_canvas->K2_DrawText(pos, color, ue::FString(s2wc(name)), true, true);
//		else
//			static_canvas->K2_DrawText(pos , color, ue::FString(s2wc(name)), true, true);
//	}
//
//	static void GetColor(ue::FLinearColor* color, float* r, float* g, float* b, float* a)
//	{
//		*r = color->R;
//		*g = color->G;
//		*b = color->B;
//		*a = color->A;
//	}
//	static UINT32 GetColorUINT(int r, int g, int b, int a)
//	{
//		UINT32 result = (BYTE(a) << 24) + (BYTE(r) << 16) + (BYTE(g) << 8) + BYTE(b);
//		return result;
//	}
//
//	static void Draw_Line(Vector2 from, Vector2 to, int thickness, ue::FLinearColor color)
//	{
//		static_canvas->K2_DrawLine(Vector2{ from.x, from.y }, Vector2{ to.x, to.y }, thickness, color);
//	}
//	static void drawFilledRect(Vector2 initial_pos, float w, float h, ue::FLinearColor color)
//	{
//		for (float i = 0.0f; i < h; i += 1.0f)
//			static_canvas->K2_DrawLine(Vector2{ initial_pos.x, initial_pos.y + i }, Vector2{ initial_pos.x + w, initial_pos.y + i }, 1.0f, color);
//	}
//	static void DrawFilledCircle(Vector2 pos, float r, ue::FLinearColor color)
//	{
//		float smooth = 0.07f;
//
//		double PI = 3.14159265359;
//		int size = (int)(2.0f * PI / smooth) + 1;
//
//		float angle = 0.0f;
//		int i = 0;
//
//		for (; angle < 2 * PI; angle += smooth, i++)
//		{
//			Draw_Line(Vector2{ pos.x, pos.y }, Vector2{ pos.x + cosf(angle) * r, pos.y + sinf(angle) * r }, 1.0f, color);
//		}
//	}
//	static void DrawCircle(Vector2 pos, int radius, int numSides, ue::FLinearColor Color)
//	{
//		float PI = 3.1415927f;
//
//		float Step = PI * 2.0 / numSides;
//		int Count = 0;
//		Vector2 V[128];
//		for (float a = 0; a < PI * 2.0; a += Step) {
//			float X1 = radius * cos(a) + pos.x;
//			float Y1 = radius * sin(a) + pos.y;
//			float X2 = radius * cos(a + Step) + pos.x;
//			float Y2 = radius * sin(a + Step) + pos.y;
//			V[Count].x = X1;
//			V[Count].x = Y1;
//			V[Count + 1].x = X2;
//			V[Count + 1].x = Y2;
//			//Draw_Line(Vector2{ pos.x, pos.y }, Vector2{ X2, Y2 }, 1.0f, Color); // Points from Centre to ends of circle
//			Draw_Line(Vector2{ V[Count].x, V[Count].x }, Vector2{ X2, Y2 }, 1.5f, Color);// Circle Around
//		}
//	}
//
//	static Vector2 dragPos;
//	static bool Window(char* name, Vector2* pos, Vector2 size, bool isOpen, bool WindowInvisible)
//	{
//		elements_count = 0;
//
//		if (!isOpen)
//			return false;
//
//		bool isHovered = MouseInZone(Vector2{ pos->x, pos->y }, size);
//
//		//Drop last element
//		if (current_element != -1 && !safe_call(safe_call(GetAsyncKeyState))(0x1))
//		{
//			current_element = -1;
//		}
//
//		//Drag
//		if (hover_element && safe_call(safe_call(GetAsyncKeyState))(0x1))
//		{
//
//		}
//		else if ((isHovered || dragPos.x != 0) && !hover_element)
//		{
//			if (Input::IsMouseClicked(0, elements_count, true))
//			{
//				/*Vector2 cursorPos = CursorPos();
//
//				cursorPos.x -= size.x;
//				cursorPos.y -= size.y;
//
//				if (dragPos.x == 0)
//				{
//					dragPos.x = (cursorPos.x - pos->x);
//					dragPos.x = (cursorPos.x - pos->y);
//				}
//				pos->x = cursorPos.x - dragPos.x;
//				pos->y = cursorPos.y - dragPos.y;*/
//			}
//			else
//			{
//				dragPos = Vector2{ 0, 0 };
//			}
//		}
//		else
//		{
//			hover_element = false;
//		}
//
//
//		offset_x = 0.0f; offset_y = 0.0f;
//		menu_pos = Vector2{ pos->x, pos->y };
//		first_element_pos = Vector2{ 0, 0 };
//		current_element_pos = Vector2{ 0, 0 };
//		current_element_size = Vector2{ 0, 0 };
//
//		if (!WindowInvisible) {
//			//Bg
//			drawFilledRect(Vector2{ pos->x, pos->y }, size.x, size.y, Colors::Window_Background);
//			//drawFilledRect(Vector2{ pos->x, pos->y }, 122, size.y, ue::FLinearColor{ 0.006f, 0.006f, 0.006f, 1.0f });//My tabs bg
//
//			//Header
//			drawFilledRect(Vector2{ pos->x, pos->y }, size.x, 25.0f, Colors::Window_Header);
//
//			offset_y += 25.0f;
//
//			//Title
//			Vector2 titlePos = Vector2{ pos->x + size.x / 2, pos->y + 25 / 2 };
//			TextCenter(name, titlePos, ue::FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);
//		}
//		else {
//			offset_y += 25.0f;
//		}
//		return true;
//	}
//
//	static void Text(char* text, bool center = false, bool outline = false)
//	{
//		elements_count++;
//
//		float size = 25;
//		Vector2 padding = Vector2{ 10, 10 };
//		Vector2 pos = Vector2{ menu_pos.x + padding.x + offset_x, menu_pos.y + padding.y + offset_y };
//		if (sameLine)
//		{
//			pos.x = last_element_pos.x + last_element_size.x + padding.x;
//			pos.y = last_element_pos.y;
//		}
//		if (pushY)
//		{
//			pos.y = pushYvalue;
//			pushY = false;
//			pushYvalue = 0.0f;
//			offset_y = pos.y - menu_pos.y;
//		}
//
//		if (!sameLine)
//			offset_y += size + padding.y;
//
//		//Text
//		Vector2 textPos = Vector2{ pos.x + 5.0f, pos.y + size / 2 };
//		if (center)
//			TextCenter(text, textPos, ue::FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, outline);
//		else
//			TextLeft(text, textPos, ue::FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, outline);
//
//		sameLine = false;
//		last_element_pos = pos;
//		//last_element_size = size;
//		if (first_element_pos.x == 0.0f)
//			first_element_pos = pos;
//	}
//	static bool ButtonTab(char* name, Vector2 size, bool active)
//	{
//		elements_count++;
//
//		Vector2 padding = Vector2{ 5, 10 };
//		Vector2 pos = Vector2{ menu_pos.x + padding.x + offset_x, menu_pos.y + padding.y + offset_y };
//		if (sameLine)
//		{
//			pos.x = last_element_pos.x + last_element_size.x + padding.x;
//			pos.y = last_element_pos.y;
//		}
//		if (pushY)
//		{
//			pos.y = pushYvalue;
//			pushY = false;
//			pushYvalue = 0.0f;
//			offset_y = pos.y - menu_pos.y;
//		}
//		bool isHovered = MouseInZone(Vector2{ pos.x, pos.y }, size);
//
//		//Bg
//		if (active)
//		{
//			drawFilledRect(Vector2{ pos.x, pos.y }, size.x, size.y, Colors::Button_Active);
//		}
//		else if (isHovered)
//		{
//			drawFilledRect(Vector2{ pos.x, pos.y }, size.x, size.y, Colors::Button_Hovered);
//			hover_element = true;
//		}
//		else
//		{
//			drawFilledRect(Vector2{ pos.x, pos.y }, size.x, size.y, Colors::Button_Idle);
//		}
//
//		if (!sameLine)
//			offset_y += size.y + padding.y;
//
//		//Text
//		Vector2 textPos = Vector2{ pos.x + size.x / 2, pos.y + size.y / 2 };
//		TextCenter(name, textPos, ue::FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);
//
//
//		sameLine = false;
//		last_element_pos = pos;
//		last_element_size = size;
//		if (first_element_pos.x == 0.0f)
//			first_element_pos = pos;
//
//		if (isHovered && Input::IsMouseClicked(0, elements_count, false))
//			return true;
//
//		return false;
//	}
//	static bool Button(char* name, Vector2 size)
//	{
//		elements_count++;
//
//		Vector2 padding = Vector2{ 5, 10 };
//
//		Vector2 pos = Vector2{ menu_pos.x + padding.x + offset_x, menu_pos.y + padding.y + offset_y };
//
//		
//		if (sameLine)
//		{
//			pos.x = last_element_pos.x + last_element_size.x + padding.x;
//			pos.y = last_element_pos.y;
//		}
//		if (pushY)
//		{
//			pos.y = pushYvalue;
//			pushY = false;
//			pushYvalue = 0.0f;
//			offset_y = pos.y - menu_pos.y;
//		}
//		bool isHovered = MouseInZone(Vector2{ pos.x, pos.y }, size);
//
//		//Bg
//		if (isHovered)
//		{
//			drawFilledRect(Vector2{ pos.x, pos.y }, size.x, size.y, Colors::Button_Hovered);
//			hover_element = true;
//		}
//		else
//		{
//			drawFilledRect(Vector2{ pos.x, pos.y }, size.x, size.y, Colors::Button_Idle);
//		}
//
//		if (!sameLine)
//			offset_y += size.y + padding.y;
//
//		//Text
//		Vector2 textPos = Vector2{ pos.x + size.x / 2, pos.y + size.y / 2 };
//		//if (!TextOverlapedFromActiveElement(textPos))
//		TextCenter(name, textPos, ue::FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);
//
//
//		sameLine = false;
//		last_element_pos = pos;
//		last_element_size = size;
//		if (first_element_pos.x == 0.0f)
//			first_element_pos = pos;
//
//		if (isHovered && Input::IsMouseClicked(0, elements_count, false))
//			return true;
//
//		return false;
//	}
//	static bool InvisibleButton(char* name, Vector2 size)
//	{
//		elements_count++;
//
//		Vector2 padding = Vector2{ 5, 10 };
//		Vector2 pos = Vector2{ menu_pos.x + padding.x + offset_x, menu_pos.y + padding.y + offset_y };
//		if (sameLine)
//		{
//			pos.x = last_element_pos.x + last_element_size.x + padding.x;
//			pos.y = last_element_pos.y;
//		}
//		if (pushY)
//		{
//			pos.y = pushYvalue;
//			pushY = false;
//			pushYvalue = 0.0f;
//			offset_y = pos.y - menu_pos.y;
//		}
//		bool isHovered = MouseInZone(Vector2{ pos.x, pos.y }, size);
//
//		if (!sameLine)
//			offset_y += size.y + padding.y;
//
//		sameLine = false;
//		last_element_pos = pos;
//		last_element_size = size;
//		if (first_element_pos.x == 0.0f)
//			first_element_pos = pos;
//
//		if (isHovered && Input::IsMouseClicked(0, elements_count, false))
//			return true;
//
//		return false;
//	}
//	static void FakeElement()
//	{
//		Vector2 size = Vector2(1, 1);
//		elements_count++;
//
//		Vector2 padding = Vector2{ 1, 1 };
//
//		Vector2 pos = Vector2{ menu_pos.x + padding.x + offset_x, menu_pos.y + padding.y + offset_y };
//
//
//		if (sameLine)
//		{
//			pos.x = last_element_pos.x + last_element_size.x + padding.x;
//			pos.y = last_element_pos.y;
//		}
//		if (pushY)
//		{
//			pos.y = pushYvalue;
//			pushY = false;
//			pushYvalue = 0.0f;
//			offset_y = pos.y - menu_pos.y;
//		}
//
//
//
//		if (!sameLine)
//			offset_y += size.y + padding.y;
//
//
//		sameLine = false;
//		last_element_pos = pos;
//		last_element_size = size;
//		if (first_element_pos.x == 0.0f)
//			first_element_pos = pos;
//
//		return;
//	}
//
//	static void Checkbox(char* name, bool* value)
//	{
//		elements_count++;
//
//		Vector2 size = Vector2(20, 20);
//		Vector2 padding = Vector2{ 10, 10 };
//		Vector2 pos = Vector2{ menu_pos.x + padding.x + offset_x, menu_pos.y + padding.y + offset_y };
//		if (sameLine)
//		{
//			pos.x = last_element_pos.x + last_element_size.x + padding.x;
//			pos.y = last_element_pos.y;
//		}
//		if (pushY)
//		{
//			pos.y = pushYvalue;
//			pushY = false;
//			pushYvalue = 0.0f;
//			offset_y = pos.y - menu_pos.y;
//		}
//		bool isHovered = MouseInZone(Vector2{ pos.x, pos.y }, Vector2{ size.x, size.y });
//
//		if (!sameLine)
//			offset_y += size.y + padding.y;
//
//
//		const float check_sz = ZeroGUI_MIN(size.x, size.y);
//		const float pad = ZeroGUI_MAX(1.0f, (float)(int)(check_sz / 6.0f));
//
//
//		Vector2 CheckMarkPos = Vector2(pos.x, pos.y);
//
//
//		float sz = size.x - pad * 2.0f;
//
//
//		float thickness = ZeroGUI_MAX(sz / 5.0f, 1.0f);
//		sz -= thickness * 0.5f;
//		CheckMarkPos = CheckMarkPos + Vector2(thickness * 0.25f, thickness * 0.25f);
//
//		float third = sz / 3.0f;
//		float bx = CheckMarkPos.x + third;
//		float by = CheckMarkPos.y + sz - third * 0.5f;
//
//		Vector2 TopLeft = Vector2(bx + third * 2 - sz, by - third * 2);
//		Vector2 TopRight = Vector2(bx + third * 2, by - third * 2);
//		Vector2 BottomLeft = Vector2(bx + third * 2 - sz, by - third * 2 + sz);
//		Vector2 BottomRight = Vector2(bx + third * 2, by - third * 2 + sz);
//
//		if (!*value)
//		{
//			//Top Left -> Bottom Right
//			//Draw_Line(TopLeft, BottomRight, thickness, ue::FLinearColor(1.0f, 1.0f, 1.0f, 1.0f));
//			
//			//Bottom Left -> Top Right			
//			//Draw_Line(BottomLeft, TopRight, thickness, ue::FLinearColor(1.0f, 1.0f, 1.0f, 1.0f));
//
//			Draw_Line(TopLeft, TopRight, thickness, ue::FLinearColor(1.0f, 1.0f, 1.0f, 1.0f));
//			Draw_Line(TopRight, BottomRight, thickness, ue::FLinearColor(1.0f, 1.0f, 1.0f, 1.0f));
//			Draw_Line(BottomRight, BottomLeft, thickness, ue::FLinearColor(1.0f, 1.0f, 1.0f, 1.0f));
//			Draw_Line(BottomLeft, TopLeft, thickness, ue::FLinearColor(1.0f, 1.0f, 1.0f, 1.0f));
//		}
//		else {
//
//			//Third -> Center
//			Draw_Line(Vector2(bx - third, by - third), Vector2(bx, by), thickness, ue::FLinearColor(1.0f, 1.0f, 1.0f, 1.0f));
//
//			//Center -> Top Right
//			Draw_Line(Vector2(bx, by), TopRight, thickness, ue::FLinearColor(1.0f, 1.0f, 1.0f, 1.0f));
//		}
//
//
//
//		//Text
//		Vector2 textPos = Vector2{ pos.x + size.x + 5.0f, pos.y/* + size.y / 2 */};
//		//if (!TextOverlapedFromActiveElement(textPos))
//		TextLeft(name, textPos, ue::FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);
//
//
//		sameLine = false;
//		last_element_pos = pos;
//		//last_element_size = size;
//		if (first_element_pos.x == 0.0f)
//			first_element_pos = pos;
//
//		if (isHovered && Input::IsMouseClicked(0, elements_count, false))
//			*value = !*value;
//	}
//	static void SliderInt(char* name, int* value, int min, int max)
//	{
//		elements_count++;
//
//		Vector2 size = Vector2{ 240, 50 };
//		Vector2 slider_size = Vector2{ 200, 10 };
//		Vector2 padding = Vector2{ 10, 15 };
//		Vector2 pos = Vector2{ menu_pos.x + padding.x + offset_x, menu_pos.y + padding.y + offset_y };
//		if (sameLine)
//		{
//			pos.x = last_element_pos.x + last_element_size.x + padding.x;
//			pos.y = last_element_pos.y;
//		}
//		if (pushY)
//		{
//			pos.y = pushYvalue;
//			pushY = false;
//			pushYvalue = 0.0f;
//			offset_y = pos.y - menu_pos.y;
//		}
//		bool isHovered = MouseInZone(Vector2{ pos.x, pos.y + slider_size.y + padding.y }, slider_size);
//
//		if (!sameLine)
//			offset_y += size.y + padding.y;
//
//		//Bg
//		if (isHovered || current_element == elements_count)
//		{
//			//Drag
//			if (Input::IsMouseClicked(0, elements_count, true))
//			{
//				current_element = elements_count;
//
//				Vector2 cursorPos = CursorPos();
//				*value = ((cursorPos.x - pos.x) * ((max - min) / slider_size.x)) + min;
//				if (*value < min) *value = min;
//				if (*value > max) *value = max;
//			}
//
//			drawFilledRect(Vector2{ pos.x, pos.y + slider_size.y + padding.y }, slider_size.x, slider_size.y, Colors::Slider_Hovered);
//			drawFilledRect(Vector2{ pos.x, pos.y + slider_size.y + padding.y + 5.0f }, 5.0f, 5.0f, Colors::Slider_Progress);
//
//			hover_element = true;
//		}
//		else
//		{
//			drawFilledRect(Vector2{ pos.x, pos.y + slider_size.y + padding.y }, slider_size.x, slider_size.y, Colors::Slider_Idle);
//			drawFilledRect(Vector2{ pos.x, pos.y + slider_size.y + padding.y + 5.0f }, 5.0f, 5.0f, Colors::Slider_Progress);
//		}
//
//
//		//Value
//		float oneP = slider_size.x / (max - min);
//		drawFilledRect(Vector2{ pos.x, pos.y + slider_size.y + padding.y }, oneP * (*value - min), slider_size.y, Colors::Slider_Progress);
//		//drawFilledRect(Vector2{ pos.x + oneP * (*value - min) - 10.0f, pos.y + slider_size.y - 5.0f + padding.y }, 20.0f, 20.0f, Colors::Slider_Button);
//		DrawFilledCircle(Vector2{ pos.x + oneP * (*value - min), pos.y + slider_size.y + 3.3f + padding.y }, 10.0f, Colors::Slider_Button);
//		DrawFilledCircle(Vector2{ pos.x + oneP * (*value - min), pos.y + slider_size.y + 3.3f + padding.y }, 5.0f, Colors::Slider_Progress);
//
//		char buffer[32];
//		sprintf_s(buffer, "%i", *value);
//		Vector2 valuePos = Vector2{ pos.x + oneP * (*value - min), pos.y + slider_size.y + 25 + padding.y };
//		TextCenter(buffer, valuePos, ue::FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);
//
//		//Text
//		Vector2 textPos = Vector2{ pos.x + 5, pos.y + 10 };
//		TextLeft(name, textPos, ue::FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);
//
//
//		sameLine = false;
//		last_element_pos = pos;
//		last_element_size = size;
//		if (first_element_pos.x == 0.0f)
//			first_element_pos = pos;
//	}
//	static void SliderFloat(char* name, float* value, float min, float max, const char* format = "%.1f")
//	{
//		elements_count++;
//
//		Vector2 size = Vector2{ 210, 40 };
//		Vector2 slider_size = Vector2{ 421, 2 };
//		Vector2 adjust_zone = Vector2{ 0, 20 };
//		Vector2 padding = Vector2{ 10, 20 }; //15
//		Vector2 pos = Vector2{ menu_pos.x + padding.x + offset_x, menu_pos.y + padding.y + offset_y };
//		if (sameLine)
//		{
//			pos.x = last_element_pos.x + last_element_size.x + padding.x;
//			pos.y = last_element_pos.y;
//		}
//		if (pushY)
//		{
//			pos.y = pushYvalue;
//			pushY = false;
//			pushYvalue = 0.0f;
//			offset_y = pos.y - menu_pos.y;
//		}
//		bool isHovered = MouseInZone(Vector2{ pos.x, pos.y + slider_size.y + padding.y - adjust_zone.y }, Vector2{ pos.x + slider_size.x, slider_size.y + adjust_zone.y * 1.5f });
//		
//		if (!sameLine)
//			offset_y += size.y + padding.y - 5;
//
//		//Bg
//		if (isHovered || current_element == elements_count)
//		{
//			//Drag
//			if (Input::IsMouseClicked(0, elements_count, true))
//			{
//				current_element = elements_count;
//
//				Vector2 cursorPos = CursorPos();
//
//				*value = ((cursorPos.x - pos.x) * ((max - min) / slider_size.x)) + min;
//				if (*value < min) *value = min;
//				if (*value > max) *value = max;
//			}
//
//			//drawFilledRect(Vector2{ pos.x, pos.y + slider_size.y + padding.y }, slider_size.x, slider_size.y, Colors::Slider_Hovered);
//			//DrawFilledCircle(Vector2{ pos.x, pos.y + padding.y + 9.3f }, 3.1f, Colors::Slider_Progress);
//			//DrawFilledCircle(Vector2{ pos.x + slider_size.x, pos.y + padding.y + 9.3f }, 3.1f, Colors::Slider_Hovered);
//
//			hover_element = true;
//		}
//		else
//		{
//			//drawFilledRect(Vector2{ pos.x, pos.y + slider_size.y + padding.y }, slider_size.x, slider_size.y, Colors::Slider_Idle);
//			//DrawFilledCircle(Vector2{ pos.x, pos.y + padding.y + 9.3f }, 3.1f, Colors::Slider_Progress);
//			//DrawFilledCircle(Vector2{ pos.x + slider_size.x, pos.y + padding.y + 9.3f }, 3.1f, Colors::Slider_Idle);
//		}
//
//
//		//Text
//		Vector2 textPos = Vector2{ pos.x, pos.y + 5 };
//		TextLeft(name, textPos, Colors::Text, false);
//
//		//Empty
//		float oneP = slider_size.x / (max - min);
//		drawFilledRect(Vector2{ pos.x, pos.y + slider_size.y + padding.y }, slider_size.x, slider_size.y, ue::FLinearColor(0.21f, 0.20f, 0.21f, 1.00f));
//
//		//Value
//		drawFilledRect(Vector2{ pos.x, pos.y + slider_size.y + padding.y }, oneP * (*value - min), slider_size.y, ue::FLinearColor(0.76f, 0.10f, 0.24f, 1.00f));
//
//		Vector2 GrabPosition = Vector2(pos.x + oneP * (*value - min), pos.y + slider_size.y + 2.66f + padding.y);
//		if (*value != min)
//			Draw_Line(Vector2(GrabPosition.x, GrabPosition.y + 5), Vector2(GrabPosition.x, GrabPosition.y - 10), 2.1f, ue::FLinearColor(0.76f, 0.10f, 0.24f, 1.00f));
//
//		char buffer[32];
//		sprintf_s(buffer, format, *value);
//		Vector2 valuePos = Vector2{ pos.x + slider_size.x, pos.y + 5 };
//		TextCenter(buffer, valuePos, Colors::Text, false);
//
//
//		sameLine = false;
//		last_element_pos = pos;
//		last_element_size = size;
//		if (first_element_pos.x == 0.0f)
//			first_element_pos = pos;
//	}
//
//
//
//	static bool checkbox_enabled[256];
//	static void Combobox(char* name, Vector2 size, int* value, const char* arg, ...)
//	{
//		elements_count++;
//
//		Vector2 padding = Vector2{ 5, 10 };
//		Vector2 pos = Vector2{ menu_pos.x + padding.x + offset_x, menu_pos.y + padding.y + offset_y };
//		if (sameLine)
//		{
//			pos.x = last_element_pos.x + last_element_size.x + padding.x;
//			pos.y = last_element_pos.y;
//		}
//		if (pushY)
//		{
//			pos.y = pushYvalue;
//			pushY = false;
//			pushYvalue = 0.0f;
//			offset_y = pos.y - menu_pos.y;
//		}
//		bool isHovered = MouseInZone(Vector2{ pos.x, pos.y - 15 }, size);
//
//		//Bg
//		if (isHovered || checkbox_enabled[elements_count])
//		{
//			drawFilledRect(Vector2{ pos.x, pos.y }, size.x, size.y, Colors::Combobox_Hovered);
//
//			hover_element = true;
//		}
//		else
//		{
//			drawFilledRect(Vector2{ pos.x, pos.y }, size.x, size.y, Colors::Combobox_Idle);
//		}
//
//		if (!sameLine)
//			offset_y += size.y + padding.y;
//
//		//Text
//		Vector2 textPos = Vector2{ pos.x + size.x + 5.0f, pos.y/* + size.y / 2*/ };
//		TextLeft(name, textPos, ue::FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);
//
//		//Elements
//		bool isHovered2 = false;
//		Vector2 element_pos = pos;
//		int num = 0;
//
//		if (checkbox_enabled[elements_count])
//		{
//			current_element_size.x = element_pos.x - 5.0f;
//			current_element_size.y = element_pos.y - 5.0f;
//		}
//		va_list arguments;
//		for (va_start(arguments, arg); arg != NULL; arg = va_arg(arguments, const char*))
//		{
//			//Selected Element
//			if (num == *value)
//			{
//				Vector2 _textPos = Vector2{ pos.x + 5.0f, pos.y/*+ size.y / 2*/ };
//				TextLeft((char*)arg, _textPos, ue::FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);
//			}
//
//			if (checkbox_enabled[elements_count])
//			{
//				element_pos.y += 25.0f;
//
//				isHovered2 = MouseInZone(Vector2{ element_pos.x, element_pos.y }, Vector2{ size.x, 25.0f });
//				if (isHovered2)
//				{
//					hover_element = true;
//					PostRenderer::drawFilledRect(Vector2{ element_pos.x, element_pos.y }, size.x, 25.0f, Colors::Combobox_Hovered);
//
//					//Click
//					if (Input::IsMouseClicked(0, elements_count, false))
//					{
//						*value = num;
//						checkbox_enabled[elements_count] = false;
//					}
//				}
//				else
//				{
//					PostRenderer::drawFilledRect(Vector2{ element_pos.x, element_pos.y }, size.x, 25.0f, Colors::Combobox_Idle);
//				}
//
//				PostRenderer::TextLeft((char*)arg, Vector2{ element_pos.x + 5.0f, element_pos.y/* + 13.0f*/ }, ue::FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);
//			}
//			num++;
//		}
//		va_end(arguments);
//		if (checkbox_enabled[elements_count])
//		{
//			current_element_size.x = element_pos.x + 5.0f;
//			current_element_size.y = element_pos.y + 5.0f;
//		}
//
//
//		sameLine = false;
//		last_element_pos = pos;
//		last_element_size = size;
//		if (first_element_pos.x == 0.0f)
//			first_element_pos = pos;
//
//		if (isHovered && Input::IsMouseClicked(0, elements_count, false))
//		{
//			checkbox_enabled[elements_count] = !checkbox_enabled[elements_count];
//		}
//		if (!isHovered && !isHovered2 && Input::IsMouseClicked(0, elements_count, false))
//		{
//			checkbox_enabled[elements_count] = false;
//		}
//	}
//
//	static int active_hotkey = -1;
//	static bool already_pressed = false;
//	static std::string VirtualKeyCodeToString(UCHAR virtualKey)
//	{
//		UINT scanCode = MapVirtualKey(virtualKey, MAPVK_VK_TO_VSC);
//
//		if (virtualKey == VK_LBUTTON)
//		{
//			return ("MOUSE0");
//		}
//		if (virtualKey == VK_RBUTTON)
//		{
//			return ("MOUSE1");
//		}
//		if (virtualKey == VK_MBUTTON)
//		{
//			return ("MBUTTON");
//		}
//		if (virtualKey == VK_XBUTTON1)
//		{
//			return ("XBUTTON1");
//		}
//		if (virtualKey == VK_XBUTTON2)
//		{
//			return ("XBUTTON2");
//		}
//
//		CHAR szName[128];
//		int result = 0;
//		switch (virtualKey)
//		{
//		case VK_LEFT: case VK_UP: case VK_RIGHT: case VK_DOWN:
//		case VK_RCONTROL: case VK_RMENU:
//		case VK_LWIN: case VK_RWIN: case VK_APPS:
//		case VK_PRIOR: case VK_NEXT:
//		case VK_END: case VK_HOME:
//		case VK_INSERT: case VK_DELETE:
//		case VK_DIVIDE:
//		case VK_NUMLOCK:
//			scanCode |= KF_EXTENDED;
//		default:
//			result = GetKeyNameTextA(scanCode << 16, szName, 128);
//		}
//
//		return szName;
//	}
//	static void Hotkey(char* name, Vector2 size, int* key)
//	{
//		elements_count++;
//
//		Vector2 padding = Vector2{ 5, 10 };
//		Vector2 pos = Vector2{ menu_pos.x + padding.x + offset_x, menu_pos.y + padding.y + offset_y };
//		if (sameLine)
//		{
//			pos.x = last_element_pos.x + last_element_size.x + padding.x;
//			pos.y = last_element_pos.y + (last_element_size.y / 2) - size.y / 2;
//		}
//		if (pushY)
//		{
//			pos.y = pushYvalue;
//			pushY = false;
//			pushYvalue = 0.0f;
//			offset_y = pos.y - menu_pos.y;
//		}
//		bool isHovered = MouseInZone(Vector2{ pos.x, pos.y }, size);
//
//		//Bg
//		if (isHovered)
//		{
//			drawFilledRect(Vector2{ pos.x, pos.y }, size.x, size.y, Colors::Button_Hovered);
//			hover_element = true;
//		}
//		else
//		{
//			drawFilledRect(Vector2{ pos.x, pos.y }, size.x, size.y, Colors::Button_Idle);
//		}
//
//		if (!sameLine)
//			offset_y += size.y + padding.y;
//
//		if (active_hotkey == elements_count)
//		{
//			//Text
//			Vector2 textPos = Vector2{ pos.x + size.x / 2, pos.y + size.y / 2 };
//			TextCenter(xorstr("[Press Key]"), textPos, ue::FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);
//
//			if (!ZeroGUI::Input::IsAnyMouseDown())
//			{
//				already_pressed = false;
//			}
//
//			if (!already_pressed)
//			{
//				for (int code = 0; code < 255; code++)
//				{
//					if (safe_call(safe_call(GetAsyncKeyState))(code))
//					{
//						*key = code;
//						active_hotkey = -1;
//					}
//				}
//			}
//		}
//		else
//		{
//			//Text
//			Vector2 textPos = Vector2{ pos.x + size.x / 2, pos.y + size.y / 2 };
//			TextCenter((char*)VirtualKeyCodeToString(*key).c_str(), textPos, ue::FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);
//
//			if (isHovered)
//			{
//				if (Input::IsMouseClicked(0, elements_count, false))
//				{
//					already_pressed = true;
//					active_hotkey = elements_count;
//
//					//Queue Fix
//					for (int code = 0; code < 255; code++)
//						if (safe_call(safe_call(GetAsyncKeyState))(code)) {}
//				}
//			}
//			else
//			{
//				if (Input::IsMouseClicked(0, elements_count, false))
//				{
//					active_hotkey = -1;
//				}
//			}
//		}
//
//
//		sameLine = false;
//		last_element_pos = pos;
//		last_element_size = size;
//		if (first_element_pos.x == 0.0f)
//			first_element_pos = pos;
//	}
//
//	static int active_picker = -1;
//	static ue::FLinearColor saved_color;
//	static bool ColorPixel(Vector2 pos, Vector2 size, ue::FLinearColor* original, ue::FLinearColor color)
//	{
//		PostRenderer::drawFilledRect(Vector2{ pos.x, pos.y }, size.x, size.y, color);
//
//		//Выбранный цвет
//		if (original->R == color.R && original->G == color.G && original->B == color.B)
//		{
//			PostRenderer::Draw_Line(Vector2{ pos.x, pos.y }, Vector2{ pos.x + size.x - 1, pos.y }, 1.0f, ue::FLinearColor{ 0.0f, 0.0f, 0.0f, 1.0f });
//			PostRenderer::Draw_Line(Vector2{ pos.x, pos.y + size.y - 1 }, Vector2{ pos.x + size.x - 1, pos.y + size.y - 1 }, 1.0f, ue::FLinearColor{ 0.0f, 0.0f, 0.0f, 1.0f });
//			PostRenderer::Draw_Line(Vector2{ pos.x, pos.y }, Vector2{ pos.x, pos.y + size.y - 1 }, 1.0f, ue::FLinearColor{ 0.0f, 0.0f, 0.0f, 1.0f });
//			PostRenderer::Draw_Line(Vector2{ pos.x + size.x - 1, pos.y }, Vector2{ pos.x + size.x - 1, pos.y + size.y - 1 }, 1.0f, ue::FLinearColor{ 0.0f, 0.0f, 0.0f, 1.0f });
//		}
//
//		//Смена цвета
//		bool isHovered = MouseInZone(Vector2{ pos.x, pos.y }, size);
//		if (isHovered)
//		{
//			if (Input::IsMouseClicked(0, elements_count, false))
//				*original = color;
//		}
//
//		return true;
//	}
//	static void ColorPicker(char* name, ue::FLinearColor* color)
//	{
//		elements_count++;
//
//		float size = 25;
//		Vector2 padding = Vector2{ 10, 10 };
//		Vector2 pos = Vector2{ menu_pos.x + padding.x + offset_x, menu_pos.y + padding.y + offset_y };
//		if (sameLine)
//		{
//			pos.x = last_element_pos.x + last_element_size.x + padding.x;
//			pos.y = last_element_pos.y;
//		}
//		if (pushY)
//		{
//			pos.y = pushYvalue;
//			pushY = false;
//			pushYvalue = 0.0f;
//			offset_y = pos.y - menu_pos.y;
//		}
//		bool isHovered = MouseInZone(Vector2{ pos.x, pos.y }, Vector2{ size, size });
//
//		if (!sameLine)
//			offset_y += size + padding.y;
//
//		if (active_picker == elements_count)
//		{
//			hover_element = true;
//
//			float sizePickerX = 250;
//			float sizePickerY = 250;
//			bool isHoveredPicker = MouseInZone(Vector2{ pos.x, pos.y }, Vector2{ sizePickerX, sizePickerY - 60 });
//
//			//Background
//			PostRenderer::drawFilledRect(Vector2{ pos.x, pos.y }, sizePickerX, sizePickerY - 65, Colors::ColorPicker_Background);
//
//			//float pixedSize = sizePickerY / pixels;
//			//ue::FLinearColor temp_color{1.0f, 1.0f, 1.0f, 1.0f};
//			//float iterator = 0.0f;
//			//
//			//for (int y = 0; y < pixels; y++)
//			//{
//			//	for (int x = 0; x < pixels; x++)
//			//	{
//			//		ColorPixel(Vector2{ pos.x + pixedSize * x, pos.y + pixedSize * y }, pixedSize, color, temp_color);
//			//		temp_color.R -= (1.0f - saved_color.R) / pixels;
//			//		temp_color.G -= (1.0f - saved_color.G) / pixels;
//			//		temp_color.B -= (1.0f - saved_color.B) / pixels;
//			//	}
//			//	
//			//	iterator += 1.0f / pixels;
//			//	temp_color = ue::FLinearColor{ 1.0f - iterator, 1.0f - iterator, 1.0f - iterator, 1.0f };
//			//}
//
//			Vector2 pixelSize = Vector2{ sizePickerX / 12, sizePickerY / 12 };
//
//			//0
//			{
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 0, pos.y + pixelSize.y * 0 }, pixelSize, color, ue::FLinearColor{ 174 / 255.f, 235 / 255.f, 253 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 0, pos.y + pixelSize.y * 1 }, pixelSize, color, ue::FLinearColor{ 136 / 255.f, 225 / 255.f, 251 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 0, pos.y + pixelSize.y * 2 }, pixelSize, color, ue::FLinearColor{ 108 / 255.f, 213 / 255.f, 250 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 0, pos.y + pixelSize.y * 3 }, pixelSize, color, ue::FLinearColor{ 89 / 255.f, 175 / 255.f, 213 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 0, pos.y + pixelSize.y * 4 }, pixelSize, color, ue::FLinearColor{ 76 / 255.f, 151 / 255.f, 177 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 0, pos.y + pixelSize.y * 5 }, pixelSize, color, ue::FLinearColor{ 60 / 255.f, 118 / 255.f, 140 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 0, pos.y + pixelSize.y * 6 }, pixelSize, color, ue::FLinearColor{ 43 / 255.f, 85 / 255.f, 100 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 0, pos.y + pixelSize.y * 7 }, pixelSize, color, ue::FLinearColor{ 32 / 255.f, 62 / 255.f, 74 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 0, pos.y + pixelSize.y * 8 }, pixelSize, color, ue::FLinearColor{ 255 / 255.f, 255 / 255.f, 255 / 255.f, 1.0f });
//			}
//			//1
//			{
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 1, pos.y + pixelSize.y * 0 }, pixelSize, color, ue::FLinearColor{ 175 / 255.f, 205 / 255.f, 252 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 1, pos.y + pixelSize.y * 1 }, pixelSize, color, ue::FLinearColor{ 132 / 255.f, 179 / 255.f, 252 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 1, pos.y + pixelSize.y * 2 }, pixelSize, color, ue::FLinearColor{ 90 / 255.f, 152 / 255.f, 250 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 1, pos.y + pixelSize.y * 3 }, pixelSize, color, ue::FLinearColor{ 55 / 255.f, 120 / 255.f, 250 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 1, pos.y + pixelSize.y * 4 }, pixelSize, color, ue::FLinearColor{ 49 / 255.f, 105 / 255.f, 209 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 1, pos.y + pixelSize.y * 5 }, pixelSize, color, ue::FLinearColor{ 38 / 255.f, 83 / 255.f, 165 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 1, pos.y + pixelSize.y * 6 }, pixelSize, color, ue::FLinearColor{ 28 / 255.f, 61 / 255.f, 120 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 1, pos.y + pixelSize.y * 7 }, pixelSize, color, ue::FLinearColor{ 20 / 255.f, 43 / 255.f, 86 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 1, pos.y + pixelSize.y * 8 }, pixelSize, color, ue::FLinearColor{ 247 / 255.f, 247 / 255.f, 247 / 255.f, 1.0f });
//			}
//			//2
//			{
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 2, pos.y + pixelSize.y * 0 }, pixelSize, color, ue::FLinearColor{ 153 / 255.f, 139 / 255.f, 250 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 2, pos.y + pixelSize.y * 1 }, pixelSize, color, ue::FLinearColor{ 101 / 255.f, 79 / 255.f, 249 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 2, pos.y + pixelSize.y * 2 }, pixelSize, color, ue::FLinearColor{ 64 / 255.f, 50 / 255.f, 230 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 2, pos.y + pixelSize.y * 3 }, pixelSize, color, ue::FLinearColor{ 54 / 255.f, 38 / 255.f, 175 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 2, pos.y + pixelSize.y * 4 }, pixelSize, color, ue::FLinearColor{ 39 / 255.f, 31 / 255.f, 144 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 2, pos.y + pixelSize.y * 5 }, pixelSize, color, ue::FLinearColor{ 32 / 255.f, 25 / 255.f, 116 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 2, pos.y + pixelSize.y * 6 }, pixelSize, color, ue::FLinearColor{ 21 / 255.f, 18 / 255.f, 82 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 2, pos.y + pixelSize.y * 7 }, pixelSize, color, ue::FLinearColor{ 16 / 255.f, 13 / 255.f, 61 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 2, pos.y + pixelSize.y * 8 }, pixelSize, color, ue::FLinearColor{ 228 / 255.f, 228 / 255.f, 228 / 255.f, 1.0f });
//			}
//			//3
//			{
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 3, pos.y + pixelSize.y * 0 }, pixelSize, color, ue::FLinearColor{ 194 / 255.f, 144 / 255.f, 251 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 3, pos.y + pixelSize.y * 1 }, pixelSize, color, ue::FLinearColor{ 165 / 255.f, 87 / 255.f, 249 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 3, pos.y + pixelSize.y * 2 }, pixelSize, color, ue::FLinearColor{ 142 / 255.f, 57 / 255.f, 239 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 3, pos.y + pixelSize.y * 3 }, pixelSize, color, ue::FLinearColor{ 116 / 255.f, 45 / 255.f, 184 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 3, pos.y + pixelSize.y * 4 }, pixelSize, color, ue::FLinearColor{ 92 / 255.f, 37 / 255.f, 154 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 3, pos.y + pixelSize.y * 5 }, pixelSize, color, ue::FLinearColor{ 73 / 255.f, 29 / 255.f, 121 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 3, pos.y + pixelSize.y * 6 }, pixelSize, color, ue::FLinearColor{ 53 / 255.f, 21 / 255.f, 88 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 3, pos.y + pixelSize.y * 7 }, pixelSize, color, ue::FLinearColor{ 37 / 255.f, 15 / 255.f, 63 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 3, pos.y + pixelSize.y * 8 }, pixelSize, color, ue::FLinearColor{ 203 / 255.f, 203 / 255.f, 203 / 255.f, 1.0f });
//			}
//			//4
//			{
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 4, pos.y + pixelSize.y * 0 }, pixelSize, color, ue::FLinearColor{ 224 / 255.f, 162 / 255.f, 197 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 4, pos.y + pixelSize.y * 1 }, pixelSize, color, ue::FLinearColor{ 210 / 255.f, 112 / 255.f, 166 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 4, pos.y + pixelSize.y * 2 }, pixelSize, color, ue::FLinearColor{ 199 / 255.f, 62 / 255.f, 135 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 4, pos.y + pixelSize.y * 3 }, pixelSize, color, ue::FLinearColor{ 159 / 255.f, 49 / 255.f, 105 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 4, pos.y + pixelSize.y * 4 }, pixelSize, color, ue::FLinearColor{ 132 / 255.f, 41 / 255.f, 89 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 4, pos.y + pixelSize.y * 5 }, pixelSize, color, ue::FLinearColor{ 104 / 255.f, 32 / 255.f, 71 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 4, pos.y + pixelSize.y * 6 }, pixelSize, color, ue::FLinearColor{ 75 / 255.f, 24 / 255.f, 51 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 4, pos.y + pixelSize.y * 7 }, pixelSize, color, ue::FLinearColor{ 54 / 255.f, 14 / 255.f, 36 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 4, pos.y + pixelSize.y * 8 }, pixelSize, color, ue::FLinearColor{ 175 / 255.f, 175 / 255.f, 175 / 255.f, 1.0f });
//			}
//			//5
//			{
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 5, pos.y + pixelSize.y * 0 }, pixelSize, color, ue::FLinearColor{ 235 / 255.f, 175 / 255.f, 176 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 5, pos.y + pixelSize.y * 1 }, pixelSize, color, ue::FLinearColor{ 227 / 255.f, 133 / 255.f, 135 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 5, pos.y + pixelSize.y * 2 }, pixelSize, color, ue::FLinearColor{ 219 / 255.f, 87 / 255.f, 88 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 5, pos.y + pixelSize.y * 3 }, pixelSize, color, ue::FLinearColor{ 215 / 255.f, 50 / 255.f, 36 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 5, pos.y + pixelSize.y * 4 }, pixelSize, color, ue::FLinearColor{ 187 / 255.f, 25 / 255.f, 7 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 5, pos.y + pixelSize.y * 5 }, pixelSize, color, ue::FLinearColor{ 149 / 255.f, 20 / 255.f, 6 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 5, pos.y + pixelSize.y * 6 }, pixelSize, color, ue::FLinearColor{ 107 / 255.f, 14 / 255.f, 4 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 5, pos.y + pixelSize.y * 7 }, pixelSize, color, ue::FLinearColor{ 77 / 255.f, 9 / 255.f, 3 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 5, pos.y + pixelSize.y * 8 }, pixelSize, color, ue::FLinearColor{ 144 / 255.f, 144 / 255.f, 144 / 255.f, 1.0f });
//			}
//			//6
//			{
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 6, pos.y + pixelSize.y * 0 }, pixelSize, color, ue::FLinearColor{ 241 / 255.f, 187 / 255.f, 171 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 6, pos.y + pixelSize.y * 1 }, pixelSize, color, ue::FLinearColor{ 234 / 255.f, 151 / 255.f, 126 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 6, pos.y + pixelSize.y * 2 }, pixelSize, color, ue::FLinearColor{ 229 / 255.f, 115 / 255.f, 76 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 6, pos.y + pixelSize.y * 3 }, pixelSize, color, ue::FLinearColor{ 227 / 255.f, 82 / 255.f, 24 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 6, pos.y + pixelSize.y * 4 }, pixelSize, color, ue::FLinearColor{ 190 / 255.f, 61 / 255.f, 15 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 6, pos.y + pixelSize.y * 5 }, pixelSize, color, ue::FLinearColor{ 150 / 255.f, 48 / 255.f, 12 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 6, pos.y + pixelSize.y * 6 }, pixelSize, color, ue::FLinearColor{ 107 / 255.f, 34 / 255.f, 8 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 6, pos.y + pixelSize.y * 7 }, pixelSize, color, ue::FLinearColor{ 79 / 255.f, 25 / 255.f, 6 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 6, pos.y + pixelSize.y * 8 }, pixelSize, color, ue::FLinearColor{ 113 / 255.f, 113 / 255.f, 113 / 255.f, 1.0f });
//			}
//			//7
//			{
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 7, pos.y + pixelSize.y * 0 }, pixelSize, color, ue::FLinearColor{ 245 / 255.f, 207 / 255.f, 169 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 7, pos.y + pixelSize.y * 1 }, pixelSize, color, ue::FLinearColor{ 240 / 255.f, 183 / 255.f, 122 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 7, pos.y + pixelSize.y * 2 }, pixelSize, color, ue::FLinearColor{ 236 / 255.f, 159 / 255.f, 74 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 7, pos.y + pixelSize.y * 3 }, pixelSize, color, ue::FLinearColor{ 234 / 255.f, 146 / 255.f, 37 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 7, pos.y + pixelSize.y * 4 }, pixelSize, color, ue::FLinearColor{ 193 / 255.f, 111 / 255.f, 28 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 7, pos.y + pixelSize.y * 5 }, pixelSize, color, ue::FLinearColor{ 152 / 255.f, 89 / 255.f, 22 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 7, pos.y + pixelSize.y * 6 }, pixelSize, color, ue::FLinearColor{ 110 / 255.f, 64 / 255.f, 16 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 7, pos.y + pixelSize.y * 7 }, pixelSize, color, ue::FLinearColor{ 80 / 255.f, 47 / 255.f, 12 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 7, pos.y + pixelSize.y * 8 }, pixelSize, color, ue::FLinearColor{ 82 / 255.f, 82 / 255.f, 82 / 255.f, 1.0f });
//			}
//			//8
//			{
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 8, pos.y + pixelSize.y * 0 }, pixelSize, color, ue::FLinearColor{ 247 / 255.f, 218 / 255.f, 170 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 8, pos.y + pixelSize.y * 1 }, pixelSize, color, ue::FLinearColor{ 244 / 255.f, 200 / 255.f, 124 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 8, pos.y + pixelSize.y * 2 }, pixelSize, color, ue::FLinearColor{ 241 / 255.f, 182 / 255.f, 77 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 8, pos.y + pixelSize.y * 3 }, pixelSize, color, ue::FLinearColor{ 239 / 255.f, 174 / 255.f, 44 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 8, pos.y + pixelSize.y * 4 }, pixelSize, color, ue::FLinearColor{ 196 / 255.f, 137 / 255.f, 34 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 8, pos.y + pixelSize.y * 5 }, pixelSize, color, ue::FLinearColor{ 154 / 255.f, 108 / 255.f, 27 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 8, pos.y + pixelSize.y * 6 }, pixelSize, color, ue::FLinearColor{ 111 / 255.f, 77 / 255.f, 19 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 8, pos.y + pixelSize.y * 7 }, pixelSize, color, ue::FLinearColor{ 80 / 255.f, 56 / 255.f, 14 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 8, pos.y + pixelSize.y * 8 }, pixelSize, color, ue::FLinearColor{ 54 / 255.f, 54 / 255.f, 54 / 255.f, 1.0f });
//			}
//			//9
//			{
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 9, pos.y + pixelSize.y * 0 }, pixelSize, color, ue::FLinearColor{ 254 / 255.f, 243 / 255.f, 187 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 9, pos.y + pixelSize.y * 1 }, pixelSize, color, ue::FLinearColor{ 253 / 255.f, 237 / 255.f, 153 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 9, pos.y + pixelSize.y * 2 }, pixelSize, color, ue::FLinearColor{ 253 / 255.f, 231 / 255.f, 117 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 9, pos.y + pixelSize.y * 3 }, pixelSize, color, ue::FLinearColor{ 254 / 255.f, 232 / 255.f, 85 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 9, pos.y + pixelSize.y * 4 }, pixelSize, color, ue::FLinearColor{ 242 / 255.f, 212 / 255.f, 53 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 9, pos.y + pixelSize.y * 5 }, pixelSize, color, ue::FLinearColor{ 192 / 255.f, 169 / 255.f, 42 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 9, pos.y + pixelSize.y * 6 }, pixelSize, color, ue::FLinearColor{ 138 / 255.f, 120 / 255.f, 30 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 9, pos.y + pixelSize.y * 7 }, pixelSize, color, ue::FLinearColor{ 101 / 255.f, 87 / 255.f, 22 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 9, pos.y + pixelSize.y * 8 }, pixelSize, color, ue::FLinearColor{ 29 / 255.f, 29 / 255.f, 29 / 255.f, 1.0f });
//			}
//			//10
//			{
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 10, pos.y + pixelSize.y * 0 }, pixelSize, color, ue::FLinearColor{ 247 / 255.f, 243 / 255.f, 185 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 10, pos.y + pixelSize.y * 1 }, pixelSize, color, ue::FLinearColor{ 243 / 255.f, 239 / 255.f, 148 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 10, pos.y + pixelSize.y * 2 }, pixelSize, color, ue::FLinearColor{ 239 / 255.f, 232 / 255.f, 111 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 10, pos.y + pixelSize.y * 3 }, pixelSize, color, ue::FLinearColor{ 235 / 255.f, 229 / 255.f, 76 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 10, pos.y + pixelSize.y * 4 }, pixelSize, color, ue::FLinearColor{ 208 / 255.f, 200 / 255.f, 55 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 10, pos.y + pixelSize.y * 5 }, pixelSize, color, ue::FLinearColor{ 164 / 255.f, 157 / 255.f, 43 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 10, pos.y + pixelSize.y * 6 }, pixelSize, color, ue::FLinearColor{ 118 / 255.f, 114 / 255.f, 31 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 10, pos.y + pixelSize.y * 7 }, pixelSize, color, ue::FLinearColor{ 86 / 255.f, 82 / 255.f, 21 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 10, pos.y + pixelSize.y * 8 }, pixelSize, color, ue::FLinearColor{ 9 / 255.f, 9 / 255.f, 9 / 255.f, 1.0f });
//			}
//			//11
//			{
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 11, pos.y + pixelSize.y * 0 }, pixelSize, color, ue::FLinearColor{ 218 / 255.f, 232 / 255.f, 182 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 11, pos.y + pixelSize.y * 1 }, pixelSize, color, ue::FLinearColor{ 198 / 255.f, 221 / 255.f, 143 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 11, pos.y + pixelSize.y * 2 }, pixelSize, color, ue::FLinearColor{ 181 / 255.f, 210 / 255.f, 103 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 11, pos.y + pixelSize.y * 3 }, pixelSize, color, ue::FLinearColor{ 154 / 255.f, 186 / 255.f, 76 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 11, pos.y + pixelSize.y * 4 }, pixelSize, color, ue::FLinearColor{ 130 / 255.f, 155 / 255.f, 64 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 11, pos.y + pixelSize.y * 5 }, pixelSize, color, ue::FLinearColor{ 102 / 255.f, 121 / 255.f, 50 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 11, pos.y + pixelSize.y * 6 }, pixelSize, color, ue::FLinearColor{ 74 / 255.f, 88 / 255.f, 36 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 11, pos.y + pixelSize.y * 7 }, pixelSize, color, ue::FLinearColor{ 54 / 255.f, 64 / 255.f, 26 / 255.f, 1.0f });
//				ColorPixel(Vector2{ pos.x + pixelSize.x * 11, pos.y + pixelSize.y * 8 }, pixelSize, color, ue::FLinearColor{ 0 / 255.f, 0 / 255.f, 0 / 255.f, 1.0f });
//			}
//
//
//
//			if (isHoveredPicker)
//			{
//				if (Input::IsMouseClicked(0, elements_count, false))
//				{
//
//				}
//			}
//			else
//			{
//				if (Input::IsMouseClicked(0, elements_count, false))
//				{
//					active_picker = -1;
//					//hover_element = false;
//				}
//			}
//		}
//		else
//		{
//
//			//Color
//			drawFilledRect(Vector2{ pos.x + 4, pos.y + 4 }, size - 8, size - 8, *color);
//
//			//Text
//			Vector2 textPos = Vector2{ pos.x + size + 5.0f, pos.y + size / 2 };
//			TextLeft(name, textPos, ue::FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);
//
//			if (isHovered && Input::IsMouseClicked(0, elements_count, false))
//			{
//				saved_color = *color;
//				active_picker = elements_count;
//			}
//		}
//
//
//		sameLine = false;
//		last_element_pos = pos;
//		//last_element_size = size;
//		if (first_element_pos.x == 0.0f)
//			first_element_pos = pos;
//	}
//
//
//	static void Render()
//	{
//		for (int i = 0; i < 128; i++)
//		{
//			if (PostRenderer::drawlist[i].type != -1)
//			{
//				//Filled Rect
//				if (PostRenderer::drawlist[i].type == 1)
//				{
//					ZeroGUI::drawFilledRect(PostRenderer::drawlist[i].pos, PostRenderer::drawlist[i].size.x, PostRenderer::drawlist[i].size.y, PostRenderer::drawlist[i].color);
//				}
//				//TextLeft
//				else if (PostRenderer::drawlist[i].type == 2)
//				{
//					ZeroGUI::TextLeft(PostRenderer::drawlist[i].name, PostRenderer::drawlist[i].pos, PostRenderer::drawlist[i].color, PostRenderer::drawlist[i].outline);
//				}
//				//TextCenter
//				else if (PostRenderer::drawlist[i].type == 3)
//				{
//					ZeroGUI::TextCenter(PostRenderer::drawlist[i].name, PostRenderer::drawlist[i].pos, PostRenderer::drawlist[i].color, PostRenderer::drawlist[i].outline);
//				}
//				//Draw_Line
//				else if (PostRenderer::drawlist[i].type == 4)
//				{
//					Draw_Line(PostRenderer::drawlist[i].from, PostRenderer::drawlist[i].to, PostRenderer::drawlist[i].thickness, PostRenderer::drawlist[i].color);
//				}
//
//				PostRenderer::drawlist[i].type = -1;
//			}
//		}
//	}
//}
#include <Windows.h>

namespace ZeroGUI
{
	namespace Input
	{
		bool mouseDown[5];
		bool mouseDownAlready[256];

		bool keysDown[256];
		bool keysDownAlready[256];

		bool IsAnyMouseDown()
		{
			if (mouseDown[0]) return true;
			if (mouseDown[1]) return true;
			if (mouseDown[2]) return true;
			if (mouseDown[3]) return true;
			if (mouseDown[4]) return true;

			return false;
		}

		bool IsMouseClicked(int button, int element_id, bool repeat)
		{
			if (mouseDown[button])
			{
				if (!mouseDownAlready[element_id])
				{
					mouseDownAlready[element_id] = true;
					return true;
				}
				if (repeat)
					return true;
			}
			else
			{
				mouseDownAlready[element_id] = false;
			}
			return false;
		}
		bool IsKeyPressed(int key, bool repeat)
		{
			if (keysDown[key])
			{
				if (!keysDownAlready[key])
				{
					keysDownAlready[key] = true;
					return true;
				}
				if (repeat)
					return true;
			}
			else
			{
				keysDownAlready[key] = false;
			}
			return false;
		}

		void Handle()
		{
			if (safe_call(GetAsyncKeyState)(0x01))
				mouseDown[0] = true;
			else
				mouseDown[0] = false;
		}
	}
}
wchar_t* s2wc(const char* c)
{
	const size_t cSize = strlen(c) + 1;
	wchar_t* wc = new wchar_t[cSize];
	mbstowcs(wc, c, cSize);

	return wc;
}

namespace ZeroGUI
{
	namespace Colors
	{
		ue::FLinearColor Text{ 1.0f, 1.0f, 1.0f, 1.0f };
		ue::FLinearColor Text_Shadow{ 0.0f, 0.0f, 0.0f, 0.0f };
		ue::FLinearColor Text_Outline{ 0.0f, 0.0f, 0.0f, 0.30f };

		ue::FLinearColor Window_Background{ 0.009f, 0.009f, 0.009f, 1.0f };
		ue::FLinearColor Window_Header{ 0.10f, 0.15f, 0.84f, 1.0f };

		ue::FLinearColor Button_Idle{ 0.10f, 0.15f, 0.84f, 1.0f };
		ue::FLinearColor Button_Hovered{ 0.15f, 0.20f, 0.89f, 1.0f };
		ue::FLinearColor Button_Active{ 0.20f, 0.25f, 0.94f, 1.0f };

		ue::FLinearColor Checkbox_Idle{ 0.17f, 0.16f, 0.23f, 1.0f };
		ue::FLinearColor Checkbox_Hovered{ 0.22f, 0.30f, 0.72f, 1.0f };
		ue::FLinearColor Checkbox_Enabled{ 0.20f, 0.25f, 0.94f, 1.0f };

		ue::FLinearColor Combobox_Idle{ 0.17f, 0.16f, 0.23f, 1.0f };
		ue::FLinearColor Combobox_Hovered{ 0.17f, 0.16f, 0.23f, 1.0f };
		ue::FLinearColor Combobox_Elements{ 0.239f, 0.42f, 0.82f, 1.0f };

		ue::FLinearColor Slider_Idle{ 0.17f, 0.16f, 0.23f, 1.0f };
		ue::FLinearColor Slider_Hovered{ 0.17f, 0.16f, 0.23f, 1.0f };
		ue::FLinearColor Slider_Progress{ 0.22f, 0.30f, 0.72f, 1.0f };
		ue::FLinearColor Slider_Button{ 0.10f, 0.15f, 0.84f, 1.0f };

		ue::FLinearColor ColorPicker_Background{ 0.006f, 0.006f, 0.006f, 1.0f };
	}

	namespace PostRenderer
	{
		struct DrawList
		{
			int type = -1; //1 = FilledRect, 2 = TextLeft, 3 = TextCenter, 4 = Draw_Line
			Vector2 pos;
			Vector2 size;
			ue::FLinearColor color;
			char* name;
			bool outline;

			Vector2 from;
			Vector2 to;
			int thickness;
		};
		DrawList drawlist[128];

		void drawFilledRect(Vector2 pos, float w, float h, ue::FLinearColor color)
		{
			for (int i = 0; i < 128; i++)
			{
				if (drawlist[i].type == -1)
				{
					drawlist[i].type = 1;
					drawlist[i].pos = pos;
					drawlist[i].size = Vector2{ w, h };
					drawlist[i].color = color;
					return;
				}
			}
		}
		void TextLeft(char* name, Vector2 pos, ue::FLinearColor color, bool outline)
		{
			for (int i = 0; i < 128; i++)
			{
				if (drawlist[i].type == -1)
				{
					drawlist[i].type = 2;
					drawlist[i].name = name;
					drawlist[i].pos = pos;
					drawlist[i].outline = outline;
					drawlist[i].color = color;
					return;
				}
			}
		}
		void TextCenter(char* name, Vector2 pos, ue::FLinearColor color, bool outline)
		{
			for (int i = 0; i < 128; i++)
			{
				if (drawlist[i].type == -1)
				{
					drawlist[i].type = 3;
					drawlist[i].name = name;
					drawlist[i].pos = pos;
					drawlist[i].outline = outline;
					drawlist[i].color = color;
					return;
				}
			}
		}
		void Draw_Line(Vector2 from, Vector2 to, int thickness, ue::FLinearColor color)
		{
			for (int i = 0; i < 128; i++)
			{
				if (drawlist[i].type == -1)
				{
					drawlist[i].type = 4;
					drawlist[i].from = from;
					drawlist[i].to = to;
					drawlist[i].thickness = thickness;
					drawlist[i].color = color;
					return;
				}
			}
		}
	}

	UCanvas* canvas;


	bool hover_element = false;
	Vector2 menu_pos = Vector2{ 0, 0 };
	float offset_x = 0.0f;
	float offset_y = 0.0f;

	Vector2 first_element_pos = Vector2{ 0, 0 };

	Vector2 last_element_pos = Vector2{ 0, 0 };
	Vector2 last_element_size = Vector2{ 0, 0 };

	int current_element = -1;
	Vector2 current_element_pos = Vector2{ 0, 0 };
	Vector2 current_element_size = Vector2{ 0, 0 };
	int elements_count = 0;

	bool sameLine = false;

	bool pushY = false;
	float pushYvalue = 0.0f;

	void SetupCanvas(UCanvas* _canvas)
	{
		canvas = _canvas;
	}

	Vector2 CursorPos()
	{
		//POINT cursorPos;
		//GetCursorPos(&cursorPos);
		float cursorPosX;
		float cursorPosY;
		PlayerController->GetMousePosition(&cursorPosX, &cursorPosY);
		return Vector2{ cursorPosX, cursorPosY };
	}
	bool MouseInZone(Vector2 pos, Vector2 size)
	{
		Vector2 cursor_pos = CursorPos();

		if (cursor_pos.x > pos.x && cursor_pos.y > pos.y)
			if (cursor_pos.x < pos.x + size.x && cursor_pos.y < pos.y + size.y)
				return true;

		return false;
	}

	void Draw_Cursor(bool toogle)
	{
		if (toogle)
		{
			Vector2 cursorPos = CursorPos();
			canvas->K2_DrawLine(Vector2{ cursorPos.x, cursorPos.y }, Vector2{ cursorPos.x + 35, cursorPos.y + 10 }, 1, ue::FLinearColor{ 0.30f, 0.30f, 0.80f, 1.0f });


			int x = 35;
			int y = 10;
			while (y != 30) //20 steps
			{
				x -= 1; if (x < 15) x = 15;
				y += 1; if (y > 30) y = 30;

				canvas->K2_DrawLine(Vector2{ cursorPos.x, cursorPos.y }, Vector2{ cursorPos.x + x, cursorPos.y + y }, 1, ue::FLinearColor{ 0.30f, 0.30f, 0.80f, 1.0f });
			}

			canvas->K2_DrawLine(Vector2{ cursorPos.x, cursorPos.y }, Vector2{ cursorPos.x + 15, cursorPos.y + 30 }, 1, ue::FLinearColor{ 0.30f, 0.30f, 0.80f, 1.0f });
			canvas->K2_DrawLine(Vector2{ cursorPos.x + 35, cursorPos.y + 10 }, Vector2{ cursorPos.x + 15, cursorPos.y + 30 }, 1, ue::FLinearColor{ 0.30f, 0.30f, 0.80f, 1.0f });
		}
	}

	void SameLine()
	{
		sameLine = true;
	}
	void PushNextElementY(float y, bool from_last_element = true)
	{
		pushY = true;
		if (from_last_element)
			pushYvalue = last_element_pos.y + last_element_size.y + y;
		else
			pushYvalue = y;
	}
	void NextColumn(float x)
	{
		offset_x = x;
		PushNextElementY(first_element_pos.y, false);
	}
	void ClearFirstPos()
	{
		first_element_pos = Vector2{ 0, 0 };
	}

	/*void TextLeft(char* name, Vector2 pos, ue::FLinearColor color, bool outline)
	{
		int length = strlen(name) + 1;
		canvas->K2_DrawText(Functions::NamesFont, ue::FString{ s2wc(name), length, length }, pos, Vector2{ 0.97f, 0.97f }, color, false, Colors::Text_Shadow, Vector2{ pos.x + 1, pos.y + 1 }, false, true, true, Colors::Text_Outline);
	}
	void TextCenter(char* name, Vector2 pos, ue::FLinearColor color, bool outline)
	{
		int length = strlen(name) + 1;
		canvas->K2_DrawText(Functions::NamesFont, ue::FString{ s2wc(name), length, length }, pos, Vector2{ 0.97f, 0.97f }, color, false, Colors::Text_Shadow, Vector2{ pos.x + 1, pos.y + 1 }, true, true, true, Colors::Text_Outline);
	}*/

	static void TextLeft(const char* name, Vector2 pos, ue::FLinearColor color, bool outline, bool big = false)
	{
		if(big)
			static_canvas->K2_DrawText(pos, color, ue::FString(s2wc(name)), false, true);
		else
			static_canvas->K2_DrawText(pos, color, ue::FString(s2wc(name)), false, true);
			
	}
	static void TextCenter(const char* name, Vector2 pos, ue::FLinearColor color, bool outline, bool big = false)
	{
		if (big)
			static_canvas->K2_DrawText(pos, color, ue::FString(s2wc(name)), true, true);
		else
			static_canvas->K2_DrawText(pos , color, ue::FString(s2wc(name)), true, true);
		}
	void GetColor(ue::FLinearColor* color, float* r, float* g, float* b, float* a)
	{
		*r = color->R;
		*g = color->G;
		*b = color->B;
		*a = color->A;
	}
	UINT32 GetColorUINT(int r, int g, int b, int a)
	{
		UINT32 result = (BYTE(a) << 24) + (BYTE(r) << 16) + (BYTE(g) << 8) + BYTE(b);
		return result;
	}

	void Draw_Line(Vector2 from, Vector2 to, int thickness, ue::FLinearColor color)
	{
		canvas->K2_DrawLine(Vector2{ from.x, from.y }, Vector2{ to.x, to.y }, thickness, color);
	}
	void drawFilledRect(Vector2 initial_pos, float w, float h, ue::FLinearColor color)
	{
		for (float i = 0.0f; i < h; i += 1.0f)
			canvas->K2_DrawLine(Vector2{ initial_pos.x, initial_pos.y + i }, Vector2{ initial_pos.x + w, initial_pos.y + i }, 1.0f, color);
	}
	void DrawFilledCircle(Vector2 pos, float r, ue::FLinearColor color)
	{
		float smooth = 0.07f;

		double PI = 3.14159265359;
		int size = (int)(2.0f * PI / smooth) + 1;

		float angle = 0.0f;
		int i = 0;

		for (; angle < 2 * PI; angle += smooth, i++)
		{
			Draw_Line(Vector2{ pos.x, pos.y }, Vector2{ pos.x + cosf(angle) * r, pos.y + sinf(angle) * r }, 1.0f, color);
		}
	}
	void DrawCircle(Vector2 pos, int radius, int numSides, ue::FLinearColor Color)
	{
		float PI = 3.1415927f;

		float Step = PI * 2.0 / numSides;
		int Count = 0;
		Vector2 V[128];
		for (float a = 0; a < PI * 2.0; a += Step) {
			float X1 = radius * cos(a) + pos.x;
			float Y1 = radius * sin(a) + pos.y;
			float X2 = radius * cos(a + Step) + pos.x;
			float Y2 = radius * sin(a + Step) + pos.y;
			V[Count].x = X1;
			V[Count].y = Y1;
			V[Count + 1].x = X2;
			V[Count + 1].y = Y2;
			//Draw_Line(Vector2{ pos.x, pos.y }, Vector2{ X2, Y2 }, 1.0f, Color); // Points from Centre to ends of circle
			Draw_Line(Vector2{ V[Count].x, V[Count].y }, Vector2{ X2, Y2 }, 1.0f, Color);// Circle Around
		}
	}

	Vector2 dragPos;
	bool Window(const char* name, Vector2* pos, Vector2 size, bool isOpen)
	{
		elements_count = 0;

		if (!isOpen)
			return false;

		bool isHovered = MouseInZone(Vector2{ pos->x, pos->y }, size);

		//Drop last element
		if (current_element != -1 && !safe_call(GetAsyncKeyState)(0x1))
		{
			current_element = -1;
		}

		//Drag
		if (hover_element && safe_call(GetAsyncKeyState)(0x1))
		{

		}
		else if ((isHovered || dragPos.x != 0) && !hover_element)
		{
			if (Input::IsMouseClicked(0, elements_count, true))
			{
				Vector2 cursorPos = CursorPos();

				cursorPos.x -= size.x;
				cursorPos.y -= size.y;

				if (dragPos.x == 0)
				{
					dragPos.x = (cursorPos.x - pos->x);
					dragPos.y = (cursorPos.y - pos->y);
				}
				pos->x = cursorPos.x - dragPos.x;
				pos->y = cursorPos.y - dragPos.y;
			}
			else
			{
				dragPos = Vector2{ 0, 0 };
			}
		}
		else
		{
			hover_element = false;
		}


		offset_x = 0.0f; offset_y = 0.0f;
		menu_pos = Vector2{ pos->x, pos->y };
		first_element_pos = Vector2{ 0, 0 };
		current_element_pos = Vector2{ 0, 0 };
		current_element_size = Vector2{ 0, 0 };

		//Bg
		drawFilledRect(Vector2{ pos->x, pos->y }, size.x, size.y, Colors::Window_Background);
		//drawFilledRect(Vector2{ pos->x, pos->y }, 122, size.y, FLinearColor{ 0.006f, 0.006f, 0.006f, 1.0f });//My tabs bg

		//Header
		drawFilledRect(Vector2{ pos->x, pos->y }, size.x, 25.0f, Colors::Window_Header);

		offset_y += 25.0f;

		//Title
		Vector2 titlePos = Vector2{ pos->x + size.x / 2, pos->y + 25 / 2 };
		TextCenter(name, titlePos, ue::FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);

		return true;
	}

	void Text(const char* text, bool center = false, bool outline = false)
	{
		elements_count++;

		float size = 25;
		Vector2 padding = Vector2{ 10, 10 };
		Vector2 pos = Vector2{ menu_pos.x + padding.x + offset_x, menu_pos.y + padding.y + offset_y };
		if (sameLine)
		{
			pos.x = last_element_pos.x + last_element_size.x + padding.x;
			pos.y = last_element_pos.y;
		}
		if (pushY)
		{
			pos.y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.y - menu_pos.y;
		}

		if (!sameLine)
			offset_y += size + padding.y;

		//Text
		Vector2 textPos = Vector2{ pos.x + 5.0f, pos.y + size / 2 };
		if (center)
			TextCenter(text, textPos, ue::FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, outline);
		else
			TextLeft(text, textPos, ue::FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, outline);

		sameLine = false;
		last_element_pos = pos;
		//last_element_size = size;
		if (first_element_pos.x == 0.0f)
			first_element_pos = pos;
	}
	bool ButtonTab(const char* name, Vector2 size, bool active)
	{
		elements_count++;

		Vector2 padding = Vector2{ 5, 10 };
		Vector2 pos = Vector2{ menu_pos.x + padding.x + offset_x, menu_pos.y + padding.y + offset_y };
		if (sameLine)
		{
			pos.x = last_element_pos.x + last_element_size.x + padding.x;
			pos.y = last_element_pos.y;
		}
		if (pushY)
		{
			pos.y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.y - menu_pos.y;
		}
		bool isHovered = MouseInZone(Vector2{ pos.x, pos.y }, size);

		//Bg
		if (active)
		{
			drawFilledRect(Vector2{ pos.x, pos.y }, size.x, size.y, Colors::Button_Active);
		}
		else if (isHovered)
		{
			drawFilledRect(Vector2{ pos.x, pos.y }, size.x, size.y, Colors::Button_Hovered);
			hover_element = true;
		}
		else
		{
			drawFilledRect(Vector2{ pos.x, pos.y }, size.x, size.y, Colors::Button_Idle);
		}

		if (!sameLine)
			offset_y += size.y + padding.y;

		//Text
		Vector2 textPos = Vector2{ pos.x + size.x / 2, pos.y + size.y / 2 };
		TextCenter(name, textPos, ue::FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);


		sameLine = false;
		last_element_pos = pos;
		last_element_size = size;
		if (first_element_pos.x == 0.0f)
			first_element_pos = pos;

		if (isHovered && Input::IsMouseClicked(0, elements_count, false))
			return true;

		return false;
	}
	bool Button(const char* name, Vector2 size)
	{
		elements_count++;

		Vector2 padding = Vector2{ 5, 10 };
		Vector2 pos = Vector2{ menu_pos.x + padding.x + offset_x, menu_pos.y + padding.y + offset_y };
		if (sameLine)
		{
			pos.x = last_element_pos.x + last_element_size.x + padding.x;
			pos.y = last_element_pos.y;
		}
		if (pushY)
		{
			pos.y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.y - menu_pos.y;
		}
		bool isHovered = MouseInZone(Vector2{ pos.x, pos.y }, size);

		//Bg
		if (isHovered)
		{
			drawFilledRect(Vector2{ pos.x, pos.y }, size.x, size.y, Colors::Button_Hovered);
			hover_element = true;
		}
		else
		{
			drawFilledRect(Vector2{ pos.x, pos.y }, size.x, size.y, Colors::Button_Idle);
		}

		if (!sameLine)
			offset_y += size.y + padding.y;

		//Text
		Vector2 textPos = Vector2{ pos.x + size.x / 2, pos.y + size.y / 2 };
		//if (!TextOverlapedFromActiveElement(textPos))
		TextCenter(name, textPos, ue::FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);


		sameLine = false;
		last_element_pos = pos;
		last_element_size = size;
		if (first_element_pos.x == 0.0f)
			first_element_pos = pos;

		if (isHovered && Input::IsMouseClicked(0, elements_count, false))
			return true;

		return false;
	}
	void Checkbox(const char* name, bool* value)
	{
		elements_count++;

		float size = 18;
		Vector2 padding = Vector2{ 10, 10 };
		Vector2 pos = Vector2{ menu_pos.x + padding.x + offset_x, menu_pos.y + padding.y + offset_y };
		if (sameLine)
		{
			pos.x = last_element_pos.x + last_element_size.x + padding.x;
			pos.y = last_element_pos.y;
		}
		if (pushY)
		{
			pos.y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.y - menu_pos.y;
		}
		bool isHovered = MouseInZone(Vector2{ pos.x, pos.y }, Vector2{ size, size });

		//Bg
		if (isHovered)
		{
			drawFilledRect(Vector2{ pos.x, pos.y }, size, size, Colors::Checkbox_Hovered);
			hover_element = true;
		}
		else
		{
			drawFilledRect(Vector2{ pos.x, pos.y }, size, size, Colors::Checkbox_Idle);
		}

		if (!sameLine)
			offset_y += size + padding.y;

		if (*value)
		{
			drawFilledRect(Vector2{ pos.x + 3, pos.y + 3 }, size - 6, size - 6, Colors::Checkbox_Enabled);
			//drawFilledRect(Vector2{ pos.x + 9, pos.y + 9 }, size - 18, size - 18, Colors::Checkbox_Hovered);
		}



		//Text
		Vector2 textPos = Vector2{ pos.x + size + 10, (pos.y + size / 2) - 7};
		//if (!TextOverlapedFromActiveElement(textPos))
		TextLeft(name, textPos, ue::FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);


		sameLine = false;
		last_element_pos = pos;
		//last_element_size = size;
		if (first_element_pos.x == 0.0f)
			first_element_pos = pos;

		if (isHovered && Input::IsMouseClicked(0, elements_count, false))
			*value = !*value;
	}
	void SliderInt(char* name, int* value, int min, int max)
	{
		elements_count++;

		Vector2 size = Vector2{ 240, 50 };
		Vector2 slider_size = Vector2{ 200, 10 };
		Vector2 padding = Vector2{ 10, 15 };
		Vector2 pos = Vector2{ menu_pos.x + padding.x + offset_x, menu_pos.y + padding.y + offset_y };
		if (sameLine)
		{
			pos.x = last_element_pos.x + last_element_size.x + padding.x;
			pos.y = last_element_pos.y;
		}
		if (pushY)
		{
			pos.y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.y - menu_pos.y;
		}
		bool isHovered = MouseInZone(Vector2{ pos.x, pos.y + slider_size.y + padding.y }, slider_size);

		if (!sameLine)
			offset_y += size.y + padding.y;

		//Bg
		if (isHovered || current_element == elements_count)
		{
			//Drag
			if (Input::IsMouseClicked(0, elements_count, true))
			{
				current_element = elements_count;

				Vector2 cursorPos = CursorPos();
				*value = ((cursorPos.x - pos.x) * ((max - min) / slider_size.x)) + min;
				if (*value < min) *value = min;
				if (*value > max) *value = max;
			}

			drawFilledRect(Vector2{ pos.x, pos.y + slider_size.y + padding.y }, slider_size.x, slider_size.y, Colors::Slider_Hovered);
			drawFilledRect(Vector2{ pos.x, pos.y + slider_size.y + padding.y + 5.0f }, 5.0f, 5.0f, Colors::Slider_Progress);

			hover_element = true;
		}
		else
		{
			drawFilledRect(Vector2{ pos.x, pos.y + slider_size.y + padding.y }, slider_size.x, slider_size.y, Colors::Slider_Idle);
			drawFilledRect(Vector2{ pos.x, pos.y + slider_size.y + padding.y + 5.0f }, 5.0f, 5.0f, Colors::Slider_Progress);
		}


		//Value
		float oneP = slider_size.x / (max - min);
		drawFilledRect(Vector2{ pos.x, pos.y + slider_size.y + padding.y }, oneP * (*value - min), slider_size.y, Colors::Slider_Progress);
		//drawFilledRect(Vector2{ pos.x + oneP * (*value - min) - 10.0f, pos.y + slider_size.y - 5.0f + padding.y }, 20.0f, 20.0f, Colors::Slider_Button);
		DrawFilledCircle(Vector2{ pos.x + oneP * (*value - min), pos.y + slider_size.y + 3.3f + padding.y }, 10.0f, Colors::Slider_Button);
		DrawFilledCircle(Vector2{ pos.x + oneP * (*value - min), pos.y + slider_size.y + 3.3f + padding.y }, 5.0f, Colors::Slider_Progress);

		char buffer[32];
		sprintf_s(buffer, "%i", *value);
		Vector2 valuePos = Vector2{ pos.x + oneP * (*value - min), pos.y + slider_size.y + 25 + padding.y };
		TextCenter(buffer, valuePos, ue::FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);

		//Text
		Vector2 textPos = Vector2{ pos.x + 5, pos.y + 10 };
		TextLeft(name, textPos, ue::FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);


		sameLine = false;
		last_element_pos = pos;
		last_element_size = size;
		if (first_element_pos.x == 0.0f)
			first_element_pos = pos;
	}
	void SliderFloat(const char* name, float* value, float min, float max, const char* format = "%.0f")
	{
		elements_count++;

		Vector2 size = Vector2{ 210, 40 };
		Vector2 slider_size = Vector2{ 170, 7 };
		Vector2 adjust_zone = Vector2{ 0, 20 };
		Vector2 padding = Vector2{ 10, 15 };
		Vector2 pos = Vector2{ menu_pos.x + padding.x + offset_x, menu_pos.y + padding.y + offset_y };
		if (sameLine)
		{
			pos.x = last_element_pos.x + last_element_size.x + padding.x;
			pos.y = last_element_pos.y;
		}
		if (pushY)
		{
			pos.y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.y - menu_pos.y;
		}
		bool isHovered = MouseInZone(Vector2{ pos.x, pos.y + slider_size.y + padding.y - adjust_zone.y }, Vector2{ slider_size.x, slider_size.y + adjust_zone.y * 1.5f });

		if (!sameLine)
			offset_y += size.y + padding.y;

		//Bg
		if (isHovered || current_element == elements_count)
		{
			//Drag
			if (Input::IsMouseClicked(0, elements_count, true))
			{
				current_element = elements_count;

				Vector2 cursorPos = CursorPos();
				*value = ((cursorPos.x - pos.x) * ((max - min) / slider_size.x)) + min;
				if (*value < min) *value = min;
				if (*value > max) *value = max;
			}

			drawFilledRect(Vector2{ pos.x, pos.y + slider_size.y + padding.y }, slider_size.x, slider_size.y, Colors::Slider_Hovered);
			DrawFilledCircle(Vector2{ pos.x, pos.y + padding.y + 9.3f }, 3.1f, Colors::Slider_Progress);
			DrawFilledCircle(Vector2{ pos.x + slider_size.x, pos.y + padding.y + 9.3f }, 3.1f, Colors::Slider_Hovered);

			hover_element = true;
		}
		else
		{
			drawFilledRect(Vector2{ pos.x, pos.y + slider_size.y + padding.y }, slider_size.x, slider_size.y, Colors::Slider_Idle);
			DrawFilledCircle(Vector2{ pos.x, pos.y + padding.y + 9.3f }, 3.1f, Colors::Slider_Progress);
			DrawFilledCircle(Vector2{ pos.x + slider_size.x, pos.y + padding.y + 9.3f }, 3.1f, Colors::Slider_Idle);
		}


		//Text
		Vector2 textPos = Vector2{ pos.x, pos.y  };
		TextLeft(name, textPos, Colors::Text, false);

		//Value
		float oneP = slider_size.x / (max - min);
		drawFilledRect(Vector2{ pos.x, pos.y + slider_size.y + padding.y }, oneP * (*value - min), slider_size.y, Colors::Slider_Progress);
		DrawFilledCircle(Vector2{ pos.x + oneP * (*value - min), pos.y + slider_size.y + 2.66f + padding.y }, 8.0f, Colors::Slider_Button);
		DrawFilledCircle(Vector2{ pos.x + oneP * (*value - min), pos.y + slider_size.y + 2.66f + padding.y }, 4.0f, Colors::Slider_Progress);

		char buffer[32];
		sprintf_s(buffer, format, *value);
		Vector2 valuePos = Vector2{ pos.x + oneP * (*value - min), pos.y + slider_size.y + 20 + padding.y };
		TextCenter(buffer, valuePos, Colors::Text, false);


		sameLine = false;
		last_element_pos = pos;
		last_element_size = size;
		if (first_element_pos.x == 0.0f)
			first_element_pos = pos;
	}



	bool checkbox_enabled[256];
	void Combobox(const char* name, Vector2 size, int* value, const char* arg, ...)
	{
		elements_count++;

		Vector2 padding = Vector2{ 5, 10 };
		Vector2 pos = Vector2{ menu_pos.x + padding.x + offset_x, menu_pos.y + padding.y + offset_y };
		if (sameLine)
		{
			pos.x = last_element_pos.x + last_element_size.x + padding.x;
			pos.y = last_element_pos.y;
		}
		if (pushY)
		{
			pos.y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.y - menu_pos.y;
		}
		bool isHovered = MouseInZone(Vector2{ pos.x, pos.y }, size);

		//Bg
		if (isHovered || checkbox_enabled[elements_count])
		{
			drawFilledRect(Vector2{ pos.x, pos.y }, size.x, size.y, Colors::Combobox_Hovered);

			hover_element = true;
		}
		else
		{
			drawFilledRect(Vector2{ pos.x, pos.y }, size.x, size.y, Colors::Combobox_Idle);
		}

		if (!sameLine)
			offset_y += size.y + padding.y;

		//Text
		Vector2 textPos = Vector2{ pos.x + size.x + 5.0f, pos.y + size.y / 2 };
		TextLeft(name, textPos, ue::FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);

		//Elements
		bool isHovered2 = false;
		Vector2 element_pos = pos;
		int num = 0;

		if (checkbox_enabled[elements_count])
		{
			current_element_size.x = element_pos.x - 5.0f;
			current_element_size.y = element_pos.y - 5.0f;
		}
		va_list arguments;
		for (va_start(arguments, arg); arg != NULL; arg = va_arg(arguments, const char*))
		{
			//Selected Element
			if (num == *value)
			{
				Vector2 _textPos = Vector2{ pos.x + size.x / 2, pos.y + size.y / 2 };
				TextCenter((char*)arg, _textPos, ue::FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);
			}

			if (checkbox_enabled[elements_count])
			{
				element_pos.y += 25.0f;

				isHovered2 = MouseInZone(Vector2{ element_pos.x, element_pos.y }, Vector2{ size.x, 25.0f });
				if (isHovered2)
				{
					hover_element = true;
					PostRenderer::drawFilledRect(Vector2{ element_pos.x, element_pos.y }, size.x, 25.0f, Colors::Combobox_Hovered);

					//Click
					if (Input::IsMouseClicked(0, elements_count, false))
					{
						*value = num;
						checkbox_enabled[elements_count] = false;
					}
				}
				else
				{
					PostRenderer::drawFilledRect(Vector2{ element_pos.x, element_pos.y }, size.x, 25.0f, Colors::Combobox_Idle);
				}

				PostRenderer::TextLeft((char*)arg, Vector2{ element_pos.x + 5.0f, element_pos.y + 10.0f }, ue::FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);
			}
			num++;
		}
		va_end(arguments);
		if (checkbox_enabled[elements_count])
		{
			current_element_size.x = element_pos.x + 5.0f;
			current_element_size.y = element_pos.y + 5.0f;
		}


		sameLine = false;
		last_element_pos = pos;
		last_element_size = size;
		if (first_element_pos.x == 0.0f)
			first_element_pos = pos;

		if (isHovered && Input::IsMouseClicked(0, elements_count, false))
		{
			checkbox_enabled[elements_count] = !checkbox_enabled[elements_count];
		}
		if (!isHovered && !isHovered2 && Input::IsMouseClicked(0, elements_count, false))
		{
			checkbox_enabled[elements_count] = false;
		}
	}

	int active_hotkey = -1;
	bool already_pressed = false;
	std::string VirtualKeyCodeToString(UCHAR virtualKey)
	{
		UINT scanCode = MapVirtualKey(virtualKey, MAPVK_VK_TO_VSC);

		if (virtualKey == VK_LBUTTON)
		{
			return xorstr("MOUSE0");
		}
		if (virtualKey == VK_RBUTTON)
		{
			return xorstr("MOUSE1");
		}
		if (virtualKey == VK_MBUTTON)
		{
			return xorstr("MBUTTON");
		}
		if (virtualKey == VK_XBUTTON1)
		{
			return xorstr("XBUTTON1");
		}
		if (virtualKey == VK_XBUTTON2)
		{
			return xorstr("XBUTTON2");
		}

		CHAR szName[128];
		int result = 0;
		switch (virtualKey)
		{
		case VK_LEFT: case VK_UP: case VK_RIGHT: case VK_DOWN:
		case VK_RCONTROL: case VK_RMENU:
		case VK_LWIN: case VK_RWIN: case VK_APPS:
		case VK_PRIOR: case VK_NEXT:
		case VK_END: case VK_HOME:
		case VK_INSERT: case VK_DELETE:
		case VK_DIVIDE:
		case VK_NUMLOCK:
			scanCode |= KF_EXTENDED;
		default:
			result = GetKeyNameTextA(scanCode << 16, szName, 128);
		}

		return szName;
	}
	void Hotkey(const char* name, Vector2 size, int* key)
	{
		elements_count++;

		Vector2 padding = Vector2{ 5, 10 };
		Vector2 pos = Vector2{ menu_pos.x + padding.x + offset_x, menu_pos.y + padding.y + offset_y };
		if (sameLine)
		{
			pos.x = last_element_pos.x + last_element_size.x + padding.x;
			pos.y = last_element_pos.y + (last_element_size.y / 2) - size.y / 2;
		}
		if (pushY)
		{
			pos.y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.y - menu_pos.y;
		}
		bool isHovered = MouseInZone(Vector2{ pos.x, pos.y }, size);

		//Bg
		if (isHovered)
		{
			drawFilledRect(Vector2{ pos.x, pos.y }, size.x, size.y, Colors::Button_Hovered);
			hover_element = true;
		}
		else
		{
			drawFilledRect(Vector2{ pos.x, pos.y }, size.x, size.y, Colors::Button_Idle);
		}

		if (!sameLine)
			offset_y += size.y + padding.y;

		if (active_hotkey == elements_count)
		{
			//Text
			Vector2 textPos = Vector2{ pos.x + size.x / 2, pos.y + size.y / 2 };
			TextCenter(xorstr("[Press Key]"), textPos, ue::FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);

			if (!ZeroGUI::Input::IsAnyMouseDown())
			{
				already_pressed = false;
			}

			if (!already_pressed)
			{
				for (int code = 0; code < 255; code++)
				{
					if (safe_call(GetAsyncKeyState)(code))
					{
						*key = code;
						active_hotkey = -1;
					}
				}
			}
		}
		else
		{
			//Text
			Vector2 textPos = Vector2{ pos.x + size.x / 2, pos.y + size.y / 2 };
			TextCenter((char*)VirtualKeyCodeToString(*key).c_str(), textPos, ue::FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);

			if (isHovered)
			{
				if (Input::IsMouseClicked(0, elements_count, false))
				{
					already_pressed = true;
					active_hotkey = elements_count;

					//Queue Fix
					for (int code = 0; code < 255; code++)
						if (safe_call(GetAsyncKeyState)(code)) {}
				}
			}
			else
			{
				if (Input::IsMouseClicked(0, elements_count, false))
				{
					active_hotkey = -1;
				}
			}
		}


		sameLine = false;
		last_element_pos = pos;
		last_element_size = size;
		if (first_element_pos.x == 0.0f)
			first_element_pos = pos;
	}

	int active_picker = -1;
	ue::FLinearColor saved_color;
	bool ColorPixel(Vector2 pos, Vector2 size, ue::FLinearColor* original, ue::FLinearColor color)
	{
		PostRenderer::drawFilledRect(Vector2{ pos.x, pos.y }, size.x, size.y, color);

		//Выбранный цвет
		if (original->R == color.R && original->G == color.G && original->B == color.B)
		{
			PostRenderer::Draw_Line(Vector2{ pos.x, pos.y }, Vector2{ pos.x + size.x - 1, pos.y }, 1.0f, ue::FLinearColor{ 0.0f, 0.0f, 0.0f, 1.0f });
			PostRenderer::Draw_Line(Vector2{ pos.x, pos.y + size.y - 1 }, Vector2{ pos.x + size.x - 1, pos.y + size.y - 1 }, 1.0f, ue::FLinearColor{ 0.0f, 0.0f, 0.0f, 1.0f });
			PostRenderer::Draw_Line(Vector2{ pos.x, pos.y }, Vector2{ pos.x, pos.y + size.y - 1 }, 1.0f, ue::FLinearColor{ 0.0f, 0.0f, 0.0f, 1.0f });
			PostRenderer::Draw_Line(Vector2{ pos.x + size.x - 1, pos.y }, Vector2{ pos.x + size.x - 1, pos.y + size.y - 1 }, 1.0f, ue::FLinearColor{ 0.0f, 0.0f, 0.0f, 1.0f });
		}

		//Смена цвета
		bool isHovered = MouseInZone(Vector2{ pos.x, pos.y }, size);
		if (isHovered)
		{
			if (Input::IsMouseClicked(0, elements_count, false))
				*original = color;
		}

		return true;
	}
	void ColorPicker(const char* name, ue::FLinearColor* color)
	{
		elements_count++;

		float size = 25;
		Vector2 padding = Vector2{ 10, 10 };
		Vector2 pos = Vector2{ menu_pos.x + padding.x + offset_x, menu_pos.y + padding.y + offset_y };
		if (sameLine)
		{
			pos.x = last_element_pos.x + last_element_size.x + padding.x;
			pos.y = last_element_pos.y;
		}
		if (pushY)
		{
			pos.y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.y - menu_pos.y;
		}
		bool isHovered = MouseInZone(Vector2{ pos.x, pos.y }, Vector2{ size, size });

		if (!sameLine)
			offset_y += size + padding.y;

		if (active_picker == elements_count)
		{
			hover_element = true;

			float sizePickerX = 250;
			float sizePickerY = 250;
			bool isHoveredPicker = MouseInZone(Vector2{ pos.x, pos.y }, Vector2{ sizePickerX, sizePickerY - 60 });

			//Background
			PostRenderer::drawFilledRect(Vector2{ pos.x, pos.y }, sizePickerX, sizePickerY - 65, Colors::ColorPicker_Background);

			//float pixedSize = sizePickerY / pixels;
			//FLinearColor temp_color{1.0f, 1.0f, 1.0f, 1.0f};
			//float iterator = 0.0f;
			//
			//for (int y = 0; y < pixels; y++)
			//{
			//	for (int x = 0; x < pixels; x++)
			//	{
			//		ColorPixel(Vector2{ pos.x + pixedSize * x, pos.y + pixedSize * y }, pixedSize, color, temp_color);
			//		temp_color.R -= (1.0f - saved_color.R) / pixels;
			//		temp_color.G -= (1.0f - saved_color.G) / pixels;
			//		temp_color.B -= (1.0f - saved_color.B) / pixels;
			//	}
			//	
			//	iterator += 1.0f / pixels;
			//	temp_color = FLinearColor{ 1.0f - iterator, 1.0f - iterator, 1.0f - iterator, 1.0f };
			//}

			Vector2 pixelSize = Vector2{ sizePickerX / 12, sizePickerY / 12 };

			//0
			{
				ColorPixel(Vector2{ pos.x + pixelSize.x * 0, pos.y + pixelSize.y * 0 }, pixelSize, color, ue::FLinearColor{ 174 / 255.f, 235 / 255.f, 253 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 0, pos.y + pixelSize.y * 1 }, pixelSize, color, ue::FLinearColor{ 136 / 255.f, 225 / 255.f, 251 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 0, pos.y + pixelSize.y * 2 }, pixelSize, color, ue::FLinearColor{ 108 / 255.f, 213 / 255.f, 250 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 0, pos.y + pixelSize.y * 3 }, pixelSize, color, ue::FLinearColor{ 89 / 255.f, 175 / 255.f, 213 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 0, pos.y + pixelSize.y * 4 }, pixelSize, color, ue::FLinearColor{ 76 / 255.f, 151 / 255.f, 177 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 0, pos.y + pixelSize.y * 5 }, pixelSize, color, ue::FLinearColor{ 60 / 255.f, 118 / 255.f, 140 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 0, pos.y + pixelSize.y * 6 }, pixelSize, color, ue::FLinearColor{ 43 / 255.f, 85 / 255.f, 100 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 0, pos.y + pixelSize.y * 7 }, pixelSize, color, ue::FLinearColor{ 32 / 255.f, 62 / 255.f, 74 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 0, pos.y + pixelSize.y * 8 }, pixelSize, color, ue::FLinearColor{ 255 / 255.f, 255 / 255.f, 255 / 255.f, 1.0f });
			}
			//1
			{
				ColorPixel(Vector2{ pos.x + pixelSize.x * 1, pos.y + pixelSize.y * 0 }, pixelSize, color, ue::FLinearColor{ 175 / 255.f, 205 / 255.f, 252 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 1, pos.y + pixelSize.y * 1 }, pixelSize, color, ue::FLinearColor{ 132 / 255.f, 179 / 255.f, 252 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 1, pos.y + pixelSize.y * 2 }, pixelSize, color, ue::FLinearColor{ 90 / 255.f, 152 / 255.f, 250 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 1, pos.y + pixelSize.y * 3 }, pixelSize, color, ue::FLinearColor{ 55 / 255.f, 120 / 255.f, 250 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 1, pos.y + pixelSize.y * 4 }, pixelSize, color, ue::FLinearColor{ 49 / 255.f, 105 / 255.f, 209 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 1, pos.y + pixelSize.y * 5 }, pixelSize, color, ue::FLinearColor{ 38 / 255.f, 83 / 255.f, 165 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 1, pos.y + pixelSize.y * 6 }, pixelSize, color, ue::FLinearColor{ 28 / 255.f, 61 / 255.f, 120 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 1, pos.y + pixelSize.y * 7 }, pixelSize, color, ue::FLinearColor{ 20 / 255.f, 43 / 255.f, 86 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 1, pos.y + pixelSize.y * 8 }, pixelSize, color, ue::FLinearColor{ 247 / 255.f, 247 / 255.f, 247 / 255.f, 1.0f });
			}
			//2
			{
				ColorPixel(Vector2{ pos.x + pixelSize.x * 2, pos.y + pixelSize.y * 0 }, pixelSize, color, ue::FLinearColor{ 153 / 255.f, 139 / 255.f, 250 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 2, pos.y + pixelSize.y * 1 }, pixelSize, color, ue::FLinearColor{ 101 / 255.f, 79 / 255.f, 249 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 2, pos.y + pixelSize.y * 2 }, pixelSize, color, ue::FLinearColor{ 64 / 255.f, 50 / 255.f, 230 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 2, pos.y + pixelSize.y * 3 }, pixelSize, color, ue::FLinearColor{ 54 / 255.f, 38 / 255.f, 175 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 2, pos.y + pixelSize.y * 4 }, pixelSize, color, ue::FLinearColor{ 39 / 255.f, 31 / 255.f, 144 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 2, pos.y + pixelSize.y * 5 }, pixelSize, color, ue::FLinearColor{ 32 / 255.f, 25 / 255.f, 116 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 2, pos.y + pixelSize.y * 6 }, pixelSize, color, ue::FLinearColor{ 21 / 255.f, 18 / 255.f, 82 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 2, pos.y + pixelSize.y * 7 }, pixelSize, color, ue::FLinearColor{ 16 / 255.f, 13 / 255.f, 61 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 2, pos.y + pixelSize.y * 8 }, pixelSize, color, ue::FLinearColor{ 228 / 255.f, 228 / 255.f, 228 / 255.f, 1.0f });
			}
			//3
			{
				ColorPixel(Vector2{ pos.x + pixelSize.x * 3, pos.y + pixelSize.y * 0 }, pixelSize, color, ue::FLinearColor{ 194 / 255.f, 144 / 255.f, 251 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 3, pos.y + pixelSize.y * 1 }, pixelSize, color, ue::FLinearColor{ 165 / 255.f, 87 / 255.f, 249 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 3, pos.y + pixelSize.y * 2 }, pixelSize, color, ue::FLinearColor{ 142 / 255.f, 57 / 255.f, 239 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 3, pos.y + pixelSize.y * 3 }, pixelSize, color, ue::FLinearColor{ 116 / 255.f, 45 / 255.f, 184 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 3, pos.y + pixelSize.y * 4 }, pixelSize, color, ue::FLinearColor{ 92 / 255.f, 37 / 255.f, 154 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 3, pos.y + pixelSize.y * 5 }, pixelSize, color, ue::FLinearColor{ 73 / 255.f, 29 / 255.f, 121 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 3, pos.y + pixelSize.y * 6 }, pixelSize, color, ue::FLinearColor{ 53 / 255.f, 21 / 255.f, 88 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 3, pos.y + pixelSize.y * 7 }, pixelSize, color, ue::FLinearColor{ 37 / 255.f, 15 / 255.f, 63 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 3, pos.y + pixelSize.y * 8 }, pixelSize, color, ue::FLinearColor{ 203 / 255.f, 203 / 255.f, 203 / 255.f, 1.0f });
			}
			//4
			{
				ColorPixel(Vector2{ pos.x + pixelSize.x * 4, pos.y + pixelSize.y * 0 }, pixelSize, color, ue::FLinearColor{ 224 / 255.f, 162 / 255.f, 197 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 4, pos.y + pixelSize.y * 1 }, pixelSize, color, ue::FLinearColor{ 210 / 255.f, 112 / 255.f, 166 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 4, pos.y + pixelSize.y * 2 }, pixelSize, color, ue::FLinearColor{ 199 / 255.f, 62 / 255.f, 135 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 4, pos.y + pixelSize.y * 3 }, pixelSize, color, ue::FLinearColor{ 159 / 255.f, 49 / 255.f, 105 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 4, pos.y + pixelSize.y * 4 }, pixelSize, color, ue::FLinearColor{ 132 / 255.f, 41 / 255.f, 89 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 4, pos.y + pixelSize.y * 5 }, pixelSize, color, ue::FLinearColor{ 104 / 255.f, 32 / 255.f, 71 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 4, pos.y + pixelSize.y * 6 }, pixelSize, color, ue::FLinearColor{ 75 / 255.f, 24 / 255.f, 51 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 4, pos.y + pixelSize.y * 7 }, pixelSize, color, ue::FLinearColor{ 54 / 255.f, 14 / 255.f, 36 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 4, pos.y + pixelSize.y * 8 }, pixelSize, color, ue::FLinearColor{ 175 / 255.f, 175 / 255.f, 175 / 255.f, 1.0f });
			}
			//5
			{
				ColorPixel(Vector2{ pos.x + pixelSize.x * 5, pos.y + pixelSize.y * 0 }, pixelSize, color, ue::FLinearColor{ 235 / 255.f, 175 / 255.f, 176 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 5, pos.y + pixelSize.y * 1 }, pixelSize, color, ue::FLinearColor{ 227 / 255.f, 133 / 255.f, 135 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 5, pos.y + pixelSize.y * 2 }, pixelSize, color, ue::FLinearColor{ 219 / 255.f, 87 / 255.f, 88 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 5, pos.y + pixelSize.y * 3 }, pixelSize, color, ue::FLinearColor{ 215 / 255.f, 50 / 255.f, 36 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 5, pos.y + pixelSize.y * 4 }, pixelSize, color, ue::FLinearColor{ 187 / 255.f, 25 / 255.f, 7 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 5, pos.y + pixelSize.y * 5 }, pixelSize, color, ue::FLinearColor{ 149 / 255.f, 20 / 255.f, 6 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 5, pos.y + pixelSize.y * 6 }, pixelSize, color, ue::FLinearColor{ 107 / 255.f, 14 / 255.f, 4 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 5, pos.y + pixelSize.y * 7 }, pixelSize, color, ue::FLinearColor{ 77 / 255.f, 9 / 255.f, 3 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 5, pos.y + pixelSize.y * 8 }, pixelSize, color, ue::FLinearColor{ 144 / 255.f, 144 / 255.f, 144 / 255.f, 1.0f });
			}
			//6
			{
				ColorPixel(Vector2{ pos.x + pixelSize.x * 6, pos.y + pixelSize.y * 0 }, pixelSize, color, ue::FLinearColor{ 241 / 255.f, 187 / 255.f, 171 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 6, pos.y + pixelSize.y * 1 }, pixelSize, color, ue::FLinearColor{ 234 / 255.f, 151 / 255.f, 126 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 6, pos.y + pixelSize.y * 2 }, pixelSize, color, ue::FLinearColor{ 229 / 255.f, 115 / 255.f, 76 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 6, pos.y + pixelSize.y * 3 }, pixelSize, color, ue::FLinearColor{ 227 / 255.f, 82 / 255.f, 24 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 6, pos.y + pixelSize.y * 4 }, pixelSize, color, ue::FLinearColor{ 190 / 255.f, 61 / 255.f, 15 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 6, pos.y + pixelSize.y * 5 }, pixelSize, color, ue::FLinearColor{ 150 / 255.f, 48 / 255.f, 12 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 6, pos.y + pixelSize.y * 6 }, pixelSize, color, ue::FLinearColor{ 107 / 255.f, 34 / 255.f, 8 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 6, pos.y + pixelSize.y * 7 }, pixelSize, color, ue::FLinearColor{ 79 / 255.f, 25 / 255.f, 6 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 6, pos.y + pixelSize.y * 8 }, pixelSize, color, ue::FLinearColor{ 113 / 255.f, 113 / 255.f, 113 / 255.f, 1.0f });
			}
			//7
			{
				ColorPixel(Vector2{ pos.x + pixelSize.x * 7, pos.y + pixelSize.y * 0 }, pixelSize, color, ue::FLinearColor{ 245 / 255.f, 207 / 255.f, 169 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 7, pos.y + pixelSize.y * 1 }, pixelSize, color, ue::FLinearColor{ 240 / 255.f, 183 / 255.f, 122 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 7, pos.y + pixelSize.y * 2 }, pixelSize, color, ue::FLinearColor{ 236 / 255.f, 159 / 255.f, 74 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 7, pos.y + pixelSize.y * 3 }, pixelSize, color, ue::FLinearColor{ 234 / 255.f, 146 / 255.f, 37 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 7, pos.y + pixelSize.y * 4 }, pixelSize, color, ue::FLinearColor{ 193 / 255.f, 111 / 255.f, 28 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 7, pos.y + pixelSize.y * 5 }, pixelSize, color, ue::FLinearColor{ 152 / 255.f, 89 / 255.f, 22 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 7, pos.y + pixelSize.y * 6 }, pixelSize, color, ue::FLinearColor{ 110 / 255.f, 64 / 255.f, 16 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 7, pos.y + pixelSize.y * 7 }, pixelSize, color, ue::FLinearColor{ 80 / 255.f, 47 / 255.f, 12 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 7, pos.y + pixelSize.y * 8 }, pixelSize, color, ue::FLinearColor{ 82 / 255.f, 82 / 255.f, 82 / 255.f, 1.0f });
			}
			//8
			{
				ColorPixel(Vector2{ pos.x + pixelSize.x * 8, pos.y + pixelSize.y * 0 }, pixelSize, color, ue::FLinearColor{ 247 / 255.f, 218 / 255.f, 170 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 8, pos.y + pixelSize.y * 1 }, pixelSize, color, ue::FLinearColor{ 244 / 255.f, 200 / 255.f, 124 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 8, pos.y + pixelSize.y * 2 }, pixelSize, color, ue::FLinearColor{ 241 / 255.f, 182 / 255.f, 77 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 8, pos.y + pixelSize.y * 3 }, pixelSize, color, ue::FLinearColor{ 239 / 255.f, 174 / 255.f, 44 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 8, pos.y + pixelSize.y * 4 }, pixelSize, color, ue::FLinearColor{ 196 / 255.f, 137 / 255.f, 34 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 8, pos.y + pixelSize.y * 5 }, pixelSize, color, ue::FLinearColor{ 154 / 255.f, 108 / 255.f, 27 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 8, pos.y + pixelSize.y * 6 }, pixelSize, color, ue::FLinearColor{ 111 / 255.f, 77 / 255.f, 19 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 8, pos.y + pixelSize.y * 7 }, pixelSize, color, ue::FLinearColor{ 80 / 255.f, 56 / 255.f, 14 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 8, pos.y + pixelSize.y * 8 }, pixelSize, color, ue::FLinearColor{ 54 / 255.f, 54 / 255.f, 54 / 255.f, 1.0f });
			}
			//9
			{
				ColorPixel(Vector2{ pos.x + pixelSize.x * 9, pos.y + pixelSize.y * 0 }, pixelSize, color, ue::FLinearColor{ 254 / 255.f, 243 / 255.f, 187 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 9, pos.y + pixelSize.y * 1 }, pixelSize, color, ue::FLinearColor{ 253 / 255.f, 237 / 255.f, 153 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 9, pos.y + pixelSize.y * 2 }, pixelSize, color, ue::FLinearColor{ 253 / 255.f, 231 / 255.f, 117 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 9, pos.y + pixelSize.y * 3 }, pixelSize, color, ue::FLinearColor{ 254 / 255.f, 232 / 255.f, 85 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 9, pos.y + pixelSize.y * 4 }, pixelSize, color, ue::FLinearColor{ 242 / 255.f, 212 / 255.f, 53 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 9, pos.y + pixelSize.y * 5 }, pixelSize, color, ue::FLinearColor{ 192 / 255.f, 169 / 255.f, 42 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 9, pos.y + pixelSize.y * 6 }, pixelSize, color, ue::FLinearColor{ 138 / 255.f, 120 / 255.f, 30 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 9, pos.y + pixelSize.y * 7 }, pixelSize, color, ue::FLinearColor{ 101 / 255.f, 87 / 255.f, 22 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 9, pos.y + pixelSize.y * 8 }, pixelSize, color, ue::FLinearColor{ 29 / 255.f, 29 / 255.f, 29 / 255.f, 1.0f });
			}
			//10
			{
				ColorPixel(Vector2{ pos.x + pixelSize.x * 10, pos.y + pixelSize.y * 0 }, pixelSize, color, ue::FLinearColor{ 247 / 255.f, 243 / 255.f, 185 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 10, pos.y + pixelSize.y * 1 }, pixelSize, color, ue::FLinearColor{ 243 / 255.f, 239 / 255.f, 148 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 10, pos.y + pixelSize.y * 2 }, pixelSize, color, ue::FLinearColor{ 239 / 255.f, 232 / 255.f, 111 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 10, pos.y + pixelSize.y * 3 }, pixelSize, color, ue::FLinearColor{ 235 / 255.f, 229 / 255.f, 76 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 10, pos.y + pixelSize.y * 4 }, pixelSize, color, ue::FLinearColor{ 208 / 255.f, 200 / 255.f, 55 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 10, pos.y + pixelSize.y * 5 }, pixelSize, color, ue::FLinearColor{ 164 / 255.f, 157 / 255.f, 43 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 10, pos.y + pixelSize.y * 6 }, pixelSize, color, ue::FLinearColor{ 118 / 255.f, 114 / 255.f, 31 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 10, pos.y + pixelSize.y * 7 }, pixelSize, color, ue::FLinearColor{ 86 / 255.f, 82 / 255.f, 21 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 10, pos.y + pixelSize.y * 8 }, pixelSize, color, ue::FLinearColor{ 9 / 255.f, 9 / 255.f, 9 / 255.f, 1.0f });
			}
			//11
			{
				ColorPixel(Vector2{ pos.x + pixelSize.x * 11, pos.y + pixelSize.y * 0 }, pixelSize, color, ue::FLinearColor{ 218 / 255.f, 232 / 255.f, 182 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 11, pos.y + pixelSize.y * 1 }, pixelSize, color, ue::FLinearColor{ 198 / 255.f, 221 / 255.f, 143 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 11, pos.y + pixelSize.y * 2 }, pixelSize, color, ue::FLinearColor{ 181 / 255.f, 210 / 255.f, 103 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 11, pos.y + pixelSize.y * 3 }, pixelSize, color, ue::FLinearColor{ 154 / 255.f, 186 / 255.f, 76 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 11, pos.y + pixelSize.y * 4 }, pixelSize, color, ue::FLinearColor{ 130 / 255.f, 155 / 255.f, 64 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 11, pos.y + pixelSize.y * 5 }, pixelSize, color, ue::FLinearColor{ 102 / 255.f, 121 / 255.f, 50 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 11, pos.y + pixelSize.y * 6 }, pixelSize, color, ue::FLinearColor{ 74 / 255.f, 88 / 255.f, 36 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 11, pos.y + pixelSize.y * 7 }, pixelSize, color, ue::FLinearColor{ 54 / 255.f, 64 / 255.f, 26 / 255.f, 1.0f });
				ColorPixel(Vector2{ pos.x + pixelSize.x * 11, pos.y + pixelSize.y * 8 }, pixelSize, color, ue::FLinearColor{ 0 / 255.f, 0 / 255.f, 0 / 255.f, 1.0f });
			}



			if (isHoveredPicker)
			{
				if (Input::IsMouseClicked(0, elements_count, false))
				{

				}
			}
			else
			{
				if (Input::IsMouseClicked(0, elements_count, false))
				{
					active_picker = -1;
					//hover_element = false;
				}
			}
		}
		else
		{
			//Bg
			if (isHovered)
			{
				drawFilledRect(Vector2{ pos.x, pos.y }, size, size, Colors::Checkbox_Hovered);
				hover_element = true;
			}
			else
			{
				drawFilledRect(Vector2{ pos.x, pos.y }, size, size, Colors::Checkbox_Idle);
			}

			//Color
			drawFilledRect(Vector2{ pos.x + 4, pos.y + 4 }, size - 8, size - 8, *color);

			//Text
			Vector2 textPos = Vector2{ pos.x + size + 5.0f, pos.y + size / 2 };
			TextLeft(name, textPos, ue::FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);

			if (isHovered && Input::IsMouseClicked(0, elements_count, false))
			{
				saved_color = *color;
				active_picker = elements_count;
			}
		}


		sameLine = false;
		last_element_pos = pos;
		//last_element_size = size;
		if (first_element_pos.x == 0.0f)
			first_element_pos = pos;
	}


	void Render()
	{
		for (int i = 0; i < 128; i++)
		{
			if (PostRenderer::drawlist[i].type != -1)
			{
				//Filled Rect
				if (PostRenderer::drawlist[i].type == 1)
				{
					ZeroGUI::drawFilledRect(PostRenderer::drawlist[i].pos, PostRenderer::drawlist[i].size.x, PostRenderer::drawlist[i].size.y, PostRenderer::drawlist[i].color);
				}
				//TextLeft
				else if (PostRenderer::drawlist[i].type == 2)
				{
					ZeroGUI::TextLeft(PostRenderer::drawlist[i].name, PostRenderer::drawlist[i].pos, PostRenderer::drawlist[i].color, PostRenderer::drawlist[i].outline);
				}
				//TextCenter
				else if (PostRenderer::drawlist[i].type == 3)
				{
					ZeroGUI::TextCenter(PostRenderer::drawlist[i].name, PostRenderer::drawlist[i].pos, PostRenderer::drawlist[i].color, PostRenderer::drawlist[i].outline);
				}
				//Draw_Line
				else if (PostRenderer::drawlist[i].type == 4)
				{
					Draw_Line(PostRenderer::drawlist[i].from, PostRenderer::drawlist[i].to, PostRenderer::drawlist[i].thickness, PostRenderer::drawlist[i].color);
				}

				PostRenderer::drawlist[i].type = -1;
			}
		}
	}
}
bool ShowMenu = true;

namespace Settings
{
	//Aim
	static bool MemoryAim = 0; //Done
	static bool pmemory = 0; //Done
	static bool SilentAim = 0; //Done
	static bool SniperTp = 0; //Done
	int BoneTarget = 1;
	static int AimBone = 66;
	static float MemoryAimSmooth = 0; //Done

	static bool fov360 = 0; //Done
	static float FovCircle_Value = 430; //Done



	//Player ESP
	static bool BoxESP = 1; //Done
	static bool SkeletonESP = 0; //Done
	static bool LinesESP = 0; //Done
	static bool PlayerNameESP = 0; //Done
	static bool DistanceESP = 0; //Done
	static bool LevelESP = 0; //Done
	static bool KillsESP = 0; //Done
	static bool PlatformESP = 0; //Done
	static bool EnemyWeaponESP = 0; //Done
	static bool AmmoESP = 0; //Done
	static bool RadarESP = 0;
	static float RadarESPRange = 7000.f;
	static int RadarESPOpacity = 255;


	//Exploits
	static bool NoSpread = 0; //Done
	static bool Chams = 0; //Done
	static bool Invisible = 0; //Done
	static bool InstantRevive = 0; //Done
	static bool AimWhileJumping = 0; //Done
	static bool resources = 0;
	static bool RapidFire = 0;
	static float RapidFireValue = 0.001f;
	static bool FirstCamera = 0; //Done
	static bool InstantReload = 0; //Done
	static bool SpeedStuff = 0; //Done
	static float CustomSpeedStuff = 0; //Done

	//Fov Changer
	static bool FovChanger = 0; //Done
	static float FovChanger_Value = 80.f; //Done

	//Boat Speed
	static bool VehicleSpeed = 0;
	static float VehicleSpeedValue = 30.f;

	//Car Exploits
	static bool CarFly = 0; //Done
	static bool CarTpToPing = 0; //Done
	static bool CarTpToPlayer = 0; //Done
	static bool TP_Locations_Start = 0; //Done
	static int TP_Locations = 0; //Done


	static bool TPToAimingPlayer = 0; //Done


	//Misc

	static float MaxESPDistance = 300; //Done
	static bool ShowFovCircle = true; //Done

	static bool PanicButtonFeature = true;
	static bool PanicButtonON = false;



}
int tabs = 0;
float FovSize = 200;
float inr;
float ing;
float inb;
float ino;

float outr;
float outg;
float outb;
float outo;
Vector3 galgan(Vector3& zaz, Vector3& daz) {

	Vector3 dalte = zaz - daz;
	Vector3 ongle;
	float hpm = sqrtf(dalte.x * dalte.x + dalte.y * dalte.y);
	ongle.y = atan(dalte.y / dalte.x) * 57.295779513082f;
	ongle.x = (atan(dalte.z / hpm) * 57.295779513082f) * -1.f;
	if (dalte.x >= 0.f) ongle.y += 180.f;
	return ongle;
}
#define D2R(d) (d / 180.f) * M_PI
#define MAX_SEGMENTS 180
void Pasted_line(Vector2 one, Vector2 two, ue::FLinearColor color)
{
	static_canvas->K2_DrawLine(one, two, 1, color);
}
void Pasted_PointArray(size_t count, Vector2* ary, ue::FLinearColor color)
{
	for (size_t i = 1; i < count; ++i)
		Pasted_line(ary[i - 1], ary[i], color);
}

int myceilf(float num)
{
	int inum = (int)num;
	if (num == (float)inum) {
		return inum;
	}
	return inum + 1;
}
void Pasted_CircleOutline(Vector2 pos, int r, ue::FLinearColor outline)
{
	float circum = M_PI * 2.f * r;
	int seg = myceilf(circum);

	if (seg > MAX_SEGMENTS) seg = MAX_SEGMENTS;

	float theta = 0.f;
	float step = 360.f / seg;

	Vector2 points[MAX_SEGMENTS] = {};

	for (size_t i = 0; i < seg; ++i)
	{
		theta = i * step;
		points[i] = Vector2(pos.x + roundf(r * sin(D2R(theta))), pos.y + roundf(r * cos(D2R(theta))));
	}

	Pasted_PointArray(seg, points, outline);
}
```

`notes.txt`:

```txt
MoveUp_World - 0x818 - https://docs.unrealengine.com/4.26/en-US/API/Runtime/Engine/GameFramework/ADefaultPawn/MoveUp_World/
K2_OnEndCrouch - 0x2B8 - https://docs.unrealengine.com/4.26/en-US/API/Runtime/Engine/GameFramework/ACharacter/K2_OnEndCrouch/ (maybe 0x108 but prob not) or 0xE0
GetActorBounds - 0x340 - https://docs.unrealengine.com/4.26/en-US/API/Runtime/Engine/GameFramework/AActor/GetActorBounds/
GetPlayerName - - https://docs.unrealengine.com/4.26/en-US/API/Runtime/Engine/GameFramework/APlayerState/GetPlayerName/ 0x118 or 0x2B8 or 0x108  0x718


Vector3 (*o_K2_GetActorRotation)(); //0x688
Vector3 K2_GetActorRotation() {
	std::cout << "Called" << "\n";
	return Vector3(90, 0, 0);
}
//if (!temponce) {
	//	auto uworld = ((GWorld*)(*(uintptr_t*)(ue::cached::signatures::GWorld)));
	//	auto LocalPawn = uworld->OwningGameInstance()->LocalPlayers()->LocalPlayer()->PlayerController()->LocalPawn();
	//	
	//	auto MoveUp_World_VFTable = *(uintptr_t*)(uintptr_t(LocalPawn));
	//	auto MoveUp_World_addr = *(uintptr_t*)(MoveUp_World_VFTable + 0x818); //MoveUp_World
	//	//MessageBox(0, L"Hooked!", 0, 0);
	//	int v0 = (int)*(BYTE*)(MoveUp_World_addr);
	//	std::cout << v0 << "\n";

	//	MH_Initialize();
	//	MH_CreateHook((PVOID)MoveUp_World_addr, hk_MoveUp_World, reinterpret_cast<PVOID*>(&o_MoveUp_World));
	//	MH_EnableHook((PVOID)MoveUp_World_addr);
	//	temponce = true;
	//}

void Emote(const struct FName& AssetName);
void AllowShowMainMap(bool bAllowShow);
void K2_OnMovementModeChanged(TEnumAsByte<EMovementMode> PrevMovementMode, TEnumAsByte<EMovementMode> NewMovementMode, unsigned char PrevCustomMode, unsigned char NewCustomMode);
void MeleeSwingRight_End();
void SetActorScale3D(const struct FVector& NewScale3D);
void SetWorldScale3D(const struct FVector& NewScale);
	void SetVisibility(bool bNewVisibility, bool bPropagateToChildren);
	bool IsExceedingMaxSpeed(float MaxSpeed);
	class AWorldSettings : public AInfo
	class UFloatingPawnMovement : public UPawnMovementComponent

		void SetWeaponData(class UFortWeaponItemDefinition* InWeaponData);

GetAccelerationPercent

GetActorLocation(TheViewTarget, &out_location)
GetCameraViewPoint(PlayerCameraManager, out_Location, out_Rotation);
//sub_7FF6BD2356A8 = hk_GetCameraCachePOV

48 89 5C 24 18 55 57 41 54 41 56 41 57 48 8B EC 48 83 EC 40 - 2 floats i think and get the vtable of current weapon

143 - GetWeaponRateOfFireModifier - (__int64 a1, __int64 a2, float *a3) - float
GetMagazineAmmoCount - int - 66
GetTimeToNextFire - float - 101
83 - float GetProjectileSpeed(float ChargePercent);

AFortPlayerControllerAthena	MatchReport	0x40a8	UAthenaPlayerMatchReport*
GetTotalScoreEarned - int - 5 - UAthenaPlayerMatchReport
float STATIC_GetBuildingHealthPercentage(class ABuildingActor* BuildingActor); - 0x8A8 - (__int64 a1, _QWORD *a2, float *a3)
unsigned char STATIC_GetActorTeam(class AActor* Actor);
//STATIC_K2_GiveBuildingResource 
```

`safecall.h`:

```h
#pragma once

/*
 * Copyright 2017 - 2021 Justas Masiulis
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//

#ifndef LAZY_IMPORTER_HPP
#define LAZY_IMPORTER_HPP

#define LI_FN(name) \
    ::li::detail::lazy_function<::li::detail::khash(#name), decltype(&name)>()

#define LI_FN_DEF(name) ::li::detail::lazy_function<::li::detail::khash(#name), name>()

#define LI_MODULE(name) ::li::detail::lazy_module<::li::detail::khash(name)>()

// NOTE only std::forward is used from this header.
// If there is a need to eliminate this dependency the function itself is very small.

#include <utility>
#include <cstddef>
#include <intrin.h>

#ifndef LAZY_IMPORTER_NO_FORCEINLINE
#if defined(_MSC_VER)
#define LAZY_IMPORTER_FORCEINLINE __forceinline
#elif defined(__GNUC__) && __GNUC__ > 3
#define LAZY_IMPORTER_FORCEINLINE inline __attribute__((__always_inline__))
#else
#define LAZY_IMPORTER_FORCEINLINE inline
#endif
#else
#define LAZY_IMPORTER_FORCEINLINE inline
#endif

#ifdef LAZY_IMPORTER_CASE_INSENSITIVE
#define LAZY_IMPORTER_TOLOWER(c) (c >= 'A' && c <= 'Z' ? (c | (1 << 5)) : c)
#else
#define LAZY_IMPORTER_TOLOWER(c) (c)
#endif

namespace li {
    namespace detail {

        template<class First, class Second>
        struct pair {
            First  first;
            Second second;
        };

        namespace win {

            struct LIST_ENTRY_T {
                const char* Flink;
                const char* Blink;
            };

            struct UNICODE_STRING_T {
                unsigned short Length;
                unsigned short MaximumLength;
                wchar_t* Buffer;
            };

            struct PEB_LDR_DATA_T {
                unsigned long Length;
                unsigned long Initialized;
                const char* SsHandle;
                LIST_ENTRY_T  InLoadOrderModuleList;
            };

            struct PEB_T {
                unsigned char   Reserved1[2];
                unsigned char   BeingDebugged;
                unsigned char   Reserved2[1];
                const char* Reserved3[2];
                PEB_LDR_DATA_T* Ldr;
            };

            struct LDR_DATA_TABLE_ENTRY_T {
                LIST_ENTRY_T InLoadOrderLinks;
                LIST_ENTRY_T InMemoryOrderLinks;
                LIST_ENTRY_T InInitializationOrderLinks;
                const char* DllBase;
                const char* EntryPoint;
                union {
                    unsigned long SizeOfImage;
                    const char* _dummy;
                };
                UNICODE_STRING_T FullDllName;
                UNICODE_STRING_T BaseDllName;

                LAZY_IMPORTER_FORCEINLINE const LDR_DATA_TABLE_ENTRY_T*
                    load_order_next() const noexcept
                {
                    return reinterpret_cast<const LDR_DATA_TABLE_ENTRY_T*>(
                        InLoadOrderLinks.Flink);
                }
            };

            struct IMAGE_DOS_HEADER { // DOS .EXE header
                unsigned short e_magic; // Magic number
                unsigned short e_cblp; // Bytes on last page of file
                unsigned short e_cp; // Pages in file
                unsigned short e_crlc; // Relocations
                unsigned short e_cparhdr; // Size of header in paragraphs
                unsigned short e_minalloc; // Minimum extra paragraphs needed
                unsigned short e_maxalloc; // Maximum extra paragraphs needed
                unsigned short e_ss; // Initial (relative) SS value
                unsigned short e_sp; // Initial SP value
                unsigned short e_csum; // Checksum
                unsigned short e_ip; // Initial IP value
                unsigned short e_cs; // Initial (relative) CS value
                unsigned short e_lfarlc; // File address of relocation table
                unsigned short e_ovno; // Overlay number
                unsigned short e_res[4]; // Reserved words
                unsigned short e_oemid; // OEM identifier (for e_oeminfo)
                unsigned short e_oeminfo; // OEM information; e_oemid specific
                unsigned short e_res2[10]; // Reserved words
                long           e_lfanew; // File address of new exe header
            };

            struct IMAGE_FILE_HEADER {
                unsigned short Machine;
                unsigned short NumberOfSections;
                unsigned long  TimeDateStamp;
                unsigned long  PointerToSymbolTable;
                unsigned long  NumberOfSymbols;
                unsigned short SizeOfOptionalHeader;
                unsigned short Characteristics;
            };

            struct IMAGE_EXPORT_DIRECTORY {
                unsigned long  Characteristics;
                unsigned long  TimeDateStamp;
                unsigned short MajorVersion;
                unsigned short MinorVersion;
                unsigned long  Name;
                unsigned long  Base;
                unsigned long  NumberOfFunctions;
                unsigned long  NumberOfNames;
                unsigned long  AddressOfFunctions; // RVA from base of image
                unsigned long  AddressOfNames; // RVA from base of image
                unsigned long  AddressOfNameOrdinals; // RVA from base of image
            };

            struct IMAGE_DATA_DIRECTORY {
                unsigned long VirtualAddress;
                unsigned long Size;
            };

            struct IMAGE_OPTIONAL_HEADER64 {
                unsigned short       Magic;
                unsigned char        MajorLinkerVersion;
                unsigned char        MinorLinkerVersion;
                unsigned long        SizeOfCode;
                unsigned long        SizeOfInitializedData;
                unsigned long        SizeOfUninitializedData;
                unsigned long        AddressOfEntryPoint;
                unsigned long        BaseOfCode;
                unsigned long long   ImageBase;
                unsigned long        SectionAlignment;
                unsigned long        FileAlignment;
                unsigned short       MajorOperatingSystemVersion;
                unsigned short       MinorOperatingSystemVersion;
                unsigned short       MajorImageVersion;
                unsigned short       MinorImageVersion;
                unsigned short       MajorSubsystemVersion;
                unsigned short       MinorSubsystemVersion;
                unsigned long        Win32VersionValue;
                unsigned long        SizeOfImage;
                unsigned long        SizeOfHeaders;
                unsigned long        CheckSum;
                unsigned short       Subsystem;
                unsigned short       DllCharacteristics;
                unsigned long long   SizeOfStackReserve;
                unsigned long long   SizeOfStackCommit;
                unsigned long long   SizeOfHeapReserve;
                unsigned long long   SizeOfHeapCommit;
                unsigned long        LoaderFlags;
                unsigned long        NumberOfRvaAndSizes;
                IMAGE_DATA_DIRECTORY DataDirectory[16];
            };

            struct IMAGE_OPTIONAL_HEADER32 {
                unsigned short       Magic;
                unsigned char        MajorLinkerVersion;
                unsigned char        MinorLinkerVersion;
                unsigned long        SizeOfCode;
                unsigned long        SizeOfInitializedData;
                unsigned long        SizeOfUninitializedData;
                unsigned long        AddressOfEntryPoint;
                unsigned long        BaseOfCode;
                unsigned long        BaseOfData;
                unsigned long        ImageBase;
                unsigned long        SectionAlignment;
                unsigned long        FileAlignment;
                unsigned short       MajorOperatingSystemVersion;
                unsigned short       MinorOperatingSystemVersion;
                unsigned short       MajorImageVersion;
                unsigned short       MinorImageVersion;
                unsigned short       MajorSubsystemVersion;
                unsigned short       MinorSubsystemVersion;
                unsigned long        Win32VersionValue;
                unsigned long        SizeOfImage;
                unsigned long        SizeOfHeaders;
                unsigned long        CheckSum;
                unsigned short       Subsystem;
                unsigned short       DllCharacteristics;
                unsigned long        SizeOfStackReserve;
                unsigned long        SizeOfStackCommit;
                unsigned long        SizeOfHeapReserve;
                unsigned long        SizeOfHeapCommit;
                unsigned long        LoaderFlags;
                unsigned long        NumberOfRvaAndSizes;
                IMAGE_DATA_DIRECTORY DataDirectory[16];
            };

            struct IMAGE_NT_HEADERS {
                unsigned long     Signature;
                IMAGE_FILE_HEADER FileHeader;
#ifdef _WIN64
                IMAGE_OPTIONAL_HEADER64 OptionalHeader;
#else
                IMAGE_OPTIONAL_HEADER32 OptionalHeader;
#endif
            };

        } // namespace win

        // hashing stuff
        struct hash_t {
            using value_type = unsigned long;
            constexpr static value_type         offset = 2166136261;
            constexpr static value_type         prime = 16777619;
            constexpr static unsigned long long prime64 = prime;

            LAZY_IMPORTER_FORCEINLINE constexpr static value_type single(value_type value,
                char c) noexcept
            {
                return static_cast<hash_t::value_type>(
                    (value ^ LAZY_IMPORTER_TOLOWER(c)) *
                    static_cast<unsigned long long>(prime));
            }
        };

        template<class CharT = char>
        LAZY_IMPORTER_FORCEINLINE constexpr hash_t::value_type
            khash(const CharT* str, hash_t::value_type value = hash_t::offset) noexcept
        {
            return (*str ? khash(str + 1, hash_t::single(value, *str)) : value);
        }

        template<class CharT = char>
        LAZY_IMPORTER_FORCEINLINE hash_t::value_type hash(const CharT* str) noexcept
        {
            hash_t::value_type value = hash_t::offset;

            for (;;) {
                char c = *str++;
                if (!c)
                    return value;
                value = hash_t::single(value, c);
            }
        }

        LAZY_IMPORTER_FORCEINLINE hash_t::value_type hash(
            const win::UNICODE_STRING_T& str) noexcept
        {
            auto       first = str.Buffer;
            const auto last = first + (str.Length / sizeof(wchar_t));
            auto       value = hash_t::offset;
            for (; first != last; ++first)
                value = hash_t::single(value, static_cast<char>(*first));

            return value;
        }

        LAZY_IMPORTER_FORCEINLINE pair<hash_t::value_type, hash_t::value_type> hash_forwarded(
            const char* str) noexcept
        {
            pair<hash_t::value_type, hash_t::value_type> module_and_function{
                hash_t::offset, hash_t::offset
            };

            for (; *str != '.'; ++str)
                module_and_function.first = hash_t::single(module_and_function.first, *str);

            ++str;

            for (; *str; ++str)
                module_and_function.second = hash_t::single(module_and_function.second, *str);

            return module_and_function;
        }


        // some helper functions
        LAZY_IMPORTER_FORCEINLINE const win::PEB_T* peb() noexcept
        {
#if defined(_M_X64) || defined(__amd64__)
            return reinterpret_cast<const win::PEB_T*>(__readgsqword(0x60));
#elif defined(_M_IX86) || defined(__i386__)
            return reinterpret_cast<const win::PEB_T*>(__readfsdword(0x30));
#elif defined(_M_ARM) || defined(__arm__)
            return *reinterpret_cast<const win::PEB_T**>(_MoveFromCoprocessor(15, 0, 13, 0, 2) + 0x30);
#elif defined(_M_ARM64) || defined(__aarch64__)
            return *reinterpret_cast<const win::PEB_T**>(__getReg(18) + 0x60);
#elif defined(_M_IA64) || defined(__ia64__)
            return *reinterpret_cast<const win::PEB_T**>(static_cast<char*>(_rdteb()) + 0x60);
#else
#error Unsupported platform. Open an issue and I'll probably add support.
#endif
        }

        LAZY_IMPORTER_FORCEINLINE const win::PEB_LDR_DATA_T* ldr()
        {
            return reinterpret_cast<const win::PEB_LDR_DATA_T*>(peb()->Ldr);
        }

        LAZY_IMPORTER_FORCEINLINE const win::IMAGE_NT_HEADERS* nt_headers(
            const char* base) noexcept
        {
            return reinterpret_cast<const win::IMAGE_NT_HEADERS*>(
                base + reinterpret_cast<const win::IMAGE_DOS_HEADER*>(base)->e_lfanew);
        }

        LAZY_IMPORTER_FORCEINLINE const win::IMAGE_EXPORT_DIRECTORY* image_export_dir(
            const char* base) noexcept
        {
            return reinterpret_cast<const win::IMAGE_EXPORT_DIRECTORY*>(
                base + nt_headers(base)->OptionalHeader.DataDirectory->VirtualAddress);
        }

        LAZY_IMPORTER_FORCEINLINE const win::LDR_DATA_TABLE_ENTRY_T* ldr_data_entry() noexcept
        {
            return reinterpret_cast<const win::LDR_DATA_TABLE_ENTRY_T*>(
                ldr()->InLoadOrderModuleList.Flink);
        }

        struct exports_directory {
            const char* _base;
            const win::IMAGE_EXPORT_DIRECTORY* _ied;
            unsigned long                      _ied_size;

        public:
            using size_type = unsigned long;

            LAZY_IMPORTER_FORCEINLINE
                exports_directory(const char* base) noexcept : _base(base)
            {
                const auto ied_data_dir = nt_headers(base)->OptionalHeader.DataDirectory[0];
                _ied = reinterpret_cast<const win::IMAGE_EXPORT_DIRECTORY*>(
                    base + ied_data_dir.VirtualAddress);
                _ied_size = ied_data_dir.Size;
            }

            LAZY_IMPORTER_FORCEINLINE explicit operator bool() const noexcept
            {
                return reinterpret_cast<const char*>(_ied) != _base;
            }

            LAZY_IMPORTER_FORCEINLINE size_type size() const noexcept
            {
                return _ied->NumberOfNames;
            }

            LAZY_IMPORTER_FORCEINLINE const char* base() const noexcept { return _base; }
            LAZY_IMPORTER_FORCEINLINE const win::IMAGE_EXPORT_DIRECTORY* ied() const noexcept
            {
                return _ied;
            }

            LAZY_IMPORTER_FORCEINLINE const char* name(size_type index) const noexcept
            {
                return reinterpret_cast<const char*>(
                    _base + reinterpret_cast<const unsigned long*>(
                        _base + _ied->AddressOfNames)[index]);
            }

            LAZY_IMPORTER_FORCEINLINE const char* address(size_type index) const noexcept
            {
                const auto* const rva_table =
                    reinterpret_cast<const unsigned long*>(_base + _ied->AddressOfFunctions);

                const auto* const ord_table = reinterpret_cast<const unsigned short*>(
                    _base + _ied->AddressOfNameOrdinals);

                return _base + rva_table[ord_table[index]];
            }

            LAZY_IMPORTER_FORCEINLINE bool is_forwarded(
                const char* export_address) const noexcept
            {
                const auto ui_ied = reinterpret_cast<const char*>(_ied);
                return (export_address > ui_ied && export_address < ui_ied + _ied_size);
            }
        };

        struct safe_module_enumerator {
            using value_type = const detail::win::LDR_DATA_TABLE_ENTRY_T;
            value_type* value;
            value_type* head;

            LAZY_IMPORTER_FORCEINLINE safe_module_enumerator() noexcept
                : safe_module_enumerator(ldr_data_entry())
            {}

            LAZY_IMPORTER_FORCEINLINE
                safe_module_enumerator(const detail::win::LDR_DATA_TABLE_ENTRY_T* ldr) noexcept
                : value(ldr->load_order_next()), head(value)
            {}

            LAZY_IMPORTER_FORCEINLINE void reset() noexcept
            {
                value = head->load_order_next();
            }

            LAZY_IMPORTER_FORCEINLINE bool next() noexcept
            {
                value = value->load_order_next();

                return value != head && value->DllBase;
            }
        };

        struct unsafe_module_enumerator {
            using value_type = const detail::win::LDR_DATA_TABLE_ENTRY_T*;
            value_type value;

            LAZY_IMPORTER_FORCEINLINE unsafe_module_enumerator() noexcept
                : value(ldr_data_entry())
            {}

            LAZY_IMPORTER_FORCEINLINE void reset() noexcept { value = ldr_data_entry(); }

            LAZY_IMPORTER_FORCEINLINE bool next() noexcept
            {
                value = value->load_order_next();
                return true;
            }
        };

        // provides the cached functions which use Derive classes methods
        template<class Derived, class DefaultType = void*>
        class lazy_base {
        protected:
            // This function is needed because every templated function
            // with different args has its own static buffer
            LAZY_IMPORTER_FORCEINLINE static void*& _cache() noexcept
            {
                static void* value = nullptr;
                return value;
            }

        public:
            template<class T = DefaultType>
            LAZY_IMPORTER_FORCEINLINE static T safe() noexcept
            {
                return Derived::template get<T, safe_module_enumerator>();
            }

            template<class T = DefaultType, class Enum = unsafe_module_enumerator>
            LAZY_IMPORTER_FORCEINLINE static T cached() noexcept
            {
                auto& cached = _cache();
                if (!cached)
                    cached = Derived::template get<void*, Enum>();

                return (T)(cached);
            }

            template<class T = DefaultType>
            LAZY_IMPORTER_FORCEINLINE static T safe_cached() noexcept
            {
                return cached<T, safe_module_enumerator>();
            }
        };

        template<hash_t::value_type Hash>
        struct lazy_module : lazy_base<lazy_module<Hash>> {
            template<class T = void*, class Enum = unsafe_module_enumerator>
            LAZY_IMPORTER_FORCEINLINE static T get() noexcept
            {
                Enum e;
                do {
                    if (hash(e.value->BaseDllName) == Hash)
                        return (T)(e.value->DllBase);
                } while (e.next());
                return {};
            }

            template<class T = void*, class Ldr>
            LAZY_IMPORTER_FORCEINLINE static T in(Ldr ldr) noexcept
            {
                safe_module_enumerator e((const detail::win::LDR_DATA_TABLE_ENTRY_T*)(ldr));
                do {
                    if (hash(e.value->BaseDllName) == Hash)
                        return (T)(e.value->DllBase);
                } while (e.next());
                return {};
            }

            template<class T = void*, class Ldr>
            LAZY_IMPORTER_FORCEINLINE static T in_cached(Ldr ldr) noexcept
            {
                auto& cached = lazy_base<lazy_module<Hash>>::_cache();
                if (!cached)
                    cached = in(ldr);

                return (T)(cached);
            }
        };

        template<hash_t::value_type Hash, class T>
        struct lazy_function : lazy_base<lazy_function<Hash, T>, T> {
            using base_type = lazy_base<lazy_function<Hash, T>, T>;

            template<class... Args>
            LAZY_IMPORTER_FORCEINLINE decltype(auto) operator()(Args&&... args) const
            {
#ifndef LAZY_IMPORTER_CACHE_OPERATOR_PARENS
                return get()(std::forward<Args>(args)...);
#else
                return this->cached()(std::forward<Args>(args)...);
#endif
            }

            template<class F = T, class Enum = unsafe_module_enumerator>
            LAZY_IMPORTER_FORCEINLINE static F get() noexcept
            {
                // for backwards compatability.
                // Before 2.0 it was only possible to resolve forwarded exports when
                // this macro was enabled
#ifdef LAZY_IMPORTER_RESOLVE_FORWARDED_EXPORTS
                return forwarded<F, Enum>();
#else

                Enum e;

                do {
#ifdef LAZY_IMPORTER_HARDENED_MODULE_CHECKS
                    if (!e.value->DllBase || !e.value->FullDllName.Length)
                        continue;
#endif

                    const exports_directory exports(e.value->DllBase);

                    if (exports) {
                        auto export_index = exports.size();
                        while (export_index--)
                            if (hash(exports.name(export_index)) == Hash)
                                return (F)(exports.address(export_index));
                    }
                } while (e.next());
                return {};
#endif
            }

            template<class F = T, class Enum = unsafe_module_enumerator>
            LAZY_IMPORTER_FORCEINLINE static F forwarded() noexcept
            {
                detail::win::UNICODE_STRING_T name;
                hash_t::value_type            module_hash = 0;
                auto                          function_hash = Hash;

                Enum e;
                do {
                    name = e.value->BaseDllName;
                    name.Length -= 8; // get rid of .dll extension

                    if (!module_hash || hash(name) == module_hash) {
                        const exports_directory exports(e.value->DllBase);

                        if (exports) {
                            auto export_index = exports.size();
                            while (export_index--)
                                if (hash(exports.name(export_index)) == function_hash) {
                                    const auto addr = exports.address(export_index);

                                    if (exports.is_forwarded(addr)) {
                                        auto hashes = hash_forwarded(
                                            reinterpret_cast<const char*>(addr));

                                        function_hash = hashes.second;
                                        module_hash = hashes.first;

                                        e.reset();
                                        break;
                                    }
                                    return (F)(addr);
                                }
                        }
                    }
                } while (e.next());
                return {};
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F forwarded_safe() noexcept
            {
                return forwarded<F, safe_module_enumerator>();
            }

            template<class F = T, class Enum = unsafe_module_enumerator>
            LAZY_IMPORTER_FORCEINLINE static F forwarded_cached() noexcept
            {
                auto& value = base_type::_cache();
                if (!value)
                    value = forwarded<void*, Enum>();
                return (F)(value);
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F forwarded_safe_cached() noexcept
            {
                return forwarded_cached<F, safe_module_enumerator>();
            }

            template<class F = T, bool IsSafe = false, class Module>
            LAZY_IMPORTER_FORCEINLINE static F in(Module m) noexcept
            {
                if (IsSafe && !m)
                    return {};

                const exports_directory exports((const char*)(m));
                if (IsSafe && !exports)
                    return {};

                for (unsigned long i{};; ++i) {
                    if (IsSafe && i == exports.size())
                        break;

                    if (hash(exports.name(i)) == Hash)
                        return (F)(exports.address(i));
                }
                return {};
            }

            template<class F = T, class Module>
            LAZY_IMPORTER_FORCEINLINE static F in_safe(Module m) noexcept
            {
                return in<F, true>(m);
            }

            template<class F = T, bool IsSafe = false, class Module>
            LAZY_IMPORTER_FORCEINLINE static F in_cached(Module m) noexcept
            {
                auto& value = base_type::_cache();
                if (!value)
                    value = in<void*, IsSafe>(m);
                return (F)(value);
            }

            template<class F = T, class Module>
            LAZY_IMPORTER_FORCEINLINE static F in_safe_cached(Module m) noexcept
            {
                return in_cached<F, true>(m);
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F nt() noexcept
            {
                return in<F>(ldr_data_entry()->load_order_next()->DllBase);
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F nt_safe() noexcept
            {
                return in_safe<F>(ldr_data_entry()->load_order_next()->DllBase);
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F nt_cached() noexcept
            {
                return in_cached<F>(ldr_data_entry()->load_order_next()->DllBase);
            }

            template<class F = T>
            LAZY_IMPORTER_FORCEINLINE static F nt_safe_cached() noexcept
            {
                return in_safe_cached<F>(ldr_data_entry()->load_order_next()->DllBase);
            }
        };

    }
} // namespace li::detail

#endif // include guard

// To hide the DLL imports when used on "X" function.
#define safe_call(Function) LI_FN(Function).safe_cached()
```

`sdk.h`:

```h
#pragma once
#include "custom_runtimes.h"
#include "custom_runtimes.cpp"
#include "safecall.h"
#include "spoof_call.h"
class sdk {
public:

	inline uintptr_t GetGameBase() {
		return *(uintptr_t*)(__readgsqword(0x60) + 0x10);
	}
	inline bool isValidPointer(uintptr_t address)
	{
		
		if (!(safe_call(IsBadWritePtr))((LPVOID)address, (UINT_PTR)8))
			return true;
		else
			return false;
	}
	inline uintptr_t PatternScan(uintptr_t pModuleBaseAddress, const char* sSignature, int pIndex, bool sRelativeAdr = false)
	{
		static auto patternToByte = [](const char* pattern) { auto bytes = std::vector<int>{}; const auto start = const_cast<char*>(pattern); const auto end = const_cast<char*>(pattern) + strlen(pattern); for (auto current = start; current < end; ++current) { if (*current == '?') { ++current; if (*current == '?') ++current; bytes.push_back(-1); } else bytes.push_back(strtoul((const char*)current, &current, 16)); } return bytes; };

		const auto dosHeader = (PIMAGE_DOS_HEADER)pModuleBaseAddress;
		const auto ntHeaders = (PIMAGE_NT_HEADERS)((std::uint8_t*)pModuleBaseAddress + dosHeader->e_lfanew);

		const auto sizeOfImage = ntHeaders->OptionalHeader.SizeOfImage;
		auto patternBytes = patternToByte(sSignature);
		const auto scanBytes = reinterpret_cast<std::uint8_t*>(pModuleBaseAddress);

		const auto s = patternBytes.size();
		const auto d = patternBytes.data();

		for (auto i = 0ul; i < sizeOfImage - s; ++i) {
			bool found = true; for (auto j = 0ul; j < s; ++j) { if (scanBytes[i + j] != d[j] && d[j] != -1) { found = false; break; } }
			if (found)
			{
				if (sRelativeAdr)
				{
					return ((uintptr_t)((UINT_PTR)(reinterpret_cast<uintptr_t>(&scanBytes[i])) + *(PINT)((UINT_PTR)(reinterpret_cast<uintptr_t>(&scanBytes[i])) + ((pIndex)-sizeof(INT))) + (pIndex)));
				}
				else
				{
					return reinterpret_cast<uintptr_t>(&scanBytes[i]);
				}
			}
		}

		return NULL;
	}
	inline bool ProcessEvent(uintptr_t address, void* fnobject, void* parms)
	{
		if (!isValidPointer(address)) return false;
		auto index = *reinterpret_cast<void***>(address); if (!index) return false;
		auto fProcessEvent = static_cast<void(*)(void* address, void* fnobject, void* parms)>(index[0x4D]); if (!fProcessEvent) return false; //changes sometimes (needs to be found in ida)
		fProcessEvent((void*)address, (void*)fnobject, (void*)parms);
		return true;
	}
	inline ue::FName Conv_StringToName(const wchar_t* String)
	{
		struct
		{
			ue::FString                                     inString;                                                 // (Parm, ZeroConstructor)
			ue::FName                                       ReturnValue;                                              // (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)
		} params;

		params.inString = String;

		ProcessEvent((uintptr_t)ue::cached::KismetStringLibrary, ue::cached::Conv_StringToName, &params);

		return params.ReturnValue;
	}
	inline float STATIC_Cos(float a)
	{
		
		struct
		{
			float                                              A;                                                        // (Parm, ZeroConstructor, IsPlainOldData)
			float                                              ReturnValue;                                              // (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)
		} params;

		params.A = a;

		ProcessEvent((uintptr_t)ue::cached::KismetMathLibrary, ue::cached::Cos, &params);

		return params.ReturnValue;
	}
	inline float STATIC_Sin(float a)
	{
		
		struct
		{
			float                                              A;                                                        // (Parm, ZeroConstructor, IsPlainOldData)
			float                                              ReturnValue;                                              // (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)
		} params;

		params.A = a;

		ProcessEvent((uintptr_t)ue::cached::KismetMathLibrary, ue::cached::Sin, &params);

		return params.ReturnValue;
	}
	
};
sdk* sdkUssage = new sdk();

namespace find
{
	inline void FnFree(uintptr_t address)
	{
		if (!sdkUssage->isValidPointer(address)) return;
		auto function = reinterpret_cast<void(__fastcall*)(__int64)>(ue::cached::signatures::FreeFn);
		return function((__int64)address);
	}

	inline const wchar_t* GetNameByIndex(int idx)
	{
		std::wstring name = L"";

		if (!idx) return L"";

		auto function = reinterpret_cast<ue::FString * (__fastcall*)(int* index, ue::FString * res)>(ue::cached::signatures::GetNameByIndex);

		int index = idx;

		ue::FString fObjectName;
		function(&index, &fObjectName);

		if (!fObjectName.IsValid()) return L"";

		auto objectName = fObjectName.c_str();

		name = objectName;
		FnFree((uintptr_t)fObjectName.c_str());

		return name.c_str();
	}

	inline const wchar_t* GetObjectName(ue::classes::UObject* object)
	{
		std::wstring name = (L"");

		if (!object) return (L"");

		auto function = reinterpret_cast<ue::FString * (__fastcall*)(int* index, ue::FString * res)>(ue::cached::signatures::GetNameByIndex);

		int index = *(int*)(reinterpret_cast<uint64_t>(object) + 0x18);

		ue::FString fObjectName;
		function(&index, &fObjectName);

		if (!fObjectName.IsValid()) return (L"");

		auto objectName = fObjectName.c_str();

		name = objectName;
		FnFree((uintptr_t)fObjectName.c_str());

		return name.c_str();
	}

	inline const wchar_t* GetFullObjectName(ue::classes::UObject* object)
	{
		std::wstring name = (L"");

		for (auto i = 0; object; object = object->Outer, i++)
		{
			if (!object) return (L"");

			auto function = reinterpret_cast<ue::FString * (__fastcall*)(int* index, ue::FString * res)>(ue::cached::signatures::GetNameByIndex);

			int index = *(int*)(reinterpret_cast<uint64_t>(object) + 0x18);

			ue::FString fObjectName;
			function(&index, &fObjectName);

			if (!fObjectName.IsValid()) break;

			auto objectName = fObjectName.c_str();

			name = objectName + std::wstring(i > 0 ? (L".") : (L"")) + name;
			FnFree((uintptr_t)fObjectName.c_str());
		}

		return name.c_str();
	}

	inline void NumChunks(ue::classes::TUObjectArray* ObjectArray, int* start, int* end)
	{
		int cStart = 0, cEnd = 0;

		if (!cEnd)
		{
			while (true)
			{
				if (ObjectArray->Objects[cStart] == nullptr)
				{
					cStart++;
				}
				else
				{
					break;
				}
			}

			cEnd = cStart;
			while (true)
			{
				if (ObjectArray->Objects[cEnd] == nullptr)
				{
					break;
				}
				cEnd++;
			}
		}

		*start = cStart;
		*end = cEnd;
	}

	inline ue::classes::UObject* GetObjByIndex(ue::classes::TUObjectArray* ObjectArray, int32_t index)
	{
		int cStart = 0, cEnd = 0;
		int chunkIndex, chunkSize = 0xFFFF, chunkPos;
		ue::classes::FUObjectItem* Object;

		NumChunks(ObjectArray, &cStart, &cEnd);

		chunkIndex = index / chunkSize;
		if (chunkSize * chunkIndex != 0 &&
			chunkSize * chunkIndex == index)
		{
			chunkIndex--;
		}

		chunkPos = cStart + chunkIndex;
		if (chunkPos < cEnd)
		{
			Object = ObjectArray->Objects[chunkPos] + (index - chunkSize * chunkIndex);
			if (!Object) { return nullptr; }

			return Object->Object;
		}

		return nullptr;
	}


	inline const wchar_t* fix_objectname(const wchar_t* objname)
	{
		wchar_t* _4 = (wchar_t*)objname;

		for (int i = 0; i < wcslen(_4); i++)
		{
			if (_4[i] == L'_')
			{
				if (_4[i + 1] == L'0' ||
					_4[i + 1] == L'1' ||
					_4[i + 1] == L'2' ||
					_4[i + 1] == L'3' ||
					_4[i + 1] == L'4' ||
					_4[i + 1] == L'5' ||
					_4[i + 1] == L'6' ||
					_4[i + 1] == L'7' ||
					_4[i + 1] == L'8' ||
					_4[i + 1] == L'9')
					_4[i] = L'$';

				for (int idx = 1; idx < 7; idx++) {

					if (_4[i + idx] == L'.') break;

					if (_4[i + idx] == L'0' ||
						_4[i + idx] == L'1' ||
						_4[i + idx] == L'2' ||
						_4[i + idx] == L'3' ||
						_4[i + idx] == L'4' ||
						_4[i + idx] == L'5' ||
						_4[i + idx] == L'6' ||
						_4[i + idx] == L'7' ||
						_4[i + idx] == L'8' ||
						_4[i + idx] == L'9') {
						_4[i + idx] = L'$';
					}
				}

			}
		}

		std::wstring str = _4;
		str.erase(std::remove(str.begin(), str.end(), '$'), str.end());
		return str.c_str();
	}

	inline PVOID FindObject(const wchar_t* objectname)
	{
		for (auto index = 0x0; index < ue::classes::objects->ObjectCount; index++)
		{
			auto object = GetObjByIndex(ue::classes::objects->ObjectArray, index);
			const wchar_t* tmp_name = GetFullObjectName(object);
			const wchar_t* name = fix_objectname(tmp_name);
			

			if ((math::custom_wcsstr(name, objectname)))
			{
				return object;
			}
		}

		return 0;
	}

	
}
class UCanvas {
public:

	int32_t SizeX() {
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return 0;
		return *(int32_t*)((uintptr_t)this + 0x40); //wont change
	}

	int32_t SizeY() {
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return 0;
		return *(int32_t*)((uintptr_t)this + 0x44); //wont change
	}

	void K2_DrawLine(Vector2 ScreenPositionA, Vector2 ScreenPositionB, float Thickness, ue::FLinearColor RenderColor)
	{
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return;

		struct
		{
			Vector2                                   ScreenPositionA;                                          // (Parm, ZeroConstructor, IsPlainOldData)
			Vector2                                  ScreenPositionB;                                          // (Parm, ZeroConstructor, IsPlainOldData)
			float                                              Thickness;                                                // (Parm, ZeroConstructor, IsPlainOldData)
			ue::FLinearColor                                RenderColor;                                              // (Parm, ZeroConstructor, IsPlainOldData)
		} params;

		params.ScreenPositionA = { ScreenPositionA.x, ScreenPositionA.y };
		params.ScreenPositionB = { ScreenPositionB.x, ScreenPositionB.y };
		params.Thickness = Thickness;
		params.RenderColor = { (float)RenderColor.R, (float)RenderColor.G, (float)RenderColor.B, (float)RenderColor.A };

		sdkUssage->ProcessEvent(uintptr_t(this), ue::cached::objects::render::K2_DrawLine, &params);
	}

	void K2_DrawBox(Vector2 ScreenPosition, Vector2 ScreenSize, float Thickness, ue::FLinearColor RenderColor)
	{
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return;

		struct
		{
			Vector2                                  ScreenPosition;                                           // (Parm, ZeroConstructor, IsPlainOldData)
			Vector2                                   ScreenSize;                                               // (Parm, ZeroConstructor, IsPlainOldData)
			float                                              Thickness;                                                // (Parm, ZeroConstructor, IsPlainOldData)
			ue::FLinearColor                                RenderColor;                                              // (Parm, ZeroConstructor, IsPlainOldData)
		} params;

		params.ScreenPosition = { ScreenPosition.x, ScreenPosition.y };
		params.ScreenSize = { ScreenSize.x, ScreenSize.y };
		params.Thickness = Thickness;
		params.RenderColor = { (float)RenderColor.R, (float)RenderColor.G, (float)RenderColor.B, (float)RenderColor.A };

		sdkUssage->ProcessEvent(uintptr_t(this), ue::cached::objects::render::K2_DrawBox, &params);
	}

	void K2_DrawText(Vector2 ScreenPosition, ue::FLinearColor RenderColor, ue::FString RenderText, bool bCentered = true, bool bOutlined = false)
	{
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return;

		struct
		{
			uintptr_t RenderFont;                                               // (Parm, ZeroConstructor, IsPlainOldData)
			ue::FString                                     RenderText;                                               // (Parm, ZeroConstructor)
			Vector2                                   ScreenPosition;                                           // (Parm, ZeroConstructor, IsPlainOldData)
			Vector2                                   Scale;                                                    // (Parm, ZeroConstructor, IsPlainOldData)
			ue::FLinearColor                                RenderColor;                                              // (Parm, ZeroConstructor, IsPlainOldData)
			float                                              Kerning;                                                  // (Parm, ZeroConstructor, IsPlainOldData)
			ue::FLinearColor                                ShadowColor;                                              // (Parm, ZeroConstructor, IsPlainOldData)
			Vector2                                   ShadowOffset;                                             // (Parm, ZeroConstructor, IsPlainOldData)
			bool                                               bCentreX;                                                 // (Parm, ZeroConstructor, IsPlainOldData)
			bool                                               bCentreY;                                                 // (Parm, ZeroConstructor, IsPlainOldData)
			bool                                               bOutlined;                                                // (Parm, ZeroConstructor, IsPlainOldData)
			ue::FLinearColor                                OutlineColor;                                             // (Parm, ZeroConstructor, IsPlainOldData)
		} params;

		params.RenderFont = uintptr_t(ue::cached::objects::render::Font);
		params.RenderText = RenderText;
		params.ScreenPosition = { ScreenPosition.x, ScreenPosition.y };
		params.Scale = { 1.f, 1.f };
		params.RenderColor = { (float)RenderColor.R, (float)RenderColor.G, (float)RenderColor.B, (float)RenderColor.A };
		params.Kerning = false;
		params.ShadowColor = { 0.f, 0.f, 0.f, 0.f };
		params.ShadowOffset = { ScreenPosition.x + 1.5f, ScreenPosition.y + 1.5f };

		if (bCentered)
		{
			params.bCentreX = true;
			params.bCentreY = true;
		}
		else
		{
			params.bCentreX = false;
			params.bCentreY = false;
		}

		params.bOutlined = bOutlined;
		params.OutlineColor = { 0.0f, 0.0f, 0.0f, 1.f };

		sdkUssage->ProcessEvent(uintptr_t(this), ue::cached::objects::render::K2_DrawText, &params);
	}

	Vector2 K2_TextSize(ue::FString RenderText)
	{
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return { 0, 0 };

		struct
		{
			uintptr_t RenderFont;                                               // (Parm, ZeroConstructor, IsPlainOldData)
			ue::FString                                     RenderText;                                               // (Parm, ZeroConstructor)
			Vector2                                   Scale;                                                    // (Parm, ZeroConstructor, IsPlainOldData)
			Vector2                                   ReturnValue;                                              // (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)
		} params;

		params.RenderFont = uintptr_t(ue::cached::objects::render::Font);
		params.RenderText = RenderText;
		params.Scale = { 0.6f, 0.6f };

		sdkUssage->ProcessEvent(uintptr_t(this), ue::cached::objects::render::K2_TextSize, &params);

		return { params.ReturnValue.x, params.ReturnValue.y };
	}
};
// Enum FortniteGame.EFortItemTier
enum class EFortItemTier : uint8_t
{
	No_Tier = 0,
	I = 1,
	II = 2,
	III = 3,
	IV = 4,
	V = 5,
	VI = 6,
	VII = 7,
	VIII = 8,
	IX = 9,
	X = 10,
	NumItemTierValues = 11,
	EFortItemTier_MAX = 12
};
class AFortItemDefinition {
public:

	ue::FText DisplayName() {
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return {};
		return *(ue::FText*)((uintptr_t)this + ue::cached::offsets::DisplayName);
	}
	EFortItemTier Tier() {
		return *(EFortItemTier*)((uintptr_t)this + ue::cached::offsets::Tier);
	}
};
class AWeapon {
public:
	AFortItemDefinition* WeaponData() {
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return 0;
		return (AFortItemDefinition*)(*(uintptr_t*)(this + ue::cached::offsets::WeaponData));
	}
	void RapidFire() {
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return;

		float a = 0;
		float b = 0;
		a = *(float*)((uintptr_t)this + ue::cached::offsets::LastFireTime); //LastFireTime Offset
		b = *(float*)((uintptr_t)this + ue::cached::offsets::LastFireTimeVerified); //LastFireTimeVerified Offset
		*(float*)((uintptr_t)this + ue::cached::offsets::LastFireTime) = a + b - 0.3333; //LastFireTime Offset
	}
	// Enum FortniteGame.EFortItemTier
	int GetBulletsPerClip()
	{
		static ue::classes::UObject* fn = NULL;
		if (!fn)
			fn = (ue::classes::UObject*)find::FindObject((L"FortniteGame.FortWeapon.GetBulletsPerClip"));


		struct
		{
			int                                                ReturnValue;                                              // (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)
		} params;


		sdkUssage->ProcessEvent(uintptr_t(this), fn, &params);
		return params.ReturnValue;
	}
	int GetMagazineAmmoCount()
	{
		static ue::classes::UObject* fn = NULL;
		if (!fn)
			fn = (ue::classes::UObject*)find::FindObject((L"FortniteGame.FortWeapon.GetMagazineAmmoCount"));


		struct
		{
			int                                                ReturnValue;                                              // (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)
		} params;


		sdkUssage->ProcessEvent(uintptr_t(this), fn, &params);
		return params.ReturnValue;
	}
	
};
class APlayerState {
public:

	uintptr_t TeamIndex() {
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return 0;
		return *(uintptr_t*)(this + ue::cached::offsets::TeamIndex);
	}
	int32_t SeasonLevelUIDisplay() {
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return 0;
		return *(int32_t*)(this + 0x1080); //FortPlayerState
	}
	ue::FString GetPlayerName() {
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return L"";
		ue::FString PlayerName;
		sdkUssage->ProcessEvent((uintptr_t)this, ue::cached::objects::actor::GetPlayerName, &PlayerName);
		if (!PlayerName.IsValid()) return L"";
		return PlayerName;
	}
	
	ue::FString GetPlatform() {
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return L"";
		static ue::classes::UObject* fn = NULL;
		if (!fn)
			fn = (ue::classes::UObject*)find::FindObject((L"FortniteGame.FortPlayerState.GetPlatform"));
		ue::FString Platform;
		sdkUssage->ProcessEvent((uintptr_t)this, fn, &Platform);
		if (!Platform.IsValid()) return L"";
		return Platform;
	}
	int GetKillScore()
	{
		static ue::classes::UObject* fn = NULL;
		if (!fn)
			fn = (ue::classes::UObject*)find::FindObject((L"FortniteGame.FortPlayerStateAthena.GetKillScore"));


		struct
		{
			int                                                ReturnValue;                                              // (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)
		} params;


		sdkUssage->ProcessEvent(uintptr_t(this), fn, &params);
		return params.ReturnValue;
	}
};
class ARootComponent {
public:

	Vector3 RelativeLocation() {
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return { 0, 0, 0 };
		return *(Vector3*)((uintptr_t)this + ue::cached::offsets::RelativeLocation);
	}
	void SetWorldScale3D(Vector3 NewScale)
	{
		static ue::classes::UObject* fn = NULL;
		if (!fn)
			fn = (ue::classes::UObject*)find::FindObject((L"Function Engine.SceneComponent.SetWorldScale3D"));

		struct AFortPlayerPawn_OnEndWaterSprintBoost_Params
		{
			struct Vector3                                     NewScale;                                                 // (Parm, ZeroConstructor, IsPlainOldData)
		} params;

		params.NewScale = NewScale;

		sdkUssage->ProcessEvent(uintptr_t(this), fn, &params);
	}
	/*Vector3 RelativeRotation() {
		if (!Memory::IsValidPointer((uintptr_t)this)) return { 0, 0, 0 };
		return *(Vector3*)((uintptr_t)this + 0x128);
	}

	Vector3 GetComponentVelocity()
	{
		if (!Memory::IsValidPointer((uintptr_t)this)) return { 0, 0, 0 };
		StructsParams::USceneComponent_GetComponentVelocity_Params params;

		FN::ProcessEvent(uintptr_t(this), ObjectsAddresses::GetComponentVelocity, &params);

		return params.ReturnValue;
	}*/
};
class UFortVehicleFuelComponent {
public:
	
};
class APlayerController;
class AFortAthenaVehicle {
public:
	UFortVehicleFuelComponent* CachedFuelComponent() {
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return 0;
		return (UFortVehicleFuelComponent*)(*(uintptr_t*)((uintptr_t)this + 0x1060));
	}
};
class AFortPawn {
public:
	const wchar_t* ObjectName() {
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return (L"");
		return find::GetObjectName((ue::classes::UObject*)this);
	}
	
	APlayerState* PlayerState() {
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return 0;
		return (APlayerState*)(*(uintptr_t*)((uintptr_t)this + ue::cached::offsets::PlayerState));
	}
	ARootComponent* RootComponent() {
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return 0;
		return (ARootComponent*)(*(uintptr_t*)((uintptr_t)this + ue::cached::offsets::RootComponent));
	}
	APlayerController* PlayerController() {
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return 0;
		return (APlayerController*)(*(uintptr_t*)((uintptr_t)this + 0x30)); //wont change
	}
	void AimWhileJumping(bool action) {
		*(bool*)((uintptr_t)this + 0x4805) = action;
	}
	BOOL IsA(PVOID parentClass) {
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return false;
		ue::classes::UObject* object = (ue::classes::UObject*)this;
		for (auto super = object->Class; super; super = super->SuperClass) {
			if (super == parentClass) {
				return true;
			}
		}
		return false; 
	}
	uintptr_t Mesh() {
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return 0;
		return *(uintptr_t*)((uintptr_t)this + ue::cached::offsets::Mesh);
	}
	
	Vector3 GetBone(int Id)
	{
		if (!sdkUssage->isValidPointer(uintptr_t(this))) return { 0, 0, 0 };

		auto mesh = Mesh();
		if (!mesh) return { 0, 0, 0 };

		auto function = ((ue::FMatrix * (__fastcall*)(uintptr_t, ue::FMatrix*, int))(ue::cached::signatures::GetBoneMatrix));
		function(mesh, ue::myMatrix, Id);

		return { ue::myMatrix->M[3][0], ue::myMatrix->M[3][1], ue::myMatrix->M[3][2] };
	}
	AWeapon* CurrentWeapon() {
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return 0;
		return (AWeapon*)(*(uintptr_t*)((uintptr_t)this + ue::cached::offsets::CurrentWeapon));
	}
	AFortAthenaVehicle* GetVehicle() {

		if (!sdkUssage->isValidPointer((uintptr_t)this)) return 0;
		uintptr_t result;

		sdkUssage->ProcessEvent((uintptr_t)this, ue::cached::objects::actor::GetVehicle, &result);

		return (AFortAthenaVehicle*)result;
	}
	
	void ApplyPawnHighlight(ue::FLinearColor InnerCol, ue::FLinearColor OuterCol)
	{
		//AFortPawn -> ApplyPawnHighlight

		if (!sdkUssage->isValidPointer(uintptr_t(this))) return;

		struct APlayerPawn_Athena_C_ApplyPawnHighlight_Params
		{
			uintptr_t Source; // (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData)
			ue::FPawnHighlight HitGlow; // (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData)
		} params;

		ue::FPawnHighlight HitGlow;

		HitGlow.FresnelBrightness_23_52B0F96447FF640F47DF2895B0602E92 = 0.f;
		HitGlow.FresnelExponent_24_B427CF0C441AA37ED49833BF7579DE6D = 0;
		HitGlow.Inner_21_4CC2801147EA190DE16F59B34F36853E = { (float)InnerCol.R, (float)InnerCol.G, (float)InnerCol.B, (float)InnerCol.A };//{ 1.f, 0.f, 0.f, 1.f };//{ (float)col.R, (float)col.G, (float)col.B, (float)col.A };
		HitGlow.Outer_22_5A1D7D0543D303E8B54B66A7F7BD2E2E = { (float)OuterCol.R, (float)OuterCol.G, (float)OuterCol.B, (float)OuterCol.A };//{ 0.f, 1.f, 0.f, 1.f };//{ (float)col.R, (float)col.G, (float)col.B, (float)col.A };
		HitGlow.Priority_28_E2E1B5344846E187B9C11B863A7F0698 = 0.f;
		HitGlow.UsesPulse_25_E29229F64E540F0617E4C4987AD77605 = 0.f;


		params.Source = uintptr_t(this);
		params.HitGlow = HitGlow;

		sdkUssage->ProcessEvent(uintptr_t(this), ue::cached::objects::actor::ApplyPawnHighlight, &params);

	}
	VOID ScalePlayerUp()
	{
		//AFortPawn -> ApplyPawnHighlight

		if (!sdkUssage->isValidPointer(uintptr_t(this))) return;
		struct
		{
		} params;
		sdkUssage->ProcessEvent(uintptr_t(this), ue::cached::objects::actor::ScalePlayerUp, &params);

	}
	VOID ScalePlayerDown()
	{
		//AFortPawn -> ApplyPawnHighlight

		if (!sdkUssage->isValidPointer(uintptr_t(this))) return;
		struct
		{
		} params;
		sdkUssage->ProcessEvent(uintptr_t(this), ue::cached::objects::actor::ScalePlayerDown, &params);

	}
	VOID isHiddingInProp()
	{
		//AFortPawn -> ApplyPawnHighlight

		if (!sdkUssage->isValidPointer(uintptr_t(this))) return;
		struct
		{
			bool                                               IsHidden;                                                 // (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData)
		} params;
		params.IsHidden = true;
		sdkUssage->ProcessEvent(uintptr_t(this), ue::cached::objects::actor::isHiddingInProp, &params);

	}
	BOOL SetCharacterBodyVisibilityForPossession(bool bVisible)
	{
		//AFortPawn -> ApplyPawnHighlight

		if (!sdkUssage->isValidPointer(uintptr_t(this))) return 0;
		struct
		{
			bool                                               bVisible;                                                 // (Parm, ZeroConstructor, IsPlainOldData)
			bool                                               ReturnValue;                                              // (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)
		} params;
		params.bVisible = bVisible;
		sdkUssage->ProcessEvent(uintptr_t(this), ue::cached::objects::actor::SetCharacterBodyVisibilityForPossession, &params);

	}
	BOOL K2_SetActorLocation(const Vector3 NewLocation, bool bSweep, bool bTeleport)
	{
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return 0;

		struct
		{
			Vector3							NewLocation;
			bool							bSweep;
			int								SweepHitResult;
			bool							bTeleport;
			bool							ReturnValue;
		} params;

		params.NewLocation = NewLocation;
		params.bSweep = bSweep;
		params.bTeleport = bTeleport;

		sdkUssage->ProcessEvent((uintptr_t)this, ue::cached::objects::K2_SetActorLocation, &params);

		return params.ReturnValue;
	}
	BOOL K2_TeleportTo(const Vector3& DestLocation, const Vector3& DestRotation)
	{
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return 0;
		struct
		{
			Vector3										DestLocation;                                             // (Parm, ZeroConstructor, IsPlainOldData)
			Vector3										DestRotation;                                             // (Parm, ZeroConstructor, IsPlainOldData)
			bool										ReturnValue;                                              // (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)
		} params;
		
		params.DestLocation = DestLocation;
		params.DestRotation = DestRotation;

		sdkUssage->ProcessEvent((uintptr_t)this, ue::cached::objects::K2_TeleportTo, &params);

		return params.ReturnValue;
	}
};
class APlayerCameraManager {
public:
	Vector3 GetCameraLocation()
	{
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return { 0,0,0 };

		struct APlayerCameraManager_GetCameraLocation_Params
		{
			Vector3                                    ReturnValue;                                              // (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)
		};
		APlayerCameraManager_GetCameraLocation_Params params;

		sdkUssage->ProcessEvent((uintptr_t)this, ue::cached::objects::camera::GetCameraLocation, &params);

		return params.ReturnValue;
	}
	Vector3 GetCameraRotation()
	{
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return { 0,0,0 };

		
		struct APlayerCameraManager_GetCameraRotation_Params
		{
			Vector3                                    ReturnValue;                                              // (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)
		};
		APlayerCameraManager_GetCameraRotation_Params params;

		sdkUssage->ProcessEvent((uintptr_t)this, ue::cached::objects::camera::GetCameraRotation, &params);

		return params.ReturnValue;
	}
	float GetFOVAngle()
	{
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return 0;

		struct APlayerCameraManager_GetFOVAngle_Params
		{
			float                                              ReturnValue;                                              // (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)
		};

		APlayerCameraManager_GetFOVAngle_Params params;

		sdkUssage->ProcessEvent((uintptr_t)this, ue::cached::objects::camera::GetFOVAngle, &params);

		return params.ReturnValue;
	}
#define M_PI	3.14159265358979323846264338327950288419716939937510
	Vector2 ProjectWorldLocationToScreen(int SizeX, int SizeY, Vector3 world_location)
	{
		Vector3 CameraLocation = GetCameraLocation();

		Vector3 CameraRotation = GetCameraRotation();

		float FOVAngle = GetFOVAngle();


		Vector2 output;
		float delta[3];
		float sp = 0, cp = 0, sy = 0, cy = 0, sr = 0, cr = 0;
		float axisx[3];
		float axisy[3];
		float axisz[3];
		float transformed[3];

		delta[0] = world_location.x - CameraLocation.x;
		delta[1] = world_location.y - CameraLocation.y;
		delta[2] = world_location.z - CameraLocation.z;

		sp = crt::sinf(CameraRotation.x * M_PI / 180);
		cp = crt::cosf(CameraRotation.x * M_PI / 180);
		sy = crt::sinf(CameraRotation.y * M_PI / 180);
		cy = crt::cosf(CameraRotation.y * M_PI / 180);
		sr = crt::sinf(CameraRotation.z * M_PI / 180);
		cr = crt::cosf(CameraRotation.z * M_PI / 180);

		axisx[0] = cp * cy;
		axisx[1] = cp * sy;
		axisx[2] = sp;

		axisy[0] = sr * sp * cy - cr * sy;
		axisy[1] = sr * sp * sy + cr * cy;
		axisy[2] = -sr * cp;

		axisz[0] = -(cr * sp * cy + sr * sy);
		axisz[1] = cy * sr - cr * sp * sy;
		axisz[2] = cr * cp;

		transformed[0] = delta[0] * axisy[0] + delta[1] * axisy[1] + delta[2] * axisy[2];
		transformed[1] = delta[0] * axisz[0] + delta[1] * axisz[1] + delta[2] * axisz[2];
		transformed[2] = delta[0] * axisx[0] + delta[1] * axisx[1] + delta[2] * axisx[2];

		if (transformed[2] < 1)
			transformed[2] = 1;

		if (transformed[2] / 100 > 0)
		{
			float tmpx = 0, tmpy = 0;

			tmpx = (float)(SizeX / 2);
			tmpy = (float)(SizeY / 2);

			output.x = tmpx + transformed[0] * tmpx / crt::tanf(FOVAngle * M_PI / 360) / transformed[2];
			output.y = tmpy - transformed[1] * tmpx / crt::tanf(FOVAngle * M_PI / 360) / transformed[2];

			return output;
		}

		return Vector2(0, 0);
	}

};
enum class EFortResourceType : uint8_t
{
	Wood = 0,
	Stone = 1,
	Metal = 2,
	Permanite = 3,
	GoldCurrency = 4,
	Ingredient = 5,
	None = 6,
	EFortResourceType_MAX = 7
};
template<class TEnum>
class TEnumAsByte
{
public:
	inline TEnumAsByte()
	{
	}

	inline TEnumAsByte(TEnum _value)
		: value(static_cast<uint8_t>(_value))
	{
	}

	explicit inline TEnumAsByte(int32_t _value)
		: value(static_cast<uint8_t>(_value))
	{
	}

	explicit inline TEnumAsByte(uint8_t _value)
		: value(_value)
	{
	}

	inline operator TEnum() const
	{
		return (TEnum)value;
	}

	inline TEnum GetValue() const
	{
		return (TEnum)value;
	}

private:
	uint8_t value;
};
class APlayerController {
public:
	AFortPawn* LocalPawn() {
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return 0;
		return (AFortPawn*)(*(uintptr_t*)((uintptr_t)this + ue::cached::offsets::AcknowledgedPawn));
	}

	APlayerCameraManager* PlayerCameraManager() {
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return 0;
		return (APlayerCameraManager*)(*(uintptr_t*)(this + ue::cached::offsets::PlayerCameraManager));
	}
	Vector2 WorldToScreen(Vector3 WorldLocation)
	{
		
		if (!sdkUssage->isValidPointer(uintptr_t(this))) return Vector2(0, 0);

		Vector2 Output;

		auto WorldToScreen = reinterpret_cast<bool(__fastcall*)(uintptr_t, Vector3, Vector2*, char)>(ue::cached::signatures::ProjectWorldToScreen);
		WorldToScreen((uintptr_t)this, WorldLocation, &Output, (char)0);

		return { Output.x, Output.y };
	}
	BOOL ClientSetRotation(const Vector3& NewRotation, bool bResetCamera)
	{
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return 0;

		struct AController_ClientSetRotation_Params
		{
			Vector3										NewRotation;                                              // (Parm, ZeroConstructor, IsPlainOldData)
			bool										bResetCamera;                                             // (Parm, ZeroConstructor, IsPlainOldData)
		};

		AController_ClientSetRotation_Params params;
		params.NewRotation = NewRotation;
		params.bResetCamera = bResetCamera;

		sdkUssage->ProcessEvent(uintptr_t(this), ue::cached::objects::actor::ClientSetRotation, &params);
		return TRUE;
	}
	void Fov(float newfov)
	{
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return;

		struct APlayerController_FOV_Params
		{
			float                                              NewFOV;                                                   // (Parm, ZeroConstructor, IsPlainOldData)
		};

		APlayerController_FOV_Params params;
		params.NewFOV = newfov;

		sdkUssage->ProcessEvent(uintptr_t(this), ue::cached::objects::actor::Fov, &params);
	}
	bool IsInputKeyDown(const struct ue::FKey& Key)
	{
		static ue::classes::UObject* fn = NULL;
		if (!fn)
			fn = (ue::classes::UObject*)find::FindObject((L"Engine.PlayerController.IsInputKeyDown"));

		struct
		{
			struct ue::FKey                                        Key;                                                      // (Parm)
			bool                                               ReturnValue;                                              // (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)
		} params;
		params.Key = Key;


		sdkUssage->ProcessEvent(uintptr_t(this), fn, &params);


		return params.ReturnValue;
	}
	bool WasInputKeyJustPressed(const struct ue::FKey& Key)
	{
		static ue::classes::UObject* fn = NULL;
		if (!fn)
			fn = (ue::classes::UObject*)find::FindObject((L"Engine.PlayerController.WasInputKeyJustPressed"));

		struct
		{
			struct ue::FKey                                        Key;                                                      // (Parm)
			bool                                               ReturnValue;                                              // (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)
		} params;
		params.Key = Key;


		sdkUssage->ProcessEvent(uintptr_t(this), fn, &params);


		return params.ReturnValue;
	}
	bool GetMousePosition(float* LocationX, float* LocationY)
	{
		static ue::classes::UObject* fn = NULL;
		if (!fn)
			fn = (ue::classes::UObject*)find::FindObject((L"Engine.PlayerController.GetMousePosition"));
		

		struct
		{
			float                                              LocationX;                                                // (Parm, OutParm, ZeroConstructor, IsPlainOldData)
			float                                              LocationY;                                                // (Parm, OutParm, ZeroConstructor, IsPlainOldData)
			bool                                               ReturnValue;                                              // (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)
		} params;
		

		sdkUssage->ProcessEvent(uintptr_t(this), fn, &params);
		if (LocationX != nullptr)
			*LocationX = params.LocationX;
		if (LocationY != nullptr)
			*LocationY = params.LocationY;
		return params.ReturnValue;
	}
	void ServerSetVehicleHealth(float NewHealth)
	{
		static ue::classes::UObject* fn = NULL;
		if (!fn)
			fn = (ue::classes::UObject*)find::FindObject((L"FortniteGame.FortPlayerControllerZone.ServerSetVehicleHealth"));

		struct
		{
			float                                              NewHealth;                                                // (Parm, ZeroConstructor, IsPlainOldData)
		} params;
		params.NewHealth = NewHealth;


		sdkUssage->ProcessEvent(uintptr_t(this), fn, &params);
	}
	void EditModeDistance() {
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return;
		*(float*)((uintptr_t)this + 0x19a8) = 20;
	}
	void TurboBuildInterval() {
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return;
		*(float*)((uintptr_t)this + 0x28a8) = 0000.1;
	}

	
};
class UViewportClient {
public:

};
class ULocalPlayer {
public:
	APlayerController* PlayerController() {
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return 0;
		return (APlayerController*)(*(uintptr_t*)((uintptr_t)this + 0x30)); //wont change
	}
	UViewportClient* ViewportClient() {
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return 0;
		return (UViewportClient*)(*(uintptr_t*)((uintptr_t)this + 0x70)); //wont change
	}

};
class ULocalPlayers {
public:
	ULocalPlayer* LocalPlayer() {
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return 0;
		return (ULocalPlayer*)(*(uintptr_t*)((uintptr_t)this));
	}
};
class UGameInstance {
public:
	ULocalPlayers* LocalPlayers() {
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return 0;
		return (ULocalPlayers*)(*(uintptr_t*)((uintptr_t)this + 0x38)); //wont change
	}
};
class AActors {
public:

	AFortPawn* GetCurrentActor(int i) {
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return 0;
		return (AFortPawn*)(*(uintptr_t*)(this + i * sizeof(uintptr_t)));
	}
};
class ULevel {
public:
	

	
	int ActorCount() {
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return 0;
		return (int)(*(uintptr_t*)(this + 0xA0)); //wont change
	}
	ue::TArray<AFortPawn*> ActorArray() {
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return {};
		return *(ue::TArray<AFortPawn*>*)((uintptr_t)this + 0x98); //wont change
	}
	AActors* Actors() {
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return 0;
		return (AActors*)(*(uintptr_t*)(this + 0x98)); //wont change
	}
};
class GWorld {
public: 
	UGameInstance* OwningGameInstance() {
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return 0;
		return (UGameInstance*)(*(uintptr_t*)((uintptr_t)this + ue::cached::offsets::OwningGameInstance));
	}
	ue::TArray<ULevel*> Levels() {
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return {};
		return *(ue::TArray<ULevel*>*)((uintptr_t)this + ue::cached::offsets::Levels);
	}
	ULevel* PersistentLevel() {
		if (!sdkUssage->isValidPointer((uintptr_t)this)) return 0;
		return (ULevel*)(*(uintptr_t*)(this + 0x30)); //wont change
	}
};

```

`sdkdefines.h`:

```h
#pragma once
#include "vector.h"
#include <xmmintrin.h>
#include <immintrin.h>
namespace ue {
	struct FVector
	{
		double X;
		double Y;
		double Z;
	};
	struct FMatrix
	{
		double M[4][4];


	};
	static FMatrix* myMatrix = new FMatrix();

	template<class T>
	struct TArray
	{
		friend struct FString;

	public:
		inline TArray()
		{
			Data = nullptr;
			Count = Max = 0;
		};

		inline int Num() const
		{
			return Count;
		};

		inline T& operator[](int i)
		{
			return Data[i];
		};

		inline const T& operator[](int i) const
		{
			return Data[i];
		};

		inline bool IsValidIndex(int i) const
		{
			return i < Num();
		}

	private:
		T* Data;
		int32_t Count;
		int32_t Max;
	};

	struct FString : private TArray<wchar_t>
	{
		inline FString()
		{
		};

		FString(const wchar_t* other)
		{
			Max = Count = *other ? wcslen(other) + 1 : 0;

			if (Count)
			{
				Data = const_cast<wchar_t*>(other);
			}
		};

		inline bool IsValid() const
		{
			return Data != nullptr;
		}

		inline const wchar_t* c_str() const
		{
			return Data;
		}
		std::string ToString() const
		{
			auto length = std::wcslen(Data);

			std::string str(length, '\0');

			std::use_facet<std::ctype<wchar_t>>(std::locale()).narrow(Data, Data + length, '?', &str[0]);

			return str;
		}
	};

	struct FName
	{
		uint32_t ComparisonIndex;
		uint32_t DisplayIndex;
	};

	struct FKey
	{
		FName KeyName;
		unsigned char Padding_00[0x10];
	};

	struct FLinearColor
	{
		float R;
		float G;
		float B;
		float A;

		FLinearColor()
		{
			R = G = B = A = 0;
		}

		FLinearColor(float R, float G, float B, float A)
		{
			this->R = R;
			this->G = G;
			this->B = B;
			this->A = A;
		}
	};
	struct FPawnHighlight
	{
		float                                              Priority_28_E2E1B5344846E187B9C11B863A7F0698;             // 0x0000(0x0004) (Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData)
		FLinearColor                                Inner_21_4CC2801147EA190DE16F59B34F36853E;                // 0x0004(0x0010) (Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData)
		FLinearColor                                Outer_22_5A1D7D0543D303E8B54B66A7F7BD2E2E;                // 0x0014(0x0010) (Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData)
		float                                              FresnelBrightness_23_52B0F96447FF640F47DF2895B0602E92;    // 0x0024(0x0004) (Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData)
		float                                              FresnelExponent_24_B427CF0C441AA37ED49833BF7579DE6D;      // 0x0028(0x0004) (Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData)
		float                                              UsesPulse_25_E29229F64E540F0617E4C4987AD77605;            // 0x002C(0x0004) (Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData)
	};
	struct FRotator
	{
		double Pitch;
		double Yaw;
		double Roll;
	};

	struct FMinimalViewInfo {
		Vector3 Location;
		Vector3 Rotation;
		float FOV;
		float OrthoWidth;
		float OrthoNearClipPlane;
		float OrthoFarClipPlane;
		float AspectRatio;
	};

	class FTextData {
	public:
		char pad_0x0000[0x30];  //0x0000
		wchar_t* Name;          //0x0028 
		__int32 Length;         //0x0030 

	};

	struct FText {
		FTextData* Data;
		char UnknownData[0x10];

		wchar_t* Get() const {
			if (Data) {
				return Data->Name;
			}

			return nullptr;
		}
	};
	namespace classes
	{
		class UClass {
		public:
			BYTE _padding_0[0x40];
			UClass* SuperClass;
		};

		class UObject {
		public:
			PVOID VTableObject;
			DWORD ObjectFlags;
			DWORD InternalIndex;
			UClass* Class;
			BYTE _padding_0[0x8];
			UObject* Outer;

			inline BOOLEAN IsA(PVOID parentClass)
			{
				for (auto super = this->Class; super; super = super->SuperClass)
					if (super == parentClass)
						return true;

				return false;
			}
		};

		class UControl
		{
		public:
			Vector2 Origin;
			Vector2 Size;
			bool* BoundBool = nullptr;
			bool bIsMenuTabControl;
			bool bIsRangeSlider;
			int RangeValueMin;
			int RangeValueMax;
			int* pBoundRangeValue;
			int BoundMenuTabIndex;

			bool ContainsPoint(Vector2 pt)
			{
				auto extent = Origin + Size;
				return (pt.x > Origin.x && pt.y > Origin.y && pt.x < extent.x&& pt.y < extent.y);
			}
		};

		class FUObjectItem {
		public:
			UObject* Object;
			DWORD Flags;
			DWORD ClusterIndex;
			DWORD SerialNumber;
			DWORD SerialNumber2;
		};

		class TUObjectArray {
		public:
			FUObjectItem* Objects[9];
		};

		class GObjects {
		public:
			TUObjectArray* ObjectArray;
			BYTE _padding_0[0xC];
			DWORD ObjectCount;
		};

		inline GObjects* objects = nullptr;
	}
	namespace cached {
		inline uintptr_t Base = 0;

		namespace keys
		{
			inline ue::FKey LButton;
			inline ue::FKey Insert;
		}
		namespace offsets {
			inline uintptr_t OwningGameInstance;
			inline uintptr_t Levels;
			inline uintptr_t AcknowledgedPawn;
			inline uintptr_t PlayerCameraManager;
			inline uintptr_t PlayerState;
			inline uintptr_t bADSWhileNotOnGround;
			inline uintptr_t CurrentWeapon;
			inline uintptr_t TeamIndex;
			inline uintptr_t WeaponData;
			inline uintptr_t DisplayName;
			inline uintptr_t Mesh;
			inline uintptr_t RootComponent;
			inline uintptr_t LastFireTime;
			inline uintptr_t AmmoCount;
			inline uintptr_t LastFireTimeVerified;
			inline uintptr_t RelativeLocation;
			inline uintptr_t Tier;
		}
		namespace signatures
		{
			inline uintptr_t GWorld = 0;
			inline uintptr_t FreeFn = 0;
			
			inline uintptr_t GetNameByIndex = 0;
			inline uintptr_t LineSightOfTo = 0;
			inline uintptr_t GetBoneMatrix = 0;
			inline uintptr_t ProjectWorldToScreen = 0;
			
		}
		inline  ue::classes::UObject* FortKismetLibrary = 0;
		inline  ue::classes::UObject* KismetStringLibrary = 0;
		inline  ue::classes::UObject* KismetMathLibrary = 0;
		inline  ue::classes::UObject* Conv_StringToName = 0;
		inline  ue::classes::UObject* Cos = 0;
		inline  ue::classes::UObject* Sin = 0;


		namespace objects {
			inline ue::classes::UObject* FortProjectileBase = 0;
			inline ue::classes::UObject* AFortAthenaZipline = 0;
			inline ue::classes::UObject* K2_SetActorLocation = 0;
			inline ue::classes::UObject* K2_TeleportTo = 0;
			inline ue::classes::UObject* FortRangedWeaponStats = 0;
			inline ue::classes::UObject* K2_GetActorRotation = 0;
			

			namespace actor {
				inline  ue::classes::UObject* FortPlayerPawnAthena = 0;
				inline  ue::classes::UObject* ClientSetRotation = 0;
				inline  ue::classes::UObject* GetPlayerName = 0;
				inline  ue::classes::UObject* ApplyPawnHighlight = 0;
				inline  ue::classes::UObject* ScalePlayerUp = 0;
				inline  ue::classes::UObject* ScalePlayerDown = 0;
				inline  ue::classes::UObject* isHiddingInProp = 0;
				inline  ue::classes::UObject* Fov = 0;
				inline  ue::classes::UObject* SetMouseLocation = 0;
				inline  ue::classes::UObject* SetCharacterBodyVisibilityForPossession = 0;
				inline  ue::classes::UObject* K2_PayBuildingResourceCost = 0;
				inline  ue::classes::UObject* GetVehicle = 0;
				

				
				

				
				
				
			}
			namespace camera {
				inline ue::classes::UObject* GetCameraLocation = 0; 
				inline ue::classes::UObject* GetCameraRotation = 0;
				inline ue::classes::UObject* GetFOVAngle = 0;
			}
			

			namespace render {
				inline ue::classes::UObject* Font = 0;
				inline ue::classes::UObject* K2_DrawLine = 0;
				inline ue::classes::UObject* K2_DrawBox = 0;
				inline ue::classes::UObject* K2_DrawText = 0;
				inline ue::classes::UObject* K2_TextSize = 0;
			}

		}

	}
}
namespace math {
	inline float custom_sqrtf(float _X)
	{
		return _mm_cvtss_f32(_mm_sqrt_ss(_mm_set_ss(_X)));
	}

	inline float custom_sinf(float _X)
	{
		return _mm_cvtss_f32(_mm_sin_ps(_mm_set_ss(_X)));
	}

	inline float custom_cosf(float _X)
	{
		return _mm_cvtss_f32(_mm_cos_ps(_mm_set_ss(_X)));
	}

	inline float custom_acosf(float _X)
	{
		return _mm_cvtss_f32(_mm_acos_ps(_mm_set_ss(_X)));
	}

	inline float custom_tanf(float _X)
	{
		return _mm_cvtss_f32(_mm_tan_ps(_mm_set_ss(_X)));
	}

	inline float custom_atan2f(float _X, float _Y)
	{
		return _mm_cvtss_f32(_mm_atan2_ps(_mm_set_ss(_X), _mm_set_ss(_Y)));
	}

	inline int custom_compare(const char* X, const char* Y)
	{
		while (*X && *Y) {
			if (*X != *Y) {
				return 0;
			}
			X++;
			Y++;
		}

		return (*Y == '\0');
	}

	inline int custom_wcompare(const wchar_t* X, const wchar_t* Y)
	{
		while (*X && *Y) {
			if (*X != *Y) {
				return 0;
			}
			X++;
			Y++;
		}

		return (*Y == L'\0');
	}

	inline const wchar_t* custom_wcsstr(const wchar_t* X, const wchar_t* Y)
	{
		while (*X != L'\0') {
			if ((*X == *Y) && custom_wcompare(X, Y)) {
				return X;
			}
			X++;
		}
		return NULL;
	}

	inline const char* custom_strstr(const char* X, const char* Y)
	{
		while (*X != '\0') {
			if ((*X == *Y) && custom_compare(X, Y)) {
				return X;
			}
			X++;
		}
		return NULL;
	}

	inline int custom_strlen(const char* string)
	{
		int cnt = 0;
		if (string)
		{
			for (; *string != 0; ++string) ++cnt;
		}
		return cnt;
	}

	inline int custom_wcslen(const wchar_t* string)
	{
		int cnt = 0;
		if (string)
		{
			for (; *string != 0; ++string) ++cnt;
		}
		return cnt;
	}
}

//namespace Colors
//{
//	ue::FLinearColor AliceBlue = { 0.941176534f, 0.972549081f, 1.000000000f, 1.000000000f };
//	ue::FLinearColor AntiqueWhite = { 0.980392218f, 0.921568692f, 0.843137324f, 1.000000000f };
//	ue::FLinearColor Aqua = { 0.000000000f, 1.000000000f, 1.000000000f, 1.000000000f };
//	ue::FLinearColor Aquamarine = { 0.498039246f, 1.000000000f, 0.831372619f, 1.000000000f };
//	ue::FLinearColor Azure = { 0.941176534f, 1.000000000f, 1.000000000f, 1.000000000f };
//	ue::FLinearColor Beige = { 0.960784376f, 0.960784376f, 0.862745166f, 1.000000000f };
//	ue::FLinearColor Bisque = { 1.000000000f, 0.894117713f, 0.768627524f, 1.000000000f };
//	ue::FLinearColor Black = { 0.000000000f, 0.000000000f, 0.000000000f, 1.000000000f };
//	ue::FLinearColor BlanchedAlmond = { 1.000000000f, 0.921568692f, 0.803921640f, 1.000000000f };
//	ue::FLinearColor Blue = { 0.000000000f, 0.000000000f, 1.000000000f, 1.000000000f };
//	ue::FLinearColor BlueViolet = { 0.541176498f, 0.168627456f, 0.886274576f, 1.000000000f };
//	ue::FLinearColor Brown = { 0.647058845f, 0.164705887f, 0.164705887f, 1.000000000f };
//	ue::FLinearColor BurlyWood = { 0.870588303f, 0.721568644f, 0.529411793f, 1.000000000f };
//	ue::FLinearColor CadetBlue = { 0.372549027f, 0.619607866f, 0.627451003f, 1.000000000f };
//	ue::FLinearColor Chartreuse = { 0.498039246f, 1.000000000f, 0.000000000f, 1.000000000f };
//	ue::FLinearColor Chocolate = { 0.823529482f, 0.411764741f, 0.117647067f, 1.000000000f };
//	ue::FLinearColor Coral = { 1.000000000f, 0.498039246f, 0.313725501f, 1.000000000f };
//	ue::FLinearColor CornflowerBlue = { 0.392156899f, 0.584313750f, 0.929411829f, 1.000000000f };
//	ue::FLinearColor Cornsilk = { 1.000000000f, 0.972549081f, 0.862745166f, 1.000000000f };
//	ue::FLinearColor Crimson = { 0.862745166f, 0.078431375f, 0.235294133f, 1.000000000f };
//	ue::FLinearColor Cyan = { 0.000000000f, 1.000000000f, 1.000000000f, 1.000000000f };
//	ue::FLinearColor DarkBlue = { 0.000000000f, 0.000000000f, 0.545098066f, 1.000000000f };
//	ue::FLinearColor DarkCyan = { 0.000000000f, 0.545098066f, 0.545098066f, 1.000000000f };
//	ue::FLinearColor DarkGoldenrod = { 0.721568644f, 0.525490224f, 0.043137256f, 1.000000000f };
//	ue::FLinearColor DarkGray = { 0.662745118f, 0.662745118f, 0.662745118f, 1.000000000f };
//	ue::FLinearColor DarkGreen = { 0.000000000f, 0.392156899f, 0.000000000f, 1.000000000f };
//	ue::FLinearColor DarkKhaki = { 0.741176486f, 0.717647076f, 0.419607878f, 1.000000000f };
//	ue::FLinearColor DarkMagenta = { 0.545098066f, 0.000000000f, 0.545098066f, 1.000000000f };
//	ue::FLinearColor DarkOliveGreen = { 0.333333343f, 0.419607878f, 0.184313729f, 1.000000000f };
//	ue::FLinearColor DarkOrange = { 1.000000000f, 0.549019635f, 0.000000000f, 1.000000000f };
//	ue::FLinearColor DarkOrchid = { 0.600000024f, 0.196078449f, 0.800000072f, 1.000000000f };
//	ue::FLinearColor DarkRed = { 0.545098066f, 0.000000000f, 0.000000000f, 1.000000000f };
//	ue::FLinearColor DarkSalmon = { 0.913725555f, 0.588235319f, 0.478431404f, 1.000000000f };
//	ue::FLinearColor DarkSeaGreen = { 0.560784340f, 0.737254918f, 0.545098066f, 1.000000000f };
//	ue::FLinearColor DarkSlateBlue = { 0.282352954f, 0.239215702f, 0.545098066f, 1.000000000f };
//	ue::FLinearColor DarkSlateGray = { 0.120f, 0.120f, 0.120f, 1.000000000f };
//	ue::FLinearColor DarkTurquoise = { 0.000000000f, 0.807843208f, 0.819607913f, 1.000000000f };
//	ue::FLinearColor DarkViolet = { 0.580392182f, 0.000000000f, 0.827451050f, 1.000000000f };
//	ue::FLinearColor DeepPink = { 1.000000000f, 0.078431375f, 0.576470613f, 1.000000000f };
//	ue::FLinearColor DeepSkyBlue = { 0.000000000f, 0.749019623f, 1.000000000f, 1.000000000f };
//	ue::FLinearColor DimGray = { 0.411764741f, 0.411764741f, 0.411764741f, 1.000000000f };
//	ue::FLinearColor DodgerBlue = { 0.117647067f, 0.564705908f, 1.000000000f, 1.000000000f };
//	ue::FLinearColor Firebrick = { 0.698039234f, 0.133333340f, 0.133333340f, 1.000000000f };
//	ue::FLinearColor FloralWhite = { 1.000000000f, 0.980392218f, 0.941176534f, 1.000000000f };
//	ue::FLinearColor ForestGreen = { 0.133333340f, 0.545098066f, 0.133333340f, 1.000000000f };
//	ue::FLinearColor Fuchsia = { 1.000000000f, 0.000000000f, 1.000000000f, 1.000000000f };
//	ue::FLinearColor Gainsboro = { 0.862745166f, 0.862745166f, 0.862745166f, 1.000000000f };
//	ue::FLinearColor GhostWhite = { 0.972549081f, 0.972549081f, 1.000000000f, 1.000000000f };
//	ue::FLinearColor Gold = { 1.000000000f, 0.843137324f, 0.000000000f, 1.000000000f };
//	ue::FLinearColor Goldenrod = { 0.854902029f, 0.647058845f, 0.125490203f, 1.000000000f };
//	ue::FLinearColor Gray = { 0.501960814f, 0.501960814f, 0.501960814f, 1.000000000f };
//	ue::FLinearColor Green = { 0.000000000f, 0.501960814f, 0.000000000f, 1.000000000f };
//	ue::FLinearColor GreenYellow = { 0.678431392f, 1.000000000f, 0.184313729f, 1.000000000f };
//	ue::FLinearColor Honeydew = { 0.941176534f, 1.000000000f, 0.941176534f, 1.000000000f };
//	ue::FLinearColor HotPink = { 1.000000000f, 0.411764741f, 0.705882370f, 1.000000000f };
//	ue::FLinearColor IndianRed = { 0.803921640f, 0.360784322f, 0.360784322f, 1.000000000f };
//	ue::FLinearColor Indigo = { 0.294117659f, 0.000000000f, 0.509803951f, 1.000000000f };
//	ue::FLinearColor Ivory = { 1.000000000f, 1.000000000f, 0.941176534f, 1.000000000f };
//	ue::FLinearColor Khaki = { 0.941176534f, 0.901960850f, 0.549019635f, 1.000000000f };
//	ue::FLinearColor Lavender = { 0.901960850f, 0.901960850f, 0.980392218f, 1.000000000f };
//	ue::FLinearColor LavenderBlush = { 1.000000000f, 0.941176534f, 0.960784376f, 1.000000000f };
//	ue::FLinearColor LawnGreen = { 0.486274540f, 0.988235354f, 0.000000000f, 1.000000000f };
//	ue::FLinearColor LemonChiffon = { 1.000000000f, 0.980392218f, 0.803921640f, 1.000000000f };
//	ue::FLinearColor LightBlue = { 0.678431392f, 0.847058892f, 0.901960850f, 1.000000000f };
//	ue::FLinearColor LightCoral = { 0.941176534f, 0.501960814f, 0.501960814f, 1.000000000f };
//	ue::FLinearColor LightCyan = { 0.878431439f, 1.000000000f, 1.000000000f, 1.000000000f };
//	ue::FLinearColor LightGoldenrodYellow = { 0.980392218f, 0.980392218f, 0.823529482f, 1.000000000f };
//	ue::FLinearColor LightGreen = { 0.564705908f, 0.933333397f, 0.564705908f, 1.000000000f };
//	ue::FLinearColor LightGray = { 0.827451050f, 0.827451050f, 0.827451050f, 1.000000000f };
//	ue::FLinearColor LightPink = { 1.000000000f, 0.713725507f, 0.756862819f, 1.000000000f };
//	ue::FLinearColor LightSalmon = { 1.000000000f, 0.627451003f, 0.478431404f, 1.000000000f };
//	ue::FLinearColor LightSeaGreen = { 0.125490203f, 0.698039234f, 0.666666687f, 1.000000000f };
//	ue::FLinearColor LightSkyBlue = { 0.529411793f, 0.807843208f, 0.980392218f, 1.000000000f };
//	ue::FLinearColor LightSlateGray = { 0.466666698f, 0.533333361f, 0.600000024f, 1.000000000f };
//	ue::FLinearColor LightSteelBlue = { 0.690196097f, 0.768627524f, 0.870588303f, 1.000000000f };
//	ue::FLinearColor LightYellow = { 1.000000000f, 1.000000000f, 0.878431439f, 1.000000000f };
//	ue::FLinearColor Lime = { 0.000000000f, 1.000000000f, 0.000000000f, 1.000000000f };
//	ue::FLinearColor LimeGreen = { 0.196078449f, 0.803921640f, 0.196078449f, 1.000000000f };
//	ue::FLinearColor Linen = { 0.980392218f, 0.941176534f, 0.901960850f, 1.000000000f };
//	ue::FLinearColor Magenta = { 1.000000000f, 0.000000000f, 1.000000000f, 1.000000000f };
//	ue::FLinearColor Maroon = { 0.501960814f, 0.000000000f, 0.000000000f, 1.000000000f };
//	ue::FLinearColor MediumAquamarine = { 0.400000036f, 0.803921640f, 0.666666687f, 1.000000000f };
//	ue::FLinearColor MediumBlue = { 0.000000000f, 0.000000000f, 0.803921640f, 1.000000000f };
//	ue::FLinearColor MediumOrchid = { 0.729411781f, 0.333333343f, 0.827451050f, 1.000000000f };
//	ue::FLinearColor MediumPurple = { 0.576470613f, 0.439215720f, 0.858823597f, 1.000000000f };
//	ue::FLinearColor MediumSeaGreen = { 0.235294133f, 0.701960802f, 0.443137288f, 1.000000000f };
//	ue::FLinearColor MediumSlateBlue = { 0.482352972f, 0.407843173f, 0.933333397f, 1.000000000f };
//	ue::FLinearColor MediumSpringGreen = { 0.000000000f, 0.980392218f, 0.603921592f, 1.000000000f };
//	ue::FLinearColor MediumTurquoise = { 0.282352954f, 0.819607913f, 0.800000072f, 1.000000000f };
//	ue::FLinearColor MediumVioletRed = { 0.780392230f, 0.082352944f, 0.521568656f, 1.000000000f };
//	ue::FLinearColor MidnightBlue = { 0.098039225f, 0.098039225f, 0.439215720f, 1.000000000f };
//	ue::FLinearColor MintCream = { 0.960784376f, 1.000000000f, 0.980392218f, 1.000000000f };
//	ue::FLinearColor MistyRose = { 1.000000000f, 0.894117713f, 0.882353008f, 1.000000000f };
//	ue::FLinearColor Moccasin = { 1.000000000f, 0.894117713f, 0.709803939f, 1.000000000f };
//	ue::FLinearColor NavajoWhite = { 1.000000000f, 0.870588303f, 0.678431392f, 1.000000000f };
//	ue::FLinearColor Navy = { 0.000000000f, 0.000000000f, 0.501960814f, 1.000000000f };
//	ue::FLinearColor OldLace = { 0.992156923f, 0.960784376f, 0.901960850f, 1.000000000f };
//	ue::FLinearColor Olive = { 0.501960814f, 0.501960814f, 0.000000000f, 1.000000000f };
//	ue::FLinearColor OliveDrab = { 0.419607878f, 0.556862772f, 0.137254909f, 1.000000000f };
//	ue::FLinearColor Orange = { 1.000000000f, 0.647058845f, 0.000000000f, 1.000000000f };
//	ue::FLinearColor OrangeRed = { 1.000000000f, 0.270588249f, 0.000000000f, 1.000000000f };
//	ue::FLinearColor Orchid = { 0.854902029f, 0.439215720f, 0.839215755f, 1.000000000f };
//	ue::FLinearColor PaleGoldenrod = { 0.933333397f, 0.909803987f, 0.666666687f, 1.000000000f };
//	ue::FLinearColor PaleGreen = { 0.596078455f, 0.984313786f, 0.596078455f, 1.000000000f };
//	ue::FLinearColor PaleTurquoise = { 0.686274529f, 0.933333397f, 0.933333397f, 1.000000000f };
//	ue::FLinearColor PaleVioletRed = { 0.858823597f, 0.439215720f, 0.576470613f, 1.000000000f };
//	ue::FLinearColor PapayaWhip = { 1.000000000f, 0.937254965f, 0.835294187f, 1.000000000f };
//	ue::FLinearColor PeachPuff = { 1.000000000f, 0.854902029f, 0.725490212f, 1.000000000f };
//	ue::FLinearColor Peru = { 0.803921640f, 0.521568656f, 0.247058839f, 1.000000000f };
//	ue::FLinearColor Pink = { 1.000000000f, 0.752941251f, 0.796078503f, 1.000000000f };
//	ue::FLinearColor Plum = { 0.866666734f, 0.627451003f, 0.866666734f, 1.000000000f };
//	ue::FLinearColor PowderBlue = { 0.690196097f, 0.878431439f, 0.901960850f, 1.000000000f };
//	ue::FLinearColor Purple = { 0.501960814f, 0.000000000f, 0.501960814f, 1.000000000f };
//	ue::FLinearColor Red = { 1.f, 0.f, 0.f, 1.f };
//	ue::FLinearColor RosyBrown = { 0.737254918f, 0.560784340f, 0.560784340f, 1.000000000f };
//	ue::FLinearColor RoyalBlue = { 0.254901975f, 0.411764741f, 0.882353008f, 1.000000000f };
//	ue::FLinearColor SaddleBrown = { 0.545098066f, 0.270588249f, 0.074509807f, 1.000000000f };
//	ue::FLinearColor Salmon = { 0.980392218f, 0.501960814f, 0.447058856f, 1.000000000f };
//	ue::FLinearColor SandyBrown = { 0.956862807f, 0.643137276f, 0.376470625f, 1.000000000f };
//	ue::FLinearColor SeaGreen = { 0.180392161f, 0.545098066f, 0.341176480f, 1.000000000f };
//	ue::FLinearColor SeaShell = { 1.000000000f, 0.960784376f, 0.933333397f, 1.000000000f };
//	ue::FLinearColor Sienna = { 0.627451003f, 0.321568638f, 0.176470593f, 1.000000000f };
//	ue::FLinearColor Silver = { 0.752941251f, 0.752941251f, 0.752941251f, 1.000000000f };
//	ue::FLinearColor SkyBlue = { 0.529411793f, 0.807843208f, 0.921568692f, 1.000000000f };
//	ue::FLinearColor SlateBlue = { 0.415686309f, 0.352941185f, 0.803921640f, 1.000000000f };
//	ue::FLinearColor SlateGray = { 0.720, 0.720, 0.720, 1.000000000f };
//	ue::FLinearColor Snow = { 1.000000000f, 0.980392218f, 0.980392218f, 1.000000000f };
//	ue::FLinearColor SpringGreen = { 0.000000000f, 1.000000000f, 0.498039246f, 1.000000000f };
//	ue::FLinearColor SteelBlue = { 0.274509817f, 0.509803951f, 0.705882370f, 1.000000000f };
//	ue::FLinearColor Tan = { 0.823529482f, 0.705882370f, 0.549019635f, 1.000000000f };
//	ue::FLinearColor Teal = { 0.000000000f, 0.501960814f, 0.501960814f, 1.000000000f };
//	ue::FLinearColor Thistle = { 0.847058892f, 0.749019623f, 0.847058892f, 1.000000000f };
//	ue::FLinearColor Tomato = { 1.000000000f, 0.388235331f, 0.278431386f, 1.000000000f };
//	ue::FLinearColor Transparent = { 0.000000000f, 0.000000000f, 0.000000000f, 0.000000000f };
//	ue::FLinearColor Turquoise = { 0.250980407f, 0.878431439f, 0.815686345f, 1.000000000f };
//	ue::FLinearColor Violet = { 0.933333397f, 0.509803951f, 0.933333397f, 1.000000000f };
//	ue::FLinearColor Wheat = { 0.960784376f, 0.870588303f, 0.701960802f, 1.000000000f };
//	ue::FLinearColor White = { 1.000000000f, 1.000000000f, 1.0f, 1.000000000f };
//	ue::FLinearColor WhiteSmoke = { 0.960784376f, 0.960784376f, 0.960784376f, 1.000000000f };
//	ue::FLinearColor Yellow = { 1.000000000f, 1.000000000f, 0.000000000f, 1.000000000f };
//	ue::FLinearColor YellowGreen = { 0.603921592f, 0.803921640f, 0.196078449f, 1.000000000f };
//};
```

`spoof_call.h`:

```h
#pragma once

#include <iostream>
#include <fstream>
#include <vector>
#include <iomanip>
#include <algorithm>
#include <windows.h>

#include "sdkdefines.h"

uintptr_t get_base_address(const wchar_t* mod_name);

namespace detail
{
	extern "C" void* _spoofer_stub();

	template <typename Ret, typename... Args>
	static inline auto shellcode_stub_helper(
		const void* shell,
		Args... args
	) -> Ret
	{
		auto fn = (Ret(*)(Args...))(shell);
		return fn(args...);
	}

	template <std::size_t Argc, typename>
	struct argument_remapper
	{
		template<
			typename Ret,
			typename First,
			typename Second,
			typename Third,
			typename Fourth,
			typename... Pack
		>
			static auto do_call(const void* shell, void* shell_param, First first, Second second,
				Third third, Fourth fourth, Pack... pack) -> Ret
		{
			return shellcode_stub_helper< Ret, First, Second, Third, Fourth, void*, void*, Pack... >(shell, first, second, third, fourth, shell_param, nullptr, pack...);
		}
	};

	template <std::size_t Argc>
	struct argument_remapper<Argc, std::enable_if_t<Argc <= 4>>
	{
		template<
			typename Ret,
			typename First = void*,
			typename Second = void*,
			typename Third = void*,
			typename Fourth = void*
		>
			static auto do_call(
				const void* shell,
				void* shell_param,
				First first = First{},
				Second second = Second{},
				Third third = Third{},
				Fourth fourth = Fourth{}
			) -> Ret
		{
			return shellcode_stub_helper<
				Ret,
				First,
				Second,
				Third,
				Fourth,
				void*,
				void*
			>(
				shell,
				first,
				second,
				third,
				fourth,
				shell_param,
				nullptr
				);
		}
	};
}



template <typename Ret, typename... Args>
static inline auto spoof_call(Ret(*fn)(Args...), Args... args) -> Ret
{
	static const void* jmprbx = nullptr;
	if (!jmprbx) {

		const auto ntdll = reinterpret_cast<const unsigned char*>(ue::cached::Base);
		const auto dos = reinterpret_cast<const IMAGE_DOS_HEADER*>(ntdll);
		const auto nt = reinterpret_cast<const IMAGE_NT_HEADERS*>(ntdll + dos->e_lfanew);
		const auto sections = IMAGE_FIRST_SECTION(nt);
		const auto num_sections = nt->FileHeader.NumberOfSections;

		constexpr char section_name[5]{ '.', 't', 'e', 'x', 't' };
		const auto     section = std::find_if(sections, sections + num_sections, [&](const auto& s) {
			return std::equal(s.Name, s.Name + 5, section_name);
			});

		constexpr unsigned char instr_bytes[2]{ 0xFF, 0x26 };
		const auto              va = ntdll + section->VirtualAddress;
		jmprbx = std::search(va, va + section->Misc.VirtualSize, instr_bytes, instr_bytes + 2);
	}

	struct shell_params
	{
		const void* trampoline;
		void* function;
		void* rdx;
	};

	shell_params p
	{
		jmprbx,
		reinterpret_cast<void*>(fn)
	};

	using mapper = detail::argument_remapper<sizeof...(Args), void>;
	return mapper::template do_call<Ret, Args...>((const void*)&detail::_spoofer_stub, &p, args...);
}
```

`spoofinternal.asm`:

```asm
PUBLIC _spoofer_stub
 
.code
 
_spoofer_stub PROC
    pop r11
    add rsp, 8
    mov rax, [rsp + 24]
    
    mov r10, [rax]
    mov [rsp], r10
    
    mov r10, [rax + 8] 
    mov [rax + 8], r11 
 
    mov [rax + 16], rsi
    lea rsi, fixup
    mov [rax], rsi
    mov rsi, rax
    
    jmp r10
 
fixup:
    sub rsp, 16
    mov rcx, rsi
    mov rsi, [rcx + 16]
    jmp QWORD PTR [rcx + 8]
_spoofer_stub ENDP
 
END 
```

`vector.h`:

```h
#pragma once
#include <corecrt_math.h>

class Vector2
{
public:
	double x, y;
	Vector2()
	{
		x = y = 0.f;
	}

	Vector2(double _x, double _y)
	{
		x = _x;
		y = _y;
	}

	Vector2 operator+(const Vector2& v) {
		return Vector2{ x + v.x, y + v.y };
	}


	Vector2 operator-(const Vector2& v) {
		return Vector2{ x - v.x, y - v.y };
	}

	double DistanceFrom(const Vector2& Other) const {
		const Vector2& a = *this;
		double dx = (a.x - Other.x);
		double dy = (a.y - Other.y);

		return (sqrt((dx * dx) + (dy * dy)));
	}
};

class Vector3
{
public:
	double x, y, z;
	Vector3()
	{
		x = y = z = 0.f;
	}

	Vector3(double _x, double _y, double _z)
	{
		x = _x;
		y = _y;
		z = _z;
	}

	Vector3 operator+(const Vector3& v) {
		return Vector3{ x + v.x, y + v.y, z + v.z };
	}

	Vector3 operator-(const Vector3& v) {
		return Vector3{ x - v.x, y - v.y, z - v.z };
	}

	Vector3 operator*(const double v) {
		return Vector3{ x * v, y * v, z * v };
	}

	Vector3 operator/(const double fl) const {
		return Vector3(x / fl, y / fl, z / fl);
	}

	inline double DistanceFrom(const Vector3 Other) {
		double dx = (this->x - Other.x);
		double dy = (this->y - Other.y);
		double dz = (this->z - Other.z);

		return sqrt((dx * dx) + (dy * dy) + (dz * dz));
	}
	inline double Distance(Vector3 v)
	{
		return double(sqrtf(powf(v.x - x, 2.0) + powf(v.y - y, 2.0) + powf(v.z - z, 2.0)));
	}
};
```

`x64/Release/inject instructions.txt`:

```txt
1. turn of anti virus and windows defender 
2. open load injector.exe
3. f1 to load driver (before u launch fortnite)
4. make sure ur dll is in the same folder and named ritz.dll
5. click f2 in lobby to inject

```

`xor.h`:

```h
/*
 * Copyright 2017 - 2018 Justas Masiulis
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef JM_XORSTR_HPP
#define JM_XORSTR_HPP

#include <immintrin.h>
#include <cstdint>
#include <cstddef>
#include <utility>

#define JM_XORSTR_DISABLE_AVX_INTRINSICS

#define xorstr_(str)                                             \
    ::jm::make_xorstr(                                           \
        []() { return str; },                                    \
        std::make_index_sequence<sizeof(str) / sizeof(*str)>{},  \
        std::make_index_sequence<::jm::detail::_buffer_size<sizeof(str)>()>{})
#define xorstr(str) xorstr_(str).crypt_get()

#ifdef _MSC_VER
#define XORSTR_FORCEINLINE __forceinline
#else
#define XORSTR_FORCEINLINE __attribute__((always_inline))
#endif

 // you can define this macro to get possibly faster code on gcc/clang
 // at the expense of constants being put into data section.
#if !defined(XORSTR_ALLOW_DATA)
// MSVC - no volatile
// GCC and clang - volatile everywhere
#if defined(__clang__) || defined(__GNUC__)
#define XORSTR_VOLATILE volatile
#endif

#endif
#ifndef XORSTR_VOLATILE
#define XORSTR_VOLATILE
#endif

namespace jm {

    namespace detail {

        template<std::size_t S>
        struct unsigned_;

        template<>
        struct unsigned_<1> {
            using type = std::uint8_t;
        };
        template<>
        struct unsigned_<2> {
            using type = std::uint16_t;
        };
        template<>
        struct unsigned_<4> {
            using type = std::uint32_t;
        };

        template<auto C, auto...>
        struct pack_value_type {
            using type = decltype(C);
        };

        template<std::size_t Size>
        constexpr std::size_t _buffer_size() {
            return ((Size / 16) + (Size % 16 != 0)) * 2;
        }

        template<auto... Cs>
        struct tstring_ {
            using value_type = typename pack_value_type<Cs...>::type;
            constexpr static std::size_t size = sizeof...(Cs);
            constexpr static value_type  str[size] = { Cs... };

            constexpr static std::size_t buffer_size = _buffer_size<sizeof(str)>();
            constexpr static std::size_t buffer_align =
#ifndef JM_XORSTR_DISABLE_AVX_INTRINSICS
            ((sizeof(str) > 16) ? 32 : 16);
#else
                16;
#endif
        };

        template<std::size_t I, std::uint64_t K>
        struct _ki {
            constexpr static std::size_t   idx = I;
            constexpr static std::uint64_t key = K;
        };

        template<std::uint32_t Seed>
        constexpr std::uint32_t key4() noexcept {
            std::uint32_t value = Seed;
            for (char c : __TIME__)
                value = static_cast<std::uint32_t>((value ^ c) * 16777619ull);
            return value;
        }

        template<std::size_t S>
        constexpr std::uint64_t key8() {
            constexpr auto first_part = key4<2166136261 + S>();
            constexpr auto second_part = key4<first_part>();
            return (static_cast<std::uint64_t>(first_part) << 32) | second_part;
        }

        // clang and gcc try really hard to place the constants in data
        // sections. to counter that there was a need to create an intermediate
        // constexpr string and then copy it into a non constexpr container with
        // volatile storage so that the constants would be placed directly into
        // code.
        template<class T, std::uint64_t... Keys>
        struct string_storage {
            std::uint64_t storage[T::buffer_size];

            XORSTR_FORCEINLINE constexpr string_storage() noexcept : storage{ Keys... } {
                using cast_type =
                    typename unsigned_<sizeof(typename T::value_type)>::type;
                constexpr auto value_size = sizeof(typename T::value_type);
                // puts the string into 64 bit integer blocks in a constexpr
                // fashion
                for (std::size_t i = 0; i < T::size; ++i)
                    storage[i / (8 / value_size)] ^=
                    (std::uint64_t{ static_cast<cast_type>(T::str[i]) }
                << ((i % (8 / value_size)) * 8 * value_size));
            }
        };

    } // namespace detail

    template<class T, class... Keys>
    class xor_string {
        alignas(T::buffer_align) std::uint64_t _storage[T::buffer_size];

        // _single functions needed because MSVC crashes without them
        XORSTR_FORCEINLINE void _crypt_256_single(const std::uint64_t* keys,
            std::uint64_t* storage) noexcept

        {
            _mm256_store_si256(
                reinterpret_cast<__m256i*>(storage),
                _mm256_xor_si256(
                    _mm256_load_si256(reinterpret_cast<const __m256i*>(storage)),
                    _mm256_load_si256(reinterpret_cast<const __m256i*>(keys))));
        }

        template<std::size_t... Idxs>
        XORSTR_FORCEINLINE void _crypt_256(const std::uint64_t* keys,
            std::index_sequence<Idxs...>) noexcept {
            (_crypt_256_single(keys + Idxs * 4, _storage + Idxs * 4), ...);
        }

        XORSTR_FORCEINLINE void _crypt_128_single(const std::uint64_t* keys,
            std::uint64_t* storage) noexcept {
            _mm_store_si128(
                reinterpret_cast<__m128i*>(storage),
                _mm_xor_si128(_mm_load_si128(reinterpret_cast<const __m128i*>(storage)),
                    _mm_load_si128(reinterpret_cast<const __m128i*>(keys))));
        }

        template<std::size_t... Idxs>
        XORSTR_FORCEINLINE void _crypt_128(const std::uint64_t* keys,
            std::index_sequence<Idxs...>) noexcept {
            (_crypt_128_single(keys + Idxs * 2, _storage + Idxs * 2), ...);
        }

        // loop generates vectorized code which places constants in data dir
        XORSTR_FORCEINLINE constexpr void _copy() noexcept {
            constexpr detail::string_storage<T, Keys::key...> storage;
            static_cast<void>(std::initializer_list<std::uint64_t>{
                (const_cast<XORSTR_VOLATILE std::uint64_t*>(_storage))[Keys::idx] =
                    storage.storage[Keys::idx]... });
        }

    public:
        using value_type = typename T::value_type;
        using size_type = std::size_t;
        using pointer = value_type*;
        using const_pointer = const pointer;

        XORSTR_FORCEINLINE xor_string() noexcept { _copy(); }

        XORSTR_FORCEINLINE constexpr size_type size() const noexcept {
            return T::size - 1;
        }

        XORSTR_FORCEINLINE void crypt() noexcept {
            alignas(T::buffer_align) std::uint64_t keys[T::buffer_size];
            static_cast<void>(std::initializer_list<std::uint64_t>{
                (const_cast<XORSTR_VOLATILE std::uint64_t*>(keys))[Keys::idx] =
                    Keys::key... });

            _copy();

#ifndef JM_XORSTR_DISABLE_AVX_INTRINSICS
            _crypt_256(keys, std::make_index_sequence<T::buffer_size / 4>{});
            if constexpr (T::buffer_size % 4 != 0)
                _crypt_128(keys, std::index_sequence<T::buffer_size / 2 - 1>{});
#else
            _crypt_128(keys, std::make_index_sequence<T::buffer_size / 2>{});
#endif
        }

        XORSTR_FORCEINLINE const_pointer get() const noexcept {
            return reinterpret_cast<const_pointer>(_storage);
        }

        XORSTR_FORCEINLINE const_pointer crypt_get() noexcept {
            crypt();
            return reinterpret_cast<const_pointer>(_storage);
        }
    };

    template<class Tstr, std::size_t... StringIndices, std::size_t... KeyIndices>
    XORSTR_FORCEINLINE constexpr auto
        make_xorstr(Tstr str_lambda,
            std::index_sequence<StringIndices...>,
            std::index_sequence<KeyIndices...>) noexcept {
        return xor_string<detail::tstring_<str_lambda()[StringIndices]...>,
            detail::_ki<KeyIndices, detail::key8<KeyIndices>()>...>{};
    }

} // namespace jm

#endif // include guard
```

`xxself pasted.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="FNTool">
      <UniqueIdentifier>{6026f970-e8ce-43c4-bf33-2717af7bb903}</UniqueIdentifier>
    </Filter>
    <Filter Include="Spoofer">
      <UniqueIdentifier>{a660c3aa-420f-4b6c-b25f-c97a9e70270d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Memory">
      <UniqueIdentifier>{9df62fb2-e369-4fe7-a964-a9533b7e178e}</UniqueIdentifier>
    </Filter>
    <Filter Include="main">
      <UniqueIdentifier>{0fd6bc86-9b2e-45f6-9ce1-9b3157c0df8e}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp" />
    <ClCompile Include="FNTool.cpp">
      <Filter>FNTool</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="FNTool.h">
      <Filter>FNTool</Filter>
    </ClInclude>
    <ClInclude Include="spoof_call.h">
      <Filter>Spoofer</Filter>
    </ClInclude>
    <ClInclude Include="Memory.h">
      <Filter>Memory</Filter>
    </ClInclude>
    <ClInclude Include="GUI.h">
      <Filter>main</Filter>
    </ClInclude>
    <ClInclude Include="includes.h">
      <Filter>main</Filter>
    </ClInclude>
    <ClInclude Include="sdk.h">
      <Filter>main</Filter>
    </ClInclude>
    <ClInclude Include="sdkdefines.h">
      <Filter>main</Filter>
    </ClInclude>
    <ClInclude Include="vector.h">
      <Filter>main</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="spoofinternal.asm">
      <Filter>Spoofer</Filter>
    </MASM>
  </ItemGroup>
</Project>
```

`xxself pasted.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.32126.315
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "xxself pasted", "xxself pasted.vcxproj", "{8278C77B-59FF-4EF3-BE10-68B5AC068DF5}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{8278C77B-59FF-4EF3-BE10-68B5AC068DF5}.Debug|x64.ActiveCfg = Debug|x64
		{8278C77B-59FF-4EF3-BE10-68B5AC068DF5}.Debug|x64.Build.0 = Debug|x64
		{8278C77B-59FF-4EF3-BE10-68B5AC068DF5}.Debug|x86.ActiveCfg = Debug|Win32
		{8278C77B-59FF-4EF3-BE10-68B5AC068DF5}.Debug|x86.Build.0 = Debug|Win32
		{8278C77B-59FF-4EF3-BE10-68B5AC068DF5}.Release|x64.ActiveCfg = Release|x64
		{8278C77B-59FF-4EF3-BE10-68B5AC068DF5}.Release|x64.Build.0 = Release|x64
		{8278C77B-59FF-4EF3-BE10-68B5AC068DF5}.Release|x86.ActiveCfg = Release|Win32
		{8278C77B-59FF-4EF3-BE10-68B5AC068DF5}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {2B2CAFA8-92D4-4CCE-8B9E-DC74B090C174}
	EndGlobalSection
EndGlobal

```

`xxself pasted.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`xxself pasted.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{8278c77b-59ff-4ef3-be10-68b5ac068df5}</ProjectGuid>
    <RootNamespace>FNTool</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>ritz</TargetName>
    <IncludePath>C:\Users\mab82\OneDrive\Documents\aclim\xxritz is cute\xxself pasted\xxself pasted\minhook;C:\Users\mab82\Downloads\xxritz is cute\xxself pasted\xxself pasted\minhook;C:\Users\mab82\Downloads\Fortnite-Dumper-Tool-main %282%29\Fortnite-Dumper-Tool-main\FNTool\minhook;$(IncludePath)</IncludePath>
    <LibraryPath>C:\Users\mab82\OneDrive\Documents\aclim\xxritz is cute\xxself pasted\xxself pasted\minhook;C:\Users\mab82\Downloads\xxritz is cute\xxself pasted\xxself pasted\minhook;C:\Users\mab82\Downloads\Fortnite-Dumper-Tool-main %282%29\Fortnite-Dumper-Tool-main\FNTool\minhook;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp" />
    <ClCompile Include="FNTool.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="FNTool.h" />
    <ClInclude Include="menu.h" />
    <ClInclude Include="includes.h" />
    <ClInclude Include="Memory.h" />
    <ClInclude Include="safecall.h" />
    <ClInclude Include="sdk.h" />
    <ClInclude Include="sdkdefines.h" />
    <ClInclude Include="spoof_call.h" />
    <ClInclude Include="utils.h" />
    <ClInclude Include="vector.h" />
    <ClInclude Include="xor.h" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="spoofinternal.asm">
      <FileType>Document</FileType>
    </MASM>
  </ItemGroup>
  <ItemGroup>
    <Text Include="notes.txt" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`xxself pasted.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="FNTool.cpp">
      <Filter>main</Filter>
    </ClCompile>
    <ClCompile Include="dllmain.cpp">
      <Filter>main</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="FNTool.h">
      <Filter>defines</Filter>
    </ClInclude>
    <ClInclude Include="menu.h">
      <Filter>main</Filter>
    </ClInclude>
    <ClInclude Include="includes.h">
      <Filter>defines</Filter>
    </ClInclude>
    <ClInclude Include="Memory.h">
      <Filter>defines</Filter>
    </ClInclude>
    <ClInclude Include="sdk.h">
      <Filter>main</Filter>
    </ClInclude>
    <ClInclude Include="sdkdefines.h">
      <Filter>defines</Filter>
    </ClInclude>
    <ClInclude Include="spoof_call.h">
      <Filter>defines</Filter>
    </ClInclude>
    <ClInclude Include="vector.h">
      <Filter>defines</Filter>
    </ClInclude>
    <ClInclude Include="safecall.h">
      <Filter>defines</Filter>
    </ClInclude>
    <ClInclude Include="xor.h">
      <Filter>defines</Filter>
    </ClInclude>
    <ClInclude Include="utils.h">
      <Filter>defines</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="main">
      <UniqueIdentifier>{00f3de48-c290-4490-88aa-c28bc7b3c326}</UniqueIdentifier>
    </Filter>
    <Filter Include="defines">
      <UniqueIdentifier>{3ef1e2d1-50b5-4a37-a8ca-44522d45986d}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="spoofinternal.asm">
      <Filter>defines</Filter>
    </MASM>
  </ItemGroup>
  <ItemGroup>
    <Text Include="notes.txt" />
  </ItemGroup>
</Project>
```

`xxself pasted.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```