Project Path: arc_gmh5225_oxorany_ytendsxq

Source Tree:

```txt
arc_gmh5225_oxorany_ytendsxq
â”œâ”€â”€ LICENSE
â”œâ”€â”€ README.en.md
â”œâ”€â”€ README.md
â””â”€â”€ source
    â”œâ”€â”€ main.cpp
    â”œâ”€â”€ oxorany.cpp
    â”œâ”€â”€ oxorany.h
    â””â”€â”€ oxorany_bak.h

```

`LICENSE`:

```
MIT License

Copyright (c) 2021 Chase

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.en.md`:

```md
# oxorany
## A heavily obfuscated c++14 compile time any constant encryption.

[![LICENSE](https://img.shields.io/badge/license-MIT-blue.svg)](LICENSE)
[![](https://img.shields.io/badge/C%2B%2B-14-brightgreen)]()
[![](https://img.shields.io/badge/OS-any-brightgreen)]()
[![](https://img.shields.io/badge/compiler-any-brightgreen)]()
[![](https://img.shields.io/badge/arch-any-brightgreen)]()

* [ç®€ä½“ä¸­æ–‡](README.md)

### Description

> We integrated some implementation ideas from open source projects `ollvm` and `xorstr`, as well as the new `constexpr` keyword in the `c++14` standard and some template knowledge, to complete the compile-time obfuscation encryption of arbitrary constants.

> Before C++14, if we want to protect the constants in the program, we first encrypt the constants, here we take the string `"some_data_or_string"` byte by byte `-1` as an example, and then write the encrypted data "rnld^c\`s\`^nq^rsqhmf" to the code, while doing byte by byte `+1` decryption.

> Code show as below

```C++
char encrypted[] = {"rnld^c`s`^nq^rsqhmf"};
char key = 0x1;
for (size_t i = 0; i < strlen(encrypted); i++) {
	encrypted[i] += key;
}
//output: some_data_or_string
printf("%s\n", encrypted);
```

> The above method can only be used when the amount of data to be protected is relatively small, and when the amount of data increases, the time taken by the tedious encryption process will also rise, and it makes the readability and maintainability of the code greatly reduced. And it is not possible to design a separate decryption algorithm and key for each data, which makes a general decryption tool easier to write.

> **With the advent of `oxorany`, the above process will be changed**

### ğŸ¨ Features
* **Support any platform(`C++14`)**
* **Higher operability, using `__asm` `_emit` can further increase the difficulty of reverse**
* Obfuscated encryption of any constants at compile time
* All the decryption process is done inside the stack, and the decrypted data cannot be obtained through runtime `dump`ï¼Œunlike [Armariris](https://github.com/GoSSIP-SJTU/Armariris)ã€[flounder](https://github.com/isrc-cas/flounder)
* Decryption algorithm with `Bogus Control Flow` like `ollvm`
* Generate a unique control flow for each encryption algorithm through `compile optimization`
* Generate a unique `key` for each encryption algorithm with the `__COUNTER__` macro
* Dynamically generate `key` via the `__TIME__` macro
* **The code has been crafted** so that can Destroying the stack to anti `IDA` `F5`
* Stack variable based `Opaque Predicate`
* Fuzzy data length
* Since most of the code for the decryption algorithm is not executed, the impact on efficiency is not particularly significant
* **The complexity of the decryption algorithm can be improve**
* Because of the `implicit conversion` feature of constants in `C++`, some constants may require forced type conversion
* Easy to use, tested in `msvc`, `clang`, `gcc`
* **There is no guarantee that the data will be embedded directly into code**ï¼Œ[Want embedded](https://github.com/llxiaoyuan/xorstr)

### Data types supported

- [x] String(`char*` `wchar_t*`)
- [x] Macro
- [x] Enume
- [x] Integer(`int8_t` `int16_t` `int32_t` `int64_t` `uint8_t` `uint16_t` `uint32_t` `uint64_t`)
- [x] Floating point(`float` `double`)

### Compilers Supported

- [x] `msvc`
- [x] `clang`(`llvm`)
- [x] `gcc`
- [x] `android ndk`
- [x] `leetcode gcc`
- [x] `...`

<br />

### ğŸš€ Usage
```C++
#include <iostream>
//#define OXORANY_DISABLE_OBFUSCATION
#include "oxorany.h"

enum class MyEnum : int {
	first = 1,
	second = 2,
};

#define NUM_1 1

int main() {
        // output:
        // 1 1 2 12 1234 12345678 1234567887654321 1.000000 2.000000
        // string wstring raw string raw wstring
	printf(oxorany("%d %d %d %hhx %hx %x %llx %f %lf\n%s %S %s %S\n")  //string
            , oxorany(NUM_1)                                               //macro
            , oxorany(MyEnum::first), oxorany(MyEnum::second)              //enum
            , oxorany((uint8_t)0x12)                                       //uint8_t
            , oxorany((uint16_t)0x1234)                                    //uint16_t
            , oxorany((uint32_t)0x12345678)                                //uint32_t
            , oxorany((uint64_t)0x1234567887654321)                        //uint64_t
            , oxorany(1.0f)                                                //float
            , oxorany(2.0)                                                 //double
            , oxorany("string")                                            //string
            , oxorany(L"wstring")                                          //wstring
            , oxorany(R"(raw string)")                                     //raw string
            , oxorany(LR"(raw wstring)")                                   //raw wstring
	);
	return oxorany(0);
}
```

<br />

### âš™ï¸ Need Cast

> 0 error 0 warning

```C++
MessageBoxA(0, 0, 0, 0);
```

<br />

> error(active)	E0167 Real parameters of type "int" are incompatible with formal parameters of type "HWND"

```C++
MessageBoxA(oxorany(0), 0, 0, 0);
```

<br />

> The reason for the above problem is due to the peculiarity of `0` in `C/C++`, because it can be implicitly converted to a pointer of any type, and is also related to the definition of `NULL`

```C++
#ifndef NULL
    #ifdef __cplusplus
        #define NULL 0
    #else
        #define NULL ((void *)0)
    #endif
#endif
```

<br />

> So we add a forced type conversion to `HWND` to solve the problem
```C++
MessageBoxA(oxorany((HWND)0), 0, 0, 0);
```

<br />

### `Control Flow Graph` in `IDA`

![image](https://user-images.githubusercontent.com/36320938/132527280-34c443b8-40b5-4b76-a35b-2629a1df087c.png)

<br />

### `Compilation Optimization` test

```C++
#include "oxorany.h"
int main() {
	return oxorany(0);
}
```

<br />

### âœ… `Control Flow Graph` in `IDA` after multiple compilation using `msvc`

![image](https://user-images.githubusercontent.com/36320938/132721095-7ef48f99-37ef-407e-bf14-0ba3e72f1e25.png)

<br />

### âœ… `Control Flow Graph` in `IDA` after multiple compilation using `clang`

![image](https://user-images.githubusercontent.com/36320938/132723406-dcf26a9e-9a12-4fa4-a0b7-4889861d7478.png)

<br />

### âœ… `Control Flow Graph` in `IDA` after multiple compilation using `gcc`

![image](https://user-images.githubusercontent.com/36320938/132799274-d816cc02-e913-43ab-b183-3a1c75fee5ce.png)

<br />

### âœ… `Control Flow Graph` in `IDA` after compilation using `android ndk`

![image](https://user-images.githubusercontent.com/36320938/133132325-d70fe632-5e7e-407a-a42c-7594b788507a.png)

<br />

### âœ… Testing with `leetcode gcc` ([Sword Pointing Offer 05. replace space](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/comments/))

![S5(LFNXH~_KM6UH@L}U(CY6](https://user-images.githubusercontent.com/36320938/133314352-50d434a3-d5ae-4e0d-8504-1e1215be19e6.png)

<br />

### âœ… `Control Flow Graph` in `IDA` after multiple compilation using `wdk`

![image](https://user-images.githubusercontent.com/36320938/133409709-7e176557-439c-4988-91ee-219b35ab80e0.png)

<br />

### âœ… `Control Flow Graph` in `IDA` after compilation using `ollvm`

![image](https://user-images.githubusercontent.com/36320938/133938052-cdccca0f-6bdf-4fc7-811f-f470bbea7663.png)

<br />

### Opaque predicate

> The `opaque predicate` can be understood as `"the judgment of the result cannot be determined"`ï¼ŒThe words themselves do not contain the meaning that the result must be true or must be false, but only the condition that the result must be true is used here for obfuscation

> The `rand() % 2 == 0` in the code is actually an opaque predicate, because we can't determine its result, so we can't be sure whether the program is outputting `hello` or `world`

```C++
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
int main() {
	srand((unsigned int)time(NULL));
	if (rand() % 2 == 0) {
		printf("hello\n");
	}
	else {
		printf("world\n");
	}
	return 0;
}
```

<br />

> But in another case, here we create a global variable `zeor` and assign an initial value of `0`, without modifying the value of `zeor` or making reasonable modifications to ensure that the result of the predicate is constant, then the predicate `zeor < 1` is constant, and at the same time the compiler will not optimize due to the natural opacity of global variables, so we add a forged to the control flow. We can add `any code` inside an unreachable basic block, and here we add a `99 multiplication table` as an example.ã€‚

```C++
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
int zeor = 0;
int main() {
	if (zeor < 1) {
		printf("hello\n");
	}
	else {
		//unreachable
		for (int i = 1; i <= 9; i++) {
			for (int j = 1; j <= 9; j++) {
				printf("%d*%d=%2d\t", i, j, i * j);
			}
		    	printf("\n");
		}
	}
	return 0;
}
```

<br />

> Here `copy` the code from `ollvm`ï¼Œ`ASCII Picasso`

```C++
// Before :
// 	         	     entry
//      		       |
//  	    	  	 ______v______
//   	    		|   Original  |
//   	    		|_____________|
//             		       |
// 		       	       v
//		             return
//
// After :
//           		     entry
//             		       |
//            		   ____v_____
//      		  |condition*| (false)
//           		  |__________|----+
//           		 (true)|          |
//             		       |          |
//           		 ______v______    |
// 	            +-->|   Original* |   |
// 	            |   |_____________| (true)
// 	            |   (false)|    !-----------> return
// 	            |    ______v______    |
// 	            |   |   Altered   |<--!
// 	            |   |_____________|
// 	            |__________|
//
//  * The results of these terminator's branch's conditions are always true, but these predicates are
//    opacificated. For this, we declare two global values: x and y, and replace the FCMP_TRUE
//    predicate with (y < 10 || x * (x + 1) % 2 == 0) (this could be improved, as the global
//    values give a hint on where are the opaque predicates)
```

<br />

> Definition of global `x`, `y` in ollvm`

```C++
      GlobalVariable 	* x = new GlobalVariable(M, Type::getInt32Ty(M.getContext()), false,
          GlobalValue::CommonLinkage, (Constant * )x1,
          *varX);
      GlobalVariable 	* y = new GlobalVariable(M, Type::getInt32Ty(M.getContext()), false,
          GlobalValue::CommonLinkage, (Constant * )y1,
          *varY);
```

<br />

> The implementation of the opaque predicate `y < 10 || x * (x + 1) % 2 == 0` in `ollvm` is shown by `Instruction::Sub`, which, although annotated with `x + 1`, actually uses `x - 1`

```C++
        //if y < 10 || x*(x+1) % 2 == 0
        opX = new LoadInst ((Value *)x, "", (*i));
        opY = new LoadInst ((Value *)y, "", (*i));

        op = BinaryOperator::Create(Instruction::Sub, (Value *)opX,
            ConstantInt::get(Type::getInt32Ty(M.getContext()), 1,
              false), "", (*i));
        op1 = BinaryOperator::Create(Instruction::Mul, (Value *)opX, op, "", (*i));
        op = BinaryOperator::Create(Instruction::URem, op1,
            ConstantInt::get(Type::getInt32Ty(M.getContext()), 2,
              false), "", (*i));
        condition = new ICmpInst((*i), ICmpInst::ICMP_EQ, op,
            ConstantInt::get(Type::getInt32Ty(M.getContext()), 0,
              false));
        condition2 = new ICmpInst((*i), ICmpInst::ICMP_SLT, opY,
            ConstantInt::get(Type::getInt32Ty(M.getContext()), 10,
              false));
        op1 = BinaryOperator::Create(Instruction::Or, (Value *)condition,
            (Value *)condition2, "", (*i));

```


<br />

> Adjusting our code above slightly to show the implementation of `ollvm`, here `x * (x + 1) % 2 == 0`, thinking that `x` and `x + 1`, must be an odd number and an even number, according to the operation of parity we can learn that the result of `x * (x + 1)` must be even, so the judgment of `% 2 == 0` will necessarily hold

```C++
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
int x = 0;
int y = 0;
int main() {
	if (y < 10 || x * (x + 1) % 2 == 0) {
		printf("hello\n");
	}
	else {
		//unreachable
        	for (int i = 1; i <= 9; i++) {
			for (int j = 1; j <= 9; j++) {
                		printf("%d*%d=%2d\t", i, j, i * j);
			}
            		printf("\n");
        	}
	}
	return 0;
}
```

<br />

### Implemention
> Inspired by the `Bogus Control Flow` function in `ollvm`, we created two global variables `x` and `y` and assigned initial values of `0` as the basis for implementing opaque predicates

![image](https://user-images.githubusercontent.com/36320938/132540802-06b63425-acc8-4da8-b9d7-de5886587f42.png)

<br />

> Due to the complexity of the stack environment, we assign the global variables `x` and `y` to two local variables `stack_x` and `stack_y` respectively to make the inverse more difficult

![image](https://user-images.githubusercontent.com/36320938/132541176-02f4f8a7-0b80-4b2a-b584-7658f954a003.png)

<br />

> We created `label` in many positions of the function, used `stack_x`, `stack_y` to judge the constant to be true for confusion, and added `goto label` in the basic block that could not be reached to remove the basic block as much as possible point. We use the wrong key to decrypt the decrypted data `decrypted` in many places, so that the real key is difficult to identify among the many wrong keys.

![image](https://user-images.githubusercontent.com/36320938/132542465-c9495bde-c34f-468b-ae0f-b9ab79959bba.png)

<br />

> Generate random numbers with range limition, since the same values can occur here, while duplicate conditions are removed by compilation optimization because of the existence of compilation optimization, which makes us have a different control flow diagram for each compilation

![image](https://user-images.githubusercontent.com/36320938/132543102-c7c59806-6f34-4f60-b5cf-59abdfa79048.png)

<br />

> We add illegal stack operations within the unreachable basic fast to make `IDA`'s stack frame analysis fail against `F5`

![image](https://user-images.githubusercontent.com/36320938/132544334-27a63575-35b0-4b52-ac12-9079a984c2bf.png)

<br />

> We are aligning the data by `16` bytes and adding a certain random value to obscure the data length, which may waste a little space

![image](https://user-images.githubusercontent.com/36320938/132553464-d8ef7b64-c4a7-4a36-9250-51062751a8d1.png)

<br />

> We are replacing `xor` with a more complex implementation to make the inversion more difficult

![image](https://user-images.githubusercontent.com/36320938/132621379-81796348-23d1-4549-99b7-55e4aa87f0eb.png)

<br />

> Use the `__TIME__` macro to implement a different `key` for each compilation

![image](https://user-images.githubusercontent.com/36320938/132704045-7510c6df-f2db-4e9b-99b0-ca80aa871aed.png)

<br />

> Random number generator with range restrictions, making `opaque predicates` similar to normal `predicates`

![image](https://user-images.githubusercontent.com/36320938/132704535-10761dda-61e7-47b3-95a4-e2439d483532.png)

<br />

> To sum up, with the help of `oxorany`, the security of the software will be further improved

### Reference
+ [Armariris -- LLVM obfuscation framework maintained by the Laboratory of Cryptography and Computer Security, Shanghai Jiao Tong University](https://github.com/GoSSIP-SJTU/Armariris)
+ [PLCT labs maintain the collvm branch](https://github.com/isrc-cas/flounder)
+ [heavily vectorized c++17 compile time string encryption](https://github.com/JustasMasiulis/xorstr)

### Github
https://github.com/llxiaoyuan/oxorany

```

`README.md`:

```md
# [oxorany](https://github.com/llxiaoyuan/oxorany)
## å¸¦æœ‰æ··æ·†çš„ç¼–è¯‘æ—¶ä»»æ„å¸¸é‡åŠ å¯†

[![LICENSE](https://img.shields.io/badge/license-MIT-blue.svg)](LICENSE)
[![](https://img.shields.io/badge/C%2B%2B-14-brightgreen)]()
[![](https://img.shields.io/badge/OS-any-brightgreen)]()
[![](https://img.shields.io/badge/compiler-any-brightgreen)]()
[![](https://img.shields.io/badge/arch-any-brightgreen)]()

* [English](README.en.md)

### ä»‹ç»

> æˆ‘ä»¬ç»¼åˆäº†å¼€æºé¡¹ç›®`ollvm`ã€`xorstr`ä¸€äº›å®ç°æ€è·¯ï¼Œä»¥åŠ`c++14`æ ‡å‡†ä¸­æ–°åŠ å…¥çš„`constexpr`å…³é”®å­—å’Œä¸€äº›æ¨¡æ¿çš„çŸ¥è¯†ï¼Œå®Œæˆäº†ç¼–è¯‘æ—¶çš„ä»»æ„å¸¸é‡çš„æ··æ·†`(å¯é€‰)`å’ŒåŠ å¯†åŠŸèƒ½ã€‚

> åœ¨C++14ä¹‹å‰ï¼Œæˆ‘ä»¬å¦‚æœè¦å¯¹ç¨‹åºä¸­çš„å¸¸é‡è¿›è¡Œä¿æŠ¤ï¼Œæˆ‘ä»¬é¦–å…ˆå¯¹å¸¸é‡è¿›è¡ŒåŠ å¯†æ“ä½œï¼Œè¿™é‡Œä»¥å­—ç¬¦ä¸²`"some_data_or_string"`é€å­—èŠ‚`-1`ä¸ºä¾‹ï¼Œç„¶åå°†åŠ å¯†åçš„æ•°æ®"rnld^c\`s\`^nq^rsqhmf"ï¼Œå†™åˆ°ä»£ç é‡Œï¼ŒåŒæ—¶è¿›è¡Œé€å­—èŠ‚`+1`è§£å¯†ã€‚

> ä»£ç å¦‚ä¸‹

```C++
char encrypted[] = {"rnld^c`s`^nq^rsqhmf"};
char key = 0x1;
for (size_t i = 0; i < strlen(encrypted); i++) {
	encrypted[i] += key;
}
//output: some_data_or_string
printf("%s\n", encrypted);
```

> ä¸Šè¿°çš„æ–¹æ³•åªèƒ½åœ¨éœ€è¦è¢«ä¿æŠ¤çš„æ•°æ®çš„æ•°é‡æ¯”è¾ƒå°‘æ—¶ä½¿ç”¨ï¼Œå½“æ•°æ®é‡å¢å¤§ï¼Œç¹ççš„åŠ å¯†è¿‡ç¨‹æ‰€å ç”¨çš„æ—¶é—´ä¹Ÿä¼šæ°´æ¶¨èˆ¹é«˜ï¼Œè€Œä¸”ä½¿å¾—ä»£ç çš„å¯è¯»æ€§ã€å¯ç»´æŠ¤æ€§å¤§å¤§é™ä½ã€‚è€Œä¸”ä¸å¯èƒ½ä¸ºæ¯ä¸€ä¸ªæ•°æ®éƒ½å•ç‹¬è®¾è®¡ä¸€ä¸ªè§£å¯†ç®—æ³•å’Œkeyï¼Œä½¿å¾—é€šç”¨çš„è§£å¯†å·¥å…·æ›´æ˜“äºç¼–å†™ã€‚

> **éšç€`oxorany`çš„å‡ºç°ï¼Œä¸Šè¿°è¿‡ç¨‹å°†è¢«æ”¹å˜**

### ğŸ¨ ç‰¹æ€§
* **æ”¯æŒä»»æ„å¹³å°(`C++14`)ï¼Œå·²åœ¨æ‰€æœ‰è¯¸å¤šç¼–è¯‘å™¨ä¸­è¿›è¡Œäº†æµ‹è¯•**
* **è¾ƒé«˜çš„å¯æ“ä½œæ€§ï¼Œä½¿ç”¨`__asm` `_emit`å¯è¿›ä¸€æ­¥æé«˜é€†å‘éš¾åº¦**
* æ‰€æœ‰çš„åŠ å¯†è¿‡ç¨‹å‡åœ¨ç¼–è¯‘æ—¶å®Œæˆ
* æ‰€æœ‰çš„è§£å¯†è¿‡ç¨‹å‡åœ¨æ ˆå†…å®Œæˆï¼Œæ— æ³•é€šè¿‡è¿è¡Œæ—¶`dump`è·å¾—è§£å¯†åçš„æ•°æ®ï¼Œä¸åŒäº [Armariris](https://github.com/GoSSIP-SJTU/Armariris)ã€[flounder](https://github.com/isrc-cas/flounder)
* å¸¦æœ‰`ä¼ªé€ æ§åˆ¶æµ`åŠŸèƒ½çš„è§£å¯†ç®—æ³•
* é€šè¿‡`ç¼–è¯‘ä¼˜åŒ–`ä¸ºæ¯ä¸€ä¸ªåŠ å¯†ç®—æ³•ç”Ÿæˆå”¯ä¸€çš„æ§åˆ¶æµ
* é€šè¿‡`__COUNTER__` å®ä¸ºæ¯ä¸€ä¸ªåŠ å¯†ç®—æ³•ç”Ÿæˆå”¯ä¸€çš„`key`
* é€šè¿‡`__TIME__`å®åŠ¨æ€äº§ç”Ÿ`key`
* ä»£ç ç»è¿‡**ç²¾å¿ƒç¼–å†™**ï¼Œè¶³ä»¥ç ´åå †æ ˆä»¥å¯¹æŠ—`IDA` `F5`
* åŸºäºå †æ ˆå˜é‡çš„`ä¸é€æ˜è°“è¯`
* æ¨¡ç³Šæ•°æ®é•¿åº¦
* ç”±äºè§£å¯†ç®—æ³•çš„å¤§éƒ¨åˆ†ä»£ç ä¸ä¼šè¢«æ‰§è¡Œï¼Œæ‰€ä»¥å¯¹äºæ•ˆç‡çš„å½±å“å¹¶ä¸ä¼šç‰¹åˆ«å¤§
* **è§£å¯†ç®—æ³•çš„å¤æ‚åº¦ä»æœ‰æå‡ç©ºé—´**
* å› ä¸º`C++`ä¸­å¸¸é‡çš„`éšå¼è½¬æ¢`ç‰¹æ€§ï¼ŒæŸäº›å¸¸é‡å¯èƒ½éœ€è¦å¼ºåˆ¶ç±»å‹è½¬æ¢
* **ç›¸å½“ç®€å•çš„ä½¿ç”¨æ–¹æ³•**
### **ä¸èƒ½ä¿è¯æ•°æ®ä¼šè¢«å†…è”åˆ°ä»£ç æ®µ**ï¼Œ[æƒ³è¦å†…è”](https://github.com/llxiaoyuan/xorstr)

### æ”¯æŒçš„æ•°æ®ç±»å‹

- [x] å­—ç¬¦ä¸²(`char*` `wchar_t*`)
- [x] å®
- [x] æšä¸¾
- [x] å­—ç¬¦(`char` `wchar_t`)
- [x] æŒ‡é’ˆ(`NULL` `nullptr`)
- [x] æ•´æ•°(`int8_t` `int16_t` `int32_t` `int64_t` `uint8_t` `uint16_t` `uint32_t` `uint64_t`)
- [ ] æµ®ç‚¹(`float` `double`)(**ä¼šä¿ç•™åŸæ•°æ®**)

### æ”¯æŒçš„ç¼–è¯‘å™¨

- [x] `msvc`
- [x] `clang`(`llvm`)(**æ”¯æŒå åŠ ollvm**)
- [x] `gcc`
- [x] `android ndk`(**æ”¯æŒå®‰å“**)
- [x] `leetcode gcc`(**æ”¯æŒç±»ä¼¼çš„äº‘ç¼–è¯‘å™¨**)
- [x] `wdk`(**æ”¯æŒWindowsé©±åŠ¨ç¨‹åº**)
- [x] `...`

<br />

### ğŸš€ ä½¿ç”¨
```C++
#include <iostream>
#define OXORANY_DISABLE_OBFUSCATION
//use OXORANY_USE_BIT_CAST for remove float double src data
#define OXORANY_USE_BIT_CAST
#include "oxorany.h"

enum class MyEnum : int {
    first = 1,
    second = 2,
};

#define NUM_1 1

int main() {
    // output:
    // 1 1 2 c w 00000000 00000000 12 1234 12345678 1234567887654321 1.000000 2.000000
    // string u8 string wstring raw string raw wstring abcd
    printf(oxorany("%d %d %d %c %C %p %p %hhx %hx %x %llx %f %lf\n%s %s %S %s %S %s\n")  //string
           , oxorany(NUM_1)                                                           //macro
           , oxorany(MyEnum::first), oxorany(MyEnum::second)                          //enum
           , oxorany('c')                                                             //char
           , oxorany(L'w')                                                            //wchar_t
           , oxorany(NULL), oxorany(nullptr)                                          //pointer
           , oxorany(0x12)                                                            //int8_t
           , oxorany(0x1234)                                                          //int16_t
           , oxorany(0x12345678)                                                      //int32_t
           , oxorany(0x1234567887654321)                                              //int64_t
           , oxorany_flt(1.0f)                                                            //float
           , oxorany_flt(2.0)                                                             //double

           , oxorany("string")                                                        //string
           , oxorany(u8"u8 string")                                                   //u8 string
           , oxorany(L"wstring")                                                      //wstring
           , oxorany(R"(raw string)")                                                 //raw string
           , oxorany(LR"(raw wstring)")                                               //raw wstring
           , oxorany("\x61\x62\x63\x64")                                              //binary data
    );
    return 0;
}

```

<br />

### âš™ï¸ éœ€è¦å¼ºåˆ¶ç±»å‹è½¬æ¢çš„ç¤ºä¾‹

> 0 error 0 warning

```C++
MessageBoxA(0, 0, 0, 0);
```

<br />

> é”™è¯¯(æ´»åŠ¨)	E0167	"int" ç±»å‹çš„å®å‚ä¸ "HWND" ç±»å‹çš„å½¢å‚ä¸å…¼å®¹

```C++
MessageBoxA(oxorany(0), 0, 0, 0);
```

<br />

> å‡ºç°ä¸Šè¿°é—®é¢˜çš„åŸå› æ˜¯å› ä¸º`C/C++`ä¸­`0`çš„ç‰¹æ®Šæ€§ï¼Œå› ä¸ºå®ƒå¯ä»¥éšå¼è½¬æ¢åˆ°ä»»æ„ç±»å‹çš„æŒ‡é’ˆï¼Œä¹Ÿå’Œ`NULL`çš„å®šä¹‰æœ‰å…³

```C++
#ifndef NULL
    #ifdef __cplusplus
        #define NULL 0
    #else
        #define NULL ((void *)0)
    #endif
#endif
```

<br />

> æ‰€ä»¥æˆ‘ä»¬æ·»åŠ ä¸€ä¸ªåˆ°`HWND`çš„å¼ºåˆ¶ç±»å‹è½¬æ¢å°±å¯ä»¥è§£å†³è¯¥é—®é¢˜
```C++
MessageBoxA(oxorany((HWND)0), 0, 0, 0);
```

<br />

### âš™ï¸ åœ¨`wdk`ä¸­ä½¿ç”¨æ—¶éœ€å¯ç”¨`__TIME__`å®
![image](https://user-images.githubusercontent.com/36320938/133402525-328e0515-6a30-473b-97cc-70905ca33606.png)

<br />

### `IDA`ä¸­çš„æ§åˆ¶æµç¨‹å›¾

![image](https://user-images.githubusercontent.com/36320938/132527280-34c443b8-40b5-4b76-a35b-2629a1df087c.png)

<br />

### `ç¼–è¯‘ä¼˜åŒ–`æµ‹è¯•

> è¿™é‡Œæ˜¯æµ‹è¯•`ç¼–è¯‘ä¼˜åŒ–`å¯¹æ§åˆ¶æµç¨‹å›¾çš„å½±å“ï¼ŒæœŸæœ›çš„ç»“æœæ˜¯æ¯ä¸€æ¬¡ç¼–è¯‘éƒ½æ‹¥æœ‰ä¸åŒçš„`æ§åˆ¶æµç¨‹å›¾`

```C++
#include "oxorany.h"
int main() {
	return oxorany(0);
}
```

<br />

### âœ… ä½¿ç”¨`msvc`å¤šæ¬¡ç¼–è¯‘å`IDA`ä¸­çš„`æ§åˆ¶æµç¨‹å›¾`

![image](https://user-images.githubusercontent.com/36320938/132721095-7ef48f99-37ef-407e-bf14-0ba3e72f1e25.png)

<br />

### âœ… ä½¿ç”¨`clang`å¤šæ¬¡ç¼–è¯‘å`IDA`ä¸­çš„`æ§åˆ¶æµç¨‹å›¾`

![image](https://user-images.githubusercontent.com/36320938/132723406-dcf26a9e-9a12-4fa4-a0b7-4889861d7478.png)

<br />

### âœ… ä½¿ç”¨`gcc`å¤šæ¬¡ç¼–è¯‘å`IDA`ä¸­çš„`æ§åˆ¶æµç¨‹å›¾`

![image](https://user-images.githubusercontent.com/36320938/132799274-d816cc02-e913-43ab-b183-3a1c75fee5ce.png)

<br />

### âœ… ä½¿ç”¨`android ndk`ç¼–è¯‘å`IDA`ä¸­çš„`æ§åˆ¶æµç¨‹å›¾`

![image](https://user-images.githubusercontent.com/36320938/133132325-d70fe632-5e7e-407a-a42c-7594b788507a.png)

<br />

### âœ… ä½¿ç”¨`leetcode gcc`è¿›è¡Œæµ‹è¯• ([å‰‘æŒ‡ Offer 05. æ›¿æ¢ç©ºæ ¼](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/comments/))

![S5(LFNXH~_KM6UH@L}U(CY6](https://user-images.githubusercontent.com/36320938/133314352-50d434a3-d5ae-4e0d-8504-1e1215be19e6.png)

<br />

### âœ… ä½¿ç”¨`wdk`å¤šæ¬¡ç¼–è¯‘å`IDA`ä¸­çš„`æ§åˆ¶æµç¨‹å›¾`

![image](https://user-images.githubusercontent.com/36320938/133409709-7e176557-439c-4988-91ee-219b35ab80e0.png)

<br />

### âœ… ä½¿ç”¨`ollvm`ç¼–è¯‘å`IDA`ä¸­çš„`æ§åˆ¶æµç¨‹å›¾`

![image](https://user-images.githubusercontent.com/36320938/133938052-cdccca0f-6bdf-4fc7-811f-f470bbea7663.png)

<br />

### ä¸é€æ˜è°“è¯

> ä¸é€æ˜ï¼š`opaque`  
> `â˜…`æ¥è‡ªæ‹‰ä¸è¯­opacus,æœ‰é˜´å½±çš„ï¼Œé»‘æš—çš„ï¼Œæ¨¡ç³Šçš„ã€‚

> è°“è¯ï¼š`predicate`  
> `â˜…`æ¥è‡ªæ‹‰ä¸è¯­praedicare,é¢„æµ‹ï¼Œæ–­è¨€ï¼Œå£°ç§°ï¼Œæ¥è‡ªprae,åœ¨å‰ï¼Œæ—©äºï¼Œdicare,è¯´ï¼Œå£°ç§°ï¼Œè¯æºåŒdiction.å¹¶å¼•ç”³è¯¸ç›¸å…³è¯ä¹‰ã€‚

> `ä¸é€æ˜è°“è¯`å¯ä»¥ç†è§£ä¸º`â€œæ— æ³•ç¡®å®šç»“æœçš„åˆ¤æ–­â€`ï¼Œè¯è¯­æœ¬èº«å¹¶æ²¡æœ‰åŒ…å«ç»“æœå¿…ä¸ºçœŸæˆ–è€…å¿…ä¸ºå‡çš„å«ä¹‰ï¼Œåªæ˜¯åœ¨è¿™é‡Œä½¿ç”¨äº†ç»“æœå¿…ä¸ºçœŸçš„æ¡ä»¶è¿›è¡Œæ··æ·†ã€‚

> ä»£ç ä¸­çš„`rand() % 2 == 0`å®é™…ä¸Šä¹Ÿæ˜¯ä¸€ä¸ªä¸é€æ˜è°“è¯ï¼Œå› ä¸ºæˆ‘ä»¬æ— æ³•ç¡®å®šå®ƒçš„ç»“æœï¼Œæ‰€ä»¥å°±æ— æ³•ç¡®å®ç¨‹åºæ˜¯è¾“å‡º`hello`è¿˜æ˜¯è¾“å‡º`world`

```C++
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
int main() {
	srand((unsigned int)time(NULL));
	if (rand() % 2 == 0) {
		printf("hello\n");
	}
	else {
		printf("world\n");
	}
	return 0;
}
```

<br />

> ä½†æ˜¯æ¢ä¸€ç§æƒ…å†µï¼Œè¿™é‡Œæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªå…¨å±€å˜é‡`zeor`ï¼Œå¹¶èµ‹åˆå€¼ä¸º`0`ï¼Œä¸å»ä¿®æ”¹`zeor`çš„å€¼æˆ–è€…åœ¨ä¿è¯è°“è¯ç»“æœæ’å®šçš„æƒ…å†µä¸‹è¿›è¡Œåˆç†çš„ä¿®æ”¹ï¼Œé‚£ä¹ˆè°“è¯`zeor < 1`å°±æ˜¯æ’æˆç«‹çš„ï¼ŒåŒæ—¶åˆç”±äºå…¨å±€å˜é‡çš„å¤©ç„¶çš„ä¸é€æ˜æ€§ï¼Œç¼–è¯‘å™¨ä¸ä¼šè¿›è¡Œä¼˜åŒ–ï¼Œæ‰€ä»¥æˆ‘ä»¬å°±å¢åŠ ä¸€ä¸ªä¼ªé€ çš„æ§åˆ¶æµï¼Œ`æ— ä¸­ç”Ÿæœ‰`ã€‚æˆ‘ä»¬å¯ä»¥åœ¨ä¸å¯è¾¾çš„åŸºæœ¬å—å†…åŠ å…¥`ä»»æ„ä»£ç `ï¼Œè¿™é‡Œæˆ‘ä»¬æ·»åŠ äº†ä¸€ä¸ªå…¸ä¸­å…¸`99ä¹˜æ³•è¡¨`ä½œä¸ºç¤ºä¾‹ï¼Œ`æš—åº¦é™ˆä»“`ã€‚

```C++
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
int zeor = 0;
int main() {
	if (zeor < 1) {
		printf("hello\n");
	}
	else {
		//unreachable
		for (int i = 1; i <= 9; i++) {
			for (int j = 1; j <= 9; j++) {
				printf("%d*%d=%2d\t", i, j, i * j);
			}
		    	printf("\n");
		}
	}
	return 0;
}
```

<br />

> è¿™é‡Œ`copy`ä¸€ä¸‹`ollvm`ä¸­çš„ä»£ç ï¼Œ`ASCII Picasso`

```C++
// Before :
// 	         	     entry
//      		       |
//  	    	  	 ______v______
//   	    		|   Original  |
//   	    		|_____________|
//             		       |
// 		       	       v
//		             return
//
// After :
//           		     entry
//             		       |
//            		   ____v_____
//      		  |condition*| (false)
//           		  |__________|----+
//           		 (true)|          |
//             		       |          |
//           		 ______v______    |
// 	            +-->|   Original* |   |
// 	            |   |_____________| (true)
// 	            |   (false)|    !-----------> return
// 	            |    ______v______    |
// 	            |   |   Altered   |<--!
// 	            |   |_____________|
// 	            |__________|
//
//  * The results of these terminator's branch's conditions are always true, but these predicates are
//    opacificated. For this, we declare two global values: x and y, and replace the FCMP_TRUE
//    predicate with (y < 10 || x * (x + 1) % 2 == 0) (this could be improved, as the global
//    values give a hint on where are the opaque predicates)
```

<br />

> `ollvm`ä¸­å…¨å±€`x`ã€`y`çš„å®šä¹‰

```C++
      GlobalVariable 	* x = new GlobalVariable(M, Type::getInt32Ty(M.getContext()), false,
          GlobalValue::CommonLinkage, (Constant * )x1,
          *varX);
      GlobalVariable 	* y = new GlobalVariable(M, Type::getInt32Ty(M.getContext()), false,
          GlobalValue::CommonLinkage, (Constant * )y1,
          *varY);
```

<br />

> `ollvm`ä¸­ä¸é€æ˜è°“è¯`y < 10 || x * (x + 1) % 2 == 0`çš„å®ç°ï¼Œç”±`Instruction::Sub`å¯çŸ¥ï¼Œè™½ç„¶æ³¨é‡Šæ˜¯`x + 1`ï¼Œä½†å®é™…ä½¿ç”¨çš„ç¡®å®`x - 1`ï¼Œ`é—®é¢˜ä¸å¤§ï¼Œæ®Šé€”åŒå½’`

```C++
        //if y < 10 || x*(x+1) % 2 == 0
        opX = new LoadInst ((Value *)x, "", (*i));
        opY = new LoadInst ((Value *)y, "", (*i));

        op = BinaryOperator::Create(Instruction::Sub, (Value *)opX,
            ConstantInt::get(Type::getInt32Ty(M.getContext()), 1,
              false), "", (*i));
        op1 = BinaryOperator::Create(Instruction::Mul, (Value *)opX, op, "", (*i));
        op = BinaryOperator::Create(Instruction::URem, op1,
            ConstantInt::get(Type::getInt32Ty(M.getContext()), 2,
              false), "", (*i));
        condition = new ICmpInst((*i), ICmpInst::ICMP_EQ, op,
            ConstantInt::get(Type::getInt32Ty(M.getContext()), 0,
              false));
        condition2 = new ICmpInst((*i), ICmpInst::ICMP_SLT, opY,
            ConstantInt::get(Type::getInt32Ty(M.getContext()), 10,
              false));
        op1 = BinaryOperator::Create(Instruction::Or, (Value *)condition,
            (Value *)condition2, "", (*i));

```


<br />

> å°†æˆ‘ä»¬ä¸Šé¢çš„ä»£ç ç¨ä½œè°ƒæ•´ï¼Œä»¥å±•ç¤º`ollvm`çš„å®ç°ï¼Œè¿™é‡Œçš„`x * (x + 1) % 2 == 0`ï¼Œä»¥ä¸º`x`å’Œ`x + 1`ï¼Œå¿…ç„¶æ˜¯ä¸€ä¸ªå¥‡æ•°ä¸€ä¸ªå¶æ•°ï¼Œæ ¹æ®å¥‡å¶æ€§çš„è¿ç®—æ³•åˆ™å¯ä»¥å¾—çŸ¥`x * (x + 1)`çš„ç»“æœå¿…ç„¶æ˜¯å¶æ•°ï¼Œæ‰€ä»¥`% 2 == 0`çš„åˆ¤æ–­å°†å¿…ç„¶æˆç«‹

```C++
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
int x = 0;
int y = 0;
int main() {
	if (y < 10 || x * (x + 1) % 2 == 0) {
		printf("hello\n");
	}
	else {
		//unreachable
        	for (int i = 1; i <= 9; i++) {
			for (int j = 1; j <= 9; j++) {
                		printf("%d*%d=%2d\t", i, j, i * j);
			}
            		printf("\n");
        	}
	}
	return 0;
}
```

<br />

### å®ç°
> å—åˆ°`ollvm`ä¸­`ä¼ªé€ æ§åˆ¶æµ`åŠŸèƒ½çš„å¯å‘ï¼Œæˆ‘ä»¬åˆ›å»ºäº†ä¸¤ä¸ªå…¨å±€å˜é‡`x`ã€`y`ï¼Œå¹¶èµ‹åˆå€¼ä¸º`0`ï¼Œä½œä¸ºå®ç°ä¸é€æ˜è°“è¯çš„åŸºç¡€

![image](https://user-images.githubusercontent.com/36320938/132540802-06b63425-acc8-4da8-b9d7-de5886587f42.png)

<br />

> ç”±äºæ ˆç¯å¢ƒçš„å¤æ‚æ€§ï¼Œæˆ‘ä»¬å°†å…¨å±€å˜é‡`x`ã€`y`åˆ†åˆ«èµ‹å€¼ç»™ä¸¤ä¸ªå±€éƒ¨å˜é‡`stack_x`ã€`stack_y`ï¼Œä»¥æé«˜é€†å‘çš„éš¾åº¦

![image](https://user-images.githubusercontent.com/36320938/132541176-02f4f8a7-0b80-4b2a-b584-7658f954a003.png)

<br />

> æˆ‘ä»¬åœ¨å‡½æ•°çš„å¾ˆå¤šä½ç½®åˆ›å»ºäº†`label`ï¼Œä½¿ç”¨`stack_x`ã€`stack_y`è¿›è¡Œæ’ä¸ºçœŸçš„åˆ¤æ–­è¿›è¡Œæ··æ·†ï¼Œåœ¨æ— æ³•åˆ°è¾¾çš„åŸºæœ¬å¿«å†…æ·»åŠ `goto label`ä»¥å°½å¯èƒ½å¾—å¯¹åŸºæœ¬å—è¿›è¡Œæ‹†åˆ†ã€‚æˆ‘ä»¬åœ¨å¤šå¤„å¯¹è§£å¯†åçš„æ•°æ®`decrypted`ä½¿ç”¨é”™è¯¯çš„`key`è¿›è¡Œè§£å¯†ï¼Œä½¿å¾—çœŸå®çš„`key`åœ¨ä¼—å¤šçš„é”™è¯¯çš„`key`ä¸­éš¾ä»¥è¢«è¯†åˆ«ï¼Œ`ä¹±èŠ±æ¸æ¬²è¿·äººçœ¼ï¼Œæµ…è‰æ‰èƒ½æ²¡é©¬è¹„`

![image](https://user-images.githubusercontent.com/36320938/132542465-c9495bde-c34f-468b-ae0f-b9ab79959bba.png)

<br />

> ç”Ÿæˆå¸¦æœ‰èŒƒå›´é™åˆ¶çš„éšæœºæ•°ï¼Œå› ä¸ºè¿™é‡Œå¯ä»¥å‡ºç°ç›¸åŒçš„å€¼ï¼ŒåŒæ—¶åˆå› ä¸ºç¼–è¯‘ä¼˜åŒ–çš„å­˜åœ¨ï¼Œé‡å¤çš„æ¡ä»¶ä¼šè¢«æ¶ˆé™¤ï¼Œè¿™ä½¿å¾—æˆ‘ä»¬æ¯ä¸€æ¬¡çš„ç¼–è¯‘ï¼Œéƒ½æ‹¥æœ‰ä¸å°½ç›¸åŒçš„æ§åˆ¶æµç¨‹å›¾

![image](https://user-images.githubusercontent.com/36320938/132543102-c7c59806-6f34-4f60-b5cf-59abdfa79048.png)

<br />

> æˆ‘ä»¬åœ¨æ— æ³•åˆ°è¾¾çš„åŸºæœ¬å¿«å†…åŠ å…¥éæ³•çš„æ ˆæ“ä½œå†åŠ ä¸Šä»£ç ä¸­ç»è¿‡ç²¾å¿ƒåˆ†é…çš„æ§åˆ¶æµä½¿å¾—`IDA`çš„æ ˆå¸§åˆ†æå¤±è´¥ï¼Œä»¥å¯¹æŠ—`F5`

![image](https://user-images.githubusercontent.com/36320938/132544334-27a63575-35b0-4b52-ac12-9079a984c2bf.png)

<br />

> æˆ‘ä»¬åœ¨å°†æ•°æ®æŒ‰`16`å­—èŠ‚å¯¹é½å¹¶åŠ ä¸Šä¸€å®šçš„éšæœºå€¼ä»¥æ¨¡ç³Šæ•°æ®é•¿åº¦ï¼Œè¿™å¯èƒ½ä¼šæµªè´¹ä¸€ç‚¹ç©ºé—´

![image](https://user-images.githubusercontent.com/36320938/132553464-d8ef7b64-c4a7-4a36-9250-51062751a8d1.png)

<br />

> æˆ‘ä»¬åœ¨å°†`xor`æ›¿æ¢ä¸ºä¸€ç§æ›´åŠ å¤æ‚çš„å®ç°æ–¹å¼ï¼Œä»¥æé«˜é€†å‘çš„éš¾åº¦

![image](https://user-images.githubusercontent.com/36320938/132621379-81796348-23d1-4549-99b7-55e4aa87f0eb.png)

<br />

> ä½¿ç”¨`__TIME__`å®å®ç°æ¯ä¸€æ¬¡ç¼–è¯‘éƒ½æ‹¥æœ‰å”¯ä¸€çš„`key`

![image](https://user-images.githubusercontent.com/36320938/132704045-7510c6df-f2db-4e9b-99b0-ca80aa871aed.png)

<br />

> å¸¦æœ‰èŒƒå›´é™åˆ¶çš„éšæœºæ•°äº§ç”Ÿå™¨ï¼Œä½¿å¾—`ä¸é€æ˜è°“è¯`ç›¸ä¼¼äºæ­£å¸¸çš„`è°“è¯`

![image](https://user-images.githubusercontent.com/36320938/132704535-10761dda-61e7-47b3-95a4-e2439d483532.png)

<br />

> ç»¼ä¸Šæ‰€è¿°ï¼Œåœ¨`oxorany`çš„å¸®åŠ©ä¸‹ï¼Œè½¯ä»¶çš„å®‰å…¨æ€§å°†ä¼šå¾—åˆ°è¿›ä¸€æ­¥çš„æé«˜

### å‚è€ƒ
+ [å­¤æŒºèŠ±ï¼ˆArmaririsï¼‰-- ç”±ä¸Šæµ·äº¤é€šå¤§å­¦å¯†ç ä¸è®¡ç®—æœºå®‰å…¨å®éªŒå®¤ç»´æŠ¤çš„LLVMæ··æ·†æ¡†æ¶](https://github.com/GoSSIP-SJTU/Armariris)
+ [PLCTå®éªŒå®¤ç»´æŠ¤çš„ollvmåˆ†æ”¯](https://github.com/isrc-cas/flounder)
+ [é«˜åº¦çŸ¢é‡åŒ–çš„ c++17 ç¼–è¯‘æ—¶å­—ç¬¦ä¸²åŠ å¯†](https://github.com/JustasMasiulis/xorstr)

### Github
https://github.com/llxiaoyuan/oxorany

```

`source/main.cpp`:

```cpp
#include <iostream>
#define OXORANY_DISABLE_OBFUSCATION
//use OXORANY_USE_BIT_CAST for remove float double src data
#define OXORANY_USE_BIT_CAST
#include "oxorany.h"

enum class MyEnum : int {
    first = 1,
    second = 2,
};

#define NUM_1 1

int main() {
    // output:
    // 1 1 2 c w 00000000 00000000 12 1234 12345678 1234567887654321 1.000000 2.000000
    // string u8 string wstring raw string raw wstring abcd
    //printf(oxorany("%d %d %d %c %C %p %p %hhx %hx %x %llx %f %lf\n%s %s %S %s %S %s\n")  //string
    //       , oxorany(NUM_1)                                                           //macro
    //       , oxorany(MyEnum::first), oxorany(MyEnum::second)                          //enum
    //       , oxorany('c')                                                             //char
    //       , oxorany(L'w')                                                            //wchar_t
    //       , oxorany(NULL), oxorany(nullptr)                                          //pointer
    //       , oxorany(0x12)                                                            //int8_t
    //       , oxorany(0x1234)                                                          //int16_t
    //       , oxorany(0x12345678)                                                      //int32_t
    //       , oxorany(0x1234567887654321)                                              //int64_t
    //       , oxorany_flt(1.0f)                                                            //float
    //       , oxorany_flt(2.0)                                                             //double

    //       , oxorany("string")                                                        //string
    //       , oxorany(u8"u8 string")                                                   //u8 string
    //       , oxorany(L"wstring")                                                      //wstring
    //       , oxorany(R"(raw string)")                                                 //raw string
    //       , oxorany(LR"(raw wstring)")                                               //raw wstring
    //       , oxorany("\x61\x62\x63\x64")                                              //binary data
    //);
    return (int)oxorany_flt(3.0f) + (int)oxorany_flt(6.0);
}

```

`source/oxorany.cpp`:

```cpp
/*

@author llxiaoyuan https://github.com/llxiaoyuan/oxorany

MIT License

Copyright (c) 2021 Chase

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/


#include "oxorany.h"

size_t& _lxy_oxor_any_::X() {
	static size_t x = 0; 
	return x;
}

size_t& _lxy_oxor_any_::Y() {
	static size_t y = 0; 
	return y;
}

```

`source/oxorany.h`:

```h
/*

@author llxiaoyuan https://github.com/llxiaoyuan/oxorany

MIT License

Copyright (c) 2021 Chase

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

#ifndef OXORANY_H
#define OXORANY_H

#if _KERNEL_MODE
#include <ntddk.h>
typedef UINT8 _lxy__uint8_t;
typedef UINT32 _lxy__uint32_t;
typedef UINT64 _lxy__uint64_t;
typedef SIZE_T _lxy__size_t;
#else
#include <stdint.h>
typedef uint8_t _lxy__uint8_t;
typedef uint32_t _lxy__uint32_t;
typedef uint64_t _lxy__uint64_t;
typedef size_t _lxy__size_t;
#endif

#if _WIN32 || _WIN64
#if _WIN64
#define OXORANY_ENVIRONMENT64
#else
#define OXORANY_ENVIRONMENT32
#endif
#endif

#if __GNUC__
#if __x86_64__ || __ppc64__
#define OXORANY_ENVIRONMENT64
#else
#define OXORANY_ENVIRONMENT32
#endif
#endif

#ifdef _MSC_VER
#define OXORANY_FORCEINLINE __forceinline
#else
#define OXORANY_FORCEINLINE __attribute__((always_inline)) inline
#endif

#ifdef _DEBUG
#define oxorany
#define oxorany_flt
#else
#define oxorany(any) _lxy_oxor_any_::oxor_any<decltype(_lxy_oxor_any_::typeofs(any)), _lxy_oxor_any_::array_size(any), __COUNTER__>(any, _lxy_::make_index_sequence<sizeof(decltype(any))>()).get()

#ifdef OXORANY_USE_BIT_CAST
#define oxorany_flt(any) _lxy_::_Bit_cast<decltype(any)>(oxorany((_lxy_::integral_constant<typename _lxy_::type_cast<decltype(any)>::type,_lxy_::_Bit_cast<typename _lxy_::type_cast<decltype(any)>::type>(any)>::value)))
#endif // OXORANY_USE_BIT_CAST

#endif

namespace _lxy_ {

	template<typename T>
	struct type_cast { using type = T; };

	template<>
	struct type_cast<float> { using type = _lxy__uint32_t; };

	template<>
	struct type_cast<double> { using type = _lxy__uint64_t; };

	template <class _Ty, _Ty _Val>
	struct integral_constant {
		static constexpr _Ty value = _Val;

		using value_type = _Ty;
		using type = integral_constant;

		constexpr operator value_type() const noexcept {
			return value;
		}

		/*_NODISCARD*/ constexpr value_type operator()() const noexcept {
			return value;
		}
	};

#ifdef OXORANY_USE_BIT_CAST
	template <class _To, class _From>
	/*_NODISCARD*/ constexpr _To _Bit_cast(const _From& _Val) noexcept {
		return __builtin_bit_cast(_To, _Val);
	}
#endif

	// https://stackoverflow.com/a/32223343/16602611

	template <_lxy__size_t... Ints>
	struct index_sequence {
		using type = index_sequence;
		using value_type = _lxy__size_t;
		static constexpr _lxy__size_t size() noexcept { return sizeof...(Ints); }
	};

	// --------------------------------------------------------------------

	template <class Sequence1, class Sequence2>
	struct _merge_and_renumber;

	template <_lxy__size_t... I1, _lxy__size_t... I2>
	struct _merge_and_renumber<index_sequence<I1...>, index_sequence<I2...>>
		: index_sequence<I1..., (sizeof...(I1) + I2)...>
	{ };

	// --------------------------------------------------------------------

	template <_lxy__size_t N>
	struct make_index_sequence
		: _merge_and_renumber<typename make_index_sequence<N / 2>::type,
		typename make_index_sequence<N - N / 2>::type>
	{ };

	template<> struct make_index_sequence<0> : index_sequence<> { };
	template<> struct make_index_sequence<1> : index_sequence<0> { };
}

namespace _lxy_oxor_any_ {

	/*
	template <_lxy__size_t ...>
	struct indexSequence {
	};

	template <_lxy__size_t N, _lxy__size_t ... Next>
	struct indexSequenceHelper : public indexSequenceHelper<N - 1U, N - 1U, Next...> {
	};

	template <_lxy__size_t ... Next>
	struct indexSequenceHelper<0U, Next ... > {
		using type = indexSequence<Next ... >;
	};

	template <_lxy__size_t N>
	using makeIndexSequence = typename indexSequenceHelper<N>::type;
	*/

	_lxy__size_t& X();

	_lxy__size_t& Y();

	static constexpr _lxy__size_t base_key = static_cast<_lxy__size_t>(
		((_lxy__size_t)__TIME__[7] - '0') +
		((_lxy__size_t)__TIME__[6] - '0') * 10 +
		((_lxy__size_t)__TIME__[4] - '0') * 60 +
		((_lxy__size_t)__TIME__[3] - '0') * 600 +
		((_lxy__size_t)__TIME__[1] - '0') * 3600 +
		((_lxy__size_t)__TIME__[0] - '0') * 36000);

	template<_lxy__uint32_t s, _lxy__size_t n>
	class random_constant_32 {
		static constexpr _lxy__uint32_t x = s ^ (s << 13);
		static constexpr _lxy__uint32_t y = x ^ (x >> 17);
		static constexpr _lxy__uint32_t z = y ^ (y << 5);
	public:
		static constexpr _lxy__uint32_t value = random_constant_32<z, n - 1>::value;
	};

	template<_lxy__uint32_t s>
	class random_constant_32<s, 0> {
	public:
		static constexpr _lxy__uint32_t value = s;
	};

	template<_lxy__uint64_t s, _lxy__size_t n>
	class random_constant_64 {
		static constexpr _lxy__uint64_t x = s ^ (s << 13);
		static constexpr _lxy__uint64_t y = x ^ (x >> 7);
		static constexpr _lxy__uint64_t z = y ^ (y << 17);
	public:
		static constexpr _lxy__uint64_t value = random_constant_64<z, n - 1>::value;
	};

	template<_lxy__uint64_t s>
	class random_constant_64<s, 0> {
	public:
		static constexpr _lxy__uint64_t value = s;
	};

#ifdef OXORANY_ENVIRONMENT64
#define random_constant random_constant_64
#else
#define random_constant random_constant_32
#endif 

	template<typename T, _lxy__size_t size>
	static OXORANY_FORCEINLINE constexpr _lxy__size_t array_size(const T(&)[size]) { return size; }

	template<typename T>
	static OXORANY_FORCEINLINE constexpr _lxy__size_t array_size(T) { return 0; }

	template<typename T, _lxy__size_t size>
	static inline T typeofs(const T(&)[size]);

	template<typename T>
	static inline T typeofs(T);

	template<_lxy__size_t key>
	static OXORANY_FORCEINLINE constexpr _lxy__uint8_t encrypt_byte(_lxy__uint8_t c, _lxy__size_t i) {
		return static_cast<_lxy__uint8_t>(((c + (key * 7)) ^ (i + key)));
	}

	template<_lxy__size_t key>
	static OXORANY_FORCEINLINE constexpr _lxy__uint8_t decrypt_byte(_lxy__uint8_t c, _lxy__size_t i) {
		//a ^ b == (a + b) - 2 * (a & b)
		_lxy__size_t a = c;
		_lxy__size_t b = i + key;
		//_lxy__size_t a_xor_b = (a + b) - 2 * (a & b);
		_lxy__size_t a_xor_b = (a + b) - ((a & b) + (b & a));
		return static_cast<_lxy__uint8_t>((a_xor_b)-(key * 7));
	}

	template<_lxy__size_t key>
	static OXORANY_FORCEINLINE constexpr _lxy__size_t limit() {
		constexpr _lxy__size_t bcf_value[] = { 1,2,3,4,5, 6,8,9,10,16, 32,40,64,66,100, 128,512,1000,1024,4096, 'a','z','A','Z','*' };
		return bcf_value[key % (sizeof(bcf_value) / sizeof(bcf_value[0]))];
	}

	template<typename return_type, _lxy__size_t key, _lxy__size_t size>
	static OXORANY_FORCEINLINE const return_type decrypt(_lxy__uint8_t(&buffer)[size]) {
#ifndef OXORANY_DISABLE_OBFUSCATION

		_lxy__uint8_t source;
		_lxy__uint8_t decrypted; //do not assign initial value
		_lxy__size_t stack_x;
		_lxy__size_t stack_y;

	loc_start_1:
		stack_x = X();
		stack_y = Y();
	loc_start_2:
		for (_lxy__size_t i = 0; i < size; i++) {
			source = buffer[i];
		loc_start_3:
			if (stack_x <= i) {
				if (stack_x < stack_y + limit<key * __COUNTER__>()) {
					decrypted = decrypt_byte<key* __COUNTER__>(source, i);//fake
				}
				else if (stack_x == stack_y + limit<key * __COUNTER__>() % 1 + 1) {
					//unreachable
					decrypted = decrypt_byte<key* __COUNTER__>(source, i);
					goto loc_unreachable_9;
				}
				else if (stack_x == stack_y + limit<key * __COUNTER__>() % 2 + 1) {
					//unreachable
					decrypted = decrypt_byte<key* __COUNTER__>(source, i);
					goto loc_unreachable_8;
				}
				else if (stack_x == stack_y + limit<key * __COUNTER__>() % 3 + 1) {
					//unreachable
					decrypted = decrypt_byte<key* __COUNTER__>(source, i);
					goto loc_unreachable_7;
				}
				else if (stack_x == stack_y + limit<key * __COUNTER__>() % 4 + 1) {
					//unreachable
					decrypted = decrypt_byte<key* __COUNTER__>(source, i);
					goto loc_unreachable_6;
				}
				else if (stack_x == stack_y + limit<key * __COUNTER__>() % 5 + 1) {
					//unreachable
					decrypted = decrypt_byte<key* __COUNTER__>(source, i);
					goto loc_unreachable_5;
				}
				else if (stack_x == stack_y + limit<key * __COUNTER__>() % 6 + 1) {
					//unreachable
					decrypted = decrypt_byte<key* __COUNTER__>(source, i);
					goto loc_unreachable_4;
				}
				else if (stack_x == stack_y + limit<key * __COUNTER__>() % 7 + 1) {
					//unreachable
					decrypted = decrypt_byte<key* __COUNTER__>(source, i);
					goto loc_unreachable_3;
				}
				else if (stack_x == stack_y + limit<key * __COUNTER__>() % 8 + 1) {
					//unreachable
					decrypted = decrypt_byte<key* __COUNTER__>(source, i);
					goto loc_unreachable_2;
				}
				else if (stack_x == stack_y + limit<key * __COUNTER__>() % 9 + 1) {
					//unreachable
					decrypted = decrypt_byte<key* __COUNTER__>(source, i);
					goto loc_unreachable_1;
				}
			loc_start_4:
				if (stack_y <= i) {
					if (stack_x < stack_y + limit<key * __COUNTER__>()) {
						decrypted = decrypt_byte<key* __COUNTER__>(source, i);//fake
					}
					else if (stack_x == stack_y + limit<key * __COUNTER__>() % 1 + 1) {
						//unreachable
						decrypted = decrypt_byte<key* __COUNTER__>(source, i);
						goto loc_unreachable_1;
					}
					else if (stack_x == stack_y + limit<key * __COUNTER__>() % 2 + 1) {
						//unreachable
						decrypted = decrypt_byte<key* __COUNTER__>(source, i);
						goto loc_unreachable_2;
					}
					else if (stack_x == stack_y + limit<key * __COUNTER__>() % 3 + 1) {
						//unreachable
						decrypted = decrypt_byte<key* __COUNTER__>(source, i);
						goto loc_unreachable_3;
					}
					else if (stack_x == stack_y + limit<key * __COUNTER__>() % 4 + 1) {
						//unreachable
						decrypted = decrypt_byte<key* __COUNTER__>(source, i);
						goto loc_unreachable_4;
					}
					else if (stack_x == stack_y + limit<key * __COUNTER__>() % 5 + 1) {
						//unreachable
						decrypted = decrypt_byte<key* __COUNTER__>(source, i);
						goto loc_unreachable_5;
					}
					else if (stack_x == stack_y + limit<key * __COUNTER__>() % 6 + 1) {
						//unreachable
						decrypted = decrypt_byte<key* __COUNTER__>(source, i);
						goto loc_unreachable_6;
					}
					else if (stack_x == stack_y + limit<key * __COUNTER__>() % 7 + 1) {
						//unreachable
						decrypted = decrypt_byte<key* __COUNTER__>(source, i);
						goto loc_unreachable_7;
					}
					else if (stack_x == stack_y + limit<key * __COUNTER__>() % 8 + 1) {
						//unreachable
						decrypted = decrypt_byte<key* __COUNTER__>(source, i);
						goto loc_unreachable_8;
					}
					else if (stack_x == stack_y + limit<key * __COUNTER__>() % 9 + 1) {
						//unreachable
						decrypted = decrypt_byte<key* __COUNTER__>(source, i);
						goto loc_unreachable_9;
					}
				loc_start_5:
					if (stack_x + stack_y <= i) {
						if (stack_x < stack_y + limit<key * __COUNTER__>()) {
							decrypted = decrypt_byte<key>(source, i);//real
						}
						else if (stack_x == stack_y + limit<key * __COUNTER__>() % 1 + 1) {
							//unreachable
							decrypted = decrypt_byte<key* __COUNTER__>(source, i);
							goto loc_unreachable_9;
						}
						else if (stack_x == stack_y + limit<key * __COUNTER__>() % 2 + 1) {
							//unreachable
							decrypted = decrypt_byte<key* __COUNTER__>(source, i);
							goto loc_unreachable_8;
						}
						else if (stack_x == stack_y + limit<key * __COUNTER__>() % 3 + 1) {
							//unreachable
							decrypted = decrypt_byte<key* __COUNTER__>(source, i);
							goto loc_unreachable_7;
						}
						else if (stack_x == stack_y + limit<key * __COUNTER__>() % 4 + 1) {
							//unreachable
							decrypted = decrypt_byte<key* __COUNTER__>(source, i);
							goto loc_unreachable_6;
						}
						else if (stack_x == stack_y + limit<key * __COUNTER__>() % 5 + 1) {
							//unreachable
							decrypted = decrypt_byte<key* __COUNTER__>(source, i);
							goto loc_unreachable_5;
						}
						else if (stack_x == stack_y + limit<key * __COUNTER__>() % 6 + 1) {
							//unreachable
							decrypted = decrypt_byte<key* __COUNTER__>(source, i);
							goto loc_unreachable_4;
						}
						else if (stack_x == stack_y + limit<key * __COUNTER__>() % 7 + 1) {
							//unreachable
							decrypted = decrypt_byte<key* __COUNTER__>(source, i);
							goto loc_unreachable_3;
						}
						else if (stack_x == stack_y + limit<key * __COUNTER__>() % 8 + 1) {
							//unreachable
							decrypted = decrypt_byte<key* __COUNTER__>(source, i);
							goto loc_unreachable_2;
						}
						else if (stack_x == stack_y + limit<key * __COUNTER__>() % 9 + 1) {
							//unreachable
							decrypted = decrypt_byte<key* __COUNTER__>(source, i);
							goto loc_unreachable_1;
						}
					loc_start_6:
						if (stack_x + stack_y != limit<key * __COUNTER__>()) {
							if (stack_x > stack_y + limit<key * __COUNTER__>()) {
								//unreachable
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
							}
							else if (stack_x == stack_y + limit<key * __COUNTER__>() % 1 + 1) {
								//unreachable
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_1;
							}
							else if (stack_x == stack_y + limit<key * __COUNTER__>() % 2 + 1) {
								//unreachable
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_2;
							}
							else if (stack_x == stack_y + limit<key * __COUNTER__>() % 3 + 1) {
								//unreachable
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_3;
							}
							else if (stack_x == stack_y + limit<key * __COUNTER__>() % 4 + 1) {
								//unreachable
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_4;
							}
							else if (stack_x == stack_y + limit<key * __COUNTER__>() % 5 + 1) {
								//unreachable
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_5;
							}
							else if (stack_x == stack_y + limit<key * __COUNTER__>() % 6 + 1) {
								//unreachable
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_6;
							}
							else if (stack_x == stack_y + limit<key * __COUNTER__>() % 7 + 1) {
								//unreachable
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_7;
							}
							else if (stack_x == stack_y + limit<key * __COUNTER__>() % 8 + 1) {
								//unreachable
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_8;
							}
							else if (stack_x == stack_y + limit<key * __COUNTER__>() % 9 + 1) {
								//unreachable
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_9;
							}
						loc_start_7:
							if (stack_x < limit<key * __COUNTER__>()) {
								if (stack_x > stack_y + limit<key * __COUNTER__>()) {
									//unreachable
									decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								}
								else if (stack_x == stack_y + limit<key * __COUNTER__>() % 1 + 1) {
									//unreachable
									decrypted = decrypt_byte<key* __COUNTER__>(source, i);
									goto loc_unreachable_9;
								}
								else if (stack_x == stack_y + limit<key * __COUNTER__>() % 2 + 1) {
									//unreachable
									decrypted = decrypt_byte<key* __COUNTER__>(source, i);
									goto loc_unreachable_8;
								}
								else if (stack_x == stack_y + limit<key * __COUNTER__>() % 3 + 1) {
									//unreachable
									decrypted = decrypt_byte<key* __COUNTER__>(source, i);
									goto loc_unreachable_7;
								}
								else if (stack_x == stack_y + limit<key * __COUNTER__>() % 4 + 1) {
									//unreachable
									decrypted = decrypt_byte<key* __COUNTER__>(source, i);
									goto loc_unreachable_6;
								}
								else if (stack_x == stack_y + limit<key * __COUNTER__>() % 5 + 1) {
									//unreachable
									decrypted = decrypt_byte<key* __COUNTER__>(source, i);
									goto loc_unreachable_5;
								}
								else if (stack_x == stack_y + limit<key * __COUNTER__>() % 6 + 1) {
									//unreachable
									decrypted = decrypt_byte<key* __COUNTER__>(source, i);
									goto loc_unreachable_4;
								}
								else if (stack_x == stack_y + limit<key * __COUNTER__>() % 7 + 1) {
									//unreachable
									decrypted = decrypt_byte<key* __COUNTER__>(source, i);
									goto loc_unreachable_3;
								}
								else if (stack_x == stack_y + limit<key * __COUNTER__>() % 8 + 1) {
									//unreachable
									decrypted = decrypt_byte<key* __COUNTER__>(source, i);
									goto loc_unreachable_2;
								}
								else if (stack_x == stack_y + limit<key * __COUNTER__>() % 9 + 1) {
									//unreachable
									decrypted = decrypt_byte<key* __COUNTER__>(source, i);
									goto loc_unreachable_1;
								}
							loc_start_8:
								if (stack_y < limit<key * __COUNTER__>()) {
								loc_start_9:
									buffer[i] = decrypted;//assign
								}
								else {
									//unreachable
									decrypted = decrypt_byte<key* __COUNTER__>(source, i);
									decrypted += decrypted;
								loc_unreachable_1:
									buffer[i] = decrypt_byte<key* __COUNTER__>(source, i);
								loc_unreachable_2:
									stack_y++;
								loc_unreachable_3:
									i--;
								}
							}
							else {
								//unreachable
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								decrypted += buffer[i];
							loc_unreachable_4:
								buffer[i] = decrypt_byte<key* __COUNTER__>(source, i);
								buffer[i] += decrypted;
							loc_unreachable_5:
								stack_x += stack_y;
							loc_unreachable_6:
								i--;
								i -= decrypted;
							}
						}
						else {
							//unreachable
							decrypted = decrypt_byte<key* __COUNTER__>(source, i);
							decrypted -= buffer[i];
						loc_unreachable_7:
							buffer[i] = decrypt_byte<key* __COUNTER__>(source, i);
							stack_y++;
							i -= buffer[i];
							i -= stack_y;
						loc_unreachable_8:
							buffer[i] = decrypt_byte<key* __COUNTER__>(source, i);
							stack_x++;
							i--;
							i -= stack_x;
						loc_unreachable_9:
							i += buffer[i];
							i += stack_y;
							continue;
						}
					}
					else {
						//unreachable
						while (true) {
							if (stack_x == stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_1;
							}
							else if (stack_x == stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_2;
							}
							else if (stack_x == stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_3;
							}
							else if (stack_x == stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_4;
							}
							else if (stack_x == stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_5;
							}
							else if (stack_x == stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_6;
							}
							else if (stack_x == stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_7;
							}
							else if (stack_x == stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_8;
							}
							else if (stack_x == stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_9;
							}
							else if (stack_x == stack_y + limit<key * __COUNTER__>()) {
								continue;
							}
							else {
								stack_x = stack_y + limit<key* __COUNTER__>();
								stack_y = stack_x + limit<key* __COUNTER__>();
							}

							if (stack_x < stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_start_1;
							}
							else if (stack_x < stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_start_2;
							}
							else if (stack_x < stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_start_3;
							}
							else if (stack_x < stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_start_4;
							}
							else if (stack_x < stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_start_5;
							}
							else if (stack_x < stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_start_6;
							}
							else if (stack_x < stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_start_7;
							}
							else if (stack_x < stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_start_8;
							}
							else if (stack_x < stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_start_9;
							}
							else if (stack_x < stack_y + limit<key * __COUNTER__>()) {
								continue;
							}
							else {
								stack_x = stack_y + limit<key* __COUNTER__>();
								stack_y = stack_x + limit<key* __COUNTER__>();
							}

							if (stack_x > stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_9;
							}
							else if (stack_x > stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_8;
							}
							else if (stack_x > stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_7;
							}
							else if (stack_x > stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_6;
							}
							else if (stack_x > stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_5;
							}
							else if (stack_x > stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_4;
							}
							else if (stack_x > stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_3;
							}
							else if (stack_x > stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_2;
							}
							else if (stack_x > stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_1;
							}
							else if (stack_x > stack_y + limit<key * __COUNTER__>()) {
								continue;
							}
							else {
								stack_x = stack_y + limit<key* __COUNTER__>();
								stack_y = stack_x + limit<key* __COUNTER__>();
							}
						}
					}
				}
				else {
					//unreachable
					//Ooops, Decompilation failure:
					//401000: stack frame is too big
					return reinterpret_cast<return_type>(buffer + ((key * __COUNTER__) % 0x400000 + 0x1400000));
				}
			}
			else {
				//unreachable
				//Ooops, Decompilation failure:
				//401000: stack frame is too big
				return reinterpret_cast<return_type>(buffer + ((key * __COUNTER__) % 0x1400000 + 0x400000));
			}
		}

#else
		for (volatile _lxy__size_t i = 0; i < size; i++) {
			buffer[i] = decrypt_byte<key>(buffer[i], i);
		}
#endif // OXORANY_DISABLE_OBFUSCATION
		return reinterpret_cast<return_type>(buffer);
	}

	static OXORANY_FORCEINLINE constexpr _lxy__size_t align(_lxy__size_t n, _lxy__size_t a) {
		return (n + a - 1) & ~(a - 1);
	}

	template<typename any_t, _lxy__size_t ary_size, _lxy__size_t counter>
	class oxor_any {

		static constexpr _lxy__size_t size = align(ary_size * sizeof(any_t), 16)
			+ random_constant<counter^ base_key, (counter^ base_key) % 128>::value % (16 + 1);

		static constexpr _lxy__size_t key = random_constant<counter^ base_key, (size^ base_key) % 128>::value;

		_lxy__uint8_t buffer[size];

	public:

		template<_lxy__size_t... indices>
		OXORANY_FORCEINLINE constexpr oxor_any(const any_t(&any)[ary_size], _lxy_::index_sequence<indices...>) :
			buffer{ encrypt_byte<key>(((_lxy__uint8_t*)&any)[indices], indices)... } {
		}

		OXORANY_FORCEINLINE const any_t* get() { return decrypt<const any_t*, key>(buffer); }
	};

	template<typename any_t, _lxy__size_t counter>
	class oxor_any<any_t, 0, counter> {

		static constexpr _lxy__size_t size = align(sizeof(any_t), 16)
			+ random_constant<counter^ base_key, (counter^ base_key) % 128>::value % (16 + 1);

		static constexpr _lxy__size_t key = random_constant<counter^ base_key, (size^ base_key) % 128>::value;

		_lxy__uint8_t buffer[size];

	public:

		template<_lxy__size_t... indices>
		OXORANY_FORCEINLINE constexpr oxor_any(any_t any, _lxy_::index_sequence<indices...>) :
			buffer{ encrypt_byte<key>(reinterpret_cast<_lxy__uint8_t*>(&any)[indices], indices)... } {
		}

		OXORANY_FORCEINLINE const any_t get() { return *decrypt<const any_t*, key>(buffer); }
	};
}

#endif // OXORANY_H
```

`source/oxorany_bak.h`:

```h
/*

@author llxiaoyuan https://github.com/llxiaoyuan/oxorany

MIT License

Copyright (c) 2021 Chase

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

#ifndef OXORANY_H
#define OXORANY_H

#if _KERNEL_MODE
#ifndef _VCRUNTIME_DISABLED_WARNINGS
#define _VCRUNTIME_DISABLED_WARNINGS
#endif
#endif

#include <stdint.h>

#if _WIN32 || _WIN64
#if _WIN64
#define OXORANY_ENVIRONMENT64
#else
#define OXORANY_ENVIRONMENT32
#endif
#endif

#if __GNUC__
#if __x86_64__ || __ppc64__
#define OXORANY_ENVIRONMENT64
#else
#define OXORANY_ENVIRONMENT32
#endif
#endif

#ifdef _MSC_VER
#define OXORANY_FORCEINLINE __forceinline
#else
#define OXORANY_FORCEINLINE __attribute__((always_inline)) inline
#endif

#ifdef _DEBUG
#define oxorany
#else
#define oxorany_old(any) _lxy_oxor_any_::oxor_any<decltype(_lxy_oxor_any_::typeofs(any)), _lxy_oxor_any_::array_size(any), __COUNTER__>(any, _lxy_::make_index_sequence<sizeof(decltype(any))>()).get()

#ifdef OXORANY_USE_BIT_CAST
#define oxorany(any) _lxy_::_Bit_cast<decltype(any)>(oxorany_old((_lxy_::integral_constant<typename _lxy_::type_cast<decltype(any)>::type,_lxy_::_Bit_cast<typename _lxy_::type_cast<decltype(any)>::type>(any) >::value)))
#else
#define oxorany oxorany_old
#endif // OXORANY_USE_BIT_CAST

#endif

namespace _lxy_ {

	template<typename T>
	struct type_cast { using type = T; };

	template<>
	struct type_cast<float> { using type = uint32_t; };

	template<>
	struct type_cast<double> { using type = uint64_t; };

	template <class _Ty, _Ty _Val>
	struct integral_constant {
		static constexpr _Ty value = _Val;

		using value_type = _Ty;
		using type = integral_constant;

		constexpr operator value_type() const noexcept {
			return value;
		}

		_NODISCARD constexpr value_type operator()() const noexcept {
			return value;
		}
	};

#ifdef OXORANY_USE_BIT_CAST
	template <class _To, class _From>
	_NODISCARD constexpr _To _Bit_cast(const _From& _Val) noexcept {
		return __builtin_bit_cast(_To, _Val);
	}
#endif

	// https://stackoverflow.com/a/32223343/16602611

	template <size_t... Ints>
	struct index_sequence {
		using type = index_sequence;
		using value_type = size_t;
		static constexpr size_t size() noexcept { return sizeof...(Ints); }
	};

	// --------------------------------------------------------------------

	template <class Sequence1, class Sequence2>
	struct _merge_and_renumber;

	template <size_t... I1, size_t... I2>
	struct _merge_and_renumber<index_sequence<I1...>, index_sequence<I2...>>
		: index_sequence<I1..., (sizeof...(I1) + I2)...>
	{ };

	// --------------------------------------------------------------------

	template <size_t N>
	struct make_index_sequence
		: _merge_and_renumber<typename make_index_sequence<N / 2>::type,
		typename make_index_sequence<N - N / 2>::type>
	{ };

	template<> struct make_index_sequence<0> : index_sequence<> { };
	template<> struct make_index_sequence<1> : index_sequence<0> { };
}

namespace _lxy_oxor_any_ {

	/*
	template <size_t ...>
	struct indexSequence {
	};

	template <size_t N, size_t ... Next>
	struct indexSequenceHelper : public indexSequenceHelper<N - 1U, N - 1U, Next...> {
	};

	template <size_t ... Next>
	struct indexSequenceHelper<0U, Next ... > {
		using type = indexSequence<Next ... >;
	};

	template <size_t N>
	using makeIndexSequence = typename indexSequenceHelper<N>::type;
	*/

	size_t& X();

	size_t& Y();

	static constexpr size_t base_key = static_cast<size_t>(
		(__TIME__[7] - '0') +
		(__TIME__[6] - '0') * 10 +
		(__TIME__[4] - '0') * 60 +
		(__TIME__[3] - '0') * 600 +
		(__TIME__[1] - '0') * 3600 +
		(__TIME__[0] - '0') * 36000);

	template<uint32_t s, size_t n>
	class random_constant_32 {
		static constexpr uint32_t x = s ^ (s << 13);
		static constexpr uint32_t y = x ^ (x >> 17);
		static constexpr uint32_t z = y ^ (y << 5);
	public:
		static constexpr uint32_t value = random_constant_32<z, n - 1>::value;
	};

	template<uint32_t s>
	class random_constant_32<s, 0> {
	public:
		static constexpr uint32_t value = s;
	};

	template<uint64_t s, size_t n>
	class random_constant_64 {
		static constexpr uint64_t x = s ^ (s << 13);
		static constexpr uint64_t y = x ^ (x >> 7);
		static constexpr uint64_t z = y ^ (y << 17);
	public:
		static constexpr uint64_t value = random_constant_64<z, n - 1>::value;
	};

	template<uint64_t s>
	class random_constant_64<s, 0> {
	public:
		static constexpr uint64_t value = s;
	};

#ifdef OXORANY_ENVIRONMENT64
#define random_constant random_constant_64
#else
#define random_constant random_constant_32
#endif 

	template<typename T, size_t size>
	static OXORANY_FORCEINLINE constexpr size_t array_size(const T(&)[size]) { return size; }

	template<typename T>
	static OXORANY_FORCEINLINE constexpr size_t array_size(T) { return 0; }

	template<typename T, size_t size>
	static inline T typeofs(const T(&)[size]);

	template<typename T>
	static inline T typeofs(T);

	template<size_t key>
	static OXORANY_FORCEINLINE constexpr uint8_t encrypt_byte(uint8_t c, size_t i) {
		return static_cast<uint8_t>(((c + (key * 7)) ^ (i + key)));
	}

	template<size_t key>
	static OXORANY_FORCEINLINE constexpr uint8_t decrypt_byte(uint8_t c, size_t i) {
		//a ^ b == (a + b) - 2 * (a & b)
		size_t a = c;
		size_t b = i + key;
		//size_t a_xor_b = (a + b) - 2 * (a & b);
		size_t a_xor_b = (a + b) - ((a & b) + (b & a));
		return static_cast<uint8_t>((a_xor_b)-(key * 7));
	}

	template<size_t key>
	static OXORANY_FORCEINLINE constexpr size_t limit() {
		constexpr size_t bcf_value[] = { 1,2,3,4,5, 6,8,9,10,16, 32,40,64,66,100, 128,512,1000,1024,4096, 'a','z','A','Z','*' };
		return bcf_value[key % (sizeof(bcf_value) / sizeof(bcf_value[0]))];
	}

	template<typename return_type, size_t key, size_t size>
	static OXORANY_FORCEINLINE const return_type decrypt(uint8_t(&buffer)[size]) {
#ifndef OXORANY_DISABLE_OBFUSCATION

		uint8_t source;
		uint8_t decrypted; //do not assign initial value
		size_t stack_x;
		size_t stack_y;

	loc_start_1:
		stack_x = X();
		stack_y = Y();
	loc_start_2:
		for (size_t i = 0; i < size; i++) {
			source = buffer[i];
		loc_start_3:
			if (stack_x <= i) {
				if (stack_x < stack_y + limit<key * __COUNTER__>()) {
					decrypted = decrypt_byte<key* __COUNTER__>(source, i);//fake
				}
				else if (stack_x == stack_y + limit<key * __COUNTER__>() % 1 + 1) {
					//unreachable
					decrypted = decrypt_byte<key* __COUNTER__>(source, i);
					goto loc_unreachable_9;
				}
				else if (stack_x == stack_y + limit<key * __COUNTER__>() % 2 + 1) {
					//unreachable
					decrypted = decrypt_byte<key* __COUNTER__>(source, i);
					goto loc_unreachable_8;
				}
				else if (stack_x == stack_y + limit<key * __COUNTER__>() % 3 + 1) {
					//unreachable
					decrypted = decrypt_byte<key* __COUNTER__>(source, i);
					goto loc_unreachable_7;
				}
				else if (stack_x == stack_y + limit<key * __COUNTER__>() % 4 + 1) {
					//unreachable
					decrypted = decrypt_byte<key* __COUNTER__>(source, i);
					goto loc_unreachable_6;
				}
				else if (stack_x == stack_y + limit<key * __COUNTER__>() % 5 + 1) {
					//unreachable
					decrypted = decrypt_byte<key* __COUNTER__>(source, i);
					goto loc_unreachable_5;
				}
				else if (stack_x == stack_y + limit<key * __COUNTER__>() % 6 + 1) {
					//unreachable
					decrypted = decrypt_byte<key* __COUNTER__>(source, i);
					goto loc_unreachable_4;
				}
				else if (stack_x == stack_y + limit<key * __COUNTER__>() % 7 + 1) {
					//unreachable
					decrypted = decrypt_byte<key* __COUNTER__>(source, i);
					goto loc_unreachable_3;
				}
				else if (stack_x == stack_y + limit<key * __COUNTER__>() % 8 + 1) {
					//unreachable
					decrypted = decrypt_byte<key* __COUNTER__>(source, i);
					goto loc_unreachable_2;
				}
				else if (stack_x == stack_y + limit<key * __COUNTER__>() % 9 + 1) {
					//unreachable
					decrypted = decrypt_byte<key* __COUNTER__>(source, i);
					goto loc_unreachable_1;
				}
			loc_start_4:
				if (stack_y <= i) {
					if (stack_x < stack_y + limit<key * __COUNTER__>()) {
						decrypted = decrypt_byte<key* __COUNTER__>(source, i);//fake
					}
					else if (stack_x == stack_y + limit<key * __COUNTER__>() % 1 + 1) {
						//unreachable
						decrypted = decrypt_byte<key* __COUNTER__>(source, i);
						goto loc_unreachable_1;
					}
					else if (stack_x == stack_y + limit<key * __COUNTER__>() % 2 + 1) {
						//unreachable
						decrypted = decrypt_byte<key* __COUNTER__>(source, i);
						goto loc_unreachable_2;
					}
					else if (stack_x == stack_y + limit<key * __COUNTER__>() % 3 + 1) {
						//unreachable
						decrypted = decrypt_byte<key* __COUNTER__>(source, i);
						goto loc_unreachable_3;
					}
					else if (stack_x == stack_y + limit<key * __COUNTER__>() % 4 + 1) {
						//unreachable
						decrypted = decrypt_byte<key* __COUNTER__>(source, i);
						goto loc_unreachable_4;
					}
					else if (stack_x == stack_y + limit<key * __COUNTER__>() % 5 + 1) {
						//unreachable
						decrypted = decrypt_byte<key* __COUNTER__>(source, i);
						goto loc_unreachable_5;
					}
					else if (stack_x == stack_y + limit<key * __COUNTER__>() % 6 + 1) {
						//unreachable
						decrypted = decrypt_byte<key* __COUNTER__>(source, i);
						goto loc_unreachable_6;
					}
					else if (stack_x == stack_y + limit<key * __COUNTER__>() % 7 + 1) {
						//unreachable
						decrypted = decrypt_byte<key* __COUNTER__>(source, i);
						goto loc_unreachable_7;
					}
					else if (stack_x == stack_y + limit<key * __COUNTER__>() % 8 + 1) {
						//unreachable
						decrypted = decrypt_byte<key* __COUNTER__>(source, i);
						goto loc_unreachable_8;
					}
					else if (stack_x == stack_y + limit<key * __COUNTER__>() % 9 + 1) {
						//unreachable
						decrypted = decrypt_byte<key* __COUNTER__>(source, i);
						goto loc_unreachable_9;
					}
				loc_start_5:
					if (stack_x + stack_y <= i) {
						if (stack_x < stack_y + limit<key * __COUNTER__>()) {
							decrypted = decrypt_byte<key>(source, i);//real
						}
						else if (stack_x == stack_y + limit<key * __COUNTER__>() % 1 + 1) {
							//unreachable
							decrypted = decrypt_byte<key* __COUNTER__>(source, i);
							goto loc_unreachable_9;
						}
						else if (stack_x == stack_y + limit<key * __COUNTER__>() % 2 + 1) {
							//unreachable
							decrypted = decrypt_byte<key* __COUNTER__>(source, i);
							goto loc_unreachable_8;
						}
						else if (stack_x == stack_y + limit<key * __COUNTER__>() % 3 + 1) {
							//unreachable
							decrypted = decrypt_byte<key* __COUNTER__>(source, i);
							goto loc_unreachable_7;
						}
						else if (stack_x == stack_y + limit<key * __COUNTER__>() % 4 + 1) {
							//unreachable
							decrypted = decrypt_byte<key* __COUNTER__>(source, i);
							goto loc_unreachable_6;
						}
						else if (stack_x == stack_y + limit<key * __COUNTER__>() % 5 + 1) {
							//unreachable
							decrypted = decrypt_byte<key* __COUNTER__>(source, i);
							goto loc_unreachable_5;
						}
						else if (stack_x == stack_y + limit<key * __COUNTER__>() % 6 + 1) {
							//unreachable
							decrypted = decrypt_byte<key* __COUNTER__>(source, i);
							goto loc_unreachable_4;
						}
						else if (stack_x == stack_y + limit<key * __COUNTER__>() % 7 + 1) {
							//unreachable
							decrypted = decrypt_byte<key* __COUNTER__>(source, i);
							goto loc_unreachable_3;
						}
						else if (stack_x == stack_y + limit<key * __COUNTER__>() % 8 + 1) {
							//unreachable
							decrypted = decrypt_byte<key* __COUNTER__>(source, i);
							goto loc_unreachable_2;
						}
						else if (stack_x == stack_y + limit<key * __COUNTER__>() % 9 + 1) {
							//unreachable
							decrypted = decrypt_byte<key* __COUNTER__>(source, i);
							goto loc_unreachable_1;
						}
					loc_start_6:
						if (stack_x + stack_y != limit<key * __COUNTER__>()) {
							if (stack_x > stack_y + limit<key * __COUNTER__>()) {
								//unreachable
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
							}
							else if (stack_x == stack_y + limit<key * __COUNTER__>() % 1 + 1) {
								//unreachable
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_1;
							}
							else if (stack_x == stack_y + limit<key * __COUNTER__>() % 2 + 1) {
								//unreachable
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_2;
							}
							else if (stack_x == stack_y + limit<key * __COUNTER__>() % 3 + 1) {
								//unreachable
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_3;
							}
							else if (stack_x == stack_y + limit<key * __COUNTER__>() % 4 + 1) {
								//unreachable
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_4;
							}
							else if (stack_x == stack_y + limit<key * __COUNTER__>() % 5 + 1) {
								//unreachable
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_5;
							}
							else if (stack_x == stack_y + limit<key * __COUNTER__>() % 6 + 1) {
								//unreachable
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_6;
							}
							else if (stack_x == stack_y + limit<key * __COUNTER__>() % 7 + 1) {
								//unreachable
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_7;
							}
							else if (stack_x == stack_y + limit<key * __COUNTER__>() % 8 + 1) {
								//unreachable
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_8;
							}
							else if (stack_x == stack_y + limit<key * __COUNTER__>() % 9 + 1) {
								//unreachable
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_9;
							}
						loc_start_7:
							if (stack_x < limit<key * __COUNTER__>()) {
								if (stack_x > stack_y + limit<key * __COUNTER__>()) {
									//unreachable
									decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								}
								else if (stack_x == stack_y + limit<key * __COUNTER__>() % 1 + 1) {
									//unreachable
									decrypted = decrypt_byte<key* __COUNTER__>(source, i);
									goto loc_unreachable_9;
								}
								else if (stack_x == stack_y + limit<key * __COUNTER__>() % 2 + 1) {
									//unreachable
									decrypted = decrypt_byte<key* __COUNTER__>(source, i);
									goto loc_unreachable_8;
								}
								else if (stack_x == stack_y + limit<key * __COUNTER__>() % 3 + 1) {
									//unreachable
									decrypted = decrypt_byte<key* __COUNTER__>(source, i);
									goto loc_unreachable_7;
								}
								else if (stack_x == stack_y + limit<key * __COUNTER__>() % 4 + 1) {
									//unreachable
									decrypted = decrypt_byte<key* __COUNTER__>(source, i);
									goto loc_unreachable_6;
								}
								else if (stack_x == stack_y + limit<key * __COUNTER__>() % 5 + 1) {
									//unreachable
									decrypted = decrypt_byte<key* __COUNTER__>(source, i);
									goto loc_unreachable_5;
								}
								else if (stack_x == stack_y + limit<key * __COUNTER__>() % 6 + 1) {
									//unreachable
									decrypted = decrypt_byte<key* __COUNTER__>(source, i);
									goto loc_unreachable_4;
								}
								else if (stack_x == stack_y + limit<key * __COUNTER__>() % 7 + 1) {
									//unreachable
									decrypted = decrypt_byte<key* __COUNTER__>(source, i);
									goto loc_unreachable_3;
								}
								else if (stack_x == stack_y + limit<key * __COUNTER__>() % 8 + 1) {
									//unreachable
									decrypted = decrypt_byte<key* __COUNTER__>(source, i);
									goto loc_unreachable_2;
								}
								else if (stack_x == stack_y + limit<key * __COUNTER__>() % 9 + 1) {
									//unreachable
									decrypted = decrypt_byte<key* __COUNTER__>(source, i);
									goto loc_unreachable_1;
								}
							loc_start_8:
								if (stack_y < limit<key * __COUNTER__>()) {
								loc_start_9:
									buffer[i] = decrypted;//assign
								}
								else {
									//unreachable
									decrypted = decrypt_byte<key* __COUNTER__>(source, i);
									decrypted += decrypted;
								loc_unreachable_1:
									buffer[i] = decrypt_byte<key* __COUNTER__>(source, i);
								loc_unreachable_2:
									stack_y++;
								loc_unreachable_3:
									i--;
								}
							}
							else {
								//unreachable
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								decrypted += buffer[i];
							loc_unreachable_4:
								buffer[i] = decrypt_byte<key* __COUNTER__>(source, i);
								buffer[i] += decrypted;
							loc_unreachable_5:
								stack_x += stack_y;
							loc_unreachable_6:
								i--;
								i -= decrypted;
							}
						}
						else {
							//unreachable
							decrypted = decrypt_byte<key* __COUNTER__>(source, i);
							decrypted -= buffer[i];
						loc_unreachable_7:
							buffer[i] = decrypt_byte<key* __COUNTER__>(source, i);
							stack_y++;
							i -= buffer[i];
							i -= stack_y;
						loc_unreachable_8:
							buffer[i] = decrypt_byte<key* __COUNTER__>(source, i);
							stack_x++;
							i--;
							i -= stack_x;
						loc_unreachable_9:
							i += buffer[i];
							i += stack_y;
							continue;
						}
					}
					else {
						//unreachable
						while (true) {
							if (stack_x == stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_1;
							}
							else if (stack_x == stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_2;
							}
							else if (stack_x == stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_3;
							}
							else if (stack_x == stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_4;
							}
							else if (stack_x == stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_5;
							}
							else if (stack_x == stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_6;
							}
							else if (stack_x == stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_7;
							}
							else if (stack_x == stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_8;
							}
							else if (stack_x == stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_9;
							}
							else if (stack_x == stack_y + limit<key * __COUNTER__>()) {
								continue;
							}
							else {
								stack_x = stack_y + limit<key* __COUNTER__>();
								stack_y = stack_x + limit<key* __COUNTER__>();
							}

							if (stack_x < stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_start_1;
							}
							else if (stack_x < stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_start_2;
							}
							else if (stack_x < stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_start_3;
							}
							else if (stack_x < stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_start_4;
							}
							else if (stack_x < stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_start_5;
							}
							else if (stack_x < stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_start_6;
							}
							else if (stack_x < stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_start_7;
							}
							else if (stack_x < stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_start_8;
							}
							else if (stack_x < stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_start_9;
							}
							else if (stack_x < stack_y + limit<key * __COUNTER__>()) {
								continue;
							}
							else {
								stack_x = stack_y + limit<key* __COUNTER__>();
								stack_y = stack_x + limit<key* __COUNTER__>();
							}

							if (stack_x > stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_9;
							}
							else if (stack_x > stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_8;
							}
							else if (stack_x > stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_7;
							}
							else if (stack_x > stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_6;
							}
							else if (stack_x > stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_5;
							}
							else if (stack_x > stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_4;
							}
							else if (stack_x > stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_3;
							}
							else if (stack_x > stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_2;
							}
							else if (stack_x > stack_y + limit<key * __COUNTER__>()) {
								decrypted = decrypt_byte<key* __COUNTER__>(source, i);
								goto loc_unreachable_1;
							}
							else if (stack_x > stack_y + limit<key * __COUNTER__>()) {
								continue;
							}
							else {
								stack_x = stack_y + limit<key* __COUNTER__>();
								stack_y = stack_x + limit<key* __COUNTER__>();
							}
						}
					}
				}
				else {
					//unreachable
					//Ooops, Decompilation failure:
					//401000: stack frame is too big
					return reinterpret_cast<return_type>(buffer + ((key * __COUNTER__) % 0x400000 + 0x1400000));
				}
			}
			else {
				//unreachable
				//Ooops, Decompilation failure:
				//401000: stack frame is too big
				return reinterpret_cast<return_type>(buffer + ((key * __COUNTER__) % 0x1400000 + 0x400000));
			}
		}

#else
		for (size_t i = 0; i < size; i++) {
			buffer[i] = decrypt_byte<key>(buffer[i], i);
		}
#endif // OXORANY_DISABLE_OBFUSCATION
		return reinterpret_cast<return_type>(buffer);
	}

	static OXORANY_FORCEINLINE constexpr size_t align(size_t n, size_t a) {
		return (n + a - 1) & ~(a - 1);
	}

	template<typename any_t, size_t ary_size, size_t counter>
	class oxor_any {

		static constexpr size_t size = align(ary_size * sizeof(any_t), 16)
			+ random_constant<counter^ base_key, (counter^ base_key) % 128>::value % (16 + 1);

		static constexpr size_t key = random_constant<counter^ base_key, (size^ base_key) % 128>::value;

		uint8_t buffer[size];

	public:

		template<size_t... indices>
		OXORANY_FORCEINLINE constexpr oxor_any(const any_t(&any)[ary_size], _lxy_::index_sequence<indices...>) :
			buffer{ encrypt_byte<key>(((uint8_t*)&any)[indices], indices)... } {
		}

		OXORANY_FORCEINLINE const any_t* get() { return decrypt<const any_t*, key>(buffer); }
	};

	template<typename any_t, size_t counter>
	class oxor_any<any_t, 0, counter> {

		static constexpr size_t size = align(sizeof(any_t), 16)
			+ random_constant<counter^ base_key, (counter^ base_key) % 128>::value % (16 + 1);

		static constexpr size_t key = random_constant<counter^ base_key, (size^ base_key) % 128>::value;

		uint8_t buffer[size];

	public:

		template<size_t... indices>
		OXORANY_FORCEINLINE constexpr oxor_any(any_t any, _lxy_::index_sequence<indices...>) :
			buffer{ encrypt_byte<key>(reinterpret_cast<uint8_t*>(&any)[indices], indices)... } {
		}

		OXORANY_FORCEINLINE const any_t get() { return *decrypt<const any_t*, key>(buffer); }
	};
}

#endif // OXORANY_H
```